Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i127:  lout - Lout document formatting system, v2, Part29/30
Message-ID: <1993Jun2.030700.29254@sparky.imd.sterling.com>
X-Md4-Signature: a20e64e80552f452a6303f81565af04c
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 2 Jun 1993 03:07:00 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 127
Archive-name: lout/part29
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/README lout/doc/tr.begin/s05 lout/doc/tr.begin/s06
#   lout/doc/tr.begin/s08 lout/doc/tr.begin/s09 lout/doc/tr.begin/s11
#   lout/doc/tr.begin/s12 lout/doc/tr.eq/s0 lout/doc/tr.eq/s1
#   lout/doc/tr.eq/setup lout/doc/tr.fig/s0 lout/doc/tr.fig/s1
#   lout/doc/tr.fig/s7 lout/doc/tr.fig/setup lout/doc/tr.impl/s1.0
#   lout/doc/tr.impl/s3.1 lout/doc/tr.impl/s3.4
#   lout/doc/tr.lout/ch0.00 lout/doc/tr.lout/ch2.03
#   lout/doc/tr.lout/ch3.06 lout/doc/tr.lout/ch3.08
#   lout/doc/tr.lout/ch3.10 lout/doc/tr.lout/ch3.11
#   lout/doc/tr.lout/ch3.13 lout/doc/tr.lout/ch3.16
#   lout/doc/tr.lout/ch3.21 lout/doc/tr.lout/ch3.22
#   lout/doc/tr.lout/ch3.24 lout/doc/tr.over/s0 lout/doc/tr.over/s6
#   lout/doc/tr.over/s7 lout/doc/tr.tab/s0 lout/doc/tr.tab/s1
#   lout/doc/tr.tab/s3 lout/doc/tr.tab/s5 lout/hyph.install
#   lout/include/ft
# Wrapped by kent@sparky on Sun May 30 19:44:02 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 29 (of 30)."'
if test -f 'lout/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/README'\"
else
  echo shar: Extracting \"'lout/README'\" \(2310 characters\)
  sed "s/^X//" >'lout/README' <<'END_OF_FILE'
XLOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)
XCOPYRIGHT (C) 1993 Jeffrey H. Kingston
X
XJeffrey H. Kingston
XBasser Department of Computer Science
XThe University of Sydney 2006
XAUSTRALIA
X
XTelephone (direct): 61 2 692 4216
XTelephone (messages): 61 2 692 3423
XEmail: jeff@cs.su.oz.au
XFax: 61 2 692 3838
X
XThis program is free software; you can redistribute it and/or modify
Xit under the terms of the GNU General Public License as published by
Xthe Free Software Foundation; either version 1, or (at your option)
Xany later version.
X
XThis program is distributed in the hope that it will be useful,
Xbut WITHOUT ANY WARRANTY; without even the implied warranty of
XMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
XGNU General Public License for more details.
X
XYou should have received a copy of the GNU General Public License
X(file gnu.gpl in this directory); if not, write to the Free Software
XFoundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XVersion 2.xx is not completely upward compatible with the original October
X1991 release.  The Lout base language semantics have changed slightly (some
Xobjects come out wider than they used to), but more importantly the standard
Xpackages DocumentLayout, ReportLayout, and BookLayout have been coalesced
Xinto one, and some changes made to some of the symbols.  This means that
Xmost setup files will need to be changed.  The more specialized packages
X(Tab, Eq, Fig, and Pas) are compatible with the old versions.  Apologies for
Xany inconvenience caused.
X
X
XThis directory contains everything needed to install the Lout document
Xformatting system on Unix.  It contains the following directories:
X
X    include        Lout packages (in Lout) and hyphenation patterns file
X    data           Lout databases (in Lout)
X    font0          Adobe Systems font metrics (.AFM) files (ASCII)
X    font1          Adobe Systems font metrics (.AFM) files (ISO-LATIN-1)
X    doc            Lout documents (in Lout)
X    man            Lout manual entry
X
Xand the following files:
X
X    externs z*.c   Lout source code
X    gnu.gpl        A copy of the GNU General Public License
X    hyph.install   Information about how to change the hyphenation patterns
X    makefile       A makefile for installing Lout
X
XPlease see the makefile for installation instructions.
END_OF_FILE
  if test 2310 -ne `wc -c <'lout/README'`; then
    echo shar: \"'lout/README'\" unpacked with wrong size!
  fi
  # end of 'lout/README'
fi
if test -f 'lout/doc/tr.begin/s05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s05'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s05'\" \(2789 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s05' <<'END_OF_FILE'
X@Section
X   @Tag { paras }
X   @Title { Paragraph breaking }
X@Begin
X@PP
XLout takes the words or other things making up a paragraph and fills
Xlines with them.  If two words are separated by one space in the input,
Xthey will be separated by one space in the output; two spaces in, two
Xspaces out, and so on.  The end of a line counts as one space, and a tab
Xcharacter as eight.  These spaces are then enlarged to remove ragged line ends.
X@PP
XThis process is called @I paragraph {@I breaking}, and the enlargement
Xof spaces is @I {line adjustment.}  The @Code "@Break" symbol, which is
Xmost commonly used with displays and list items, affects paragraph
Xbreaking:
X@ID @Code {
X"@IndentedDisplay ragged @Break {"
X"This little paragraph will appear with"
X"ragged ends to its lines."
X"}"
X}
Xhas result
X@IndentedDisplay 4c @Wide ragged @Break {
XThis little paragraph will appear with
Xragged ends to its lines.
X}
Xwhen placed in a four centimetre column; line adjustment is turned
Xoff.  Also available are @Code "cragged @Break" and {@Code "rragged @Break"},
Xwhich centre or right-justify each line respectively after breaking.
X@PP
XIt is also possible to have paragraphs broken in the output at the same
Xplaces they are broken in the input, using { @Code "lines @Break" }:
X@ID @Code {
X"@CenteredDisplay lines @Break @I {"
X"Teach me to hear Mermaides singing,"
X"Or to keep off envies stinging,"
X"     And finde"
X"     What winde"
X"Serves to'advance an honest minde."
X"}"
X}
Xhas result
X@CenteredDisplay lines @Break @I {
XTeach me to hear Mermaides singing,
XOr to keep off envies stinging,
X     And finde
X     What winde
XServes to'advance an honest minde.
X}
XWith @Code "lines @Break" it makes sense to indent individual lines in the
Xinput (except the first), as shown.  To centre or right-justify each line, use
X{@Code "clines @Break"} or {@PageMark clines} {@Code "rlines @Break"}.
X@PP
XThe usual method, where Lout fills and adjusts lines, is called
X{@Code "adjust @Break"}.  It has a variant called {@Code "outdent @Break"}
Xwhich inserts a small space at the beginning of each line except the first.
X@PP
XThe @Code "@Break" symbol also controls hyphenation:  @Code "hyphen"
X@Code "@Break" turns it on, @Code "nohyphen" @Code "@Break" turns it
Xoff.  For example, ragged breaking is often done without hyphenation,
Xlike this:
X@ID @Code {
X"@ID { ragged nohyphen } @Break {"
X"This little paragraph will appear with"
X"ragged ends to its lines."
X"}"
X}
XTo prevent hyphenation in the entire document, see Section
X{@NumberOf changes}.  To tell Lout where you would prefer a hyphen to be 
Xinserted (rarely necessary), use the @Code "&-" symbol:
X@ID @Code {
X"incent&-iv&-ate"
X}
XIf @Code "&-" occurs directly after a hyphen character, hyphenation will
Xbe permitted but no extra hyphen will be inserted.
X@End @Section
END_OF_FILE
  if test 2789 -ne `wc -c <'lout/doc/tr.begin/s05'`; then
    echo shar: \"'lout/doc/tr.begin/s05'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s05'
fi
if test -f 'lout/doc/tr.begin/s06' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s06'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s06'\" \(1009 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s06' <<'END_OF_FILE'
X@Section
X   @Tag { cnp }
X   @Title { Conditional new page }
X@Begin
X@PP
XOccasionally Lout will insert a page break directly following a heading,
Xand this looks very poor.  The solution is to precede the heading with
Xthe conditional new page symbol {@Code "@CNP"}, which checks whether
Xenough space is left in the page or column for a heading and at least
Xtwo lines of text.  If so, @Code "@CNP" does nothing; if not, @Code "@CNP"
Xcauses a new page or column to be begun, like {@Code "@NP"}.  The recommended
Xarrangement is
X@ID @Code {
X"end of previous part."
X"@DP"
X"@CNP"
X"@Heading { A Heading }"
X"@PP"
X"First paragraph of next part ..."
X}
XThe @Code "@CNP" symbol should be preceded by either @Code "@DP" or
X@Code "@LP", preferably {@Code "@DP"}, and this determines the amount of
Xspace when the @Code "@NP" action does not occur.  In most cases it will
Xbe better to use the @Code "@Section" symbol described below, which has
X@Code "@CNP" included in it, rather than using @Code "@CNP" directly.
X@End @Section
END_OF_FILE
  if test 1009 -ne `wc -c <'lout/doc/tr.begin/s06'`; then
    echo shar: \"'lout/doc/tr.begin/s06'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s06'
fi
if test -f 'lout/doc/tr.begin/s08' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s08'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s08'\" \(1142 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s08' <<'END_OF_FILE'
X@Section
X   @Tag { footnotes }
X   @Title { Footnotes, figures, and tables }
X@Begin
X@PP
XA footnote is created by typing
X@ID @Code "@FootNote { Like this. }"
Xafter the word that the footnote refers to.  It will be numbered
Xautomatically and placed at the foot of the page or column;
X@FootNote { Like this. }
Xor, if space there is insufficient, it may start on or run onto the
Xfollowing page or column.  Figures are created in a similar way:
X@ID @Code {
X"@Figure"
X"    @Caption { Basser Lout }"
X"@Fig {"
X"    @Box Lout &"
X"    @HArrow { 2c @Wide } &"
X"    @Box PostScript"
X"}"
X}
XThe @Code "@Figure" symbol places the figure (which in this example is
Xcreated using the Fig figure drawing package [{@Ref kingston92fig}]) at
Xthe top of the following column or page,
X@Figure
X    @Caption { Basser Lout }
X@Fig {
X    @Box Lout &
X    @HArrow { 2c @Wide } &
X    @Box PostScript
X}
Xlabelled by the @Code "@Caption" option and automatically numbered.  Unlike
Xfootnotes, figures will not break across several pages; each figure must
Xfit on one page.
X@PP
XTables are obtained in the same way using {@Code "@Table"} instead of
X{@Code "@Figure"}.
X@End @Section
END_OF_FILE
  if test 1142 -ne `wc -c <'lout/doc/tr.begin/s08'`; then
    echo shar: \"'lout/doc/tr.begin/s08'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s08'
fi
if test -f 'lout/doc/tr.begin/s09' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s09'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s09'\" \(1428 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s09' <<'END_OF_FILE'
X@Section
X   @Tag { cross }
X   @Title { Cross references }
X@Begin
X@PP
X@I {Cross references} like `see page {@PageOf cross}' are a useful feature of
Xdocuments, but they are troublesome to authors, since, as the document
Xis revised, the thing on page {@PageOf cross} might find itself on page
X{@PageOf reportlayout} and the cross reference must be changed.  Lout has
Xa simple solution to this problem:  instead of writing the page number
Xdirectly, write
X@ID @Code "see page {@PageOf taxinfo}"
Xinstead, and at the point referred to, write
X@ID @Code "Taxation {@PageMark taxinfo} ..."
X@Code "{@PageMark taxinfo}" will not appear in the output, but Lout makes
Xa note of the number of the page on which the word preceding it appears,
Xand inserts that number in place of {@Code "{@PageOf taxinfo}"}.  Any
Xsingle word may be used for the tag.
X@PP
XCross referencing also applies to sections, subsections, appendices,
Xsubappendices, figures, tables, and numbered displays, and can supply
Xboth the page on which the item begins and its number.  First, add a
X@Code "@Tag" option whose value is a single word:
X@ID @Code {
X"@Section"
X"     @Title { Cross references }"
X"     @Tag { cross }"
X"@Begin"
X"..."
X}
XThis marks the page on which the section begins, so @Code "{@PageOf cross}"
Xwill be {@PageOf cross} in this case.  In addition, @Code "{@NumberOf cross}"
Xwill be the number of the section, in this case {@NumberOf cross}.
X@End @Section
END_OF_FILE
  if test 1428 -ne `wc -c <'lout/doc/tr.begin/s09'`; then
    echo shar: \"'lout/doc/tr.begin/s09'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s09'
fi
if test -f 'lout/doc/tr.begin/s11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s11'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s11'\" \(953 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s11' <<'END_OF_FILE'
X@Section
X   @Tag { cols }
X   @Title { Multiple columns }
X@Begin
X@PP
XDocumentLayout normally produces pages with a single column of text occupying
Xthe full width.  To get multiple columns, enclose the document in
X@ID @Code {
X"@Doc @ColText @Begin"
X"..."
X"@End @ColText"
X}
XThis will ordinarily produce two columns per page, although we will see
Xin the next section how to produce three or more.
X@PP
XIt is possible to start off a document with single columns and switch to
Xmultiple columns later, using the following arrangement:
X@ID @Code {
X"@Doc @Text @Begin"
X"single column part"
X"@ColText @Begin"
X"multiple column part"
X"@End @ColText"
X"@End @Text"
X}
XThis is the most useful combination, because switching from multiple back to
Xsingle causes a new page to be begun, which generally looks poor.  Tables
Xand figures are always full width, but the width of footnotes depends on
Xwhether they occur within @Code "@Text" or {@Code "@ColText"}.
X@End @Section
END_OF_FILE
  if test 953 -ne `wc -c <'lout/doc/tr.begin/s11'`; then
    echo shar: \"'lout/doc/tr.begin/s11'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s11'
fi
if test -f 'lout/doc/tr.begin/s12' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s12'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s12'\" \(2068 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s12' <<'END_OF_FILE'
X@Section
X   @Tag { changes }
X   @Title { Changing the overall appearance }
X@Begin
X@PP
XA few aspects of the overall appearance of the document may be changed
Xby beginning with a @Code "@Document" symbol, as in the following
Xexample:
X@ID @Code {
X"@Document"
X"    @InitialFont { Times Base 12p }"
X"    @InitialBreak { adjust 1.2fx }"
X"    @Hyphenate { Yes }"
X"    @PageNumbers { Yes }"
X"    @FirstPageNumber { 1 }"
X"    @Columns { Double }"
X"//"
X"@Text @Begin"
X"..."
X"@End @Text"
X}
XThis shows the six options available with {@Code "@Document"}, and their
Xdefault values.
X@PP
X@Code "@InitialFont" and @Code "@InitialBreak" determine
Xthe overall font and paragraph breaking style; @Code "1.2fx" means that
Xthe inter-line spacing is to be 1.2 times the current font size, measured
Xfrom baseline to baseline.  To get double spacing, use {@Code "2.4fx"},
Xetc.  @Code "@Hyphenate" determines whether hyphenation is permitted or
Xnot, and may be @Code Yes or {@Code No}.
X@PP
X@Code "@PageNumbers" determines whether or not page numbers will be
Xprinted (but not their format), and also may be @Code Yes or {@Code No};
X@Code "@FirstPageNumber" is the number given to the first page; and
X@Code "@Columns" determines the number of columns that @Code "@ColText"
Xproduces, and may be {@Code Single}, {@Code Double}, or {@Code Multi},
Xthe last usually meaning triple.
X@PP
XSince there are default values for the options, it is only necessary to
Xmention those options that are to be changed.  For example, to produce a
Xdocument in Helvetica 10 point font with no page numbers, begin with
X@ID @Code {
X"@Document"
X"    @InitialFont { Helvetica Base 10p }"
X"    @PageNumbers { No }"
X"//"
X}
XDisaster will ensue if the @Code "//" symbol is forgotten.  The
X@Code "@Doc" symbol used previously is just an abbreviation for
X{@Code "@Document //"}.
X@PP
XOf course, these five options only scratch the surface of the possible
Xchanges that could be made.  Section {@NumberOf big.changes} explains
Xhow to make many other and more radical changes to the overall appearance
Xof the document.
X@End @Section
END_OF_FILE
  if test 2068 -ne `wc -c <'lout/doc/tr.begin/s12'`; then
    echo shar: \"'lout/doc/tr.begin/s12'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s12'
fi
if test -f 'lout/doc/tr.eq/s0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/s0'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/s0'\" \(909 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/s0' <<'END_OF_FILE'
X@Report
X   @Title { Eq -- A Lout Package for Typesetting Mathematics }
X   @Author { Jeffrey H. Kingston }
X   @Institution { Basser Department of Computer Science
XUniversity of Sydney 2006
XAustralia }
X   @DateLine { 22 December, 1992 }
X//
X
X@Abstract {
XThis report describes the use of Eq, a package of definitions for
Xtypesetting mathematics with the Lout document formatter.  For example,
X@ID @Code "@Eq { big int supp 1 on 0 ` dx over sqrt {1 - x sup 2} = pi over 2 }"
Xproduces the output
X@ID @Eq { big int supp 1 on 0 ` dx over sqrt {1 - x sup 2} = pi over 2 }
XThe advantages of Eq include careful attention to details of spacing, a
Xrepertoire of several hundred mathematical symbols, a simple syntax
Xextensible by the user, and complete integration with the rest of Lout.
X@PP
XIn addition, this report contains an appendix describing the use of Pas,
Xa package of definitions for printing Pascal programs.
X}
END_OF_FILE
  if test 909 -ne `wc -c <'lout/doc/tr.eq/s0'`; then
    echo shar: \"'lout/doc/tr.eq/s0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.eq/s0'
fi
if test -f 'lout/doc/tr.eq/s1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/s1'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/s1'\" \(1344 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/s1' <<'END_OF_FILE'
X@Section
X   @Title { Introduction }
X@Begin
X@PP
XEq is a package of definitions for typesetting mathematics with the Lout
Xdocument formatter [{@Ref kingston92}].  It includes several hundred
Xmathematical and other special characters (including the entire PostScript
X@FootNote { PostScript is a trademark of Adobe Systems, Incorporated. }
XSymbol font [{@Ref adobe90}]), and a smaller number of symbols for joining
Xobjects together in mathematical ways.  Eq is based on the eqn language
Xof Kernighan and Cherry [{@Ref kernighan75}], with
Xspacing rules similar to Knuth's @TeX formatter [{@Ref knuth84}].
X@PP
XTo use Eq in a Lout document, first ensure that its definition is
Xincluded, either by having @Code "@SysInclude { eq }"
Xin the setup file, or @Code "-ieq" on the command line.  Then, at any point
Xin the document, write @Code "@Eq  {  ...  }"
Xand the symbols of Eq will be available between the braces.  Any symbols
Xavailable outside continue to be available inside, which means that Eq
Xcan be freely mixed with standard Lout and with symbols from other
Xpackages, without restriction.
X@PP
XIn this report we show the Lout input at the left, and its
Xresult at the right:
X@ID {
X@Code "@Eq { {x sup 2 + y sup 2} over 2 }"
X|7ct
X@Eq { {x sup 2 + y sup 2} over 2 }
X}
XSubsequent examples will omit the enclosing {@Code "@Eq { ... }"}.
X@End @Section
END_OF_FILE
  if test 1344 -ne `wc -c <'lout/doc/tr.eq/s1'`; then
    echo shar: \"'lout/doc/tr.eq/s1'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.eq/s1'
fi
if test -f 'lout/doc/tr.eq/setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/setup'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/setup'\" \(1054 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/setup' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Lout setup file for Eq paper.                     #
X#                                                    #
X#  Jeffrey H. Kingston                               #
X#  8 June 1991                                       #
X#  22 December 1992                                  #
X#                                                    #
X######################################################
X
X@SysInclude { ft  }
X@SysInclude { dl  }
X@SysInclude { tab }
X@SysInclude { eq  }
X@SysInclude { pas }
X@SysInclude { fig }
X
X   def @TeX { T{ /0.2fo E}X }
X
X   def @Code
X      right x
X   { { Helvetica Base -1p } @Font lines @Break x
X   }
X
X   import @Eq
X   def epi { p sub i ` log sub 2 ` p sub i }
X
X   import @Eq
X   def ep right x { p sub x ` log sub 2 ` p sub x }
X
X   def @Dbl left x right y
X   { 1.95i @Wide
X     { 1.2i @Wide { |1rt @Code x } |0.2i @Eq {non y} }
X   }
X
X@Use { @DocumentLayout
X  @AppendixGap { 1.10b }
X}
X
X@SysDatabase @Reference { "loutrefs"  }
END_OF_FILE
  if test 1054 -ne `wc -c <'lout/doc/tr.eq/setup'`; then
    echo shar: \"'lout/doc/tr.eq/setup'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.eq/setup'
fi
if test -f 'lout/doc/tr.fig/s0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.fig/s0'\"
else
  echo shar: Extracting \"'lout/doc/tr.fig/s0'\" \(1153 characters\)
  sed "s/^X//" >'lout/doc/tr.fig/s0' <<'END_OF_FILE'
X@Report
X   @Title { Fig -- A Lout Package for Drawing Figures }
X   @Author { Jeffrey H. Kingston }
X   @Institution { Basser Department of Computer Science
XThe University of Sydney 2006
XAustralia }
X   @DateLine { 22 December, 1992 }
X//
X
X@Abstract @Begin
XThis report describes the use of Fig, a package of definitions
Xfor use with the Lout document formatter.  Fig draws, colours, and
Xpositions arbitrary shapes made from straight lines, circular and
Xelliptical arcs, and Bezier curves:
X@CD @Fig
X    margin { 0.2c }
X{
X@Frame -2p @Font
X{ A:: @Ellipse { 25, 39 }
X/0.3c |0.2c B:: @Ellipse { 43 } |0.1c |0.8c E:: @Box linestyle {noline} {Problem node}
X/0.3c C:: @Ellipse { 40, 41 } | | D:: @Ellipse paint { light } {44, 45, 46}
X}
X// @Line from { A@SE } to { B@NW }
X// @Line from { B@SW } to { C@NE }
X// @Line from { B@SE } to { D@NW }
X// @Arrow from { E@W } to { D@NE }
X}
XThe graphical objects may be rotated and scaled; they may enclose, and
Xbe enclosed by arbitrary Lout objects (text, equations, tables, other
Xgraphical objects, etc.) without restriction.  A convenient algebra of
Xpoints and a method of labelling points assist positioning.
X@End @Abstract
END_OF_FILE
  if test 1153 -ne `wc -c <'lout/doc/tr.fig/s0'`; then
    echo shar: \"'lout/doc/tr.fig/s0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.fig/s0'
fi
if test -f 'lout/doc/tr.fig/s1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.fig/s1'\"
else
  echo shar: Extracting \"'lout/doc/tr.fig/s1'\" \(1445 characters\)
  sed "s/^X//" >'lout/doc/tr.fig/s1' <<'END_OF_FILE'
X@Section
X   @Title { Introduction }
X@Begin
X@PP
XFig is a package of Lout definitions for drawing and filling in
Xarbitrary shapes made from straight lines, circular and elliptical arcs,
Xand Bezier curves.  Its features are smoothly integrated with the rest
Xof Lout: one can rotate and concatenate objects created by Fig, draw a
Xbox to fit neatly around any object, etc.  The design of Fig is based
Xentirely on Brian W. Kernighan's PIC language [{@Ref kernighan82}].  The
Ximplementation of Fig makes good use of the PostScript
X@FootNote { PostScript is a trademark of Adobe Systems, Inc. }
Xpage description language [{@Ref adobe90}], which was designed by John
XWarnock and others.  Lout was designed and implemented by Jeffrey
XH. Kingston [{@Ref kingston92}].
X@PP
XTo use Fig within a Lout document, first ensure that its definition is
Xincluded, either by putting @Code "@SysInclude { fig }" at the start of
Xthe document, or @Code "-ifig" on the command line.  Then, anywhere at
Xall within the document, write
X@ID @Code "@Fig {  ...  }"
Xand the symbols of Fig will be available
Xbetween the braces, which may enclose an arbitrary Lout object.  Throughout
Xthis report we will show the Lout text on the left and the corresponding
Xresult on the right, like this:
X@ID {
X@Code {
X"@Fig {"
X"   @Square"
X"   //0.5c"
X"   @Circle"
X"}"
X}
X||7ct
X@Fig {
X   @Square
X   //0.5c
X   @Circle
X}
X}
XSubsequent examples will omit the enclosing {@Code "@Fig"}.
X@End @Section
END_OF_FILE
  if test 1445 -ne `wc -c <'lout/doc/tr.fig/s1'`; then
    echo shar: \"'lout/doc/tr.fig/s1'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.fig/s1'
fi
if test -f 'lout/doc/tr.fig/s7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.fig/s7'\"
else
  echo shar: Extracting \"'lout/doc/tr.fig/s7'\" \(1067 characters\)
  sed "s/^X//" >'lout/doc/tr.fig/s7' <<'END_OF_FILE'
X@Section
X   @Title { Errors }
X@Begin
X@PP
XLout normally produces an output file that will print without mishap on
Xany PostScript device.  However, some of the options of Fig's symbols
Xare passed through Lout to the output file without checking, including
Xanything containing Fig lengths, angles, points, and labels.  Any errors
Xin these options will not be detected until the file is printed.
X@PP
XThe most likely errors are {@I syntax @I errors}, as in
X@Code "shape { 0 0 [ 0 xsize }" for example, in which a @Code "]" is
Xmissing; {@I type @I errors}, as in @Code "0 0 @Distance 45" where the
Xright parameter is not a point; and {@I undefined @I errors}, arising
Xfrom labels misspelt or used before being defined.  Less commonly, the
Xoptions may all be correct but the figure is too large in some way:  too
Xmany labels, too deeply nested, etc.
X@PP
XWhen an error is detected, Fig arranges for the offending page to
Xbe printed up to the point where the error occurred, with a message
Xnearby describing the error.  Printing of the document is then aborted.
X@End @Section
END_OF_FILE
  if test 1067 -ne `wc -c <'lout/doc/tr.fig/s7'`; then
    echo shar: \"'lout/doc/tr.fig/s7'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.fig/s7'
fi
if test -f 'lout/doc/tr.fig/setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.fig/setup'\"
else
  echo shar: Extracting \"'lout/doc/tr.fig/setup'\" \(1718 characters\)
  sed "s/^X//" >'lout/doc/tr.fig/setup' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Lout setup file for producing the Fig report.     #
X#                                                    #
X#  Jeffrey H. Kingston                               #
X#  8 June 1991                                       #
X#  22 December 1992                                  #
X#                                                    #
X######################################################
X
X@SysInclude { ft  }
X@SysInclude { dl  }
X@SysInclude { tab }
X@SysInclude { eq  }
X@SysInclude { fig }
X
X   def @Code
X      right x
X   { { Helvetica Base -1p } @Font lines @Break x
X   }
X
X   import @Fig
X   def @JoinFigures
X      left A
X      named linestyle { solid }
X      named dashlength { 0.15 cm }
X      named arrow { noarrow }
X      named linewidth { 0.5 pt }
X      right B
X   {  @Arrow
X	 from { A"@CTR" ++ {{A"@CTR" @Angle B"@CTR"} A@CIRCUM} }
X	 to   { B"@CTR" ++ {{B"@CTR" @Angle A"@CTR"} B@CIRCUM} }
X         linestyle { linestyle }
X         dashlength { dashlength }
X         arrow { arrow }
X         linewidth { linewidth }
X      {}
X   }
X
X   def @ShowMarks
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @Fig
X      {   @Box margin { 0c } linewidth { linewidth } paint { paint }
X	  {   @Figure
X		 shape { -0.3 cm ymark
X			 {xsize ymark} ++ {0.3 cm 0}  []
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	      x
X	  }
X
X      }
X   }
X
X@Use { @DocumentLayout }
X
X@SysDatabase @Reference { "loutrefs"  }
END_OF_FILE
  if test 1718 -ne `wc -c <'lout/doc/tr.fig/setup'`; then
    echo shar: \"'lout/doc/tr.fig/setup'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.fig/setup'
fi
if test -f 'lout/doc/tr.impl/s1.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s1.0'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s1.0'\" \(2523 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s1.0' <<'END_OF_FILE'
X@Section
X    @Title { Introduction }
X@Begin
X@PP
XLout [1, 2] is a high-level language
Xfor document formatting, designed and implemented by the author.  The
Ximplementation, known as Basser Lout, is a fully operational production
Xversion written in C for the Unix operating system,
X@FootNote { Unix is a trademark of "AT&T" Bell Laboratories. }
Xwhich translates Lout source code into PostScript,
X@FootNote { PostScript is a trademark of Adobe Systems, Incorporated. }
Xa device-independent graphics rendering language accepted by many
Xhigh-resolution output devices, including most laser printers.  Basser
XLout is available free of charge [3].  It includes
Xinstallation instructions, C source, seven standard packages, and complete
Xdocumentation in the form of six technical reports and a manual page.
X@PP
XThe Lout project arose out of the author's desire to bring to document
Xformatting languages the elegance of expression found in programming
Xlanguages like Algol-60 and Pascal.  This emphasis on expressiveness
Xhas produced an order of magnitude reduction in the cost of developing
Xdocument formatting applications.  For example, an equation formatting
Xapplication, which may be difficult or impossible to add to other
Xsystems, can be written in Lout in a few days.
X@PP
XWhen expert users can implement such applications quickly, non-experts
Xbenefit.  Although Lout itself provides only a small kernel of carefully
Xchosen primitives, packages written in Lout and distributed with Basser
XLout provide an unprecedented array of advanced features in a form
Xaccessible to non-expert users.  The features include rotation and scaling,
Xfonts, paragraph and page breaking, displays and lists, floating figures
Xand tables, footnotes, chapters and sections (automatically numbered),
Xrunning page headers and footers, odd-even page layouts, automatically
Xgenerated tables of contents, sorted indexes and reference lists,
Xbibliographic and other databases (including databases of formats for
Xprinting references), equations, tables, diagrams, formatting of
XPascal programs, and automatically maintained cross references.
X@PP
XThis paper charts the evolution of Lout from conception in mid-1984 to the
Xpublic release of Basser Lout in October 1991.  Lout is organized around
Xfour key concepts -- objects, definitions, galleys, and cross references --
Xand they were developed in the order listed, so this paper will treat each
Xin turn, discussing its design, implementation, problems, and
Xprospects for further improvement.
X@End @Section
END_OF_FILE
  if test 2523 -ne `wc -c <'lout/doc/tr.impl/s1.0'`; then
    echo shar: \"'lout/doc/tr.impl/s1.0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s1.0'
fi
if test -f 'lout/doc/tr.impl/s3.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s3.1'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s3.1'\" \(2778 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s3.1' <<'END_OF_FILE'
X@SubSection
X    @Tag { operators }
X    @Title { Operators }
X@Begin
X@PP
XIt is evident from the example of Eqn that user-defined operators are
Xneeded that mimic the primitive ones in taking objects as parameters
Xand returning objects as results.  For example, to define a superscript
Xoperator so that
X@ID @Code "2 sup n"
Xappears as {@Eq {2 sup @R n}}, the following operator definition may
Xbe used:
X@ID @Code {
X"def sup"
X"    precedence 50"
X"    associativity right"
X"    left x"
X"    right y"
X"{"
X"    @OneRow {  |  {-2p @Font y}  ^/0.5fk  x  }"
X"}"
X}
XThe @Code "sup" operator has precedence 50, is right associative, takes
Xtwo objects as parameters passed on the left and right, and returns the
Xobject between braces as result.  This object has the structure
X@ID @I +2p @Font {
X| @ShowMarks @Code y / @ShowMarks @Code x
X}
Xbut with the first row mark hidden by the @Code "@OneRow" operator,
Xand @Code y two points smaller than it would otherwise have been.  The
Xlength @Code "0.5f" specifies half the current font size;  Figure
X{@NumberOf gapmodes} describes the @Code k gap mode.  In the Eq equation
Xformatting package [10] the equation as a whole is
Xset in italic font, and @Code 2 is an identifier whose body contains
Xa font change back to Roman.  The digits @Code 0 to @Code 9 are classed
Xas punctuation characters, permitting @Code 234 for example to be
Xinterpreted as a sequence of three identifiers.
X@PP
XThese definitions are easily implemented by a standard symbol table
Xand an operator precedence parser.  Algol block structure with the
Xusual scope rules was adopted as a matter of course.
X@PP
XOperators are limited to at most two parameters, left and
Xright, and the parameters cannot be given default values.  @I Named
Xparameters solve both problems:
X@ID @Code {
X"def @Preface"
X"    named @Tag {}"
X"    named @Title { Preface }"
X"    right @Body"
X"{"
X"    Bold @Font @Title"
X"    //0.3v  @Body"
X"}"
X}
XThe default value appears just after the parameter's declaration,
Xbetween braces.  Invocations have a natural syntax:
X@ID @Code {
X"@Preface"
X"    @Title { About this book }"
X"{"
X"    Few observers would have supposed in 1984, that ..."
X"}"
X}
Xwith the actual named parameters following directly after the
Xoperator, before any right parameter.  In this example, @Code "@Tag"
Xwill receive its default value, and a less expert user could safely
Xomit the @Code "@Title" parameter as well.
X@PP
XLout permits named parameters to have parameters, a feature with
Xapplications to bibliographic databases, running headers, and other
Xplaces where a format has to be supplied before content is
Xknown.  One could go further and provide a complete lambda calculus,
Xwith functions as first-class objects, provided care was taken not
Xto intimidate the non-expert user.
X@End @SubSection
END_OF_FILE
  if test 2778 -ne `wc -c <'lout/doc/tr.impl/s3.1'`; then
    echo shar: \"'lout/doc/tr.impl/s3.1'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s3.1'
fi
if test -f 'lout/doc/tr.impl/s3.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s3.4'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s3.4'\" \(2778 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s3.4' <<'END_OF_FILE'
X@SubSection
X    @Tag { defs.impl }
X    @Title { Implementation of definitions }
X@Begin
X@PP
XInput is processed by a hybrid parser which employs operator precedence
Xfor objects and simple recursive descent for the headers of
Xdefinitions.  A symbol table stores the body of each definition as a
Xparse tree, except for macros which are lists of tokens, and manages the
Xusual stack of static scopes, accepting @I PushScope and @I PopScope
Xoperations as the parser enters and leaves scope regions, including
Xactual body parameters and the right parameter of the @Code "@Open"
Xoperator.
X@PP
XAs the parse proceeds, a complete call graph is constructed, recording,
Xfor each symbol, which symbols are invoked within its body.  Immediately
Xafter the last definition is read, the transitive closure of the call
Xgraph is computed, and used to determine whether each non-parameter
Xsymbol is recursive or receptive (Section {@NumberOf galleys}), and
Xwhether each parameter is invoked exactly once or not.
X@PP
XPurely functional systems may evaluate symbol invocations in applicative
Xorder (where parameters are evaluated before substitution into bodies),
Xor in normal order (substitution before evaluation), and they may also
Xshare the value of a parameter among all uses of it.  But in Basser
XLout, the presence of context-sensitive style information (Section
X{@NumberOf style}) forces normal order evaluation and prevents sharing
Xof parameter values.
X@PP
XTo evaluate an unsized object (pure parse tree), its {@I environment},
Xthe equivalent of the stack frames in Algol-like languages, must be
Xavailable, containing the actual values of all formal parameters
Xthat are visible within the unsized object.  Environment handling is
Xa well-known implementation technique, so it will be discussed
Xonly briefly here.
X@PP
XEnvironments are extra subtrees hung from the objects they refer
Xto.  This organization makes excellent use of the ordered dag to
Xpermit environments to be shared, and deleted when the last
Xreference to them is removed.  Several optimizations have been
Ximplemented.  Actual parameters known to be invoked only once are moved
Xin from the environment, not copied; copying could lead to quadratic time
Xcomplexity.  Actual parameters of the form @Code "@Next" @I object
Xreceive an applicative pre-evaluation which prevents long chains of
X@Code "@Next" symbols from forming during the generation of large page
Xnumbers.  Some environments which provably contribute nothing are
Xdeleted, most notably when a symbol invocation has no symbols within its
Xactual parameters and no import list, so that only the environment of its
Xbody need be kept; this saves a great deal of space when objects with
Xenvironments are written to auxiliary files (Section {@NumberOf cross}).
X@End @SubSection
END_OF_FILE
  if test 2778 -ne `wc -c <'lout/doc/tr.impl/s3.4'`; then
    echo shar: \"'lout/doc/tr.impl/s3.4'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s3.4'
fi
if test -f 'lout/doc/tr.lout/ch0.00' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch0.00'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch0.00'\" \(2371 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch0.00' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Start main document off                           #
X#                                                    #
X######################################################
X
X@Book
X   @Title { Document Formatting
X
Xwith Lout }
X   @Author { JEFFREY H. KINGSTON }
X   @Edition { SECOND EDITION
X
X23 April, 1993}
X   @Publisher { @I { @CopyRight Copyright 1991 and 1993, Jeffrey H. Kingston,
XBasser Department of Computer Science, The University
Xof Sydney 2006, Australia.} }
X//
X
X@Preface
X   @Tag { preface }
X@Begin
X@LP
X@IndexBlanks
XThis manual is addressed to those who wish to become
Xexpert users of the document formatting language Lout.  An expert user
Xis someone who understands the principles of document formatting
Xthat Lout embodies, and is able to apply them, for example to design
Xa document format or a special-purpose package.  In contrast, a non-expert
Xuser is someone who simply uses Lout to format documents.
X@PP
XChapter {@NumberOf principles} explains these principles, and it
Xshould be read carefully and in sequence.  Chapters {@NumberOf details}
Xand {@NumberOf symbols} are for reference; respectively, they
Xcontain descriptions of the detailed operation of Lout's major
Xcomponents, and a complete description of each predefined symbol.  The
Xfinal chapter presents a collection of advanced examples.
X@PP
XThis manual presents Version 2 of Basser Lout, as released in April 1993
X[{@Ref kingston93basser}].  Those familiar with Version 1 will notice
Xmany enhancements, including PostScript
X@FootNote { PostScript is a trademark of Adobe Systems, Inc. }
XEPS file inclusion, optimal paragraph breaking, automatic hyphenation,
Xand ligatures.
X@PP
XThis manual was printed on an Apple LaserWriter
Xapple.laserwriter @Index { Apple LaserWriter }
X@FootNote { Apple and LaserWriter are trademarks of Apple Computer, Inc. }
Xlaser printer from a PostScript
Xpostscript @Index { PostScript }
Xfile generated by Version 2 of the Basser Lout interpreter, using the
XDocumentLayout package [{@Ref kingston92begin}].
X@DP
X@Heading { Acknowledgment. }  Version 2 has benefited from hundreds of
Xcomments received since the release of Version 1 in October 1991.  Not
Xevery suggestion could be followed, but many have been, and the
Xencouragement was greatly appreciated.
X@End @Preface
END_OF_FILE
  if test 2371 -ne `wc -c <'lout/doc/tr.lout/ch0.00'`; then
    echo shar: \"'lout/doc/tr.lout/ch0.00'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch0.00'
fi
if test -f 'lout/doc/tr.lout/ch2.03' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch2.03'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch2.03'\" \(2556 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch2.03' <<'END_OF_FILE'
X@Section
X  @Tag { named }
X  @Title { Named parameters }
X@Begin
X@PP
XIn addition to left and right (or body) parameters, a symbol may have
Xany number of {@I {named parameters}}:
Xparameter.named @SubIndex { @Code named parameter }
Xnamed.par @Index { @Code named parameter }
X@ID @Code  {
X"def @Chapter"
X"    named @Tag {}"
X"    named @Title {}"
X"    right x"
X"{"
X"    ..."
X"}"
X}
XTheir definitions appear in between those of any left and right
Xparameters, and each is followed by a @I {default value} between
Xdefault @Index { Default value of parameter }
Xbraces.  When @Code "@Chapter" is invoked, its named parameters are
Xgiven values in the following way:
X@ID @Code  {
X"@Chapter"
X"    @Tag { intro }"
X"    @Title { Introduction }"
X"{"
X"    ..."
X"}"
X}
XThat is, a list of named parameters appears immediately following the
Xsymbol, each with its value enclosed in braces.  Any right parameter
Xfollows after them.  They do not have to appear in the order they were
Xdefined, and they can even be omitted altogether, in which case the
Xdefault value from the definition is used instead.
X@PP
XA named @Code "@Tag" parameter
Xtag.par @Index { @Code "@Tag" parameter, default value of }
Xdoes not take its default value from the definition; instead, if a default
Xvalue is needed, Lout invents a simple word which differs from every other
Xtag.  This is important, for example, in the production of numbered
Xchapters and sections (Section {@NumberOf chapters}).
X@PP
XNamed parameters may have parameters, {@PageMark strange} as in the
Xfollowing definition:
X@ID @Code {
X"def @Strange"
X"    named @Format right @Val { [@Val] }"
X"    right x"
X"{"
X"    @Format x"
X"}"
X}
XThe named parameter @Code "@Format" has right parameter {@Code "@Val"},
Xand the default value of @Code "@Format" is this parameter enclosed in
Xbrackets.  When @Code "@Format" is invoked it must be supplied with
Xa right parameter, which will replace {@Code "@Val"}.  Thus,
X@ID @Code {
X"@Strange 27"
X}
Xequals @Code "@Format 27" and so has result
X@ID {
X@Strange 27
X}
XThe @Code "@Format" symbol is like a definition with parameters whose
Xbody can be changed:
X@ID @Code {
X"@Strange"
X"    @Format { Slope @Font @Val. }"
X"27"
X}
Xstill equals {@Code "@Format 27"}, but this time the result is
X@ID {
X@Strange
X    @Format { Slope @Font @Val. }
X27
X}
XIn practice, examples of named parameters with parameters all have this
Xflavour of format being separated from content; running headers (Section
X{@NumberOf pagelayout}) and printing styles for bibliographies
X(Section {@NumberOf biblio}) are two major ones.
X@End @Section
END_OF_FILE
  if test 2556 -ne `wc -c <'lout/doc/tr.lout/ch2.03'`; then
    echo shar: \"'lout/doc/tr.lout/ch2.03'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch2.03'
fi
if test -f 'lout/doc/tr.lout/ch3.06' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.06'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.06'\" \(1114 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.06' <<'END_OF_FILE'
X@Section
X   @Title { "@OneCol" and "@OneRow" }
X   @Tag { onerow }
X@Begin
X@PP
XThe @@OneRow symbol
Xonerow.sym @Index { @@OneRow symbol }
Xprincipal.mark.effect @SubIndex { effect on @@OneCol and @@OneRow }
Xreturns its right parameter modified so that only the principal row mark
Xprotrudes.  This is normally the first row mark, but another one may be
Xchosen by preceding it with @Code "^/" or {@Code "^//"}.  For example,
X@ID @Code {
X"@OneRow {  |0.5rt  Slope @Font x + 2  ^//1p  @HLine  //1p  |0.5rt  5 }"
X}
Xhas result
X@LP
X@ID {
X@ShowMarks
X@OneRow { |0.5rt Slope @Font x + 2 ^//1p @HLine //1p |0.5rt 5 }
X}
X@LP
Xwith one row mark protruding from the bar as shown.  Compare this with
X@ID @Code {
X"@OneRow {  |0.5rt  Slope @Font x + 2  //1p  @HLine  //1p  |0.5rt  5 }"
X}
Xwhere the mark protrudes from the numerator:
X@LP
X@ID {
X@ShowMarks
X@OneRow { |0.5rt Slope @Font x + 2 //1p @HLine //1p |0.5rt 5 }
X}
X@PP
Xonecol.sym @Index { @@OneCol symbol }
X@@OneCol has the same effect on columns as @@OneRow does on rows, with
Xthe symbols @Code "^|" and @Code "^||" (or {@Code "^&"}) determining
Xwhich mark is chosen.
X@End @Section
END_OF_FILE
  if test 1114 -ne `wc -c <'lout/doc/tr.lout/ch3.06'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.06'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.06'
fi
if test -f 'lout/doc/tr.lout/ch3.08' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.08'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.08'\" \(1138 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.08' <<'END_OF_FILE'
X@Section
X   @Title { "@HExpand" and "@VExpand" }
X   @Tag { hexpand }
X@Begin
X@PP
Xhexpand @Index { @@HExpand symbol }
Xvexpand @Index { @@VExpand symbol }
Xexpansion @Index { Expansion of object }
XThe @@HExpand symbol causes its right parameter to be as wide as it
Xpossibly could be without violating a @@Wide symbol or intruding into
Xthe space occupied by neighbouring gaps or objects.  The @@VExpand
Xsymbol is similar, but it affects height.  For example, in the object
X@ID @Code {
X"8i @Wide 11i @High {"
X"    //1i  ||1i @HExpand @VExpand x ||1i"
X"    //1i"
X"}"
X}
Xobject @Code x could have any size up to six inches wide by nine inches
Xhigh, so the @@HExpand and @@VExpand symbols cause it to have exactly
Xthis size.  This is important, for example, if @Code x contains
X@Code "|1rt" or {@Code "/1rt"}; without the expansion these might not
Xmove as far across or down as expected.
X@PP
XAs Section {@NumberOf size} explains in detail, most objects are
Xalready as large as they possibly could be.  Consequently these symbols
Xare needed only rarely.  @@HExpand includes a @@OneCol effect, and
X@@VExpand includes a @@OneRow effect.
X@End @Section
END_OF_FILE
  if test 1138 -ne `wc -c <'lout/doc/tr.lout/ch3.08'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.08'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.08'
fi
if test -f 'lout/doc/tr.lout/ch3.10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.10'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.10'\" \(1288 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.10' <<'END_OF_FILE'
X@Section
X   @Title { "@HAdjust", "@VAdjust", and "@PAdjust" }
X   @Tag { hadjust }
X@Begin
X@PP
Xpadjust @Index { @@PAdjust symbol }
Xhadjust @Index { @@HAdjust symbol }
Xvadjust @Index { @@VAdjust symbol }
Xadjustment @Index { Adjustment of object }
XThese symbols spread their right parameter apart until it occupies
Xall the space available to it;  @@HAdjust adjusts @Code "|" sequences,
X@@VAdjust adjusts @Code "/" sequences, and @@PAdjust adjusts @Code "&"
Xsequences.  For example,
X@ID @Code {
X"4i @Wide @PAdjust { 1 2 3 4 5 6 7 8 }"
X}
Xhas result
X@ID {
X4i @Wide @PAdjust { 1 2 3 4 5 6 7 8 }
X}
XMore precisely, the widening is effected by enlarging the size of each
Xcomponent except the last by an equal fraction of the space that would
Xotherwise be left over -- just the opposite of the usual procedure,
Xwhich assigns all the leftover space to the last component (Section
X{@NumberOf size}).
X@PP
X@@PAdjust is used by the @Code adjust and @Code outdent options of
Xthe @@Break symbol (Section {@NumberOf break}).  It has a slight
Xpeculiarity:  it will not enlarge components when the immediately
Xfollowing gap has width 0.  This is to prevent space from appearing
X(for example) between a word and an immediately following comma.  The
Xother two symbols will enlarge such components.
X@End @Section
END_OF_FILE
  if test 1288 -ne `wc -c <'lout/doc/tr.lout/ch3.10'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.10'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.10'
fi
if test -f 'lout/doc/tr.lout/ch3.11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.11'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.11'\" \(999 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.11' <<'END_OF_FILE'
X@Section
X   @Title { "@HScale" and "@VScale" }
X   @Tag { hscale }
X@Begin
X@PP
Xhscale @Index { @@HScale symbol }
Xvscale @Index { @@VScale symbol }
Xscaling @Index { Scaling of object }
X@@HScale causes its right parameter to expand to fill the space available,
Xby geometricallly scaling it:
X@ID @Code {
X"4i @Wide @HScale { 1 2 3 4 5 6 7 8 }"
X}
Xhas result
X@ID {
X4i @Wide @HScale { 1 2 3 4 5 6 7 8 }
X}
Xand
X@ID @Code {
X"0.5i @Wide @HScale { 1 2 3 4 5 6 7 8 }"
X}
Xhas result
X@ID {
X0.5i @Wide @HScale { 1 2 3 4 5 6 7 8 }
X}
X@@HScale first applies @@HContract to its parameter, then horizontally
Xscales it to the actual size.  The principal mark of the right parameter
Xhas no effect on the result; the parameter is scaled to the actual size
Xand positioned to fill the space available.  (Taking account of alignment
Xof the principal mark only causes trouble in practice.)
X@PP
X@@VScale is similar, but in a vertical direction.  @@HScale and @@VScale
Xeach have both a @@OneCol and a @@OneRow effect.
X@End @Section
END_OF_FILE
  if test 999 -ne `wc -c <'lout/doc/tr.lout/ch3.11'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.11'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.11'
fi
if test -f 'lout/doc/tr.lout/ch3.13' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.13'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.13'\" \(1552 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.13' <<'END_OF_FILE'
X@Section
X   @Title { "@Rotate" }
X   @Tag { rotate }
X@Begin
X@PP
Xrotate.sym @Index { @@Rotate symbol }
Xrotation @Index { Rotation of object }
XThe symbol @@Rotate will rotate its
Xright parameter counterclockwise an amount given in degrees (positive or
Xnegative) by its left parameter.  For example,
X@ID @Code {
X"30d  @Rotate  { hello, world }"
X}
Xhas result
X@ID {
X30d  @Rotate  { hello, world }
X}
XBefore rotating the object, @@OneCol and @@OneRow are applied to it.  The
Xresult is a rectangle whose marks pass through the point where the
Xoriginal marks crossed:
X@ID {
X   @ShowMarks
X   { 0.6c @Wide 0.3c @High ^| 2.2c @Wide ^/ 0.2c @High }
X
X&4m => &4m
X
X   @ShowMarks
X   {
X	30d @Rotate
X	{	@ShowMarks
X		{ 0.6c @Wide 0.3c @High ^| 2.2c @Wide ^/ 0.2c @High }
X	}
X   }
X}
XAs this example shows, rotation by an angle other than a multiple of
Xninety degrees introduces quite a lot of white space.  So, for example, the
Xresult of
X@ID {
X@Code { "-30d" "@Rotate" 30d "@Rotate" }  @I object
X}
Xis a much larger object than {@I object}, despite the fact that one
Xrotation cancels the other.
X@PP
XRotation of objects containing receptive and recursive symbols is
Xpermitted, but for angles other than multiples of ninety degrees it is
Xbest to make the size of the rotated object clear with @@Wide and
X@@High symbols:
X@ID @Code {
X"30d @Rotate 5i @Wide 4i @High"
X"{   //1i @TextPlace"
X"    //1i"
X"}"
X}
XThis is because for angles other than multiples of ninety degrees the
Xspace available for @Code "@TextPlace" to occupy is indeterminate, and
Xthe result is poor.
X@End @Section
END_OF_FILE
  if test 1552 -ne `wc -c <'lout/doc/tr.lout/ch3.13'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.13'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.13'
fi
if test -f 'lout/doc/tr.lout/ch3.16' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.16'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.16'\" \(1705 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.16' <<'END_OF_FILE'
X@Section
X   @Title { "@Moment" }
X   @Tag { moment }
X@Begin
X@PP
XThe predefined symbol @@Moment
Xmoment.sym @Index { @@Moment symbol }
Xhas the following definition:
X@ID @Code {
X"def @Moment"
X"   named @Tag {}"
X"   named @Second {}"
X"   named @Minute {}"
X"   named @Hour {}"
X"   named @Day {}"
X"   named @Month {}"
X"   named @Year {}"
X"   named @Century {}"
X"   named @WeekDay {}"
X"   named @YearDay {}"
X"   named @DaylightSaving {}"
X"{}"
X}
XIt may be used like any other symbol.  Lout provides an invocation of
X@@Moment with tag {@Code now}, whose other parameters are numbers
Xencoding the current date and time:
X@ID {
X@JP @Code "@Second"  |0.5i the current second, between 0 and 59
X@JP @Code "@Minute"  | the current minute, between 0 and 59
X@JP @Code "@Hour"    | the current hour, between 0 and 23
X@JP @Code "@Day"     | the current day of the month, between 1 and 31
X@JP @Code "@Month"   | the current month, between 1 (January) and 12 (December)
X@JP @Code "@Year"    | the current year of the century, between 00 and 99
X@JP @Code "@Century" | the current century, e.g. 19 or 20
X@JP @Code "@WeekDay" | the current day of the week, between 1 (Sunday) and 7 (Saturday)
X@JP @Code "@YearDay" | the current day of the year, between 0 and 365
X@JP @Code "@DaylightSaving" | an implementation-dependent number that
Xmay encode the daylight saving currently in effect
X}
Xdate @Index { Date, printing of current }
XJudicious use of databases can convert
Xthese numbers into useful dates.  For example,
X@ID @Code {
X"@Moment&&now @Open { @Day {@Months&&@Month}, @Century{@Year} }"
X}
Xproduces something like
X@Moment&&now @Open { @Day {@Months&&@Month}, @Century{@Year} }
Xgiven a suitable database of months.
X@End @Section
END_OF_FILE
  if test 1705 -ne `wc -c <'lout/doc/tr.lout/ch3.16'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.16'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.16'
fi
if test -f 'lout/doc/tr.lout/ch3.21' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.21'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.21'\" \(1524 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.21' <<'END_OF_FILE'
X@Section
X   @Title { "@Open and @Use" }
X   @Tag { open }
X@Begin
X@PP
XThe @@Open symbol
Xopen.sym @Index { @@Open symbol }
Xtakes a cross reference or symbol
Xinvocation for its left parameter, and an arbitrary object, which must
Xbe enclosed in braces, for its right parameter.  The right parameter
Xmay refer to the exported parameters and nested definitions of the invocation
Xdenoted by the left parameter, and its value is the @@Open
Xsymbol's result.  The target of the cross reference may lie in an
Xexternal database (Section {@NumberOf database}).  Any symbol available
Xoutside the @@Open which happens to have the same name as one of the
Xsymbols made available by the @@Open will be unavailable within the @@Open.
X@PP
Xuse.sym @Index { @@Use symbol }
XThe @@Use symbol is an @@Open symbol in a
Xdifferent form.  It may only appear just after the definitions
Xin Lout's input, and it is equivalent to enclosing the remainder of the
Xinput in an @@Open symbol.  For example,
X@ID {
X      @I definitions
X//1vx @Code "@Use" @Code "{" @I x @Code "}"
X//1vx @Code "@Use" @Code "{" @I y @Code "}"
X//1vx @I { rest of input }
X}
Xis equivalent to
X@ID {
X      @I definitions
X//1vx @I x @Code "@Open"
X//1vx @Code "{" &4mt @I y @Code "@Open"
X//1vx   &4mt @Code "{" @I { rest of input }
X//1vx   &4mt @Code "}"
X//1vx @Code "}"
X}
XThe @@Use symbol allows a set of standard packages to be opened without
Xthe inconvenience of enclosing the entire document in @@Open symbols.  Such
Xenclosure could cause Basser Lout to run out of memory.
X@End @Section
END_OF_FILE
  if test 1524 -ne `wc -c <'lout/doc/tr.lout/ch3.21'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.21'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.21'
fi
if test -f 'lout/doc/tr.lout/ch3.22' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.22'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.22'\" \(1685 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.22' <<'END_OF_FILE'
X@Section
X   @Title { "@Database and @SysDatabase" }
X   @Tag { database }
X@Begin
X@PP
Xdatabase.sym @Index { @@Database symbol }
XThe @@Database symbol is used to declare the existence of a file
Xof symbol invocations that Lout may refer to when evaluating cross
Xreferences.  In Basser Lout, for example,
X@ID @Code {
X"@Database @Months @WeekDays { standard }"
X}
Xmeans that there is a file called @Code "standard.ld" containing
Xinvocations of the previously defined symbols @Code "@Months" and
X{@Code "@WeekDays"}.  A @@Database symbol may appear anywhere, although
Xit is most naturally placed immediately following the definitions of the
Xsymbols it refers to.  Different definitions packages may refer to a
Xcommon database, provided the definitions they give for its symbols are
Xcompatible.  An entry is interpreted as though it appears at the point
Xwhere the cross reference that retrieves it does, which allows symbols
Xlike @Code "@I" for @Code "Slope @Font" to be used in databases.  The
Xdatabase file may not contain @@Database or @@Include symbols, and each
Xinvocation within it must be enclosed in braces.
X@PP
XBasser Lout constructs an {@I {index file}},
Xindex.file @Index { Index file (for databases) }
Xwhich in this example is called {@Code "standard.li"}, the first time it
Xever encounters the database, as an aid to searching it.  If the database
Xfile is changed, its index file must be deleted by the user so that
XBasser Lout knows to reconstruct it.
X@PP
XBasser Lout searches for databases in the current directory first, then
Xin a sequence of standard places.  To search the standard places only, use
Xsysdatabase.sym @Index { @@SysDatabase symbol }
X@@SysDatabase.
X@End @Section
END_OF_FILE
  if test 1685 -ne `wc -c <'lout/doc/tr.lout/ch3.22'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.22'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.22'
fi
if test -f 'lout/doc/tr.lout/ch3.24' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.24'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.24'\" \(1436 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.24' <<'END_OF_FILE'
X@Section
X   @Title { "@IncludeGraphic" and "@SysIncludeGraphic" }
X   @Tag { includegraphic }
X@Begin
X@PP
Xincludegraphic.sym @Index { @@IncludeGraphic symbol }
Xsysincludegraphic.sym @Index { @@SysIncludeGraphic symbol }
Xpostscript.includegraphic @SubIndex { used by @@IncludeGraphic }
XThese symbols instruct Lout to incorporate a separately created
Xillustration:
X@ID @Code "@IncludeGraphic  \"myportrait.eps\""
XThe parameter is implementation-dependent; in Basser Lout it is an
Xobject whose value is a simple word denoting the name of a file.  This
Xfile should ideally be a PostScript EPS Version 3.0 file [{@Ref adobe90}],
Xsince then Lout will keep careful track of what resources are required
Xfor printing that file.  However, any PostScript file containing the
X@Code "%%BoundingBox:" comment and not requiring unusual resources is
Xlikely to work.
X@PP
XThe result of @@IncludeGraphic is an ordinary Lout object with marks
Xthrough its centre.  It may be rotated, scaled, and generally
Xtreated like any other object.  Basser Lout determines its size by
Xconsulting the bounding box information in the file.  If this cannot be
Xfound, a warning message is printed and the result object has zero size.
X@PP
X@@IncludeGraphic searches the same directories that @@Include does
X(Section {@NumberOf include}).  @@SysIncludeGraphic is the same as
X@@IncludeGraphic, except that it searches only the directories searched
Xby @@SysInclude.
X@End @Section
END_OF_FILE
  if test 1436 -ne `wc -c <'lout/doc/tr.lout/ch3.24'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.24'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.24'
fi
if test -f 'lout/doc/tr.over/s0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.over/s0'\"
else
  echo shar: Extracting \"'lout/doc/tr.over/s0'\" \(883 characters\)
  sed "s/^X//" >'lout/doc/tr.over/s0' <<'END_OF_FILE'
X@Report
X   @Title { A New Approach to Document Formatting }
X   @Author { Jeffrey H. Kingston }
X   @Institution { Basser Department of Computer Science
XUniversity of Sydney 2006
XAustralia }
X   @Columns { Double }
X   @DateLine { 22 December, 1992 }
X//
X
X@Abstract {
XThis paper describes a new approach to document formatting, in which
Xfeatures are written in a small, coherent, high-level language called
XLout.  The resulting increase in productivity has permitted many advanced
Xfeatures to be developed quickly and accurately, including page layout of
Xunprecedented flexibility, equation formatting, automatically generated
Xtables of contents, running page headers and footers, cross references,
Xsorted indexes, and access to bibliographic databases.  A fully operational
Xproduction implementation of the Lout system including all these features
Xand many others is freely available.
X}
END_OF_FILE
  if test 883 -ne `wc -c <'lout/doc/tr.over/s0'`; then
    echo shar: \"'lout/doc/tr.over/s0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.over/s0'
fi
if test -f 'lout/doc/tr.over/s6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.over/s6'\"
else
  echo shar: Extracting \"'lout/doc/tr.over/s6'\" \(2574 characters\)
  sed "s/^X//" >'lout/doc/tr.over/s6' <<'END_OF_FILE'
X@Section
X   @Title { Cross references }
X@Begin
X@PP
XThe terms @Code "@TextPlace&&preceding" and @Code "@FootPlace&&following"
Xused above can be thought of as arrows in the final printed document,
Xpointing from themselves to the place they name.  Expressed in this way,
Xfree of any reference to the internal action of the document formatter,
Xthey are easy to comprehend and work with.  These arrows are called
Xcross references in Lout.
X@PP
XA galley is transported forwards along its arrow, but it turns out that
Xa reverse flow of information can also be very useful.  For example,
Xlarge documents often have cross references such as `see Table 6 on page
X57.'  If the numbers are replaced by arrows pointing to the table in
Xquestion, it should be possible to have their values filled in
Xautomatically (an idea introduced by Scribe [{@Ref reid80}]).  An arrow
Xpointing outside the docu&-ment could retrieve an entry from a database of
Xreferences, Roman numerals, etc.  And a running page header like
X`Chapter 8:  Sorting' might obtain its value from an arrow pointing from
Xthe page header line down into the body text of the page, where the
Xcurrent chapter is known.
X@PP
XAll these ideas are realized in Lout, but here we will just sketch a
Xsimplified version of the running page header definitions found in the
XBookLayout package [{@Ref kingston92begin}].  A symbol called
X@Code "@Runner" is first defined:
X@ID @Code {
X"def @Runner"
X"    right @Val"
X"{}"
X}
X@Code "@Runner" produces nothing at all, which means that we may place
Xthe invokation
X@ID @Code {
X"@Runner { Chapter"
X"8:  Sorting }"
X}
Xat the end of a chapter without harm.  This invisible invokation will be
Xcarried along with the chapter and will end up on some page of the final
Xprinted document.
X@PP
XBy modifying the definition of {@Code "@PageList"}, we can add to each
Xpage a header line containing the expression
X@ID @Code {
X"@Runner&&following"
X"@Open { @Val }"
X}
XThis means `find the nearest following invokation of @Code "@Runner" in the
Xfinal printed document and retrieve its @Code "@Val" parameter.' Every page
Xof Chapter 8 will find the correct running header, since @Code "@Runner"
Xwas placed at the end of the chapter.  The invokation @Code "@Runner {}"
Xplaced at the beginning of the chapter will suppress the header on the
Xfirst page of the chapter, as it is conventional to do.
X@PP
XThese invokations of @Code "@Runner" are hidden from the non-expert user
Xwithin the definition of the @Code "@Chapter" operator.  The result is a
Xreliable implementation of a notoriously difficult feature.
X@End @Section
END_OF_FILE
  if test 2574 -ne `wc -c <'lout/doc/tr.over/s6'`; then
    echo shar: \"'lout/doc/tr.over/s6'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.over/s6'
fi
if test -f 'lout/doc/tr.over/s7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.over/s7'\"
else
  echo shar: Extracting \"'lout/doc/tr.over/s7'\" \(1850 characters\)
  sed "s/^X//" >'lout/doc/tr.over/s7' <<'END_OF_FILE'
X@Section
X   @Title { Conclusion }
X@Begin
X@PP
XThe Lout document formatting system permits features as diverse as page
Xlayout and equation formatting to be implemented by definitions written
Xin a high-level language.  The consequent improvement in productivity
Xhas allowed an unprecedented repertoire of advanced features to be
Xpresented to the non-expert user.
X@PP
XTo future research in document formatting, Lout offers evidence of the
Xutility of the functional paradigm, as well as two new abstractions:
Xgalleys and cross references.  These provide a secure foundation for
Xfeatures which have proven very difficult to implement in the past.
X@PP
XA number of improvements to the current system can be envisaged.  Better
Xparagraph and page breaking algorithms could be added to the formatter
Xwithout any change to the language; non-rectangular objects would be
Xuseful in some places.  Perhaps the most useful improvement would be the
Xrepresentation of paragraphs as horizontal galleys, since this would allow
Xthe full power of the language to be brought to bear on paragraph
Xlayout, in contrast to the present built-in system which offers only the
Xtraditional styles (ragged right, justified, and so on).
X{ @Reference
X    @Tag { brooks91 }
X    @Type { JournalArticle }
X    @Author { Brooks, Kenneth P. }
X    @Title { Lilac: a two-view document editor }
X    @Journal { IEEE Computer }
X    @Volume { @Null }
X    @Pages { 7--19 }
X    @Year { 1991 }
X}
X@PP
XThe author of a recent inter&-active document editor [{@Ref brooks91}]
Xhas recommended that the interface be supported by a functional base
Xlanguage, accessible to the expert user, for such purposes as page
Xlayout definition and fine control over formatting.  Lout appears to be
Xan excellent candidate for such a language, because of its small size,
Xprecision, and functional semantics.
X@End @Section
END_OF_FILE
  if test 1850 -ne `wc -c <'lout/doc/tr.over/s7'`; then
    echo shar: \"'lout/doc/tr.over/s7'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.over/s7'
fi
if test -f 'lout/doc/tr.tab/s0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.tab/s0'\"
else
  echo shar: Extracting \"'lout/doc/tr.tab/s0'\" \(1096 characters\)
  sed "s/^X//" >'lout/doc/tr.tab/s0' <<'END_OF_FILE'
X@Report
X   @Title { Tab -- A Lout Package for Formatting Tables }
X   @Author { Jeffrey H. Kingston }
X   @Institution { Basser Department of Computer Science
XUniversity of Sydney 2006
XAustralia }
X   @DateLine { 22 December 1992 }
X//
X
X@Abstract {
XThis report describes the use of Tab, a package of definitions for
Xproducing tables with the Lout document formatter:
X@Display @Tab
X   hmargin { 0.4c }
X   vmargin { 0.3v }
X   side { single }
X   @Fmta { @Col @B @CC X @Over A,B,C }
X   @Fmtb { @Col @I A ! @Col B !! @Col C }
X{
X@Rowa
X   above { single }
X   X { Value of mathematical formulae (millions of dollars) }
X@Rowb
X   above { double }
X   A { Quadratic formula }
X   B { @Eq { x ^= { minus b +- sqrt { b sup 2 - 4ac } } over 2a } }
X   C { 3^.5 }
X@Rowb
X   below { single }
X   A { Binomial theorem }
X   B { @Eq { ( a + b ) sup n ^= big sum from k=0 to infty 
Xmatrix atleft { ( } atright { ) } { n above k } a sup k b sup n-k
X} }
X   C { 12^ }
X}
XA wide variety of styles for columns and individual entries is provided,
Xand entries may contain equations, figures, and other objects without
Xrestriction.
X}
END_OF_FILE
  if test 1096 -ne `wc -c <'lout/doc/tr.tab/s0'`; then
    echo shar: \"'lout/doc/tr.tab/s0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.tab/s0'
fi
if test -f 'lout/doc/tr.tab/s1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.tab/s1'\"
else
  echo shar: Extracting \"'lout/doc/tr.tab/s1'\" \(2564 characters\)
  sed "s/^X//" >'lout/doc/tr.tab/s1' <<'END_OF_FILE'
X@Section
X   @Title { Introduction }
X@Begin
X@PP
XThe Tab table formatting package is designed to simplify the production
Xof tables in documents produced with the Lout document formatting system
X[{@Ref kingston92}].  Tab aligns entries in columns, draws boxes and
Xrules, and so on.  To use Tab, either place @Code "-itab" on the Unix
X@FootNote { Unix is a trademark of "AT&T" Bell Laboratories. }
Xcommand line, or @Code "@SysInclude { tab }" in the setup file.
X@PP
XTo begin with a very simple example, the table
X@CD
X@Tab
X    @Fmta { @Col A  !  @Col B  !  @Col C }
X{
X    @Rowa A { Austen } B { Chaucer } C { Donne }
X    @Rowa A { Balzac } B { Darwin } C { Goethe }
X    @Rowa A { Byron } B { Dickens } C { Homer }
X}
Xis the result of the following Lout input:
X@ID @Code {
X"@Tab"
X"    @Fmta { @Col A  !  @Col B  !  @Col C }"
X"{"
X"    @Rowa A { Austen } B { Chaucer } C { Donne }"
X"    @Rowa A { Balzac } B { Darwin } C { Goethe }"
X"    @Rowa A { Byron } B { Dickens } C { Homer }"
X"}"
X}
XImmediately after the @Code "@Tab" symbol, which introduces the table,
Xcomes a @I { format option } & , {@Code "@Fmta"}, describing the format
Xof each row.  It says that each row contains three columns:
X{@Code "@Col A"}, {@Code "@Col B"}, and {@Code "@Col C"}.  The format
Xoption may have up to 26 columns, with names chosen freely
Xfrom the upper-&-case letters from @Code A to {@Code Z}.  The symbol
X@Code "!" separates each pair of columns.
X@PP
XAfter the format option comes the body of the table, enclosed in
Xbraces.  It consists entirely of a sequence of rows, each introduced by
Xthe @Code "@Rowa" symbol and containing one entry for each column of the
Xformat option, as shown (the row may occupy any number of lines of the
Xinput file).  The entries may be arbitrary Lout objects, such as words,
Xparagraphs, equations, figures, and so on without restriction.  An entry
Xmay be omitted altogether if it is empty.  Lout will choose suitable widths
Xfor the columns, and break paragraphs in the entries to the right widths.
X@PP
XTab neither knows nor cares what happens to the table it produces; it
Xcould appear at any point in the document, even within a paragraph of
Xtext.  Most commonly, though, tables are displayed using the 
X@Code "@IndentedDisplay" and @Code "@CentredDisplay" symbols from the
XDocumentLayout package [{@Ref kingston92begin}]:
X@ID @Code "@CentredDisplay @Tab ..."
Xor else they go into the @Code "@Table" symbol:
X@ID @Code {
X"@Table"
X"    @Caption { ... }"
X"@Tab"
X"{ ..."
X"}"
X}
Xwhich centres them at the top of the following page and adds a caption.
X@End @Section
END_OF_FILE
  if test 2564 -ne `wc -c <'lout/doc/tr.tab/s1'`; then
    echo shar: \"'lout/doc/tr.tab/s1'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.tab/s1'
fi
if test -f 'lout/doc/tr.tab/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.tab/s3'\"
else
  echo shar: Extracting \"'lout/doc/tr.tab/s3'\" \(2783 characters\)
  sed "s/^X//" >'lout/doc/tr.tab/s3' <<'END_OF_FILE'
X@Section
X   @Title { Changing the style of rows }
X@Begin
X@PP
XSometimes different rows need different formats, usually because they
Xare headings.  Although this can be done with style-changing symbols in
Xthe entries, it is probably better to use multiple format options:
X@ID @Code {
X"@Tab"
X"    @Fmta { @Col @Heading A  !  @Col @Heading B }"
X"    @Fmtb { @Col @A  !  @Col @CC B }"
X"{"
X"    @Rowa A { Course } B { Enrolment }"
X"    @Rowb A { Software Engineering } B { 174 }"
X"    @Rowb A { Complexity Theory } B { 37 }"
X"}"
X}
Xhas result
X@CD {
X@Tab
X    @Fmta { @Col @Heading A  !  @Col @Heading B }
X    @Fmtb { @Col A  !  @Col @CC B }
X{
X    @Rowa A { Course } B { Enrolment }
X    @Rowb A { Software Engineering } B { 174 }
X    @Rowb A { Complexity Theory } B { 37 }
X}
X}
XWe have used the @Code "@Heading" symbol from the DocumentLayout package
Xjust to prove that it can be done.  Each row appears in the format of
Xthe corresponding format option:  @Code "@Rowa" rows in the format of
X{@Code "@Fmta"}, @Code "@Rowb" rows in the format of {@Code "@Fmtb"},
Xand so on.  There may be up to ten different format options, from
X@Code "@Fmta" to {@Code "@Fmtj"}, and they may be used repeatedly and
Xin any order.
X@PP
XThere is an @Code "@Over" symbol for constructing
X{@I{spanning columns}}:  columns that spread over two or more following
Xcolumns.  For example, the Lout input
X@ID @Code {
X"@I @Tab"
X"    @Fmta { @Col @CC X @Over A,B  !  @Col C }"
X"    @Fmtb { @Col A  !  @Col B  !  @Col C }"
X"{"
X"    @Rowa X { X } C { C }"
X"    @Rowb A { A } B { B } C { C }"
X"}"
X}
Xproduces the table
X@CD {
X@I @Tab
X    side { single }
X    @Fmta { @Col @CC X @Over A,B !! @Col C }
X    @Fmtb { @Col A !! @Col B !! @Col C }
X{
X    @Rowa X { X } C { C }
X       above { single }
X       below { single }
X    @Rowb A { A } B { B } C { C }
X       below { single }
X}
X}
X(We will see how to get the lines later.)  The @Code "@Over" symbol
Xalways comes directly after the column letter, and it is followed by one
Xor more letters separated by commas indicating which columns in the
Xfollowing row this column is to span over.
X@PP
XWith multiple row formats, especially those with spanning columns, it is
Ximportant to take care that each row is compatible with the one
Xpreceding it, in the sense of having the same number of columns, taking
X@Code "@Over" symbols into account.  For example, two successive
X@Code "@Rowa" rows would not be compatible in the example above, since
Xthe second has only two columns but the first prepares the way for three.
X@PP
XTab does not provide a way to have spanning columns underneath the columns
Xthey span, so spanning columns are useful only for headings.  This
Xrestriction was made necessary by inadequacies in the
Xway that the Basser Lout interpreter handles spanning columns.
X@End @Section
END_OF_FILE
  if test 2783 -ne `wc -c <'lout/doc/tr.tab/s3'`; then
    echo shar: \"'lout/doc/tr.tab/s3'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.tab/s3'
fi
if test -f 'lout/doc/tr.tab/s5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.tab/s5'\"
else
  echo shar: Extracting \"'lout/doc/tr.tab/s5'\" \(1538 characters\)
  sed "s/^X//" >'lout/doc/tr.tab/s5' <<'END_OF_FILE'
X@Section
X   @Title { Margins }
X@Begin
X@PP
XTab places a @I { vertical margin } above and below each row, and a
X@I { horizontal margin } to the left and right of each column.  (If
Xthere are no side rules, the leftmost and rightmost margins are
Xomitted.)  The size of these margins is determined by two options to the
X@Code "@Tab" symbol:
X@ID @Code {
X"@Tab"
X"    hmargin { 0.3c }"
X"    vmargin { 0.2v }"
X"    @Fmta { ... }"
X"..."
X}
XShown here are the default values, 0.3 centimetres for the horizontal
Xmargins, and 0.2 times the current inter-line spacing (denoted by the
Xletter {@Code v}) for the vertical margins.
X@PP
XThe horizontal margin is fixed, but each row may have its own vertical margin:
X@ID @Code {
X"@Rowa"
X"    vmargin { 0.5vx }"
X"    A { ... }"
X}
XIf omitted, the @Code vmargin value is taken from the @Code "@Tab" option.
X@PP
XThe value shown here, {@Code "0.5vx"}, requests a vertical margin of
Xhalf the current inter-line spacing, measured from the baseline of the
Xentry rather than from its edge (this is what the @Code x means).  This
Xvalue is a good choice when the entries contain simple words or lines
Xof text (i.e. no paragraphs, large equations, figures, etc.):
X@CD {
X@Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col @Heading A  !  @Col @Heading B }
X    @Fmtb { @Col A  !  @Col @CC B }
X{
X    @Rowa A { Course } B { Enrolment }
X    @Rowb A { Software Engineering } B { 174 }
X    @Rowb A { Complexity Theory } B { 37 }
X}
X}
Xsince the lines of the table will then be separated evenly like
Xthe lines in paragraphs.
X@End @Section
END_OF_FILE
  if test 1538 -ne `wc -c <'lout/doc/tr.tab/s5'`; then
    echo shar: \"'lout/doc/tr.tab/s5'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.tab/s5'
fi
if test -f 'lout/hyph.install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/hyph.install'\"
else
  echo shar: Extracting \"'lout/hyph.install'\" \(2297 characters\)
  sed "s/^X//" >'lout/hyph.install' <<'END_OF_FILE'
XInstallation of hyphenation patterns
X
XJeffrey H. Kingston
X22 December 1992
X
XBasser Lout Version 2.03 incorporates automatic hyphenation using the method
Xintroduced by TeX (see Appendix H of the TeXBook by D. E. Knuth).  No special
Xaction is required to install hyphenation unless it is desired to change the
Xhyphenation patterns that control it.
X
XThe first time on any run that hyphenation is required, Lout will search the
X@SysInclude directories for a binary file called lout.hyph.packed, which
Xcontains a memory image of the TeX hyphenation patterns, modified so that
Xthe file may be safely shared by big-endian and little-endian machines.  If
Xthis file cannot be found, Lout then searches for the text file lout.hyph
Xinstead, and uses it to construct lout.hyph.packed.  To change the hyphenation
Xpatterns, delete lout.hyph.packed and modify lout.hyph; the rest is automatic.
X
XFile lout.hyph mainly contains the long list of TeX hyphenation patterns,
Xbut it begins with a sequence of character classes, one class per line,
Xterminated by a blank line:
X
X    @!$%^&*()_-+=~`{[}]:;'|<,.>?/0123456789
X    aA
X    bB
X    cC
X    ...
X    yY
X    zZ
X
XBriefly, hyphenation of a word works like this.  If the word contains a
Xcharacter not found in any of these classes, it will not be hyphenated.
XOtherwise the word is analysed into sequences of letters separated by
Xsequences of non-letters (the characters in the first class are by
Xdefinition the non-letters, and the remaining characters are the letters).
XEach sequence of five or more letters is then matched with the hyphenation
Xpatterns and hyphenated.  The matching process treats the members of each
Xclass as identical (so the classes above ensure that the distinction
Xbetween upper and lower case is ignored).  The hyphen character "-" is
Xtreated specially.  Apart from the weighting digits, the patterns should
Xcontain only letters.
X
XExtreme lengths were resorted to to compress the .packed file as much as
Xpossible, and attempts to increase the number of classes or patterns
Xsignificantly are likely to fail.  Some words are not hyphenated well by
Xthe standard patterns and must be treated as exceptions; see the
XDocumentLayout package implementation (file dl in lout/include) for
Xthe standard list of these exceptions and how to deal with them.
END_OF_FILE
  if test 2297 -ne `wc -c <'lout/hyph.install'`; then
    echo shar: \"'lout/hyph.install'\" unpacked with wrong size!
  fi
  # end of 'lout/hyph.install'
fi
if test -f 'lout/include/ft' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/include/ft'\"
else
  echo shar: Extracting \"'lout/include/ft'\" \(2243 characters\)
  sed "s/^X//" >'lout/include/ft' <<'END_OF_FILE'
X
X###############################################################################
X#                                                                             #
X#  Font definitions                                                           #
X#                                                                             #
X###############################################################################
X
Xfontdef	AvantGarde Base			{ "AvantGarBoo.AFM"	}
Xfontdef	AvantGarde Slope		{ "AvantGarBooObl.AFM"	}
Xfontdef	AvantGarde Demi			{ "AvantGarDem.AFM"	}
Xfontdef	AvantGarde DemiSlope		{ "AvantGarDemObl.AFM"	}
X
Xfontdef	Bookman Base			{ "BookmDem.AFM"	}
Xfontdef	Bookman Slope			{ "BookmDemIta.AFM"	}
Xfontdef	Bookman Light			{ "BookmLig.AFM"	}
Xfontdef	Bookman LightSlope		{ "BookmLigIta.AFM"	}
X
Xfontdef	Courier Base			{ "Couri.AFM"		}
Xfontdef	Courier Slope			{ "CouriObl.AFM"	}
Xfontdef	Courier Bold			{ "CouriBol.AFM"	}
Xfontdef	Courier BoldSlope		{ "CouriBolObl.AFM"	}
X
Xfontdef	Helvetica Base			{ "Helve.AFM"		}
Xfontdef	Helvetica Slope			{ "HelveObl.AFM"	}
Xfontdef	Helvetica Bold			{ "HelveBol.AFM"	}
Xfontdef	Helvetica BoldSlope		{ "HelveBolObl.AFM"	}
Xfontdef	Helvetica Cond			{ "HelveCon.AFM"	}
Xfontdef	Helvetica CondSlope		{ "HelveConObl.AFM"	}
Xfontdef	Helvetica CondBold		{ "HelveConBol.AFM"	}
Xfontdef	Helvetica CondBoldSlope		{ "HelveConBolObl.AFM"	}
Xfontdef	Helvetica Narrow		{ "HelveNar.AFM"	}
Xfontdef	Helvetica NarrowSlope		{ "HelveNarObl.AFM"	}
Xfontdef	Helvetica NarrowBold		{ "HelveNarBol.AFM"	}
Xfontdef	Helvetica NarrowBoldSlope	{ "HelveNarBolObl.AFM"	}
X
Xfontdef	Schoolbook Base			{ "NewCenSchRom.AFM"	}
Xfontdef	Schoolbook Slope		{ "NewCenSchIta.AFM"	}
Xfontdef	Schoolbook Bold			{ "NewCenSchBol.AFM"	}
Xfontdef	Schoolbook BoldSlope		{ "NewCenSchBolIta.AFM"	}
X
Xfontdef	Palatino Base			{ "PalatRom.AFM"	}
Xfontdef	Palatino Slope			{ "PalatIta.AFM"	}
Xfontdef	Palatino Bold			{ "PalatBol.AFM"	}
Xfontdef	Palatino BoldSlope		{ "PalatBolIta.AFM"	}
X
Xfontdef	Symbol Base			{ "Symbo.AFM"		}
X
Xfontdef	Times Base			{ "TimesRom.AFM"	}
Xfontdef	Times Slope			{ "TimesIta.AFM"	}
Xfontdef	Times Bold			{ "TimesBol.AFM"	}
Xfontdef	Times BoldSlope			{ "TimesBolIta.AFM"	}
X
Xfontdef	Chancery Base			{ "ZapfChaMedIta.AFM"	}
Xfontdef	Dingbats Base			{ "ZapfDin.AFM"		}
END_OF_FILE
  if test 2243 -ne `wc -c <'lout/include/ft'`; then
    echo shar: \"'lout/include/ft'\" unpacked with wrong size!
  fi
  # end of 'lout/include/ft'
fi
echo shar: End of archive 29 \(of 30\).
cp /dev/null ark29isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
