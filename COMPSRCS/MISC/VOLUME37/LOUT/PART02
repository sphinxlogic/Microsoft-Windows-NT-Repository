Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i100:  lout - Lout document formatting system, v2, Part02/30
Message-ID: <1993May31.035107.20569@sparky.imd.sterling.com>
X-Md4-Signature: edfb395e615535178cc9a332b52b54ef
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 31 May 1993 03:51:07 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 100
Archive-name: lout/part02
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/doc/tr.lout/ch3.25 lout/externs
# Wrapped by kent@sparky on Sun May 30 19:43:53 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 30)."'
if test -f 'lout/doc/tr.lout/ch3.25' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.25'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.25'\" \(1014 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.25' <<'END_OF_FILE'
X@Section
X   @Tag { prependgraphic }
X   @Title { "@PrependGraphic and @SysPrependGraphic" }
X@Begin
X@PP
Xprependgraphic.sym @Index { @@PrependGraphic symbol }
Xsysprependgraphic.sym @Index { @@SysPrependGraphic symbol }
Xpostscript.prependgraphic @SubIndex { used by @@PrependGraphic }
XThese symbols tell Lout to include the contents of a file in the
Xpreamble of its output.  For Basser Lout this means that the file must
Xcontain PostScript (and ideally it would begin and end with the
X@Code "%%BeginResource" and @Code "%%EndResource" comments of
XDSC 3.0).  For example,
X@ID @Code {
X"@SysPrependGraphic { \"fig_prepend\" }"
X}
Xappears at the start of the Fig package; the file @Code fig_prepend
Xcontains a number of PostScript definitions used by Fig for drawing
Xdiagrams.  It saves a lot of space to include them just once at the
Xstart like this, rather than with every diagram.  @@PrependGraphic and
X@@SysPrependGraphic search for the file in the same places as @@Include and
X@@SysInclude respectively.
X@End @Section
END_OF_FILE
  if test 1014 -ne `wc -c <'lout/doc/tr.lout/ch3.25'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.25'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.25'
fi
if test -f 'lout/externs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/externs'\"
else
  echo shar: Extracting \"'lout/externs'\" \(79673 characters\)
  sed "s/^X//" >'lout/externs' <<'END_OF_FILE'
X/*@externs:External Declarations@*********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         externs                                                    */
X/*  MODULE:       External Declarations                                      */
X/*                                                                           */
X/*****************************************************************************/
X#include <stdio.h>
X#include <string.h>
X
X/*****************************************************************************/
X/*                                                                           */
X/*  Include, font and database directories, and the DEBUG_ON and ASSERT_ON   */
X/*  flags (defined by -D options on the cc command line in the makefile).    */
X/*                                                                           */
X/*  LATIN               Non-zero means compile for ISO-LATIN-1 char set.     */
X/*  INCL_DIR            The system directory where @Include files are kept   */
X/*  FONT_DIR            The system directory where .AFM font files are kept  */
X/*  DATA_DIR            The system directory where database files are kept   */
X/*  DEBUG_ON            Non-zero means compile debug code (lout -d)          */
X/*  ASSERT_ON           Non-zero means test assertions                       */
X/*                                                                           */
X/*  #define  LATIN      0                                                    */
X/*  #define  INCL_DIR   "/usr/local/lib/lout/include"                        */
X/*  #define  FONT_DIR   "/usr/local/lib/lout/font"                           */
X/*  #define  DATA_DIR   "/usr/local/lib/lout/data"                           */
X/*  #define  DEBUG_ON   0                                                    */
X/*  #define  ASSERT_ON  1                                                    */
X/*                                                                           */
X/*****************************************************************************/
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  File naming conventions and version                                      */
X/*                                                                           */
X/*  LOUT_VERSION        Version information                                  */
X/*  CROSS_DB            The default name of the cross reference database     */
X/*  INDEX_SUFFIX        The suffix of database index files                   */
X/*  NEW_INDEX_SUFFIX    The additional suffix of new database index files    */
X/*  DATA_SUFFIX         The suffix of database data files                    */
X/*  NEW_DATA_SUFFIX     The additional suffix of new database data files     */
X/*  HYPH_FILENAME       The default name of the unpacked hyphenation file    */
X/*  HYPH_SUFFIX         The suffix of the packed hyphenation file            */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	LOUT_VERSION		"Basser Lout Version 2.03 (April 1993)"
X#define	CROSS_DB		"lout"
X#define	INDEX_SUFFIX		".li"
X#define	NEW_INDEX_SUFFIX	"x"
X#define	DATA_SUFFIX		".ld"
X#define	NEW_DATA_SUFFIX		"x"
X#define	HYPH_FILENAME		"lout.hyph"
X#define	HYPH_SUFFIX		".packed"
X
X/*****************************************************************************/
X/*                                                                           */
X/*  Significant Limits (other insignificant ones appear in other files)      */
X/*                                                                           */
X/*  MAX_LEN             The maximum value storable in type LENGTH            */
X/*                                                                           */
X/*  MAX_FILES           1 + the maximum number of files.  This cannot        */
X/*                      exceed 256 without changing type FILE_NUM; and       */
X/*                      it cannot exceed 255 without increasing MAX_WORD     */
X/*                      (a WORD is used to hold an array indexed by filenum  */
X/*                      in file z10.c).                                      */
X/*                                                                           */
X/*  MAX_LINE            1 + the maximum length of an input line, in files    */
X/*                      of all types.  This cannot exceed 256, at least in   */
X/*                      source files, unless the col_num field of FILE_POS   */
X/*                      is enlarged beyond its present 1 byte unsigned       */
X/*                                                                           */
X/*  MAX_WORD            1 + the maximum length of a word storable in an      */
X/*                      object record, which includes all file path names    */
X/*                      too.  It is reasonable to make this MAX_LINE, since  */
X/*                      a word longer than MAX_LINE cannot be read in        */
X/*                                                                           */
X/*  MAX_OBJECT_REC      1 + the maximum size of an object record, measured   */
X/*                      in ALIGNs.  The value chosen should exceed           */
X/*                      ceiling( (wr + MAX_WORD - 4) / sizeof(ALIGN) )       */
X/*                      where wr = sizeof(struct word_rec), so that words of */
X/*                      length MAX_WORD-1 can be stored in an object record  */
X/*                                                                           */
X/*  MAX_FONT            1 + the maximum number of sized fonts.  This can be  */
X/*                      increased easily since font metric memory is         */
X/*                      obtained as required from malloc().                  */
X/*                                                                           */
X/*  MAX_LEX_STACK       The maximum depth of @Includes and @Databases.       */
X/*                      This can be increased easily if desired.             */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	MAX_LEN			32767
X#define	MAX_FILES		255
X#define MAX_LINE        	256
X#define MAX_WORD        	256
X#define	MAX_OBJECT_REC		73
X#define MAX_FONT		100
X#define	MAX_LEX_STACK	 	5
X
X/*****************************************************************************/
X/*                                                                           */
X/*  Miscellaneous Macros                                                     */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	BOOLEAN		unsigned	/* changed from: short unsigned      */
X#define	FALSE		0
X#define	TRUE		1
X#define	bool(x)		(x ? "TRUE" : "FALSE")
X#define	CHILD		0
X#define	PARENT		1
X#define	COL		0
X#define	ROW		1
X#define	dimen(x)	(x == COL ? "COL" : "ROW" )
X#define	nil		( (OBJECT) NULL )
X#define	null		( (FILE *) NULL )
X
X#define max(a, b)	((a) < (b) ? (b) : (a))
X#define min(a, b)	((a) < (b) ? (a) : (b))
X#define	ceiling(a, b)	( ((a) - 1)/(b) + 1 )	/* ceiling(a/b)              */
X#define is_odd(x)	( (x) & 1 )		/* TRUE if x is odd number   */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  ALIGN - the most restrictive memory alignment type.                      */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef int ALIGN;
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  LENGTH - a distance measured in integral multiples of the basic unit.    */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef short int LENGTH;
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FONT_NUM - internal name for a font                                      */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef unsigned char FONT_NUM;
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  GAP - what separates one object from another                             */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef struct
X{ unsigned char	ospare;			/* left for other things in STYLE    */
X  BOOLEAN	omark	: 1;		/* TRUE if this gap is marked        */
X  BOOLEAN	ojoin	: 1;		/* TRUE if joins exist across gap    */
X  unsigned	ounits	: 3;		/* units of measurement: fixed, etc  */
X  unsigned	omode	: 3;		/* spacing mode: edge-to-edge, etc   */
X  LENGTH	owidth;			/* width of the gap                  */
X} GAP;
X
X#define	mark(x)		(x).omark
X#define	join(x)		(x).ojoin
X#define	units(x)	(x).ounits
X#define	mode(x)		(x).omode
X#define	width(x)	(x).owidth
X
X#define SetGap(x, xmark, xjoin, xunits, xmode, xwidth)			\
X( mark(x) = xmark, join(x) = xjoin, units(x) = xunits,			\
X  mode(x) = xmode, width(x) = xwidth					\
X)
X
X#define GapCopy(x, y)							\
X( mark(x) = mark(y), join(x) = join(y), units(x) = units(y),		\
X  mode(x) = mode(y), width(x) = width(y)				\
X)
X
X#define ClearGap(x)	SetGap(x, FALSE, TRUE, FIXED_UNIT, NO_MODE, 0)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  STYLE - information about how to break text, etc.                        */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef struct
X{ GAP		oline_gap;		/* separation between lines          */
X  union {
X    GAP		ospace_gap;		/* separation indiced by white space */
X    struct {
X      unsigned	ohyph_style    : 2;	/* hyphenation off or on             */
X      unsigned	ofill_style    : 2;	/* fill lines with text off/on       */
X      unsigned	odisplay_style : 3;	/* display lines adjusted, ragged... */
X    } oss;
X  } osu;
X} STYLE;
X
X#define	line_gap(x)	(x).oline_gap
X#define	space_gap(x)	(x).osu.ospace_gap
X#define	font(x)		(x).oline_gap.ospare
X#define	hyph_style(x)	(x).osu.oss.ohyph_style
X#define	fill_style(x)	(x).osu.oss.ofill_style
X#define	display_style(x)(x).osu.oss.odisplay_style
X
X#define StyleCopy(x, y)							\
X( GapCopy( line_gap(x), line_gap(y) ),					\
X  font(x) = font(y),							\
X  hyph_style(x) = hyph_style(y),					\
X  fill_style(x) = fill_style(y),					\
X  display_style(x) = display_style(y),					\
X  GapCopy( space_gap(x), space_gap(y) )					\
X)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  CONSTRAINT - a size constraint                                           */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef struct
X{ LENGTH  obc;
X  LENGTH  obfc;
X  LENGTH  ofc;
X  LENGTH  osparec;
X} CONSTRAINT;
X
X#define	bc(x)		(x).obc
X#define	bfc(x)		(x).obfc
X#define	fc(x)		(x).ofc
X#define	sparec(x)	(x).osparec
X#define	constrained(x)	(bc(x)!=MAX_LEN || bfc(x)!=MAX_LEN || fc(x)!=MAX_LEN)
X
X#define	SetConstraint(c,x,y,z)	(bc(c) = (x),   bfc(c) = (y),    fc(c) = (z))
X#define	CopyConstraint(x, y)	(bc(x) = bc(y), bfc(x) = bfc(y), fc(x) = fc(y))
X#define FitsConstraint(b, f, c)	(b <= bc(c)  && b + f <= bfc(c) && f <= fc(c))
X
X#define	ig_fnum(x)	bc(constraint(x))
X#define	ig_xtrans(x)	bfc(constraint(x))
X#define	ig_ytrans(x)	fc(constraint(x))
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FILE_NUM - the internal representation of a file                         */
X/*  FILE_POS - a position in the set of input files                          */
X/*                                                                           */
X/*****************************************************************************/
X
Xtypedef unsigned char	FILE_NUM;
X#define	NO_FILE		0
X
Xtypedef	struct
X{ FILE_NUM	ofile_num;		/* no. of file this record is from   */
X  unsigned char	ocol_num;		/* column number this is related to  */
X  LENGTH	oline_num;		/* the line number of this record    */
X} FILE_POS;
X
X#define	file_num(x)	(x).ofile_num
X#define	col_num(x)	(x).ocol_num
X#define	line_num(x)	(x).oline_num
X
X#define FposCopy(x, y)							\
X( file_num(x) = file_num(y),						\
X  line_num(x) = line_num(y),						\
X  col_num(x)  = col_num(y)						\
X)
X
X/*@::declaration of OBJECT@***************************************************/
X/*                                                                           */
X/*  OBJECT - pointer to an arbitrary object (parse tree, symbol table, ...)  */
X/*                                                                           */
X/*****************************************************************************/
X
X#define LIST struct { union rec *opred, *osucc; }
X
Xtypedef union rec
X{
X  struct word_type		/* all fields of WORD, both token and object */
X  {  LIST	olist[2];
X     union
X     {	struct word_as_token
X	{	unsigned char	otype;
X		unsigned char	ohspace;
X		unsigned char	ovspace;
X		unsigned char	orec_size;
X	} oi1;
X
X	struct word_as_object
X	{	unsigned char	otype;
X		BOOLEAN		ogall_rec    : 1;
X		BOOLEAN		obroken      : 1;
X		BOOLEAN		othreaded    : 1;
X		BOOLEAN		oexternal    : 1;
X		BOOLEAN		oblocked     : 1;
X		BOOLEAN		obackward    : 1;
X		BOOLEAN		otrigger_externs   : 1;
X		BOOLEAN	        omust_expand : 1;
X		FONT_NUM	oword_font;
X		unsigned char	orec_size;
X	} oi2;
X     } ou1;
X     union
X     {	FILE_POS	ofpos;
X	int		oword_save_mark;
X     } ou5;
X     union
X     {  LENGTH	oback[2];
X	FILE	*ofilep;
X	/* union rec *ogall_sym; */
X     } ou3;
X     union
X     {	LENGTH	ofwd[2];
X	int	ogall_pos;
X     } ou4;
X     unsigned char ostring[4];
X  } os1;
X
X  struct closure_type		/* CLOSURE, both as token and object */
X  {  LIST	olist[2];
X     union
X     {	struct closure_as_token
X	{	unsigned char	otype;
X		unsigned char	ohspace;
X		unsigned char	ovspace;
X		unsigned char	oprecedence;
X	} oi1;
X
X	struct closure_as_object
X	{	unsigned char	otype;
X		BOOLEAN		ogall_rec    : 1;
X		BOOLEAN		obroken      : 1;
X		BOOLEAN		othreaded    : 1;
X		BOOLEAN		oexternal    : 1;
X		BOOLEAN		oblocked     : 1;
X		BOOLEAN		obackward    : 1;
X		BOOLEAN		otrigger_externs   : 1;
X		BOOLEAN	        omust_expand : 1;
X		unsigned short	ocross_type;
X	} oi2;
X     } ou1;
X     FILE_POS	ofpos;
X     LENGTH	oback[2];
X     LENGTH	ofwd[2];
X     union
X     {	STYLE		osave_style;
X	CONSTRAINT	oconstraint;
X     } ou2;
X     union rec *oactual;
X     union
X     { union rec *owhereto;
X       LENGTH    osave_mark;
X     } ou3;
X     union rec *oready_galls;
X  } os2;
X  
X  struct object_type		/* the general OBJECT */
X  {  LIST	olist[2];
X     union
X     {
X	struct
X	{	unsigned char	otype;
X		BOOLEAN		ogall_rec    : 1;
X		BOOLEAN		obroken      : 1;
X		BOOLEAN		othreaded    : 1;
X		BOOLEAN		oexternal    : 1;
X		BOOLEAN		oblocked     : 1;
X		BOOLEAN		obackward    : 1;
X		BOOLEAN		otrigger_externs   : 1;
X		BOOLEAN	        omust_expand : 1;
X		unsigned short	ocross_type;
X	} oi2;
X     } ou1;
X     FILE_POS	ofpos;
X     LENGTH	oback[2];
X     LENGTH	ofwd[2];
X     union
X     {	STYLE		osave_style;
X	CONSTRAINT	oconstraint;
X     } ou2;
X  } os3;
X
X  struct link_type		/* LINK */
X  {  LIST		olist[2];
X     unsigned char	otype;
X     unsigned char	onumber;
X     unsigned char	odb_targ;
X  } os4;
X  
X  struct gapobj_type		/* GAP_OBJ */
X  {  LIST		olist[2];
X     unsigned char	otype;
X     unsigned char	ohspace;
X     unsigned char	ovspace;
X     unsigned char	oprecedence;
X     FILE_POS		ofpos;
X     GAP		ogap;
X     int		osave_badness;		/* optimum paragraph breaker */
X     LENGTH		osave_space;		/* optimum paragraph breaker */
X     LENGTH		osave_actual_gap;	/* optimum paragraph breaker */
X     union rec  	*osave_prev;		/* optimum paragraph breaker */
X  } os5;
X
X  struct symbol_type
X  {  LIST	olist[2];
X     unsigned char otype;
X     BOOLEAN	ohas_lpar            : 1;
X     BOOLEAN	ohas_rpar            : 1;
X     BOOLEAN	oright_assoc         : 1;
X     BOOLEAN	ois_target           : 1;
X     BOOLEAN	ohas_target          : 1;
X     BOOLEAN	oforce_target	     : 1;
X     BOOLEAN	ois_tag              : 1;
X     BOOLEAN	ohas_tag             : 1;
X     BOOLEAN	ohas_body            : 1;
X     BOOLEAN	oindefinite          : 1;
X     BOOLEAN	orecursive           : 1;
X     BOOLEAN	ouses_extern_target  : 1;
X     BOOLEAN	ois_extern_target    : 1;
X     BOOLEAN	ois_key		     : 1;
X     BOOLEAN	ohas_key	     : 1;
X     unsigned	odirty               : 1;
X     unsigned	char oprecedence;
X     FILE_POS	ofpos;
X     union rec	*oenclosing;
X     union rec	*osym_body;
X     union rec	*obase_uses;
X     union rec	*ouses;
X     union rec	*omarker;
X     union rec	*ocross_sym;
X     union rec	*oimports;
X     unsigned char ouses_count;
X     BOOLEAN	ovisible	     : 1;
X     BOOLEAN	ohas_mark	     : 1;
X     BOOLEAN	ohas_join	     : 1;
X     BOOLEAN	ohas_par             : 1;
X     BOOLEAN	ouses_galley	     : 1;
X     short unsigned opredefined;
X  } os6;
X
X  struct cr_type
X  {  LIST		olist[2];
X     unsigned char	otype;
X     unsigned char	otarget_state;
X     FILE_NUM		otarget_file;
X     FILE_NUM		ocr_file;
X     union rec		*otarget_val;
X     int		otarget_seq;
X     int		otarget_pos;
X     int		ocr_seq;
X     int		ogall_seq;
X     union rec		*osymb;
X     union rec		*ogall_tag;
X     FILE_NUM		ogall_tfile;
X     FILE_NUM		ogentag_file;
X     int		ogentag_seq;
X     union rec		*ogentag_fseq;
X  } os7;
X
X  struct ext_gall_type
X  {  LIST		olist[2];
X     unsigned char	otype;
X     FILE_NUM		oeg_fnum;
X     long		oeg_fpos;
X     long		oeg_cont;
X     union rec		*oeg_symbol;
X  } os8;
X
X  struct uses_type
X  {  union rec	*oitem;
X     union rec	*onext;
X  } os9;
X
X  struct hash_entry_type
X  {  LIST	olist[1];
X  } os10;
X
X} *OBJECT;
X
X#define	succ(x, dim)	(x)->os1.olist[dim].osucc
X#define	pred(x, dim)	(x)->os1.olist[dim].opred
X#define type(x)		(x)->os1.ou1.oi1.otype
X#define	gall_rec(x)	(x)->os1.ou1.oi2.ogall_rec
X#define	non_blocking(x)	gall_rec(x)
X#define	broken(x)	(x)->os1.ou1.oi2.obroken
X#define	external(x)	(x)->os1.ou1.oi2.oexternal
X#define	threaded(x)	(x)->os1.ou1.oi2.othreaded
X#define	blocked(x)	(x)->os1.ou1.oi2.oblocked
X#define	backward(x)	(x)->os1.ou1.oi2.obackward
X#define	sized(x)	broken(x)
X#define	seen_nojoin(x)	blocked(x)
X#define	must_expand(x)	(x)->os1.ou1.oi2.omust_expand
X#define	trigger_externs(x) (x)->os1.ou1.oi2.otrigger_externs
X#define	hspace(x)	(x)->os1.ou1.oi1.ohspace
X#define	vspace(x)	(x)->os1.ou1.oi1.ovspace
X#define	word_font(x)	(x)->os1.ou1.oi2.oword_font
X#define	rec_size(x)	(x)->os1.ou1.oi2.orec_size
X#define	fpos(x)		(x)->os2.ofpos
X#define	back(x, dim)	(x)->os2.oback[dim]
X#define	fwd(x, dim)	(x)->os2.ofwd[dim]
X#define	size(x, dim)	(back(x, dim) + fwd(x, dim))
X#define word_save_mark(x) (x)->os1.ou5.oword_save_mark
X#define string(x)	(x)->os1.ostring
X
X#define	precedence(x)	(x)->os2.ou1.oi1.oprecedence
X#define	cross_type(x)	(x)->os2.ou1.oi2.ocross_type
X#define	thr_state(x)	cross_type(x)
X#define	save_style(x)	(x)->os2.ou2.osave_style
X#define	constraint(x)	(x)->os2.ou2.oconstraint
X#define actual(x)	(x)->os2.oactual
X#define whereto(x)	(x)->os2.ou3.owhereto
X#define save_mark(x)	(x)->os2.ou3.osave_mark
X#define ready_galls(x)	(x)->os2.oready_galls
X
X#define	number(x)	(x)->os4.onumber
X#define	db_targ(x)	(x)->os4.odb_targ
X#define	gap(x)		(x)->os5.ogap
X#define	save_space(x)	(x)->os5.osave_space
X#define	save_badness(x)	(x)->os5.osave_badness
X#define	save_actual_gap(x)  (x)->os5.osave_actual_gap
X#define	save_prev(x)	(x)->os5.osave_prev
X
X#define	has_lpar(x)	(x)->os6.ohas_lpar
X#define	has_rpar(x)	(x)->os6.ohas_rpar
X#define	right_assoc(x)	(x)->os6.oright_assoc
X#define	is_target(x)	(x)->os6.ois_target
X#define	has_target(x)	(x)->os6.ohas_target
X#define	force_target(x)	(x)->os6.oforce_target
X#define	is_tag(x)	(x)->os6.ois_tag
X#define	has_tag(x)	(x)->os6.ohas_tag
X#define	has_body(x)	(x)->os6.ohas_body
X#define	indefinite(x)	(x)->os6.oindefinite
X#define	recursive(x)	(x)->os6.orecursive
X#define	predefined(x)	(x)->os6.opredefined
X#define	dirty(x)	(x)->os6.odirty
X#define	enclosing(x)	(x)->os6.oenclosing
X#define	sym_body(x)	(x)->os6.osym_body
X#define	base_uses(x)	(x)->os6.obase_uses
X#define	uses(x)		(x)->os6.ouses
X#define	marker(x)	(x)->os6.omarker
X#define	cross_sym(x)	(x)->os6.ocross_sym
X#define	imports(x)	(x)->os6.oimports
X#define	uses_count(x)	(x)->os6.ouses_count
X#define	visible(x)	(x)->os6.ovisible
X#define	has_mark(x)	(x)->os6.ohas_mark
X#define	has_join(x)	(x)->os6.ohas_join
X#define	has_par(x)	(x)->os6.ohas_par
X#define	uses_galley(x)	(x)->os6.ouses_galley
X#define	is_extern_target(x) (x)->os6.ois_extern_target
X#define	uses_extern_target(x) (x)->os6.ouses_extern_target
X#define	is_key(x)	(x)->os6.ois_key
X#define	has_key(x)	(x)->os6.ohas_key
X
X#define	target_state(x)	(x)->os7.otarget_state
X#define	target_val(x)	(x)->os7.otarget_val
X#define	target_file(x)	(x)->os7.otarget_file
X#define	target_seq(x)	(x)->os7.otarget_seq
X#define	target_pos(x)	(x)->os7.otarget_pos
X#define	cr_file(x)	(x)->os7.ocr_file
X#define	cr_seq(x)	(x)->os7.ocr_seq
X#define	gall_seq(x)	(x)->os7.ogall_seq
X#define	symb(x)		(x)->os7.osymb
X#define	gall_tag(x)	(x)->os7.ogall_tag
X#define	gall_tfile(x)	(x)->os7.ogall_tfile
X#define	gentag_file(x)	(x)->os7.ogentag_file
X#define	gentag_seq(x)	(x)->os7.ogentag_seq
X#define	gentag_fseq(x) (x)->os7.ogentag_fseq
X
X#define	filep(x)	(x)->os1.ou3.ofilep
X/* #define	gall_sym(x)	(x)->os1.ou3.ogall_sym */
X#define	gall_pos(x)	(x)->os1.ou4.ogall_pos
X#define	left_pos(x)	fwd(x, COL)
X#define	save_scope(x)	fwd(x, ROW)
X
X#define	eg_fnum(x)	(x)->os8.oeg_fnum
X#define	eg_fpos(x)	(x)->os8.oeg_fpos
X#define	eg_cont(x)	(x)->os8.oeg_cont
X#define	eg_symbol(x)	(x)->os8.oeg_symbol
X#define	eg_scope(x)	(x)->os8.oeg_scope
X
X#define	item(x)		(x)->os9.oitem
X#define	next(x)		(x)->os9.onext
X
X/*@::object types@************************************************************/
X/*                                                                           */
X/*  OBJECT, TOKEN AND OTHER TYPES inhabiting type(x) and predefined(x)       */
X/*                                                                           */
X/*  Key letters in the adjacent comment indicate where the tag is legal:     */
X/*                                                                           */
X/*    t  a token type, pushed on token stack                                 */
X/*    o  an object type (returned by reduce(), inserted by Manifest)         */
X/*    i  an index type (a child of a galley header other than an object)     */
X/*    s  a predefined symbol (some symbol table entry has this predefined()) */
X/*    n  an indefinite object i.e. one which is ignored in catenation ops    */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	LINK		 0		/*        a link between objects     */
X#define	GAP_OBJ		 1		/*  o     a gap object               */
X#define	CLOSURE		 2		/* to  n  a closure of a symbol      */
X#define	NULL_CLOS	 3		/* to sn  @Null                      */
X#define	CROSS		 4		/* to sn  && (a cross reference obj) */
X#define	HEAD		 5		/*  o  n  a galley header            */
X#define	SPLIT		 6		/*  o     @Split                     */
X#define	PAR		 7		/*  o     a parameter of a closure   */
X#define	WORD		 8		/*  o     a literal word             */
X#define	ROW_THR		 9		/*  o     a row thread               */
X#define	COL_THR		10		/*  o     a column thread            */
X#define	ACAT		11		/* to s   a sequence of &-ed objs    */
X#define	HCAT		12		/* to s   a sequence of |-ed objs    */
X#define	VCAT		13		/* to s   a sequence of /-ed objs    */
X#define	ONE_COL		14		/* to s   @OneCol                    */
X#define	ONE_ROW		15		/* to s   @OneRow                    */
X#define	WIDE		16		/* to s   @Wide                      */
X#define	HIGH		17		/* to s   @High                      */
X#define	HSCALE		18		/* to s   @HScale                    */
X#define	VSCALE		19		/* to s   @HScale                    */
X#define	SCALE		20		/* to s   @Scale                     */
X#define	HCONTRACT	21		/* to s   @HContract                 */
X#define	VCONTRACT	22		/* to s   @VContract                 */
X#define	HEXPAND		23		/* to s   @HExpand                   */
X#define	VEXPAND		24		/* to s   @VExpand                   */
X#define	PADJUST		25		/* to s   @PAdjust                   */
X#define	HADJUST		26		/* to s   @HAdjust                   */
X#define	VADJUST		27		/* to s   @VAdjust                   */
X#define	ROTATE		28		/* to s   @Rotate                    */
X#define	CASE		29		/* to s   @Case                      */
X#define	YIELD		30		/* to s   @Yield                     */
X#define	FONT		31		/* to s   @Font                      */
X#define	SPACE		32		/* to s   @Space                     */
X#define	BREAK		33		/* to s   @Break                     */
X#define	NEXT		34		/* to s   @Next                      */
X#define	ENV		35		/* to s   @LEnv                      */
X#define	CLOS		36		/* to s   @LClos                     */
X#define	LVIS		37		/* to s   @LVis                      */
X#define	OPEN		38		/* to s   @Open                      */
X#define	TAGGED		39		/* to s   @Tagged                    */
X#define	INCGRAPHIC	40		/* to s   @IncludeGraphic            */
X#define	SINCGRAPHIC	41		/* to s   @SysIncludeGraphic         */
X#define	GRAPHIC		42		/* to s   @Graphic                   */
X
X#define	TSPACE		43		/* t      a space token, parser only */
X#define	TJUXTA		44		/* t      a juxta token, parser only */
X#define	LBR		45		/* t  s   left brace token           */
X#define	RBR		46		/* t  s   right brace token          */
X#define	BEGIN		47		/* t  s   @Begin token               */
X#define	END		48		/* t  s   @End token                 */
X#define	USE		49		/* t  s   @Use                       */
X#define	GSTUB_NONE	50		/* t      a galley stub, no rpar     */
X#define	GSTUB_INT	51		/* t      galley stub internal rpar  */
X#define	GSTUB_EXT	52		/* t      galley stub external rpar  */
X#define	INCLUDE		53		/*    s   @Include                   */
X#define	SYS_INCLUDE	54		/*    s   @SysInclude                */
X#define	PREPEND		55		/*    s   @Prepend                   */
X#define	SYS_PREPEND	56		/*    s   @SysPrepend                */
X#define	DATABASE	57		/*    s   @Database                  */
X#define	SYS_DATABASE	58		/*    s   @SysDatabase               */
X#define	START		59		/*    s   \Start                     */
X
X#define	DEAD		60		/*   i    a dead galley              */
X#define	UNATTACHED	61		/*   i    an inner, unsized galley   */
X#define	CLOSE_INDEX	62		/*   i    synchronize galley closing */
X#define	RECEPTIVE	63		/*   i    a receptive object index   */
X#define	RECEIVING	64		/*   i    a receiving object index   */
X#define	RECURSIVE	65		/*   i    a recursive definite obj.  */
X#define	PRECEDES	66		/*   i    an ordering constraint     */
X#define	FOLLOWS		67		/*   i    other end of ordering c.   */
X#define	CROSS_FOLL	68		/*   i    following type cross-ref   */
X#define	GALL_FOLL	69		/*   i    galley with &&following    */
X#define	CROSS_TARG	70		/*   i    value of cross-ref         */
X#define	GALL_TARG	71		/*   i    target of these galleys    */
X#define	GALL_PREC	72		/*   i    galley with &&preceding    */
X#define	CROSS_PREC	73		/*   i    preceding type cross-ref   */
X#define	EXPAND_IND	74		/*   i    index of HEXPAND or VEXPD  */
X#define	THREAD		75		/*        a sequence of threads      */
X#define	CROSS_SYM	76		/*        cross-ref info             */
X#define	CR_ROOT		77		/*        RootCross                  */
X#define	MACRO		78		/*        a macro symbol             */
X#define	LOCAL		79		/*        a local symbol             */
X#define	LPAR		80		/*        a left parameter           */
X#define	NPAR		81		/*        a named parameter          */
X#define	RPAR		82		/*        a right parameter          */
X#define	EXT_GALL	83		/*        an external galley         */
X#define	CR_LIST		84		/*        a list of cross references */
X#define	DISPOSED	85		/*        a disposed record          */
X
X#define is_indefinite(x)  ((x) >= CLOSURE && (x) <= HEAD)
X#define is_definite(x) 	 ((x) >= SPLIT && (x) <= GRAPHIC)
X#define	is_par(x)	((x) >= LPAR   && (x) <= RPAR)
X#define	is_index(x)	((x) >= DEAD && (x) <= EXPAND_IND)
X#define	is_type(x)	((x) >= LINK && (x) < DISPOSED)
X#define	is_filecom(x)	((x) >= INCLUDE && (x) <= SYS_DATABASE)
X
X/*@::miscellaneous constants@*************************************************/
X/*                                                                           */
X/*  Miscellaneous Globally Defined Constants                                 */
X/*                                                                           */
X/*****************************************************************************/
X
X/* gap modes occupying mode(x) */
X#define	NO_MODE		0		/* for error detection: no mode      */
X#define	EDGE_MODE	1		/* edge-to-edge spacing              */
X#define	HYPH_MODE	2		/* edge-to-edge with hyphenation     */
X#define	MARK_MODE	3		/* mark-to-mark spacing              */
X#define	OVER_MODE	4		/* overstrike spacing                */
X#define	KERN_MODE	5		/* kerning spacing                   */
X#define	TAB_MODE	6		/* tabulation spacing                */
X#define	ADD_HYPH	7		/* temp value used by FillObject     */
X
X/* hyph_style(style) options                                                 */
X#define	HYPH_UNDEF	0		/* hyphenation option undefined      */
X#define	HYPH_OFF	1		/* hyphenation off                   */
X#define	HYPH_ON		2		/* hyphenation on                    */
X
X/* fill_style(style) options                                                 */
X#define	FILL_UNDEF	0		/* fill option undefined             */
X#define	FILL_OFF	1		/* no filling of lines               */
X#define	FILL_ON		2		/* fill lines with text              */
X
X/* display_style(style) options                                              */
X#define	DISPLAY_UNDEF	0		/* display option undefined          */
X#define	DISPLAY_ADJUST	1		/* adjust lines (except last)        */
X#define	DISPLAY_OUTDENT	2		/* outdent lines (except first)      */
X#define	DISPLAY_LEFT	3		/* left-justify lines, no adjust     */
X#define	DISPLAY_CENTRE	4		/* centre lines, no adjust           */
X#define	DISPLAY_RIGHT	5		/* right-justify lines, no adjust    */
X#define	DO_ADJUST	6		/* placed in ACATs when adjust need  */
X
X/* sides of a mark */
X#define	BACK		86		/* means 'lies to left of mark'      */
X#define	ON		87		/* means 'lies on mark'              */
X#define	FWD		88		/* means 'lies to right of mark'     */
X
X/* statuses of thread objects */
X#define	NOTSIZED	 0		/* this thread object is not sized   */
X#define	SIZED		 1		/* thread is sized but not printed   */
X#define	FINALSIZE	 2		/* thread object's size is now final */
X
X/* constraint statuses */
X#define	PROMOTE		89		/* this component may be promoted    */
X#define	CLOSE		90		/* must close dest before promoting  */
X#define	BLOCK		91		/* cannot promote this component     */
X#define	CLEAR		92		/* this constraint is now satisfied  */
X
X/* gap increment types */
X#define	ABS		93		/* absolute,  e.g.  3p               */
X#define	INC		94		/* increment, e.g. +3p               */
X#define	DEC		95		/* decrement, e.g. -3p               */
X
X/* file types */
X#define	SOURCE_FILE	 0		/* input file from command line      */
X#define	INCLUDE_FILE	 1		/* @Include file                     */
X#define	INCGRAPHIC_FILE	 2		/* @IncludeGraphic file              */
X#define	DATABASE_FILE	 3		/* database file                     */
X#define	INDEX_FILE	 4		/* database index file               */
X#define	FONT_FILE	 5		/* font file                         */
X#define	PREPEND_FILE	 6		/* PostScript prologue file          */
X#define	HYPH_FILE	 7		/* hyphenation file                  */
X#define	HYPH_PACKED_FILE 8		/* packed hyphenation file           */
X
X/* path types (i.e. sequences of directories for file searching) */
X#define	SOURCE_PATH	 0		/* path to search for source files   */
X#define	INCLUDE_PATH	 1		/* path for @Include files           */
X#define	SYSINCLUDE_PATH	 2		/* path for @SysInclude files        */
X#define	DATABASE_PATH	 3		/* path for @Database files          */
X#define	SYSDATABASE_PATH 4		/* path for @SysDatabase files       */
X#define	FONT_PATH	 5		/* path for fontdef files            */
X
X/* units of measurement */
X#define	NO_UNIT		 0		/* no unit - for error detection     */
X#define	FIXED_UNIT	 1		/* inches, cm, points, ems           */
X#define	FRAME_UNIT	 2		/* f's (frame widths)                */
X#define	AVAIL_UNIT	 3		/* a's (available spaces)            */
X#define	DEG_UNIT	 4		/* d's (degrees)                     */
X#define	NEXT_UNIT	 5		/* b's (inners)                      */
X 
X/* units of distance as multiples of the basic unit */
X#define	CM	       567		/* 1 centimetre                      */
X#define	IN	      1440		/* 1 inch                            */
X#define	EM	       120		/* 1 em (= 1/12 inch)                */
X#define	PT		20		/* 1 point (= 1/72 inch)             */
X#define	FR	      4096		/* virtual unit for frame units      */
X#define	DG	       128		/* virtual unit for degrees          */
X#define	SF	       128		/* virtual unit for @Scale factors   */
X
X/* precedences */
X#define	NO_PREC		 0		/* lower than any precedence         */
X#define	BEGIN_PREC	 1		/* precedence of '@Begin'            */
X#define	END_PREC	 2		/* precedence of '@End'              */
X#define	LBR_PREC	 3		/* precedence of '{'                 */
X#define	RBR_PREC	 4		/* precedence of '}'                 */
X#define	VCAT_PREC	 5		/* precedence of /                   */
X#define	HCAT_PREC	 6		/* precedence of |                   */
X#define	ACAT_PREC	 7		/* precedence of & and white space   */
X#define	MIN_PREC        10		/* minimum precedence of user ops    */
X#define	MAX_PREC       100		/* maximim precedence of user ops    */
X#define	DEFAULT_PREC   100		/* default precedence of user ops    */
X#define CROSSOP_PREC   101		/* precedence of cross op &&         */
X#define GAP_PREC       102		/* precedence of gap op after cat op */
X#define JUXTA_PREC     103		/* precedence of juxtaposition &     */
X#define	FORCE_PREC     104		/* higher than any precedence        */
X
X/* error types */
X#define	INTERN	0			/* internal error (i.e. bug)         */
X#define	FATAL	1			/* fatal error, abort now            */
X#define	WARN	2			/* warning, non-fatal                */
X
X/*@::keywords@****************************************************************/
X/*                                                                           */
X/*  KEYWORDS                                                                 */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	KW_DEF		"def"
X#define	KW_FONTDEF	"fontdef"
X#define	KW_FORCE	"force"
X#define	KW_INTO		"into"
X#define	KW_IMPORT	"import"
X#define	KW_EXPORT	"export"
X#define	KW_PRECEDENCE	"precedence"
X#define	KW_ASSOC	"associativity"
X#define	KW_LEFT		"left"
X#define	KW_RIGHT	"right"
X#define	KW_BODY		"body"
X#define	KW_MACRO	"macro"
X#define	KW_NAMED	"named"
X#define	KW_NEXT		"@Next"
X#define	KW_WIDE		"@Wide"
X#define	KW_HIGH		"@High"
X#define	KW_ONE_COL	"@OneCol"
X#define	KW_ONE_ROW	"@OneRow"
X#define	KW_HSCALE	"@HScale"
X#define	KW_VSCALE	"@VScale"
X#define	KW_SCALE	"@Scale"
X#define	KW_HCONTRACT	"@HContract"
X#define	KW_VCONTRACT	"@VContract"
X#define	KW_HEXPAND	"@HExpand"
X#define	KW_VEXPAND	"@VExpand"
X#define	KW_PADJUST	"@PAdjust"
X#define	KW_HADJUST	"@HAdjust"
X#define	KW_VADJUST	"@VAdjust"
X#define	KW_ROTATE	"@Rotate"
X#define	KW_INCGRAPHIC	"@IncludeGraphic"
X#define	KW_SINCGRAPHIC	"@SysIncludeGraphic"
X#define	KW_GRAPHIC	"@Graphic"
X#define	KW_CASE		"@Case"
X#define	KW_YIELD	"@Yield"
X#define	KW_FONT		"@Font"
X#define	KW_SPACE	"@Space"
X#define	KW_BREAK	"@Break"
X#define	KW_ENV		"@LEnv"
X#define	KW_CLOS		"@LClos"
X#define	KW_LVIS		"@LVis"
X#define	KW_OPEN		"@Open"
X#define	KW_USE		"@Use"
X#define	KW_TAGGED	"@Tagged"
X#define	KW_DATABASE	"@Database"
X#define	KW_SYSDATABASE	"@SysDatabase"
X#define	KW_INCLUDE	"@Include"
X#define	KW_SYSINCLUDE	"@SysInclude"
X#define	KW_PREPEND	"@PrependGraphic"
X#define	KW_SYSPREPEND	"@SysPrependGraphic"
X#define	KW_TARGET	"@Target"
X#define	KW_FOLLOWING	"following"
X#define	KW_PRECEDING	"preceding"
X#define	KW_NOW		"now"
X#define	KW_NULL		"@Null"
X#define	KW_GALLEY	"@Galley"
X#define	KW_INPUT	"@LInput"
X#define	KW_SPLIT	"@Split"
X#define	KW_TAG		"@Tag"
X#define	KW_KEY		"@Key"
X#define	KW_CROSS	"&&"
X
X#define	KW_LBR		"{"
X#define	KW_RBR		"}"
X#define	KW_BEGIN	"@Begin"
X#define	KW_END		"@End"
X
X#define	KW_VCAT_NN	"//"
X#define	KW_VCAT_MN	"^//"
X#define	KW_VCAT_NJ	"/"
X#define	KW_VCAT_MJ	"^/"
X#define	KW_HCAT_NN	"||"
X#define	KW_HCAT_MN	"^||"
X#define	KW_HCAT_NJ	"|"
X#define	KW_HCAT_MJ	"^|"
X#define	KW_ACAT_NJ	"&"
X#define	KW_ACAT_MJ	"^&"
X
X
X/*@::memory allocation and list macros@***************************************/
X/*                                                                           */
X/*  OBJECT GetMem(siz, pos)                                                  */
X/*  OBJECT New(typ)                                                          */
X/*  OBJECT NewWord(len, pos)                                                 */
X/*                                                                           */
X/*  Return a pointer to a new record, of appropriate length (in ALIGNs).     */
X/*  The New and NewWord versions initialise LIST, type and rec_size fields.  */
X/*  Note that NewWord must be used for WORD objects.                         */
X/*                                                                           */
X/*****************************************************************************/
X#define	USES_SIZE ceiling( sizeof(struct uses_type), sizeof(ALIGN) )
X
X#if DEBUG_ON
X#define newcount zz_newcount++,
X#else
X#define newcount
X#endif
X
X#define	GetMem(siz, pos)						\
X( newcount								\
X  (zz_size=(siz))>=MAX_OBJECT_REC ?					\
X      (OBJECT) Error(FATAL,pos,"word is too long")			\
X  : zz_free[zz_size] == nil ? zz_hold = GetMemory(zz_size, pos)		\
X  : (zz_hold = zz_free[zz_size],					\
X	zz_free[zz_size] = pred(zz_hold, CHILD), zz_hold)		\
X)
X
X#if DEBUG_ON
X#define checknew(typ)							\
X  !is_type(typ) ? Error(INTERN, no_fpos,"New: type = %s", Image(typ)) :	\
X  zz_lengths[typ] == 0 ? Error(INTERN, no_fpos, "New: 0 length!") : 0,
X#else
X#define checknew(typ)
X#endif
X
X#define	New(typ)							\
X( checknew(typ)								\
X  GetMem(zz_lengths[typ], no_fpos),					\
X  type(zz_hold) = typ,							\
X  pred(zz_hold, CHILD)  = succ(zz_hold, CHILD)  =			\
X  pred(zz_hold, PARENT) = succ(zz_hold, PARENT) = zz_hold		\
X)
X
X#define NewWord(len, pos)						\
X( zz_size = sizeof(struct word_type) + (len) - 3,			\
X  GetMem(ceiling(zz_size, sizeof(ALIGN)), pos),  /* RESETS zz_size */	\
X  rec_size(zz_hold) = zz_size,  type(zz_hold) = WORD,			\
X  pred(zz_hold, CHILD)  = succ(zz_hold, CHILD)  =			\
X  pred(zz_hold, PARENT) = succ(zz_hold, PARENT) = zz_hold		\
X)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  PutMem(x, siz)                                                           */
X/*  Dispose(x)                                                               */
X/*                                                                           */
X/*  Dispose x, which is of size siz.  Dispose works out the size itself.     */
X/*                                                                           */
X/*****************************************************************************/
X
X#if DEBUG_ON
X#define disposecount zz_disposecount++,
X#define	setdisposed  , type(zz_hold) = DISPOSED
X#else
X#define disposecount
X#define	setdisposed
X#endif
X
X#define PutMem(x, siz)							\
X( disposecount								\
X  zz_hold = (x),							\
X  zz_size = (siz),							\
X  pred(zz_hold, CHILD) = zz_free[zz_size],				\
X  zz_free[zz_size] = zz_hold						\
X)
X
X#define Dispose(x)							\
X( zz_hold = (x),							\
X  assert( pred(zz_hold, CHILD)  == zz_hold, "Dispose: pred(CHILD)!"  ),	\
X  assert( succ(zz_hold, CHILD)  == zz_hold, "Dispose: succ(CHILD)!"  ),	\
X  assert( pred(zz_hold, PARENT) == zz_hold, "Dispose: pred(PARENT)!" ),	\
X  assert( succ(zz_hold, PARENT) == zz_hold, "Dispose: succ(PARENT)!" ),	\
X  PutMem(zz_hold, type(zz_hold) == WORD ? rec_size(zz_hold)		\
X				  : zz_lengths[type(zz_hold)])		\
X  setdisposed								\
X)
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT Append(x, y, dir)                                                 */
X/*                                                                           */
X/*  Return the append of lists x and y (dir is PARENT or CHILD).             */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	Append(x, y, dir)						\
X( zz_res = (x),	zz_hold = (y),						\
X  zz_hold == nil ? zz_res  :						\
X  zz_res  == nil ? zz_hold :						\
X  ( zz_tmp = pred(zz_hold, dir),					\
X    pred(zz_hold, dir) = pred(zz_res, dir),				\
X    succ(pred(zz_res, dir), dir) = zz_hold,				\
X    pred(zz_res, dir) = zz_tmp,						\
X    succ(zz_tmp, dir) = zz_res						\
X  )									\
X)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT Delete(x, dir)                                                    */
X/*                                                                           */
X/*  Delete x from its dir list, and return succ(x, dir) or nil if none.      */
X/*                                                                           */
X/*****************************************************************************/
X
X#define Delete(x, dir)							\
X( zz_hold = (x),							\
X  succ(zz_hold, dir) == zz_hold ? nil :					\
X  ( zz_res = succ(zz_hold, dir),					\
X    pred(zz_res, dir) = pred(zz_hold, dir),				\
X    succ(pred(zz_hold, dir), dir) = zz_res,				\
X    pred(zz_hold, dir) = succ(zz_hold, dir) = zz_hold,			\
X    zz_res								\
X  )									\
X)
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DeleteAndDispose(x, dir)                                          */
X/*                                                                           */
X/*  Delete x as above, dispose it, and return succ(x, dir) or nil if none.   */
X/*                                                                           */
X/*****************************************************************************/
X
X#define DeleteAndDispose(x, dir)					\
X( zz_hold = (x),							\
X  zz_res  = succ(zz_hold, dir) == zz_hold ? nil :			\
X	    ( pred(succ(zz_hold, dir), dir) = pred(zz_hold, dir),	\
X	      succ(pred(zz_hold, dir), dir) = succ(zz_hold, dir) ),	\
X  pred(zz_hold, dir) = succ(zz_hold, dir) = zz_hold,			\
X  Dispose(zz_hold),							\
X  zz_res								\
X)
X
X#define Down(x)		succ(x, CHILD)
X#define NextDown(x)	succ(x, CHILD)
X#define LastDown(x)	pred(x, CHILD)
X#define PrevDown(x)	pred(x, CHILD)
X#define	Up(x)		succ(x, PARENT)
X#define	NextUp(x)	succ(x, PARENT)
X#define	LastUp(x)	pred(x, PARENT)
X#define	PrevUp(x)	pred(x, PARENT)
X
X#define	Child(y, link)							\
Xfor( y = pred(link, PARENT);  type(y) == LINK;  y = pred(y, PARENT) )
X
X#define	Parent(y, link)							\
Xfor( y = pred(link, CHILD);   type(y) == LINK;  y = pred(y, CHILD) )
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  UpDim(x, dim)                                                            */
X/*  DownDim(x, dim)                                                          */
X/*                                                                           */
X/*  Returns the dim'th child or parent link of node x (dim == COL or ROW).   */
X/*                                                                           */
X/*****************************************************************************/
X
X#define UpDim(x, dim)	( (dim) == COL ? succ(x, PARENT) : pred(x, PARENT) )
X#define DownDim(x, dim)	( (dim) == COL ? succ(x, CHILD) : pred(x, CHILD) )
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT Link(x, y)                                                        */
X/*                                                                           */
X/*  Make y a child of x in the directed graph, using a new link.             */
X/*  The link node is returned.                                               */
X/*                                                                           */
X/*****************************************************************************/
X
X#define Link(x, y)							\
X( xx_link = New(LINK),							\
X  Append(xx_link, (x), CHILD),						\
X  Append(xx_link, (y), PARENT)						\
X)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DeleteLink(link)                                                  */
X/*                                                                           */
X/*  Cut the link between nodes x and y of the directed graph.                */
X/*  Returns the link node of the next child of x, or x if none.              */
X/*                                                                           */
X/*****************************************************************************/
X
X#define DeleteLink(link)						\
X( xx_link = (link),							\
X  Delete(xx_link, PARENT),						\
X  DeleteAndDispose(xx_link, CHILD)					\
X)
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  DisposeChild(link)                                                       */
X/*                                                                           */
X/*  Delete link, and if its child is thereby unattached, dispose it.         */
X/*                                                                           */
X/*****************************************************************************/
X
X#define DisposeChild(link)						\
X( xx_link = (link),							\
X  xx_tmp = Delete(xx_link, PARENT),					\
X  DeleteAndDispose(xx_link, CHILD),					\
X  succ(xx_tmp, PARENT) == xx_tmp ? DisposeObject(xx_tmp) : 0		\
X) /* end DisposeChild */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  MoveLink(link, x, dir)                                                   */
X/*                                                                           */
X/*  Move the dir end of link from wherever it is now to node x.              */
X/*                                                                           */
X/*****************************************************************************/
X
X#define MoveLink(link, x, dir)						\
X( xx_link = (link),							\
X  Delete(xx_link, 1 - (dir) ),						\
X  Append(xx_link, (x), 1 - (dir) )					\
X) /* end MoveLink */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  TransferLinks(start_link, stop_link, dest_link)                          */
X/*                                                                           */
X/*  Move parent end of links start_link (inclusive) to stop_link (exclusive) */
X/*  to just before dest_link.                                                */
X/*                                                                           */
X/*****************************************************************************/
X
X#define TransferLinks(start_link, stop_link, dest_link)			\
X{ OBJECT xxstart = start_link, xxstop = stop_link, xxdest = dest_link;	\
X  if( xxstart != xxstop )						\
X  {	assert( type(xxstart) == LINK, "TransferLinks: start_link!" );	\
X	Append(xxstart, xxstop, CHILD); /* actually a split */		\
X	Append(xxstart, xxdest, CHILD);					\
X  }									\
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  DeleteNode(x)                                                            */
X/*                                                                           */
X/*  Delete node x and every edge attaching to x.                             */
X/*                                                                           */
X/*****************************************************************************/
X
X#define DeleteNode(x)							\
X{ xx_hold = (x);							\
X  while( Up(xx_hold)   != xx_hold ) DeleteLink( Up(xx_hold) );		\
X  while( Down(xx_hold) != xx_hold ) DeleteLink( Down(xx_hold) );	\
X  Dispose(xx_hold);							\
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  MergeNode(x, y)                                                          */
X/*                                                                           */
X/*  Take all the children of y and make them children of x.                  */
X/*  Take all the parents of y and make them parents of x.  Dispose y.        */
X/*                                                                           */
X/*****************************************************************************/
X
X#define MergeNode(x, y)							\
X{ xx_res = (x); xx_hold = (y);						\
X  xx_tmp = Delete(xx_hold, PARENT);					\
X  Append(xx_res, xx_tmp, PARENT);					\
X  xx_tmp = DeleteAndDispose(xx_hold, CHILD);				\
X  Append(xx_res, xx_tmp, CHILD);					\
X}  /* end MergeNode */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  ReplaceNode(x, y)                                                        */
X/*                                                                           */
X/*  Move all the parent links of y to x.                                     */
X/*                                                                           */
X/*****************************************************************************/
X
X#define ReplaceNode(x, y)						\
X( xx_tmp = Delete((y), PARENT),						\
X  Append((x), xx_tmp, PARENT)						\
X) /* end ReplaceNode */
X
X
X/*@::scanning catenation objects@*********************************************/
X/*                                                                           */
X/*  FirstDefinite(x, link, y)                                                */
X/*                                                                           */
X/*  On input, x is an object and link and y are undefined.  On output there  */
X/*  are two cases:                                                           */
X/*                                                                           */
X/*  link != x.  Then y is first definite child of x and link is its link.    */
X/*                                                                           */
X/*  link == x.  Then x has no definite child and y is undefined.             */
X/*                                                                           */
X/*  A SPLIT object is considered to be definite if both its children are     */
X/*  definite.  This condition is returned by SplitIsDefinite.                */
X/*                                                                           */
X/*****************************************************************************/
X
X#define FirstDefinite(x, link, y)					\
X{ for( link = Down(x);  link != x;  link = NextDown(link) )		\
X  { Child(y, link);							\
X    if( type(y) == SPLIT ? SplitIsDefinite(y) : is_definite(type(y)) )	\
X	break;								\
X  }									\
X} /* end FirstDefinite */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  NextDefinite(x, link, y)                                                 */
X/*                                                                           */
X/*  On input, x is an object and link is a link to one of its children; y    */
X/*  is undefined.  On output there are two cases:                            */
X/*                                                                           */
X/*  link != x.  Then y is the first definite child of x following link, and  */
X/*              link is changed to be the link of y.                         */
X/*                                                                           */
X/*  link == x.  Then x has no definite child following link, and y remains   */
X/*              undefined.                                                   */
X/*                                                                           */
X/*****************************************************************************/
X
X#define NextDefinite(x, link, y)					\
X{ for( link = NextDown(link);  link != x;  link = NextDown(link) )	\
X  { Child(y, link);							\
X    if( type(y) == SPLIT ? SplitIsDefinite(y) : is_definite(type(y)) )	\
X	break;								\
X  }									\
X} /* end NextDefinite */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  NextDefiniteWithGap(x, link, y, g)                                       */
X/*                                                                           */
X/*  On input, x is an object and link is a link to one of its children; y    */
X/*  and g are undefined.  On output there are two cases:                     */
X/*                                                                           */
X/*  link != x.  Then y is the first definite child of x following link, and  */
X/*              link is changed to be the link of y.  Also, g is defined     */
X/*              to be the gap just before y; this must exist and is tested   */
X/*              by an assert test.                                           */
X/*                                                                           */
X/*  link == x.  Then x has no definite child following link, and y and g     */
X/*              remain undefined.                                            */
X/*                                                                           */
X/*****************************************************************************/
X
X#define NextDefiniteWithGap(x, link, y, g)				\
X{ g = nil;								\
X  for( link = NextDown(link);  link != x;  link = NextDown(link) )	\
X  { Child(y, link);							\
X    if( type(y) == GAP_OBJ )  g = y;					\
X    else if( type(y)==SPLIT ? SplitIsDefinite(y):is_definite(type(y)) )	\
X    { assert( g != nil, "NextDefinite: g == nil!" );			\
X      break;								\
X    }									\
X  }									\
X} /* end NextDefiniteWithGap */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  LastDefinite(x, link, y)                                                 */
X/*                                                                           */
X/*  On input, x is an object and link and y are undefined.  On output there  */
X/*  are two cases:                                                           */
X/*                                                                           */
X/*  link != x.  Then y is the last definite child of x and link is its link. */
X/*                                                                           */
X/*  link == x.  Then x has no definite child and y is undefined.             */
X/*                                                                           */
X/*  A SPLIT object is considered to be definite if both its children are     */
X/*  definite.  This condition is returned by SplitIsDefinite.                */
X/*                                                                           */
X/*****************************************************************************/
X
X#define LastDefinite(x, link, y)					\
X{ for( link = LastDown(x);  link != x;  link = PrevDown(link) )		\
X  { Child(y, link);							\
X    if( type(y) == SPLIT ? SplitIsDefinite(y) : is_definite(type(y)) )	\
X	break;								\
X  }									\
X} /* end LastDefinite */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  PrevDefinite(x, link, y)                                                 */
X/*                                                                           */
X/*  On input, x is an object and link is a link to one of its children; y    */
X/*  is undefined.  On output there are two cases:                            */
X/*                                                                           */
X/*  link != x.  Then y is the first definite child of x preceding link, and  */
X/*              link is changed to be the link of y.                         */
X/*                                                                           */
X/*  link == x.  Then x has no definite child preceding link, and y remains   */
X/*              undefined.                                                   */
X/*                                                                           */
X/*****************************************************************************/
X
X#define PrevDefinite(x, link, y)					\
X{ for( link = PrevDown(link);  link != x;  link = PrevDown(link) )	\
X  { Child(y, link);							\
X    if( type(y) == SPLIT ? SplitIsDefinite(y) : is_definite(type(y)) )	\
X	break;								\
X  }									\
X} /* end PrevDefinite */
X
X
X/*@::module declarations@*****************************************************/
X/*                                                                           */
X/*  MODULE DECLARATIONS                                                      */
X/*                                                                           */
X/*****************************************************************************/
X
X/*****  z01.c		Start Up		******************************/
Xextern			main();			/* main program              */
Xextern	OBJECT		StartSym;		/* sym tab entry for \Start  */
Xextern	OBJECT		GalleySym;		/* sym tab entry for @Galley */
Xextern	OBJECT		InputSym;		/* sym tab entry for \Input  */
Xextern	OBJECT		PrintSym;		/* sym tab entry for \Print  */
Xextern	BOOLEAN		AllowCrossDb;		/* true when -s flag absent  */
Xextern	BOOLEAN		Encapsulated;		/* true when eps wanted      */
Xextern	BOOLEAN		StringBeginsWith();	/* string compare            */
Xextern	BOOLEAN		StringContains();	/* string search             */
X
X/*****  z02.c		Lexical Analyser	******************************/
Xextern			LexInit();		/* initialise lex. analyser  */
Xextern			LexPush();		/* switch to new file list   */
Xextern			LexPop();		/* return to prev. file list */
Xextern	BOOLEAN		LexLegalName();		/* check identifier format   */
Xextern	OBJECT		LexGetToken();		/* get next token from input */
Xextern	long		LexNextTokenPos();	/* like ftell() on curr file */
X
X/*****  z03.c		File Service	        ******************************/
Xextern	FILE_POS	*no_fpos;		/* a null filepos            */
Xextern			InitFiles();		/* initialize this module    */
Xextern			AddToPath();		/* add directory to path     */
Xextern	FILE_NUM	DefineFile();		/* declare input file        */
Xextern	FILE_NUM	FirstFile();		/* first file of given type  */
Xextern	FILE_NUM	NextFile();		/* next file of given type   */
Xextern	FILE_NUM	FileNum();		/* file with given name      */
Xextern	unsigned char	*FileName();		/* file name of file         */
Xextern	unsigned char	*EchoFilePos();		/* string value of FILE_POS  */
Xextern	FILE_POS	*PosOfFile();		/* string of file's FILE_POS */
Xextern	FILE		*OpenFile();		/* open file for reading     */
Xextern	FILE		*OpenIncGraphicFile();	/* open @IncludeGraphic file */
Xextern	OBJECT		ReadFromFile();		/* read object from file     */
Xextern			AppendToFile();		/* append object to file     */
Xextern			CloseFiles();		/* close database files      */
X
X/*****  z04.c		Token Service	        ******************************/
Xextern	OBJECT		NewToken();		/* get a new token           */
Xextern	OBJECT		CopyTokenList();	/* copy a list of tokens     */
Xextern	unsigned char	*EchoCatOp();		/* string value of CAT op    */
Xextern	unsigned char	*EchoToken();		/* returns image of token    */
X
X/*****  z05.c		Definitions Reader	******************************/
Xextern			ReadDefinitions();	/* read definitions          */
X
X/*****  z06.c		Parser			******************************/
Xextern			InitParser();		/* initialise parser         */
Xextern	OBJECT		Parse();		/* parser                    */
X
X/*****  z07.c		Object Service	        ******************************/
Xextern	OBJECT		MakeWord();		/* a new WORD object         */
Xextern	OBJECT		MakeWordTwo();		/* a new WORD object         */
Xextern	OBJECT		CopyObject();		/* make a copy of an object  */
Xextern			DisposeObject();	/* dispose an object         */
Xextern	BOOLEAN		SplitIsDefinite();	/* TRUE if SPLIT is definite */
X
X/*****  z08.c		Object Manifest	        ******************************/
Xextern	OBJECT		ReplaceWithTidy();	/* tidy up an object         */
Xextern	OBJECT		Manifest();		/* manifest an object        */
X
X/*****  z09.c		Closure Expansion	******************************/
Xextern	OBJECT		SetEnv();		/* build up environment      */
Xextern			AttachEnv();		/* attach env. to object     */
Xextern	OBJECT		SearchEnv();		/* search environment        */
Xextern	OBJECT		GetEnv();		/* retrieve env. from object */
Xextern	OBJECT		DetachEnv();		/* retrieve and detach env.  */
Xextern	OBJECT		ClosureExpand();	/* expand a user-def CLOSURE */
X
X/*****  z10.c		Cross References	******************************/
Xextern			CrossInit();		/* initialize cr record      */
Xextern	OBJECT		CrossGenTag();		/* generates a tag           */
Xextern	OBJECT		CrossMake();		/* returns a cross-reference */
Xextern	OBJECT		GallTargEval();		/* returns the value of a cr */
Xextern	OBJECT		CrossExpand();		/* returns the value of a cr */
Xextern			CrossSequence();	/* record cr off root galley */
Xextern			CrossClose();		/* close down this module    */
X
X/*****  z11.c		Style Service		******************************/
Xextern			BreakChange();		/* change line spacing       */
Xextern			SpaceChange();		/* change word spacing       */
Xextern	unsigned char	*EchoStyle();		/* string value of a style   */
X
X/*****  z12.c		Size Finder		******************************/
Xextern	OBJECT		MinSize();		/* min. possible size of obj */
X
X/*****  z13.c		Object Breaking		******************************/
Xextern	OBJECT		BreakObject();		/* break object to fit width */
X
X/*****  z14.c		Object Filling	        ******************************/
Xextern	OBJECT		FillObject();		/* optimal paragraph breaker */
Xextern	OBJECT		SimpleFillObject();	/* simple paragraph breaker  */
X
X/*****  z15.c		Size Constraints	******************************/
Xextern	unsigned char	*EchoConstraint();	/* string value of a constr. */
Xextern			MinConstraint();	/* take minimum of two const */
Xextern			EnlargeToConstraint();	/* enlarge obj to constraint */
Xextern			RotateConstraint();	/* rotate constraints        */
Xextern			InvScaleConstraint();	/* inverse scale a constr.   */
Xextern			Constrained();		/* finds size constraint     */
Xextern			DebugConstrained();	/* debug constraint code     */
X
X/*****  z16.c		Size Adjustments	******************************/
Xextern			SetNeighbours();	/* locate definite neighbours*/
Xextern			AdjustSize();		/* updates sizes if changed  */
X
X/*****  z17.c		Gap Widths		******************************/
Xextern			GetGap();		/* convert string gap to num */
Xextern	LENGTH		MinGap();		/* min. possible gap width   */
Xextern	LENGTH		ExtraGap();		/* extra available gap width */
Xextern	LENGTH		ActualGap();		/* gap width for output      */
Xextern	unsigned char	*EchoGap();		/* echo gap (cat. operator)  */
X
X/*****  z18.c		Galley Transfer		******************************/
Xextern			TransferInit();		/* initialise this module    */
Xextern	OBJECT		TransferBegin();	/* begin transfer of galley  */
Xextern			TransferComponent();	/* transfer one component    */
Xextern			TransferEnd();		/* end galley transfer       */
Xextern			TransferClose();	/* close this module         */
X
X/*****  z19.c		Galley Attaching	******************************/
Xextern	OBJECT		SearchGalley();		/* search galley for target  */
Xextern			AttachGalley();		/* start off a galley        */
Xextern			DetachGalley();		/* detach a galley           */
X
X/*****  z20.c		Galley Flushing		******************************/
Xextern			FlushGalley();		/* flush out a galley        */
X
X/***    z21.c		Galley Maker		******************************/
Xextern			SizeGalley();		/* convert object to galley  */
X
X/***    z22.c		Galley Service		******************************/
Xextern			FlushInners();		/* flush a list of galleys.  */
Xextern			ExpandRecursives();	/* expand recursive definite */
Xextern			Promote();		/* promote components        */
Xextern			KillGalley();		/* destroy a galley          */
Xextern			FreeGalley();		/* free a galley to flush    */
Xextern			Interpose();		/* interpose a VCAT          */
Xextern	BOOLEAN		TargetSymbol();		/* find target of galley     */
Xextern	int		CheckConstraint();	/* check ordering constraint */
X
X/*****  z23.c		Galley Printer		******************************/
Xextern			FixAndPrintObject();	/* fix and print component   */
X
X/*****  z24.c		Back End                ******************************/
Xextern			PrintInit();		/* initialise this module    */
Xextern			FontStripQuotes();	/* convert quoted string     */
Xextern			FontDefine();		/* define a font             */
Xextern			FontChange();		/* change current font       */
Xextern			FontAtomSize();		/* set sizes of an atom      */
Xextern	LENGTH		FontSize();		/* size of current font      */
Xextern			PrintPrologue();	/* print output prologue     */
Xextern			PrintOriginIncrement();	/* reset current o/p origin  */
Xextern			PrintAtom();		/* print atom at given pos   */
Xextern			PrintClose();		/* wrapup output stream      */
Xextern			CoordTranslate();	/* translate coord system    */
Xextern			CoordRotate();		/* rotate coord system       */
Xextern			CoordScale();		/* scale coord system        */
Xextern			SaveGraphicState();	/* save coord system etc.    */
Xextern			RestoreGraphicState();	/* restore coord system etc. */
Xextern			DefineGraphicNames();	/* define xsize, ysize, etc. */
Xextern			PrintGraphicObject();	/* print PostScript object   */
Xextern			PrintGraphicInclude();	/* include PostScript file   */
X
X/*****  z25.c		Object Echo	        ******************************/
Xextern	unsigned char	*EchoObject();		/* print object, file or str */
X
X/*****  z26.c		Echo Service	        ******************************/
Xextern			BeginString();		/* begin string accumulator  */
Xextern			AppendString();		/* append to current string  */
Xextern	unsigned char	*EndString();		/* return current string     */
Xextern	unsigned char	*EchoLength();		/* echo a length             */
Xextern	unsigned char	*Image();		/* string value of type(x)   */
X
X/*****	z27.c		Debug Service		******************************/
Xextern			DebugInit();		/* set debug flag            */
Xextern			Debug();		/* print debug o/p on stderr */
Xextern			ProfileOn();		/* start profiling           */
Xextern			ProfileOff();		/* stop profiling            */
Xextern			ProfilePrint();		/* print profiling results   */
X
X/*****	z28.c		Error Service		******************************/
Xextern			ErrorInit();		/* initialise log file       */
Xextern			Error();		/* print error message       */
Xextern	BOOLEAN		ErrorSeen();		/* TRUE after first error    */
Xextern			EnterErrorBlock();	/* new block of error mess's */
Xextern			LeaveErrorBlock();	/* commit or discard block   */
X
X/*****  z29.c		Symbol Table		******************************/
Xextern			InitSym();		/* initialize table to empty */
Xextern			PushScope();		/* push a new scope on stack */
Xextern			PopScope();		/* pop a scope from stack    */
Xextern			SuppressVisible();	/* suppress visible flag     */
Xextern			UnSuppressVisible();	/* unsuppress visible flag   */
Xextern			SuppressScope();	/* suppress all scoping      */
Xextern			UnSuppressScope();	/* unsuppress scoping        */
Xextern			SwitchScope();		/* switch to a saved scope   */
Xextern			UnSwitchScope();	/* switch back from saved s. */
Xextern			BodyParAllowed();	/* let body par be invoked   */
Xextern			BodyParNotAllowed();	/* don't let body par be inv */
Xextern	OBJECT		SearchSym();		/* search table for symbol   */
Xextern	OBJECT		InsertSym();		/* insert a new symbol       */
Xextern			DeleteEverySym();	/* dispose all symbols       */
Xextern	unsigned char	*SymName();		/* string name of a symbol   */
Xextern	unsigned char	*FullSymName();		/* full path name of symbol  */
Xextern	OBJECT		ChildSym();		/* return a child of a sym   */
Xextern			CheckSymSpread();	/* check hash table spread   */
X
X/*****  z30.c		Symbol Uses		******************************/
Xextern			InsertUses();		/* record symbol x uses y    */
Xextern			FlattenUses();		/* massage uses relation     */
Xextern	BOOLEAN		SearchUses();		/* retrieve uses info        */
Xextern	OBJECT		FirstExternTarget();	/* together these return all */
Xextern	OBJECT		NextExternTarget();	/*   targets of extern galls */
X
X/*****  z31.c		Memory Allocator	******************************/
Xextern			MemInit();		/* initialise mem. allocator */
Xextern	OBJECT		GetMemory();		/* get some fresh memory     */
Xextern			DebugMemory();		/* print memory usage        */
Xextern	OBJECT		zz_free[];		/* array of free lists       */
Xextern	unsigned char	zz_lengths[];		/* array of record lengths   */
Xextern	int		zz_newcount;		/* debug count of New calls  */
Xextern	int		zz_disposecount;	/* debug count of Disposes   */
Xextern	OBJECT		zz_hold;		/* temporary variable only   */
Xextern	OBJECT		zz_tmp;			/* temporary variable only   */
Xextern	OBJECT		zz_res;			/* temporary variable only   */
Xextern	int		zz_size;		/* temporary variable only   */
Xextern	OBJECT		xx_link, xx_tmp;	/* temporary variable only   */
Xextern	OBJECT		xx_hold, xx_res;	/* temporary variable only   */
X
X/*****  z32.c		Counter Service		******************************/
Xextern	OBJECT		Next();			/* increment argument by one */
X
X/*****  z33.c		Database Service	******************************/
Xextern	OBJECT		OldCrossDb;		/* cross refs from last run  */
Xextern	OBJECT		NewCrossDb;		/* cross refs from this run  */
Xextern	OBJECT		DbCreate();		/* create writable database  */
Xextern			DbInsert();		/* insert into database      */
Xextern			DbConvert();		/* con. writable to readable */
Xextern	OBJECT		DbLoad();		/* open readable database    */
Xextern	BOOLEAN		DbRetrieve();		/* retrieve from database    */
Xextern	BOOLEAN		DbRetrieveNext();	/* next entry from database  */
X
X/*****  z34.c		Rotation Service    	******************************/
Xextern			RotateSize();		/* calculate rotated size    */
X
X/*****  z35.c		Time Keeper     	******************************/
Xextern	OBJECT		MomentSym;		/* the @Moment symbol        */
Xextern			InitTime();		/* initialize this module    */
Xextern	OBJECT		StartMoment();		/* a copy of the init time   */
Xextern	unsigned char	*TimeString();		/* a string containing time  */
X
X/*****  z36.c		Hyphenation     	******************************/
Xextern	OBJECT		Hyphenate();		/* hyphenate a paragraph     */
X
X/*@::assert and debug code@***************************************************/
X/*                                                                           */
X/*  ASSERT AND DEBUG CODE                                                    */
X/*                                                                           */
X/*****************************************************************************/
X
X#if ASSERT_ON
X#define assert(c, m)							\
X   ( (c) ? 0 : Error(INTERN, no_fpos, "Assert failed in %s", m) )
X#else
X#define assert(c, m)	0
X#endif
X
X#if DEBUG_ON
X
Xstruct dbs
X{	unsigned char	*flag;		/* external names for debug flags    */
X	BOOLEAN	on[3];			/* the debug flags                   */
X};
Xextern	struct dbs 	dbg[];
X
X/* debug routines */
X#define debug0(cat, urg, str)                				\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str); else
X#define debug1(cat, urg, str, p1)					\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1); else
X#define debug2(cat, urg, str, p1, p2)					\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2); else
X#define debug3(cat, urg, str, p1, p2, p3)				\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2, p3); else
X#define debug4(cat, urg, str, p1, p2, p3, p4)				\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2, p3, p4); else
X#define debug5(cat, urg, str, p1, p2, p3, p4, p5)			\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2, p3, p4, p5); else
X#define debug6(cat, urg, str, p1, p2, p3, p4, p5, p6)			\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2, p3, p4, p5, p6); else
X#define debug7(cat, urg, str, p1, p2, p3, p4, p5, p6, p7)		\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2, p3, p4, p5,p6,p7); else
X#define debug8(cat, urg, str, p1, p2, p3, p4, p5, p6, p7, p8)		\
X    if( dbg[cat].on[urg] ) Debug(cat, urg, str, p1, p2,p3,p4,p5,p6,p7,p8); else
X#define	ifdebug(cat, urg, x)						\
X    if( dbg[cat].on[urg] ) { x; } else 
X#define	debug_init(str)							\
X    DebugInit(str)
X
X/* debug styles */
X#define	D	 0
X#define	DD	 1
X#define	DDD	 2
X
X/* debug flags */
X#define	DSP	 1		/*  z01.c   -dsp   Supervise                 */
X#define	DLA	 2		/*  z02.c   -dla   Lexical Analyser          */
X#define	DFS	 3		/*  z03.c   -dfs   File Service              */
X#define	DTS	 4		/*  z04.c   -dts   Token Service             */
X#define	DRD	 5		/*  z05.c   -drd   Read Definitions          */
X#define	DOP	 6		/*  z06.c   -dop   Object Parser             */
X#define	DOS	 7		/*  z07.c   -dos   Object Service            */
X#define	DOM	 8		/*  z08.c   -dom   Object Manifest           */
X#define	DCE	 9		/*  z09.c   -dce   Closure Expansion         */
X#define	DCR	10		/*  z10.c   -dcr   Cross References	     */
X#define	DSS	11		/*  z11.c   -dss   Style Service	     */
X#define	DSF	12		/*  z12.c   -dsf   Size Finder               */
X#define	DOB	13		/*  z13.c   -dob   Object Breaking	     */
X#define	DOF	14		/*  z14.c   -dof   Object Filling	     */
X#define	DSC	15		/*  z15.c   -dsc   Size Constraints          */
X#define	DSA	16		/*  z16.c   -dsa   Size Adjustments	     */
X#define	DGW	17		/*  z17.c   -dgw   Gap Widths                */
X#define	DGT	18		/*  z18.c   -dgt   Galley Transfer           */
X#define	DGA	19		/*  z19.c   -dgf   Galley Attaching          */
X#define	DGF	20		/*  z20.c   -dgf   Galley Flushing           */
X#define	DGM	21		/*  z21.c   -dgm   Galley Maker              */
X#define	DGS	22		/*  z22.c   -dgs   Galley Service            */
X#define	DGP	23		/*  z23.c   -dgp   Galley Printer            */
X#define	DFT	24		/*  z24.c   -dft   Font Tables               */
X#define	DOE	25		/*  z25.c   -doe   Object Echo               */
X#define	DES	26		/*  z26.c   -des   Echo Service		     */
X#define	DZZ	27		/*  z27.c   -dzz   Debug Service             */
X#define	DYY	28		/*  z28.c   -dyy   Error Service             */
X#define	DST	29		/*  z29.c   -dst   Symbol Table              */
X#define	DSU	30		/*  z30.c   -dsu   Symbol Uses               */
X#define	DMA	31		/*  z31.c   -dma   Memory Allocator          */
X#define	DCS	32		/*  z32.c   -dcs   Counter Service           */
X#define	DBS	33		/*  z33.c   -dbs   Database Service          */
X#define	DRS	34		/*  z34.c   -drs   Rotation Service          */
X#define	DTK	35		/*  z35.c   -dtk   Time Keeper               */
X#define	DHY	36		/*  z36.c   -dhy   Hyphenation               */
X#define	DPP	37		/*          -dpp   Profiling                 */
X#define	ANY	38		/*          -d     any                       */
X
X#else
X#define ifdebug(cat, urg, x)
X#define debug0(cat, urg, str)
X#define debug1(cat, urg, str, p1)
X#define debug2(cat, urg, str, p1, p2)
X#define debug3(cat, urg, str, p1, p2, p3)
X#define debug4(cat, urg, str, p1, p2, p3, p4)
X#define debug5(cat, urg, str, p1, p2, p3, p4, p5)
X#define debug6(cat, urg, str, p1, p2, p3, p4, p5, p6)
X#define debug7(cat, urg, str, p1, p2, p3, p4, p5, p6, p7)
X#define debug8(cat, urg, str, p1, p2, p3, p4, p5, p6, p7, p8)
X#define	debug_init(str)	Error(FATAL, no_fpos,			\
X			"%s - debug flags not implemented", str)
X#endif
END_OF_FILE
  if test 79673 -ne `wc -c <'lout/externs'`; then
    echo shar: \"'lout/externs'\" unpacked with wrong size!
  fi
  # end of 'lout/externs'
fi
echo shar: End of archive 2 \(of 30\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
