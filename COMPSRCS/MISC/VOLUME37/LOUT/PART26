Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i124:  lout - Lout document formatting system, v2, Part26/30
Message-ID: <1993Jun2.030540.29011@sparky.imd.sterling.com>
X-Md4-Signature: 7edaa7b846957eb948cbb83fa8c3edc3
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 2 Jun 1993 03:05:40 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 124
Archive-name: lout/part26
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/data/loutrefs.ld lout/data/standard.ld
#   lout/doc/tr.begin/s02 lout/doc/tr.begin/s03 lout/doc/tr.eq/s6
#   lout/doc/tr.fig/s3 lout/doc/tr.impl/oldrefs.ld
#   lout/doc/tr.impl/s3.3 lout/doc/tr.impl/s5.1
#   lout/doc/tr.lout/ch2.01 lout/doc/tr.lout/ch2.05
#   lout/doc/tr.lout/ch3.07 lout/z32.c lout/z34.c
# Wrapped by kent@sparky on Sun May 30 19:44:01 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 26 (of 30)."'
if test -f 'lout/data/loutrefs.ld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/data/loutrefs.ld'\"
else
  echo shar: Extracting \"'lout/data/loutrefs.ld'\" \(5677 characters\)
  sed "s/^X//" >'lout/data/loutrefs.ld' <<'END_OF_FILE'
X{ @Reference
X     @Tag { knuth84 }
X     @Type { Book }
X     @Author { Knuth, Donald E. }
X     @Title { The T{ /0.2fo E}XBook }
X     @Publisher { Addison-Wesley }
X     @Year { 1984 }
X}
X
X{ @Reference
X     @Tag { adobe90 }
X     @Type { Book }
X     @Author { Adobe Systems, Inc. }
X     @Title { PostScript Language Reference Manual, Second Edition }
X     @Publisher { Addison-Wesley }
X     @Year { 1990 }
X}
X
X{ @Reference
X     @Tag { reid80 }
X     @Type { ConferencePaper }
X     @Author { Reid, Brian K. }
X     @Title { A High-Level Approach to Computer Document Production }
X     @Proceedings { Proceedings of the 7th Symposium on the Principles
Xof Programming Languages (POPL), Las Vegas NV }
X     @Pages { 24--31 }
X     @Year { 1980 }
X}
X
X{ @Reference
X     @Tag { strunk79 }
X     @Type { Book }
X     @Author { Strunk, William and White, E. B. }
X     @Title { The Elements of Style }
X     @Publisher { Macmillan, third edition }
X     @Year { 1979 }
X}
X
X{ @Reference
X     @Tag { ossanna76 }
X     @Type { TechReport }
X     @Author { Joseph F. Ossanna }
X     @Title { "Nroff/Troff" User's Manual }
X     @Number { 54 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan75 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. and Cherry, Lorinda L. }
X     @Title { A system for typesetting mathematics }
X     @Journal { Communications of the ACM }
X     @Volume { 18 }
X     @Pages { 182--193 }
X     @Year { 1975 }
X}
X
X{ @Reference
X     @Tag { lesk76 }
X     @Type { TechReport }
X     @Author { Lesk, M. E. }
X     @Title { Tbl -- a program to format tables }
X     @Number { 49 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan82 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. }
X     @Title { PIC -- A language for typesetting graphics}
X     @Journal { Software Practice and Experience }
X     @Volume { 12 }
X     @Pages { 1--21 }
X     @Year { 1982 }
X}
X
X{ @Reference
X     @Tag { kingston93basser }
X     @Type { Software }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The Basser Lout Document Formatter, Version 2.03 }
X     @Year { 1993 }
X     @Comment { Computer program, publicly available in the
X@I jeff subdirectory of the home directory of @I ftp to host
X@I ftp.cs.su.oz.au with login name @I anonymous or @I ftp and any
Xnon-empty password (e.g. {@I none}).  Distribution via email is
Xavailable for non-{@I ftp} sites.  All enquiries to "jeff@cs.su.oz.au". }
X}
X
X{ @Reference
X     @Tag { kingston92 }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Document Formatting with Lout (Second Edition) }
X     @Number { 449 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92begin }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A beginners' guide to Lout }
X     @Number { 450 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92eq }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Eq -- a Lout package for typesetting mathematics }
X     @Number { 452 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X     @Comment { Contains an appendix describing the Pas Pascal
Xformatter. }
X}
X
X{ @Reference
X     @Tag { kingston92fig }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Fig -- a Lout package for drawing figures }
X     @Number { 453 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston91over }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A new approach to document formatting }
X     @Number { 412 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston92tab }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Tab -- a Lout package for formatting tables }
X     @Number { 451 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92design }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The design and implementation of the Lout document formatting language }
X     @Number { 442 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X     @Comment { To appear in @I { Software---Practice and Experience. } }
X}
X
X{ @Reference
X     @Tag { wirth71 }
X     @Type { JournalArticle }
X     @Author { Wirth, N. }
X     @Title { The programming language Pascal }
X     @Journal { Acta Informatica }
X     @Volume { 1 }
X     @Year { 1975 }
X     @Pages { 35--63 }
X}
X
X{ @Reference
X     @Tag { brooks91 }
X     @Type { JournalArticle }
X     @Author { Brooks, Kenneth P. }
X     @Title { Lilac: a two-view document editor }
X     @Journal { IEEE Computer }
X     @Volume { @Null }
X     @Pages { 7--19 }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { furuta82 }
X     @Type { JournalArticle }
X     @Author { Furuta, Richard, Scofield, Jeffrey,
Xand Shaw, Alan }
X     @Title { Document formatting systems:  survey,
Xconcepts, and issues }
X     @Journal { Computing Surveys }
X     @Volume { 14 }
X     @Pages { 417--472 }
X     @Year { 1982 }
X}
END_OF_FILE
  if test 5677 -ne `wc -c <'lout/data/loutrefs.ld'`; then
    echo shar: \"'lout/data/loutrefs.ld'\" unpacked with wrong size!
  fi
  # end of 'lout/data/loutrefs.ld'
fi
if test -f 'lout/data/standard.ld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/data/standard.ld'\"
else
  echo shar: Extracting \"'lout/data/standard.ld'\" \(7113 characters\)
  sed "s/^X//" >'lout/data/standard.ld' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  standard.ld                  Jeffrey H. Kingston  #
X#                                     February 1991  #
X#                                                    #
X#  Database of commonly used symbols:                #
X#                                                    #
X#    @Roman         lower case Roman numerals        #
X#    @UCRoman       upper case Roman numerals        #
X#    @Alpha         lower case Roman alphabet        #
X#    @UCAlpha       upper case Roman alphabet        #
X#    @Months        months of the year               #
X#    @ShortMonths   months of the year, abbreviated  #
X#    @WeekDays      days of the week                 #
X#    @ShortWeekDays days of the week, abbreviated    #
X#                                                    #
X######################################################
X
X{   1 @Roman i		}
X{   2 @Roman ii		}
X{   3 @Roman iii	}
X{   4 @Roman iv		}
X{   5 @Roman v		}
X{   6 @Roman vi		}
X{   7 @Roman vii	}
X{   8 @Roman viii	}
X{   9 @Roman ix		}
X{  10 @Roman x		}
X{  11 @Roman xi		}
X{  12 @Roman xii	}
X{  13 @Roman xiii	}
X{  14 @Roman xiv	}
X{  15 @Roman xv		}
X{  16 @Roman xvi	}
X{  17 @Roman xvii	}
X{  18 @Roman xviii	}
X{  19 @Roman xix	}
X{  20 @Roman xx		}
X{  21 @Roman xxi	}
X{  22 @Roman xxii	}
X{  23 @Roman xxiii	}
X{  24 @Roman xxiv	}
X{  25 @Roman xxv	}
X{  26 @Roman xxvi	}
X{  27 @Roman xxvii	}
X{  28 @Roman xxviii	}
X{  29 @Roman xxix	}
X{  30 @Roman xxx	}
X{  31 @Roman xxxi	}
X{  32 @Roman xxxii	}
X{  33 @Roman xxxiii	}
X{  34 @Roman xxxiv	}
X{  35 @Roman xxxv	}
X{  36 @Roman xxxvi	}
X{  37 @Roman xxxvii	}
X{  38 @Roman xxxviii	}
X{  39 @Roman xxxix	}
X{  40 @Roman xl		}
X{  41 @Roman xli	}
X{  42 @Roman xlii	}
X{  43 @Roman xliii	}
X{  44 @Roman xliv	}
X{  45 @Roman xlv	}
X{  46 @Roman xlvi	}
X{  47 @Roman xlvii	}
X{  48 @Roman xlviii	}
X{  49 @Roman xlix	}
X{  50 @Roman l		}
X{  51 @Roman li		}
X{  52 @Roman lii	}
X{  53 @Roman liii	}
X{  54 @Roman liv	}
X{  55 @Roman lv		}
X{  56 @Roman lvi	}
X{  57 @Roman lvii	}
X{  58 @Roman lviii	}
X{  59 @Roman lix	}
X{  60 @Roman lx		}
X{  61 @Roman lxi	}
X{  62 @Roman lxii	}
X{  63 @Roman lxiii	}
X{  64 @Roman lxiv	}
X{  65 @Roman lxv	}
X{  66 @Roman lxvi	}
X{  67 @Roman lxvii	}
X{  68 @Roman lxviii	}
X{  69 @Roman lxix	}
X{  70 @Roman lxx	}
X{  71 @Roman lxxi	}
X{  72 @Roman lxxii	}
X{  73 @Roman lxxiii	}
X{  74 @Roman lxxiv	}
X{  75 @Roman lxxv	}
X{  76 @Roman lxxvi	}
X{  77 @Roman lxxvii	}
X{  78 @Roman lxxviii	}
X{  79 @Roman lxxix	}
X{  80 @Roman lxxx	}
X{  81 @Roman lxxxi	}
X{  82 @Roman lxxxii	}
X{  83 @Roman lxxxiii	}
X{  84 @Roman lxxxiv	}
X{  85 @Roman lxxxv	}
X{  86 @Roman lxxxvi	}
X{  87 @Roman lxxxvii	}
X{  88 @Roman lxxxviii	}
X{  89 @Roman lxxxix	}
X{  90 @Roman xc		}
X{  91 @Roman xci	}
X{  92 @Roman xcii	}
X{  93 @Roman xciii	}
X{  94 @Roman xciv	}
X{  95 @Roman xcv	}
X{  96 @Roman xcvi	}
X{  97 @Roman xcvii	}
X{  98 @Roman xcviii	}
X{  99 @Roman xcix	}
X{ 100 @Roman c		}
X
X{   1 @UCRoman I	}
X{   2 @UCRoman II	}
X{   3 @UCRoman III	}
X{   4 @UCRoman IV	}
X{   5 @UCRoman V	}
X{   6 @UCRoman VI	}
X{   7 @UCRoman VII	}
X{   8 @UCRoman VIII	}
X{   9 @UCRoman IX	}
X{  10 @UCRoman X	}
X{  11 @UCRoman XI	}
X{  12 @UCRoman XII	}
X{  13 @UCRoman XIII	}
X{  14 @UCRoman XIV	}
X{  15 @UCRoman XV	}
X{  16 @UCRoman XVI	}
X{  17 @UCRoman XVII	}
X{  18 @UCRoman XVIII	}
X{  19 @UCRoman XIX	}
X{  20 @UCRoman XX	}
X{  21 @UCRoman XXI	}
X{  22 @UCRoman XXII	}
X{  23 @UCRoman XXIII	}
X{  24 @UCRoman XXIV	}
X{  25 @UCRoman XXV	}
X{  26 @UCRoman XXVI	}
X{  27 @UCRoman XXVII	}
X{  28 @UCRoman XXVIII	}
X{  29 @UCRoman XXIX	}
X{  30 @UCRoman XXX	}
X{  31 @UCRoman XXXI	}
X{  32 @UCRoman XXXII	}
X{  33 @UCRoman XXXIII	}
X{  34 @UCRoman XXXIV	}
X{  35 @UCRoman XXXV	}
X{  36 @UCRoman XXXVI	}
X{  37 @UCRoman XXXVII	}
X{  38 @UCRoman XXXVIII	}
X{  39 @UCRoman XXXIX	}
X{  40 @UCRoman XL	}
X{  41 @UCRoman XLI	}
X{  42 @UCRoman XLII	}
X{  43 @UCRoman XLIII	}
X{  44 @UCRoman XLIV	}
X{  45 @UCRoman XLV	}
X{  46 @UCRoman XLVI	}
X{  47 @UCRoman XLVII	}
X{  48 @UCRoman XLVIII	}
X{  49 @UCRoman XLIX	}
X{  50 @UCRoman L	}
X{  51 @UCRoman LI	}
X{  52 @UCRoman LII	}
X{  53 @UCRoman LIII	}
X{  54 @UCRoman LIV	}
X{  55 @UCRoman LV	}
X{  56 @UCRoman LVI	}
X{  57 @UCRoman LVII	}
X{  58 @UCRoman LVIII	}
X{  59 @UCRoman LIX	}
X{  60 @UCRoman LX	}
X{  61 @UCRoman LXI	}
X{  62 @UCRoman LXII	}
X{  63 @UCRoman LXIII	}
X{  64 @UCRoman LXIV	}
X{  65 @UCRoman LXV	}
X{  66 @UCRoman LXVI	}
X{  67 @UCRoman LXVII	}
X{  68 @UCRoman LXVIII	}
X{  69 @UCRoman LXIX	}
X{  70 @UCRoman LXX	}
X{  71 @UCRoman LXXI	}
X{  72 @UCRoman LXXII	}
X{  73 @UCRoman LXXIII	}
X{  74 @UCRoman LXXIV	}
X{  75 @UCRoman LXXV	}
X{  76 @UCRoman LXXVI	}
X{  77 @UCRoman LXXVII	}
X{  78 @UCRoman LXXVIII	}
X{  79 @UCRoman LXXIX	}
X{  80 @UCRoman LXXX	}
X{  81 @UCRoman LXXXI	}
X{  82 @UCRoman LXXXII	}
X{  83 @UCRoman LXXXIII	}
X{  84 @UCRoman LXXXIV	}
X{  85 @UCRoman LXXXV	}
X{  86 @UCRoman LXXXVI	}
X{  87 @UCRoman LXXXVII	}
X{  88 @UCRoman LXXXVIII	}
X{  89 @UCRoman LXXXIX	}
X{  90 @UCRoman XC	}
X{  91 @UCRoman XCI	}
X{  92 @UCRoman XCII	}
X{  93 @UCRoman XCIII	}
X{  94 @UCRoman XCIV	}
X{  95 @UCRoman XCV	}
X{  96 @UCRoman XCVI	}
X{  97 @UCRoman XCVII	}
X{  98 @UCRoman XCVIII	}
X{  99 @UCRoman XCIX	}
X{ 100 @UCRoman C	}
X
X{   1 @Alpha a		}
X{   2 @Alpha b		}
X{   3 @Alpha c		}
X{   4 @Alpha d		}
X{   5 @Alpha e		}
X{   6 @Alpha f		}
X{   7 @Alpha g		}
X{   8 @Alpha h		}
X{   9 @Alpha i		}
X{  10 @Alpha j		}
X{  11 @Alpha k		}
X{  12 @Alpha l		}
X{  13 @Alpha m		}
X{  14 @Alpha n		}
X{  15 @Alpha o		}
X{  16 @Alpha p		}
X{  17 @Alpha q		}
X{  18 @Alpha r		}
X{  19 @Alpha s		}
X{  20 @Alpha t		}
X{  21 @Alpha u		}
X{  22 @Alpha v		}
X{  23 @Alpha w		}
X{  24 @Alpha x		}
X{  25 @Alpha y		}
X{  26 @Alpha z		}
X
X{   1 @UCAlpha A	}
X{   2 @UCAlpha B	}
X{   3 @UCAlpha C	}
X{   4 @UCAlpha D	}
X{   5 @UCAlpha E	}
X{   6 @UCAlpha F	}
X{   7 @UCAlpha G	}
X{   8 @UCAlpha H	}
X{   9 @UCAlpha I	}
X{  10 @UCAlpha J	}
X{  11 @UCAlpha K	}
X{  12 @UCAlpha L	}
X{  13 @UCAlpha M	}
X{  14 @UCAlpha N	}
X{  15 @UCAlpha O	}
X{  16 @UCAlpha P	}
X{  17 @UCAlpha Q	}
X{  18 @UCAlpha R	}
X{  19 @UCAlpha S	}
X{  20 @UCAlpha T	}
X{  21 @UCAlpha U	}
X{  22 @UCAlpha V	}
X{  23 @UCAlpha W	}
X{  24 @UCAlpha X	}
X{  25 @UCAlpha Y	}
X{  26 @UCAlpha Z	}
X
X{   1 @Months January   }
X{   2 @Months February  }
X{   3 @Months March     }
X{   4 @Months April     }
X{   5 @Months May       }
X{   6 @Months June      }
X{   7 @Months July      }
X{   8 @Months August    }
X{   9 @Months September }
X{  10 @Months October   }
X{  11 @Months November  }
X{  12 @Months December  }
X
X{   1 @ShortMonths Jan	}
X{   2 @ShortMonths Feb	}
X{   3 @ShortMonths Mar	}
X{   4 @ShortMonths Apr	}
X{   5 @ShortMonths May	}
X{   6 @ShortMonths Jun	}
X{   7 @ShortMonths Jul	}
X{   8 @ShortMonths Aug	}
X{   9 @ShortMonths Sep	}
X{  10 @ShortMonths Oct	}
X{  11 @ShortMonths Nov	}
X{  12 @ShortMonths Dec	}
X
X{   1 @WeekDays Sunday		}
X{   2 @WeekDays Monday		}
X{   3 @WeekDays Tuesday		}
X{   4 @WeekDays Wednesday	}
X{   5 @WeekDays Thursday	}
X{   6 @WeekDays Friday		}
X{   7 @WeekDays Saturday	}
X
X{   1 @ShortWeekDays Sun	}
X{   2 @ShortWeekDays Mon	}
X{   3 @ShortWeekDays Tue	}
X{   4 @ShortWeekDays Wed	}
X{   5 @ShortWeekDays Thu	}
X{   6 @ShortWeekDays Fri	}
X{   7 @ShortWeekDays Sat	}
END_OF_FILE
  if test 7113 -ne `wc -c <'lout/data/standard.ld'`; then
    echo shar: \"'lout/data/standard.ld'\" unpacked with wrong size!
  fi
  # end of 'lout/data/standard.ld'
fi
if test -f 'lout/doc/tr.begin/s02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s02'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s02'\" \(5199 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s02' <<'END_OF_FILE'
X@Section
X   @Tag { displays }
X   @Title { Displays }
X@Begin
X@PP
XThe @Code "@Display" symbol displays the following thing in the centre
Xof the page or column:
X@ID @Code "@Display @I Centred"
Xhas result
X@Display @I Centred
XNotice that @Code "@I Centred" does not have to be grouped within braces;
Xit is already a single thing.  Spaces (@Code "@DP" symbols) are inserted
Xautomatically above and below the display, so no paragraph symbols are
Xneeded anywhere near the display.
X@PP
XThe display can be made to appear at the left margin by using the
X{@Code "@LeftDisplay"} symbol instead of {@Code "@Display"}, or indented
Xby using {@Code "@IndentedDisplay"}.  There are also @Code "@CentredDisplay"
Xand @Code "@CenteredDisplay" symbols which are the same as
X{@Code "@Display"}.  In general, the word @Code Centred may be spelt
X@Code Centered wherever it appears.
X@PP
XEach display symbol has a `raw' version, which means that no space is
Xinserted above or below; the user must therefore add paragraph symbols:
X@ID @Code {
X"... preceding text."
X"@DP"
X"@RawIndentedDisplay @I Emma"
X"@DP"
X"@RawIndentedDisplay @I"
X"{ Mansfield Park }"
X"@DP"
X"following text ..."
X}
Xhas result
X@ID {
X... preceding text.
X@DP
X@RawIndentedDisplay @I Emma
X@DP
X@RawIndentedDisplay @I { Mansfield Park }
X@DP
Xfollowing text ...
X}
XThe point of this particular example is that two consecutive non-raw
Xdisplays would be separated by two @Code "@DP" symbols, which is too
Xmuch.  A better way to do this, using a list, will be presented in the
Xnext section.
X@PP
XDisplays may be {@I aligned}, which means that nominated points within a
Xsequence of displays are made to appear directly beneath each
Xother.  Displays may also be {@I numbered}, which means that an
Xautomatically generated number is placed at the right-hand margin.  For
Xexample, here is a first display:
X@BeginNumberedDisplays
X@BeginAlignedDisplays
X@CentredAlignedNumberedDisplay
X  @Tag { fibeq }
X@Eq { F sub n ^= F sub n-1 + F sub n-2 }
Xand here is a second display, which is aligned on its @Eq {equal} sign
Xwith the first, and also numbered in sequence with it:
X@CentredAlignedNumberedDisplay
X@Eq { F sub n - F sub n-1 ^= F sub n-2 }
X@EndNumberedDisplays
X@EndAlignedDisplays
XMathematical examples have been chosen because they are the most common
Xaligned and numbered displays; but any kind of display may be aligned or
Xnumbered.
X@PP
XNotice that the two displays are centred as a block as well as
Xaligned.  Altogether then we have four ways in which displays vary:
X@BL
X@LI { A display can be raw or not raw; }
X@LI { It can be a {@Code "@Display"}, {@Code "@LeftDisplay"},
X{@Code "@IndentedDisplay"}, {@Code "@CentredDisplay"} or
X{@Code "@CenteredDisplay"}; }
X@LI { It can be aligned or not aligned; }
X@LI { It can be numbered or not numbered. }
X@EL
XAll possible combinations are allowed.  The display that has everything
Xis called
X@ID @Code { "@RawCentredAlignedNumberedDisplay" &0io }
XBy leaving out some or all of {@Code Raw}, {@Code Aligned}, and
X{@Code Numbered}, and by changing or leaving out {@Code Centred},
Xwe get all these combinations.
X@PP
XWhen aligned displays are used, it is necessary to indicate where the
Xaligned group begins and ends, by inserting @Code "@BeginAlignedDisplays"
Xjust before the first, and @Code "@EndAlignedDisplays" just after the
Xlast.  The alignment points are indicated by preceding them by the
Xsymbol {@Code "^"}.  Numbered displays are similarly bracketed by
X@Code "@BeginNumberedDisplays" and {@Code "@EndNumberedDisplays"}.  So
Xthen, with the help of the @Code "@Eq" equation formatting package
X[{@Ref kingston92eq}], here is the input for the two displays given
Xearlier:
X@ID @Code {
X"... a first display:"
X"@BeginNumberedDisplays"
X"@BeginAlignedDisplays"
X"@CentredAlignedNumberedDisplay"
X"  @Tag { fibeq }"
X@OneCol { "@Eq { F sub n ^= F sub n-1 + F sub n-2 }" &0io }
X"and ... in sequence with it:"
X"@CentredAlignedNumberedDisplay"
X@OneCol { "@Eq { F sub n - F sub n-1 ^= F sub n-2 }" &0io }
X"@EndNumberedDisplays"
X"@EndAlignedDisplays"
X"Mathematical examples ..."
X}
XNo braces need enclose @Code "@Eq { ... }" because it is already a
Xsingle entity.  The @Code "@Tag { fibeq }" part is optional and is
Xexplained in Section {@NumberOf cross}.  Alignment and numbering work
Xquite independently; they don't have to start or end together, and there
Xcan be non-aligned and non-numbered displays among the others.
X@PP
X@Code "@BeginNumberedDisplays" has two {@I options}:  subsidiary
Xsymbols which modify the result.  For example,
X@ID @Code {
X"@BeginNumberedDisplays"
X"   style { [tag] }"
X"   start { 12.5 }"
X}
Xwill cause the associated numbered displays to be labelled [12.5],
X[12.6], and so on.  The first label is the @Code style option with
X@Code tag replaced by the @Code start option.  Font changes and other
Xsymbols are acceptable within the @Code style option.  When omitted, the
Xoptions have default values @Code "(tag)" and @Code "1" respectively.
X@PP
XEvery symbol introduced in this section has an abbreviated form
Xconsisting of @Code "@" followed by its capital letters only.  For
Xexample, @Code "@BeginNumberedDisplays" can be abbreviated to {@Code "@BND"},
Xand the display that has everything to {@Code "@RCAND"}.
X@End @Section
END_OF_FILE
  if test 5199 -ne `wc -c <'lout/doc/tr.begin/s02'`; then
    echo shar: \"'lout/doc/tr.begin/s02'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s02'
fi
if test -f 'lout/doc/tr.begin/s03' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.begin/s03'\"
else
  echo shar: Extracting \"'lout/doc/tr.begin/s03'\" \(5254 characters\)
  sed "s/^X//" >'lout/doc/tr.begin/s03' <<'END_OF_FILE'
X@Section
X   @Tag { lists }
X   @Title { Lists }
X@Begin
X@PP
XIn the previous section, we saw that several consecutive displays are
Xawkward to space correctly.  Provided they are not aligned or numbered,
Xsuch displays are better treated as a {@I list}:
X@ID @Code {
X"... preceding text."
X"@IndentedList"
X"@ListItem @I Emma"
X"@ListItem @I { Mansfield Park }"
X"@EndList"
X"following text ..."
X}
XThere are {@Code "@LeftList"}, {@Code "@IndentedList"}, and
X@Code "@CentredList" (or {@Code "@CenteredList"}) symbols; each item is
Xintroduced by {@Code "@ListItem"}, and the list ends with
X{@Code "@EndList"}.  There may be any number of items; @Code "@DP"
Xsymbols are inserted before, between, and after them.
X@PP
XA variety of automatically generated tags is available for indented
Xlists.  Here is the full set, showing the first tag produced:
X@ID {
X     @Code "@NumberedList"	|1c	1.
X/1vx @Code "@ParenNumberedList" |	(1)
X/1vx @Code "@RomanList"		|	i.
X/1vx @Code "@ParenRomanList"	|	(i)
X/1vx @Code "@UCRomanList"	|	I.
X/1vx @Code "@ParenUCRomanList"	|	(I)
X/1vx @Code "@AlphaList"		|	a.
X/1vx @Code "@ParenAlphaList"	|	(a)
X/1vx @Code "@UCAlphaList"	|	A.
X/1vx @Code "@ParenUCAlphaList"	|	(A)
X/1vx @Code "@BulletList"	|	@Bullet
X/1vx @Code "@StarList"		|	@Star
X/1vx @Code "@DashList"		|	--
X}
XThe Roman numerals end at c (100), and the alphabet ends
Xat z (26), but ordinary numbers have no limit.  For example,
X@ID @Code {
X"@Heading { Quiz }"
X"@NumberedList"
X"@ListItem { Which American"
X"statesman owned a"
X"two-storey clock? }"
X"@ListItem { Which Yankee"
X"commander cut a swathe of"
X"destruction through the"
X"State of Georgia? }"
X"@EndList"
X}
Xhas result
X@ID {
X@Heading { Quiz }
X@DP
X@RawNumberedList
X@ListItem { Which American
Xstatesman owned a
Xtwo-storey clock? }
X@ListItem { Which Yankee
Xcommander cut a swathe of
Xdestruction through the
XState of Georgia? }
X@EndList
X}
XAlternatively, the tags may be supplied by the author, using the
X@Code "@TaggedList" symbol and its variants @Code "@WideTaggedList" and
X{@Code "@VeryWideTaggedList"}, which leave a wider indent for the tags:
X@ID @Code {
X"@WideTaggedList"
X"{ 9 a.m. } @TagItem { Breakfast in"
X"the Ipamena Lounge, served with"
X"Irish coffee and fresh croissants. }"
X"{ 10 a.m. } @TagItem { Prof. A. Smith"
X"speaks on `The Wealth of Nations.' }"
X"@EndList"
X}
Xhas result
X@ID {
X@RawWideTaggedList
X{ 9 a.m. } @TagItem { Breakfast in
Xthe Ipamena Lounge, served with
XIrish coffee and fresh croissants. }
X{ 10 a.m. } @TagItem { Prof. A. Smith
Xspeaks on `The Wealth of Nations.' }
X@EndList
X}
XEach @Code "@TagItem" symbol uses the thing just preceding it as the tag.
X@PP
XEach of these lists also has a `raw' version which omits the preceding
Xand following space.  These are mainly used when an item is itself a list:
X@ID @Code {
X"@ParenNumberedList"
X"@ListItem {"
X"   @RawParenRomanList"
X"   @ListItem { MV Nominees,"
X"hereinafter called the vendor, ... }"
X"   @EndList"
X"}"
X"@EndList"
X}
Xhas result
X@ID {
X@RawParenNumberedList
X@ListItem {
X   @RawParenRomanList
X   @ListItem { MV Nominees,
Xhereinafter called the vendor, ... }
X   @EndList
X}
X@EndList
X}
XIf @Code "@ParenRomanList" had been used instead of
X{@Code "@RawParenRomanList"}, (1) and (i) would have appeared on
Xdifferent lines.
X@PP
XIn cases where it is desired to have a paragraph symbol following a raw
Xlist, owing to problems behind the scenes this symbol should be placed
Xbefore the first {@Code "@ListItem"} or {@Code "@TagItem"}, not after
Xthe @Code "@EndList" as would naturally be expected.
X@PP
XA finer control over the appearance of lists is obtained with
X@Code "@RawIndentedList" and {@Code "@RawTaggedList"}.  These
Xhave {@I options}:  optional subsidiary symbols which modify the
Xresult.  For example,
X@ID @Code {
X"@RawIndentedList"
X"     style { [tag] }"
X"     indent { 0.5i }"
X"     gap { 0.3v }"
X"     start { 5 }"
X"@ListItem { ... }"
X"@ListItem { ... }"
X"@EndList"
X}
Xshows the four options available with {@Code "@RawIndentedList"}, namely
X{@Code style}, @Code {indent}, {@Code gap}, and {@Code start}.  It
Xhas result
X@ID {
X@RawIndentedList
X     style { [tag] }
X     indent { 0.5i }
X     gap { 0.3v }
X     start { 5 }
X@ListItem { ... }
X@ListItem { ... }
X@EndList
X}
XThe @Code style option determines the appearance of each tag, any
X@Code tag symbol
Xwithin it being replaced by the number of the item.  If numbers are not
Xwanted in the tag, @Code tag may be omitted.  The other options
Xdetermine the indent, the gap between items, and the number of the first
Xitem.  In general, options may be given in any order, and if omitted
Xwill revert to a reasonable standard value.  @Code "@RawTaggedList" works
Xin a similar way, except that @Code tag is replaced by the tag supplied
Xby the @Code "@TagItem" symbol, and there is no @Code start option.  The
Xsymbol @Code "@DP" may be used above or below the list to produce the
Xusual amount of space.
X@PP
XIndividual list items are kept together on one page or column.  However,
Xa new page may be started between two list items.
X@PP
XAs in the previous section, every symbol introduced in this section has
Xan abbreviated form consisting of @Code "@" followed by its capital
Xletters only.  For example, @Code "@RawNumberedList" can be abbreviated
Xto {@Code "@RNL"}, and @Code "@ListItem" to {@Code "@LI"}.
X@End @Section
END_OF_FILE
  if test 5254 -ne `wc -c <'lout/doc/tr.begin/s03'`; then
    echo shar: \"'lout/doc/tr.begin/s03'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.begin/s03'
fi
if test -f 'lout/doc/tr.eq/s6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/s6'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/s6'\" \(5589 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/s6' <<'END_OF_FILE'
X@Appendix
X    @Title { Pas -- a Lout Package for Printing Pascal Programs }
X@Begin
X@PP
XPas
X@Reference
X   @Tag { jensen75 }
X   @Type { Book }
X   @Author { Jensen, K. and Wirth, N. }
X   @Title { Pascal User Manual and Report }
X   @Publisher { Springer-Verlag }
X   @Year { 1975 }
Xis a package of definitions for printing Pascal programs
X[{@Ref jensen75}] neatly with the Lout document formatter
X[{@Ref kingston92}].  No attempt is made to follow any particular
Xprinting standard; the design simply reflects the author's taste.
X@PP
XThe package is so simple that there is very little to say about
Xit.  To use Pas, place @Code "@SysInclude { pas }" in the setup file,
Xor type @Code "-ipas" in the command line.  A Pascal program is
Xentered like this, where the @Code "@ID" symbol from the DocumentLayout
Xpackage [{@Ref kingston92begin}] has been used to obtain an indented display:
X@ID @Code {
X"@ID @Pas {"
X"procedure PriDelete(x: PriEntry; var Q: PriorityQueue);"
X"    var i: integer;"
X"begin"
X"    with Q^ do begin"
X"        size := size - 1;"
X"        if x^.back <= size then"
X"        begin"
X"            i := x^.back;"
X"            A[i] := A[size + 1];"
X"            A[i]^.back := i;"
X"            PriAddRoot(i, Q);"
X"            PriAddLeaf(i, Q)"
X"        end"
X"    end"
X"end;"
X"}"
X}
XThe result will come out like this:
X@ID @Pas {
Xprocedure PriDelete(x: PriEntry; var Q: PriorityQueue);
X    var i: integer;
Xbegin
X    with Q^ do begin
X	size := size - 1;
X	if x^.back <= size then
X	begin
X	    i := x^.back;
X	    A[i] := A[size + 1];
X	    A[i]^.back := i;
X	    PriAddRoot(i, Q);
X	    PriAddLeaf(i, Q)
X	end
X    end
Xend;
X}
XBlank lines, line breaks, indents and spaces in the input are respected, with a
Xtab being considered equal to eight spaces.  @Code "@Pas" can also be used
Xwithin a paragraph to produce Pascal fragments like @Pas { A[i..j] }.  Use
X@Code "@OneCol @Pas { ... }" to prevent the result from breaking over two
Xlines.
X@PP
X@Code "@Pas" does not attempt to rearrange the program in any way.  Each
Xitem is simply printed according to the following plan:
X@ID {
X7c @Wide {
X      @Code and 	|2.5ct @Pas { and }
X//1vx @Code array 	|2.5ct @Pas { array }
X//1vx @Code begin 	|2.5ct @Pas { begin }
X//1vx @Code case 	|2.5ct @Pas { case }
X//1vx @Code const 	|2.5ct @Pas { const }
X//1vx @Code div 	|2.5ct @Pas { div }
X//1vx @Code do 		|2.5ct @Pas { do }
X//1vx @Code downto 	|2.5ct @Pas { downto }
X//1vx @Code else 	|2.5ct @Pas { else }
X//1vx @Code end 	|2.5ct @Pas { end }
X//1vx @Code file 	|2.5ct @Pas { file }
X//1vx @Code for 	|2.5ct @Pas { for }
X//1vx @Code forward	|2.5ct @Pas { forward }
X//1vx @Code function 	|2.5ct @Pas { function }
X//1vx @Code goto 	|2.5ct @Pas { goto }
X//1vx @Code if 		|2.5ct @Pas { if }
X//1vx @Code in 		|2.5ct @Pas { in }
X//1vx @Code label 	|2.5ct @Pas { label }
X//1vx @Code mod 	|2.5ct @Pas { mod }
X//1vx @Code nil 	|2.5ct @Pas { nil }
X//1vx @Code not 	|2.5ct @Pas { not }
X//1vx @Code of 		|2.5ct @Pas { of }
X//1vx @Code or 		|2.5ct @Pas { or }
X//1vx @Code otherwise 	|2.5ct @Pas { otherwise }
X//1vx @Code packed 	|2.5ct @Pas { packed }
X//1vx @Code procedure 	|2.5ct @Pas { procedure }
X//1vx @Code program 	|2.5ct @Pas { program }
X//1vx @Code record 	|2.5ct @Pas { record }
X//1vx @Code repeat 	|2.5ct @Pas { repeat }
X//1vx @Code set 	|2.5ct @Pas { set }
X//1vx @Code then 	|2.5ct @Pas { then }
X//1vx @Code to 		|2.5ct @Pas { to }
X//1vx @Code type 	|2.5ct @Pas { type }
X//1vx @Code until 	|2.5ct @Pas { until }
X//1vx @Code var 	|2.5ct @Pas { var }
X//1vx @Code while 	|2.5ct @Pas { while }
X//1vx @Code with 	|2.5ct @Pas { with }
X} | 7c @Wide {
X      @Code "0"		|2.5ct @Pas { 0 }
X//1vx @Code "1"		|2.5ct @Pas { 1 }
X//1vx @Code "2"		|2.5ct @Pas { 2 }
X//1vx @Code "3"		|2.5ct @Pas { 3 }
X//1vx @Code "4"		|2.5ct @Pas { 4 }
X//1vx @Code "5"		|2.5ct @Pas { 5 }
X//1vx @Code "6"		|2.5ct @Pas { 6 }
X//1vx @Code "7"		|2.5ct @Pas { 7 }
X//1vx @Code "8"		|2.5ct @Pas { 8 }
X//1vx @Code "9"		|2.5ct @Pas { 9 }
X//1vx @Code "."		|2.5ct @Pas { . }
X//1vx @Code ","		|2.5ct @Pas { , }
X//1vx @Code ":"		|2.5ct @Pas { : }
X//1vx @Code ";"		|2.5ct @Pas { ; }
X//1vx @Code "'"		|2.5ct @Pas { ' }
X//1vx @Code "`"		|2.5ct @Pas { ` }
X//1vx @Code "+"		|2.5ct @Pas { + }
X//1vx @Code "-"		|2.5ct @Pas { - }
X//1vx @Code "*"		|2.5ct @Pas { * }
X//1vx @Code "/"		|2.5ct @Pas { / }
X//1vx @Code "("		|2.5ct @Pas { ( }
X//1vx @Code ")"		|2.5ct @Pas { ) }
X//1vx @Code "["		|2.5ct @Pas { [ }
X//1vx @Code "]"		|2.5ct @Pas { ] }
X//1vx @Code "^"		|2.5ct @Pas { ^ }
X//1vx @Code ".."	|2.5ct @Pas { .. }
X//1vx @Code "="		|2.5ct @Pas { = }
X//1vx @Code "<"		|2.5ct @Pas { < }
X//1vx @Code ">"		|2.5ct @Pas { > }
X//1vx @Code "<>"	|2.5ct @Pas { <> }
X//1vx @Code "<="	|2.5ct @Pas { <= }
X//1vx @Code ">="	|2.5ct @Pas { >= }
X//1vx @Code ":="	|2.5ct @Pas { := }
X}
X}
XAnything not mentioned here will appear in italic font.
X@PP
XPascal character strings need a little attention before formatting by
XPas.  Their interiors are best enclosed in double quotes to prevent the
Xabove transformations from occurring inside them.  Any @Code "\\" or
X@Code "\"" characters inside strings will need to be replaced by
X@Code "\\\\" and @Code "\\\"" respectively, and the opening quote should
Xbe replaced by {@Code "`"}.
X@PP
XSimilar remarks apply to Pascal comments; don't forget that @Code "{"
Xand @Code "}" must be enclosed in double quotes.  Alternatively, a
X@Code "@Com" symbol can be placed in front of a comment enclosed
Xin braces.  It will add literal braces:
X@ID @Code {
X"@Com { A Pascal comment }"
X}
Xhas result
X@ID @Pas {
X@Com { A Pascal comment }
X}
XIt may still be necessary to enclose the interior in double quotes.
X@End @Appendix
END_OF_FILE
  if test 5589 -ne `wc -c <'lout/doc/tr.eq/s6'`; then
    echo shar: \"'lout/doc/tr.eq/s6'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.eq/s6'
fi
if test -f 'lout/doc/tr.fig/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.fig/s3'\"
else
  echo shar: Extracting \"'lout/doc/tr.fig/s3'\" \(5295 characters\)
  sed "s/^X//" >'lout/doc/tr.fig/s3' <<'END_OF_FILE'
X@Section
X   @Title { Creating New Shapes }
X@Begin
X@PP
XIf the needed shape is not provided by Fig, it can be created
Xusing the @Code "@Figure" symbol.  @Code "@Figure" takes all the options
Xwe have already seen, plus another one called {@Code shape}.  For
Xexample,
X@ID {
X@Code {
X"@Figure"
X"   shape {"
X"      0 0  xsize 0"
X"      0 ysize  0 0"
X"   }"
X"{ 3c @High 2c @Wide }"
X}
X||7ct
X@Fig {
X@Figure
X   shape { 0 0  xsize 0
X           0 ysize  0 0
X         }
X{ 3c @High 2c @Wide }
X}
X}
XThe pairs of numbers define points in a coordinate system whose origin
Xis the lower left corner of the right parameter; the upper right corner
Xis @Code xsize {@Code ysize}, and the point where the
Xright parameter's marks cross is {@Code "xmark ymark"}:
X@ID 10p @Font
X{
X   { &1rt @I ysize /0ik &1rt @I ymark /0ik &1rt 0 } |0.4c
X   {  /
X      |0ik @ShowMarks { 1c @High 1.5c @Wide ^| 3c @Wide ^/ 2c @High }
X      |0ik /
X   }
X   /0.3c
X   | 0 | @I xmark | @I xsize
X}
XThis arrangement is identical with that for the @Code "@Graphic"
Xsymbol of basic Lout.  A sequence of points defines a shape, like
Xthe triangle above.  Arrowheads are drawn pointing forwards from the
Xlast segment and backwards from the first, as requested; the @Code margin
Xoption has default value {@Code 0c}.
X@PP
XNormally, the points are connected by straight lines to form the shape,
Xwhich is then painted and drawn in the usual way, depending on the other
Xoptions.
X@PP
XIf two points in the shape are separated by {@Code {"[" &0.5s "]"}}, no
Xline will be drawn between them.  This permits a shape to consist of two
Xor more disconnected parts.
X@PP
XIf two points in the shape are separated by
X{@Code "[" & @Eq{x ``` y} & @Code "]"}, where
X@Eq {x} and @Eq {y} are numbers, the two points will be joined by an
Xanticlockwise arc whose centre is the point @Eq {(x, y)}.  This arc
Xwill be circular if possible, otherwise it will be part of an ellipse
Xwhose axes are oriented horizontally and vertically.  The notation
X@Code "[" & @Eq {x ``` y} @Code "clockwise]" makes the arc go
Xclockwise.  For example,
X@ID {
X@Code {
X"@Figure"
X"   shape {"
X"      0 -0.5 cm"
X"      0 0.5 cm"
X"      1 cm 0  0 -0.5 cm [" &0.5s "]"
X"      1 cm 0 [ 1.1 cm 0 ]"
X"      1 cm 0"
X"   }"
X"{}"
X}
X||7ct
X@Fig { //0.5c
X@Figure
X   shape { 0 -0.5 cm  0 0.5 cm
X           1 cm 0  0 -0.5 cm []
X           1 cm 0 [ 1.1 cm 0 ] 1 cm 0
X         }
X{}
X}
X}
XWe have recklessly disregarded the size of the right parameter when
Xdrawing this shape, a dangerous thing to do since Lout thinks that the
Xfigure is the same size as its right parameter.
X@PP
XFinally, two points may be separated by
X@Eq { [x sub 1 ``` y sub 1 ```  x sub 2 ``` y sub 2 & ] }, which requests that a
XBezier curve be drawn between them with control points
X@Eq { (x sub 1 & , y sub 1 & ) } and
X@Eq { (x sub 2 & , y sub 2 & ) }:
X@ID @Fig {
X@Figure
X   margin { 0c }
X   shape { 1 cm 2 cm 4 cm 3.5 cm  9 cm 2 cm 2 cm 0.6 cm }
X   linestyle { dashed }
X@Figure
X   margin { 0c }
X   shape { 1 cm 2 cm [4 cm 3.5 cm  9 cm 2 cm] 2 cm 0.6 cm }
X{ 7c @Wide 4c @High }
X
X// { -0.3  cm 2.0 cm } @BaseOf @Eq { (x sub 0 & , y sub 0 & )}
X// {  4.2  cm 3.5 cm } @BaseOf @Eq { (x sub 1 & , y sub 1 & )}
X// {  9.1  cm 2.0 cm } @BaseOf @Eq { (x sub 2 & , y sub 2 & )}
X// {  2.1  cm 0.0 cm } @BaseOf @Eq { (x sub 3 & , y sub 3 & )}
X}
XThe curve is attracted toward the control points, without reaching
Xthem; it is tangent to the straight line from the start point to the
Xfirst control point, and from the second control point to the finishing
Xpoint, and it lies wholly inside the quadrilateral formed by the four
Xpoints.  Owing to the author's laziness, dashes and dots do not fit as
Xneatly onto Bezier curves as they do onto lines and arcs.
X @Code "@Figure" should be general enough to draw most shapes; for
Xexample, all the other shapes ({@Code "@Box"}, {@Code "@Circle"}, etc.)
Xare just instances of {@Code "@Figure"}.  When it is inadequate, one
Xcan fall back to the standard @Code "@Graphic" symbol.
X@PP
XLines, arrows and arcs at any angle can be produced using {@Code "@Figure"}:
X@ID {
X@Code {
X"@Figure"
X"   shape { 0 0  xsize ysize }"
X"   arrow { forward }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Figure
X   shape { 0 0  xsize ysize }
X   arrow { forward }
X{ 2c @High 3c @Wide }
X}
X}
XHowever, for convenience there are symbols @Code "@Line" and @Code
X"@Arrow" which have two options, @Code "from" and {@Code "to"}, for
Xspecifying the endpoints:
X@ID {
X@Code {
X"@Arrow"
X"   from { 0 0 }"
X"   to { xsize ysize }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Arrow
X   from { 0 0 }
X   to { xsize ysize }
X{ 2c @High 3c @Wide }
X}
X}
XThere is also an @Code "@Arc" symbol, which draws a circular or
Xelliptical arc from one point to another about a given centre, with
Xthe usual options:
X@ID {
X@Code {
X"@Arc"
X"   from { 0 0 }"
X"   to { xsize ysize }"
X"   ctr { 0 ysize }"
X"   direction { anticlockwise }"
X"   arrow { forward }"
X"   linestyle { dashed }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Arc
X   from { 0 0 }
X   to { xsize ysize }
X   ctr { 0 ysize }
X   direction { anticlockwise }
X   arrow { forward }
X   linestyle { dashed }
X{ 2c @High 3c @Wide }
X}
X}
XThe arc goes either @Code clockwise (the default) or @Code anticlockwise
Xabout the centre, depending on the @Code direction option.  Any
Xarrowhead will point in a direction tangent to the arc.
X@End @Section
END_OF_FILE
  if test 5295 -ne `wc -c <'lout/doc/tr.fig/s3'`; then
    echo shar: \"'lout/doc/tr.fig/s3'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.fig/s3'
fi
if test -f 'lout/doc/tr.impl/oldrefs.ld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/oldrefs.ld'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/oldrefs.ld'\" \(5587 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/oldrefs.ld' <<'END_OF_FILE'
X{ @Reference
X     @Tag { knuth84 }
X     @Type { Book }
X     @Author { Knuth, Donald E. }
X     @Title { The T{ /0.2fo E}XBook }
X     @Publisher { Addison-Wesley }
X     @Year { 1984 }
X}
X
X{ @Reference
X     @Tag { adobe85 }
X     @Type { Book }
X     @Author { Adobe Systems, Inc. }
X     @Title { PostScript Language Reference Manual }
X     @Publisher { Addison-Wesley }
X     @Year { 1985 }
X}
X
X{ @Reference
X     @Tag { reid80 }
X     @Type { ConferencePaper }
X     @Author { Reid, Brian K. }
X     @Title { A High-Level Approach to Computer Document Production }
X     @Proceedings { Proceedings of the 7th Symposium on the Principles
Xof Programming Languages (POPL), Las Vegas NV }
X     @Pages { 24--31 }
X     @Year { 1980 }
X}
X
X{ @Reference
X     @Tag { strunk79 }
X     @Type { Book }
X     @Author { Strunk, William and White, E. B. }
X     @Title { The Elements of Style }
X     @Publisher { Macmillan, third edition }
X     @Year { 1979 }
X}
X
X{ @Reference
X     @Tag { ossanna76 }
X     @Type { TechReport }
X     @Author { Joseph F. Ossanna }
X     @Title { "Nroff/Troff" User's Manual }
X     @Number { 54 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan75 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. and Cherry, Lorinda L. }
X     @Title { A system for typesetting mathematics }
X     @Journal { Communications of the ACM }
X     @Volume { 18 }
X     @Pages { 182--193 }
X     @Year { 1975 }
X}
X
X{ @Reference
X     @Tag { lesk76 }
X     @Type { TechReport }
X     @Author { Lesk, M. E. }
X     @Title { Tbl -- a program to format tables }
X     @Number { 49 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan82 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. }
X     @Title { PIC -- A language for typesetting graphics}
X     @Journal { Software Practice and Experience }
X     @Volume { 12 }
X     @Pages { 1--21 }
X     @Year { 1982 }
X}
X
X{ @Reference
X     @Tag { kingston91 }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Document Formatting with Lout }
X     @Number { 408 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91basser }
X     @Type { Software }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The Basser Lout Document Formatter }
X     @Year { 1991 }
X     @Comment { Computer program; Version 2 publicly available
Xin the @I jeff subdirectory of the home directory of @I ftp to host
X@I ftp.cs.su.oz.au with login name @I anonymous or @I ftp and any
Xnon-empty password.  Distribution via email is available for
Xnon-{@I ftp} sites.  All enquiries to "jeff@cs.su.oz.au". }
X}
X
X{ @Reference
X     @Tag { kingston91begin }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A beginners' guide to Lout }
X     @Number { 409 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91eq }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Eq -- a Lout package for typesetting mathematics }
X     @Number { 410 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X     @Comment { (Contains an appendix describing the Pas Pascal formatter.) }
X}
X
X{ @Reference
X     @Tag { kingston91fig }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Fig -- a Lout package for drawing figures }
X     @Number { 411 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91over }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A new approach to document formatting }
X     @Number { 412 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91tab }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Tab -- a Lout package for formatting tables }
X     @Number { 413 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91design }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The design and implementation of a document formatting language }
X     @Number { @Null }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X     @Comment { @I { In preparation. } }
X}
X
X{ @Reference
X     @Tag { wirth71 }
X     @Type { JournalArticle }
X     @Author { Wirth, N. }
X     @Title { The programming language Pascal }
X     @Journal { Acta Informatica }
X     @Volume { 1 }
X     @Year { 1975 }
X     @Pages { 35--63 }
X}
X
X{ @Reference
X     @Tag { brooks91 }
X     @Type { JournalArticle }
X     @Author { Brooks, Kenneth P. }
X     @Title { Lilac: a two-view document editor }
X     @Journal { IEEE Computer }
X     @Volume { @Null }
X     @Pages { 7--19 }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { furuta82 }
X     @Type { JournalArticle }
X     @Author { Furuta, Richard, Scofield, Jeffrey,
Xand Shaw, Alan }
X     @Title { Document formatting systems:  survey,
Xconcepts, and issues }
X     @Journal { Computing Surveys }
X     @Volume { 14 }
X     @Pages { 417--472 }
X     @Year { 1982 }
X}
END_OF_FILE
  if test 5587 -ne `wc -c <'lout/doc/tr.impl/oldrefs.ld'`; then
    echo shar: \"'lout/doc/tr.impl/oldrefs.ld'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/oldrefs.ld'
fi
if test -f 'lout/doc/tr.impl/s3.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s3.3'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s3.3'\" \(5264 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s3.3' <<'END_OF_FILE'
X@SubSection
X    @Tag { modules }
X    @Title { Modules }
X@Begin
X@PP
XIt is well accepted that the visibility of symbols is not adequately
Xcontrolled by Algol block structure.  The author is aware of several
Xmajor problems of this kind in document formatting.
X@PP
XOne problem is that some symbols should be visible only within
Xrestricted parts of a document.  For example, we naturally expect
Xequation formatting to be accomplished like this:
X@ID @Code {
X"surrounding text"
X"@Eq { {x sup 2  +  1} over 4 }"
X"surrounding text"
X}
Xwith the symbols {@Code "sup"}, {@Code "over"}, etc., visible only within
Xthe equation, not in the surrounding text.
X@PP
XIt seems natural to define these symbols within {@Code "@Eq"}, since
Xthey are local to equations.  It only remains then to decree that
Xsymbols local to @Code "@Eq" are to be visible within its actual right
Xparameter, and this is done by replacing the right formal parameter with a
X@I body parameter:
X@ID @Code {
X"export sup over"
X"def @Eq"
X"    body @Body"
X"{"
X"    def sup ..."
X"    def over ..."
X""
X"    Slope @Font @Body"
X"}"
X}
XThe @Code export clause lists the identifiers which are permitted to be
Xvisible outside their usual range, the body of {@Code "@Eq"}; and the
X@Code body declaration imports them into (makes them visible within)
Xthe actual right parameter of each invocation of {@Code "@Eq"}.  This
Xarrangement has proven very convenient for defining a variety of
Xspecial-purpose packages.
X@PP
XAnother problem arises when global symbols, such as the ones used for
Xheadings and paragraph separators, call on values that the non-expert
Xuser will need to modify, such as the initial font or paragraph
Xindent.  These values are like parameters of the document as a whole, so
Xit is natural to try this:
X@ID @Code {
X"export @Heading @PP ..."
X"def @BookLayout"
X"    named @InitialFont { Times Base 12p }"
X"    named @InitialBreak { adjust 14p }"
X"    named @ColumnWidth { 6i }"
X"    ..."
X"{"
X"    def @Heading ..."
X"    def @PP ..."
X"}"
X}
XNow @Code "@Heading" and @Code "@PP" may invoke @Code "@InitialFont"
Xand the other parameters.  To make @Code "@Heading" and @Code "@PP"
Xvisible throughout the document, we need only add a body parameter to
X@Code "@BookLayout" and present the entire document as
X@ID @Code {
X"@BookLayout"
X"    @InitialFont { Helvetica Base 10p }"
X"    @InitialBreak { adjust 12p }"
X"{"
X"    The document."
X"}"
X}
Xbut for practical reasons given below we prefer not to enclose the
Xentire document in braces.  Instead, we write
X@ID @Code {
X"@Use { @BookLayout"
X"    @InitialFont { Helvetica Base 10p }"
X"    @InitialBreak { adjust 12p }"
X"}"
X"The document."
X}
Xwhich has the same effect:  @Code "@Use" makes the exported symbols of
X@Code "@BookLayout" visible for the remainder of the document, and is
Xpermitted only at the beginning.
X@PP
XThe third feature that affects visibility, and which will prove useful
Xfor cross referencing (Section {@NumberOf cross}), is the @Code "@Open"
Xsymbol.  It makes the exported symbols of its left parameter visible
Xwithin its right parameter, and is therefore similar to the Pascal @Code
Xwith statement.
X@PP
XIt could be argued that Lout is over-supplied with these visibility modifying
Xfeatures: the body parameter, @Code "@Use" and @Code "@Open" do not seem
Xsufficiently different from each another.  The @Code "@Open" symbol is
Xthe most general, being capable of replacing the other two.  For
Xexample,
X@ID @Code {
X"@Use { x }"
X"@Use { y }"
X"Body of document"
X}
Xcan be replaced by
X@ID @Code {
X"x @Open {"
X"y @Open {"
X"Body of document"
X"}}"
X}
Xand, taking the @Code "@Eq" symbol above as example, we could eliminate
Xits body parameter, add
X@ID @Code "def @Body right x { Slope @Font x }"
Xto the exported definitions of {@Code "@Eq"}, and replace
X@ID @Code "@Eq { object }"
Xby
X@ID @Code "@Eq @Open { @Body { object } }"
XIf @Code "@Eq" is a galley (Section {@NumberOf galleys}), @Code "@Body"
Xmust take over that function.  But one would not want to write these
Xclumsy expressions in practice, and the enclosure of large quantities
Xof input in extra braces could cause Basser Lout to run out of memory
X(Section {@NumberOf lookahead}).
X@PP
XA quite separate kind of visibility problem arises when expert
Xusers wish to define an object or operator for repeated use within, say,
Xequations:
X@ID @Code "def isum { sum from i=1 to n }"
XAs it stands this can only be placed within the @Code "@Eq" package itself, 
Xwhere @Code "sum" and the other symbols are visible, but it is not desirable
Xto modify the source code of a standard package.  Lout provides an
X@Code "import" clause to solve this problem:
X@ID @Code {
X"import @Eq"
X"def isum { sum from i=1 to n }"
X}
Xmay appear after @Code "@Eq" is defined, and it will make the exported symbols
Xof @Code "@Eq" visible within the body of {@Code "isum"}.  This feature
Xcomplicates the treatment of environments (Section {@NumberOf defs.impl}),
Xand even introduces an insecurity, when @Code isum is invoked outside an
Xequation.  A simpler approach would be to allow only one symbol in an
X@Code import clause, and treat the following definition exactly like a
Xlocal definition of that symbol; but then it would not be possible
Xto define symbols using the resources of more than one of the standard
Xpackages.
X@End @SubSection
END_OF_FILE
  if test 5264 -ne `wc -c <'lout/doc/tr.impl/s3.3'`; then
    echo shar: \"'lout/doc/tr.impl/s3.3'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s3.3'
fi
if test -f 'lout/doc/tr.impl/s5.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s5.1'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s5.1'\" \(6118 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s5.1' <<'END_OF_FILE'
X@SubSection
X    @Tag { galleys }
X    @Title { The galley abstraction }
X@Begin
X@PP
XLet us take the footnote as a representative example.  At some point in
Xthe document, we wish to write
X@ID @Code {
X"preceding text"
X"@FootNote { footnote text }"
X"following text"
X}
Xand we expect the formatter to remove the footnote from this context and
Xplace it at the bottom of the current page, possibly splitting some or
Xall of it onto a following page if space is insufficient.
X@PP
XAn object appears in the final document at the point it is invoked, but
Xthis basic property does not hold for footnotes:  the point of
Xinvocation and the point of appearance are different.  In some way, the
Xfootnote is attached to the document at both points, introducing a cross
Xlinking (Section {@NumberOf genesis}) that cannot be described in purely
Xfunctional terms.
X@PP
XSince the interpretation of any object depends on an environment and
Xstyle inherited from the context, the first question must be whether
Xthe footnote inherits them through the invocation point or through
Xthe point(s) of appearance.
X@PP
XIf symbols are to be interpreted statically as heretofore, then environments
Xmust be inherited through the invocation point alone.  Dynamic inheritance
Xthrough the point of appearance is enticing in some ways:  it might
Xreplace the body parameter, and it might help with automatic numbering,
Xsince the number of a footnote is known only at the point of appearance;
Xbut the implementation problems are severe, and static inheritance seems
Xmuch simpler and more comprehensible to the user.  Style, at least its
Xavailable width and height part, must of necessity be inherited through
Xthe point of appearance.  For consistency, the entire style should be
Xinherited in this way.  There is a suggestive analogy here with actual
Xparameters, which have a point of invocation from which they inherit an
Xenvironment, and a point of appearance within the body of the enclosing
Xdefinition, from which they inherit a style.  It may be possible to treat
Xa footnote as the actual parameter of some symbol, therefore, although
Xthe details seem very obscure.
X@PP
XBut the most profound consequence of having two types of attachment
Xpoint is that it leads to two distinctive tree structures.  Considering
Xinvocation points only leads to static trees like this one:
X@ID @I @Fig margin { 0.3c } { @Tree {
X@Node @Ellipse { body text }
X@LeftSub { @Node @Ellipse footnote }
X@RightSub {
X   @Node @Ellipse figure
X   @FirstSub { @Node @Ellipse footnote }
X}
X}}
Xwhich shows that the body text contains a footnote and a figure, the
Xlatter itself containing a footnote.  Considering points of appearance
Xonly gives a completely different, dynamic tree:
X@ID @I @Fig margin { 0.3c } { @Tree {
X@Node @Ellipse { sequence of pages }
X@FirstSub { @Node @Ellipse { body text } }
X@NextSub  { @Node @Ellipse { footnote  } }
X@NextSub  { @Node @Ellipse { figure    } }
X@NextSub  { @Node @Ellipse { footnote  } }
X}}
XThe tree can be deeper, for example with sections appearing within
Xchapters which appear within the body text, which appears within the
Xfinal sequence of pages.  Document formatting languages generally shirk
Xthe issues raised by this dual tree structure, by making the dynamic
Xtree built-in, by limiting one or both trees to two levels, and so on,
Xproviding a classic example of the impoverishing effect of failing to
Xpermit language features to attain their natural level of generality.
X@PP
XWe are thus led to propose a second abstraction for document formatting,
Xwhich we name the @I galley in recognition of its similarity to the
Xgalleys used in manual typesetting.  A galley consists of an object (such
Xas a footnote) together with a sequence of places where that object may
Xappear (such as the bottoms of the current and following pages).  Splitting
Xoccurs quite naturally when space at any place is insufficient to hold
Xthe entire object.
X@PP
XIn Lout, a footnote galley and its place of appearance are defined
Xas follows:
X@ID @Code {
X"def @FootPlace { @Galley }"
X""
X"def @FootNote into { @FootPlace&&following }"
X"    right x"
X"{ x }"
X}
XThe @Code "@FootPlace" symbol contains the special symbol {@Code "@Galley"},
Xindicating that it is a point of appearance for a galley.  By placing
Xinvocations of @Code "@FootPlace" at the bottoms of pages, as in Section
X{@NumberOf recursion}, we define the desired points of appearance for
Xfootnotes.  Symbols whose body contains @Code "@Galley" either directly
Xor indirectly are called receptive symbols, meaning receptive to
Xgalleys, and they are expanded only on demand.  The effect of the
X@Code "into" clause is to make each invocation of @Code "@FootNote" a
Xgalley whose object is the result of the invocation in the usual way,
Xand whose sequence of points of appearance is specified by the @Code "into"
Xclause; in this example, the sequence of all @Code "@FootPlace" symbols
Xfollowing the invocation point.
X@PP
XLout permits galleys to be invoked within other galleys to arbitrary
Xdepth, so that one may have footnotes within figures within the body
Xtext galley, for example, creating arbitrary static trees.  Receptive
Xsymbols like @Code "@FootPlace" may appear within any galley, creating
Xarbitrary dynamic trees as well.  The root of the dynamic tree, which
Xwould normally consist of the sequence of pages of the complete assembled
Xdocument, is considered to be a galley whose point of appearance is the 
Xoutput file.  Points of appearance may be @Code preceding or @Code following
Xthe invocation point; entries in tables of contents are the main users
Xof {@Code preceding}.
X@PP
XThe galley abstraction is adequate for all of the applications listed at
Xthe beginning of this section, except that there is no provision for
Xsorting index entries and references.  Sorting of galleys has been added
Xto Lout as a built-in feature, invoked by adding a special @Code "@Key"
Xparameter to the galleys, and using its value as the sort key.  The author
Xwas at a loss to find any other way, or any useful generalization of this
Xfeature.  Its implementation will be discussed in Section
X{@NumberOf cross.impl}.
X@End @SubSection
END_OF_FILE
  if test 6118 -ne `wc -c <'lout/doc/tr.impl/s5.1'`; then
    echo shar: \"'lout/doc/tr.impl/s5.1'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s5.1'
fi
if test -f 'lout/doc/tr.lout/ch2.01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch2.01'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch2.01'\" \(6076 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch2.01' <<'END_OF_FILE'
X@Section
X  @Tag { lexical }
X  @Title { Lexical structure (words, spaces, symbols) and macros }
X@Begin
X@PP
XThe input to Lout consists of a sequence of @I {textual units},
Xtextual.unit @Index {Textual unit }
Xwhich may be
Xeither {@I{white spaces}},
X@I identifiers,
X@I delimiters,
Xor
X@I {literal words}.  Each
Xis a sequence of @I characters chosen from:
Xletter @Index { Letter character }
Xpunctuation @Index { Punctuation character }
Xquote @Index { Quote character }
Xescape @Index { Escape character }
Xcomment.char @Index { Comment character }
X@ID @Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col A ! @Col B }
X{
X@Rowa A { letter      } B { @Code "@ab-zAB-Z" }
X@Rowa A { punctuation } B { @Code "!$%&'()*+,-./0123456789:;<=>?[]^_`{|}~" }
X@Rowa A { white space } B { @I { space  tab  newline } }
X@Rowa A { quote       } B { @Code "\"" }
X@Rowa A { escape      } B { @Code "\\" }
X@Rowa A { comment     } B { @Code "#" }
X}
XNotice that @Code "@" is classed as a letter, and the ten digits as
Xpunctuation characters.
X@PP
XA @I {white space} is a sequence of one or more white space characters.
Xwhite.space @Index { White space }
Xspace.f @Index { Space }
X@PP
XAn @I identifier is a sequence of one or more letters which is the name of a
Xidentifier @Index { Identifier }
Xsymbol.  It is conventional but not essential to begin identifiers with
X{@Code "@"};  Basser Lout will print a warning message if it finds an
Xunquoted literal word (see below) beginning with {@Code "@"}, since such
Xwords are usually misspelt identifiers.  The complete list of predefined
Xidentifiers is
X@ID @Code {
X{     "@Begin"
X  @JL "@Break"
X  @JL "@Case"
X  @JL "@Database"
X  @JL "@End"
X  @JL "@Font"
X  @JL "@Galley"
X  @JL "@Graphic"
X  @JL "@HAdjust"
X  @JL "@HContract"
X  @JL "@HExpand"
X  @JL "@High"
X  @JL "@HScale"
X  @JL "@Include"
X  @JL "@IncludeGraphic"
X} |4.4cx {
X      "@Key"
X  @JL "@LClos"
X  @JL "@LEnv"
X  @JL "@LInput"
X  @JL "@LVis"
X  @JL "@Moment"
X  @JL "@Next"
X  @JL "@Null"
X  @JL "@OneCol"
X  @JL "@OneRow"
X  @JL "@Open"
X  @JL "@PAdjust"
X  @JL "@PrependGraphic"
X  @JL "@Rotate"
X  @JL "@Scale"
X} |4.4cx {
X      "@Space"
X  @JL "@SysDatabase"
X  @JL "@SysInclude"
X  @JL "@SysIncludeGraphic"
X  @JL "@SysPrependGraphic"
X  @JL "@Tag"
X  @JL "@Tagged"
X  @JL "@Use"
X  @JL "@VAdjust"
X  @JL "@VContract"
X  @JL "@VExpand"
X  @JL "@VScale"
X  @JL "@Wide"
X  @JL "@Yield"
X}
X}
Xplus the names of the parameters of @@Moment.  The symbols @@LClos, @@LEnv,
Xlclos@Index { @@LClos symbol }
Xlenv @Index { @@LEnv symbol }
Xlinput @Index { @@LInput symbol }
Xlvis @Index { @@LVis symbol }
X@@LInput, and @@LVis appear in cross reference databases generated by Lout
Xand are not for use elsewhere.
X@PP
XA @I delimiter is a sequence of one or more punctuation characters which
Xdelimiter @Index { Delimiter }
Xis the name of a symbol.  For example, @Code "{" and @Code
X"//" are delimiters.  When defining a delimiter, the name must be enclosed
Xin quotes:
X@ID @Code {
X"def  \"^\"  { {}  ^&  {} }"
X}
Xbut quotes are not used when the delimiter is invoked.  A delimiter may
Xhave other delimiters and punctuation and other characters adjacent,
Xwhereas identifiers may not be adjacent to letters or other
Xidentifiers.  The complete list of predefined delimiters is
X@ID @Code {
X{
X      "/"
X  @JL "//"
X  @JL "^/"
X  @JL "^//"
X} |2.2cx {
X      "|"
X  @JL "||"
X  @JL "^|"
X  @JL "^||"
X} |2.2cx {
X      "&"
X  @JL "^&"
X} |2.2cx {
X      "&&"
X  @JL "{"
X  @JL "}"
X}
X}
XA longer delimiter like @Code "<=" will be recognised in
Xpreference to a shorter one like {@Code "<"}.
X@PP
XA sequence of characters which is neither a white space, an identifier, nor a
Xdelimiter, is by default a @I {literal word}, which means that it will
Xword @Index { Word }
Xliteral.word @Index { Literal word }
Xquoted.word @Index { Quoted word }
Xpass through Lout unchanged.  An arbitrary sequence of characters
Xenclosed in double quotes, for example @Code "\"{  }\"", is also a
Xliteral word.  Space characters may be included, but not tabs or
Xnewlines.  There are special character sequences, used only between
Xquotes, for obtaining otherwise inaccessible characters:
X@ID @Tab
X   vmargin { 0.5vx }
X   @Fmta { @Col A ! @Col B }
X{
X@Rowa A { @Code "\\\""   } B { produces @Code "\"" }
X@Rowa A { @Code "\\\\"   } B { "\\" }
X@Rowa A { @Code "\\ddd"  } B { the character whose ASCII code }
X@Rowa A {                } B { the up to three digit octal number {@Code ddd} }
X}
XSo, for example, @Code "\"\\\"@PP\\\"\"" produces {@Code "\"@PP\""}.
X@PP
XWhen the comment character
Xcomment @Index { Comment }
X@Code "#" is encountered, everything from
Xthat point to the end of the line is ignored.  This is useful for
Xincluding reminders to oneself, like this:
X@ID @Code {
X"# Lout user manual"
X"# J. Kingston, June 1989"
X}
Xfor temporarily deleting parts of the document, and so on.
X@PP
X@I Macros
Xmacro @Index { Macro }
Xprovide a means of defining symbols which stand for a
Xsequence of textual units rather than an object.  For example, the macro
Xdefinition
X@ID @Code {
X"macro  @PP  {  //1.3vx  2.0f @Wide  &0i }"
X}
Xmakes Lout replace the symbol @Code "@PP" by the given textual units
Xbefore assembling its input into objects.  A similar macro to this
Xone is used to separate the paragraphs of the present document.  The
Xenclosing braces and any spaces adjacent to them are dropped, which can
Xbe a problem:  @Code "@PP2i" has result {@Code "//1.3vx 2.0f @Wide &0i2i"}
Xwhich is erroneous.
X@PP
XThe meaning of symbols used within the body of a macro is determined by
Xwhere the macro is defined, not by where it is used.  Due to implementation
Xproblems, @@Open symbols will not work within macros.  Named and body
Xparameters will work if the symbol that they are parameters of is also
Xpresent.  There is no way to get a left or right brace into the body of
Xa macro without the matching brace.
X@PP
XMacros may be nested within other definitions and exported, but they may
Xnot be parameters.  They may not have parameters or nested definitions
Xof their own, and consequently a preceding @Code export clause (Section
X{@NumberOf visibility}) would be pointless; however, an @Code import
Xclause is permitted.
X@End @Section
END_OF_FILE
  if test 6076 -ne `wc -c <'lout/doc/tr.lout/ch2.01'`; then
    echo shar: \"'lout/doc/tr.lout/ch2.01'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch2.01'
fi
if test -f 'lout/doc/tr.lout/ch2.05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch2.05'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch2.05'\" \(5248 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch2.05' <<'END_OF_FILE'
X@Section
X   @Title { The style and size of objects }
X   @Tag { size }
X@Begin
X@PP
XThis section explains how Lout determines the style and size of each
Xobject.  Together, these attributes determine the object's final
Xappearance in the output.
Xstyle @Index { Style of an object }
X@PP
XThe style of an object comprises the following:
X@BulletList
X@ListItem { Which font family, face and size to use (also defining the
X@Code f unit); }
X@ListItem { What gap to replace a single space between two objects by (also
Xdefining the @Code s unit); }
X@ListItem { The kind of paragraph breaking to employ ({@Code adjust},
X{@Code ragged}, etc.) }
X@ListItem { What gap to insert between the lines of paragraphs
X(also defining the @Code v unit); }
X@ListItem { Whether to permit hyphenation or not. }
X@EndList
XThe style of an object depends on where it appears in the final
Xdocument.  For example, the style of a parameter depends on where it is
Xused; the style of a galley is the style of the first target that it
Xattempts to attach itself to.  Of course, the style of any object can be
Xchanged by using the @@Font, @@Space, and @@Break symbols.
X@PP
XThere are no standard default values for style.  Instead one must ensure
Xthat the root galley or each of its components is enclosed in @@Font
Xand @@Break symbols.  From there the style is passed to incoming galleys
Xand the objects within them.
X@PP
Xwidth. @Index { Width of an object }
Xheight. @Index { Height of an object }
Xsize. @Index { Size of an object }
XThe remainder of this section explains how the size of each object (its
Xwidth and height on the printed page) is determined.  We will treat width
Xonly, since height is determined in exactly the same way, except that the
Xcomplications introduced by paragraph breaking are absent.
X@PP
XWith three exceptions (see below), the width of an object is as large as
Xit possibly could be without violating a @@Wide symbol or intruding into
Xthe space occupied by neighbouring gaps or objects.  As an aid to
Xinvestigating this rule, we will use the definition
X@ID @Code {
X"def @Box right x"
X"{"
X"  \"0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath stroke\""
X"  @Graphic x"
X"}"
X}
Xwhich draws a box around the boundary of its right parameter (Section
X{@NumberOf graphic}).  The result of
X@ID @Code {
X"5c @Wide @Box metempsychosis"
X}
Xis
X@ID {
X5c @Wide @Box metempsychosis
X}
XThe widest that @Code "@Box metempsychosis" could possibly be is five
Xcentimetres, and accordingly that is its width.  The same applies to
X{@Code metempsychosis}, which is five centimetres wide as well.  Note
Xcarefully that there is no object in this example whose width is equal
Xto the sum of the widths of the letters of {@Code metempsychosis}.
X@PP
XThe first of the three exceptions to the `as wide as possible' rule is the
X@@HContract symbol, which causes the width of its right parameter to be
Xreduced to a reasonable minimum (a formal definition will not be attempted):
X@ID @Code {
X"5c @Wide @HContract @Box metempsychosis"
X}
Xproduces
X@ID {
X5c @Wide @HContract @Box metempsychosis
X}
XThe object @Code "@HContract @Box metempsychosis" is still five centimetres
Xwide, but the object @Code "@Box metempsychosis" has been reduced.
X@PP
XThe second of the three exceptions is the horizontal concatenation symbol
X@Code "|" (and also {@Code "&"}).  Consider this example:
X@ID @Code {
X"5c @Wide @Box { A  |1c  B  |1c  C }"
X}
XAs usual, the right parameter of @@Wide is five centimetres wide, and
Xthe result looks like this:
X@ID {
X5c @Wide @Box { A  |1c  B  |1c  C }
X}
XLout has to apportion the size minus inter-column gaps among the three
Xcolumns.
X@PP
XIf the columns are wide enough to require paragraph breaking, Lout will
Xassign sizes to the columns in such a way as to leave narrow columns
Xunbroken and break wider columns to equal width, occupying the full
Xsize.  Otherwise, paragraph breaking is not required, and each column
Xwill be assigned a reasonable minimum size in the manner of @@HContract,
Xexcept that the last column receives all the leftover width.  For example,
X@ID @Code {
X"5c @Wide { @Box A  |1c  @Box B  |1c  @Box C }"
X}
Xhas result
X@ID {
X5c @Wide { @Box A  |1c  @Box B  |1c  @Box C }
X}
XIf it is desired that the leftover width remain unused, rather than
Xgoing into the last column, an empty column can be appended, or the last
Xcolumn can be enclosed in @@HContract.  Two other ways to apportion the
Xleftover width are provided by the @@HExpand and @@HAdjust symbols
X(Sections {@NumberOf hexpand} and {@NumberOf hadjust}).
X@PP
XThe third and final exception to the `as wide as possible' rule concerns
Xthe components of the root galley.  Each is considered to be enclosed
Xroot.galley.size @SubIndex { size of components of }
Xin @@HContract and @@VContract symbols.
X@PP
XUp to this point we have treated width as a single quantity, but of
Xcourse it has two parts:  width to left and right of the mark.  The
X`as wide as possible' rule applies to both directions:
X@ID @Code {
X"@HContract { @Box 953^.05 /0.5c @Box 2^.8286 }"
X}
Xhas result
X@ID {
X@HContract { @Box 953^.05 /0.5c @Box 2^.8286 }
X}
XLeftover width usually goes to the right, as we have seen, but here some
Xwidth was available only to the left of {@Code "2.8286"} owing to the
Xcolumn mark alignment.
X@End @Section
END_OF_FILE
  if test 5248 -ne `wc -c <'lout/doc/tr.lout/ch2.05'`; then
    echo shar: \"'lout/doc/tr.lout/ch2.05'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch2.05'
fi
if test -f 'lout/doc/tr.lout/ch3.07' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.07'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.07'\" \(977 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.07' <<'END_OF_FILE'
X@Section
X   @Title { "@Wide" and "@High" }
X   @Tag { wide }
X@Begin
X@PP
XThe @@Wide symbol
Xwide.sym @Index { @@Wide symbol }
Xreturns its right parameter modified to have the width given by its left
Xparameter, which must be a length (Section {@NumberOf concatenation})
Xwhose unit of measurement is {@Code "c"}, {@Code "i"}, {@Code "p"},
X{@Code "m"}, {@Code "f"}, {@Code "s"}, or {@Code "v"}.  If the right
Xparameter is not as wide as required, white space is added at the right;
Xif it is too wide, its paragraphs are broken (Section {@NumberOf break})
Xso that it fits.  A @@OneCol operation is included in the effect of @@Wide,
Xsince it does not make sense for an object of fixed width to have two column
Xmarks.
X@PP
Xhigh.sym @Index { @@High symbol }
XThe @@High symbol similarly ensures that its result is of a given height,
Xby adding white space at the bottom.  In this case it is an error for the
Xright parameter to be too large.  A @@OneRow operation is included.
X@End @Section
END_OF_FILE
  if test 977 -ne `wc -c <'lout/doc/tr.lout/ch3.07'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.07'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.07'
fi
if test -f 'lout/z32.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z32.c'\"
else
  echo shar: Extracting \"'lout/z32.c'\" \(5594 characters\)
  sed "s/^X//" >'lout/z32.c' <<'END_OF_FILE'
X/*@z32.c:Counter Service:Next()@**********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z32.c                                                      */
X/*  MODULE:       Counter Service                                            */
X/*  EXTERNS:      Next()                                                     */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define isdigit(x)	( (x) >= '0' && (x) <= '9' )
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT Next(x, inc, done)                                                */
X/*                                                                           */
X/*  Return x with its value incremented by inc (if possible).                */
X/*  Set *done to TRUE if successful, leave *done unchanged otherwise.        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT Next(x, inc, done)
XOBJECT x; int inc; BOOLEAN *done;
X{ OBJECT y, link;  int l, r, n, len;
X  unsigned char buff[MAX_LINE + 1];
X  debug3(DCS, DD, "Next( %s, %d, %s )", EchoObject(null, x), inc, bool(*done));
X  switch( type(x) )
X  {
X    case WORD:
X    
X      len = strlen(string(x));
X      for( r = len - 1;  r >= 0 && !isdigit(string(x)[r]);  r--);
X      if( r < 0 ) break;
X      for( l = r-1;  l >= 0 && isdigit(string(x)[l]);  l-- );
X      sscanf(&string(x)[l+1], "%d", &n);
X      string(x)[l+1] = '\0';
X      sprintf(buff, "%s%d%s", string(x), n+inc, &string(x)[r+1]);
X      if( strlen(buff) >= MAX_LINE )
X	Error(FATAL, &fpos(x), "word %s is too long", buff);
X      y = MakeWord(buff, &fpos(x));
X      word_font(y) = word_font(x);
X      MergeNode(y, x);  x = y;
X      *done = TRUE;
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GAP_OBJ:
X    case CLOSURE:
X    case NULL_CLOS:
X    case CROSS:
X    
X      break;
X
X
X    case ONE_COL:
X    case ONE_ROW:
X    case WIDE:
X    case HIGH:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case HSCALE:
X    case VSCALE:
X    case ROTATE:
X    case SCALE:
X    case SPLIT:
X    case GRAPHIC:
X    
X      Child(y, LastDown(x));
X      y = Next(y, inc, done);
X      break;
X
X
X    case ACAT:
X    
X      /* ***
X      x = ReplaceWithTidy(x);
X      *** */
X      if( type(x) == WORD )
X      {	len = strlen(string(x));
X	for( r = len-1; r >= 0 && !isdigit(string(x)[r]); r--);
X	if( r < 0 ) break;
X	for( l = r-1;  l >= 0 && isdigit(string(x)[l]);  l-- );
X	sscanf(&string(x)[l+1], "%d", &n);
X	string(x)[l+1] = '\0';
X	sprintf(buff,"%s%d%s",string(x),n+inc,&string(x)[r+1]);
X	y = MakeWord(buff, &fpos(x));
X	word_font(y) = word_font(x);
X	MergeNode(y, x);  x = y;
X	*done = TRUE;
X      }
X      else
X      {	assert( type(x) == ACAT, "Next: ACAT!" );
X	link = LastDown(x);
X	while( link != x && !*done )
X	{ Child(y, link);
X	  if( is_index(type(y)) )  continue;
X	  y = Next(y, inc, done);
X	  if( !*done )  link = PrevDown(link);
X	}
X      }
X      break;
X
X
X    case COL_THR:
X    case ROW_THR:
X    case HCAT:
X    case VCAT:
X    
X      link = LastDown(x);
X      while( link != x && !*done )
X      {	Child(y, link);
X	if( is_index(type(y)) )  continue;
X	y = Next(y, inc, done);
X	if( !*done )  link = PrevDown(link);
X      }
X      break;
X
X
X    default:
X    
X      Error(INTERN,&fpos(x), "Next: type(x) = %s", Image(type(x)));
X      break;
X
X  } /* end switch */
X  debug1(DCS, DD, "Next returning %s", EchoObject(null, x));
X  return x;
X} /* end Next */
END_OF_FILE
  if test 5594 -ne `wc -c <'lout/z32.c'`; then
    echo shar: \"'lout/z32.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z32.c'
fi
if test -f 'lout/z34.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z34.c'\"
else
  echo shar: Extracting \"'lout/z34.c'\" \(5705 characters\)
  sed "s/^X//" >'lout/z34.c' <<'END_OF_FILE'
X/*@z34.c:Rotation Service:RotateSize()@***************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z34.c                                                      */
X/*  MODULE:       Rotation Service                                           */
X/*  EXTERNS:      RotateSize()                                               */
X/*                                                                           */
X/*****************************************************************************/
X#include <math.h>
X#ifndef M_PI
X#define M_PI       3.1415926535897931160E0
X#endif
X#include "externs"
X
Xtypedef struct { double x, y;          } rect_coord;
Xtypedef struct { double angle, radius; } polar_coord;
X
X#define rect_to_polar(rect, polar)				\
Xpolar.angle = atan2(rect.y, rect.x),				\
Xpolar.radius = sqrt(rect.x*rect.x + rect.y*rect.y)
X
X#define polar_to_rect(polar, rect)				\
Xrect.x = polar.radius * cos(polar.angle),			\
Xrect.y = polar.radius * sin(polar.angle)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  RotateSize(xcb, xcf, xrb, xrf, y, theta)                                 */
X/*                                                                           */
X/*  Calculate the size of x, assuming that it is y rotated by theta degrees. */
X/*                                                                           */
X/*****************************************************************************/
X
XRotateSize(xcb, xcf, xrb, xrf, y, theta)
XLENGTH *xcb, *xcf, *xrb, *xrf;  OBJECT y;  LENGTH theta;
X{ rect_coord ycorners[4], xcorner;  polar_coord pol;
X  double maxx, maxy, minx, miny, ang;  int i;
X  unsigned char buff1[20], buff2[20];
X
X  /* calculate theta in radians */
X  ang = (double) theta * 2 * M_PI / (double) (DG * 360);
X  ifdebug(DRS, D, sprintf(buff2, "%.1f", ang));
X  debug2(DRS, D, "RotateSize( %s, %s )", EchoObject(null, y), buff2);
X  debug4(DRS, DD, "  ycb %s, ycf %s, yrb %s, yrf %s",
X	EchoLength(back(y, COL)), EchoLength(fwd(y, COL)),
X	EchoLength(back(y, ROW)), EchoLength(fwd(y, ROW)));
X
X  /* set up coordinates of the four corners of y */
X  ycorners[0].x =   (float) fwd(y, COL);
X  ycorners[0].y =   (float) back(y, ROW);
X  ycorners[1].x = - (float) back(y, COL);
X  ycorners[1].y =   (float) back(y, ROW);
X  ycorners[2].x = - (float) back(y, COL);
X  ycorners[2].y = - (float) fwd(y, ROW);
X  ycorners[3].x =   (float) fwd(y, COL);
X  ycorners[3].y = - (float) fwd(y, ROW);
X
X  /* rotate these four corners by theta and store their extremes */
X  maxx = maxy = (float) - MAX_LEN;
X  minx = miny = (float) MAX_LEN;
X  for( i = 0;  i < 4;  i++ )
X  {	
X    if( ycorners[i].x == 0 && ycorners[i].y == 0 )
X    {	pol.radius = 0; pol.angle  = 0; }
X    else rect_to_polar(ycorners[i], pol);
X    ifdebug(DRS, DD, sprintf(buff1, "%.1f", pol.angle));
X    ifdebug(DRS, DD, sprintf(buff2, "%.1f", ang));
X    debug5(DRS, DD, "  transforming (%s, %s) -> (%s, %s) + %s",
X      EchoLength( (int) ycorners[i].x), EchoLength( (int) ycorners[i].y),
X      EchoLength( (int) pol.radius), buff1, buff2);
X    pol.angle += ang;
X    polar_to_rect(pol, xcorner);
X    ifdebug(DRS, DD, sprintf(buff1, "%.1f", pol.angle));
X    debug4(DRS, DD, "    transforming (%s, %s) -> (%s, %s)",
X      EchoLength( (int) pol.radius), buff1,
X      EchoLength( (int) xcorner.x), EchoLength( (int) xcorner.y) );
X    maxx = max(maxx, xcorner.x);    minx = min(minx, xcorner.x);
X    maxy = max(maxy, xcorner.y);    miny = min(miny, xcorner.y);
X  }
X
X  /* store sizes back into x and return */
X  *xcb = - (int) minx;    *xcf  =   (int) maxx;
X  *xrb =   (int) maxy;    *xrf  = - (int) miny;
X  debug0(DRS, D, "RotateSize returning.");
X  debug4(DRS, DD, "  xcb %s, xcf %s, xrb %s, xrf %s",
X    EchoLength(*xcb), EchoLength(*xcf),
X    EchoLength(*xrb), EchoLength(*xrf));
X} /* end RotateSize */
END_OF_FILE
  if test 5705 -ne `wc -c <'lout/z34.c'`; then
    echo shar: \"'lout/z34.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z34.c'
fi
echo shar: End of archive 26 \(of 30\).
cp /dev/null ark26isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
