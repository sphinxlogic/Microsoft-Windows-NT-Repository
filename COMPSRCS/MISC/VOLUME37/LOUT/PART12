Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i110:  lout - Lout document formatting system, v2, Part12/30
Message-ID: <1993Jun1.051916.25866@sparky.imd.sterling.com>
X-Md4-Signature: adfbf685f822e3087b06fc500b554929
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 1 Jun 1993 05:19:16 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 110
Archive-name: lout/part12
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/font0/TimesIta.AFM lout/include/fig_prepend
#   lout/z13.c lout/z25.c
# Wrapped by kent@sparky on Sun May 30 19:43:56 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 30)."'
if test -f 'lout/font0/TimesIta.AFM' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/font0/TimesIta.AFM'\"
else
  echo shar: Extracting \"'lout/font0/TimesIta.AFM'\" \(15725 characters\)
  sed "s/^X//" >'lout/font0/TimesIta.AFM' <<'END_OF_FILE'
XStartFontMetrics 2.0
XComment Copyright (c) 1984 Adobe Systems Incorporated. 	All Rights Reserved.
XComment Creation Date:Sun Feb 8 03:54:53 PST 1987
XFontName Times-Italic
XEncodingScheme AdobeStandardEncoding
XFullName Times Italic
XFamilyName Times
XWeight Medium
XItalicAngle -15.5
XIsFixedPitch false
XUnderlinePosition -96
XUnderlineThickness 48
XVersion 001.002
XNotice Times is a trademark of Allied Corporation.
XFontBBox -176 -252 990 930
XCapHeight 660
XXHeight 446
XDescender -206
XAscender 684
XStartCharMetrics 228
XC 32 ; WX 250 ; N space ; B 0 0 0 0 ;
XC 33 ; WX 333 ; N exclam ; B 46 -10 296 670 ;
XC 34 ; WX 420 ; N quotedbl ; B 107 442 402 673 ;
XC 35 ; WX 500 ; N numbersign ; B -7 -6 508 683 ;
XC 36 ; WX 500 ; N dollar ; B 13 -102 481 735 ;
XC 37 ; WX 833 ; N percent ; B 63 -14 770 682 ;
XC 38 ; WX 778 ; N ampersand ; B 60 -22 698 673 ;
XC 39 ; WX 333 ; N quoteright ; B 69 458 206 678 ;
XC 40 ; WX 333 ; N parenleft ; B 41 -180 312 662 ;
XC 41 ; WX 333 ; N parenright ; B 19 -178 286 664 ;
XC 42 ; WX 500 ; N asterisk ; B 60 268 434 684 ;
XC 43 ; WX 675 ; N plus ; B 85 0 589 505 ;
XC 44 ; WX 250 ; N comma ; B 57 -126 194 94 ;
XC 45 ; WX 333 ; N hyphen ; B 55 192 276 254 ;
XC 46 ; WX 250 ; N period ; B 75 -10 175 90 ;
XC 47 ; WX 278 ; N slash ; B 2 -14 252 641 ;
XC 48 ; WX 500 ; N zero ; B 19 -9 470 683 ;
XC 49 ; WX 500 ; N one ; B 31 0 390 684 ;
XC 50 ; WX 500 ; N two ; B -7 0 429 682 ;
XC 51 ; WX 500 ; N three ; B -7 -12 443 682 ;
XC 52 ; WX 500 ; N four ; B -8 0 454 681 ;
XC 53 ; WX 500 ; N five ; B -12 -15 462 666 ;
XC 54 ; WX 500 ; N six ; B 24 -8 497 685 ;
XC 55 ; WX 500 ; N seven ; B 56 -12 512 666 ;
XC 56 ; WX 500 ; N eight ; B 12 -7 475 681 ;
XC 57 ; WX 500 ; N nine ; B 10 -18 470 684 ;
XC 58 ; WX 333 ; N colon ; B 86 -10 284 444 ;
XC 59 ; WX 333 ; N semicolon ; B 63 -124 292 441 ;
XC 60 ; WX 675 ; N less ; B 83 -7 592 515 ;
XC 61 ; WX 675 ; N equal ; B 85 125 589 383 ;
XC 62 ; WX 675 ; N greater ; B 82 -7 591 515 ;
XC 63 ; WX 500 ; N question ; B 105 -10 439 670 ;
XC 64 ; WX 920 ; N at ; B 39 -191 866 648 ;
XC 65 ; WX 611 ; N A ; B -45 0 564 672 ;
XC 66 ; WX 611 ; N B ; B -28 0 562 660 ;
XC 67 ; WX 667 ; N C ; B 33 -23 653 672 ;
XC 68 ; WX 722 ; N D ; B -27 0 671 660 ;
XC 69 ; WX 611 ; N E ; B -17 0 609 660 ;
XC 70 ; WX 611 ; N F ; B -17 0 609 660 ;
XC 71 ; WX 722 ; N G ; B 31 -23 701 672 ;
XC 72 ; WX 722 ; N H ; B -26 0 742 660 ;
XC 73 ; WX 333 ; N I ; B -26 0 357 660 ;
XC 74 ; WX 444 ; N J ; B -36 -22 479 660 ;
XC 75 ; WX 667 ; N K ; B -15 0 702 660 ;
XC 76 ; WX 556 ; N L ; B -32 0 535 660 ;
XC 77 ; WX 833 ; N M ; B -24 0 850 660 ;
XC 78 ; WX 667 ; N N ; B -36 -12 698 660 ;
XC 79 ; WX 722 ; N O ; B 42 -23 676 671 ;
XC 80 ; WX 611 ; N P ; B -16 0 582 660 ;
XC 81 ; WX 722 ; N Q ; B 41 -186 681 671 ;
XC 82 ; WX 611 ; N R ; B -32 0 566 660 ;
XC 83 ; WX 500 ; N S ; B 9 -22 483 674 ;
XC 84 ; WX 556 ; N T ; B 32 0 602 660 ;
XC 85 ; WX 722 ; N U ; B 77 -21 747 660 ;
XC 86 ; WX 611 ; N V ; B 44 -20 659 660 ;
XC 87 ; WX 833 ; N W ; B 35 -20 875 660 ;
XC 88 ; WX 611 ; N X ; B -45 0 633 660 ;
XC 89 ; WX 556 ; N Y ; B 44 0 600 660 ;
XC 90 ; WX 556 ; N Z ; B -19 0 581 660 ;
XC 91 ; WX 389 ; N bracketleft ; B 22 -170 391 654 ;
XC 92 ; WX 278 ; N backslash ; B 2 -12 252 651 ;
XC 93 ; WX 389 ; N bracketright ; B -31 -170 341 654 ;
XC 94 ; WX 422 ; N asciicircum ; B 0 254 503 660 ;
XC 95 ; WX 500 ; N underscore ; B -9 -252 510 -206 ;
XC 96 ; WX 333 ; N quoteleft ; B 149 457 286 677 ;
XC 97 ; WX 500 ; N a ; B 15 -11 474 446 ;
XC 98 ; WX 500 ; N b ; B 24 -12 475 682 ;
XC 99 ; WX 444 ; N c ; B 32 -11 420 446 ;
XC 100 ; WX 500 ; N d ; B 15 -11 521 684 ;
XC 101 ; WX 444 ; N e ; B 34 -13 412 446 ;
XC 102 ; WX 278 ; N f ; B -148 -207 415 684 ; L i fi ; L l fl ;
XC 103 ; WX 500 ; N g ; B 10 -209 471 445 ;
XC 104 ; WX 500 ; N h ; B 23 -10 473 684 ;
XC 105 ; WX 278 ; N i ; B 43 -10 263 660 ;
XC 106 ; WX 278 ; N j ; B -109 -207 287 660 ;
XC 107 ; WX 444 ; N k ; B 16 -12 460 685 ;
XC 108 ; WX 278 ; N l ; B 41 -10 276 685 ;
XC 109 ; WX 722 ; N m ; B 11 -10 698 447 ;
XC 110 ; WX 500 ; N n ; B 23 -10 471 447 ;
XC 111 ; WX 500 ; N o ; B 27 -13 467 448 ;
XC 112 ; WX 500 ; N p ; B -75 -206 465 446 ;
XC 113 ; WX 500 ; N q ; B 20 -206 483 445 ;
XC 114 ; WX 389 ; N r ; B 24 0 392 446 ;
XC 115 ; WX 389 ; N s ; B 16 -14 367 446 ;
XC 116 ; WX 278 ; N t ; B 38 -10 288 548 ;
XC 117 ; WX 500 ; N u ; B 42 -11 472 447 ;
XC 118 ; WX 444 ; N v ; B 24 -11 423 444 ;
XC 119 ; WX 667 ; N w ; B 14 -10 650 447 ;
XC 120 ; WX 444 ; N x ; B -31 -10 450 446 ;
XC 121 ; WX 444 ; N y ; B -27 -209 420 445 ;
XC 122 ; WX 389 ; N z ; B 2 0 380 434 ;
XC 123 ; WX 400 ; N braceleft ; B 65 -179 411 675 ;
XC 124 ; WX 275 ; N bar ; B -22 -188 251 670 ;
XC 125 ; WX 400 ; N braceright ; B -66 -179 300 675 ;
XC 126 ; WX 541 ; N asciitilde ; B 18 169 522 340 ;
XC 161 ; WX 389 ; N exclamdown ; B 59 -213 317 468 ;
XC 162 ; WX 500 ; N cent ; B 62 -146 449 564 ;
XC 163 ; WX 500 ; N sterling ; B -5 -9 498 672 ;
XC 164 ; WX 167 ; N fraction ; B -176 -15 338 672 ;
XC 165 ; WX 500 ; N yen ; B 13 0 609 684 ;
XC 166 ; WX 500 ; N florin ; B 3 -189 492 688 ;
XC 167 ; WX 500 ; N section ; B 42 -96 455 743 ;
XC 168 ; WX 500 ; N currency ; B 3 105 498 604 ;
XC 169 ; WX 214 ; N quotesingle ; B 99 453 247 678 ;
XC 170 ; WX 556 ; N quotedblleft ; B 166 457 510 677 ;
XC 171 ; WX 500 ; N guillemotleft ; B 54 39 444 400 ;
XC 172 ; WX 333 ; N guilsinglleft ; B 60 39 285 400 ;
XC 173 ; WX 333 ; N guilsinglright ; B 49 34 269 406 ;
XC 174 ; WX 500 ; N fi ; B -136 -207 468 684 ;
XC 175 ; WX 500 ; N fl ; B -140 -207 509 684 ;
XC 177 ; WX 500 ; N endash ; B -3 194 501 242 ;
XC 178 ; WX 500 ; N dagger ; B 92 -93 480 734 ;
XC 179 ; WX 500 ; N daggerdbl ; B 20 -93 482 743 ;
XC 180 ; WX 250 ; N periodcentered ; B 75 192 199 316 ;
XC 182 ; WX 523 ; N paragraph ; B 87 -196 533 675 ;
XC 183 ; WX 350 ; N bullet ; B 50 175 300 425 ;
XC 184 ; WX 333 ; N quotesinglbase ; B 83 -126 220 94 ;
XC 185 ; WX 556 ; N quotedblbase ; B 63 -126 407 94 ;
XC 186 ; WX 556 ; N quotedblright ; B 68 458 412 678 ;
XC 187 ; WX 500 ; N guillemotright ; B 59 34 442 406 ;
XC 188 ; WX 889 ; N ellipsis ; B 62 -10 828 90 ;
XC 189 ; WX 1000 ; N perthousand ; B 9 -65 990 690 ;
XC 191 ; WX 500 ; N questiondown ; B 55 -215 395 462 ;
XC 193 ; WX 333 ; N grave ; B 160 491 333 659 ;
XC 194 ; WX 333 ; N acute ; B 154 501 375 680 ;
XC 195 ; WX 333 ; N circumflex ; B 96 495 374 669 ;
XC 196 ; WX 333 ; N tilde ; B 114 518 386 639 ;
XC 197 ; WX 333 ; N macron ; B 120 543 380 603 ;
XC 198 ; WX 333 ; N breve ; B 140 512 401 645 ;
XC 199 ; WX 333 ; N dotaccent ; B 112 515 222 625 ;
XC 200 ; WX 333 ; N dieresis ; B 117 534 389 634 ;
XC 202 ; WX 333 ; N ring ; B 239 509 433 703 ;
XC 203 ; WX 333 ; N cedilla ; B -30 -206 214 0 ;
XC 205 ; WX 333 ; N hungarumlaut ; B 62 532 348 749 ;
XC 206 ; WX 333 ; N ogonek ; B -44 -159 169 40 ;
XC 207 ; WX 333 ; N caron ; B 138 495 422 669 ;
XC 208 ; WX 889 ; N emdash ; B -65 194 945 242 ;
XC 225 ; WX 889 ; N AE ; B -46 0 889 660 ;
XC 227 ; WX 276 ; N ordfeminine ; B 32 300 310 677 ;
XC 232 ; WX 556 ; N Lslash ; B 0 0 567 660 ;
XC 233 ; WX 722 ; N Oslash ; B 40 -110 683 738 ;
XC 234 ; WX 944 ; N OE ; B 30 -10 943 668 ;
XC 235 ; WX 310 ; N ordmasculine ; B 45 301 310 679 ;
XC 241 ; WX 667 ; N ae ; B 24 -12 638 448 ;
XC 245 ; WX 278 ; N dotlessi ; B 47 -10 226 447 ;
XC 248 ; WX 278 ; N lslash ; B 0 -10 264 685 ;
XC 249 ; WX 500 ; N oslash ; B 28 -132 468 560 ;
XC 250 ; WX 667 ; N oe ; B 26 -15 643 445 ;
XC 251 ; WX 500 ; N germandbls ; B -167 -209 492 684 ;
XC -1 ; WX 611 ; N Aacute ; B -45 0 564 907 ;
XC -1 ; WX 611 ; N Acircumflex ; B -45 0 564 896 ;
XC -1 ; WX 611 ; N Adieresis ; B -45 0 564 861 ;
XC -1 ; WX 611 ; N Agrave ; B -45 0 564 886 ;
XC -1 ; WX 611 ; N Aring ; B -45 0 564 930 ;
XC -1 ; WX 611 ; N Atilde ; B -45 0 564 866 ;
XC -1 ; WX 667 ; N Ccedilla ; B 33 -206 653 672 ;
XC -1 ; WX 611 ; N Eacute ; B -17 0 609 907 ;
XC -1 ; WX 611 ; N Ecircumflex ; B -17 0 609 896 ;
XC -1 ; WX 611 ; N Edieresis ; B -17 0 609 861 ;
XC -1 ; WX 611 ; N Egrave ; B -17 0 609 886 ;
XC -1 ; WX 722 ; N Eth ; B -27 0 671 660 ;
XC -1 ; WX 333 ; N Iacute ; B -26 0 389 907 ;
XC -1 ; WX 333 ; N Icircumflex ; B -26 0 388 896 ;
XC -1 ; WX 333 ; N Idieresis ; B -26 0 403 861 ;
XC -1 ; WX 333 ; N Igrave ; B -26 0 357 886 ;
XC -1 ; WX 667 ; N Ntilde ; B -36 -12 698 866 ;
XC -1 ; WX 722 ; N Oacute ; B 42 -23 676 907 ;
XC -1 ; WX 722 ; N Ocircumflex ; B 42 -23 676 896 ;
XC -1 ; WX 722 ; N Odieresis ; B 42 -23 676 861 ;
XC -1 ; WX 722 ; N Ograve ; B 42 -23 676 886 ;
XC -1 ; WX 722 ; N Otilde ; B 42 -23 676 866 ;
XC -1 ; WX 500 ; N Scaron ; B 9 -22 506 896 ;
XC -1 ; WX 611 ; N Thorn ; B -16 0 547 660 ;
XC -1 ; WX 722 ; N Uacute ; B 77 -21 747 907 ;
XC -1 ; WX 722 ; N Ucircumflex ; B 77 -21 747 896 ;
XC -1 ; WX 722 ; N Udieresis ; B 77 -21 747 861 ;
XC -1 ; WX 722 ; N Ugrave ; B 77 -21 747 886 ;
XC -1 ; WX 556 ; N Yacute ; B 44 0 600 894 ;
XC -1 ; WX 556 ; N Ydieresis ; B 44 0 600 861 ;
XC -1 ; WX 556 ; N Zcaron ; B -19 0 581 896 ;
XC -1 ; WX 500 ; N aacute ; B 15 -11 474 680 ;
XC -1 ; WX 500 ; N acircumflex ; B 15 -11 474 669 ;
XC -1 ; WX 500 ; N adieresis ; B 15 -11 479 634 ;
XC -1 ; WX 500 ; N agrave ; B 15 -11 474 659 ;
XC -1 ; WX 500 ; N aring ; B 15 -11 474 703 ;
XC -1 ; WX 500 ; N atilde ; B 15 -11 476 639 ;
XC -1 ; WX 275 ; N brokenbar ; B -22 -188 251 670 ;
XC -1 ; WX 444 ; N ccedilla ; B 32 -206 420 446 ;
XC -1 ; WX 760 ; N copyright ; B 40 -22 719 672 ;
XC -1 ; WX 400 ; N degree ; B 70 384 370 684 ;
XC -1 ; WX 675 ; N divide ; B 85 0 589 505 ;
XC -1 ; WX 444 ; N eacute ; B 34 -13 444 680 ;
XC -1 ; WX 444 ; N ecircumflex ; B 34 -13 443 669 ;
XC -1 ; WX 444 ; N edieresis ; B 34 -13 458 634 ;
XC -1 ; WX 444 ; N egrave ; B 34 -13 412 659 ;
XC -1 ; WX 500 ; N eth ; B 27 -13 487 682 ;
XC -1 ; WX 278 ; N iacute ; B 47 -10 341 680 ;
XC -1 ; WX 278 ; N icircumflex ; B 47 -10 340 669 ;
XC -1 ; WX 278 ; N idieresis ; B 47 -10 355 634 ;
XC -1 ; WX 278 ; N igrave ; B 47 -10 299 659 ;
XC -1 ; WX 675 ; N logicalnot ; B 85 113 589 383 ;
XC -1 ; WX 675 ; N minus ; B 85 222 589 286 ;
XC -1 ; WX 500 ; N mu ; B -60 -206 472 446 ;
XC -1 ; WX 675 ; N multiply ; B 85 0 589 504 ;
XC -1 ; WX 500 ; N ntilde ; B 23 -10 471 639 ;
XC -1 ; WX 500 ; N oacute ; B 27 -13 467 680 ;
XC -1 ; WX 500 ; N ocircumflex ; B 27 -13 467 669 ;
XC -1 ; WX 500 ; N odieresis ; B 27 -13 479 634 ;
XC -1 ; WX 500 ; N ograve ; B 27 -13 467 659 ;
XC -1 ; WX 750 ; N onehalf ; B 30 -15 720 684 ;
XC -1 ; WX 750 ; N onequarter ; B 30 -15 720 684 ;
XC -1 ; WX 300 ; N onesuperior ; B 43 274 277 683 ;
XC -1 ; WX 500 ; N otilde ; B 27 -13 476 639 ;
XC -1 ; WX 675 ; N plusminus ; B 85 0 589 645 ;
XC -1 ; WX 760 ; N registered ; B 40 -22 719 672 ;
XC -1 ; WX 389 ; N scaron ; B 16 -14 450 669 ;
XC -1 ; WX 500 ; N thorn ; B -75 -206 465 682 ;
XC -1 ; WX 750 ; N threequarters ; B 30 -15 720 684 ;
XC -1 ; WX 300 ; N threesuperior ; B 13 267 306 684 ;
XC -1 ; WX 980 ; N trademark ; B 35 268 945 672 ;
XC -1 ; WX 300 ; N twosuperior ; B 8 274 292 684 ;
XC -1 ; WX 500 ; N uacute ; B 42 -11 472 680 ;
XC -1 ; WX 500 ; N ucircumflex ; B 42 -11 472 669 ;
XC -1 ; WX 500 ; N udieresis ; B 42 -11 473 634 ;
XC -1 ; WX 500 ; N ugrave ; B 42 -11 472 659 ;
XC -1 ; WX 444 ; N yacute ; B -27 -209 431 680 ;
XC -1 ; WX 444 ; N ydieresis ; B -27 -209 445 634 ;
XC -1 ; WX 389 ; N zcaron ; B 2 0 450 669 ;
XEndCharMetrics
XStartKernData
XStartKernPairs 120
X
XKPX A y -55
XKPX A w -55
XKPX A v -55
XKPX A space -18
XKPX A quoteright -37
XKPX A Y -55
XKPX A W -37
XKPX A V -50
XKPX A T -37
X
XKPX F period -129
XKPX F comma -129
XKPX F A -129
X
XKPX L y -30
XKPX L space -18
XKPX L quoteright -37
XKPX L Y -20
XKPX L W -37
XKPX L V -37
XKPX L T -20
X
XKPX P space -18
XKPX P period -129
XKPX P comma -129
XKPX P A -129
X
XKPX R y -18
XKPX R Y -18
XKPX R W -18
XKPX R V -18
XKPX R T 0
X
XKPX T y -74
XKPX T w -74
XKPX T u -55
XKPX T space -18
XKPX T semicolon -65
XKPX T s -92
XKPX T r -55
XKPX T period -74
XKPX T o -92
XKPX T i -55
XKPX T hyphen -74
XKPX T e -92
XKPX T comma -74
XKPX T colon -55
XKPX T c -92
XKPX T a -92
XKPX T O -18
XKPX T A -74
X
XKPX V y -92
XKPX V u -74
XKPX V space -18
XKPX V semicolon -74
XKPX V r -74
XKPX V period -129
XKPX V o -111
XKPX V i -74
XKPX V hyphen -55
XKPX V e -111
XKPX V comma -129
XKPX V colon -65
XKPX V a -111
XKPX V O -30
XKPX V A -74
X
XKPX W y -92
XKPX W u -55
XKPX W semicolon -65
XKPX W r -55
XKPX W period -92
XKPX W o -92
XKPX W i -55
XKPX W hyphen -37
XKPX W e -92
XKPX W comma -92
XKPX W colon -65
XKPX W a -92
XKPX W A -70
X
XKPX Y v -92
XKPX Y u -92
XKPX Y semicolon -65
XKPX Y q -111
XKPX Y period -92
XKPX Y p -92
XKPX Y o -92
XKPX Y i -74
XKPX Y hyphen -74
XKPX Y e -92
XKPX Y comma -92
XKPX Y colon -65
XKPX Y a -92
XKPX Y A -70
X
XKPX f quoteright 92
X
XKPX one one -74
X
XKPX quoteleft quoteleft -111
X
XKPX quoteright t -111
XKPX quoteright space -111
XKPX quoteright s -129
XKPX quoteright quoteright -111
X
XKPX r y 0
XKPX r x 0
XKPX r w 0
XKPX r v 0
XKPX r u 0
XKPX r t 0
XKPX r r 0
XKPX r quoteright 37
XKPX r q -37
XKPX r period -111
XKPX r o -37
XKPX r hyphen -20
XKPX r h -18
XKPX r g -37
XKPX r e -37
XKPX r d -37
XKPX r comma -111
XKPX r c -37
X
XKPX space A -18
X
XKPX v period -74
XKPX v comma -74
X
XKPX w period -74
XKPX w comma -74
X
XKPX y period -55
XKPX y comma -55
XEndKernPairs
XEndKernData
XStartComposites 58
XCC Zcaron 2 ; PCC Z 0 0 ; PCC caron 111 227 ;
XCC zcaron 2 ; PCC z 0 0 ; PCC caron 28 0 ;
XCC Scaron 2 ; PCC S 0 0 ; PCC caron 83 227 ;
XCC scaron 2 ; PCC s 0 0 ; PCC caron 28 0 ;
XCC Ccedilla 2 ; PCC C 0 0 ; PCC cedilla 188 0 ;
XCC ccedilla 2 ; PCC c 0 0 ; PCC cedilla 61 0 ;
XCC Yacute 2 ; PCC Y 0 0 ; PCC acute 111 214 ;
XCC yacute 2 ; PCC y 0 0 ; PCC acute 55 0 ;
XCC Ydieresis 2 ; PCC Y 0 0 ; PCC dieresis 111 227 ;
XCC ydieresis 2 ; PCC y 0 0 ; PCC dieresis 55 0 ;
XCC Uacute 2 ; PCC U 0 0 ; PCC acute 228 227 ;
XCC Ucircumflex 2 ; PCC U 0 0 ; PCC circumflex 228 227 ;
XCC Udieresis 2 ; PCC U 0 0 ; PCC dieresis 228 227 ;
XCC Ugrave 2 ; PCC U 0 0 ; PCC grave 228 227 ;
XCC uacute 2 ; PCC u 0 0 ; PCC acute 83 0 ;
XCC ucircumflex 2 ; PCC u 0 0 ; PCC circumflex 83 0 ;
XCC udieresis 2 ; PCC u 0 0 ; PCC dieresis 83 0 ;
XCC ugrave 2 ; PCC u 0 0 ; PCC grave 83 0 ;
XCC Iacute 2 ; PCC I 0 0 ; PCC acute 14 227 ;
XCC Icircumflex 2 ; PCC I 0 0 ; PCC circumflex 14 227 ;
XCC Idieresis 2 ; PCC I 0 0 ; PCC dieresis 14 227 ;
XCC Igrave 2 ; PCC I 0 0 ; PCC grave 14 227 ;
XCC iacute 2 ; PCC dotlessi 0 0 ; PCC acute -34 0 ;
XCC icircumflex 2 ; PCC dotlessi 0 0 ; PCC circumflex -34 0 ;
XCC idieresis 2 ; PCC dotlessi 0 0 ; PCC dieresis -34 0 ;
XCC igrave 2 ; PCC dotlessi 0 0 ; PCC grave -34 0 ;
XCC Eacute 2 ; PCC E 0 0 ; PCC acute 160 227 ;
XCC Ecircumflex 2 ; PCC E 0 0 ; PCC circumflex 160 227 ;
XCC Edieresis 2 ; PCC E 0 0 ; PCC dieresis 160 227 ;
XCC Egrave 2 ; PCC E 0 0 ; PCC grave 160 227 ;
XCC eacute 2 ; PCC e 0 0 ; PCC acute 68 0 ;
XCC ecircumflex 2 ; PCC e 0 0 ; PCC circumflex 68 0 ;
XCC edieresis 2 ; PCC e 0 0 ; PCC dieresis 68 0 ;
XCC egrave 2 ; PCC e 0 0 ; PCC grave 68 0 ;
XCC Aacute 2 ; PCC A 0 0 ; PCC acute 146 227 ;
XCC Acircumflex 2 ; PCC A 0 0 ; PCC circumflex 146 227 ;
XCC Adieresis 2 ; PCC A 0 0 ; PCC dieresis 146 227 ;
XCC Agrave 2 ; PCC A 0 0 ; PCC grave 146 227 ;
XCC aacute 2 ; PCC a 0 0 ; PCC acute 89 0 ;
XCC acircumflex 2 ; PCC a 0 0 ; PCC circumflex 89 0 ;
XCC adieresis 2 ; PCC a 0 0 ; PCC dieresis 89 0 ;
XCC agrave 2 ; PCC a 0 0 ; PCC grave 89 0 ;
XCC Oacute 2 ; PCC O 0 0 ; PCC acute 221 227 ;
XCC Ocircumflex 2 ; PCC O 0 0 ; PCC circumflex 221 227 ;
XCC Odieresis 2 ; PCC O 0 0 ; PCC dieresis 221 227 ;
XCC Ograve 2 ; PCC O 0 0 ; PCC grave 221 227 ;
XCC oacute 2 ; PCC o 0 0 ; PCC acute 89 0 ;
XCC ocircumflex 2 ; PCC o 0 0 ; PCC circumflex 89 0 ;
XCC odieresis 2 ; PCC o 0 0 ; PCC dieresis 89 0 ;
XCC ograve 2 ; PCC o 0 0 ; PCC grave 89 0 ;
XCC Atilde 2 ; PCC A 0 0 ; PCC tilde 146 227 ;
XCC atilde 2 ; PCC a 0 0 ; PCC tilde 89 0 ;
XCC Ntilde 2 ; PCC N 0 0 ; PCC tilde 181 227 ;
XCC ntilde 2 ; PCC n 0 0 ; PCC tilde 76 0 ;
XCC Otilde 2 ; PCC O 0 0 ; PCC tilde 221 227 ;
XCC otilde 2 ; PCC o 0 0 ; PCC tilde 89 0 ;
XCC Aring 2 ; PCC A 0 0 ; PCC ring 80 227 ;
XCC aring 2 ; PCC a 0 0 ; PCC ring 29 0 ;
XEndComposites
XEndFontMetrics
END_OF_FILE
  if test 15725 -ne `wc -c <'lout/font0/TimesIta.AFM'`; then
    echo shar: \"'lout/font0/TimesIta.AFM'\" unpacked with wrong size!
  fi
  # end of 'lout/font0/TimesIta.AFM'
fi
if test -f 'lout/include/fig_prepend' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/include/fig_prepend'\"
else
  echo shar: Extracting \"'lout/include/fig_prepend'\" \(22299 characters\)
  sed "s/^X//" >'lout/include/fig_prepend' <<'END_OF_FILE'
X%%BeginResource: procset LoutFigPrependGraphic
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X%                                                                    %
X%  PostScript @SysPrependGraphic file for @Fig  Jeffrey H. Kingston  %
X%  Version 2.0 (includes CIRCUM label)                 January 1992  %
X%                                                                    %
X%  To assist in avoiding name clashes, the names of all symbols      %
X%  defined here begin with "lfig".  However, this is not feasible    %
X%  with user-defined labels and some labels used by users.           %
X%                                                                    %
X%  <point>      is two numbers, a point.                             %
X%  <length>     is one number, a length                              %
X%  <angle>      is one number, an angle in degrees                   %
X%  <dashlength> is one number, the preferred length of a dash        %
X%                                                                    %
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X
Xerrordict begin
X   /handleerror
X   {
X      {  /Times-Roman findfont 8 pt scalefont setfont
X	 0 setgray 4 pt 4 pt moveto
X	 $error /errorname get
X	 dup lfigdict exch known
X	 { lfigdict exch get }
X	 { 30 string cvs } ifelse
X	 show
X	 (  Command: ) show
X	 $error /command get 30 string cvs show
X      } stopped {} if
X      showpage stop
X   } def
Xend
X
X% concat strings: <string> <string> lfigconcat <string>
X% must be defined outside lfigdict since used in lfigpromotelabels
X/lfigconcat
X{ 2 copy length exch length add string
X  dup 0 4 index putinterval
X  dup 3 index length 3 index putinterval
X  3 1 roll pop pop
X} def
X
X% <string> lfigdebugprint -
X% must be defined outside lfigdict since used in arbitrary places
X% /lfigdebugprint
X% { print
X%   (;  operand stack:\n) print
X%   count copy
X%   count 2 idiv
X%   { ==
X%     (\n) print
X%   } repeat
X%   (\n) print
X% } def
X
X/lfigdict 120 dict def
Xlfigdict begin
X
X% error messages
X/dictfull (dictfull error:  too many labels?) def
X/dictstackoverflow (dictstackoverflow error:  labels nested too deeply?) def
X/execstackoverflow (execstackoverflow error:  figure nested too deeply?) def
X/limitcheck (limitcheck error:  figure nested too deeply or too large?) def
X/syntaxerror (syntaxerror error:  syntax error in text of figure?) def
X/typecheck (typecheck error:  syntax error in text of figure?) def
X/undefined (undefined error:  unknown or misspelt label?) def
X/VMError (VMError error:  run out of memory?) def
X
X% push pi onto stack:  - lfigpi <num>
X/lfigpi 3.14159 def
X
X% arc directions
X/clockwise     false def
X/anticlockwise true  def
X
X% maximum of two numbers:  <num> <num> lfigmax <num>
X/lfigmax { 2 copy gt { pop } { exch pop } ifelse } def
X
X% minimum of two numbers:  <num> <num> lfigmin <num>
X/lfigmin { 2 copy lt { pop } { exch pop } ifelse } def
X
X% add two points:  <point> <point> lfigpadd <point>
X/lfigpadd { exch 3 1 roll add 3 1 roll add exch } def
X
X% subtract first point from second:  <point> <point> lfigpsub <point>
X/lfigpsub { 3 2 roll sub 3 1 roll exch sub exch } def
X
X% max two points:  <point> <point> lfigpmax <point>
X/lfigpmax { exch 3 1 roll lfigmax 3 1 roll lfigmax exch } def
X
X% min two points:  <point> <point> lfigpmin <point>
X/lfigpmin { exch 3 1 roll lfigmin 3 1 roll lfigmin exch } def
X
X% scalar multiplication: <point> <num> lfigpmul <point>
X/lfigpmul { dup 3 1 roll mul 3 1 roll mul exch } def
X
X% point at angle and distance:  <point> <length> <angle> lfigatangle <point>
X/lfigatangle { 2 copy cos mul 3 1 roll sin mul lfigpadd } def
X
X% angle from one point to another:  <point> <point> lfigangle <angle>
X/lfigangle { lfigpsub 2 copy 0 eq exch 0 eq and {pop} {exch atan} ifelse } def
X
X% distance between two points:  <point> <point> lfigdistance <length>
X/lfigdistance { lfigpsub dup mul exch dup mul add sqrt } def
X
X% difference in x coords: <point> <point> lfigxdistance <length>
X/lfigxdistance { pop 3 1 roll pop sub } def
X
X%difference in y coords: <point> <point> lfigydistance <length>
X/lfigydistance { 3 1 roll pop sub exch pop } def
X
X% stroke a solid line:  <length> <dashlength> lfigsolid -
X/lfigsolid
X{  pop pop [] 0 setdash stroke
X} def
X
X% stroke a lfigdashed line:   <length> <dashlength> lfigdashed -
X/lfigdashed
X{  2 copy div 2 le 1 index 0 le or
X   {  exch pop 1 pt lfigmax [ exch dup ] 0 setdash }
X   {  dup [ exch 4 2 roll 2 copy div
X      1 sub 2 div ceiling dup 4 1 roll
X      1 add mul sub exch div ] 0 setdash
X   } ifelse stroke
X} def
X
X% stroke a lfigcdashed line:  <length> <dashlength> lfigcdashed -
X/lfigcdashed
X{  2 copy le 1 index 0 le or
X   {  exch pop 1 pt lfigmax [ exch dup ] copy 0 get 2 div setdash }
X   { dup [ 4 2 roll exch 2 copy exch div
X     2 div ceiling div 1 index sub
X     ] exch 2 div setdash
X   } ifelse stroke
X} def
X
X% stroke a dotted line:  <length> <dashlength> lfigdotted -
X/lfigdotted
X{  dup 0 le
X   {  exch pop 1 pt lfigmax [ exch 0 exch ] 0 setdash }
X   { 1 index exch div ceiling div
X     [ 0 3 2 roll ] 0 setdash
X   } ifelse stroke
X} def
X
X% stroke a noline line:  <length> <dashlength> lfignoline -
X/lfignoline
X{ pop pop
X} def
X
X% painting (i.e. filling): - lfigwhite - (etc.)
X/lfigwhite   { 1.0  setgray fill } def
X/lfiglight   { 0.95 setgray fill } def
X/lfiggrey    { 0.9  setgray fill } def
X/lfiggray    { 0.9  setgray fill } def
X/lfigdark    { 0.7  setgray fill } def
X/lfigblack   { 0.0  setgray fill } def
X/lfignopaint {                   } def
X
X% line caps (and joins, not currently used)
X/lfigbutt       0 def
X/lfiground      1 def
X/lfigprojecting 2 def
X/lfigmiter      0 def
X/lfigbevel      2 def
X
X% shape and labels of the @Box symbol
X/lfigbox
X{
X   0     0     /SW  lfigpointdef
X   xsize 0     /SE  lfigpointdef
X   xsize ysize /NE  lfigpointdef
X   0     ysize /NW  lfigpointdef
X   SE 0.5 lfigpmul /S   lfigpointdef
X   NW 0.5 lfigpmul /W   lfigpointdef
X   W SE lfigpadd   /E   lfigpointdef
X   S NW lfigpadd   /N   lfigpointdef
X   NE 0.5 lfigpmul /CTR lfigpointdef
X   [ CTR NE lfigpsub /lfigboxcircum cvx ] lfigcircumdef
X   SW SE NE NW SW
X} def
X
X% shape and labels of the @Square symbol
X/lfigsquare
X{
X   xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   CTR xsize xsize ysize ysize lfigpmax 0.5 lfigpmul lfigpadd /NE lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 135 lfigatangle lfigpadd /NW lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 225 lfigatangle lfigpadd /SW lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 315 lfigatangle lfigpadd /SE lfigpointdef
X   SW 0.5 lfigpmul SE 0.5 lfigpmul lfigpadd /S lfigpointdef
X   NW 0.5 lfigpmul NE 0.5 lfigpmul lfigpadd /N lfigpointdef
X   SW 0.5 lfigpmul NW 0.5 lfigpmul lfigpadd /W lfigpointdef
X   SE 0.5 lfigpmul NE 0.5 lfigpmul lfigpadd /E lfigpointdef
X   [ CTR NE lfigpsub /lfigboxcircum cvx ] lfigcircumdef
X   SW SE NE NW SW
X} def
X
X% shape and labels of the @Diamond symbol
X/lfigdiamond
X{
X   xsize 0 0.5 lfigpmul /S   lfigpointdef
X   0 ysize 0.5 lfigpmul /W   lfigpointdef
X   S W         lfigpadd /CTR lfigpointdef
X   CTR W       lfigpadd /N   lfigpointdef
X   CTR S       lfigpadd /E   lfigpointdef
X   [ xsize ysize 0.5 lfigpmul /lfigdiamondcircum cvx ] lfigcircumdef
X   S E N W S
X} def
X
X% shape and labels of the @Ellipse symbol
X/lfigellipse
X{
X   xsize 0 0.5 lfigpmul /S   lfigpointdef
X   0 ysize 0.5 lfigpmul /W   lfigpointdef
X   S W         lfigpadd /CTR lfigpointdef
X   CTR W       lfigpadd /N   lfigpointdef
X   CTR S       lfigpadd /E   lfigpointdef
X   CTR xsize 0 0.3536 lfigpmul lfigpadd 0 ysize 0.3536 lfigpmul lfigpadd /NE lfigpointdef
X   0 ysize 0.3536 lfigpmul CTR xsize 0 0.3536 lfigpmul lfigpadd lfigpsub /SE lfigpointdef
X   xsize 0 0.3536 lfigpmul CTR lfigpsub 0 ysize 0.3536 lfigpmul lfigpadd /NW lfigpointdef
X   0 ysize 0.3536 lfigpmul xsize 0 0.3536 lfigpmul CTR lfigpsub lfigpsub /SW lfigpointdef
X   [ xsize ysize 0.5 lfigpmul /lfigellipsecircum cvx ] lfigcircumdef
X   S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X} def
X
X% shape and labels of the @Circle symbol
X/lfigcircle
X{
X   xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   CTR xsize 0 ysize 0 lfigpmax 0.5 lfigpmul lfigpadd /E lfigpointdef
X   CTR 0 0 CTR E lfigdistance 45 lfigatangle lfigpadd /NE lfigpointdef
X   CTR 0 0 CTR E lfigdistance 90 lfigatangle lfigpadd /N lfigpointdef
X   CTR 0 0 CTR E lfigdistance 135 lfigatangle lfigpadd /NW lfigpointdef
X   CTR 0 0 CTR E lfigdistance 180 lfigatangle lfigpadd /W lfigpointdef
X   CTR 0 0 CTR E lfigdistance 225 lfigatangle lfigpadd /SW lfigpointdef
X   CTR 0 0 CTR E lfigdistance 270 lfigatangle lfigpadd /S lfigpointdef
X   CTR 0 0 CTR E lfigdistance 315 lfigatangle lfigpadd /SE lfigpointdef
X   [ S E lfigpsub /lfigellipsecircum cvx ] lfigcircumdef
X   S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X} def
X
X% shape and labels of the @HLine and @HArrow symbols
X/lfighline
X{
X   0 ymark lfigprevious /FROM lfigpointdef
X   xsize ymark lfigprevious /TO lfigpointdef
X} def
X
X% shape and labels of the @VLine and @VArrow symbols
X/lfigvline
X{
X   xmark ysize lfigprevious /FROM lfigpointdef
X   xmark 0 lfigprevious /TO lfigpointdef
X} def
X
X% points of a polygon around base with given no of sides, vert init angle:
X% <sides> <angle> figpolygon <point> ... <point>
X/lfigpolygon
X{  xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   90 sub CTR 2 copy lfigmax 5 3 roll
X   [ 4 copy pop /lfigpolycircum cvx ] lfigcircumdef
X   exch dup 360 exch div exch
X   1 1  3 2 roll
X   {  4 string cvs (P) exch lfigconcat cvn
X      6 copy pop pop lfigatangle 2 copy 10 2 roll
X      3 2 roll lfigpointdef
X      dup 3 1 roll add exch
X   }  for
X   pop lfigatangle
X} def
X
X% next array element:  <array> <index> lfiggetnext <array> <index> <any> true
X%                                               or <array> <index> false
X/lfiggetnext
X{  2 copy exch length ge
X   { false }
X   { 2 copy get exch 1 add exch true } ifelse
X} def
X
X% check whether thing is number:  <any> lfigisnumbertype <any> <bool>
X/lfigisnumbertype
X{  dup type dup
X   /integertype eq exch /realtype eq or
X} def
X
X% check whether thing is an array:  <any> lfigisarraytype <any> <bool>
X/lfigisarraytype { dup type /arraytype eq } def
X
X% get next item:  <array> <index> lfiggetnextitem <array> <index> 0
X%                                              or <array> <index> <array> 1
X%                                              or <array> <index> <point> 2
X/lfiggetnextitem
X{   lfiggetnext
X    {	lfigisarraytype
X	{   1
X	}
X	{   lfigisnumbertype
X	    {	3 1 roll
X		lfiggetnext
X		{   lfigisnumbertype
X		    {	4 3 roll exch  2
X		    }
X		    {	pop 3 2 roll pop  0
X		    } ifelse
X		}
X		{   3 2 roll pop  0
X		} ifelse
X	    }
X	    {	pop 0
X	    } ifelse
X	} ifelse
X    }
X    {	0
X    } ifelse
X} def
X
X% set arc path:  bool x1 y1  x2 y2  x0 y0  lfigsetarc  <angle> <angle> <dist>
X% the path goes from x1 y1 to x2 y2 about centre x0 y0,
X% anticlockwise if bool is true else clockwise.
X% The orientations of backwards pointing and forwards pointing
X% arrowheads are returned in the two angles, and
X% the length of the arc is returned in <dist>.
X/lfigsetarc
X{
X  20 dict begin
X     matrix currentmatrix 8 1 roll
X     2 copy translate 2 copy 8 2 roll
X     4 2 roll lfigpsub 6 2 roll lfigpsub
X     dup /y1 exch def dup mul /y1s exch def
X     dup /x1 exch def dup mul /x1s exch def
X     dup /y2 exch def dup mul /y2s exch def
X     dup /x2 exch def dup mul /x2s exch def
X
X     y1s y2s eq
X     {	-1
X     }
X     {	y1s x2s mul y2s x1s mul sub y1s y2s sub div
X     } ifelse
X     /da exch def
X
X     x1s x2s eq
X     {	-1
X     }
X     {	x1s y2s mul x2s y1s mul sub x1s x2s sub div
X     } ifelse
X     /db exch def
X
X     da 0 gt db 0 gt and
X     {	/LMax da sqrt db sqrt lfigmax def
X	/scalex da sqrt LMax div def
X	/scaley db sqrt LMax div def
X	scalex scaley scale
X	0 0 LMax
X	0 0 x1 scalex mul y1 scaley mul lfigangle
X	0 0 x2 scalex mul y2 scaley mul lfigangle
X	2 copy eq { 360 add } if
X	2 copy 8 2 roll
X	5 index { arc } { arcn } ifelse
X	2 index 1 index
X	{ 90 sub } { 90 add } ifelse
X	dup sin scaley mul exch cos scalex mul atan
X	2 index 2 index
X	{ 90 add } { 90 sub } ifelse
X	dup sin scaley mul exch cos scalex mul atan
X	5 2 roll  % res1 res2 ang1 ang2 anticlockwise
X	{ exch sub } { sub } ifelse
X	dup 0 le { 360 add } if  lfigpi mul LMax mul 180 div
X     }
X     {	0 0 x1 y1 lfigdistance 0 0 x2 y2 lfigdistance eq
X	0 0 x1 y1 lfigdistance 0 gt and
X	{	0 0
X		0 0 x1 y1 lfigdistance
X		0 0 x1 y1 lfigangle
X		0 0 x2 y2 lfigangle
X		2 copy eq { 360 add } if
X		2 copy 8 2 roll
X		5 index { arc } { arcn } ifelse
X		2 index 1 index
X		{ 90 sub } { 90 add } ifelse
X		2 index 2 index
X		{ 90 add } { 90 sub } ifelse
X		5 2 roll % res1 res2 ang1 ang2 clockwise
X		{ exch sub } { sub } ifelse
X		dup 0 le { 360 add } if lfigpi mul 0 0 x1 y1 lfigdistance mul 180 div
X	}
X	{	x2 y2 lineto pop
X		x2 y2 x1 y1 lfigangle
X		x1 y1 x2 y2 lfigangle
X		x1 y1 x2 y2 lfigdistance
X	} ifelse
X     } ifelse
X     4 -1 roll setmatrix
X   end
X} def
X
X% lfigsetcurve: set up a Bezier curve from x0 y0 to x3 y3
X% and return arrowhead angles and length of curve (actually 0)
X% x0 y0 x1 y1 x2 y2 x3 y3 lfigsetcurve <angle> <angle> <length>
X/lfigsetcurve
X{ 8 copy curveto pop pop
X  lfigangle
X  5 1 roll
X  4 2 roll lfigangle
X  exch
X  0
X} def
X
X% lfigpaintpath: paint a path of the given shape
X% /paint [ shape ] lfigpaintpath -
X/lfigpaintpath
X{
X  10 dict begin
X    0 newpath
X    /prevseen false def
X    /curveseen false def
X    { lfiggetnextitem
X      dup 0 eq { pop exit }
X      { 1 eq
X        { /curveseen true def
X	  /curve exch def
X	  curve length 0 eq { /curveseen false def } if
X        }
X        { /ycurr exch def
X	  /xcurr exch def
X	  prevseen
X	  { curveseen
X	    { curve length 4 eq
X	      { xprev yprev
X		curve 0 get curve 1 get
X		curve 2 get curve 3 get
X		xcurr ycurr
X		lfigsetcurve pop pop pop
X	      }
X	      { xprev yprev xcurr ycurr
X	        curve length 1 ge { curve 0 get } { 0 } ifelse
X	        curve length 2 ge { curve 1 get } { 0 } ifelse
X	        curve length 3 ge { curve 2 get } { true } ifelse
X	        7 1 roll
X	        lfigsetarc pop pop pop
X	      } ifelse
X	    }
X	    { xcurr ycurr lineto
X	    } ifelse
X	  }
X	  { xcurr ycurr moveto
X	  } ifelse
X	  /xprev xcurr def
X	  /yprev ycurr def
X	  /prevseen true def
X	  /curveseen false def
X        } ifelse
X      } ifelse
X    } loop pop pop cvx exec
X  end
X} def
X
X% stroke a path of the given shape in the given linestyle and dash length.
X% Return the origin and angle of the backward and forward arrow heads.
X% dashlength /linestyle [shape] lfigdopath  [<point> <angle>] [<point> <angle>] 
X/lfigdopath
X{
X  10 dict begin
X    0
X    /prevseen  false def
X    /curveseen false def
X    /backarrow []    def
X    /fwdarrow  []    def
X    {
X	lfiggetnextitem
X	dup 0 eq { pop exit }
X	{
X	    1 eq
X	    {	/curveseen true def
X		/curve exch def
X		curve length 0 eq { /prevseen false def } if
X	    }
X	    {	/ycurr exch def
X		/xcurr exch def
X		prevseen
X		{   newpath xprev yprev moveto
X		    curveseen
X		    {	curve length 4 eq
X			{   xprev yprev
X			    curve 0 get curve 1 get
X			    curve 2 get curve 3 get
X			    xcurr ycurr lfigsetcurve
X			}
X			{   xprev yprev xcurr ycurr
X			    curve length 1 ge { curve 0 get } { 0 } ifelse
X			    curve length 2 ge { curve 1 get } { 0 } ifelse
X			    curve length 3 ge { curve 2 get } { true } ifelse
X			    7 1 roll
X			    lfigsetarc
X			} ifelse
X		    }
X		    {	xcurr ycurr lineto
X			xcurr ycurr xprev yprev lfigangle dup 180 sub
X			xprev yprev xcurr ycurr lfigdistance
X		    } ifelse
X		    6 index 6 index cvx exec
X		    [ xprev yprev 5 -1 roll ]
X		    backarrow length 0 eq
X		    { /backarrow exch def }
X		    { pop } ifelse
X		    [ xcurr ycurr 4 -1 roll ] /fwdarrow exch def
X		} if
X		/xprev xcurr def
X		/yprev ycurr def
X		/prevseen true def
X		/curveseen false def
X	    } ifelse
X	} ifelse
X    } loop
X    pop pop pop pop
X    backarrow length 0 eq { [ 0 0 0 ] } { backarrow } ifelse
X    fwdarrow  length 0 eq { [ 0 0 0 ] } { fwdarrow  } ifelse
X  end
X} def
X
X% lfigdoarrow: draw an arrow head of given form
X% dashlength /lstyle /pstyle hfrac height width [ <point> <angle> ] lfigdoarrow -
X/lfigdoarrow
X{  matrix currentmatrix 8 1 roll
X   dup 0 get 1 index 1 get translate
X   2 get rotate
X   [ 2 index neg 2 index 0 0
X     3 index 3 index neg
X     1 index 10 index mul 0
X     7 index 7 index ]
X   4 1 roll pop pop pop
X   dup 3 1 roll
X   gsave lfigpaintpath grestore lfigdopath pop pop
X   setmatrix
X} def
X
X% arrow head styles
X/lfigopen     0.0 def
X/lfighalfopen 0.5 def
X/lfigclosed   1.0 def
X
X% stroke no arrows, forward, back, and both
X/lfignoarrow { pop pop pop pop pop pop pop pop                        } def
X/lfigforward { 7 -1 roll lfigdoarrow pop                              } def
X/lfigback    { 8 -2 roll pop lfigdoarrow                              } def
X/lfigboth    { 8 -1 roll 7 copy lfigdoarrow pop 7 -1 roll lfigdoarrow } def
X
X% lfigprevious: return previous point on path
X/lfigprevious
X{ lfigisnumbertype
X  { 2 copy }
X  { lfigisarraytype
X    { 2 index 2 index }
X    { 0 0 }
X    ifelse
X  } ifelse
X} def
X
X% label a point in 2nd top dictionary:  <point> /name lfigpointdef -
X/lfigpointdef
X{
X  % (Entering lfigpointdef) lfigdebugprint
X  [ 4 2 roll transform
X    /itransform cvx ] cvx
X    currentdict end
X    3 1 roll
X    % currentdict length currentdict maxlength lt
X    % { def }
X    % { exec moveto (too many labels) show stop }
X    % ifelse
X    def
X    begin
X  % (Leaving lfigpointdef) lfigdebugprint
X} def
X
X% promote labels from second top to third top dictionary
X% <string> lfigpromotelabels -
X/lfigpromotelabels
X{
X  % (Entering lfigpromotelabels) lfigdebugprint
X  currentdict end exch currentdict end
X  { exch 20 string cvs 2 index
X    (@) lfigconcat exch lfigconcat cvn exch def
X  } forall pop begin
X  % (Leaving lfigpromotelabels) lfigdebugprint
X} def
X
X% show labels (except CIRCUM): - lfigshowlabels -
X/lfigshowlabels
X{
X  % (Entering lfigshowlabels) lfigdebugprint
X  currentdict end
X    currentdict
X    { 1 index 20 string cvs (CIRCUM) search % if CIRCUM in key
X      { pop pop pop pop pop }
X      { pop cvx exec 2 copy
X        newpath 1.5 pt 0 360 arc
X        0 setgray fill
X        /Times-Roman findfont 8 pt scalefont setfont
X        moveto 0.2 cm 0.1 cm rmoveto 20 string cvs show
X      }
X      ifelse
X    } forall
X  begin
X  % (Leaving lfigshowlabels) lfigdebugprint
X} def
X
X% fix an angle to between 0 and 360 degrees:  <angle> lfigfixangle <angle>
X/lfigfixangle
X{
X  % (Entering lfigfixangle) lfigdebugprint
X  { dup 0 ge { exit } if
X    360 add
X  } loop
X  { dup 360 lt { exit } if
X    360 sub
X  } loop
X  % (Leaving lfigfixangle) lfigdebugprint
X} def
X
X% find point on circumference of box:  alpha a b lfigboxcircum x y
X/lfigboxcircum
X{
X  % (Entering lfigboxcircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    0 0 a b lfigangle /theta exch def
X
X    % if alpha <= theta, return (a, a*tan(alpha))
X    alpha theta le
X    { a  a alpha sin mul alpha cos div }
X    {
X      % else if alpha <= 180 - theta, return (b*cot(alpha), b)
X      alpha 180 theta sub le
X      { b alpha cos mul alpha sin div  b }
X      {
X        % else if alpha <= 180 + theta, return (-a, -a*tan(alpha))
X        alpha 180 theta add le
X        { a neg  a neg alpha sin mul alpha cos div }
X        {
X	  % else if alpha <= 360 - theta, return (-b*cot(alpha), -b)
X	  alpha 360 theta sub le
X          { b neg alpha cos mul alpha sin div  b neg }
X	  {
X	    % else 360 - theta <= alpha, return (a, a*tan(alpha))
X	    a  a alpha sin mul alpha cos div
X	  } ifelse
X        } ifelse
X      } ifelse
X    } ifelse
X  end
X  % (Leaving lfigboxcircum) lfigdebugprint
X} def
X
X% find point on circumference of diamond:  alpha a b lfigdiamondcircum x y
X/lfigdiamondcircum
X{
X  % (Entering lfigdiamondcircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    b alpha cos abs mul  a alpha sin abs mul  add  /denom exch def
X    a b mul alpha cos mul denom div
X    a b mul alpha sin mul denom div
X  end
X  % (Leaving lfigdiamondcircum) lfigdebugprint
X} def
X
X% find point on circumference of ellipse:  alpha a b lfigellipsecircum x y
X/lfigellipsecircum
X{
X  % (Entering lfigellipsecircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    b alpha cos mul dup mul  a alpha sin mul dup mul  add sqrt /denom exch def
X    a b mul alpha cos mul denom div
X    a b mul alpha sin mul denom div
X  end
X  % (Leaving lfigellipsecircum) lfigdebugprint
X} def
X
X% find point of intersection of two lines each defined by two points
X% x1 y1 x2 y2  x3 y3 x4 y4  lfiglineintersect x y
X/lfiglineintersect
X{
X  % (Entering lfiglineintersect) lfigdebugprint
X  13 dict begin
X    /y4 exch def
X    /x4 exch def
X    /y3 exch def
X    /x3 exch def
X    /y2 exch def
X    /x2 exch def
X    /y1 exch def
X    /x1 exch def
X    x2 x1 sub /x21 exch def
X    x4 x3 sub /x43 exch def
X    y2 y1 sub /y21 exch def
X    y4 y3 sub /y43 exch def
X    y21 x43 mul y43 x21 mul sub /det exch def
X  
X    % calculate x 
X    y21 x43 mul x1 mul
X    y43 x21 mul x3 mul sub
X    y3 y1 sub x21 mul x43 mul add
X    det div
X
X    % calculate y
X    x21 y43 mul y1 mul
X    x43 y21 mul y3 mul sub
X    x3 x1 sub y21 mul y43 mul add
X    det neg div
X
X  end
X  % (Leaving lfiglineintersect) lfigdebugprint
X} def
X
X% find point on circumference of polygon
X% alpha radius num theta lfigpolycircum x y
X/lfigpolycircum
X{
X  % (Entering lfigpolycircum) lfigdebugprint
X  13 dict begin
X    /theta exch def
X    /num exch def
X    /radius exch def
X    /alpha exch def
X
X    % calculate delta, the angle from theta to alpha
X    alpha theta sub lfigfixangle
X
X    % calculate the angle which is the multiple of 360/num closest to delta
X    360 num div div truncate 360 num div mul theta add /anglea exch def
X
X    % calculate the next multiple of 360/num after anglea
X    anglea 360 num div add /angleb exch def
X
X    % intersect the line through these two points with the alpha line
X    anglea cos anglea sin  angleb cos angleb sin
X    0 0  alpha cos 2 mul alpha sin 2 mul
X    lfiglineintersect radius lfigpmul
X
X  end
X  % (Leaving lfigpolycircum) lfigdebugprint
X} def
X
X% add CIRCUM operator with this body:  <array> lfigcircumdef -
X/lfigcircumdef
X{   % (Entering lfigcircumdef) lfigdebugprint
X    /CIRCUM exch cvx
X    currentdict end
X    3 1 roll
X    % currentdict length currentdict maxlength lt
X    % { def }
X    % { exec moveto (too many labels) show stop }
X    % ifelse
X    def
X    begin
X    % (Leaving lfigcircumdef) lfigdebugprint
X} def
X
Xend
X%%EndResource
END_OF_FILE
  if test 22299 -ne `wc -c <'lout/include/fig_prepend'`; then
    echo shar: \"'lout/include/fig_prepend'\" unpacked with wrong size!
  fi
  # end of 'lout/include/fig_prepend'
fi
if test -f 'lout/z13.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z13.c'\"
else
  echo shar: Extracting \"'lout/z13.c'\" \(20116 characters\)
  sed "s/^X//" >'lout/z13.c' <<'END_OF_FILE'
X/*@z13.c:Object Breaking:BreakObject()@***************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z13.c                                                      */
X/*  MODULE:       Object Breaking                                            */
X/*  EXTERNS:      BreakObject()                                              */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static BreakJoinedGroup(start, stop, m, c, res_back, res_fwd)            */
X/*                                                                           */
X/*  Break joined group of components of a VCAT, beginning from Child(start)  */
X/*  inclusive and ending at Child(stop) inclusive.  Break component m first  */
X/*  because it is the widest.                                                */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic BreakJoinedGroup(start, stop, m, c, res_back, res_fwd)
XOBJECT start, stop, m;  CONSTRAINT *c;  LENGTH *res_back, *res_fwd;
X{ OBJECT y, z, link;  LENGTH b, f, mb, mf;  CONSTRAINT yc;
X  ifdebug(DOB, D, Child(y, start));
X  ifdebug(DOB, D, Child(z, stop));
X  debug3(DOB, D, "BreakJoinedGroup( -> %s, -> %s, %s, -, -)",
X	EchoObject(null, y), EchoObject(null, z), EchoConstraint(c));
X  CopyConstraint(yc, *c);
X  if( m != nil )
X  { m = BreakObject(m, &yc);
X    b = back(m, COL);
X    f = fwd(m, COL);
X    SetConstraint(yc, min(bc(yc), bfc(yc)-f), bfc(yc), min(fc(yc), bfc(yc)-b));
X  }
X  else b = f = 0;
X  for( link = start;  link != NextDown(stop);  link = NextDown(link) )
X  { Child(y, link);
X    if( !is_definite(type(y)) || y == m )  continue;
X    y = BreakObject(y, &yc);
X    b = max(b, back(y, COL));
X    f = max(f, fwd(y, COL));
X    SetConstraint(yc, min(bc(yc), bfc(yc)-f), bfc(yc), min(fc(yc), bfc(yc)-b));
X  }
X  assert( FitsConstraint(b, f, *c), "BreakJoinedGroup: result doesn't fit!" );
X  *res_back = b;  *res_fwd = f;
X  debug2(DOB,D,"BreakJoinedGroup returning (%s, %s)",
X	EchoLength(b), EchoLength(f));
X} /* end BreakJoinedGroup */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static OBJECT BreakVcat(x, c)                                            */
X/*                                                                           */
X/*  Break a VCAT to satisfy constraint c.  This is tedious because every     */
X/*  group of components between //  ...  // must be broken separately.       */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT BreakVcat(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ OBJECT y, link, start_group, m;  LENGTH b, f; int dble_fwd;  CONSTRAINT tc;
X  BOOLEAN dble_found;
X  debug2(DOB, D, "[ BreakVcat(%s, %s)", EchoObject(null, x), EchoConstraint(c));
X  assert(Down(x) != x, "BreakVcat: Down(x) == x!" );
X  SetConstraint(tc, MAX_LEN, min(bfc(*c), fc(*c)), MAX_LEN);
X  
X  dble_found = FALSE;  dble_fwd = 0;  start_group = nil;
X  for( link = Down(x);  link != x;  link = NextDown(link) )
X  {
X    Child(y, link);
X    if( is_index(type(y)) )  continue;
X    if( type(y) == GAP_OBJ )
X    { assert( start_group != nil, "BreakVcat: start_group == nil!" );
X      if( !join(gap(y)) )
X      {
X	/* finish off and break this group */
X	if( !FitsConstraint(b, f, tc) )
X	  BreakJoinedGroup(start_group, link, m, &tc, &b, &f);
X	dble_found = TRUE;
X	dble_fwd = max(dble_fwd, b + f);
X	start_group = nil;
X	debug1(DOB, D, "  end group, dble_fwd: %s", EchoLength(dble_fwd));
X      }
X    }
X    else if( start_group == nil )
X    {	
X      /* start new group */
X      b = back(y, COL);
X      f = fwd(y, COL);
X      start_group = link;
X      m = y;
X      debug3(DOB, D, "  starting group: %s (%s, %s)",
X	EchoObject(null, y), EchoLength(b), EchoLength(f));
X    }
X    else
X    {
X      /* continue with current group */
X      b = max(b, back(y, COL));
X      f = max(f, fwd(y, COL));
X      if( fwd(y, COL) > fwd(m, COL) )  m = y;
X      debug4(DOB, D, "  in group: %s%s (%s, %s)", m == y ? "new max " : "",
X	EchoObject(null, y), EchoLength(b), EchoLength(f));
X    }
X  }
X  assert( start_group != nil, "BreakVcat: start_group == nil (2)!" );
X
X  if( dble_found )
X  {	
X    /* finish off and break this last group, and set sizes of x */
X    if( !FitsConstraint(b, f, tc) )
X      BreakJoinedGroup(start_group, LastDown(x), m, &tc, &b, &f);
X    dble_fwd = max(dble_fwd, b + f);
X    debug1(DOB, D, "  ending last group, dble_fwd: %s",EchoLength(dble_fwd));
X    back(x, COL) = 0;  fwd(x, COL) = min(MAX_LEN, dble_fwd);
X  }
X  else
X  {
X    /* finish off and break this last and only group, and set sizes of x */
X    debug2(DOB, D, "  BreakVcat ending last and only group (%s, %s)",
X	EchoLength(b), EchoLength(f));
X    BreakJoinedGroup(start_group, LastDown(x), m, c, &b, &f);
X    back(x, COL) = b;  fwd(x, COL) = f;
X  }
X
X  debug1(DOB, D, "] BreakVcat returning %s", EchoObject(null, x));
X  debug2(DOB, D, "  (size is %s, %s)",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)));
X  return x;
X} /* end BreakVcat */
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static OBJECT BreakTable(x, c)                                           */
X/*                                                                           */
X/*  Break table (HCAT) x to satisfy constraint c.                            */
X/*                                                                           */
X/*  Outline of algorithm:                                                    */
X/*                                                                           */
X/*     bcount = number of components to left of mark;                        */
X/*     fcount = no. of components on and right of mark;                      */
X/*     bwidth = what back(x) would be if all components had size (0, 0);     */
X/*     fwidth = what fwd(x) would be if all components had size (0, 0);      */
X/*     Set all components of x to Unbroken (broken(y) holds this flag);      */
X/*     while( an Unbroken component of x exists )                            */
X/*     {   my = the Unbroken component of x of minimum width;                */
X/*         mc = desirable constraint for my (see below);                     */
X/*         BreakObject(my, &mc);                                             */
X/*         Set my to Broken and update bcount, fcount, bwidth, fwidth        */
X/*            to reflect the actual size of my, now broken;                  */
X/*     }                                                                     */
X/*                                                                           */
X/*  The constraint mc is chosen in an attempt to ensure that:                */
X/*                                                                           */
X/*     a)  Any sufficiently narrow components will not break;                */
X/*     b)  All broken components will have the same bfc(mc), if possible;    */
X/*     c)  All available space is used.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic OBJECT BreakTable(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ LENGTH bwidth, fwidth;	/* running back(x) and fwd(x)		     */
X  int    bcount, fcount;	/* running no. of components		     */
X  OBJECT mlink, my;		/* minimum-width unbroken component	     */
X  BOOLEAN ratm;			/* TRUE when my has a mark to its right      */
X  int    mside;			/* my's side of the mark: BACK, ON or FWD    */
X  LENGTH msize;			/* my's size (minimal among unbroken)	     */
X  CONSTRAINT mc;		/* desirable constraint for my		     */
X  OBJECT pg, prec_def;		/* preceding definite object of my           */
X  OBJECT sg, succ_def;		/* succeeding definite object of my          */
X  LENGTH pd_extra, sd_extra;	/* space availiable for free each side of my */
X  LENGTH av_colsize;		/* the size of each unbroken component       */
X				/* if they are all assigned equal width      */
X  LENGTH fwd_max, back_max;	/* maximum space available forward of or     */
X				/* back of the mark, when columns are even   */
X  LENGTH col_size;		/* the column size actually used in breaking */
X  LENGTH beffect, feffect;	/* the amount bwidth, fwidth must increase   */
X				/* when my is broken			     */
X  OBJECT link, y, prev, g;  LENGTH tmp, tmp2;
X
X  debug2(DOB,DD,"[ BreakTable( %s, %s )", EchoObject(null,x),EchoConstraint(c));
X
X  /* Initialise csize, bcount, fcount, bwidth, fwidth and broken(y) */
X  bcount = fcount = 0;  bwidth = fwidth = 0;  prev = nil;
X  Child(y, Down(x));
X  assert( type(y) != GAP_OBJ, "BreakTable: GAP_OBJ!" );
X  assert( !is_index(type(y)), "BreakTable: index!" );
X  broken(y) = is_indefinite(type(y));
X  if( !broken(y) )  prev = y, fcount = 1;
X
X  for( link = NextDown(Down(x));  link != x;  link = NextDown(NextDown(link)) )
X  {
X    /* find the next gap g and following child y */
X    Child(g, link);
X    assert( type(g) == GAP_OBJ, "BreakTable: GAP_OBJ!" );
X    assert( NextDown(link) != x, "BreakTable: GAP_OBJ is last!" );
X    Child(y, NextDown(link));
X
X    assert( type(y) != GAP_OBJ, "BreakTable: GAP_OBJ!" );
X    assert( !is_index(type(y)), "BreakTable: index!" );
X    broken(y) = is_indefinite(type(y));
X    if( !broken(y) )
X    { if( prev == nil )  fcount = 1;
X      else if( mark(gap(g)) )
X      {	bcount += fcount;
X	bwidth += fwidth + MinGap(0, 0, 0, &gap(g));
X	fcount  = 1;  fwidth = 0;
X      }
X      else
X      {	fwidth += MinGap(0, 0, 0, &gap(g));
X	fcount += 1;
X      }
X      prev = y;
X    }
X  }
X
X  /* if column gaps alone are too wide, kill them all */
X  if( !FitsConstraint(bwidth, fwidth, *c) )
X  { Error(WARN, &fpos(x), "object too wide: reducing column gaps to 0i");
X    for( link = Down(x);  link != x;  link = NextDown(link) )
X    { Child(g, link);
X      if( type(g) == GAP_OBJ )
X      {	SetGap(gap(g), mark(gap(g)), join(gap(g)), FIXED_UNIT, EDGE_MODE, 0);
X      }
X    }
X    bwidth = fwidth = 0;
X  }
X
X  /* break each column, from smallest to largest */
X  while( bcount + fcount > 0 && FitsConstraint(bwidth, fwidth, *c) )
X  {
X    debug2(DOB,DD, "bcount: %d;  bwidth: %s", bcount, EchoLength(bwidth));
X    debug2(DOB,DD, "fcount: %d;  fwidth: %s", fcount, EchoLength(fwidth));
X
X    /* find a minimal-width unbroken component my */
X    my = nil;  msize = size(x, COL);       /* an upper bound for size(y) */
X    for( link = Down(x);  ;  link = NextDown(link) )
X    { Child(y, link);
X      assert( type(y) != GAP_OBJ, "BreakTable: type(y) == GAP_OBJ!" );
X      if( !broken(y) && (size(y, COL) < msize || my == nil) )
X      {	msize = size(y, COL);
X	my = y;  mlink = link;
X	ratm = FALSE;
X      }
X
X      /* next gap */
X      link = NextDown(link);
X      if( link == x )  break;
X      Child(g, link);
X      assert( type(g) == GAP_OBJ, "BreakTable: type(g) != GAP_OBJ!" );
X      if( mark(gap(g)) )  ratm = TRUE;
X    }
X    debug2(DOB, DD, "my (%s): %s", Image(mside), EchoObject(null, my));
X
X    /* find neighbouring definite objects and resulting pd_extra and sd_extra */
X    SetNeighbours(mlink, ratm, &pg, &prec_def, &sg, &succ_def, &mside);
X    pd_extra = pg == nil ? 0 :
X      ExtraGap(broken(prec_def) ? fwd(prec_def,COL) : 0, 0, &gap(pg), BACK);
X    sd_extra = sg == nil ? 0 :
X      ExtraGap(0, broken(succ_def) ? back(succ_def,COL) : 0, &gap(sg), FWD);
X    debug2(DOB, DD, "pd_extra:   %s;  sd_extra:      %s",
X		EchoLength(pd_extra), EchoLength(sd_extra) );
X
X    /* calculate desirable constraints for my */
X    av_colsize = (bfc(*c) - bwidth - fwidth) / (bcount + fcount);
X    debug1(DOB, DD, "av_colsize = %s", EchoLength(av_colsize));
X    switch( mside )
X    {
X
X      case BACK:
X      
X	back_max = min(bc(*c), bwidth + av_colsize * bcount);
X	col_size = (back_max - bwidth) / bcount;
X	SetConstraint(mc, col_size + pd_extra, col_size + pd_extra + sd_extra,
X			col_size + sd_extra );
X	break;
X
X
X      case ON:
X      
X	fwd_max = min(fc(*c), fwidth + av_colsize * fcount);
X	col_size = (fwd_max - fwidth) / fcount;
X	SetConstraint(mc, pd_extra, MAX_LEN, col_size + sd_extra);
X	break;
X
X
X      case FWD:
X      
X	fwd_max = min(fc(*c), fwidth + av_colsize * fcount);
X	col_size = (fwd_max - fwidth) / fcount;
X	SetConstraint(mc, col_size + pd_extra, col_size + pd_extra + sd_extra,
X			col_size + sd_extra );
X	break;
X
X
X      default:
X      
X	Error(INTERN, no_fpos, "BreakTable found illegal side");
X	break;
X    }
X
X    /* now break my according to these constraints, and accept it */
X    my = BreakObject(my, &mc);  broken(my) = TRUE;
X
X    /* calculate the effect of accepting my on bwidth and fwidth */
X    if( pg != nil )
X    { tmp = broken(prec_def) ? fwd(prec_def, COL) : 0;
X      beffect = MinGap(tmp, back(my, COL), fwd(my, COL), &gap(pg)) -
X	        MinGap(tmp, 0,             0,            &gap(pg));
X    }
X    else beffect = back(my, COL);
X
X    if( sg != nil )
X    { tmp = broken(succ_def) ? back(succ_def, COL) : 0;
X      tmp2 = broken(succ_def) ? fwd(succ_def, COL) : 0;
X      feffect = MinGap(fwd(my, COL), tmp, tmp2, &gap(sg)) -
X	        MinGap(0,            tmp, tmp2, &gap(sg));
X    }
X    else feffect = fwd(my, COL);
X
X    switch( mside )
X    {
X	case BACK:	bwidth += beffect + feffect;
X			bcount--;
X			break;
X	
X	case ON:	bwidth += beffect;  fwidth += feffect;
X			fcount--;
X			break;
X
X	case FWD:	fwidth += beffect + feffect;
X			fcount--;
X			break;
X	
X	default:	Error(INTERN, no_fpos, "BreakTable found illegal side");
X			break;
X    }
X
X  } /* end while */
X
X  back(x, COL) = bwidth;
X  fwd(x, COL) = fwidth;
X
X  debug1(DOB, DD,  "] BreakTable returning %s", EchoObject(null, x));
X  debug2(DOB, DD, "  (size is %s, %s)",
X	EchoLength(bwidth), EchoLength(fwidth));
X  return x;
X} /* end BreakTable */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT BreakObject(x, c)                                                 */
X/*                                                                           */
X/*  Break lines of object x so that it satisfies constraint c.               */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT BreakObject(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ OBJECT y;  CONSTRAINT yc, tc;
X  /***
X  debug1(DOB, DD,  "[ BreakObject( %s )", EchoObject(null, x));
X  debug3(DOB, DD, "  (size %s,%s; constraint %s)",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)), EchoConstraint(c));
X  ***/
X  debug3(DOB, DD,  "[ BreakObject(x (%s,%s),  %s), x =",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)), EchoConstraint(c));
X  ifdebug(DOB, DD, EchoObject(stderr, x));
X
X  if( FitsConstraint(back(x, COL), fwd(x, COL), *c) )
X  { debug0(DOB, DD, "] BreakObject returning (fits).");
X    return x;
X  }
X  switch( type(x) )
X  {
X
X    case ROTATE:
X    
X      Error(WARN, &fpos(x), "%s deleted (too wide; cannot break %s)",
X	KW_ROTATE, KW_ROTATE);
X      y = MakeWord("", &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case SCALE:
X
X      InvScaleConstraint(&yc, bc(constraint(x)), c);
X      Child(y, Down(x));
X      y = BreakObject(y, &yc);
X      back(x, COL) = (back(y, COL) * bc(constraint(x))) / SF;
X      fwd(x, COL) =  (fwd(y, COL)  * bc(constraint(x))) / SF;
X      break;
X
X
X    case WORD:
X    
X      Error(WARN, &fpos(x), "word %s deleted (too wide)",string(x));
X      y = MakeWord("", &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case WIDE:
X    
X      Error(WARN, &fpos(x), "%s %s reduced (too wide)",
X	EchoLength(bfc(constraint(x))), KW_WIDE);
X      MinConstraint(&constraint(x), c);
X      Child(y, Down(x));
X      y = BreakObject(y, &constraint(x));
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      EnlargeToConstraint(&back(x, COL), &fwd(x, COL), &constraint(x));
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X
X      Error(WARN, &fpos(x), "%s or %s deleted (too wide)", KW_INCGRAPHIC,
X	KW_SINCGRAPHIC);
X      y = MakeWord("", &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case HIGH:
X    case VSCALE:
X    case HCONTRACT: 
X    case VCONTRACT:
X    case HEXPAND: 
X    case VEXPAND:
X    case PADJUST: 
X    case HADJUST: 
X    case VADJUST:
X    case ONE_ROW:
X    case ONE_COL:
X    
X      assert( Down(x) == LastDown(x), "BreakObject: downs!" );
X      Child(y, Down(x));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case GRAPHIC:
X    
X      Child(y, LastDown(x));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case SPLIT:
X    
X      Child(y, DownDim(x, COL));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case ACAT:
X    
X      x = FillObject(x, c);
X      break;
X
X
X    case HCAT:
X    
X      x = BreakTable(x, c);
X      break;
X
X
X    case COL_THR:
X    
X      BreakJoinedGroup(Down(x), LastDown(x), nil, c, &back(x,COL), &fwd(x,COL));
X      break;
X
X
X    case VCAT:
X    
X      x = BreakVcat(x, c);
X      break;
X			
X
X    default:
X    
X      Error(INTERN, &fpos(x), "BreakObject: %s!", Image(type(x)) );
X      break;
X
X  }
X  assert( back(x, COL) >= 0, "BreakObject: back(x, COL) < 0!" );
X  assert( fwd(x, COL) >= 0, "BreakObject: fwd(x, COL) < 0!" );
X  debug1(DOB, DD,  "] BreakObject returning %s", EchoObject(null, x));
X  debug2(DOB, DD, "  (size is %s, %s)",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)));
X  return x;
X} /* end BreakObject */
END_OF_FILE
  if test 20116 -ne `wc -c <'lout/z13.c'`; then
    echo shar: \"'lout/z13.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z13.c'
fi
if test -f 'lout/z25.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z25.c'\"
else
  echo shar: Extracting \"'lout/z25.c'\" \(20719 characters\)
  sed "s/^X//" >'lout/z25.c' <<'END_OF_FILE'
X/*@z25.c:Object Echo:EchoObject()@********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z25.c                                                      */
X/*  MODULE:       Object Echo                                                */
X/*  EXTERNS:      EchoObject()                                               */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#if DEBUG_ON
X
Xstatic	int	limit;			/* column where newline is needed    */
Xstatic	int	indent;			/* current indent                    */
Xstatic	int	col;			/* current output column             */
Xstatic	FILE	*fp;			/* current output file               */
X
X#define	moveright()	(indent += 3)
X#define	moveleft()	(indent -= 3)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static print(x)                                                          */
X/*                                                                           */
X/*  Print the string x onto the appropriate output.                          */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic print(x)
Xunsigned char *x;
X{ col += strlen(x);
X  if( fp == null ) AppendString(x);
X  else fputs(x, fp);
X} /* end print */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static printnum(x)                                                       */
X/*                                                                           */
X/*  Print the number x onto the appropriate output.                          */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic printnum(x)
Xint x;
X{ static unsigned char buff[20];
X  sprintf(buff, "%d", x);
X  print(buff);
X} /* end printnum */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static tab(x)                                                            */
X/*                                                                           */
X/*  Tab to column x, or anyway insert at least one space.                    */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic tab(x)
Xint x;
X{  do
X     print(" ");
X   while( col < x );
X} /* end tab */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static newline()                                                         */
X/*                                                                           */
X/*  Echo a newline to the appropriate output (unless output is a string).    */
X/*  Correct indenting and right limits are maintained, if possible.          */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic newline()
X{ if( fp == null )  AppendString(" ");
X  else
X  { fputs("\n", fp);
X    fflush(fp);
X    for( col = 0;  col < indent;  col++ )  fputs(" ", fp);
X  }
X} /* end newline */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static space(n)                                                          */
X/*                                                                           */
X/*  Echo n spaces to the appropriate output.                                 */
X/*  Correct indenting and right limits are maintained, if possible.          */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic space(n)
Xint n;
X{ int i;
X  if( fp == null )
X    for( i = 0;  i < n;  i++ )  AppendString(" ");
X  else if( col + n > limit )
X  { fputs("\n", fp);
X    for( col = 0;  col < n-1;  col++ )  fputs(" ", fp);
X  }
X  else for( i = 0;  i < n;  col++, i++ )  fputs(" ", fp);
X} /* end space */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static echo(x, outer_prec)                                               */
X/*                                                                           */
X/*  Echo x.  The result will be enclosed in braces only if its precedence    */
X/*  is less than or equal to outer_prec (words and parameterless closures    */
X/*  are taken to have infinite precedence, i.e. never enclosed in braces).   */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic echo(x, outer_prec)
XOBJECT x;  unsigned outer_prec;
X{ OBJECT link, y, tmp, sym;
X  unsigned char str[10], *op;  int prec, i;
X  BOOLEAN npar_seen, name_printed, lbr_printed, braces_needed;
X
X  switch( type(x) )
X  {
X
X    case DEAD:
X
X	print("#dead");
X	break;
X
X    case UNATTACHED:
X    
X	print( "#unattached " );
X	moveright();
X	if( Down(x) != x )
X	{ Child(y, Down(x));
X	  if( y != x ) echo(y, NO_PREC);
X	  else print("<child is self!>");
X	}
X	else print("<no child!>");
X	moveleft();
X	break;
X
X
X    case EXPAND_IND:
X    case GALL_PREC:
X    case GALL_FOLL:
X    case GALL_TARG:
X    case CROSS_PREC:
X    case CROSS_FOLL:
X    case CROSS_TARG:
X    case RECURSIVE:
X    
X	print("#"); print(Image(type(x))); print(" ");
X	echo(actual(x), NO_PREC);
X	break;
X
X		
X    case RECEPTIVE:
X    case RECEIVING:
X    
X	print(type(x) == RECEIVING ? "#receiving " : "#receptive ");
X	if( external(actual(x)) )  print("(external) ");
X	if( threaded(actual(x)) )  print("(threaded) ");
X	if( blocked(x) )           print("(blocked) " );
X	if( trigger_externs(x) )   print("(trigger_externs) " );
X	if( non_blocking(x) )      print("(non_blocking) " );
X	print( type(actual(x)) == CLOSURE ?
X		SymName(actual(actual(x))) : Image(type(actual(x))) );
X	print(" ");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  moveright();
X	  echo(y, NO_PREC);
X	  moveleft();
X	}
X	break;
X
X
X    case PRECEDES:
X    
X	print("#precedes");
X	break;
X
X
X    case FOLLOWS:
X    
X	print("#follows");
X	if( blocked(x) )  print(" (blocked)");
X	Child(y, Down(x));
X	if( Up(y) == LastUp(y) )  print(" (no precedes!)");
X	break;
X
X
X    case HEAD:
X    
X	print("Galley ");  print(SymName(actual(x)));
X	print(" into ");   print(SymName(whereto(x)));
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  newline();
X	  echo(y, type(y) == GAP_OBJ ? VCAT : VCAT_PREC);
X	}
X	break;
X
X
X    case ROW_THR:
X
X	print("{R ");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  echo(y, VCAT_PREC);
X	  newline();
X	  if( NextDown(link) != x )  print("/R ");
X	}
X	print("R}");
X	break;
X
X
X    case COL_THR:
X
X	print("{C ");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  echo(y, HCAT_PREC);
X	  newline();
X	  if( NextDown(link) != x )  print("|C ");
X	}
X	print("C}");
X	break;
X
X
X    case VCAT: op = (unsigned char *) "/", prec = VCAT_PREC;  goto ETC;
X    case HCAT: op = (unsigned char *) "|", prec = HCAT_PREC;  goto ETC;
X    case ACAT: op = (unsigned char *) "&", prec = ACAT_PREC;  goto ETC;
X    
X	ETC:
X	if( Down(x) == x )
X	{ print(op);
X	  print("<empty>");
X	  break;
X	}
X	if( prec <= outer_prec ) print("{ ");
X	/* *** if( Down(x) == LastDown(x) )  print(op);  must be manifested */
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( is_index(type(y)) )
X	    newline();
X	  else if( (type(y) == GAP_OBJ && type(x) != ACAT) )
X	    newline();
X	  if( type(y) == GAP_OBJ )  echo(y, type(x));
X	  else echo(y, prec);
X	}
X	if( prec <= outer_prec )  print(" }");
X	break;
X
X
X    case GAP_OBJ:
X
X	/* in this case the outer_prec argument is VCAT, HCAT or ACAT */
X	if( Down(x) != x )
X	{ if( outer_prec == ACAT )  print(" ");
X	  print( EchoCatOp(outer_prec, mark(gap(x)), join(gap(x))) );
X	  Child(y, Down(x));
X	  echo(y, FORCE_PREC);
X	  print(" ");
X	}
X	else if( outer_prec == ACAT )
X	{ for( i = 1;  i <= vspace(x);  i++ )  newline();
X	  for( i = 1;  i <= hspace(x);  i++ )  print(" ");
X	}
X	else
X	{ print( EchoCatOp(outer_prec, mark(gap(x)), join(gap(x))) );
X	  print( EchoGap(&gap(x)) );
X	  print(" ");
X	}
X	break;
X
X
X    case WORD:
X    
X	if( strlen(string(x)) == 0 )
X	{ print(KW_LBR);
X	  print(KW_RBR);
X	}
X	else print( string(x) );
X	break;
X
X
X    case ENV:
X    
X	/* debug only */
X	print("<");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( type(y) == CLOSURE )
X	  { print( SymName(actual(y)) );
X	    echo(GetEnv(y), NO_PREC);
X	  }
X	  else if( type(y) == ENV )  echo(y, NO_PREC);
X	  else print(Image(type(y)));
X	  if( NextDown(link) != x )  print(" ");
X	}
X	print(">");
X	break;
X
X
X    case CROSS:
X
X	assert( Down(x) != x, "echo: CROSS Down(x)!" );
X	Child(y, Down(x));
X	if( type(y) == CLOSURE )  print(SymName(actual(y)));
X	else
X	{ print(KW_LBR);
X	  echo(y, NO_PREC);
X	  print(KW_RBR);
X	}
X	print(KW_CROSS);
X	if( NextDown(Down(x)) != x )
X	{ Child(y, NextDown(Down(x)));
X	  echo(y, NO_PREC);
X	}
X	else print("??");
X	break;
X
X
X    case CLOSURE:
X    
X	sym = actual(x);
X	braces_needed =
X	    precedence(sym) <= outer_prec && (has_lpar(sym) || has_rpar(sym));
X
X	/* print brace if needed */
X	if( braces_needed )  print(KW_LBR), print(" ");
X
X	npar_seen = FALSE;  name_printed = FALSE;
X	for( link = Down(x); link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( type(y) == PAR )
X	  { assert( Down(y) != y, "EchoObject: Down(PAR)!" );
X	    switch( type(actual(y)) )
X	    {
X	     case LPAR:	Child(tmp, Down(y));
X			echo(tmp, (unsigned) precedence(sym));
X			print(" ");
X			break;
X
X	     case NPAR:	if( !name_printed )
X			{ print(SymName(sym));
X			  if( external(x) || threaded(x) )
X			  { print(" #");
X			    if( external(x) )  print(" external");
X			    if( threaded(x) )  print(" threaded");
X			    newline();
X			  }
X			  name_printed = TRUE;
X			}
X			newline();  print("  ");
X			print( SymName(actual(y)) );
X			print(" ");  print(KW_LBR);  print(" ");
X			Child(tmp, Down(y));
X			echo(tmp, NO_PREC);
X			print(" ");  print(KW_RBR);
X			npar_seen = TRUE;
X			break;
X
X	     case RPAR:	if( !name_printed )
X			{ print(SymName(sym));
X			  if( external(x) || threaded(x) )
X			  { print(" #");
X			    if( external(x) )  print(" external");
X			    if( threaded(x) )  print(" threaded");
X			    newline();
X			  }
X			  name_printed = TRUE;
X			}
X			if( npar_seen ) newline();
X			else print(" ");
X			Child(tmp, Down(y));
X			if( has_body(sym) )
X			{ print(KW_LBR);  print(" ");
X			  echo(tmp, NO_PREC);
X			  print(" ");  print(KW_RBR);
X			}
X			else echo(tmp, (unsigned) precedence(sym));
X			break;
X	
X	     default:	Error(INTERN, &fpos(y), "echo: %s",
X					Image(type(actual(y))) );
X			break;
X
X	    }
X	  }
X	}
X	if( !name_printed )
X	{ print( SymName(sym) );
X	  if( external(x) || threaded(x) )
X	  { print(" #");
X	    if( external(x) )  print(" external");
X	    if( threaded(x) )  print(" threaded");
X	    newline();
X	  }
X	}
X
X	/* print closing brace if needed */
X	if( braces_needed ) print(" "), print(KW_RBR);
X	break;
X
X
X    case SPLIT:
X    
X	/* this should occur only in debug output case */
X	print(KW_SPLIT);  moveright();
X	Child(y, DownDim(x, COL));
X	print(" ");
X	echo(y, FORCE_PREC);
X	moveleft();
X	break;
X
X
X    case PAR:
X    
X	/* this should occur only in debug output case */
X	print("par ");  print(SymName(actual(x)));
X	break;
X
X
X    case CR_LIST:
X
X	print("(");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  echo(y, NO_PREC);
X	  if( NextDown(link) != x )  print(", ");
X	}
X	print(")");
X	break;
X
X
X    case MACRO:
X    
X	newline();  print(KW_MACRO);
X	print(" ");  print(SymName(x));
X	if( sym_body(x) != nil )
X	{ newline();  print(KW_LBR);
X	  y = sym_body(x);
X	  do
X	  { for( i = 1;  i <= vspace(y);  i++ )  newline();
X	    for( i = 1;  i <= hspace(y);  i++ )  print(" ");
X	    print(EchoToken(y));
X	    y = succ(y, PARENT);
X	  } while( y != sym_body(x) );
X	  newline();  print(KW_RBR);
X	}
X	else print(" "), print(KW_LBR), print(KW_RBR);
X	if( visible(x) )  print(" # (visible)");
X	break;
X
X
X    case NPAR:
X    case LOCAL:
X    
X	/* print predefined operators in abbreviated form */
X	if( sym_body(x) == nil && enclosing(x) != nil )
X	{ tab(3); print("# sys ");
X	  print(SymName(x));
X	  break;
X	}
X
X	/* print def line and miscellaneous debug info */
X	if( type(x) == LOCAL ) newline();
X	print(type(x) == NPAR ? KW_NAMED : KW_DEF);
X	print(" ");  print( SymName(x) );
X	if( recursive(x) || indefinite(x) || visible(x) ||
X	    is_extern_target(x) || uses_extern_target(x) || uses_galley(x) )
X	{ tab(25);  print("#");
X	  if( visible(x)  )  print(" visible");
X	  if( recursive(x)  )  print(" recursive");
X	  if( indefinite(x) )  print(" indefinite");
X	  if( is_extern_target(x) )  print(" is_extern_target");
X	  if( uses_extern_target(x) )  print(" uses_extern_target");
X	  if( uses_galley(x) )  print(" uses_galley");
X	}
X
X	/* print uses list, if necessary */
X	if( uses(x) != nil || dirty(x) )
X	{ newline();  print("   # ");
X	  if( dirty(x) ) print("dirty, ");
X	  print("uses");
X	  if( uses(x) != nil )
X	  { tmp = next(uses(x));
X	    do
X	    { print(" "), print( SymName(item(tmp)) );
X	      tmp = next(tmp);
X	    } while( tmp != next(uses(x)) );
X	  }
X	  /* ***
X	  for( tmp = uses(x);  tmp != nil;  tmp = next(tmp) )
X	  { print(" "), print( SymName(item(tmp)) );
X	  }
X	  *** */
X	}
X
X	/* print precedence, if necessary */
X	if( precedence(x) != DEFAULT_PREC )
X	{ newline();  print("   ");  print(KW_PRECEDENCE);
X	  sprintf(str, " %d", precedence(x));
X	  print(str);
X	}
X
X	/* print associativity, if necessary */
X	if( !right_assoc(x) )
X	{ newline();  print("   ");
X	  print(KW_ASSOC);  print(" ");  print(KW_LEFT);
X	}
X
X	/* print named parameters and local objects */
X	lbr_printed = FALSE;
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  assert( enclosing(y) == x, "echo: enclosing(y) != x!" );
X	  switch( type(y) )
X	  {
X	    case LPAR:
X	    case RPAR:	newline();  print("   ");
X			print( type(y) == LPAR ? KW_LEFT :
X			    has_body(x) ? KW_BODY : KW_RIGHT);
X			print(" ");
X			print( SymName(y) );
X			print("   # uses_count = ");
X			printnum(uses_count(y));
X			if( visible(y) )  print(" (visible)");
X			break;
X
X	    case NPAR:	moveright();  newline();
X			echo(y, NO_PREC);
X			print("   # uses_count = ");
X			printnum(uses_count(y));
X			moveleft();
X			break;
X
X	    case MACRO:
X	    case LOCAL:	if( !lbr_printed )
X			{ newline();
X			  print(KW_LBR);
X			  lbr_printed = TRUE;
X			}
X			moveright();
X			echo(y, NO_PREC);
X			moveleft();  newline();
X			break;
X
X	    default:	Error(FATAL, &fpos(y), "echo: type(y) = %s",
X					Image(type(y)));
X			break;
X	  }
X	}
X	if( type(x) == NPAR && Down(x) == x )  print(" ");
X	else newline();
X	if( !lbr_printed )
X	{ print(KW_LBR);  print("  ");
X	  lbr_printed = TRUE;
X	}
X	else print("   ");
X
X	/* print body */
X	moveright();
X	if( sym_body(x) != nil )  echo(sym_body(x), NO_PREC);
X	moveleft();  if( type(x) == LOCAL ) newline();
X	print(KW_RBR);
X	break;
X
X
X    case ONE_COL:
X    case ONE_ROW:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case HSCALE:
X    case VSCALE:
X    case NEXT:
X    case WIDE:
X    case HIGH:
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GRAPHIC:
X    case ROTATE:
X    case SCALE:
X    case CASE:
X    case YIELD:
X    case FONT:
X    case SPACE:
X    case BREAK:
X    case OPEN:
X    case TAGGED:
X    
X	/* print enclosing left brace if needed */
X	braces_needed = (DEFAULT_PREC <= outer_prec);
X	if( braces_needed )  print(KW_LBR), print(" ");
X
X	/* print left parameter */
X	if( Down(x) != LastDown(x) )
X	{ Child(y, Down(x));
X	  echo(y, max(outer_prec, DEFAULT_PREC));
X	  print(" ");
X	}
X
X	print(Image(type(x)));
X
X	/* print right parameter */
X	assert( LastDown(x) != x, "echo: right parameter of predefined!" );
X	print(" ");
X	Child(y, LastDown(x));
X	echo(y, type(x)==OPEN ? FORCE_PREC : max(outer_prec,DEFAULT_PREC));
X	if( braces_needed )  print(" "), print(KW_RBR);
X	break;
X
X
X    case NULL_CLOS:
X    
X	print(Image(type(x)));
X	break;
X
X
X    case CR_ROOT:
X
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  echo(y, NO_PREC);  newline();
X	}
X	break;
X
X
X    case CROSS_SYM:
X
X	print("Cross-references for ");
X	print(SymName(symb(x)));  newline();
X	switch( target_state(x) )
X	{
X	  case 0:	print("NO_TARGET");
X			break;
X
X	  case 1:	print("SEEN_TARGET ");
X			printnum(target_seq(x));
X			print(": ");
X			echo(target_val(x), NO_PREC);
X			break;
X
X	  case 2:	print("WRITTEN_TARGET ");
X			printnum(target_seq(x));
X			print(": to file ");
X			print(FileName(target_file(x)));
X			print(" at ");
X			printnum(target_pos(x));
X			break;
X	
X	  default:	print("ILLEGAL!");
X			break;
X	}
X	newline();
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  print("   ");
X	  if( gall_rec(y) )  print("gall_rec!");
X	  else print(string(y));
X	  newline();
X	}
X	break;
X
X
X    default:
X    
X	Error(INTERN, no_fpos, "echo found %s", Image(type(x)));
X	break;
X
X  } /* end switch */
X} /* end echo */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  unsigned char *EchoObject(file_ptr, x)                                   */
X/*                                                                           */
X/*  Send an image of unsized object x to result (if file_ptr is null) or to  */
X/*  file file_ptr if file_ptr is not null.                                   */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *EchoObject(file_ptr, x)
XFILE *file_ptr;  OBJECT x;
X{ debug0(DOE, D, "EchoObject()");
X  fp = file_ptr;
X  col = 0;
X  indent = 0;
X  limit  = 60;
X  if( fp == null )
X  { BeginString();
X    if( x == nil )  AppendString("<nil>");
X    else echo(x, type(x) == GAP_OBJ ? VCAT : 0);
X    return EndString();
X  }
X  else
X  { if( x != nil )
X    { echo(x, type(x) == GAP_OBJ ? VCAT : 0);
X      fprintf(file_ptr, "\n");
X    }
X    else fprintf(file_ptr, "<nil>\n");
X    debug0(DOE, D, "EchoObject returning");
X    return (unsigned char *) "";
X  }
X} /* end EchoObject */
X#endif
END_OF_FILE
  if test 20719 -ne `wc -c <'lout/z25.c'`; then
    echo shar: \"'lout/z25.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z25.c'
fi
echo shar: End of archive 12 \(of 30\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
