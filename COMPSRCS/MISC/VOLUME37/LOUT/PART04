Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i102:  lout - Lout document formatting system, v2, Part04/30
Message-ID: <1993May31.035157.20729@sparky.imd.sterling.com>
X-Md4-Signature: 04f5db9ba51da692bf13e07e82d61fe0
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 31 May 1993 03:51:57 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 102
Archive-name: lout/part04
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/doc/tr.eq/outfile.ps.A lout/doc/tr.impl/s5.0
#   lout/z10.c
# Wrapped by kent@sparky on Sun May 30 19:43:54 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 30)."'
if test -f 'lout/doc/tr.eq/outfile.ps.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/outfile.ps.A'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/outfile.ps.A'\" \(54341 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/outfile.ps.A' <<'END_OF_FILE'
X%!PS-Adobe-3.0
X%%Creator: Basser Lout Version 2.03 (April 1993)
X%%CreationDate: Fri Apr 23 09:09:42 1993
X%%DocumentNeededResources: (atend)
X%%Pages: (atend)
X%%BoundingBox: 0 0 595 841
X%%EndComments
X%%BeginProlog
X%%BeginResource: procset LoutStartUp
X/fnt { exch findfont exch scalefont setfont } def
X/x { currentpoint exch pop moveto } def
X/s { show } def
X/in { 1440 mul } def
X/cm { 567 mul } def
X/pt { 20 mul } def
X/em { 120 mul } def
X/sp { louts mul } def
X/vs { loutv mul } def
X/ft { loutf mul } def
X/dg {           } def
X/loutgr {
X  /louts exch def
X  /loutv exch def
X  /loutf exch def
X  /ymark exch def
X  /xmark exch def
X  /ysize exch def
X  /xsize exch def
X} def
X/BeginEPSF {
X  /LoutEPSFState save def
X  /dict_count countdictstack def
X  /op_count count 1 sub def
X  userdict begin
X  /showpage { } def
X  0 setgray 0 setlinecap
X  1 setlinewidth 0 setlinejoin
X  10 setmiterlimit [] 0 setdash newpath
X  /languagelevel where
X  { pop languagelevel
X    1 ne
X    { false setstrokeadjust false setoverprint
X    } if
X  } if
X} bind def
X/EndEPSF {
X  count op_count sub { pop } repeat
X  countdictstack dict_count sub { end } repeat
X  LoutEPSFState restore
X} bind def
X%%EndResource
X%%BeginResource: procset LoutTabPrependGraphic
X
X% @PrependGraphic file /usr/staff/jeff/lout.lib/include/tab_prepend
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X%                                                  %
X%  PostScript @SysPrependGraphic file for @Tab     %
X%                                                  %
X%  To assist in avoiding name clashes, the names   %
X%  of all these symbols begin with "ltab".         %
X%                                                  %
X%  Jeffrey H. Kingston                             %
X%  24 September 1991                               %
X%  22 December 1992                                %
X%                                                  %
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X
X% linewidth ltabhs -
X% horizontal single line
X/ltabhs
X{  0 0 moveto xsize 0 lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhsp -
X% horizontal single line with projecting ends
X/ltabhsp
X{  0 0 moveto xsize 0 lineto
X   setlinewidth 2 setlinecap stroke
X} def
X
X% linewidth ltabhd -
X% horizontal double line
X/ltabhd
X{  dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch 3 mul moveto xsize exch 3 mul lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhdb -
X% horizontal double line below mark
X/ltabhdb
X{  dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch -3 mul moveto xsize exch -3 mul lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhdnw -
X% horizontal double line with northwest corner
X/ltabhdnw
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   xsize exch 3 mul moveto
X   -3 mul exch 3 mul lineto
X   -3 mul 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdne -
X% horizontal double line with northeast corner
X/ltabhdne
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch 3 mul moveto
X   3 mul xsize add exch 3 mul lineto
X   3 mul xsize add 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdsw -
X% horizontal double line with southwest corner
X/ltabhdsw
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   xsize exch -3 mul moveto
X   -3 mul exch -3 mul lineto
X   -3 mul 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdse -
X% horizontal double line with southeast corner
X/ltabhdse
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch -3 mul moveto
X   3 mul xsize add exch -3 mul lineto
X   3 mul xsize add 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabvs -
X% vertical single line
X/ltabvs
X{  0 0 moveto 0 ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabvd -
X% vertical double line
X/ltabvd
X{  dup dup
X   0 0 moveto 0 ysize lineto
X   -3 mul 0 moveto -3 mul ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabvdr -
X% vertical double line to right of mark
X/ltabvdr
X{  dup dup
X   0 0 moveto 0 ysize lineto
X   3 mul 0 moveto 3 mul ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X%%EndResource
X%%BeginResource: procset LoutFigPrependGraphic
X
X% @PrependGraphic file /usr/staff/jeff/lout.lib/include/fig_prepend
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X%                                                                    %
X%  PostScript @SysPrependGraphic file for @Fig  Jeffrey H. Kingston  %
X%  Version 2.0 (includes CIRCUM label)                 January 1992  %
X%                                                                    %
X%  To assist in avoiding name clashes, the names of all symbols      %
X%  defined here begin with "lfig".  However, this is not feasible    %
X%  with user-defined labels and some labels used by users.           %
X%                                                                    %
X%  <point>      is two numbers, a point.                             %
X%  <length>     is one number, a length                              %
X%  <angle>      is one number, an angle in degrees                   %
X%  <dashlength> is one number, the preferred length of a dash        %
X%                                                                    %
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X
Xerrordict begin
X   /handleerror
X   {
X      {  /Times-Roman findfont 8 pt scalefont setfont
X	 0 setgray 4 pt 4 pt moveto
X	 $error /errorname get
X	 dup lfigdict exch known
X	 { lfigdict exch get }
X	 { 30 string cvs } ifelse
X	 show
X	 (  Command: ) show
X	 $error /command get 30 string cvs show
X      } stopped {} if
X      showpage stop
X   } def
Xend
X
X% concat strings: <string> <string> lfigconcat <string>
X% must be defined outside lfigdict since used in lfigpromotelabels
X/lfigconcat
X{ 2 copy length exch length add string
X  dup 0 4 index putinterval
X  dup 3 index length 3 index putinterval
X  3 1 roll pop pop
X} def
X
X% <string> lfigdebugprint -
X% must be defined outside lfigdict since used in arbitrary places
X% /lfigdebugprint
X% { print
X%   (;  operand stack:\n) print
X%   count copy
X%   count 2 idiv
X%   { ==
X%     (\n) print
X%   } repeat
X%   (\n) print
X% } def
X
X/lfigdict 120 dict def
Xlfigdict begin
X
X% error messages
X/dictfull (dictfull error:  too many labels?) def
X/dictstackoverflow (dictstackoverflow error:  labels nested too deeply?) def
X/execstackoverflow (execstackoverflow error:  figure nested too deeply?) def
X/limitcheck (limitcheck error:  figure nested too deeply or too large?) def
X/syntaxerror (syntaxerror error:  syntax error in text of figure?) def
X/typecheck (typecheck error:  syntax error in text of figure?) def
X/undefined (undefined error:  unknown or misspelt label?) def
X/VMError (VMError error:  run out of memory?) def
X
X% push pi onto stack:  - lfigpi <num>
X/lfigpi 3.14159 def
X
X% arc directions
X/clockwise     false def
X/anticlockwise true  def
X
X% maximum of two numbers:  <num> <num> lfigmax <num>
X/lfigmax { 2 copy gt { pop } { exch pop } ifelse } def
X
X% minimum of two numbers:  <num> <num> lfigmin <num>
X/lfigmin { 2 copy lt { pop } { exch pop } ifelse } def
X
X% add two points:  <point> <point> lfigpadd <point>
X/lfigpadd { exch 3 1 roll add 3 1 roll add exch } def
X
X% subtract first point from second:  <point> <point> lfigpsub <point>
X/lfigpsub { 3 2 roll sub 3 1 roll exch sub exch } def
X
X% max two points:  <point> <point> lfigpmax <point>
X/lfigpmax { exch 3 1 roll lfigmax 3 1 roll lfigmax exch } def
X
X% min two points:  <point> <point> lfigpmin <point>
X/lfigpmin { exch 3 1 roll lfigmin 3 1 roll lfigmin exch } def
X
X% scalar multiplication: <point> <num> lfigpmul <point>
X/lfigpmul { dup 3 1 roll mul 3 1 roll mul exch } def
X
X% point at angle and distance:  <point> <length> <angle> lfigatangle <point>
X/lfigatangle { 2 copy cos mul 3 1 roll sin mul lfigpadd } def
X
X% angle from one point to another:  <point> <point> lfigangle <angle>
X/lfigangle { lfigpsub 2 copy 0 eq exch 0 eq and {pop} {exch atan} ifelse } def
X
X% distance between two points:  <point> <point> lfigdistance <length>
X/lfigdistance { lfigpsub dup mul exch dup mul add sqrt } def
X
X% difference in x coords: <point> <point> lfigxdistance <length>
X/lfigxdistance { pop 3 1 roll pop sub } def
X
X%difference in y coords: <point> <point> lfigydistance <length>
X/lfigydistance { 3 1 roll pop sub exch pop } def
X
X% stroke a solid line:  <length> <dashlength> lfigsolid -
X/lfigsolid
X{  pop pop [] 0 setdash stroke
X} def
X
X% stroke a lfigdashed line:   <length> <dashlength> lfigdashed -
X/lfigdashed
X{  2 copy div 2 le 1 index 0 le or
X   {  exch pop 1 pt lfigmax [ exch dup ] 0 setdash }
X   {  dup [ exch 4 2 roll 2 copy div
X      1 sub 2 div ceiling dup 4 1 roll
X      1 add mul sub exch div ] 0 setdash
X   } ifelse stroke
X} def
X
X% stroke a lfigcdashed line:  <length> <dashlength> lfigcdashed -
X/lfigcdashed
X{  2 copy le 1 index 0 le or
X   {  exch pop 1 pt lfigmax [ exch dup ] copy 0 get 2 div setdash }
X   { dup [ 4 2 roll exch 2 copy exch div
X     2 div ceiling div 1 index sub
X     ] exch 2 div setdash
X   } ifelse stroke
X} def
X
X% stroke a dotted line:  <length> <dashlength> lfigdotted -
X/lfigdotted
X{  dup 0 le
X   {  exch pop 1 pt lfigmax [ exch 0 exch ] 0 setdash }
X   { 1 index exch div ceiling div
X     [ 0 3 2 roll ] 0 setdash
X   } ifelse stroke
X} def
X
X% stroke a noline line:  <length> <dashlength> lfignoline -
X/lfignoline
X{ pop pop
X} def
X
X% painting (i.e. filling): - lfigwhite - (etc.)
X/lfigwhite   { 1.0  setgray fill } def
X/lfiglight   { 0.95 setgray fill } def
X/lfiggrey    { 0.9  setgray fill } def
X/lfiggray    { 0.9  setgray fill } def
X/lfigdark    { 0.7  setgray fill } def
X/lfigblack   { 0.0  setgray fill } def
X/lfignopaint {                   } def
X
X% line caps (and joins, not currently used)
X/lfigbutt       0 def
X/lfiground      1 def
X/lfigprojecting 2 def
X/lfigmiter      0 def
X/lfigbevel      2 def
X
X% shape and labels of the @Box symbol
X/lfigbox
X{
X   0     0     /SW  lfigpointdef
X   xsize 0     /SE  lfigpointdef
X   xsize ysize /NE  lfigpointdef
X   0     ysize /NW  lfigpointdef
X   SE 0.5 lfigpmul /S   lfigpointdef
X   NW 0.5 lfigpmul /W   lfigpointdef
X   W SE lfigpadd   /E   lfigpointdef
X   S NW lfigpadd   /N   lfigpointdef
X   NE 0.5 lfigpmul /CTR lfigpointdef
X   [ CTR NE lfigpsub /lfigboxcircum cvx ] lfigcircumdef
X   SW SE NE NW SW
X} def
X
X% shape and labels of the @Square symbol
X/lfigsquare
X{
X   xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   CTR xsize xsize ysize ysize lfigpmax 0.5 lfigpmul lfigpadd /NE lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 135 lfigatangle lfigpadd /NW lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 225 lfigatangle lfigpadd /SW lfigpointdef
X   CTR 0 0 CTR NE lfigdistance 315 lfigatangle lfigpadd /SE lfigpointdef
X   SW 0.5 lfigpmul SE 0.5 lfigpmul lfigpadd /S lfigpointdef
X   NW 0.5 lfigpmul NE 0.5 lfigpmul lfigpadd /N lfigpointdef
X   SW 0.5 lfigpmul NW 0.5 lfigpmul lfigpadd /W lfigpointdef
X   SE 0.5 lfigpmul NE 0.5 lfigpmul lfigpadd /E lfigpointdef
X   [ CTR NE lfigpsub /lfigboxcircum cvx ] lfigcircumdef
X   SW SE NE NW SW
X} def
X
X% shape and labels of the @Diamond symbol
X/lfigdiamond
X{
X   xsize 0 0.5 lfigpmul /S   lfigpointdef
X   0 ysize 0.5 lfigpmul /W   lfigpointdef
X   S W         lfigpadd /CTR lfigpointdef
X   CTR W       lfigpadd /N   lfigpointdef
X   CTR S       lfigpadd /E   lfigpointdef
X   [ xsize ysize 0.5 lfigpmul /lfigdiamondcircum cvx ] lfigcircumdef
X   S E N W S
X} def
X
X% shape and labels of the @Ellipse symbol
X/lfigellipse
X{
X   xsize 0 0.5 lfigpmul /S   lfigpointdef
X   0 ysize 0.5 lfigpmul /W   lfigpointdef
X   S W         lfigpadd /CTR lfigpointdef
X   CTR W       lfigpadd /N   lfigpointdef
X   CTR S       lfigpadd /E   lfigpointdef
X   CTR xsize 0 0.3536 lfigpmul lfigpadd 0 ysize 0.3536 lfigpmul lfigpadd /NE lfigpointdef
X   0 ysize 0.3536 lfigpmul CTR xsize 0 0.3536 lfigpmul lfigpadd lfigpsub /SE lfigpointdef
X   xsize 0 0.3536 lfigpmul CTR lfigpsub 0 ysize 0.3536 lfigpmul lfigpadd /NW lfigpointdef
X   0 ysize 0.3536 lfigpmul xsize 0 0.3536 lfigpmul CTR lfigpsub lfigpsub /SW lfigpointdef
X   [ xsize ysize 0.5 lfigpmul /lfigellipsecircum cvx ] lfigcircumdef
X   S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X} def
X
X% shape and labels of the @Circle symbol
X/lfigcircle
X{
X   xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   CTR xsize 0 ysize 0 lfigpmax 0.5 lfigpmul lfigpadd /E lfigpointdef
X   CTR 0 0 CTR E lfigdistance 45 lfigatangle lfigpadd /NE lfigpointdef
X   CTR 0 0 CTR E lfigdistance 90 lfigatangle lfigpadd /N lfigpointdef
X   CTR 0 0 CTR E lfigdistance 135 lfigatangle lfigpadd /NW lfigpointdef
X   CTR 0 0 CTR E lfigdistance 180 lfigatangle lfigpadd /W lfigpointdef
X   CTR 0 0 CTR E lfigdistance 225 lfigatangle lfigpadd /SW lfigpointdef
X   CTR 0 0 CTR E lfigdistance 270 lfigatangle lfigpadd /S lfigpointdef
X   CTR 0 0 CTR E lfigdistance 315 lfigatangle lfigpadd /SE lfigpointdef
X   [ S E lfigpsub /lfigellipsecircum cvx ] lfigcircumdef
X   S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X} def
X
X% shape and labels of the @HLine and @HArrow symbols
X/lfighline
X{
X   0 ymark lfigprevious /FROM lfigpointdef
X   xsize ymark lfigprevious /TO lfigpointdef
X} def
X
X% shape and labels of the @VLine and @VArrow symbols
X/lfigvline
X{
X   xmark ysize lfigprevious /FROM lfigpointdef
X   xmark 0 lfigprevious /TO lfigpointdef
X} def
X
X% points of a polygon around base with given no of sides, vert init angle:
X% <sides> <angle> figpolygon <point> ... <point>
X/lfigpolygon
X{  xsize ysize 0.5 lfigpmul /CTR lfigpointdef
X   90 sub CTR 2 copy lfigmax 5 3 roll
X   [ 4 copy pop /lfigpolycircum cvx ] lfigcircumdef
X   exch dup 360 exch div exch
X   1 1  3 2 roll
X   {  4 string cvs (P) exch lfigconcat cvn
X      6 copy pop pop lfigatangle 2 copy 10 2 roll
X      3 2 roll lfigpointdef
X      dup 3 1 roll add exch
X   }  for
X   pop lfigatangle
X} def
X
X% next array element:  <array> <index> lfiggetnext <array> <index> <any> true
X%                                               or <array> <index> false
X/lfiggetnext
X{  2 copy exch length ge
X   { false }
X   { 2 copy get exch 1 add exch true } ifelse
X} def
X
X% check whether thing is number:  <any> lfigisnumbertype <any> <bool>
X/lfigisnumbertype
X{  dup type dup
X   /integertype eq exch /realtype eq or
X} def
X
X% check whether thing is an array:  <any> lfigisarraytype <any> <bool>
X/lfigisarraytype { dup type /arraytype eq } def
X
X% get next item:  <array> <index> lfiggetnextitem <array> <index> 0
X%                                              or <array> <index> <array> 1
X%                                              or <array> <index> <point> 2
X/lfiggetnextitem
X{   lfiggetnext
X    {	lfigisarraytype
X	{   1
X	}
X	{   lfigisnumbertype
X	    {	3 1 roll
X		lfiggetnext
X		{   lfigisnumbertype
X		    {	4 3 roll exch  2
X		    }
X		    {	pop 3 2 roll pop  0
X		    } ifelse
X		}
X		{   3 2 roll pop  0
X		} ifelse
X	    }
X	    {	pop 0
X	    } ifelse
X	} ifelse
X    }
X    {	0
X    } ifelse
X} def
X
X% set arc path:  bool x1 y1  x2 y2  x0 y0  lfigsetarc  <angle> <angle> <dist>
X% the path goes from x1 y1 to x2 y2 about centre x0 y0,
X% anticlockwise if bool is true else clockwise.
X% The orientations of backwards pointing and forwards pointing
X% arrowheads are returned in the two angles, and
X% the length of the arc is returned in <dist>.
X/lfigsetarc
X{
X  20 dict begin
X     matrix currentmatrix 8 1 roll
X     2 copy translate 2 copy 8 2 roll
X     4 2 roll lfigpsub 6 2 roll lfigpsub
X     dup /y1 exch def dup mul /y1s exch def
X     dup /x1 exch def dup mul /x1s exch def
X     dup /y2 exch def dup mul /y2s exch def
X     dup /x2 exch def dup mul /x2s exch def
X
X     y1s y2s eq
X     {	-1
X     }
X     {	y1s x2s mul y2s x1s mul sub y1s y2s sub div
X     } ifelse
X     /da exch def
X
X     x1s x2s eq
X     {	-1
X     }
X     {	x1s y2s mul x2s y1s mul sub x1s x2s sub div
X     } ifelse
X     /db exch def
X
X     da 0 gt db 0 gt and
X     {	/LMax da sqrt db sqrt lfigmax def
X	/scalex da sqrt LMax div def
X	/scaley db sqrt LMax div def
X	scalex scaley scale
X	0 0 LMax
X	0 0 x1 scalex mul y1 scaley mul lfigangle
X	0 0 x2 scalex mul y2 scaley mul lfigangle
X	2 copy eq { 360 add } if
X	2 copy 8 2 roll
X	5 index { arc } { arcn } ifelse
X	2 index 1 index
X	{ 90 sub } { 90 add } ifelse
X	dup sin scaley mul exch cos scalex mul atan
X	2 index 2 index
X	{ 90 add } { 90 sub } ifelse
X	dup sin scaley mul exch cos scalex mul atan
X	5 2 roll  % res1 res2 ang1 ang2 anticlockwise
X	{ exch sub } { sub } ifelse
X	dup 0 le { 360 add } if  lfigpi mul LMax mul 180 div
X     }
X     {	0 0 x1 y1 lfigdistance 0 0 x2 y2 lfigdistance eq
X	0 0 x1 y1 lfigdistance 0 gt and
X	{	0 0
X		0 0 x1 y1 lfigdistance
X		0 0 x1 y1 lfigangle
X		0 0 x2 y2 lfigangle
X		2 copy eq { 360 add } if
X		2 copy 8 2 roll
X		5 index { arc } { arcn } ifelse
X		2 index 1 index
X		{ 90 sub } { 90 add } ifelse
X		2 index 2 index
X		{ 90 add } { 90 sub } ifelse
X		5 2 roll % res1 res2 ang1 ang2 clockwise
X		{ exch sub } { sub } ifelse
X		dup 0 le { 360 add } if lfigpi mul 0 0 x1 y1 lfigdistance mul 180 div
X	}
X	{	x2 y2 lineto pop
X		x2 y2 x1 y1 lfigangle
X		x1 y1 x2 y2 lfigangle
X		x1 y1 x2 y2 lfigdistance
X	} ifelse
X     } ifelse
X     4 -1 roll setmatrix
X   end
X} def
X
X% lfigsetcurve: set up a Bezier curve from x0 y0 to x3 y3
X% and return arrowhead angles and length of curve (actually 0)
X% x0 y0 x1 y1 x2 y2 x3 y3 lfigsetcurve <angle> <angle> <length>
X/lfigsetcurve
X{ 8 copy curveto pop pop
X  lfigangle
X  5 1 roll
X  4 2 roll lfigangle
X  exch
X  0
X} def
X
X% lfigpaintpath: paint a path of the given shape
X% /paint [ shape ] lfigpaintpath -
X/lfigpaintpath
X{
X  10 dict begin
X    0 newpath
X    /prevseen false def
X    /curveseen false def
X    { lfiggetnextitem
X      dup 0 eq { pop exit }
X      { 1 eq
X        { /curveseen true def
X	  /curve exch def
X	  curve length 0 eq { /curveseen false def } if
X        }
X        { /ycurr exch def
X	  /xcurr exch def
X	  prevseen
X	  { curveseen
X	    { curve length 4 eq
X	      { xprev yprev
X		curve 0 get curve 1 get
X		curve 2 get curve 3 get
X		xcurr ycurr
X		lfigsetcurve pop pop pop
X	      }
X	      { xprev yprev xcurr ycurr
X	        curve length 1 ge { curve 0 get } { 0 } ifelse
X	        curve length 2 ge { curve 1 get } { 0 } ifelse
X	        curve length 3 ge { curve 2 get } { true } ifelse
X	        7 1 roll
X	        lfigsetarc pop pop pop
X	      } ifelse
X	    }
X	    { xcurr ycurr lineto
X	    } ifelse
X	  }
X	  { xcurr ycurr moveto
X	  } ifelse
X	  /xprev xcurr def
X	  /yprev ycurr def
X	  /prevseen true def
X	  /curveseen false def
X        } ifelse
X      } ifelse
X    } loop pop pop cvx exec
X  end
X} def
X
X% stroke a path of the given shape in the given linestyle and dash length.
X% Return the origin and angle of the backward and forward arrow heads.
X% dashlength /linestyle [shape] lfigdopath  [<point> <angle>] [<point> <angle>] 
X/lfigdopath
X{
X  10 dict begin
X    0
X    /prevseen  false def
X    /curveseen false def
X    /backarrow []    def
X    /fwdarrow  []    def
X    {
X	lfiggetnextitem
X	dup 0 eq { pop exit }
X	{
X	    1 eq
X	    {	/curveseen true def
X		/curve exch def
X		curve length 0 eq { /prevseen false def } if
X	    }
X	    {	/ycurr exch def
X		/xcurr exch def
X		prevseen
X		{   newpath xprev yprev moveto
X		    curveseen
X		    {	curve length 4 eq
X			{   xprev yprev
X			    curve 0 get curve 1 get
X			    curve 2 get curve 3 get
X			    xcurr ycurr lfigsetcurve
X			}
X			{   xprev yprev xcurr ycurr
X			    curve length 1 ge { curve 0 get } { 0 } ifelse
X			    curve length 2 ge { curve 1 get } { 0 } ifelse
X			    curve length 3 ge { curve 2 get } { true } ifelse
X			    7 1 roll
X			    lfigsetarc
X			} ifelse
X		    }
X		    {	xcurr ycurr lineto
X			xcurr ycurr xprev yprev lfigangle dup 180 sub
X			xprev yprev xcurr ycurr lfigdistance
X		    } ifelse
X		    6 index 6 index cvx exec
X		    [ xprev yprev 5 -1 roll ]
X		    backarrow length 0 eq
X		    { /backarrow exch def }
X		    { pop } ifelse
X		    [ xcurr ycurr 4 -1 roll ] /fwdarrow exch def
X		} if
X		/xprev xcurr def
X		/yprev ycurr def
X		/prevseen true def
X		/curveseen false def
X	    } ifelse
X	} ifelse
X    } loop
X    pop pop pop pop
X    backarrow length 0 eq { [ 0 0 0 ] } { backarrow } ifelse
X    fwdarrow  length 0 eq { [ 0 0 0 ] } { fwdarrow  } ifelse
X  end
X} def
X
X% lfigdoarrow: draw an arrow head of given form
X% dashlength /lstyle /pstyle hfrac height width [ <point> <angle> ] lfigdoarrow -
X/lfigdoarrow
X{  matrix currentmatrix 8 1 roll
X   dup 0 get 1 index 1 get translate
X   2 get rotate
X   [ 2 index neg 2 index 0 0
X     3 index 3 index neg
X     1 index 10 index mul 0
X     7 index 7 index ]
X   4 1 roll pop pop pop
X   dup 3 1 roll
X   gsave lfigpaintpath grestore lfigdopath pop pop
X   setmatrix
X} def
X
X% arrow head styles
X/lfigopen     0.0 def
X/lfighalfopen 0.5 def
X/lfigclosed   1.0 def
X
X% stroke no arrows, forward, back, and both
X/lfignoarrow { pop pop pop pop pop pop pop pop                        } def
X/lfigforward { 7 -1 roll lfigdoarrow pop                              } def
X/lfigback    { 8 -2 roll pop lfigdoarrow                              } def
X/lfigboth    { 8 -1 roll 7 copy lfigdoarrow pop 7 -1 roll lfigdoarrow } def
X
X% lfigprevious: return previous point on path
X/lfigprevious
X{ lfigisnumbertype
X  { 2 copy }
X  { lfigisarraytype
X    { 2 index 2 index }
X    { 0 0 }
X    ifelse
X  } ifelse
X} def
X
X% label a point in 2nd top dictionary:  <point> /name lfigpointdef -
X/lfigpointdef
X{
X  % (Entering lfigpointdef) lfigdebugprint
X  [ 4 2 roll transform
X    /itransform cvx ] cvx
X    currentdict end
X    3 1 roll
X    % currentdict length currentdict maxlength lt
X    % { def }
X    % { exec moveto (too many labels) show stop }
X    % ifelse
X    def
X    begin
X  % (Leaving lfigpointdef) lfigdebugprint
X} def
X
X% promote labels from second top to third top dictionary
X% <string> lfigpromotelabels -
X/lfigpromotelabels
X{
X  % (Entering lfigpromotelabels) lfigdebugprint
X  currentdict end exch currentdict end
X  { exch 20 string cvs 2 index
X    (@) lfigconcat exch lfigconcat cvn exch def
X  } forall pop begin
X  % (Leaving lfigpromotelabels) lfigdebugprint
X} def
X
X% show labels (except CIRCUM): - lfigshowlabels -
X/lfigshowlabels
X{
X  % (Entering lfigshowlabels) lfigdebugprint
X  currentdict end
X    currentdict
X    { 1 index 20 string cvs (CIRCUM) search % if CIRCUM in key
X      { pop pop pop pop pop }
X      { pop cvx exec 2 copy
X        newpath 1.5 pt 0 360 arc
X        0 setgray fill
X        /Times-Roman findfont 8 pt scalefont setfont
X        moveto 0.2 cm 0.1 cm rmoveto 20 string cvs show
X      }
X      ifelse
X    } forall
X  begin
X  % (Leaving lfigshowlabels) lfigdebugprint
X} def
X
X% fix an angle to between 0 and 360 degrees:  <angle> lfigfixangle <angle>
X/lfigfixangle
X{
X  % (Entering lfigfixangle) lfigdebugprint
X  { dup 0 ge { exit } if
X    360 add
X  } loop
X  { dup 360 lt { exit } if
X    360 sub
X  } loop
X  % (Leaving lfigfixangle) lfigdebugprint
X} def
X
X% find point on circumference of box:  alpha a b lfigboxcircum x y
X/lfigboxcircum
X{
X  % (Entering lfigboxcircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    0 0 a b lfigangle /theta exch def
X
X    % if alpha <= theta, return (a, a*tan(alpha))
X    alpha theta le
X    { a  a alpha sin mul alpha cos div }
X    {
X      % else if alpha <= 180 - theta, return (b*cot(alpha), b)
X      alpha 180 theta sub le
X      { b alpha cos mul alpha sin div  b }
X      {
X        % else if alpha <= 180 + theta, return (-a, -a*tan(alpha))
X        alpha 180 theta add le
X        { a neg  a neg alpha sin mul alpha cos div }
X        {
X	  % else if alpha <= 360 - theta, return (-b*cot(alpha), -b)
X	  alpha 360 theta sub le
X          { b neg alpha cos mul alpha sin div  b neg }
X	  {
X	    % else 360 - theta <= alpha, return (a, a*tan(alpha))
X	    a  a alpha sin mul alpha cos div
X	  } ifelse
X        } ifelse
X      } ifelse
X    } ifelse
X  end
X  % (Leaving lfigboxcircum) lfigdebugprint
X} def
X
X% find point on circumference of diamond:  alpha a b lfigdiamondcircum x y
X/lfigdiamondcircum
X{
X  % (Entering lfigdiamondcircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    b alpha cos abs mul  a alpha sin abs mul  add  /denom exch def
X    a b mul alpha cos mul denom div
X    a b mul alpha sin mul denom div
X  end
X  % (Leaving lfigdiamondcircum) lfigdebugprint
X} def
X
X% find point on circumference of ellipse:  alpha a b lfigellipsecircum x y
X/lfigellipsecircum
X{
X  % (Entering lfigellipsecircum) lfigdebugprint
X  4 dict begin
X    /b exch def
X    /a exch def
X    lfigfixangle /alpha exch def
X    b alpha cos mul dup mul  a alpha sin mul dup mul  add sqrt /denom exch def
X    a b mul alpha cos mul denom div
X    a b mul alpha sin mul denom div
X  end
X  % (Leaving lfigellipsecircum) lfigdebugprint
X} def
X
X% find point of intersection of two lines each defined by two points
X% x1 y1 x2 y2  x3 y3 x4 y4  lfiglineintersect x y
X/lfiglineintersect
X{
X  % (Entering lfiglineintersect) lfigdebugprint
X  13 dict begin
X    /y4 exch def
X    /x4 exch def
X    /y3 exch def
X    /x3 exch def
X    /y2 exch def
X    /x2 exch def
X    /y1 exch def
X    /x1 exch def
X    x2 x1 sub /x21 exch def
X    x4 x3 sub /x43 exch def
X    y2 y1 sub /y21 exch def
X    y4 y3 sub /y43 exch def
X    y21 x43 mul y43 x21 mul sub /det exch def
X  
X    % calculate x 
X    y21 x43 mul x1 mul
X    y43 x21 mul x3 mul sub
X    y3 y1 sub x21 mul x43 mul add
X    det div
X
X    % calculate y
X    x21 y43 mul y1 mul
X    x43 y21 mul y3 mul sub
X    x3 x1 sub y21 mul y43 mul add
X    det neg div
X
X  end
X  % (Leaving lfiglineintersect) lfigdebugprint
X} def
X
X% find point on circumference of polygon
X% alpha radius num theta lfigpolycircum x y
X/lfigpolycircum
X{
X  % (Entering lfigpolycircum) lfigdebugprint
X  13 dict begin
X    /theta exch def
X    /num exch def
X    /radius exch def
X    /alpha exch def
X
X    % calculate delta, the angle from theta to alpha
X    alpha theta sub lfigfixangle
X
X    % calculate the angle which is the multiple of 360/num closest to delta
X    360 num div div truncate 360 num div mul theta add /anglea exch def
X
X    % calculate the next multiple of 360/num after anglea
X    anglea 360 num div add /angleb exch def
X
X    % intersect the line through these two points with the alpha line
X    anglea cos anglea sin  angleb cos angleb sin
X    0 0  alpha cos 2 mul alpha sin 2 mul
X    lfiglineintersect radius lfigpmul
X
X  end
X  % (Leaving lfigpolycircum) lfigdebugprint
X} def
X
X% add CIRCUM operator with this body:  <array> lfigcircumdef -
X/lfigcircumdef
X{   % (Entering lfigcircumdef) lfigdebugprint
X    /CIRCUM exch cvx
X    currentdict end
X    3 1 roll
X    % currentdict length currentdict maxlength lt
X    % { def }
X    % { exec moveto (too many labels) show stop }
X    % ifelse
X    def
X    begin
X    % (Leaving lfigcircumdef) lfigdebugprint
X} def
X
Xend
X%%EndResource
X
X%%EndProlog
X
X%%Page: ? 1
X%%BeginPageSetup
X0.0500 dup scale 10 setlinewidth
X/pgsave save def
X%%EndPageSetup
X
X/Times-Bold 240 fnt
X3365 13817 moveto(Eq)s 3718 x(\261)s 3898 x(A)s 4131 x(Lout)s 4683 x(Package)s
X5594 x(for)s 5959 x(Typesetting)s 7214 x(Mathematics)s 
X/Times-Italic 240 fnt
X5020 13243 moveto(Jeffrey)s 5729 x(H.)s
X6022 x(Kingston)s 
X/Times-Roman 240 fnt
X4001 12671 moveto(Basser)s 4698 x(Department)s 5886 x(of)s 6145 x(Computer)s
X7162 x(Science)s 4659 12383 moveto(University)s 5728 x(of)s 5987 x(Sydney)s 6766 x(2006)s
X5515 12095 moveto(Australia)s 
X/Times-Italic 240 fnt
X5388 11211 moveto(ABSTRACT)s 
X/Times-Roman 240 fnt
X2137 10755 moveto(This)s 2660 x(report)s 3328 x(describes)s
X4315 x(the)s 4705 x(use)s 5122 x(of)s 5419 x(Eq,)s 5843 x(a)s
X6047 x(package)s 6929 x(of)s 7226 x(de\256nitions)s 8334 x(for)s 8710 x(typesetting)s
X2137 10467 moveto(mathematics)s 3404 x(with)s 3889 x(the)s 4241 x(Lout)s 4753 x(document)s
X5757 x(formatter.)s 6824 x(For)s 7216 x(example,)s 
X/Helvetica 220 fnt
X2617 9966 moveto(@Eq { big int supp 1 on 0 ` dx over sqrt {1 - x sup 2} = pi over 2 })s 
X/Times-Roman 240 fnt
X2137 9467 moveto(produces)s
X3061 x(the)s 3413 x(output)s gsave
X2617 8850 translate
X-180.0000 rotate
Xgsave
X0 -206 translate
X180.0000 rotate
X
X/Symbol 405 fnt
X0 -370 moveto(\362)s 
Xgrestore
X
Xgrestore
X
X/Symbol 405 fnt
X2617 8687 moveto(\362)s 
X/Symbol 168 fnt
X2727 9014 moveto(\061)s
X2727 8602 moveto(\060)s 
X/Times-Italic 240 fnt
X3105 8901 moveto(dx)s gsave
X2854 8850 translate
X729 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
Xgsave
X0 8582 translate
X1.0000 1.3755 scale
X
X/Symbol 240 fnt
X2854 -60 moveto(\326)s 
Xgrestore
Xgsave
X2985 8802 translate
X598 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.03 ft setlinewidth 2 setlinecap stroke
Xgrestore
X
Xgrestore
X
X/Symbol 240 fnt
X3028 8530 moveto(\061)s 3205 x(-)s
X
X/Symbol 168 fnt
X3499 8644 moveto(\062)s 
X/Times-Italic 240 fnt
X3393 8537 moveto(x)s 
X/Symbol 240 fnt
X3655 8790 moveto(\075)s 3858 8902 moveto(\160)s gsave
X3858 8850 translate
X131 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Symbol 240 fnt
X3863 8638 moveto(\062)s
X
X/Times-Roman 240 fnt
X2137 8037 moveto(The)s 2568 x(advantages)s 3690 x(of)s 3948 x(Eq)s 4273 x(include)s
X5036 x(careful)s 5757 x(attention)s 6652 x(to)s 6897 x(details)s 7579 x(of)s
X7837 x(spacing,)s 8687 x(a)s 8852 x(repertoire)s 2137 7749 moveto(of)s 2382 x(several)s
X3104 x(hundred)s 3935 x(mathematical)s 5267 x(symbols,)s 6171 x(a)s 6323 x(simple)s
X7006 x(syntax)s 7677 x(extensible)s 8692 x(by)s 8978 x(the)s 9316 x(user,)s
X2137 7461 moveto(and)s 2543 x(complete)s 3479 x(integration)s 4574 x(with)s 5059 x(the)s
X5411 x(rest)s 5815 x(of)s 6074 x(Lout.)s 2617 7087 moveto(In)s 2898 x(addition,)s
X3824 x(this)s 4251 x(report)s 4903 x(contains)s 5782 x(an)s 6090 x(appendix)s
X7050 x(describing)s 8128 x(the)s 8502 x(use)s 8903 x(of)s 9184 x(Pas,)s
X9658 x(a)s 2137 6799 moveto(package)s 2981 x(of)s 3240 x(de\256nitions)s 4310 x(for)s
X4648 x(printing)s 5465 x(Pascal)s 6135 x(programs.)s 1417 5145 moveto(22)s 1717 x(December,)s
X2819 x(1992)s 
Xpgsave restore
Xshowpage
X
X%%Page: ? 2
X%%BeginPageSetup
X0.0500 dup scale 10 setlinewidth
X/pgsave save def
X%%EndPageSetup
X
X/Times-Bold 240 fnt
X3365 14537 moveto(Eq)s 3718 x(\261)s 3898 x(A)s 4131 x(Lout)s 4683 x(Package)s
X5594 x(for)s 5959 x(Typesetting)s 7214 x(Mathematics)s 
X/Times-Italic 240 fnt
X5020 13963 moveto(Jeffrey)s 5729 x(H.)s
X6022 x(Kingston)s 
X/Times-Roman 240 fnt
X4001 13391 moveto(Basser)s 4698 x(Department)s 5886 x(of)s 6145 x(Computer)s
X7162 x(Science)s 4659 13103 moveto(University)s 5728 x(of)s 5987 x(Sydney)s 6766 x(2006)s
X5515 12815 moveto(Australia)s 
X/Times-Bold 240 fnt
X1417 12222 moveto(1.)s 1717 x(Introduction)s 
X/Times-Roman 240 fnt
X1897 11850 moveto(Eq)s 2205 x(is)s
X2406 x(a)s 2554 x(package)s 3380 x(of)s 3621 x(de\256nitions)s 4673 x(for)s
X4993 x(typesetting)s 6084 x(mathematics)s 7333 x(with)s 7800 x(the)s 8134 x(Lout)s
X8628 x(document)s 9614 x(formatter)s 1417 11562 moveto([)s 1496 x(4)s 1616 x(].)s
X1874 x(It)s 2078 x(includes)s 2934 x(several)s 3669 x(hundred)s 4513 x(mathematical)s
X5858 x(and)s 6263 x(other)s 6813 x(special)s 7535 x(characters)s 8561 x(\(including)s
X9603 x(the)s 9954 x(entire)s 1417 11274 moveto(PostScript)s 
X/Times-Roman 153 fnt
X2399 11379 moveto(1)s 
X/Times-Roman 240 fnt
X2545 11274 moveto(Symbol)s
X3360 x(font)s 3815 x([)s 3894 x(1)s 4014 x(]\),)s 4302 x(and)s
X4718 x(a)s 4894 x(smaller)s 5666 x(number)s 6467 x(of)s 6736 x(symbols)s
X7604 x(for)s 7952 x(joining)s 8700 x(objects)s 9447 x(together)s 10300 x(in)s
X1417 10986 moveto(mathematical)s 2753 x(ways.)s 3415 x(Eq)s 3731 x(is)s 3940 x(based)s
X4535 x(on)s 4825 x(the)s 5167 x(eqn)s 5563 x(language)s 6477 x(of)s
X6726 x(Kernighan)s 7786 x(and)s 8182 x(Cherry)s 8896 x([)s 8975 x(3)s
X9095 x(],)s 9284 x(with)s 9759 x(spacing)s 1417 10698 moveto(rules)s 1941 x(similar)s
X2663 x(to)s 2909 x(Knuth's)s 3740 x(T)s 3886 10650 moveto(E)s 4032 10698 moveto(X)s
X4265 x(formatter)s 5212 x([)s 5291 x(6)s 5411 x(].)s 1897 10324 moveto(To)s
X2226 x(use)s 2608 x(Eq)s 2937 x(in)s 3186 x(a)s 3355 x(Lout)s
X3870 x(document,)s 4937 x(\256rst)s 5371 x(ensure)s 6058 x(that)s 6479 x(its)s
X6767 x(de\256nition)s 7747 x(is)s 7969 x(included,)s 8916 x(either)s 9522 x(by)s
X9825 x(having)s 
X/Helvetica 220 fnt
X1417 10032 moveto(@SysInclude { eq })s 
X/Times-Roman 240 fnt
X3367 10036 moveto(in)s 3634 x(the)s 4007 x(setup)s
X4593 x(\256le,)s 5039 x(or)s 
X/Helvetica 220 fnt
X5319 10032 moveto(-ieq)s 
X/Times-Roman 240 fnt
X5765 10036 moveto(on)s 6086 x(the)s
X6459 x(command)s 7484 x(line.)s 8043 x(Then,)s 8676 x(at)s 8929 x(any)s
X9356 x(point)s 9929 x(in)s 10196 x(the)s 1417 9748 moveto(document,)s 2479 x(write)s
X
X/Helvetica 220 fnt
X3027 9744 moveto(@Eq  {  ...  })s 
X/Times-Roman 240 fnt
X4271 9748 moveto(and)s 4675 x(the)s 5025 x(symbols)s 5881 x(of)s
X6138 x(Eq)s 6462 x(will)s 6891 x(be)s 7175 x(available)s 8095 x(between)s
X8950 x(the)s 9300 x(braces.)s 10088 x(Any)s 1417 9460 moveto(symbols)s 2290 x(available)s
X3227 x(outside)s 3993 x(continue)s 4892 x(to)s 5153 x(be)s 5454 x(available)s
X6391 x(inside,)s 7097 x(which)s 7757 x(means)s 8443 x(that)s 8876 x(Eq)s
X9217 x(can)s 9624 x(be)s 9925 x(freely)s 1417 9172 moveto(mixed)s 2075 x(with)s
X2560 x(standard)s 3430 x(Lout)s 3942 x(and)s 4348 x(with)s 4833 x(symbols)s
X5691 x(from)s 6215 x(other)s 6766 x(packages,)s 7763 x(without)s 8554 x(restriction.)s
X1897 8798 moveto(In)s 2156 x(this)s 2561 x(report)s 3191 x(we)s 3530 x(show)s
X4096 x(the)s 4448 x(Lout)s 4960 x(input)s 5512 x(at)s 5744 x(the)s
X6096 x(left,)s 6533 x(and)s 6939 x(its)s 7224 x(result)s 7814 x(at)s
X8046 x(the)s 8398 x(right:)s 
X/Helvetica 220 fnt
X1897 8081 moveto(@Eq { {x sup 2 + y sup 2} over 2 })s 
X/Symbol 168 fnt
X5972 8343 moveto(\062)s 
X/Times-Italic 240 fnt
X5866 8236 moveto(x)s
X
X/Symbol 240 fnt
X6113 8229 moveto(+)s 
X/Symbol 168 fnt
X6407 8343 moveto(\062)s 
X/Times-Italic 240 fnt
X6301 8236 moveto(y)s gsave
X5866 8138 translate
X625 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Symbol 240 fnt
X6118 7926 moveto(\062)s 
X/Times-Roman 240 fnt
X1417 7476 moveto(Subsequent)s
X2581 x(examples)s 3544 x(will)s 3975 x(omit)s 4473 x(the)s 4825 x(enclosing)s
X
X/Helvetica 220 fnt
X5802 7472 moveto(@Eq { ... })s 
X/Times-Roman 240 fnt
X6805 7476 moveto(.)s 
X/Times-Bold 240 fnt
X1417 6683 moveto(2.)s 1717 x(Symbols)s 
X/Times-Roman 240 fnt
X1897 6311 moveto(Eq)s
X2223 x(prints)s 2827 x(characters)s 3854 x(in)s 4100 x(the)s 4452 x(fonts)s
X4990 x(appropriate)s 6138 x(for)s 6476 x(mathematics:)s 
X/Helvetica 220 fnt
X1897 5810 moveto(x - 2)s 
X/Times-Italic 240 fnt
X5866 5814 moveto(x)s
X
X/Symbol 240 fnt
X6029 5807 moveto(-)s 6217 x(\062)s 
X/Times-Roman 240 fnt
X1417 5356 moveto(Here)s 
X/Times-Italic 240 fnt
X1923 x(x)s 
X/Times-Roman 240 fnt
X2071 x(is)s
X2272 x(in)s 2500 x(Italic,)s 
X/Symbol 240 fnt
X3091 5349 moveto(\062)s 
X/Times-Roman 240 fnt
X3253 5356 moveto(is)s 3454 x(in)s
X3682 x(Roman,)s 4476 x(and)s 
X/Symbol 240 fnt
X4864 5349 moveto(-)s 
X/Times-Roman 240 fnt
X5037 5356 moveto(is)s 5238 x(from)s
X5744 x(the)s 6078 x(Symbol)s 6865 x(font.)s 7412 x(The)s 7826 x(character)s
X
X/Helvetica 220 fnt
X8742 5352 moveto(-)s 
X/Times-Roman 240 fnt
X8857 5356 moveto(is)s 9058 x(a)s 
X/Times-Italic 240 fnt
X9206 x(symbol)s 
X/Times-Roman 240 fnt
X9926 x(which)s
X1417 5068 moveto(stands)s 2075 x(for)s 
X/Symbol 240 fnt
X2413 5061 moveto(-)s 
X/Times-Roman 240 fnt
X2544 5068 moveto(,)s 2664 x(and)s
X
X/Helvetica 220 fnt
X3070 5064 moveto(2)s 
X/Times-Roman 240 fnt
X3252 5068 moveto(is)s 3471 x(also)s 3916 x(a)s 4082 x(symbol,)s
X4907 x(standing)s 5778 x(for)s 
X/Symbol 240 fnt
X6116 5061 moveto(\062)s 
X/Times-Roman 240 fnt
X6236 5068 moveto(.)s 6416 x(Eq)s
X6742 x(includes)s 7599 x(a)s 7765 x(vast)s 8210 x(number)s 9001 x(of)s
X9260 x(symbols:)s 
X/Helvetica 220 fnt
X1897 4512 moveto(Omega delta int partial club)s 
X/Symbol 240 fnt
X5866 4509 moveto(\127)s 6050 x(\144)s gsave
X6168 4569 translate
X-180.0000 rotate
Xgsave
X0 -159 translate
X180.0000 rotate
X
X/Symbol 312 fnt
X0 -285 moveto(\362)s
X
Xgrestore
X
Xgrestore
X
X/Symbol 312 fnt
X6168 4443 moveto(\362)s 
X/Symbol 240 fnt
X6253 4509 moveto(\266)s 6371 x(\247)s 
X/Times-Roman 240 fnt
X1417 3960 moveto(The)s 1849 x(summary)s
X2799 x(at)s 3031 x(the)s 3383 x(end)s 3789 x(of)s 4048 x(this)s
X4453 x(report)s 5083 x(has)s 5462 x(the)s 5814 x(complete)s 6750 x(list.)s
X1897 3586 moveto(Symbols)s 2813 x(whose)s 3503 x(names)s 4192 x(are)s 4561 x(made)s
X5157 x(from)s 5699 x(letters)s 6359 x(should)s 7076 x(be)s 7380 x(separated)s
X8360 x(from)s 8902 x(each)s 9418 x(other)s 9987 x(by)s 10305 x(at)s
X1417 3298 moveto(least)s 1914 x(one)s 2320 x(space)s 2911 x(or)s 3170 x(end)s
X3576 x(of)s 3835 x(line,)s 4313 x(as)s 4572 x(was)s 5004 x(done)s
X5530 x(above,)s 6222 x(or)s 6481 x(else)s 6912 x(Eq)s 7238 x(will)s
X7669 x(become)s 8473 x(confused:)s 
X/Helvetica 220 fnt
X1897 2791 moveto(Omegadelta)s 
X/Times-Italic 240 fnt
X5866 2795 moveto(Omegadelta)s 
X/Times-Roman 240 fnt
X1417 2292 moveto(Symbols)s
X2327 x(whose)s 3011 x(names)s 3694 x(are)s 4057 x(made)s 4647 x(from)s
X5183 x(digits)s 5786 x(and)s 6204 x(punctuation)s 7406 x(characters)s 8445 x(can,)s
X8909 x(however,)s 9865 x(be)s 10163 x(run)s gsave
X1417 1752 translate
X680 0 0 0 240 288 60 loutgr
Xgsave
X0 0 moveto xsize 0 lineto stroke
Xgrestore
X
Xgrestore
X
X/Times-Roman 153 fnt
X1417 1536 moveto(1)s 
X/Times-Roman 192 fnt
X1493 1458 moveto(PostScript)s
X2326 x(is)s 2501 x(a)s 2634 x(trademark)s 3457 x(of)s 3664 x(Adobe)s
X4223 x(Systems,)s 4956 x(Incorporated.)s 
Xpgsave restore
Xshowpage
X
X%%Page: ? 3
X%%BeginPageSetup
X0.0500 dup scale 10 setlinewidth
X/pgsave save def
X%%EndPageSetup
X
X/Times-Roman 240 fnt
X5754 15261 moveto(-)s 5893 x(2)s 6073 x(-)s 1417 14674 moveto(together)s 2260 x(with)s
X2745 x(each)s 3243 x(other)s 3794 x(and)s 4200 x(with)s 4685 x(symbols)s
X5543 x(made)s 6121 x(from)s 6645 x(letters:)s 
X/Helvetica 220 fnt
X1897 14160 moveto(Omega-delta<=2)s 
X/Symbol 240 fnt
X5866 14157 moveto(\127)s
X6107 x(-)s 6295 x(\144)s 6485 x(\243)s 6688 x(\062)s 
X/Times-Roman 240 fnt
X1417 13661 moveto(This)s
X1902 x(rule)s 2333 x(applies)s 3070 x(throughout)s 4181 x(the)s 4533 x(Lout)s
X5045 x(world.)s 1897 13287 moveto(Some)s 2502 x(symbols)s 3360 x(join)s 3792 x(objects)s
X4529 x(together)s 5372 x(in)s 5618 x(mathematical)s 6964 x(ways:)s 
X/Helvetica 220 fnt
X1897 12788 moveto(x sub 2)s
X
X/Times-Italic 240 fnt
X5866 12792 moveto(x)s 
X/Symbol 168 fnt
X5972 12707 moveto(\062)s 
X/Times-Roman 240 fnt
X1417 12257 moveto(Here)s 1930 x(the)s 
X/Helvetica 220 fnt
X2271 12253 moveto(sub)s
X
X/Times-Roman 240 fnt
X2674 12257 moveto(symbol)s 3428 x(has)s 3796 x(taken)s 4363 x(the)s 4704 x(object)s
X5337 x(just)s 5731 x(to)s 5966 x(its)s 6240 x(left,)s 6666 x(and)s
X7061 x(the)s 7402 x(object)s 8035 x(just)s 8429 x(to)s 8664 x(its)s
X8938 x(right,)s 9498 x(and)s 9893 x(joined)s 1417 11969 moveto(them)s 1972 x(into)s
X2421 x(one)s 2844 x(object)s 3505 x(in)s 3768 x(the)s 4137 x(form)s
X4678 x(of)s 4954 x(a)s 5137 x(subscript.)s 6197 x(The)s 6646 x(two)s
X7082 x(objects)s 7836 x(are)s 8204 x(called)s 8851 x(the)s 9220 x(left)s
X9614 x(and)s 10037 x(right)s 1417 11681 moveto(parameters)s 2524 x(of)s 
X/Helvetica 220 fnt
X2783 11677 moveto(sub)s
X
X/Times-Roman 240 fnt
X3137 11681 moveto(,)s 3257 x(and)s 3663 x(they)s 4135 x(may)s 4607 x(be)s
X4893 x(arbitrary)s 5774 x(Lout)s 6286 x(objects.)s 1897 11307 moveto(Other)s 2499 x(symbols)s
X3355 x(of)s 3612 x(a)s 3776 x(similar)s 4496 x(kind)s 4980 x(include)s
X
X/Helvetica 220 fnt
X5742 11303 moveto(sup)s 
X/Times-Roman 240 fnt
X6154 11307 moveto(for)s 6490 x(superscripting,)s 
X/Helvetica 220 fnt
X7962 11303 moveto(over)s 
X/Times-Roman 240 fnt
X8447 11307 moveto(for)s
X8783 x(built-up)s 9598 x(fractions,)s 1417 11019 moveto(and)s 
X/Helvetica 220 fnt
X1831 11015 moveto(from)s 
X/Times-Roman 240 fnt
X2338 11019 moveto(and)s
X
X/Helvetica 220 fnt
X2752 11015 moveto(to)s 
X/Times-Roman 240 fnt
X3003 11019 moveto(for)s 3349 x(the)s 3709 x(lower)s 4321 x(and)s
X4735 x(upper)s 5348 x(limits)s 5959 x(of)s 6226 x(sums,)s 6846 x(products,)s
X7798 x(etc.)s 8264 x(These)s 8903 x(symbols)s 9769 x(may)s 10249 x(be)s
X1417 10731 moveto(used)s 1916 x(together)s 2759 x(to)s 3005 x(produce)s 3836 x(complicated)s
X5064 x(equations)s 6041 x(with)s 6526 x(astonishing)s 7676 x(ease:)s 
X/Helvetica 220 fnt
X1897 10231 moveto(big sum from i=0 to n r sup i)s
X1897 9943 moveto(= {r sup n+1 - 1} over r-1)s 
X/Times-Italic 168 fnt
X5943 10317 moveto(n)s 
X/Symbol 312 fnt
X5874 10038 moveto(\345)s 
X/Times-Italic 168 fnt
X5866 9852 moveto(i)s 
X/Symbol 168 fnt
X5920 9847 moveto(\075)s
X6020 x(\060)s 
X/Times-Italic 168 fnt
X6197 10175 moveto(i)s 
X/Times-Italic 240 fnt
X6104 10063 moveto(r)s 
X/Symbol 240 fnt
X6315 10056 moveto(\075)s 
X/Times-Italic 168 fnt
X6611 10283 moveto(n)s
X
X/Symbol 168 fnt
X6701 10278 moveto(+)s 6799 x(\061)s 
X/Times-Italic 240 fnt
X6518 10171 moveto(r)s 
X/Symbol 240 fnt
X6940 10164 moveto(-)s 7128 x(\061)s
Xgsave
X6518 10116 translate
X730 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Times-Italic 240 fnt
X6654 9914 moveto(r)s 
X/Symbol 240 fnt
X6804 9907 moveto(-)s 6992 x(\061)s 
X/Times-Roman 240 fnt
X1417 9384 moveto(Here)s 
X/Helvetica 220 fnt
X1937 9380 moveto(sum)s
X
X/Times-Roman 240 fnt
X2408 9384 moveto(is)s 2623 x(just)s 3024 x(the)s 
X/Symbol 240 fnt
X3372 9377 moveto(\345)s 
X/Times-Roman 240 fnt
X3599 9384 moveto(symbol;)s
X
X/Helvetica 220 fnt
X4426 9380 moveto(from)s 
X/Times-Roman 240 fnt
X4921 9384 moveto(and)s 
X/Helvetica 220 fnt
X5323 9380 moveto(to)s 
X/Times-Roman 240 fnt
X5562 9384 moveto(do)s 5858 x(all)s
X6152 x(the)s 6500 x(work)s 7048 x(of)s 7303 x(placing)s 8063 x(the)s
X8411 x(limits.)s 9130 x(They)s 9678 x(are)s 10025 x(quite)s 1417 9096 moveto(independent,)s
X2718 x(so)s 3002 x(either)s 3616 x(or)s 3886 x(both)s 4383 x(may)s
X4866 x(be)s 5163 x(omitted.)s 6084 x(To)s 6421 x(get)s 6784 x(a)s
X6961 x(superscript)s 8080 x(directly)s 8880 x(over)s 9376 x(a)s 9553 x(subscript,)s
X1417 8808 moveto(use)s 1796 x(the)s 
X/Helvetica 220 fnt
X2148 8804 moveto(supp)s 
X/Times-Roman 240 fnt
X2684 8808 moveto(and)s 
X/Helvetica 220 fnt
X3090 8804 moveto(on)s
X
X/Times-Roman 240 fnt
X3394 8808 moveto(symbols:)s 
X/Helvetica 220 fnt
X1897 8231 moveto(A supp 2 on 1)s 
X/Times-Italic 240 fnt
X5866 8235 moveto(A)s 
X/Symbol 168 fnt
X6012 8353 moveto(\062)s 6012 8150 moveto(\061)s
X
X/Times-Roman 240 fnt
X1417 7700 moveto(These)s 2048 x(two)s 2467 x(symbols)s 3325 x(should)s 4024 x(always)s
X4748 x(be)s 5034 x(used)s 5533 x(together)s 6376 x(as)s 6635 x(shown.)s
X1897 7326 moveto(As)s 2230 x(usual)s 2802 x(in)s 3055 x(Lout,)s 3634 x(braces)s
X4311 x(are)s 4669 x(used)s 5175 x(to)s 5428 x(group)s 6054 x(something)s
X7118 x(into)s 7557 x(an)s 7850 x(indivisible)s 8926 x(object.)s 9697 x(Leaving)s
X1417 7038 moveto(them)s 1955 x(out)s 2321 x(creates)s 3043 x(ambiguities:)s 
X/Helvetica 220 fnt
X1897 6539 moveto(a  sup  b  over  c)s
X
X/Times-Roman 240 fnt
X1417 6041 moveto(There)s 2034 x(are)s 2385 x(two)s 2804 x(possible)s 3648 x(interpretations)s
X5087 x(for)s 5425 x(this:)s 
X/Helvetica 220 fnt
X1897 5367 moveto({a  sup  b}  over  c)s 
X/Times-Italic 168 fnt
X5986 5587 moveto(b)s 
X/Times-Italic 240 fnt
X5866 5475 moveto(a)s
Xgsave
X5866 5424 translate
X204 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Times-Italic 240 fnt
X5915 5270 moveto(c)s 
X/Helvetica 220 fnt
X1897 4664 moveto(a  sup  {b  over  c})s 
X/Times-Italic 168 fnt
X5986 4865 moveto(b)s gsave
X5986 4830 translate
X84 0 0 0 168 33 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Times-Italic 168 fnt
X5991 4723 moveto(c)s 
X/Times-Italic 240 fnt
X5866 4668 moveto(a)s
X
X/Times-Roman 240 fnt
X1417 4166 moveto(Eq)s 1746 x(chooses)s 2567 x(between)s 3427 x(them)s 3968 x(in)s
X4217 x(the)s 4572 x(following)s 5565 x(way.)s 6147 x(Every)s 6781 x(symbol)s
X7549 x(that)s 7970 x(takes)s 8524 x(a)s 8693 x(parameter)s 9710 x(also)s
X10158 x(has)s 1417 3878 moveto(a)s 
X/Times-Italic 240 fnt
X1574 x(precedence)s 
X/Times-Roman 240 fnt
X2663 x(,)s 2774 x(which)s
X3410 x(is)s 3620 x(a)s 3777 x(number.)s 4679 x(For)s 5062 x(example,)s
X
X/Helvetica 220 fnt
X5983 3874 moveto(sup)s 
X/Times-Roman 240 fnt
X6388 3878 moveto(has)s 6758 x(precedence)s 7884 x(60)s 8175 x(and)s
X
X/Helvetica 220 fnt
X8572 3874 moveto(over)s 
X/Times-Roman 240 fnt
X9050 3878 moveto(has)s 9420 x(precedence)s 1417 3590 moveto(54.)s 1823 x(The)s
X2241 x(symbol)s 2992 x(with)s 3463 x(the)s 3801 x(highest)s 4538 x(precedence)s
X5659 x(wins)s 6157 x(the)s 6495 x(object)s 7125 x(lying)s 7663 x(between)s
X8506 x(them,)s 9090 x(so)s 9349 x(in)s 9581 x(the)s 9919 x(above)s
X1417 3302 moveto(case)s 1875 x(the)s 2214 x(\256rst)s 2632 x(interpretation)s 3965 x(is)s
X4171 x(chosen.)s 5003 x(If)s 5208 x(two)s 5614 x(symbols)s 6459 x(of)s
X6705 x(equal)s 7270 x(precedence)s 8392 x(compete)s 9249 x(for)s 9574 x(an)s
X9847 x(object,)s 1417 3014 moveto(the)s 1769 x(association)s 2891 x(is)s 3110 x(towards)s
X3927 x(the)s 4279 x(left:)s 
X/Helvetica 220 fnt
X1897 2492 moveto(a sup b sub 2)s 
X/Times-Italic 168 fnt
X5986 2608 moveto(b)s 
X/Times-Italic 240 fnt
X5866 2496 moveto(a)s
X
X/Symbol 168 fnt
X6070 2411 moveto(\062)s 
X/Times-Roman 240 fnt
X1417 1961 moveto(In)s 1676 x(this)s 2081 x(case)s 2552 x(it)s
X2744 x(is)s 2963 x(more)s 3514 x(probable)s 4411 x(that)s 4829 x(the)s
X5181 x(following)s 6171 x(right)s 6682 x(association)s 7804 x(was)s 8236 x(actually)s
X9052 x(wanted:)s 
Xpgsave restore
Xshowpage
X
X%%Page: ? 4
X%%BeginPageSetup
X0.0500 dup scale 10 setlinewidth
X/pgsave save def
X%%EndPageSetup
X
X/Times-Roman 240 fnt
X5754 15261 moveto(-)s 5893 x(3)s 6073 x(-)s 
X/Helvetica 220 fnt
X1897 14602 moveto(a sup { b sub 2 })s 
X/Times-Italic 168 fnt
X5986 14718 moveto(b)s
X
X/Symbol 117 fnt
X6070 14659 moveto(\062)s 
X/Times-Italic 240 fnt
X5866 14606 moveto(a)s 
X/Times-Roman 240 fnt
X1897 13839 moveto(White)s 2549 x(space)s 3148 x(between)s
X4013 x(two)s 4440 x(objects)s 5185 x(is)s 5412 x(considered)s 6516 x(to)s
X6770 x(be)s 7064 x(a)s 7238 x(symbol)s 8011 x(with)s 8504 x(precedence)s
X9647 x(7,)s 9895 x(which)s 1417 13551 moveto(is)s 1636 x(lower)s 2240 x(than)s
X2712 x(the)s 3064 x(precedence)s 4199 x(of)s 4458 x(any)s 4864 x(Eq)s
X5190 x(symbol;)s 6021 x(but)s 6387 x(if)s 6592 x(the)s 6944 x(two)s
X7363 x(objects)s 8100 x(are)s 8451 x(immediately)s 9705 x(adjacent)s 1417 13263 moveto(the)s
X1774 x(precedence)s 2914 x(is)s 3138 x(102,)s 3623 x(which)s 4273 x(is)s
X4497 x(higher)s 5173 x(than)s 5650 x(the)s 6007 x(precedence)s 7147 x(of)s
X7411 x(any)s 7822 x(Eq)s 8153 x(symbol.)s 9043 x(Compare)s 9985 x(these)s
X1417 12975 moveto(three)s 1954 x(examples:)s 
X/Helvetica 220 fnt
X1897 12303 moveto(big sum from i=0 to n)s 
X/Times-Italic 168 fnt
X5943 12561 moveto(n)s 
X/Symbol 312 fnt
X5874 12282 moveto(\345)s
X
X/Times-Italic 168 fnt
X5866 12096 moveto(i)s 
X/Symbol 168 fnt
X5920 12091 moveto(\075)s 6020 x(\060)s 
X/Helvetica 220 fnt
X1897 11469 moveto(big sum from {i = 0} to n)s 
X/Times-Italic 168 fnt
X5943 11727 moveto(n)s
X
X/Symbol 312 fnt
X5874 11448 moveto(\345)s 
X/Times-Italic 168 fnt
X5866 11262 moveto(i)s 
X/Symbol 168 fnt
X5920 11257 moveto(\075)s 6020 x(\060)s 
X/Helvetica 220 fnt
X1897 10687 moveto(big sum from i = 0 to n)s
X
X/Symbol 312 fnt
X5866 10666 moveto(\345)s 
X/Times-Italic 168 fnt
X5954 10480 moveto(i)s 
X/Symbol 240 fnt
X6160 10684 moveto(\075)s 
X/Times-Italic 168 fnt
X6381 10893 moveto(n)s 
X/Symbol 240 fnt
X6363 10684 moveto(\060)s
X
X/Times-Roman 240 fnt
X1417 10028 moveto(and)s 1824 x(you)s 2245 x(will)s 2677 x(see)s 3043 x(that)s
X3462 x(some)s 4028 x(care)s 4486 x(is)s 4706 x(needed)s 5445 x(on)s
X5746 x(this)s 6152 x(point.)s 6825 x(Braces)s 7536 x(can)s 7929 x(always)s
X8654 x(be)s 8941 x(used)s 9441 x(to)s 9688 x(override)s 1417 9740 moveto(precedence)s
X2554 x(and)s 2962 x(associativity,)s 4278 x(and)s 4686 x(when)s 5267 x(in)s
X5515 x(doubt)s 6123 x(the)s 6477 x(easiest)s 7175 x(course)s 7861 x(is)s
X8082 x(to)s 8330 x(insert)s 8922 x(them.)s 9582 x(Although)s 1417 9452 moveto(Lout)s
X1980 x(allows)s 2715 x(symbols)s 3624 x(to)s 3921 x(as)s 4120 x(so)s
X4333 x(ciate)s 4894 x(towards)s 5762 x(the)s 6165 x(left)s 6593 x(or)s
X6903 x(right,)s 7525 x(Eq)s 7902 x(chooses)s 8771 x(to)s 9068 x(have)s
X9631 x(only)s 10168 x(left)s 1417 9164 moveto(associative)s 2559 x(symbols.)s 3571 x(The)s
X4037 x(summary)s 5021 x(at)s 5287 x(the)s 5673 x(end)s 6113 x(of)s
X6406 x(this)s 6845 x(report)s 7509 x(gives)s 8108 x(the)s 8494 x(precedence)s
X9663 x(of)s 9956 x(every)s 1417 8876 moveto(symbol.)s 1897 8502 moveto(The)s 
X/Times-Italic 240 fnt
X2329 x(matrix)s
X
X/Times-Roman 240 fnt
X3013 x(symbol)s 3778 x(builds)s 4423 x(an)s 4709 x(array)s 5259 x(of)s
X5518 x(objects:)s 
X/Helvetica 220 fnt
X1897 8003 moveto(matrix)s 1897 7715 moveto(   atleft { blpar })s 1897 7427 moveto(   atright { brpar })s 1897 7139 moveto({ x sup 2 above x above 1)s
X1897 6851 moveto(  nextcol)s 1897 6563 moveto(  y sup 2 above y above 1)s 1897 6275 moveto(  nextcol)s 1897 5987 moveto(  z sup 2 above z above 1)s 1897 5699 moveto(})s
Xgsave
X5866 7691 translate
X-180.0000 rotate
Xgsave
X0 -471 translate
X180.0000 rotate
Xgsave
X0 -518 translate
X1.0000 1.1416 scale
X
X/Symbol 240 fnt
X0 232 moveto(\346)s 0 -60 moveto(\347)s 0 -302 moveto(\350)s 
Xgrestore
X
X/Symbol 168 fnt
X241 -172 moveto(\062)s 
X/Times-Italic 240 fnt
X135 -279 moveto(x)s
X194 -555 moveto(x)s 
X/Symbol 240 fnt
X187 -886 moveto(\061)s 
X/Symbol 168 fnt
X623 -172 moveto(\062)s 
X/Times-Italic 240 fnt
X517 -279 moveto(y)s 576 -555 moveto(y)s
X
X/Symbol 240 fnt
X569 -886 moveto(\061)s 
X/Symbol 168 fnt
X992 -172 moveto(\062)s 
X/Times-Italic 240 fnt
X899 -279 moveto(z)s 955 -555 moveto(z)s 
X/Symbol 240 fnt
X941 -886 moveto(\061)s
Xgsave
X0 -518 translate
X1.0000 1.1416 scale
X
X/Symbol 240 fnt
X1119 232 moveto(\366)s 1119 -60 moveto(\367)s 1119 -302 moveto(\370)s 
Xgrestore
X
Xgrestore
X
Xgrestore
Xgsave
X0 7645 translate
X1.0000 1.1416 scale
X
X/Symbol 240 fnt
X5866 232 moveto(\346)s 5866 -60 moveto(\347)s
X5866 -302 moveto(\350)s 
Xgrestore
X
X/Symbol 168 fnt
X6107 7991 moveto(\062)s 
X/Times-Italic 240 fnt
X6001 7884 moveto(x)s 6060 7608 moveto(x)s 
X/Symbol 240 fnt
X6053 7277 moveto(\061)s
X
X/Symbol 168 fnt
X6489 7991 moveto(\062)s 
X/Times-Italic 240 fnt
X6383 7884 moveto(y)s 6442 7608 moveto(y)s 
X/Symbol 240 fnt
X6435 7277 moveto(\061)s 
X/Symbol 168 fnt
X6858 7991 moveto(\062)s
X
X/Times-Italic 240 fnt
X6765 7884 moveto(z)s 6821 7608 moveto(z)s 
X/Symbol 240 fnt
X6807 7277 moveto(\061)s gsave
X0 7645 translate
X1.0000 1.1416 scale
X
X/Symbol 240 fnt
X6985 232 moveto(\366)s 6985 -60 moveto(\367)s
X6985 -302 moveto(\370)s 
Xgrestore
X
X/Times-Roman 240 fnt
X1417 5202 moveto(The)s 
X/Helvetica 220 fnt
X1876 5198 moveto(atleft)s 
X/Times-Roman 240 fnt
X2438 5202 moveto(and)s 
X/Helvetica 220 fnt
X2871 5198 moveto(atright)s
X
X/Times-Roman 240 fnt
X3567 5202 moveto(options)s 4359 x(place)s 4950 x(vertically)s 5938 x(scaled)s 6622 x(versions)s
X7506 x(of)s 7792 x(their)s 8316 x(values)s 9014 x(at)s 9273 x(each)s
X9798 x(side;)s 10336 x(if)s 1417 4914 moveto(either)s 2034 x(is)s 2267 x(omitted)s
X3071 x(the)s 3437 x(value)s 4029 x(is)s 4262 x(taken)s 4854 x(to)s
X5114 x(be)s 5414 x(an)s 5714 x(empty)s 6386 x(object)s 7044 x(of)s
X7317 x(zero)s 7802 x(width)s 8421 x(by)s 8735 x(default.)s 9592 x(The)s
X10038 x(right)s 1417 4626 moveto(parameter)s 2421 x(of)s 
X/Helvetica 220 fnt
X2670 4622 moveto(matrix)s 
X/Times-Roman 240 fnt
X3317 4626 moveto(is)s
X3526 x(the)s 3868 x(array)s 4408 x(itself.)s 5054 x(It)s 5249 x(is)s
X5458 x(a)s 5614 x(sequence)s 6541 x(of)s 6790 x(columns)s 7651 x(separated)s
X8603 x(by)s 
X/Helvetica 220 fnt
X8893 4622 moveto(nextcol)s 
X/Times-Roman 240 fnt
X9638 4626 moveto(symbols;)s 1417 4338 moveto(each)s 1915 x(column)s
X2693 x(is)s 2912 x(a)s 3078 x(sequence)s 4015 x(of)s 4274 x(objects)s
X5011 x(separated)s 5973 x(by)s 
X/Helvetica 220 fnt
X6273 4334 moveto(above)s 
X/Times-Roman 240 fnt
X6931 4338 moveto(symbols.)s 1897 3964 moveto(The)s
X
X/Helvetica 220 fnt
X2310 3960 moveto(nextcol)s 
X/Times-Roman 240 fnt
X3046 3964 moveto(and)s 
X/Helvetica 220 fnt
X3433 3960 moveto(above)s 
X/Times-Roman 240 fnt
X4072 3964 moveto(symbols)s 4911 x(have)s
X5404 x(low)s 5804 x(precedence,)s 6980 x(but)s 7327 x(not)s 7674 x(as)s
X7914 x(low)s 8314 x(as)s 8554 x(white)s 9126 x(space)s 9698 x(between)s
X1417 3676 moveto(two)s 1826 x(objects.)s 2673 x(Therefore,)s 3724 x(unless)s 4372 x(the)s
X4714 x(entries)s 5400 x(in)s 5636 x(the)s 5978 x(array)s 6518 x(are)s
X6859 x(very)s 7334 x(simple,)s 8081 x(it)s 8263 x(is)s 8472 x(safest)s
X9065 x(to)s 9301 x(enclose)s 10068 x(each)s 1417 3388 moveto(of)s 1676 x(them)s
X2214 x(in)s 2460 x(braces.)s 1897 3014 moveto(Columns)s 2856 x(built)s 3388 x(with)s
X3907 x(the)s 
X/Helvetica 220 fnt
X4293 3010 moveto(above)s 
X/Times-Roman 240 fnt
X4985 3014 moveto(symbol)s 5784 x(have)s 6330 x(their)s
X6861 x(objects)s 7632 x(centred)s 8429 x(in)s 8709 x(the)s 9095 x(column.)s
X10027 x(Also)s 1417 2726 moveto(available)s 2343 x(are)s 
X/Helvetica 220 fnt
X2698 2722 moveto(labove)s 
X/Times-Roman 240 fnt
X3408 2726 moveto(for)s
X3750 x(left-justi\256ed)s 4980 x(columns,)s 
X/Helvetica 220 fnt
X5915 2722 moveto(cabove)s 
X/Times-Roman 240 fnt
X6687 2726 moveto(meaning)s 7575 x(the)s
X7931 x(same)s 8486 x(as)s 
X/Helvetica 220 fnt
X8749 2722 moveto(above)s 
X/Times-Roman 240 fnt
X9347 2726 moveto(,)s 
X/Helvetica 220 fnt
X9471 2722 moveto(rabove)s
X
X/Times-Roman 240 fnt
X10206 2726 moveto(for)s 1417 2438 moveto(right-justi\256ed)s 2785 x(columns,)s 3724 x(and)s 
X/Helvetica 220 fnt
X4138 2434 moveto(mabove)s
X
X/Times-Roman 240 fnt
X4987 2438 moveto(for)s 5333 x(alignment)s 6357 x(along)s 6957 x(column)s 7743 x(marks.)s
X8515 x(Each)s 9061 x(column)s 9847 x(should)s 1417 2150 moveto(contain)s 2182 x(only)s
X2669 x(one)s 3076 x(kind)s 3563 x(of)s 
X/Helvetica 220 fnt
X3823 2146 moveto(above)s 
X/Times-Roman 240 fnt
X4482 2150 moveto(symbol)s
X5248 x(\(although)s 6226 x(adventurous)s 7457 x(users)s 8009 x(might)s 8628 x(be)s
X8915 x(able)s 9374 x(to)s 9621 x(get)s 9974 x(some)s 1417 1862 moveto(mixtures)s
X2313 x(to)s 2559 x(work\),)s 3250 x(but)s 3616 x(different)s 4497 x(columns)s
X5368 x(may)s 5840 x(differ.)s 6549 x(For)s 6941 x(example,)s 
Xpgsave restore
Xshowpage
X
X%%Page: ? 5
X%%BeginPageSetup
X0.0500 dup scale 10 setlinewidth
X/pgsave save def
X%%EndPageSetup
X
X/Times-Roman 240 fnt
X5754 15261 moveto(-)s 5893 x(4)s 6073 x(-)s 
X/Helvetica 220 fnt
X1897 14674 moveto(@R "Chain rule:"  labove  @R "Product rule:")s 1897 14386 moveto(nextcol)s
X1897 14098 moveto({df over dx ^= df over dy cdot dy over dx})s 1897 13810 moveto(mabove)s 1897 13522 moveto({dfg over dy ^= f ` dg over dx + g df over dx})s 
X/Times-Roman 240 fnt
X1417 13023 moveto(has)s 1796 x(result)s
X1897 12418 moveto(Chain rule:)s 1897 11776 moveto(Product rule:)s 
X/Times-Italic 240 fnt
X3430 12569 moveto(df)s gsave
X3410 12471 translate
X226 0 0 0 240 288 0 loutgr
Xgsave
X0 0 moveto xsize 0 lineto 0.05 ft setlinewidth stroke
Xgrestore
X
Xgrestore
X
X/Times-Italic 240 fnt
X3410 12260 moveto(dx)s 
END_OF_FILE
  if test 54341 -ne `wc -c <'lout/doc/tr.eq/outfile.ps.A'`; then
    echo shar: \"'lout/doc/tr.eq/outfile.ps.A'\" unpacked with wrong size!
  elif test -f 'lout/doc/tr.eq/outfile.ps.B' && test -f 'lout/doc/tr.eq/outfile.ps.C'; then
    echo shar: Combining  \"'lout/doc/tr.eq/outfile.ps'\" \(157394 characters\)
    cat 'lout/doc/tr.eq/outfile.ps.A' 'lout/doc/tr.eq/outfile.ps.B' 'lout/doc/tr.eq/outfile.ps.C' > 'lout/doc/tr.eq/outfile.ps'
    if test 157394 -ne `wc -c <'lout/doc/tr.eq/outfile.ps'`; then
      echo shar: \"'lout/doc/tr.eq/outfile.ps'\" combined with wrong size!
    else
      rm lout/doc/tr.eq/outfile.ps.A lout/doc/tr.eq/outfile.ps.B 
      rm lout/doc/tr.eq/outfile.ps.C
    fi
  fi
  # end of 'lout/doc/tr.eq/outfile.ps.A'
fi
if test -f 'lout/doc/tr.impl/s5.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s5.0'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s5.0'\" \(476 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s5.0' <<'END_OF_FILE'
X@Section
X    @Title { Galleys }
X@Begin
X@PP
XWith objects and definitions under control, the author faced the problem
Xof getting body text, footnotes, floating figures and tables,
Xreferences, index entries, and entries in the table of contents into
Xtheir places.  The resulting investigation occupied three months of
Xfull-time design work, and proceeded approximately as described in
XSection {@NumberOf galleys}; the implementation occupied the years 1987-89.
X@BeginSubSections
END_OF_FILE
  if test 476 -ne `wc -c <'lout/doc/tr.impl/s5.0'`; then
    echo shar: \"'lout/doc/tr.impl/s5.0'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s5.0'
fi
if test -f 'lout/z10.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z10.c'\"
else
  echo shar: Extracting \"'lout/z10.c'\" \(24737 characters\)
  sed "s/^X//" >'lout/z10.c' <<'END_OF_FILE'
X/*@z10.c:Cross References:CrossExpand(), CrossSequence()@*********************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z10.c                                                      */
X/*  MODULE:       Cross References                                           */
X/*  EXTERNS:      CrossInit(), CrossMake(), GallTargEval(), CrossExpand(),   */
X/*                CrossSequence(), CrossClose()                              */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define	CROSS_LIT	CROSS_TARG
X#define	NO_TARGET	0
X#define	SEEN_TARGET	1
X#define	WRITTEN_TARGET	2
X
Xstatic OBJECT RootCross = nil;			/* header for all crs        */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  CrossInit(sym)                                                           */
X/*                                                                           */
X/*  Initialize cross_sym(sym).                                               */
X/*                                                                           */
X/*****************************************************************************/
X
XCrossInit(sym)
XOBJECT sym;
X{ OBJECT cs;  int i;
X  cs = New(CROSS_SYM);
X  target_state(cs)  = NO_TARGET;
X  target_seq(cs)    = 0;
X  cr_file(cs)       = NO_FILE;
X  gall_seq(cs)      = 0;
X  gall_tag(cs)      = nil;
X  gall_tfile(cs)    = NO_FILE;
X  gentag_file(cs)   = NO_FILE;
X  symb(cs)          = sym;
X  cross_sym(sym)    = cs;
X  gentag_fseq(cs)   = NewWord(MAX_FILES, no_fpos);
X  for( i = 0;  i < MAX_FILES;  i++ ) string(gentag_fseq(cs))[i] = 0;
X  if( RootCross == nil )  RootCross = New(CR_ROOT);
X  Link(RootCross, cs);
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT CrossGenTag(x)                                                    */
X/*                                                                           */
X/*  Generate a tag suitable for labelling closure x, in such a way that      */
X/*  the same tag is likely to be generated on subsequent runs.               */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT CrossGenTag(x)
XOBJECT x;
X{ unsigned char buff[MAX_LINE], *str1, *str2;
X  OBJECT sym, cs, gt, res;  FILE_NUM fnum;
X  unsigned char *sgt;
X  int seq;
X  debug1(DCR, D, "CrossGenTag( %s )", SymName(actual(x)));
X  sym = actual(x);
X  if( cross_sym(sym) == nil )  CrossInit(sym);
X  cs = cross_sym(sym);
X  fnum = file_num(fpos(x));
X  /* ***
X  if( fnum != gentag_file(cs) )
X  { gentag_file(cs) = fnum;
X    gentag_seq(cs)  = 0;
X  }
X  *** */
X  str1 = FullSymName(sym, ".");
X  str2 = FileName(fnum);
X  gt = gentag_fseq(cs);
X  sgt = string(gt);
X  seq = ++(sgt[fnum]);
X  if( strlen(str1) + strlen(str2) + 10 >= MAX_LINE )
X    Error(FATAL,no_fpos, "automatically generated tag \"%s.%s.%d\" is too long",
X	str1, str2, seq);
X  sprintf(buff, "\"%s.%s.%d\"", str1, str2, seq);
X  res = MakeWord(buff, &fpos(x));
X  debug1(DCR, DD, "CrossGenTag returning %s", string(res));
X  return res;
X} /* end CrossGenTag */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT CrossMake(sym, val, ctype)                                        */
X/*                                                                           */
X/*  Make a cross-reference with the given sym and tag value.                 */
X/*  NB The fpos fields are not set, so we cannot EchofilePos from this.      */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT CrossMake(sym, val, ctype)
XOBJECT sym, val;  int ctype;
X{ OBJECT v1, res;
X  debug3(DCR, DD, "CrossMake(%s, %s, %s)", SymName(sym),
X		EchoObject(null, val), Image(ctype));
X  res = New(CROSS);
X  cross_type(res) = ctype;  threaded(res) = FALSE;
X  v1 = New(CLOSURE);  actual(v1) = sym;
X  Link(res, v1);  Link(res, val);
X  debug1(DCR, DD, "CrossMake returning %s", EchoObject(null, res));
X  return res;
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT GallTargEval(sym, dfpos)                                          */
X/*                                                                           */
X/*  Produce a suitable cross-reference for a galley target.                  */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT GallTargEval(sym, dfpos)
XOBJECT sym; FILE_POS *dfpos;
X{ OBJECT cs, res;
X  unsigned char buff[MAX_LINE], *str;
X  debug2(DCR, DD, "GallTargEval( %s,%s )", SymName(sym), EchoFilePos(dfpos));
X  if( cross_sym(sym) == nil )  CrossInit(sym);
X  cs = cross_sym(sym);
X  if( file_num(*dfpos) != gall_tfile(cs) )
X  { gall_tfile(cs) = file_num(*dfpos);
X    gall_seq(cs)   = 0;
X  }
X  str = FileName(gall_tfile(cs));
X  if( strlen(str) + 6 >= MAX_LINE )
X    Error(FATAL, dfpos, "automatically generated tag %s&%d is too long",
X	str, ++gall_seq(cs));
X  sprintf(buff, "%s&%d", str, ++gall_seq(cs));
X  res = CrossMake(sym, MakeWord(buff, dfpos), GALL_TARG);
X  debug1(DCR, DD, "GallTargEval returning %s", EchoObject(null, res));
X  return res;
X} /* end GallTargEval */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT CrossExpand(x, env, style, crs_wanted, crs, res_env)              */
X/*                                                                           */
X/*  Return the value of cross-reference x, with environment *res_env.  If x  */
X/*  has a non-literal tag, it must be tracked, so an object is added to *crs */
X/*  for this purpose if crs_wanted.  Result replaces x, which is disposed.   */
X/*                                                                           */
X/*****************************************************************************/
Xstatic OBJECT nbt[2] = { nil, nil };
Xstatic OBJECT nft[2] = { nil, nil };
Xstatic OBJECT ntarget = nil;
X
XOBJECT CrossExpand(x, env, style, crs_wanted, crs, res_env)
XOBJECT x, env;  STYLE *style;  BOOLEAN crs_wanted; OBJECT *crs, *res_env;
X{ OBJECT sym, res, tag, y, cs, link, db, tmp, index;
X  int ctype;  unsigned char buff[MAX_LINE], seq[MAX_LINE], *str;
X  FILE_NUM fnum, dfnum;
X  long cont, dfpos;
X  assert( type(x) == CROSS, "CrossExpand: x!" );
X  debug2(DCR, DD, "CrossExpand( %s, %s )",
X	EchoObject(null, x), EchoObject(null, *crs));
X  assert( NextDown(Down(x)) == LastDown(x), "CrossExpand: #args!" );
X
X  /* manifest and tidy the right parameter */
X  Child(tag, LastDown(x));
X  tag = Manifest(tag, env, style, nbt, nft, &ntarget, crs, FALSE, FALSE);
X  tag = ReplaceWithTidy(tag);
X
X  /* extract sym (the symbol name) and tag (the tag value) from x */
X  Child(y, Down(x));
X  if( type(y) == CLOSURE )  sym = actual(y);
X  ctype = type(y) != CLOSURE ? 1 :
X	  type(tag) != WORD ? 2 :
X	  string(tag)[0] == '\0' ? 3 :
X	  strcmp(string(tag), KW_PRECEDING) == 0 ? CROSS_PREC :
X	  strcmp(string(tag), KW_FOLLOWING) == 0 ? CROSS_FOLL : CROSS_LIT;
X
X  res = nil;
X  switch( ctype )
X  {
X
X    case 1:
X
X      Error(WARN, &fpos(y), "left parameter of %s is not a symbol", KW_CROSS);
X      break;
X
X
X    case 2:
X
X      Error(WARN, &fpos(tag),
X	"value of right parameter of %s is not a simple word", KW_CROSS);
X      break;
X
X
X    case 3:
X    
X      Error(WARN, &fpos(tag),
X	"value of right parameter of %s is an empty word", KW_CROSS);
X      break;
X
X
X    case CROSS_LIT:
X    
X      if( cross_sym(sym) == nil )  CrossInit(sym);
X      cs = cross_sym(sym);
X      if( sym == MomentSym && strcmp(string(tag), KW_NOW) == 0 )
X      {	/* this is a request for the current time */
X	res = StartMoment();
X      }
X      else for( link = NextUp(Up(cs));  link != cs;  link = NextUp(link) )
X      {	Parent(db, link);
X	assert( type(db) == WORD, "CrossExpand: db!" );
X	if( DbRetrieve(db, FALSE, sym, string(tag), seq, &dfnum,&dfpos,&cont) )
X	{ res = ReadFromFile(dfnum, dfpos, sym);
X	  if( db != OldCrossDb )  AttachEnv(env, res);
X	  break;
X	}
X      }
X      break;
X
X
X    case CROSS_PREC:
X    case CROSS_FOLL:
X    
X      if( cross_sym(sym) == nil )  CrossInit(sym);
X      cs = cross_sym(sym);
X      assert( cs != nil, "CrossExpand/CROSS_FOLL: cs == nil!" );
X      assert( type(cs) == CROSS_SYM, "CrossExpand/CROSS_FOLL: type(cs)!" );
X      fnum = file_num(fpos(tag));
X      if( fnum != cr_file(cs) )
X      {	cr_file(cs) = fnum;
X	cr_seq(cs) = 0;
X      }
X      str = FileName(fnum);
X      if( strlen(str) + 5 >= MAX_LINE )
X	Error(FATAL, &fpos(x), "automatically generated tag %s_%d is too long",
X	  str, ++cr_seq(cs));
X      sprintf(buff, "%s_%d", str, ++cr_seq(cs));
X      tmp = CrossMake(sym, MakeWord(buff, &fpos(tag)), ctype);
X      index = New(ctype);
X      actual(index) = tmp;
X      Link(index, tmp);
X      if( crs_wanted )
X      {	if( *crs == nil )  *crs = New(CR_LIST);
X	link = Link(*crs, index);
X      }
X      else Error(FATAL, &fpos(x), "%s or %s tag not allowed here",
X	KW_PRECEDING, KW_FOLLOWING);
X      if( AllowCrossDb &&
X	  DbRetrieve(OldCrossDb, FALSE, sym, buff, seq, &dfnum, &dfpos,&cont) )
X	res = ReadFromFile(dfnum, dfpos, nil);
X      break;
X
X
X    default:
X    
X      Error(INTERN, no_fpos, "CrossExpand switch!");
X      break;
X
X
X  } /* end switch */
X  if( res == nil )
X  { OBJECT envt;
X    if( ctype > 1 )  Error(WARN, &fpos(x), "%s%s%s unknown",
X		SymName(sym), KW_CROSS, string(tag));
X
X    /* build dummy result with environment attached */
X    /* nb at present we are not adding dummy import closures to this! */
X    res = New(CLOSURE);  actual(res) = sym;
X    y = res;
X    debug1(DCR, DD, "First y = %s", SymName(actual(y)));
X    while( enclosing(actual(y)) != StartSym )
X    { tmp = New(CLOSURE);
X      actual(tmp) = enclosing(actual(y));
X      envt = SetEnv(tmp, nil);
X      AttachEnv(envt, y);
X      y = tmp;
X      debug1(DCR, DD, "Later y = %s", SymName(actual(y)));
X    }
X    envt = New(ENV);  Link(y, envt);
X  }
X
X  /* set environment, replace x by res, debug and exit */
X  *res_env = DetachEnv(res);
X  ReplaceNode(res, x);
X  DisposeObject(x);
X  debug1(DCR, DD, "CrossExpand returning %s", EchoObject(null, res));
X  debug1(DCR, DD, "  *crs = %s", EchoObject(null, *crs));
X  debug1(DCR, DD, "  *res_env = %s", EchoObject(null, *res_env));
X  return res;
X} /* end CrossExpand */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  CrossSequence(x)                                                         */
X/*                                                                           */
X/*  Object x is an insinuated cross-reference that has just been popped off  */
X/*  the top of the root galley.  Resolve it with the sequence of others.     */
X/*                                                                           */
X/*****************************************************************************/
X
XCrossSequence(x)
XOBJECT x;
X{ OBJECT sym, tag, val, tmp, cs, par, key, link, y;
X  unsigned ctype;  unsigned char buff[MAX_LINE], *str, *seq;
X  FILE_NUM dfnum;  int dfpos;
X
X  /* if suppressing cross-referencing, dispose x and quit */
X  if( !AllowCrossDb )
X  { if( Up(x) == x )  DisposeObject(x);
X    debug0(DCR, D, "CrossSequence returning (!AllowCrossDb).");
X    return;
X  }
X
X  /* get interesting fragments from x */
X  assert( type(x) == CROSS, "CrossSequence: type(x)!" );
X  ctype = cross_type(x);
X  Child(tmp, Down(x));
X  assert( type(tmp) == CLOSURE, "CrossSequence: type(tmp)!" );
X  sym = actual(tmp);
X  if( cross_sym(sym) == nil )  CrossInit(sym);
X  cs = cross_sym(sym);
X  assert( type(cs) == CROSS_SYM, "CrossSequence: cs!" );
X
X  /* debug output */
X  debug2(DCR, D, "CrossSequence %s %s", Image(ctype), SymName(sym));
X  debug1(DCR, DD, "  x = %s", EchoObject(null, x));
X  ifdebug(DCR, DD, EchoObject(stderr, cs));
X
X  /* delete as much of x as possible */
X  Child(tag, NextDown(Down(x)));
X  DeleteLink(NextDown(Down(x)));
X  if( Up(x) == x )  DisposeObject(x);
X
X  switch( ctype )
X  {
X    case GALL_FOLL:
X    case GALL_PREC:
X
X      /* find key of the galley, if any */
X      val = tag;  key = nil;
X      for( link = Down(val);  link != val;  link = NextDown(link) )
X      {	Child(par, link);
X	if( type(par) == PAR && (is_key(actual(par)) || is_tag(actual(par))) )
X	{ assert( Down(par) != par, "CrossSequence: PAR child!" );
X	  Child(key, Down(par));
X	  key = ReplaceWithTidy(key);
X	}
X      }
X
X      /* write out the galley */
X      str = FileName(file_num(fpos(val)));
X      if( strlen(str) + strlen(DATA_SUFFIX) >= MAX_LINE )
X	Error(FATAL, &fpos(val), "database file name %s%s is too long",
X		str, DATA_SUFFIX);
X      sprintf(buff, "%s%s", str, DATA_SUFFIX);
X      dfnum = FileNum(buff);
X      if( dfnum == NO_FILE )
X	dfnum = DefineFile(MakeWord(buff, &fpos(val)),
X				DATABASE_FILE, SOURCE_PATH);
X      AppendToFile(val, dfnum, &dfpos);
X
X      /* determine the sequence number or string of this galley */
X      if( key == nil )
X      {	sprintf(buff, "%.5d", ++gall_seq(cs));
X	seq = buff;
X      }
X      else if( type(key) != WORD )
X      {	Error(WARN, &fpos(key), "%s parameter is not a word", KW_KEY);
X	seq = (unsigned char *) "badkey";
X      }
X      else if(  string(key)[0] == '\0' )
X      {	Error(WARN, &fpos(key), "%s parameter is empty word", KW_KEY);
X	seq = (unsigned char *) "badkey";
X      }
X      else seq = string(key);
X
X      /* either write out the index immediately or store it for later */
X      if( ctype == GALL_PREC )
X      {	if( gall_tag(cs) == nil )
X	{ Error(WARN, &fpos(val), "no %s precedes this %s%s%s",
X		SymName(sym), SymName(sym), KW_CROSS, KW_PRECEDING);
X	  debug0(DCR, DD, "  ... so substituting \"none\"");
X	  gall_tag(cs) = MakeWord("none", &fpos(val));
X	}
X	assert( type(gall_tag(cs)) == WORD && string(gall_tag(cs))[0] != '\0',
X			"CrossSequence: gall_tag!" );
X	debug3(DCR, D, "  inserting galley (prec) %s&%s %s", SymName(sym),
X	  string(gall_tag(cs)), seq);
X	DbInsert(NewCrossDb, TRUE, sym, string(gall_tag(cs)), seq,
X			dfnum, (long) dfpos);
X      }
X      else
X      {	tmp = MakeWord(seq, &fpos(val));
X	gall_rec(tmp) = TRUE;
X	file_num(fpos(tmp)) = dfnum;
X	gall_pos(tmp) = dfpos;
X	Link(cs, tmp);
X	debug2(DCR, D, "  saving galley (foll) %s&? %s", SymName(sym), seq);
X      }
X      DisposeObject(val);
X      break;
X
X
X    case GALL_TARG:
X
X      if( gall_tag(cs) != nil )  DisposeObject(gall_tag(cs));
X      if( type(tag) != WORD || string(tag)[0] == '\0' )
X      {
X	debug2(DCR, DD, "  GALL_TARG %s put none for %s",
X	  SymName(sym), EchoObject(null, tag));
X	DisposeObject(tag);
X	gall_tag(cs) = MakeWord("none", no_fpos);
X      }
X      else gall_tag(cs) = tag;
X      debug2(DCR, D, "  have new %s gall_targ %s", SymName(sym),
X	  EchoObject(null, gall_tag(cs)));
X      for( link = Down(cs);  link != cs;  link = NextDown(link) )
X      {	Child(y, link);
X	assert( type(y) == WORD && string(y)[0] != '\0',
X				"CrossSequence: GALL_TARG y!" );
X	if( gall_rec(y) )
X	{
X	  debug3(DCR, D, "  inserting galley (foll) %s&%s %s", SymName(sym),
X	    string(gall_tag(cs)), string(y));
X	  DbInsert(NewCrossDb, TRUE, sym, string(gall_tag(cs)), string(y),
X			file_num(fpos(y)), (long) gall_pos(y));
X	  link = PrevDown(link);
X	  DisposeChild(NextDown(link));
X	}
X      }
X      break;
X
X
X    case CROSS_PREC:
X
X      if( target_state(cs) == NO_TARGET )
X      {	Error(WARN, &fpos(tag), "no invokation of %s precedes this %s%s%s",
X		SymName(sym), SymName(sym), KW_CROSS, KW_PRECEDING);
X	break;
X      }
X      if( target_state(cs) == SEEN_TARGET )
X      {
X	debug2(DCR, D, "  inserting %s cross_targ %s",
X	  SymName(sym), target_val(cs));
X	AppendToFile(target_val(cs), target_file(cs), &target_pos(cs));
X	DisposeObject(target_val(cs));
X	target_val(cs) = nil;
X	target_state(cs) = WRITTEN_TARGET;
X      }
X      if( type(tag) != WORD || string(tag)[0] == '\0' )
X      {
X	debug2(DCR, DD, "  GALL_TARG %s put none for %s", SymName(sym),
X		EchoObject(null, tag));
X	DisposeObject(tag);
X	tag = MakeWord("none", no_fpos);
X      }
X      debug3(DCR, D, "  inserting cross (prec) %s&%s %s", SymName(sym),
X	    string(tag), "0");
X      DbInsert(NewCrossDb, FALSE, sym, string(tag), "0", target_file(cs),
X			(long) target_pos(cs));
X      DisposeObject(tag);
X      break;
X
X
X    case CROSS_FOLL:
X
X      if( type(tag) != WORD )
X      {	Error(WARN, &fpos(tag), "tag of %s is not a simple word",
X		SymName(symb(cs)));
X	debug1(DCR, DD, "  tag = %s", EchoObject(null, tag));
X      }
X      else if( string(tag)[0] == '\0' )
X      {
X        debug1(DCR, D, "  ignoring cross (foll) %s (empty tag)", SymName(sym));
X      }
X      else
X      { Link(cs, tag);
X	gall_rec(tag) = FALSE;
X        debug3(DCR, D, "  storing cross (foll) %s&%s %s", SymName(sym),
X	    string(tag), "?");
X      }
X      break;
X
X
X    case CROSS_TARG:
X
X      /* get rid of old target, if any, and add new one */
X      if( target_state(cs) == SEEN_TARGET )
X      {
X	debug2(DCR, D, "  disposing unused %s cross_targ %s", SymName(sym),
X	  target_val(cs));
X	DisposeObject(target_val(cs));
X      }
X      debug2(DCR, D, "  remembering new %s cross_targ %s", SymName(sym),
X	EchoObject(null, tag));
X      target_val(cs) = tag;
X      assert( Up(tag) == tag, "CrossSeq: Up(tag)!" );
X      str = FileName(file_num(fpos(tag)));
X      if( strlen(str) + strlen(DATA_SUFFIX) >= MAX_LINE )
X	Error(FATAL, &fpos(tag), "database file name %s%s is too long",
X		str, DATA_SUFFIX);
X      sprintf(buff, "%s%s", str, DATA_SUFFIX);
X      target_file(cs) = FileNum(buff);
X      if( target_file(cs) == NO_FILE )
X	target_file(cs) = DefineFile(MakeWord(buff, &fpos(tag)),
X					DATABASE_FILE, SOURCE_PATH);
X      target_state(cs) = SEEN_TARGET;
X
X      /* store tag of the galley, if any */
X      tag = nil;
X      assert( type(target_val(cs)) == CLOSURE, "CrossSequence: target_val!" );
X      link = Down(target_val(cs));
X      for( ;  link != target_val(cs);  link = NextDown(link) )
X      {	Child(par, link);
X	if( type(par) == PAR && is_tag(actual(par)) )
X	{ assert( Down(par) != par, "CrossSequence: Down(PAR)!" );
X	  Child(tag, Down(par));
X	  tag = ReplaceWithTidy(tag);
X	  if( type(tag) != WORD )
X	  { Error(WARN, &fpos(tag), "%s tag is not a simple word",
X			SymName(actual(target_val(cs))));
X	    debug1(DCR, DD, "  tag = %s", EchoObject(null, tag));
X	  }
X	  else if( string(tag)[0] == '\0' )
X	  {
X            debug1(DCR, D, "  ignoring cross (own tag) %s (empty tag)",
X		SymName(sym));
X	  }
X	  else
X	  { Link(cs, tag);
X	    gall_rec(tag) = FALSE;
X            debug3(DCR, D, "  storing cross (own tag) %s&%s %s", SymName(sym),
X		string(tag), "?");
X	  }
X	  break;
X	}
X      }
X
X      /* if new target is already writable, write it */
X      if( Down(cs) != cs )
X      {
X	debug2(DCR, D, "  writing %s cross_targ %s", SymName(sym),
X		EchoObject(null, target_val(cs)));
X	AppendToFile(target_val(cs), target_file(cs), &target_pos(cs));
X	DisposeObject(target_val(cs));
X	for( link = Down(cs);  link != cs;  link = NextDown(link) )
X	{ Child(tag, link);
X	  assert( type(tag) == WORD && string(tag)[0] != '\0',
X			"CrossSeq: non-WORD or empty tag!" );
X	  if( !gall_rec(tag) )
X	  {
X	    debug3(DCR, D, "  inserting cross (foll) %s&%s %s", SymName(sym),
X	      string(tag), "0");
X	    DbInsert(NewCrossDb, FALSE, sym, string(tag),
X			"0", target_file(cs), (long) target_pos(cs));
X	    link = PrevDown(link);
X	    DisposeChild(NextDown(link));
X	  }
X	}
X	target_state(cs) = WRITTEN_TARGET;
X      }
X      break;
X
X
X    default:
X
X      Error(INTERN, &fpos(tag), "CrossSequence: ctype = %s", Image(ctype));
X      break;
X
X  } /* end switch */
X  debug0(DCR, D, "CrossSequence returning.");
X  debug0(DCR, DD, "   cs =");
X  ifdebug(DCR, DD, EchoObject(stderr, cs));
X} /* end CrossSequence */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  CrossClose()                                                             */
X/*                                                                           */
X/*  Check for dangling forward references, and convert old cross reference   */
X/*  database to new one.                                                     */
X/*                                                                           */
X/*****************************************************************************/
X
XCrossClose()
X{ OBJECT link, cs, ylink, y, sym;  BOOLEAN g;  int len, count;
X  FILE_NUM dfnum;  long dfpos, cont;
X  unsigned char buff[MAX_LINE], seq[MAX_LINE], tag[MAX_LINE];
X  debug0(DCR, D, "CrossClose()");
X  ifdebug(DCR, DD, if( RootCross != nil ) EchoObject(stderr, RootCross));
X
X  /* if suppressing cross referencing, return */
X  if( !AllowCrossDb )
X  { debug0(DCR, D, "CrossClose returning (!AllowCrossDb).");
X    return;
X  }
X
X  /* check for dangling forward references and dispose cross ref structures */
X  if( RootCross != nil )
X  { for( link = Down(RootCross);  link != RootCross;  link = NextDown(link) )
X    { Child(cs, link);
X      assert( type(cs) == CROSS_SYM, "CrossClose: type(cs)!" );
X      count = 0;  ylink = Down(cs);
X      while( ylink != cs && count <= 5 )
X      {	Child(y, ylink);
X	Error(WARN, &fpos(y), "no invokation of %s follows this %s%s%s",
X		SymName(symb(cs)), SymName(symb(cs)), KW_CROSS, KW_FOLLOWING);
X	debug2(DCR, D, "gall_rec(y) = %s, y = %s",
X			bool(gall_rec(y)), EchoObject(null, y));
X	if( gall_rec(y) ) DbInsert(NewCrossDb, TRUE, symb(cs), "none",
X			string(y), file_num(fpos(y)), (long) gall_pos(y));
X	count++;  ylink = NextDown(ylink);
X      }
X      if( ylink != cs )  Error(WARN, no_fpos, "and more undefined %s%s%s",
X				SymName(symb(cs)), KW_CROSS, KW_FOLLOWING);
X      ifdebug(ANY, D,
X	if( target_state(cs) == SEEN_TARGET )  DisposeObject(target_val(cs));
X	if( gall_tag(cs) != nil )  DisposeObject(gall_tag(cs));
X      );
X    }
X    ifdebug(ANY, D, DisposeObject(RootCross); );
X  }
X
X  /* add to NewCrossDb those entries of OldCrossDb from other source files */
X  if( AllowCrossDb )
X  cont = 0L;  len = strlen(DATA_SUFFIX);
X  while( DbRetrieveNext(OldCrossDb, &g, &sym, tag, seq, &dfnum, &dfpos, &cont) )
X  { if( g ) continue;
X    strcpy(buff, FileName(dfnum));
X    buff[strlen(buff) - len] = '\0';
X    if( FileNum(buff) == NO_FILE )
X      DbInsert(NewCrossDb, FALSE, sym, tag, seq, dfnum, dfpos);
X  }
X
X  /* make NewCrossDb readable, for next run */
X  DbConvert(NewCrossDb, TRUE);
X
X  debug0(DCR, D, "CrossClose returning.");
X} /* end CrossClose */
END_OF_FILE
  if test 24737 -ne `wc -c <'lout/z10.c'`; then
    echo shar: \"'lout/z10.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z10.c'
fi
echo shar: End of archive 4 \(of 30\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
