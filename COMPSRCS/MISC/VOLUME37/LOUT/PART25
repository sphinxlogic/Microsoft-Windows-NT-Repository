Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i123:  lout - Lout document formatting system, v2, Part25/30
Message-ID: <1993Jun2.030522.28932@sparky.imd.sterling.com>
X-Md4-Signature: f4435d608aa6a7818f7045c74a8667ed
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 2 Jun 1993 03:05:22 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 123
Archive-name: lout/part25
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/doc/tr.eq/s3 lout/doc/tr.lout/ch3.23
#   lout/doc/tr.lout/ch4.01 lout/doc/tr.lout/ch4.02
#   lout/doc/tr.lout/ch4.05 lout/doc/tr.lout/setup lout/z07.c
#   lout/z11.c lout/z28.c lout/z35.c
# Wrapped by kent@sparky on Sun May 30 19:44:01 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 25 (of 30)."'
if test -f 'lout/doc/tr.eq/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.eq/s3'\"
else
  echo shar: Extracting \"'lout/doc/tr.eq/s3'\" \(3414 characters\)
  sed "s/^X//" >'lout/doc/tr.eq/s3' <<'END_OF_FILE'
X@Section
X   @Title { Spacing }
X@Begin
X@PP
XThere is a basic rule governing the use of white space characters
X(space, tab, and newline) in the input to Lout:  white space between two
Xobjects affects the result; white space between a symbol and its
Xparameter does not.
X@PP
XAlthough this rule is just right most of the time, it is not adequate
Xfor equation formatting.  Getting the horizontal spacing right in
Xequations is a very fiddly business, involving four different sizes of
Xspace (zero, thin, medium, and thick), and different rules for spacing
Xwithin superscripts and subscripts to those applying outside, according
Xto a leading authority [{@Ref knuth84}].  Eq therefore takes the spacing
Xdecisions upon itself, and con&-sequently chooses to ignore all white
Xspace in its input, even between two objects.
X@FootNote {
XThis effect is produced by enclosing the entire equation in
X{@Code "0c @Space"}.  The simplest way to restore the effect of white
Xspace to part of an equation is to enclose that part in a @Code "@Font"
Xsymbol.  Eq also changes the value of the @Code v unit, so if a paragraph
Xof filled text is desired within an equation, it may be necessary to
Xenclose it in a @Code "@Break" symbol. }
X@PP
XEvery symbol provided by Eq has a {@I {full name}}, which denotes the
Xsymbol without any space attached.  Many symbols also
Xhave a {@I {short name}}, which denotes the same symbol with what Eq
Xconsiders to be an appropriate amount of space for that symbol attached
Xto it.  For example, @Eq { lessequal } has full name @Code lessequal
Xand short name {@Code "<="}:
X@IL
X@LI {
X@Code "a lessequal b"
X|7ct
X@Eq { a lessequal b }
X}
X@LI {
X@Code "a <= b"
X|7ct
X@Eq { a <= b }
X}
X@EL
XEq puts a thick space around relation symbols like {@Code "<="}, a
Xmedium space around binary operator symbols like {@Code "+"}, and a thin
Xspace after punctuation symbols (@Code ";" and {@Code ","}); except
Xthat in places where the symbols appear in a smaller size (superscripts,
Xsubscripts, etc.), these spaces are omitted.  No other horizontal space
Xis ever inserted.
X@PP
XThe short names have been carefully designed to produce good-looking
Xmathematics most of the time.  It is best to rely
Xon them in the first instance and only think about spacing when the result
Xis not pleasing.  In that case, Eq's space can be removed by using the
Xfull names, and thin, medium and thick space can be added using the
Xfollowing symbols:
X@ID @Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col A ! @Col B }
X{
X@Rowa
X  A { @Code "`" }
X  B { {@Code "0.18f"}  ({@Code "0.018f"} in subscripts, etc.) }
X@Rowa
X  A { @Code "``" }
X  B { {@Code "0.24f"}  ({@Code "0.024f"} in subscripts, etc.) }
X@Rowa
X  A { @Code "```" }
X  B { {@Code "0.30f"}  ({@Code "0.030f"} in subscripts, etc.) }
X}
Xwhere @Code "1f" is the current font size.  These symbols have low
Xprecedence.  The @Code "&" symbol from standard Lout is also available;
Xthe @Code "s" unit has value 0 and so is not very useful, but one can write
X@Code "&2m" for example for a two em space.  Since the full names are tedious
Xto remember, Eq provides a symbol @Code "non" which removes spaces from
Xits right parameter; thus @Code "non <=" is equivalent to {@Code "lessequal"},
Xfor example.  There are also symbols {@Code "rel"}, {@Code "bin"}, and
X{@Code "punct"} for telling Eq to add space to the following symbol as
Xthough it was a relation symbol, binary operator, or punctuation symbol.
X@End @Section
END_OF_FILE
  if test 3414 -ne `wc -c <'lout/doc/tr.eq/s3'`; then
    echo shar: \"'lout/doc/tr.eq/s3'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.eq/s3'
fi
if test -f 'lout/doc/tr.lout/ch3.23' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch3.23'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch3.23'\" \(7416 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch3.23' <<'END_OF_FILE'
X@Section
X   @Title { "@Graphic" }
X   @Tag { graphic }
X@Begin
X@PP
Xgraphic.sym @Index { @@Graphic symbol }
Xdiagrams @Index { Diagrams }
XLout does not provide the vast repertoire of graphical objects (lines,
Xcircles, boxes, etc.) required by diagrams.  Instead, it provides an
Xescape route to some other language that does have these features, via
Xits @@Graphic symbol:
Xpostscript.graphic @SubIndex { used by @@Graphic }
X@ID @Code {
X"{ 0 0 moveto"
X"  0 ysize lineto"
X"  xsize ysize lineto"
X"  xsize 0 lineto"
X"  closepath"
X"  stroke"
X"}"
X"@Graphic"
X"{ //0.2c"
X"  ||0.2c hello, world ||0.2c"
X"  //0.2c"
X"}"
X}
XThe result of the above invocation of the symbol @@Graphic is
X@ID {
X{ 0     0     moveto
X  0     ysize lineto
X  xsize ysize lineto
X  xsize 0     lineto
X  closepath
X  stroke
X}
X@Graphic
X{ //0.2c
X  ||0.2c hello, world ||0.2c
X  //0.2c
X}
X}
X@PP
XThe right parameter always appears as part of the result, and indeed the
Xresult is always an object whose size is identical to the size of the
Xright parameter with @@OneCol and @@OneRow applied to
Xit.  From now on we refer to this part of the result as the {@I base}.
X@PP
XThe left parameter is implementation-dependent: that is, its
Xmeaning is not defined by Lout, and different implementations could
Xrequire different values for it.  The following description applies to
XBasser Lout, which uses the PostScript page description language
X[{@Ref adobe90}].
X@PP
XThe left parameter refers to a coordinate system whose origin 
Xis the bottom left-hand corner of the base.  It may use the symbols
X@Code xsize and @Code ysize to denote the horizontal and vertical size
Xof the base; similarly, @Code xmark and @Code ymark denote the positions
Xof the base's column and row marks:
X@ID 9p @Font @Fig {
X   { &1rt @I ysize /0ik &1rt @I ymark /0ik &1rt 0 } |0.4c
X   {  /
X      |0ik @ShowMarks { 1c @High 1.5c @Wide ^| 3c @Wide ^/ 2c @High }
X      |0ik /
X   }
X   /0.2c
X   | 0 | @I xmark | @I xsize
X}
XIn addition to these four symbols and 0, lengths may be denoted in
Xcentimetres, inches, points, ems, f's, v's and s's using the notation
X@ID @Tab
X    vmargin { 0.5vx }
X    hmargin { 1m }
X    @Fmta { @Col {@I l  @Code A} ! @Col {instead of Lout's} ! @Col {{@I l}B} }
X{
X@Rowa A { cm } B { c }
X@Rowa A { in } B { i }
X@Rowa A { pt } B { p }
X@Rowa A { em } B { m }
X@Rowa A { ft } B { f }
X@Rowa A { vs } B { v }
X@Rowa A { sp } B { s }
X}
XNote that there must be a space between the number and its unit,
Xunlike Lout proper.
X@PP
XA point within the base (and, with care, a point outside it) may
Xbe denoted by a pair of lengths.  For example,
X@ID @Code {
X"xmark  ymark"
X}
Xis the point where the marks cross, and
X@ID @Code {
X"0   2 cm"
X}
Xis a point on the left edge, two centimetres above the bottom left-hand
Xcorner.  These two numbers are called the @I {x coordinate} and the
X@I {y coordinate} of the point.
X@PP
XThe first step in specifying a graphic object is to define a
X{@I path}.  A path can be thought of as the track of a pen moving over
Xthe page.  The pen may be up (not drawing) or down (drawing a line or
Xcurve) as it moves.  The entire path is a sequence of the following
Xitems:
X@LP
X2i @Wide { |1rt @I {x y} @Code moveto }
X|2m Lift the pen and move it to the indicated point.
X@JP
X2i @Wide { |1rt @I {x y} @Code lineto }
X|2m Put the pen down and draw a straight line to the indicated point.
X@JP
X2i @Wide { |1rt @I {x y r angle1 angle2} @Code arc }
X|2m Put the pen down and draw a circular arc whose centre has
Xcoordinates @I x and @I y and whose radius is {@I r}.  The arc begins
Xat the angle @I angle1 measuring counterclockwise from the point
Xdirectly to the right of the centre, and proceeds counterclockwise to
X{@I angle2}.  If the arc is not the first thing on the path, a straight
Xline will be drawn connecting the current point to the start of the arc.
X@JP
X2i @Wide { |1rt @I {x y r angle1 angle2} @Code arcn }
X|2m As for arc, but the arc goes clockwise from @I angle1 to
X{@I angle2 }.
X@JP
X2i @Wide @Code { |1rt closepath }
X|2m Draw a straight line back to the point most recently moved to.
X@LP
XThe first item should always be a {@Code moveto}, {@Code arc}, or
X{@Code arcn}.  It should be clear from this that the path given earlier:
X@ID @Code {
X"0 0 moveto"
X"0 ysize lineto"
X"xsize ysize lineto"
X"xsize 0 lineto"
X"closepath"
X}
Xtraces around the boundary of the base with the pen down.
X@PP
XOnce a path is set up, we are ready to @I paint it onto the page.  There 
Xare two choices: we can either @I stroke it, which means to display it
Xas described; or we can @I fill it, which means to paint everything
Xinside it grey or black.  For stroking the two main options are
X@IL
X@LI {
X2i @Wide { |1rt @I length @Code setlinewidth }
X|2m The pen will draw lines of the given width.
X}
X@LI {
X2i @Wide { |1rt @Code "[" @I length @Code {"]" 0 setdash} }
X|2m The pen will draw dashed lines when it is down, with the dashes each
Xof the given length.
X}
X@EL
XThese options are followed by the word {@Code "stroke"}.  So, for example,
X@ID @Code {
X"{ 0 0 moveto xsize 0 lineto"
X"  2 pt setlinewidth [ 5 pt ] 0 setdash stroke"
X"}"
X"@Graphic { 3i @Wide }"
X}
Xhas result
X@ID {
X{ 0 0 moveto xsize 0 lineto
X  2 pt setlinewidth [ 5 pt ] 0 setdash stroke
X}
X@Graphic { 3i @Wide }
X}
X@PP
XWhen filling in the region enclosed by a path, the main option is
X{@Code setgray}, which determines the shade of grey to use, on a scale
Xfrom 0 (black) to 1 (white).  So, for example,
X@ID @Code {
X"{ 0 0 moveto xsize 0 lineto 0 ysize lineto closepath"
X"  0.8 setgray fill"
X"}"
X"@Graphic"
X"{ 2c @Wide  2c @High }"
X}
Xhas result
X@ID {
X{ 0 0 moveto xsize 0 lineto 0 ysize lineto closepath
X  0.8 setgray fill
X}
X@Graphic
X{ 2c @Wide  2c @High }
X}
X@PP
XThere are many other options.  The value of the left parameter of
X@@Graphic may be any fragment of the PostScript page description language
X[{@Ref adobe90}].  Here are two other examples:
X@ID @Code {
Xxsize 2 div
X}
Xdenoting a length equal to half the horizontal size of the base, and
X@ID @Code {
Xgsave fill grestore stroke
X}
Xwhich both fills and strokes the path.  Since Basser Lout does not check
Xthat the left parameter is valid PostScript, it is possible to cause
Xmysterious errors in the printing device, resulting in no output, if an
Xincorrect value is given.  It is a good idea to encapsulate graphics
Xobjects in carefully tested definitions, like those of the Fig figure
Xdrawing package [{@Ref kingston92fig}],
Xfig @Index { Fig figure-drawing package }
Xto be sure of avoiding these errors.
X@PP
XPostScript experts may find the following information helpful when
Xdesigning advanced graphics features.  The left parameter of @@Graphic
Xmay have two parts, separated by {@Code "//"}:
X@ID {
X@Code "{" @I {first part} @Code "//" @I {second part} @Code "} @Graphic"
X@I object
X}
XIf there is no {@Code "//"}, the second part is taken to be empty.  The
XPostScript output has the form
X@ID lines @Break {
X@Code gsave
X@I x @I y @Code translate
X@I {Code which defines {@Code xsize}, {@Code ysize}, {@Code xmark}, {@Code ymark}, {@Code ft}, {@Code vs}, and {@Code sp} }
X@Code gsave
X@I {first part}
X@Code grestore
X@I {Code which renders the right parameter in translated coordinates}
X@I {second part}
X@Code grestore
X}
Xwhere @Eq {x, y} is the position of the lower left corner of the
Xbase.  Having two parts permits bracketing operations, like @Code save
Xand @Code restore or @Code begin and {@Code end}, to enclose an
Xobject.  See the source file of the Fig package for examples.
X@End @Section
END_OF_FILE
  if test 7416 -ne `wc -c <'lout/doc/tr.lout/ch3.23'`; then
    echo shar: \"'lout/doc/tr.lout/ch3.23'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch3.23'
fi
if test -f 'lout/doc/tr.lout/ch4.01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch4.01'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch4.01'\" \(7273 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch4.01' <<'END_OF_FILE'
X@Section
X   @Title { An equation formatting package }
X   @Tag { eq }
X@Begin
X@PP
XIn this section we describe the design and implementation of the Eq
Xeq @Index { Eq equation formatting package }
Xequation formatting package.  Equation formatting makes a natural first
Xexample, partly because its requirements have strongly influenced the
Xdesign of Lout, and partly because no cross references or galleys are
Xrequired.
X@PP
XTo the author's knowledge, Eq is the first equation formatter to be
Ximplemented as a collection of high-level definitions.  This approach
Xhas significant advantages:  the basics of language and layout are
Xtrivial, so the implementor can concentrate on fine-tuning; and the
Xdefinitions, being readily available, can be improved, extended, or even
Xreplaced.
X@PP
XAs described in the Eq user manual [{@Ref kingston92eq}], an equation is
Xentered in a format based on the one introduced by the eqn language of
XKernighan and Cherry [{@Ref kernighan75}]:
Xkernighan.b @Index { Kernighan, B. }
Xcherry.l @Index { Cherry, L. }
X@ID @Code {
X"@Eq { { x sup 2  +  y sup 2 }  over  2 }"
X}
XThe result is
X@ID @Eq { { x sup 2  +  y sup 2 }  over  2 }
XIn outline, the definition of the @Code "@Eq" symbol is
Xeq.example @Index { @Code "@Eq" example }
X@ID @Code {
X"export  sup  over \"+\"  \"2\"  \"<=\""
X"def @Eq"
X"   body @Body"
X"{"
X"   def sup precedence 60 left x right y { ... }"
X"   def over precedence 54 left x right y { ... }"
X"   def \"2\" { Base @Font \"2\" }"
X"   def \"+\" { {Symbol Base} @Font \"+\" }"
X"   def \"<=\" { {Symbol Base} @Font \"\\243\" }"
X"   ..."
X""
X"   Slope @Font 1.2f @Break 0c @Space @Body"
X"}"
X}
XA body parameter is used to restrict the visibility of the equation
Xformatting symbols (there are hundreds of them).  The equation as a whole
Xis set in Slope (i.e. Italic) font, and symbols such as @Code "\"2\"" and
X@Code "\"+\"" are defined when other fonts are needed.  Precedences are
Xused to resolve ambiguities such as {@Code "a sup b over c"}.  Eq takes
Xall spacing decisions on itself, so to prevent white space
Xtyped by the user from interfering, the equation is enclosed in
X{@Code "0c @Space"}.  We will discuss the {@Code "1.2f @Break"} later.
X@PP
XThus have we disposed of the language design part of the equation
Xformatting problem; it remains now to define the twenty or so symbols
Xwith parameters, and get the layout right.
X@PP
XEvery equation has an {@I axis}:  an imaginary horizontal line through
Xthe centre of variables, through the bar of built-up fractions, and so
Xon.  We can satisfy this requirement by ensuring that the result of each
Xsymbol has a single row mark, on the axis.  For example, the
Xsuperscripting symbol is defined as follows:
Xsup.example @Index { @Code "sup" example }
X@ID @Code {
X"def sup"
X"    precedence 60"
X"    associativity left"
X"    left x"
X"    named gap { @SupGap }"
X"    right y"
X"{"
X"    @HContract @VContract {"
X"        |  @Smaller y"
X"        ^/gap  x"
X"    }"
X"}"
X}
XThe @Code "@VContract" and @Code "^/" symbols together ensure that the axis
Xof the result is the axis of the left parameter.  A @Code "gap"
Xparameter has been provided for varying the height of the superscript,
Xwith default value @Code "@SupGap"  defined elsewhere as
X{@Code "0.40fk"}.  It is important that such gaps be expressed in units
Xthat vary with the font size, so that they remain correct when the size
Xchanges.  Collecting the default values into symbols like @Code
X"@SupGap" ensures consistency and assists when tuning the values.  Here
Xis another characteristic definition:
Xover.example @Index { @Code "over" example }
X@ID @Code {
X"def over"
X"    precedence 54"
X"    associativity left"
X"    left x"
X"    named gap { 0.2f }"
X"    right y"
X"{"
X"    @HContract @VContract {"
X"        |0.5rt  @OneCol x"
X"        ^//gap  @HLine"
X"        //gap  |0.5rt @OneCol y"
X"    }"
X"}"
X}
XBoth parameters are centred, since we do not know which will be the
Xwider; we use @@OneCol to make sure that the entire parameter is
Xcentred, not just its first column, and @@HContract ensures that the
Xfraction will never expand to fill all the available space, as Lout objects
Xhave a natural tendency to do (Section {@NumberOf size}).  @Code "@HLine"
Xis a horizontal line of the width of the column:
Xhline.example @Index { @Code "@Hline" example }
X@ID @Code {
X"def @HLine"
X"    named line { \"0.05 ft setlinewidth\" }"
X"{  "
X"    { \"0 0 moveto xsize 0 lineto\" line \"stroke\" } @Graphic {}"
X"}"
X}
XHere we are relying on the expanding tendency just mentioned.
X@PP
XThe remaining symbols are quite similar to these ones.  We conclude with
Xa few fine points of mathematical typesetting mentioned by a leading
Xauthority, D. E. Knuth [{@Ref knuth84}].
Xknuth.d @Index { Knuth, D. }
X@PP
XSome symbols, such as @Eq {lessequal} and @Eq { notequal }, should have a
Xthick space on each side; others, such as @Eq {plus} and @Eq {minus},
Xhave a medium space; others have a thin space on the right only.  This
Xwould be easy to do except that these spaces are not wanted in
Xsuperscripts and subscripts:
X@ID @Eq { r sup n+1 - 1 }
XIn effect, the definition of such symbols changes depending on the
Xcontext; but Lout does not permit such a change.  Luckily, the so-called
X`style' information set by the @@Font, @@Break, and @@Space symbols can
Xchange in this way.  Accordingly, Eq commandeers the @Code v unit,
Xnormally used for line gaps, and uses it for these spaces instead:
X@ID @Code {
X"def @MedGap { 0.20v }"
X""
X"def \"+\" { &@MedGap plus &@MedGap }"
X""
X"def @Smaller right x { 0.7f @Font 0c @Space 0.2f @Break x }"
X}
XThe @Code "@Smaller" symbol is applied to all superscripts and subscripts,
Xreducing the font size and also reducing the @Code "v" unit,
Xthereby reducing the space around @Code "+" and similar symbols.
X@PP
XSome objects, notably matrices and large summation signs, must be
Xvertically centred in the sense that their axis must be placed halfway
Xdown the object.  This seems quite different to the usual kind of
Xcentring of one object within another handled by the @Code "0.5rt" gap.
X With the aid of the @Code w unit used with concatenation symbols (one
Xw.unit.example @SubIndex { example of use of }
X@Code w is the size of the following object) and some ingenuity we find that
Xvctr.example @Index { @Code vctr example }
X@ID @Code {
X"def vctr right x"
X"{ @OneRow { /0.5wo @OneRow { @OneRow x ^/ } }"
X"}"
X}
Xwill vertically centre its parameter: @Code "@OneRow { @OneRow x ^/ }"
Xreplaces {@Code x}'s mark by one mark along its lower boundary; then
X@Code "/0.5wo" overstrikes the desired mark, and the outer @@OneRow
Xhides the lower mark.  Unfortunately, although the parameter is
Xcorrectly placed and printed, the overstriking hides its top half, and
X@ID @Code {
X"vctr sum from i=0 to n i"
X}
Xappears as
X@ID @Eq { 
X@OneRow { /0.5wo @OneRow { @OneRow sum ^/ } }
Xfrom i=0 to n i
X}
Xusing this definition.  The version of @Code "vctr" in Eq
Xovercomes this problem by overstriking two copies of the parameter, one
Xof which has been rotated twice by 180 degrees:
X@ID @Code {
X"def vctr  right x"
X"{  @OneRow"
X"   {  -180d @Rotate { /0.5wo 180d @Rotate { / @OneRow @OneCol x  } }"
X"      ^/  @OneRow { /0.5wo @OneRow { @OneRow @OneCol x ^/ } }"
X"   }"
X"}"
X}
XThis is very ugly and suggests that something is lacking from Lout's features.
X@End @Section
END_OF_FILE
  if test 7273 -ne `wc -c <'lout/doc/tr.lout/ch4.01'`; then
    echo shar: \"'lout/doc/tr.lout/ch4.01'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch4.01'
fi
if test -f 'lout/doc/tr.lout/ch4.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch4.02'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch4.02'\" \(8479 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch4.02' <<'END_OF_FILE'
X@Section
X   @Title { Paragraphs, displays, and lists }
X   @Tag { paras }
X@Begin
X@PP
XThe remaining sections of this chapter are all based on the
XDocumentLayout package, described from the user's perspective in the
Xdocument.layout @Index { DocumentLayout package }
XBeginners' Guide [{@Ref kingston92begin}].  In 26 pages of Lout,
Xthe package defines many features required in the formatting of simple
Xdocuments, technical reports, and books, including displays, lists, page
Xlayout, cross references, tables of contents, footnotes, figures,
Xtables, references, chapters, sections, and sorted indexes.
X@PP
XThe symbols used for separating paragraphs and producing displays and
Xdocument.layout.paras @SubIndex { paragraphs }
Xlists may lack the excitement of more exotic features, but they can
Xteach some important lessons about robust design.  The following macro
Xfor separating paragraphs produces a 0.3 cm vertical space and a 1 cm
Xindent on the following line, and is clearly on the right track:
X@ID @Code "macro  @PP  { //0.3c &1c }"
XNevertheless it has several major problems.
X@PP
XThe @Code "&" symbol is subject to widening during line adjustment, so
Xit should be replaced by {@Code "1c @Wide {}"}.  But then white space
Xfollowing the symbol will affect the result, so an extra @Code "&0i" must
Xbe added.  If the document is printed double spaced, this paragraph gap
Xwill fail to widen:  it should be expressed in terms of the @Code "v" unit,
Xwith mark-to-mark spacing mode.  Similarly, the paragraph indent should
Xprobably be made proportional to the font size.
X@PP
X`Magic numbers' like @Code "0.3c" should not be buried in definitions
Xwhere they cannot be changed easily, or kept consistent with similar
Xdefinitions during tuning.  They are much better placed as symbols,
Xpossibly parameters of the enclosing package:
X@ID @Code {
X"def @DocumentLayout" pp.example @Index { @Code "@PP" example }
X"    named @ParaGap { 1.3vx }"
X"    named @ParaIndent { 2f }"
X"    ..."
X"@Begin"
X""
X"    macro @PP { //@ParaGap @ParaIndent @Wide &0i }"
X"    macro @LP { //@ParaGap }"
X"    ..."
X"@End @DocumentLayout"
X}
Xand we have arrived at the definition of @Code "@PP" as it appears in
Xthe DocumentLayout package.
X@PP
XA display is a table in which the first column is blank:
Xdocument.layout.displays @SubIndex { displays }
X@ID lines @Break {
X@I { preceding text }
X@Code "//@DispGap |@DispIndent"  @I display
X@Code "//@DispGap"
X@I { following text }
X}
XEdge-to-edge is the appropriate spacing mode before and after displays,
Xsince the display could be a table or figure whose mark does not
Xcorrespond to a baseline.  Thus, @Code "1v" is a reasonable value for
X{@Code "@DispGap"}.
X@PP
XThe ordinary user cannot be expected to type the Lout source shown
Xabove; a more appropriate syntax is
Xindented.display.example @Index { @Code "@IndentedDisplay" example }
X@ID lines @Break {
X@I { preceding text }
X@Code "@IndentedDisplay {"  @I display  @Code "}"
X@I { following text }
X}
XThis presents a problem:  if @Code "@IndentedDisplay" is made a definition
Xwith a right parameter, its result will be an object separated from the
Xsurrounding text only by white space, hence part of the paragraph; while
Xif it is a macro, the final @Code "//@DispGap" cannot be included in it.
X The solution adopted in the DocumentLayout package uses a galley and a macro:
X@ID @Code {
X"    def @DispPlace { @Galley }"
X"    def @Disp into { @DispPlace&&preceding }"
X"        right x"
X"    {"
X"        @OneRow x"
X"    }"
X""
X"    macro @IndentedDisplay"
X"    {"
X"        //@DispGap  |@DispIndent  @DispPlace  |"
X"        //@DispGap  //  @Disp"
X"    }"
X}
X@Code "@DispPlace" and @Code "@Disp" are not exported, so there is
Xno danger of a name clash with some other symbol.  The ordinary user's
Xsyntax expands to
X@ID lines @Break {
X@I { preceding text }
X@Code "//@DispGap  |@DispIndent  @DispPlace  |"
X@Code "//@DispGap  //  @Disp {" @I display @Code "}"
X@I { following text }
X}
Xand the @Code "@Disp" galley appears at the preceding
X{@Code "@DispPlace"}, being itself replaced by @@Null.  The @Code "//"
Xsymbol protects the preceding @Code "//@DispGap" from being deleted by
Xthis @@Null when there is no following text.
X@PP
XAn automatically numbered list
Xdocument.layout.lists @SubIndex { lists }
Xnumbered @Index { Numbered list }
Xcould have an arbitrarily large number of
Xitems, so, by analogy with sequences of pages, we see immmediately that
Xrecursion must be involved:
X@ID @Code {
X"def @List right num"
X"{"
X"    @DispIndent @Wide num.  |  @ItemPlace"
X"    //@DispGap @List @Next num"
X"}"
X}
XNotice how the @@Next symbol works in conjunction with the recursion to
Xproduce an ascending sequence of numbers; the result of @Code "@List 1"
Xwill be
X@ID @Code {
X"1.   @ItemPlace"
X"2.   @ItemPlace"
X"3.   @ItemPlace"
X"..."
X}
XWe can follow this with items which are galleys targeted to
X{@Code "@ItemPlace&&preceding"}, and @Code "@List" will expand just
Xenough to accommodate them.
X@PP
XThe usual problem with recursive-receptive symbols now arises:  there is
Xalways one unexpanded {@Code "@List"}, and until it can be removed the
Xgalley containing it will appear to be incomplete and will be prevented at
Xthat point from flushing into its parent (see page {@PageOf forcing}).  We
Xadopt the usual solution:  a forcing galley into a later target will
Xreplace the last @Code "@List" by @@Null.  This brings us to the
Xdefinitions as they appear in DocumentLayout:
Xindented.list.example @Index { @Code "@IndentedList" example }
X@IndentedList
X@LI @Code {
X"def @ItemPlace { @Galley }"
X"def @ListItem into { @ItemPlace&&preceding }"
X"    right x"
X"{ x }"
X}
X@LI @Code {
X"def @EndListPlace { @Galley }"
X"def @EndList force into { @EndListPlace&&preceding }"
X"{}"
X}
X@LI @Code {
X"def @RawIndentedList"
X"   named style right tag {}"
X"   named indent { @DispIndent }"
X"   named gap { @DispGap }"
X"   named start { 1 }"
X"{"
X"    def @IList right num"
X"    {"
X"        indent @Wide {style num} | @ItemPlace"
X"        //gap @IList @Next num"
X"    }"
X""
X"    @IList start  //  @EndListPlace"
X"}"
X}
X@EndList
XNow given the input
X@ID @Code {
X"@RawIndentedList"
X"@ListItem { first item }"
X"@ListItem { second item }"
X"..."
X"@ListItem { last item }"
X"@EndList"
X}
X@Code "@RawIndentedList" will expand to receive the items, and will be
Xclosed off by {@Code "@EndList"}.
X@PP
XThe {@Code indent}, {@Code gap}, and {@Code start} parameters are
Xstraightforward (note that the burden of typing @Code 1 has been lifted
Xfrom the ordinary user), but the @Code style parameter has a parameter
Xof its own (see page {@PageOf strange}).  It is used like this:
X@ID @Code {
X"def @RawNumberedList { @RawIndentedList style { tag. } }"
X"def @RawParenNumberedList { @RawIndentedList style { (tag) } }"
X}
XIn {@Code "@RawNumberedList"}, @Code "style" is given the value
X{@Code "tag."}, where @Code tag is its own right parameter, so the value
Xof @Code "{style num}" within @Code "@IList" is {@Code "num."}; while in
X{@Code "@RawParenNumberedList"}, @Code "{style num}" is {@Code "(num)"}.  In
Xthis way we achieve an unlimited variety of numbering formats without
Xhaving to rewrite @Code "@RawIndentedList" over and over.
X@PP
XThese list symbols are objects without surrounding space, so macros
Xsimilar to those used for displays are needed:
X@ID @Code {
X"macro @NumberedList { //@DispGap @RawNumberedList //@DispGap }"
X"macro @ParenNumberedList { //@DispGap @RawParenNumberedList //@DispGap }"
X}
Xand so on.
X@PP
XLists numbered by Roman numerals
Xroman @Index { Roman numerals }
Xpresent a problem, because @@Next will
Xnot increment Roman numerals.  Instead, they must be stored in a
Xdatabase:
X@ID @Code {
X"def @Roman"
X"    left @Tag"
X"    right @Val"
X"{ @Val }"
X""
X"@SysDatabase @Roman { standard }"
X}
X@Code "@SysDatabase" is preferred over @Code "@Database" here because
Xthis database should be kept in a standard place and shared by
Xeveryone.  The database itself, a file called @Code "standard.ld" in
XBasser Lout, contains invocations of {@Code "@Roman"}, each enclosed in
Xbraces:
X@ID @Code {
X"{ 1 @Roman i }"
X"{ 2 @Roman ii }"
X"..."
X"{ 100 @Roman c }"
X}
XThen @Code "@Roman&&12" for example has value {@Roman&&12}, and
X@ID @Code {
X"def @RawRomanList { @RawIndentedList style { {@Roman&&tag}. } }"
X}
Xproduces a list numbered by Roman numerals.  The counting still
Xproceeds in Arabic, but each Arabic numeral is converted to Roman by the
Xcross reference.  Since arbitrary objects may be stored in databases,
Xarbitrary finite sequences of objects may be `counted' in this way.
X@End @Section
END_OF_FILE
  if test 8479 -ne `wc -c <'lout/doc/tr.lout/ch4.02'`; then
    echo shar: \"'lout/doc/tr.lout/ch4.02'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch4.02'
fi
if test -f 'lout/doc/tr.lout/ch4.05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/ch4.05'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/ch4.05'\" \(8311 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/ch4.05' <<'END_OF_FILE'
X@Section
X   @Title { Bibliographies }
X   @Tag { biblio }
X@Begin
X@PP
Xbibliographies @Index { Bibliographies }
XThe first step in the production of a bibliography is to create a
Xdatabase of references based on the definition
Xreference.example @Index { @Code "@Reference" example }
X@ID @Code {
X      "export @Type @Author @Title @Institution @Number @Publisher"
X//1vx "       @Year @Proceedings @Journal @Volume @Pages @Comment"
X//1vx ""
X//1vx "def @Reference"
X//1vx "   named @Tag"         |2f  "{ TAG? }"
X /1vx "   named @Type"        |    "{ TYPE? }"
X /1vx "   named @Author"      |    "{ AUTHOR? }"
X /1vx "   named @Title"       |    "{ TITLE? }"
X /1vx "   named @Institution" |    "{ INSTITUTION? }"
X /1vx "   named @Number"      |    "{ NUMBER? }"
X /1vx "   named @Publisher"   |    "{ PUBLISHER? }"
X /1vx "   named @Year"        |    "{ YEAR? }"
X /1vx "   named @Proceedings" |    "{ PROCEEDINGS? }"
X /1vx "   named @Journal"     |    "{ JOURNAL? }"
X /1vx "   named @Volume"      |    "{ VOLUME? }"
X /1vx "   named @Pages"       |    "{ PAGES? }"
X /1vx "   named @Comment"     |    "{ @Null }"
X//1vx "{ @Null }"
X}
XFor example, the database might contain
X@IL
X@LI @Code {
X"{ @Reference"
X"     @Tag { strunk79 }"
X"     @Type { Book }"
X"     @Author { Strunk, William and White, E. B. }"
X"     @Title { The Elements of Style }"
X"     @Publisher { MacMillan, third edition }"
X"     @Year { 1979 }"
X"}"
X}
X
X@LI @Code {
X"{ @Reference"
X"     @Tag { kingston92 }"
X"     @Type { TechReport }"
X"     @Author { Kingston, Jeffrey H. }"
X"     @Title { Document Formatting with Lout (Second Edition) }"
X"     @Number { 449 }"
X"     @Institution { Basser Department of Computer"
X"Science F09, University of Sydney 2006, Australia }"
X"     @Year { 1992 }"
X"}"
X}
X@EL
XSince named parameters are optional, we have one for every conceivable
Xtype of attribute, and simply leave out those that do not apply in any
Xparticular reference.  We can print a reference by using the @@Open
Xsymbol to get at its attributes:
X@ID @Code {
X"@Reference&&strunk79 @Open"
X"{  @Author,  {Slope @Font @Title}.  @Publisher, @Year.  }"
X}
XThe right parameter of @@Open may use the exported parameters of the
Xleft, and so the result is
X@ID {
X@Reference&&strunk79 @Open
X{  @Author,  {Slope @Font @Title}.  @Publisher, @Year.  } &0io
X}
XIncidentally, we are not limited to just one database of references;
Xseveral @@Database symbols can nominate the same symbol, and invocations of
Xthat symbol can appear in the document itself as well if we wish.
X@PP
XThe second step is to create a database of print styles for the various
Xtypes of reference (Book, TechReport, etc.), based on the following
Xdefinition:
X@ID @Code {
X"export @Style"
X"def @RefStyle"
X"   left @Tag"
X"   named @Style right reftag {}"
X"{}"
X}
XNotice that the named parameter @Code "@Style" has a right parameter
X{@Code "reftag"}.  The style database has one entry for each type of
Xreference:
X@ID @Code {
X"{ Book @RefStyle @Style"
X"  {  @Reference&&reftag @Open"
X"     { @Author,  {Slope @Font @Title}.  @Publisher, @Year.  @Comment }"
X"  }"
X"}"
X""
X"{ TechReport @RefStyle @Style"
X"  {  @Reference&&reftag @Open"
X"     { @Author,  {Slope @Font @Title}.  Tech. Rep. @Number (@Year),"
X"@Institution.  @Comment }"
X"  }"
X"}"
X}
Xand so on.  The following prints the reference whose tag is
X@Code strunk79 in the Book style:
X@ID @Code {
X"@RefStyle&&Book @Open { @Style strunk79 }"
X}
XIt has result
X@ID {
X@RefStyle&&Book @Open { @Style strunk79 } &0io
X}
XNotice how the @Code "@Style" parameter of @Code "@RefStyle" is given the
Xparameter {@Code strunk79}, which it uses to open the appropriate
Xreference.
X@PP
XWe can consult the @Code "@Type" attribute of a reference to find out
Xits style, which brings us to the following definition for printing out
Xa reference in the style appropriate to it:
X@ID @Code {
X"def @RefPrint"
X"   right reftag"
X"{  @RefStyle&&{ @Reference&&reftag @Open { @Type } }"
X"   @Open { @Style reftag }"
X"}"
X}
XFor example, to evaluate {@Code "@RefPrint strunk79"}, Lout first
Xevaluates
X@ID @Code {
X"@Reference&&strunk79  @Open  { @Type }"
X}
Xwhose result is {@Code { @Reference&&strunk79  @Open  { @Type } }},
Xand then evaluates
X@Code {
X"@RefStyle&&Book @Open { @Style strunk79 }"
X}
Xas before.  Complicated as this is, with its two databases and clever
Xpassing about of tags, the advantages of separating references from
Xprinting styles are considerable:  printing styles may be changed
Xeasily, and non-expert users need never see them.
X@PP
XFinally, we come to the problem of printing out a numbered list of
Xreferences, and referring to them by number in the body of the
Xdocument.  The first step is to create a numbered list of places that
Xgalleys containing references may attach to:
Xreferencesection.example @Index { @Code "@ReferenceSection" example }
X@ID @Code {
X"def @ReferenceSection"
X"    named @Tag {}"
X"    named @Title { References }"
X"    named @RunningTitle { dft }"
X"    named style right tag { tag. }"
X"    named headstyle right @Title { @Heading @Title }"
X"    named indent { @DispIndent }"
X"    named gap { @DispGap }"
X"    named start { 1 }"
X"{"
X"    def @RefList right num"
X"    {"
X"        @NumberMarker num  &  indent @Wide {style num}  |  @RefPlace"
X"        //gap @RefList @Next num"
X"    }"
X""
X"        @Protect headstyle @Title"
X"    //  @PageMarker&&preceding @Tagged @Tag"
X"    //  @Title @MajorContentsEntry {@PageOf @Tag}"
X"    //  @Runner"
X"            @FootEven { |0.5rt 0.8f @Font @B @PageNum }"
X"            @FootOdd  { |0.5rt 0.8f @Font @B @PageNum }"
X"    //@DispGap  @RefList start"
X"    //  @Runner"
X"            @TopEven { @B @PageNum }"
X"            @TopOdd  { @I {@RunningTitle @OrElse @Title} |1rt @B @PageNum }"
X"}"
X}
XWe place the expression @Code "@ReferenceSection" at the point where we
Xwant the list of references to appear; its value is something like
X@ID @Code {
X"1.   @RefPlace"
X"2.   @RefPlace"
X"3.   @RefPlace"
X"..."
X}
Xwhere @Code "@RefPlace" is @Code "@Galley" as usual.  We can scatter
Xmultiple lists of references through the document if we wish (at the end
Xof each chapter, for example), simply by placing @Code "@ReferenceSection"
Xat each point.
X@PP
XOur task is completed by the following definition:
Xref.example @Index { @Code "@Ref" example }
X@ID @Code {
X"def @Ref right x"
X"{"
X"    def sendref into { @RefPlace&&following }"
X"        right @Key"
X"    {"
X"        @NumberMarker&&preceding @Tagged x  &"
X"        @PageMarker&&preceding @Tagged x  &"
X"        @RefPrint x"
X"    }"
X""
X"    @NumberMarker&&x @Open { @Tag } sendref x"
X"}"
X}
XGiven this definition, the invocation {@Code "@Ref strunk79"} has result
X@ID @Code "@NumberMarker&&strunk79 @Open { @Tag }"
Xplus the galley {@Code "sendref strunk79"}.  We first
Xfollow what happens to the galley.
X@PP
XAccording to its @Code into clause, the galley will replace a
X@Code "@RefPlace" in the nearest following {@Code "@ReferenceSection"}.  If
Xevery such galley is a sorted galley whose key is the reference's tag, as
Xthis one is, they will appear sorted by tag.  The galley's object is
X@ID @Code {
X"@NumberMarker&&preceding @Tagged strunk79  &"
X"@PageMarker&&preceding @Tagged strunk79  &"
X"@RefPrint strunk79"
X}
XThe result of the @@Tagged symbol is always @@Null, so this prints the
X@Code strunk79 reference in the appropriate style at the
X{@Code "@RefPlace"}, as desired.
X@PP
XNow @Code "@NumberMarker&&preceding" is the nearest preceding invocation of
X@Code "@NumberMarker" in the final document.  This must be the invocation of
X@Code "@NumberMarker" just before the @Code "@RefPlace" that received
Xthe galley, and so this invocation of @Code "@NumberMarker" is given @Code
Xstrunk79 as an additional tag by the @@Tagged symbol.  Its original tag
Xwas the number of the reference place, which means that
X@ID @Code {
X"@NumberMarker&&strunk79 @Open { @Tag }"
X}
Xhas for its result the number of the reference place that received the
X@Code strunk79 galley, and this is the desired result of
X{@Code "@Ref strunk79"}.
X@PP
XIt might seem that if we refer to the @Code strunk79 reference twice,
Xtwo copies will be sent to the reference list and it will appear
Xtwice.  However, when more than one sorted galley with the same key is sent
Xto the same place, only one of them is printed (Section {@NumberOf galleys});
Xso provided that sorted galleys are used there is no problem.
X@End @Section
END_OF_FILE
  if test 8311 -ne `wc -c <'lout/doc/tr.lout/ch4.05'`; then
    echo shar: \"'lout/doc/tr.lout/ch4.05'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/ch4.05'
fi
if test -f 'lout/doc/tr.lout/setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.lout/setup'\"
else
  echo shar: Extracting \"'lout/doc/tr.lout/setup'\" \(8555 characters\)
  sed "s/^X//" >'lout/doc/tr.lout/setup' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Lout setup file for producing the user manual.    #
X#                                                    #
X#  Jeffrey H. Kingston                               #
X#  20 June 1991                                      #
X#  22 December 1991                                  #
X#                                                    #
X######################################################
X
X@SysInclude { ft  }
X@SysInclude { dl  }
X@SysInclude { eq  }
X@SysInclude { fig }
X@SysInclude { tab }
X
X
X   def "->" { {Symbol Base} @Font "\256" } #174 decimal
X   def "=>" { {Symbol Base} @Font "\336" } #222 decimal
X   macro @JP	{ /0.5v  }
X
X   def @Code right x
X   { { Helvetica Base -1p } @Font lines @Break x }
X
X   macro @JL { //1vx }
X
X   ###################################################
X   #                                                 #
X   #  Lout keywords.                                 #
X   #                                                 #
X   ###################################################
X
X   def @@Begin             { @Code "@Begin"             }
X   def @@Break             { @Code "@Break"             }
X   def @@Case              { @Code "@Case"              }
X   def @@Database          { @Code "@Database"          }
X   def @@End               { @Code "@End"               }
X   def @@Font              { @Code "@Font"              }
X   def @@Galley            { @Code "@Galley"            }
X   def @@Graphic           { @Code "@Graphic"           }
X   def @@HAdjust           { @Code "@HAdjust"           }
X   def @@HContract         { @Code "@HContract"         }
X   def @@HExpand           { @Code "@HExpand"           }
X   def @@HScale            { @Code "@HScale"            }
X   def @@High              { @Code "@High"              }
X   def @@Include           { @Code "@Include"           }
X   def @@IncludeGraphic    { @Code "@IncludeGraphic"    }
X   def @@Key               { @Code "@Key"               }
X   def @@LClos             { @Code "@LClos"             }
X   def @@LEnv              { @Code "@LEnv"              }
X   def @@LInput            { @Code "@LInput"            }
X   def @@LVis              { @Code "@LVis"              }
X   def @@Moment            { @Code "@Moment"            }
X   def @@Next              { @Code "@Next"              }
X   def @@Null              { @Code "@Null"              }
X   def @@OneCol            { @Code "@OneCol"            }
X   def @@OneRow            { @Code "@OneRow"            }
X   def @@Open              { @Code "@Open"              }
X   def @@PAdjust           { @Code "@PAdjust"           }
X   def @@PrependGraphic    { @Code "@PrependGraphic"    }
X   def @@Rotate            { @Code "@Rotate"            }
X   def @@Scale             { @Code "@Scale"             }
X   def @@Space             { @Code "@Space"             }
X   def @@SysDatabase       { @Code "@SysDatabase"       }
X   def @@SysInclude        { @Code "@SysInclude"        }
X   def @@SysIncludeGraphic { @Code "@SysIncludeGraphic" }
X   def @@SysPrependGraphic { @Code "@SysPrependGraphic" }
X   def @@Tag               { @Code "@Tag"               }
X   def @@Tagged            { @Code "@Tagged"            }
X   def @@Use               { @Code "@Use"               }
X   def @@VAdjust           { @Code "@VAdjust"           }
X   def @@VContract         { @Code "@VContract"         }
X   def @@VExpand           { @Code "@VExpand"           }
X   def @@VScale            { @Code "@VScale"            }
X   def @@Yield             { @Code "@Yield"             }
X   def @@Wide              { @Code "@Wide"              }
X
X
X   ###################################################
X   #                                                 #
X   #  Miscellaneous, mostly graphical definitions.   #
X   #                                                 #
X   ###################################################
X
X   def @TeX { T{ /0.2fo E}X }
X
X   export sp sb
X   def @Equation
X      body x
X   @Begin
X
X      def sp left x right y { @OneRow { | "-2p" @Font y ^/0.5fk x } }
X      def sb left x right y { @OneRow { x ^/0.5fk | "-2p" @Font y } }
X
X      Slope @Font x
X
X   @End @Equation
X
X   def @Super
X      left x
X      right y
X   { @OneRow { | -2p @Font y ^/0.5fk x }
X   }
X
X   def @NineSquare
X      right x
X   {
X      def @Three { x |0.2i x |0.2i x }
X
X      @Three /0.2i @Three /0.2i @Three
X   }
X
X   def @Leaders
X   { ..   @Leaders
X   }
X
X   def @HLine
X   {
X	{ 0 0 moveto xsize 0 lineto stroke } @Graphic {}
X   }
X
X   def @VDashLine
X      right length
X   {
X      length @High {
X	{ 0 0 moveto 0 ysize lineto [ 3 pt ] 0 setdash stroke } @Graphic {}
X      }
X   }
X
X   def @LBox
X      right offset
X   {  @HContract @VContract
X      {
X        {  //0.2c
X           0.6c @High 1.2c @Wide
X           { 0 0 moveto xsize 0 lineto
X	     xsize ysize lineto 0 ysize lineto closepath
X	     gsave 0.9 setgray fill grestore stroke }
X           @Graphic {}
X        }
X        ||offset @VDashLine 1c
X      }
X   }
X
X   def @Arrow
X      right length
X   {  @OneCol @OneRow
X      {
X	   30d @Rotate {0.12c @Wide @HLine}
X	   //
X	   length @Wide @HLine
X	   //
X	   "-30d" @Rotate {0.12c @Wide @HLine}
X      }
X   }
X
X   def @DoubleArrow
X      right length
X   {  @OneCol @OneRow
X      { 
X         & 180d @Rotate @Arrow length
X         |0io @Arrow length
X      }
X   }
X
X   def @Put
X     left coord
X     right x
X   { @OneCol @OneRow
X     { coord / | @OneCol @OneRow x
X     }
X   }
X   
X   macro @At { //0io }
X
X
X   ###################################################
X   #                                                 #
X   #  Interpolated example documents.                #
X   #                                                 #
X   ###################################################
X
X   def @LittleEndRunPlace { @Galley }
X   def @LittleEndRun
X      force into { @LittleEndRunPlace&&preceding }
X   {}
X
X   def @LittleTextPlace { @Galley }
X   def @LittleText into { @LittleTextPlace&&preceding }
X      right x
X   { x
X   }
X
X   def @LittleFootPlace { @Galley }
X   def @LittleFootNote into { @LittleFootPlace&&following }
X      right x
X   { x
X   }
X
X   def @LittlePageColumn
X      right x
X   {
X        9px @Break 8p @Font
X        2.8c @Wide x
X   }
X
X   def @LittlePage
X      right x
X   {
X      @HContract @VContract {
X        { 0 0 moveto xsize 0 lineto xsize ysize lineto
X    	  0 ysize lineto closepath stroke } @Graphic
X        {  //0.3c ||0.3c
X           9px @Break 8p @Font
X           2.8c @Wide 3.8c @High x
X           ||0.3c //0.3c
X        }
X      }
X   }
X
X   def @LittleFootSect
X   {  1c @Wide @HLine
X      //0.3v @LittleFootPlace ||0.5c
X   }
X
X   def @LittlePageList
X     right @PageNum
X   {
X      @LittlePage { # |0.5rt @PageNum //0.8v
X		//0.3v @LittleTextPlace
X		//1rt @LittleFootSect
X	     }
X      //
X      @LittlePageList @Next @PageNum
X   }
X
X   def @LittleDocument
X   {  @LittlePage
X      {  @LittleTextPlace
X         //1rt @LittleFootSect
X      }
X      // @LittlePageList 2
X      // @LittleEndRunPlace
X   }
X		
X   def @ShowMarks
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @HContract @VContract @Fig
X      {   @Box margin { 0c } linewidth { linewidth } paint { paint }
X	  {   @Figure
X		 shape { -0.3 cm ymark
X			 {xsize ymark} ++ {0.3 cm 0}  []
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	      x
X	  }
X
X      }
X   }
X
X   def @ShowVMark
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @Fig
X      {   
X	 @Figure
X		 shape {
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	 x
X      }
X   }
X
X   def @Strange
X       named @Format right @Val { [@Val] }
X       right x
X   {   @Format x
X   }
X
X   def @Box right x
X   {
X     "0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath stroke"
X     @Graphic x
X   }
X
X   def @GreyBox right x
X   {
X     "0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath 0.8 setgray fill"
X     @Graphic x
X   }
X
X@Use { @DocumentLayout
X  @MakeIndex        { Yes                  }
X  @TableOfContents  { Yes                  }
X  @AppendixGap      { 1.10b                }
X  @BookTitleFormat  { {Bold 2.0f} @Font {//2.0f @Title //0.5f} }
X}
X
X@SysDatabase @Reference { loutrefs }
END_OF_FILE
  if test 8555 -ne `wc -c <'lout/doc/tr.lout/setup'`; then
    echo shar: \"'lout/doc/tr.lout/setup'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.lout/setup'
fi
if test -f 'lout/z07.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z07.c'\"
else
  echo shar: Extracting \"'lout/z07.c'\" \(8502 characters\)
  sed "s/^X//" >'lout/z07.c' <<'END_OF_FILE'
X/*@z07.c:Object Service:CopyObject(), DisposeObject()@************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z07.c                                                      */
X/*  MODULE:       Object Service                                             */
X/*  EXTERNS:      MakeWord(), DisposeObject(), CopyObject(),                 */
X/*                SplitIsDefinite()                                          */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT MakeWord(str, pos)                                                */
X/*  OBJECT MakeWordTwo(str1, str2, pos)                                      */
X/*                                                                           */
X/*  Return an unsized WORD with the given string or concatenation of         */
X/*  strings, and the given filepos.                                          */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT MakeWord(str, pos)
Xunsigned char *str;  FILE_POS *pos;
X{ OBJECT res = NewWord(strlen(str), pos);
X  strcpy( string(res), str );
X  FposCopy(fpos(res), *pos);
X  debug2(DOS, DD, "MakeWord(%s) returning %s", str, EchoObject(null, res));
X  return res;
X} /* end MakeWord */
X
XOBJECT MakeWordTwo(str1, str2, pos)
Xunsigned char *str1, *str2;  FILE_POS *pos;
X{ int len1 = strlen(str1);
X  int len2 = strlen(str2);
X  OBJECT res = NewWord(len1 + len2, pos);
X  strcpy( string(res), str1 );
X  strcpy( &string(res)[len1], str2 );
X  FposCopy(fpos(res), *pos);
X  debug4(DOS, DD, "MakeWordTwo(%s, %s, %s) returning %s",
X    str1, str2, EchoFilePos(pos), EchoObject(null, res));
X  return res;
X} /* end MakeWordTwo */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  DisposeObject(x)                                                         */
X/*                                                                           */
X/*  Dispose object x.  If some of x's children are shared with other         */
X/*  parents, those children are left intact.                                 */
X/*                                                                           */
X/*****************************************************************************/
X
XDisposeObject(x)
XOBJECT x;
X{ debug2(DOS,D,"[DisposeObject( %d ), type = %s, x =", (int) x, Image(type(x)));
X  ifdebug(DOS, DD, EchoObject(stderr, x));
X  assert( Up(x) == x, "DisposeObject: x has a parent!" );
X  while( Down(x) != x )  DisposeChild(Down(x));
X  Dispose(x);
X  debug0(DOS, D, "]DisposeObject returning.");
X} /* end DisposeObject */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT CopyObject(x, pos)                                                */
X/*                                                                           */
X/*  Make a copy of unsized object x, setting all file positions to *pos.     */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT CopyObject(x, pos)
XOBJECT x;  FILE_POS *pos;
X{ OBJECT y, link, res, tmp;
X
X  debug2(DOS, DD, "CopyObject(%s,%s)", EchoObject(null, x), EchoFilePos(pos));
X  switch( type(x) )
X  {
X
X    case WORD:
X    
X      res = NewWord(strlen(string(x)), pos);
X      strcpy(string(res), string(x));
X      break;
X
X
X    case GAP_OBJ:
X    
X      res = New(type(x));
X      mark(gap(res)) = mark(gap(x));
X      join(gap(res)) = join(gap(x));
X      if( Down(x) != x )
X      {	Child(y, Down(x));
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      else
X      {	hspace(res) = hspace(x);
X	vspace(res) = vspace(x);
X      }
X      break;
X
X
X    case HEAD:
X    case NULL_CLOS:
X    case CROSS:
X    case ONE_COL:
X    case ONE_ROW:
X    case WIDE:
X    case HIGH:
X    case HSCALE:
X    case VSCALE:
X    case SCALE:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case ROTATE:
X    case CASE:
X    case YIELD:
X    case FONT:
X    case SPACE:
X    case BREAK:
X    case NEXT:
X    case OPEN:
X    case TAGGED:
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GRAPHIC:
X    case VCAT:
X    case HCAT:
X    case ACAT:
X    
X      res = New(type(x));
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      break;
X
X
X    case ENV:
X    
X      res = x;  /* don't copy environments */
X      break;
X
X
X    case PAR:
X    
X      res = New(PAR);
X      actual(res) = actual(x);
X      assert( Down(x) != x, "CopyObject: PAR child!" );
X      Child(y, Down(x));
X      tmp = CopyObject(y, pos);
X      Link(res, tmp);
X      break;
X
X
X    case CLOSURE:
X    
X      res = New(type(x));
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	assert( type(y) != CLOSURE, "CopyObject: CLOSURE!" );
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      actual(res) = actual(x);
X      StyleCopy(save_style(res), save_style(x));
X      break;
X
X
X    default:
X    
X      Error(INTERN, pos, "CopyObject: %s found", Image(type(x)));
X		  break;
X
X  } /* end switch */
X  if( pos == no_fpos )  FposCopy(fpos(res), fpos(x));
X  else FposCopy(fpos(res), *pos);
X  debug1(DOS, DD, "CopyObject returning %s", EchoObject(null, res));
X  return res;
X} /* end CopyObject */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN SplitIsDefinite(x)                                               */
X/*                                                                           */
X/*  Return TRUE if x is a definite SPLIT object (both children definite)     */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN SplitIsDefinite(x)
XOBJECT x;
X{ OBJECT y1, y2;
X  assert( type(x) == SPLIT, "SplitIsDefinite: x not a SPLIT!" );
X  Child(y1, DownDim(x, COL));
X  Child(y2, DownDim(x, ROW));
X  return is_definite(type(y1)) && is_definite(type(y2));
X}
END_OF_FILE
  if test 8502 -ne `wc -c <'lout/z07.c'`; then
    echo shar: \"'lout/z07.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z07.c'
fi
if test -f 'lout/z11.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z11.c'\"
else
  echo shar: Extracting \"'lout/z11.c'\" \(8495 characters\)
  sed "s/^X//" >'lout/z11.c' <<'END_OF_FILE'
X/*@z11.c:Style Service:SpaceChange(), BreakChange(), EchoStyle()@*************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z11.c                                                      */
X/*  MODULE:       Style Service                                              */
X/*  EXTERNS:      SpaceChange(), BreakChange(), EchoStyle()                  */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  SpaceChange(style, x)                                                    */
X/*                                                                           */
X/*  Change the current break style as indicated by object x.                 */
X/*                                                                           */
X/*****************************************************************************/
X
XSpaceChange(style, x)
XSTYLE *style;  OBJECT x;
X{ GAP res_gap;  unsigned gap_inc;
X  debug2(DSS, D, "SpaceChange(%s, %s)", EchoStyle(style), EchoObject(null, x));
X  if( type(x) != WORD )
X  { Error(WARN, &fpos(x), "invalid left parameter to %s", KW_SPACE);
X  }
X  else
X  { GetGap(x, style, &res_gap, &gap_inc);
X    if( gap_inc != ABS && units(res_gap) != units(space_gap(*style)) )
X    { Error(WARN, &fpos(x), "space %s incompatible with enclosing", string(x));
X    }
X    else
X    { units(space_gap(*style)) = units(res_gap);
X      mode(space_gap(*style))  = mode(res_gap);
X      width(space_gap(*style)) = gap_inc == ABS ? width(res_gap) :
X	     gap_inc == INC ? width(space_gap(*style)) + width(res_gap) :
X	     max(width(space_gap(*style)) - width(res_gap), 0);
X    }
X  }
X  debug1(DSS, D, "SpaceChange returning %s", EchoStyle(style));
X} /* end SpaceChange */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BreakChange(style, x)                                                    */
X/*                                                                           */
X/*  Change the current break style as indicated by object x.                 */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic changebreak(style, x)
XSTYLE *style;  OBJECT x;
X{ int i; GAP res_gap;  unsigned gap_inc;
X  if( string(x)[0] >= 'a' && string(x)[0] <= 'z' )
X  {
X    /* should be a new break style option */
X    if( strcmp(string(x), "hyphen") == 0 )
X	hyph_style(*style) = HYPH_ON;
X    else if( strcmp(string(x), "nohyphen") == 0 )
X	hyph_style(*style) = HYPH_OFF;
X    else if( strcmp(string(x), "adjust") == 0 )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_ADJUST;
X    else if( strcmp(string(x), "outdent") == 0 )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_OUTDENT;
X    else if( strcmp(string(x), "ragged") == 0 )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_LEFT;
X    else if( strcmp(string(x), "cragged") == 0 )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_CENTRE;
X    else if( strcmp(string(x), "ragged") == 0 )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_RIGHT;
X    else if( strcmp(string(x), "lines") == 0 )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_LEFT;
X    else if( strcmp(string(x), "clines") == 0 )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_CENTRE;
X    else if( strcmp(string(x), "rlines") == 0 )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_RIGHT;
X    else Error(WARN, &fpos(x), "invalid %s option %s", KW_BREAK, string(x));
X  }
X  else
X  {
X    /* should be a new inter-line gap */
X    GetGap(x, style, &res_gap, &gap_inc);
X    if( gap_inc != ABS && units(res_gap) != units(line_gap(*style)) )
X    { Error(WARN, &fpos(x),
X		    "line spacing %s incompatible with enclosing", string(x));
X    }
X    else
X    { units(line_gap(*style)) = units(res_gap);
X      mode(line_gap(*style))  = mode(res_gap);
X      width(line_gap(*style)) = gap_inc == ABS ? width(res_gap) :
X	gap_inc == INC ? width(line_gap(*style)) + width(res_gap) :
X	max(width(line_gap(*style)) - width(res_gap), 0);
X    }
X  }
X} /* end changebreak */
X
XBreakChange(style, x)
XSTYLE *style;  OBJECT x;
X{ OBJECT link, y;
X  debug2(DSS, D, "BreakChange(%s, %s)", EchoStyle(style), EchoObject(null, x));
X  switch( type(x) )
X  {
X    case WORD:
X    
X      changebreak(style, x);
X      break;
X
X
X    case ACAT:
X    
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	if( type(y) == GAP_OBJ )  continue;
X	else if( type(y) == WORD )  changebreak(style, y);
X	else Error(WARN, &fpos(x), "invalid left parameter of %s", KW_BREAK);
X      }
X      break;
X
X
X    default:
X    
X      Error(WARN, &fpos(x), "invalid left parameter of %s", KW_BREAK);
X      break;
X
X  }
X  debug1(DSS, D, "BreakChange returning %s", EchoStyle(style));
X} /* end BreakChange */
X
X
X#if DEBUG_ON
X/*****************************************************************************/
X/*                                                                           */
X/*  unsigned char *EchoStyle(style)                                          */
X/*                                                                           */
X/*  Returns a string showing the value of the style.                         */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *EchoStyle(style)
XSTYLE *style;
X{ char buff1[100], buff2[100], buff3[100], buff4[100];
X  static char res[100];
X  static char *hyphwords[] = { "hyph_undef", "hyph_off", "hyph_on" };
X  static char *fillwords[] = { "fill_undef", "fill_off", "fill_on" };
X  static char *displaywords[] = { "undef", "adjust", "outdent", "left",
X			     "centre", "right", "do" };
X  strcpy(buff1, EchoCatOp(VCAT,mark(line_gap(*style)),join(line_gap(*style))));
X  strcpy(buff2, EchoGap(&line_gap(*style)));
X  strcpy(buff3, EchoGap(&space_gap(*style)));
X  sprintf(buff4, "%s:%s:%s",
X	hyph_style(*style) < 3 ? hyphwords[hyph_style(*style)] : "?",
X	fill_style(*style) < 3 ? fillwords[fill_style(*style)] : "?",
X	display_style(*style) < 7 ? displaywords[display_style(*style)] : "?");
X  sprintf(res, "[%s%s, %d (%s), %s]", buff1, buff2, font(*style), buff3, buff4);
X  return (unsigned char *) res;
X} /* end EchoStyle */
X#endif
END_OF_FILE
  if test 8495 -ne `wc -c <'lout/z11.c'`; then
    echo shar: \"'lout/z11.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z11.c'
fi
if test -f 'lout/z28.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z28.c'\"
else
  echo shar: Extracting \"'lout/z28.c'\" \(8137 characters\)
  sed "s/^X//" >'lout/z28.c' <<'END_OF_FILE'
X/*@z28.c:Error Service:ErrorInit(), Error(), ErrorSeen()@*********************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z28.c                                                      */
X/*  MODULE:       Error Service                                              */
X/*  EXTERNS:      ErrorInit(), Error(), ErrorSeen()                          */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X#define	MAX_BLOCKS	 20		/* max number of error blocks        */
X#define	MAX_ERRORS	 20		/* max number of held error messages */
X
Xstatic BOOLEAN	print_block[MAX_BLOCKS];	/* TRUE if print this block  */
Xstatic int	start_block[MAX_BLOCKS];	/* first message of block    */
Xstatic unsigned char message[MAX_ERRORS][MAX_LINE]; /* the error messages    */
Xstatic FILE	*fp = NULL;			/* file pointer of log file  */
Xstatic BOOLEAN	error_seen = FALSE;		/* TRUE after first error    */
Xstatic int	block_top = 0;			/* first free error block    */
Xstatic int	mess_top = 0;			/* first free error message  */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  ErrorInit(str)                                                           */
X/*                                                                           */
X/*  Open log file str and initialise this module.                            */
X/*                                                                           */
X/*****************************************************************************/
X
XErrorInit(str)
Xunsigned char *str;
X{ if( fp != NULL )
X    Error(FATAL, no_fpos, "-e argument appears twice in command line");
X  fp = fopen(str, "w");
X  if( fp == NULL )
X    Error(FATAL, no_fpos, "cannot open error file \"%s\"", str);
X} /* end ErrorInit */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN ErrorSeen()                                                      */
X/*                                                                           */
X/*  TRUE once an error has been found.                                       */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN ErrorSeen()
X{ return error_seen;
X} /* end ErrorSeen */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  EnterErrorBlock(ok_to_print)                                             */
X/*                                                                           */
X/*  Start off a new block of error messages.  If ok_to_print, they do not    */
X/*  need to be held for a later commit.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
XEnterErrorBlock(ok_to_print)
XBOOLEAN ok_to_print;
X{ if( block_top < MAX_BLOCKS )
X  { print_block[block_top] = ok_to_print;
X    start_block[block_top] = mess_top;
X    block_top++;
X  }
X  else Error(FATAL, no_fpos, "too many levels of error messages");
X} /* end EnterErrorBlock */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  LeaveErrorBlock(commit)                                                  */
X/*                                                                           */
X/*  Finish off a block or error messages.  If commit is true, print them,    */
X/*  otherwise discard them.                                                  */
X/*                                                                           */
X/*****************************************************************************/
X
XLeaveErrorBlock(commit)
XBOOLEAN commit;
X{ int i;
X  assert( block_top > 0, "LeaveErrorBlock: no matching EnterErrorBlock!" );
X  assert( commit || !print_block[block_top - 1], "LeaveErrorBlock: commit!" );
X  if( fp == NULL )  fp = stderr;
X  if( commit )
X  { for( i = start_block[block_top - 1];  i < mess_top;  i++ )
X      fputs(message[i], fp);
X  }
X  block_top--;
X  mess_top = start_block[block_top];
X} /* end LeaveErrorBlock */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  Error(etype, pos, str, p1, p2, p3, p4, p5, p6)                           */
X/*                                                                           */
X/*  Report error of type etype at position *pos in input.                    */
X/*  The error message is str with parameters p1 - p6.                        */
X/*                                                                           */
X/*****************************************************************************/
X
X/*VARARGS3*/
XError(etype, pos, str, p1, p2, p3, p4, p5, p6)
Xint etype;  FILE_POS *pos;  unsigned char *str, *p1, *p2, *p3, *p4, *p5, *p6;
X{ unsigned char val[MAX_LINE];
X  sprintf(val, str, p1, p2, p3, p4, p5, p6);
X  if( fp == NULL )  fp = stderr;
X  switch( etype )
X  {
X
X    case INTERN:
X    
X      while( block_top > 0 )  LeaveErrorBlock(TRUE);
X      fprintf(fp, "lout%s internal error: %s\n", EchoFilePos(pos), val);
X#ifdef DEBUG_ON
X      abort();
X#else
X      exit(1);
X#endif
X      break;
X
X
X    case FATAL:
X    
X      while( block_top > 0 )  LeaveErrorBlock(TRUE);
X      fprintf(fp, "lout%s fatal error: %s\n", EchoFilePos(pos), val);
X      exit(1);
X      break;
X
X
X    case WARN:
X    
X      if( block_top == 0 || print_block[block_top - 1] )
X	fprintf(fp, "lout%s: %s\n", EchoFilePos(pos), val);
X      else if( mess_top < MAX_ERRORS )
X	sprintf(message[mess_top++], "lout%s: %s\n", EchoFilePos(pos), val);
X      else Error(FATAL, pos, "too many error messages");
X      error_seen = TRUE;
X      break;
X
X
X    default:
X    
X      Error(INTERN, no_fpos, "invalid error type");
X      exit(1);
X      break;
X
X  }
X} /* end Error */
END_OF_FILE
  if test 8137 -ne `wc -c <'lout/z28.c'`; then
    echo shar: \"'lout/z28.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z28.c'
fi
if test -f 'lout/z35.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z35.c'\"
else
  echo shar: Extracting \"'lout/z35.c'\" \(7660 characters\)
  sed "s/^X//" >'lout/z35.c' <<'END_OF_FILE'
X/*@z35.c:Time Keeper: InitTime()@*********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z35.c                                                      */
X/*  MODULE:       Time Keeper                                                */
X/*  EXTERNS:      InitTime()                                                 */
X/*                                                                           */
X/*****************************************************************************/
X#include <time.h>
X#include "externs"
X
X#define load(str, typ, encl)						\
X  sym = InsertSym(str, typ, no_fpos, DEFAULT_PREC,  			\
X  FALSE, FALSE, 0, encl, MakeWord("", no_fpos));			\
X  if( typ == NPAR )  visible(sym) = TRUE
X
X#define add_par(format, val, sym)					\
X  sprintf(buff, format, val);						\
X  par = New(PAR);  actual(par) = sym;					\
X  Link(current_moment, par);						\
X  tmp = MakeWord(buff, no_fpos);					\
X  Link(par, tmp);
X
Xstatic OBJECT current_moment = nil;
Xstatic unsigned char time_string[30] = { '\0' };
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT MomentSym;                                                        */
X/*                                                                           */
X/*  The symbol table entry for the @Moment symbol.                           */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT MomentSym = nil;
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  InitTime()                                                               */
X/*                                                                           */
X/*  Place a declaration of the @Moment symbol into the symbol table, and     */
X/*  initialize the value of the object StartMoment.                          */
X/*                                                                           */
X/*****************************************************************************/
X
XInitTime()
X{ long raw_time; struct tm *now;
X  unsigned char buff[20]; OBJECT par, tmp, sym, env;
X  OBJECT tag, second, minute, hour, weekday,
X	monthday, yearday, month, year, century, dst;
X  debug0(DTK, D, "InitTime()");
X
X  /* define @Moment symbol with its host of named parameters */
X  MomentSym = load("@Moment",         LOCAL, StartSym);
X  tag       = load(KW_TAG,            NPAR,  MomentSym);
X  second    = load("@Second",         NPAR,  MomentSym);
X  minute    = load("@Minute",         NPAR,  MomentSym);
X  hour      = load("@Hour",           NPAR,  MomentSym);
X  monthday  = load("@Day",            NPAR,  MomentSym);
X  month     = load("@Month",          NPAR,  MomentSym);
X  year      = load("@Year",           NPAR,  MomentSym);
X  century   = load("@Century",        NPAR,  MomentSym);
X  weekday   = load("@WeekDay",        NPAR,  MomentSym);
X  yearday   = load("@YearDay",        NPAR,  MomentSym);
X  dst       = load("@DaylightSaving", NPAR,  MomentSym);
X
X  /* get current time and convert to ASCII */
X  time(&raw_time);
X  now = localtime(&raw_time);
X  strcpy(time_string, asctime(now));
X
X  /* start of current_moment */
X  current_moment = New(CLOSURE);
X  actual(current_moment) = MomentSym;
X
X  /* attach its many parameters */
X  add_par("%s",   KW_NOW,                      tag);
X  add_par("%d",   now->tm_sec,                 second);
X  add_par("%d",   now->tm_min,                 minute);
X  add_par("%d",   now->tm_hour,                hour);
X  add_par("%d",   now->tm_mday,                monthday);
X  add_par("%d",   now->tm_mon + 1,             month);
X  add_par("%.2d", now->tm_year % 100,          year);
X  add_par("%d",   (now->tm_year+1900) / 100,   century);
X  add_par("%d",   now->tm_wday + 1,            weekday);
X  add_par("%d",   now->tm_yday,                yearday);
X  add_par("%d",   now->tm_isdst,               dst);
X
X  /* add a null environment */
X  env = New(ENV);
X  AttachEnv(env, current_moment);
X  debug0(DTK, D, "InitTime() returning.");
X  debug0(DTK, DD, "current_moment =");
X  ifdebug(DTK, DD, EchoObject(stderr, current_moment));
X} /* end InitTime */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT StartMoment()                                                     */
X/*                                                                           */
X/*  Returns a copy of the initial time.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT StartMoment()
X{ OBJECT res;
X  debug0(DTK, D, "StartMoment()");
X  assert(current_moment != nil, "StartMoment: current_moment == nil!");
X  res = CopyObject(current_moment, no_fpos);
X  debug0(DTK, D, "StartMoment returning");
X  ifdebug(DTK, D, EchoObject(stderr, res));
X  return res;
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  unsigned char *TimeString()                                              */
X/*                                                                           */
X/*  Returns a pointer to a string containing the current time.               */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *TimeString()
X{ return time_string;
X} /* end TimeString */
END_OF_FILE
  if test 7660 -ne `wc -c <'lout/z35.c'`; then
    echo shar: \"'lout/z35.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z35.c'
fi
echo shar: End of archive 25 \(of 30\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
