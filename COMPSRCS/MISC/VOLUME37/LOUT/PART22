Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i120:  lout - Lout document formatting system, v2, Part22/30
Message-ID: <1993Jun2.030409.28605@sparky.imd.sterling.com>
X-Md4-Signature: a784ff22441983ebad7a8b5cf997095b
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 2 Jun 1993 03:04:09 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 120
Archive-name: lout/part22
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/doc/tr.impl/s5.2 lout/font0/TimesBolIta.AFM
#   lout/gnu.gpl lout/z09.c lout/z21.c lout/z26.c
# Wrapped by kent@sparky on Sun May 30 19:44:00 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 22 (of 30)."'
if test -f 'lout/doc/tr.impl/s5.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/doc/tr.impl/s5.2'\"
else
  echo shar: Extracting \"'lout/doc/tr.impl/s5.2'\" \(14105 characters\)
  sed "s/^X//" >'lout/doc/tr.impl/s5.2' <<'END_OF_FILE'
X@SubSection
X    @Tag { flushing }
X    @Title { The galley flushing algorithm }
X@Begin
X@PP
XGalley components are promoted one by one into the point of appearance in
Xthe dynamic parent galley, then carried along with it, ultimately to the
Xroot galley and the output file.  This process is called @I galley
X{@I flushing}: the galleys are rivers running together to the sea, and
Xeach component is a drop of water.
X@PP
XHere is a snapshot of a small dynamic tree, based on the @Code "@PageList"
Xdefinitions of Section {@NumberOf recursion}:
X@ID @Fig {
X
X@I 10p @Font { output file } A:: @Box linestyle { noline } margin { 0c }
X
X||2c
X
X{
X@I 10p @Font { root galley }
X//0.2c
XB:: @Box margin { 0c } linestyle { noline }
X//
X@LittlePage {
X|0.5rt - 1 -
X//1.2vx &2m A small
X//1.2vx @Code "@Galley" * C:: @Box margin { 0.01c } linestyle { noline }
X//1rt @Code "@FootSect"
X}
X//
X@Box margin { 0.3c } 2.8c @Wide 8p @Font @Code "@PageList 2"
X}
X
X||2c
X
X{
X//0.9c  @I 10p @Font { body text }
X//0.2c  D:: @Box margin { 0.3c } 2.8c @Wide 8p @Font paragraph
X//      @Box margin { 0.3c } 2.8c @Wide 8p @Font { of text. }
X//      @Box margin { 0.3c } 2.8c @Wide @Code 8p @Font "@Input"
X}
X
X// @Arrow from { B@W } to { A@E }
X// @Arrow from { D@W } to { C@E }
X
X}
XThe components of the body text galley are lines, except for the special
Xreceptive symbol @Code "@Input" which is a placeholder for as yet unread
Xinput (Section {@NumberOf lookahead}).  The components of the root galley are
Xpages, except for the concluding unexpanded invocation of {@Code "@PageList"},
Xwhich is an inexhaustible source of more pages, expanded on demand.
X@PP
XThe concrete data structure used by Basser Lout permits the galley
Xflushing algorithm to navigate the dynamic tree and find significant
Xfeatures quickly:
X@ID 10p @Font @Fig maxlabels { 100 } {
X
XA:: @Ellipse @I { HEAD }
X
X||1.5c
X
X@OneCol @OneRow {
XB:: @Ellipse @I { RECEIVING * }
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@W  A@CIRCUM} } to { B@W  }
X//0.6c
XC:: @Ellipse @I { RECEPTIVE }
X// @Arrow from { A@CTR ++ {A@CTR @Angle C@W  A@CIRCUM} } to { C@W  }
X//0.6c
XD:: @Box margin { 0c } linestyle { noline }
X// @Arrow from { A@CTR ++ {A@CTR @Angle D@NW  A@CIRCUM} } to { D@NW  }
X//
X@LittlePage {
X|0.5rt - 1 -
X//1.2vx &2m A small
X//1.2vx  E:: @Box margin { 0c } linestyle { noline } @Code "@Galley "
X//1rt    F:: @Box margin { 0c } linestyle { noline } @Code "@FootSect "
X}
X// @FunnyArrow arrow { forward } from { B@E } to { E@E }
X// @FunnyArrow arrow { forward } from { C@E } to { F@E }
X//0.6c
XC:: @Ellipse @I { GAP }
X// @Arrow from { A@CTR ++ {A@CTR @Angle C@W  A@CIRCUM} } to { C@W  }
X//0.6c
XC:: @Ellipse @I { RECEPTIVE }
X// @Arrow from { A@CTR ++ {A@CTR @Angle C@W  A@CIRCUM} } to { C@W  }
X//0.6c
XD:: @Box margin { 0.3c } 2.8c @Wide 8p @Font @Code "@PageList 2"
X//  @Arrow from { A@CTR ++ {A@CTR @Angle D@NW  A@CIRCUM} } to { D@NW  }
X//  @FunnyArrow from { C@E } to { D@W ++ { 1.8 cm 0 } }
X}
X
X||1.0c
X
XA:: @Ellipse @I { HEAD }
X& @Arrow from { B@E } to { A@W }
X
X||1.5c
X
X@OneCol @OneRow {
XB:: @Box margin { 0.3c } 2.8c @Wide 8p @Font paragraph
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@W A@CIRCUM} } to { B@W }
X//0.6c
XB:: @Ellipse @I { GAP }
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@W A@CIRCUM} } to { B@W }
X//0.6c
XB:: @Box margin { 0.3c } 2.8c @Wide 8p @Font { of text. }
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@NW A@CIRCUM} } to { B@NW }
X//0.6c
XB:: @Ellipse @I { GAP }
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@W A@CIRCUM} } to { B@W }
X//0.6c
XB:: @Ellipse @I { RECEPTIVE }
X// @Arrow from { A@CTR ++ {A@CTR @Angle B@W A@CIRCUM} } to { B@W }
X//0.6c
XC:: @Box margin { 0.3c } 2.8c @Wide 8p @Font @Code "@Input"
X// @Arrow from { A@CTR ++ {A@CTR @Angle C@NW A@CIRCUM} } to { C@NW }
X// @FunnyArrow from { B@E } to { C@W ++ { 1.2 cm 0 } }
X}
X
X}
XEach galley has a @Eq { HEAD } node whose children are its component
Xobjects, separated by @Eq { GAP } nodes recording the inter-component
Xgaps.
X@PP
XEach component is preceded by zero or more @I {galley index nodes} of
Xvarious types.  Every receptive symbol has a @Eq { RECEPTIVE } index pointing
Xto it, so that it can be found without searching through its
Xcomponent.  If the symbol is currently the target of a galley, it has a
X@Eq { RECEIVING } index instead which is also linked to the incoming
Xgalley.  Galleys that are currently without a target are linked to the
Xdynamic tree by @Eq { UNATTACHED } galley indexes, either just after their
Xmost recent target if there has been one, or else at their point of
Xinvocation.
X@PP
XEach galley should be thought of as a concurrent process, although the
Ximplementation in C uses coroutines implemented by procedures.  A galley
Xmay promote its first component only if it has a target, sufficient space
Xis available at the target to receive the component, and the component
Xcontains no receptive symbols.  This last condition seems to be the key
Xto galley synchronization:  it forces a bottom-up promotion regime,
Xpreventing pages from flushing to output before text flushes into them,
Xfor example.
X@PP
XEach galley contains a number of binary semaphores, shown as asterisks
Xin our snapshots when set.  At any given moment, a galley process is
Xeither running or else is suspended on one of its own semaphores.  The
X@Eq { HEAD } node contains a semaphore which is set when the galley has tried
Xto find a target and failed.  Each receptive symbol has a semaphore
Xwhich is set when that symbol is preventing the first component from
Xbeing promoted.
X@PP
XFor example, in the snapshot at the beginning of this section, the root
Xgalley is suspended on the @Code "@Galley" symbol, but the text galley
Xis running.  It will suspend on the @Code "@Input" symbol after the
Xfirst two components are promoted.
X@PP
XEvery galley {@I G}, be it a list of pages, body text, a footnote, or
Xwhatever, executes the following algorithm in parallel with every other
Xgalley:
X@DP
X1.  Initially @I G is unattached.  Search forwards or backwards from its
X@Eq { UNATTACHED } index as required, to find a receptive symbol @I S which
Xcan expand to reveal a target for {@I G}.
X@DP
X2.  If no @I S can be found, suspend on the attachment semaphore.  Resume
Xlater from step 1.
X@DP
X3.  Expand @I S to reveal the target of {@I G}.  Preserve {@I S}'s
Xsemaphore by moving it to the first receptive symbol within the
Xexpansion of {@I S}.
X@DP
X4.  Calculate the available width and height at the target, and if
X@I G is still a pure parse tree, use the environment attached to @I G
Xand the style information from the target to evaluate @I G as in
XSection {@NumberOf functional}.
X@DP
X5.  Examine the components of @I G one by one.  For each component there
Xare three possibilities:
X@PP
X@I ACCEPT.  If the component fits into the available space, and has
Xno other problems, then promote it into the target.  If this is the
Xfirst component promoted into this target, and @I G is a forcing
Xgalley (Section {@NumberOf lookahead}), delete every receptive symbol
Xpreceding the target in the parent galley.  If @I G is the root galley,
Xrender the component on the output file and dispose it;
X@PP
X@I REJECT.  If the component is too large for the available space, or a
X@Eq { FOLLOWS } index (described below) forbids its promotion into this
Xtarget, then detach @I G from the target.  If this was the first component
Xat this target, @I S has been a complete failure, so undo step 3 (Basser
XLout is not able to undo step 4); otherwise delete the target.  Return to
Xstep 1 and continue immediately;
X@PP
X@I SUSPEND.  If the component contains a receptive symbol, it cannot be
Xpromoted yet.  If this symbol is the target of a galley that was written
Xto an auxiliary file on a previous run, read in that galley and flush
Xit.  Otherwise suspend on the receptive symbol's semaphore; resume later
Xfrom step 4.
X@DP
X6.  Terminate when the galley is empty.
X@DP
XAt various points in this algorithm, receptive symbols (and their
Xsemaphores) are deleted in the dynamic parent galley, possibly
Xpermitting it to resume flushing.  When this happens, Basser Lout resumes
Xthe parent immediately after @I G suspends or terminates.  Also,
Xwhenever a component is promoted, any child galleys connected to
Xit by @Eq { UNATTACHED } indexes must be resumed, since these
Xgalleys may be able to find a target now.  A good example of this
Xsituation occurs when a line of body text with one or more footnotes
Xis promoted onto a page.  Basser Lout gives priority to such children,
Xsuspending @I G while each is given a chance to flush.
X@PP
XBasser Lout searches for the first target of @I G only in regions of the
Xdynamic tree that will clearly precede or follow {@I G}'s invocation
Xpoint in the final printed document, whichever is specified in the
X@Code into clause; subsequent targets are sought later in the same
Xgalley as the first.  An exception to this rule, whose necessity will
Xbe made clear later, is that a first @Code following target will be
Xsought within a dynamic sibling galley preceding {@I G}'s invocation
Xpoint:
X@ID 10p @Font @Fig {
X
X{
X@I { dynamic parent }
X//0.2c
X@Box 2.8c @Wide 4.5c @High
X{
X   //0.5c A:: @Box margin { 0c } linestyle { noline } @Code "@XTarget"
X   //1.0c C:: @Box margin { 0c } linestyle { noline } @Eq { UNATTACHED }
X   //1.3c @Code "@XTarget"
X}
X}
X
X||1.5c
X
X{
X//0.6c
XB:: @Box margin {0c} linestyle {noline} @Code "X into { @XTarget&&following }"
X//0.2c
X@Box 2.8c @Wide 1.5c @High { //0.8c @Code "@GTarget" }
X//1.0c
XD:: @Box margin {0c} linestyle {noline} @Code "G into { @GTarget&&following }"
X//0.2c
X@Box 2.8c @Wide 2.5c @High {}
X}
X
X// @Arrow from { A@E ++ {0.2 cm 0} } to { B@W -- {0.2 cm 0} }
X// @Arrow from { C@E ++ {0.2 cm 0} } to { D@W -- {0.2 cm 0} }
X
X}
XHere @I G will find the @Code "@GTarget" target within {@I X}.  This is
Xdangerous, since if the first component of @I G is then promoted via
X@I X into the first {@Code "@XTarget"} rather than into the second,
X{@I G}'s target will not appear later in the final printed document than
Xits invocation point, as required by the @Code into clause.
X@PP
XAccordingly, when such a target is chosen, two special galley indexes
Xare inserted and linked together: a @Eq { PRECEDES } index at {@I G}'s
Xinvocation point, and a @Eq { FOLLOWS } index at the first component of
X{@I G}.  The algorithm checks before promoting any @Eq { FOLLOWS } index
Xthat its promotion would not place it earlier than the corresponding
X@Eq { PRECEDES } index in the same galley, and rejects the component if
Xit would.  Since @Eq { PRECEDES } and @Eq { FOLLOWS } indexes are rarely used,
Xthis check can be implemented by linear search.
X@PP
XWhen two components are separated by {@Code "/"}, as opposed to the more
Xusual {@Code "//"}, each influences the horizontal position of the
Xother.  Because of this, the @I SUSPEND action is in fact taken if a
Xreceptive symbol occurs in any component separated from the first by
X{@Code "/"} operators only.  Again, linear search forwards to the first
X{@Code "//"} suffices for this check.
X@PP
XA good illustration of these unusual cases is afforded by the
X@Code "@Align" symbols from the standard DocumentLayout package.  These
Xare used to produce displayed equations, aligned on their equals signs
Xdespite being separated by arbitrary body text.
X@PP
XThe @Code "@Align" symbols are packaged neatly for the convenience of
Xthe non-expert user, but we will show just the essence of the
Ximplementation here.  First, an @Code "@AlignList" galley is created
Xwhich contains an infinite supply of @Code "@AlignPlace" receptive
Xsymbols separated by @Code "/" operators:
X@ID @Fig {
X
X{
X@I { body text galley }
X//0.2c
X@Box 2.8c @Wide 4.0c @High
X{ //1.5c
X  A:: @Box margin { 0c } linestyle { noline } @Code "@Galley"
X}
X}
X
X||1.5c
X
X{
X//2.4c
XB:: @Box margin { 0c } linestyle { noline } @Code "@AlignList"
X//0.2c
X@Box {
X      @Code "@AlignPlace"
X//1vx @Code "@AlignPlace"
X//1vx @Code "..."
X//1vx @Code "@EndAlignList"
X}
X
X}
X
X// @Arrow from { A@E ++ {0.2 cm 0} } to { B@W -- {0.2 cm 0} }
X}
XThen equations like
X@ID @ShowMarks @Eq { f(x) ^= g(x) + 2 }
Xare created and sent to @Code "@AlignPlace&&following" targets.  They
Xcollect in the @Code "@AlignList" galley and are aligned there:
X@ID @Fig {
X
X{
X@I { body text galley }
X//0.2c
X@Box 2.8c @Wide 4.0c @High
X{ //1.5c
X  A:: @Box margin { 0c } linestyle { noline } @Code "@Galley"
X}
X}
X
X||1.5c
X
X{
X//2.4c
XB:: @Box margin { 0c } linestyle { noline } @Code "@AlignList"
X//0.2c
X@Box {
X   @Line linestyle { dashed } from { xmark ysize } to { xmark 0 }
X   {
X	     @Eq { f(x) ^= g(x) + 2 }
X	/1vx @Eq { f(x) - g(x) ^= 2 }
X	/1vx @Code "..."
X	/1vx @Code "@EndAlignList"
X   }
X}
X
X}
X
X// @Arrow from { A@E ++ {0.2 cm 0} } to { B@W -- {0.2 cm 0} }
X}
XThe @Code "@AlignList" galley does not flush, because its first
Xcomponent is connected to a receptive symbol by @Code "/" operators.
X@PP
XAfter the last equation, an empty forcing galley is sent to
X{@Code "@EndAlignList"}, deleting the two remaining receptive symbols from
Xthe @Code "@AlignList" galley and permitting it to flush.  @Eq { FOLLOWS }
Xindexes ensure that each equation finds a target placed in the body text
Xjust after its point of invocation, so the equations return, aligned, to
Xapproximately the points where they were invoked.  Notice that the flushing
Xof body text is suspended until the list of equations is completed, as it
Xmust be, since the horizontal position of the first equation cannot
Xbe known until the last equation is added to the list.
X@PP
XLayout quality can occasionally be improved by rejecting a component
Xthat could be promoted -- for example, a component of body text that
Xcarries a footnote too large to fit on the current page.  Since Lout
Xdoes not specify how breaking decisions are made, beyond the basic
Xconstraints imposed by available space and @Code into clauses, in
Xprinciple such high quality breaking could be added to the
Ximplementation with no change to the language.  However, the
Xgenerality of the galley flushing algorithm, and its already
Xconsiderable complexity, make this a daunting problem in practice,
Xalthough a fascinating one.  @TeX [9], with its unnested
Xset of `floating insertions' clearly identifiable as each page is begun,
Xhas the advantage in this respect.
X@End @SubSection
END_OF_FILE
  if test 14105 -ne `wc -c <'lout/doc/tr.impl/s5.2'`; then
    echo shar: \"'lout/doc/tr.impl/s5.2'\" unpacked with wrong size!
  fi
  # end of 'lout/doc/tr.impl/s5.2'
fi
if test -f 'lout/font0/TimesBolIta.AFM' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/font0/TimesBolIta.AFM'\"
else
  echo shar: Extracting \"'lout/font0/TimesBolIta.AFM'\" \(14435 characters\)
  sed "s/^X//" >'lout/font0/TimesBolIta.AFM' <<'END_OF_FILE'
XStartFontMetrics 2.0
XComment Copyright (c) 1984 Adobe Systems Incorporated.  All Rights Reserved.
XComment Creation Date:Wed May 27 16:42:35 PDT 1987
XFontName Times-BoldItalic
XEncodingScheme AdobeStandardEncoding
XFullName Times Bold Italic
XFamilyName Times
XWeight Bold
XItalicAngle -15.0
XIsFixedPitch false
XUnderlinePosition -98
XUnderlineThickness 54
XVersion 001.004
XNotice Times is a registered trademark of Allied Corporation.
XFontBBox -168 -232 1014 894
XCapHeight 662
XXHeight 458
XDescender -203
XAscender 682
XStartCharMetrics 228
XC 32 ; WX 250 ; N space ; B 0 0 0 0 ;
XC 33 ; WX 389 ; N exclam ; B 66 -13 367 676 ;
XC 34 ; WX 555 ; N quotedbl ; B 142 367 549 693 ;
XC 35 ; WX 500 ; N numbersign ; B 4 0 496 662 ;
XC 36 ; WX 500 ; N dollar ; B -20 -101 492 723 ;
XC 37 ; WX 833 ; N percent ; B 39 -8 784 685 ;
XC 38 ; WX 778 ; N ampersand ; B 41 -19 727 676 ;
XC 39 ; WX 333 ; N quoteright ; B 80 362 282 675 ;
XC 40 ; WX 333 ; N parenleft ; B 28 -179 340 676 ;
XC 41 ; WX 333 ; N parenright ; B -44 -179 268 676 ;
XC 42 ; WX 500 ; N asterisk ; B 56 244 445 676 ;
XC 43 ; WX 570 ; N plus ; B 33 0 537 505 ;
XC 44 ; WX 250 ; N comma ; B -10 -181 192 132 ;
XC 45 ; WX 333 ; N hyphen ; B 33 167 299 282 ;
XC 46 ; WX 250 ; N period ; B 23 -13 170 133 ;
XC 47 ; WX 278 ; N slash ; B -11 -18 289 682 ;
XC 48 ; WX 500 ; N zero ; B 17 -13 472 676 ;
XC 49 ; WX 500 ; N one ; B 5 0 415 676 ;
XC 50 ; WX 500 ; N two ; B -27 0 441 676 ;
XC 51 ; WX 500 ; N three ; B -15 -13 445 676 ;
XC 52 ; WX 500 ; N four ; B -15 0 498 676 ;
XC 53 ; WX 500 ; N five ; B -11 -13 482 662 ;
XC 54 ; WX 500 ; N six ; B 23 -13 504 676 ;
XC 55 ; WX 500 ; N seven ; B 51 0 519 662 ;
XC 56 ; WX 500 ; N eight ; B 3 -13 471 676 ;
XC 57 ; WX 500 ; N nine ; B -12 -13 470 676 ;
XC 58 ; WX 333 ; N colon ; B 52 -13 291 458 ;
XC 59 ; WX 333 ; N semicolon ; B 13 -181 291 458 ;
XC 60 ; WX 570 ; N less ; B 31 -14 540 524 ;
XC 61 ; WX 570 ; N equal ; B 33 116 537 401 ;
XC 62 ; WX 570 ; N greater ; B 31 -14 540 524 ;
XC 63 ; WX 500 ; N question ; B 78 -13 465 676 ;
XC 64 ; WX 832 ; N at ; B -9 -150 838 691 ;
XC 65 ; WX 667 ; N A ; B -51 0 602 676 ;
XC 66 ; WX 667 ; N B ; B -24 0 618 662 ;
XC 67 ; WX 667 ; N C ; B 22 -18 660 677 ;
XC 68 ; WX 722 ; N D ; B -31 0 693 662 ;
XC 69 ; WX 667 ; N E ; B -27 0 646 662 ;
XC 70 ; WX 667 ; N F ; B -20 0 646 662 ;
XC 71 ; WX 722 ; N G ; B 21 -18 699 676 ;
XC 72 ; WX 778 ; N H ; B -24 0 791 662 ;
XC 73 ; WX 389 ; N I ; B -22 0 412 662 ;
XC 74 ; WX 500 ; N J ; B -45 -98 519 662 ;
XC 75 ; WX 667 ; N K ; B -31 0 685 662 ;
XC 76 ; WX 611 ; N L ; B -22 0 584 662 ;
XC 77 ; WX 889 ; N M ; B -29 -12 907 662 ;
XC 78 ; WX 722 ; N N ; B -27 -18 740 662 ;
XC 79 ; WX 722 ; N O ; B 27 -18 684 676 ;
XC 80 ; WX 611 ; N P ; B -27 0 608 662 ;
XC 81 ; WX 722 ; N Q ; B 27 -203 684 676 ;
XC 82 ; WX 667 ; N R ; B -29 0 616 662 ;
XC 83 ; WX 556 ; N S ; B 6 -18 524 676 ;
XC 84 ; WX 611 ; N T ; B 39 0 632 662 ;
XC 85 ; WX 722 ; N U ; B 66 -18 736 662 ;
XC 86 ; WX 667 ; N V ; B 48 -18 692 662 ;
XC 87 ; WX 889 ; N W ; B 48 -18 914 662 ;
XC 88 ; WX 667 ; N X ; B -24 0 687 662 ;
XC 89 ; WX 611 ; N Y ; B 46 0 625 662 ;
XC 90 ; WX 611 ; N Z ; B -1 0 594 662 ;
XC 91 ; WX 333 ; N bracketleft ; B -7 -157 388 682 ;
XC 92 ; WX 278 ; N backslash ; B 1 0 465 682 ;
XC 93 ; WX 333 ; N bracketright ; B -65 -157 330 682 ;
XC 94 ; WX 570 ; N asciicircum ; B 34 259 536 662 ;
XC 95 ; WX 500 ; N underscore ; B 0 -127 500 -89 ;
XC 96 ; WX 333 ; N quoteleft ; B 117 363 319 676 ;
XC 97 ; WX 500 ; N a ; B 9 -14 480 458 ;
XC 98 ; WX 500 ; N b ; B 20 -13 473 682 ;
XC 99 ; WX 444 ; N c ; B 25 -13 418 458 ;
XC 100 ; WX 500 ; N d ; B 9 -13 541 682 ;
XC 101 ; WX 444 ; N e ; B 25 -13 413 458 ;
XC 102 ; WX 333 ; N f ; B -146 -203 460 682 ; L i fi ; L l fl ;
XC 103 ; WX 500 ; N g ; B -27 -203 498 458 ;
XC 104 ; WX 556 ; N h ; B 12 -13 518 682 ;
XC 105 ; WX 278 ; N i ; B 24 -13 283 676 ;
XC 106 ; WX 278 ; N j ; B -152 -203 311 676 ;
XC 107 ; WX 500 ; N k ; B 10 -13 511 682 ;
XC 108 ; WX 278 ; N l ; B 30 -13 311 682 ;
XC 109 ; WX 778 ; N m ; B 16 -13 744 458 ;
XC 110 ; WX 556 ; N n ; B 24 -13 518 458 ;
XC 111 ; WX 500 ; N o ; B 27 -13 467 458 ;
XC 112 ; WX 500 ; N p ; B -79 -203 481 458 ;
XC 113 ; WX 500 ; N q ; B 21 -203 486 459 ;
XC 114 ; WX 389 ; N r ; B 9 0 415 458 ;
XC 115 ; WX 389 ; N s ; B 16 -13 364 459 ;
XC 116 ; WX 278 ; N t ; B 15 -14 304 592 ;
XC 117 ; WX 556 ; N u ; B 47 -13 520 458 ;
XC 118 ; WX 444 ; N v ; B 50 -13 432 458 ;
XC 119 ; WX 667 ; N w ; B 50 -13 642 458 ;
XC 120 ; WX 500 ; N x ; B -5 -13 498 458 ;
XC 121 ; WX 444 ; N y ; B -60 -203 423 458 ;
XC 122 ; WX 389 ; N z ; B -24 -58 394 448 ;
XC 123 ; WX 348 ; N braceleft ; B 30 -154 380 686 ;
XC 124 ; WX 220 ; N bar ; B 70 0 151 682 ;
XC 125 ; WX 348 ; N braceright ; B -31 -161 319 679 ;
XC 126 ; WX 570 ; N asciitilde ; B 33 158 537 353 ;
XC 161 ; WX 389 ; N exclamdown ; B 20 -232 320 458 ;
XC 162 ; WX 500 ; N cent ; B 50 -142 443 570 ;
XC 163 ; WX 500 ; N sterling ; B -32 -13 505 676 ;
XC 164 ; WX 167 ; N fraction ; B -161 0 327 662 ;
XC 165 ; WX 500 ; N yen ; B -15 0 565 662 ;
XC 166 ; WX 500 ; N florin ; B -86 -154 530 682 ;
XC 167 ; WX 500 ; N section ; B 36 -143 454 676 ;
XC 168 ; WX 500 ; N currency ; B -3 110 503 612 ;
XC 169 ; WX 278 ; N quotesingle ; B 126 367 295 693 ;
XC 170 ; WX 500 ; N quotedblleft ; B 57 363 513 676 ;
XC 171 ; WX 500 ; N guillemotleft ; B 21 33 474 416 ;
XC 172 ; WX 333 ; N guilsinglleft ; B 42 33 310 416 ;
XC 173 ; WX 333 ; N guilsinglright ; B 22 38 290 421 ;
XC 174 ; WX 556 ; N fi ; B -157 -203 538 682 ;
XC 175 ; WX 556 ; N fl ; B -149 -203 577 682 ;
XC 177 ; WX 500 ; N endash ; B -11 176 511 266 ;
XC 178 ; WX 500 ; N dagger ; B 90 -146 489 676 ;
XC 179 ; WX 500 ; N daggerdbl ; B 11 -143 487 675 ;
XC 180 ; WX 250 ; N periodcentered ; B 51 179 200 328 ;
XC 182 ; WX 500 ; N paragraph ; B 61 -189 592 682 ;
XC 183 ; WX 350 ; N bullet ; B 50 175 300 425 ;
XC 184 ; WX 333 ; N quotesinglbase ; B 66 -181 268 132 ;
XC 185 ; WX 500 ; N quotedblbase ; B -57 -181 398 132 ;
XC 186 ; WX 500 ; N quotedblright ; B 56 362 509 675 ;
XC 187 ; WX 500 ; N guillemotright ; B 20 38 473 421 ;
XC 188 ; WX 1000 ; N ellipsis ; B 93 -13 906 133 ;
XC 189 ; WX 1000 ; N perthousand ; B 7 -49 985 699 ;
XC 191 ; WX 500 ; N questiondown ; B 30 -203 417 487 ;
XC 193 ; WX 333 ; N grave ; B 115 511 325 690 ;
XC 194 ; WX 333 ; N acute ; B 168 511 405 690 ;
XC 195 ; WX 333 ; N circumflex ; B 70 510 394 682 ;
XC 196 ; WX 333 ; N tilde ; B 69 530 424 648 ;
XC 197 ; WX 333 ; N macron ; B 81 547 420 616 ;
XC 198 ; WX 333 ; N breve ; B 98 511 413 671 ;
XC 199 ; WX 333 ; N dotaccent ; B 180 519 308 648 ;
XC 200 ; WX 333 ; N dieresis ; B 85 519 424 648 ;
XC 202 ; WX 333 ; N ring ; B 141 466 352 676 ;
XC 203 ; WX 333 ; N cedilla ; B 32 -216 264 5 ;
XC 205 ; WX 333 ; N hungarumlaut ; B 28 538 339 750 ;
XC 206 ; WX 333 ; N ogonek ; B -36 -173 193 44 ;
XC 207 ; WX 333 ; N caron ; B 109 511 437 683 ;
XC 208 ; WX 1000 ; N emdash ; B -14 176 1014 266 ;
XC 225 ; WX 944 ; N AE ; B -41 0 931 662 ;
XC 227 ; WX 266 ; N ordfeminine ; B -24 286 291 676 ;
XC 232 ; WX 611 ; N Lslash ; B -22 0 584 662 ;
XC 233 ; WX 722 ; N Oslash ; B 27 -124 684 754 ;
XC 234 ; WX 944 ; N OE ; B 23 -8 936 670 ;
XC 235 ; WX 300 ; N ordmasculine ; B 1 286 300 676 ;
XC 241 ; WX 722 ; N ae ; B 15 -13 685 458 ;
XC 245 ; WX 278 ; N dotlessi ; B 27 -13 260 458 ;
XC 248 ; WX 278 ; N lslash ; B 12 -13 326 682 ;
XC 249 ; WX 500 ; N oslash ; B 27 -118 467 556 ;
XC 250 ; WX 722 ; N oe ; B 26 -13 687 458 ;
XC 251 ; WX 500 ; N germandbls ; B -168 -203 497 682 ;
XC -1 ; WX 667 ; N Aacute ; B -51 0 602 894 ;
XC -1 ; WX 667 ; N Acircumflex ; B -51 0 602 886 ;
XC -1 ; WX 667 ; N Adieresis ; B -51 0 602 852 ;
XC -1 ; WX 667 ; N Agrave ; B -51 0 602 894 ;
XC -1 ; WX 667 ; N Aring ; B -51 0 602 880 ;
XC -1 ; WX 667 ; N Atilde ; B -51 0 602 852 ;
XC -1 ; WX 667 ; N Ccedilla ; B 22 -216 660 677 ;
XC -1 ; WX 667 ; N Eacute ; B -27 0 646 894 ;
XC -1 ; WX 667 ; N Ecircumflex ; B -27 0 646 886 ;
XC -1 ; WX 667 ; N Edieresis ; B -27 0 646 852 ;
XC -1 ; WX 667 ; N Egrave ; B -27 0 646 894 ;
XC -1 ; WX 722 ; N Eth ; B -31 0 693 662 ;
XC -1 ; WX 389 ; N Iacute ; B -22 0 433 894 ;
XC -1 ; WX 389 ; N Icircumflex ; B -22 0 422 886 ;
XC -1 ; WX 389 ; N Idieresis ; B -22 0 452 852 ;
XC -1 ; WX 389 ; N Igrave ; B -22 0 412 894 ;
XC -1 ; WX 722 ; N Ntilde ; B -27 -18 740 852 ;
XC -1 ; WX 722 ; N Oacute ; B 27 -18 684 894 ;
XC -1 ; WX 722 ; N Ocircumflex ; B 27 -18 684 886 ;
XC -1 ; WX 722 ; N Odieresis ; B 27 -18 684 852 ;
XC -1 ; WX 722 ; N Ograve ; B 27 -18 684 894 ;
XC -1 ; WX 722 ; N Otilde ; B 27 -18 684 852 ;
XC -1 ; WX 556 ; N Scaron ; B 6 -18 549 887 ;
XC -1 ; WX 611 ; N Thorn ; B -27 0 572 662 ;
XC -1 ; WX 722 ; N Uacute ; B 66 -18 736 894 ;
XC -1 ; WX 722 ; N Ucircumflex ; B 66 -18 736 886 ;
XC -1 ; WX 722 ; N Udieresis ; B 66 -18 736 852 ;
XC -1 ; WX 722 ; N Ugrave ; B 66 -18 736 894 ;
XC -1 ; WX 611 ; N Yacute ; B 46 0 625 894 ;
XC -1 ; WX 611 ; N Ydieresis ; B 46 0 625 852 ;
XC -1 ; WX 611 ; N Zcaron ; B -1 0 594 887 ;
XC -1 ; WX 500 ; N aacute ; B 9 -14 489 690 ;
XC -1 ; WX 500 ; N acircumflex ; B 9 -14 480 682 ;
XC -1 ; WX 500 ; N adieresis ; B 9 -14 508 648 ;
XC -1 ; WX 500 ; N agrave ; B 9 -14 480 690 ;
XC -1 ; WX 500 ; N aring ; B 9 -14 480 676 ;
XC -1 ; WX 500 ; N atilde ; B 9 -14 508 648 ;
XC -1 ; WX 220 ; N brokenbar ; B 70 0 151 682 ;
XC -1 ; WX 444 ; N ccedilla ; B 25 -216 418 458 ;
XC -1 ; WX 747 ; N copyright ; B 23 -18 723 676 ;
XC -1 ; WX 400 ; N degree ; B 70 376 370 676 ;
XC -1 ; WX 570 ; N divide ; B 33 0 537 505 ;
XC -1 ; WX 444 ; N eacute ; B 25 -13 461 690 ;
XC -1 ; WX 444 ; N ecircumflex ; B 25 -13 450 682 ;
XC -1 ; WX 444 ; N edieresis ; B 25 -13 480 648 ;
XC -1 ; WX 444 ; N egrave ; B 25 -13 413 690 ;
XC -1 ; WX 500 ; N eth ; B 27 -13 498 682 ;
XC -1 ; WX 278 ; N iacute ; B 27 -13 378 690 ;
XC -1 ; WX 278 ; N icircumflex ; B 27 -13 367 682 ;
XC -1 ; WX 278 ; N idieresis ; B 27 -13 397 648 ;
XC -1 ; WX 278 ; N igrave ; B 27 -13 298 690 ;
XC -1 ; WX 606 ; N logicalnot ; B 51 120 555 401 ;
XC -1 ; WX 606 ; N minus ; B 51 210 555 300 ;
XC -1 ; WX 576 ; N mu ; B -62 -210 522 458 ;
XC -1 ; WX 570 ; N multiply ; B 33 0 537 504 ;
XC -1 ; WX 556 ; N ntilde ; B 24 -13 536 648 ;
XC -1 ; WX 500 ; N oacute ; B 27 -13 489 690 ;
XC -1 ; WX 500 ; N ocircumflex ; B 27 -13 478 682 ;
XC -1 ; WX 500 ; N odieresis ; B 27 -13 508 648 ;
XC -1 ; WX 500 ; N ograve ; B 27 -13 467 690 ;
XC -1 ; WX 750 ; N onehalf ; B 30 0 720 676 ;
XC -1 ; WX 750 ; N onequarter ; B 30 0 720 676 ;
XC -1 ; WX 300 ; N onesuperior ; B 17 270 283 676 ;
XC -1 ; WX 500 ; N otilde ; B 27 -13 508 648 ;
XC -1 ; WX 570 ; N plusminus ; B 33 0 537 665 ;
XC -1 ; WX 747 ; N registered ; B 23 -18 723 676 ;
XC -1 ; WX 389 ; N scaron ; B 16 -13 465 683 ;
XC -1 ; WX 500 ; N thorn ; B -79 -203 474 682 ;
XC -1 ; WX 750 ; N threequarters ; B 30 0 720 676 ;
XC -1 ; WX 300 ; N threesuperior ; B 0 263 299 676 ;
XC -1 ; WX 1000 ; N trademark ; B 40 272 980 676 ;
XC -1 ; WX 300 ; N twosuperior ; B -2 270 302 676 ;
XC -1 ; WX 556 ; N uacute ; B 47 -13 520 690 ;
XC -1 ; WX 556 ; N ucircumflex ; B 47 -13 520 682 ;
XC -1 ; WX 556 ; N udieresis ; B 47 -13 536 648 ;
XC -1 ; WX 556 ; N ugrave ; B 47 -13 520 690 ;
XC -1 ; WX 444 ; N yacute ; B -60 -203 461 690 ;
XC -1 ; WX 444 ; N ydieresis ; B -60 -203 480 648 ;
XC -1 ; WX 389 ; N zcaron ; B -24 -58 465 683 ;
XEndCharMetrics
XStartKernData
XStartKernPairs 108
X
XKPX A y -74
XKPX A w -74
XKPX A v -74
XKPX A space -55
XKPX A quoteright -74
XKPX A Y -55
XKPX A W -92
XKPX A V -74
XKPX A T -55
X
XKPX F space -18
XKPX F period -129
XKPX F comma -129
XKPX F A -92
X
XKPX L y -37
XKPX L space -37
XKPX L quoteright -55
XKPX L Y -37
XKPX L W -37
XKPX L V -37
XKPX L T -18
X
XKPX P space -37
XKPX P period -129
XKPX P comma -129
XKPX P A -74
X
XKPX R y -18
XKPX R Y -18
XKPX R W -18
XKPX R V -18
X
XKPX T y -37
XKPX T w -37
XKPX T u -37
XKPX T semicolon -74
XKPX T s -92
XKPX T r -37
XKPX T period -92
XKPX T o -92
XKPX T i -37
XKPX T hyphen -92
XKPX T e -92
XKPX T comma -92
XKPX T colon -74
XKPX T c -92
XKPX T a -92
XKPX T O -18
XKPX T A -55
X
XKPX V y -74
XKPX V u -55
XKPX V space -18
XKPX V semicolon -74
XKPX V r -55
XKPX V period -129
XKPX V o -111
XKPX V i -55
XKPX V hyphen -55
XKPX V e -111
XKPX V comma -129
XKPX V colon -74
XKPX V a -111
XKPX V A -74
X
XKPX W y -55
XKPX W u -55
XKPX W space -18
XKPX W semicolon -55
XKPX W r -74
XKPX W period -74
XKPX W o -74
XKPX W i -37
XKPX W hyphen -37
XKPX W e -74
XKPX W comma -74
XKPX W colon -55
XKPX W a -74
XKPX W A -74
X
XKPX Y v -92
XKPX Y u -92
XKPX Y space -37
XKPX Y semicolon -92
XKPX Y q -111
XKPX Y period -74
XKPX Y p -74
XKPX Y o -111
XKPX Y i -55
XKPX Y hyphen -92
XKPX Y e -111
XKPX Y comma -92
XKPX Y colon -92
XKPX Y a -92
XKPX Y A -74
X
XKPX f quoteright 55
XKPX f f -18
X
XKPX one one -55
X
XKPX quoteleft quoteleft -74
X
XKPX quoteright t -37
XKPX quoteright space -74
XKPX quoteright s -74
XKPX quoteright quoteright -74
X
XKPX r quoteright 37
XKPX r period -55
XKPX r comma -55
X
XKPX space Y -18
XKPX space W -18
XKPX space A -37
X
XKPX v period -37
XKPX v comma -37
X
XKPX w period -37
XKPX w comma -37
X
XKPX y period -37
XKPX y comma -37
XEndKernPairs
XEndKernData
XStartComposites 58
XCC Zcaron 2 ; PCC Z 0 0 ; PCC caron 139 204 ;
XCC zcaron 2 ; PCC z 0 0 ; PCC caron 28 0 ;
XCC Scaron 2 ; PCC S 0 0 ; PCC caron 111 204 ;
XCC scaron 2 ; PCC s 0 0 ; PCC caron 28 0 ;
XCC Ccedilla 2 ; PCC C 0 0 ; PCC cedilla 167 0 ;
XCC ccedilla 2 ; PCC c 0 0 ; PCC cedilla 55 0 ;
XCC Yacute 2 ; PCC Y 0 0 ; PCC acute 139 204 ;
XCC yacute 2 ; PCC y 0 0 ; PCC acute 55 0 ;
XCC Ydieresis 2 ; PCC Y 0 0 ; PCC dieresis 139 204 ;
XCC ydieresis 2 ; PCC y 0 0 ; PCC dieresis 55 0 ;
XCC Uacute 2 ; PCC U 0 0 ; PCC acute 194 204 ;
XCC Ucircumflex 2 ; PCC U 0 0 ; PCC circumflex 194 204 ;
XCC Udieresis 2 ; PCC U 0 0 ; PCC dieresis 194 204 ;
XCC Ugrave 2 ; PCC U 0 0 ; PCC grave 194 204 ;
XCC uacute 2 ; PCC u 0 0 ; PCC acute 111 0 ;
XCC ucircumflex 2 ; PCC u 0 0 ; PCC circumflex 111 0 ;
XCC udieresis 2 ; PCC u 0 0 ; PCC dieresis 111 0 ;
XCC ugrave 2 ; PCC u 0 0 ; PCC grave 111 0 ;
XCC Iacute 2 ; PCC I 0 0 ; PCC acute 28 204 ;
XCC Icircumflex 2 ; PCC I 0 0 ; PCC circumflex 28 204 ;
XCC Idieresis 2 ; PCC I 0 0 ; PCC dieresis 28 204 ;
XCC Igrave 2 ; PCC I 0 0 ; PCC grave 28 204 ;
XCC iacute 2 ; PCC dotlessi 0 0 ; PCC acute -27 0 ;
XCC icircumflex 2 ; PCC dotlessi 0 0 ; PCC circumflex -27 0 ;
XCC idieresis 2 ; PCC dotlessi 0 0 ; PCC dieresis -27 0 ;
XCC igrave 2 ; PCC dotlessi 0 0 ; PCC grave -27 0 ;
XCC Eacute 2 ; PCC E 0 0 ; PCC acute 167 204 ;
XCC Ecircumflex 2 ; PCC E 0 0 ; PCC circumflex 167 204 ;
XCC Edieresis 2 ; PCC E 0 0 ; PCC dieresis 167 204 ;
XCC Egrave 2 ; PCC E 0 0 ; PCC grave 167 204 ;
XCC eacute 2 ; PCC e 0 0 ; PCC acute 55 0 ;
XCC ecircumflex 2 ; PCC e 0 0 ; PCC circumflex 55 0 ;
XCC edieresis 2 ; PCC e 0 0 ; PCC dieresis 55 0 ;
XCC eg
END_OF_FILE
  echo shar: appended 1 NEWLINEs to \"'lout/font0/TimesBolIta.AFM'\"
  if test 14436 -ne `wc -c <'lout/font0/TimesBolIta.AFM'`; then
    echo shar: \"'lout/font0/TimesBolIta.AFM'\" unpacked with wrong size!
  fi
  # end of 'lout/font0/TimesBolIta.AFM'
fi
if test -f 'lout/gnu.gpl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/gnu.gpl'\"
else
  echo shar: Extracting \"'lout/gnu.gpl'\" \(12487 characters\)
  sed "s/^X//" >'lout/gnu.gpl' <<'END_OF_FILE'
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
Xat the mercy of those companies.  By contrast, our General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  The
XGeneral Public License applies to the Free Software Foundation's
Xsoftware and to any other program whose authors commit to using it.
XYou can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Specifically, the General Public License is designed to make
Xsure that you have the freedom to give away or sell copies of free
Xsoftware, that you receive source code or can get it if you want it,
Xthat you can change the software or use pieces of it in new free
Xprograms; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
Xcontains a notice placed by the copyright holder saying it may be
Xdistributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
Xon the Program" means either the Program or any work containing the
XProgram or a portion of it, either verbatim or with modifications.  Each
Xlicensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
Xcode as you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy an appropriate copyright notice and
Xdisclaimer of warranty; keep intact all the notices that refer to this
XGeneral Public License and to the absence of any warranty; and give any
Xother recipients of the Program a copy of this General Public License
Xalong with the Program.  You may charge a fee for the physical act of
Xtransferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
Xit, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
XMere aggregation of another independent work with the Program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
Xit, under Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XSource code for a work means the preferred form of the work for making
Xmodifications to it.  For an executable file, complete source code means
Xall the source code for all modules it contains; but, as a special
Xexception, it need not include source code for modules which are standard
Xlibraries that accompany the operating system on which the executable
Xfile runs, or for standard header files or definitions files that
Xaccompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
XProgram except as expressly provided under this General Public License.
XAny attempt otherwise to copy, modify, sublicense, distribute or transfer
Xthe Program is void, and will automatically terminate your rights to use
Xthe Program under this License.  However, parties who have received
Xcopies, or rights to use copies, from you under this General Public
XLicense will not have their licenses terminated so long as such parties
Xremain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
Xon the Program) you indicate your acceptance of this license to do so,
Xand all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the original
Xlicensor to copy, distribute or modify the Program subject to these
Xterms and conditions.  You may not impose any further restrictions on the
Xrecipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of the license which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthe license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
Xpossible use to humanity, the best way to achieve this is to make it
Xfree software which everyone can redistribute and change under these
Xterms.
X
X  To do so, attach the following notices to the program.  It is safest to
Xattach them to the start of each source file to most effectively convey
Xthe exclusion of warranty; and each file should have at least the
X"copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 1, or (at your option)
X    any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
XAlso add information on how to contact you by electronic and paper mail.
X
XIf the program is interactive, make it output a short notice like this
Xwhen it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19xx name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
XThe hypothetical commands `show w' and `show c' should show the
Xappropriate parts of the General Public License.  Of course, the
Xcommands you use may be called something other than `show w' and `show
Xc'; they could even be mouse-clicks or menu items--whatever suits your
Xprogram.
X
XYou should also get your employer (if you work as a programmer) or your
Xschool, if any, to sign a "copyright disclaimer" for the program, if
Xnecessary.  Here a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the
X  program `Gnomovision' (a program to direct compilers to make passes
X  at assemblers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
XThat's all there is to it!
END_OF_FILE
  if test 12487 -ne `wc -c <'lout/gnu.gpl'`; then
    echo shar: \"'lout/gnu.gpl'\" unpacked with wrong size!
  fi
  # end of 'lout/gnu.gpl'
fi
if test -f 'lout/z09.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z09.c'\"
else
  echo shar: Extracting \"'lout/z09.c'\" \(14080 characters\)
  sed "s/^X//" >'lout/z09.c' <<'END_OF_FILE'
X/*@z09.c:Closure Expansion:ClosureExpand()@***********************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z09.c                                                      */
X/*  MODULE:       Closure Expansion                                          */
X/*  EXTERNS:      SetEnv(), AttachEnv(), GetEnv(), SearchEnv(),              */
X/*                ClosureExpand()                                            */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT SearchEnv(env, sym)                                               */
X/*                                                                           */
X/*  Search environment env for a symbol such that actual() == sym.           */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT SearchEnv(env, sym)
XOBJECT env, sym;
X{ OBJECT link, y;
X  debug2(DCE, DD, "SearchEnv(%s, %s)", EchoObject(null, env), SymName(sym));
X  for(;;)
X  {
X    debug1(DCE, DDD, "  searching env %s", EchoObject(null, env));
X    assert( env != nil && type(env) == ENV, "SearchEnv: env!" );
X    if( Down(env) == env )
X    { debug0(DCE, DD, "SearchEnv returning <nil>");
X      return nil;
X    }
X    Child(y, Down(env));
X    assert( type(y) == CLOSURE, "SearchEnv: type(y) != CLOSURE!" );
X    if( actual(y) == sym )
X    { debug1(DCE, DD, "SearchEnv returning %s", EchoObject(null, y));
X      return y;
X    }
X    assert( LastDown(y) != y, "SearchEnv: LastDown(y) == y!" );
X    link = LastDown(env) != Down(env) ? LastDown(env) : LastDown(y);
X    Child(env, link);
X  }
X} /* end SearchEnv */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static OBJECT EvalNext(x, env)                                           */
X/*                                                                           */
X/*  Evaluate x, which is a @Next something object, in environment env.       */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic OBJECT EvalNext(x, env)
XOBJECT x, env;
X{ OBJECT y, prnt, link, par, py;
X  BOOLEAN done;
X  assert( type(x) == NEXT, "EvalNext: x is not NEXT!" );
X  assert( Down(x) != x, "EvalNext: x has no child!" );
X  assert( env == nil || type(env) == ENV, "EvalNext: env!" );
X  debug2(DCE,DD, "EvalNext(%s, %s)", EchoObject(null,x), EchoObject(null,env));
X  Child(y, Down(x));
X
X  /* if argument of @Next can be evaluated, do so */
X  if( type(y) == NEXT )  y = EvalNext(y, env);
X  else if( type(y) == CLOSURE && is_par(type(actual(y))) )
X  { prnt = SearchEnv(env, enclosing(actual(y)));
X    if( prnt == nil )
X    { Error(WARN,&fpos(y),"environment missing when evaluating %s", KW_NEXT);
X    }
X    else
X    { assert( prnt != nil, "EvalNext: prnt == nil!" );
X      for( link = Down(prnt);  link != prnt;  link = NextDown(link) )
X      {	Child(par, link);
X	if( type(par) == PAR && actual(par) == actual(y) )
X	{ assert( Down(par) != par, "AttachEnv: par!" );
X	  Child(py, Down(par));
X	  if( type(py) == WORD )
X	  { y = CopyObject(py, &fpos(py));
X	    DisposeChild(Down(x));
X	    Link(x, y);
X	  }
X	  break;
X	}
X      }
X    }
X  }
X
X  /* if argument of @Next is a WORD, increment it */
X  if( type(y) == WORD )
X  { done = FALSE;
X    y = Next(y, 1, &done);
X    ReplaceNode(y, x);
X    DisposeObject(x);
X    x = y;
X  }
X
X  debug1(DCE, DD, "EvalNext returning %s", EchoObject(null, x));
X  return x;
X} /* end EvalNext */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT SetEnv(x, y)                                                      */
X/*                                                                           */
X/*  Create a new environment containing x and possibly y.                    */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT SetEnv(x, y)
XOBJECT x, y;
X{ OBJECT res;
X  debug2(DCE, D, "SetEnv( %s, %s )", EchoObject(null, x), EchoObject(null, y));
X  assert( x != nil && type(x) == CLOSURE, "SetEnv: x == nil or not CLOSURE!" );
X  assert( y == nil || type(y) == ENV, "SetEnv: y != nil && type(y) != ENV!" );
X  res = New(ENV);
X  Link(res, x);
X  if( y != nil )  Link(res, y);
X  debug1(DCE, D, "SetEnv returning %s", EchoObject(null, res));
X  return res;
X} /* end SetEnv */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  AttachEnv(env, x)                                                        */
X/*                                                                           */
X/*  Attach environment env to CLOSURE x.                                     */
X/*                                                                           */
X/*****************************************************************************/
X
XAttachEnv(env, x)
XOBJECT env, x;
X{ debug2(DCE,D,"AttachEnv( %s, %s )", EchoObject(null,env), EchoObject(null,x));
X  assert( env != nil && type(env) == ENV, "AttachEnv: type(env) != ENV!" );
X  assert( type(x) == CLOSURE, "AttachEnv: type(x) != CLOSURE!" );
X  Link(x, env);
X  debug0(DCE, D, "AttachEnv returning.");
X} /* end AttachEnv */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT GetEnv(x)                                                         */
X/*                                                                           */
X/*  Get from CLOSURE x the environment previously attached.                  */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT GetEnv(x)
XOBJECT x;
X{ OBJECT env;
X  debug1(DCE, DD, "GetEnv( %s )", EchoObject(null, x));
X  assert( type(x) == CLOSURE, "GetEnv: type(x) != CLOSURE!" );
X  assert( LastDown(x) != x, "GetEnv: LastDown(x) == x!" );
X  Child(env, LastDown(x));
X  assert( type(env) == ENV, "GetEnv: type(env) != ENV!" );
X  debug1(DCE, DD, "GetEnv resturning %s", EchoObject(null, env));
X  return env;
X} /* end GetEnv */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DetachEnv(x)                                                      */
X/*                                                                           */
X/*  Detach from CLOSURE x the environment previously attached.               */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT DetachEnv(x)
XOBJECT x;
X{ OBJECT env;
X  debug1(DCE, DD, "DetachEnv( %s )", EchoObject(null, x));
X  assert( type(x) == CLOSURE, "DetachEnv: type(x) != CLOSURE!" );
X  assert( LastDown(x) != x, "DetachEnv: LastDown(x) == x!" );
X  Child(env, LastDown(x));
X  DeleteLink(LastDown(x));
X  assert( type(env) == ENV, "DetachEnv: type(env) != ENV!" );
X  debug1(DCE, DD, "DetachEnv resturning %s", EchoObject(null, env));
X  return env;
X} /* end DetachEnv */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT ClosureExpand(x, env, style, crs_wanted, crs, res_env)            */
X/*                                                                           */
X/*  Return expansion of closure x in environment env and style style.        */
X/*  The body comes from x's environment if x is a parameter, else from the   */
X/*  symbol table.  The original x is pushed into the environments.           */
X/*                                                                           */
X/*  If crs_wanted and x has a tag, a cross-reference is added to crs.        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT ClosureExpand(x, env, style, crs_wanted, crs, res_env)
XOBJECT x, env;  STYLE *style;  BOOLEAN crs_wanted;  OBJECT *crs, *res_env;
X{ OBJECT link, y, res, prnt_env, par, prnt, ppar;
X  debug3(DCE, D, "ClosureExpand( %s, crs, %s, %s, res_env )",
X		EchoObject(null, x), bool(crs_wanted), EchoObject(null, env));
X  assert( type(x) == CLOSURE, "ClosureExpand given non-CLOSURE!");
X  assert( predefined(actual(x)) == FALSE, "ClosureExpand given predefined!" );
X
X  /* add a tag to x if needed but none provided */
X  if( has_tag(actual(x)) )
X  { for( link = Down(x);  link != x;  link = NextDown(link) )
X    { Child(par, link);
X      if( type(par) == PAR && is_tag(actual(par)) )  break;
X    }
X    if( link == x )
X    { ppar = nil;
X      for( link=Down(actual(x));  link != actual(x);  link = NextDown(link) )
X      {	Child(y, link);
X	if( is_par(type(y)) && is_tag(y) )
X	{ ppar = y;
X	  break;
X	}
X      }
X      if( ppar != nil )
X      {
X	/* prepare new PAR containing generated tag */
X	par = New(PAR);
X	actual(par) = ppar;
X	y = CrossGenTag(x);
X	Link(par, y);
X
X	/* find the right spot, then link it to x */
X	switch( type(ppar) )
X	{
X	  case LPAR:	link = Down(x);
X			break;
X
X	  case NPAR:	link = Down(x);
X			if( Down(x) != x )
X			{ Child(y, Down(x));
X			  if( type(y) == PAR && type(actual(par)) == LPAR )
X				link = NextDown(link);
X			}
X			break;
X
X	  case RPAR:	for( link = Down(x); link != x; link = NextDown(link) )
X			{ Child(y, link);
X			  if( type(y) != PAR )  break;
X			}
X			break;
X	}
X	Link(link, par);
X      }
X    }
X  }
X
X  /* add cross-reference to crs if needed */
X  if( crs_wanted && has_tag(actual(x)) )
X  { OBJECT tmp;
X    tmp = CopyObject(x, no_fpos);  AttachEnv(env, tmp);
X    y = CrossMake(actual(x), tmp, CROSS_TARG);
X    tmp = New(CROSS_TARG);
X    actual(tmp) = y;
X    Link(tmp, y);
X    if( *crs == nil )  *crs = New(CR_LIST);
X    Link(*crs, tmp);
X  }
X
X
X  /* case x is a parameter */
X  res = *res_env = nil;
X  if( is_par(type(actual(x))) )
X  {
X    prnt = SearchEnv(env, enclosing(actual(x)));
X    if( prnt == nil )
X      Error(FATAL, &fpos(x), "symbol with import list used illegally");
X    assert( prnt != nil, "ClosureExpand: is_par but prnt == nil!" );
X    prnt_env = GetEnv(prnt);
X    for( link = Down(prnt);  link != prnt;  link = NextDown(link) )
X    { Child(par, link);
X      if( type(par) == PAR && actual(par) == actual(x) )
X      {	assert( Down(par) != par, "ExpandCLosure: Down(par)!");
X	Child(res, Down(par));
X	if( dirty(enclosing(actual(par))) )
X	{ debug2(DSU, DD, "  copying %s %s",
X		SymName(actual(par)), EchoObject(null, res));
X	  res = CopyObject(res, no_fpos);
X	}
X	else
X	{ debug2(DSU, DD, "  linking %s %s",
X		SymName(actual(par)), EchoObject(null, res));
X	  DeleteLink(Down(par));
X	  y = MakeWord("??", &fpos(res));
X	  Link(par, y);
X	}
X	ReplaceNode(res, x);
X	if( type(actual(x)) == RPAR && has_body(enclosing(actual(x))) )
X	{ *res_env = SetEnv(prnt, nil);
X	  DisposeObject(x);
X	}
X	else
X	{ AttachEnv(env, x);
X	  *res_env = SetEnv(x, prnt_env);
X	}
X	break;
X      }
X    }
X  }
X
X  /* case x is a user-defined symbol or default parameter */
X  if( res == nil )
X  { if( sym_body(actual(x)) == nil )  res = MakeWord("??", &fpos(x));
X    else res = CopyObject(sym_body(actual(x)), &fpos(x));
X    ReplaceNode(res, x);
X    AttachEnv(env, x);
X    *res_env = SetEnv(x, nil);
X  }
X
X  assert( *res_env != nil && type(*res_env) == ENV, "ClosureExpand: *res_env!");
X  debug0(DCE, D, "ClosureExpand returning, res =");
X  ifdebug(DCE, D, EchoObject(stderr, res));
X  debug1(DCE, DD, "  environment = %s", EchoObject(null, *res_env));
X  return res;
X} /* end ClosureExpand */
END_OF_FILE
  if test 14080 -ne `wc -c <'lout/z09.c'`; then
    echo shar: \"'lout/z09.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z09.c'
fi
if test -f 'lout/z21.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z21.c'\"
else
  echo shar: Extracting \"'lout/z21.c'\" \(10867 characters\)
  sed "s/^X//" >'lout/z21.c' <<'END_OF_FILE'
X/*@z21.c:Galley Maker:SizeGalley()@*******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z21.c                                                      */
X/*  MODULE:       Galley Maker                                               */
X/*  EXTERNS:      SizeGalley()                                               */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  SizeGalley(hd, env, rows, joined, nonblock, trig, style, c, target,      */
X/*                                                dest_index, recs, inners)  */
X/*                                                                           */
X/*  Convert unsized galley hd into sized format.  The input parameters are:  */
X/*                                                                           */
X/*    hd          the galley to be converted                                 */
X/*    env         its environment                                            */
X/*    rows        TRUE if the resulting galley may have more than one row    */
X/*    joined      TRUE if the resulting galley must be simply joined         */
X/*    nonblock    Set the non_blocking() field of RECEPTIVEs to this value   */
X/*    trig        TRUE if galley's indefinites may trigger external galleys  */
X/*    *style      The initial style                                          */
X/*    *c          the width constraint hd should conform to                  */
X/*    target      if non-nil, expand indefinite objects to reveal a          */
X/*                @Galley within this symbol                                 */
X/*                                                                           */
X/*  The output parameters, in addition to the converted hd, are:             */
X/*                                                                           */
X/*    dest_index  the index of the @Galley found within target, if any       */
X/*    recs        list of all RECURSIVE indexes found (or nil if none)       */
X/*    inners      list of all UNATTACHED indexes found (or nil if none)      */
X/*                                                                           */
X/*****************************************************************************/
X
XSizeGalley(hd, env, rows, joined, nonblock, trig, style, c, target,
X						dest_index, recs, inners)
XOBJECT hd, env;  BOOLEAN rows, joined, nonblock, trig;  STYLE *style;
XCONSTRAINT *c;  OBJECT target, *dest_index, *recs, *inners;
X{ OBJECT y, link, z, crs, t, tlink, zlink, tmp;
X  OBJECT extras, tmp1, tmp2, bt[2], ft[2];
X  
X  assert( type(hd) == HEAD && Down(hd) != hd, "SizeGalley: precondition!" );
X  assert( !sized(hd), "SizeGalley: already sized!" );
X  debug6(DGM, D, "SizeGalley(hd, -, %s, %s, %s, %s, %s, %s, -, -, -), hd =",
X	bool(joined), bool(nonblock), bool(trig), EchoStyle(style),
X	EchoConstraint(c), SymName(target));
X  ifdebug(DGM, DD, EchoObject(stderr, hd));
X
X  /* manifest hd's child, making sure it is simply joined if required */
X  tmp1 = target;
X  Child(y, Down(hd));
X  crs = nil;
X  bt[COL] = ft[COL] = bt[ROW] = ft[ROW] = nil;
X  if( joined )
X  { bt[COL] = New(THREAD);  ft[COL] = New(THREAD);
X    y = Manifest(y, env, style, bt, ft, &tmp1, &crs, TRUE, must_expand(hd));
X    assert( Down(bt[COL]) != bt[COL] && Down(ft[COL]) != ft[COL],
X	"SizeGalley: threads!" );
X    Child(tmp1, Down(bt[COL]));  Child(tmp2, Down(ft[COL]));
X    if( Down(bt[COL]) != LastDown(bt[COL]) ||
X	  Down(ft[COL]) != LastDown(ft[COL]) || tmp1 != tmp2 )
X      Error(FATAL, &fpos(y), "galley %s must have just one column mark",
X						SymName(actual(hd)) );
X    DisposeObject(bt[COL]);  DisposeObject(ft[COL]);
X  }
X  else y = Manifest(y, env, style, bt, ft, &tmp1, &crs, TRUE, must_expand(hd));
X
X  /* horizontally size and break hd */
X  debug0(DGM, DD, "SizeGalley: after manifesting, hd =");
X  ifdebug(DGM, DD, EchoObject(stderr, hd));
X  debug0(DGM, DD, "SizeGalley horizontally sizing and breaking hd:");
X  CopyConstraint(constraint(hd), *c);
X  y = MinSize(y, COL, &extras);
X  debug0(DOB, DD, "  calling BreakObject from SizeGalley");
X  y = BreakObject(y, c);
X  back(hd, COL) = back(y, COL);
X  fwd(hd, COL)  = fwd(y, COL);
X  assert( FitsConstraint(back(hd, COL), fwd(hd, COL), *c),
X	"SizeGalley: BreakObject failed to fit!" );
X  debug2(DSF, D, "MinSize(hd, COL) = %s,%s",
X	  EchoLength(back(hd, COL)), EchoLength(fwd(hd, COL)) );
X
X  /* get the rows of hd to the top level, if required */
X  seen_nojoin(hd) = FALSE;
X  if( rows )
X  { /* OBJECT prev_gap = nil; */
X    debug0(DGM, DD, "SizeGalley cleaning up rows of hd:");
X    for( link = hd;  NextDown(link) != hd;  link = NextDown(link) )
X    { Child(y, NextDown(link));
X      debug2(DGM,DD,"  cleaning %s: %s", Image(type(y)), EchoObject(null,y));
X      switch( type(y) )
X      {
X	case GAP_OBJ:
X
X	  /* prev_gap = y; */
X	  if( !join(gap(y)) )  seen_nojoin(hd) = TRUE;
X	  break;
X
X
X	case VCAT:
X	  
X	  TransferLinks(Down(y), y, Up(y));
X	  DisposeChild(Up(y));
X	  link = PrevDown(link);
X	  break;
X
X
X	case SPLIT:
X	  
X	  assert(Up(y)==LastUp(y), "SizeGalley COL_THR: Up(y)!=LastUp(y)!");
X	  Child(z, DownDim(y, ROW));
X	  if( is_indefinite(type(z)) )  external(z) = TRUE;
X	  else if( type(z) == VCAT )
X	  { OBJECT hor, thor, clink, dlink;
X	    Child(hor, DownDim(y, COL));
X	    assert( type(hor) == COL_THR, "SizeGalley: missing COL_THR!" );
X	    Parent(thor, UpDim(z, COL));
X	    assert( hor == thor, "SizeGalley/SPLIT: hor != thor!" );
X	    clink = DownDim(y, COL);
X	    dlink = UpDim(z, COL);
X	    for( tlink = LastDown(z);  tlink != z;  tlink = PrevDown(tlink) )
X	    { Child(t, tlink);
X	      if( type(t) == GAP_OBJ )  Link(NextDown(link), t);
X	      else
X	      {	tmp = New(SPLIT);
X		back(tmp, COL) = back(hor, COL);
X		fwd(tmp, COL) = fwd(hor, COL);
X		Link(NextDown(link), tmp);
X		Link(tmp, NextUp(clink));
X		Link(NextDown(dlink), t);
X		Link(tmp, t);
X	      }
X	    }
X	    DeleteLink(dlink);
X	    assert(Up(y)==LastUp(y), "SizeGalley COL_THR: Up(y) != LastUp(y)!");
X	    DisposeChild(Up(y));
X	    link = PrevDown(link);
X	  }
X	  break;
X
X
X	case CLOSURE:
X	case HEAD:
X	  
X	  external(y) = TRUE;
X	  break;
X
X
X	default:
X	  
X	  break;
X      }
X    }
X  }
X
X  /* size the rows of hd and attach indices where needed */
X  debug0(DGM, DD, "SizeGalley sizing rows of hd =");
X  ifdebug(DGM, DD, EchoObject(stderr, hd));
X  *recs = *inners = *dest_index = nil;
X  for( link = Down(hd);  link != hd;  link = NextDown(link) )
X  { Child(y, link);
X    if( type(y) == GAP_OBJ || is_index(type(y)) )  continue;
X    debug0(DGM, DDD, "  ROW sizing:");
X    ifdebug(DGM, DDD, EchoObject(stderr, y));
X    extras = New(ACAT);
X    y = MinSize(y, ROW, &extras);
X    debug3(DSF, D, "MinSize( %s , ROW ) = %s,%s", EchoObject(null, y),
X	  EchoLength(back(y, ROW)), EchoLength(fwd(y, ROW)) );
X    debug0(DGM, DDD, "  ROW result:");
X    ifdebug(DGM, DDD, EchoObject(stderr, y));
X
X    /* now attach indexes in front of y */
X    for( zlink = Down(extras);  zlink != extras;  zlink = NextDown(zlink) )
X    { Child(z, zlink);
X      blocked(z) = FALSE;
X      /* debug1(DCR, D, "  extra: %s", EchoObject(null, z)); */
X      debug1(DGM, DD, "  extra: %s", EchoObject(null, z));
X      switch( type(z) )
X      {
X	case RECEPTIVE:
X
X	  /* debug2(DCR, D, "  ... uses_ext  = %s, trig = %s",
X	    bool(uses_extern_target(actual(actual(z)))), bool(trig)); */
X	  trigger_externs(z) = uses_extern_target(actual(actual(z))) && trig;
X	  non_blocking(z)    = nonblock;
X	  if( actual(actual(z)) == GalleySym )  *dest_index = z;
X	  break;
X
X
X	case RECURSIVE:
X
X	  if( *recs == nil )  *recs = New(ACAT);
X	  Link(*recs, z);
X	  break;
X
X
X	case UNATTACHED:
X
X	  if( *inners == nil )  *inners = New(ACAT);
X	  Link(*inners, z);
X	  break;
X
X		
X	case EXPAND_IND:
X	case GALL_PREC:
X	case GALL_FOLL:
X	case GALL_TARG:
X	case CROSS_PREC:
X	case CROSS_FOLL:
X	case CROSS_TARG:
X
X	  debug1(DCR, DD, "  SizeGalley: %s", EchoObject(null, z));
X	  break;
X
X
X	default:
X	  
X	  Error(INTERN, no_fpos, "SizeGalley: %s", Image(type(z)) );
X	  break;
X
X      }
X    }
X    TransferLinks(Down(extras), extras, link);
X    assert( Down(extras) == extras && Up(extras) == extras, "SizeG: extras!");
X    Dispose(extras);
X  }
X  
X  /* insinuate cross references */
X  if( crs != nil )
X  { 
X    debug1(DCR, D, "SizeGalley insinuating %s", crs);
X    TransferLinks(Down(crs), crs, Down(hd));
X    DisposeObject(crs);
X  }
X
X  /* check that *dest_index was found if it was required, and exit */
X  if( target != nil && *dest_index == nil )
X    Error(FATAL, &fpos(hd), "Unexpected absence of %s from the body of %s",
X      SymName(target), SymName(actual(hd)));
X  debug3(DGM, D, "SizeGalley returning %s,%s  %s;  hd =",
X    EchoLength(back(hd, COL)), EchoLength(fwd(hd, COL)),
X    EchoConstraint(&constraint(hd)));
X  ifdebug(DGM, DD, EchoObject(stderr, hd));
X  sized(hd) = TRUE;
X
X} /* end SizeGalley */
END_OF_FILE
  if test 10867 -ne `wc -c <'lout/z21.c'`; then
    echo shar: \"'lout/z21.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z21.c'
fi
if test -f 'lout/z26.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z26.c'\"
else
  echo shar: Extracting \"'lout/z26.c'\" \(12088 characters\)
  sed "s/^X//" >'lout/z26.c' <<'END_OF_FILE'
X/*@z26.c:Echo Service:BeginString(), AppendString(), EndString(), Image()@****/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z26.c                                                      */
X/*  MODULE:       Echo Service                                               */
X/*  EXTERNS:      BeginString(), AppendString(), EndString(), Image()        */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X#if DEBUG_ON
X#define	MULTI	  7			/* max no of simultaneous calls      */
X
Xstatic	unsigned char buff[MULTI][MAX_LINE];	/* buffers for strings       */
Xstatic	int	curr = 1;		/* current buffer in use             */
Xstatic	int	bp;			/* next free space in buff[curr]     */
Xstatic	BOOLEAN	instring = FALSE;	/* TRUE while making a string        */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BeginString()                                                            */
X/*                                                                           */
X/*  Locate a clear buffer into which debug output may be accumulated.        */
X/*                                                                           */
X/*****************************************************************************/
X
XBeginString()
X{ if( instring ) Error(INTERN, no_fpos, "BeginString: currently in string!");
X  instring = TRUE;  curr = (curr + 1) % MULTI;
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  strcpy(buff[curr], "");  bp = 0;
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  AppendString(str, p1, p2, p3, p4, p5, p6)                                */
X/*                                                                           */
X/*  Sprintf str to the current buffer, if space is available there.          */
X/*                                                                           */
X/*****************************************************************************/
X
X/*VARARGS1*/
XAppendString(str, p1, p2, p3, p4, p5, p6)
Xunsigned char *str;  int p1, p2, p3, p4, p5, p6;
X{ int len;
X  if( !instring ) Error(INTERN, no_fpos, "AppendString: no current string!");
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  if( bp == MAX_LINE ) return;		/* no space, do nothing */
X
X  len = strlen(str);
X  if( len + bp >= MAX_LINE )
X  { strcpy( &buff[curr][MAX_LINE/2], " ... <too long to print>" );
X    bp = MAX_LINE;
X  }
X  else
X  { sprintf( &buff[curr][bp], str, p1, p2, p3, p4, p5, p6 );
X    while( buff[curr][bp] != '\0' )  bp++;
X    if( bp >= MAX_LINE )  Error(INTERN, no_fpos, "AppendString abort");
X  }
X} /* end AppendString */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  unsigned char *EndString()                                               */
X/*                                                                           */
X/*  Return the string constructed by previous AppendString operations.       */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *EndString()
X{ if( !instring ) Error(INTERN, no_fpos, "EndString: no current string!");
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  instring = FALSE;
X  return buff[curr];
X} /* end Endstring */
X#endif
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  unsigned char *EchoLength(len)                                           */
X/*                                                                           */
X/*  Echo a length.                                                           */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *EchoLength(len)
Xint len;
X{ static unsigned char buff[6][20];
X  static int i = 0;
X  i = (i + 1) % 6;
X  sprintf(buff[i], "%.3fc", (float) len/CM);
X  return buff[i];
X} /* end EchoLength */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  unsigned char *Image(c)                                                  */
X/*                                                                           */
X/*  Returns the string value of type c.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
Xunsigned char *Image(c)
Xunsigned int c;
X{ static unsigned char b[20];
X  switch(c)
X  {
X
X    case LINK:		return (unsigned char *) "link";
X
X    case SPLIT:		return (unsigned char *) "split";
X    case HEAD:		return (unsigned char *) "head";
X    case PAR:		return (unsigned char *) "par";
X    case WORD:		return (unsigned char *) "word";
X    case GAP_OBJ:	return (unsigned char *) "gap_obj";
X    case ROW_THR:	return (unsigned char *) "row_thr";
X    case COL_THR:	return (unsigned char *) "col_thr";
X    case CLOSURE:	return (unsigned char *) "closure";
X    case NULL_CLOS:	return (unsigned char *) KW_NULL;
X    case CROSS:		return (unsigned char *) KW_CROSS;
X    case ONE_COL:	return (unsigned char *) KW_ONE_COL;
X    case ONE_ROW:	return (unsigned char *) KW_ONE_ROW;
X    case WIDE:		return (unsigned char *) KW_WIDE;
X    case HIGH:		return (unsigned char *) KW_HIGH;
X    case HSCALE:	return (unsigned char *) KW_HSCALE;
X    case VSCALE:	return (unsigned char *) KW_VSCALE;
X    case HCONTRACT:	return (unsigned char *) KW_HCONTRACT;
X    case VCONTRACT:	return (unsigned char *) KW_VCONTRACT;
X    case HEXPAND:	return (unsigned char *) KW_HEXPAND;
X    case VEXPAND:	return (unsigned char *) KW_VEXPAND;
X    case PADJUST:	return (unsigned char *) KW_PADJUST;
X    case HADJUST:	return (unsigned char *) KW_HADJUST;
X    case VADJUST:	return (unsigned char *) KW_VADJUST;
X    case ROTATE:	return (unsigned char *) KW_ROTATE;
X    case SCALE:		return (unsigned char *) KW_SCALE;
X    case CASE:		return (unsigned char *) KW_CASE;
X    case YIELD:		return (unsigned char *) KW_YIELD;
X    case FONT:		return (unsigned char *) KW_FONT;
X    case SPACE:		return (unsigned char *) KW_SPACE;
X    case BREAK:		return (unsigned char *) KW_BREAK;
X    case NEXT:		return (unsigned char *) KW_NEXT;
X    case ENV:		return (unsigned char *) KW_ENV;
X    case CLOS:		return (unsigned char *) KW_CLOS;
X    case LVIS:		return (unsigned char *) KW_LVIS;
X    case OPEN:		return (unsigned char *) KW_OPEN;
X    case TAGGED:	return (unsigned char *) KW_TAGGED;
X    case INCGRAPHIC:	return (unsigned char *) KW_INCGRAPHIC;
X    case SINCGRAPHIC:	return (unsigned char *) KW_SINCGRAPHIC;
X    case GRAPHIC:	return (unsigned char *) KW_GRAPHIC;
X    case ACAT:		return (unsigned char *) "acat";
X    case HCAT:		return (unsigned char *) "hcat";
X    case VCAT:		return (unsigned char *) "vcat";
X
X    case TSPACE:	return (unsigned char *) "tspace";
X    case TJUXTA:	return (unsigned char *) "tjuxta";
X    case LBR:		return (unsigned char *) "lbr";
X    case RBR:		return (unsigned char *) "rbr";
X    case BEGIN:		return (unsigned char *) KW_BEGIN;
X    case END:		return (unsigned char *) KW_END;
X    case USE:		return (unsigned char *) KW_USE;
X    case GSTUB_NONE:	return (unsigned char *) "gstub_none";
X    case GSTUB_INT:	return (unsigned char *) "gstub_int";
X    case GSTUB_EXT:	return (unsigned char *) "gstub_ext";
X    case INCLUDE:	return (unsigned char *) KW_INCLUDE;
X    case SYS_INCLUDE:	return (unsigned char *) KW_SYSINCLUDE;
X    case PREPEND:	return (unsigned char *) KW_PREPEND;
X    case SYS_PREPEND:	return (unsigned char *) KW_SYSPREPEND;
X    case DATABASE:	return (unsigned char *) KW_DATABASE;
X    case SYS_DATABASE:	return (unsigned char *) KW_SYSDATABASE;
X    case START:	 	return (unsigned char *) "start";
X
X    case DEAD:		return (unsigned char *) "dead";
X    case UNATTACHED:	return (unsigned char *) "unattached";
X    case RECEPTIVE:	return (unsigned char *) "receptive";
X    case RECEIVING:	return (unsigned char *) "receiving";
X    case RECURSIVE:	return (unsigned char *) "recursive";
X    case PRECEDES:	return (unsigned char *) "precedes";
X    case FOLLOWS:	return (unsigned char *) "follows";
X    case CROSS_FOLL:	return (unsigned char *) "cross_foll";
X    case GALL_FOLL:	return (unsigned char *) "gall_foll";
X    case CROSS_TARG:	return (unsigned char *) "cross_targ";
X    case GALL_TARG:	return (unsigned char *) "gall_targ";
X    case GALL_PREC:	return (unsigned char *) "gall_prec";
X    case CROSS_PREC:	return (unsigned char *) "cross_prec";
X    case EXPAND_IND:	return (unsigned char *) "expand_ind";
X    case THREAD:	return (unsigned char *) "thread";
X    case CROSS_SYM:	return (unsigned char *) "cross_sym";
X    case CR_ROOT:	return (unsigned char *) "cr_root";
X    case MACRO:		return (unsigned char *) KW_MACRO;
X    case LOCAL:		return (unsigned char *) "local";
X    case LPAR:		return (unsigned char *) "lpar";
X    case NPAR:		return (unsigned char *) "npar";
X    case RPAR:		return (unsigned char *) "rpar";
X    case CR_LIST:	return (unsigned char *) "cr_list";
X    case EXT_GALL:	return (unsigned char *) "ext_gall";
X    case DISPOSED:	return (unsigned char *) "disposed";
X
X    case BACK:		return (unsigned char *) "back";
X    case ON:		return (unsigned char *) "on";
X    case FWD:		return (unsigned char *) "fwd";
X
X    case PROMOTE:	return (unsigned char *) "promote";
X    case CLOSE:		return (unsigned char *) "close";
X    case BLOCK:		return (unsigned char *) "block";
X    case CLEAR:		return (unsigned char *) "clear";
X
X    case ABS:		return (unsigned char *) "abs";
X    case INC:		return (unsigned char *) "inc";
X    case DEC:		return (unsigned char *) "dec";
X
X    default:		sprintf(b, "??(%d)", c);
X			return b;
X  } /* end switch */
X} /* end Image */
END_OF_FILE
  if test 12088 -ne `wc -c <'lout/z26.c'`; then
    echo shar: \"'lout/z26.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z26.c'
fi
echo shar: End of archive 22 \(of 30\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
