Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v37i108:  lout - Lout document formatting system, v2, Part10/30
Message-ID: <1993Jun1.051842.25709@sparky.imd.sterling.com>
X-Md4-Signature: 80d190065a1f19f1182ab586b119794e
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 1 Jun 1993 05:18:42 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 37, Issue 108
Archive-name: lout/part10
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lout/include/lout.hyph lout/z06.c lout/z33.c
# Wrapped by kent@sparky on Sun May 30 19:43:56 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 30)."'
if test -f 'lout/include/lout.hyph' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/include/lout.hyph'\"
else
  echo shar: Extracting \"'lout/include/lout.hyph'\" \(27421 characters\)
  sed "s/^X//" >'lout/include/lout.hyph' <<'END_OF_FILE'
X@!$%^&*()_-+=~`{[}]:;'|<,.>?/0123456789
XaA
XbB
XcC
XdD
XeE
XfF
XgG
XhH
XiI
XjJ
XkK
XlL
XmM
XnN
XoO
XpP
XqQ
XrR
XsS
XtT
XuU
XvV
XwW
XxX
XyY
XzZ
X
X.ach4
X.ad4der
X.af1t
X.al3t
X.am5at
X.an5c
X.ang4
X.ani5m
X.ant4
X.an3te
X.anti5s
X.ar5s
X.ar4tie
X.ar4ty
X.as3c
X.as1p
X.as1s
X.aster5
X.atom5
X.au1d
X.av4i
X.awn4
X.ba4g
X.ba5na
X.bas4e
X.ber4
X.be5ra
X.be3sm
X.be5sto
X.bri2
X.but4ti
X.cam4pe
X.can5c
X.capa5b
X.car5ol
X.ca4t
X.ce4la
X.ch4
X.chill5i
X.ci2
X.cit5r
X.co3e
X.co4r
X.cor5ner
X.de4moi
X.de3o
X.de3ra
X.de3ri
X.des4c
X.dictio5
X.do4t
X.du4c
X.dumb5
X.earth5
X.eas3i
X.eb4
X.eer4
X.eg2
X.el5d
X.el3em
X.enam3
X.en3g
X.en3s
X.eq5ui5t
X.er4ri
X.es3
X.eu3
X.eye5
X.fes3
X.for5mer
X.ga2
X.ge2
X.gen3t4
X.ge5og
X.gi5a
X.gi4b
X.go4r
X.hand5i
X.han5k
X.he2
X.hero5i
X.hes3
X.het3
X.hi3b
X.hi3er
X.hon5ey
X.hon3o
X.hov5
X.id4l
X.idol3
X.im3m
X.im5pin
X.in1
X.in3ci
X.ine2
X.in2k
X.in3s
X.ir5r
X.is4i
X.ju3r
X.la4cy
X.la4m
X.lat5er
X.lath5
X.le2
X.leg5e
X.len4
X.lep5
X.lev1
X.li4g
X.lig5a
X.li2n
X.li3o
X.li4t
X.mag5a5
X.mal5o
X.man5a
X.mar5ti
X.me2
X.mer3c
X.me5ter
X.mis1
X.mist5i
X.mon3e
X.mo3ro
X.mu5ta
X.muta5b
X.ni4c
X.od2
X.odd5
X.of5te
X.or5ato
X.or3c
X.or1d
X.or3t
X.os3
X.os4tl
X.oth3
X.out3
X.ped5al
X.pe5te
X.pe5tit
X.pi4e
X.pio5n
X.pi2t
X.pre3m
X.ra4c
X.ran4t
X.ratio5na
X.ree2
X.re5mit
X.res2
X.re5stat
X.ri4g
X.rit5u
X.ro4q
X.ros5t
X.row5d
X.ru4d
X.sci3e
X.self5
X.sell5
X.se2n
X.se5rie
X.sh2
X.si2
X.sing4
X.st4
X.sta5bl
X.sy2
X.ta4
X.te4
X.ten5an
X.th2
X.ti2
X.til4
X.tim5o5
X.ting4
X.tin5k
X.ton4a
X.to4p
X.top5i
X.tou5s
X.trib5ut
X.un1a
X.un3ce
X.under5
X.un1e
X.un5k
X.un5o
X.un3u
X.up3
X.ure3
X.us5a
X.ven4de
X.ve5ra
X.wil5i
X.ye4
X4ab.
Xa5bal
Xa5ban
Xabe2
Xab5erd
Xabi5a
Xab5it5ab
Xab5lat
Xab5o5liz
X4abr
Xab5rog
Xab3ul
Xa4car
Xac5ard
Xac5aro
Xa5ceou
Xac1er
Xa5chet
X4a2ci
Xa3cie
Xac1in
Xa3cio
Xac5rob
Xact5if
Xac3ul
Xac4um
Xa2d
Xad4din
Xad5er.
X2adi
Xa3dia
Xad3ica
Xadi4er
Xa3dio
Xa3dit
Xa5diu
Xad4le
Xad3ow
Xad5ran
Xad4su
X4adu
Xa3duc
Xad5um
Xae4r
Xaeri4e
Xa2f
Xaff4
Xa4gab
Xaga4n
Xag5ell
Xage4o
X4ageu
Xag1i
X4ag4l
Xag1n
Xa2go
X3agog
Xag3oni
Xa5guer
Xag5ul
Xa4gy
Xa3ha
Xa3he
Xah4l
Xa3ho
Xai2
Xa5ia
Xa3ic.
Xai5ly
Xa4i4n
Xain5in
Xain5o
Xait5en
Xa1j
Xak1en
Xal5ab
Xal3ad
Xa4lar
X4aldi
X2ale
Xal3end
Xa4lenti
Xa5le5o
Xal1i
Xal4ia.
Xali4e
Xal5lev
X4allic
X4alm
Xa5log.
Xa4ly.
X4alys
X5a5lyst
X5alyt
X3alyz
X4ama
Xam5ab
Xam3ag
Xama5ra
Xam5asc
Xa4matis
Xa4m5ato
Xam5era
Xam3ic
Xam5if
Xam5ily
Xam1in
Xami4no
Xa2mo
Xa5mon
Xamor5i
Xamp5en
Xa2n
Xan3age
X3analy
Xa3nar
Xan3arc
Xanar4i
Xa3nati
X4and
Xande4s
Xan3dis
Xan1dl
Xan4dow
Xa5nee
Xa3nen
Xan5est.
Xa3neu
X2ang
Xang5ie
Xan1gl
Xa4n1ic
Xa3nies
Xan3i3f
Xan4ime
Xa5nimi
Xa5nine
Xan3io
Xa3nip
Xan3ish
Xan3it
Xa3niu
Xan4kli
X5anniz
Xano4
Xan5ot
Xanoth5
Xan2sa
Xan4sco
Xan4sn
Xan2sp
Xans3po
Xan4st
Xan4sur
Xantal4
Xan4tie
X4anto
Xan2tr
Xan4tw
Xan3ua
Xan3ul
Xa5nur
X4ao
Xapar4
Xap5at
Xap5ero
Xa3pher
X4aphi
Xa4pilla
Xap5illar
Xap3in
Xap3ita
Xa3pitu
Xa2pl
Xapoc5
Xap5ola
Xapor5i
Xapos3t
Xaps5es
Xa3pu
Xaque5
X2a2r
Xar3act
Xa5rade
Xar5adis
Xar3al
Xa5ramete
Xaran4g
Xara3p
Xar4at
Xa5ratio
Xar5ativ
Xa5rau
Xar5av4
Xaraw4
Xarbal4
Xar4chan
Xar5dine
Xar4dr
Xar5eas
Xa3ree
Xar3ent
Xa5ress
Xar4fi
Xar4fl
Xar1i
Xar5ial
Xar3ian
Xa3riet
Xar4im
Xar5inat
Xar3io
Xar2iz
Xar2mi
Xar5o5d
Xa5roni
Xa3roo
Xar2p
Xar3q
Xarre4
Xar4sa
Xar2sh
X4as.
Xas4ab
Xas3ant
Xashi4
Xa5sia.
Xa3sib
Xa3sic
X5a5si4t
Xask3i
Xas4l
Xa4soc
Xas5ph
Xas4sh
Xas3ten
Xas1tr
Xasur5a
Xa2ta
Xat3abl
Xat5ac
Xat3alo
Xat5ap
Xate5c
Xat5ech
Xat3ego
Xat3en.
Xat3era
Xater5n
Xa5terna
Xat3est
Xat5ev
X4ath
Xath5em
Xa5then
Xat4ho
Xath5om
X4ati.
Xa5tia
Xat5i5b
Xat1ic
Xat3if
Xation5ar
Xat3itu
Xa4tog
Xa2tom
Xat5omiz
Xa4top
Xa4tos
Xa1tr
Xat5rop
Xat4sk
Xat4tag
Xat5te
Xat4th
Xa2tu
Xat5ua
Xat5ue
Xat3ul
Xat3ura
Xa2ty
Xau4b
Xaugh3
Xau3gu
Xau4l2
Xaun5d
Xau3r
Xau5sib
Xaut5en
Xau1th
Xa2va
Xav3ag
Xa5van
Xave4no
Xav3era
Xav5ern
Xav5ery
Xav1i
Xavi4er
Xav3ig
Xav5oc
Xa1vor
X3away
Xaw3i
Xaw4ly
Xaws4
Xax4ic
Xax4id
Xay5al
Xaye4
Xays4
Xazi4er
Xazz5i
X5ba.
Xbad5ger
Xba4ge
Xbal1a
Xban5dag
Xban4e
Xban3i
Xbarbi5
Xbari4a
Xbas4si
X1bat
Xba4z
X2b1b
Xb2be
Xb3ber
Xbbi4na
X4b1d
X4be.
Xbeak4
Xbeat3
X4be2d
Xbe3da
Xbe3de
Xbe3di
Xbe3gi
Xbe5gu
X1bel
Xbe1li
Xbe3lo
X4be5m
Xbe5nig
Xbe5nu
X4bes4
Xbe3sp
Xbe5str
X3bet
Xbet5iz
Xbe5tr
Xbe3tw
Xbe3w
Xbe5yo
X2bf
X4b3h
Xbi2b
Xbi4d
X3bie
Xbi5en
Xbi4er
X2b3if
X1bil
Xbi3liz
Xbina5r4
Xbin4d
Xbi5net
Xbi3ogr
Xbi5ou
Xbi2t
X3bi3tio
Xbi3tr
X3bit5ua
Xb5itz
Xb1j
Xbk4
Xb2l2
Xblath5
Xb4le.
Xblen4
X5blesp
Xb3lis
Xb4lo
Xblun4t
X4b1m
X4b3n
Xbne5g
X3bod
Xbod3i
Xbo4e
Xbol3ic
Xbom4bi
Xbon4a
Xbon5at
X3boo
X5bor.
X4b1ora
Xbor5d
X5bore
X5bori
X5bos4
Xb5ota
Xboth5
Xbo4to
Xbound3
X4bp
X4brit
Xbroth3
X2b5s2
Xbsor4
X2bt
Xbt4l
Xb4to
Xb3tr
Xbuf4fer
Xbu4ga
Xbu3li
Xbumi4
Xbu4n
Xbunt4i
Xbu3re
Xbus5ie
Xbuss4e
X5bust
X4buta
X3butio
Xb5uto
Xb1v
X4b5w
X5by.
Xbys4
X1ca
Xcab3in
Xca1bl
Xcach4
Xca5den
X4cag4
X2c5ah
Xca3lat
Xcal4la
Xcall5in
X4calo
Xcan5d
Xcan4e
Xcan4ic
Xcan5is
Xcan3iz
Xcan4ty
Xcany4
Xca5per
Xcar5om
Xcast5er
Xcas5tig
X4casy
Xca4th
X4cativ
Xcav5al
Xc3c
Xccha5
Xcci4a
Xccompa5
Xccon4
Xccou3t
X2ce.
X4ced.
X4ceden
X3cei
X5cel.
X3cell
X1cen
X3cenc
X2cen4e
X4ceni
X3cent
X3cep
Xce5ram
X4cesa
X3cessi
Xces5si5b
Xces5t
Xcet4
Xc5e4ta
Xcew4
X2ch
X4ch.
X4ch3ab
X5chanic
Xch5a5nis
Xche2
Xcheap3
X4ched
Xche5lo
X3chemi
Xch5ene
Xch3er.
Xch3ers
X4ch1in
X5chine.
Xch5iness
X5chini
X5chio
X3chit
Xchi2z
X3cho2
Xch4ti
X1ci
X3cia
Xci2a5b
Xcia5r
Xci5c
X4cier
X5cific.
X4cii
Xci4la
X3cili
X2cim
X2cin
Xc4ina
X3cinat
Xcin3em
Xc1ing
Xc5ing.
X5cino
Xcion4
X4cipe
Xci3ph
X4cipic
X4cista
X4cisti
X2c1it
Xcit3iz
X5ciz
Xck1
Xck3i
X1c4l4
X4clar
Xc5laratio
X5clare
Xcle4m
X4clic
Xclim4
Xcly4
Xc5n
X1co
Xco5ag
Xcoe2
X2cog
Xco4gr
Xcoi4
Xco3inc
Xcol5i
X5colo
Xcol3or
Xcom5er
Xcon4a
Xc4one
Xcon3g
Xcon5t
Xco3pa
Xcop3ic
Xco4pl
X4corb
Xcoro3n
Xcos4e
Xcov1
Xcove4
Xcow5a
Xcoz5e
Xco5zi
Xc1q
Xcras5t
X5crat.
X5cratic
Xcre3at
X5cred
X4c3reta
Xcre4v
Xcri2
Xcri5f
Xc4rin
Xcris4
X5criti
Xcro4pl
Xcrop5o
Xcros4e
Xcru4d
X4c3s2
X2c1t
Xcta4b
Xct5ang
Xc5tant
Xc2te
Xc3ter
Xc4ticu
Xctim3i
Xctu4r
Xc4tw
Xcud5
Xc4uf
Xc4ui
Xcu5ity
X5culi
Xcul4tis
X3cultu
Xcu2ma
Xc3ume
Xcu4mi
X3cun
Xcu3pi
Xcu5py
Xcur5a4b
Xcu5ria
X1cus
Xcuss4i
X3c4ut
Xcu4tie
X4c5utiv
X4cutr
X1cy
Xcze4
X1d2a
X5da.
X2d3a4b
Xdach4
X4daf
X2dag
Xda2m2
Xdan3g
Xdard5
Xdark5
X4dary
X3dat
X4dativ
X4dato
X5dav4
Xdav5e
X5day
Xd1b
Xd5c
Xd1d4
X2de.
Xdeaf5
Xdeb5it
Xde4bon
Xdecan4
Xde4cil
Xde5com
X2d1ed
X4dee.
Xde5if
Xdeli4e
Xdel5i5q
Xde5lo
Xd4em
X5dem.
X3demic
Xdem5ic.
Xde5mil
Xde4mons
Xdemor5
X1den
Xde4nar
Xde3no
Xdenti5f
Xde3nu
Xde1p
Xde3pa
Xdepi4
Xde2pu
Xd3eq
Xd4erh
X5derm
Xdern5iz
Xder5s
Xdes2
Xd2es.
Xde1sc
Xde2s5o
Xdes3ti
Xde3str
Xde4su
Xde1t
Xde2to
Xde1v
Xdev3il
X4dey
X4d1f
Xd4ga
Xd3ge4t
Xdg1i
Xd2gy
Xd1h2
X5di.
X1d4i3a
Xdia5b
Xdi4cam
Xd4ice
X3dict
X3did
X5di3en
Xd1if
Xdi3ge
Xdi4lato
Xd1in
X1dina
X3dine.
X5dini
Xdi5niz
X1dio
Xdio5g
Xdi4pl
Xdir2
Xdi1re
Xdirt5i
Xdis1
X5disi
Xd4is3t
Xd2iti
X1di1v
Xd1j
Xd5k2
X4d5la
X3dle.
X3dled
X3dles.
X4dless
X2d3lo
X4d5lu
X2dly
Xd1m
X4d1n4
X1do
X3do.
Xdo5de
X5doe
X2d5of
Xd4og
Xdo4la
Xdoli4
Xdo5lor
Xdom5iz
Xdo3nat
Xdoni4
Xdoo3d
Xdop4p
Xd4or
X3dos
X4d5out
Xdo4v
X3dox
Xd1p
X1dr
Xdrag5on
X4drai
Xdre4
Xdrea5r
X5dren
Xdri4b
Xdril4
Xdro4p
X4drow
X5drupli
X4dry
X2d1s2
Xds4p
Xd4sw
Xd4sy
Xd2th
X1du
Xd1u1a
Xdu2c
Xd1uca
Xduc5er
X4duct.
X4ducts
Xdu5el
Xdu4g
Xd3ule
Xdum4be
Xdu4n
X4dup
Xdu4pe
Xd1v
Xd1w
Xd2y
X5dyn
Xdy4se
Xdys5p
Xe1a4b
Xe3act
Xead1
Xead5ie
Xea4ge
Xea5ger
Xea4l
Xeal5er
Xeal3ou
Xeam3er
Xe5and
Xear3a
Xear4c
Xear5es
Xear4ic
Xear4il
Xear5k
Xear2t
Xeart3e
Xea5sp
Xe3ass
Xeast3
Xea2t
Xeat5en
Xeath3i
Xe5atif
Xe4a3tu
Xea2v
Xeav3en
Xeav5i
Xeav5o
X2e1b
Xe4bel.
Xe4bels
Xe4ben
Xe4bit
Xe3br
Xe4cad
Xecan5c
Xecca5
Xe1ce
Xec5essa
Xec2i
Xe4cib
Xec5ificat
Xec5ifie
Xec5ify
Xec3im
Xeci4t
Xe5cite
Xe4clam
Xe4clus
Xe2col
Xe4comm
Xe4compe
Xe4conc
Xe2cor
Xec3ora
Xeco5ro
Xe1cr
Xe4crem
Xec4tan
Xec4te
Xe1cu
Xe4cul
Xec3ula
X2e2da
X4ed3d
Xe4d1er
Xede4s
X4edi
Xe3dia
Xed3ib
Xed3ica
Xed3im
Xed1it
Xedi5z
X4edo
Xe4dol
Xedon2
Xe4dri
Xe4dul
Xed5ulo
Xee2c
Xeed3i
Xee2f
Xeel3i
Xee4ly
Xee2m
Xee4na
Xee4p1
Xee2s4
Xeest4
Xee4ty
Xe5ex
Xe1f
Xe4f3ere
X1eff
Xe4fic
X5efici
Xefil4
Xe3fine
Xef5i5nite
X3efit
Xefor5es
Xe4fuse.
X4egal
Xeger4
Xeg5ib
Xeg4ic
Xeg5ing
Xe5git5
Xeg5n
Xe4go.
Xe4gos
Xeg1ul
Xe5gur
X5egy
Xe1h4
Xeher4
Xei2
Xe5ic
Xei5d
Xeig2
Xei5gl
Xe3imb
Xe3inf
Xe1ing
Xe5inst
Xeir4d
Xeit3e
Xei3th
Xe5ity
Xe1j
Xe4jud
Xej5udi
Xeki4n
Xek4la
Xe1la
Xe4la.
Xe4lac
Xelan4d
Xel5ativ
Xe4law
Xelaxa4
Xe3lea
Xel5ebra
X5elec
Xe4led
Xel3ega
Xe5len
Xe4l1er
Xe1les
Xel2f
Xel2i
Xe3libe
Xe4l5ic.
Xel3ica
Xe3lier
Xel5igib
Xe5lim
Xe4l3ing
Xe3lio
Xe2lis
Xel5ish
Xe3liv3
X4ella
Xel4lab
Xello4
Xe5loc
Xel5og
Xel3op.
Xel2sh
Xel4ta
Xe5lud
Xel5ug
Xe4mac
Xe4mag
Xe5man
Xem5ana
Xem5b
Xe1me
Xe2mel
Xe4met
Xem3ica
Xemi4e
Xem5igra
Xem1in2
Xem5ine
Xem3i3ni
Xe4mis
Xem5ish
Xe5miss
Xem3iz
X5emniz
Xemo4g
Xemoni5o
Xem3pi
Xe4mul
Xem5ula
Xemu3n
Xe3my
Xen5amo
Xe4nant
Xench4er
Xen3dic
Xe5nea
Xe5nee
Xen3em
Xen5ero
Xen5esi
Xen5est
Xen3etr
Xe3new
Xen5ics
Xe5nie
Xe5nil
Xe3nio
Xen3ish
Xen3it
Xe5niu
X5eniz
X4enn
X4eno
Xeno4g
Xe4nos
Xen3ov
Xen4sw
Xent5age
X4enthes
Xen3ua
Xen5uf
Xe3ny.
X4en3z
Xe5of
Xeo2g
Xe4oi4
Xe3ol
Xeop3ar
Xe1or
Xeo3re
Xeo5rol
Xeos4
Xe4ot
Xeo4to
Xe5out
Xe5ow
Xe2pa
Xe3pai
Xep5anc
Xe5pel
Xe3pent
Xep5etitio
Xephe4
Xe4pli
Xe1po
Xe4prec
Xep5reca
Xe4pred
Xep3reh
Xe3pro
Xe4prob
Xep4sh
Xep5ti5b
Xe4put
Xep5uta
Xe1q
Xequi3l
Xe4q3ui3s
Xer1a
Xera4b
X4erand
Xer3ar
X4erati.
X2erb
Xer4bl
Xer3ch
Xer4che
X2ere.
Xe3real
Xere5co
Xere3in
Xer5el.
Xer3emo
Xer5ena
Xer5ence
X4erene
Xer3ent
Xere4q
Xer5ess
Xer3est
Xeret4
Xer1h
Xer1i
Xe1ria4
X5erick
Xe3rien
Xeri4er
Xer3ine
Xe1rio
X4erit
Xer4iu
Xeri4v
Xe4riva
Xer3m4
Xer4nis
X4ernit
X5erniz
Xer3no
X2ero
Xer5ob
Xe5roc
Xero4r
Xer1ou
Xer1s
Xer3set
Xert3er
X4ertl
Xer3tw
X4eru
Xeru4t
X5erwau
Xe1s4a
Xe4sage.
Xe4sages
Xes2c
Xe2sca
Xes5can
Xe3scr
Xes5cu
Xe1s2e
Xe2sec
Xes5ecr
Xes5enc
Xe4sert.
Xe4serts
Xe4serva
X4esh
Xe3sha
Xesh5en
Xe1si
Xe2sic
Xe2sid
Xes5iden
Xes5igna
Xe2s5im
Xes4i4n
Xesis4te
Xesi4u
Xe5skin
Xes4mi
Xe2sol
Xes3olu
Xe2son
Xes5ona
Xe1sp
Xes3per
Xes5pira
Xes4pre
X2ess
Xes4si4b
Xestan4
Xes3tig
Xes5tim
X4es2to
Xe3ston
X2estr
Xe5stro
Xestruc5
Xe2sur
Xes5urr
Xes4w
Xeta4b
Xeten4d
Xe3teo
Xethod3
Xet1ic
Xe5tide
Xetin4
Xeti4no
Xe5tir
Xe5titio
Xet5itiv
X4etn
Xet5ona
Xe3tra
Xe3tre
Xet3ric
Xet5rif
Xet3rog
Xet5ros
Xet3ua
Xet5ym
Xet5z
X4eu
Xe5un
Xe3up
Xeu3ro
Xeus4
Xeute4
Xeuti5l
Xeu5tr
Xeva2p5
Xe2vas
Xev5ast
Xe5vea
Xev3ell
Xevel3o
Xe5veng
Xeven4i
Xev1er
Xe5verb
Xe1vi
Xev3id
Xevi4l
Xe4vin
Xevi4v
Xe5voc
Xe5vu
Xe1wa
Xe4wag
Xe5wee
Xe3wh
Xewil5
Xew3ing
Xe3wit
X1exp
X5eyc
X5eye.
Xeys4
X1fa
Xfa3bl
Xfab3r
Xfa4ce
X4fag
Xfain4
Xfall5e
X4fa4ma
Xfam5is
X5far
Xfar5th
Xfa3ta
Xfa3the
X4fato
Xfault5
X4f5b
X4fd
X4fe.
Xfeas4
Xfeath3
Xfe4b
X4feca
X5fect
X2fed
Xfe3li
Xfe4mo
Xfen2d
Xfend5e
Xfer1
X5ferr
Xfev4
X4f1f
Xf4fes
Xf4fie
Xf5fin.
Xf2f5is
Xf4fly
Xf2fy
X4fh
X1fi
Xfi3a
X2f3ic.
X4f3ical
Xf3ican
X4ficate
Xf3icen
Xfi3cer
Xfic4i
X5ficia
X5ficie
X4fics
Xfi3cu
Xfi5del
Xfight5
Xfil5i
Xfill5in
X4fily
X2fin
X5fina
Xfin2d5
Xfi2ne
Xf1in3g
Xfin4n
Xfis4ti
Xf4l2
Xf5less
Xflin4
Xflo3re
Xf2ly5
X4fm
X4fn
X1fo
X5fon
Xfon4de
Xfon4t
Xfo2r
Xfo5rat
Xfor5ay
Xfore5t
Xfor4i
Xfort5a
Xfos5
X4f5p
Xfra4t
Xf5rea
Xfres5c
Xfri2
Xfril4
Xfrol5
X2f3s
X2ft
Xf4to
Xf2ty
X3fu
Xfu5el
X4fug
Xfu4min
Xfu5ne
Xfu3ri
Xfusi4
Xfus4s
X4futa
X1fy
X1ga
Xgaf4
X5gal.
X3gali
Xga3lo
X2gam
Xga5met
Xg5amo
Xgan5is
Xga3niz
Xgani5za
X4gano
Xgar5n4
Xgass4
Xgath3
X4gativ
X4gaz
Xg3b
Xgd4
X2ge.
X2ged
Xgeez4
Xgel4in
Xge5lis
Xge5liz
X4gely
X1gen
Xge4nat
Xge5niz
X4geno
X4geny
X1geo
Xge3om
Xg4ery
X5gesi
Xgeth5
X4geto
Xge4ty
Xge4v
X4g1g2
Xg2ge
Xg3ger
Xgglu5
Xggo4
Xgh3in
Xgh5out
Xgh4to
X5gi.
X1gi4a
Xgia5r
Xg1ic
X5gicia
Xg4ico
Xgien5
X5gies.
Xgil4
Xg3imen
X3g4in.
Xgin5ge
X5g4ins
X5gio
X3gir
Xgir4l
Xg3isl
Xgi4u
X5giv
X3giz
Xgl2
Xgla4
Xglad5i
X5glas
X1gle
Xgli4b
Xg3lig
X3glo
Xglo3r
Xg1m
Xg4my
Xgn4a
Xg4na.
Xgnet4t
Xg1ni
Xg2nin
Xg4nio
Xg1no
Xg4non
X1go
X3go.
Xgob5
X5goe
X3g4o4g
Xgo3is
Xgon2
X4g3o3na
Xgondo5
Xgo3ni
X5goo
Xgo5riz
Xgor5ou
X5gos.
Xgov1
Xg3p
X1gr
X4grada
Xg4rai
Xgran2
X5graph.
Xg5rapher
X5graphic
X4graphy
X4gray
Xgre4n
X4gress.
X4grit
Xg4ro
Xgruf4
Xgs2
Xg5ste
Xgth3
Xgu4a
X3guard
X2gue
X5gui5t
X3gun
X3gus
X4gu4t
Xg3w
X1gy
X2g5y3n
Xgy5ra
Xh3ab4l
Xhach4
Xhae4m
Xhae4t
Xh5agu
Xha3la
Xhala3m
Xha4m
Xhan4ci
Xhan4cy
X5hand.
Xhan4g
Xhang5er
Xhang5o
Xh5a5niz
Xhan4k
Xhan4te
Xhap3l
Xhap5t
Xha3ran
Xha5ras
Xhar2d
Xhard3e
Xhar4le
Xharp5en
Xhar5ter
Xhas5s
Xhaun4
X5haz
Xhaz3a
Xh1b
X1head
X3hear
Xhe4can
Xh5ecat
Xh4ed
Xhe5do5
Xhe3l4i
Xhel4lis
Xhel4ly
Xh5elo
Xhem4p
Xhe2n
Xhena4
Xhen5at
Xheo5r
Xhep5
Xh4era
Xhera3p
Xher4ba
Xhere5a
Xh3ern
Xh5erou
Xh3ery
Xh1es
Xhe2s5p
Xhe4t
Xhet4ed
Xheu4
Xh1f
Xh1h
Xhi5an
Xhi4co
Xhigh5
Xh4il2
Xhimer4
Xh4ina
Xhion4e
Xhi4p
Xhir4l
Xhi3ro
Xhir4p
Xhir4r
Xhis3el
Xhis4s
Xhith5er
Xhi2v
X4hk
X4h1l4
Xhlan4
Xh2lo
Xhlo3ri
X4h1m
Xhmet4
X2h1n
Xh5odiz
Xh5ods
Xho4g
Xhoge4
Xhol5ar
X3hol4e
Xho4ma
Xhome3
Xhon4a
Xho5ny
X3hood
Xhoon4
Xhor5at
Xho5ris
Xhort3e
Xho5ru
Xhos4e
Xho5sen
Xhos1p
X1hous
Xhouse3
Xhov5el
X4h5p
X4hr4
Xhree5
Xhro5niz
Xhro3po
X4h1s2
Xh4sh
Xh4tar
Xht1en
Xht5es
Xh4ty
Xhu4g
Xhu4min
Xhun5ke
Xhun4t
Xhus3t4
Xhu4t
Xh1w
Xh4wart
Xhy3pe
Xhy3ph
Xhy2s
X2i1a
Xi2al
Xiam4
Xiam5ete
Xi2an
X4ianc
Xian3i
X4ian4t
Xia5pe
Xiass4
Xi4ativ
Xia4tric
Xi4atu
Xibe4
Xib3era
Xib5ert
Xib5ia
Xib3in
Xib5it.
Xib5ite
Xi1bl
Xib3li
Xi5bo
Xi1br
Xi2b5ri
Xi5bun
X4icam
X5icap
X4icar
Xi4car.
Xi4cara
Xicas5
Xi4cay
Xiccu4
X4iceo
X4ich
X2ici
Xi5cid
Xic5ina
Xi2cip
Xic3ipa
Xi4cly
Xi2c5oc
X4i1cr
X5icra
Xi4cry
Xic4te
Xictu2
Xic4t3ua
Xic3ula
Xic4um
Xic5uo
Xi3cur
X2id
Xi4dai
Xid5anc
Xid5d
Xide3al
Xide4s
Xi2di
Xid5ian
Xidi4ar
Xi5die
Xid3io
Xidi5ou
Xid1it
Xid5iu
Xi3dle
Xi4dom
Xid3ow
Xi4dr
Xi2du
Xid5uo
X2ie4
Xied4e
X5ie5ga
Xield3
Xien5a4
Xien4e
Xi5enn
Xi3enti
Xi1er.
Xi3esc
Xi1est
Xi3et
X4if.
Xif5ero
Xiff5en
Xif4fr
X4ific.
Xi3fie
Xi3fl
X4ift
X2ig
Xiga5b
Xig3era
Xight3i
X4igi
Xi3gib
Xig3il
Xig3in
Xig3it
Xi4g4l
Xi2go
Xig3or
Xig5ot
Xi5gre
Xigu5i
Xig1ur
Xi3h
X4i5i4
Xi3j
X4ik
Xi1la
Xil3a4b
Xi4lade
Xi2l5am
Xila5ra
Xi3leg
Xil1er
Xilev4
Xil5f
Xil1i
Xil3ia
Xil2ib
Xil3io
Xil4ist
X2ilit
Xil2iz
Xill5ab
X4iln
Xil3oq
Xil4ty
Xil5ur
Xil3v
Xi4mag
Xim3age
Xima5ry
Ximenta5r
X4imet
Xim1i
Xim5ida
Ximi5le
Xi5mini
X4imit
Xim4ni
Xi3mon
Xi2mu
Xim3ula
X2in.
Xi4n3au
X4inav
Xincel4
Xin3cer
X4ind
Xin5dling
X2ine
Xi3nee
Xiner4ar
Xi5ness
X4inga
X4inge
Xin5gen
X4ingi
Xin5gling
X4ingo
X4ingu
X2ini
Xi5ni.
Xi4nia
Xin3io
Xin1is
Xi5nite.
X5initio
Xin3ity
X4ink
X4inl
X2inn
X2i1no
Xi4no4c
Xino4s
Xi4not
X2ins
Xin3se
Xinsur5a
X2int.
X2in4th
Xin1u
Xi5nus
X4iny
X2io
X4io.
Xioge4
Xio2gr
Xi1ol
Xio4m
Xion3at
Xion4ery
Xion3i
Xio5ph
Xior3i
Xi4os
Xio5th
Xi5oti
Xio4to
Xi4our
X2ip
Xipe4
Xiphras4
Xip3i
Xip4ic
Xip4re4
Xip3ul
Xi3qua
Xiq5uef
Xiq3uid
Xiq3ui3t
X4ir
Xi1ra
Xira4b
Xi4rac
Xird5e
Xire4de
Xi4ref
Xi4rel4
Xi4res
Xir5gi
Xir1i
Xiri5de
Xir4is
Xiri3tu
X5i5r2iz
Xir4min
Xiro4g
X5iron.
Xir5ul
X2is.
Xis5ag
Xis3ar
Xisas5
X2is1c
Xis3ch
X4ise
Xis3er
X3isf
Xis5han
Xis3hon
Xish5op
Xis3ib
Xisi4d
Xi5sis
Xis5itiv
X4is4k
Xislan4
X4isms
Xi2so
Xiso5mer
Xis1p
Xis2pi
Xis4py
X4is1s
Xis4sal
Xissen4
Xis4ses
Xis4ta.
Xis1te
Xis1ti
Xist4ly
X4istral
Xi2su
Xis5us
X4ita.
Xita4bi
Xi4tag
X4ita5m
Xi3tan
Xi3tat
X2ite
Xit3era
Xi5teri
Xit4es
X2ith
Xi1ti
X4itia
X4i2tic
Xit3ica
X5i5tick
Xit3ig
Xit5ill
Xi2tim
X2itio
X4itis
Xi4tism
Xi2t5o5m
X4iton
Xi4tram
Xit5ry
X4itt
Xit3uat
Xi5tud
Xit3ul
X4itz.
Xi1u
X2iv
Xiv3ell
Xiv3en.
Xi4v3er.
Xi4vers.
Xiv5il.
Xiv5io
Xiv1it
Xi5vore
Xiv3o3ro
Xi4v3ot
X4i5w
Xix4o
X4iy
X4izar
Xizi4
X5izont
X5ja
Xjac4q
Xja4p
X1je
Xjer5s
X4jestie
X4jesty
Xjew3
Xjo4p
X5judg
X3ka.
Xk3ab
Xk5ag
Xkais4
Xkal4
Xk1b
Xk2ed
X1kee
Xke4g
Xke5li
Xk3en4d
Xk1er
Xkes4
Xk3est.
Xke4ty
Xk3f
Xkh4
Xk1i
X5ki.
X5k2ic
Xk4ill
Xkilo5
Xk4im
Xk4in.
Xkin4de
Xk5iness
Xkin4g
Xki4p
Xkis4
Xk5ish
Xkk4
Xk1l
X4kley
X4kly
Xk1m
Xk5nes
X1k2no
Xko5r
Xkosh4
Xk3ou
Xkro5n
X4k1s2
Xk4sc
Xks4l
Xk4sy
Xk5t
Xk1w
Xlab3ic
Xl4abo
Xlaci4
Xl4ade
Xla3dy
Xlag4n
Xlam3o
X3land
Xlan4dl
Xlan5et
Xlan4te
Xlar4g
Xlar3i
Xlas4e
Xla5tan
X4lateli
X4lativ
X4lav
Xla4v4a
X2l1b
Xlbin4
X4l1c2
Xlce4
Xl3ci
X2ld
Xl2de
Xld4ere
Xld4eri
Xldi4
Xld5is
Xl3dr
Xl4dri
Xle2a
Xle4bi
Xleft5
X5leg.
X5legg
Xle4mat
Xlem5atic
X4len.
X3lenc
X5lene.
X1lent
Xle3ph
Xle4pr
Xlera5b
Xler4e
X3lerg
X3l4eri
Xl4ero
Xles2
Xle5sco
X5lesq
X3less
X5less.
Xl3eva
Xlev4er.
Xlev4era
Xlev4ers
X3ley
X4leye
X2lf
Xl5fr
X4l1g4
Xl5ga
Xlgar3
Xl4ges
Xlgo3
X2l3h
Xli4ag
Xli2am
Xliar5iz
Xli4as
Xli4ato
Xli5bi
X5licio
Xli4cor
X4lics
X4lict.
Xl4icu
Xl3icy
Xl3ida
Xlid5er
X3lidi
Xlif3er
Xl4iff
Xli4fl
X5ligate
X3ligh
Xli4gra
X3lik
X4l4i4l
Xlim4bl
Xlim3i
Xli4mo
Xl4im4p
Xl4ina
X1l4ine
Xlin3ea
Xlin3i
Xlink5er
Xli5og
X4l4iq
Xlis4p
Xl1it
Xl2it.
X5litica
Xl5i5tics
Xliv3er
Xl1iz
X4lj
Xlka3
Xl3kal
Xlka4t
Xl1l
Xl4law
Xl2le
Xl5lea
Xl3lec
Xl3leg
Xl3lel
Xl3le4n
Xl3le4t
Xll2i
Xl2lin4
Xl5lina
Xll4o
Xlloqui5
Xll5out
Xl5low
X2lm
Xl5met
Xlm3ing
Xl4mod
Xlmon4
X2l1n2
X3lo.
Xlob5al
Xlo4ci
X4lof
X3logic
Xl5ogo
X3logu
Xlom3er
X5long
Xlon4i
Xl3o3niz
Xlood5
X5lope.
Xlop3i
Xl3opm
Xlora4
Xlo4rato
Xlo5rie
Xlor5ou
X5los.
Xlos5et
X5losophiz
X5losophy
Xlos4t
Xlo4ta
Xloun5d
X2lout
X4lov
X2lp
Xlpa5b
Xl3pha
Xl5phi
Xlp5ing
Xl3pit
Xl4pl
Xl5pr
X4l1r
X2l1s2
Xl4sc
Xl2se
Xl4sie
X4lt
Xlt5ag
Xltane5
Xl1te
Xlten4
Xltera4
Xlth3i
Xl5ties.
Xltis4
Xl1tr
Xltu2
Xltur3a
Xlu5a
Xlu3br
Xluch4
Xlu3ci
Xlu3en
Xluf4
Xlu5id
Xlu4ma
X5lumi
Xl5umn.
X5lumnia
Xlu3o
Xluo3r
X4lup
Xluss4
Xlus3te
X1lut
Xl5ven
Xl5vet4
X2l1w
X1ly
X4lya
X4lyb
Xly5me
Xly3no
X2lys4
Xl5yse
X1ma
X2mab
Xma2ca
Xma5chine
Xma4cl
Xmag5in
X5magn
X2mah
Xmaid5
X4mald
Xma3lig
Xma5lin
Xmal4li
Xmal4ty
X5mania
Xman5is
Xman3iz
X4map
Xma5rine.
Xma5riz
Xmar4ly
Xmar3v
Xma5sce
Xmas4e
Xmas1t
X5mate
Xmath3
Xma3tis
X4matiza
X4m1b
Xmba4t5
Xm5bil
Xm4b3ing
Xmbi4v
X4m5c
X4me.
X2med
X4med.
X5media
Xme3die
Xm5e5dy
Xme2g
Xmel5on
Xmel4t
Xme2m
Xmem1o3
X1men
Xmen4a
Xmen5ac
Xmen4de
X4mene
Xmen4i
Xmens4
Xmensu5
X3ment
Xmen4te
Xme5on
Xm5ersa
X2mes
X3mesti
Xme4ta
Xmet3al
Xme1te
Xme5thi
Xm4etr
X5metric
Xme5trie
Xme3try
Xme4v
X4m1f
X2mh
X5mi.
Xmi3a
Xmid4a
Xmid4g
Xmig4
X3milia
Xm5i5lie
Xm4ill
Xmin4a
X3mind
Xm5inee
Xm4ingl
Xmin5gli
Xm5ingly
Xmin4t
Xm4inu
Xmiot4
Xm2is
Xmis4er.
Xmis5l
Xmis4ti
Xm5istry
X4mith
Xm2iz
X4mk
X4m1l
Xm1m
Xmma5ry
X4m1n
Xmn4a
Xm4nin
Xmn4o
X1mo
X4mocr
X5mocratiz
Xmo2d1
Xmo4go
Xmois2
Xmoi5se
X4mok
Xmo5lest
Xmo3me
Xmon5et
Xmon5ge
Xmoni3a
Xmon4ism
Xmon4ist
Xmo3niz
Xmonol4
Xmo3ny.
Xmo2r
X4mora.
Xmos2
Xmo5sey
Xmo3sp
Xmoth3
Xm5ouf
X3mous
Xmo2v
X4m1p
Xmpara5
Xmpa5rab
Xmpar5i
Xm3pet
Xmphas4
Xm2pi
Xmpi4a
Xmp5ies
Xm4p1in
Xm5pir
Xmp5is
Xmpo3ri
Xmpos5ite
Xm4pous
Xmpov5
Xmp4tr
Xm2py
X4m3r
X4m1s2
Xm4sh
Xm5si
X4mt
X1mu
Xmula5r4
X5mult
Xmulti3
X3mum
Xmun2
X4mup
Xmu4u
X4mw
X1na
X2n1a2b
Xn4abu
X4nac.
Xna4ca
Xn5act
Xnag5er.
Xnak4
Xna4li
Xna5lia
X4nalt
Xna5mit
Xn2an
Xnanci4
Xnan4it
Xnank4
Xnar3c
X4nare
Xnar3i
Xnar4l
Xn5arm
Xn4as
Xnas4c
Xnas5ti
Xn2at
Xna3tal
Xnato5miz
Xn2au
Xnau3se
X3naut
Xnav4e
X4n1b4
Xncar5
Xn4ces.
Xn3cha
Xn5cheo
Xn5chil
Xn3chis
Xnc1in
Xnc4it
Xncour5a
Xn1cr
Xn1cu
Xn4dai
Xn5dan
Xn1de
Xnd5est.
Xndi4b
Xn5d2if
Xn1dit
Xn3diz
Xn5duc
Xndu4r
Xnd2we
X2ne.
Xn3ear
Xne2b
Xneb3u
Xne2c
X5neck
X2ned
Xne4gat
Xneg5ativ
X5nege
Xne4la
Xnel5iz
Xne5mi
Xne4mo
X1nen
X4nene
X3neo
Xne4po
Xne2q
Xn1er
Xnera5b
Xn4erar
Xn2ere
Xn4er5i
Xner4r
X1nes
X2nes.
X4nesp
X2nest
X4nesw
X3netic
Xne4v
Xn5eve
Xne4w
Xn3f
Xn4gab
Xn3gel
Xnge4n4e
Xn5gere
Xn3geri
Xng5ha
Xn3gib
Xng1in
Xn5git
Xn4gla
Xngov4
Xng5sh
Xn1gu
Xn4gum
Xn2gy
X4n1h4
Xnha4
Xnhab3
Xnhe4
X3n4ia
Xni3an
Xni4ap
Xni3ba
Xni4bl
Xni4d
Xni5di
Xni4er
Xni2fi
Xni5ficat
Xn5igr
Xnik4
Xn1im
Xni3miz
Xn1in
X5nine.
Xnin4g
Xni4o
X5nis.
Xnis4ta
Xn2it
Xn4ith
X3nitio
Xn3itor
Xni3tr
Xn1j
X4nk2
Xn5kero
Xn3ket
Xnk3in
Xn1kl
X4n1l
Xn5m
Xnme4
Xnmet4
X4n1n2
Xnne4
Xnni3al
Xnni4v
Xnob4l
Xno3ble
Xn5ocl
X4n3o2d
X3noe
X4nog
Xnoge4
Xnois5i
Xno5l4i
X5nologis
X3nomic
Xn5o5miz
Xno4mo
Xno3my
Xno4n
Xnon4ag
Xnon5i
Xn5oniz
X4nop
X5nop5o5li
Xnor5ab
Xno4rary
X4nosc
Xnos4e
Xnos5t
Xno5ta
X1nou
X3noun
Xnov3el3
Xnowl3
Xn1p4
Xnpi4
Xnpre4c
Xn1q
Xn1r
Xnru4
X2n1s2
Xns5ab
Xnsati4
Xns4c
Xn2se
Xn4s3es
Xnsid1
Xnsig4
Xn2sl
Xns3m
Xn4soc
Xns4pe
Xn5spi
Xnsta5bl
Xn1t
Xnta4b
Xnter3s
Xnt2i
Xn5tib
Xnti4er
Xnti2f
Xn3tine
Xn4t3ing
Xnti4p
Xntrol5li
Xnt4s
Xntu3me
Xnu1a
Xnu4d
Xnu5en
Xnuf4fe
Xn3uin
X3nu3it
Xn4um
Xnu1me
Xn5umi
X3nu4n
Xn3uo
Xnu3tr
Xn1v2
Xn1w4
Xnym4
Xnyp4
X4nz
Xn3za
X4oa
Xoad3
Xo5a5les
Xoard3
Xoas4e
Xoast5e
Xoat5i
Xob3a3b
Xo5bar
Xobe4l
Xo1bi
Xo2bin
Xob5ing
Xo3br
Xob3ul
Xo1ce
Xoch4
Xo3chet
Xocif3
Xo4cil
Xo4clam
Xo4cod
Xoc3rac
Xoc5ratiz
Xocre3
X5ocrit
Xoctor5a
Xoc3ula
Xo5cure
Xod5ded
Xod3ic
Xodi3o
Xo2do4
Xodor3
Xod5uct.
Xod5ucts
Xo4el
Xo5eng
Xo3er
Xoe4ta
Xo3ev
Xo2fi
Xof5ite
Xofit4t
Xo2g5a5r
Xog5ativ
Xo4gato
Xo1ge
Xo5gene
Xo5geo
Xo4ger
Xo3gie
X1o1gis
Xog3it
Xo4gl
Xo5g2ly
X3ogniz
Xo4gro
Xogu5i
X1ogy
X2ogyn
Xo1h2
Xohab5
Xoi2
Xoic3es
Xoi3der
Xoiff4
Xoig4
Xoi5let
Xo3ing
Xoint5er
Xo5ism
Xoi5son
Xoist5en
Xoi3ter
Xo5j
X2ok
Xo3ken
Xok5ie
Xo1la
Xo4lan
Xolass4
Xol2d
Xold1e
Xol3er
Xo3lesc
Xo3let
Xol4fi
Xol2i
Xo3lia
Xo3lice
Xol5id.
Xo3li4f
Xo5lil
Xol3ing
Xo5lio
Xo5lis.
Xol3ish
Xo5lite
Xo5litio
Xo5liv
Xolli4e
Xol5ogiz
Xolo4r
Xol5pl
Xol2t
Xol3ub
Xol3ume
Xol3un
Xo5lus
Xol2v
Xo2ly
Xom5ah
Xoma5l
Xom5atiz
Xom2be
Xom4bl
Xo2me
Xom3ena
Xom5erse
Xo4met
Xom5etry
Xo3mia
Xom3ic.
Xom3ica
Xo5mid
Xom1in
Xo5mini
X5ommend
Xomo4ge
Xo4mon
Xom3pi
Xompro5
Xo2n
Xon1a
Xon4ac
Xo3nan
Xon1c
X3oncil
X2ond
Xon5do
Xo3nen
Xon5est
Xon4gu
Xon1ic
Xo3nio
Xon1is
Xo5niu
Xon3key
Xon4odi
Xon3omy
Xon3s
Xonspi4
Xonspir5a
Xonsu4
Xonten4
Xon3t4i
Xontif5
Xon5um
Xonva5
Xoo2
Xood5e
Xood5i
Xoo4k
Xoop3i
Xo3ord
Xoost5
Xo2pa
Xope5d
Xop1er
X3opera
X4operag
X2oph
Xo5phan
Xo5pher
Xop3ing
Xo3pit
Xo5pon
Xo4posi
Xo1pr
Xop1u
Xopy5
Xo1q
Xo1ra
Xo5ra.
Xo4r3ag
Xor5aliz
Xor5ange
Xore5a
Xo5real
Xor3ei
Xore5sh
Xor5est.
Xorew4
Xor4gu
X4o5ria
Xor3ica
Xo5ril
Xor1in
Xo1rio
Xor3ity
Xo3riu
Xor2mi
Xorn2e
Xo5rof
Xor3oug
Xor5pe
X3orrh
Xor4se
Xors5en
Xorst4
Xor3thi
Xor3thy
Xor4ty
Xo5rum
Xo1ry
Xos3al
Xos2c
Xos4ce
Xo3scop
X4oscopi
Xo5scr
Xos4i4e
Xos5itiv
Xos3ito
Xos3ity
Xosi4u
Xos4l
Xo2so
Xos4pa
Xos4po
Xos2ta
Xo5stati
Xos5til
Xos5tit
Xo4tan
Xotele4g
Xot3er.
Xot5ers
Xo4tes
X4oth
Xoth5esi
Xoth3i4
Xot3ic.
Xot5ica
Xo3tice
Xo3tif
Xo3tis
Xoto5s
Xou2
Xou3bl
Xouch5i
Xou5et
Xou4l
Xounc5er
Xoun2d
Xou5v
Xov4en
Xover4ne
Xover3s
Xov4ert
Xo3vis
Xoviti4
Xo5v4ol
Xow3der
Xow3el
Xow5est
Xow1i
Xown5i
Xo4wo
Xoy1a
X1pa
Xpa4ca
Xpa4ce
Xpac4t
Xp4ad
X5pagan
Xp3agat
Xp4ai
Xpain4
Xp4al
Xpan4a
Xpan3el
Xpan4ty
Xpa3ny
Xpa1p
Xpa4pu
Xpara5bl
Xpar5age
Xpar5di
X3pare
Xpar5el
Xp4a4ri
Xpar4is
Xpa2te
Xpa5ter
X5pathic
Xpa5thy
Xpa4tric
Xpav4
X3pay
X4p1b
Xpd4
X4pe.
X3pe4a
Xpear4l
Xpe2c
X2p2ed
X3pede
X3pedi
Xpedia4
Xped4ic
Xp4ee
Xpee4d
Xpek4
Xpe4la
Xpeli4e
Xpe4nan
Xp4enc
Xpen4th
Xpe5on
Xp4era.
Xpera5bl
Xp4erag
Xp4eri
Xperi5st
Xper4mal
Xperme5
Xp4ern
Xper3o
Xper3ti
Xpe5ru
Xper1v
Xpe2t
Xpe5ten
Xpe5tiz
X4pf
X4pg
X4ph.
Xphar5i
Xphe3no
Xph4er
Xph4es.
Xph1ic
X5phie
Xph5ing
X5phisti
X3phiz
Xph2l
X3phob
X3phone
X5phoni
Xpho4r
X4phs
Xph3t
X5phu
X1phy
Xpi3a
Xpian4
Xpi4cie
Xpi4cy
Xp4id
Xp5ida
Xpi3de
X5pidi
X3piec
Xpi3en
Xpi4grap
Xpi3lo
Xpi2n
Xp4in.
Xpind4
Xp4ino
X3pi1o
Xpion4
Xp3ith
Xpi5tha
Xpi2tu
X2p3k2
X1p2l2
X3plan
Xplas5t
Xpli3a
Xpli5er
X4plig
Xpli4n
Xploi4
Xplu4m
Xplum4b
X4p1m
X2p3n
Xpo4c
X5pod.
Xpo5em
Xpo3et5
X5po4g
Xpoin2
X5point
Xpoly5t
Xpo4ni
Xpo4p
X1p4or
Xpo4ry
X1pos
Xpos1s
Xp4ot
Xpo4ta
X5poun
X4p1p
Xppa5ra
Xp2pe
Xp4ped
Xp5pel
Xp3pen
Xp3per
Xp3pet
Xppo5site
Xpr2
Xpray4e
X5preci
Xpre5co
Xpre3em
Xpref5ac
Xpre4la
Xpre3r
Xp3rese
X3press
Xpre5ten
Xpre3v
X5pri4e
Xprin4t3
Xpri4s
Xpris3o
Xp3roca
Xprof5it
Xpro3l
Xpros3e
Xpro1t
X2p1s2
Xp2se
Xps4h
Xp4sib
X2p1t
Xpt5a4b
Xp2te
Xp2th
Xpti3m
Xptu4r
Xp4tw
Xpub3
Xpue4
Xpuf4
Xpul3c
Xpu4m
Xpu2n
Xpur4r
X5pus
Xpu2t
X5pute
Xput3er
Xpu3tr
Xput4ted
Xput4tin
Xp3w
Xqu2
Xqua5v
X2que.
X3quer
X3quet
X2rab
Xra3bi
Xrach4e
Xr5acl
Xraf5fi
Xraf4t
Xr2ai
Xra4lo
Xram3et
Xr2ami
Xrane5o
Xran4ge
Xr4ani
Xra5no
Xrap3er
X3raphy
Xrar5c
Xrare4
Xrar5ef
X4raril
Xr2as
Xration4
Xrau4t
Xra5vai
Xrav3el
Xra5zie
Xr1b
Xr4bab
Xr4bag
Xrbi2
Xrbi4f
Xr2bin
Xr5bine
Xrb5ing.
Xrb4o
Xr1c
Xr2ce
Xrcen4
Xr3cha
Xrch4er
Xr4ci4b
Xrc4it
Xrcum3
Xr4dal
Xrd2i
Xrdi4a
Xrdi4er
Xrdin4
Xrd3ing
X2re.
Xre1al
Xre3an
Xre5arr
X5reav
Xre4aw
Xr5ebrat
Xrec5oll
Xrec5ompe
Xre4cre
X2r2ed
Xre1de
Xre3dis
Xred5it
Xre4fac
Xre2fe
Xre5fer.
Xre3fi
Xre4fy
Xreg3is
Xre5it
Xre1li
Xre5lu
Xr4en4ta
Xren4te
Xre1o
Xre5pin
Xre4posi
Xre1pu
Xr1er4
Xr4eri
Xrero4
Xre5ru
Xr4es.
Xre4spi
Xress5ib
Xres2t
Xre5stal
Xre3str
Xre4ter
Xre4ti4z
Xre3tri
Xreu2
Xre5uti
Xrev2
Xre4val
Xrev3el
Xr5ev5er.
Xre5vers
Xre5vert
Xre5vil
Xrev5olu
Xre4wh
Xr1f
Xrfu4
Xr4fy
Xrg2
Xrg3er
Xr3get
Xr3gic
Xrgi4n
Xrg3ing
Xr5gis
Xr5git
Xr1gl
Xrgo4n
Xr3gu
Xrh4
X4rh.
X4rhal
Xri3a
Xria4b
Xri4ag
Xr4ib
Xrib3a
Xric5as
Xr4ice
X4rici
X5ricid
Xri4cie
Xr4ico
Xrid5er
Xri3enc
Xri3ent
Xri1er
Xri5et
Xrig5an
X5rigi
Xril3iz
X5riman
Xrim5i
X3rimo
Xrim4pe
Xr2ina
X5rina.
Xrin4d
Xrin4e
Xrin4g
Xri1o
X5riph
Xriph5e
Xri2pl
Xrip5lic
Xr4iq
Xr2is
Xr4is.
Xris4c
Xr3ish
Xris4p
Xri3ta3b
Xr5ited.
Xrit5er.
Xrit5ers
Xrit3ic
Xri2tu
Xrit5ur
Xriv5el
Xriv3et
Xriv3i
Xr3j
Xr3ket
Xrk4le
Xrk4lin
Xr1l
Xrle4
Xr2led
Xr4lig
Xr4lis
Xrl5ish
Xr3lo4
Xr1m
Xrma5c
Xr2me
Xr3men
Xrm5ers
Xrm3ing
Xr4ming.
Xr4mio
Xr3mit
Xr4my
Xr4nar
Xr3nel
Xr4ner
Xr5net
Xr3ney
Xr5nic
Xr1nis4
Xr3nit
Xr3niv
Xrno4
Xr4nou
Xr3nu
Xrob3l
Xr2oc
Xro3cr
Xro4e
Xro1fe
Xro5fil
Xrok2
Xro5ker
X5role.
Xrom5ete
Xrom4i
Xrom4p
Xron4al
Xron4e
Xro5n4is
Xron4ta
X1room
X5root
Xro3pel
Xrop3ic
Xror3i
Xro5ro
Xros5per
Xros4s
Xro4the
Xro4ty
Xro4va
Xrov5el
Xrox5
Xr1p
Xr4pea
Xr5pent
Xrp5er.
Xr3pet
Xrp4h4
Xrp3ing
Xr3po
Xr1r4
Xrre4c
Xrre4f
Xr4reo
Xrre4st
Xrri4o
Xrri4v
Xrron4
Xrros4
Xrrys4
X4rs2
Xr1sa
Xrsa5ti
Xrs4c
Xr2se
Xr3sec
Xrse4cr
Xrs5er.
Xrs3es
Xrse5v2
Xr1sh
Xr5sha
Xr1si
Xr4si4b
Xrson3
Xr1sp
Xr5sw
Xrtach4
Xr4tag
Xr3teb
Xrten4d
Xrte5o
Xr1ti
Xrt5ib
Xrti4d
Xr4tier
Xr3tig
Xrtil3i
Xrtil4l
Xr4tily
Xr4tist
Xr4tiv
Xr3tri
Xrtroph4
Xrt4sh
Xru3a
Xru3e4l
Xru3en
Xru4gl
Xru3in
Xrum3pl
Xru2n
Xrunk5
Xrun4ty
Xr5usc
Xruti5n
Xrv4e
Xrvel4i
Xr3ven
Xrv5er.
Xr5vest
Xr3vey
Xr3vic
Xrvi4v
Xr3vo
Xr1w
Xry4c
X5rynge
Xry3t
Xsa2
X2s1ab
X5sack
Xsac3ri
Xs3act
X5sai
Xsalar4
Xsal4m
Xsa5lo
Xsal4t
X3sanc
Xsan4de
Xs1ap
Xsa5ta
X5sa3tio
Xsat3u
Xsau4
Xsa5vor
X5saw
X4s5b
Xscan4t5
Xsca4p
Xscav5
Xs4ced
X4scei
Xs4ces
Xsch2
Xs4cho
X3s4cie
X5scin4d
Xscle5
Xs4cli
Xscof4
X4scopy
Xscour5a
Xs1cu
X4s5d
X4se.
Xse4a
Xseas4
Xsea5w
Xse2c3o
X3sect
X4s4ed
Xse4d4e
Xs5edl
Xse2g
Xseg3r
X5sei
Xse1le
X5self
X5selv
X4seme
Xse4mol
Xsen5at
X4senc
Xsen4d
Xs5ened
Xsen5g
Xs5enin
X4sentd
X4sentl
Xsep3a3
X4s1er.
Xs4erl
Xser4o
X4servo
Xs1e4s
Xse5sh
Xses5t
X5se5um
X5sev
Xsev3en
Xsew4i
X5sex
X4s3f
X2s3g
Xs2h
X2sh.
Xsh1er
X5shev
Xsh1in
Xsh3io
X3ship
Xshiv5
Xsho4
Xsh5old
Xshon3
Xshor4
Xshort5
X4shw
Xsi1b
Xs5icc
X3side.
X5sides
X5sidi
Xsi5diz
X4signa
Xsil4e
X4sily
X2s1in
Xs2ina
X5sine.
Xs3ing
X1sio
X5sion
Xsion5a
Xsi2r
Xsir5a
X1sis
X3sitio
X5siu
X1siv
X5siz
Xsk2
X4ske
Xs3ket
Xsk5ine
Xsk5ing
Xs1l2
Xs3lat
Xs2le
Xslith5
X2s1m
Xs3ma
Xsmall3
Xsman3
Xsmel4
Xs5men
X5smith
Xsmol5d4
Xs1n4
X1so
Xso4ce
Xsoft3
Xso4lab
Xsol3d2
Xso3lic
X5solv
X3som
X3s4on.
Xsona4
Xson4g
Xs4op
X5sophic
Xs5ophiz
Xs5ophy
Xsor5c
Xsor5d
X4sov
Xso5vi
X2spa
X5spai
Xspa4n
Xspen4d
X2s5peo
X2sper
Xs2phe
X3spher
Xspho5
Xspil4
Xsp5ing
X4spio
Xs4ply
Xs4pon
Xspor4
X4spot
Xsqual4l
Xs1r
X2ss
Xs1sa
Xssas3
Xs2s5c
Xs3sel
Xs5seng
Xs4ses.
Xs5set
Xs1si
Xs4sie
Xssi4er
Xss5ily
Xs4sl
Xss4li
Xs4sn
Xsspend4
Xss2t
Xssur5a
Xss5w
X2st.
Xs2tag
Xs2tal
Xstam4i
X5stand
Xs4ta4p
X5stat.
Xs4ted
Xstern5i
Xs5tero
Xste2w
Xstew5a
Xs3the
Xst2i
Xs4ti.
Xs5tia
Xs1tic
X5stick
Xs4tie
Xs3tif
Xst3ing
X5stir
Xs1tle
X5stock
Xstom3a
X5stone
Xs4top
X3store
Xst4r
Xs4trad
X5stratu
Xs4tray
Xs4trid
X4stry
X4st3w
Xs2ty
X1su
Xsu1al
Xsu4b3
Xsu2g3
Xsu5is
Xsuit3
Xs4ul
Xsu2m
Xsum3i
Xsu2n
Xsu2r
X4sv
Xsw2
X4swo
Xs4y
X4syc
X3syl
Xsyn5o
Xsy5rin
X1ta
X3ta.
X2tab
Xta5bles
X5taboliz
X4taci
Xta5do
X4taf4
Xtai5lo
Xta2l
Xta5la
Xtal5en
Xtal3i
X4talk
Xtal4lis
Xta5log
Xta5mo
Xtan4de
Xtanta3
Xta5per
Xta5pl
Xtar4a
X4tarc
X4tare
Xta3riz
Xtas4e
Xta5sy
X4tatic
Xta4tur
Xtaun4
Xtav4
X2taw
Xtax4is
X2t1b
X4tc
Xt4ch
Xtch5et
X4t1d
X4te.
Xtead4i
X4teat
Xtece4
X5tect
X2t1ed
Xte5di
X1tee
Xteg4
Xte5ger
Xte5gi
X3tel.
Xteli4
X5tels
Xte2ma2
Xtem3at
X3tenan
X3tenc
X3tend
X4tenes
X1tent
Xten4tag
X1teo
Xte4p
Xte5pe
Xter3c
X5ter3d
X1teri
Xter5ies
Xter3is
Xteri5za
X5ternit
Xter5v
X4tes.
X4tess
Xt3ess.
Xteth5e
X3teu
X3tex
X4tey
X2t1f
X4t1g
X2th.
Xthan4
Xth2e
X4thea
Xth3eas
Xthe5at
Xthe3is
X3thet
Xth5ic.
Xth5ica
X4thil
X5think
X4thl
Xth5ode
X5thodic
X4thoo
Xthor5it
Xtho5riz
X2ths
X1tia
Xti4ab
Xti4ato
X2ti2b
X4tick
Xt4ico
Xt4ic1u
X5tidi
X3tien
Xtif2
Xti5fy
X2tig
X5tigu
Xtill5in
X1tim
X4timp
Xtim5ul
X2t1in
Xt2ina
X3tine.
X3tini
X1tio
Xti5oc
Xtion5ee
X5tiq
Xti3sa
X3tise
Xtis4m
Xti5so
Xtis4p
X5tistica
Xti3tl
Xti4u
X1tiv
Xtiv4a
X1tiz
Xti3za
Xti3zen
X2tl
Xt5la
Xtlan4
X3tle.
X3tled
X3tles.
Xt5let.
Xt5lo
X4t1m
Xtme4
X2t1n2
X1to
Xto3b
Xto5crat
X4todo
X2tof
Xto2gr
Xto5ic
Xto2ma
Xtom4b
Xto3my
Xton4ali
Xto3nat
X4tono
X4tony
Xto2ra
Xto3rie
Xtor5iz
Xtos2
X5tour
X4tout
Xto3war
X4t1p
X1tra
Xtra3b
Xtra5ch
Xtraci4
Xtrac4it
Xtrac4te
Xtras4
Xtra5ven
Xtrav5es5
Xtre5f
Xtre4m
Xtrem5i
X5tria
Xtri5ces
X5tricia
X4trics
X2trim
Xtri4v
Xtro5mi
Xtron5i
X4trony
Xtro5phe
Xtro3sp
Xtro3v
Xtru5i
Xtrus4
X4t1s2
Xt4sc
Xtsh4
Xt4sw
X4t3t2
Xt4tes
Xt5to
Xttu4
X1tu
Xtu1a
Xtu3ar
Xtu4bi
Xtud2
X4tue
X4tuf4
X5tu3i
X3tum
Xtu4nis
X2t3up.
X3ture
X5turi
Xtur3is
Xtur5o
Xtu5ry
X3tus
X4tv
Xtw4
X4t1wa
Xtwis4
X4two
X1ty
X4tya
X2tyl
Xtype3
Xty5ph
X4tz
Xtz4e
X4uab
Xuac4
Xua5na
Xuan4i
Xuar5ant
Xuar2d
Xuar3i
Xuar3t
Xu1at
Xuav4
Xub4e
Xu4bel
Xu3ber
Xu4bero
Xu1b4i
Xu4b5ing
Xu3ble.
Xu3ca
Xuci4b
Xuc4it
Xucle3
Xu3cr
Xu3cu
Xu4cy
Xud5d
Xud3er
Xud5est
Xudev4
Xu1dic
Xud3ied
Xud3ies
Xud5is
Xu5dit
Xu4don
Xud4si
Xu4du
Xu4ene
Xuens4
Xuen4te
Xuer4il
X3ufa
Xu3fl
Xugh3en
Xug5in
X2ui2
Xuil5iz
Xui4n
Xu1ing
Xuir4m
Xuita4
Xuiv3
Xuiv4er.
Xu5j
X4uk
Xu1la
Xula5b
Xu5lati
Xulch4
X5ulche
Xul3der
Xul4e
Xu1len
Xul4gi
Xul2i
Xu5lia
Xul3ing
Xul5ish
Xul4lar
Xul4li4b
Xul4lis
X4ul3m
Xu1l4o
X4uls
Xuls5es
Xul1ti
Xultra3
X4ultu
Xu3lu
Xul5ul
Xul5v
Xum5ab
Xum4bi
Xum4bly
Xu1mi
Xu4m3ing
Xumor5o
Xum2p
Xunat4
Xu2ne
Xun4er
Xu1ni
Xun4im
Xu2nin
Xun5ish
Xuni3v
Xun3s4
Xun4sw
Xunt3ab
Xun4ter.
Xun4tes
Xunu4
Xun5y
Xun5z
Xu4ors
Xu5os
Xu1ou
Xu1pe
Xuper5s
Xu5pia
Xup3ing
Xu3pl
Xup3p
Xupport5
Xupt5ib
Xuptu4
Xu1ra
X4ura.
Xu4rag
Xu4ras
Xur4be
Xurc4
Xur1d
Xure5at
Xur4fer
Xur4fr
Xu3rif
Xuri4fic
Xur1in
Xu3rio
Xu1rit
Xur3iz
Xur2l
Xurl5ing.
Xur4no
Xuros4
Xur4pe
Xur4pi
Xurs5er
Xur5tes
Xur3the
Xurti4
Xur4tie
Xu3ru
X2us
Xu5sad
Xu5san
Xus4ap
Xusc2
Xus3ci
Xuse5a
Xu5sia
Xu3sic
Xus4lin
Xus1p
Xus5sl
Xus5tere
Xus1tr
Xu2su
Xusur4
Xuta4b
Xu3tat
X4ute.
X4utel
X4uten
Xuten4i
X4u1t2i
Xuti5liz
Xu3tine
Xut3ing
Xution5a
Xu4tis
X5u5tiz
Xu4t1l
Xut5of
Xuto5g
Xuto5matic
Xu5ton
Xu4tou
Xuts4
Xu3u
Xuu4m
Xu1v2
Xuxu3
Xuz4e
X1va
X5va.
X2v1a4b
Xvac5il
Xvac3u
Xvag4
Xva4ge
Xva5lie
Xval5o
Xval1u
Xva5mo
Xva5niz
Xva5pi
Xvar5ied
X3vat
X4ve.
X4ved
Xveg3
Xv3el.
Xvel3li
Xve4lo
Xv4ely
Xven3om
Xv5enue
Xv4erd
X5vere.
Xv4erel
Xv3eren
Xver5enc
Xv4eres
Xver3ie
Xvermi4n
X3verse
Xver3th
Xv4e2s
X4ves.
Xves4te
Xve4te
Xvet3er
Xve4ty
Xvi5ali
X5vian
X5vide.
X5vided
X4v3iden
X5vides
X5vidi
Xv3if
Xvi5gn
Xvik4
X2vil
X5vilit
Xv3i3liz
Xv1in
X4vi4na
Xv2inc
Xvin5d
X4ving
Xvio3l
Xv3io4r
Xvi1ou
Xvi4p
Xvi5ro
Xvis3it
Xvi3so
Xvi3su
X4viti
Xvit3r
X4vity
X3viv
X5vo.
Xvoi4
X3vok
Xvo4la
Xv5ole
X5volt
X3volv
Xvom5i
Xvor5ab
Xvori4
Xvo4ry
Xvo4ta
X4votee
X4vv4
Xv4y
Xw5abl
X2wac
Xwa5ger
Xwag5o
Xwait5
Xw5al.
Xwam4
Xwar4t
Xwas4t
Xwa1te
Xwa5ver
Xw1b
Xwea5rie
Xweath3
Xwed4n
Xweet3
Xwee5v
Xwel4l
Xw1er
Xwest3
Xw3ev
Xwhi4
Xwi2
Xwil2
Xwill5in
Xwin4de
Xwin4g
Xwir4
X3wise
Xwith3
Xwiz5
Xw4k
Xwl4es
Xwl3in
Xw4no
X1wo2
Xwom1
Xwo5ven
Xw5p
Xwra4
Xwri4
Xwrita4
Xw3sh
Xws4l
Xws4pe
Xw5s4t
X4wt
Xwy4
Xx1a
Xxac5e
Xx4ago
Xxam3
Xx4ap
Xxas5
Xx3c2
Xx1e
Xxe4cuto
Xx2ed
Xxer4i
Xxe5ro
Xx1h
Xxhi2
Xxhil5
Xxhu4
Xx3i
Xxi5a
Xxi5c
Xxi5di
Xx4ime
Xxi5miz
Xx3o
Xx4ob
Xx3p
Xxpan4d
Xxpecto5
Xxpe3d
Xx1t2
Xx3ti
Xx1u
Xxu3a
Xxx4
Xy5ac
X3yar4
Xy5at
Xy1b
Xy1c
Xy2ce
Xyc5er
Xy3ch
Xych4e
Xycom4
Xycot4
Xy1d
Xy5ee
Xy1er
Xy4erf
Xyes4
Xye4t
Xy5gi
X4y3h
Xy1i
Xy3la
Xylla5bl
Xy3lo
Xy5lu
Xymbol5
Xyme4
Xympa3
Xyn3chr
Xyn5d
Xyn5g
Xyn5ic
X5ynx
Xy1o4
Xyo5d
Xy4o5g
Xyom4
Xyo5net
Xy4ons
Xy4os
Xy4ped
Xyper5
Xyp3i
Xy3po
Xy4poc
Xyp2ta
Xy5pu
Xyra5m
Xyr5ia
Xy3ro
Xyr4r
Xys4c
Xy3s2e
Xys3ica
Xys3io
X3ysis
Xy4so
Xyss4
Xys1t
Xys3ta
Xysur4
Xy3thin
Xyt3ic
Xy1w
Xza1
Xz5a2b
Xzar2
X4zb
X2ze
Xze4n
Xze4p
Xz1er
Xze3ro
Xzet4
X2z1i
Xz4il
Xz4is
X5zl
X4zm
X1zo
Xzo4m
Xzo5ol
Xzte4
X4z1z2
Xz4zy
END_OF_FILE
  if test 27421 -ne `wc -c <'lout/include/lout.hyph'`; then
    echo shar: \"'lout/include/lout.hyph'\" unpacked with wrong size!
  fi
  # end of 'lout/include/lout.hyph'
fi
if test -f 'lout/z06.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z06.c'\"
else
  echo shar: Extracting \"'lout/z06.c'\" \(27162 characters\)
  sed "s/^X//" >'lout/z06.c' <<'END_OF_FILE'
X/*@z06.c:Parser:InitParser(), Parse()@****************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z06.c                                                      */
X/*  MODULE:       Parser                                                     */
X/*  EXTERNS:      InitParser(), Parse()                                      */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define	is_cat_op(x)	((x) >= ACAT && (x) <= TJUXTA)
X#define	LEFT_ASSOC	0
X#define	RIGHT_ASSOC	1
Xstatic	OBJECT		cross_name;		/* name of the cr database   */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static Stack Handler ADT:                                                */
X/*                                                                           */
X/*      DebugStacks()       Print debug output of the stacks state           */
X/*      Shift()             Shift one token onto the stacks                  */
X/*      ShiftObj()          Optimized shift for object with no parameters    */
X/*      Reduce()            Perform one reduction of the stacks              */
X/*                                                                           */
X/*****************************************************************************/
X
X#define	MAX_STACK	50			/* size of parser stacks     */
Xstatic	OBJECT		obj_stack[MAX_STACK];	/* stack of objects          */
Xstatic	int		otop = -1;		/* top of obj_stack          */
Xstatic	OBJECT		tok_stack[MAX_STACK];	/* stack of tokens           */
Xstatic	int		ttop = -1;		/* top of tok_stack          */
Xstatic	BOOLEAN		obj_prev;		/* TRUE when object is prev  */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  PushObj(x)                                                               */
X/*  PushToken(t)                                                             */
X/*  OBJECT PopObj()                                                          */
X/*  OBJECT PopToken()                                                        */
X/*  OBJECT TokenTop                                                          */
X/*  OBJECT ObjTop                                                            */
X/*                                                                           */
X/*  Push and pop from the object and token stacks; examine top item.         */
X/*                                                                           */
X/*****************************************************************************/
X
X#define PushObj(x)							\
X{ zz_hold = x;								\
X  if( ++otop < MAX_STACK ) obj_stack[otop] = zz_hold;			\
X  else Error(FATAL, &fpos(obj_stack[otop-1]),				\
X	"object stack overflow: need to simplify expression");		\
X}
X
X#define PushToken(t)							\
X{ if( ++ttop < MAX_STACK ) tok_stack[ttop] = t;				\
X  else Error(FATAL, &fpos(tok_stack[ttop-1]),				\
X	"operator stack overflow: need to simplify expression");	\
X}
X
X#define PopObj()	obj_stack[otop--]
X#define PopToken()	tok_stack[ttop--]
X#define	TokenTop	tok_stack[ttop]
X#define	ObjTop		obj_stack[otop]
X
X
X#if DEBUG_ON
Xstatic DebugStacks(initial_ttop)
Xint initial_ttop;
X{ int i;
X  fprintf(stderr, "obj_prev: %s; otop: %d; ttop: %d\n",
X    bool(obj_prev), otop, ttop);
X  for( i = 0;  i <= otop; i++ )
X    fprintf(stderr, "obj[%d] = %s\n", i, EchoObject(null, obj_stack[i]));
X  for( i = 0;  i <= ttop;  i++ )
X  { if( i == initial_ttop+1 ) fprintf(stderr, "$\n");
X    fprintf(stderr, "tok[%d] = %s.%d\n", i, type(tok_stack[i]) == CLOSURE ?
X	SymName(actual(tok_stack[i])) : Image(type(tok_stack[i])),
X	precedence(tok_stack[i]));
X  }
X}
X#endif
X
X/*****************************************************************************/
X/*                                                                           */
X/*  insert_space(t)                                                          */
X/*                                                                           */
X/*  Add any missing catenation operator in front of token t.                 */
X/*                                                                           */
X/*****************************************************************************/
X
X#define insert_space(t)							\
Xif( obj_prev )								\
X{ int typ, prec;							\
X  if( hspace(t) + vspace(t) > 0 )					\
X  { typ = TSPACE;							\
X    prec = ACAT_PREC;							\
X  }									\
X  else									\
X  { typ = TJUXTA;							\
X    prec = JUXTA_PREC;							\
X  }									\
X  while( obj_prev && precedence(TokenTop) >= prec )  Reduce();		\
X  if( obj_prev )							\
X  { tmp = New(typ);							\
X    precedence(tmp) = prec;						\
X    vspace(tmp) = vspace(t);						\
X    hspace(tmp) = hspace(t);						\
X    mark(gap(tmp)) = FALSE;						\
X    join(gap(tmp)) = TRUE;						\
X    FposCopy( fpos(tmp), fpos(t) );					\
X    PushToken(tmp);							\
X  }									\
X} /* end insert_space */
X
X#define Shift(t, prec, rassoc, leftpar, rightpar)			\
X{ if( leftpar )								\
X  { for(;;)								\
X    { if( !obj_prev )							\
X      {	PushObj( MakeWord("", &fpos(t)) );				\
X	obj_prev = TRUE;						\
X      }									\
X      else if( precedence(TokenTop) >= prec + rassoc )			\
X      {	Reduce();							\
X      }									\
X      else break;							\
X    }									\
X  }									\
X  else insert_space(t);							\
X  PushToken(t);								\
X  if( rightpar )  obj_prev = FALSE;					\
X  else									\
X  { obj_prev = TRUE;							\
X    Reduce();								\
X  }									\
X} /* end Shift */
X
X#define ShiftObj(t)							\
X{ insert_space(t);							\
X  PushObj(t);								\
X  obj_prev = TRUE;							\
X}
X
Xstatic Reduce()
X{ OBJECT p1, p2, p3, s1, s2, tmp;
X  OBJECT op;
X  assert( obj_prev, "Reduce: obj_prev!" );
X
X  op = PopToken();
X  obj_prev = TRUE;
X  switch( type(op) )
X  {
X
X    case GSTUB_INT:
X    case GSTUB_EXT:
X    
X	TransferEnd( PopObj() );
X	obj_prev = TRUE;
X	PushObj(New(NULL_CLOS));
X	Dispose(op);
X	break;
X
X
X    case GSTUB_NONE:
X
X	PushObj(New(NULL_CLOS));
X	Dispose(op);
X	break;
X
X
X    case NULL_CLOS:
X    case CROSS:
X    case ONE_ROW:
X    case ONE_COL:
X    case WIDE:
X    case HIGH:
X    case HSCALE:
X    case VSCALE:
X    case SCALE:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case ROTATE:
X    case CASE:
X    case YIELD:
X    case FONT:
X    case SPACE:
X    case BREAK:
X    case NEXT:
X    case TAGGED:
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GRAPHIC:
X    case OPEN:
X
X	if( has_rpar(actual(op)) )
X	{ s2 = PopObj();
X	  Link(op, s2);
X	}
X	if( has_lpar(actual(op)) )
X	{ s1 = PopObj();
X	  Link(Down(op), s1);
X	  if( type(op)==CROSS && type(s1)!=CLOSURE ) Error(WARN, &fpos(s1),
X	    "left parameter of %s is not a symbol (or not visible)", KW_CROSS);
X	}
X	PushObj(op);
X	break;
X
X
X    case CLOSURE:
X    
X	if( has_rpar(actual(op)) )
X	{ s2 = New(PAR);
X	  tmp = PopObj();
X	  Link(s2, tmp);
X	  FposCopy(fpos(s2), fpos(tmp));
X	  actual(s2) = ChildSym(actual(op), RPAR);
X	  Link(op, s2);
X	}
X	if( has_lpar(actual(op)) )
X	{ s1 = New(PAR);
X	  tmp = PopObj();
X	  Link(s1, tmp);
X	  FposCopy(fpos(s1), fpos(tmp));
X	  actual(s1) = ChildSym(actual(op), LPAR);
X	  Link(Down(op), s1);
X	}
X	PushObj(op);
X	break;
X
X
X    case LBR:
X    
X	Error(WARN, &fpos(op), "unmatched %s - inserted %s", KW_LBR, KW_RBR);
X	Dispose(op);
X	break;
X
X
X    case BEGIN:
X    
X	Error(INTERN, &fpos(op), "Reduce: unmatched BEGIN");
X	break;
X
X
X    case RBR:
X    
X	if( type(TokenTop) == LBR )
X	{ /* *** FposCopy(fpos(ObjTop), fpos(TokenTop)); *** */
X	  Dispose( PopToken() );
X	}
X	else if( type(TokenTop) == BEGIN )
X	  Error(WARN, &fpos(op), "unmatched %s; inserted %s at%s (after %s)",
X	    KW_RBR, KW_LBR, EchoFilePos(&fpos(TokenTop)), KW_BEGIN);
X	else Error(INTERN, &fpos(op), "Reduce: unmatched RBR");
X	Dispose(op);
X	break;
X
X
X    case END:
X    
X	if( type(TokenTop) != BEGIN )
X	  Error(INTERN, &fpos(op), "Reduce: unmatched END");
X	else
X	{ if( actual(op) != actual(TokenTop) )
X	    if( actual(op) == StartSym )
X	      Error(WARN, &fpos(op),
X		"%s %s appended at end of file to match %s at%s",
X		KW_END, SymName(actual(TokenTop)),
X		KW_BEGIN, EchoFilePos(&fpos(TokenTop)) );
X	    else if( actual(op) == nil )
X	      Error(WARN, &fpos(op),
X		"%s replaced by %s %s to match %s at%s",
X		KW_END, KW_END, SymName(actual(TokenTop)),
X		KW_BEGIN, EchoFilePos(&fpos(TokenTop)) );
X	    else
X	      Error(WARN, &fpos(op),
X		"%s %s replaced by %s %s to match %s at%s",
X		KW_END, SymName(actual(op)),
X		KW_END, SymName(actual(TokenTop)),
X		KW_BEGIN, EchoFilePos(&fpos(TokenTop)) );
X	  Dispose( PopToken() );
X	}
X	Dispose(op);
X	break;
X
X
X    case GAP_OBJ:
X
X	p1 = PopObj();
X	Link(op, p1);
X	PushObj(op);
X	obj_prev = FALSE;
X	break;
X
X
X    case VCAT:
X    case HCAT:
X    case ACAT:
X    
X	p3 = PopObj();  p2 = PopObj();  p1 = PopObj();
X	if( type(p1) == type(op) )  Dispose(op);
X	else
X	{ Link(op, p1);
X	  p1 = op;
X	}
X	Link(p1, p2);
X	Link(p1, p3);
X	PushObj(p1);
X	break;
X
X
X    case TSPACE:
X    case TJUXTA:
X
X	p2 = PopObj();  p1 = PopObj();
X	if( type(p1) != ACAT )
X	{ tmp = New(ACAT);
X	  Link(tmp, p1);
X	  FposCopy(fpos(tmp), fpos(p1));
X	  p1 = tmp;
X	}
X	type(op) = GAP_OBJ;
X	Link(p1, op);
X	Link(p1, p2);
X	PushObj(p1);
X	break;
X
X
X    default:
X    
X	Error(INTERN, &fpos(op), "Reduce: %s", Image(type(op)) );
X	break;
X
X  } /* end switch */
X  debug0(DOP, DD, "Reduce returning; ");
X  ifdebug(DOP, DD, DebugStacks(0) );
X} /* end Reduce */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static SetScope(env, count)                                              */
X/*                                                                           */
X/*  Push scopes required to parse object whose environment is env.           */
X/*  Add to *count the number of scope pushes made.                           */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic SetScope(env, count)
XOBJECT env;  int *count;
X{ OBJECT link, y, yenv;
X  debug2(DOP, D, "SetScope( %s, %d )", EchoObject(null, env), *count);
X  assert( env != nil && type(env) == ENV, "SetScope: type(env) != ENV!" );
X  if( Down(env) != env )
X  { Child(y, Down(env));
X    assert( LastDown(y) != y, "SetScope: LastDown(y)!" );
X    link = LastDown(env) != Down(env) ? LastDown(env) : LastDown(y);
X    Child(yenv, link);
X    assert( type(yenv) == ENV, "SetScope: type(yenv) != ENV!" );
X    SetScope(yenv, count);
X    PushScope(actual(y), FALSE, FALSE);  (*count)++;
X  }
X  debug1(DOP, D, "SetScope returning, count = %d", *count);
X} /* end SetScope */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  InitParser()                                                             */
X/*                                                                           */
X/*  Initialise the parser to contain just GstubExt.                          */
X/*  Remember cross_db, the name of the cross reference database, for Parse.  */
X/*                                                                           */
X/*****************************************************************************/
X
XInitParser(cross_db)
Xunsigned char *cross_db;
X{ if( strlen(cross_db) + strlen(INDEX_SUFFIX) >= MAX_LINE )
X    Error(FATAL, no_fpos, "cross reference database file name %s%s is too long",
X	cross_db, INDEX_SUFFIX);
X  cross_name = MakeWordTwo(cross_db, INDEX_SUFFIX, no_fpos);
X  PushToken( NewToken(GSTUB_EXT, no_fpos, 0, 0, DEFAULT_PREC, StartSym) );
X} /* end InitParser */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static OBJECT ParseEnvClosure(t, encl)                                   */
X/*                                                                           */
X/*  Parse an object which is a closure with environment.  Consume the        */
X/*  concluding @Clos.                                                        */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic OBJECT ParseEnvClosure(t, encl)
XOBJECT t, encl;
X{ OBJECT env, res, y;  int count, i;
X  debug0(DOP, DD, "ParseEnvClosure(t, encl)");
X  assert( type(t) == ENV, "ParseEnvClosure: type(t) != ENV!" );
X  env = t;  t = LexGetToken();
X  while( type(t) != CLOS )  switch( type(t) )
X  {
X    case LBR:	count = 0;
X		SetScope(env, &count);
X		y = Parse(&t, encl, FALSE, FALSE);
X		if( type(y) != CLOSURE )  Error(FATAL, &fpos(y),
X			"syntax error in cross reference database");
X		for( i = 1;  i <= count;  i++ )  PopScope();
X		AttachEnv(env, y);
X		env = SetEnv(y, nil);
X		t = LexGetToken();
X		break;
X
X    case ENV:	y = ParseEnvClosure(t, encl);
X		env = SetEnv(y, env);
X		t = LexGetToken();
X		break;
X
X    default:	Error(FATAL, &fpos(t), "error in cross reference database");
X		break;
X  }
X  Dispose(t);
X  if( Down(env) == env || Down(env) != LastDown(env) )
X	Error(FATAL, &fpos(env), "error in cross reference database");
X  Child(res, Down(env));
X  DeleteNode(env);
X  debug1(DOP, DD, "ParseEnvClosure returning %s", EchoObject(null, res));
X  assert( type(res) == CLOSURE, "ParseEnvClosure: type(res) != CLOSURE!" );
X  return res;
X} /* end ParseEnvClosure */
X
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  OBJECT Parse(token, encl, defs_allowed, transfer_allowed)                */
X/*                                                                           */
X/*  Parse input tokens, beginning with *token, looking for an object of the  */
X/*  form { ... } or @Begin ... @End <sym>, and return the object.            */
X/*  The parent definition is encl, and scope has been set appropriately.     */
X/*  Parse reads up to and including the last token of the object             */
X/*  (the right brace or <sym>), and returns nil in *token.                   */
X/*                                                                           */
X/*  If defs_allowed == TRUE, there may be local definitions in the object.   */
X/*  In this case, encl is guaranteed to be the enclosing definition.         */
X/*                                                                           */
X/*  If transfer_allowed == TRUE, the parser may transfer components to the   */
X/*  galley handler as they are read.                                         */
X/*                                                                           */
X/*  Note: the lexical analyser returns "@End \Input" at end of input, so the */
X/*  parser does not have to handle end of input separately.                  */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT Parse(token, encl, defs_allowed, transfer_allowed)
XOBJECT *token, encl;  BOOLEAN defs_allowed, transfer_allowed;
X{ OBJECT t, x, tmp, xsym, env, y, res;
X  int i, initial_ttop = ttop;
X  unsigned char buff[MAX_LINE];  FILE_NUM index_fnum;
X
X  debug4(DOP, D, "[ Parse(%s, %s, %s, %s)", EchoToken(*token), SymName(encl),
X	bool(defs_allowed), bool(transfer_allowed));
X  assert( type(*token) == LBR || type(*token) == BEGIN, "Parse: *token!" );
X
X  obj_prev = FALSE;
X  Shift(*token, precedence(*token), 0, FALSE, TRUE);
X  t = LexGetToken();
X  if( defs_allowed )
X  { ReadDefinitions(&t, encl, LOCAL);
X    if( encl == StartSym ) /* transition point from defs to content */
X    {
X      /* if error in definitions, stop now */
X      if( ErrorSeen() )  Error(FATAL, &fpos(t), "Exiting now");
X
X      /* load cross-references from previous run, open new cross refs */
X      if( AllowCrossDb )
X      {	index_fnum = DefineFile(cross_name, INDEX_FILE, SOURCE_PATH);
X	OldCrossDb = DbLoad(index_fnum,string(cross_name),&fpos(t),FALSE,nil);
X	NewCrossDb = DbCreate(string(cross_name), &fpos(t));
X      }
X      else OldCrossDb = NewCrossDb = nil;
X
X      /* tidy up and possibly print symbol table */
X      FlattenUses();
X      ifdebug(DST, D, EchoObject(stderr, StartSym) );
X
X      /* read @Use commands and construct env */
X      env = New(ENV);
X      while( type(t) == USE )
X      {
X	OBJECT crs, res_env;  STYLE style;
X	Dispose(t);  t = LexGetToken();
X	if( type(t) != LBR )
X	  Error(FATAL, &fpos(t), "%s expected after %s", KW_LBR, KW_USE);
X	y = Parse(&t, encl, FALSE, FALSE);
X	if( type(y) == CROSS )
X	{ y = CrossExpand(y, env, &style, FALSE, &crs, &res_env);
X	  AttachEnv(res_env, y);
X	  env = SetEnv(y, env);
X	}
X	else if( type(y) == CLOSURE )
X	{ AttachEnv(env, y);
X	  env = SetEnv(y, nil);
X	}
X	else Error(FATAL, &fpos(y), "invalid parameter of %s", KW_USE);
X
X	PushScope(actual(y), FALSE, TRUE);
X	t = LexGetToken();
X      }
X      TransferInit(env);
X    }
X  }
X
X  for(;;)
X  { 
X    ifdebug(DOP, DD, DebugStacks(initial_ttop) );
X    debug2(DOP, DD, ">> %s.%d", EchoToken(t), precedence(t) );
X
X    switch( type(t) )
X    {
X
X      case WORD:
X      
X	if( string(t)[0] == '@' )
X	  Error(WARN, &fpos(t), "symbol %s unknown or misspelt", string(t));
X	ShiftObj(t);
X	t = LexGetToken();
X	break;
X
X
X      case VCAT:
X      case HCAT:
X      case ACAT:
X      
X	/* clean up left context */
X	Shift(t, precedence(t), LEFT_ASSOC, TRUE, TRUE);
X
X	/* invoke transfer subroutines if appropriate */
X	if( type(t) == VCAT && !has_join(actual(t))
X		&& type(tok_stack[ttop-2]) == GSTUB_EXT )
X	{ TransferComponent( PopObj() );
X	  obj_prev = FALSE;
X	  tmp = New(NULL_CLOS);
X	  FposCopy( fpos(tmp), fpos(t) );
X	  PushObj(tmp);
X	}
X
X	/* push GAP_OBJ token, to cope with 3 parameters */
X	x = New(GAP_OBJ);
X	mark(gap(x)) = has_mark(actual(t));
X	join(gap(x)) = has_join(actual(t));
X	precedence(x) = GAP_PREC;
X	FposCopy( fpos(x), fpos(t) );
X	Shift(x, GAP_PREC, LEFT_ASSOC, FALSE, TRUE);
X
X	/* if op is followed by space, insert {} */
X	t = LexGetToken();
X	if( hspace(t) + vspace(t) > 0 )
X	{ ShiftObj(MakeWord("", &fpos(x)));
X	}
X	break;
X
X
X      case CROSS:
X      case NULL_CLOS:
X      case ONE_COL:
X      case ONE_ROW:
X      case WIDE:
X      case HIGH:
X      case HSCALE:
X      case VSCALE:
X      case SCALE:
X      case HCONTRACT:
X      case VCONTRACT:
X      case HEXPAND:
X      case VEXPAND:
X      case PADJUST:
X      case HADJUST:
X      case VADJUST:
X      case ROTATE:
X      case CASE:
X      case YIELD:
X      case FONT:
X      case SPACE:
X      case BREAK:
X      case NEXT:
X      case TAGGED:
X      case INCGRAPHIC:
X      case SINCGRAPHIC:
X      case GRAPHIC:
X
X	/* clean up left context of t (these ops are all right associative) */
X	Shift(t, precedence(t), RIGHT_ASSOC,
X		has_lpar(actual(t)), has_rpar(actual(t)));
X	t = LexGetToken();
X	break;
X
X
X      case BEGIN:
X      
X	if( actual(t) == nil )
X	{ Error(WARN, &fpos(t), "%s replaced by %s", KW_BEGIN, KW_LBR);
X	  type(t) = LBR;
X	}
X	/* NB NO BREAK! */
X
X
X      case LBR:
X      
X	Shift(t, LBR_PREC, 0, FALSE, TRUE);
X	t = LexGetToken();
X	break;
X
X
X      case END:
X      
X	x = LexGetToken();
X	if( type(x) == CLOSURE )
X	{ actual(t) = actual(x);
X	  Dispose(x);
X	  x = nil;
X	}
X	else if( type(x) == WORD && string(x)[0] == '@' )
X	{ Error(WARN,&fpos(x),"unknown or misspelt symbol %s after %s deleted",
X		string(x), KW_END);
X	  actual(t) = nil;
X	  Dispose(x);
X	  x = nil;
X	}
X	else
X	{ Error(WARN, &fpos(x), "symbol expected after %s", KW_END);
X	  actual(t) = nil;
X	}
X	Shift(t, precedence(t), 0, TRUE, FALSE);
X	if( ttop == initial_ttop )
X	{ ifdebug(DOP, DD, DebugStacks(initial_ttop));
X	  *token = x;
X	  debug0(DOP, D, "] Parse returning");
X	  ifdebug(DOP, D, EchoObject(stderr, ObjTop));
X	  obj_prev = FALSE;
X	  return PopObj();
X	}
X	t = (x != nil) ? x : LexGetToken();
X	break;
X
X
X      case RBR:
X      
X	Shift(t, precedence(t), 0, TRUE, FALSE);
X	if( ttop == initial_ttop )
X	{ ifdebug(DOP, DD, DebugStacks(initial_ttop));
X	  *token = nil;
X	  debug0(DOP, D, "] Parse returning");
X	  ifdebug(DOP, D, EchoObject(stderr, ObjTop));
X	  obj_prev = FALSE;
X	  return PopObj();
X	}
X	t = LexGetToken();
X	break;
X				
X
X      case USE:
X      
X	Error(FATAL, &fpos(t), "%s symbol out of place", SymName(actual(t)));
X	break;
X
X
X      case ENV:
X      
X	/* only occurs in cross reference databases */
X	res = ParseEnvClosure(t, encl);
X	ShiftObj(res);
X	t = LexGetToken();
X	break;
X
X
X      case LVIS:
X      
X	/* only occurs in cross-reference databases */
X	SuppressVisible();
X	Dispose(t);  t = LexGetToken();
X	UnSuppressVisible();
X	if( type(t) != CLOSURE )
X	  Error(FATAL, &fpos(t), "symbol expected following %s", KW_LVIS);
X	/* NB NO BREAK! */
X
X
X      case CLOSURE:
X      
X	x = t;  xsym = actual(x);
X
X	/* look ahead one token, which could be an NPAR */
X	PushScope(xsym, TRUE, FALSE);
X	t = LexGetToken();
X	PopScope();
X
X	/* if x starts a cross-reference, make it a CLOSURE */
X	if( type(t) == CROSS )
X	{ ShiftObj(x);
X	  break;
X	}
X
X	/* clean up left context of x */
X	Shift(x, precedence(x),right_assoc(xsym),has_lpar(xsym),has_rpar(xsym));
X
X	/* update uses relation if required */
X	if( encl != StartSym )
X	{ if( !has_target(xsym) )  InsertUses(encl, xsym);
X	  else uses_galley(encl) = TRUE;
X	}
X
X	/* read named parameters */
X	while( type(t) == CLOSURE && enclosing(actual(t)) == xsym
X				       && type(actual(t)) == NPAR )
X	{	
X	  /* check syntax and attach the named parameter to x */
X	  OBJECT new_par = t;
X	  t = LexGetToken();
X	  if( type(t) != LBR )
X	  { Error(WARN, &fpos(new_par), "%s must follow named parameter %s",
X		    KW_LBR, SymName(actual(new_par)) );
X	    Dispose(new_par);
X	    break;
X	  }
X
X	  /* read the named parameter's body */
X	  PushScope(actual(new_par), FALSE, FALSE);
X	  tmp = Parse(&t, encl, FALSE, FALSE);
X	  type(new_par) = PAR;
X	  Link(x, new_par);
X	  Link(new_par, tmp);
X	  PopScope();
X
X	  /* get next token, possibly another NPAR */
X	  PushScope(xsym, TRUE, FALSE);	 /* allow NPARs only */
X	  if( t == nil )  t = LexGetToken();
X	  PopScope();
X
X	} /* end while */
X	obj_prev = !has_rpar(xsym);
X
X	/* record symbol name in BEGIN following, if any */
X	if( type(t) == BEGIN )
X	{ if( !has_rpar(xsym) )
X	    Error(WARN, &fpos(x), "%s takes no right parameter", SymName(xsym));
X	  else actual(t) = xsym;
X	}
X
X	/* if x can be transferred, do so */
X	if( transfer_allowed && has_target(xsym) && !has_key(xsym) )
X	{   
X	  if( !has_rpar(xsym) || uses_count(ChildSym(xsym, RPAR)) <= 1 )
X	  {
X	    debug1(DGT, DD, "examining transfer of %s", SymName(xsym));
X	    ifdebug(DGT, DD, DebugStacks(initial_ttop));
X	    i = has_rpar(xsym) ? ttop -1 : ttop;
X	    while( is_cat_op(type(tok_stack[i])) )   i--;
X	    if( (type(tok_stack[i])==LBR || type(tok_stack[i])==BEGIN)
X		  && type(tok_stack[i-1]) == GSTUB_EXT )
X	    {
X	      /* at this point it is likely that x is transferable */
X	      if( has_rpar(xsym) )
X	      { tmp = New(CLOSURE);
X		actual(tmp) = InputSym;
X		FposCopy( fpos(tmp), fpos(t) );
X		PushObj(tmp);  obj_prev = TRUE;
X		Reduce();
X	      }
X	      x = PopObj();
X	      x = TransferBegin(x);
X	      if( type(x) == CLOSURE )	/* failure: unReduce */
X	      {	if( has_rpar(xsym) )
X		{ Child(tmp, LastDown(x));
X		  assert(type(tmp)==PAR && type(actual(tmp))==RPAR,
X				"Parse: can't undo rpar" );
X		  DisposeChild(LastDown(x));
X		  if( has_lpar(xsym) )
X		  { Child(tmp, Down(x));
X		    assert(type(tmp)==PAR && type(actual(tmp))==LPAR,
X				"Parse: can't undo lpar" );
X		    Child(tmp, Down(tmp));
X		    PushObj(tmp);
X		    DeleteLink(Up(tmp));
X		    DisposeChild(Down(x));
X		  }
X		  PushToken(x);  obj_prev = FALSE;
X		}
X		else
X		{ PushObj(x);
X		  obj_prev = TRUE;
X		}
X	      }
X	      else /* success */
X	      { obj_prev = FALSE;
X	        Shift(x, NO_PREC, 0, FALSE, has_rpar(xsym));
X	      }
X	    }
X	  }
X	} /* end if has_target */
X
X	if( has_body(xsym) )
X	{ if( type(t) == BEGIN || type(t) == LBR )
X	  { PushScope(xsym, FALSE, TRUE);
X	    PushScope(ChildSym(xsym, RPAR), FALSE, FALSE);
X	    PushObj( Parse(&t, encl, FALSE, TRUE) );
X	    obj_prev = TRUE;
X	    Reduce();
X	    PopScope();
X	    PopScope();
X	    if( t == nil )  t = LexGetToken();
X	  }
X	  else
X	  { Error(WARN, &fpos(t),
X	      "%s parameter of %s must be enclosed in %s .. %s",
X	      KW_BODY, SymName(xsym), KW_LBR, KW_RBR);
X	  }
X	}
X	break;
X
X
X      case OPEN:
X
X	x = t;  xsym = nil;
X	Shift(t, precedence(t), RIGHT_ASSOC, TRUE, TRUE);
X	if( type(ObjTop) == CLOSURE )  xsym = actual(ObjTop);
X	else if( type(ObjTop) == CROSS && Down(ObjTop) != ObjTop )
X	{ Child(tmp, Down(ObjTop));
X	  if( type(tmp) == CLOSURE )  xsym = actual(tmp);
X	}
X	t = LexGetToken();
X
X	if( xsym == nil )
X	  Error(WARN, &fpos(x), "invalid left parameter of %s", KW_OPEN);
X	else if( type(t) != BEGIN && type(t) != LBR )
X	  Error(WARN, &fpos(t), "%s parameter of %s not enclosed in %s .. %s",
X		   KW_RIGHT, KW_OPEN, KW_LBR, KW_RBR);
X	else
X	{ PushScope(xsym, FALSE, TRUE);
X	  tmp = Parse(&t, encl, FALSE, FALSE);
X	  ShiftObj(tmp);
X	  PopScope();
X	  if( t == nil )  t = LexGetToken();
X	  Reduce();
X	}
X	break;
X
X
X      default:
X      
X	Error(INTERN, &fpos(t), "Parse: type %s", Image(type(t)) );
X	break;
X
X    } /* end switch */
X  } /* end for */
X
X} /* end Parse */
END_OF_FILE
  if test 27162 -ne `wc -c <'lout/z06.c'`; then
    echo shar: \"'lout/z06.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z06.c'
fi
if test -f 'lout/z33.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lout/z33.c'\"
else
  echo shar: Extracting \"'lout/z33.c'\" \(24078 characters\)
  sed "s/^X//" >'lout/z33.c' <<'END_OF_FILE'
X/*@z33.c:Database Service:DbCreate(), DbRetrieve()@***************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.03)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z33.c                                                      */
X/*  MODULE:       Database Service                                           */
X/*  EXTERNS:      OldCrossDb, NewCrossDb, DbCreate(), DbInsert(),            */
X/*                DbConvert(), DbLoad(), DbRetrieve(), DbRetrieveNext()      */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define	reading(x)	threaded(x)
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OldCrossDb     Database containing cross references from previous run.   */
X/*  NewCrossDb     Writable database of cross references from this run.      */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT OldCrossDb, NewCrossDb;
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DbCreate(str, fpos)                                               */
X/*                                                                           */
X/*  Create a new writable database with name (i.e. file stem) str and file   */
X/*  position fpos for error messages.                                        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT DbCreate(str, fposn)
Xunsigned char *str;  FILE_POS *fposn;
X{ OBJECT db;
X  debug2(DBS, D, "DbCreate( %s,%s )", str, EchoFilePos(fposn));
X  db = MakeWord(str, fposn);
X  reading(db) = FALSE;
X  filep(db) = null;
X  debug1(DBS, D, "DbCreate returning %s", EchoObject(null, db));
X  return db;
X} /* end DbCreate */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  #define SymToNum(db, sym, num, gall)                                     */
X/*                                                                           */
X/*  Set num to the number used to refer to sym in database db.  If sym is    */
X/*  not currently referred to in db, create a new number and record sym.     */
X/*  If gall is true, sym is the target of galleys stored in this database.   */
X/*  Store in boolean fields db_targ(link) and is_extern_target(sym).         */
X/*                                                                           */
X/*****************************************************************************/
X
X#define SymToNum(db, sym, num, gall)					\
X{ OBJECT link, yy;  int count;						\
X  count = 0;								\
X  for( link = Down(db);  link != db;  link = NextDown(link) )		\
X  { Child(yy, link);							\
X    assert(type(yy)==CROSS_SYM || type(yy)==ACAT, "SymToNum: yy!");	\
X    if( type(yy) != CROSS_SYM )  continue;				\
X    if( symb(yy) == sym )  break;					\
X    if( number(link) > count )  count = number(link);			\
X  }									\
X  if( link == db )							\
X  { if( cross_sym(sym) == nil )  CrossInit(sym);			\
X    link = Link(db, cross_sym(sym));					\
X    number(link) = count + 1;						\
X    db_targ(link) = FALSE;						\
X  }									\
X  num = number(link);							\
X  if( gall )  db_targ(link) = is_extern_target(sym) =			\
X				uses_extern_target(sym) = TRUE;		\
X} /* end SymToNum */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  #define NumToSym(db, num, sym)                                           */
X/*                                                                           */
X/*  Set sym to the symbol which is referred to in database db by num.        */
X/*                                                                           */
X/*****************************************************************************/
X
X#define NumToSym(db, num, sym)						\
X{ OBJECT link, y;							\
X  for( link = Down(db);  link != db;  link = NextDown(link) )		\
X  { Child(y, link);							\
X    if( type(y) == CROSS_SYM && number(link) == num )  break;		\
X  }									\
X  if( link == db )  Error(INTERN, &fpos(db), "NumToSym: no sym!");	\
X  assert( type(y) == CROSS_SYM, "NumToSym: y!" );			\
X  sym = symb(y);							\
X} /* end NumToSym */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  DbInsert(db, gall, sym, tag, seq, dfnum, dfpos)                          */
X/*                                                                           */
X/*  Insert a new entry into writable database db.  The primary key of the    */
X/*  entry has these three parts:                                             */
X/*                                                                           */
X/*      gall        TRUE if inserting a galley                               */
X/*      sym         The symbol which is the target of this entry             */
X/*      tag         The tag of this target (must be a non-null string)       */
X/*                                                                           */
X/*  There is also an auxiliary key, seq, which enforces an ordering on       */
X/*  entries with equal primary keys.  This is used for sorted galleys.       */
X/*  The value of the entry has the following parts:                          */
X/*                                                                           */
X/*      dfnum       The file containing the object                           */
X/*      dfpos       The position of the object in that file                  */
X/*                                                                           */
X/*****************************************************************************/
X
XDbInsert(db, gall, sym, tag, seq, dfnum, dfpos)
XOBJECT db;  BOOLEAN gall;  OBJECT sym;  unsigned char *tag, *seq;
XFILE_NUM dfnum;  long dfpos;
X{ int symnum;
X  unsigned char buff[MAX_LINE];
X  assert( type(db) == WORD, "DbInsert: db!" );
X  assert( tag[0] != '\0', "DbInsert: null tag!" );
X  assert( seq[0] != '\0', "DbInsert: null seq!" );
X  ifdebug(DPP, D, ProfileOn("DbInsert"));
X  debug6(DBS, D, "DbInsert(%s, %s, %s, %s, %s, %s, dfpos)",
X	string(db), bool(gall), SymName(sym), tag, seq,
X	dfnum == NO_FILE ? (unsigned char *) "." : FileName(dfnum));
X  if( reading(db) )  Error(INTERN, &fpos(db), "insert into reading database!");
X  if( filep(db) == null )
X  { if( strlen(string(db)) + strlen(NEW_INDEX_SUFFIX) >= MAX_LINE )
X      Error(FATAL, no_fpos, "database file name %s%s is too long",
X	string(db), NEW_INDEX_SUFFIX);
X    sprintf(buff, "%s%s", string(db), NEW_INDEX_SUFFIX);
X    filep(db) = fopen(buff, "w");
X    if( filep(db) == null )
X      Error(FATAL, &fpos(db), "cannot write to database file %s", buff);
X  }
X  SymToNum(db, sym, symnum, gall);
X  fprintf(filep(db), "%s%d&%s\t%s\t%ld\t%s\n", gall ? "&" : "", symnum,
X    tag, seq, dfpos, dfnum==NO_FILE ? (unsigned char *) "." : FileName(dfnum));
X  debug0(DBS, D, "DbInsert returning.");
X  ifdebug(DPP, D, ProfileOff("DbInsert"));
X} /* end DbInsert */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  DbConvert(db, full_name)                                                 */
X/*                                                                           */
X/*  Convert database db from writable to readable, then dispose it.          */
X/*  full_name is TRUE if symbols are to be known by their full path name.    */
X/*                                                                           */
X/*****************************************************************************/
X
XDbConvert(db, full_name)
XOBJECT db;  BOOLEAN full_name;
X{ unsigned char buff[2*MAX_LINE + 20], oldname[MAX_LINE+10], newname[MAX_LINE];
X  OBJECT link, y;
X  ifdebug(DPP, D, ProfileOn("DbConvert"));
X  debug2(DBS, D, "DbConvert( %d %s )", (int) db,string(db));
X  if( reading(db) )  Error(INTERN, &fpos(db), "DbConvert: reading database!");
X  sprintf(newname, "%s", string(db));
X  sprintf(oldname, "%s%s", string(db), NEW_INDEX_SUFFIX);
X  if( filep(db) != null )
X  { for( link = Down(db);  link != db;  link = NextDown(link) )
X    { Child(y, link);
X      assert( type(y) == CROSS_SYM || type(y) == ACAT, "DbConvert: y!" );
X      if( type(y) != CROSS_SYM )  continue;
X      fprintf(filep(db), "%s %d %s\n", db_targ(link) ? "#target" : "#symbol",
X	number(link), full_name ? FullSymName(symb(y)," ") : SymName(symb(y)));
X    }
X    fclose(filep(db));
X    sprintf(buff, "sort -o %s %s", newname, oldname);
X    system(buff);
X  }
X  else unlink(newname);
X  unlink(oldname);
X  DeleteNode(db);
X  debug0(DBS, D, "DbConvert returning.");
X  ifdebug(DPP, D, ProfileOff("DbConvert"));
X} /* end DbConvert */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DbLoad(index_fnum, str, fpos, create, symbs)                      */
X/*                                                                           */
X/*  Open the database whose name (i.e. <stem>.li) is str for reading.        */
X/*  This file has already been defined; its internal name is index_fnum.     */
X/*  If it won't open and create is true, try to create it from <stem>.ld.    */
X/*                                                                           */
X/*  symbs is an ACAT of CLOSUREs showing the symbols that the database may   */
X/*  contain; or nil if the database may contain any symbol.                  */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT DbLoad(index_fnum, str, fposn, create, symbs)
XFILE_NUM index_fnum;  unsigned char *str;  FILE_POS *fposn;
XBOOLEAN create;  OBJECT symbs;
X{ FILE *fp;  OBJECT db, t, res, tag, par, sym, link, y;
X  int i, lnum, num, count;  unsigned char line[MAX_LINE];
X  unsigned char indexname[MAX_LINE], dataname[MAX_LINE], sym_name[MAX_LINE];
X  FILE_NUM dfnum;  long dfpos;  BOOLEAN gall;
X  ifdebug(DPP, D, ProfileOn("DbLoad"));
X  debug4(DBS, D, "DbLoad(%s, %s, %s, %s, symbs)", FileName(index_fnum),
X    str, EchoFilePos(fposn), bool(create));
X
X  /* open or else create index file fp */
X  fp = OpenFile(index_fnum, create);
X  if( fp == null && create )
X  { db = nil;
X    strcpy(dataname, str);
X    strcpy(&dataname[strlen(dataname) - strlen(INDEX_SUFFIX)], DATA_SUFFIX);
X    dfnum = DefineFile(MakeWord(dataname, fposn), DATABASE_FILE, DATABASE_PATH);
X    dfpos = 0L;
X    LexPush(dfnum, 0, DATABASE_FILE);
X    t = LexGetToken();
X    while( type(t) == LBR )
X    { res = Parse(&t, StartSym, FALSE, FALSE);
X      if( t != nil || type(res) != CLOSURE )
X	Error(FATAL, &fpos(res), "syntax error in database file %s", dataname);
X      assert( symbs != nil, "DbLoad: create && symbs == nil!" );
X      if( symbs != nil )
X      {	for( link = Down(symbs);  link != symbs;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( type(y) == CLOSURE && actual(y) == actual(res) )  break;
X	}
X	if( link == symbs )  Error(FATAL, &fpos(res),
X	  "%s found in database but not declared in %s line",
X	  SymName(actual(res)), KW_DATABASE);
X      }
X      tag = nil;
X      for( link = Down(res);  link != res;  link = NextDown(link) )
X      {	Child(par, link);
X	if( type(par) == PAR && is_tag(actual(par)) && Down(par) != par )
X	{ Child(tag, Down(par));
X	  break;
X	}
X      }
X      if( tag == nil )
X	Error(FATAL, &fpos(res), "database symbol %s has no tag", SymName(res));
X      tag = ReplaceWithTidy(tag);
X      if( type(tag) != WORD )
X	Error(FATAL, &fpos(res), "database symbol's tag is not a simple word");
X      if( string(tag)[0] == '\0' )
X	Error(FATAL, &fpos(res), "database symbol's tag is an empty word");
X      if( db == nil )
X      {	strcpy(indexname, FileName(dfnum));
X	strcpy(&indexname[strlen(indexname)-strlen(DATA_SUFFIX)], INDEX_SUFFIX);
X	db = DbCreate(indexname, fposn);
X      }
X      DbInsert(db, FALSE, actual(res), string(tag), "0", NO_FILE, dfpos);
X      DisposeObject(res);
X      dfpos = LexNextTokenPos();
X      t = LexGetToken();
X    }
X    if( type(t) != END )
X      Error(FATAL, &fpos(t), "%s or end of file expected here", KW_LBR);
X    LexPop();
X    if( db == nil )
X    { strcpy(indexname, FileName(dfnum));
X      strcpy(&indexname[strlen(indexname)-strlen(DATA_SUFFIX)], INDEX_SUFFIX);
X      db = DbCreate(indexname, fposn);
X    }
X    DbConvert(db, FALSE);
X    fp = OpenFile(index_fnum, FALSE);
X    if( fp == null )
X      Error(FATAL, &fpos(db), "cannot open database file %s", indexname);
X  }
X  else strcpy(indexname, str);
X
X  /* set up database record */
X  db = MakeWord(FileName(index_fnum), fposn);
X  reading(db) = TRUE;
X  filep(db) = fp;
X  if( symbs != nil )
X  { assert( type(symbs) = ACAT, "DbLoad: type(symbs)!" );
X    Link(db, symbs);
X  }
X  if( fp == null )
X  { debug1(DBS, D, "DbLoad returning (empty) %s", string(db));
X    ifdebug(DPP, D, ProfileOff("DbLoad"));
X    return db;
X  }
X
X  /* read header lines of index file, find its symbols */
X  left_pos(db) = 0;
X  lnum = 0;
X  while( fgets(line, MAX_LINE, fp) != NULL && line[0] == '#' )
X  { lnum++;
X    left_pos(db) = (int) ftell(fp);
X    gall = line[1] == 't';
X    sscanf(line, gall ? "#target %d" : "#symbol %d", &num);
X    for( i = 8;  line[i] != ' ' && line[i] != '\0';  i++ );
X    if( symbs == nil )
X    {
X      /* any symbols are possible, full path names in index file required */
X      count = 0;  sym = StartSym;
X      while( line[i] != '\n' && line[i] != '\0' )
X      {	PushScope(sym, FALSE, FALSE);  count++;
X	sscanf(&line[i+1], "%s", sym_name);
X	sym = SearchSym(sym_name, strlen(sym_name));
X	i += strlen(sym_name) + 1;
X      }
X      for( i = 1;  i <= count;  i++ )  PopScope();
X    }
X    else
X    {
X      /* only symbs symbols possible, full path names not required */
X      sym = nil;
X      sscanf(&line[i+1], "%s", sym_name);
X      for( link = Down(symbs);  link != symbs;  link = NextDown(link) )
X      {	Child(y, link);
X	assert( type(y) == CLOSURE, "DbLoad: type(y) != CLOSURE!" );
X	if( strcmp(sym_name, SymName(actual(y))) == 0 )
X	{ sym = actual(y);
X	  break;
X	}
X      }
X    }
X    if( sym != nil && sym != StartSym )
X    { if( cross_sym(sym) == nil )  CrossInit(sym);
X      link = Link(db, cross_sym(sym));
X      number(link) = num;
X      db_targ(link) = gall;
X      if( gall )  is_extern_target(sym) = uses_extern_target(sym) = TRUE;
X    }
X    else
X    { Error(WARN, &fpos(db), "undefined symbol in database file %s (line %d)",
X			indexname, lnum);
X      debug1(DBS, D, "DbLoad returning %s (error)", string(db));
X      fclose(filep(db));	/* effectively an empty database */
X      filep(db) = null;
X      ifdebug(DPP, D, ProfileOff("DbLoad"));
X      return db;
X    }
X  }
X  debug1(DBS, D, "DbLoad returning %s", string(db));
X  ifdebug(DPP, D, ProfileOff("DbLoad"));
X  return db;
X} /* end DbLoad */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  static BOOLEAN SearchFile(fp, left, right, str, line)                    */
X/*                                                                           */
X/*  File fp is a text file.  left is the beginning of a line, right is the   */
X/*  end of a line.   Search the file by binary search for a line beginning   */
X/*  with str.  If found, return it in line, else return FALSE.               */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic BOOLEAN SearchFile(fp, left, right, str, line)
XFILE *fp;  int left, right;  unsigned char *str, *line;
X{ int l, r, mid, mid_end;  unsigned char buff[MAX_LINE];  BOOLEAN res;
X  ifdebug(DPP, D, ProfileOn("SearchFile"));
X  debug3(DBS, DD, "SearchFile(fp, %d, %d, %s, line)", left, right, str);
X
X  l = left;  r = right;
X  while( l <= r )
X  {
X    /* loop invt: (l==0 or fp[l-1]=='\n') and (fp[r] == '\n')       */
X    /* and first key >= str lies in the range fp[l..r+1]            */
X
X    /* find line near middle of the range; mid..mid_end brackets it */
X    debug2(DBS, DD, "  start loop: l = %d, r = %d", l, r);
X    mid = (l + r)/2;
X    fseek(fp, (long) mid, 0);
X    do { mid++; } while( getc(fp) != '\n' );
X    if( mid == r + 1 )
X    { mid = l;
X      fseek(fp, (long) mid, 0);
X    }
X    fgets(line, MAX_LINE, fp);
X    mid_end = (int) ftell(fp) - 1;
X    debug3(DBS, DD, "  mid: %d, mid_end: %d, line: %s", mid, mid_end, line);
X    assert( l <= mid,      "SearchFile: l > mid!"        );
X    assert( mid < mid_end, "SearchFile: mid >= mid_end!" );
X    assert( mid_end <= r,  "SearchFile: mid_end > r!"    );
X
X    /* compare str with this line and prepare next step */
X    debug2(DBS, DD, "  comparing key %s with line %s", str, line);
X    if( strcmp(str, line) <= 0 )  r = mid - 1;
X    else l = mid_end + 1;
X  } /* end while */
X
X  /* now first key >= str lies in fp[l]; compare it with str */
X  if( l < right )
X  { fseek(fp, (long) l, 0);
X    fgets(line, MAX_LINE, fp);
X    sscanf(line, "%s", buff);
X    res = strcmp(str, buff) == 0;
X  }
X  else res = FALSE;
X  debug1(DBS, DD, "SearchFile returning %s", bool(res));
X  ifdebug(DPP, D, ProfileOff("SearchFile"));
X  return res;
X} /* end SearchFile */
X
X
X/*@@**************************************************************************/
X/*                                                                           */
X/*  BOOLEAN DbRetrieve(db, gall, sym, tag, seq, dfnum, dfpos, cont)          */
X/*                                                                           */
X/*  Retrieve the first entry of database db with the given gall, sym and     */
X/*  tag.  Set *seq, *dfnum, *dfpos to the associated value.                  */
X/*  Set *cont to a private value for passing to DbRetrieveNext.              */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN DbRetrieve(db, gall, sym, tag, seq, dfnum, dfpos, cont)
XOBJECT db;  BOOLEAN gall;  OBJECT sym;  unsigned char *tag, *seq;
XFILE_NUM *dfnum;  long *dfpos;  long *cont;
X{ int symnum;  unsigned char line[MAX_LINE], buff[MAX_LINE];  OBJECT y;
X  ifdebug(DPP, D, ProfileOn("DbRetrieve"));
X  debug4(DBS, D, "DbRetrieve(%s, %s%s&%s)", string(db), gall ? "&" : "",
X	SymName(sym), tag);
X  if( !reading(db) || filep(db) == null )
X  { debug0(DBS, D, "DbRetrieve returning FALSE (empty or not reading)");
X    ifdebug(DPP, D, ProfileOff("DbRetrieve"));
X    return FALSE;
X  }
X  SymToNum(db, sym, symnum, FALSE);
X  sprintf(buff, "%s%d&%s", gall ? "&" : "", symnum, tag);
X  fseek(filep(db), 0L, 2);
X  if( !SearchFile(filep(db), left_pos(db), (int) ftell(filep(db))-1,buff,line) )
X  { debug0(DBS, D, "DbRetrieve returning FALSE (key not present)");
X    ifdebug(DPP, D, ProfileOff("DbRetrieve"));
X    return FALSE;
X  }
X  sscanf(line, "%*s\t%s\t%ld\t%[^\n]", seq, dfpos, buff);
X  if( strcmp(buff, ".") == 0 )
X  { strcpy(buff, string(db));
X    strcpy(&buff[strlen(buff) - strlen(INDEX_SUFFIX)], DATA_SUFFIX);
X  }
X  *dfnum = FileNum(buff);
X  if( *dfnum == NO_FILE )  /* can only occur in cross reference database */
X    *dfnum = DefineFile(MakeWord(buff, &fpos(db)), DATABASE_FILE, SOURCE_PATH);
X  *cont = ftell(filep(db));
X  Child(y, Down(db));
X  debug2(DBS, D, "DbRetrieve returning TRUE (in %s at %ld)",
X    FileName(*dfnum), *dfpos);
X  ifdebug(DPP, D, ProfileOff("DbRetrieve"));
X  return TRUE;
X} /* end DbRetrieve */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN DbRetrieveNext(db, gall, sym, tag, seq, dfnum, dfpos, cont)      */
X/*                                                                           */
X/*  Retrieve the entry of database db pointed to by *cont.                   */
X/*  Set *gall, *sym, *tag, *seq, *dfnum, *dfpos to the entry's value.        */
X/*  Reset *cont to the next entry for passing to the next DbRetrieveNext.    */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN DbRetrieveNext(db, gall, sym, tag, seq, dfnum, dfpos, cont)
XOBJECT db;  BOOLEAN *gall;  OBJECT *sym;  unsigned char *tag, *seq;
XFILE_NUM *dfnum;  long *dfpos;  long *cont;
X{ unsigned char line[MAX_LINE], fname[MAX_LINE]; int symnum;
X  ifdebug(DPP, D, ProfileOn("DbRetrieveNext"));
X  debug2(DBS, D, "DbRetrieveNext( %s, %ld )", string(db), *cont);
X  if( !reading(db) )  Error(INTERN, &fpos(db), "DbRetrieveNext: writing!");
X  if( filep(db) == null )
X  { debug0(DBS, D, "DbRetrieveNext returning FALSE (empty database)");
X    ifdebug(DPP, D, ProfileOff("DbRetrieveNext"));
X    return FALSE;
X  }
X  fseek(filep(db), *cont == 0L ? left_pos(db) : *cont, 0);
X  if( fgets(line, MAX_LINE, filep(db)) == NULL )
X  { debug0(DBS, D, "DbRetrieveNext returning FALSE (no successor)");
X    ifdebug(DPP, D, ProfileOff("DbRetrieveNext"));
X    return FALSE;
X  }
X  *gall = (line[0] == '&' ? 1 : 0);
X  sscanf(&line[*gall], "%d&%s\t%s\t%ld\t%[^\n]", &symnum, tag, seq,dfpos,fname);
X  if( strcmp(fname, ".") == 0 )
X  { strcpy(fname, string(db));
X    strcpy(&fname[strlen(fname) - strlen(INDEX_SUFFIX)], DATA_SUFFIX);
X  }
X  *dfnum = FileNum(fname);
X  if( *dfnum == NO_FILE )  /* can only occur in cross reference database */
X    *dfnum = DefineFile(MakeWord(fname, &fpos(db)), DATABASE_FILE, SOURCE_PATH);
X  NumToSym(db, symnum, *sym);  *cont = ftell(filep(db));
X  debug2(DBS, D, "DbRetrieveNext returning TRUE (in %s at %ld)",
X    FileName(*dfnum), *dfpos);
X  ifdebug(DPP, D, ProfileOff("DbRetrieveNext"));
X  return TRUE;
X} /* end DbRetrieveNext */
END_OF_FILE
  if test 24078 -ne `wc -c <'lout/z33.c'`; then
    echo shar: \"'lout/z33.c'\" unpacked with wrong size!
  fi
  # end of 'lout/z33.c'
fi
echo shar: End of archive 10 \(of 30\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 30 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
