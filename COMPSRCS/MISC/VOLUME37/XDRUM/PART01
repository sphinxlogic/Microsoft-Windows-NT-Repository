Newsgroups: comp.sources.misc
From: durian@advtech.uswest.com (Mike Durian)
Subject: v37i048:  xdrum - create and edit drum patterns, Part01/02
Message-ID: <csm-v37i048=xdrum.123859@sparky.IMD.Sterling.COM>
X-Md4-Signature: 7849343278f93bd20863b159e7f3798e
Date: Tue, 11 May 1993 17:39:11 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: durian@advtech.uswest.com (Mike Durian)
Posting-number: Volume 37, Issue 48
Archive-name: xdrum/part01
Environment: X11, tcl, tk, tclm, BSD/386, Esix SysV, SunOS

Xdrum is a wishm script that allows you to create and edit drum
patterns under X11.  These patterns can then be saved as Standard
MIDI Files for use by other programs, or as ASCII files for text
editing and re-loading.  Xdrum is requires tcl, tk and tclm.

mike
---------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  xdrum-1.0 xdrum-1.0/Blurb xdrum-1.0/INSTALL
#   xdrum-1.0/Makefile xdrum-1.0/README xdrum-1.0/XDrum.ad
#   xdrum-1.0/drumgrid.3 xdrum-1.0/main.c xdrum-1.0/patchlevel.h
#   xdrum-1.0/tkm.h xdrum-1.0/wishm.tcl xdrum-1.0/wishmversion.3
#   xdrum-1.0/xdrum xdrum-1.0/xdrum.1
# Wrapped by durian@angeleys on Fri May  7 13:06:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'xdrum-1.0' ; then
    echo shar: Creating directory \"'xdrum-1.0'\"
    mkdir 'xdrum-1.0'
fi
if test -f 'xdrum-1.0/Blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/Blurb'\"
else
echo shar: Extracting \"'xdrum-1.0/Blurb'\" \(259 characters\)
sed "s/^X//" >'xdrum-1.0/Blurb' <<'END_OF_FILE'
X  Xdrum is a wishm script that allows you to create and edit drum
patterns under X11.  These patterns can then be saved as Standard
MIDI Files for use by other programs, or as ASCII files for text
editing and re-loading.
X  Xdrum is requires tcl, tk and tclm.
END_OF_FILE
if test 259 -ne `wc -c <'xdrum-1.0/Blurb'`; then
    echo shar: \"'xdrum-1.0/Blurb'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/Blurb'
fi
if test -f 'xdrum-1.0/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/INSTALL'\"
else
echo shar: Extracting \"'xdrum-1.0/INSTALL'\" \(1302 characters\)
sed "s/^X//" >'xdrum-1.0/INSTALL' <<'END_OF_FILE'
X  Installation for xdrum-1.0     May 5, 1993
X
X  1) Get tcl, tk and tclm.  Tk comes with tcl, so if you
get tk, you don't have to get tcl separately.  As of today,
the latest version of tk is tk3.2 and the latest version
of tcl is tcl6.7.  They are both available at sprite.berkeley.edu
in the tcl directory.
X     The latest release of tclm is tclm-1.0.  It can be found
at comp.sources.misc archive sites and harbor.ecn.purdue.edu.
Most likely it is available where you picked this up.
X
X  2) Build and install the aforementioned packages.  See
their documentation on how to do this.
X
X  3) Edit the Makefile.  Check out the stuff near the top
and change the paths as necessary.  If you change the install
directory, you'll also have to change the first line of
the xdrum script to point to the correct location of wishm.
X
X  4) make
X
X  5) make install
X
X  6) If you want to install you man pages, either
make install-man-cooked (the default) or make install-man-raw.
install-man-cooked formats the man pages and copies the
formatted document to the man dir.  install-man-raw installs
the unformatted document.
X     You probably want to use the cooked option, as the man pages
use the mdoc macros and not the older man macros.  I don't think
man(1) knows to process the files with mdoc.
X
X  7) You're done.
END_OF_FILE
if test 1302 -ne `wc -c <'xdrum-1.0/INSTALL'`; then
    echo shar: \"'xdrum-1.0/INSTALL'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/INSTALL'
fi
if test -f 'xdrum-1.0/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/Makefile'\"
else
echo shar: Extracting \"'xdrum-1.0/Makefile'\" \(3232 characters\)
sed "s/^X//" >'xdrum-1.0/Makefile' <<'END_OF_FILE'
X#
X# XINCDIR is the directory for the X11 include files.
X#
XXINCDIR = /usr/X11/include
X
X#
X# XLIBDIR is the directory for the X11 library files.
X#
XXLIBDIR = /usr/X11/lib
X
X#
X# XTRALIBS are any extra libraries your system might want
X# for instance a SVR4 system might want -lns -lnsl -lsocket
X#
X# XTRALIBS = -lns -lnsl -lsocket
XXTRALIBS =
X
X#
X# INSTALL is the install program
X#
X# INSTALL = cp
INSTALL = install
X
X#
X# INSTALLEXECFLAG are the flags used when installing executables
X#
X# INSTALLEXECFLAG =
INSTALLEXECFLAG = -c -m 755
X
X#
X# INSTALLTEXTFLAG are the flags used when installing text files
X#
X# INSTALLTEXTFLAG =
INSTALLTEXTFLAG = -c -m 644
X
X#
X# INSTALLMANFLAG are the flags used when installing the man pages
X#
X# INSTALLMANFLAG =
INSTALLMANFLAG = -c -m 444 -o bin -g bin
X
X#
X# INSTALLDIR is the directory where wishm and xdrum should go.
X# If you change this, be sure to change the 1st line of
X# xdrum script so the path to wishm is correct.
X#
INSTALLDIR = /usr/local/bin
X
X#
X# TKLIBDIR is the directory where the wishm.tcl startup
X# script should go.  wishm.tcl contains the default bindings
X# for the drumgrid widget
X#
TKLIBDIR = /usr/local/lib/tk
X
X#
X# LIBDIR is the directory where libraries like libtcl.a, libtk.a,
X# and libtclm.a can be found.
X#
LIBDIR = /usr/local/lib
X
X#
X# INCDIR is the directory where include files like tk.h, tclm.h
X# mutil.h can be found
X#
INCDIR = /usr/local/include
X
X#
X# If you don't have or don't need ranlib, set this to true
X#
X# RANLIB = true
RANLIB = ranlib
X
X#
X# NROFF is the command to format the man pages
X#
NROFF = groff -mdoc -Tascii
X
X#
X# MANDIR is the directory when the man pages go
X#
MANDIR = /usr/local/man
X
X#
X# MANSUB is the subdirectory for man pages
X#
X# MANSUB = man
MANSUB = cat
X
X#
X# MANEXT1 is the extension for man section 1 pages
X#
MANEXT1 = 1
X
X#
X# MANEXT3 is the extension for man section 3 pages
X#
MANEXT3 = 3
X
TKMSRCS = tkmGrid.c
TKMOBJS = tkmGrid.o
TKMLIB = libtkm.a
X
WISHMSRCS = main.c
WISHMOBJS = main.o
WISHMEXEC = wishm
X
SCRIPTS = xdrum
X
MAN1 = xdrum.1
MAN3 = drumgrid.3 wishmversion.3
X
MAN10 = xdrum.0
MAN30 = drumgrid.0 wishmversion.0
X
LIBPATH = -L. -L$(LIBDIR) -L$(XLIBDIR)
LIBS = -ltkm -ltclm -lmutil -ltk -ltcl -lX11 -lm $(XTRALIBS)
LFLAGS = $(LIBPATH) $(LIBS)
X
CFLAGS = -O -I$(INCDIR) -I$(XINCDIR)
X
CC = cc
X
X.SUFFIXES: $(.SUFFIXES) .0 .1 .3
X
X$(WISHMEXEC): $(WISHMOBJS) $(TKMLIB)
X	$(CC) -o $(WISHMEXEC) $(WISHMOBJS) $(LFLAGS)
X
X$(TKMLIB): $(TKMOBJS)
X	ar cr $(TKMLIB) $(TKMOBJS)
X	$(RANLIB) $(TKMLIB)
X
install: $(WISHMEXEC)
X	$(INSTALL) $(INSTALLEXECFLAG) $(WISHMEXEC) $(SCRIPTS) $(INSTALLDIR)
X	$(INSTALL) $(INSTALLTEXTFLAG) wishm.tcl $(TKLIBDIR)
X	$(INSTALL) $(INSTALLTEXTFLAG) $(TKMLIB) $(LIBDIR)
X	$(RANLIB) $(LIBDIR)/$(TKMLIB)
X	$(INSTALL) $(INSTALLTEXTFLAG) tkm.h $(INCDIR)
X
X
install-man-cooked: $(MAN10) $(MAN30)
X	$(INSTALL) $(INSTALLMANFLAG) $(MAN10) $(MANDIR)/$(MANSUB)$(MANEXT1)
X	$(INSTALL) $(INSTALLMANFLAG) $(MAN30) $(MANDIR)/$(MANSUB)$(MANEXT3)
X
install-man-raw:
X	$(INSTALL) $(INSTALLMANFLAG) $(MAN1) $(MANDIR)/$(MANSUB)$(MANEXT1)
X	$(INSTALL) $(INSTALLMANFLAG) $(MAN3) $(MANDIR)/$(MANSUB)$(MANEXT3)
X
X.1.0:
X	$(NROFF) $< > $@
X
X.3.0:
X	$(NROFF) $< > $@
X
clean:
X	rm -f $(WISHMOBJS) $(TKMOBJS) $(TKMLIB) $(WISHMEXEC) errlist core* \
X	    $(MAN10) $(MAN30)
X
tkmGrid.o: tkm.h
END_OF_FILE
if test 3232 -ne `wc -c <'xdrum-1.0/Makefile'`; then
    echo shar: \"'xdrum-1.0/Makefile'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/Makefile'
fi
if test -f 'xdrum-1.0/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/README'\"
else
echo shar: Extracting \"'xdrum-1.0/README'\" \(1148 characters\)
sed "s/^X//" >'xdrum-1.0/README' <<'END_OF_FILE'
X  This is release 1.0 of xdrum.
X
X  xdrum is wishm based script that allows you to create and
edit drum patterns under X11.  These patterns can then be saved
in a re-loadable and editable ASCII format or in a non-loadable
MIDI format.  Though the MIDI format can't be re-loaded,
it conforms to the Standard MIDI Format and can be used with
other tools such as the tclm scripts mplay and minfo.
X  Wishm is John Ousterhout's wish interpreter with tclm
extensions.  Wish in turn is based on his interpreted
language tcl.  Tcl is a simple and easy to use scripting
language designed for applications such as this.
X  The tclm extensions are extensions to tcl that allow one
to easily read/write and modify MIDI files.
X  To use xdrum, you must have tcl, tk and tclm.  Tcl and
tk are available at sprite.berkeley.edu.  Tclm is probably
available where you found xdrum.  If not check comp.sources.misc
archive sites and harbor.ecn.purdue.edu.
X
X  See the INSTALL file for information on how to build and
install xdrum.
X
X  Special thanks go to Michael Caro (acps7221@ryevm.ryerson.ca)
for invaluable input and feedback.
X
mike durian
durian@advtech.uswest.com
END_OF_FILE
if test 1148 -ne `wc -c <'xdrum-1.0/README'`; then
    echo shar: \"'xdrum-1.0/README'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/README'
fi
if test -f 'xdrum-1.0/XDrum.ad' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/XDrum.ad'\"
else
echo shar: Extracting \"'xdrum-1.0/XDrum.ad'\" \(175 characters\)
sed "s/^X//" >'xdrum-1.0/XDrum.ad' <<'END_OF_FILE'
xdrum*Labels:	Kick Snare {High Hat Open} {High Hat Closed} Ride Crash
xdrum*Pitches:	35 38 46 42 51 49
xdrum*Levels:	8
xdrum*Beats:	4
xdrum*Measures:	2
xdrum*Quantization:	16
END_OF_FILE
if test 175 -ne `wc -c <'xdrum-1.0/XDrum.ad'`; then
    echo shar: \"'xdrum-1.0/XDrum.ad'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/XDrum.ad'
fi
if test -f 'xdrum-1.0/drumgrid.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/drumgrid.3'\"
else
echo shar: Extracting \"'xdrum-1.0/drumgrid.3'\" \(8434 characters\)
sed "s/^X//" >'xdrum-1.0/drumgrid.3' <<'END_OF_FILE'
X.Dd March 30, 1993
X.Os WISHM
X.Dt DRUMGRID 3
X.Sh NAME
X.Nm drumgrid
X.Nd "a wishm widget to display and edit drum patterns"
X.Sh SYNOPSIS
X.Nm
X.Ar pathName
X.Op Ar options
X.Ss STANDARD OPTIONS
X.Bl -item -compact
X.It
X.Fl background Ar color
X.It
X.Fl borderwidth Ar width
X.It
X.Fl cursor Ar cursor
X.It
X.Fl font Ar font
X.It
X.Fl foreground Ar color
X.It
X.Fl relief Ar relief
X.It
X.Fl xscrollcommand Ar command
X.It
X.Fl yscrollcommand Ar command
X.El
X.Ss WIDGET SPECIFIC OPTIONS
X.Bl -tag -width Fl
X.It Fl beatcolor Ar color
This option specifies the color of the lines dividing
beats.
If not specified the color blue is used.
It's class in BeatColor.
X.It Fl beats Ar beats
This option specifies how many beats are in a measure.
If not specified the value 4 is used.
It's class is Beats.
X.It Fl boxheight Ar height
This option specifies the height of the boxes.
If not specified the value 20 is used.
It's class is BoxHeight.
X.It Fl boxwidth Ar width
This option specifies the width of the boxes.
If not specified the value 20 is used.
It's class is BoxWidth.
X.It Fl height Ar height
This option specifies how many rows should be displayed.
The remainder can be viewed by scrolling.
If not specified the number of labels is used.
It's class is Height.
X.It Fl labels Ar labelList
This option specifies the labels for each row.
It is a list and each element in the list corresponds
to one row.
If not specified the list {Kick Snare {High Hat Open} {High Hat Closed}
Crash Ride {High Tom} {Middle Tom} {Low Tom}} is assumed.
It's class is Labels.
X.It Fl levels Ar levels
This option specifies how many different dynamic
levels exist.
If not specified the value 8 is assumed.
It's class is Levels.
X.It Fl linecolor Ar color
This option specifies the colors of lines that
are neither dividing beats nor dividing measures.
If not specified the value bisque3 is assumed.
It's class is LineColor.
X.It Fl linethickness Ar thickness
This option specifies the thickness of the lines.
If not specified the value 2 is assumed.
It's class is LineThickness.
X.It Fl measurecolor Ar color
This option specifies the color to use when
drawing lines that divide measures.
If not specified the color red is assumed.
It's class is MeasureColor.
X.It Fl measures Ar measures
This option specifies how many measures are
in the pattern.
If not specified a value of 2 is assumed.
It's class is Measures.
X.It Fl padx Ar pad
This option specifies how many pixels to insert
in front of the labels.
If not specified a value of 2 is assumed.
It's class if PadX.
X.It Fl pitches Ar pitchList
This option specifies the pitches associated with
each row.
It is a list and each element corresponds to one
row.
If not specified a pitchlist of {35 38 56 42 49 51 48 45 41}
is assumed.
This corresponds to pitches on an Alesis HR-16 appropriate
for the default labels.
It's class is Pitches.
X.It Fl quantization Ar quantization
This option specifies the quantization of the grid.
It should be a multiple of 4 and corresponds to
the number of boxes per measure.
If not specified a quantization of 16 is assumed.
It's class is Quantization.
X.It Fl width Ar width
This option specifies the number of boxes to display.
The remainder can be viewed by scrolling.
If a value is not specified, one measure's worth of
boxes will be displayed.
It's class is Width.
X.El
X.Sh DESCRIPTION
X.Nm
is a
X.Tn TCL/TK
compatible widget designed for use as an aid in
creating and editing drum rhythms, though it could be
used for other purposes as well.
These rhythms are represented in a grid with each row
corresponding to one voice of the drum kit and each column
a time period when a voice can be struck.
The time is shown as increasing on the x-axis.
The columns are grouped by beats and measures.
There are
X.Ar quantization
divided by 4 columns per beat,
X.Ar beats
beats per measure, and
X.Ar measures
measures per pattern.
Varying dynamics are represented by different
shadings in each box.
There are
X.Ar levels
distinct levels of dynamics available.
X.Pp
The default bindings for
X.Nm
are loaded automatically by
X.Xr wishm 1
when it is started.
Pressing mouse button 1 in a box will
increase the velocity of the box by 1.
Pressing mouse button 3 decrease the
velocity by 1, and pressing mouse button 2 sets
the velocity to zero.
The velocity of a box can be set directly to a
specific value by first moving the mouse to the
box and then pressing a key in the range 0 - 9,
where the key value is the desired velocity.
The '+' key can be used to increment the velocity
of a box by 10 and the '-' decrements the velocity
by 10.
Thus, you can set the value to velocities greater
than 9.
If you specify a velocity greater than the maximum
level, the maximum level will be used.
X.Sh WIDGET COMMAND
The
X.Nm
command creates a new Tcl command whose
name is
X.Ar pathName.
This command may be used to invoke various
operations on the widget.
It has the following general form:
X.Dl Nm pathName Ar option Op Ar "arg arg ..."
The following options are possible for the
X.Nm
widgets:
X.Bl -tag -width configure
X.It Nm configure Oo option
X.Op value
X.Oc
The configure command allows you to change to configuration
parameters of the widget.
These parameters are listed in the
X.Tn STANDARD OPTIONS
and
X.Tn WIDGET SPECIFIC OPTIONS
sections.
If no option and value are specified, then this
command returns all of the options and their settings.
If an option is specified without a value, then
the setting for that option only is returned.
If both an option and a value are specified, then
that parameter will be set to the given value.
The grid will be cleared whenever a configure parameter
is changed.
This is due to difficulties in placing existing patterns
into new beat/measure/quantization combinations.
X.It Nm down Ar x y
This command will change the relief the the box specified
by the x and y coordinates to sunken.
X.It Nm label add Ar label
This command adds another row to the grid.
The row will initially be empty and the label will be
X.Em label.
X.It Nm label remove Ar {label | index} value
This command will remove a row from the grid.
This row can be specified by either its label or
its index.
X.It Nm label list
This command returns a list of all the current labels.
X.It Nm pitch get Ar index
This command returns the pitch value associated with
a row.
The row is specified in by the index value.
X.It Nm pitch set Ar index value
This command set the pitch associated with a row.
The row is specified by the index parameter and the new
pitch by the value parameter.
X.It Nm pitch list
This command returns a list of all the current pitch values.
This first element is for row 0, the second for row 1, etc.
X.It Nm up Ar x y
This command changes the relief of the box specified
by the x and y coordinates to raised.
X.It Nm volume get Ar {all | x y}
This command returns the volume setting for either one box
or the entire grid.
If the string all is the argument instead of a x and y positions,
then a list will be returned.
The list will have sublists for each column.
XEach sublist will contain the volume settings for each row
in that time slice.
If x and y positions are specified in stead of the string all,
then the volume setting for that one box is returned.
X.It Nm volume set Ar x y value
This command sets the volume at a given x and y coordinate to
the value specified.
X.It Nm xview Op index
This command adjusts the display so that the column specified by
index is in the far left position unless there will not be
enough boxes to the right of index to span the display area.
In this case the last box will be placed in the far right
position and the preceding boxes filled to the left.
If an index is not specified then the current index of the
left most box in the display is returned.
X.It Nm yview Op index
This command adjusts the display so that the row specified by
index is in the top position unless there will not be enough
rows below index to fill the display area.
In this case the last row will be placed in the bottom positions
and preceding rows placed above it.
If an index is not specified then the current index of the
top label in the display is returned.
X.El
X.Sh RETURN VALUES
The
X.Nm
command returns the specified
X.Ar pathName .
X.Sh SEE ALSO
X.Xr tclm 1 ,
X.Xr wish 1
X.Sh AUTHORS
X.Tn TCL
and
X.Tn TK
X.D1 John Ousterhout - ouster@cs.berkeley.edu
X.Tn TCLM
and
X.Tn XDRUM
X.D1 Mike Durian - durian@advtech.uswest.com
X.Sh BUGS
Just because I don't currently know of any doesn't mean they
aren't there.
END_OF_FILE
if test 8434 -ne `wc -c <'xdrum-1.0/drumgrid.3'`; then
    echo shar: \"'xdrum-1.0/drumgrid.3'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/drumgrid.3'
fi
if test -f 'xdrum-1.0/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/main.c'\"
else
echo shar: Extracting \"'xdrum-1.0/main.c'\" \(8848 characters\)
sed "s/^X//" >'xdrum-1.0/main.c' <<'END_OF_FILE'
X/*-
X * main.c --
X *
X *	A simple program to test the toolkit facilities.
X *
X * Copyright 1990-1992 Regents of the University of California.
X * Permission to use, copy, modify, and distribute this
X * software and its documentation for any purpose and without
X * fee is hereby granted, provided that the above copyright
X * notice appear in all copies.  The University of California
X * makes no representations about the suitability of this
X * software for any purpose.  It is provided "as is" without
X * express or implied warranty.
X */
X/*-
X * Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X */
X/*-
X * I made it conform to BSD's KNF (Kernel Normal Form) - or at
X * least mostly.  Also changed a few minor things and extended
X * it to work with TCLM and TKM.
X * Mike
X */
X
X#ifndef lint
static char rcsid[] = "main.c,v 1.8 1993/05/07 17:51:17 durian Exp";
X#endif
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <unistd.h>
X#include <string.h>
X#include "tk.h"
X#include "tkm.h"
X#include "mutil.h"
X#include "tclm.h"
X#include "patchlevel.h"
X
X/*
X * Declarations for library procedures:
X */
X
extern int isatty();
X
X/*
X * Command used to initialize wish:
X */
X
char initCmd[] = "source $tk_library/wish.tcl";
char initTkmCmd[] = "source $tk_library/wishm.tcl";
X
Tk_Window w;			/* NULL means window has been deleted. */
Tk_TimerToken timeToken = 0;
Tcl_CmdBuf buffer;
Tcl_Interp *interp;
int idleHandler = 0;
int x, y;
int tty;
int Tk_SquareCmd _ANSI_ARGS_((ClientData clientData, Tcl_Interp *interp,
X    int argc, char **argv));
int Tk_WishmVersionCmd _ANSI_ARGS_((ClientData clientData, Tcl_Interp *interp,
X    int argc, char **argv));
X
X/*
X * Information for testing out command-line options:
X */
X
int synchronize = 0;
char *fileName = NULL;
char *name = NULL;
char *display = NULL;
char *geometry = NULL;
X
Tk_ArgvInfo argTable[] = {
X	{"-file", TK_ARGV_STRING, (char *)NULL, (char *)&fileName,
X	    "File from which to read commands"},
X	{"-geometry", TK_ARGV_STRING, (char *)NULL, (char *)&geometry,
X	    "Initial geometry for window"},
X	{"-display", TK_ARGV_STRING, (char *)NULL, (char *)&display,
X	    "Display to use"},
X	{"-name", TK_ARGV_STRING, (char *)NULL, (char *)&name,
X	    "Name to use for application"},
X	{"-sync", TK_ARGV_CONSTANT, (char *)1, (char *)&synchronize,
X	    "Use synchronous mode for display server"},
X	{(char *)NULL, TK_ARGV_END, (char *)NULL, (char *)NULL,
X	    (char *)NULL}
X};
X
X/* ARGSUSED */
void
StdinProc(clientData, mask)
X	ClientData clientData;		/* Not used. */
X	int mask;
X{
X	char line[200];
X	static int gotPartial = 0;
X	char *cmd;
X	int result;
X
X	if (mask & TK_READABLE) {
X		if (fgets(line, 200, stdin) == NULL) {
X			if (gotPartial)
X				line[0] = 0;
X			else {
X				if (!tty)
X					Tk_DeleteFileHandler(0);
X				else {
X					Tcl_Eval(interp, "destroy .", 0,
X					    (char **)NULL);
X					exit(0);
X				}
X				return;
X			}
X		}
X		cmd = Tcl_AssembleCmd(buffer, line);
X		if (cmd == NULL) {
X			gotPartial = 1;
X			return;
X		}
X		gotPartial = 0;
X		result = Tcl_RecordAndEval(interp, cmd, 0);
X		if (*interp->result != 0)
X			if ((result != TCL_OK) || (tty))
X				printf("%s\n", interp->result);
X		if (tty) {
X			printf("wishm: ");
X			fflush(stdout);
X		}
X	}
X}
X
X/* ARGSUSED */
static void
StructureProc(clientData, eventPtr)
X	ClientData clientData;	/* Information about window. */
X	XEvent *eventPtr;	/* Information about event. */
X{
X	if (eventPtr->type == DestroyNotify)
X		w = NULL;
X}
X
X/*
X * Procedure to map initial window.  This is invoked as a do-when-idle
X * handler.  Wait for all other when-idle handlers to be processed
X * before mapping the window, so that the window's correct geometry
X * has been determined.
X */
X
X/* ARGSUSED */
static void
DelayedMap(clientData)
X	ClientData clientData;	/* Not used. */
X{
X
X	/* Empty loop body. */
X	while (Tk_DoOneEvent(TK_IDLE_EVENTS) != 0);
X	if (w == NULL)
X		return;
X	Tk_MapWindow(w);
X}
X
X/* ARGSUSED */
int
DotCmd(dummy, interp, argc, argv)
X	ClientData dummy;	/* Not used. */
X	Tcl_Interp *interp;	/* Current interpreter. */
X	int argc;		/* Number of arguments. */
X	char **argv;		/* Argument strings. */
X{
X	int x, y;
X
X	if (argc != 3) {
X		Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
X		    " x y\"", (char *)NULL);
X		return (TCL_ERROR);
X	}
X	x = strtol(argv[1], (char **)NULL, 0);
X	y = strtol(argv[2], (char **)NULL, 0);
X	Tk_MakeWindowExist(w);
X	XDrawPoint(Tk_Display(w), Tk_WindowId(w),
X	    DefaultGCOfScreen(Tk_Screen(w)), x, y);
X	return (TCL_OK);
X}
X
X/* ARGSUSED */
int
MovetoCmd(dummy, interp, argc, argv)
X	ClientData dummy;	/* Not used. */
X	Tcl_Interp *interp;	/* Current interpreter. */
X	int argc;		/* Number of arguments. */
X	char **argv;		/* Argument strings. */
X{
X	if (argc != 3) {
X		Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
X		    " x y\"", (char *)NULL);
X		return (TCL_ERROR);
X	}
X	x = strtol(argv[1], (char **)NULL, 0);
X	y = strtol(argv[2], (char **)NULL, 0);
X	return (TCL_OK);
X}
X
X/* ARGSUSED */
int
LinetoCmd(dummy, interp, argc, argv)
X	ClientData dummy;	/* Not used. */
X	Tcl_Interp *interp;	/* Current interpreter. */
X	int argc;		/* Number of arguments. */
X	char **argv;		/* Argument strings. */
X{
X	int newX, newY;
X
X	if (argc != 3) {
X		Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
X		    " x y\"", (char *)NULL);
X		return (TCL_ERROR);
X	}
X	newX = strtol(argv[1], (char **)NULL, 0);
X	newY = strtol(argv[2], (char **)NULL, 0);
X	Tk_MakeWindowExist(w);
X	XDrawLine(Tk_Display(w), Tk_WindowId(w),
X	    DefaultGCOfScreen(Tk_Screen(w)), x, y, newX, newY);
X	x = newX;
X	y = newY;
X	return (TCL_OK);
X}
X
int
main(argc, argv)
X	int argc;
X	char **argv;
X{
X	char *args, *p, *msg;
X	char buf[20];
X	int result;
X	Tk_3DBorder border;
X
X	interp = Tcl_CreateInterp();
X#ifdef TCL_MEM_DEBUG
X	Tcl_InitMemory(interp);
X#endif
X	if (Tk_ParseArgv(interp, (Tk_Window)NULL, &argc, argv, argTable, 0)
X	    != TCL_OK) {
X		fprintf(stderr, "%s\n", interp->result);
X		exit(1);
X	}
X	if (name == NULL) {
X		if (fileName != NULL)
X			p = fileName;
X		else
X			p = argv[0];
X		name = strrchr(p, '/');
X		if (name != NULL)
X			name++;
X		else
X			name = p;
X	}
X	w = Tk_CreateMainWindow(interp, display, name);
X	if (w == NULL) {
X		fprintf(stderr, "%s\n", interp->result);
X		exit(1);
X	}
X	Tk_SetClass(w, "Tk");
X	Tk_CreateEventHandler(w, StructureNotifyMask, StructureProc,
X	    (ClientData)NULL);
X	Tk_DoWhenIdle(DelayedMap, (ClientData)NULL);
X	tty = isatty(0);
X
X	args = Tcl_Merge(argc-1, argv+1);
X	Tcl_SetVar(interp, "argv", args, TCL_GLOBAL_ONLY);
X	ckfree(args);
X	sprintf(buf, "%d", argc-1);
X	Tcl_SetVar(interp, "argc", buf, TCL_GLOBAL_ONLY);
X
X	if (synchronize)
X		XSynchronize(Tk_Display(w), True);
X	Tk_GeometryRequest(w, 200, 200);
X	border = Tk_Get3DBorder(interp, w, None, "#4eee94");
X	if (border != NULL)
X		Tk_SetBackgroundFromBorder(w, border);
X	else {
X		Tcl_SetResult(interp, (char *)NULL, TCL_STATIC);
X		Tk_SetWindowBackground(w, WhitePixelOfScreen(Tk_Screen(w)));
X    	}
X	XSetForeground(Tk_Display(w), DefaultGCOfScreen(Tk_Screen(w)),
X	    BlackPixelOfScreen(Tk_Screen(w)));
X	Tcl_CreateCommand(interp, "dot", DotCmd, (ClientData)w,
X	    (void (*)())NULL);
X	Tcl_CreateCommand(interp, "lineto", LinetoCmd, (ClientData)w,
X	    (void (*)())NULL);
X	Tcl_CreateCommand(interp, "moveto", MovetoCmd, (ClientData)w,
X	    (void (*)())NULL);
X#ifdef SQUARE_DEMO
X	Tcl_CreateCommand(interp, "square", Tk_SquareCmd, (ClientData)w,
X	    (void (*)())NULL);
X#endif
X	Tcl_CreateCommand(interp, "drumgrid", Tk_DrumGridCmd, (ClientData)w,
X	    (void(*)())NULL);
X	Tcl_CreateCommand(interp, "wishmversion", Tk_WishmVersionCmd,
X	    (ClientData)w, (void(*)())NULL);
X
X	/* the MIDI stuff */
X	Tclm_InitMidi(interp);
X
X	if (geometry != NULL)
X		Tcl_SetVar(interp, "geometry", geometry, TCL_GLOBAL_ONLY);
X	result = Tcl_Eval(interp, initCmd, 0, (char **)NULL);
X	if (result != TCL_OK)
X		goto error;
X	result = Tcl_Eval(interp, initTkmCmd, 0, (char **)NULL);
X	if (result != TCL_OK)
X		goto error;
X	if (fileName != NULL) {
X		result = Tcl_VarEval(interp, "source ", fileName,
X		    (char *)NULL);
X		if (result != TCL_OK)
X			goto error;
X		tty = 0;
X	} else {
X		tty = isatty(0);
X		Tk_CreateFileHandler(0, TK_READABLE, StdinProc, (ClientData)0);
X		if (tty)
X			printf("wishm: ");
X	}
X	fflush(stdout);
X	buffer = Tcl_CreateCmdBuf();
X	(void)Tcl_Eval(interp, "update", 0, (char **)NULL);
X
X	Tk_MainLoop();
X	Tcl_DeleteInterp(interp);
X	Tcl_DeleteCmdBuf(buffer);
X	exit(0);
X
error:
X	msg = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
X	if (msg == NULL)
X		msg = interp->result;
X	fprintf(stderr, "%s\n", msg);
X	Tcl_Eval(interp, "destroy .", 0, (char **)NULL);
X	exit(1);
X	return (0);
X}
X
int
Tk_WishmVersionCmd(clientData, interp, argc, argv)
X	ClientData clientData;
X	Tcl_Interp *interp;
X	int argc;
X	char **argv;
X{
X
X	if (argc != 1) {
X		Tcl_AppendResult(interp, "wrong # args: should be \"",
X		    argv[0], "\"", (char *)NULL);
X		return (TCL_ERROR);
X	}
X	Tcl_AppendResult(interp, WISHM_PATCHLEVEL, (char *)NULL);
X	return (TCL_OK);
X}
END_OF_FILE
if test 8848 -ne `wc -c <'xdrum-1.0/main.c'`; then
    echo shar: \"'xdrum-1.0/main.c'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/main.c'
fi
if test -f 'xdrum-1.0/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/patchlevel.h'\"
else
echo shar: Extracting \"'xdrum-1.0/patchlevel.h'\" \(144 characters\)
sed "s/^X//" >'xdrum-1.0/patchlevel.h' <<'END_OF_FILE'
X/*
X * patchlevel.h,v 1.1 1993/05/06 02:49:44 durian Exp
X */
X
X#ifndef PATCHLEVEL_H
X#define PATCHLEVEL_H
X
X#define WISHM_PATCHLEVEL "0.9.5"
X#endif
END_OF_FILE
if test 144 -ne `wc -c <'xdrum-1.0/patchlevel.h'`; then
    echo shar: \"'xdrum-1.0/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/patchlevel.h'
fi
if test -f 'xdrum-1.0/tkm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/tkm.h'\"
else
echo shar: Extracting \"'xdrum-1.0/tkm.h'\" \(3039 characters\)
sed "s/^X//" >'xdrum-1.0/tkm.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by Michael B. Durian.
X * 4. The name of the the Author may be used to endorse or promote 
X *    products derived from this software without specific prior written 
X *    permission.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X/*
X * tkm.h,v 1.2 1993/04/04 22:02:27 durian Exp
X */
X#ifndef TKM_H
X#define TKM_H
extern int Tk_DrumGridCmd _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
X
X#define BLACK		"Black"
X#define WHITE		"White"
X#define GRAY		"#b0b0b0"
X
X#define BISQUE1		"#ffe4c4"
X#define BISQUE2		"#eed5b7"
X#define BISQUE3		"#cdb79e"
X
X#define LIGHTBLUE2	"#b2dfee"
X
X#define LIGHTPINK1	"#ffaeb9"
X
X#define MAROON		"#b03060"
X
X#define DEF_GRID_FG_COLOR		BLACK
X#define DEF_GRID_FG_MONO		WHITE
X#define DEF_GRID_NORMAL_BG_COLOR	BISQUE1
X#define DEF_GRID_NORMAL_BG_MONO		BLACK
X#define DEF_GRID_LINE_COLOR		BISQUE3
X#define DEF_GRID_MEASURE_COLOR		"red"
X#define DEF_GRID_BEAT_COLOR		"blue"
X#define DEF_GRID_BORDER_WIDTH		"2"
X#define DEF_GRID_CURSOR			((char *)NULL)
X#define DEF_GRID_FONT			"*-Helvetica-Bold-R-Normal-*-120-*"
X#define DEF_GRID_HEIGHT			"0"
X#define DEF_GRID_WIDTH			"0"
X#define DEF_GRID_RELIEF			"flat"
X#define DEF_GRID_LABELS			"Kick Snare {High Hat Open} {High Hat \
Closed} Crash Ride {High Tom} {Middle Tom} {Low Tom}"
X#define DEF_GRID_PITCHES		"35 38 46 42 49 51 48 45 41"
X#define DEF_GRID_LEVELS			"8"
X#define DEF_GRID_BEATS			"4"
X#define DEF_GRID_MEASURES		"2"
X#define DEF_GRID_QUANTIZATION		"16"
X#define DEF_GRID_LINETHICKNESS		"2"
X#define DEF_GRID_PADX			"2"
X#define DEF_GRID_BOXWIDTH		"20"
X#define DEF_GRID_BOXHEIGHT		"20"
X#define DEF_GRID_SCROLL_COMMAND		((char *)NULL)
X
X#endif
END_OF_FILE
if test 3039 -ne `wc -c <'xdrum-1.0/tkm.h'`; then
    echo shar: \"'xdrum-1.0/tkm.h'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/tkm.h'
fi
if test -f 'xdrum-1.0/wishm.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/wishm.tcl'\"
else
echo shar: Extracting \"'xdrum-1.0/wishm.tcl'\" \(4630 characters\)
sed "s/^X//" >'xdrum-1.0/wishm.tcl' <<'END_OF_FILE'
X# Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X#
X# Redistribution and use in source and binary forms, with or without
X# modification, are permitted provided that the following conditions
X# are met:
X# 1. Redistributions of source code must retain the above copyright
X#    notice, this list of conditions and the following disclaimer.
X# 2. Redistributions in binary form must reproduce the above copyright
X#    notice, this list of conditions and the following disclaimer in the
X#    documentation and/or other materials provided with the distribution.
X# 3. All advertising materials mentioning features or use of this software
X#    must display the following acknowledgement:
X#	This product includes software developed by Michael B. Durian.
X# 4. The name of the the Author may be used to endorse or promote 
X#    products derived from this software without specific prior written 
X#    permission.
X#
X# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X# SUCH DAMAGE.
X
X# wishm.tcl,v 1.3 1993/04/05 21:35:12 durian Exp
X
X# default bindings for drumgrid widget
X# briefly:
X# mouse 1 - incrs. level
X# mouse 3 - decrs. level
X# mouse 2 - clears
X# keys 0-9 set level to value
X# key + incrs. level by 10
X# key - decrs. level by 10
X#
X# also handles moving in and out of boxes, in and out of grid, changing
X# relief etc.
X
set DrumGridSomethingPressed 0
X
proc DrumGridPress {W x y} {
X	global DrumGridLastX
X	global DrumGridLastY
X	global DrumGridSomethingPressed
X
X	incr DrumGridSomethingPressed
X	set DrumGridLastX [$W xnearest $x]
X	set DrumGridLastY [$W ynearest $y]
X	if {$DrumGridLastX != -1 && $DrumGridLastY != -1} {
X		$W down $DrumGridLastX $DrumGridLastY
X	}
X}
X
proc DrumGridMotion {W x y} {
X	global DrumGridLastX
X	global DrumGridLastY
X
X	set DrumGridNewX [$W xnearest $x]
X	set DrumGridNewY [$W ynearest $y]
X	if {$DrumGridNewX != $DrumGridLastX || \
X	    $DrumGridNewY != $DrumGridLastY} {
X		if {$DrumGridLastX != -1 && $DrumGridLastY != -1} {
X			$W up $DrumGridLastX $DrumGridLastY
X		}
X		if {$DrumGridNewX != -1 && $DrumGridNewY != -1} {
X			$W down $DrumGridNewX $DrumGridNewY
X		}
X		set DrumGridLastX $DrumGridNewX
X		set DrumGridLastY $DrumGridNewY
X	}
X}
X
bind DrumGrid <ButtonPress> {
X
X	DrumGridPress %W %x %y
X}
X
bind DrumGrid <Any-Motion> {
X	global DrumGridSomethingPressed
X
X	if {$DrumGridSomethingPressed} {
X		DrumGridMotion %W %x %y
X	}
X}
X
bind DrumGrid <ButtonRelease-1> {
X	global DrumGridLastX
X	global DrumGridLastY
X	global DrumGridSomethingPressed
X
X	if {$DrumGridLastX != -1 && $DrumGridLastY != -1} {
X		%W volume set $DrumGridLastX $DrumGridLastY \
X		    [expr {[%W volume get $DrumGridLastX $DrumGridLastY] + 1}]
X	}
X	incr DrumGridSomethingPressed -1
X}
X
bind DrumGrid <ButtonRelease-2> {
X	global DrumGridLastX
X	global DrumGridLastY
X	global DrumGridSomethingPressed
X
X	if {$DrumGridLastX != -1 && $DrumGridLastY != -1} {
X		%W volume set $DrumGridLastX $DrumGridLastY 0
X	}
X	incr DrumGridSomethingPressed -1
X}
X
bind DrumGrid <ButtonRelease-3> {
X	global DrumGridLastX
X	global DrumGridLastY
X	global DrumGridSomethingPressed
X
X	if {$DrumGridLastX != -1 && $DrumGridLastY != -1} {
X		%W volume set $DrumGridLastX $DrumGridLastY \
X		    [expr {[%W volume get $DrumGridLastX $DrumGridLastY] - 1}]
X	}
X	incr DrumGridSomethingPressed -1
X}
X
bind DrumGrid <Enter> {
X
X	focus %W
X}
X
bind DrumGrid <Leave> {
X
X	focus none
X}
X
bind DrumGrid <Any-KeyPress> {
X
X	case %A in {
X	{1 2 3 4 5 6 7 8 9 0 + -} {
X		DrumGridPress %W %x %y
X	}
X	}
X}
X
bind DrumGrid <Any-KeyRelease> {
X	global DrumGridLastX
X	global DrumGridLastY
X	global DrumGridSomethingPressed
X
X	case %A in {
X	{1 2 3 4 5 6 7 8 9 0} {
X		%W volume set $DrumGridLastX $DrumGridLastY %A
X		incr DrumGridSomethingPressed -1
X	}
X	{+} {
X		%W volume set $DrumGridLastX $DrumGridLastY \
X		    [expr {[%W volume get $DrumGridLastX $DrumGridLastY] + 10}]
X		incr DrumGridSomethingPressed -1
X	}
X	{-} {
X		%W volume set $DrumGridLastX $DrumGridLastY \
X		    [expr {[%W volume get $DrumGridLastX $DrumGridLastY] - 10}]
X		incr DrumGridSomethingPressed -1
X	}
X	}
X}
END_OF_FILE
if test 4630 -ne `wc -c <'xdrum-1.0/wishm.tcl'`; then
    echo shar: \"'xdrum-1.0/wishm.tcl'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/wishm.tcl'
fi
if test -f 'xdrum-1.0/wishmversion.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/wishmversion.3'\"
else
echo shar: Extracting \"'xdrum-1.0/wishmversion.3'\" \(369 characters\)
sed "s/^X//" >'xdrum-1.0/wishmversion.3' <<'END_OF_FILE'
X.Dt WISHMVERSION 3
X.Os WISHM
X.Dd May 5, 1993
X.Sh NAME
X.Nm wishmversion
X.Nd "wishm command that returns the version of wishm being used"
X.Sh SYNOPSIS
X.Nm
X.Sh DESCRIPTION
X.Nm
is a simple command that returns
the version of
X.Xr wishm 1
being used.
X.Sh RETURN VALUES
The version of
X.Xr wishm 1 .
X.Sh SEE ALSO
X.Xr wishm 1
X.Sh AUTHORS
Mike Durian - durian@advtech.uswest.com
END_OF_FILE
if test 369 -ne `wc -c <'xdrum-1.0/wishmversion.3'`; then
    echo shar: \"'xdrum-1.0/wishmversion.3'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/wishmversion.3'
fi
if test -f 'xdrum-1.0/xdrum' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/xdrum'\"
else
echo shar: Extracting \"'xdrum-1.0/xdrum'\" \(16554 characters\)
sed "s/^X//" >'xdrum-1.0/xdrum' <<'END_OF_FILE'
X#!/usr/local/bin/wishm -f
X# Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X#
X# Redistribution and use in source and binary forms, with or without
X# modification, are permitted provided that the following conditions
X# are met:
X# 1. Redistributions of source code must retain the above copyright
X#    notice, this list of conditions and the following disclaimer.
X# 2. Redistributions in binary form must reproduce the above copyright
X#    notice, this list of conditions and the following disclaimer in the
X#    documentation and/or other materials provided with the distribution.
X# 3. All advertising materials mentioning features or use of this software
X#    must display the following acknowledgement:
X#	This product includes software developed by Michael B. Durian.
X# 4. The name of the the Author may be used to endorse or promote 
X#    products derived from this software without specific prior written 
X#    permission.
X#
X# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X# SUCH DAMAGE.
X
X# xdrum,v 1.8 1993/05/05 01:35:25 durian Exp
X
set InputValue {}
set InputValid {}
set InputIndex {}
X
set Division 120
set Tempo 120
set Channel 0
set BaseFileName xdrum
X
set PlayPID -1
set PlayMFile {}
X
wm maxsize . 1024 1024
drumgrid .dg -xscrollcommand {.xscroll set} -yscrollcommand {.yscroll set}
scrollbar .xscroll -command {ChangePosition} -orient horizontal
scrollbar .yscroll -command {.dg yview} -orient vertical
frame .buttons
menubutton .buttons.config -text "Adjust Grid" -menu .buttons.config.menu \
X    -relief raised
menu .buttons.config.menu
X.buttons.config.menu add command -label "Add Voice" -command AddVoice
X.buttons.config.menu add command -label "Remove Voice" -command RemoveVoice
X.buttons.config.menu add command -label "Change Pitch" -command ChangePitch
X.buttons.config.menu add command -label "Change Tempo" -command ChangeTempo
X.buttons.config.menu add command -label "Change Division" \
X    -command ChangeDivision
X.buttons.config.menu add command -label "Change Channel" -command ChangeChannel
X.buttons.config.menu add separator
X.buttons.config.menu add command -label "Change Beats" -command ChangeBeats
X.buttons.config.menu add command -label "Change Measures" \
X    -command ChangeMeasures
X.buttons.config.menu add command -label "Change Quantization" \
X    -command ChangeQuant
X.buttons.config.menu add command -label "Change Levels" -command ChangeLevels
menubutton .buttons.file -text "File I/O" -menu .buttons.file.menu \
X    -relief raised
menu .buttons.file.menu
X.buttons.file.menu add command -label "Save ASCII" -command SaveASCII
X.buttons.file.menu add command -label "Load ASCII" -command LoadASCII
X.buttons.file.menu add command -label "Save MIDI" -command SaveMIDI
if {[midiplayable]} {
X	menubutton .buttons.play -text "Play" -menu .buttons.play.menu \
X	    -relief raised
X	menu .buttons.play.menu
X	.buttons.play.menu add command -label "Play Pattern" \
X	    -command PlayPattern
X	.buttons.play.menu add command -label "Stop Playing" \
X	    -command StopPlaying
X}
button .buttons.quit -text "Quit" -command {StopPlaying; destroy .}
label .position
pack append .buttons \
X    .buttons.config {left expand} \
X    .buttons.file {left expand} \
X    .buttons.quit {left expand}
pack append . \
X    .buttons {bottom fillx} \
X    .position {top fillx} \
X    .yscroll {right filly} \
X    .xscroll {bottom fillx} \
X    .dg {top fill expand}
X
if {[midiplayable]} {
X	pack before .buttons.quit .buttons.play {left expand}
X}
X
proc AddVoice {} {
X	global InputValue
X	global InputValid
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X	
X	tkwait window [GetText $x $y "New Voice:" ""]
X	if {$InputValid} {
X		.dg label add $InputValue
X	}
X}
X
proc RemoveVoice {} {
X	global InputValue
X	global InputValid
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X	
X	tkwait window [GetSelection $x $y "Which Voice:" [.dg label list]]
X	if {$InputValid} {
X		.dg label remove label [lindex $InputValue 0]
X	}
X}
X
proc ChangePitch {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetSelection $x $y "Which Voice:" [.dg label list]]
X	if {!$InputValid} {
X		return
X	}
X	set pitch [.dg pitch get $InputIndex]
X
X	tkwait window [GetText $x $y "Pitch:" $pitch]
X	if {$InputValid} {
X		.dg pitch set $InputIndex $InputValue
X	}
X}
X
proc ChangeTempo {} {
X	global InputValue
X	global InputValid
X	global Tempo
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X	
X	tkwait window [GetText $x $y "New Tempo:" $Tempo]
X	if {$InputValid} {
X		set Tempo $InputValue
X	}
X}
X
proc ChangeDivision {} {
X	global InputValue
X	global InputValid
X	global Division
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X	
X	tkwait window [GetText $x $y "New Division:" $Division]
X	if {$InputValid} {
X		set Division $InputValue
X	}
X}
X
proc ChangeChannel {} {
X	global InputValue
X	global InputValid
X	global Channel
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X	
X	tkwait window [GetText $x $y "New Channel:" $Channel]
X	if {$InputValid} {
X		set Channel $InputValue
X	}
X}
X
proc ChangeBeats {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "Beats Per Measure:" \
X	    [lindex [.dg configure -beats] 4]]
X	if {$InputValid} {
X		.dg configure -beats $InputValue
X		ChangePositionLabel [.dg xview]
X	}
X}
X
proc ChangeMeasures {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "Number of Measures:" \
X	    [lindex [.dg configure -measures] 4]]
X	if {$InputValid} {
X		.dg configure -measures $InputValue
X		ChangePositionLabel [.dg xview]
X	}
X}
X
proc ChangeQuant {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "New Quantization (mult. of 4):" \
X	    [lindex [.dg configure -quantization] 4]]
X	if {$InputValid} {
X		.dg configure -quantization $InputValue
X		ChangePositionLabel [.dg xview]
X	}
X}
X
proc ChangeLevels {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "New Levels of Dynamics:" \
X	    [lindex [.dg configure -levels] 4]]
X	if {$InputValid} {
X		.dg configure -levels $InputValue
X		ChangePositionLabel [.dg xview]
X	}
X}
X
proc SaveASCII {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X	global BaseFileName
X	global Tempo
X	global Division
X	global Channel
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "File Name:" ${BaseFileName}.ptrn]
X	if {!$InputValid} {
X		return
X	}
X
X	set BaseFileName [join [lrange [split $InputValue .] \
X	    0 [expr {[llength $InputValue] - 1}]] .]
X
X	ChangePositionLabel [.dg xview]
X
X	if {[file exists $InputValue] && ! [file writable $InputValue]} {
X		tkwait window [PutMessage $x $y \
X		    "$InputValue exists and is not writable."]
X		return
X	}
X
X	set file [open $InputValue "w"]
X	puts $file "xdrum pattern $InputValue"
X	puts $file "Measures:"
X	puts $file "[lindex [.dg configure -measures] 4]"
X	puts $file "Beats:"
X	puts $file "[lindex [.dg configure -beats] 4]"
X	puts $file "Quantization:"
X	puts $file "[lindex [.dg configure -quantization] 4]"
X	puts $file "Levels:"
X	puts $file "[lindex [.dg configure -levels] 4]"
X	puts $file "Tempo:"
X	puts $file "$Tempo"
X	puts $file "Division:"
X	puts $file "$Division"
X	puts $file "Channel:"
X	puts $file "$Channel"
X	set labels [.dg label list]
X	set num_labels [llength $labels]
X	puts $file "Number Labels:"
X	puts $file "$num_labels"
X	puts $file "Labels:"
X	foreach label $labels {
X		puts $file $label
X	}
X	puts $file "Pitches:"
X	for {set i 0} {$i < $num_labels} {incr i} {
X		puts $file [.dg pitch get $i]
X	}
X	puts $file "Volumes:"
X	foreach column [.dg volume get all] {
X		puts $file $column
X	}
X	close $file
X}
X
proc LoadASCII {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X	global BaseFileName
X	global Tempo
X	global Division
X	global Channel
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "File Name:" ${BaseFileName}.ptrn]
X	if {!$InputValid} {
X		return
X	}
X
X	set BaseFileName [join [lrange [split $InputValue .] \
X	    0 [expr {[llength $InputValue] - 1}]] .]
X
X	ChangePositionLabel [.dg xview]
X	
X	if {! ([file exists $InputValue] && [file readable $InputValue])} {
X		tkwait window [PutMessage $x $y \
X		    "$InputValue does not exist or is not readable."]
X		return
X	}
X	set file [open $InputValue "r"]
X	if { ! [string match "xdrum pattern*" [gets $file]] } {
X		tkwait window [PutMessage $x $y \
X		    "$InputValue is not a valid xdrum ASCII pattern file."]
X		return
X	}
X	# Measures:
X	gets $file
X	set measures [gets $file]
X	# Beats:
X	gets $file
X	set beats [gets $file]
X	# Quantization:
X	gets $file
X	set quant [gets $file]
X	# Levels:
X	gets $file
X	set levels [gets $file]
X	# Tempo:
X	gets $file
X	set Tempo [gets $file]
X	# Division
X	gets $file
X	set Division [gets $file]
X	# Channel
X	gets $file
X	set Channel [gets $file]
X	# Number labels:
X	gets $file
X	set num_labels [gets $file]
X	# Labels:
X	gets $file
X	for {set i 0} {$i < $num_labels} {incr i} {
X		lappend labels [gets $file]
X	}
X	# Pitches:
X	gets $file
X	for {set i 0} {$i < $num_labels} {incr i} {
X		lappend pitches [gets $file]
X	}
X	# Volumes:
X	gets $file
X	set num_hits [expr {$measures * $beats * $quant / 4}]
X	for {set i 0} {$i < $num_hits} {incr i} {
X		lappend volumes [gets $file]
X	}
X	close $file
X
X	.dg configure -measures $measures
X	.dg configure -beats $beats
X	.dg configure -quantization $quant
X	.dg configure -levels $levels
X	.dg configure -labels $labels
X	.dg configure -pitches $pitches
X	set x 0
X	foreach column $volumes {
X		set y 0
X		foreach voice $column {
X			.dg volume set $x $y $voice
X			incr y
X		}
X		incr x
X	}
X}
X
proc GenerateSMF {pattern_name} {
X	global Tempo
X	global Division
X	global Channel
X
X	# some values we'll need
X	set beats [lindex [.dg configure -beats] 4]
X	set measures [lindex [.dg configure -measures] 4]
X	set quant [lindex [.dg configure -quantization] 4]
X	set levels [lindex [.dg configure -levels] 4]
X
X	set mfile [midimake]
X	midiconfig $mfile format 1
X	midiconfig $mfile division $Division
X	midiconfig $mfile tracks 2
X
X	# give a seqence name
X	midiput $mfile 0 0 metaseqname $pattern_name
X
X	# set the tempo
X	midiput $mfile 0 0 metatempo $Tempo
X
X	# time signature
X	midiput $mfile 0 0 metatime 4 4 24 8
X
X	# now put an EOT at the end - with proper delta
X	set elapsed [expr {$Division * $beats * $measures}]
X	midiput $mfile 0 $elapsed metaeot
X
X	# now the real events
X	set events [.dg volume get all]
X	set pitches [.dg pitch list]
X	set num_voices [llength $pitches]
X
X	set time_delta [expr {$Division * 4 / $quant}]
X
X	set delta 0
X	set no_status 1
X	foreach time_slice $events {
X		set notes_on ""
X		# do notes on
X		for {set i 0} {$i < $num_voices} {incr i} {
X			set voice [lindex $time_slice $i]
X			if {$voice != 0} {
X				set p [lindex $pitches $i]
X				midiput $mfile 1 $delta noteon $Channel $p \
X				    [expr {127 * $voice / ($levels - 1)}]
X				# keep track off pitches that need to go
X				# off
X				lappend notes_on $p
X				# clear delta
X				set delta 0
X			}
X		}
X		incr delta $time_delta
X
X		# do notes off if needed
X		if {[llength $notes_on] > 0} {
X			foreach p $notes_on {
X				midiput $mfile 1 $delta noteoff $Channel $p
X				# clear delta
X				set delta 0
X			}
X		}
X	}
X	# EOT for track 1
X	midiput $mfile 1 $delta metaeot
X
X	return $mfile
X}
X
proc SaveMIDI {} {
X	global InputValue
X	global InputValid
X	global InputIndex
X	global BaseFileName
X
X	set pos [split [wm geometry .] +]
X	set x [expr {[lindex $pos 1] + 20}]
X	set y [expr {[lindex $pos 2] + 20}]
X
X	tkwait window [GetText $x $y "File Name:" ${BaseFileName}.mid]
X	if {!$InputValid} {
X		return
X	}
X
X	set BaseFileName [join [lrange [split $InputValue .] \
X	    0 [expr {[llength $InputValue] - 1}]] .]
X
X	ChangePositionLabel [.dg xview]
X
X	if {[file exists $InputValue] && ! [file writable $InputValue]} {
X		tkwait window [PutMessage $x $y \
X		    "$InputValue exists and is not writable."]
X		return
X	}
X
X	# now let's write this puppy
X	set file [open $InputValue "w"]
X	set mfile [GenerateSMF $InputValue]
X	midiwrite $mfile $file
X	close $file
X	midifree $mfile
X}
X
proc PlayPattern {} {
X	global PlayPID
X	global PlayMFile
X
X	set mfile [GenerateSMF internal]
X	set PlayPID [midiplay background repeat $mfile]
X	set PlayMFile $mfile
X}
X
proc StopPlaying {} {
X	global PlayPID
X	global PlayMFile
X
X	if {$PlayPID != -1} {
X		midistop $PlayPID
X		midifree $PlayMFile
X		set PlayPID -1
X	}
X}
X
X
proc ChangePositionLabel {hit} {
X	global BaseFileName
X
X	set quant [lindex [.dg configure -quantization] 4]
X	set measure [expr {$hit / $quant}]
X	set remain [expr {$hit % $quant}]
X	set hit_per_beat [expr {$quant / 4}]
X	set beat [expr {$remain / $hit_per_beat}]
X	set q [expr {$remain % $hit_per_beat}]
X
X	.position configure -text \
X	    "$BaseFileName - Measure:$measure Beat:$beat Quant:$q/$hit_per_beat"
X}
X
proc ChangePosition {hit} {
X
X	.dg xview $hit
X	ChangePositionLabel [.dg xview]
X}
X
X
proc GetText {x y prompt default} {
X	global InputValue
X	global InputValid
X
X	toplevel .get_text
X	wm transient .get_text .
X	wm geometry .get_text "+$x+$y"
X	grab .get_text
X
X	set InputValid 0
X
X	label .get_text.label -text "$prompt"
X	entry .get_text.entry
X	.get_text.entry insert 0 "$default"
X	bind .get_text.entry <Return> {set InputValue [.get_text.entry get]; \
X	    set InputValid 1; destroy .get_text}
X	button .get_text.ok -text "OK" -command {set InputValue \
X	    [.get_text.entry get]; set InputValid 1; destroy .get_text}
X	button .get_text.cancel -text "Cancel" -command {destroy .get_text}
X
X	focus .get_text.entry
X
X	pack append .get_text \
X	    .get_text.label {top fill} \
X	    .get_text.entry {top fill} \
X	    .get_text.ok {left fill expand} \
X	    .get_text.cancel {left fill expand}
X	return ".get_text"
X}
X
proc GetSelection {x y prompt list} {
X	global InputValue
X	global InputValid
X
X	toplevel .get_sel
X	wm transient .get_sel .
X	wm geometry .get_sel "+$x+$y"
X	grab .get_sel
X
X	set InputValid 0
X	set InputIndex 0
X
X	label .get_sel.label -text "$prompt"
X	listbox .get_sel.list -yscrollcommand {.get_sel.scrolly set}
X	foreach elem $list {
X		.get_sel.list insert end $elem
X	}
X	tk_listboxSingleSelect .get_sel.list
X	button .get_sel.cancel -text "Cancel" -command {destroy .get_sel}
X	scrollbar .get_sel.scrolly -command {.get_sel.list yview}
X
X	bind .get_sel.list <ButtonRelease-1> {set InputValue [selection get]; \
X	    set InputValid 1; \
X	    set InputIndex [.get_sel.list curselection]; \
X	    destroy .get_sel}
X
X	pack append .get_sel \
X		.get_sel.label {top fill} \
X		.get_sel.cancel {bottom fill} \
X		.get_sel.scrolly {right filly} \
X		.get_sel.list {top fill expand}
X
X	return .get_sel
X}
X
proc PutMessage {x y message} {
X
X	toplevel .put_message
X	wm transient .put_message .
X	wm geometry .put_message "+$x+$y"
X	grab .put_message
X
X	label .put_message.message -text "$message"
X	button .put_message.ok -text "OK" -command {destroy .put_message}
X
X	pack append .put_message \
X	    .put_message.message {top fill expand} \
X	    .put_message.ok {bottom fill}
X	return ".put_message"
X}
X
proc StrToHex {str} {
X
X	foreach char [split $str {}] {
X		scan $char %c dec
X		lappend hex_str [format 0x%x $dec]
X	}
X
X	return $hex_str
X}
X
ChangePositionLabel 0
END_OF_FILE
if test 16554 -ne `wc -c <'xdrum-1.0/xdrum'`; then
    echo shar: \"'xdrum-1.0/xdrum'\" unpacked with wrong size!
fi
chmod +x 'xdrum-1.0/xdrum'
# end of 'xdrum-1.0/xdrum'
fi
if test -f 'xdrum-1.0/xdrum.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdrum-1.0/xdrum.1'\"
else
echo shar: Extracting \"'xdrum-1.0/xdrum.1'\" \(3912 characters\)
sed "s/^X//" >'xdrum-1.0/xdrum.1' <<'END_OF_FILE'
X.Dd March 31, 1993
X.Os WISHM
X.Dt XDRUM 1
X.Sh NAME
X.Nm xdrum
X.Nd "a program for graphically creating and editing drum patterns"
X.Sh SYNOPSIS
X.Nm
X.Sh DESCRIPTION
X.Nm
is a program that runs under X.
It is designed to facilitate constructing and editing
rhythms for drum machines, and
is based on 
X.Xr TCL 1,
X.Xr TK  1
and
X.Xr TCLM 1 .
X.Nm
supports reading and saving the patterns in an
X.Tn ASCII
format as well as saving
patterns in the Standard
X.Tn MIDI
format for playing back with other utilities,
such as
X.Xr mplay 1 .
XEssentially,
X.Nm
is just a fancy wrapper around the
X.Xr drumgrid 3
widget.
See
X.Xr drumgrid 3
for further information.
X.Pp
X.Nm
uses the default
X.Xr drumgrid 3
bindings.
Pressing mouse button 1 in a box will
increase the velocity of the box by 1.
Pressing mouse button 3 decrease the
velocity by 1, and pressing mouse button 2 sets
the velocity to zero.
Since it is a pain to constantly click the mouse
button to set velocities to higher values,
keyboard accelerators have also been incorporated
into
X.Nm Ns . 
The velocity of a box can be set directly to a
specific value by first moving the mouse to the
box and then pressing a key in the range 0 - 9,
where the key value is the desired velocity.
The '+' key can be used to increment the velocity
of a box by 10 and the '-' decrements the velocity
by 10.
Thus, you can set the value to velocities greater
than 9.
If you specify a velocity greater than the maximum
level, the maximum level will be used.
X.Pp
X.Nm
also has 2, or 3, pull down menus that allow you
to adjust the parameters in the grid and save or load
files.
The optional third menu will only appear if the
X.Xr tclm 1
library was compiled with play support.
The ``Adjust Grid'' menu allows you to add voices and
remove them, change the pitch of voices, which is a voice's
associated
X.Tn MIDI
value, change the tempo
of the pattern, change the
X.Tn MIDI
channel on which
the pattern is played and change the division value to
use when generating a
X.Tn MIDI
file.
This menu also allows you to change the configuration of
the grid.
You can change the number of measures in the pattern, the
number of beats per measure, the quantization value and
the number velocity levels (remember a velocity of zero
counts as a level).
These options are displayed below a line in the menu because
changing these values will erase anything that is currently
in the grid.
X.Pp
The ``File I/O'' menu allows you to save a pattern in
an
X.Tn ASCII
format, load a pattern that was previously
saved in the
X.Tn ASCII
format and save a pattern as
a Standard
X.Tn MIDI
file.
X.Nm
cannot load files in the Standard
X.Tn MIDI
format.
XFiles that have been saved in the
X.tn ASCII
format
may also be edited by hand with your favorite editor.
X.Pp
The optional third menu allows you to start playing the
pattern and stop playing the pattern.
This menu will only appear if your version of the
X.Xr tclm 1
library was compiled with support for playing Standard
X.Tn MIDI
files.
X.Pp
There is also a ``Quit'' button for exiting the application.
X.Pp
Since
X.Nm
may only display a portion of the pattern at one time,
a message is displayed above the grid showing
where in the pattern
the display begins.
This value is shown in measures, beats and fractions of a beat.
The name of the pattern is also displayed.
The scrollbars allow you to move around in the pattern.
X.Sh APPLICATION RESOURCES
The application resources which are part of the
X.Xr drumgrid 3
widget are
available to customize the
X.Nm
setup.
It is recommended that the voices and related pitches be
stored in your .Xdefaults file so they need not be set
by hand each time
X.Nm
is run.
X.Sh SEE ALSO
X.Xr tclm 1 ,
X.Xr wish 1 ,
X.Xr drumgrid 3
X.Sh AUTHORS
X.Tn TCL
and
X.Tn TK
X.D1 John Ousterhout - ouster@cs.berkeley.edu
X.Tn TCLM
and
X.Tn XDRUM
X.D1 Mike Durian - durian@advtech.uswest.com
X.Sh BUGS
Just because I don't currently know of any doesn't mean they
aren't there.
END_OF_FILE
if test 3912 -ne `wc -c <'xdrum-1.0/xdrum.1'`; then
    echo shar: \"'xdrum-1.0/xdrum.1'\" unpacked with wrong size!
fi
# end of 'xdrum-1.0/xdrum.1'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
