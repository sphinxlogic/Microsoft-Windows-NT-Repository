Newsgroups: comp.sources.misc
From: fleurant@hri.com (P.Fleurant)
Subject: v37i040:  magiccube - a cube simulator for X11/Motif, Part03/05
Message-ID: <1993May10.213158.29157@sparky.imd.sterling.com>
X-Md4-Signature: bfdc115c9148e0b7b11aa2eb2f299581
Date: Mon, 10 May 1993 21:31:58 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: fleurant@hri.com (P.Fleurant)
Posting-number: Volume 37, Issue 40
Archive-name: magiccube/part03
Environment: X11, Motif, ANSI-C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  cube/Makefile cube/layer2.c cube/layer3.c cube/ldfile.c
#   cube/ldfile.h cube/lib/menus.c cube/lib/pix_buttons.c
# Wrapped by kent@sparky on Mon May 10 16:15:41 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 5)."'
if test -f 'cube/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/Makefile'\"
else
  echo shar: Extracting \"'cube/Makefile'\" \(13072 characters\)
  sed "s/^X//" >'cube/Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a02058>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.0.3
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X#
X# Imakefile - magicCube
X#
X#
X
X############################################################################
X#
X#
X#
X
XCC = cc
X#CC = cc #-Aa -D_HPUX_SOURCE
X#CC = cc -Aa -D_HPUX_SOURCE		#HPUX
X#CC = cc -xansi -D__STDC__		#SGI Indigo?
X
XXSLIB = lib/libXs.a
X
XSTD_INCLUDES = -I/usr/local/X11R5/include -I/usr/local/include  -I./lib
XSTD_CPP_DEFINES =
XSTD_DEFINES =
XEXTRA_LOAD_FLAGS = -lXm -lX11 -lXt -lm
XEXTRA_LIBRARIES = -L/usr/local/X11R5/lib -L/usr/lib
X
XCDEBUGFLAGS = -g
X#CDEBUGFLAGS = +O3 +OS +ESlit	#HPUX cc
X#HPUX: CDEBUGFLAGS = +O3 +OS +ESlit ... LDFLAGS: -Wl,-I first, then -Wl,-P
X
X############################################################################
X#
X# Source and object files.
X#
X
XOBJS  = cube.o init_cubik.o taylor.o layer1edge_tf.o layer1edge_tr.o layer1edge_tb.o layer1edge_tl.o \
X       layer1corner.o layer1c_txx.o layer2.o layer3.o layer3twirl.o layer3flip.o ldfile.o
XSRCS  = cube.c init_cubik.c taylor.c layer1edge_tf.c layer1edge_tr.c layer1edge_tb.c layer1edge_tl.c \
X       layer1corner.c layer1c_txx.c layer2.c layer3.c layer3twirl.c layer3flip.c ldfile.c
X
X############################################################################
X#
X# Make subdirectories, Xs
X#
XSUBDIRS = lib
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   depend); \
X	done
X
X############################################################################
X#
X#
X#
X
Xall:: magicCube
X
XmagicCube: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(XSLIB) $(LDLIBS) $(SYS_LIBRARIES) $(EXTRA_LOAD_FLAGS)
X
Xclean::
X	$(RM) magicCube
X
Xadd_resource:
X	xrdb -merge MagicCube
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	#load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	#load $(ALLDEFINES) $(OBJS)
X
X###########################################################################
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*) newtop=../../ sub=subsub;; \
X	./?*) newtop=../ sub=sub;; \
X	*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	*/?*) newtop=../../ sub=subsub;; \
X	*) newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop= upprefix= ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   includes); \
X	done
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
  if test 13072 -ne `wc -c <'cube/Makefile'`; then
    echo shar: \"'cube/Makefile'\" unpacked with wrong size!
  fi
  # end of 'cube/Makefile'
fi
if test -f 'cube/layer2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/layer2.c'\"
else
  echo shar: Extracting \"'cube/layer2.c'\" \(7518 characters\)
  sed "s/^X//" >'cube/layer2.c' <<'END_OF_FILE'
X/* layer2.c
X   This incorporates Don Taylor's solution to the 
X   Buvos Kocka (Hungarian Magic Cube). 
X
X   Middle Layer Cubes
X   
X   The following references were used:
X   "The X Window System Programming And Applications with Xt
X   OSF/MOTIF EDITION"
X   by Douglas A Young 
X   Prentice-Hall, 1990.
X   ISBN 0-13-642786-3
X
X   "Mastering Rubik's Cube"
X   by Don Taylor
X   An Owl Book; Holt, Rinehart and Winston, New York, 1980
X   ISBN 0-03-059941-5
X
X-------------------------------------------------------------------
XCopyright (C) 1993 by Pierre A. Fleurant
XPermission is granted to copy and distribute this program
Xwithout charge, provided this copyright notice is included
Xin the copy.
XThis Software is distributed on an as-is basis. There will be
XABSOLUTELY NO WARRANTY for any part of this software to work
Xcorrect. In no case will the author be liable to you for damages
Xcaused by the usage of this software.
X-------------------------------------------------------------------
X       
X*/   
X
X#include "taylor.h"
X
Xextern void F(); /*  front  */
Xextern void L(); /*  left   */
Xextern void R(); /*  right  */
Xextern void B(); /*  back   */
Xextern void U(); /*  up     */
Xextern void D(); /*  down   */
X
XBoolean middle_layer(w,wdata,call_data) /* These parameters needed for macros */
X     Widget   w;
X     widget_data *wdata;
X     caddr_t  call_data;
X{
X  /* Search for middle edge cubes.
X     Place in bottom layer.
X     Dispatch to middle_layer_[f,r,b,l]t accordingly.
X     */
X
X  /* Find edge cubes in bottom layer that belong 
X   * in  middle layer.
X   */
X  
X  /*1*/
X  if(Front(7) != BOTTOM &&
X     Bottom(1) != BOTTOM){
X    /* Then it is a middle layer edge */
X    /* It is 1 of 8 combinations */
X    if(Front(7)  == FRONT &&
X       Bottom(1) == RIGHT){
X      D(-1);
X      F(1);D(2);L(1);D(1);L(-1);D(2);F(-1); /* 10.3 'top matches left-hand' */
X    }
X    
X    else if(Front(7)  == RIGHT &&
X	    Bottom(1) == FRONT){
X      F(1);D(2);L(1);D(-1);L(-1);D(2);F(-1); /* 10.4 'top matches front-hand' */
X    }
X    
X    
X    
X    else if(Front(7)  == RIGHT &&
X	    Bottom(1) == BACK){
X      R(1);D(2);F(1);D(1);F(-1);D(2);R(-1); /* 10.3 */
X    }
X    
X    else if(Front(7)  == BACK &&
X	    Bottom(1) == RIGHT){
X      D(1);
X      R(1);D(2);F(1);D(-1);F(-1);D(2);R(-1); /* 10.4 */
X    }
X    
X    
X    
X    else if(Front(7)  == BACK &&
X	    Bottom(1) == LEFT){
X      D(1);
X      B(1);D(2);R(1);D(1);R(-1);D(2);B(-1); /* 10.3 */
X    }
X    
X    else if(Front(7)  == LEFT &&
X	    Bottom(1) == BACK){
X      D(2);
X      B(1);D(2);R(1);D(-1);R(-1);D(2);B(-1);
X    }
X    
X    
X    
X    else if(Front(7)  == LEFT &&
X	    Bottom(1) == FRONT){
X      D(2);
X      L(1);D(2);B(1);D(1);B(-1);D(2);L(-1);
X    }
X    
X    else if(Front(7)  == FRONT &&
X	    Bottom(1) == LEFT){
X      D(-1);
X      L(1);D(2);B(1);D(-1);B(-1);D(2);L(-1);
X    }
X    return(False);
X  }
X  /*2*/
X  else if(Right(7) != BOTTOM &&
X	  Bottom(5) != BOTTOM){
X    /* Then it is a middle layer edge */
X    /* It is 1 of 8 combinations */
X    if(Right(7)  == FRONT &&
X       Bottom(5) == RIGHT){
X      D(2);
X      F(1);D(2);L(1);D(1);L(-1);D(2);F(-1); /* 10.3 'top matches left-hand' */
X    }
X    
X    else if(Right(7)  == RIGHT &&
X	    Bottom(5) == FRONT){
X      D(-1);
X      F(1);D(2);L(1);D(-1);L(-1);D(2);F(-1); /* 10.4 'top matches front-hand' */
X    }
X    
X    
X    
X    else if(Right(7)  == RIGHT &&
X	    Bottom(5) == BACK){
X      D(-1);
X      R(1);D(2);F(1);D(1);F(-1);D(2);R(-1); /* 10.3 */
X    }
X    
X    else if(Right(7)  == BACK &&
X	    Bottom(5) == RIGHT){
X      R(1);D(2);F(1);D(-1);F(-1);D(2);R(-1); /* 10.4 */
X    }
X    
X    
X    
X    else if(Right(7)  == BACK &&
X	    Bottom(5) == LEFT){
X      B(1);D(2);R(1);D(1);R(-1);D(2);B(-1); /* 10.3 */
X    }
X    
X    else if(Right(7)  == LEFT &&
X	    Bottom(5) == BACK){
X      D(1);
X      B(1);D(2);R(1);D(-1);R(-1);D(2);B(-1);
X    }
X    
X    
X    
X    else if(Right(7)  == LEFT &&
X	    Bottom(5) == FRONT){
X      D(1);
X      L(1);D(2);B(1);D(1);B(-1);D(2);L(-1);
X    }
X    
X    else if(Right(7)  == FRONT &&
X	    Bottom(5) == LEFT){
X      D(2);
X      L(1);D(2);B(1);D(-1);B(-1);D(2);L(-1);
X    }
X    return(False);
X  }
X  /*3*/
X  else if(Back(7) != BOTTOM &&
X	  Bottom(7) != BOTTOM){
X    /* Then it is a middle layer edge */
X    /* It is 1 of 8 combinations */
X    if(Back(7)  == FRONT &&
X       Bottom(7) == RIGHT){
X      D(1);
X      F(1);D(2);L(1);D(1);L(-1);D(2);F(-1); /* 10.3 'top matches left-hand' */
X    }
X    
X    else if(Back(7)  == RIGHT &&
X	    Bottom(7) == FRONT){
X      D(2);
X      F(1);D(2);L(1);D(-1);L(-1);D(2);F(-1); /* 10.4 'top matches front-hand' */
X    }
X    
X    
X    
X    else if(Back(7)  == RIGHT &&
X	    Bottom(7) == BACK){
X      D(2);
X      R(1);D(2);F(1);D(1);F(-1);D(2);R(-1); /* 10.3 */
X    }
X    
X    else if(Back(7)  == BACK &&
X	    Bottom(7) == RIGHT){
X      D(3);
X      R(1);D(2);F(1);D(-1);F(-1);D(2);R(-1); /* 10.4 */
X    }
X    
X    
X    
X    else if(Back(7)  == BACK &&
X	    Bottom(7) == LEFT){
X      D(3);
X      B(1);D(2);R(1);D(1);R(-1);D(2);B(-1); /* 10.3 */
X    }
X    
X    else if(Back(7)  == LEFT &&
X	    Bottom(7) == BACK){
X      B(1);D(2);R(1);D(-1);R(-1);D(2);B(-1);
X    }
X    
X    
X    
X    else if(Back(7)  == LEFT &&
X	    Bottom(7) == FRONT){
X      L(1);D(2);B(1);D(1);B(-1);D(2);L(-1);
X    }
X    
X    else if(Back(7)  == FRONT &&
X	    Bottom(7) == LEFT){
X      D(1);
X      L(1);D(2);B(1);D(-1);B(-1);D(2);L(-1);
X    }
X    return(False);
X  }
X  /*4*/
X  else if(Left(7) != BOTTOM &&
X	  Bottom(3) != BOTTOM){
X    /* Then it is a middle layer edge */
X    /* It is 1 of 8 combinations */
X    if(Left(7)  == FRONT &&
X       Bottom(3) == RIGHT){
X      F(1);D(2);L(1);D(1);L(-1);D(2);F(-1); /* 10.3 'top matches left-hand' */
X    }
X    
X    else if(Left(7)  == RIGHT &&
X	    Bottom(3) == FRONT){
X      D(1);
X      F(1);D(2);L(1);D(-1);L(-1);D(2);F(-1); /* 10.4 'top matches front-hand' */
X    }
X    
X    
X    
X    else if(Left(7)  == RIGHT &&
X	    Bottom(3) == BACK){
X      D(1);
X      R(1);D(2);F(1);D(1);F(-1);D(2);R(-1); /* 10.3 */
X    }
X    
X    else if(Left(7)  == BACK &&
X	    Bottom(3) == RIGHT){
X      D(2);
X      R(1);D(2);F(1);D(-1);F(-1);D(2);R(-1); /* 10.4 */
X    }
X    
X    
X    
X    else if(Left(7)  == BACK &&
X	    Bottom(3) == LEFT){
X      D(2);
X      B(1);D(2);R(1);D(1);R(-1);D(2);B(-1); /* 10.3 */
X    }
X    
X    else if(Left(7)  == LEFT &&
X	    Bottom(3) == BACK){
X      D(-1);
X      B(1);D(2);R(1);D(-1);R(-1);D(2);B(-1);
X    }
X    
X    
X    
X    else if(Left(7)  == LEFT &&
X	    Bottom(3) == FRONT){
X      D(-1);
X      L(1);D(2);B(1);D(1);B(-1);D(2);L(-1);
X    }
X    
X    else if(Left(7)  == FRONT &&
X	    Bottom(3) == LEFT){
X      L(1);D(2);B(1);D(-1);B(-1);D(2);L(-1);
X    }
X    return(False);
X  }
X
X  /* Check if all middle layer cubes in place */
X  else if(Front(5) == FRONT &&
X	  Right(3) == RIGHT &&
X	  Right(5) == RIGHT &&
X	  Back(5) == BACK &&
X	  Back(3) == BACK &&
X	  Left(5) == LEFT &&
X	  Left(3) == LEFT &&
X	  Front(3) == FRONT){
X    return(True);
X  }
X  /* Else no middle layer cubes in the bottom layer.
X     * So a middle layer cube must be moved out to the bottom layer.
X     */
X  else {
X    if(Front(5) == RIGHT &&
X       Right(3) == FRONT){
X      F(1);D(2);L(1);D(1);L(-1);D(2);F(-1);     
X    }
X    else if(Right(5) == BACK &&
X	    Back(5) == RIGHT){
X      R(1);D(2);F(1);D(1);F(-1);D(2);R(-1); 
X    }
X    else if(Back(3) == LEFT &&
X	    Left(5) == BACK){
X      B(1);D(2);R(1);D(1);R(-1);D(2);B(-1); 
X    }
X    else if(Left(3) == FRONT &&
X	    Front(3) == LEFT){
X      L(1);D(2);B(1);D(1);B(-1);D(2);L(-1);
X    }
X    return(False);
X  }
X}
END_OF_FILE
  if test 7518 -ne `wc -c <'cube/layer2.c'`; then
    echo shar: \"'cube/layer2.c'\" unpacked with wrong size!
  fi
  # end of 'cube/layer2.c'
fi
if test -f 'cube/layer3.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/layer3.c'\"
else
  echo shar: Extracting \"'cube/layer3.c'\" \(12224 characters\)
  sed "s/^X//" >'cube/layer3.c' <<'END_OF_FILE'
X/* layer3.c
X   This incorporates Don Taylor's solution to the 
X   Buvos Kocka (Hungarian Magic Cube). 
X
X   Last Layer Cubes
X
X   a) Down(n) until one corner has correct position
X   b) Move corners into correct position (Section 11; a, b, c, d solutions)
X   c) Move edge cubes into correct position
X       
X
X
XThe following references were used:
X   "The X Window System Programming And Applications with Xt
X   OSF/MOTIF EDITION"
X   by Douglas A Young 
X   Prentice-Hall, 1990.
X   ISBN 0-13-642786-3
X
X   "Mastering Rubik's Cube"
X   by Don Taylor
X   An Owl Book; Holt, Rinehart and Winston, New York, 1980
X   ISBN 0-03-059941-5
X
X-------------------------------------------------------------------
XCopyright (C) 1993 by Pierre A. Fleurant
XPermission is granted to copy and distribute this program
Xwithout charge, provided this copyright notice is included
Xin the copy.
XThis Software is distributed on an as-is basis. There will be
XABSOLUTELY NO WARRANTY for any part of this software to work
Xcorrect. In no case will the author be liable to you for damages
Xcaused by the usage of this software.
X-------------------------------------------------------------------
X*/   
X
X#include "taylor.h"
X
Xextern void F(); /*  front  */
Xextern void L(); /*  left   */
Xextern void R(); /*  right  */
Xextern void B(); /*  back   */
Xextern void U(); /*  up     */
Xextern void D(); /*  down   */
X
Xvoid last_layer(w,wdata,call_data) /* These parameters needed for macros */
X     Widget   w;
X     widget_data *wdata;
X     caddr_t  call_data;
X{
X  /**** Move corners into correct position ****/
X  /* Place correct corner at Back(8)/Right(8)/Bottom(8).
X   * There are only 4 possible locations.
X   */
X  
X  
X  if((Back(6) == BACK   || Back(6) == BOTTOM   || Back(6) == RIGHT) &&
X     (Bottom(6) == BACK || Bottom(6) == BOTTOM || Bottom(6) == RIGHT) &&
X     (Left(8) == BACK   || Left(8) == BOTTOM   || Left(8) == RIGHT)){
X    D(-1);
X  }
X  else if((Front(6) == BACK  || Front(6) == BOTTOM  || Front(6) == RIGHT) &&
X	  (Bottom(0) == BACK || Bottom(0) == BOTTOM || Bottom(0) == RIGHT) &&
X	  (Left(6) == BACK   || Left(6) == BOTTOM   || Left(6) == RIGHT)){
X    D(2);
X  }
X  else if((Front(8) == BACK  || Front(8) == BOTTOM  || Front(8) == RIGHT) &&
X	  (Bottom(2) == BACK || Bottom(2) == BOTTOM || Bottom(2) == RIGHT) &&
X	  (Right(6) == BACK  || Right(6) == BOTTOM  || Right(6) == RIGHT)){
X    D(1);
X  }
X  
X  /* Now Back(8)/Right(8)/Bottom(8) is correct and is reference  point.
X   * Place other corner cubes in correct position.
X   * 
X   * Proceed to crack for a, b, c, or d solution.
X   * Using just bottom(n=0,2,6,8) == true to test if cube is in right 
X   * position. The following if/then/else tree is used to crack for
X   * a, b, c,  or d solution.
X   *
X   *  Given that bottom(8) = true now:
X   *          front 
X   *   -------------------
X   *   |     |     |     |
X   *   |     |     |     |
X   *   |  0  |     |  2  |
X   *   -------------------
X   * l |     |     |     |  right 
X   * e |     |     |     |
X   * f |     |     |     |
X   * t  -------------------
X   *   |     |     |     |
X   *   |     |     | ok  |
X   *   |  6  |     |  8  |
X   *   -------------------
X   *          back
X   *
X   *   if(bottom(2) == true){
X   *       if(bottom(0) == true)  
X   *         "then all four courners must be in correct postion"
X   *       else
X   *         "then bottom(6)=false and C solution(swap0-6)"
X   *   }
X   *   else{
X   *       if(bottom(0) == true)
X   *         "then bottom(6)=false and D solution(swap2-6)"
X   *       else{
X   *         if(bottom(6) == true)
X   *          "then C solution(swap0-2)"
X   *	     else{
X   *	       if(bottom(6) belongs in bottom(0))
X   *	          "A solution(2<--0;0<--6;6<--2)"
X   *	       else
X   *	          "B solution(2<--6;0<--2;6<--0)"
X   *         }
X   *       }
X   *   }
X   */
X
X  if(/* bottom(2) */
X     (Front(8) == FRONT  || Front(8) == BOTTOM  || Front(8) == RIGHT) &&
X     (Bottom(2) == FRONT || Bottom(2) == BOTTOM || Bottom(2) == RIGHT) &&
X     (Right(6) == FRONT  || Right(6) == BOTTOM  || Right(6) == RIGHT)){
X    /* Then this adjacent cube is correct and sub-solution is `c' 
X     * or all corners in correct position.
X     */
X    if(/* bottom(0) */
X       (Front(6) == FRONT  || Front(6) == BOTTOM  || Front(6) == LEFT) &&
X       (Bottom(0) == FRONT || Bottom(0) == BOTTOM || Bottom(0) == LEFT) &&
X       (Left(6) == FRONT   || Left(6) == BOTTOM   || Left(6) == LEFT)){
X      /* all corners must be ok */
X      ;
X    }
X    else{
X      /*          front 
X       *   -------------------
X       *   |  0  |     |  2  |
X       *   | not |     | ok  |
X       *   | ok  |     |     |
X       *   -------------------
X       * l |     |     |     |  right 
X       * e |     |     |     |
X       * f |     |     |     |
X       * t  -------------------
X       *   | not |     |     |
X       *   | ok  |     | ok  |
X       *   |  6  |     |  8  |
X       *   -------------------
X       *          back
X       */
X      /* c solution needed */
X      R(1);D(-1);L(-1);D(1);R(-1);D(-1);L(1);D(2);
X    }
X  }
X  else{
X    if(/* Bottom(0) */
X       (Front(6) == FRONT  || Front(6) == BOTTOM  || Front(6) == LEFT) &&
X       (Bottom(0) == FRONT || Bottom(0) == BOTTOM || Bottom(0) == LEFT) &&
X       (Left(6) == FRONT   || Left(6) == BOTTOM   || Left(6) == LEFT)){
X      /*          front 
X       *   -------------------
X       *   |     |     | not |
X       *   |  ok |     |  ok |
X       *   |  0  |     |  2  |
X       *   -------------------
X       * l |     |     |     |  right 
X       * e |     |     |     |
X       * f |     |     |     |
X       * t -------------------
X       *   | not |     |     |
X       *   | ok  |     | ok  | 
X       *   |  6  |     |  8  |
X       *   -------------------
X       *          back
X       */
X      /* d solution needed */
X      D(1);B(1);D(1);R(1);D(-1);R(-1);B(-1);
X    }
X    else{
X      if(/*bottom(6)*/
X	 (Back(6) == BACK   || Back(6) == BOTTOM   || Back(6) == LEFT) &&
X	 (Bottom(6) == BACK || Bottom(6) == BOTTOM || Bottom(6) == LEFT) &&
X	 (Left(8) == BACK   || Left(8) == BOTTOM   || Left(8) == LEFT)){
X	/*          front 
X	 *   -------------------
X	 *   | not |     | not |
X	 *   |  ok |     |  ok |
X	 *   |  0  |     |  2  |
X	 *   -------------------
X	 * l |     |     |     |  right 
X	 * e |     |     |     |
X	 * f |     |     |     |
X	 * t -------------------
X	 *   |     |     |     |
X	 *   | ok  |     | ok  | Must be OK
X	 *   |  6  |     |  8  |
X	 *   -------------------
X	 *          back
X	 */ 
X	/* c solution needed */
X	B(1);D(-1);F(-1);D(1);B(-1);D(-1);F(1);D(2);
X      }
X      else{ 
X	if(/*bottom(6)*/
X	 (Back(6) == FRONT   || Back(6) == BOTTOM   || Back(6) == LEFT) &&
X	 (Bottom(6) == FRONT || Bottom(6) == BOTTOM || Bottom(6) == LEFT) &&
X	 (Left(8) == FRONT   || Left(8) == BOTTOM   || Left(8) == LEFT)){
X	  /* bottom(6) belongs in bottom(0) */
X	  /* A solution needed (2<--0;0<--6;6<--2) */
X	  L(-1);D(1);R(1);D(-1);L(1);D(1);R(-1);D(-1);
X	}
X	else{
X	  /* bottom(6) belongs in bottom(2) */
X	  /* B solution needed (2<--6;0<--2;6<--0) */
X	  D(1);R(1);D(-1);L(-1);D(1);R(-1);D(-1);L(1);
X	}
X      }
X    }
X  }
X
X  /**** Move edges into correct position ****/
X  
X  /* Proceed to crack for a, b, c, or d solution.
X   * Using just bottom(n=1,3,5,7) == true to test if cube is in right 
X   * position. The following if/then/else tree is used to crack for
X   * a, b, c,  or d solution.
X   *
X   *          front 
X   *   -------------------
X   *   |     |     |     |
X   *   |     |     |     |
X   *   |     |  1  |     |
X   *   -------------------
X   * l |     |     |     |  right 
X   * e |     |     |     |
X   * f |  3  |     |  5  |
X   * t -------------------
X   *   |     |     |     |
X   *   |     |     |     |
X   *   |     |  7  |     |
X   *   -------------------
X   *          back
X   *
X   *   if(bottom(1) == true){
X   *      if(bottom(3) belongs in bottom(5))
X   *        "A solution(3 to 5 to 7 to 3)"
X   *      else if(bottom(5) belongs in bottom(3))
X   *        "B solution(5 to 3 to 7 to 5)"
X   *      else
X   *        "No solution needed, all edges  are ok"
X   *   }else
X   *   if(bottom(3) == true){
X   *      if(bottom(7) belongs in bottom(1))
X   *        "A solution(7 to 1 to 5 to 7)"
X   *      else if(bottom(1) belongs in bottom(7))
X   *        "B solution(1 to 7 to 5 to 1)"
X   *      else
X   *        "No solution needed, all edges  are ok"
X   *   }else
X   *   if(bottom(5) == true){
X   *      if(bottom(1) belongs in bottom(7))
X   *        "A solution(1 to 7 to 3 to 1)"
X   *      else if(bottom(7) belongs in bottom(1))
X   *        "B solution(7 to 1 to 3 to 7)"
X   *      else
X   *        "No solution needed, all edges  are ok"
X   *   }else
X   *   if(bottom(7) == true){
X   *      if(bottom(5) belongs in bottom(3))
X   *        "A solution(5 to 3 to 1 to 5)"
X   *      else if(bottom(3) belongs in bottom(5))
X   *        "B solution(3 to 5 to 1 to 3)"
X   *      else
X   *        "No solution needed, all edges  are ok"
X   *   }else{
X   *    "No edges are in the correct position."
X   *    "Find out where bottom(1) belongs and this determines
X   *     the correct solution"
X   *     if(bottom(1) belongs in bottom(3))
X   *       "D solution(1 to 3; 3 to 1; 5 to 7; 7 to 5)"
X   *     else if(bottom(1) belongs in bottom(7))
X   *       "C solution(1 to 7; 7 to 1; 3 to 5; 5 to 3)"
X   *     else if(bottom(1) belongs in bottom(5))
X   *       "D solution(1 to 5; 5 to 1; 3 to 7; 7 to 3)"
X   *   }
X   */ 
X
X  if(Front(7) == FRONT || Bottom(1) == FRONT){
X    /* bottom(1) ok */
X    if(Left(7) == RIGHT || Bottom(3) == RIGHT){
X      /* bottom(3) belongs in bottom(5) */
X      /* A solution(3 to 5 to 7 to 3) */
X      B(2);D(1);R(-1);L(1);B(2);R(1);L(-1);D(1);B(2);
X    }
X    else if(Right(7) == LEFT || Bottom(5) == LEFT){
X      /* bottom(5) belongs in bottom(3) */
X      /* B solution(5 to 3 to 7 to 5) */
X      B(2);D(-1);R(-1);L(1);B(2);R(1);L(-1);D(-1);B(2);
X    }
X    else{ ; } /* all edges in proper place */
X  }
X
X  else if(Left(7) == LEFT || Bottom(3) == LEFT){
X    /* bottom(3) ok */
X    if(Back(7) == FRONT || Bottom(7) == FRONT){
X      /* bottom(7) belongs in bottom(1) */
X      /* A solution(7 to 1 to 5 to 7) */
X      L(2);D(1);F(-1);B(1);L(2);F(1);B(-1);D(1);L(2);
X    }
X    else if(Front(7) == BACK || Bottom(1) == BACK){
X      /* bottom(1) belongs in bottom(7) */
X      /* B solution(1 to 7 to 5 to 1) */
X      L(2);D(-1);F(-1);B(1);L(2);F(1);B(-1);D(-1);L(2);
X    }
X    else{ ; } /* all edges in proper place */
X  }
X
X  else if(Right(7) == RIGHT || Bottom(3) == RIGHT){
X    /* bottom(5) ok */
X    if(Front(7) == BACK || Bottom(1) == BACK){
X      /* bottom(1) belongs in bottom(7) */
X      /* A solution(1 to 7 to 3 to 1) */
X      L(2);D(1);B(-1);F(1);L(2);B(1);F(-1);D(1);L(2);
X    }
X    else if(Back(7) == FRONT || Bottom(7) == FRONT){
X      /* bottom(7) belongs in bottom(1) */
X      /* B solution(7 to 1 to 3 to 7) */
X      L(2);D(-1);B(-1);F(1);L(2);B(1);F(-1);D(-1);L(2);
X    }
X    else{ ; } /* all edges in proper place */
X  }
X  
X  else if(Back(7) == BACK || Bottom(3) == BACK){
X    /* bottom(7) ok */
X    if(Right(7) == LEFT || Bottom(5) == LEFT){
X      /* bottom(5) belongs in bottom(3) */
X      /* A solution(5 to 3 to 1 to 5) */
X      F(2);D(1);L(-1);R(1);F(2);L(1);R(-1);D(1);F(2);
X    }
X    else if(Left(7) == RIGHT || Bottom(3) == RIGHT){
X      /* bottom(3) belongs in bottom(5) */
X      /* B solution(3 to 5 to 1 to 3) */
X      F(2);D(-1);L(-1);R(1);F(2);L(1);R(-1);D(-1);F(2);
X    }
X    else{ ; } /* all edges in proper place */
X  }
X
X  else{
X    /* There are no edges in their proper place. */
X    if(Front(7) == LEFT || Bottom(1) == LEFT){
X      /* bottom(1) belongs in bottom(3) */
X      /* D solution(1 to 3; 3 to 1; 5 to 7; 7 to 5) */
X      F(1);L(1);D(1);L(-1);D(-1);F(2);R(-1);D(-1);R(1);D(1);F(1);
X    }
X    else if(Front(7) == BACK || Bottom(7) == BACK){
X      /* bottom(1) belongs in bottom(7) */
X      /* C solution(1 to 7; 7 to 1; 3 to 5; 5 to 3) */
X      R(2);L(2);U(1);R(2);L(2);D(2);R(2);L(2);U(1);R(2);L(2);
X    }
X    else if(Front(7) == RIGHT || Bottom(5) == RIGHT){
X      /* bottom(1) belongs in bottom(5) */
X      /* D solution(1 to 5; 5 to 1; 3 to 7; 7 to 3) */
X      R(1);F(1);D(1);F(-1);D(-1);R(2);B(-1);D(-1);B(1);D(1);R(1);
X    }
X    else{
X      printf("ERROR: layer3 error...");
X    }
X  }
X
X}
END_OF_FILE
  if test 12224 -ne `wc -c <'cube/layer3.c'`; then
    echo shar: \"'cube/layer3.c'\" unpacked with wrong size!
  fi
  # end of 'cube/layer3.c'
fi
if test -f 'cube/ldfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/ldfile.c'\"
else
  echo shar: Extracting \"'cube/ldfile.c'\" \(5589 characters\)
  sed "s/^X//" >'cube/ldfile.c' <<'END_OF_FILE'
X/* ldfile.c
X   This is the callback for the load_file_button.
X   Files loaded contain a sequence of cube moves that result
X   in some desired pattern.
X   Buvos Kocka (Hungarian Magic Cube). 
X       
X
XThe following references were used:
X   "The X Window System Programming And Applications with Xt
X   OSF/MOTIF EDITION"
X   by Douglas A Young 
X   Prentice-Hall, 1990.
X   ISBN 0-13-642786-3
X
X   "Mastering Rubik's Cube"
X   by Don Taylor
X   An Owl Book; Holt, Rinehart and Winston, New York, 1980
X   ISBN 0-03-059941-5
X
X-------------------------------------------------------------------
XCopyright (C) 1993 by Pierre A. Fleurant
XPermission is granted to copy and distribute this program
Xwithout charge, provided this copyright notice is included
Xin the copy.
XThis Software is distributed on an as-is basis. There will be
XABSOLUTELY NO WARRANTY for any part of this software to work
Xcorrect. In no case will the author be liable to you for damages
Xcaused by the usage of this software.
X-------------------------------------------------------------------
X*/   
X
X#include "ldfile.h"
X
XXtCallbackProc fileProc;
X
Xvoid FileNamePopUp();
Xvoid okFileNameCallback();
Xvoid cancelFileNameCallback();
Xvoid FileNameAction();
Xvoid ld_sequence_file();
Xvoid displayMessage();
X
Xextern Widget         saved_w;
Xextern widget_data    *saved_wdata;
Xextern caddr_t        saved_call_data;
Xextern int            number_moves;
X
Xextern void F(); /*  front  */
Xextern void L(); /*  left   */
Xextern void R(); /*  right  */
Xextern void B(); /*  back   */
Xextern void U(); /*  up     */
Xextern void D(); /*  down   */
X
X
Xvoid ldfile(w,wdata,call_data)
X     Widget   w;
X     widget_data *wdata;
X     caddr_t  call_data;
X{
X  /* Save 'em in a global so we don't have to pass 'em 
X   * around all the time.
X   */
X  saved_w = w;
X  saved_wdata = wdata;
X  saved_call_data = call_data;
X  number_moves = 1;
X
X  FileNamePopUp("Init filename", ld_sequence_file, w, wdata);
X  
X}
X
Xvoid ld_sequence_file(filename)
X     char* filename;
X{
X  char *tptr, *t1ptr, line[MSG_SIZ], buf[MSG_SIZ], function;
X  Arg args[1];
X  FILE *fp;
X  int i, j, parameter;
X
X
X  
X  if (filename[0] == '/')
X    strcpy(buf, filename);
X  else {
X    strcpy(buf, "./");
X    strcat(buf, filename);
X  }
X  
X  if ((fp = fopen(buf, "r")) == NULL) {
X    strcpy(line, buf);
X    sprintf(buf,"Can't open %s", line);
X    displayMessage(buf);
X    return;
X  }else{
X    sprintf(line,"\nSequence filename: %s\n",buf);
X    displayMessage(line);
X  }
X  
X  /*
X   * check if file is empty
X   */
X  if(!fgets(line, MSG_SIZ, fp)){
X    /* NULL pointer is returned if eof */
X    sprintf(buf,"file is empty");
X    displayMessage(buf);
X    fclose(fp);
X    return;
X  }
X  do {
X    /* skip comments */
X    if(*line == '!')
X      continue;
X    /* use tptr because it will get incremented */
X    tptr = line;
X
X      /* parse function commands */
X      while(sscanf(tptr, "%1s(%d);", &function, &parameter) == 2){
X	/* execute it */
X	switch(function){
X	case 'F':
X	  F(parameter);
X	  break;
X	case 'L':
X	  L(parameter);
X	  break;
X	case 'R':
X	  R(parameter);
X	  break;
X	case 'B':
X	  B(parameter);
X	  break;
X	case 'U':
X	  U(parameter);
X	  break;
X	case 'D':
X	  D(parameter);
X	  break;
X	default:
X	  sprintf(buf,"file has incorrect syntax");
X	  displayMessage(buf);
X	  fclose(fp);
X	  return;
X	}      
X	/* point to next command */
X	if(!(t1ptr = strchr(tptr,';')))
X	  break;
X	tptr = t1ptr + 1;
X      }
X    
X  }while (fgets(line, MSG_SIZ, fp)); /* while not eof */
X  
X  /* close shop */
X  fclose(fp);
X  
X}
X
Xvoid displayMessage(msg)
X     char* msg;
X{
X  printf("%s\n", msg);
X}
X
X/************************************************************************/
X/** The following is generic stuff for File list popUp windows         **/
X/************************************************************************/
X
X/* The following is a generic routine to popUp a file list for loading. */
Xvoid FileNamePopUp(label, proc, theParent, wdata)
X     char *label;
X     void (*proc)();
X     Widget theParent;
X     widget_data *wdata;
X{
X  Arg args[4];
X  Widget popup, dialog;
X  Position x, y;
X  Dimension bw_width, pw_width;
X  int n;
X  
X  fileProc = (XtCallbackProc) proc;
X  
X  popup = XtCreatePopupShell("ldfile_popup",
X			     transientShellWidgetClass, theParent, NULL, 0);
X  
X  n=0;
X  XtSetArg(args[n], XtNheight, DIALOG_SIZE);n++;
X  XtSetArg(args[n], XtNwidth, DIALOG_SIZE);n++;
X  dialog = XmCreateFileSelectionDialog(popup,label,
X				       args, n);
X  
X  /* Unmanage the help button */
X  XtUnmanageChild(XmFileSelectionBoxGetChild(dialog,
X					     XmDIALOG_HELP_BUTTON));
X  
X  XtManageChild(dialog);
X  
X  XtAddCallback(dialog, XmNokCallback, okFileNameCallback, (XtPointer) dialog);
X  XtAddCallback(dialog, XmNcancelCallback, cancelFileNameCallback, (XtPointer) dialog);
X  
X  XtRealizeWidget(dialog);
X  
X  XtSetKeyboardFocus(dialog, popup);
X}
X
X
Xvoid okFileNameCallback(w, client_data, call_data)
X     Widget w;
X     XtPointer client_data, call_data;
X{
X  FileNameAction(w, NULL);
X}
X
Xvoid cancelFileNameCallback(w, client_data, call_data)
X     Widget w;
X     XtPointer client_data, call_data;
X{
X  XtDestroyWidget(w);
X}
X
Xvoid FileNameAction(w, event)
X     Widget w;
X     XEvent *event;
X{
X  char buf[MSG_SIZ];
X  String name;
X  int n;
X  XmString compoundString;
X  Arg args[1];
X  
X  
X  n=0;
X  XtSetArg(args[n], XmNtextString, &compoundString);n++;
X  XtGetValues(w, args, n);
X  name = xs_get_string_from_xmstring(compoundString);
X  XtDestroyWidget(w);
X  
X  if ((name != NULL) && (*name != '\0')) {
X    strcpy(buf, name);
X    (*fileProc)(buf);	 /* I can't see a way not to use a global here [from xboard stuff] */
X    return;
X  }
X  
X}
END_OF_FILE
  if test 5589 -ne `wc -c <'cube/ldfile.c'`; then
    echo shar: \"'cube/ldfile.c'\" unpacked with wrong size!
  fi
  # end of 'cube/ldfile.c'
fi
if test -f 'cube/ldfile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/ldfile.h'\"
else
  echo shar: Extracting \"'cube/ldfile.h'\" \(1242 characters\)
  sed "s/^X//" >'cube/ldfile.h' <<'END_OF_FILE'
X/* ldfile.h
X   Header file for ldfile.c 
X   Buvos Kocka (Hungarian Magic Cube). 
X
X
XThe following references were used:
X   "The X Window System Programming And Applications with Xt
X   OSF/MOTIF EDITION"
X   by Douglas A Young 
X   Prentice-Hall, 1990.
X   ISBN 0-13-642786-3
X
X   "Mastering Rubik's Cube"
X   by Don Taylor
X   An Owl Book; Holt, Rinehart and Winston, New York, 1980
X   ISBN 0-03-059941-5
X
X-------------------------------------------------------------------
XCopyright (C) 1993 by Pierre A. Fleurant
XPermission is granted to copy and distribute this program
Xwithout charge, provided this copyright notice is included
Xin the copy.
XThis Software is distributed on an as-is basis. There will be
XABSOLUTELY NO WARRANTY for any part of this software to work
Xcorrect. In no case will the author be liable to you for damages
Xcaused by the usage of this software.
X-------------------------------------------------------------------
X*/   
X
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h> 
X#include <X11/Shell.h>
X#include <Xm/Xm.h>
X#include <Xm/DialogS.h>
X#include <Xm/FileSB.h> 
X
X#include "common.h"
X#include "libXs.h"
X#include <stdio.h>
X
X#define DIALOG_SIZE			325
X#define DIALOG_X			325
X#define DIALOG_Y			325
X#define MSG_SIZ				256
X
X
END_OF_FILE
  if test 1242 -ne `wc -c <'cube/ldfile.h'`; then
    echo shar: \"'cube/ldfile.h'\" unpacked with wrong size!
  fi
  # end of 'cube/ldfile.h'
fi
if test -f 'cube/lib/menus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/lib/menus.c'\"
else
  echo shar: Extracting \"'cube/lib/menus.c'\" \(7132 characters\)
  sed "s/^X//" >'cube/lib/menus.c' <<'END_OF_FILE'
X/*********************************************************
X * menus.c: Simple menu package
X *         From:
X *                   The X Window System, 
X *            Programming and Applications with Xt
X *                   OSF/Motif Edition
X *         by
X *                Douglas Young
X *              Prentice Hall, 1990
X *
X *                 Example described on pages:  104-106
X *
X *
X *  Copyright 1989 by Prentice Hall
X *  All Rights Reserved
X *
X * This code is based on the OSF/Motif widget set and the X Window System
X *
X * Permission to use, copy, modify, and distribute this software for 
X * any purpose and without fee is hereby granted, provided that the above
X * copyright notice appear in all copies and that both the copyright notice
X * and this permission notice appear in supporting documentation.
X *
X * Prentice Hall and the author disclaim all warranties with regard to 
X * this software, including all implied warranties of merchantability and fitness.
X * In no event shall Prentice Hall or the author be liable for any special,
X * indirect or cosequential damages or any damages whatsoever resulting from 
X * loss of use, data or profits, whether in an action of contract, negligence 
X * or other tortious action, arising out of or in connection with the use 
X * or performance of this software.
X *
X * Open Software Foundation is a trademark of The Open Software Foundation, Inc.
X * OSF is a trademark of Open Software Foundation, Inc.
X * OSF/Motif is a trademark of Open Software Foundation, Inc.
X * Motif is a trademark of Open Software Foundation, Inc.
X * DEC is a registered trademark of Digital Equipment Corporation
X * HP is a registered trademark of the Hewlett Packard Company
X * DIGITAL is a registered trademark of Digital Equipment Corporation
X * X Window System is a trademark of the Massachusetts Institute of Technology
X **********************************************************************************/
X
X#include <Xm/BulletinB.h>
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h>
X#include <Xm/Xm.h>
X#include <Xm/Separator.h>
X#include <Xm/PushB.h>
X#include <Xm/CascadeB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Label.h>
X#include "libXs.h"
X
Xxs_create_menu_buttons(title, menu, menulist, nitems)
X     char           *title;
X     Widget          menu;
X     xs_menu_struct *menulist;
X     int             nitems;
X{
X  Arg        wargs[1];
X  int        i;
X  WidgetList buttons;
X  int        separators = 0;
X  /*
X   * Allocate a widget list to hold all 
X   * button widgets.
X   */
X  buttons = (WidgetList) XtMalloc(nitems * sizeof(Widget));
X  /*
X   * If a title is given, create Label and Separator widgets.
X   */
X  if(title){
X    XtCreateManagedWidget(title, xmLabelWidgetClass, menu,
X                          NULL, 0);
X    XtCreateManagedWidget("separator", xmSeparatorWidgetClass, menu, NULL, 0);
X  }
X  /*
X   * Create an entry for each item in the menu.
X   */
X  for(i=0;i<nitems;i++){
X    /* 
X     * A NULL name represents a separator.
X     */
X    if(menulist[i].name == NULL){ 
X      XtCreateManagedWidget("separator", xmSeparatorWidgetClass, menu, NULL, 0);
X      separators++; /* Count how many entries aren't buttons */
X    }
X    /*
X     * If there is a name and a callback, create a "normal"
X     * menu entry and register the callback function.
X     */
X    else if(menulist[i].func){
X      buttons[i-separators] = XtCreateWidget(menulist[i].name, xmPushButtonWidgetClass,menu, NULL, 0);
X      XtAddCallback(buttons[i-separators], XmNactivateCallback,
X		    menulist[i].func, menulist[i].data);
X    }
X    /*
X     * If there is a name, but no callback function, the entry
X     * must be a label, unless there is a submenu.
X     */
X    else if(!menulist[i].sub_menu)
X      buttons[i-separators] = XtCreateWidget(menulist[i].name,
X					     xmLabelWidgetClass,
X					     menu, NULL, 0);
X    /*
X     * If we got here, the entry must be a submenu.
X     * Create a pulldown menu pane and an XmCascadeButton
X     * widget. Attach the menu pane and make a recursive call
X     * to create the entries in the submenu.
X     */
X    else{  
X      Widget sub_menu;
X      sub_menu =XmCreatePulldownMenu(menu,
X				     menulist[i].sub_menu_title,
X				     NULL, 0);
X      XtSetArg(wargs[0], XmNsubMenuId, sub_menu);
X      buttons[i-separators] =
X	XtCreateWidget(menulist[i].name,
X		       xmCascadeButtonWidgetClass,
X		       menu, wargs, 1);
X      xs_create_menu_buttons(menulist[i].sub_menu_title,
X			     sub_menu, menulist[i].sub_menu,
X			     menulist[i].n_sub_items);
X    }
X  } 
X  /*
X   * Manage all button widgets. Menu panes are not managed.
X   */
X  XtManageChildren(buttons, nitems - separators);
X}
X
Xxss_create_menu_buttons(title, menu, menulist, nitems, auxdata)
X     char           *title;
X     Widget          menu;
X     xs_menu_struct *menulist;
X     int             nitems;
X     caddr_t         auxdata;
X{
X  Arg        wargs[1];
X  int        i;
X  WidgetList buttons;
X  int        separators = 0;
X  /*
X   * Allocate a widget list to hold all 
X   * button widgets.
X   */
X  buttons = (WidgetList) XtMalloc(nitems * sizeof(Widget));
X  /*
X   * If a title is given, create Label and Separator widgets.
X   */
X  if(title){
X    XtCreateManagedWidget(title, xmLabelWidgetClass, menu,
X                          NULL, 0);
X    XtCreateManagedWidget("separator", xmSeparatorWidgetClass, menu, NULL, 0);
X  }
X  /*
X   * Create an entry for each item in the menu.
X   */
X  for(i=0;i<nitems;i++){
X    /* 
X     * A NULL name represents a separator.
X     */
X    if(menulist[i].name == NULL){ 
X      XtCreateManagedWidget("separator", xmSeparatorWidgetClass, menu, NULL, 0);
X      separators++; /* Count how many entries aren't buttons */
X    }
X    /*
X     * If there is a name and a callback, create a "normal"
X     * menu entry and register the callback function.
X     */
X    else if(menulist[i].func){
X      buttons[i-separators] = XtCreateWidget(menulist[i].name, xmPushButtonWidgetClass,menu, NULL, 0);
X      XtAddCallback(buttons[i-separators], XmNactivateCallback,
X		    menulist[i].func, auxdata);
X    }
X    /*
X     * If there is a name, but no callback function, the entry
X     * must be a label, unless there is a submenu.
X     */
X    else if(!menulist[i].sub_menu)
X      buttons[i-separators] = XtCreateWidget(menulist[i].name,
X					     xmLabelWidgetClass,
X					     menu, NULL, 0);
X    /*
X     * If we got here, the entry must be a submenu.
X     * Create a pulldown menu pane and an XmCascadeButton
X     * widget. Attach the menu pane and make a recursive call
X     * to create the entries in the submenu.
X     */
X    else{  
X      Widget sub_menu;
X      sub_menu =XmCreatePulldownMenu(menu,
X				     menulist[i].sub_menu_title,
X				     NULL, 0);
X      XtSetArg(wargs[0], XmNsubMenuId, sub_menu);
X      buttons[i-separators] =
X	XtCreateWidget(menulist[i].name,
X		       xmCascadeButtonWidgetClass,
X		       menu, wargs, 1);
X      xss_create_menu_buttons(menulist[i].sub_menu_title,
X			      sub_menu, menulist[i].sub_menu,
X			      menulist[i].n_sub_items,auxdata);
X    }
X  } 
X  /*
X   * Manage all button widgets. Menu panes are not managed.
X   */
X  XtManageChildren(buttons, nitems - separators);
X}
END_OF_FILE
  if test 7132 -ne `wc -c <'cube/lib/menus.c'`; then
    echo shar: \"'cube/lib/menus.c'\" unpacked with wrong size!
  fi
  # end of 'cube/lib/menus.c'
fi
if test -f 'cube/lib/pix_buttons.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cube/lib/pix_buttons.c'\"
else
  echo shar: Extracting \"'cube/lib/pix_buttons.c'\" \(9237 characters\)
  sed "s/^X//" >'cube/lib/pix_buttons.c' <<'END_OF_FILE'
X/*
X      pixmap_browser functions
X   and ... label_wbutton (label with button) function.
X   
X           From:
X                     The X Window System, 
X              Programming and Applications with Xt
X                     OSF/Motif Edition
X           by
X                  Douglas Young
X                Prentice Hall, 1990
X  
X                   Example described on pages:  200-202
X  
X  
X    Copyright 1989 by Prentice Hall
X    All Rights Reserved
X  
X   This code is based on the OSF/Motif widget set and the X Window System
X  
X   Permission to use, copy, modify, and distribute this software for 
X   any purpose and without fee is hereby granted, provided that the above
X   copyright notice appear in all copies and that both the copyright notice
X   and this permission notice appear in supporting documentation.
X  
X   Prentice Hall and the author disclaim all warranties with regard to 
X   this software, including all implied warranties of merchantability and fitness.
X   In no event shall Prentice Hall or the author be liable for any special,
X   indirect or cosequential damages or any damages whatsoever resulting from 
X   loss of use, data or profits, whether in an action of contract, negligence 
X   or other tortious action, arising out of or in connection with the use 
X   or performance of this software.
X  
X   Open Software Foundation is a trademark of The Open Software Foundation, Inc.
X   OSF is a trademark of Open Software Foundation, Inc.
X   OSF/Motif is a trademark of Open Software Foundation, Inc.
X   Motif is a trademark of Open Software Foundation, Inc.
X   DEC is a registered trademark of Digital Equipment Corporation
X   HP is a registered trademark of the Hewlett Packard Company
X   DIGITAL is a registered trademark of Digital Equipment Corporation
X   X Window System is a trademark of the Massachusetts Institute of Technology
X*/
X#include <X11/StringDefs.h>
X#include <X11/Intrinsic.h> 
X#include <Xm/Xm.h>
X#include <Xm/ToggleB.h>
X#include <Xm/RowColumn.h>
X#include "libXs.h"
X
X
XWidget xs_create_pixmap_browser (parent,tiles,n_tiles,callback,data)
X     Widget     parent;       /* widget to manage the browser */
X     char      *tiles[];      /* list of tile names           */
X     int        n_tiles;      /* how many tiles               */
X     void      (*callback)(); /* invoked when state changes   */
X     caddr_t    data;         /* data to be passed to callback*/
X{
X  Widget     browser;
X  WidgetList buttons;
X  int        i;
X  Arg        wargs[10];
X  /*
X   * Malloc room for button widgets.
X   */
X  buttons = (WidgetList) XtMalloc(n_tiles * sizeof(Widget));
X  /*
X   * Create a "RadioBox" RowColumn widget.
X   */
X  XtSetArg(wargs[0], XmNentryClass, xmToggleButtonWidgetClass);
X  browser = XmCreateRadioBox(parent, "browser", wargs, 1);
X  /*
X   * Create a button for each tile. If a callback function
X   * has been given, register it as an XmNvalueChangedCallback
X   */
X  for(i=0;i< n_tiles;i++){
X    buttons[i] = xs_create_pixmap_button(browser, tiles[i]);
X    if(callback)
X      XtAddCallback(buttons[i], XmNvalueChangedCallback, 
X		    callback, data);
X  }
X  /*
X   * Manage all buttons and return the RadioBox widget, which
X   * is still unmanaged
X   */ 
X  XtManageChildren(buttons, n_tiles);
X  return browser;
X}
X
XWidget xss_create_label_wbutton(parent,names,n_names,callback,data)
X     Widget     parent;       /* widget to manage the browser */
X     char      *names[];      /* list of names                */
X     int        n_names;      /* number of names              */
X     void      (*callback)(); /* invoked when state changes   */
X     caddr_t    data;         /* data to be passed to callback*/
X{
X  Widget     panel;
X  WidgetList buttons;
X  int        i;
X  Arg        wargs[10];
X  /*
X   * Malloc room for button widgets.
X   */
X  buttons = (WidgetList) XtMalloc(n_names * sizeof(Widget));
X  /*
X   * Create a "RadioBox" RowColumn widget.
X   */
X  XtSetArg(wargs[0], XmNentryClass, xmToggleButtonWidgetClass);
X  panel = XmCreateRadioBox(parent, "panel", wargs, 1);
X  /*
X   * Create a button for each name If a callback function
X   * has been given, register it as an XmNvalueChangedCallback
X   */
X  for(i=0;i< n_names;i++){
X    buttons[i] = xss_create_label_button(panel, names[i], (Cardinal)i);
X    if(callback)
X      XtAddCallback(buttons[i], XmNvalueChangedCallback, 
X		    callback, data);
X  }
X  /*
X   * Manage all buttons and return the RadioBox widget, which
X   * is still unmanaged
X   */ 
X  XtManageChildren(buttons, n_names);
X  return panel;
X}
X
XWidget xs_create_pixmap_button(parent, pattern)
X     Widget         parent;
X     char *         pattern;
X{
X  Pixmap   tile;
X  Widget   button;
X  Arg      wargs[10];
X  Pixel    foreground, background;
X  int      n;
X  
X  button = XtCreateWidget(pattern, xmToggleButtonWidgetClass,
X			  parent, NULL, 0);
X  /*
X   * Retrieve the colors of the widget.
X   */
X  n = 0;
X  XtSetArg(wargs[n], XtNforeground, &foreground);n++;
X  XtSetArg(wargs[n], XtNbackground, &background);n++;
X  XtGetValues(button, wargs, n);
X  /*
X   * Get a tile corresponding the given pattern.
X   */
X  tile = XmGetPixmap (XtScreen(button),  pattern,
X		      foreground, background);
X  /*
X   * Display the pixmap in the button and also store it
X   * so it can be retrieved from the button later.
X   */
X  n = 0;
X  XtSetArg(wargs[n], XmNlabelType,   XmPIXMAP); n++;
X  XtSetArg(wargs[n], XmNlabelPixmap, tile); n++;
X  XtSetArg(wargs[n], XmNuserData,    tile); n++;
X  XtSetValues(button, wargs, n);
X  /*
X   * Return the unmanaged button.
X   */
X  return button;
X}
X
XWidget xss_create_label_button(parent, name, side_number)
X     Widget   parent;
X     char     *name;
X     Cardinal side_number;
X{
X  Widget   button;
X  Arg      wargs[10];
X  int      n;
X  XmString   xmstr;
X  
X  button = XtCreateWidget(name, xmToggleButtonWidgetClass,
X			  parent, NULL, 0);
X  /*
X   * Display the name in the button and also store it
X   * so it can be retrieved from the button later.
X   */
X
X  /* Convert name to a compound string. */
X
X  xmstr = XmStringCreate(name, XmSTRING_DEFAULT_CHARSET);
X
X  n = 0;
X  XtSetArg(wargs[n], XmNlabelString, xmstr); n++;
X  XtSetArg(wargs[n], XmNuserData, side_number); n++;
X  XtSetValues(button, wargs, n);
X
X  /*
X   * Return the unmanaged button.
X   */
X  return button;
X}
X
Xxs_register_pattern(w, name, bits, width, height)
X     Widget         w;
X     char          *name;
X     unsigned char *bits;
X     int            width, height;
X{
X  XImage *image;
X  image = XCreateImage(XtDisplay(w),
X		       DefaultVisualOfScreen(XtScreen(w)), 
X		       1, XYBitmap, 0, 
X		       bits, width, height, 8, 2);
X  XmInstallImage(image, name);
X}
X
XWidget xss_create_pixmap_browser(parent,tiles,n_tiles,callback,data)
X     Widget     parent;       /* widget to manage the browser */
X     char      *tiles[];      /* list of tile names           */
X     int        n_tiles;      /* how many tiles               */
X     void      (*callback)(); /* invoked when state changes   */
X     caddr_t    data;         /* data to be passed to callback*/
X{
X  Widget     browser;
X  WidgetList buttons;
X  int        i;
X  Arg        wargs[10];
X  /*
X   * Malloc room for button widgets.
X   */
X  buttons = (WidgetList) XtMalloc(n_tiles * sizeof(Widget));
X  /*
X   * Create a "RadioBox" RowColumn widget.
X   */
X  XtSetArg(wargs[0], XmNentryClass, xmToggleButtonWidgetClass);
X  browser = XmCreateRadioBox(parent, "browser", wargs, 1);
X  /*
X   * Create a button for each tile. If a callback function
X   * has been given, register it as an XmNvalueChangedCallback
X   */
X  for(i=0; i< n_tiles; i++){
X    buttons[i] = xss_create_pixmap_button(browser, tiles[i],i);
X    if(callback)
X      XtAddCallback(buttons[i], XmNvalueChangedCallback, 
X		    callback, data);
X  }
X  /*
X   * Manage all buttons and return the RadioBox widget, which
X   * is still unmanaged
X   */ 
X  XtManageChildren(buttons, n_tiles);
X  return browser;
X}
X
XWidget xss_create_pixmap_button(parent, pattern,i)
X     Widget         parent;
X     char          *pattern;
X     int           i;   /* button number */
X{
X  Pixmap   tile;
X  Widget   button;
X  Arg      wargs[10];
X  int      n;
X  
X  button = XtCreateWidget(pattern, xmToggleButtonWidgetClass,parent, NULL, 0);
X  /*
X   * Get a tile corresponding the given pattern.
X   */
X  tile = XmGetPixmap (XtScreen(button),  pattern,
X		      xss_get_pixel_by_name(parent, pattern),
X		      xss_get_pixel_by_name(parent, pattern));
X  /*
X   * Display the pixmap in the button and also store it
X   * so it can be retrieved from the button later.
X   */
X  n = 0;
X  XtSetArg(wargs[n], XmNlabelType,   XmPIXMAP); n++;
X  XtSetArg(wargs[n], XmNlabelPixmap, tile);     n++;
X  XtSetArg(wargs[n], XmNuserData,    i);        n++; /* button number */
X  XtSetValues(button, wargs, n);
X  /*
X   * Return the unmanaged button.
X   */
X  return button;
X}
X
XPixel xss_get_pixel_by_name(w, colorname)
X     Widget w;
X     char  *colorname;
X{
X  Display *dpy  = XtDisplay(w);
X  int      scr  = DefaultScreen(dpy);
X  Colormap cmap = DefaultColormap(dpy, scr);
X  XColor   color, ignore;
X  /* 
X   * Allocate the named color.
X   */
X  if(XAllocNamedColor(dpy, cmap, colorname, &color, &ignore))
X    return (color.pixel);
X  else{
X    printf("Warning: Couldn't allocate color %s\n", colorname);
X    return (BlackPixel(dpy, scr));
X  }
X}
END_OF_FILE
  if test 9237 -ne `wc -c <'cube/lib/pix_buttons.c'`; then
    echo shar: \"'cube/lib/pix_buttons.c'\" unpacked with wrong size!
  fi
  # end of 'cube/lib/pix_buttons.c'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
