Newsgroups: comp.sources.misc
From: anita@bouw.tno.nl (Anita Eijs)
Subject: v37i037:  linkedlist - Generic Linked List Package, Part02/02
Message-ID: <1993May4.154424.18359@sparky.imd.sterling.com>
X-Md4-Signature: ebc7dadad33c1bcd5d63c0214cea86f0
Date: Tue, 4 May 1993 15:44:24 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: anita@bouw.tno.nl (Anita Eijs)
Posting-number: Volume 37, Issue 37
Archive-name: linkedlist/part02
Environment: UNIX, MS-DOS, VAX/VMS, Macintosh
Supersedes: linkedlist: Volume 30, Issue 22

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  CHANGES Doc/Intro.3 Doc/lDef.3 Doc/lDel.3 Doc/lDelAll.3
#   Doc/lDelIndxNode.3 Doc/lDelNode.3 Doc/lDump.3 Doc/lFndFlagNode.3
#   Doc/lFndNode.3 Doc/lGetIndxNode.3 Doc/lGetNode.3 Doc/lInfo.3
#   Doc/lInfoIndxNode.3 Doc/lInfoNode.3 Doc/lInsNode.3 Doc/lSort.3
#   Doc/lUndump.3 Doc/lUpdIndxNode.3 Doc/lUpdNode.3 Makefile.BCC
#   Tools_makerule example.c list.h sorttest.c
# Wrapped by kent@sparky on Tue May  4 10:37:10 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(381 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XMost important changes from version 0.7 to version 0.8 :
X
X-	Routine lIndxNode is renamed to lGetIndxNode.
X
X-	Routine lFlagNode is renamed to lFndFlagNode.
X	The parameter where is added to find several nodes matching the
X	requested flag.
X
X-	Some routines added : lDelIndxNode, lInfoIndxNode, lUpdIndxNode,
X	lSort.
X
X-	Defines are made more specific; FIRST is renamed to lFIRST, etc.
END_OF_FILE
  if test 381 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'Doc/Intro.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/Intro.3'\"
else
  echo shar: Extracting \"'Doc/Intro.3'\" \(7888 characters\)
  sed "s/^X//" >'Doc/Intro.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "Intro"
X.IX Intro
X.SH NAME
XIntro - Introduction to the Generic Linked List.
X.SH DESCRIPTION
XThe Generic Linked List package is a package to define, create, update,
Xquery and delete one or more (nodes of) linked lists, to sort linked
Xlists, and so on. The user doesn't have to take care of allocating a
Xnumber of bytes for a node, inserting on the right place, deleting and
Xfreeing a node and so on.
X.br
XDifferent kind of linked lists can be defined. In a \fIsingly\fP linked
Xlist each node points to the next node, in a \fIdoubly\fP linked list
Xeach node points also to the previous node. A \fIchain\fP is a list in
Xwhich the last node has a NULL-pointer and in a \fIcircular\fP linked
Xlist the last node points back to the first node.
X.br
XThe package consists of the following routines :
X.nf
X.if t .ta 0.2i 1.3i
X	lDef	define linked list
X	lInfo	get information about linked list
X	lSort	sort linked list
X	lDel	delete linked list
X	lDelAll	delete all linked lists
X	lDump	dump a linked list to a file
X	lUndump	undump a linked list from a file
X	lInsNode	insert node
X	lInfoNode	get information about node
X	lGetNode	get node
X	lFndNode	find node
X	lFndFlagNode	find node by flag
X	lUpdNode	update current node
X	lDelNode	delete node
X	lInfoIndxNode	get information about node by index
X	lGetIndxNode	get node by index
X	lUpdIndxNode	update node by index
X	lDelIndxNode	delete node by index
X.fi
X.SH ERROR CODES
X.if t .ta 0.2i 1.8i
XHere follows an enumeration of the possible error codes, and their
Xmeanings. For each function-call is specified which error codes
Xcould be expected. The marked errors (*) will also be written to
Xthe error-file \fI=listError=\fP.
X.nf
X	lEMPTY_LIST	linked list doesn't contain any nodes
X	lEOL	end of list reached
X	lNO_LIST	there are no linked lists defined (*)
X	lNOT_DOUBLY	backward searching / retrieving not possible for
X		singly linked list (*)
X	lNOT_FOUND	node not found
X	lOPEN_ERROR	can't open linked list dump file for writing or
X		reading (*)
X	lSIZE_NE	size of expected data and size of node are not
X		equal (*)
X	lUNKNOWN_FUNC	function name is unknown (*)
X	lUNKNOWN_ID	list identifier is unknown (*)
X	lWRONG_CC	parameter \fIcc\fP has wrong value (*)
X	lWRONG_INDEX	index out of range (*)
X	lWRONG_ORDER	parameter \fIorder\fP has wrong value (*)
X	lWRONG_SD	parameter \fIsd\fP has wrong value (*)
X	lWRONG_THEORY	parameter \fItheory\fP has wrong value (*)
X	lWRONG_WHERE	parameter \fIwhere\fP has wrong value (*)
X	lWRONG_WHICH	parameter \fIwhich\fP has wrong value (*)
X.fi
X.SH LIBRARY
X$(TOOLS_HOME)/Lib/list.a
X.SH INCLUDE FILE
X$(TOOLS_HOME)/List/list.h
X.SH PORTABILITY
XThe Generic Linked List package is a very portable tool. The tool is
Xdeveloped on UNIX and ported to MSDOS, VAX-VMS and Macintosh. On
Xthose 'ported' machines the library isn't created, but list.c and list.h
Xwere treated the same as all the other source-files (*.[ch]) of the
Xprogram, which used the Generic Linked List package.
X.SH EXAMPLE
X.if t .ta 0.3i 0.6i 0.9i 1.2i 2.2i 3.2i 4.2i 4.5i 4.8i
X.nf
X#include		<stdio.h>
X#include		"list.h"
X
Xtypedef struct rapport {
X	char		title[30];
X	char		author[15];
X	int		date;
X} Rapport;
Xint	rapSz = sizeof(Rapport);
X
Xstatic void	insRap(), prRapAll(), prRap();
Xstatic int		search(), compare();
X
Xmain()
X{
X	int			id, code, search_date;
X	Rapport		rap;
X
X	id = lDef(lSINGLY, lCHAIN);
X
X	insRap(id, lFIRST, 1, "Book 1", "People", 890129);
X	insRap(id, lFIRST, 2, "Book 2", "More People", 890130);
X	insRap(id, lLAST, 1, "Book 3", "Lots of People", 890131);
X
X	fprintf(stdout, "lGetNode\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lGetIndxNode\n");
X	code = lGetIndxNode(id, 4, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, -1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 3, &rap, rapSz);
X	prRap(code, &rap);
X
X	fprintf(stdout, "lFndNode\n");
X	search_date = 890129;
X	code = lFndNode(id, lFIRST, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X
X	code = lDump(id, "dump");
X	fprintf(stdout, "lDump : %d\n", code);
X
X	lDel(id);
X
X	id = lUndump("dump");
X	fprintf(stdout, "lUndump : %d\n", id);
X
X	insRap(id, lFIRST, 4, "Book 4", "The Author", 891127);
X
X	prRapAll(id);
X
X	fprintf(stdout, "lFndFlagNode\n");
X	code = lFndFlagNode(id, lFIRST, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lNEXT, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 7, &rap, rapSz);
X	prRap(code, &rap);
X	
X	fprintf(stdout, "Untouched list\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\n");
X	lSort(id, lDESCENDING, lBUBBLE, compare);
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\n");
X	lSort(id, lASCENDING, lHEAP, compare);
X	prRapAll(id);
X
X	lDelAll();
X}
X
Xstatic void
XinsRap(id, where, flag, title, author, date)
Xint	id, where, flag, date;
Xchar	*title, *author;
X{
X	int		code;
X	Rapport	rap;
X
X	strcpy(rap.title, title);
X	strcpy(rap.author, author);
X	rap.date = date;
X	code = lInsNode(id, where, &rap, rapSz, flag);
X}
X
Xstatic void
XprRapAll(id)
Xint	id;
X{
X	int		code;
X	Rapport	rap;
X
X	code = lGetNode(id, lFIRST, &rap, rapSz);
X	prRap(code, &rap);
X	while (code == lFIRST || code == lSUCCESS || code == lLAST) {
X		code = lGetNode(id, lNEXT, &rap, rapSz);
X		prRap(code, &rap);
X	}
X}
X
Xstatic void
XprRap(code, rpprt)
Xint			code;
XRapport		*rpprt;
X{
X	if (code >= 0)
X		fprintf(stdout, "Rapport : '%s' '%s' '%d'\n", rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		fprintf(stdout, "Return code = %d\n", code);
X}
X
Xstatic int
Xsearch(date, rpprt)
Xint			*date;
XRapport		*rpprt;
X{
X	if (rpprt->date > *date)
X		return(lFOUND);
X	else
X		return(lNOT_FOUND);
X}
X
Xstatic int 
Xcompare(data1, data2)
XRapport *data1, *data2;
X{
X	int	k = strcmp(data1->author, data2->author);
X
X	if (k == 0)
X		return(lSAME);	/* key1 == key2 */
X	else if (k > 0)
X		return(l2LT1);	/* key1 > key2 */
X	else if (k < 0)
X		return(l1LT2);	/* key1 < key2 */
X}
X.fi
X.sp 2
XThis example program produces the following output :
X.nf
X	lGetNode
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Return code = -9
X	lGetIndxNode
X	Return code = -13
X	Rapport : 'Book 1' 'People' '890129'
X	Return code = -13
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	lFndNode
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Return code = -10
X	lDump : 0
X	lUndump : 1
X	Rapport : 'Book 4' 'The Author' '891127'
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Return code = -9
X	lFndFlagNode
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Rapport : 'Book 2' 'More People' '890130'
X	Return code = -10
X	Untouched list
X	Rapport : 'Book 4' 'The Author' '891127'
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Return code = -9
X	lSort
X	Rapport : 'Book 4' 'The Author' '891127'
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Return code = -9
X	lSort
X	Rapport : 'Book 3' 'Lots of People' '890131'
X	Rapport : 'Book 2' 'More People' '890130'
X	Rapport : 'Book 1' 'People' '890129'
X	Rapport : 'Book 4' 'The Author' '891127'
X	Return code = -9
X.fi
X.SH VERSION
XGeneric Linked List 0.8, March 1993.
X.SH PUBLIC DOMAIN
XThe Generic Linked List package is in the public domain. If you have
Xany comments, suggestions, or find any bugs, or make any changes you'd
Xlike to share, please let me know.
X.SH AUTHOR
XCopyright (c) 1993 by Anita Eijs (anita@bouw.tno.nl).
X.sp 1
X.nf
XTNO - Bouw - BouwInformatica
XP.O. Box 49
X2600 AA Delft
XThe Netherlands
X.fi
END_OF_FILE
  if test 7888 -ne `wc -c <'Doc/Intro.3'`; then
    echo shar: \"'Doc/Intro.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/Intro.3'
fi
if test -f 'Doc/lDef.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDef.3'\"
else
  echo shar: Extracting \"'Doc/lDef.3'\" \(1033 characters\)
  sed "s/^X//" >'Doc/lDef.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDef"
X.IX lDef
X.SH NAME
XlDef - Define linked list.
X.SH SYNOPSIS
Xint
X.BR "lDef" "(sd, cc)"
X.br
X.RT
X.RP
XIn	int	sd	singly or doubly linked list
X.br
X.RP
XIn	int	cc	chain or circular linked list
X.DT
X.SH DESCRIPTION
XTo define a linked list use \fBlDef\fP. It is possible to define a
Xsingly or doubly linked list and a chain or circular linked list.
XThe routine returns the identifier of the defined linked list (\(>= 1),
Xwhich must be used in the other routines of the linked list tool.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIsd\fP :
X.nf
X	lSINGLY	singly linked list, each node points to the next node
X	lDOUBLY	doubly linked list, each node points to the previous and
X		the next node
X.fi
X\fIcc\fP :
X.nf
X	lCHAIN	chain linked list, last node has a NULL-pointer
X	lCIRCULAR	circular linked list, last node points back to the first node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	identifier of linked list (\(>= 1)
XReturn on error :
X	lWRONG_SD, lWRONG_CC
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1033 -ne `wc -c <'Doc/lDef.3'`; then
    echo shar: \"'Doc/lDef.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDef.3'
fi
if test -f 'Doc/lDel.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDel.3'\"
else
  echo shar: Extracting \"'Doc/lDel.3'\" \(348 characters\)
  sed "s/^X//" >'Doc/lDel.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDel"
X.IX lDel
X.SH NAME
XlDel - Delete linked list.
X.SH SYNOPSIS
Xint
X.BR "lDel" "(id)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.DT
X.SH DESCRIPTION
X\fBlDel\fP deletes a linked list.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 348 -ne `wc -c <'Doc/lDel.3'`; then
    echo shar: \"'Doc/lDel.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDel.3'
fi
if test -f 'Doc/lDelAll.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelAll.3'\"
else
  echo shar: Extracting \"'Doc/lDelAll.3'\" \(322 characters\)
  sed "s/^X//" >'Doc/lDelAll.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelAll"
X.IX lDelAll
X.SH NAME
XlDelAll - Delete all linked lists.
X.SH SYNOPSIS
Xint
X.BR "lDelAll" "()"
X.br
X.DT
X.SH DESCRIPTION
X\fBlDelAll\fP deletes all linked lists.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lNO_LIST
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 322 -ne `wc -c <'Doc/lDelAll.3'`; then
    echo shar: \"'Doc/lDelAll.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelAll.3'
fi
if test -f 'Doc/lDelIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lDelIndxNode.3'\" \(617 characters\)
  sed "s/^X//" >'Doc/lDelIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelIndxNode"
X.IX lDelIndxNode
X.SH NAME
XlDelIndxNode - Delete node by index.
X.SH SYNOPSIS
Xint
X.BR "lDelIndxNode" "(id, index)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	index	index of node which must be deleted
X.DT
X.SH DESCRIPTION
X\fBlDelIndxNode\fP deletes an indexed node from a linked list. Which node
Xmust be deleted can be specified by \fIindex\fP (\(>= 1).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 617 -ne `wc -c <'Doc/lDelIndxNode.3'`; then
    echo shar: \"'Doc/lDelIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelIndxNode.3'
fi
if test -f 'Doc/lDelNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelNode.3'\"
else
  echo shar: Extracting \"'Doc/lDelNode.3'\" \(716 characters\)
  sed "s/^X//" >'Doc/lDelNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelNode"
X.IX lDelNode
X.SH NAME
XlDelNode - Delete node.
X.SH SYNOPSIS
Xint
X.BR "lDelNode" "(id, which)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	which	which node must be deleted
X.DT
X.SH DESCRIPTION
X\fBlDelNode\fP deletes a node from a linked list. Which node must be
Xdeleted can be specified by \fIwhich\fP. The first, the current and
Xthe last node of a linked list can be deleted.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	first node
X	lCURRENT	current node
X	lLAST	last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 716 -ne `wc -c <'Doc/lDelNode.3'`; then
    echo shar: \"'Doc/lDelNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelNode.3'
fi
if test -f 'Doc/lDump.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDump.3'\"
else
  echo shar: Extracting \"'Doc/lDump.3'\" \(793 characters\)
  sed "s/^X//" >'Doc/lDump.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDump"
X.IX lDump
X.SH NAME
XlDump - Dump a linked list to a file.
X.SH SYNOPSIS
Xint
X.BR "lDump" "(id, file)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlDump\fP is a linked list dumping utility. It allows the user to store
Xlinked list data in a specially formatted file, so the linked list data can
Xbe used within another program session. This file can be read by the linked
Xlist undumping utility lUndump.
X.br
XDon't use pointers within your data structure, because only the pointers
Xwill be written in the dump file, not the data pointed to.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lOPEN_ERROR
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 793 -ne `wc -c <'Doc/lDump.3'`; then
    echo shar: \"'Doc/lDump.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDump.3'
fi
if test -f 'Doc/lFndFlagNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFndFlagNode.3'\"
else
  echo shar: Extracting \"'Doc/lFndFlagNode.3'\" \(1307 characters\)
  sed "s/^X//" >'Doc/lFndFlagNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFndFlagNode"
X.IX lFndFlagNode
X.SH NAME
XlFndFlagNode - Get node by flag.
X.SH SYNOPSIS
Xint
X.BR "lFndFlagNode" "(id, from, flag, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	from	from where must be searched
X.br
X.RP
XIn	int	flag	flag of node which must be retrieved
X.br
X.RP
XOut	Byte	*data	data of node
X.br
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFndFlagNode\fP searches a 'flagged' node from the linked list. From
Xwhere the node must be searched can be specified by \fIfrom\fP. A node
Xcan be searched forward from the beginning of the list or from the
Xcurrent node and backward from the current node or from the end of the
Xlist.
X.br
XBackward searching is only possible for doubly linked list.
X.br
XWhen the found node is the first or the last node, the return code will
Xhave the value lFIRST or lLAST, otherwise lFOUND.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIfrom\fP :
X.nf
X	lFIRST	search forward from first node
X	lPREVIOUS	search backward from previous node
X	lNEXT	search forward from next node
X	lLAST	search backward from last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lFOUND, lFIRST, lLAST, lNOT_FOUND
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_FROM, lSIZE_NE
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1307 -ne `wc -c <'Doc/lFndFlagNode.3'`; then
    echo shar: \"'Doc/lFndFlagNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFndFlagNode.3'
fi
if test -f 'Doc/lFndNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFndNode.3'\"
else
  echo shar: Extracting \"'Doc/lFndNode.3'\" \(1730 characters\)
  sed "s/^X//" >'Doc/lFndNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFndNode"
X.IX lFndNode
X.SH NAME
XlFndNode - Find node.
X.SH SYNOPSIS
Xint
X.BR "lFndNode" "(id, from, func, ptr, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	from	from where must be searched
X.br
X.RP
XIn	int	(*func)()	function for checking the data on conditions
X.br
X.RP
XIn	Byte	*ptr	data for comparison in function
X.br
X.RP
XOut	Byte	*data	data of node
X.br
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFndNode\fP searches a node from the linked list, using the user
Xdefined serach function \fIfunc\fP, which checks the data of a node
Xon conditions. This function must have two parameters, a pointer to
Xthe data to compare with and a pointer to the data of a node. The
Xpossible return values are lFOUND or lNOT_FOUND. See the introduction
Xof Generic Linked List for an example of such a search function. From
Xwhere the node must be searched can be specified by \fIfrom\fP. A node
Xcan be searched forward from the beginning of the list or from the
Xcurrent node and backward from the current node or from the end of the
Xlist.
X.br
XBackward searching is only possible for doubly linked list.
X.br
XWhen the found node is the first or the last node, the return code will
Xhave the value lFIRST or lLAST, otherwise lFOUND.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIfrom\fP :
X.nf
X	lFIRST	search forward from first node
X	lPREVIOUS	search backward from previous node
X	lNEXT	search forward from next node
X	lLAST	search backward from last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lFOUND, lFIRST, lLAST, lNOT_FOUND
XReturn on error :
X.fi
X.in +0.2i
XlUNKNOWN_ID, lEMPTY_LIST, lWRONG_FROM, lUNKNOWN_FUNC, lNOT_DOUBLY
X.in 10.2i
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1730 -ne `wc -c <'Doc/lFndNode.3'`; then
    echo shar: \"'Doc/lFndNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFndNode.3'
fi
if test -f 'Doc/lGetIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lGetIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lGetIndxNode.3'\" \(835 characters\)
  sed "s/^X//" >'Doc/lGetIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lGetIndxNode"
X.IX lGetIndxNode
X.SH NAME
XlGetIndxNode - Get node by index.
X.SH SYNOPSIS
Xint
X.BR "lGetIndxNode" "(id, index, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlGetIndxNode\fP gets the data of an indexed node of a linked list. Which
Xnode must be retrieved can be specified by \fIindex\fP (\(>= 1).
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value lFIRST or lLAST. For the other nodes the routine returns
XlSUCCESS.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS, lFIRST, lLAST
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX, lSIZE_NE
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 835 -ne `wc -c <'Doc/lGetIndxNode.3'`; then
    echo shar: \"'Doc/lGetIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lGetIndxNode.3'
fi
if test -f 'Doc/lGetNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lGetNode.3'\"
else
  echo shar: Extracting \"'Doc/lGetNode.3'\" \(1241 characters\)
  sed "s/^X//" >'Doc/lGetNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lGetNode"
X.IX lGetNode
X.SH NAME
XlGetNode - Get node.
X.SH SYNOPSIS
Xint
X.BR "lGetNode" "(id, which, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlGetNode\fP gets the data of a node of a linked list. Which node must
Xbe retrieved can be specified by \fIwhich\fP. The first node, the current
Xnode, the node before or after the current node and the node at the end
Xof the list can be retrieved.
X.br
XBackward retrieving is only possible for doubly linked list. A previous
Xnode can't be retrieved for singly linked lists.
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value lFIRST or lLAST. For the other nodes the routine
Xreturns lSUCCESS.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	first node
X	lPREVIOUS	previous node
X	lCURRENT	current node
X	lNEXT	next node
X	lLAST	last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS, lFIRST, lLAST
XReturn on error :
X.fi
X.in +02.i
XlUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY, lSIZE_NE
X.in -02.i
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1241 -ne `wc -c <'Doc/lGetNode.3'`; then
    echo shar: \"'Doc/lGetNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lGetNode.3'
fi
if test -f 'Doc/lInfo.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfo.3'\"
else
  echo shar: Extracting \"'Doc/lInfo.3'\" \(657 characters\)
  sed "s/^X//" >'Doc/lInfo.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfo"
X.IX lInfo
X.SH NAME
XlInfo - Get information about linked list.
X.SH SYNOPSIS
Xint
X.BR "lInfo" "(id, sd, cc, n)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XOut	int	*sd	singly or doubly linked list
X.RP
XOut	int	*cc	chain or circular linked list
X.RP
XOut	int	*n	number of nodes
X.DT
X.SH DESCRIPTION
X\fBlInfo\fP returns some information about a linked list. The type of
Xthe linked list (\fIsd\fP and \fIcc\fP, defined by the user) and the
Xnumber of nodes added to the linked list (\fIn\fP).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 657 -ne `wc -c <'Doc/lInfo.3'`; then
    echo shar: \"'Doc/lInfo.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfo.3'
fi
if test -f 'Doc/lInfoIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfoIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lInfoIndxNode.3'\" \(837 characters\)
  sed "s/^X//" >'Doc/lInfoIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfoIndxNode"
X.IX lInfoIndxNode
X.SH NAME
XlInfoIndxNode - Get information about node by index.
X.SH SYNOPSIS
Xint
X.BR "lInfoIndxNode" "(id, index, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be inspected
X.RP
XOut	int	*size	size of data of node
X.RP
XOut	int	*flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInfoIndxNode\fP returns some information about an indexed node.
XThe size of the data of the node (\fIsize\fP) and the user information
Xflag (\fIflag\fP). Of which node the information must be given can be
Xspecified by \fIindex\fP (\(>= 1).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 837 -ne `wc -c <'Doc/lInfoIndxNode.3'`; then
    echo shar: \"'Doc/lInfoIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfoIndxNode.3'
fi
if test -f 'Doc/lInfoNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfoNode.3'\"
else
  echo shar: Extracting \"'Doc/lInfoNode.3'\" \(1197 characters\)
  sed "s/^X//" >'Doc/lInfoNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfoNode"
X.IX lInfoNode
X.SH NAME
XlInfoNode - Get information about node.
X.SH SYNOPSIS
Xint
X.BR "lInfoNode" "(id, which, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be inspected
X.RP
XOut	int	*size	size of data of node
X.RP
XOut	int	*flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInfoNode\fP returns some information about a node. The size of
Xthe data of the node (\fIsize\fP) and the user information flag
X(\fIflag\fP). Of which node the information must be given can be
Xspecified by \fIwhich\fP. The first node, the current node, the node
Xbefore or after the current node and the node at the end of the list
Xcan be inspected.
X.br
XBackward retrieving is only possible for doubly linked list. A previous
Xnode can't be inspected for singly linked lists.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	first node
X	lPREVIOUS	previous node
X	lCURRENT	current node
X	lNEXT	next node
X	lLAST	last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X.fi
X.in +0.2i
XlUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY
X.in -0.2i
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1197 -ne `wc -c <'Doc/lInfoNode.3'`; then
    echo shar: \"'Doc/lInfoNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfoNode.3'
fi
if test -f 'Doc/lInsNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInsNode.3'\"
else
  echo shar: Extracting \"'Doc/lInsNode.3'\" \(1074 characters\)
  sed "s/^X//" >'Doc/lInsNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInsNode"
X.IX lInsNode
X.SH NAME
XlInsNode - Insert node.
X.SH SYNOPSIS
Xint
X.BR "lInsNode" "(id, where, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	where	place where node must be inserted
X.RP
XIn	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInsNode\fP inserts a node in a linked list. Where the node must be
Xinserted can be specified by \fIwhere\fP. A node can be added at the
Xfront of the list, before or after the current node and at the end of
Xthe list. For each node a flag can be set by the user, e.g. to identify
Xthe node or the type of node. When the flag identifies the node you can
Xretrieve the nodes by flag (lFndFlagNode).
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhere\fP :
X.nf
X	lFIRST	as first node
X	lBEFORE	before current node
X	lAFTER	after current node
X	lLAST	as last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lWRONG_WHERE
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1074 -ne `wc -c <'Doc/lInsNode.3'`; then
    echo shar: \"'Doc/lInsNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInsNode.3'
fi
if test -f 'Doc/lSort.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lSort.3'\"
else
  echo shar: Extracting \"'Doc/lSort.3'\" \(1293 characters\)
  sed "s/^X//" >'Doc/lSort.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lSort"
X.IX lSort
X.SH NAME
XlSort - Sort a linked list.
X.SH SYNOPSIS
Xint
X.BR "lSort" "(id, order, theory, func)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	order	sorting order
X.RP
XIn	int	theory	sorting theory
X.RP
XIn	int	(*func)()	function for comparing the data of 2 nodes
X.DT
X.SH DESCRIPTION
X\fBlSort\fP sorts a linked list in the specified \fIorder\fP, using
Xthe specified \fItheory\fP, and the user defined function \fIfunc\fP,
Xwhich compares the data of two nodes. This function must have two
Xparameters, two pointers to the data of a node. The possible return
Xvalues are lSAME, l1LT2 and l2LT1. See the introduction of Generic
XLinked List for an example of such a compare function.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIorder\fP :
X.nf
X	lASCENDING	'a', 'b', 'c', ...
X	lDESCENDING	'z', 'y', 'x', ...
X.fi
X\fItheory\fP :
X.nf
X	lBUBBLE	bubble sorting algorithm ...
X	lHEAP	heap sorting algorithm ...
X	lINSERT	insert sorting algorithm ...
X	lQUICK	quick sorting algorithm ...
X	lSELECTION	selection sorting algorithm ...
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_ORDER, lWRONG_THEORY
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 1293 -ne `wc -c <'Doc/lSort.3'`; then
    echo shar: \"'Doc/lSort.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lSort.3'
fi
if test -f 'Doc/lUndump.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUndump.3'\"
else
  echo shar: Extracting \"'Doc/lUndump.3'\" \(810 characters\)
  sed "s/^X//" >'Doc/lUndump.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUndump"
X.IX lUndump
X.SH NAME
XlUndump - Undump a linked list from a file.
X.SH SYNOPSIS
Xint
X.BR "lUndump" "(file)"
X.br
X.RT
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlUndump\fP is a linked list undumping utility. The user will be able to
Xuse linked list data that was saved by lDump in the same or an earlier
Xprogram session. The linked list data was saved in a specially formatted
Xfile by lDump. The routine returns the identifier of the undumped linked
Xlist (\(>= 1), which must be used in the other routines of the linked list
Xtool. This identifier doesn't have to be the same as used by lDump.
X.SH RETURN CODES
X.nf
XReturn on success :
X	identifier of linked list (\(>=1)
XReturn on error :
X	lOPEN_ERROR
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 810 -ne `wc -c <'Doc/lUndump.3'`; then
    echo shar: \"'Doc/lUndump.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUndump.3'
fi
if test -f 'Doc/lUpdIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUpdIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lUpdIndxNode.3'\" \(817 characters\)
  sed "s/^X//" >'Doc/lUpdIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUpdIndxNode"
X.IX lUpdIndxNode
X.SH NAME
XlUpdIndxNode - Update node by index.
X.SH SYNOPSIS
Xint
X.BR "lUpdIndxNode" "(id, index, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be updated
X.RP
XIn	Byte	*data	updated data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	updated user information flag
X.DT
X.SH DESCRIPTION
X\fBlUpdIndxNode\fP updates an indexed node in a linked list, in fact
Xthis routine replaces the data of the indexed node by the data of the
Xupdated node. The flag for user information can also be updated.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 817 -ne `wc -c <'Doc/lUpdIndxNode.3'`; then
    echo shar: \"'Doc/lUpdIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUpdIndxNode.3'
fi
if test -f 'Doc/lUpdNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUpdNode.3'\"
else
  echo shar: Extracting \"'Doc/lUpdNode.3'\" \(677 characters\)
  sed "s/^X//" >'Doc/lUpdNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUpdNode"
X.IX lUpdNode
X.SH NAME
XlUpdNode - Update current node.
X.SH SYNOPSIS
Xint
X.BR "lUpdNode" "(id, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	Byte	*data	updated data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	updated user information flag
X.DT
X.SH DESCRIPTION
X\fBlUpdNode\fP updates the current node in a linked list, in fact
Xthis routine replaces the data of the current node by the data of the
Xupdated node. The flag for user information can also be updated.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 677 -ne `wc -c <'Doc/lUpdNode.3'`; then
    echo shar: \"'Doc/lUpdNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUpdNode.3'
fi
if test -f 'Makefile.BCC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.BCC'\"
else
  echo shar: Extracting \"'Makefile.BCC'\" \(5737 characters\)
  sed "s/^X//" >'Makefile.BCC' <<'END_OF_FILE'
X.AUTODEPEND
X
X#
X# Linked List Tool -- makefile for Borland C++ v3.1
X#
X# Gabe Helou <gabe@angus.mi.org>, September 1992
X#                                                                 
X# This make file has been tested with MS-DOS versions of tar, shar,
X# zip, and lha.
X#
X
XTOOLS_HOME     = c:\usr
XMAKERULE       = Tools_makerule
X
X# Name of current directory
XDIR    = .
X
X# Name of library
XLIB    = $(TOOLS_HOME)\lib
X
X# Name of user include dir
XINC    = $(TOOLS_HOME)\include
X
X# Contents of current directory
XLIST   = Makefile README example.c list.c list.h
X
X#          *Translator Definitions*
X
XCC = bcc +list.CFG
XFLAGS       = -O2 -c
XTASM        = TASM
XTLIB        = tlib
XTLINK       = tlink
XSHAR        = shar -v -c -pXX
X
XLIBPATH     = $(BCDIR)\lib
XINCLUDEPATH = $(BCDIR)\include
X
XTARFILE     = $(TOOLS_HOME)\llistt.tar
XSHARFILE    = $(TOOLS_HOME)\llistt.shr
XZIPFILE     = $(TOOLS_HOME)\llistt.zip
XLHAFILE     = $(TOOLS_HOME)\llistt.lzh
X
X# Doc list for shar
XDOC_1 = Doc/Intro.1    Doc/lDef.1      Doc/lDel.1      Doc/lDelAll.1
XDOC_2 = Doc/lDelNode.1 Doc/lDump.1     Doc/lFlagNode.1 Doc/lFndNode.1
XDOC_3 = Doc/lGetNode.1 Doc/lIndxNode.1 Doc/lInfo.1     Doc/lInfoNode.1
XDOC_4 = Doc/lInsNode.1 Doc/lUndump.1   Doc/lUpdNode.1
X
XDOC_ALL_1 = Doc/Intro.man    Doc/lDef.man      Doc/lDel.man      Doc/lDelAll.man
XDOC_ALL_2 = Doc/lDelNode.man Doc/lDump.man     Doc/lFlagNode.man Doc/lFndNode.man
XDOC_ALL_3 = Doc/lGetNode.man Doc/lIndxNode.man Doc/lInfo.man     Doc/lInfoNode.man
XDOC_ALL_4 = Doc/lInsNode.man Doc/lUndump.man   Doc/lUpdNode.man  
XDOC_ALL_5 = Doc/list_doc.ps
X
X#              *Implicit Rules*
X
X.c.obj:
X  $(CC) $(FLAGS) {$< }
X
X.cpp.obj:
X  $(CC) $(FLAGS) {$< }
X
X
X#              *List Macros*
X
XLIB_dependencies =  \
X  list.obj
X
X
X#              *Targets*
X
Xusge:   usage.msg
X    type usage.msg
X
Xall:      lib
X
Xinstall:  newlib
X
Xclean:
X    del list.obj
X    del list.lib
X    
Xlist.lib: lib
X
Xlib:      list.cfg $(LIB_dependencies)
X    del list.lib
X    $(TLIB) /C /E /e list.lib +list.obj
X
Xnewlib:   list.h list.lib
X    copy list.lib $(LIB)
X    copy list.h   $(INC)
X
Xofiles:   $(LIB_dependencies)
X
Xtest:     example
X
Xexample:  $(LIB)\list.lib example.obj
X        $(CC) -c $(FLAGS) example.c
X        $(TLINK) /v/x/c/P-/L$(LIBPATH);$(LIB) @&&|
Xc0l.obj+
Xexample.obj
Xexample
X       	     	# no map file
Xemu.lib+
Xmathl.lib+
Xlist.lib+
Xcl.lib
X|
X
Xtar:    doc.lst doc_all.lst src.lst
X        echo Making tar-file in $(TARFILE)
X        type doc.lst      >  $$tartmp
X        type doc_all.lst  >> $$tartmp
X        echo $(MAKERULE)  >> $$tartmp
X        type src.lst      >> $$tartmp
X        tar -cvf $(TARFILE) -T $$tartmp
X        del $$tartmp
X
Xshar:
X        echo Making shar-file in $(SHARFILE)
X        $(SHAR) $(MAKERULE) >  $(SHARFILE)
X        $(SHAR) $(LIST)     >> $(SHARFILE)
X        $(SHAR) $(DOC_1)    >> $(SHARFILE)
X        $(SHAR) $(DOC_2)    >> $(SHARFILE)
X        $(SHAR) $(DOC_3)    >> $(SHARFILE)
X        $(SHAR) $(DOC_4)    >> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_1)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_2)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_3)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_4)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_5)>> $(SHARFILE)
X        dos2unix $(SHARFILE)
X
Xshort_shar:
X        echo Making short shar-file in $(SHARFILE)
X        $(SHAR) $(MAKERULE) >  $(SHARFILE)
X        $(SHAR) $(LIST)     >> $(SHARFILE)
X        $(SHAR) $(DOC_1)    >> $(SHARFILE)
X        $(SHAR) $(DOC_2)    >> $(SHARFILE)
X        $(SHAR) $(DOC_3)    >> $(SHARFILE)
X        $(SHAR) $(DOC_4)    >> $(SHARFILE)
X        dos2unix $(SHARFILE)
X
Xzip:    doc.lst doc_all.lst
X        echo Making ZIP-file in $(ZIPFILE)
X        pkzip -ap $(ZIPFILE) $(MAKERULE) $(LIST)
X        pkzip -ap $(ZIPFILE) @doc.lst
X        pkzip -ap $(ZIPFILE) @doc_all.lst
X#                           zip    $(ZIPFILE) $(MAKERULE) $(LIST)
X#        type doc.lst     | zip -@ $(ZIPFILE)
X#        type doc_all.lst | zip -@ $(ZIPFILE)
X
Xlha:    doc.lst doc_all.lst
X        echo Making lha-file in $(LHAFILE)
X        lha a /x1 $(LHAFILE) $(MAKERULE) $(LIST)
X        lha a /x1 $(LHAFILE) @doc.lst
X        lha a /x1 $(LHAFILE) @doc_all.lst
X
Xlist.obj: list.cfg list.c list.h
X
Xusage.msg:  makefile.bcc
X    copy &&|
X
X  Makefile of directory $(DIR)
X
X  Targets are:
X
X     usge         = Prints this
X     lib          = Make objects for LIB
X     newlib       = Make objects and place them in LIB
X     ofiles       = Make objects
X     test/example = Make test program
X     tar          = Make TARFILE
X     shar         = Make SHARFILE
X     zip          = Make ZIPFILE
X     lha          = Make LHAFILE
X
X     all          = same as 'lib'
X     install      = same as 'newlib'
X     clean        = remove object files and temp files
X
X  defaults:
X
X     TARFILE  = $(TARFILE)
X     LIB      = $(LIB)
X     SHARFILE = $(SHARFILE)
X     ZIPFILE  = $(ZIPFILE)
X     LHAFILE  = $(LHAFILE)
X
X| usage.msg
X
X# Documentation
Xdoc.lst:  makefile.bcc
X   copy &&|
XDoc/Intro.1             
XDoc/lDef.1
XDoc/lDel.1
XDoc/lDelAll.1
XDoc/lDelNode.1
XDoc/lDump.1
XDoc/lFlagNode.1
XDoc/lFndNode.1
XDoc/lGetNode.1
XDoc/lIndxNode.1
XDoc/lInfo.1
XDoc/lInfoNode.1
XDoc/lInsNode.1
XDoc/lUndump.1
XDoc/lUpdNode.1
X| doc.lst
X
Xdoc_all.lst:  makefile.bcc
X   copy &&|
XDoc/list_doc.ps
XDoc/Intro.man
XDoc/lDef.man
XDoc/lDel.man
XDoc/lDelAll.man
XDoc/lDelNode.man
XDoc/lDump.man
XDoc/lFlagNode.man
XDoc/lFndNode.man
XDoc/lGetNode.man
XDoc/lIndxNode.man
XDoc/lInfo.man
XDoc/lInfoNode.man
XDoc/lInsNode.man
XDoc/lUndump.man
XDoc/lUpdNode.man
X| doc_all.lst
X
Xsrc.lst:  makefile.bcc
X   copy &&|
XMakefile
XREADME
Xexample.c 
Xlist.c 
Xlist.h
X| src.lst
X
Xlist.cfg: makefile.bcc
X   copy &&|
X-ml
X-v
X-vi-
X-H=list.SYM
X-w-ret
X-w-nci
X-w-inl
X-wamp
X-w-par
X-w-cpt
X-w-dup
X-w-pia
X-w-ill
X-w-sus
X-wstv
X-w-ext
X-w-ias
X-w-ibc
X-w-pre
X-w-nst
X-I$(INCLUDEPATH)
X-L$(LIBPATH)
X-DANSI
X-DMSDOS
X| list.cfg
END_OF_FILE
  if test 5737 -ne `wc -c <'Makefile.BCC'`; then
    echo shar: \"'Makefile.BCC'\" unpacked with wrong size!
  fi
  # end of 'Makefile.BCC'
fi
if test -f 'Tools_makerule' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tools_makerule'\"
else
  echo shar: Extracting \"'Tools_makerule'\" \(827 characters\)
  sed "s/^X//" >'Tools_makerule' <<'END_OF_FILE'
XTARFILE		= /tmp/Tools$(DIR).tar
XSHARFILE	= /tmp/Tools$(DIR).shar
XAR		= ar
X# RANLIB should be :
X# echo :	IRIX System V Release 3.3.1, Silicon Graphics, Inc.
X# ranlib :	Sun Sparc2 SunOS, Berkeley UNIX
X#	(AE, Dec 91)
X#RANLIB		= echo "Ready with"
XRANLIB		= ranlib
XCOFLAGS		= -q
XCFLAGS		= -O
X
X# Set defaults for macro's
XECHO		= echo $(INDNTTN)
XARG_INDNTTN	= INDNTTN="$(INDNTTN)'	'"
X
X# Help macro
XUSAGE_ID	= "Makefile of directory $(DIR)"
XUSAGE_TARGETS	= "Targets are:"
XUSAGE_USAGE	= "usage		= Prints this"
XUSAGE_LIB	= "lib		= Make objects for LIB"
XUSAGE_NEWLIB	= "newlib		= Make objects and place them in LIB"
XUSAGE_OFILES	= "ofiles		= Make objects"
XUSAGE_TEST	= "test/example	= Make test program"
XUSAGE_TAR	= "tar		= Make TARFILE"
XUSAGE_DEFLTS1	= "defaults:"
XUSAGE_DEFLTS2	= "	TARFILE = $(TARFILE)"
XUSAGE_DEFLTS3	= "	LIB = $(LIB)"
END_OF_FILE
  if test 827 -ne `wc -c <'Tools_makerule'`; then
    echo shar: \"'Tools_makerule'\" unpacked with wrong size!
  fi
  # end of 'Tools_makerule'
fi
if test -f 'example.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example.c'\"
else
  echo shar: Extracting \"'example.c'\" \(3052 characters\)
  sed "s/^X//" >'example.c' <<'END_OF_FILE'
X#include		<stdio.h>
X#include		"list.h"
X
Xtypedef struct rapport {
X	char		title[30];
X	char		author[15];
X	int		date;
X} Rapport;
Xint	rapSz = sizeof(Rapport);
X
Xstatic void	insRap(), prRapAll(), prRap();
Xstatic int		search(), compare();
X
Xmain()
X{
X	int			id, code, search_date;
X	Rapport		rap;
X
X	id = lDef(lSINGLY, lCHAIN);
X
X	insRap(id, lFIRST, 1, "Book 1", "People", 890129);
X	insRap(id, lFIRST, 2, "Book 2", "More People", 890130);
X	insRap(id, lLAST, 1, "Book 3", "Lots of People", 890131);
X
X	fprintf(stdout, "lGetNode\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lGetIndxNode\n");
X	code = lGetIndxNode(id, 4, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, -1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 3, &rap, rapSz);
X	prRap(code, &rap);
X
X	fprintf(stdout, "lFndNode\n");
X	search_date = 890129;
X	code = lFndNode(id, lFIRST, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X
X	code = lDump(id, "dump");
X	fprintf(stdout, "lDump : %d\n", code);
X
X	lDel(id);
X
X	id = lUndump("dump");
X	fprintf(stdout, "lUndump : %d\n", id);
X
X	insRap(id, lFIRST, 4, "Book 4", "The Author", 891127);
X
X	prRapAll(id);
X
X	fprintf(stdout, "lFndFlagNode\n");
X	code = lFndFlagNode(id, lFIRST, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lNEXT, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 7, &rap, rapSz);
X	prRap(code, &rap);
X	
X	fprintf(stdout, "Untouched list\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\n");
X	lSort(id, lDESCENDING, lBUBBLE, compare);
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\n");
X	lSort(id, lASCENDING, lHEAP, compare);
X	prRapAll(id);
X
X	lDelAll();
X}
X
Xstatic void
XinsRap(id, where, flag, title, author, date)
Xint	id, where, flag, date;
Xchar	*title, *author;
X{
X	int		code;
X	Rapport	rap;
X
X	strcpy(rap.title, title);
X	strcpy(rap.author, author);
X	rap.date = date;
X	code = lInsNode(id, where, &rap, rapSz, flag);
X}
X
Xstatic void
XprRapAll(id)
Xint	id;
X{
X	int		code;
X	Rapport	rap;
X
X	code = lGetNode(id, lFIRST, &rap, rapSz);
X	prRap(code, &rap);
X	while (code == lFIRST || code == lSUCCESS || code == lLAST) {
X		code = lGetNode(id, lNEXT, &rap, rapSz);
X		prRap(code, &rap);
X	}
X}
X
Xstatic void
XprRap(code, rpprt)
Xint			code;
XRapport		*rpprt;
X{
X	if (code >= 0)
X		fprintf(stdout, "Rapport : '%s' '%s' '%d'\n", rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		fprintf(stdout, "Return code = %d\n", code);
X}
X
Xstatic int
Xsearch(date, rpprt)
Xint			*date;
XRapport		*rpprt;
X{
X	if (rpprt->date > *date)
X		return(lFOUND);
X	else
X		return(lNOT_FOUND);
X}
X
Xstatic int 
Xcompare(data1, data2)
XRapport *data1, *data2;
X{
X	int	k = strcmp(data1->author, data2->author);
X
X	if (k == 0)
X		return(lSAME);	/* key1 == key2 */
X	else if (k > 0)
X		return(l2LT1);	/* key1 > key2 */
X	else if (k < 0)
X		return(l1LT2);	/* key1 < key2 */
X}
END_OF_FILE
  if test 3052 -ne `wc -c <'example.c'`; then
    echo shar: \"'example.c'\" unpacked with wrong size!
  fi
  # end of 'example.c'
fi
if test -f 'list.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list.h'\"
else
  echo shar: Extracting \"'list.h'\" \(3467 characters\)
  sed "s/^X//" >'list.h' <<'END_OF_FILE'
X#define	lBUBBLE		1	/* bubble sorting algorithm */
X#define	lHEAP		2	/* heap sorting algorithm */
X#define	lINSERT		3	/* insert sorting algorithm */
X#define	lQUICK		4	/* quick sorting algorithm */
X#define	lSELECTION	5	/* selection sorting algorithm */
X
X/* Sorting defines by shane.s.brath@uwrf.edu */
X#define lASCENDING 1
X#define lDESCENDING -1
X
X#define	lSAME		1	/* compared nodes are the same */
X#define	l1LT2		2	/* first node is less than second node */
X#define	l2LT1		3	/* second node is less than first node */
X
X#define	lSUCCESS	0	/* function call ended successfully */
X
X#define	lSINGLY		1	/* singly linked list */
X#define	lDOUBLY		2	/* doubly linked list */
X#define	lCHAIN		3	/* chain linked list */
X#define	lCIRCULAR	4	/* circular linked list */
X
X#define	lFIRST		1	/* add at front of list */
X				/* get/find/delete first node */
X#define	lPREVIOUS	2	/* get/find previous node */
X#define	lBEFORE		3	/* add before current node */
X#define	lCURRENT	4	/* get/delete current node */
X#define	lAFTER		5	/* add after current node */
X#define	lNEXT		6	/* get/find next node */
X#define	lLAST		7	/* add at end of list */
X				/* get/find/delete last node */
X
X#define	lONE_NODE	10	/* add first node to list / delete last node */
X
X#define	lWRONG_SD	-1	/* parameter 'sd' has wrong value */
X#define	lWRONG_CC	-2	/* parameter 'cc' has wrong value */
X#define	lWRONG_WHERE	-3	/* parameter 'where' has wrong value */
X#define	lWRONG_WHICH	-4	/* parameter 'which' has wrong value */
X#define	lUNKNOWN_ID	-5	/* list id is unknown */
X#define	lUNKNOWN_FUNC	-6	/* function name is unknown */
X#define	lNO_LIST	-7	/* there are no lists defined */
X#define	lEMPTY_LIST	-8	/* list is empty */
X#define	lEOL		-9	/* end of list reached */
X#define	lNOT_FOUND	-10	/* node not found */
X#define	lNOT_DOUBLY	-11	/* list is not doubly linked */
X#define	lSIZE_NE	-12	/* size of expected data and node not equal */
X#define	lWRONG_INDEX	-13	/* 'index' out of range */
X#define	lOPEN_ERROR	-14	/* can't open dump-file */
X#define	lWRONG_ORDER	-15	/* parameter 'order' has wrong value */
X#define	lWRONG_THEORY	-16	/* parameter 'theory' has wrong value */
X
X#define	lFOUND		0	/* node found */
X
X#ifdef MSDOS_OR_VAXC
X#define	lERROR_FILE	"linklist.err"
X#else
X#define	lERROR_FILE	"=listError="
X#endif
X
X#ifdef ANSI
Xtypedef	int		(*Func)();
Xtypedef	unsigned char	Byte;
Xint lDef(int sd, int cc);
Xint lInfo(int id, int *sd, int *cc, int *n);
Xint lSort(int id, int order, int theory, Func func);
Xint lDump(int id, char *file);
Xint lUndump(char *file);
Xint lDel(int id);
Xint lDelAll(void);
Xint lInsNode(int id, int where, Byte *data, int size, int flag);
Xint lInfoNode(int id, int which, int *size, int *flag);
Xint lGetNode(int id, int which, Byte *data, int size);
Xint lFndNode(int id, int where, Func func, Byte *ptr, Byte *data, int size);
Xint lFndFlagNode(int id, int where, int flag, Byte *data, int size);
Xint lUpdNode(int id, Byte *data, int size, int flag);
Xint lDelNode(int id, int which);
Xint lInfoIndxNode(int id, int index, int *size, int *flag);
Xint lGetIndxNode(int id, int index, Byte *data, int size);
Xint lUpdIndxNode(int id, int index, Byte *data, int size, int flag);
Xint lDelIndxNode(int id, int index);
X#else
Xint lDef();
Xint lInfo();
Xint lSort();
Xint lDump();
Xint lUndump();
Xint lDel();
Xint lDelAll();
Xint lInsNode();
Xint lInfoNode();
Xint lGetNode();
Xint lFndNode();
Xint lFndFlagNode();
Xint lUpdNode();
Xint lDelNode();
Xint lInfoIndxNode();
Xint lGetIndxNode();
Xint lUpdIndxNode();
Xint lDelIndxNode();
X#endif
END_OF_FILE
  if test 3467 -ne `wc -c <'list.h'`; then
    echo shar: \"'list.h'\" unpacked with wrong size!
  fi
  # end of 'list.h'
fi
if test -f 'sorttest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sorttest.c'\"
else
  echo shar: Extracting \"'sorttest.c'\" \(7365 characters\)
  sed "s/^X//" >'sorttest.c' <<'END_OF_FILE'
X/* Sort torture test */
X
X#include	<stdio.h>
X#include	<string.h>
X#include	"list.h"
X#include	"time.h"
X
Xtypedef struct catalog {
X	char		number[35];
X	char		title[40];
X	char		author[35];
X	int		date;
X} catalog;
X
Xstatic int	compare_author();
Xstatic int	compare_title();
Xstatic void	load_it();
Xstatic void	print_some();
Xstatic time_t	what_time();
Xstatic void	prRap();
X
X#ifdef ANSI
Xstatic int
Xcompare_author(catalog *a, catalog *b)
X#else
Xstatic int
Xcompare_author(a, b)
Xcatalog *a, *b;
X#endif
X{
X	int	k;
X
X	k = strcmp(a->author, b->author);
X
X	if (k == 0)
X		return(lSAME);
X	else if (k > 0)
X		return(l2LT1);
X	else if (k < 0)
X		return(l1LT2);
X}
X
X#ifdef ANSI
Xstatic int
Xcompare_title(catalog *a, catalog *b, int order)
X#else
Xstatic int
Xcompare_title(a, b, order)
Xcatalog *a, *b;
Xint order;
X#endif
X{
X	int	k;
X
X	k = strcmp(a->title, b->title);
X
X	if (k == 0)
X		return(lSAME);
X	else if (k > 0)
X		return(l2LT1);
X	else if (k < 0)
X		return(l1LT2);
X}
X
X#ifdef ANSI
Xstatic void
Xload_it(int id, int num)
X#else
Xstatic void
Xload_it(id, num)
Xint id;
Xint num;
X#endif
X{
X	int	loop, size = sizeof(catalog), code;
X	char	c1, c2, c3, c4, c5, c6, c7, c8;
X	catalog	rap;
X
X	c1 = c2 = c3 = c4 = c5 = c6 = c7 = 'A';
X	c7--;
X	for (loop=1; loop<=num; loop++) {
X		c7++;
X
X		if (c7>'Z') {c7 = 'A'; c6++;}
X		if (c6>'Z') {c6 = 'A'; c5++;}
X		if (c5>'Z') {c5 = 'A'; c4++;}
X		if (c4>'Z') {c4 = 'A'; c3++;}
X		if (c3>'Z') {c3 = 'A'; c2++;}
X		if (c2>'Z') {c2 = 'A'; c1++;}
X		if (c1>'Z') {c1 = 'A'; c1 = c2 = c3 = c4 = c5 = c6 = c7 = 'A';}
X
X		sprintf(rap.number,"B-90-%d", loop);
X		sprintf(rap.title, "Book %d", loop);
X		sprintf(rap.author,"%c%c%c%c%c%c%c%d",
X			c1, c2, c3, c4, c5, c6, c7, loop);
X		rap.date = 890129;
X		code = lInsNode(id, lLAST, &rap, size, loop);
X	}
X	/* printf("Linked List created\n"); */
X}
X
X#ifdef ANSI
Xstatic void
Xprint_some(int id, int num)
X#else
Xstatic void
Xprint_some(id, num)
Xint id;
Xint num;
X#endif
X{
X	int	size = sizeof(catalog), loop;
X	int	code;
X	catalog	rap;
X
X	code = lGetNode(id, lFIRST, &rap, size);
X	prRap(code, &rap);
X
X	for (loop=2; loop<=num; loop++) {
X		code = lGetNode(id, lNEXT, &rap, size);
X		prRap(code, &rap);
X	}
X}
X
X#ifdef ANSI
Xstatic time_t what_time(void)
X#else
Xstatic time_t what_time()
X#endif
X{
X	return((time_t)time(NULL));
X}
X
X#ifdef ANSI
Xstatic void diff_time(time_t a, time_t b)
X#else
Xstatic void diff_time(a, b)
Xtime_t a, b;
X#endif
X{
X	struct tm	*tt;
X	char		buf1[101], buf2[101];
X	int		hour[2], min[2], sec[2];
X	time_t		x;
X
X	tt = (struct tm *)malloc(sizeof(struct tm *) + 1);
X
X	tt = (struct tm *)localtime(&a);
X	strftime(buf1, 100, "%H %M %S", tt);
X
X	tt = (struct tm *)localtime(&b);
X	strftime(buf2, 100, "%H %M %S", tt);
X
X	sscanf(buf1,"%d %d %d", &hour[0], &min[0], &sec[0]);
X	sscanf(buf2,"%d %d %d", &hour[1], &min[1], &sec[1]);
X
X	printf("Hours = %d  Mins = %d  Secs = %d\n",
X	(hour[1] - hour[0] > 0)?(hour[1] - hour[0]) : (hour[0] - hour[1]),
X	(min[1] - min[0] > 0)?(min[1] - min[0]) : (min[0] - min[1]),
X	(sec[1] - sec[0] > 0)?(sec[1] - sec[0]) : (sec[0] - sec[1]));
X}
X
Xmain()
X{
X	int	size = sizeof(catalog);
X	int	id, code;
X	time_t	start, finish;
X	catalog	rap;
X
X	/* Quick sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("-- lQuickSort --\nlQuickSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lQUICK, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lQUICK, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort DESCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lQUICK, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lQUICK, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* Heap sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf(" -- lHeapSort -- \nlHeapSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lHEAP, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lHeapSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lHEAP, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lHeapSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lHEAP, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* Selection sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lSelectionSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lSELECTION, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lSelectionSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lSELECTION, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lSelectionSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lSELECTION, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* insertion sort*/
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lInsertSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lINSERT, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lInsertSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lINSERT, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lInsertSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lINSERT, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	/* Bubble sort */
X	printf("lBubbleSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lBUBBLE, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lBubbleSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lBUBBLE, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lBubbleSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lBUBBLE, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X}
X
Xstatic void
XprRap(code, rpprt)
Xint			code;
Xcatalog		*rpprt;
X{
X	if (code >= 0)
X		printf("catalog :'%s' '%s' '%s' '%d'\n", rpprt->number, rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		printf("Return code = %d\n", code);
X}
END_OF_FILE
  if test 7365 -ne `wc -c <'sorttest.c'`; then
    echo shar: \"'sorttest.c'\" unpacked with wrong size!
  fi
  # end of 'sorttest.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
