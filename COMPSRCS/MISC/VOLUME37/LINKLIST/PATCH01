Newsgroups: comp.sources.misc
From: anita@bouw.tno.nl (Anita Eijs)
Subject: v37i088:  linkedlist - Generic Linked List Package, Patch01
Message-ID: <1993May29.174307.16758@sparky.imd.sterling.com>
X-Md4-Signature: d59fd7cbaf8f6a1cca7f46574d0627ec
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sat, 29 May 1993 17:43:07 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: anita@bouw.tno.nl (Anita Eijs)
Posting-number: Volume 37, Issue 88
Archive-name: linkedlist/patch01
Environment: UNIX, MS-DOS, VAX/VMS, Macintosh, Amiga
Patch-To: linkedlist: Volume 37, Issue 36-37

Below is the patch for the Generic Linked List Package. This
brings the Generic Linked List Package from version 0.8 to
version 0.9.  Apply with 'patch -p < patch1'.

The sources of the Generic Linked List Package 0.9 are also
available as shar file (linkedlist0.9.shar) in the FTP archive
of TNO (ftp.tno.nl or hermes.bouw.tno.nl) in the directory
/pub/TNO/BOUW/Bouwinf.

The Generic Linked List Package is a package to define, create,
update, query and delete one or more (nodes of) linked lists,
to sort linked lists, and so on. The user doesn't have to take
care of allocating a number of bytes for a node, inserting on
the right place, deleting and freeing a node and so on.

		Anita

	+--------------------------------------------------------+
	| TNO - BOUW, PO-box 49, 2600 AA  Delft, The Netherlands |
	| FAX : +31 15 122182         E-MAIL : anita@bouw.tno.nl |
	+--------------------------------------------------------+

---------- cut here : linkedlist - patch1 --------------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile.Amiga ReadMe.Amiga ReadMe.BCC patch1
# Wrapped by kent@sparky on Sat May 29 12:36:47 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'Makefile.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.Amiga'\"
else
  echo shar: Extracting \"'Makefile.Amiga'\" \(1085 characters\)
  sed "s/^X//" >'Makefile.Amiga' <<'END_OF_FILE'
X# Generic Linked List
X#
X# Anita Eijs, TNO-BOUW, BouwInformatica, September 1989
X# Amiga Port By James Diffendaffer, May 1993
X# SAS 6.0 Makefile
X
XCC	= sc
XASM	= asm
XLINK	= slink
XSTARTUP	= lib:c.o
X#MYLIBS	= 
XCFLAGS	= streq strmer nominc nostkchk ansi noicons \
X	DEF=ANSI DEF=AMIGA IGN=88 IGN=304
XAFLAGS	= -iInclude:
XLFLAGS	= BATCH SC ND
X# DEFINE ___main=___tinymain
X
XAPP		= example
XHFL		= list.h
XCFILES	= example.c sorted.c sorttest.c list.c
XOFILES	= example.o sorted.o sorttest.o list.o
XHFILES	= list.h
X
Xexample:	example.o list.o sorted sorttest Makefile.Amiga
X	$(LINK) FROM $(STARTUP) example.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO example ${LFLAGS}
Xsorted:	sorted.o list.o Makefile.Amiga
X	$(LINK) FROM $(STARTUP) sorted.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO sorted ${LFLAGS}
Xsorttest:	sorttest.o list.o Makefile.Amiga
X	$(LINK) FROM $(STARTUP) sorttest.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO sorttest ${LFLAGS}
X
Xexample.o:
X	$(CC) $(CFLAGS) example.c
X
Xsorted.o:
X	$(CC) $(CFLAGS) sorted.c
X
Xsorttest.o:
X	$(CC) $(CFLAGS) sorttest.c
X
Xlist.o:
X	$(CC) $(CFLAGS) list.c
END_OF_FILE
  if test 1085 -ne `wc -c <'Makefile.Amiga'`; then
    echo shar: \"'Makefile.Amiga'\" unpacked with wrong size!
  fi
  # end of 'Makefile.Amiga'
fi
if test -f 'ReadMe.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe.Amiga'\"
else
  echo shar: Extracting \"'ReadMe.Amiga'\" \(662 characters\)
  sed "s/^X//" >'ReadMe.Amiga' <<'END_OF_FILE'
XThe included makefile for the Amiga is for SAS C 6.0,
Xif you have something else you'll have to modify it.
XBTW, this was a quick-n-dirty makefile, so don't yell
Xat me if you don't like the way it's set up.
XI only put in a couple hours on it (max), don't expect
Xperfection... it works.
XThe makefile does not build a link library.
X
XJust type "smake -f Makefile.Amiga" to build the
Xexamples.
X
XDon't add the time optimization flag "OPT OPTTIME" to
Xthe CFLAGS line of Makefile.Amiga, because this option
Xcauses some problems with the HEAP sorting algorithm.
X
XIf you have questions regarding the Amiga port, you can
Xsend email to:
X
XJames Diffendaffer
Xslwjt@cc.usu.edu
END_OF_FILE
  if test 662 -ne `wc -c <'ReadMe.Amiga'`; then
    echo shar: \"'ReadMe.Amiga'\" unpacked with wrong size!
  fi
  # end of 'ReadMe.Amiga'
fi
if test -f 'ReadMe.BCC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe.BCC'\"
else
  echo shar: Extracting \"'ReadMe.BCC'\" \(614 characters\)
  sed "s/^X//" >'ReadMe.BCC' <<'END_OF_FILE'
XThe makefile for Borland C++ v3.1 is made by Gabe Helou
X(gabe@angus.mi.org). If you have any questions regarding
Xthis port, don't ask me, but send mail to Gabe.
X
XShane S. Brath (shane.s.brath@uwrf.edu) suggested to add
Xthe following line to the top of list.c on one line :
X
X#pragma option -ml -v -vi- -w-ret -w-nci -w-inl -wamp -w-par -w-cpt -w-dup -w-pia -w-ill -w-sus -wstv -w-ext -w-ias -w-ibc -w-pre -w-nst -A -G -O2 -w-sus -w-aus -w-par -w-pro -w-rvl
X
XThe addition of the pragma line was meant for Borland and
Xother MSDOS C compilers. The Microsoft C compiler (5.10)
Xgives a warning on this line.
X
XAnita Eijs
END_OF_FILE
  if test 614 -ne `wc -c <'ReadMe.BCC'`; then
    echo shar: \"'ReadMe.BCC'\" unpacked with wrong size!
  fi
  # end of 'ReadMe.BCC'
fi
if test -f 'patch1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch1'\"
else
  echo shar: Extracting \"'patch1'\" \(50341 characters\)
  sed "s/^X//" >'patch1' <<'END_OF_FILE'
X*** ../CHANGES	Wed May 19 15:57:55 1993
X--- CHANGES	Wed May 19 15:39:41 1993
X***************
X*** 1,5 ****
X! Most important changes from version 0.7 to version 0.8 :
X  
X  -	Routine lIndxNode is renamed to lGetIndxNode.
X  
X  -	Routine lFlagNode is renamed to lFndFlagNode.
X--- 1,16 ----
X! Most important changes from version 0.8 to version 0.9 (May 1993) :
X  
X+ -	Bug solved in the heap sorting algorithm.
X+ 
X+ -	Ported to Amiga by James Diffendaffer.
X+ 
X+ -	Some additional porting solutions for Borland and other MSDOS C
X+ 	compilers by Shane Brath).
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.7 to version 0.8 (March 1993) :
X+ 
X  -	Routine lIndxNode is renamed to lGetIndxNode.
X  
X  -	Routine lFlagNode is renamed to lFndFlagNode.
X***************
X*** 10,12 ****
X--- 21,67 ----
X  	lSort.
X  
X  -	Defines are made more specific; FIRST is renamed to lFIRST, etc.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.6 to version 0.7 (March 1992) :
X+ 
X+ -	Ported to Macintosh by Vincent van Gentevoort.
X+ 
X+ -	New routine 'lFlagNode'.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.5 to version 0.6 (December 1991) :
X+ 
X+ -	Ported to VAX/VMS by Anita Eijs & Rene Balkenende.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.4 to version 0.5  (February 1991) :
X+ 
X+ -	Return type for each routine.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.3 to version 0.4 (November 1990) :
X+ 
X+ -	New routines 'lDump' and 'lUndump'.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.2 to version 0.3 (September 1990) :
X+ 
X+ -	New routine 'lError'.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Most important changes from version 0.1 to version 0.2 (April 1990) :
X+ 
X+ -	New routine 'lIndxNode'.
X+ 
X+ --------------------------------------------------------------------------------
X+ 
X+ Version 0.1 (May 1989) :
X+ 
X+ -	Created by Anita Eijs, TNO-BOUW, BouwInformatica.
X*** ../README	Mon May  3 12:58:56 1993
X--- README	Tue May 25 15:23:21 1993
X***************
X*** 2,8 ****
X  				===================
X  
X  
X! The distribution of the Generic Linked List package (Version 0.8, May 1993)
X  includes the following files:
X  
X  	Doc/Intro.3		- [nt]roff manual pages
X--- 2,8 ----
X  				===================
X  
X  
X! The distribution of the Generic Linked List package (Version 0.9, May 1993)
X  includes the following files:
X  
X  	Doc/Intro.3		- [nt]roff manual pages
X***************
X*** 26,31 ****
X--- 26,34 ----
X  	Doc/lUpdNode.3
X  	Makefile		- Berkeley or System V Makefile
X  	Makefile.BCC		- Borland C++ v3.1 Makefile
X+ 	ReadMe.BCC		- some additional info about Borland port
X+ 	Makefile.Amiga		- Amiga SAS C 6.0 Makefile
X+ 	ReadMe.Amiga		- some additional info about Amiga port
X  	README			- this file !
X  	CHANGES			- list of changes
X  	Tools_makerule		- make rules for Makefile
X***************
X*** 43,51 ****
X  
X  2)	Check the environment settings (RANLIB) in the Tools_makerule.
X  
X! 3)	Enter 'make newlib' at the UNIX prompt.
X  
X! 4)	Enter 'make test' or 'make example' to create the executable of
X  	the program 'example' at the UNIX prompt.
X  
X  
X--- 46,56 ----
X  
X  2)	Check the environment settings (RANLIB) in the Tools_makerule.
X  
X! 3)	Be sure that the LIB-directory is created.
X  
X! 4)	Enter 'make newlib' at the UNIX prompt.
X! 
X! 5)	Enter 'make test' or 'make example' to create the executable of
X  	the program 'example' at the UNIX prompt.
X  
X  
X***************
X*** 55,63 ****
X  
X  
X  The Generic Linked List is in the public domain. It is available at our FTP
X! archive (ftp.tno.nl or hermes.bouw.tno.nl), just retrieve te files :
X! 	/pub/TNO/BOUW/Bouwinf/linkedlist_0.8.README
X! 	/pub/TNO/BOUW/Bouwinf/linkedlist_0.8.shar
X  
X  
X  If you have any comments, suggestions, or find any bugs, or make any changes
X--- 60,68 ----
X  
X  
X  The Generic Linked List is in the public domain. It is available at our FTP
X! archive (ftp.tno.nl or hermes.bouw.tno.nl), just retrieve the files :
X! 	/pub/TNO/BOUW/Bouwinf/linkedlist_0.9.README
X! 	/pub/TNO/BOUW/Bouwinf/linkedlist_0.9.shar
X  
X  
X  If you have any comments, suggestions, or find any bugs, or make any changes
X***************
X*** 69,72 ****
X  P.O. Box 49
X  2600 AA Delft
X  The Netherlands
X! FAX : +31 15 843990
X--- 74,77 ----
X  P.O. Box 49
X  2600 AA Delft
X  The Netherlands
X! FAX : +31 15 122182
X*** ../example.c	Fri Feb 26 09:04:13 1993
X--- example.c	Fri May 21 09:58:14 1993
X***************
X*** 1,3 ****
X--- 1,7 ----
X+ #ifdef	AMIGA
X+ #include		<string.h>
X+ #endif
X+ 
X  #include		<stdio.h>
X  #include		"list.h"
X  
X***************
X*** 8,16 ****
X  } Rapport;
X  int	rapSz = sizeof(Rapport);
X  
X  static void	insRap(), prRapAll(), prRap();
X! static int		search(), compare();
X  
X  main()
X  {
X  	int			id, code, search_date;
X--- 12,30 ----
X  } Rapport;
X  int	rapSz = sizeof(Rapport);
X  
X+ #ifdef ANSI
X+ static void	insRap(int id, int where, int flag, char *title, char *author,
X+ 				int date);
X+ static void	prRapAll(int id);
X+ static void	prRap(int code, Rapport *rpprt);
X+ static int	search(int *date, Rapport *rpprt);
X+ static int	compare(Rapport *data1, Rapport *data2);
X+ #else
X  static void	insRap(), prRapAll(), prRap();
X! static int	search(), compare();
X! #endif
X  
X+ int
X  main()
X  {
X  	int			id, code, search_date;
X***************
X*** 82,89 ****
X  
X  static void
X  insRap(id, where, flag, title, author, date)
X! int	id, where, flag, date;
X! char	*title, *author;
X  {
X  	int		code;
X  	Rapport	rap;
X--- 96,103 ----
X  
X  static void
X  insRap(id, where, flag, title, author, date)
X! int		id, where, flag, date;
X! char		*title, *author;
X  {
X  	int		code;
X  	Rapport	rap;
X*** ../list.c	Mon May  3 11:08:59 1993
X--- list.c	Wed May 19 16:38:34 1993
X***************
X*** 1,3 ****
X--- 1,6 ----
X+ #pragma option -ml -v -vi- -w-ret -w-nci -w-inl -wamp -w-par -w-cpt -w-dup -w-pia -w-ill -w-sus -wstv -w-ext -w-ias -w-ibc -w-pre -w-nst -A -G -O2 -w-sus -w-aus -w-par -w-pro -w-rvl
X+ /* line at the top added for Borland or other MSDOS C compilers */
X+ 
X  /*
X  **	Anita Eijs	TNO-BOUW, BouwInformatica	May 1989
X  **
X***************
X*** 41,72 ****
X  **	***** Version 0.8, May 1993 *****
X  */
X  
X! #ifdef MAC
X! #define	MAC_OR_VAXC
X  #endif
X! #ifdef VAXC
X! #define	MAC_OR_VAXC
X! #define	MSDOS_OR_VAXC
X  #endif
X  #ifdef MSDOS
X! #define	MSDOS_OR_VAXC
X  #endif
X  
X  #ifdef MAC
X  #include	<unix.h>	/* open, creat, write, read, close */
X  #include	<stddef.h>	/* sizeof */
X  #endif
X  
X! #ifdef MAC_OR_VAXC
X  #include	<stdlib.h>
X! #else
X! #include	<malloc.h>
X  #endif
X  
X- #ifdef MSDOS
X- #include	<io.h>	/* open, creat, write, read, close */
X- #endif
X- 
X  #include	<stdio.h>
X  #include	"list.h"
X  
X--- 44,84 ----
X  **	***** Version 0.8, May 1993 *****
X  */
X  
X! #ifdef __MSDOS__
X! #define	MSDOS
X! #define	ANSI
X  #endif
X! 
X! #ifdef UNIX
X! #include	<malloc.h>
X  #endif
X+ 
X  #ifdef MSDOS
X! #include	<malloc.h>
X! #include	<io.h>		/* open, creat, write, read, close */
X! 	/* added for Borland or other MSDOS C compilers */
X! #include	<stdlib.h>
X! #include	<fcntl.h>
X! #include	<sys\types.h>
X! #include	<sys\stat.h>
X! #include	<string.h>
X  #endif
X  
X+ #ifdef VAXC
X+ #include	<stdlib.h>
X+ #endif
X+ 
X  #ifdef MAC
X  #include	<unix.h>	/* open, creat, write, read, close */
X  #include	<stddef.h>	/* sizeof */
X+ #include	<stdlib.h>
X  #endif
X  
X! #ifdef AMIGA
X  #include	<stdlib.h>
X! #include	<fcntl.h>	/* open, creat, write, read, close */
X  #endif
X  
X  #include	<stdio.h>
X  #include	"list.h"
X  
X***************
X*** 98,106 ****
X  		while (i--) *to++ = *frm++; \
X  	}
X  
X! #define	BIN_WRITE	1	/* necessary for binary file access */
X  #define	BIN_READ	0
X  #define	PMODE		0666
X  
X  /* -------------------------------------------------------------------------- */
X  
X--- 110,125 ----
X  		while (i--) *to++ = *frm++; \
X  	}
X  
X! 	/* necessary for binary file access */
X! #ifdef MSDOS
X! #define	BIN_WRITE	O_WRONLY|O_BINARY
X! #define	BIN_READ	O_RDONLY|O_BINARY
X! #define	PMODE		S_IREAD
X! #else
X! #define	BIN_WRITE	1
X  #define	BIN_READ	0
X  #define	PMODE		0666
X+ #endif
X  
X  /* -------------------------------------------------------------------------- */
X  
X***************
X*** 148,154 ****
X  static void	lError(char *str, int code, int int1, int int2, char *str1);
X  static int	setWhchNode(int id, int which, char *fname);
X  static int	setIndxNode(int id, int index, char *fname);
X! static int	partition(NodePtr *array, int order, Func func, int lb, int ub,
X  			int *pj);
X  static int	stack_empty(int id);
X  static int	intInSet(int intgr, int *set, int set_n);
X--- 167,173 ----
X  static void	lError(char *str, int code, int int1, int int2, char *str1);
X  static int	setWhchNode(int id, int which, char *fname);
X  static int	setIndxNode(int id, int index, char *fname);
X! static void	partition(NodePtr *array, int order, Func func, int lb, int ub,
X  			int *pj);
X  static int	stack_empty(int id);
X  static int	intInSet(int intgr, int *set, int set_n);
X***************
X*** 159,165 ****
X  static void	lError();
X  static int	setWhchNode();
X  static int	setIndxNode();
X! static int	partition();
X  static int	stack_empty();
X  static int	intInSet();
X  #endif
X--- 178,184 ----
X  static void	lError();
X  static int	setWhchNode();
X  static int	setIndxNode();
X! static void	partition();
X  static int	stack_empty();
X  static int	intInSet();
X  #endif
X***************
X*** 186,199 ****
X  ** Return on error:
X  **	lWRONG_SD, lWRONG_CC
X  */
X- #ifdef ANSI
X  int
X- lDef(int sd, int cc)
X- #else
X- int
X  lDef(sd, cc)
X  int	sd, cc;
X- #endif
X  {
X  	ListPtr		list, new;
X  	static int	set1[] = { lSINGLY, lDOUBLY },
X--- 205,213 ----
X***************
X*** 245,258 ****
X  ** Return on error:
X  **	lUNKNOWN_ID
X  */
X- #ifdef ANSI
X  int
X- lInfo(int id, int *sd, int *cc, int *n)
X- #else
X- int
X  lInfo(id, sd, cc, n)
X  int	id, *sd, *cc, *n;
X- #endif
X  {
X  	ListPtr	list;
X  
X--- 259,267 ----
X***************
X*** 286,299 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_ORDER, lWRONG_THEORY
X  */
X- #ifdef ANSI
X- int lSort(int id, int order, int theory, Func func)
X- #else
X  int
X  lSort(id, order, theory, func)
X  int	id, order, theory;
X  Func	func;
X- #endif
X  {
X  	int		node_n, i, s, f, k, where, j, cmp;
X  	ListPtr		list;
X--- 295,304 ----
X***************
X*** 320,331 ****
X  		return(lWRONG_THEORY);
X  	}
X  
X  	node_n = list->n;
X! 		/* allocate 1 extra so I can nave a null in it */
X  	CALLOC(array, NodePtr, node_n+1);
X  
X  	list->current = list->first;
X! 	for (i=0; i<node_n && list->current != NULL ; i++) {
X  		array[i] = list->current;
X  		list->current = (list->current)->nxt;
X  	}
X--- 325,340 ----
X  		return(lWRONG_THEORY);
X  	}
X  
X+ 		/* one node is already sorted */
X+ 	if (list->n == 1)
X+ 		return(lSUCCESS);
X+ 
X  	node_n = list->n;
X! 		/* allocate 1 extra so I can have a null in it */
X  	CALLOC(array, NodePtr, node_n+1);
X  
X  	list->current = list->first;
X! 	for (i=0; i < node_n && list->current != NULL; i++) {
X  		array[i] = list->current;
X  		list->current = (list->current)->nxt;
X  	}
X***************
X*** 377,386 ****
X  				s = -1;
X  			else
X  				s = 1;
X! 			cmp = (*func)(array[2]->data, array[1]->data);
X! 			if (i > 2 && ((order == lASCENDING && cmp == l2LT1)
X! 			 || (order == lDESCENDING && cmp == l1LT2)))
X! 				s = 2;
X  
X  			if (s >= 0)
X  				cmp = (*func)(temp->data, array[s]->data);
X--- 386,397 ----
X  				s = -1;
X  			else
X  				s = 1;
X! 			if (i > 2) {
X! 				cmp = (*func)(array[2]->data, array[1]->data);
X! 				if ((order == lASCENDING && cmp == l2LT1)
X! 				 || (order == lDESCENDING && cmp == l1LT2))
X! 					s = 2;
X! 			}
X  
X  			if (s >= 0)
X  				cmp = (*func)(temp->data, array[s]->data);
X***************
X*** 393,399 ****
X  				if (s+1 <= i-1) {
X  					cmp = (*func)(array[s]->data,
X  						array[s+1]->data);
X! 					if (cmp < 0)
X  						s = s+1;
X  				}
X  				if (s > i-1)
X--- 404,413 ----
X  				if (s+1 <= i-1) {
X  					cmp = (*func)(array[s]->data,
X  						array[s+1]->data);
X! 					if ((order == lASCENDING
X! 						&& cmp == l1LT2) ||
X! 					 (order == lDESCENDING
X! 						&& cmp == l2LT1))
X  						s = s+1;
X  				}
X  				if (s > i-1)
X***************
X*** 474,480 ****
X  	case lSELECTION: {
X  		int	indx;
X  
X! 		for (i=node_n-1; i>0 ; i--) {
X  			temp = array[0];
X  			indx = 0;
X  
X--- 488,494 ----
X  	case lSELECTION: {
X  		int	indx;
X  
X! 		for (i=node_n-1; i>0; i--) {
X  			temp = array[0];
X  			indx = 0;
X  
X***************
X*** 557,571 ****
X  **	header.n	number of <info>-<data>-combinations (nodes)
X  **	info.size	size of <data>
X  */
X- #ifdef ANSI
X  int
X- lDump(int id, char *file)
X- #else
X- int
X  lDump(id, file)
X  int	id;
X  char	*file;
X- #endif
X  {
X  #ifndef MSDOS
X  	int	open(), creat(), write(), close();
X--- 571,580 ----
X***************
X*** 622,639 ****
X  ** Return on error:
X  **	lOPEN_ERROR
X  */
X- #ifdef ANSI
X  int
X- lUndump(char *file)
X- #else
X- int
X  lUndump(file)
X  char	*file;
X- #endif
X  {
X  #ifndef MSDOS
X  	int	open(), read(), close();
X  #endif
X  
X  	int	fdDump, i, id;
X  	Info	info;
X--- 631,645 ----
X  ** Return on error:
X  **	lOPEN_ERROR
X  */
X  int
X  lUndump(file)
X  char	*file;
X  {
X  #ifndef MSDOS
X+ #ifndef AMIGA
X  	int	open(), read(), close();
X  #endif
X+ #endif
X  
X  	int	fdDump, i, id;
X  	Info	info;
X***************
X*** 674,687 ****
X  ** Return on error:
X  **	lUNKNOWN_ID
X  */
X- #ifdef ANSI
X  int
X- lDel(int id)
X- #else
X- int
X  lDel(id)
X  int	id;
X- #endif
X  {
X  	ListPtr	list;
X  
X--- 680,688 ----
X***************
X*** 710,722 ****
X  ** Return on error:
X  **	lNO_LIST
X  */
X- #ifdef ANSI
X  int
X- lDelAll(void)
X- #else
X- int
X  lDelAll()
X- #endif
X  {
X  	ListPtr	list, nxt;
X  
X--- 711,718 ----
X***************
X*** 760,774 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lWRONG_WHERE
X  */
X- #ifdef ANSI
X  int
X- lInsNode(int id, int where, Byte *data, int size, int flag)
X- #else
X- int
X  lInsNode(id, where, data, size, flag)
X  int	id, where, size, flag;
X  Byte	*data;
X- #endif
X  {
X  	ListPtr		list;
X  	NodePtr		node, new;
X--- 756,765 ----
X***************
X*** 892,905 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY
X  */
X- #ifdef ANSI
X  int
X- lInfoNode(int id, int which, int *size, int *flag)
X- #else
X- int
X  lInfoNode(id, which, size, flag)
X  int	id, which, *size, *flag;
X- #endif
X  {
X  	ListPtr	list;
X  	int	rtrn;
X--- 883,891 ----
X***************
X*** 932,946 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY, lSIZE_NE
X  */
X- #ifdef ANSI
X  int
X- lGetNode(int id, int which, Byte *data, int size)
X- #else
X- int
X  lGetNode(id, which, data, size)
X  int	id, which, size;
X  Byte	*data;
X- #endif
X  {
X  	ListPtr	list;
X  	int	rtrn;
X--- 918,927 ----
X***************
X*** 959,965 ****
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X--- 940,953 ----
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->n == 1) {
X! 		if (which == lPREVIOUS || which == lLAST)
X! 			return(lFIRST);
X! 		else if (which == lNEXT || which == lFIRST)
X! 			return(lLAST);
X! 		else
X! 			return(lLAST);	/* which == lCURRENT */
X! 	} else if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X***************
X*** 972,978 ****
X  **
X  ** Parameters:
X  **	In	int	id	identifier of linked list
X! **	In	int	where	from where must be searched
X  **	In	Func	func	function for checking the data on conditions
X  **	In	Byte	*ptr	data for comparison in function
X  **	Out	Byte	*data	data of node
X--- 960,967 ----
X  **
X  ** Parameters:
X  **	In	int	id	identifier of linked list
X! **	In	int	which	from which node must be searched and in which
X! **				direction
X  **	In	Func	func	function for checking the data on conditions
X  **	In	Byte	*ptr	data for comparison in function
X  **	Out	Byte	*data	data of node
X***************
X*** 981,998 ****
X  ** Return on success:
X  **	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  ** Return on error:
X! **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHERE, lUNKNOWN_FUNC, lNOT_DOUBLY
X  */
X- #ifdef ANSI
X  int
X! lFndNode(int id, int where, Func func, Byte *ptr, Byte *data, int size)
X! #else
X! int
X! lFndNode(id, where, func, ptr, data, size)
X! int	id, where, size;
X  Func	func;
X  Byte	*ptr, *data;
X- #endif
X  {
X  	NodePtr		node;
X  	ListPtr		list;
X--- 970,982 ----
X  ** Return on success:
X  **	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  ** Return on error:
X! **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lUNKNOWN_FUNC, lNOT_DOUBLY
X  */
X  int
X! lFndNode(id, which, func, ptr, data, size)
X! int	id, which, size;
X  Func	func;
X  Byte	*ptr, *data;
X  {
X  	NodePtr		node;
X  	ListPtr		list;
X***************
X*** 1008,1016 ****
X  		lError("lFndNode", lEMPTY_LIST, id, 0, NULL);
X  		return(lEMPTY_LIST);
X  	}
X! 	if (intInSet(where, set, 4) != 0) {
X! 		lError("lFndNode", lWRONG_WHERE, where, 0, NULL);
X! 		return(lWRONG_WHERE);
X  	}
X  	if (func == NULL) {
X  		lError("lFndNode", lUNKNOWN_FUNC, (int) func, 0, NULL);
X--- 992,1000 ----
X  		lError("lFndNode", lEMPTY_LIST, id, 0, NULL);
X  		return(lEMPTY_LIST);
X  	}
X! 	if (intInSet(which, set, 4) != 0) {
X! 		lError("lFndNode", lWRONG_WHICH, which, 0, NULL);
X! 		return(lWRONG_WHICH);
X  	}
X  	if (func == NULL) {
X  		lError("lFndNode", lUNKNOWN_FUNC, (int) func, 0, NULL);
X***************
X*** 1017,1024 ****
X  		return(lUNKNOWN_FUNC);
X  	}
X  
X! 		/* set node for where searching must start */
X! 	switch (where) {
X  	case lFIRST:	node = list->first;	break;
X  	case lNEXT:
X  	case lPREVIOUS:	node = list->current;	break;
X--- 1001,1008 ----
X  		return(lUNKNOWN_FUNC);
X  	}
X  
X! 		/* set node where searching must start */
X! 	switch (which) {
X  	case lFIRST:	node = list->first;	break;
X  	case lNEXT:
X  	case lPREVIOUS:	node = list->current;	break;
X***************
X*** 1026,1037 ****
X  	}
X  
X  		/* expected data and node must have same size */
X! 	if ((where == lFIRST || where == lLAST) && node->size == size) {
X  		BYTE_COPY(node->data, data, size);
X  		cmp = (*func)(ptr, data);
X  	}
X  
X! 	switch (where) {
X  	case lFIRST:	/* search forward */
X  	case lNEXT:
X  		while (cmp != lFOUND && node->nxt != NULL
X--- 1010,1021 ----
X  	}
X  
X  		/* expected data and node must have same size */
X! 	if ((which == lFIRST || which == lLAST) && node->size == size) {
X  		BYTE_COPY(node->data, data, size);
X  		cmp = (*func)(ptr, data);
X  	}
X  
X! 	switch (which) {
X  	case lFIRST:	/* search forward */
X  	case lNEXT:
X  		while (cmp != lFOUND && node->nxt != NULL
X***************
X*** 1080,1085 ****
X--- 1064,1071 ----
X  **
X  ** Parameters:
X  **	In	int	id	identifier of linked list
X+ **	In	int	which	from which node must be searched and in which
X+ **				direction
X  **	In	int	flag	flag of node which must be retrieved
X  **	Out	Byte	*data	data of node
X  **	In	int	size	size of data
X***************
X*** 1087,1103 ****
X  ** Return on success:
X  **	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  ** Return on error:
X! **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHERE, lSIZE_NE
X  */
X- #ifdef ANSI
X  int
X! lFndFlagNode(int id, int where, int flag, Byte *data, int size)
X! #else
X! int
X! lFndFlagNode(id, where, flag, data, size)
X! int	id, where, flag, size;
X  Byte	*data;
X- #endif
X  {
X  	NodePtr		node;
X  	ListPtr		list;
X--- 1073,1084 ----
X  ** Return on success:
X  **	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  ** Return on error:
X! **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lSIZE_NE
X  */
X  int
X! lFndFlagNode(id, which, flag, data, size)
X! int	id, which, flag, size;
X  Byte	*data;
X  {
X  	NodePtr		node;
X  	ListPtr		list;
X***************
X*** 1112,1124 ****
X  		lError("lFndFlagNode", lEMPTY_LIST, id, 0, NULL);
X  		return(lEMPTY_LIST);
X  	}
X! 	if (intInSet(where, set, 4) != 0) {
X! 		lError("lFndFlagNode", lWRONG_WHERE, where, 0, NULL);
X! 		return(lWRONG_WHERE);
X  	}
X  
X! 		/* set node for where searching must start */
X! 	switch (where) {
X  	case lFIRST:
X  		node = list->first;
X  		break;
X--- 1093,1105 ----
X  		lError("lFndFlagNode", lEMPTY_LIST, id, 0, NULL);
X  		return(lEMPTY_LIST);
X  	}
X! 	if (intInSet(which, set, 4) != 0) {
X! 		lError("lFndFlagNode", lWRONG_WHICH, which, 0, NULL);
X! 		return(lWRONG_WHICH);
X  	}
X  
X! 		/* set node where searching must start */
X! 	switch (which) {
X  	case lFIRST:
X  		node = list->first;
X  		break;
X***************
X*** 1138,1144 ****
X  	}
X  
X  		/* search till begin/end of list */
X! 	switch (where) {
X  	case lFIRST:	/* search forward */
X  	case lNEXT:
X  		while (node->flag != flag && node != list->last)
X--- 1119,1125 ----
X  	}
X  
X  		/* search till begin/end of list */
X! 	switch (which) {
X  	case lFIRST:	/* search forward */
X  	case lNEXT:
X  		while (node->flag != flag && node != list->last)
X***************
X*** 1172,1178 ****
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X--- 1153,1166 ----
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->n == 1) {
X! 		if (which == lPREVIOUS || which == lLAST)
X! 			return(lFIRST);
X! 		else if (which == lNEXT || which == lFIRST)
X! 			return(lLAST);
X! 		else
X! 			return(lLAST);	/* which == lCURRENT */
X! 	} else if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X***************
X*** 1181,1187 ****
X  }
X  
X  /*******************************************************************************
X! ** Update curent node.
X  **
X  ** Parameters:
X  **	In	int	id	identifier of linked list
X--- 1169,1175 ----
X  }
X  
X  /*******************************************************************************
X! ** Update current node.
X  **
X  ** Parameters:
X  **	In	int	id	identifier of linked list
X***************
X*** 1194,1208 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST
X  */
X- #ifdef ANSI
X  int
X- lUpdNode(int id, Byte *data, int size, int flag)
X- #else
X- int
X  lUpdNode(id, data, size, flag)
X  int	id, size, flag;
X  Byte	*data;
X- #endif
X  {
X  	ListPtr	list;
X  
X--- 1182,1191 ----
X***************
X*** 1242,1255 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH
X  */
X- #ifdef ANSI
X  int
X- lDelNode(int id, int which)
X- #else
X- int
X  lDelNode(id, which)
X  int	id, which;
X- #endif
X  {
X  	NodePtr		node, prv, nxt;
X  	ListPtr		list;
X--- 1225,1233 ----
X***************
X*** 1355,1368 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X  */
X- #ifdef ANSI
X  int
X- lInfoIndxNode(int id, int index, int *size, int *flag)
X- #else
X- int
X  lInfoIndxNode(id, index, size, flag)
X  int	id, index, *size, *flag;
X- #endif
X  {
X  	ListPtr	list;
X  	int	rtrn;
X--- 1333,1341 ----
X***************
X*** 1394,1408 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX, lSIZE_NE
X  */
X- #ifdef ANSI
X  int
X- lGetIndxNode(int id, int index, Byte *data, int size)
X- #else
X- int
X  lGetIndxNode(id, index, data, size)
X  int	id, index, size;
X  Byte	*data;
X- #endif
X  {
X  	ListPtr	list;
X  	int	rtrn;
X--- 1367,1376 ----
X***************
X*** 1422,1428 ****
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X--- 1390,1398 ----
X  
X  	BYTE_COPY((list->current)->data, data, size);
X  
X! 	if (list->n == 1)
X! 		return(lLAST);
X! 	else if (list->current == list->first)
X  		return(lFIRST);
X  	else if (list->current == list->last)
X  		return(lLAST);
X***************
X*** 1445,1459 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X  */
X- #ifdef ANSI
X  int
X- lUpdIndxNode(int id, int index, Byte *data, int size, int flag)
X- #else
X- int
X  lUpdIndxNode(id, index, data, size, flag)
X  int	id, index, size, flag;
X  Byte	*data;
X- #endif
X  {
X  	ListPtr	list;
X  	int	rtrn;
X--- 1415,1424 ----
X***************
X*** 1489,1502 ****
X  ** Return on error:
X  **	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X  */
X- #ifdef ANSI
X  int
X- lDelIndxNode(int id, int index)
X- #else
X- int
X  lDelIndxNode(id, index)
X  int	id, index;
X- #endif
X  {
X  	int	rtrn;
X  
X--- 1454,1462 ----
X***************
X*** 1510,1523 ****
X  /* ---------- static local functions ---------------------------------------- */
X  
X  /* get address of list data */
X- #ifdef ANSI
X  static ListPtr
X- getAddress(int id)
X- #else
X- static ListPtr
X  getAddress(id)
X  int	id;
X- #endif
X  {
X  	ListPtr	list;
X  
X--- 1470,1478 ----
X***************
X*** 1535,1549 ****
X  }
X  
X  /* delete nodes of a linked list */
X- #ifdef ANSI
X  static void
X- delNodes(NodePtr node, int n)
X- #else
X- static void
X  delNodes(node, n)
X  NodePtr	node;
X  int	n;
X- #endif
X  {
X  	NodePtr	nxt;
X  	int	i;
X--- 1490,1499 ----
X***************
X*** 1557,1570 ****
X  }
X  
X  /* delete info about linked list */
X- #ifdef ANSI
X  static void
X- delListInfo(ListPtr list)
X- #else
X- static void
X  delListInfo(list)
X  ListPtr	list;
X- #endif
X  {
X  	ListPtr	nxt;
X  
X--- 1507,1515 ----
X***************
X*** 1576,1592 ****
X  }
X  
X  /* print error message in lERROR_FILE */
X- #ifdef ANSI
X  static void
X- lError(char *str, int code, int int1, int int2, char *str1)
X- #else
X- static void
X  lError(str, code, int1, int2, str1)
X  char	*str, *str1;
X  int	code, int1, int2;
X- #endif
X  {
X- #ifndef MSDOS
X  	char	mess[60];
X  	FILE	*fpError, *fopen();
X  
X--- 1521,1531 ----
X***************
X*** 1660,1680 ****
X  		fprintf(stderr, "Can't open error-file '%s'\n", lERROR_FILE);
X  		fprintf(stderr, "Error, '%s': %s\n", str, mess);
X  	} else {
X! 		fprintf(fpError, "Error, '%s': %s\n", str, mess);
X  		fclose(fpError);
X  	}
X- #endif
X  }
X  
X- #ifdef ANSI
X  static int
X- setWhchNode(int id, int which, char *fname)
X- #else
X- static int
X  setWhchNode(id, which, fname)
X  int	id, which;
X  char	*fname;
X- #endif
X  {
X  	ListPtr		list;
X  	static int	set[] = { lFIRST, lNEXT, lCURRENT, lPREVIOUS, lLAST };
X--- 1599,1613 ----
X  		fprintf(stderr, "Can't open error-file '%s'\n", lERROR_FILE);
X  		fprintf(stderr, "Error, '%s': %s\n", str, mess);
X  	} else {
X! 		fprintf(fpError, "Error in '%s': %s\n", str, mess);
X  		fclose(fpError);
X  	}
X  }
X  
X  static int
X  setWhchNode(id, which, fname)
X  int	id, which;
X  char	*fname;
X  {
X  	ListPtr		list;
X  	static int	set[] = { lFIRST, lNEXT, lCURRENT, lPREVIOUS, lLAST };
X***************
X*** 1726,1740 ****
X  	return(lSUCCESS);
X  }
X  
X- #ifdef ANSI
X  static int
X- setIndxNode(int id, int index, char *fname)
X- #else
X- static int
X  setIndxNode(id, index, fname)
X  int	id, index;
X  char	*fname;
X- #endif
X  {
X  	ListPtr	list;
X  	int	i;
X--- 1659,1668 ----
X***************
X*** 1767,1782 ****
X  }
X  
X  /* local function for QUICK sort */
X! #ifdef ANSI
X! static int
X! partition(NodePtr *array, int order, Func func, int lb, int ub, int *pj)
X! #else
X! static int
X  partition(array, order, func, lb, ub, pj)
X  NodePtr	*array;
X  int	order, lb, ub, *pj;
X  Func	func;
X- #endif
X  {
X  	int	down, up, cmp;
X  	NodePtr	temp, a;
X--- 1695,1705 ----
X  }
X  
X  /* local function for QUICK sort */
X! static void
X  partition(array, order, func, lb, ub, pj)
X  NodePtr	*array;
X  int	order, lb, ub, *pj;
X  Func	func;
X  {
X  	int	down, up, cmp;
X  	NodePtr	temp, a;
X***************
X*** 1812,1825 ****
X  }
X  
X  /* local function for QUICK sort */
X- #ifdef ANSI
X  static int
X- stack_empty(int id)
X- #else
X- static int
X  stack_empty(id)
X  int	id;
X- #endif
X  {
X  	int	sd, cc, n;
X  
X--- 1735,1743 ----
X*** ../list.h	Tue Apr 20 11:06:14 1993
X--- list.h	Wed May 19 10:08:47 1993
X***************
X*** 50,59 ****
X  
X  #define	lFOUND		0	/* node found */
X  
X! #ifdef MSDOS_OR_VAXC
X  #define	lERROR_FILE	"linklist.err"
X  #else
X  #define	lERROR_FILE	"=listError="
X  #endif
X  
X  #ifdef ANSI
X--- 50,63 ----
X  
X  #define	lFOUND		0	/* node found */
X  
X! #ifdef MSDOS
X  #define	lERROR_FILE	"linklist.err"
X  #else
X+ # ifdef VAXC
X+ #define	lERROR_FILE	"linklist.err"
X+ # else
X  #define	lERROR_FILE	"=listError="
X+ # endif
X  #endif
X  
X  #ifdef ANSI
X*** ../sorted.c	Fri Feb 26 11:25:09 1993
X--- sorted.c	Wed May 19 14:09:36 1993
X***************
X*** 2,10 ****
X  #include	<string.h>
X  #include	"list.h"
X  
X- static void	addPersonSorted(), addPerson();
X- static int	fndNxtPerson(), sortPerson(), compare();
X- 
X  typedef struct person {
X  	char	lastname[15];
X  	char	firstname[15];
X--- 2,7 ----
X***************
X*** 11,16 ****
X--- 8,25 ----
X  } Person, *PersonPtr;
X  int	personSz = sizeof(Person);
X  
X+ #ifdef ANSI
X+ static void	addPerson(int id, char *first, char *last);
X+ static void	addPersonSorted(int id, char *first, char *last);
X+ static int	compare(PersonPtr p1, PersonPtr p2, int order);
X+ static int	fndNxtPerson(char *last, PersonPtr data);
X+ static int	sortPerson(int id);
X+ #else
X+ static void	addPerson(), addPersonSorted();
X+ static int	compare(), fndNxtPerson(), sortPerson();
X+ #endif
X+ 
X+ int
X  main()
X  {
X  	Person	person;
X*** ../sorttest.c	Mon May  3 11:45:21 1993
X--- sorttest.c	Wed May 19 14:37:07 1993
X***************
X*** 1,9 ****
X  /* Sort torture test */
X  
X  #include	<stdio.h>
X  #include	<string.h>
X  #include	"list.h"
X- #include	"time.h"
X  
X  typedef struct catalog {
X  	char		number[35];
X--- 1,21 ----
X  /* Sort torture test */
X  
X+ #ifdef UNIX
X+ #include	<malloc.h>
X+ #endif
X+ 
X+ #ifdef	AMIGA
X+ #include	<stdlib.h>
X+ #endif
X+ 
X+ #ifdef MSDOS
X+ #include	<malloc.h>
X+ #endif
X+ 
X  #include	<stdio.h>
X  #include	<string.h>
X+ #include	<time.h>
X  #include	"list.h"
X  
X  typedef struct catalog {
X  	char		number[35];
X***************
X*** 12,32 ****
X  	int		date;
X  } catalog;
X  
X  static int	compare_author();
X  static int	compare_title();
X  static void	load_it();
X  static void	print_some();
X  static time_t	what_time();
X  static void	prRap();
X  
X- #ifdef ANSI
X  static int
X- compare_author(catalog *a, catalog *b)
X- #else
X- static int
X  compare_author(a, b)
X  catalog *a, *b;
X- #endif
X  {
X  	int	k;
X  
X--- 24,50 ----
X  	int		date;
X  } catalog;
X  
X+ #ifdef ANSI
X+ static int	compare_author(catalog *a, catalog *b);
X+ static int	compare_title(catalog *a, catalog *b, int order);
X+ static void	load_it(int id, int num);
X+ static void	print_some(int id, int num);
X+ static time_t	what_time(void);
X+ static void	diff_time(time_t a, time_t b);
X+ static void	prRap(int code, catalog *rpprt);
X+ #else
X  static int	compare_author();
X  static int	compare_title();
X  static void	load_it();
X  static void	print_some();
X  static time_t	what_time();
X+ static void	diff_time();
X  static void	prRap();
X+ #endif
X  
X  static int
X  compare_author(a, b)
X  catalog *a, *b;
X  {
X  	int	k;
X  
X***************
X*** 40,54 ****
X  		return(l1LT2);
X  }
X  
X- #ifdef ANSI
X  static int
X- compare_title(catalog *a, catalog *b, int order)
X- #else
X- static int
X  compare_title(a, b, order)
X  catalog *a, *b;
X  int order;
X- #endif
X  {
X  	int	k;
X  
X--- 58,67 ----
X***************
X*** 62,76 ****
X  		return(l1LT2);
X  }
X  
X- #ifdef ANSI
X  static void
X- load_it(int id, int num)
X- #else
X- static void
X  load_it(id, num)
X  int id;
X  int num;
X- #endif
X  {
X  	int	loop, size = sizeof(catalog), code;
X  	char	c1, c2, c3, c4, c5, c6, c7, c8;
X--- 75,84 ----
X***************
X*** 99,113 ****
X  	/* printf("Linked List created\n"); */
X  }
X  
X- #ifdef ANSI
X  static void
X- print_some(int id, int num)
X- #else
X- static void
X  print_some(id, num)
X  int id;
X  int num;
X- #endif
X  {
X  	int	size = sizeof(catalog), loop;
X  	int	code;
X--- 107,116 ----
X***************
X*** 122,142 ****
X  	}
X  }
X  
X! #ifdef ANSI
X! static time_t what_time(void)
X! #else
X! static time_t what_time()
X! #endif
X  {
X  	return((time_t)time(NULL));
X  }
X  
X! #ifdef ANSI
X! static void diff_time(time_t a, time_t b)
X! #else
X! static void diff_time(a, b)
X  time_t a, b;
X- #endif
X  {
X  	struct tm	*tt;
X  	char		buf1[101], buf2[101];
X--- 125,139 ----
X  	}
X  }
X  
X! static time_t
X! what_time()
X  {
X  	return((time_t)time(NULL));
X  }
X  
X! static void
X! diff_time(a, b)
X  time_t a, b;
X  {
X  	struct tm	*tt;
X  	char		buf1[101], buf2[101];
X***************
X*** 160,165 ****
X--- 157,163 ----
X  	(sec[1] - sec[0] > 0)?(sec[1] - sec[0]) : (sec[0] - sec[1]));
X  }
X  
X+ int
X  main()
X  {
X  	int	size = sizeof(catalog);
X***************
X*** 175,181 ****
X  	printf("Untouched list\n");
X  	print_some(id, 10);
X  
X! 	printf("-- lQuickSort --\nlQuickSort DESCENDING by TITLE : ");
X  	start = what_time();
X  	code = lSort(id, lDESCENDING, lQUICK, compare_title);
X  	finish = what_time();
X--- 173,179 ----
X  	printf("Untouched list\n");
X  	print_some(id, 10);
X  
X! 	printf("lQuickSort DESCENDING by TITLE : ");
X  	start = what_time();
X  	code = lSort(id, lDESCENDING, lQUICK, compare_title);
X  	finish = what_time();
X***************
X*** 213,219 ****
X  	printf("Untouched list\n");
X  	print_some(id, 10);
X  
X! 	printf(" -- lHeapSort -- \nlHeapSort DESCENDING by TITLE : ");
X  	start = what_time();
X  	code = lSort(id, lDESCENDING, lHEAP, compare_title);
X  	finish = what_time();
X--- 211,217 ----
X  	printf("Untouched list\n");
X  	print_some(id, 10);
X  
X! 	printf("lHeapSort DESCENDING by TITLE : ");
X  	start = what_time();
X  	code = lSort(id, lDESCENDING, lHEAP, compare_title);
X  	finish = what_time();
X***************
X*** 332,343 ****
X  
X  static void
X  prRap(code, rpprt)
X! int			code;
X! catalog		*rpprt;
X  {
X  	if (code >= 0)
X! 		printf("catalog :'%s' '%s' '%s' '%d'\n", rpprt->number, rpprt->title,
X! 			rpprt->author, rpprt->date);
X  	else
X  		printf("Return code = %d\n", code);
X  }
X--- 330,341 ----
X  
X  static void
X  prRap(code, rpprt)
X! int	code;
X! catalog	*rpprt;
X  {
X  	if (code >= 0)
X! 		printf("catalog :'%s'\t'%s'\t'%s'\t'%d'\n", rpprt->number,
X! 			rpprt->title, rpprt->author, rpprt->date);
X  	else
X  		printf("Return code = %d\n", code);
X  }
X*** ../Doc/Intro.3	Fri Feb 26 10:56:12 1993
X--- Doc/Intro.3	Thu May 27 12:01:52 1993
X***************
X*** 1,4 ****
X- '.so tmac.clman
X  .TH "Intro"
X  .IX Intro
X  .SH NAME
X--- 1,3 ----
X***************
X*** 78,83 ****
X--- 77,86 ----
X  .SH EXAMPLE
X  .if t .ta 0.3i 0.6i 0.9i 1.2i 2.2i 3.2i 4.2i 4.5i 4.8i
X  .nf
X+ #ifdef	AMIGA
X+ #include		<string.h>
X+ #endif
X+ 
X  #include		<stdio.h>
X  #include		"list.h"
X  
X***************
X*** 88,96 ****
X  } Rapport;
X  int	rapSz = sizeof(Rapport);
X  
X  static void	insRap(), prRapAll(), prRap();
X! static int		search(), compare();
X  
X  main()
X  {
X  	int			id, code, search_date;
X--- 91,109 ----
X  } Rapport;
X  int	rapSz = sizeof(Rapport);
X  
X+ #ifdef ANSI
X+ static void	insRap(int id, int where, int flag, char *title, char *author,
X+ 				int date);
X+ static void	prRapAll(int id);
X+ static void	prRap(int code, Rapport *rpprt);
X+ static int	search(int *date, Rapport *rpprt);
X+ static int	compare(Rapport *data1, Rapport *data2);
X+ #else
X  static void	insRap(), prRapAll(), prRap();
X! static int	search(), compare();
X! #endif
X  
X+ int
X  main()
X  {
X  	int			id, code, search_date;
X***************
X*** 102,111 ****
X  	insRap(id, lFIRST, 2, "Book 2", "More People", 890130);
X  	insRap(id, lLAST, 1, "Book 3", "Lots of People", 890131);
X  
X! 	fprintf(stdout, "lGetNode\n");
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lGetIndxNode\n");
X  	code = lGetIndxNode(id, 4, &rap, rapSz);
X  	prRap(code, &rap);
X  	code = lGetIndxNode(id, 2, &rap, rapSz);
X--- 115,124 ----
X  	insRap(id, lFIRST, 2, "Book 2", "More People", 890130);
X  	insRap(id, lLAST, 1, "Book 3", "Lots of People", 890131);
X  
X! 	fprintf(stdout, "lGetNode\\n");
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lGetIndxNode\\n");
X  	code = lGetIndxNode(id, 4, &rap, rapSz);
X  	prRap(code, &rap);
X  	code = lGetIndxNode(id, 2, &rap, rapSz);
X***************
X*** 115,121 ****
X  	code = lGetIndxNode(id, 3, &rap, rapSz);
X  	prRap(code, &rap);
X  
X! 	fprintf(stdout, "lFndNode\n");
X  	search_date = 890129;
X  	code = lFndNode(id, lFIRST, search, &search_date, &rap, rapSz);
X  	prRap(code, &rap);
X--- 128,134 ----
X  	code = lGetIndxNode(id, 3, &rap, rapSz);
X  	prRap(code, &rap);
X  
X! 	fprintf(stdout, "lFndNode\\n");
X  	search_date = 890129;
X  	code = lFndNode(id, lFIRST, search, &search_date, &rap, rapSz);
X  	prRap(code, &rap);
X***************
X*** 125,142 ****
X  	prRap(code, &rap);
X  
X  	code = lDump(id, "dump");
X! 	fprintf(stdout, "lDump : %d\n", code);
X  
X  	lDel(id);
X  
X  	id = lUndump("dump");
X! 	fprintf(stdout, "lUndump : %d\n", id);
X  
X  	insRap(id, lFIRST, 4, "Book 4", "The Author", 891127);
X  
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lFndFlagNode\n");
X  	code = lFndFlagNode(id, lFIRST, 1, &rap, rapSz);
X  	prRap(code, &rap);
X  	code = lFndFlagNode(id, lNEXT, 1, &rap, rapSz);
X--- 138,155 ----
X  	prRap(code, &rap);
X  
X  	code = lDump(id, "dump");
X! 	fprintf(stdout, "lDump : %d\\n", code);
X  
X  	lDel(id);
X  
X  	id = lUndump("dump");
X! 	fprintf(stdout, "lUndump : %d\\n", id);
X  
X  	insRap(id, lFIRST, 4, "Book 4", "The Author", 891127);
X  
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lFndFlagNode\\n");
X  	code = lFndFlagNode(id, lFIRST, 1, &rap, rapSz);
X  	prRap(code, &rap);
X  	code = lFndFlagNode(id, lNEXT, 1, &rap, rapSz);
X***************
X*** 146,159 ****
X  	code = lFndFlagNode(id, lFIRST, 7, &rap, rapSz);
X  	prRap(code, &rap);
X  	
X! 	fprintf(stdout, "Untouched list\n");
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lSort\n");
X  	lSort(id, lDESCENDING, lBUBBLE, compare);
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lSort\n");
X  	lSort(id, lASCENDING, lHEAP, compare);
X  	prRapAll(id);
X  
X--- 159,172 ----
X  	code = lFndFlagNode(id, lFIRST, 7, &rap, rapSz);
X  	prRap(code, &rap);
X  	
X! 	fprintf(stdout, "Untouched list\\n");
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lSort\\n");
X  	lSort(id, lDESCENDING, lBUBBLE, compare);
X  	prRapAll(id);
X  
X! 	fprintf(stdout, "lSort\\n");
X  	lSort(id, lASCENDING, lHEAP, compare);
X  	prRapAll(id);
X  
X***************
X*** 162,169 ****
X  
X  static void
X  insRap(id, where, flag, title, author, date)
X! int	id, where, flag, date;
X! char	*title, *author;
X  {
X  	int		code;
X  	Rapport	rap;
X--- 175,182 ----
X  
X  static void
X  insRap(id, where, flag, title, author, date)
X! int		id, where, flag, date;
X! char		*title, *author;
X  {
X  	int		code;
X  	Rapport	rap;
X***************
X*** 195,204 ****
X  Rapport		*rpprt;
X  {
X  	if (code >= 0)
X! 		fprintf(stdout, "Rapport : '%s' '%s' '%d'\n", rpprt->title,
X  			rpprt->author, rpprt->date);
X  	else
X! 		fprintf(stdout, "Return code = %d\n", code);
X  }
X  
X  static int
X--- 208,217 ----
X  Rapport		*rpprt;
X  {
X  	if (code >= 0)
X! 		fprintf(stdout, "Rapport : '%s' '%s' '%d'\\n", rpprt->title,
X  			rpprt->author, rpprt->date);
X  	else
X! 		fprintf(stdout, "Return code = %d\\n", code);
X  }
X  
X  static int
X***************
X*** 226,281 ****
X  		return(l1LT2);	/* key1 < key2 */
X  }
X  .fi
X- .sp 2
X- This example program produces the following output :
X- .nf
X- 	lGetNode
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Return code = -9
X- 	lGetIndxNode
X- 	Return code = -13
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Return code = -13
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	lFndNode
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Return code = -10
X- 	lDump : 0
X- 	lUndump : 1
X- 	Rapport : 'Book 4' 'The Author' '891127'
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Return code = -9
X- 	lFndFlagNode
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Return code = -10
X- 	Untouched list
X- 	Rapport : 'Book 4' 'The Author' '891127'
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Return code = -9
X- 	lSort
X- 	Rapport : 'Book 4' 'The Author' '891127'
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Return code = -9
X- 	lSort
X- 	Rapport : 'Book 3' 'Lots of People' '890131'
X- 	Rapport : 'Book 2' 'More People' '890130'
X- 	Rapport : 'Book 1' 'People' '890129'
X- 	Rapport : 'Book 4' 'The Author' '891127'
X- 	Return code = -9
X- .fi
X  .SH VERSION
X! Generic Linked List 0.8, March 1993.
X  .SH PUBLIC DOMAIN
X  The Generic Linked List package is in the public domain. If you have
X  any comments, suggestions, or find any bugs, or make any changes you'd
X--- 239,246 ----
X  		return(l1LT2);	/* key1 < key2 */
X  }
X  .fi
X  .SH VERSION
X! Generic Linked List 0.9, May 1993.
X  .SH PUBLIC DOMAIN
X  The Generic Linked List package is in the public domain. If you have
X  any comments, suggestions, or find any bugs, or make any changes you'd
X*** ../Doc/lDef.3	Fri Feb 26 10:30:43 1993
X--- Doc/lDef.3	Thu May 27 12:01:53 1993
X***************
X*** 27,32 ****
X--- 27,33 ----
X  	lDOUBLY	doubly linked list, each node points to the previous and
X  		the next node
X  .fi
X+ .sp 1
X  \fIcc\fP :
X  .nf
X  	lCHAIN	chain linked list, last node has a NULL-pointer
X*** ../Doc/lFndFlagNode.3	Fri Feb 26 10:38:09 1993
X--- Doc/lFndFlagNode.3	Thu May 27 12:01:53 1993
X***************
X*** 5,11 ****
X  lFndFlagNode - Get node by flag.
X  .SH SYNOPSIS
X  int
X! .BR "lFndFlagNode" "(id, from, flag, data, size)"
X  .br
X  .RT
X  .RP
X--- 5,11 ----
X  lFndFlagNode - Get node by flag.
X  .SH SYNOPSIS
X  int
X! .BR "lFndFlagNode" "(id, which, flag, data, size)"
X  .br
X  .RT
X  .RP
X***************
X*** 12,18 ****
X  In	int	id	identifier of linked list
X  .br
X  .RP
X! In	int	from	from where must be searched
X  .br
X  .RP
X  In	int	flag	flag of node which must be retrieved
X--- 12,18 ----
X  In	int	id	identifier of linked list
X  .br
X  .RP
X! In	int	which	from which node must be searched and in which direction
X  .br
X  .RP
X  In	int	flag	flag of node which must be retrieved
X***************
X*** 25,47 ****
X  .DT
X  .SH DESCRIPTION
X  \fBlFndFlagNode\fP searches a 'flagged' node from the linked list. From
X! where the node must be searched can be specified by \fIfrom\fP. A node
X! can be searched forward from the beginning of the list or from the
X! current node and backward from the current node or from the end of the
X! list.
X  .br
X  Backward searching is only possible for doubly linked list.
X  .br
X  When the found node is the first or the last node, the return code will
X  have the value lFIRST or lLAST, otherwise lFOUND.
X  .SH PARAMETER DEFINITIONS
X  .if t .ta 0.2i 1.5i
X! \fIfrom\fP :
X  .nf
X! 	lFIRST	search forward from first node
X! 	lPREVIOUS	search backward from previous node
X! 	lNEXT	search forward from next node
X! 	lLAST	search backward from last node
X  .fi
X  .SH RETURN CODES
X  .nf
X--- 25,51 ----
X  .DT
X  .SH DESCRIPTION
X  \fBlFndFlagNode\fP searches a 'flagged' node from the linked list. From
X! which node the searching must start and in which direction must be
X! searched can be specified by \fIwhich\fP. A node can be searched forward
X! from the beginning of the list (lFIRST) or from the current node (lNEXT)
X! and backward from the end of the list (lLAST) or from the current node
X! (lPREVIOUS).
X  .br
X  Backward searching is only possible for doubly linked list.
X  .br
X  When the found node is the first or the last node, the return code will
X  have the value lFIRST or lLAST, otherwise lFOUND.
X+ When the linked list contains only one node, the return code will have
X+ the value lFIRST, when searching backward, and the value lLAST, when
X+ searching forward.
X  .SH PARAMETER DEFINITIONS
X  .if t .ta 0.2i 1.5i
X! \fIwhich\fP :
X  .nf
X! 	lFIRST	search forward starting from the first node
X! 	lNEXT	search forward starting from the next node
X! 	lLAST	search backward starting from the last node
X! 	lPREVIOUS	search backward starting from the previous node
X  .fi
X  .SH RETURN CODES
X  .nf
X***************
X*** 48,54 ****
X  Return on success :
X  	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  Return on error :
X! 	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_FROM, lSIZE_NE
X  .fi
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X--- 52,58 ----
X  Return on success :
X  	lFOUND, lFIRST, lLAST, lNOT_FOUND
X  Return on error :
X! 	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lSIZE_NE
X  .fi
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X*** ../Doc/lFndNode.3	Fri Feb 26 10:47:50 1993
X--- Doc/lFndNode.3	Thu May 27 12:01:53 1993
X***************
X*** 5,11 ****
X  lFndNode - Find node.
X  .SH SYNOPSIS
X  int
X! .BR "lFndNode" "(id, from, func, ptr, data, size)"
X  .br
X  .RT
X  .RP
X--- 5,11 ----
X  lFndNode - Find node.
X  .SH SYNOPSIS
X  int
X! .BR "lFndNode" "(id, which, func, ptr, data, size)"
X  .br
X  .RT
X  .RP
X***************
X*** 12,18 ****
X  In	int	id	identifier of linked list
X  .br
X  .RP
X! In	int	from	from where must be searched
X  .br
X  .RP
X  In	int	(*func)()	function for checking the data on conditions
X--- 12,18 ----
X  In	int	id	identifier of linked list
X  .br
X  .RP
X! In	int	which	from which node must be searched and in which direction
X  .br
X  .RP
X  In	int	(*func)()	function for checking the data on conditions
X***************
X*** 28,55 ****
X  .DT
X  .SH DESCRIPTION
X  \fBlFndNode\fP searches a node from the linked list, using the user
X! defined serach function \fIfunc\fP, which checks the data of a node
X  on conditions. This function must have two parameters, a pointer to
X  the data to compare with and a pointer to the data of a node. The
X  possible return values are lFOUND or lNOT_FOUND. See the introduction
X  of Generic Linked List for an example of such a search function. From
X! where the node must be searched can be specified by \fIfrom\fP. A node
X! can be searched forward from the beginning of the list or from the
X! current node and backward from the current node or from the end of the
X! list.
X  .br
X  Backward searching is only possible for doubly linked list.
X  .br
X  When the found node is the first or the last node, the return code will
X  have the value lFIRST or lLAST, otherwise lFOUND.
X  .SH PARAMETER DEFINITIONS
X  .if t .ta 0.2i 1.5i
X! \fIfrom\fP :
X  .nf
X! 	lFIRST	search forward from first node
X! 	lPREVIOUS	search backward from previous node
X! 	lNEXT	search forward from next node
X! 	lLAST	search backward from last node
X  .fi
X  .SH RETURN CODES
X  .nf
X--- 28,59 ----
X  .DT
X  .SH DESCRIPTION
X  \fBlFndNode\fP searches a node from the linked list, using the user
X! defined search function \fIfunc\fP, which checks the data of a node
X  on conditions. This function must have two parameters, a pointer to
X  the data to compare with and a pointer to the data of a node. The
X  possible return values are lFOUND or lNOT_FOUND. See the introduction
X  of Generic Linked List for an example of such a search function. From
X! which node the searching must start and in which direction must be
X! searched can be specified by \fIwhich\fP. A node can be searched
X! forward from the beginning of the list (lFIRST) or from the current
X! node (lNEXT) and backward from the end of the list (lLAST) or from
X! the current node (lPREVIOUS).
X  .br
X  Backward searching is only possible for doubly linked list.
X  .br
X  When the found node is the first or the last node, the return code will
X  have the value lFIRST or lLAST, otherwise lFOUND.
X+ When the linked list contains only one node, the return code will have
X+ the value lFIRST, when searching backward, and the value lLAST, when
X+ searching forward.
X  .SH PARAMETER DEFINITIONS
X  .if t .ta 0.2i 1.5i
X! \fIwhich\fP :
X  .nf
X! 	lFIRST	search forward starting from the first node
X! 	lNEXT	search forward starting from the next node
X! 	lLAST	search backward starting from the last node
X! 	lPREVIOUS	search backward starting from the previous node
X  .fi
X  .SH RETURN CODES
X  .nf
X***************
X*** 58,64 ****
X  Return on error :
X  .fi
X  .in +0.2i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_FROM, lUNKNOWN_FUNC, lNOT_DOUBLY
X! .in 10.2i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X--- 62,68 ----
X  Return on error :
X  .fi
X  .in +0.2i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lNOT_DOUBLY, lUNKNOWN_FUNC
X! .in -0.2i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X*** ../Doc/lGetNode.3	Fri Feb 26 10:43:42 1993
X--- Doc/lGetNode.3	Thu May 27 12:01:53 1993
X***************
X*** 29,34 ****
X--- 29,37 ----
X  When the retrieved node is the first or the last node, the return code
X  will have the value lFIRST or lLAST. For the other nodes the routine
X  returns lSUCCESS.
X+ When the linked list contains only one node, the return code will have
X+ the value lFIRST, when retrieving backward, and the value lLAST, when
X+ retrieving forward.
X  .SH PARAMETER DEFINITIONS
X  .if t .ta 0.2i 1.5i
X  \fIwhich\fP :
X***************
X*** 45,52 ****
X  	lSUCCESS, lFIRST, lLAST
X  Return on error :
X  .fi
X! .in +02.i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY, lSIZE_NE
X! .in -02.i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X--- 48,55 ----
X  	lSUCCESS, lFIRST, lLAST
X  Return on error :
X  .fi
X! .in +0.2i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lSIZE_NE, lNOT_DOUBLY
X! .in -0.2i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X*** ../Doc/lInfoNode.3	Fri Feb 26 10:44:07 1993
X--- Doc/lInfoNode.3	Thu May 27 12:01:53 1993
X***************
X*** 44,50 ****
X  Return on error :
X  .fi
X  .in +0.2i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lEOL, lNOT_DOUBLY
X  .in -0.2i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X--- 44,50 ----
X  Return on error :
X  .fi
X  .in +0.2i
X! lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lNOT_DOUBLY, lEOL
X  .in -0.2i
X  .SH AUTHOR
X  Anita Eijs (TNO - Bouw - BouwInformatica)
X*** ../Doc/lSort.3	Mon Apr 19 13:49:00 1993
X--- Doc/lSort.3	Thu May 27 12:01:53 1993
X***************
X*** 15,21 ****
X  .RP
X  In	int	theory	sorting theory
X  .RP
X! In	int	(*func)()	function for comparing the data of 2 nodes
X  .DT
X  .SH DESCRIPTION
X  \fBlSort\fP sorts a linked list in the specified \fIorder\fP, using
X--- 15,21 ----
X  .RP
X  In	int	theory	sorting theory
X  .RP
X! In	int	(*func)()	function for comparing the data of two nodes
X  .DT
X  .SH DESCRIPTION
X  \fBlSort\fP sorts a linked list in the specified \fIorder\fP, using
X***************
X*** 31,43 ****
X  	lASCENDING	'a', 'b', 'c', ...
X  	lDESCENDING	'z', 'y', 'x', ...
X  .fi
X  \fItheory\fP :
X  .nf
X! 	lBUBBLE	bubble sorting algorithm ...
X! 	lHEAP	heap sorting algorithm ...
X! 	lINSERT	insert sorting algorithm ...
X! 	lQUICK	quick sorting algorithm ...
X! 	lSELECTION	selection sorting algorithm ...
X  .fi
X  .SH RETURN CODES
X  .nf
X--- 31,44 ----
X  	lASCENDING	'a', 'b', 'c', ...
X  	lDESCENDING	'z', 'y', 'x', ...
X  .fi
X+ .sp 1
X  \fItheory\fP :
X  .nf
X! 	lBUBBLE	bubble sorting algorithm
X! 	lHEAP	heap sorting algorithm
X! 	lINSERT	insert sorting algorithm
X! 	lQUICK	quick sorting algorithm
X! 	lSELECTION	selection sorting algorithm
X  .fi
X  .SH RETURN CODES
X  .nf
END_OF_FILE
  if test 50341 -ne `wc -c <'patch1'`; then
    echo shar: \"'patch1'\" unpacked with wrong size!
  fi
  # end of 'patch1'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
