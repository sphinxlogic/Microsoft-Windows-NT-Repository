Newsgroups: comp.sources.misc
From: <dfs@doe.carleton.ca> (David F. Skoll)
Subject: v37i035:  remind - A replacement for calendar, Patch06
Message-ID: <1993May4.151305.17307@sparky.imd.sterling.com>
X-Md4-Signature: f0cc56879d4ba5da04df0c4638c2c7a5
Date: Tue, 4 May 1993 15:13:05 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: <dfs@doe.carleton.ca> (David F. Skoll)
Posting-number: Volume 37, Issue 35
Archive-name: remind/patch06
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

This is patch 6 for version 3.0 of Remind.

Remind is a sophisticated calendar/alarm program, which runs under
MS-DOS, UNIX and OS/2.

>From the WHATSNEW file:

* Version 3.0 Patch 6

+ MINOR ENHANCEMENTS

- Added the PS- and PSFILE-type reminders - these allow you to include
  arbitrary PostScript code in your PostScript calendars.  Useful for
  shading, drawing graphics on calendars, etc.  Use with care, though!

- Added the "-ivar=val" option to initialize variables from the command
  line.  Changed the remind-all.* shell scripts to predefine the variable
  "remind_all".

+ BUG FIXES

- Fixed a bug in the hebmon(), hebday() and hebyear() functions - there
  was an off-by-one error.  Sorry!

- Fixed a bug in the hebdate() function which resulted in infinite loops
  for dates after about 2075

- Fixed a bug in the -u option which sometimes caused a core dump
  (embarrassed grin!)  The fix is due to Tina Hoeltig.  Thanks, Tina!

Availability:

You can get Remind via ftp from ftp.doe.carleton.ca (134.117.9.35)
in the directory "pub/remind-3.0".  See the file README.1st for
a description of the files.

David F. Skoll
---------------------------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  patch.06
# Wrapped by kent@sparky on Tue May  4 10:07:16 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'patch.06' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.06'\"
else
  echo shar: Extracting \"'patch.06'\" \(46327 characters\)
  sed "s/^X//" >'patch.06' <<'END_OF_FILE'
XPrereq: "03.00.05"
X*** ../p5rel/version.h	Thu Apr 22 10:24:22 1993
X--- ./version.h	Fri Apr 23 12:59:49 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.05"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.06"
X*** ../p5rel/COPYRIGHT	Thu Apr 22 10:24:02 1993
X--- ./COPYRIGHT	Mon May  3 10:13:51 1993
X***************
X*** 30,38 ****
X  1993 by David Skoll.  These programs can be distributed according to
X  the terms of paragraphs 3 and 4.
X  
X! 7. I will attempt to support REMIND as much as possible.  However, you
X! use it at your own risk.  I am not responsible for any damages caused
X! by the use or misuse of REMIND.
X  
X  8. If you wish to contribute ideas or money to help the production of
X  software like REMIND, you can reply to the address shown at the end of
X--- 30,39 ----
X  1993 by David Skoll.  These programs can be distributed according to
X  the terms of paragraphs 3 and 4.
X  
X! 7. I will attempt to support REMIND as much as possible.  However,
X! REMIND is supplied on an "as-is" basis with no warranty.  You use it
X! at your own risk.  I am not responsible for any damages caused by the
X! use or misuse of REMIND.
X  
X  8. If you wish to contribute ideas or money to help the production of
X  software like REMIND, you can reply to the address shown at the end of
X*** ../p5rel/Makefile	Thu Apr 22 10:24:10 1993
X--- ./Makefile	Fri Apr 23 13:00:44 1993
X***************
X*** 46,52 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.05
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X--- 46,52 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.06
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X***************
X*** 105,112 ****
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.5.tar $(MANIFEST)
X! 	compress -v remind-3.0.5.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X--- 105,112 ----
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.6.tar $(MANIFEST)
X! 	compress -v remind-3.0.6.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X*** ../p5rel/WHATSNEW.30	Thu Apr 22 10:24:22 1993
X--- ./WHATSNEW.30	Mon May  3 11:00:51 1993
X***************
X*** 1,5 ****
X--- 1,28 ----
X  CHANGES TO REMIND
X  
X+ * Version 3.0 Patch 6
X+ 
X+ + MINOR ENHANCEMENTS
X+ 
X+ - Added the PS- and PSFILE-type reminders - these allow you to include
X+   arbitrary PostScript code in your PostScript calendars.  Useful for
X+   shading, drawing graphics on calendars, etc.  Use with care, though!
X+ 
X+ - Added the "-ivar=val" option to initialize variables from the command
X+   line.  Changed the remind-all.* shell scripts to predefine the variable
X+   "remind_all".
X+ 
X+ + BUG FIXES
X+ 
X+ - Fixed a bug in the hebmon(), hebday() and hebyear() functions - there
X+   was an off-by-one error.  Sorry!
X+ 
X+ - Fixed a bug in the hebdate() function which resulted in infinite loops
X+   for dates after about 2075
X+ 
X+ - Fixed a bug in the -u option which sometimes caused a core dump
X+   (embarrassed grin!)  The fix is due to Tina Hoeltig.  Thanks, Tina!
X+ 
X  * Version 3.0 Patch 5
X  
X  + MAJOR ENHANCEMENTS:
X*** ../p5rel/calendar.c	Thu Apr 22 10:24:00 1993
X--- ./calendar.c	Mon May  3 12:01:29 1993
X***************
X*** 33,38 ****
X--- 33,39 ----
X  
X  /* Global variables */
X  static CalEntry *CalColumn[7];
X+ static CalEntry *CalPs[7];
X  
X  static int ColSpaces;
X  
X***************
X*** 614,619 ****
X--- 615,621 ----
X     int r;
X     int jul;
X     CalEntry *CurCol = CalColumn[col];
X+    CalEntry *CurPs = CalPs[col];
X     CalEntry *e;
X     char *s;
X  
X***************
X*** 626,635 ****
X--- 628,642 ----
X  #endif
X     if (trig.typ == NO_TYPE) return E_EOLN;
X     if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X+ 
X     /* Calculate the trigger date */
X     jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X     if (r) return r;
X+    if (!PsCal && (trig.typ == PS_TYPE || trig.typ == PSF_TYPE)) return OK;
X  
X+    /* Remove any "at" times from PS or PSFILE reminders */
X+    if (trig.typ == PS_TYPE || trig.typ == PSF_TYPE) tim.ttime = NO_TIME;
X+ 
X     /* If trigger date == today, add it to the current entry */   
X     if (jul == JulianToday) {
X        s = SubstBuffer;
X***************
X*** 646,656 ****
X           free(e);
X  	 return E_NO_MEM;
X        }
X!       e->pos = e->text;
X!       e->time = tim.ttime;
X!       e->next = CurCol;
X!       CalColumn[col] = e;
X!       SortColByTime(col);
X     }
X     return OK;
X  }
X--- 653,670 ----
X           free(e);
X  	 return E_NO_MEM;
X        }
X!       if (trig.typ == PS_TYPE || trig.typ == PSF_TYPE) {
X!          e->pos = (trig.typ == PS_TYPE) ? "P" : "F";
X! 	 e->time = NO_TIME;
X! 	 e->next = CurPs;
X! 	 CalPs[col] = e;
X!       } else {
X!          e->pos = e->text;
X!          e->time = tim.ttime;
X!          e->next = CurCol;
X!          CalColumn[col] = e;
X!          SortColByTime(col);
X!       }
X     }
X     return OK;
X  }
X***************
X*** 669,679 ****
X  int col, jul;
X  #endif
X  {
X!    CalEntry *e = CalColumn[col];
X     CalEntry *n;
X     int y, m, d;
X  
X     FromJulian(jul, &y, &m, &d);
X     while(e) {
X        printf("%04d%c%02d%c%02d ", y, DATESEP, m+1, DATESEP, d);
X        printf("%s\n", e->text);
X--- 683,707 ----
X  int col, jul;
X  #endif
X  {
X!    CalEntry *e = CalPs[col];
X     CalEntry *n;
X     int y, m, d;
X  
X+ /* Do all the PostScript entries first, if any */
X     FromJulian(jul, &y, &m, &d);
X+    while(e) {
X+       printf("%c%c%c%c%c%02d%c%02d ", *(e->pos), *(e->pos),
X+                                      *(e->pos), *(e->pos), DATESEP,
X+ 				     m+1, DATESEP, d);
X+       printf("%s\n", e->text);
X+       free(e->text);
X+       n = e->next;
X+       free(e);
X+       e = n;
X+    }
X+    CalPs[col] = NULL;
X+ 
X+    e = CalColumn[col];				     
X     while(e) {
X        printf("%04d%c%02d%c%02d ", y, DATESEP, m+1, DATESEP, d);
X        printf("%s\n", e->text);
X*** ../p5rel/defs.rem	Thu Apr 22 10:24:03 1993
X--- ./defs.rem	Mon May  3 10:29:12 1993
X***************
X*** 13,18 ****
X--- 13,19 ----
X  # Use your text editor to search for:					    #
X  #  "#USHOLS" for U.S. holidays						    #
X  #  "#JHOLS"  for Jewish holidays					    #
X+ #  "#PSSTUFF" for nifty PostScript examples				    #
X  # 									    #
X  # This file is part of REMIND.						    #
X  # Copyright (C) 1992, 1993 by David F. Skoll				    #
X***************
X*** 24,31 ****
X  ################################################
X  # Ensure required version of remind is used... #
X  ################################################
X! IF version() < "03.00.05"
X!    ERRMSG This file requires at least version 03.00.05 of Remind.%
X     ERRMSG This version is version [version()].
X     EXIT
X  ENDIF
X--- 25,32 ----
X  ################################################
X  # Ensure required version of remind is used... #
X  ################################################
X! IF version() < "03.00.06"
X!    ERRMSG This file requires at least version 03.00.06 of Remind.%
X     ERRMSG This version is version [version()].
X     EXIT
X  ENDIF
X***************
X*** 442,444 ****
X--- 443,476 ----
X     ENDIF
X     CAL [ORD(odays)] of Omer
X  ENDIF
X+ 
X+ #PSSTUFF
X+ ##########################################################################
X+ #								         #
X+ # This portion of the file contains some cute examples of the new        #
X+ # PS-type reminders.  You need a PostScript printer or viewer to         #
X+ # appreciate these.  To use them, pipe the output of remind -p into the  #
X+ # rem2ps program.                                                        #
X+ #								         #
X+ ##########################################################################
X+ 
X+ # Convenient to stick all the PostScript code in a string var - makes
X+ # reminders easier to understand.  The variable "shade" will contain
X+ # PostScript code to shade in a particular box on the calendar.
X+ SET shade \
X+ "/_A LineWidth 2 div def \
X+ _A _A moveto \
X+ BoxWidth _A sub _A lineto \
X+ BoxWidth _A sub BoxHeight _A sub lineto \
X+ _A BoxHeight _A sub lineto \
X+ closepath 0.95 setgray fill 0.0 setgray"
X+ 
X+ # The following reminder will shade the Saturday and Sunday calendar
X+ # entries. 
X+ REM Sat Sun PS [shade]
X+ 
X+ # The following will fill in the Hebrew dates on the calendar.  For this
X+ # example, I recommend that you use the "-sd 10" option for rem2ps.
X+ REM PS Border BoxHeight Border sub DaySize sub moveto \
X+    /DayFont findfont DaySize scalefont setfont \
X+    ([hebday(today())] [hebmon(today())]) show
X*** ../p5rel/dorem.c	Thu Apr 22 10:24:03 1993
X--- ./dorem.c	Fri Apr 30 13:16:27 1993
X***************
X*** 466,472 ****
X     int r, y, m, d;
X  
X     if (t->typ == RUN_TYPE && RunDisabled) return E_RUN_DISABLED;
X!    if (t->typ == CAL_TYPE) return OK;
X  
X  /* If it's a MSG-type reminder, and no -k option was used, issue the banner. */
X     if (t->typ == MSG_TYPE && !NumTriggered && !NextMode && !MsgCommand) {
X--- 466,473 ----
X     int r, y, m, d;
X  
X     if (t->typ == RUN_TYPE && RunDisabled) return E_RUN_DISABLED;
X!    if (t->typ == CAL_TYPE || t->typ == PS_TYPE || t->typ == PSF_TYPE)
X!       return OK;
X  
X  /* If it's a MSG-type reminder, and no -k option was used, issue the banner. */
X     if (t->typ == MSG_TYPE && !NumTriggered && !NextMode && !MsgCommand) {
X*** ../p5rel/hbcal.c	Thu Apr 22 10:24:38 1993
X--- ./hbcal.c	Mon May  3 11:34:29 1993
X***************
X*** 237,243 ****
X     ylen = DaysInHebYear(y);
X     monlen = DaysInHebMonths(ylen);
X     m = 0;
X!    while((jul > monlen[m]) || !monlen[m]) {
X        jul -= monlen[m];
X        m++;
X     }
X--- 237,243 ----
X     ylen = DaysInHebYear(y);
X     monlen = DaysInHebMonths(ylen);
X     m = 0;
X!    while((jul >= monlen[m]) || !monlen[m]) {
X        jul -= monlen[m];
X        m++;
X     }
X***************
X*** 424,431 ****
X  int julstart, hm, hd, jahr, *ans;
X  #endif
X  {
X!    int r, yout, mout, dout, jul;
X  
X     JulToHeb(julstart, &yout, &mout, &dout);
X  
X     r = 1;
X--- 424,435 ----
X  int julstart, hm, hd, jahr, *ans;
X  #endif
X  {
X!    int r, yout, mout, dout, jul=1;
X  
X+    /* I initialize jul above to stop gcc from complaining about
X+       possible use of uninitialized variable.  You can take it
X+       out if the small inefficiency really bothers you. */
X+ 
X     JulToHeb(julstart, &yout, &mout, &dout);
X  
X     r = 1;
X***************
X*** 437,442 ****
X--- 441,447 ----
X  	 continue;
X        }
X        jul = HebToJul(yout, mout, dout);
X+       if (jul < 0) return E_DATE_OVER;
X        if (jul >= julstart) break;
X        else {
X           yout++;
X*** ../p5rel/init.c	Thu Apr 22 10:24:09 1993
X--- ./init.c	Thu Apr 29 15:08:41 1993
X***************
X*** 63,68 ****
X--- 63,69 ----
X   *  -xn      = Max. number of iterations for SATISFY
X   *  -uname   = Run as user 'name' - only valid when run by root.
X   *  -kcmd    = Run 'cmd' for MSG-type reminders instead of printing to stdout
X+  *  -iVAR=EXPR = Initialize and preserve VAR.
X   *
X   **************************************************************/
X  
X***************
X*** 79,84 ****
X--- 80,87 ----
X  PRIVATE void ChgUser ARGS((char *uname));
X  #endif
X  
X+ PRIVATE void InitializeVar ARGS ((char *str));
X+ 
X  static char *BadDate = "Illegal date on command line\n";
X  
X  /***************************************************************/
X***************
X*** 123,128 ****
X--- 126,137 ----
X  
X        while (*arg) {
X           switch(*arg++) {
X+             case 'i':
X+ 	    case 'I':
X+ 	       InitializeVar(arg);
X+ 	       while(*arg) arg++;
X+ 	       break;
X+ 	   
X  	    case 'n':
X  	    case 'N':
X  	       NextMode = 1;
X***************
X*** 393,398 ****
X--- 402,408 ----
X     fprintf(ErrFp, " -x[n]  Iteration limit for SATISFY clause (def=150)\n");
X     fprintf(ErrFp, " -kcmd  Run 'cmd' for MSG-type reminders\n");
X     fprintf(ErrFp, " -g[d[d]] Sort reminders by date and time before issuing\n");
X+    fprintf(ErrFp, "-ivar=val Initialize var to val and preserve var\n");
X     exit(1);
X  }
X  
X***************
X*** 456,462 ****
X     sprintf(home, "HOME=%s", pwent->pw_dir);
X     putenv(home);
X  
X!    shell = malloc(strlen(pwent->pw_dir) + 7);
X     if (!shell) {
X        fprintf(ErrFp, NoEnvMem);
X        exit(1);
X--- 466,472 ----
X     sprintf(home, "HOME=%s", pwent->pw_dir);
X     putenv(home);
X  
X!    shell = malloc(strlen(pwent->pw_shell) + 7);
X     if (!shell) {
X        fprintf(ErrFp, NoEnvMem);
X        exit(1);
X***************
X*** 483,485 ****
X--- 493,550 ----
X  }
X  #endif /* UNIX && WANT_U_OPTION */
X     
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  InitializeVar                                              */
X+ /*                                                             */
X+ /*  Initialize and preserve a variable                         */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE void InitializeVar(char *str)
X+ #else
X+ static void InitializeVar(str)
X+ char *str;
X+ #endif
X+ {
X+    char *varname, *expr;
X+    static char Err[] = "Remind: -i option: %s\n";
X+ 
X+    Value val;
X+ 
X+    int r;
X+ 
X+    /* Scan for an '=' sign */
X+    varname = str;
X+    while (*str && *str != '=') str++;
X+    if (!*str) {
X+       fprintf(ErrFp, Err, "Missing '=' sign");
X+       return;
X+    }
X+    *str = 0;
X+    if (!*varname) {
X+       fprintf(ErrFp, Err, "Missing varname");
X+       return;
X+    }
X+    expr = str+1;
X+    if (!*expr) {
X+       fprintf(ErrFp, Err, "Missing expr");
X+       return;
X+    }
X+ 
X+    r=EvalExpr(&expr, &val);
X+    if (r) {
X+       fprintf(ErrFp, Err, ErrMsg[r]);
X+       return;
X+    }
X+ 
X+    r=SetVar(varname, &val);
X+    if (r) {
X+       fprintf(ErrFp, Err, ErrMsg[r]);
X+       return;
X+    }
X+    r=PreserveVar(varname);
X+    if (r) fprintf(ErrFp, Err, ErrMsg[r]);
X+    return;
X+ }
X+ 
X*** ../p5rel/makefile.os2	Thu Apr 22 10:24:11 1993
X--- ./makefile.os2	Fri Apr 23 13:00:11 1993
X***************
X*** 25,31 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.05
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finish.h
X--- 25,31 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.06
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finish.h
X*** ../p5rel/makefile.tc	Thu Apr 22 10:24:11 1993
X--- ./makefile.tc	Fri Apr 23 13:00:07 1993
X***************
X*** 1,6 ****
X  # Makefile for REMIND for Turbo C for MSDOS
X  
X! VERSION= 03.00.05
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X--- 1,6 ----
X  # Makefile for REMIND for Turbo C for MSDOS
X  
X! VERSION= 03.00.06
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X*** ../p5rel/queue.c	Thu Apr 22 10:24:12 1993
X--- ./queue.c	Thu Apr 29 16:29:18 1993
X***************
X*** 270,282 ****
X     printf("Contents of AT queue:%s", NL);
X  
X     while (q) {
X!       printf("Trigger: %02d%c%02d  Activate: %02d%c%02d  Rep: %d  Delta: %d%s",
X!               q->tt.ttime / 60, TIMESEP, q->tt.ttime % 60,
X! 	      q->tt.nexttime / 60, TIMESEP, q->tt.nexttime % 60,
X!               q->tt.rep, q->tt.delta, NL);
X!       printf("Text: %s %s%s%s", ((q->typ == MSG_TYPE) ? "MSG" : "RUN"),
X!               q->text,
X!               NL, NL);
X        q = q->next;
X     }
X     printf(NL);
X--- 270,284 ----
X     printf("Contents of AT queue:%s", NL);
X  
X     while (q) {
X!       if (q->tt.nexttime != NO_TIME) {
X!          printf("Trigger: %02d%c%02d  Activate: %02d%c%02d  Rep: %d  Delta: %d%s",
X!                  q->tt.ttime / 60, TIMESEP, q->tt.ttime % 60,
X!                  q->tt.nexttime / 60, TIMESEP, q->tt.nexttime % 60,
X!                  q->tt.rep, q->tt.delta, NL);
X!          printf("Text: %s %s%s%s", ((q->typ == MSG_TYPE) ? "MSG" : "RUN"),
X!                  q->text,
X!                  NL, NL);
X!       }
X        q = q->next;
X     }
X     printf(NL);
X*** ../p5rel/rem2ps.1	Thu Apr 22 10:24:28 1993
X--- ./rem2ps.1	Mon May  3 15:27:50 1993
X***************
X*** 10,15 ****
X--- 10,21 ----
X  draws a calendar) to the standard output.
X  .SH OPTIONS
X  .TP
X+ .B \-p file
X+ Include the contents of \fIfile\fR in the PostScript prologue.  This
X+ allows you to define procedures, variables etc. which can be used
X+ by the \fBPS\fR and \fBPSFILE\fR reminders.  You should not
X+ include any document structuring comments in your prologue.
X+ .TP
X  .B \-l
X  Produce the calendar in landscape mode rather than the default
X  portrait mode.
X***************
X*** 147,152 ****
X--- 153,269 ----
X  entries from the reminder file "~/.reminders."  The calendar is produced
X  in landscape mode, with a font size of 18 for the day numbers.  The result
X  is put in the PostScript file "cal.ps."
X+ .PP
X+ .SH VARIABLES AVAILABLE TO USER-SUPPLIED POSTSCRIPT CODE
X+ .PP
X+ The following variables are available to \fBPS\fR and 
X+ \fBPSFILE\fR-type reminders.  (This material is duplicated
X+ in the \fBRemind\fR manual page.)
X+ .TP
X+ LineWidth
X+ The width of the black grid lines making up the calendar.
X+ .TP
X+ Border
X+ The border between the center of the grid lines and the space used to print
X+ calendar entries.  This border is normally blank space.
X+ .TP
X+ BoxWidth and BoxHeight
X+ The width and height of the calendar box, from center-to-center of the
X+ black gridlines.
X+ .TP
X+ InBoxHeight
X+ The height from the center of the bottom black gridline to the top
X+ of the regular calendar entry area.  The space from here to the top
X+ of the box is used only to draw the day number.
X+ .TP
X+ /DayFont, /EntryFont, /SmallFont and /HeadFont
X+ The fonts used to draw the day numbers, the calendar entries, the small
X+ calendars, and the month and day headings, respectively.
X+ .TP
X+ DaySize, EntrySize and HeadSize
X+ The sizes of the above fonts.  (The size of the small calendar font
X+ is \fInot\fR defined here.)  For example, if you wanted to print
X+ the Hebrew date next to the regular day number in the calendar, use:
X+ .PP
X+ .nf
X+ 	REM PS Border BoxHeight Border sub DaySize sub moveto \\
X+ 	   /DayFont findfont DaySize scalefont setfont \\
X+ 	   ([hebday(today())] [hebmon(today())]) show
X+ .fi
X+ .PP
X+ .RS
X+ Note how /DayFont and DaySize are used.
X+ .RE
X+ .PP
X+ Note that if you supply PostScript code, it is possible to produce invalid
X+ PostScript files.  Always test your PostScript thoroughly with a PostScript
X+ viewer before sending it to the printer.  You should not use any document
X+ structuring comments in your PostScript code.
X+ .PP
X+ In addition, prior to drawing a calendar page, \fBRem2ps\fR emits
X+ the following PostScript code:
X+ .PP
X+ .nf
X+ 	save (mon) (yr) PreCal restore
X+ .fi
X+ .PP
X+ where \fImon\fR and \fIyr\fR are the month and year of the calendar
X+ page.  The default \fBPreCal\fR procedure simply pops
X+ the arguments and does nothing.  However, you can define a \fBPreCal\fR
X+ function in your prologue file to do whatever you want - it can draw a
X+ background for the entire calendar, for instance.
X+ .PP
X+ In the context of the \fBPreCal\fR procedure, the following conditions
X+ hold:
X+ .TP
X+ o
X+ The PostScript origin is at the bottom left-hand corner of the page, and
X+ PostScript units of 1/72" are in effect.
X+ .TP
X+ o
X+ The variables MinX, MinY, MaxX and MaxY define the bounding box within
X+ which the calendar will be drawn.
X+ .TP
X+ o
X+ The font and font-size variables, as well as Border and LineWidth described
X+ previously, are valid.
X+ .PP
X+ For an example, create a file called "myprolog" whose contents are:
X+ .PP
X+ .nf
X+ 		/PreCal {
X+ 		 /yr exch def
X+ 		 /mon exch def
X+ 		 /xsiz1 MaxX MinX sub def
X+ 		 /ysiz1 MaxY MinY sub def
X+ 		 /xsiz xsiz1 MinX sub MinX sub def
X+ 		 /ysiz ysiz1 MinY sub MinY sub def
X+ 		 xsiz
X+ 		 ysiz
X+ 		 lt
X+ 		 {/len xsiz 1.41 mul def
X+ 		  MinX MinX add ysiz1 xsiz1 sub 2 div MinY add MinY add moveto}
X+ 		 {/len ysiz 1.41 mul def
X+ 		  xsiz1 ysiz1 sub 2 div MinX add MinX add MinY MinY add moveto}
X+ 		 ifelse
X+ 		 /Helvetica-Bold findfont 1 scalefont setfont
X+ 		 mon stringwidth pop
X+ 		 ( ) stringwidth pop add
X+ 		 yr stringwidth pop add
X+ 		 len exch div /len exch def
X+ 		 /Helvetica-Bold findfont len scalefont setfont
X+ 		 0.95 setgray
X+ 		 45 rotate
X+ 		 mon show
X+ 		 ( ) show
X+ 		 yr show
X+ 		} bind def
X+ .fi
X+ .PP
X+ Use that file with the \fBRem2ps\fR \fB\-p\fR option to create calendars
X+ with the year and month in large grey letters in the background of the
X+ calendar.
X+ .PP
X  .SH AUTHOR
X  David F. Skoll
X  .SH BUGS
X*** ../p5rel/rem2ps.c	Thu Apr 22 10:24:26 1993
X--- ./rem2ps.c	Mon May  3 10:37:57 1993
X***************
X*** 68,74 ****
X  
X  #define NUMPAGES (sizeof(Pages)/sizeof(Pages[0]))
X  
X! CalEntry *CurEntries;
X  PageType *CurPage;
X  char PortraitMode;
X  char NoSmallCal;
X--- 68,75 ----
X  
X  #define NUMPAGES (sizeof(Pages)/sizeof(Pages[0]))
X  
X! CalEntry *CurEntries = NULL;
X! CalEntry *PsEntries[32];
X  PageType *CurPage;
X  char PortraitMode;
X  char NoSmallCal;
X***************
X*** 87,92 ****
X--- 88,95 ----
X  char *EntrySize="8";
X  char *BorderSize = "6";
X  
X+ char *UserProlog = NULL;
X+ 
X  int validfile = 0;
X  
X  int CurDay;
X***************
X*** 99,104 ****
X--- 102,108 ----
X  void Init ARGS ((int argc, char *argv[]));
X  void Usage ARGS ((char *s));
X  void DoPsCal ARGS ((void));
X+ int DoQueuedPs ARGS ((void));
X  void DoSmallCal ARGS((char *m, int days, int first, int col));
X  void WriteProlog ARGS ((void));
X  void WriteCalEntry ARGS ((void));
X***************
X*** 160,165 ****
X--- 164,170 ----
X     int sfirst;
X     int i;
X     int smallcol;
X+    int is_ps;
X     CalEntry *c, *d;
X  
X     printf("%%%%Page: %d %d\n", validfile, validfile);
X***************
X*** 175,180 ****
X--- 180,186 ----
X  
X  /* Emit PostScript to do the heading */
X     if (!PortraitMode) printf("XSIZE 0 translate 90 rotate\n");
X+    printf("/SAVESTATE save def (%s) (%s) PreCal SAVESTATE restore\n", month, year);
X     printf("(%s %s) doheading\n", month, year);
X  
X  /* Calculate the minimum box size */
X***************
X*** 215,234 ****
X           fprintf(stderr, "malloc failed - aborting.\n");
X  	 exit(1);
X        }
X        c->next = NULL;
X!       c->entry = malloc(strlen(LineBuffer+10) + 1);
X        if (!c->entry) {
X           fprintf(stderr, "malloc failed - aborting.\n");
X  	 exit(1);
X        }
X!       strcpy(c->entry, LineBuffer+10);
X  
X  /* Put on linked list */
X!       if (!CurEntries) CurEntries = c;
X!       else {
X!          d = CurEntries;
X! 	 while(d->next) d = d->next;
X! 	 d->next = c;
X        }
X     }
X     for(; CurDay<=days; CurDay++) {
X--- 221,248 ----
X           fprintf(stderr, "malloc failed - aborting.\n");
X  	 exit(1);
X        }
X+       is_ps = (*LineBuffer == 'F' || *LineBuffer == 'P');
X        c->next = NULL;
X!       c->entry = malloc(strlen(LineBuffer+10) + 1 + is_ps);
X        if (!c->entry) {
X           fprintf(stderr, "malloc failed - aborting.\n");
X  	 exit(1);
X        }
X!       strcpy(c->entry+is_ps, LineBuffer+10);
X  
X+       if (is_ps) {
X+ /* Save the 'P' or 'F' flag */
X+          *(c->entry) = *LineBuffer;
X+ 	 c->next = PsEntries[DayNum];
X+ 	 PsEntries[DayNum] = c;
X+       } else {
X  /* Put on linked list */
X!          if (!CurEntries) CurEntries = c;
X!          else {
X!             d = CurEntries;
X!    	    while(d->next) d = d->next;
X! 	    d->next = c;
X! 	 }
X        }
X     }
X     for(; CurDay<=days; CurDay++) {
X***************
X*** 281,286 ****
X--- 295,303 ----
X     int x = CurPage->xsize;
X     int y = CurPage->ysize;
X     char *isostuff;
X+    FILE *fp;
X+    int nread;
X+    char buffer[LINELEN];
X  
X     if (!PortraitMode) {
X        i = x; x = y; y = i;
X***************
X*** 325,330 ****
X--- 342,348 ----
X     printf("/MaxX %d def\n", x-RightMarg);
X     printf("/MaxY %d def\n", y-TopMarg);
X     printf("/Border %s def\n", BorderSize);
X+    printf("/LineWidth %s def\n", LineWidth);
X     printf("%s setlinewidth\n", LineWidth);
X  
X  /* Check if smallfont is fixed pitch */
X***************
X*** 335,343 ****
X        printf("{/SmallString (WW ) def}\n");
X        printf("{/SmallString (WW) def}\nifelse\n");
X     }
X     printf("%%%%EndProlog\n");
X- /* Set the minimum box size */
X  
X  }
X  
X  /***************************************************************/
X--- 353,377 ----
X        printf("{/SmallString (WW ) def}\n");
X        printf("{/SmallString (WW) def}\nifelse\n");
X     }
X+ 
X+ /* Do the user-supplied prolog file, if any */
X+    if (UserProlog) {
X+       fp = fopen(UserProlog, "r");
X+       if (!fp) {
X+          fprintf(stderr, "Could not open prologue file '%s'\n", UserProlog);
X+       } else {
X+          while(1) {
X+ 	    nread = fread(buffer, sizeof(char), LINELEN, fp);
X+ 	    if (!nread) break;
X+ 	    fwrite(buffer, sizeof(char), nread, stdout);
X+          }
X+          fclose(fp);
X+       }
X+    }
X+ 
X     printf("%%%%EndProlog\n");
X  
X+ 
X  }
X  
X  /***************************************************************/
X***************
X*** 353,360 ****
X--- 387,396 ----
X  {
X     CalEntry *c = CurEntries;
X     CalEntry *d;
X+    int begin, end, i, HadQPS;
X  
X  /* Move to appropriate location */
X+    printf("/CAL%d {\n", CurDay);
X     printf("Border ytop %d xincr mul MinX add xincr\n", WkDayNum);
X  
X  /* Set up the text array */
X***************
X*** 378,386 ****
X  
X  /* Update ymin */
X     printf("/y exch def y ymin lt {/ymin y def} if\n");
X  
X! /* If WkDayNum is a Sunday, move to next row. */
X     if (WkDayNum == 6 || CurDay == MaxDay) {
X        printf("/y ytop MinBoxSize sub def y ymin lt {/ymin y def} if\n");
X  
X  /* Draw the line at the bottom of the row */
X--- 414,440 ----
X  
X  /* Update ymin */
X     printf("/y exch def y ymin lt {/ymin y def} if\n");
X+    printf("} def\n");
X  
X! /* If WkDayNum is a Sunday, move to next row.  Also handle the queued
X!    PS and PSFILE reminders */
X     if (WkDayNum == 6 || CurDay == MaxDay) {
X+       HadQPS = 0;
X+       begin = CurDay - WkDayNum;
X+       if (begin < 1) begin = 1;
X+       end = CurDay;
X+       for (i=begin; i<=end; i++) {
X+ 	 if (PsEntries[i]) {
X+ 	    HadQPS = 1;
X+ 	    break;
X+          }
X+       }
X+       /* Avoid problems with blotching if PS printer has roundoff errors */
X+       if (HadQPS) printf("1 setgray\n");
X+       for (i=begin; i<=end; i++) {
X+          printf("CAL%d\n", i);
X+       }
X+       if (HadQPS) printf("0 setgray\n");
X        printf("/y ytop MinBoxSize sub def y ymin lt {/ymin y def} if\n");
X  
X  /* Draw the line at the bottom of the row */
X***************
X*** 389,394 ****
X--- 443,462 ----
X  /* Update ytop */
X        printf("/ylast ytop def\n");
X        printf("/ytop ymin def\n");
X+ 
X+       (void) DoQueuedPs();
X+ 
X+ /* Re-do the calendar stuff if there was any included PS code */
X+       if (HadQPS) {
X+          printf("/ytop ylast def\n");
X+          for (i=begin; i<=end; i++) {
X+             printf("CAL%d\n", i);
X+          }
X+          printf("/y ytop MinBoxSize sub def y ymin lt {/ymin y def} if\n");
X+          printf("MinX ymin MaxX ymin L\n");
X+          printf("/ylast ytop def\n");
X+ 	 printf("/ytop ymin def\n");
X+       }
X     }
X  }
X  
X***************
X*** 454,459 ****
X--- 522,529 ----
X     BotMarg = 36;
X     UseISO = 0;
X  
X+    for(j=0; j<32; j++) PsEntries[i] = NULL;
X+ 
X     CurPage = DefaultPage;  /* Letter size by default */
X  
X     while (i < argc) {
X***************
X*** 463,468 ****
X--- 533,543 ----
X        if (*s++ != '-') Usage("Options must begin with '-'");
X  
X        switch(*s++) {
X+          case 'p':
X+ 	    if (i == argc) Usage("Prologue filename must be supplied");
X+ 	    UserProlog = argv[i++];
X+ 	    break;
X+ 
X           case 's':
X  	    if (i == argc) Usage("Size must be supplied");
X  	    t = argv[i++];
X***************
X*** 564,580 ****
X     fprintf(stderr, "Rem2PS: Produce a PostScript calendar from output of Remind.\n\n");
X     fprintf(stderr, "Usage: rem2ps [options]\n\n");
X     fprintf(stderr, "Options:\n\n");
X!    fprintf(stderr, "-l            Do calendar in landscape mode.\n");
X     fprintf(stderr, "-c            Do NOT generate small calendars for previous\n");
X!    fprintf(stderr, "              and next month.\n");
X     fprintf(stderr, "-i            Use ISO 8859-1 encoding in PostScript output\n");
X     fprintf(stderr, "-m media      Set page size (eg, Letter, Legal, A4.)  Case sensitive!\n");
X     fprintf(stderr, "              (Default page size is %s)\n", DefaultPage[0].name);
X!    fprintf(stderr, "-f[shed] font Set font for small cal, hdr, cal entries and/or day numbers.\n");
X!    fprintf(stderr, "-s[hed] size  Set size for header, calendar entries and/or day numbers.\n");
X!    fprintf(stderr, "-b size       Set border size for calendar entries.\n");
X!    fprintf(stderr, "-t size       Set line thickness.\n");
X!    fprintf(stderr, "-o[lrtb] marg Specify left, right, top and bottom margins.\n");
X     exit(1);
X  }
X  
X--- 639,656 ----
X     fprintf(stderr, "Rem2PS: Produce a PostScript calendar from output of Remind.\n\n");
X     fprintf(stderr, "Usage: rem2ps [options]\n\n");
X     fprintf(stderr, "Options:\n\n");
X!    fprintf(stderr, "-p file       Include user-supplied PostScript code in prologue\n");
X!    fprintf(stderr, "-l            Do calendar in landscape mode\n");
X     fprintf(stderr, "-c            Do NOT generate small calendars for previous\n");
X!    fprintf(stderr, "              and next month\n");
X     fprintf(stderr, "-i            Use ISO 8859-1 encoding in PostScript output\n");
X     fprintf(stderr, "-m media      Set page size (eg, Letter, Legal, A4.)  Case sensitive!\n");
X     fprintf(stderr, "              (Default page size is %s)\n", DefaultPage[0].name);
X!    fprintf(stderr, "-f[shed] font Set font for small cal, hdr, cal entries and/or day numbers\n");
X!    fprintf(stderr, "-s[hed] size  Set size for header, calendar entries and/or day numbers\n");
X!    fprintf(stderr, "-b size       Set border size for calendar entries\n");
X!    fprintf(stderr, "-t size       Set line thickness\n");
X!    fprintf(stderr, "-o[lrtb] marg Specify left, right, top and bottom margins\n");
X     exit(1);
X  }
X  
X***************
X*** 632,634 ****
X--- 708,782 ----
X     printf("grestore\n");
X  }
X  
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  DoQueuedPs - do the queued PS and PSFILE reminders.        */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PUBLIC int DoQueuedPs(void)
X+ #else
X+ int DoQueuedPs()
X+ #endif
X+ {
X+    int i;
X+    int HadPS = 0;
X+    int wd;
X+    int begin, end;
X+    int nread;
X+    CalEntry *e, *n;
X+    FILE *fp;
X+    int fnoff;
X+    char buffer[LINELEN];
X+ 
X+    begin = CurDay - WkDayNum;
X+    wd = 0;
X+    while (begin < 1) begin++, wd++;
X+    end = CurDay;
X+    for (i=begin; i<=end; i++, wd++) {
X+       e = PsEntries[i];
X+ 
X+       if (e) {
X+          HadPS = 1;
X+          printf("/SAVESTATE save def\n");
X+ 
X+          /* Translate coordinates to bottom of calendar box */
X+          printf("%d xincr mul MinX add ytop translate\n", wd);
X+ 
X+          /* Set up convenient variables */
X+          printf("/BoxWidth xincr def\n/BoxHeight ylast ytop sub def\n");
X+ 	 printf("/InBoxHeight BoxHeight border sub DaySize sub DaySize sub 2 add EntrySize add def \n");
X+       }
X+ 
X+       while (e) {
X+ 
X+ /* Now do the user's PostScript code */
X+          fnoff = 1;
X+ 	 while (isspace(*(e->entry+fnoff))) fnoff++;
X+          if (*(e->entry) == 'P') {
X+ 	    printf("%s\n", e->entry+fnoff);
X+          } else {
X+ 	    fp = fopen(e->entry+fnoff, "r");
X+ 	    if (!fp) {
X+ 	       fprintf(stderr, "Could not open PostScript file '%s'\n", e->entry+1);
X+             } else {
X+ 	       while(1) {
X+ 	          nread = fread(buffer, sizeof(char), LINELEN, fp);
X+ 		  if (!nread) break;
X+ 		  fwrite(buffer, sizeof(char), nread, stdout);
X+                }
X+ 	       fclose(fp);
X+             }
X+          }
X+ 
X+ /* Free the entry */
X+          free(e->entry);
X+ 	 n = e->next;
X+ 	 free(e);
X+ 	 e = n;
X+       }
X+       if (PsEntries[i]) printf("\n SAVESTATE restore\n");
X+       PsEntries[i] = NULL;
X+    }
X+    return HadPS;
X+ }
X*** ../p5rel/rem2ps.h	Thu Apr 22 10:24:26 1993
X--- ./rem2ps.h	Mon May  3 10:36:51 1993
X***************
X*** 11,16 ****
X--- 11,18 ----
X  
X  char *PSProlog1[] =
X  {
X+    "% This file was produced by Remind and Rem2PS, written by",
X+    "% David F. Skoll.",
X     "/ISOLatin1Encoding where { pop save true }{ false } ifelse",
X     "  /ISOLatin1Encoding [ StandardEncoding 0 45 getinterval aload pop /minus",
X     "    StandardEncoding 46 98 getinterval aload pop /dotlessi /grave /acute",
X***************
X*** 200,204 ****
X--- 202,208 ----
X     "    forall",
X     "} bind def",
X     "2 setlinecap",
X+    "% Define a default PreCal procedure",
X+    "/PreCal { pop pop } bind def",
X     NULL
X  };
X*** ../p5rel/remind-all.csh	Thu Apr 22 10:24:14 1993
X--- ./remind-all.csh	Tue Apr 27 11:00:15 1993
X***************
X*** 31,40 ****
X  # Scan each user's directory for a .reminders file
X  foreach i ($USERS)
X     if (-r ~$i/.reminders) then
X- 
X  #     echo "$i has a .reminders file."     DEBUGGING PURPOSES ONLY
X  
X!       $REMIND -u$i -h -r -q ~$i/.reminders < /dev/null > $REMFILE
X        if (! -z $REMFILE) then
X  #        echo "Sending mail to $i"         DEBUGGING PURPOSES ONLY
X  
X--- 31,39 ----
X  # Scan each user's directory for a .reminders file
X  foreach i ($USERS)
X     if (-r ~$i/.reminders) then
X  #     echo "$i has a .reminders file."     DEBUGGING PURPOSES ONLY
X  
X!       $REMIND -u$i -h -r -q -iremind_all=1 ~$i/.reminders < /dev/null > $REMFILE
X        if (! -z $REMFILE) then
X  #        echo "Sending mail to $i"         DEBUGGING PURPOSES ONLY
X  
X*** ../p5rel/remind-all.sh	Thu Apr 22 10:24:14 1993
X--- ./remind-all.sh	Tue Apr 27 10:59:25 1993
X***************
X*** 36,42 ****
X  
X  #     echo "$i has a .reminders file."     DEBUGGING PURPOSES ONLY
X  
X!       $REMIND -u$i -h -r -q $HOME/.reminders < /dev/null > $REMFILE
X        if [ -s $REMFILE ]; then
X  #        echo "Sending mail to $i"         DEBUGGING PURPOSES ONLY
X           $MAIL -s "Reminders" $i < $REMFILE
X--- 36,42 ----
X  
X  #     echo "$i has a .reminders file."     DEBUGGING PURPOSES ONLY
X  
X!       $REMIND -u$i -h -r -q -iremind_all=1 $HOME/.reminders < /dev/null > $REMFILE
X        if [ -s $REMFILE ]; then
X  #        echo "Sending mail to $i"         DEBUGGING PURPOSES ONLY
X           $MAIL -s "Reminders" $i < $REMFILE
X*** ../p5rel/remind.1	Thu Apr 22 10:24:17 1993
X--- ./remind.1	Mon May  3 15:28:18 1993
X***************
X*** 175,180 ****
X--- 175,185 ----
X  and user name, respectively, of the specified user.  LOGNAME is also
X  set to the specified user name.  This option is meant for
X  use in shell scripts which mail reminders to all users.
X+ .TP
X+ \fB\-i\fR\fIvar\fR\fB=\fR\fIexpr\fR
X+ Sets the value of the specified \fIvar\fR to \fIexpr\fR, and \fBpreserves\fR
X+ \fIvar\fR.  \fIExpr\fR can be any valid \fBRemind\fR expression.  See the
X+ section "Initializing Variables on the Command Line" for more details.
X  .PP
X  If you supply a \fIdate\fR on the command line, it must consist of
X  \fIday month year\fR, where \fIday\fR is the day of the month,
X***************
X*** 233,245 ****
X  [\fBAT\fR \fItime\fR [\fItdelta\fR] [\fItrepeat\fR]]
X  [\fBUNTIL\fR \fIexpiry_date\fR]
X  [\fBSCANFROM\fR \fIscan_date\fR]
X! \fBMSG\fR | \fBRUN\fR | \fBCAL\fR | \fBSATISFY\fR
X  .I body
X  .RE
X  .PP
X  The parts of the \fBREM\fR command can be specified in any order, except
X  that the \fIbody\fR must come immediately after the \fBMSG\fR,
X! \fBRUN\fR, \fBCAL\fR or \fBSATISFY\fR keyword.
X  .PP
X  The \fBREM\fR token is optional, providing that the remainder
X  of the command cannot be mistaken for another \fBRemind\fR command
X--- 238,250 ----
X  [\fBAT\fR \fItime\fR [\fItdelta\fR] [\fItrepeat\fR]]
X  [\fBUNTIL\fR \fIexpiry_date\fR]
X  [\fBSCANFROM\fR \fIscan_date\fR]
X! \fBMSG\fR | \fBRUN\fR | \fBCAL\fR | \fBSATISFY\fR | \fBPS\fR | \fBPSFILE\fR
X  .I body
X  .RE
X  .PP
X  The parts of the \fBREM\fR command can be specified in any order, except
X  that the \fIbody\fR must come immediately after the \fBMSG\fR,
X! \fBRUN\fR, \fBCAL\fR, \fBPS\fR, \fBPSFILE\fR or \fBSATISFY\fR keyword.
X  .PP
X  The \fBREM\fR token is optional, providing that the remainder
X  of the command cannot be mistaken for another \fBRemind\fR command
X***************
X*** 247,255 ****
X  before the \fBMSG\fR, \fBRUN\fR, \fBCAL\fR or \fBSATISFY\fR clause
X  is called a \fItrigger\fR.
X  .PP
X! .B MSG, RUN, and CAL
X  .PP
X! The keywords \fBMSG\fR, \fBRUN\fR and \fBCAL\fR denote the \fItype\fR
X  of the reminder.  (\fBSATISFY\fR is more complicated and will be explained
X  later.)  A \fBMSG\fR-type reminder normally prints a message to the standard
X  output, after passing the \fIbody\fR through a special substitution filter,
X--- 252,260 ----
X  before the \fBMSG\fR, \fBRUN\fR, \fBCAL\fR or \fBSATISFY\fR clause
X  is called a \fItrigger\fR.
X  .PP
X! .B MSG, RUN, CAL, PS and PSFILE
X  .PP
X! These keywords denote the \fItype\fR
X  of the reminder.  (\fBSATISFY\fR is more complicated and will be explained
X  later.)  A \fBMSG\fR-type reminder normally prints a message to the standard
X  output, after passing the \fIbody\fR through a special substitution filter,
X***************
X*** 264,269 ****
X--- 269,283 ----
X  is used only to place entries in the calendar produced when \fBRemind\fR
X  is run with the \fB\-c\fR, \fB\-s\fR or \fB\-p\fR options.
X  .PP
X+ A \fBPS\fR or \fBPSFILE\fR-type reminder is used to pass PostScript code
X+ directly to the printer when producing PostScript calendars.  This can
X+ be used to shade certain calendar entries, include graphics in the calendar,
X+ or almost any other purpose you can think of.  You
X+ should not use these types of reminders unless you are an expert PostScript
X+ programmer.  The \fBPS\fR and \fBPSFILE\fR reminders are ignored unless
X+ \fBRemind\fR is run with the \fB\-p\fR option.  See the section
X+ "More about PostScript" for more details.
X+ .PP
X  .B DATE SPECIFICATIONS
X  .PP
X  A \fIdate_spec\fR consists of zero to four parts.
X***************
X*** 2267,2272 ****
X--- 2281,2389 ----
X  places the time of timed reminders in the calendar according to the
X  \fB\-b\fR command-line option.
X  .PP
X+ .SH INITIALIZING VARIABLES ON THE COMMAND LINE
X+ .PP
X+ The \fB\-i\fR option is used to initialize variables on the \fBRemind\fR
X+ command line.  The format is \fB\-i\fR\fIvar\fR\fB=\fR\fIexpr\fR, where
X+ \fIexpr\fR is any valid expression.  Note that you may have to use quotes
X+ or escapes to prevent the shell from interpreting special characters in
X+ \fIexpr\fR.  You can have as many \fB\-i\fR options as you want on the
X+ command line, and they are processed in order.  Thus, if a variable is defined
X+ in one \fB\-i\fR option, it can be referred to by subsequent \fB\-i\fR
X+ options.
X+ .PP
X+ Note that if you supply a date on the command line, it is not parsed until
X+ all options have been processed.  Thus, if you use \fBtoday()\fR in any
X+ of the \fB\-i\fR expressions, it will return the same value as
X+ \fBrealtoday()\fR and not the date supplied on the command line.
X+ .PP
X+ Any variables defined on the command line are \fBpreserved\fR as with the
X+ \fBPRESERVE\fR command.
X+ .PP
X+ You should not have any spaces between the \fB\-i\fR option and the equal
X+ sign; otherwise, strange variable names are created which can only be accessed
X+ with the \fBvalue()\fR or \fBdefined()\fR functions.
X+ .PP
X+ If your site uses the \fBRemind-all\fR shell script to mail reminders
X+ to users, the script will initialize the variable \fIremind_all\fR to 1
X+ using the \fB\-i\fR option.  Thus, you can detect when your reminder
X+ script is being processed by \fBRemind-all\fR and can use this information
X+ to control which reminders you want mailed to you.
X+ .PP
X+ .SH MORE ABOUT POSTSCRIPT
X+ .PP
X+ The \fBPS\fR and \fBPSFILE\fR reminders pass PostScript code directly
X+ to the printer.  They differ in that the \fBPS\fR-type reminder passes
X+ its body directly to the PostScript output (after processing by the
X+ substitution filter) while the \fBPSFILE\fR-type's body should
X+ simply consist of a filename.  The \fBRem2ps\fR program will open the
X+ file named in the \fBPSFILE\fR-type reminder, and include its contents in
X+ the PostScript output.
X+ .PP
X+ The PostScript-type reminders for a particular day are included in the
X+ PostScript output in the same order they were triggered in the \fBRemind\fR
X+ script file.  All of the PostScript code for a particular date is enclosed
X+ in a \fBsave\fR-\fBrestore\fR pair.  However, if several PostScript-type
X+ reminders are triggered for a single day, each section of PostScript is
X+ not enclosed in a \fBsave\fR-\fBrestore\fR pair - instead, the entire
X+ body of included PostScript is enclosed.
X+ .PP
X+ PostScript-type reminders are executed by the PostScript printer before any
X+ regular calendar entries.  Thus, regular calendar entries will overlay
X+ the PostScript-type reminders, allowing you to create shaded or graphical
X+ backgrounds for particular days.
X+ .PP
X+ Before executing your PostScript code, the origin of the PostScript coordinate
X+ system is positioned to the bottom left-hand corner of the "box" in the
X+ calendar representing \fBtoday()\fR.  This location is exactly in the middle
X+ of the intersection of the bottom and left black lines delineating the box -
X+ you may have to account for the thickness of these lines when calculating
X+ positions.
X+ .PP
X+ Several PostScript variables are available to the PostScript code you supply.
X+ All distance and size variables are in PostScript units (1/72 inch.)  The
X+ variables are:
X+ .TP
X+ LineWidth
X+ The width of the black grid lines making up the calendar.
X+ .TP
X+ Border
X+ The border between the center of the grid lines and the space used to print
X+ calendar entries.  This border is normally blank space.
X+ .TP
X+ BoxWidth and BoxHeight
X+ The width and height of the calendar box, from center-to-center of the
X+ black gridlines.
X+ .TP
X+ InBoxHeight
X+ The height from the center of the bottom black gridline to the top
X+ of the regular calendar entry area.  The space from here to the top
X+ of the box is used only to draw the day number.
X+ .TP
X+ /DayFont, /EntryFont, /SmallFont and /HeadFont
X+ The fonts used to draw the day numbers, the calendar entries, the small
X+ calendars, and the month and day headings, respectively.
X+ .TP
X+ DaySize, EntrySize and HeadSize
X+ The sizes of the above fonts.  (The size of the small calendar font
X+ is \fInot\fR defined here.)  For example, if you wanted to print
X+ the Hebrew date next to the regular day number in the calendar, use:
X+ .PP
X+ .nf
X+ 	REM PS Border BoxHeight Border sub DaySize sub moveto \\
X+ 	   /DayFont findfont DaySize scalefont setfont \\
X+ 	   ([hebday(today())] [hebmon(today())]) show
X+ .fi
X+ .PP
X+ .RS
X+ Note how /DayFont and DaySize are used.
X+ .RE
X+ .PP
X+ Note that if you supply PostScript code, it is possible to produce invalid
X+ PostScript files.  Always test your PostScript thoroughly with a PostScript
X+ viewer before sending it to the printer.  You should not use any document
X+ structuring comments in your PostScript code.
X+ .PP
X  .SH DAEMON MODE
X  .PP
X  If you use the \fB\-z\fR command-line option, \fBRemind\fR runs in the
X***************
X*** 2732,2736 ****
X  substitution buffer length, number of global \fBOMIT\fRs, etc.
X  .PP
X  .SH SEE ALSO
X! .pp
X  rem, elm, kall, rem2ps
X--- 2849,2853 ----
X  substitution buffer length, number of global \fBOMIT\fRs, etc.
X  .PP
X  .SH SEE ALSO
X! .PP
X  rem, elm, kall, rem2ps
X*** ../p5rel/test.cmp	Thu Apr 22 10:24:19 1993
X--- ./test.cmp	Fri Apr 23 12:59:58 1993
X***************
X*** 631,637 ****
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.05"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X--- 631,637 ----
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.06"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X***************
X*** 735,741 ****
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.05"
X          a049  21
X          a068  "STRING"
X          a059  "Saturday"
X--- 735,741 ----
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.06"
X          a049  21
X          a068  "STRING"
X          a059  "Saturday"
X*** ../p5rel/token.c	Thu Apr 22 10:59:12 1993
X--- ./token.c	Fri Apr 30 13:14:20 1993
X***************
X*** 75,80 ****
X--- 75,82 ----
X     { "once", 		3, 	T_Once,		0 },
X     { "pop-omit-context", 3,	T_Pop,		0 },
X     { "preserve",        8,      T_Preserve,     0 },
X+    { "ps", 		2, 	T_RemType, 	PS_TYPE },
X+    { "psfile", 		6, 	T_RemType, 	PSF_TYPE },
X     { "push-omit-context", 4, 	T_Push,		0 },
X     { "rem",		3,	T_Rem,		0 },
X     { "run", 		3, 	T_RemType, 	RUN_TYPE },
X*** ../p5rel/types.h	Thu Apr 22 10:24:21 1993
X--- ./types.h	Fri Apr 30 13:13:31 1993
X***************
X*** 98,103 ****
X--- 98,105 ----
X  #define RUN_TYPE 2
X  #define CAL_TYPE 3
X  #define SAT_TYPE 4
X+ #define PS_TYPE  5
X+ #define PSF_TYPE 6
X  
X  /* DEFINES for debugging flags */
X  #define DB_PRTLINE   1
END_OF_FILE
  if test 46327 -ne `wc -c <'patch.06'`; then
    echo shar: \"'patch.06'\" unpacked with wrong size!
  fi
  # end of 'patch.06'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
