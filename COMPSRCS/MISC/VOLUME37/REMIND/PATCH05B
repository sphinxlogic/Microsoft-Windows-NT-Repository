Newsgroups: comp.sources.misc
From: <dfs@doe.carleton.ca> (David F. Skoll)
Subject: v37i029:  remind - A replacement for calendar, Patch05b/3
Message-ID: <1993Apr28.025402.2879@sparky.imd.sterling.com>
X-Md4-Signature: fd25d5a20c78250eb78fedad7b854e67
Date: Wed, 28 Apr 1993 02:54:02 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: <dfs@doe.carleton.ca> (David F. Skoll)
Posting-number: Volume 37, Issue 29
Archive-name: remind/patch05b
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  patch.05.A
# Wrapped by kent@sparky on Tue Apr 27 21:38:31 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'patch.05.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.05.A'\"
else
  echo shar: Extracting \"'patch.05.A'\" \(52350 characters\)
  sed "s/^X//" >'patch.05.A' <<'END_OF_FILE'
XPrereq: "03.00.04"
X*** ../p4rel/version.h	Mon Feb 15 13:24:00 1993
X--- ./version.h	Thu Apr 22 10:24:22 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.04"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.05"
X*** ../p4rel/COPYRIGHT	Wed Mar  3 17:13:09 1993
X--- ./COPYRIGHT	Thu Apr 22 10:24:02 1993
X***************
X*** 76,81 ****
X--- 76,84 ----
X  
X  Phillipp Slusallek for suggesting the -k option.
X  
X+ Amos Shapir, David W. Tamkin and Frank Yellin for help with the Hebrew
X+ calendar.
X+ 
X  All of the language translators whose names are listed in lang.h
X  
X  Timo Salmi, Keith Petersen, Bill Davidsen and Kent Landfield for
X*** ../p4rel/MANIFEST.DOS	Mon Mar  1 16:52:01 1993
X--- ./MANIFEST.DOS	Thu Apr 22 10:24:11 1993
X***************
X*** 15,20 ****
X--- 15,21 ----
X  german.h
X  globals.c
X  globals.h
X+ hbcal.c
X  init.c
X  kall
X  kall.1
X*** ../p4rel/MANIFEST.UNX	Mon Mar  1 16:51:53 1993
X--- ./MANIFEST.UNX	Thu Apr 22 10:24:11 1993
X***************
X*** 22,27 ****
X--- 22,28 ----
X  german.h
X  globals.c
X  globals.h
X+ hbcal.c
X  init.c
X  kall
X  kall.1
X*** ../p4rel/Makefile	Tue Mar  2 11:03:25 1993
X--- ./Makefile	Thu Apr 22 10:24:10 1993
X***************
X*** 46,52 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.04
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X--- 46,52 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.05
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X***************
X*** 53,60 ****
X  
X  STDHDRS= config.h types.h protos.h globals.h err.h lang.h
X  
X! SRCS= calendar.c dorem.c dosubst.c expr.c files.c funcs.c globals.c init.c \
X! main.c omit.c sort.c queue.c token.c trigger.c userfns.c utils.c var.c
X  
X  MANIFEST= README.UNIX README.DOS COPYRIGHT $(HDRS) $(SRCS) Makefile rem rem.1 \
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X--- 53,60 ----
X  
X  STDHDRS= config.h types.h protos.h globals.h err.h lang.h
X  
X! SRCS= calendar.c dorem.c dosubst.c expr.c files.c funcs.c globals.c hbcal.c \
X! init.c main.c omit.c sort.c queue.c token.c trigger.c userfns.c utils.c var.c
X  
X  MANIFEST= README.UNIX README.DOS COPYRIGHT $(HDRS) $(SRCS) Makefile rem rem.1 \
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X***************
X*** 92,97 ****
X--- 92,98 ----
X  files.o: files.c $(STDHDRS)
X  funcs.o: funcs.c $(STDHDRS) expr.h version.h
X  globals.o: globals.c config.h types.h globals.h err.h lang.h
X+ hbcal.o: hbcal.c $(STDHDRS)
X  init.o: init.c $(STDHDRS) expr.h version.h
X  main.o: main.c $(STDHDRS) expr.h
X  omit.o: omit.c $(STDHDRS)
X***************
X*** 104,111 ****
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.4.tar $(MANIFEST)
X! 	compress -v remind-3.0.4.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X--- 105,112 ----
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.5.tar $(MANIFEST)
X! 	compress -v remind-3.0.5.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X*** ../p4rel/README.DOS	Wed Mar  3 17:15:06 1993
X--- ./README.DOS	Thu Apr 22 10:24:12 1993
X***************
X*** 15,21 ****
X  
X  This will create REMIND.EXE, which is ready to be executed.
X  
X! The file "defs.rem" has some sample Remind definitions and commands.
X  
X  OTHER LANGUAGE SUPPORT
X  
X--- 15,22 ----
X  
X  This will create REMIND.EXE, which is ready to be executed.
X  
X! The file "defs.rem" has some sample Remind definitions and commands,
X! as well as U.S. and Jewish holidays.
X  
X  OTHER LANGUAGE SUPPORT
X  
X*** ../p4rel/README.OS2	Wed Mar  3 17:14:49 1993
X--- ./README.OS2	Thu Apr 22 10:24:12 1993
X***************
X*** 17,23 ****
X  This will make 'remind.exe' which is an OS/2 1.x--2.0 executable, and
X  'remindb.exe' which is an OS/2 and MSDOS bound executable.
X  
X! The file "defs.rem" has some sample Remind definitions and commands.
X  
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X--- 17,24 ----
X  This will make 'remind.exe' which is an OS/2 1.x--2.0 executable, and
X  'remindb.exe' which is an OS/2 and MSDOS bound executable.
X  
X! The file "defs.rem" has some sample Remind definitions and commands,
X! as well as U.S. and Jewish holidays.
X  
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X*** ../p4rel/README.UNIX	Wed Mar  3 17:14:29 1993
X--- ./README.UNIX	Thu Apr 22 10:24:13 1993
X***************
X*** 53,59 ****
X  remind processes when you log out.  See the man page.  Note that kall
X  depends on the output of "ps", and may not be portable.
X  
X! The file "defs.rem" has some sample Remind definitions and commands.
X  
X  OTHER LANGUAGE SUPPORT
X  
X--- 53,60 ----
X  remind processes when you log out.  See the man page.  Note that kall
X  depends on the output of "ps", and may not be portable.
X  
X! The file "defs.rem" has some sample Remind definitions and commands,
X! as well as U.S. and Jewish holidays.
X  
X  OTHER LANGUAGE SUPPORT
X  
X*** ../p4rel/WHATSNEW.30	Wed Mar  3 17:16:40 1993
X--- ./WHATSNEW.30	Thu Apr 22 10:24:22 1993
X***************
X*** 1,5 ****
X--- 1,40 ----
X  CHANGES TO REMIND
X  
X+ * Version 3.0 Patch 5
X+ 
X+ + MAJOR ENHANCEMENTS:
X+ 
X+ - Added support for the Hebrew calendar - can now specify Jewish holidays
X+   easily.  Thanks to Amos Shapir for explaining the Hebrew calendar, and
X+   to Danny Sadinoff, from whose HEBCAL program I got some inspiration.
X+   Also thanks to David W. Tamkin and Frank Yellin for explaining the rules
X+   for jahrzeits.
X+ 
X+ + MINOR ENHANCEMENTS:
X+ 
X+ - Allowed the default page size used by Rem2PS to be selected in config.h
X+ 
X+ - Edited the defs.rem file to contain Jewish holidays.  Cleaned up some
X+   of the examples and improved the layout - thanks to George M. Sipe.
X+ 
X+ - Modified the IIF function to be more general
X+ 
X+ - Updated finnish.h to support the ISO 8859-1 character set, courtesy
X+   of Mikko Silvonen.
X+ 
X+ - Changed the date conversion routines to greatly speed up conversion from
X+   Julian to yyyy/mm/dd form.
X+ 
X+ + BUG FIXES:
X+ 
X+ - Fixed a bug in which Remind complained incorrectly about a missing quote
X+   in the command SET foo ""
X+ 
X+ - Fixed bugs in dosubst.c which caused the %o, %1 and %@ substitutions
X+   to be incorrect
X+ 
X+ - Fixed a bug in the man page - thanks to Ed Oskiewicz.
X+ 
X  * Version 3.0 Patch 4
X  
X  - Added the -g option - this sorts reminders by date/time before
X*** ../p4rel/config.h	Tue Mar  2 12:12:49 1993
X--- ./config.h	Thu Apr 22 10:24:02 1993
X***************
X*** 12,17 ****
X--- 12,25 ----
X  /***************************************************************/
X  
X  /*---------------------------------------------------------------------*/
X+ /* DEFAULT_PAGE:  The default page size to use for Rem2PS.             */
X+ /* The Letter version is appropriate for North America; the A4 version */
X+ /* is appropriate for Europe.                                          */
X+ /*---------------------------------------------------------------------*/
X+ #define DEFAULT_PAGE {"Letter", 612, 792}
X+ /* #define DEFAULT_PAGE {"A4", 595, 842} */
X+   
X+ /*---------------------------------------------------------------------*/
X  /* DATESEP:  The default date separator.  North American usage is '/'; */
X  /* others may prefer '-'.                                              */
X  /*---------------------------------------------------------------------*/
X***************
X*** 61,66 ****
X--- 69,78 ----
X  /*---------------------------------------------------------------------*/
X  /* BASE: The base year for date calculation.  NOTE!  January 1 of the  */
X  /*       base year MUST be a Monday, else Remind will not work!        */
X+ /*       IMPORTANT NOTE:  The Hebrew date routines depend on BASE      */
X+ /*       being set to 1990.  If you change it, you'll have to add the  */
X+ /*       number of days between 1 Jan <NEWBASE> and 1 Jan 1990 to the  */
X+ /*       manifest constant CORRECTION in hbcal.c                       */
X  /*---------------------------------------------------------------------*/
X  #define BASE 1990
X  
X*** ../p4rel/defs.rem	Fri Mar  5 11:46:11 1993
X--- ./defs.rem	Thu Apr 22 10:24:03 1993
X***************
X*** 1,29 ****
X! # ---------------------------------------------------------------------------
X! #
X! # DEFS.REM
X! #
X! # This file is a reminder script, which contains a few handy definitions.
X! # Cut and paste as desired!  Also, near the end, there are a bunch of holiday
X! # definitions for the U.S.
X! #
X! # Some examples provided by George M. Sipe <gsipe@pyratl.ga.pyramid.com>
X! #
X! # U.S. holidays provided by Dave Rickel <drickel@sjc.mentorg.com>
X! #
X! # This file is part of REMIND.
X! # Copyright (C) 1992, 1993 by David F. Skoll
X! #
X! # ---------------------------------------------------------------------------
X  
X- # Bombproofing
X  RUN OFF
X! IF version() < "03.00.04"
X!    ERRMSG This file requires at least version 03.00.04 of Remind.%
X!    ERRMSG This version is [version()].
X     EXIT
X  ENDIF
X  
X! # It's handy to have symbolic constants for weekdays and month names
X  SET Sunday    0
X  SET Monday    1
X  SET Tuesday   2
X--- 1,38 ----
X! #############################################################################
X! # 									    #
X! # DEFS.REM								    #
X! # 									    #
X! # This file is a reminder script, which contains a few handy definitions.   #
X! # Cut and paste as desired!  Also, near the end, there are a bunch of	    #
X! # holiday definitions for the U.S.					    #
X! # 									    #
X! # Some examples provided by George M. Sipe <gsipe@pyratl.ga.pyramid.com>    #
X! # 									    #
X! # U.S. holidays provided by Dave Rickel <drickel@sjc.mentorg.com>	    #
X! # 									    #
X! # Use your text editor to search for:					    #
X! #  "#USHOLS" for U.S. holidays						    #
X! #  "#JHOLS"  for Jewish holidays					    #
X! # 									    #
X! # This file is part of REMIND.						    #
X! # Copyright (C) 1992, 1993 by David F. Skoll				    #
X! # 									    #
X! #############################################################################
X  
X  RUN OFF
X! 
X! ################################################
X! # Ensure required version of remind is used... #
X! ################################################
X! IF version() < "03.00.05"
X!    ERRMSG This file requires at least version 03.00.05 of Remind.%
X!    ERRMSG This version is version [version()].
X     EXIT
X  ENDIF
X  
X! ######################################
X! # Symbolic constants for weekdays... #
X! ######################################
X  SET Sunday    0
X  SET Monday    1
X  SET Tuesday   2
X***************
X*** 40,46 ****
X  SET Fri 5
X  SET Sat 6
X  
X! # ---------------------------------------------------------------------------
X  
X  SET Jan 1
X  SET Feb 2
X--- 49,57 ----
X  SET Fri 5
X  SET Sat 6
X  
X! #########################################
X! # Symbolic constants for month names... #
X! #########################################
X  
X  SET Jan 1
X  SET Feb 2
X***************
X*** 55,62 ****
X  SET Nov 11
X  SET Dec 12
X  
X- # ---------------------------------------------------------------------------
X- 
X  SET January   1
X  SET February  2
X  SET March     3
X--- 66,71 ----
X***************
X*** 70,172 ****
X  SET November  11
X  SET December  12
X  
X! # ---------------------------------------------------------------------------
X  
X! # A function which, given a time, returns a string in "AM/PM" format.
X! # Unfortunately, has a leading zero.  Example call:
X! #	set a _am_pm(now())
X  
X! FSET _am_pm(tm)	IIF (tm<1:00, tm+12*60+"am", \
X! 			IIF (tm<12:00, tm+"am", \
X! 				IIF (tm<13:00, tm+"pm", tm-12*60+"pm")))
X  
X! # A function which knocks off a single leading zero from a string
X  
X! FSET _no_lz(s) IIF(SUBSTR(s, 1, 1)=="0", SUBSTR(s, 2), s)
X  
X! # ---------------------------------------------------------------------------
X  
X! # Here's a tricky problem:  The 4th of July is a holiday in the U.S.
X! # However, if it falls on a Saturday, the previous Friday is a holiday.
X! # If it falls on a Sunday, the next Monday is a holiday.  Here's how
X! # to do it.  NOTE that the following procedure makes the OMIT context
X! # dependent upon the current date.  SInce it only depends on the current
X! # year, which is not likely to change while producing a calendar, we
X! # are fairly safe.  However, reminders with huge DELTA or BACK components
X! # may not operate as expected.  In general, any time you make OMIT
X! # dependent upon the current date, it's tricky and results may not be
X! # what you expect.  You should try to make sure that the OMIT context
X! # "near" any current reminders will not change during a calendar run.
X! # The SCANFROM clause should help make these OMITs very safe.
X  
X! # Convenient function and variable for safe moveable OMITs
X! FSET _safe(x) trigger(today()-x)
X! # Usually, a safety margin of 7 is sufficient.  We can stick it in a
X! # variable.  Note that you must NOT preserve this variable, because
X! # it must be updated as today() is incremented.
X! SET safe7 _safe(7)
X  
X! # The usual holiday
X! OMIT 4 July MSG Independence day
X  
X! # Calculate a "potential" advanced holiday
X! REM 3 July SCANFROM [safe7] SATISFY 1
X  
X! # But only trigger it if it falls on a Friday
X! IF WKDAYNUM(TRIGDATE()) == 5
X!    OMIT [TRIGGER(TRIGDATE())] MSG Independence day (observed)
X! ENDIF
X  
X- # Calculate a "potential" delayed holiday
X- REM 5 July SCANFROM [safe7] SATISFY 1
X- 
X- # But only trigger it if it falls on a Monday
X- IF WKDAYNUM(TRIGDATE()) == 1
X-    OMIT [TRIGGER(TRIGDATE())] MSG Independence day (observed)
X- ENDIF
X- 
X- # ---------------------------------------------------------------------------
X- # Function to calculate number of years since a given year or
X- # number of months since a given month and year...  useful for kids'
X- # birthdays.
X- 
X- FSET _yr_num(yr)	ORD(YEAR(TRIGDATE()) - yr)
X- FSET _mo_num(mo, yr)	ORD(12 * (YEAR(TRIGDATE()) - yr) + \
X- 				MONNUM(TRIGDATE()) - mo)
X- 
X  # Here's an example of how to use them:
X  REM 1 Nov ++12 MSG %"Dean's [_yr_num(1984)] birthday%" is %b.
X  REM 1 MSG Dean's [_mo_num(11, 1984)] 'monthly' anniversary
X- # ---------------------------------------------------------------------------
X  
X! # How do we get a double-quote into a string????  Only works on ASCII
X! # machines
X  
X- set Quote char(34)
X- set example "The last word of this sentence is in " \
X- 	+ Quote + "quotes." + Quote
X- 
X- # ---------------------------------------------------------------------------
X- 
X- # Function to send mail via elm's "fastmail" (by George M. Sipe)...
X- 
X  #FSET _mail(from, subj)	"mailx -s " + \
X  #				Quote + from + " : " + subj + Quote \
X! #				getenv("LOGNAME") + " < /dev/null 1>&0"
X! 
X  FSET _mail(from, subj)	"fastmail -f " + \
X  				Quote + from + Quote + \
X  				" -s " + Quote + subj + Quote + \
X! 				" /dev/null " + getenv("LOGNAME")
X  
X! # Example of use of _mail
X! REM Feb 14 ONCE RUN [_mail("Someone you know", "Valentine's day is today")]
X  
X! # ---------------------------------------------------------------------------
X  
X! # A meeting on the first Monday of every month which is moved to the
X! # second Monday in the event of a holiday.
X  
X  # First, the normal meeting.  However, the SKIP keyword means this
X  # one won't be triggered if the first Monday is a holiday
X  REM Mon 1 SKIP MSG Meeting
X--- 79,181 ----
X  SET November  11
X  SET December  12
X  
X! ###########################################################
X! # Other symbolic constants and functions for "pasting"... #
X! ###########################################################
X  
X! SET Quote CHAR(34)
X  
X! # Handy constants/function for specifing week of month...
X! SET  Week_1		 1
X! SET  Week_2		 8
X! SET  Week_3		15
X! SET  Week_4		22
X! FSET _last(mo)		"1 " + MON((mo%12)+1)+" --7"
X  
X! # Shorthand for commonly used expression...
X! FSET _trig()		TRIGGER(TRIGDATE())
X  
X! # Handy function to provide SCANFROM dates...
X! FSET _back(days)	TRIGGER(TODAY()-days)
X  
X! ###########################################################
X! # Function which returns a string in "am/pm" format based #
X! # on the time.  For example, set a am_pm(NOW())...        #
X! ###########################################################
X  
X! FSET _am_pm(tm)	IIF(tm<01:00, tm+12*60+"am", \
X!                     tm<12:00, tm+"am", \
X!                     tm<13:00, tm+"pm", \
X!                               tm-12*60+"pm")
X  
X! #################################################################
X! # Function which removes a single leading zero from a string... #
X! #################################################################
X  
X! FSET _no_lz(s) IIF(SUBSTR(s, 1, 1)=="0", SUBSTR(s, 2), s)
X  
X! ############################################################
X! # Function to calculate number of years since a given year #
X! # or number of months since a given month and year...      #
X! ############################################################
X  
X! FSET _yr_num(yr)		ORD(YEAR(TRIGDATE()) - yr)
X! FSET _mo_num(mo, yr)		ORD(12 * (YEAR(TRIGDATE()) - yr) + \
X! 					MONNUM(TRIGDATE()) - mo)
X  
X  # Here's an example of how to use them:
X  REM 1 Nov ++12 MSG %"Dean's [_yr_num(1984)] birthday%" is %b.
X  REM 1 MSG Dean's [_mo_num(11, 1984)] 'monthly' anniversary
X  
X! ###########################################################
X! # Function to send mail via elm's "fastmail" (by GMS!)... #
X! ###########################################################
X  
X  #FSET _mail(from, subj)	"mailx -s " + \
X  #				Quote + from + " : " + subj + Quote \
X! #				GETENV("LOGNAME") + " < /dev/null 1>&0"
X  FSET _mail(from, subj)	"fastmail -f " + \
X  				Quote + from + Quote + \
X  				" -s " + Quote + subj + Quote + \
X! 				" /dev/null " + GETENV("LOGNAME")
X  
X! #############################################################################
X! # Here's a tricky problem:  The 4th of July is a holiday in the U.S.
X! # However, if it falls on a Saturday, the previous Friday is a holiday.
X! # If it falls on a Sunday, the next Monday is a holiday.  Here's how
X! # to do it.  NOTE that the following procedure makes the OMIT context
X! # dependent upon the current date.  SInce it only depends on the current
X! # year, which is not likely to change while producing a calendar, we
X! # are fairly safe.  However, reminders with huge DELTA or BACK components
X! # may not operate as expected.  In general, any time you make OMIT
X! # dependent upon the current date, it's tricky and results may not be
X! # what you expect.  You should try to make sure that the OMIT context
X! # "near" any current reminders will not change during a calendar run.
X! # The SCANFROM clause should help make these OMITs very safe.
X! ############################################################################
X  
X! # Calculate the weekday of the holiday.
X! REM 4 July SCANFROM [_back(7)] SATISFY 1
X  
X! IF WKDAYNUM(TRIGDATE()) == Sat
X! 	REM [TRIGGER(TRIGDATE())] MSG Independence day (actual)
X! 	OMIT [TRIGGER(TRIGDATE()-1)] MSG Independence day (observed)
X! ELSE
X! 	IF WKDAYNUM(TRIGDATE()) == Sun
X! 		REM [TRIGGER(TRIGDATE())] MSG Independence day (actual)
X! 		OMIT [TRIGGER(TRIGDATE()+1)] MSG Independence day (observed)
X! 	ELSE
X! 		OMIT [TRIGGER(TRIGDATE())] MSG Independence day
X! 	ENDIF
X! ENDIF
X  
X+ ############################################################################
X+ #									   #
X+ # A meeting on the first Monday of every month which is moved to the       #
X+ # second Monday in the event of a holiday.                                 #
X+ #									   #
X+ ############################################################################
X+ 
X  # First, the normal meeting.  However, the SKIP keyword means this
X  # one won't be triggered if the first Monday is a holiday
X  REM Mon 1 SKIP MSG Meeting
X***************
X*** 180,199 ****
X     REM [TRIGGER(TRIGDATE())] MSG Delayed meeting
X  ENDIF
X  
X! # ---------------------------------------------------------------------------
X! #
X! # A very complicated reminder sent in by a Remind user.
X! # This person gets paid every two weeks, starting from 8 January 1993.
X! # If a pay date occurs before the twelfth of a month, then that
X! # he pays his mortgage on that pay date.  Otherwise, he pays the mortgage
X! # on the previous pay date.  Furthermore, he has to schedule his
X! # mortgage payment six days before it is due.  He wants to be reminded
X! # a further four days before the scheduling deadline.  He also
X! # wants to be mailed a notice two weeks before the scheduling deadline.
X  
X- # Here's the solution - if you can follow this, consider yourself a
X- # Remind programmer extraordinaire!
X- 
X  # A function to determine whether or not a pay-date is a mortgage-date.
X  
X  FSET _IsMortDate(x) DAY(x) < 12 || (DAY(x+14) >= 12 && DAY(x+14) <= 14)
X--- 189,210 ----
X     REM [TRIGGER(TRIGDATE())] MSG Delayed meeting
X  ENDIF
X  
X! ############################################################################
X! #									   #
X! # A very complicated reminder sent in by a Remind user.			   #
X! # This person gets paid every two weeks, starting from 8 January 1993.	   #
X! # If a pay date occurs before the twelfth of a month, then that		   #
X! # he pays his mortgage on that pay date.  Otherwise, he pays the mortgage  #
X! # on the previous pay date.  Furthermore, he has to schedule his	   #
X! # mortgage payment six days before it is due.  He wants to be reminded	   #
X! # a further four days before the scheduling deadline.  He also		   #
X! # wants to be mailed a notice two weeks before the scheduling deadline.	   #
X! #									   #
X! # Here's the solution - if you can follow this, consider yourself a	   #
X! # Remind programmer extraordinaire!					   #
X! #									   #
X! ############################################################################
X  
X  # A function to determine whether or not a pay-date is a mortgage-date.
X  
X  FSET _IsMortDate(x) DAY(x) < 12 || (DAY(x+14) >= 12 && DAY(x+14) <= 14)
X***************
X*** 225,299 ****
X  REM [TRIGGER(TRIGDATE())] CAL Mortgage payment
X  
X  
X! # ---------------------------------------------------------------------------
X! #
X! # The following holidays were provided by Dave Rickel
X! # Modified by D. Skoll to give safe OMITs for moveable holidays
X  
X! set thisyear year(today())
X! if ! defined("eyear")
X! 	set eyear 0
X! endif
X  
X! # Note:  A shorter way to set a default value for eyear is the following:
X! # set eyear value("eyear", 0) -- David S.
X  
X- if eyear != thisyear
X- 	set a thisyear % 19
X- 	set b thisyear / 100
X- 	set c thisyear % 100
X- 	set d b / 4
X- 	set e b % 4
X- 	set f (b + 8) % 25
X- 	set g (b - f + 1) / 3
X- 	set h (19 * a + b - d - g + 15) % 30
X- 	set i c / 4
X- 	set k c % 4
X- 	set l (32 + e + e + i + i - h - k) % 7
X- 	set m (a + 11 * h + 22 * l) / 451
X- 	set a h + l - 7 * m + 114
X- 	set n a / 31
X- 	set p a % 31 + 1
X- 
X- 	set eyear thisyear
X- 	set emon mon(n)
X- 	set eday p
X- 	preserve eyear emon eday
X- endif
X- REM [emon] [eday] MSG Easter Sunday.
X- 
X  # Some holidays are omitted, some are not.  You may want to change
X  # which ones are omitted - use the general forms shown below.
X! # You'll need the safe7 variable from way up above.
X  
X! REM Monday Feb 15 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG President's Day.
X  
X! REM Saturday Mar 31 MSG Daylight Savings Time begins tonight.
X! REM Mon Tue Wed Thu Fri Sat 15 April MSG Income Tax Day.
X! REM Saturday May 1 MSG Kentucky Derby Day.
X! REM Sunday May 8 MSG Mother's Day.
X  
X! REM Monday May 25 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Memorial Day.
X  
X! REM Sunday June 15 MSG Father's Day.
X  
X! REM Monday Sep 1 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Labor Day.
X  
X! REM Monday Oct 8 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Columbus Day.
X  
X! REM Monday Oct 22 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Veteran's Day.
X  
X! REM Saturday Oct 24 MSG Daylight Savings Time ends tonight.
X  
X! REM Tuesday Nov 2 SCANFROM [safe7] SATISFY (year(trigdate()) % 4) == 0
X! OMIT [trigger(trigdate())] MSG U.S. Election Day.
X  
X! REM Saturday Nov 12 MSG Sadie Hawkin's Day.
X  
X! REM Thursday Nov 22 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Thanksgiving.
X--- 236,444 ----
X  REM [TRIGGER(TRIGDATE())] CAL Mortgage payment
X  
X  
X! #USHOLS
X! #############################################################################
X! #       								    #
X! # The following holidays were provided by Dave Rickel			    #
X! # Modified by D. Skoll to give safe OMITs for moveable holidays		    #
X! #									    #
X! #############################################################################
X  
X! IF !DEFINED("easter")
X! 	SET a YEAR(TODAY())
X! 	SET b (a/100 - (a/100 + 8) % 25 + 1) / 3
X! 	SET c (a%19*19 + a/100 - a/400 - b + 15) % 30
X! 	SET d (32 + a/100%4*2 + (a%100/4*2) - c - a%100%4) % 7
X! 	SET e c + d - (((a%19) + c*11 + d*22) / 451) * 7 + 114
X! 	SET easter DATE(a, e / 31, e % 31 + 1)
X! 	PRESERVE easter
X! ENDIF
X  
X! REM  [TRIGGER(easter-46)] MSG %"Ash Wednesday%"
X! REM  [TRIGGER(easter-7)]  MSG %"Palm Sunday%"
X! OMIT [TRIGGER(easter-2)]  MSG %"Good Friday%"
X! OMIT [TRIGGER(easter)]    MSG %"Easter%" Sunday
X! REM  [TRIGGER(easter+39)] MSG %"Ascension Day%"
X! REM  [TRIGGER(easter+49)] MSG %"Pentecost%"
X  
X  # Some holidays are omitted, some are not.  You may want to change
X  # which ones are omitted - use the general forms shown below.
X! # You'll need the _back() function and the Week_n variables defined
X! # way up in the file.
X  
X! OMIT     Jan  1		MSG %"New Year's%" Day
X! REM  Mon Jan [Week_3]	MSG Martin Luther King - %"MLK Day%"
X! REM      Feb  2		MSG %"Ground Hog Day%"
X! REM      Feb 14		MSG %"Valentine's%" Day
X! REM  Mon Feb [Week_3]	SCANFROM [_back(7)] SATISFY 1
X! 			OMIT [_trig()] MSG %"President's Day%"
X! REM      Mar 17		MSG %"St. Patrick's%" Day
X! REM  Sun Apr  1 ++2	MSG Daylight Savings Time - %"DST starts%" %b
X! REM      Apr  1		MSG %"April Fool's%" Day
X! REM  Mon Tue Wed Thu Fri Sat 15 Apr MSG %"Income tax%" due
X! REM      May  5		MSG %"Cinco de Mayo%"
X! REM  Sat May [Week_1]	MSG %"Kentucky Derby%"
X! REM  Sun May [Week_2]	MSG %"Mother's Day%"
X! REM  Sat May [Week_3]	MSG %"Armed Forces Day%"
X! REM  Mon [_last(May)]	SCANFROM [_back(7)] SATISFY 1
X! 			OMIT [_trig()] MSG %"Memorial Day%"
X! REM      Jun 14		MSG %"Flag Day%"
X! REM  Sun Jun [Week_3]	MSG %"Father's Day%"
X! REM  Mon Sep [Week_1]	SCANFROM [_back(7)] SATISFY 1
X! 			OMIT [_trig()] MSG %"Labor Day%"
X! REM  Mon Oct [Week_2]	MSG %"Columbus Day%"
X! REM      Nov 11		MSG %"Veterans Day%"
X! REM  Sun [_last(Oct)]	MSG Daylight Savings Time - %"DST over%"
X! REM      Oct 30		MSG %"Mischief Night%"
X! REM      Oct 31		MSG %"Halloween%"
X! REM  Tue Nov  2		SCANFROM [_back(7)] SATISFY (YEAR(TRIGDATE()) % 4) == 0
X! 			REM [_trig()] MSG %"Election%" Day
X! REM  Thu Nov [Week_4]	SCANFROM [_back(7)] SATISFY 1
X! 			OMIT [_trig()] MSG %"Thanksgiving%" Day
X! REM  Fri Nov [Week_4+1]	SCANFROM [_back(7)] SATISFY 1
X! 			OMIT [_trig()] MSG %"Thanksgiving%" (cont.)
X! OMIT     Dec 24		MSG %"Christmas Eve%"
X! OMIT     Dec 25		MSG %"Christmas%" Day
X  
X! # Seasons (valid from 1992 to 2000)...
X! REM Mar 20 MSG %"Spring%" begins
X! REM Jun [IIF(YEAR(TODAY())%4, 21, 20)] MSG %"Summer%" begins
X! REM Sep [CHOOSE(YEAR(TODAY())-1991, 22,22,23,23,22,22,22,23,22)] \
X! 	MSG %"Fall%" begins
X! REM Dec [IIF((YEAR(TODAY())+1)%4, 21, 22)] MSG %"Winter%" begins
X  
X! #JHOLS
X! ##########################################################################
X! #								         #
X! # This portion of the file contains reminders for Jewish holidays.  The	 #
X! # dates were obtained from "The First Jewish Catalog" by Richard Siegel	 #
X! # and Michael and Sharon Strassfeld, published by the Jewish Publication #
X! # Society of America.  The Reform version of the calendar was guessed	 #
X! # at by David Skoll based on experience # I welcome corrections.	 #
X! #									 #
X! # You (probably) want to add deltas to some of the reminders so that	 #
X! # you are given advance notice of Jewish holidays.			 #
X! #								         #
X! ##########################################################################
X  
X! # Here are some general functions that you might find nice to use
X  
X! # _hstr:  Returns a string which is the full Hebrew date of its argument.
X! #         Example: hstr('1994/02/02') returns "21 Shvat 5754"
X! FSET _hstr(x) HEBDAY(x) + " " + HEBMON(x) + " " + HEBYEAR(x)
X  
X! # _hyrlen:  Return the length of the specified Hebrew year
X! #           Example: _hyrlen(5754) returns 355
X! FSET _hyrlen(x) HEBDATE(1, "Tishrey", x+1) - HEBDATE(1, "Tishrey", x)
X  
X! # --- HERE ARE THE JEWISH HOLIDAYS ---
X! # Set the variable InIsrael to 1 if you live in Israel.  Otherwise,
X! # you get the Diaspora versions of Jewish holidays
X! SET InIsrael 0
X  
X! # Set the variable Reform to 1 if you want the Reform version of the
X! # Jewish calendar.  Otherwise, you get the traditional version
X! SET Reform 0
X  
X! # Convenient function definition to save typing
X! FSET _h(x, y) TRIGGER(HEBDATE(x,y))
X  
X! # Default values in case InIsrael and Reform are not set
X! SET InIsrael VALUE("InIsrael", 0)
X! SET Reform   VALUE("Reform", 0)
X  
X! [_h(1,  "Tishrey")] MSG Rosh Hashana 1
X! 
X! # No RH-2 or Tzom Gedalia in Reform
X! IF !Reform
X!    [_h(2,  "Tishrey")] MSG Rosh Hashana 2
X!    [_h(3,  "Tishrey")] MSG Tzom Gedalia
X! ENDIF
X! 
X! [_h(10, "Tishrey")] MSG Yom Kippur
X! [_h(15, "Tishrey")] MSG Sukkot 1
X! 
X! IF !InIsrael
X!    [_h(16, "Tishrey")] MSG Sukkot 2
X! ENDIF
X! 
X! [_h(21, "Tishrey")] MSG Hashana Rabba
X! [_h(22, "Tishrey")] MSG Shemini Atzeret
X! 
X! IF InIsrael
X!    [_h(22, "Tishrey")] MSG Simchat Torah
X! ELSE
X!    [_h(23, "Tishrey")] MSG Simchat Torah
X! ENDIF
X! 
X! # Because Kislev can change length, we must be more careful about Chanukah
X! FSET _chan(x) TRIGGER(HEBDATE(24, "Kislev", today()-9)+x)
X! [_chan(1)] MSG Chanukah 1
X! [_chan(2)] MSG Chanukah 2
X! [_chan(3)] MSG Chanukah 3
X! [_chan(4)] MSG Chanukah 4
X! [_chan(5)] MSG Chanukah 5
X! [_chan(6)] MSG Chanukah 6
X! [_chan(7)] MSG Chanukah 7
X! [_chan(8)] MSG Chanukah 8
X! 
X! # Not sure about Reform's position on the next one.
X! IF !Reform
X!    [_h(10, "Tevet")] MSG Asara B'Tevet
X! ENDIF
X! 
X! [_h(15, "Shvat")] MSG Tu B'Shvat
X! [_h(15, "Adar A")] MSG Purim Katan
X! [_h(13, "Adar")] MSG Fast of Esther
X! [_h(14, "Adar")] MSG Purim
X! [_h(15, "Nisan")] MSG Pesach
X! 
X! IF !InIsrael
X!    [_h(16, "Nisan")] MSG Pesach 2
X! ENDIF
X! 
X! [_h(21, "Nisan")] MSG Pesach 7
X! 
X! IF !InIsrael && !Reform
X!    [_h(22, "Nisan")] MSG Pesach 8
X! ENDIF
X! 
X! [_h(27, "Nisan")] MSG Yom HaShoah
X! [_h(4,  "Iyar")] MSG Yom HaZikaron
X! [_h(5,  "Iyar")] MSG Yom Ha'atzmaut
X! 
X! # Not sure about Reform's position on Lag B'Omer
X! IF !Reform
X!    [_h(18, "Iyar")] MSG Lag B'Omer
X! ENDIF
X! 
X! [_h(28, "Iyar")] MSG Yom Yerushalayim
X! [_h(6,  "Sivan")] MSG Shavuot
X! 
X! IF !InIsrael && !Reform
X!    [_h(7, "Sivan")] MSG Shavuot 2
X! ENDIF
X! 
X! # Fairly sure Reform Jews don't observe the next two
X! IF !Reform
X!    [_h(17, "Tamuz")] MSG Fast of 17th of Tammuz
X!    [_h(9,  "Av")] MSG Tish'a B'Av
X! ENDIF
X! 
X! # Counting the omer - do the whole spiel, i.e:
X! # "This is the xth day of the omer, being y weeks and z days of the omer."
X! # Nice Remind programming example here!
X! SET ostart HEBDATE(16, "Nisan", TODAY()-50)
X! IF ostart <= TODAY() && (TODAY() - ostart < 49)
X!    SET odays TODAY()-ostart+1
X!    IF odays < 7
X!       MSG %"%"Today is the [ORD(odays)] day of the Omer.
X!    ELSE
X!       IF !(odays % 7)
X!          MSG %"%"Today is the [ORD(odays)] day of the Omer, being [odays / 7] [PLURAL(odays/7, "week")] of the Omer.
X!       ELSE
X! 	 MSG %"%"Today is the [ORD(odays)] day of the Omer, being [odays/7] [PLURAL(odays/7, "week")] and [odays%7] [PLURAL(odays%7, "day")] of the Omer.
X!       ENDIF
X!    ENDIF
X!    CAL [ORD(odays)] of Omer
X! ENDIF
X*** ../p4rel/dosubst.c	Fri Mar  5 11:57:34 1993
X--- ./dosubst.c	Thu Apr 22 10:24:04 1993
X***************
X*** 324,329 ****
X--- 324,330 ----
X  L_O_OVER
X  #else
X  	    if (RealToday == JulianToday) sprintf(s, " (%s)", L_TODAY);
X+ 	    else *s = 0;
X  #endif
X  	    s += strlen(s);
X  	    break;
X***************
X*** 450,456 ****
X  #ifdef L_2_OVER
X  L_2_OVER
X  #else
X! 	    sprintf(s, "%s %d:%02d%s", L_AT, hh, min, pm);
X  #endif
X  	    s += strlen(s);
X  	    break;
X--- 451,457 ----
X  #ifdef L_2_OVER
X  L_2_OVER
X  #else
X! 	    sprintf(s, "%s %d%c%02d%s", L_AT, hh, TIMESEP, min, pm);
X  #endif
X  	    s += strlen(s);
X  	    break;
X***************
X*** 541,547 ****
X  #ifdef L_AT_OVER
X  L_AT_OVER
X  #else
X! 	    sprintf(s, "%d:%02d%s", chh, cmin, cpm);
X  #endif
X  	    s += strlen(s);
X  	    break;
X--- 542,548 ----
X  #ifdef L_AT_OVER
X  L_AT_OVER
X  #else
X! 	    sprintf(s, "%d%c%02d%s", chh, TIMESEP, cmin, cpm);
X  #endif
X  	    s += strlen(s);
X  	    break;
X*** ../p4rel/expr.c	Wed Mar  3 17:35:34 1993
X--- ./expr.c	Thu Apr 22 11:00:23 1993
X***************
X*** 225,231 ****
X  
X     /* Handle the parsing of quoted strings */
X     if (c == '\"') {
X!       if (!*(*in+1)) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\"') break;
X        *out = 0;
X        if (c == '\"') return OK ; else return E_MISS_QUOTE;
X--- 225,231 ----
X  
X     /* Handle the parsing of quoted strings */
X     if (c == '\"') {
X!       if (!**in) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\"') break;
X        *out = 0;
X        if (c == '\"') return OK ; else return E_MISS_QUOTE;
X***************
X*** 233,239 ****
X  
X     /* Dates can be specified with single-quotes */
X     if (c == '\'') {
X!       if (!*(*in+1)) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\'') break;
X        *out = 0;
X        if (c == '\'') return OK ; else return E_MISS_QUOTE;
X--- 233,239 ----
X  
X     /* Dates can be specified with single-quotes */
X     if (c == '\'') {
X!       if (!**in) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\'') break;
X        *out = 0;
X        if (c == '\'') return OK ; else return E_MISS_QUOTE;
X***************
X*** 771,776 ****
X--- 771,777 ----
X     if ((v1.type == TIM_TYPE && v2.type == INT_TYPE) ||
X         (v1.type == INT_TYPE && v2.type == TIM_TYPE)) {
X        v1.v.val = (v1.v.val + v2.v.val) % 1440;
X+       if (v1.v.val < 0) v1.v.val += 1440;
X        v1.type = TIM_TYPE;
X        return PushValStack(&v1);
X     }   	
X***************
X*** 839,844 ****
X--- 840,846 ----
X     /* If it's a time minus an int, do subtraction mod 1440 */
X     if (v1.type == TIM_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val - v2.v.val) % 1440;
X+       if (v1.v.val < 0) v1.v.val += 1440;
X        return PushValStack(&v1);
X     }
X  
X*** ../p4rel/finnish.h	Tue Feb 16 17:19:19 1993
X--- ./finnish.h	Thu Apr 22 10:24:36 1993
X***************
X*** 11,19 ****
X  /*                                                             */
X  /***************************************************************/
X  
X- /* All Finnish words in this file are in "7-bit Finnish ASCII";
X-    they can be converted to other character sets if needed. */
X-    
X  /* The very first define in a language support file must be L_LANGNAME: */
X  #define L_LANGNAME "Finnish"
X  
X--- 11,16 ----
X***************
X*** 35,42 ****
X--- 32,44 ----
X  #define L_MAR "maaliskuu"
X  #define L_APR "huhtikuu"
X  #define L_MAY "toukokuu"
X+ #ifdef ISOLATIN1
X+ #define L_JUN "kes\xE4kuu"
X+ #define L_JUL "hein\xE4kuu"
X+ #else
X  #define L_JUN "kes{kuu"
X  #define L_JUL "hein{kuu"
X+ #endif
X  #define L_AUG "elokuu"
X  #define L_SEP "syyskuu"
X  #define L_OCT "lokakuu"
X***************
X*** 44,50 ****
X--- 46,56 ----
X  #define L_DEC "joulukuu"
X  
X  /* Today and tomorrow */
X+ #ifdef ISOLATIN1
X+ #define L_TODAY "t\xE4n\xE4\xE4n"
X+ #else
X  #define L_TODAY "t{n{{n"
X+ #endif
X  #define L_TOMORROW "huomenna"
X  
X  /* The default banner */
X***************
X*** 62,68 ****
X--- 68,78 ----
X  #define L_FROMNOW "kuluttua"
X  
X  /* "in %d days' time" */
X+ #ifdef ISOLATIN1
X+ #define L_INXDAYS "%d p\xE4iv\xE4n kuluttua"
X+ #else
X  #define L_INXDAYS "%d p{iv{n kuluttua"
X+ #endif
X  
X  /* "on" as in "on date...", but in Finnish it is a case ending;
X     L_PARTIT is the partitive ending appended to -kuu and -tai */
X***************
X*** 72,78 ****
X--- 82,92 ----
X  /* Pluralizing - this is a problem for many languages and may require
X     a more drastic fix */
X  /* The partitive ending of "day" */
X+ #ifdef ISOLATIN1
X+ #define L_PLURAL "\xE4"
X+ #else
X  #define L_PLURAL "{"
X+ #endif
X  
X  /* Minutes, hours, at, etc */
X  #define L_NOW "nyt"
X***************
X*** 96,102 ****
X--- 110,130 ----
X  /* Define any overrides here, such as L_ORDINAL_OVERRIDE, L_A_OVER, etc.
X     See the file dosubst.c for more info. */
X  
X+ #ifdef ISOLATIN1
X  #define L_ORDINAL_OVERRIDE switch(d) { \
X+                                case 1:  plu = ":sen\xE4"; break; \
X+                                case 2:  plu = ":sena"; break; \
X+                                default: \
X+                                    switch(d%10) { \
X+                                        case 2: \
X+                                        case 3: \
X+                                        case 6: \
X+                                        case 8:  plu = ":ntena"; break; \
X+                                        default: plu = ":nten\xE4"; break; \
X+                                    } \
X+                            }
X+ #else
X+ #define L_ORDINAL_OVERRIDE switch(d) { \
X                                 case 1:  plu = ":sen{"; break; \
X                                 case 2:  plu = ":sena"; break; \
X                                 default: \
X***************
X*** 108,113 ****
X--- 136,142 ----
X                                         default: plu = ":nten{"; break; \
X                                     } \
X                             }
X+ #endif
X  #define L_A_OVER sprintf(s, "%s%s, %d. %s%s %d", DayName[jul%7], L_ON, d, \
X                           MonthName[m], L_PARTIT, y);
X  #define L_C_OVER sprintf(s, "%s%s", DayName[jul%7], L_ON);
X*** ../p4rel/funcs.c	Tue Mar  2 16:27:55 1993
X--- ./funcs.c	Thu Apr 22 10:24:25 1993
X***************
X*** 60,65 ****
X--- 60,69 ----
X  PRIVATE	int	FDosubst	ARGS ((void));
X  PRIVATE	int	FFilename	ARGS ((void));
X  PRIVATE	int	FGetenv		ARGS ((void));
X+ PRIVATE int     FHebdate	ARGS ((void));
X+ PRIVATE int     FHebday		ARGS ((void));
X+ PRIVATE int     FHebmon		ARGS ((void));
X+ PRIVATE int     FHebyear	ARGS ((void));
X  PRIVATE	int	FHour		ARGS ((void));
X  PRIVATE	int	FIif		ARGS ((void));
X  PRIVATE	int	FIndex		ARGS ((void));
X***************
X*** 96,102 ****
X  PRIVATE int	FTrigger        ARGS ((void));
X  PRIVATE int	CheckArgs       ARGS ((Operator *f, int nargs));
X  PRIVATE int	CleanUpAfterFunc ARGS ((void));
X!      
X  #ifdef __MSDOS__
X  PRIVATE FILE *popen  ARGS((char *cmd, char *mode));
X  PRIVATE int   pclose ARGS((FILE *fp));
X--- 100,106 ----
X  PRIVATE int	FTrigger        ARGS ((void));
X  PRIVATE int	CheckArgs       ARGS ((Operator *f, int nargs));
X  PRIVATE int	CleanUpAfterFunc ARGS ((void));
X! 
X  #ifdef __MSDOS__
X  PRIVATE FILE *popen  ARGS((char *cmd, char *mode));
X  PRIVATE int   pclose ARGS((FILE *fp));
X***************
X*** 117,122 ****
X--- 121,134 ----
X  /* Temp string buffer */
X  static char Buffer[32];
X  
X+ /* Caches for extracting months, days, years from dates - may
X+    improve performance slightly. */
X+ static int CacheJul = -1;
X+ static int CacheYear, CacheMon, CacheDay;
X+ 
X+ static int CacheHebJul = -1;
X+ static int CacheHebYear, CacheHebMon, CacheHebDay;
X+ 
X  /* We need access to the value stack */
X  extern Value ValStack[];
X  extern int ValStackPtr;
X***************
X*** 151,158 ****
X      {   "dosubst",	1,	3,	FDosubst },
X      {   "filename",	0,	0,	FFilename },
X      {   "getenv",	1,	1,	FGetenv },
X      {   "hour",		1,	1,	FHour	},
X!     {   "iif",		3,	3,	FIif	},
X      {   "index",	2,	3,	FIndex 	},
X      {   "isleap",	1,	1,	FIsleap },
X      {   "isomitted",	1,	1,	FIsomitted },
X--- 163,174 ----
X      {   "dosubst",	1,	3,	FDosubst },
X      {   "filename",	0,	0,	FFilename },
X      {   "getenv",	1,	1,	FGetenv },
X+     {   "hebdate",	2,	4,	FHebdate },
X+     {   "hebday",	1,	1,	FHebday },
X+     {   "hebmon",	1,	1,	FHebmon },
X+     {   "hebyear",	1,	1,	FHebyear },
X      {   "hour",		1,	1,	FHour	},
X!     {   "iif",		1,	NO_MAX,	FIif	},
X      {   "index",	2,	3,	FIndex 	},
X      {   "isleap",	1,	1,	FIsleap },
X      {   "isomitted",	1,	1,	FIsomitted },
X***************
X*** 189,195 ****
X  
X  /* Need a variable here - Func[] array not really visible to outside. */
X  int NumFuncs = sizeof(Func) / sizeof(Operator) ;
X!      
X  /***************************************************************/
X  /*                                                             */
X  /*  CallFunc                                                   */
X--- 205,211 ----
X  
X  /* Need a variable here - Func[] array not really visible to outside. */
X  int NumFuncs = sizeof(Func) / sizeof(Operator) ;
X! 
X  /***************************************************************/
X  /*                                                             */
X  /*  CallFunc                                                   */
X***************
X*** 545,551 ****
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    FromJulian(ARG(0).v.val, &y, &m, &d);
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = d;
X     return OK;
X--- 561,575 ----
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    if (ARG(0).v.val == CacheJul)
X!       d = CacheDay;
X!    else {
X!       FromJulian(ARG(0).v.val, &y, &m, &d);
X!       CacheJul = ARG(0).v.val;
X!       CacheYear = y;
X!       CacheMon = m;
X!       CacheDay = d;
X!    }
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = d;
X     return OK;
X***************
X*** 559,565 ****
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    FromJulian(ARG(0).v.val, &y, &m, &d);
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = m+1;
X     return OK;
X--- 583,597 ----
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    if (ARG(0).v.val == CacheJul)
X!       m = CacheMon;
X!    else {
X!       FromJulian(ARG(0).v.val, &y, &m, &d);
X!       CacheJul = ARG(0).v.val;
X!       CacheYear = y;
X!       CacheMon = m;
X!       CacheDay = d;
X!    }
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = m+1;
X     return OK;
X***************
X*** 573,579 ****
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    FromJulian(ARG(0).v.val, &y, &m, &d);
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = y;
X     return OK;
X--- 605,619 ----
X  {
X     int y, m, d;
X     if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X!    if (ARG(0).v.val == CacheJul)
X!       y = CacheYear;
X!    else {
X!       FromJulian(ARG(0).v.val, &y, &m, &d);
X!       CacheJul = ARG(0).v.val;
X!       CacheYear = y;
X!       CacheMon = m;
X!       CacheDay = d;
X!    }
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = y;
X     return OK;
X***************
X*** 628,634 ****
X        m = ARG(0).v.val - 1;
X        if (m < 0) return E_2LOW;
X        if (m > 11) return E_2HIGH;
X!    } else FromJulian(ARG(0).v.val, &y, &m, &d);
X     s = MonthName[m];
X     return RetStrVal(s);
X  }
X--- 668,684 ----
X        m = ARG(0).v.val - 1;
X        if (m < 0) return E_2LOW;
X        if (m > 11) return E_2HIGH;
X!    } else {
X!       if (ARG(0).v.val == CacheJul)
X!          m = CacheMon;
X!       else {
X!          FromJulian(ARG(0).v.val, &y, &m, &d);
X!          CacheJul = ARG(0).v.val;
X!          CacheYear = y;
X!          CacheMon = m;
X!          CacheDay = d;
X!       }
X!    }
X     s = MonthName[m];
X     return RetStrVal(s);
X  }
X***************
X*** 856,862 ****
X  		return RetStrVal("OS/2");
X  #endif
X     return RetStrVal("MSDOS");
X! #endif  
X  }
X  
X  /***************************************************************/
X--- 906,912 ----
X  		return RetStrVal("OS/2");
X  #endif
X     return RetStrVal("MSDOS");
X! #endif
X  }
X  
X  /***************************************************************/
X***************
X*** 949,955 ****
X     if (ARG(0).type != STR_TYPE) return E_BAD_TYPE;
X     return RetStrVal(getenv(ARG(0).v.str));
X  }
X!      
X  /***************************************************************/
X  /*                                                             */
X  /*  FValue                                                     */
X--- 999,1005 ----
X     if (ARG(0).type != STR_TYPE) return E_BAD_TYPE;
X     return RetStrVal(getenv(ARG(0).v.str));
X  }
X! 
X  /***************************************************************/
X  /*                                                             */
X  /*  FValue                                                     */
X***************
X*** 1282,1298 ****
X  #endif
X  {
X     int istrue;
X  
X!    if (ARG(0).type != STR_TYPE && ARG(0).type != INT_TYPE) return E_BAD_TYPE;
X  
X!    if (ARG(0).type == INT_TYPE)
X!       istrue = ARG(0).v.val;
X!    else
X!       istrue = *(ARG(0).v.str);
X  
X!    if (istrue) DCOPYVAL(RetVal, ARG(1));
X!    else        DCOPYVAL(RetVal, ARG(2));
X  
X     return OK;
X  }
X  
X--- 1332,1360 ----
X  #endif
X  {
X     int istrue;
X+    int arg;
X  
X!    if (!(Nargs % 2)) {
X!       Eprint("IIF needs odd number of args");
X!       return E_2FEW_ARGS;
X!    }
X  
X!    for (arg=0; arg<Nargs-1; arg += 2) {
X!       if (ARG(arg).type != STR_TYPE && ARG(arg).type != INT_TYPE)
X!          return E_BAD_TYPE;
X  
X!       if (ARG(arg).type == INT_TYPE)
X!          istrue = ARG(arg).v.val;
X!       else
X!          istrue = *(ARG(arg).v.str);
X  
X+       if (istrue) {
X+          DCOPYVAL(RetVal, ARG(arg+1));
X+ 	 return OK;
X+       }
X+    }
X+ 
X+    DCOPYVAL(RetVal, ARG(Nargs-1));
X     return OK;
X  }
X  
X***************
X*** 1327,1334 ****
X  {
X     int amode;
X     char *s;
X!   
X!    if (ARG(0).type != STR_TYPE || 
X         (ARG(1).type != INT_TYPE && ARG(1).type != STR_TYPE)) return E_BAD_TYPE;
X  
X     if (ARG(1).type == INT_TYPE) amode = ARG(1).v.val;
X--- 1389,1396 ----
X  {
X     int amode;
X     char *s;
X! 
X!    if (ARG(0).type != STR_TYPE ||
X         (ARG(1).type != INT_TYPE && ARG(1).type != STR_TYPE)) return E_BAD_TYPE;
X  
X     if (ARG(1).type == INT_TYPE) amode = ARG(1).v.val;
X***************
X*** 1345,1351 ****
X  	    case 'X': amode |= X_OK; break;
X           }
X        }
X!    } 
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = access(ARG(0).v.str, amode);
X     return OK;
X--- 1407,1413 ----
X  	    case 'X': amode |= X_OK; break;
X           }
X        }
X!    }
X     RetVal.type = INT_TYPE;
X     RetVal.v.val = access(ARG(0).v.str, amode);
X     return OK;
X***************
X*** 1490,1492 ****
X--- 1552,1684 ----
X     return RetStrVal(TmpBuf);
X  }
X  
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  FHebdate                                                   */
X+ /*  FHebday						       */
X+ /*  FHebmon						       */
X+ /*  FHebyear                                                   */
X+ /*                                                             */
X+ /*  Hebrew calendar support functions                          */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FHebdate(void)
X+ #else
X+ static int FHebdate()
X+ #endif
X+ {
X+    int year, day, mon, jahr;
X+    int mout, dout;
X+    int ans, r;
X+ 
X+    if (ARG(0).type != INT_TYPE || ARG(1).type != STR_TYPE) return E_BAD_TYPE;
X+    day = ARG(0).v.val;
X+    mon = HebNameToNum(ARG(1).v.str);
X+    if (mon < 0) {
X+       Eprint("Invalid Hebrew month");
X+       return E_BAD_DATE;
X+    }
X+    if (Nargs == 2) {
X+       r = GetNextHebrewDate(JulianToday, mon, day, 0, &ans);
X+       if (r) return r;
X+       RetVal.type = DATE_TYPE;
X+       RetVal.v.val = ans;
X+       return OK;
X+    }
X+    if (Nargs == 4) {
X+       if (ARG(3).type != INT_TYPE) return E_BAD_TYPE;
X+       jahr = ARG(3).v.val;
X+       if (jahr < 0) return E_2LOW;
X+       if (jahr > 2) {
X+          r = ComputeJahr(jahr, mon, day, &jahr);
X+ 	 if (r) return r;
X+       }
X+    } else jahr = 0;
X+ 
X+ 
X+    if (ARG(2).type == INT_TYPE) {
X+       year = ARG(2).v.val;
X+       r = GetValidHebDate(year, mon, day, &mout, &dout, jahr);
X+       if (r) return r;
X+       r = HebToJul(year, mout, dout);
X+       if (r<0) return E_DATE_OVER;
X+       RetVal.v.val = r;
X+       RetVal.type = DATE_TYPE;
X+       return OK;
X+    } else if (ARG(2).type == DATE_TYPE) {
X+       r = GetNextHebrewDate(ARG(2).v.val, mon, day, jahr, &ans);
X+       if (r) return r;
X+       RetVal.v.val = ans;
X+       RetVal.type = DATE_TYPE;
X+       return OK;
X+    } else return E_BAD_TYPE;
X+ }
X+ 
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FHebday(void)
X+ #else
X+ static int FHebday()
X+ #endif
X+ {
X+    int y, m, d;
X+ 
X+    if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X+    if (ARG(0).v.val == CacheHebJul)
X+       d = CacheHebDay;
X+    else {
X+       JulToHeb(ARG(0).v.val, &y, &m, &d);
X+       CacheHebJul = ARG(0).v.val;
X+       CacheHebYear = y;
X+       CacheHebMon = m;
X+       CacheHebDay = d;
X+    }
X+    RetVal.type = INT_TYPE;
X+    RetVal.v.val = d;
X+    return OK;
X+ }
X+ 
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FHebmon(void)
X+ #else
X+ static int FHebmon()
X+ #endif
X+ {
X+    int y, m, d;
X+ 
X+    if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X+    if (ARG(0).v.val == CacheHebJul) {
X+       m = CacheHebMon;
X+       y = CacheHebYear;
X+    } else {
X+       JulToHeb(ARG(0).v.val, &y, &m, &d);
X+       CacheHebJul = ARG(0).v.val;
X+       CacheHebYear = y;
X+       CacheHebMon = m;
X+       CacheHebDay = d;
X+    }
X+    return RetStrVal(HebMonthName(m, y));
X+ }
X+ 
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FHebyear(void)
X+ #else
X+ static int FHebyear()
X+ #endif
X+ {
X+    int y, m, d;
X+ 
X+    if (ARG(0).type != DATE_TYPE) return E_BAD_TYPE;
X+    if (ARG(0).v.val == CacheHebJul)
X+       y = CacheHebYear;
X+    else {
X+       JulToHeb(ARG(0).v.val, &y, &m, &d);
X+       CacheHebJul = ARG(0).v.val;
X+       CacheHebYear = y;
X+       CacheHebMon = m;
X+       CacheHebDay = d;
X+    }
X+    RetVal.type = INT_TYPE;
X+    RetVal.v.val = y;
X+    return OK;
X+ }
X*** ../p4rel/globals.h	Mon Mar  1 16:56:30 1993
X--- ./globals.h	Thu Apr 22 10:24:07 1993
X***************
X*** 30,36 ****
X  EXTERN	int	CurDay;
X  EXTERN	int	CurMon;
X  EXTERN	int	CurYear;
X- EXTERN	int	FirstYear;
X  EXTERN  int	LineNo;
X  EXTERN  char    FreshLine;
X  EXTERN  char    LineBuffer[LINELEN];
X--- 30,35 ----
X***************
X*** 69,75 ****
X  EXTERN  INIT(   int     MaxSatIter, 150);
X  EXTERN  INIT(	char	*FileName, NULL);
X  EXTERN  FILE *ErrFp;
X- EXTERN  INIT(	int	JulFirst,  -1);
X  EXTERN  INIT(   int     NumIfs,    0);
X  EXTERN  INIT(   unsigned int IfFlags,   0);
X  EXTERN  INIT(   int     LastTriggerDate, 0);
X--- 68,73 ----
X***************
X*** 115,118 ****
X    }
X  #endif
X  ;
X- 
X--- 113,115 ----
X*** ../p4rel/init.c	Mon Mar  1 17:37:26 1993
X--- ./init.c	Thu Apr 22 10:24:09 1993
X***************
X*** 111,117 ****
X        exit(1);
X     }
X     JulianToday = RealToday;
X-    FirstYear = -1;
X     FromJulian(JulianToday, &CurYear, &CurMon, &CurDay);
X  
X     /* Parse the command-line options */
X--- 111,116 ----
X***************
X*** 350,358 ****
X        CurDay = d;
X        if (JulianToday != RealToday) IgnoreOnce = 1;
X     }
X- /* Set JulFirst */
X-    JulFirst = Julian(CurYear, 0, 1);
X-    FirstYear = CurYear;
X  }
X  
X  /***************************************************************/
X--- 349,354 ----
X***************
X*** 369,374 ****
X--- 365,373 ----
X  #endif
X  {
X     fprintf(ErrFp, "\nREMIND %s (%s version) Copyright 1992, 1993 by David F. Skoll\n", VERSION, L_LANGNAME);
X+ #ifdef BETA
X+    fprintf(ErrFp, ">>>> BETA VERSION <<<<\n");
X+ #endif   
X     fprintf(ErrFp, "Usage: remind [options] filename [date]\n");
X     fprintf(ErrFp, "Options:\n");
X     fprintf(ErrFp, " -n     Output next occurrence of reminders in simple format\n");
END_OF_FILE
  if test 52350 -ne `wc -c <'patch.05.A'`; then
    echo shar: \"'patch.05.A'\" unpacked with wrong size!
  elif test -f 'patch.05.B' ; then
    echo shar: Combining  \"'patch.05'\" \(106166 characters\)
    cat 'patch.05.A' 'patch.05.B' > 'patch.05'
    if test 106166 -ne `wc -c <'patch.05'`; then
      echo shar: \"'patch.05'\" combined with wrong size!
    else
      rm patch.05.A patch.05.B
    fi
  fi
  # end of 'patch.05.A'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
