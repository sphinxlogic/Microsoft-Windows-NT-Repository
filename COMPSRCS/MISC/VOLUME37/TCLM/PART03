Newsgroups: comp.sources.misc
From: durian@advtech.uswest.com (Mike Durian)
Subject: v37i045:  tclm - TCL extensions for MIDI file manipulation, Part03/05
Message-ID: <1993May10.215145.3932@sparky.imd.sterling.com>
X-Md4-Signature: 865dd15b90efa71a5aacfe0acb278560
Date: Mon, 10 May 1993 21:51:45 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: durian@advtech.uswest.com (Mike Durian)
Posting-number: Volume 37, Issue 45
Archive-name: tclm/part03
Environment: BSD/386, Esix SV4, SunOS, TCL 6.x

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  tclm-1.0/doc/midiget.3 tclm-1.0/doc/midiput.3
#   tclm-1.0/doc/mseq.1 tclm-1.0/doc/tclm_interface.3 tclm-1.0/infom
#   tclm-1.0/main.c tclm-1.0/minfo tclm-1.0/mlib/Makefile
#   tclm-1.0/mlib/mutil.h tclm-1.0/mrecord tclm-1.0/tclm.h
# Wrapped by kent@sparky on Mon May 10 09:43:33 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 5)."'
if test -f 'tclm-1.0/doc/midiget.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/doc/midiget.3'\"
else
  echo shar: Extracting \"'tclm-1.0/doc/midiget.3'\" \(5857 characters\)
  sed "s/^X//" >'tclm-1.0/doc/midiget.3' <<'END_OF_FILE'
X.Dt MIDIGET 3
X.Os TCLM
X.Dd April 7, 1993
X.Sh NAME
X.Nm midiget
X.Nd "tclm command to get one event from a track in a Standard MIDI File"
X.Sh SYNOPSIS
X.Nm
X.Ar mfileId
X.Ar track
X.Sh DESCRIPTION
X.Nm
Xis a
X.Xr tclm 3
Xcommand that
Xgets one event from the specified track
Xof a
XStandard
X.Tn MIDI
XFile.
XThe first argument specifies the Standard
X.Tn MIDI
XFile
Xand should be a value returned by either
X.Xr midiread 3
Xor
X.Xr midimake 3 .
XThe second argument specifies the
Xtrack from which to get the event.
XSuccessive calls to
X.Nm
Xon the same track
Xwill get successive events from
Xthat track.
X.Xr midirewind 3
Xcan be used to
Xreturn to the beginning of the track.
X.Sh RETURN VALUES
X.Nm
Xreturns the event in a form that can
Xbe used by
X.Xr midiput 3 .
XIf no more events are available in the track
X.Dq EOT
Xis returned.
X.Pp
XThe return values for the non-meta events are
Xas follows:
X.Bl -tag -width "channelpressure" -offset indent
X.It Nm channelpressure Ar channel value
XThis
X.Tn MIDI
Xevent changes the pressure parameter for
Xan entire channel.
XIt has two arguments.
XThe first the the channel number
Xand the second is the pressure value.
X.It Nm keypressure Ar channel key value
XThis event changes the pressure for one key.
XIt has three arguments.
XThe first is the channel number, the second the
Xkey value and the last the pressure value.
X.It Nm noteoff Ar channel pitch velocity
XThis event turns a note off.
XIt has three arguments.
XThe first argument is the channel, the second
Xis the pitch and the third is the velocity.
X.It Nm noteon Ar channel pitch velocity
XThis event turns a note on.
XIt takes three arguments.
XThe first arguments is the channel, the
Xsecond is the pitch and the third is the
Xvelocity.
X.It Nm parameter Ar channel param_number setting
XThis event sets a parameter value.
XIt has three arguments.
XThe first is the channel, the second
Xis the parameter number and the third
Xis the setting.
X.It Nm pitchwheel Ar channel setting
XThis event sets the pitchwheel.
XIt has two arguments.
XThe first is the channel and the second
Xis the setting.
X.Nm
Xtakes care of converting to two
X7 bit values to one integer value.
XThis integer value is returned in
Xthe setting field.
X.It Nm program Ar channel setting
XThis event changes the program for a channel.
XIt has two arguments.
XThe first argument is the channel and
Xthe second is the setting.
X.It Nm sysex Ar [cont] {byte_list}
XThis event is used to transfer implementation
Xspecific information over
X.Tn MIDI .
XIt has one or two arguments.
XIf the first argument is the string
X.Dq cont ,
Xthen
Xthe sysex message which follows
Xwas a continued sysex message
X(ie it began with a 0xf7).
XIf
X.Dq cont
Xis not specified, then the message
Xis a normal sysex message (ie it
Xbegan with a 0xf0).
XThe last argument is the data.
XIt is a list in which each element
Xis one byte of the message.
X.El
X.Pp
XThe return values for the meta events are:
X.Bl -tag -width "metachanprefix" -offset indent
X.It Nm metachanprefix Ar {byte_list}
XI really don't know what this event does, so I had to
Xguess on the format.
XIt has one argument, which is a list of bytes.
X.It Nm metacpy Ar copyright
XThis event is a text event that is used for
Xcopyrights.
XIt has one argument which is the copyright.
X.It Nm metacue Ar cue
XThis event is a text event that is used for
Xcue information.
XIt has one argument which is the cue.
X.It Nm metaeot
XThis event marks the end of a track.
XAll tracks must have one.
XIt has no arguments
X.It Nm metainstname Ar name
XThis event is a text event used for instrument
Xinformation.
XIt has one argument which is the instrument data.
X.It Nm metakey Ar key_name key_type
XThis event is used to specify a key signature.
XIt has two arguments.
XThe first is one of the following strings:
X.Dq C flat ,
X.Dq G flat ,
X.Dq D flat ,
X.Dq A flat ,
X.Dq E flat ,
X.Dq B flat ,
X.Dq F ,
X.Dq C ,
X.Dq G ,
X.Dq D ,
X.Dq A ,
X.Dq E ,
X.Dq B ,
X.Dq F sharp
Xor
X.Dq C sharp 
X(I hope I got those right - it should 7 flats to 7 sharps).
XThe second argument is either:
X.Dq major
Xor
X.Dq minor .
X.It Nm metalyric Ar lyric
XThis event is a text event used for lyrics.
XIt has one argument which is the lyric.
X.It Nm metamarker Ar marker
XThis event is a text event used for marker
Xinformation.
XIt has one argument which is the marker data.
X.It Nm metaseqname Ar name
XThis event is a text event used for naming
Xsequences.
XIt has one argument which is the sequence
Xname.
X.It Nm metaseqnum Ar number
XThis event is used for numbering sequences.
XIt has one argument which is the sequence
Xnumber.
X.It Nm metaseqspec
XI don't know anything about this event, and
Xit is not currently implemented.
X.It Nm metasmpte Ar hour minute second frame fractional_frame
XThis event is used for supplying
X.Tn SMPTE
Xinformation.
XIt has five arguments.
XThis first argument is the hour position,
Xthe second is the minute position
Xand the third the second position.
XThe fourth argument is the frame number
Xand the fifth the fractional frame number.
X.It Nm metatempo Ar tempo
XThis event is used to specify a tempo,
Xand has one argument.
XUnlike
X.Xr midiput 3
Xwhich can take the argument as either
Xbeats per minute or microseconds per
Xquarter-note,
X.Nm
Xalways uses beats per minute.
X.It Nm metatext Ar text
XThis event is a generic text event.
XIt has one argument which is a string.
X.It Nm metatime Ar numerator denominator clocks 32nds
XThis event is used for specifying the
Xtime signature.
XIt has four arguments.
XThe first is the numerator of
Xthe time signature
Xand the second is the denominator.
XThe third argument is how many clocks per
Xmetronome beat and the fourth is
Xhow many 32nd notes per quarter note.
X.Nm
Xtakes care of converting the denominator
Xfrom a negative power of two, which is the
Xform specified by Standard
X.Tn MIDI
Xfiles
Xto the integer value.
X.El
X.Sh SEE ALSO
X.Xr tclm 1 ,
X.Xr midiread 3 ,
X.Xr midimake 3 ,
X.Xr midirewind 3 ,
X.Xr midiput 3
X.Sh AUTHORS
XMike Durian - durian@advtech.uswest.com
END_OF_FILE
  if test 5857 -ne `wc -c <'tclm-1.0/doc/midiget.3'`; then
    echo shar: \"'tclm-1.0/doc/midiget.3'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/doc/midiget.3'
fi
if test -f 'tclm-1.0/doc/midiput.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/doc/midiput.3'\"
else
  echo shar: Extracting \"'tclm-1.0/doc/midiput.3'\" \(7802 characters\)
  sed "s/^X//" >'tclm-1.0/doc/midiput.3' <<'END_OF_FILE'
X.Dt MIDIPUT 3
X.Os TCLM
X.Dd April 7, 1993
X.Sh NAME
X.Nm midiput
X.Nd "tclm command to append an event to a track of a Standard MIDI File"
X.Sh SYNOPSIS
X.Nm
X.Ar mfileId
X.Ar track
X.Ar timing
X.Ar event
X.Op Ar arg ...
X.Sh DESCRIPTION
X.Nm
Xis a tclm command that
Xappends an event to a specified
Xtrack in a
XStandard
X.Tn MIDI
XFile.
XThe first argument specifies the Standard
X.Tn MIDI
XFile
Xand should be a value returned by either
X.Xr midiread 3
Xor
X.Xr midimake 3 .
XThe second argument specifies the
Xtrack in which to put the event,
Xand the third argument is the time in clocks since
Xthe previous event in the track.
XIf the timing argument is not a list, then it is
Xinterpreted as a fixed length value.
XIf it is a list of more than on value, then it is treated
Xas a variable length value as used in Standard
X.Tn MIDI
XFiles.
XTiming values specified as fixed length values are
Xconverted to variable length values by
X.Nm
Xinternally.
XThe next argument to
X.Nm
Xis the event name.
XThe remaining optional arguments are dependent on the
Xevent type.
XThe non-meta event names, their descriptions and their arguments
Xare as follows:
X.Bl -tag -width "channelpressure" -offset indent
X.It Nm channelpressure Ar channel value
XThis
X.Tn MIDI
Xevent changes the pressure parameter for
Xan entire channel.
XIt takes two arguments.
XThe first the the channel number
Xand the second is the pressure value.
XBoth values should be less than 128.
X.It Nm keypressure Ar channel key value
XThis event changes the pressure for one key.
XIt takes three arguments.
XThe first is the channel number, the second the
Xkey value and the last the pressure value.
XAll values should be less than 128.
X.It Nm noteoff Ar channel pitch velocity
XThis event turns a note off.
XIt takes two arguments with an optional third.
XThe first argument is the channel and the second
Xis the pitch.
XIf a third argument is specified, it is the
Xvelocity for the note off.
XIf it is not specified, then a velocity of
Xzero is assumed.
XIf a velocity of zero is used, either through
Xassumption or as specified, then a note
Xon event with a velocity of zero will be substituted.
XThis is to take advantage of the running status,
Xsince most
X.Tn MIDI
Xevents are note on and
Xnote off events.
XAll arguments should have values of 127 or less.
X.It Nm noteon Ar channel pitch velocity
XThis event turns a note on.
XIt takes three arguments.
XThe first argument is the channel, the
Xsecond is the pitch and the third is the
Xvelocity.
XAll values should be less than 128.
X.It Nm parameter Ar channel param_number setting
XThis event sets a parameter value.
XIt takes three arguments.
XThe first is the channel, the second
Xis the parameter number and the third
Xis the setting.
XAll values should be 127 or less.
X.It Nm pitchwheel Ar channel setting
XThis event sets the pitchwheel.
XIt takes two arguments.
XThe first is the channel and the second
Xis the setting.
XTclm takes care of converting the pitchwheel
Xsetting to the proper
X.Tn MIDI
Xevent
Xform (eg two 7 bit values).
XThe channel should be less than 128 and
Xthe setting should be less than 0x4000.
X.It Nm program Ar channel setting
XThis event changes the program for a channel.
XIt takes two arguments.
XThe first argument is the channel, and
Xthe second is the setting.
XBoth should be less than 128.
X.It Nm sysex Ar [cont] {byte_list}
XThis event is used to transfer implementation
Xspecific information over
X.Tn MIDI .
XIt takes one or two arguments.
XIf the first argument is the string
X.Dq cont ,
Xthen
X.Nm
Xwill generate a sysex message in
Xthe continuation form.
XThe second argument is then treated
Xas the data.
XIf there is only one argument, then
Xit is treated as the
Xdata.
XThe data should be in a standard tcl
Xlist with each element being a byte
Xof the sysex message.
XThe data need not specify the initial
X0xf0 or 0xf7 byte as
X.Nm
Xincludes the proper value depending
Xon if the
X.Dq cont
Xstring was an argument.
XIt is up to the user to make sure
Xall sysex messages are properly
Xterminated.
XAll data in the sysex message should
Xbe less than 128.
X.El
X.Pp
XAll non-meta events except sysex take advantage
Xof the running status feature of Standard
X.Tn MIDI
XFiles.
XThat is, if one event immediately follows an event
Xof the same track on the same channel, then the
Xevent type need not be explicitly stated and is
Xassumed to be the same as the previous value.
X.Pp
XIn addition to the events listed above,
X.Nm
Xcan also be used with meta events.
XTheir names, descriptions and parameters are:
X.Bl -tag -width "metachanprefix" -offset indent
X.It Nm metachanprefix Ar {byte_list}
XI really don't know what this event does, so I had to
Xguess on the format.
XIt takes one argument, which is a list of bytes.
X.It Nm metacpy Ar copyright
XThis event is a text event that is used for
Xcopyrights.
XIt takes one argument which should be the copyright
Xas a string.
X.It Nm metacue Ar cue
XThis event is a text event that is used for
Xcue information.
XIt takes one argument which should be the cue
Xas a string.
X.It Nm metaeot
XThis event marks the end of a track.
XAll tracks must have one.
XIt takes no arguments.
X.It Nm metainstname Ar name
XThis event is a text event used for instrument
Xinformation.
XIt takes one arguments which should be the instrument
Xdata as a string.
X.It Nm metakey Ar key_name key_type
XThis event is used to specify a key signature.
XIt takes two arguments.
XThe first should be one of the following strings:
X.Dq C flat ,
X.Dq G flat ,
X.Dq D flat ,
X.Dq A flat ,
X.Dq E flat ,
X.Dq B flat ,
X.Dq F ,
X.Dq C ,
X.Dq G ,
X.Dq D ,
X.Dq A ,
X.Dq E ,
X.Dq B ,
X.Dq F sharp
Xor
X.Dq C sharp 
X(I hope I got those right - it should 7 flats to 7 sharps).
XThe second argument should be either:
X.Dq major
Xor
X.Dq minor .
X.It Nm metalyric Ar lyric
XThis event is a text event used for lyrics.
XIt takes one argument which is the lyric
Xin string form.
X.It Nm metamarker Ar marker
XThis event is a text event used for marker
Xinformation.
XIt takes one argument which is the marker
Xdata as a string.
X.It Nm metaseqname Ar name
XThis event is a text event used for naming
Xsequences.
XIt takes one argument which is the sequence
Xname as a string.
X.It Nm metaseqnum Ar number
XThis event is used for numbering sequences.
XIt takes one argument which is the sequence
Xnumber.
X.Nm
Xconverts the number to the proper two
Xbyte form.
X.It Nm metaseqspec
XI don't know anything about this event, and
Xit is not currently implemented.
X.It Nm metasmpte Ar hour minute second frame fractional_frame
XThis event is used for supplying
X.Tn SMPTE
Xinformation.
XIt takes five arguments.
XThe first argument is the hour position,
Xthe second is the minute position
Xand the third the second position.
XThe fourth argument is the frame number
Xand the fifth the fractional frame number.
X.It Nm metatempo Ar tempo
XThis event is used to specify a tempo.
XIt takes one argument.
XThe argument should be an integer.
XIf the number has a
X.Sq u
Xcharacter at
Xthe end it is treated as if it
Xrepresents microseconds per quarter-note.
XIf it does not have a
X.Sq u
Xcharacter then
Xit is treated as if it represents
Xbeats per minute.
X.It Nm metatext Ar text
XThis event is a generic text event.
XIt take one argument which is a string.
X.It Nm metatime Ar numerator denominator clocks 32nds
XThis event is used for specifying the
Xtime signature.
XIt takes four arguments.
XThe first is the numerator of
Xthe time signature
Xand the second is the denominator.
XThe third argument is the number of clocks per
Xmetronome beat and the fourth is
Xthe number of 32nd notes per quarter note.
X.Nm
Xtakes care of converting the denominator
Xto a negative power of two, which is the
Xform specified by Standard
X.Tn MIDI
XFiles.
X.El
X.Sh RETURN VALUES
X.Nm
Xreturns nothing.
X.Sh BUGS
X.Nm
Xshould be rewritten to handle
Xinserting events in the middle
Xof a track.
X.Sh SEE ALSO
X.Xr tclm 1 ,
X.Xr midiread 3 ,
X.Xr midimake 3 ,
X.Xr midiget 3
X.Sh AUTHORS
XMike Durian - durian@advtech.uswest.com
END_OF_FILE
  if test 7802 -ne `wc -c <'tclm-1.0/doc/midiput.3'`; then
    echo shar: \"'tclm-1.0/doc/midiput.3'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/doc/midiput.3'
fi
if test -f 'tclm-1.0/doc/mseq.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/doc/mseq.1'\"
else
  echo shar: Extracting \"'tclm-1.0/doc/mseq.1'\" \(6593 characters\)
  sed "s/^X//" >'tclm-1.0/doc/mseq.1' <<'END_OF_FILE'
X.Dt MSEQ 1
X.Os TCLM
X.Dd April 7, 1993
X.Sh NAME
X.Nm mseq
X.Nd "a tclm script to sequence MIDI files according to a simple language"
X.Sh SYNOPSIS
X.Nm
X.Op sequence_file Op midi_file
X.Sh DESCRIPTION
X.Nm
Xis a
X.Xr tclm 1
Xscript that sequences Standard
X.Tn MIDI
Xfiles according to a simple
Xlanguage.
XThe sequenced result is placed in a new
X.Tn MIDI
Xfile.
X.Pp
XIf an output
X.Tn MIDI
Xfile is not specified, then
Xoutput is sent to
X.Em stdout .
XIf an input sequence file is not specified then
Xinput is read from
X.Em stdin .
X.Pp
XThe purpose of
X.Nm
Xis to generate more complicated
X.Tn MIDI
Xfiles from
Xsmaller
X.Tn MIDI
Xfile components.
X.Ss SEQUENCING LANGUAGE
XThe language 
X.Nm
Xuses is
X.Dq spartan
Xat best, but does provide
Xuseful functionality.
XIt allows one to play parts in parallel
Xby specifying information for different
Xtracks, group phrases into blocks
Xand repeat blocks.
X.Pp
XThe
X.Tn BNF ,
Xor
X.No quasi- Ns Tn BNF
Xas I don't quite
Xremember the true form, looks like this:
X.sp
X.Bl -item -compact -offset indent
X.It
Xmseq_file :== section+
X.It
Xsection :== 
X.Em track
Xstatement+
X.It
Xstatement :== labeled sequence | filename | command | comment
X.It
Xlabeled sequence :== label sequence
X.It
Xlabel :==
X.Pf name Em \:
X.It
Xsequence :== block | filename
X.It
Xblock :==
X.Em {
Xsequence+
X.Em }
X.It
Xcommand :==
X.Em repeat
Xlabel |
X.Em repeat
Xlabel multiplier
X.It
Xmultiplier :== number
X.It
Xcomment :==
X.Em #
Xanything to end-of-line
X.El
X.sp
XThe results look like this (though this isn't
Xa very practical example):
X.sp
X.Bd -literal -compact -offset indent
Xtrack
X# This is track 1
Xpat1.mid
Xpat2.mid
XA: {
X	pat3.mid
X	B: { # block B:
X		pat4.mid
X		pat5.mid
X	}
X	pat6.mid
X	repeat B: 3
X}
Xpat7.mid
Xpat8.mid # pattern 8
X
X# This is track 2
Xtrack
Xpat1.mid
Xpat2.mid
XA: {
X	pat3.mid
X	pat4.mid
X	B: pat5.mid
X	pat6.mid
X	repeat B: 6
X}
Xpat7.mid
Xrepeat A:
X.Ed
X.Pp
XThere are six main parts to a sequence
Xfile.
XThere are
X.Em tracks ,
X.Em blocks ,
X.Em repeats ,
X.Em comments ,
Xand
X.Em files .
XThe tracks are different sections of the sequence
Xthat should play in parallel and should
Xbelong to separate tracks in the output
X.Tn MIDI
Xfile.
XEach track will start at time 0, the beginning
Xof the sequence.
XEvery sequence must have at least one track.
XTracks are designated by the word
X.Em track .
XThis is a simple example of using tracks,
X.sp
X.Bd -literal -compact -offset indent
Xtrack
Xpart1.mid
Xpart2.mid
Xpart3.mid
X
Xtrack
XpartA.mid
XpartB.mid
XpartC.mid
X.Ed
X.sp
XIn this case two tracks will be created and, assuming
Xall the parts are the same length, part1.mid will be
Xplayed the same time partA.mid is played, part2.mid
Xwill be played the same time partB.mid is played, etc.
X.Pp
XBlocks are groups of one or more files or other
Xblocks.
XEach block has a label, which is designated by
Xending in a
X.So : Sc .
XIf a block is to consist of only on file, then
Xit may be labeled directly like,
X.sp
X.Bd -literal -compact -offset indent
XShortBlock: part1.mid
X.Ed
X.sp
XOtherwise the block should be enclosed in
Xcurly braces like,
X.sp
X.Bd -literal -compact -offset indent
XLongerBlock: {
X	part1.mid
X	part2.mid
X	part3.mid
X}
X.Ed
X.sp
XBlocks may even contain other blocks like,
X.sp
X.Bd -literal -compact -offset indent
XOutterBlock: {
X	part1.mid
X	InnerBlock: {
X		part2.mid
X		part3.mid
X	}
X	part4.mid
X}
X.Ed
X.sp
XIn this case
X.Em InnerBlock:
Xcontains
X.Em part2.mid
Xand
X.Em part3.mid ,
Xwhile
X.Em OutterBlock:
Xcontains
X.Em part1.mid , part2.mid , part3.mid
X.Em part4.mid .
X.Pp
XRepeats provide a way of re-sequencing previously
Xdefined blocks.
XRepeats consist of the string
X.Em repeat
Xfollowed by a block name, including the colon,
Xand an optional number.
XThe optional number specifies the number of times
Xthe block should be repeated.
XIf no number is specified, the block is only
Xrepeated once.
XA simple example of a repeat looks like,
X.sp
X.Bd -literal -compact -offset indent
XABlock: part1.mid
Xrepeat ABlock: 3
X.Ed
X.sp
XThe sequence generated by this
Xfragment would contain,
X.Em part1.mid , part1.mid , part1.mid
Xand
X.Em part1.mid .
XA more complicated example might look like,
X.sp
X.Bd -literal -compact -offset indent
XBlock1: {
X	part1.mid
X	part2.mid
X	Block2: {
X		part3.mid
X		part4.mid
X	}
X	repeat Block2: 2
X}
Xpart5.mid
Xrepeat Block1:
X.Ed
X.sp
XThis sequence generates,
X.Em part1.mid , part2.mid , part3.mid ,
X.Em part4.mid , part3.mid , part4.mid ,
X.Em part3.mid , part4.mid , part5.mid ,
X.Em part1.mid , part2.mid , part3.mid ,
X.Em part4.mid , part3.mid , part4.mid ,
X.Em part3.mid
Xand
X.Em part4.mid .
X.Pp
XComments begin with a
X.Sq #
Xand continue to the
Xend of a line.
X.Nm
Xcompletely ignores anything in a comment.
XThis is an example of a few comments,
X.sp
X.Bd -literal -compact -offset indent
Xtrack
X# This track is for the drum part
Xbackbeat: pat1.mid
Xrepeat pat1.mid 7
Xpat2.mid   # here's a turn around fill
X.Ed
X.sp
X.Pp
XThe final part of a sequence file is the
Xmost important.
XIt is the filenames of the smaller
X.Tn MIDI
Xfiles that are to be
Xsequenced.
XEach filename specifies one
X.Tn MIDI
Xfile
Xand is read into the sequence as they are
Xencountered in the sequence file.
XThey are also read in when blocks containing
Xthem are repeated.
XCurrently, only
X.Tn MIDI
Xfiles of format
X1 are accepted.
X.Pp
XThough there is not much complexity in the sequencing
Xlanguage, it should be rich enough
Xto allow the easy creation of sophisticated
X.Tn MIDI
Xfiles.
X.Ss OUTPUT MIDI FILE
XThe final output
X.Tn MIDI
Xfile created from
Xthe sequence is in the Standard
X.Tn MIDI
XFormat,
Xand is a format type 1 file.
XAll the meta events from each sequenced
X.Tn MIDI
Xare merged together and put in track 0 at their
Xproper relative times.
XFor instance, a
X.Em metaseqname
Xevent occurring at time
X10 in the first track will be at time 10 in the output
Xfile as will a
X.Em metaseqname
Xevent occurring at time
X10 in the third track.
XBe aware of potential conflicts between
X.Em metatempo
Xevents in different tracks.
X.Pp
XThe remaining tracks in the output
X.Tn MIDI
Xfile
Xwill correspond to the
X.Em tracks
Xin the sequence file.
XThese tracks are created by collapsing each smaller
X.Tn MIDI
Xfile listed in the sequence file to
Xjust two tracks, track 0 which remains unchanged, and
Xtrack 1 which is created by merging all the other
Xtracks in the file.
XThese collapsed files are then concatenated together
Xto form one long
X.Tn MIDI
Xfile for each track.
XAs mentioned above, the track 0's from each sequence
X.Em track
Xare then merged to form one new track 0 while the other tracks
Xare kept separate in the final output.
X.Pp
XThe resulting
X.Tn MIDI
Xfile can then be manipulated
Xjust like any other
X.Tn MIDI
Xfile.
X.Sh SEE ALSO
X.Xr tclm 1 ,
X.Xr midimerge 3 ,
X.Xr midiget 3
X.Sh AUTHORS
XMike Durian - durian@advtech.uswest.com
END_OF_FILE
  if test 6593 -ne `wc -c <'tclm-1.0/doc/mseq.1'`; then
    echo shar: \"'tclm-1.0/doc/mseq.1'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/doc/mseq.1'
fi
if test -f 'tclm-1.0/doc/tclm_interface.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/doc/tclm_interface.3'\"
else
  echo shar: Extracting \"'tclm-1.0/doc/tclm_interface.3'\" \(4457 characters\)
  sed "s/^X//" >'tclm-1.0/doc/tclm_interface.3' <<'END_OF_FILE'
X.Dt TCLM_INTERFACE 3
X.Os TCLM
X.Dd April 20, 1993
X.Sh NAME
X.Nm tclm_interface
X.Nd "function hooks to interface tclm to a MIDI device"
X.Sh SYNOPSIS
X.Fd #include <mdevice.h>
X.Fd typedef enum {PLAY, RECORD, PLAYRECORD} PlayMode
X.Ft int
X.Fn play_tracks "int dev" "TCHUNK *tracks" "int *indices" "int num" "int repeat"
X.Ft int
X.Fn record_tracks "int dev" "TCHUNK *p_tracks" "int *indices" "int p_num" "TCHUNK *r_track" "int repeat"
X.Ft int
X.Fn stop_processing "int dev"
X.Ft int
X.Fn open_midi_device "PlayMode mode"
X.Ft int
X.Fn init_midi_device "int dev" "HCHUNK *hd" "double reltempo"
X.Ft int
X.Fn start_midi_device "int dev" "PlayMode mode"
X.Ft int
X.Fn stop_midi_device "int dev" "PlayMode mode"
X.Ft int
X.Fn close_midi_device "int dev"
X.Sh DESCRIPTION
X.Ss play_tracks
X.Fn play_tracks
Xprovides the functionality to convert events in
XStandard
X.Tn MIDI
XFile
X.No ( Tn SMF Ns No )
Xform to a form
Xthe
X.Tn MIDI
Xdevice wants, and to send the converted
Xevents to the device to be played.
X.Pp
XThe
X.Ar dev
Xargument specifies the
X.Tn MIDI
Xdevice that the
Xevents will be sent to.
XThis value is what was returned from
X.Fn open_midi_device .
XThe second argument,
X.Ar tracks ,
Xis a pointer to a list of
X.Tn SMF
Xtracks as
Xfound in
X.Tn MIDI
Xfiles.
X.Ar indices
Xis a pointer to a list of indices to the
X.Ar tracks .
XEach index is the index number of a track
Xthat should be played.
XThe fourth argument,
X.Ar num ,
Xis the number of indices pointed to by
X.Ar indices .
XIt is also the number of tracks to play.
X.Ar repeat ,
Xthe final argument is a boolean value.
XIf it is true it signifies that the tracks
Xshould be replayed when they reach their
Xend.
X.Pp
X.Fn play_tracks
Xdoes not send the actual commands
Xto start and stop playing.
XIt only processes and sends the
Xevents.
X.Ss record_tracks
X.Fn record_tracks
Xis very similar to
X.Fn play_tracks
Xand only differs in one argument.
XIt provides the functionality
Xto play
X.Em and
Xrecord
X.Tn SMF
Xfiles.
XIf
X.Ar p_tracks
Xis NULL, or
X.Ar p_num
Xis 0, then nothing will be played
Xwhile recording.
X.Pp
XThe only argument that differs from
X.Fn play_tracks
Xis the
X.Ar r_track
Xargument.
XThis argument specifies
Xthe track where the recorded
Xevents should be placed.
X.Ss stop_processing
X.Fn stop_processing
Xprovides the ability to abort
Xfrom a
X.Fn play_tracks
Xcall or a
X.Fn record_tracks
Xcall.
XWhen called,
X.Fn stop_processing ,
Xforces the two routines
Xto exit with success.
X.Fn stop_processing
Xis designed for use in
Xprocesses playing or recording in
Xthe background.
XIt takes one argument, the device
Xdescriptor and returns 1 on success
Xand 0 on failure.
X.Ss open_midi_device
X.Fn open_midi_device
Xopens the appropriate
X.Tn MIDI
Xdevice for use by the
Xother functions.
XIt takes one argument which is the
Xplay mode.
XThe play mode will be one of either
X.Tn PLAY , RECORD
Xor
X.Tn PLAYRECORD .
XIt returns the descriptor for
Xthat device.
X.Ss init_midi_device
X.Fn init_midi_device
Xtakes care of any initial
Xset up the device needs.
X.Ar dev
Xis the device descriptor as
Xreturned by
X.Fn open_midi_device .
XThe
X.Ar hd
Xargument contains the
Xheader chunk information
Xfor the file to be processed.
XThe division information in the header chunk might
Xbe especially useful.
XThe
X.Ar reltempo
Xargument contains a tempo
Xscaling factor.
XIf possible any tempos
Xfound in the playing files should
Xbe multiplied by this value.
XIf that is not possible, this argument
Xmay be ignored.
X.Ss start_midi_device
X.Fn start_midi_device
Xstarts the
X.Tn MIDI
Xdevice
Xspecified by
X.Ar dev
Xplaying or recording or both.
XThe
X.Ar mode
Xargument determines which should occur.
XIt will be one of
X.Tn PLAY , RECORD
Xor
X.Tn PLAYRECORD .
X.Ss stop_midi_device
X.Fn stop_midi_device
Xstops the
X.Tn MIDI
Xdevice
Xfrom further playing or recording.
XIt differs from
X.Fn stop_processing
Xin that it switches the device
Xoff rather than stopping the
Xflow of data to the device.
XThe argument
X.Ar dev
Xcontains the descriptor for
Xthe device as returned by
X.Fn open_midi_device .
X.Ar mode
Xcontains the same value that was used
Xin
X.Fn start_midi_device .
X.Ss close_midi_device
X.Fn close_midi_device
Xdoes any clean up necessary for the
X.tn MIDI
Xdevice and closes the
Xdescriptor.
X.Ar dev
Xis the descriptor for the device
Xas returned by
X.Fn open_midi_device .
X.Sh RETURN VALUES
XAll functions with the exception of
X.Fn open_midi_device ,
Xwhich returns the descriptor number,
Xreturn 1 on success and 0 otherwise.
X.Fn open_midi_device
Xreturns -1 on error.
X.Sh SEE ALSO
X.Xr tclm 1
X.Sh AUTHORS
XMike Durian - durian@advtech.uswest.com
END_OF_FILE
  if test 4457 -ne `wc -c <'tclm-1.0/doc/tclm_interface.3'`; then
    echo shar: \"'tclm-1.0/doc/tclm_interface.3'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/doc/tclm_interface.3'
fi
if test -f 'tclm-1.0/infom' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/infom'\"
else
  echo shar: Extracting \"'tclm-1.0/infom'\" \(6958 characters\)
  sed "s/^X//" >'tclm-1.0/infom' <<'END_OF_FILE'
X#!/usr/local/bin/tclm -f
X#
X# Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X#
X# Redistribution and use in source and binary forms, with or without
X# modification, are permitted provided that the following conditions
X# are met:
X# 1. Redistributions of source code must retain the above copyright
X#    notice, this list of conditions and the following disclaimer.
X# 2. Redistributions in binary form must reproduce the above copyright
X#    notice, this list of conditions and the following disclaimer in the
X#    documentation and/or other materials provided with the distribution.
X# 3. All advertising materials mentioning features or use of this software
X#    must display the following acknowledgement:
X#	This product includes software developed by Michael B. Durian.
X# 4. The name of the the Author may be used to endorse or promote 
X#    products derived from this software without specific prior written 
X#    permission.
X#
X# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X# SUCH DAMAGE.
X#
X
X# infom,v 1.2 1993/05/06 21:42:20 durian Exp
X
X# get filename arg
Xif {[string compare [lindex $argv 0] "-f"] == 0} {
X	incr argc -2
X	set argv [lrange $argv 2 end]
X}
X
Xcase $argc in {
X	0 {
X		set infile_name stdin
X		set outfile_name stdout
X	} 1 {
X		set infile_name [lindex $argv 0]
X		set outfile_name stdout
X	} 2 {
X		set infile_name [lindex $argv 0]
X		set outfile_name [lindex $argv 1]
X	} default {
X		puts stderr "Usage: infom [info_file [midi_file]]"
X		exit 1
X	}
X}
X
Xproc PutEvent {event mfile track_num last_timing} {
X
X	# get the timing part of the event
X	set timing [lindex $event 0]
X	# minus :
X	set timing [string trimright $timing :]
X
X	#determine time since last event
X	set delta [expr {$timing - $last_timing}]
X
X	case [lindex $event 1] in {
X	NOTEOFF {
X		set chan [lindex $event 3]
X		set pitch [lindex $event 5]
X		set vel [lindex $event 7]
X		midiput $mfile $track_num $delta noteoff $chan $pitch $vel
X	} NOTEON {
X		set chan [lindex $event 3]
X		set pitch [lindex $event 5]
X		set vel [lindex $event 7]
X		midiput $mfile $track_num $delta noteon $chan $pitch $vel
X	} KEY {
X		set chan [lindex $event 4]
X		set pitch [lindex $event 6]
X		set pres [lindex $event 8]
X		midiput $mfile $track_num $delta keypressure $chan $pitch $pres
X	} PARAMETER {
X		set chan [lindex $event 3]
X		set param [lindex $event 5]
X		set set [lindex $event 7]
X		midiput $mfile $track_num $delta parameter $chan $param $set
X	} PROGRAM {
X		set chan [lindex $event 3]
X		set prog [lindex $event 5]
X		midiput $mfile $track_num $delta program $chan $prog
X	} CHANNEL {
X		set chan [lindex $event 4]
X		set pres [lindex $event 6]
X		midiput $mfile $track_num $delta channelpressure $chan $pres
X	} PITCH {
X		set chan [lindex $event 4]
X		set val [lindex $event 6]
X		midiput $mfile $track_num $delta pitchwheel $chan $val
X	} METACHANPREFIX {
X		midiput $mfile $track_num $delta metachanprefix \
X		    [lrange $event 2 end]
X	} METACPY {
X		midiput $mfile $track_num $delta metacpy [lrange $event 2 end]
X	} METACUE {
X		midiput $mfile $track_num $delta metacue [lrange $event 2 end]
X	} METAEOT {
X		midiput $mfile $track_num $delta metaeot
X	} METAINSTNAME {
X		midiput $mfile $track_num $delta metainstname \
X		    [lrange $event 2 end]
X	} METAKEY {
X		midiput $mfile $track_num $delta metakey [lindex $event 2] \
X		    [lindex $event 3]
X	} METALYRIC {
X		midiput $mfile $track_num $delta metalyric \
X		    [lrange $event 2 end]
X	} METAMARKER {
X		midiput $mfile $track_num $delta metamarker \
X		    [lrange $event 2 end]
X	} METASEQNAME {
X		midiput $mfile $track_num $delta metaseqname \
X		    [lrange $event 2 end]
X	} METASEQNUM {
X		midiput $mfile $track_num $delta metaseqnum [lindex $event 2]
X	} METASEQSPEC {
X		# no idea, so we skip it
X		return $last_timing
X	} METASMPTE {
X		set hr [string trimright [lindex $event 3] ,]
X		set mi [string trimright [lindex $event 5] ,]
X		set se [string trimright [lindex $event 7] ,]
X		set fr [string trimright [lindex $event 9] ,]
X		set ff [lindex $event 12]
X		midiput $mfile $track_num $delta metasmpte $hr $mi $se $fr $ff
X	} METATEMPO {
X		midiput $mfile $track_num $delta metatempo [lindex $event 2]
X	} METATEXT {
X		midiput $mfile $track_num $delta metatext [lrange $event 2 end]
X	} METATIME {
X		set fraction [split [lindex $event 2] /]
X		set num [lindex $fraction 0]
X		set den [lindex $fraction 1]
X		set cpm [lindex $event 3]
X		set _32 [lindex $event 8]
X		midiput $mfile $track_num $delta metatime $num $den $cpm $_32
X	} SYSEX {
X		if {[string compare [lindex $event 2] cont] == 0} {
X			midiput $mfile $track_num $delta sysex cont \
X			    [lrange $event 3 end]
X		} else {
X			midiput $mfile $track_num $delta sysex \
X			    [lrange $event 2 end]
X		}
X	}
X	}
X
X	return $timing
X}
X
Xif {[string compare $infile_name stdin] == 0} {
X	set infile stdin
X} else {
X	if {![file exists $infile_name]} then {
X		puts stderr "Bad file name: $infile_name"
X		exit 1
X	} else {
X		set infile [open $infile_name "r"]
X	}
X}
X
Xif {[string compare $outfile_name stdout] == 0} {
X	set outfile stdout
X} else {
X	# check to see if the specified file exists and open it
X	if {[catch {open $outfile_name "w"} outfile]} {
X		puts stderr "Couldn't open $midi_file_name for writing"
X		puts stderr $outfile
X	}
X}
X
X# make an empty mfile
Xset mfile [midimake]
X
X# skip over filename since we use the command line
Xif {[gets $infile line] == -1} {
X	puts stderr "bad input line: $junk"
X	exit 1
X}
X
X# get format
Xif {[gets $infile line] == -1} {
X	puts stderr "bad input line: $junk"
X	exit 1
X}
Xset format [lindex $line 2]
Xmidiconfig $mfile format $format
X
X# get division
Xif {[gets $infile line] == -1} {
X	puts stderr "bad input line: $junk"
X	exit 1
X}
Xset division [lindex $line 2]
Xmidiconfig $mfile division $division
X
X# get num_trks
Xif {[gets $infile line] == -1} {
X	puts stderr "bad input line: $junk"
X	exit 1
X}
Xset num_trks [lindex $line 4]
Xmidiconfig $mfile tracks $num_trks
X
X# generate all the tracks
Xset track 0
Xwhile {1} {
X	if {[gets $infile line] == -1} {
X		if {[expr {$num_trks - 1}] != $track} {
X			puts stderr "bad input line: $junk"
X			exit 1
X		} else {
X			break
X		}
X	}
X	if {[string compare [lindex $line 0] Track] == 0} {
X		set timing 0
X		set track [lindex $line 1]
X		continue
X	}
X	if {[string length $line] == 0} {
X		continue
X	}
X	set timing [PutEvent $line $mfile $track $timing]
X}
Xmidiwrite $mfile $outfile
Xmidifree $mfile
Xclose $outfile
Xclose $infile
Xexit 0
END_OF_FILE
  if test 6958 -ne `wc -c <'tclm-1.0/infom'`; then
    echo shar: \"'tclm-1.0/infom'\" unpacked with wrong size!
  fi
  chmod +x 'tclm-1.0/infom'
  # end of 'tclm-1.0/infom'
fi
if test -f 'tclm-1.0/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/main.c'\"
else
  echo shar: Extracting \"'tclm-1.0/main.c'\" \(3578 characters\)
  sed "s/^X//" >'tclm-1.0/main.c' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by Michael B. Durian.
X * 4. The name of the the Author may be used to endorse or promote 
X *    products derived from this software without specific prior written 
X *    permission.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X/*
X * main.c,v 1.4 1993/05/07 17:45:03 durian Exp
X */
X
Xstatic char cvsid[] = "main.c,v 1.4 1993/05/07 17:45:03 durian Exp";
X
X#include "tclInt.h"
X#include "mutil.h"
X#include "tclm.h"
X
X/*
X * Declarations for library procedures:
X */
X
Xextern int isatty();
X
XTcl_Interp *interp;
XTcl_CmdBuf buffer;
Xint tty;
X
Xvoid usage _ANSI_ARGS_(());
Xextern char *optarg;
X
X    /* ARGSUSED */
Xint
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{
X	static int gotPartial = 0;
X	int result;
X	FILE *file;
X	char *args;
X	char *cmd;
X	int have_f;
X	char buf[20];
X	char line[200];
X	char opt;
X
X	have_f = 0;
X	file = stdin;
X
X	/*
X	 * we want to stop parsing args when we get a -f, so the
X	 * script can get the args it wants
X	 */
X	while (!have_f && (opt = getopt(argc, argv, "f:")) != -1) {
X		switch (opt) {
X		case 'f':
X			if ((file = fopen(optarg, "r")) == NULL) {
X				fprintf(stderr, "Couldn't open %s\n", optarg);
X				exit(1);
X			}
X			have_f = 1;
X			break;
X		case '?':
X			usage();
X			exit(1);
X		}
X	}
X
X	interp = Tcl_CreateInterp();
X	args = Tcl_Merge(argc-1, argv+1);
X	Tcl_SetVar(interp, "argv", args, TCL_GLOBAL_ONLY);
X	ckfree(args);
X	sprintf(buf, "%d", argc - 1);
X	Tcl_SetVar(interp, "argc", buf, TCL_GLOBAL_ONLY);
X	Tclm_InitMidi(interp);
X	buffer = Tcl_CreateCmdBuf();
X	tty = isatty(0);
X
X	for (;;) {
X		if (file == stdin && tty)
X			printf("tclm: ");
X
X		if (fgets(line, 200, file) == NULL)
X			break;
X		cmd = Tcl_AssembleCmd(buffer, line);
X		if (cmd == NULL) {
X			gotPartial = 1;
X			continue;
X		}
X		gotPartial = 0;
X		result = Tcl_RecordAndEval(interp, cmd, 0);
X		if (*interp->result != 0) {
X			if (result != TCL_OK) {
X				printf("%s\n", Tcl_GetVar(interp, "errorInfo",
X				    0));
X				if (file !=stdin || !tty)
X					break;
X			} else if (file == stdin && tty) {
X				printf("%s\n", interp->result);
X			}
X		}
X	}
X
X	Tcl_DeleteInterp(interp);
X	Tcl_DeleteCmdBuf(buffer);
X	exit(0);
X}
X
Xvoid
Xusage()
X{
X
X	(void) fprintf(stderr, "Usage: tclm [ -f filename ]\n");
X}
END_OF_FILE
  if test 3578 -ne `wc -c <'tclm-1.0/main.c'`; then
    echo shar: \"'tclm-1.0/main.c'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/main.c'
fi
if test -f 'tclm-1.0/minfo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/minfo'\"
else
  echo shar: Extracting \"'tclm-1.0/minfo'\" \(5581 characters\)
  sed "s/^X//" >'tclm-1.0/minfo' <<'END_OF_FILE'
X#!/usr/local/bin/tclm -f
X#
X# Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X#
X# Redistribution and use in source and binary forms, with or without
X# modification, are permitted provided that the following conditions
X# are met:
X# 1. Redistributions of source code must retain the above copyright
X#    notice, this list of conditions and the following disclaimer.
X# 2. Redistributions in binary form must reproduce the above copyright
X#    notice, this list of conditions and the following disclaimer in the
X#    documentation and/or other materials provided with the distribution.
X# 3. All advertising materials mentioning features or use of this software
X#    must display the following acknowledgement:
X#	This product includes software developed by Michael B. Durian.
X# 4. The name of the the Author may be used to endorse or promote 
X#    products derived from this software without specific prior written 
X#    permission.
X#
X# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X# SUCH DAMAGE.
X#
X
X# minfo,v 1.6 1993/04/08 04:16:01 durian Exp
X
X# get filename arg
Xif {[string compare [lindex $argv 0] "-f"] == 0} {
X	set midi_file_name [lindex $argv 2]
X} else {
X	set midi_file_name [lindex $argv 0]
X}
X
Xproc FormatEvent {event} {
X	global pos
X
X	# get the timing part of the event
X	set timing [lindex $event 0]
X
X	# determine offset from start of track
X	set pos [expr {$timing + $pos}]
X	set out [format "%6d: " $pos]
X
X	case [lindex $event 1] in {
X	noteoff {
X		set chan [lindex $event 2]
X		set pitch [lindex $event 3]
X		set vel [lindex $event 4]
X		append out "NOTEOFF channel $chan pitch $pitch velocity $vel"
X	} noteon {
X		set chan [lindex $event 2]
X		set pitch [lindex $event 3]
X		set vel [lindex $event 4]
X		append out "NOTEON channel $chan pitch $pitch velocity $vel"
X	} keypressure {
X		set chan [lindex $event 2]
X		set pitch [lindex $event 3]
X		set pres [lindex $event 4]
X		append out \
X		    "KEY PRESSURE channel $chan pitch $pitch pressure $pres"
X	} parameter {
X		set chan [lindex $event 2]
X		set param [lindex $event 3]
X		set set [lindex $event 4]
X		append out \
X		    "PARAMETER channel $chan parameter $param setting $set"
X	} program {
X		set chan [lindex $event 2]
X		set prog [lindex $event 3]
X		append out "PROGRAM channel $chan program $prog"
X	} channelpressure {
X		set chan [lindex $event 2]
X		set pres [lindex $event 3]
X		append out "CHANNEL PRESSURE channel $chan pressure $pres"
X	} pitchwheel {
X		set chan [lindex $event 2]
X		set val [lindex $event 3]
X		append out "PITCH WHEEL channel $chan value $val"
X	} metachanprefix {
X		append out "METACHANPREFIX [lindex $event 2]"
X	} metacpy {
X		append out "METACPY [lindex $event 2]"
X	} metacue {
X		append out "METACUE [lindex $event 2]"
X	} metaeot {
X		append out "METAEOT"
X	} metainstname {
X		append out "METAINSTNAME [lindex $event 2]"
X	} metakey {
X		append out "METAKEY [lindex $event 2] [lindex $event 3]"
X	} metalyric {
X		append out "METALYRIC [lindex $event 2]"
X	} metamarker {
X		append out "METAMARKER [lindex $event 2]"
X	} metaseqname {
X		append out "METASEQNAME [lindex $event 2]"
X	} metaseqnum {
X		append out "METASEQNUM [lindex $event 2]"
X	} metaseqspec {
X		append out "METASEQSPEC"
X	} metasmpte {
X		set hr [lindex $event 2]
X		set mi [lindex $event 3]
X		set se [lindex $event 4]
X		set fr [lindex $event 5]
X		set ff [lindex $event 6]
X		append out \
X		    "METASMPTE Hour $hr, Min. $mi, Sec. $se, Frame $fr, Frac. Frame $ff"
X	} metatempo {
X		append out "METATEMPO [lindex $event 2] BPM"
X	} metatext {
X		append out "METATEXT [lindex $event 2]"
X	} metatime {
X		set num [lindex $event 2]
X		set den [lindex $event 3]
X		set cpm [lindex $event 4]
X		set _32 [lindex $event 5]
X		append out \
X		    "METATIME $num/$den, $cpm clocks per met. beat, $_32 32nd notes per 1/4 note"
X	} sysex {
X		append out "SYSEX [lindex $event 2]"
X		if {[llength $event] > 3} {
X			append out " [lindex $event 3]"
X		}
X	}
X	}
X
X	return $out
X}
X
Xif {[string length $midi_file_name] == 0} {
X	# if no filename is specified use stdin
X	set midi_file stdin
X	set midi_file_name stdin
X} else {
X	# check to see if the specified file exists and open it
X	if {![file exists $midi_file_name]} then {
X		puts stderr "Bad file name: $midi_file_name"
X		exit 1
X	} else {
X		set midi_file [open $midi_file_name]
X	}
X}
X
X# read the midi file
X# print out error if there is one
Xif {[catch {midiread $midi_file} mfile]} {
X	puts stderr $mfile
X	exit 1
X}
Xputs stdout [format "%-16s = %s" "file name" $midi_file_name]
Xputs stdout [format "%-16s = %s" "format" [midiconfig $mfile format]]
Xputs stdout [format "%-16s = %s" "division" [midiconfig $mfile division]]
Xset num_trks [midiconfig $mfile tracks]
Xputs stdout [format "%-16s = %s" "number of tracks" $num_trks]
X
X# print out all the tracks
Xfor {set track 0} {$track < $num_trks} {incr track} {
X	puts stdout "\nTrack $track"
X	set pos 0
X	while {[string compare [set event [midiget $mfile $track]] EOT] != 0} {
X		set out [FormatEvent $event]
X		puts stdout $out
X	}
X}
Xexit 0
END_OF_FILE
  if test 5581 -ne `wc -c <'tclm-1.0/minfo'`; then
    echo shar: \"'tclm-1.0/minfo'\" unpacked with wrong size!
  fi
  chmod +x 'tclm-1.0/minfo'
  # end of 'tclm-1.0/minfo'
fi
if test -f 'tclm-1.0/mlib/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/mlib/Makefile'\"
else
  echo shar: Extracting \"'tclm-1.0/mlib/Makefile'\" \(1433 characters\)
  sed "s/^X//" >'tclm-1.0/mlib/Makefile' <<'END_OF_FILE'
X# add -DMIDIPLAY to defines if you wish to compile in the ability to
X# play standard MIDI files.  This will only work on systems
X# equipped with a MIDI interface and systems with an interface
X# between tclm and the MIDI device.  Currently this is
X# only BSD/386 with a MPU-401 compatible and the new midi
X# driver.
XDEFS =
X# DEFS = -DMIDIPLAY
X
X# add driver type.  This only matters if PLAYMIDI is defined
X# current choices are:
X# mpu_bsd386.o
X# DRIVER = mpu_bsd386.o
XDRIVER = 
X
X# set RANLIB to ranlib if your system has it - otherwise set it to
X# true
X# RANLIB = true
XRANLIB = ranlib
X
X# set INSTALL to be your install program
X# INSTALL = cp
XINSTALL = install
X
X# set INSTALLEXECFLAG to be flags needed when installing
X# executables
XINSTALLEXECFLAG = -c -m 755
X
X# set INSTALLTEXTFLAG to be flags needed when installing
X# text files
XINSTALLTEXTFLAG = -c -m 644
X
X# set LIBDIR to the place where libmutil.a should go
XLIBDIR = /usr/local/lib
X
X# set INCDIR to the place where the .h files should go
XINCDIR = /usr/local/include
X
XMIDILIBOBJS = mfileutil.o $(DRIVER)
XMIDILIB = libmutil.a
X
XCFLAGS = $(DEFS) -O -I.
XCC = cc
X
Xall: $(MIDILIB)
X
X$(MIDILIB): $(MIDILIBOBJS)
X	rm -f $(MIDILIB)
X	ar cr $(MIDILIB) $(MIDILIBOBJS)
X	$(RANLIB) $(MIDILIB)
X
Xinstall: $(MIDILIB)
X	$(INSTALL) $(INSTALLTEXTFLAG) $(MIDILIB) $(LIBDIR)
X	$(RANLIB) $(LIBDIR)/$(MIDILIB)
X	$(INSTALL) $(INSTALLTEXTFLAG) mutil.h mdevice.h $(INCDIR)
X
Xclean:
X	rm -f $(MIDILIB) $(MIDILIBOBJS)
END_OF_FILE
  if test 1433 -ne `wc -c <'tclm-1.0/mlib/Makefile'`; then
    echo shar: \"'tclm-1.0/mlib/Makefile'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/mlib/Makefile'
fi
if test -f 'tclm-1.0/mlib/mutil.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/mlib/mutil.h'\"
else
  echo shar: Extracting \"'tclm-1.0/mlib/mutil.h'\" \(4343 characters\)
  sed "s/^X//" >'tclm-1.0/mlib/mutil.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by Michael B. Durian.
X * 4. The name of the the Author may be used to endorse or promote 
X *    products derived from this software without specific prior written 
X *    permission.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X/*
X * mutil.h,v 1.6 1993/05/06 21:44:06 durian Exp
X */
X#ifndef MUTIL_H
X#define MUTIL_H
X#if defined(i386) || defined(vax)
X#	define mtohl(l) ((((l) << 24) & 0xff000000L) | (((l) << 8) & \
X	    0x00ff0000L) | (((l) >> 8) & 0x0000ff00L) | (((l) >> 24) & \
X	    0x000000ffL))
X#	define htoml(l) ((((l) << 24) & 0xff000000L) | (((l) << 8) & \
X	    0x00ff0000L) | (((l) >> 8) & 0x0000ff00L) | (((l) >> 24) & \
X	    0x000000ffL))
X#	define mtohs(s) ((((s) << 8) & 0xff00) | (((s) >> 8) & 0x00ff))
X#	define htoms(s) ((((s) << 8) & 0xff00) | (((s) >> 8) & 0x00ff))
X#else
X#	define mtohl(l) l
X#	define mtohs(s) s
X#	define htoml(l) l
X#	define htoms(s) s
X#endif
X
Xtypedef enum {NORMAL = 0xff, SYSEX = 0xf0, METASEQNUM = 0x00, METATEXT = 0x01,
X    METACPY = 0x02, METASEQNAME = 0x03, METAINSTNAME = 0x04, METALYRIC = 0x05,
X    METAMARKER = 0x06, METACUE = 0x07, METACHANPREFIX = 0x20, METAEOT = 0x2f,
X    METATEMPO = 0x51, METASMPTE = 0x54, METATIME = 0x58, METAKEY = 0x59,
X    METASEQSPEC = 0x7f} EVENT_TYPE;
X
Xtypedef struct {
X        char str[4];
X        long length;
X        short format;
X        short num_trks;
X        short division;
X} HCHUNK;
X
Xtypedef struct {
X        char str[4];
X        long pos;
X        long length;
X	long msize;
X        unsigned char *events;
X        unsigned char *event_start;
X	unsigned char read_rs;
X	unsigned char write_rs;
X} TCHUNK;
X
X/* hack to tell us when reading from stdin if there is anymore data */
Xextern int MidiEof;
Xextern char MidiError[];
X
X/* function prototypes */
X#ifdef __STDC__
X#	define _ANSI_ARGS_(x) x
X#else
X#	define _ANSI_ARGS_(x) ()
X#endif
X
Xextern unsigned char get_running_state _ANSI_ARGS_((TCHUNK *));
Xextern int get_smf_event _ANSI_ARGS_((TCHUNK *, unsigned char *, EVENT_TYPE *));
Xextern int put_smf_event _ANSI_ARGS_((TCHUNK *, unsigned char *, int));
Xextern int read_header_chunk _ANSI_ARGS_((int, HCHUNK *));
Xextern int read_track_chunk _ANSI_ARGS_((int, TCHUNK *));
Xextern int skip_track_chunk _ANSI_ARGS_((int));
Xextern void rewind_track _ANSI_ARGS_((TCHUNK *));
Xextern void reset_track _ANSI_ARGS_((TCHUNK *));
Xextern int write_header_chunk _ANSI_ARGS_((int, HCHUNK *));
Xextern int write_track_chunk _ANSI_ARGS_((int, TCHUNK *));
Xextern int merge_tracks _ANSI_ARGS_((TCHUNK *, TCHUNK **, int *, int, int));
Xextern int split_type_zero _ANSI_ARGS_((TCHUNK *));
Xextern int fix2var _ANSI_ARGS_((long, unsigned char *));
Xextern long var2fix _ANSI_ARGS_((unsigned char *, int *));
Xextern void free_track _ANSI_ARGS_((TCHUNK *));
Xextern void init_track _ANSI_ARGS_((TCHUNK *));
Xextern int mread _ANSI_ARGS_((int, char *, int));
Xextern int mwrite _ANSI_ARGS_((int, char *, int));
Xextern int more_memory _ANSI_ARGS_((char **, int));
X#endif
END_OF_FILE
  if test 4343 -ne `wc -c <'tclm-1.0/mlib/mutil.h'`; then
    echo shar: \"'tclm-1.0/mlib/mutil.h'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/mlib/mutil.h'
fi
if test -f 'tclm-1.0/mrecord' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/mrecord'\"
else
  echo shar: Extracting \"'tclm-1.0/mrecord'\" \(4102 characters\)
  sed "s/^X//" >'tclm-1.0/mrecord' <<'END_OF_FILE'
X#!/usr/local/bin/tclm -f
X#
X# Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X#
X# Redistribution and use in source and binary forms, with or without
X# modification, are permitted provided that the following conditions
X# are met:
X# 1. Redistributions of source code must retain the above copyright
X#    notice, this list of conditions and the following disclaimer.
X# 2. Redistributions in binary form must reproduce the above copyright
X#    notice, this list of conditions and the following disclaimer in the
X#    documentation and/or other materials provided with the distribution.
X# 3. All advertising materials mentioning features or use of this software
X#    must display the following acknowledgement:
X#	This product includes software developed by Michael B. Durian.
X# 4. The name of the the Author may be used to endorse or promote 
X#    products derived from this software without specific prior written 
X#    permission.
X#
X# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X# SUCH DAMAGE.
X
X# mrecord,v 1.1 1993/05/06 02:51:08 durian Exp
X
Xif {! [midiplayable]} {
X	puts stderr [concat "Cannot record.  Tclm was not compiled with the " \
X	    "record functionality turned on."]
X	exit 1
X}
X
Xset repeat {}
Xset tracks {}
Xset speed {}
Xset play ""
Xset reltempo ""
Xset rec_file_name ""
Xset play_file_name ""
X
Xproc parse_arg {args} {
X	global repeat
X	global tracks
X	global speed
X	global play_file_name
X	global rec_file_name
X
X	# strip away extra {}'s
X	set argv [lindex $args 0]
X	set argc [llength $argv]
X	if {$argc > 1 && [string compare [lindex $argv 0] "-f"] == 0} {
X		incr argc -2
X		set argv [lrange $argv 2 end]
X	}
X	for {set i 0} {$i < $argc} {incr i} {
X
X		set arg [lindex $argv $i]
X		case $arg in \
X		-repeat {
X			set repeat repeat
X		} -tracks {
X			set tracks [lindex $argv [incr i]]
X		} -speed {
X			set speed [lindex $argv [incr i]]
X		} -pfile {
X			set play_file_name [lindex $argv [incr i]]
X		} default {
X			if {[string length $rec_file_name] != 0} {
X				Usage
X			} else {
X				set rec_file_name [lindex $argv $i]
X			}
X		}
X	}
X}
X
Xproc Usage {} {
X	puts stderr {Usage: mrecord [-pfile play_file [-repeat] \
X[-tracks track_list] [-speed speed]] record_file}
X	exit 1
X}
X
Xparse_arg $argv
X
Xset background ""
Xset rmfile [midimake]
Xmidiconfig $rmfile format 0
Xmidiconfig $rmfile tracks 1
X
Xif {[string length $play_file_name] == 0} {
X	if {[string length $repeat] != 0} {
X		Usage
X	}
X	if {[string length $tracks] != 0} {
X		Usage
X	}
X	if {[string length $speed] != 0} {
X		Usage
X	}
X	set pfile ""
X	set pmfile ""
X	set background background
X} else {
X	if {[string length $repeat] != 0} {
X		set background background
X	}
X
X	if {[llength $tracks] != 0} {
X		set tracks "tracks \"$tracks\""
X	} else {
X		set tracks ""
X	}
X
X	if {[string length $speed] != 0} {
X		set reltempo "reltempo $speed"
X	} else {
X		set reltempo ""
X	}
X	set pfile [open $play_file_name "r"]
X	set pmfile [midiread $pfile]
X	close $pfile
X
X	set play "play $pmfile"
X
X	midiconfig $rmfile division [midiconfig $pmfile division]
X}
X
Xif {[string length $background] == 0} {
X	eval "midirecord $background $play $repeat $tracks $reltempo $rmfile"
X} else {
X	set pid [eval \
X	    "midirecord $background $play $repeat $tracks $reltempo $rmfile"]
X	puts stdout "Press return to stop recording"
X	gets stdin
X	midistop $pid $rmfile
X}
X
Xmidiput $rmfile 0 0 metaeot
X
Xset rfile [open $rec_file_name "w"]
Xmidiwrite $rmfile $rfile
Xclose $rfile
Xif {[string length $pmfile] != 0} {
X	midifree $pmfile
X}
Xmidifree $rmfile
Xexit 0
END_OF_FILE
  if test 4102 -ne `wc -c <'tclm-1.0/mrecord'`; then
    echo shar: \"'tclm-1.0/mrecord'\" unpacked with wrong size!
  fi
  chmod +x 'tclm-1.0/mrecord'
  # end of 'tclm-1.0/mrecord'
fi
if test -f 'tclm-1.0/tclm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclm-1.0/tclm.h'\"
else
  echo shar: Extracting \"'tclm-1.0/tclm.h'\" \(3432 characters\)
  sed "s/^X//" >'tclm-1.0/tclm.h' <<'END_OF_FILE'
X/*-
X * Copyright (c) 1993 Michael B. Durian.  All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by Michael B. Durian.
X * 4. The name of the the Author may be used to endorse or promote 
X *    products derived from this software without specific prior written 
X *    permission.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED 
X * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
X * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
X * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X/*
X * tclm.h,v 1.7 1993/05/06 02:51:12 durian Exp
X */
X#ifndef TCLM_H
X#define TCLM_H
Xtypedef struct {
X	HCHUNK	hchunk;
X	TCHUNK	*tchunks;
X} MIDI_FILE;
X
X#define MAX_EVENT_SIZE 256
X
Xextern int Tclm_MidiConfig _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_Division _ANSI_ARGS_((Tcl_Interp *, int, char **));
Xextern int Tclm_MidiFixToVar _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_Format _ANSI_ARGS_((Tcl_Interp *, int, char **));
Xextern int Tclm_MidiFree _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_MidiGet _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_MidiPut _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_GetMFile _ANSI_ARGS_((Tcl_Interp *, char *, MIDI_FILE **));
Xextern void Tclm_InitMidi _ANSI_ARGS_((Tcl_Interp *));
Xextern int Tclm_MidiMake _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_MidiMerge _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_NumTracks _ANSI_ARGS_((Tcl_Interp *, int, char **));
Xextern int Tclm_MidiRead _ANSI_ARGS_((ClientData, Tcl_Interp *, int, char **));
Xextern int Tclm_MidiRewind _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_SetMFile _ANSI_ARGS_((Tcl_Interp *, char *, MIDI_FILE *));
Xextern int Tclm_MidiTiming _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_MidiVarToFix _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_MidiWrite _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_MidiPlayable _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
Xextern int Tclm_TclmVersion _ANSI_ARGS_((ClientData, Tcl_Interp *, int,
X    char **));
X#endif
END_OF_FILE
  if test 3432 -ne `wc -c <'tclm-1.0/tclm.h'`; then
    echo shar: \"'tclm-1.0/tclm.h'\" unpacked with wrong size!
  fi
  # end of 'tclm-1.0/tclm.h'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
