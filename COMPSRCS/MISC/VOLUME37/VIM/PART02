Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v37i002:  vim - Vi IMitation editor v1.27, Part02/24
Message-ID: <1993Apr23.172733.15476@sparky.imd.sterling.com>
X-Md4-Signature: 6a7b4dc1d9f1d324ab40d11172cda86e
Date: Fri, 23 Apr 1993 17:27:33 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 37, Issue 2
Archive-name: vim/part02
Environment: UNIX, AMIGA, MS-DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 23)."
# Contents:  vim/README vim/doc/digraph.doc.uue vim/doc/msdos.doc
#   vim/src/addcr.bat vim/src/alloc.c vim/src/charset.c vim/src/help.c
#   vim/src/linefunc.c vim/src/makefile.dice vim/src/makefile.dos
#   vim/src/message.c vim/src/mkcmdtab.c vim/src/msdos.h vim/src/ops.h
#   vim/src/sun_stdlib.h vim/src/tcconfig.tc.uue vim/src/unix.h
#   vim/termcap
# Wrapped by mool@oce-rd2 on Mon Apr 19 15:50:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/README'\"
else
echo shar: Extracting \"'vim/README'\" \(2167 characters\)
sed "s/^X//" >'vim/README' <<'END_OF_FILE'
XREADME for version 1.27 of Vim: Vi IMitation.
X
XVim is an almost compatible version of the UNIX editor vi. Only the 'Q' 
Xcommand is missing. Many new features have been added: multi level undo, 
Xcommand line history, filename completion, quoting, etc. See difference.doc.
X
XThis editor is very useful for editing programs and other plain ASCII files. 
XAll commands are given with normal keyboard characters, so those who can type 
Xwith ten fingers can work very fast. Function keys can be used for macros.
X
XVim currently runs under Amiga DOS, MSDOS and UNIX. Porting to other systems 
Xshould not be very difficult.
X
XDocumentation:
X	  tutor/readme - one hour training course for beginners
X	 reference.doc - complete reference of all Vim commands
X	difference.doc - summarizes the differences with UNIX vi
X		 index - alfabetical list of commands
X	      unix.doc - remarks for unix
X	     msdos.doc - remarks for MSDOS
X
XVim is Public Domain. You can copy it as much as you like. If you want to 
Xdistribute a modified version of the source code please contact me first.
X
XInstallation on the Amiga:
X- Put "arp.library" in "libs:" (not required for Amiga DOS 2.0 and later)
X- Assign "vim:" to the directory where the vim.hlp file is (for the help 
X  command).
X- With DOS 1.3 or earlier: make sure that newcli and run are in "c:" (for 
X  executing external commands).
X- Put a shell that accepts a command with "-c" (e.g. "Csh" from Fish disk 
X  624) in "c:" or in any other directory that is in your search path (for 
X  executing external commands).
X
XIf you have sufficient memory you can avoid startup delays by making Vim and 
Xcsh resident with the command "rez csh vim". You will have to put 
X"rezlib.library" in your "libs:" directory. Under 2.0 you will need rez 
Xversion 0.5.
X
XIf you do not use digraphs, you can save some memory by recompiling without 
Xthe DIGRAPHS option. If you want to use Vim with other terminals you can 
Xrecompile with the TERMCAP option. Vim compiles with Manx 5.x and SAS 6.x.
XSee the makefiles.
X
XPlease send comments, bug reports and suggestions to:
X
X	Bram Moolenaar
X	Clematisstraat 30
X	5925 BE  Venlo
X	The Netherlands
X
XUUCP E-mail:	mool@oce.nl
END_OF_FILE
if test 2167 -ne `wc -c <'vim/README'`; then
    echo shar: \"'vim/README'\" unpacked with wrong size!
fi
# end of 'vim/README'
fi
if test -f 'vim/doc/digraph.doc.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/digraph.doc.uue'\"
else
echo shar: Extracting \"'vim/doc/digraph.doc.uue'\" \(1961 characters\)
sed "s/^X//" >'vim/doc/digraph.doc.uue' <<'END_OF_FILE'
X
Xbegin 644 digraph.doc
XM5&AE<V4@87)E('1H92!D969A=6QT(&1I9W)A<&@@8VAA<F%C=&5R<R!F;W(@]
XM5FEM+B!4:&4@9FER<W0@='=O(&-H87)A8W1E<G,@:6X@"F5A8V@@8V]L=6UN]
XM(&%R92!T:&4@8VAA<F%C=&5R<R!Y;W4@:&%V92!T;R!T>7!E('1O(&5N=&5R@
XM(&$@9&EG<F%P:"X@26X@=&AE(`IM:61D;&4@;V8@96%C:"!C;VQU;6X@:7,@O
XM=&AE(')E<W5L=&EN9R!C:&%R86-T97(N(%1H:7,@;6%Y(&)E(&UA;F=L960@7
XM:68@>6]U(`IL;V]K(&%T('1H:7,@9FEL92!O;B!S;VUE=&AI;F<@96QS92!T`
XM:&%N(&%N($%M:6=A(&]R('=H96X@>6]U('!R:6YT(&ET+B!4:&4@"F1E8VEM:
XM86P@;G5M8F5R(&ES('1H92!!4T-)22!C;V1E(&9O<B!T:&4@8VAA<F%C=&5RL
XM+@H*?B$@H2`Q-C$@("!C?""B(#$V,B`@("0D(*,@,38S("`@;W@@I"`Q-C0@?
XM("!9+2"E(#$V-2`@('Q\(*8@,38V("`@<&$@IR`Q-C<*(B(@J"`Q-C@@("!CP
XM3R"I(#$V.2`@(&$M(*H@,3<P("`@/#P@JR`Q-S$@("`M+2"M(#$W,R`@(')/'
XM(*X@,3<T("`@+3T@KR`Q-S4*?F\@L"`Q-S8@("`K+2"Q(#$W-R`@(#(R(+(@C
XM,3<X("`@,S,@LR`Q-SD@("`G)R"T(#$X,"`@(&IU(+4@,3@Q("`@<'`@MB`QJ
XM.#(*?BX@MR`Q.#,@("`L+""X(#$X-"`@(#$Q(+D@,3@U("`@;RT@NB`Q.#8@.
XM("`^/B"[(#$X-R`@(#$T(+P@,3@X("`@,3(@O2`Q.#D*,S0@OB`Q.3`@("!^"
XM/R"_(#$Y,2`@($%@(,`@,3DR("`@02<@P2`Q.3,@("!!7B#"(#$Y-"`@($%^:
XM(,,@,3DU("`@02(@Q"`Q.38*04`@Q2`Q.3<@("!!12#&(#$Y."`@($,L(,<@>
XM,3DY("`@16`@R"`R,#`@("!%)R#)(#(P,2`@($5>(,H@,C`R("`@12(@RR`R/
XM,#,*26`@S"`R,#0@("!))R#-(#(P-2`@($E>(,X@,C`V("`@22(@SR`R,#<@L
XM("`M1"#0(#(P."`@($Y^(-$@,C`Y("`@3V`@TB`R,3`*3R<@TR`R,3$@("!/]
XM7B#4(#(Q,B`@($]^(-4@,C$S("`@3R(@UB`R,30@("`O7"#7(#(Q-2`@($\O5
XM(-@@,C$V("`@56`@V2`R,3<*52<@VB`R,3@@("!57B#;(#(Q.2`@(%4B(-P@Q
XM,C(P("`@62<@W2`R,C$@("!)<"#>(#(R,B`@('-S(-\@,C(S("`@86`@X"`RB
XM,C0*82<@X2`R,C4@("!A7B#B(#(R-B`@(&%^(.,@,C(W("`@82(@Y"`R,C@@-
XM("!A0"#E(#(R.2`@(&%E(.8@,C,P("`@8RP@YR`R,S$*96`@Z"`R,S(@("!E#
XM)R#I(#(S,R`@(&5>(.H@,C,T("`@92(@ZR`R,S4@("!I8"#L(#(S-B`@(&DG:
XM(.T@,C,W("`@:5X@[B`R,S@*:2(@[R`R,SD@("`M9"#P(#(T,"`@(&Y^(/$@1
XM,C0Q("`@;V`@\B`R-#(@("!O)R#S(#(T,R`@(&]>(/0@,C0T("`@;WX@]2`R!
XM-#4*;R(@]B`R-#8@("`Z+2#W(#(T-R`@(&\O(/@@,C0X("`@=6`@^2`R-#D@R
XM("!U)R#Z(#(U,"`@('5>(/L@,C4Q("`@=2(@_"`R-3(*>2<@_2`R-3,@("!I)
X3<"#^(#(U-"`@('DB(/\@,C4U"C4Q/
X``
Xend
Xsize 1369
END_OF_FILE
if test 1961 -ne `wc -c <'vim/doc/digraph.doc.uue'`; then
    echo shar: \"'vim/doc/digraph.doc.uue'\" unpacked with wrong size!
fi
# end of 'vim/doc/digraph.doc.uue'
fi
if test -f 'vim/doc/msdos.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/msdos.doc'\"
else
echo shar: Extracting \"'vim/doc/msdos.doc'\" \(2942 characters\)
sed "s/^X//" >'vim/doc/msdos.doc' <<'END_OF_FILE'
XThis file contains the particularities for the MSDOS version of Vim.
X
XIf Vim produces all kinds of garbage on the screen you need to install
Xansi.sys (or equivalent).
X
XIf the "tx" (textmode) option is set (which is the default), Vim will accept a 
Xsingle <LF> or a <CR><LF> pair for end-of-line. When writing a file Vim will 
Xuse <CR><LF>. Thus if you edit a file and write it, <LF> is replaced with 
X<CR><LF>. Single <CR> characters are lost. If the "tx" option is not set the 
Xsingle <LF> will be used for end-of-line. A <CR> will be shown as ^M.
XYou can use Vim to replace <LF> by <CR><LF> by reading in any mode and 
Xwriting in text mode. You can use Vim to replace <CR><LF> by <LF> by reading 
Xin text mode and writing in non-text mode.
X
XScript files contain single <CR> characters. If you want to edit a script file 
Xyou should reset the textmode option before loading the file.
X
XThe default help filename is "$VIM\vim.hlp". If the environment variable $VIM 
Xis not defined or the file is not found, the DOS search path is used to 
Xsearch for the file "vim.hlp". If you do not want to put "vim.hlp" in your 
Xsearch path, use the command ":set helpfile=pathname" to tell Vim where the 
Xhelp file is.
X
XThe files "_vimrc" and "_exrc" are used instead of ".vimrc" and ".exrc".
XThe files "$VIM\_vimrc" and "$VIM\_exrc" are used instead of "s:.vimrc" and 
X"s:.exrc".
X
XUse CTRL-break instead of CTRL-C to interrupt searches. The CTRL-C is not
Xdetected until a key is read.
X
XUse CTRL-arrow-left and CTRL-arrow-right instead of SHIFT-arrow-left and 
XSHIFT-arrow-right. The arrow-up and arrow-down cannot be used with SHIFT or 
XCTRL.
X
XTemporary files (for filtering) are put in the current directory.
X
XThe default for the sh (shell) option is "command". External commands are 
Xstarted with "command /c <command_name>". Typing CTRL-Z starts a new command 
Xshell. Return to Vim with "exit".
X
X
XMS-DOS allows for only one filename extention. Therefore, in the original 
Xfilename the '.' is replaced by a '_', the name is truncated to 8 characters 
Xand the new extention ".vim" or ".bak" is appended. Two examples: "test.c" 
Xbecomes "test_c.bak", "ditiseen.tst" becomes "ditiseen.bak". The 'shortname' 
Xoption is not available.
X
XThe MS-DOS binary was compiled with Turbo-C version 2.0 (yes, it's old). You 
Xmay get some "argument never used" warning messages. They can be ignored. If 
Xyou get all kinds of strange error messages when compiling, you have to add 
X<CR> characters at the end of each line. This can be done with the addcr 
Xprogram: "make addcr". This will compile addcr.c to addcr.exe and execute 
Xthe addcr.bat file.
X
XAll text is kept in memory. This limits the size of the file you can edit,
Xthe number of undo levels that can be remembered, etc.. If Vim gives an "Out 
Xof memory" warning you should stop editing. Result of further editing actions 
Xis unpredictable.
X
XThe *.info files are for the Amiga. You don't need them with MSDOS.
END_OF_FILE
if test 2942 -ne `wc -c <'vim/doc/msdos.doc'`; then
    echo shar: \"'vim/doc/msdos.doc'\" unpacked with wrong size!
fi
# end of 'vim/doc/msdos.doc'
fi
if test -f 'vim/src/addcr.bat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/addcr.bat'\"
else
echo shar: Extracting \"'vim/src/addcr.bat'\" \(3795 characters\)
sed "s/^X//" >'vim/src/addcr.bat' <<'END_OF_FILE'
Xaddcr <addcr.c >tmp
Xcp tmp addcr.c 
Xaddcr <alloc.c >tmp
Xcp tmp alloc.c 
Xaddcr <ascii.h >tmp
Xcp tmp ascii.h 
Xaddcr <buffers.c >tmp
Xcp tmp buffers.c 
Xaddcr <charset.c >tmp
Xcp tmp charset.c 
Xaddcr <cmdline.c >tmp
Xcp tmp cmdline.c 
Xaddcr <cmdtab.h >tmp
Xcp tmp cmdtab.h 
Xaddcr <cmdtab.tab >tmp
Xcp tmp cmdtab.tab 
Xaddcr <csearch.c >tmp
Xcp tmp csearch.c 
Xaddcr <debug.h >tmp
Xcp tmp debug.h 
Xaddcr <digraph.c >tmp
Xcp tmp digraph.c 
Xaddcr <edit.c >tmp
Xcp tmp edit.c 
Xaddcr <env.h >tmp
Xcp tmp env.h 
Xaddcr <fileio.c >tmp
Xcp tmp fileio.c 
Xaddcr <globals.h >tmp
Xcp tmp globals.h 
Xaddcr <help.c >tmp
Xcp tmp help.c 
Xaddcr <keymap.h >tmp
Xcp tmp keymap.h 
Xaddcr <linefunc.c >tmp
Xcp tmp linefunc.c 
Xaddcr <macros.h >tmp
Xcp tmp macros.h 
Xaddcr <main.c >tmp
Xcp tmp main.c 
Xaddcr <makefile >tmp
Xcp tmp makefile 
Xaddcr <mark.c >tmp
Xcp tmp mark.c 
Xaddcr <mark.h >tmp
Xcp tmp mark.h 
Xaddcr <message.c >tmp
Xcp tmp message.c 
Xaddcr <misccmds.c >tmp
Xcp tmp misccmds.c 
Xaddcr <mkcmdtab.c >tmp
Xcp tmp mkcmdtab.c 
Xaddcr <msdos.c >tmp
Xcp tmp msdos.c 
Xaddcr <msdos.h >tmp
Xcp tmp msdos.h 
Xaddcr <normal.c >tmp
Xcp tmp normal.c 
Xaddcr <ops.c >tmp
Xcp tmp ops.c 
Xaddcr <ops.h >tmp
Xcp tmp ops.h 
Xaddcr <param.c >tmp
Xcp tmp param.c 
Xaddcr <param.h >tmp
Xcp tmp param.h 
Xaddcr <proto.h >tmp
Xcp tmp proto.h 
Xaddcr <quickfix.c >tmp
Xcp tmp quickfix.c 
Xaddcr <regexp.c >tmp
Xcp tmp regexp.c 
Xaddcr <regexp.h >tmp
Xcp tmp regexp.h 
Xaddcr <regmagic.h >tmp
Xcp tmp regmagic.h 
Xaddcr <regsub.c >tmp
Xcp tmp regsub.c 
Xaddcr <screen.c >tmp
Xcp tmp screen.c 
Xaddcr <script.c >tmp
Xcp tmp script.c 
Xaddcr <search.c >tmp
Xcp tmp search.c 
Xaddcr <storage.c >tmp
Xcp tmp storage.c 
Xaddcr <tag.c >tmp
Xcp tmp tag.c 
Xaddcr <tags >tmp
Xcp tmp tags 
Xaddcr <term.c >tmp
Xcp tmp term.c 
Xaddcr <term.h >tmp
Xcp tmp term.h 
Xaddcr <termlib.c >tmp
Xcp tmp termlib.c 
Xaddcr <termlib.fix >tmp
Xcp tmp termlib.fix 
Xaddcr <undo.c >tmp
Xcp tmp undo.c 
Xaddcr <version.c >tmp
Xcp tmp version.c 
Xaddcr <vim.h >tmp
Xcp tmp vim.h 
Xaddcr <vim.prj >tmp
Xcp tmp vim.prj 
Xaddcr <vimresp >tmp
Xcp tmp vimresp 
Xaddcr <proto\alloc.pro >tmp
Xcp tmp proto\alloc.pro 
Xaddcr <proto\amiga.pro >tmp
Xcp tmp proto\amiga.pro 
Xaddcr <proto\buffers.pro >tmp
Xcp tmp proto\buffers.pro 
Xaddcr <proto\charset.pro >tmp
Xcp tmp proto\charset.pro 
Xaddcr <proto\cmdline.pro >tmp
Xcp tmp proto\cmdline.pro 
Xaddcr <proto\csearch.pro >tmp
Xcp tmp proto\csearch.pro 
Xaddcr <proto\digraph.pro >tmp
Xcp tmp proto\digraph.pro 
Xaddcr <proto\edit.pro >tmp
Xcp tmp proto\edit.pro 
Xaddcr <proto\fileio.pro >tmp
Xcp tmp proto\fileio.pro 
Xaddcr <proto\help.pro >tmp
Xcp tmp proto\help.pro 
Xaddcr <proto\linefunc.pro >tmp
Xcp tmp proto\linefunc.pro 
Xaddcr <proto\main.pro >tmp
Xcp tmp proto\main.pro 
Xaddcr <proto\mark.pro >tmp
Xcp tmp proto\mark.pro 
Xaddcr <proto\message.pro >tmp
Xcp tmp proto\message.pro 
Xaddcr <proto\misccmds.pro >tmp
Xcp tmp proto\misccmds.pro 
Xaddcr <proto\normal.pro >tmp
Xcp tmp proto\normal.pro 
Xaddcr <proto\ops.pro >tmp
Xcp tmp proto\ops.pro 
Xaddcr <proto\param.pro >tmp
Xcp tmp proto\param.pro 
Xaddcr <proto\quickfix.pro >tmp
Xcp tmp proto\quickfix.pro 
Xaddcr <proto\regexp.pro >tmp
Xcp tmp proto\regexp.pro 
Xaddcr <proto\regsub.pro >tmp
Xcp tmp proto\regsub.pro 
Xaddcr <proto\screen.pro >tmp
Xcp tmp proto\screen.pro 
Xaddcr <proto\script.pro >tmp
Xcp tmp proto\script.pro 
Xaddcr <proto\search.pro >tmp
Xcp tmp proto\search.pro 
Xaddcr <proto\storage.pro >tmp
Xcp tmp proto\storage.pro 
Xaddcr <proto\tag.pro >tmp
Xcp tmp proto\tag.pro 
Xaddcr <proto\term.pro >tmp
Xcp tmp proto\term.pro 
Xaddcr <proto\termlib.pro >tmp
Xcp tmp proto\termlib.pro 
Xaddcr <proto\undo.pro >tmp
Xcp tmp proto\undo.pro 
Xaddcr <proto\version.pro >tmp
Xcp tmp proto\version.pro 
Xdel tmp
END_OF_FILE
if test 3795 -ne `wc -c <'vim/src/addcr.bat'`; then
    echo shar: \"'vim/src/addcr.bat'\" unpacked with wrong size!
fi
# end of 'vim/src/addcr.bat'
fi
if test -f 'vim/src/alloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/alloc.c'\"
else
echo shar: Extracting \"'vim/src/alloc.c'\" \(2444 characters\)
sed "s/^X//" >'vim/src/alloc.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * alloc.c
X *
X * This file contains various routines dealing with allocation and
X * deallocation of data structures.
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
X#ifdef AMIGA
X# undef FALSE			/* these are redefined in exec/types.h */
X# undef TRUE
X# include <exec/types.h>
X# include <exec/memory.h>
X# undef FALSE
X# define FALSE 0		/* define FALSE and TRUE as ints instead of longs */
X# undef TRUE
X# define TRUE 1
X#endif /* AMIGA */
X
X#ifdef MSDOS
X# include <alloc.h>
X#endif /* MSDOS */
X
X#define PANIC_FACTOR_CHIP 8192L
X
X	char *
Xalloc(size)
X	unsigned		size;
X{
X	return (lalloc((u_long)size, TRUE));
X}
X
X	char *
Xlalloc(size, message)
X	u_long			size;
X	int				message;
X{
X	register char   *p;			/* pointer to new storage space */
X
X	if ((p = (char *)malloc(size)) != NULL)
X	{
X#ifdef AMIGA
X		if (AvailMem((long)MEMF_CHIP) < PANIC_FACTOR_CHIP)
X		{ 								/* System is low... no go! */
X				free(p);
X				p = NULL;
X		}
X#endif
X#ifdef MSDOS
X		if (coreleft() < PANIC_FACTOR_CHIP)
X		{ 								/* System is low... no go! */
X				free(p);
X				p = NULL;
X		}
X#endif
X	}
X	if (message && p == NULL)
X		emsg(e_outofmem);
X	return (p);
X}
X
X/*
X * copy a string into newly allocated memory
X */
X	char *
Xstrsave(string)
X	char		   *string;
X{
X	char *p;
X
X	p = alloc((unsigned) (strlen(string) + 1));
X	if (p != NULL)
X		strcpy(p, string);
X	return p;
X}
X
X	char *
Xstrnsave(string, len)
X	char		*string;
X	int 		len;
X{
X	char *p;
X
X	p = alloc((unsigned) (len + 1));
X	if (p != NULL)
X	{
X		strncpy(p, string, (size_t)len);
X		p[len] = NUL;
X	}
X	return p;
X}
X
X/*
X * copy a number of spaces
X */
X	void
Xcopy_spaces(ptr, count)
X	char	*ptr;
X	size_t	count;
X{
X	register size_t	j;
X
X	while (count)		/* copy 15 spaces at a time */
X	{
X		j = count;
X		if (j > 15)
X			j = 15;
X		memmove(ptr, spaces, j);
X		ptr += j;
X		count -= j;
X	}
X}
X
X	char *
Xmkstr(c)
X	unsigned	  c;
X{
X	static char	  s[2];
X
X	s[0] = c;
X	s[1] = NUL;
X
X	return s;
X}
X
X#ifdef NO_FREE_NULL
X#undef free
X/*
X * replacement for free() that cannot handle NULL pointers
X */
X	void
XnofreeNULL(x)
X	void *x;
X{
X	if (x != NULL)
X		free(x);
X}
X#endif
X
X#ifdef BSD
X	char *
Xbsdmemset(ptr, c, size)
X	char	*ptr;
X	int		c;
X	long	size;
X{
X	register char *p = ptr;
X
X	while (size-- > 0)
X		*p++ = c;
X	return ptr;
X}
X#endif
END_OF_FILE
if test 2444 -ne `wc -c <'vim/src/alloc.c'`; then
    echo shar: \"'vim/src/alloc.c'\" unpacked with wrong size!
fi
# end of 'vim/src/alloc.c'
fi
if test -f 'vim/src/charset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/charset.c'\"
else
echo shar: Extracting \"'vim/src/charset.c'\" \(1994 characters\)
sed "s/^X//" >'vim/src/charset.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
X
X	char *
Xtranschar(c)
X	unsigned c;
X{
X		static char buf[3];
X
X		if (c < ' ')
X		{
X				if (c == NL)
X						c = NUL;		/* we use newline in place of a NUL */
X				buf[0] = '^';
X				buf[1] = '@' + c;
X				buf[2] = NUL;
X		}
X		else if (c <= '~' || c > 0xa0 || p_gr)
X		{
X				buf[0] = c;
X				buf[1] = NUL;
X		}
X		else
X		{
X				buf[0] = '~';
X				buf[1] = c - 0x80 + '@';
X				buf[2] = NUL;
X		}
X		return buf;
X}
X
X/*
X * output 'len' characters in 'str' (including NULs) with translation
X * if 'len' is -1, output upto a NUL character
X * return the number of characters it takes on the screen
X */
X	int
Xouttrans(str, len)
X	register char *str;
X	register int   len;
X{
X	int retval = 0;
X
X	if (len == -1)
X		len = strlen(str);
X	while (--len >= 0)
X	{
X		outstrn(transchar(*(u_char *)str));
X		retval += charsize(*(u_char *)str);
X		++str;
X	}
X	return retval;
X}
X
X/*
X * return the number of characters 'c' will take on the screen
X */
X	int
Xcharsize(c)
X	int c;
X{
X	return ((c >= ' ' && (p_gr || c <= '~')) || c > 0xa0 ? 1 : 2);
X}
X
X/*
X * return the number of characters string 's' will take on the screen
X */
X	int
Xstrsize(s)
X	char *s;
X{
X	int	len = 0;
X
X	while (*s)
X		len += charsize(*s++);
X	return len;
X}
X
X/*
X * return the number of characters 'c' will take on the screen, taking
X * into account the size of a tab
X */
X	int
Xchartabsize(c, col)
X	int c, col;
X{
X	if ((c >= ' ' && (c <= '~' || p_gr)) || c > 0xa0)
X   		return 1;
X   	else if (c == TAB && !p_list)
X   		return (int)(p_ts - (col % p_ts));
X   	else
X		return 2;
X}
X
X/*
X * return TRUE if 'c' is an identifier character
X */
X	int
Xisidchar(c)
X	int c;
X{
X#ifdef __STDC__
X		return (isalnum(c) || c == '_');
X#else
X		return (isalpha(c) || isdigit(c) || c == '_');
X#endif
X}
END_OF_FILE
if test 1994 -ne `wc -c <'vim/src/charset.c'`; then
    echo shar: \"'vim/src/charset.c'\" unpacked with wrong size!
fi
# end of 'vim/src/charset.c'
fi
if test -f 'vim/src/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/help.c'\"
else
echo shar: Extracting \"'vim/src/help.c'\" \(2810 characters\)
sed "s/^X//" >'vim/src/help.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * help.c: display help from the vim.hlp file
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
Xstatic long helpfilepos;		/* position in help file */
Xstatic FILE *helpfd;			/* file descriptor of help file */
X
X	void
Xhelp()
X{
X	int		c;
X	int		eof;
X	int		i;
X	long	filepos[26];	/* seek position for each screen */
X	int		screennr;		/* screen number; 'c' == 1 */
X	char	fnamebuf[MAXPATHL];
X#ifdef MSDOS
X	char	*fnamep;
X#endif
X
X/*
X * try to open the file specified by the "helpfile" option
X */
X	expand_env(p_hf, fnamebuf, MAXPATHL);
X	if ((helpfd = fopen(fnamebuf, READBIN)) == NULL)
X	{
X#ifdef MSDOS
X	/*
X	 * for MSdos: try the DOS search path
X     */
X		strcpy(fnamebuf, "vim.hlp");
X		fnamep = searchpath(fnamebuf);
X		if (fnamep == NULL || (helpfd = fopen(fnamep, READBIN)) == NULL)
X		{
X#endif
X			smsg("Sorry, help file %s not found", fnamebuf);
X			return;
X#ifdef MSDOS
X		}
X#endif
X	}
X	helpfilepos = 0;
X	screennr = 0;
X	for (i = 0; i < 26; ++i)
X		filepos[i] = 0;
X	State = HELP;
X	for (;;)
X	{
X		eof = redrawhelp();
X		if (!eof)
X			filepos[screennr + 1] = ftell(helpfd);
X
X		if ((c = vgetc()) == '\n' || c == '\r')
X			break;
X
X		if (c == ' ')						/* one screen forwards */
X		{
X			if (screennr < 25 && !eof)
X				++screennr;
X		}
X		else if (c == 'a')					/* go to first screen */
X			screennr = 0;
X		else if (c == 'b')					/* go one screen backwards */
X		{
X			if (screennr > 0)
X				--screennr;
X		}
X		else if (c >= 'c' && c <= 'z')		/* go to specified screen */
X		{
X			if (c - 'b' < screennr)			/* backwards */
X				screennr = c - 'b';
X			else							/* forwards */
X			{
X				while (screennr < c - 'b' && filepos[screennr + 1])
X					++screennr;
X				fseek(helpfd, filepos[screennr], 0);
X				while (screennr < c - 'b')
X				{
X					while ((i = getc(helpfd)) != '\f' && i != -1)
X						;
X					if (i == -1)
X						break;
X					filepos[++screennr] = ftell(helpfd);
X				}
X			}
X		}
X		helpfilepos = filepos[screennr];
X	}
X	State = NORMAL;
X	script_winsize_pp();
X	fclose(helpfd);
X	updateScreen(CLEAR);
X}
X
X	int
Xredrawhelp()
X{
X		int nextc;
X		int col;
X
X		fseek(helpfd, helpfilepos, 0);
X		col = Columns - 52;
X		if (col < 0)
X				col = 0;
X		outstr(T_ED);
X		while ((nextc = getc(helpfd)) != -1 && nextc != '\f')
X		{
X			if (nextc == Ctrl('B'))		/* begin of invert */
X				outstr(T_TI);
X			else if (nextc == Ctrl('E'))	/* end of invert */
X				outstr(T_TP);
X			else
X				outchar((char)nextc);
X		}
X		windgoto(0, (int)(Columns - strlen(Version) - 1));
X		outstrn(Version);
X		windgoto((int)Rows - 1, col);
X		outstrn("<space = next; return = quit; a = index; b = back>");
X		return (nextc == -1);
X}
END_OF_FILE
if test 2810 -ne `wc -c <'vim/src/help.c'`; then
    echo shar: \"'vim/src/help.c'\" unpacked with wrong size!
fi
# end of 'vim/src/help.c'
fi
if test -f 'vim/src/linefunc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/linefunc.c'\"
else
echo shar: Extracting \"'vim/src/linefunc.c'\" \(2625 characters\)
sed "s/^X//" >'vim/src/linefunc.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * linefunc.c: some functions to move to the next/previous line and
X *			   to the next/previous character
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
X/*
X * coladvance(col)
X *
X * Try to advance the Cursor to the specified column.
X */
X
X	void
Xcoladvance(wcol)
X	colnr_t 		wcol;
X{
X	int 				index;
X	register u_char		*ptr;
X	register colnr_t	col;
X
X	ptr = (u_char *)nr2ptr(Curpos.lnum);
X
X	/* try to advance to the specified column */
X	index = -1;
X	col = 0;
X	while (col <= wcol && *ptr)
X	{
X		++index;
X		/* Count a tab for what it's worth (if list mode not on) */
X		col += chartabsize(*ptr, col);
X		++ptr;
X	}
X	if (index < 0)
X		Curpos.col = 0;
X	else
X		Curpos.col = index;
X}
X
X/*
X * inc(p)
X *
X * Increment the line pointer 'p' crossing line boundaries as necessary. Return
X * 1 when crossing a line, -1 when at end of file, 0 otherwise.
X */
X	int
Xinc(lp)
X	register FPOS  *lp;
X{
X	register char  *p = pos2ptr(lp);
X
X	if (*p != NUL)
X	{			/* still within line */
X		lp->col++;
X		return ((p[1] != NUL) ? 0 : 1);
X	}
X	if (lp->lnum != line_count)
X	{			/* there is a next line */
X		lp->col = 0;
X		lp->lnum++;
X		return 1;
X	}
X	return -1;
X}
X
X	int
XincCurpos()
X{
X	return inc(&Curpos);
X}
X
X/*
X * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines
X */
X	int
Xincl(lp)
X		register FPOS *lp;
X{
X		register int r;
X
X		if ((r = inc(lp)) == 1 && lp->col)
X				r = inc(lp);
X		return r;
X}
X
X/*
X * dec(p)
X *
X * Decrement the line pointer 'p' crossing line boundaries as necessary. Return
X * 1 when crossing a line, -1 when at start of file, 0 otherwise.
X */
X	int
Xdec(lp)
X	register FPOS  *lp;
X{
X	if (lp->col > 0)
X	{			/* still within line */
X		lp->col--;
X		return 0;
X	}
X	if (lp->lnum > 1)
X	{			/* there is a prior line */
X		lp->lnum--;
X		lp->col = strlen(nr2ptr(lp->lnum));
X		return 1;
X	}
X	return -1;					/* at start of file */
X}
X
X	int
XdecCurpos()
X{
X	return dec(&Curpos);
X}
X
X/*
X * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines
X */
X	int
Xdecl(lp)
X		register FPOS *lp;
X{
X		register int r;
X
X		if ((r = dec(lp)) == 1 && lp->col)
X				r = dec(lp);
X		return r;
X}
X
X/*
X * make sure Curpos in on a valid character
X */
X	void
XadjustCurpos()
X{
X	int len;
X
X	if (Curpos.lnum == 0)
X		Curpos.lnum = 1;
X	if (Curpos.lnum > line_count)
X		Curpos.lnum = line_count;
X
X	len = strlen(nr2ptr(Curpos.lnum));
X	if (len == 0)
X		Curpos.col = 0;
X	else if (Curpos.col >= len)
X		Curpos.col = len - 1;
X}
END_OF_FILE
if test 2625 -ne `wc -c <'vim/src/linefunc.c'`; then
    echo shar: \"'vim/src/linefunc.c'\" unpacked with wrong size!
fi
# end of 'vim/src/linefunc.c'
fi
if test -f 'vim/src/makefile.dice' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.dice'\"
else
echo shar: Extracting \"'vim/src/makefile.dice'\" \(3130 characters\)
sed "s/^X//" >'vim/src/makefile.dice' <<'END_OF_FILE'
X#
X# Makefile for VIM, using DICE 2.06.40 and 2.06.21
X#
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DWILD_CARDS	wildcard expansion code
X### -DNO_ARP		do not use arp.library, DOS 2.0 required
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
XDEFINES = -DWILD_CARDS -DTERMCAP -DDIGRAPHS -DSOME_BUILTIN_TCAPS
X
X#>>>>> if TERMCAP is defined termlib.o has to be used
XTERMLIB = termlib.o
X#TERMLIB = 
X
X#>>>>> end of choices
X###########################################################################
X
XCFLAGS = -c -DAMIGA $(DEFINES)
X
XINCL = vim.syms
XPRE = -H${INCL}=vim.h
XLIBS = -lmanx -la
XCC = dcc
XLD = dcc
X
X.c.o:
X	${CC} ${PRE} ${CFLAGS} $*.c -o $@
X
XOBJ =	alloc.o amiga.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o undo.o $(TERMLIB)
X
X/Vim: $(OBJ) version.c
X	${CC} $(CFLAGS) version.c -o version.o
X	${LD} -o /Vim $(OBJ) version.o $(LIBS)
X
Xdebug: $(OBJ) version.c
X	${CC} $(CFLAGS) version.c -o version.o
X	${LD} -s -o /Vim $(OBJ) version.o $(LIBS)
X
Xctags:
X	csh -c ctags *.c *.h
X
X# can't use delete here, too many file names
Xclean:
X	csh -c rm -f $(OBJ) version.o mkcmdtab.o /Vim $(INCL) mkcmdtab
X
X$(INCL)  : vim.h globals.h keymap.h macros.h ascii.h term.h amiga.h
X	delete $(INCL)
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(INCL)
X
Xamiga.o:	amiga.c  $(INCL) amiga.h
X
Xbuffers.o:	buffers.c  $(INCL)
X
Xcharset.o:	charset.c  $(INCL)
X
Xcmdline.o:	cmdline.c  $(INCL) cmdtab.h
X
Xcsearch.o:	csearch.c  $(INCL) regexp.h
X
Xdigraph.o: digraph.c	$(INCL)
X
Xedit.o: edit.c	$(INCL)
X
Xfileio.o:	fileio.c  $(INCL)
X
Xhelp.o: help.c	$(INCL)
X
Xlinefunc.o:	linefunc.c  $(INCL)
X
Xmain.o: main.c
X	${CC} ${CFLAGS} main.c -o main.o
X
Xmark.o: mark.c	$(INCL) mark.h
X
Xmessage.o:	message.c  $(INCL)
X
Xmisccmds.o:	misccmds.c  $(INCL)
X
Xnormal.o:	normal.c  $(INCL) ops.h
X
Xops.o:	ops.c  $(INCL) ops.h
X
Xparam.o:	param.c  $(INCL)
X# Because of a bug in DC1 2.06.40, initialisation of unions does not
X# work correctly. dc1-21 is DC1 2.06.21 which does work.
X	rename dc1-21 dc1
X	${CC} ${CFLAGS} param.c -o param.o
X	rename dc1 dc1-21
X
Xquickfix.o:	quickfix.c  $(INCL)
X
Xregexp.o:	regexp.c  $(INCL) regexp.h
X
Xregsub.o:	regsub.c  $(INCL) regexp.h
X
Xscreen.o:	screen.c  $(INCL)
X
Xscript.o:	script.c  $(INCL)
X
Xsearch.o:	search.c  $(INCL) regexp.h
X
Xtag.o:	tags.c  $(INCL) mark.h
X
Xtermlib.o:	termlib.c $(INCL)
X
Xstorage.o:	storage.c  $(INCL)
X
Xundo.o: undo.c	$(INCL)
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab: mkcmdtab.o
X	${LD} -o mkcmdtab mkcmdtab.o
END_OF_FILE
if test 3130 -ne `wc -c <'vim/src/makefile.dice'`; then
    echo shar: \"'vim/src/makefile.dice'\" unpacked with wrong size!
fi
# end of 'vim/src/makefile.dice'
fi
if test -f 'vim/src/makefile.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.dos'\"
else
echo shar: Extracting \"'vim/src/makefile.dos'\" \(3966 characters\)
sed "s/^X//" >'vim/src/makefile.dos' <<'END_OF_FILE'
X#
X# Makefile for VIM on MSDOS, using Turbo C
X#
X
X#>>>>> choose options:
X### -DUSE_KBHIT		use kbhit() and getch() instead of bioskey()
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DWILD_CARDS	wildcard expansion code
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
XDEFINES = -DWILD_CARDS
X
X#>>>>> name of the compiler and linker, name of lib directory
XCC = tcc
XLINK = tlink
XLIB = d:\tc\lib
X
X#>>>>> end of choices
X###########################################################################
X
XINCL = vim.h globals.h param.h keymap.h macros.h ascii.h term.h msdos.h
XCFLAGS = -c -ml -DMSDOS $(DEFINES)
X
XOBJ =	alloc.obj msdos.obj buffers.obj charset.obj cmdline.obj csearch.obj \
X	digraph.obj edit.obj fileio.obj help.obj linefunc.obj main.obj mark.obj \
X	message.obj misccmds.obj normal.obj ops.obj param.obj quickfix.obj \
X	regexp.obj regsub.obj screen.obj script.obj search.obj storage.obj \
X	tag.obj term.obj undo.obj
X
X..\vim: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(LINK) /c /m $(LIB)\C0l @vimresp,..\vim,..\vim,$(LIB)\emu $(LIB)\Cl
X
Xctags:
X	command /c ctags *.c *.h
X
Xclean:
X	del $(OBJ) version.obj mkcmdtab.obj ..\vim mkcmdtab
X
Xaddcr:	addcr.c
X	$(CC) addcr.c
X	command /c addcr.bat
X
X###########################################################################
X
Xalloc.obj:	alloc.c  $(INCL)
X	$(CC) $(CFLAGS) alloc.c
X
Xmsdos.obj:	msdos.c  $(INCL) msdos.h
X	$(CC) $(CFLAGS) msdos.c
X
Xbuffers.obj:	buffers.c  $(INCL)
X	$(CC) $(CFLAGS) buffers.c
X
Xcharset.obj:	charset.c  $(INCL)
X	$(CC) $(CFLAGS) charset.c
X
Xcmdline.obj:	cmdline.c  $(INCL) cmdtab.h
X	$(CC) $(CFLAGS) cmdline.c
X
Xcsearch.obj:	csearch.c  $(INCL)
X	$(CC) $(CFLAGS) csearch.c
X
Xdigraph.obj:	digraph.c  $(INCL)
X	$(CC) $(CFLAGS) digraph.c
X
Xedit.obj:	edit.c  $(INCL)
X	$(CC) $(CFLAGS) edit.c
X
Xfileio.obj:	fileio.c  $(INCL)
X	$(CC) $(CFLAGS) fileio.c
X
Xhelp.obj:	help.c  $(INCL)
X	$(CC) $(CFLAGS) help.c
X
Xlinefunc.obj:	linefunc.c  $(INCL)
X	$(CC) $(CFLAGS) linefunc.c
X
Xmain.obj:	main.c  $(INCL)
X	$(CC) $(CFLAGS) main.c
X
Xmark.obj:	mark.c  $(INCL)
X	$(CC) $(CFLAGS) mark.c
X
Xmessage.obj:	message.c  $(INCL)
X	$(CC) $(CFLAGS) message.c
X
Xmisccmds.obj:	misccmds.c  $(INCL)
X	$(CC) $(CFLAGS) misccmds.c
X
Xnormal.obj:	normal.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) normal.c
X
Xops.obj:	ops.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) ops.c
X
Xparam.obj:	param.c  $(INCL)
X	$(CC) $(CFLAGS) param.c
X
Xquickfix.obj:	quickfix.c  $(INCL)
X	$(CC) $(CFLAGS) quickfix.c
X
Xregexp.obj:	regexp.c  $(INCL)
X	$(CC) $(CFLAGS) regexp.c
X
Xregsub.obj:	regsub.c  $(INCL)
X	$(CC) $(CFLAGS) regsub.c
X
Xscreen.obj:	screen.c  $(INCL)
X	$(CC) $(CFLAGS) screen.c
X
Xscript.obj:	script.c  $(INCL)
X	$(CC) $(CFLAGS) script.c
X
Xsearch.obj:	search.c  $(INCL)
X	$(CC) $(CFLAGS) search.c
X
Xstorage.obj:	storage.c  $(INCL)
X	$(CC) $(CFLAGS) storage.c
X
Xtag.obj:	tag.c  $(INCL)
X	$(CC) $(CFLAGS) tag.c
X
Xterm.obj:	term.c  $(INCL)
X	$(CC) $(CFLAGS) term.c
X
Xundo.obj:	undo.c  $(INCL)
X	$(CC) $(CFLAGS) undo.c
X
Xcmdtab.h: cmdtab.tab mkcmdtab.exe
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab.exe: mkcmdtab.obj
X	$(CC) -ml -omkcmdtab mkcmdtab.obj
X
Xmkcmdtab.obj: mkcmdtab.c
X	$(CC) $(CFLAGS) mkcmdtab.c
END_OF_FILE
if test 3966 -ne `wc -c <'vim/src/makefile.dos'`; then
    echo shar: \"'vim/src/makefile.dos'\" unpacked with wrong size!
fi
# end of 'vim/src/makefile.dos'
fi
if test -f 'vim/src/message.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/message.c'\"
else
echo shar: Extracting \"'vim/src/message.c'\" \(2523 characters\)
sed "s/^X//" >'vim/src/message.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * message.c: functions for displaying messages on the command line
X */
X
X#include "vim.h"
X#include "globals.h"
X#define MESSAGE
X#include "proto.h"
X#include "param.h"
X
Xstatic int msg_invert = FALSE;
X
X/*
X * msg(s) - displays the string 's' on the status line
X */
X	void
Xmsg(s)
X	char		   *s;
X{
X	int len;
X
X	if (Columns == 0)	/* terminal not initialized */
X	{
X		fprintf(stderr, s);
X		fflush(stderr);
X		return;
X	}
X
X	gotocmdline(TRUE, NUL);
X	if (msg_invert)
X		outstr(T_TI);
X	len = outtrans(s, -1);
X	if (msg_invert)
X	{
X		outstr(T_TP);
X		msg_invert = FALSE;
X	}
X	flushbuf();
X	/*
X	 * if the string is larger than the window,
X	 * or the ruler option is set and we run into it,
X	 * we have to redraw the window.
X	 * Do not do this if we are abandoning the file.
X	 */
X	if (!exiting && len >= Columns - (p_ru ? 22 : 0))
X	{
X		outchar('\n');
X		wait_return(TRUE);
X	}
X}
X
X/* VARARGS */
X#ifndef PROTO		/* automatic prototype generation does not understand this */
X	void
Xsmsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
X	char		*s;
X	long		a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;
X{
X	sprintf(IObuff, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
X	msg(IObuff);
X}
X#endif
X
X/*
X * emsg() - display an error message
X *
X * Rings the bell, if appropriate, and calls message() to do the real work
X */
X	void
Xemsg(s)
X	char		   *s;
X{
X	if (p_eb)
X		beep();				/* also includes flush_buffers() */
X	else
X		flush_buffers();		/* delete all typeahead characters */
X	msg_invert = TRUE;
X	msg(s);
X	flushbuf();
X	if (got_int)		/* remove typeahead now, allow typeadhead during sleep */
X		inchar(TRUE, FALSE);
X	sleep(1);	/* give the user a chance to read the message */
X}
X
X	void
Xwait_return(redraw)
X	int		redraw;
X{
X	u_char			c;
X	int				oldstate;
X
X	oldstate = State;
X	State = HITRETURN;
X	if (got_int)
X		outstrn("Interrupt: ");
X
X#ifdef ORG_HITRETURN
X	outstrn("Press RETURN to continue");
X	do {
X		c = vgetc();
X	} while (strchr("\r\n: ", c) == NULL);
X	if (c == ':')			 /* this can vi too (but not always!) */
X		stuffReadbuff(mkstr(c));
X#else
X	outstrn("Press RETURN or enter command to continue");
X	c = vgetc();
X	if (strchr("\r\n ", c) == NULL)
X		stuffReadbuff(mkstr(c));
X#endif
X
X	if (State == SETWINSIZE)
X	{
X		State = oldstate;
X		set_winsize(0, 0, FALSE);
X	}
X	State = oldstate;
X	script_winsize_pp();
X
X	if (redraw)
X		updateScreen(CLEAR);
X}
END_OF_FILE
if test 2523 -ne `wc -c <'vim/src/message.c'`; then
    echo shar: \"'vim/src/message.c'\" unpacked with wrong size!
fi
# end of 'vim/src/message.c'
fi
if test -f 'vim/src/mkcmdtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/mkcmdtab.c'\"
else
echo shar: Extracting \"'vim/src/mkcmdtab.c'\" \(2066 characters\)
sed "s/^X//" >'vim/src/mkcmdtab.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * mkcmdtab.c: separate program that reads cmdtab.tab and produces cmdtab.h
X *
X *	call with: mkcmdtab cmdtab.tab cmdtab.h
X */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include "vim.h"
X
X	void
Xmain(argc, argv)
X	int		argc;
X	char	**argv;
X{
X	register int	c;
X	char			buffer[100];
X	int				count;
X	int				i;
X	FILE			*ifp, *ofp;
X
X	if (argc != 3)
X	{
X		fprintf(stderr, "Usage: mkcmdtab cmdtab.tab cmdtab.h\n");
X		exit(10);
X	}
X	ifp = fopen(argv[1], "r");
X	if (ifp == NULL)
X	{
X		perror(argv[1]);
X		exit(10);
X	}
X	ofp = fopen(argv[2], "w");
X	if (ofp == NULL)
X	{
X		perror(argv[2]);
X		exit(10);
X	}
X
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X	fprintf(ofp, "THIS FILE IS AUTOMATICALLY PRODUCED - DO NOT EDIT");
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		;
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X
X	count = 0;
X	while ((c = getc(ifp)) != '|' && c != EOF)
X	{
X		putc(c, ofp);
X		while ((c = getc(ifp)) != '"' && c != EOF)
X			putc(c, ofp);
X		putc(c, ofp);
X
X		i = 0;
X		while ((c = getc(ifp)) != '"' && c != EOF)
X		{
X			putc(c, ofp);
X			buffer[i++] = c;
X		}
X		putc(c, ofp);
X		buffer[i] = 0;
X
X		while ((c = getc(ifp)) != '\n' && c != EOF)
X			putc(c, ofp);
X		putc(c, ofp);
X
X		switch (buffer[0])
X		{
X			case '@':	strcpy(buffer, "at");
X						break;
X			case '!':	strcpy(buffer, "bang");
X						break;
X			case '<':	strcpy(buffer, "lshift");
X						break;
X			case '>':	strcpy(buffer, "rshift");
X						break;
X			case '=':	strcpy(buffer, "equal");
X						break;
X			case '&':	strcpy(buffer, "and");
X						break;
X			case '~':	strcpy(buffer, "tilde");
X						break;
X		}
X					
X		fprintf(ofp, "#define CMD_%s %d\n", buffer, count++);
X	}
X
X	fprintf(ofp, "#define CMD_SIZE %d\n", count);
X
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X
X	if (c != '|')
X	{
X		fprintf(stderr, "not enough |'s\n");
X		exit(1);
X	}
X	exit(0);
X}
END_OF_FILE
if test 2066 -ne `wc -c <'vim/src/mkcmdtab.c'`; then
    echo shar: \"'vim/src/mkcmdtab.c'\" unpacked with wrong size!
fi
# end of 'vim/src/mkcmdtab.c'
fi
if test -f 'vim/src/msdos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/msdos.h'\"
else
echo shar: Extracting \"'vim/src/msdos.h'\" \(2033 characters\)
sed "s/^X//" >'vim/src/msdos.h' <<'END_OF_FILE'
X/* vi:ts=8:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar		mool@oce.nl
X *				Tim Thompson		twitch!tjt
X *				Tony Andrews		onecom!wldrdg!tony
X *				G. R. (Fred) Walter	watmath!watcgl!grwalter
X */
X
X/*
X * MSDOS Machine-dependent filenames.
X */
X#ifdef SYSEXRC_FILE
X# undef SYSEXRC_FILE
X# undef SYSVIMRC_FILE
X#endif /* SYSEXRC_FILE */
X#define SYSEXRC_FILE "$VIM\\_exrc"
X#define SYSVIMRC_FILE "$VIM\\_vimrc"
X
X#ifdef EXRC_FILE
X# undef EXRC_FILE
X# undef VIMRC_FILE
X#endif /* EXRC_FILE */
X#define EXRC_FILE "_exrc"
X#define VIMRC_FILE "_vimrc"
X
X#ifdef VIM_HLP
X# undef VIM_HLP
X#endif /* VIM_HLP */
X#define VIM_HLP "$VIM\\vim.hlp"
X
X#ifdef TMPNAME1
X# undef TMPNAME1
X# undef TMPNAME2
X# undef TMPNAMELEN
X#endif /* TMPNAME1 */
X#define TMPNAME1 "viXXXXXX"		/* put it in current dir */
X#define TMPNAME2 "voXXXXXX"		/*  is there a better place? */
X#define TMPNAMELEN	10
X
X/*
X * MSDOS Machine-dependent routines.
X */
X
X#undef remove                   /* MSDOS remove()s when not readonly */
X
X/* msdos.c */
Xvoid	vim_delay __ARGS((void));
Xint	remove __ARGS((char *));
Xvoid	flushbuf __ARGS((void));
Xvoid	outchar __ARGS((unsigned));
Xvoid	outstr __ARGS((char *));
Xint 	GetChars __ARGS((char *, int, int));
Xvoid    textfile __ARGS((int));
Xvoid	mch_suspend __ARGS((void));
Xvoid	mch_windinit __ARGS((void));
Xvoid	check_win __ARGS((int, char **));
Xvoid	fname_case __ARGS((char *));
Xvoid	settitle __ARGS((char *));
Xvoid	resettitle __ARGS((void));
Xint	dirname __ARGS((char *, int));
Xint	FullName __ARGS((char *, char *, int));
Xlong	getperm __ARGS((char *));
Xint	setperm __ARGS((char *, int));
Xint	isdir __ARGS((char *));
Xvoid	mch_windexit __ARGS((int));
Xvoid	mch_settmode __ARGS((int));
Xint	mch_get_winsize __ARGS((void));
Xvoid	mch_set_winsize __ARGS((void));
Xint	call_shell __ARGS((char *, int));
Xvoid	breakcheck __ARGS((void));
Xchar	*modname __ARGS((char *, char *));
X#ifdef WILD_CARDS
Xint	has_wildcard __ARGS((char *));
Xint	ExpandWildCards __ARGS((int, char **, int *, char ***, int, int));
Xvoid	FreeWild __ARGS((int, char **));
X#endif
END_OF_FILE
if test 2033 -ne `wc -c <'vim/src/msdos.h'`; then
    echo shar: \"'vim/src/msdos.h'\" unpacked with wrong size!
fi
# end of 'vim/src/msdos.h'
fi
if test -f 'vim/src/ops.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ops.h'\"
else
echo shar: Extracting \"'vim/src/ops.h'\" \(1963 characters\)
sed "s/^X//" >'vim/src/ops.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * ops.h: things shared between normal.c, cmdline.c and ops.c
X */
X
X/*
X * Operators
X */
X#define NOP 	0				/* no pending operation */
X#define DELETE	1
X#define YANK	2
X#define CHANGE	3
X#define LSHIFT	4
X#define RSHIFT	5
X#define FILTER	6
X#define TILDE	7
X#define INDENT	8
X#define FORMAT	9
X#define COLON	10
X#define UPPER	11
X#define LOWER	12
X
X/*
X * operator characters; the order must correspond to the defines above
X */
XEXTERN char *opchars INIT(= "dyc<>!~=V:uU");
X
X/*
X * When a cursor motion command is made, it is marked as being a character or
X * line oriented motion. Then, if an operator is in effect, the operation
X * becomes character or line oriented accordingly.
X *
X * Character motions are marked as being inclusive or not. Most char. motions
X * are inclusive, but some (e.g. 'w') are not.
X *
X * Generally speaking, every command in normal() should either clear any pending
X * operator (with CLEAROP), or set the motion type variable.
X */
X
X/*
X * Motion types
X */
X#define MBAD	(-1)			/* 'bad' motion type marks unusable yank buf */
X#define MCHAR	0
X#define MLINE	1
X#define MBLOCK	2
X
XEXTERN int		operator INIT(= NOP);	/* current pending operator */
XEXTERN int		mtype;					/* type of the current cursor motion */
XEXTERN int		mincl;					/* true if char motion is inclusive */
XEXTERN int		oneless;				/* 1 if !mincl and startop != endop */
XEXTERN FPOS 	startop;				/* cursor pos. at start of operator */
XEXTERN FPOS		endop;					/* cursor pos. at end of operator */
XEXTERN colnr_t	startvcol;				/* start col for block mode operator */
XEXTERN colnr_t	endvcol;				/* end col for block mode operator */
XEXTERN long		nlines;					/* lines between startop and endop + 1 */
XEXTERN int		yankbuffer INIT(= 0);	/* current yank buffer */
END_OF_FILE
if test 1963 -ne `wc -c <'vim/src/ops.h'`; then
    echo shar: \"'vim/src/ops.h'\" unpacked with wrong size!
fi
# end of 'vim/src/ops.h'
fi
if test -f 'vim/src/sun_stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/sun_stdlib.h'\"
else
echo shar: Extracting \"'vim/src/sun_stdlib.h'\" \(1868 characters\)
sed "s/^X//" >'vim/src/sun_stdlib.h' <<'END_OF_FILE'
X/*
X * sun_stdlib.h: declararions used on a sun
X */
X
X#ifndef __stdlib_h
Xextern void free(void *);
Xextern void *malloc(unsigned);
Xextern void *realloc(void *, unsigned);
Xextern void *calloc(unsigned, unsigned);
X#endif
X#ifdef __sys_types_h
Xextern off_t lseek(int, off_t, int);
X
X# ifdef _sys_time_h
Xextern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
X# endif _sys_time_h
X
X#else
Xextern long lseek(int, long, int);
X#endif
X
Xextern long tell(int);
Xextern void perror(char *);
X
X#ifndef __sys_fcntlcom_h
Xextern int open(char *, int, ...);
X#endif
Xextern int close(int);
Xextern int read(int, char *, unsigned);
Xextern int write(int, char *, unsigned);
Xextern int ioctl(int, int, ...);
Xextern int unlink(char *);
X
X#ifdef FILE
Xextern int _filbuf(FILE *);
Xextern int _flsbuf(unsigned char, FILE *);
Xextern int fclose(FILE *);
Xextern int fprintf(FILE *, char *, ...);
Xextern int fscanf(FILE *, char *, ...);
Xextern int fseek(FILE *, long, int);
Xextern int fflush(FILE *);
Xextern int fread(char *, int, int, FILE *);
X#else
Xextern char *sprintf(char *, char *, ...);
X#endif
X
Xextern int printf(char *, ...);
X
Xextern int scanf(char *, ...);
Xextern int sscanf(char *, char *, ...);
X
Xextern int system(char *);
Xextern char *getenv(char *);
X
Xextern char *getcwd(char *, int);
Xextern char *getwd(char *);
X
Xextern int chdir(char *);
Xextern int getuid(void);
Xextern int getgid(void);
X
Xextern int atoi (char *);
Xextern long atol(char *);
Xextern long strtol(char * , char **, int);
X
Xextern void bcopy(char *, char *, int);
Xextern int bcmp(char *, char *, int);
Xextern void bzero(char *, int);
X
Xextern char *memccpy(char *, char *, int, int);
Xextern char *memchr(char *, int, int);
Xextern char *memset(char *, int, int);
X
Xextern int strncmp(char *, char *, int);
Xextern int strcasecmp(char *, char *);
X
Xextern int toupper(int);
Xextern int tolower(int);
Xextern int isatty(int);
END_OF_FILE
if test 1868 -ne `wc -c <'vim/src/sun_stdlib.h'`; then
    echo shar: \"'vim/src/sun_stdlib.h'\" unpacked with wrong size!
fi
# end of 'vim/src/sun_stdlib.h'
fi
if test -f 'vim/src/tcconfig.tc.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/tcconfig.tc.uue'\"
else
echo shar: Extracting \"'vim/src/tcconfig.tc.uue'\" \(2410 characters\)
sed "s/^X//" >'vim/src/tcconfig.tc.uue' <<'END_OF_FILE'
X
Xbegin 644 tcconfig.tc
XM5'5R8F\@0R!#;VYF:6=U<F%T:6]N($9I;&4@&@`!#1(7`1H``@$!``(````";
XM``(``0`#``(``@`$``$```4``0``!@`!```(``$`!`D``@````T``@`!``X`2
XM`@```!$``0`($@`"````$P`"`!D`%``"````%0`"``$`%@`"````%P`"``$`^
XM&``"``$`9``!``%E``$``68``0`!9P`!``%H``$``6D``0`!:@`!``%K``$`F
XM`6P``0`!;0`!``%N``$``6\``0`!<``!``%Q``$``7(``0`!<P`!``%T``$`"
XM`74``0`!=@`!``%W``$``7@``0`!>0`!``%Z``$``7L``0``?``!``%]``$`2
XM`7X``0``?P`!``&```$``8(``0``A``!``&%``$``<@``0``R0`!``#*``$`Q
XM`<L``0``S``!``#-``$``,X``0`!SP`!``#0``$`&=$``0!DT@`!`"#5``$`Q
XM`-<``0``V``!``#9``$``=H``0`!VP`!``#<``$``=T``0`!W@`!``#?``$``
XM`.```0``X0`!``#B``$``2P!1```````````````````````````````````8
XM`````````````````````````````````````````````````````````"T!N
XM@`!$.EQ40UQ)3D-,541%````````````````````````````````````````1
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````"X!@`!$S
XM.EQ40UQ,24(`````````````````````````````````````````````````@
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````"\!4`!624TN:
XM4%)*````````````````````````````````````````````````````````L
XM`````````````````````````````````````````#`!!``S,@``,0$%`#(UX
XM````,@$%`#$P,```,P%_`$U31$]3.U=)3$1?0T%21%,`````````````````Y
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM```````````T`1X`*@``````````````````````````````````````-0$>1
XM`"H``````````````````````````````````````#8!'@`J````````````I
XM```````````````````````````W`1X`*@```````````````````````````
XM````````````.`$>`"H``````````````````````````````````````#D![
XM'@`J```````````````````````````````````````Z`1X`*@``````````+
XM````````````````````````````.P$>`"H`````````````````````````$
XM`````````````#P!'@`J```````````````````````````````````````]"
XM`8``````````````````````````````````````````````````````````!
XM`````````````````````````````````````````````````````````````
XM```````````````````````````````````````````````````````^`00`#
XM.````#\!4```````````````````````````````````````````````````(
XM`````````````````````````````````````````````````````````$`!!
XM1`!$.EQ40P``````````````````````````````````````````````````U
XM`````````````````````````````````$$!4```````````````````````2
XM`````````````````````````````````````````````````````````````
X9`````````````````````````/__`@`:````:
X``
Xend
Xsize 1690
END_OF_FILE
if test 2410 -ne `wc -c <'vim/src/tcconfig.tc.uue'`; then
    echo shar: \"'vim/src/tcconfig.tc.uue'\" unpacked with wrong size!
fi
# end of 'vim/src/tcconfig.tc.uue'
fi
if test -f 'vim/src/unix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/unix.h'\"
else
echo shar: Extracting \"'vim/src/unix.h'\" \(1925 characters\)
sed "s/^X//" >'vim/src/unix.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Unix system-dependent filenames
X */
X#define BACKUPDIR "~/"
X
X#ifdef TMPNAME1
X# undef TMPNAME1
X# undef TMPNAME2
X# undef TMPNAMELEN
X#endif /* TMPNAME1 */
X#define TMPNAME1 "/tmp/viXXXXXX"
X#define TMPNAME2 "/tmp/voXXXXXX"
X#define TMPNAMELEN	15
X
X#ifdef MAX_COLUMNS
X# undef MAX_COLUMNS
X#endif /* MAX_COLUMNS */
X#define MAX_COLUMNS 1024
X
X#define stricmp vim_stricmp
X
Xvoid	flushbuf __ARGS((void));
Xvoid	outchar __ARGS((unsigned));
Xvoid	outstr __ARGS((char *));
Xint 	GetChars __ARGS((char *, int, int));
Xvoid	vim_delay __ARGS((void));
Xvoid	mch_suspend __ARGS((void));
Xvoid	mch_windinit __ARGS((void));
Xvoid	check_win __ARGS((int, char **));
Xvoid	fname_case __ARGS((char *));
Xvoid	settitle __ARGS((char *));
Xvoid	resettitle __ARGS((void));
Xvoid	mch_settmode __ARGS((int));
Xint 	dirname __ARGS((char *, int));
Xint		FullName __ARGS((char *, char *, int));
Xlong	getperm __ARGS((char *));
Xint		setperm __ARGS((char *, int));
Xint		isdir __ARGS((char *));
Xvoid	mch_windexit __ARGS((int));
Xint		mch_get_winsize __ARGS((void));
Xvoid	mch_set_winsize __ARGS((void));
Xint		call_shell __ARGS((char *, int));
Xvoid	breakcheck __ARGS((void));
X#ifndef linux
Xint		remove __ARGS((char *));
X
X/* generic functions, not in unix.c */
Xvoid	sleep __ARGS((int));
Xint		rename __ARGS((char *, char *));
X#endif
X
Xint		stricmp __ARGS((char *, char *));
X
X#ifdef WILD_CARDS
Xint		has_wildcard __ARGS((char *));
Xint		ExpandWildCards __ARGS((int, char **, int *, char ***, int, int));
Xvoid	FreeWild __ARGS((int, char **));
X#endif
X
X/* memmove is not present on all systems, use bcopy or memcpy */
X#ifdef SYSV
X#define memmove(to, from, len) memcpy(to, from, len)
X#else
X#define memmove(to, from, len) bcopy(from, to, len);
X#endif
END_OF_FILE
if test 1925 -ne `wc -c <'vim/src/unix.h'`; then
    echo shar: \"'vim/src/unix.h'\" unpacked with wrong size!
fi
# end of 'vim/src/unix.h'
fi
if test -f 'vim/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/termcap'\"
else
echo shar: Extracting \"'vim/termcap'\" \(2694 characters\)
sed "s/^X//" >'vim/termcap' <<'END_OF_FILE'
X#
X#	Demonstration of a termcap file
X#
Xsx|ansi|any ansi terminal with pessimistic assumptions:\
X	:co#80:li#24:cl=50\E[;H\E[2J:bs:am:cm=\E[%i%d;%dH:\
X	:nd=\E[C:up=\E[A:ce=\E[K:ho=\E[H:pt:
XMu|sun|Sun Microsystems Workstation console:\
X	:am:bs:km:mi:ms:pt:li#34:co#80:cl=^L:cm=\E[%i%d;%dH:\
X	:ce=\E[K:cd=\E[J:\
X	:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:rs=\E[s:\
X	:md=\E[1m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:im=:ei=:ic=\E[@:dc=\E[P:\
X	:AL=\E[%dL:DL=\E[%dM:IC=\E[%d@:DC=\E[%dP:\
X	:up=\E[A:nd=\E[C:ku=\E[A:kd=\E[B:kr=\E[C:kl=\E[D:\
X	:k1=\E[224z:k2=\E[225z:k3=\E[226z:k4=\E[227z:k5=\E[228z:\
X	:k6=\E[229z:k7=\E[230z:k8=\E[231z:k9=\E[232z:
XM-|sun-e|sun-nic|sune|Sun Microsystems Workstation without insert character:\
X	:ic@:im@:ei@:tc=sun:
XMu|sun-s|Sun Microsystems Workstation window with status line:\
X	:hs:ts=\E]l:fs=\E\\:ds=\E]l\E\\:tc=sun:
XMu|sun-e-s|sun-s-e|Sun Microsystems Workstation with status hacked for emacs:\
X	:hs:ts=\E]l:fs=\E\\:ds=\E]l\E\\:tc=sun-e:
XM0|sun-48|Sun 48-line window:\
X	:li#48:co#80:tc=sun:
XM1|sun-34|Sun 34-line window:\
X	:li#34:co#80:tc=sun:
XM2|sun-24|Sun 24-line window:\
X	:li#24:co#80:tc=sun:
XM3|sun-17|Sun 17-line window:\
X	:li#17:co#80:tc=sun:
Xv9|925a|tvi925a|TeleVideo Model 925:\
X	:al=\EE:am:bs:bt=\EI:bw:cd=\EY:ce=\ET:cl=^Z:cm=\E=%+ %+ :co#80:dc=\EW:\
X	:dl=\ER:do=^V:ei=:ic=\EQ:if=/usr/share/lib/tabset/std:im=:kb=^H:kd=^V:\
X	:kh=^^:kl=^H:kn#12:kr=^L:ku=^K:li#24:nd=^L:pt:se=\EG0:sg#1:so=\EG4:\
X	:ue=\EG0:ug#1:ul:up=^K:us=\EG8:is=\El\
X	:vb=\Eb\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Ed:\
X	:ve=\E.4:vs=\E.2:
Xd0|vt100|vt100-am|vt100am|dec vt100:\
X	:do=^J:co#80:li#24:cl=50\E[;H\E[2J:sf=5\ED:\
X	:le=^H:bs:am:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:\
X	:ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
X	:rf=/usr/share/lib/tabset/vt100:\
X	:rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:ke=\E[?1l\E>:\
X	:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:\
X	:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:pt:sr=5\EM:vt#3:xn:\
X	:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:
X# Amiga termcap by Bram Moolenaar
XAA|amiga|Amiga ANSI:\
X	:co#80:li#25:am:do=\E[B:ce=\E[K:cd=\E[J:\
X	:cl=\014:ku=\233A:kd=\233B:kl=\233D:kr=\233C:kb=^H:\
X	:#4=\233 A:%i=\233 @:%1=\233?~:\
X	:k1=\2330~:k2=\2331~:k3=\2332~:k4=\2333~:k5=\2334~:\
X	:k6=\2335~:k7=\2336~:k8=\2337~:k9=\2338~:k;=\2339~:\
X	:F1=\23310~:F2=\23311~:F3=\23312~:F4=\23313~:F5=\23314~:\
X	:F6=\23315~:F7=\23316~:F8=\23317~:F9=\23318~:FA=\23319~:\
X	:al=\E[L:AL=\E[%dL:dl=\E[M:DL=\E[%dM:le=^H:cm=\E[%i%d;%dH:\
X	:nd=\E[C:RI=\E[%dC:up=\E[A:\
X	:ce=\E[K:ho=\E[H:dc=\E[P:ic=\E[@:vi=\E[0 p:ve=\E[1 p:\
X	:so=\E[2m:se=\E[m:us=\E[4m:ue=\E[m:mr=\E[7m:mb=\E[7;2m:me=\E[m:
X#
X# END OF TERMCAP
X#
END_OF_FILE
if test 2694 -ne `wc -c <'vim/termcap'`; then
    echo shar: \"'vim/termcap'\" unpacked with wrong size!
fi
# end of 'vim/termcap'
fi
echo shar: End of archive 2 \(of 23\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 23 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-------------8<----------------8<----------------8<---------------8<--------
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595450 | whatever will be accepted.

exit 0 # Just in case...
