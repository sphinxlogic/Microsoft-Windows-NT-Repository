Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v37i009:  vim - Vi IMitation editor v1.27, Part09/24
Message-ID: <1993Apr23.173702.18518@sparky.imd.sterling.com>
X-Md4-Signature: 9198928b4c843a98c1cd69bf7df98d94
Date: Fri, 23 Apr 1993 17:37:02 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 37, Issue 9
Archive-name: vim/part09
Environment: UNIX, AMIGA, MS-DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 23)."
# Contents:  vim/macros/maze/maze.mac.uue vim/src/buffers.c
#   vim/src/fileio.c
# Wrapped by mool@oce-rd2 on Mon Apr 19 15:50:09 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/macros/maze/maze.mac.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze.mac.uue'\"
else
echo shar: Extracting \"'vim/macros/maze/maze.mac.uue'\" \(17071 characters\)
sed "s/^X//" >'vim/macros/maze/maze.mac.uue' <<'END_OF_FILE'
X
Xbegin 644 maze.mac
XM(B!4:&5S92!M86-R;W,@)W-O;'9E)R!A;GD@;6%Z92!P<F]D=6-E9"!B>2!TQ
XM:&4@82UM87IE+6EN9R!M87IE+F,@<')O9W)A;2X*(B`*(B!&:7)S="P@82!B&
XM:70@;V8@;6%Z92!T:&5O<GDN"B(@268@>6]U('=E<F4@<'5T(&EN=&\@82!MT
XM87IE+"!A(&=U87)A;G1E960@;65T:&]D(&]F(&9I;F1I;F<@>6]U<B!W87D*L
XM(B!O=70@;V8@=&AE(&UA>F4@:7,@=&\@<'5T('EO=7(@;&5F="!H86YD(&]NG
XM=&\@82!W86QL(&%N9"!J=7-T(&ME97`@=V%L:VEN9RP*(B!N979E<B!T86MI@
XM;F<@>6]U<B!H86YD(&]F9B!T:&4@=V%L;"X@5&AI<R!T96-H;FEQ=64@:7,@S
XM;VYL>2!G=6%R86YT965D('1O"B(@=V]R:R!I9B!T:&4@;6%Z92!D;V5S(&YOY
XM="!H879E(&%N>2`G:7-L86YD<R<L(&]R(&EF('1H92`G97AI="<@:7,@;VX@Z
XM=&AE"B(@<V%M92!I<VQA;F0@87,@>6]U<B!S=&%R=&EN9R!P;VEN="X@5&AEV
XM<V4@8V]N9&ET:6]N<R!H;VQD(&9O<B!T:&4@;6%Z97,*(B!U;F1E<B!C;VYS^
XM:61E<F%T:6]N+@HB(`HB($%S<W5M:6YG('1H870@=&AE(&UA>F4@:7,@;6%D9
XM92!U<"!O9B!H;W)I>F]N=&%L(&%N9"!V97)T:6-A;"!W86QL<R!S<&%C960*S
XM(B!O;F4@<W1E<"!A<&%R="!A;F0@=&AA="!Y;W4@8V%N(&UO=F4@96ET:&5R#
XM(&YO<G1H+"!S;W5T:"P@96%S="!O<B!W97-T+`HB('1H96X@>6]U(&-A;B!A>
XM=71O;6%T92!T:&ES('!R;V-E9'5R92!B>2!C87)R>6EN9R!O=70@=&AE(&9O(
XM;&QO=VEN9R!S=&5P<RX*(B`*(B`Q+B!0=70@>6]U<G-E;&8@<V]M97=H97)E1
XM(&EN('1H92!M87IE(&YE87(@82!W86QL+@HB(#(N($-H96-K(&EF('EO=2!H(
XM879E(&$@=V%L;"!O;B!Y;W5R(&QE9G0N($EF('-O+"!G;R!T;R!S=&5P(#0N&
XM"B(@,RX@5&AE<F4@:7,@;F\@=V%L;"!O;B!Y;W5R(&QE9G0L('-O('1U<FX@\
XM;VX@=&AE('-P;W0@=&\@>6]U<B!L969T(&%N9"!S=&5P"B(@("`@9F]R=V%R-
XM9"!B>2!O;F4@<W1E<"!A;F0@<F5P96%T('-T97`@,BX*(B`T+B!#:&5C:R!WP
XM:&%T(&ES(&1I<F5C=&QY(&EN(&9R;VYT(&]F('EO=2X@268@:70@:7,@82!WY
XM86QL+"!T=7)N(&]N('1H90HB("`@('-P;W0@=&\@>6]U<B!R:6=H="!B>2`YB
XM,"!D96=R965S(&%N9"!R97!E870@<W1E<"`T+@HB(#4N(%1H97)E(&ES(&YO!
XM('=A;&P@:6X@9G)O;G0@;V8@>6]U+"!S;R!S=&5P(&9O<G=A<F0@;VYE('-T*
XM97`@86YD"B(@("`@9V\@=&\@<W1E<"`R+@HB(`HB($EN('1H:7,@=V%Y('EOI
XM=2!W:6QL(&-O=F5R(&%L;"!T:&4@8V]R<FED;W)S(&]F('1H92!M87IE("AU=
XM;G1I;"!Y;W4@9V5T(&)A8VL*(B!T;R!W:&5R92!Y;W4@<W1A<G1E9"!F<F]M7
XM+"!I9B!Y;W4@9&\@;F]T('-T;W`I+@HB(`HB($)Y(&5X86UI;FEN9R!A(&UA;
XM>F4@<')O9'5C960@8GD@=&AE(&UA>F4N8R!P<F]G<F%M('EO=2!W:6QL('-ET
XM92!T:&%T(`HB(&5A8V@@<W%U87)E(&]F('1H92!M87IE(&ES(&]N92!C:&%RC
XM86-T97(@:&EG:"!A;F0@='=O(&-H87)A8W1E<G,@=VED92X*(B!4;R!G;R!NF
XM;W)T:"!O<B!S;W5T:"P@>6]U(&UO=F4@8GD@82!O;F4@8VAA<F%C=&5R('-T#
XM97`L(&)U="!T;R!M;W9E(&5A<W0@;W(*(B!W97-T('EO=2!M;W9E(&)Y(&$@3
XM='=O(&-H87)A8W1E<B!S=&5P+B!!;'-O(&YO=&4@=&AA="!I;B!A;GD@<&]S8
XM:71I;VX*(B!T:&5R92!A<F4@9F]U<B!P;&%C97,@=VAE<F4@=V%L;',@8V]UX
XM;&0@8F4@<'5T("T@=&\@=&AE(&YO<G1H+"!T;R!T:&4@<V]U=&@L"B(@=&\@*
XM=&AE(&5A<W0@86YD('1O('1H92!W97-T+@HB($$@=V%L;"!E>&ES=',@=&\@6
XM=&AE(&YO<G1H(&]F('EO=2!I9B!T:&4@8VAA<F%C=&5R('1O('1H92!N;W)TB
XM:"!O9@HB('EO=2!I<R!A(%\@*&]T:&5R=VES92!I="!I<R!A('-P86-E*2X*K
XM(B!!('=A;&P@97AI<W1S('1O('1H92!E87-T(&]F('EO=2!I9B!T:&4@8VAA2
XM<F%C=&5R('1O('1H92!E87-T(&]F('EO=0HB(&ES(&$@?"`H;W1H97)W:7-E+
XM(&ET(&ES(&$@+BDN"B(@02!W86QL(&5X:7-T<R!T;R!T:&4@=V5S="!O9B!Y1
XM;W4@:68@=&AE(&-H87)A8W1E<B!T;R!T:&4@=V5S="!O9B!Y;W4*(B!I<R!AC
XM('P@*&]T:&5R=VES92!I="!I<R!A("XI+@HB($$@=V%L;"!E>&ES=',@=&\@=
XM=&AE('-O=71H(&]F('EO=2!I9B!T:&4@8VAA<F%C=&5R('=H97)E('EO=2!A<
XM<F4*(B!I<R!A(%\@*&]T:&5R=VES92!I="!I<R!A('-P86-E*2X*(B`*(B!.$
XM;W1E('1H92!D:69F97)E;F-E(&9O<B!D:7)E8W1I;VX@<V]U=&@L('=H97)E6
XM('=E(&UU<W0@97AA;6EN92!T:&4@8VAA<F%C=&5R"B(@=VAE<F4@=&AE(&-U:
XM<G-O<B!I<R!R871H97(@=&AA;B!A;B!A9&IA8V5N="!C96QL+@HB(`HB($EFQ
XM('EO=2!W97)E(&EM<&QE;65N=&EN9R!T:&4@86)O=F4@<')O8V5D=7)E(&ESL
XM(&$@;F]R;6%L(&-O;7!U=&5R(&QA;F=U86=E"B(@>6]U(&-O=6QD('5S92!AK
XM(&QO;W`@=VET:"!I9B!S=&%T96UE;G1S(&%N9"!C;VYT:6YU92!S=&%T96UEX
XM;G1S+"`*(B!(;W=E=F5R+"!T:&5S92!C;VYS=')U8W1S(&%R92!N;W0@879A+
XM:6QA8FQE(&EN('9I(&UA8W)O<R!S;R!)(&AA=F4@=7-E9`HB(&$@<W1A=&4@2
XM;6%C:&EN92!W:71H(#@@<W1A=&5S+B!%86-H('-T871E('-I9VYI9FEE<R!TR
XM:&4@9&ER96-T:6]N('EO=0HB(&%R92!G;VEN9R!I;B!A;F0@=VAE=&AE<B!O3
XM<B!N;W0@>6]U(&AA=F4@8VAE8VME9"!I9B!T:&5R92!I<R!A('=A;&P@;VX*&
XM(B!Y;W5R(&QE9G0N"B(@"B(@5&AE('1R86YS:71I;VX@9G)O;2!S=&%T92!T7
XM;R!S=&%T92!A;F0@=&AE(&%C=&EO;G,@=&%K96X@;VX@96%C:"!T<F%N<VET[
XM:6]N"B(@87)E(&=I=F5N(&EN('1H92!S=&%T92!T86)L92!B96QO=RX*(B!4+
XM:&4@;F%M97,@;V8@=&AE('-T871E<R!A<F4@3C$L($XR+"!3,2P@4S(L($4QQ
XM+"!%,BP@5S$L(%<R+"!W:&5R92!E86-H(&QE='1E<@HB('-T86YD<R!F;W(@4
XM82!D:7)E8W1I;VX@;V8@=&AE(&-O;7!A<W,L('1H92!N=6UB97(@,2!I;F1IY
XM8V%T97,@=&AA="!T:&4@=V4*(B!H879E(&YO="!Y970@8VAE8VME9"!T;R!S.
XM964@:68@=&AE<F4@:7,@82!W86QL(&]N(&]U<B!L969T(&%N9"!T:&4@;G5M@
XM8F5R(#(*(B!I;F1I8V%T97,@=&AA="!W92!H879E(&-H96-K960@86YD('1H2
XM97)E(&ES(&$@=V%L;"!O;B!O=7(@;&5F="X*(B`*(B!&;W(@96%C:"!S=&%T!
XM92!W92!M=7-T(&-O;G-I9&5R('1H92!E>&ES=&5N8V4@;W(@;F]T(&]F(&$@2
XM=V%L;"!I;B!A"B(@<&%R=&EC=6QA<B!D:7)E8W1I;VXN(%1H:7,@9&ER96-T-
XM:6]N(&ES(&=I=F5N(&EN('1H92!F;VQL;W=I;F<@=&%B;&4N"B(@"B(@3F5X=
XM=$-H87(@=&%B;&4Z"B(@<W1A=&4@("`@("`@(&1I<F5C=&EO;B`@("`@("!V8
XM:2!C;VUM86YD<PHB("!.,2`@("`@("`@("`@("`@5R`@("`@("`@("`@("`@=
XM(&A&"B(@($XR("`@("`@("`@("`@("!.("`@("`@("`@("`@("`@:T8*(B`@%
XM4S$@("`@("`@("`@("`@($4@("`@("`@("`@("`@("!L1@HB("!3,B`@("`@L
XM("`@("`@("`@4R`@("`@("`@("`@("`@($8*(B`@13$@("`@("`@("`@("`@;
XM($X@("`@("`@("`@("`@("!K1@HB("!%,B`@("`@("`@("`@("`@12`@("`@'
XM("`@("`@("`@(&Q&"B(@(%<Q("`@("`@("`@("`@("!3("`@("`@("`@("`@Y
XM("`@1@HB("!7,B`@("`@("`@("`@("`@5R`@("`@("`@("`@("`@(&A&"B(@,
XM"B(@=VAE<F4@1B!I<R!A(&UA8W)O('=H:6-H('EA;FMS('1H92!C:&%R86-T,
XM97(@=6YD97(@=&AE(&-U<G-O<B!I;G1O"B(@=&AE($YE>'1#:&%R(')E9VES2
XM=&5R("AN*2X*(B`*(B!3=&%T92!T86)L93H*(B!);B!T:&4@)W9I(&-O;6UA*
XM;F1S)R!C;VQU;6X@:7,@9VEV96X@=&AE(&%C=&EO;G,@=&\@8V%R<GD@;W5T]
XM('=H96X@:6X*(B!T:&ES('-T871E(&%N9"!T:&4@3F5X=$-H87(@:7,@87,@/
XM9VEV96XN(%1H92!C;VUM86YD<R!K+"!J+"!L;"P@:&@@;6]V90HB('1H92!CB
XM=7)R96YT('!O<VET:6]N(&YO<G1H+"!S;W5T:"P@96%S="!A;F0@=V5S="!R`
XM97-P96-T:79E;'DN(%1H90HB(&-O;6UA;F0@;6T@:7,@=7-E9"!A<R!A(&YO`
XM+6]P(&-O;6UA;F0N"B(@26X@=&AE("=N97AT('-T871E)R!C;VQU;6X@:7,@5
XM9VEV96X@=&AE(&YE=R!S=&%T92!O9B!T:&4@;6%C:&EN92!A9G1E<@HB('1H*
XM92!A8W1I;VX@:7,@8V%R<FEE9"!O=70N"B(@"B(@8W5R<F5N="!S=&%T92`@[
XM("`@("`@3F5X=$-H87(@("`@=FD@8V]M;6%N9',@(&YE>'0@<W1A=&4*(B`@:
XM("`@($XQ("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@:&@@("`@("`@]
XM("`@5S$*(B`@("`@($XQ("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@O
XM;6T@("`@("`@("`@3C(*(B`@("`@($XR("`@("`@("`@("`@("`@("!?("`@E
XM("`@("`@("`@;6T@("`@("`@("`@13$*(B`@("`@($XR("`@("`@("`@("`@<
XM("`@<W!A8V4@("`@("`@("`@:R`@("`@("`@("`@3C$*(B`@("`@(%,Q("`@&
XM("`@("`@("`@("`@("`N("`@("`@("`@("`@;&P@("`@("`@("`@13$*(B`@H
XM("`@(%,Q("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@:
XM("`@4S(*(B`@("`@(%,R("`@("`@("`@("`@("`@("!?("`@("`@("`@("`@5
XM;6T@("`@("`@("`@5S$*(B`@("`@(%,R("`@("`@("`@("`@("`@<W!A8V4@?
XM("`@("`@("`@:B`@("`@("`@("`@4S$*(B`@("`@($4Q("`@("`@("`@("`@0
XM("`@<W!A8V4@("`@("`@("`@:R`@("`@("`@("`@3C$*(B`@("`@($4Q("`@X
XM("`@("`@("`@("`@("!?("`@("`@("`@("`@;6T@("`@("`@("`@13(*(B`@<
XM("`@($4R("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@-
XM("`@4S$*(B`@("`@($4R("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@5
XM;&P@("`@("`@("`@13$*(B`@("`@(%<Q("`@("`@("`@("`@("`@<W!A8V4@.
XM("`@("`@("`@:B`@("`@("`@("`@4S$*(B`@("`@(%<Q("`@("`@("`@("`@B
XM("`@("!?("`@("`@("`@("`@;6T@("`@("`@("`@5S(*(B`@("`@(%<R("`@W
XM("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@("`@3C$*(B`@!
XM("`@(%<R("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@:&@@("`@("`@'
XM("`@5S$*(@HB(`HB($-O;7!L86EN="!A8F]U="!V:2!M86-R;W,Z"B(@270@5
XM<V5E;7,@=&AA="!Y;W4@8V%N;F]T(&AA=F4@;6]R92!T:&%N(&]N92`G=6YD@
XM;RUA8FQE)R!V:2!C;VUM86YD"B(@:6X@=&AE(&]N92!M86-R;RP@<V\@>6]U8
XM(&AA=F4@=&\@;6%K92!L;W1S(&]F(&QI='1L92!M86-R;W,@86YD"B(@<'5TG
XM('1H96T@=&]G971H97(N"B(*(B!))VQL(&5X<&QA:6X@=VAA="!)(&UE86X@M
XM8GD@86X@97AA;7!L92X@161I="!A(&9I;&4@86YD"B(@='EP92`G.FUA<"!1\
XM(')862<N(%1H:7,@<VAO=6QD(&UA<"!T:&4@42!K97D@=&\@)W)E<&QA8V4@>
XM=&AE"B(@8VAA<F%C=&5R('5N9&5R('1H92!C=7)S;W(@=VET:"!8(&%N9"!Y7
XM86YK('1H92!L:6YE)RX*(B!"=70@=VAE;B!)('1Y<&4@42P@=FD@=&5L;',@,
XM;64@)T-A;B=T('EA;FL@:6YS:61E(&=L;V)A;"]M86-R;R<@86YD"B(@9V]E(
XM<R!I;G1O(&5X(&UO9&4N($AO=V5V97(@:68@22!T>7!E("<Z;6%P(%$@<EA4E
XM)R!A;F0@)SIM87`@5"!9)RP*(B!E=F5R>71H:6YG(&ES($]++B!)8&T@9&]I`
XM;F<@86QL('1H:7,@;VX@82!3<&%R8W-T871I;VXN"B(@268@86YY;VYE(')EI
XM861I;F<@=&AI<R!H87,@86X@86YS=V5R('1O('1H:7,@<')O8FQE;2P@=&AE/
XM(&%U=&AO<B!W;W5L9`HB(&QO=F4@=&\@9FEN9"!O=70N($UA:6P@=&\@9W)EN
XM9VU`;W1C+F]T8V$N;WHN874N"B(*(B!4:&4@;6%C<F]S.@HB(%1H92!M86-R@
XM;R!T;R!R=6X@=&AE(&UA>F4@<V]L=F5R(&ES("=G)RX@5&AI<R!S:6UP;'D@E
XM8V%L;',@='=O(&]T:&5R"B(@;6%C<F]S.B!)+"!T;R!I;FET:6%L:7-E(&5VT
XM97)Y=&AI;F<L(&%N9"!,+"!T;R!L;V]P(&9O<F5V97(@<G5N;FEN9PHB('1H`
XM<F]U9V@@=&AE('-T871E('1A8FQE+@HB($)O=&@@;V8@=&AE<V4@;6%C<F]S)
XM(&%R92!L;VYG('-E<75E;F-E<R!O9B!C86QL<R!T;R!O=&AE<B!M86-R;W,N0
XM($%L;`HB(&]F('1H97-E(&]T:&5R(&UA8W)O<R!A<F4@<75I=&4@<VEM<&QE$
XM(&%N9"!S;R!T;R!U;F1E<G-T86YD(&AO=R!T:&ES"B(@=V]R:W,L(&%L;"!Y6
XM;W4@;F5E9"!T;R!D;R!I<R!E>&%M:6YE(&UA8W)O<R!)(&%N9"!,(&%N9"!L%
XM96%R;B!W:&%T('1H97D*(B!D;R`H82!S:6UP;&4@<V5Q=65N8V4@;V8@=FD@3
XM86-T:6]N<RD@86YD(&AO=R!,(&QO;W!S("AB>2!C86QL:6YG(%4L('=H:6-H%
XM"B(@<VEM<&QY(&-A;&QS($P@86=A:6XI+@HB"B(@36%C<F\@22!S971S('5PS
XM('1H92!S=&%T92!T86)L92!A;F0@3F5X=$-H87(@=&%B;&4@870@=&AE(&5N+
XM9"!O9B!T:&4@9FEL92X*(B!-86-R;R!,('1H96X@<V5A<F-H97,@=&AE<V4@H
XM=&%B;&5S('1O(&9I;F0@;W5T('=H870@86-T:6]N<R!T;R!P97)F;W)M(&%NI
XM9`HB('=H870@<W1A=&4@8VAA;F=E<R!T;R!M86ME+@HB"B(@5&AE(&5N=')IH
XM97,@:6X@=&AE('-T871E('1A8FQE(&%L;"!B96=I;B!W:71H(&$@:V5Y(&-O/
XM;G-I<W1I;F<@;V8@=&AE"B(@;&5T=&5R("=S)RP@=&AE(&-U<G)E;G0@<W1A:
XM=&4@86YD('1H92!.97AT0VAA<BX@($%F=&5R('1H:7,@:7,@=&AE"B(@86-TC
XM:6]N('1O('1A:V4@:6X@=&AI<R!S=&%T92!A;F0@869T97(@=&AI<R!I<R!T+
XM:&4@;F5X="!S=&%T92!T;R!C:&%N9V4@=&\N"B(*(B!4:&4@96YT<FEE<R!IC
XM;B!T:&4@3F5X=$-H87(@=&%B;&4@8F5G:6X@=VET:"!A(&ME>2!C;VYS:7-T"
XM:6YG(&]F('1H90HB(&QE='1E<B`G;B<@86YD('1H92!C=7)R96YT('-T871ED
XM+B!!9G1E<B!T:&ES(&ES('1H92!A8W1I;VX@=&\@=&%K92!T;PHB(&]B=&%IY
XM;B!.97AT0VAA<B`M('1H92!C:&%R86-T97(@=&AA="!M=7-T(&)E(&5X86UI[
XM;F5D('1O(&-H86YG92!S=&%T92X*(@HB($]N92!W87D@=&\@<V5E('=H870@.
XM96%C:"!P87)T(&]F('1H92!M86-R;W,@:7,@9&]I;F<@:7,@=&\@='EP92!IZ
XM;B!T:&4*(B!B;V1Y(&]F('1H92!M86-R;W,@22!A;F0@3"!M86YU86QL>2`HW
XM:6YS=&5A9"!O9B!T>7!I;F<@)V<G*2!A;F0@<V5E"B(@=VAA="!H87!P96YS5
XM(&%T(&5A8V@@<W1E<"X*(@HB($=O;V0@;'5C:RX*(@HB(%)E9VES=&5R<R!US
XM<V5D(&)Y('1H92!M86-R;W,Z"B(@<R`H4W1A=&4I("`@("`@("`M(&AO;&1S/
XM('1H92!S=&%T92!T:&4@;6%C:&EN92!I<R!I;@HB(&,@*$-H87(I("`@("`@)
XM("`@+2!H;VQD<R!T:&4@8VAA<F%C=&5R('5N9&5R('1H92!C=7)R96YT('!OV
XM<VET:6]N"B(@;2`H36%C<F\I("`@("`@("`M(&AO;&1S(&$@=FD@8V]M;6%NT
XM9"!S=')I;F<@=&\@8F4@97AE8W5T960@;&%T97(*(B!N("A.97AT0VAA<BD@<
XM("`@("T@:&]L9',@=&AE(&-H87)A8W1E<B!W92!M=7-T(&5X86UI;F4@=&\@D
XM8VAA;F=E('-T871E"B(@<B`H4V5C;VYD($UA8W)O*2`M(&AO;&1S(&$@<V5CG
XM;VYD('9I(&-O;6UA;F0@<W1R:6YG('1O(&)E(&5X96-U=&5D(&QA=&5R"B(*%
XM<V5T(')E;6%P"G-E="!N;VUA9VEC"G-E="!N;W1E<G-E"G-E="!W<F%P<V-AR
XM;@HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T].
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@9R`M(&=O(')U;G,@=&AE('=HV
XM;VQE('-H;W<*(B`@("`@("`@22`M(&EN:71I86QI<V4*(B`@("`@("`@3"`MS
XM('1H96X@;&]O<"!F;W)E=F5R"FUA<"!G("`@24P*(@HB/3T]/3T]/3T]/3T]Z
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/0HB($D@+2!I;FET:6%L:7-E(&5V97)Y=&AI;F<@8F5F;W)E(')U7
XM;FYI;F<@=&AE(&QO;W`*(B`@($<D/RY>32`M(&9I;F0@=&AE(&QA<W0@+B!I^
XM;B!T:&4@;6%Z90HB("`@("`@("!>("T@<F5P;&%C92!I="!W:71H(&%N(%@@/
XM*'1H92!G;V%L*0HB("`@1UE+9410("T@<')I;G0@=&AE('-T871E('1A8FQEI
XM(&%N9"!N97AT(&-H87(@=&%B;&4@870@=&AE(&5N9"!O9B!T:&4@9FEL90HB'
XM("`@("`@(#!3("T@:6YI=&EA;&ES92!T:&4@<W1A=&4@;V8@=&AE(&UA8VAI5
XM;F4@=&\@13$*(B`@("`@(#)';"`M(&UO=F4@=&\@=&AE('1O<"!L969T(&-EK
XM;&P@;V8@=&AE(&UA>F4*;6%P($D@("!')#\N#5Y'64ME1%`P4S)';`HB"B(]P
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]"B(@3"`M('1H92!L;V]P('=H:6-H(&ES(&5X6
XM96-U=&5D(&9O<F5V97(*(B`@("`@("`@42`M('-A=F4@=&AE(&-U<G)E;G0@0
XM8VAA<F%C=&5R(&EN('1H92!#:&%R(')E9VES=&5R"B(@("`@("`@($$@+2!RT
XM97!L86-E('1H92!C=7)R96YT(&-H87)A8W1E<B!W:71H(&%N("=/)PHB("`@/
XM("`@(&UA("T@;6%R:R!T:&4@8W5R<F5N="!P;W-I=&EO;B!W:71H(&UA<FL@&
XM)V$G"B(@("`@("!'3D(@+2!O;B!B;W1T;VT@;&EN92P@8W)E871E(&$@8V]M9
XM;6%N9"!T;R!S96%R8V@@=&AE($YE>'1#:&%R('1A8FQE"B(@("`@("`@("`@K
XM("!F;W(@=&AE(&-U<G)E;G0@<W1A=&4*(B`P33!%0&U>32`M('EA;FL@=&AEC
XM(&-O;6UA;F0@:6YT;R!T:&4@36%C<F\@<F5G:7-T97(@86YD(&5X96-U=&4@7
XM:70*(B`@("`@("!W6"`M('=E(&AA=F4@;F]W(&9O=6YD('1H92!E;G1R>2!IQ
XM;B!T:&4@=&%B;&4L(&YO=R!Y86YK('1H90HB("`@("`@("`@("`@9F]L;&]W*
XM:6YG('=O<F0@:6YT;R!T:&4@36%C<F\@<F5G:7-T97(*(B`@("`@8&%`;2`MS
XM(&=O(&)A8VL@=&\@=&AE(&-U<G)E;G0@<&]S:71I;VX@86YD(&5X96-U=&4@)
XM=&AE(&UA8W)O+"!T:&ES('=I;&P*(B`@("`@("`@("`@('EA;FL@=&AE($YEB
XM>'1#:&%R(&EN(')E9VES=&5R(&X*(B`@($=4)$(D4B`M(&]N(&)O='1O;2!L"
XM:6YE+"!C<F5A=&4@82!C;VUM86YD('1O('-E87)C:"!T:&4@<W1A=&4@=&%B.
XM;&4*(B`@("`@("`@("`@(&9O<B!T:&4@8W5R<F5N="!S=&%T92!A;F0@3F5XG
XM=$-H87(*(B`P33!%0&U>32`M('EA;FL@=&AE(&-O;6UA;F0@:6YT;R!T:&4@C
XM36%C<F\@<F5G:7-T97(@86YD(&5X96-U=&4@:70*(B`@("`@(#)74R`M('=EK
XM(&AA=F4@;F]W(&9O=6YD('1H92!E;G1R>2!I;B!T:&4@=&%B;&4L(&YO=R!Y@
XM86YK('1H90HB("`@("`@("`@("`@;F5X="!S=&%T92!I;G1O('1H92!3=&%T^
XM92!M86-R;PHB("`@("`@(&)8("T@86YD('EA;FL@=&AE(&%C=&EO;B!C;W)RE
XM97-P;VYD:6YG('1O('1H:7,@<W1A=&4@=&%B;&4@96YT<GD*(B`@("`@("`@)
XM("`@(&EN=&\@=&AE($UA8W)O(')E9VES=&5R"B(@("`@("!'5DH@+2!O;B!B1
XM;W1T;VT@;&EN92P@8W)E871E(&$@8V]M;6%N9"!T;R!R97-T;W)E('1H92!C&
XM=7)R96YT(&-H87)A8W1E<@HB("`@("`@(#!(("T@86YD('-A=F4@=&AE(&-OS
XM;6UA;F0@:6YT;R!T:&4@<V5C;VYD($UA8W)O(')E9VES=&5R"B(@("`@(&!A(
XM0'(@+2!G;R!B86-K('1O('1H92!C=7)R96YT('!O<VET:6]N(&%N9"!E>&5C:
XM='5T92!T:&4@;6%C<F\@=&\@<F5S=&]R90HB("`@("`@("`@("`@=&AE(&-UA
XM<G)E;G0@8VAA<F%C=&5R"B(@("`@("`@0&T@+2!E>&5C=71E('1H92!A8W1IS
XM;VX@87-S;V-I871E9"!W:71H('1H:7,@<W1A=&4*(B`@("`@("`@52`M(&%N/
XM9"!R97!E870*;6%P($P@("!106UA1TY",$TP14!M#7=88&%`;4=4)$(D4C!-M
XM,$5`;0TR5U-B6$=62C!(8&%`<D!M50HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]X
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM"B(@52`M(&YO('1A:6P@<F5C=7)S:6]N(&%L;&]W960@:6X@=FD@;6%C<F]S2
XM('-O(&-H96%T(&%N9"!S970@52`]($P*;6%P(%4@("!,"B(*(CT]/3T]/3T]-
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T*(B!3("T@>6%N:R!T:&4@;F5X="!T=V\@8VAA<F%C=&5RE
XM<R!I;G1O('1H92!3=&%T92!R96=I<W1E<@IM87`@4R`@(")S>3)L"B(*(CT]M
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!1("T@<V%V92!T:&4@8W5R<F5N="!C:&%R(
XM86-T97(@:6X@=&AE($-H87(@<F5G:7-T97(*;6%P(%$@("`B8WEL"B(*(CT]?
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!!("T@<F5P;&%C92!T:&4@8W5R<F5N="!CJ
XM:&%R86-T97(@=VET:"!A;B`G3R<*;6%P($$@("!R3PHB"B(]/3T]/3T]/3T]6
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]"B(@3B`M(')E<&QA8V4@=&AI<R!L:6YE('=I=&@@=&AE('-TL
XM<FEN9R`G;B<*;6%P($X@("!#+VX;"B(*(CT]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T*&
XM(B!"("T@<'5T('1H92!C=7)R96YT('-T871E"FUA<"!"("`@(G-P"B(*(CT]P
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!-("T@>6%N:R!T:&ES(&QI;F4@:6YT;R!T4
XM:&4@36%C<F\@<F5G:7-T97(*;6%P($T@("`B;7DD"B(*(CT]/3T]/3T]/3T]<
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T*(B!%("T@9&5L971E('1O('1H92!E;F0@;V8@=&AE(&QI;F4*\
XM;6%P($4@("!D)`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]&
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@6"`M('EA;FL@!
XM=&AI<R!W;W)D(&EN=&\@=&AE($UA8W)O(')E9VES=&5R"FUA<"!8("`@(FUY.
XM="`*(@HB/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]W
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/0HB(%0@+2!R97!L86-E('1H:7,@6
XM;&EN92!W:71H('1H92!S=')I;F<@)W,G"FUA<"!4("`@0R]S&PHB"B(]/3T]E
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]"B(@4B`M('!U="!.97AT0VAA<@IM87`@4B`@(")N>
XM<`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]0
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@5B`M(&%D9"!T:&4@;&5T=&5R!
XM("=R)R`H=&AE(')E<&QA8V4@=FD@8V]M;6%N9"D*;6%P(%8@("!A<AL*(@HBP
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]/0HB($H@+2!R97-T;W)E('1H92!C=7)R96YT2
XM(&-H87)A8W1E<@IM87`@2B`@(")C<`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]S
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM"B(@2"`M('EA;FL@=&AI<R!L:6YE(&EN=&\@=&AE('-E8V]N9"!-86-R;R!R/
XM96=I<W1E<@IM87`@2"`@(")R>20*(@HB/3T]/3T]/3T]/3T]/3T]/3T]/3T]-
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/0HBK
XM($8@+2!Y86YK($YE>'1#:&%R("AT:&ES(&UA8W)O(&ES(&-A;&QE9"!F<F]M*
XM('1H92!-86-R;R!R96=I<W1E<BD*;6%P($8@("`B;GEL"B(*(CT]/3T]/3T]D
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T*(B!>("T@<F5P;&%C92!T:&4@8W5R<F5N="!C:&%R86-T,
XM97(@=VET:"!A;B`G6"<*;6%P(%X@("!R6`HB"B(]/3T]/3T]/3T]/3T]/3T]`
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]"B(@64ME1%`@+2!C<F5A=&4@=&AE('-T871E('1A8FQE+"!.97AT0VAA"
XM<B!T86)L92!A;F0@:6YI=&EA;"!S=&%T90HB($YO=&4@=&AA="!Y;W4@:&%V'
XM92!T;R!E<V-A<&4@=&AE(&)A<B!C:&%R86-T97(L('-I;F-E(&ET(&ES('-P6
XM96-I86P@=&\*(B!T:&4@;6%P(&-O;6UA;F0@*&ET(&EN9&EC871E<R!A(&YE8
XM=R!L:6YE*2X*;6%P(%D@("!O<T4Q("!K("!.,2`@("`@("!S13%?(&UM($4RR
XM("`@("`@('-%,A9\(&UM(%,Q("`@("`@('-%,BX@;&P@13$;"FUA<"!+("`@N
XM;W-7,2`@:B`@4S$@("`@("`@<U<Q7R!M;2!7,B`@("`@("!S5S(6?"!M;2!.+
XM,2`@("`@("!S5S(N(&AH(%<Q&PIM87`@92`@(&]S3C$N(&AH(%<Q("`@("`@"
XM('-.,19\(&UM($XR("`@("`@('-.,B`@:R`@3C$@("`@("`@<TXR7R!M;2!%,
XM,1L*;6%P($0@("!O<U,Q+B!L;"!%,2`@("`@("!S4S$6?"!M;2!3,B`@("`@B
XM("!S4S(@(&H@(%,Q("`@("`@('-3,E\@;6T@5S$;"FUA<"!0("`@;VY%,2!K0
XM1B!N13(@;$8@;E<Q($<D2D8@;E<R(&A&(&Y.,2!H1B!N3C(@:T8@;E,Q(&Q&1
X/(&Y3,B!')$I&(`U%,1L*V
X``
Xend
Xsize 12165
END_OF_FILE
if test 17071 -ne `wc -c <'vim/macros/maze/maze.mac.uue'`; then
    echo shar: \"'vim/macros/maze/maze.mac.uue'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/maze.mac.uue'
fi
if test -f 'vim/src/buffers.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/buffers.c'\"
else
echo shar: Extracting \"'vim/src/buffers.c'\" \(17483 characters\)
sed "s/^X//" >'vim/src/buffers.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * buffers.c
X *
X * manipulations with redo buffer and stuff buffer
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
X
X/*
X * structure used to store one block of the stuff/redo/macro buffers
X */
Xstruct bufblock
X{
X		struct bufblock *b_next;		/* pointer to next bufblock */
X		u_char			b_str[1];		/* contents (actually longer) */
X};
X
X#define MINIMAL_SIZE 20 				/* minimal size for b_str */
X
X/*
X * header used for the stuff buffer and the redo buffer
X */
Xstruct buffheader
X{
X		struct bufblock bh_first;		/* first (dummy) block of list */
X		struct bufblock *bh_curr;		/* bufblock for appending */
X		int 			bh_index;		/* index for reading */
X		int 			bh_space;		/* space in bh_curr for appending */
X};
X
Xstatic struct buffheader stuffbuff = {{NULL, {NUL}}, NULL, 0, 0};
Xstatic struct buffheader redobuff = {{NULL, {NUL}}, NULL, 0, 0};
Xstatic struct buffheader recordbuff = {{NULL, {NUL}}, NULL, 0, 0};
X
X	/*
X	 * when block_redo is TRUE redo buffer will not be changed
X	 * used by edit() to repeat insertions and 'V' command for redoing
X	 */
Xstatic int		block_redo = FALSE;
X
Xstruct mapblock
X{
X	struct mapblock *m_next;		/* next mapblock */
X	char			*m_keys;		/* mapped from */
X	char			*m_str; 		/* mapped to */
X	int 			 m_mode;		/* valid mode */
X	int				 m_noremap;		/* no re-mapping for this one */
X};
X
X/* variables used by vgetorpeek() and flush_buffers */
X#define MAXMAPLEN 10	/* maximum length of key sequence to be mapped */
Xstatic char		typeahead[MAXMAPLEN + 2];
Xstatic int		typelen = 0;	/* number of characters in typeahead[] */
Xstatic char		*mapstr = NULL;	/* mapped characters */
Xstatic int		maplen = 0;		/* number of characters in mapstr */
X
Xstatic void		free_buff __ARGS((struct buffheader *));
Xstatic void		add_buff __ARGS((struct buffheader *, char *));
Xstatic void		add_num_buff __ARGS((struct buffheader *, long));
Xstatic u_char	read_stuff __ARGS((int));
Xstatic int		start_stuff __ARGS((void));
Xstatic int		read_redo __ARGS((int));
Xstatic u_char	vgetorpeek __ARGS((int));
Xstatic void		showmap __ARGS((struct mapblock *));
X
X/*
X * free and clear a buffer
X */
X	static void
Xfree_buff(buf)
X	struct buffheader *buf;
X{
X		register struct bufblock *p, *np;
X
X		for (p = buf->bh_first.b_next; p != NULL; p = np)
X		{
X				np = p->b_next;
X				free((char *)p);
X		}
X		buf->bh_first.b_next = NULL;
X}
X
X/*
X * return the contents of a buffer as a single string
X */
X	u_char *
Xget_bufcont(buffer)
X	struct buffheader *buffer;
X{
X		unsigned		count = 0;
X		u_char			*p = NULL;
X		struct bufblock	*bp;
X
X/* compute the total length of the string */
X		for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
X				count += strlen((char *)bp->b_str);
X
X		if (count != 0 && (p = (u_char *)alloc(count + 1)) != NULL)
X		{
X				*p = NUL;
X				for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
X						strcat((char *)p, (char *)bp->b_str);
X		}
X		return (p);
X}
X
X/*
X * return the contents of the record buffer as a single string
X *	and clear the record buffer
X */
X	u_char *
Xget_recorded()
X{
X		u_char *p;
X
X		p = get_bufcont(&recordbuff);
X		free_buff(&recordbuff);
X		return (p);
X}
X
X/*
X * return the contents of the redo buffer as a single string
X */
X	u_char *
Xget_inserted()
X{
X		return(get_bufcont(&redobuff));
X}
X
X/*
X * add string "s" after the current block of buffer "buf"
X */
X	static void
Xadd_buff(buf, s)
X	register struct buffheader	*buf;
X	char						*s;
X{
X		struct bufblock *p;
X		int 			n;
X		int 			len;
X
X		if ((n = strlen(s)) == 0)		/* don't add empty strings */
X				return;
X
X		if (buf->bh_first.b_next == NULL)		/* first add to list */
X		{
X				buf->bh_space = 0;
X				buf->bh_curr = &(buf->bh_first);
X		}
X		else if (buf->bh_curr == NULL)	/* buffer has already been read */
X		{
X				emsg("Add to read buffer");
X				return;
X		}
X		else if (buf->bh_index != 0)
X				strcpy((char *)buf->bh_first.b_next->b_str, (char *)buf->bh_first.b_next->b_str + buf->bh_index);
X		buf->bh_index = 0;
X
X		if (buf->bh_space >= n)
X		{
X				strcat((char *)buf->bh_curr->b_str, s);
X				buf->bh_space -= n;
X		}
X		else
X		{
X				if (n < MINIMAL_SIZE)
X						len = MINIMAL_SIZE;
X				else
X						len = n;
X				p = (struct bufblock *)alloc((unsigned)(sizeof(struct bufblock) + len));
X				if (p == NULL)
X						return; /* no space, just forget it */
X				buf->bh_space = len - n;
X				strcpy((char *)p->b_str, s);
X
X				p->b_next = buf->bh_curr->b_next;
X				buf->bh_curr->b_next = p;
X				buf->bh_curr = p;
X		}
X		return;
X}
X
X	static void
Xadd_num_buff(buf, n)
X	struct buffheader *buf;
X	long 			  n;
X{
X		char	number[32];
X
X		sprintf(number, "%ld", n);
X		add_buff(buf, number);
X}
X
X/*
X * get one character from the stuff buffer
X * If advance == TRUE go to the next char.
X */
X	static u_char
Xread_stuff(advance)
X	int			advance;
X{
X		register u_char c;
X		register struct bufblock *curr;
X
X
X		if (stuffbuff.bh_first.b_next == NULL)	/* buffer is empty */
X			return NUL;
X
X		curr = stuffbuff.bh_first.b_next;
X		c = curr->b_str[stuffbuff.bh_index];
X
X		if (advance)
X		{
X			if (curr->b_str[++stuffbuff.bh_index] == NUL)
X			{
X				stuffbuff.bh_first.b_next = curr->b_next;
X				free((char *)curr);
X				stuffbuff.bh_index = 0;
X			}
X		}
X		return c;
X}
X
X/*
X * prepare stuff buffer for reading (if it contains something)
X */
X	static int
Xstart_stuff()
X{
X	if (stuffbuff.bh_first.b_next == NULL)
X		return FALSE;
X	stuffbuff.bh_curr = &(stuffbuff.bh_first);
X	stuffbuff.bh_space = 0;
X	return TRUE;
X}
X
X/*
X * check if the stuff buffer is empty
X */
X	int
Xstuff_empty()
X{
X	if (stuffbuff.bh_first.b_next == NULL)
X		return TRUE;
X	return FALSE;
X}
X
X/*
X * remove all typeahead characters (used in case of an error).
X */
X	void
Xflush_buffers()
X{
X	start_stuff();
X	while (read_stuff(TRUE) != NUL)
X		;
X	typelen = 0;
X	maplen = 0;
X	if (mapstr)
X		*mapstr = 0;
X}
X
X	void
XResetBuffers()
X{
X	if (!block_redo)
X		free_buff(&redobuff);
X}
X
X	void
XAppendToRedobuff(s)
X	char		   *s;
X{
X	if (!block_redo)
X		add_buff(&redobuff, s);
X}
X
X	void
XAppendNumberToRedobuff(n)
X	long 			n;
X{
X	if (!block_redo)
X		add_num_buff(&redobuff, n);
X}
X
X	void
XstuffReadbuff(s)
X	char		   *s;
X{
X	add_buff(&stuffbuff, s);
X}
X
X	void
XstuffnumReadbuff(n)
X	long	n;
X{
X	add_num_buff(&stuffbuff, n);
X}
X
X/*
X * Read a character from the redo buffer.
X * The redo buffer is left as it is.
X */
X	static int
Xread_redo(init)
X	int			init;
X{
X	static struct bufblock	*bp;
X	static u_char			*p;
X	int						c;
X
X	if (init)
X	{
X		if ((bp = redobuff.bh_first.b_next) == NULL)
X			return TRUE;
X		p = bp->b_str;
X		return FALSE;
X	}
X	if ((c = *p) != NUL)
X	{
X		if (*++p == NUL && bp->b_next != NULL)
X		{
X			bp = bp->b_next;
X			p = bp->b_str;
X		}
X	}
X	return c;
X}
X
X/*
X * copy the rest of the redo buffer into the stuff buffer (could be done faster)
X */
X	void
Xcopy_redo()
X{
X	register int c;
X
X	while ((c = read_redo(FALSE)) != NUL)
X		stuffReadbuff(mkstr(c));
X}
X
Xextern int redo_Quote_busy;		/* this is in normal.c */
X
X/*
X * Stuff the redo buffer into the stuffbuff.
X * Insert the redo count into the command.
X */
X	int
Xstart_redo(count)
X	long count;
X{
X		register int c;
X
X		if (read_redo(TRUE))	/* init the pointers; return if nothing to redo */
X				return FALSE;
X
X		c = read_redo(FALSE);
X
X/* copy the buffer name, if present */
X		if (c == '"')
X		{
X				add_buff(&stuffbuff, "\"");
X				c = read_redo(FALSE);
X
X		/* if a numbered buffer is used, increment the number */
X				if (c >= '1' && c < '9')
X						++c;
X				add_buff(&stuffbuff, mkstr(c));
X				c = read_redo(FALSE);
X		}
X
X		if (c == 'q')	/* redo Quoting */
X		{
X			Quote = Curpos;
X			redo_Quote_busy = TRUE;
X			c = read_redo(FALSE);
X		}
X
X/* try to enter the count (in place of a previous count) */
X		if (count)
X		{
X				while (isdigit(c))		/* skip "old" count */
X						c = read_redo(FALSE);
X				add_num_buff(&stuffbuff, count);
X		}
X
X/* copy from the redo buffer into the stuff buffer */
X		add_buff(&stuffbuff, mkstr(c));
X		copy_redo();
X		return TRUE;
X}
X
X/*
X * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing the redo buffer
X * into the stuffbuff.
X */
X	int
Xstart_redo_ins()
X{
X		register u_char c;
X
X		if (read_redo(TRUE))
X				return FALSE;
X		start_stuff();
X
X/* skip the count and the command character */
X		while ((c = read_redo(FALSE)) != NUL)
X		{
X			c = toupper(c);
X			if (strchr("AIRO", c) != NULL)
X			{
X				if (c == 'O')
X					stuffReadbuff(NL_STR);
X				break;
X			}
X		}
X
X/* copy the typed text from the redo buffer into the stuff buffer */
X		copy_redo();
X		block_redo = TRUE;
X		return TRUE;
X}
X
X	void
Xset_redo_ins()
X{
X		block_redo = TRUE;
X}
X
X	void
Xstop_redo_ins()
X{
X		block_redo = FALSE;
X}
X
Xstruct mapblock maplist = {NULL, NULL, NULL}; /* first dummy entry in maplist */
X
X/*
X * insert a string in front of the map-buffer (for '@' command and vgetorpeek)
X */
X	int
Xins_mapbuf(str)
X	char *str;
X{
X	register char *s;
X	register int newlen;
X
X	newlen = maplen + strlen(str) + 1;
X	if (newlen < 0)				/* string is getting too long */
X	{
X		emsg(e_toocompl);		/* also calls flush_buffers */
X		setcursor();
X		return -1;
X	}
X	s = alloc(newlen);
X	if (s == NULL)
X		return -1;
X	strcpy(s, str);
X	if (mapstr)
X	{
X		strcat(s, mapstr);
X		free(mapstr);
X	}
X	mapstr = s;
X	maplen = strlen(mapstr);
X	return 0;
X}
X
Xextern int arrow_used;		/* this is in edit.c */
X
X/*
X * get a character: 1. from the stuffbuffer
X *					2. from the user
X *
X * KeyTyped is set to TRUE in the case the user typed the key.
X * If advance is TRUE, we really get the character. Otherwise we just look
X * whether there is a character available.
X */
X	static u_char
Xvgetorpeek(advance)
X	int		advance;
X{
X	register int	c;
X	int				n = 0;		/* init for GCC */
X	char			*str;
X	int				len;
X	struct mapblock *mp;
X	int				mode = State;
X	static int		nomapping = 0;		/* number of characters that should
X											not be mapped */
X	int				timedout = FALSE;	/* waited for more than 1 second
X												for mapping to complete */
X	int				mapdepth = 0;		/* check for recursive mapping */
X
X	if (mode == REPLACE || mode == CMDLINE)
X		mode = INSERT;			/* treat replace mode just like insert mode */
X	else if (mode == NORMAL_BUSY)
X		mode = NORMAL;
X
X	start_stuff();
X	do
X	{
X		c = read_stuff(advance);
X		if (c != NUL)
X			KeyTyped = FALSE;
X		else
X		{
X			/*
X			 * Loop until we either find a matching mapped key, or we
X			 * are sure that it is not a mapped key.
X			 * We do this first for mapstr and then for typeahead.
X			 * If a mapped key sequence is found we go back to mapstr to
X			 * try re-mapping.
X			 */
X			if (maplen)		/* first try mapstr */
X			{
X				str = mapstr;
X				len = maplen;
X			}
X			else			/* no mapped chars, try typeahead[] */
X			{
X				str = typeahead;
X				len = typelen;
X			}
X
X			for (;;)		/* loop until we got a character */
X			{
X				breakcheck();				/* check for CTRL-C */
X				if (got_int)
X				{
X					typelen = 0;			/* flush all typeahead */
X					maplen = 0;
X					len = 0;
X				}
X				else if (len > 0)	/* see if we have a mapped key sequence */
X				{
X					/*
X					 * walk through the maplist until we find an
X					 * entry that matches (if not timed out).
X					 */
X					mp = NULL;
X					if (!timedout && (str != mapstr || (p_remap && nomapping == 0)))
X					{
X						for (mp = maplist.m_next; mp; mp = mp->m_next)
X						{
X							if (mp->m_mode != mode)
X								continue;
X							n = strlen(mp->m_keys);
X							if (!strncmp(mp->m_keys, str, (size_t)(n > len ? len : n)))
X								break;
X						}
X					}
X					if (mp == NULL || (str == mapstr && n > len))
X					{								/* no match found */
X						c = str[0] & 255;
X						if (str == mapstr)
X							KeyTyped = FALSE;
X						else
X							KeyTyped = TRUE;
X						if (advance)
X						{
X							strncpy(&str[0], &str[1], (size_t)len);
X							if (str == mapstr)
X								--maplen;
X							else
X								--typelen;
X							if (nomapping)
X								--nomapping;
X						}
X						break;
X					}
X					if (n <= len)	/* complete match */
X					{
X							/* remove the mapped keys */
X						len -= n;
X						strncpy(&str[0], &str[n], (size_t)(len + 1));
X						if (str == mapstr)
X							maplen = len;
X						else
X							typelen = len;
X
X						/*
X						 * Put the replacement string in front of mapstr.
X						 * The depth check catches ":map x y" and ":map y x".
X						 */
X						if (++mapdepth == 1000)
X						{
X							emsg("recursive mapping");
X							setcursor();
X							maplen = 0;
X							c = -1;
X							break;
X						}
X						if (ins_mapbuf(mp->m_str) < 0)
X						{
X							c = -1;
X							break;
X						}
X						if (mp->m_noremap)
X							nomapping += strlen(mp->m_str);
X						str = mapstr;
X						len = maplen;
X						continue;
X					}
X				}
X											/* inchar() will reset got_int */
X				c = inchar(!advance, len == 0 || !p_timeout);
X				if (c <= NUL || !advance)	/* no character available or async */
X				{
X					if (!advance)
X						break;
X					if (len)				/* timed out */
X					{
X						timedout = TRUE;
X						continue;
X					}
X				}
X				else
X				{
X					typeahead[typelen++] = c;
X					updatescript(c);
X					if (Recording)
X						add_buff(&recordbuff, mkstr(c));
X
X							/* do not sync in insert mode, unless cursor key has
X							 * been used */
X					if (mode != INSERT || arrow_used)		
X						u_sync();
X				}
X				len = typelen;
X				str = typeahead;
X			}
X		}
X	} while (c < 0 || (advance && c == NUL));
X						/* if advance is FALSE don't loop on NULs */
X
X	return (u_char) c;
X}
X
X	u_char
Xvgetc()
X{
X	return (vgetorpeek(TRUE));
X}
X
X	u_char
Xvpeekc()
X{
X	return (vgetorpeek(FALSE));
X}
X
X/*
X * unmap[!] {lhs}			: remove key mapping for {lhs}
X * map[!]					: show all key mappings
X * map[!] {lhs}				: show key mapping for {lhs}
X * map[!] {lhs} {rhs}		: set key mapping for {lhs} to {rhs}
X * noremap[!] {lhs} {rhs}	: same, but no remapping for {rhs}
X *
X * maptype == 1 for unmap command, 2 for noremap command.
X * arg is pointer to any arguments.
X * mode is INSERT if [!] is present.
X * 
X * Return 0 for success
X *		  1 for invalid arguments
X *		  2 for no match
X *		  3 for ambiguety
X *		  4 for out of mem
X */
X	int
Xdomap(maptype, keys, mode)
X	int		maptype;
X	char	*keys;
X	int		mode;
X{
X		struct mapblock		*mp, *mprev;
X		char				*arg;
X		char				*p;
X		int					n = 0;			/* init for GCC */
X		int					len = 0;		/* init for GCC */
X		char				*newstr;
X		int					hasarg;
X
X/*
X * find end of keys and remove CTRL-Vs in it
X */
X		p = keys;
X		while (*p && *p != ' ' && *p != '\t')
X		{
X			if (*p == Ctrl('V') && p[1] != NUL)
X				strcpy(p, p + 1);			/* remove CTRL-V */
X			++p;
X		}
X		if (*p != NUL)
X			*p++ = NUL;
X		skipspace(&p);
X		hasarg = (*p != NUL);
X		arg = p;
X/*
X * remove CTRL-Vs from argument
X */
X		while (*p)
X		{
X			if (*p == Ctrl('V') && p[1] != NUL)
X				strcpy(p, p + 1);			/* remove CTRL-V */
X			++p;
X		}
X
X/*
X * check arguments and translate function keys
X */
X		if (*keys != NUL)
X		{
X				if (maptype == 1 && hasarg)			/* unmap has no arguments */
X					return 1;
X				if (*keys == '#' && isdigit(*(keys + 1)))	/* function key */
X				{
X					if (*++keys == '0')
X						*(u_char *)keys = K_F10;
X					else
X						*keys += K_F1 - '1';
X				}
X				len = strlen(keys);
X				if (len > MAXMAPLEN)			/* maximum lenght of 10 chars */
X					return 2;
X		}
X
X/*
X * Find an entry in the maplist that matches.
X */
X#ifdef AMIGA
X		if (*keys == NUL || (maptype != 1 && !hasarg))
X			settmode(0);				/* set cooked mode so output can be halted */
X#endif
X		for (mp = maplist.m_next, mprev = &maplist; mp; mprev = mp, mp = mp->m_next)
X		{
X			if (mp->m_mode != mode)
X				continue;
X			n = strlen(mp->m_keys);
X			if (*keys == NUL)
X				showmap(mp);
X			else if (!strncmp(mp->m_keys, keys, (size_t)(n < len ? n : len)))
X			{
X				if (maptype != 1 && !hasarg)
X					showmap(mp);
X				else
X					break;
X			}
X		}
X		if (*keys == NUL || (maptype != 1 && !hasarg))
X		{
X#ifdef AMIGA
X				settmode(1);
X#endif
X				wait_return(TRUE);
X				return 0;				/* listing finished */
X		}
X
X		if (mp == NULL) 		/* new entry or nothing to remove */
X		{
X				if (maptype == 1)
X						return 2;		/* no match */
X
X				/* allocate a new entry for the maplist */
X				mp = (struct mapblock *)alloc((unsigned)sizeof(struct mapblock));
X				if (mp == NULL)
X						return 4;		/* no mem */
X				mp->m_keys = strsave(keys);
X				mp->m_str = strsave(arg);
X				if (mp->m_keys == NULL || mp->m_str == NULL)
X				{
X						free(mp->m_keys);
X						free(mp->m_str);
X						free(mp);
X						return 4;		/* no mem */
X				}
X				mp->m_noremap = maptype;
X
X				/* add the new entry in front of the maplist */
X				mp->m_next = maplist.m_next;
X				mp->m_mode = mode;
X				maplist.m_next = mp;
X				return 0;				/* added OK */
X		}
X		if (n != len)
X			return 3;					/* ambigious */
X
X		if (maptype == 1)
X		{
X				free(mp->m_keys);
X				free(mp->m_str);
X				mprev->m_next = mp->m_next;
X				free(mp);
X				return 0;				/* removed OK */
X		}
X
X/*
X * replace existing entry
X */
X		newstr = strsave(arg);
X		if (newstr == NULL)
X				return 4;				/* no mem */
X		free(mp->m_str);
X		mp->m_str = newstr;
X		mp->m_noremap = maptype;
X
X		return 0;						/* replaced OK */
X}
X
X	static void
Xshowmap(mp)
X	struct mapblock *mp;
X{
X	int len;
X
X	len = outtrans(mp->m_keys, -1);	/* get length of what we have written */
X	while (len < MAXMAPLEN)
X	{
X		outchar(' ');				/* padd with blanks */
X		++len;
X	}
X	if (mp->m_noremap)
X		outchar('*');
X	else
X		outchar(' ');
X	outtrans(mp->m_str, -1);
X	outchar('\n');
X	flushbuf();
X}
X
X/*
X * Write map commands for the current mapping to an .exrc file.
X * Return 1 on error.
X */
X	int
Xmakemap(fd)
X	FILE *fd;
X{
X	struct mapblock *mp;
X
X	for (mp = maplist.m_next; mp; mp = mp->m_next)
X	{
X		if (fprintf(fd, "map%c %s %s\n", mp->m_mode == INSERT ? '!' : ' ',
X									mp->m_keys, mp->m_str) < 0)
X			return 1;
X	}
X	return 0;
X}
END_OF_FILE
if test 17483 -ne `wc -c <'vim/src/buffers.c'`; then
    echo shar: \"'vim/src/buffers.c'\" unpacked with wrong size!
fi
# end of 'vim/src/buffers.c'
fi
if test -f 'vim/src/fileio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/fileio.c'\"
else
echo shar: Extracting \"'vim/src/fileio.c'\" \(17623 characters\)
sed "s/^X//" >'vim/src/fileio.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * fileio.c: read from and write to a file
X */
X
X/*
X * special feature of this version: NUL characters in the file are
X * replaced by newline characters in memory. This allows us to edit
X * binary files!
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X#include "fcntl.h"
X
X#ifdef LATTICE
X# include <proto/dos.h>		/* for Lock() and UnLock() */
X#endif
X
X#define BUFSIZE 4096
Xstatic void do_mlines __ARGS((void));
X
X	void
Xfilemess(name, s)
X	char		*name;
X	char		*s;
X{
X	smsg("\"%s\" %s", ((name == NULL) ? "" : name), s);
X}
X
X/*
X * Read lines from file 'fname' into the buffer after line 'from'.
X *
X * 1. We allocate blocks with m_blockalloc, as big as possible.
X * 2. Each block is filled with characters from the file with a single read().
X * 3. The lines are inserted in the buffer with appendline().
X *
X * (caller must check that fname != NULL)
X */
X	int
Xreadfile(fname, from, newfile)
X	char		   *fname;
X	linenr_t		from;
X	int				newfile;
X{
X#ifdef UNIX
X	int 				fd = -1;
X#else
X	int 				fd;
X#endif
X	register u_char 	c;
X	register linenr_t	lnum = from;
X	register u_char 	*ptr = NULL;			/* pointer into read buffer */
X	register u_char		*buffer = NULL;			/* read buffer */
X	register long		size;
X	long				filesize;
X#define UNKNOWN		0x0fffffff					/* file size is unknown */
X	linenr_t			linecnt = line_count;
X	int					incomplete = FALSE; 	/* was the last line incomplete? */
X	int 				error = 0;				/* read errors encountered */
X	long				linerest = 0;			/* remaining characters in line */
X	long				filerest;				/* remaining characters in file */
X
X	if (bufempty())		/* special case: buffer has no lines */
X		linecnt = 0;
X
X	if (
X#ifdef UNIX
X		!(getperm(fname) & 0200) ||				/* root's way to check RO */
X#endif
X		(fd = open(fname, O_RDWR)) == -1)		/* cannot open r/w */
X	{
X		if ((fd = open(fname, O_RDONLY)) == -1) /* cannot open at all */
X		{
X			if (newfile)
X				filemess(fname, "[New File]");
X
X#ifdef MSDOS		/* the screen may be messed up by the "insert disk
X							in drive b: and hit return" message */
X			updateScreen(CLEAR);
X#endif
X			return TRUE;
X		}
X		if (newfile)							/* set file readonly */
X			p_ro = TRUE;
X	}
X	else if (newfile && !readonlymode)		/* set file not readonly */
X		p_ro = FALSE;
X
X	if (
X#ifdef MSDOS
X	/* the CR characters disappear in read(), so the file lenght is wrong */
X		p_tx == TRUE ||
X#endif
X			(filesize = lseek(fd, 0L, 2)) < 0)	/* get length of file */
X		filesize = UNKNOWN;
X	lseek(fd, 0L, 0);
X
X	filemess(fname, "");
X
X	for (filerest = filesize; !error && !got_int && filerest != 0; breakcheck())
X	{
X		/*
X		 * We allocate as much space for the file as we can get, plus
X		 * space for the old line, one NUL in front and one NUL at the tail.
X		 * The amount is limited by the fact that read() only can read
X		 * upto max_unsigned characters.
X		 * If we don't know the file size, just get one Kbyte.
X		 */
X		if (filesize >= UNKNOWN)
X			size = 1024;
X		else if (filerest > 0xff00L)
X			size = 0xff00L;
X		else if (filerest < 10)
X			size = 10;
X		else
X			size = filerest;
X
X		for ( ; size >= 10; size /= 2)
X		{
X			if ((buffer = (u_char *)m_blockalloc((u_long)(size + linerest + 4), FALSE))
X						!= NULL)
X				break;
X		}
X		if (buffer == NULL)
X		{
X			emsg(e_outofmem);
X			error = 1;
X			break;
X		}
X		buffer[0] = NUL;	/* make sure there is a NUL in front of the first line */
X		++buffer;
X		if (linerest)		/* copy characters from the previous buffer */
X		{
X			ptr -= linerest;
X			memmove((char *)buffer, (char *)ptr, linerest);
X			memset((char *)ptr, 1, linerest);	/* fill with non-NULs */
X			ptr[linerest - 1] = NUL;			/* add a NUL on the end */
X			free_line((char *)ptr);				/* free the space we don't use */
X		}
X		ptr = buffer + linerest;
X		
X		if ((size = (unsigned)read(fd, (char *)ptr, (size_t)size)) <= 0)
X		{
X			error = 2;
X			break;
X		}
X		if (filesize >= UNKNOWN)			/* if we don't know the file size */
X			filesize += size;				/* .. count the number of characters */
X		else								/* .. otherwise */
X			filerest -= size;				/* .. compute the remaining length */
X
X		/*
X		 * This loop is executed once for every character read.
X		 * Keep it fast!
X		 */
X		--ptr;
X		while (++ptr, --size >= 0)
X		{
X			if ((c = *ptr) != NUL && c != NL)	/* catch most common case */
X				continue;
X			if (c == NUL)
X				*ptr = NL;		/* NULs are replaced by newlines! */
X			else
X			{
X				*ptr = NUL;		/* end of line */
X				if (!appendline(lnum, (char *)buffer))
X				{
X					error = 1;
X					break;
X				}
X				++lnum;
X				buffer = ptr + 1;
X			}
X		}
X		linerest = ptr - buffer;
X	}
X	if (error != 1 && linerest != 0)
X	{
X		/*
X		 * If we get EOF in the middle of a line, note the fact and
X		 * complete the line ourselves.
X		 */
X		incomplete = TRUE;
X		*ptr = NUL;
X		if (!appendline(lnum, (char *)buffer))
X			error = 1;
X	}
X	if (error == 2 && filesize >= UNKNOWN)	/* no error, just EOF encountered */
X	{
X		filesize -= UNKNOWN;
X		error = 0;
X	}
X
X	close(fd);
X
X#ifdef MSDOS		/* the screen may be messed up by the "insert disk
X							in drive b: and hit return" message */
X	updateScreen(CLEAR);
X#endif
X
X	if (got_int)
X	{
X		filemess(fname, e_interr);
X		return FALSE;			/* an interrupt isn't really an error */
X	}
X
X	linecnt = line_count - linecnt;
X	smsg("\"%s\" %s%s%s%ld line%s, %ld character%s",
X			fname,
X			p_ro ? "[readonly] " : "",
X			incomplete ? "[Incomplete last line] " : "",
X			error ? "[READ ERRORS] " : "",
X			(long)linecnt, plural((long)linecnt),
X			filesize, plural(filesize));
X
X	u_clearline();		/* cannot use "U" command after adding lines */
X
X	if (newfile)		/* edit a new file: read mode from lines */
X		do_mlines();
X	if (from < line_count)
X	{
X		Curpos.lnum = from + 1;	/* put cursor at first new line */
X		Curpos.col = 0;
X	}
X
X	return FALSE;
X}
X
X/*
X * writeit - write to file 'fname' lines 'start' through 'end'
X *
X * We do our own buffering here because fwrite() is so slow.
X *
X * If forceit is true, we don't care for errors when attempting backups (jw).
X * In case of an error everything possible is done to restore the original file.
X * But when forceit is TRUE, we risk loosing it.
X */
X	int
Xwriteit(fname, start, end, append, forceit)
X	char			*fname;
X	linenr_t		start, end;
X	int				append;
X	int				forceit;
X{
X	int 				fd;
X	char			   *backup = NULL;
X	register char	   *s;
X	register u_char	   *ptr;
X	register u_char		c;
X	register int		len;
X	register linenr_t	lnum;
X	long				nchars;
X	char				*errmsg = NULL;
X	char				*buffer;
X	long 				perm = -1;			/* file permissions */
X	int					retval = TRUE;
X	int					newfile = FALSE;	/* TRUE if file does not exist yet */
X#ifdef UNIX
X	struct stat			old;
X	int					made_writable = FALSE;	/* 'w' bit has been set */
X#endif
X#ifdef AMIGA
X	BPTR				flock;
X#endif
X
X	if (fname == NULL || *fname == NUL)		/* safety check */
X		return FALSE;
X
X	/*
X	 * Disallow writing from .exrc and .vimrc in current directory for
X	 * security reasons.
X	 */
X	if (secure)
X	{
X		secure = 2;
X		emsg(e_curdir);
X		return FALSE;
X	}
X
X	filemess(fname, "");		/* show that we are busy */
X
X	buffer = alloc(BUFSIZE);
X	if (buffer == NULL)
X		return FALSE;
X
X#ifdef UNIX
X		/* get information about original file (if there is one) */
X	old.st_dev = old.st_ino = 0;
X	if (stat(fname, &old))
X		newfile = TRUE;
X	else
X		perm = old.st_mode;
X/*
X * If we are not appending, the file exists, and the 'writebackup' or
X * 'backup' option is set, try to make a backup copy of the file.
X */
X	if (!append && perm >= 0 && (p_wb || p_bk) &&
X					(fd = open(fname, O_RDONLY)) >= 0)
X	{
X		int				bfd, buflen, wlen;
X		char			buf[BUFSIZE + 1], *wp;
X		int				some_error = FALSE;
X		struct stat		new;
X
X		new.st_dev = new.st_ino = 0;
X
X		/*
X		 * Unix semantics has it, that we may have a writable file, 
X		 * that cannot be recreated with a simple open(..., O_CREATE, ) e.g:
X		 *  - the directory is not writable, 
X		 *  - the file may be a symbolic link, 
X		 *  - the file may belong to another user/group, etc.
X		 *
X		 * For these reasons, the existing writable file must be truncated and
X		 * reused. Creation of a backup COPY will be attempted.
X		 */
X		if ((backup = modname(fname, ".bak")) == NULL)
X		{
X			some_error = TRUE;
X			goto nobackup;
X		}			
X		stat(backup, &new);
X		if (new.st_dev == old.st_dev && new.st_ino == old.st_ino)
X		{
X			/*
X			 * may happen when modname gave the same file back.
X			 * E.g. silly link, or filename-length reached.
X			 * If we don't check here, we either ruin the file when
X			 * copying or erase it after writing. jw.
X			 */
X			errmsg = "Invalid backup file";
X			free(backup);
X			backup = NULL;	/* there is no backup file to delete */
X			goto nobackup;
X		}
X		remove(backup);		/* remove old backup, if present */
X		if ((bfd = open(backup, O_WRONLY | O_CREAT, 0666)) < 0)
X		{
X			char *home;
X
X			/* 
X			 * oops, no write/create permission here?
X			 * try again in p_bdir directory. 
X			 */
X			for (wp = fname + strlen(fname); wp >= fname; wp--)
X				if (*wp == '/')
X					break;
X			++wp;
X			if (p_bdir[0] == '~' && p_bdir[1] == '/' &&
X							(home = (char *)vimgetenv("HOME")) != NULL)
X				sprintf(buf, "%s/%s/%s", home, p_bdir + 2, wp);
X			else
X				sprintf(buf, "%s/%s", p_bdir, wp);
X			free(backup);
X			if ((backup = modname(buf, ".bak")) == NULL)
X			{
X				some_error = TRUE;
X				goto nobackup;
X			}
X			stat(backup, &new);
X			if (new.st_dev == old.st_dev && new.st_ino == old.st_ino)
X			{
X				errmsg = "Invalid backup file";
X				free(backup);
X				backup = NULL;	/* there is no backup file to delete */
X				goto nobackup;
X			}
X			remove(backup);
X			if ((bfd = open(backup, O_WRONLY | O_CREAT, 0666)) < 0)
X			{
X				free(backup);
X				backup = NULL;	/* there is no backup file to delete */
X				errmsg = "Can't make backup file";
X				goto nobackup;
X			}
X		}
X		/* set file protection same as original file, but strip s-bit */
X		setperm(backup, perm & 0777);
X
X		/* copy the file. */
X		while ((buflen = read(fd, buf, BUFSIZE)) > 0)
X		{
X			wp = buf;
X			do
X			{
X				if ((wlen = write(bfd, wp, buflen)) <= 0)
X				{
X					errmsg = "Can't write to backup file";
X					goto writeerr;
X				}
X				wp += wlen;
X				buflen -= wlen;
X			}
X			while (buflen > 0);
X		}
Xwriteerr:
X		close(bfd);
X		if (buflen < 0)
X			errmsg = "Can't read file for backup";
Xnobackup:
X		close(fd);
X	/* ignore errors when forceit is TRUE */
X		if ((some_error || errmsg) && !forceit)
X		{
X			retval = FALSE;
X			goto fail;
X		}
X		errmsg = NULL;
X	}
X		/* if forceit and the file was read-only: make it writable */
X	if (forceit && (old.st_uid == getuid()) && perm >= 0 && !(perm & 0200))
X 	{
X		perm |= 0200;	
X		made_writable = TRUE;
X		setperm(fname, perm);
X 	}
X#else /* UNIX */
X
X/*
X * If we are not appending, the file exists, and the 'writebackup' or
X * 'backup' option is set, make a backup.
X * Do not make any backup, if "writebackup" and "backup" are 
X * both switched off. This helps when editing large files on
X * almost-full disks. (jw)
X */
X	perm = getperm(fname);
X	if (perm < 0)
X		newfile = TRUE;
X	if (!append && perm >= 0 && (p_wb || p_bk))
X	{
X		/*
X		 * Form the backup file name - change path/fo.o.h to path/fo.o.h.bak
X		 */
X		backup = modname(fname, ".bak");
X		if (backup == NULL)
X		{
X			if (!forceit)
X				goto fail;
X		}
X		else
X		{
X			/*
X			 * Delete any existing backup and move the current version to the backup.
X			 * For safety, we don't remove the backup until the write has finished
X			 * successfully. And if the 'backup' option is set, leave it around.
X			 */
X#ifdef AMIGA
X			/*
X			 * With MSDOS-compatible filesystems (crossdos, messydos) it is
X			 * possible that the name of the backup file is the same as the
X			 * original file. To avoid the chance of accidently deleting the
X			 * original file (horror!) we lock it during the remove.
X			 * This should not happen with ":w", because startscript() should
X			 * detect this problem and set thisfile_sn, causing modname to
X			 * return a correct ".bak" filename. This problem does exist with
X			 * ":w filename", but then the original file will be somewhere else
X			 * so the backup isn't really important. If autoscripting is off
X			 * the rename may fail.
X			 */
X			flock = Lock((UBYTE *)fname, (long)ACCESS_READ);
X#endif
X			remove(backup);
X#ifdef AMIGA
X			if (flock)
X				UnLock(flock);
X#endif
X			len = rename(fname, backup);
X			if (len != 0)
X			{
X				if (forceit)
X				{
X					free(backup);	/* don't do the rename below */
X					backup = NULL;
X				}
X				else
X				{
X					errmsg = "Can't make backup file";
X					goto fail;
X				}
X			}
X		}
X	}
X#endif /* UNIX */
X
X		/* 
X		 * We may try to open the file twice: If we can't write to the
X		 * file and forceit is TRUE we delete the existing file and try to create
X		 * a new one. If this still fails we may have lost the original file!
X		 * (this may happen when the user reached his quotum for number of files).
X		 */
X	while ((fd = open(fname, O_WRONLY | (append ? O_APPEND : (O_CREAT | O_TRUNC)), 0666)) < 0)
X 	{
X		/*
X		 * A forced write will try to create a new file if the old one is
X		 * still readonly. This may also happen when the directory is
X		 * read-only. In that case the remove() will fail.
X		 */
X		if (!errmsg)
X		{
X			errmsg = "Can't open file for writing";
X			if (forceit)
X			{
X#ifdef UNIX
X				/* we write to the file, thus it should be marked
X													writable after all */
X				perm |= 0200;		
X				made_writable = TRUE;
X				if (old.st_uid != getuid() || old.st_gid != getgid())
X					perm &= 0777;
X#endif /* UNIX */
X				remove(fname);
X				continue;
X			}
X		}
X/*
X * If we failed to open the file, we don't need a backup. Throw it away.
X * If we moved or removed the original file try to put the backup in its place.
X */
X 		if (backup)
X		{
X#ifdef UNIX
X			struct stat st;
X
X			/*
X			 * There is a small chance that we removed the original, try
X			 * to move the copy in its place.
X			 * This won't work if the backup is in another file system!
X			 * In that case we leave the copy around.
X			 */
X			if (stat(fname, &st) < 0)	/* file does not exist */
X				rename(backup, fname);	/* put the copy in its place */
X			if (stat(fname, &st) >= 0)	/* original file does exist */
X				remove(backup);			/* throw away the copy */
X#else
X 			rename(backup, fname);	/* try to put the original file back */
X#endif
X		}
X 		goto fail;
X 	}
X	errmsg = NULL;
X
X	len = 0;
X	s = buffer;
X	nchars = 0;
X	for (lnum = start; lnum <= end; ++lnum)
X	{
X		/*
X		 * The next loop is done once for each character written.
X		 * Keep it fast!
X		 */
X		ptr = (u_char *)nr2ptr(lnum) - 1;
X		while ((c = *++ptr) != NUL)
X		{
X			if (c == NL)
X				*s = NUL;		/* replace newlines with NULs */
X			else
X				*s = c;
X			++s;
X			if (++len != BUFSIZE)
X				continue;
X			if (write(fd, buffer, (size_t)BUFSIZE) == -1)
X			{
X				end = 0;				/* write error: break loop */
X				break;
X			}
X			nchars += BUFSIZE;
X			s = buffer;
X			len = 0;
X		}
X		*s = NL;
X		++s;
X		if (++len == BUFSIZE)
X		{
X			if (write(fd, buffer, (size_t)BUFSIZE) == -1)
X				end = 0;				/* write error: break loop */
X			nchars += BUFSIZE;
X			s = buffer;
X			len = 0;
X		}
X	}
X	if (len)
X	{
X		if (write(fd, buffer, (size_t)len) == -1)
X			end = 0;				/* write error */
X		nchars += len;
X	}
X
X	if (close(fd) != 0)
X	{
X		errmsg = "Close failed";
X		goto fail;
X	}
X#ifdef UNIX
X	if (made_writable)
X		perm &= ~0200;			/* reset 'w' bit for security reasons */
X#endif
X	if (perm >= 0)
X		setperm(fname, perm);	/* set permissions of new file same as old file */
X
X	if (end == 0)
X	{
X		errmsg = "write error (file system full?)";
X		goto fail;
X	}
X
X#ifdef MSDOS		/* the screen may be messed up by the "insert disk
X							in drive b: and hit return" message */
X	updateScreen(CLEAR);
X#endif
X
X	lnum -= start;		/* compute number of written lines */
X	smsg("\"%s\"%s %ld line%s, %ld character%s",
X			fname,
X			newfile ? " [New File]" : " ",
X			(long)lnum, plural((long)lnum),
X			nchars, plural(nchars));
X	if (start == 1 && end == line_count)		/* when written everything */
X	{
X		UNCHANGED;
X		startscript();		/* re-start auto script file */
X	}
X
X	/*
X	 * Remove the backup unless 'backup' option is set
X	 */
X	if (!p_bk && backup != NULL && remove(backup) != 0)
X		emsg("Can't delete backup file");
X	
X	goto nofail;
X
Xfail:
X#ifdef MSDOS		/* the screen may be messed up by the "insert disk
X							in drive b: and hit return" message */
X	updateScreen(CLEAR);
X#endif
Xnofail:
X
X	free((char *) backup);
X	free(buffer);
X
X	if (errmsg != NULL)
X	{
X		filemess(fname, errmsg);
X		retval = FALSE;
X	}
X	return retval;
X}
X
X/*
X * do_mlines() - process mode lines for the current file
X *
X * Returns immediately if the "ml" parameter isn't set.
X */
Xstatic void 	chk_mline __ARGS((linenr_t));
X
X	static void
Xdo_mlines()
X{
X		linenr_t		lnum;
X		int 			nmlines;
X
X		if ((nmlines = p_ml) == 0)
X				return;
X
X		for (lnum = 1; lnum <= line_count && lnum <= nmlines; ++lnum)
X				chk_mline(lnum);
X
X		for (lnum = line_count; lnum > 0 && lnum > nmlines &&
X								lnum > line_count - nmlines; --lnum)
X				chk_mline(lnum);
X}
X
X/*
X * chk_mline() - check a single line for a mode string
X */
X	static void
Xchk_mline(lnum)
X	linenr_t lnum;
X{
X	register char	*s;
X	register char	*e;
X	char			*cs;			/* local copy of any modeline found */
X	char			prev;
X	int				end;
X
X	prev = ' ';
X	for (s = nr2ptr(lnum); *s != NUL; ++s)
X	{
X		if (isspace(prev) && (strncmp(s, "vi:", (size_t)3) == 0 || strncmp(s, "ex:", (size_t)3) == 0))
X		{
X			s += 3;
X			end = FALSE;
X			s = cs = strsave(s);
X			if (cs == NULL)
X				break;
X			while (end == FALSE)
X			{
X				while (*s == ' ' || *s == TAB)
X					++s;
X				if (*s == NUL)
X					break;
X				for (e = s; *e != ':' && *e != NUL; ++e)
X					;
X				if (*e == NUL)
X					end = TRUE;
X				*e = NUL;
X				doset(s);
X				s = e + 1;
X			}
X			free(cs);
X			break;
X		}
X		prev = *s;
X	}
X}
END_OF_FILE
if test 17623 -ne `wc -c <'vim/src/fileio.c'`; then
    echo shar: \"'vim/src/fileio.c'\" unpacked with wrong size!
fi
# end of 'vim/src/fileio.c'
fi
echo shar: End of archive 9 \(of 23\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 23 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-------------8<----------------8<----------------8<---------------8<--------
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595450 | whatever will be accepted.

exit 0 # Just in case...
