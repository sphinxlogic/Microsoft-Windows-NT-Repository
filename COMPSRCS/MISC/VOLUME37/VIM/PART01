Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v37i001:  vim - Vi IMitation editor v1.27, Part01/24
Message-ID: <csm-v37i001=vim.121529@sparky.IMD.Sterling.COM>
X-Md4-Signature: c705eea8f9e7574012aa19f97280578a
Date: Fri, 23 Apr 1993 17:17:16 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 37, Issue 1
Archive-name: vim/part01
Environment: UNIX, AMIGA, MS-DOS

Vim - Vi IMitation. A clone of the UNIX text editor Vi. Very useful for 
editing programs and other plain ASCII text. Full Vi compatibility (except Q 
command) and includes most Ex commands.

Extra features above Vi: Multilevel undo, command line history, improved 
command line editing, command typeahead display, command to display yank 
buffers, possibility to edit binary files, file name stack, support for Manx 
QuickFix, shows current file name in window title, on-line help, etc. 

Version 1.27, update to 1.24. Most important changes:
- 'ignorecase' did not work with UNIX, fixed
- ":s/a/b/ did not work with MSDOS, fixed
- all other reported bugs fixed
- portability for UNIX improved for linux, hpux, pyramid, SCO Xenix, etc.
- improved security for .exrc and .vimrc in current directory
- a few Ex commands added and a few compatibility problems fixed
- added 'compatible' option to switch off a few vi incompatible extentions
- Vim now works on more terminals (e.g. Sun cmdtool)
- with Amiga DOS 2.0 arp.library is no longer needed
- help file is now displayed using terminal codes
- support for locale() with UNIX

Portability: Runs on Amiga, MSDOS and several UNIX versions.

Distribution:
comp.sources.misc: Sources and documentation (shell archive)
comp.binaries.amiga: AMIGA binaries and documentation (lha archive)
comp.binaries.ibm.pc: MSDOS binaries and documentation (lha archive)
(Sorry to post the documentation three times. It is the only way to guarantee 
that everybody gets it. Otherwise people will start asking me for it).

The shell archive contains a few uuencoded files and the reference.doc file
is split up in three. To get the original files back you can use the
"execute.me" script.

Vim is public domain. You are encouraged to put it on ftp servers. It has
already been put on "Aminet". I will ask Fred Fish to put it on one of his
disks. 

-------------8<----------------8<----------------8<---------------8<--------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 23)."
# Contents:  vim vim/.exrc vim/doc vim/doc/unix.doc vim/doc/vim132.uue
#   vim/execute.me vim/macros vim/macros/center.uue vim/macros/hanoi
#   vim/macros/hanoi/click.me vim/macros/hanoi/hanoi.mac.uue
#   vim/macros/hanoi/poster vim/macros/maze vim/macros/maze/README
#   vim/macros/maze/makefile vim/macros/maze/maze.c
#   vim/macros/maze/maze_5.78 vim/macros/maze/maze_ansi.c
#   vim/macros/maze/poster vim/macros/readme vim/src vim/src/addcr.c
#   vim/src/ascii.h vim/src/debug.h vim/src/keymap.h vim/src/macros.h
#   vim/src/mark.h vim/src/proto vim/src/proto.h
#   vim/src/proto/alloc.pro vim/src/proto/amiga.pro
#   vim/src/proto/buffers.pro vim/src/proto/charset.pro
#   vim/src/proto/cmdline.pro vim/src/proto/csearch.pro
#   vim/src/proto/digraph.pro vim/src/proto/edit.pro
#   vim/src/proto/fileio.pro vim/src/proto/help.pro
#   vim/src/proto/linefunc.pro vim/src/proto/main.pro
#   vim/src/proto/mark.pro vim/src/proto/message.pro
#   vim/src/proto/misccmds.pro vim/src/proto/normal.pro
#   vim/src/proto/ops.pro vim/src/proto/param.pro
#   vim/src/proto/quickfix.pro vim/src/proto/regexp.pro
#   vim/src/proto/regsub.pro vim/src/proto/screen.pro
#   vim/src/proto/script.pro vim/src/proto/search.pro
#   vim/src/proto/storage.pro vim/src/proto/tag.pro
#   vim/src/proto/term.pro vim/src/proto/termlib.pro
#   vim/src/proto/undo.pro vim/src/ptx_stdlib.h vim/src/regexp.h
#   vim/src/regmagic.h vim/src/termlib.fix.uue vim/src/vim.prj
#   vim/src/vimresp vim/todo vim/tutor vim/tutor/Readme
#   vim/tutor/poster
# Wrapped by mool@oce-rd2 on Mon Apr 19 15:50:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'vim' ; then
    echo shar: Creating directory \"'vim'\"
    mkdir 'vim'
fi
if test -f 'vim/.exrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/.exrc'\"
else
echo shar: Extracting \"'vim/.exrc'\" \(35 characters\)
sed "s/^X//" >'vim/.exrc' <<'END_OF_FILE'
Xset ai bs=2 shell=csh nojs nord ru
END_OF_FILE
if test 35 -ne `wc -c <'vim/.exrc'`; then
    echo shar: \"'vim/.exrc'\" unpacked with wrong size!
fi
# end of 'vim/.exrc'
fi
if test ! -d 'vim/doc' ; then
    echo shar: Creating directory \"'vim/doc'\"
    mkdir 'vim/doc'
fi
if test -f 'vim/doc/unix.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/unix.doc'\"
else
echo shar: Extracting \"'vim/doc/unix.doc'\" \(1300 characters\)
sed "s/^X//" >'vim/doc/unix.doc' <<'END_OF_FILE'
XThis file contains the particularities for the UNIX version of Vim.
X
XThe default help filename is "/usr/local/doc/vim.hlp"
XThe files "$HOME/.vimrc" and "$HOME/.exrc" are used instead of "s:.vimrc" and 
X"s:.exrc". Additionally "/usr/etc/.vimrc" is used first.
X
XTemporary files (for filtering) are put in "/tmp".
X
XIn some rare cases the terminal may have a problem with CTRL-Q or CTRL-S. To 
Xget around this you can map another key to CTRL-Q and CTRL-S, and remap 
XCTRL-Q and CTRL-S to nothing. You could use CTRL-W and CTRL-X:
X	:noremap! ^W ^V017
X	:noremap! ^X ^V019
X	:noremap! ^V017 ^V^V
X	:noremap! ^V019 ^V^V
X	:noremap ^W ^V017
X	:noremap ^X ^V019
X	:noremap ^V017 ^V^V
X	:noremap ^V019 ^V^V
X(^V is the single character CTRL-V. Do not use the '^' character. You have to 
Xtype CTRL-V twice to get one. What is shown above is what you have to type, 
Xit will look different on the screen or in the .exrc file.)
X
XWith wildcard expansion you can use <~> (home directory) and <$> 
X(environment variable).
X
XIf terminal updating is slow, try resetting the 'showcommand' and the 
X'ruler' option (e.g. in a shell window in suntools).
X
XThe file Vim132 is a shell script that can be used to put Vim in 132 column 
Xmode on a vt100 and lookalikes.
X
XThe *.info files are for the Amiga. You don't need them with unix.
END_OF_FILE
if test 1300 -ne `wc -c <'vim/doc/unix.doc'`; then
    echo shar: \"'vim/doc/unix.doc'\" unpacked with wrong size!
fi
# end of 'vim/doc/unix.doc'
fi
if test -f 'vim/doc/vim132.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/vim132.uue'\"
else
echo shar: Extracting \"'vim/doc/vim132.uue'\" \(372 characters\)
sed "s/^X//" >'vim/doc/vim132.uue' <<'END_OF_FILE'
X
Xbegin 644 vim132
XM(R$@+V)I;B]C<V@*(R!3:&5L;"!S8W)I<'0@9F]R('5S92!W:71H(%5.25@*1
XM(R!3=&%R=',@=7`@5FEM('=I=&@@=&AE('1E<FUI;F%L(&EN(#$S,B!C;VQU.
XM;6X@;6]D90HC($]N;'D@=V]R:W,@;VX@5E0M,3`P('1E<FUI;F%L<R!A;F0@,
XM;&]O:V%L:6ME<PHC"G-E="!O;&1T97)M/21T97)M"F5C:&\@(AM;/S-H(@IS[
XM971E;G8@5$5232!V=#$P,"UW(`IV:6T@)"H*<V5T('1E<FT])&]L9'1E<FT*M
X-96-H;R`B&UL_,VPB"C$P"
X``
Xend
Xsize 238
END_OF_FILE
if test 372 -ne `wc -c <'vim/doc/vim132.uue'`; then
    echo shar: \"'vim/doc/vim132.uue'\" unpacked with wrong size!
fi
# end of 'vim/doc/vim132.uue'
fi
if test -f 'vim/execute.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/execute.me'\"
else
echo shar: Extracting \"'vim/execute.me'\" \(599 characters\)
sed "s/^X//" >'vim/execute.me' <<'END_OF_FILE'
X#execute this script while standing in the 'vim' directory
Xcd macros
Xuudecode center.uue
Xrm center.uue
Xcd maze
Xuudecode maze.mac.uue
Xrm maze.mac.uue
Xcd ../hanoi
Xuudecode hanoi.mac.uue
Xrm hanoi.mac.uue
Xcd ../../src
Xuudecode digraph.c.uue
Xuudecode tcconfig.tc.uue
Xuudecode termlib.fix.uue
Xrm digraph.c.uue tcconfig.tc.uue termlib.fix.uue
Xcd ../doc
Xuudecode vim.hlp.uue
Xuudecode digraph.doc.uue
Xuudecode vim.man.uue
Xuudecode vim132.uue
Xrm vim.hlp.uue digraph.doc.uue vim.man.uue vim132.uue
Xcat reference.doc1 reference.doc2 reference.doc3 >reference.doc
Xrm reference.doc1 reference.doc2 reference.doc3
END_OF_FILE
if test 599 -ne `wc -c <'vim/execute.me'`; then
    echo shar: \"'vim/execute.me'\" unpacked with wrong size!
fi
chmod +x 'vim/execute.me'
# end of 'vim/execute.me'
fi
if test ! -d 'vim/macros' ; then
    echo shar: Creating directory \"'vim/macros'\"
    mkdir 'vim/macros'
fi
if test -f 'vim/macros/center.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/center.uue'\"
else
echo shar: Extracting \"'vim/macros/center.uue'\" \(274 characters\)
sed "s/^X//" >'vim/macros/center.uue' <<'END_OF_FILE'
X
Xbegin 644 center
XM(E1H:7,@;6%C<F\@8V5N=&5R<R!A(&QI;F4@:6X@86X@.#`@8VAA<F%C=&5R$
XM('-P86-E+@HB0V%R969U;#H@;&EN97,@;&]N9V5R('1H86X@.#`@8VAA<F%CY
XM=&5R<R!W:6QL(&)E('1R=6YC871E9`IM87`@.V-E(#IS+UY;(`E=*B\O#21MS
XB83@Q82`;.#$6?$1@86QL9#`Z<R\@("\@+V<-)'`-:R1X"EY;+
X``
Xend
Xsize 169
END_OF_FILE
if test 274 -ne `wc -c <'vim/macros/center.uue'`; then
    echo shar: \"'vim/macros/center.uue'\" unpacked with wrong size!
fi
# end of 'vim/macros/center.uue'
fi
if test ! -d 'vim/macros/hanoi' ; then
    echo shar: Creating directory \"'vim/macros/hanoi'\"
    mkdir 'vim/macros/hanoi'
fi
if test -f 'vim/macros/hanoi/click.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/click.me'\"
else
echo shar: Extracting \"'vim/macros/hanoi/click.me'\" \(255 characters\)
sed "s/^X//" >'vim/macros/hanoi/click.me' <<'END_OF_FILE'
X
X
XSee Vim solve the towers of Hanoi!
X
XInstructions:
X   type ":so hanoi.mac<RETURN>" to load the macros
X   type "g" to start it
X
Xand watch it go.
X
X     to quit type ":q!<RETURN>"
Xto interrupt type CTRL-C
X
X(This text will disappear as soon as you type "g")
END_OF_FILE
if test 255 -ne `wc -c <'vim/macros/hanoi/click.me'`; then
    echo shar: \"'vim/macros/hanoi/click.me'\" unpacked with wrong size!
fi
# end of 'vim/macros/hanoi/click.me'
fi
if test -f 'vim/macros/hanoi/hanoi.mac.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/hanoi.mac.uue'\"
else
echo shar: Extracting \"'vim/macros/hanoi/hanoi.mac.uue'\" \(1577 characters\)
sed "s/^X//" >'vim/macros/hanoi/hanoi.mac.uue' <<'END_OF_FILE'
X
Xbegin 644 hanoi.mac
XM<V5T(')E;6%P"G-E="!N;W1E<G-E"G-E="!W<F%P<V-A;@HB('1O('-E="!T[
XM:&4@:&5I9VAT(&]F('1H92!T;W=E<BP@8VAA;F=E('1H92!D:6=I="!I;B!T<
XM:&4@9F]L;&]W:6YG"B(@='=O(&QI;F5S('1O('1H92!H96EG:'0@>6]U('=A1
XM;G0@*'-E;&5C="!F<F]M(#$@=&\@.2D*;6%P('0@-PIM87`A('0@-PIM87`@#
XM3"`Q1R]T#5@O7C`-)%`Q1THD06XD0D=#,&4D6#!%,$8D6"]4#4!F#4!H#21!$
XM,4=*0&8P;"18;B1050IM87`@9R!)3`H*;6%P($H@+UXP6UYT72HD#0IM87`@A
XM6"!X"FUA<"!0('`*;6%P(%4@3`IM87`@02`B9GEL"FUA<"!"(")H>6P*;6%P8
XM($,@(F9P"FUA<"!E(")F>3)L"FUA<"!%(")H<`IM87`@1B`B:'DR;`H*(B!I\
XM;FET:6%L:7-A=&EO;G,Z"B(@2TT)8VQE86YU<"!B=69F97(*(B!9"6-R96%T1
XM92!T;W=E<B!O9B!D97-I<F5D(&AE:6=H=`HB($Y/40EC;W!Y(&ET(&%N9"!I;
XM;G-T97(@82!4"B(@3D\)8V]P>2!T:&ES(&]N90HB(%,)8VAA;F=E(&QA<W0@*
XM8VAA<B!I;G1O(&$@)`HB(%()8VAA;F=E(&QA<W0@8VAA<B!I;B!P<F5V:6]U]
XM<R!L:6YE(&EN=&\@82!N"B(@5`EI;G-E<G0@='=O(&QI;F5S(&-O;G1A:6YI,
XM;F<@82!Z97)O"B(@5@EA9&0@82!L87-T(&QI;F4@8V]N=&%I;FEN9R!A(&)A5
XM8VMS;&%S:`IM87`@22!+35E.3U%.3U-K4E16"@HB8W)E871E(&5M<'1Y(&QI>
XM;F4*;6%P($L@,4=O&PH*(F1E;&5T92!T;R!E;F0@;V8@9FEL90IM87`@32!D9
XM1PH*(GEA;FL@;VYE(&QI;F4*;6%P($X@>7D*"B)P=70*;6%P($\@<`H*(F1EW
XM;&5T92!M;W)E('1H86X@:&5I9VAT+6]F+71O=V5R(&-H87)A8W1E<G,*;6%P)
XM('$@=&QL1`H*(F-R96%T92!A('1O=V5R(&]F(&1E<VER960@:&5I9VAT"FUAC
XM<"!9(&\P,3(S-#4V-S@Y6ALP<0H*(FEN<V5R="!A(%0@:6X@8V]L=6UN(#$*;
XM;6%P(%$@,&E4&PH*(G-U8G-T:71U=&4@;&%S="!C:&%R86-T97(@=VET:"!AG
XM(&X*;6%P(%(@)')N"@HB<W5B<W1I='5T92!L87-T(&-H87)A8W1E<B!W:71H[
XM(&$@)`IM87`@4R`D<B0*"B)I;G-E<G0@='=O(&QI;F5S(&-O;G1A:6YI;F<@$
XM82!Z97)O"FUA<"!4(&MO,`TP#0T;"@HB861D(&$@8F%C:W-L87-H(&%T('1HV
X192!E;F0*;6%P(%8@1V\O&PHP4
X``
Xend
Xsize 1097
END_OF_FILE
if test 1577 -ne `wc -c <'vim/macros/hanoi/hanoi.mac.uue'`; then
    echo shar: \"'vim/macros/hanoi/hanoi.mac.uue'\" unpacked with wrong size!
fi
# end of 'vim/macros/hanoi/hanoi.mac.uue'
fi
if test -f 'vim/macros/hanoi/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/poster'\"
else
echo shar: Extracting \"'vim/macros/hanoi/poster'\" \(1259 characters\)
sed "s/^X//" >'vim/macros/hanoi/poster' <<'END_OF_FILE'
XArticle 2913 of alt.sources:
XPath: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!cluster!swift!softway!otc!gregm
XFrom: gregm@otc.otca.oz.au (Greg McFarlane)
XNewsgroups: comp.sources.d,alt.sources,comp.editors
XSubject: VI SOLVES HANOI
XMessage-ID: <2323@otc.otca.oz>
XDate: 19 Feb 91 01:32:14 GMT
XSender: news@otc.otca.oz
XReply-To: gregm@otc.otca.oz.au (Greg McFarlane)
XOrganization: OTC Development Unit, Australia
XLines: 80
XXref: oce-rd1 comp.sources.d:5702 alt.sources:2913 comp.editors:2313
X
XSubmitted-by: gregm@otc.otca.oz.au
XArchive-name: hanoi.vi.macros/part01
X
XEveryone seems to be writing stupid Tower of Hanoi programs.
XWell, here is the stupidest of them all: the hanoi solving vi macros.
X
XSave this article, unshar it, and run uudecode on hanoi.vi.macros.uu.
XThis will give you the macro file hanoi.vi.macros.
XThen run vi (with no file: just type "vi") and type:
X	:so hanoi.vi.macros
X	g
Xand watch it go.
X
XThe default height of the tower is 7 but can be easily changed by editing
Xthe macro file.
X
XThe disks aren't actually shown in this version, only numbers representing
Xeach disk, but I believe it is possible to write some macros to show the
Xdisks moving about as well. Any takers?
X
X(For maze solving macros, see alt.sources or comp.editors)
X
XGreg
END_OF_FILE
if test 1259 -ne `wc -c <'vim/macros/hanoi/poster'`; then
    echo shar: \"'vim/macros/hanoi/poster'\" unpacked with wrong size!
fi
# end of 'vim/macros/hanoi/poster'
fi
if test ! -d 'vim/macros/maze' ; then
    echo shar: Creating directory \"'vim/macros/maze'\"
    mkdir 'vim/macros/maze'
fi
if test -f 'vim/macros/maze/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/README'\"
else
echo shar: Extracting \"'vim/macros/maze/README'\" \(1666 characters\)
sed "s/^X//" >'vim/macros/maze/README' <<'END_OF_FILE'
XTo prove that you can do anything in vi, I wrote a couple of macros that
Xallows vi to solve mazes. It will solve any maze produced by maze.c
Xthat was posted to the net recently.
X
XJust follow this recipe and SEE FOR YOURSELF.
X	1. run uudecode on the file "maze.vi.macros.uu" to
X		produce the file "maze.vi.macros"
X	(If you can't wait to see the action, jump to step 4)
X	2. compile maze.c with "cc -o maze maze.c"
X	3. run maze > maze.out and input a small number (for example 10 if
X		you are on a fast machine, 3-5 if slow) which
X		is the size of the maze to produce
X	4. edit the maze (vi maze.out)
X	5. include the macros with the vi command:
X		:so maze.vi.macros
X	6. type the letter "g" (for "go") and watch vi solve the maze
X	7. when vi solves the maze, you will see why it lies
X	8. now look at maze.vi.macros and all will be revealed
X
XTested on a sparc, a sun and a pyramid (although maze.c will not compile
Xon the pyramid).
X
XAnyone who can't get the maze.c file to compile, get a new compiler,
Xtry maze.ansi.c which was also posted to the net.
XIf you can get it to compile but the maze comes out looking like a fence
Xand not a maze and you are using SysV or DOS replace the "27" on the
Xlast line of maze.c by "11"
XThanks to John Tromp (tromp@piring.cwi.nl) for maze.c.
XThanks to antonyc@nntp-server.caltech.edu (Bill T. Cat) for maze.ansi.c.
X
XAny donations should be in unmarked small denomination bills :^)=.
X
X                   ACSnet:  gregm@otc.otca.oz.au
XGreg McFarlane       UUCP:  {uunet,mcvax}!otc.otca.oz.au!gregm
X|||| OTC ||         Snail:  OTC R&D GPO Box 7000, Sydney 2001, Australia
X                    Phone:  +61 2 287 3139    Fax: +61 2 287 3299
X
X
END_OF_FILE
if test 1666 -ne `wc -c <'vim/macros/maze/README'`; then
    echo shar: \"'vim/macros/maze/README'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/README'
fi
if test -f 'vim/macros/maze/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/makefile'\"
else
echo shar: Extracting \"'vim/macros/maze/makefile'\" \(104 characters\)
sed "s/^X//" >'vim/macros/maze/makefile' <<'END_OF_FILE'
X#On the amiga with manx C 5.0 we have to use maze.ansi.c
X
Xmaze: maze.ansi.o
X	ln maze.ansi.o -o maze -lc
END_OF_FILE
if test 104 -ne `wc -c <'vim/macros/maze/makefile'`; then
    echo shar: \"'vim/macros/maze/makefile'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/makefile'
fi
if test -f 'vim/macros/maze/maze.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze.c'\"
else
echo shar: Extracting \"'vim/macros/maze/maze.c'\" \(441 characters\)
sed "s/^X//" >'vim/macros/maze/maze.c' <<'END_OF_FILE'
Xchar*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);
X--            E;             J[              E]             =T
X[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
X)    ,   A    =              39              ,C             --
X)    ;   Z    ||    printf   (M   ))M[Z]=Z[A-(E   =A[J-Z])&&!C
X&    A   ==             T[                                  A]
X|6<<27<rand()||!C&!Z?J[T[E]=T[A]]=E,J[T[A]=A-Z]=A,"_.":" |"];}
END_OF_FILE
if test 441 -ne `wc -c <'vim/macros/maze/maze.c'`; then
    echo shar: \"'vim/macros/maze/maze.c'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/maze.c'
fi
if test -f 'vim/macros/maze/maze_5.78' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze_5.78'\"
else
echo shar: Extracting \"'vim/macros/maze/maze_5.78'\" \(758 characters\)
sed "s/^X//" >'vim/macros/maze/maze_5.78' <<'END_OF_FILE'
X._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
X| ._| . . ._| | |_._._. . ._|_._._._._. ._|_. ._|_._. ._| . ._|_. | . ._._. |
X| ._|_| |_. | | | | ._._|_._|_._. . |_. | | | ._._| |_._._| | ._. ._| . . |_|
X|_._._._. | ._|_. ._._._. | | ._. |_._. . | ._._| |_. | ._._._. |_. | |_|_| |
X| | . |_._| . ._._._| ._._. ._._| | | |_| . | |_. . ._|_| ._._. |_._|_| . | |
X|_._|_._._._|_._._._|_|_._._._|_._|_._._._|_._._._|_._._._|_._._._._._._|_._|
X
XSee Vim solve a maze!
X
X   type ":so maze<DOT>mac<RETURN>" to load the macros
X   		(replace <DOT> by a real dot; can't type it here because the
X		macros use the last dot in the file as the goal in the maze)
X   type "g" to start
X
Xto interrupt type "<CTRL-C>"
X     to quit type ":q!<RETURN>"
X
END_OF_FILE
if test 758 -ne `wc -c <'vim/macros/maze/maze_5.78'`; then
    echo shar: \"'vim/macros/maze/maze_5.78'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/maze_5.78'
fi
if test -f 'vim/macros/maze/maze_ansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze_ansi.c'\"
else
echo shar: Extracting \"'vim/macros/maze/maze_ansi.c'\" \(441 characters\)
sed "s/^X//" >'vim/macros/maze/maze_ansi.c' <<'END_OF_FILE'
Xchar*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&
XC)            ;--            E;J             [E            ]=M
X[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
X)    ,   A    =              39              ,C             --
X)    ;   Z    ||    printf   (T   ))T[Z]=Z[A-(E   =A[J-Z])&&!C
X&    A   ==             M[                                  A]
X|6<<11<rand()||!C&!Z?J[M[E]=M[A]]=E,J[M[A]=A-Z]=A,"_.":" |"];}
END_OF_FILE
if test 441 -ne `wc -c <'vim/macros/maze/maze_ansi.c'`; then
    echo shar: \"'vim/macros/maze/maze_ansi.c'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/maze_ansi.c'
fi
if test -f 'vim/macros/maze/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/poster'\"
else
echo shar: Extracting \"'vim/macros/maze/poster'\" \(1562 characters\)
sed "s/^X//" >'vim/macros/maze/poster' <<'END_OF_FILE'
XArticle 2846 of alt.sources:
XPath: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!otc!gregm
XFrom: gregm@otc.otca.oz.au (Greg McFarlane)
XNewsgroups: alt.sources
XSubject: VI SOLVES MAZE (commented macros)
XMessage-ID: <2289@otc.otca.oz>
XDate: 10 Feb 91 23:31:02 GMT
XSender: news@otc.otca.oz
XReply-To: gregm@otc.otca.oz.au (Greg McFarlane)
XOrganization: OTC Development Unit, Australia
XLines: 464
X
XSubmitted-by: gregm@otc.otca.oz.au
XArchive-name: maze_solving_vi_macros
X
XA real working model. See it walk the maze in front of your very own eyes.
X
XTo prove that you can do anything in vi, I wrote a couple of macros that
Xallows vi to solve mazes. It will solve any maze produced by maze.c
Xthat was posted to the alt.sources last month. (Maze.c is also included
Xin this posting as well as an example of its output.)
X
XThe uncommented version of the macros was sent to alt.sources last month.
XHowever, so many people mailed me requesting the commented version of the
Xmacros that I decided to post it. I have made some modifications to the
Xoriginal macros to make them easier to follow and also after I learnt
Xthat you can escape the special meaning of '|' in macros by using '^V|'.
X
XSave this article and unshar it. Then read maze.README.
X
XAfter studying these macros, anyone who cannot write an emacs emulator
Xin vi macros should just curl up and :q!.
X
XComing soon to a newsgroup near you: "Vi macros solve Tower of Hanoi",
Xand a repost of the original "Turing Machine implemented in Vi macros"
X
XAnyone who has a version of these macros for edlin or nroff, please post.
END_OF_FILE
if test 1562 -ne `wc -c <'vim/macros/maze/poster'`; then
    echo shar: \"'vim/macros/maze/poster'\" unpacked with wrong size!
fi
# end of 'vim/macros/maze/poster'
fi
if test -f 'vim/macros/readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/readme'\"
else
echo shar: Extracting \"'vim/macros/readme'\" \(271 characters\)
sed "s/^X//" >'vim/macros/readme' <<'END_OF_FILE'
XThe macros in these directories can be used to test Vim for vi compatibility.
XThey have been written for vi to show its unlimited possibilities.
X
XHANOI are macros that solve the tower of hanoi problem.
XMAZE  are macros that solve a maze (amazing!).
X
XThey are unmodified.
END_OF_FILE
if test 271 -ne `wc -c <'vim/macros/readme'`; then
    echo shar: \"'vim/macros/readme'\" unpacked with wrong size!
fi
# end of 'vim/macros/readme'
fi
if test ! -d 'vim/src' ; then
    echo shar: Creating directory \"'vim/src'\"
    mkdir 'vim/src'
fi
if test -f 'vim/src/addcr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/addcr.c'\"
else
echo shar: Extracting \"'vim/src/addcr.c'\" \(413 characters\)
sed "s/^X//" >'vim/src/addcr.c' <<'END_OF_FILE'
X/*
X * This program, when compiled with Turbo-C, will make <LF> into <CR><LF>
X */
X
X#include <stdio.h>
X
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{
X	char buffer[1024];
X	int	len;
X
X	while ((len = fread(buffer, 1, 1024, stdin)) > 0)
X		fwrite(buffer, 1, len, stdout);
X	if (ferror(stdin))
X		fprintf(stderr, "Error while reading\n");
X	if (ferror(stdout))
X		fprintf(stderr, "Error while writing\n");
X}
END_OF_FILE
if test 413 -ne `wc -c <'vim/src/addcr.c'`; then
    echo shar: \"'vim/src/addcr.c'\" unpacked with wrong size!
fi
# end of 'vim/src/addcr.c'
fi
if test -f 'vim/src/ascii.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ascii.h'\"
else
echo shar: Extracting \"'vim/src/ascii.h'\" \(766 characters\)
sed "s/^X//" >'vim/src/ascii.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Definitions of various common control characters
X */
X
X#define NUL 					'\000'
X#define BS						'\010'
X#define BS_STR					"\010"
X#define TAB 					'\011'
X#define NL						'\012'
X#define NL_STR					"\012"
X#define CR						'\015'
X#define ESC 					'\033'
X#define ESC_STR 				"\033"
X#define DEL 					0x7f
X#define CSI 					0x9b
X
X#define Ctrl(x) ((x) & 0x1f)
X
X/*
X * character that separates dir names in a path
X */
X#ifdef MSDOS
X# define PATHSEP '\\'
X# define PATHSEPSTR "\\"
X#else
X# define PATHSEP '/'
X# define PATHSEPSTR "/"
X#endif
END_OF_FILE
if test 766 -ne `wc -c <'vim/src/ascii.h'`; then
    echo shar: \"'vim/src/ascii.h'\" unpacked with wrong size!
fi
# end of 'vim/src/ascii.h'
fi
if test -f 'vim/src/debug.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/debug.h'\"
else
echo shar: Extracting \"'vim/src/debug.h'\" \(865 characters\)
sed "s/^X//" >'vim/src/debug.h' <<'END_OF_FILE'
X/*
X * debug.h -- my debug header for just any program.
X * use:
X * place the statement OPENDEBUG("/tmp/programdebug"); inside main.
X * Nothing will happen, unless you compile the source with -DDEBUG.
X * 
X * jw. 13.4.91.
X */
X#ifndef FILE
X# include <stdio.h>
X#endif
X
X#ifdef DEBUG
X#	define debug(x) {fprintf(debugfp,x);fflush(debugfp);}
X#	define debug1(x,a) {fprintf(debugfp,x,a);fflush(debugfp);}
X#	define debug2(x,a,b) {fprintf(debugfp,x,a,b);fflush(debugfp);}
X#	define debug3(x,a,b,c) {fprintf(debugfp,x,a,b,c);fflush(debugfp);}
X#	define OPENDEBUG(file)\
X	if ((debugfp = fopen(file,"w")) == NULL)\
X	{	debugfp = stderr;\
X		debug1("OPENDEBUG: sorry, cannot open '%s'\n", file);\
X		debug("           beware, using stderr!\n");\
X		sleep(3);\
X	}
X#else
X#	define debug(x)
X#	define debug1(x,a)
X#	define debug2(x,a,b)
X#	define debug3(x,a,b,c)
X#	define OPENDEBUG(file)
X#endif
END_OF_FILE
if test 865 -ne `wc -c <'vim/src/debug.h'`; then
    echo shar: \"'vim/src/debug.h'\" unpacked with wrong size!
fi
# end of 'vim/src/debug.h'
fi
if test -f 'vim/src/keymap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/keymap.h'\"
else
echo shar: Extracting \"'vim/src/keymap.h'\" \(1576 characters\)
sed "s/^X//" >'vim/src/keymap.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Keycode definitions for special keys
X *
X * On systems that have any of these keys, the routine 'inchar' in the
X * machine-dependent code should return one of the codes here.
X */
X
X#define K_CCIRCM		0x1e	/* control circumflex */
X
X/*
X * careful: the next entries must be in the same order as the termcap strings
X * in term.h and the numbers must be consecutive (used by inchar()).
X */
X#define K_UARROW		0x80
X#define K_DARROW		0x81
X#define K_LARROW		0x82
X#define K_RARROW		0x83
X#define K_SUARROW		0x84
X#define K_SDARROW		0x85
X#define K_SLARROW		0x86
X#define K_SRARROW		0x87
X
X#define K_F1			0x88	/* function keys */
X#define K_F2			0x89
X#define K_F3			0x8a
X#define K_F4			0x8b
X#define K_F5			0x8c
X#define K_F6			0x8d
X#define K_F7			0x8e
X#define K_F8			0x8f
X#define K_F9			0x90
X#define K_F10			0x91
X
X#define K_SF1			0x92	/* shifted function keys */
X#define K_SF2			0x93
X#define K_SF3			0x94
X#define K_SF4			0x95
X#define K_SF5			0x96
X#define K_SF6			0x97
X#define K_SF7			0x98
X#define K_SF8			0x99
X#define K_SF9			0x9a
X#define K_SF10			0x9b
X
X#define K_HELP			0x9c
X#define K_UNDO			0x9d
X
X/*
X * NULs cannot be in the input string, therefore CTRL-@ is replaced by K_ZERO.
X * K_NUL is used for MSDOS extended keys (same value used in term.h).
X */
X#define K_NUL			0x9e	/* for MSDOS: special key follows */
X#define K_ZERO			0x9f	/* replaces ^@ */
END_OF_FILE
if test 1576 -ne `wc -c <'vim/src/keymap.h'`; then
    echo shar: \"'vim/src/keymap.h'\" unpacked with wrong size!
fi
# end of 'vim/src/keymap.h'
fi
if test -f 'vim/src/macros.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/macros.h'\"
else
echo shar: Extracting \"'vim/src/macros.h'\" \(1055 characters\)
sed "s/^X//" >'vim/src/macros.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * macros.h: macro definitions for often used code
X */
X
X/*
X * pchar(lp, c) - put character 'c' at position 'lp'
X */
X#define pchar(lp, c) (*(nr2ptr((lp).lnum) + (lp).col) = (c))
X
X/*
X * Position comparisons
X */
X#define lt(a, b) (((a).lnum != (b).lnum) \
X				   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
X
X#define ltoreq(a, b) (((a).lnum != (b).lnum) \
X				   ? ((a).lnum < (b).lnum) : ((a).col <= (b).col))
X
X#define equal(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
X
X/*
X * buf1line() - return TRUE if there is only one line in file buffer
X */
X#define buf1line() (line_count == 1)
X
X/*
X * lineempty() - return TRUE if the line is empty
X */
X#define lineempty(p) (*nr2ptr(p) == NUL)
X
X/*
X * bufempty() - return TRUE if the file buffer is empty
X */
X#define bufempty() (buf1line() && lineempty((linenr_t)1))
END_OF_FILE
if test 1055 -ne `wc -c <'vim/src/macros.h'`; then
    echo shar: \"'vim/src/macros.h'\" unpacked with wrong size!
fi
# end of 'vim/src/macros.h'
fi
if test -f 'vim/src/mark.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/mark.h'\"
else
echo shar: Extracting \"'vim/src/mark.h'\" \(546 characters\)
sed "s/^X//" >'vim/src/mark.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * mark.h: definitions shared between tag.c and mark.c 
X */
X
Xstruct mark
X{
X	char		   *ptr;
X	colnr_t 		col;
X};
X
Xstruct filemark
X{
X	struct mark		mark;			/* cursor position */
X	linenr_t		lnum;			/* last known line number */
X	int				fnum;			/* file number */
X};
X
Xchar *fm_getname __ARGS((struct filemark *));
END_OF_FILE
if test 546 -ne `wc -c <'vim/src/mark.h'`; then
    echo shar: \"'vim/src/mark.h'\" unpacked with wrong size!
fi
# end of 'vim/src/mark.h'
fi
if test ! -d 'vim/src/proto' ; then
    echo shar: Creating directory \"'vim/src/proto'\"
    mkdir 'vim/src/proto'
fi
if test -f 'vim/src/proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto.h'\"
else
echo shar: Extracting \"'vim/src/proto.h'\" \(1269 characters\)
sed "s/^X//" >'vim/src/proto.h' <<'END_OF_FILE'
X/*
X * proto.h: include the (automatically generated) function prototypes
X *
X * the proto/xxx.pro files are automatically generated when using Manx/Aztec C.
X * For other compilers you will have to edit them.
X */
X
X#include "regexp.h"		/* for struct regexp */
X
X/*
X * Machine-dependent routines.
X */
X#ifdef AMIGA
X# include "proto/amiga.pro"
X#endif
X#ifdef UNIX
X# include "unix.h"
X#endif
X#ifdef MSDOS
X# include "msdos.h"
X#endif
X
X#include "proto/alloc.pro"
X#include "proto/buffers.pro"
X#include "proto/charset.pro"
X#include "proto/cmdline.pro"
X#include "proto/csearch.pro"
X#include "proto/digraph.pro"
X#include "proto/edit.pro"
X#include "proto/fileio.pro"
X#include "proto/help.pro"
X#include "proto/linefunc.pro"
X#include "proto/main.pro"
X#include "proto/mark.pro"
X
X#ifndef MESSAGE
Xvoid smsg __PARMS((char *, ...));	/* cannot be produced automatically */
X#endif
X#include "proto/message.pro"
X#include "proto/misccmds.pro"
X#include "proto/normal.pro"
X#include "proto/ops.pro"
X#include "proto/param.pro"
X#include "proto/quickfix.pro"
X#include "proto/regexp.pro"
X#include "proto/regsub.pro"
X#include "proto/screen.pro"
X#include "proto/script.pro"
X#include "proto/search.pro"
X#include "proto/storage.pro"
X#include "proto/tag.pro"
X#include "proto/term.pro"
X#include "proto/undo.pro"
END_OF_FILE
if test 1269 -ne `wc -c <'vim/src/proto.h'`; then
    echo shar: \"'vim/src/proto.h'\" unpacked with wrong size!
fi
# end of 'vim/src/proto.h'
fi
if test -f 'vim/src/proto/alloc.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/alloc.pro'\"
else
echo shar: Extracting \"'vim/src/proto/alloc.pro'\" \(300 characters\)
sed "s/^X//" >'vim/src/proto/alloc.pro' <<'END_OF_FILE'
X/* alloc.c */
Xchar *alloc __PARMS((unsigned int size));
Xchar *lalloc __PARMS((unsigned long size, int message));
Xchar *strsave __PARMS((char *string));
Xchar *strnsave __PARMS((char *string, int len));
Xvoid copy_spaces __PARMS((char *ptr, unsigned long count));
Xchar *mkstr __PARMS((unsigned int c));
END_OF_FILE
if test 300 -ne `wc -c <'vim/src/proto/alloc.pro'`; then
    echo shar: \"'vim/src/proto/alloc.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/alloc.pro'
fi
if test -f 'vim/src/proto/amiga.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/amiga.pro'\"
else
echo shar: Extracting \"'vim/src/proto/amiga.pro'\" \(1222 characters\)
sed "s/^X//" >'vim/src/proto/amiga.pro' <<'END_OF_FILE'
X/* amiga.c */
Xvoid win_resize_on __PARMS((void));
Xvoid win_resize_off __PARMS((void));
Xvoid flushbuf __PARMS((void));
Xvoid outchar __PARMS((unsigned int c));
Xint GetChars __PARMS((char *buf, int maxlen, int type));
Xvoid sleep __PARMS((int n));
Xvoid vim_delay __PARMS((void));
Xvoid mch_suspend __PARMS((void));
Xvoid mch_windinit __PARMS((void));
Xvoid check_win __PARMS((int argc, char **argv));
Xvoid fname_case __PARMS((char *name));
Xvoid settitle __PARMS((char *str));
Xvoid resettitle __PARMS((void));
Xint dirname __PARMS((char *buf, int len));
Xint FullName __PARMS((char *fname, char *buf, int len));
Xlong getperm __PARMS((char *name));
Xint setperm __PARMS((char *name, long perm));
Xint isdir __PARMS((char *name));
Xvoid mch_windexit __PARMS((int r));
Xvoid mch_settmode __PARMS((int raw));
Xint mch_get_winsize __PARMS((void));
Xvoid mch_set_winsize __PARMS((void));
Xint call_shell __PARMS((char *cmd, int filter));
Xvoid breakcheck __PARMS((void));
Xlong Chk_Abort __PARMS((void));
Xint ExpandWildCards __PARMS((int num_pat, char **pat, int *num_file, char ***file, int files_only, int list_notfound));
Xvoid FreeWild __PARMS((int num, char **file));
Xint has_wildcard __PARMS((char *p));
Xchar *vimgetenv __PARMS((char *var));
END_OF_FILE
if test 1222 -ne `wc -c <'vim/src/proto/amiga.pro'`; then
    echo shar: \"'vim/src/proto/amiga.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/amiga.pro'
fi
if test -f 'vim/src/proto/buffers.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/buffers.pro'\"
else
echo shar: Extracting \"'vim/src/proto/buffers.pro'\" \(832 characters\)
sed "s/^X//" >'vim/src/proto/buffers.pro' <<'END_OF_FILE'
X/* buffers.c */
Xunsigned char *get_bufcont __PARMS((struct buffheader *buffer));
Xunsigned char *get_recorded __PARMS((void));
Xunsigned char *get_inserted __PARMS((void));
Xint stuff_empty __PARMS((void));
Xvoid flush_buffers __PARMS((void));
Xvoid ResetBuffers __PARMS((void));
Xvoid AppendToRedobuff __PARMS((char *s));
Xvoid AppendNumberToRedobuff __PARMS((long n));
Xvoid stuffReadbuff __PARMS((char *s));
Xvoid stuffnumReadbuff __PARMS((long n));
Xvoid copy_redo __PARMS((void));
Xint start_redo __PARMS((long count));
Xint start_redo_ins __PARMS((void));
Xvoid set_redo_ins __PARMS((void));
Xvoid stop_redo_ins __PARMS((void));
Xint ins_mapbuf __PARMS((char *str));
Xunsigned char vgetc __PARMS((void));
Xunsigned char vpeekc __PARMS((void));
Xint domap __PARMS((int maptype, char *keys, int mode));
Xint makemap __PARMS((struct __stdio *fd));
END_OF_FILE
if test 832 -ne `wc -c <'vim/src/proto/buffers.pro'`; then
    echo shar: \"'vim/src/proto/buffers.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/buffers.pro'
fi
if test -f 'vim/src/proto/charset.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/charset.pro'\"
else
echo shar: Extracting \"'vim/src/proto/charset.pro'\" \(240 characters\)
sed "s/^X//" >'vim/src/proto/charset.pro' <<'END_OF_FILE'
X/* charset.c */
Xchar *transchar __PARMS((unsigned int c));
Xint outtrans __PARMS((char *str, int len));
Xint charsize __PARMS((int c));
Xint strsize __PARMS((char *s));
Xint chartabsize __PARMS((int c, int col));
Xint isidchar __PARMS((int c));
END_OF_FILE
if test 240 -ne `wc -c <'vim/src/proto/charset.pro'`; then
    echo shar: \"'vim/src/proto/charset.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/charset.pro'
fi
if test -f 'vim/src/proto/cmdline.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/cmdline.pro'\"
else
echo shar: Extracting \"'vim/src/proto/cmdline.pro'\" \(487 characters\)
sed "s/^X//" >'vim/src/proto/cmdline.pro' <<'END_OF_FILE'
X/* cmdline.c */
Xint getcmdline __PARMS((int firstc, unsigned char *buff));
Xvoid redrawcmdline __PARMS((void));
Xvoid redrawcmd __PARMS((void));
Xvoid docmdline __PARMS((unsigned char *cmdline));
Xint doarglist __PARMS((char *str));
Xvoid gotocmdline __PARMS((int clr, int firstc));
Xint getfile __PARMS((char *fname, int setpm));
Xint samealtfile __PARMS((int n));
Xint getaltfile __PARMS((int n, long lnum, int setpm));
Xchar *getaltfname __PARMS((int n));
Xint dosource __PARMS((char *fname));
END_OF_FILE
if test 487 -ne `wc -c <'vim/src/proto/cmdline.pro'`; then
    echo shar: \"'vim/src/proto/cmdline.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/cmdline.pro'
fi
if test -f 'vim/src/proto/csearch.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/csearch.pro'\"
else
echo shar: Extracting \"'vim/src/proto/csearch.pro'\" \(158 characters\)
sed "s/^X//" >'vim/src/proto/csearch.pro' <<'END_OF_FILE'
X/* csearch.c */
Xvoid dosub __PARMS((long lp, long up, char *cmd, unsigned char **nextcommand));
Xvoid doglob __PARMS((int type, long lp, long up, char *cmd));
END_OF_FILE
if test 158 -ne `wc -c <'vim/src/proto/csearch.pro'`; then
    echo shar: \"'vim/src/proto/csearch.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/csearch.pro'
fi
if test -f 'vim/src/proto/digraph.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/digraph.pro'\"
else
echo shar: Extracting \"'vim/src/proto/digraph.pro'\" \(137 characters\)
sed "s/^X//" >'vim/src/proto/digraph.pro' <<'END_OF_FILE'
X/* digraph.c */
Xint getdigraph __PARMS((int char1, int char2));
Xvoid putdigraph __PARMS((char *str));
Xvoid listdigraphs __PARMS((void));
END_OF_FILE
if test 137 -ne `wc -c <'vim/src/proto/digraph.pro'`; then
    echo shar: \"'vim/src/proto/digraph.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/digraph.pro'
fi
if test -f 'vim/src/proto/edit.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/edit.pro'\"
else
echo shar: Extracting \"'vim/src/proto/edit.pro'\" \(389 characters\)
sed "s/^X//" >'vim/src/proto/edit.pro' <<'END_OF_FILE'
X/* edit.c */
Xvoid edit __PARMS((long count));
Xint get_literal __PARMS((int *nextc));
Xvoid insertchar __PARMS((unsigned int c));
Xint oneright __PARMS((void));
Xint oneleft __PARMS((void));
Xvoid beginline __PARMS((int flag));
Xint oneup __PARMS((long n));
Xint onedown __PARMS((long n));
Xint onepage __PARMS((int dir, long count));
Xvoid stuff_inserted __PARMS((int c, long count, int no_esc));
END_OF_FILE
if test 389 -ne `wc -c <'vim/src/proto/edit.pro'`; then
    echo shar: \"'vim/src/proto/edit.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/edit.pro'
fi
if test -f 'vim/src/proto/fileio.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/fileio.pro'\"
else
echo shar: Extracting \"'vim/src/proto/fileio.pro'\" \(205 characters\)
sed "s/^X//" >'vim/src/proto/fileio.pro' <<'END_OF_FILE'
X/* fileio.c */
Xvoid filemess __PARMS((char *name, char *s));
Xint readfile __PARMS((char *fname, long from, int newfile));
Xint writeit __PARMS((char *fname, long start, long end, int append, int forceit));
END_OF_FILE
if test 205 -ne `wc -c <'vim/src/proto/fileio.pro'`; then
    echo shar: \"'vim/src/proto/fileio.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/fileio.pro'
fi
if test -f 'vim/src/proto/help.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/help.pro'\"
else
echo shar: Extracting \"'vim/src/proto/help.pro'\" \(72 characters\)
sed "s/^X//" >'vim/src/proto/help.pro' <<'END_OF_FILE'
X/* help.c */
Xvoid help __PARMS((void));
Xint redrawhelp __PARMS((void));
END_OF_FILE
if test 72 -ne `wc -c <'vim/src/proto/help.pro'`; then
    echo shar: \"'vim/src/proto/help.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/help.pro'
fi
if test -f 'vim/src/proto/linefunc.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/linefunc.pro'\"
else
echo shar: Extracting \"'vim/src/proto/linefunc.pro'\" \(306 characters\)
sed "s/^X//" >'vim/src/proto/linefunc.pro' <<'END_OF_FILE'
X/* linefunc.c */
Xvoid coladvance __PARMS((unsigned int wcol));
Xint inc __PARMS((struct fpos *lp));
Xint incCurpos __PARMS((void));
Xint incl __PARMS((struct fpos *lp));
Xint dec __PARMS((struct fpos *lp));
Xint decCurpos __PARMS((void));
Xint decl __PARMS((struct fpos *lp));
Xvoid adjustCurpos __PARMS((void));
END_OF_FILE
if test 306 -ne `wc -c <'vim/src/proto/linefunc.pro'`; then
    echo shar: \"'vim/src/proto/linefunc.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/linefunc.pro'
fi
if test -f 'vim/src/proto/main.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/main.pro'\"
else
echo shar: Extracting \"'vim/src/proto/main.pro'\" \(87 characters\)
sed "s/^X//" >'vim/src/proto/main.pro' <<'END_OF_FILE'
X/* main.c */
Xvoid main __PARMS((int argc, char **argv));
Xvoid getout __PARMS((int r));
END_OF_FILE
if test 87 -ne `wc -c <'vim/src/proto/main.pro'`; then
    echo shar: \"'vim/src/proto/main.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/main.pro'
fi
if test -f 'vim/src/proto/mark.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/mark.pro'\"
else
echo shar: Extracting \"'vim/src/proto/mark.pro'\" \(433 characters\)
sed "s/^X//" >'vim/src/proto/mark.pro' <<'END_OF_FILE'
X/* mark.c */
Xint setmark __PARMS((int c));
Xvoid setpcmark __PARMS((void));
Xstruct fpos *movemark __PARMS((int count));
Xstruct fpos *getmark __PARMS((int c, int changefile));
Xvoid clrallmarks __PARMS((void));
Xvoid incrmarks __PARMS((void));
Xvoid decrmarks __PARMS((void));
Xvoid adjustmark __PARMS((char *old, char *new));
Xchar *fm_getname __PARMS((struct filemark *fmark));
Xvoid domarks __PARMS((void));
Xvoid dojumps __PARMS((void));
END_OF_FILE
if test 433 -ne `wc -c <'vim/src/proto/mark.pro'`; then
    echo shar: \"'vim/src/proto/mark.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/mark.pro'
fi
if test -f 'vim/src/proto/message.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/message.pro'\"
else
echo shar: Extracting \"'vim/src/proto/message.pro'\" \(115 characters\)
sed "s/^X//" >'vim/src/proto/message.pro' <<'END_OF_FILE'
X/* message.c */
Xvoid msg __PARMS((char *s));
Xvoid emsg __PARMS((char *s));
Xvoid wait_return __PARMS((int redraw));
END_OF_FILE
if test 115 -ne `wc -c <'vim/src/proto/message.pro'`; then
    echo shar: \"'vim/src/proto/message.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/message.pro'
fi
if test -f 'vim/src/proto/misccmds.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/misccmds.pro'\"
else
echo shar: Extracting \"'vim/src/proto/misccmds.pro'\" \(986 characters\)
sed "s/^X//" >'vim/src/proto/misccmds.pro' <<'END_OF_FILE'
X/* misccmds.c */
Xint get_indent __PARMS((void));
Xvoid set_indent __PARMS((int size, int delete));
Xint Opencmd __PARMS((int dir, int redraw));
Xint plines __PARMS((long p));
Xint plines_m __PARMS((long first, long last));
Xvoid fileinfo __PARMS((void));
Xvoid setfname __PARMS((char *s));
Xint otherfile __PARMS((char *s));
Xvoid maketitle __PARMS((void));
Xvoid inschar __PARMS((int c));
Xvoid insstr __PARMS((char *s));
Xint delchar __PARMS((int fixpos));
Xvoid dellines __PARMS((long nlines, int can_update));
Xint gchar __PARMS((struct fpos *pos));
Xint gcharCurpos __PARMS((void));
Xint inindent __PARMS((void));
Xvoid skipspace __PARMS((char **pp));
Xvoid skiptospace __PARMS((char **pp));
Xlong getdigits __PARMS((char **pp));
Xchar *plural __PARMS((long n));
Xvoid set_Changed __PARMS((void));
Xint ask_yesno __PARMS((char *str));
Xvoid msgmore __PARMS((long n));
Xvoid beep __PARMS((void));
Xvoid expand_env __PARMS((char *src, char *dst, int dstlen));
Xint fullpathcmp __PARMS((char *s1, char *s2));
END_OF_FILE
if test 986 -ne `wc -c <'vim/src/proto/misccmds.pro'`; then
    echo shar: \"'vim/src/proto/misccmds.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/misccmds.pro'
fi
if test -f 'vim/src/proto/normal.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/normal.pro'\"
else
echo shar: Extracting \"'vim/src/proto/normal.pro'\" \(44 characters\)
sed "s/^X//" >'vim/src/proto/normal.pro' <<'END_OF_FILE'
X/* normal.c */
Xvoid normal __PARMS((void));
END_OF_FILE
if test 44 -ne `wc -c <'vim/src/proto/normal.pro'`; then
    echo shar: \"'vim/src/proto/normal.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/normal.pro'
fi
if test -f 'vim/src/proto/ops.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/ops.pro'\"
else
echo shar: Extracting \"'vim/src/proto/ops.pro'\" \(691 characters\)
sed "s/^X//" >'vim/src/proto/ops.pro' <<'END_OF_FILE'
X/* ops.c */
Xvoid doshift __PARMS((int op));
Xvoid shift_line __PARMS((int left));
Xint dorecord __PARMS((int c));
Xint doexecbuf __PARMS((int c));
Xint insertbuf __PARMS((int c));
Xvoid dodelete __PARMS((void));
Xvoid dotilde __PARMS((void));
Xvoid swapchar __PARMS((struct fpos *pos));
Xvoid dochange __PARMS((void));
Xvoid init_yank __PARMS((void));
Xint doyank __PARMS((int deleting));
Xvoid doput __PARMS((int dir, long count));
Xvoid dodis __PARMS((void));
Xvoid dodojoin __PARMS((long count, int flag, int redraw));
Xint dojoin __PARMS((int insert_space));
Xvoid doformat __PARMS((void));
Xvoid startinsert __PARMS((int initstr, int startln, long count));
Xint doaddsub __PARMS((int c, long Prenum1));
END_OF_FILE
if test 691 -ne `wc -c <'vim/src/proto/ops.pro'`; then
    echo shar: \"'vim/src/proto/ops.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/ops.pro'
fi
if test -f 'vim/src/proto/param.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/param.pro'\"
else
echo shar: Extracting \"'vim/src/proto/param.pro'\" \(159 characters\)
sed "s/^X//" >'vim/src/proto/param.pro' <<'END_OF_FILE'
X/* param.c */
Xvoid set_init __PARMS((void));
Xvoid doset __PARMS((char *arg));
Xint makeset __PARMS((struct __stdio *fd));
Xvoid clear_termparam __PARMS((void));
END_OF_FILE
if test 159 -ne `wc -c <'vim/src/proto/param.pro'`; then
    echo shar: \"'vim/src/proto/param.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/param.pro'
fi
if test -f 'vim/src/proto/quickfix.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/quickfix.pro'\"
else
echo shar: Extracting \"'vim/src/proto/quickfix.pro'\" \(209 characters\)
sed "s/^X//" >'vim/src/proto/quickfix.pro' <<'END_OF_FILE'
X/* quickfix.c */
Xint qf_init __PARMS((char *fname));
Xvoid qf_jump __PARMS((int errornr));
Xvoid qf_list __PARMS((void));
Xvoid qf_clrallmarks __PARMS((void));
Xvoid qf_adjustmark __PARMS((char *old, char *new));
END_OF_FILE
if test 209 -ne `wc -c <'vim/src/proto/quickfix.pro'`; then
    echo shar: \"'vim/src/proto/quickfix.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/quickfix.pro'
fi
if test -f 'vim/src/proto/regexp.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/regexp.pro'\"
else
echo shar: Extracting \"'vim/src/proto/regexp.pro'\" \(171 characters\)
sed "s/^X//" >'vim/src/proto/regexp.pro' <<'END_OF_FILE'
X/* regexp.c */
Xstruct regexp *regcomp __PARMS((char *exp));
Xint regexec __PARMS((struct regexp *prog, char *string, int at_bol));
Xchar *cstrchr __PARMS((char *s, int c));
END_OF_FILE
if test 171 -ne `wc -c <'vim/src/proto/regexp.pro'`; then
    echo shar: \"'vim/src/proto/regexp.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/regexp.pro'
fi
if test -f 'vim/src/proto/regsub.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/regsub.pro'\"
else
echo shar: Extracting \"'vim/src/proto/regsub.pro'\" \(105 characters\)
sed "s/^X//" >'vim/src/proto/regsub.pro' <<'END_OF_FILE'
X/* regsub.c */
Xint regsub __PARMS((struct regexp *prog, char *source, char *dest, int copy, int magic));
END_OF_FILE
if test 105 -ne `wc -c <'vim/src/proto/regsub.pro'`; then
    echo shar: \"'vim/src/proto/regsub.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/regsub.pro'
fi
if test -f 'vim/src/proto/screen.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/screen.pro'\"
else
echo shar: Extracting \"'vim/src/proto/screen.pro'\" \(662 characters\)
sed "s/^X//" >'vim/src/proto/screen.pro' <<'END_OF_FILE'
X/* screen.c */
Xvoid updateline __PARMS((void));
Xvoid updateScreen __PARMS((int type));
Xvoid comp_Botline __PARMS((void));
Xint prt_line __PARMS((char *s));
Xvoid screenalloc __PARMS((void));
Xvoid screenclear __PARMS((void));
Xvoid cursupdate __PARMS((void));
Xvoid curs_columns __PARMS((void));
Xint getvcol __PARMS((struct fpos *pos, int type));
Xvoid scrolldown __PARMS((long nlines));
Xvoid scrollup __PARMS((long nlines));
Xint s_ins __PARMS((int row, int nlines, int invalid));
Xint s_del __PARMS((int row, int nlines, int invalid));
Xvoid showmode __PARMS((void));
Xvoid delmode __PARMS((void));
Xvoid showruler __PARMS((int always));
Xvoid clear_line __PARMS((void));
END_OF_FILE
if test 662 -ne `wc -c <'vim/src/proto/screen.pro'`; then
    echo shar: \"'vim/src/proto/screen.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/screen.pro'
fi
if test -f 'vim/src/proto/script.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/script.pro'\"
else
echo shar: Extracting \"'vim/src/proto/script.pro'\" \(315 characters\)
sed "s/^X//" >'vim/src/proto/script.pro' <<'END_OF_FILE'
X/* script.c */
Xvoid startscript __PARMS((void));
Xint stopscript __PARMS((void));
Xint openscript __PARMS((char *name));
Xvoid updatescript __PARMS((int c));
Xvoid openrecover __PARMS((void));
Xchar *modname __PARMS((char *fname, char *ext));
Xvoid script_winsize __PARMS((void));
Xvoid script_winsize_pp __PARMS((void));
END_OF_FILE
if test 315 -ne `wc -c <'vim/src/proto/script.pro'`; then
    echo shar: \"'vim/src/proto/script.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/script.pro'
fi
if test -f 'vim/src/proto/search.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/search.pro'\"
else
echo shar: Extracting \"'vim/src/proto/search.pro'\" \(717 characters\)
sed "s/^X//" >'vim/src/proto/search.pro' <<'END_OF_FILE'
X/* search.c */
Xstruct regexp *myregcomp __PARMS((char *pat));
Xint searchit __PARMS((struct fpos *pos, int dir, char *str, long count, int end));
Xint dosearch __PARMS((int dir, char *str, int reverse, long count, int echo));
Xint searchc __PARMS((int c, int dir, int type, long count));
Xstruct fpos *showmatch __PARMS((void));
Xint findfunc __PARMS((int dir, int what, long count));
Xint findsent __PARMS((int dir, long count));
Xint findpar __PARMS((int dir, long count, int what));
Xint startPS __PARMS((long lnum, int para));
Xint fwd_word __PARMS((long count, int type));
Xint bck_word __PARMS((long count, int type));
Xint end_word __PARMS((long count, int type, int stop));
Xint skip_chars __PARMS((int class, int dir));
END_OF_FILE
if test 717 -ne `wc -c <'vim/src/proto/search.pro'`; then
    echo shar: \"'vim/src/proto/search.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/search.pro'
fi
if test -f 'vim/src/proto/storage.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/storage.pro'\"
else
echo shar: Extracting \"'vim/src/proto/storage.pro'\" \(705 characters\)
sed "s/^X//" >'vim/src/proto/storage.pro' <<'END_OF_FILE'
X/* storage.c */
Xchar *m_blockalloc __PARMS((unsigned long size, int message));
Xvoid m_blockfree __PARMS((void));
Xvoid free_line __PARMS((char *ptr));
Xchar *alloc_line __PARMS((unsigned int size));
Xchar *save_line __PARMS((char *src));
Xvoid filealloc __PARMS((void));
Xvoid freeall __PARMS((void));
Xchar *nr2ptr __PARMS((long nr));
Xchar *pos2ptr __PARMS((struct fpos *pos));
Xvoid setmarked __PARMS((long lnum));
Xlong firstmarked __PARMS((void));
Xvoid clearmarked __PARMS((void));
Xlong ptr2nr __PARMS((char *ptr, long start));
Xint appendline __PARMS((long after, char *s));
Xchar *delsline __PARMS((long nr, int delmarks));
Xchar *replaceline __PARMS((long lnum, char *new));
Xint canincrease __PARMS((int n));
END_OF_FILE
if test 705 -ne `wc -c <'vim/src/proto/storage.pro'`; then
    echo shar: \"'vim/src/proto/storage.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/storage.pro'
fi
if test -f 'vim/src/proto/tag.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/tag.pro'\"
else
echo shar: Extracting \"'vim/src/proto/tag.pro'\" \(187 characters\)
sed "s/^X//" >'vim/src/proto/tag.pro' <<'END_OF_FILE'
X/* tag.c */
Xvoid dotag __PARMS((char *tag, int type, int count));
Xvoid clrtags __PARMS((void));
Xvoid incrtags __PARMS((void));
Xvoid decrtags __PARMS((void));
Xvoid dotags __PARMS((void));
END_OF_FILE
if test 187 -ne `wc -c <'vim/src/proto/tag.pro'`; then
    echo shar: \"'vim/src/proto/tag.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/tag.pro'
fi
if test -f 'vim/src/proto/term.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/term.pro'\"
else
echo shar: Extracting \"'vim/src/proto/term.pro'\" \(594 characters\)
sed "s/^X//" >'vim/src/proto/term.pro' <<'END_OF_FILE'
X/* term.c */
Xvoid set_term __PARMS((char *term));
Xchar *tgoto __PARMS((char *cm, int x, int y));
Xvoid termcapinit __PARMS((char *term));
Xvoid outstrn __PARMS((char *s));
Xvoid outstr __PARMS((char *s));
Xvoid windgoto __PARMS((int row, int col));
Xvoid setcursor __PARMS((void));
Xvoid ttest __PARMS((int pairs));
Xint inchar __PARMS((int async, int waitforever));
Xvoid outnum __PARMS((long n));
Xvoid check_winsize __PARMS((void));
Xvoid set_winsize __PARMS((int width, int height, int mustset));
Xvoid settmode __PARMS((int raw));
Xvoid starttermcap __PARMS((void));
Xvoid stoptermcap __PARMS((void));
END_OF_FILE
if test 594 -ne `wc -c <'vim/src/proto/term.pro'`; then
    echo shar: \"'vim/src/proto/term.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/term.pro'
fi
if test -f 'vim/src/proto/termlib.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/termlib.pro'\"
else
echo shar: Extracting \"'vim/src/proto/termlib.pro'\" \(300 characters\)
sed "s/^X//" >'vim/src/proto/termlib.pro' <<'END_OF_FILE'
X/* termlib.c */
Xint tgetent __PARMS((char *tbuf, char *term));
Xint tgetflag __PARMS((char *id));
Xint tgetnum __PARMS((char *id));
Xchar *tgetstr __PARMS((char *id, char **buf));
Xchar *tgoto __PARMS((char *cm, int col, int line));
Xint tputs __PARMS((char *cp, int affcnt, void (*outc)(unsigned int)));
END_OF_FILE
if test 300 -ne `wc -c <'vim/src/proto/termlib.pro'`; then
    echo shar: \"'vim/src/proto/termlib.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/termlib.pro'
fi
if test -f 'vim/src/proto/undo.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/undo.pro'\"
else
echo shar: Extracting \"'vim/src/proto/undo.pro'\" \(418 characters\)
sed "s/^X//" >'vim/src/proto/undo.pro' <<'END_OF_FILE'
X/* undo.c */
Xint u_saveCurpos __PARMS((void));
Xint u_save __PARMS((long top, long bot));
Xint u_savesub __PARMS((long lnum, char *ptr));
Xint u_savedel __PARMS((long lnum, char *ptr));
Xvoid u_undo __PARMS((int count));
Xvoid u_redo __PARMS((int count));
Xvoid u_sync __PARMS((void));
Xvoid u_clearall __PARMS((void));
Xvoid u_saveline __PARMS((long lnum));
Xvoid u_clearline __PARMS((void));
Xvoid u_undoline __PARMS((void));
END_OF_FILE
if test 418 -ne `wc -c <'vim/src/proto/undo.pro'`; then
    echo shar: \"'vim/src/proto/undo.pro'\" unpacked with wrong size!
fi
# end of 'vim/src/proto/undo.pro'
fi
if test -f 'vim/src/ptx_stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ptx_stdlib.h'\"
else
echo shar: Extracting \"'vim/src/ptx_stdlib.h'\" \(955 characters\)
sed "s/^X//" >'vim/src/ptx_stdlib.h' <<'END_OF_FILE'
X/*
X * ptx_stdlib.h: declarations which are needed for sequent
X */
X
Xextern void free(void *);
X#ifdef SIZE_T /* sys/types.h */
Xextern void *malloc(size_t);
Xextern off_t lseek(int, off_t, int);
X#else
Xextern void *malloc(unsigned);
Xextern int lseek(int, int, int);
X#endif
X
X#ifndef _FCNTL_H_
Xextern int open(char *, int, ...);
X#endif
Xextern int close(int);
Xextern int read(int, char *, unsigned);
Xextern int write(int, char *, unsigned);
Xextern int ioctl(int, int, ...);
Xextern int unlink(char *);
X
Xextern char *getenv(char *);
Xextern int getuid(void);
Xextern int getgid(void);
X
X#ifdef _NFILE /* stdio.h */
Xextern int _filbuf(FILE *);
Xextern int _flsbuf(unsigned char, FILE *);
X#endif
X
X#ifdef _POLL_H_
Xextern int poll(struct pollfd[], unsigned long, int);
X#endif /* _POLL_H_ */
X
Xextern char *getcwd(char *, int);
X
Xextern int chdir(char *);
X
Xextern int atoi (char *);
Xextern long atol(char *);
Xextern long strtol(char *, char **, int);
X
Xextern int isatty(int);
END_OF_FILE
if test 955 -ne `wc -c <'vim/src/ptx_stdlib.h'`; then
    echo shar: \"'vim/src/ptx_stdlib.h'\" unpacked with wrong size!
fi
# end of 'vim/src/ptx_stdlib.h'
fi
if test -f 'vim/src/regexp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regexp.h'\"
else
echo shar: Extracting \"'vim/src/regexp.h'\" \(1541 characters\)
sed "s/^X//" >'vim/src/regexp.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * Definitions etc. for regexp(3) routines.
X *
X * Caveat:	this is V8 regexp(3) [actually, a reimplementation thereof],
X * not the System V one.
X */
X
X#ifndef _REGEXP_H
X#define _REGEXP_H
X
X#define NSUBEXP  10
Xtypedef struct regexp {
X	char		   *startp[NSUBEXP];
X	char		   *endp[NSUBEXP];
X	char			regstart;	/* Internal use only. */
X	char			reganch;	/* Internal use only. */
X	char		   *regmust;	/* Internal use only. */
X	int 			regmlen;	/* Internal use only. */
X	char			program[1]; /* Unwarranted chumminess with compiler. */
X}				regexp;
X
X/* regexp.c */
Xregexp *regcomp __ARGS((char *));
Xint regexec __ARGS((regexp *, char *, int));
X/* int cstrncmp __ARGS((char *, char *, int)); */
Xchar *cstrchr __ARGS((char *, int));
X
X/* regsub.c */
Xint regsub __ARGS((regexp *, char *, char *, int, int));
X
X/* search.c */
Xextern void 	regerror __ARGS((char *));
X
X#ifndef ORIGINAL
Xextern int		reg_ic; 		/* set non-zero to ignore case in searches */
Xextern int		reg_magic;		/* set zero to disable magicness of .*[~& */
X#endif
X#endif	/* _REGEXP_H */
END_OF_FILE
if test 1541 -ne `wc -c <'vim/src/regexp.h'`; then
    echo shar: \"'vim/src/regexp.h'\" unpacked with wrong size!
fi
# end of 'vim/src/regexp.h'
fi
if test -f 'vim/src/regmagic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regmagic.h'\"
else
echo shar: Extracting \"'vim/src/regmagic.h'\" \(663 characters\)
sed "s/^X//" >'vim/src/regmagic.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * The first byte of the regexp internal "program" is actually this magic
X * number; the start node begins in the second byte.
X */
X
X#define MAGIC	0234
END_OF_FILE
if test 663 -ne `wc -c <'vim/src/regmagic.h'`; then
    echo shar: \"'vim/src/regmagic.h'\" unpacked with wrong size!
fi
# end of 'vim/src/regmagic.h'
fi
if test -f 'vim/src/termlib.fix.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/termlib.fix.uue'\"
else
echo shar: Extracting \"'vim/src/termlib.fix.uue'\" \(89 characters\)
sed "s/^X//" >'vim/src/termlib.fix.uue' <<'END_OF_FILE'
X
Xbegin 644 termlib.fix
XB#2]O=71C*2@I#6QL;&QL875N<VEG;F5D(&EN=!LZ=W$-"O__5
X``
Xend
Xsize 34
END_OF_FILE
if test 89 -ne `wc -c <'vim/src/termlib.fix.uue'`; then
    echo shar: \"'vim/src/termlib.fix.uue'\" unpacked with wrong size!
fi
# end of 'vim/src/termlib.fix.uue'
fi
if test -f 'vim/src/vim.prj' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vim.prj'\"
else
echo shar: Extracting \"'vim/src/vim.prj'\" \(283 characters\)
sed "s/^X//" >'vim/src/vim.prj' <<'END_OF_FILE'
XALLOC.C
XBUFFERS.C
XCHARSET.C
XCMDLINE.C
XCSEARCH.C
XEDIT.C
XDIGRAPH.C
XFILEIO.C
XHELP.C
XLINEFUNC.C
XMAIN.C
XMARK.C
XMESSAGE.C
XMISCCMDS.C
XMSDOS.C
XNORMAL.C
XOPS.C
XPARAM.C
XQUICKFIX.C
XREGEXP.C
XREGSUB.C
XSCREEN.C
XSCRIPT.C
XSEARCH.C
XSTORAGE.C
XTAG.C
XTERM.C
XUNDO.C
XVERSION.C
END_OF_FILE
if test 283 -ne `wc -c <'vim/src/vim.prj'`; then
    echo shar: \"'vim/src/vim.prj'\" unpacked with wrong size!
fi
# end of 'vim/src/vim.prj'
fi
if test -f 'vim/src/vimresp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vimresp'\"
else
echo shar: Extracting \"'vim/src/vimresp'\" \(325 characters\)
sed "s/^X//" >'vim/src/vimresp' <<'END_OF_FILE'
Xalloc.obj msdos.obj buffers.obj charset.obj cmdline.obj csearch.obj +
Xdigraph.obj edit.obj fileio.obj help.obj linefunc.obj main.obj mark.obj +
Xmessage.obj misccmds.obj normal.obj ops.obj param.obj quickfix.obj +
Xregexp.obj regsub.obj screen.obj script.obj search.obj storage.obj +
Xtag.obj term.obj undo.obj version.obj
END_OF_FILE
if test 325 -ne `wc -c <'vim/src/vimresp'`; then
    echo shar: \"'vim/src/vimresp'\" unpacked with wrong size!
fi
# end of 'vim/src/vimresp'
fi
if test -f 'vim/todo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/todo'\"
else
echo shar: Extracting \"'vim/todo'\" \(1614 characters\)
sed "s/^X//" >'vim/todo' <<'END_OF_FILE'
XBugs, VI compatibility:
X
XSetting the size of the window does not always work as expected.
XWith quickfix we only get the first 25 errors. How do we get the rest?
XThe ":cq" command does not always abort the compiler.
XWhen editing multiple files, typing :q twice should exit Vim.
X
X
XFurther extentions:
X
XHistory stack for . command?
XWhen there are "Too many files", possibility to insert them all (CTRL-A).
XUse insert/delete char when terminal supports it.
X"edit" option: when off changing the buffer is not possible.
XAdd "-d null" for editing with a script file without a display.
XFor MSDOS use memory mapped screen output (ansi.sys not needed).
XFor MSDOS search for _exrc in the directory where the binary is, instead
X	of using $VIM\_exrc.
XIn insert mode: Remember the characters that were removed with backspace and
X	re-insert them one at a time with CTRL-x, all together with CTRL-x.
XAdd possibility to set a keymap. The code in amiga.c does not work yet.
XAdd recognition of CR-LF files and correctly write them automatically.
XAdd to quoting: Center, right-adjust, left-adjust, function (e.g. add).
XAdd possibility to re-select previously quoted part.
X
XFrom Elvis:
Xfontchanges recognized "\\fB" etc.
Xparse error messages from many compilers
X
X
XFar future extentions:
X
XOption verbose; when on keep the screen uptodate, when off only redisplay when
X	input needed.
XRemember message line for redraw.
XUse disk swap file when editing very large files.
XMode to keep text formatted while inserting/deleting.
XMode to keep C-code formatted (sort of on-line indent)
XOption to choose between line wrap and horizontal scrolling
END_OF_FILE
if test 1614 -ne `wc -c <'vim/todo'`; then
    echo shar: \"'vim/todo'\" unpacked with wrong size!
fi
# end of 'vim/todo'
fi
if test ! -d 'vim/tutor' ; then
    echo shar: Creating directory \"'vim/tutor'\"
    mkdir 'vim/tutor'
fi
if test -f 'vim/tutor/Readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/tutor/Readme'\"
else
echo shar: Extracting \"'vim/tutor/Readme'\" \(768 characters\)
sed "s/^X//" >'vim/tutor/Readme' <<'END_OF_FILE'
XVitutor is a "hands on" tutorial for new users of the Vim editor.
X
XMost new users can get through it in less than one hour.  The result
Xis that you can do a simple editing task using the Vim editor.
X
XTutor is a file that contains the tutorial lessons.  You can simply
Xexecute "vim tutor" and then follow the instructions in the lessons.
XThe lessons tell you to modify the file, so DON'T DO THIS ON YOUR
XORIGINAL COPY.
X
XI have considered adding more advanced lessons but have not found the
Xtime.  Please let me know how you like it and send any improvements you
Xmake.
X
XBob Ware, Colorado School of Mines, Golden, Co 80401, USA
X(303) 273-3987
Xbware@mines.colorado.edu bware@slate.mines.colorado.edu bware@mines.bitnet
X
X(This file was modified by Bram Moolenaar for Vim)
END_OF_FILE
if test 768 -ne `wc -c <'vim/tutor/Readme'`; then
    echo shar: \"'vim/tutor/Readme'\" unpacked with wrong size!
fi
# end of 'vim/tutor/Readme'
fi
if test -f 'vim/tutor/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/tutor/poster'\"
else
echo shar: Extracting \"'vim/tutor/poster'\" \(860 characters\)
sed "s/^X//" >'vim/tutor/poster' <<'END_OF_FILE'
XArticle 3390 of alt.sources:
XXref: oce-rd1 comp.editors:3231 alt.sources:3390
XPath: oce-rd1!venlo!hp4nl!mcsun!uunet!zaphod.mps.ohio-state.edu!magnus.acs.ohio-state.edu!csn!pikes!slate!bware
XFrom: bware@slate.mines.colorado.edu (Ware Bob)
XNewsgroups: comp.editors,alt.sources
XSubject: hands on vi tutor
XKeywords: for new users
XMessage-ID: <1991Jul17.161355.15677@slate.mines.colorado.edu>
XDate: 17 Jul 91 16:13:55 GMT
XSender: bware@slate.mines.colorado.edu (Ware Bob)
XOrganization: Colorado School of Mines
XLines: 830
X
X
XI posted this a few weeks ago, but a number of people have munged 
Xtheir copy, so I am reposting it with better instructions.
X
XThis is a "hand-on" tutor to help new users learn the vi editor.
X
XBob Ware, Colorado School of Mines, Golden, Co 80401, USA
X(303) 273-3987
Xbware@mines.colorado.edu bware@slate.mines.colorado.edu bware@mines.bitnet
END_OF_FILE
if test 860 -ne `wc -c <'vim/tutor/poster'`; then
    echo shar: \"'vim/tutor/poster'\" unpacked with wrong size!
fi
# end of 'vim/tutor/poster'
fi
echo shar: End of archive 1 \(of 23\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 23 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-------------8<----------------8<----------------8<---------------8<--------
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595450 | whatever will be accepted.

exit 0 # Just in case...
