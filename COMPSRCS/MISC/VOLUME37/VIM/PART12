Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v37i012:  vim - Vi IMitation editor v1.27, Part12/24
Message-ID: <1993Apr25.013418.22285@sparky.imd.sterling.com>
X-Md4-Signature: c9891e2c16a4e43afb1a2578a5604090
Date: Sun, 25 Apr 1993 01:34:18 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 37, Issue 12
Archive-name: vim/part12
Environment: UNIX, AMIGA, MS-DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 23)."
# Contents:  vim/src/ops.c vim/src/search.c
# Wrapped by mool@oce-rd2 on Mon Apr 19 15:50:10 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/src/ops.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ops.c'\"
else
echo shar: Extracting \"'vim/src/ops.c'\" \(28332 characters\)
sed "s/^X//" >'vim/src/ops.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * ops.c: implementation of various operators: doshift, dodelete, dotilde,
X *		  dochange, doyank, doput, dojoin
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X#include "ops.h"
X
X/*
X * We have one yank buffer for normal yanks and puts, nine yank buffers for
X * deletes and 26 yank buffers for use by name.
X * Each yank buffer is an array of pointers to lines.
X */
Xstatic struct yankbuf
X{
X	char		**y_array;		/* pointer to array of line pointers */
X	linenr_t 	y_size; 		/* number of lines in y_array */
X	char		y_type; 		/* MLINE, MCHAR or MBLOCK */
X} y_buf[36];					/* 0..9 = number buffers, 10..35 = char buffers */
X
Xstatic struct	yankbuf *y_current;		/* ptr to current yank buffer */
Xstatic int		yankappend;				/* TRUE when appending */
Xstatic struct	yankbuf *y_previous = NULL; /* ptr to last written yank buffer */
X
Xstatic void		get_yank_buffer __ARGS((int));
Xstatic int		stuff_yank __ARGS((int, char *));
Xstatic void		free_yank __ARGS((long));
Xstatic void		free_yank_all __ARGS((void));
Xstatic void		block_prep __ARGS((linenr_t, int));
X
X/* variables use by block_prep, dodelete and doyank */
Xstatic int		startspaces;
Xstatic int		endspaces;
Xstatic int		textlen;
Xstatic char		*textstart;
Xstatic colnr_t	textcol;
X
X/*
X * doshift - handle a shift operation
X */
X	void
Xdoshift(op)
X	int 			op;
X{
X	register int i;
X
X	if (!u_save((linenr_t)(Curpos.lnum - 1), (linenr_t)(Curpos.lnum + nlines)))
X		return;
X
X	Curpos.lnum += nlines;		/* start with last line, leave cursor on first */
X	for (i = nlines; --i >= 0; )
X		if (lineempty(--Curpos.lnum))
X			Curpos.col = 0;
X		else
X			shift_line(op == LSHIFT);
X
X	updateScreen(CURSUPD);
X
X	if (nlines > p_report)
X		smsg("%ld line%s %ced", nlines, plural(nlines),
X									(op == RSHIFT) ? '>' : '<');
X}
X
X/*
X * shift the current line one shiftwidth left (if left != 0) or right
X * leaves cursor on first blank in the line
X */
X	void
Xshift_line(left)
X	int left;
X{
X	register int count;
X	register int i, j;
X
X	count = get_indent();			/* get current indent */
X
X	if (p_sr)		/* round off indent */
X	{
X		i = count / p_sw;			/* compute new indent */
X		j = count % p_sw;
X		if (j)
X		{
X			if (!left)
X				++i;
X		}
X		else if (left)
X		{
X			if (i)
X				--i;
X		}
X		else
X			++i;
X		count = i * p_sw;
X	}
X	else				/* original vi indent */
X	{
X		if (left)
X		{
X			count -= p_sw;
X			if (count < 0)
X				count = 0;
X		}
X		else
X			count += p_sw;
X	}
X	set_indent(count, TRUE);		/* set new indent */
X}
X
X/*
X * Set y_current and yankappend, according to the value of yankbuffer.
X */
X	static void
Xget_yank_buffer(writing)
X	int		writing;
X{
X	register int i;
X
X	yankappend = FALSE;
X	if (yankbuffer == 0 && y_previous != NULL && !writing)
X	{
X		y_current = y_previous;
X		return;
X	}
X	i = yankbuffer;
X	if (isdigit(i))
X		i -= '0';
X	else if (islower(i))
X		i -= 'a' - 10;
X	else if (isupper(i))
X	{
X		i -= 'A' - 10;
X		yankappend = TRUE;
X	}
X	else			/* not 0-9, a-z or A-Z: use buffer 0 */
X		i = 0;
X	y_current = &(y_buf[i]);
X	if (writing)		/* remember the buffer we write into for doput() */
X		y_previous = y_current;
X}
X
X/*
X * (stop) recording into a yank buffer
X */
X	int
Xdorecord(c)
X	int c;
X{
X	char *p, *lp;
X	static int bufname;
X
X	if (Recording == FALSE) 		/* start recording */
X	{
X		if (!isalpha(c))
X			return FALSE;
X		Recording = TRUE;
X		showmode();
X		bufname = c;
X		return TRUE;
X	}
X	else							/* stop recording */
X	{
X		Recording = FALSE;
X		if (p_mo)
X			msg("");
X		p = (char *)get_recorded();
X		if (p == NULL)
X			return FALSE;
X		lp = strrchr(p, 'v');	/* delete the trailing 'v' */
X		if (lp != NULL)
X			*lp = NUL;
X		return (stuff_yank(bufname, p));
X	}
X}
X
X/*
X * stuff string 'p' into yank buffer 'bufname' (append if uppercase)
X * 'p' is assumed to be alloced.
X */
X	static int
Xstuff_yank(bufname, p)
X	int bufname;
X	char *p;
X{
X	char *lp;
X	char **pp;
X
X	yankbuffer = bufname;
X	if (yankbuffer == '.')		/* read-only buffer */
X		return FALSE;
X	get_yank_buffer(TRUE);
X	if (yankappend && y_current->y_array != NULL)
X	{
X		pp = &(y_current->y_array[y_current->y_size - 1]);
X		lp = alloc((unsigned)(strlen(*pp) + strlen(p) + 1));
X		if (lp == NULL)
X		{
X			free(p);
X			return FALSE;
X		}
X		strcpy(lp, *pp);
X		strcat(lp, p);
X		free(p);
X		free(*pp);
X		*pp = lp;
X	}
X	else
X	{
X		free_yank_all();
X		if ((y_current->y_array = (char **)alloc((unsigned)sizeof(char *))) == NULL)
X		{
X			free(p);
X			return FALSE;
X		}
X		y_current->y_array[0] = p;
X		y_current->y_size = 1;
X		y_current->y_type = MCHAR;	/* used to be MLINE, why? */
X	}
X	return TRUE;
X}
X
X/*
X * execute a yank buffer: copy it into the stuff buffer
X */
X	int
Xdoexecbuf(c)
X	int c;
X{
X	static int lastc = NUL;
X	long i;
X
X	if (c == '@')			/* repeat previous one */
X		c = lastc;
X
X	lastc = c;
X	if (!isalnum(c))		/* registers 0-9 and a-z are allowed */
X		return FALSE;
X
X	yankbuffer = c;
X	get_yank_buffer(FALSE);
X	if (y_current->y_array == NULL)
X		return FALSE;
X
X	for (i = y_current->y_size; --i >= 0; )
X	{
X	/* insert newline between lines and after last line if type is MLINE */
X		if (y_current->y_type == MLINE || i < y_current->y_size - 1)
X		{
X			if (ins_mapbuf("\n") < 0)
X				return FALSE;
X		}
X		if (ins_mapbuf(y_current->y_array[i]) < 0)
X			return FALSE;
X	}
X
X	return TRUE;
X}
X
X/*
X * insert a yank buffer: copy it into the Read buffer
X */
X	int
Xinsertbuf(c)
X	int c;
X{
X	long i;
X
X	if (!isalnum(c))		/* registers 0-9 and a-z are allowed */
X		return FALSE;
X
X	yankbuffer = c;
X	get_yank_buffer(FALSE);
X	if (y_current->y_array == NULL)
X		return FALSE;
X
X	for (i = 0; i < y_current->y_size; ++i)
X	{
X		stuffReadbuff(y_current->y_array[i]);
X	/* insert newline between lines and after last line if type is MLINE */
X		if (y_current->y_type == MLINE || i < y_current->y_size - 1)
X			stuffReadbuff("\n");
X	}
X	return TRUE;
X}
X
X/*
X * dodelete - handle a delete operation
X */
X	void
Xdodelete()
X{
X	register int	n;
X	linenr_t		lnum;
X	char			*ptr;
X
X	/*
X	 * Do a yank of whatever we're about to delete. If there's too much stuff
X	 * to fit in the yank buffer, then get a confirmation before doing the
X	 * delete. This is crude, but simple. And it avoids doing a delete of
X	 * something we can't put back if we want.
X	 */
X	if (yankbuffer == 0)				/* normal delete: shift number buffers */
X	{
X		y_current = &y_buf[9];
X		free_yank_all();				/* free buffer nine */
X		for (n = 9; n > 1; --n)
X			y_buf[n] = y_buf[n - 1];
X		y_previous = y_current = &y_buf[1];
X		y_buf[1].y_array = NULL;		/* set buffer one to empty */
X	}
X	else if (yankbuffer == '.')			/* read-only buffer */
X	{
X		beep();
X		return;
X	}
X	else								/* yank into specified buffer */
X		get_yank_buffer(TRUE);
X
X	if (!doyank(TRUE))
X	{
X		if (ask_yesno("cannot yank; delete anyway") != 'y')
X		{
X			emsg(e_abort);
X			return;
X		}
X	}
X
X	if (!u_save((linenr_t)(startop.lnum - 1), (linenr_t)(endop.lnum + 1)))
X		return;
X
X/*
X * block mode
X */
X	if (Quote_block)
X	{
X		for (lnum = Curpos.lnum; Curpos.lnum <= endop.lnum; ++Curpos.lnum)
X		{
X			block_prep(Curpos.lnum, TRUE);
X			if (textlen == 0)		/* nothing to delete */
X				continue;
X
X		/*
X		 * If we delete a TAB, it may be replaced by several characters.
X		 * Thus the number of characters may increase!
X		 */
X			n = textlen - startspaces - endspaces;
X		/* number of characters increases - make room */
X			if (n < 0 && !canincrease(-n))
X				continue;
X			ptr = nr2ptr(Curpos.lnum) + textcol;
X		/* copy the part after the deleted part */
X			memmove(ptr + startspaces + endspaces, ptr + textlen, strlen(ptr + textlen) + 1);
X		/* insert spaces */
X			copy_spaces(ptr, (size_t)(startspaces + endspaces));
X			if (n > 0)
X				canincrease(0);
X		}
X		Curpos.lnum = lnum;
X		CHANGED;
X		updateScreen(VALID_TO_CURSCHAR);
X		nlines = 0;		/* no lines deleted */
X	}
X	else if (mtype == MLINE)
X	{
X		u_clearline();	/* "U" command should not be possible after "dd" */
X		if (operator == CHANGE)
X		{
X			dellines((long)(nlines - 1), TRUE);
X			Curpos.col = 0;
X			while (delchar(TRUE));
X		}
X		else
X		{
X			dellines(nlines, TRUE);
X		}
X	}
X	else if (nlines == 1)		/* del. within line */
X	{
X		n = endop.col - startop.col + 1 - oneless;
X		while (n--)
X			if (!delchar(TRUE))
X				break;
X	}
X	else						/* del. between lines */
X	{
X		n = Curpos.col;
X		while (Curpos.col >= n)
X			if (!delchar(TRUE))
X				break;
X
X		startop = Curpos;		/* remember Curpos */
X		++Curpos.lnum;
X		dellines((long)(nlines - 2), TRUE);
X		n = endop.col - oneless;
X
X		while (n-- >= 0)
X			if (!delchar(TRUE))
X				break;
X		Curpos = startop;		/* restore Curpos */
X		dojoin(FALSE);
X	}
X
X	if ((mtype == MCHAR && nlines <= 2 /* && p_nu == FALSE */) || operator == CHANGE)
X	{
X		cursupdate();
X		updateline();
X	}
X	else
X		updateScreen(CURSUPD);
X
X	if (mtype == MCHAR)
X		--nlines;
X	msgmore(-nlines);
X
X		/* correct endop for deleted text (for "']" command) */
X	if (Quote_block)
X		endop.col = startop.col;
X	else
X		endop = startop;
X}
X
X/*
X * dotilde - handle the (non-standard vi) tilde operator
X */
X	void
Xdotilde()
X{
X	FPOS pos;
X
X	if (!u_save((linenr_t)(startop.lnum - 1), (linenr_t)(endop.lnum + 1)))
X		return;
X
X	pos = startop;
X	if (Quote_block)		/* block mode */
X	{
X		for (; pos.lnum <= endop.lnum; ++pos.lnum)
X		{
X			block_prep(pos.lnum, FALSE);
X			pos.col = textcol;
X			for (; --textlen >= 0; inc(&pos))
X				swapchar(&pos);
X		}
X	}
X	else			/* not block mode */
X	{
X		if (mtype == MLINE)
X		{
X				pos.col = 0;
X				endop.col = strlen(nr2ptr(endop.lnum));
X				if (endop.col)
X						--endop.col;
X		}
X		else if (oneless)
X			dec(&endop);
X
X		for ( ; ltoreq(pos, endop); inc(&pos))
X			swapchar(&pos);
X	}
X
X	if (mtype == MCHAR && nlines == 1 && !Quote_block)
X	{
X		cursupdate();
X		updateline();
X	}
X	else
X		updateScreen(CURSUPD);
X
X	if (nlines > p_report)
X			smsg("%ld line%s ~ed", nlines, plural(nlines));
X}
X
X/*
X * If operator == UPPER: make uppercase,
X * if operator == LOWER: make lowercase,
X * else swap case of character at 'pos'
X */
X	void
Xswapchar(pos)
X	FPOS	*pos;
X{
X	int		c;
X
X	c = gchar(pos);
X	if (islower(c) && operator != LOWER)
X	{
X		pchar(*pos, toupper(c));
X		CHANGED;
X	}
X	else if (isupper(c) && operator != UPPER)
X	{
X		pchar(*pos, tolower(c));
X		CHANGED;
X	}
X}
X
X/*
X * dochange - handle a change operation
X */
X	void
Xdochange()
X{
X	register colnr_t 		   l;
X
X	l = startop.col;
X
X	dodelete();
X
X	if ((l > Curpos.col) && !lineempty(Curpos.lnum))
X		incCurpos();
X
X	startinsert(NUL, FALSE, (linenr_t)1);
X}
X
X/*
X * set all the yank buffers to empty (called from main())
X */
X	void
Xinit_yank()
X{
X		register int i;
X
X		for (i = 0; i < 36; ++i)
X				y_buf[i].y_array = NULL;
X}
X
X/*
X * Free "n" lines from the current yank buffer.
X * Called for normal freeing and in case of error.
X */
X	static void
Xfree_yank(n)
X	long n;
X{
X	if (y_current->y_array != NULL)
X	{
X		register long i;
X
X		for (i = n; --i >= 0; )
X		{
X			if (i % 1000 == 999)					/* this may take a while */
X				smsg("freeing %ld lines", i + 1);
X			free(y_current->y_array[i]);
X		}
X		free((char *)y_current->y_array);
X		y_current->y_array = NULL;
X		if (n >= 1000)
X			msg("");
X	}
X}
X
X	static void
Xfree_yank_all()
X{
X		free_yank(y_current->y_size);
X}
X
X/*
X * Yank the text between Curpos and startpos into a yank buffer.
X * If we are to append ("uppercase), we first yank into a new yank buffer and
X * then concatenate the old and the new one (so we keep the old one in case
X * of out-of-memory).
X */
X	int
Xdoyank(deleting)
X	int deleting;
X{
X	long 				i;				/* index in y_array[] */
X	struct yankbuf		*curr;		/* copy of y_current */
X	struct yankbuf		new; 		/* new yank buffer when appending */
X	char				**new_ptr;
X	register linenr_t	lnum;			/* current line number */
X	long 				j;
X
X	char				*pnew;
X
X	if (yankbuffer == '.')			/* read-only buffer */
X	{
X		beep();
X		return FALSE;
X	}
X	if (!deleting)					/* dodelete() already set y_current */
X		get_yank_buffer(TRUE);
X
X	curr = y_current;
X	if (yankappend && y_current->y_array != NULL) /* append to existing contents */
X		y_current = &new;
X	else
X		free_yank_all();		/* free previously yanked lines */
X
X	y_current->y_size = nlines;
X	y_current->y_type = mtype;	/* set the yank buffer type */
X	y_current->y_array = (char **)alloc((unsigned)(sizeof(char *) * nlines));
X
X	if (y_current->y_array == NULL)
X	{
X		y_current = curr;
X		return FALSE;
X	}
X
X	i = 0;
X	lnum = startop.lnum;
X
X	if (Quote_block)
X	{
X/*
X * block mode
X */
X		y_current->y_type = MBLOCK;	/* set the yank buffer type */
X		for ( ; lnum <= endop.lnum; ++lnum)
X		{
X			block_prep(lnum, FALSE);
X			if ((pnew= alloc(startspaces + endspaces + textlen + 1)) == NULL)
X				goto fail;
X			y_current->y_array[i++] = pnew;
X			copy_spaces(pnew, (size_t)startspaces);
X			pnew += startspaces;
X			strncpy(pnew, textstart, (size_t)textlen);
X			pnew += textlen;
X			copy_spaces(pnew, (size_t)endspaces);
X			pnew += endspaces;
X			*pnew = NUL;
X		}
X	}
X	else
X	{
X/*
X * there are three parts for non-block mode:
X * 1. if mtype != MLINE yank last part of the top line
X * 2. yank the lines between startop and endop, inclusive when mtype == MLINE
X * 3. if mtype != MLINE yank first part of the bot line
X */
X		if (mtype != MLINE)
X		{
X			if (nlines == 1)		/* startop and endop on same line */
X			{
X					j = endop.col - startop.col + 1 - oneless;
X					if ((y_current->y_array[0] = strnsave(nr2ptr(lnum) + startop.col, (int)j)) == NULL)
X					{
X	fail:
X							free_yank(i);	/* free the lines that we allocated */
X							y_current = curr;
X							return FALSE;
X					}
X					goto success;
X			}
X			if ((y_current->y_array[0] = strsave(nr2ptr(lnum++) + startop.col)) == NULL)
X					goto fail;
X			++i;
X		}
X
X		while (mtype == MLINE ? (lnum <= endop.lnum) : (lnum < endop.lnum))
X		{
X			if ((y_current->y_array[i] = strsave(nr2ptr(lnum++))) == NULL)
X					goto fail;
X			++i;
X		}
X		if (mtype != MLINE)
X		{
X			if ((y_current->y_array[i] = strnsave(nr2ptr(endop.lnum), endop.col + 1 - oneless)) == NULL)
X					goto fail;
X		}
X	}
X
Xsuccess:
X	if (curr != y_current)		/* append the new block to the old block */
X	{
X		new_ptr = (char **)alloc((unsigned)(sizeof(char *) * (curr->y_size + y_current->y_size)));
X		if (new_ptr == NULL)
X				goto fail;
X		for (j = 0; j < curr->y_size; ++j)
X				new_ptr[j] = curr->y_array[j];
X		free(curr->y_array);
X		curr->y_array = new_ptr;
X
X		if (mtype == MLINE) 	/* MLINE overrides MCHAR and MBLOCK */
X				curr->y_type = MLINE;
X		if (curr->y_type == MCHAR)		/* concatenate the last line of the old
X										block with the first line of the new block */
X		{
X				new_ptr = (char **)alloc((unsigned)(strlen(curr->y_array[curr->y_size - 1]) + strlen(y_current->y_array[0]) + 1));
X				if (new_ptr == NULL)
X				{
X						i = y_current->y_size - 1;
X						goto fail;
X				}
X				strcpy((char *)new_ptr, curr->y_array[--j]);
X				strcat((char *)new_ptr, y_current->y_array[0]);
X				free(curr->y_array[j]);
X				free(y_current->y_array[0]);
X				curr->y_array[j++] = (char *)new_ptr;
X				i = 1;
X		}
X		else
X				i = 0;
X		while (i < y_current->y_size)
X				curr->y_array[j++] = y_current->y_array[i++];
X		curr->y_size = j;
X		free(y_current->y_array);
X		y_current = curr;
X	}
X	if (operator == YANK)		/* don't do this when deleting */
X	{
X		if (mtype == MCHAR)
X			--nlines;
X		if (nlines > p_report)
X		{
X			cursupdate();		/* redisplay now, so message is not deleted */
X			smsg("%ld line%s yanked", nlines, plural(nlines));
X		}
X	}
X
X	return TRUE;
X}
X
X	void
Xdoput(dir, count)
X	int dir;
X	long count;
X{
X	char		*ptr, *ep;
X	int 		newlen;
X	int			totlen = 0;		/* init for gcc */
X	linenr_t	lnum;
X	int			col;
X	long 		i;		/* index in y_array[] */
X	int 		y_type;
X	long 		y_size;
X	char		**y_array;
X	long 		nlines = 0;
X	int			vcol;
X	int			delchar;
X	int			incr = 0;
X	long		j;
X	FPOS		newCurpos;
X
X	startop = Curpos;			/* default for "'[" command */
X	if (dir == FORWARD)
X		startop.col++;
X	endop = Curpos;				/* default for "']" command */
X	if (yankbuffer == '.')		/* use inserted text */
X	{
X		stuff_inserted(dir == FORWARD ? (count == -1 ? 'o' : 'a') : (count == -1 ? 'O' : 'i'), count, FALSE);
X		return;
X	}
X	get_yank_buffer(FALSE);
X
X	y_type = y_current->y_type;
X	y_size = y_current->y_size;
X	y_array = y_current->y_array;
X
X	if (count == -1)		/* :put command */
X	{
X		y_type = MLINE;
X		count = 1;
X	}
X
X	if (y_size == 0 || y_array == NULL)
X	{
X		beep();
X		return;
X	}
X
X	if (y_type == MBLOCK)
X	{
X		lnum = Curpos.lnum + y_size + 1;
X		if (lnum > line_count)
X			lnum = line_count + 1;
X		if (!u_save(Curpos.lnum - 1, lnum))
X			return;
X	}
X	else if (!u_saveCurpos())
X		return;
X
X	newlen = strlen(y_array[0]);
X	CHANGED;
X
X	lnum = Curpos.lnum;
X	col = Curpos.col;
X
X/*
X * block mode
X */
X	if (y_type == MBLOCK)
X	{
X		if (dir == FORWARD && gcharCurpos() != NUL)
X		{
X			col = getvcol(&Curpos, 3) + 1;
X			++Curpos.col;
X		}
X		else
X			col = getvcol(&Curpos, 2);
X		for (i = 0; i < y_size; ++i)
X		{
X			startspaces = 0;
X			endspaces = 0;
X			textcol = 0;
X			vcol = 0;
X			delchar = 0;
X
X		/* add a new line */
X			if (Curpos.lnum > line_count)
X			{
X				ep = alloc_line(0);
X				if (ep == NULL)
X						goto error;
X				appendline(line_count, ep);
X				++nlines;
X			}
X			ptr = nr2ptr(Curpos.lnum);
X			while (vcol < col && *ptr)
X			{
X				/* Count a tab for what it's worth (if list mode not on) */
X				incr = chartabsize(*ptr, vcol);
X				vcol += incr;
X				++ptr;
X				++textcol;
X			}
X			if (vcol < col)	/* line too short, padd with spaces */
X			{
X				startspaces = col - vcol;
X			}
X			else if (vcol > col)
X			{
X				endspaces = vcol - col;
X				startspaces = incr - endspaces;
X				--textcol;
X				delchar = 1;
X			}
X			newlen = strlen(y_array[i]);
X			totlen = count * newlen + startspaces + endspaces;
X			if (!canincrease(totlen))
X				break;
X			ptr = nr2ptr(Curpos.lnum) + textcol;
X
X		/* move the text after the cursor to the end of the line. */
X			memmove(ptr + totlen - delchar, ptr, strlen(ptr) + 1);
X		/* may insert some spaces before the new text */
X			copy_spaces(ptr, (size_t)startspaces);
X			ptr += startspaces;
X		/* insert the new text */
X			for (j = 0; j < count; ++j)
X			{
X					strncpy(ptr, y_array[i], (size_t)newlen);
X					ptr += newlen;
X			}
X		/* may insert some spaces after the new text */
X			copy_spaces(ptr, (size_t)endspaces);
X
X			++Curpos.lnum;
X			if (i == 0)
X				Curpos.col += startspaces;
X		}
X		endop.lnum = Curpos.lnum - 1;		/* for "']" command */
X		endop.col = textcol + totlen - 1;
X		Curpos.lnum = lnum;
X		cursupdate();
X		updateScreen(VALID_TO_CURSCHAR);
X	}
X	else		/* not block mode */
X	{
X		if (y_type == MCHAR)
X		{
X	/* if type is MCHAR, FORWARD is the same as BACKWARD on the next character */
X			if (dir == FORWARD && gcharCurpos() != NUL)
X			{
X				++col;
X				if (newlen)
X				{
X					++Curpos.col;
X					++endop.col;
X				}
X			}
X			newCurpos = Curpos;
X		}
X		else if (dir == BACKWARD)
X	/* if type is MLINE, BACKWARD is the same as FORWARD on the previous line */
X			--lnum;
X		else	/* type == MLINE, dir == FORWARD */
X		{
X			startop.col = 0;
X			startop.lnum++;
X		}
X
X/*
X * simple case: insert into current line
X */
X		if (y_type == MCHAR && y_size == 1)
X		{
X			i = count * newlen;
X			if (!canincrease((int)i))
X					return; 				/* alloc() will give error message */
X			ep = nr2ptr(lnum) + col;
X			memmove(ep + i, ep, strlen(ep) + 1);
X			Curpos.col += i - 1;		/* put cursor on last putted char */
X			for (i = 0; i < count; ++i)
X			{
X					strncpy(ep, y_array[0], (size_t)newlen);
X					ep += newlen;
X			}
X			endop = Curpos;
X			updateline();
X		}
X		else
X		{
X			if (y_type == MCHAR)
X				--y_size;
X			while (--count >= 0)
X			{
X				i = 0;
X				if (y_type == MCHAR)
X				{
X					/*
X					 * Split the current line in two at the insert position.
X					 * Append y_array[0] to first line.
X					 * Insert y_array[size - 1] in front of second line.
X					 */
X					ptr = nr2ptr(lnum) + col;
X					col = strlen(y_array[y_size]);
X					ep = alloc_line((unsigned)(strlen(ptr) + col));
X					if (ep == NULL)
X						goto error;
X					strcpy(ep, y_array[y_size]);
X					strcat(ep, ptr);
X					appendline(lnum, ep);			/* insert in second line */
X					++nlines;
X					*ptr = NUL;
X					Curpos.lnum = lnum;
X					if (!canincrease(newlen))		/* lnum == Curpos.lnum! */
X						goto error;
X					strcat(nr2ptr(lnum), y_array[0]);/* append to first line */
X					i = 1;
X				}
X
X				while (i < y_size)
X				{
X					ep = save_line(y_array[i++]);
X					if (ep == NULL)
X						goto error;
X					appendline(lnum++, ep);
X					++nlines;
X				}
X				if (y_type == MCHAR)
X					++lnum; 	/* lnum is now number of line below inserted lines */
X			}
X
X			endop.lnum = lnum;		/* for "']" command */
X			if (y_type == MLINE)
X			{
X				Curpos.col = 0;
X				endop.col = 0;
X				if (dir == FORWARD)
X				{
X					updateScreen(NOT_VALID);		/* recompute Botline */
X					++Curpos.lnum;
X				}
X					/* put cursor on first non-blank in last inserted line */
X				beginline(TRUE);
X			}
X			else		/* put cursor on first inserted character */
X			{
X				if (col > 1)
X					endop.col = col - 1;
X				else
X					endop.col = 0;
X				Curpos = newCurpos;
X			}
X
Xerror:
X			updateScreen(CURSUPD);
X		}
X	}
X
X	msgmore(nlines);
X	set_want_col = TRUE;
X}
X
X/*
X * display the contents of the yank buffers
X */
X	void
Xdodis()
X{
X	register int i, n;
X	register long j;
X	register char *p;
X	register struct yankbuf *yb;
X
X#ifdef AMIGA
X	settmode(0);			/* set cooked mode so output can be halted */
X#endif
X	for (i = -1; i < 36; ++i)
X	{
X		if (i == -1)
X		{
X			if (y_previous != NULL)
X				yb = y_previous;
X			else
X				yb = &(y_buf[0]);
X		}
X		else
X			yb = &(y_buf[i]);
X		if (yb->y_array != NULL)
X		{
X			if (i == -1)
X				outstrn("pP");
X			else
X			{
X				outchar('"');
X				if (i < 10)
X					outchar(i + '0');
X				else
X					outchar(i + 'a' - 10);
X			}
X			outchar(' ');
X
X			n = Columns - 4;
X			for (j = 0; j < yb->y_size && n > 0; ++j)
X			{
X				if (j)
X				{
X					outstrn("^J");
X					n -= 2;
X				}
X				for (p = yb->y_array[j]; *p && n > 0; ++p)
X				{
X					outstrn(transchar(*p));
X					n -= charsize(*p);
X				}
X			}
X			outchar('\n');
X			flushbuf();
X		}
X	}
X#ifdef AMIGA
X	settmode(1);
X#endif
X	wait_return(TRUE);
X}
X
X/*
X * join 'count' lines (minimal 2), including u_save()
X */
X	void
Xdodojoin(count, flag, redraw)
X	long	count;
X	int		flag;
X	int		redraw;
X{
X	if (!u_save((linenr_t)(Curpos.lnum - 1), (linenr_t)(Curpos.lnum + count)))
X		return;
X
X	while (--count > 0)
X		if (!dojoin(flag))
X		{
X				beep();
X				break;
X		}
X
X	if (redraw)
X		updateScreen(VALID_TO_CURSCHAR);
X}
X
X	int
Xdojoin(insert_space)
X	int			insert_space;
X{
X	char		*curr;
X	char		*next;
X	char		*endcurr;
X	int 		currsize;		/* size of the current line */
X	int 		nextsize;		/* size of the next line */
X	int			spaces;			/* number of spaces to insert */
X	int			rows_to_del;	/* number of rows on screen to delete */
X	linenr_t	t;
X
X	if (Curpos.lnum == line_count)		/* on last line */
X		return FALSE;
X
X	rows_to_del = plines_m(Curpos.lnum, Curpos.lnum + 1);
X	curr = nr2ptr(Curpos.lnum);
X	currsize = strlen(curr);
X	next = nr2ptr((linenr_t)(Curpos.lnum + 1));
X	spaces = 0;
X	if (insert_space)
X	{
X		skipspace(&next);
X		spaces = 1;
X		if (*next == ')' || currsize == 0)
X			spaces = 0;
X		else
X		{
X			endcurr = curr + currsize - 1;
X			if (*endcurr == ' ' || *endcurr == TAB)
X			{
X				spaces = 0;
X				if (currsize > 1)
X					--endcurr;
X			}
X			if (p_js && strchr(".!?", *endcurr) != NULL)
X				++spaces;
X		}
X	}
X	nextsize = strlen(next);
X	if (!canincrease(nextsize + spaces))
X		return FALSE;
X
X	curr = nr2ptr(Curpos.lnum); /* canincrease() will have changed the pointer */
X
X	while (spaces)
X	{
X		*(curr + currsize++) = ' ';
X		--spaces;
X	}
X	strcpy(curr + currsize, next);
X
X	/*
X	 * Delete the following line. To do this we move the cursor there
X	 * briefly, and then move it back.
X	 */
X	t = Curpos.lnum;
X	++Curpos.lnum;
X	dellines(1L, FALSE);
X	Curpos.lnum = t;
X
X	/*
X	 * the number of rows on the screen is reduced by the difference
X	 * in number of rows of the two old lines and the one new line
X	 */
X	rows_to_del -= plines(Curpos.lnum);
X	if (rows_to_del > 0)
X		s_del(Cursrow, rows_to_del, TRUE);
X
X	if (currsize == 0)
X		Curpos.col = 0;
X	else
X	{
X		Curpos.col = currsize - 1;
X		oneright(); 	/* go to first char. of joined line */
X	}
X	CHANGED;
X
X	return TRUE;
X}
X
X/*
X * implementation of the format operator 'V'
X */
X	void
Xdoformat()
X{
X		/* prepare undo and join the lines */
X	dodojoin((long)endop.lnum - (long)startop.lnum + 1, TRUE, FALSE);
X
X		/* put cursor on last non-space */
X	coladvance(29999);
X	while (Curpos.col && isspace(gcharCurpos()))
X		decCurpos();
X	curs_columns();			/* update Cursvcol */
X
X		/* do the formatting */
X	State = INSERT;		/* for Opencmd() */
X	insertchar(NUL);
X	State = NORMAL;
X	updateScreen(NOT_VALID);
X}
X
X	void
Xstartinsert(initstr, startln, count)
X	int			initstr;
X	int 		startln;		/* if set, insert at start of line */
X	long 		count;
X{
X	Insstart = Curpos;
X	if (startln)
X		Insstart.col = 0;
X
X	if (initstr != NUL)
X	{
X			ResetBuffers();
X			AppendNumberToRedobuff(count);
X			AppendToRedobuff(mkstr(initstr));
X	}
X
X	if (initstr == 'R')
X		State = REPLACE;
X	else
X		State = INSERT;
X
X	if (p_mo)
X		showmode();
X
X	edit(count);
X}
X
X/*
X * prepare a few things for block mode yank/delete/tilde
X *
X * for delete:
X * - textlen includes the first/last char to be (partly) deleted
X * - start/endspaces is the number of columns that are taken by the
X *	 first/last deleted char minus the number of columns that have to be deleted.
X * for yank and tilde:
X * - textlen includes the first/last char to be wholly yanked
X * - start/endspaces is the number of columns of the first/last yanked char
X *   that are to be yanked.
X */
X	static void
Xblock_prep(lnum, delete)
X	linenr_t	lnum;
X	int			delete;
X{
X	int			vcol;
X	int			incr = 0;
X	char		*pend;
X
X	startspaces = 0;
X	endspaces = 0;
X	textlen = 0;
X	textcol = 0;
X	vcol = 0;
X	textstart = nr2ptr(lnum);
X	while (vcol < startvcol && *textstart)
X	{
X		/* Count a tab for what it's worth (if list mode not on) */
X		incr = chartabsize(*textstart, vcol);
X		vcol += incr;
X		++textstart;
X		++textcol;
X	}
X	if (vcol < startvcol)	/* line too short */
X	{
X		if (!delete)
X			endspaces = endvcol - startvcol + 1;
X	}
X	else /* vcol >= startvcol */
X	{
X		startspaces = vcol - startvcol;
X		if (delete && vcol > startvcol)
X			startspaces = incr - startspaces;
X		pend = textstart;
X		while (vcol <= endvcol && *pend)
X		{
X			/* Count a tab for what it's worth (if list mode not on) */
X			incr = chartabsize(*pend, vcol);
X			vcol += incr;
X			++pend;
X		}
X		if (vcol < endvcol && !delete)	/* line too short */
X		{
X			endspaces = endvcol - vcol;
X		}
X		else if (vcol > endvcol)
X		{
X			if (delete)
X				endspaces = vcol - endvcol - 1;
X			else if (pend != textstart)
X			{
X				endspaces = incr - (vcol - endvcol);
X				if (endspaces)
X					--pend;
X			}
X		}
X		if (delete && startspaces)
X		{
X			--textstart;
X			--textcol;
X		}
X		textlen = pend - textstart;
X	}
X}
X
X	int
Xdoaddsub(c, Prenum1)
X	int			c;
X	linenr_t	Prenum1;
X{
X	register int 	col;
X	char			buf[30];
X	int				hex;		/* 'x' or 'X': hexadecimal; '0': octal */
X	static int		hexupper = FALSE;	/* 0xABC */
X	long			n;
X	char			*ptr;
X
X	ptr = nr2ptr(Curpos.lnum);
X	col = Curpos.col;
X
X		/* first check if we are on a hexadecimal number */
X	while (col > 0 && isxdigit(ptr[col]))
X		--col;
X	if (col > 0 && toupper(ptr[col]) == 'X' && ptr[col - 1] == '0' && isxdigit(ptr[col + 1]))
X		--col;		/* found hexadecimal number */
X	else
X	{
X		/* first search forward and then backward for start of number */
X		col = Curpos.col;
X
X		while (ptr[col] != NUL && !isdigit(ptr[col]))
X			++col;
X
X		while (col > 0 && isdigit(ptr[col - 1]))
X			--col;
X	}
X
X	if (isdigit(ptr[col]) && u_saveCurpos())
X	{
X		set_want_col = TRUE;
X
X		if (ptr[col] != '0')
X			hex = 0;				/* decimal */
X		else
X		{
X			hex = toupper(ptr[col + 1]);		/* assume hexadecimal */
X			if (hex != 'X' || !isxdigit(ptr[col + 2]))
X			{
X				if (isdigit(hex))
X					hex = '0';		/* octal */
X				else
X					hex = 0;		/* 0 by itself is decimal */
X			}
X		}
X
X		if (!hex && col > 0 && ptr[col - 1] == '-')
X			--col;
X
X		ptr += col;
X		if (hex == '0')
X			sscanf(ptr, "%lo", &n);
X		else if (hex)
X			sscanf(ptr, "%lx", &n);	/* "%X" doesn't work! */
X		else
X			n = atol(ptr);
X
X		if (c == Ctrl('A'))
X			n += Prenum1;
X		else
X			n -= Prenum1;
X
X		if (hex == 'X')					/* skip the '0x' */
X			col += 2;
X		Curpos.col = col;
X		do								/* delete the old number */
X		{
X			if (isalpha(c))
X			{
X				if (isupper(c))
X					hexupper = TRUE;
X				else
X					hexupper = FALSE;
X			}
X			delchar(FALSE);
X			c = gcharCurpos();
X		}
X		while (hex ? (hex == '0' ? c >= '0' && c <= '7' : isxdigit(c)) : isdigit(c));
X
X		if (hex == '0')
X			sprintf(buf, "0%lo", n);
X		else if (hexupper)
X			sprintf(buf, "%lX", n);
X		else if (hex)
X			sprintf(buf, "%lx", n);
X		else
X			sprintf(buf, "%ld", n);
X		insstr(buf);					/* insert the new number */
X		--Curpos.col;
X		updateline();
X		return TRUE;
X	}
X	else
X	{
X		beep();
X		return FALSE;
X	}
X}
END_OF_FILE
if test 28332 -ne `wc -c <'vim/src/ops.c'`; then
    echo shar: \"'vim/src/ops.c'\" unpacked with wrong size!
fi
# end of 'vim/src/ops.c'
fi
if test -f 'vim/src/search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/search.c'\"
else
echo shar: Extracting \"'vim/src/search.c'\" \(21652 characters\)
sed "s/^X//" >'vim/src/search.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony
X *							G. R. (Fred) Walter     watmath!watcgl!grwalter
X */
X/*
X * search.c: code for normal mode searching commands
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
X/* modified Henry Spencer's regular expression routines */
X#include "regexp.h"
X
Xstatic int inmacro __ARGS((char *, char *));
Xstatic int cls __ARGS((void));
X
X/*
X * This file contains various searching-related routines. These fall into
X * three groups:
X * 1. string searches (for /, ?, n, and N)
X * 2. character searches within a single line (for f, F, t, T, etc)
X * 3. "other" kinds of searches like the '%' command, and 'word' searches.
X */
X
X/*
X * String searches
X *
X * The string search functions are divided into two levels:
X * lowest:	searchit(); called by dosearch() and docmdline().
X * Highest: dosearch(); changes Curpos, called by normal().
X *
X * The last search pattern is remembered for repeating the same search.
X * This pattern is shared between the :g, :s, ? and / commands.
X * This is in myregcomp().
X *
X * The actual string matching is done using a heavily modified version of
X * Henry Spencer's regular expression library.
X */
X
Xstatic char 	*search_pattern = NULL;  /* previous search pattern */
Xstatic int		want_start; 			 /* looking for start of line? */
X
X/*
X * translate search pattern for regcomp()
X */
X	regexp *
Xmyregcomp(pat)
X	char *pat;
X{
X	regexp *retval;
X
X	if (pat == NULL || *pat == NUL)     /* use previous search pattern */
X	{
X		if (search_pattern == NULL)
X		{
X			emsg(e_noprevre);
X			return (regexp *) NULL;
X		}
X		pat = search_pattern;
X	}
X	else
X	{
X		if (search_pattern != NULL)
X			free(search_pattern);
X		search_pattern = strsave(pat);
X		reg_magic = p_magic;		/* Magic sticks with the r.e. */
X	}
X	want_start = (*pat == '^');		/* looking for start of line? */
X	reg_ic = p_ic;				/* tell the regexec routine how to search */
X	retval = regcomp(pat);
X	return retval;
X}
X
X/*
X * lowest level search function.
X * Search for 'count'th occurrence of 'str' in direction 'dir'.
X * Start at position 'pos' and return the found position in 'pos'.
X * Return 1 for success, 0 for failure.
X */
X	int
Xsearchit(pos, dir, str, count, end)
X	FPOS	*pos;
X	int 	dir;
X	char	*str;
X	long	count;
X	int		end;
X{
X	int 			found;
X	linenr_t		lnum;
X	linenr_t		startlnum;
X	regexp		   *prog;
X	register char  *s;
X	char		   *ptr;
X	register int	i;
X	register char  *match, *matchend;
X	int 			loop;
X
X	if ((prog = myregcomp(str)) == NULL)
X	{
X		emsg(e_invstring);
X		return 0;
X	}
X/*
X * find the string
X */
X	found = 1;
X	while (count-- && found)    /* stop after count matches, or no more matches */
X	{
X		startlnum = pos->lnum;	/* remember start of search for detecting no match */
X		found = 0;				/* default: not found */
X
X		i = pos->col + dir; 	/* search starts one postition away */
X		lnum = pos->lnum;
X
X		if (dir == BACKWARD)
X		{
X			if (i < 0)
X				--lnum;
X		}
X
X		for (loop = 0; loop != 2; ++loop)   /* do this twice if 'wrapscan' is set */
X		{
X			for ( ; lnum > 0 && lnum <= line_count; lnum += dir, i = -1)
X			{
X				s = ptr = nr2ptr(lnum);
X				if (dir == FORWARD && i > 0)    /* first line for forward search */
X				{
X					if (want_start || strlen(s) <= (size_t)i)   /* match not possible */
X						continue;
X					s += i;
X				}
X
X				if (regexec(prog, s, dir == BACKWARD || i <= 0))
X				{							/* match somewhere on line */
X					match = prog->startp[0];
X					matchend = prog->endp[0];
X					if (dir == BACKWARD && !want_start)
X					{
X						/*
X						 * Now, if there are multiple matches on this line, we have to
X						 * get the last one. Or the last one before the cursor, if we're
X						 * on that line.
X						 */
X						while (regexec(prog, prog->startp[0] + 1, (int)FALSE))
X						{
X							if ((i >= 0) && ((prog->startp[0] - s) > i))
X								break;
X							match = prog->startp[0];
X							matchend = prog->endp[0];
X						}
X
X						if ((i >= 0) && ((match - s) > i))
X							continue;
X					}
X
X					pos->lnum = lnum;
X					if (end)
X						pos->col = (int) (matchend - ptr - 1);
X					else
X						pos->col = (int) (match - ptr);
X					found = 1;
X					break;
X				}
X				/* breakcheck is slow, do it only once in 16 lines */
X				if ((lnum & 15) == 0)
X					breakcheck();       /* stop if ctrl-C typed */
X				if (got_int)
X					break;
X
X				if (loop && lnum == startlnum)  /* if second loop stop where started */
X					break;
X			}
X	/* stop the search if wrapscan isn't set, after an interrupt and after a match */
X			if (!p_ws || got_int || found)
X				break;
X
X			if (dir == BACKWARD)    /* start second loop at the other end */
X				lnum = line_count;
X			else
X				lnum = 1;
X		}
X		if (got_int)
X			break;
X	}
X
X	free((char *) prog);
X
X	if (!found)             /* did not find it */
X	{
X		if (got_int)
X				emsg(e_interr);
X		else
X				emsg(e_patnotf);
X		return 0;
X	}
X
X	return 1;
X}
X
X/*
X * Highest level string search function.
X * Search for the 'count'th occurence of string 'str' in direction 'dir'
X *					 If 'dir' is 0: use previous dir.
X * If 'str' is 0 or 'str' is empty: use previous string.
X *			  If 'reverse' is TRUE: go in reverse of previous dir.
X *				 If 'echo' is TRUE: echo the search command
X */
X	int
Xdosearch(dir, str, reverse, count, echo)
X	int				dir;
X	char		   *str;
X	int				reverse;
X	long			count;
X	int				echo;
X{
X	FPOS			pos;		/* position of the last match */
X	int				dirc;
X	static int		lastsdir = FORWARD;	/* previous search direction */
X	static int		lastoffline;/* previous/current search has line offset */
X	static int		lastend;	/* previous/current search set cursor at end */
X	static long 	lastoff;	/* previous/current line or char offset */
X	static int		nosetpm;    /* do not call setpcmark() */
X	register char	*p;
X	register long	c;
X	char			*dircp = NULL;
X
X	if (dir == 0)
X		dir = lastsdir;
X	else
X		lastsdir = dir;
X	if (reverse)
X		dir = -dir;
X
X	dirc = (dir == FORWARD ? '/' : '?');
X	if (str == NULL || *str == NUL)     /* use previous string and options */
X	{
X		if (search_pattern == NULL)
X		{
X			emsg(e_noprevre);
X			return 0;
X		}
X		str = "";
X	}
X	else
X	{
X		/* If there is a matching '/' or '?', toss it */
X		for (p = str; *p; ++p)
X		{
X			if (*p == dirc)
X			{
X				dircp = p;		/* remember where we put the NUL */
X				*p++ = NUL;
X				break;
X			}
X			if (*p == '\\' && p[1] != NUL)
X				++p;	/* skip next character */
X		}
X
X		lastoffline = FALSE;
X		lastend = FALSE;
X		nosetpm = FALSE;
X		lastoff = 0;
X		switch (*p)
X		{
X			case 'n':   nosetpm = TRUE; /* do not call setpcmark() */
X						++p;
X						break;
X			case '+':
X			case '-':                   /* got a line offset */
X						lastoffline = TRUE;
X						break;
X			case 'e':                   /* position cursor at end */
X						lastend = TRUE;
X			case 's':                   /* got a character offset from start */
X						++p;
X		}
X		if (*p == '+' || *p == '-')     /* got an offset */
X		{
X			lastoff = atol(p);
X			++p;						/* skip number */
X			while (isdigit(*p))
X				++p;
X		}
X		searchcmdlen = p - str;			/* compute lenght of search command
X														for get_address() */
X	}
X
X	if (echo)
X	{
X		smsg("%c%s", dirc, *str == NUL ? search_pattern : str);
X		if (lastoffline || lastend || lastoff || nosetpm)
X		{
X			outchar(dirc);
X			if (nosetpm)
X				outchar('n');
X			else if (lastend)
X				outchar('e');
X			else if (!lastoffline)
X				outchar('s');
X			if (lastoff < 0)
X			{
X				outchar('-');
X				outnum((long)-lastoff);
X			}
X			else if (lastoff > 0 || lastoffline)
X			{
X				outchar('+');
X				outnum((long)lastoff);
X			}
X		}
X
X		gotocmdline(FALSE, NUL);
X		flushbuf();
X	}
X
X	pos = Curpos;
X
X	c = searchit(&pos, dir, str, count, lastend);
X	if (dircp)
X		*dircp = dirc;		/* put second '/' or '?' back for normal() */
X	if (!c)
X		return 0;
X
X	if (!lastoffline)           /* add the character offset to the column */
X	{
X		if (lastoff > 0)        /* offset to the right, check for end of line */
X		{
X			p = pos2ptr(&pos) + 1;
X			c = lastoff;
X			while (c-- && *p++ != NUL)
X				++pos.col;
X		}
X		else					/* offset to the left, check for start of line */
X		{
X			if ((c = pos.col + lastoff) < 0)
X				c = 0;
X			pos.col = c;
X		}
X	}
X
X	if (!nosetpm)
X		setpcmark();
X	Curpos = pos;
X	set_want_col = TRUE;
X
X	if (!lastoffline)
X		return 1;
X
X/*
X * add the offset to the line number.
X */
X	c = Curpos.lnum + lastoff;
X	if (c < 1)
X		Curpos.lnum = 1;
X	else if (c > line_count)
X		Curpos.lnum = line_count;
X	else
X		Curpos.lnum = c;
X	Curpos.col = 0;
X
X	return 2;
X}
X
X
X/*
X * Character Searches
X */
X
X/*
X * searchc(c, dir, type, count)
X *
X * Search for character 'c', in direction 'dir'. If 'type' is 0, move to the
X * position of the character, otherwise move to just before the char.
X * Repeat this 'count' times.
X */
X	int
Xsearchc(c, dir, type, count)
X	int 			c;
X	register int	dir;
X	int 			type;
X	long			count;
X{
X	static char 	lastc = NUL;	/* last character searched for */
X	static int		lastcdir;		/* last direction of character search */
X	static int		lastctype;		/* last type of search ("find" or "to") */
X	register int	col;
X	char			*p;
X	int 			len;
X
X	if (c != NUL)       /* normal search: remember args for repeat */
X	{
X		lastc = c;
X		lastcdir = dir;
X		lastctype = type;
X	}
X	else				/* repeat previous search */
X	{
X		if (lastc == NUL)
X			return FALSE;
X		if (dir)        /* repeat in opposite direction */
X			dir = -lastcdir;
X		else
X			dir = lastcdir;
X	}
X
X	p = nr2ptr(Curpos.lnum);
X	col = Curpos.col;
X	len = strlen(p);
X
X	/*
X	 * On 'to' searches, skip one to start with so we can repeat searches in
X	 * the same direction and have it work right.
X	 * REMOVED to get vi compatibility
X	 * if (lastctype)
X	 *	col += dir;
X	 */
X
X	while (count--)
X	{
X			for (;;)
X			{
X				if ((col += dir) < 0 || col >= len)
X					return FALSE;
X				if (p[col] == lastc)
X						break;
X			}
X	}
X	if (lastctype)
X		col -= dir;
X	Curpos.col = col;
X	return TRUE;
X}
X
X/*
X * "Other" Searches
X */
X
X/*
X * showmatch - move the cursor to the matching paren or brace
X */
X	FPOS		   *
Xshowmatch()
X{
X	static FPOS pos;
X	char		initc;		/* char under cursor */
X	char		findc;		/* matching char */
X	char		c;
X	int 		count = 0;
X	int 		i;
X	static char table[6] = {'(', ')', '[', ']', '{', '}'};
X	int 		inquote = 0;
X	register char		*p;
X
X	pos = Curpos;
X
X	for (p = nr2ptr(pos.lnum); ;++pos.col)
X	{
X		if ((initc = p[pos.col]) == NUL)
X			return (FPOS *) NULL;
X		for (i = 0; i < 6; ++i)
X			if (table[i] == initc)
X				goto foundit;
X	}
X
Xfoundit:
X	if (i & 1)                  /* backward search */
X		findc = table[i - 1];
X	else						/* forward search */
X		findc = table[i + 1];
X	i &= 1;
X
X	/* we only do a breakcheck() once for every 16 lines */
X	while (!got_int)
X	{
X			/* we could use inc() and dec() here, but that is much slower */
X		if (i)              /* backward search */
X		{
X			if (pos.col == 0)   /* at start of line, go to previous one */
X			{
X				if (pos.lnum == 1)      /* start of file */
X					break;
X				--pos.lnum;
X				p = nr2ptr(pos.lnum);
X				pos.col = strlen(p);
X				if ((pos.lnum & 15) == 0)
X					breakcheck();
X			}
X			else
X				--pos.col;
X		}
X		else					/* forward search */
X		{
X			if (p[pos.col] == NUL)  /* at end of line, go to next one */
X			{
X				if (pos.lnum == line_count) /* end of file */
X					break;
X				++pos.lnum;
X				pos.col = 0;
X				p = nr2ptr(pos.lnum);
X				if ((pos.lnum & 15) == 0)
X					breakcheck();
X			}
X			else
X				++pos.col;
X		}
X
X		/*
X		 * anything that is preceded with a backslash is ignored
X		 */
X		if (pos.col == 0 || p[pos.col - 1] != '\\')
X		{
X		/*
X		 * Things inside quotes are ignored by setting 'inquote'.
X		 * If we find a quote without a preceding '\' invert 'inquote'.
X		 * At the end of a line not ending in '\' we reset 'inquote'.
X		 */
X			switch (c = p[pos.col])
X			{
X			case NUL:
X				inquote = FALSE;
X				break;
X
X			case '"':
X				inquote = !inquote;
X				break;
X
X			/*
X			 * Skip things in single quotes: 'x' or '\x'.
X			 * Be careful for single single quotes, eg jon's.
X			 * Things like '\233' or '\x3f' are ok, there is no brace in it.
X			 */
X			case '\'':
X				if (i)						/* backward search */
X				{
X					if (pos.col > 1)
X					{
X						if (p[pos.col - 2] == '\'')
X							pos.col -= 2;
X						else if (p[pos.col - 2] == '\\' && pos.col > 2 && p[pos.col - 3] == '\'')
X							pos.col -= 3;
X					}
X				}
X				else if (p[pos.col + 1])	/* forward search */
X				{
X					if (p[pos.col + 1] == '\\' && p[pos.col + 2] && p[pos.col + 3] == '\'')
X						pos.col += 3;
X					else if (p[pos.col + 2] == '\'')
X						pos.col += 2;
X				}
X				break;
X
X			default:
X				if (!inquote)      /* only check for match outside of quotes */
X				{
X					if (c == initc)
X						count++;
X					else if (c == findc)
X					{
X						if (count == 0)
X							return &pos;
X						count--;
X					}
X				}
X			}
X		}
X	}
X	return (FPOS *) NULL;       /* never found it */
X}
X
X/*
X * findfunc(dir, what) - Find the next line starting with 'what' in direction 'dir'
X *
X * Return TRUE if a line was found.
X */
X	int
Xfindfunc(dir, what, count)
X	int 		dir;
X	int			what;
X	long		count;
X{
X	linenr_t	curr;
X
X	curr = Curpos.lnum;
X
X	for (;;)
X	{
X		if (dir == FORWARD)
X		{
X				if (curr++ == line_count)
X						break;
X		}
X		else
X		{
X				if (curr-- == 1)
X						break;
X		}
X
X		if (*nr2ptr(curr) == what)
X		{
X			if (--count > 0)
X				continue;
X			setpcmark();
X			Curpos.lnum = curr;
X			Curpos.col = 0;
X			return TRUE;
X		}
X	}
X
X	return FALSE;
X}
X
X/*
X * findsent(dir, count) - Find the start of the next sentence in direction 'dir'
X * Sentences are supposed to end in ".", "!" or "?" followed by white space,
X * or at an empty line.
X * Return TRUE if the next sentence was found.
X */
X	int
Xfindsent(dir, count)
X		int 	dir;
X		long	count;
X{
X		FPOS			pos, tpos;
X		register int	c;
X		int 			(*func) __PARMS((FPOS *));
X		int 			startlnum;
X
X		pos = Curpos;
X		if (dir == FORWARD)
X				func = incl;
X		else
X				func = decl;
X
X		while (count--)
X		{
X				/* if on an empty line, skip upto a non-empty line */
X				if (gchar(&pos) == NUL)
X				{
X						do
X								if ((*func)(&pos) == -1)
X										break;
X						while (gchar(&pos) == NUL);
X						if (dir == FORWARD)
X								goto found;
X				}
X				/* if on the start of a paragraph or a section and searching
X				 * forward, go to the next line */
X				else if (dir == FORWARD && pos.col == 0 && startPS(pos.lnum, NUL))
X				{
X						if (pos.lnum == line_count)
X							return FALSE;
X						++pos.lnum;
X						goto found;
X				}
X				else if (dir == BACKWARD)
X						decl(&pos);
X
X				/* go back to the previous non-blank char */
X				while ((c = gchar(&pos)) == ' ' || c == '\t' ||
X						(dir == BACKWARD && strchr(".!?)]\"'", c) != NULL))
X						if (decl(&pos) == -1)
X								break;
X
X				/* remember the line where the search started */
X				startlnum = pos.lnum;
X
X				for (;;)                /* find end of sentence */
X				{
X						if ((c = gchar(&pos)) == NUL ||
X								(pos.col == 0 && startPS(pos.lnum, NUL)))
X						{
X							if (dir == BACKWARD && pos.lnum != startlnum)
X								++pos.lnum;
X							break;
X						}
X						if (c == '.' || c == '!' || c == '?')
X						{
X								tpos = pos;
X								do
X									if ((c = inc(&tpos)) == -1)
X										break;
X								while (strchr(")}\"'", c = gchar(&tpos)) != NULL);
X								if (c == -1  || c == ' ' || c == '\t' || c == NUL)
X								{
X										pos = tpos;
X										if (gchar(&pos) == NUL) /* skip NUL at EOL */
X												inc(&pos);
X										break;
X								}
X						}
X						if ((*func)(&pos) == -1)
X						{
X								if (count)
X										return FALSE;
X								break;
X						}
X				}
Xfound:
X				/* skip white space */
X				while ((c = gchar(&pos)) == ' ' || c == '\t')
X						if (incl(&pos) == -1)
X								break;
X		}
X
X		Curpos = pos;
X		setpcmark();
X		return TRUE;
X}
X
X/*
X * findpar(dir, count, what) - Find the next paragraph in direction 'dir'
X * Paragraphs are currently supposed to be separated by empty lines.
X * Return TRUE if the next paragraph was found.
X * If 'what' is '{' or '}' we go to the next section.
X */
X	int
Xfindpar(dir, count, what)
X	register int	dir;
X	long			count;
X	int 			what;
X{
X	register linenr_t	curr;
X	int					did_skip;		/* TRUE after separating lines have
X												been skipped */
X	int					first;			/* TRUE on first line */
X
X	curr = Curpos.lnum;
X
X	while (count--)
X	{
X		did_skip = FALSE;
X		for (first = TRUE; ; first = FALSE)
X		{
X				if (*nr2ptr(curr) != NUL)
X					did_skip = TRUE;
X
X				if (!first && did_skip && startPS(curr, what))
X					break;
X
X				if ((curr += dir) < 1 || curr > line_count)
X				{
X						if (count)
X								return FALSE;
X						curr -= dir;
X						break;
X				}
X		}
X	}
X	setpcmark();
X	Curpos.lnum = curr;
X	if (curr == line_count)
X	{
X		if ((Curpos.col = strlen(nr2ptr(curr))) != 0)
X				--Curpos.col;
X	}
X	else
X		Curpos.col = 0;
X	return TRUE;
X}
X
X/*
X * check if the string 's' is a nroff macro that is in option 'opt'
X */
X	static int
Xinmacro(opt, s)
X		char *opt;
X		register char *s;
X{
X		register char *macro;
X
X		for (macro = opt; macro[0]; ++macro)
X		{
X				if (macro[0] == s[0] && (((s[1] == NUL || s[1] == ' ')
X						&& (macro[1] == NUL || macro[1] == ' ')) || macro[1] == s[1]))
X						break;
X				++macro;
X				if (macro[0] == NUL)
X						break;
X		}
X		return (macro[0] != NUL);
X}
X
X/*
X * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.
X * If 'para' is '{' or '}' only check for sections.
X */
X	int
XstartPS(lnum, para)
X	linenr_t	lnum;
X	int 		para;
X{
X	register char *s;
X
X	s = nr2ptr(lnum);
X	if ((para == NUL && *s == '{') || *s == para || *s == '\f')
X		return TRUE;
X	if (*s++ != '.')
X		return FALSE;
X	if (inmacro(p_sections, s) || (!para && inmacro(p_para, s)))
X		return TRUE;
X	else
X		return FALSE;
X}
X
X/*
X * The following routines do the word searches performed by the 'w', 'W',
X * 'b', 'B', 'e', and 'E' commands.
X */
X
X/*
X * To perform these searches, characters are placed into one of three
X * classes, and transitions between classes determine word boundaries.
X *
X * The classes are:
X *
X * 0 - white space
X * 1 - letters, digits and underscore
X * 2 - everything else
X */
X
Xstatic int		stype;			/* type of the word motion being performed */
X
X/*
X * cls() - returns the class of character at Curpos
X *
X * The 'type' of the current search modifies the classes of characters if a 'W',
X * 'B', or 'E' motion is being done. In this case, chars. from class 2 are
X * reported as class 1 since only white space boundaries are of interest.
X */
X	static int
Xcls()
X{
X	register int c;
X
X	c = gcharCurpos();
X	if (c == ' ' || c == '\t' || c == NUL)
X		return 0;
X
X	if (isidchar(c))
X		return 1;
X
X	/*
X	 * If stype is non-zero, report these as class 1.
X	 */
X	return (stype == 0) ? 2 : 1;
X}
X
X
X/*
X * fwd_word(count, type) - move forward one word
X *
X * Returns TRUE if end of the file was reached.
X */
X	int
Xfwd_word(count, type)
X	long		count;
X	int 		type;
X{
X	int 		sclass; 	/* starting class */
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X
X		/*
X		 * We always move at least one character.
X		 */
X		if (incCurpos() == -1)
X			return TRUE;
X
X		if (sclass != 0)
X			if (skip_chars(sclass, FORWARD))
X				return TRUE;
X
X		/*
X		 * go to next non-white
X		 */
X		while (cls() == 0)
X		{
X			/*
X			 * We'll stop if we land on a blank line
X			 */
X			if (Curpos.col == 0 && *nr2ptr(Curpos.lnum) == NUL)
X				break;
X
X			if (incCurpos() == -1)
X				return TRUE;
X		}
X	}
X	return FALSE;
X}
X
X/*
X * bck_word(count, type) - move backward 'count' words
X *
X * Returns TRUE if top of the file was reached.
X */
X	int
Xbck_word(count, type)
X	long		count;
X	int 		type;
X{
X	int 		sclass; 	/* starting class */
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X
X		if (decCurpos() == -1)
X			return TRUE;
X
X		if (cls() != sclass || sclass == 0)
X		{
X			/*
X			 * We were at the start of a word. Go back to the end of the prior
X			 * word.
X			 */
X			while (cls() == 0)  /* skip any white space */
X			{
X				/*
X				 * We'll stop if we land on a blank line
X				 */
X				if (Curpos.col == 0 && *nr2ptr(Curpos.lnum) == NUL)
X					goto finished;
X
X				if (decCurpos() == -1)
X					return TRUE;
X			}
X			sclass = cls();
X		}
X
X		/*
X		 * Move backward to start of this word.
X		 */
X		if (skip_chars(sclass, BACKWARD))
X				return TRUE;
X
X		incCurpos();                    /* overshot - forward one */
Xfinished:
X		;
X	}
X	return FALSE;
X}
X
X/*
X * end_word(count, type, stop) - move to the end of the word
X *
X * There is an apparent bug in the 'e' motion of the real vi. At least on the
X * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'
X * motion crosses blank lines. When the real vi crosses a blank line in an
X * 'e' motion, the cursor is placed on the FIRST character of the next
X * non-blank line. The 'E' command, however, works correctly. Since this
X * appears to be a bug, I have not duplicated it here.
X *
X * Returns TRUE if end of the file was reached.
X *
X * If stop is TRUE and we are already on the end of a word, move one less.
X */
X	int
Xend_word(count, type, stop)
X	long		count;
X	int 		type;
X	int			stop;
X{
X	int 		sclass; 	/* starting class */
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X		if (incCurpos() == -1)
X			return TRUE;
X
X		/*
X		 * If we're in the middle of a word, we just have to move to the end of it.
X		 */
X		if (cls() == sclass && sclass != 0)
X		{
X			/*
X			 * Move forward to end of the current word
X			 */
X			if (skip_chars(sclass, FORWARD))
X					return TRUE;
X		}
X		else if (!stop || sclass == 0)
X		{
X			/*
X			 * We were at the end of a word. Go to the end of the next word.
X			 */
X
X			if (skip_chars(0, FORWARD))     /* skip any white space */
X				return TRUE;
X
X			/*
X			 * Move forward to the end of this word.
X			 */
X			if (skip_chars(cls(), FORWARD))
X				return TRUE;
X		}
X		decCurpos();                    /* overshot - backward one */
X		stop = FALSE;					/* we move only one word less */
X	}
X	return FALSE;
X}
X
X	int
Xskip_chars(class, dir)
X	int class;
X	int dir;
X{
X		while (cls() == class)
X			if ((dir == FORWARD ? incCurpos() : decCurpos()) == -1)
X				return 1;
X		return 0;
X}
END_OF_FILE
if test 21652 -ne `wc -c <'vim/src/search.c'`; then
    echo shar: \"'vim/src/search.c'\" unpacked with wrong size!
fi
# end of 'vim/src/search.c'
fi
echo shar: End of archive 12 \(of 23\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 23 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-------------8<----------------8<----------------8<---------------8<--------
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595450 | whatever will be accepted.

exit 0 # Just in case...
