Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v37i003:  vim - Vi IMitation editor v1.27, Part03/24
Message-ID: <1993Apr23.172908.16086@sparky.imd.sterling.com>
X-Md4-Signature: a26f1e759afb6e7150ed6ea7810fcd00
Date: Fri, 23 Apr 1993 17:29:08 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 37, Issue 3
Archive-name: vim/part03
Environment: UNIX, AMIGA, MS-DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 23)."
# Contents:  vim/doc/vim.1 vim/src/arp_proto.h vim/src/cmdtab.h
#   vim/src/cmdtab.tab vim/src/makefile.unix vim/src/param.h
#   vim/src/quickfix.c vim/src/term.h vim/src/vim.h
# Wrapped by mool@oce-rd2 on Mon Apr 19 15:50:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/vim.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/vim.1'\"
else
echo shar: Extracting \"'vim/doc/vim.1'\" \(4378 characters\)
sed "s/^X//" >'vim/doc/vim.1' <<'END_OF_FILE'
X.TH VIM 1 "28 March 1992"
X.SH NAME
Xvim \- Vi IMitation, a programmers text editor
X.SH SYNOPSIS
X.B vim
X[options] [file ..]
X.br
X.B vim
X[options] \-t tag
X.br
X.B vim
X[options] +[command] file ..
X.br
X.B vim
X[options] \-c {command} file ..
X.br
X.B vim
X[options] \-e
X.SH DESCRIPTION
X.B Vim
Xis a text editor that is upwards compatible to vi. It can be used to edit any 
XASCII text. It is especially useful for editing programs.
X.PP
XThere are a lot of enhancements above vi: multi level undo, command line 
Xediting, filename completion, on line help, quoting, etc.. Read difference.doc 
Xfor a summary of the differences between vi and Vim.
X.PP
XMost often
X.B Vim
Xis started to edit a single file with the command
X.PP
X	vim file
X.PP
XMore generally VIM is started with:
X.PP
X	vim [options] [filelist]
X.PP
XIf the filelist is missing, the editor will start with an empty buffer.
XOtherwise exactly one out of the following four may be used to choose one or
Xmore files to be edited.
X.TP 12
Xfile ..
XA list of file names. The first one (alphabetically) will be
Xthe current file and read into the buffer. The cursor will be
Xpositioned on the first line of the buffer. You can get to the other files
Xwith the ":next" command.
X.TP
X+[num] file ..
XSame as the above, but the cursor will be positioned on line
X"num". If "num" is missing, the cursor will be positioned on
Xthe last line.
X.TP
X+/pat file ..
XSame as the above, but the cursor will be positioned on the
Xfirst occurrence of "pat" in the current file (see reference.doc, 
Xsection "pattern searches" for the available search 
Xpatterns).
X.TP
X+{command} file ..
X.TP
X-c {command} file ..
XSame as the above, but {command} will be executed after the 
Xfile has been read. {command} is interpreted as an Ex 
Xcommand. If the {command} contains spaces it must 
Xbe enclosed in double quotes (this depends on the shell that 
Xis used).
XExample: Vim "+set si" main.c
X.TP
X-t {tag}
XThe file to edit and the initial cursor position depends on a "tag", a sort 
Xof goto label. {tag} is looked up in the tags file, the associated file 
Xbecomes the current file and the associated command is executed. Mostly this 
Xis used for C programs. {tag} then should be a function name. The effect is 
Xthat the file containing that function becomes the current file and the 
Xcursor is positioned on the start of the function (see reference.doc, 
Xsection "tag searches").
X.TP
X-e
XStart in quickFix mode. The error file "AztecC.Err" 
Xis read and the first error is displayed. Further errors can be jumped to 
Xwith the ":cn" command. See reference.doc section 5.6.
X.SH OPTIONS
XThe options, if present, must precede the filelist. The options may be given 
Xin any order.
X.TP 12
X-r
XRecovery mode. The autoscript file is read to recover a 
Xcrashed editing session. It has almost the same effect as 
X"-s file.vim". See reference.doc, chapter "Recovery after a crash".
X.TP
X-v
XView mode. The 'readonly' option will be set. You can still 
Xedit the buffer, but will be prevented from accidental 
Xoverwriting a file. If you do want to overwrite a file, add 
Xan exclamation mark to the Ex command, as in ":w!". The 
X'readonly' option can be reset with ":set noro" (see reference.doc, 
Xoptions chapter).
X.TP
X-n
XNo autoscript file will be written. Recovery after a crash 
Xwill be impossible. Handy if you want to edit a file on a 
Xvery slow medium (e.g. floppy). Can also be done with ":set 
Xuc=0".
X.TP
X-s {scriptin}
XThe script file {scriptin} is read. The characters in the 
Xfile are interpreted as if you had typed them. The same can 
Xbe done with the command ":source! {scriptin}". If the end 
Xof the file is reached before the editor exits, further 
Xcharacters are read from the keyboard.
X.TP
X-w {scriptout}
XAll the characters that you type are recorded in the file
X{scriptout}, until you exit VIM. This is useful if you want 
Xto create a script file to be used with "vim -s" or 
X":source!".
X.TP
X-T terminal
XTells Vim the name of the terminal you are using. Should be a terminal known 
Xto Vim (builtin) or defined in the termcap file.
X.TP
X-d device
XOpen "device" for use as a terminal. Only on the Amiga. Example:
X"\-d con:20/30/600/150".
X.SH SEE ALSO
XVim documentation: Reference.doc, index, difference.doc, unix.doc, vim.hlp.
X.SH AUTHOR
XMost of VIM was made by Bram Moolenaar.
X.br
XVIM is based on Stevie, worked on by: Tim Thompson,
XTony Andrews and G.R. (Fred) Walter
X.SH BUGS
XProbably.
END_OF_FILE
if test 4378 -ne `wc -c <'vim/doc/vim.1'`; then
    echo shar: \"'vim/doc/vim.1'\" unpacked with wrong size!
fi
# end of 'vim/doc/vim.1'
fi
if test -f 'vim/src/arp_proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/arp_proto.h'\"
else
echo shar: Extracting \"'vim/src/arp_proto.h'\" \(6655 characters\)
sed "s/^X//" >'vim/src/arp_proto.h' <<'END_OF_FILE'
X#ifndef	PROTO_ARP_H
X#define	PROTO_ARP_H	1
X
X/*
X ************************************************************************
X *	The arp copies of the dos.library calls...			*
X ************************************************************************
X */
X
X/* Only include these if you can use ARP.library without dos.library... */
X#ifdef	DO_ARP_COPIES
X#pragma	amicall(ArpBase, 0x1E, Open(d1, d2))
X#pragma	amicall(ArpBase, 0x24, Close(d1))
X#pragma	amicall(ArpBase, 0x2A, Read(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x30, Write(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x36, Input())
X#pragma	amicall(ArpBase, 0x3C, Output())
X#pragma	amicall(ArpBase, 0x42, Seek(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x48, DeleteFile(d1))
X#pragma	amicall(ArpBase, 0x4E, Rename(d1, d2))
X#pragma	amicall(ArpBase, 0x54, Lock(d1, d2))
X#pragma	amicall(ArpBase, 0x5A, UnLock(d1))
X#pragma	amicall(ArpBase, 0x60, DupLock(d1))
X#pragma	amicall(ArpBase, 0x66, Examine(d1, d2))
X#pragma	amicall(ArpBase, 0x6C, ExNext(d1, d2))
X#pragma	amicall(ArpBase, 0x72, Info(d1, d2))
X#pragma	amicall(ArpBase, 0x78, CreateDir(d1))
X#pragma	amicall(ArpBase, 0x7E, CurrentDir(d1))
X#pragma	amicall(ArpBase, 0x84, IoErr())
X#pragma	amicall(ArpBase, 0x8A, CreateProc(d1, d2, d3, d4))
X#pragma	amicall(ArpBase, 0x90, Exit(d1))
X#pragma	amicall(ArpBase, 0x96, LoadSeg(d1))
X#pragma	amicall(ArpBase, 0x9C, UnLoadSeg(d1))
X#pragma	amicall(ArpBase, 0xAE, DeviceProc(d1))
X#pragma	amicall(ArpBase, 0xB4, SetComment(d1, d2))
X#pragma	amicall(ArpBase, 0xBA, SetProtection(d1, d2))
X#pragma	amicall(ArpBase, 0xC0, DateStamp(d1))
X#pragma	amicall(ArpBase, 0xC6, Delay(d1))
X#pragma	amicall(ArpBase, 0xCC, WaitForChar(d1, d2))
X#pragma	amicall(ArpBase, 0xD2, ParentDir(d1))
X#pragma	amicall(ArpBase, 0xD8, IsInteractive(d1))
X#pragma	amicall(ArpBase, 0xDE, Execute(d1, d2, d3))
X#endif
X
X/*
X ************************************************************************
X *	Stuff only in arp.library					*
X ************************************************************************
X */
X/*	amicall(ArpBase, 0x0E4, Printf(a0, a1))	This does not work without glue */
X/*	amicall(ArpBase, 0x0EA, FPrintf(d0, a0, a1))	This does not work without glue */
X#pragma	amicall(ArpBase, 0x0F0, Puts(a1))
X#pragma	amicall(ArpBase, 0x0F6, Readline(a0))
X#pragma	amicall(ArpBase, 0x0FC, GADS(a0, d0, a1, a2, a3))
X#pragma	amicall(ArpBase, 0x102, Atol(a0))
X#pragma	amicall(ArpBase, 0x108, EscapeString(a0))
X#pragma	amicall(ArpBase, 0x10E, CheckAbort(a1))
X#pragma	amicall(ArpBase, 0x114, CheckBreak(d1, a1))
X#pragma	amicall(ArpBase, 0x11A, Getenv(a0, a1, d0))
X#pragma	amicall(ArpBase, 0x120, Setenv(a0, a1))
X#pragma	amicall(ArpBase, 0x126, FileRequest(a0))
X#pragma	amicall(ArpBase, 0x12C, CloseWindowSafely(a0, a1))
X#pragma	amicall(ArpBase, 0x132, CreatePort(a0, d0))
X#pragma	amicall(ArpBase, 0x138, DeletePort(a1))
X#pragma	amicall(ArpBase, 0x13E, SendPacket(d0, a0, a1))
X#pragma	amicall(ArpBase, 0x144, InitStdPacket(d0, a0, a1, a2))
X#pragma	amicall(ArpBase, 0x14A, PathName(d0, a0, d1))
X#pragma	amicall(ArpBase, 0x150, Assign(a0, a1))
X#pragma	amicall(ArpBase, 0x156, DosAllocMem(d0))
X#pragma	amicall(ArpBase, 0x15C, DosFreeMem(a1))
X#pragma	amicall(ArpBase, 0x162, BtoCStr(a0, d0, d1))
X#pragma	amicall(ArpBase, 0x168, CtoBStr(a0, d0, d1))
X#pragma	amicall(ArpBase, 0x16E, GetDevInfo(a2))
X#pragma	amicall(ArpBase, 0x174, FreeTaskResList())
X#pragma	amicall(ArpBase, 0x17A, ArpExit(d0, d2))
X#pragma	amicall(ArpBase, 0x180, ArpAlloc(d0))
X/*	amicall(ArpBase, 0x186, ArpAllocMem(d0, d1))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x18C, ArpOpen(d1, d2))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x192, ArpDupLock(d1))		Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x198, ArpLock(d1, d2))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x19E, RListAlloc(a0, d0))	Secondary result - IoErr() */
X#pragma	amicall(ArpBase, 0x1A4, FindCLI(d0))
X#pragma	amicall(ArpBase, 0x1AA, QSort(a0, d0, d1, a1))
X
X#pragma	amicall(ArpBase, 0x1B0, PatternMatch(a0, a1))
X#pragma	amicall(ArpBase, 0x1B6, FindFirst(d0, a0))
X#pragma	amicall(ArpBase, 0x1BC, FindNext(a0))
X#pragma	amicall(ArpBase, 0x1C2, FreeAnchorChain(a0))
X
X#pragma	amicall(ArpBase, 0x1C8, CompareLock(d0, d1))
X
X#pragma	amicall(ArpBase, 0x1CE, FindTaskResList())
X#pragma	amicall(ArpBase, 0x1D4, CreateTaskResList())
X#pragma	amicall(ArpBase, 0x1DA, FreeResList(a1))
X#pragma	amicall(ArpBase, 0x1E0, FreeTrackedItem(a1))
X/*	amicall(ArpBase, 0x1E6, GetTracker())	Stores the ID in the tracker */
X
X#pragma	amicall(ArpBase, 0x1EC, GetAccess(a1))
X#pragma	amicall(ArpBase, 0x1F2, FreeAccess(a1))
X
X#pragma	amicall(ArpBase, 0x1F8, FreeDAList(a1))
X#pragma	amicall(ArpBase, 0x1FE, AddDANode(a0, a1, d0, d1))
X#pragma	amicall(ArpBase, 0x204, AddDADevs(a0, d0))
X
X#pragma	amicall(ArpBase, 0x20A, Strcmp(a0, a1))
X#pragma	amicall(ArpBase, 0x210, Strncmp(a0, a1, d0))
X#pragma	amicall(ArpBase, 0x216, Toupper(d0))
X#pragma	amicall(ArpBase, 0x21C, SyncRun(a0, a1, d0, d1))
X
X/*
X ************************************************************************
X *	Added V32 of arp.library					*
X *	Note that SpawnShell is ASyncRun but was added at V39 of arp...	*
X ************************************************************************
X */
X#pragma	amicall(ArpBase, 0x222, ASyncRun(a0, a1, a2))
X#pragma	amicall(ArpBase, 0x222, SpawnShell(a0, a1, a2))
X#pragma	amicall(ArpBase, 0x228, LoadPrg(d1))
X#pragma	amicall(ArpBase, 0x22E, PreParse(a0, a1))
X
X/*
X ************************************************************************
X *	Added V33 of arp.library					*
X ************************************************************************
X */
X#pragma	amicall(ArpBase, 0x234, StamptoStr(a0))
X#pragma	amicall(ArpBase, 0x23A, StrtoStamp(a0))
X
X#pragma	amicall(ArpBase, 0x240, ObtainResidentPrg(a0))
X#pragma	amicall(ArpBase, 0x246, AddResidentPrg(d1, a0))
X#pragma	amicall(ArpBase, 0x24C, RemResidentPrg(a0))
X#pragma	amicall(ArpBase, 0x252, UnLoadPrg(d1))
X#pragma	amicall(ArpBase, 0x258, LMult(d0, d1))
X#pragma	amicall(ArpBase, 0x25E, LDiv(d0, d1))
X#pragma	amicall(ArpBase, 0x264, LMod(d0, d1))
X
X#pragma	amicall(ArpBase, 0x26A, CheckSumPrg(d1))
X#pragma	amicall(ArpBase, 0x270, TackOn(a0, a1))
X#pragma	amicall(ArpBase, 0x276, BaseName(a0))
X#pragma	amicall(ArpBase, 0x27C, ReleaseResidentPrg(d1))
X
X/*
X ************************************************************************
X *	Added V36 of arp.library					*
X ************************************************************************
X */
X/*	amicall(ArpBase, 0x282, SPrintf(d0, a0, a1))	This does not work without glue */
X#pragma	amicall(ArpBase, 0x288, GetKeywordIndex(a0, a1))
X/*	amicall(ArpBase, 0x28E, ArpOpenLibrary(a1, d0))	Secondary result - IoErr() */
X#pragma	amicall(ArpBase, 0x294, ArpAllocFreq())
X
X#endif
END_OF_FILE
if test 6655 -ne `wc -c <'vim/src/arp_proto.h'`; then
    echo shar: \"'vim/src/arp_proto.h'\" unpacked with wrong size!
fi
# end of 'vim/src/arp_proto.h'
fi
if test -f 'vim/src/cmdtab.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/cmdtab.h'\"
else
echo shar: Extracting \"'vim/src/cmdtab.h'\" \(5973 characters\)
sed "s/^X//" >'vim/src/cmdtab.h' <<'END_OF_FILE'
X/* vi:ts=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * THIS FILE IS AUTOMATICALLY PRODUCED - DO NOT EDIT
X */
X
X#define RANGE	0x01			/* allow a linespecs */
X#define BANG	0x02			/* allow a ! after the command name */
X#define EXTRA	0x04			/* allow extra args after command name */
X#define XFILE	0x08			/* expand wildcards in extra part */
X#define NOSPC	0x10			/* no spaces allowed in the extra part */
X#define	DFLALL	0x20			/* default file range is 1,$ */
X#define NODFL	0x40			/* do not default to the current file name */
X#define NEEDARG	0x80			/* argument required */
X#define TRLBAR	0x100			/* check for trailing vertical bar */
X#define REGSTR	0x200			/* allow "x for register designation */
X#define COUNT	0x400			/* allow count in argument */
X#define NOTRLCOM 0x800			/* no trailing comment allowed */
X#define ZEROR	0x1000			/* zero line number allowed */
X#define USECTRLV 0x2000			/* do not remove CTRL-V from argument */
X#define FILES	(XFILE + EXTRA)	/* multiple extra files allowed */
X#define WORD1	(EXTRA + NOSPC)	/* one extra word allowed */
X#define FILE1	(FILES + NOSPC)	/* 1 file allowed, defaults to current file */
X#define NAMEDF	(FILE1 + NODFL)	/* 1 file allowed, defaults to "" */
X#define NAMEDFS	(FILES + NODFL)	/* multiple files allowed, default is "" */
X
X/*
X * This array maps ex command names to command codes. The order in which
X * command names are listed below is significant -- ambiguous abbreviations
X * are always resolved to be the first possible match (e.g. "r" is taken
X * to mean "read", not "rewind", because "read" comes before "rewind").
X * Not supported commands are included to avoid ambiguities.
X */
Xstatic struct
X{
X	char	*cmd_name;	/* name of the command */
X	short	 cmd_argt;	/* command line arguments permitted/needed/used */
X} cmdnames[] =
X{
X	{"append",		BANG+RANGE+TRLBAR},			/* not supported */
X#define CMD_append 0
X	{"abbreviate",	EXTRA+TRLBAR+NOTRLCOM},		/* not supported */
X#define CMD_abbreviate 1
X	{"args",		TRLBAR},
X#define CMD_args 2
X	{"change",		BANG+RANGE+COUNT+TRLBAR},	/* not supported */
X#define CMD_change 3
X	{"cd",			NAMEDF+TRLBAR},
X#define CMD_cd 4
X	{"cc",			TRLBAR+WORD1+BANG},
X#define CMD_cc 5
X	{"cf",			TRLBAR+FILE1+BANG},
X#define CMD_cf 6
X	{"cl",			TRLBAR},
X#define CMD_cl 7
X	{"cn",			TRLBAR+BANG},
X#define CMD_cn 8
X	{"cp",			TRLBAR+BANG},
X#define CMD_cp 9
X	{"cq",			TRLBAR+BANG},
X#define CMD_cq 10
X	{"copy",		RANGE+EXTRA+TRLBAR},
X#define CMD_copy 11
X	{"chdir",		NAMEDF+TRLBAR},
X#define CMD_chdir 12
X	{"delete",		RANGE+REGSTR+COUNT+TRLBAR},
X#define CMD_delete 13
X	{"display",		TRLBAR},
X#define CMD_display 14
X	{"digraph",		EXTRA+TRLBAR},
X#define CMD_digraph 15
X	{"edit",		BANG+FILE1+TRLBAR},
X#define CMD_edit 16
X	{"ex",			BANG+FILE1+TRLBAR},
X#define CMD_ex 17
X	{"file",		FILE1+TRLBAR},
X#define CMD_file 18
X	{"files",		TRLBAR},
X#define CMD_files 19
X	{"global",		RANGE+BANG+EXTRA+DFLALL},
X#define CMD_global 20
X	{"help",		TRLBAR},
X#define CMD_help 21
X	{"insert",		BANG+RANGE+TRLBAR},			/* not supported */
X#define CMD_insert 22
X	{"join",		RANGE+COUNT+TRLBAR},
X#define CMD_join 23
X	{"jumps",		TRLBAR},
X#define CMD_jumps 24
X	{"k",			RANGE+WORD1+TRLBAR},
X#define CMD_k 25
X	{"list",		RANGE+COUNT+TRLBAR},
X#define CMD_list 26
X	{"move",		RANGE+EXTRA+TRLBAR},
X#define CMD_move 27
X	{"mark",		RANGE+WORD1+TRLBAR},
X#define CMD_mark 28
X	{"marks",		TRLBAR},
X#define CMD_marks 29
X	{"map",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_map 30
X	{"mkexrc",		BANG+FILE1+TRLBAR},
X#define CMD_mkexrc 31
X	{"mkvimrc",		BANG+FILE1+TRLBAR},
X#define CMD_mkvimrc 32
X	{"next",		RANGE+BANG+NAMEDFS+TRLBAR},
X#define CMD_next 33
X	{"number",		RANGE+COUNT+TRLBAR},
X#define CMD_number 34
X	{"noremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_noremap 35
X	{"Next",		RANGE+BANG+TRLBAR},
X#define CMD_Next 36
X	{"print",		RANGE+COUNT+TRLBAR},
X#define CMD_print 37
X	{"pop",			RANGE+TRLBAR+ZEROR},
X#define CMD_pop 38
X	{"put",			RANGE+BANG+REGSTR+TRLBAR},
X#define CMD_put 39
X	{"previous",	RANGE+BANG+TRLBAR},
X#define CMD_previous 40
X	{"quit",		BANG+TRLBAR},
X#define CMD_quit 41
X	{"read",		RANGE+NAMEDF+NEEDARG+TRLBAR+ZEROR},
X#define CMD_read 42
X	{"rewind",		BANG+TRLBAR},
X#define CMD_rewind 43
X	{"recover",		FILE1+TRLBAR},				/* not supported */
X#define CMD_recover 44
X	{"substitute",	RANGE+EXTRA},
X#define CMD_substitute 45
X	{"set",			EXTRA+TRLBAR},
X#define CMD_set 46
X	{"setkeymap",	NAMEDF+TRLBAR},
X#define CMD_setkeymap 47
X	{"shell",		TRLBAR},
X#define CMD_shell 48
X	{"source",		NAMEDF+NEEDARG+TRLBAR},
X#define CMD_source 49
X	{"stop",		TRLBAR+BANG},
X#define CMD_stop 50
X	{"t",			RANGE+EXTRA+TRLBAR},
X#define CMD_t 51
X	{"tag",			RANGE+BANG+WORD1+TRLBAR+ZEROR},
X#define CMD_tag 52
X	{"tags",		TRLBAR},
X#define CMD_tags 53
X	{"undo",		TRLBAR},
X#define CMD_undo 54
X	{"unabbreviate", EXTRA+TRLBAR},				/* not supported */
X#define CMD_unabbreviate 55
X	{"unmap",		BANG+EXTRA+TRLBAR},
X#define CMD_unmap 56
X	{"vglobal",		RANGE+EXTRA+DFLALL},
X#define CMD_vglobal 57
X	{"version",		TRLBAR},
X#define CMD_version 58
X	{"visual",		RANGE+BANG+FILE1+TRLBAR},
X#define CMD_visual 59
X	{"write",		RANGE+BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_write 60
X	{"wnext",		RANGE+BANG+FILE1+TRLBAR},
X#define CMD_wnext 61
X	{"winsize",		EXTRA+NEEDARG+TRLBAR},
X#define CMD_winsize 62
X	{"wq",			BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_wq 63
X	{"xit",			BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_xit 64
X	{"yank",		RANGE+REGSTR+COUNT+TRLBAR},
X#define CMD_yank 65
X	{"z",			RANGE+COUNT+TRLBAR},		/* not supported */
X#define CMD_z 66
X	{"@",			RANGE+EXTRA+TRLBAR},
X#define CMD_at 67
X	{"!",			RANGE+NAMEDFS},
X#define CMD_bang 68
X	{"<",			RANGE+COUNT+TRLBAR},
X#define CMD_lshift 69
X	{">",			RANGE+COUNT+TRLBAR},
X#define CMD_rshift 70
X	{"=",			RANGE+TRLBAR},
X#define CMD_equal 71
X	{"&",			RANGE+EXTRA},
X#define CMD_and 72
X	{"~",			RANGE+TRLBAR}				/* not supported */
X#define CMD_tilde 73
X#define CMD_SIZE 74
X
X};
END_OF_FILE
if test 5973 -ne `wc -c <'vim/src/cmdtab.h'`; then
    echo shar: \"'vim/src/cmdtab.h'\" unpacked with wrong size!
fi
# end of 'vim/src/cmdtab.h'
fi
if test -f 'vim/src/cmdtab.tab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/cmdtab.tab'\"
else
echo shar: Extracting \"'vim/src/cmdtab.tab'\" \(4518 characters\)
sed "s/^X//" >'vim/src/cmdtab.tab' <<'END_OF_FILE'
X/* vi:ts=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * |This file is read by mkcmdtab to produce cmdtab.h.
X *
X * The bars are used to recognize file positions. Do not insert/delete them.|
X */
X
X#define RANGE	0x01			/* allow a linespecs */
X#define BANG	0x02			/* allow a ! after the command name */
X#define EXTRA	0x04			/* allow extra args after command name */
X#define XFILE	0x08			/* expand wildcards in extra part */
X#define NOSPC	0x10			/* no spaces allowed in the extra part */
X#define	DFLALL	0x20			/* default file range is 1,$ */
X#define NODFL	0x40			/* do not default to the current file name */
X#define NEEDARG	0x80			/* argument required */
X#define TRLBAR	0x100			/* check for trailing vertical bar */
X#define REGSTR	0x200			/* allow "x for register designation */
X#define COUNT	0x400			/* allow count in argument */
X#define NOTRLCOM 0x800			/* no trailing comment allowed */
X#define ZEROR	0x1000			/* zero line number allowed */
X#define USECTRLV 0x2000			/* do not remove CTRL-V from argument */
X#define FILES	(XFILE + EXTRA)	/* multiple extra files allowed */
X#define WORD1	(EXTRA + NOSPC)	/* one extra word allowed */
X#define FILE1	(FILES + NOSPC)	/* 1 file allowed, defaults to current file */
X#define NAMEDF	(FILE1 + NODFL)	/* 1 file allowed, defaults to "" */
X#define NAMEDFS	(FILES + NODFL)	/* multiple files allowed, default is "" */
X
X/*
X * This array maps ex command names to command codes. The order in which
X * command names are listed below is significant -- ambiguous abbreviations
X * are always resolved to be the first possible match (e.g. "r" is taken
X * to mean "read", not "rewind", because "read" comes before "rewind").
X * Not supported commands are included to avoid ambiguities.
X */
Xstatic struct
X{
X	char	*cmd_name;	/* name of the command */
X	short	 cmd_argt;	/* command line arguments permitted/needed/used */
X} cmdnames[] =
X{
X|	{"append",		BANG+RANGE+TRLBAR},			/* not supported */
X	{"abbreviate",	EXTRA+TRLBAR+NOTRLCOM},		/* not supported */
X	{"args",		TRLBAR},
X	{"change",		BANG+RANGE+COUNT+TRLBAR},	/* not supported */
X	{"cd",			NAMEDF+TRLBAR},
X	{"cc",			TRLBAR+WORD1+BANG},
X	{"cf",			TRLBAR+FILE1+BANG},
X	{"cl",			TRLBAR},
X	{"cn",			TRLBAR+BANG},
X	{"cp",			TRLBAR+BANG},
X	{"cq",			TRLBAR+BANG},
X	{"copy",		RANGE+EXTRA+TRLBAR},
X	{"chdir",		NAMEDF+TRLBAR},
X	{"delete",		RANGE+REGSTR+COUNT+TRLBAR},
X	{"display",		TRLBAR},
X	{"digraph",		EXTRA+TRLBAR},
X	{"edit",		BANG+FILE1+TRLBAR},
X	{"ex",			BANG+FILE1+TRLBAR},
X	{"file",		FILE1+TRLBAR},
X	{"files",		TRLBAR},
X	{"global",		RANGE+BANG+EXTRA+DFLALL},
X	{"help",		TRLBAR},
X	{"insert",		BANG+RANGE+TRLBAR},			/* not supported */
X	{"join",		RANGE+COUNT+TRLBAR},
X	{"jumps",		TRLBAR},
X	{"k",			RANGE+WORD1+TRLBAR},
X	{"list",		RANGE+COUNT+TRLBAR},
X	{"move",		RANGE+EXTRA+TRLBAR},
X	{"mark",		RANGE+WORD1+TRLBAR},
X	{"marks",		TRLBAR},
X	{"map",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"mkexrc",		BANG+FILE1+TRLBAR},
X	{"mkvimrc",		BANG+FILE1+TRLBAR},
X	{"next",		RANGE+BANG+NAMEDFS+TRLBAR},
X	{"number",		RANGE+COUNT+TRLBAR},
X	{"noremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"Next",		RANGE+BANG+TRLBAR},
X	{"print",		RANGE+COUNT+TRLBAR},
X	{"pop",			RANGE+TRLBAR+ZEROR},
X	{"put",			RANGE+BANG+REGSTR+TRLBAR},
X	{"previous",	RANGE+BANG+TRLBAR},
X	{"quit",		BANG+TRLBAR},
X	{"read",		RANGE+NAMEDF+NEEDARG+TRLBAR+ZEROR},
X	{"rewind",		BANG+TRLBAR},
X	{"recover",		FILE1+TRLBAR},				/* not supported */
X	{"substitute",	RANGE+EXTRA},
X	{"set",			EXTRA+TRLBAR},
X	{"setkeymap",	NAMEDF+TRLBAR},
X	{"shell",		TRLBAR},
X	{"source",		NAMEDF+NEEDARG+TRLBAR},
X	{"stop",		TRLBAR+BANG},
X	{"t",			RANGE+EXTRA+TRLBAR},
X	{"tag",			RANGE+BANG+WORD1+TRLBAR+ZEROR},
X	{"tags",		TRLBAR},
X	{"undo",		TRLBAR},
X	{"unabbreviate", EXTRA+TRLBAR},				/* not supported */
X	{"unmap",		BANG+EXTRA+TRLBAR},
X	{"vglobal",		RANGE+EXTRA+DFLALL},
X	{"version",		TRLBAR},
X	{"visual",		RANGE+BANG+FILE1+TRLBAR},
X	{"write",		RANGE+BANG+FILE1+DFLALL+TRLBAR},
X	{"wnext",		RANGE+BANG+FILE1+TRLBAR},
X	{"winsize",		EXTRA+NEEDARG+TRLBAR},
X	{"wq",			BANG+FILE1+DFLALL+TRLBAR},
X	{"xit",			BANG+FILE1+DFLALL+TRLBAR},
X	{"yank",		RANGE+REGSTR+COUNT+TRLBAR},
X	{"z",			RANGE+COUNT+TRLBAR},		/* not supported */
X	{"@",			RANGE+EXTRA+TRLBAR},
X	{"!",			RANGE+NAMEDFS},
X	{"<",			RANGE+COUNT+TRLBAR},
X	{">",			RANGE+COUNT+TRLBAR},
X	{"=",			RANGE+TRLBAR},
X	{"&",			RANGE+EXTRA},
X	{"~",			RANGE+TRLBAR}				/* not supported */
X|
X};
X|
END_OF_FILE
if test 4518 -ne `wc -c <'vim/src/cmdtab.tab'`; then
    echo shar: \"'vim/src/cmdtab.tab'\" unpacked with wrong size!
fi
# end of 'vim/src/cmdtab.tab'
fi
if test -f 'vim/src/makefile.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.unix'\"
else
echo shar: Extracting \"'vim/src/makefile.unix'\" \(4829 characters\)
sed "s/^X//" >'vim/src/makefile.unix' <<'END_OF_FILE'
X#
X# Makefile for Vim on Unix, using gcc or standard cc
X#
X
X#>>>>> choose bsd (Sun, Linux, HPUX) or system V (Dynix/PTX)
XMACHINE = -DBSD
X#MACHINE = -DSYSV
X
X#>>>>> choose one compiler
X### standard C compiler, with optimizer or debugger
XCC=cc -O
X#CC=cc -g
X
X### GCC on sun, Dynix
X#CC=gcc -g -Wall -traditional
X
X### GCC 2.2.2d on Linux
X#CC=gcc -O6 -Wall
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support
X### -DNO_FREE_NULL	do not call free() with a null pointer
X### -DWILD_CARDS	wildcard expansion code
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DSTRNCASECMP	use strncasecmp() instead of internal function
X### -DUSE_LOCALE	use setlocale() to change ctype() and others
X### -DTERMCAP		full termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DMAXNAMLEN 31	maximum length of a file name (if not defined in sys/dir.h)
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
XDEFS = -DDIGRAPHS -DTERMCAP -DWILD_CARDS -DSOME_BUILTIN_TCAPS -DNO_FREE_NULL \
X	-DSYSVIMRC_FILE=\"\$$HOME/.vimrc\" -DSYSEXRC_FILE=\"\$$HOME/.exrc\" \
X	-DDEFVIMRC_FILE=\"/etc/vimrc\" -DVIM_HLP=\"/usr/local/doc/vim.hlp\"
X
X#>>>>> link with termlib or termcap only if TERMCAP is defined
X# termcap is for linux, HPUX, etc.
XLIBS = -ltermlib
X#LIBS = -ltermcap
X#LIBS = 
X
X#>>>>> end of choices
X###########################################################################
X
XCFLAGS = -c $(MACHINE) $(DEFS)
X
XINCL = vim.h globals.h param.h keymap.h macros.h ascii.h term.h unix.h debug.h
X
XOBJ =	alloc.o unix.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o term.o undo.o
X
X../vim: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) -o ../vim $(OBJ) version.o $(LIBS)
X
Xdebug: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) -o ../vim -g $(OBJ) version.o $(LIBS)
X
Xctags:
X	csh -c ctags *.c *.h
X
Xclean:
X	-rm -f $(OBJ) mkcmdtab.o version.o core ../vim mkcmdtab
X
X#use this in case the files have been transported via an MSDOS system
X
XFILES = *.c *.h makefile makefile.* cmdtab.tab proto/*.pro tags
X
Xdos2unix:
X	-mv arp_prot.h arp_proto.h
X	-mv ptx_stdl.h ptx_stdlib.h
X	-mv sun_stdl.h sun_stdlib.h
X	-mv makefile.dic makefile.dice
X	-mv makefile.uni makefile.unix
X	-mv makefile.man makefile.manx
X	-mv makefile.6sa makefile.6sas
X	-mv makefile.5sa makefile.5sas
X	for i in $(FILES); do tr -d '\r\032' < $$i > ~tmp~; mv ~tmp~ $$i; echo $$i; done
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(INCL)
X	$(CC) $(CFLAGS) alloc.c
X
Xunix.o:	unix.c  $(INCL) unix.h
X	$(CC) $(CFLAGS) unix.c
X
Xbuffers.o:	buffers.c  $(INCL)
X	$(CC) $(CFLAGS) buffers.c
X
Xcharset.o:	charset.c  $(INCL)
X	$(CC) $(CFLAGS) charset.c
X
Xcmdline.o:	cmdline.c  $(INCL) cmdtab.h
X	$(CC) $(CFLAGS) cmdline.c
X
Xcsearch.o:	csearch.c  $(INCL)
X	$(CC) $(CFLAGS) csearch.c
X
Xdigraph.o:	digraph.c  $(INCL)
X	$(CC) $(CFLAGS) digraph.c
X
Xedit.o:	edit.c  $(INCL)
X	$(CC) $(CFLAGS) edit.c
X
Xfileio.o:	fileio.c  $(INCL)
X	$(CC) $(CFLAGS) fileio.c
X
Xhelp.o:	help.c  $(INCL)
X	$(CC) $(CFLAGS) help.c
X
Xlinefunc.o:	linefunc.c  $(INCL)
X	$(CC) $(CFLAGS) linefunc.c
X
Xmain.o:	main.c  $(INCL)
X	$(CC) $(CFLAGS) main.c
X
Xmark.o:	mark.c  $(INCL)
X	$(CC) $(CFLAGS) mark.c
X
Xmessage.o:	message.c  $(INCL)
X	$(CC) $(CFLAGS) message.c
X
Xmisccmds.o:	misccmds.c  $(INCL)
X	$(CC) $(CFLAGS) misccmds.c
X
Xnormal.o:	normal.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) normal.c
X
Xops.o:	ops.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) ops.c
X
Xparam.o:	param.c  $(INCL)
X	$(CC) $(CFLAGS) param.c
X
Xquickfix.o:	quickfix.c  $(INCL)
X	$(CC) $(CFLAGS) quickfix.c
X
Xregexp.o:	regexp.c  $(INCL)
X	$(CC) $(CFLAGS) regexp.c
X
Xregsub.o:	regsub.c  $(INCL)
X	$(CC) $(CFLAGS) regsub.c
X
Xscreen.o:	screen.c  $(INCL)
X	$(CC) $(CFLAGS) screen.c
X
Xscript.o:	script.c  $(INCL)
X	$(CC) $(CFLAGS) script.c
X
Xsearch.o:	search.c  $(INCL)
X	$(CC) $(CFLAGS) search.c
X
Xstorage.o:	storage.c  $(INCL)
X	$(CC) $(CFLAGS) storage.c
X
Xtag.o:	tag.c  $(INCL)
X	$(CC) $(CFLAGS) tag.c
X
Xterm.o:	term.c  $(INCL)
X	$(CC) $(CFLAGS) term.c
X
Xundo.o:	undo.c  $(INCL)
X	$(CC) $(CFLAGS) undo.c
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	./mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab: mkcmdtab.o
X	$(CC) -o mkcmdtab mkcmdtab.o
END_OF_FILE
if test 4829 -ne `wc -c <'vim/src/makefile.unix'`; then
    echo shar: \"'vim/src/makefile.unix'\" unpacked with wrong size!
fi
# end of 'vim/src/makefile.unix'
fi
if test -f 'vim/src/param.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/param.h'\"
else
echo shar: Extracting \"'vim/src/param.h'\" \(5234 characters\)
sed "s/^X//" >'vim/src/param.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * param.h: definition of global variables for settable parameters
X *
X * EXTERN is only defined in main.c (and vim.h)
X */
X
X#ifndef EXTERN
X# define EXTERN extern
X# define INIT(x)
X#else
X# ifndef INIT
X#  define INIT(x) x
X# endif
X#endif
X
X/*
X * The following are actual variabables for the parameters
X */
X
XEXTERN int	p_ai	INIT(= FALSE);		/* auto-indent */
XEXTERN int	p_aw	INIT(= FALSE);		/* auto-write */
XEXTERN long	p_bs	INIT(= 0);			/* backspace over newlines in insert mode */
X#if defined(COMPATIBLE) || defined(NOBACKUP)
XEXTERN int	p_bk	INIT(= FALSE);		/* make backups when writing out files */
X#else
XEXTERN int	p_bk	INIT(= TRUE);		/* make backups when writing out files */
X#endif
X#ifdef UNIX
XEXTERN char *p_bdir	INIT(= BACKUPDIR);	/* directory for backups */
X#endif
XEXTERN int	p_cp	INIT(= FALSE);		/* vi-compatible */
X#ifdef DIGRAPHS
XEXTERN int	p_dg	INIT(= FALSE);		/* enable digraphs */
X#endif /* DIGRAPHS */
XEXTERN char *p_dir	INIT(= "");			/* directory for autoscript file */
XEXTERN char *p_ep	INIT(= "indent");	/* program name for '=' command */
XEXTERN int	p_eb	INIT(= FALSE);		/* ring bell for errors */
X#ifdef AMIGA
XEXTERN char *p_ef	INIT(= "AztecC.Err");	/* name of errorfile */
X#else
XEXTERN char *p_ef	INIT(= "");			/* name of errorfile */
X#endif
XEXTERN int	p_et	INIT(= FALSE);		/* expand tabs into spaces */
X#ifdef MSDOS
XEXTERN int	p_gr	INIT(= TRUE);		/* display graphic characters */
X#else
XEXTERN int	p_gr	INIT(= FALSE);		/* display graphic characters */
X#endif
XEXTERN long p_hi	INIT(= 20);			/* command line history size */
XEXTERN char *p_hf	INIT(= VIM_HLP);	/* name of help file */
XEXTERN int	p_ic	INIT(= FALSE);		/* ignore case in searches */
XEXTERN int	p_im	INIT(= FALSE);		/* start editing in input mode */
XEXTERN char *p_kp	INIT(= "ref");		/* keyword program */
XEXTERN int	p_js	INIT(= TRUE);		/* use two spaces after period with Join */
XEXTERN int	p_list	INIT(= FALSE);		/* show tabs and newlines graphically */
XEXTERN int	p_magic INIT(= TRUE);		/* use some characters for reg exp */
XEXTERN long p_ml	INIT(= 5);			/* number of mode lines */
XEXTERN int	p_nu	INIT(= FALSE);		/* number lines on the screen */
XEXTERN char *p_para	INIT(= "IPLPPPQPP LIpplpipbp");		/* paragraphs */
XEXTERN int	p_ro	INIT(= FALSE);		/* readonly */
XEXTERN int	p_remap	INIT(= TRUE);		/* remap */
XEXTERN int	p_rd	INIT(= TRUE);		/* delete when replacing */
XEXTERN long	p_report	INIT(= 2);		/* minimum number of lines for report */
XEXTERN int	p_ru	INIT(= FALSE);		/* show column/line number */
XEXTERN long	p_scroll	INIT(= 12);		/* scroll size */
XEXTERN long	p_sj	INIT(= 1);			/* scroll jump size */
XEXTERN char *p_sections	INIT(= "SHNHH HUnhsh");		/* sections */
X#ifdef MSDOS
XEXTERN char *p_sh 	INIT(= "command");		/* name of shell to use */
X#else
XEXTERN char *p_sh 	INIT(= "sh");		/* name of shell to use */
X#endif
XEXTERN long	p_st	INIT(= 0);			/* type of shell */
XEXTERN int	p_sr	INIT(= FALSE);		/* shift round off (for < and >) */
XEXTERN long	p_sw	INIT(= 8);			/* shiftwidth (for < and >) */
X#ifdef COMPATIBLE
XEXTERN int	p_sc	INIT(= FALSE);		/* show command in status line */
X#else
XEXTERN int	p_sc	INIT(= TRUE);		/* show command in status line */
X#endif
X#ifndef MSDOS
XEXTERN int	p_sn	INIT(= FALSE);		/* short names in file system */
X#endif
XEXTERN int	p_sm	INIT(= FALSE);		/* showmatch */
X#ifdef COMPATIBLE
XEXTERN int	p_mo	INIT(= FALSE);		/* show mode */
X#else
XEXTERN int	p_mo	INIT(= TRUE);		/* show mode */
X#endif
XEXTERN int	p_si	INIT(= FALSE);		/* smart-indent for c programs */
XEXTERN char *p_su	INIT(= ".bak.o.h.info.vim");	/* suffixes for wildcard expansion */
XEXTERN long p_ts	INIT(= 8);			/* tab size in the file */
XEXTERN long p_tl	INIT(= 0);			/* used tag length */
XEXTERN char *p_tags	INIT(= "tags");		/* tags search path */
XEXTERN int	p_terse	INIT(= TRUE);		/* terse (not used) */
X#ifdef MSDOS
XEXTERN int	p_tx	INIT(= TRUE);		/* textmode for file I/O */
X#endif
XEXTERN long p_tw	INIT(= 9999);		/* textwidth */
XEXTERN int	p_to	INIT(= FALSE);		/* tilde is an operator */
XEXTERN int	p_timeout	INIT(= TRUE);	/* mappings entered within one second */
XEXTERN int	p_ttimeout	INIT(= FALSE);	/* key codes entered within one second */
X#ifdef COMPATIBLE
XEXTERN long p_ul	INIT(= 0);			/* number of Undo Levels */
XEXTERN long p_uc	INIT(= 0);			/* update count for auto script file */
X#else
XEXTERN long p_ul	INIT(= 100);		/* number of Undo Levels */
XEXTERN long p_uc	INIT(= 100);		/* update count for auto script file */
X#endif
XEXTERN long p_ut	INIT(= 2000);		/* update time for auto script file */
XEXTERN int	p_vb	INIT(= FALSE);		/* visual bell only (no beep) */
XEXTERN int	p_warn	INIT(= TRUE);		/* warn for changes at shell command */
XEXTERN int	p_ws	INIT(= TRUE);		/* wrap scan */
XEXTERN long p_wm	INIT(= 0);			/* wrapmargin */
XEXTERN int	p_wa	INIT(= FALSE);		/* write any */
X#if defined(COMPATIBLE) || defined(NOBACKUP)
XEXTERN int	p_wb	INIT(= FALSE);		/* write backup files */
X#else
XEXTERN int	p_wb	INIT(= TRUE);		/* write backup files */
X#endif
XEXTERN int	p_ye	INIT(= FALSE);		/* Y yanks to end of line */
END_OF_FILE
if test 5234 -ne `wc -c <'vim/src/param.h'`; then
    echo shar: \"'vim/src/param.h'\" unpacked with wrong size!
fi
# end of 'vim/src/param.h'
fi
if test -f 'vim/src/quickfix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/quickfix.c'\"
else
echo shar: Extracting \"'vim/src/quickfix.c'\" \(5881 characters\)
sed "s/^X//" >'vim/src/quickfix.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * quickfix.c: functions for quickfix mode, using the Manx errorfile
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
Xstatic void qf_free __ARGS((void));
X
X/*
X * for each error the next struct is allocated and linked in a list
X */
Xstruct qf_line
X{
X	struct qf_line	*qf_next;	/* pointer to next error in the list */
X	struct qf_line	*qf_prev;	/* pointer to previous error in the list */
X	linenr_t		 qf_lnum;	/* line number where the error occurred */
X	char			*qf_mark;	/* pointer to that line (if != NULL) */
X	int				 qf_col;	/* column where the error occurred */
X	char			 qf_cleared;/* set to TRUE if qf_mark has been cleared */
X	char			 qf_type;	/* type of the error (mostly 'E') */
X	int				 qf_nr;		/* error number */
X	char			*qf_fname;	/* file name where the error occurred */
X	char			*qf_text;	/* description of the error */
X};
X
Xstatic struct qf_line *qf_start;		/* pointer to the first error */
Xstatic struct qf_line *qf_ptr;			/* pointer to the current error */
X
Xstatic int	qf_count = 0;		/* number of errors (0 means no error list) */
X	   int	qf_index;			/* current index in the error list */
Xstatic int	qf_marksset;		/* set to 1 when qf_mark-s have been set */
X
X/*
X * Read the errorfile into memory, line by line, building the error list.
X * Return 1 for error, 0 for success.
X */
X	int
Xqf_init(fname)
X	char *fname;
X{
X	char 			namebuf[CMDBUFFSIZE];
X	char			errmsg[CMDBUFFSIZE];
X	FILE			*fd;
X	struct qf_line	*qfp = NULL;
X
X	if (fname == NULL)
X	{
X		emsg(e_errorf);
X		return 1;
X	}
X	if ((fd = fopen(fname, "r")) == NULL)
X	{
X		emsg(e_openerrf);
X		return 1;
X	}
X	qf_free();
X
X	while (fgets(IObuff, IOSIZE, fd) != NULL)
X	{
X		if ((qfp = (struct qf_line *)alloc((unsigned)sizeof(struct qf_line))) == NULL)
X			goto error2;
X
X	/* parse the line: "filename>linenr:colnr:type:number:text" */
X		if (sscanf(IObuff, "%[^>]>%ld:%d:%c:%d:%[^\n]", namebuf,
X				&qfp->qf_lnum, &qfp->qf_col, &qfp->qf_type,
X								&qfp->qf_nr, errmsg) != 6)
X			goto error;
X		if ((qfp->qf_fname = strsave(namebuf)) == NULL)
X			goto error1;
X		if ((qfp->qf_text = strsave(errmsg)) == NULL)
X		{
X			free(qfp->qf_fname);
X			goto error1;
X		}
X		if (qf_count == 0)		/* first element in the list */
X		{
X			qf_start = qfp;
X			qfp->qf_prev = qfp;	/* first element points to itself */
X		}
X		else
X		{
X			qfp->qf_prev = qf_ptr;
X			qf_ptr->qf_next = qfp;
X		}
X		qfp->qf_next = qfp;		/* last element points to itself */
X		qfp->qf_mark = NULL;
X		qfp->qf_cleared = FALSE;
X		qf_ptr = qfp;
X		++qf_count;
X	}
X	if (!ferror(fd))
X	{
X		qf_ptr = qf_start;
X		qf_index = 1;
X		fclose(fd);
X		return 0;
X	}
Xerror:
X	emsg(e_readerrf);
Xerror1:
X	free(qfp);
Xerror2:
X	fclose(fd);
X	qf_free();
X	return 1;
X}
X
X/*
X * jump to quickfix line "errornr"; if "errornr" is zero, redisplay the same line
X */
X	void
Xqf_jump(errornr)
X	int errornr;
X{
X	struct qf_line *qfp;
X	linenr_t		i;
X	char			*msgp;
X
X	if (qf_count == 0)
X	{
X		emsg(e_quickfix);
X		return;
X	}
X	if (errornr == 0)
X		errornr = qf_index;
X	while (errornr < qf_index && qf_index > 1)
X	{
X		--qf_index;
X		qf_ptr = qf_ptr->qf_prev;
X	}
X	while (errornr > qf_index && qf_index < qf_count)
X	{
X		++qf_index;
X		qf_ptr = qf_ptr->qf_next;
X	}
X
X	/*
X	 * read the wanted file if needed, and check autowrite etc.
X	 */
X	if (getfile(qf_ptr->qf_fname, TRUE) <= 0)
X	{
X		/*
X		 * use mark if possible, because the line number may be invalid
X		 * after line inserts / deletes
X		 */
X		i = 0;
X		msgp = "";
X		if ((qf_ptr->qf_mark != NULL && (i = ptr2nr(qf_ptr->qf_mark, (linenr_t)0)) == 0) || qf_ptr->qf_cleared)
X			msgp = "(line changed) ";
X		if (i == 0)
X			i = qf_ptr->qf_lnum;
X		if (i > line_count)
X			i = line_count;
X		Curpos.lnum = i;
X		Curpos.col = qf_ptr->qf_col;
X		adjustCurpos();
X		cursupdate();
X		smsg("(%d of %d) %s%s %d: %s", qf_index, qf_count, msgp, qf_ptr->qf_type == 'E' ? "Error" : "Warning", qf_ptr->qf_nr, qf_ptr->qf_text);
X
X		if (!qf_marksset)		/* marks not set yet: try to find them for
X									the errors in the curren file */
X		{
X			for (i = 0, qfp = qf_start; i < qf_count; ++i, qfp = qfp->qf_next)
X				if (strcmp(qfp->qf_fname, qf_ptr->qf_fname) == 0 && qfp->qf_lnum <= line_count)
X					qfp->qf_mark = nr2ptr(qfp->qf_lnum);
X			qf_marksset = 1;
X		}
X	}
X}
X
X/*
X * list all errors
X */
X	void
Xqf_list()
X{
X	struct qf_line *qfp;
X	int i;
X
X	if (qf_count == 0)
X	{
X		emsg(e_quickfix);
X		return;
X	}
X	qfp = qf_start;
X	gotocmdline(TRUE, NUL);
X#ifdef AMIGA
X	settmode(0);		/* set cooked mode so output can be halted */
X#endif
X	for (i = 1; i <= qf_count; ++i)
X	{
X		sprintf(IObuff, "%2d line %ld col %2d %s %3d: %s",
X			i,
X			(long)qfp->qf_lnum,
X			qfp->qf_col,
X			qfp->qf_type == 'E' ? "Error" : "Warning",
X			qfp->qf_nr,
X			qfp->qf_text);
X		outstr(IObuff);
X		outchar('\n');
X		qfp = qfp->qf_next;
X		flushbuf();
X	}
X#ifdef AMIGA
X	settmode(1);
X#endif
X	wait_return(TRUE);
X}
X
X/*
X * free the error list
X */
X	static void
Xqf_free()
X{
X	struct qf_line *qfp;
X
X	while (qf_count)
X	{
X		qfp = qf_start->qf_next;
X		free(qf_start->qf_fname);
X		free(qf_start->qf_text);
X		free(qf_start);
X		qf_start = qfp;
X		--qf_count;
X	}
X	qf_marksset = 0;
X}
X
X/*
X * qf_clrallmarks() - clear all marks
X *
X * Used mainly when trashing the entire buffer during ":e" type commands
X */
X	void
Xqf_clrallmarks()
X{
X	int 			i;
X	struct qf_line *qfp;
X
X	if (qf_count)
X		for (i = 0, qfp = qf_start; i < qf_count; i++, qfp = qfp->qf_next)
X			qfp->qf_mark = NULL;
X	qf_marksset = 0;
X}
X
X/*
X * qf_adjustmark: set new ptr for a mark
X */
X   void
Xqf_adjustmark(old, new)
X	char		*old, *new;
X{
X	register int i;
X	struct qf_line *qfp;
X
X	if (qf_count)
X	{
X		for (i = 0, qfp = qf_start; i < qf_count; ++i, qfp = qfp->qf_next)
X			if (qfp->qf_mark == old)
X			{
X				qfp->qf_mark = new;
X				if (new == NULL)
X					qfp->qf_cleared = TRUE;
X			}
X	}
X}
END_OF_FILE
if test 5881 -ne `wc -c <'vim/src/quickfix.c'`; then
    echo shar: \"'vim/src/quickfix.c'\" unpacked with wrong size!
fi
# end of 'vim/src/quickfix.c'
fi
if test -f 'vim/src/term.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/term.h'\"
else
echo shar: Extracting \"'vim/src/term.h'\" \(7566 characters\)
sed "s/^X//" >'vim/src/term.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * term.h -- VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * This file contains the machine dependent escape sequences that the editor
X * needs to perform various operations. Some of the sequences here are
X * optional. Anything not available should be indicated by a null string. In
X * the case of insert/delete line sequences, the editor checks the capability
X * and works around the deficiency, if necessary.
X */
X
X/*
X * the terminal capabilities are stored in this structure
X * keep in sync with array in term.c
X */
Xtypedef struct _tcarr
X{
X/* output codes */
X  char *t_name;		/* name of this terminal entry */
X  char *t_el;		/* el       ce	clear to end of line */
X  char *t_il;		/* il1      al	add new blank line */
X  char *t_cil;		/* il       AL	add number of blank lines */
X  char *t_dl;		/* dl1      dl	delete line */
X  char *t_cdl;		/* dl       DL	delete number of lines */
X  char *t_ed;		/* clear    cl	clear screen */
X  char *t_ci;		/* civis    vi	cursur invisible */
X  char *t_cv;		/* cnorm    ve	cursur visible */
X  char *t_tp;		/* sgr0     me	normal mode */
X  char *t_ti;		/* rev      mr	reverse mode */
X  char *t_cm;		/* cup      cm	cursor motion */
X  char *t_sr;		/* ri       sr	scroll reverse (backward) */
X  char *t_cri;		/* cuf      RI	cursor number of chars right */
X  char *t_vb;		/* flash    vb	visual bell */
X  char *t_ks;		/* smkx     ks	put terminal in "keypad transmit" mode */
X  char *t_ke;		/* rmkx     ke	out of "keypad transmit" mode */
X  char *t_ts;		/*          ti	put terminal in termcap mode */
X  char *t_te;		/*          te	out of termcap mode */
X
X/* key codes */
X  char *t_ku;		/* kcuu1    ku	arrow up */
X  char *t_kd;		/* kcud1    kd	arrow down */
X  char *t_kl;		/* kcub1    kl	arrow left */
X  char *t_kr;		/* kcuf1    kr	arrow right */
X  char *t_sku;		/* shift arrow up */
X  char *t_skd;		/* shift arrow down */
X  char *t_skl;		/* kLFT     #4	shift arrow left */
X  char *t_skr;		/* kRIT     %	shift arrow right */
X  char *t_f1;		/* kf1      k1	function key 1 */
X  char *t_f2;		/* kf2      k2	function key 2 */
X  char *t_f3;		/* kf3      k3	function key 3 */
X  char *t_f4;		/* kf4      k4	function key 4 */
X  char *t_f5;		/* kf5      k5	function key 5 */
X  char *t_f6;		/* kf6      k6	function key 6 */
X  char *t_f7;		/* kf7      k7	function key 7 */
X  char *t_f8;		/* kf8      k8	function key 8 */
X  char *t_f9;		/* kf9      k9	function key 9 */
X  char *t_f10;		/* kf10     k;	function key 10 */
X  char *t_sf1;		/* kf11     F1	shifted function key 1 */
X  char *t_sf2;		/* kf12     F2	shifted function key 2 */
X  char *t_sf3;		/* kf13     F3	shifted function key 3 */
X  char *t_sf4;		/* kf14     F4	shifted function key 4 */
X  char *t_sf5;		/* kf15     F5	shifted function key 5 */
X  char *t_sf6;		/* kf16     F6	shifted function key 6 */
X  char *t_sf7;		/* kf17     F7	shifted function key 7 */
X  char *t_sf8;		/* kf18     F8	shifted function key 8 */
X  char *t_sf9;		/* kf19     F9	shifted function key 9 */
X  char *t_sf10;		/* kf20     FA	shifted function key 10 */
X  char *t_help;		/* khlp     %1	help key */
X  char *t_undo;		/* kund     &8	undo key */
X  /* adjust inchar() for last entry! */
X} Tcarr;
X
Xextern Tcarr term_strings;	/* currently used terminal strings */
X
X/*
X * strings used for terminal
X */
X#define T_EL	(term_strings.t_el)
X#define T_IL	(term_strings.t_il)
X#define T_CIL	(term_strings.t_cil)
X#define T_DL	(term_strings.t_dl)
X#define T_CDL	(term_strings.t_cdl)
X#define T_ED	(term_strings.t_ed)
X#define T_CI	(term_strings.t_ci)
X#define T_CV	(term_strings.t_cv)
X#define T_TP	(term_strings.t_tp)
X#define T_TI	(term_strings.t_ti)
X#define T_CM	(term_strings.t_cm)
X#define T_SR	(term_strings.t_sr)
X#define T_CRI	(term_strings.t_cri)
X#define T_VB	(term_strings.t_vb)
X#define T_KS	(term_strings.t_ks)
X#define T_KE	(term_strings.t_ke)
X#define T_TS	(term_strings.t_ts)
X#define T_TE	(term_strings.t_te)
X
X
X#ifndef NO_BUILTIN_TCAPS
X/*
X * here are the builtin termcap entries.
X * They not stored as complete Tcarr structures, as such a structure 
X * is to big. 
X * Each termcap is a concatenated string of entries, where '\0' characters
X * followed by a skip character sepereate the capabilities. The skip 
X * character is the relative structure offset for the following entry.
X * See parse_builtin_tcap() in term.c for all details.
X */
X# define AMIGA_TCAP "amiga\0\
X\0\033[K\0\
X\0\033[L\0\
X\0\033[%dL\0\
X\0\033[M\0\
X\0\033[%dM\0\
X\0\014\0\
X\0\033[0 p\0\
X\0\033[1 p\0\
X\0\033[0m\0\
X\0\033[7m\0\
X\0\033[%i%d;%dH\0\
X\1\033[%dC\0\
X\5\233A\0\
X\0\233B\0\
X\0\233D\0\
X\0\233C\0\
X\0\233T\0\
X\0\233S\0\
X\0\233 A\0\
X\0\233 @\0\
X\0\233\060~\0\
X\0\233\061~\0\
X\0\233\062~\0\
X\0\233\063~\0\
X\0\233\064~\0\
X\0\233\065~\0\
X\0\233\066~\0\
X\0\233\067~\0\
X\0\233\070~\0\
X\0\233\071~\0\
X\0\233\061\060~\0\
X\0\233\061\061~\0\
X\0\233\061\062~\0\
X\0\233\061\063~\0\
X\0\233\061\064~\0\
X\0\233\061\065~\0\
X\0\233\061\066~\0\
X\0\233\061\067~\0\
X\0\233\061\070~\0\
X\0\233\061\071~\0\
X\0\233?~\0\
X\0\0"
X
X# define ATARI_TCAP "atari\0\
X\0\033l\0\
X\0\033L\0\
X\1\033M\0\
X\1\033E\0\
X\0\033f\0\
X\0\033e\0\
X\0\0"
X
X# define ANSI_TCAP "ansi\0\
X\0\033[2K\0\
X\0\033[L\0\
X\0\033[%dL\0\
X\0\033[M\0\
X\0\033[%dM\0\
X\0\033[2J\0\
X\2\033[0m\0\
X\0\033[7m\0\
X\0\033[%i%d;%dH\0\
X\1\033[%dC\0\
X\0\0"
X
X/*
X * These codes are valid when ansi.sys or equivalent has been installed.
X * Function keys on a PC are preceded with a NUL. These are converted into
X * K_ZERO '\236' in GetChars(), because we cannot handle NULs in key codes.
X * CTRL-arrow is used instead of SHIFT-arrow.
X */
X# define PCTERM_TCAP "pcterm\0\
X\0\033[K\0\
X\0\033|L\0\
X\1\033|M\0\
X\1\033[2J\0\
X\2\033[0m\0\
X\0\033[7m\0\
X\0\033[%i%d;%dH\0\
X\1\033[%dC\0\
X\5\236H\0\
X\0\236P\0\
X\0\236K\0\
X\0\236M\0\
X\2\236s\0\
X\0\236t\0\
X\0\236;\0\
X\0\236<\0\
X\0\236=\0\
X\0\236>\0\
X\0\236?\0\
X\0\236@\0\
X\0\236A\0\
X\0\236B\0\
X\0\236C\0\
X\0\236D\0\
X\0\236T\0\
X\0\236U\0\
X\0\236V\0\
X\0\236W\0\
X\0\236X\0\
X\0\236Y\0\
X\0\236Z\0\
X\0\236[\0\
X\0\236\\\0\
X\0\236]\0\
X\0\0"
X
X# define VT52_TCAP "vt52\0\
X\0\033K\0\
X\0\033T\0\
X\1\033U\0\
X\1\014\0\
X\2\033SO\0\
X\0\033S2\0\
X\0\033Y%+ %+ \0\
X\0\0"
X
X# define XTERM_TCAP "xterm\0\
X\0\033[K\0\
X\0\033[L\0\
X\0\033[%dL\0\
X\0\033[M\0\
X\0\033[%dM\0\
X\0\033[2J\0\
X\2\033[m\0\
X\0\033[7m\0\
X\0\033[%i%d;%dH\0\
X\0\033M\0\
X\0\033[%dC\0\
X\1\033[?1h\0\
X\0\033[?0h\0\
X\2\033[OA\0\
X\0\033[OB\0\
X\0\033[OD\0\
X\0\033[OC\0\
X\0\033[Ox\0\
X\0\033[Or\0\
X\0\033[Ot\0\
X\0\033[Ov\0\
X\0\033[12~\0\
X\0\033[13~\0\
X\0\033[14~\0\
X\0\033[15~\0\
X\0\033[16~\0\
X\0\033[17~\0\
X\0\033[18~\0\
X\0\033[19~\0\
X\0\033[20~\0\
X\0\033[21~\0\
X\0\033[23~\0\
X\0\033[24~\0\
X\10\033[28~\0\
X\0\033[26~\0\
X\0\0"
X
X# define DEBUG_TCAP "debug\0\
X\0[EL]\0\
X\0[IL]\0\
X\0[CIL%d]\0\
X\0[DL]\0\
X\0[CDL%d]\0\
X\0[ED]\0\
X\0[CI]\0\
X\0[CV]\0\
X\0[TP]\0\
X\0[TI]\0\
X\0[%dCM%d]\0\
X\0[SR]\0\
X\0[CRI%d]\0\
X\0[VB]\0\
X\0[KS]\0\
X\0[KE]\0\
X\0[TI]\0\
X\0[TE]\0\
X\0[KU]\0\
X\0[KD]\0\
X\0[KL]\0\
X\0[KR]\0\
X\0[SKU]\0\
X\0[SKD]\0\
X\0[SKL]\0\
X\0[SKR]\0\
X\0[F1]\0\
X\0[F2]\0\
X\0[F3]\0\
X\0[F4]\0\
X\0[F5]\0\
X\0[F6]\0\
X\0[F7]\0\
X\0[F8]\0\
X\0[F9]\0\
X\0[F10]\0\
X\0[SF1]\0\
X\0[SF2]\0\
X\0[SF3]\0\
X\0[SF4]\0\
X\0[SF5]\0\
X\0[SF6]\0\
X\0[SF7]\0\
X\0[SF8]\0\
X\0[SF9]\0\
X\0[SF10]\0\
X\0[HELP]\0\
X\0[UNDO]\0\
X\0\0"
X
X# ifdef ATARI
X#  define DFLT_TCAP ATARI_TCAP
X# endif /* ATARI */
X
X# ifdef AMIGA
X#  define DFLT_TCAP AMIGA_TCAP
X# endif /* AMIGA */
X
X# ifdef MSDOS
X#  define DFLT_TCAP PCTERM_TCAP
X# endif /* MSDOS */
X
X# ifdef UNIX
X#  define DFLT_TCAP ANSI_TCAP
X# endif /* UNIX */
X
X#endif /* NO_BUILTIN_TCAPS */
END_OF_FILE
if test 7566 -ne `wc -c <'vim/src/term.h'`; then
    echo shar: \"'vim/src/term.h'\" unpacked with wrong size!
fi
# end of 'vim/src/term.h'
fi
if test -f 'vim/src/vim.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vim.h'\"
else
echo shar: Extracting \"'vim/src/vim.h'\" \(6430 characters\)
sed "s/^X//" >'vim/src/vim.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMitation
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X#if defined(SYSV) || defined(BSD)
X# ifndef UNIX
X#  define UNIX
X# endif
X#endif
X
X#include "debug.h"
X
X#include <stdio.h>
X
X#ifndef SYSV
X# include <stdlib.h>
X#endif
X
X#include <ctype.h>
X
X#ifdef BSD
X# include <strings.h>
X#else
X# include <string.h>
X#endif
X
X#include "ascii.h"
X#include "keymap.h"
X#include "term.h"
X#include "macros.h"
X#ifdef LATTICE
X# include <sys/types.h>
X# include <sys/stat.h>
X#else
X# ifdef _DCC
X#  include <sys/stat.h>
X# else
X#  ifdef MSDOS 
X#   include <sys\stat.h>
X#  else
X#   ifdef UNIX
X#	 ifndef linux
X#	  define volatile		/* needed for gcc */
X#	  define signed			/* needed for gcc */
X#    endif
X#    include <sys/types.h>
X#    include <sys/stat.h>
X#   else
X#     include <stat.h>
X#   endif
X#  endif
X# endif
X#endif
X
X#ifdef AMIGA
X/*
X * arpbase.h must be included before functions.h
X */
X# include <libraries/arpbase.h>
X
X/*
X * This won't be needed if you have a version of Lattice 4.01 without broken
X * break signal handling.
X */
X#include <signal.h>
X#endif
X
X#ifndef AMIGA
X/*
X * For the Amiga we use a version of getenv that does local variables under 2.0
X */
X#define vimgetenv(x) getenv(x)
X#endif
X
X#ifdef AZTEC_C
X# include <functions.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef SASC
X# include <clib/exec_protos.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef _DCC
X# include <functions.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef __TURBOC__
X# define __ARGS(x) x
X#endif
X
X#ifdef MSDOS
X# include <dos.h>
X# include <dir.h>
X#endif
X
X#ifdef UNIX
X# include <sys/dir.h>		/* for MAXNAMLEN */
X# if defined(UFS_MAXNAMLEN) && !defined(MAXNAMLEN)
X#  define MAXNAMLEN UFS_MAXNAMLEN		/* for dynix/ptx */
X# endif
X# if defined(NAME_MAX) && !defined(MAXNAMLEN)
X#  define MAXNAMLEN NAME_MAX			/* for Linux befor .99p3 */
X# endif
X#endif
X
X#if defined(__STDC__) || defined(__GNUC__)
X# ifndef __ARGS
X#  define __ARGS(x) x
X# endif /* __ARGS */
X# if defined(_SEQUENT_)
X#  include "ptx_stdlib.h"
X# endif
X# if defined(sun)
X#  include "sun_stdlib.h"
X# endif
X# if defined(linux)
X#  include <unistd.h>  /* may make sense for others too. jw. */
X# endif
X#else /*__STDC__*/
X# if defined(_SEQUENT_) && !defined(_STDLIB_H_)
X  extern char *getenv();
X  extern void *malloc();
X# endif
X#endif /* __STDC__ */
X
X#ifndef __ARGS
X#define __ARGS(x)	()
X#endif
X#ifndef __PARMS
X#define __PARMS(x)	()
X#endif
X
X/*
X * for systems that do not allow free(NULL)
X */
X#ifdef NO_FREE_NULL
X# define free(x)	nofreeNULL(x)
X  extern void nofreeNULL __ARGS((void *));
X#endif
X
X/*
X * fnamecmp() is used to compare filenames.
X * On some systems case in a filename does not matter, on others it does.
X * (this does not account for maximum name lengths, thus it is not 100% accurate!)
X */
X#if defined(AMIGA) || defined(MSDOS)
X# define fnamecmp(x, y) stricmp((x), (y))
X#else
X# define fnamecmp(x, y) strcmp((x), (y))
X#endif
X
X/* flags for updateScreen() */
X#define VALID					90	/* buffer not changed */
X#define NOT_VALID				91	/* buffer changed */
X#define VALID_TO_CURSCHAR		92	/* buffer before cursor not changed */
X#define INVERTED				93	/* redisplay inverted part */
X#define CLEAR					94	/* first clear screen */
X#define CURSUPD					95	/* update cursor first */
X
X/* values for State */
X#define NORMAL					 0
X#define CMDLINE 				 1
X#define INSERT					 2
X#define APPEND					 3
X#define REPLACE 				 4	/* replace mode */
X#define HELP					 5
X#define NOMAPPING 				 6	/* no :mapping mode for vgetc() */
X#define HITRETURN				 7
X#define SETWINSIZE				 8
X#define NORMAL_BUSY				 9	/* busy interpreting a command */
X
X/* directions */
X#define FORWARD 				 1
X#define BACKWARD				 -1
X
X/* for GetChars */
X#define T_PEEK					1	/* do not wait at all */
X#define T_WAIT					2	/* wait for a short time */
X#define T_BLOCK					3	/* wait forever */
X
X#define QUOTELINE				29999	/* Quoting is linewise */
X
X/*
X * Names for the EXRC, HELP and temporary files.
X * Some of these may have been defined in the makefile.
X */
X#ifndef SYSVIMRC_FILE
X# define SYSVIMRC_FILE	"s:.vimrc"
X#endif
X#ifndef SYSEXRC_FILE
X# define SYSEXRC_FILE	"s:.exrc"
X#endif
X#ifndef VIMRC_FILE
X# define VIMRC_FILE		".vimrc"
X#endif
X#ifndef EXRC_FILE
X# define EXRC_FILE		".exrc"
X#endif
X#ifndef VIM_HLP
X# define VIM_HLP		"vim:vim.hlp"
X#endif
X#define TMPNAME1		"t:viXXXXXX"
X#define TMPNAME2		"t:voXXXXXX"
X#define TMPNAMELEN		12
X
X/*
X * Boolean constants
X */
X#ifndef TRUE
X#define FALSE	(0)			/* note: this is an int, not a long! */
X#define TRUE	(1)
X#endif
X
X/*
X * Maximum screen dimensions
X */
X#define MAX_COLUMNS 140L
X
X/*
X * Buffer sizes
X */
X#define CMDBUFFSIZE	256			/* size of the command processing buffer */
X
X#define LSIZE		512			/* max. size of a line in the tags file */
X
X#define IOSIZE	   (1024+1) 	/* file i/o and sprintf buffer size */
X
X#define	TERMBUFSIZE	1024
X
X#ifdef linux
X# define TBUFSZ 2048			/* buffer size for termcap entry */
X#else
X# define TBUFSZ 1024			/* buffer size for termcap entry */
X#endif
X
X/*
X * maximum length of a file name path
X */
X#ifdef UNIX
X# define MAXPATHL	1024		/* Unix has long paths and plenty of memory */
X#else
X# define MAXPATHL	128			/* not too long to put name on stack */
X#endif
X
X#ifdef MSDOS
X# define BASENAMELEN	8		/* length of base of file name */
X#else
X# ifdef UNIX
X#  define BASENAMELEN	(MAXNAMLEN - 5)
X# else
X#  define BASENAMELEN	26		/* Amiga */
X# endif
X#endif
X
X#ifdef MSDOS
X# define WRITEBIN	"wb"		/* no CR-LF translation */
X# define READBIN	"rb"
X#else
X# define WRITEBIN	"w"
X# define READBIN	"r"
X#endif
X
X#define CHANGED   set_Changed()
X#define UNCHANGED Changed = 0
X
X#if !defined(BSD) && !defined(linux) && !defined(SASC)
Xtypedef unsigned char	u_char;		/* shorthand */
Xtypedef unsigned short	u_short;	/* shorthand */
Xtypedef unsigned int	u_int;		/* shorthand */
Xtypedef unsigned long	u_long;		/* shorthand */
X#endif
X
X#ifdef BSD
X#define strchr(ptr, c)			index(ptr, c)
X#define strrchr(ptr, c)			rindex(ptr, c)
X#define memset(ptr, c, size)	bsdmemset(ptr, c, size)
Xchar *bsdmemset __ARGS((char *, int, long));
X#endif
X
Xtypedef long			linenr_t;	/* line number type */
Xtypedef unsigned		colnr_t;	/* column number type */
Xtypedef struct fpos		FPOS;		/* file position type */
X
X#define INVLNUM (0x7fffffff)		/* invalid line number */
X
Xstruct fpos
X{
X		linenr_t		lnum;	/* line number */
X		colnr_t 		col;	/* column number */
X};
END_OF_FILE
if test 6430 -ne `wc -c <'vim/src/vim.h'`; then
    echo shar: \"'vim/src/vim.h'\" unpacked with wrong size!
fi
# end of 'vim/src/vim.h'
fi
echo shar: End of archive 3 \(of 23\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 23 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-------------8<----------------8<----------------8<---------------8<--------
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595450 | whatever will be accepted.

exit 0 # Just in case...
