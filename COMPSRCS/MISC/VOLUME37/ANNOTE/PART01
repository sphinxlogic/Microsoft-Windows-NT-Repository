Newsgroups: comp.sources.misc
From: arrouye@cosmos.imag.fr (Yves Arrouye)
Subject: v37i057:  annote - BibTeX styles supporting annotations, Part01/03
Message-ID: <csm-v37i057=annote.201417@sparky.IMD.Sterling.COM>
X-Md4-Signature: c9bc19ed26c0436641cf854b5736b44b
Date: Sun, 16 May 1993 01:14:33 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: arrouye@cosmos.imag.fr (Yves Arrouye)
Posting-number: Volume 37, Issue 57
Archive-name: annote/part01
Environment: LaTex

Announcing the `annote' package for BibTeX styles supporting annotations.

The package is intended to facilitate the use of annotated bibliographies
by enabling one to modify ``normal'' BibTeX styles in order to support
an `annote' field (like is available in Bibcard). The advantages of
this package over existing annotated bibliographies are twofold: users can
easily customize the annotation layout, and existing BibTeX styles can
be automatically modified in order to support the `annote' package.

Styles for BibTeX may be developped using the conventions of this
package, or existing style files may be converted to these
conventions. Automatic conversion of the files is available through
two interactive Emacs functions.
  
The `annotated' BibTeX styles support listing the bibliographies in
annotated or non-annotated forms without any further modifications;
instead, the user can include a style file defining his preferred
layout of annotations and use it on her bibliography. This layout is
easily modified by using a simple LaTeX \renewcommand.

This release contains the `annote' package and some example BibTeX
styles, including the ones bundled with the LaTeX distribution (i.e.
`plain.bst', `alpha.bst', `unsrt.bst' and `abbrv.bst'); these BibTeX
styles were all modified to support `annote', some by hand when
annotebib.el wasn't wrote, the other with annotebib.el.

Simple documentation is in the `annote.README' file.

Yves Arrouye <arrouye@imag.imag.fr>
May, 1993
-------------------------------------------------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README alpha.bst annotebib.el plain.bst
# Wrapped by kent@sparky on Sat May 15 20:06:12 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1868 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the ``annote'' package, which provides a simple and convenient
Xway to add support for annotated bibliographies to LaTeX.
X
XThis package provides you with:
X
X  1. A generic way to add annotation capacities to your BibTeX styles.
X
X  2. An automated way of modifying your existing files.
X
X  3. A style of annotations which can be redefined by the user.
X
X
XTo make the package work, one has to make the following steps:
X
X  1. Change the .bst files to add support for annotation. This is done
X     by adding the annote field in the ENTRY list, adding the
X     format.annote function to the style file, and changing the
X     fin.entry (or the corresponding entry-closing function) by adding
X     a call to format.annote at the end of the function, followed by a
X     write$ call.
X       See the "annotebib.add" file for the source of the modifications.
X
X     * This step can be automated on most bibliography styles with the
X     use of the `annotebib.el' functions. It is the preferred (and
X     painless) way to make such modifications.
X
X  2. Install "annote.sty" in one of your LaTeX directories (one which
X     is listed in the TEXINPUTS environment variable).
X
X  3. Use it! Just add annote to your \documentstyle options when you
X     need it, or define the annote environment in your document, or
X     make that definition (the one you prefer, of course) a new .sty
X     file...
X
X       For example, to have annotations printed as quotations in
X     emphasized typeface, just say
X
X	  \newenvironment{annote}{\begin{quotation}\em}{\end{quotation}}
X
X     in your document, before the \bibliography statement.
X
X  NOTE. The modifications here use the "annote" field of the .bib
X        file, which can be easily edited with BibCard (menu "View",
X        item "Annotation..."), but one can easily change that field.
X
X
XYves Arrouye (arrouye@imag.imag.fr)
XMay 12, 1993
X
END_OF_FILE
  if test 1868 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'alpha.bst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'alpha.bst'\"
else
  echo shar: Extracting \"'alpha.bst'\" \(24397 characters\)
  sed "s/^X//" >'alpha.bst' <<'END_OF_FILE'
X% Style file modified on Wed May 12 20:53:22 1993
X%                     by Yves.Arrouye <arrouye@cosmos>
X
X% This bibliography style was made annote-compatible by annotebib.el v1.0
X% It can be used for both annotated and non-annotated bibliographies listing
X% (annote package by Yves Arrouye <arrouye@imag.imag.fr>)
X
X% BibTeX standard bibliography style `alpha'
X        % version 0.99a for BibTeX versions 0.99a or later, LaTeX version 2.09.
X        % Copyright (C) 1985, all rights reserved.
X        % Copying of this file is authorized only if either
X        % (1) you make absolutely no changes to your copy, including name, or
X        % (2) if you do make changes, you name it something other than
X        % btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
X        % This restriction helps ensure that all standard styles are identical.
X        % The file btxbst.doc has the documentation for this style.
X
XENTRY
X  { annote
X    address
X    author
X    booktitle
X    chapter
X    edition
X    editor
X    howpublished
X    institution
X    journal
X    key
X    month
X    note
X    number
X    organization
X    pages
X    publisher
X    school
X    series
X    title
X    type
X    volume
X    year
X  }
X  {}
X  { label extra.label sort.label }
X
XINTEGERS { output.state before.all mid.sentence after.sentence after.block }
X
XFUNCTION {init.state.consts}
X{ #0 'before.all :=
X  #1 'mid.sentence :=
X  #2 'after.sentence :=
X  #3 'after.block :=
X}
X
XSTRINGS { s t }
X
XFUNCTION {output.nonnull}
X{ 's :=
X  output.state mid.sentence =
X    { ", " * write$ }
X    { output.state after.block =
X        { add.period$ write$
X          newline$
X          "\newblock " write$
X        }
X        { output.state before.all =
X            'write$
X            { add.period$ " " * write$ }
X          if$
X        }
X      if$
X      mid.sentence 'output.state :=
X    }
X  if$
X  s
X}
X
XFUNCTION {output}
X{ duplicate$ empty$
X    'pop$
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.check}
X{ 't :=
X  duplicate$ empty$
X    { pop$ "empty " t * " in " * cite$ * warning$ }
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.bibitem}
X{ newline$
X  "\bibitem[" write$
X  label write$
X  "]{" write$
X  cite$ write$
X  "}" write$
X  newline$
X  ""
X  before.all 'output.state :=
X}
X
XFUNCTION {format.annote}
X{ annote empty$
X        { "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X          annote
X          * " \end{annote}\fi " *
X        }
X      if$
X}
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  format.annote write$
X}
X
XFUNCTION {new.block}
X{ output.state before.all =
X    'skip$
X    { after.block 'output.state := }
X  if$
X}
X
XFUNCTION {new.sentence}
X{ output.state after.block =
X    'skip$
X    { output.state before.all =
X        'skip$
X        { after.sentence 'output.state := }
X      if$
X    }
X  if$
X}
X
XFUNCTION {not}
X{   { #0 }
X    { #1 }
X  if$
X}
X
XFUNCTION {and}
X{   'skip$
X    { pop$ #0 }
X  if$
X}
X
XFUNCTION {or}
X{   { pop$ #1 }
X    'skip$
X  if$
X}
X
XFUNCTION {new.block.checka}
X{ empty$
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.block.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.sentence.checka}
X{ empty$
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {new.sentence.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {field.or.null}
X{ duplicate$ empty$
X    { pop$ "" }
X    'skip$
X  if$
X}
X
XFUNCTION {emphasize}
X{ duplicate$ empty$
X    { pop$ "" }
X    { "{\em " swap$ * "}" * }
X  if$
X}
X
XINTEGERS { nameptr namesleft numnames }
X
XFUNCTION {format.names}
X{ 's :=
X  #1 'nameptr :=
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=
X      nameptr #1 >
X        { namesleft #1 >
X            { ", " * t * }
X            { numnames #2 >
X                { "," * }
X                'skip$
X              if$
X              t "others" =
X                { " et~al." * }
X                { " and " * t * }
X              if$
X            }
X          if$
X        }
X        't
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {format.authors}
X{ author empty$
X    { "" }
X    { author format.names }
X  if$
X}
X
XFUNCTION {format.editors}
X{ editor empty$
X    { "" }
X    { editor format.names
X      editor num.names$ #1 >
X        { ", editors" * }
X        { ", editor" * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.title}
X{ title empty$
X    { "" }
X    { title "t" change.case$ }
X  if$
X}
X
XFUNCTION {n.dashify}
X{ 't :=
X  ""
X    { t empty$ not }
X    { t #1 #1 substring$ "-" =
X        { t #1 #2 substring$ "--" = not
X            { "--" *
X              t #2 global.max$ substring$ 't :=
X            }
X            {   { t #1 #1 substring$ "-" = }
X                { "-" *
X                  t #2 global.max$ substring$ 't :=
X                }
X              while$
X            }
X          if$
X        }
X        { t #1 #1 substring$ *
X          t #2 global.max$ substring$ 't :=
X        }
X      if$
X    }
X  while$
X}
X
XFUNCTION {format.date}
X{ year empty$
X    { month empty$
X        { "" }
X        { "there's a month but no year in " cite$ * warning$
X          month
X        }
X      if$
X    }
X    { month empty$
X        'year
X        { month " " * year * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.btitle}
X{ title emphasize
X}
X
XFUNCTION {tie.or.space.connect}
X{ duplicate$ text.length$ #3 <
X    { "~" }
X    { " " }
X  if$
X  swap$ * *
X}
X
XFUNCTION {either.or.check}
X{ empty$
X    'pop$
X    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
X  if$
X}
X
XFUNCTION {format.bvolume}
X{ volume empty$
X    { "" }
X    { "volume" volume tie.or.space.connect
X      series empty$
X        'skip$
X        { " of " * series emphasize * }
X      if$
X      "volume and number" number either.or.check
X    }
X  if$
X}
X
XFUNCTION {format.number.series}
X{ volume empty$
X    { number empty$
X        { series field.or.null }
X        { output.state mid.sentence =
X            { "number" }
X            { "Number" }
X          if$
X          number tie.or.space.connect
X          series empty$
X            { "there's a number but no series in " cite$ * warning$ }
X            { " in " * series * }
X          if$
X        }
X      if$
X    }
X    { "" }
X  if$
X}
X
XFUNCTION {format.edition}
X{ edition empty$
X    { "" }
X    { output.state mid.sentence =
X        { edition "l" change.case$ " edition" * }
X        { edition "t" change.case$ " edition" * }
X      if$
X    }
X  if$
X}
X
XINTEGERS { multiresult }
X
XFUNCTION {multi.page.check}
X{ 't :=
X  #0 'multiresult :=
X    { multiresult not
X      t empty$ not
X      and
X    }
X    { t #1 #1 substring$
X      duplicate$ "-" =
X      swap$ duplicate$ "," =
X      swap$ "+" =
X      or or
X        { #1 'multiresult := }
X        { t #2 global.max$ substring$ 't := }
X      if$
X    }
X  while$
X  multiresult
X}
X
XFUNCTION {format.pages}
X{ pages empty$
X    { "" }
X    { pages multi.page.check
X        { "pages" pages n.dashify tie.or.space.connect }
X        { "page" pages tie.or.space.connect }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.vol.num.pages}
X{ volume field.or.null
X  number empty$
X    'skip$
X    { "(" number * ")" * *
X      volume empty$
X        { "there's a number but no volume in " cite$ * warning$ }
X        'skip$
X      if$
X    }
X  if$
X  pages empty$
X    'skip$
X    { duplicate$ empty$
X        { pop$ format.pages }
X        { ":" * pages n.dashify * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.chapter.pages}
X{ chapter empty$
X    'format.pages
X    { type empty$
X        { "chapter" }
X        { type "l" change.case$ }
X      if$
X      chapter tie.or.space.connect
X      pages empty$
X        'skip$
X        { ", " * format.pages * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.in.ed.booktitle}
X{ booktitle empty$
X    { "" }
X    { editor empty$
X        { "In " booktitle emphasize * }
X        { "In " format.editors * ", " * booktitle emphasize * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {empty.misc.check}
X{ author empty$ title empty$ howpublished empty$
X  month empty$ year empty$ note empty$
X  and and and and and
X  key empty$ not and
X    { "all relevant fields are empty in " cite$ * warning$ }
X    'skip$
X  if$
X}
X
XFUNCTION {format.thesis.type}
X{ type empty$
X    'skip$
X    { pop$
X      type "t" change.case$
X    }
X  if$
X}
X
XFUNCTION {format.tr.number}
X{ type empty$
X    { "Technical Report" }
X    'type
X  if$
X  number empty$
X    { "t" change.case$ }
X    { number tie.or.space.connect }
X  if$
X}
X
XFUNCTION {format.article.crossref}
X{ key empty$
X    { journal empty$
X        { "need key or journal for " cite$ * " to crossref " * crossref *
X          warning$
X          ""
X        }
X        { "In {\em " journal * "\/}" * }
X      if$
X    }
X    { "In " key * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.crossref.editor}
X{ editor #1 "{vv~}{ll}" format.name$
X  editor num.names$ duplicate$
X  #2 >
X    { pop$ " et~al." * }
X    { #2 <
X        'skip$
X        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
X            { " et~al." * }
X            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
X          if$
X        }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.book.crossref}
X{ volume empty$
X    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
X      "In "
X    }
X    { "Volume" volume tie.or.space.connect
X      " of " *
X    }
X  if$
X  editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { series empty$
X            { "need editor, key, or series for " cite$ * " to crossref " *
X              crossref * warning$
X              "" *
X            }
X            { "{\em " * series * "\/}" * }
X          if$
X        }
X        { key * }
X      if$
X    }
X    { format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.incoll.inproc.crossref}
X{ editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { booktitle empty$
X            { "need editor, key, or booktitle for " cite$ * " to crossref " *
X              crossref * warning$
X              ""
X            }
X            { "In {\em " booktitle * "\/}" * }
X          if$
X        }
X        { "In " key * }
X      if$
X    }
X    { "In " format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {article}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { journal emphasize "journal" output.check
X      format.vol.num.pages output
X      format.date "year" output.check
X    }
X    { format.article.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {book}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {booklet}
X{ output.bibitem
X  format.authors output
X  new.block
X  format.title "title" output.check
X  howpublished address new.block.checkb
X  howpublished output
X  address output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inbook}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {incollection}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.chapter.pages output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X      format.edition output
X      format.date "year" output.check
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.chapter.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inproceedings}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.pages output
X      address empty$
X        { organization publisher new.sentence.checkb
X          organization output
X          publisher output
X          format.date "year" output.check
X        }
X        { address output.nonnull
X          format.date "year" output.check
X          new.sentence
X          organization output
X          publisher output
X        }
X      if$
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {conference} { inproceedings }
X
XFUNCTION {manual}
X{ output.bibitem
X  author empty$
X    { organization empty$
X        'skip$
X        { organization output.nonnull
X          address output
X        }
X      if$
X    }
X    { format.authors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  author empty$
X    { organization empty$
X        { address new.block.checka
X          address output
X        }
X        'skip$
X      if$
X    }
X    { organization address new.block.checkb
X      organization output
X      address output
X    }
X  if$
X  format.edition output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {mastersthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  "Master's thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {misc}
X{ output.bibitem
X  format.authors output
X  title howpublished new.block.checkb
X  format.title output
X  howpublished new.block.checka
X  howpublished output
X  format.date output
X  new.block
X  note output
X  fin.entry
X  empty.misc.check
X}
X
XFUNCTION {phdthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.btitle "title" output.check
X  new.block
X  "PhD thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {proceedings}
X{ output.bibitem
X  editor empty$
X    { organization output }
X    { format.editors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  format.bvolume output
X  format.number.series output
X  address empty$
X    { editor empty$
X        { publisher new.sentence.checka }
X        { organization publisher new.sentence.checkb
X          organization output
X        }
X      if$
X      publisher output
X      format.date "year" output.check
X    }
X    { address output.nonnull
X      format.date "year" output.check
X      new.sentence
X      editor empty$
X        'skip$
X        { organization output }
X      if$
X      publisher output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {techreport}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  format.tr.number output.nonnull
X  institution "institution" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {unpublished}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  note "note" output.check
X  format.date output
X  fin.entry
X}
X
XFUNCTION {default.type} { misc }
X
XMACRO {jan} {"January"}
X
XMACRO {feb} {"February"}
X
XMACRO {mar} {"March"}
X
XMACRO {apr} {"April"}
X
XMACRO {may} {"May"}
X
XMACRO {jun} {"June"}
X
XMACRO {jul} {"July"}
X
XMACRO {aug} {"August"}
X
XMACRO {sep} {"September"}
X
XMACRO {oct} {"October"}
X
XMACRO {nov} {"November"}
X
XMACRO {dec} {"December"}
X
XMACRO {acmcs} {"ACM Computing Surveys"}
X
XMACRO {acta} {"Acta Informatica"}
X
XMACRO {cacm} {"Communications of the ACM"}
X
XMACRO {ibmjrd} {"IBM Journal of Research and Development"}
X
XMACRO {ibmsj} {"IBM Systems Journal"}
X
XMACRO {ieeese} {"IEEE Transactions on Software Engineering"}
X
XMACRO {ieeetc} {"IEEE Transactions on Computers"}
X
XMACRO {ieeetcad}
X {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}
X
XMACRO {ipl} {"Information Processing Letters"}
X
XMACRO {jacm} {"Journal of the ACM"}
X
XMACRO {jcss} {"Journal of Computer and System Sciences"}
X
XMACRO {scp} {"Science of Computer Programming"}
X
XMACRO {sicomp} {"SIAM Journal on Computing"}
X
XMACRO {tocs} {"ACM Transactions on Computer Systems"}
X
XMACRO {tods} {"ACM Transactions on Database Systems"}
X
XMACRO {tog} {"ACM Transactions on Graphics"}
X
XMACRO {toms} {"ACM Transactions on Mathematical Software"}
X
XMACRO {toois} {"ACM Transactions on Office Information Systems"}
X
XMACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}
X
XMACRO {tcs} {"Theoretical Computer Science"}
X
XREAD
X
XFUNCTION {sortify}
X{ purify$
X  "l" change.case$
X}
X
XINTEGERS { len }
X
XFUNCTION {chop.word}
X{ 's :=
X  'len :=
X  s #1 len substring$ =
X    { s len #1 + global.max$ substring$ }
X    's
X  if$
X}
X
XINTEGERS { et.al.char.used }
X
XFUNCTION {initialize.et.al.char.used}
X{ #0 'et.al.char.used :=
X}
X
XEXECUTE {initialize.et.al.char.used}
X
XFUNCTION {format.lab.names}
X{ 's :=
X  s num.names$ 'numnames :=
X  numnames #1 >
X    { numnames #4 >
X        { #3 'namesleft := }
X        { numnames 'namesleft := }
X      if$
X      #1 'nameptr :=
X      ""
X        { namesleft #0 > }
X        { nameptr numnames =
X            { s nameptr "{ff }{vv }{ll}{ jj}" format.name$ "others" =
X                { "{\etalchar{+}}" *
X                  #1 'et.al.char.used :=
X                }
X                { s nameptr "{v{}}{l{}}" format.name$ * }
X              if$
X            }
X            { s nameptr "{v{}}{l{}}" format.name$ * }
X          if$
X          nameptr #1 + 'nameptr :=
X          namesleft #1 - 'namesleft :=
X        }
X      while$
X      numnames #4 >
X        { "{\etalchar{+}}" *
X          #1 'et.al.char.used :=
X        }
X        'skip$
X      if$
X    }
X    { s #1 "{v{}}{l{}}" format.name$
X      duplicate$ text.length$ #2 <
X        { pop$ s #1 "{ll}" format.name$ #3 text.prefix$ }
X        'skip$
X      if$
X    }
X  if$
X}
X
XFUNCTION {author.key.label}
X{ author empty$
X    { key empty$
X        { cite$ #1 #3 substring$ }
X        { key #3 text.prefix$ }
X      if$
X    }
X    { author format.lab.names }
X  if$
X}
X
XFUNCTION {author.editor.key.label}
X{ author empty$
X    { editor empty$
X        { key empty$
X            { cite$ #1 #3 substring$ }
X            { key #3 text.prefix$ }
X          if$
X        }
X        { editor format.lab.names }
X      if$
X    }
X    { author format.lab.names }
X  if$
X}
X
XFUNCTION {author.key.organization.label}
X{ author empty$
X    { key empty$
X        { organization empty$
X            { cite$ #1 #3 substring$ }
X            { "The " #4 organization chop.word #3 text.prefix$ }
X          if$
X        }
X        { key #3 text.prefix$ }
X      if$
X    }
X    { author format.lab.names }
X  if$
X}
X
XFUNCTION {editor.key.organization.label}
X{ editor empty$
X    { key empty$
X        { organization empty$
X            { cite$ #1 #3 substring$ }
X            { "The " #4 organization chop.word #3 text.prefix$ }
X          if$
X        }
X        { key #3 text.prefix$ }
X      if$
X    }
X    { editor format.lab.names }
X  if$
X}
X
XFUNCTION {calc.label}
X{ type$ "book" =
X  type$ "inbook" =
X  or
X    'author.editor.key.label
X    { type$ "proceedings" =
X        'editor.key.organization.label
X        { type$ "manual" =
X            'author.key.organization.label
X            'author.key.label
X          if$
X        }
X      if$
X    }
X  if$
X  duplicate$
X  year field.or.null purify$ #-1 #2 substring$
X  *
X  'label :=
X  year field.or.null purify$ #-1 #4 substring$
X  *
X  sortify 'sort.label :=
X}
X
XFUNCTION {sort.format.names}
X{ 's :=
X  #1 'nameptr :=
X  ""
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { nameptr #1 >
X        { "   " * }
X        'skip$
X      if$
X      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=
X      nameptr numnames = t "others" = and
X        { "et al" * }
X        { t sortify * }
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {sort.format.title}
X{ 't :=
X  "A " #2
X    "An " #3
X      "The " #4 t chop.word
X    chop.word
X  chop.word
X  sortify
X  #1 global.max$ substring$
X}
X
XFUNCTION {author.sort}
X{ author empty$
X    { key empty$
X        { "to sort, need author or key in " cite$ * warning$
X          ""
X        }
X        { key sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.editor.sort}
X{ author empty$
X    { editor empty$
X        { key empty$
X            { "to sort, need author, editor, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { editor sort.format.names }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.organization.sort}
X{ author empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need author, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {editor.organization.sort}
X{ editor empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need editor, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { editor sort.format.names }
X  if$
X}
X
XFUNCTION {presort}
X{ calc.label
X  sort.label
X  "    "
X  *
X  type$ "book" =
X  type$ "inbook" =
X  or
X    'author.editor.sort
X    { type$ "proceedings" =
X        'editor.organization.sort
X        { type$ "manual" =
X            'author.organization.sort
X            'author.sort
X          if$
X        }
X      if$
X    }
X  if$
X  *
X  "    "
X  *
X  year field.or.null sortify
X  *
X  "    "
X  *
X  title field.or.null
X  sort.format.title
X  *
X  #1 entry.max$ substring$
X  'sort.key$ :=
X}
X
XITERATE {presort}
X
XSORT
X
XSTRINGS { longest.label last.sort.label next.extra }
X
XINTEGERS { longest.label.width last.extra.num }
X
XFUNCTION {initialize.longest.label}
X{ "" 'longest.label :=
X  #0 int.to.chr$ 'last.sort.label :=
X  "" 'next.extra :=
X  #0 'longest.label.width :=
X  #0 'last.extra.num :=
X}
X
XFUNCTION {forward.pass}
X{ last.sort.label sort.label =
X    { last.extra.num #1 + 'last.extra.num :=
X      last.extra.num int.to.chr$ 'extra.label :=
X    }
X    { "a" chr.to.int$ 'last.extra.num :=
X      "" 'extra.label :=
X      sort.label 'last.sort.label :=
X    }
X  if$
X}
X
XFUNCTION {reverse.pass}
X{ next.extra "b" =
X    { "a" 'extra.label := }
X    'skip$
X  if$
X  label extra.label * 'label :=
X  label width$ longest.label.width >
X    { label 'longest.label :=
X      label width$ 'longest.label.width :=
X    }
X    'skip$
X  if$
X  extra.label 'next.extra :=
X}
X
XEXECUTE {initialize.longest.label}
X
XITERATE {forward.pass}
X
XREVERSE {reverse.pass}
X
XFUNCTION {begin.bib}
X{ et.al.char.used
X    { "\newcommand{\etalchar}[1]{$^{#1}$}" write$ newline$ }
X    'skip$
X  if$
X  preamble$ empty$
X    'skip$
X    { preamble$ write$ newline$ }
X  if$
X  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
X}
X
XEXECUTE {begin.bib}
X
XEXECUTE {init.state.consts}
X
XITERATE {call.type$}
X
XFUNCTION {end.bib}
X{ newline$
X  "\end{thebibliography}" write$ newline$
X}
X
XEXECUTE {end.bib}
END_OF_FILE
  if test 24397 -ne `wc -c <'alpha.bst'`; then
    echo shar: \"'alpha.bst'\" unpacked with wrong size!
  fi
  # end of 'alpha.bst'
fi
if test -f 'annotebib.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annotebib.el'\"
else
  echo shar: Extracting \"'annotebib.el'\" \(6492 characters\)
  sed "s/^X//" >'annotebib.el' <<'END_OF_FILE'
X;;;; annotebib.el, v1.0
X;;;;
X;;;; Transform a bibliography style so that it is compatible with the
X;;;; conventions used by my `annote' package.
X;;;;
X;;;; Yves Arrouye (arrouye@imag.imag.fr), May 1993
X;;;;
X
X;;;; The functions follow the guidelines found in annotebib.add: they
X;;;; look for the ENTRY declaration, add the `annote' field, then look
X;;;; for the fin.entry FUNCTION and add the `format.annote' FUNCTION
X;;;; before it, then add a call to `format.annote' at the end of
X;;;; `fin.entry'.
X;;;;
X;;;; The modification is done in a separate buffer by default, then
X;;;; this buffer is copied into the original one. This means that the
X;;;; modification is undoable by a single undo, and that in case of
X;;;; errors the original file is not modified.
X
X;;;; If the transformation fails, you can either do it by hand
X;;;; (following directions in annotebib.add), or modify the regular
X;;;; expressions used to search for interesting information. The
X;;;; latter approach is best for multiple style files written with the
X;;;; same conventions/functions.
X
X;;; Regexps for recognizing things which interest us.
X
X(defvar annote-entry-regexp "ENTRY[^{]*{"
X  "*A regexp to find the ENTRY fields declaration. This regexp should
Xmatch up to the opening brace af the ENTRY declaration.")
X
X(defvar annote-fin-entry-regexp "FUNCTION[ \t]*{[ \t]*fin.entry[ \t]*}[^{]*"
X  "*A regexp to find the FUNCTION for ending entries. This regexp
Xshould match up to but not including the opening brace of the
Xfunction.")
X
X;;; Other customization
X
X(defvar annote-savefile-prefix ""
X  "* A string prefixed to a bibliography file name when saving it. An
Xempty string means to replace the file if in the same directory.")
X
X;;; Private variables
X
X(setq annote-version-string "v1.0")
X
X;;; Set up a syntax table. The syntax entries are borrowed from a
X;;; BibTeX mode, and the syntax entries for { and } were added for
X;;; security (if the mode the file was in has redefined those chars)
X
X(if (or (not (boundp 'bibtex-mode-syntax-table))
X	(null bibtex-mode-syntax-table))
X    (progn
X      (setq bibtex-mode-syntax-table (copy-syntax-table))
X      (modify-syntax-entry ?\$ "$$  ")
X      (modify-syntax-entry ?\% "<   ")
X      (modify-syntax-entry ?\f ">   ")
X      (modify-syntax-entry ?\n ">   ")
X      (modify-syntax-entry ?'  "w   ")
X      (modify-syntax-entry ?@  "w   ")
X      (modify-syntax-entry ?{  "(}")
X      (modify-syntax-entry ?}  "){")))
X
X;;; Annotation of a bibliography in a buffer. This is the basic
X;;; annotation primitive.
X
X(defun annote-buffer (&optional in-place noerror)
X  "Annote the bibliography style in the current buffer. If a non-nil argument
Xis given, the file is edited in place. Does nothing if the buffer
Xalready supports (or looks like it does support) annote'.
X
XReturn the success of the modification, or the list '(no-change) if already
Xsupporting `annote'."
X  (interactive "P")
X  (let ((success nil)
X	(old-syntax (syntax-table))
X	(tembuf (if (not in-place) (generate-new-buffer " annote temp")))
X	(bibbuf (current-buffer)))
X    (unwind-protect
X	(save-excursion
X	  (if (search-forward "FUNCTION {format.annote}" (point-max) t)
X	      (setq success '(no-change))
X	    (if (not in-place)
X		(progn
X		  (set-buffer tembuf)
X		  (erase-buffer)
X		  (insert-buffer-substring bibbuf)))
X	    (set-syntax-table bibtex-mode-syntax-table)
X	    (goto-char (point-min))
X	    (insert "\
X% Style file modified on " (current-time-string) "\n\
X%                     by " (user-full-name)
X" <" (user-real-login-name) "@" (system-name) ">\n
X% This bibliography style was made annote-compatible by annotebib.el "
Xannote-version-string "\n\
X% It can be used for both annotated and non-annotated bibliographies \
Xlisting\n\
X% (annote package by Yves Arrouye <arrouye@imag.imag.fr>)\n\n")
X	    (if (not (re-search-forward annote-entry-regexp (point-max) t))
X		(error "Cannot find ENTRY declaration")
X	      (goto-char (match-end 0))
X	      (insert " annote\n   ")
X	      (if (not (re-search-forward annote-fin-entry-regexp
X					  (point-max) t))
X		  (error "Cannot find FUNCTION for ending entries")
X		;; found the fin.entry function
X		(setq success t)
X		(goto-char (1- (scan-lists (match-end 0) 1 0)))
X		(insert "  format.annote write$\n")
X		(goto-char (1- (match-beginning 0)))
X		(insert "\n\
XFUNCTION {format.annote}\n\
X{ annote empty$\n\
X        { \"\" }\n\
X        { \"\\ifx\\annote\\undefined\\else\\begin{annote} \"\n\
X          annote\n\
X          * \" \\end{annote}\\fi \" *\n\
X        }\n\
X      if$\n\
X}\n")
X		(if (not in-place)
X		    (progn
X		      (set-buffer bibbuf)
X		      (erase-buffer)
X		      (insert-buffer-substring tembuf)))))))
X      (set-syntax-table old-syntax)
X      (if tembuf (kill-buffer tembuf)))
X      success))
X
X;;; Annotation of a file.
X;;;
X;;; If not called interactively, and savefile is nil, then the original
X;;; file is modified.
X
X(defun annote-file (origfile &optional savefile)
X  "Annote a file. If called interactively, asks for an existing
Xfilename, then for the name of the annotated file. If this name is a
Xdirectory, then the name of the file will be the filename of the
Xoriginal file in this directory, unless the directories are the same,
Xin which case the original file will have the value of
Xannote-savefile-prefix prefixed to it.
X
XIf annote-buffer fails on the loaded file, it is not saved. Return
Xsuccess as got from annote-buffer."
X  (interactive"fBib file: \nFSave file: ")
X  (if savefile
X      ;; a savefile is specified
X      (progn
X	(if (string-match ".+\\(/+\\)$" savefile)
X	    (setq savefile (substring savefile 0 (match-beginning 1))))
X	(if (file-directory-p savefile)
X	    ;; the savefile is a directory
X	    (progn
X	      (setq savefile (concat savefile "/"))
X	      (setq savefile
X		    (concat savefile
X			    (if (string-equal (file-name-directory origfile)
X					      savefile)
X				;; same directory: append the contents of
X				;; the annote-savefile-prefix variable
X				annote-savefile-prefix)
X			    (file-name-nondirectory origfile)))))))
X  ;; now do the real job: load the file, modify it, and save it
X  (let ((success nil)
X	(tembuf (find-file-noselect origfile)))
X    (unwind-protect
X	(save-excursion
X	  (set-buffer tembuf)
X	  (if (setq success (annote-buffer t))
X	      (progn
X		(if savefile
X		    (set-visited-file-name savefile))
X		(if (buffer-modified-p)
X		    (save-buffer)))))
X      (if (not success)
X	  ;; don't save!
X	  (progn
X	    (set-buffer tembuf)
X	    (set-buffer-modified-p nil))))
X    (kill-buffer tembuf)
X    success))
X
END_OF_FILE
  if test 6492 -ne `wc -c <'annotebib.el'`; then
    echo shar: \"'annotebib.el'\" unpacked with wrong size!
  fi
  # end of 'annotebib.el'
fi
if test -f 'plain.bst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'plain.bst'\"
else
  echo shar: Extracting \"'plain.bst'\" \(21104 characters\)
  sed "s/^X//" >'plain.bst' <<'END_OF_FILE'
X% Style file modified on Wed May 12 19:48:03 1993
X%                     by Yves Arrouye <arrouye@mistral>
X
X% This bibliography style was made annote-compatible by annotebib.el v1.0
X% It can be used for both annotated and non-annotated bibliographies listing
X% (annote package by Yves Arrouye <arrouye@imag.imag.fr>)
X
X% BibTeX standard bibliography style `plain'
X        % version 0.99a for BibTeX versions 0.99a or later, LaTeX version 2.09.
X        % Copyright (C) 1985, all rights reserved.
X        % Copying of this file is authorized only if either
X        % (1) you make absolutely no changes to your copy, including name, or
X        % (2) if you do make changes, you name it something other than
X        % btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
X        % This restriction helps ensure that all standard styles are identical.
X        % The file btxbst.doc has the documentation for this style.
X
XENTRY
X  { annote
X    address
X    author
X    booktitle
X    chapter
X    edition
X    editor
X    howpublished
X    institution
X    journal
X    key
X    month
X    note
X    number
X    organization
X    pages
X    publisher
X    school
X    series
X    title
X    type
X    volume
X    year
X  }
X  {}
X  { label }
X
XINTEGERS { output.state before.all mid.sentence after.sentence after.block }
X
XFUNCTION {init.state.consts}
X{ #0 'before.all :=
X  #1 'mid.sentence :=
X  #2 'after.sentence :=
X  #3 'after.block :=
X}
X
XSTRINGS { s t }
X
XFUNCTION {output.nonnull}
X{ 's :=
X  output.state mid.sentence =
X    { ", " * write$ }
X    { output.state after.block =
X        { add.period$ write$
X          newline$
X          "\newblock " write$
X        }
X        { output.state before.all =
X            'write$
X            { add.period$ " " * write$ }
X          if$
X        }
X      if$
X      mid.sentence 'output.state :=
X    }
X  if$
X  s
X}
X
XFUNCTION {output}
X{ duplicate$ empty$
X    'pop$
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.check}
X{ 't :=
X  duplicate$ empty$
X    { pop$ "empty " t * " in " * cite$ * warning$ }
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.bibitem}
X{ newline$
X  "\bibitem{" write$
X  cite$ write$
X  "}" write$
X  newline$
X  ""
X  before.all 'output.state :=
X}
X
XFUNCTION {format.annote}
X{ annote empty$
X        { "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X          annote
X          * " \end{annote}\fi " *
X        }
X      if$
X}
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  format.annote write$
X}
X
XFUNCTION {new.block}
X{ output.state before.all =
X    'skip$
X    { after.block 'output.state := }
X  if$
X}
X
XFUNCTION {new.sentence}
X{ output.state after.block =
X    'skip$
X    { output.state before.all =
X        'skip$
X        { after.sentence 'output.state := }
X      if$
X    }
X  if$
X}
X
XFUNCTION {not}
X{   { #0 }
X    { #1 }
X  if$
X}
X
XFUNCTION {and}
X{   'skip$
X    { pop$ #0 }
X  if$
X}
X
XFUNCTION {or}
X{   { pop$ #1 }
X    'skip$
X  if$
X}
X
XFUNCTION {new.block.checka}
X{ empty$
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.block.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.sentence.checka}
X{ empty$
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {new.sentence.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {field.or.null}
X{ duplicate$ empty$
X    { pop$ "" }
X    'skip$
X  if$
X}
X
XFUNCTION {emphasize}
X{ duplicate$ empty$
X    { pop$ "" }
X    { "{\em " swap$ * "}" * }
X  if$
X}
X
XINTEGERS { nameptr namesleft numnames }
X
XFUNCTION {format.names}
X{ 's :=
X  #1 'nameptr :=
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=
X      nameptr #1 >
X        { namesleft #1 >
X            { ", " * t * }
X            { numnames #2 >
X                { "," * }
X                'skip$
X              if$
X              t "others" =
X                { " et~al." * }
X                { " and " * t * }
X              if$
X            }
X          if$
X        }
X        't
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {format.authors}
X{ author empty$
X    { "" }
X    { author format.names }
X  if$
X}
X
XFUNCTION {format.editors}
X{ editor empty$
X    { "" }
X    { editor format.names
X      editor num.names$ #1 >
X        { ", editors" * }
X        { ", editor" * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.title}
X{ title empty$
X    { "" }
X    { title "t" change.case$ }
X  if$
X}
X
XFUNCTION {n.dashify}
X{ 't :=
X  ""
X    { t empty$ not }
X    { t #1 #1 substring$ "-" =
X        { t #1 #2 substring$ "--" = not
X            { "--" *
X              t #2 global.max$ substring$ 't :=
X            }
X            {   { t #1 #1 substring$ "-" = }
X                { "-" *
X                  t #2 global.max$ substring$ 't :=
X                }
X              while$
X            }
X          if$
X        }
X        { t #1 #1 substring$ *
X          t #2 global.max$ substring$ 't :=
X        }
X      if$
X    }
X  while$
X}
X
XFUNCTION {format.date}
X{ year empty$
X    { month empty$
X        { "" }
X        { "there's a month but no year in " cite$ * warning$
X          month
X        }
X      if$
X    }
X    { month empty$
X        'year
X        { month " " * year * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.btitle}
X{ title emphasize
X}
X
XFUNCTION {tie.or.space.connect}
X{ duplicate$ text.length$ #3 <
X    { "~" }
X    { " " }
X  if$
X  swap$ * *
X}
X
XFUNCTION {either.or.check}
X{ empty$
X    'pop$
X    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
X  if$
X}
X
XFUNCTION {format.bvolume}
X{ volume empty$
X    { "" }
X    { "volume" volume tie.or.space.connect
X      series empty$
X        'skip$
X        { " of " * series emphasize * }
X      if$
X      "volume and number" number either.or.check
X    }
X  if$
X}
X
XFUNCTION {format.number.series}
X{ volume empty$
X    { number empty$
X        { series field.or.null }
X        { output.state mid.sentence =
X            { "number" }
X            { "Number" }
X          if$
X          number tie.or.space.connect
X          series empty$
X            { "there's a number but no series in " cite$ * warning$ }
X            { " in " * series * }
X          if$
X        }
X      if$
X    }
X    { "" }
X  if$
X}
X
XFUNCTION {format.edition}
X{ edition empty$
X    { "" }
X    { output.state mid.sentence =
X        { edition "l" change.case$ " edition" * }
X        { edition "t" change.case$ " edition" * }
X      if$
X    }
X  if$
X}
X
XINTEGERS { multiresult }
X
XFUNCTION {multi.page.check}
X{ 't :=
X  #0 'multiresult :=
X    { multiresult not
X      t empty$ not
X      and
X    }
X    { t #1 #1 substring$
X      duplicate$ "-" =
X      swap$ duplicate$ "," =
X      swap$ "+" =
X      or or
X        { #1 'multiresult := }
X        { t #2 global.max$ substring$ 't := }
X      if$
X    }
X  while$
X  multiresult
X}
X
XFUNCTION {format.pages}
X{ pages empty$
X    { "" }
X    { pages multi.page.check
X        { "pages" pages n.dashify tie.or.space.connect }
X        { "page" pages tie.or.space.connect }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.vol.num.pages}
X{ volume field.or.null
X  number empty$
X    'skip$
X    { "(" number * ")" * *
X      volume empty$
X        { "there's a number but no volume in " cite$ * warning$ }
X        'skip$
X      if$
X    }
X  if$
X  pages empty$
X    'skip$
X    { duplicate$ empty$
X        { pop$ format.pages }
X        { ":" * pages n.dashify * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.chapter.pages}
X{ chapter empty$
X    'format.pages
X    { type empty$
X        { "chapter" }
X        { type "l" change.case$ }
X      if$
X      chapter tie.or.space.connect
X      pages empty$
X        'skip$
X        { ", " * format.pages * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.in.ed.booktitle}
X{ booktitle empty$
X    { "" }
X    { editor empty$
X        { "In " booktitle emphasize * }
X        { "In " format.editors * ", " * booktitle emphasize * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {empty.misc.check}
X{ author empty$ title empty$ howpublished empty$
X  month empty$ year empty$ note empty$
X  and and and and and
X  key empty$ not and
X    { "all relevant fields are empty in " cite$ * warning$ }
X    'skip$
X  if$
X}
X
XFUNCTION {format.thesis.type}
X{ type empty$
X    'skip$
X    { pop$
X      type "t" change.case$
X    }
X  if$
X}
X
XFUNCTION {format.tr.number}
X{ type empty$
X    { "Technical Report" }
X    'type
X  if$
X  number empty$
X    { "t" change.case$ }
X    { number tie.or.space.connect }
X  if$
X}
X
XFUNCTION {format.article.crossref}
X{ key empty$
X    { journal empty$
X        { "need key or journal for " cite$ * " to crossref " * crossref *
X          warning$
X          ""
X        }
X        { "In {\em " journal * "\/}" * }
X      if$
X    }
X    { "In " key * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.crossref.editor}
X{ editor #1 "{vv~}{ll}" format.name$
X  editor num.names$ duplicate$
X  #2 >
X    { pop$ " et~al." * }
X    { #2 <
X        'skip$
X        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
X            { " et~al." * }
X            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
X          if$
X        }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.book.crossref}
X{ volume empty$
X    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
X      "In "
X    }
X    { "Volume" volume tie.or.space.connect
X      " of " *
X    }
X  if$
X  editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { series empty$
X            { "need editor, key, or series for " cite$ * " to crossref " *
X              crossref * warning$
X              "" *
X            }
X            { "{\em " * series * "\/}" * }
X          if$
X        }
X        { key * }
X      if$
X    }
X    { format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.incoll.inproc.crossref}
X{ editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { booktitle empty$
X            { "need editor, key, or booktitle for " cite$ * " to crossref " *
X              crossref * warning$
X              ""
X            }
X            { "In {\em " booktitle * "\/}" * }
X          if$
X        }
X        { "In " key * }
X      if$
X    }
X    { "In " format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {article}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { journal emphasize "journal" output.check
X      format.vol.num.pages output
X      format.date "year" output.check
X    }
X    { format.article.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {book}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {booklet}
X{ output.bibitem
X  format.authors output
X  new.block
X  format.title "title" output.check
X  howpublished address new.block.checkb
X  howpublished output
X  address output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inbook}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {incollection}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.chapter.pages output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X      format.edition output
X      format.date "year" output.check
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.chapter.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inproceedings}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.pages output
X      address empty$
X        { organization publisher new.sentence.checkb
X          organization output
X          publisher output
X          format.date "year" output.check
X        }
X        { address output.nonnull
X          format.date "year" output.check
X          new.sentence
X          organization output
X          publisher output
X        }
X      if$
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {conference} { inproceedings }
X
XFUNCTION {manual}
X{ output.bibitem
X  author empty$
X    { organization empty$
X        'skip$
X        { organization output.nonnull
X          address output
X        }
X      if$
X    }
X    { format.authors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  author empty$
X    { organization empty$
X        { address new.block.checka
X          address output
X        }
X        'skip$
X      if$
X    }
X    { organization address new.block.checkb
X      organization output
X      address output
X    }
X  if$
X  format.edition output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {mastersthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  "Master's thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {misc}
X{ output.bibitem
X  format.authors output
X  title howpublished new.block.checkb
X  format.title output
X  howpublished new.block.checka
X  howpublished output
X  format.date output
X  new.block
X  note output
X  fin.entry
X  empty.misc.check
X}
X
XFUNCTION {phdthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.btitle "title" output.check
X  new.block
X  "PhD thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {proceedings}
X{ output.bibitem
X  editor empty$
X    { organization output }
X    { format.editors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  format.bvolume output
X  format.number.series output
X  address empty$
X    { editor empty$
X        { publisher new.sentence.checka }
X        { organization publisher new.sentence.checkb
X          organization output
X        }
X      if$
X      publisher output
X      format.date "year" output.check
X    }
X    { address output.nonnull
X      format.date "year" output.check
X      new.sentence
X      editor empty$
X        'skip$
X        { organization output }
X      if$
X      publisher output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {techreport}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  format.tr.number output.nonnull
X  institution "institution" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {unpublished}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  note "note" output.check
X  format.date output
X  fin.entry
X}
X
XFUNCTION {default.type} { misc }
X
XMACRO {jan} {"January"}
X
XMACRO {feb} {"February"}
X
XMACRO {mar} {"March"}
X
XMACRO {apr} {"April"}
X
XMACRO {may} {"May"}
X
XMACRO {jun} {"June"}
X
XMACRO {jul} {"July"}
X
XMACRO {aug} {"August"}
X
XMACRO {sep} {"September"}
X
XMACRO {oct} {"October"}
X
XMACRO {nov} {"November"}
X
XMACRO {dec} {"December"}
X
XMACRO {acmcs} {"ACM Computing Surveys"}
X
XMACRO {acta} {"Acta Informatica"}
X
XMACRO {cacm} {"Communications of the ACM"}
X
XMACRO {ibmjrd} {"IBM Journal of Research and Development"}
X
XMACRO {ibmsj} {"IBM Systems Journal"}
X
XMACRO {ieeese} {"IEEE Transactions on Software Engineering"}
X
XMACRO {ieeetc} {"IEEE Transactions on Computers"}
X
XMACRO {ieeetcad}
X {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}
X
XMACRO {ipl} {"Information Processing Letters"}
X
XMACRO {jacm} {"Journal of the ACM"}
X
XMACRO {jcss} {"Journal of Computer and System Sciences"}
X
XMACRO {scp} {"Science of Computer Programming"}
X
XMACRO {sicomp} {"SIAM Journal on Computing"}
X
XMACRO {tocs} {"ACM Transactions on Computer Systems"}
X
XMACRO {tods} {"ACM Transactions on Database Systems"}
X
XMACRO {tog} {"ACM Transactions on Graphics"}
X
XMACRO {toms} {"ACM Transactions on Mathematical Software"}
X
XMACRO {toois} {"ACM Transactions on Office Information Systems"}
X
XMACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}
X
XMACRO {tcs} {"Theoretical Computer Science"}
X
XREAD
X
XFUNCTION {sortify}
X{ purify$
X  "l" change.case$
X}
X
XINTEGERS { len }
X
XFUNCTION {chop.word}
X{ 's :=
X  'len :=
X  s #1 len substring$ =
X    { s len #1 + global.max$ substring$ }
X    's
X  if$
X}
X
XFUNCTION {sort.format.names}
X{ 's :=
X  #1 'nameptr :=
X  ""
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { nameptr #1 >
X        { "   " * }
X        'skip$
X      if$
X      s nameptr "{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}" format.name$ 't :=
X      nameptr numnames = t "others" = and
X        { "et al" * }
X        { t sortify * }
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {sort.format.title}
X{ 't :=
X  "A " #2
X    "An " #3
X      "The " #4 t chop.word
X    chop.word
X  chop.word
X  sortify
X  #1 global.max$ substring$
X}
X
XFUNCTION {author.sort}
X{ author empty$
X    { key empty$
X        { "to sort, need author or key in " cite$ * warning$
X          ""
X        }
X        { key sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.editor.sort}
X{ author empty$
X    { editor empty$
X        { key empty$
X            { "to sort, need author, editor, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { editor sort.format.names }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.organization.sort}
X{ author empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need author, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {editor.organization.sort}
X{ editor empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need editor, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { editor sort.format.names }
X  if$
X}
X
XFUNCTION {presort}
X{ type$ "book" =
X  type$ "inbook" =
X  or
X    'author.editor.sort
X    { type$ "proceedings" =
X        'editor.organization.sort
X        { type$ "manual" =
X            'author.organization.sort
X            'author.sort
X          if$
X        }
X      if$
X    }
X  if$
X  "    "
X  *
X  year field.or.null sortify
X  *
X  "    "
X  *
X  title field.or.null
X  sort.format.title
X  *
X  #1 entry.max$ substring$
X  'sort.key$ :=
X}
X
XITERATE {presort}
X
XSORT
X
XSTRINGS { longest.label }
X
XINTEGERS { number.label longest.label.width }
X
XFUNCTION {initialize.longest.label}
X{ "" 'longest.label :=
X  #1 'number.label :=
X  #0 'longest.label.width :=
X}
X
XFUNCTION {longest.label.pass}
X{ number.label int.to.str$ 'label :=
X  number.label #1 + 'number.label :=
X  label width$ longest.label.width >
X    { label 'longest.label :=
X      label width$ 'longest.label.width :=
X    }
X    'skip$
X  if$
X}
X
XEXECUTE {initialize.longest.label}
X
XITERATE {longest.label.pass}
X
XFUNCTION {begin.bib}
X{ preamble$ empty$
X    'skip$
X    { preamble$ write$ newline$ }
X  if$
X  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
X}
X
XEXECUTE {begin.bib}
X
XEXECUTE {init.state.consts}
X
XITERATE {call.type$}
X
XFUNCTION {end.bib}
X{ newline$
X  "\end{thebibliography}" write$ newline$
X}
X
XEXECUTE {end.bib}
END_OF_FILE
  if test 21104 -ne `wc -c <'plain.bst'`; then
    echo shar: \"'plain.bst'\" unpacked with wrong size!
  fi
  # end of 'plain.bst'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
