Newsgroups: comp.sources.misc
From: arrouye@cosmos.imag.fr (Yves Arrouye)
Subject: v37i058:  annote - BibTeX styles supporting annotations, Part02/03
Message-ID: <1993May16.011508.17826@sparky.imd.sterling.com>
X-Md4-Signature: c69b2f53c7e81deaa8dc30eea385f0c1
Date: Sun, 16 May 1993 01:15:08 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: arrouye@cosmos.imag.fr (Yves Arrouye)
Posting-number: Volume 37, Issue 58
Archive-name: annote/part02
Environment: LaTex

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  ANNOUNCE IDEAS Makefile abbrv.bst annote.sty annotebib.add
#   sample.bib sample.tex unsrt.bst
# Wrapped by kent@sparky on Sat May 15 20:06:13 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'ANNOUNCE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ANNOUNCE'\"
else
  echo shar: Extracting \"'ANNOUNCE'\" \(1485 characters\)
  sed "s/^X//" >'ANNOUNCE' <<'END_OF_FILE'
XAnnouncing the `annote' package for BibTeX styles supporting annotations.
X
XThe package is intended to facilitate the use of annotated bibliographies
Xby enabling one to modify ``normal'' BibTeX styles in order to support
Xan `annote' field (like is available in Bibcard). The advantages of
Xthis package over existing annotated bibliographies are twofold: users can
Xeasily customize the annotation layout, and existing BibTeX styles can
Xbe automatically modified in order to support the `annote' package.
X
XStyles for BibTeX may be developped using the conventions of this
Xpackage, or existing style files may be converted to these
Xconventions. Automatic conversion of the files is available through
Xtwo interactive Emacs functions.
X  
XThe `annotated' BibTeX styles support listing the bibliographies in
Xannotated or non-annotated forms without any further modifications;
Xinstead, the user can include a style file defining his preferred
Xlayout of annotations and use it on her bibliography. This layout is
Xeasily modified by using a simple LaTeX \renewcommand.
X
XThis release contains the `annote' package and some example BibTeX
Xstyles, including the ones bundled with the LaTeX distribution (i.e.
X`plain.bst', `alpha.bst', `unsrt.bst' and `abbrv.bst'); these BibTeX
Xstyles were all modified to support `annote', some by hand when
Xannotebib.el wasn't wrote, the other with annotebib.el.
X
XSimple documentation is in the `annote.README' file.
X
XYves Arrouye <arrouye@imag.imag.fr>
XMay, 1993
END_OF_FILE
  if test 1485 -ne `wc -c <'ANNOUNCE'`; then
    echo shar: \"'ANNOUNCE'\" unpacked with wrong size!
  fi
  # end of 'ANNOUNCE'
fi
if test -f 'IDEAS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IDEAS'\"
else
  echo shar: Extracting \"'IDEAS'\" \(463 characters\)
  sed "s/^X//" >'IDEAS' <<'END_OF_FILE'
XThis file is intended to hold ideas for future enhancements of the
X`annote' package. If you have such ideas, please complete this file
Xand email it to the author, Yves Arrouye <arrouye@imag.imag.fr>
X
X1. Make an elaborated \cite command which takes an optional parameter
X   saying if we really want the annotation. This may be used in a
X   bibliography where related items (with similar annotations) are
X   \cite'd, but we do want only one annotation to appear.
X
X
END_OF_FILE
  if test 463 -ne `wc -c <'IDEAS'`; then
    echo shar: \"'IDEAS'\" unpacked with wrong size!
  fi
  # end of 'IDEAS'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(1066 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XBST = *.bst
XSTY = annote.sty
X
XBST2= abbrv.bst alpha.bst
XBST3= plain.bst unsrt.bst
XBST4= siam.bst fsiam.bst lsiam.bst
X
XOTH = ANNOUNCE README IDEAS annotebib.add Makefile
XELP = annotebib.el
X
XALL = $(OTH) $(STY) $(ELP) $(BST)
X
XBSTDIR = /usr/local/lib/tex/inputs
XSTYDIR = /usr/local/lib/tex/inputs
XOTHDIR = $(STYDIR)/documents
XELPDIR = /usr/local/src/Gnu/Emacs18/local-lisp
X
Xshar: manifest shar1 shar2 shar3 shar4
Xmanifest:
X	@echo creating MANIFEST
X	@echo 'Contents of the 4 archives of the `annote'"'"' package' \
X	      >MANIFEST
X	@echo >>MANIFEST
X	@echo "Archive 1: " $(OTH) $(ELP) $(STY) >>MANIFEST
X	@echo "Archive 2: " $(BST2) >>MANIFEST
X	@echo "Archive 3: " $(BST3) >>MANIFEST
X	@echo "Archive 4: " $(BST4) >>MANIFEST
X	@echo >>MANIFEST
X
Xshar1:
X	shar $(OTH) $(ELP) $(STY) >annote.shar.part1
Xshar2:
X	shar $(BST2) >annote.shar.part2
Xshar3:
X	shar $(BST3) >annote.shar.part3
Xshar4:
X	shar $(BST4) >annote.shar.part4
X
Xinstall:
X	install -c -m 664 $(BST) $(BSTDIR)
X	install -c -m 664 $(STY) $(BSTDIR)
X	install -c -m 664 $(ELP) $(ELPDIR)
X	install -c -m 664 $(OTH) $(OTHDIR)
X
END_OF_FILE
  if test 1066 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'abbrv.bst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'abbrv.bst'\"
else
  echo shar: Extracting \"'abbrv.bst'\" \(20820 characters\)
  sed "s/^X//" >'abbrv.bst' <<'END_OF_FILE'
X% Style file modified on Wed May 12 19:27:11 1993
X%                     by Yves Arrouye <arrouye@mistral>
X
X% This bibliography style was made annote-compatible by annotebib.el v1.0
X% It can be used for both annotated and non-annotated bibliographies listing
X% (annote package by Yves Arrouye <arrouye@imag.imag.fr>)
X
X% BibTeX standard bibliography style `abbrv'
X        % version 0.99a for BibTeX versions 0.99a or later, LaTeX version 2.09.
X        % Copyright (C) 1985, all rights reserved.
X        % Copying of this file is authorized only if either
X        % (1) you make absolutely no changes to your copy, including name, or
X        % (2) if you do make changes, you name it something other than
X        % btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
X        % This restriction helps ensure that all standard styles are identical.
X        % The file btxbst.doc has the documentation for this style.
X
XENTRY
X  { annote
X    address
X    author
X    booktitle
X    chapter
X    edition
X    editor
X    howpublished
X    institution
X    journal
X    key
X    month
X    note
X    number
X    organization
X    pages
X    publisher
X    school
X    series
X    title
X    type
X    volume
X    year
X  }
X  {}
X  { label }
X
XINTEGERS { output.state before.all mid.sentence after.sentence after.block }
X
XFUNCTION {init.state.consts}
X{ #0 'before.all :=
X  #1 'mid.sentence :=
X  #2 'after.sentence :=
X  #3 'after.block :=
X}
X
XSTRINGS { s t }
X
XFUNCTION {output.nonnull}
X{ 's :=
X  output.state mid.sentence =
X    { ", " * write$ }
X    { output.state after.block =
X        { add.period$ write$
X          newline$
X          "\newblock " write$
X        }
X        { output.state before.all =
X            'write$
X            { add.period$ " " * write$ }
X          if$
X        }
X      if$
X      mid.sentence 'output.state :=
X    }
X  if$
X  s
X}
X
XFUNCTION {output}
X{ duplicate$ empty$
X    'pop$
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.check}
X{ 't :=
X  duplicate$ empty$
X    { pop$ "empty " t * " in " * cite$ * warning$ }
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.bibitem}
X{ newline$
X  "\bibitem{" write$
X  cite$ write$
X  "}" write$
X  newline$
X  ""
X  before.all 'output.state :=
X}
X
XFUNCTION {format.annote}
X{ annote empty$
X        { "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X          annote
X          * " \end{annote}\fi " *
X        }
X      if$
X}
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  format.annote write$
X}
X
XFUNCTION {new.block}
X{ output.state before.all =
X    'skip$
X    { after.block 'output.state := }
X  if$
X}
X
XFUNCTION {new.sentence}
X{ output.state after.block =
X    'skip$
X    { output.state before.all =
X        'skip$
X        { after.sentence 'output.state := }
X      if$
X    }
X  if$
X}
X
XFUNCTION {not}
X{   { #0 }
X    { #1 }
X  if$
X}
X
XFUNCTION {and}
X{   'skip$
X    { pop$ #0 }
X  if$
X}
X
XFUNCTION {or}
X{   { pop$ #1 }
X    'skip$
X  if$
X}
X
XFUNCTION {new.block.checka}
X{ empty$
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.block.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.sentence.checka}
X{ empty$
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {new.sentence.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {field.or.null}
X{ duplicate$ empty$
X    { pop$ "" }
X    'skip$
X  if$
X}
X
XFUNCTION {emphasize}
X{ duplicate$ empty$
X    { pop$ "" }
X    { "{\em " swap$ * "}" * }
X  if$
X}
X
XINTEGERS { nameptr namesleft numnames }
X
XFUNCTION {format.names}
X{ 's :=
X  #1 'nameptr :=
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { s nameptr "{f.~}{vv~}{ll}{, jj}" format.name$ 't :=
X      nameptr #1 >
X        { namesleft #1 >
X            { ", " * t * }
X            { numnames #2 >
X                { "," * }
X                'skip$
X              if$
X              t "others" =
X                { " et~al." * }
X                { " and " * t * }
X              if$
X            }
X          if$
X        }
X        't
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {format.authors}
X{ author empty$
X    { "" }
X    { author format.names }
X  if$
X}
X
XFUNCTION {format.editors}
X{ editor empty$
X    { "" }
X    { editor format.names
X      editor num.names$ #1 >
X        { ", editors" * }
X        { ", editor" * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.title}
X{ title empty$
X    { "" }
X    { title "t" change.case$ }
X  if$
X}
X
XFUNCTION {n.dashify}
X{ 't :=
X  ""
X    { t empty$ not }
X    { t #1 #1 substring$ "-" =
X        { t #1 #2 substring$ "--" = not
X            { "--" *
X              t #2 global.max$ substring$ 't :=
X            }
X            {   { t #1 #1 substring$ "-" = }
X                { "-" *
X                  t #2 global.max$ substring$ 't :=
X                }
X              while$
X            }
X          if$
X        }
X        { t #1 #1 substring$ *
X          t #2 global.max$ substring$ 't :=
X        }
X      if$
X    }
X  while$
X}
X
XFUNCTION {format.date}
X{ year empty$
X    { month empty$
X        { "" }
X        { "there's a month but no year in " cite$ * warning$
X          month
X        }
X      if$
X    }
X    { month empty$
X        'year
X        { month " " * year * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.btitle}
X{ title emphasize
X}
X
XFUNCTION {tie.or.space.connect}
X{ duplicate$ text.length$ #3 <
X    { "~" }
X    { " " }
X  if$
X  swap$ * *
X}
X
XFUNCTION {either.or.check}
X{ empty$
X    'pop$
X    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
X  if$
X}
X
XFUNCTION {format.bvolume}
X{ volume empty$
X    { "" }
X    { "volume" volume tie.or.space.connect
X      series empty$
X        'skip$
X        { " of " * series emphasize * }
X      if$
X      "volume and number" number either.or.check
X    }
X  if$
X}
X
XFUNCTION {format.number.series}
X{ volume empty$
X    { number empty$
X        { series field.or.null }
X        { output.state mid.sentence =
X            { "number" }
X            { "Number" }
X          if$
X          number tie.or.space.connect
X          series empty$
X            { "there's a number but no series in " cite$ * warning$ }
X            { " in " * series * }
X          if$
X        }
X      if$
X    }
X    { "" }
X  if$
X}
X
XFUNCTION {format.edition}
X{ edition empty$
X    { "" }
X    { output.state mid.sentence =
X        { edition "l" change.case$ " edition" * }
X        { edition "t" change.case$ " edition" * }
X      if$
X    }
X  if$
X}
X
XINTEGERS { multiresult }
X
XFUNCTION {multi.page.check}
X{ 't :=
X  #0 'multiresult :=
X    { multiresult not
X      t empty$ not
X      and
X    }
X    { t #1 #1 substring$
X      duplicate$ "-" =
X      swap$ duplicate$ "," =
X      swap$ "+" =
X      or or
X        { #1 'multiresult := }
X        { t #2 global.max$ substring$ 't := }
X      if$
X    }
X  while$
X  multiresult
X}
X
XFUNCTION {format.pages}
X{ pages empty$
X    { "" }
X    { pages multi.page.check
X        { "pages" pages n.dashify tie.or.space.connect }
X        { "page" pages tie.or.space.connect }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.vol.num.pages}
X{ volume field.or.null
X  number empty$
X    'skip$
X    { "(" number * ")" * *
X      volume empty$
X        { "there's a number but no volume in " cite$ * warning$ }
X        'skip$
X      if$
X    }
X  if$
X  pages empty$
X    'skip$
X    { duplicate$ empty$
X        { pop$ format.pages }
X        { ":" * pages n.dashify * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.chapter.pages}
X{ chapter empty$
X    'format.pages
X    { type empty$
X        { "chapter" }
X        { type "l" change.case$ }
X      if$
X      chapter tie.or.space.connect
X      pages empty$
X        'skip$
X        { ", " * format.pages * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.in.ed.booktitle}
X{ booktitle empty$
X    { "" }
X    { editor empty$
X        { "In " booktitle emphasize * }
X        { "In " format.editors * ", " * booktitle emphasize * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {empty.misc.check}
X{ author empty$ title empty$ howpublished empty$
X  month empty$ year empty$ note empty$
X  and and and and and
X  key empty$ not and
X    { "all relevant fields are empty in " cite$ * warning$ }
X    'skip$
X  if$
X}
X
XFUNCTION {format.thesis.type}
X{ type empty$
X    'skip$
X    { pop$
X      type "t" change.case$
X    }
X  if$
X}
X
XFUNCTION {format.tr.number}
X{ type empty$
X    { "Technical Report" }
X    'type
X  if$
X  number empty$
X    { "t" change.case$ }
X    { number tie.or.space.connect }
X  if$
X}
X
XFUNCTION {format.article.crossref}
X{ key empty$
X    { journal empty$
X        { "need key or journal for " cite$ * " to crossref " * crossref *
X          warning$
X          ""
X        }
X        { "In {\em " journal * "\/}" * }
X      if$
X    }
X    { "In " key * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.crossref.editor}
X{ editor #1 "{vv~}{ll}" format.name$
X  editor num.names$ duplicate$
X  #2 >
X    { pop$ " et~al." * }
X    { #2 <
X        'skip$
X        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
X            { " et~al." * }
X            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
X          if$
X        }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.book.crossref}
X{ volume empty$
X    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
X      "In "
X    }
X    { "Volume" volume tie.or.space.connect
X      " of " *
X    }
X  if$
X  editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { series empty$
X            { "need editor, key, or series for " cite$ * " to crossref " *
X              crossref * warning$
X              "" *
X            }
X            { "{\em " * series * "\/}" * }
X          if$
X        }
X        { key * }
X      if$
X    }
X    { format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.incoll.inproc.crossref}
X{ editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { booktitle empty$
X            { "need editor, key, or booktitle for " cite$ * " to crossref " *
X              crossref * warning$
X              ""
X            }
X            { "In {\em " booktitle * "\/}" * }
X          if$
X        }
X        { "In " key * }
X      if$
X    }
X    { "In " format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {article}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { journal emphasize "journal" output.check
X      format.vol.num.pages output
X      format.date "year" output.check
X    }
X    { format.article.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {book}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {booklet}
X{ output.bibitem
X  format.authors output
X  new.block
X  format.title "title" output.check
X  howpublished address new.block.checkb
X  howpublished output
X  address output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inbook}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {incollection}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.chapter.pages output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X      format.edition output
X      format.date "year" output.check
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.chapter.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inproceedings}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.pages output
X      address empty$
X        { organization publisher new.sentence.checkb
X          organization output
X          publisher output
X          format.date "year" output.check
X        }
X        { address output.nonnull
X          format.date "year" output.check
X          new.sentence
X          organization output
X          publisher output
X        }
X      if$
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {conference} { inproceedings }
X
XFUNCTION {manual}
X{ output.bibitem
X  author empty$
X    { organization empty$
X        'skip$
X        { organization output.nonnull
X          address output
X        }
X      if$
X    }
X    { format.authors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  author empty$
X    { organization empty$
X        { address new.block.checka
X          address output
X        }
X        'skip$
X      if$
X    }
X    { organization address new.block.checkb
X      organization output
X      address output
X    }
X  if$
X  format.edition output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {mastersthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  "Master's thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {misc}
X{ output.bibitem
X  format.authors output
X  title howpublished new.block.checkb
X  format.title output
X  howpublished new.block.checka
X  howpublished output
X  format.date output
X  new.block
X  note output
X  fin.entry
X  empty.misc.check
X}
X
XFUNCTION {phdthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.btitle "title" output.check
X  new.block
X  "PhD thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {proceedings}
X{ output.bibitem
X  editor empty$
X    { organization output }
X    { format.editors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  format.bvolume output
X  format.number.series output
X  address empty$
X    { editor empty$
X        { publisher new.sentence.checka }
X        { organization publisher new.sentence.checkb
X          organization output
X        }
X      if$
X      publisher output
X      format.date "year" output.check
X    }
X    { address output.nonnull
X      format.date "year" output.check
X      new.sentence
X      editor empty$
X        'skip$
X        { organization output }
X      if$
X      publisher output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {techreport}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  format.tr.number output.nonnull
X  institution "institution" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {unpublished}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  note "note" output.check
X  format.date output
X  fin.entry
X}
X
XFUNCTION {default.type} { misc }
X
XMACRO {jan} {"Jan."}
X
XMACRO {feb} {"Feb."}
X
XMACRO {mar} {"Mar."}
X
XMACRO {apr} {"Apr."}
X
XMACRO {may} {"May"}
X
XMACRO {jun} {"June"}
X
XMACRO {jul} {"July"}
X
XMACRO {aug} {"Aug."}
X
XMACRO {sep} {"Sept."}
X
XMACRO {oct} {"Oct."}
X
XMACRO {nov} {"Nov."}
X
XMACRO {dec} {"Dec."}
X
XMACRO {acmcs} {"ACM Comput. Surv."}
X
XMACRO {acta} {"Acta Inf."}
X
XMACRO {cacm} {"Commun. ACM"}
X
XMACRO {ibmjrd} {"IBM J. Res. Dev."}
X
XMACRO {ibmsj} {"IBM Syst.~J."}
X
XMACRO {ieeese} {"IEEE Trans. Softw. Eng."}
X
XMACRO {ieeetc} {"IEEE Trans. Comput."}
X
XMACRO {ieeetcad}
X {"IEEE Trans. Comput.-Aided Design Integrated Circuits"}
X
XMACRO {ipl} {"Inf. Process. Lett."}
X
XMACRO {jacm} {"J.~ACM"}
X
XMACRO {jcss} {"J.~Comput. Syst. Sci."}
X
XMACRO {scp} {"Sci. Comput. Programming"}
X
XMACRO {sicomp} {"SIAM J. Comput."}
X
XMACRO {tocs} {"ACM Trans. Comput. Syst."}
X
XMACRO {tods} {"ACM Trans. Database Syst."}
X
XMACRO {tog} {"ACM Trans. Gr."}
X
XMACRO {toms} {"ACM Trans. Math. Softw."}
X
XMACRO {toois} {"ACM Trans. Office Inf. Syst."}
X
XMACRO {toplas} {"ACM Trans. Prog. Lang. Syst."}
X
XMACRO {tcs} {"Theoretical Comput. Sci."}
X
XREAD
X
XFUNCTION {sortify}
X{ purify$
X  "l" change.case$
X}
X
XINTEGERS { len }
X
XFUNCTION {chop.word}
X{ 's :=
X  'len :=
X  s #1 len substring$ =
X    { s len #1 + global.max$ substring$ }
X    's
X  if$
X}
X
XFUNCTION {sort.format.names}
X{ 's :=
X  #1 'nameptr :=
X  ""
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { nameptr #1 >
X        { "   " * }
X        'skip$
X      if$
X      s nameptr "{vv{ } }{ll{ }}{  f{ }}{  jj{ }}" format.name$ 't :=
X      nameptr numnames = t "others" = and
X        { "et al" * }
X        { t sortify * }
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {sort.format.title}
X{ 't :=
X  "A " #2
X    "An " #3
X      "The " #4 t chop.word
X    chop.word
X  chop.word
X  sortify
X  #1 global.max$ substring$
X}
X
XFUNCTION {author.sort}
X{ author empty$
X    { key empty$
X        { "to sort, need author or key in " cite$ * warning$
X          ""
X        }
X        { key sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.editor.sort}
X{ author empty$
X    { editor empty$
X        { key empty$
X            { "to sort, need author, editor, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { editor sort.format.names }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {author.organization.sort}
X{ author empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need author, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { author sort.format.names }
X  if$
X}
X
XFUNCTION {editor.organization.sort}
X{ editor empty$
X    { organization empty$
X        { key empty$
X            { "to sort, need editor, organization, or key in " cite$ * warning$
X              ""
X            }
X            { key sortify }
X          if$
X        }
X        { "The " #4 organization chop.word sortify }
X      if$
X    }
X    { editor sort.format.names }
X  if$
X}
X
XFUNCTION {presort}
X{ type$ "book" =
X  type$ "inbook" =
X  or
X    'author.editor.sort
X    { type$ "proceedings" =
X        'editor.organization.sort
X        { type$ "manual" =
X            'author.organization.sort
X            'author.sort
X          if$
X        }
X      if$
X    }
X  if$
X  "    "
X  *
X  year field.or.null sortify
X  *
X  "    "
X  *
X  title field.or.null
X  sort.format.title
X  *
X  #1 entry.max$ substring$
X  'sort.key$ :=
X}
X
XITERATE {presort}
X
XSORT
X
XSTRINGS { longest.label }
X
XINTEGERS { number.label longest.label.width }
X
XFUNCTION {initialize.longest.label}
X{ "" 'longest.label :=
X  #1 'number.label :=
X  #0 'longest.label.width :=
X}
X
XFUNCTION {longest.label.pass}
X{ number.label int.to.str$ 'label :=
X  number.label #1 + 'number.label :=
X  label width$ longest.label.width >
X    { label 'longest.label :=
X      label width$ 'longest.label.width :=
X    }
X    'skip$
X  if$
X}
X
XEXECUTE {initialize.longest.label}
X
XITERATE {longest.label.pass}
X
XFUNCTION {begin.bib}
X{ preamble$ empty$
X    'skip$
X    { preamble$ write$ newline$ }
X  if$
X  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
X}
X
XEXECUTE {begin.bib}
X
XEXECUTE {init.state.consts}
X
XITERATE {call.type$}
X
XFUNCTION {end.bib}
X{ newline$
X  "\end{thebibliography}" write$ newline$
X}
X
XEXECUTE {end.bib}
END_OF_FILE
  if test 20820 -ne `wc -c <'abbrv.bst'`; then
    echo shar: \"'abbrv.bst'\" unpacked with wrong size!
  fi
  # end of 'abbrv.bst'
fi
if test -f 'annote.sty' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annote.sty'\"
else
  echo shar: Extracting \"'annote.sty'\" \(287 characters\)
  sed "s/^X//" >'annote.sty' <<'END_OF_FILE'
X% annote.sty, by Yves Arrouye (arrouye@imag.imag.fr)
X%
X% This style file must be used in conjunction with a .bst file
X% supporting the annote environment, and writing annotations in such
X% an environment.
X%
X% Grenoble, April 13, 1993
X
X\newenvironment{annote}{\begin{quote}}{\end{quote}}
END_OF_FILE
  if test 287 -ne `wc -c <'annote.sty'`; then
    echo shar: \"'annote.sty'\" unpacked with wrong size!
  fi
  # end of 'annote.sty'
fi
if test -f 'annotebib.add' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annotebib.add'\"
else
  echo shar: Extracting \"'annotebib.add'\" \(628 characters\)
  sed "s/^X//" >'annotebib.add' <<'END_OF_FILE'
X% annotebib.add: what to add/change to a .bst file to support annotations
X%
X% Yves Arrouye (arrouye@imag.imag.fr)
X%
X% April 13, 1993
X
X% You have to add the following field to the ENTRY list (after the
X% address field)
X
Xannote
X
X% This function has to be added to your .bst file
X
XFUNCTION {format.annote}
X{ annote empty$
X	{ "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X	  annote
X	  * " \end{annote}\fi " *
X	}
X      if$
X}
X
X% The fin.entry function is changed to call format.annote just before
X% the end (closing brace) of the function.
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  format.annote write$
X}
END_OF_FILE
  if test 628 -ne `wc -c <'annotebib.add'`; then
    echo shar: \"'annotebib.add'\" unpacked with wrong size!
  fi
  # end of 'annotebib.add'
fi
if test -f 'sample.bib' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.bib'\"
else
  echo shar: Extracting \"'sample.bib'\" \(5203 characters\)
  sed "s/^X//" >'sample.bib' <<'END_OF_FILE'
X
X
X@manual{gnu:lew90el,
X   author = {Bil Lewis and Dan {LaLiberte} and {the GNU Manual Group}},
X   address = {675 Mass Ave, Cambridge, MA 02139},
X   edition = {1.03},
X   month = dec,
X   organization = {Free Software Foundation},
X   title = {{GNU Emacs Lisp Reference Manual}},
X   year = {1990},
X   annote = {Manuel de r\'ef\'erence d'Elisp (pour Emacs Lisp), le Lisp sp\'ecialis\'e int\'egr\'e \`a
XEmacs. Ce Lisp permet d'\'etendre facilement les fonctionnalit\'es d'Emacs, et dispose, outre les primitives Lisp ``classiques'', d'un tr\`es grand nombre de primitives sp\'ecialis\'ees dans la gestion de l'\'edition (insertion, destruction, recherche et remplacement de cha\^\i{}nes et d'expressions r\'eguli\`eres, gestion des modes et fen\^etres d'Emacs, etc\ldots{}), la manipulation de fichiers et la gestion de processus ``attach\'es'' \`a Emacs.}
X}
X
X@manual{gnu:sta92em,
X   author = {Richard M. Stallman},
X   address = {675 Mass Ave, Cambridge, MA 02139},
X   edition = {7},
X   month = sep,
X   note = {Emacs Version 18.58},
X   organization = {Free Software Foundation},
X   title = {{GNU Emacs Manual}},
X   year = {1992},
X   annote = {Emacs est un \'editeur de texte extr\^emement puissant, facilement extensible gr\^ace au
XLisp sp\'ecialis\'e qui lui est int\'egr\'e et qui permet de reprogrammer enti\`erement
Xles fonctionnalit\'es de l'\'editeur, ainsi que d'en ajouter de nouvelles.
X\par 
XIl est possible de trouver un ``mode'' Emacs pour faciliter \`a peu pr\`es n'importe quelle
Xt\^ache d'\'edition, que ce soit de la saisie de texte dans un langage donn\'e ou
Xl'interaction avec un logiciel complexe\ldots{}}
X}
X
X@article{lng:lib91a,
X   author = {Don Libes},
X   journal = {Computing Systems},
X   number = {2},
X   pages = {99-125},
X   title = {{expect: Scripts for Controlling Interactive Processes}},
X   volume = {4},
X   year = {1991},
X   annote = {Le langage expect est bas\'e sur Tcl, auquel il ajoute la possibilit\'e de contr\^oler n'importe quel programme Unix, interactif ou non, sous forme de processus attach\'e au programme expect.
X\par
XComme Tcl, expect peut \^etre inclus dans une application, lui apportant alors de grandes facilit\'es d'extension.
X\par 
XCet article pr\'esente le langage en donnant un certain nombre de scripts utilis\'es dans des domaines vari\'es (administration syst\`eme, s\'ecurit\'e, jeux (!), communication,
X\ldots{}).
X
X}
X}
X
X@techreport{lng:lib91b,
X   author = {Don Libes},
X   address = {Gaithesburg, MD},
X   institution = {National Institute of Standards and Technology},
X   number = {NIST IR 744-91},
X   title = {{expect User Manual}},
X   year = {1991},
X   annote = {Le langage expect est bas\'e sur Tcl, auquel il ajoute la possibilit\'e de contr\^oler n'importe quel programme Unix, interactif ou non, sous forme de processus attach\'e au programme expect.
X\par 
XComme Tcl, expect peut \^etre inclus dans une application, lui apportant alors de grandes facilit\'es d'extension.
X}
X}
X
X@inproceedings{lng:ous90,
X   author = {John Ousterhout},
X   booktitle = {{Proceedings of the Winter 1990 USENIX Conference}},
X   crossref = {prc:usenix90w},
X   title = {{Tcl: An Embeddable Command Language}},
X   year = {1990},
X   annote = {Tcl est un langage destin\'e \`a \^etre inclus dans des applications afin de leur fournir un langage int\'egr\'e simple et puissant.
X\par 
XUne fois le langage ajout\'e \`a l'application, celle-ci fournit un certain nombre de points d'entr\'ee vers ses fonctionnalit\'es, qui peuvent alors \^etre utilis\'ees par un simple appel proc\'edural dans les programmes que l'utilisateur \'ecrit en Tcl.
X\par 
XTcl a \'et\'e utilis\'e dans beaucoup d'applications, dont un \'editeur de texte enti\`erement reconfigurable et programmable, Point, qui utilise Tcl et son extension pour X, Tk.}
X}
X
X@inproceedings{lng:bir92,
X   author = {J. J. Birchman and S. L. Tanimoto},
X   title = {{An Implementation of the VIVA Visual Language on the NeXT Computer}},
X   year = {1992},
X   annote = {VIVA est un langage de programmation visuelle destin\'e au traitement d'image. Il utilise des ic\^ones pour repr\'esenter les op\'erateurs de traitement d'image, et des arcs orient\'es pour repr\'esenter le flot de donn\'es (images) entre les op\'erateurs.
X\par 
XLe syst\`eme est organis\'e en deux niveaux accompagn\'es d'un certain nombre de modules. Le niveaux sup\'erieur est la pr\'esentation de l'environnement de programmation \`a l'utilisateur, lui permettant de cr\'eer, modifier, sauver et ex\'ecuter ses programmes. Le niveau inf\'erieur est la structure interne du langage, qui g\`ere la programmation visuelle, le d\'eclenchement des op\'erateurs \`a l'arriv\'ee de nouvelles donn\`ees, et la gestion des ic\^ones (op\'erateurs).
X\par 
XVIVA propose un mod\`ele synchrone de flot de donn\'ees, dans un environnement ``pleinement vivant'', i.e. refl\'etant \`a tout moment l'\'etat du syst\`eme et les actions de l'utilisateur.
X\par 
XVIVA a \'et\'e d\'evelopp\'e pour faciliter l'apprentissage des techniques d'imagerie m\'edicale par des m\'edecins sans connaissances informatiques.}
X}
X
X@proceedings{prc:usenix90w,
X   address = {Washington, DC},
X   month = jan,
X   title = {{Proceedings of the Winter 1990 USENIX Conference}},
X   year = {1990}
X}
END_OF_FILE
  if test 5203 -ne `wc -c <'sample.bib'`; then
    echo shar: \"'sample.bib'\" unpacked with wrong size!
  fi
  # end of 'sample.bib'
fi
if test -f 'sample.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.tex'\"
else
  echo shar: Extracting \"'sample.tex'\" \(601 characters\)
  sed "s/^X//" >'sample.tex' <<'END_OF_FILE'
X% sample.tex: a test for the `annote' package. Assume that you are
X% using the annote-compatible `plain.bst' BibTeX style.
X
X% To format: latex sample
X%            bibtex sample
X%            latex sample
X%            latex sample
X
X% Yves Arrouye
X% May, 1993
X
X\documentstyle[a4,refrench]{article}
X
X\begin{document}
X\section*{Testing the `annote' package with {\tt plain.bst}}
X% Here is an annote environment, comment it to look the non-annotated
X% bibliography. 
X\newenvironment{annote}{\begin{quote}\em}{\end{quote}}
X% Cite all
X\nocite{*}
X\bibliography{sample}
X\bibliographystyle{plain}
X\end{document}
END_OF_FILE
  if test 601 -ne `wc -c <'sample.tex'`; then
    echo shar: \"'sample.tex'\" unpacked with wrong size!
  fi
  # end of 'sample.tex'
fi
if test -f 'unsrt.bst' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unsrt.bst'\"
else
  echo shar: Extracting \"'unsrt.bst'\" \(18521 characters\)
  sed "s/^X//" >'unsrt.bst' <<'END_OF_FILE'
X% Style file modified on Wed May 12 20:20:52 1993
X%                     by Yves Arrouye <arrouye@mistral>
X
X% This bibliography style was made annote-compatible by annotebib.el v1.0
X% It can be used for both annotated and non-annotated bibliographies listing
X% (annote package by Yves Arrouye <arrouye@imag.imag.fr>)
X
X% BibTeX standard bibliography style `unsrt'
X        % version 0.99a for BibTeX versions 0.99a or later, LaTeX version 2.09.
X        % Copyright (C) 1985, all rights reserved.
X        % Copying of this file is authorized only if either
X        % (1) you make absolutely no changes to your copy, including name, or
X        % (2) if you do make changes, you name it something other than
X        % btxbst.doc, plain.bst, unsrt.bst, alpha.bst, and abbrv.bst.
X        % This restriction helps ensure that all standard styles are identical.
X        % The file btxbst.doc has the documentation for this style.
X
XENTRY
X  { annote
X    address
X    author
X    booktitle
X    chapter
X    edition
X    editor
X    howpublished
X    institution
X    journal
X    key
X    month
X    note
X    number
X    organization
X    pages
X    publisher
X    school
X    series
X    title
X    type
X    volume
X    year
X  }
X  {}
X  { label }
X
XINTEGERS { output.state before.all mid.sentence after.sentence after.block }
X
XFUNCTION {init.state.consts}
X{ #0 'before.all :=
X  #1 'mid.sentence :=
X  #2 'after.sentence :=
X  #3 'after.block :=
X}
X
XSTRINGS { s t }
X
XFUNCTION {output.nonnull}
X{ 's :=
X  output.state mid.sentence =
X    { ", " * write$ }
X    { output.state after.block =
X        { add.period$ write$
X          newline$
X          "\newblock " write$
X        }
X        { output.state before.all =
X            'write$
X            { add.period$ " " * write$ }
X          if$
X        }
X      if$
X      mid.sentence 'output.state :=
X    }
X  if$
X  s
X}
X
XFUNCTION {output}
X{ duplicate$ empty$
X    'pop$
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.check}
X{ 't :=
X  duplicate$ empty$
X    { pop$ "empty " t * " in " * cite$ * warning$ }
X    'output.nonnull
X  if$
X}
X
XFUNCTION {output.bibitem}
X{ newline$
X  "\bibitem{" write$
X  cite$ write$
X  "}" write$
X  newline$
X  ""
X  before.all 'output.state :=
X}
X
XFUNCTION {format.annote}
X{ annote empty$
X        { "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X          annote
X          * " \end{annote}\fi " *
X        }
X      if$
X}
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  format.annote write$
X}
X
XFUNCTION {new.block}
X{ output.state before.all =
X    'skip$
X    { after.block 'output.state := }
X  if$
X}
X
XFUNCTION {new.sentence}
X{ output.state after.block =
X    'skip$
X    { output.state before.all =
X        'skip$
X        { after.sentence 'output.state := }
X      if$
X    }
X  if$
X}
X
XFUNCTION {not}
X{   { #0 }
X    { #1 }
X  if$
X}
X
XFUNCTION {and}
X{   'skip$
X    { pop$ #0 }
X  if$
X}
X
XFUNCTION {or}
X{   { pop$ #1 }
X    'skip$
X  if$
X}
X
XFUNCTION {new.block.checka}
X{ empty$
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.block.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.block
X  if$
X}
X
XFUNCTION {new.sentence.checka}
X{ empty$
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {new.sentence.checkb}
X{ empty$
X  swap$ empty$
X  and
X    'skip$
X    'new.sentence
X  if$
X}
X
XFUNCTION {field.or.null}
X{ duplicate$ empty$
X    { pop$ "" }
X    'skip$
X  if$
X}
X
XFUNCTION {emphasize}
X{ duplicate$ empty$
X    { pop$ "" }
X    { "{\em " swap$ * "}" * }
X  if$
X}
X
XINTEGERS { nameptr namesleft numnames }
X
XFUNCTION {format.names}
X{ 's :=
X  #1 'nameptr :=
X  s num.names$ 'numnames :=
X  numnames 'namesleft :=
X    { namesleft #0 > }
X    { s nameptr "{ff~}{vv~}{ll}{, jj}" format.name$ 't :=
X      nameptr #1 >
X        { namesleft #1 >
X            { ", " * t * }
X            { numnames #2 >
X                { "," * }
X                'skip$
X              if$
X              t "others" =
X                { " et~al." * }
X                { " and " * t * }
X              if$
X            }
X          if$
X        }
X        't
X      if$
X      nameptr #1 + 'nameptr :=
X      namesleft #1 - 'namesleft :=
X    }
X  while$
X}
X
XFUNCTION {format.authors}
X{ author empty$
X    { "" }
X    { author format.names }
X  if$
X}
X
XFUNCTION {format.editors}
X{ editor empty$
X    { "" }
X    { editor format.names
X      editor num.names$ #1 >
X        { ", editors" * }
X        { ", editor" * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.title}
X{ title empty$
X    { "" }
X    { title "t" change.case$ }
X  if$
X}
X
XFUNCTION {n.dashify}
X{ 't :=
X  ""
X    { t empty$ not }
X    { t #1 #1 substring$ "-" =
X        { t #1 #2 substring$ "--" = not
X            { "--" *
X              t #2 global.max$ substring$ 't :=
X            }
X            {   { t #1 #1 substring$ "-" = }
X                { "-" *
X                  t #2 global.max$ substring$ 't :=
X                }
X              while$
X            }
X          if$
X        }
X        { t #1 #1 substring$ *
X          t #2 global.max$ substring$ 't :=
X        }
X      if$
X    }
X  while$
X}
X
XFUNCTION {format.date}
X{ year empty$
X    { month empty$
X        { "" }
X        { "there's a month but no year in " cite$ * warning$
X          month
X        }
X      if$
X    }
X    { month empty$
X        'year
X        { month " " * year * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.btitle}
X{ title emphasize
X}
X
XFUNCTION {tie.or.space.connect}
X{ duplicate$ text.length$ #3 <
X    { "~" }
X    { " " }
X  if$
X  swap$ * *
X}
X
XFUNCTION {either.or.check}
X{ empty$
X    'pop$
X    { "can't use both " swap$ * " fields in " * cite$ * warning$ }
X  if$
X}
X
XFUNCTION {format.bvolume}
X{ volume empty$
X    { "" }
X    { "volume" volume tie.or.space.connect
X      series empty$
X        'skip$
X        { " of " * series emphasize * }
X      if$
X      "volume and number" number either.or.check
X    }
X  if$
X}
X
XFUNCTION {format.number.series}
X{ volume empty$
X    { number empty$
X        { series field.or.null }
X        { output.state mid.sentence =
X            { "number" }
X            { "Number" }
X          if$
X          number tie.or.space.connect
X          series empty$
X            { "there's a number but no series in " cite$ * warning$ }
X            { " in " * series * }
X          if$
X        }
X      if$
X    }
X    { "" }
X  if$
X}
X
XFUNCTION {format.edition}
X{ edition empty$
X    { "" }
X    { output.state mid.sentence =
X        { edition "l" change.case$ " edition" * }
X        { edition "t" change.case$ " edition" * }
X      if$
X    }
X  if$
X}
X
XINTEGERS { multiresult }
X
XFUNCTION {multi.page.check}
X{ 't :=
X  #0 'multiresult :=
X    { multiresult not
X      t empty$ not
X      and
X    }
X    { t #1 #1 substring$
X      duplicate$ "-" =
X      swap$ duplicate$ "," =
X      swap$ "+" =
X      or or
X        { #1 'multiresult := }
X        { t #2 global.max$ substring$ 't := }
X      if$
X    }
X  while$
X  multiresult
X}
X
XFUNCTION {format.pages}
X{ pages empty$
X    { "" }
X    { pages multi.page.check
X        { "pages" pages n.dashify tie.or.space.connect }
X        { "page" pages tie.or.space.connect }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.vol.num.pages}
X{ volume field.or.null
X  number empty$
X    'skip$
X    { "(" number * ")" * *
X      volume empty$
X        { "there's a number but no volume in " cite$ * warning$ }
X        'skip$
X      if$
X    }
X  if$
X  pages empty$
X    'skip$
X    { duplicate$ empty$
X        { pop$ format.pages }
X        { ":" * pages n.dashify * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.chapter.pages}
X{ chapter empty$
X    'format.pages
X    { type empty$
X        { "chapter" }
X        { type "l" change.case$ }
X      if$
X      chapter tie.or.space.connect
X      pages empty$
X        'skip$
X        { ", " * format.pages * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.in.ed.booktitle}
X{ booktitle empty$
X    { "" }
X    { editor empty$
X        { "In " booktitle emphasize * }
X        { "In " format.editors * ", " * booktitle emphasize * }
X      if$
X    }
X  if$
X}
X
XFUNCTION {empty.misc.check}
X{ author empty$ title empty$ howpublished empty$
X  month empty$ year empty$ note empty$
X  and and and and and
X    { "all relevant fields are empty in " cite$ * warning$ }
X    'skip$
X  if$
X}
X
XFUNCTION {format.thesis.type}
X{ type empty$
X    'skip$
X    { pop$
X      type "t" change.case$
X    }
X  if$
X}
X
XFUNCTION {format.tr.number}
X{ type empty$
X    { "Technical Report" }
X    'type
X  if$
X  number empty$
X    { "t" change.case$ }
X    { number tie.or.space.connect }
X  if$
X}
X
XFUNCTION {format.article.crossref}
X{ key empty$
X    { journal empty$
X        { "need key or journal for " cite$ * " to crossref " * crossref *
X          warning$
X          ""
X        }
X        { "In {\em " journal * "\/}" * }
X      if$
X    }
X    { "In " key * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.crossref.editor}
X{ editor #1 "{vv~}{ll}" format.name$
X  editor num.names$ duplicate$
X  #2 >
X    { pop$ " et~al." * }
X    { #2 <
X        'skip$
X        { editor #2 "{ff }{vv }{ll}{ jj}" format.name$ "others" =
X            { " et~al." * }
X            { " and " * editor #2 "{vv~}{ll}" format.name$ * }
X          if$
X        }
X      if$
X    }
X  if$
X}
X
XFUNCTION {format.book.crossref}
X{ volume empty$
X    { "empty volume in " cite$ * "'s crossref of " * crossref * warning$
X      "In "
X    }
X    { "Volume" volume tie.or.space.connect
X      " of " *
X    }
X  if$
X  editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { series empty$
X            { "need editor, key, or series for " cite$ * " to crossref " *
X              crossref * warning$
X              "" *
X            }
X            { "{\em " * series * "\/}" * }
X          if$
X        }
X        { key * }
X      if$
X    }
X    { format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {format.incoll.inproc.crossref}
X{ editor empty$
X  editor field.or.null author field.or.null =
X  or
X    { key empty$
X        { booktitle empty$
X            { "need editor, key, or booktitle for " cite$ * " to crossref " *
X              crossref * warning$
X              ""
X            }
X            { "In {\em " booktitle * "\/}" * }
X          if$
X        }
X        { "In " key * }
X      if$
X    }
X    { "In " format.crossref.editor * }
X  if$
X  " \cite{" * crossref * "}" *
X}
X
XFUNCTION {article}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { journal emphasize "journal" output.check
X      format.vol.num.pages output
X      format.date "year" output.check
X    }
X    { format.article.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {book}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {booklet}
X{ output.bibitem
X  format.authors output
X  new.block
X  format.title "title" output.check
X  howpublished address new.block.checkb
X  howpublished output
X  address output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inbook}
X{ output.bibitem
X  author empty$
X    { format.editors "author and editor" output.check }
X    { format.authors output.nonnull
X      crossref missing$
X        { "author and editor" editor either.or.check }
X        'skip$
X      if$
X    }
X  if$
X  new.block
X  format.btitle "title" output.check
X  crossref missing$
X    { format.bvolume output
X      format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.number.series output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X    }
X    { format.chapter.pages "chapter and pages" output.check
X      new.block
X      format.book.crossref output.nonnull
X    }
X  if$
X  format.edition output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {incollection}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.chapter.pages output
X      new.sentence
X      publisher "publisher" output.check
X      address output
X      format.edition output
X      format.date "year" output.check
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.chapter.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {inproceedings}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  crossref missing$
X    { format.in.ed.booktitle "booktitle" output.check
X      format.bvolume output
X      format.number.series output
X      format.pages output
X      address empty$
X        { organization publisher new.sentence.checkb
X          organization output
X          publisher output
X          format.date "year" output.check
X        }
X        { address output.nonnull
X          format.date "year" output.check
X          new.sentence
X          organization output
X          publisher output
X        }
X      if$
X    }
X    { format.incoll.inproc.crossref output.nonnull
X      format.pages output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {conference} { inproceedings }
X
XFUNCTION {manual}
X{ output.bibitem
X  author empty$
X    { organization empty$
X        'skip$
X        { organization output.nonnull
X          address output
X        }
X      if$
X    }
X    { format.authors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  author empty$
X    { organization empty$
X        { address new.block.checka
X          address output
X        }
X        'skip$
X      if$
X    }
X    { organization address new.block.checkb
X      organization output
X      address output
X    }
X  if$
X  format.edition output
X  format.date output
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {mastersthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  "Master's thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {misc}
X{ output.bibitem
X  format.authors output
X  title howpublished new.block.checkb
X  format.title output
X  howpublished new.block.checka
X  howpublished output
X  format.date output
X  new.block
X  note output
X  fin.entry
X  empty.misc.check
X}
X
XFUNCTION {phdthesis}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.btitle "title" output.check
X  new.block
X  "PhD thesis" format.thesis.type output.nonnull
X  school "school" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {proceedings}
X{ output.bibitem
X  editor empty$
X    { organization output }
X    { format.editors output.nonnull }
X  if$
X  new.block
X  format.btitle "title" output.check
X  format.bvolume output
X  format.number.series output
X  address empty$
X    { editor empty$
X        { publisher new.sentence.checka }
X        { organization publisher new.sentence.checkb
X          organization output
X        }
X      if$
X      publisher output
X      format.date "year" output.check
X    }
X    { address output.nonnull
X      format.date "year" output.check
X      new.sentence
X      editor empty$
X        'skip$
X        { organization output }
X      if$
X      publisher output
X    }
X  if$
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {techreport}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  format.tr.number output.nonnull
X  institution "institution" output.check
X  address output
X  format.date "year" output.check
X  new.block
X  note output
X  fin.entry
X}
X
XFUNCTION {unpublished}
X{ output.bibitem
X  format.authors "author" output.check
X  new.block
X  format.title "title" output.check
X  new.block
X  note "note" output.check
X  format.date output
X  fin.entry
X}
X
XFUNCTION {default.type} { misc }
X
XMACRO {jan} {"January"}
X
XMACRO {feb} {"February"}
X
XMACRO {mar} {"March"}
X
XMACRO {apr} {"April"}
X
XMACRO {may} {"May"}
X
XMACRO {jun} {"June"}
X
XMACRO {jul} {"July"}
X
XMACRO {aug} {"August"}
X
XMACRO {sep} {"September"}
X
XMACRO {oct} {"October"}
X
XMACRO {nov} {"November"}
X
XMACRO {dec} {"December"}
X
XMACRO {acmcs} {"ACM Computing Surveys"}
X
XMACRO {acta} {"Acta Informatica"}
X
XMACRO {cacm} {"Communications of the ACM"}
X
XMACRO {ibmjrd} {"IBM Journal of Research and Development"}
X
XMACRO {ibmsj} {"IBM Systems Journal"}
X
XMACRO {ieeese} {"IEEE Transactions on Software Engineering"}
X
XMACRO {ieeetc} {"IEEE Transactions on Computers"}
X
XMACRO {ieeetcad}
X {"IEEE Transactions on Computer-Aided Design of Integrated Circuits"}
X
XMACRO {ipl} {"Information Processing Letters"}
X
XMACRO {jacm} {"Journal of the ACM"}
X
XMACRO {jcss} {"Journal of Computer and System Sciences"}
X
XMACRO {scp} {"Science of Computer Programming"}
X
XMACRO {sicomp} {"SIAM Journal on Computing"}
X
XMACRO {tocs} {"ACM Transactions on Computer Systems"}
X
XMACRO {tods} {"ACM Transactions on Database Systems"}
X
XMACRO {tog} {"ACM Transactions on Graphics"}
X
XMACRO {toms} {"ACM Transactions on Mathematical Software"}
X
XMACRO {toois} {"ACM Transactions on Office Information Systems"}
X
XMACRO {toplas} {"ACM Transactions on Programming Languages and Systems"}
X
XMACRO {tcs} {"Theoretical Computer Science"}
X
XREAD
X
XSTRINGS { longest.label }
X
XINTEGERS { number.label longest.label.width }
X
XFUNCTION {initialize.longest.label}
X{ "" 'longest.label :=
X  #1 'number.label :=
X  #0 'longest.label.width :=
X}
X
XFUNCTION {longest.label.pass}
X{ number.label int.to.str$ 'label :=
X  number.label #1 + 'number.label :=
X  label width$ longest.label.width >
X    { label 'longest.label :=
X      label width$ 'longest.label.width :=
X    }
X    'skip$
X  if$
X}
X
XEXECUTE {initialize.longest.label}
X
XITERATE {longest.label.pass}
X
XFUNCTION {begin.bib}
X{ preamble$ empty$
X    'skip$
X    { preamble$ write$ newline$ }
X  if$
X  "\begin{thebibliography}{"  longest.label  * "}" * write$ newline$
X}
X
XEXECUTE {begin.bib}
X
XEXECUTE {init.state.consts}
X
XITERATE {call.type$}
X
XFUNCTION {end.bib}
X{ newline$
X  "\end{thebibliography}" write$ newline$
X}
X
XEXECUTE {end.bib}
END_OF_FILE
  if test 18521 -ne `wc -c <'unsrt.bst'`; then
    echo shar: \"'unsrt.bst'\" unpacked with wrong size!
  fi
  # end of 'unsrt.bst'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
