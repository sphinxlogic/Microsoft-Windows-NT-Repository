Newsgroups: comp.sources.misc
From: hsilbiger@attmail.att.com
Subject: v37i025:  aimm-demo - ANSI/AIIM Image File Program and Sources, Part01/03
Message-ID: <csm-v37i025=aimm-demo.083922@sparky.IMD.Sterling.COM>
X-Md4-Signature: f756b31d0dc9b3f40f49f3eda50ace58
Date: Mon, 26 Apr 1993 13:40:40 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: hsilbiger@attmail.att.com
Posting-number: Volume 37, Issue 25
Archive-name: aimm-demo/part01
Environment: Borland_C, MicroSoft_C

This is part 1 of 3 of a program to construct an image file according 
to ANSI/AIIM MS53 Standard bi-level image file format.  A description 
of the format is included.  This material is intended primarily to 
demonstrate the format.

This program was developed to generate the examples in appendix
E of the ANSI/AIIM MS53-199x standard it would work as a primitive
import routine. This program should compile with either Borland C or
Microsoft C. The tab spacing was set to 4.

This was not written to be the most efficient code but rather as a
demo of the A11 standard encoding. Also, there is minimal error checking
a full implementation would have extensive error checking.

The ANSI/AIIM MS-53 Standard Recommended Practice - File Format for Storage
and Exchange of Images - Bi-Level File Format: Part 1 is available from

    Association for Information and Image Management
    1100 Wayne Avenue
    Silver Spring, MD 20910-5699
    Tel: +1 301 587-8202
    Fax: +1 301 588-3848
----------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  a11_new.c e5.ctl gen_a11.c
# Wrapped by kent@sparky on Mon Apr 26 08:32:53 CDT 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'a11_new.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'a11_new.c'\"
else
  echo shar: Extracting \"'a11_new.c'\" \(24691 characters\)
  sed "s/^X//" >'a11_new.c' <<'END_OF_FILE'
X/* This program was written by Mike Fleischmann of Optical Publishing, Inc.
X	Copyright 1993 Optical Publishing, Inc. All rights reserved.
X	Redistribution and use in source and binary form are freely permitted
X	provided that the above copyright notice appears in all documentation.
X	
X	THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESSED OR IMPLIED
X	WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
X	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. By installing this 
X	software, you agree to hold Optical Publishing, Inc. harmless for any 
X	damages resulting from the use of this software.
X*/
X
X/* The program was copyrighted to allow you to know the source of the code. 
X	This way if you need to contact us, you at least know the company name.
X	We are in based in Ft. Collins, Colorado at (303)-226-3466.
X	Our intention is to allow you to use, modify, copy and redistribute this
X	code as well as integrate it into your applications at no charge or 
X	royalties of any kind. Our only request is that if you use sections of 
X	this code in your products, you include a 'Portions Copyright 1993 Optical
X	Publishing, Inc. All rights reserved.' in your documentation. That's it, 
X	we want to make this standard as easy to use as possible and giving away
X	working code seemed the best way to do it.
X*/
X
X/***********************************************************************
X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X!!!!!!!!!!!!!!!!!!!!!!!!      NOTE NOTE NOTE    !!!!!!!!!!!!!!!!!!!!!!!!!
X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X	This version has proposed changes that affect table A.1 in annex A of
X	the standard. Although this change is likely to be approved please 
X	contact AIIM for confirmation of the approval.
X!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X/***********************************************************************/
X
X/* although this program was developed to generate the examples in appendix
X	E of the ANSI/AIIM MS53-199x standard it would work as a primitive 
X	import routine. This program should compile with either Borland C or 
X	Microsoft C. The tab spacing was set to 4.
X	
X	This was not written to be the most efficient code but rather as a  
X	demo of the A11 standard encoding. Also, there is minimal error checking
X	a full implementation would have extensive error checking.
X
X
X	The program's calling parameters are GEN_A11 filename.ext where
X		filename.ext is the name of the control file.
X	The control file is in the format keyword=value. All values are in HEX!!
X	NOTE: all the keywords are not necessary if you are excluding the area
X	where they are used. i.e. clipping.
X
X	keywords are (case insensitive):
X		infile		the input image file
X		outfile		the output image file name. (an extension .A11 is suggested)
X		length		the length of the data file
X		c4			the last digit in the c1 c2 c3 c4 encoding string
X		cp			the compression flag
X		lp			the line progression 
X		pp			the pel path
X		ps			the pel spaces value
X		rl			the raster ratio for line spacing
X		rp			the raster ratio for pel spacing
X		sl			the spacing length
X		string		the user string. (note this can span lines needs to be 
X					ended with the tilda (~) character.
X		dh			horizontal block dimensions
X		dv			vertical block dimensions
X		fx			first X clipping coord in BMUs
X		fy			first Y clipping coord in BMUs
X		hp			horizontal page dimensions in BMUs
X		nl			number of lines (if known)
X		ph			horizontal starting position in BMUs
X		pl			number of pels per line
X		pv			vertical starting position in BMUs 
X		sx			second X clipping coord in BMUs
X		sy			secong Y clipping coord in BMUs
X		vp			vertical page dimensions in BMUs
X*/
X
X/****************************************************************************/
X
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <ctype.h>
X
X#define LEN_A1_NARY (sizeof(a1_nary))
X#define LEN_A2 (sizeof(a2))
X#define LEN_A3_NARY (sizeof(a3_nary))
X#define LEN_A4 (sizeof(a4))
X
Xunsigned char a1_nary[]={	/* fixed portion of a1 */
X	0x84,0x05,
X		0x2a,0x86,0x48,0xce,0x1c,
X	0xa5,0x06,
X		0x06,0x04,
X			0x58,0x02,0x07,0x02,
X		0x86,0x01,
X			0x00,
X	0xa8,0x4e,
X		0x43,0x40,
X			0x43,0x43,0x49,0x54,0x54,0x20,0x52,0x65,0x63,0x2e,
X			0x20,0x54,0x2e,0x34,0x31,0x30,0x20,0x73,0x65,0x72,
X			0x69,0x65,0x73,0x20,0x28,0x31,0x39,0x39,0x32,0x29,
X			0x20,0x7c,0x20,0x49,0x53,0x4f,0x2f,0x49,0x45,0x43,
X			0x20,0x38,0x36,0x31,0x33,0x3a,0x31,0x39,0x39,0x33,
X			0x3b,0x20,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x20,
X			0x32,0x2e,0x30,0x30,
X		0x44,0x0a,
X			0x31,0x39,0x39,0x32,0x2d,0x30,0x35,0x2d,0x30,0x31,
X	0xaa,0x10,
X		0xa0,0x0e,
X			0x80,0x04,
X				0x58,0x02,0x07,0x02,
X			0xaa,0x06,
X				0x86,0x04,
X					0x58,0x03,0x07,0x06
X	};
X
Xunsigned char a2[]={		/* The document layout root  fixed content */
X					0xa2,0x0d,
X						0x02,0x01,
X							0x00,
X						0x31,0x08,
X							0x41,0x01,
X								0x31,
X							0xa0,0x03,
X								0x12,0x01,
X									0x30
X					};
X
Xunsigned char a3_nary[]={	/* fixed portion of a3 */
X		0x41,0x03,
X			0x31,0x20,0x30,
X		0xa0,0x03,
X			0x12,0x01,
X				0x30,
X			0xaf,0x06,
X				0x80,0x01,
X					0x00,
X				0x80,0x01,
X					0x00
X	};
X
Xunsigned char a4[]={		/* The document layout root  fixed content */
X					0xa2,0x11,
X						0x02,0x01,
X							0x03,
X						0x31,0x0c,
X							0x41,0x05,
X								0x31,0x20,0x30,0x20,0x30,
X							0xa0,0x03,
X								0x12,0x01,
X									0x30
X					};
X
Xunsigned char c1[]={0x58,0x03,0x07,0xff};	/* the c1c2c3c4 param */
Xunsigned char cp=0xff;		/* compression set to invalid value */
Xunsigned char lp=0xff;		/* line progression set to invalid value */
Xunsigned char pp=0xff;		/* pel path set to invalid character */
Xunsigned char ps=0;	/* pel spaces (invalid value)*/
Xunsigned char rl=0;	/* raster ratio line spacing (invalid value) */
Xunsigned char rp=0;	/* raster ratio pel spacing (invalid value) */
Xunsigned char sl=0;	/* spacing length (invalid value) */
Xchar str1[510];			/* the variable length string. (512 bytes max) */
X
Xlong dh=0;				/* horizontal block dimensions in BMUs */
Xlong dv=0;				/* vertical block dimensions in BMUs */
Xlong fx=0;				/* first x clipping coord in BMUs */
Xlong fy=0;				/* first y clipping coord in BMUs */
Xlong hp=0;				/* horizontal page dimensions in BMU's */
Xlong nl=0;				/* number of lines */
Xlong ph=0;				/* horizontal starting position in BMUs */
Xlong pl=0;				/* number of pels per line */
Xlong pv=0;				/* vertical starting position */
Xlong sx=0;				/* second X clipping coord in BMUs */
Xlong sy=0;				/* second Y clipping coord in BMUs */
Xlong vp=0;				/* vertical page dimensions in BMUs */
X
Xlong length=0;			/* length of the input data file */
X
XFILE *fin;				/* handle for the input image file */
XFILE *fout;				/* handle for the output A11 file */
XFILE *ctrl;				/* the file handle for the control file */
X
Xunsigned char buff[0x8000];		/* work buffer */
Xunsigned char line[0x200];		/* line entry buffer */
X
Xchar *keyword[]={
X	"INFILE",
X	"OUTFILE",
X	"LENGTH",
X	"C4",
X	"CP",
X	"LP",
X	"PP",
X	"PS",
X	"RL",
X	"RP",
X	"SL",
X	"STRING",
X	"DH",
X	"DV",
X	"FX",
X	"FY",
X	"HP",
X	"NL",
X	"PH",
X	"PL",
X	"PV",
X	"SX",
X	"SY",
X	"VP",
X	"~~~"};		/* mark as the end */
X
X#define INFILE 0
X#define OUTFILE 1
X#define LENGTH 2 
X#define C4 3 
X#define CP 4 
X#define LP 5
X#define PP 6
X#define PS 7
X#define RL 8
X#define RP 9 
X#define SL 10
X#define STRING 11
X#define DH 12
X#define DV 13
X#define FX 14
X#define FY 15
X#define HP 16
X#define NL 17
X#define PH 18
X#define PL 19
X#define PV 20
X#define SX 21
X#define SY 22
X#define VP 23
X
X
Xvoid Get_Line(void);
Xint Char2val(int);
Xlong Get_Hex(char *);
XRead_Control(void);
XDo_In_Fun(int,char *);
Xint Gen_Lxx(int,unsigned long);		/* gen the format lxx table 5*/
Xint Gen_Len(int,unsigned long);		/* gen the format lxx table 4*/
XDo_A1(void);		/* this and the following will build the data from
X					the end
X					*/ 
XDo_A3(void);
XDo_A5c(void);
XDo_A5(int,int);		/* first int is current, second int is scpe loc */
XDo_A6d(void);
XDo_A6i(void);
X
X
X
Xint main(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	int rtn;		/* used for function return checking */
X
X	str1[0]=' ';	/* guarentee at least a comment */
X	str1[1]=0;	/* guarentee at least a comment */
X	if(argc<2)
X	{
X		printf("calling parameters are A11_NEW ctrlfile.ext\n");
X		printf(" where ctrlfile.ext is the controll file. See source code for\n");
X		printf(" more information\n");
X		exit(0);
X	}
X	
X	ctrl=fopen(argv[1],"r");
X	if(ctrl==NULL)
X	{
X		printf("unable to open the controll file >%s<\n",argv[1]);
X		exit(0);
X	}
X	
X	rtn=Read_Control();			/* read the control file in */
X	if(rtn)		/* if an error */
X	{
X		printf("error reading controll file. Program ending\n");
X		exit(0);
X	}
X	rtn=Do_A1();		/* go and do the a.1 table */
X	if(rtn)		/* if an error */
X	{
X		printf("error in generation of the A.1 header table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=fwrite(a2,1,LEN_A2,fout);		/* output the a2 table */
X	if(rtn!=LEN_A2)		/* if an error */
X	{
X		printf("error in writing A.2 table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=Do_A3();		/* go and do the a.3 table */
X	if(rtn)		/* if an error */
X	{
X		printf("error in generation of the A.3 header table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=fwrite(a4,1,LEN_A4,fout);		/* output the a4 table */
X	if(rtn!=LEN_A4)		/* if an error */
X	{
X		printf("error in writing A.4 table. Program ending\n");
X		exit(0);
X	}
X
X	if(fx!=0 || fy!=0 || sx!=0 || sy!=0)
X	{
X		/* if here we have clipping */
X		rtn=Do_A5c();		/* go and do the a.5 table for clipping */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.51 header table. Program ending\n");
X			exit(0);
X		}
X	}
X	else
X	{
X		rtn=Do_A5(0x400,0x400);		/* go and do the a.5 table for no clipping*/
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.3 header table. Program ending\n");
X			exit(0);
X		}
X	}
X
X	if(length>0)		/* definite length */
X	{
X		rtn=Do_A6d();		/* go and do the a.6 table */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.6 table. Program ending\n");
X			exit(0);
X		}
X	}
X	else	/* indefinite length */
X	{
X		rtn=Do_A6i();		/* go and do the a.6 table */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.6 table. Program ending\n");
X			exit(0);
X		}
X	}
X
X	fclose(fout);
X	fclose(fin);
X	fclose(ctrl);
X	printf("File build finished\n");
X	return(0);
X}
X
Xvoid Get_Line()
X{
X	int i;		/* temp work variable */
X
X	fgets(line,0x200,ctrl);
X	i=strlen(line);
X	for(i--;i>0 && line[i]<=' ';line[i--]=0) ;  /* remove trailing crlf */
X	
X	/* turn to uppercase */
X	for(i=0;line[i] && line[i]!='=';line[i]=toupper(line[i]),i++);
X	if(memcmp(line,"STRING",6)!=0)	/* skip string case */
X		for(;line[i];line[i]=toupper(line[i]),i++);
X
X}
X
Xint Char2val(ch)
Xint ch;
X{
X	if(ch<='9')
X		ch-='0';
X	else
X		ch = ch-'A'+10;
X	return(ch);
X}
X
Xlong Get_Hex(str)
Xchar *str;
X{
X	long l1;
X	int i;
X	
X	for(i=0;str[i]<=' ' && str[i];i++);	/* ignore leading white space */
X
X	for(i=0,l1=0;isxdigit(str[i]);i++)
X	{
X		l1<<=4;
X		l1+=(long)Char2val(str[i]);
X	}
X	return(l1);
X}
X
XRead_Control()
X{
X	/* this will read in the control file and initialize the variables */
X	char *cptr,*cptr1;		/* temp char pointer used for parsing */
X	int i,j,k;
X	
X	Get_Line();		/* input the line */
X	while(!feof(ctrl))
X	{
X		cptr=line;
X		while(cptr[0]==' ')		/* skip leading spaces */
X			cptr++;
X		cptr1=strchr(cptr,'=');
X		if(cptr1!=NULL)		/* if null treat as comment field */
X		{
X			/* if here have something to work with */
X			cptr1[0]=0;		/* mark end */
X			cptr1++;
X			i=strlen(cptr);		/* get the length of compare string  */
X			for(j=0;keyword[j][0]!='~';j++)
X			{
X				if(memcmp(cptr,keyword[j],i)==0)
X				{
X					k=Do_In_Fun(j,cptr1);
X					if(k)
X						return(k);		/* return if error */
X					break;
X				}
X			}
X		}
X		Get_Line();		/* input the line */
X	}
X	return(0);		/* return valid processing */
X}
X
XDo_In_Fun(fun,str)
Xint fun;		/* the function number to do */
Xchar *str;		/* the remaining string */
X{
X	int i,j;
X	char *cptr;
X	
X	switch(fun)
X	{
X		case INFILE:
X			fin=fopen(str,"rb");		/* open the input image file */
X			if(fin==NULL)
X				return(INFILE+1);
X			break;
X		case OUTFILE:
X			fout=fopen(str,"wb");		/* open the output A11 file */
X			if(fout==NULL)
X				return(OUTFILE+1);
X			break;
X		case LENGTH:
X			length=Get_Hex(str);		/* get the length */
X			if(length<1)
X				return(LENGTH+1);
X			break;
X		case C4:
X			c1[3]=(char)Get_Hex(str);	/* get the c4 character */
X			if(c1[3]>8)
X				return(C4+1);
X			break;
X		case CP:
X			cp=(char)Get_Hex(str);	/* get the cp character */
X			if(cp<0 || cp>1)
X				return(CP+1);
X			break;
X		case LP:
X			lp=(char)Get_Hex(str);	/* get the lp character */
X			if(lp!=1 && lp!=3)
X				return(LP+1);
X			break;
X		case PP:
X			pp=(char)Get_Hex(str);	/* get the pp character */
X			if(pp<0 || pp>3)
X				return(PP+1);
X			break;
X		case PS:
X			ps=(char)Get_Hex(str);	/* get the ps character */
X			if(ps==0)
X				return(PS+1);
X			break;
X		case RL:
X			rl=(char)Get_Hex(str);	/* get the cp character */
X			if(rl==0)
X				return(RL+1);
X			break;
X		case RP:
X			rp=(char)Get_Hex(str);	/* get the cp character */
X			if(rp==0)
X				return(RP+1);
X			break;
X		case SL:
X			sl=(char)Get_Hex(str);	/* get the cp character */
X			if(sl==0)
X				return(SL+1);
X			break;
X		case STRING:
X			j=0;
X			cptr=str;
X			while(1)
X			{
X				for(i=0;cptr[i] && cptr[i]!='~' && j<500;i++)
X					str1[j++]=cptr[i];
X				if(j>499 || cptr[i]=='~')	/* done entering string */
X					break;
X				Get_Line();
X				if(feof(ctrl))
X					return(STRING+1);
X				cptr=line;
X			}
X			str1[j++]=0;		/* null terminate */
X			break;
X		case DH:
X			dh=Get_Hex(str);	/* get the dh value */
X			if(dh<1)
X				return(DH+1);
X			break;
X		case DV:
X			dv=Get_Hex(str);	/* get the dv value */
X			if(dv<1)
X				return(DV+1);
X			break;
X		case FX:
X			fx=Get_Hex(str);	/* get the fx value */
X			break;
X		case FY:
X			fy=Get_Hex(str);	/* get the fy value */
X			break;
X		case HP:
X			hp=Get_Hex(str);	/* get the hp value */
X			if(hp<1)
X				return(HP+1);
X			break;
X		case NL:
X			nl=Get_Hex(str);	/* get the nl value */
X			if(nl<1)
X				return(NL+1);
X			break;
X		case PH:
X			ph=Get_Hex(str);	/* get the ph value */
X			if(dh<0)
X				return(PH+1);
X			break;
X		case PL:
X			pl=Get_Hex(str);	/* get the pl value */
X			if(pl<1)
X				return(PL+1);
X			break;
X		case PV:
X			pv=Get_Hex(str);	/* get the pv value */
X			break;
X		case SX:
X			sx=Get_Hex(str);	/* get the sx value */
X			break;
X		case SY:
X			sy=Get_Hex(str);	/* get the sy value */
X			break;
X		case VP:
X			vp=Get_Hex(str);	/* get the vp value */
X			if(vp<1)
X				return(VP+1);
X			break;
X		default:
X			return(-1);
X	}
X    return(0);
X}
X
Xint Gen_Lxx(cur,val)		/* gen the format table 5 */
Xint cur;		/* current position in buff */
Xunsigned long val;		/* value to insert */
X{
X	
X	if(val <0x80L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		return(1);
X	}
X	else if(val <0x100L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=0x81;
X		return(2);
X	}
X	else if(val <0x10000L)	/* 2 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=0x82;
X		return(3);
X	}
X	else if(val <0x1000000L)	/* 3 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=0x83;
X		return(4);
X	}
X	else	/* 4 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=(unsigned char) (val>>24) & 0xff;
X		buff[cur-4]=0x84;
X		return(5);
X	}
X}
X
Xint Gen_Len(cur,val)		/* gen the format table 4 */
Xint cur;		/* current position in buff */
Xunsigned long val;		/* value to insert */
X{
X	
X	if(val <0x100L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=1;
X		return(2);
X	}
X	else if(val <0x10000L)	/* 2 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=2;
X		return(3);
X	}
X	else if(val <0x1000000L)	/* 3 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=3;
X		return(4);
X	}
X	else	/* 4 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=(unsigned char) (val>>24) & 0xff;
X		buff[cur-4]=4;
X		return(5);
X	}
X}
X
XDo_A1()		/* this and the following will build the data from the end 
X			towards the front */
X{
X	int a1_end=0x400;
X	int cur=0x400;
X	int dend;
X	int nend;
X	int pt8;
X	int pt7;
X	int pt3;
X	int i;
X	
X	i=strlen(str1);
X	i--;
X	while(i>=0)		/* copy the users string */
X	{
X		buff[cur--]=str1[i--];
X	}
X
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LDR section */
X	buff[cur--]=0x43;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD3 section */
X	buff[cur--]=0xa5;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD2 section */
X	buff[cur--]=0xa7;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD1 section */
X	buff[cur--]=0xa3;
X	dend=cur;		/* mark the current position */
X	
X	i=LEN_A1_NARY;
X	i--;
X	while(i>=0)		/* copy the fixed array stuff */
X	{
X		buff[cur--]=a1_nary[i--];
X	}
X	nend=cur;		/* mark position of a1_end byte */
X	
X	buff[cur--]=ps;
X	buff[cur--]=1;
X	buff[cur--]=2;
X
X	buff[cur--]=sl;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	buff[cur--]=6;
X	buff[cur--]=0xa0;
X	buff[cur--]=8;
X	buff[cur--]=0xa5;
X	
X	buff[cur--]=lp;
X	buff[cur--]=1;
X	buff[cur--]=0x8a;
X	
X	buff[cur--]=pp;
X	buff[cur--]=1;
X	buff[cur--]=0x89;
X	buff[cur--]=0x10;
X	buff[cur--]=0xa4;
X	
X	buff[cur--]=cp;
X	buff[cur--]=1;
X	buff[cur--]=0x80;
X	buff[cur--]=3;
X	buff[cur--]=0xa3;
X
X	pt8=cur;
X	buff[cur--]=0;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	pt7=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,pt7-cur);		/* do the L13 */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt8-cur);		/* do the LNP */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt8-cur);		/* do the LMT */
X	buff[cur--]=0xa8;
X	pt3=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,pt3-cur);		/* do the L12 */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt3-cur);		/* do the L11 */
X	buff[cur--]=0xa2;
X	
X	cur-=Gen_Lxx(cur,nend-cur);		/* do the LND */
X	buff[cur--]=0xa2;
X	buff[cur--]=0x00;
X	buff[cur--]=0x01;
X	buff[cur--]=0x81;
X	
X	cur-=Gen_Lxx(cur,dend-cur);		/* do the LDC*/
X	buff[cur--]=0xa2;
X	buff[cur--]=0x31;
X	buff[cur--]=0x01;
X	buff[cur--]=0x81;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LDP*/
X	buff[cur--]=0xa0;
X	
X	i=fwrite(&buff[cur+1],1,a1_end-cur,fout);
X	if(i!=a1_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A3()
X{
X	int a3_end=0x400;
X	int cur=0x400;
X	int a3_nend;
X	int a3_mt;
X	int a3_nps;
X	int a3_pde;
X	int a3_pds;
X	int a3_body;
X	int a3_start;
X	int i;
X	
X	buff[cur--]=0;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	a3_nend=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X	a3_nps=cur;
X
X	cur-=Gen_Lxx(cur,a3_nend-a3_nps);		/* do the LN3 */
X	buff[cur--]=0x30;
X	a3_mt=cur;
X	
X	cur-=Gen_Lxx(cur,a3_end-a3_mt);		/* do the LM3 */
X	buff[cur--]=0xb0;
X	a3_pde=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X	a3_pds=cur;
X
X	cur-=Gen_Lxx(cur,a3_pde-a3_pds);		/* do the LPD */
X	buff[cur--]=0xa4;
X
X	i=LEN_A3_NARY;
X	i--;
X	while(i>=0)		/* copy the fixed array stuff */
X	{
X		buff[cur--]=a3_nary[i--];
X	}
X	a3_body=cur;		/* mark position */
X	cur-=Gen_Lxx(cur,a3_end-a3_body);		/* do the LAB */
X	buff[cur--]=0x31;
X	buff[cur--]=0x02;
X	buff[cur--]=0x01;
X	buff[cur--]=0x02;
X
X
X	a3_start=cur;		/* mark position of a1_end byte */
X
X	cur-=Gen_Lxx(cur,a3_end-a3_start);		/* do the LA3 */
X	buff[cur--]=0xa2;
X
X	i=fwrite(&buff[cur+1],1,a3_end-cur,fout);
X	if(i!=a3_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A5c()
X{
X	int a5_end=0x400;
X	int cur=0x400;
X	int a5_dime;
X	int a5_scpe;
X	int a5_fcpe;
X	
X	
X	if(nl<1)		/* if we don't know the number of lines (required for clp)*/
X	{
X		return(1);		/* return the error */
X	}
X
X	cur-=Gen_Len(cur,pv);		/* do the pv */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,ph);		/* do the ph */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LPS */
X	buff[cur--]=0xa3;
X	a5_dime=cur;
X
X	cur-=Gen_Len(cur,dv);		/* do the dv */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,dh);		/* do the dh */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,a5_dime-cur);		/* do the LDM */
X	buff[cur--]=0xa4;
X	a5_scpe=cur;
X
X	cur-=Gen_Len(cur,sy);		/* do the sy */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Len(cur,sx);		/* do the sx */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LSP */
X	buff[cur--]=0xa1;
X	a5_fcpe=cur;
X
X	cur-=Gen_Len(cur,fy);		/* do the fy */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Len(cur,fx);		/* do the fx */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Lxx(cur,a5_fcpe-cur);		/* do the LFP */
X	buff[cur--]=0xa0;
X
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LFP */
X	buff[cur--]=0xa4;
X
X	return(Do_A5(cur,a5_scpe));
X}
X
XDo_A5(cur,a5_scpe)
Xint	cur;			/* current position in the buffer */
Xint a5_scpe;		/* scpe position in the buffer */
X{
X	int i;
X	int a5_end=0x400;
X	static char pa_data[]={6,4,0x58,2,7,2};
X	static unsigned char db_data[]={
X							0x41,7,0x31,0x20,0x30,0x20,0x30,0x20,0x30,
X							0xa1,3,0x12,1,0x30
X						};
X	
X	buff[cur--]=rp;			/* pel spacing ratio */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=rl;			/* pel spacing ratio */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=0x6;
X	buff[cur--]=0xa6;
X	
X	buff[cur--]=ps;			/* pel spaces */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=sl;			/* spacing length */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=0x6;
X	buff[cur--]=0xa0;
X	
X	buff[cur--]=0x8;		/* pel spacing */
X	buff[cur--]=0xa5;
X	
X	buff[cur--]=lp;			/* line progression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x81;
X	
X	buff[cur--]=pp;			/* pel path */
X	buff[cur--]=0x1;
X	buff[cur--]=0x80;
X	
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LRG */
X	buff[cur--]=0xa1;
X
X	for(i=sizeof(pa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=pa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LPA */
X	buff[cur--]=0xa6;
X
X	for(i=sizeof(db_data)-1;i>=0;i--)
X	{
X		buff[cur--]=db_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LDB */
X	buff[cur--]=0x31;
X
X	buff[cur--]=0x4;		/* pel spacing */
X	buff[cur--]=0x1;		/* pel spacing */
X	buff[cur--]=0x2;		/* pel spacing */
X	
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LDL */
X	buff[cur--]=0xa2;
X
X	i=fwrite(&buff[cur+1],1,a5_end-cur,fout);
X	if(i!=a5_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A6d()
X{
X	int a6_end=0x400;
X	long a6_tend;
X	int cur=0x400;
X	int i;
X	unsigned int u1,u2;
X	int a6_t1;
X	static unsigned char cpa_data[]={
X			0x40,0x09,0x31,0x20,0x30,0x20,0x30,0x20,0x30,0x20,0x30,
X			0x86,0x4};
X	
X	a6_tend=0x400+length;		/* calc the end of the data */
X	
X	cur-=Gen_Lxx(cur,a6_tend-cur);		/* do the LCN */
X	buff[cur--]=0x04;
X	a6_t1=cur;
X	
X	if(nl)		/* if we know the number of lines */
X	{
X		cur-=Gen_Len(cur,nl);		/* do the nl */
X		buff[cur--]=0x81;
X	}
X	
X	cur-=Gen_Len(cur,pl);		/* do the pl */
X	buff[cur--]=0x80;
X	
X	buff[cur--]=cp;		/* do the compression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x82;
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LRC */
X	buff[cur--]=0xa2;
X	
X	for(i=3;i>=0;i--)
X	{
X		buff[cur--]=c1[i];
X	}
X	
X	for(i=sizeof(cpa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=cpa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LCA */
X	buff[cur--]=0x31;
X	
X	cur-=Gen_Lxx(cur,a6_tend-cur);		/* do the LA6*/
X	buff[cur--]=0xa3;
X	
X	i=fwrite(&buff[cur+1],1,a6_end-cur,fout);
X	if(i!=a6_end-cur)
X		return(1);
X	
X	u1=fread(buff,1,0x8000,fin);
X	while(u1>0)
X	{
X		
X		u2=fwrite(buff,1,u1,fout);
X		if(u2!=u1)
X			return(2);
X		u1=fread(buff,1,0x8000,fin);
X	}
X	return(0);
X}
XDo_A6i()
X{
X	int a6_end=0x400;
X	int cur=0x400;
X	int i;
X	unsigned int u1,u2;
X	int a6_t1;
X	static unsigned char cpa_data[]={
X			0x40,0x09,0x31,0x20,0x30,0x20,0x30,0x20,0x30,0x20,0x30,
X			0x86,0x4};
X	
X	buff[cur--]=0x80;
X	buff[cur--]=0x04;
X	a6_t1=cur;
X	
X	if(nl)		/* if we know the number of lines */
X	{
X		cur-=Gen_Len(cur,nl);		/* do the nl */
X		buff[cur--]=0x81;
X	}
X	
X	cur-=Gen_Len(cur,pl);		/* do the pl */
X	buff[cur--]=0x80;
X	
X	buff[cur--]=cp;		/* do the compression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x82;
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LRC */
X	buff[cur--]=0xa2;
X	
X	for(i=3;i>=0;i--)
X	{
X		buff[cur--]=c1[i];
X	}
X	
X	for(i=sizeof(cpa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=cpa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LCA */
X	buff[cur--]=0x31;
X	
X	buff[cur--]=0x80;
X	buff[cur--]=0xa3;
X	
X	i=fwrite(&buff[cur+1],1,a6_end-cur,fout);
X	if(i!=a6_end-cur)
X		return(1);
X	
X	u1=fread(buff,1,0x8000,fin);
X	while(u1>0)
X	{
X		
X		u2=fwrite(buff,1,u1,fout);
X		if(u2!=u1)
X			return(2);
X		u1=fread(buff,1,0x8000,fin);
X	}
X	for(i=0;i<4;buff[i++]=0);
X	u2=fwrite(buff,1,4,fout);
X	if(u2!=4)
X		return(3);
X	
X	return(0);
X}
X
X	
X	
X	
X
END_OF_FILE
  if test 24691 -ne `wc -c <'a11_new.c'`; then
    echo shar: \"'a11_new.c'\" unpacked with wrong size!
  fi
  # end of 'a11_new.c'
fi
if test -f 'e5.ctl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'e5.ctl'\"
else
  echo shar: Extracting \"'e5.ctl'\" \(229 characters\)
  sed "s/^X//" >'e5.ctl' <<'END_OF_FILE'
Xinfile=annexe.dta
Xoutfile=e5.a11
Xlength=31f8
Xc4=03
Xcp=01
Xlp=03
Xpp=00
Xps=01
Xrl=01
Xrp=01
Xsl=04
Xstring=Example for Annex E.5 of ANSI/AIIM MS53 199X~
X
Xdh=27d8
Xdv=41a0
Xfx=0
Xfy=0
Xhp=27d8
Xnl=af0
Xph=0
Xpl=6c0
Xpv=0
Xsx=27d8
Xsy=3390
Xvp=41a0
END_OF_FILE
  if test 229 -ne `wc -c <'e5.ctl'`; then
    echo shar: \"'e5.ctl'\" unpacked with wrong size!
  fi
  # end of 'e5.ctl'
fi
if test -f 'gen_a11.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gen_a11.c'\"
else
  echo shar: Extracting \"'gen_a11.c'\" \(23635 characters\)
  sed "s/^X//" >'gen_a11.c' <<'END_OF_FILE'
X/* This program was written by Mike Fleischmann of Optical Publishing, Inc.
X	Copyright 1993 Optical Publishing, Inc. All rights reserved.
X	Redistribution and use in source and binary form are freely permitted
X	provided that the above copyright notice appears in all documentation.
X	
X	THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESSED OR IMPLIED
X	WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF 
X	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. By installing this 
X	software, you agree to hold Optical Publishing, Inc. harmless for any 
X	damages resulting from the use of this software.
X*/
X
X/* The program was copyrighted to allow you to know the source of the code. 
X	This way if you need to contact us, you at least know the company name.
X	We are in based in Ft. Collins, Colorado at (303)-226-3466.
X	Our intention is to allow you to use, modify, copy and redistribute this
X	code as well as integrate it into your applications at no charge or 
X	royalties of any kind. Our only request is that if you use sections of 
X	this code in your products, you include a 'Portions Copyright 1993 Optical
X	Publishing, Inc. All rights reserved.' in your documentation. That's it, 
X	we want to make this standard as easy to use as possible and giving away
X	working code seemed the best way to do it.
X*/
X
X/* although this program was developed to generate the examples in appendix
X	E of the ANSI/AIIM MS53-199x standard it would work as a primitive 
X	import routine. This program should compile with either Borland C or 
X	Microsoft C. The tab spacing was set to 4.
X	
X	This was not written to be the most efficient code but rather as a  
X	demo of the A11 standard encoding. Also, there is minimal error checking
X	a full implementation would have extensive error checking.
X
X
X	The program's calling parameters are GEN_A11 filename.ext where
X		filename.ext is the name of the control file.
X	The control file is in the format keyword=value. All values are in HEX!!
X	NOTE: all the keywords are not necessary if you are excluding the area
X	where they are used. i.e. clipping.
X
X	keywords are (case insensitive):
X		infile		the input image file
X		outfile		the output image file name. (an extension .A11 is suggested)
X		length		the length of the data file
X		c4			the last digit in the c1 c2 c3 c4 encoding string
X		cp			the compression flag
X		lp			the line progression 
X		pp			the pel path
X		ps			the pel spaces value
X		rl			the raster ratio for line spacing
X		rp			the raster ratio for pel spacing
X		sl			the spacing length
X		string		the user string. (note this can span lines needs to be 
X					ended with the tilda (~) character.
X		dh			horizontal block dimensions
X		dv			vertical block dimensions
X		fx			first X clipping coord in BMUs
X		fy			first Y clipping coord in BMUs
X		hp			horizontal page dimensions in BMUs
X		nl			number of lines (if known)
X		ph			horizontal starting position in BMUs
X		pl			number of pels per line
X		pv			vertical starting position in BMUs 
X		sx			second X clipping coord in BMUs
X		sy			secong Y clipping coord in BMUs
X		vp			vertical page dimensions in BMUs
X*/
X
X#include <stdio.h>
X#include <string.h>
X#include <stdlib.h>
X#include <ctype.h>
X
X#define LEN_A1_NARY 60
X#define LEN_A2 15
X#define LEN_A3_NARY 18
X#define LEN_A4 19
X
Xunsigned char a1_nary[]={	/* fixed portion of a1 */
X	0x84,0x05,
X		0x2a,0x86,0x48,0xce,0x1c,
X	0xa5,0x06,
X		0x06,0x04,
X			0x58,0x02,0x07,0x02,
X		0x86,0x01,
X			0x00,
X		0xa8,0x16,
X			0x43,0x08,
X				0x49,0x53,0x4f,0x20,0x38,0x36,0x31,0x33,
X			0x44,0x0a,
X				0x31,0x39,0x39,0x31,0x2d,0x31,0x32,0x2d,0x33,0x31,
X		0xaa,0x10,
X			0xa0,0x0e,
X				0x80,0x04,
X					0x58,0x02,0x07,0x02,
X				0xaa,0x06,
X					0x86,0x04,
X						0x58,0x03,0x07,0x06
X	};
X
Xunsigned char a2[]={		/* The document layout root  fixed content */
X					0xa2,0x0d,
X						0x02,0x01,
X							0x00,
X						0x31,0x08,
X							0x41,0x01,
X								0x31,
X							0xa0,0x03,
X								0x12,0x01,
X									0x30
X					};
X
Xunsigned char a3_nary[]={	/* fixed portion of a3 */
X		0x41,0x03,
X			0x31,0x20,0x30,
X		0xa0,0x03,
X			0x12,0x01,
X				0x30,
X			0xaf,0x06,
X				0x80,0x01,
X					0x00,
X				0x80,0x01,
X					0x00
X	};
X
Xunsigned char a4[]={		/* The document layout root  fixed content */
X					0xa2,0x11,
X						0x02,0x01,
X							0x03,
X						0x31,0x0c,
X							0x41,0x05,
X								0x31,0x20,0x30,0x20,0x30,
X							0xa0,0x03,
X								0x12,0x01,
X									0x30
X					};
X
Xunsigned char c1[]={0x58,0x03,0x07,0xff};	/* the c1c2c3c4 param */
Xunsigned char cp=0xff;		/* compression set to invalid value */
Xunsigned char lp=0xff;		/* line progression set to invalid value */
Xunsigned char pp=0xff;		/* pel path set to invalid character */
Xunsigned char ps=0;	/* pel spaces (invalid value)*/
Xunsigned char rl=0;	/* raster ratio line spacing (invalid value) */
Xunsigned char rp=0;	/* raster ratio pel spacing (invalid value) */
Xunsigned char sl=0;	/* spacing length (invalid value) */
Xchar str1[510];			/* the variable length string. (512 bytes max) */
X
Xlong dh=0;				/* horizontal block dimensions in BMUs */
Xlong dv=0;				/* vertical block dimensions in BMUs */
Xlong fx=0;				/* first x clipping coord in BMUs */
Xlong fy=0;				/* first y clipping coord in BMUs */
Xlong hp=0;				/* horizontal page dimensions in BMU's */
Xlong nl=0;				/* number of lines */
Xlong ph=0;				/* horizontal starting position in BMUs */
Xlong pl=0;				/* number of pels per line */
Xlong pv=0;				/* vertical starting position */
Xlong sx=0;				/* second X clipping coord in BMUs */
Xlong sy=0;				/* second Y clipping coord in BMUs */
Xlong vp=0;				/* vertical page dimensions in BMUs */
X
Xlong length=0;			/* length of the input data file */
X
XFILE *fin;				/* handle for the input image file */
XFILE *fout;				/* handle for the output A11 file */
XFILE *ctrl;				/* the file handle for the control file */
X
Xunsigned char buff[0x8000];		/* work buffer */
Xunsigned char line[0x200];		/* line entry buffer */
X
Xchar *keyword[]={
X	"INFILE",
X	"OUTFILE",
X	"LENGTH",
X	"C4",
X	"CP",
X	"LP",
X	"PP",
X	"PS",
X	"RL",
X	"RP",
X	"SL",
X	"STRING",
X	"DH",
X	"DV",
X	"FX",
X	"FY",
X	"HP",
X	"NL",
X	"PH",
X	"PL",
X	"PV",
X	"SX",
X	"SY",
X	"VP",
X	"~~~"};		/* mark as the end */
X
X#define INFILE 0
X#define OUTFILE 1
X#define LENGTH 2 
X#define C4 3 
X#define CP 4 
X#define LP 5
X#define PP 6
X#define PS 7
X#define RL 8
X#define RP 9 
X#define SL 10
X#define STRING 11
X#define DH 12
X#define DV 13
X#define FX 14
X#define FY 15
X#define HP 16
X#define NL 17
X#define PH 18
X#define PL 19
X#define PV 20
X#define SX 21
X#define SY 22
X#define VP 23
X
X
Xvoid Get_Line(void);
Xint Char2val(int);
Xlong Get_Hex(char *);
XRead_Control(void);
XDo_In_Fun(int,char *);
Xint Gen_Lxx(int,unsigned long);		/* gen the format lxx table 5*/
Xint Gen_Len(int,unsigned long);		/* gen the format lxx table 4*/
XDo_A1(void);		/* this and the following will build the data from
X					the end
X					*/ 
XDo_A3(void);
XDo_A5c(void);
XDo_A5(int,int);		/* first int is current, second int is scpe loc */
XDo_A6d(void);
XDo_A6i(void);
X
X
X
Xint main(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	int rtn;		/* used for function return checking */
X
X	str1[0]=' ';	/* guarentee at least a comment */
X	str1[1]=0;	/* guarentee at least a comment */
X	if(argc<2)
X	{
X		printf("calling parameters are GEN_A11 ctrlfile.ext\n");
X		printf(" where ctrlfile.ext is the controll file. See source code for\n");
X		printf(" more information\n");
X		exit(0);
X	}
X	
X	ctrl=fopen(argv[1],"r");
X	if(ctrl==NULL)
X	{
X		printf("unable to open the controll file >%s<\n",argv[1]);
X		exit(0);
X	}
X	
X	rtn=Read_Control();			/* read the control file in */
X	if(rtn)		/* if an error */
X	{
X		printf("error reading controll file. Program ending\n");
X		exit(0);
X	}
X	rtn=Do_A1();		/* go and do the a.1 table */
X	if(rtn)		/* if an error */
X	{
X		printf("error in generation of the A.1 header table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=fwrite(a2,1,LEN_A2,fout);		/* output the a2 table */
X	if(rtn!=LEN_A2)		/* if an error */
X	{
X		printf("error in writing A.2 table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=Do_A3();		/* go and do the a.3 table */
X	if(rtn)		/* if an error */
X	{
X		printf("error in generation of the A.3 header table. Program ending\n");
X		exit(0);
X	}
X
X	rtn=fwrite(a4,1,LEN_A4,fout);		/* output the a4 table */
X	if(rtn!=LEN_A4)		/* if an error */
X	{
X		printf("error in writing A.4 table. Program ending\n");
X		exit(0);
X	}
X
X	if(fx!=0 || fy!=0 || sx!=0 || sy!=0)
X	{
X		/* if here we have clipping */
X		rtn=Do_A5c();		/* go and do the a.5 table for clipping */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.51 header table. Program ending\n");
X			exit(0);
X		}
X	}
X	else
X	{
X		rtn=Do_A5(0x400,0x400);		/* go and do the a.5 table for no clipping*/
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.3 header table. Program ending\n");
X			exit(0);
X		}
X	}
X
X	if(length>0)		/* definite length */
X	{
X		rtn=Do_A6d();		/* go and do the a.6 table */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.6 table. Program ending\n");
X			exit(0);
X		}
X	}
X	else	/* indefinite length */
X	{
X		rtn=Do_A6i();		/* go and do the a.6 table */
X		if(rtn)		/* if an error */
X		{
X			printf("error in generation of the A.6 table. Program ending\n");
X			exit(0);
X		}
X	}
X
X	fclose(fout);
X	fclose(fin);
X	fclose(ctrl);
X	printf("File build finished\n");
X	return(0);
X}
X
Xvoid Get_Line()
X{
X	int i;		/* temp work variable */
X
X	fgets(line,0x200,ctrl);
X	i=strlen(line);
X	for(i--;i>0 && line[i]<=' ';line[i--]=0) ;  /* remove trailing crlf */
X	
X	/* turn to uppercase */
X	for(i=0;line[i] && line[i]!='=';line[i]=toupper(line[i]),i++);
X	if(memcmp(line,"STRING",6)!=0)	/* skip string case */
X		for(;line[i];line[i]=toupper(line[i]),i++);
X
X}
X
Xint Char2val(ch)
Xint ch;
X{
X	if(ch<='9')
X		ch-='0';
X	else
X		ch = ch-'A'+10;
X	return(ch);
X}
X
Xlong Get_Hex(str)
Xchar *str;
X{
X	long l1;
X	int i;
X	
X	for(i=0;str[i]<=' ' && str[i];i++);	/* ignore leading white space */
X
X	for(i=0,l1=0;isxdigit(str[i]);i++)
X	{
X		l1<<=4;
X		l1+=(long)Char2val(str[i]);
X	}
X	return(l1);
X}
X
XRead_Control()
X{
X	/* this will read in the control file and initialize the variables */
X	char *cptr,*cptr1;		/* temp char pointer used for parsing */
X	int i,j,k;
X	
X	Get_Line();		/* input the line */
X	while(!feof(ctrl))
X	{
X		cptr=line;
X		while(cptr[0]==' ')		/* skip leading spaces */
X			cptr++;
X		cptr1=strchr(cptr,'=');
X		if(cptr1!=NULL)		/* if null treat as comment field */
X		{
X			/* if here have something to work with */
X			cptr1[0]=0;		/* mark end */
X			cptr1++;
X			i=strlen(cptr);		/* get the length of compare string  */
X			for(j=0;keyword[j][0]!='~';j++)
X			{
X				if(memcmp(cptr,keyword[j],i)==0)
X				{
X					k=Do_In_Fun(j,cptr1);
X					if(k)
X						return(k);		/* return if error */
X					break;
X				}
X			}
X		}
X		Get_Line();		/* input the line */
X	}
X	return(0);		/* return valid processing */
X}
X
XDo_In_Fun(fun,str)
Xint fun;		/* the function number to do */
Xchar *str;		/* the remaining string */
X{
X	int i,j;
X	char *cptr;
X	
X	switch(fun)
X	{
X		case INFILE:
X			fin=fopen(str,"rb");		/* open the input image file */
X			if(fin==NULL)
X				return(INFILE+1);
X			break;
X		case OUTFILE:
X			fout=fopen(str,"wb");		/* open the output A11 file */
X			if(fout==NULL)
X				return(OUTFILE+1);
X			break;
X		case LENGTH:
X			length=Get_Hex(str);		/* get the length */
X			if(length<1)
X				return(LENGTH+1);
X			break;
X		case C4:
X			c1[3]=(char)Get_Hex(str);	/* get the c4 character */
X			if(c1[3]>8)
X				return(C4+1);
X			break;
X		case CP:
X			cp=(char)Get_Hex(str);	/* get the cp character */
X			if(cp<0 || cp>1)
X				return(CP+1);
X			break;
X		case LP:
X			lp=(char)Get_Hex(str);	/* get the lp character */
X			if(lp!=1 && lp!=3)
X				return(LP+1);
X			break;
X		case PP:
X			pp=(char)Get_Hex(str);	/* get the pp character */
X			if(pp<0 || pp>3)
X				return(PP+1);
X			break;
X		case PS:
X			ps=(char)Get_Hex(str);	/* get the ps character */
X			if(ps==0)
X				return(PS+1);
X			break;
X		case RL:
X			rl=(char)Get_Hex(str);	/* get the cp character */
X			if(rl==0)
X				return(RL+1);
X			break;
X		case RP:
X			rp=(char)Get_Hex(str);	/* get the cp character */
X			if(rp==0)
X				return(RP+1);
X			break;
X		case SL:
X			sl=(char)Get_Hex(str);	/* get the cp character */
X			if(sl==0)
X				return(SL+1);
X			break;
X		case STRING:
X			j=0;
X			cptr=str;
X			while(1)
X			{
X				for(i=0;cptr[i] && cptr[i]!='~' && j<500;i++)
X					str1[j++]=cptr[i];
X				if(j>499 || cptr[i]=='~')	/* done entering string */
X					break;
X				Get_Line();
X				if(feof(ctrl))
X					return(STRING+1);
X				cptr=line;
X			}
X			str1[j++]=0;		/* null terminate */
X			break;
X		case DH:
X			dh=Get_Hex(str);	/* get the dh value */
X			if(dh<1)
X				return(DH+1);
X			break;
X		case DV:
X			dv=Get_Hex(str);	/* get the dv value */
X			if(dv<1)
X				return(DV+1);
X			break;
X		case FX:
X			fx=Get_Hex(str);	/* get the fx value */
X			break;
X		case FY:
X			fy=Get_Hex(str);	/* get the fy value */
X			break;
X		case HP:
X			hp=Get_Hex(str);	/* get the hp value */
X			if(hp<1)
X				return(HP+1);
X			break;
X		case NL:
X			nl=Get_Hex(str);	/* get the nl value */
X			if(nl<1)
X				return(NL+1);
X			break;
X		case PH:
X			ph=Get_Hex(str);	/* get the ph value */
X			if(dh<0)
X				return(PH+1);
X			break;
X		case PL:
X			pl=Get_Hex(str);	/* get the pl value */
X			if(pl<1)
X				return(PL+1);
X			break;
X		case PV:
X			pv=Get_Hex(str);	/* get the pv value */
X			break;
X		case SX:
X			sx=Get_Hex(str);	/* get the sx value */
X			break;
X		case SY:
X			sy=Get_Hex(str);	/* get the sy value */
X			break;
X		case VP:
X			vp=Get_Hex(str);	/* get the vp value */
X			if(vp<1)
X				return(VP+1);
X			break;
X		default:
X			return(-1);
X	}
X    return(0);
X}
X
Xint Gen_Lxx(cur,val)		/* gen the format table 5 */
Xint cur;		/* current position in buff */
Xunsigned long val;		/* value to insert */
X{
X	
X	if(val <0x80L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		return(1);
X	}
X	else if(val <0x100L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=0x81;
X		return(2);
X	}
X	else if(val <0x10000L)	/* 2 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=0x82;
X		return(3);
X	}
X	else if(val <0x1000000L)	/* 3 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=0x83;
X		return(4);
X	}
X	else	/* 4 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=(unsigned char) (val>>24) & 0xff;
X		buff[cur-4]=0x84;
X		return(5);
X	}
X}
X
Xint Gen_Len(cur,val)		/* gen the format table 4 */
Xint cur;		/* current position in buff */
Xunsigned long val;		/* value to insert */
X{
X	
X	if(val <0x100L)	/* single byte */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=1;
X		return(2);
X	}
X	else if(val <0x10000L)	/* 2 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=2;
X		return(3);
X	}
X	else if(val <0x1000000L)	/* 3 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=3;
X		return(4);
X	}
X	else	/* 4 bytes */
X	{
X		buff[cur]=(unsigned char) val & 0xff;
X		buff[cur-1]=(unsigned char) (val>>8) & 0xff;
X		buff[cur-2]=(unsigned char) (val>>16) & 0xff;
X		buff[cur-3]=(unsigned char) (val>>24) & 0xff;
X		buff[cur-4]=4;
X		return(5);
X	}
X}
X
XDo_A1()		/* this and the following will build the data from the end 
X			towards the front */
X{
X	int a1_end=0x400;
X	int cur=0x400;
X	int dend;
X	int nend;
X	int pt8;
X	int pt7;
X	int pt3;
X	int i;
X	
X	i=strlen(str1);
X	i--;
X	while(i>=0)		/* copy the users string */
X	{
X		buff[cur--]=str1[i--];
X	}
X
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LDR section */
X	buff[cur--]=0x43;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD3 section */
X	buff[cur--]=0xa5;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD2 section */
X	buff[cur--]=0xa7;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LD1 section */
X	buff[cur--]=0xa3;
X	dend=cur;		/* mark the current position */
X	
X	i=LEN_A1_NARY;
X	i--;
X	while(i>=0)		/* copy the fixed array stuff */
X	{
X		buff[cur--]=a1_nary[i--];
X	}
X	nend=cur;		/* mark position of a1_end byte */
X	
X	buff[cur--]=ps;
X	buff[cur--]=1;
X	buff[cur--]=2;
X
X	buff[cur--]=sl;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	buff[cur--]=6;
X	buff[cur--]=0xa0;
X	buff[cur--]=8;
X	buff[cur--]=0xa5;
X	
X	buff[cur--]=lp;
X	buff[cur--]=1;
X	buff[cur--]=0x8a;
X	
X	buff[cur--]=pp;
X	buff[cur--]=1;
X	buff[cur--]=0x89;
X	buff[cur--]=0x10;
X	buff[cur--]=0xa4;
X	
X	buff[cur--]=cp;
X	buff[cur--]=1;
X	buff[cur--]=0x80;
X	buff[cur--]=3;
X	buff[cur--]=0xa3;
X
X	pt8=cur;
X	buff[cur--]=0;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	pt7=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,pt7-cur);		/* do the L13 */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt8-cur);		/* do the LNP */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt8-cur);		/* do the LMT */
X	buff[cur--]=0xa8;
X	pt3=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,pt3-cur);		/* do the L12 */
X	buff[cur--]=0x30;
X	
X	cur-=Gen_Lxx(cur,pt3-cur);		/* do the L11 */
X	buff[cur--]=0xa2;
X	
X	cur-=Gen_Lxx(cur,nend-cur);		/* do the LND */
X	buff[cur--]=0xa2;
X	buff[cur--]=0x00;
X	buff[cur--]=0x01;
X	buff[cur--]=0x81;
X	
X	cur-=Gen_Lxx(cur,dend-cur);		/* do the LDC*/
X	buff[cur--]=0xa2;
X	buff[cur--]=0x31;
X	buff[cur--]=0x01;
X	buff[cur--]=0x81;
X	
X	cur-=Gen_Lxx(cur,a1_end-cur);		/* do the LDP*/
X	buff[cur--]=0xa0;
X	
X	i=fwrite(&buff[cur+1],1,a1_end-cur,fout);
X	if(i!=a1_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A3()
X{
X	int a3_end=0x400;
X	int cur=0x400;
X	int a3_nend;
X	int a3_mt;
X	int a3_nps;
X	int a3_pde;
X	int a3_pds;
X	int a3_body;
X	int a3_start;
X	int i;
X	
X	buff[cur--]=0;
X	buff[cur--]=1;
X	buff[cur--]=2;
X	a3_nend=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X	a3_nps=cur;
X
X	cur-=Gen_Lxx(cur,a3_nend-a3_nps);		/* do the LN3 */
X	buff[cur--]=0x30;
X	a3_mt=cur;
X	
X	cur-=Gen_Lxx(cur,a3_end-a3_mt);		/* do the LM3 */
X	buff[cur--]=0xb0;
X	a3_pde=cur;
X	
X	cur-=Gen_Len(cur,vp);		/* do the vp */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,hp);		/* do the hp */
X	buff[cur--]=0x80;
X	a3_pds=cur;
X
X	cur-=Gen_Lxx(cur,a3_pde-a3_pds);		/* do the LPD */
X	buff[cur--]=0xa4;
X
X	i=LEN_A3_NARY;
X	i--;
X	while(i>=0)		/* copy the fixed array stuff */
X	{
X		buff[cur--]=a3_nary[i--];
X	}
X	a3_body=cur;		/* mark position */
X	cur-=Gen_Lxx(cur,a3_end-a3_body);		/* do the LAB */
X	buff[cur--]=0x31;
X	buff[cur--]=0x02;
X	buff[cur--]=0x01;
X	buff[cur--]=0x02;
X
X
X	a3_start=cur;		/* mark position of a1_end byte */
X
X	cur-=Gen_Lxx(cur,a3_end-a3_start);		/* do the LA3 */
X	buff[cur--]=0xa2;
X
X	i=fwrite(&buff[cur+1],1,a3_end-cur,fout);
X	if(i!=a3_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A5c()
X{
X	int a5_end=0x400;
X	int cur=0x400;
X	int a5_dime;
X	int a5_scpe;
X	int a5_fcpe;
X	
X	
X	if(nl<1)		/* if we don't know the number of lines (required for clp)*/
X	{
X		return(1);		/* return the error */
X	}
X
X	cur-=Gen_Len(cur,pv);		/* do the pv */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,ph);		/* do the ph */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LPS */
X	buff[cur--]=0xa3;
X	a5_dime=cur;
X
X	cur-=Gen_Len(cur,dv);		/* do the dv */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Len(cur,dh);		/* do the dh */
X	buff[cur--]=0x80;
X
X	cur-=Gen_Lxx(cur,a5_dime-cur);		/* do the LDM */
X	buff[cur--]=0xa4;
X	a5_scpe=cur;
X
X	cur-=Gen_Len(cur,sy);		/* do the sy */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Len(cur,sx);		/* do the sx */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LSP */
X	buff[cur--]=0xa1;
X	a5_fcpe=cur;
X
X	cur-=Gen_Len(cur,fy);		/* do the fy */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Len(cur,fx);		/* do the fx */
X	buff[cur--]=0x2;
X
X	cur-=Gen_Lxx(cur,a5_fcpe-cur);		/* do the LFP */
X	buff[cur--]=0xa0;
X
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LFP */
X	buff[cur--]=0xa4;
X
X	return(Do_A5(cur,a5_scpe));
X}
X
XDo_A5(cur,a5_scpe)
Xint	cur;			/* current position in the buffer */
Xint a5_scpe;		/* scpe position in the buffer */
X{
X	int i;
X	int a5_end=0x400;
X	static char pa_data[]={6,4,0x58,2,7,2};
X	static unsigned char db_data[]={
X							0x41,7,0x31,0x20,0x30,0x20,0x30,0x20,0x30,
X							0xa1,3,0x12,1,0x30
X						};
X	
X	buff[cur--]=rp;			/* pel spacing ratio */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=rl;			/* pel spacing ratio */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=0x6;
X	buff[cur--]=0xa6;
X	
X	buff[cur--]=ps;			/* pel spaces */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=sl;			/* spacing length */
X	buff[cur--]=0x1;
X	buff[cur--]=0x2;
X	
X	buff[cur--]=0x6;
X	buff[cur--]=0xa0;
X	
X	buff[cur--]=0x8;		/* pel spacing */
X	buff[cur--]=0xa5;
X	
X	buff[cur--]=lp;			/* line progression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x81;
X	
X	buff[cur--]=pp;			/* pel path */
X	buff[cur--]=0x1;
X	buff[cur--]=0x80;
X	
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LRG */
X	buff[cur--]=0xa1;
X
X	for(i=sizeof(pa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=pa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a5_scpe-cur);		/* do the LPA */
X	buff[cur--]=0xa6;
X
X	for(i=sizeof(db_data)-1;i>=0;i--)
X	{
X		buff[cur--]=db_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LDB */
X	buff[cur--]=0x31;
X
X	buff[cur--]=0x4;		/* pel spacing */
X	buff[cur--]=0x1;		/* pel spacing */
X	buff[cur--]=0x2;		/* pel spacing */
X	
X	cur-=Gen_Lxx(cur,a5_end-cur);		/* do the LDL */
X	buff[cur--]=0xa2;
X
X	i=fwrite(&buff[cur+1],1,a5_end-cur,fout);
X	if(i!=a5_end-cur)
X		return(1);
X	return(0);
X}
X
XDo_A6d()
X{
X	int a6_end=0x400;
X	long a6_tend;
X	int cur=0x400;
X	int i;
X	unsigned int u1,u2;
X	int a6_t1;
X	static unsigned char cpa_data[]={
X			0x40,0x09,0x31,0x20,0x30,0x20,0x30,0x20,0x30,0x20,0x30,
X			0x86,0x4};
X	
X	a6_tend=0x400+length;		/* calc the end of the data */
X	
X	cur-=Gen_Lxx(cur,a6_tend-cur);		/* do the LCN */
X	buff[cur--]=0x04;
X	a6_t1=cur;
X	
X	if(nl)		/* if we know the number of lines */
X	{
X		cur-=Gen_Len(cur,nl);		/* do the nl */
X		buff[cur--]=0x81;
X	}
X	
X	cur-=Gen_Len(cur,pl);		/* do the pl */
X	buff[cur--]=0x80;
X	
X	buff[cur--]=cp;		/* do the compression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x82;
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LRC */
X	buff[cur--]=0xa2;
X	
X	for(i=3;i>=0;i--)
X	{
X		buff[cur--]=c1[i];
X	}
X	
X	for(i=sizeof(cpa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=cpa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LCA */
X	buff[cur--]=0x31;
X	
X	cur-=Gen_Lxx(cur,a6_tend-cur);		/* do the LA6*/
X	buff[cur--]=0xa3;
X	
X	i=fwrite(&buff[cur+1],1,a6_end-cur,fout);
X	if(i!=a6_end-cur)
X		return(1);
X	
X	u1=fread(buff,1,0x8000,fin);
X	while(u1>0)
X	{
X		
X		u2=fwrite(buff,1,u1,fout);
X		if(u2!=u1)
X			return(2);
X		u1=fread(buff,1,0x8000,fin);
X	}
X	return(0);
X}
XDo_A6i()
X{
X	int a6_end=0x400;
X	int cur=0x400;
X	int i;
X	unsigned int u1,u2;
X	int a6_t1;
X	static unsigned char cpa_data[]={
X			0x40,0x09,0x31,0x20,0x30,0x20,0x30,0x20,0x30,0x20,0x30,
X			0x86,0x4};
X	
X	buff[cur--]=0x80;
X	buff[cur--]=0x04;
X	a6_t1=cur;
X	
X	if(nl)		/* if we know the number of lines */
X	{
X		cur-=Gen_Len(cur,nl);		/* do the nl */
X		buff[cur--]=0x81;
X	}
X	
X	cur-=Gen_Len(cur,pl);		/* do the pl */
X	buff[cur--]=0x80;
X	
X	buff[cur--]=cp;		/* do the compression */
X	buff[cur--]=0x1;
X	buff[cur--]=0x82;
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LRC */
X	buff[cur--]=0xa2;
X	
X	for(i=3;i>=0;i--)
X	{
X		buff[cur--]=c1[i];
X	}
X	
X	for(i=sizeof(cpa_data)-1;i>=0;i--)
X	{
X		buff[cur--]=cpa_data[i];
X	}
X	
X	cur-=Gen_Lxx(cur,a6_t1-cur);		/* do the LCA */
X	buff[cur--]=0x31;
X	
X	buff[cur--]=0x80;
X	buff[cur--]=0xa3;
X	
X	i=fwrite(&buff[cur+1],1,a6_end-cur,fout);
X	if(i!=a6_end-cur)
X		return(1);
X	
X	u1=fread(buff,1,0x8000,fin);
X	while(u1>0)
X	{
X		
X		u2=fwrite(buff,1,u1,fout);
X		if(u2!=u1)
X			return(2);
X		u1=fread(buff,1,0x8000,fin);
X	}
X	for(i=0;i<4;buff[i++]=0);
X	u2=fwrite(buff,1,4,fout);
X	if(u2!=4)
X		return(3);
X	
X	return(0);
X}
X
X	
X	
X	
X
END_OF_FILE
  if test 23635 -ne `wc -c <'gen_a11.c'`; then
    echo shar: \"'gen_a11.c'\" unpacked with wrong size!
  fi
  # end of 'gen_a11.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
