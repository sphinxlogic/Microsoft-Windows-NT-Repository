Newsgroups: comp.sources.misc
From: mgleason@cse.unl.edu (Michael Gleason)
Subject: v35i005:  ncftp - Alternative User Interface for FTP, Part02/04
Message-ID: <1993Jan25.155436.13646@sparky.imd.sterling.com>
X-Md4-Signature: 2300b67254e4be90ac0afc3a7b34dbae
Date: Mon, 25 Jan 1993 15:54:36 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: mgleason@cse.unl.edu (Michael Gleason)
Posting-number: Volume 35, Issue 5
Archive-name: ncftp/part02
Environment: UNIX, ANSI-C, getopt
Supersedes: ncftp: Volume 34, Issue 14-16

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  defaults.h ftp.c main.c
# Wrapped by kent@sparky on Mon Jan 25 09:48:03 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 4)."'
if test -f 'defaults.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defaults.h'\"
else
  echo shar: Extracting \"'defaults.h'\" \(1763 characters\)
  sed "s/^X//" >'defaults.h' <<'END_OF_FILE'
X/* defaults.h: default values for ftp's common variables */
X
X#ifndef _DEFAULTS_H_
X#define _DEFAULTS_H_
X
X#ifndef NEWMAILMESSAGE			/* For english speakers, "You have new mail." */
X#define NEWMAILMESSAGE "You have new mail."
X#endif
X
X#ifndef ZCAT					/* Usually "zcat," but use the full pathname */
X								/* if possible. */
X#define ZCAT "zcat"
X#endif
X
X#ifndef MAX_XFER_BUFSIZE
X#define MAX_XFER_BUFSIZE 32768
X#endif
X
X#ifndef dDEBUG					/* 1 or 0, usually 0 */
X#define dDEBUG 0
X#endif
X
X#ifndef dMPROMPT				/* Usually 1, I prefer 0... */
X#define dMPROMPT 0
X#endif
X
X#ifndef dVERBOSE				/* V_QUIET, V_ERRS, V_TERSE, V_VERBOSE */
X#include "cmds.h"				/* for definitions of the above */
X#define dVERBOSE V_TERSE
X#endif
X
X#ifndef dPROMPT					/* short: "@Bftp@P>" */
X								/* long: "@B@E @UNcFTP@P @B@M@D@P ->" */
X#define dPROMPT "@B@E @UNcFTP@P @B@M@D@P ->"
X#endif
X
X#ifndef dPAGER					/* if set to empty string, act like 'cat' */
X#define dPAGER "more"
X#endif
X
X#ifndef dLOGNAME				/* put in the user's home directory. */
X#define dLOGNAME ".ftplog"
X#endif
X
X								/* Do you want logging on by default? */
X#ifndef dLOGGING				/* usually 0 */
X#define dLOGGING 0
X#endif
X
X#ifndef dTYPE					/* usually TYPE_A */
X#define dTYPE TYPE_A
X#endif
X
X#ifndef dTYPESTR				/* usually "ascii" */
X#define dTYPESTR "ascii"
X#endif
X
X#ifndef dREDIALDELAY			/* usu. 60 (seconds). */
X#define dREDIALDELAY 60
X#endif
X
X#ifndef CMDLINELEN
X#define CMDLINELEN 256
X#endif
X
X#ifndef RECEIVEDLINELEN
X#define RECEIVEDLINELEN 256
X#endif
X
X#ifndef MAXMACROS
X#define MAXMACROS 16
X#endif
X
X#ifndef MACBUFLEN				/* usually 4096. */
X#define MACBUFLEN 4096
X#endif
X
X/* Do you want binary transfers by default? */
X#ifndef dAUTOBINARY				/* usually 1 */
X#define dAUTOBINARY 1
X#endif
X
X#endif	/* _DEFAULTS_H_ */
X
X/* eof */
END_OF_FILE
  if test 1763 -ne `wc -c <'defaults.h'`; then
    echo shar: \"'defaults.h'\" unpacked with wrong size!
  fi
  # end of 'defaults.h'
fi
if test -f 'ftp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ftp.c'\"
else
  echo shar: Extracting \"'ftp.c'\" \(29938 characters\)
  sed "s/^X//" >'ftp.c' <<'END_OF_FILE'
X/* ftp.c */
X
X#include "sys.h"
X#include <sys/types.h>
X#include <sys/param.h>
X#include <setjmp.h>
X#include <sys/stat.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <sys/file.h>
X
X#ifdef SYSLOG
X#	include <syslog.h>
X#endif
X
X/* You may need this for declarations of fd_set, etc. */
X#ifdef SYSSELECTH
X#   include <sys/select.h>
X#else
Xextern int select (int, void *, void *, void *, struct timeval *);
X#endif
X
X#ifndef NO_UNISTDH		/* for prototypes only. */
X#	include <unistd.h>
X#endif
X
X#include <netinet/in.h>
X#include <arpa/ftp.h>
X#include <arpa/inet.h>
X#include <arpa/telnet.h>
X#include <string.h>
X#include <signal.h>
X#include <errno.h>
X#include <netdb.h>
X#include <fcntl.h>
X#include <pwd.h>
X#include <ctype.h>
X#include "ftpdefs.h"
X#include "defaults.h"
X#include "ftp.h"
X#include "cmds.h"
X#include "main.h"
X#include "ftprc.h"
X#include "getpass.h"
X#include "copyright.h"
X
X/* ftp.c globals */
Xstruct				sockaddr_in hisctladdr;
Xstruct				sockaddr_in data_addr;
Xint					data = -1;
Xint					abrtflag = 0;
Xint					connected;			/* connected to server */
Xstruct sockaddr_in	myctladdr;
XFILE				*cin = NULL, *cout = NULL;
Xchar				*reply_string = NULL;
Xjmp_buf				sendabort, recvabort;
Xint					progress_meter = 1;
Xint					cur_progress_meter;
Xint					sendport = -1;		/* use PORT cmd for each data connection */
Xint					code;				/* return/reply code for ftp command */
Xstring				hostname;			/* name of host connected to */
Xint     			cpend;				/* flag: if != 0, then pending server reply */
Xchar				*xferbuf;			/* buffer for local and remote I/O */
Xsize_t				xferbufsize;		/* size in bytes, of the transfer buffer. */
Xlong				next_report;
Xlong				bytes;
Xlong				now_sec;
Xlong				file_size;
Xstruct timeval		start, stop;
X
X/* ftp.c externs */
Xextern FILE					*logf;
Xextern string				hostname, cwd, anon_password;
Xextern int					verbose, debug, macnum, margc;
Xextern int					curtype, creating;
Xextern int					options, activemcmd, paging;
Xextern int					ansi_escapes;
Xextern char					*line, *margv[];
Xextern char					*tcap_normal, *tcap_boldface;
Xextern char					*tcap_underline, *tcap_reverse;
Xextern struct userinfo		uinfo;
Xextern struct macel			macros[];
X
X#ifdef REDIR
Xextern struct lslist		*lshead, *lstail;
Xextern int					is_ls;
X#endif
X
X#define UPDATE_100 2
X
X
Xint hookup(char *host, int port)
X{
X	register struct hostent *hp = 0;
X	int s, len, hErr = -1;
X
X	bzero((char *)&hisctladdr, sizeof (hisctladdr));
X#ifdef BAD_INETADDR
X	hisctladdr.sin_addr = inet_addr(host);
X#else
X 	hisctladdr.sin_addr.s_addr = inet_addr(host);
X#endif
X	if (hisctladdr.sin_addr.s_addr != -1) {
X		hisctladdr.sin_family = AF_INET;
X		(void) Strncpy(hostname, host);
X	} else {
X		hp = gethostbyname(host);
X		if (hp == NULL) {
X#ifdef HERROR
X			extern int h_errno;
X			if (h_errno == HOST_NOT_FOUND)
X				(void) printf("%s: unknown host\n", host);
X			else (void) fprintf(stderr, "%s: gethostbyname herror (%d):  ",
X				host, h_errno);
X			herror(NULL);
X#else
X			(void) printf("%s: unknown host\n", host);
X#endif
X			goto done;
X		}
X		hisctladdr.sin_family = hp->h_addrtype;
X		bcopy(hp->h_addr_list[0],
X		    (caddr_t)&hisctladdr.sin_addr, hp->h_length);
X		(void) Strncpy(hostname, hp->h_name);
X	}
X	s = socket(hisctladdr.sin_family, SOCK_STREAM, 0);
X	if (s < 0) {
X		Perror("socket");
X		goto done;
X	}
X	hisctladdr.sin_port = port;
X	while (connect(s, (struct sockaddr *) &hisctladdr, (int) sizeof (hisctladdr)) < 0) {
X		if (hp && hp->h_addr_list[1]) {
X			int oerrno = errno;
X
X			(void) fprintf(stderr, "NcFTP: connect error (%d) to address %s: ",
X				errno, inet_ntoa(hisctladdr.sin_addr));
X			errno = oerrno;
X			Perror((char *) 0);
X			hp->h_addr_list++;
X			bcopy(hp->h_addr_list[0],
X			     (caddr_t)&hisctladdr.sin_addr, hp->h_length);
X			(void) fprintf(stdout, "Trying %s...\n",
X				inet_ntoa(hisctladdr.sin_addr));
X			(void) close(s);
X			s = socket(hisctladdr.sin_family, SOCK_STREAM, 0);
X			if (s < 0) {
X				Perror("socket");
X				goto done;
X			}
X			continue;
X		}
X		Perror("connect");
X		switch (errno) {
X			case ENETDOWN:
X			case ENETUNREACH:
X			case ECONNABORTED:
X			case ETIMEDOUT:
X			case ECONNREFUSED:
X			case EHOSTDOWN:
X				hErr = -2;	/* we can re-try later. */
X		}
X		goto bad;
X	}
X	len = sizeof (myctladdr);
X	if (getsockname(s, (char *)&myctladdr, &len) < 0) {
X		Perror("getsockname");
X		goto bad;
X	}
X	cin = fdopen(s, "r");
X	cout = fdopen(s, "w");
X	if (cin == NULL || cout == NULL) {
X		(void) fprintf(stderr, "ftp: fdopen failed.\n");
X		close_streams(0);
X		goto bad;
X	}
X	if (IS_VVERBOSE)
X		(void) printf("Connected to %s.\n", hostname);
X	if (getreply(0) > 2) { 	/* read startup message from server */
X		close_streams(0);
X		goto bad;
X	}
X#ifdef SO_OOBINLINE
X	{
X	int on = 1;
X
X	if (setsockopt(s, SOL_SOCKET, SO_OOBINLINE, (char *) &on, sizeof(on))
X		< 0 && debug) {
X			Perror("setsockopt");
X		}
X	}
X#endif /* SO_OOBINLINE */
X
X	hErr = 0;
X	goto done;
X
Xbad:
X	(void) close(s);
Xdone:
X	code = hErr;
X	return (hErr);
X}	/* hookup */
X
X
X
X
Xint login(char *host, int openmode, int ignore_rc)
X{
X	string				tmp, str;
X	char				*username, *pass, *acct;
X	int					n, aflag = 0, prompted_login;
X	int					user_in_rc, tmpverbose;
X
X	username = pass = acct = NULL;
X	if (!ignore_rc) {
X		if ((ruserpass2(host, &username, &pass, &acct)) < 0) {
X			/*NOTREACHED */
X			code = -1;
X			return(0);
X		}
X	}
X
X	user_in_rc = 1;
X	prompted_login = 0;
X	if (username == NULL) {
X		user_in_rc = 0;
X		prompted_login = 1;
X	} 
X
X	if (!user_in_rc) {
X		/* There was no username in the rc. */
X		if (openmode == OPEN_A) {
X			username = "anonymous";
X			prompted_login = 0;
X		} else { /* openmode == OPEN_U */
X			/* Prompt for a username. */
X			(void) printf("Name (%s:%s): ", host, uinfo.username);
X			(void) FGets(tmp, stdin);
X			tmp[strlen(tmp) - 1] = '\0';
X			/*
X			 *	User can hit return if he wants to enter his username
X			 *	automatically.
X			 */
X			if (*tmp == '\0')
X				username = uinfo.username;
X			else
X				username = tmp;
X		}
X	}
X	(void) sprintf(str, "USER %s", username);
X	n = command(str);
X	if (n == CONTINUE) {
X		if (pass == NULL) {
X			if (strcmp("anonymous", username) == 0)
X				pass = anon_password;
X			else
X				pass = Getpass("Password:");
X		}
X		(void) sprintf(str, "PASS %s", pass);
X		n = command(str);
X	}
X	if (n == CONTINUE) {
X		aflag++;
X		acct = Getpass("Account:");
X		(void) sprintf(str, "ACCT %s", acct);
X		n = command(str);
X	}
X	if (n != COMPLETE) {
XnoLogin:
X		(void) fprintf(stderr, "Login failed.\n");
X		return (0);
X	}
X#ifdef SYSLOG
X	syslog (LOG_INFO, "%s connected to %s as %s.",
X		uinfo.username, host, username);
X#endif
X
X	if (!aflag && acct != NULL) {
X		(void) sprintf(str, "ACCT %s", acct);
X		(void) command(str);
X	}
X
X	/* See if remote host dropped connection. */
X	tmpverbose = verbose;
X	verbose = V_QUIET;
X	n = command("NOOP");
X	verbose = tmpverbose;
X	if (n == 4)
X		goto noLogin;
X
X	if (NOT_VQUIET && !prompted_login)
X		(void) printf("Logged into %s.\n", host);
X	if (!ignore_rc)
X		for (n = 0; n < macnum; ++n) {
X			if (!strcmp("init", macros[n].mac_name)) {
X				(void) strcpy(line, "$init");
X				makeargv();
X				domacro(margc, margv);
X				break;
X			}
X		}
X	return (1);
X}	/* login */
X
X
X
X/*ARGSUSED*/
Xvoid cmdabort(int unused)
X{
X	(void) printf("\n");
X	(void) fflush(stdout);
X	abrtflag++;
X}	/* cmdabort */
X
X
X
X
Xcommand(char *cmd)
X{
X	int r;
X	void (*oldintr)(int);
X	string str;
X
X	abrtflag = 0;
X	if (debug) {
X		(void) printf("---> \"%s\" (length %lu)\n", cmd, strlen(cmd));
X	}
X	if (cout == NULL) {
X		(void) sprintf(str, "%s: No control connection for command", cmd);
X		Perror(str);
X		code = -1;
X		return (0);
X	}
X	oldintr = signal(SIGINT, /* cmdabort */ SIG_IGN);
X#ifndef SCO324
X	if (cout != NULL)
X		(void) fprintf(cout, "%s\r\n", cmd);
X#else
X	{
X		/*
X		 * The fprintf() above gives me a core-dump in memcpy()...
X		 * This does the trick though...
X		 */
X
X		char *p = cmd;
X		while (*p)
X			fputc(*p++, cout);
X		fputc('\r', cout);
X		fputc('\n', cout);
X	}
X#endif /* !SCO324 */
X	(void) fflush(cout);
X	cpend = 1;
X	r = getreply(strcmp(cmd, "QUIT") == 0);
X	if (abrtflag && oldintr != SIG_IGN && oldintr != NULL)
X		(*oldintr)(0);
X	(void) signal(SIGINT, oldintr);
X	return(r);
X}	/* command */
X
X
X
X
Xgetreply(int expecteof)
X{
X	register int c, n;
X	int dig;
X	char *cp, *end, *dp;
X	int thiscode, originalcode = 0, continuation = 0;
X	void (*oldintr)(int);
X
X	if (cin == NULL)
X		return (-1);
X	oldintr = signal(SIGINT, /* cmdabort */ SIG_IGN);
X	end = reply_string + RECEIVEDLINELEN - 2;
X	for (;;) {
X		dig = n = code = 0;
X		cp = reply_string;
X		for (;;) {
X			c = getc(cin);
X			if (c == IAC) {     /* handle telnet commands */
X				switch (c = getc(cin)) {
X				case WILL:
X				case WONT:
X					c = getc(cin);
X					(void) fprintf(cout, "%c%c%c",IAC,DONT,c);
X					(void) fflush(cout);
X					break;
X				case DO:
X				case DONT:
X					c = getc(cin);
X					(void) fprintf(cout, "%c%c%c",IAC,WONT,c);
X					(void) fflush(cout);
X					break;
X				default:
X					break;
X				}
X				continue;
X			}
X			dig++;
X			if (c == EOF) {
X				if (expecteof) {
X					(void) signal(SIGINT,oldintr);
X					code = 221;
X					return (0);
X				}
X				lostpeer(0);
X				if (NOT_VQUIET) {
X					(void) printf("421 Service not available, remote server has closed connection\n");
X					(void) fflush(stdout);
X				}
X				code = 421;
X				return(4);
X			}
X			if (cp < end && c != '\r')
X				*cp++ = c;
X
X			if (c == '\n')
X				break;
X			if (dig < 4 && isdigit(c))
X				code = thiscode = code * 10 + (c - '0');
X			else if (dig == 4 && c == '-') {
X				if (continuation)
X					code = 0;
X				continuation++;
X			}
X			if (n == 0)
X				n = c;
X		}	/* end for(;;) #2 */
X		
X		*cp = '\0';
X		switch (verbose) {
X			case V_QUIET:
X				/* Don't print anything. */
X				break;
X			case V_ERRS:
X				if (n == '5') {
X					dp = reply_string;
X					goto stripCode;
X				}
X				break;	
X			case V_IMPLICITCD:
X			case V_TERSE:
X				dp = NULL;
X				if (n == '5' && verbose == V_TERSE)
X					dp = reply_string;
X				else {
X					switch (thiscode) {
X						case 230:
X						case 214:
X						case 332:
X							dp = reply_string;
X							break;
X						case 220:
X							/*
X							 * Skip the foo FTP server ready line.
X							 */
X							if (strstr(reply_string, "ready.") == NULL)
X								dp = reply_string;
X							break;
X						case 250:
X							/*
X							 * Print 250 lines if they aren't
X							 * "250 CWD command successful."
X							 */
X							if (strncmp(reply_string + 4, "CWD ", (size_t) 4))
X								dp = reply_string;
X					}
X				}
X				if (dp == NULL) break;			
XstripCode:
X				/* Try to strip out the code numbers, etc. */
X				if (isdigit(*dp++) && isdigit(*dp++) && isdigit(*dp++)) {
X					if (*dp == ' ' || *dp == '-') {
X						dp++;
X						if (*dp == ' ') dp++;
X					} else dp = reply_string;			
X				} else {
X					int spaces;
X					dp = reply_string;
X					for (spaces = 0; spaces < 4; ++spaces)
X						if (dp[spaces] != ' ')
X							break;
X					if (spaces == 4)
X						dp += spaces;
X				}					
X				goto printLine;
X			case V_VERBOSE:
X				dp = reply_string;
XprintLine:		(void) fputs(dp, stdout);
X		}	/* end switch */
X
X		if (continuation && code != originalcode) {
X			if (originalcode == 0)
X				originalcode = code;
X			continue;
X		}
X		if (n != '1')
X			cpend = 0;
X		(void) signal(SIGINT,oldintr);
X		if (code == 421 || originalcode == 421)
X			lostpeer(0);
X		if (abrtflag && oldintr != cmdabort && oldintr != SIG_IGN && oldintr)
X			(*oldintr)(0);
X		return (n - '0');
X	}	/* end for(;;) #1 */
X}	/* getreply */
X
X
X
X
Xstatic int empty(struct fd_set *mask, int sec)
X{
X	struct timeval t;
X
X	t.tv_sec = (long) sec;
X	t.tv_usec = 0;
X
X	return(select(32, mask, NULL, NULL, &t));
X}	/* empty */
X
X
X
X
Xstatic void tvsub(struct timeval *tdiff, struct timeval *t1, struct timeval *t0)
X{
X	tdiff->tv_sec = t1->tv_sec - t0->tv_sec;
X	tdiff->tv_usec = t1->tv_usec - t0->tv_usec;
X	if (tdiff->tv_usec < 0)
X		tdiff->tv_sec--, tdiff->tv_usec += 1000000;
X}	/* tvsub */
X
X
X
Xstatic int barlen;
X
Xint start_progress(int sending, char *local)
X{
X	long s;
X	str32 spec;
X
X	cur_progress_meter = progress_meter;
X	if ((cur_progress_meter > pr_kbytes) || (cur_progress_meter < 0))
X		cur_progress_meter = pr_percent;
X	if ((file_size <= 0) && ((cur_progress_meter == pr_percent) || (cur_progress_meter == pr_philbar)))
X		cur_progress_meter = pr_kbytes;
X	if (!ansi_escapes && (cur_progress_meter == pr_philbar))
X		cur_progress_meter = pr_none;
X
X	(void) gettimeofday(&start, (struct timezone *)0);
X	now_sec = start.tv_sec;
X
X	switch (cur_progress_meter) {
X		case pr_none:
X			break;
X		case pr_percent:
X			(void) printf("%s:     ", local);
X			goto zz;
X		case pr_kbytes:
X			(void) printf("%s:       ", local);
X			goto zz;
X		case pr_philbar:
X			printf("%s%s file: %s %s\n", 
X				tcap_boldface,
X				sending ? "Sending" : "Receiving",
X				local,
X				tcap_normal
X			);
X			barlen = 64;
X			for (s = file_size; s > 0; s /= 10L) barlen--;
X			(void) sprintf(spec, "      0 %%%ds %%ld bytes.\r", barlen);
X			printf(spec, " ", file_size);
X		zz:
X			(void) fflush(stdout);
X			echo(stdin, 0);
X	}	/* end switch */
X	return (cur_progress_meter);
X}	/* start_progress */
X
X
X
X
Xvoid progress_report(int finish_up)
X{
X	int i;
X	int size;
X	str32 spec;
X
X	next_report += xferbufsize;
X	(void) gettimeofday(&stop, (struct timezone *)0);
X	if ((stop.tv_sec > now_sec) || finish_up) {
X		switch (cur_progress_meter) {
X			case pr_none:
X				break;
X			case pr_percent:
X				(void) printf("\b\b\b\b%3ld%%", 100L * bytes / file_size);
X				(void) fflush(stdout);
X				break;
X			case pr_philbar:
X				size = (int) ((float)barlen * ((float) bytes/file_size));
X				(void) sprintf(spec, "%%3ld%%%%  0 %%s%%%ds%%s\r", size);
X				(void) printf(
X					spec,
X					100L * bytes / file_size,
X					tcap_reverse,
X					" ",
X					tcap_normal
X				);
X				(void) fflush(stdout);
X				break;
X			case pr_kbytes:
X				if ((bytes / 1024) > 0) {
X					(void) printf("\b\b\b\b\b\b%5ldK", bytes / 1024);
X					(void) fflush(stdout);
X				}
X		}	/* end switch */
X		now_sec = stop.tv_sec;
X	}	/* end if we updated */
X}	/* progress_report */
X
X
X
X
Xvoid end_progress(char *direction, char *local, char *remote)
X{
X    struct timeval			td;
X    float					s, bs;
X    char					*cp, *bsstr;
X	string					str;
X
X	if (bytes <= 0)
X		return;
X	progress_report(1);		/* tell progress proc to cleanup. */
X
X	tvsub(&td, &stop, &start);
X	s = td.tv_sec + (td.tv_usec / 1000000.0);
X	if (s != 0.0)
X		bs = bytes / s;
X	if (bs > 1024.0) {
X		bs /= 1024.0;
X		bsstr = "K/s.\n";
X	} else
X		bsstr = "Bytes/s.\n";
X
X	if (NOT_VQUIET) switch(cur_progress_meter) {
X		case pr_none:
X			(void) printf("%s: %ld bytes %s in %.2f seconds, %.2f %s", local, bytes, direction, s, bs, bsstr);
X			break;
X		case pr_kbytes:
X		case pr_percent:
X			(void) printf("%s%ld bytes %s in %.2f seconds, %.2f %s",
X			cur_progress_meter == pr_kbytes ? "\b\b\b\b\b\b" : "\b\b\b\b",
X			bytes, direction, s, bs, bsstr);
X			echo(stdin, 1);
X			break;
X		case pr_philbar:
X			printf("\n");
X			echo(stdin, 1);
X			break;
X	}
X	
X	/* Save transfers to the logfile. */
X    if (logf != NULL) {
X		/* if a simple path is given, try to log the full path */
X		if (rindex(remote, '/') == NULL && cwd != NULL) {
X			(void) sprintf(str, "%s/%s", cwd, remote);
X			 cp = str;
X		} else
X			cp = remote;
X		(void) fprintf(logf, "\t-> \"%s\" %s, %.2f %s", cp, direction, bs, bsstr);
X    } 
X#ifdef SYSLOG
X	if (direction[0] == 'r')
X		syslog (LOG_INFO, "%s %s %s as %s from %s (%ld bytes).",
X			uinfo.username, direction, remote, local, hostname, bytes);
X	else
X		syslog (LOG_INFO, "%s %s %s as %s to %s (%ld bytes).",
X			uinfo.username, direction, local, remote, hostname, bytes);
X#endif
X}   /* end_progress */
X
X
X
Xvoid close_file(FILE **fin, int filetype)
X{
X	if (*fin != NULL) {
X		if (filetype == IS_FILE) {
X			(void) fclose(*fin);
X			*fin = NULL;
X		} else if (filetype == IS_PIPE) {
X			(void) pclose(*fin);
X			*fin = NULL;
X		}
X	}
X}	/* close_file */
X
X
X
X
X/*ARGSUSED*/
Xvoid abortsend(int unused)
X{
X	activemcmd = 0;
X	abrtflag = 0;
X	(void) printf("\nSend aborted.\n");
X	(void) fflush(stdout);
X	longjmp(sendabort, 1);
X}	/* abortsend */
X
X
X
Xvoid sendrequest(char *cmd, char *local, char *remote)
X{
X	FILE					*fin, *dout = NULL;
X	void					(*oldintr)(int), (*oldintp)(int);
X	string					str;
X	register int			c, d;
X	struct stat				st;
X	int						filetype;
X	int						do_reports = 0;
X	char					*mode;
X	register char			*bufp;
X
X	oldintr = NULL;
X	oldintp = NULL;
X	mode = "w";
X	bytes = file_size = 0L;
X	if (setjmp(sendabort)) {
X		while (cpend) {
X			(void) getreply(0);
X		}
X		if (data >= 0) {
X			(void) close(data);
X			data = -1;
X		}
X		if (oldintr)
X			(void) signal(SIGINT,oldintr);
X		if (oldintp)
X			(void) signal(SIGPIPE,oldintp);
X		code = -1;
X		echo(stdin, 1);
X		return;
X	}
X	oldintr = signal(SIGINT, abortsend);
X	file_size = -1;
X	if (strcmp(local, "-") == 0)  {
X		fin = stdin;
X		filetype = IS_STREAM;
X	} else if (*local == '|') {
X		filetype = IS_PIPE;
X		oldintp = signal(SIGPIPE,SIG_IGN);
X		fin = popen(local + 1, "r");
X		if (fin == NULL) {
X			Perror(local + 1);
X			(void) signal(SIGINT, oldintr);
X			(void) signal(SIGPIPE, oldintp);
X			code = -1;
X			return;
X		}
X	} else {
X		filetype = IS_FILE;
X		fin = fopen(local, "r");
X		if (fin == NULL) {
X			Perror(local);
X			(void) signal(SIGINT, oldintr);
X			code = -1;
X			return;
X		}
X		if (fstat(fileno(fin), &st) < 0 ||
X		    (st.st_mode&S_IFMT) != S_IFREG) {
X			(void) fprintf(stdout, "%s: not a plain file.\n", local);
X			(void) signal(SIGINT, oldintr);
X			(void) fclose(fin);
X			code = -1;
X			return;
X		}
X		file_size = st.st_size;
X	}
X	if (initconn()) {
X		(void) signal(SIGINT, oldintr);
X		if (oldintp)
X			(void) signal(SIGPIPE, oldintp);
X		code = -1;
X		close_file(&fin, filetype);
X		return;
X	}
X	if (setjmp(sendabort))
X		goto Abort;
X
X	if (remote) {
X		(void) sprintf(str, "%s %s", cmd, remote);
X		if (command(str) != PRELIM) {
X			(void) signal(SIGINT, oldintr);
X			if (oldintp)
X				(void) signal(SIGPIPE, oldintp);
X			close_file(&fin, filetype);
X			return;
X		}
X	} else
X		if (command(cmd) != PRELIM) {
X			(void) signal(SIGINT, oldintr);
X			if (oldintp)
X				(void) signal(SIGPIPE, oldintp);
X			close_file(&fin, filetype);
X			return;
X		}
X	dout = dataconn(mode);
X	if (dout == NULL)
X		goto Abort;
X	(void) gettimeofday(&start, (struct timezone *)0);
X	oldintp = signal(SIGPIPE, SIG_IGN);
X	if (do_reports = (filetype == IS_FILE && NOT_VQUIET))
X		do_reports = start_progress(1, local);
X
X	switch (curtype) {
X
X	case TYPE_I:
X	case TYPE_L:
X		errno = d = 0;
X		while ((c = read(fileno(fin), xferbuf, (int)xferbufsize)) > 0) {
X			bytes += c;
X			for (bufp = xferbuf; c > 0; c -= d, bufp += d)
X				if ((d = write(fileno(dout), bufp, c)) <= 0)
X					break;
X			/* Print progress indicator. */
X			if (do_reports)
X				progress_report(0);
X		}
X		if (c < 0)
X			Perror(local);
X		if (d <= 0) {
X			if (d == 0 && !creating)
X				(void) fprintf(stderr, "netout: write returned 0?\n");
X			else if (errno != EPIPE) 
X				Perror("netout");
X			bytes = -1;
X		}
X		break;
X
X	case TYPE_A:
X		next_report = xferbufsize;
X		while ((c = getc(fin)) != EOF) {
X			if (c == '\n') {
X				if (ferror(dout))
X					break;
X				(void) putc('\r', dout);
X				bytes++;
X			}
X			(void) putc(c, dout);
X			bytes++;
X
X			/* Print progress indicator. */
X			if (do_reports && bytes > next_report)
X				progress_report(0);
X		}
X		if (ferror(fin))
X			Perror(local);
X		if (ferror(dout)) {
X			if (errno != EPIPE)
X				Perror("netout");
X			bytes = -1;
X		}
X		break;
X	}
XDone:
X	close_file(&fin, filetype);
X	if (dout)
X		(void) fclose(dout);
X	(void) getreply(0);
X	(void) signal(SIGINT, oldintr);
X	if (oldintp)
X		(void) signal(SIGPIPE, oldintp);
X	end_progress("sent", local, remote);
X	return;
XAbort:
X	code = -1;
X	echo(stdin, 1);
X	if (!cpend)
X		return;
X	if (data >= 0) {
X		(void) close(data);
X		data = -1;
X	}
X	goto Done;
X}	/* sendrequest */
X
X
X
Xlong get_remote_size(char *remote, int filetype)
X{
X	int oldverbose;
X	long rmt_size;
X	string str;
X
X	rmt_size = -1;				/*
X								 * Return -1 if we could't get it. 
X								 * Not all sites support SIZE.
X								 */
X	
X	if (filetype == IS_FILE) {
X		/* Won't make sense for a pipe or stream. */
X		(void) sprintf(str, "SIZE %s", remote);
X		*reply_string = 0;
X		oldverbose = verbose;
X		verbose = V_QUIET;
X		(void) command(str);
X		verbose = oldverbose;
X		if (*reply_string != 5)		/* 5xx is an error. */
X			(void) sscanf(reply_string, "%*d %ld", &rmt_size);	
X	}
X	return rmt_size;
X}	/* get_remote_size */
X
X
X
X/*ARGSUSED*/
Xvoid abortrecv(int unused)
X{
X	activemcmd = 0;
X	abrtflag = 0;
X	(void) printf("(abort)\n");
X	(void) fflush(stdout);
X	longjmp(recvabort, 1);
X}	/* abortrecv */
X
X
X
Xvoid recvrequest(char *cmd, char *local, char *remote, char *mode)
X{
X	FILE						*fout, *din;
X	void						(*oldintr)(int), (*oldintp)(int); 
X	int							oldverbose, oldtype = 0, is_retr;
X	int							tcrflag, nfnd;
X	char						msg;
X	string						str;
X	struct fd_set				mask;
X	int							c, d;
X	int							filetype, do_reports = 0;
X	string						remote_dir;
X	char						*cp;
X#ifdef REDIR
X	char						*linePtr;
X	int							nchars;
X	string						str2;
X#endif
X
X	bytes = 0;
X	is_retr = strcmp(cmd, "RETR") == 0;
X	oldintr = NULL;
X	oldintp = NULL;
X	tcrflag = /* !crflag && */ is_retr;
X
X	/*
X	 * The ls() function can specify a directory to list along with ls flags,
X	 * if it sends the flags first followed by the directory name.
X	 *
X	 * So far, we don't care about the remote directory being listed.  I put
X	 * it now so I won't forget in case I need to do something with it later.
X	 */
X	remote_dir[0] = 0;
X	if (remote != NULL) {
X		cp = index(remote, LS_FLAGS_AND_FILE);
X		if (cp == NULL)
X			(void) Strncpy(remote_dir, remote);
X		else {
X			*cp++ = ' ';
X			(void) Strncpy(remote_dir, cp);
X		}
X	}
X
X	if (setjmp(recvabort)) {
X		echo(stdin, 1);
X		while (cpend) {
X			(void) getreply(0);
X		}
X		if (data >= 0) {
X			(void) close(data);
X			data = -1;
X		}
X		if (oldintr)
X			(void) signal(SIGINT, oldintr);
X		code = -1;
X		return;
X	}
X	oldintr = signal(SIGINT, abortrecv);
X
X	if (strcmp(local, "-") == 0)
X		filetype = IS_STREAM;
X	else if (*local == '|')
X		filetype = IS_PIPE;
X	else {
X		filetype = IS_FILE;  /* is_retr ? IS_FILE : IS_STREAM; */
X		if (access(local, 2) < 0) {
X			char *dir = rindex(local, '/');
X
X			if (errno != ENOENT && errno != EACCES) {
X				Perror(local);
X				(void) signal(SIGINT, oldintr);
X				code = -1;
X				return;
X			}
X			/* See if we have write permission on this directory. */
X			if (dir != NULL) {
X				/* Special case: /filename. */
X				if (dir != local)
X					*dir = 0;
X				if (access(dir == local ? "/" : local, 2) < 0) {
X					/*
X					 *	We have a big long pathname, like /a/b/c/d,
X					 *	but see if we can write into the current
X					 *	directory and call the file ./d.
X					 */
X					if (access(".", 2) < 0) {
X						(void) strcpy(local, " and .");
X						goto noaccess;
X					}
X					(void) strcpy(local, dir + 1);	/* use simple filename. */
X				} else
X					*dir = '/';
X			} else {
X				/* We have a simple path name (file name only). */
X				if (access(".", 2) < 0) {
Xnoaccess:			Perror(local);
X					(void) signal(SIGINT, oldintr);
X					code = -1;
X					return;
X				}
X			}
X		}
X	}
X	if (initconn()) {
X		(void) signal(SIGINT, oldintr);
X		code = -1;
X		return;
X	}
X	if (!is_retr) {
X		if (curtype != TYPE_A) {
X			oldtype = curtype;
X			oldverbose = verbose;
X			if (!debug)
X				verbose = V_QUIET;
X			setascii(0, NULL);
X			verbose = oldverbose;
X		}
X	}
X
X	file_size = -1;
X	if (remote) {
X		file_size = get_remote_size(remote, filetype);
X		(void) sprintf(str, "%s %s", cmd, remote);
X		if (command(str) != PRELIM) 
X			goto nevrmind;
X	} else {
X		if (command(cmd) != PRELIM) {
Xnevrmind:	(void) signal(SIGINT, oldintr);
X			if (oldtype) {
X				if (!debug)
X					verbose = V_QUIET;
X				if (oldtype == TYPE_I)
X					setbinary(0, NULL);
X				verbose = oldverbose;
X			}
X			return;
X		}
X	}
X	din = dataconn("r");
X	if (din == NULL)
X		goto Abort;
X	if (filetype == IS_STREAM) {
X		fout = stdout;
X	} else if (filetype == IS_PIPE) {
X		oldintp = signal(SIGPIPE, SIG_IGN);
X		fout = popen(local + 1, "w");
X		if (fout == NULL) {
X			Perror(local+1);
X			goto Abort;
X		}
X	} else {
X		fout = fopen(local, mode);
X		if (fout == NULL) {
X			Perror(local);
X			goto Abort;
X		}
X	}
X	do_reports = NOT_VQUIET && is_retr && filetype == IS_FILE;
X	if (do_reports)
X		do_reports = start_progress(0, local);
X
X	if (setjmp(recvabort))
X		goto Abort;
X
X	switch (curtype) {
X
X	case TYPE_I:
X	case TYPE_L:
X		errno = d = 0;
X		while ((c = read(fileno(din), xferbuf, (int)xferbufsize)) > 0) {
X			if ((d = write(fileno(fout), xferbuf, c)) != c)
X				break;
X			bytes += c;
X
X			/* Print progress indicator. */
X			if (do_reports)
X				progress_report(0);
X		}
X		if (c < 0) {
X			if (errno != EPIPE)
X				Perror("netin");
X			bytes = -1;
X		}
X		if (d < c) {
X			if (d < 0) {
X				if (errno != EPIPE)
X					Perror(local);
X			} else
X				(void) fprintf(stderr, "%s: short write\n", local);
X		}
X		break;
X
X	case TYPE_A:
X#ifdef REDIR
X		nchars = 0;
X		linePtr = str2;
X#endif
X		next_report = xferbufsize;
X		while ((c = getc(din)) != EOF) {
X			while (c == '\r') {
X				bytes++;
X				if ((c = getc(din)) != '\n' || tcrflag) {
X					if (ferror(fout))
X						goto break2;
X					(void) putc('\r', fout);
X					if (c == '\0') {
X						bytes++;
X						goto contin2;
X					}
X					if (c == EOF)
X						goto contin2;
X				}
X			}
X			(void) putc(c, fout);
X			bytes++;
X			
X			/* Print progress indicator. */
X			if (do_reports && bytes > next_report)
X				progress_report(0);
X#ifdef REDIR
X			if (nchars < sizeof(str2) - 1) {		/* No seg violations, please */
X         		*linePtr++ = c;  /* build redir string */
X         		nchars++;
X         	}
X#endif
X   contin2:
X#ifdef REDIR
X			/* Save the input line in the buffer for recall later. */
X	         if (c=='\n' && is_ls) {
X	            register struct lslist *new;
X	
X				*--linePtr = '\0';
X				nchars--;
X				new = (struct lslist *) malloc((size_t) sizeof(struct lslist));
X				if (new != NULL) {
X					if (new->string = malloc(strlen(str2) + 1))
X						(void) strcpy(new->string, str2);
X		   			new->next = NULL;
X	   				if (lshead == NULL)
X	   					lshead = lstail = new;
X	  				else {
X	  					lstail->next = new;
X	  					lstail = new;
X			      	}
X		      	}
X		      	/* reset line buffer */
X				linePtr = str2;
X				nchars = 0;
X			}	/* ls mode & last char is a newline */
X#else
X			;
X#endif
X		}	/* while ((c = getc(din)) != EOF) */
Xbreak2:
X		if (ferror(din)) {
X			if (errno != EPIPE)
X				Perror("netin");
X			bytes = -1;
X		}
X		if (ferror(fout)) {
X			if (errno != EPIPE)
X				Perror(local);
X		}
X		break;
X	}	/* end switch (curtype) */
X	
X	close_file(&fout, filetype);
X	(void) signal(SIGINT, oldintr);
X	if (oldintp)
X		(void) signal(SIGPIPE, oldintp);
X	if (din)
X		(void) fclose(din);
X	(void) getreply(0);
X	if (bytes > 0 && is_retr && filetype == IS_FILE)
X		end_progress("received", local, remote);
X	if (oldtype) {
X		if (!debug)
X			verbose = V_QUIET;
X			if (oldtype == TYPE_I)
X				setbinary(0, NULL);
X		verbose = oldverbose;
X	}
X	return;
XAbort:
X	echo(stdin, 1);
X
X/* Abort using RFC959 recommended IP,SYNC sequence  */
X
X	if (oldintp)
X		(void) signal(SIGPIPE, oldintr);
X	(void) signal(SIGINT,SIG_IGN);
X	if (oldtype) {
X		if (!debug)
X			verbose = V_QUIET;
X			if (oldtype == TYPE_I)
X				setbinary(0, NULL);
X		verbose = oldverbose;
X	}
X	if (!cpend) {
X		code = -1;
X		(void) signal(SIGINT,oldintr);
X		return;
X	}
X
X	if (!cout) return;
X	(void) fprintf(cout,"%c%c",IAC,IP);
X	(void) fflush(cout); 
X	msg = IAC;
X/* send IAC in urgent mode instead of DM because UNIX places oob mark */
X/* after urgent byte rather than before as now is protocol            */
X	if (send(fileno(cout),&msg,1,MSG_OOB) != 1) {
X		Perror("abort");
X	}
X	(void) fprintf(cout,"%cABOR\r\n",DM);
X	(void) fflush(cout);
X	FD_ZERO(&mask);
X	FD_SET(fileno(cin), &mask);
X	if (din) { 
X		FD_SET(fileno(din), &mask);
X	}
X	if ((nfnd = empty(&mask,10)) <= 0) {
X		if (nfnd < 0) {
X			Perror("abort");
X		}
X		code = -1;
X		lostpeer(0);
X	}
X	if (din && FD_ISSET(fileno(din), &mask)) {
X		while ((c = read(fileno(din), xferbuf, xferbufsize)) > 0)
X			;
X	}
X	if ((c = getreply(0)) == ERROR && code == 552) { /* needed for nic style abort */
X		if (data >= 0) {
X			(void) close(data);
X			data = -1;
X		}
X		(void) getreply(0);
X	}
X	(void) getreply(0);
X	code = -1;
X	if (data >= 0) {
X		(void) close(data);
X		data = -1;
X	}
X	close_file(&fout, filetype);
X	if (din)
X		(void) fclose(din);
X	end_progress("received", local, remote);
X	(void) signal(SIGINT,oldintr);
X}	/* recvrequest */
X
X
X
X
X/*
X * Need to start a listen on the data channel
X * before we send the command, otherwise the
X * server's connect may fail.
X */
X
Xinitconn(void)
X{
X	register char		*p, *a;
X	int					result, len, tmpno = 0;
X	int					on = 1, rval;
X	string				str;
X	void				(*oldintr)(int);
X
X	oldintr = signal(SIGINT, SIG_IGN);
Xnoport:
X	data_addr = myctladdr;
X	if (sendport)
X		data_addr.sin_port = 0;	/* let system pick one */ 
X	if (data != -1)
X		(void) close (data);
X	data = socket(AF_INET, SOCK_STREAM, 0);
X	if (data < 0) {
X		Perror("socket");
X		if (tmpno)
X			sendport = 1;
X		rval = 1;  goto Return;
X	}
X	if (!sendport)
X		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
X			Perror("setsockopt (reuse address)");
X			goto bad;
X		}
X	if (bind(data, (struct sockaddr *)&data_addr, sizeof (data_addr)) < 0) {
X		Perror("bind");
X		goto bad;
X	}
X	if (options & SO_DEBUG &&
X	    setsockopt(data, SOL_SOCKET, SO_DEBUG, (char *)&on, sizeof (on)) < 0)
X		Perror("setsockopt (ignored)");
X	len = sizeof (data_addr);
X	if (getsockname(data, (char *)&data_addr, &len) < 0) {
X		Perror("getsockname");
X		goto bad;
X	}
X	if (listen(data, 1) < 0)
X		Perror("listen");
X	if (sendport) {
X		a = (char *)&data_addr.sin_addr;
X		p = (char *)&data_addr.sin_port;
X#define UC(x) (int) (((int) x) & 0xff)
X		(void) sprintf(str, "PORT %d,%d,%d,%d,%d,%d",
X			UC(a[0]), UC(a[1]), UC(a[2]), UC(a[3]), UC(p[0]), UC(p[1]));
X        result = command(str);
X		if (result == ERROR && sendport == -1) {
X			sendport = 0;
X			tmpno = 1;
X			goto noport;
X		}
X		rval = (result != COMPLETE);  goto Return;
X	}
X	if (tmpno)
X		sendport = 1;
X	rval = 0;  goto Return;
Xbad:
X	(void) close(data), data = -1;
X	if (tmpno)
X		sendport = 1;
X	rval = 1;
XReturn:
X	(void) signal(SIGINT, oldintr);
X	return (rval);
X}	/* initconn */
X
X
X
X
XFILE *
Xdataconn(char *mode)
X{
X	struct sockaddr_in from;
X	FILE *fp;
X	int s, fromlen = sizeof (from);
X
X	s = accept(data, (struct sockaddr *) &from, &fromlen);
X	if (s < 0) {
X		Perror("accept");
X		(void) close(data), data = -1;
X		fp = NULL;
X	} else {
X		(void) close(data);
X		data = s;
X		fp = fdopen(data, mode);
X	}
X	return (fp);
X}	/* dataconn */
X
X/* eof ftp.c */
END_OF_FILE
  if test 29938 -ne `wc -c <'ftp.c'`; then
    echo shar: \"'ftp.c'\" unpacked with wrong size!
  fi
  # end of 'ftp.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(19081 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* main.c */
X
X#define _main_c_
X
X#include "sys.h"
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <sys/stat.h>
X#include <sys/time.h>
X#include <arpa/ftp.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <string.h>
X#include <errno.h>
X#include <ctype.h>
X#include <netdb.h>
X#include <pwd.h>
X
X#ifdef SYSLOG
X#	include <syslog.h>
X#endif
X
X#ifndef NO_UNISTDH
X#	include <unistd.h>
X#endif
X
X#ifdef CURSES
X#	undef HZ		/* Collides with HaZeltine ! */
X#	include <curses.h>
X#endif	/* CURSES */
X
X#include "ftpdefs.h"
X#include "defaults.h"
X#include "cmds.h"
X#include "main.h"
X#include "ftp.h"
X#include "ftprc.h"
X#include "copyright.h"
X
X/* main.c globals */
Xint					slrflag;
Xint					fromatty;			/* input is from a terminal */
Xchar				*altarg;			/* argv[1] with no shell-like preprocessing  */
Xstruct	servent		*sp;				/* service spec for tcp/ftp */
Xjmp_buf				toplevel;			/* non-local goto stuff for cmd scanner */
Xchar				*line;				/* input line buffer */
Xchar				*stringbase;		/* current scan point in line buffer */
Xchar				*argbuf;			/* argument storage buffer */
Xchar				*argbase;			/* current storage point in arg buffer */
Xint					margc;				/* count of arguments on input line */
Xchar				*margv[20];			/* args parsed from input line */
Xstruct userinfo		uinfo;				/* a copy of their pwent really */
Xint					ansi_escapes;		/* for fancy graphics */
Xint					ignore_rc;			/* are we supposed to ignore the netrc */
Xstring				progname;			/* simple filename */
Xstring				prompt, prompt2;	/* shell prompt string */
Xstring				anon_password;		/* most likely your email address */
Xstring				pager;				/* program to browse text files */
Xstring				version = FTP_VERSION;
Xlong				eventnumber;		/* number of commands we've done */
XFILE				*logf = NULL;		/* log user activity */
Xstring				logfname;			/* name of the logfile */
Xlong				logsize = 4096L;	/* max log size. 0 == no limit */
Xint					percent_flags;		/* "%" in prompt string? */
Xint					at_flags;			/* "@" in prompt string? */
Xstring 				mail_path;			/* your mailbox */
Xint					newmail;			/* how many new letters you have */
Xtime_t				mbox_time;			/* last modified time of mbox */
X
Xchar				*tcap_normal = "\033[0m";	/* Default ANSI escapes */
Xchar				*tcap_boldface = "\033[1m";
Xchar				*tcap_underline = "\033[4m";
Xchar				*tcap_reverse = "\033[7m";
X
X#ifdef CURSES
Xstatic char			tcbuf[2048];
X#endif
X
X/* main.c externs */
Xextern int			debug, verbose, mprompt;
Xextern int			options, cpend, data, connected;
Xextern int			curtype, macnum;
Xextern FILE			*cout;
Xextern struct cmd	cmdtab[];
Xextern str32		curtypename;
Xextern char			*macbuf;
Xextern char			*reply_string;
Xextern string		hostname, cwd, lcwd;
Xextern int			Optind;
Xextern char			*Optarg;
X
Xmain(int argc, char **argv)
X{
X	register char		*cp;
X	int					top, opt, openopts = 0;
X	string				tmp, oline;	
X
X	if ((cp = rindex(argv[0], '/'))) cp++;
X	else cp = argv[0];
X	(void) Strncpy(progname, cp);
X	
X	sp = getservbyname("ftp", "tcp");
X	if (sp == 0) fatal("ftp/tcp: unknown service");
X
X	if (init_arrays())			/* Reserve large blocks of memory now */
X		fatal("could not reserve large amounts of memory.");
X
X	/*
X	 * Set up defaults for FTP.
X	 */
X	mprompt = dMPROMPT;
X	verbose = dVERBOSE;
X	debug = dDEBUG;
X
X	(void) Strncpy(curtypename, dTYPESTR);
X	curtype = dTYPE;
X	(void) Strncpy(prompt, dPROMPT);
X	
X	/*	Setup our pager variable, before we run through the rc,
X		which may change it. */
X	set_pager(getenv("PAGER"), 0);
X#ifdef CURSES
X	ansi_escapes = 1;
X#else
X	ansi_escapes = 0;
X	if ((cp = getenv("TERM")) != NULL) {
X		if ((*cp == 'v' && cp[1] == 't')		/* vt100, vt102, ... */
X			|| (strcmp(cp, "xterm") == 0))
X			ansi_escapes = 1;
X	}
X#endif
X	(void) getuserinfo();
X	newmail = 0;
X	(void) time(&mbox_time);
X	(void) Strncpy(anon_password, uinfo.username);
X	if (getlocalhostname(uinfo.hostname, sizeof(uinfo.hostname)) == 0) {
X		(void) Strncat(anon_password, "@");
X		(void) Strncat(anon_password, uinfo.hostname);
X	}
X#if dLOGGING
X	(void) sprintf(logfname, "%s/%s", uinfo.homedir, dLOGNAME);
X#else
X	*logfname = 0;
X#endif
X	(void) get_cwd(lcwd, (int) sizeof(lcwd));
X
X#ifdef SYSLOG
X#	ifdef LOG_LOCAL3
X	openlog ("NcFTP", LOG_PID, LOG_LOCAL3);
X#	else
X	openlog ("NcFTP", LOG_PID);
X#	endif
X#endif				/* SYSLOG */
X
X
X	ignore_rc = 0;
X	(void) strcpy(oline, "open ");
X	while ((opt = Getopt(argc, argv, "DVINRHaiup:rd:g:")) >= 0) {
X		switch(opt) {
X			case 'a':
X			case 'i':
X			case 'u':
X			case 'r':
X				(void) sprintf(tmp, "-%c ", opt);
X				goto cattmp;
X
X			case 'p':
X			case 'd':
X			case 'g':
X				(void) sprintf(tmp, "-%c %s ", opt, Optarg);
X			cattmp:
X				(void) strcat(oline, tmp);
X				openopts++;
X				break;
X
X			case 'D':
X				/* options |= SO_DEBUG; done below... */
X				debug++;
X				break;
X			
X			case 'V':
X				verbose++;
X				break;
X
X			case 'I':
X				mprompt = !mprompt;
X				break;
X
X			case 'N':
X				ignore_rc = !ignore_rc;
X				break;
X
X			case 'H':
X				show_version(0, NULL);
X				exit (0);
X
X			default:
X			usage:
X				(void) fprintf(stderr, "Usage: %s [program options] [[open options] site.to.open[:path]]\n\
XProgram Options:\n\
X    -D     : Increase debug level.\n\
X    -H     : Show version and compilation information.\n\
X    -I     : Toggle interactive (mprompt) mode.\n\
X    -N     : Toggle reading of the .netrc/.ncftprc.\n\
X    -V     : Increase verbosity.\n\
XOpen Options:\n\
X    -a     : Open anonymously (this is the default).\n\
X    -u     : Open, specify user/password.\n\
X    -i     : Ignore machine entry in your .netrc.\n\
X    -p N   : Use port #N for connection.\n\
X    -r     : \"Redial\" until connected.\n\
X    -d N   : Redial, pausing N seconds between tries.\n\
X    -g N   : Redial, giving up after N tries.\n\
X    :path  : Open site, retrieve file \"path,\" then exit.\n\
XExamples:\n\
X    %s ftp.unl.edu:/pub/README\n\
X    %s -V -u ftp.unl.edu\n\
X    %s -D -r -d 120 -g 10 ftp.unl.edu\n", progname, progname, progname, progname);
X			exit(1);
X		}
X	}
X
X	cp = argv[Optind];  /* the site to open. */
X	if (cp == NULL) {
X		if (openopts)
X			goto usage;
X	} else
X		(void) strcat(oline, cp);
X
X	if (ignore_rc == 0)
X		(void) thrash_rc();
X
X	(void) fix_options();	/* adjust "options" according to "debug"  */
X	
X	fromatty = isatty(fileno(stdin));
X	cpend = 0;  /* no pending replies */
X	
X	if (*logfname)
X		logf = fopen (logfname, "a");
X
X	eventnumber = 0L;
X	/* The user specified a host on the command line.  Open it now... */
X	if (argc > 1 && cp) {
X		if (setjmp(toplevel))
X			exit(0);
X		(void) signal(SIGINT, intr);
X		(void) signal(SIGPIPE, lostpeer);
X		(void) strcpy(line, oline);
X		makeargv();
X		(void) setpeer(margc, margv);
X	}
X
X	(void) init_prompt();
X
X	eventnumber = 1L;
X	if (ansi_escapes) {
X#ifndef CURSES
X		(void) printf("%s%s Ready.%s\n", 
X				tcap_boldface, FTP_VERSION, tcap_normal);
X#else
X		string vis;
X		(void) sprintf(vis, "%s%s Ready.%s\n", 
X				tcap_boldface, FTP_VERSION, tcap_normal);
X		tcap_put(vis);
X#endif /* !CURSES */
X	}
X	else
X		(void) printf("%s Ready.\n", FTP_VERSION);
X	top = setjmp(toplevel) == 0;
X	if (top) {
X		(void) signal(SIGINT, intr);
X		(void) signal(SIGPIPE, lostpeer);
X	}
X	for (;;) {
X		(void) cmdscanner(top);
X		top = 1;
X	}
X}	/* main */
X
X
X
X/*ARGSUSED*/
Xvoid intr(int unused)
X{
X	(void) longjmp(toplevel, 1);
X}	/* intr */
X
X
X
Xint getuserinfo(void)
X{
X	register char			*cp;
X	struct passwd			*pw = NULL;
X	string					str;
X	extern char				*home;	/* for glob.c */
X	
X	cp = getlogin();
X	if (cp != NULL)
X		pw = getpwnam(cp);
X	if (pw == NULL)
X		pw = getpwuid(getuid());
X	if (pw != NULL) {
X		(void) Strncpy(uinfo.username, pw->pw_name);
X		(void) Strncpy(uinfo.shell, pw->pw_shell);
X		(void) Strncpy(uinfo.homedir, pw->pw_dir);
X		uinfo.uid = pw->pw_uid;
X		home = uinfo.homedir;	/* for glob.c */
X		if (((cp = getenv("MAIL")) == NULL) && ((cp = getenv("mail")) == NULL)) {
X			(void) sprintf(str, "/usr/spool/mail/%s", uinfo.username);
X			cp = str;
X		}
X		/*	mbox variable may be like MAIL=(28 /usr/mail/me /usr/mail/you),
X			so try to find the first mail path.  */
X		while (*cp != '/')
X			cp++;
X		(void) Strncpy(mail_path, cp);
X		if ((cp = index(mail_path, ' ')) != NULL)
X			*cp = '\0';
X		return (0);
X	} else {
X		(void) Strncpy(uinfo.username, "unknown");
X		(void) Strncpy(uinfo.shell, "/bin/sh");
X		(void) Strncpy(uinfo.homedir, ".");	/* current directory */
X		uinfo.uid = 999;
X		return (-1);
X	}
X}	/* getuserinfo */
X
X
X
X
Xint init_arrays(void)
X{
X	if ((macbuf = (char *) malloc((size_t)(MACBUFLEN))) == NULL)
X		goto barf;
X	if ((line = (char *) malloc((size_t)(CMDLINELEN))) == NULL)
X		goto barf;
X	if ((argbuf = (char *) malloc((size_t)(CMDLINELEN))) == NULL)
X		goto barf;
X	if ((reply_string = (char *) malloc((size_t)(RECEIVEDLINELEN))) == NULL)
X		goto barf;
X	
X	*macbuf = '\0';
X	init_transfer_buffer();
X	return (0);
Xbarf:
X	return (-1);
X}	/* init_arrays */
X
X
X
X#ifndef BUFSIZ
X#define BUFSIZ 512
X#endif
X
Xvoid init_transfer_buffer(void)
X{
X	extern char *xferbuf;
X	extern size_t xferbufsize;
X	
X	/* Make sure we use a multiple of BUFSIZ for efficiency. */
X	xferbufsize = (MAX_XFER_BUFSIZE / BUFSIZ) * BUFSIZ;
X	while (1) {
X		xferbuf = (char *) malloc (xferbufsize);
X		if (xferbuf != NULL || xferbufsize < 1024)
X			break;
X		xferbufsize >>= 2;
X	}
X	
X	if (xferbuf != NULL) return;
X	fatal("out of memory for transfer buffer.");
X}	/* init_transfer_buffer */
X
X
X
X
Xvoid init_prompt(void)
X{
X	register char *cp;
X	
X	percent_flags = at_flags = 0;
X	for (cp = prompt; *cp; cp++) {
X		if (*cp == '%') percent_flags = 1;
X		else if (*cp == '@') at_flags = 1;
X	}
X}	/* init_prompt */
X
X
X
X/*ARGSUSED*/
Xvoid lostpeer(int unused)
X{
X	if (connected) {
X		close_streams(1);
X		if (data >= 0) {
X			(void) shutdown(data, 1+1);
X			(void) close(data);
X			data = -1;
X		}
X		connected = 0;
X	}
X	if (connected) {
X		close_streams(1);
X		connected = 0;
X	}
X	hostname[0] = cwd[0] = 0;
X	macnum = 0;
X}	/* lostpeer */
X
X
X
X/*
X * Command parser.
X */
Xvoid cmdscanner(int top)
X{
X	register struct cmd *c;
X#ifdef CURSES
X	string vis, *vp;
X#endif
X
X	if (!top)
X		(void) putchar('\n');
X	for (;;) {
X		if (fromatty) {
X#ifndef CURSES
X			(void) printf(strprompt());
X#else
X			(void) Strncpy(vis, (strprompt()));
X			tcap_put(vis);
X#endif /* !CURSES */
X			(void) fflush(stdout);
X		}
X		if (Gets(line, (size_t)CMDLINELEN) == 0) {
X			if (feof(stdin) || ferror(stdin))
X				(void) quit(0, NULL);	/* control-d */
X			break;
X		}
X		if (line[0] == 0)	/* blank line */
X			break;
X		eventnumber++;
X		if (debug > 1)
X			(void) printf("---> \"%s\"\n", line);
X		(void) makeargv();
X		if (margc == 0) {
X			continue;	/* blank line... */
X		}
X		c = getcmd(margv[0]);
X		if (c == (struct cmd *) -1) {
X			(void) printf("?Ambiguous command\n");
X			continue;
X		}
X		if (c == 0) {
X			if (!implicit_cd(margv[0]))
X				(void) printf("?Invalid command\n");
X			continue;
X		}
X		if (c->c_conn && !connected) {
X			(void) printf ("Not connected.\n");
X			continue;
X		}
X		(*c->c_handler)(margc, margv);
X		if (c->c_handler != help)
X			break;
X	}
X	(void) signal(SIGINT, intr);
X	(void) signal(SIGPIPE, lostpeer);
X}	/* cmdscanner */
X
X
X
X
Xchar *strprompt(void)
X{
X	time_t					tyme;
X	char					eventstr[8];
X	register char			*p, *q;
X	string					str;
X#ifdef CURSES
X	static int 				virgin = 0;
X
X	if (!virgin++ && ansi_escapes)
X		termcap_init();
X#endif /* CURSES */
X
X
X	if (at_flags == 0 && percent_flags == 0)
X		return (prompt);	/* But don't overwrite it! */
X
X	if (at_flags) {
X		for (p = prompt, q = prompt2, *q = 0; (*p); p++)
X			if (*p == '@') switch (islower(*p) ? (toupper(*++p)) : (*++p)) {
X				case '\0':
X					--p;
X					break;
X				case 'M':
X					if (CheckNewMail() > 0)
X						q = Strpcpy(q, "(Mail) ");
X					break;
X				case 'N':
X					q = Strpcpy(q, "\n");
X					break;
X				case 'P':	/* reset to no bold, no uline, no inverse, etc. */
X					if (ansi_escapes)
X						q = Strpcpy(q, tcap_normal);
X					break;
X				case 'B':	/* toggle boldface */
X					if (ansi_escapes)
X						q = Strpcpy(q, tcap_boldface);
X					break;
X				case 'U':	/* toggle underline */
X					if (ansi_escapes)
X						q = Strpcpy(q, tcap_underline);
X					break;
X				case 'R':
X				case 'I':	/* toggle inverse (reverse) video */
X					if (ansi_escapes)
X						q = Strpcpy(q, tcap_reverse);
X					break;
X				case 'D':	/* insert current directory */
X					if (cwd != NULL)
X						q = Strpcpy(q, cwd);
X					break;
X				case 'H':	/* insert name of connected host */
X					if (hostname != NULL)
X						q = Strpcpy(q, hostname);
X					break;
X				case '!':
X				case 'E':	/* insert event number */
X					(void) sprintf(eventstr, "%ld", eventnumber);
X					q = Strpcpy(q, eventstr);
X					break;
X				default:
X					*q++ = *p;	/* just copy it; unknown switch */
X			} else
X				*q++ = *p;
X		*q = '\0';
X	} else 
X		(void) strcpy(prompt2, prompt);
X	
X	if (percent_flags) {
X		/*	only strftime if the user requested it (with a %something),
X			otherwise don't waste time doing nothing. */
X		(void) time(&tyme);
X		(void) Strncpy(str, prompt2);
X		(void) strftime(prompt2, sizeof(str), str, localtime(&tyme));
X	}		
X	return (prompt2);
X}	/* strprompt */
X
X
X
Xchar *Strpcpy(char *dst, char *src)
X{
X	while (*dst++ = *src++)
X		;
X	return (--dst);	/* return current value of dst, NOT original value! */
X}	/* Strpcpy */
X
X
X
X
Xstruct cmd *getcmd(char *name)
X{
X	register char *p, *q;
X	register struct cmd *c, *found;
X	register int nmatches, longest;
X
X	if (name == NULL)
X		return (NULL);
X	longest = 0;
X	nmatches = 0;
X	found = 0;
X	for (c = cmdtab; p = c->c_name; c++) {
X		for (q = name; *q == *p++; q++)
X			if (*q == 0)		/* exact match? */
X				return (c);
X		if (!*q) {			/* the name was a prefix */
X			if (q - name > longest) {
X				longest = q - name;
X				nmatches = 1;
X				found = c;
X			} else if (q - name == longest)
X				nmatches++;
X		}
X	}
X	if (nmatches > 1)
X		return ((struct cmd *)-1);
X	return (found);
X}	/* getcmd */
X
X
X
X
X/*
X * Slice a string up into argc/argv.
X */
X
Xvoid makeargv(void)
X{
X	char **argp;
X
X	margc = 0;
X	argp = margv;
X	stringbase = line;		/* scan from first of buffer */
X	argbase = argbuf;		/* store from first of buffer */
X	slrflag = 0;
X	while (*argp++ = slurpstring())
X		margc++;
X}	/* makeargv */
X
X
X
X
X/*
X * Parse string into argbuf;
X * implemented with FSM to
X * handle quoting and strings
X */
Xchar *slurpstring(void)
X{
X	int got_one = 0;
X	register char *sb = stringbase;
X	register char *ap = argbase;
X	char *tmp = argbase;		/* will return this if token found */
X
X	if (*sb == '!' || *sb == '$') {	/* recognize ! as a token for shell */
X		switch (slrflag) {	/* and $ as token for macro invoke */
X			case 0:
X				slrflag++;
X				stringbase++;
X				return ((*sb == '!') ? "!" : "$");
X				/* NOTREACHED */
X			case 1:
X				slrflag++;
X				altarg = stringbase;
X				break;
X			default:
X				break;
X		}
X	}
X
XS0:
X	switch (*sb) {
X
X	case '\0':
X		goto OUT;
X
X	case ' ':
X	case '\t':
X	case '\n':
X	case '=':
X		sb++; goto S0;
X
X	default:
X		switch (slrflag) {
X			case 0:
X				slrflag++;
X				break;
X			case 1:
X				slrflag++;
X				altarg = sb;
X				break;
X			default:
X				break;
X		}
X		goto S1;
X	}
X
XS1:
X	switch (*sb) {
X
X	case ' ':
X	case '\t':
X	case '\n':
X	case '=':
X	case '\0':
X		goto OUT;	/* end of token */
X
X	case '\\':
X		sb++; goto S2;	/* slurp next character */
X
X	case '"':
X		sb++; goto S3;	/* slurp quoted string */
X
X	default:
X		*ap++ = *sb++;	/* add character to token */
X		got_one = 1;
X		goto S1;
X	}
X
XS2:
X	switch (*sb) {
X
X	case '\0':
X		goto OUT;
X
X	default:
X		*ap++ = *sb++;
X		got_one = 1;
X		goto S1;
X	}
X
XS3:
X	switch (*sb) {
X
X	case '\0':
X		goto OUT;
X
X	case '"':
X		sb++; goto S1;
X
X	default:
X		*ap++ = *sb++;
X		got_one = 1;
X		goto S3;
X	}
X
XOUT:
X	if (got_one)
X		*ap++ = '\0';
X	argbase = ap;			/* update storage pointer */
X	stringbase = sb;		/* update scan pointer */
X	if (got_one) {
X		return(tmp);
X	}
X	switch (slrflag) {
X		case 0:
X			slrflag++;
X			break;
X		case 1:
X			slrflag++;
X			altarg = (char *) 0;
X			break;
X		default:
X			break;
X	}
X	return((char *)0);
X}	/* slurpstring */
X
X
X
X
X#define HELPINDENT (sizeof ("directory"))
X
X/*
X * Help command.
X * Call each command handler with argc == 0 and argv[0] == name.
X */
Xhelp(int argc, char **argv)
X{
X	register struct cmd		*c;
X	int						i, showall = 0;
X	char					*arg;
X
X	if (argc == 2)
X		showall = strcmp(argv[1], "all") == 0;
X	if (argc == 1 || showall)  {
X		(void) printf("Commands may be abbreviated.  'help all' shows aliases,\ninvisible and unsupported commands.  'help <command>' \ngives a brief description of <command>.  Commands are:\n");
X		for (c = cmdtab, i=0; c->c_name != NULL; c++) {
X			if (c->c_hidden && !showall) continue;
X			(void) printf("%-13s", c->c_name);
X			if (++i == 6) {
X				i = 0;
X				putchar('\n');
X			}
X		}
X		if (i < 6)
X			putchar('\n');
X	} else while (--argc > 0) {
X		arg = *++argv;
X		c = getcmd(arg);
X		if (c == (struct cmd *)-1)
X			(void) printf("?Ambiguous help command %s\n", arg);
X		else if (c == (struct cmd *)0)
X			(void) printf("?Invalid help command %s\n", arg);
X		else
X			(void) printf("%-*s\t%s\n", HELPINDENT,
X				c->c_name, c->c_help);
X	}
X}	/* help */
X
X
X/*
X * If the user wants to, s/he can specify the maximum size of the log
X * file, so it doesn't waste too much disk space.  If the log is too
X * fat, trim the older lines (at the top) until we're under the limit.
X */
Xvoid trim_log(void)
X{
X	FILE				*new, *old;
X	struct stat			st;
X	long				fat;
X	string				tmplogname, str;
X
X	if (logsize <= 0 || *logfname == 0 || stat(logfname, &st) ||
X		(old = fopen(logfname, "r")) == NULL)
X		return;	/* never trim, or no log */
X	fat = st.st_size - logsize;
X	if (fat <= 0L) return;	/* log too small yet */
X	while (fat > 0L) {
X		if (FGets(str, old) == NULL) return;
X		fat -= (long) strlen(str);
X	}
X	/* skip lines until a new site was opened */
X	while (1) {
X		if (FGets(str, old) == NULL) {
X			(void) fclose(old);
X			(void) unlink(logfname);
X			return;	/* nothing left, start anew */
X		}
X		if (*str != '\t') break;
X	}
X	
X	/* copy the remaining lines in "old" to "new" */
X	(void) Strncpy(tmplogname, logfname);
X	tmplogname[strlen(tmplogname) - 1] = 'T';
X	if ((new = fopen(tmplogname, "w")) == NULL) {
X		(void) Perror(tmplogname);
X		return;
X	}
X	(void) fputs(str, new);
X	while (FGets(str, old))
X		(void) fputs(str, new);
X	(void) fclose(old); (void) fclose(new);
X	if (unlink(logfname) < 0)
X		Perror(logfname);
X	if (rename(tmplogname, logfname) < 0)
X		Perror(tmplogname);
X}	/* trim_log */
X
X
X
X
Xint CheckNewMail(void)
X{
X	struct stat stbuf;
X
X	if (*mail_path == '\0') return 0;
X	if (stat(mail_path, &stbuf) < 0) {	/* cant find mail_path so we'll */
X		*mail_path = '\0';				/* never check it again */
X		return 0;
X	}
X
X	if (stbuf.st_mtime > mbox_time) {
X		newmail++;
X		(void) printf("%s\n", NEWMAILMESSAGE);
X		(void) time(&mbox_time);				/* only notify once. */
X	}
X	
X	return newmail;
X}	/* CheckNewMail */
X
X
X#ifdef CURSES
Xvoid termcap_init(void)
X{
X	static char area[1024];
X	static char *s = area;
X	char *tgetstr(char *, char **);
X	char *term;
X
X	if (tgetent(tcbuf,(term = getenv("TERM"))) != 1) {
X		(void) fprintf(stderr,"Can't get termcap entry for terminal [%s]\n", term);
X	} else {
X		if (!(tcap_normal = tgetstr("se", &s)))
X			tcap_normal = "";
X		if (!(tcap_boldface = tgetstr("md", &s)))
X			tcap_boldface = "";
X		if (!(tcap_underline = tgetstr("us", &s)))
X			tcap_underline = "";
X		if (!(tcap_reverse = tgetstr("so", &s)))
X			tcap_reverse = "";
X	}
X}	/* termcap_init */
X
X
X
Xstatic int c_output(int c)
X{
X	putchar(c);
X}	/* c_output */
X
X
X
X
Xvoid tcap_put(char *cap)
X{
X	tputs(cap, 0, c_output);
X}	/* tcap_put */
X
X#endif /* CURSES */
X
X/* eof main.c */
END_OF_FILE
  if test 19081 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
