Newsgroups: comp.sources.misc
From: hugh@nsmdserv.cnd.hp.com (Hugh F. Mahon)
Subject: v35i083:  ee - Easy Editor, a simple editor for UNIX, Part04/05
Message-ID: <1993Feb22.041501.15413@sparky.imd.sterling.com>
X-Md4-Signature: d5b0c1abecc217641218b3bfa757d076
Date: Mon, 22 Feb 1993 04:15:01 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: hugh@nsmdserv.cnd.hp.com (Hugh F. Mahon)
Posting-number: Volume 35, Issue 83
Archive-name: ee/part04
Environment: SYSV, SunOS, Curses

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  ee.1 new_curse.c.A
# Wrapped by kent@sparky on Sat Feb 20 21:31:19 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 5)."'
if test -f 'ee.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ee.1'\"
else
  echo shar: Extracting \"'ee.1'\" \(14671 characters\)
  sed "s/^X//" >'ee.1' <<'END_OF_FILE'
X.\"
X.\"
X.\"  To format this reference page, use the command:
X.\"
X.\"    nroff -man ee.1
X.\"
X.\"  $Header: /users/hugh/tmp/old_ae/ee.1,v 1.14 1993/01/25 04:13:39 hugh Exp $
X.\"
X.TH ee 1 "" "" "" ""
X.SH NAME
Xee \- easy editor
X.SH SYNOPSIS
X.nf
Xee [-e] [-i] [-h] [\fIfile\fR ...]
Xree [-e] [-i] [-h] [\fIfile\fR ...]
X.ta
X.fi
X.ad b
X.SH DESCRIPTION
XThe command 
X.I ee 
Xis a simple screen oriented text editor.  It is always in text insertion 
Xmode unless there is a prompt at the bottom of the terminal, or a 
Xmenu present (in a box in the middle of the terminal).  The command 
X.I ree 
Xis the same as 
X.I ee, 
Xbut restricted to editing the named 
Xfile (no file operations, or shell escapes are allowed).
X.PP
XFor 
X.I ee
Xto work properly, the environment variable 
X.SM TERM 
Xmust be set to indicate the type of terminal being used.  For 
Xexample, for an 
X.SM HP 700/92 
Xterminal, the 
X.SM TERM 
Xvariable should be set to "70092".  See your System Administrator if 
Xyou need more information.
X.\"
X.\"     options
X.\"
X.SS Options
XThe following options are available from the command line:
X.PP
X.TP 4
X.B -e
XTurns off expansion of tab character to spaces.
X.TP 
X.B -i
XTurns off display of information window at top of terminal.
X.TP
X.B -h
XTurns off highlighting of borders of windows and menus (improves 
Xperformance on some terminals).
X.br
X.\"
X.\"     command summary
X.\"
X.SS Command Summary
XTo do anything other than insert text, the user must use the control 
Xkeys (the 
X.B Control 
Xkey, represented by a "^",  pressed in conjunction with an 
Xalphabetic key, e.g., ^a) and function keys available on the keyboard 
X(such as 
X.BR "Next Page" ", " "Prev Page" ,
Xarrow keys, etc.).
X.PP
XSince not all terminals have function keys, 
X.I ee
Xhas the basic cursor movement functions assigned to control keys as 
Xwell as more intuitive keys on the keyboard when available.  For 
Xinstance, to move the cursor up, the user can use the up arrow key, 
Xor 
X.BR ^u .
X.RS 4
X.PP
X.\"
X.\"     control keys
X.\"
X.SS Control keys
X.PP
X.nf
X.ta 1.4i
X.sp
X^a 	Prompt for the decimal value of a character to insert.
X^b 	Move to the bottom of the text.
X^c 	Get the prompt for a command.
X^d 	Move the cursor down.
X^e 	Prompt for the string to search for.
X^f 	Undelete the last deleted character.
X^g 	Move to the beginning of the line.
X^h 	Backspace.
X^i 	Tab.
X^j 	Insert a newline.
X^k 	Delete the character the cursor is sitting on.
X^l 	Move the cursor left.
X^m 	Insert a newline.
X^n 	Move to the next page.
X^o 	Move to the end of the line.
X^p 	Move to the previous page.
X^r 	Move the cursor to the right.
X^t 	Move to the top of the text.
X^u 	Move the cursor up.
X^v 	Undelete the last deleted word.
X^w 	Delete the word beginning at the cursor position.
X^x 	Search.
X^y 	Delete from the cursor position to the end of line.
X^z 	Undelete the last deleted line.
X^[ (\s-1ESC\s+1)	Pop up menu.
X.RE
X.ta
X.fi
X.sp
X.\"
X.\"     function keys
X.\"
X.SS Function Keys
X.RS 4
X.IP "\fBNext Page\fR"
XMove to the next page.
X.IP "\fBPrev Page\fR"
XMove to the previous page.
X.IP "\fBDelete Char\fR"
XDelete the character the cursor is on.
X.IP "\fBDelete Line\fR"
XDelete from the cursor to the end of line.
X.IP "\fBInsert line\fR"
XInsert a newline at the cursor position.
X.IP "\fBArrow keys\fR"
XMove the cursor in the direction indicated.
X.RE
X.\"
X.\"     commands
X.\"
X.SS Commands
X.PP
XSome operations require more information than a single keystroke can 
Xprovide.  For the most basic operations, there is a menu that can be 
Xobtained by pressing the 
X.SM \fBESC\fR
Xkey.  The same operations, and more can be performed by obtaining the 
Xcommand prompt (^c) and typing in one of the commands below.
X.RS 4
X.IP "!\fBcmd\fR"
XExecute \fBcmd\fR in a shell.
X.IP "\fB0-9\fR"
XMove to the line indicated.
X.IP "\fBcase\fR"
XMake searches case sensitive.
X.IP "\fBcharacter\fR"
XDisplay the ascii value of the character at the cursor.
X.IP "\fBexit\fR"
XSave the edited text, and leave the editor.
X.IP "\fBexpand\fR"
XExpand tabs to spaces.
X.IP "\fBfile\fR"
XPrint the name of the file.
X.IP "\fBhelp\fR"
XDisplay help screen.
X.IP "\fBline\fR"
XDisplay the current line number.
X.IP "\fBnocase\fR
XMake searches insensitive to case (the default).
X.IP "\fBnoexpand\fR"
XDon't expand tab to spaces when the \s-1TAB\s+1 key is pressed.
X.IP "\fBquit\fR"
XLeave the editor without saving changes.
X.IP "\fBread\fR \fIfile\fR"
XRead the named \fIfile\fR.
X.IP "\fBwrite\fR \fIfile\fR"
XWrite the text to the named \fIfile\fR.
X.RE
X.\"
X.\"     menu options
X.\"
X.SS Menu Operations
X.PP
XPop-up menus can be obtained by pressing the 
X.B escape 
Xkey (or 
X.B ^[ 
Xif no 
X.B escape 
Xkey is present).  When in the menu, the escape key can be 
Xused to leave the menu without performing any operations.  Use the up and 
Xdown arrow keys, or 
X.B ^u
Xfor moving up and 
X.B ^d 
Xfor moving down to move to the desired items in the menu, then press 
X.B return 
Xto perform the indicated task.
X.PP
XThe main menu in \fIee\fR is as follows:
X.RS 4
X.IP "\fBleave editor\fR" 
XIf changes have been made, the user will get a menu prompting whether or 
Xnot the changes should be saved.
X.IP "\fBhelp\fR"
XDisplays a help screen, with all of the keyboard operations and commands.
X.IP "\fBfile operations\fR"
XPops up a menu for selecting whether to read a file, write to a file, or 
Xsave the current contents of the editor, as well as send the contents of 
Xthe editor to a print command (see the section \fBInitializing ee from a 
Xfile\fR).
X.IP "\fBredraw screen\fR"
XProvides a means to repaint the screen if the screen has been corrupted.
X.IP "\fBsettings\fR"
XShows the current values of the operating modes, and right margin.  By 
Xpressing return when the cursor is on a particular item, the value can be 
Xchanged.  To leave this menu, press the \fBescape\fR key.  (See \fBModes\fR 
Xbelow.)
X.IP "\fBsearch\fR"
X.br
XPops up a menu in which the user may choose to enter a string to search 
Xfor, or search for a string already entered.
X.IP "\fBmiscellaneous\fR"
XPops up a menu that allows the user to format the current paragraph, 
Xexecute a shell command, or check the spelling of the text in the editor.
X.RE
X.\"
X.\"     paragraph formatting
X.\"
X.SS Paragraph Formatting
X.PP
XParagraphs are defined for \fIee\fR by a block of text bounded by:
X.sp 
X.RS 8
X.IP \(bu 
XBegin or end of file.
X.IP \(bu
XLine with no characters, or only spaces and/or tabs.
X.IP \(bu
XLine starting with a period ('.') or right angle bracket ('>').
X.RE
X.PP
XA paragraph may be formatted two ways:  explicitly by choosing the 
X\fBformat paragraph\fR menu item, or by setting \fIee\fR to automatically 
Xformat paragraphs.  The automatic mode may be set via a menu, or via the 
Xinitialization file.
X.PP
XThere are three states for text operation in \fIee\fR: free-form, margins, 
Xand automatic formatting.
X.PP
X"Free-form" is best used for things like programming.  There are no 
Xrestrictions on the length of lines, and no formatting takes place.
X.PP
X"Margins" allows the user to type in text without having to worry about going 
Xbeyond the right margin (the right margin may be set in the \fBsettings\fR 
Xmenu, the default is for the margin to be the right edge of the 
Xterminal).  This is the mode that allows the \fBformat paragraph\fR menu 
Xitem to work.
X.PP
X"Automatic formatting" provides word-processor-like behavior.  The user 
Xmay type in text, while \fIee\fR will make sure the entire paragraph fits 
Xwithin the width of the terminal every time the user inserts a space after 
Xtyping or deleting text.  Margin observation must also be enabled in order for 
Xautomatic formatting to occur.
X.\"
X.\"     modes
X.\"
X.SS Modes
X.PP
XAlthough ee is a 'modeless' editor (it is in text insertion mode all the 
Xtime), there are modes in some of the things it does.  These include:
X.RS 4
X.IP "\fBtab expansion\fR"
XTabs may be inserted as a single tab character, or replaced with spaces.
X.IP "\fBcase sensitivity\fR"
XThe search operation can be sensitive to whether characters are upper- or 
Xlower-case, or ignore case completely.
X.IP "\fBmargins observed\fR"
XLines can either be truncated at the right margin, or extend on forever.
X.IP "\fBauto paragraph formatting\fR"
XWhile typing in text, the editor can try to keep it looking reasonably well 
Xwithin the width of the screen.
X.IP "\fBeightbit characters\fR"
XToggles whether eight bit characters are displayed as their value in angle 
Xbrackets (e.g. "<220>") or as a character.
X.IP "\fBinfo window\fR"
XA window showing the keyboard operations that can be performed can be 
Xdisplayed or not.
X.RE
X.PP
XYou may set these modes via the initialization file (see below), or with a 
Xmenu (see above).
X.\"
X.\"     spell checking
X.\"
X.SS Spell Checking
X.PP
XThere are two ways to have the spelling in the text checked from \fIee\fR.  
XOne is by the traditional \fIspell\fR(1) command, the other is with the 
Xoptional \fIispell\fR(1) command.
X.PP
XUsing \fIspell\fR, the words that are not recognized will be placed at the top 
Xof the file.  For the \fIispell\fR option, the file is written to disk, 
Xthen \fIispell\fR run on the file, and the file read back in once 
X\fIispell\fR has completed making changes to the file.
X.\"
X.\"     printing
X.\"
X.SS Printing the contents of the editor
X.PP
XThe user may select a menu item which prints the contents of the editor.  
X.I ee
Xpipes the text in the editor to the command specified by the 
Xinitialization command 
X.B printcommand
X(see the section 
X.B Initializing ee from a file 
Xbelow).  The default is to send the contents to "lp".  
X.PP
XWhatever the user assigns to 
X.B printcommand 
Xmust take input from 
Xstandard input.  See your system administrator for more details.
X.\"
X.\"     shell operations
X.\"
X.SS Shell operations
X.PP
XShell commands can be executed from within 
X.I ee 
Xby selecting the 
X.B shell command 
Xitem in the 
X.B miscellaneous 
Xmenu, or by placing an exclamation mark ("!") before the command to 
Xexecute at the 
X.B command: 
Xprompt.  Additionally, the user may direct the contents of the edit buffer 
Xout to a shell operation (via a pipe) by using the left angle bracket 
X(">"), followed by a "!" and the shell command to execute.  The output of 
Xa shell operation can also be directed into the edit buffer by using a 
Xright angle bracket ("<") before the exclamation mark.  These can even be 
Xused together to send output to a shell operation and read back the 
Xresults into the editor.  So, if the editor contained a list of words 
Xto be sorted, they could be sorted by typing the following at the command 
Xprompt:
X.RS 4
X.sp
X><!sort
X.sp
X.RE
XThis would send the contents of the editor to be piped into the 
X.I sort 
Xutility and the result would be placed into the edit buffer at the current 
Xcursor location.  The old information would have to be deleted by the user.
X.\"
X.\"     initializing ee from a file
X.\"
X.SS Initializing ee from a file
X.PP
XSince different users have different preferences, \fIee\fR allows some 
Xslight configurability.  There are three possible locations for an 
Xinitialization file for ee:  the file \fI/usr/local/lib/init.ee\fR, the 
Xfile \fI.init.ee\fR in the user's home directory, or the file \fI.init.ee\fR 
Xin the current directory (if different from the home 
Xdirectory).  This allows system administrators to set some preferences for 
Xthe users on a system-wide basis (for example, the \fBprint\fR command), 
Xand the user to customize settings for particular directories (like one 
Xfor correspondence, and a different directory for programming).
X.PP
XThe file \fI\/usr/local/lib/init.ee\fR is read first, then 
X\fI$HOME/.init.ee\fR, then \fI.init.ee\fR, with the settings specified by the 
Xmost recent file read taking precedence.
X.PP
XThe following items may be entered in the initialization file:
X.RS 4
X.IP \fBcase\fR
XSets searches to be case sensitive.
X.IP \fBnocase\fR
XSets searches to be insensitive to case (default).
X.IP \fBexpand\fR
XCauses \fIee\fR to expand tabs to spaces (default).
X.IP \fBnoexpand\fR 
XCauses \fIee\fR to insert tabs as a single character.
X.IP \fBinfo\fR
XA small information window is displayed at the top of the terminal 
X(default).
X.IP \fBnoinfo\fR
XTurns off the display of the information window.
X.IP \fBmargins\fR
XCauses \fIee\fR to truncate lines at the right margin when the 
Xcursor passes beyond the right margin as set by the user 
Xwhile text is being inserted 
X(default).
X.IP \fBnomargins\fR
XAllows lines to extend beyond the right margin.
X.IP \fBautoformat\fR
XCauses \fIee\fR to automatically try to format the current paragraph while 
Xtext insertion is occurring.
X.IP \fBnoautoformat\fR
XTurns off automatic paragraph formatting (default).
X.IP \fBprintcommand\fR
XAllows the setting of the print command (default: "lp").
X.IP \fBrightmargin\fR
XThe user can select a value for the right margin (the first column on the 
Xscreen is zero).
X.IP \fBhighlight\fR
XTurns on highlighting border of information window and menus (default).
X.IP \fBnohighlight\fR
XTurns off highlighting of border of information window and menus.
X.IP \fBeightbit\fR
XTurns on display of eight bit characters.
X.IP \fBnoeightbit\fR
XTurns off display of eight bit characters (they are displayed as their decimal 
Xvalue inside angle brackets, e.g., "<220>").
X.RE
X.SH CAVEATS
X.PP
XTHIS MATERIAL IS PROVIDED "AS IS".  THERE ARE 
XNO WARRANTIES OF ANY KIND WITH REGARD TO THIS 
XMATERIAL, INCLUDING, BUT NOT LIMITED TO, THE 
XIMPLIED WARRANTIES OF MERCHANTABILITY AND 
XFITNESS FOR A PARTICULAR PURPOSE.  Neither 
XHewlett-Packard nor Hugh Mahon shall be liable 
Xfor errors contained herein, nor for 
Xincidental or consequential damages in 
Xconnection with the furnishing, performance or 
Xuse of this material.  Neither Hewlett-Packard 
Xnor Hugh Mahon assumes any responsibility for 
Xthe use or reliability of this software or 
Xdocumentation.  This software and 
Xdocumentation is totally UNSUPPORTED.  There 
Xis no support contract available.  Hewlett-Packard 
Xhas done NO Quality Assurance on ANY 
Xof the program or documentation.  You may find 
Xthe quality of the materials inferior to 
Xsupported materials. 
X.PP
XAlways make a copy of files that cannot be easily reproduced before 
Xediting.  Save files early, and save often.
X.SS International Code Set Support
X.I ee 
Xsupports single-byte character code sets (eight-bit clean).
X.SH WARNINGS
XThe automatic paragraph formatting operation 
Xmay be too slow for slower systems.
X.SH FILES
X.PP
X.I /usr/local/lib/init.ee
X.br
X.I $HOME/.init.ee
X.br
X.I .init.ee
X.SH AUTHOR
X.PP
XThe software 
X.I ee
Xwas developed by Hugh Mahon.
X.PP
XThis software and documentation contains 
Xproprietary information which is protected by 
Xcopyright.  All rights are reserved. 
X.PP
XCopyright (c) 1990, 1991, 1992, 1993 Hugh Mahon.
X.SH SEE ALSO
X.PP
Xterminfo(4), environ(5), spell(1), ispell(1), lp(1)
X
END_OF_FILE
  if test 14671 -ne `wc -c <'ee.1'`; then
    echo shar: \"'ee.1'\" unpacked with wrong size!
  fi
  # end of 'ee.1'
fi
if test -f 'new_curse.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'new_curse.c.A'\"
else
  echo shar: Extracting \"'new_curse.c.A'\" \(36627 characters\)
  sed "s/^X//" >'new_curse.c.A' <<'END_OF_FILE'
X/*
X |	new_curse.c
X |
X |	A subset of curses developed for use with ae.
X |
X |	written by Hugh Mahon
X |
X |	THIS MATERIAL IS PROVIDED "AS IS".  THERE ARE
X |	NO WARRANTIES OF ANY KIND WITH REGARD TO THIS
X |	MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE
X |	IMPLIED WARRANTIES OF MERCHANTABILITY AND
X |	FITNESS FOR A PARTICULAR PURPOSE.  Neither
X |	Hewlett-Packard nor Hugh Mahon shall be liable
X |	for errors contained herein, nor for
X |	incidental or consequential damages in
X |	connection with the furnishing, performance or
X |	use of this material.  Neither Hewlett-Packard
X |	nor Hugh Mahon assumes any responsibility for
X |	the use or reliability of this software or
X |	documentation.  This software and
X |	documentation is totally UNSUPPORTED.  There
X |	is no support contract available.  Hewlett-
X |	Packard has done NO Quality Assurance on ANY
X |	of the program or documentation.  You may find
X |	the quality of the materials inferior to
X |	supported materials.
X |
X |	This software is not a product of Hewlett-Packard, Co., or any 
X |	other company.  No support is implied or offered with this software.
X |	You've got the source, and you're on your own.
X |
X |	This software is for free distribution, and is not to be sold, or 
X |	otherwise traded for value without the expressed, written consent of 
X |	the author.  Likewise, any derivatives of this software cannot be 
X |	sold or traded without the consent of the author.  
X |
X |	This notice must be included with this software and any derivatives.
X |
X |	Copyright (c) 1986, 1987, 1988, 1991, 1992 Hugh Mahon
X |	All are rights reserved.
X |
X |	$Header: /users/hugh/tmp/old_ae/new_curse.c,v 1.20 1992/12/18 05:04:39 hugh Exp $
X |
X */
X
X#include "new_curse.h"
X#include <signal.h>
X
Xchar *copyright_message[] = { "Copyright (c) 1986, 1987, 1988, 1991, 1992 Hugh Mahon",
X				"All rights are reserved."};
X
Xchar * new_curse_name= "@(#) new_curse.c $Revision: 1.20 $";
X
XWINDOW *curscr;
Xstatic WINDOW *virtual_scr;
XWINDOW *stdscr;
XWINDOW *newwin();
XWINDOW *last_window_refreshed;
X
X#ifndef CAP
X#define String_Out(table, stack, place) Info_Out(table, stack, place)
X#else
X#define String_Out(table, stack, place) Cap_Out(table, stack, place)
X#endif
X
X#define bw__ 0	/* booleans	*/
X#define am__ 1
X#define xb__ 2
X#define xs__ 3	/* hp glitch (standout not erased by overwrite)	*/
X#define xn__ 4
X#define eo__ 5
X#define gn__ 6	/* generic type terminal	*/
X#define hc__ 7	/* hardcopy terminal		*/
X#define km__ 8
X#define hs__ 9
X#define in__ 10
X#define da__ 11
X#define db__ 12
X#define mi__ 13	/* safe to move during insert mode	*/
X#define ms__ 14	/* safe to move during standout mode	*/
X#define os__ 15
X#define es__ 16
X#define xt__ 17
X#define hz__ 18	/* hazeltine glitch	*/
X#define ul__ 19
X#define xo__ 20
X#define chts__ 21
X#define nxon__ 22
X#define nrrmc__ 23
X#define npc__ 24
X#define mc5i__ 25
X
X#define co__ 0	/* number of columns	*/	/* numbers		*/
X#define it__ 1	/* spaces per tab	*/
X#define li__ 2	/* number of lines	*/
X#define lm__ 3
X#define sg__ 4	/* magic cookie glitch	*/
X#define pb__ 5
X#define vt__ 6
X#define ws__ 7
X
X#define cols__ 0
X#define lines__ 2
X#define xmc__ 4
X#define vt__ 6
X#define wsl__ 7
X#define nlab__ 8
X#define lh__ 9
X#define lw__ 10
X
X#define bt__ 0	/* back tab		*/	/* strings	*/
X#define bl__ 1	/* bell			*/
X#define cr__ 2	/* carriage return	*/
X#define cs__ 3	/* change scroll region	*/
X#define ct__ 4	/* clear all tab stops	*/
X#define cl__ 5	/* clear screen and home cursor	*/
X#define ce__ 6	/* clear to end of line	*/
X#define cd__ 7	/* clear to end of display	*/
X#define ch__ 8	/* set cursor column	*/
X#define CC__ 9	/* term, settable cmd char in 	*/
X#define cm__ 10	/* screen rel cursor motion, row, column	*/
X#define do__ 11	/* down one line	*/
X#define ho__ 12	/* home cursor	*/
X#define vi__ 13	/* make cursor invisible	*/
X#define le__ 14	/* move cursor left one space	*/
X#define CM__ 15	/* memory rel cursor addressing	*/
X#define ve__ 16	/* make cursor appear normal	*/
X#define nd__ 17	/* non-destructive space (cursor right)	*/
X#define ll__ 18	/* last line, first col	*/
X#define up__ 19	/* cursor up		*/
X#define vs__ 20
X#define dc__ 21	/* delete character	*/
X#define dl__ 22	/* delete line		*/
X#define ds__ 23
X#define hd__ 24
X#define as__ 25
X#define mb__ 26
X#define md__ 27	/* turn on bold		*/
X#define ti__ 28
X#define dm__ 29	/* turn on delete mode	*/
X#define mh__ 30	/* half bright mode	*/
X#define im__ 31	/* insert mode		*/
X#define mk__ 32
X#define mp__ 33
X#define mr__ 34
X#define so__ 35	/* enter standout mode	*/
X#define us__ 36
X#define ec__ 37
X#define ae__ 38
X#define me__ 39
X#define te__ 40
X#define ed__ 41
X#define ei__ 42	/* exit insert mode	*/
X#define se__ 43	/* exit standout mode	*/
X#define ue__ 44
X#define vb__ 45
X#define ff__ 46
X#define fs__ 47
X#define i1__ 48
X#define i2__ 49
X#define i3__ 50
X#define if__ 51
X#define ic__ 52
X#define al__ 53
X#define ip__ 54
X#define kb__ 55		/* backspace key	*/
X#define ka__ 56
X#define kC__ 57
X#define kt__ 58
X#define kD__ 59
X#define kL__ 60
X#define kd__ 61
X#define kM__ 62
X#define kE__ 63
X#define kS__ 64
X#define k0__ 65
X#define k1__ 66
X#define kf10__ 67
X#define k2__ 68
X#define k3__ 69
X#define k4__ 70
X#define k5__ 71
X#define k6__ 72
X#define k7__ 73
X#define k8__ 74
X#define k9__ 75
X#define kh__ 76
X#define kI__ 77
X#define kA__ 78
X#define kl__ 79
X#define kH__ 80
X#define kN__ 81
X#define kP__ 82
X#define kr__ 83
X#define kF__ 84
X#define kR__ 85
X#define kT__ 86
X#define ku__ 87	/* key up	*/
X#define ke__ 88
X#define ks__ 89
X#define l0__ 90
X#define l1__ 91
X#define la__ 92
X#define l2__ 93
X#define l3__ 94
X#define l4__ 95
X#define l5__ 96
X#define l6__ 97
X#define l7__ 98
X#define l8__ 99
X#define l9__ 100
X#define mo__ 101
X#define mm__ 102
X#define nw__ 103
X#define pc__ 104
X#define DC__ 105
X#define DL__ 106
X#define DO__ 107
X#define IC__ 118
X#define SF__ 109
X#define AL__ 110
X#define LE__ 111
X#define RI__ 112
X#define SR__ 113
X#define UP__ 114
X#define pk__ 115
X#define pl__ 116
X#define px__ 117
X#define ps__ 118
X#define pf__ 119
X#define po__ 120
X#define rp__ 121
X#define r1__ 122
X#define r2__ 123
X#define r3__ 124
X#define rf__ 125
X#define rc__ 126
X#define cv__ 127
X#define sc__ 128
X#define sf__ 129
X#define sr__ 130
X#define sa__ 131	/* sgr	*/
X#define st__ 132
X#define wi__ 133
X#define ta__ 134
X#define ts__ 135
X#define uc__ 136
X#define hu__ 137
X#define iP__ 138
X#define K1__ 139
X#define K2__ 140
X#define K3__ 141
X#define K4__ 142
X#define K5__ 143
X#define pO__ 144
X#define ml__ 145
X#define mu__ 146
X#define rmp__ 145
X#define acsc__ 146
X#define pln__ 147
X#define kcbt__ 148
X#define smxon__ 149
X#define rmxon__ 150
X#define smam__ 151
X#define rmam__ 152
X#define xonc__ 153
X#define xoffc__ 154
X#define enacs__ 155
X#define smln__ 156
X#define rmln__ 157
X#define kbeg__ 158
X#define kcan__ 159
X#define kclo__ 160
X#define kcmd__ 161
X#define kcpy__ 162
X#define kcrt__ 163
X#define kend__ 164
X#define kent__ 165
X#define kext__ 166
X#define kfnd__ 167
X#define khlp__ 168
X#define kmrk__ 169
X#define kmsg__ 170
X#define kmov__ 171
X#define knxt__ 172
X#define kopn__ 173
X#define kopt__ 174
X#define kprv__ 175
X#define kprt__ 176
X#define krdo__ 177
X#define kref__ 178
X#define krfr__ 179
X#define krpl__ 180
X#define krst__ 181
X#define kres__ 182
X#define ksav__ 183
X#define kspd__ 184
X#define kund__ 185
X#define kBEG__ 186
X#define kCAN__ 187
X#define kCMD__ 188
X#define kCPY__ 189
X#define kCRT__ 190
X#define kDC__ 191
X#define kDL__ 192
X#define kslt__ 193
X#define kEND__ 194
X#define kEOL__ 195
X#define kEXT__ 196
X#define kFND__ 197
X#define kHLP__ 198
X#define kHOM__ 199
X#define kIC__ 200
X#define kLFT__ 201
X#define kMSG__ 202
X#define kMOV__ 203
X#define kNXT__ 204
X#define kOPT__ 205
X#define kPRV__ 206
X#define kPRT__ 207
X#define kRDO__ 208
X#define kRPL__ 209
X#define kRIT__ 210
X#define kRES__ 211
X#define kSAV__ 212
X#define kSPD__ 213
X#define kUND__ 214
X#define rfi__ 215
X#define kf11__ 216
X#define kf12__ 217
X#define kf13__ 218
X#define kf14__ 219
X#define kf15__ 220
X#define kf16__ 221
X#define kf17__ 222
X#define kf18__ 223
X#define kf19__ 224
X#define kf20__ 225
X#define kf21__ 226
X#define kf22__ 227
X#define kf23__ 228
X#define kf24__ 229
X#define kf25__ 230
X#define kf26__ 231
X#define kf27__ 232
X#define kf28__ 233
X#define kf29__ 234
X#define kf30__ 235
X#define kf31__ 236
X#define kf32__ 237
X#define kf33__ 238
X#define kf34__ 239
X#define kf35__ 240
X#define kf36__ 241
X#define kf37__ 242
X#define kf38__ 243
X#define kf39__ 244
X#define kf40__ 245
X#define kf41__ 246
X#define kf42__ 247
X#define kf43__ 248
X#define kf44__ 249
X#define kf45__ 250
X#define kf46__ 251
X#define kf47__ 252
X#define kf48__ 253
X#define kf49__ 254
X#define kf50__ 255
X#define kf51__ 256
X#define kf52__ 257
X#define kf53__ 258
X#define kf54__ 259
X#define kf55__ 260
X#define kf56__ 261
X#define kf57__ 262
X#define kf58__ 263
X#define kf59__ 264
X#define kf60__ 265
X#define kf61__ 266
X#define kf62__ 267
X#define kf63__ 268
X#define el1__ 269
X#define mgc__ 270
X#define smgl__ 271
X#define smgr__ 272
X
X#ifdef CAP
Xchar *Boolean_names[] = {
X"bw", "am", "xb", "xs", "xn", "eo", "gn", "hc", "km", "hs", "in", "da", "db", 
X"mi", "ms", "os", "es", "xt", "hz", "ul", "xo", "HC", "nx", "NR", "NP", "5i"
X}; 
X
Xchar *Number_names[] = { 
X"co#", "it#", "li#", "lm#", "sg#", "pb#", "vt#", "ws#", "Nl#", "lh#", "lw#"
X};
X
Xchar *String_names[] = {
X"bt=", "bl=", "cr=", "cs=", "ct=", "cl=", "ce=", "cd=", "ch=", "CC=", "cm=", 
X"do=", "ho=", "vi=", "le=", "CM=", "ve=", "nd=", "ll=", "up=", "vs=", "dc=", 
X"dl=", "ds=", "hd=", "as=", "mb=", "md=", "ti=", "dm=", "mh=", "im=", "mk=", 
X"mp=", "mr=", "so=", "us=", "ec=", "ae=", "me=", "te=", "ed=", "ei=", "se=", 
X"ue=", "vb=", "ff=", "fs=", "i1=", "i2=", "i3=", "if=", "ic=", "al=", "ip=", 
X"kb=", "ka=", "kC=", "kt=", "kD=", "kL=", "kd=", "kM=", "kE=", "kS=", "k0=", 
X"k1=", "k;=", "k2=", "k3=", "k4=", "k5=", "k6=", "k7=", "k8=", "k9=", "kh=", 
X"kI=", "kA=", "kl=", "kH=", "kN=", "kP=", "kr=", "kF=", "kR=", "kT=", "ku=", 
X"ke=", "ks=", "l0=", "l1=", "la=", "l2=", "l3=", "l4=", "l5=", "l6=", "l7=", 
X"l8=", "l9=", "mo=", "mm=", "nw=", "pc=", "DC=", "DL=", "DO=", "IC=", "SF=", 
X"AL=", "LE=", "RI=", "SR=", "UP=", "pk=", "pl=", "px=", "ps=", "pf=", "po=", 
X"rp=", "r1=", "r2=", "r3=", "rf=", "rc=", "cv=", "sc=", "sf=", "sr=", "sa=", 
X"st=", "wi=", "ta=", "ts=", "uc=", "hu=", "iP=", "K1=", "K3=", "K2=", "K4=", 
X"K5=", "pO=", "rP=", "ac=", "pn=", "kB=", "SX=", "RX=", "SA=", "RA=", "XN=", 
X"XF=", "eA=", "LO=", "LF=", "@1=", "@2=", "@3=", "@4=", "@5=", "@6=", "@7=", 
X"@8=", "@9=", "@0=", "%1=", "%2=", "%3=", "%4=", "%5=", "%6=", "%7=", "%8=", 
X"%9=", "%0=", "&1=", "&2=", "&3=", "&4=", "&5=", "&6=", "&7=", "&8=", "&9=", 
X"&0=", "*1=", "*2=", "*3=", "*4=", "*5=", "*6=", "*7=", "*8=", "*9=", "*0=", 
X"#1=", "#2=", "#3=", "#4=", "%a=", "%b=", "%c=", "%d=", "%e=", "%f=", "%g=", 
X"%h=", "%i=", "%j=", "!1=", "!2=", "!3=", "RF=", "F1=", "F2=", "F3=", "F4=", 
X"F5=", "F6=", "F7=", "F8=", "F9=", "FA=", "FB=", "FC=", "FD=", "FE=", "FF=", 
X"FG=", "FH=", "FI=", "FJ=", "FK=", "FL=", "FM=", "FN=", "FO=", "FP=", "FQ=", 
X"FR=", "FS=", "FT=", "FU=", "FV=", "FW=", "FX=", "FY=", "FZ=", "Fa=", "Fb=", 
X"Fc=", "Fd=", "Fe=", "Ff=", "Fg=", "Fh=", "Fi=", "Fj=", "Fk=", "Fl=", "Fm=", 
X"Fn=", "Fo=", "Fp=", "Fq=", "Fr=", "cb=", "MC=", "ML=", "MR="
X};
X#endif
X
Xchar *new_curse = "October 1987";
X
Xchar in_buff[100];	/* buffer for ungetch			*/
Xint bufp;		/* next free position in in_buff	*/
X
Xchar *TERMINAL_TYPE = NULL; /* terminal type to be gotten from environment	*/
Xint CFOUND = NULL;
Xint Data_Line_len = 0;
Xint Max_Key_len;	/* max length of a sequence sent by a key	*/
Xchar *Data_Line = NULL;
Xchar *TERM_PATH = NULL;
Xchar *TERM_data_ptr = NULL;
Xchar *Term_File_name = NULL;	/* name of file containing terminal description	*/
XFILE *TFP;		/* file pointer to file with terminal des.	*/
Xint Fildes;		/* file descriptor for terminfo file		*/
Xint STAND = FALSE;	/* is standout mode activated?			*/
Xint TERM_INFO = FALSE;	/* is terminfo being used (TRUE), or termcap (FALSE) */
Xint Time_Out;	/* set when time elapsed while trying to read function key */
Xint Curr_x;		/* current x position on screen			*/
Xint Curr_y;		/* current y position on the screen		*/
Xint LINES;
Xint COLS;
Xint Move_It;		/* flag to move cursor if magic cookie glitch	*/
Xint initialized = FALSE;	/* tells whether new_curse is initialized	*/
Xfloat speed;
Xfloat chars_per_millisecond;
Xint Repaint_screen;	/* if an operation to change screen impossible, repaint screen	*/
Xint Intr;		/* storeage for interrupt character		*/
Xint Parity;		/* 0 = no parity, 1 = odd parity, 2 = even parity */
Xint Nowait;		/* for BSD systems				*/
Xint Num_bits;	/* number of bits per character	*/
Xint Flip_Bytes;	/* some systems have byte order reversed	*/
X
X#ifndef CAP
Xchar *Strings;
X#endif
X
Xstruct KEYS {
X	int length;	/* length of string sent by key			*/
X	char *string;	/* string sent by key				*/
X	int value;	/* CURSES value of key (9-bit)			*/
X	};
X
Xstruct KEY_STACK {
X	struct KEYS *element;
X	struct KEY_STACK *next;
X	};
X
Xstruct KEY_STACK *KEY_TOS = NULL;
Xstruct KEY_STACK *KEY_POINT;
X
Xstruct Parameters {
X	int value;
X	struct Parameters *next;
X	};
X
Xint Key_vals[] = { 
X	0407, 0526, 0515, 0525, 0512, 0510, 0402, 0514, 0517, 0516, 0410, 0411, 
X	0422, 0412, 0413, 0414, 0415, 0416, 0417, 0420, 0421, 0406, 0513, 0511, 
X	0404, 0533, 0522, 0523, 0405, 0520, 0521, 0524, 0403, 
X	0534, 0535, 0536, 0537, 0540, 0541, 0542, 0543, 0544, 0545, 0546, 0547, 
X	0550, 0527, 0551, 0552, 0553, 0554, 0555, 0556, 0557, 0560, 0561, 0562, 
X	0532, 0563, 0564, 0565, 0566, 0567, 0570, 0571, 0627, 0630, 0572, 0573, 
X	0574, 0575, 0576, 0577, 0600, 0601, 0602, 0603, 0604, 0605, 0606, 0607, 
X	0610, 0611, 0612, 0613, 0614, 0615, 0616, 0617, 0620, 0621, 0622, 0623, 
X	0624, 0625, 0626, 0423, 0424, 0425, 0426, 0427, 0430, 0431, 
X	0432, 0433, 0434, 0435, 0436, 0437, 0440, 0441, 0442, 0443, 0444, 0445, 
X	0446, 0447, 0450, 0451, 0452, 0453, 0454, 0455, 0456, 0457, 0460, 0461, 
X	0462, 0463, 0464, 0465, 0466, 0467, 0470, 0471, 0472, 0473, 0474, 0475, 
X	0476, 0477, 0500, 0501, 0502, 0503, 0504, 0505, 0506, 0507
X};
X
Xint attributes_set[9];
X
X#ifdef SYS5
Xstruct termio Terminal;
Xstruct termio Saved_tty;
X#else
Xstruct sgttyb Terminal;
Xstruct sgttyb Saved_tty;
X#endif
X
Xchar *tc_;
X
Xint Booleans[128];	
Xint Numbers[128];
Xchar *String_table[1024];
X
Xint *virtual_lines;
X
Xinitscr()		/* initialize terminal for operations	*/
X{
X	char *pointer;
X	int value;
X	char *lines_string;
X	char *columns_string;
X
X#ifdef DIAG
Xprintf("starting initscr \n");fflush(stdout);
X#endif
X	if (initialized)
X		return;
X	Flip_Bytes = FALSE;
X	Parity = 0;
X	Time_Out = FALSE;
X	bufp = 0;
X	Move_It = FALSE;
X	Nowait = FALSE;
X#ifdef SYS5
X	value = ioctl(0, TCGETA, &Terminal);
X	if (Terminal.c_cflag & PARENB)
X	{
X		if (Terminal.c_cflag & PARENB)
X			Parity = 1;
X		else
X			Parity = 2;
X	}
X	if ((Terminal.c_cflag & CS8) == CS8)
X	{
X		Num_bits = 8;
X	}
X	else if ((Terminal.c_cflag & CS7) == CS7)
X		Num_bits = 7;
X	else if ((Terminal.c_cflag & CS6) == CS6)
X		Num_bits = 6;
X	else
X		Num_bits = 5;
X	value = Terminal.c_cflag & 037;
X	switch (value) {
X	case 01:	speed = 50.0;
X		break;
X	case 02:	speed = 75.0;
X		break;
X	case 03:	speed = 110.0;
X		break;
X	case 04:	speed = 134.5;
X		break;
X	case 05:	speed = 150.0;
X		break;
X	case 06:	speed = 200.0;
X		break;
X	case 07:	speed = 300.0;
X		break;
X	case 010:	speed = 600.0;
X		break;
X	case 011:	speed = 900.0;
X		break;
X	case 012:	speed = 1200.0;
X		break;
X	case 013:	speed = 1800.0;
X		break;
X	case 014:	speed = 2400.0;
X		break;
X	case 015:	speed = 3600.0;
X		break;
X	case 016:	speed = 4800.0;
X		break;
X	case 017:	speed = 7200.0;
X		break;
X	case 020:	speed = 9600.0;
X		break;
X	case 021:	speed = 19200.0;
X		break;
X	case 022:	speed = 38400.0;
X		break;
X	default:	speed = 0.0;
X	}
X#else
X	value = ioctl(0, TIOCGETP, &Terminal);
X	if (Terminal.sg_flags & EVENP)
X		Parity = 2;
X	else if (Terminal.sg_flags & ODDP)
X		Parity = 1;
X	value = Terminal.sg_ospeed;
X	switch (value) {
X	case 01:	speed = 50.0;
X		break;
X	case 02:	speed = 75.0;
X		break;
X	case 03:	speed = 110.0;
X		break;
X	case 04:	speed = 134.5;
X		break;
X	case 05:	speed = 150.0;
X		break;
X	case 06:	speed = 200.0;
X		break;
X	case 07:	speed = 300.0;
X		break;
X	case 010:	speed = 600.0;
X		break;
X	case 011:	speed = 1200.0;
X		break;
X	case 012:	speed = 1800.0;
X		break;
X	case 013:	speed = 2400.0;
X		break;
X	case 014:	speed = 4800.0;
X		break;
X	case 015:	speed = 9600.0;
X		break;
X	default:	speed = 0.0;
X	}
X#endif
X	chars_per_millisecond = (0.001 * speed) / 8.0;
X	TERMINAL_TYPE = getenv("TERM");
X	if (TERMINAL_TYPE == NULL)
X	{
X		printf("unknown terminal type\n");
X		exit(0);
X	}
X#ifndef CAP
X	TERM_PATH = getenv("TERMINFO");
X	if (TERM_PATH != NULL)
X	{
X		Data_Line_len = 23 + strlen(TERM_PATH) + strlen(TERMINAL_TYPE);
X		pointer = Term_File_name = malloc(Data_Line_len);
X		strcpy(Term_File_name, TERM_PATH);
X		while (*pointer != NULL)
X			pointer++;
X		*pointer = '/';
X		pointer++;
X	}
X	else
X	{
X		pointer = Term_File_name = malloc(22 + strlen(TERMINAL_TYPE));
X		strcpy(Term_File_name, "/usr/lib/terminfo/");
X		while (*pointer != NULL)
X			pointer++;
X	}
X	*pointer = *TERMINAL_TYPE;
X	pointer++;
X	*pointer = '/';
X	pointer++;
X	strcpy(pointer, TERMINAL_TYPE);
X	if ((Fildes = open(Term_File_name, 0)) == -1)
X	{
X		free(Term_File_name);
X		Term_File_name = NULL;
X	}
X	else
X		TERM_INFO = INFO_PARSE();
X#else
X	Term_File_name = "/etc/termcap";
X	if ((TFP = fopen(Term_File_name, "r")) == NULL)
X	{
X		printf("unable to open /etc/termcap file \n");
X		exit(0);
X	}
X 	for (value = 0; value < 1024; value++)	
X		String_table[value] = NULL;
X	for (value = 0; value < 128; value++)	
X		Booleans[value] = 0;
X	for (value = 0; value < 128; value++)	
X		Numbers[value] = 0;
X	Find_term();
X	CAP_PARSE();
X#endif
X	if ((String_table[cm__] == NULL) || (Booleans[hc__]))
X	{
X		fprintf(stderr, "sorry, unable to use this terminal type for screen editing\n");
X		exit(0);
X	}
X	Key_Get();
X	LINES = Numbers[li__];
X	COLS = Numbers[co__];
X	if ((lines_string = getenv("LINES")) != NULL)
X	{
X		value = atoi(lines_string);
X		if (value > 0)
X			LINES = value;
X	}
X	if ((columns_string = getenv("COLUMNS")) != NULL)
X	{
X		value = atoi(columns_string);
X		if (value > 0)
X			COLS = value;
X	}
X	virtual_scr = newwin(LINES, COLS, 0, 0);
X	stdscr = newwin(LINES, COLS, 0, 0);
X	curscr = newwin(LINES, COLS, 0, 0);
X	wmove(stdscr, 0, 0);
X	werase(stdscr);
X	Repaint_screen = TRUE;
X	initialized = TRUE;
X	virtual_lines = (int *) malloc(LINES * (sizeof(int)));
X}
X
X#ifndef CAP
XGet_int()		/* get a two-byte integer from the terminfo file */
X{
X	int High_byte;
X	int Low_byte;
X	int temp;
X
X	Low_byte = *((unsigned char *) TERM_data_ptr++);
X	High_byte = *((unsigned char *) TERM_data_ptr++);
X	if (Flip_Bytes)
X	{
X		temp = Low_byte;
X		Low_byte = High_byte;
X		High_byte = temp;
X	}
X	if ((High_byte == 255) && (Low_byte == 255))
X		return (-1);
X	else
X		return(Low_byte + (High_byte * 256));
X}
X
XINFO_PARSE()		/* parse off the data in the terminfo data file	*/
X{
X	int offset;
X	int magic_number = 0;
X	int counter = 0;
X	int Num_names = 0;
X	int Num_bools = 0;
X	int Num_ints = 0;
X	int Num_strings = 0;
X	int string_table_len = 0;
X	char *temp_ptr;
X
X	TERM_data_ptr = Data_Line = calloc(1, (10240 * (sizeof(char))));
X	Data_Line_len = read(Fildes, Data_Line, 10240);
X	if ((Data_Line_len >= 10240) || (Data_Line_len < 0))
X		return(0);
X	/*
X	 |	get magic number
X	 */
X	magic_number = Get_int();
X	/*
X	 |	if magic number not right, reverse byte order and check again
X	 */
X	if (magic_number != 282)
X	{
X		Flip_Bytes = TRUE;
X		TERM_data_ptr--;
X		TERM_data_ptr--;
X		magic_number = Get_int();
X		if (magic_number != 282)
X			return(0);
X	}
X	/*
X	 |	get the number of each type in the terminfo data file
X	 */
X	Num_names = Get_int();
X	Num_bools = Get_int();
X	Num_ints = Get_int();
X	Num_strings = Get_int();
X	string_table_len = Get_int();
X	Strings = calloc(1, string_table_len);
X	while (Num_names > 0)
X	{
X		TERM_data_ptr++;
X		Num_names--;
X	}
X	counter = 0;
X	while (Num_bools)
X	{
X		Num_bools--;
X		Booleans[counter++] = *TERM_data_ptr++;
X	}
X	if (((unsigned int) TERM_data_ptr) & 1)	/* force alignment	*/
X		TERM_data_ptr++;
X	counter = 0;
X	while (Num_ints)
X	{
X		Num_ints--;
X		Numbers[counter] = Get_int();
X		counter++;
X	}
X	temp_ptr = TERM_data_ptr + Num_strings + Num_strings;
X	memcpy(Strings, temp_ptr, string_table_len);
X	counter = bt__;
X	while (Num_strings)
X	{
X		Num_strings--;
X		if ((offset=Get_int()) != -1)
X		{
X			if (String_table[counter] == NULL)
X				String_table[counter] = Strings + offset;
X		}
X		else
X			String_table[counter] = NULL;
X		counter++;
X	}
X	close(Fildes);
X	cfree(Data_Line);
X	return(TRUE);
X}
X#endif		/* ifndef CAP	*/
X
XAtoI()		/* convert ascii text to integers	*/
X{
X	int Temp;
X
X	Temp = 0;
X	while ((*TERM_data_ptr >= '0') && (*TERM_data_ptr <= '9'))
X	{
X		Temp = (Temp * 10) + (*TERM_data_ptr - '0');
X		TERM_data_ptr++;
X	}
X	return(Temp);
X}
X
XKey_Get()		/* create linked list with all key sequences obtained from terminal database	*/
X{
X	int Counter;
X	int Klen;
X	int key_def;
X	struct KEY_STACK *Spoint;
X
X	Max_Key_len = 0;
X	Counter = 0;
X	key_def = kb__;
X	while (key_def <= kf63__)
X	{
X		if (key_def == ke__)
X			key_def = K1__;
X		else if (key_def == (K5__ + 1))
X			key_def = kcbt__;
X		else if (key_def == (kcbt__ + 1))
X			key_def = kbeg__;
X		else if (key_def == (kUND__ + 1))
X			key_def = kf11__;
X		if (String_table[key_def] != NULL)
X		{
X			if (KEY_TOS == NULL)
X				Spoint = KEY_TOS = (struct KEY_STACK *) malloc(sizeof(struct KEY_STACK));
X			else
X			{
X				Spoint = KEY_TOS;
X				while (Spoint->next != NULL)
X					Spoint = Spoint->next;
X				Spoint->next = (struct KEY_STACK *) malloc(sizeof(struct KEY_STACK));
X				Spoint = Spoint->next;
X			}
X			Spoint->next = NULL;
X			Spoint->element = (struct KEYS *) malloc(sizeof(struct KEYS));
X			Spoint->element->string = String_table[key_def];
X			Spoint->element->length = strlen(String_table[key_def]);
X			Spoint->element->value = Key_vals[Counter];
X			Klen = strlen(Spoint->element->string);
X			if (Klen > Max_Key_len)
X				Max_Key_len = Klen;
X		}
X		key_def++;
X		Counter++;
X	}
X}
X
X#ifdef CAP
Xchar *String_Get(param)		/* read the string */
Xchar *param;
X{
X	char *String;
X	char *Temp;
X	int Counter;
X
X	if (param == NULL)
X	{
X		while (*TERM_data_ptr != '=')
X			TERM_data_ptr++;
X		Temp = ++TERM_data_ptr;
X		Counter = 1;
X		while ((*Temp != ':') && (*Temp != NULL))
X		{
X			Counter++;
X			Temp++;
X		}
X		String = Temp = malloc(Counter);
X		while ((*TERM_data_ptr != ':') && (*TERM_data_ptr != NULL))
X		{
X			if (*TERM_data_ptr == '\\')
X			{
X				TERM_data_ptr++;
X				if (*TERM_data_ptr == 'n')
X					*Temp = '\n';
X				else if (*TERM_data_ptr == 't')
X					*Temp = '\t';
X				else if (*TERM_data_ptr == 'b')
X					*Temp = '\b';
X				else if (*TERM_data_ptr == 'r')
X					*Temp = '\r';
X				else if (*TERM_data_ptr == 'f')
X					*Temp = '\f';
X				else if ((*TERM_data_ptr == 'e') || (*TERM_data_ptr == 'E'))
X					*Temp = '\033';		/* escape */
X				else if (*TERM_data_ptr == '\\')
X					*Temp = '\\';
X				else if (*TERM_data_ptr == '\'')
X					*Temp = '\'';
X				else if ((*TERM_data_ptr >= '0') && (*TERM_data_ptr <= '9'))
X				{
X					Counter = 0;
X					while ((*TERM_data_ptr >= '0') && (*TERM_data_ptr <= '9'))
X					{
X						Counter = (8 * Counter) + (*TERM_data_ptr - '0');
X						*TERM_data_ptr++;
X					}
X					*Temp = Counter;
X					TERM_data_ptr--;
X				}
X				TERM_data_ptr++;
X				Temp++;
X			}
X			else if (*TERM_data_ptr == '^')
X			{
X				TERM_data_ptr++;
X				if ((*TERM_data_ptr >= '@') && (*TERM_data_ptr <= '_'))
X					*Temp = *TERM_data_ptr - '@';
X				else if (*TERM_data_ptr == '?')
X					*Temp = 127;
X				TERM_data_ptr++;
X				Temp++;
X			}
X			else
X				*Temp++ = *TERM_data_ptr++;
X		}
X		*Temp = NULL;
X		param = String;
X	}
X	else
X	{
X		while ((*TERM_data_ptr != NULL) && (*TERM_data_ptr != ':'))
X			TERM_data_ptr++;
X		if (*TERM_data_ptr == ':')
X			TERM_data_ptr++;
X	}
X	return(param);
X}
X
XGet_int(param)		/* read the integer				*/
Xint param;
X{
X	char *Temp;
X	int Itemp;
X
X	if (param == 0)
X	{
X		while ((*TERM_data_ptr != NULL) && (*TERM_data_ptr != '#'))
X			TERM_data_ptr++;
X		TERM_data_ptr++;
X		Itemp = AtoI();
X		if (*TERM_data_ptr == ':')
X			TERM_data_ptr++;
X		param = Itemp;
X	}
X	else
X	{
X		while (*TERM_data_ptr != ':')
X			TERM_data_ptr++;
X		if (*TERM_data_ptr == ':')
X			TERM_data_ptr++;
X	}
X	return(param);
X}
X
XFind_term()		/* find terminal description in termcap file	*/
X{
X	char *Name;
X	char *Ftemp;
X
X	Ftemp = Name = malloc(strlen(TERMINAL_TYPE + 1) + 1);
X	strcpy(Name, TERMINAL_TYPE);
X	while (*Ftemp != NULL)
X		Ftemp++;
X	*Ftemp++ = '|';
X	*Ftemp = NULL;
X	Data_Line = malloc(512);
X	CFOUND = FALSE;
X	Data_Line_len = strlen(TERMINAL_TYPE) + 1;
X	while ((!CFOUND) && ((TERM_data_ptr=fgets(Data_Line, 512, TFP)) != NULL))
X	{
X		if ((*TERM_data_ptr != ' ') && (*TERM_data_ptr != '\t') && (*TERM_data_ptr != '#'))
X		{
X			while ((!CFOUND) && (*TERM_data_ptr != NULL))
X			{
X				CFOUND = !strncmp(TERM_data_ptr, Name, Data_Line_len);
X				while ((*TERM_data_ptr != NULL) && (*TERM_data_ptr != '|') && (*TERM_data_ptr != '#') && (*TERM_data_ptr != ':'))
X					TERM_data_ptr++;
X				if (*TERM_data_ptr == '|')
X					TERM_data_ptr++;
X				else if (!CFOUND)
X					*TERM_data_ptr = NULL;
X			}
X		}
X	}
X	if (!CFOUND)
X	{
X		printf("terminal type %s not found\n", TERMINAL_TYPE);
X		exit(0);
X	}
X}
X
XCAP_PARSE()		/* parse off the data in the termcap data file	*/
X{
X	int offset;
X	int Cip = 0;
X	int found;
X
X	do
X	{
X		while (*TERM_data_ptr != NULL)
X		{
X			for (found = FALSE, offset = 0; (!found) && (offset < 26); offset++)
X			{
X				if (!strncmp(TERM_data_ptr, Boolean_names[offset], 2))
X				{
X					found = TRUE;
X					Booleans[offset] = TRUE;
X				}
X			}
X			if (!found)
X			{
X				for (found = FALSE, offset = 0; (!found) && (offset < lw__); offset++)
X				{
X					if (!strncmp(TERM_data_ptr, Number_names[offset], 3))
X					{
X						found = TRUE;
X						Numbers[offset] = Get_int(Numbers[offset]);
X					}
X				}
X			}
X			if (!found)
X			{
X				for (found = FALSE, offset = 0; (!found) && (offset < smgr__); offset++)
X				{
X					if (!strncmp(TERM_data_ptr, String_names[offset], 3))
X					{
X						found = TRUE;
X						String_table[offset] = String_Get(String_table[offset]);
X					}
X				}
X			}
X
X			if (!strncmp(TERM_data_ptr, "tc=", 3))
X				tc_ = String_Get(NULL);
X			while ((*TERM_data_ptr != ':') && (*TERM_data_ptr != NULL))
X				TERM_data_ptr++;
X			if (*TERM_data_ptr == ':')
X				TERM_data_ptr++;
X		}
X	} while (((TERM_data_ptr = fgets(Data_Line, 512, TFP)) != NULL) && ((*TERM_data_ptr == ' ') || (*TERM_data_ptr == '\t')));
X	if (tc_ != NULL)
X	{
X		TERMINAL_TYPE = tc_;
X		rewind(TFP);
X		Find_term();
X		free(tc_);
X		tc_ = NULL;
X		CAP_PARSE();
X	}
X	else
X		fclose(TFP);
X}
X#endif		/* ifdef CAP	*/
X
Xstruct _line *
XScreenalloc(columns)
Xint columns;
X{
X	int i;
X	struct _line *tmp;
X
X	tmp = (struct _line *) malloc(sizeof (struct _line));
X	tmp->row = malloc(columns + 1);
X	tmp->attributes = malloc(columns + 1);
X	tmp->prev_screen = NULL;
X	tmp->next_screen = NULL;
X	for (i = 0; i < columns; i++)
X	{
X		tmp->row[i] = ' ';
X		tmp->attributes[i] = NULL;
X	}
X	tmp->scroll = tmp->changed = FALSE;
X	tmp->row[0] = NULL;
X	tmp->attributes[0] = NULL;
X	tmp->row[columns] = NULL;
X	tmp->attributes[columns] = NULL;
X	tmp->last_char = 0;
X	return(tmp);
X}
X
XWINDOW *newwin(lines, cols, start_l, start_c)
Xint lines, cols;	/* number of lines and columns to be in window	*/
Xint start_l, start_c;	/* starting line and column to be inwindow	*/
X{
X	WINDOW *Ntemp;
X	struct _line *temp_screen;
X	int i;
X
X	Ntemp = (WINDOW *) malloc(sizeof(WINDOW));
X	Ntemp->SR = start_l;
X	Ntemp->SC = start_c;
X	Ntemp->Num_lines = lines;
X	Ntemp->Num_cols = cols;
X	Ntemp->LX = 0;
X	Ntemp->LY = 0;
X	Ntemp->scroll_down = Ntemp->scroll_up = 0;
X	Ntemp->SCROLL_CLEAR = FALSE;
X	Ntemp->Attrib = FALSE;
X	Ntemp->first_line = temp_screen = Screenalloc(cols);
X	Ntemp->first_line->number = 0;
X	for (i = 1; i < lines; i++)
X	{
X		temp_screen->next_screen = Screenalloc(cols);
X		temp_screen->next_screen->number = i;
X		temp_screen->next_screen->prev_screen = temp_screen;
X		temp_screen = temp_screen->next_screen;
X	}
X	Ntemp->first_line->prev_screen = NULL;
X	temp_screen->next_screen = NULL;
X	return(Ntemp);
X}
X
X#ifdef CAP
XCap_Out(string, p_list, place)		/* interpret the output string if necessary */
Xchar *string;
Xint p_list[];			/* stack of values	*/
Xint place;			/* place keeper of top of stack	*/
X{
X	char *Otemp;		/* temporary string pointer to parse output */
X	int delay;
X	int p1, p2, temp;
X	float chars;
X	int old_arg, value;
X
X	if (string == NULL)
X		return;
X
X/*#ifndef SYS5
X	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg & ~FNDELAY);
X#endif*/
X
X	if (p_list != NULL)
X	{
X		p1 = p_list[--place];
X		p2 = p_list[--place];
X	}
X	delay = 0;
X	Otemp = string;
X	if ((*Otemp >= '0') && (*Otemp <= '9'))
X	{
X		delay = atoi(Otemp);
X		while ((*Otemp >= '0') && (*Otemp <= '9'))
X			Otemp++;
X		if (*Otemp == '*')
X			Otemp++;
X	}
X	while (*Otemp != NULL)
X	{
X		if (*Otemp == '%')
X		{
X			Otemp++;
X			if ((*Otemp == 'd') || (*Otemp == '2') || (*Otemp == '3') || (*Otemp == '.') || (*Otemp == '+')) 
X			{
X				if (*Otemp == 'd')
X				 	printf("%d", p1);
X				else if (*Otemp == '2')
X					printf("%2d", p1);
X				else if (*Otemp == '3')
X					printf("%3d", p1);
X				else if (*Otemp == '+')
X				{
X					Otemp++;
X					p1 += *Otemp;
X					putchar(p1);
X				}
X				else if (*Otemp == '.')
X					putchar(p1);
X				p1 = p2;
X				p2 = 0;
X			}
X			else if (*Otemp == '>')
X			{
X				Otemp++;
X				if (p1 > *Otemp)
X				{
X					Otemp++;
X					p1 += *Otemp;
X				}
X				else
X					Otemp++;
X			}
X			else if (*Otemp == 'r')
X			{
X				temp = p1;
X				p1 = p2;
X				p2 = temp;
X			}
X			else if (*Otemp == 'i')
X			{
X				p1++;
X				p2++;
X			}
X			else if (*Otemp == '%')
X				putchar(*Otemp);
X			else if (*Otemp == 'n')
X			{
X				p1 ^= 0140;
X				p2 ^= 0140;
X			}
X			else if (*Otemp == 'B')
X			{
X				p1 = (16 * (p1/10)) + (p1 % 10);
X				p2 = (16 * (p2/10)) + (p2 % 10);
X			}
X			else if (*Otemp == 'D')
X			{
X				p1 = (p1 - 2 * (p1 % 16));
X				p2 = (p2 - 2 * (p2 % 16));
X			}
X		}
X		else
X			putchar (*Otemp);
X		Otemp++;
X	}
X	if (delay != 0)
X	{
X		chars = delay * chars_per_millisecond;
X		delay = chars;
X		if ((chars - delay) > 0.0)
X			delay++;
X		for (; delay > 0; delay--)
X			putchar(*String_table[pc__]);
X	}
X	fflush(stdout);
X/*#ifndef SYS5
X	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg | FNDELAY);
X#endif*/
X}
X
X#else
X
X	char *Otemp;		/* temporary string pointer to parse output */
X	float chars;
X	int p[10];
X	int variable[27];
X
XOperation(Temp_Stack, place)		/* handle conditional operations	*/
Xint Temp_Stack[];
Xint place;
X{
X	int temp;
X
X	if (*Otemp == 'd')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X	 	printf("%d", temp);
X	}
X	else if (!strncmp(Otemp, "2d", 2))
X	{
X		temp = Temp_Stack[--place];
X		printf("%2d", temp);
X		Otemp++;
X		Otemp++;
X	}
X	else if (!strncmp(Otemp, "3d", 2))
X	{
X		temp = Temp_Stack[--place];
X		printf("%0d", temp);
X		Otemp++;
X		Otemp++;
X	}
X	else if (!strncmp(Otemp, "02d", 3))
X	{
X		temp = Temp_Stack[--place];
X		printf("%02d", temp);
X		Otemp++;
X		Otemp++;
X		Otemp++;
X	}
X	else if (!strncmp(Otemp, "03d", 3))
X	{
X		temp = Temp_Stack[--place];
X		printf("%03d", temp);
X		Otemp++;
X		Otemp++;
X		Otemp++;
X	}
X	else if (*Otemp == '+')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp += Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '-')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp -= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '*')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp *= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '/')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp /= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == 'm')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp %= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '&')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp &= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '|')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp |= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '^')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp ^= Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '=')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp = (temp == Temp_Stack[--place]);
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '>')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp = temp > Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == '<')
X	{
X		Otemp++;
X		temp = Temp_Stack[--place];
X		temp = temp < Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X	}
X	else if (*Otemp == 'c')
X	{
X		Otemp++;
X		putchar(Temp_Stack[--place]);
X	}
X	else if (*Otemp == 'i')
X	{
X		Otemp++;
X		p[1]++;
X		p[2]++;
X	}
X	else if (*Otemp == '%')
X	{
X		putchar(*Otemp);
X		Otemp++;
X	}
X	else if (*Otemp == '!')
X	{
X		temp = ! Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X		Otemp++;
X	}
X	else if (*Otemp == '~')
X	{
X		temp = ~Temp_Stack[--place];
X		Temp_Stack[place++] = temp;
X		Otemp++;
X	}
X	else if (*Otemp == 'p')
X	{
X		Otemp++;
X		Temp_Stack[place++] = p[*Otemp - '0'];
X		Otemp++;
X	}
X	else if (*Otemp == 'P')
X	{
X		Otemp++;
X		Temp_Stack[place++] = variable[*Otemp - 'a'];
X		Otemp++;
X	}
X	else if (*Otemp == 'g')
X	{
X		Otemp++;
X		variable[*Otemp - 'a'] = Temp_Stack[--place];
X		Otemp++;
X	}
X	else if (*Otemp == '\'')
X	{
X		Otemp++;
X		Temp_Stack[place++] = *Otemp;
X		Otemp++;
X		Otemp++;
X	}
X	else if (*Otemp == '{')
X	{
X		Otemp++;
X		temp = atoi(Otemp);
X		Temp_Stack[place++] = temp;
X		while (*Otemp != '}')
X			Otemp++;
X		Otemp++;
X	}
X	return(place);
X}
X
XInfo_Out(string, p_list, place)	/* interpret the output string if necessary */
Xchar *string;
Xint p_list[];
Xint place;
X{
X	char *tchar;
X	int delay;
X	int temp;
X	int value;
X	int Cond_FLAG;
X	int EVAL;
X	int Cond_Stack[128];
X	int Cond_place;
X	int Stack[128];
X	int Top_of_stack;
X
X	if (string == NULL)
X		return;
X
X	Cond_FLAG = FALSE;
X	Cond_place = 0;
X	Top_of_stack = 0;
X	p[0] = 0;
X	p[1] = 0;
X	p[2] = 0;
X	p[3] = 0;
X	p[4] = 0;
X	p[5] = 0;
X	p[6] = 0;
X	p[7] = 0;
X	p[8] = 0;
X	p[9] = 0;
X	if (p_list != NULL)
X	{
X		for (temp = 1; (place != 0); temp++)
X		{
X			p[temp] = p_list[--place];
X		}
X	}
X	delay = 0;
X	Otemp = string;
X	while (*Otemp != NULL)
X	{
X		if (*Otemp == '%')
X		{
X			Otemp++;
X			if ((*Otemp == '?') || (*Otemp == 't') || (*Otemp == 'e') || (*Otemp == ';'))
X			{
X				if (*Otemp == '?')
X				{
X					Otemp++;
X					Cond_FLAG = TRUE;
X					EVAL = TRUE;
X					while (EVAL)
X					{
X						/*
X						 |  find the end of the 
X						 |  conditional statement
X						 */
X						while ((strncmp(Otemp, "%t", 2)) && (*Otemp != NULL))
X						{
X							/*
X							 |  move past '%'
X							 */
X							Otemp++;
X							Cond_place = Operation(Cond_Stack, Cond_place);
X						}
X
X						/*
X						 |  if condition is true
X						 */
X						if ((Cond_place > 0) && (Cond_Stack[Cond_place-1]))
X						{
X							/*
X							 |  end conditional 
X							 |  parsing
X							 */
X							EVAL = FALSE;
X							Otemp++;
X							Otemp++;
X						}
X						else	/* condition is false */
X						{
X							/*
X							 |  find 'else' or end 
X							 |  of if statement
X							 */
X							while ((strncmp(Otemp, "%e", 2)) && (strncmp(Otemp, "%;", 2)) && (*Otemp != NULL))
X								Otemp++;
X							/*
X							 |  if an 'else' found
X							 */
X							if ((*Otemp != NULL) && (!strncmp(Otemp, "%e", 2)))
X							{
X								Otemp++;
X								Otemp++;
X								tchar = Otemp;
X								/*
X								 |  check for 'then' part
X								 */
X								while ((*tchar != NULL) && (strncmp(tchar, "%t", 2)) && (strncmp(tchar, "%;", 2)))
X									tchar++;
X								/*
X								 |  if end of string
X								 */
X								if (*tchar == NULL)
X								{
X									EVAL = FALSE;
X									Cond_FLAG = FALSE;
X									Otemp = tchar;
X								}
X								/*
X								 |  if end of if found,
X								 |  set up to parse 
X								 |  info
X								 */
X								else if (!strncmp(tchar, "%;", 2))
X									EVAL = FALSE;
X								/*
X								 |  otherwise, check 
X								 |  conditional in 
X								 |  'else'
X								 */
X							}
X							/*
X							 |  if end of if found,
X							 |  get out of if 
X							 |  statement
X							 */
X							else if ((*Otemp != NULL) && (!strncmp(Otemp, "%;", 2)))
X							{
X								EVAL = FALSE;
X								Otemp++;
X								Otemp++;
X							}
X							else /* Otemp == NULL */
X							{
X								EVAL = FALSE;
X								Cond_FLAG = FALSE;
X							}
X						}
X					}
X				}
X				else
X				{
X					Otemp++;
X					Cond_FLAG = FALSE;
X					if (*Otemp != ';')
X					{
X						while ((*Otemp != NULL) && (strncmp(Otemp, "%;", 2)))
X							Otemp++;
X						if (*Otemp != NULL)
X						{
X							Otemp++;
X							Otemp++;
X						}
X					}
X					else
X						Otemp++;
X				}
X			}
X			else
X			{
X				Top_of_stack = Operation(Stack, Top_of_stack);
X			}
X		}
X		else if (!strncmp(Otemp, "$<", 2))
X		{
X			Otemp++;
X			Otemp++;
X			delay = atoi(Otemp);
X			while (*Otemp != '>')
X				Otemp++;
X			Otemp++;
X			chars = delay * chars_per_millisecond;
X			delay = chars;
X			if ((chars - delay) > 0.0)
X				delay++;
X			if (String_table[pc__] == NULL)
X				temp = 0;
X			else
X				temp = *String_table[pc__];
X			for (; delay > 0; delay--)
X				putc(temp, stdout);
X		}
X		else
X		{
X			putchar(*Otemp);
X			Otemp++;
X		}
X	}
X	fflush(stdout);
X}
X#endif
X
END_OF_FILE
  if test 36627 -ne `wc -c <'new_curse.c.A'`; then
    echo shar: \"'new_curse.c.A'\" unpacked with wrong size!
  elif test -f 'new_curse.c.B'; then
    echo shar: Combining  \"'new_curse.c'\" \(73709 characters\)
    cat 'new_curse.c.A' 'new_curse.c.B' > 'new_curse.c'
    if test 73709 -ne `wc -c <'new_curse.c'`; then
      echo shar: \"'new_curse.c'\" combined with wrong size!
    else
      rm new_curse.c.A new_curse.c.B
    fi
  fi
  # end of 'new_curse.c.A'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
