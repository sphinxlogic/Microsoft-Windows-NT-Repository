Newsgroups: comp.sources.misc
From: hugh@nsmdserv.cnd.hp.com (Hugh F. Mahon)
Subject: v35i080:  ee - Easy Editor, a simple editor for UNIX, Part01/05
Message-ID: <csm-v35i080=ee.220843@sparky.IMD.Sterling.COM>
X-Md4-Signature: 192044ca308a2e3f6c82f3ce4394b8e4
Date: Mon, 22 Feb 1993 04:10:13 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: hugh@nsmdserv.cnd.hp.com (Hugh F. Mahon)
Posting-number: Volume 35, Issue 80
Archive-name: ee/part01
Environment: SYSV, SunOS, Curses

This is ee ("Easy Editor"), a text editor so simple to learn no instruction 
is required.  ee is intended for simple editing tasks such as E-mail messages 
and news articles.

ee should compile on most System V based platforms, but may be able to 
operate on other platforms with appropriate curses support.  On systems 
with support for X/Open localization, it is possible to localize ee for 
languages with single octet character sets.  

Hugh Mahon              |___|     
h_mahon@fc.hp.com       |   |     
                            |\  /|
                            | \/ |
--------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README.ee ee.i18n.guide new_curse.c.B
# Wrapped by kent@sparky on Sat Feb 20 21:31:17 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 5)."'
if test -f 'README.ee' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.ee'\"
else
  echo shar: Extracting \"'README.ee'\" \(5919 characters\)
  sed "s/^X//" >'README.ee' <<'END_OF_FILE'
X          THIS MATERIAL IS PROVIDED "AS IS".  THERE ARE NO WARRANTIES OF 
X          ANY KIND WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT 
X          LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
X          FITNESS FOR A PARTICULAR PURPOSE.  Neither Hewlett-Packard nor 
X          Hugh Mahon shall be liable for errors contained herein, nor for 
X          incidental or consequential damages in connection with the 
X          furnishing, performance or use of this material.  Neither 
X          Hewlett-Packard nor Hugh Mahon assumes any responsibility for 
X          the use or reliability of this software or documentation.  This 
X          software and documentation is totally UNSUPPORTED.  There is no 
X          support contract available.  Hewlett-Packard has done NO 
X          Quality Assurance on ANY of the program or documentation.  You 
X          may find the quality of the materials inferior to supported 
X          materials. 
X
X      This software is for free distribution, and is not to be sold, or 
X      otherwise traded for value without the expressed, written consent 
X      of the author.  Likewise, any derivatives of this software cannot 
X      be sold or traded without the consent of the author.  
X
X      This notice must be included with this software and any 
X      derivatives. 
X
X      Any modifications to this software by anyone but the original author 
X      must be so noted. 
X
X
XThe editor 'ee' (easy editor) is intended to be a simple, easy to use 
Xterminal-based screen oriented editor that requires no instruction to 
Xuse.  Its primary use would be for people who are new to computers, or who 
Xuse computers only for things like e-mail.
X
Xee's simplified interface is highlighted by the use of pop-up menus which 
Xmake it possible for users to carry out tasks without the need to 
Xremember commands.  An information window at the top of the screen shows 
Xthe user the operations available with control-keys.
X
Xee relies on the virtual memory abilities of the platform it is running on 
Xand does not have its own memory management capabilities.
X
XI am releasing ee because I hate to see new users and non-computer types 
Xget frustrated by vi, and would like to see more intuitive interfaces for 
Xbasic tools (both character-based and graphical) become more pervasive.
XTerminal capabilities and communication speeds have evolved considerably 
Xsince the time in which vi's interface was created, allowing much more 
Xintuitive interfaces to be used.  Since character-based I/O won't be 
Xcompletely replaced by graphical user interfaces for at least a few more 
Xyears, I'd like to do what I can to make using computers with less 
Xglamorous interfaces as easy to use as possible.  If terminal interfaces 
Xare still used in ten years, I hope neophytes won't still be stuck with 
Xonly vi.  
X
XFor a text editor to be easy to use requires a certain set of abilities.  In 
Xorder for ee to work, a terminal must have the ability to position the cursor 
Xon the screen, and should have arrow keys that send unique sequences 
X(multiple characters, the first character is an "escape", octal code 
X'\033').  All of this information needs to be in a database called "terminfo" 
X(System V implementations) or "termcap" (usually used for BSD systems).  In 
Xcase the arrow keys do not transmit unique sequences, motion operations are 
Xmapped to control keys as well, but this at least partially defeats the 
Xpurpose.  The curses package is used to handle the I/O which deals with the 
Xterminal's capabilities.  
X
XWhile ee is based on curses, I have included here the source code to 
Xnew_curse, a subset of curses developed for use with ee.  'curses' often  
Xwill have a defect that reduces the usefulness of the editor relying upon 
Xit.  
X
XThe new_curse source is provided simply as a back up in case the curses on 
Xyour system has such a defect.  The code is a rather nasty hack, and can be 
Xnoticeably slower than real curses.  Also, although there is code for 
Xhandling non-System V systems, this code has been much less used, and so may 
Xnow be non-functional.  Likewise with the code for handling termcap.  I just 
Xfelt that since it was already there, I may as well leave it since someone 
Xmay find it useful.  While new_curse is somewhat poorly written code in some 
Xplaces, it is source code that can be hacked if all else fails.  Note, 
Xhowever, that if you're having problems, first make sure of the terminal 
Xconfiguration, especially if you're using a terminal emulator, and make sure 
Xthat you are using the right terminfo entry before rummaging through code.  
XTerminfo entries often contain inaccuracies, or incomplete information, or 
Xmay not totally match the terminal or emulator the terminal information is 
Xbeing used with.  Complaints that ee isn't working quite right often end up 
Xbeing something else (like the terminal emulator being used). 
X
XBoth ee and new_curse were developed using K&R C (also known as "classic 
XC").  Some tweaks may be required to make ee and new_curse compile on 
Xsome platforms.
X
Xee is the result of several conflicting design goals.  While I know that it 
Xsolves the problems of some users, I also have no doubt that some will decry 
Xits lack of more features.  I will settle for knowing that ee does fulfill 
Xthe needs of a minority (but still large number) of users.  The goals of ee 
Xare: 
X
X        1. To be so easy to use as to require no instruction.
X        2. To be easy to compile and, if necessary, port to new platforms 
X           by people with relatively little knowledge of C and UNIX.
X        3. To have a minimum number of files to be dealt with, for compile 
X           and installation.
X        4. To have enough functionality to be useful to a large number of 
X           people.
X
XHugh Mahon              |___|     
Xh_mahon@fc.hp.com       |   |     
X                            |\  /|
X                            | \/ |
X
END_OF_FILE
  if test 5919 -ne `wc -c <'README.ee'`; then
    echo shar: \"'README.ee'\" unpacked with wrong size!
  fi
  # end of 'README.ee'
fi
if test -f 'ee.i18n.guide' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ee.i18n.guide'\"
else
  echo shar: Extracting \"'ee.i18n.guide'\" \(6826 characters\)
  sed "s/^X//" >'ee.i18n.guide' <<'END_OF_FILE'
XEasy Editor ("ee") provides the ability to translate the messages displayed to 
Xthe user and the commands entered.  This is done via message catalogs, 
Xfollowing X/Open standards.  ee only supports eight bit characters.
X
X(The name ee.i18n.guide is for "ee internationalization guide".  The i18n 
Xabbreviation is used because there are 18 characters between the first 
Xletter ("i") and last ("n") of "internationalization".)
X
XAll of the messages, warnings, information, and commands, are contained in the 
Xmessage catalog.  Each numbered entry represents an individual string used by 
Xee.  Some strings contain formatting information for formatted print 
Xstatements, which are of the form "%s", or "%d", these must be preserved in 
Xthe translation, or the correct information will not be displayed.  For those 
Xstrings containing multiple formatting codes, the order of each item must be 
Xpreserved as well.
X
XMessage		content 
X1 		title for modes, or settings menu
X2 - 8		entries for modes menu, each line should be the same length 
X		 (padded with spaces)
X9 - 34		other menu titles and entries
X35 - 56 	help screen 
X57 - 61 	actions assigned to control keys 
X62 - 66 	commands information 
X67 		message displayed when info window turned off
X68 		indication that no file name was entered when invoking ee
X69		prompt for decimal value of character to be entered
X70		message displaying the print command being invoked
X71 		prompt for command 
X72		prompt for name of file to be written 
X73		prompt for name of file to be read 
X74		string used to display the decimal value of the character 
X		 the cursor is on 
X75		string displaying an unrecognized command 
X76 		string indicating that the command entered is not a unique 
X		 substring of a valid command
X77		string indicating the current line number 
X78		string for displaying the length of the line 
X79		string for displaying the name of the file 
X80 - 83		strings showing how to invoke ee, and its options
X84		message indicating that the file entered is a directory, not a 
X		 text file
X85		message informing that the entered file does not yet exist 
X86		message informing that the file can't be opened (because of 
X		 permission problems)
X87		message after file has been read with the file name and number 
X		 of lines read
X88		message indicating that the file has been read
X89		message indicating that the file is being read
X90		message indicating that permissions only allow the file to be 
X		 read, not written
X91		message after file has been read with the file name and number 
X		 of lines read
X92		prompt for name of file to be saved (used when no name was 
X		 entered for a file to edit)
X93		message indicating that the file was not written, since no 
X		 name was entered at the prompt
X94		prompt asking user if changes should not be saved ("yes_char" 
X		 will be expected for affirmative response)
X95		"yes" character, single character expected to confirm action 
X		 (can be upper or lower case, will be converted to upper-case 
X		 during test)
X96		prompt
X97		error message
X98		message indicating that the named file is being written
X99		message indicating the name of the file written, the number of 
X		 lines, and the number of characters (order of items must be 
X		 maintained)
X100		search in progress message
X101		message that the string was not found
X102		prompt for search
X103		message that string could not be executed
X104		self-explanatory
X105		message for menus, indicating that the Escape character will 
X		 allow the user to exit the menu
X106		error message indicating the menu won't fit on the screen
X107		self-explanatory
X108		prompt for shell command
X109		message displayed while formatting a paragraph
X110		string which places message for spell checking at top of 
X		 buffer (the portions 'list of unrecognized words' and 
X		 '-=-=-=-=-=-' may be replaced, but the rest must remain the 
X		 same)
X111		message informing that spell checking is in progress
X112		prompt for right margin
X113		error informing user that operation is not permitted in ree
X114		string indicating mode is turned 'on' in modes menu
X115		string indicating mode is turned 'off' in modes menu
X116 - 131	strings used for commands (some also used for initialization)
X132 - 144	strings used for initialization
X
XCare should be taken when translating commands and initialization keywords 
Xbecause the algorithm used for detecting uniqueness of entered commands 
Xwill not be able to distinguish words that are not unique before the end 
Xof the shorter word, for example, it would not be able to distinguish the 
Xcommand 'abcd' from 'abcde'.
X
XAfter translating the messages, use the 'gencat' command to create the compiled 
Xcatalog used when running the software.  The standard syntax would be:
X
X	gencat ee.cat ee.msg
X
XWhere ee.msg is the file containing the translations, and ee.cat is the 
Xcompiled catalog.  If the file ee.cat does not exist, it will be created.  
XCheck the documentation for your system for proper syntax.  
X
XMessage catalog placement varies from system to system.  A common location 
Xfor message catalogs is in /usr/lib/nls.  In this directory are 
Xdirectories with the names of other languages.  The default language is 
X'C'.  There is also an environment variable, named NLSPATH used to 
Xdetermine where message catalogs can be found.  This variable is similar 
Xto the PATH variable used for commands, but with some differences.  The 
XNLSPATH variable must have the ability to handle different names for 
Xlanguages and the catalog files, so it has field descriptors for these.  A 
Xtypical setting for NLSPATH could be:
X
X	NLSPATH=/usr/lib/nls/%L/%N.cat:/usr/local/lib/nls/%L/%N.cat
X
XWhere "%L" is the field descriptor for the language (obtained from the 
XLANG environment variable) and "%N" is the name of the file (with the 
X".cat" appended by the path variable, it is not passed from the requesting 
Xprogram).  The colon (:) is used to separate paths, so in the above 
Xexample there are two paths possible for message catalogs.  You may wish 
Xto maintain catalogs for applications that are not supported by your 
Xsystem vendor in a location unique for you, and this is facilitated by the 
XNLSPATH variable.  Remember to set and export both the LANG and NLSPATH 
Xvariables for each user that expects to use localization either in a 
Xsystem-wide profile or in each user's profile.  See your system 
Xdocumentation for more information.
X
XThe message catalog supplied with ee also uses the '$quote' directive to 
Xspecify a quote around strings to ensure proper padding.  This directive 
Xmay not be supported on all systems, and lead to quotes being included in 
Xthe string used in ee, which will cause incorrect behavior.  If the 
X'$quote' directive is not supported by your system's gencat command, edit 
Xthe msg file to remove the leading and trailing quotation marks.
END_OF_FILE
  if test 6826 -ne `wc -c <'ee.i18n.guide'`; then
    echo shar: \"'ee.i18n.guide'\" unpacked with wrong size!
  fi
  # end of 'ee.i18n.guide'
fi
if test -f 'new_curse.c.B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'new_curse.c.B'\"
else
  echo shar: Extracting \"'new_curse.c.B'\" \(37082 characters\)
  sed "s/^X//" >'new_curse.c.B' <<'END_OF_FILE'
Xatoi(string)		/* convert ascii text to integers	*/
Xchar *string;
X{
X	int Temp;
X	char *astring;
X
X	astring = string;
X	Temp = 0;
X	while ((*astring >= '0') && (*astring <= '9'))
X	{
X		Temp = (Temp * 10) + (*astring - '0');
X		astring++;
X	}
X	return(Temp);
X}
X
Xwmove(window, row, column)	/* move cursor to indicated position in window */
XWINDOW *window;
Xint row, column;
X{
X	if ((row < window->Num_lines) && (column < window->Num_cols))
X	{
X		window->LX = column;
X		window->LY = row;
X	}
X}
X
Xclear_line(line, column, cols)
Xstruct _line *line;
Xint column;
X{
X	int j;
X
X	if (column > line->last_char)
X		line->row[line->last_char] = ' ';
X	line->last_char = column;
X	line->row[column] = NULL;
X	line->attributes[column] = NULL;
X	line->changed = TRUE;
X/*	if (column == 0)
X		line->scroll = FALSE;*/
X	for (j = column + 1; j < cols; j++)
X	{
X		line->row[j] = ' ';
X		line->attributes[j] = NULL;
X	}
X}
X
Xwerase(window)			/* clear the specified window		*/
XWINDOW *window;
X{
X	int i;
X	struct _line *tmp;
X
X	window->SCROLL_CLEAR = CLEAR;
X	window->scroll_up = window->scroll_down = 0;
X	for (i = 0, tmp = window->first_line; i < window->Num_lines; i++, tmp = tmp->next_screen)
X		clear_line(tmp, 0, window->Num_cols);
X}
X
Xwclrtoeol(window)	/* erase from current cursor position to end of line */
XWINDOW *window;
X{
X	int column, row;
X	struct _line *tmp;
X
X	window->SCROLL_CLEAR = CHANGE;
X	column = window->LX;
X	row = window->LY;
X	for (row = 0, tmp = window->first_line; row < window->LY; row++)
X		tmp = tmp->next_screen;
X	clear_line(tmp, column, window->Num_cols);
X}
X
Xwrefresh(window)		/* flush all previous output		*/
XWINDOW *window;
X{
X	int old_arg, value;
X/*#ifndef SYS5
X	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg & ~FNDELAY);
X#endif   to be uncommented if setting to nodelay on input only is unsuitable */
X	wnoutrefresh(window);
X#ifdef DIAG
X{
X	struct _line *temp;
X	fprintf(stderr, "columns=%d, lines=%d, SC=%d, SR=%d\n",window->Num_cols, window->Num_lines, window->SC, window->SR);
X	for (value = 0, temp = window->first_line; value < window->Num_lines; value++, temp = temp->next_screen)
X	{
X		if (temp->number == -1)
X			fprintf(stderr, "line moved ");
X		if (temp->scroll)
X			fprintf(stderr, "scroll_x is set:  ");
X		fprintf(stderr, "lc%d=%s|\n", temp->last_char, temp->row);
X	}
X	fprintf(stderr, "+-------------------- virtual screen ----------------------------------------+\n");
X	fprintf(stderr, "columns=%d, lines=%d \n",virtual_scr->Num_cols, virtual_scr->Num_lines);
X	for (value = 0, temp = virtual_scr->first_line; value < virtual_scr->Num_lines; value++, temp = temp->next_screen)
X	{
X		if (temp->number == -1)
X			fprintf(stderr, "line moved ");
X		if (temp->scroll)
X			fprintf(stderr, "scroll_x is set:  ");
X		fprintf(stderr, "lc%d=%s|\n", temp->last_char, temp->row);
X	}
X	fprintf(stderr, "columns=%d, lines=%d \n",curscr->Num_cols, curscr->Num_lines);
X	for (value = 0, temp = curscr->first_line; value < curscr->Num_lines; value++, temp = temp->next_screen)
X		fprintf(stderr, "line=%s|\n", temp->row);
X}
X#endif
X	doupdate();
X	virtual_scr->SCROLL_CLEAR = FALSE;
X	virtual_scr->scroll_down = virtual_scr->scroll_up = 0;
X	fflush(stdout);
X/*#ifndef SYS5
X	value = fcntl(0, F_SETFL, old_arg | FNDELAY);
X#endif*/
X}
X
Xtouchwin(window)
XWINDOW *window;
X{
X	struct _line *user_line;
X	int line_counter = 0;
X
X	for (line_counter = 0, user_line = window->first_line; 
X		line_counter < window->Num_lines; line_counter++)
X	{
X		user_line->changed = TRUE;
X	}
X	window->SCROLL_CLEAR = TRUE;
X}
X
Xwnoutrefresh(window)
XWINDOW *window;
X{
X	struct _line *user_line;
X	struct _line *virtual_line;
X	int line_counter = 0;
X	int user_col = 0;
X	int virt_col = 0;
X
X	user_line = window->first_line;
X	virtual_line = virtual_scr->first_line;
X	virtual_scr->SCROLL_CLEAR = window->SCROLL_CLEAR;
X	virtual_scr->LX = window->LX + window->SC;
X	virtual_scr->LY = window->LY + window->SR;
X	virtual_scr->scroll_up = window->scroll_up;
X	virtual_scr->scroll_down = window->scroll_down;
X	if ((last_window_refreshed == window) && (!window->SCROLL_CLEAR))
X		return;
X	for (line_counter = 0; line_counter < window->SR; line_counter++)
X	{
X		virtual_line = virtual_line->next_screen;
X	}
X	for (line_counter = 0; line_counter < window->Num_lines; line_counter++)
X	{
X		if ((last_window_refreshed != window) || (user_line->changed) || ((SCROLL | CLEAR) & window->SCROLL_CLEAR))
X		{
X			for (user_col = 0, virt_col = window->SC; user_col < window->Num_cols; virt_col++, user_col++)
X			{
X				virtual_line->row[virt_col] = user_line->row[user_col];
X				virtual_line->attributes[virt_col] = user_line->attributes[user_col];
X			}
X		}
X		if (virtual_scr->Num_cols != window->Num_cols)
X		{
X			if (virtual_line->last_char < (user_line->last_char + window->SC))
X			{
X				if (virtual_line->row[virtual_line->last_char] == NULL)
X					virtual_line->row[virtual_line->last_char] = ' ';
X				virtual_line->last_char = user_line->last_char + window->SC;
X			}
X			else if (virtual_line->last_char > (user_line->last_char + window->SC))
X			{
X				virtual_line->row[window->SC + user_line->last_char] = ' ';
X			}
X		}
X		else
X			virtual_line->last_char = user_line->last_char;
X		virtual_line->row[virtual_line->last_char] = NULL;
X		virtual_line->changed = user_line->changed;
X		virtual_line = virtual_line->next_screen;
X		user_line = user_line->next_screen;
X	}
X	window->SCROLL_CLEAR = FALSE;
X	window->scroll_up = window->scroll_down = 0;
X	last_window_refreshed = window;
X}
X
Xflushinp()			/* flush input				*/
X{
X	int value;
X/*
X#ifdef SYS5
X	value = ioctl(0, TCFLSH, 0);
X#else
X	value = ioctl(0, TIOCFLUSH, 0);
X#endif
X*/
X}
X
Xungetch(c)			/* push a character back on input	*/
Xint c;
X{
X	if (bufp < 100)
X		in_buff[bufp++] = c;
X}
X
Xint 
Xwgetch(window)			/* get character from specified window	*/
XWINDOW *window;
X{
X	int old_arg;
X	int in_value;
X
X#ifndef SYS5
X	if (!Nowait)
X	{
X		Time_Out = FALSE;
X		Nowait = TRUE;
X		old_arg = fcntl(0, F_GETFL, 0);
X		value = fcntl(0, F_SETFL, old_arg | FNDELAY);
X	}
X#endif
X	in_value = ((bufp > 0) ? in_buff[--bufp] : getchar());
X	if (in_value != -1) 
X	{
X		in_value &= 0xff;
X		if ((Parity) && (Num_bits < 8))	/* strip eighth bit if parity in use */
X		in_value &= 0177;
X	}
X	if ((in_value == '\033') || (in_value == '\037'))		/* escape character		*/
X		in_value = Get_key(in_value);
X#ifndef SYS5
X	if (!Time_Out)
X	{
X		Nowait = FALSE;
X		value = fcntl(0, F_SETFL, old_arg);
X	}
X#endif
X	return(in_value);
X}
X
XClear()		/* notify that time out has occurred	*/
X{
X	Time_Out = TRUE;
X}
X
Xint 
XGet_key(first_char)			/* try to decode key sequence		*/
Xint first_char;				/* first character of sequence		*/
X{
X	int in_char;
X	int Count;
X	char string[128];
X	char *Gtemp;
X	int value;
X	int Found;
X	int old_arg;
X#ifdef SYS5
X	struct termio Gterminal;
X#else
X	struct sgttyb Gterminal;
X#endif
X	struct KEY_STACK *St_point;
X
X	Count = 0;
X	Gtemp = string;
X	string[Count++] = first_char;
X	string[Count] = NULL;
X	Time_Out = FALSE;
X	signal(SIGALRM, Clear);
X	value = alarm(1);
X#ifdef SYS5
X/*	value = ioctl(0, TCGETA, &Gterminal);
X	Gterminal.c_cc[VMIN] = 0;	/* minimum of zero characters	*/
X	Gterminal.c_cc[VTIME] = 0;		/* timeout value	*/
X	Gterminal.c_lflag &= ~ICANON;	/* disable canonical operation	*/
X	Gterminal.c_lflag &= ~ECHO;		/* disable echo		*/
X/*	value = ioctl(0, TCSETA, &Gterminal);	/* set characteristics	*/
X#else
X/*	value = ioctl(0, TIOCGETP, &Gterminal);
X	Gterminal.sg_flags |= RAW ;
X	Gterminal.sg_flags &= ~ECHO;
X	value = ioctl(0, TIOCSETP, &Gterminal);	/* set characteristics	*/
X/*	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg | FNDELAY);*/
X#endif
X	Count = 1;
X	Found = FALSE;
X	while ((Count < Max_Key_len) && (!Time_Out) && (!Found))
X	{
X		in_char = wgetch(stdscr);
X		if (in_char != -1)
X		{
X			string[Count++] = in_char;
X			string[Count] = NULL;
X			St_point = KEY_TOS;
X			while ((St_point != NULL) && (!Found))
X			{
X				if (!strcmp(string, St_point->element->string))
X					Found = TRUE;
X				else
X					St_point = St_point->next;
X			}
X		}
X	}
X	if (!Time_Out)
X		value = alarm(0);
X#ifdef SYS5
X/*	value = ioctl(0, TCSETA, &Terminal);*/
X#else
X	value = ioctl(0, TIOCSETP, &Terminal);
X/*	value = fcntl(0, F_SETFL, old_arg);*/
X#endif
X	if (Found)
X	{
X		return(St_point->element->value);
X	}
X	else
X	{
X		while (Count > 1)
X		{
X			if ((string[--Count] != -1) && (string[Count] != 255))
X			{
X#ifdef DIAG
Xfprintf(stderr, "ungetting character %d\n", string[Count]);fflush(stdout);
X#endif
X				ungetch(string[Count]);
X			}
X		}
X		return(first_char);
X	}
X}
X
Xwaddch(window, c)	/* output the character in the specified window	*/
XWINDOW *window;
Xint c;
X{
X	int i, j;
X	int row, column;
X	int shift;	/* number of spaces to shift if a tab		*/
X	struct _line *tmpline;
X
X#ifdef DIAG
X/*printf("starting waddch \n");fflush(stdout);*/
X#endif
X	row = window->LY;
X	column = window->LX;
X	if (c == '\t')
X	{
X		shift = (column + 1) % 8;
X		if (shift == 0)
X			shift++;
X		else
X			shift = 9 - shift;
X		while (shift > 0)
X		{
X			shift--;
X			waddch(window, ' ');
X		}
X	}
X	else if ((column < window->Num_cols) && (row < window->Num_lines))
X	{
X		if ((c == '~') && (Booleans[hz__]))
X			c = '@';
X
X		if (( c != '\b') && (c != '\n') && (c != '\r'))
X		{
X			row = 0;
X			tmpline = window->first_line; 
X			while (row < window->LY)
X			{
X				row++;
X				tmpline = tmpline->next_screen;
X			}
X			tmpline->row[column] = c;
X			tmpline->attributes[column] = window->Attrib;
X			tmpline->changed = TRUE;
X			if (column >= tmpline->last_char)
X			{
X				if (column > tmpline->last_char)
X					tmpline->row[tmpline->last_char] = ' ';
X				tmpline->row[column + 1] = NULL;
X				tmpline->attributes[column + 1] = NULL;
X				tmpline->last_char = column + 1;
X			}
X		}
X		if (c == '\n')
X		{
X			wclrtoeol(window);
X			window->LX = window->Num_cols;
X		}
X		else if (c == '\r')
X			window->LX = 0;
X		else if (c == '\b')
X			window->LX--;
X		else
X			window->LX++;
X	}
X	if (window->LX >= window->Num_cols)
X	{
X		window->LX = 0;
X		window->LY++;
X		if (window->LY >= window->Num_lines)
X		{
X			window->LY = window->Num_lines - 1;
X/*			window->LY = row;
X			wmove(window, 0, 0);
X			wdeleteln(window);
X			wmove(window, row, 0);*/
X		}
X	}
X	window->SCROLL_CLEAR = CHANGE;
X}
X
Xwinsertln(window)	/* insert a blank line into the specified window */
XWINDOW *window;
X{
X	int row, column;
X	struct _line *tmp;
X	struct _line *tmp1;
X
X	window->scroll_down += 1;
X	window->SCROLL_CLEAR = SCROLL;
X	column = window->LX;
X	row = window->LY;
X	for (row = 0, tmp = window->first_line; (row < window->Num_lines) && (tmp->next_screen != NULL); row++)
X		tmp = tmp->next_screen;
X	if (tmp->prev_screen != NULL)
X		tmp->prev_screen->next_screen = NULL;
X	tmp1 = tmp;
X	clear_line(tmp1, 0, window->Num_cols);
X	tmp1->number = -1;
X	for (row = 0, tmp = window->first_line; (row < window->LY) && (tmp->next_screen != NULL); row++)
X		tmp = tmp->next_screen;
X	if ((window->LY == (window->Num_lines - 1)) && (window->Num_lines > 1))
X	{
X		tmp1->next_screen = tmp->next_screen;
X		tmp->next_screen = tmp1;
X		tmp->changed = TRUE;
X		tmp->next_screen->prev_screen = tmp;
X	}
X	else if (window->Num_lines > 1)
X	{
X		if (tmp->prev_screen != NULL)
X			tmp->prev_screen->next_screen = tmp1;
X		tmp1->prev_screen = tmp->prev_screen;
X		tmp->prev_screen = tmp1;
X		tmp1->next_screen = tmp;
X		tmp->changed = TRUE;
X		tmp->scroll = DOWN;
X	}
X	if (window->LY == 0)
X		window->first_line = tmp1;
X}
X
Xwdeleteln(window)	/* delete a line in the specified window */
XWINDOW *window;
X{
X	int row, column;
X	struct _line *tmp;
X	struct _line  *tmpline;
X
X	if (window->Num_lines > 1)
X	{
X		window->scroll_up += 1;
X		window->SCROLL_CLEAR = SCROLL;
X		column = window->LX;
X		row = window->LY;
X		for (row = 0, tmp = window->first_line; row < window->LY; row++)
X			tmp = tmp->next_screen;
X		if (window->LY == 0)
X			window->first_line = tmp->next_screen;
X		if (tmp->prev_screen != NULL)
X			tmp->prev_screen->next_screen = tmp->next_screen;
X		if (tmp->next_screen != NULL)
X		{
X			tmp->next_screen->changed = TRUE;
X			tmp->next_screen->scroll = UP;
X			tmp->next_screen->prev_screen = tmp->prev_screen;
X		}
X		tmpline = tmp;
X		clear_line(tmpline, 0, window->Num_cols);
X		tmpline->number = -1;
X		for (row = 0, tmp = window->first_line; tmp->next_screen != NULL; row++)
X			tmp = tmp->next_screen;
X		if (tmp != NULL)
X		{
X			tmp->next_screen = tmpline;
X			tmp->next_screen->prev_screen = tmp;
X			tmp->changed = TRUE;
X			tmp = tmp->next_screen;
X		}
X		else
X			tmp = tmpline;
X		tmp->next_screen = NULL;
X	}
X	else
X	{
X		clear_line(window->first_line, 0, window->Num_cols);
X	}
X}
X
Xwclrtobot(window)	/* delete from current position to end of the window */
XWINDOW *window;
X{
X	int row, column;
X	int Trow;
X	struct _line *tmp;
X
X	window->SCROLL_CLEAR |= CLEAR;
X	column = window->LX;
X	row = window->LY;
X	for (row = 0, tmp = window->first_line; row < window->LY; row++)
X		tmp = tmp->next_screen;
X	clear_line(tmp, column, window->Num_cols);
X	for (row = (window->LY + 1); row < window->Num_lines; row++)
X	{
X		tmp = tmp->next_screen;
X		clear_line(tmp, 0, window->Num_cols);
X	}
X	wmove(window, row, column);
X}
X
Xwstandout(window)	/* begin standout mode in window	*/
XWINDOW *window;
X{
X	if (Numbers[sg__] < 1)	/* if not magic cookie glitch	*/
X		window->Attrib |= A_STANDOUT;
X}
X
Xwstandend(window)	/* end standout mode in window	*/
XWINDOW *window;
X{
X	window->Attrib &= ~A_STANDOUT;
X}
X
Xwaddstr(window, string)	/* write 'string' in window	*/
XWINDOW *window;
Xchar *string;
X{
X	char *wstring;
X
X	for (wstring = string; *wstring != NULL; wstring++)
X		waddch(window, *wstring);
X}
X
Xclearok(window, flag)	/* erase screen and redraw at next refresh	*/
XWINDOW *window;
Xint flag;
X{
X	Repaint_screen = TRUE;
X}
X
Xecho()			/* turn on echoing				*/
X{
X	int value;
X
X#ifdef SYS5
X	Terminal.c_lflag |= ECHO;		/* enable echo		*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#else
X	Terminal.sg_flags |= ECHO;		/* enable echo		*/
X	value = ioctl(0, TIOCSETP, &Terminal);	/* set characteristics	*/
X#endif
X}
X
Xnoecho()		/* turn off echoing				*/
X{
X	int value;
X
X#ifdef SYS5
X	Terminal.c_lflag &= ~ECHO;		/* disable echo		*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#else
X	Terminal.sg_flags &= ~ECHO;		/* disable echo		*/
X	value = ioctl(0, TIOCSETP, &Terminal);	/* set characteristics	*/
X#endif
X}
X
Xraw()			/* set to read characters immediately		*/
X{
X	int value;
X	int old_arg;
X
X#ifdef SYS5
X	Intr = Terminal.c_cc[VINTR];	/* get the interrupt character	*/
X	Terminal.c_lflag &= ~ICANON;	/* disable canonical operation	*/
X	Terminal.c_lflag &= ~ISIG;	/* disable signal checking	*/
X#ifdef SUN
X	Terminal.c_lflag &= ~FLUSHO;
X	Terminal.c_lflag &= ~PENDIN;
X	Terminal.c_lflag &= ~IEXTEN;
X#endif
X	Terminal.c_cc[VMIN] = 1;		/* minimum of one character */
X	Terminal.c_cc[VTIME] = 255;		/* timeout value	*/
X	Terminal.c_cc[VINTR] = 0;		/* eliminate interrupt	*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#else
X	Terminal.sg_flags |= RAW;	/* enable raw mode		*/
X	value = ioctl(0, TIOCSETP, &Terminal);	/* set characteristics	*/
X/*	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg | FNDELAY);*/
X#endif
X}
X
Xnoraw()			/* set to normal character read mode		*/
X{
X	int value;
X	int old_arg;
X
X#ifdef SYS5
X	Terminal.c_lflag |= ICANON;	/* enable canonical operation	*/
X	Terminal.c_lflag |= ISIG;	/* enable signal checking	*/
X	Terminal.c_cc[VEOF] = 4;		/* EOF character = 4	*/
X	Terminal.c_cc[VEOL] = NULL;		/* EOL = 0		*/
X	Terminal.c_cc[VINTR] = Intr;		/* reset interrupt char	*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#else
X	Terminal.sg_flags &= ~RAW;	/* disable raw mode		*/
X	value = ioctl(0, TIOCSETP, &Terminal);	/* set characteristics	*/
X/*	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg & ~FNDELAY);*/
X#endif
X}
X
Xnl()
X{
X	int value;
X
X#ifdef SYS5
X	Terminal.c_iflag |= ICRNL;	/* enable carriage-return to line-feed mapping	*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#endif
X}
X
Xnonl()
X{
X	int value;
X
X#ifdef SYS5
X	Terminal.c_iflag &= ~ICRNL;	/* disable carriage-return to line-feed mapping	*/
X	Terminal.c_iflag &= ~IGNCR;	/* do not ignore carriage-return	*/
X	value = ioctl(0, TCSETA, &Terminal);	/* set characteristics	*/
X#endif
X}
X
Xsaveterm()
X{
X}
X
Xfixterm()
X{
X}
X
Xresetterm()
X{
X}
X
Xnodelay(window, flag)
XWINDOW *window;
Xint flag;
X{
X}
X
Xidlok(window, flag)
XWINDOW *window;
Xint flag;
X{
X}
X
Xkeypad(window, flag)
XWINDOW *window;
Xint flag;
X{
X	if (flag)
X		String_Out(String_table[ks__], NULL, 0);
X	else
X		String_Out(String_table[ke__], NULL, 0);
X}
X
Xsavetty()		/* save current tty stats			*/
X{
X	int value;
X
X#ifdef SYS5
X	value = ioctl(0, TCGETA, &Saved_tty);	/* set characteristics	*/
X#else
X	value = ioctl(0, TIOCGETP, &Saved_tty);	/* set characteristics	*/
X#endif
X}
X
Xresetty()		/* restore previous tty stats			*/
X{
X	int value;
X
X#ifdef SYS5
X	value = ioctl(0, TCSETA, &Saved_tty);	/* set characteristics	*/
X#else
X	value = ioctl(0, TIOCSETP, &Saved_tty);	/* set characteristics	*/
X#endif
X}
X
Xendwin()		/* end windows					*/
X{
X	keypad(stdscr, FALSE);
X	free(stdscr);
X	initialized = FALSE;
X	delwin(curscr);
X	delwin(virtual_scr);
X	delwin(stdscr);
X#ifndef SYS5
X{
X	int old_arg, value;
X/*	old_arg = fcntl(0, F_GETFL, 0);
X	value = fcntl(0, F_SETFL, old_arg & ~FNDELAY);*/
X}
X#endif
X}
X
Xdelwin(window)		/* delete the window structure			*/
XWINDOW *window;
X{
X	int i;
X
X	for (i = 1; (i < window->Num_lines) && (window->first_line->next_screen != NULL); i++)
X	{
X		window->first_line = window->first_line->next_screen;
X		free(window->first_line->prev_screen->row);
X		free(window->first_line->prev_screen->attributes);
X		free(window->first_line->prev_screen);
X	}
X	if (window == last_window_refreshed)
X		last_window_refreshed = 0;
X	if (window->first_line != NULL)
X	{
X		free(window->first_line->row);
X		free(window->first_line->attributes);
X		free(window->first_line);
X		free(window);
X	}
X}
X
Xwprintw(va_alist)
Xva_dcl
X{
X	WINDOW *window;
X	va_list ap;
X	char *format;
X	int value;
X	char *fpoint;
X	char *wtemp;
X
X	va_start(ap);
X	window = va_arg(ap, WINDOW *);
X	format = va_arg(ap, char *);
X	fpoint = format;
X	while (*fpoint != NULL)
X	{
X		if (*fpoint == '%')
X		{
X			fpoint++;
X			if (*fpoint == 'd')
X			{
X				value = va_arg(ap, int);
X				iout(window, value);
X			}
X			else if (*fpoint == 'c')
X			{
X				value = va_arg(ap, int);
X				waddch(window, value);
X			}
X			else if (*fpoint == 's')
X			{
X				wtemp = va_arg(ap, char *);
X					waddstr(window, wtemp);
X			}
X			fpoint++;
X		}
X		else if (*fpoint == '\\')
X		{
X			fpoint++;
X			if (*fpoint == 'n')
X				waddch(window, '\n');
X			else if ((*fpoint >= '0') && (*fpoint <= '9'))
X			{
X				value = 0;
X				while ((*fpoint >= '0') && (*fpoint <= '9'))
X				{
X					value = (value * 8) + (*fpoint - '0');
X					fpoint++;
X				}
X				waddch(window, value);
X			}
X			fpoint++;
X		}
X		else
X			waddch(window, *fpoint++);
X	}
X}
X
Xiout(window, value)	/* output characters		*/
XWINDOW *window;
Xint value;
X{
X	int i;
X
X	if ((i = value / 10) != 0)
X		iout(window, i);
X	waddch(window, ((value % 10) + '0'));
X}
X
XComp_line(line1, line2)		/* compare lines	*/
Xstruct _line *line1;
Xstruct _line *line2;
X{
X	int count1, count2;
X	int i;
X	char *att1, *att2;
X	char *c1, *c2;
X
X	c1 = line1->row;
X	c2 = line2->row;
X	att1 = line1->attributes;
X	att2 = line2->attributes;
X	count2 = strlen(c1) + 1;
X	count1 = strlen(c2) + 1;
X	if (count1 > count2)
X	{
X		i = count2;
X		count2 = count1;
X		count1 = i;
X	}
X	if (count2 > (count1 + count1))
X		return(2);
X	i = 0;
X	while ((c1[i] != NULL) && (c2[i] != NULL) && (c1[i] == c2[i]) && (att1[i] == att2[i]))
X		i++;
X	count1 = i + 1;
X	if ((count1 == 1) && (count2 == 1))
X		count1 = 0;			/* both lines blank	*/
X	else if (count2 == count1)
X		count1 = -1;			/* equal		*/
X	else
X		count1 = count2 / count1;	/* lines unequal	*/
X	return(count1);
X}
X
Xstruct _line *
XInsert_line(row, window)	/* insert line into screen */
Xint row;
XWINDOW *window;
X{
X	int i;
X	struct _line *tmp;
X	struct _line *tmp1;
X
X	for (i = 0, tmp = curscr->first_line; i < window->SR; i++)
X		tmp = tmp->next_screen;
X	top_of_win = tmp;
X	/*
X	 |	find bottom line to delete
X	 */
X	for (i = 1, tmp = top_of_win; (tmp->next_screen != NULL) && (i < window->Num_lines); i++)
X		tmp = tmp->next_screen;
X	if (tmp->prev_screen != NULL)
X		tmp->prev_screen->next_screen = tmp->next_screen;
X	if (tmp->next_screen != NULL)
X		tmp->next_screen->prev_screen = tmp->prev_screen;
X	/*
X	 |	clear deleted line
X	 */
X	tmp1 = tmp;
X	clear_line(tmp, 0, window->Num_cols);
X	tmp1->number = -1;
X	for (i = 0, tmp = curscr->first_line; (tmp->next_screen != NULL) && (i < window->SR); i++)
X		tmp = tmp->next_screen;
X	top_of_win = tmp;
X	for (i = 0, tmp = top_of_win; i < row; i++)
X		tmp = tmp->next_screen;
X	if ((tmp->prev_screen != NULL) && (window->Num_lines > 0))
X		tmp->prev_screen->next_screen = tmp1;
X	tmp1->prev_screen = tmp->prev_screen;
X	tmp->prev_screen = tmp1;
X	tmp1->next_screen = tmp;
X	if ((row + window->SR) == 0)
X		curscr->first_line = tmp1;
X	if (tmp1->next_screen != NULL)
X		tmp1 = tmp1->next_screen;
X/*	Position(window, (window->Num_lines -1), 0);
X	String_Out(String_table[dl__], NULL, 0);*/
X	Position(window, row, 0);
X	String_Out(String_table[al__], NULL, 0);
X	for (i = 0, top_of_win = curscr->first_line; (top_of_win->next_screen != NULL) && (i < window->SR); i++)
X		top_of_win = top_of_win->next_screen;
X	return(tmp1);
X}
X
Xstruct _line *
XDelete_line(row, window)	/* delete a line on screen */
Xint row;
XWINDOW *window;
X{
X	int i;
X	struct _line *tmp;
X	struct _line *tmp1;
X	struct _line *tmp2;
X
X	i = 0;
X	tmp = curscr->first_line;
X	while (i < window->SR)
X	{
X		i++;
X		tmp = tmp->next_screen;
X	}
X	/*
X	 |	find line to delete
X	 */
X	top_of_win = tmp;
X	if ((row + window->SR) == 0)
X		curscr->first_line = top_of_win->next_screen;
X	for (i = 0, tmp = top_of_win; i < row; i++)
X		tmp = tmp->next_screen;
X	if (tmp->prev_screen != NULL)
X		tmp->prev_screen->next_screen = tmp->next_screen;
X	if (tmp->next_screen != NULL)
X		tmp->next_screen->prev_screen = tmp->prev_screen;
X	tmp2 = tmp->next_screen;
X	tmp1 = tmp;
X	/*
X	 |	clear deleted line
X	 */
X	clear_line(tmp1, 0, window->Num_cols);
X	tmp1->number = -1;
X	/*
X	 |	find location to insert deleted line
X	 */
X	for (i = 0, tmp = curscr->first_line; (tmp->next_screen != NULL) && (i < window->SR); i++)
X		tmp = tmp->next_screen;
X	top_of_win = tmp;
X	for (i = 1, tmp = top_of_win; (i < window->Num_lines) && (tmp->next_screen != NULL); i++)
X		tmp = tmp->next_screen;
X	tmp1->next_screen = tmp->next_screen;
X	tmp1->prev_screen = tmp;
X	if (tmp1->next_screen != NULL)
X		tmp1->next_screen->prev_screen = tmp1;
X	tmp->next_screen = tmp1;
X	Position(window, row, 0);
X	String_Out(String_table[dl__], NULL, 0);
X/*	Position(window, (window->Num_lines -1), 0);
X	String_Out(String_table[al__], NULL, 0);*/
X	if (row == (window->Num_lines-1))
X		tmp2 = tmp1;
X	if ((row + window->SR) == 0)
X		curscr->first_line = top_of_win = tmp2;
X	return(tmp2);
X}
X
XCLEAR_TO_EOL(window, row, column)
XWINDOW *window;
Xint row, column;
X{
X	int x, y;
X	struct _line *tmp1;
X
X	for (y = 0, tmp1 = curscr->first_line; (y < (window->SR+row)) && (tmp1->next_screen != NULL); y++)
X		tmp1 = tmp1->next_screen;
X	for (x = column; x<window->Num_cols; x++)
X	{
X		tmp1->row[x] = ' ';
X		tmp1->attributes[x] = NULL;
X	}
X	tmp1->row[column] = NULL;
X	tmp1->last_char = column;
X	if (column < COLS)
X	{
X		if (String_table[ce__] != NULL)
X			String_Out(String_table[ce__], NULL, 0);
X		else
X		{
X			for (x = column; x < window->Num_cols; x++)
X				putchar(' ');
X		}
X	}
X}
X
Xcheck_delete(window, line, offset, pointer_new, pointer_old)
XWINDOW *window;
Xint line, offset;
Xstruct _line *pointer_new, *pointer_old;
X{
X	int end_old;
X	int end_new;
X	int k;
X	int i;
X	int changed;
X	char *old_lin;
X	char *new_lin;
X	char *old_att;
X	char *new_att;
X	
X	changed = FALSE;
X	new_lin = pointer_new->row;
X	new_att = pointer_new->attributes;
X	old_lin = pointer_old->row;
X	old_att = pointer_old->attributes;
X	end_old = end_new = offset;
X	while (((new_lin[end_new] != old_lin[end_old]) || (new_att[end_new] != old_att[end_old])) && (old_lin[end_old] != NULL) && (new_lin[end_old] != NULL))
X		end_old++;
X	if (old_lin[end_old] != NULL)
X	{
X		k = 0;
X		while ((old_lin[end_old+k] == new_lin[end_new+k]) && (new_att[end_new+k] == old_att[end_old+k]) && (new_lin[end_new+k] != NULL) && (old_lin[end_old+k] != NULL) && (k < 10))
X			k++;
X		if ((k > 8) || ((new_lin[end_new+k] == NULL) && (k != 0)))
X		{
X			if (new_lin[end_new+k] == NULL)
X			{
X				Position(window, line, (end_new+k));
X						CLEAR_TO_EOL(window, line, (end_new+k));
X			}
X			Position(window, line, offset);
X			for (k = offset; k < end_old; k++)
X				Char_del(old_lin, old_att, offset, window->Num_cols);
X			while ((old_lin[offset] != NULL) && (offset < COLS))
X				offset++;
X			pointer_old->last_char = offset;
X			changed = TRUE;
X		}
X	}
X	return(changed);
X}
X
Xcheck_insert(window, line, offset, pointer_new, pointer_old)
XWINDOW *window;
Xint line, offset;
Xstruct _line *pointer_new, *pointer_old;
X{
X	int changed;
X	int count1, count2;
X	int begin_old, begin_new;
X	int end_old, end_new;
X	int i, j, k;
X	int same = FALSE;
X	int old_off;
X	int insert;
X	char *old_lin;
X	char *new_lin;
X	char *old_att;
X	char *new_att;
X
X	changed = FALSE;
X	new_lin = pointer_new->row;
X	new_att = pointer_new->attributes;
X	old_lin = pointer_old->row;
X	old_att = pointer_old->attributes;
X	end_old = end_new = offset;
X	while (((new_lin[end_new] != old_lin[end_old]) || (new_att[end_new] != old_att[end_old])) && (new_lin[end_new] != NULL) && (old_lin[end_new] != NULL))
X		end_new++;
X	if (new_lin[end_new] != NULL)
X	{
X		k = 0;
X		while ((old_lin[end_old+k] == new_lin[end_new+k]) && (old_att[end_old+k] == new_att[end_new+k]) && (new_lin[end_new+k] != NULL) && (old_lin[end_old+k] != NULL) && (k < 10))
X			k++;
X		/*
X		 |  check for commonality between rest of lines (are the old 
X		 |  and new lines the same, except for a chunk in the middle?)
X		 |  if the rest of the lines are common, do not insert text
X		 */
X		old_off = end_new;
X		while ((old_lin[old_off] != NULL) && (new_lin[old_off] != NULL) && (old_lin[old_off] == new_lin[old_off]) && (old_att[old_off] == new_att[old_off]))
X			old_off++;
X		if ((old_lin[old_off] == new_lin[old_off]) && (old_att[old_off] == new_att[old_off]))
X			same = TRUE;
X		if ((!same) && ((k > 8) || ((new_lin[end_new+k] == NULL) && (k != 0))))
X		{
X			Position(window, line, offset);
X			insert = FALSE;
X			if (String_table[ic__] == NULL)
X			{
X				String_Out(String_table[im__], NULL, 0);
X				insert = TRUE;
X			}
X			for (k = offset; k < end_new; k++)
X			{
X				if (!insert)
X					String_Out(String_table[ic__], NULL, 0);
X				Char_ins(old_lin, old_att, new_lin[k], new_att[k], k, window->Num_cols);
X			}
X			if (insert)
X				String_Out(String_table[ei__], NULL, 0);
X/*				j += k;*/
X			while ((old_lin[offset] != NULL) && (offset < COLS))
X				offset++;
X			pointer_old->last_char = offset;
X			changed = TRUE;
X		}
X	}
X	return(changed);
X}
X
Xdoupdate()
X{
X	WINDOW *window;
X	int similar;
X	int diff;
X	int begin_old, begin_new;
X	int end_old, end_new;
X	int count1, j;
X	int from_top, tmp_ft, offset;
X	int changed;
X	int first_time;
X	int first_same;
X	int last_same;
X
X
X	struct _line *curr;
X	struct _line *virt;
X	struct _line *old;
X
X	struct _line *new;
X
X	char *cur_lin;
X	char *vrt_lin;
X	char *cur_att;
X	char *vrt_att;
X	char *att1, *att2;
X	char *c1, *c2;
X
X	window = virtual_scr;
X
X	if (Repaint_screen)
X	{
X		if (String_table[cl__])
X			String_Out(String_table[cl__], NULL, 0);
X		else
X		{
X			from_top = 0;
X			while (from_top < LINES)
X			{
X				Position(curscr, from_top, 0);
X				if (String_table[ce__] != NULL)
X					String_Out(String_table[ce__], NULL, 0);
X				else
X				{
X					for (j = 0; j < window->Num_cols; j++)
X						putchar(' ');
X				}
X				from_top++;
X			}
X		}
X		for (from_top = 0, curr = curscr->first_line; from_top < curscr->Num_lines; from_top++, curr = curr->next_screen)
X		{
X			Position(curscr, from_top, 0);
X			for (j = 0; (curr->row[j] != NULL) && (j < curscr->Num_cols); j++)
X			{
X				Char_out(curr->row[j], curr->attributes[j], curr->row, curr->attributes, j);
X			}
X			if (STAND)
X			{
X				STAND = FALSE;
X				Position(curscr, from_top, j);
X				attribute_off();
X			}
X		}
X		Repaint_screen = FALSE;
X	}
X
X	similar = 0;
X	diff = FALSE;
X	top_of_win = curscr->first_line;
X
X	for (from_top = 0, curr = top_of_win, virt = window->first_line; 
X			from_top < window->Num_lines; from_top++)
X	{
X		virtual_lines[from_top] = TRUE;
X		if ((similar = Comp_line(curr, virt)) > 0)
X		{
X			diff = TRUE;
X			virtual_lines[from_top] = FALSE;
X		}
X		curr = curr->next_screen;
X		virt = virt->next_screen;
X	}
X
X	from_top = 0;
X	virt = window->first_line;
X	curr = top_of_win;
X	similar = 0;
X	/*
X	 |  if the window has lines that are different
X	 */
X	if (diff)
X	{
X		last_same = -1;
X		changed = FALSE;
X		while ((from_top < window->Num_lines) && (String_table[al__]) && (String_table[dl__]))	/* check entire lines for diffs	*/
X		{
X
X			if (!virtual_lines[from_top])
X			{
X				for (first_same = window->Num_lines; (first_same > from_top) && (virtual_lines[first_same - 1]); first_same--)
X					;
X				count1 = first_same - 1;
X				diff = TRUE;
X				/*
X				 |	check for lines deleted (scroll up)
X				 */
X				for (tmp_ft = from_top+1, old = curr->next_screen; 
X					((window->scroll_up) && (diff) && 
X					(tmp_ft < window->Num_lines) && 
X					(!virtual_lines[tmp_ft]));
X						tmp_ft++)
X				{
X					if ((Comp_line(old, virt) == -1) && (!virtual_lines[tmp_ft]))
X					{
X						for (offset = (tmp_ft - from_top); (offset > 0); offset--)
X						{
X							old = Delete_line(from_top, window);
X							if (first_same < window->Num_lines)
X							{
X								old = Insert_line(count1, window);
X							}
X							else
X							{
X								Position(window, (window->Num_lines -1), 0);
X								String_Out(String_table[al__], NULL, 0);
X							}
X							window->scroll_up--;
X							diff = FALSE;
X						}
X						top_of_win = curscr->first_line;
X						curr = top_of_win;
X						for (offset = 0; offset < from_top; offset++)
X							curr = curr->next_screen;
X						for (offset = from_top, old=curr, new=virt; 
X						   offset < window->Num_lines; 
X						   old=old->next_screen, new=new->next_screen,
X						   offset++)
X						{
X							virtual_lines[offset] = TRUE;
X							if ((similar = Comp_line(old, new)) > 0)
X							{
X								virtual_lines[offset] = FALSE;
X							}
X						}
X					}
X					else
X						old = old->next_screen;
X				}
X				/*
X				 |	check for lines inserted (scroll down)
X				 */
X				for (tmp_ft = from_top-1, old = curr->prev_screen; 
X					((window->scroll_down) && (tmp_ft >= 0) && 
X					(diff) && 
X					(!virtual_lines[tmp_ft])); 
X					  tmp_ft--)
X				{
X					if (Comp_line(old, virt) == -1)
X					{
X						for (first_same = window->Num_lines; (first_same > from_top) && (virtual_lines[first_same - 1]); first_same--)
X							;
X						count1 = first_same -  1;
X						for (offset = (from_top - tmp_ft); (offset > 0); offset--)
X						{
X							if (first_same < window->Num_lines)
X							{
X								old = Delete_line(count1, window);
X							}
X							else
X							{
X								Position(window, (window->Num_lines -1), 0);
X								String_Out(String_table[dl__], NULL, 0);
X							}
X							old = Insert_line(tmp_ft, window);
X							window->scroll_down--;
X							diff = FALSE;
X						}
X						top_of_win = curscr->first_line;
X						curr = top_of_win;
X						for (offset = 0; offset < from_top; offset++)
X							curr = curr->next_screen;
X						for (offset = from_top, old=curr, new=virt; 
X						   offset < window->Num_lines; 
X						   old=old->next_screen, new=new->next_screen,
X						   offset++)
X						{
X							virtual_lines[offset] = TRUE;
X							if ((similar = Comp_line(old, new)) > 0)
X							{
X								virtual_lines[offset] = FALSE;
X							}
X						}
X					}
X					else
X						old = old->prev_screen;
X				}
X			}
X			from_top++;
X			curr = curr->next_screen;
X			virt = virt->next_screen;
X		}
X	}
X	for (from_top = 0, curr = curscr->first_line; from_top < window->SR; from_top++)
X		curr = curr->next_screen;
X	top_of_win = curr;
X	for (from_top = 0, curr = top_of_win, virt = window->first_line; from_top < window->Num_lines; from_top++, curr = curr->next_screen, virt = virt->next_screen)
X	{
X		if (((String_table[ic__]) || (String_table[im__])) && (String_table[dc__]) && (curr->row[0] != NULL))
X		{
X			j = 0;
X			first_time = TRUE;
X			vrt_lin = virt->row;
X			vrt_att = virt->attributes;
X			cur_lin = curr->row;
X			cur_att = curr->attributes;
X			while ((vrt_lin[j] != NULL) && (j < window->Num_cols))
X			{
X				if ((STAND) && (Booleans[xs__]))
X				{
X					while ((vrt_lin[j] == cur_lin[j]) && (vrt_att[j] == cur_att[j]) && (vrt_lin[j] != NULL) && (vrt_att[j]))
X						j++;
X					if ((STAND) && (!vrt_att[j]))
X					{
X						STAND = FALSE;
X						Position(window, from_top, j);
X						attribute_off();
X						attribute_off();
X					}
X				}
X				else
X				{
X					while ((vrt_lin[j] == cur_lin[j]) && (vrt_att[j] == cur_att[j]) && (vrt_lin[j] != NULL))
X						j++;
X				}
X				if ((vrt_att[j] != cur_att[j]) && (cur_att[j]) && (Booleans[xs__]))
X				{
X					Position(window, from_top, j);
X/*					CLEAR_TO_EOL(window, from_top, j);*/
X					attribute_off();
X					attribute_off();
X				}
X				if (vrt_lin[j] != NULL)
X				{
X					begin_new = j;
X					begin_old = j;
X					end_old = j;
X					end_new = j;
X					if ((first_time) && (virt->changed))
X					{
X						if (curr->last_char <= virt->last_char)
X							changed = check_insert(window, from_top, j, virt, curr);
X					}
X					changed = check_delete(window, from_top, j, virt, curr);
X					first_time = FALSE;
X					virt->changed = FALSE;
X					if (!changed)
X						changed = check_insert(window, from_top, j, virt, curr);
X					if (((!changed) || (cur_lin[j] != vrt_lin[j]) || (cur_att[j] != vrt_att[j])) && (j < window->Num_cols))
X					{
X						if ((vrt_lin[j] == ' ') && (cur_lin[j] == NULL) && (vrt_att[j] == cur_att[j]))
X							cur_lin[j] = ' ';
X						else
X						{
X							Position(window, from_top, j);
X							Char_out(vrt_lin[j], vrt_att[j], cur_lin, cur_att, j);
X						}
X					}
X					if ((vrt_lin[j] != NULL) && (cur_lin[j] != NULL))
X						j++;
X				}
X				if ((STAND) && (!vrt_att[j]))
X				{
X					STAND = FALSE;
X					Position(window, from_top, j);
X					attribute_off();
X				}
X			}
X			if ((vrt_lin[j] == NULL) && (cur_lin[j] != NULL))
X			{
X				Position(window, from_top, j);
X				CLEAR_TO_EOL(window, from_top, j);
X			}
X		}
X		else /*if ((similar != -1) && (similar != 0))*/
X		{
X			j = 0;
X			c1 = curr->row;
X			att1 = curr->attributes;
X			c2 = virt->row;
X			att2 = virt->attributes;
X			while ((j < window->Num_cols) && (c2[j] != NULL))
X			{
X				while ((c1[j] == c2[j]) && (att1[j] == att2[j]) && (j < window->Num_cols) && (c2[j] != NULL))
X					j++;
X				begin_old = j;
X				begin_new = j;
X				if ((j < window->Num_cols) && (c2[j] != NULL))
X				{
X					Position(window, from_top, begin_old);
X					CLEAR_TO_EOL(window, from_top, j);
X					Position(window, from_top, begin_old);
X					for (j = begin_old; (c2[j] != NULL) && (j < window->Num_cols); j++)
X						Char_out(c2[j], att2[j], c1, att1, j);
X				}
X			}
X			if ((c2[j] == NULL) && (c1[j] != NULL))
X			{
X				Position(window, from_top, j);
X				CLEAR_TO_EOL(window, from_top, j);
X			}
X		}
X		if (STAND)
X		{
X			STAND = FALSE;
X			Position(window, from_top, j);
X			attribute_off();
X		}
X		virt->number = from_top;
X	}
X	Position(window, window->LY, window->LX);
X}
X
XPosition(window, row, col)	/* position the cursor for output on the screen	*/
XWINDOW *window;
Xint row;
Xint col;
X{
X	int list[10];
X	int place;
X
X	int pos_row;
X	int pos_column;
X
X	pos_row = row + window->SR;
X	pos_column = col + window->SC;
X	if ((pos_row != Curr_y) || (pos_column != Curr_x))
X	{
X		if (String_table[cm__] != NULL) /* && (row < window->Num_lines) && (column < window->Num_cols))*/ 
X		{
X			place = 0;
X			list[place++] = pos_column;
X			list[place++] = pos_row;
X			String_Out(String_table[cm__], list, place);
X			if ((STAND) && (!Booleans[ms__]))
X				attribute_on();
X		}
X		Curr_x = pos_column;
X		Curr_y = pos_row;
X	}
X}
X
XChar_del(line, attrib, offset, maxlen)	/* delete chars from line	*/
Xchar *line;
Xchar *attrib;
Xint offset;
Xint maxlen;
X{
X	int one, two;
X
X	for (one = offset, two = offset+1; (line[one] != NULL) && (one < maxlen); one++, two++)
X	{
X		line[one] = line[two];
X		attrib[one] = attrib[two];
X	}
X	String_Out(String_table[dc__], NULL, 0);
X}
X
XChar_ins(line, attrib, newc, newatt, offset, maxlen)	/* insert chars in line	*/
Xchar *line;
Xchar *attrib;
Xchar newc;
Xchar newatt;
Xint offset;
Xint maxlen;
X{
X	int one, two;
X
X	one = 0;
X	while ((line[one] != NULL) && (one < (maxlen - 2)))
X		one++;
X	for (two = one + 1; (two > offset); one--, two--)
X	{
X		line[two] = line[one];
X		attrib[two] = attrib[one];
X	}
X	line[offset] = newc;
X	attrib[offset] = newatt;
X	Char_out(newc, newatt, line, attrib, offset);
X}
X
Xattribute_on()
X{
X	if (String_table[sa__])
X	{
X		attributes_set[0] = 1;
X		String_Out(String_table[sa__], attributes_set, 1);
X	}
X	else if (String_table[so__])
X		String_Out(String_table[so__], NULL, 0);
X}
X
Xattribute_off()
X{
X	if (String_table[me__])
X		String_Out(String_table[me__], NULL, 0);
X	else if (String_table[sa__])
X	{
X		attributes_set[0] = 0;
X		String_Out(String_table[sa__], attributes_set, 1);
X	}
X	else if (String_table[sa__])
X		String_Out(String_table[se__], NULL, 0);
X}
X
XChar_out(newc, newatt, line, attrib, offset)	/* output character with proper attribute	*/
Xchar newc;
Xchar newatt;
Xchar *line;
Xchar *attrib;
Xint offset;
X{
X
X
X	if ((newatt) && (!STAND))
X	{
X		STAND = TRUE;
X		attribute_on();
X	}
X	else if ((STAND) && (!newatt))
X	{
X		STAND = FALSE;
X		attribute_off();
X	}
X
X	if ((newatt) && (STAND) && (Booleans[xs__]))
X	{
X		attribute_on();
X	}
X
X	if (!((Curr_y >= (LINES - 1)) && (Curr_x >= (COLS - 1))))
X	{
X		putchar(newc);
X		line[offset] = newc;
X		attrib[offset] = newatt;
X	}
X	Curr_x++;
X}
X
END_OF_FILE
  if test 37082 -ne `wc -c <'new_curse.c.B'`; then
    echo shar: \"'new_curse.c.B'\" unpacked with wrong size!
  elif test -f 'new_curse.c.A'; then
    echo shar: Combining  \"'new_curse.c'\" \(73709 characters\)
    cat 'new_curse.c.A' 'new_curse.c.B' > 'new_curse.c'
    if test 73709 -ne `wc -c <'new_curse.c'`; then
      echo shar: \"'new_curse.c'\" combined with wrong size!
    else
      rm new_curse.c.A new_curse.c.B
    fi
  fi
  # end of 'new_curse.c.B'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
