Newsgroups: comp.sources.misc
From: pdh@netcom.com (Philip D. Howard)
Subject: v35i106:  bitio - portable bit stream function library, Part02/03
Message-ID: <1993Mar3.151915.14085@sparky.imd.sterling.com>
X-Md4-Signature: b4870c0b6b0e6e9918f419a2cd605fa9
Date: Wed, 3 Mar 1993 15:19:15 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pdh@netcom.com (Philip D. Howard)
Posting-number: Volume 35, Issue 106
Archive-name: bitio/part02
Environment: MS-DOS, UNIX, ANSI-C, BCC, GCC, MSC, PC, NeXT, Sparc, Sequent

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  bitio104/INSTALL bitio104/README bitio104/bit1get.c
#   bitio104/bit1put.c bitio104/bitclose.c bitio104/bitflush.c
#   bitio104/bithget.c bitio104/bitio.3 bitio104/bitio.h
#   bitio104/bitopen.c bitio104/bitput.h bitio104/bituse.c
#   bitio104/rand.h bitio104/randul.c bitio104/testio.h
#   bitio104/testmi.c bitio104/testmo.c
# Wrapped by kent@sparky on Wed Mar  3 09:07:10 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'bitio104/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/INSTALL'\"
else
  echo shar: Extracting \"'bitio104/INSTALL'\" \(3430 characters\)
  sed "s/^X//" >'bitio104/INSTALL' <<'END_OF_FILE'
X------------------------------------------------------------------------
XFor UNIX with GNU C Compiler:
X
XJust type "gmake".  The library "libbitio.a" will be created.  You can
Xthen "cp" or "mv" the library wherever you would like to have it for
Xyour own program development.
X
XIf you are on a NeXT system, your "cc" compiler should already be the
XGNU C Compiler.  Just link the name "gcc" to your compiler such as
Xwith the command:  "ln -s gcc /bin/cc" or if you "cc" compiler is
Xsomewhere else, but in your path, "ln -s gcc `which cc`".
X
XYou also have the command "gremake", "gclean", and "gvirgin".
X------------------------------------------------------------------------
XFor UNIX without GNU C Compiler:
X
XI have found that many compilers will not work well because BITIO is
Xwritten in ANSI Standard C and a lot of UNIX system vendors have not
Xkept up with software technology in the area of compiler and C language
Xstandards.  However, a few do work.  I have not yet tested a make setup
Xwith traditional and antique C compilers so I don't know what steps are
Xbest.  Start from the g*.mf makefiles and change the commands internally
Xas appropriate for your system.  Sorry about this not being easy.  These
Xare among the problems that inspired standards like ANSI Standard C.
X
XGood luck!
X------------------------------------------------------------------------
XFor MS-DOS with Borland C++ 3.1 (or maybe some other versions):
X
XThe command "bmake" will do all the compiling for you.  You will need
Xto edit and change the "bmake.bat" file to select a preferred memory
Xmodel.  Or you may compile all the C/H/L/M/S models using "bmakeall".
X
XYou also have the commands "bremake", "bclean", and "bvirgin".
X------------------------------------------------------------------------
XFor MS-DOS with MicroSoft C 6.00 (or maybe some other versions):
X
XThe command "mmake" will do all the compiling for you.  You will need
Xto edit and change the "mmake.bat" file to select a preferred memory
Xmodel.  Or you may compile all the C/H/L/M/S models using "mmakeall".
X
XYou also have the commands "mremake", "mclean", and "mvirgin".
X------------------------------------------------------------------------
XAlso compiled are a set of test programs.  You can run the tests by
Xdoing the command "test".  The first test verifies bit portability
Xby reading in a supplied bit stream file called "test.bit" and comparing
Xit to a random number sequence originally used to create the file.  The
Xsecond test uses the various functions and macros to first write a file
Xand then to read it back in.  A random number sequences controls the data
Xbeing processed.  The third test writes and reads data using only the
Xone bit macros for speed checking.  There is no actual timing included;
Xit is just a demonstration.  If you want to time the performance, you
Xwould need to deal with the particulars of you system.  For instance
Xtiming results will vary greatly on multi-user timesharing systems.
X------------------------------------------------------------------------
XI would appreciate feedback on problems getting this library to compile,
Xas well as problems using it.  Specific details are of course best and
Xare likely the only things I will be able to deal with.  I can be reached
Xby E-mail through Internet at pdh@netcom.com (CompuServe users will need
Xto use the Internet mail gateway).
X------------------------------------------------------------------------
END_OF_FILE
  if test 3430 -ne `wc -c <'bitio104/INSTALL'`; then
    echo shar: \"'bitio104/INSTALL'\" unpacked with wrong size!
  fi
  # end of 'bitio104/INSTALL'
fi
if test -f 'bitio104/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/README'\"
else
  echo shar: Extracting \"'bitio104/README'\" \(2465 characters\)
  sed "s/^X//" >'bitio104/README' <<'END_OF_FILE'
XVersion 1.04 of BITIO
X
XAuthor:		Philip D. Howard
XEmail:		pdh@netcom.com
X
XBITIO is a function library package that implements a bit stream on top
Xof a byte stream (8 bits per byte).  This bit stream is designed to be
Xexchangeable between different platforms and retain the same bit order
Xregardless of the endianness of the platforms.
X
XC programs may read and write 0 to 32 bits or more in each function
Xcall.  Special functions and macros are implemented for doing exactly
Xone bit at a time with less overhead.  The variable length functions
Xcome in versions that pass the data justified on the low order end of
Xthe unsigned long value, or on the high order end of the unsigned long
Xvalue.  The single bit functions always use the low order end (i.e. have
Xvalues 0 or 1).  Consistency is maintained through the use of all
Xfunctions and macros executed in any sequence.
X
XFor UNIX platforms, I have tested this program with the GNU C Compiler.
XThe makefiles are provided with this assumption.
X
XFor the MS-DOS platform, special makefiles are provided for Borland C
Xand MicroSoft C.  I have tested this package with Borland C++ 3.1 and
XMicroSoft C 6.00a.  Special BAT files are provided to make BITIO on
Xthese compilers:
X
XBCLEAN   or MCLEAN   make clean
XBMAKE    or MMAKE    make the library and test programs
XBMAKEALL or MMAKEALL make all memory models (CHLMS) of the library
XBREMAKE  or MREMAKE  make clean and make
XBVIRGIN  or MVIRGIN  make clean and virgin (delete .EXE and .LIB files)
X
XUnlike versions prior to 1.02, this version includes its own random
Xnumber generator for the test programs which is designed to produce
Xthe same random sequence on any platform (this has not been quite as
Xthoroughly tested as BITIO itself since some platforms were tested
Xonly on previous versions).
X
XThree tests are performed.
X
XTest 1 compares a random sequence against a distributed random data
Xfile (not the same in versions prior to 1.02) to ensure that
Xportability works.
X
XTest 2 writes random data and reads it back in to compare in order to
Xverify that the various operations are working consistently.  This test
X(and test 1) uses a mixture of the function calls to write and read the
Xdata, including the macros.  Alternative tests may be configured in the
Xfile TESTIO.H.
X
XTest 3 tests the macros BIT1PUT and BIT1GET for speed.  This is only a
Xdemostration test.  If you need actual timings, you will need to add
Xthe capability to capture it in or around these programs.
END_OF_FILE
  if test 2465 -ne `wc -c <'bitio104/README'`; then
    echo shar: \"'bitio104/README'\" unpacked with wrong size!
  fi
  # end of 'bitio104/README'
fi
if test -f 'bitio104/bit1get.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bit1get.c'\"
else
  echo shar: Extracting \"'bitio104/bit1get.c'\" \(2169 characters\)
  sed "s/^X//" >'bitio104/bit1get.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bit1get							|
X|purpose:	to input one bit from a bit stream file			|
X|									|
X|argument:	(BITFILE *) bit stream file to be read from		|
X|returns:	(int) data 0=0 1=1 -1=EOF -2=error			|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
Xint bit1get(
X	BITFILE *	bitstream
X)
X
X#else
X
Xint bit1get( bitstream )
X	BITFILE *	bitstream	;
X
X#endif
X
X{
X    if ( NULL == bitstream || 0 == ( BITIO_INPUT & bitstream->flags ) ) {
X	return ( -2 );
X    }
X
X    /*********************************\
X    |if the buffer is empty, refill it|
X    \*********************************/
X    if ( 0 == bitstream->bits ) {
X	bitstream->buf = getc( bitstream->cfile );
X	if ( EOF == bitstream->buf ) return ( -1 );
X	bitstream->bits = 8;
X    }
X
X    /**************\
X    |return one bit|
X    \**************/
X    return ( 1 & ( ( bitstream->buf ) >> ( --(bitstream->bits) ) ) );
X
X}
END_OF_FILE
  if test 2169 -ne `wc -c <'bitio104/bit1get.c'`; then
    echo shar: \"'bitio104/bit1get.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bit1get.c'
fi
if test -f 'bitio104/bit1put.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bit1put.c'\"
else
  echo shar: Extracting \"'bitio104/bit1put.c'\" \(2638 characters\)
  sed "s/^X//" >'bitio104/bit1put.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bit1put							|
X|purpose:	to output one bit to a bit stream file			|
X|									|
X|arguments:	1 (BITFILE *) bit stream file to be written to		|
X|		2 (int) one bit data (0 or 1) to be written		|
X|returns:	(int) ==EOF: error  !=EOF: ok				|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
Xint bit1put(
X	BITFILE *	bitstream	,
X	int		data
X)
X
X#else
X
Xint bit1put( bitstream , data )
X	BITFILE *	bitstream	;
X	int		data		;
X
X#endif
X
X{
X    if ( NULL == bitstream ) return ( EOF );
X    if ( 0 == ( BITIO_OUTPUT & bitstream->flags ) ) return ( EOF );
X
X    /**********************************************************\
X    |if the buffer is full, flush it before we try to add to it|
X    \**********************************************************/
X    if ( bitstream->bits == 8 ) {
X	putc( bitstream->buf , bitstream->cfile );
X	bitstream->bits = 0;
X	bitstream->buf = 0;
X    }
X
X    /**************************\
X    |add one bit to byte buffer|
X    \**************************/
X    ++(bitstream->bits);
X    bitstream->buf |= ( ( 1 & data ) << 8 ) >> bitstream->bits;
X
X    /********************************\
X    |if we filled up buffer, flush it|
X    \********************************/
X    if ( bitstream->bits == 8 ) {
X	putc( bitstream->buf , bitstream->cfile );
X	bitstream->bits = 0;
X	bitstream->buf = 0;
X    }
X
X    return ( 0 );
X}
END_OF_FILE
  if test 2638 -ne `wc -c <'bitio104/bit1put.c'`; then
    echo shar: \"'bitio104/bit1put.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bit1put.c'
fi
if test -f 'bitio104/bitclose.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitclose.c'\"
else
  echo shar: Extracting \"'bitio104/bitclose.c'\" \(2093 characters\)
  sed "s/^X//" >'bitio104/bitclose.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bitclose						|
X|purpose:	to close a bit stream					|
X|									|
X|note:		if the bit stream was opened with bituse() the file	|
X|		originally used remains open and usable for regular i/o |
X|									|
X|note:		if the bit stream was opened with bitopen() the file	|
X|		it uses is fully closed					|
X|									|
X|argument:	(BITFILE *) bit stream to be closed			|
X|returns:	(int) irrelevant					|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
Xint bitclose(
X	BITFILE *	bitstream
X)
X
X#else
X
Xint bitclose( bitstream )
X	BITFILE *	bitstream	;
X
X#endif
X
X{
X    if ( NULL == bitstream ) {
X	return ( -1 );
X    }
X
X    if ( 0 == ( BITIO_USEFILE & bitstream->flags )
X      && NULL != bitstream->cfile ) {
X	fclose( bitstream->cfile );
X    }
X
X    free( bitstream );
X
X    return ( 0 );
X}
END_OF_FILE
  if test 2093 -ne `wc -c <'bitio104/bitclose.c'`; then
    echo shar: \"'bitio104/bitclose.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitclose.c'
fi
if test -f 'bitio104/bitflush.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitflush.c'\"
else
  echo shar: Extracting \"'bitio104/bitflush.c'\" \(1990 characters\)
  sed "s/^X//" >'bitio104/bitflush.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bitflush						|
X|purpose:	to flush a bit stream, padding the last byte with 0s	|
X|		this will also flush the associated character file	|
X|									|
X|argument:	(BITFILE *) bit stream to be flushed			|
X|returns:	(int) irrelevant					|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
Xint bitflush(
X	BITFILE *	bitstream
X)
X
X#else
X
Xint bitflush( bitstream )
X	BITFILE *	bitstream	;
X
X#endif
X
X{
X    if ( NULL == bitstream || 0 == ( BITIO_OUTPUT & bitstream->flags ) ) {
X	return ( EOF );
X    }
X
X    if ( bitstream->bits > 0 ) {
X	putc( bitstream->buf , bitstream->cfile );
X	bitstream->bits = 0;
X	bitstream->buf = 0;
X    }
X
X    fflush( bitstream->cfile );
X
X    return ( 0 );
X}
END_OF_FILE
  if test 1990 -ne `wc -c <'bitio104/bitflush.c'`; then
    echo shar: \"'bitio104/bitflush.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitflush.c'
fi
if test -f 'bitio104/bithget.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bithget.c'\"
else
  echo shar: Extracting \"'bitio104/bithget.c'\" \(1989 characters\)
  sed "s/^X//" >'bitio104/bithget.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bithget							|
X|purpose:	to input bit data from a bit stream file		|
X|		data is high order justified				|
X|									|
X|arguments:	1 (BITFILE *) bit stream file to be read from		|
X|		2 (uint *) pointer to where actual count goes		|
X|		3 (uint) count of bits to get				|
X|returns:	(ulong) data from bit stream file			|
X|									|
X|note:		returned count is 0 for EOF, -1 for error		|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
Xulong bithget(
X	BITFILE *	bitstream	,
X	uint *		countptr	,
X	uint		count
X)
X
X#else
X
Xulong bithget( bitstream , countptr , count )
X	BITFILE *	bitstream	;
X	uint *		countptr	;
X	uint		count		;
X
X#endif
X
X#define BITIO_HIGH
X#include <bitget.h>
END_OF_FILE
  if test 1989 -ne `wc -c <'bitio104/bithget.c'`; then
    echo shar: \"'bitio104/bithget.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bithget.c'
fi
if test -f 'bitio104/bitio.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitio.3'\"
else
  echo shar: Extracting \"'bitio104/bitio.3'\" \(3985 characters\)
  sed "s/^X//" >'bitio104/bitio.3' <<'END_OF_FILE'
X
X
XBITIO(3)		BIT I/O FUNCTIONS		BITIO(3)
X
X
XNAME
X    bitopen, bituse, bitflush, bitclose,
X    bit1get, bithget, bitlget, bit1put, bithput, bitlput
X
X    do bit level file I/O
X
X
XSYNOPSIS
X    #include <bitio.h>
X
X    BITFILE * bitopen(onst char *name, const char *mode);
X
X    BITFILE * bituse(FILE *charstream, const char *mode);
X
X    int bitflush(BITFILE *bitstream);
X
X    int bitclose(BITFILE *bitstream);
X
X    int bit1get(BITFILE *bitstream );
X
X    unsigned long bithget(BITFILE *bitstream, unsigned int *countptr,
X	unsigned int count);
X
X    unsigned long bitlget(BITFILE *bitstream, unsigned int *countptr,
X	unsigned int count);
X
X    int bit1put(BITFILE *bitstream, int data);
X
X    int bithput(BITFILE *bitstream, unsigned long data,
X	unsigned int count);
X
X    int bitlput(BITFILE *bitstream, unsigned long data,
X	unsigned int count);
X
X    BIT1GET(bitstream);
X
X    BIT1PUT(bitstream,data);
X
X
XDESCRIPTION
X    bitopen() opens a named file for read, write, or append and returns
X    a pointer to the bit stream.
X
X    bituse() uses an already open character stream file as the medium
X    for a new bit stream, the pointer of which is returned.
X
X    bitflush() pads a partial character with 0 bits then flushes the
X    associated character stream.
X
X    bitclose() closes a bit stream, leaving the associated character
X    stream file open if bituse() created the bitstream.	 No padding is
X    done and partial characters will be lost.  Do bitflush() before
X    doing bitclose() if the final bits are definitely needed.
X
X    bit1get() gets a single bit from a bit stream.  BIT1GET() is also
X    available in macro implementation.
X
X    bithget() gets a specified number of bits from a bit stream and
X    returns them as a high order justified unsigned long.
X
X    bitlget() gets a specified number of bits from a bit stream and
X    returns them as a low order justified unsigned long.
X
X    bit1put() puts a single bit to a bit stream.  BIT1PUT() is also
X    available in macro implementation.
X
X    bithput() puts a specified number of bits, given as a high order
X    justified unsigned long, to a bit stream.
X
X    bitlput() puts a specified number of bits, given as a low order
X    justified unsigned long, to a bit stream.
X
X
X    Bits are written in "high order first" regardless of byte ordering
X    of platform/architecture.  This allows portability of bit files
X    between machines with unlike byte ordering which causes problems
X    in other circumstances.
X
X    The "1", "h", and "l" functions may be fully interleaved as needed
X    by the calling program since the buffering state is managed in a
X    consistent way.
X
X
XSEE ALSO
X    Standard I/O library.
X
X
XDIAGNOSTICS
X    bithget() and bitlget() set an unsigned int (pointed to be countptr)
X    to the number of bits actually gotten at EOF.   All subsequent calls
X    will set the return count to 0 indicating EOF.
X
X    bit1get() returns 0 or 1 for 1 bit of data, -1 for EOF, or -2 for error.
X
X    bitopen() and bituse() return a NULL pointer of an error occurs trying
X    to create the bitstream.
X
X
XBUGS
X    bitclose() does not flush partial characters.  However this allows
X    such a choice since bitflush() be used for force such a flush before
X    doing a bitclose().
X
X    BIT1GET() and BIT1PUT() are implemented as macros and have certain
X    side effects on arguments, including multiple evaluation.
X
X    Bits written by successful bit*put() functions may actually not be
X    written when later errors occur due to bit buffering (and asscociated
X    character file buffering).
X
X    Bits are not necessarily written in the order that may be "natural"
X    for certain particular platforms or architectures.	They are instead
X    written in a way that allows like programs on different platforms
X    to be able to read the bits in exactly the same order originally
X    written.
X
X    There are no bit level equivalents to ungetc(), fgetpos(),	fseek(),
X    fsetpos(), ftell(), or rewind().
X
X
XAUTHOR
X    Philip D. Howard, pdh@netcom.com
X
X
END_OF_FILE
  if test 3985 -ne `wc -c <'bitio104/bitio.3'`; then
    echo shar: \"'bitio104/bitio.3'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitio.3'
fi
if test -f 'bitio104/bitio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitio.h'\"
else
  echo shar: Extracting \"'bitio104/bitio.h'\" \(5672 characters\)
  sed "s/^X//" >'bitio104/bitio.h' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X
X/***********************************************************************\
X|header:	bitio.h							|
X|purpose:	definitions and declarations for the bitio library	|
X\***********************************************************************/
X
X/***********************************************************************\
X|configure the compilation						|
X\***********************************************************************/
X#define BITIO_CHECK_ERROR 1
X
X
X/***********************************************************************\
X|do library includes							|
X\***********************************************************************/
X#include <limits.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <errno.h>
X
X
X/***********************************************************************\
X|define the size of type long if not yet defined			|
X\***********************************************************************/
X#ifndef LONG_BIT
X#define LONG_BIT ( CHAR_BIT * sizeof ( long ) )
X#endif
X
X
X/***********************************************************************\
X|define abbreviated types						|
X\***********************************************************************/
Xtypedef unsigned long ulong;
Xtypedef unsigned int uint;
X
X
X/***********************************************************************\
X|define data structs							|
X\***********************************************************************/
Xstruct BITFILE {
X    FILE *		cfile	;
X    uint		flags	;
X    uint		bits	;
X    int			buf	;
X};
X
Xtypedef struct BITFILE BITFILE;
X
X
X/***********************************************************************\
X|define flags								|
X\***********************************************************************/
X#define BITIO_INPUT	1	/* bit stream is input */
X#define BITIO_OUTPUT	2	/* bit stream is output */
X#define BITIO_USEFILE	4	/* bit stream created by bituse() */
X
X
X/***********************************************************************\
X|define macros								|
X\***********************************************************************/
X
X/***********************************************************************\
X|macro:		BIT1GET							|
X|purpose:	to input one bit from a bit stream file			|
X|									|
X|argument:	(BITFILE *) bit stream file to be read from		|
X|returns:	(int) data 0=0 1=1 -1=EOF				|
X\***********************************************************************/
X#define BIT1GET(bs)							\
X(									\
X    (									\
X	0 == (bs)->bits							\
X	&&								\
X	(								\
X	    (bs)->bits = 8						\
X	    ,								\
X	    EOF == ( (bs)->buf = getc( (bs)->cfile ) )			\
X	)								\
X    )									\
X    ?									\
X    (									\
X	(bs)->bits = 0							\
X	,								\
X	-1								\
X    )									\
X    :									\
X    (									\
X	1 & ( (uint) (bs)->buf >> ( --( (bs)->bits ) ) )	\
X    )									\
X)
X
X
X/***********************************************************************\
X|macro:		BIT1PUT							|
X|purpose:	to output one bit to a bit stream file			|
X|									|
X|arguments:	1 (BITFILE *) bit stream file to be written to		|
X|		2 (int) one bit data (0 or 1) to be written		|
X|returns:	0							|
X\***********************************************************************/
X#define BIT1PUT(bs,d)							\
X(									\
X    (bs)->buf |= ( ( 1 & (d) ) << 8 ) >> ( ++( (bs)->bits ) )		\
X    ,									\
X    (									\
X	( 8 == (bs)->bits )						\
X	?								\
X	(								\
X	    putc( (bs)->buf , (bs)->cfile )				\
X	    ,								\
X	    (bs)->buf = (bs)->bits = 0					\
X	)								\
X	:								\
X	0								\
X    )									\
X)
X
X
X/***********************************************************************\
X|declare functions							|
X\***********************************************************************/
Xint bit1get(
X#ifdef __STDC__
X	BITFILE *	bitstream
X#endif
X);
X
Xint bit1put(
X#ifdef __STDC__
X	BITFILE *	bitstream	,
X	int		data
X#endif
X);
X
Xint bitclose(
X#ifdef __STDC__
X	BITFILE *	bitstream
X#endif
X);
X
Xint bitflush(
X#ifdef __STDC__
X	BITFILE *	bitstream
X#endif
X);
X
Xulong bithget(
X#ifdef __STDC__
X	BITFILE *	bitstream	,
X	uint *		countptr	,
X	uint		count
X#endif
X);
X
Xint bithput(
X#ifdef __STDC__
X	BITFILE *	bitstream	,
X	ulong		data		,
X	uint		count
X#endif
X);
X
Xulong bitlget(
X#ifdef __STDC__
X	BITFILE *	bitstream	,
X	uint *		countptr	,
X	uint		count
X#endif
X);
X
Xint bitlput(
X#ifdef __STDC__
X	BITFILE *	bitstream	,
X	ulong		data		,
X	uint		count
X#endif
X);
X
XBITFILE * bitopen(
X#ifdef __STDC__
X	const char *	name		,
X	const char *	mode
X#endif
X);
X
XBITFILE * bituse(
X#ifdef __STDC__
X	FILE *		charstream	,
X	const char *	mode
X#endif
X);
END_OF_FILE
  if test 5672 -ne `wc -c <'bitio104/bitio.h'`; then
    echo shar: \"'bitio104/bitio.h'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitio.h'
fi
if test -f 'bitio104/bitopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitopen.c'\"
else
  echo shar: Extracting \"'bitio104/bitopen.c'\" \(2744 characters\)
  sed "s/^X//" >'bitio104/bitopen.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bitopen							|
X|purpose:	to open a bit stream file				|
X|									|
X|note:		when the bit stream is closed by bitclose() the		|
X|		stream file will also be closed				|
X|									|
X|arguments:	1 (char *) name of file to be opened			|
X|		2 (char *) mode string					|
X|returns:	(BITFILE *) bit stream pointer				|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
XBITFILE * bitopen(
X	const char *	name		,
X	const char *	mode
X)
X
X#else
X
XBITFILE * bitopen( name , mode )
X	const char *	name		;
X	const char *	mode		;
X
X#endif
X
X{
X    BITFILE *		bitstream	;
X    FILE *		charstream	;
X    char *		bmode		;
X    uint		flags		;
X
X    if ( NULL == name || '\0' == *name ) return ( NULL );
X
X    if ( '+' == mode[1] || '+' == mode[2] ) return ( NULL );
X
X    if ( 'r' == mode[0] ) {
X	flags = BITIO_INPUT;
X	bmode = "rb";
X    } else if ( 'w' == mode[0] ) {
X	flags = BITIO_OUTPUT;
X	bmode = "wb";
X    } else if ( 'a' == mode[0] ) {
X	flags = BITIO_OUTPUT;
X	bmode = "ab";
X    } else {
X	return ( NULL );
X    }
X
X    bitstream = (BITFILE *) malloc( sizeof ( BITFILE ) );
X    if ( NULL == bitstream ) return ( NULL );
X
X    charstream = fopen( name , bmode );
X    if ( NULL == charstream ) {
X	free( bitstream );
X	return ( NULL );
X    }
X
X#ifdef __MSDOS__
X    setvbuf( charstream , NULL , _IOFBF , 4096 );
X#endif
X
X    bitstream->flags = flags;
X    bitstream->cfile = charstream;
X    bitstream->bits = 0;
X    bitstream->buf = 0;
X
X    return ( bitstream );
X}
END_OF_FILE
  if test 2744 -ne `wc -c <'bitio104/bitopen.c'`; then
    echo shar: \"'bitio104/bitopen.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitopen.c'
fi
if test -f 'bitio104/bitput.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bitput.h'\"
else
  echo shar: Extracting \"'bitio104/bitput.h'\" \(4193 characters\)
  sed "s/^X//" >'bitio104/bitput.h' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|header:	bitput							|
X|purpose:	to output bit data to a bit stream file			|
X|		generate code for bithget.c or bitlget.c		|
X|									|
X|arguments:	1 (BITFILE *) bit stream file to be written to		|
X|		2 (ulong) bit data to be written			|
X|		3 (uint) count of bits to be written			|
X|returns:	(int) ==EOF: error  !=EOF: ok				|
X\***********************************************************************/
X{
X    /********************************************\
X    |this is an array, indexed by n, of one byte |
X    |masks with n bits on from the high order end|
X    \********************************************/
X    static unsigned char mask[8] = {0,128,192,224,240,248,252,254};
X
X    /*************************************************\
X    |if the count is zero, then there is nothing to do|
X    \*************************************************/
X    if ( count == 0 ) return ( 0 );
X
X#ifdef BITIO_CHECK_ERROR
X    /***********************************************************\
X    |if the bit stream file pointer is NULL then return an error|
X    \***********************************************************/
X    if ( NULL == bitstream ) return ( EOF );
X
X    /******************************************************************\
X    |if the bit stream file is not open for output then return an error|
X    \******************************************************************/
X    if ( 0 == ( BITIO_OUTPUT & bitstream->flags ) ) return ( EOF );
X#endif
X
X#ifdef BITIO_LOW
X    /*************************************\
X    |put data into the high order position|
X    \*************************************/
X    data <<= LONG_BIT - count;
X#endif
X
X    /******************************\
X    |try to fill up the byte buffer|
X    \******************************/
X    bitstream->buf |= (uint) ( data >> ( LONG_BIT - 8 ) ) >> bitstream->bits;
X
X    /*****************************************\
X    |if it is not full yet, mask it and return|
X    \*****************************************/
X    if ( ( bitstream->bits + count ) < 8 ) {
X	bitstream->buf &= (uint) mask[ bitstream->bits += count ];
X	return ( 0 );
X    }
X
X    /************************************\
X    |output the full byte from the buffer|
X    \************************************/
X    putc( bitstream->buf , bitstream->cfile );
X
X    /**************************\
X    |realign the remaining data|
X    \**************************/
X    data <<= ( 8 - bitstream->bits );
X    count -= ( 8 - bitstream->bits );
X
X    /**************************\
X    |output all the whole bytes|
X    \**************************/
X    while ( count >= 8 ) {
X	putc( (uint) ( data >> ( LONG_BIT - 8 ) ), bitstream->cfile );
X	data <<= 8;
X	count -= 8;
X    }
X
X    /*****************************************\
X    |put any remaining portion into the buffer|
X    \*****************************************/
X    bitstream->bits = count;
X    bitstream->buf = (uint) ( ( data >> ( LONG_BIT - 8 ) ) & mask[ count ] );
X
X    return ( 0 );
X}
END_OF_FILE
  if test 4193 -ne `wc -c <'bitio104/bitput.h'`; then
    echo shar: \"'bitio104/bitput.h'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bitput.h'
fi
if test -f 'bitio104/bituse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/bituse.c'\"
else
  echo shar: Extracting \"'bitio104/bituse.c'\" \(2544 characters\)
  sed "s/^X//" >'bitio104/bituse.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|function:	bituse							|
X|purpose:	to use an open character stream file for bit stream i/o |
X|									|
X|note:		when the bit stream is closed by bitclose() the used	|
X|		stream file remains open and usable for regular i/o	|
X|									|
X|note:		the character stream should be opened for binary i/o	|
X|		this is generally not relevant on UNIX platforms	|
X|									|
X|arguments:	1 (FILE *) character stream file to be used		|
X|		2 (char *) mode string "r" or "w"			|
X|returns:	(BITFILE *) bit stream pointer				|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
X
XBITFILE * bituse(
X	FILE *		charstream	,
X	const char *	mode
X)
X
X#else
X
XBITFILE * bituse( charstream , mode )
X	FILE *		charstream	;
X	char *		mode		;
X
X#endif
X
X{
X    BITFILE *		bitstream		;
X    uint		flags		;
X
X    if ( NULL == charstream ) return ( NULL );
X
X    if ( 'r' == *mode ) flags = BITIO_INPUT;
X    else if ( 'w' == *mode || 'a' == *mode ) flags = BITIO_OUTPUT;
X
X    if ( 0 == flags ) return ( NULL );
X
X    bitstream = (BITFILE *) malloc( sizeof ( BITFILE ) );
X    if ( NULL == bitstream ) return ( NULL );
X
X    bitstream->flags = flags | BITIO_USEFILE;
X    bitstream->cfile = charstream;
X    bitstream->bits = 0;
X    bitstream->buf = 0;
X
X    return ( bitstream );
X}
END_OF_FILE
  if test 2544 -ne `wc -c <'bitio104/bituse.c'`; then
    echo shar: \"'bitio104/bituse.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/bituse.c'
fi
if test -f 'bitio104/rand.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/rand.h'\"
else
  echo shar: Extracting \"'bitio104/rand.h'\" \(2222 characters\)
  sed "s/^X//" >'bitio104/rand.h' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms if the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X/***********************************************************************\
X|header:	rand.h							|
X|purpose:	define compile configuration and declare functions for  |
X|		an extended state int/long random number generator	|
X\***********************************************************************/
X#include <limits.h>
X
X#define RANDI_MAX INT_MAX
X#define RANDUI_MAX UINT_MAX
X#define RANDL_MAX LONG_MAX
X#define RANDUL_MAX ULONG_MAX
X
X#define RANDI_SEED_CYCLE (sizeof(int)*CHAR_BIT)
X#define RANDUI_SEED_CYCLE (sizeof(unsigned int)*CHAR_BIT)
X#define RANDL_SEED_CYCLE (sizeof(long)*CHAR_BIT)
X#define RANDUL_SEED_CYCLE (sizeof(unsigned long)*CHAR_BIT)
X
X#define RANDI_SEED_INIT 1
X#define RANDUI_SEED_INIT 1
X#define RANDL_SEED_INIT 1
X#define RANDUL_SEED_INIT 1
X
X#define RANDI_STATE_SIZE 8
X#define RANDUI_STATE_SIZE 8
X#define RANDL_STATE_SIZE 8
X#define RANDUL_STATE_SIZE 8
X
Xint randi(void);
Xunsigned int randui(void);
Xlong randl(void);
Xunsigned long randul(void);
X
Xvoid srandi(int);
Xvoid srandui(unsigned int);
Xvoid srandl(long);
Xvoid srandul(unsigned long);
END_OF_FILE
  if test 2222 -ne `wc -c <'bitio104/rand.h'`; then
    echo shar: \"'bitio104/rand.h'\" unpacked with wrong size!
  fi
  # end of 'bitio104/rand.h'
fi
if test -f 'bitio104/randul.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/randul.c'\"
else
  echo shar: Extracting \"'bitio104/randul.c'\" \(2571 characters\)
  sed "s/^X//" >'bitio104/randul.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms if the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X#include <rand.h>
X
Xstatic unsigned long	state	[ RANDUL_STATE_SIZE ] = { RANDUL_SEED_INIT };
Xstatic unsigned int	init	= 1;
X
X/***********************************************************************\
X|function:	randul							|
X|purpose:	generate random number of type unsigned long		|
X|									|
X|arguments:	-none-							|
X|returns:	(unsigned long) random number				|
X\***********************************************************************/
Xunsigned long randul()
X{
X    unsigned long l;
X    unsigned long n;
X    unsigned int i;
X    unsigned int k;
X
X    k = 1;
X    if ( init ) {
X	init = 0;
X	n = state[ 0 ];
X	for ( i = 1 ; i < RANDUL_STATE_SIZE ; ++i ) {
X	    state[ i ] = n;
X	}
X	k = RANDUL_SEED_CYCLE;
X    }
X
X    while ( k ) {
X	n = 1;
X	for ( i = 0 ; i < RANDUL_STATE_SIZE ; ++i ) {
X	    l = n;
X	    l |= state[ i ];
X	    n += state[ i ];
X	    state[ i ] = n;
X	    if ( n < l ) ++n;
X	}
X	state[ 0 ] = n;
X	--k;
X    }
X
X    return ( n );
X}
X
X/***********************************************************************\
X|function:	srandul							|
X|purpose:	seed the random number generator			|
X|									|
X|argument:	(unsigned long) seed					|
X|returns:	(void)							|
X\***********************************************************************/
X#ifdef __STDC__
X
Xvoid srandul(
X	unsigned long	seed
X)
X
X#else
X
Xint srandul( seed )
X	unsigned long	seed	;
X
X#endif
X
X{
X    state[ 0 ] = seed;
X    init = 1;
X    return;
X}
END_OF_FILE
  if test 2571 -ne `wc -c <'bitio104/randul.c'`; then
    echo shar: \"'bitio104/randul.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/randul.c'
fi
if test -f 'bitio104/testio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/testio.h'\"
else
  echo shar: Extracting \"'bitio104/testio.h'\" \(4580 characters\)
  sed "s/^X//" >'bitio104/testio.h' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X#define MAXERRS 10
X
X#define TEST1 1
X#define TESTH 1
X#define TESTL 1
X#define TESTM 1
X
X#include <bitio.h>
X
X#include <randul.c>
X
X#ifdef __STDC__
Xmain(int argc,char **argv)
X#else
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X#endif
X{
X    BITFILE *		bitfile ;
X    unsigned long	nn	;
X    unsigned long	data	;
X    unsigned long	count	;
X    unsigned long	total	;
X#ifdef INPUT
X    unsigned long	cmp	;
X    unsigned long	errs	;
X    unsigned long	maxerrs ;
X    unsigned int	gotbits ;
X#endif
X    unsigned int	bits	;
X
X    if ( argc < 3 ) {
X	fprintf(stderr,"arguments count seed\n");
X	exit(1);
X    }
X
X#ifdef OUTPUT
X    bitfile = bitopen( argv[1] , "w" );
X#endif
X#ifdef INPUT
X    bitfile = bitopen( argv[1] , "r" );
X    errs = 0;
X    maxerrs = MAXERRS;
X    if ( argc > 4 ) maxerrs = atol( argv[4] );
X#endif
X
X    count = atol( argv[2] );
X    srandul( atoi( argv[3] ) );
X    total = 0;
X    for ( nn = 0 ; nn < count ; ++nn ) {
X
X#if TESTM > 0
X	data = 1 & randul();
X#ifdef OUTPUT
X	BIT1PUT( bitfile , (unsigned int) data );
X#endif
X#ifdef INPUT
X	cmp = (unsigned long) BIT1GET( bitfile );
X	if ( cmp > 1 ) {
X	    fprintf(stderr,"0 unexpected value %08lx at %lu\n",cmp,total+1);
X	    exit(1);
X	}
X	if ( cmp != data ) {
X	    fprintf(stderr,"0 expected %08lx  got %08lx	 (one bit at %lu)\n",data,cmp,total);
X	    if ( ++errs >= maxerrs ) exit(1);
X	}
X#endif
X	++total;
X#endif
X
X#if TEST1 > 0
X	data = 1 & randul();
X#ifdef OUTPUT
X	bit1put( bitfile , (unsigned int) data );
X#endif
X#ifdef INPUT
X	cmp = (unsigned long) bit1get( bitfile );
X	if ( cmp > 1 ) {
X	    fprintf(stderr,"1 unexpected value %08lx at %lu\n",cmp,total+1);
X	    exit(1);
X	}
X	if ( cmp != data ) {
X	    fprintf(stderr,"1 expected %08lx  got %08lx	 (one bit at %lu)\n",data,cmp,total);
X	    if ( ++errs >= maxerrs ) exit(1);
X	}
X#endif
X	++total;
X#endif
X
X#if TESTL > 0
X	data = 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	bits = 1 + (unsigned int) ( 31 & randul() );
X	data &= 0xffffffffL >> (unsigned int) ( 32 - bits );
X
X#ifdef OUTPUT
X	bitlput( bitfile , data , bits );
X#endif
X#ifdef INPUT
X	cmp = bitlget( bitfile , & gotbits , bits );
X	if ( gotbits < bits ) {
X	    fprintf(stderr,"unexpected EOF at %lu\n",total+gotbits);
X	    exit(1);
X	}
X	if ( bits && cmp != data ) {
X	    fprintf(stderr,"l expected %08lx  got %08lx	 (%02u bits at %lu)\n",data,cmp,bits,total);
X	    if ( ++errs >= maxerrs ) exit(1);
X	}
X#endif
X	total += bits;
X#endif
X
X#if TESTH > 0
X	data = 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	data <<= 8;
X	data |= 255 & randul();
X	bits = 1 + (unsigned int) ( 0x1f & randul() );
X	data &= 0xffffffffL << ( 32 - bits );
X
X#ifdef OUTPUT
X	bithput( bitfile , data , bits );
X#endif
X#ifdef INPUT
X	cmp = bithget( bitfile , & gotbits , bits );
X	if ( gotbits < bits ) {
X	    fprintf(stderr,"unexpected EOF at %lu\n",total+gotbits);
X	    exit(1);
X	}
X	if ( bits && cmp != data ) {
X	    fprintf(stderr,"h expected %08lx  got %08lx	 (%02u bits at %lu)\n",data,cmp,bits,total);
X	    if ( ++errs >= maxerrs ) exit(1);
X	}
X#endif
X	total += bits;
X#endif
X
X    }
X
X    bitflush( bitfile );
X    bitclose( bitfile );
X
X#ifdef OUTPUT
X    fprintf(stderr,"total bits out = %lu (%08lx)\n",total,total);
X#endif
X#ifdef INPUT
X    fprintf(stderr,"total bits in  = %lu (%08lx)\n",total,total);
X    fprintf(stderr,"total errors   = %u\n",errs);
X#endif
X
X    return ( 0 );
X}
END_OF_FILE
  if test 4580 -ne `wc -c <'bitio104/testio.h'`; then
    echo shar: \"'bitio104/testio.h'\" unpacked with wrong size!
  fi
  # end of 'bitio104/testio.h'
fi
if test -f 'bitio104/testmi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/testmi.c'\"
else
  echo shar: Extracting \"'bitio104/testmi.c'\" \(2107 characters\)
  sed "s/^X//" >'bitio104/testmi.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
Xmain(int argc,char **argv)
X#else
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X#endif
X{
X    BITFILE *		bitfile ;
X    unsigned long	ii	;
X    unsigned int	m,n	;
X    int			b	;
X    int			errs	;
X    int			maxerrs = 20;
X
X    if ( argc <= 1 ) {
X	fprintf(stderr,"syntax: testmi filename\n");
X	exit(1);
X    }
X
X    bitfile = bitopen( argv[1] , "r" );
X    if ( NULL == bitfile ) {
X	fprintf(stderr,"unable to open file: %s\n",argv[1]);
X	exit(1);
X    }
X
X    errs = 0;
X    m = n = 0;
X    ii = 0;
X    for (;;) {
X	m += (unsigned int) ii;
X	n += m;
X	b = BIT1GET( bitfile );
X	if ( b < 0 ) break;
X	if ( b != ( 1 & n ) ) {
X	    fprintf(stderr,"mismatch at %lu\n",ii);
X	    if ( ++errs >= maxerrs ) {
X		fprintf(stderr,"abort\n");
X		bitclose( bitfile );
X		exit(1);
X	    }
X	}
X	m += n >> 12;
X	++ii;
X    }
X
X    if ( b < -1 ) {
X	fprintf(stderr,"error in input bit stream\n");
X    }
X
X    bitclose( bitfile );
X
X    return ( 0 );
X}
END_OF_FILE
  if test 2107 -ne `wc -c <'bitio104/testmi.c'`; then
    echo shar: \"'bitio104/testmi.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/testmi.c'
fi
if test -f 'bitio104/testmo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitio104/testmo.c'\"
else
  echo shar: Extracting \"'bitio104/testmo.c'\" \(1804 characters\)
  sed "s/^X//" >'bitio104/testmo.c' <<'END_OF_FILE'
X/***********************************************************************\
X|   Copyright (C) 1993 - by Philip David Howard - all rights reserved	|
X|									|
X|   This library is free software; you may redistribute it and/or	|
X|   modify it under the terms of the GNU Library General Public		|
X|   License as published by the Free Software Foundation; either	|
X|   version 2 of the license, or (at your option) any later version.	|
X|									|
X|   This library is distributed in the hope that it will be useful,	|
X|   but WITHOUT ANY WARRANTY; without even the implied warranty of	|
X|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	|
X|   GNU Library General Public License for more details.		|
X|									|
X|   You should have received a copy of the GNU Library General Public	|
X|   License along with this library.  If not, write to the Free		|
X|   Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	|
X|									|
X|author:	Philip D. Howard (ka9wgn)				|
X|email:		pdh@netcom.com						|
X|postal:	PO Box 5012;  Champaign, IL  61825-5012			|
X|voice/fax:	217-384-4934						|
X\***********************************************************************/
X#include <bitio.h>
X
X#ifdef __STDC__
Xmain(int argc,char **argv)
X#else
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X#endif
X{
X    BITFILE *		bitfile ;
X    unsigned long	ii,kk	;
X    unsigned int	m,n	;
X
X    if ( argc <= 2 ) {
X	fprintf(stderr,"syntax: testmo filename count\n");
X	exit(1);
X    }
X
X    kk = atol( argv[2] );
X    bitfile = bitopen( argv[1] , "w" );
X    if ( NULL == bitfile ) {
X	fprintf(stderr,"unable to open file: %s\n",argv[1]);
X	exit(1);
X    }
X
X    m = n = 0;
X    for ( ii = 0; ii < kk; ++ii ) {
X	m += (unsigned int) ii;
X	n += m;
X	BIT1PUT( bitfile , n );
X	m += n >> 12;
X    }
X
X    bitclose( bitfile );
X
X    return ( 0 );
X}
END_OF_FILE
  if test 1804 -ne `wc -c <'bitio104/testmo.c'`; then
    echo shar: \"'bitio104/testmo.c'\" unpacked with wrong size!
  fi
  # end of 'bitio104/testmo.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
