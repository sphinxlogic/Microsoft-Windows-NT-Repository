Newsgroups: comp.sources.misc
From: morris@netcom.com (Jim Morris)
Subject: v35i001:  splash - Small Perl-like List And String Handling class lib, v1.8, Patch01
Message-ID: <1993Jan20.232429.21589@sparky.imd.sterling.com>
X-Md4-Signature: 51012b5e6bde1eb23c063b463fe1e320
Date: Wed, 20 Jan 1993 23:24:29 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: morris@netcom.com (Jim Morris)
Posting-number: Volume 35, Issue 1
Archive-name: splash/patch01
Environment: C++
Patch-To: splash: Volume 34, Issue 121-123

[ It seems that when I repackaged splash I left out the sample files that  ]
[ were suppose to be in the sample directory.  This shar file contains the ]
[ missing sample files.  To apply this "patch", cd to the splash top level ]
[ source directory and unshar the following.  Sorry Jim, and to any others ]
[ I have inconvenienced.                                                   ]
[ 			-Kent+                                             ]
-----------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  sample/README.sam sample/assoc.c++ sample/chgfnt.c++
#   sample/cislog.c++ sample/justify.c++ sample/tracer.c++
#   sample/tracer.h sample/tstio.c++ sample/xcl.c++
# Wrapped by kent@sparky on Tue Jan 19 21:39:05 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'sample/README.sam' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/README.sam'\"
else
  echo shar: Extracting \"'sample/README.sam'\" \(714 characters\)
  sed "s/^X//" >'sample/README.sam' <<'END_OF_FILE'
XThe files in this directory are samples of programs I have written
Xto use the SPLASH class library.
X
Xassoc.c++	- Shows hows to use the association arrays
X
Xchgfnt.c++	- Is a program that reads in an AmiPro style file
X		  and also the win.ini file. It replaces all
X		  non-truetype fonts with a user entered one
X
Xcislog.c++	- calculates the monthly charges from a log file
X		  generated by Procomm/win for Compuserve logins
X
Xtstio.c++	- Simple minded test of streams use with SPLASH
X
Xjustify.c++	- A filter program that justifies text to a given
X		  line width
X
Xxcl.c++		- A program that is used with the Tracer files that
X		  automatically inserts a TRACER macro at the start
X		  of all functions in a c++ program.
END_OF_FILE
  if test 714 -ne `wc -c <'sample/README.sam'`; then
    echo shar: \"'sample/README.sam'\" unpacked with wrong size!
  fi
  # end of 'sample/README.sam'
fi
if test -f 'sample/assoc.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/assoc.c++'\"
else
  echo shar: Extracting \"'sample/assoc.c++'\" \(535 characters\)
  sed "s/^X//" >'sample/assoc.c++' <<'END_OF_FILE'
X#ifdef	TESTASSOC
X
X#include <iostream.h>
X#include "splash.h"
X#include "assoc.h"
X
Xmain()
X{
X    Assoc<int> a;
X    a("one")= 1; a("two")= 2; a("three")= 3;
X    cout << a << endl;
X    
X    cout << "Keys:" << endl << a.keys() << endl;
X    cout << "Values:" << endl << a.values() << endl;
X    
X    cout << "a.isin(\"three\")= " << a.isin("three") << endl;
X    cout << "a.isin(\"four\")= " << a.isin("four") << endl;
X    
X    int t= a.adelete("two");
X    cout << "a.adelete(\"two\") returns: " << t << ", a= " << endl << a << endl;
X
X}
X#endif
X
END_OF_FILE
  if test 535 -ne `wc -c <'sample/assoc.c++'`; then
    echo shar: \"'sample/assoc.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/assoc.c++'
fi
if test -f 'sample/chgfnt.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/chgfnt.c++'\"
else
  echo shar: Extracting \"'sample/chgfnt.c++'\" \(3541 characters\)
  sed "s/^X//" >'sample/chgfnt.c++' <<'END_OF_FILE'
X#ifdef	TESTCHGFNT
X// Read an AmiPro style sheet and change any unknown font
X#include	<fstream.h>
X#include	<stdlib.h>
X
X#ifdef	__TURBOC__
X#pragma hdrstop
X#endif
X
X#include	"splash.h"
X#include	"assoc.h"
X
Xvoid main(int argc, char **argv)
X{
Xchar c, *infn;
Xifstream ini("\\win3\\win.ini");
Xofstream fout("t.sty");
Xint ln= 0;
XSPString w;
XSPStringList l;
XSPStringList ttfonts;
XAssoc<SPString> repfnts("", "");  // saves font replacement names
X
X    if(argc < 2) infn= "test.sty";
X    else infn= argv[1];
X
X    ifstream fin(infn);
X
X    if(!ini){
X    	cerr << "Can't open \\win3\\win.ini" << endl;
X        exit(1);
X    }
X
X    if(!fin){
X    	cerr << "Can't open " << infn << endl;
X        exit(1);
X    }
X
X    if(!fout){
X    	cerr << "Can't open t.sty for write" << endl;
X        exit(1);
X    }
X
X    cout << "Reading in truetype fonts" << endl;
X
X    while(ini >> w){ // find the [fonts] section
X	if(w.m("\\[fonts\\]")) break;
X    }
X
X//    cout << buf << endl;
X
X    if(!ini.good()){ // checks all file state
X    	cerr << "Couldn't find [fonts] section in win.ini" << endl;
X        exit(1);
X    }
X
X    // make a list of truetype fonts
X    Regexp r1("^([a-zA-Z ]+) \\(([a-zA-Z ]+)\\)=");
X    Regexp r2("^TrueType$");
X    Regexp r3("\\[.*\\]");
X
X    while(ini >> w){
X	if(w.m(r3)) break; // found the start of another section
X        if(w.m(r1, l) != 3) continue; // ignore this line
X//        cout << "Font match:" << l[1] << ", " << l[2] << endl;
X        if(l[2].m(r2)){
X            ttfonts.push(l[1]);
X        } 
X    }
X
X    cout << "ttfonts: " << endl << ttfonts << endl;
X    ini.close();
X
X    cout << "Looking for non-truetype fonts" << endl;
X
X    SPString s, fnt, newfnt;
X    SPStringList sl;
X    while(fin >> s){
X	ln++;
X//    	cout << "line " << ln << ": <" << s << ">" << endl;
X    	if(s.m("\\[fnt\\]")){
X            fout << s << endl; // write out [fnt] line
X			       // read next line which should have font in it
X	    if(!(fin >> s)){
X		cerr << "Error reading font line " << ln << endl;
X		exit(1);
X	    }
X	    ln++;
X	    fnt= s.split("' '").join(" "); // This trims whitespace
X//	    cout << "font name: <" << fnt << ">" << endl;
X            if(!ttfonts.grep("^" + fnt + "$", "i")){ // not a truetype font
X                int pos= s.index(fnt); // get position in string of font
X                if(pos < 0){
X                    cerr << "Couldn't find <" << fnt << "> in string <" << s << "> line " << ln << endl;
X                    exit(1);
X                }
X
X                // See if we already know what to exchange it with
X		if(repfnts.isin(fnt)) // just replace it
X		    s.substr(pos, strlen(fnt)) = repfnts(fnt);
X                else{ // need to ask what the new font name will be
X		    do{
X			cout << "Replace font <" << fnt << "> with:"; cout.flush();
X			cin >> newfnt;
X			if(!(sl=ttfonts.grep("^" + newfnt + "$", "i"))){
X			    cerr << "<" << newfnt << "> is not a valid font" << endl;
X			    continue;
X			}
X		    break;
X		    }while(1);
X		    s.substr(pos, strlen(fnt)) = sl[0]; // replace it
X                    repfnts(fnt) = sl[0];  // remember for next time
X                }
X		fout << s << endl;
X            }else{
X//            	cout << fnt << " is a truetype font" << endl;
X                fout << s << endl; // write out original font line
X            }
X
X   	}else{
X            fout << s << endl; // echo line out
X        }
X    }while(!fin.eof());
X
X    cout << "replacement fonts were:" << endl << repfnts << endl;
X
X    if(fout.fail())
X    	cerr << "Something bad happened to the output file" << endl;
X    fout.close();
X
X}
X
X#endif
END_OF_FILE
  if test 3541 -ne `wc -c <'sample/chgfnt.c++'`; then
    echo shar: \"'sample/chgfnt.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/chgfnt.c++'
fi
if test -f 'sample/cislog.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/cislog.c++'\"
else
  echo shar: Extracting \"'sample/cislog.c++'\" \(2250 characters\)
  sed "s/^X//" >'sample/cislog.c++' <<'END_OF_FILE'
X//
X// Display monthly connect time to CIS
X//
X
X#include	<fstream.h>
X#include	<stdlib.h>
X#include	"splash.h"
X#include	"assoc.h"
X
Xvoid main()
X{
Xchar buf[80];
Xifstream fin("cis.log");
Xint ln= 1, gotit= 0;
XAssoc<int> tot("", 0);
XRegexp reet("(..):(..):(..)"), remnth("^(..)/../..");
XRegexp r1("^(../../..) (..:..).. (.*)");
XSPString s;
X
X    fin >> s;	// eat first line
X
X    while(fin >> s){
X	ln++;
X//    	cout << "line " << ln << ": <" << s << ">" << endl;
X
X        SPStringList l;
X
X//05/20/92 10:48PM CIS 2400 988-5366
X//05/21/92 09:24PM OFFLINE                                   00:00:06
X    	if(s.m(r1, l)){
X            if(l.scalar() < 4){
X            	cerr << "Didn't match all expressions" << endl;
X                exit(1);
X	    }
X//            cout << "Expressions matched: " << endl << l << endl;
X	    SPString a= l[3];
X	    if(a.m("^CIS")) gotit= 1;
X	    else if(a.m("^OFFLINE") && gotit){ // extract Elapsed time
X            	SPStringList et, mnth;
X                int hr, mn, sc, tm;
X
X		if(a.m(reet, et) != 4){
X		    cerr << "Failed to extract Elapsed time" << endl;
X                    exit(1);
X		}
X                hr= atoi(et[1]); mn= atoi(et[2]); sc= atoi(et[3]);
X                tm= (hr*60) + mn + ((sc >= 30) ? 1 : 0);
X
X		gotit= 0;
X		// extract month
X                if(l[1].m(remnth, mnth) != 2){
X                    cerr << "Failed to extract Month" << endl;
X                    exit(1);
X                }
X
X//                cout << "Month: " << mnth[1] << " Elapsed Time = " << tm << " mins" << endl;
X		tot(mnth[1]) += tm;
X		 		            	
X            }else gotit= 0;
X	        
X 	}else{
X            cerr << "Didn't match any expressions" << endl;
X            exit(1);
X        }
X
X    };
X//    cout << "tot = " << endl << tot << endl;
X    Assoc<SPString> months;
X    months("01")= "January"; months("02")= "February"; months("03")= "March";
X    months("04")= "April"; months("05")= "May"; months("06")= "June";
X    months("07")= "July"; months("08")= "August"; months("09")= "September";
X    months("10")= "October"; months("11")= "November"; months("12")= "December";
X
X    for(int i=0;i<tot.scalar();i++)
X    	cout << months(tot[i].key()) << ": " << tot[i].value() << " mins $"
X             << tot[i].value() * (12.50/60.0) << endl;
X}
X
END_OF_FILE
  if test 2250 -ne `wc -c <'sample/cislog.c++'`; then
    echo shar: \"'sample/cislog.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/cislog.c++'
fi
if test -f 'sample/justify.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/justify.c++'\"
else
  echo shar: Extracting \"'sample/justify.c++'\" \(4024 characters\)
  sed "s/^X//" >'sample/justify.c++' <<'END_OF_FILE'
X/*
X * Simple program to read STDIN and justify the text to the
X * specified number of columns and output to STDOUT.
X * The padding is alternated from line to line so as to look even.
X * Blank lines in the input stream are preserved.
X * This was designed to be used as a filter.
X * As with fmt(1) indents are preserved, this can be disabled
X * with an option.
X * Also a change in indent level will be treated as the end of a 
X * stream, so no words on the following line will be wrapped up to
X * the current line.
X */
X
X#include    <iostream.h>
X#include    <stdlib.h>
X#include    <ctype.h>
X
X#include    "splash.h"
X#include    "tracer.h"
X
X// Some useful synonyms
Xtypedef SPString Str;
Xtypedef SPStringList StrList;
X
Xint tog= 0;
X
Xstatic int nextnonspace(const Str& s, int n)
X{
X    while(n < s.length() && s[n] == ' ') n++;    
X    return n;
X}
X
Xstatic int prevnonspace(const Str& s, int n)
X{
X    while(n >= 0 && s[n] == ' ') n--;    
X    return n;
X}
X
Xvoid justify(Str& ln, int width)
X{
XTRACER("justify(Str ln, int width)")
X    LTRACE(2, ln)
X    int p, o= tog?0:ln.length();
X    while(ln.length() < width){
X	if(tog){ // left to right pad
X	    p= ln.index(" ", o); // find a space
X	    if(p > 0){
X		ln.substr(p, 0)= " "; // insert a space
X		o= nextnonspace(ln, p); // start from next non-space
X	    }else if(o) o= 0; // reset
X	    else ln += " "; // put at end of line
X	}else{ // right to left pad
X	    p= ln.rindex(" ", o); // find a space
X	    if(p > 0){
X		ln.substr(p, 0)= " "; // insert a space
X		o= prevnonspace(ln, p); // start from previous non-space
X	    }else if(o != ln.length()) o= ln.length(); // reset
X	    else ln += " "; // put at end of line
X	}	
X    }
X    tog ^= 1;
X}
X
Xvoid Usage()
X{
X    cout << "Usage: justify [-i] [width]" << endl;
X    cout << "\t-i ignores leading whitespace" << endl;
X    cout << "\twidth is the line width, default is 79" << endl;
X    exit(1);
X}
X
Xint main(int argc,  char **argv)
X{
XFTRACER("main()", 0, cout)
XStr inl, curln, curword;
XStrList words;
Xint width= 79, wwidth, ignorews= 0, lastindent= 0;
XStr lws;	// leading whitespace
XStrList ARGS;
X
X    for(int i=1;i<argc;i++){ // load args
X	ARGS.push(argv[i]);
X    }
X    
X    while(ARGS){ // process them
X	Str arg= ARGS.shift();
X	if(arg == "-i") ignorews= 1;
X	else if(arg == "-x") TRACE_ON
X	else if(isdigit(arg[0])) width= atoi(arg);
X	else Usage();
X    }
X	
X    while(cin >> inl){
X	LTRACE(2, inl)
X
X	if(inl.length() == 0){ // honour existing blank lines
X	    if(curln.length()){
X		if(lws.length()) cout << lws; // leading space
X		cout << curln << endl; // flush previous line
X	    }
X	    cout << endl; // output blank line
X	    curln= "";
X	    continue;
X	}
X
X	if(!ignorews){ // don't ignore leading whitespace
X	    StrList t= m("^([ \t]+)", inl); // get leading whitespace
X	    LTRACE(4, "Length = " << t[0].length());
X    	    if(t){
X		int l= 0;
X		for(int i=0;i<t[0].length();i++){ // expand tabs
X		    if(t[0][i] == '\t') l= l + (8 - l%8);
X		    else l++;
X		}
X		wwidth= width - l;
X	    }else wwidth= width;
X	    if(wwidth != lastindent && curln.length()){ // indent changed, flush line
X		if(lws.length()) cout << lws; // leading space
X		cout << curln << endl; // flush previous line
X		curln= "";
X	    }
X	    lastindent= wwidth;
X	    lws= t[0];
X	}else wwidth= width;
X	
X    	words.push(inl.split("' '")); // put at end of word FIFO
X	LTRACE(2, words)
X	while(words){
X	    if(curln.length() == 0){
X		curln= words.shift(); // get first word
X	    }
X	    while(curln.length() < wwidth){
X		if(!words) break; // need to refill FIFO
X		curword= words.shift(); // next word
X		if(curln.length() + curword.length() + 1 > wwidth){
X		    words.unshift(curword); // put it back
X		    justify(curln, wwidth); // pads with spaces to width
X		}else curln += (" " + curword); // add word to line
X	    }
X	    if(curln.length() >= wwidth){ // done with this line
X		if(lws.length()) cout << lws; // leading space
X		cout << curln << endl;
X		curln= "";
X	    }
X	}
X    }
X    if(curln.length()){
X	if(lws.length()) cout << lws; // leading space
X	cout << curln << endl;
X    }
X}
END_OF_FILE
  if test 4024 -ne `wc -c <'sample/justify.c++'`; then
    echo shar: \"'sample/justify.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/justify.c++'
fi
if test -f 'sample/tracer.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/tracer.c++'\"
else
  echo shar: Extracting \"'sample/tracer.c++'\" \(4542 characters\)
  sed "s/^X//" >'sample/tracer.c++' <<'END_OF_FILE'
X/*
X** File - tracer.cxx
X*/
X
X#ifndef TRACER_HXX
X#include "tracer.h"
X#endif
X
X#include <iostream.h>
X#include <string.h>
X
Xchar*    Tracer::prog;           // program being worked on
Xint      Tracer::mode;           // global mode of Tracer
Xchar*    Tracer::watch;          // function to watch for and trace
Xint	 Tracer::level;
Xostream* Tracer::str;
X
X// ****************************************************************:
X//      Tracer
X//
X// Description:
X//      Initialize local as well as static information.  Set up
X//      for total cleanup at destruction.  Also outputs Tracer
X//      to stream using operator<<.  Implicit assumption is that
X//      this is only called once per run of a program.
X// ****************************************************************:
XTracer::Tracer(char* s, const int n, ostream &st)
X{
X        str= &st;
X        prog = func = s;        // Set program name
X        mode = n;               // Initialize the tracing mode (no default).
X        lmode = 1;              // Recognize this as top-level.
X	level = 0;
X        if (mode)               // Should we output?
X                *str << *this << ": entered" << endl;
X}
X
X// ****************************************************************:
X//      Tracer
X//
X// Description:
X//      Initialize only local information.  No total cleanup
X//      at destuction.  Also outputs Tracer to stream using
X//      operator<<.  Also checks to see if input character
X//      string contains information that Tracer is watching
X//      for and turns tracing on if it does.  Implicit assumption
X//      is that this is the way Tracer will be set up when needed.
X// ****************************************************************:
XTracer::Tracer(char* s, int l)
X{
X        func = s;               // Leave program alone, but set function
X        emode= l;		// entry/exit mode
X	level++;
X        if (watch != 0)                 // Watching something?
X        {
X                if (strstr(func, watch) != 0)   // Watching for this?
X                {                       // yes...
X                        lmode = mode;   // remember global mode locally
X                        mode = -1;      // turn tracing on
X                }
X        }
X        else                            // no...
X                lmode = 0;              // set local mode to not top level
X
X        if (mode & emode){                  // Should we output?
X                *str << *this << ": entered" << endl;
X        }
X}
X
X
X// ****************************************************************:
X//      ~Tracer
X//
X// Description:
X//      Check for totalcleanup flag and cleanup.
X//      Also outputs Tracer to stream using operator<<.
X// ****************************************************************:
XTracer::~Tracer()
X{
X        if (mode & emode){                       // Should we output?
X                *str << *this << ": exitted" << endl;
X        }
X        level--;
X
X        if (watch != 0)                 // Watching something?
X        {
X                if (strstr(func, watch) != 0)   // Watching for the function?
X                {                       // yes...
X                        mode = lmode;   // reset remembered global mode
X                        lmode = 0;      // this is not the top level
X                }
X        }
X
X        if (lmode)                      // Is this top level?
X                TotalCleanup();
X}
X
X
X// ****************************************************************:
X//              TotalCleanup
X//
X// Description:
X//      Do what's needed to finally cleanup Tracer.
X//      For instance, might be a close of a log file.
X// ****************************************************************:
Xvoid
XTracer::TotalCleanup()
X{
X        if (watch)
X                delete watch;
X}
X
X
X// ****************************************************************:
X//              SetWatch
X//
X// Description:
X//      Set a function name to watch trace on.
X// ****************************************************************:
Xvoid
XTracer::SetWatch(char* name)
X{
X        if (watch)
X                delete watch;
X
X        watch = new char[strlen(name)+1];
X        strcpy(watch, name);
X}
X
X// ****************************************************************:
X//              Operator<<
X//
X// Description:
X//      Puts Tracer into an output stream.
X// ****************************************************************:
Xostream&
Xoperator<<(ostream& str, Tracer& x)
X{
X	for(int i=0;i<x.level;i++) str << '.';
X        str << x.func;   // output the Tracer object to stream
X        return str;
X}
END_OF_FILE
  if test 4542 -ne `wc -c <'sample/tracer.c++'`; then
    echo shar: \"'sample/tracer.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/tracer.c++'
fi
if test -f 'sample/tracer.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/tracer.h'\"
else
  echo shar: Extracting \"'sample/tracer.h'\" \(4798 characters\)
  sed "s/^X//" >'sample/tracer.h' <<'END_OF_FILE'
X/*
X** Tracer object
X**
X** Purpose:
X**      Mostly for tracing function calls, but may be adapted for
X**      logging a trace of a program to somewhere else.
X*/
X
X#ifndef TRACER_HXX
X#define TRACER_HXX
X
X// .NAME Tracer - class to manage providing a trace of functions.
X// .LIBRARY util
X// .HEADER Utility Classes
X// .INCLUDE tracer.hxx
X// .FILE tracer.hxx
X// .FILE tracer.cxx
X
X// .SECTION Description
X// This class makes use of some of the semantics of C++ to provide
X// a convenient way of tracing function calls.  This code was initially
X// suggested by Bjarne Stroustrup, but has now been modified to allow
X// control of when tracing takes place.  Tracing messages are sprinkled
X// about the user's code and, at the user's choosing, the type of
X// tracing is enabled.  Users of this object class will rarely (if
X// ever) directly see the class.  Instead, they will use the macro
X// interface defined with this class.
X
X// .SECTION Tracing Types
X// Tracer may be set to output its tracing information according to the
X// type of mode it has been put into.  At the simplest level, Tracer may
X// be set to output all tracing information by setting its type to -1
X// (which is what TRACE_ON does).  At the next level, messages that
X// Tracer is told about may be given a positive integer type < 32.
X// Tracer may also be set to output only messages that are of certain
X// types (via bitwise AND of current type with message type).  Users
X// can, therefore, monitor all types of messages, some of the types,
X// or just one of the types depending on the user's interest.  The final
X// level is that a user may turn on monitoring of a function call by
X// telling Tracer the name of the function to WATCH.  When Tracer hits
X// the function in question, it turns TRACE_ON and turns TRACE_OFF when
X// it leaves the function (so, all lower functions are also traced).
X
X#include <iostream.h>
X
X
Xclass Tracer
X{
Xpublic:
X        Tracer(char*, const int, ostream &st);   // Full tracer invocation
X        Tracer(char*, int= -1);                  // Lower level invocation
X
X        ~Tracer();                      // Close tracer invocation
X
X        void    TotalCleanup();         // Clean up when fully done
X
X        void    SetMode(const int n){mode = n;} // Set current mode of tracing
X        int     GetMode(){ return mode;}        // Determine current tracing mode
X
X        void    SetWatch(char*);        	// Function name to begin tracing in
X        char*   GetWatch(){return watch;};      // What we are watching for?
X
X        ostream& GetStream(void){ return *str; }
X        friend ostream& operator<<(ostream&, Tracer&);
X                                        // Output tracing information
X
Xprivate:
X        char*           func;           // function being worked on
X        int             lmode;          // local mode of Tracer
X        int		emode;		// entry/exit mode, determines if printed
X        static char*    prog;           // program being worked on
X        static int      mode;           // global mode of Tracer
X        static char*    watch;          // function to watch for and trace
X	static int	level;		// function call nesting
X	static ostream*	str;		// stream to output onto
X};
X
X
X// ****************************************************************
X//              Macro Interface to Tracer Object
X// ****************************************************************
X#ifdef DOTRACER
X
X#define FTRACER(s,n,st)    /* Trace program s with type n */\
X        Tracer  _trace(s, n, st);
X
X#define TRACER(s)       /* Trace function s */\
X        Tracer  _trace(s);
X
X#define LTRACER(s, l)       /* Trace function s with type n */\
X        Tracer  _trace(s, l);
X
X#define TRACE(s)        /* If TRACE_ON then output s */\
X        if (_trace.GetMode()) _trace.GetStream() << _trace << ": " << s << endl;
X
X#define TRACEF(f)       /* If TRACE_ON then call function f */\
X        if (_trace.GetMode()) f;
X
X#define TRACE_ON        /* Turn tracing on */\
X        _trace.SetMode(-1);
X
X#define TRACE_OFF       /* Turn tracing off */\
X        _trace.SetMode(0);
X
X#define LTRACE(l,s)     /* If (type & l) then output s */\
X        if (_trace.GetMode() & l) \
X                _trace.GetStream() << _trace << ": " << s << endl;
X
X#define LTRACEF(l,f)    /* If (type & l) then call function f */\
X        if (_trace.GetMode() & l) f;
X
X#define STRACE(m)       /* Set tracing to type m */\
X        _trace.SetMode(m);
X
X#define WATCH(s)        /* Set function to watch to s */\
X        _trace.SetWatch(s);
X
X#else
X
X#define FTRACER(s,n,st) /**/
X#define TRACER(s)       /**/
X#define LTRACER(s,l)	/**/
X#define TRACE(s)        /**/
X#define TRACE_ON        /**/
X#define TRACE_OFF       /**/
X#define LTRACE(l,s)     /**/
X#define LTRACEF(l,s)    /**/
X#define STRACE(m)       /**/
X#define WATCH(s)        /**/
X
X#endif
X
X#endif
END_OF_FILE
  if test 4798 -ne `wc -c <'sample/tracer.h'`; then
    echo shar: \"'sample/tracer.h'\" unpacked with wrong size!
  fi
  # end of 'sample/tracer.h'
fi
if test -f 'sample/tstio.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/tstio.c++'\"
else
  echo shar: Extracting \"'sample/tstio.c++'\" \(806 characters\)
  sed "s/^X//" >'sample/tstio.c++' <<'END_OF_FILE'
X#include	<fstream.h>
X#include	<strstream.h>
X#include	<stdlib.h>
X#include	"splash.h"
X#include	"assoc.h"
X
Xvoid main()
X{
Xifstream fin("t.txt");
Xofstream fout("t2.txt");
X
XSPString s;
XSPStringList l;
X
X    while(fin >> s){
X	cout << "read in string: " << s << endl;
X	fout << s << endl;
X    }
X    
X    fin.close();
X    fout.close();
X    
X    fin.open("t.txt");
X    
X    fin >> l;
X    
X    cout << "List =" << endl << l << endl;
X
X#if 1
X    strstream ss, iss;
X    ss << "one\n" << "two\nthree\nfour\n";
X    ss >> l;
X    cout << l << endl;
X    SPList<int> il;
X    iss << 1 << " " << 2 << " " << 3 << " " << 4 << endl;
X    iss << "5 6 7 8 9" << endl;
X    iss >> il;
X    cout << il << endl;
X#endif
X
X
X    cout << "Start Typing:" << endl;
X    while(cin >> s){
X	cout << "read in string: " << s << endl;
X    }
X
X    
X    
X}
END_OF_FILE
  if test 806 -ne `wc -c <'sample/tstio.c++'`; then
    echo shar: \"'sample/tstio.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/tstio.c++'
fi
if test -f 'sample/xcl.c++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample/xcl.c++'\"
else
  echo shar: Extracting \"'sample/xcl.c++'\" \(3936 characters\)
  sed "s/^X//" >'sample/xcl.c++' <<'END_OF_FILE'
X#include <iostream.h>
X#include <fstream.h>
X#include "splash.h"
X#include "tracer.h"
X
X#ifdef	_Windows
X#include "../win/debugwin/debugstr.h"
X#define OUTSTREAM dout
X#else
X#define OUTSTREAM cout
X#endif
X
Xifstream fin;
X
X// Globals
XSPString curln, curclass;
Xint bcnt;   // current brace count
X
X/*
X * Reads in a line, and eliminates anything in between comments
X * or quotes. Also keeps count of the brace level
X */
Xint getline()
X{
XLTRACER("getline", 4)
X
X    if(!(fin >> curln)) return 0;
X    cout << curln << endl;
X    LTRACE(2, curln)
X    while(curln.m("\".*\"")){ // remove anything in quoted strings
X	int o, c;
X	SPString tl= curln.substr(0, o= curln.index("\""));
X	do{ // make sure the quote is not backslashed
X            c= curln.index("\"", o+1);
X	    o= c;
X	}while(c > 1 && curln[c-1] == '\\');
X	tl += curln.substr(c+1); // rest of line
X	curln= tl;
X//	cout << "quote stripped curln= " << curln <<endl;
X    }
X
X    if(curln.m("//")){ // found a comment in line
X	curln.substr(curln.index("//"))= ""; // chop it off
X    }
X
X    if(curln.m("/\\*")){ // in c comment
X	SPString tl= curln.substr(0, curln.index("/*"));
X	if(curln.m("\\*/")){ // closing comment on same line
X	    tl += curln.substr(curln.index("*/")+2); // rest of line
X	    curln= tl;
X//	    cout << "comment stripped curln= " << curln <<endl;
X	}else{ // find close of comment
X	    while(fin >> curln){
X		cout << curln << endl;
X		if(curln.m("\\*/")){
X		    tl += curln.substr(curln.index("*/")+2); // get rest of line
X		    break;		
X		}
X	    }
X	    curln= tl;
X	}
X    }
X    LTRACE(4, curln)
X    int ob= curln.tr("{", "");
X    int cb= curln.tr("}", "");
X    int cnt= ob - cb;
X    bcnt += cnt;
X    LTRACE(4, "Brace count = " << bcnt);
X    if(bcnt < 0){
X	cout.flush();
X	cerr << "Brace count dropped below zero,  oops" << endl;
X	exit(1);
X    }
X    return 1;
X}
X
Xvoid dofunction(const SPStringList &subm, int bc= 0)
X{
XTRACER("dofunction")
XSPString fnname= subm[1], fnparams= subm[2];
X
XLTRACE(1, "In Function " << fnname << "(" << fnparams << ")")
X
X    if(curln.m("{.*}")){
X//	cerr << "Can't insert TRACER here" << endl;
X	return;
X    }else if(curln.m("{")) bc--;
X
X    while(bcnt == bc && getline()); // find opening brace
X    LTRACE(1, "Inside Function " << fnname)
X
X    if(fnname.m("^main$")){ // special treatment for main()
X	cout << "FTRACER(\"main()\", 0)" << endl;
X    }else{
X	cout << "TRACER(\"";
X	if(curclass.length()) cout << curclass << "::";
X	cout << fnname << "(" << fnparams << ")\")" << endl;
X    }
X
X    while(getline()){
X	if(bcnt == bc){ // no longer in function
X	    LTRACE(1, "End of function " << fnname)
X	    break;
X	}
X	
X    }
X
X}
X
Xvoid doclass(const SPStringList &subm)
X{
XTRACER("doclass")
XSPStringList sl;
X
X    if(curln.m(";")) return; // if a ';' on line then probably a forward reference
X    LTRACE(1, "Seen Class " << subm[1])
X    curclass= subm[1];	// remember class name
X    
X    while(bcnt == 0 && getline()); // find opening brace
X    LTRACE(1, "Inside Class " << curclass)
X    
X    while(getline()){
X	if(bcnt == 0){ // no longer in class
X	    LTRACE(1, "End of class " << curclass)
X	    break;
X	}
X
X	if(curln.m("[ \t]*([^ \t]+)[ \t]*\\(([^)]*)\\)", sl)){ // function def
X	    if(curln.m(";[ \t]*$")) continue; // declaration
X	    dofunction(sl, bcnt);
X	}
X    
X    }
X    curclass= "";
X}
X
Xint main(int argc, char **argv)
X{
Xint debug= 0;
X
X    if(argc > 2 && *argv[1] == '-'){
X	debug= atoi(&argv[1][1]);
X	argc--; argv++;
X    }
X
X
XFTRACER("xcl", debug, OUTSTREAM)
XSPStringList sl;
X
X    if(argc < 2){
X	cerr << "Usage: xcl [-n] fn" << endl;
X	exit(1);
X    }
X
X    fin.open(argv[1], ios::in);
X    if(!fin){
X	cerr << "Couldn't open file: " << argv[1] << endl;
X	exit(1);
X    }
X    
X    while(getline()){
X	if(curln.m("^[ \t]*class[ \t]+([a-zA-Z_]+[a-zA-Z_0-9]*)", sl)){
X	    doclass(sl);
X	    continue;
X	}
X
X    	if(curln.m("[ \t]*([^ \t]+)[ \t]*\\(([^)]*)\\)", sl)){ // function def
X	    if(curln.m(";[ \t]*$")) continue; // declaration
X	    dofunction(sl, bcnt);
X	}
X    }
X}
X
END_OF_FILE
  if test 3936 -ne `wc -c <'sample/xcl.c++'`; then
    echo shar: \"'sample/xcl.c++'\" unpacked with wrong size!
  fi
  # end of 'sample/xcl.c++'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
