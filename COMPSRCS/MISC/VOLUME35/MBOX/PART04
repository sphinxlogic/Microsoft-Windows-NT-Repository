Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i039:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part04/15
Message-ID: <1993Feb5.185618.10071@sparky.imd.sterling.com>
X-Md4-Signature: 28f57e5bf6d17e354be10958482268e8
Date: Fri, 5 Feb 1993 18:56:18 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 39
Archive-name: mbox/part04
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/admin.c wendy/tools.c
# Wrapped by kent@sparky on Fri Feb  5 12:18:05 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 15)."'
if test -f 'src/admin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/admin.c'\"
else
  echo shar: Extracting \"'src/admin.c'\" \(26246 characters\)
  sed "s/^X//" >'src/admin.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  admin.c						   */
X/*        FUNKTIONEN  user_aendern(), user_anzeigen(), user_loeschen(),    */
X/*		      setup_get(), wait_until_keypressed(), admin(),       */
X/*		      setup()					           */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  29.08.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <fcntl.h>
X
X#include "mbox.h"
X
Xvoid wait_until_keypressed();
X
X/***************************************************************************/
X/*      FUNKTION  user_aendern						   */
X/*  BESCHREIBUNG  Aendern ALLER Teilnehmerparameter (von ADMIN aus)        */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid user_aendern()
X{
X  int fd;
X  struct userdaten DUMMY, LOOSER;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  long ll = -1L;
X  size_t dummy = sizeof(DUMMY);
X  unsigned char c;
X  int i;
X  int uid = -1;
X
X  headline( ADM01_MSG );
X
X  printf("%s ", ADM02_MSG);
X  strcpy(s, (unsigned char *) getline(30, 11, '.', ""));
X  if ((s[0] > 47) && (s[0] < 58)) uid = atoi(s);
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if(fd == -1){
X	nerror("admin.c", 324, "aendern", "Datei-Lesefehler", UDBASE);
X  }
X  while(read(fd, (unsigned char *) &DUMMY, dummy) == dummy){
X	if(uid == DUMMY.id){
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	}
X	else{
X		if((strcomp(s, DUMMY.name) == 0) ||
X		   (strcomp(s, DUMMY.nick) == 0) ||
X		   (strcomp(s, DUMMY.sh_name) == 0)){
X			ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X		}
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  read(fd, (unsigned char *) &LOOSER, sizeof(LOOSER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  if(ll == -1L) return;
X
X  printf("%c%s %d                                               ", CR, ADM03_MSG, LOOSER.id);
X
X  printf("\n%s ", ADM04_MSG);
X  strcpy(s, (unsigned char *) getline(30, 1011, '.', LOOSER.name));
X  if (s[0] > 32) sprintf(LOOSER.name, s);
X  if (s[0] == 32) LOOSER.name[0] = '\0';
X
X  printf("\n%s ", ADM05_MSG);
X  strcpy(s, (unsigned char *) getline(10, 1011, '.', LOOSER.passwort));
X  if (s[0] > 32) sprintf(LOOSER.passwort, s);
X  if (s[0] == 32) LOOSER.passwort[0] = '\0';
X
X  printf("\n%s ", ADM06_MSG);
X  strcpy(s, (unsigned char *) getline(14, 1011, '.', LOOSER.sh_name));
X  if (s[0] > 32) sprintf(LOOSER.sh_name, s);
X  if (s[0] == 32) LOOSER.sh_name[0] = '\0';
X
X  printf("\n%s ", ADM07_MSG);
X  strcpy(s, (unsigned char *) getline(30, 1011, '.', LOOSER.nick));
X  if (s[0] > 32) sprintf(LOOSER.nick, s);
X  if (s[0] == 32) LOOSER.nick[0] = '\0';
X
X  printf("\n%s ", ADM08_MSG);
X  strcpy(s, (unsigned char *) getline(30, 1011, '.', LOOSER.wohnort));
X  if (s[0] > 31) sprintf(LOOSER.wohnort, s);
X
X  printf("\n%s ", ADM09_MSG);
X  strcpy(s, (unsigned char *) getline(30, 1011, '.', LOOSER.strasse));
X  if (s[0] > 31) sprintf(LOOSER.strasse, s);
X
X  printf("\n%s ", ADM10_MSG);
X  strcpy(s, (unsigned char *) getline(20, 1011, '.', LOOSER.telefon1));
X  if (s[0] > 31) sprintf(LOOSER.telefon1, s);
X
X  printf("\n%s ", ADM11_MSG);
X  strcpy(s, (unsigned char *) getline(20, 1011, '.', LOOSER.telefon2));
X  if (s[0] > 31) sprintf(LOOSER.telefon2, s);
X
X  printf("\n%s ", ADM12_MSG);
X  strcpy(s, (unsigned char *) getline(10, 1114, '?', LOOSER.geburtsdatum));
X  if (s[0] > 31) sprintf(LOOSER.geburtsdatum, s);
X
X  printf("\n%s ", ADM13_MSG);
X  sprintf(t, "%d", LOOSER.terminal);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.terminal = atoi(s);
X  if ((LOOSER.terminal < 1) || (LOOSER.terminal > 4)) LOOSER.terminal = 1;
X
X  printf("\n%s ", ADM14_MSG);
X  sprintf(t, "%d", LOOSER.editor);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.editor = atoi(s);
X  if ((LOOSER.editor < 1) || (LOOSER.editor > OFFERED_EDITORS)) LOOSER.editor = 1;
X
X  printf("\n%s ", ADM15_MSG);
X  sprintf(t, "%d", LOOSER.level);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.level = atoi(s);
X
X  printf("\n%s ", ADM16_MSG);
X  sprintf(t, "%d", LOOSER.more);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.more = atoi(s);
X  if ((LOOSER.more < 0) || (LOOSER.more > 3)) LOOSER.more = 1;
X
X  printf("\n%s ", ADM17_MSG);
X  sprintf(t, "%d", LOOSER.bell);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.bell = atoi(s);
X  if ((LOOSER.bell < -1) || (LOOSER.bell > 1)) LOOSER.bell = 0;
X
X  printf("\n%s ", ADM18_MSG);
X  sprintf(t, "%d", LOOSER.prompt);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.prompt = atoi(s);
X  if ((LOOSER.prompt < 1) || (LOOSER.prompt > 3)) LOOSER.prompt = 2;
X
X  printf("\n%s ", ADM19_MSG);
X  LOOSER.tlines += 2;
X  sprintf(t, "%d", LOOSER.tlines);
X  strcpy(s, (unsigned char *) getline(5, 1111, '.', t));
X  if (s[0] > 31) LOOSER.tlines = atoi(s);
X  LOOSER.tlines -= 2;
X  if ((LOOSER.tlines < 22) || (LOOSER.tlines > 23)) LOOSER.tlines = DEF_MAX_SCR_LINES;
X  
X  printf("\n%s ", ADM20_MSG);
X  strcpy(s, (unsigned char *) getline(10, 1114, '?', LOOSER.lastlog));
X  if (s[0] > 31) sprintf(LOOSER.lastlog, s);
X
X  printf("\n%s ", ADM21_MSG);
X  strcpy(t, (unsigned char *) timereconv((long) LOOSER.lasttime));
X  t[5] = '\0';
X  strcpy(s, (unsigned char *) getline(5, 1113, '?', t));
X  LOOSER.lasttime = timeconv(s);
X
X  printf("\n%s ", ADM21aMSG);
X  strcpy(s, (unsigned char *) ttyname(0));
X  if(strcomp(PMS_TTY, s) == 0){
X	strcpy(s, (unsigned char *) getline(17, 1011, '.', LOOSER.account));
X	if (s[0] > 31) sprintf(LOOSER.account, s);
X  }
X  else{
X	printf("%s", LOOSER.account);
X  }
X
X  printf("\n%s ", ADM22_MSG);
X  strcpy(s, (unsigned char *) getline(58, 1011, '.', LOOSER.newsgrps));
X  if (s[0] > 31) sprintf(LOOSER.newsgrps, s);
X
X  printf("\n%s ", ADM23_MSG);
X  sprintf(t, "%d", LOOSER.seq);
X  strcpy(s, (unsigned char *) getline(10, 1111, '.', t));
X  if (s[0] > 31) LOOSER.seq = atoi(s);
X
X  wait_until_keypressed();
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_WRONLY);
X  if (fd == -1) {
X	nerror("admin.c", 428, "aendern", "Datei-Schreibfehler", UDBASE);
X  }
X  if (lseek(fd, ll, SEEK_SET) == -1) {
X	nerror("admin.c", 431, "aendern", "Positionierungsfehler", UDBASE);
X  }
X  write(fd, (unsigned char *) &LOOSER, sizeof(LOOSER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  if (LOOSER.id == USER.id) {	/* Ich bin's !!! */
X
X	maybe_locked(UDBASE, "r");
X	mblock(UDBASE);
X	fd = open(UDBASE, O_RDONLY);
X	if (fd == -1) {
X		nerror("admin.c", 324, "aendern", "Datei-Lesefehler", UDBASE);
X	}
X	lseek(fd, ll, SEEK_SET);
X	read(fd, (unsigned char *) &USER, sizeof(USER));
X	close(fd);
X	mbunlock(UDBASE);
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  user_anzeigen()					   */
X/*  BESCHREIBUNG  ALLE Teilnehmerdaten anzeigen (von ADMIN aus)		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid user_anzeigen()
X{
X  int fd;
X  struct userdaten DUMMY, LOOSER;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  long ll = -1L;
X  size_t dummy = sizeof(DUMMY);
X  unsigned char c;
X  int i;
X  int uid = -1;
X
X
X  headline( ADM01_MSG );
X
X  printf("%s ", ADM02_MSG);
X  strcpy(s, (unsigned char *) getline(30, 11, '.', ""));
X  if ((s[0] > 47) && (s[0] < 58)) uid = atoi(s);
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("admin.c", 324, "aendern", "Datei-Lesefehler", UDBASE);
X  }
X  while (read(fd, (unsigned char *) &DUMMY, dummy) == dummy) {
X	if (uid == DUMMY.id) {
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	} 
X	else{
X		if ((strcomp(s, DUMMY.name) == 0) ||
X		    (strcomp(s, DUMMY.nick) == 0) ||
X		    (strcomp(s, DUMMY.sh_name) == 0)) {
X			ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X		}
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  read(fd, (unsigned char *) &LOOSER, sizeof(LOOSER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  if (ll == -1L) return;
X
X  printf("%c  %s %d                                               ", CR, ADM03_MSG, LOOSER.id);
X  printf("\n  %s %s",   ADM04_MSG, LOOSER.name);
X  printf("\n  %s %s",   ADM05_MSG, LOOSER.passwort);
X  printf("\n  %s %s",   ADM06_MSG, LOOSER.sh_name);
X  printf("\n  %s %s",   ADM07_MSG, LOOSER.nick);
X  printf("\n  %s %s",   ADM08_MSG, LOOSER.wohnort);
X  printf("\n  %s %s",   ADM09_MSG, LOOSER.strasse);
X  printf("\n  %s %s",   ADM10_MSG, LOOSER.telefon1);
X  printf("\n  %s %s",   ADM11_MSG, LOOSER.telefon2);
X  printf("\n  %s %s",   ADM12_MSG, LOOSER.geburtsdatum);
X  printf("\n  %s %d",   ADM13_MSG, LOOSER.terminal);
X  printf("\n  %s %d",   ADM14_MSG, LOOSER.editor);
X  printf("\n  %s %d",   ADM15_MSG, LOOSER.level);
X  printf("\n  %s %d",   ADM16_MSG, LOOSER.more);
X  printf("\n  %s %d",   ADM17_MSG, LOOSER.bell);
X  printf("\n  %s %d",   ADM18_MSG, LOOSER.prompt);
X  printf("\n  %s %d",   ADM19_MSG, LOOSER.tlines += 2);
X  printf("\n  %s %s",   ADM20_MSG, LOOSER.lastlog);
X  printf("\n  %s %.5s", ADM21_MSG, (unsigned char *) timereconv((long) LOOSER.lasttime));
X  printf("\n  %s %s",   ADM21aMSG, LOOSER.account);
X  printf("\n  %s %s",   ADM22_MSG, LOOSER.newsgrps);
X  printf("\n  %s %d",   ADM23_MSG, LOOSER.seq);
X
X  wait_until_keypressed();
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  user_loeschen()					   */
X/*  BESCHREIBUNG  Einen Teilnehmer einsch. persoenlicher Post etc. aus	   */
X/*		  dem System entfernen.                                    */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid user_loeschen()
X{
X  int fd;
X  int gd;
X  struct userdaten DUMMY, LOOSER;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  long ll = -1L;
X  size_t dummy = sizeof(DUMMY);
X  unsigned char c;
X  int i;
X  int uid = -1;
X
X
X  headline( ADM25_MSG );
X	
X  printf("\n%s ", ADM02_MSG);
X  strcpy(s, (unsigned char *) getline(30, 11, '.', ""));
X  if ((s[0] > 47) && (s[0] < 58)) uid = atoi(s);
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("admin.c", 459, "loeschen", "Datei-Lesefehler", UDBASE);
X  }
X  while (read(fd, (unsigned char *) &DUMMY, dummy) == dummy) {
X	if (uid == DUMMY.id) {
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	}
X	else{
X		if ((strcomp(s, DUMMY.name) == 0) ||
X		    (strcomp(s, DUMMY.nick) == 0) ||
X		    (strcomp(s, DUMMY.sh_name) == 0)) {
X			ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X		}
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  read(fd, (unsigned char *) &LOOSER, sizeof(LOOSER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  if (ll == -1L) return;
X
X  printf("%c%s (%d)                                     ", CR, ADM26_MSG, LOOSER.id);
X  printf("\n%s (%s) ", ADM27_MSG, LOOSER.name);
X
X  ansi("md");
X  printf("\n\n%s [%c, %c] ? > ", ADM28_MSG, GBL06_MSG, GBL07_MSG);
X  ansi("me");
X
X  c = yesno();
X
X  if (c != GBL06_MSG) return;
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("admin.c", 490, "loeschen", "Datei-Lesefehler", UDBASE);
X  }
X  sprintf(s, "%s/%dbase", TMP, getpid());
X
X  gd = open(s, O_WRONLY | O_CREAT);
X  if (gd == -1) {
X	nerror("admin.c", 497, "loeschen", "Datei-Erstellungsfehler", s);
X  }
X  while (read(fd, (unsigned char *) &DUMMY, dummy) == dummy) {
X	if (DUMMY.id != LOOSER.id) {
X		write(gd, (unsigned char *) &DUMMY, dummy);
X	}
X  }
X  close(gd);
X  close(fd);
X  mbunlock(UDBASE);
X
X  sprintf(t, "cp %s %s", s, UDBASE);
X  system(t);
X
X  unlink(s);
X
X  sprintf(s, "rm -r %s/usr/%d", HOME, LOOSER.id);
X  system(s);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  setup_get()						   */
X/*  BESCHREIBUNG  Die Ziffern 1-max einlesen und zurueckgeben.		   */
X/*     PARAMETER  max  =  groesste, zulaessige Ziffer		           */
X/*     RUECKGABE  erfasste Ziffer (CHAR !!!)				   */
X/***************************************************************************/
X
Xint setup_get(max)
Xunsigned char max;
X{
X  unsigned char c;
X
X  ansi("md");
X  printf("\n[1-%c] %s > ", max, ADM29_MSG);
X  ansi("me");
X
X  do {
X	c = getint();
X	if ((c < '0') || (c > max)) c = 0;
X  } while (c == 0);
X  printf("%c", c);
X
X  return c;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  wait_until_keypressed					   */
X/*  BESCHREIBUNG  siehe FUNKTION					   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid wait_until_keypressed()
X{
X  unsigned char c;
X
X  ansi("md");
X  printf("\n\n%s > ", ADM30_MSG);
X  ansi("me");
X 
X  c = getint();
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  admin()						   */
X/*  BESCHREIBUNG  Teilnehmerverwaltung fuer den Administrator/Sysop.       */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid admin()
X{
X  unsigned char c;
X
XAGAIN:
X
X  headline( ADM31_MSG );
X
X  printf(  "\n  1 - %s", ADM32_MSG);
X  printf("\n\n  2 - %s", ADM33_MSG);
X  printf("\n\n  3 - %s", ADM34_MSG);
X  printf("\n\n  4 - %s", ADM35_MSG);
X  printf("\n\n  5 - %s", ADM36_MSG);
X
X  printf("\n");
X  printf("\n\n  8 - %s", ADM37_MSG);
X
X  MEDIUM: printf("\n");
X
X  c = setup_get('8');
X
X  switch (c) {
X      case '1':	
X		postfach("*");
X		logout();
X		intro();
X		break;
X
X      case '2':	
X		user_aendern();
X		break;
X
X      case '3':	
X		user_loeschen();
X		break;
X
X      case '4':	
X		user_anzeigen();
X		break;
X
X      case '5':
X		userliste("");
X		wait_until_keypressed();
X		break;
X
X       default:
X		printf("\n");
X		return;
X  }
X  goto AGAIN;
X
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  setup()						   */
X/*  BESCHREIBUNG  Teilnehmerdaten/Parameter aendern (fuer die User)        */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid setup()
X{
X  FILE *fp;
X  int fd;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char c;
X  int i;
X  int ok = 0;
X  long ll;
X  struct userdaten DUMMY;
X  int dummy = sizeof(DUMMY);
X  unsigned char *BLANKS = "                                               ";
X
X
X  AGAIN:
X
X  headline( ADM38_MSG );
X  printf("\n");
X
X  printf("  1 - %s\n\n", ADM39_MSG);
X  printf("  2 - %s\n\n", ADM40_MSG);
X  printf("  3 - %s\n\n", ADM41_MSG);
X  printf("  4 - %s\n\n", ADM42_MSG);
X  printf("  5 - %s\n\n", ADM43_MSG);
X  printf("  6 - %s\n\n", ADM44_MSG);
X  printf("  7 - %s\n\n", ADM45_MSG);
X  printf("  8 - %s\n\n", ADM46_MSG);
X  printf("\n");
X  printf("  9 - %s\n\n", ADM47_MSG);
X
X  c = setup_get('9');
X
X  switch (c) {
X      case '1':
X		headline( ADM48_MSG );
X		printf("\n");
X		if (USER.terminal == 1)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 1 - ANSI (X3.64 ... PC-BBS-ANSI)\n\n");
X		if (USER.terminal == 2)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 2 - VT100\n\n");
X		if (USER.terminal == 3)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 3 - VT52\n\n");
X		if (USER.terminal == 4)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 4 - Dump (%s)\n\n", ADM49_MSG);
X		if (USER.terminal == 5)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 5 - COLOR-ANSI (X3.64 & ISO 6429)\n\n");
X		USER.terminal = setup_get('5') - 48;
X		
X		break;
X
X      case '2':
X		headline( ADM50_MSG );
X		printf("\n");
X		fp = fopen(EDITORS, "r");
X		if (fp == NULL) {
X			nerror("admin.c", 563, "setup", "Datei-Lesefehler", EDITORS);
X		}
X		i = 0;
X		while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X		while (fscanf(fp, "%s %s", s, t) > 0) {
X			i++;
X			if (USER.editor == i)
X				printf("*");
X			else
X				printf(" ");
X			printf(" %d - %s\n\n", i, s);
X		}
X		fclose(fp);
X		USER.editor = setup_get((i + 48)) - 48;
X	
X		if ((USER.level < WRITE_INTERNAT) && (USER.editor > 2)) 
X			USER.editor = 2;
X		break;
X
X      case '3':
X		headline( ADM51_MSG );
X		printf("\n");
X		strcpy(s, (unsigned char *) mytime(0));
X		if ((USER.prompt == 1) && (USER.bell == 1))
X			printf("*");
X		else
X			printf(" ");
X		printf(" 1 - %s->     \"[%s] %s > \"\n\n", ADM52_MSG, s, LOP06_MSG);
X		if ((USER.prompt == 1) && (USER.bell == 0))
X			printf("*");             
X		else
X			printf(" ");
X		printf(" 2 - %s->     \"[%s] %s > \"\n\n", ADM53_MSG, s, LOP06_MSG);
X		if ((USER.prompt == 2) && (USER.bell == 1))
X			printf("*");
X		else
X			printf(" ");
X		printf(" 3 - %s->     \"[%s] %s > \"\n\n", ADM54_MSG, NG, LOP06_MSG);
X		if ((USER.prompt == 2) && (USER.bell == 0))
X			printf("*");
X		else
X			printf(" ");
X		printf(" 4 - %s->     \"[%s] %s > \"\n\n", ADM55_MSG, NG, LOP06_MSG);
X		if ((USER.prompt == 3) && (USER.bell == 1))
X			printf("*");
X		else
X			printf(" ");
X		printf(" 5 - %s->     \"[(Sec.) NZ, RZ, WZ] %s > \"\n\n", ADM56_MSG, LOP06_MSG);
X		if ((USER.prompt == 3) && (USER.bell == 0))
X			printf("*");
X		else
X			printf(" ");
X		printf(" 6 - %s->     \"[(Sec.) NZ, RZ, WZ] %s > \"\n\n", ADM57_MSG, LOP06_MSG);
X	
X		c = setup_get('6');
X		switch (c) {
X			    case '1':
X					USER.prompt = 1;
X					USER.bell = 1;
X					break;
X			    case '2':
X					USER.prompt = 1;
X					USER.bell = 0;
X					break;
X			    case '3':
X					USER.prompt = 2;
X					USER.bell = 1;
X					break;
X			    case '4':
X					USER.prompt = 2;
X					USER.bell = 0;
X					break;
X			    case '5':
X					USER.prompt = 3;
X					USER.bell = 1;
X					break;
X			    case '6':
X					USER.prompt = 3;
X					USER.bell = 0;
X					break;
X		}
X		break;
X
X      case '4':
X		headline( ADM58_MSG );
X		printf("\n");
X		if (USER.more == 0)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 1 - %s\n\n", ADM59_MSG);
X		if (USER.more == 1)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 2 - %s\n\n", ADM60_MSG);
X		if (USER.more == 3)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 3 - %s\n\n", ADM61_MSG);
X		printf("\n");
X		printf("  4 - %s\n\n", ADM62_MSG);
X		printf("  5 - %s\n\n", ADM63_MSG);
X		printf("  6 - %s\n\n", ADM64_MSG);		
X		printf("  7 - %s\n\n", ADM64aMSG);
X		printf("  8 - %s\n\n", ADM64bMSG);
X
X		i = setup_get('8') - 49;
X
X		if (i < 3) {
X			USER.more = i;
X			if (USER.more == 2) USER.more++;
X		}
X		else {
X			headline( ADM58_MSG );
X			printf("\n");
X			
X			if (i == 3) {
X				if (USER.leserichtung == 1)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 1 - %s\n\n", ADM65_MSG);
X				if (USER.leserichtung == 2)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 2 - %s\n\n", ADM66_MSG);
X		
X				USER.leserichtung = setup_get('2') - 48;
X			}
X			if (i == 4) {
X				if (USER.tlines == 22)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 1 - %s\n\n", ADM67_MSG);
X				if (USER.tlines == 23)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 2 - %s\n\n", ADM68_MSG);
X				if (USER.tlines == 43)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 3 - %s\n\n", ADM68aMSG);
X
X				USER.tlines = setup_get('3') - 48 + 21;
X				if(USER.tlines == 24) USER.tlines = 43; /* 45 Zeilen !! */	
X			}
X			if (i == 5) {
X				if (USER.schluessel[0] != 32)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 1 - %s\n\n", ADM69_MSG);
X				if (USER.schluessel[0] == 32)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 2 - %s\n\n", ADM70_MSG);
X		
X				i = setup_get('2') - 48;
X				if (i == 2){
X					USER.schluessel[0] = 32;
X				}				
X				else{
X					USER.schluessel[0] = 1;
X				}
X			}
X			if (i == 6) {
X				if (USER.schluessel[1] == 2)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 1 - %s\n\n", ADM70aMSG);
X				if (USER.schluessel[1] == 3)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 2 - %s\n\n", ADM70bMSG);
X		
X				if (USER.schluessel[1] == 4)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 3 - %s\n\n", ADM70cMSG);
X	
X				i = setup_get('3') - 48;
X				USER.schluessel[1] = i + 1;
X			}
X			if (i == 7) {
X				if (USER.schluessel[2] == 1)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 1 - %s\n\n", ADM70dMSG);
X				if (USER.schluessel[2] == 2)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 2 - %s\n\n", ADM70eMSG);
X				if (USER.schluessel[2] == 3)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 3 - %s\n\n", ADM70fMSG);
X				if (USER.schluessel[2] == 4)
X					printf("*");
X				else
X					printf(" ");
X				printf(" 4 - %s\n\n", ADM70gMSG);
X
X				i = setup_get('4') - 48;
X				USER.schluessel[2] = i;
X			}
X		}
X		break;
X
X	case '5':
X		if (strcomp(GUEST, USER.name) == 0) break;
X
X		headline( ADM71_MSG );
X		printf("\n");
X
X		ansi("md");
X		printf("%s\n", ADM72_MSG);
X		printf("%s\n", ADM73_MSG);
X		printf("%s\n", ADM74_MSG);
X		printf("\n");
X		printf("%s\n", ADM75_MSG);
X		printf("%s\n", ADM76_MSG);
X		ansi("me");
X
X		maybe_locked(UDBASE, "r"); 
X	        fd = open(UDBASE, O_RDONLY);
X		if (fd == -1) {
X			nerror("admin.c", 747, "setup", "Datei-Lesefehler", UDBASE);
X		}	
X
X		printf("\n%s ", ADM04_MSG);
X		strcpy(s, (unsigned char *) getline(30, 1015, '.', USER.name));
X		if(strcomp(GUEST, s) != 0){
X			if (s[0] > 31){
X				ok = 0;
X				lseek(fd, 0L, SEEK_SET);
X				while ((read(fd, (unsigned char *) &DUMMY, sizeof(DUMMY)) == sizeof(DUMMY)) && (ok == 0)) {
X					if (strcomp(s, DUMMY.name)    == 0) ok = 1;
X					if (strcomp(s, DUMMY.nick)    == 0) ok = 1;
X					if (strcomp(s, DUMMY.sh_name) == 0) ok = 1;
X				}
X				if(USER.level < ADMIN_LEV){
X					if ((strcomp("SYSOP", s) == 0) ||
X					    (strcomp("POST",  s) == 0) ||
X					    (strcomp("GAST",  s) == 0) ||
X					    (strcomp("ADMIN", s) == 0) ||
X					    (strcomp("COSYS", s) == 0)) ok++;
X				}
X
X				if(ok == 0) sprintf(USER.name, s);
X			}
X		}
X
X		printf("\n%s ", ADM07_MSG);
X		strcpy(s, (unsigned char *) getline(30, 1015, '.', USER.nick));
X		if (s[0] > 31){	
X			ok = 0;
X			lseek(fd, 0L, SEEK_SET);
X			while ((read(fd, (unsigned char *) &DUMMY, sizeof(DUMMY)) == sizeof(DUMMY)) && (ok == 0)) {
X				if (strcomp(s, DUMMY.name)    == 0) ok = 1;
X				if (strcomp(s, DUMMY.nick)    == 0) ok = 1;
X				if (strcomp(s, DUMMY.sh_name) == 0) ok = 1;
X			}
X			if (USER.level < ADMIN_LEV){
X				if ((strcomp("SYSOP", s) == 0) ||
X				    (strcomp("POST",  s) == 0) ||
X				    (strcomp("GAST",  s) == 0) ||
X				    (strcomp("ADMIN", s) == 0) ||
X				    (strcomp("COSYS", s) == 0)) ok++;
X			}
X
X			if(ok == 0) sprintf(USER.nick, s);
X		}
X
X		close(fd);
X		mbunlock(UDBASE);
X
X		printf("\n%s ", ADM08_MSG);
X		strcpy(s, (unsigned char *) getline(30, 1011, '.', USER.wohnort));
X		if (s[0] > 31) sprintf(USER.wohnort, s);
X
X		printf("\n%s ", ADM09_MSG);
X		strcpy(s, (unsigned char *) getline(30, 1011, '.', USER.strasse));
X		if (s[0] > 31) sprintf(USER.strasse, s);
X
X		printf("\n%s ", ADM10_MSG);
X		strcpy(s, (unsigned char *) getline(20, 1011, '.', USER.telefon1));
X		if (s[0] > 31) sprintf(USER.telefon1, s);
X
X		printf("\n%s ", ADM11_MSG);
X		strcpy(s, (unsigned char *) getline(20, 1011, '.', USER.telefon2));
X		if (s[0] > 31) sprintf(USER.telefon2, s);
X
X		printf("\n%s ", ADM12_MSG);
X		strcpy(s, (unsigned char *) getline(10, 1114, '?', USER.geburtsdatum));
X		if (s[0] > 31) sprintf(USER.geburtsdatum, s);
X
X		break;
X
X
X      case '6':
X		if (strcomp(GUEST, USER.name) == 0) break;
X
X		headline( ADM77_MSG );
X		
X		NIX: printf("\n%s ", ADM78_MSG);
X	
X		strcpy(s, (unsigned char *) getline(10, 12, '.', ""));
X		if (s[0] != '\0') {
X			strcpy(USER.passwort, (unsigned char *) crypted(s));
X			printf(" (%s)", USER.passwort);
X		}
X		if (length(USER.passwort) < 5) {
X			ansi("md");
X			printf("\n\n%s\n", ADM79_MSG);
X			ansi("me");
X			goto NIX;
X		}
X		printf("\n\n%s ", ADM80_MSG);
X		strcpy(s, (unsigned char *) getline(10, 12, '.', ""));
X		strcpy(t, (unsigned char *) crypted(s));
X		printf(" (%s)", t);
X		if ((strcomp(t, USER.passwort) != 0) || (strcomp(USER.passwort, t) != 0)) {
X			ansi("md");
X			printf(" %s         \n", ADM81_MSG);
X			ansi("me");
X			goto NIX;
X		}
X		break;
X
X	case '7':
X		headline( ADM82_MSG );
X		printf("\n");
X		strcpy(s, (unsigned char *) mytime(0));
X		if (USER.intro == 1)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 1 - %s\n\n", ADM83_MSG);
X		if (USER.intro == 2)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 2 - %s\n\n", ADM84_MSG);
X		if (USER.intro == 3)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 3 - %s\n\n", ADM85_MSG);
X		if (USER.intro == 4)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 4 - %s\n\n", ADM86_MSG);
X
X		USER.intro = setup_get('4') - 48;
X		break;
X
X      case '8':
X		headline( ADM87_MSG );
X		printf("\n");
X		if (USER.lastmode == 1)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 1 - %s\n\n", ADM88_MSG);
X		if (USER.lastmode == 2)
X			printf("*");
X		else
X			printf(" ");
X		printf(" 2 - %s\n\n", ADM89_MSG);
X		printf("\n");
X		printf("  3 - %s\n\n", ADM90_MSG);
X	
X		i = setup_get('3') - 48;
X
X		switch (i) {
X		    case 1:
X				USER.lastmode = 1;
X				LASTTIME = USER.lasttime;
X				break;
X		    case 2:
X				USER.lastmode = 2;
X				LASTTIME = (int) 0;
X				break;
X		    case 3:
X				headline( ADM87_MSG );
X				ansi("md");
X				printf("\n%s\n", ADM91_MSG);
X				printf("%s\n", ADM92_MSG);
X				printf("%s\n", ADM93_MSG);
X				printf("%s\n", ADM94_MSG);
X				ansi("me");
X
X				printf("\n%s ", ADM95_MSG);
X				strcpy(t, (unsigned char *) datereconv(LASTLOG));
X				strcpy(s, (unsigned char *) getline(10, 1114, '?', t));
X				LASTLOG = (long) dateconv(s);
X
X				printf("\n%s ", ADM96_MSG);
X				strcpy(t, (unsigned char *) timereconv(LASTTIME));
X				strcpy(s, (unsigned char *) getline(8, 1113, '?', t));
X				LASTTIME = timeconv(s);
X
X				break;
X		}
X		break;
X
X      case '9':	
X		goto ENDE;
X		break;
X  }
X  printf("\n\n");
X  init_user( ADM97_MSG );
X  goto AGAIN;
X
X  ENDE:
X
X  printf("\n");
X  return;
X}
END_OF_FILE
  if test 26246 -ne `wc -c <'src/admin.c'`; then
    echo shar: \"'src/admin.c'\" unpacked with wrong size!
  fi
  # end of 'src/admin.c'
fi
if test -f 'wendy/tools.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/tools.c'\"
else
  echo shar: Extracting \"'wendy/tools.c'\" \(24683 characters\)
  sed "s/^X//" >'wendy/tools.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  tools.c						   */
X/*        FUNKTIONEN  whoami(), tty(), stripped(), upcased(), length(),    */
X/*		      strcopy(), strcomp(), ansi2(), mydate(), mytime(),   */
X/*	              crypted(), dateconv(), datereconv(), timeconv(),     */
X/*		      timereconv(), maybe_locked(), num_stripped(),        */
X/*		      rename(), headline(), ttyna(), bigcopy(), mblock(),  */
X/*		      mbunlock(), shortname(), clearline(), isin()	   */
X/*		      termansi(), sgrep()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  18.12.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X#include <unistd.h>
X#include <time.h>
X#include <pwd.h>
X
X#ifdef _SYS7
X#include <termcap.h>
X#endif
X
X
X#ifdef _MBOX
X#define EXTERN
X#include "mbox.h"
X#else
X#define VERSION "TOOLS.C"
X#define CR 13
X#define TOL01_MSG	"Sonntag"
X#define TOL02_MSG	"Montag"
X#define TOL03_MSG	"Dienstag"
X#define TOL04_MSG	"Mittwoch"
X#define TOL05_MSG	"Donnerstag"
X#define TOL06_MSG	"Freitag"
X#define TOL07_MSG	"Samstag"
X#define TOL08_MSG	"Momentchen"
X#endif
X#ifdef STRING
X#undef STRING
X#endif
X
X#ifdef LONGSTRING
X#undef LONGSTRING
X#endif
X
X#define STRING 81
X#define LONGSTRING 256
X
Xunsigned char headinfo[STRING];
X
X
X/***************************************************************************/
X/*      FUNKTION  whoami()						   */
X/*  BESCHREIBUNG  Name des eigenen SH-Accounts.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xunsigned char *whoami()
X{
X  struct passwd *pw_entry;
X
X  pw_entry = getpwuid(getuid());
X
X  if (pw_entry->pw_uid < 0) return (unsigned char *) "OOPS";
X
X  return (unsigned char *) (pw_entry->pw_name);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  stripped()						   */
X/*  BESCHREIBUNG  STRING von fuehrenden und folgenden Leerzeichen be-      */
X/*		  freien.                                                  */
X/*     PARAMETER  st  =  STRING inclusive Leerzeichen                      */
X/*     RUECKGABE  STRING exclusive Leerzeichen                             */
X/***************************************************************************/
X
Xunsigned char *stripped(st)
Xunsigned char st[];
X{
X  static unsigned char s[STRING];
X
X  int i = 0, a = 0, b = 0, c = 0;
X
X  if (st[0] == '\0') return (unsigned char *) '\0';
X  if ((st[0] == 10) || (st[0] == 13)) return (unsigned char *) " ";
X
X  strcpy(s, st);
X
X  while ((s[i] < 33) && (s[i] != '\0')) i++;
X  a = i;
X  while (s[a] != '\0') a++;
X  a--;
X  while (s[a] < 33) a--;
X
X  for (c = i; c <= a; c++) {
X	s[b] = s[c];
X	b++;
X  }
X  s[b] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  upcased()						   */
X/*  BESCHREIBUNG  Zeichen eines STRING auf Grossbuchstaben umstellen.	   */
X/*     PARAMETER  st  =  STRING mit Gross-/Kleinbuchstaben		   */
X/*     RUECKGABE  STRING in Grossbuchstaben                                */
X/***************************************************************************/
X
Xunsigned char *upcased(st)
Xunsigned char st[];
X{
X  static unsigned char s[STRING];
X
X  int i = 0;
X
X
X  strcpy(s, st);
X
X  while (s[i] != '\0') {
X	if (s[i] > 96) s[i] -= 32;
X	i++;
X  }
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  length()						   */
X/*  BESCHREIBUNG  Laenge eines STRING ermitteln (ja, ja, "strlen" ...)	   */
X/*     PARAMETER  st  =  STRING                                            */
X/*     RUECKGABE  Laenge des STRING                                        */
X/***************************************************************************/
X
Xint length(st)
Xunsigned char st[];
X{
X  int i = 0;
X
X  while (st[i] != '\0') i++;
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcopy()						   */
X/*  BESCHREIBUNG  Einen TeilSTRING aus einem STRING herausschneiden.       */
X/*     PARAMETER  st  =  STRING                                            */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilSTRING                                               */
X/***************************************************************************/
X
Xunsigned char *strcopy(st, v, b)
Xunsigned char st[];
Xint v, b;
X{
X  static unsigned char s[STRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  bigcopy()						   */
X/*  BESCHREIBUNG  Einen TeilLONGSTRING aus LONGSTRING herausschneiden.     */
X/*     PARAMETER  st  =  LONGSTRING                                        */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilLONGSTRING                                           */
X/***************************************************************************/
X
Xunsigned char *bigcopy(st, v, b)
Xunsigned char st[];
Xint v, b;
X{
X  static unsigned char s[LONGSTRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcomp()						   */
X/*  BESCHREIBUNG  Zwei STRINGs vergleichen. Und zwar genau solange, bis    */
X/*		  bei STRING1 das Ende ('\0') erreicht ist !!!             */
X/*                Gross-/Kleinschreibung wird dabei IGNORIERT !!!          */
X/*     PARAMETER  st  =  STRING1                                           */
X/*	          tt  =  STRING2                                           */
X/*     RUECKGABE  Anzahl der UNGLEICHEN Zeichen                            */
X/***************************************************************************/
X
Xint strcomp(s, t)
Xunsigned char s[], t[];
X{
X  int i = 0, a = 0;
X  int s1, t1;
X
X  while (s[i] != '\0') {
X	s1 = s[i];
X	t1 = t[i];
X	if ((t1 > 96) && (t1 < 123)) t1 -= 32;
X	if ((s1 > 96) && (s1 < 123)) s1 -= 32;
X	if (t1 != s1) a++;
X	i++;
X  }
X  return a;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ansi2()						   */
X/*  BESCHREIBUNG  TERMCAP-Eintrag fuer ein Terminal in "buf" einlesen,     */
X/*		  und angeforderte Sequenzen finden & ausgeben.            */
X/*     PARAMETER  code  =  'INIT'  =  Eintrag holen und speichern	   */
X/*		  	           =  Sequenz finden & ausgeben            */
X/*     RUECKGABE  -1  =  Terminal nicht gefunden                           */
X/*		   1  =  Sequenz nicht gefunden				   */
X/***************************************************************************/
X
Xstatic unsigned char buf[1024];
X
Xint ansi(code)
Xunsigned char code[];
X{
X  ansi2(code, 0, 0);
X}
X
Xint ansi2(code, x, y)
Xunsigned char code[];
Xint x, y;
X{
X  unsigned char *getenv();
X  static unsigned char s[STRING];
X  unsigned char *p = s;
X  unsigned char *term;
X
X#ifdef _MBOX
X  term = TERMINAL;
X#else
X  term = getenv("TERM");
X#endif
X
X  if ((x == -1) && (y == -1)) {
X	if (tgetent(buf, code) != 1) return -1;
X  }
X  if (strcomp("INIT", code) == 0) {
X	if (tgetent(buf, term) != 1) return -1;
X  }
X  if (strcomp("cm", code) == 0) {
X	if (tgetstr(code, &p) == 0) return 1;
X	printf("%s", (unsigned char *) tgoto( s, (x -1), (y -1) ));
X	return 0;
X  }
X  else{
X	if (tgetstr(code, &p) == 0) return 1;
X  }
X
X  printf("%s", s);
X
X  return 0;
X}
X
Xunsigned char *termansi(code)
Xunsigned char code[];
X{
X  unsigned char *getenv();
X  unsigned char s[STRING];
X  unsigned char *p = s;
X  unsigned char *term;
X
X#ifdef _MBOX
X  term = TERMINAL;
X#else
X  term = getenv("TERM");
X#endif
X
X  if (strcomp("INIT", code) == 0) {
X	if (tgetent(buf, term) != 1) return (unsigned char *) '\0';
X  }
X  if (tgetstr(code, &p) == 0) return (unsigned char *) '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mydate()						   */
X/*  BESCHREIBUNG  Tagesdatum liefern.  					   */
X/*     PARAMETER  mode  =  0  =  tt.mm.yyyy				   */
X/*			   1  =  tt.mm.yy				   */
X/*			   2  =  ttt					   */	
X/*     RUECKGABE  Datum                                                    */
X/***************************************************************************/
X
X#define TZS      1
X
Xunsigned char *mydate(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X  unsigned char wt[8][11];
X
X  static unsigned char s[STRING];
X
X#ifndef _MBOX
X  strcpy(wt[0], "Sonntag");
X  strcpy(wt[1], "Montag");
X  strcpy(wt[2], "Dienstag");
X  strcpy(wt[3], "Mittwoch");
X  strcpy(wt[4], "Donnerstag");
X  strcpy(wt[5], "Freitag");
X  strcpy(wt[6], "Samstag");
X#else
X  strcpy(wt[0], TOL01_MSG);
X  strcpy(wt[1], TOL02_MSG);
X  strcpy(wt[2], TOL03_MSG);
X  strcpy(wt[3], TOL04_MSG);
X  strcpy(wt[4], TOL05_MSG);
X  strcpy(wt[5], TOL06_MSG);
X  strcpy(wt[6], TOL07_MSG);
X#endif
X
X  time(&tt);
X  tp = localtime(&tt);
X  if (mode == 0) {
X	sprintf(s, "%02.2d.%02.2d.%04.4d", tp->tm_mday, tp->tm_mon + TZS, 1900 + tp->tm_year);
X  }
X  if (mode == 1) {
X	sprintf(s, "%02.2d.%02.2d.%02.2d", tp->tm_mday, tp->tm_mon + TZS, tp->tm_year);
X  }
X  if (mode == 2) {
X	sprintf(s, "%s", wt[tp->tm_wday]);
X  }
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mytime()						   */
X/*  BESCHREIBUNG  Tageszeit liefern.  					   */
X/*     PARAMETER  mode  =  0  =  hh:mm:ss				   */
X/*			   1  =  hh:mm	 				   */
X/*     RUECKGABE  Zeit                                                     */
X/***************************************************************************/
X
Xunsigned char *mytime(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X
X  static unsigned char s[STRING];
X
X  time(&tt);
X  tp = localtime(&tt);
X  sprintf(s, "%02.2d:%02.2d:%02.2d", tp->tm_hour, tp->tm_min, tp->tm_sec);
X
X  if (mode == 1) s[5] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  crypted()						   */
X/*  BESCHREIBUNG  STRING verschluesseln und zurueckgeben.		   */
X/*     PARAMETER  s  =  STRING                                             */
X/*     RUECKGABE  Verschluesselter STRING                                  */
X/***************************************************************************/
X
Xunsigned char *crypted(s)
Xunsigned char s[];
X{
X  static unsigned char t[STRING];
X  int i, a;
X
X
X  strcpy(t, s);
X  i = 0;
X  a = 2;
X  while (t[i] != '\0') {
X	t[i] = (t[i] / a) + 32;
X	i++;
X	a++;
X	if (a > 5) a = 2;
X  }
X
X  return (unsigned char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  dateconv() 						   */
X/*  BESCHREIBUNG  Datum (STRING) in Datum (LONG) wandeln.		   */
X/*     PARAMETER  d  =  Datum (STRING)                                     */
X/*     RUECKGABE  Datum (LONG)                                             */
X/***************************************************************************/
X
Xlong dateconv(d)
Xunsigned char d[];
X{
X  unsigned char s[STRING];
X  int a, b, i;
X
X
X  strcpy(s, (unsigned char *) strcopy(d, 0, 1));
X  a = atoi(s);
X  strcpy(s, (unsigned char *) strcopy(d, 3, 4));
X  b = atoi(s);
X  strcpy(s, (unsigned char *) strcopy(d, 6, 9));
X  i = atoi(s);
X  if (i < 1900) i += 1900;
X
X  sprintf(s, "%4.4d%02.2d%02.2d", i, b, a);
X
X  return atol(s);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  datereconv() 						   */
X/*  BESCHREIBUNG  Datum (LONG) in Datum (STRING) wandeln.		   */
X/*     PARAMETER  l  =  Datum (LONG)                                       */
X/*     RUECKGABE  Datum (STRING)                                           */
X/***************************************************************************/
X
Xunsigned char *datereconv(l)
Xlong l;
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X
X
X  if (l < 19000000)
X	sprintf(s, "%ld", 1900000L + l);
X  else
X	sprintf(s, "%ld", l);
X
X  strcpy(t, (unsigned char *) strcopy(s, 6, 7));
X  strcat(t, ".");
X  strcat(t, (unsigned char *) strcopy(s, 4, 5));
X  strcat(t, ".");
X  strcat(t, (unsigned char *) strcopy(s, 0, 3));
X
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timeconv() 						   */
X/*  BESCHREIBUNG  Zeit (STRING) in Zeit (LONG) wandeln.			   */
X/*     PARAMETER  t  =  Zeit (STRING)                                      */
X/*     RUECKGABE  Zeit (LONG)                                              */
X/***************************************************************************/
X
Xint timeconv(t)
Xunsigned char t[];
X{
X  unsigned char s[STRING];
X  int i = 0;
X
X
X  strcpy(s, (unsigned char *) strcopy(t, 0, 1));
X  i = 100 * atoi(s);
X  strcpy(s, (unsigned char *) strcopy(t, 3, 4));
X  i += atoi(s);
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timereconv() 						   */
X/*  BESCHREIBUNG  Zeit (LONG) in Zeit (STRING) wandeln.			   */
X/*     PARAMETER  i  =  Zeit (LONG)                                        */
X/*     RUECKGABE  Zeit (STRING)                                            */
X/***************************************************************************/
X
Xunsigned char *timereconv(i)
Xint i;
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X
X
X  if (i < 10000)
X	sprintf(s, "%04.4d00", i);
X  else
X	sprintf(s, "%06.6d", i);
X
X  strcpy(t, (unsigned char *) strcopy(s, 0, 1));
X  strcat(t, ":");
X  strcat(t, (unsigned char *) strcopy(s, 2, 3));
X  strcat(t, ":");
X  strcat(t, (unsigned char *) strcopy(s, 4, 5));
X
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  shortname() 						   */
X/*  BESCHREIBUNG  Wandelt lange Namen (NGs) ins 14-Zeichenformat, um Ver-  */
X/*                Wechslungen zu vermeiden:				   */
X/*									   */
X/*		      comp.protocols.tcp-ip.sources.wanted		   */
X/*                =>  com0ces.wanted					   */
X/*							                   */
X/*     PARAMETER  longname : langer Name                                   */
X/*									   */
X/*   									   */
X/*     RUECKGABE  s : kurzer Name                                          */
X/***************************************************************************/
X
Xunsigned char *shortname( longname )
Xunsigned char longname[];
X{
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X
X  int i = 0, j = 0;
X
X  strcpy(s, longname);
X
X  strcpy(t, longname);
X
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X
X  i = strlen(t);
X
X  if((i - j) < 15) return (unsigned char *) s;
X
X  s[j + 3] = '0'; s[j + 4] = '\0';
X  strcat(s, (unsigned char *) strcopy(t, (i-10), i));
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  maybe_locked()					   */
X/*  BESCHREIBUNG  Um sicherzustellen das eine Datei, die eigentlich vor-   */
X/*		  handen sein MUSS, wirklich nicht da ist (und nicht nur   */
X/*		  gerade von einem anderen Task benutzt wird), verzoegert  */
X/*		  diese Funktion die Fehlermeldung um eine festgelegte     */
X/*		  Zeitspanne.                                              */
X/*     PARAMETER  name  =  Dateiname				           */
X/*		  mode  =  Zugriffsmodus (sollte NICHT verwendet werden !) */
X/*     RUECKGABE   0    =  Datei erreichbar				   */
X/*		  -1    =  Datei nicht verfuegbar			   */
X/***************************************************************************/
X
Xint maybe_locked(name, mode)
Xunsigned char name[], mode[];
X{
X  FILE *fp;
X  int i = 0, LCK = 0;
X  unsigned char s[STRING];
X
X  sprintf(s, "%s.LCK", name);
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  TRY_TWICE:
X
X  fp = NULL;
X
X  do {
X	if(fp != NULL) fclose(fp);
X	fp = fopen(s, "r");
X	i++;
X	if (fp != NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);
X		printf(".");
X		sleep(3);
X	}
X  } while ((i < 8) && (fp != 0));
X
X  if(fp != 0){
X	fclose(fp);
X#ifdef _MBOX
X	mbunlock(name);  /* <--- DAS IST NATUERLICH NICHT KORREKT !!! */
X	goto TRY_TWICE;  /* <--- DAS AUCH NICHT !!! */
X	nerror("tools.c", 566, "maybe_locked", "Datei gesperrt", name);	
X#else
X	printf("\n\nDatei >>%s<< gesperrt !!!\n\n", name);
X#endif
X	exit( -1 );
X  }
X
X  i = 0;
X
X  do {
X	fp = fopen(name, "r");	/* "r" => "mode", aber VORSICHT ! */
X	i++;
X	if (fp == NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);	
X		printf(".");
X		sync();
X		sleep(3);
X	}
X  } while ((i < 5) && (fp == NULL));
X
X  if (fp == NULL) return -1;
X
X  fclose(fp);
X  return 0;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  num_stripped()					   */
X/*  BESCHREIBUNG  Entfernt alle Ziffern aus STRING.			   */
X/*     PARAMETER  s  =  STRING (incl. Ziffern)				   */
X/*     RUECKGABE  STRING (excl. Ziffern)				   */
X/***************************************************************************/
X
Xunsigned char *numstripped(s)
Xunsigned char s[];
X{
X  static unsigned char t[STRING];
X  int i = 0, a = 0;
X
X  while (s[i] != '\0') {
X	if (((s[i] > 64) && (s[i] < 127)) || (s[i] == ' ') || (s[i] == '-')) {
X		t[a] = s[i];
X		a++;
X	}
X	i++;
X  }
X  t[a] = '\0';
X
X  return (unsigned char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  rename()						   */
X/*  BESCHREIBUNG  Benennt Datei1 in Datei2 um (ok, gelogen ... Datei1 wird */
X/*		  in Datei2 kopiert).                                      */
X/*     PARAMETER  alt  =  Datei1                                           */
X/*		  neu  =  Datei2                                           */
X/*     RUECKGABE   0   =  ok                                               */
X/*		  -1   =  Datei1 nicht gefunden				   */
X/***************************************************************************/
X
X#ifndef _ANSI
X
Xint rename(alt, neu)
Xunsigned char *alt[], *neu[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  unsigned char s[250];
X
X  fp = fopen(neu, "w");
X  if (fp == NULL) {
X	return -1;
X  }
X  ff = fopen(alt, "r");
X  if (ff == NULL) {
X	return -2;
X  }
X  while (fgets(s, 250, ff) != NULL) {
X	fputs(s, fp);
X  }
X
X  fclose(fp);
X  fclose(ff);
X
X  unlink(alt);
X
X  return 0;
X}
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  headline()						   */
X/*  BESCHREIBUNG  Ueberschrift mit Ansage-Text ausgeben. Vorher wird der   */
X/*		  der Bildschirm geloescht (falls moegliche) und auf	   */
X/*		  negative Darstellung umgeschaltet.                       */
X/*     PARAMETER  line  =  Ansage-Text					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid headline(line)
Xunsigned char line[];
X{
X  unsigned char ex[255];
X  int i;
X
X
X  strcpy(ex, line);
X  i = 0;
X  while(line[i] != '\0'){
X	if(line[i] == '^'){
X		strcpy(ex, (unsigned char *) strcopy(line, 0, (i-1)));
X		line[i] = ' ';
X	}
X	i++;
X  }
X  strcpy(headinfo, ex);
X  sprintf(ex, "%s                                                                          ", line);
X  ex[79] = '\0';
X  if (ansi("cl") != -1) {
X	if (ansi("mr") == 1) {
X		if (ansi("so") == 1) { 
X			printf("\n\n------  %s  ------\n\n", line);
X			return;
X		}
X	}
X	printf("%s\n", ex);
X	if (ansi("me") == 1) {
X		ansi("se");
X	}
X  }
X  else {
X	printf("\n\n\n\n\n------  %s  ------\n\n", line);
X  }
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  mblock()						   */
X/*  BESCHREIBUNG  Schuetzt eine Datei vor ALLEN Zugriffen		   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mblock( path )
Xunsigned char path[];
X{
X  FILE *fp;
X  unsigned char s[STRING];
X
X  sprintf(s, "%s.LCK", path); 
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  fp = fopen( s, "w" );
X  fputs(VERSION, fp);
X  fclose(fp);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  unmblock()						   */
X/*  BESCHREIBUNG  Erlaubt Zugriffe auf eine Datei			   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mbunlock( path )
Xunsigned char path[];
X{
X  unsigned char s[STRING];
X  
X  sprintf(s, "%s.LCK", path); 
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  unlink(s);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  tty()							   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xint tty()
X{
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  int i, l, a, b;
X
X
X  strcpy(s, (unsigned char *) ttyname(0));
X  l = length(s);
X  i = l;
X
X  while ((s[l] != 'y') && (l > 0)) l--;
X
X  l++;
X  a = 0;
X
X  for (b = l; b < i; b++) {
X	t[a] = s[b];
X	a++;
X  }
X  t[a] = '\0';
X
X  return atoi(t);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ttyna()						   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xunsigned char *ttyna()
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X  int i, j, l;
X
X
X  strcpy(s, (unsigned char *) ttyname(0));
X
X  l = length(s) + 1;
X
X  i = 0; 
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X  (void) strcpy(t, (unsigned char *) strcopy(s, j, l));
X  
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  clearline()						   */
X/*  BESCHREIBUNG  Bildschirmzeile loeschen.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine			                                   */
X/***************************************************************************/
X
Xvoid clearline()
X{
X  printf("%c", CR);
X  if (ansi("ce") == 1) {
X	printf("                                                               ");
X  }
X  printf("%c", CR);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  isin()						   */
X/*  BESCHREIBUNG  Prueft ob ein Zeichen in einer Zeichenkette vorkommt.	   */
X/*     PARAMETER  pattern = Zeichenkette mit den moegl. Uebereinstimmungen */
X/*		  c       = Zeichen					   */
X/*     RUECKGABE  0       = Zeichen ist NICHT in Zeichenkette enthalten	   */
X/***************************************************************************/
X
Xint isin( pattern, c )
Xunsigned char pattern[];
Xint c;
X{
X  int i = 0;
X  int ok = 0;
X
X  while((pattern[i] != '\0') && (ok == 0)){
X	if(pattern[i] == c) ok++;	
X	i++;
X  }
X  
X  return (int) ok;  
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  sgrep()						   */
X/*  BESCHREIBUNG  Prueft ob Muster in einer Zeichenkette vorkommt.	   */
X/*     PARAMETER  pattern = Zeichenkette mit den moegl. Uebereinstimmungen */
X/*		  source  = Zeichenkette				   */
X/*     RUECKGABE  0       = Muster ist NICHT in Zeichenkette enthalten	   */
X/***************************************************************************/
X
Xint sgrep( source, pattern )
Xunsigned char source[];
Xunsigned char pattern[];
X{
X  unsigned char t[STRING];
X  int i = 0;
X 
X  while(source[i] != 0){
X	if(source[i] == pattern[0]){
X		strcpy(t, (unsigned char *) strcopy(source, i, strlen(source)));
X		if(strcomp(pattern, t) == 0) return (int) i;
X	}
X	i++;
X  }
X
X  return (int) 0;
X}
X
END_OF_FILE
  if test 24683 -ne `wc -c <'wendy/tools.c'`; then
    echo shar: \"'wendy/tools.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/tools.c'
fi
echo shar: End of archive 4 \(of 15\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
