Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i046:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part11/15
Message-ID: <1993Feb5.185856.10639@sparky.imd.sterling.com>
X-Md4-Signature: f38ad296a1b668ac13fbf0c49c1a8e17
Date: Fri, 5 Feb 1993 18:58:56 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 46
Archive-name: mbox/part11
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Changelog etc/english.hilfe src/games.c src/lesen.c
#   src/postfach.c wendy/getline.c
# Wrapped by kent@sparky on Fri Feb  5 12:18:14 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 15)."'
if test -f 'Changelog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Changelog'\"
else
  echo shar: Extracting \"'Changelog'\" \(10716 characters\)
  sed "s/^X//" >'Changelog' <<'END_OF_FILE'
X
XHeute, nach einem Telefonat mit Volker haben wir beschlossen die Versionen
Xder ix/MBox mal auf einen Gleichstand zu bringen.
X
XDa inzwischen mehrere Leute an der Box programmieren, verliert man leicht
Xden Ueberblick, wenn nicht von einem definierten Stand der Version ausge-
Xgangen wird.
X
XDie Version 1.6.0 soll deshalb die Version sein, auf die sich alle nach-
Xfolgenden Aenderungen beziehen!
X
XAlso wenn Aenderungen gemacht werden, diff's erzeugen und Volker schicken.
XDabei sollte man die Angabe der Version (ab Version 1.6.0) und Patchlevel
Xnicht vergessen, auf die sich das Diff bezieht!
X
XUm Aenderungen nachvollziehen zu koennen, waehre meine Bitte, an dieses
XFile kurze Erlaeuterungen zu den Aenderungen anzuhaengen!
X
X---------------------------------------------------------------------------
X
XSat Nov 16 02:21:20 MEZ 1991, Hergo Pape <hergo@ivcmd.Boerde.DE>
X
Xix/MBox 1.6 PL1::
X
X-  File patchlevel.h eingefuert, hier sind die Version, der Autor und
X   die aktuelle Patchlevel definiert. Das File wird in mbox.h eingelesen.
X
X-  Makefile geaendert, "bled" braucht nicht mehr extra uebersetzt werden.
X   Die Variable MBOXHOME eingefuehrt, daher man kann jetzt die Sourcen
X   irgendwo uebersetzen und installiert wird in MBOXHOME. Ist meiner Meinung
X   nach guenstiger fuer die Versionskontrolle.
X
X-  In nerror() den Aufruf der Funktion loop() gegen longjmp() ausgetauscht.
X   Zumindest unter ISC gibt es jetzt kein core mehr beim verlassen der Box.
X
X-  In mb-daemon.c gibt die Finktion scan() nur char zurueck! Geaendert auf
X   char *scan(), da ein String zurueckgegeben wird.
X
X-  In bled.c, HILFE wird jetzt im Makefile definiert.
X
X-  File portinfo.c, bei ps musz leider anstatt "ps a", "ps -a" angegeben
X   werden. Kann jetzt per #define in mbox.h definiert werden.
X   Wenn ich <defunkt> Prozesse habe, geht das aber auch noch nicht richtig.
X
X-  If's auf File-Zeiger von 0 nach NULL geaendert. Ich hoffe ich habe alle
X   gefunden.
X
X---------------------------------------------------------------------------
X
XSun Nov 17 09:02:12 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL1::
X
X-  Fataler Fehler im File xmd.c gefunden und behoben. 
X   (Das Uebliche: "=" oder "==", dass ist hier die Frage ...)
X
X-  Ausgabe im Modus "Seitenweise ausgeben, Seitende markieren" komplett
X   ueberarbeitet. Diese Aenderung bezieht sich auf show.c, portinfo.c,
X   tools.c, misc2.c, misc.c und lesen2.c.
X
X-  Hergo's Makefile fast komplett uebernommen - leider ist MINIXens
X   MAKE etwas umstaendlicher, desshalb musste 'ne kleinere Aenderung
X   gemacht werden.
X
X-  Die Geschichte mit "ps -a" wird generell so gefahren, denn auch
X   MINIX kennt diese Flagge. 
X
X---------------------------------------------------------------------------
X
XWed Nov 20 17:02:12 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL2::
X
X-  Im Makefile gab's noch ein paar Unstimmigkeiten .... jetzt gibt's
X   ein paar weniger :-)
X
X-  Fuer den Fall das die Datei UDBASE (siehe mbox.h) nicht existiert,
X   richtet die MBox automagisch eine Userdatenbank ein, die den 
X   Definitionen in mbox.h angepasst wird.
X
X-  In admin.c war eine Forward Deklaration nicht zulaessig.
X
X-  Die SYSV-Version hatte den "nnpost" nicht im Griff. Dieses Problem
X   ist jetzt behoben - allerdings werden Subject, Keywords und Summary
X   mit "No xxxx." gefuellt wenn sie nicht definiert vom User definiert
X   wurden.
X
X---------------------------------------------------------------------------
X
XSat Nov 23 16:22:24 MEZ 1991, Hergo Pape <hergo@ivcmd.Boerde.DE>
X
Xix/MBox 1.6 PL3::
X
X -  In coreleft.c noch ein "#include <malloc.h> eingefuegt, sonst kommt
X    bei malloc() ein Warning.
X -  Im Makefile ist weiterl.c angegeben! habe das File weiterleiten.c
X    entsprechend umbenannt.
X -  Unter ISC gibt es keine Funktion "chgrp()", das wird wie bei SYS7
X    mit chown() gemacht. 
X -  In bled.c wurde HILFE nochmal definiert! Habe #ifndef Klammer drum
X    gesetzt.
X -  In xmd.c fehlt in der Funktion main(), ganz hinten eine Klammer '}'!.
X
X---------------------------------------------------------------------------
X
XSun Nov 24 11:15:43 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL3::
X
X -  Die Flagge -D_ISC sorgt dafuer, dass auch unter Interactive UNIX
X    der System Call "chown" statt "chown"&"chgrp" eingesetzt wird.
X
X -  Die Flagge -D_DATESTAMP gibt auf der Console (oder auf was immer
X    gerade per REDIRECT umgeleitet wird) zusaetlich zu den alten MBox-
X    Informatione auch Datum und Uhrzeit aus.
X
X---------------------------------------------------------------------------
X
XWed Dec 4 19:41:02 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL4::
X
X -  Die Flagge -D_SCO entspricht fast komplett -D_ISC. Allerdings wird
X    die Definition der ENTER Taste bei -D_SCO zusaetzlich beeinflusst
X    (ENTER = 13).
X
X -  Im Makefile fehlte bei PROGS die Angabe "xmd" ("mb-daemon" war doppelt
X    aufgefuehrt.
X
X -  Die Umbenennung von "weiterleiten.c" auf "weiterl.c" bleibt auch
X    weiterhin den Installateuren ueberlassen :-)
X
X
X---------------------------------------------------------------------------
X
XSun Dec 8 19:41:02 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL4::
X
X -  Da die MBox ab sofort komplett auf RMAIL und INEWS aufsetzt, gibt's
X    ein paar GROESSERE Aenderungen:
X
X    Die Modi SYS_ACCOUNT und HDB_UUCP wurden komplett deaktiviert.
X
X    Die Kommunikation mit RMAIL, INEWS und SMAIL (?) laeuft ueber drei
X    Shell-Scripts: $MBOXHOME/etc/rmail.sh, ~/etc/inews.sh und ~/etc/alias.sh
X
X -  Bisher habe ich es nicht fertig gebracht auf SETUID "root" zu verzichten.    
X    Auch nach der Umstellung auf RMAIL/INEWS laufen MB-DAEMON und MBOX
X    nur mit "root"-Permissions fehlerfrei.
X
X---------------------------------------------------------------------------
X
XSat Dec 28 18:11:41 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6e PL5::
X    
X -  Alle Text-Zeilen im Source-Code der ix/MBox wurden entfernt und durch
X    #DEFINES ersetzt. Diese Defines koennen ueber das "Language-File"
X    [mbox.msg] belegt werde.
X
X -  Die Dateien [help.befehle], [help.hilfe] und [help.shorthelp] liegen
X    in englischen Versionen vor. Das gilt auch fuer die Dokumentation.
X
X -  Verschiedene Fehler in "lesen2.c" und "admin.c" wurden behoben. Ausserdem
X    wird neue Post auch direkt beim Anmelden angekuendigt. 
X
X
X---------------------------------------------------------------------------
X
XWed Jan 1 11:11:11 CET 1992, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL6::
X
X -  Probleme mit "ifdef XXX || XXX" in [defs.h] und [getline.c] geloest.
X
X -  Der XMD wertet nur noch das erste Auftreten von "From:" und "Subject:"
X    aus. Bei "From" (aus dem Envelope) gibt's 'ne Sonderregelung. 
X
X---------------------------------------------------------------------------
X
XWed Jan 4 22:31:51 CET 1992, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL6::
X
X -  Befehl "Suchen" testweise implementiert. Er setzt auf GREP auf.
X
X -  Die Header von MAIL und NEWS koennen editiert werden. "Followup" und
X    "Poster" werden erkannt und ausgewertet.
X
X---------------------------------------------------------------------------
X
XTue Feb 17 21:02:32 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL8.7::
X
X -  Befehl "User" erweitert: Informationen ueber lokale User aus der
X    Userdatenbank, oder per "uux" von anderen Sites.
X
X -  Sicherheitslecks in "postfach.c" und "admin.c" gefunden und entschaerft.
X
X -  Header werden generell <intensive> ausgegeben.
X
X -  Funktion "Download" bietet die Option mehrer Dateien mit einem
X    Kommando zu uebertragen.
X
X -  Funktion "Statistik #" zeigt zusaetlich die Ausnutzung der Baudrate
X    in Prozent an.
X
X -  Befehl "Statistik %" errechnet eine HITLISTE aus der Liste der
X    Downloads.
X
X -  Erfassung in "postfach.c" und "admin.c" erlaubt keine Sonderzeichen
X    in Name, Nick/Alias und Shell-Name.
X
X -  XMD verfuegt ueber eine XMD.ALIAS-Datei, in der Empfaenger-Adressen
X    lokal umgeleitet werden koennen.
X
X -  Das Makefile wurde ERHEBLICH verbessert!
X
X -  Die INDEX-Files muessen nicht mehr global fuer alle Gruppen im
X    voraus gebildet werden, sondern koennen auch online von der MBox
X    gruppenweise erstellt werden.
X
X---------------------------------------------------------------------------
X
XFri May 28 19:53:21 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL10::
X
X -  MB-DAEMON wurde erheblich verbessert, was zu einem Geschwindigkeits-
X    vorteil von bis zu 200% fuehrt
X
X -  RTF (Richtext Format) und 'Quoted-Printable' sind jetzt fuer alle
X    MBox-User lesbar
X
X -  Erste Schritte ich Richtung MultiMedia-Mail sind implementiert 
X
X -  Neue Befehle: EDIT, DOWNLOAD
X
X -  Es wurde ein Accouting-Mechanismus eingefuehrt, der levelabhaengig
X    greift - dadurch laesst sich eine Trennung von zahlenden und nicht-
X    zahlenden Usern herstellen
X
X---------------------------------------------------------------------------
X
XSat Jun 6 14:11:01 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL10a::
X
X -  Der Befehl "BRETT !" wurde erweitert: Er zeigt jetzt neben dem
X    Namen eines Brettes auch den entsprechenden Informationstext an
X
X -  Es gibt jetzt eine Moeglichkeit externe Kommandos direkt in die
X    Befehls-Struktur der MBox einzubinden
X
X---------------------------------------------------------------------------
X
XWed Nov 25 24:00:00 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL10j2::
X
X -  Umlaute werden nach ISO-8859-1 und IBM konvertiert. Natuerlich ist
X    eine Umsetztung nach 'ae', 'oe', ... moeglich.
X
X -  RTF-Preview wurde entsfernt. Stattdessen gibt's einen neuen Fullscreen-
X    Editor, der RTF-tauglich ist.
X
X -  Der Befehl "STATISTIK >" zeigt die Aktivitaeten von XMD an.
X
X -  Der Befehl "DISKUSSION" listet die Artikel/Gruppen, die ein User
X    gesendet hat.
X
X -  XMD laesst sich als Gateway konfigurieren: "name%node@mailbox" ...
X
X -  Der Befehl "LOESCHEN >" entfernt alle 'Antworten', die sich im
X    privaten Postfach befinden.
X
X---------------------------------------------------------------------------
X
XSun Jan 16 15:53:03 CET 1993, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL10j7::
X
X -  Weiterer Terminaltyp COLOR-ANSI implementiert.
X    
X -  Der Befehl "USER" wurde um die Flagge "%" erweitert. Dieser Befehl
X    zeigt die Userliste mit den NEWSGROUPS an.
X
X -  Die Headerzeile "Return-Receipt-To:" wird sowohl beim Senden als
X    auch beim Empfangen von Mails unterstuetzt. 
X
X -  Wenn ein neues Postfach eingerichtet wird, geht automatisch eine
X    Info-Mail an den Sysop.
X
X -  Die aktuelle Version wird am 17.01.1993 an "comp.sources.misc"
X    verschickt.
X
X 
END_OF_FILE
  if test 10716 -ne `wc -c <'Changelog'`; then
    echo shar: \"'Changelog'\" unpacked with wrong size!
  fi
  # end of 'Changelog'
fi
if test -f 'etc/english.hilfe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.hilfe'\"
else
  echo shar: Extracting \"'etc/english.hilfe'\" \(10356 characters\)
  sed "s/^X//" >'etc/english.hilfe' <<'END_OF_FILE'
X#?
XCommand: "?"
X
XYou'll get a list of all commands, which you may use. The contents of this
Xlist depends on your user-level. Type "? *", if you like to see ALL commands
Xof this BBS.
X
X#0
XCommand: "0" ("1-9")
X
XThere is a "dynamic command buffer", who captures every input you type at
Xthe command-prompt. Type "0" to see which commands are in buffer, or any
Xnumber between 1 and 9 to execute one of those commands. Of course, you may
Xuse the cursor-keys to select any command, too.
X
X#+
XCommand: "+"
X
XJump to the next board with new articles.
X
X#-
XCommand: "-"
XJump to the previous board with new articles.
X
X#ACCOUNT
XCommand: "Account"
X
XYou need to registered to send and receive mails to/from all over the
Xworld. The registration makes you a fully accepted user of this BBS.
XYou're now reachable by mail from users on this host or on any host, this
Xhost is connected to.
X
XPLEASE use your full name as username !
X
X#AREA
XCommand: "Area"
X
XThis command makes it possible to jump between groups ('ar ++', 'ar --') or
Xjust subgroups ('ar +', 'ar -').
X
X#BOARD
XCommand: "Board"
X
XThere is a board for every single subject/theme with it's own index. So you
Xhadn't to search long for special information on any item. To move from one
Xboard to another, you use the command "board" with some options:
X
XBOARD                      list boards with new articles
XBOARD *                    list all boards depending on userlevel
XBOARD **                   list ALL boards
XBOARD +                    go to the next board
XBOARD -                    go to the previous board
XBOARD !                    display the name of the current board
XBOARD #                    list areas in board
XBOARD ..		   step from one area to the previous one
XBOARD boardname            jump to board "boardname"
X
X#CHAT
XCommand: "Chat"
X
X- systemdepending stuff -
X
X#DATE
XCommand: "Date"
X
XShows the current date. (Not quite right ... it's shows the systems date :-)
X
X#DELETE
XCommand: "Delete"
X
XDelete mails or articles. NOTE: Be careful! If you type "delete" in your
XPM, every (!) mail will be scratched!
X
XDELETE			   delete all your mail
XDELETE article		   delete article no. "article"
XDELETE article-article	   delete from "article" to "article"
X
X#DIR
XCommand: "Dir"
X
XThis will give you a survey of what subjects are collect in the current
Xboard. If you hadn't add a '*', you'll ony see the entries which are
Xnew for you.
X
XDIR                        index new articles
XDIR *                      index ALL articles (of a board)
X
X#DIRECTION
XCommand: "Direction"
X
XIt's sounds pretty funny, but this commands decides whether you see
Xanswers before questions or not :-)
X
X#DOWNLOAD
XCommand: "Download"
X
XYou may use this to fetch a couple of articles. Just type in which
Xarticles you want, and choose the prefered xfer-protocol.
X
X#EDIT
XCommand: "Edit"
X
XFor the folks that are never quite satisfied with their work, the
Xcommand "edit" offers the possibility to re-edit the text. Depending
Xon the userlevel, changing other users articles is allowed, too ;-)
X
X#FINGER
XCommand: "Finger"
X
XGetting informations about specified users is very easy. Use the command
X"finger username" for local users, or "finger host!username" for users
Xwho work on other sites.
X
X#FORWARD
XCommand: "Forward"
X
XIf you like to send copies of mails/articles to other users, you may use
Xthis command. The variable "user" (see below) stand for every kind of
Xaddress (i.e. "Prename.Name", "host!name", "name@host.domain" etc.). So
Xit is possible to forward articles to your own shell-account on this host,
Xor to your account on any other host ... this may be useful sometimes.
X
XFORWARD                    list stored mails
XFORWARD user               forward a stored mail to "user"
XFORWARD mail user          forward "mail" to "user"
XFORWARD article user       forward "article" to "user"
X
X#GAMES
XCommand: "Games"
X
XThe list, that will be shown if you enter this command, includes some
Xgames you may play. They all have own accounting procedures and different
Xinstruction sets ... so don't blame the sysop for anything that will
Xhappen to you :-)
X
X#GOODBYE
XCommand: "Goodbye"
X
XNEVER use this command! (Exception: If you REALLY want to leave :-)
X
X#HELP
XCommand: "Help"
X
XYou managed to get this information ... so why do you ask ???
X
XHELP                       this shorthelp
XHELP *                     display some pages of helpful descriptions
XHELP command               show information on "command"
X
X#MAIL
XCommand: "Mail"
X
XOne of the most powerful commands on this BBS. If you are fitted out with
Xthe right user-level, you're able to send mails to receivers all over the
Xworld ... or just to another BBS-user.
X
XMAIL Prename.Name          (Prename.Name i.e. "Volker.Schuermann")
XMAIL Alias                 (Alias i.e. "Sysop")
XMAIL Shell-Account         (Shell-Account i.e. "volkers")
X
XThese three commands will deliver a mail to a user on this host. If this user
Xhas his own BBS-account, the mail will be sent to his BBS-maildrop. 
XOtherwise his/her shell-account-maildrop will be filled ... 
X
XMAIL Host!User             (Host!User i.e. "unnet!Volker.Schuermann")
XMAIL User@Host.Domain      (User@Host.Domain i.e. "volker@unnet.w.open.de")
X
XBoth commands will send the mail to a user on another host (if "host" or
X"host@domain" are the address of this host, the mail won't leave this host).
X
X#MACRO
XCommand: "Macro"
X
XFor all lazy/intelligent users, here is a way to simplify work! Just create
Xa new command to collect a group of commands:
X
Xnew = b comp.os.minix, d, key, b sub.os.minix, b
X
XThe new command "new" will jump to board "comp.os.minix" and show the index
Xof new articels. If you hit (the) any key, it moves to "sub.os.minix" and 
Xdoes the same.
X
XMacro = Command Sequence
X===========================================================================
Xandi  = mail andreas@xenox.ruhr.de
Xwalt  = mail Walter, forward weller!walterb
Xgrp   = mail volkers, forw xenox, forw stefans, forw joergg
Xsts   = mail Stefan S, forw stefans@coduck.ruhr.sub.org, forw unnet!stefans
Xin    = +, dir, KEY, in
Xpp    = PORTINFO, SLEEP 5, pp
X
XThe entries "in" and "pp" are demonstrating how to build recursive commands.
XUse CTRL-X to break the run of such a command sequence!
X
X#MESSAGE
XCommand: "Message"
X
XYou may use this text to inform other users that you're offline for a
Xfew days or that you never answers mail or what ever ...
X
XThis text is shown to everybody who wants to send a mail to you on this
Xhost.
X
X#MINIX
XCommand: "Minix"
X
XIf you'd have to leave the BBS everytime you like to do something on
Xshell-level, it would be a nice swapping around on this system. But with
Xthe command "minix", you can do everything (even start the BBS :-) without
Xleaving ... 
X
X#PORTINFO
XCommand: "Portinfo"
X
XHave a look on what the other users are doing. This includes BBS-users
Xas well as shell-only-users (poor guys :-)
X
X#PROTOCOL
XCommand: "Protocol"
X
XSee WHO called in WHEN from WHERE on WHICH line ... puhh, but that's exactly
Xwhat this command is doing.
X
XIf you use the option "#" (means "protocol #"), the informations are shown
Xas a diagram (for statistics purposes). 
X
X#PM
XCommand: "PM"
X
XMove to the board with your BBS-maildrop. There you may check your incomming
Xmails and answer (reply) them.
X
X#READ
XCommand: "Read"
X
XThat's how to get the information hidden behind the subjects ... the options
Xto this command a described in the following:
X
XREAD                       read NEW articles
XREAD *                     real ALL articles (of a board)
XREAD article               show article no. "article"
XREAD article-article       display from "article" to "article"
X
XThe line "READ article" builds an exceptions ... if the listing of the
Xspecified article is complete, the BBS shows a little menu to you. Type
Xa "?" at the prompt to see what actions are available there!
X
XUsing this form of the command "read" is the most convenient way to consume
Xarticles!!! 
X
X#SETUP
XCommand: "Setup"
X
XTo make life easier (especially YOUR life), you may change lot's of the
XBBS depending paramaters. The SETUP is fully controlled by menu, so you
Xonly have to hit keys (more or less astonished because of the features 
Xyou never noticed before) ...
X
X#SIGNATURE
XCommand: "Signature"
X
XUse this command to create a text, that will be sent as a footnote of every
Xmail/article you'll write on this BBS. Have a look on the ".signatures"
Xof other ppl. to see which facts belong to such a text ...  
X
X#STATE
XCommand: "State"
X
XGives a summary of all data, this BBS has stored in it's accouting database.
XOf course,only that part of data is shown, that belongs to you!
X
X#STATISTICS
XCommand: "Statistics"
X
XThe BBS collects some information for statistics purpose. If you are inter-
Xested in those statistics, use one of the following options:
X
XSTATISTICS                 table containing NEWS-statistics
XSTATISTICS *               table containing more NEWS-statistics
XSTATISTICS $               UUCP-rates (only if UUCP supports this)
XSTATISTICS #               download-statistics 
X
XThe option "$" depends on the systems UUCP-Support. Ask your Sysop whether
Xthis system accounts UUCP-Rates or not.
X
X#TIME
XCommand: "Time"
X
XShows the system time and the time you're online in seconds ... my goodness,
Xfive hours, and still online ...
X
X#USERS
XCommand: "Users"
X
XYep, you're not alone on this host. To see who's on too, type one of the
Xfollowing commands:
X
XUSERS                      show users list
XUSERS *                    show users list (more detailed)
XUSERS #                    users up-/download ratio
X
XIf your level is to low, you won't be able to use the "#" option - don't
Xbe angry, it's not as much interesting, as it seems to be (use "stati #"
Xinstead :-)
X
X#VERSION
XCommand: "Version"
X
XThis option was built in for other Sysops only - they may use it to spy out
Xwhich BBS is the older one - nothing else.
X
XVERSION                    print version
XVERSION *                  display compiling definitions
XVERSION #                  the "Hall of Fame"
X
XThe option "#" gives a list of ppl., who were members of the "BBS gold crew"
Xduring it's development :-)
X
X#WRITE
XCommand: "Write"
X
XUse this command to create a new article for any board or newsgroup on this
XBBS. Depending on your user-level this article will be sent with distribution
X"world", "*group*" or "local". 
X
XDon't use this command to send mails to other users ... try it, if you don't
Xtrust in documentations. 
END_OF_FILE
  if test 10356 -ne `wc -c <'etc/english.hilfe'`; then
    echo shar: \"'etc/english.hilfe'\" unpacked with wrong size!
  fi
  # end of 'etc/english.hilfe'
fi
if test -f 'src/games.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/games.c'\"
else
  echo shar: Extracting \"'src/games.c'\" \(1173 characters\)
  sed "s/^X//" >'src/games.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  games.c						   */
X/*        FUNKTIONEN  games()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  25.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include "mbox.h"
X
X
Xgames()
X{
X  FILE *fp;
X  int i, c;
X
X  unsigned char s[STRING];
X  unsigned char GAME[MAX_GAMES][STRING];
X
X
X  headline( GA01_MSG );
X  printf("\n");
X
X  fp = fopen(GAMES, "r");
X  if (fp == NULL) {
X	nerror("games.c", 19, "games", "Datei-Lesefehler", GAMES);
X  }
X  i = 0;
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  while((i < MAX_GAMES) && (fscanf(fp, "%s %s", s, GAME[i]) > 0)){
X	i++;
X	printf("  %d - %s\n\n", i, s); 
X  }
X  fclose(fp);
X
X  ansi("md");
X  printf("\n%s > ", GA02_MSG);
X  ansi("me");
X
X  c = getint();
X  if(c > 32) printf("%c", c);
X  c -= 49;
X
X  if((c >= 0) && (c < i)){
X	printf("\n\n");
X	sprintf(s, "%s %s %d %d", RSH, GAME[c], OLDUID, OLDGID);
X	system(s);	
X  }
X  else{
X	ansi("md");
X	printf(" %s\n", GA03_MSG);
X	ansi("me");
X  }
X}
X
END_OF_FILE
  if test 1173 -ne `wc -c <'src/games.c'`; then
    echo shar: \"'src/games.c'\" unpacked with wrong size!
  fi
  # end of 'src/games.c'
fi
if test -f 'src/lesen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lesen.c'\"
else
  echo shar: Extracting \"'src/lesen.c'\" \(9853 characters\)
  sed "s/^X//" >'src/lesen.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  lesen.c						   */
X/*        FUNKTIONEN  lesen(), ansage(), unterschrift()			   */
X/*		      getsite(), checkdomaintype()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  30.10.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <utmp.h>
X#include <time.h>
X
X
X#include "mbox.h"
X
X
Xextern unsigned char headinfo[STRING];
X
X
X/***************************************************************************/
X/*      FUNKTION  lesen()						   */
X/*  BESCHREIBUNG  Zeigt einen Artikel o. eine persoenliche Mail an. Bietet */
X/*		  dann versch. Optionen zum Weiterlesen o. Beantworten an. */
X/*     PARAMETER  arg  =  Nummer des Artikels/der Mail                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid lesen(arg)
Xunsigned char arg[];
X{
X  FILE *fp;
X  unsigned char s[LSTRING];
X  unsigned char entry[STRING];
X  unsigned char no[10];
X  unsigned char c;
X  int i;
X  int ok;
X  int MIN, MAX;
X  int pr;
X
X  struct stat fst;
X
X  sprintf(no, "%s", arg);
X
X  maybe_locked(INHALT, "r");
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	nerror("misc.c", 558, "lesen", "Datei-Lesefehler", INHALT);
X  }
X  while ((fgets(s, LSTRING, fp) != NULL) && (s[2] != '='));
X  fgets(s, LSTRING, fp);
X  MIN = atoi(s);
X  while (fgets(s, LSTRING, fp) != NULL) {
X	MAX = atoi(s);
X  }
X  fclose(fp);
X
X  if (MAX < MIN) {
X	i = MIN;
X	MIN = MAX;
X	MAX = i;
X  }
X
X  NEXT_MSG:
X
X  if ((no[0] < '1') || (no[0] > '9')) {
X	ansi("md");
X	printf(" %s\n", MIS41_MSG);
X	ansi("me");
X	return;
X  }
X  if (pruefe(no) != 0) goto NEXT_NEXT;
X
X  printf("\n\n");
X  ansi("cl");
X
X  if (strcomp(BRETT, "PM") != 0) {
X        sprintf(entry, "%s/%s", BRETT, no); 
X	if(USER.terminal == 4){
X		ansi("md");
X		printf("%s %s\n", MIS42_MSG, no);
X		ansi("me");
X	}
X	else{
X		sprintf(headinfo, " %s %s (%s) ", MIS43_MSG, no, NG);
X		headline( headinfo );
X	}
X	ok = show(entry, 9999, USER.more);
X  }
X  else {
X	sprintf(entry, "%s/usr/%d/%s", HOME, USER.id, no);
X	if(USER.terminal == 4){
X		ansi("md");
X		printf("%s %s\n", MIS44_MSG, no);
X		ansi("me");
X	}
X	else{
X		sprintf(headinfo, " %s (%s) ", MIS45_MSG, no);
X		headline( headinfo );
X	}
X	ok = show(entry, 9999, USER.more);
X  }
X
X  if(ok == -1) return;
X  if(ok == -9){
X	if(USER.leserichtung == 1){
X		c = MIS52_MSG;
X	}
X	else{
X		c = MIS51_MSG;
X 	}
X	goto NEXT_DIS;
X  }
X
X  c = LF;
X
X  NEXT_NEXT:
X
X  printf("\n");
X  ansi("mr");
X  printf("[Mesg. %s] %s, ? > ", no, MIS46_MSG);
X  ansi("me");
X  printf("%c%c", MIS51_MSG, BS);
X
X  do {
X	c = getint();
X	if (strcomp(BRETT, "PM") == 0) {
X		if (c == MIS50_MSG) c = '*';
X	}
X	if (c >= 97) c -= 32;
X	if (c == ENTER) c = MIS51_MSG;
X	if (c == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, MIS53_MSG);
X		ansi("me");
X	}
X	if ((c != MIS47_MSG) && (c != MIS48_MSG) && (c != MIS49_MSG) && (c != MIS50_MSG) && (c != MIS51_MSG) && (c != MIS52_MSG) && (c != '*'))
X		c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  NEXT_DIS:
X
X  if (c == MIS50_MSG) {		/* LOESCHEN */
X	clearline();
X	ansi("mr");
X	printf("%s [%c, %c] > ", MIS54_MSG, GBL06_MSG, GBL07_MSG);
X	ansi("me");
X	if (yesno() == GBL06_MSG) {
X		loeschen(no);
X	}
X	printf("\n");
X	c = MIS51_MSG;
X  }
X  if (c == '*') {		/* LOESCHEN (sofort) */
X	loeschen(no);
X	printf("\n");
X	c = MIS51_MSG;
X  }
X  if (c == MIS51_MSG) {		/* NAECHSTE */
X	ok = 0;
X	do {
X		i = atoi(no);
X		i++;
X		sprintf(no, "%d", i);
X		pr = pruefe(no);
X		if (pr == 0) ok = 1;
X		if (pr == 1) goto NEXT_NEXT;
X		if (i > MAX) {
X			printf("\n\n%s\n", MIS55_MSG);
X			return;
X		}
X	} while (ok == 0);
X	if (ok == 1) goto NEXT_MSG;
X	goto NEXT_NEXT;
X  }
X  if (c == MIS52_MSG) {		/* VORHERIGE */
X	ok = 0;
X	do {
X		i = atoi(no);
X		i--;
X		sprintf(no, "%d", i);
X		pr = pruefe(no);
X		if (pr == 0) ok = 1;
X		if (pr == 1) goto NEXT_NEXT;
X		if (i < MIN) {
X			printf("\n\n%s\n", MIS56_MSG);
X			return;
X		}
X	} while (ok == 0);
X	if (ok == 1) goto NEXT_MSG;
X	goto NEXT_NEXT;
X  }
X  if (c == MIS49_MSG) goto NEXT_MSG;	/* WIEDERHOLEN */
X
X
X  if (c == MIS48_MSG) {			/* BEANTWORTEN */
X	headline( MIS57_MSG );
X	printf("\n%s", MIS58_MSG);
X	sprintf(s, "cp %s %s/%dRep > /dev/null", entry, TMP, getpid());
X	system(s);
X
X	if (strcomp(BRETT, "PM") == 0) {
X		if(brief("~REPLY~") != -1){
X			sprintf(s, "%s?", USER.name);
X			brief(s);
X			sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X			stat(s, &fst);
X			IDX_SIZE = (int) fst.st_size;
X		}
X	}
X	else {
X		printf("\n\n");
X		ansi("mr");
X		printf("%s, ? > ", MIS59_MSG);
X		ansi("me");
X
X		do {
X			c = getint();
X			if (c >= 97) c -= 32;
X			if (c == '?') {
X				clearline();
X				ansi("mr");
X				printf("%c%s > ", CR, MIS60_MSG);
X				ansi("me");
X			}
X			if ((c != MIS61_MSG) && (c != MIS62_MSG)) c = 0;
X		} while (c == 0);
X
X		printf("%c", c);
X
X		if (c == MIS62_MSG) {
X			schreiben("");
X		}
X		if (c == MIS61_MSG) {
X			if((brief("~REPLY~") != -1) && (strcomp(GUEST, USER.name) != 0)){
X				sprintf(s, "%s?", USER.name);
X				brief(s);
X				sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X				stat(s, &fst);
X			        IDX_SIZE = (long) fst.st_size;
X			}
X		}
X	}
X	goto NEXT_NEXT;
X  }
X  printf("\n");
X  return;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  ansage()						   */
X/*  BESCHREIBUNG  Der Ansage-Text wird angezeigt und kann geandert werden. */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid ansage()
X{
X  FILE *ff;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char TEP[STRING];
X  unsigned char c;
X
X
X  printf("\n\n%s\n\n", MAL38_MSG);
X
X  sprintf(TEP, "%s/usr/%d/.hello", HOME, USER.id);
X  ff = fopen(TEP, "r");
X  if (ff != NULL) {
X	ansi("md");
X	while (fgets(s, 80, ff) != NULL) {
X		printf("%s", s);
X	}
X	fclose(ff);
X	ansi("me");
X	printf("\n\n");
X  }
X  ansi("mr");
X  printf("%c%s [%c, %c] > ", CR, MAL39_MSG, GBL06_MSG, GBL07_MSG);
X  ansi("me");
X
X  c = yesno();
X
X  if (c == GBL06_MSG) {
X	sprintf(t, "%s %s", EDDY, TEP);
X	system(t);
X  }
X  printf("\n");
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  unterschrift						   */
X/*  BESCHREIBUNG  Die Unterschrift (.signature) wird angezeigt und kann    */
X/*		  geandert werden.                                         */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid unterschrift()
X{
X  FILE *ff;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char TEP[STRING];
X  unsigned char c;
X
X
X  printf("\n\n%s\n\n", MAL40_MSG);
X
X  sprintf(TEP, "%s/usr/%d/.signature", HOME, USER.id);
X  ff = fopen(TEP, "r");
X  if (ff != NULL) {
X	ansi("md");
X	while (fgets(s, 80, ff) != NULL) {
X		printf("%s", s);
X	}
X	fclose(ff);
X	ansi("me");
X	printf("\n\n");
X  }
X  ansi("mr");
X  printf("%c%s [%c, %c] > ", CR, MAL41_MSG, GBL06_MSG, GBL07_MSG);
X  ansi("me");
X
X  c = yesno();
X
X  if (c == GBL06_MSG) {
X	sprintf(t, "%s %s", EDDY, TEP);
X	system(t);
X  }
X  printf("\n");
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  getsite()						   */
X/*  BESCHREIBUNG  Findet den Empfaenger SITE in der Adresse		   */
X/*     PARAMETER  Adresse                                                  */
X/*     RUECKGABE  Empfaenger SITE                                          */
X/***************************************************************************/
X
Xunsigned char *getsite(arg)
Xunsigned char arg[];
X{
X  int i = 0, a = 0, b = 0, c = 0;
X  unsigned char s[STRING];
X
X  while(arg[i] != '\0'){
X	if(arg[i] == '!') a = i - 1;
X	if(arg[i] == '@') b = i + 1;
X	if(arg[i] == '.'){
X		if((b != 0) && (c == 0)) c = i -1;
X	}
X	i++;
X  }
X
X  if((a == 0) && (b == 0)) strcat(s, UUCPSITE);
X  if(a != 0) strcpy(s, (unsigned char *) strcopy(arg, 0, a));
X  if(b != 0) strcpy(s, (unsigned char *) strcopy(arg, b, c));
X
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  checkdomaintype()					   */
X/*  BESCHREIBUNG  Internationale MAIL ???			 	   */
X/*     PARAMETER  Adresse                                                  */
X/*     RUECKGABE   0 = ok                                                  */
X/*                -1 = Level zu gering					   */
X/***************************************************************************/
X
Xint checkdomaintype(arg)
Xunsigned char arg[];
X{
X  int i = 0, l, a, e = 0, f = 0, g = 0, international = 0;
X  unsigned char s[STRING];
X
X  if(USER.level >= WRITE_INTERNAT) return 0;
X
X  while(arg[i] != '\0'){
X	if(arg[i] == '!') e++;
X	if(arg[i] == '@') g++;
X	i++;
X  }
X  s[0] = '\0';
X
X  if((e == 0) && (g == 0)) return 0;
X
X  if(e > 1) international++;
X
X  if(e == 0){
X
X	l = strlen( (unsigned char *) arg);
X
X	a = strlen( (unsigned char *) NAT_DOMAIN1 );
X	strcpy(s, (unsigned char *) strcopy(arg, (l-a), l));
X	if(strcomp(s, NAT_DOMAIN1) == 0) f++;
X
X	a = strlen( (unsigned char *) NAT_DOMAIN2 );
X	strcpy(s, (unsigned char *) strcopy(arg, (l-a), l));
X	if(strcomp(s, NAT_DOMAIN2) == 0) f++;
X
X	a = strlen( (unsigned char *) NAT_DOMAIN3 );
X	strcpy(s, (unsigned char *) strcopy(arg, (l-a), l));
X	if(strcomp(s, NAT_DOMAIN3) == 0) f++;  	
X
X	if(f == 0) international++;
X  }  
X
X  if(international != 0){
X	ansi("md");
X	printf("\n\n%s (%d) %s\n", MAL01_MSG, WRITE_INTERNAT, MAL02_MSG);
X	ansi("me");
X	return -1;	
X  }
X
X  return 0;
X}
X
X
X
X
END_OF_FILE
  if test 9853 -ne `wc -c <'src/lesen.c'`; then
    echo shar: \"'src/lesen.c'\" unpacked with wrong size!
  fi
  # end of 'src/lesen.c'
fi
if test -f 'src/postfach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/postfach.c'\"
else
  echo shar: Extracting \"'src/postfach.c'\" \(9214 characters\)
  sed "s/^X//" >'src/postfach.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  postfach.c					   */
X/*        FUNKTIONEN  postfach()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1992					   */
X/***************************************************************************/
X  
X#include <stdio.h>
X#include <sys/types.h>
X#include <fcntl.h>
X#include <unistd.h>
X#include <ctype.h>
X
X#include "mbox.h"
X
X
X
X/***************************************************************************/
X/*      FUNKTION  postfach()						   */
X/*  BESCHREIBUNG  Postfach und versch. Dateien fuer einen neuen Teil-      */
X/*		  nehmer einrichten.                                       */
X/*     PARAMETER  arg  =  '*'  =  normaler Aufruf, wird geprueft	   */
X/*			       =  Aufruf von ADMIN                         */
X/*		       =  '#'  =  Neuinstallation der UDBASE		   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid postfach(arg)
Xunsigned char arg[];
X{
X  int fd;
X  FILE *fp;
X  unsigned char s[STRING*2];
X  unsigned char t[STRING*2];
X  struct userdaten LOOSER;
X  struct userdaten POSTER;
X  int ok, i, j, c;
X  long ll;
X
X
X  if (arg[0] == '*') {
X	if ((strcomp(GUEST, USER.name) != 0) &&
X	    (strcomp(POSTMASTER, USER.sh_name) != 0)) {
X		ansi("md");
X		printf(" %s\n", POS01_MSG);
X		ansi("me");
X		return;
X	}
X  }
X  
X  if (arg[0] == '#') {
X
X	if (arg[1] == '1') { /* ADMINISTRATION */
X
X		strcpy(USER.name, "Administration");
X		strcpy(USER.sh_name, POSTMASTER);
X		strcpy(USER.nick, "Sysop");
X
X		USER.id = 1;
X		USER.level = 10;
X
X		printf("%s - %s (%s)\n", POS04_MSG, USER.name, USER.sh_name);
X
X		fp = fopen(UDSEQ, "w");
X		if (fp == NULL) {
X			nerror("postfach.c", 63, "postfach", "Datei-Schreibfehler", UDSEQ);
X		}
X		fputs("1", fp);
X		fclose(fp);
X		
X		fp = fopen(UDBASE, "w");
X		fclose(fp);
X	}	 
X	if (arg[1] == '2') { /* GUEST */
X	
X		strcpy(USER.name, GUEST);
X		strcpy(USER.sh_name, GBL10_MSG);
X		strcpy(USER.nick, POS03_MSG);
X
X		USER.id = 2;
X		USER.level = 0;
X	
X		printf("%s - %s (%s)\n", POS05_MSG, USER.name, USER.sh_name);
X	}
X
X	strcpy(USER.passwort, "*****");
X	strcpy(USER.wohnort, "");
X	strcpy(USER.strasse, "???");
X	strcpy(USER.telefon1, "???");
X	strcpy(USER.telefon2, "???");
X	strcpy(USER.geburtsdatum, "00.00.0000");
X	strcpy(USER.account, "00.00.0000 000.00");
X
X	goto INIT_UDBASE;
X  }
X
X  maybe_locked(UDBASE, "r"); 
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("postfach.c", 51, "postfach", "Datei-Lesefehler", UDBASE);
X  }
X  headline( POS06_MSG );
X  ansi("md");
X  printf("\n%s\n%s\n%s\n\n", POS07_MSG, POS08_MSG, POS09_MSG);
X  ansi("me");
X
X  RETRY_1:
X
X  printf("\n%s ", POS10_MSG);
X  strcpy(s, POSTER.name);
X  strcpy(POSTER.name, (unsigned char *) getline(30, 15, '.', ""));
X  if ((strcomp("<BREAK>", POSTER.name) == 0) || (POSTER.name[0] < 64) || (POSTER.name[1] < 64)) {
X	strcpy(POSTER.name, s);
X	printf("\n\n");
X	ansi("md");
X	printf("%s", POS11_MSG);
X	ansi("me");
X	printf("\n");
X	return;
X  }
X  ansi("md");
X  printf("\n%s", POS12_MSG);
X  ok = 0;
X  strcpy(POSTER.name, (unsigned char *) stripped(POSTER.name));
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, (unsigned char *) &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (ok == 0)) {
X	if (strcomp(POSTER.name, LOOSER.name)    == 0) ok = 1;
X	if (strcomp(POSTER.name, LOOSER.nick)    == 0) ok = 1;
X	if (strcomp(POSTER.name, LOOSER.sh_name) == 0) ok = 1;
X  }
X
X  if (USER.level < ADMIN_LEV){
X	  if ((strcomp("SYSOP", POSTER.name) == 0) ||
X	      (strcomp("POST",  POSTER.name) == 0) ||
X	      (strcomp("GAST",  POSTER.name) == 0) ||
X	      (strcomp("ADMIN", POSTER.name) == 0) ||
X	      (strcomp("COSYS", POSTER.name) == 0)) ok = 1;
X  }
X
X  if (ok == 1) {
X	printf(" %s\n", POS13_MSG);
X	ansi("me");
X	sprintf(POSTER.name, "%s", s);
X	goto RETRY_1;
X  }
X  ansi("me");
X
X  do {
X	printf("%c%s ", CR, POS14_MSG);
X	strcpy(s, (unsigned char *) getline(10, 11, '.', ""));
X	if (strcomp("<BREAK>", s) == 0) s[0] = '\0';
X	strcpy(POSTER.passwort, (unsigned char *) crypted(s));
X	if (length(POSTER.passwort) < 5) {
X		ansi("md");
X		printf("\n%s", POS15_MSG);		
X		ansi("me");
X	}
X  } while (length(POSTER.passwort) < 5);
X
XRETRY_2:
X
X  printf("\n%s ", POS16_MSG);
X  strcpy(s, getline(30, 15, '.', ""));
X  if (strcomp("<BREAK>", s) == 0) {
X	strcpy(s, "John Doe");
X  }
X  strcpy(POSTER.nick, (unsigned char *) stripped(s));
X
X  ansi("md");
X  printf("\n%s", POS12_MSG);
X  ok = 0;
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, (unsigned char *) &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (ok == 0)) {
X	if (strcomp(POSTER.nick, LOOSER.nick)    == 0) ok = 1;
X	if (strcomp(POSTER.nick, LOOSER.name)    == 0) ok = 1;
X	if (strcomp(POSTER.nick, LOOSER.sh_name) == 0) ok = 1;
X  }
X
X  if (USER.level < ADMIN_LEV){
X	  if ((strcomp("SYSOP", POSTER.nick) == 0) ||
X	      (strcomp("POST",  POSTER.nick) == 0) ||
X	      (strcomp("GAST",  POSTER.nick) == 0) ||
X	      (strcomp("ADMIN", POSTER.nick) == 0) ||
X	      (strcomp("COSYS", POSTER.nick) == 0)) ok = 1;
X  }
X
X  if (ok == 1) {
X	printf(" %s\n", POS13_MSG);
X	ansi("me");
X	goto RETRY_2;
X  }
X  ansi("me");
X
X
X  printf("%c%s ", CR, POS17_MSG);
X  strcpy(POSTER.wohnort, (unsigned char *) getline(30, 11, '.', ""));
X
X  printf("\n%s ", POS18_MSG);
X  strcpy(POSTER.strasse, (unsigned char *) getline(30, 11, '.', ""));
X
X  printf("\n%s ", POS19_MSG);
X  strcpy(POSTER.telefon1, (unsigned char *) getline(20, 11, '.', ""));
X
X  printf("\n%s ", POS20_MSG);
X  strcpy(POSTER.telefon2, (unsigned char *) getline(20, 11, '.', ""));
X
X  printf("\n%s ", POS21_MSG);
X  strcpy(POSTER.geburtsdatum, (unsigned char *) getline(10, 114, '?', ""));
X
X  close(fd);
X
X  ansi("md");
X  printf("\n\n%s\n%s\n\n", POS22_MSG, POS23_MSG);
X  ansi("me");
X
X  USER.level = 0;
X  if(USER.id == 1) USER.level = 10; /* POSTMASTER-Account */
X
X  if (arg[0] != '*') {
X	sprintf(s, "%s", arg);
X	s[14] = '\0';
X	strcpy(USER.sh_name, s);
X	USER.level = WRITE_EX_LEV;
X  }
X  else USER.sh_name[0] = '\0';
X
X  sprintf(USER.name, "%s", POSTER.name);
X  sprintf(USER.passwort, "%s", POSTER.passwort);
X  sprintf(USER.nick, "%s", POSTER.nick);
X  sprintf(USER.wohnort, "%s", POSTER.wohnort);
X  sprintf(USER.strasse, "%s", POSTER.strasse);
X  sprintf(USER.telefon1, "%s", POSTER.telefon1);
X  sprintf(USER.telefon2, "%s", POSTER.telefon2);
X  sprintf(USER.geburtsdatum, "%s", POSTER.geburtsdatum);   
X
X
X  INIT_UDBASE:
X
X  if(USER.terminal < 3)
X	USER.editor = 2;
X  else
X	USER.editor = 1;
X  USER.prompt = 2;
X  USER.bell = 0;
X  USER.more = 1;
X  USER.seq = 0;
X  USER.intro = 3;
X  LASTLOG = (long) dateconv( (unsigned char *) "01.01.1970");
X  strcpy(USER.lastlog, (unsigned char *) mydate( 0 ));
X  USER.lasttime = 0;
X  USER.lastmode = 2;
X  USER.leserichtung = 1;
X  USER.upratio = 0L;
X  USER.downratio = 0L;
X  USER.elapsed = 0L;
X  sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X  strcpy(USER.account, "00.00.0000 000.00");
X
X  maybe_locked(UDSEQ, "r"); mblock(UDSEQ);
X  fp = fopen(UDSEQ, "r");
X  if (fp == NULL) {
X	nerror("postfach.c", 188, "postfach", "Datei-Lesefehler", UDSEQ);
X  }
X  fscanf(fp, "%d", &USER.id);
X  fclose(fp);
X  mbunlock(UDSEQ);
X
X  if(USER.id < 1) USER.id = 1;
X
X  maybe_locked(UDSEQ, "r"); mblock(UDSEQ);
X  fp = fopen(UDSEQ, "w");
X  if (fp == NULL) {
X	nerror("postfach.c", 196 , "postfach", "Datei-Schreibfehler", UDSEQ);
X  }
X  fprintf(fp, "%d\n", (USER.id + 1));
X  fclose(fp);
X  mbunlock(UDSEQ);
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDWR);
X  if (fd == -1) {
X	nerror("postfach.c", 204, "postfach", "Datei-Lesefehler", UDBASE);
X  }
X  ll = lseek(fd, 0L, SEEK_END);
X  write(fd, (unsigned char *) &USER, sizeof(USER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  sprintf(s, "%s/usr/%d", HOME, USER.id);
X  if(mkdir(s, 0777) != 0){
X	printf("\n\n%s\n\n", POS24aMSG);	
X	nerror("postfach.c", 295, "postfach", "Datei-Erstellungsfehler", s);	
X  }  
X
X  sprintf(s, "%s/usr/%d/seq", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("1\n", fp);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.hello", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("\n", fp);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.signature", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("\n", fp);
X  fclose(fp);
X
X  if (arg[0] != '*') {
X	sprintf(s, "cp /usr/%s/%s %s/usr/%d/.signature &", USER.sh_name, SIGNATURE,
X		HOME, USER.id);
X	system(s);
X  }
X  sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X  fp = fopen(s, "w");
X  fprintf(fp, "%s\n", GBL05_MSG);
X  fputs("===============================================================================\n", fp);
X  fclose(fp);
X
X  if (arg[0] == '#') {
X	return; /* UDBASE installiert */
X  }
X
X  i = 0;
X  strcpy(t, USER.name);
X  while(t[i] != '\0'){
X	if(t[i] == ' ') t[i] = '.';
X	i++;
X  }
X
X  sprintf(s, "/bin/sh ./etc/alias.sh \"%s\"", t);
X  system( s );
X
X
X  sprintf(s, "%s \"%s\" (%d)", POS24_MSG, USER.name, USER.id);
X  control(s, 3);
X
X  init_user( POS25_MSG );
X  printf("\n");
X
X  sprintf(s, "%s/usr/%d/.lastletter", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("FYI ;-)", fp);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X  fp = fopen(s, "w");
X  fprintf(fp, ">--- %s (%d) --->>", POS26_MSG, USER.id);
X  fclose(fp);
X
X  sprintf(s, "%s?", POSTMASTER );
X  brief( s );
X  
X}
X
END_OF_FILE
  if test 9214 -ne `wc -c <'src/postfach.c'`; then
    echo shar: \"'src/postfach.c'\" unpacked with wrong size!
  fi
  # end of 'src/postfach.c'
fi
if test -f 'wendy/getline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/getline.c'\"
else
  echo shar: Extracting \"'wendy/getline.c'\" \(8445 characters\)
  sed "s/^X//" >'wendy/getline.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  getline.c						   */
X/*        FUNKTIONEN  getline(), getint(), yesno()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  17.11.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#ifdef _MBOX
X#include "mbox.h"
X#else
X#define BS		8
X#define CR		13
X#define LF		10
X#define CTRL_X		24
X#define CTRL_D		4
X#define BELL		7
X#define ESC		27
X#define DEL		127
X#define GBL06_MSG	'J' 	
X#define GBL07_MSG	'N'	
X
Xint UMLAUT = 0;
X
X#ifdef _SYS7
X#define ENTER		13
X#else
X#define ENTER	 	10
X#endif
X#endif
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X/***************************************************************************/
X/*      FUNKTION  getline()						   */
X/*  BESCHREIBUNG  Eine Zeile (STRING) einlesen. Beendet wird mit ENTER,	   */
X/*		  oder wenn die max. zulaessige Anzahl von Zeichen er-     */
X/*		  reicht ist.	                                           */
X/*     PARAMETER  siehe unten                                              */
X/*     RUECKGABE  Eingelesene Zeile (STRING)				   */
X/*  ---------------------------------------------------------------------  */
X/*  len     -> Anzahl der max. einzulesenden Zeichen     		   */
X/*									   */
X/*  mode    ->      >0 = 7BIT						   */
X/*		     0 = Kein Echo					   */
X/*	   	     1 = Mit Echo				           */
X/*       	     2 = '*' als Echo				           */
X/*		     3 = ':' als drittes & sechstes Zeichen (Uhrzeit)      */
X/*	             4 = '.' als drittes & sechstes Zeichen (Datum)        */
X/*	 	     5 = Ausschliesslich BUCHSTABEN			   */
X/*		    10 = "bsc" vor der Eingabe "len"-mal ausgeben          */
X/*		   100 = nur Zahlen (und '.', ':')                         */
X/*	 	  1000 = String "deftext" + "bsc" ausgeben                 */
X/*		 10000 = bei "0-9" als erstes Zeichen -> sofort zurueck    */
X/*								           */
X/*  bsc     -> Mit diesem Zeichen wird geloescht			   */
X/*								           */
X/*  deftext -> Text-Vorgabe                                                */
X/*			                                                   */
X/***************************************************************************/
X
Xstatic int endless;
X
Xunsigned char *getline(len, mode, bsc, deftext)
Xint len, mode;
Xint bsc;
Xunsigned char deftext[];
X{
X  static unsigned char gls[STRING];
X  int c;
X  int gli, gll;
X  int delim = '\0';
X  int matrix = 0;
X  int echo = 1, numerics = 0, defmode = 0, letters = 0;
X  int escape = 0;
X  int lenmem = len;
X  int lastwasblank = 0;
X  int siebenbit = 0;
X  
X  if (mode < 0) {
X	siebenbit++;
X	mode *= -1;
X  }
X  if (mode > 10000) {
X	escape++;
X	mode -= 10000;
X  }
X  if (mode > 1000) {
X	mode -= 1000;
X	defmode++;
X  }
X  if (mode > 100) {
X	mode -= 100;
X	numerics++;
X  }
X  if (mode > 10) {
X	mode -= 10;
X	matrix++;
X  }
X  if (mode > 2) {
X	switch(mode){
X		case 3	: delim = ':';
X			  break;
X		case 4  : delim = '.';		
X			  break;
X	 	case 5  : letters++;
X			  break;
X	}
X	mode = 1;
X  }
X  echo = mode;
X
X  if (defmode != 0) {
X	if((deftext[0] < 32) || (deftext[0] > 126)) deftext[0] = '\0';
X	gll = length(deftext);
X	lenmem = len - gll;
X	if(deftext[0] != '\0'){
X		sprintf(gls, "%s", deftext);
X		printf("%s", deftext);
X	}
X	else gls[0] = '\0';
X  }
X  else {
X	gll = 0;
X	strcpy(gls, (unsigned char *) "OOPS");
X  }
X
X  if (matrix != 0) {
X	for (gli = 0; gli < lenmem; gli++) {
X		if (((gli == 2) || (gli == 5)) && (delim != '\0') && (gli != len)) {
X			printf("%c", delim);
X		}
X		else {
X			printf("%c", bsc);
X		}
X	}
X	for (gli = 0; gli < lenmem; gli++) printf("%c", BS);
X  }
X
X  do {
X
X	if (delim != '\0') {
X		if (((gll == 2) || (gll == 5)) && (gll < len)){
X			c = delim;
X		}
X		else {
X			c = getint();  
X		}
X	}
X	else {
X		c = getint();  
X	}        
X
X	if(siebenbit != 0){
X		if(c > 127) c = 0;
X	}
X
X	if (c == ESC) {
X		c = getint();  
X		c = getint();  
X		if ((c == 'A') || (c == 'B')) {
X			if (c == 'A') endless++;
X			if (c == 'B') endless--;
X			if (endless < 1) endless = 9;
X			if (endless > 9) endless = 1;
X			sprintf(gls, "%d", endless);
X			return (unsigned char *) gls;
X		}
X		if (c == 'D') c = BS;
X		if (c == 'C') c = ENTER;
X	}
X	if ((c == CTRL_X) || (c == CTRL_D) || (c == DEL)) {
X		return("<BREAK>");
X	}
X	if (c != ENTER) {
X		if ((c == BS) && (gll > 0)) {
X			if (((gll == 3) || (gll == 6)) && (delim != '\0')) {
X				gll -= 2;
X				printf("%c%c%c%c", BS, BS, bsc, BS);
X			} else {
X				gll--;
X				printf("%c%c%c", BS, bsc, BS);
X			}
X		}
X		if (numerics == 0) {
X			if (c >= 32) {
X				if(letters != 0){
X					if((c < 'A') && (c != ' ')) c = 0;
X					if(c > 'z') c = 0;
X					if((c > 'Z') && (c < 'a')) c = 0;
X
X					if(c == ' '){
X						if(lastwasblank != 0) c = 0;
X						lastwasblank++;
X					}
X					else{
X						if(c != 0) lastwasblank = 0;
X					}				
X
X					/*
X					if((c == 0) && (USER.bell == 1))
X						printf("%c", BELL);
X					*/
X					if(c == 0)
X						printf("%c", BELL);
X				}
X				if(c != 0){
X					gls[gll] = c;
X					gll++;
X				}
X			}
X			else {
X				c = 0;
X			}
X		}
X		else {
X			if ((c == '.') || (c == ':') || ((c >= '0') && (c <= '9'))) {
X				if (((delim != '\0') && ((c == '.') || (c == ':'))) &&
X				    ((gll != 2) && (gll != 5))) {
X					printf("%c", BELL);
X					c = 0;
X				}
X				else {
X					gls[gll] = c;
X					gll++;
X					gls[gll] = '\0';
X				}
X			}
X			else {
X				if (c != BS) printf("%c", BELL);
X				c = 0;
X			}
X		}
X		if (c != 0) {
X			if (echo == 1) printf("%c", c);
X			if (echo == 2) printf("*");
X		}
X	}
X	if (gll == 1) {
X		if ((escape != 0) && ((c > 47) && (c < 58))) {
X			gls[gll] = '\0';
X			return (unsigned char *) gls;
X		}
X	}
X
X  } while ((c != ENTER) && (gll < len));
X
X  gls[gll] = '\0';
X
X  return (unsigned char *) gls;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  getint() 						   */
X/*  BESCHREIBUNG  Ein Zeichen wird mit Hilfe der "getch"-Funktion einge-   */
X/*		  lesen. Es wird gewartet bis ein Zeichen erfasst ist.     */
X/*     PARAMETER  keine                                                    */
X/*     RUECKGABE  Eingelesenes Zeichen (INT)				   */
X/***************************************************************************/
X
X
Xint getint()
X{
X  int c;
X
X
X  if(UMLAUT != 0){
X	c = UMLAUT;
X	UMLAUT = 0;
X	return (int) c;
X  }
X
X  do{
X	c = (int) getch();
X
X#ifndef _UMLAUT
X
X	if(c > 127){
X
X		UMLAUT = 'e';
X
X		switch(c){
X			case 142 : c = 'A'; /* IBM 'Ae' */
X				   break;
X			case 153 : c = 'O'; /* IBM 'Oe' */
X				   break;
X			case 154 : c = 'U'; /* IBM 'Ue' */
X				   break;
X			case 132 : c = 'a'; /* IBM 'ae' */
X				   break;
X			case 148 : c = 'o'; /* IBM 'oe' */
X				   break;
X			case 129 : c = 'u'; /* IBM 'ue' */
X				   break;
X			case 225 : c = 's'; /* IBM 'ss' */
X				   UMLAUT = 's';
X				   break;
X
X			case 196 : c = 'A'; /* AMIGA 'Ae' */
X				   break;
X			case 214 : c = 'O'; /* AMIGA 'Oe' */
X				   break;
X			case 220 : c = 'U'; /* AMIGA 'Ue' */
X				   break;
X			case 228 : c = 'a'; /* AMIGA 'ae' */
X				   break;
X			case 246 : c = 'o'; /* AMIGA 'oe' */
X				   break;
X			case 252 : c = 'u'; /* AMIGA 'ue' */
X				   break;
X			case 223 : c = 's'; /* AMIGA 'ss' */
X				   UMLAUT = 's';
X				   break;
X
X#ifdef I_LIKE_CONFUSIONS
X		        case 128 : c = 'A'; /* APPLE 'Ae' */
X				   break;
X			case 133 : c = 'O'; /* APPLE 'Oe' */
X				   break;
X			case 134 : c = 'U'; /* APPLE 'Ue' */
X				   break;
X			case 138 : c = 'a'; /* APPLE 'ae' */
X				   break;
X			case 154 : c = 'o'; /* APPLE 'oe' */
X				   break;
X			case 159 : c = 'u'; /* APPLE 'ue' */
X				   break;
X			case 167 : c = 's'; /* APPLE 'ss' */
X				   UMLAUT = 's';
X				   break;
X#endif /* _CONFUSION */
X			default  : UMLAUT = 0;
X		}		
X        }
X
X  }while((c == 0) || (c > 127));
X
X#else /* _UMLAUT */
X
X  }while(c == 0);
X
X#endif /* _UMLAUT */
X
X
X  return (int) c;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  yesno()						   */
X/*  BESCHREIBUNG  Die Zeichen "j", "J", "n" oder "N" werden ausschliess-   */
X/*		  lich eingelesen und zurueckgegeben.	                   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  Eines der Zeichen (siehe oben) (INT)			   */
X/***************************************************************************/
X
Xint yesno()
X{
X  int c;
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if ((c != GBL06_MSG) && (c != GBL07_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  return (int) c;
X}
X
X
END_OF_FILE
  if test 8445 -ne `wc -c <'wendy/getline.c'`; then
    echo shar: \"'wendy/getline.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/getline.c'
fi
echo shar: End of archive 11 \(of 15\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
