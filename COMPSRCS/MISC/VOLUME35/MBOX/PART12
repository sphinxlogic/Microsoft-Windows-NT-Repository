Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i047:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part12/15
Message-ID: <1993Feb5.185924.10723@sparky.imd.sterling.com>
X-Md4-Signature: 7efb0bf7e626b95e31085c80df1ce32b
Date: Fri, 5 Feb 1993 18:59:24 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 47
Archive-name: mbox/part12
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  etc/deutsch.s.U etc/help.s.U src/control.c src/getline.c
#   src/main.c wendy/misc.c wendy/wendy.c
# Wrapped by kent@sparky on Fri Feb  5 12:18:15 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 15)."'
if test -f 'etc/deutsch.s.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/deutsch.s.U'\"
else
  echo shar: Extracting \"'etc/deutsch.s.U'\" \(7113 characters\)
  sed "s/^X//" >'etc/deutsch.s.U' <<'END_OF_FILE'
Xbegin 644 etc/deutsch.shorth
XM/R @(" @(" @(" @(" @(" @(" @(" @(" @0F5F96AL<X%B97)S:6-H=" H
XM;&5V96QA8FB$;F=I9RD*/R J(" @(" @(" @(" @(" @(" @(" @(" @0F5F
XM96AL<X%B97)S:6-H=" H86QL92!"969E:&QE*0I"969E:&P@/R @(" @(" @
XM(" @(" @(" @("!);F9O<FUA=&EO;F5N('IU(")"969E:&PB"@HP(" @(" @
XM(" @(" @(" @(" @(" @(" @("!);FAA;'0@9&5S($)E9F5H;'-P=69F97)S
XM"C$M.2 @(" @(" @(" @(" @(" @(" @(" @($)E9F5H;"!A=7,@9&5M(%!U
XM9F9E<B!A8G)U9F5N"@HK(" @(" @(" @(" @(" @(" @(" @(" @("!796-H
XM<V5L;B!I;G,@;H1C:'-T92!"<F5T="!M:70@;F5U96X@07)T:6ME;&X*"BT@
XM(" @(" @(" @(" @(" @(" @(" @(" @(%=E8VAS96QN(&EN<R!V;W)H97)I
XM9V4@0G)E='0@;6ET(&YE=65N($%R=&EK96QN"@I!3E)51D52(" @(" @(" @
XM(" @(" @(" @("!!;G)U9F5R<')O=&]K;VQL"D%.4E5&15(@*B @(" @(" @
XM(" @(" @(" @($%N<G5F97)P<F]T;VMO;&P@*&MO;7!L971T*0I!3E)51D52
XM(",@(" @(" @(" @(" @(" @("!3=&%T:7-T:6L@9&5R($%N<G5F90I!3E)5
XM1D52("4@(" @(" @(" @(" @(" @("!3=&%T:7-T:6L@9&5R($%N<G5F97(@
XM*$AI=&QI<W1E*0H*04Y304=%(" @(" @(" @(" @(" @(" @(" @36ET=&5I
XM;'5N9W-T97AT(&%N>F5I9V5N+X1N9&5R;@H*0E)%5%0@(" @(" @(" @(" @
XM(" @(" @(" @0G)E='1E<B!M:70@86MT=65L;&5N($%R=&EK96QN(&%N>F5I
XM9V5N"D)21514("H@(" @(" @(" @(" @(" @(" @($%L;&4@0G)E='1E<B!A
XM;GIE:6=E;B H;&5V96QA8FB$;F=I9RD*0E)%5%0@*BH@(" @(" @(" @(" @
XM(" @(" @04Q,12!"<F5T=&5R(&%N>F5I9V5N"D)21514("L@(" @(" @(" @
XM(" @(" @(" @(%=E8VAS96QN(&EN<R!NA&-H<W1E($)R971T"D)21514("T@
XM(" @(" @(" @(" @(" @(" @(%=E8VAS96QN(&EN<R!V;W)H97)I9V4@0G)E
XM='0*0E)%5%0@(2 @(" @(" @(" @(" @(" @(" @06MT=65L;&5N($)R971T
XM;F%M96X@875S9V5B96X*0E)%5%0@(R @(" @(" @(" @(" @(" @(" @1W)U
XM<'!E;B H07)E87,I(&%U<V=E8F5N"D)21514("XN(" @(" @(" @(" @(" @
XM(" @($EN;F5R:&%L8B!E:6YE<B!'<G5P<&4@:6YS('9O<FAE<FEG92!"<F5T
XM="!W96-H<V5L;@I"4D545"!"<F5T=&YA;64@(" @(" @(" @("!);G,@0G)E
XM='0@(D)R971T;F%M92(@=V5C:'-E;&X*"D)2245&(%5S97(@(" @(" @(" @
XM(" @(" @(%!E<G.4;FQI8VAE($YA8VAR:6-H="!A;B B57-E<B(@<V5N9&5N
XM"D)2245&($AO<W0A57-E<B @(" @(" @(" @(%!E<G.4;FQI8VAE($YA8VAR
XM:6-H="!A;B B57-E<B(@875F(")(;W-T(@H*0TA!5" @(" @(" @(" @(" @
XM(" @(" @(" @375L=&EP;W)T($-H871S>7-T96T*"D1)4TM54U-)3TX@*B @
XM(" @(" @(" @(" @($%N('=E;&-H96X@1&ES:W5S<VEO;F5N(&)I;B!I8V@@
XM8F5T96EL:6=T/PI$25-+55-324].(" @(" @(" @(" @(" @("!$96T@5&AE
XM;6$@96EN97(@1&ES:W5S<VEO;B!D=7)C:"!E:6YE($=R=7!P92!F;VQG96X*
XM"D1/5TY,3T%$(" @(" @(" @(" @(" @(" @($1I97-E($9U;FMT:6]N(&5R
XM;&%U8G0@97,L($%R=&EK96P@=6YD(%!R;V=R86UM90H@(" @(" @(" @(" @
XM(" @(" @(" @(" @("!U;G1E<B!0<F]T;VMO;&PM2V]N=')O;&QE;B!Z=2!E
XM;7!F86YG96X*"D5$250@07)T:6ME;" @(" @(" @(" @(" @($1E<B!!<G1I
XM:V5L(&UI="!D97(@3G5M;65R(")!<G1I:V5L(B!K86YN"B @(" @(" @(" @
XM(" @(" @(" @(" @(" @(&YA8VAT<H1G;&EC:"!E9&ET:65R="!W97)D96X*
XM"D5.1$4@(" @(" @(" @(" @(" @(" @(" @($UA:6QB;W@@=F5R;&%S<V5N
XM"D5.1$4@*B @(" @(" @(" @(" @(" @(" @($UA:6QB;W@@=F5R;&%S<V5N
XM("A38V%N;F5R(&YI8VAT(&%K='5A;&QI<VEE<F5N*0H*1U)54%!%("L@(" @
XM(" @(" @(" @(" @(" @6G5R(&YE>'1E;B!'<G5P<&4@96EN97(@56YT97)G
XM<G5P<&4*1U)54%!%("LK(" @(" @(" @(" @(" @(" @6G5R(&YE>'1E;B!'
XM<G5P<&4*1U)54%!%("T@(" @(" @(" @(" @(" @(" @6G5R('9O<FAE<FEG
XM96X@1W)U<'!E(&5I;F5R(%5N=&5R9W)U<'!E"D=255!012 M+2 @(" @(" @
XM(" @(" @(" @(%IU<B!V;W)H97)I9V5N($=R=7!P90H*2$E,1D4@(" @(" @
XM(" @(" @(" @(" @(" @1&EE<V4@2W5R>FAI;&9E(&%N>F5I9V5N"DA)3$9%
XM("H@(" @(" @(" @(" @(" @(" @($AI;&9S=&5X=&4@:V]M<&QE='0@875S
XM9V5B96X*2$E,1D4@0F5F96AL(" @(" @(" @(" @(" @2&EL9G-T97AT('IU
XM;2!"969E:&P@(D)E9F5H;"(@>F5I9V5N"@I)3DA!3%0@(" @(" @(" @(" @
XM(" @(" @("!);F1E>"!D97(@86MT=65L;&5N($%R=&EK96P@875S9V5B96X*
XM24Y(04Q4("H@(" @(" @(" @(" @(" @(" @06QL92!!<G1I:V5L(&5I;F5S
XM($)R971T97,@86YZ96EG96X*"DQ%4T5.(" @(" @(" @(" @(" @(" @(" @
XM($YE=64@07)T:6ME;"!L:7-T96X*3$5314X@*B @(" @(" @(" @(" @(" @
XM(" @06QL92!!<G1I:V5L(&QI<W1E;@I,15-%3B!!<G1I:V5L(" @(" @(" @
XM(" @("!!<G1I:V5L(&UI="!D97(@3G5M;65R(")!<G1I:V5L(B!A=7-G96)E
XM;@I,15-%3B!!<G1I:V5L+4%R=&EK96P@(" @("!!<G1I:V5L('9O;B!.=6UM
XM97(@(D%R=&EK96PB(&)I<R B07)T:6ME;"(@>F5I9V5N"@I,3T530TA%3B!!
XM<G1I:V5L(" @(" @(" @("!!<G1I:V5L($YU;6UE<B B07)T:6ME;"(@;)1S
XM8VAE;@I,3T530TA%3B!!<G1I:V5L+4%R=&EK96P@("!,E'-C:&5N('9O;B B
XM07)T:6ME;"(@8FES(")!<G1I:V5L(@I,3T530TA%3B ^(" @(" @(" @(" @
XM(" @("!!;&QE($MO<&EE;B H(2D@96EG96YE<B!-86EL<R!LE'-C:&5N"@I-
XM04M23R @(" @(" @(" @(" @(" @(" @("!-86MR;W9E<F5I;F)A<G5N9V5N
XM('IE:6=E;B^$;F1E<FX*"DU)3DE8(%-H96QL+4)E9F5H;" @(" @(" @($5X
XM=&5R;F5S($MO;6UA;F1O(")3:&5L;"U"969E:&PB(&%U<V:!:')E;@H*3U54
XM1$E!3" @(" @(" @(" @(" @(" @(" @5F5R8FEN9'5N9R!Z=2!E>'1E<FYE
XM;B!(;W-T<R!V:6$@1&%T97@M4 H*4$T@(" @(" @(" @(" @(" @(" @(" @
XM(" @26YS('!E<G.4;FQI8VAE(%9E<GIE:6-H;FES('=E8VAS96QN"@I03U)4
XM24Y&3R @(" @(" @(" @(" @(" @("!!:W1I=FETA'1E;B!D97(@=F5R<V-H
XM:65D96YE;B!497)M:6YA;',@>F5I9V5N"@I03U-41D%#2" @(" @(" @(" @
XM(" @(" @("!0;W-T9F%C:"!E:6YR:6-H=&5N"@I224-(5%5.1R @(" @(" @
XM(" @(" @(" @("!,97-E<FEC:'1U;F<@*&%L=" \+3X@;F5U*2"$;F1E<FX*
XM"E-#2%)%24)%3B @(" @(" @(" @(" @(" @($%R=&EK96P@97)F87-S96X@
XM=6YD('-P96EC:&5R;@H*4T5455 @(" @(" @(" @(" @(" @(" @(" @4&5R
XM<Y1N;&EC:&4@06YP87-S=6YG96X*"E-0245,12 @(" @(" @(" @(" @(" @
XM(" @(%9E<G-C:&EE9&5N92!3<&EE;&4@=V5R9&5N(&%U9F=E;&ES=&5T+V%U
XM9F=E<G5F96X*"E-405154R @(" @(" @(" @(" @(" @(" @($%U<V=A8F4@
XM9&5R(&5I9V5N96X@06YP87-S=6YG96X*"E-4051)4U1)2R @(" @(" @(" @
XM(" @(" @($1A=&5I+5-T871I<W1I:R!D97(@=F5R<V-H+B!"<F5T=&5R(&%N
XM>F5I9V5N"E-4051)4U1)2R J(" @(" @(" @(" @(" @(%-T871I<W1I:R!K
XM;VUP;&5T="!A=7-G96)E;@I35$%425-424L@)" @(" @(" @(" @(" @("":
XM8F5R<VEC:'0@9&5R(%550U M1V5B@6AR96X*4U1!5$E35$E+(",@(" @(" @
XM(" @(" @(" @4')O=&]K;VQL(&1E<B!$;W=N;&]A9',@*%!$+4)R971T97(I
XM"E-4051)4U1)2R E(" @(" @(" @(" @(" @(%!R;W1O:V]L;"!D97(@1&]W
XM;FQO861S("A(251,25-412D*4U1!5$E35$E+(#X@(" @(" @(" @(" @(" @
XM4')O=&]K;VQL(&1E<R!8340@*$UA:6QE<BD*"E-50TA%3B!-=7-T97(@(" @
XM(" @(" @(" @($%R=&EK96P@96EN97,@0G)E='1E<R!N86-H(")-=7-T97(B
XM(&1U<F-H<W5C:&5N"@I365-)3D9/(" @(" @(" @(" @(" @(" @("!!;&QG
XM96UE:6YE($EN9F]R;6%T:6]N96X@>G5R($UA:6QB;W@*"E5.5$524T-(4DE&
XM5" @(" @(" @(" @(" @(%5N=&5R<V-H<FEF="!A;GIE:6=E;B^$;F1E<FX*
XM"E503$]!1" @(" @(" @(" @(" @(" @(" @($1I97-E($9U;FMT:6]N('=I
XM<F0@=65B97(@9&5N($)E9F5H;"!30TA214E"14X*(" @(" @(" @(" @(" @
XM(" @(" @(" @(" @875T;VUA=&ES8V@@875F9V5R=69E;@H*55-%4B @(" @
XM(" @(" @(" @(" @(" @(" @57-E<FQI<W1E(&%U<V=E8F5N"E5315(@*B @
XM(" @(" @(" @(" @(" @(" @(%5S97)L:7-T92!M:70@97)W96ET97)E;B!)
XM;F9O<FUA=&EO;F5N"E5315(@(R @(" @(" @(" @(" @(" @(" @(%5S97)L
XM:7-T92!M:70@57 M+T1O=VYL;V%D(%9E<FB$;'1N:7,*55-%4B E(" @(" @
XM(" @(" @(" @(" @(" @57-E<FQI<W1E(&UI="!!;F=A8F4@9&5R($=R=7!P
XM96XO3F5W<V=R;W5P<PI54T52("0@(" @(" @(" @(" @(" @(" @("!5<V5R
XM;&ES=&4@>G5R($=E8H%H<F5N86)R96-H;G5N9PI54T52($YA;64@(" @(" @
XM(" @(" @(" @("!);F9O<FUA=&EO;F5N((%B97(@9&5N(%1E:6QN96AM97)N
XM(").86UE(@H*54U,0554(" @(" @(" @(" @(" @(" @(" @56UL875T+4MO
XM;G9E<G1I97)U;F<@96EN+2!U;F0@875S<V-H86QT96X*"E9%4E-)3TX@(" @
XM(" @(" @(" @(" @(" @(%9E<G-I;VYS;G5M;65R(&%U<V=E8F5N"E9%4E-)
XM3TX@*B @(" @(" @(" @(" @(" @(%9E<G-I;VYS;G5M;65R('5N9"!$969I
XM;FET:6]N96X@875S9V5B96X*5D524TE/3B C(" @(" @(" @(" @(" @(" @
XM5F5R<VEO;G-N=6UM97(@=6YD(")(86QL(&]F($9A;64B(&%U<V=E8F5N"@I7
XM14E415),14E414X@(" @(" @(" @(" @("!796ET97)L96ET8F%R92!037,@
XM86YZ96EG96X*5T5)5$523$5)5$5.(%5S97(@(" @(" @(" @5V5I=&5R;&5I
XM=&)A<F4@4$T@86X@(E5S97(B('-E;F1E;@I714E415),14E414X@07)T:6ME
XM;"!5<V5R("!!<G1I:V5L($YU;6UE<B B07)T:6ME;"(@86X@(E5S97(B('-E
X%;F1E;@IR
X 
Xend
END_OF_FILE
  if test 7113 -ne `wc -c <'etc/deutsch.s.U'`; then
    echo shar: \"'etc/deutsch.s.U'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'etc/deutsch.shorth'\" \(5135 characters\)
    cat etc/deutsch.s.U | uudecode
    if test 5135 -ne `wc -c <'etc/deutsch.shorth'`; then
      echo shar: \"'etc/deutsch.shorth'\" uudecoded with wrong size!
    else
      rm etc/deutsch.s.U
    fi
  fi
  # end of 'etc/deutsch.s.U'
fi
if test -f 'etc/help.s.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.s.U'\"
else
  echo shar: Extracting \"'etc/help.s.U'\" \(7113 characters\)
  sed "s/^X//" >'etc/help.s.U' <<'END_OF_FILE'
Xbegin 644 etc/help.shorthelp
XM/R @(" @(" @(" @(" @(" @(" @(" @(" @0F5F96AL<X%B97)S:6-H=" H
XM;&5V96QA8FB$;F=I9RD*/R J(" @(" @(" @(" @(" @(" @(" @(" @0F5F
XM96AL<X%B97)S:6-H=" H86QL92!"969E:&QE*0I"969E:&P@/R @(" @(" @
XM(" @(" @(" @("!);F9O<FUA=&EO;F5N('IU(")"969E:&PB"@HP(" @(" @
XM(" @(" @(" @(" @(" @(" @("!);FAA;'0@9&5S($)E9F5H;'-P=69F97)S
XM"C$M.2 @(" @(" @(" @(" @(" @(" @(" @($)E9F5H;"!A=7,@9&5M(%!U
XM9F9E<B!A8G)U9F5N"@HK(" @(" @(" @(" @(" @(" @(" @(" @("!796-H
XM<V5L;B!I;G,@;H1C:'-T92!"<F5T="!M:70@;F5U96X@07)T:6ME;&X*"BT@
XM(" @(" @(" @(" @(" @(" @(" @(" @(%=E8VAS96QN(&EN<R!V;W)H97)I
XM9V4@0G)E='0@;6ET(&YE=65N($%R=&EK96QN"@I!3E)51D52(" @(" @(" @
XM(" @(" @(" @("!!;G)U9F5R<')O=&]K;VQL"D%.4E5&15(@*B @(" @(" @
XM(" @(" @(" @($%N<G5F97)P<F]T;VMO;&P@*&MO;7!L971T*0I!3E)51D52
XM(",@(" @(" @(" @(" @(" @("!3=&%T:7-T:6L@9&5R($%N<G5F90I!3E)5
XM1D52("4@(" @(" @(" @(" @(" @("!3=&%T:7-T:6L@9&5R($%N<G5F97(@
XM*$AI=&QI<W1E*0H*04Y304=%(" @(" @(" @(" @(" @(" @(" @36ET=&5I
XM;'5N9W-T97AT(&%N>F5I9V5N+X1N9&5R;@H*0E)%5%0@(" @(" @(" @(" @
XM(" @(" @(" @0G)E='1E<B!M:70@86MT=65L;&5N($%R=&EK96QN(&%N>F5I
XM9V5N"D)21514("H@(" @(" @(" @(" @(" @(" @($%L;&4@0G)E='1E<B!A
XM;GIE:6=E;B H;&5V96QA8FB$;F=I9RD*0E)%5%0@*BH@(" @(" @(" @(" @
XM(" @(" @04Q,12!"<F5T=&5R(&%N>F5I9V5N"D)21514("L@(" @(" @(" @
XM(" @(" @(" @(%=E8VAS96QN(&EN<R!NA&-H<W1E($)R971T"D)21514("T@
XM(" @(" @(" @(" @(" @(" @(%=E8VAS96QN(&EN<R!V;W)H97)I9V4@0G)E
XM='0*0E)%5%0@(2 @(" @(" @(" @(" @(" @(" @06MT=65L;&5N($)R971T
XM;F%M96X@875S9V5B96X*0E)%5%0@(R @(" @(" @(" @(" @(" @(" @1W)U
XM<'!E;B H07)E87,I(&%U<V=E8F5N"D)21514("XN(" @(" @(" @(" @(" @
XM(" @($EN;F5R:&%L8B!E:6YE<B!'<G5P<&4@:6YS('9O<FAE<FEG92!"<F5T
XM="!W96-H<V5L;@I"4D545"!"<F5T=&YA;64@(" @(" @(" @("!);G,@0G)E
XM='0@(D)R971T;F%M92(@=V5C:'-E;&X*"D)2245&(%5S97(@(" @(" @(" @
XM(" @(" @(%!E<G.4;FQI8VAE($YA8VAR:6-H="!A;B B57-E<B(@<V5N9&5N
XM"D)2245&($AO<W0A57-E<B @(" @(" @(" @(%!E<G.4;FQI8VAE($YA8VAR
XM:6-H="!A;B B57-E<B(@875F(")(;W-T(@H*0TA!5" @(" @(" @(" @(" @
XM(" @(" @(" @375L=&EP;W)T($-H871S>7-T96T*"D1)4TM54U-)3TX@*B @
XM(" @(" @(" @(" @($%N('=E;&-H96X@1&ES:W5S<VEO;F5N(&)I;B!I8V@@
XM8F5T96EL:6=T/PI$25-+55-324].(" @(" @(" @(" @(" @("!$96T@5&AE
XM;6$@96EN97(@1&ES:W5S<VEO;B!D=7)C:"!E:6YE($=R=7!P92!F;VQG96X*
XM"D1/5TY,3T%$(" @(" @(" @(" @(" @(" @($1I97-E($9U;FMT:6]N(&5R
XM;&%U8G0@97,L($%R=&EK96P@=6YD(%!R;V=R86UM90H@(" @(" @(" @(" @
XM(" @(" @(" @(" @("!U;G1E<B!0<F]T;VMO;&PM2V]N=')O;&QE;B!Z=2!E
XM;7!F86YG96X*"D5$250@07)T:6ME;" @(" @(" @(" @(" @($1E<B!!<G1I
XM:V5L(&UI="!D97(@3G5M;65R(")!<G1I:V5L(B!K86YN"B @(" @(" @(" @
XM(" @(" @(" @(" @(" @(&YA8VAT<H1G;&EC:"!E9&ET:65R="!W97)D96X*
XM"D5.1$4@(" @(" @(" @(" @(" @(" @(" @($UA:6QB;W@@=F5R;&%S<V5N
XM"D5.1$4@*B @(" @(" @(" @(" @(" @(" @($UA:6QB;W@@=F5R;&%S<V5N
XM("A38V%N;F5R(&YI8VAT(&%K='5A;&QI<VEE<F5N*0H*1U)54%!%("L@(" @
XM(" @(" @(" @(" @(" @6G5R(&YE>'1E;B!'<G5P<&4@96EN97(@56YT97)G
XM<G5P<&4*1U)54%!%("LK(" @(" @(" @(" @(" @(" @6G5R(&YE>'1E;B!'
XM<G5P<&4*1U)54%!%("T@(" @(" @(" @(" @(" @(" @6G5R('9O<FAE<FEG
XM96X@1W)U<'!E(&5I;F5R(%5N=&5R9W)U<'!E"D=255!012 M+2 @(" @(" @
XM(" @(" @(" @(%IU<B!V;W)H97)I9V5N($=R=7!P90H*2$E,1D4@(" @(" @
XM(" @(" @(" @(" @(" @1&EE<V4@2W5R>FAI;&9E(&%N>F5I9V5N"DA)3$9%
XM("H@(" @(" @(" @(" @(" @(" @($AI;&9S=&5X=&4@:V]M<&QE='0@875S
XM9V5B96X*2$E,1D4@0F5F96AL(" @(" @(" @(" @(" @2&EL9G-T97AT('IU
XM;2!"969E:&P@(D)E9F5H;"(@>F5I9V5N"@I)3DA!3%0@(" @(" @(" @(" @
XM(" @(" @("!);F1E>"!D97(@86MT=65L;&5N($%R=&EK96P@875S9V5B96X*
XM24Y(04Q4("H@(" @(" @(" @(" @(" @(" @06QL92!!<G1I:V5L(&5I;F5S
XM($)R971T97,@86YZ96EG96X*"DQ%4T5.(" @(" @(" @(" @(" @(" @(" @
XM($YE=64@07)T:6ME;"!L:7-T96X*3$5314X@*B @(" @(" @(" @(" @(" @
XM(" @06QL92!!<G1I:V5L(&QI<W1E;@I,15-%3B!!<G1I:V5L(" @(" @(" @
XM(" @("!!<G1I:V5L(&UI="!D97(@3G5M;65R(")!<G1I:V5L(B!A=7-G96)E
XM;@I,15-%3B!!<G1I:V5L+4%R=&EK96P@(" @("!!<G1I:V5L('9O;B!.=6UM
XM97(@(D%R=&EK96PB(&)I<R B07)T:6ME;"(@>F5I9V5N"@I,3T530TA%3B!!
XM<G1I:V5L(" @(" @(" @("!!<G1I:V5L($YU;6UE<B B07)T:6ME;"(@;)1S
XM8VAE;@I,3T530TA%3B!!<G1I:V5L+4%R=&EK96P@("!,E'-C:&5N('9O;B B
XM07)T:6ME;"(@8FES(")!<G1I:V5L(@I,3T530TA%3B ^(" @(" @(" @(" @
XM(" @("!!;&QE($MO<&EE;B H(2D@96EG96YE<B!-86EL<R!LE'-C:&5N"@I-
XM04M23R @(" @(" @(" @(" @(" @(" @("!-86MR;W9E<F5I;F)A<G5N9V5N
XM('IE:6=E;B^$;F1E<FX*"DU)3DE8(%-H96QL+4)E9F5H;" @(" @(" @($5X
XM=&5R;F5S($MO;6UA;F1O(")3:&5L;"U"969E:&PB(&%U<V:!:')E;@H*3U54
XM1$E!3" @(" @(" @(" @(" @(" @(" @5F5R8FEN9'5N9R!Z=2!E>'1E<FYE
XM;B!(;W-T<R!V:6$@1&%T97@M4 H*4$T@(" @(" @(" @(" @(" @(" @(" @
XM(" @26YS('!E<G.4;FQI8VAE(%9E<GIE:6-H;FES('=E8VAS96QN"@I03U)4
XM24Y&3R @(" @(" @(" @(" @(" @("!!:W1I=FETA'1E;B!D97(@=F5R<V-H
XM:65D96YE;B!497)M:6YA;',@>F5I9V5N"@I03U-41D%#2" @(" @(" @(" @
XM(" @(" @("!0;W-T9F%C:"!E:6YR:6-H=&5N"@I224-(5%5.1R @(" @(" @
XM(" @(" @(" @("!,97-E<FEC:'1U;F<@*&%L=" \+3X@;F5U*2"$;F1E<FX*
XM"E-#2%)%24)%3B @(" @(" @(" @(" @(" @($%R=&EK96P@97)F87-S96X@
XM=6YD('-P96EC:&5R;@H*4T5455 @(" @(" @(" @(" @(" @(" @(" @4&5R
XM<Y1N;&EC:&4@06YP87-S=6YG96X*"E-0245,12 @(" @(" @(" @(" @(" @
XM(" @(%9E<G-C:&EE9&5N92!3<&EE;&4@=V5R9&5N(&%U9F=E;&ES=&5T+V%U
XM9F=E<G5F96X*"E-405154R @(" @(" @(" @(" @(" @(" @($%U<V=A8F4@
XM9&5R(&5I9V5N96X@06YP87-S=6YG96X*"E-4051)4U1)2R @(" @(" @(" @
XM(" @(" @($1A=&5I+5-T871I<W1I:R!D97(@=F5R<V-H+B!"<F5T=&5R(&%N
XM>F5I9V5N"E-4051)4U1)2R J(" @(" @(" @(" @(" @(%-T871I<W1I:R!K
XM;VUP;&5T="!A=7-G96)E;@I35$%425-424L@)" @(" @(" @(" @(" @("":
XM8F5R<VEC:'0@9&5R(%550U M1V5B@6AR96X*4U1!5$E35$E+(",@(" @(" @
XM(" @(" @(" @4')O=&]K;VQL(&1E<B!$;W=N;&]A9',@*%!$+4)R971T97(I
XM"E-4051)4U1)2R E(" @(" @(" @(" @(" @(%!R;W1O:V]L;"!D97(@1&]W
XM;FQO861S("A(251,25-412D*4U1!5$E35$E+(#X@(" @(" @(" @(" @(" @
XM4')O=&]K;VQL(&1E<R!8340@*$UA:6QE<BD*"E-50TA%3B!-=7-T97(@(" @
XM(" @(" @(" @($%R=&EK96P@96EN97,@0G)E='1E<R!N86-H(")-=7-T97(B
XM(&1U<F-H<W5C:&5N"@I365-)3D9/(" @(" @(" @(" @(" @(" @("!!;&QG
XM96UE:6YE($EN9F]R;6%T:6]N96X@>G5R($UA:6QB;W@*"E5.5$524T-(4DE&
XM5" @(" @(" @(" @(" @(%5N=&5R<V-H<FEF="!A;GIE:6=E;B^$;F1E<FX*
XM"E503$]!1" @(" @(" @(" @(" @(" @(" @($1I97-E($9U;FMT:6]N('=I
XM<F0@=65B97(@9&5N($)E9F5H;"!30TA214E"14X*(" @(" @(" @(" @(" @
XM(" @(" @(" @(" @875T;VUA=&ES8V@@875F9V5R=69E;@H*55-%4B @(" @
XM(" @(" @(" @(" @(" @(" @57-E<FQI<W1E(&%U<V=E8F5N"E5315(@*B @
XM(" @(" @(" @(" @(" @(" @(%5S97)L:7-T92!M:70@97)W96ET97)E;B!)
XM;F9O<FUA=&EO;F5N"E5315(@(R @(" @(" @(" @(" @(" @(" @(%5S97)L
XM:7-T92!M:70@57 M+T1O=VYL;V%D(%9E<FB$;'1N:7,*55-%4B E(" @(" @
XM(" @(" @(" @(" @(" @57-E<FQI<W1E(&UI="!!;F=A8F4@9&5R($=R=7!P
XM96XO3F5W<V=R;W5P<PI54T52("0@(" @(" @(" @(" @(" @(" @("!5<V5R
XM;&ES=&4@>G5R($=E8H%H<F5N86)R96-H;G5N9PI54T52($YA;64@(" @(" @
XM(" @(" @(" @("!);F9O<FUA=&EO;F5N((%B97(@9&5N(%1E:6QN96AM97)N
XM(").86UE(@H*54U,0554(" @(" @(" @(" @(" @(" @(" @56UL875T+4MO
XM;G9E<G1I97)U;F<@96EN+2!U;F0@875S<V-H86QT96X*"E9%4E-)3TX@(" @
XM(" @(" @(" @(" @(" @(%9E<G-I;VYS;G5M;65R(&%U<V=E8F5N"E9%4E-)
XM3TX@*B @(" @(" @(" @(" @(" @(%9E<G-I;VYS;G5M;65R('5N9"!$969I
XM;FET:6]N96X@875S9V5B96X*5D524TE/3B C(" @(" @(" @(" @(" @(" @
XM5F5R<VEO;G-N=6UM97(@=6YD(")(86QL(&]F($9A;64B(&%U<V=E8F5N"@I7
XM14E415),14E414X@(" @(" @(" @(" @("!796ET97)L96ET8F%R92!037,@
XM86YZ96EG96X*5T5)5$523$5)5$5.(%5S97(@(" @(" @(" @5V5I=&5R;&5I
XM=&)A<F4@4$T@86X@(E5S97(B('-E;F1E;@I714E415),14E414X@07)T:6ME
XM;"!5<V5R("!!<G1I:V5L($YU;6UE<B B07)T:6ME;"(@86X@(E5S97(B('-E
X%;F1E;@IR
X 
Xend
END_OF_FILE
  if test 7113 -ne `wc -c <'etc/help.s.U'`; then
    echo shar: \"'etc/help.s.U'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'etc/help.shorthelp'\" \(5135 characters\)
    cat etc/help.s.U | uudecode
    if test 5135 -ne `wc -c <'etc/help.shorthelp'`; then
      echo shar: \"'etc/help.shorthelp'\" uudecoded with wrong size!
    else
      rm etc/help.s.U
    fi
  fi
  # end of 'etc/help.s.U'
fi
if test -f 'src/control.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/control.c'\"
else
  echo shar: Extracting \"'src/control.c'\" \(2626 characters\)
  sed "s/^X//" >'src/control.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  control.c						   */
X/*        FUNKTIONEN  control(), whodo()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  24.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X
X/***************************************************************************/
X/*      FUNKTION  control()						   */
X/*  BESCHREIBUNG  Fuehrt ein "Logbuch" in zwei versch. Dateien/auf zwei    */
X/*		  versch. Geraeten (CONSOLE & CPRN).                       */
X/*     PARAMETER  text  =  Ansage-Text                                     */
X/*		  mode  =  '< 99'  =  Ausgabe auf CONSOLE                  */
X/*		  mode  =  '= 99'  =  Ausgabe auf CPRN                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
XFILE *contfp = NULL;
X
Xvoid control(text, mode)
Xunsigned char text[];
Xint mode;
X{
X  if (mode < 99) {
X
X#ifdef _MINIX
X	if(tty() >= FIRST_EX_TTY){
X#endif
X		contfp = fopen(CONSOLE_REDIRECT, "a");
X		if (contfp == NULL) {
X			printf("\n\n%s [%s]\n\n", CTL01_MSG, CONSOLE_REDIRECT);
X			exit(-1);
X		}
X#ifdef _DATESTAMP
X		fprintf(contfp, "%s %s <%s>  %s\n", mydate(1), mytime(1), ttyna(), text);
X#else
X		fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X#endif
X		fflush(contfp);
X		fclose(contfp);
X#ifdef _MINIX
X	}
X#endif
X
X  }
X  if (mode == 99) {
X	contfp = fopen(CPRN, "a");
X	if (contfp == NULL) {
X		printf("\n\n%s [%s]\n\n", CTL01_MSG, CPRN);
X		exit(-1);
X	}
X	fprintf(contfp, "\n%s  -  %s\n", mydate(1), mytime(1));
X	fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X	fflush(contfp);
X	fclose(contfp);
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  whodo()						   */
X/*  BESCHREIBUNG  Erstellt eine Datei fuer die "portinfo()"-Routine.       */
X/*     PARAMETER  text = Ansage-Text (aktiver Befehl etc.)                 */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid whodo(text)
Xunsigned char text[];
X{
X  FILE *fp;
X  unsigned char s[STRING];
X
X  s[0] = '\0'; strcat(s, HOME); strcat(s, "/etc/");
X  strcat(s, (unsigned char *) ttyna()); strcat(s, ".");
X
X  fp = fopen(s, "w");
X  if (fp == NULL) {
X	nerror("control.c", 44, "whodo", "Datei-Schreibfehler", s);
X  }
X  fputs(text, fp);
X  fclose(fp);
X}
END_OF_FILE
  if test 2626 -ne `wc -c <'src/control.c'`; then
    echo shar: \"'src/control.c'\" unpacked with wrong size!
  fi
  # end of 'src/control.c'
fi
if test -f 'src/getline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getline.c'\"
else
  echo shar: Extracting \"'src/getline.c'\" \(8445 characters\)
  sed "s/^X//" >'src/getline.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  getline.c						   */
X/*        FUNKTIONEN  getline(), getint(), yesno()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  17.11.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#ifdef _MBOX
X#include "mbox.h"
X#else
X#define BS		8
X#define CR		13
X#define LF		10
X#define CTRL_X		24
X#define CTRL_D		4
X#define BELL		7
X#define ESC		27
X#define DEL		127
X#define GBL06_MSG	'J' 	
X#define GBL07_MSG	'N'	
X
Xint UMLAUT = 0;
X
X#ifdef _SYS7
X#define ENTER		13
X#else
X#define ENTER	 	10
X#endif
X#endif
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X/***************************************************************************/
X/*      FUNKTION  getline()						   */
X/*  BESCHREIBUNG  Eine Zeile (STRING) einlesen. Beendet wird mit ENTER,	   */
X/*		  oder wenn die max. zulaessige Anzahl von Zeichen er-     */
X/*		  reicht ist.	                                           */
X/*     PARAMETER  siehe unten                                              */
X/*     RUECKGABE  Eingelesene Zeile (STRING)				   */
X/*  ---------------------------------------------------------------------  */
X/*  len     -> Anzahl der max. einzulesenden Zeichen     		   */
X/*									   */
X/*  mode    ->      >0 = 7BIT						   */
X/*		     0 = Kein Echo					   */
X/*	   	     1 = Mit Echo				           */
X/*       	     2 = '*' als Echo				           */
X/*		     3 = ':' als drittes & sechstes Zeichen (Uhrzeit)      */
X/*	             4 = '.' als drittes & sechstes Zeichen (Datum)        */
X/*	 	     5 = Ausschliesslich BUCHSTABEN			   */
X/*		    10 = "bsc" vor der Eingabe "len"-mal ausgeben          */
X/*		   100 = nur Zahlen (und '.', ':')                         */
X/*	 	  1000 = String "deftext" + "bsc" ausgeben                 */
X/*		 10000 = bei "0-9" als erstes Zeichen -> sofort zurueck    */
X/*								           */
X/*  bsc     -> Mit diesem Zeichen wird geloescht			   */
X/*								           */
X/*  deftext -> Text-Vorgabe                                                */
X/*			                                                   */
X/***************************************************************************/
X
Xstatic int endless;
X
Xunsigned char *getline(len, mode, bsc, deftext)
Xint len, mode;
Xint bsc;
Xunsigned char deftext[];
X{
X  static unsigned char gls[STRING];
X  int c;
X  int gli, gll;
X  int delim = '\0';
X  int matrix = 0;
X  int echo = 1, numerics = 0, defmode = 0, letters = 0;
X  int escape = 0;
X  int lenmem = len;
X  int lastwasblank = 0;
X  int siebenbit = 0;
X  
X  if (mode < 0) {
X	siebenbit++;
X	mode *= -1;
X  }
X  if (mode > 10000) {
X	escape++;
X	mode -= 10000;
X  }
X  if (mode > 1000) {
X	mode -= 1000;
X	defmode++;
X  }
X  if (mode > 100) {
X	mode -= 100;
X	numerics++;
X  }
X  if (mode > 10) {
X	mode -= 10;
X	matrix++;
X  }
X  if (mode > 2) {
X	switch(mode){
X		case 3	: delim = ':';
X			  break;
X		case 4  : delim = '.';		
X			  break;
X	 	case 5  : letters++;
X			  break;
X	}
X	mode = 1;
X  }
X  echo = mode;
X
X  if (defmode != 0) {
X	if((deftext[0] < 32) || (deftext[0] > 126)) deftext[0] = '\0';
X	gll = length(deftext);
X	lenmem = len - gll;
X	if(deftext[0] != '\0'){
X		sprintf(gls, "%s", deftext);
X		printf("%s", deftext);
X	}
X	else gls[0] = '\0';
X  }
X  else {
X	gll = 0;
X	strcpy(gls, (unsigned char *) "OOPS");
X  }
X
X  if (matrix != 0) {
X	for (gli = 0; gli < lenmem; gli++) {
X		if (((gli == 2) || (gli == 5)) && (delim != '\0') && (gli != len)) {
X			printf("%c", delim);
X		}
X		else {
X			printf("%c", bsc);
X		}
X	}
X	for (gli = 0; gli < lenmem; gli++) printf("%c", BS);
X  }
X
X  do {
X
X	if (delim != '\0') {
X		if (((gll == 2) || (gll == 5)) && (gll < len)){
X			c = delim;
X		}
X		else {
X			c = getint();  
X		}
X	}
X	else {
X		c = getint();  
X	}        
X
X	if(siebenbit != 0){
X		if(c > 127) c = 0;
X	}
X
X	if (c == ESC) {
X		c = getint();  
X		c = getint();  
X		if ((c == 'A') || (c == 'B')) {
X			if (c == 'A') endless++;
X			if (c == 'B') endless--;
X			if (endless < 1) endless = 9;
X			if (endless > 9) endless = 1;
X			sprintf(gls, "%d", endless);
X			return (unsigned char *) gls;
X		}
X		if (c == 'D') c = BS;
X		if (c == 'C') c = ENTER;
X	}
X	if ((c == CTRL_X) || (c == CTRL_D) || (c == DEL)) {
X		return("<BREAK>");
X	}
X	if (c != ENTER) {
X		if ((c == BS) && (gll > 0)) {
X			if (((gll == 3) || (gll == 6)) && (delim != '\0')) {
X				gll -= 2;
X				printf("%c%c%c%c", BS, BS, bsc, BS);
X			} else {
X				gll--;
X				printf("%c%c%c", BS, bsc, BS);
X			}
X		}
X		if (numerics == 0) {
X			if (c >= 32) {
X				if(letters != 0){
X					if((c < 'A') && (c != ' ')) c = 0;
X					if(c > 'z') c = 0;
X					if((c > 'Z') && (c < 'a')) c = 0;
X
X					if(c == ' '){
X						if(lastwasblank != 0) c = 0;
X						lastwasblank++;
X					}
X					else{
X						if(c != 0) lastwasblank = 0;
X					}				
X
X					/*
X					if((c == 0) && (USER.bell == 1))
X						printf("%c", BELL);
X					*/
X					if(c == 0)
X						printf("%c", BELL);
X				}
X				if(c != 0){
X					gls[gll] = c;
X					gll++;
X				}
X			}
X			else {
X				c = 0;
X			}
X		}
X		else {
X			if ((c == '.') || (c == ':') || ((c >= '0') && (c <= '9'))) {
X				if (((delim != '\0') && ((c == '.') || (c == ':'))) &&
X				    ((gll != 2) && (gll != 5))) {
X					printf("%c", BELL);
X					c = 0;
X				}
X				else {
X					gls[gll] = c;
X					gll++;
X					gls[gll] = '\0';
X				}
X			}
X			else {
X				if (c != BS) printf("%c", BELL);
X				c = 0;
X			}
X		}
X		if (c != 0) {
X			if (echo == 1) printf("%c", c);
X			if (echo == 2) printf("*");
X		}
X	}
X	if (gll == 1) {
X		if ((escape != 0) && ((c > 47) && (c < 58))) {
X			gls[gll] = '\0';
X			return (unsigned char *) gls;
X		}
X	}
X
X  } while ((c != ENTER) && (gll < len));
X
X  gls[gll] = '\0';
X
X  return (unsigned char *) gls;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  getint() 						   */
X/*  BESCHREIBUNG  Ein Zeichen wird mit Hilfe der "getch"-Funktion einge-   */
X/*		  lesen. Es wird gewartet bis ein Zeichen erfasst ist.     */
X/*     PARAMETER  keine                                                    */
X/*     RUECKGABE  Eingelesenes Zeichen (INT)				   */
X/***************************************************************************/
X
X
Xint getint()
X{
X  int c;
X
X
X  if(UMLAUT != 0){
X	c = UMLAUT;
X	UMLAUT = 0;
X	return (int) c;
X  }
X
X  do{
X	c = (int) getch();
X
X#ifndef _UMLAUT
X
X	if(c > 127){
X
X		UMLAUT = 'e';
X
X		switch(c){
X			case 142 : c = 'A'; /* IBM 'Ae' */
X				   break;
X			case 153 : c = 'O'; /* IBM 'Oe' */
X				   break;
X			case 154 : c = 'U'; /* IBM 'Ue' */
X				   break;
X			case 132 : c = 'a'; /* IBM 'ae' */
X				   break;
X			case 148 : c = 'o'; /* IBM 'oe' */
X				   break;
X			case 129 : c = 'u'; /* IBM 'ue' */
X				   break;
X			case 225 : c = 's'; /* IBM 'ss' */
X				   UMLAUT = 's';
X				   break;
X
X			case 196 : c = 'A'; /* AMIGA 'Ae' */
X				   break;
X			case 214 : c = 'O'; /* AMIGA 'Oe' */
X				   break;
X			case 220 : c = 'U'; /* AMIGA 'Ue' */
X				   break;
X			case 228 : c = 'a'; /* AMIGA 'ae' */
X				   break;
X			case 246 : c = 'o'; /* AMIGA 'oe' */
X				   break;
X			case 252 : c = 'u'; /* AMIGA 'ue' */
X				   break;
X			case 223 : c = 's'; /* AMIGA 'ss' */
X				   UMLAUT = 's';
X				   break;
X
X#ifdef I_LIKE_CONFUSIONS
X		        case 128 : c = 'A'; /* APPLE 'Ae' */
X				   break;
X			case 133 : c = 'O'; /* APPLE 'Oe' */
X				   break;
X			case 134 : c = 'U'; /* APPLE 'Ue' */
X				   break;
X			case 138 : c = 'a'; /* APPLE 'ae' */
X				   break;
X			case 154 : c = 'o'; /* APPLE 'oe' */
X				   break;
X			case 159 : c = 'u'; /* APPLE 'ue' */
X				   break;
X			case 167 : c = 's'; /* APPLE 'ss' */
X				   UMLAUT = 's';
X				   break;
X#endif /* _CONFUSION */
X			default  : UMLAUT = 0;
X		}		
X        }
X
X  }while((c == 0) || (c > 127));
X
X#else /* _UMLAUT */
X
X  }while(c == 0);
X
X#endif /* _UMLAUT */
X
X
X  return (int) c;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  yesno()						   */
X/*  BESCHREIBUNG  Die Zeichen "j", "J", "n" oder "N" werden ausschliess-   */
X/*		  lich eingelesen und zurueckgegeben.	                   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  Eines der Zeichen (siehe oben) (INT)			   */
X/***************************************************************************/
X
Xint yesno()
X{
X  int c;
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if ((c != GBL06_MSG) && (c != GBL07_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  return (int) c;
X}
X
X
END_OF_FILE
  if test 8445 -ne `wc -c <'src/getline.c'`; then
    echo shar: \"'src/getline.c'\" unpacked with wrong size!
  fi
  # end of 'src/getline.c'
fi
if test -f 'src/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/main.c'\"
else
  echo shar: Extracting \"'src/main.c'\" \(7181 characters\)
  sed "s/^X//" >'src/main.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  main.c						   */
X/*        FUNKTIONEN  logout(), init(), fixoutput(), main()		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  13.06.1992					   */
X/***************************************************************************/
X   
X#include <sys/types.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <time.h>
X#include <fcntl.h>
X
X#include "mbox.h"
X
Xextern time_t time_start, time_now;
X
X
X
X/***************************************************************************/
X/*      FUNKTION  logout()						   */
X/*  BESCHREIBUNG  Entfernt den User aus "WHO" und reorganisiert seine      */
X/*		  Teilnehmerdaten.                                         */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid logout()
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char u[STRING];
X  unsigned char f[STRING];
X  long ll;
X  int a, b;
X  int fd;
X  struct tm *timeptr;
X  struct userdaten DUMMY;
X  int dummy = sizeof(DUMMY);
X
X  printf("\n");
X
X
X  time(&time_now);
X  USER.elapsed += (long) (time_now - time_start);
X
X  sprintf(f, "%s/who%d", TMP, getpid());
X  maybe_locked(WHO, "r"); mblock(WHO);
X  fp = fopen(WHO, "r");
X  if (fp == NULL) {
X	nerror("main.c", 34, "logout", "Datei-Lesefehler", WHO);
X  }
X 
X  strcpy(t, (unsigned char *) ttyna()); t[9] = '\0';
X
X  ff = fopen(f, "w");
X  if (ff == NULL) {
X	nerror("main.c", 38, "logout", "Datei-Schreibfehler", f);
X  }
X  while (fgets(s, 80, fp) != NULL) {
X	if(strcomp(t, s) != 0) fputs(s, ff);
X  }
X  fclose(ff);
X  fclose(fp);
X  sprintf(s, "cp %s %s", f, WHO);
X  system(s);
X  unlink(f);
X  mbunlock(WHO);
X
X  strcpy(s, HOME); strcat(s, "/etc/");
X  strcat(s, (unsigned char *) ttyna()); strcat(s, ".");
X  unlink( s );
X
X  sprintf(USER.abused, "%ld", IDX_SIZE);
X
X  USER.seq--;		
X  printf("\n");
X  init_user( MAI01_MSG );
X
X#ifdef _NOINDEX
X  sprintf(s, "%s/inhalt.%d", TMP, getpid());
X  unlink(s);
X#endif
X
X  control(MAI02_MSG, 3);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  init()						   */
X/*  BESCHREIBUNG  Liest die Befehle aus "BEFEHLE", fuellt die Befehl-      */
X/*		  Stuktur und verteilt die Level-Vorgaben.                 */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid init()
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char udcc[STRING];
X  int udcl;
X  unsigned char udcp[STRING];
X  int b = 0;
X  int ok = 0;
X
X  ff = fopen(UDCS, "r");
X  if (ff == NULL) {
X	nerror("main.c", 115, "init", "Datei-Lesefehler", "./etc/mbox.udc");
X	exit(0);
X  }  
X  while((fgets(s, 80, ff) != NULL) && (s[0] == '/'));
X  if(fgets(s, 80, ff) != NULL) ok = 1;
X  sscanf(s, "%s %d %s %s", udcc, &udcl, udcp, t);
X  if(udcc[0] > 96) udcc[0] -= 32;
X  strcat(udcp, " "); strcat(udcp, t);
X
X  fp = fopen(BEFEHLE, "r");
X  if (fp == NULL) {
X	nerror("main.c", 68, "init", "Datei-Lesefehler", BEFEHLE);
X  }
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  
X  fgets(s, 80, fp); /* 3 Zeilen nach dem Kommentar (exakt 3 Zeilen !!!) */
X  fgets(s, 80, fp);
X
X  while (fscanf(fp, "%d %d %d %d %s", &BEF[b].id, &BEF[b].in, &BEF[b].ex, &BEF[b].prototyp, BEF[b].befehl) > 0) {
X
X	if (BEF[b].id == 160) MAILOUT_LEV = BEF[b].ex;
X	if (BEF[b].id == 125) ADMIN_LEV = BEF[b].ex;
X	if (BEF[b].id == 230) WRITE_EX_LEV = BEF[b].ex;
X	if (BEF[b].id == 230) WRITE_IN_LEV = BEF[b].in;
X	if (BEF[b].id == 998) WRITE_INTERNAT = BEF[b].in;
X	if (BEF[b].id == 195) PD_D_LEV = BEF[b].in;
X	if (BEF[b].id == 195) PD_U_LEV = BEF[b].ex;
X	if (BEF[b].id == 240) EXE_LEV = BEF[b].ex;
X	if (BEF[b].id == 320) GUEST_LEV = BEF[b].in;
X	if (BEF[b].id == 130) BB1 = b;
X	if (BEF[b].id == 150) BB2 = b;
X	if (BEF[b].id == 160) BB3 = b;
X	if (BEF[b].id == 170) BB4 = b;
X	if (BEF[b].id == 210) BB5 = b;
X	if (BEF[b].id == 180) BB6 = b;
X	if (BEF[b].id == 190) BB7 = b;
X	if (BEF[b].id == 200) BB8 = b;
X	if (BEF[b].id == 270) BB9 = b;
X
X	if((ok == 1) && (BEF[b].prototyp == 1) && (udcc[0] < BEF[b].befehl[0])){
X		BEF[(b+1)].id = BEF[b].id;
X		BEF[(b+1)].in = BEF[b].in;
X		BEF[(b+1)].ex = BEF[b].ex;
X		BEF[(b+1)].prototyp = BEF[b].prototyp;
X		strcpy(BEF[(b+1)].befehl, (unsigned char *) BEF[b].befehl);
X		BEF[b].id = 1000;
X		BEF[b].in = udcl;
X		BEF[b].ex = udcl;
X		BEF[b].prototyp = 1;
X		strcpy(BEF[b].befehl, (unsigned char *) udcc);
X		strcpy(BEF[b].pfad, (unsigned char *) udcp);
X		b++;
X		if(fgets(s, 80, ff) == NULL) ok = 0;
X		sscanf(s, "%s %d %s %s", udcc, &udcl, udcp, t);
X		if(udcc[0] > 96) udcc[0] -= 32;
X		strcat(udcp, " "); strcat(udcp, t);
X	}
X
X	b++;
X	if (b >= MAX_BEF) {
X		nerror("main.c", 85, "init", "MAX_BEF ueberschritten !!", "???");
X	}
X  }
X  BEF[b].id = -1;
X
X  fclose(fp);
X  fclose(ff);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  fixoutput()						   */
X/*  BESCHREIBUNG  Legt fest an welches Geraet, oder in welche Datei, die   */
X/*		  Logbuch-Eintraege geschickt werden.			   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid fixoutput()
X{
X  unsigned char s[STRING];
X
X  FILE *fp;
X
X  strcpy(s, CONSOLE); CONSOLE_REDIRECT[0] = '\0';
X
X  if(strcomp("REDIRECT", CONSOLE) == 0){
X	fp = fopen( CDIRECTFL, "r" );
X	if(fp != NULL){
X		fgets(s, STRING, fp);
X		fclose(fp);
X		
X	}
X   }
X   strcat(CONSOLE_REDIRECT, (unsigned char *) stripped(s));
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  main()						   */
X/*  BESCHREIBUNG  Hauptfunktion. Rettet UID/GID, initialisiert, startet    */
X/*		  die MBox-Funktionen und terminiert.                      */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  "Exit-Status"						   */
X/***************************************************************************/
X
Xint main(argc, argv)
Xint argc;
Xunsigned char *argv[];
X{
X  FILE *fp;
X  int i;
X
X#if defined(_ESTDIO) || !defined(_SYS7)
X  setbuf(stdout, NULL);
X#endif
X
X
X  chdir(HOME);
X
X  OLDUID = getuid();
X  OLDGID = getgid();
X
X  sprintf(MYNAME, "%s", "J. Random Looser");
X
X  fp = fopen( UDBASE, "r" );
X  if(fp == NULL){
X	strcpy(TERMINAL, "ansi");
X	ansi("INIT");
X
X	headline( MAI03_MSG );
X	ansi("md");
X	printf("\n%s", MAI04_MSG);
X	printf("\n%s", MAI05_MSG);
X	printf("\n%s", MAI06_MSG);
X	printf("\n");
X	printf("\n%s", MAI07_MSG);
X	printf("\n%s", MAI08_MSG);
X	printf("\n%s\n\n", MAI09_MSG);
X	ansi("me");
X
X	postfach( "#1" );
X	postfach( "#2" );
X
X	ansi("md");
X	printf("\n%s\n\n", MAI10_MSG);
X	ansi("me");
X	return 0;
X  }
X  fclose(fp);
X
X  fixoutput();
X  init();  
X  intro();
X  get_makros();
X  ctrlx();
X
X  loop();
X
X  logout();
X  noctrlx();
X  ansi("md");
X  printf("\n\n%s\n\n", MAI11_MSG);
X  ansi("me");
X
X  return 0;
X}
END_OF_FILE
  if test 7181 -ne `wc -c <'src/main.c'`; then
    echo shar: \"'src/main.c'\" unpacked with wrong size!
  fi
  # end of 'src/main.c'
fi
if test -f 'wendy/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/misc.c'\"
else
  echo shar: Extracting \"'wendy/misc.c'\" \(8395 characters\)
  sed "s/^X//" >'wendy/misc.c' <<'END_OF_FILE'
X#include "wendy.h"
X
X
Xunsigned char *right_stripped();
X
X
X
X/*	Eingabe zeilenweise in Blocksatz umformen 	*/
X
Xblockset()
X{
X  FILE *fp;
X
X  unsigned char s[STRING];
X  unsigned char a[STRING];
X  unsigned char q[LONGSTRING];
X
X  int i, j = 0, l;
X  int WIDE = MAXX;
X  int whitespace = 1;
X
X  
X  strcpy(s, (unsigned char *) SCREEN[y]); l = strlen((unsigned char *) right_stripped(s));
X
X  if(l < ((WIDE / 10) * 8)) return;
X
X  while(l < WIDE){
X	i = 0; whitespace = 1;
X
X	while((l < WIDE) && (i < WIDE)){
X		if(SCREEN[y][i] != BLANK) whitespace = 0;
X		if(whitespace == 1){
X			i++;
X			continue;
X		}
X		strcpy(s, (unsigned char *) SCREEN[y]);
X		strcpy(a, (unsigned char *) ATTRIB[y]);
X
X		if(isin(".!?,;:", SCREEN[y][i]) != 0){
X			if((WIDE - l - 3) > 0){
X				i++;
X				SCREEN[y][i] = '\0';
X				strcat(SCREEN[y], (unsigned char *) "   ");
X				strcat(SCREEN[y], (unsigned char *) strcopy(s, i, l));
X				ATTRIB[y][i]   = ATTRIB[y][i-1];
X				ATTRIB[y][i+1] = ATTRIB[y][i-1];
X				ATTRIB[y][i+2] = ATTRIB[y][i-1];
X				ATTRIB[y][i+3] = '\0';
X				strcat(ATTRIB[y], (unsigned char *) strcopy(a, i, l));				
X				i += 2;
X			}
X		}
X		if(SCREEN[y][i] == BLANK){
X			i++;
X			SCREEN[y][i] = '\0';
X			strcat(SCREEN[y], (unsigned char *) " ");
X			strcat(SCREEN[y], (unsigned char *) strcopy(s, i, l));
X			ATTRIB[y][i] = ATTRIB[y][i-1];
X			ATTRIB[y][i+1] = '\0';
X			strcat(ATTRIB[y], (unsigned char *) strcopy(a, i, l));				
X		}
X		i++;
X		strcpy(q, (unsigned char *) SCREEN[y]);
X		l = strlen((unsigned char *) right_stripped(q));
X	}
X  }
X}
X
X
X
X/*	Datei einfuegen		*/  
X
Xinsert_file( t )
Xunsigned char t[];
X{
X  unsigned char s[STRING];
X  unsigned char path[STRING];
X  unsigned char tmp[STRING];
X  int i = 0, ynow;
X
X  FILE *fp, *ff;  
X
X  while((t[i] != ' ') && (t[i] != '\0')) i++;
X  strcpy(path, (unsigned char *) strcopy(t, (i+1), strlen(t)));
X
X  fp = fopen( path, "r" );
X  if(fp == 0){
X#ifdef _LOCAL
X	sprintf(t, "Datei <%s> nicht gefunden.", path);
X#else
X	sprintf(t, "File <%s> not found.", path);
X#endif
X        return;
X  }
X
X  sprintf(tmp, "/tmp/wendy.%d", getpid());
X
X  ynow = ypos + y;
X
X  restore_screen( ypos );
X
X  ff = fopen( tmp, "w" );
X  for(i = ynow; i <= lastline; i++){
X	fprintf(ff, "%s\n", TEXT[i]);
X  }
X  fclose(ff);
X
X  lastline = ynow;
X
X  while(fgets(TEXT[lastline], LINELENGTH, fp) != 0) lastline++;
X  fclose(fp);   
X
X  fp = fopen( tmp, "r" );
X  while(fgets(TEXT[lastline], LINELENGTH, fp) != 0) lastline++;
X  fclose(fp);
X
X  unlink( tmp );
X 
X  prep_screen( ypos );
X  show_screen( START );
X}
X
X
X
X/*	ASCII-Schrott (incl. BLANK ;-) auf der rechten Seite abschneiden	*/
X
Xunsigned char *right_stripped( s )
Xunsigned char s[];
X{
X  int i;
X  
X  i = strlen( (unsigned char *) s);
X
X  while(((s[i] < 33) || (s[i] == BLANK)) && (i > -1)) i--;
X  i++;
X  s[i] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X/*	Hilfe!		*/
X
Xhelp()
X{
X  FILE *fp;
X  unsigned char s[STRING];
X  int c, i;
X
X  restore_screen( ypos );
X
X  ansi( "cl" );
X  c = MAXY;
X  MAXY = 0;
X  show_status( VERSION ); /* !! */
X  MAXY = c;
X
X  i = START;
X
X  fp = fopen( HILFE, "r" );
X  if(fp == NULL){
X#ifdef _LOCAL
X	printf("\n\nDatei <%s> nicht gefunden!\n\n", HILFE);
X#else
X	printf("\n\nDatei <%s> not found!\n\n", HILFE);
X#endif
X  }
X  else{
X	while(fgets(s, STRING, fp) != 0){
X		ansi2( "cm", 1, i );
X		printf("%s\n", right_stripped(s));	
X		i++;
X	}
X	fclose(fp);
X  }
X
X  c = getch();
X
X  ansi( "cl" );
X
X  show_status( version );
X  prep_screen( ypos );
X  show_screen( START );
X}
X
X
X
X
X
X/*	Zeichen einfuegen	*/
X
Xinsert( c )
Xunsigned char c;
X{
X  unsigned char s[STRING];
X  unsigned char q[LONGSTRING];
X
X  strcpy(q, (unsigned char *) SCREEN[y]);
X
X  if(strlen((unsigned char *) right_stripped(q)) >= MAXX){
X	printf("%c", 7);
X	if(x >= MAXX) x = MAXX;
X	ansi2( "cm", x, y );
X	return;
X  }
X
X  if(c == ' ') c = BLANK;
X
X  strcpy(s, (unsigned char *) SCREEN[y]);
X  s[x] = '\0'; 
X  s[(x-1)] = c; 
X  strcpy(q, (unsigned char *) SCREEN[y]);
X  strcat(s, (unsigned char *) right_stripped(strcopy(q, (x-1), strlen(q))));
X  strcat(s, " ");
X  s[MAXX] = '\0';	
X  strcpy(SCREEN[y], (unsigned char *) s);
X
X  strcpy(s, (unsigned char *) ATTRIB[y]);
X  s[x] = '\0';
X  s[(x-1)] = RTF_attrib;
X  strcpy(q, (unsigned char *) ATTRIB[y]);
X  strcat(s, (unsigned char *) right_stripped(strcopy(q, (x-1), strlen(q))));
X  strcat(s, "0");
X  s[MAXX] = '\0';	
X  strcpy(ATTRIB[y], (unsigned char *) s);
X
X  if(ansi( "ic") != 0){
X	show_line( SCREEN[y], ATTRIB[y], x );
X  }
X  else{
X	if(c == BLANK)
X		printf(" ");
X	else
X		printf("%c", c);		
X  }
X  x++;
X  ansi2( "cm", x, y );
X}
X
X
X
X/*	ENTER	*/
X
Xenter()
X{
X  int i, j;
X  int memo;
X  int ymem = y;
X  
X  	
X  if(FORMATTER == 'b'){
X	blockset();
X	ansi( "me" );
X	show_line( SCREEN[y], ATTRIB[y], 1 );  
X	activate( RTF_attrib );
X  }
X 
X  if(INS_mode != 0){
X	memo = SCREEN[y][x]; 
X	SCREEN[y][x] = (126);
X	restore_screen( ypos );
X	j = ypos + y - 2;
X        for(i = lastline; i > j; i--){
X		strcpy(TEXT[i+1], (unsigned char *) TEXT[i]);
X		FLAG[i+1] = FLAG[i];
X	} 
X	lastline++;
X
X	i = 0; j++;
X	while((TEXT[j][i] != (126)) && (TEXT[j][i] != '\0')) i++;
X	TEXT[j][i] = memo;
X
X	strcpy(TEXT[(j+1)], (unsigned char *) strcopy(TEXT[j], (i-1), strlen(TEXT[j])));
X	TEXT[j][(i-1)] = '\0'; strcat(TEXT[j], (unsigned char *) "<nl>\n");
X
X	prep_screen( ypos );
X	ansi2( "cm", 1, MAXY );
X	ansi( "ce" );
X	ansi2( "cm", x, y );
X
X	if(ansi( "al" ) != 0){
X		show_screen( (y-1) );	
X	}
X	else{
X		show_line( SCREEN[y], ATTRIB[y], 1);
X		y++;
X		show_line( SCREEN[y], ATTRIB[y], 1);
X		y--;
X	}
X  }
X  if(y < MAXY){
X	lastline++;
X	ansi( "do" );
X	y++; 
X  }
X  else{
X	ctrlj();
X  }
X  x = 1;
X  ansi2( "cm", x, y );
X}
X
X
X
X/*	VI Kommando-Modus (SUBSET!)	*/
X
Xint vi( f )
Xunsigned char f[];
X{
X  unsigned char s[STRING];
X  int mode = 0;
X  int newp = 0;
X
X  show_status( ":" );
X  ansi( "mr" );
X  strcpy(s, (unsigned char *) getline( 70, 1, 32, "" ));
X
X
X  newp = atoi(s);
X  if(newp > 0){
X	restore_screen( ypos );	
X
X	if(newp > (lastline - MAXY))
X		ypos = (lastline - MAXY);
X	else
X		ypos = newp;
X
X	y = START;
X
X	prep_screen( ypos );
X	show_screen( START );	 
X  }
X
X  if((strcomp(s, "w")    == 0) || (strcomp(s, "w!") == 0)) ctrlw( f );
X  if(strcomp("set ", s)  == 0) ctrls();
X  if((strcomp(s, "q")    == 0) || (strcomp(s, "q!") == 0)){
X	ctrlx( f );
X	mode = CTRL_X;
X  }
X  if(strcomp(s, "i")    == 0) ctrlv();
X  if(strcomp("r ", s)	== 0) insert_file( s );
X
X  activate( RTF_attrib );
X  ansi2( "cm", x, y );
X
X  return mode;
X}
X
X
X
X/*	PGUP	*/
X
Xpgup()
X{
X  int oldypos = ypos;
X  
X
X  if((ypos - (MAXY -1)) > 1) 
X	ypos -= (MAXY -1);
X  else
X	ypos = 1;
X
X  if(ypos == oldypos) return;
X
X  restore_screen( oldypos );
X  prep_screen( ypos );
X  show_screen( START );
X}
X
X
X
X/*	PGDN	*/
X
Xpgdn()
X{
X  int oldypos = ypos;
X
X  if((ypos + (MAXY -1)) < (lastline - (MAXY -1))) 
X	ypos += (MAXY -1);
X  else
X	ypos = lastline - MAXY;
X  if(ypos < 1) ypos = 1;
X
X  if(ypos == oldypos) return;
X
X  restore_screen( oldypos );
X  prep_screen( ypos );
X  show_screen( START );
X}
X
X
X
X
X/*	Eingabe direkt zentriert ausgeben 	*/
X
Xcenter()
X{
X  int i, j = strlen((unsigned char *) stripped(SCREEN[y]));
X
X  unsigned char s[LONGSTRING];
X  unsigned char t[STRING];
X 
X
X  i = (MAXX - j) / 2;
X 
X  strcpy(s, (unsigned char *) "                                                    ");
X  s[i] = '\0'; strcat(s, (unsigned char *) stripped(SCREEN[y]));
X  strcat(s, (unsigned char *) "                                                    ");
X  s[MAXX] = '\0';
X  strcpy(SCREEN[y], (unsigned char *) s);
X 
X  strcpy(ATTRIB[y], (unsigned char *) "00000000000000000000000000000000000000000000000000000000000000000000000000000000");
X 
X  show_line( SCREEN[y], ATTRIB[y], 1 );
X  strcpy(s, (unsigned char *) SCREEN[y]);
X  x = strlen( (unsigned char *) right_stripped(s)) + 1;
X  FLAG[(ypos + y - 1)] |= is_centered;
X  ansi2( "cm", x, y );
X}
X 
X
X
X/*	Cursor zum Zeilenende 	*/
X
Xlines_end()
X{
X  unsigned char s[STRING];
X
X  strcpy(s, (unsigned char *) SCREEN[y]);
X  x = strlen((unsigned char *) right_stripped(s)) + 1;
X  if(x > MAXX) x = MAXX;
X  ansi2( "cm", x, y );
X}
X
X
X
X/*	Wordwrap: Beim Schreiben ueber das Zeilenende hinaus 	*/
X
Xint wordwrap()
X{
X  unsigned char s[STRING];
X  int i = MAXX -1, j = 0;
X  int a = y;
X  int b = y + 1;
X
X  while((i > 1) && (j == 0)){
X 	if((SCREEN[a][i] == BLANK) || (SCREEN[a][i] < 33)) j = i;
X	i--;
X  }
X
X  if(j == 0) return 1;
X
X  j++; x = 0;
X
X  for(i = j; i <= MAXX; i++){
X	SCREEN[b][x] = SCREEN[a][i];
X	SCREEN[a][i] = BLANK;
X
X	ATTRIB[b][x] = ATTRIB[a][i];
X	ATTRIB[a][i] = '0';
X
X	x++; 
X  } 
X  show_line( SCREEN[a], ATTRIB[a], 1 );
X  y++;
X  show_line( SCREEN[b], ATTRIB[b], 1 );  
X  y = a;
X
X  return x;
X}
END_OF_FILE
  if test 8395 -ne `wc -c <'wendy/misc.c'`; then
    echo shar: \"'wendy/misc.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/misc.c'
fi
if test -f 'wendy/wendy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/wendy.c'\"
else
  echo shar: Extracting \"'wendy/wendy.c'\" \(8407 characters\)
  sed "s/^X//" >'wendy/wendy.c' <<'END_OF_FILE'
X#include "wendy.h"
X
X
X 
X/*      Zeichen einlesen und bearbeiten         */
X 
Xloop( f )
Xunsigned char f[];
X{
X  unsigned char s[STRING];
X  int c;
X  int oldy = -1;
X 
X  ansi2( "cm", x, y );
X 
X  do{
X    c = getch();
X 
X    if(c == ESC){
X        c = getch();
X        if(c == ':'){
X                c = vi( f );
X                goto ENDLOOP;
X        }
X        else c *= 100;
X        c = c + getch();
X    }
X    /*
X    ansi2( "cm", 75, 1 );
X    ansi( "mr" );
X    printf("<%d> ", c);
X    ansi2( "cm", x, y );
X    activate( RTF_attrib );
X    */ 
X 
X    switch(c){
X        case ENTER      :       enter();
X                                break;
X        case CTRL_K     :
X        case UP         :       ctrlk();
X                                break;
X        case CTRL_J     :
X        case DOWN       :       ctrlj();
X                                break;
X        case LEFT       :       if(x > 1){
X                                        ansi( "kl" );
X                                        x--;
X                                }
X				else{
X					ctrlk();
X					lines_end();
X				}
X                                break;
X        case RIGHT      :       if(x < MAXX){
X                                        ansi( "kr" );
X                                        x++;
X                                }
X				else{
X					ctrlj();
X					x = 1;
X					ansi2( "cm", x, y );
X				}
X                                break;
X        case CTRL_B     :
X        case PGUP       :       pgup();
X                                break;
X        case CTRL_F     :
X        case PGDN       :       pgdn();
X                                break;
X        case CTRL_A     :
X        case HOME       :       x = 1;
X				ansi2( "cm", x, y );
X                                break;
X	case CTRL_E	:
X	case TLX_END	:
X        case CTRL_Z     :
X        case END        :       lines_end();
X                                break;
X        case BS         :       ctrlh();
X                                CHANGED++;
X                                break;
X	case TLX_DEL	:
X        case DEL        :       x++;
X                                CHANGED++;
X                                ctrlh();
X                                break;
X	case TAB	:	 x = (int)((x+8)/8*8) + 1;
X				if(x > MAXX) x = MAXX; 
X				ansi2( "cm", x, y ); 
X				break;
X        case CTRL_O     :       help();
X                                break;
X        case CTRL_P     :       if(RULER == 0){
X					strcpy(version, (unsigned char *) RULERLINE);
X					RULER++;
X					xruler = -1;
X				}
X				else{
X					RULER = 0;
X					strcpy(version, (unsigned char *) VERSION);
X				}
X				show_status( version );
X				STATUSM = 0;
X				ansi2( "cm", x, y );
X				break;
X        case CTRL_L     :       ansi( "me" );
X				ansi2( "cm", 1, y );
X                                show_line( SCREEN[y], ATTRIB[y], 1 );
X				activate( RTF_attrib );
X				ansi2( "cm", x, y );
X                                break;
X        case CTRL_R     :       show_status( version );
X                                show_screen( START );
X                                break;
X	case CTRL_X	:	ctrlx( f );
X				break;
X	case CTRL_W	:	ctrlw( f );
X				break;
X	case CTRL_N	:	ctrln();
X				break;
X	case CTRL_U	:	ctrlu();
X				break;
X	case CTRL_T	:	ctrlt();
X				break;
X	case CTRL_S	:	ctrls();
X				break;
X	case CTRL_Y	:	ctrly();
X				break;
X	case CTRL_Q	:	block_set();
X				break;
X	case TLX_INS	:	
X	case INS	:
X	case CTRL_V	:	ctrlv();
X				break;
X	case NUM5	:
X	case CTRL_G	:	ctrlg( f );
X				break;
X	default		:       if(c > 9100){
X#ifdef _LOCAL
X					show_status( " WENDY: Unbekannte Taste " );
X#else
X					show_status( " WENDY: Unknown key " );	
X#endif
X					ansi( "mr" );
X					printf("<%d>. ", c);
X					ansi( "me" );
X					ansi2( "cm", x, y );
X				}
X				if((c > 31) && (c < 9100)){
X					CHANGED++;
X					if(INS_mode == 0){
X						printf("%c", c);	
X						if(c == ' ') c = BLANK;	
X						SCREEN[y][(x-1)] = c;
X						ATTRIB[y][(x-1)] = RTF_attrib;
X						x++;
X						if(x > MAXX){
X							if(FORMATTER != 'b')
X								x = wordwrap();
X							if((y < MAXY) && (y < lastline))
X								y++;
X							else
X								ctrlj();
X							ansi2( "cm", x, y );
X						}
X					}
X					else{
X						insert( c );
X					}
X					if(FORMATTER == 'c'){
X						center();
X					}
X					if((ypos + y) > lastline)
X					lastline = ypos + y;
X				}
X    }
X
X
X
X
X    ENDLOOP:
X
X    if(oldy != y){
X	if((FLAG[(ypos + y - 1)] & is_richtext) == is_richtext){
X#ifdef _LOCAL
X		show_status( "Der folgende Text ist klassifiziert als 'text/richtext'." );
X#else
X		show_status( "The following text is classified as 'text/richtext'.");
X#endif
X	}
X	if((FLAG[(ypos + y - 1)] & is_plain) == is_plain){
X#ifdef _LOCAL
X		show_status( "Der folgende Text ist klassifiziert als 'text/plain'." );
X#else
X		show_status( "The following text is classified as 'text/plain'.");
X#endif
X	}
X	ansi2( "cm", x, y );
X    	/*
X	if(CHANGED != 0){
X		fprintf(ROLLBACK, "%05.5d %s\n", oldy, (unsigned char *) make_rtf( SCREEN[oldy], ATTRIB[oldy] ));
X	}
X	*/
X    }
X    oldy = y;
X
X    if(RULER){
X	if(x != xruler){
X		if(STATUSM != 0) show_status( version );
X		if(xruler != -1){
X			ansi( "mr" );
X			ansi2( "cm", xruler, 1 );
X			printf("%c", version[(xruler - 1)]);
X		}
X		ansi( "me" );
X		xruler = x;
X		ansi2( "cm", xruler, 1 );
X		printf("%c", version[(xruler - 1)]);
X		ansi2( "cm", x, y );
X		STATUSM = 0;
X		activate( RTF_attrib );
X	}
X    }
X
X  }while(c != CTRL_X);
X}
X
X
X
X/*	MAIN	*/
X
Xmain(argc, argv)
Xint argc;
Xunsigned char *argv[];
X{
X  FILE *fp;
X
X  unsigned char s[LONGSTRING];
X  unsigned char *home;
X  int i, j;
X  int RTF = 0;
X
X#if defined(_ESTDIO) || !defined(_SYS7)
X  setbuf(stdout, NULL);
X#endif
X
X  RTF_attrib = '0';
X
X  MAXX = 79;	/* Default Parameter */
X  MAXY = 24;
X  strcpy(terminal, (unsigned char *) "ansi" );
X  strcpy(umlaut, (unsigned char *) "ibm" );
X  
X  home = (unsigned char *) getenv( "HOME" );
X  sprintf(s, "%s/.wendy", home);
X
X  fp = fopen( s, "r" );
X  if(fp != NULL){
X	fgets(s, 80, fp); MAXY = atoi(s);
X	fgets(s, 80, fp); MAXX = atoi(s);
X	fgets(s, 80, fp); sscanf(s, "%s", &terminal);
X	fgets(s, 80, fp); sscanf(s, "%s", &umlaut);	
X	fclose(fp);
X  }
X  if(MAXY > 24) MAXY = 24;
X  if(MAXY <  4) MAXY =  4;
X  
X  if(MAXX < 10) MAXX = 80;
X
X
X  ansi2( terminal, -1, -1 );
X  i = ansi2( "cm" );
X  ansi( "cl" );
X#ifdef _LOCAL
X  printf("\n\nMein Name ist "); 
X#else
X  printf("\n\nMy name is ");
X#endif
X  ansi( "md" ); printf("Wendy");
X  ansi( "me" ); printf("!\n\n");
X
X
X  if((i == 1) || (i == -1)){
X#ifdef _LOCAL
X	printf("Und ich kann Dein Terminal nicht bedienen!\n\n");
X#else
X	printf("And I can't handle your terminal!\n\n");
X#endif
X	return;
X  }
X 
X  if(argc < 2){
X#ifdef _LOCAL
X	printf("Und Du hast vergessen einen Dateinamen anzugeben!\n\n");
X#else
X	printf("And you've forgotten to mention a filename!\n\n");
X#endif
X	return;
X  }
X  /*
X  sprintf(s, "/usr/tmp/WENDY.%d", getpid());
X  ROLLBACK = fopen( s, "w" );
X  if(ROLLBACK == NULL){
X	printf("Rollback ???");
X  }
X  fprintf(ROLLBACK, "00000 %s, %s [%s] on %s\n\n", mydate( 0 ), mytime( 0 ), whoami(), ttyna());
X  */
X  lastline = 2;
X  NEU = 0;
X  RTF_toggle = 0;
X
X  i = LINELENGTH -2;
X
X  fp = fopen( argv[1], "r" );
X  if(fp != NULL){
X	FLAG[lastline] = 0;
X	while(fgets(TEXT[lastline], i, fp) != 0){
X		FLAG[lastline+1] = 0;
X		if(strcomp("Content-Type: text/richtext", TEXT[lastline]) == 0){
X			FLAG[lastline] |= is_richtext;
X			lastline--;
X		}
X		if(strcomp("Content-Type: text/plain", TEXT[lastline]) == 0){
X			FLAG[lastline] |= is_plain;
X			lastline--;
X		}
X		lastline++;
X		if(lastline > MAXLINES){
X#ifdef _LOCAL
X			printf("Und die Datei <%s> ist zu gross fuer mich!\n\n", argv[1]);
X#else
X			printf("And the file <%s> is much to big for me!\n\n", argv[1]);
X#endif
X			fclose(fp);
X			return;
X		}
X	}
X	  fclose(fp);
X  }
X  else{
X	NEU++;
X	RTF_toggle++;
X	for(i = 0; i < 25; i++){
X		strcpy(TEXT[i], (unsigned char *) "\n");
X		FLAG[i] = 0;
X	}
X	lastline += 25;
X  }
X  strcpy(TEXT[lastline], (unsigned char *) "\n");
X
X  signal(SIGINT,  SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGHUP,  SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X  strcpy(version, (unsigned char *) VERSION);
X  show_status( version );
X 
X  INS_mode     = 0;
X  CHANGED      = 0;
X  REALLY       = 0;
X  MARK	       = 0;
X  START	       = 2;
X  RULER	       = 0;
X  STATUSM      = 0;
X  FORMATTER    = 0;
X  BLOCK.status = 0;
X
X  x = 1; y = START; ypos = 1;
X  
X  prep_screen( ypos );
X  show_screen( START );
X 
X  echo( 0 );
X  loop( argv[1] );
X  echo( 1 );
X  /*
X  fclose( ROLLBACK );
X  */
X  ansi( "me" );
X  ansi2( "cm", 1, MAXY );
X  ansi( "ce" );
X}
END_OF_FILE
  if test 8407 -ne `wc -c <'wendy/wendy.c'`; then
    echo shar: \"'wendy/wendy.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/wendy.c'
fi
echo shar: End of archive 12 \(of 15\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
