Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i041:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part06/15
Message-ID: <1993Feb5.185705.10231@sparky.imd.sterling.com>
X-Md4-Signature: c999e202c8a8eb41a784f2c2eba1fbf7
Date: Fri, 5 Feb 1993 18:57:05 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 41
Archive-name: mbox/part06
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/mb-daemon.c src/misc.c src/uptodate.c
# Wrapped by kent@sparky on Fri Feb  5 12:18:07 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 15)."'
if test -f 'src/mb-daemon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mb-daemon.c'\"
else
  echo shar: Extracting \"'src/mb-daemon.c'\" \(24038 characters\)
  sed "s/^X//" >'src/mb-daemon.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  mb-daemon.c					   */
X/*        FUNKTIONEN  reflector(), scan(), mix(), main()		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.09.1992					   */
X/***************************************************************************/
X
X#ifndef _ESTDIO
X#include <stdio.h>
X#else
X#include <estdio.h>
X#endif
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <time.h>
X#include <dirent.h>
X
X#include "mbox.h"
X
X
Xint FASTMODE;
X
X
Xint mb_gruppen;
Xint mb_new;
Xlong mb_bytes;
Xlong mb_new_bytes;
Xlong mb_artikel;
X
X#ifdef ADDRMODE
XFILE *ad;
X#endif
X
X/***************************************************************************/
X/*      FUNKTION  reflector()						   */
X/*  BESCHREIBUNG  Sendet eine persoenliche Mail an den Autor eines Arti-   */
X/*		  kels in einer bestimmten NG.	                           */
X/*			                                                   */
X/*		  VORSICHT: Wilde Reflectoren werden vom Netz getrennt !!! */
X/*     PARAMETER  arg  =  DUMMY (?)                                        */
X/*		  msg  =  Artikel                                          */
X/*     RUECKGABE  -1   =  Artikel nicht gefunden                           */
X/*                0    =  Ok					 	   */
X/***************************************************************************/
X
Xint FLAG;
X
Xint reflector(arg, msg)
Xunsigned char arg[];
Xunsigned char msg[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  unsigned char s[255];
X  unsigned char tmp[STRING];
X
X  unsigned char receiver[STRING];
X
X  unsigned char path[255];
X  unsigned char reply_to[255];
X  unsigned char from[255];
X  unsigned char sender[255];
X  unsigned char subject[255];
X  unsigned char summary[255];
X  unsigned char keywords[255];
X  unsigned char newsgroups[255];
X  unsigned char followup_to[255];
X  unsigned char distribution[255];
X  unsigned char date[255];
X  unsigned char lines[255];
X  unsigned char message_id[255];
X  unsigned char organization[255];
X  unsigned char posted[255];
X  unsigned char article_id[255];
X  unsigned char nntp_post[255];
X  unsigned char references[255];
X
X  int id_err = 0;
X  int i;
X  int inlines;
X
X  int reply = 0;
X  int noreply = 0;
X  int dirlist = 0;
X  int logfile = 0;
X  int info = 0;
X  int minimal = 0;
X  long timer;
X
X  int ok = 0;
X
X  fp = fopen(msg, "r");
X  if (fp == NULL) return -1;
X
X  sprintf(tmp, "%s/%d", TMP, getpid());
X  ff = fopen(tmp, "w");
X  
X  i = 1;
X  inlines = -1;
X
X  while (fgets(s, 255, fp) != NULL) {
X	ok = 0;
X	if (strcomp("Path:", s) == 0) {
X		sprintf(path, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Reply-To:", s) == 0) {
X		sprintf(reply_to, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		reply--;
X		ok++;
X	}
X	if (strcomp("From:", s) == 0) {
X		sprintf(from, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Sender:", s) == 0) {
X		sprintf(sender, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Subject:", s) == 0) {
X		sprintf(subject, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Summary:", s) == 0) {
X		sprintf(summary, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Keywords:", s) == 0) {
X		sprintf(keywords, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Newsgroups:", s) == 0) {
X		sprintf(newsgroups, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Followup-To:", s) == 0) {
X		sprintf(followup_to, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Distribution:", s) == 0) {
X		sprintf(distribution, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Date:", s) == 0) {
X		sprintf(date, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Lines:", s) == 0) {
X		sprintf(lines, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Message-I", s) == 0) {
X		sprintf(message_id, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		/*
X		if (s[9] == 'D') id_err++;
X		*/
X		ok++;
X	}
X	if (strcomp("Organization:", s) == 0) {
X		sprintf(organization, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Posted:", s) == 0) {
X		sprintf(posted, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Article-I.D.:", s) == 0) {
X		sprintf(article_id, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("Nntp-Posting-Host:", s) == 0) {
X		sprintf(nntp_post, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X	if (strcomp("References:", s) == 0) {
X		sprintf(references, "%02d>> %s <<\n", i, (unsigned char *) stripped(s));
X		ok++;
X	}
X
X
X
X	if (strcomp("NO REPLY", s)        == 0 ||
X	    strcomp("NOT REPLY", s)       == 0 ||
X	    strcomp("KEIN REPLY", s)      == 0 ||
X	    strcomp("NO REPLIES", s)      == 0 ||
X	    strcomp("KEINE REPLIES", s)   == 0 ||
X	    strcomp("NO REPLYS", s)       == 0 ||
X	    strcomp("KEINE REPLYS", s)    == 0 ||
X	    strcomp("KEINE ANTWORTEN", s) == 0 ||
X	    strcomp("NICHT ANTWORTEN", s) == 0 ||
X	    strcomp("NO REFLECT", s)      == 0 ||
X	    strcomp("NOT REFLECT", s)     == 0 ||
X	    strcomp("NO ANSWER", s)       == 0 ||
X	    strcomp("NOT ANSWER", s)      == 0 ||
X	    strcomp("IGNORE", s)          == 0)
X		noreply++;
X
X	if (strcomp("PLEASE REPLY", s)    == 0 ||
X	    strcomp("BITTE REPLY", s)     == 0 ||
X	    strcomp("PLEASE REFLECT", s)  == 0 ||
X	    strcomp("BITTE REFLECT", s)   == 0 ||
X	    strcomp("BITTE ANTWORT", s)   == 0 ||
X	    strcomp("REPLY", s)           == 0 ||
X	    strcomp("REFLECT", s)         == 0 ||
X	    strcomp("ANTWORT", s)         == 0)
X		reply++;
X
X	if (strcomp("DIRLIST", s) == 0) dirlist++;
X
X	if (strcomp("LOGFILE", s) == 0) logfile++;
X
X	if (strcomp("INFO", s) == 0 ||
X	    strcomp("HELP", s) == 0)
X		info++;
X
X	if (strcomp("SHORT", s) == 0) minimal++;
X
X	if (ok == 0) {
X		/* Sprintf(s, "%02d Body >> %s <<\n\n", i, (unsigned char *) stripped(s)); */
X		inlines++;
X	}
X	i++;
X  }
X  fclose(fp);
X
X  strcpy(s, (unsigned char *) strcopy(organization, 19, 80));
X  if ((FLAG == 1) && (strcomp(ORGANIZATION, s) != 0)) return -1;
X
X  if (reply_to[0] != '\0') {
X	strcpy(receiver, (unsigned char *) strcopy(reply_to, 15, 80));
X  } else {
X	strcpy(receiver, (unsigned char *) strcopy(from, 11, 80));
X  }
X
X  i = 0;
X  while ((receiver[i] != '\0') && (receiver[i] != '(')) i++;
X  receiver[(i - 1)] = '\0';
X
X
X
X  time(&timer);
X
X  fprintf(ff, "From: reflector@%s (Reflecting Device)\n", UUCPID2); 
X  fprintf(ff, "Reply-To: postmaster@%s (Reflectors' Boss)\n", UUCPID2);
X  fprintf(ff, "Organization: %s\n", ORGANIZATION);
X  if(message_id[0] != '\0'){
X	fprintf(fp, "References: %s", message_id);
X  }
X  fprintf(ff, "To: %s\n", receiver);
X  fprintf(ff, "Subject: *Reflexion*\n");
X  fprintf(ff, "X-Mailer: %s %s %s\n", VERSION, PATCHLEVEL, AUTOR);	
X  fprintf(ff, "Message-Id: <%x.reflector@%s>\n", timer, UUCPID2);
X  fputs("\n", ff);
X
X
X
X  fp = fopen(REFLECT_LOG, "a");
X  if (fp == NULL) {
X	while (1) printf("%c", 7);
X  }
X  fprintf(fp, "%s - %s", (unsigned char *) mydate(1), from);
X  fprintf(fp, "         - %s", message_id);
X  fprintf(fp, "         - %s", subject);
X  if (dirlist != 0) {
X	fprintf(fp, "         - DIRLIST-Request\n");
X  }
X  if (logfile != 0) {
X	fprintf(fp, "         - LOGFILE-Request\n");
X  }
X  if (info != 0) {
X	fprintf(fp, "         - INFO-Request\n");
X  }
X  fprintf(fp, "         - Reflected to %s\n\n", receiver);
X  fclose(fp);
X
X
X  fprintf(ff, "%s\n\n", MVERSION);
X
X
X  if ((dirlist == 0) && (logfile == 0) && (info == 0) && (minimal == 0)) {
X	fprintf(ff, "That's what we received in NG \"%s\" ...\n\n", arg);
X
X	fputs(path, ff);
X	fputs(from, ff);
X	fputs(reply_to, ff);
X	fputs(sender, ff);
X	fputs(newsgroups, ff);
X	fputs(subject, ff);
X	fputs(article_id, ff);
X	fputs(posted, ff);
X	fputs(nntp_post, ff);
X	fputs(summary, ff);
X	fputs(keywords, ff);
X	fputs(followup_to, ff);
X	fputs(distribution, ff);
X	fputs(references, ff);
X	fputs(message_id, ff);
X	fputs(organization, ff);
X	fputs(date, ff);
X	fputs(lines, ff);
X
X
X	fputs("\n\nDiagnostics ...\n\n", ff);
X
X	ok = 0;
X
X	if (id_err != 0) {
X		fprintf(ff, "- \"Message-ID\" may cause trouble ... use \"Message-Id\".\n\n");
X		ok++;
X	}
X	if (reply_to[0] == '\0') {
X		fprintf(ff, "- No \"Reply-To\"-Path ... not a problem.\n\n");
X		ok++;
X	}
X	i = atoi((unsigned char *) strcopy(lines, 12, 80));
X	inlines--;
X	if (inlines != i) {
X		fprintf(ff, "- Your Header reports %d lines ... we counted %d.\n\n", i, inlines);
X		ok++;
X	}
X	if ((reply != 0) || (noreply != 0)) {
X		fprintf(ff, "- Found %d Reply-Requests and %d No-Replies.\n\n", reply, noreply);
X		ok++;
X	}
X
X	if (ok == 0) {
X		fprintf(ff, "- Everything seems to be correct!\n\n");
X	}
X  }
X
X	
X  if (dirlist != 0) {
X	fp = fopen(DIRLIST, "r");
X	if (fp != NULL) {
X		fputs("DIRLIST:\n\n", ff);
X		while (fgets(s, 250, fp) != NULL) fputs(s, ff);
X		fclose(fp);
X	} else {
X		fputs("Sorry, no DIRLIST-Entry found ...\n\n", ff);
X	}
X	printf("\n\n");
X  }
X  if (logfile != 0) {
X	fp = fopen(REFLECT_LOG, "r");
X	if (fp != NULL) {
X		fputs("LOGFILE:\n\n", ff);
X		while (fgets(s, 250, fp) != NULL) fputs(s, ff);
X		fclose(fp);
X	} else {
X		fputs("Sorry, no LOGFILE-Entry found ...\n\n", ff);
X	}
X	printf("\n\n");
X  }
X  if (info != 0) {
X	fputs("INFO (weitere Schluesselwoerter):\n\n", ff);
X	fputs("LOGFILE - Wenn der Reflektor nicht reflektiert, kann man sich\n", ff);
X	fputs("          das LOGFILE senden lassen, um zu ueberpruefen ob der\n", ff);
X	fputs("		         Artikel jemals erfasst worden ist.\n\n", ff);
X
X	fputs("DIRLIST - Eine Liste des lokalen MINIX-Archivs. Da der Reflektor\n", ff);
X	fputs("          (noch) kein PD-Server ist, kann man diese Liste nur zu\n", ff);
X	fputs("          Testzwecken anfordern.\n\n", ff);
X
X	fputs("SHORT   - Quittiert nur den Empfang des Artikels.\n\n", ff);
X  }
X  if (minimal != 0) {
X	fprintf(ff, "Received your article %s", message_id);
X  }
X  fclose(ff);
X
X  sprintf(s, "/bin/sh ./etc/rmail.sh %s %s", tmp, receiver);
X  system(s);
X
X  unlink(tmp);
X
X  return 0;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  pdsize()						   */
X/*  BESCHREIBUNG  Groesse eine PD-Datei ermitteln 			   */
X/*     PARAMETER  arg - Name des NG-Eintrags                               */
X/*     RUECKGABE  Groesse in kBytes                                        */
X/***************************************************************************/
X
Xint pdsize( arg )
Xunsigned char arg[];
X{
X  FILE *fp;
X  unsigned char s[STRING];
X  int ok = 0, i;
X  struct stat fstat;
X
X  fp = fopen( arg, "r" );
X  if(fp == NULL){
X	return (int) 0;
X  }
X  while((ok == 0) && (fgets(s, 80, fp) != NULL)){
X	if(strcomp("BINFILE", s) == 0) ok++;
X  }
X  fgets(s, 80, fp);
X  fclose(fp);
X
X  if(ok == 0) strcpy(s, (unsigned char *) arg);
X
X  if(stat((unsigned char *) stripped(s), &fstat) != NULL){
X	return (int) 0;
X  }
X  i = (int) (fstat.st_size / 1024);
X  if(i < 1) i = 1;
X  return (int) i;
X}
X
X
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  scan()						   */
X/*  BESCHREIBUNG  Filtert einen NEWS-Artikel, und erstellt einen Eintrag   */
X/*		  fuer das entsprechenden INDEX-Files der ix/Mbox.	   */
X/*     PARAMETER  arg  =  NG                                               */
X/*     RUECKGABE  Datum des aktuellsten Artikels                           */
X/***************************************************************************/
X
Xunsigned char *scan(arg)
Xunsigned char arg[];
X{
X  FILE *ff;
X  FILE *fp;
X  FILE *fl;
X  FILE *ft;
X  FILE *fg;
X
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char f[STRING];
X  unsigned char v[STRING];
X  unsigned char from[STRING];
X  unsigned char subj[STRING];
X  unsigned char date[STRING];
X  unsigned char line[STRING];
X  unsigned char orga[STRING];
X  unsigned char Ndir[STRING];
X  unsigned char Ldir[STRING];
X  unsigned char Tdir[STRING];
X  unsigned char ex[1024];
X  unsigned char et[355];
X
X  int dirarray[MAX_PER_NG];
X  int idp = 0, iii = 0;
X
X  DIR *dp;
X  struct dirent *actdir;
X
X
X  static unsigned char sdate[STRING];
X
X  unsigned char today[STRING];
X  unsigned char thatday[STRING];
X  unsigned char arti[STRING];
X
X  int i, j;
X  int ok = 0;
X  int a, b;
X  int BINFILE = 0;
X  int PDGROUP = 0;
X  int fsi = 0;
X  int seq = 0;
X  int OLDENTRY = 0;
X  int OLDn = 0;
X  int OLDo = 0;
X  int got_org = 0;
X
X  struct stat fstat;
X  struct tm *tp;
X
X  i = 0;
X  while (arg[i] != '\0') {
X	t[i] = arg[i];
X	if (t[i] == '.') t[i] = '/';
X	i++;
X  }
X  t[i] = '\0';
X
X  sprintf(Ndir, "%s/%s", NEWS, t);
X
X  if(length(arg) > 14){
X#ifndef _LONGNAMES
X	strcpy(s, (unsigned char *) shortname(arg));
X#else
X	strcpy(s, (unsigned char *) arg);
X#endif
X	sprintf(Ldir, "%s/%s", LIB, s);
X  } 
X  else{
X	sprintf(Ldir, "%s/%s", LIB, arg);
X  }
X  strcpy(Ldir, (unsigned char *) stripped(Ldir));
X
X  sprintf(Tdir, "%s/TD.%d", TMP, getpid());
X
X  if (FLAG == 0) printf("\n%s...\n", Ndir);
X
X  sprintf(f, "%s/%dA", TMP, getpid());
X
X
X  dp = opendir( Ndir );
X  if(dp == NULL){
X	printf("::No such directory!\n\n");
X	return "";
X  }
X  while((actdir = readdir(dp)) != NULL){
X	 dirarray[idp] = atoi(actdir->d_name);
X	 if(dirarray[idp] != 0) idp++;
X	 if(idp >= MAX_PER_NG){
X		nerror("mb-daemon.c", 506, "scan", "Verzeichnis zu gross > ", Ndir );		
X	 }
X  }
X  closedir(dp);
X
X  for(i = 0; i < idp; i++){
X	for(j = 0; j< idp; j++){
X		if(dirarray[i] > dirarray[j]){
X			a = dirarray[j];
X			dirarray[j] = dirarray[i];
X			dirarray[i] = a;
X		}
X        }
X  } 
X
X  if(idp == 0){
X	if (FLAG == 0) printf("::Directory is empty!\n\n");
X	ft = fopen(Ldir, "w");
X	fputs(" ", ft);
X	fclose(ft);
X	return "";
X  }
X
X  sprintf(sdate, "%s", ":-)");
X
X  sprintf(today, "%s", (unsigned char *) mydate(1));
X
X
X  ft = fopen(Ldir, "r");
X  if(ft == NULL){
X	ft = fopen(Ldir, "w");
X	fputs("\n\n0\n", ft);
X	fclose(ft);
X	ft = fopen(Ldir, "r");
X	OLDo = -2;
X  }
X  fgets(s, 81, ft);
X  fgets(s, 81, ft);
X  fgets(s, 81, ft);
X  OLDENTRY = atoi(s); 
X
X  mblock(Ldir);
X
X  ff = fopen(Tdir, "w");
X
X  seq = 0;
X
X  mb_gruppen++;
X
X
X  if(strcomp(PDNG, arg) == 0){
X	PDGROUP++;	
X	fprintf(ff, "%s\n", GBL08_MSG); 
X  }
X  else{
X	fprintf(ff, "%s\n", GBL05_MSG);
X  }
X  fputs("===============================================================================\n", ff);
X
X  while (iii < idp) {
X
X	if((dirarray[iii] < OLDENTRY) && (FASTMODE == 1)) goto YET_SCANNED;
X
X	OLDn++;
X
X	seq++;
X	BINFILE = 0;
X	fsi++;
X
X	sprintf(arti, "%s/%d", Ndir, dirarray[iii]);  
X	strcpy(t, (unsigned char *) arti); /* ??? */
X
X	if (FLAG == 0) printf("%s: ", t);
X
X	fp = fopen(t, "r");
X	if (fp != NULL) {
X
X		stat(t, &fstat);
X		tp = localtime(&fstat.st_mtime);
X
X		if(fstat.st_mode & S_IFDIR) goto OFF_HERE;
X
X		mb_bytes += (long) fstat.st_size;
X		sprintf(thatday, "%02.2d.%02.2d.%02.2d", tp->tm_mday, tp->tm_mon + TZS, tp->tm_year);
X		if(strcomp(thatday, today) == 0) mb_new_bytes += (long) fstat.st_size;
X
X		if (sdate[0] == ':') {
X			sprintf(sdate, "%4.4d%02.2d%02.2d",
X				1900 + tp->tm_year, tp->tm_mon + TZS, tp->tm_mday);
X			sprintf(s, "%02.2d:%02.2d",
X				tp->tm_hour, tp->tm_min);
X			LASTTIME = timeconv(s);
X			if (FLAG == 0) printf(" (%s) ", sdate);
X			if(strcomp(thatday, today) == 0) mb_new++;
X		}
X		if ((strcomp(arg, REFLECT_NG) == 0) || (strcomp(arg, "local.test") == 0)) {
X			if (strcomp(thatday, today) == 0) {
X				reflector(arg, t);
X			}
X		}
X		from[0] = '\0';
X		subj[0] = '\0';
X		date[0] = '\0';
X		line[0] = '\0';
X		orga[0] = '\0';
X
X		got_org = 0;
X		i = 0;
X
X		while((got_org == 0) && (i < 20)){
X			fgets(ex, 1024, fp);
X#ifdef ADDRMODE
X			if (strcomp("de.", arg) == 0) {
X				if (strcomp("Path:", ex) == 0) {
X					fprintf(ad, "%s\n", (unsigned char *) stripped(ex));
X				}
X			}
X#endif
X			ex[80] = '\0'; strcpy(s, ex);
X			if (strcomp("From:", s) == 0) {
X				strcpy(from, s);
X			}
X			if (strcomp("Reply-To:", s) == 0) {
X				strcpy(from, s);
X			}
X			if (strcomp("Subject:", s)      == 0) strcpy(subj, s);
X			if (strcomp("Date:", s)         == 0) strcpy(date, s);
X			if (strcomp("Lines:", s)        == 0) strcpy(line, s);
X			if (strcomp("BINFILE", s)       == 0) BINFILE++;
X			if (strcomp("Organization:", s) == 0) strcpy(orga, s);
X			if (strlen(s) < 3) got_org++;
X			i++;
X		}
X
X#ifdef ADDRMODE		
X		if (strcomp("de.", arg) == 0) {
X			fprintf(ad, "%s\n", (unsigned char *) stripped(from));
X			fprintf(ad, "%s\n", (unsigned char *) stripped(orga));
X		}
X#endif
X
X		if (FLAG == 0) printf("%s", subj);
X
X		if ((from[0] == 'F') || (from[0] == 'R')) {
X
X			sprintf(s, "%d        ", dirarray[iii]);
X			s[6] = '\0';
X			if (BINFILE != 0) s[5] = '*';
X
X			subj[79] = '\0';
X			strcpy(ex, (unsigned char *) strcopy(subj, 8, 79));
X			strcpy(et, (unsigned char *) stripped(ex));
X			strcpy(ex, et);
X			strcat(ex, "                           ");
X			ex[25] = '\0';
X			strcat(s, ex);
X			strcat(s, "   ");
X
X			
X			i = 5; /* 8 */
X			if (from[0] == 'R') i = 10;
X
X			from[79] = '\0';
X			strcpy(ex, (unsigned char *) strcopy(from, i, 80));
X			strcpy(et, (unsigned char *) stripped(ex));
X			strcpy(ex, et);
X
X			a = 0;
X			b = 0;
X			i = 0;
X			while (ex[i] != '\0') {
X				if (ex[i] == '(') a = i + 1;
X				if (ex[i] == ')') b = i - 1;
X				i++;
X			}
X			if (a < b) {
X				strcpy(et, (unsigned char *) strcopy(ex, a, b));
X				strcpy(ex, et);
X			}
X			strcat(ex, "                           ");
X			ex[19] = '\0';
X			strcat(s, ex);
X			strcat(s, "   ");
X
X
X			i = 0;
X			j = 0;
X			while (date[i] != '\0') {
X				if (j == 0) {
X					if ((date[i] >= '1') && (date[i] <= '9'))
X						j = i;
X				}
X				i++;
X			}
X
X			sprintf(ex, "%02.2d.%02.2d.%02.2d  %02.2d:%02.2d",
X			 tp->tm_mday, tp->tm_mon + TZS, tp->tm_year,
X				tp->tm_hour, tp->tm_min);
X			strcat(ex, "                         ");
X			ex[15] = '\0';
X			strcat(s, ex);
X			strcat(s, "  ");
X
X			strcpy(ex, (unsigned char *) strcopy(line, 7, 20));
X			strcpy(t, (unsigned char *) stripped(ex));
X			i = atoi(t);
X			sprintf(ex, "%-6.d", i);
X		
X			if(PDGROUP != 0){
X				i = pdsize(arti);
X				sprintf(ex, "%-6.d", i);
X				if(i == 0){
X					fg = fopen( CPRN, "a" );
X				        if(fg != NULL){
X						fprintf(fg, "\nMB-DAEMON -> %23.23s | %s\n", s, arti);
X						fclose(fg);
X					}
X				}
X			}
X
X			strcat(s, ex);
X			fputs(s, ff);
X			fputs("\n", ff);
X
X			mb_artikel++;
X
X			ok = 1;
X		} else {
X			if (FLAG == 0) printf("invalid header!\n");
X		}
X
X		OFF_HERE:
X
X		if (fp != 0) fclose(fp);
X	} else {
X		if (FLAG == 0) printf("can't open!\n");
X	}
X	iii++;
X  }
X
X  YET_SCANNED:
X
X  if(OLDn != 0) OLDn -= 1;
X
X  idp -= 2; /* ??? */
X
X  while(iii < idp){
X	if((OLDn != 0) || (FASTMODE == 0)){
X		fgets(s, 81, ft); 
X		fputs(s, ff);
X	}
X	if(FLAG == 0){
X		sprintf(t, "%s/%d", Ndir, dirarray[iii]);
X		stat(t, &fstat);
X		mb_bytes += (long) fstat.st_size;
X	}
X	mb_artikel++;
X	OLDo++;
X	iii++;
X  }
X
X  if((OLDn != 0) || (FASTMODE == 0)){
X	fgets(s, 81, ft);
X	if((FASTMODE == 1) && (OLDo > 0)) fputs(s, ff);
X	fclose(ff);
X	fclose(ft);
X	if(rename( Tdir, Ldir ) != 0){
X		ff = fopen( Tdir, "r");
X		ft = fopen( Ldir, "w");
X		while(fgets(s, 81, ff) != NULL){
X			fputs(s, ft);
X		}
X	}
X  }
X  if (ff != 0) fclose(ff);
X  if (ft != 0) fclose(ft);
X
X  unlink(f);
X  unlink(Tdir);
X
X
X  if (sdate[0] == ':') {
X	sprintf(sdate, "%s", "19700101");
X	LASTTIME = 0;
X  }
X
X#ifdef _SYS7
X  if ((seq > MAX_PER_NG) && (FLAG == 0) && (strcomp("local", arg) != 0)) {
X	sprintf(s, "%s -n %s -e %d", EXPIRE, arg, EXPIRED_DAYS);
X	printf("%s\n", s);
X	system(s);
X	sprintf(s, "%s %s EXP", MB_DAEMON, arg);
X	system(s);
X  }
X#endif
X  
X  mbunlock(Ldir);
X
X  if((FASTMODE == 1) && (FLAG == 0)){
X	OLDo += 2;
X	printf("\n==> %s %d. %s %d.\n\n", MBD01_MSG, OLDn, MBD02_MSG, OLDo);
X  }
X  
X  return (unsigned char *) sdate;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mix()							   */
X/*  BESCHREIBUNG  Aktualisiert einzelnen Eintraege im AGROUPS-File.	   */
X/*     PARAMETER  s  =  NG                                                 */
X/*		  t  =  Neuer AGROUPS-Eintrag                              */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mix( s, t )
Xunsigned char s[], t[];
X{
X  FILE *ff, *fp;
X  unsigned char tmp[STRING];
X  unsigned char f[STRING];
X
X  sprintf(tmp, "%s/ff%d", TMP, getpid());
X
X
X  maybe_locked( AGROUPS, "r" );
X  fp = fopen( AGROUPS, "r" );
X  if(fp == NULL){
X	printf("%s ?", AGROUPS);
X	exit(-1);
X  }
X
X  ff = fopen( tmp, "w" );
X  if(ff == NULL){
X	printf("%s ?", tmp);
X	exit(-1);
X  }
X
X  while(fgets(f, 80, fp) != NULL){
X	if(strcomp(s, f) == 0){
X		fputs(t, ff);
X	}
X	else{
X		fputs(f, ff);
X	}
X  }
X  fclose(fp);
X  fclose(ff);
X
X  sprintf(f, "mv %s %s", tmp, AGROUPS);
X  system( f );
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  main() (mb_daemon)					   */
X/*  BESCHREIBUNG  Scannt einen bzw. alle NEWS-Artikel, um die INDEX-Files  */
X/*		  der ix/Mbox zu aktualisieren.                            */
X/*     PARAMETER  argc  =  Anzahl der Parameter                            */
X/*		  argv  =  NG  = nur diese NG scannen 			   */
X/*			   ''  = alle NGs scannen     			   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xmain(argc, argv)
Xint argc;
Xunsigned char *argv[];
X{
X  FILE *fp;
X  FILE *fa;
X  FILE *fc;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char d[STRING];
X  unsigned char TMP_AGROUPS[STRING];
X
X  int a, b, i;
X
X  chdir(HOME);
X
X  setuid(0);
X  setgid(0);
X  umask(0000);
X
X  FLAG = 0;
X  FASTMODE = 1;
X
X  sprintf(TMP_AGROUPS, "%s/ACTIVE.%d", TMP, getpid() );
X
X  if(argc > 1){
X	FLAG++;
X  }
X  if(argc > 2){			/* MB-Daemon ruft MB-Daemon !!! */
X	FLAG++; 
X	FASTMODE = 0; 
X  }
X
X  if(strcomp("all", argv[1]) == 0) FLAG = 0;
X
X#if 0
X  if(argv[2][0] == '-'){	/* Index KOMPLETT neu bilden !!! */
X	FASTMODE = 0;
X  }
X#endif
X
X  if(FLAG == 0){
X	fa = fopen( TMP_AGROUPS, "w" );
X	if(fa == NULL){
X		printf("%s ???", TMP_AGROUPS);
X		exit( 0 );
X	}
X  }
X
X#ifdef ADDRMODE
X    ad = fopen( "/local/address/addresses", "a" );
X    if(ad == NULL){
X	printf("\n[local/address/addresses] ???\n");
X	exit( 0 );	
X    }
X#endif
X
X  mb_gruppen = 0;
X  mb_new = 0;
X  mb_bytes = 0L;
X  mb_new_bytes = 0L;
X  mb_artikel = 0L;
X
X
X  if (fp = fopen(NGROUPS, "r"))
X  while (fscanf(fp, "%s %d %d %s", s, &a, &b, t) > 0) {
X#ifdef _CNEWS
X	if(t[0] == '=')
X		continue;
X#endif
X	if(FLAG > 0){
X		if(strcomp(argv[1], s) == 0){
X			d[0] = '\0';
X#ifdef _SYS7
X			strcat(d, (unsigned char *) scan(s));
X#else
X			strcat(d, (unsigned char *) scan(&s));
X#endif
X			sprintf(t, "%s  %s  %ld\n", s, d, LASTTIME);
X			if(FLAG < 2) mix( s, t );
X		}
X	}
X	else{
X		d[0] = '\0';
X#ifdef _SYS7	
X		strcat(d, (unsigned char *) scan(s));
X#else	
X		strcat(d, (unsigned char *) scan(&s));
X#endif
X		fprintf(fa, "%s  %s  %ld\n", s, d, LASTTIME);
X	}
X  }
X  if(fp != 0) fclose(fp);
X
X  if(FLAG > 0){
X  }
X  else{
X     mb_bytes = (long)(mb_bytes / 1024);
X     mb_new_bytes = (long)(mb_new_bytes /1024);
X   
X     sprintf(d, "%s/%d.mbd", TMP, getpid());
X     fp = fopen( d, "w" );
X     fprintf(fp, "%s  %s    %6.d   %6.ld",
X                  mydate(1), mytime(1), mb_new, mb_new_bytes);
X     fprintf(fp, "%16.16s", " ");
X     fprintf(fp, "%6.d   %6.ld   %6.ld\n", mb_gruppen, mb_artikel, mb_bytes);
X
X     b = PRO_ENTRIES / 2; a = 0;
X
X     fc = fopen( MB_DLOG, "r" );
X     if(fc != 0){
X	while((fgets(s, STRING, fc) != 0) && (a < b)){
X		fputs(s, fp);
X		a++;
X	}
X	fclose(fc);
X     }
X     if(fp != 0) fclose(fp);
X
X     sprintf(s, "mv %s %s > /dev/null", d, MB_DLOG);
X     system(s);
X  } 
X
X  if((FASTMODE == 1) && (FLAG == 0)){
X	printf("%s %d %s %ld %s.\n", MBD03_MSG, mb_new, MBD04_MSG, 
X		mb_new_bytes, MBD05_MSG);
X	printf("%s %d %s %ld %s %ld %s.\n\n", 
X		MBD06_MSG, mb_gruppen, MBD07_MSG, mb_artikel, MBD08_MSG, 
X		mb_bytes, MBD09_MSG);
X  }
X
X
X#ifdef ADDRMODE
X  if(ad != 0) fclose(ad);
X#endif
X
X  if(FLAG == 0){
X	fflush(fa);
X	fclose(fa);
X	fp = fopen( TMP_AGROUPS, "r" );
X	if(fp == NULL){
X	}
X	fa = fopen( AGROUPS, "w" );
X	if(fa == NULL){
X	}
X	while(fgets(s, 80, fp) != 0){
X		fputs(s, fa);
X	}
X	fflush(fa);
X	fclose(fa);
X	fclose(fp);
X	unlink( TMP_AGROUPS );
X  }
X
X  return;
X}
X
X
END_OF_FILE
  if test 24038 -ne `wc -c <'src/mb-daemon.c'`; then
    echo shar: \"'src/mb-daemon.c'\" unpacked with wrong size!
  fi
  # end of 'src/mb-daemon.c'
fi
if test -f 'src/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/misc.c'\"
else
  echo shar: Extracting \"'src/misc.c'\" \(23300 characters\)
  sed "s/^X//" >'src/misc.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  misc.c						   */
X/*        FUNKTIONEN  scanner(), schreiben(), prf(), pruefe()		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  26.09.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <utmp.h>
X#include <time.h>
X
X
X#include "mbox.h"
X
X
Xextern unsigned char headinfo[STRING];
X
X
Xint lastpoint( name )
Xunsigned char name[];
X{
X  int a = 0, b = 0;
X
X  while(name[a] != '\0'){
X	if(name[a] == '.') b = a;
X	a++;
X  }
X  if(b == 0) return a;
X
X  return (int) b;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  scanner()   						   */
X/*  BESCHREIBUNG  Wechselt BRETTER. Bei "B +" bzw. "B -" wird die Aktual-  */
X/*		  litaet nicht beruecksichtigt. In den anderen Modi 	   */
X/*		  werden nur aktuelle Bretter angesprungen.                */
X/*     PARAMETER  mode  =  '> 255'  =  nicht nur aktuelle Bretter	   */
X/*		           '> 500'  =  zur nexten AREA			   */
X/*			   '+'      =  aufwaerts springen		   */
X/*			   '-'      =  abwaerts springen		   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid scanner(mode)
Xint mode;
X{
X  FILE *fp;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char f[STRING];
X  unsigned char prevg[STRING];
X  unsigned char prevf[STRING];
X  int ok = 0, a, b;
X  int line = 0, l = 0;
X  int locmod = 0;
X  int max = 0;
X  int widerange = 0;
X
X
X  if (mode >= 1000) {
X	widerange = 1000;
X	mode -= 1000;
X  }
X
X  if (mode >= 500) {
X	locmod = 500;
X	mode -= 500;
X  }
X
X  if (mode >= 255) {
X	locmod = 255;
X	mode -= 255;
X  }
X  KEIN_ZUGRIFF:
X
X  if (locmod == 255) {
X	maybe_locked(NGROUPS, "r");
X	fp = fopen(NGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 26, "scanner", "Datei-Lesefehler", NGROUPS);
X	}
X }
X  else {
X	maybe_locked(UGROUPS, "r");
X	fp = fopen(UGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 34, "scanner", "Datei-Lesefehler", UGROUPS);
X	}
X  }
X
X  f[0] = '\0';
X  ok = 0;
X  strcpy(prevg, "L.I.S.A.");
X
X  while ((ok == 0) && (fscanf(fp, "%s %d %d %s", s, &a, &a, t) > 0)) {
X	l++;
X	if (strcomp(NG, s) == 0) {
X		ok = 1;
X	}
X	else {
X		strcpy(f, (unsigned char *) s);
X	
X		if(strcomp(prevg, s) != 0){
X			if(widerange == 0){
X		  		a = lastpoint( s );
X				strcpy(prevg, (unsigned char *) s);
X				strcpy(prevf, (unsigned char *) s);
X				prevg[a] = '\0';
X			}
X			else{
X				strcpy(prevg, (unsigned char *) s); prevg[3] = '\0';
X				strcpy(prevf, (unsigned char *) s);
X			}
X		}
X	}
X  }
X
X  if (locmod == 500) {
X	if (mode == '+') {
X		ok = 0;
X		
X		if(widerange == 0){
X			a = lastpoint( NG );
X			strcpy(prevg, (unsigned char *) NG);
X			prevg[a] = '\0';
X		}
X		else{
X			strcpy(prevg, (unsigned char *) NG);
X			prevg[3] = '\0';
X		}
X
X		while ((ok == 0) && (fscanf(fp, "%s %d %d %s", s, &a, &a, t) > 0)) {
X			l++;
X			if (strcomp(prevg, s) != 0) {
X				ok = 1;
X				strcpy(f, (unsigned char *) s);
X			}
X		}
X		if(ok == 0) line = -1;
X	}
X	if (mode == '-') {
X		strcpy(f, (unsigned char *) prevf);
X	}
X  }
X  else{
X	  if (mode == '+') {
X		if (fscanf(fp, "%s %d %d %s", f, &a, &a, t) < 1) {
X			if (ok == 0) {
X				rewind(fp);
X				fscanf(fp, "%s %d %d %s", f, &a, &a, t);
X			}
X		  	else {
X				line = -1;
X			}
X		}
X	  }
X	  if (mode == '-') {
X		if (f[0] == '\0') {
X			rewind(fp);
X			while (fscanf(fp, "%s %d %d %s", f, &a, &a, t) > 0);
X		}
X	  }
X  }	
X  fclose(fp);
X
X  if (max > 20) line = -1;
X
X  if ((line == -1) || (f[0] == '\0')) {
X	strcpy(BRETT, (unsigned char *) "PM");
X	printf("\n");
X	sprintf(NG, "%s.PM", USER.name);
X	sprintf(INHALT, "%s/usr/%d/INDEX", HOME, USER.id);
X	return;
X  }
X  if (l == 0) {
X	ansi("md");
X	printf(" %s\n", MIS01_MSG);
X	ansi("me");
X	return;
X  }
X  if (chk_newsgrp(f) != 0) {
X	sprintf(NG, "%s", f);
X	max++;
X	goto KEIN_ZUGRIFF;
X  }
X  brett(f);
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  schreiben()						   */
X/*  BESCHREIBUNG  Artikel fuer NEWS einlesen und verteilen. Die Distri-    */
X/*		  bution ist abhaengig von der NG und vom Userlevel.	   */
X/*     PARAMETER  arg = DUMMY (!)                                          */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid schreiben(arg)
Xunsigned char arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *fl;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char f[STRING];
X  unsigned char g[LSTRING];
X  unsigned char ex[255];
X  unsigned char cmdl[STRING];
X  unsigned char rep[STRING];
X  unsigned char subj[STRING];
X  unsigned char keyw[STRING];
X  unsigned char summ[STRING];
X  unsigned char from[STRING];
X  unsigned char msid[STRING];
X  unsigned char refs[STRING];
X  unsigned char tmp[STRING];
X  unsigned char ng[STRING];
X  unsigned char reply[STRING];
X  unsigned char group[STRING];
X  unsigned char newsgroups[STRING];
X  unsigned char distribution[STRING];
X  unsigned char followup[STRING];
X  unsigned char expires[STRING];
X  unsigned char ctrl[STRING];
X  unsigned char sender[STRING];
X  unsigned char approved[STRING];
X  unsigned char content[STRING];
X  unsigned char iam[STRING];
X  unsigned char username[STRING];
X
X  int i, a, b, ok;
X  int app;
X
X  unsigned char protokoll = 0;
X  unsigned char c;
X  unsigned char lf;
X
X  int BINFILE;
X
X  struct stat fst;
X
X  unsigned char pubdir[STRING];
X  long tdummy;
X  long tn, ts;
X
X  if (strcomp(BRETT, "PM") == 0) {
X	ansi("md");
X	printf(" <- \"%s.PM\" %s\n\n", USER.name, MIS02_MSG);
X	ansi("me");
X	return;
X  }
X  BINFILE = 0;
X
X
X  i = 0;				/* Vorname.Name */
X  strcpy(ng, USER.name);
X  while (ng[i] != '\0') {
X	if (ng[i] == ' ') ng[i] = '.';
X	i++;
X  }
X  strcpy(username, ng);
X
X  strcpy(group, NG);
X
X
X  umask(0000);
X
X  if (arg[0] == '\0') {
X
X	subj[0] = '\0';
X	keyw[0] = '\0';
X	from[0] = '\0';
X	msid[0] = '\0';
X	summ[0] = '\0';
X	refs[0] = '\0';
X
X	sprintf(rep, "%s/%dRep", TMP, getpid());
X
X	fp = fopen(rep, "r");
X	if (fp != NULL) {		/* REPLY */
X		while ((fgets(s, 80, fp) != NULL) && (strlen(s) > 2)) {
X			if (strcomp("Subject:", s)   == 0) {
X				strcat(subj, strcopy(s, 8, 79));
X				strcpy(subj,  (unsigned char *) stripped(subj));				
X			}
X			if (strcomp("From:", s)      == 0) {
X				from[0] = '\0';
X				strcat(from, strcopy(s, 6, 79));
X				strcpy(from,  (unsigned char *) stripped(from));
X			}
X			if (strcomp("Reply-To:", s)  == 0) {
X				from[0] = '\0';
X				strcat(from, strcopy(s, 10, 79));
X				strcpy(from,  (unsigned char *) stripped(from));
X			}
X			if (strcomp("Keywords:", s)  == 0) {
X				strcat(keyw, strcopy(s, 10, 79));
X				strcpy(keyw,  (unsigned char *) stripped(keyw));
X			}
X			if (strcomp("Summary:", s)   == 0) {
X				strcat(summ, strcopy(s, 9, 79));
X				strcpy(summ,  (unsigned char *) stripped(summ));
X			}
X			if (strcomp("Message-ID:", s) == 0) {
X				strcat(msid, strcopy(s, 11, 79));
X				strcpy(msid,  (unsigned char *) stripped(msid));
X			}
X			if (strcomp("Content-Type:", s) == 0) {
X				strcat(content, strcopy(s, 14, 79));
X				strcpy(content,  (unsigned char *) stripped(content));
X			}
X			if (strcomp("Article-I.D.:", s) == 0) {
X				strcat(msid, strcopy(s, 13, 79));
X				strcpy(msid,  (unsigned char *) stripped(msid));
X			}
X			if (strcomp("References:", s) == 0) {
X				strcat(refs, strcopy(s, 12, 79));
X				strcpy(refs,  (unsigned char *) stripped(refs));
X			} 
X			if (strcomp("Followup-To:", s) == 0) {
X				strcpy(group, strcopy(s, 13, 79));
X				strcpy(group, (unsigned char *) stripped(group));
X			}
X		}
X		
X		if(strcomp("Poster", group) == 0){
X			printf(" <- %s\n", MIS02aMSG);
X			return;
X		}
X
X
X		sprintf(t, "%s/A%d", TMP, getpid());
X		ff = fopen(t, "w");
X
X		a = 0;
X		b = 0;
X		i = 0;
X		while (from[i] != '\0') {
X			if (from[i] == '(') a = i + 1;
X			if (from[i] == ')') b = i - 1;
X			i++;
X		}
X		if (a < b) {
X			strcpy(s, (unsigned char *) strcopy(from, a, b));
X			strcpy(from, (unsigned char *) s);
X		}
X		sprintf(ex, "In article %s,\n            %s writes:\n\n", msid, from);
X		fputs(ex, ff);
X		while (fgets(s, 80, fp) != NULL) {
X			if(s[0] != '\n') fputs("> ", ff);
X			fputs((unsigned char *) iso_line(s), ff);
X		}
X		fclose(fp);
X		fclose(ff);
X
X		sprintf(cmdl, "%s %s", EDDY, t);
X		printf("\n\n");
X		system(cmdl);
X		if (strcomp("Re:", subj) != 0) {
X			sprintf(f, "Re: %s", stripped(subj));
X			strcpy(subj, (unsigned char *) f);
X		}
X		unlink(rep);
X	}
X	else {		/* Interactive MAIL */
X
X		printf("\n\n%c", CR);
X		ansi("mr");
X		printf("%s", MIS03_MSG);
X		ansi("me");
X		printf(" %s (%s)\n%c", USER.name, USER.nick, CR);
X		ansi("mr");
X		printf("%s", MIS04_MSG);
X		ansi("me");
X		printf(" %s\n%c", NG, CR);
X		ansi("mr");
X		printf("%s", MIS05_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(subj, (unsigned char *) getline(57, -11, '.', ""));
X		printf("\n");
X		ansi("mr");
X		printf("%s", MIS06_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(keyw, (unsigned char *) getline(57, -11, '.', ""));
X		printf("\n");
X		ansi("mr");
X		printf("%s", MIS07_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(summ, (unsigned char *) getline(57, -11, '.', ""));
X
X		printf("\n\n");
X		ansi("mr");
X		printf("[%s] %s ? > ", NG, MIS08_MSG);
X		ansi("me");
X		printf("%c%c", MIS09_MSG, BS);
X
X		do {
X			c = getint();
X			if (c >= 97) c -= 32;
X			if (c == '?') {
X				clearline();
X				ansi("mr");
X				printf("%c%s > ", CR, MIS12_MSG);
X				ansi("me");
X			}
X			if (c == ENTER) c = MIS09_MSG;
X			if ((c != MIS09_MSG) && (c != MIS10_MSG) && (c != MIS11_MSG)) c = 0;
X		} while (c == 0);
X
X		printf("%c", c);
X
X		if (c == MIS11_MSG) {
X			printf("\n");
X			unlink(t);
X			return;
X		}
X		if (c == MIS10_MSG) {
X			printf("%c                                                                       ", CR);
X			ansi("mr");
X			printf("%c%s, ? > ", CR, MIS13_MSG);
X			ansi("me");
X
X			do {
X				protokoll = getint();
X				if (protokoll >= 97) protokoll -= 32;
X				if (protokoll == '?') {
X					clearline();
X					ansi("mr");
X					printf("%c%s > ", CR, MIS14_MSG);
X					ansi("me"); 
X				}
X				if ((protokoll != MIS15_MSG) && (protokoll != MIS15_MSG) &&
X				    (protokoll != MIS18_MSG) && (protokoll != MIS17_MSG ))
X					protokoll = 0;
X			} while (protokoll == 0);
X
X			printf("%c", protokoll);
X
X		}
X		sprintf(tmp, "%s/A%d", TMP, getpid());
X		sprintf(cmdl, "%s %s", EDDY, tmp);
X		sprintf(pubdir, "%s/dir%d", TMP, getpid());
X
X		if (c == MIS09_MSG) {
X			noctrlx();
X			system(cmdl);
X			ctrlx();
X			protokoll = '*';
X		}
X		else {	/* UPLOAD */
X
X			printf("\n\n");
X			ansi("md");
X			printf("%s", MIS19_MSG);
X			ansi("me");
X
X			switch (protokoll) {
X			    case MIS15_MSG:
X					fp = fopen(tmp, "w");
X					if (fp == NULL) {
X						nerror("misc.c", 310, "schreiben", "DSF", tmp);
X					}
X					c = 0;
X					lf = CR;
X					fputc(LF, fp);
X
X					while ((c != CTRL_X) && (c != CTRL_D)) {
X						c = getint();
X						if ((c == CR) && (lf == CR))
X							fputc(LF, fp);
X						if (c == CR) lf = CR;
X						if (c == LF) lf = LF;
X						if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X							fputc(c, fp);
X						}
X					}
X					fclose(fp);
X					break;
X			    case MIS16_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -bc TimeTravelAgency 2> /dev/null", RX);
X					break;
X			    case MIS17_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -b 2> /dev/null", RB);
X					break;
X			    case MIS18_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -b 2> /dev/null", RZ);
X					break;
X			}
X			if (protokoll != MIS15_MSG){
X				mkdir( pubdir, 0777 );
X				chdir( pubdir );
X
X				time(&ts);
X				system( s );
X				time(&tn); tn = tn - ts;
X				tn -= 10;  /* 10 = "Toleranz" */
X	
X				chdir( HOME );
X				sprintf(s, "mv %s/* %s", pubdir, tmp);
X				system( s );
X				sprintf(s, "rm -r %s", pubdir);
X				system( s );
X			}
X			sync();
X			stat(tmp, &fst);
X			if (fst.st_size < 3L) {
X				printf("\n\n%s\n", MIS20_MSG);
X				control(MIS21_MSG, 3);
X				unlink(tmp);
X				return;
X			}
X			if (prf(tmp) == 1) {
X				if (strcomp(PDNG, NG) == 0) {
X					USER.upratio += ((long) fst.st_size / 1024);
X				}
X				BINFILE++;
X				sprintf(s, MIS22_MSG);
X			}
X			else{
X				mkix(tmp);
X				sprintf(s, MIS23_MSG);
X			}
X			ansi( "md" );
X			printf("\n\n%ld %s %s %s.\n", fst.st_size, MIS24_MSG, s, MIS25_MSG);
X			ansi( "me" );
X			if(tn < 1) tn = 1L;
X			printf("%s %d cps (ca. %d bps).", MIS26_MSG,
X				(fst.st_size / tn), ((fst.st_size / tn) * 11));				
X		}
X	}
X
X	sprintf(iam, "%s <%s@%s>", USER.name, username, UUCPID);
X	sprintf(reply, "%s@%s (%s)", username, UUCPID, USER.name);
X	strcpy(newsgroups, group);
X	if (USER.level < WRITE_EX_LEV) {
X		strcpy(distribution, "local");
X	}
X	else {
X		/*
X		strcpy(ng, NG);
X		i = 0;
X		while ((ng[i] != '.') && (ng[i] != '\0')) i++;
X		ng[i] = '\0';
X		strcpy(distribution, ng);
X		*/
X		strcpy(distribution, "world");
X	}
X	if(refs[0] != '\0') strcat(refs, " ");
X	strcat(refs, msid);	
X	followup[0] = '\0';
X	sender[0] = '\0';
X	ctrl[0] = '\0';
X	expires[0] = '\0';
X	approved[0] = '\0';
X	app = 0;
X	content[0] = '\0';	
X
X#if defined(_MULTIMEDIA) && defined(_UMLAUT)
X	strcpy(content, (unsigned char *) "text/plain; charset=iso-8859-1");
X#endif
X
X	ONCE_MORE:
X
X	printf("\n\n");
X	ansi("mr");
X	if(BINFILE == 0){
X		printf("[%s] %s, ? > ", NG, MIS27_MSG);
X	}
X	else{
X		printf("[%s] %s, ? > ", NG, MIS28_MSG);
X	}
X	ansi("me");
X	printf("%c%c", MIS29_MSG, BS);
X
X	do {
X		c = getint();
X		if (c >= 97) c -= 32;
X		if (c == '?') {
X			clearline();
X			ansi("mr");
X			if(BINFILE == 0){
X				printf("%c%s > ", CR, MIS32_MSG);
X			}
X			else{
X				printf("%c%s > ", CR, MIS33_MSG);
X			}
X			ansi("me");
X		}
X		if (c == ENTER) c = MIS29_MSG;
X		if ((c != MIS29_MSG) && (c != MIS30_MSG) && (c != MIS31_MSG) && (c != MIS31aMSG)) c = 0;
X	} while (c == 0);
X
X	printf("%c", c);
X	if (c == MIS30_MSG) {
X		unlink(f);
X		unlink(s);
X		unlink(t);
X		unlink(tmp); /* ??? */
X		unlink(rep);
X		printf("\n");
X		return;
X	}
X	if ((c == MIS31_MSG) && (BINFILE == 0)) {
X		noctrlx();
X		system(cmdl);
X		ctrlx();
X		goto ONCE_MORE;
X	}
X	if (c == MIS31aMSG) { /* HEADER */
X		headline( MIS38aMSG );
X		printf("\n");
X		time(&tdummy);
X
X		ansi( "md" );
X		printf("From: ");
X		ansi( "me" );
X		if(USER.level > ADMIN_LEV){
X			strcpy(s, (unsigned char *) getline(80, -1001, 32, iam));
X			if(strcomp(s, iam) != 0) app++;			
X			if(s[0] != '\0') strcpy(iam, s);
X			printf("\n");
X		}
X		else printf("%s\n", iam);
X
X		ansi( "md" );
X		printf("Reply-To: ");
X		ansi( "me" );
X		if(USER.level > GUEST_LEV){
X			strcpy(reply, (unsigned char *) getline(80, -1001, 32, reply));
X			printf("\n");
X		}
X		else printf("%s\n", reply);
X
X		ansi( "md" );
X		printf("Sender: ");
X		ansi( "me" );
X		if(USER.level >= ADMIN_LEV){
X			strcpy(sender, (unsigned char *) getline(80, -1001, 32, sender));
X			printf("\n");
X		}
X		else printf("%s\n", sender);	
X		
X		ansi( "md" );
X		printf("Control: ");
X		ansi( "me" );
X		if(USER.level >= ADMIN_LEV){
X			strcpy(ctrl, (unsigned char *) getline(80, -1001, 32, ctrl));
X			printf("\n");
X		}
X		else printf("%s\n", ctrl);	
X		
X		ansi( "md" );
X		printf("Approved: ");
X		ansi( "me" );
X		if(app != 0) sprintf(approved, "%s <%s@%s>", USER.name, username, UUCPID);
X		if(USER.level >= EXE_LEV){
X			strcpy(approved, (unsigned char *) getline(80, -1001, 32, approved));
X			printf("\n");
X		}
X		else printf("%s\n", approved);	
X	
X		ansi( "md" );
X		printf("Newsgroups: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_EX_LEV){
X			strcpy(newsgroups, (unsigned char *) getline(80, -1001, 32, newsgroups));
X			printf("\n");
X			i = 0;
X			while(newsgroups[i] != '\0'){
X				if(newsgroups[i] == ' '){
X					strcpy(s, (unsigned char *) newsgroups);
X					newsgroups[i] = '\0';
X					strcat(newsgroups, (unsigned char *) strcopy(s, (i+1), 80));
X					i--;
X				}
X				i++;
X			}			
X		}
X		else printf("%s\n", newsgroups);	
X		
X		ansi( "md" );
X		printf("Distribution: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_INTERNAT){
X			strcpy(distribution, (unsigned char *) getline(80, -1001, 32, distribution));
X			printf("\n");
X		}
X		else printf("%s\n", distribution);	
X		
X		ansi( "md" );
X		printf("Followup-To: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_EX_LEV){
X			strcpy(followup, (unsigned char *) getline(80, -1001, 32, followup));
X			printf("\n");
X		}
X		else printf("%s\n", followup);	
X		
X		ansi( "md" );
X		printf("Subject: ");
X		ansi( "me" );
X		strcpy(subj, (unsigned char *) getline(80, -1001, 32, subj));
X
X		ansi( "md" );
X		printf("\nKeywords: ");
X		ansi( "me" );
X		strcpy(keyw, (unsigned char *) getline(80, -1001, 32, keyw));
X			
X		ansi( "md" );
X		printf("\nSummary: ");
X		ansi( "me" );
X		strcpy(summ, (unsigned char *) getline(80, -1001, 32, summ));
X
X#ifdef _MULTIMEDIA
X
X		if(USER.level >= WRITE_INTERNAT){
X			if(content[0] == '\0')
X				strcpy(content, (unsigned char *) "text/plain; charset=us-ascii");
X			ansi( "md" ); 
X			printf("\nContent-Type: ");
X			ansi( "me" );
X			strcpy(content, (unsigned char *) getline(80, -1001, 32, content));
X		}
X#endif
X
X		ansi( "md" );
X		printf("\nX-News-Reader: ");
X		ansi( "me" );
X	        printf("%s %s %s\n", VERSION, PATCHLEVEL, AUTOR);
X
X		ansi( "md" );
X		printf("References: ");
X		ansi( "me" );
X		printf("%s\n", refs);
X		
X		ansi( "md" );
X		printf("Message-ID: ");
X		ansi( "me" );
X		printf("<%x.%d@%s>\n", tdummy, USER.id, UUCPID);
X		
X		ansi( "md" );
X		printf("Expires: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_INTERNAT){
X			strcpy(expires, (unsigned char *) getline(80, -1001, 32, expires));
X			printf("\n");
X		}
X		else printf("%s\n", expires);	
X
X		goto ONCE_MORE;		
X	}
X
X	ansi( "md" );
X	printf("\n\n%s\n", MIS34_MSG);
X	ansi( "me" );
X
X	sprintf(f, "%s/A%d", TMP, getpid());
X	sprintf(t, "%s/B%d", TMP, getpid());
X
X	fp = fopen(f, "r");
X	if (fp == NULL) {
X		printf("\n");
X		ansi("md");
X		printf("%s ...\n", MIS35_MSG);
X		ansi("me");
X		control(MIS36_MSG, 3);
X		unlink(rep);
X		return;
X	}
X
X	ff = fopen(t, "w");
X
X	time(&tdummy);
X
X	fprintf(ff, "From: %s\n", iam);
X	if(reply[0] != '\0')
X		fprintf(ff, "Reply-To: %s\n", reply);
X	if(sender[0] != '\0')
X		fprintf(ff, "Sender: %s\n", sender);
X	if(approved[0] != '\0')
X		fprintf(ff, "Approved: %s\n", approved);
X	if(newsgroups[0] != '\0')
X		fprintf(ff, "Newsgroups: %s\n", newsgroups);
X	if(distribution[0] != '\0')
X		fprintf(ff, "Distribution: %s\n", distribution);
X	if(ctrl[0] != '\0')
X		fprintf(ff, "Control: %s\n", ctrl);
X	if(followup[0] != '\0')
X		fprintf(ff, "Followup-To: %s\n", followup);
X	if(subj[0] != '\0')
X		fprintf(ff, "Subject: %s\n", subj);
X	if(keyw[0] != '\0')
X		fprintf(ff, "Keywords: %s\n", keyw);
X	if(summ[0] != '\0')
X		fprintf(ff, "Summary: %s\n", summ);
X	if(content[0] != '\0'){
X		fprintf(ff, "Content-Type: %s\n", content);
X#ifdef _UMLAUT
X		fprintf(ff, "Content-Transfer-Encoding: 8bit\n");
X#endif
X	}
X	fprintf(ff, "X-News-Reader: %s %s %s\n", VERSION, PATCHLEVEL, AUTOR);
X	fprintf(ff, "Message-ID: <%x.%d@%s>\n", tdummy, USER.id, UUCPID);
X	if(expires[0] != '\0')
X		fprintf(ff, "Expires: %s\n", expires);
X	if(refs[0] != '\0')
X		fprintf(ff, "References: %s\n", refs);	
X	fputs("\n", ff);	
X	
X	if (BINFILE == 0) {
X		UMLAUT_MODUS = 1;
X		while (fgets(s, 80, fp) != 0) {
X			fputs((unsigned char *) iso_line(s), ff);
X		}
X	}
X	else {
X		time(&tdummy);
X		fputs("BINFILE\n", ff);
X		sprintf(s, "%s/PD.%d", BRETT, tdummy);
X		fputs(s, ff);
X		sprintf(f, "cp %s %s &", tmp, s);
X		system(f);
X		sprintf(s, "\n/public/pd/%s\n", subj);
X		fputs(s, ff);
X		fl = fopen( PDSCRIPT, "a" );
X		fprintf(fl, "mv %s/PD.%d /public/pd/%s\n", BRETT, tdummy, subj);
X		fclose(fl);
X	}
X	fclose(fp);
X	unlink(f);
X
X	unlink(rep);
X
X	if ((USER.level > WRITE_IN_LEV) && (BINFILE == 0)) {
X		sprintf(s, "%s/usr/%d/.signature", HOME, USER.id);
X		fp = fopen(s, "r");
X		if (fp != NULL) {
X			while (fgets(s, 80, fp) != 0) {
X				fputs((unsigned char *) iso_line(s), ff);
X			}
X			fclose(fp);
X		}
X	}
X	fclose(ff);
X
X	UMLAUT_MODUS = USER.schluessel[2];
X
X	sprintf(ex, "/bin/sh ./etc/inews.sh %s %s", NG, t);
X	system(ex);
X
X	unlink(t);
X
X	sprintf(s, "%s \"%s\" %s", MIS37_MSG, NG, MIS38_MSG);
X	control(s, 3);
X
X	
X	if(BINFILE != 0){
X		maybe_locked(NGROUPS, "r");
X		fp = fopen(NGROUPS, "r");
X		if (fp == NULL) {
X			nerror("misc.c", 895, "schreiben", "Datei-Lesefehler", NGROUPS);
X		}
X
X		ok = 0;
X
X	        while ((ok == 0) && (fscanf(fp, "%s %d %d %s", s, &a, &b, f) > 0)) {
X			if(strcomp(NG, s) == 0){
X				i = a;
X				ok = 1;
X			}
X	 	}
X		fclose(fp);
X
X		fl = fopen( PDSCRIPT, "a" );
X		fprintf(fl, "mined %s/%d\n", BRETT, i); 
X		fprintf(fl, "#%s   %s\n\n", NG, USER.name);
X		fclose(fl);
X	}
X
X	printf("%s", MIS39_MSG);
X
X#ifndef _SYS7
X	sleep(30);	/* Scheinbar laeuft INEWS bei SYSV im Hintergrund */
X#endif
X
X	sprintf(s, "%s %s", MB_DAEMON, group);
X	system(s);
X	unlink(tmp);
X	printf("\n");
X  }
X  else {
X	ansi("md");
X	printf(" %s\n\n", MIS40_MSG);
X	ansi("me");
X  }
X  umask(0007);
X
X  /*			  
X
X  Better not use the following! It's a not yet complete implemented
X  new feature - the beginning of a threated NEWSREADER...
X
X  sprintf(s, "%s/usr/%d/.dis", HOME, USER.id);
X  fp = fopen(s, "a");
X  fprintf(fp, "%-32.32s %-21.21s  %x.%d  %s\n", NG, subj, tdummy, USER.id, (unsigned char *) mydate( 0 )); 
X  fclose(fp);
X  */  
X
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  prf()							   */
X/*  BESCHREIBUNG  Stellt fest, ob eine Datei (die per UPLOAD empfangen     */
X/*		  wurde) einen Text oder ein ausfuehrbares Programm ent-   */
X/*		  haelt.                                                   */
X/*     PARAMETER  arg  =  Dateiname                                        */
X/*     RUECKGABE  0    =  Text-Datei                                       */
X/*		  1    =  Ausfuehrbares Programm			   */
X/***************************************************************************/
X
Xint prf(arg)
Xunsigned char arg[];
X{
X  FILE *fp;
X  unsigned char ex[255];
X  int i, a;
X
X  fp = fopen(arg, "r");
X  if (fp == NULL) return -1;
X  while ((fgets(ex, 250, fp) != NULL) && (strlen(ex) < 30));
X  fclose(fp);
X
X  i = 0;
X  a = 0;
X  while (ex[i] != '\0') {
X	if ((ex[i] < 32) || (ex[i] > 127)) a++;
X	i++;
X  }
X  if (a > 3) return 1;		/* BINFILE */
X
X  return 0;			/* TEXTFILE */
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  pruefe()	 					   */
X/*  BESCHREIBUNG  Stellt fest, ob eine Datei aus den News-Artikeln die     */
X/*		  Kennung "BINFILE" enthaelt. Faellt die Antwort positiv   */
X/*		  aus, wird die Routine "pd()" aufgerufen.		   */
X/*     PARAMETER  arg  =  Nummer des Artikels                              */
X/*     RUECKGABE  0    =  Text-Datei                                       */
X/*                1    =  BINFILE					   */
X/***************************************************************************/
X
Xint pruefe(arg)
Xunsigned char arg[];
X{
X  FILE *fp;
X  unsigned char ex[255];
X  unsigned char s[STRING];
X  unsigned char entry[STRING];
X  unsigned char keywds[STRING];
X
X  if ((arg[0] == '\0') || (arg[0] == '*')) return -1;
X
X  if (strcomp(BRETT, "PM") != 0) {
X	sprintf(entry, "%s/%s", BRETT, arg);
X  }
X  else {
X	sprintf(entry, "%s/usr/%d/%s", HOME, USER.id, arg);
X  }
X
X  keywds[0] = '\0';
X
X  fp = fopen(entry, "r");
X  if (fp == NULL) return -1;
X
X  while ((fgets(ex, 250, fp) != NULL) && (ex[0] > 32)){
X	if(strcomp("Keywords: ", ex) == 0){
X		ex[80] = '\0';
X		strcpy(keywds, strcopy(ex, 10, 80));
X	}
X  }
X
X  while ((fgets(ex, 250, fp) != NULL) && (ex[0] < 32));
X
X  if (strcomp("BINFILE", ex) == 0) {
X	fgets(s, 80, fp);
X	fclose(fp);
X	pd(s, keywds);
X	return 1;
X  }
X  fclose(fp);
X
X  return 0;
X}
X
X
X
X
X
X
END_OF_FILE
  if test 23300 -ne `wc -c <'src/misc.c'`; then
    echo shar: \"'src/misc.c'\" unpacked with wrong size!
  fi
  # end of 'src/misc.c'
fi
if test -f 'src/uptodate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/uptodate.c'\"
else
  echo shar: Extracting \"'src/uptodate.c'\" \(2961 characters\)
  sed "s/^X//" >'src/uptodate.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*          PROGRAMM  ix/Mbox                                              */
X/*             DATEI  update.c                                             */
X/*        FUNKTIONEN  uptodate()                                           */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)                 */
X/*  LETZTE AENDERUNG  16.03.1993                                           */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X/*
X	WARNING! This part of the ix/MBox automagically generates an
X        update-request every month. This request is sent to "unnet!mbox"
X        in germany.
X
X        If there are any bugfixes, infosheets etc., you'll get them
X        via mailserver as an reply to the update-request.
X
X        The update-request includes some informations about your BBS:
X        name, uucp-address, sysops name, number of accounts&caller etc. ...
X
X        Maybe this data will be used to build reference-lists or will
X        be mentioned in infosheets.
X
X 
X        If you don't want|like that, please change the following
X        defines!!! 
X*/
X
X#define NO_UPDATE	0	/* 1 means: absolutly no update-requests */
X#define NO_DETAILS	0	/* 1 means: don't send any data	         */
X
X
X
Xuptodate()
X{
X
X#if !NO_UPDATE
X
X  FILE *fp;
X  
X  char s[STRING];
X  char t[STRING];
X  char d[STRING];
X
X  int accounts;
X  int calls;
X  int month;
X
X
X  if(USER.level < WRITE_EX_LEV) return;
X
X  strcpy(d, (unsigned char *) mydate( 1 ));
X  month = atoi(strcopy(d, 3, 4));
X  sprintf(s, "%s/etc/uptodate.%d", HOME, month);
X  fp = fopen(s, "r");
X  if(fp != NULL){
X	fclose(fp);
X	return;
X  }
X  fp = fopen(s, "w");
X  fprintf(fp, "Update requested: %s at %s", mydate( 1 ), mytime( 0 )); 
X  fclose(fp);
X
X  if(month == 1) month = 13;
X  month--;
X
X  sprintf(s, "%s/etc/uptodate.%d", HOME, month);
X  unlink( s );
X
X  sprintf(s, "%s/etc/users.seq", HOME);
X  fp = fopen(s, "r");
X  fgets(s, 80, fp);
X  fclose(fp);
X  accounts = atoi(s);
X
X  sprintf(s, "%s/etc/mbox.seq", HOME);
X  fp = fopen(s, "r");
X  fgets(s, 80, fp);
X  fclose(fp);
X  calls = atoi(s);
X
X  sprintf(s, "%s/usr/%d/.lastletter", HOME, USER.id);
X  fp = fopen(s, "w"); 
X  fprintf(fp, "This is %s %s, on <%s>!\n\n", VERSION, PATCHLEVEL, UUCPID1);
X
X#if !NO_DETAILS
X  fprintf(fp, "My sysop %s of %s\n", POSTMASTER, ORGANIZATION);
X  fprintf(fp, "wants update patches, infosheets and so on ...\n\n");
X  fprintf(fp, "Our systems' called \"%s\",\n", SYSTEM);
X  fprintf(fp, "and we joggle around with %d users (%d calls) at this moment.\n\n", accounts, calls);
X#endif /* NO_DETAILS */
X
X  fprintf(fp, "If you can't reach us, call <%s> or <%s> ...\n\n", UUCPID2, SMARTHOST);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X  fp = fopen(s, "w");
X  fprintf(fp, "UPDATE-RQ <%s>", UUCPID1);
X  fclose(fp);
X
X  brief( "mbox@unnet.w.open.DE?" );
X
X#endif	/* NO_UPDATE */
X
X}
X
END_OF_FILE
  if test 2961 -ne `wc -c <'src/uptodate.c'`; then
    echo shar: \"'src/uptodate.c'\" unpacked with wrong size!
  fi
  # end of 'src/uptodate.c'
fi
echo shar: End of archive 6 \(of 15\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
