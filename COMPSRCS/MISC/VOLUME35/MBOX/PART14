Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i049:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part14/15
Message-ID: <1993Feb5.190001.10879@sparky.imd.sterling.com>
X-Md4-Signature: 369faef603273dbbf1023fb86ccb8df7
Date: Fri, 5 Feb 1993 19:00:01 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 49
Archive-name: mbox/part14
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  FAQ etc/alias.sh etc/english.befehl etc/help.befehle
#   etc/mbox.packers etc/rmail.sh etc/sysinfo.U etc/xmd.alias rz.cdiff
#   src/CROSSREF src/HISTORY src/baudrate.c src/befehl.c src/bled.doc
#   src/derror.c src/dis.c src/getch.c src/help.c src/nerror.c
#   src/outdial.c wendy/echo.c wendy/english.hlp wendy/getch.c
#   wendy/wendy.h
# Wrapped by kent@sparky on Fri Feb  5 12:18:19 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 15)."'
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
  echo shar: Extracting \"'FAQ'\" \(2491 characters\)
  sed "s/^X//" >'FAQ' <<'END_OF_FILE'
XFAQs // ix/MBox BBS 1.6 PL10j7 // 25.01.1993
X
X
XQ: Why does the BBS 'core', when I try to start it the FIRST time?
XA: Maybe you've forgotten to 'make world' first?
X
XQ: Why does the BBS speak german?
XA: You have to 'make english' to get the english version.
X
XQ: Why doesn't the BBS report any boards with OLD articles?
XA: Type in 'mb-daemon all -x' and be patient ... (you have to be ROOT !)
X   Check your 'Boards'-Entry with the 'admin' command!
X
XQ: Why doesn't the BBS report any boards with NEW articles?
XA: Check your scanner-date. Use 'setup'!
X
XQ: Why do I always get problems if I try to mail or write something?
XA: It sounds like you've forgotten to use SETUID root.root for [mbox].
X
XQ: Why does the BBS terminate everytime I try to get in as ROOT?
XA: You've defined the ONE AND ONLY terminal, which ROOT may use, in
X   [mbox.h], do you remember??
X
XQ: Why do I never see new NEWS in the boards of BBS?
XA: Maybe you never start MB-DAEMON by cron!?
X
XQ: Why do I only get a few newsgroups instead of all?
XA: Use the command "admin" and choose "change user" option. There you'll
X   find a "newsgroups" entry. Delete the list of groups and just type "all"!
X
XQ: Why do I have trillions of mails in postmasters maildrop?
XA: You should start XMD by cron hourly!
X
XQ: Why does XMD crash instead of delivering mails?
XA: It has to be owned by 'root.root'!
X
XQ: Why seems MB-DAEMON to be sooooo slow?
XA: Spend a TMP-directory on the same FS as HOME|MBOXHOME!
X
XQ: Why do I get addresses like this in UUCP-Spoolfiles:
X   From: unnet!Volker.Schuermann@unnet.w.open.DE
XA: It's a problem with RMAIL. Have a look at README.addrpatch to fix it!
X
XQ: How can I include ELM etc. to the BBS command set?
XA: Check README, Section: User defined Commands!
X
XQ: Why does the BBS blow up, when I use C-NEWS?
XA: Maybe I haven't implemented the aliasing mechanism correct - please
X   tell me, how it works!
X
XQ: Is there any risk to loose one of my system-files?
XA: Yes, If you play around with MB-DAEMON, you may destroy [~/news/active]!
X   Be clever: Copy first, destroy later ;-)
X
XQ: Why does my SMAIL create a second Message-ID & Received-Field ?
XA: Just set the SMAIL-Flag "-received_field". To make live easier, append
X   the flag "error_copy_postmaster", too! 
X
XQ: It it possible to port the BBS to system XYZ?
XA: Just try it :-) If you've done so, send the DIFFs to me!
X
XQ: Are there any plans to develope further versions of this BBS?
XA: Surely! Join our Mailing-List to stay put - see README how to do that!
X
X
END_OF_FILE
  if test 2491 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
  fi
  # end of 'FAQ'
fi
if test -f 'etc/alias.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/alias.sh'\"
else
  echo shar: Extracting \"'etc/alias.sh'\" \(908 characters\)
  sed "s/^X//" >'etc/alias.sh' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  A L I A S . S H
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 08.12.1991
X#
X#---------------------------------------------------------------------------
X# Dieses Script fuegt einen Eintrag fuer jeden neuen User der ix/MBox an die
X# Alias-Datei von SMAIL (etc.) an und erzeugt einen neue Alias-Datenbank. 
X#
X# Wird UMAIL statt SMAIL verwendet, sollten alle Zeilen dieses Scripts' aus-
X# kommentiert werden.
X#---------------------------------------------------------------------------
X# Parameter:
X#
X# $1  ->  Name des neuen Users im Format "Vorname.Nachname"
X# 
X# Beispiel:
X#
X# echo $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X# /usr/bin/mkaliases
X
Xecho $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X#/usr/bin/mkaliases
END_OF_FILE
  if test 908 -ne `wc -c <'etc/alias.sh'`; then
    echo shar: \"'etc/alias.sh'\" unpacked with wrong size!
  fi
  # end of 'etc/alias.sh'
fi
if test -f 'etc/english.befehl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.befehl'\"
else
  echo shar: Extracting \"'etc/english.befehl'\" \(2169 characters\)
  sed "s/^X//" >'etc/english.befehl' <<'END_OF_FILE'
X/***************************************************************************/
X/* Please make changes to this file VERY wisely! Remember that you have to */
X/* list D(ir) before DA(te) and M(ail) before MA(cro) to stay conform with */
X/* GEONET etc. ...							   */
X/*								           */
X/*                 Description						   */
X/* ======================================================================= */
X/* ID            - Number of command (see 'loop.c')			   */
X/* Intern        - Need Userlevel X to execute the command		   */
X/* Extern        - Oldfashioned diff between int. & ext. access		   */
X/* Prototyp      - If this value is '1', the command is shown in helpfile  */
X/* Befehl        - That's the name of the command			   */
X/*									   */
X/*									   */
X/* NOTE: Leave ONE blank line between this comment-box and the ID-Line!    */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X260	0	0	1	Account
X125	9	9	0	Admin
X460	0	0	1	Area
X150	0	0	1	Board
X170	0	0	1	Chat
X200	0	0	1	Dir
X370	0	0	1	Date
X220	1	1	1	Delete
X440	0	0	1	Download
X150	0	0	0	Cd
X490  	0	0	1	Discussion
X400     0       0       1       Direction
X180	0	0	0	End
X480  	1	1	1	Edit
X300	1	1	1	Finger
X340	1	1	1	Forward
X390 	0	0	1	Games
X180	0	0	1	Goodbye
X180	0	0	0	Quit
X180	0	0	0	Bye
X190	0	0	1	Help
X160	0	2	1	Mail
X330     0       0       1       Macro
X140	0	0	1	Message
X240	6	6	1	Minix
X510	9	9	1	Monitor
X240	6	6	0	Execute
X450 	7	7	0	Outdial
X270	0	0	1	Portinfo
X130	0	0	1	Protocol
X250	0	0	1	PM
X210	0	0	1	Read
X280	0	0	1	Setup
X470	0	0	1	Sysinfo
X280	0	0	0	Password
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Address
X310	1	0	1	Signature
X290	0	0	1	State
X410     0       0       1       Statistics
X430     1       1       1       Search
X380	0	0	1	Time
X300	0	0	1	Users
X320	0	0	1	Version        
X230	0	5	1	Write
X270	0	0	0	Who
X420	0	0	0	RING
X195	0	1	0	~PD
X215	0	0	0	Level
X275	9	9	0	Relogin
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X230     0       5       1       Upload
X180     0       0       0       RING
X998	2	2	0	~MAIL_DUMMY
END_OF_FILE
  if test 2169 -ne `wc -c <'etc/english.befehl'`; then
    echo shar: \"'etc/english.befehl'\" unpacked with wrong size!
  fi
  # end of 'etc/english.befehl'
fi
if test -f 'etc/help.befehle' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.befehle'\"
else
  echo shar: Extracting \"'etc/help.befehle'\" \(2904 characters\)
  sed "s/^X//" >'etc/help.befehle' <<'END_OF_FILE'
X/***************************************************************************/
X/* Wer diese Datei aendert sollte GENAU wissen was er tut. Die Reihen-     */
X/* folge der Befehle ist NICHT willkuerlich festgelegt worden, sondern     */
X/* entspricht der Vorgabe fuer GEOnet-Befehle und deren Abkuerzungen.      */
X/*									   */
X/* S(chreiben) kommt vor SE(tup) und L(esen) vor LOE(schen) etc. ... wer   */
X/* sich nicht voellig sicher ist, sollte die Datei einfach im Urzustand    */
X/* belassen.								   */
X/*								           */
X/*                 Die Bedeutung der versch. Spalten 			   */
X/* ======================================================================= */
X/* ID            - Nummer des Befehls (siehe "loop()")			   */
X/* Intern        - Benoetigtes Userlevel				   */
X/* Extern        - Bei einigen Befehle wird unterscheiden zwischen intern  */
X/*		   und extern. Z.B. beim Befehl "schreiben" wird diese     */
X/*		   Regelung angewendet, damit User zwar an die lokalen     */
X/*		   Bretter senden duerfen, nicht aber an die externen.     */
X/* Prototyp      - Enthaelt diese Spalte eine '1', wird der Befehl bei der */
X/*		   Befehlsuebersicht angezeigt.				   */
X/* Befehl        - Unter diesem Namen wird der Befehl aufgerufen           */
X/*									   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Ueberschrift EINE Leerzeile einfuegen ! */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X130	0	0	1	Anrufer
X140	1	0	1	Ansage
X150	0	0	1	Brett
X160	0	2	1	Brief
X170	0	0	1	Chat
X490	0	0	1	Diskussion
X170	0	0	0	Dialog
X370	0	0	0	Datum
X170	0	0	0	Co
X999	0	0	1	Demo
X440     0       0       1       Download
X210	0	0	1	Lesen
X480	1	1	1	Edit
X180	0	0	1	Ende
X180	0	0	0	Quit
X180	0	0	0	Log
X460	0	0	0	Area
X460	0	0	1	Gruppe
X180	0	0	0	Goodbye
X190	0	0	1	Hilfe
X195	0	1	0	~PD
X200	0	0	1	Inhalt
X200	0	0	0	Dir
X205	0	0	0	Id
X215	0	0	0	Level
X220	1	1	1	Loeschen
X330     0       0       1       Makro
X240	8	8	1	Minix
X510	9	9	1	Monitor
X240	8	8	0	Execute
X450	1	1	1	Outdial
X450	1	1	0	Od
X270	0	0	1	Portinfo
X270	0	0	0	Who
X270	0	0	0	Wer
X260	0	0	1	Postfach
X260	0	0	0	Antrag
X275	9	9	0	Relogin
X400     0       0       1       Richtung
X230	0	5	1	Schreiben
X280	0	0	1	Setup
X390 	0	0	1	Spiele
X430	1	1	1	Suchen
X470	0	0	1	Sysinfo
X280	0	0	0	Passwort
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Anschrift
X290	0	0	1	Status
X410     0       0       1       Statistik
X300	0	0	1	User
X310	1	0	1	Unterschrift
X230     0       5       1       Upload
X500	0	0	1	Umlaut
X320	0	0	1	Version        
X340	1	1	1	Weiterleiten
X380	0	0	0	Zeit
X125	9	9	0	Admin
X130	0	0	0	Protokoll
X250	0	0	1	PM
X150	0	0	0	Cd
X300	0	0	0	Finger
X160	0	2	0	Mail
X180	0	0	0	Quit
X180	0	0	0	Exit
X180	0	0	0	Logout
X420	0	0	0	RING
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X998	7	7	0	~MAIL_DUMMY
END_OF_FILE
  if test 2904 -ne `wc -c <'etc/help.befehle'`; then
    echo shar: \"'etc/help.befehle'\" unpacked with wrong size!
  fi
  # end of 'etc/help.befehle'
fi
if test -f 'etc/mbox.packers' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/mbox.packers'\"
else
  echo shar: Extracting \"'etc/mbox.packers'\" \(798 characters\)
  sed "s/^X//" >'etc/mbox.packers' <<'END_OF_FILE'
X/***************************************************************************/
X/* In dieser Datei befindet sich eine Liste von Komprimieren und Archi-    */
X/* vierern ueber die Artikel im Download-Modus gepackt werden koennen.	   */
X/*									   */
X/* Packer	Kommando	     Befehl TAR-Archiv 	Endung		   */
X/* ======================================================================= */
X/* Compress4.3	/usr/bin/compress	?	+	  .Z		   */
X/* Lharc1.02	/usr/bin/lharc a	-a	-	  .lzh	   	   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Liste EINE Leerzeile einfuegen !	   */
X/***************************************************************************/
X
XCompress4.3	/usr/bin/compress	?	+	.Z
XLharc1.02	/usr/bin/lharc		a	-	.lzh
XZoo2.1		/usr/bin/zoo		-add	-	.zoo
XFreeze1.1	/usr/bin/freeze		?	+	.F
X
X
END_OF_FILE
  if test 798 -ne `wc -c <'etc/mbox.packers'`; then
    echo shar: \"'etc/mbox.packers'\" unpacked with wrong size!
  fi
  # end of 'etc/mbox.packers'
fi
if test -f 'etc/rmail.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/rmail.sh'\"
else
  echo shar: Extracting \"'etc/rmail.sh'\" \(993 characters\)
  sed "s/^X//" >'etc/rmail.sh' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  R M A I L . S H
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 08.12.1991
X#
X#---------------------------------------------------------------------------
X# Dieses Script uebergibt eine "persoenliche Mail" und eine Empfaenger-
X# Adresse an das Programm RMAIL. Die "persoenliche Mail" enthaelt bereits
X# einen (fast) kompletten Header !
X#
X# Bei Verwendung von SMAIL sollte "config.mbox" speziell fuer die Unter-
X# drueckung der SMAIL-Message-ID etc. konfiguriert werden.
X#---------------------------------------------------------------------------
X# Parameter:
X#
X# $1  ->  Name der Datei ("persoenliche Mail" s.o.)
X# $2  ->  Empfaenger der Mail
X# 
X# Beispiel:
X#
X# rmail -d -i $1 $2
X#
X# Oder:
X# 
X# smail -i -C /usr/local/lib/smail/config.mbox $2 < $1
X#
X# config.mbox ->
X# -recieved_field
X# copy_error_postmaster   
X
Xrmail -d -i $1 $2
END_OF_FILE
  if test 993 -ne `wc -c <'etc/rmail.sh'`; then
    echo shar: \"'etc/rmail.sh'\" unpacked with wrong size!
  fi
  # end of 'etc/rmail.sh'
fi
if test -f 'etc/sysinfo.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/sysinfo.U'\"
else
  echo shar: Extracting \"'etc/sysinfo.U'\" \(2646 characters\)
  sed "s/^X//" >'etc/sysinfo.U' <<'END_OF_FILE'
Xbegin 644 etc/sysinfo
XM0V]N=&5N="U4>7!E.B!T97AT+W)I8VAT97AT.R *1&EE<V4@36%I;&)O>"!L
XMA'5F="!A=68@96EN96T@,C @34AZ(#,X-F5R(&E.5$5,+5)E8VAN97(@;6ET
XM(&-A+B R-# @34(\;FP^"E!L871T96YK87!A>FETA'0@=6YD(#@@34(@2&%U
XM<'1S<&5I8VAE<BX\;FP^"CQN;#X*16EN9V5S971Z="!W:7)D(&1A<R!"971R
XM:65B<W-Y<W1E;2!-24Y)6"!I;B!D97(@,S@V97(@5F5R<VEO;BX@1&%S($UA
XM:6PM/&YL/@IB;WAP<F]G<F%M;2!I<W0@:7@O34)O>"P@96EN92!0<F]D=6MT
XM(&%U<R!D97(@4'5B;&EC($1O;6%I;BX\;FP^"CQN;#X*17,@=V5R9&5N('IW
XM96D@36]D96TM4&]R=',@86YG96)O=&5N.CQN;#X*/&YL/@I0;W)T,3H@55-2
XM;V)O=&EC<R!#;W5R:65R($A35" S,# M,3DN,FL@(" @,#(P,B @-#8R,3$T
XM/&YL/@I0;W)T,CH@1&EC;W9E<GD@,C0P,$,@(" @(" @(" S,# M,C0P," @
XM(" @,#(P,B @-#8V,#(S-#QN;#X*/&YL/@H\0V5N=&5R/CQ";VQD/BTM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM/"]";VQD/CPO0V5N=&5R/CQN;#X*/&YL
XM/@I/8G=O:&P@9&EE<V4@36%I;&)O>"!N:6-H="!K;VUM97)Z:65L;"!B971R
XM:65B96X@=VER9"P@<VEN9"!E:6YI9V4@9&5R/&YL/@IA;F=E8F]T96YE;B!$
XM:65N<W1E(&=E8H%H<F5N<&9L:6-H=&EG+CQN;#X*/&YL/@H)/$)O;&0^1T5"
XMFDA214Y&4D5)/"]";VQD/B!I<W0Z/&YL/@H\;FP^"@EO("!D:64@0F5N=71Z
XM='5N9R!D97(@36%I;&)O>#QN;#X*"6\@(&1A<R!P<FEV871E(%!O<W1F86-H
XM/&YL/@H);R @9&EE($YU='IU;F<@9&5R('9E<G-C:&EE;F1E;B!01"U!<F-H
XM:79E/&YL/B *"6\@(&1I92!P<FEV871E(%!O<W0@86X@5&5I;&YE:&UE<B!I
XM;FYE<FAA;&(@9&5S(%-50FYE=#QN;#X*"6\@(&1I92!496EL;F%H;64@86X@
XM9&5N($Y%5U,M1W)U<'!E;B B9&4N*B(\;FP^"CQN;#X*"3Q";VQD/D=%0II(
XM4D5.4$9,24-(5$E'/"]";VQD/B!I<W0Z/&YL/@H\;FP^"@EO("!D97(@/$)O
XM;&0^3U541$E!3#PO0F]L9#XM4V5R=FEC92 M(%9E<F)I;F1U;F<@>G4@36%I
XM;&)O>&5N/&YL/@H)(" @=6YD($1A=&5N8F%N:V5N(&EM($EN+2!U;F0@075S
XM;&%N9#QN;#X*"6\@(&1I92!P<FEV871E(%!O<W0@86X@5&5I;&YE:&UE<B!A
XM=7-S97)H86QB(&1E<R!354)N970\;FP^"@EO("!D:64@5&5I;&YA:&UE(&%N
XM(&1E;B!I;G1E<FYA=&EO;F%L96X@3D574RU'<G5P<&5N/&YL/B @( H\;FP^
XM(" @( I'96YA=65R92!);F9O<FUA=&EO;F5N('5N9"!A:W1U96QL92".;F1E
XM<G5N9V5N('=E<F1E;B!R96=E;&V$<W-I9R!I;3QN;#X*0G)E='0@)VQO8V%L
XM+G1A;&LG(&)E:V%N;G1G96=E8F5N+CQN;#X*/&YL/@H\0V5N=&5R/CQ";VQD
XM/BTM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM/"]";VQD/CPO0V5N=&5R/CQN
XM;#X*/&YL/@I$:64@1V5B@6AR96X@9G5E<B!D96X@:6YT97)N871I;VYA;&5N
XM($U!24PM('5N9"!.15=3+5IU9W)I9F8@8F5T<F%G96X\;FP^"G!R;R!1=6%R
XM=&%L+U5S97(@,3DN-3 @1$TN(%-I92!S:6YD(&%U9B!U;G1E;G-T96AE;F1E
XM<R!+;VYT;R!Z=2"!8F5R+3QN;#X*=V5I<V5N+CQN;#X*/&YL/@H)5F]L:V5R
XM(%-C:(%R;6%N;CQN;#X*"4MT;RX@-#$S,3,V,SQN;#X*"4)L>BX@,S,P(#4P
XM," P," O(%-T861T<W!A<FMA<W-E(%=U<'!E<G1A;#QN;#X*"3Q";VQD/E-4
XM24-(5T]25#PO0F]L9#X@(D%C8W0N(%5S97)N86UE(CQN;#X@(" @(" @"CQN
XM;#X*0FET=&4@9&%S(#Q";VQD/E-424-(5T]25#PO0F]L9#X@=6YB961I;F=T
XM(&%N9V5B96XL(&1A(&1I92!"=6-H=6YG('-O;G-T(&5V=&PN(&%L<SQN;#X*
XM4W!E;F1E(&=E=V5R=&5T('=I<F0A/&YL/@H\;FP^"CQ#96YT97(^/$)O;&0^
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2T\+T)O;&0^/"]#96YT97(^/&YL
X(/@H\;FP^"@HM
X 
Xend
END_OF_FILE
  if test 2646 -ne `wc -c <'etc/sysinfo.U'`; then
    echo shar: \"'etc/sysinfo.U'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'etc/sysinfo'\" \(1898 characters\)
    cat etc/sysinfo.U | uudecode
    if test 1898 -ne `wc -c <'etc/sysinfo'`; then
      echo shar: \"'etc/sysinfo'\" uudecoded with wrong size!
    else
      rm etc/sysinfo.U
    fi
  fi
  # end of 'etc/sysinfo.U'
fi
if test -f 'etc/xmd.alias' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/xmd.alias'\"
else
  echo shar: Extracting \"'etc/xmd.alias'\" \(1057 characters\)
  sed "s/^X//" >'etc/xmd.alias' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  X M D . A L I A S
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 15.02.1992
X#
X#---------------------------------------------------------------------------
X# In dieser Datei werden Empfaenger-Adressen und deren Alias gespeichert.
X#
X# Das Format der Eintraege ist folgendes:
X#
X# To: (1) Adresse, die per RMAIL uebertragen wurde
X# To: (2) Adresse, die innerhalb der ix/MBox verwendet werden soll
X# <LEERZEILE>
X# To: (1) etc.
X# To: (2) etc.
X# <LEERZEILE>
X#
X#---------------------------------------------------------------------------
X# Parameter: -keine-
X
XTo: Multiple recipients of <TEX-D-L@dearn.bitnet>
XTo: Christian.Boehm@unnet.w.open.DE
X
XTo: Multiple recipients of <TEX-D-L@DEARN.uucp>
XTo: Christian.Boehm@unnet.w.open.DE
X
XTo: Postmaster@unnet.w.open.DE
XTo: Volker.Schuermann@unnet.w.open.DE
X
XTo: Multiple recipients of list <386bsd-list@compuram.bbt.se>
XTo: Christian.Boehm@unnet.w.open.DE
X
X
END_OF_FILE
  if test 1057 -ne `wc -c <'etc/xmd.alias'`; then
    echo shar: \"'etc/xmd.alias'\" unpacked with wrong size!
  fi
  # end of 'etc/xmd.alias'
fi
if test -f 'rz.cdiff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rz.cdiff'\"
else
  echo shar: Extracting \"'rz.cdiff'\" \(1562 characters\)
  sed "s/^X//" >'rz.cdiff' <<'END_OF_FILE'
X*** rz.c~	Sat Aug 10 13:39:34 1991
X--- rz.c	Sat Aug 10 13:13:54 1991
X***************
X*** 1,6 ****
X--- 1,8 ----
X  #define VERSION "2.03 05-17-88"
X  #define PUBDIR "/usr/spool/uucppublic"
X  
X+ /* Unnet == Modified for ix/MBox-Use !!! */
X+ 
X  /*% cc -compat -M2 -Ox -K -i -DMD -DOMEN % -o rz; size rz;
X  <-xtx-*> cc386 -Ox -DMD -DOMEN -DSEGMENTS=8 rz.c -o $B/rz;  size $B/rz
X   *
X***************
X*** 390,395 ****
X--- 392,399 ----
X  {
X  	register c;
X  
X+ 	strcpy(Pathname, *argp); checkpath(Pathname);  /* Unnet */
X+ 
X  	if (Batch || argc==0) {
X  		Crcflg=1;
X  		if ( !Quiet)
X***************
X*** 432,439 ****
X  		pclose(fout);  return ERROR;
X  	}
X  #endif
X! 	if (fout)
X! 		fclose(fout);
X  #ifndef vax11c
X  	if (Restricted) {
X  		unlink(Pathname);
X--- 436,445 ----
X  		pclose(fout);  return ERROR;
X  	}
X  #endif
X! 	if (fout){
X! 		fflush(fout); /* Unnet */
X! 		fclose(fout);
X! 	}
X  #ifndef vax11c
X  	if (Restricted) {
X  		unlink(Pathname);
X***************
X*** 915,922 ****
X  register n;
X  {
X  	register char *p;
X! 	if (n == 0)
X! 		return OK;
X  
X  	if (Thisbinary) {
X  		for (p=buf; --n>=0; ) 	
X--- 921,931 ----
X  register n;
X  {
X  	register char *p;
X!                                                       
X! 	if (n == 0)
X! 		return OK;
X!        
X! 	if (fout == 0) fout = fopen( Pathname, "a" );     /* Unnet */
X  
X  	if (Thisbinary) {
X  		for (p=buf; --n>=0; ) 	
X***************
X*** 1436,1441 ****
X--- 1445,1451 ----
X  		return OK;
X  	}
X  #endif
X+ 	fflush(fout);  /* Unnet */
X  	if (fclose(fout)==ERROR) {
X  		fprintf(stderr, "file close ERROR\n");
X  		return ERROR;
END_OF_FILE
  if test 1562 -ne `wc -c <'rz.cdiff'`; then
    echo shar: \"'rz.cdiff'\" unpacked with wrong size!
  fi
  # end of 'rz.cdiff'
fi
if test -f 'src/CROSSREF' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/CROSSREF'\"
else
  echo shar: Extracting \"'src/CROSSREF'\" \(2465 characters\)
  sed "s/^X//" >'src/CROSSREF' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  CROSSREF						   */
X/*        FUNKTIONEN  Cross-Referenz-Liste der Funktionen		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  28.05.1992					   */
X/***************************************************************************/
X
Xadmin()				admin.c
Xansage()			lesen.c
Xansi()		 		tools.c
Xanzeigen()			lesen2.c
Xbaudrate()			baudrate.c
Xbef()				befehl.c
Xbrett()				misc2.c
Xbrief()				mail.c
Xbigcopy()			tools.c
Xcarboncopy()			weiterl.c
Xcheckdomaintype()		lesen.c
Xchk_newsgrp()			misc2.c
Xclearline()			tools.c
Xcontrol()			control.c
Xcrypted()			tools.c
Xctrlx()				ctrlx.c
Xcut_arg()			loop.c
Xcut_bef()			loop.c
Xdateconv()			tools.c
Xdatereconv()			tools.c
Xdownload()			pd.c
Xedit()				suchen.c
Xfaces()				faces.c
Xfetch_receipy()			misc2.c
Xfinger()			portinfo.c
Xfixoutput()			main.c
Xgames()				games.c
Xgetch()				getch.c
Xgetint()			getline.c
Xgetline()			getline.c
Xgetsite()			lesen.c
Xheadline()			tools.c
Xhelp()				help.c
Xinhalt2()			lesen2.c
Xinit()				main.c
Xinit_user()			intro.c
Xintro()				intro.c
Xisin()				tools.c
Xiso_convert()			show.c
Xiso_line()			show.c
Xlength()			tools.c
Xlesen()				lesen.c
Xlesen2()			lesen2.c
Xloeschen()			misc2.c
Xloeschen2()			lesen2.c
Xlogout()			main.c
Xloop()				loop.c
Xmain()				main.c
Xmaybe_locked()			tools.c
Xmblock()			tools.c
Xmbunlock()			tools.c
Xmore()				more.c
Xmkix()				pd.c
Xmydate()			tools.c
Xmytime()			tools.c
Xnerror()			nerror.c & derror.c
Xnoctrlx()			ctrlx.c
Xnum_stripped()			tools.c
Xoutdial()			outdial.c
Xpd()				pd.c
Xperms()				tools.c
Xport()				portinfo.c
Xpostfach()			postfach.c
Xprf()				misc.c
Xpruefe()			misc.c
Xquoted_printable()		show.c
Xrates()				loop.c
Xrename()			tools.c
Xrichtext()			show.c
Xscanner()			misc.c
Xschreiben()			misc.c
Xsetup()		  		admin.c
Xsetup_get()			admin.c
Xshortname()			tools.c
Xshow()				show.c
Xshow_level()			portinfo.c
Xsigcatch()			loop.c
Xstatus()			pd.c
Xstatistik()			pd.c
Xstrcomp()			tools.c
Xstrcopy()			tools.c
Xstripped()			tools.c
Xsubb()				misc2.c
Xsuchen()			suchen.c
Xtimeconv()			tools.c
Xtimereconv()			tools.c
Xtty()		 		tools.c
Xttyna()				tools.c
Xunterschrift()			lesen.c
Xupcased()			tools.c
Xuser_aendern()			admin.c
Xuser_anzeigen()			admin.c
Xuser_loeschen()			admin.c
Xuserliste()			portinfo.c
Xwait_until_keypressed()		admin.c
Xweiterleiten()			weiterl.c
Xwhoami()			tools.c
Xwhodo()				control.c
Xyesno()				getline.c
END_OF_FILE
  if test 2465 -ne `wc -c <'src/CROSSREF'`; then
    echo shar: \"'src/CROSSREF'\" unpacked with wrong size!
  fi
  # end of 'src/CROSSREF'
fi
if test -f 'src/HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/HISTORY'\"
else
  echo shar: Extracting \"'src/HISTORY'\" \(2280 characters\)
  sed "s/^X//" >'src/HISTORY' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  HISTORY						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  09.09.1993					   */
X/***************************************************************************/
X
X20.04.1991  ->  Erste Versuche einen NEWS-Reader im Stil der alten "PC-Boxen"
X		zu basteln (sind positiv verlaufen)
X
X21.04.1991  ->  Schreiben an NGs via PNEWS 				
X
X22.04.1991  ->  REPLY via PNEWS
X
X23.04.1991  ->  SH-unabhaengiges Accounting
X
X26.04.1991  ->  Persoenliche Mail lesen, schreiben, beantworten
X
X11.05.1991  ->  Inhalt/Datum, Status
X
X01.06.1991  ->  Vorbereitung fuer die Portierung
X
X02.06.1991  ->  Erste BETA-Test Version an die Portierer/Tester verschickt
X
X18.06.1991  ->  Makro-Befehle implementiert
X
X15.08.1991  ->  SVR3 einigermassen angepasst, LOCK-Mechanismus eingebaut,
X		NNPOST und RMAIL ermoeglicht, versuchweise _SYS_ACCOUNT
X		integriert
X
X21.09.1991  ->  Scanner-Datum beim LOGOUT aktuallisieren, nicht mehr bei
X		init_user()
X
X21.10.1991  ->  Option fuer Online-Spiele implementiert
X
X26.10.1991  ->  Endlich ein "anstaendiges" Makefile:-)
X
X12.11.1991  ->  Die Anspassung an SVR3 laeuft auf Hochtouren
X
X16.11.1991  ->  Referenzversion 1.6.0 ueber "sub.os.minix" gepostet
X
X17.11.1991  ->  Patchlevel PL1 fertiggestellt
X           
X27.11.1991  ->  Patchlevel PL3 mit schnellerem MB-DAEMON ausgeliefert
X
X06.12.1991  ->  Umgestellt auf RMAIL & INEWS (Header mit Refs. etc.)
X
X28.12.1991  ->  Internationale Version (DEFINES, README, etc.) ausgeliefert
X
X04.01.1992  ->  MAIL- & NEWS-Header editierbar (Followup etc.)
X
X20.02.1992  ->  Eigener DOWNLOAD-Befehl. MB-DAEMON erstellt LIB online (opt.)
X
X09.05.1992  ->  RTF (Richtext Format) implementiert
X
X24.05.1992  ->  Strict-Accounting eingebaut / SVR4-Port funxt (!) / 1.6 PL9f
X
X06.06.1992  ->  Version 1.6 PL10 ausgeliefert
X
X04.07.1992  ->  Version 1.6 PL10e ausgeliefert
X
X10.08.1992  ->  Version 1.6 PL10a ist ueber FTP verfuegbar: <nic.funet.fi>
X
X10.11.1992  ->  Umlautkonvertierung eingebaut (Patchlevel 1.6 PL10j2)
X
X09.01.1993  ->  RTF-Editor WENDY, NEWUSER-Mail an Root (Version 1.6 PL10j7)
X
X17.01.1993  ->  Version 1.6 PL10j7 an "comp.sources.misc" ausgeliefert
X
END_OF_FILE
  if test 2280 -ne `wc -c <'src/HISTORY'`; then
    echo shar: \"'src/HISTORY'\" unpacked with wrong size!
  fi
  # end of 'src/HISTORY'
fi
if test -f 'src/baudrate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/baudrate.c'\"
else
  echo shar: Extracting \"'src/baudrate.c'\" \(1758 characters\)
  sed "s/^X//" >'src/baudrate.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  baudrate.c					   */
X/*        FUNKTIONEN  baudrate()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.03.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <time.h>
X
X#include "mbox.h"
X
X
X#ifdef _SYS7	/* UNIX System 7  (MINIX, COHERENT, ...) */
X
X#include  <sgtty.h>
Xstatic struct sgttyb told;
X
X#else		/* UNIX System V  (UNIX, XENIX, ESIX, ...) */
X
X#ifdef _LINUX
X#include  <termio.h>
X#else
X#include  <sys/termio.h> 
X#endif
Xstatic struct termio told;
X
X#endif
X
X
X#define BYTE	0377	/* Don't ask me, ask Andy !! */
X
X
Xint baudrate( try )
Xint try;
X{
X  int i, j = 0;
X  int guess = -1;
X  long ts, tn;
X
X
X  if(BAUDRATE != 0) return BAUDRATE;
X
X#ifdef _SYS7
X  
X  ioctl( 0, TIOCGETP, &told );
X  guess = (int) (100 * (told.sg_ospeed & BYTE));
X
X#else
X
X  ioctl( 0, TCGETA, &told );
X
X  if(told.c_cflag &=    B300) guess = (int)   300;
X  if(told.c_cflag &=   B1200) guess = (int)  1200;
X  if(told.c_cflag &=   B2400) guess = (int)  2400;
X  if(told.c_cflag &=   B4800) guess = (int)  4800;
X  if(told.c_cflag &=   B9600) guess = (int)  9600;
X  /*
X  if(told.c_cflag &=  B14400) guess = (int) 14400;
X  */
X  if(told.c_cflag &=  B19200) guess = (int) 19200;
X  if(told.c_cflag &=  B38400) guess = (int) 38400;
X
X#endif
X
X#ifdef _BAUDRATE  	/* HST mit 'fixed baudrate 19.2k' */
X	
X  if((guess == MAX_BPS) || (guess == 0)){
X
X	guess = 300;
X
X	if(try >   300) guess =  1200;
X	if(try >  1200) guess =  2400;
X	if(try >  2400) guess =  9600;
X	if(try >  9600) guess = 14400;
X	if(try > 14400) guess = 19200;
X  }
X
X#endif
X
X  return guess;
X
X}
END_OF_FILE
  if test 1758 -ne `wc -c <'src/baudrate.c'`; then
    echo shar: \"'src/baudrate.c'\" unpacked with wrong size!
  fi
  # end of 'src/baudrate.c'
fi
if test -f 'src/befehl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/befehl.c'\"
else
  echo shar: Extracting \"'src/befehl.c'\" \(2087 characters\)
  sed "s/^X//" >'src/befehl.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  befehl.c						   */
X/*        FUNKTIONEN  bef()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  06.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  bef()							   */
X/*  BESCHREIBUNG  Sucht entweder die Befehlsnummer zu einem bekannten      */
X/*		  Befehl, oder zeigt die Befehle als Uebersicht an.        */
X/*		  Dabei wird das Userlevel beruecksichtigt.                */
X/*     PARAMETER  befehl  =  Befehl  =  Befehl, der gesucht werden soll    */
X/*			     '?'     =  Befehle anzeigen (levelabhaengig)  */
X/*		  arg     =  '*'     =  ALLE Befehle anzeigen 	           */
X/*     RUECKGABE  -1  =  Userlevel reicht nicht aus			   */
X/*     		  -9  =  Befehl nicht gefunden				   */
X/*		   n  =  Befehlsnummer (siehe Datei BEFEHLE und loop.c)	   */
X/***************************************************************************/
X
Xint bef(befehl, arg)
Xunsigned char befehl[];
Xunsigned char arg[];
X{
X  unsigned char s[STRING];
X  int b = 0, i = 0, l;
X
X  l = USER.level;
X
X  if (befehl[0] == '?') {
X
X	if (arg[0] == '*') l = 9999;
X
X	while (BEF[b].id != -1) {
X		if ((BEF[b].prototyp == 1) && (BEF[b].in <= l)) {
X			printf("%-14.14s ", BEF[b].befehl);
X			i++;
X			if (i == 5) {
X				printf("\n");
X				i = 0;
X			}
X		}
X		b++;
X	}
X	printf("\n\n");
X	return 0;
X  }
X  else {
X	while (BEF[b].id != -1) {
X		if (strcomp(befehl, BEF[b].befehl) == 0) {
X			if (BEF[b].in <= USER.level){
X				if(BEF[b].id == 1000){
X					printf("\n\n");
X					if(arg[0] == '\0')
X						sprintf(s, "exec %s %s %d %d", RSH, BEF[b].pfad, OLDUID, OLDGID);
X					else
X						sprintf(s, "exec %s %s \"%s\" %d %d", RSH, BEF[b].pfad, arg, OLDUID, OLDGID);			
X					system(s);
X				}
X				return BEF[b].id;
X			}
X			else{
X				return -1;
X			}
X		}
X		b++;
X	}
X	return -9;
X  }
X}
END_OF_FILE
  if test 2087 -ne `wc -c <'src/befehl.c'`; then
    echo shar: \"'src/befehl.c'\" unpacked with wrong size!
  fi
  # end of 'src/befehl.c'
fi
if test -f 'src/bled.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bled.doc'\"
else
  echo shar: Extracting \"'src/bled.doc'\" \(1399 characters\)
  sed "s/^X//" >'src/bled.doc' <<'END_OF_FILE'
X(B)LED ist ein zeilenorientierer Editor (Text-Erfassungssystem), der Texte
Xbeliebiger Groesse verarbeiten kann.
X
XEr verwendet verschiedene Eingabemodi, die jeweils am Prefix vor der
XZeilennummer zu identifizieren sind:
X
XL0000 Text-Zeile ...                  # Lese-Modus (".l" und ".L")
XA0000 Text-Zeile ...                  # Anhaenge-Modus (".a")
XI0000 Text-Zeile ...                  # Einfuge-Modus (".i")
XK0000 Text-Zeile ...                  # Korrektur-Modus (".k");
X
XWird ein neuer Text erfasst, ist der Anhaenge-Modus aktiv. Mit dem
XBefehl ".l" (bzw. ".L") kann man sich den bereits eingegeben Text
Xanzeigen lassen.
X
XMuss eine Zeile korrigiert werden, wird mit dem Befehl ".k ZEILE" die
Xentsprechende Zeile (ZEILE) nochmals angezeigt und kann ueberarbeitet
Xwerden.
X
XSoll zwischen den bereits erfassten Zeilen neuer Text eingegeben werden,
Xmuss mit ".i ZEILE" in den Einfuege-Modus gewechselt werden. Von nun 
Xan werden die Eingaben zwischen "ZEILE -1" und "ZEILE" eingefuegt. Die
XNummerierung der auf "ZEILE" folgenden Zeilen wird automatisch angepasst.
XDer Einfuege-Modus wird mit ".a" beendet. Danach ist der Anhaenge-Modus
Xaktiv, und alle Eingaben werden ans Ende des Textes angehaengt.
X
XSollen Zeilen komplett entfernt werden, kommt der Befehl ".d" zum Einsatz.
XWerden keine Zeilennummern angegeben, wird der gesamte Text geloescht !!!
X
XBeendet und gesichert wird die Eingabe mit "." !
END_OF_FILE
  if test 1399 -ne `wc -c <'src/bled.doc'`; then
    echo shar: \"'src/bled.doc'\" unpacked with wrong size!
  fi
  # end of 'src/bled.doc'
fi
if test -f 'src/derror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/derror.c'\"
else
  echo shar: Extracting \"'src/derror.c'\" \(1767 characters\)
  sed "s/^X//" >'src/derror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  dummy_nerror.c					   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "defs.h"
X#include "mbox.msg"
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wie die        */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xunsigned char file[];
Xint line;
Xunsigned char function[], descr[], er[];
X{
X  unsigned char s[80];
X
X  printf("%c%s %s (%s) - %s \"%s\"\n", CR, DER01_MSG, function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	DER02_MSG, file, line, function, descr, er, DER03_MSG);
X  
X}
X
X
END_OF_FILE
  if test 1767 -ne `wc -c <'src/derror.c'`; then
    echo shar: \"'src/derror.c'\" unpacked with wrong size!
  fi
  # end of 'src/derror.c'
fi
if test -f 'src/dis.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dis.c'\"
else
  echo shar: Extracting \"'src/dis.c'\" \(1370 characters\)
  sed "s/^X//" >'src/dis.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*          PROGRAMM  ix/Mbox                                              */
X/*             DATEI  dis.c                                                */
X/*        FUNKTIONEN  dis()                                                */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)                 */
X/*  LETZTE AENDERUNG  16.11.1992                                           */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
Xvoid dis( argument )
Xunsigned char argument[];
X{
X  unsigned char s[STRING];
X
X  if(argument[0] == '*'){
X	headline( DIS01_MSG );
X	printf("%s\n", DIS02_MSG);
X	printf("===============================================================================\n");
X
X	sprintf(s, "%s/usr/%d/.dis", HOME, USER.id);
X	if (show(s, 9999, USER.more + 100) == -1) {
X	        ansi( "md" );
X	        printf("%s.\n", DIS03_MSG);
X	        ansi( "me" );
X	        printf("%s\n", DIS04_MSG);
X	}
X  }
X  else{
X	DISKUSSION = 1;
X
X	printf("\n\n");
X	ansi( "md" );
X	printf("%s: ", DIS05_MSG);
X	ansi( "me" );
X	strcpy(s, (unsigned char *) getline(15, 1, 32, ""));
X	ansi( "md" );
X	printf("\n%s: ", DIS06_MSG);
X	ansi( "me" );
X	strcpy(DIS_subject, (unsigned char *) getline(60, 1, 32, ""));
X
X	lesen( s );
X
X	DISKUSSION = 0;
X  }
X}
END_OF_FILE
  if test 1370 -ne `wc -c <'src/dis.c'`; then
    echo shar: \"'src/dis.c'\" unpacked with wrong size!
  fi
  # end of 'src/dis.c'
fi
if test -f 'src/getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getch.c'\"
else
  echo shar: Extracting \"'src/getch.c'\" \(1978 characters\)
  sed "s/^X//" >'src/getch.c' <<'END_OF_FILE'
X/*
X *	%Z% %M%	%I% %D% %Q%
X *
X *	Copyright (C) 1990 by Christian Schlichtherle
X *			      (chriss@attron.ruhr.sub.org)
X *
X *	%M% - C module for getch(S).
X *
X *	"getch" is a DOS and curses(S) like function which reads
X *	a unsigned character and returns immediately without waiting for
X *	newline.
X *
X * 	getch() - Gets a unsigned character.
X * 	This function gets one unsigned character and immediately returns
X * 	without waiting for newline. The unsigned character is not echoed.
X * 	This function can be used best when you want to input only one
X * 	unsigned character within canonical input or if you need this function
X * 	only very rarely.
X * 	EOF is returned on errors or if an ignored signal occured.
X *	
X *	Modificated by andreas@xenox.w.open.de 06/20/92 Xenox
X */
X
X#include "defs.h"
X#include <sys/types.h>
X#include <stdio.h>    
X#include <errno.h>
X#ifndef _SYS7
X#include <sys/ioctl.h>
X#include <termio.h>
X#else
X#include <sgtty.h>
X#endif 
X
X#ifndef _SYS7
Xstatic struct termio	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TCGETA, &told)
X#define	set_oldmode()	ioctl(0,TCSETA, &told)
X#define	set_newmode()	(tnew.c_cc[VMIN] = 1,tnew.c_cc[VTIME] = 0,\
X			 tnew.c_lflag &= ~(ICANON | ECHO),\
X			 ioctl(0, TCSETA, &tnew))
X
X#else
Xstatic struct sgttyb	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TIOCGETP, &told)
X#define	set_oldmode()	ioctl(0,TIOCSETP, &told)
X#define	set_newmode()	(tnew.sg_flags |= RAW,tnew.sg_flags &= ~ECHO,\
X			 ioctl(0, TIOCSETP, &tnew))
X
X#endif
X
Xstatic int	set = 0;
X
Xint	getch()
X{
X	int	rstat;
X	int	c;
X
X	if (!set) {
X			/* Get old terminal mode. */
X		if (get_oldmode() == -1)
X			return (EOF);
X
X		tnew = told;
X			/* Don't execute this part anymore. */
X		set = 1;
X	}
X
X		/* Set new terminal mode. */
X	if (set_newmode() == -1)
X		return (EOF);
X
X		/* 
X		 * Read one character. The orginal function used 
X		 * read(0, &c, 1) but getchar is a macro 
X		 * and faster. Xenox Fri Jun 19 20:44:46 DST 1992
X		 */
X	c = getchar();
X
X        set_oldmode();
X
X	return ((int)c);
X}
X
END_OF_FILE
  if test 1978 -ne `wc -c <'src/getch.c'`; then
    echo shar: \"'src/getch.c'\" unpacked with wrong size!
  fi
  # end of 'src/getch.c'
fi
if test -f 'src/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/help.c'\"
else
  echo shar: Extracting \"'src/help.c'\" \(2419 characters\)
  sed "s/^X//" >'src/help.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  help.c						   */
X/*        FUNKTIONEN  help()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  help() 						   */
X/*  BESCHREIBUNG  Der Inhalt der Datei HILFE wird entweder komplett ange-  */
X/*		  zeigt, oder aber in Abhaengigkeit von 'cmd' in Auszuegen */
X/*		  ausgegeben.                                              */
X/*     PARAMETER  cmd  =  '*'      =  HILFE wird komplett ausgegeben       */
X/*                        '='      =  SHORTHELP                            */
X/*		  #Befehl  	   =  HILFE zu "Befehl" wird ausgegeben    */
X/*     RUECKGABE  0  =  Keinen Eintrag gefunden                            */
X/*                n  =  Anzahl der Eintraege				   */
X/***************************************************************************/
X
Xint help(cmd)
Xunsigned char cmd[];
X{
X  FILE *fp;
X  unsigned char s[255];
X  int ende = 0, ok = 0, found = 0, toggle = 0, lines = 0;
X
X  show(KURZHILFE, 99, 99); /* RESET */
X  
X  if(cmd[0] == '='){
X	headline( HLP01_MSG );
X	show(KURZHILFE, 9999, USER.more);	
X	return 9999;
X  }
X
X  maybe_locked(HILFE, "r");
X  fp = fopen(HILFE, "r");
X  if (fp == NULL) {
X	nerror("help.c", 14, "help", "Datei-Lesefehler", HILFE);
X  }
X  if (cmd[0] != '#') {
X	ok = 2;
X	found++;
X  }
X  headline( HLP01_MSG );
X  lines = 0;
X
X  while ((fgets(s, 85, fp) != NULL) && !ende) {
X
X	if (USER.more > 0) {
X		if (lines >= MAX_SCR_LINES) {
X			lines = 0;
X			if (more() != 0) return 1;
X		}
X	}
X	if (ok == 2) {
X		if (s[0] != '#') {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle = 0;
X			}
X		}
X		else {
X			printf("\n");
X			lines++;
X			ansi("md");
X			toggle++;
X		}
X	}
X	else {
X		if ((ok == 1) && (s[0] == '#')) {
X			ok = 0;
X			printf("\n");
X			lines++;
X		}
X		if ((ok == 1) && (s[0] != '#')) {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle == 0;
X			}
X		}
X		if ((ok == 0) && (s[0] == '#')) {
X			if (strcomp(cmd, s) == 0) {
X				ok = 1;
X				found++;
X				ansi("md");
X				toggle++;
X			}
X		}
X	}
X  }
X  fclose(fp);
X
X  return found;
X}
END_OF_FILE
  if test 2419 -ne `wc -c <'src/help.c'`; then
    echo shar: \"'src/help.c'\" unpacked with wrong size!
  fi
  # end of 'src/help.c'
fi
if test -f 'src/nerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/nerror.c'\"
else
  echo shar: Extracting \"'src/nerror.c'\" \(1886 characters\)
  sed "s/^X//" >'src/nerror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  nerror.c						   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <setjmp.h>
X
X#include "mbox.h"
X
X
Xextern jmp_buf jmpenv;
X
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wird die       */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xunsigned char file[];
Xint line;
Xunsigned char function[], descr[], er[];
X{
X  unsigned char s[80];
X
X  ansi("md");
X  printf("%c%s ", CR, NER01_MSG);
X  ansi("me");
X
X  printf("%s (%s) - %s \"%s\"\n", function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	NER02_MSG, file, line, function, descr, er, NER03_MSG);
X
X  control(s, 99);
X  control(s, 3);
X
X  longjmp(jmpenv, 1);
X}
X
END_OF_FILE
  if test 1886 -ne `wc -c <'src/nerror.c'`; then
    echo shar: \"'src/nerror.c'\" unpacked with wrong size!
  fi
  # end of 'src/nerror.c'
fi
if test -f 'src/outdial.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/outdial.c'\"
else
  echo shar: Extracting \"'src/outdial.c'\" \(1018 characters\)
  sed "s/^X//" >'src/outdial.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  outdial.c						   */
X/*        FUNKTIONEN  outdial()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  02.04.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
Xvoid outdial()
X{
X  FILE *fp;
X  
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  int a, b;
X
X  
X  fp = fopen( "/tmp/door", "w" );
X  fprintf(fp, "%s\n%s\n%d\n%d\n", 
X	  USER.name, USER.account, USER.id, USER.terminal);
X  fclose(fp);
X
X  printf("\n\n");
X
X  system( "outdial" );
X
X  fp = fopen( "/tmp/acct", "r" );
X  if(fp != NULL){
X     fgets(s, 80, fp);	
X     fclose(fp);
X     unlink( "/tmp/acct" );
X  }
X  strcpy(t, (unsigned char *) strcopy(USER.account, 11, 16));
X  a = atoi(t);
X  b = atoi(s);
X  a -= b;
X
X  USER.account[11] = '\0';
X  sprintf(s, "%d", a);
X  strcat(USER.account, s);
X}
X
END_OF_FILE
  if test 1018 -ne `wc -c <'src/outdial.c'`; then
    echo shar: \"'src/outdial.c'\" unpacked with wrong size!
  fi
  # end of 'src/outdial.c'
fi
if test -f 'wendy/echo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/echo.c'\"
else
  echo shar: Extracting \"'wendy/echo.c'\" \(1659 characters\)
  sed "s/^X//" >'wendy/echo.c' <<'END_OF_FILE'
X/*
X *	%Z% %M%	%I% %D% %Q%
X *
X *	Copyright (C) 1990 by Christian Schlichtherle
X *			      (chriss@attron.ruhr.sub.org)
X *
X *	%M% - C module for getch(S).
X *
X *	"getch" is a DOS and curses(S) like function which reads
X *	a unsigned character and returns immediately without waiting for
X *	newline.
X *
X * 	getch() - Gets a unsigned character.
X * 	This function gets one unsigned character and immediately returns
X * 	without waiting for newline. The unsigned character is not echoed.
X * 	This function can be used best when you want to input only one
X * 	unsigned character within canonical input or if you need this function
X * 	only very rarely.
X * 	EOF is returned on errors or if an ignored signal occured.
X *	
X *	Modificated by andreas@xenox.w.open.de 06/20/92 Xenox
X */
X
X
X#include <sys/types.h>
X#include <stdio.h>    
X#include <errno.h>
X#ifndef _SYS7
X#include <sys/ioctl.h>
X#include <termio.h>
X#else
X#include <sgtty.h>
X#endif 
X
X#ifndef _SYS7
Xstatic struct termio	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TCGETA, &told)
X#define	set_oldmode()	ioctl(0,TCSETA, &told)
X#define	set_newmode()	(tnew.c_cc[VMIN] = 1,tnew.c_cc[VTIME] = 0,\
X			 tnew.c_lflag &= ~(ICANON | ECHO),\
X			 ioctl(0, TCSETA, &tnew))
X
X#else
Xstatic struct sgttyb	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TIOCGETP, &told)
X#define	set_oldmode()	ioctl(0,TIOCSETP, &told)
X#define	set_newmode()	(tnew.sg_flags |= RAW,tnew.sg_flags &= ~ECHO,\
X			 ioctl(0, TIOCSETP, &tnew))
X
X#endif
X
Xstatic int	set = 0;
X
Xvoid	echo( mode )
Xint 	mode;
X{
X	int	rstat;
X
X	if(mode == 0){
X		if (!set) {
X			get_oldmode();
X			tnew = told;
X			set = 1;
X		}
X		set_newmode();
X	}	
X	if(mode == 1){
X	        set_oldmode();
X	}
X}
X
END_OF_FILE
  if test 1659 -ne `wc -c <'wendy/echo.c'`; then
    echo shar: \"'wendy/echo.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/echo.c'
fi
if test -f 'wendy/english.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/english.hlp'\"
else
  echo shar: Extracting \"'wendy/english.hlp'\" \(752 characters\)
  sed "s/^X//" >'wendy/english.hlp' <<'END_OF_FILE'
XCursor up ............... CTRL-K,UP    Cursor to start of line . CTRL-A,HOME
XCursor down ..... ....... CTRL-J,DOWN  Cursor to end of line ... CTRL-Z,END
X
XDelete line ............. CTRL-Y       Backwards a page ........ CTRL-B,PAGEUP
XDelete to end of line ... CTRL-T       Forward a page .......... CTRL-F,PAGEDN
X
XRebuild screen .......... CTRL-R       Insertmode on/off ....... CTRL-V,INSERT
XRebuild line ............ CTRL-L       Setup (!!!) ............. CTRL-S
X
XSave file ............... CTRL-W       State ................... CTRL-G
XExit .................... CTRL-X       Ruler ................... CTRL-P
X
XMark block .............. CTRL-Q       Choose RTF-features ..... CTRL-U
XRTF on/off .............. CTRL-N       VI-Commandmode .......... ESC:
END_OF_FILE
  if test 752 -ne `wc -c <'wendy/english.hlp'`; then
    echo shar: \"'wendy/english.hlp'\" unpacked with wrong size!
  fi
  # end of 'wendy/english.hlp'
fi
if test -f 'wendy/getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/getch.c'\"
else
  echo shar: Extracting \"'wendy/getch.c'\" \(1978 characters\)
  sed "s/^X//" >'wendy/getch.c' <<'END_OF_FILE'
X/*
X *	%Z% %M%	%I% %D% %Q%
X *
X *	Copyright (C) 1990 by Christian Schlichtherle
X *			      (chriss@attron.ruhr.sub.org)
X *
X *	%M% - C module for getch(S).
X *
X *	"getch" is a DOS and curses(S) like function which reads
X *	a unsigned character and returns immediately without waiting for
X *	newline.
X *
X * 	getch() - Gets a unsigned character.
X * 	This function gets one unsigned character and immediately returns
X * 	without waiting for newline. The unsigned character is not echoed.
X * 	This function can be used best when you want to input only one
X * 	unsigned character within canonical input or if you need this function
X * 	only very rarely.
X * 	EOF is returned on errors or if an ignored signal occured.
X *	
X *	Modificated by andreas@xenox.w.open.de 06/20/92 Xenox
X */
X
X#include "defs.h"
X#include <sys/types.h>
X#include <stdio.h>    
X#include <errno.h>
X#ifndef _SYS7
X#include <sys/ioctl.h>
X#include <termio.h>
X#else
X#include <sgtty.h>
X#endif 
X
X#ifndef _SYS7
Xstatic struct termio	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TCGETA, &told)
X#define	set_oldmode()	ioctl(0,TCSETA, &told)
X#define	set_newmode()	(tnew.c_cc[VMIN] = 1,tnew.c_cc[VTIME] = 0,\
X			 tnew.c_lflag &= ~(ICANON | ECHO),\
X			 ioctl(0, TCSETA, &tnew))
X
X#else
Xstatic struct sgttyb	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TIOCGETP, &told)
X#define	set_oldmode()	ioctl(0,TIOCSETP, &told)
X#define	set_newmode()	(tnew.sg_flags |= RAW,tnew.sg_flags &= ~ECHO,\
X			 ioctl(0, TIOCSETP, &tnew))
X
X#endif
X
Xstatic int	set = 0;
X
Xint	getch()
X{
X	int	rstat;
X	int	c;
X
X	if (!set) {
X			/* Get old terminal mode. */
X		if (get_oldmode() == -1)
X			return (EOF);
X
X		tnew = told;
X			/* Don't execute this part anymore. */
X		set = 1;
X	}
X
X		/* Set new terminal mode. */
X	if (set_newmode() == -1)
X		return (EOF);
X
X		/* 
X		 * Read one character. The orginal function used 
X		 * read(0, &c, 1) but getchar is a macro 
X		 * and faster. Xenox Fri Jun 19 20:44:46 DST 1992
X		 */
X	c = getchar();
X
X        set_oldmode();
X
X	return ((int)c);
X}
X
END_OF_FILE
  if test 1978 -ne `wc -c <'wendy/getch.c'`; then
    echo shar: \"'wendy/getch.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/getch.c'
fi
if test -f 'wendy/wendy.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/wendy.h'\"
else
  echo shar: Extracting \"'wendy/wendy.h'\" \(2114 characters\)
  sed "s/^X//" >'wendy/wendy.h' <<'END_OF_FILE'
X#include <stdio.h>
X#include <signal.h>
X
X#ifndef EXTERN
X#define EXTERN extern
X#endif
X
X#ifdef _LOCAL
X#	define HILFE	  	"/local/mbox/wendy/wendy.hlp"
X#	define VERSION   	" WENDY 1.1e  -  Simple (MIME) RichTextFormat Editor  -  HILFE: CTRL-O "
X#else
X#	define HILFE		"/local/mbox/wendy/english.hlp"
X#	define VERSION   	" WENDY 1.1e  -  Simple (MIME) RichTextFormat Editor  -  HELP: CTRL-O "
X#endif
X
X#define RULERLINE 	"1...5...10...15...20...25...30...35...40...45...50...55...60...65...70...75...80"
X
X#define CR		13
X#define LF		10
X#define BS		8
X#define TAB		9
X#define ESC		27
X
X#define ENTER   	13
X
X#define CTRL_A		1
X#define CTRL_B  	2
X#define CTRL_C		3
X#define CTRL_D  	4
X#define CTRL_E		5
X#define CTRL_F  	6
X#define CTRL_G  	7
X#define CTRL_H  	8
X
X#define CTRL_J  	10  
X#define CTRL_K		11
X#define CTRL_L		12
X
X#define CTRL_N		14
X#define CTRL_O		15
X#define CTRL_P		16
X#define CTRL_Q		17
X#define CTRL_R		18
X#define CTRL_S		19
X#define CTRL_T  	20
X#define CTRL_U		21
X#define CTRL_V  	22
X#define CTRL_W  	23
X#define CTRL_X  	24
X#define CTRL_Y		25
X#define CTRL_Z  	26
X
X#define UP		9165
X#define DOWN		9166
X#define LEFT		9168
X#define RIGHT		9167
X
X#define PGUP		9186
X#define PGDN		9185
X
X#define END 		9189
X#define HOME		9172	
X
X#define DEL		9152
X#define INS		9151
X
X#define NUM5		9171
X
X
X#define TLX_END		9175	/* TELIX 3.11  &  PROCOMM 2.4.1 */
X#define TLX_DEL		127
X#define TLX_INS		0
X
X#define TEM_INS 	22	/* TELEMATE 2.11 */
X#define TEM_DEL 	7
X
X#define	BLANK		127
X
X#define STRING 		140
X#define LONGSTRING	255
X
X#define MAXLINES 	2000
X
X#define LINELENGTH	180
X
X#define is_centered	1
X#define is_richtext	2
X#define is_plain	4
X
X#define BLOCKMODE	2
X
XFILE *ROLLBACK;
X
Xunsigned char SCREEN[27][STRING];
Xunsigned char ATTRIB[27][STRING];
X
Xunsigned char TEXT[MAXLINES][LINELENGTH];
Xint  FLAG[MAXLINES];
X
Xunsigned char version[STRING];
X
Xunsigned char umlaut[STRING], terminal[STRING];
X
Xint x, y, ypos, lastline, xruler;
X
Xint NEU, CHANGED, REALLY, MARK, RULER, STATUSM, FORMATTER;
Xint MAXX, MAXY, START;
X
Xint RTF_attrib;
Xint RTF_toggle;
Xint INS_mode;
X
Xstruct block{
X	int status;
X	int x1;
X	int y1;
X	int x2;
X	int y2;
X	int y;
X	int ypos;
X} BLOCK;
END_OF_FILE
  if test 2114 -ne `wc -c <'wendy/wendy.h'`; then
    echo shar: \"'wendy/wendy.h'\" unpacked with wrong size!
  fi
  # end of 'wendy/wendy.h'
fi
echo shar: End of archive 14 \(of 15\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
