Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i048:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part13/15
Message-ID: <1993Feb5.185943.10801@sparky.imd.sterling.com>
X-Md4-Signature: e34ad2971cd0d5262a8f8a3dbfdb8a5a
Date: Fri, 5 Feb 1993 18:59:43 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 48
Archive-name: mbox/part13
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Announce10j7 etc/english.shorth src/ctrlx.c src/defs.h
#   src/faces.c src/suchen.c src/weiterl.c wendy/block.c wendy/rtf.c
#   wendy/screen.c wendy/wendy.dok.U
# Wrapped by kent@sparky on Fri Feb  5 12:18:17 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 13 (of 15)."'
if test -f 'Announce10j7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce10j7'\"
else
  echo shar: Extracting \"'Announce10j7'\" \(5165 characters\)
  sed "s/^X//" >'Announce10j7' <<'END_OF_FILE'
XAnnouncement for the BBS-package ix/MBox 1.6 PL10j7                25.01.1993
X
X
XThe package includes a BBS for UNIX. The following derivations and compilers
Xhave been tested:
X
X- MINIX 386 (You have to have the 386 version!) with BCC
X
X- MINIX 386 with GCC 1.37 (with or w/o ESTDIO-patches)
X
X- ESIX SVR3 with CC (MSC) or GCC
X
X- ISC 2.21 with "Shared Libs"
X
X- DELL UNIX 2.1 SVR4 with GCC 2.1
X
X- LINUX 0.99pl2 with GCC 2.3.3
X
XIf you don't have one of those systems or anything that's compatible to
Xany of them, you may stop reading now!
X
XNOTE: The 64+64 limitation of Coherent and plain MINIX makes it impossible
X      to run ix/MBox BBS! The BBS itself needs more than 170kB of memory!
X
X
XFor all who are still reading, some other requirements. The ix/MBox uses
Xsome UNIX services to stay compatible to the UNIX world and to make updates
Xmore easy. You need:
X
X- a mailer like SMAIL (RMAIL) or UMAIL 
X
X- a news-package B/C-NEWS (INEWS) or WNEWS
X
X- a uucp-system like HDB, Taylor or MNXUUCP or UUCP1.2
X
X(The packages UMAIL and WNEWS are MINIX stuff by Fred v. Kempen, UUCP1.2
Xis the (best) UUCP-package for MINIX by Will Rose)
X
X
X  
XYou're STILL (!) reading? Ok, now the features of the BBS. If you're missing
Xa feature that is important for you, just talk to me. Maybe I've forgotten
Xto mention it, or I'm able to offer it with the next patchlevel!
X
XThe BBS ...
X
X... uses NEWS to handle all boards/articles. You may use the BBS or your
X    prevered newsreader to maintain the articles.
X
X... uses an internal mailer for mails between BBS-users.
X
X... uses (R/S)MAIL to receive/deliver mails from BBS-users to system-users
X    of the same or foreigen sites and vice versa.
X
X... uses a variable command set. If you don't like the presetted commands,
X    just change the config-file to have your own commands set.
X
X... commands are all fitted out with a user-level and a prototype-flag.
X    You may have several commands with the same function, but only the
X    commands with the prototype-flag set will be shown in the command-
X    survey.
X
X... has "user defined commands". If you like to offer an external newsreader
X    or mailer to your users, you only have to state that in a config-file.
X
X... is able to communicate in various languages. A german and an english
X    language-file are delivered with this package. It takes about two or
X    three hours to build language- and help-files for other countries.
X
X... offers PD-areas like all other boards. The trick is, that the articles
X    in the PD-boards are including a pointer to the real PD-package. You
X    are able to maintain that areas like all other boards. You don't have to
X    copy your PD-directories!
X   
X... uses SX/SZ/SB and RX/RZ/RB as filetransfer protocols. Also ASCII up- 
X    and download are available for text and PD transfer.
X
X... has it's own line-editor (B)LED. Users with higher level may use
X    fullscreen-editors, of course. You only have to put all offered editors
X    in a config-file.
X
X... even has it's on fullscreen (MIME) RTF-Editor. This one also handles
X    8bit texts (like texts including 'umlauts' ;-)
X
X... NEWS&MAIL have a total 8bit-transparency. ISO 8859-1 and IBM-Keymaps are
X    no longer a problem.
X
X... offers games to the users. Again, there's a config-file, which
X    includes the list of your online-games (rogue/nethack etc.).
X
X... may call a CHAT-program. If you don't have one, please tell me. I've
X    a PD-mutliport-chat program, too. Otherwise you can use TALK or
X    phone as a two-person chat.
X
X... is able to read Bellcore RTF (Richtext Format) and Qouted-Printable.
X
X... creates MIME-Headers. This, and the RTF-feature are the first steps to
X    multimedia-mail. 
X
X... allows to change the headerfield of news-articles and mails. (Depending
X    on userlevel, of course!)
X
X... supports the (critical) header field "return-receipt-to:", to get an
X    acknowledge for you sent mails and to confirm mails sent to mbox-users.
X
X... allows to reedit articles, if you are the autor. If you are the sysop,
X    you may reedit everything ;-)
X
X... is able to generate statistics on calls, downloads, news-articles.
X
X... builds hitlists on calls per user, downloads per file, etc.
X
X... contains a users database with online-maintenance-facility.
X
X... allows users to setup the BBS to hit their preferences. They may
X    choose:
X
X    - TERMINAL      ANSI X3.64, VT100, VT52, Dump (have a look at TERMCAP)
X
X    - EDITOR        VI, EMACS, PED, MINED, LED, WENDY (or whatever you offer)
X
X    - PROMPT        BOARD, TIME, RATES (with or w/o BELL)
X
X    - OUTPUT        TYPE, MORE, MORE with marks, direction, lines, etc. ...
X
X    - INTRO         INFOTEXT, STATE, both
X       
X    - SCANNER       DATE&TIME, DATE, change scanner date
X
X
X... supports the following commands by default:
X
X    +, -, ACCOUNT, AREA, BOARD, CHAT, DIR, DATE, DELETE, DOWNLOAD, DIRECTION,
X    DISUSSION, EDIT, FINGER, FORWARD, GAMES, GOODBYE, HELP, MAIL, MACRO, 
X    MESSAGE, MINIX, PORTINFO, PROTOCOL, PM, READ, SETUP, SYSINFO, SIGNATURES,
X    STATE, STATISTICS, SEARCH, TIME, USERS, UPLOAD, VERSION, WRITE
X
X    If you count the them and their various flags/options, you'll get a list
X    of 102 commands. 
END_OF_FILE
  if test 5165 -ne `wc -c <'Announce10j7'`; then
    echo shar: \"'Announce10j7'\" unpacked with wrong size!
  fi
  # end of 'Announce10j7'
fi
if test -f 'etc/english.shorth' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.shorth'\"
else
  echo shar: Extracting \"'etc/english.shorth'\" \(4474 characters\)
  sed "s/^X//" >'etc/english.shorth' <<'END_OF_FILE'
X?                          reachable commands are shown 
X? *                        all commands are shown
Xcommand ?                  help on "command"
X
X0                          list command-buffers contents
X1-9                        execute one of nine buffered commands 
X
X+                          go to the next board/group with NEW articles
X
X-                          go to the previous board/group with NEW articles
X
XACCOUNT			   establish an account & a maildrop for a new user
X
XAREA +                     go to the next group of a subgroup
XAREA ++                    go to the next group
XAREA -                     go to a previous group of a subgroup
XAREA --                    go to a previous group
X
XBOARD                      list boards with new articles
XBOARD *                    list all boards depending on userlevel
XBOARD **                   list ALL boards
XBOARD +                    go to the next board
XBOARD -                    go to the previous board
XBOARD !                    display the name of the current board
XBOARD #                    list areas in board
XBOARD ..		   step from one area to the previous one
XBOARD boardname            jump to board "boardname"
X
XCHAT                       multiport chatsystem
X
XDATE			   display current date
X
XDELETE article		   delete article no. "article"
XDELETE article-article	   delete from "article" to "article"
XDELETE >                   delete copies of your own mail in your PM
X
XDIR                        index new articles
XDIR *                      index ALL articles (of a board)
X
XDIRECTION                  reading direction OLD <> NEW ?
X
XDISCUSSION *               in which discussions am I involved
XDISCUSSION                 follow a subject thru the articles of a group
X
XDOWNLOAD                   receive a couple of articles under X-, Y-, Z-
X                           or NONE-protocol 
X
XEDIT article               re-edit article no. "article"
X
XFINGER name                list infos about user "name"
X
XFORWARD                    list stored mails
XFORWARD user               forward a stored mail to "user"
XFORWARD article user       forward "article" to "user"
X
XGAMES			   offer a (list of) game(s)
X
XGOODBYE			   leave the BBS 
X
XHELP                       this shorthelp
XHELP *                     display some pages of helpful descriptions
XHELP command               show information on "command"
X
XMAIL user                  send mail to "user" 
XMAIL host!user             send mail to "user" on system "host"
XMAIL user@host.domain      send mail to "user" on system "host.domain"
X
XMACRO			   display/declare macros
X
XMESSAGE                    show/change "hello" message
X
XMINIX OS-command           execute "OS-command" on MINIX-shell
X
XPORTINFO                   list all terminals, users, activities
X
XPROTOCOL                   protocol of all call(s/ers)
XPROTOCOL *                 protocol (complete)
XPROTOCOL #                 statistics of these calls
XPROTOCOL %                 callers statistics (hitlist)
X
XPM                         move to your maildrop
X
XREAD                       read NEW articles
XREAD *                     real ALL articles (of a board)
XREAD article               show article no. "article"
XREAD article-article       display from "article" to "article"
X
XSEARCH pattern             search for "pattern" in all articles of a group
X
XSETUP                      configure the BBS to your favor
X
XSIGNATURE		   show/change your signature
X
XSTATE                      list your BBS-configuration
X
XSTATISTICS                 table containing NEWS-statistics
XSTATISTICS *               table containing more NEWS-statistics
XSTATISTICS $               UUCP-rates (only if UUCP supports this)
XSTATISTICS #               download-statistics 
XSTATISTICS %               download-statistics (hitlist)
XSTATISTICS >               mailing-statistics (xmd)
X
XTIME                       local time and your online-time in seconds
X
XUSERS                      show users list
XUSERS *                    show users list (more detailed)
XUSERS #                    users up-/download ratio
XUSERS %                    list users with their newsgroups
XUSERS $                    accounting information (payload ;-)
XUSERS name                 list infos about user "name"
X
XVERSION                    print version
XVERSION *                  display compiling definitions
XVERSION #                  the "Hall of Fame"
X
XWRITE                      create a new article and post it 
END_OF_FILE
  if test 4474 -ne `wc -c <'etc/english.shorth'`; then
    echo shar: \"'etc/english.shorth'\" unpacked with wrong size!
  fi
  # end of 'etc/english.shorth'
fi
if test -f 'src/ctrlx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ctrlx.c'\"
else
  echo shar: Extracting \"'src/ctrlx.c'\" \(2125 characters\)
  sed "s/^X//" >'src/ctrlx.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  ctrlx.c						   */
X/*        FUNKTIONEN  ctrlx(), noctrlx()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#ifdef _SYS7	/* UNIX System 7  (MINIX, COHERENT, ...) */
X
X#include  <sgtty.h>
Xstatic struct tchars newtc, oldtc;
X
X#else		/* UNIX System V  (UNIX, XENIX, ESIX, ...) */
X
X#ifdef _LINUX
X#include  <termio.h>
X#else
X#include  <sys/termio.h> 
X#endif
Xstatic struct termio newtc, oldtc;
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  ctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird auf (int) 24 gesetzt - das ent-	   */
X/*		  spricht einem CTRL-X. Wird nun CTRL-X gedrueckt, loest   */
X/*		  UNIX das Signal SIGABRT aus ...                          */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid ctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCGETC, (struct sgttyb *) &oldtc);
X  newtc = oldtc;
X  newtc.t_quitc = 24;
X  ioctl(0, TIOCSETC, (struct sgttyb *) &newtc);
X
X#else
X
X  ioctl(0, TCGETA, (struct termio *) &oldtc);
X  newtc = oldtc;
X  newtc.c_cc[VQUIT] = 24;
X  ioctl(0, TCSETA, (struct termio *) &newtc);
X
X#endif
X
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  noctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird "restauriert" ...		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid noctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCSETC, (struct sgttyb *) &oldtc);
X
X#else
X
X  ioctl(0, TCSETA, (struct termio *) &oldtc);
X
X#endif
X
X}
END_OF_FILE
  if test 2125 -ne `wc -c <'src/ctrlx.c'`; then
    echo shar: \"'src/ctrlx.c'\" unpacked with wrong size!
  fi
  # end of 'src/ctrlx.c'
fi
if test -f 'src/defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/defs.h'\"
else
  echo shar: Extracting \"'src/defs.h'\" \(3711 characters\)
  sed "s/^X//" >'src/defs.h' <<'END_OF_FILE'
X/***************************************************************************/
X/* Was jetzt folgt, ist fuer Experimente voellig ungeeignet. Jegliche Aen- */
X/* derung bringt ueber kurz oder lang ernste Probleme fuer die Konsistenz  */
X/* der ix/MBox.						 	           */
X/*									   */
X/* Auch wenn Aenderungen (zufaellig) erfolgreich sein sollten, duerfen sie */
X/* nicht an dritte weitergeleitet werden.				   */
X/*									   */
X/* Wer globale Variablen/Strukturen nicht akzeptiert, sollte jetzt auf der */
X/* Stelle diese Datei verlassen !					   */
X/***************************************************************************/
X
X  
X#ifndef EXTERN
X#define EXTERN extern
X#endif
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X#include "proto.h"
X
X#define STRING	     81
X#define LSTRING	     STRING + 4
X#define LONGSTRING  256
X#define BS            8
X#define CR           13
X#define LF           10
X#define TAB           9
X#define BELL          7
X#define DEL         127
X#define CTRL_X	     24
X#define CTRL_Z       26
X#define CTRL_D        4
X#define ESC          27
X
X#if defined( _SYS7) || defined(_SCO)
X#define ENTER        13
X#else
X#define ENTER        10
X#endif
X
X
X#define fix( II )  ( II / 100 )
X#define flt( II )  ( II - (fix( II ) * 100 ))
X
X#define MAKRO_MAX_REK 30
X
X#define DEF_MAX_SCR_LINES 23
X
XEXTERN int MAX_SCR_LINES;
X
XEXTERN int OLDUID;
XEXTERN int OLDGID;
X
XEXTERN unsigned char PROMPT[STRING];
XEXTERN unsigned char TERMINAL[STRING];
X
XEXTERN unsigned char EDDY[STRING];
X
XEXTERN unsigned char BRETT[STRING];
XEXTERN unsigned char INHALT[STRING];
XEXTERN unsigned char NG[STRING];
X
XEXTERN unsigned char UGROUPS[STRING];
XEXTERN unsigned char MAKRO[STRING];
X
XEXTERN unsigned char MYNAME[STRING];
X
XEXTERN long LASTLOG;
XEXTERN int LASTTIME;
X
XEXTERN int IS_BUFFERED;
X
XEXTERN int SHORT_HEADER;
X
XEXTERN long IDX_SIZE;
X
XEXTERN struct userdaten {
X	int id;
X	unsigned char name[31];
X	unsigned char passwort[11];
X	unsigned char sh_name[15];
X	unsigned char nick[31];
X	unsigned char wohnort[31];
X	unsigned char strasse[31];
X	unsigned char telefon1[31];
X	unsigned char telefon2[31];
X	unsigned char geburtsdatum[31];
X        int terminal;
X	int editor;
X	int level;
X        int bell;
X	int prompt;
X	int more;
X	unsigned char lastlog[11]; 
X	int seq;
X        int intro;
X	int lasttime;
X 	int lastmode;
X	int leserichtung;
X	int tlines;
X	long upratio;
X	long downratio;
X	long elapsed;
X	unsigned char newsgrps[STRING];
X	unsigned char schluessel[STRING];
X	unsigned char abused[STRING];
X	unsigned char account[STRING]; 		
X} USER;
X
X
X
X#define MAX_BEF 80
X
XEXTERN struct bef_struct {
X	int id;
X	int in;
X 	int ex;
X	int prototyp;
X	unsigned char befehl[(STRING/2)];
X	unsigned char pfad[STRING];
X} BEF[MAX_BEF];
X
X
X#define MAX_MAK 30
X
XEXTERN struct mak_struct {
X	unsigned char makname[STRING];
X	unsigned char makwert[(STRING * 2)];
X} MAK[MAX_MAK];
X
X
X
X#define MAX_NEWSGRPS 20
X
XEXTERN unsigned char newsgrp[MAX_NEWSGRPS][(STRING/3)];
XEXTERN int newsgrpptr;
X
XEXTERN int MAILOUT_LEV;
XEXTERN int ADMIN_LEV;
XEXTERN int WRITE_EX_LEV;
XEXTERN int WRITE_IN_LEV;
XEXTERN int WRITE_INTERNAT;
XEXTERN int PD_D_LEV;
XEXTERN int PD_U_LEV;
XEXTERN int EXE_LEV; 
XEXTERN int GUEST_LEV;
X
XEXTERN unsigned char CONSOLE_REDIRECT[STRING];
X
XEXTERN int BB1;
XEXTERN int BB2;
XEXTERN int BB3;
XEXTERN int BB4;
XEXTERN int BB5;
XEXTERN int BB6;
XEXTERN int BB7;
XEXTERN int BB8;
XEXTERN int BB9;
X
XEXTERN unsigned char UUCPID[STRING];
X
XEXTERN int BAUDRATE;
X
XEXTERN int UMLAUT;
X
XEXTERN int UMLAUT_MODUS;
X
XEXTERN int fetch_local;
XEXTERN unsigned char fetch_subj[STRING];
X
XEXTERN int DISKUSSION;
XEXTERN unsigned char DIS_subject[STRING];
X
XEXTERN int OFFERED_EDITORS;
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X
X
X
X
X
X
X
END_OF_FILE
  if test 3711 -ne `wc -c <'src/defs.h'`; then
    echo shar: \"'src/defs.h'\" unpacked with wrong size!
  fi
  # end of 'src/defs.h'
fi
if test -f 'src/faces.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/faces.c'\"
else
  echo shar: Extracting \"'src/faces.c'\" \(3576 characters\)
  sed "s/^X//" >'src/faces.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  faces.c						   */
X/*        FUNKTIONEN  faces()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  08.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X/* There were plans to implement the X-Face: Headlines, but the resulting
X   overhead is much too big, to realize it! */
X
X
X#define a1	219
X#define a2	223
X#define a3	220
X#define a4	32
X
X#define b1	'8'
X#define b2	'9'
X#define b3	'6'
X#define b4	32
X
X
Xvoid faces( fname )
Xunsigned char fname[];
X{
X  int x, y;
X  int x1, y1;
X  int Z1, Z2, Z3, Z4;
X  FILE *fp;
X  int c, i;
X  unsigned char s[STRING];
X  int tog = 0;
X  unsigned char t[STRING];
X
X
X
X  ansi("mr");
X  printf("[Bild des Autors ansehen?] G, A, %c, ? > ", GBL07_MSG);
X  ansi("me");
X  printf("G%c", BS);
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if (c == ENTER) c = 'G';
X	if (c == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, "Bild des Autors anzeigen als Grafik, Ascii-Bild oder lieber Nicht ?");
X		ansi("me");
X	}
X	if ((c != 'G') && (c != 'A') && (c != GBL07_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c\n\n", c);
X
X  if (c == GBL07_MSG) return;
X
X  if(c == 'G'){
X	Z1 = a1;
X	Z2 = a2;
X	Z3 = a3;
X	Z4 = a4;
X  }
X  if(c == 'A'){
X	Z1 = b1;
X	Z2 = b2;
X	Z3 = b3;
X	Z4 = b4;
X  }
X
X  sprintf(s, "%s/etc/face.put", HOME);
X
X  fp = fopen( s, "r" );
X  
X  x1 = fgetc(fp); c = fgetc(fp);
X  y1 = fgetc(fp); c = fgetc(fp);
X
X  for(y = 0; y < y1; y++){
X	i = 0;
X	for(x = 0; x < x1; x += 8){
X		c = fgetc(fp);
X		if(tog == 0) s[i] = c;
X		else t[i] = c;
X		i++;
X	}
X	tog++;
X	if(tog == 2){
X		tog = 0;
X		i = (int) x/8;
X		for(x = 0; x < i; x ++){
X			if( (s[x] & 128) &&  (t[x] & 128)) printf("%c", Z1);
X			if( (s[x] & 128) && !(t[x] & 128)) printf("%c", Z2);
X			if(!(s[x] & 128) &&  (t[x] & 128)) printf("%c", Z3);
X			if(!(s[x] & 128) && !(t[x] & 128)) printf("%c", Z4);
X
X			if( (s[x] & 64) &&  (t[x] & 64)) printf("%c", Z1);
X			if( (s[x] & 64) && !(t[x] & 64)) printf("%c", Z2);
X			if(!(s[x] & 64) &&  (t[x] & 64)) printf("%c", Z3);
X			if(!(s[x] & 64) && !(t[x] & 64)) printf("%c", Z4);
X
X			if( (s[x] & 32) &&  (t[x] & 32)) printf("%c", Z1);
X			if( (s[x] & 32) && !(t[x] & 32)) printf("%c", Z2);
X			if(!(s[x] & 32) &&  (t[x] & 32)) printf("%c", Z3);
X			if(!(s[x] & 32) && !(t[x] & 32)) printf("%c", Z4);
X
X			if( (s[x] & 16) &&  (t[x] & 16)) printf("%c", Z1);
X			if( (s[x] & 16) && !(t[x] & 16)) printf("%c", Z2);
X			if(!(s[x] & 16) &&  (t[x] & 16)) printf("%c", Z3);
X			if(!(s[x] & 16) && !(t[x] & 16)) printf("%c", Z4);
X
X			if( (s[x] & 8) &&  (t[x] & 8)) printf("%c", Z1);
X			if( (s[x] & 8) && !(t[x] & 8)) printf("%c", Z2);
X			if(!(s[x] & 8) &&  (t[x] & 8)) printf("%c", Z3);
X			if(!(s[x] & 8) && !(t[x] & 8)) printf("%c", Z4);
X
X			if( (s[x] & 4) &&  (t[x] & 4)) printf("%c", Z1);
X			if( (s[x] & 4) && !(t[x] & 4)) printf("%c", Z2);
X			if(!(s[x] & 4) &&  (t[x] & 4)) printf("%c", Z3);
X			if(!(s[x] & 4) && !(t[x] & 4)) printf("%c", Z4);
X
X			if( (s[x] & 2) &&  (t[x] & 2)) printf("%c", Z1);
X			if( (s[x] & 2) && !(t[x] & 2)) printf("%c", Z2);
X			if(!(s[x] & 2) &&  (t[x] & 2)) printf("%c", Z3);
X			if(!(s[x] & 2) && !(t[x] & 2)) printf("%c", Z4);
X
X			if( (s[x] & 1) &&  (t[x] & 1)) printf("%c", Z1);
X			if( (s[x] & 1) && !(t[x] & 1)) printf("%c", Z2);
X			if(!(s[x] & 1) &&  (t[x] & 1)) printf("%c", Z3);
X			if(!(s[x] & 1) && !(t[x] & 1)) printf("%c", Z4);
X		}
X		printf("\n");
X	}
X  }
X  fclose(fp);
X
X  c = getint();
X}
X
X
X
END_OF_FILE
  if test 3576 -ne `wc -c <'src/faces.c'`; then
    echo shar: \"'src/faces.c'\" unpacked with wrong size!
  fi
  # end of 'src/faces.c'
fi
if test -f 'src/suchen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/suchen.c'\"
else
  echo shar: Extracting \"'src/suchen.c'\" \(4792 characters\)
  sed "s/^X//" >'src/suchen.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  suchen.c						   */
X/*        FUNKTIONEN  suchen(), edit()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  13.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <signal.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  suchen()						   */
X/*  BESCHREIBUNG  Artikel im aktuellen Brett mit GREP nach muster durch-   */
X/* 		  suchen und entsprechende Artikel anzeigen.		   */
X/*     PARAMETER  muster = Suchbegriff				           */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid suchen( muster )
Xunsigned char muster[];
X{
X  FILE *fp;
X
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char tmp[STRING];
X  unsigned char ex[LONGSTRING];
X
X  int fpid;
X  int found = 0;
X  int ok = 0;
X  int i;
X  
X
X  if(muster[0] == '\0'){
X	ansi( "md" );
X	printf("\n\n%s ", SUC01_MSG);
X	ansi( "me" );
X	strcpy(muster, (unsigned char *) getline(60, 1, 32, ""));
X	if(muster[0] == '\0'){
X		printf(" <- %s\n", SUC02_MSG);
X		return;
X	}
X  }
X
X  i = 0;
X  while(muster[i] != '\0'){
X	if(muster[i] == '"') muster[i] = ' ';
X	i++;
X  }
X
X  sprintf(s, " %s \"%s\" %s [%s] ", SUC03_MSG, (unsigned char *) stripped(muster), SUC04_MSG, NG);
X  headline( s );
X
X  printf("%s .", SUC05_MSG);
X
X  sprintf(tmp, "%s/such.%d", TMP, getpid());
X
X  if(strcomp("PM", BRETT) == 0){
X	sprintf(t, "%s/usr/%d", HOME, USER.id);
X	chdir( t );
X  }
X  else{
X	chdir( BRETT );
X  }
X
X  switch( (fpid = fork()) ){
X		case -1 :
X				break;
X		case  0 :	while(1){
X					printf(".");
X					sleep(3);
X				}	
X				break;
X  }
X
X  sprintf(s, "%s \"%s\" * > %s 2> %s", GREP, (unsigned char *) stripped(muster), tmp, CPRN);
X  system( s );
X
X  kill( fpid, SIGKILL );
X  (void) wait( &fpid );
X
X  printf("%c", CR);
X
X
X  fp = fopen( tmp, "r" );
X  if(fp == 0){
X	
X  }
X  while((fgets(ex, LONGSTRING, fp) != NULL) && (ok == 0)){
X	if(atoi(ex) != 0){	
X		if(show( (unsigned char *) stripped(ex), 9999, USER.more ) == -1) ok++;
X		found++;
X	}
X  }
X  fclose(fp);
X
X  chdir( HOME );
X
X  if(found == 0){
X	printf("%s \"%s\" %s\n", SUC06_MSG, (unsigned char *) stripped(muster), SUC07_MSG);
X  }
X
X  unlink( tmp );
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  edit()						   */
X/*  BESCHREIBUNG  							   */
X/*     PARAMETER  						           */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid edit( arg )
Xunsigned char arg[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char d[STRING];
X  unsigned char p1[STRING];
X  unsigned char p2[STRING];
X
X  int ok = 0;
X  int yet = 0;
X
X  if (arg[0] == '\0') {
X	ansi( "md" );
X	printf(" <- %s\n", SUC07aMSG);
X	ansi( "me" ); 
X	return;
X  }
X
X  if (strcomp(BRETT, "PM") != 0) {
X        sprintf(t, "%s/%s", BRETT, arg); 
X  }
X  else {
X	sprintf(t, "%s/usr/%d/%s", HOME, USER.id, arg);
X	/*
X	ansi( "md" );
X	printf(" <- %s\n", SUC08_MSG);
X	ansi( "me" ); 
X	return;
X	*/
X  }
X  
X  if((USER.level < ADMIN_LEV) && (USER.level >= EXE_LEV)){
X 	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi( "md" );
X		printf(" <- %s\n", SUC10_MSG);
X		ansi( "me" ); 
X		return;
X	}
X	while((fgets(s, 80, fp) != 0) && (ok == 0)){
X		if(strcomp("From: ", s) == 0){
X			strcpy(d, (unsigned char *) strcopy(s, 6, 80));
X			if(strcomp(USER.name, d) == 0) ok++;
X		}
X	}
X	fclose(fp);
X	if(ok == 0){
X		ansi( "md" );
X		printf(" <- %s\n", SUC09_MSG);
X		ansi( "me" ); 
X		return;
X	}
X  }
X
X  if(USER.level >= EXE_LEV){
X	sprintf(s, "%s %s", EDDY, t);
X	noctrlx();
X	system(s);
X	ctrlx();
X  }
X  else{
X	sprintf(p1, "%s/%dED1", TMP, getpid());
X	sprintf(p2, "%s/%dED2", TMP, getpid());
X
X	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi( "md" );
X		printf(" <- %s\n", SUC08_MSG);
X		ansi( "me" ); 
X		return;
X	}
X 	ff = fopen( p1, "w" );
X	while(fgets(s, 80, fp) != NULL){
X		fputs(s, ff);
X		if(strcomp("From: ", s) == 0){
X			strcpy(d, (unsigned char *) strcopy(s, 6, 80));
X			if(strcomp(USER.name, d) == 0) ok++;
X		}
X		if((strlen(s) < 3) && (yet == 0)){
X			fclose(ff);
X			ff = fopen( p2, "w" );
X			yet++;
X		}
X	}
X	fclose(fp);
X	fclose(ff);
X
X	if(ok == 0){
X		ansi( "md" );
X		printf(" <- %s\n", SUC09_MSG);
X		ansi( "me" ); 
X		unlink( p1 );
X		unlink( p2 );
X		return;
X	}
X
X	sprintf(s, "%s %s", EDDY, p2);
X	noctrlx();
X	system(s);
X	ctrlx();
X
X	sprintf(s, "cat %s > %s", p1, t);
X	system( s );
X	sprintf(s, "cat %s >> %s", p2, t);
X	system( s );
X
X	unlink( p1 );
X	unlink( p2 );
X  }
X}
END_OF_FILE
  if test 4792 -ne `wc -c <'src/suchen.c'`; then
    echo shar: \"'src/suchen.c'\" unpacked with wrong size!
  fi
  # end of 'src/suchen.c'
fi
if test -f 'src/weiterl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/weiterl.c'\"
else
  echo shar: Extracting \"'src/weiterl.c'\" \(3768 characters\)
  sed "s/^X//" >'src/weiterl.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  weiterleiten.c					   */
X/*        FUNKTIONEN  weiterleiten(), carboncopy()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  05.07.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  weiterleiten()					   */
X/*  BESCHREIBUNG  Je nach Parameter wird entweder ein Artikel an einen     */
X/*		  User weitergeleitet, oder aber die letzte PM nochmal     */
X/*		  mit einer anderen Adresse verschickt.                    */
X/*     PARAMETER  arg = Nummer des Artikel, Empfaenger, etc.               */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid weiterleiten( arg )
Xunsigned char arg[];
X{
X  FILE *fp;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char subject[STRING];
X  int i, a, num;
X  unsigned char empf[STRING];
X
X  subject[0] = '\0';
X
X  sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X  fp = fopen( s, "r" );
X  if(fp != NULL){
X	fgets(subject, 80, fp);
X	fclose(fp);
X  }
X
X  if((subject[0] == '\0') && ((arg[0] > 64) || (arg[0] == '?'))){
X	ansi("md", 0, 0);
X	printf(" %s\n", WEI01_MSG);
X	ansi("me", 0, 0);
X	return;
X  }
X
X  if(arg[0] == '\0'){
X	printf("\n\n%s\n\n", WEI02_MSG);
X	ansi("md", 0, 0);
X	printf("%s %s\n\n", WEI03_MSG, subject);
X	ansi("me", 0, 0);
X	return;
X  }
X
X  num = 0;
X
X  if(arg[0] < 65){
X	i = 0;
X	while((arg[i] > 32) && (arg[i] != '\0')) i++;
X	strcpy(s, (unsigned char *) strcopy(arg, 0, (i-1)));
X	num = atoi(s);
X	strcpy(empf, (unsigned char *) strcopy(arg, (i+1), length(arg)));
X	strcat(empf, "$");
X  }
X  else{
X	sprintf(empf, "%s$", arg);
X  }  
X
X  if(num != 0){
X	if(strcomp(BRETT, "PM") != 0){
X		sprintf(t, "%s/%d", BRETT, num);
X		sprintf(s, "cp %s/%d %s/usr/%d/.lastletter", BRETT, num, HOME, USER.id);
X	}
X	else{
X		sprintf(t, "%s/usr/%d/%d", HOME, USER.id, num);
X		sprintf(s, "cp %s/usr/%d/%d %s/usr/%d/.lastletter", HOME, USER.id, num, HOME, USER.id);
X	}
X	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi("md", 0, 0);
X		printf(" %s\n", WEI04_MSG);
X		ansi("me", 0, 0);
X	return;
X	}
X	fclose(fp);
X	system(s);
X	sprintf(s, "%s/usr/%d/.lastletter", HOME, USER.id);
X
X	sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X	fp = fopen( s, "w" );
X	if(fp == NULL){
X		nerror("weiterl.c", 76, "weiterleiten", "Datei_Schreibfehler", s);
X	}
X	fprintf(fp, "%d <%s>", num, NG);
X	fclose(fp);
X  }
X
X  brief(empf);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  carboncopy()						   */
X/*  BESCHREIBUNG  Kopien einer MAIL an mehrer Empfaenger versenden	   */
X/*     PARAMETER  cc  = Empfaenger einer Kopie (im Header sichtbar)	   */
X/*		  bcc = Empfaenger einer Kopie (im Header unsichtbar)	   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid carboncopy( cc, bcc )
Xunsigned char cc[], bcc[];
X{
X  unsigned char ex[LONGSTRING];
X  unsigned char ef[LONGSTRING];
X  unsigned char s[STRING];
X
X  int a = 0, i = 0;
X  int ok = 0;
X
X  printf("\n");
X
X  sprintf(ex, "%s,%s ", (unsigned char *) stripped(cc), bcc);
X
X  if(ex[0] == '\0') return;
X
X  while(ok == 0){
X	while((ex[i] != ',') && (ex[i] != '\0')) i++;
X
X	if(ex[i] == '\0') ok++;
X
X	strcpy(ef, (unsigned char *) bigcopy(ex, a, (i-1)));
X	strcpy(s, (unsigned char *) stripped(ef));
X
X	if((strlen(s) > 1) && (s[0] != '(')){
X		weiterleiten( s );
X	}
X	a = i + 1;
X	i++;
X  }
X  
X}
END_OF_FILE
  if test 3768 -ne `wc -c <'src/weiterl.c'`; then
    echo shar: \"'src/weiterl.c'\" unpacked with wrong size!
  fi
  # end of 'src/weiterl.c'
fi
if test -f 'wendy/block.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/block.c'\"
else
  echo shar: Extracting \"'wendy/block.c'\" \(5294 characters\)
  sed "s/^X//" >'wendy/block.c' <<'END_OF_FILE'
X#include "wendy.h"
X
X
X/*	Block markieren		*/
X
Xblock_set()
X{
X  int xa, ya;
X
X  if((BLOCK.status == 0) || (BLOCK.status == BLOCKMODE)){
X	BLOCK.status = 1;
X	BLOCK.x1     = x;
X	BLOCK.y1     = (ypos + y) -1;
X	BLOCK.ypos   = ypos;
X	BLOCK.y	     = y;
X#ifdef _LOCAL
X	show_status( " WENDY: Blockanfang markiert. " );
X#else
X	show_status( " WENDY: Begin of block marked. " );
X#endif
X  }
X  else{
X	if(BLOCK.status == 1){
X		BLOCK.status = BLOCKMODE;
X		BLOCK.x2 = x;
X		BLOCK.y2 = (ypos + y) -1;
X
X		if((BLOCK.y1 == BLOCK.y2) && (BLOCK.x1 == BLOCK.x2)){
X			printf("%c", 7);
X#ifdef _LOCAL
X			show_status( " WENDY: Hae? " );
X#else		
X			show_status( " WENDE: So what? ");
X#endif
X			BLOCK.status = 0;
X		}
X		else{
X			if(BLOCK.y1 > BLOCK.y2){
X				ya = BLOCK.y1;
X				xa = BLOCK.x1;
X				BLOCK.y1 = BLOCK.y2;
X				BLOCK.x1 = BLOCK.x2;
X				BLOCK.y2 = ya;
X				BLOCK.x2 = xa;
X			}
X
X			if(BLOCK.y1 == BLOCK.y2){
X				if(BLOCK.x1 > BLOCK.x2){
X					xa = BLOCK.x1;
X					BLOCK.x1 = BLOCK.x2;
X					BLOCK.x2 = xa;
X				}
X			}
X#ifdef _LOCAL
X			show_status( " WENDY: Blockende markiert. " );
X#else
X			show_status( " WENDY: End of block marked. ");
X#endif
X		}
X		show_screen( START );
X	}
X  }
X  activate( RTF_attrib );
X  ansi2( "cm", x, y );
X}
X
X
X
X/*	Block sichern		*/
X
Xblock_ctrlw()
X{
X  FILE *fp;
X  unsigned char s[LONGSTRING];
X  unsigned char a[LONGSTRING];  
X  unsigned char p[STRING];
X  int i;
X  int o = BLOCK.y1;
X
X#ifdef _LOCAL
X  show_status( " WENDY: Block sichern. Dateiname? " );
X#else
X  show_status( " WENDY: Save block. Filename? " );
X#endif
X  ansi( "mr", 0, 0 );
X  strcpy(p, (unsigned char *) getline( 20, 1, ' ', "" ));
X
X  fp = fopen( p, "w" );
X  if(fp == NULL){
X	printf("%c", 7);
X#ifdef _LOCAL
X	sprintf(s, " WENDY: Fehler <%d>! ", p);
X#else
X	sprintf(s, " WENDY: Error <%d>! ", p);
X#endif
X	show_screen( s );
X	return;
X  }
X
X  rtf_convert( TEXT[o], 1, o);
X  strcpy(s, (unsigned char *) strcopy(SCREEN[1], (BLOCK.x1 -1), MAXX));
X  strcpy(a, (unsigned char *) strcopy(ATTRIB[1], (BLOCK.x1 -1), MAXX));
X  if(BLOCK.y1 == BLOCK.y2){
X	s[(BLOCK.x2 - BLOCK.x1 + 1)] = '\0';
X	a[(BLOCK.x2 - BLOCK.x1 + 1)] = '\0';
X  }
X
X  fprintf(fp, "%s\n", (unsigned char *) make_rtf( s, a ));
X  o++;
X
X  if(BLOCK.y1 == BLOCK.y2) goto NOTAUSGANG;
X
X  if((BLOCK.y2 - BLOCK.y1) > 1){ 
X	do{
X		fprintf(fp, "%s\n", (unsigned char *) TEXT[o]);
X		o++;
X	}while(o < BLOCK.y2); 
X  }
X
X  rtf_convert( TEXT[o], 1, o);
X  strcpy(s, (unsigned char *) strcopy(SCREEN[1], 0, (BLOCK.x2 -1)));
X  strcpy(a, (unsigned char *) strcopy(ATTRIB[1], 0, (BLOCK.x2 -1)));
X  fprintf(fp, "%s\n", (unsigned char *) make_rtf( s, a ));
X
X  NOTAUSGANG:
X
X  fclose(fp);
X
X  BLOCK.status = 0;
X
X  activate( RTF_attrib );
X  ansi2( "cm", x, y );  
X}
X
X
X
X/*	Block ''attributieren''		*/
X
Xblock_ctrlu()
X{
X  int i;
X  int o = BLOCK.y1;
X  int ymem = y;
X
X  restore_screen( ypos );
X
X  rtf_convert( TEXT[o], 1, o );
X  y = 1;
X
X  if(BLOCK.y1 == BLOCK.y2){
X	for(i = (BLOCK.x1 -1); i <= (BLOCK.x2 -1); i++){
X		ATTRIB[1][i] = RTF_attrib;
X	}
X  }
X  else{
X	for(i = (BLOCK.x1 -1); i <= MAXX; i++){
X		ATTRIB[1][i] = RTF_attrib;
X	}
X  }
X  if(FORMATTER == 'b') blockset();
X  strcpy(TEXT[o], (unsigned char *) make_rtf( SCREEN[1], ATTRIB[1] ));
X  if(FORMATTER == 'c') FLAG[o] |= is_centered;
X  if(BLOCK.y1 == BLOCK.y2) goto NOTAUSGANG;
X  o++;
X
X  if((BLOCK.y2 - BLOCK.y1) > 1){
X	do{
X		rtf_convert( TEXT[o], 1, o );
X		memset(ATTRIB[1], RTF_attrib, MAXX);
X		if(FORMATTER == 'b') blockset();
X		strcpy(TEXT[o], (unsigned char *) make_rtf( SCREEN[1], ATTRIB[1] ));
X		if(FORMATTER == 'c') FLAG[o] |= is_centered;
X		o++;
X	}while(o < BLOCK.y2); 
X  }
X  rtf_convert( TEXT[o], 1, o );
X  
X  for(i = 0; i <= (BLOCK.x2 -1); i++){
X	ATTRIB[1][i] = RTF_attrib;
X  }
X  if(FORMATTER == 'b') blockset();
X  strcpy(TEXT[o], (unsigned char *) make_rtf( SCREEN[1], ATTRIB[1] ));
X  if(FORMATTER == 'c') FLAG[o] |= is_centered;
X
X  NOTAUSGANG:
X
X  BLOCK.status = 0;
X
X  prep_screen( ypos );
X  show_screen( START );
X  y = ymem;
X  ansi2( "cm", x, y );  
X}
X
X
X/*	Block loeschen		*/
X
Xblock_ctrly()
X{
X  int i;
X  int start = BLOCK.y1 + 1;
X  int diff  = BLOCK.y2 - BLOCK.y1; /* + 1 */
X  int dummy;
X
X  unsigned char s[LONGSTRING];
X  unsigned char a[LONGSTRING];
X
X  restore_screen( ypos );
X
X  if(BLOCK.y1 == BLOCK.y2){
X	dummy = MAXX - (BLOCK.x2 - BLOCK.x1);
X	for(i = 0; i < dummy; i++){
X		SCREEN[y][(BLOCK.x1 + i - 1)] = SCREEN[y][(BLOCK.x2 + i)];
X		ATTRIB[y][(BLOCK.x1 + i - 1)] = ATTRIB[y][(BLOCK.x2 + i)];
X	}       
X	diff = i + 1;
X	for(i = diff; i < MAXX; i++){
X		SCREEN[y][i] = ' ';
X		ATTRIB[y][i] = '0';
X	}	
X	strcpy(TEXT[(ypos + y - 1)], (unsigned char *) make_rtf( SCREEN[y], ATTRIB[y] ));
X	goto NOTAUSGANG;
X  }
X
X  SCREEN[BLOCK.y1][(BLOCK.x1 - 1)] = '\0';
X  ATTRIB[BLOCK.y1][(BLOCK.x1 - 1)] = '\0';
X
X  rtf_convert( TEXT[BLOCK.y2], 26, BLOCK.y2 );  
X
X  strcpy(s, (unsigned char *) SCREEN[BLOCK.y1]);
X  strcpy(a, (unsigned char *) ATTRIB[BLOCK.y1]);
X
X  strcat(s, (unsigned char *) strcopy(SCREEN[26], BLOCK.x2, MAXX));
X  strcat(a, (unsigned char *) strcopy(ATTRIB[26], BLOCK.x2, MAXX));
X
X  strcpy(TEXT[BLOCK.y1], (unsigned char *) make_rtf( s, a ));  
X
X  for(i = start; i <= lastline; i++){
X	strcpy(TEXT[i], (unsigned char *) TEXT[(i + diff)]);
X  	FLAG[i] = FLAG[(i + diff)];
X  } 
X  lastline -= diff;
X
X  NOTAUSGANG:
X
X  BLOCK.status = 0;
X  ypos = BLOCK.ypos;
X  x = BLOCK.x1;
X  y = BLOCK.y;
X
X  prep_screen( ypos );
X  show_screen( START );
X  ansi2( "cm", x, y );  
X}
END_OF_FILE
  if test 5294 -ne `wc -c <'wendy/block.c'`; then
    echo shar: \"'wendy/block.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/block.c'
fi
if test -f 'wendy/rtf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/rtf.c'\"
else
  echo shar: Extracting \"'wendy/rtf.c'\" \(6396 characters\)
  sed "s/^X//" >'wendy/rtf.c' <<'END_OF_FILE'
X#include "wendy.h"
X
X
X
X/*	Bildschirmzeile ins RTF umwandeln	*/
X
Xunsigned char *make_rtf( t, a )
Xunsigned char t[], a[];
X{
X  unsigned char s[LONGSTRING];
X  unsigned char q[LONGSTRING];
X  int olda = '0';
X  int i = 0;
X  int l = 0;
X
X  unsigned char line[1024];
X
X  strcpy(q, (unsigned char *) t);  strcpy(s, (unsigned char *) right_stripped(q));
X
X  strcat(s, (unsigned char *) "`");
X  strcat(a, (unsigned char *) "0");
X
X  if(s[0] == '~'){
X	line[0] = '~';
X	l++;
X	i++;
X  }
X
X  if(strcomp("        ", s) == 0){ 	/* TAB for Makefiles ;-) */
X	line[l] = TAB;
X	l++;
X	i += 8;
X  }
X
X  while((s[i] != '\0') && (l < LINELENGTH)){
X	if(s[i] == BLANK) s[i] = ' ';
X	if(a[i] != olda){
X		line[l] = '\0';
X		if(olda == '0'){
X			switch(a[i]){
X				case 'b' : strcat(line, (unsigned char *) "<Bold>");
X					   break;	
X				case 'i' : strcat(line, (unsigned char *) "<Italic>");
X					   break;
X				case 'f' : strcat(line, (unsigned char *) "<Fixed>");
X					   break;
X				case 'u' : strcat(line, (unsigned char *) "<Underline>");
X					   break;
X			}
X		}
X		else{
X			switch(olda){
X				case 'b' : strcat(line, (unsigned char *) "</Bold>");
X					   break;	
X				case 'i' : strcat(line, (unsigned char *) "</Italic>");
X					   break;
X				case 'f' : strcat(line, (unsigned char *) "</Fixed>");
X					   break;
X				case 'u' : strcat(line, (unsigned char *) "</Underline>");
X					   break;
X			}
X		}
X		olda = a[i];
X		l = strlen(line);
X	}
X	if(s[i] != '`'){
X		line[l] = s[i];
X		l++;		
X	}
X	i++;
X  }
X
X  line[l] = ' '; line[l+1] = '\0'; /* !!!? */
X
X  return (unsigned char *) line;
X}
X
X
X
X/*	RTF-Zeile in Bildschirmzeile umwandeln	*/
X
Xrtf_convert( line, scrpos, tpos )
Xunsigned char line[];
Xint scrpos;
Xint tpos;
X{
X  unsigned char s[LINELENGTH];
X
X  unsigned char screen[1024];
X  unsigned char attrib[1024];
X  unsigned char scr2[1024];
X  unsigned char att2[1024];
X
X  int i = 0;
X  int l = 0;
X  int j = 0;
X  int c = 0;
X
X  int rtf = 0;
X  int RTF_local = '0';
X
X  screen[0] = '\0';
X  attrib[0] = '\0';
X
X  while(line[i] != '\0'){
X	rtf = 0;
X	if(line[i] > 127){
X		if(strcomp("iso", umlaut) == 0){
X			switch(line[i]){
X				case 142 : line[i] = 196; 
X					   break;
X				case 153 : line[i] = 214; 
X					   break;
X				case 154 : line[i] = 220; 
X					   break;
X				case 225 : line[i] = 223; 
X					   break;
X				case 132 : line[i] = 228; 
X					   break;
X				case 148 : line[i] = 246;
X					   break;
X				case 129 : line[i] = 252; 
X					   break;
X			}
X		}
X		if(strcomp("ibm", umlaut) == 0){
X			switch(line[i]){
X				case 196 : line[i] = 142; 
X					   break;
X				case 214 : line[i] = 153; 
X					   break;
X				case 220 : line[i] = 154; 
X					   break;
X				case 223 : line[i] = 225; 
X					   break;
X				case 228 : line[i] = 132; 
X					   break;
X				case 246 : line[i] = 148;
X					   break;
X				case 252 : line[i] = 129; 
X					   break;
X			}
X		}
X	}
X	if(line[i] == ' ') line[i] = BLANK;
X	if(line[i] == '<'){
X		if(line[(i+1)] == '/'){
X			rtf++;
X		}
X		else{
X			strcpy(s, (unsigned char *) strcopy(line, (i+1), strlen(line)));
X			if((strcomp("Bold",        s) == 0) ||
X			   (strcomp("Italic",      s) == 0) ||
X			   (strcomp("Fixed",       s) == 0) ||
X			   (strcomp("Smaller",     s) == 0) ||
X			   (strcomp("Bigger",      s) == 0) ||
X			   (strcomp("Underline",   s) == 0) ||
X			   (strcomp("Center",      s) == 0) ||
X			   (strcomp("Flush",       s) == 0) ||
X			   (strcomp("Indent",      s) == 0) ||
X		 	   (strcomp("Outdent",     s) == 0) ||
X			   (strcomp("Samepage",    s) == 0) ||
X		           (strcomp("Subscript",   s) == 0) ||
X			   (strcomp("Superscript", s) == 0) ||
X			   (strcomp("Heading",     s) == 0) ||
X			   (strcomp("Footing",     s) == 0) ||
X			   (strcomp("ISO-8859-",   s) == 0) ||
X			   (strcomp("US-ASCII",    s) == 0) ||
X			   (strcomp("Excerpt",     s) == 0) ||
X			   (strcomp("Paragraph",   s) == 0) ||
X			   (strcomp("Signature",   s) == 0) ||
X		           (strcomp("Comment",     s) == 0) ||
X			   (strcomp("nl",          s) == 0) ||
X			   (strcomp("np",          s) == 0) ||
X			   (strcomp("lt",          s) == 0) ||
X			   (strcomp("No-op",       s) == 0)) rtf++;
X		}
X        }
X
X	if(rtf == 0){
X		if(line[i] == TAB){
X			j = (((int)(l+8)/8) * 8) - l;
X			strcpy(s, "            "); s[j] = '\0';						
X			screen[l] = '\0'; strcat(screen, (unsigned char *) s);
X			strcpy(s, "000000000000"); s[j] = '\0';
X			attrib[l] = '\0'; strcat(attrib, (unsigned char *) s);
X			l += (j -1);
X		}
X		else{
X			if(line[i] > 31){
X				screen[l] = line[i];
X				attrib[l] = RTF_local;
X			}
X		}
X		l++;
X	}		
X	else{
X		j = i + 1;
X		while((line[i] != '>') && (line[i] != '\0')){
X			i++;
X		}
X
X		strcpy(s, (unsigned char *) strcopy(line, j, (i-1)));
X
X		if(s[0] == '/'){
X			RTF_local = '0';
X		}		
X		else{
X			if(strcomp("nl", s) != 0){
X				c = s[0]; if(c < 97) c += 32;
X				if((c == 'b') || (c == 'i') || (c == 'f') || (c == 'u')){
X					RTF_local = c;
X				}
X				if(c == 'c'){
X					FLAG[(ypos + scrpos -1)] |= is_centered;
X				}
X				if(strcomp("lt", s) == 0){
X					screen[l] = '<';
X					attrib[l] = RTF_local;
X					l++;
X				}
X			}
X		}
X	}
X	i++;
X  }
X  l--;
X
X  while(l < MAXX){
X	screen[l] = ' ';
X	attrib[l] = '0';
X	l++;
X  }
X  screen[l] = '\0';
X  attrib[l] = '\0';
X 
X  sprintf(SCREEN[scrpos], "%-*.*s", MAXX, MAXX, (unsigned char *) screen);
X  sprintf(ATTRIB[scrpos], "%-*.*s", MAXX, MAXX, (unsigned char *) attrib);
X
X  if(l > MAXX){
X	strcpy(screen, (unsigned char *) strcopy(screen, (MAXX-1), l));
X	strcpy(attrib, (unsigned char *) strcopy(attrib, (MAXX-1), l));
X	
X	screen[0] = '~';
X	attrib[0] = '0';
X
X	for(i = lastline; i > tpos; i--){
X		strcpy(TEXT[(i+1)], (unsigned char *) TEXT[i]);
X		FLAG[(i+1)] = FLAG[i];
X	}
X	lastline++;	
X	tpos++;
X	strcpy(TEXT[tpos], (unsigned char *) make_rtf( screen, attrib ));
X  }  
X
X  if(((FLAG[tpos] & is_centered) == is_centered) && (SCREEN[scrpos][0] != ' ')){
X	strcpy(screen, (unsigned char *) SCREEN[scrpos]);
X	strcpy(attrib, (unsigned char *) ATTRIB[scrpos]);
X	strcpy(s, (unsigned char *) SCREEN[scrpos]); i = strlen((unsigned char *) right_stripped(s));
X	j = (MAXX - i) / 2;
X	strcpy(SCREEN[scrpos], (unsigned char *) "                                                                              ");           		
X	strcpy(ATTRIB[scrpos], (unsigned char *) "000000000000000000000000000000000000000000000000000000000000000000000000000000");
X	SCREEN[scrpos][j] = '\0';
X	ATTRIB[scrpos][j] = '\0';
X        screen[i] = '\0';
X	strcat(SCREEN[scrpos], (unsigned char *) screen);
X	attrib[i] = '\0';
X	strcat(ATTRIB[scrpos], (unsigned char *) attrib);
X  }
X}
END_OF_FILE
  if test 6396 -ne `wc -c <'wendy/rtf.c'`; then
    echo shar: \"'wendy/rtf.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/rtf.c'
fi
if test -f 'wendy/screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/screen.c'\"
else
  echo shar: Extracting \"'wendy/screen.c'\" \(3798 characters\)
  sed "s/^X//" >'wendy/screen.c' <<'END_OF_FILE'
X#include "wendy.h"
X 
X 
X 
X/*      ANSI-Sequenz fuer Attribute senden      */
X 
Xactivate( c )
Xint c;
X{
X  ansi( "me" );
X
X  switch(c){
X        case 'b' : ansi( "md" );
X                   break;
X        case 'i' : ansi( "mr" );
X                   break;
X        case 'f' : ansi( "mb" );
X                   break;
X        case 'u' : ansi( "us" );
X                   break;
X	case 'c' : break;
X        default  : RTF_attrib = '0';
X  }
X}
X 
X 
X 
X/*      Zeile mit Attributen anzeigen   */
X 
Xshow_line( s, a, start )
Xunsigned char s[], a[];
Xint start;
X{
X  int olda = '0';
X  int i = 0;
X  int l = 0;
X  int dummy = (ypos + y) -1;
X  int set = 0;
X 
X  unsigned char line[1024];
X 
X  i = start -1;
X 
X  ansi2( "cm", start, y );
X 
X  while(s[i] != '\0'){
X
X	if(BLOCK.status == BLOCKMODE){
X		line[l] = '\0';
X		if((dummy == BLOCK.y1) && (i == (BLOCK.x1 -1))){
X			if(set == 0){
X				strcat(line, (unsigned char *) termansi( "md" ));
X				set++;
X			}
X		}
X		if((dummy > BLOCK.y1) && (dummy < BLOCK.y2)){
X			if(set == 0){
X				strcat(line, (unsigned char *) termansi( "md" ));
X				set++;
X			}
X		}
X		if((dummy == BLOCK.y2) && (i == BLOCK.x2)){
X			if((BLOCK.y1 == BLOCK.y2) && (set != 99)){
X				set = 99;
X			}
X			if((set == 0) || (set == 99)){
X				strcat(line, (unsigned char *) termansi( "me" ));
X				if(set != 99) set++;
X			}
X		}
X		if(dummy > BLOCK.y2){
X			if(set == 0){
X				strcat(line, (unsigned char *) termansi( "me" ));
X				set++;
X			}
X		}
X		
X		if(((dummy >  BLOCK.y1) && (dummy < BLOCK.y2)) ||
X                   ((dummy == BLOCK.y1) && (i > BLOCK.x1))     ||
X		   ((dummy == BLOCK.y2) && (i < BLOCK.x2))) olda = a[i];
X
X		l = strlen(line);
X	}
X
X        if(a[i] != olda){
X                olda = a[i];
X                line[l] = '\0';
X		strcat(line, (unsigned char *) termansi( "me" ));
X                switch(olda){
X                        case 'b' : strcat(line, (unsigned char *) termansi( "md" ));
X                                   break;
X                        case 'i' : strcat(line, (unsigned char *) termansi( "mr" ));
X                                   break;
X                        case 'f' : strcat(line, (unsigned char *) termansi( "mb" ));
X                                   break;
X                        case 'u' : strcat(line, (unsigned char *) termansi( "us" ));
X                                   break;
X                }
X		l = strlen(line);
X        }
X	if(s[i] == BLANK)
X		line[l] = ' ';
X	else
X	        line[l] = s[i];
X        l++;
X        i++;
X  }
X  line[l] = '\0';
X  if(start == 1) ansi( "ce" );
X  printf("%s", (unsigned char *) right_stripped( (unsigned char *) line));
X}
X 
X 
X 
X/*      Bildschirm mit Attributen aufbauen      */
X 
Xshow_screen( start )
Xint start;
X{
X  int i, xmem = x, ymem = y;
X 
X  ansi( "me" );
X 
X  x = 1; y = start;
X 
X  for(i = start; i <= MAXY; i++){
X        show_line( (unsigned char *) SCREEN[i], (unsigned char *) ATTRIB[i], 1 );
X        y++;
X  }
X  x = xmem; y = ymem;
X  activate( RTF_attrib );
X  ansi2( "cm", x, y );
X}
X 
X 
X 
X 
X/*      Bildschirminhalt aus RTF-Datei bilden   */
X 
Xprep_screen( ypos )
Xint ypos;
X{
X  int i;
X 
X  RTF_attrib = '0';
X 
X  for(i = START; i <= MAXY; i++){
X        rtf_convert( TEXT[(ypos -1 + i)], i, (ypos -1 + i) );
X  }
X}
X 
X 
X 
X/*      Bildschirminhalt ins RTF wandeln        */
X 
Xrestore_screen( ypos )
Xint ypos;
X{
X  int i;
X 
X  for(i = START; i <= MAXY; i++){
X        strcpy( TEXT[(ypos -1 + i)], (unsigned char *) make_rtf( SCREEN[i], ATTRIB[i] ));
X  }
X}
X 
X 
X 
X/*      Status-Zeile ausgeben   */
X 
Xshow_status( s )
Xunsigned char s[];
X{
X  unsigned char l[LONGSTRING];
X
X  strcpy(l, (unsigned char *) s);
X  strcat(l, "                                                                          ");
X  l[MAXX] = '\0';
X
X  ansi2( "cm", 1, 1 );
X  ansi( "mr" );
X  printf("%s", l);
X  ansi2( "cm", (strlen(s) +1), 1 );
X
X  STATUSM = 1;
X 
X  activate( RTF_attrib );
X}
X
X
X
END_OF_FILE
  if test 3798 -ne `wc -c <'wendy/screen.c'`; then
    echo shar: \"'wendy/screen.c'\" unpacked with wrong size!
  fi
  # end of 'wendy/screen.c'
fi
if test -f 'wendy/wendy.dok.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/wendy.dok.U'\"
else
  echo shar: Extracting \"'wendy/wendy.dok.U'\" \(4682 characters\)
  sed "s/^X//" >'wendy/wendy.dok.U' <<'END_OF_FILE'
Xbegin 644 wendy/wendy.dok
XM4&%T:#H@=6YN970A<F]O= I&<F]M.B!6;VQK97(@4V-H=65R;6%N;B \5F]L
XM:V5R+E-C:'5E<FUA;FY =6YN970N=RYO<&5N+D1%/@I297!L>2U4;SH@5F]L
XM:V5R+E-C:'5E<FUA;FY =6YN970N=RYO<&5N+D1%("A6;VQK97(@4V-H=65R
XM;6%N;BD*3F5W<V=R;W5P<SH@;&]C86PN=&%L:PI$:7-T<FEB=71I;VXZ('=O
XM<FQD"E-U8FIE8W0Z(")796YD>2(@+2!E:6X@<&%A<B!4:7!S(0I#;VYT96YT
XM+51Y<&4Z('1E>'0O<&QA:6X[(&-H87)S970]:7-O+3@X-3DM,0I#;VYT96YT
XM+51R86YS9F5R+45N8V]D:6YG.B X8FET"E@M3F5W<RU296%D97(Z(&EX+TU"
XM;W@@,2XV(%!,,3!J,B!B>2 \=F]L:V5R<T!U;FYE="YW+F]P96XN1$4^"DUE
XM<W-A9V4M240Z(#PR0C!"0C@S."XQ.$!U;FYE="YW+F]P96XN1$4^"D]R9V%N
XM:7IA=&EO;CH@5$A%(%5.1$521U)/54Y$($Y%5%=/4DL@*$)"4SH@*S0Y(#(P
XM,B T-C(Q,30O-#8V,#(S-"D*1&%T93H@5&AU+" Q.2!.;W8@.3(@,34Z-3(Z
XM,C8@0T54"DQI;F5S.B S-@H*0V]N=&5N="U4>7!E.B!T97AT+W)I8VAT97AT
XM.R!C:&%R<V5T/6ES;RTX.#4Y+3$*3F%T@7)L:6-H(&=I8G0G<R!S;W=A<R!W
XM:64@/$)O;&0^3TY,24Y%/"]";VQD/BU(:6QF92P@86)E<B!M96AR(&%L<R!E
XM:6YE($%U9FQI<W1U;F<\;FP^"F1E<B!V97)W96YD8F%R96X@5&%S=&5N:V]M
XM8FEN871I;VYE;B!B:65T970@<VEE(&YI8VAT("XN+CQN;#X*/&YL/@I$97-S
XM:&%L8B!H:65R(&5I;B!P86%R("AV:65L;&5I8VAT*2!N@71Z;&EC:&4@5&EP
XM<SH\;FP^"CQN;#X*;R \0F]L9#Y714Y$63PO0F]L9#X@=W5R9&4@9H%R(&1E
XM;B!/3DQ)3D4M0F5T<FEE8B!K;VYZ:7!I97)T+B!$97-S:&%L8B!I<W0@<VEE
XM(&EN/&YL/@H@(&1E<B!,86=E('9E<G-C:&EE9&5N<W1E(%1E<FUI;F%L+45M
XM=6QA=&EO;F5N('IU('5N=&5R<W2!='IE;BX\;FP^"CQN;#X*("!,96ED97(@
XM=VER9"!S:64@9&%D=7)C:"!N:6-H="!U;F)E9&EN9W0@<V-H;F5L;&5R+B!"
XM96D@;&%N9W-A;65R96X\;FP^"B @5F5R8FEN9'5N9V5N(&5M<&9I96AL="!S
XM:6-H(&1E<W=E9V5N(&9O;&=E;F1E<SH\;FP^"CQN;#X*(" \0F]L9#Y#5%),
XM+44\+T)O;&0^(&\N(#Q";VQD/D-44DPM4SPO0F]L9#XZ($5I;G-T96QL=6YG
XM(&1E<B!&96YS=&5R9W*4X64@875F(&-A+B Q,"!:96EL96X\;FP^"CQN;#X*
XM;R!-:70@/$)O;&0^0U123"U1/"]";VQD/B!W:7)D(&1E<B!%:6YF@6=E;6]D
XM=7,@86MT:79I97)T+B!!=6-H(&1E<B!S=&5L;'0@;FEC:'0\;FP^"B @9V5R
XM861E(&5I;F5N($)E<V-H;&5U;FEG97(@9&%R+B!$97-S:&%L8B!ME&=L:6-H
XM<W0@;F%C:"!D96T@16EN9H%G92T\;FP^"B @=F]R9V%N9R!D:7)E:W0@=VEE
XM9&5R(&UI=" \0F]L9#Y#5%),+5$\+T)O;&0^(&1E;B!-;V1U<R!B965N9&5N
XM(3QN;#X*/&YL/@IO(%IW87(@:V%N;B!M86X@<V5H<B!S8VB4;B!M:70@/$)O
XM;&0^4$=54#PO0F]L9#XO/$)O;&0^4$=$3CPO0F]L9#X@8GIW+B \0F]L9#Y#
XM5%),+4(\+T)O;&0^+SQ";VQD/D-44DPM1CPO0F]L9#X@8FR$='1E<FXL/&YL
XM/@H@(&%B97(@>G5M($%U9G-U8VAE;B!W96ET(&5N=&9E<FYT97(@5&5X='-T
XM96QL96X@:7-T(&1A<R!Z=2!L86YG<V%M+CQN;#X*/&YL/@H@($UI=" \0F]L
XM9#Y#5%),+4<\+T)O;&0^(&R$<W-T(&UA;B!S:6-H('-T871T(&1E<W-E;B!D
XM:64@6F5I;&5N86YZ86AL(&1E<B!$871E:3QN;#X*("!A=7-G96)E;BP@=6YD
XM('-P<FEN9W0@9&%N;B!M:70@/$)O;&0^15-#.CPO0F]L9#X@6UIE:6QE;FYU
XM;6UE<ET@86X@9&EE(&=E=X%N<V-H=&4\;FP^"B @4W1E;&QE+CQN;#X*/&YL
XM/@H@()IB<FEN9V5N<R!V97)S=&5C:W0@<VEC:"!H:6YT97(@9&5M(#Q";VQD
XM/D530SH\+T)O;&0^(&YO8V@@:V5I;B!K;VUP;&5T=&5R(%9)+4UO9'5S(3QN
XM;#X*/&YL/@IO(%IE:6QE;B!W97)D96X@96EN9V5F@6=T+"!I;F1E;2!M86X@
XM;6ET(#Q";VQD/D-44DPM43PO0F]L9#X@:6X@9&5N($5I;F:!9V5M;V1U<SQN
XM;#X*("!W96-H<V5L="P@=6YD(&1O<G0@;6ET(#Q";VQD/D5.5$52/"]";VQD
XM/B!D96X@5&5X="!U;G1E<B!D97(@86MT=65L;&5N(%IE:6QE('5M/&YL/@H@
XM(&5I;F4@6F5I;&4@=V5I=&5R(&YO8V@@=6YT96X@<H%C:W0N/&YL/@H\;FP^
XM"F\@4V]L;'1E(&1E<B!":6QD<V-H:7)M(&1U8V@@4W24<G5N9V5N(&1U<F-H
XM96EN86YD97(@9V5R871E;B!S96EN+"!LA'-S=#QN;#X*("!E<B!S:6-H(&UI
XM=" \0F]L9#Y#5%),+4P\+T)O;&0^(&\N(#Q";VQD/D-44DPM4CPO0F]L9#X@
XM=VEE9&5R:&5R<W1E;&QE;BX\;FP^"CQN;#X*;R!$:64@9W5T92 \0F]L9#Y7
XM14Y$63PO0F]L9#X@:V%N;B!M87@N(#@P(%IE:6-H96X@<')O(%IE:6QE(&1A
XM<G-T96QL96XN($%U<R!D:65S96T\;FP^"B @1W)U;F0@;8%S<V5N(&R$;F=E
XM<F4@6F5I;&4@=6UG96)R;V-H96X@=V5R9&5N+B!$:65S92 B@6)E<G-T96AE
XM;F1E;B(\;FP^"B @6F5I;&5N('=E<F1E(&1U<F-H(&5I;F4@6WY=(&%M(%IE
XM:6QE;F%N9F%N9R!G96ME;FYZ96EC:&YE="X\;FP^"CQN;#X*("!$87,@:V%N
XM;B!M86X@<VEC:"!Z=6YU='IE(&UA8VAE;BP@=V5N;B!M86X@<V5L8G-T(%IE
XM:6QE;B!M:70@;65H<CQN;#X*("!A;',@.# @6F5I8VAE;B!E<F9A<W-E;B!W
XM:6QL+B!%:6YE(%M^72!A;2!!;F9A;F<@9&5R('IW96ET96X@*"$I('5N9#QN
XM;#X*("!A;&QE<B!W96ET97)E;B!:96EL96X@9V5N@6=T+CQN;#X*/&YL/@IO
XM($EN('9I96QE;B!&A&QL96X@<VEN9"!B96D@06YG86)E;B!Z=2!487-T96YK
XM;VUB:6YA=&EO;F5N('IU<X1T>FQI8V@\;FP^"B @;F]C:"!!=7-D<H%C:V4@
XM875F9V5L:7-T970L(&1I92!S:6-H('=I92!!=69D<G5C:V4@=F]N(%1A<W1E
XM;B!A;FB4<F5N+CQN;#X*("!$87,@8F5D975T970L(&1AX2!M86X@>BY"+B \
XM0F]L9#Y#5%),+48\+T)O;&0^(&1R@6-K96X@:V%N;B!U;2!E:6YE(%-E:71E
XM('9O<GIU+3QN;#X*("!B;(1T=&5R;BP@86)E<B!D87,@9VQE:6-H92!W@7)D
XM92!E:6X@1')U8VL@875F(#Q";VQD/E!'1$X\+T)O;&0^(&)E=VER:V5N+CQN
XM;#X*/&YL/@H@(%=E<B!E:6X@(F%N<W2$;F1I9V5S(B!497)M:6YA;%!21R!B
XM96YU='IT+"!S;VQL=&4@86QS;R!D:64@96YS='!R96-H96YD96X\;FP^"B @
XM5&%S=&5N('-T871T(&1E<B!#5%),+4MO;6)I;F%T:6]N96X@=F5R=V5N9&5N
XM(&N4;FYE;B$\;FP^"CQN;#X*0V]N=&5N="U4>7!E.B!T97AT+W!L86EN.R!C
XM:&%R<V5T/6ES;RTX.#4Y+3$*+2!6;VQK97(@4V-H=65R;6%N;B @(" @(" @
XM(" @(" @(" @(" @(" @(" @(" @("!554-0.B!V;VQK97)S0'5N;F5T+G<N
XM;W!E;BYD90H@(%1H92!5;F1E<F=R;W5N9"!.971W;W)K+"!'97)M86YY(" @
XK(" @(" @(" @(" @(" @(" @(" @(" @(" @("!;0V%R<&4@9&EE;2%="B @
X 
Xend
END_OF_FILE
  if test 4682 -ne `wc -c <'wendy/wendy.dok.U'`; then
    echo shar: \"'wendy/wendy.dok.U'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'wendy/wendy.dok'\" \(3373 characters\)
    cat wendy/wendy.dok.U | uudecode
    if test 3373 -ne `wc -c <'wendy/wendy.dok'`; then
      echo shar: \"'wendy/wendy.dok'\" uudecoded with wrong size!
    else
      rm wendy/wendy.dok.U
    fi
  fi
  # end of 'wendy/wendy.dok.U'
fi
echo shar: End of archive 13 \(of 15\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
