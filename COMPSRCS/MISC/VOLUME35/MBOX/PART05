Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i040:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part05/15
Message-ID: <1993Feb5.185645.10153@sparky.imd.sterling.com>
X-Md4-Signature: 1aedcbb4ea7abae554007a6a7f64f4f2
Date: Fri, 5 Feb 1993 18:56:45 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 40
Archive-name: mbox/part05
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/mbox.english src/tools.c wendy/Makefile
# Wrapped by kent@sparky on Fri Feb  5 12:18:06 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 15)."'
if test -f 'src/mbox.english' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mbox.english'\"
else
  echo shar: Extracting \"'src/mbox.english'\" \(25566 characters\)
  sed "s/^X//" >'src/mbox.english' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  MBOX.MSG "english"				   */
X/*        FUNKTIONEN  Landessprachen-abhaengige Text-Zeilen		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.01.1993					   */
X/***************************************************************************/
X
X/* ?? SysV.getch.c */
X
X/* admin.c */
X
X#define ADM01_MSG	" Administration (Change User) "
X#define ADM01aMSG	" Administration (Show User) "
X#define ADM02_MSG	"UserID/Username:"
X#define ADM03_MSG	"            User-ID:"
X#define ADM04_MSG	"           Username:"
X#define ADM05_MSG	"           Password:"
X#define ADM06_MSG	"         SH-Account:"
X#define ADM07_MSG	"              Alias:"
X#define ADM08_MSG	"           Hometown:"
X#define ADM09_MSG	"             Street:"
X#define ADM10_MSG	"  Telephone (voice):"
X#define ADM11_MSG	"   Telephone (data):"
X#define ADM12_MSG	"      Date of Birth:"
X#define ADM13_MSG	"           Terminal:"
X#define ADM14_MSG	"             Editor:"
X#define ADM15_MSG	"              Level:"
X#define ADM16_MSG	"               More:"
X#define ADM17_MSG	"               Bell:"
X#define ADM18_MSG	"             Prompt:"
X#define ADM19_MSG	"              Lines:"
X#define ADM20_MSG	"          LastLogin:"
X#define ADM21_MSG	"           LastTime:"
X#define ADM21aMSG	"            Account:"
X#define ADM22_MSG	"             Boards:"
X#define ADM23_MSG	"                SEQ:"
X#define ADM24_MSG	" Administration (Change User) "	
X#define ADM25_MSG	" Administration (Delete User) "
X#define ADM26_MSG	"User-ID"
X#define ADM27_MSG	"Username"
X#define ADM28_MSG	"[DELETE] Really?"
X#define ADM29_MSG	"Which?"
X#define ADM30_MSG	"[ADM] More?"
X#define ADM31_MSG	" Administration (The Revenge of the Sysop) "
X#define ADM32_MSG	"Register User"
X#define ADM33_MSG	"Change User"
X#define ADM34_MSG	"Delete User"
X#define ADM35_MSG	"Show User"
X#define ADM36_MSG	"Show List of Users"
X#define ADM37_MSG	"Back to MBox"
X#define ADM38_MSG	" Administration (Setup) "
X#define ADM39_MSG	"Terminal (ANSI, VT100 etc.)"
X#define ADM40_MSG	"Editor (Textprocessor)"
X#define ADM41_MSG	"Prompt (Id, Board, Rates)"
X#define ADM42_MSG	"Output (Textoutput)"
X#define ADM43_MSG	"Address (Personal Data)"
X#define ADM44_MSG	"Password (To be changed regularly!)"
X#define ADM45_MSG	"Intro (Show State and/or Intro MSG?)"
X#define ADM46_MSG	"Scanner (Date of last login)"
X#define ADM47_MSG	"END (Leave Setup)"
X#define ADM48_MSG	" Administration (Terminal) "
X#define ADM49_MSG	"List-Device"
X#define ADM50_MSG	" Administration (Editor) "
X#define ADM51_MSG	" Administration (Prompt) "
X#define ADM52_MSG	"Time & Signal (BELL)         "
X#define ADM53_MSG	"Time                         "
X#define ADM54_MSG	"Board & Signal (BELL)        "
X#define ADM55_MSG	"Board                        "
X#define ADM56_MSG	"Rates & Signal (BELL)        "
X#define ADM57_MSG	"Rates                        "
X#define ADM58_MSG	" Administration (Textoutput) "
X#define ADM59_MSG	"List continuously (TYPE, CAT)"
X#define ADM60_MSG	"Page (Mark end of page)"
X#define ADM61_MSG	"Page (Don't mark end of page)"
X#define ADM62_MSG	"Reading-Direction (OLD <> NEW)"
X#define ADM63_MSG	"Number of Screen-Lines (State-Line?)"
X#define ADM64_MSG	"Format of Article-\"Header\""
X#define ADM64aMSG	"Boards Survey (Number of Columns)"
X#define ADM64bMSG	"Converting German 'Umlauts'"
X#define ADM65_MSG	"Reading-Direction OLD -> NEW"
X#define ADM66_MSG	"Reading-Direction NEW -> OLD"
X#define ADM67_MSG	"Number of Screen-Lines: 24 (State-Line; ProComm etc.)"
X#define ADM68_MSG	"Number of Screen-Lines: 25 (no State-Line)"
X#define ADM68aMSG	"Number of Screen-Lines: 45 (experimental)"
X#define ADM69_MSG	"Original Article-\"Header\" (Total)"	
X#define ADM70_MSG	"Short Output (Author, Subject, Date)"
X#define ADM70aMSG	"Output in two-column Format"
X#define ADM70bMSG	"Output in three Columns"
X#define ADM70cMSG	"Output in four Columns"
X#define ADM70dMSG	"ISO-8859-1 (Amiga, german Keyboard)"
X#define ADM70eMSG	"IBMs german Charset"
X#define ADM70fMSG	"Converting to Substitutes"
X#define ADM70gMSG	"Don't convert anything"
X#define ADM71_MSG	" Administration (Address) "
X#define ADM72_MSG	"At this point, you are able to change ALL personal data (including your"
X#define ADM73_MSG	"Username). To get permission to send NEWS-Articles and external mails,"
X#define ADM74_MSG	"your name and address have to be specified." 
X#define ADM75_MSG	"If the old entries are still correct, you have to use the <ENTER>-key to"
X#define ADM76_MSG	"leave them uncorrected. Otherwise you may enter the new data."
X#define ADM77_MSG	" Administration (Password) "
X#define ADM78_MSG	"New Password:"
X#define ADM79_MSG	"You have to enter more than four characters!" 
X#define ADM80_MSG	"Again, please:"
X#define ADM81_MSG	"<- not identical!!!"
X#define ADM82_MSG	" Administration (Intro) "
X#define ADM83_MSG	"State & intro message"
X#define ADM84_MSG	"State message"
X#define ADM85_MSG	"Intro message"
X#define ADM86_MSG	"No message"
X#define ADM87_MSG	" Administration (Scanner) "
X#define ADM88_MSG	"Date & time of last login are checked"
X#define ADM89_MSG	"Only date is checked"
X#define ADM90_MSG	"Change date & time"
X#define ADM91_MSG	"Everytime the system was assigned to show \"new\" information, "
X#define ADM92_MSG	"it checks the \"date of your last login\" to find out what is new. This date"
X#define ADM93_MSG	"you may change now. The number of \"new\" articles grows more, if you"
X#define ADM94_MSG	"count back further ..."
X#define ADM95_MSG	"New date:"
X#define ADM96_MSG	"New time:"
X#define ADM97_MSG	"Reorganizing"
X
X
X/* ?? befehl.c */
X
X/* bled.c */
X
X#define BLD01_MSG	"Wrong line."
X#define BLD02_MSG	"Transfer starts. (Cancel with CTRL-X !)"
X#define BLD03_MSG	"Syntax error."
X#define BLD04_MSG	"Commands"
X#define BLD05_MSG	".l [LINE]|[FROM,TO]    list"
X#define BLD06_MSG	".L [LINE]|[FROM,TO]    list (don't show line numbers)"
X#define BLD07_MSG	".i AT                  insert"
X#define BLD08_MSG	".a                     append (stops insert mode)"
X#define BLD09_MSG	".c LINE                correct"
X#define BLD10_MSG	".d [LINE]|[FROM,TO]    delete"	
X#define BLD11_MSG	".u                     upload (ASCII text)"
X#define BLD12_MSG	".q                     quit (don't save)"
X#define BLD13_MSG	".h                     help (long text)"
X#define BLD14_MSG	".                      save & quit"
X#define BLD15_MSG	"LINE, FROM, TO, AT are legal line numbers."
X#define BLD16_MSG	"Statements in [brackets] are optional. If there"
X#define BLD17_MSG	"are no values specified: AT=1, FROM=1, TO=32000."
X#define BLD18_MSG	"Help"
X#define BLD19_MSG	"Break. File NOT saved."
X#define BLD20_MSG	"Command not known."
X#define BLD21_MSG	"Process terminated. File saved."
X#define BLD22_MSG	"No file specified."	
X#define BLD23_MSG	"Wait a while ..."
X#define BLD24_MSG	"File"
X#define BLD25_MSG	"contains non-ASCII characters."
X#define BLD26_MSG	"New file."
X#define BLD27_MSG	"File contains"
X#define BLD28_MSG	"lines"	
X#define BLD29_MSG	"Problems ..."
X#define BLD30_MSG	"That's all ..."
X
X
X/* control.c */
X
X#define CTL01_MSG	"Error in errorhandler!!!"
X
X
X/* ?? coreleft.c */
X
X/* ?? ctrlx.c */
X
X/* derror.c */
X
X#define DER01_MSG	"ERROR:"
X#define DER02_MSG	"Error:"
X#define DER03_MSG	"break"
X
X
X/* dis.c */
X
X#define DIS01_MSG	" We are involved in the following discussions: "
X#define DIS02_MSG	"Newsgroup/Board                  Subject                Msg-ID     Date"
X#define DIS03_MSG	"No entries at all."
X#define DIS04_MSG	"Maybe this discussion is yet out of date."
X#define DIS05_MSG	"Start at article no."
X#define DIS06_MSG	"Subject"
X
X
X/* games.c */
X
X#define GA01_MSG	" Onlinegames (Some using ANSI Codes) "
X#define GA02_MSG	"[Games] Which?"
X#define GA03_MSG	"<- Ok, don't play!"
X
X
X/* ?? getch.c */
X
X/* ?? getline.c */
X
X/* help.c */
X
X#define HLP01_MSG	" Helpfunctions (For ix/MBox only) "
X
X
X/* intro.c */
X
X#define INT01_MSG	"Organisation:"
X#define INT02_MSG	"BBS-Software:"
X#define INT03_MSG	"Mailbox-Name:"
X#define INT04_MSG	"Choose a terminal:"
X#define INT05_MSG	"1 - ANSI      2 - VT100      3 - VT52      4 - DUMP      5 - COLOR-ANSI"
X#define INT06_MSG	"Terminal?"
X#define INT07_MSG	"---  Your process was terminated  ---"
X#define INT08_MSG	"User"
X#define INT09_MSG	"logged in"
X#define INT10_MSG	"Login"
X#define INT11_MSG	"Initializing"
X#define INT12_MSG	"That's your"
X#define INT13_MSG	"call to this BBS; On"
X#define INT14_MSG	"you were in last"
X#define INT15_MSG	"There are"
X#define INT16_MSG	"boards with new articles and your mailbox contains"
X#define INT17_MSG	"mails"
X#define INT18_MSG	"Hey, todays your birthday ... yet noticed?"
X#define INT19_MSG	"So I wish you a \"Happy Birthday\" !!!"
X#define INT20_MSG	"MERRY XMAS, and best of holidays to you!"
X#define INT21_MSG	"May Santa Claus bring the \"right\" presents ..."
X#define INT22_MSG	""
X#define INT23_MSG	""
X#define INT24_MSG	"Puhh ... the year is gone at least ..."
X#define INT25_MSG	"So have a nice new one !!!"
X#define INT26_MSG	"There he is, the"
X#define INT27_MSG	"st caller !!!"
X#define INT28_MSG	"Your account for special access rights will be cancled at"
X#define INT29_MSG	"!"
X#define INT30_MSG	"PAY YOUR BILL AS SOON AS POSSIBLE!"
X
X
X/* lesen2.c */
X
X#define LE201_MSG	"Article"
X#define LE202_MSG	"Article:"
X#define LE203_MSG	"<- Can't find that article!"
X#define LE204_MSG	"<- No new articles in here!"
X#define LE205_MSG	"Directory"
X#define LE206_MSG	"Sorry, no new articles ..."
X#define LE207_MSG	"But there are still"
X#define LE208_MSG	"older entries."
X#define LE209_MSG	"And there ain't no older entries, either."
X#define LE210_MSG 	"In this board, there are"
X#define LE211_MSG	"older articles."
X#define LE212_MSG	"In this board, there are no older articles."
X#define LE213_MSG	"<- Can't find that article!"
X#define LE214_MSG	"No corresponding article found ..."
X
X
X/* loop.c */
X
X#define LOP01_MSG	"---  Break  ---"
X#define LOP02_MSG	"---  Your process was terminated  ---"	
X#define LOP03_MSG	"New mail arrived for you ..."
X#define LOP04_MSG	"Cmd:"
X#define LOP05_MSG	" Commandbuffer (1-9) "
X#define LOP06_MSG	"So what?"
X#define LOP07_MSG	"<- No, there couldn't be such stupid users!"
X#define LOP08_MSG	"Commands (At Level"
X#define LOP09_MSG	"Commands (Survey)"
X#define LOP10_MSG	"<- Ridiculous!"
X#define LOP11_MSG	"<- You have to add a command!"
X#define LOP12_MSG	"No help for command"
X#define LOP13_MSG	"available ..."
X#define LOP14_MSG	" Protocol (Calls) "
X#define LOP15_MSG	" Call  User                          Hometown         Terminal  Date      Time"
X#define LOP16_MSG	"No write authorization!"
X#define LOP17_MSG	"Definitions:"
X#define LOP18_MSG	"Date:"
X#define LOP19_MSG	"Time:"	
X#define LOP20_MSG	"Seconds"
X#define LOP21_MSG	"Reading-Directions:"
X#define LOP22_MSG	"New -> Old"
X#define LOP22aMSG	"Old -> New"
X#define LOP23_MSG	" Statistics (NewsSystem) "	
X#define LOP24_MSG	"Date      Time       Boards  Bytes (Bb)     total: Boards  Articles  Bytes (kB)"
X#define LOP25_MSG	" Statistics (UUCP-Rates) "
X#define LOP26_MSG	" Statistics (Download) "
X#define LOP27_MSG	"Date         File                                         CPS     BPS  State"
X#define LOP27aMSG	" Statistics (Mailer XMD) "
X#define LOP27bMSG	"Date   Time    Reciever                        Subject"
X#define LOP28_MSG	"[END] Really?"
X#define LOP29_MSG	"Wait"
X#define LOP30_MSG	"<- Remember, you only have level"
X#define LOP31_MSG	"<- Command not known!"
X#define LOP32_MSG	" Statistics (Download/HITLIST) "
X#define LOP33_MSG	"DNLs   Files"
X#define LOP33aMSG	"Converting 'Umlauts' "
X#define LOP33bMSG	"on"
X#define LOP33cMSG	"off"
X#define LOP34_MSG	" Statistics (Calls per User) "
X#define LOP35_MSG	"Calls    User"
X#define LOP36_MSG	" Any key to stop! "
X
X
X/* mail.c */
X
X#define MAL01_MSG	"You need level"
X#define MAL02_MSG	"to send international mails ..."
X#define MAL03_MSG	"<- No receiver specified!"
X#define MAL04_MSG	"You need level"
X#define MAL05_MSG	"for mailing to external users ..."
X#define MAL06_MSG	"Transmission:"
X#define MAL07_MSG	"<No subject found>"
X#define MAL08_MSG	"Can't find external users address!"
X#define MAL09_MSG	"The user"
X#define MAL10_MSG	"doesn't \"live\" on this host!"
X#define MAL11_MSG	"Mail to"
X#define MAL12_MSG	"W, U, A"
X#define MAL13_MSG	'W'
X#define MAL14_MSG	'U'
X#define MAL15_MSG	'A'
X#define MAL16_MSG	"Write, Upload, reject & Abort"
X#define MAL17_MSG	"[Transfer-Protocol] A, X, Y, Z"
X#define MAL17aMSG	"ASCII (Text), [X-Modem], Y-Modem (Batch), Z-Modem"
X#define MAL18_MSG	'A'
X#define MAL19_MSG	'X'
X#define MAL20_MSG	'Y'
X#define MAL21_MSG	'Z'
X#define MAL22_MSG	"   From:"
X#define MAL23_MSG	"     To:"
X#define MAL23aMSG	"Copy to:"
X#define MAL24_MSG	"Subject:"
X#define MAL25_MSG	"It's not allowed to mail binaries! They will be rejected!"
X#define MAL26_MSG	"Please start transfer now ... cancel with CTRL-X!"
X#define MAL27_MSG	"No mail recieved. Job canceld ..."
X#define MAL28_MSG	"Nothing received!"
X#define MAL28aMSG	"W, A, C, E"
X#define MAL29_MSG	'W'
X#define MAL30_MSG	'A'
X#define MAL30aMSG	'R'
X#define MAL31_MSG	'C'
X#define MAL31aMSG	'E'
X#define MAL32_MSG	"Write & send, Abort, Continue, Edit header"
X#define MAL32aMSG	" Edit Header "
X#define MAL32bMSG	"Receiver"
X#define MAL32cMSG	"unknown!"
X#define MAL33_MSG	"Ok, no mail ..."
X#define MAL34_MSG	"Mail canled!"
X#define MAL35_MSG	"Wait a while ..."
X#define MAL36_MSG	"that's all!"
X#define MAL37_MSG	"sent"
X#define MAL38_MSG	"The current \"hello\" message:"
X#define MAL39_MSG	"[MESSAGE] change?"
X#define MAL40_MSG	"The current signature:"
X#define MAL41_MSG	"[SIGNATURE] change?"
X
X
X/* main.c */
X
X#define MAI01_MSG	"Updating account"
X#define MAI02_MSG	"Connection closed ..."
X#define MAI03_MSG	" Administration (Setup UDBASE) "
X#define MAI04_MSG	"Can't find users DATABASE. Therefore a DATABASE will be established auto-"
X#define MAI05_MSG	"matically. The necessary stuff will be found in 'mbox.h' (have a look there)."
X#define MAI06_MSG	""
X#define MAI07_MSG	"These new DATABASE has to be checked with the command 'admin', or may be" 
X#define MAI08_MSG	"rebuild by deleting the DATABASE - don't forget to change the entries in" 
X#define MAI09_MSG	"'mbox.h' (read the TUTORIAL)."
X#define MAI10_MSG       "The DATABASE is usable now. Please restart \"ix/Mbox\" ..."
X#define MAI11_MSG	"Bye, bye, ..."
X
X
X/* makro.c */
X
X#define MAK01_MSG	"The following macros are declared:"
X#define MAK02_MSG	"[MACROS] Change?"
X#define MAK03_MSG	"Macro declared."
X#define MAK04_MSG	"<- Error in macro declaration!"
X
X
X/* mb-daemon.c */
X
X#define MBD01_MSG	"New articles"
X#define MBD02_MSG	"Yet scanned articles"
X#define MBD03_MSG	"Today there are"
X#define MBD04_MSG	"new borads with"
X#define MBD05_MSG	"kbytes"
X#define MBD06_MSG	"In total"
X#define MBD07_MSG	"groups there are"
X#define MBD08_MSG	"articles with"
X#define MBD09_MSG	"kbytes"
X
X/* ?? mbrsh.c */
X
X/* misc.c */
X
X#define MIS01_MSG	"<- No new boards available."
X#define MIS02_MSG	"is not a NEWSGROUP!"
X#define MIS02aMSG	"Not allowed! (See: \"Followup-To:\")"
X#define MIS03_MSG	"     From:"
X#define MIS04_MSG	"       To:"	
X#define MIS05_MSG	"  Subject:"
X#define MIS06_MSG	" Keywords:"
X#define MIS07_MSG	"  Summary:"
X#define MIS08_MSG	"W, U, A"
X#define MIS09_MSG	'W'
X#define MIS10_MSG	'U'
X#define MIS11_MSG	'A'
X#define MIS12_MSG	"Write, Upload, reject & Abort"
X#define MIS13_MSG	"[Transfer-Protocol] A, [X], Y, Z"
X#define MIS14_MSG	"ASCII (Text), [X-Modem], Y-Modem (Batch), Z-Modem"
X#define MIS15_MSG	'A'
X#define MIS16_MSG 	'X'
X#define MIS17_MSG	'Y'
X#define MIS18_MSG	'Z'
X#define MIS19_MSG	"Please start transfer now ... cancel with CTRL-X!"
X#define MIS20_MSG	"Nothing received, no new article ..."
X#define MIS21_MSG	"Upload hasn't received data!"
X#define MIS22_MSG	"binaryfile"
X#define MIS23_MSG	"textfile"
X#define MIS24_MSG	"bytes of a"
X#define MIS25_MSG	"received"
X#define MIS26_MSG	"The effective transfer-rate was"
X#define MIS27_MSG	"W, A, C"
X#define MIS28_MSG	"W, A"
X#define MIS29_MSG	'W'
X#define MIS30_MSG	'A'
X#define MIS31_MSG	'C'
X#define MIS31aMSG	"E"
X#define MIS32_MSG	"Write & send, Abort, Continue, Edit header"	
X#define MIS33_MSG	"Write & send, Abort, Edit header"
X#define MIS34_MSG	"Writing ..."
X#define MIS35_MSG	"Ok, no new article ..."
X#define MIS36_MSG	"Article rejected!"
X#define MIS37_MSG	"Message to"
X#define MIS38_MSG	"sent"
X#define MIS38aMSG	" Edit Header "
X#define MIS39_MSG	"The new article will be available in 30 seconds."
X#define MIS40_MSG	"<- Options are not allowed ..."
X#define MIS41_MSG	"<- Wrong option  ..."
X#define MIS42_MSG	"Message:"
X#define MIS43_MSG	"Article"
X#define MIS44_MSG	"Message:"
X#define MIS45_MSG	"Personal message"
X#define MIS46_MSG	"A, R, S, D, N, P"
X#define MIS47_MSG	'A'
X#define MIS48_MSG  	'R'
X#define MIS49_MSG	'S'
X#define MIS50_MSG	'D'
X#define MIS51_MSG	'N'
X#define MIS52_MSG	'P'
X#define MIS53_MSG	"Abort, Reply, Show again, Delete, Next one, Previous one"
X#define MIS54_MSG	"[DELETE] really?"
X#define MIS55_MSG	"No more new articles in this board!"
X#define MIS56_MSG	"There are no older articles!"
X#define MIS57_MSG	" Reply in progress (Searching path etc. ...) "
X#define MIS58_MSG	"Wait a while ..."
X#define MIS59_MSG	"[REPLY] A, B"
X#define MIS60_MSG	"Send to Author or Board?"
X#define MIS61_MSG	'A'
X#define MIS62_MSG	'B'
X
X
X
X/* misc2.c */
X
X#define MI201_MSG	"<- Wrong option ..."
X#define MI202_MSG	"<- Not with level"
X#define MI203_MSG	"The index will be available in 30 seconds."
X#define MI204_MSG	"Board/Group:"
X#define MI204aMSG	"Description:"
X#define MI204bMSG	"Your personal maildrop"
X#define MI205_MSG	" Boards (Level"
X#define MI206_MSG	"No boards with new articles found ..."
X#define MI207_MSG	"Board"	
X#define MI208_MSG	
X#define MI209_MSG	
X#define MI210_MSG	"<- No access "
X#define MI211_MSG	"Building index"
X
X
X/* nerror.c */
X
X#define NER01_MSG	"ERROR:"
X#define NER02_MSG	"Error:"
X#define NER03_MSG	"break"
X
X
X/* pd.c */
X
X#define PD01_MSG	"Can't list this article. It contains an executable program."
X#define PD02_MSG	"Contents:"
X#define PD03_MSG	"[PROGRAM] Transmit?"
X#define PD04_MSG	
X#define PD05_MSG	
X#define PD06_MSG	'Q'
X#define PD07_MSG	"Transfer-Protocol"
X#define PD08_MSG	'A'
X#define PD09_MSG	'X'
X#define PD10_MSG	'Y'
X#define PD11_MSG	'Z'
X#define PD12_MSG	"ASCII (UUE), X-Modem, Y-Modem, Z-Modem"
X#define PD13_MSG	"Please start transfer now ... cancel with CTRL-X !"
X#define PD14_MSG	"Transfer probably (!) interrupted ..."
X#define PD15_MSG	"bytes transmitted"
X#define PD16_MSG	"The effective transfer-rate was"
X#define PD17_MSG	"BREAK"
X#define PD18_MSG	"State (UserID"
X#define PD19_MSG	"Address                    Alias(es)         Date of Birth    Telephone"
X#define PD20_MSG	"Terminal  Editor  Level  Bell  Prompt  More  Intro   Calls  Last Call"
X#define PD21_MSG	"Onlinetime (min. total)     Bytes (kB Upload)         Bytes (kB Download)"
X#define PD22_MSG	"UUCP-Adresse(es)                                      Accounted until"
X#define PD22aMSG	"Accounted until"
X#define PD23_MSG	"Subnet"
X#define PD24_MSG	"Bang"
X#define PD25_MSG	"Local"
X#define PD26_MSG	"Newsgroup(s)"
X#define PD27_MSG	" Statistics (Login) "
X#define PD28_MSG   	"Date         \"Daytime\"  \"Nightshift\"       Total    Diagram"
X#define PD29_MSG	"<Su>"
X#define PD30_MSG	"<Sa>"
X#define PD31_MSG	"Total       "
X#define PD32_MSG	"Diagram"
X#define PD33_MSG	"The line \"Total\" refers to the calls of the last"
X#define PD34_MSG	"days"
X#define PD35_MSG	"Transaktion failed! No such articles located."
X#define PD36_MSG	"Assembling articles. Wait"
X#define PD37_MSG	" Compressing/Archiving Tools "
X#define PD38_MSG	"Which?"
X#define PD39_MSG	"Wait"
X#define PD40_MSG	"NOTE: "
X#define PD41_MSG	"The files have to be packed before compressing!"
X#define PD42_MSG	"The archive"
X#define PD43_MSG	"contains"
X#define PD44_MSG	"Bytes"
X#define PD45_MSG	"Only the articles from"
X#define PD46_MSG	"upto"
X#define PD47_MSG	"have been copied!"
X
X
X/* portinfo.c */
X
X#define POR01_MSG	" Portinfo (external/internal) "
X#define POR02_MSG	"User                             Terminal   Login   Process"
X#define POR03_MSG	"Wait a moment"
X#define POR04_MSG	" Level (Survey) "
X#define POR05_MSG	"Option/Description         required level"
X#define POR06_MSG	"Visitor (Guest) ....................."
X#define POR07_MSG	"Write (internal Mail) ..............."
X#define POR08_MSG	"Write (external Mail) ..............."
X#define POR09_MSG	"Write (NEWS Articles) ..............."
X#define POR10_MSG	"Write (international Mail) .........."
X#define POR11_MSG	"Freeware (Download) ................."
X#define POR12_MSG	"Freeware (Upload) ..................."
X#define POR13_MSG	"OS-Shell ............................"
X#define POR14_MSG	"Administration (Postmaster) ........."
X#define POR15_MSG	"And we are on level"
X#define POR15aMSG	" List of Users "
X#define POR16_MSG	"User                            Last Call      Calls   Online   Level   Account"
X#define POR17_MSG	"Wait a while ..."
X#define POR18_MSG	"User                              Upload       Download      Online"
X#define POR18aMSG	"User                               ID     Account (until)"
X#define POR18bMSG	"User               ID  Level  Newsgroups"
X#define POR19_MSG	"Users with <?> mark should check their accounting-data (something is missing)."
X#define POR20_MSG	"All {-} entries will be deleted at next update."  
X#define POR21_MSG	"Momentary"
X#define POR22_MSG	"users are on this BBS. Thereof"
X#define POR23_MSG	"are regularly active."
X#define POR24_MSG	"And besides"
X#define POR25_MSG	"guests have looked around here."
X#define POR25aMSG	"Informations about the external user"
X#define POR25bMSG	"will be ordered on"
X#define POR25cMSG	"via UUCP"
X#define POR26_MSG	"Look for an answers in your mailbox the next days!"
X#define POR26aMSG	"Illegal DOMAIN-Address!"
X#define POR27_MSG	"User not known."
X#define POR28_MSG	"Userinformation"
X#define POR29_MSG	"       User-ID:"
X#define POR30_MSG	"      Username:"
X#define POR31_MSG	" Shell-Account:"
X#define POR32_MSG	"         Alias:"
X#define POR33_MSG	"      Internet:"
X#define POR34_MSG	"      Hometown:"
X#define POR35_MSG	"        Street:"
X#define POR36_MSG	"     Telephone:"
X#define POR37_MSG	" Date of Birth:"
X#define POR38_MSG	" Calls (total):"
X#define POR39_MSG	"     Last Call:"
X#define POR40_MSG	"   Time Online:"
X#define POR41_MSG	"day(s)"
X#define POR41aMSG	"hour(s)"
X#define POR41bMSG	"minute(s)"
X#define POR41cMSG	" Account until:"
X#define POR42_MSG       "        Upload:"
X#define POR43_MSG	"kByte(s)"
X#define POR44_MSG	"      Download:"
X#define POR45_MSG	"         Mails:"
X
X
X
X/* postfach.c */
X
X#define POS01_MSG	"<- Don't you think that one account is enough ?"
X#define POS02_MSG	
X#define POS03_MSG	"Guest"
X#define POS04_MSG	"User No.1"
X#define POS05_MSG	"User No.2"
X#define POS06_MSG	" Administration (Registration) "
X#define POS07_MSG	"Your personal data will be stored for administrative purpose!"
X#define POS08_MSG	"The sysop can't give any guarantees for the security of your data, because"
X#define POS09_MSG	"this hosts allows shell-accounting, too." 
X#define POS10_MSG	"First name and name (Username=Realname):"
X#define POS11_MSG	"Ok, ok, no account ..."
X#define POS12_MSG	"Checking ... wait a while, please ..."
X#define POS13_MSG	"yet accounted!!!"
X#define POS14_MSG	"                               Password:"
X#define POS15_MSG	"More than four characters!!!"
X#define POS16_MSG	"                  Alias (for UUCP etc.):"
X#define POS17_MSG	"                               Hometown:"
X#define POS18_MSG	"                                 Street:"
X#define POS19_MSG	"                      Telephone (VOICE):"
X#define POS20_MSG	"                       Telephone (DATA):"
X#define POS21_MSG	"                          Date of Birth:"
X#define POS22_MSG	"You now have an account and a maildrop on this host. As soon as your data"
X#define POS23_MSG	"is checked, your \"LEVEL\" will be raised."
X#define POS24_MSG	"New account for"
X#define POS24aMSG	"!You have to 'make world' first!"
X#define POS25_MSG	"Reorganizing"	
X#define POS26_MSG	"New user"
X
X
X/* show.c */
X
X#define SHO01_MSG
X#define SHO02_MSG
X#define SHO03_MSG
X#define SHO04_MSG	"MORE"
X#define SHO05_MSG	"Show again, Abort, Leave or use \"SPACE\"-bar to continue"
X#define SHO06_MSG	'L'
X#define SHO07_MSG	'X'
X#define SHO08_MSG	'Q'
X#define SHO09_MSG	'A'
X#define SHO10_MSG	'S'
X#define SHO11_MSG	"Repetition ..."
X#define SHO12_MSG	"Page"
X
X
X/* suchen.c */
X
X#define SUC01_MSG	"Searchpattern:"
X#define SUC02_MSG	"Ok, don't search!"
X#define SUC03_MSG	"Searching for"
X#define SUC04_MSG	"in"
X#define SUC05_MSG	"Wait a moment"
X#define SUC06_MSG	"No articles including pattern"	
X#define SUC07_MSG	"found."	
X#define SUC07aMSG	"Which article?"
X#define SUC08_MSG	"Your own mail ... WHY ???"
X#define SUC09_MSG	"No permissions!"
X#define SUC10_MSG	"Can't find that!"
X
X
X/* tools.c */
X
X#define TOL01_MSG	"Sunday"
X#define TOL02_MSG	"Monday"
X#define TOL03_MSG	"Tuesday"
X#define TOL04_MSG	"Wednesday"
X#define TOL05_MSG	"Thursday"
X#define TOL06_MSG	"Friday"
X#define TOL07_MSG	"Saturday"
X#define TOL08_MSG	"Wait a moment"
X
X
X/* weiterl.c */
X
X#define WEI01_MSG	"<- No messages stored."
X#define WEI02_MSG	"Stored message(s):"
X#define WEI03_MSG	"Subject:"
X#define WEI04_MSG	"<- Article not found!"
X
X
X/* xmd.c */
X
X#define XMD01_MSG	"Mail from an \"external\" user"
X#define XMD02_MSG	"---------  Message follows  ---------"
X
X
X/*  G L O B A L  */
X
X#define GBL01_MSG	"Author:"
X
X#define GBL02_MSG	"Date:"
X#define GBL03_MSG	"Subject:"
X
X#define GBL04_MSG	"Username:"
X#define GBL05_MSG	"No.   Subject                     Author                Date      Time   Lines"
X
X#define GBL06_MSG	'Y' 	/* YES !!!!! */
X#define GBL07_MSG	'N'	/* NO !!!!!! */
X
X#define GBL08_MSG	"No.   Subject                     Author                Date      Time   kBytes"
X#define GBL09_MSG	"Password:"
X
X#define GBL10_MSG	"guest"
END_OF_FILE
  if test 25566 -ne `wc -c <'src/mbox.english'`; then
    echo shar: \"'src/mbox.english'\" unpacked with wrong size!
  fi
  # end of 'src/mbox.english'
fi
if test -f 'src/tools.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/tools.c'\"
else
  echo shar: Extracting \"'src/tools.c'\" \(24683 characters\)
  sed "s/^X//" >'src/tools.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  tools.c						   */
X/*        FUNKTIONEN  whoami(), tty(), stripped(), upcased(), length(),    */
X/*		      strcopy(), strcomp(), ansi2(), mydate(), mytime(),   */
X/*	              crypted(), dateconv(), datereconv(), timeconv(),     */
X/*		      timereconv(), maybe_locked(), num_stripped(),        */
X/*		      rename(), headline(), ttyna(), bigcopy(), mblock(),  */
X/*		      mbunlock(), shortname(), clearline(), isin()	   */
X/*		      termansi(), sgrep()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  18.12.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X#include <unistd.h>
X#include <time.h>
X#include <pwd.h>
X
X#ifdef _SYS7
X#include <termcap.h>
X#endif
X
X
X#ifdef _MBOX
X#define EXTERN
X#include "mbox.h"
X#else
X#define VERSION "TOOLS.C"
X#define CR 13
X#define TOL01_MSG	"Sonntag"
X#define TOL02_MSG	"Montag"
X#define TOL03_MSG	"Dienstag"
X#define TOL04_MSG	"Mittwoch"
X#define TOL05_MSG	"Donnerstag"
X#define TOL06_MSG	"Freitag"
X#define TOL07_MSG	"Samstag"
X#define TOL08_MSG	"Momentchen"
X#endif
X#ifdef STRING
X#undef STRING
X#endif
X
X#ifdef LONGSTRING
X#undef LONGSTRING
X#endif
X
X#define STRING 81
X#define LONGSTRING 256
X
Xunsigned char headinfo[STRING];
X
X
X/***************************************************************************/
X/*      FUNKTION  whoami()						   */
X/*  BESCHREIBUNG  Name des eigenen SH-Accounts.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xunsigned char *whoami()
X{
X  struct passwd *pw_entry;
X
X  pw_entry = getpwuid(getuid());
X
X  if (pw_entry->pw_uid < 0) return (unsigned char *) "OOPS";
X
X  return (unsigned char *) (pw_entry->pw_name);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  stripped()						   */
X/*  BESCHREIBUNG  STRING von fuehrenden und folgenden Leerzeichen be-      */
X/*		  freien.                                                  */
X/*     PARAMETER  st  =  STRING inclusive Leerzeichen                      */
X/*     RUECKGABE  STRING exclusive Leerzeichen                             */
X/***************************************************************************/
X
Xunsigned char *stripped(st)
Xunsigned char st[];
X{
X  static unsigned char s[STRING];
X
X  int i = 0, a = 0, b = 0, c = 0;
X
X  if (st[0] == '\0') return (unsigned char *) '\0';
X  if ((st[0] == 10) || (st[0] == 13)) return (unsigned char *) " ";
X
X  strcpy(s, st);
X
X  while ((s[i] < 33) && (s[i] != '\0')) i++;
X  a = i;
X  while (s[a] != '\0') a++;
X  a--;
X  while (s[a] < 33) a--;
X
X  for (c = i; c <= a; c++) {
X	s[b] = s[c];
X	b++;
X  }
X  s[b] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  upcased()						   */
X/*  BESCHREIBUNG  Zeichen eines STRING auf Grossbuchstaben umstellen.	   */
X/*     PARAMETER  st  =  STRING mit Gross-/Kleinbuchstaben		   */
X/*     RUECKGABE  STRING in Grossbuchstaben                                */
X/***************************************************************************/
X
Xunsigned char *upcased(st)
Xunsigned char st[];
X{
X  static unsigned char s[STRING];
X
X  int i = 0;
X
X
X  strcpy(s, st);
X
X  while (s[i] != '\0') {
X	if (s[i] > 96) s[i] -= 32;
X	i++;
X  }
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  length()						   */
X/*  BESCHREIBUNG  Laenge eines STRING ermitteln (ja, ja, "strlen" ...)	   */
X/*     PARAMETER  st  =  STRING                                            */
X/*     RUECKGABE  Laenge des STRING                                        */
X/***************************************************************************/
X
Xint length(st)
Xunsigned char st[];
X{
X  int i = 0;
X
X  while (st[i] != '\0') i++;
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcopy()						   */
X/*  BESCHREIBUNG  Einen TeilSTRING aus einem STRING herausschneiden.       */
X/*     PARAMETER  st  =  STRING                                            */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilSTRING                                               */
X/***************************************************************************/
X
Xunsigned char *strcopy(st, v, b)
Xunsigned char st[];
Xint v, b;
X{
X  static unsigned char s[STRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  bigcopy()						   */
X/*  BESCHREIBUNG  Einen TeilLONGSTRING aus LONGSTRING herausschneiden.     */
X/*     PARAMETER  st  =  LONGSTRING                                        */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilLONGSTRING                                           */
X/***************************************************************************/
X
Xunsigned char *bigcopy(st, v, b)
Xunsigned char st[];
Xint v, b;
X{
X  static unsigned char s[LONGSTRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcomp()						   */
X/*  BESCHREIBUNG  Zwei STRINGs vergleichen. Und zwar genau solange, bis    */
X/*		  bei STRING1 das Ende ('\0') erreicht ist !!!             */
X/*                Gross-/Kleinschreibung wird dabei IGNORIERT !!!          */
X/*     PARAMETER  st  =  STRING1                                           */
X/*	          tt  =  STRING2                                           */
X/*     RUECKGABE  Anzahl der UNGLEICHEN Zeichen                            */
X/***************************************************************************/
X
Xint strcomp(s, t)
Xunsigned char s[], t[];
X{
X  int i = 0, a = 0;
X  int s1, t1;
X
X  while (s[i] != '\0') {
X	s1 = s[i];
X	t1 = t[i];
X	if ((t1 > 96) && (t1 < 123)) t1 -= 32;
X	if ((s1 > 96) && (s1 < 123)) s1 -= 32;
X	if (t1 != s1) a++;
X	i++;
X  }
X  return a;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ansi2()						   */
X/*  BESCHREIBUNG  TERMCAP-Eintrag fuer ein Terminal in "buf" einlesen,     */
X/*		  und angeforderte Sequenzen finden & ausgeben.            */
X/*     PARAMETER  code  =  'INIT'  =  Eintrag holen und speichern	   */
X/*		  	           =  Sequenz finden & ausgeben            */
X/*     RUECKGABE  -1  =  Terminal nicht gefunden                           */
X/*		   1  =  Sequenz nicht gefunden				   */
X/***************************************************************************/
X
Xstatic unsigned char buf[1024];
X
Xint ansi(code)
Xunsigned char code[];
X{
X  ansi2(code, 0, 0);
X}
X
Xint ansi2(code, x, y)
Xunsigned char code[];
Xint x, y;
X{
X  unsigned char *getenv();
X  static unsigned char s[STRING];
X  unsigned char *p = s;
X  unsigned char *term;
X
X#ifdef _MBOX
X  term = TERMINAL;
X#else
X  term = getenv("TERM");
X#endif
X
X  if ((x == -1) && (y == -1)) {
X	if (tgetent(buf, code) != 1) return -1;
X  }
X  if (strcomp("INIT", code) == 0) {
X	if (tgetent(buf, term) != 1) return -1;
X  }
X  if (strcomp("cm", code) == 0) {
X	if (tgetstr(code, &p) == 0) return 1;
X	printf("%s", (unsigned char *) tgoto( s, (x -1), (y -1) ));
X	return 0;
X  }
X  else{
X	if (tgetstr(code, &p) == 0) return 1;
X  }
X
X  printf("%s", s);
X
X  return 0;
X}
X
Xunsigned char *termansi(code)
Xunsigned char code[];
X{
X  unsigned char *getenv();
X  unsigned char s[STRING];
X  unsigned char *p = s;
X  unsigned char *term;
X
X#ifdef _MBOX
X  term = TERMINAL;
X#else
X  term = getenv("TERM");
X#endif
X
X  if (strcomp("INIT", code) == 0) {
X	if (tgetent(buf, term) != 1) return (unsigned char *) '\0';
X  }
X  if (tgetstr(code, &p) == 0) return (unsigned char *) '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mydate()						   */
X/*  BESCHREIBUNG  Tagesdatum liefern.  					   */
X/*     PARAMETER  mode  =  0  =  tt.mm.yyyy				   */
X/*			   1  =  tt.mm.yy				   */
X/*			   2  =  ttt					   */	
X/*     RUECKGABE  Datum                                                    */
X/***************************************************************************/
X
X#define TZS      1
X
Xunsigned char *mydate(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X  unsigned char wt[8][11];
X
X  static unsigned char s[STRING];
X
X#ifndef _MBOX
X  strcpy(wt[0], "Sonntag");
X  strcpy(wt[1], "Montag");
X  strcpy(wt[2], "Dienstag");
X  strcpy(wt[3], "Mittwoch");
X  strcpy(wt[4], "Donnerstag");
X  strcpy(wt[5], "Freitag");
X  strcpy(wt[6], "Samstag");
X#else
X  strcpy(wt[0], TOL01_MSG);
X  strcpy(wt[1], TOL02_MSG);
X  strcpy(wt[2], TOL03_MSG);
X  strcpy(wt[3], TOL04_MSG);
X  strcpy(wt[4], TOL05_MSG);
X  strcpy(wt[5], TOL06_MSG);
X  strcpy(wt[6], TOL07_MSG);
X#endif
X
X  time(&tt);
X  tp = localtime(&tt);
X  if (mode == 0) {
X	sprintf(s, "%02.2d.%02.2d.%04.4d", tp->tm_mday, tp->tm_mon + TZS, 1900 + tp->tm_year);
X  }
X  if (mode == 1) {
X	sprintf(s, "%02.2d.%02.2d.%02.2d", tp->tm_mday, tp->tm_mon + TZS, tp->tm_year);
X  }
X  if (mode == 2) {
X	sprintf(s, "%s", wt[tp->tm_wday]);
X  }
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mytime()						   */
X/*  BESCHREIBUNG  Tageszeit liefern.  					   */
X/*     PARAMETER  mode  =  0  =  hh:mm:ss				   */
X/*			   1  =  hh:mm	 				   */
X/*     RUECKGABE  Zeit                                                     */
X/***************************************************************************/
X
Xunsigned char *mytime(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X
X  static unsigned char s[STRING];
X
X  time(&tt);
X  tp = localtime(&tt);
X  sprintf(s, "%02.2d:%02.2d:%02.2d", tp->tm_hour, tp->tm_min, tp->tm_sec);
X
X  if (mode == 1) s[5] = '\0';
X
X  return (unsigned char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  crypted()						   */
X/*  BESCHREIBUNG  STRING verschluesseln und zurueckgeben.		   */
X/*     PARAMETER  s  =  STRING                                             */
X/*     RUECKGABE  Verschluesselter STRING                                  */
X/***************************************************************************/
X
Xunsigned char *crypted(s)
Xunsigned char s[];
X{
X  static unsigned char t[STRING];
X  int i, a;
X
X
X  strcpy(t, s);
X  i = 0;
X  a = 2;
X  while (t[i] != '\0') {
X	t[i] = (t[i] / a) + 32;
X	i++;
X	a++;
X	if (a > 5) a = 2;
X  }
X
X  return (unsigned char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  dateconv() 						   */
X/*  BESCHREIBUNG  Datum (STRING) in Datum (LONG) wandeln.		   */
X/*     PARAMETER  d  =  Datum (STRING)                                     */
X/*     RUECKGABE  Datum (LONG)                                             */
X/***************************************************************************/
X
Xlong dateconv(d)
Xunsigned char d[];
X{
X  unsigned char s[STRING];
X  int a, b, i;
X
X
X  strcpy(s, (unsigned char *) strcopy(d, 0, 1));
X  a = atoi(s);
X  strcpy(s, (unsigned char *) strcopy(d, 3, 4));
X  b = atoi(s);
X  strcpy(s, (unsigned char *) strcopy(d, 6, 9));
X  i = atoi(s);
X  if (i < 1900) i += 1900;
X
X  sprintf(s, "%4.4d%02.2d%02.2d", i, b, a);
X
X  return atol(s);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  datereconv() 						   */
X/*  BESCHREIBUNG  Datum (LONG) in Datum (STRING) wandeln.		   */
X/*     PARAMETER  l  =  Datum (LONG)                                       */
X/*     RUECKGABE  Datum (STRING)                                           */
X/***************************************************************************/
X
Xunsigned char *datereconv(l)
Xlong l;
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X
X
X  if (l < 19000000)
X	sprintf(s, "%ld", 1900000L + l);
X  else
X	sprintf(s, "%ld", l);
X
X  strcpy(t, (unsigned char *) strcopy(s, 6, 7));
X  strcat(t, ".");
X  strcat(t, (unsigned char *) strcopy(s, 4, 5));
X  strcat(t, ".");
X  strcat(t, (unsigned char *) strcopy(s, 0, 3));
X
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timeconv() 						   */
X/*  BESCHREIBUNG  Zeit (STRING) in Zeit (LONG) wandeln.			   */
X/*     PARAMETER  t  =  Zeit (STRING)                                      */
X/*     RUECKGABE  Zeit (LONG)                                              */
X/***************************************************************************/
X
Xint timeconv(t)
Xunsigned char t[];
X{
X  unsigned char s[STRING];
X  int i = 0;
X
X
X  strcpy(s, (unsigned char *) strcopy(t, 0, 1));
X  i = 100 * atoi(s);
X  strcpy(s, (unsigned char *) strcopy(t, 3, 4));
X  i += atoi(s);
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timereconv() 						   */
X/*  BESCHREIBUNG  Zeit (LONG) in Zeit (STRING) wandeln.			   */
X/*     PARAMETER  i  =  Zeit (LONG)                                        */
X/*     RUECKGABE  Zeit (STRING)                                            */
X/***************************************************************************/
X
Xunsigned char *timereconv(i)
Xint i;
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X
X
X  if (i < 10000)
X	sprintf(s, "%04.4d00", i);
X  else
X	sprintf(s, "%06.6d", i);
X
X  strcpy(t, (unsigned char *) strcopy(s, 0, 1));
X  strcat(t, ":");
X  strcat(t, (unsigned char *) strcopy(s, 2, 3));
X  strcat(t, ":");
X  strcat(t, (unsigned char *) strcopy(s, 4, 5));
X
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  shortname() 						   */
X/*  BESCHREIBUNG  Wandelt lange Namen (NGs) ins 14-Zeichenformat, um Ver-  */
X/*                Wechslungen zu vermeiden:				   */
X/*									   */
X/*		      comp.protocols.tcp-ip.sources.wanted		   */
X/*                =>  com0ces.wanted					   */
X/*							                   */
X/*     PARAMETER  longname : langer Name                                   */
X/*									   */
X/*   									   */
X/*     RUECKGABE  s : kurzer Name                                          */
X/***************************************************************************/
X
Xunsigned char *shortname( longname )
Xunsigned char longname[];
X{
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X
X  int i = 0, j = 0;
X
X  strcpy(s, longname);
X
X  strcpy(t, longname);
X
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X
X  i = strlen(t);
X
X  if((i - j) < 15) return (unsigned char *) s;
X
X  s[j + 3] = '0'; s[j + 4] = '\0';
X  strcat(s, (unsigned char *) strcopy(t, (i-10), i));
X
X  return (unsigned char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  maybe_locked()					   */
X/*  BESCHREIBUNG  Um sicherzustellen das eine Datei, die eigentlich vor-   */
X/*		  handen sein MUSS, wirklich nicht da ist (und nicht nur   */
X/*		  gerade von einem anderen Task benutzt wird), verzoegert  */
X/*		  diese Funktion die Fehlermeldung um eine festgelegte     */
X/*		  Zeitspanne.                                              */
X/*     PARAMETER  name  =  Dateiname				           */
X/*		  mode  =  Zugriffsmodus (sollte NICHT verwendet werden !) */
X/*     RUECKGABE   0    =  Datei erreichbar				   */
X/*		  -1    =  Datei nicht verfuegbar			   */
X/***************************************************************************/
X
Xint maybe_locked(name, mode)
Xunsigned char name[], mode[];
X{
X  FILE *fp;
X  int i = 0, LCK = 0;
X  unsigned char s[STRING];
X
X  sprintf(s, "%s.LCK", name);
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  TRY_TWICE:
X
X  fp = NULL;
X
X  do {
X	if(fp != NULL) fclose(fp);
X	fp = fopen(s, "r");
X	i++;
X	if (fp != NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);
X		printf(".");
X		sleep(3);
X	}
X  } while ((i < 8) && (fp != 0));
X
X  if(fp != 0){
X	fclose(fp);
X#ifdef _MBOX
X	mbunlock(name);  /* <--- DAS IST NATUERLICH NICHT KORREKT !!! */
X	goto TRY_TWICE;  /* <--- DAS AUCH NICHT !!! */
X	nerror("tools.c", 566, "maybe_locked", "Datei gesperrt", name);	
X#else
X	printf("\n\nDatei >>%s<< gesperrt !!!\n\n", name);
X#endif
X	exit( -1 );
X  }
X
X  i = 0;
X
X  do {
X	fp = fopen(name, "r");	/* "r" => "mode", aber VORSICHT ! */
X	i++;
X	if (fp == NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);	
X		printf(".");
X		sync();
X		sleep(3);
X	}
X  } while ((i < 5) && (fp == NULL));
X
X  if (fp == NULL) return -1;
X
X  fclose(fp);
X  return 0;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  num_stripped()					   */
X/*  BESCHREIBUNG  Entfernt alle Ziffern aus STRING.			   */
X/*     PARAMETER  s  =  STRING (incl. Ziffern)				   */
X/*     RUECKGABE  STRING (excl. Ziffern)				   */
X/***************************************************************************/
X
Xunsigned char *numstripped(s)
Xunsigned char s[];
X{
X  static unsigned char t[STRING];
X  int i = 0, a = 0;
X
X  while (s[i] != '\0') {
X	if (((s[i] > 64) && (s[i] < 127)) || (s[i] == ' ') || (s[i] == '-')) {
X		t[a] = s[i];
X		a++;
X	}
X	i++;
X  }
X  t[a] = '\0';
X
X  return (unsigned char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  rename()						   */
X/*  BESCHREIBUNG  Benennt Datei1 in Datei2 um (ok, gelogen ... Datei1 wird */
X/*		  in Datei2 kopiert).                                      */
X/*     PARAMETER  alt  =  Datei1                                           */
X/*		  neu  =  Datei2                                           */
X/*     RUECKGABE   0   =  ok                                               */
X/*		  -1   =  Datei1 nicht gefunden				   */
X/***************************************************************************/
X
X#ifndef _ANSI
X
Xint rename(alt, neu)
Xunsigned char *alt[], *neu[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  unsigned char s[250];
X
X  fp = fopen(neu, "w");
X  if (fp == NULL) {
X	return -1;
X  }
X  ff = fopen(alt, "r");
X  if (ff == NULL) {
X	return -2;
X  }
X  while (fgets(s, 250, ff) != NULL) {
X	fputs(s, fp);
X  }
X
X  fclose(fp);
X  fclose(ff);
X
X  unlink(alt);
X
X  return 0;
X}
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  headline()						   */
X/*  BESCHREIBUNG  Ueberschrift mit Ansage-Text ausgeben. Vorher wird der   */
X/*		  der Bildschirm geloescht (falls moegliche) und auf	   */
X/*		  negative Darstellung umgeschaltet.                       */
X/*     PARAMETER  line  =  Ansage-Text					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid headline(line)
Xunsigned char line[];
X{
X  unsigned char ex[255];
X  int i;
X
X
X  strcpy(ex, line);
X  i = 0;
X  while(line[i] != '\0'){
X	if(line[i] == '^'){
X		strcpy(ex, (unsigned char *) strcopy(line, 0, (i-1)));
X		line[i] = ' ';
X	}
X	i++;
X  }
X  strcpy(headinfo, ex);
X  sprintf(ex, "%s                                                                          ", line);
X  ex[79] = '\0';
X  if (ansi("cl") != -1) {
X	if (ansi("mr") == 1) {
X		if (ansi("so") == 1) { 
X			printf("\n\n------  %s  ------\n\n", line);
X			return;
X		}
X	}
X	printf("%s\n", ex);
X	if (ansi("me") == 1) {
X		ansi("se");
X	}
X  }
X  else {
X	printf("\n\n\n\n\n------  %s  ------\n\n", line);
X  }
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  mblock()						   */
X/*  BESCHREIBUNG  Schuetzt eine Datei vor ALLEN Zugriffen		   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mblock( path )
Xunsigned char path[];
X{
X  FILE *fp;
X  unsigned char s[STRING];
X
X  sprintf(s, "%s.LCK", path); 
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  fp = fopen( s, "w" );
X  fputs(VERSION, fp);
X  fclose(fp);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  unmblock()						   */
X/*  BESCHREIBUNG  Erlaubt Zugriffe auf eine Datei			   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mbunlock( path )
Xunsigned char path[];
X{
X  unsigned char s[STRING];
X  
X  sprintf(s, "%s.LCK", path); 
X
X#ifndef _LONGNAMES
X  strcpy(s, (unsigned char *) shortname(s));
X#endif
X
X  unlink(s);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  tty()							   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xint tty()
X{
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  int i, l, a, b;
X
X
X  strcpy(s, (unsigned char *) ttyname(0));
X  l = length(s);
X  i = l;
X
X  while ((s[l] != 'y') && (l > 0)) l--;
X
X  l++;
X  a = 0;
X
X  for (b = l; b < i; b++) {
X	t[a] = s[b];
X	a++;
X  }
X  t[a] = '\0';
X
X  return atoi(t);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ttyna()						   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xunsigned char *ttyna()
X{
X  static unsigned char s[STRING];
X  static unsigned char t[STRING];
X  int i, j, l;
X
X
X  strcpy(s, (unsigned char *) ttyname(0));
X
X  l = length(s) + 1;
X
X  i = 0; 
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X  (void) strcpy(t, (unsigned char *) strcopy(s, j, l));
X  
X  return (unsigned char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  clearline()						   */
X/*  BESCHREIBUNG  Bildschirmzeile loeschen.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine			                                   */
X/***************************************************************************/
X
Xvoid clearline()
X{
X  printf("%c", CR);
X  if (ansi("ce") == 1) {
X	printf("                                                               ");
X  }
X  printf("%c", CR);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  isin()						   */
X/*  BESCHREIBUNG  Prueft ob ein Zeichen in einer Zeichenkette vorkommt.	   */
X/*     PARAMETER  pattern = Zeichenkette mit den moegl. Uebereinstimmungen */
X/*		  c       = Zeichen					   */
X/*     RUECKGABE  0       = Zeichen ist NICHT in Zeichenkette enthalten	   */
X/***************************************************************************/
X
Xint isin( pattern, c )
Xunsigned char pattern[];
Xint c;
X{
X  int i = 0;
X  int ok = 0;
X
X  while((pattern[i] != '\0') && (ok == 0)){
X	if(pattern[i] == c) ok++;	
X	i++;
X  }
X  
X  return (int) ok;  
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  sgrep()						   */
X/*  BESCHREIBUNG  Prueft ob Muster in einer Zeichenkette vorkommt.	   */
X/*     PARAMETER  pattern = Zeichenkette mit den moegl. Uebereinstimmungen */
X/*		  source  = Zeichenkette				   */
X/*     RUECKGABE  0       = Muster ist NICHT in Zeichenkette enthalten	   */
X/***************************************************************************/
X
Xint sgrep( source, pattern )
Xunsigned char source[];
Xunsigned char pattern[];
X{
X  unsigned char t[STRING];
X  int i = 0;
X 
X  while(source[i] != 0){
X	if(source[i] == pattern[0]){
X		strcpy(t, (unsigned char *) strcopy(source, i, strlen(source)));
X		if(strcomp(pattern, t) == 0) return (int) i;
X	}
X	i++;
X  }
X
X  return (int) 0;
X}
X
END_OF_FILE
  if test 24683 -ne `wc -c <'src/tools.c'`; then
    echo shar: \"'src/tools.c'\" unpacked with wrong size!
  fi
  # end of 'src/tools.c'
fi
if test -f 'wendy/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wendy/Makefile'\"
else
  echo shar: Extracting \"'wendy/Makefile'\" \(1007 characters\)
  sed "s/^X//" >'wendy/Makefile' <<'END_OF_FILE'
X# MINIX 386 (BCC)
X O= o
X CC= bcc
X CHMEM= chmem
X CFLAGS= -D_SYS7 -D_LOCAL
X CONVERT= mv a.out $@
X STRIP= strip $@
X#
X#
X# MINIX 386 (GCC 1.37)
X# O= o
X# CC= gcc
X# CHMEM= :
X# CFLAGS= -O -D_SYS7 -D_ESTDIO -traditional
X# CONVERT= /usr/local/bin/gcc2minix < a.out > $@
X# STRIP= strip $@
X#
X#
X# ESIX SVR3
X# O= o
X# CC= gcc
X# CFLAGS= -O2
X# LIB= -lcurses -lc_s
X# CONVERT= mv a.out $@
X# STRIP= strip $@
X# 
X# 
X# Dell 2.1 (SVR4) & GCC 2.1
X# O= o
X# CC= /usr/local/bin/gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -traditional -g 
X# LIB= -ltermlib
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X#
X# 
X 
XPROG=wendy
X 
XOBJ=    getch.$(O) echo.$(O) getline.$(O) tools.$(O) block.$(O) \
X	misc.$(O) rtf.$(O) screen.$(O) ctrl.$(O) wendy.$(O)
X 
X$(PROG): $(OBJ)
X	$(CC) $(CFLAGS) $(OBJ) $(LIB)
X	@$(CONVERT)
X	@$(CHMEM) +250000 $@
X	@$(STRIP)
X	@chmod +x $@
X
Xblock.o:	wendy.h
Xmisc.o:		wendy.h
Xrtf.o:		wendy.h
Xscreen.o:	wendy.h
Xctrl.o:		wendy.h
Xwendy.o:	wendy.h	
X
X 
Xclean:;
X	@rm -f *.$(O) core a.out wendy wendy.sh
X	
END_OF_FILE
  if test 1007 -ne `wc -c <'wendy/Makefile'`; then
    echo shar: \"'wendy/Makefile'\" unpacked with wrong size!
  fi
  # end of 'wendy/Makefile'
fi
echo shar: End of archive 5 \(of 15\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
