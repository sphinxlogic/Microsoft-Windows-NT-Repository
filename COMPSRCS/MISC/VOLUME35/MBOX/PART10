Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Subject: v35i045:  mbox - ix/Mbox, A BBS for UNIX and MINIX v1.6 PL10j7, Part10/15
Message-ID: <1993Feb5.185838.10560@sparky.imd.sterling.com>
X-Md4-Signature: 1b5e154c1b74014a32a697759e44086e
Date: Fri, 5 Feb 1993 18:58:38 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de (Volker Schuermann)
Posting-number: Volume 35, Issue 45
Archive-name: mbox/part10
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 31, Issue 16-27

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  etc/deutsch.befehl etc/reflector.log src/Makefile
#   src/bled.c src/lesen2.c src/mbox.h
# Wrapped by kent@sparky on Fri Feb  5 12:18:12 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 15)."'
if test -f 'etc/deutsch.befehl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/deutsch.befehl'\"
else
  echo shar: Extracting \"'etc/deutsch.befehl'\" \(2904 characters\)
  sed "s/^X//" >'etc/deutsch.befehl' <<'END_OF_FILE'
X/***************************************************************************/
X/* Wer diese Datei aendert sollte GENAU wissen was er tut. Die Reihen-     */
X/* folge der Befehle ist NICHT willkuerlich festgelegt worden, sondern     */
X/* entspricht der Vorgabe fuer GEOnet-Befehle und deren Abkuerzungen.      */
X/*									   */
X/* S(chreiben) kommt vor SE(tup) und L(esen) vor LOE(schen) etc. ... wer   */
X/* sich nicht voellig sicher ist, sollte die Datei einfach im Urzustand    */
X/* belassen.								   */
X/*								           */
X/*                 Die Bedeutung der versch. Spalten 			   */
X/* ======================================================================= */
X/* ID            - Nummer des Befehls (siehe "loop()")			   */
X/* Intern        - Benoetigtes Userlevel				   */
X/* Extern        - Bei einigen Befehle wird unterscheiden zwischen intern  */
X/*		   und extern. Z.B. beim Befehl "schreiben" wird diese     */
X/*		   Regelung angewendet, damit User zwar an die lokalen     */
X/*		   Bretter senden duerfen, nicht aber an die externen.     */
X/* Prototyp      - Enthaelt diese Spalte eine '1', wird der Befehl bei der */
X/*		   Befehlsuebersicht angezeigt.				   */
X/* Befehl        - Unter diesem Namen wird der Befehl aufgerufen           */
X/*									   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Ueberschrift EINE Leerzeile einfuegen ! */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X130	0	0	1	Anrufer
X140	1	0	1	Ansage
X150	0	0	1	Brett
X160	0	2	1	Brief
X170	0	0	1	Chat
X490	0	0	1	Diskussion
X170	0	0	0	Dialog
X370	0	0	0	Datum
X170	0	0	0	Co
X999	0	0	1	Demo
X440     0       0       1       Download
X210	0	0	1	Lesen
X480	1	1	1	Edit
X180	0	0	1	Ende
X180	0	0	0	Quit
X180	0	0	0	Log
X460	0	0	0	Area
X460	0	0	1	Gruppe
X180	0	0	0	Goodbye
X190	0	0	1	Hilfe
X195	0	1	0	~PD
X200	0	0	1	Inhalt
X200	0	0	0	Dir
X205	0	0	0	Id
X215	0	0	0	Level
X220	1	1	1	Loeschen
X330     0       0       1       Makro
X240	8	8	1	Minix
X510	9	9	1	Monitor
X240	8	8	0	Execute
X450	1	1	1	Outdial
X450	1	1	0	Od
X270	0	0	1	Portinfo
X270	0	0	0	Who
X270	0	0	0	Wer
X260	0	0	1	Postfach
X260	0	0	0	Antrag
X275	9	9	0	Relogin
X400     0       0       1       Richtung
X230	0	5	1	Schreiben
X280	0	0	1	Setup
X390 	0	0	1	Spiele
X430	1	1	1	Suchen
X470	0	0	1	Sysinfo
X280	0	0	0	Passwort
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Anschrift
X290	0	0	1	Status
X410     0       0       1       Statistik
X300	0	0	1	User
X310	1	0	1	Unterschrift
X230     0       5       1       Upload
X500	0	0	1	Umlaut
X320	0	0	1	Version        
X340	1	1	1	Weiterleiten
X380	0	0	0	Zeit
X125	9	9	0	Admin
X130	0	0	0	Protokoll
X250	0	0	1	PM
X150	0	0	0	Cd
X300	0	0	0	Finger
X160	0	2	0	Mail
X180	0	0	0	Quit
X180	0	0	0	Exit
X180	0	0	0	Logout
X420	0	0	0	RING
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X998	7	7	0	~MAIL_DUMMY
END_OF_FILE
  if test 2904 -ne `wc -c <'etc/deutsch.befehl'`; then
    echo shar: \"'etc/deutsch.befehl'\" unpacked with wrong size!
  fi
  # end of 'etc/deutsch.befehl'
fi
if test -f 'etc/reflector.log' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/reflector.log'\"
else
  echo shar: Extracting \"'etc/reflector.log'\" \(0 characters\)
  sed "s/^X//" >'etc/reflector.log' <<'END_OF_FILE'
END_OF_FILE
  if test 0 -ne `wc -c <'etc/reflector.log'`; then
    echo shar: \"'etc/reflector.log'\" unpacked with wrong size!
  fi
  # end of 'etc/reflector.log'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
  echo shar: Extracting \"'src/Makefile'\" \(11550 characters\)
  sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                      ix/MBox  M A K E F I L E
X#             Bulletin Board System for UNIX(-Derivations)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 26.10.1991
X#
X#
X#	  	           Modified for SVR3    
X#		
X#	      Walter Buerger <walterb@weller.ruhr.sub.org>
X#              Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#		  Solingen/Wuppertal, FRG, 08.11.1991
X#
X#
X#                        Modified for ISC 2.21
X#
X#	   	   Hergo Pape <hergo@ivcmd.BOERDE.DE>
X#		       Magdeburg, FRG, 16.11.1991
X#
X#		
X#			     DIFF-Support
X#
X#		Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#			Wuppertal, FRG, 07.01.1992
X#
X#
X#		       Modified for ST Minix/c86
X#      
X#		      Olaf <olaf@oski.toppoint.de>
X#      		          Kiel, FRG, 14.01.1992
X#
X#
X#                           SVR4 Support by 
X#
X#                Andreas Laumann <andreas@xenox.w.open.de>
X#	               Wuppertal, FRG, 30.05.1992
X#
X#
X#---------------------------------------------------------------------------
X# CFLAGS: 
X# 
X# -D_MBOX         Has to be set ALWAYS!
X# -D_SYS7         UNIX System 7 (MINIX, COHERENT, ...)
X# -D_MINIX        MINIX special stuff
X# -D_ISC          Interactive UNIX goodies
X# -D_SCO          For SCO UNIX only
X# -D_SVR4         For AT&T's System V Release 4 
X# -D_LINUX	  For Linus' LINUX v0.99pl2
X# -D_LONGNAMES    Long filenames allowed (SVR4, BSD, ULTRIX, ...)
X# -D_ESTDIO       Earl Chew's "estdio.h" and GNU C 1.37
X# -D_CORELEFT     To check your memory (-D_CORELEFT=10000)
X# -D_DATESTAMP    Add time&date to console LOGFILE
X# -D_NOINDEX      Index files for NEWS will be created interactive for
X#		  each group that is called by a user
X#		  Otherwise MB-DAEMON has to be called by [cron] daily
X# -D_BAUDRATE     If you've a HST-Modem with FIXED BAUDRATE
X# -D_MULTIMEDIA   "Multimedia"-Features (i.e. read RTF-Files etc.)
X# -D_CNEWS	  To prevent problems with C-NEWS' aliasing mechanism
X# -D_PMCOPY       Copy POSTMASTERs BBS-PM to "yourdomain!root"
X# -D_UMLAUT       Allow german "Umlauts" (i.e. allow 8bit MAIL/NEWS) 
X# -D_ADDRMODE     Never (!) use this - it's local UNNET stuff
X#---------------------------------------------------------------------------
X# This is a workaround for the System V (not SVR4) /bin/sh bug 
X
XSHELL = /bin/sh
X
X# The following definition tells all ix/MBox BBS parts where they have to 
X# live in the future. 
X
XMBOXHOME=/local/mbox
X
X# All BBS binaries will be stored in the BIN dircetory ... except [mbrsh]
X# NOTE that the path to BIN has to be on all users PATH!
X
XBIN=/usr/bin
X
X#---------------------------------------------------------------------------
X# And now some predefined settings for various compilers/systems:
X#
X# MINIX 386 (BCC)
X CC= bcc
X LN= ln
X CHMEM= chmem
X CFLAGS= -D_MINIX -D_SYS7 -D_MBOX -D_BAUDRATE -D_MULTIMEDIA \
X	-DHOME="\"$(MBOXHOME)"\" -D_UMLAUT
X LIB=
X CONVERT= mv a.out $@
X CHOWN= chown $(OWNER).$(GROUP) 
X CHGRP= :
X STRIP= strip $@
X#
X#
X# MINIX 386 & ESTDIO.H
X# CC= cc
X# LN= ln
X# CHMEM= chmem
X# CFLAGS= -D_MINIX -D_SYS7 -D_ESTDIO -D_MBOX -DHOME="\"$(MBOXHOME)"\"
X# LIB= -lestdio
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X#
X#
X# MINIX 386 (GCC 1.37)
X# CC= gcc
X# LN= ln
X# CHMEM= : 
X# CFLAGS= -O -D_MINIX -D_SYS7 -D_MBOX -D_ESTDIO -DHOME="\"$(MBOXHOME)"\" \
X#	-D_BAUDRATE -D_MULTIMEDIA -traditional
X# LIB=
X# CONVERT= /usr/local/bin/gcc2minix < a.out > $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X#
X#
X# ESIX SVR3 
X# CC= cc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -DHOME="\"$(MBOXHOME)"\"
X# LIB= -lcurses -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= $@
X#
X#
X# ISC 2.21 & "Shared Libs" 
X# CC= gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -D_ISC -traditional -DHOME="\"$(MBOXHOME)"\"
X# LIB= -ltermcap -lcurses -lc_s -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X#
X#
X# Dell 2.1 (SVR4) & GCC 2.1
X# CC= gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -traditional -g -D_MBOX -D_SVR4 -D_DATESTAMP -D_BAUDRATE \
X#	 -D_LONGNAMES -D_MULTIMEDIA -D_CNEWS -DHOME="\"$(MBOXHOME)"\"
X# LIB= -ltermlib
X# DBM= 
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X#
X#
X# LINUX 
X# CC= cc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -DHOME="\"$(MBOXHOME)"\" -traditional
X# LIB= -ltermcap
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= $@
X
X# This is the pager which BLED uses to display his helpfile 
XBLPAGER=/bin/cat
X
X# In this directory, you hide your helpfiles and manuals
XHELPDIR=/usr/doc
X
X
X# Sorry, but SETUID root.root is still necessary ...
XOWNER=root
XGROUP=root
X
X
XMBOX.OBJ=main.o getch.o tools.o getline.o \
X	intro.o nerror.o show.o	loop.o help.o admin.o mail.o control.o \
X	misc.o lesen.o lesen2.o pd.o portinfo.o befehl.o misc2.o \
X	postfach.o ctrlx.o makro.o weiterl.o coreleft.o games.o suchen.o \
X	baudrate.o outdial.o faces.o uptodate.o dis.o
X
XBLED.OBJ=bled.o getch.o bltools.o blgetline.o derror.o
X
XXMD.OBJ=xmd.o tools.o derror.o
X
XMBRSH.OBJ=mbrsh.o
X
XMBD.OBJ=tools.o mb-daemon.o derror.o
X
XDIFF_FILES=admin.c befehl.c bled.c control.c coreleft.c \
X	ctrlx.c defs.h derror.c games.c getch.c getline.c help.c intro.c \
X	lesen.c lesen2.c loop.c mail.c main.c makro.c mb-daemon.c mbox.h \
X	mbrsh.c misc.c misc2.c nerror.c patchlevel.h pd.c portinfo.c \
X	postfach.c show.c suchen.c tools.c weiterl.c xmd.c baudrate.c \
X	outdial.c faces.c dis.c
X
XPROGS=mbox bled mb-daemon mbrsh xmd
X
Xdefault:; @echo ''
X	  @echo 'One of the following:'
X	  @echo ''
X	  @echo 'make all       <-   Create every object file'
X	  @echo 'make world     <-   Make directories and set permissions'
X	  @echo 'make inst      <-   Install the BBS (make all, world, etc.)'
X	  @echo 'make english   <-   Prepare for english version'
X	  @echo 'make german    <-   Prepare for german version'
X	  @echo 'make clean     <-   Remove object files'
X	  @echo 'make mbox      <-   Make the BBS itself (ix/MBox BBS)'
X	  @echo 'make mb-daemon <-   Compile "mb-daemon" (NEWS Scanner)'
X	  @echo 'make xmd       <-   Create "xmd" (Mailing Agent)'
X	  @echo 'make mbrsh     <-   Build "mbrsh" (External Shell)'
X	  @echo 'make bled      <-   Make "bled" (B[etter] L[ine] ED[itor])'
X	  @echo ''
X	  @echo 'Active definitions:'
X	  @echo ''
X	  @echo 'Compiler [$(CC)]'
X	  @echo 'CFLAGS   [$(CFLAGS)]'
X	  @echo 'Lib(s)   [$(LIB)]'
X	  @echo 'Root-ID  [$(OWNER).$(GROUP)]'
X	  @echo ''
X
Xall: $(PROGS)
X	@echo ''
X	@echo '- All files are made' 
X	@echo ''
X
Xmbox:	$(MBOX.OBJ)
X	@echo ''
X	@echo '- The BBS is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBOX.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHGRP) $@
X	@$(CHOWN) $@
X	@chmod +x mbox
X	@chmod ug+s mbox
X	@$(CHMEM) +280000 mbox
X	@$(STRIP)
X
Xbled:	$(BLED.OBJ) 
X	@echo ''
X	@echo '- The Editor (BLED) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(BLED.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHMEM) +10000 bled	
X	@$(STRIP)
X	@chmod +x bled
X
Xxmd:    $(XMD.OBJ) 
X	@echo ''
X	@echo '- The Mailing Agent (xmd) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(XMD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x xmd
X
Xmbrsh:  $(MBRSH.OBJ) 
X	@echo ''
X	@echo '- The external SHELL (mbrsh) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBRSH.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x mbrsh
X
Xmb-daemon:    $(MBD.OBJ) 
X	@echo ''
X	@echo '- The NEWS Scanner (mb-daemon) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@chmod +x mb-daemon
X	@chmod ug+s mb-daemon
X	@$(CHMEM) +64000 mb-daemon		
X	@$(STRIP)
X
Xinst:	world all
X	@echo
X	@echo -n '- The BBS is going to be installed...'
X	@cp mbox $(BIN)
X	@cp bled $(BIN)
X	@cp mbrsh $(MBOXHOME)
X	@cp mb-daemon $(BIN)
X	@cp xmd $(BIN)
X	@cp bled.doc $(HELPDIR)
X	@$(CHOWN) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@$(CHGRP) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@chmod +s $(BIN)/mbox
X	@chmod +s $(BIN)/mb-daemon
X	@echo  'done.'
X	@echo
X
Xcopy:
X	cp mbox bled mb-daemon xmd $(BIN)
X	cp mbrsh $(MBOXHOME)
X
Xenglish:;
X	@echo
X	@echo -n '- Preparing english version...'
X	@rm $(MBOXHOME)/src/mbox.msg
X	@ln $(MBOXHOME)/src/mbox.english $(MBOXHOME)/src/mbox.msg
X	@rm $(MBOXHOME)/etc/help.*
X	@ln $(MBOXHOME)/etc/english.befehle $(MBOXHOME)/etc/help.befehle
X	@ln $(MBOXHOME)/etc/english.hilfe $(MBOXHOME)/etc/help.hilfe
X	@ln $(MBOXHOME)/etc/english.shorthelp $(MBOXHOME)/etc/help.shorthelp
X	@echo 'done.'
X	@echo ''
X
Xgerman:;
X	@echo
X	@echo -n '- Preparing german version...'
X	@rm $(MBOXHOME)/src/mbox.msg
X	@ln $(MBOXHOME)/src/mbox.deutsch $(MBOXHOME)/src/mbox.msg
X	@rm $(MBOXHOME)/etc/help.*
X	@ln $(MBOXHOME)/etc/deutsch.befehle $(MBOXHOME)/etc/help.befehle
X	@ln $(MBOXHOME)/etc/deutsch.hilfe $(MBOXHOME)/etc/help.hilfe
X	@ln $(MBOXHOME)/etc/deutsch.shorthelp $(MBOXHOME)/etc/help.shorthelp
X	@echo 'done.'
X	@echo ''
X
Xworld:;	@echo
X	@echo -n '- Making directories...'
X	@if test -d $(MBOXHOME) ; then echo -n ''; else mkdir $(MBOXHOME) ; fi
X	@if test -d $(BIN) ; then echo -n ''; else mkdir $(BIN) ; fi
X	@if test -d $(MBOXHOME)/etc ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/etc ; fi
X	@if test -d $(MBOXHOME)/lib ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/lib ; fi
X	@if test -d $(MBOXHOME)/src ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/src ; fi
X	@if test -d $(MBOXHOME)/usr ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/usr ; fi
X	@$(CHOWN) $(MBOXHOME) $(MBOXHOME)/*
X	@$(CHGRP) $(MBOXHOME) $(MBOXHOME)/*
X	@chmod ug+rwx $(MBOXHOME)/lib
X	@chmod o-rwx $(MBOXHOME)/lib
X	@chmod ug+rwx $(MBOXHOME)/src
X	@chmod o-rwx $(MBOXHOME)/src
X	@chmod ug+rwx $(MBOXHOME)/etc
X	@chmod o-rwx $(MBOXHOME)/etc
X	@chmod ug+rwx $(MBOXHOME)/usr
X	@chmod o-rwx $(MBOXHOME)/usr
X	@echo 'done.'
X	@echo ''
X
X
Xclean:;	
X	@echo ''
X	@echo -n '- Old stuff is going to be deleted...' 
X	@rm -f *.o mbox mbrsh bled xmd mb-daemon bltools.c blgetline.c core
X	@echo 'done.'
X	@echo ''
X
Xblgetline.o:	mbox.h patchlevel.h
X	@if test -f blgetline.c ; then echo -n '' ; \
X		else $(LN) getline.c blgetline.c ; fi
X	$(CC) -c $(CFLAGS) blgetline.c
X
Xbltools.o:	mbox.h patchlevel.h
X	@rm -f bltools.c
X	@cat undef.c > bltools.c
X	@cat tools.c >> bltools.c
X	$(CC) -c $(CFLAGS) bltools.c
X
Xbled.o:	mbox.h patchlevel.h
X	$(CC) -c $(CFLAGS) -DHILFE="\"$(BLPAGER) $(HELPDIR)/bled.doc"\" bled.c
X
X
X
X# For automagic update service (Beta-Testers only) ...
XDIFF	 = /usr/bin/cdiff
XSRC      = /mbox/src
XSRC_ORIG = /mbox/1.6
XADRESSE  = "volkers@unnet.w.open.DE"
X
X
Xdiff: $(DIFF_FILES)
X	@echo DiffMailer by ralf@heibox.ruhr.sub.org >$@
X	@echo Project: ix/MBox 1.6 >>$@
X	@echo Adresse: $(ADRESSE)
X	@echo Folgende Aenderungen sind in $? vorzunehmen >>$@
X	@date >>$@
X	@echo >>$@
X	@for f in $? ; do \
X	echo ----- $$f -----; \
X	echo ----- $$f ----- >>$@; \
X	$(DIFF) $(SRC)/$$f $(SRC_ORIG) | cat >>$@; \
X	done
X	@cat diff | mail -s "ix/MBox PATCHES" volkers@unnet.w.open.de
X
X
Xadmin.o:		mbox.h defs.h
Xbefehl.o:		mbox.h defs.h
Xbled.o:			mbox.h defs.h
Xbaudrate.o:		mbox.h defs.h
Xcontrol.o:		mbox.h defs.h
Xderror.o:		mbox.h defs.h
Xdis.o:			mbox.h defs.h
Xfaces.o:		mbox.h defs.h
Xgames.o:		mbox.h defs.h
Xgetline.o:		mbox.h defs.h
Xhelp.o:			mbox.h defs.h
Xintro.o:		mbox.h defs.h
Xlesen:			mbox.h defs.h
Xlesen2.o:		mbox.h defs.h
Xloop.o:			mbox.h defs.h
Xmail.o:			mbox.h defs.h
Xmain.o:			mbox.h defs.h
Xmakro.o:		mbox.h defs.h
Xmbd.o:			mbox.h defs.h
Xmbrsh.o:		mbox.h defs.h
Xmisc.o:			mbox.h defs.h
Xmisc2.o:		mbox.h defs.h
Xnerror.o:		mbox.h defs.h
Xoutdial.o:		mbox.h defs.h
Xpd.o:			mbox.h defs.h
Xportinfo.o:		mbox.h defs.h
Xpostfach.o:		mbox.h defs.h
Xshow.o:			mbox.h defs.h
Xsuchen.o:		mbox.h defs.h
Xtools.o:		mbox.h defs.h
Xuptodate.o:		mbox.h defs.h
Xweiterl.o:		mbox.h defs.h
Xxmd.o:			mbox.h defs.h
X
X
END_OF_FILE
  if test 11550 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
  fi
  # end of 'src/Makefile'
fi
if test -f 'src/bled.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bled.c'\"
else
  echo shar: Extracting \"'src/bled.c'\" \(11597 characters\)
  sed "s/^X//" >'src/bled.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <setjmp.h>
X#include <signal.h>
X
X#define VERSION "LED 3.5 (Unix)"
X#define AUTOR   "Volker.Schuermann@unnet.w.open.de"
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X#include "mbox.msg"
X
X
X#define CR     13
X#define LF     10
X#define BS      8
X#define CTRL_X 24
X#define CTRL_D  4
X
X
X#define TMP "/tmp"
X
X#define APPEND 1
X#define INSERT 2
X#define FINISH 3
X#define QUIT   4
X#define UPLOAD 5
X
X#ifdef _MBOX
X#undef _MBOX
X#endif
X
Xstatic int melted;
X
Xstatic unsigned char tmp1[STRING];
Xstatic unsigned char tmp2[STRING];
X
Xstatic int von, bis;
Xstatic int max_line;
X
Xstatic unsigned char imode;
X
Xstatic unsigned char THE_FILE[STRING];
Xstatic int  THE_LINE;
X
Xint UMLAUT;
X
X
X
X
Xint melt(startlin)
Xint startlin;
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *fg;
X  unsigned char s[255];
X  unsigned char tmp3[STRING];
X  int i;
X
X
X  if (melted == 0) return 0;
X
X  sprintf(tmp3, "%s/bled3.%d", TMP, getpid());
X
X  fg = fopen(tmp3, "w");
X  if (fg == NULL) {
X	printf("\n%s\n", tmp3);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 0;
X  while ((i < startlin) && (fgets(s, 250, fp) != NULL)) {
X	fputs(s, fg);
X	i++;
X  }
X  ff = fopen(tmp2, "r");
X  if (ff != NULL) {
X	while (fgets(s, 250, ff) != NULL) {
X		fputs(s, fg);
X		i++;
X	}
X	fclose(ff);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, fg);
X  }
X  fclose(fg);
X  fclose(fp);
X
X  unlink(tmp1);
X  rename(tmp3, tmp1);
X  unlink(tmp3);
X
X  return 0;
X}
X
X
X
Xbledmove(from, to)
Xunsigned char from[], to[];
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char s[255];
X
X
X  fp = fopen(from, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  ff = fopen(to, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, ff);
X  }
X  fclose(fp);
X  fclose(ff);
X}
X
X
X
X
X
Xzeigen(mode)
Xunsigned char mode;
X{
X  FILE *fp;
X  unsigned char t[STRING];
X  unsigned char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != NULL) {
X	if ((i >= von) && (i <= bis)) {
X		if (mode == 'l')
X			printf("L%04.4d %s", i, s);
X		else
X			printf("%s", s);
X	}
X	i++;
X  }
X  fclose(fp);
X}
X
X
X
Xloeschen()
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char t[STRING];
X  unsigned char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != 0) {
X	if ((i < von) || (i > bis)) {
X		fputs(s, ff);
X	}
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
Xupload()
X{
X  FILE *fp;
X  unsigned char c;
X  unsigned char lf;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  /*
X  printf("\n\nLED: Uebertragung beginnt. (Beenden mit CTRL-X !)\n\n");
X  */
X  printf("\n\nLED: %s\n\n", BLD02_MSG);
X
X  c = 0;
X  lf = CR;
X
X
X  while ((c != CTRL_X) && (c != CTRL_D)) {
X
X        c = getint();
X
X	if ((c == CR) && (lf == CR)) fputc(LF, fp);
X	if (c == CR) lf = CR;
X	if (c == LF) lf = LF;
X	if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X		fputc(c, fp);
X	}
X  }
X  fclose(fp);
X}
X
X
X
Xkorrigieren()
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char s[255];
X  unsigned char t[255];
X  int i, z;
X
X  if (von == 0) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  while (fgets(s, 250, fp) != NULL) {
X	if (i == von) {
X		t[0] = '\0';
X		strcpy(t, s); 
X		z = strlen(t);
X		while(t[z] < 33) z--;
X		z++;
X		t[z] = '\0';
X		s[0] = '\0';
X		if (length(t) < 74)
X			printf("\n\nK%04.4d ", i);
X		else
X			printf("\n\n");
X		strcat(s, getline(74, 1001, ' ', t));
X		strcat(s, "\n");
X		printf("\n");
X	}
X	fputs(s, ff);
X	i++;
X  }
X  fclose(ff);
X  fclose(fp);
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
X
Xcrunch(s)
Xunsigned char s[];
X{
X  unsigned char t[STRING];
X  int i = 0, a = 0;
X
X  von = 0;
X  bis = 0;
X
X  while (s[i] != '\0') {
X	if ((s[i] == ',') || (s[i] == '-')) a = i;
X	i++;
X  }
X  if (a == 0) a = i;
X  t[0] = '\0';
X  strcat(t, strcopy(s, 3, (a - 1)));
X  von = atoi(t);
X  t[0] = '\0';
X  strcat(t, strcopy(s, (a + 1), i));
X  bis = atoi(t);
X  if ((a != i) && (bis == 0)) bis = 32000;
X}
X
X
X
X
X
Xint befehl(s)
Xunsigned char s[];
X{
X  unsigned char c = s[1];
X
X  if ((s[2] != ' ') && (s[2] != '\0') && (s[1] != '\0')) {
X	/*
X	printf("\n\nLED: Syntax-Fehler.\n");
X	*/
X	printf("\n\nLED: %s\n", BLD03_MSG);
X	return 0;
X  }
X  crunch(s);
X
X  switch (c) {
X      case '\0':
X			return FINISH;
X			break;
X      case '?':
X			printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Befehlsuebersicht ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD04_MSG);
X			ansi("me");
X			printf("\n\n");
X			/*
X			printf(".l [ZEILE]|[VON,BIS]   lesen\n");
X			printf(".L [ZEILE]|[VON,BIS]   lesen (keine Zeilennummern)\n");
X			printf(".i AB                  einfuegen\n");
X			printf(".a                     anhaengen (beendet einfuegen)\n");
X			printf(".k ZEILE               korrigieren\n");
X			printf(".d [ZEILE]|[VON,BIS]   loeschen\n");
X			printf(".u                     uebertragen (ASCII-Upload)\n");
X			printf(".q                     abbrechen\n");
X			printf(".h                     ausfuehrliche Hilfe\n");
X			printf(".                      sichern & beenden\n\n");
X			printf("ZEILE, VON, BIS, AB sind gueltige Zeilennummern.\n");
X			printf("Angaben in [KLAMMERN] sind optional. Werden\n");
X			printf("keine Angaben gemacht gilt AB=1, VON=1, BIS=32000.\n");
X			*/
X			printf("%s\n", BLD05_MSG);
X			printf("%s\n", BLD06_MSG);
X			printf("%s\n", BLD07_MSG);
X			printf("%s\n", BLD08_MSG);
X			printf("%s\n", BLD09_MSG);
X			printf("%s\n", BLD10_MSG);			
X			printf("%s\n", BLD11_MSG);
X			printf("%s\n", BLD12_MSG);
X			printf("%s\n", BLD13_MSG);
X			printf("%s\n", BLD14_MSG);
X			printf("\n");
X			printf("%s\n", BLD15_MSG);
X			printf("%s\n", BLD16_MSG);
X			printf("%s\n", BLD17_MSG);
X			break;
X      case 'h':	        printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Hilfe ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD18_MSG);
X			ansi("me");
X			printf("\n\n");
X			system( HILFE );
X			break;
X      case 'a':	
X			return APPEND;	
X			break;
X      case 'i':
X			return INSERT;	
X			break;
X      case 'l':
X      case 'L':
X			zeigen(c);
X			return APPEND;
X			break;
X      case 'd':
X			loeschen();
X			return APPEND;
X			break;
X      case 'k':
X      case 'c':
X			korrigieren();
X			return APPEND;
X      case 'u':
X			upload();
X			return UPLOAD;
X      case 'q':
X			unlink(tmp1);
X			unlink(tmp2);
X			/*
X			printf("\n\nLED: Abgebrochen. Datei NICHT gesichert.\n\n");
X			*/
X			printf("\n\nLED: %s\n\n", BLD19_MSG);
X			exit(0);
X			break;
X      default:		/*
X			printf("\n\nLED: Befehl unbekannt.\n");
X			*/
X			printf("\n\nLED: %s\n", BLD20_MSG);
X}
X  return 0;
X}
X
X
X
X
X
Xint erfassen(line, mode)
Xint line, mode;
X{
X  FILE *fp;
X  unsigned char s[STRING];
X  unsigned char t[STRING];
X  unsigned char def[STRING];
X  int ok = 0;
X  int elin = line;
X  int startlin = line - 1;
X  int a, b;
X
X  melted = 1;			/* Sicher ist sicher ... */
X  THE_LINE = startlin;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) return -1;
X
X  def[0] = '\0';
X
X  do {
X	if (elin > max_line) max_line = elin;
X	printf("\n%c%04.4d ", imode, elin);
X	s[0] = '\0';
X	if (def[0] == '\0')
X		strcat(s, getline(73, 1, ' ', " "));
X	else
X		strcat(s, getline(73, 1001, ' ', def));
X
X	if (strcomp("<BREAK>", s) == 0) {
X		sprintf(s, ".?");
X	}
X	if (s[0] == '.') {
X		fclose(fp);
X		melted = melt(startlin);
X
X		ok = befehl(s);
X
X		if (ok == UPLOAD) {
X			melted = 1;
X			melted = melt(startlin);
X			ok = APPEND;
X		}
X		if (ok == INSERT) {
X			imode = 'I';
X			if (von < 1) von = 1;
X			if (von > max_line) {
X				ok = APPEND;
X			}
X			 else {
X				startlin = von - 1;
X				THE_LINE = startlin;
X				elin = von;
X			}
X		}
X		if (ok == APPEND) {
X			imode = 'A';
X			unlink(tmp2);
X			rename(tmp1, tmp2);
X			startlin = getfile(tmp2);
X			if (startlin < 1) startlin = 0;
X			elin = startlin + 1;
X			THE_LINE = startlin;
X		}
X		fp = fopen(tmp2, "w");
X		if (fp == NULL) return -1;
X
X	} else {
X		def[0] = '\0';
X		a = length(s);
X		if (a == 73) {
X			while ((s[a] != ' ') && (a > 40)) a--;
X			if (s[a] == ' ') {
X				strcat(def, strcopy(s, (a + 1), 73));
X				s[a] = '\0';
X				for (b = a; b < 73; b++) printf("%c", BS);
X				for (b = a; b < 73; b++) printf(" ");
X			}
X		}
X		fprintf(fp, "%s\n", s);
X		elin++;
X		melted++;
X	}
X  } while (ok != FINISH);
X  return elin;
X}
X
X
X
Xsigcatch(sig)
Xint sig;
X{
X
X  switch (sig) {
X      case SIGINT:
X      case SIGQUIT:
X      case SIGHUP:
X      case SIGABRT:
X      case SIGTERM:
X	melted++;
X	melt(THE_LINE);
X	bledmove(tmp1, THE_FILE);
X	unlink(tmp1);
X	unlink(tmp2);
X	/*
X	printf("\n\nLED: Prozess terminiert. Datei gesichert.\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD21_MSG);
X	exit(-1);
X	break;
X  }
X}
X
X
X
Xint getfile(path)
Xunsigned char path[];
X{
X  FILE *fp;
X  FILE *ff;
X  int i = 0;
X  unsigned char s[STRING];
X
X  ff = fopen(tmp1, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X  }
X  fp = fopen(path, "r");
X  if (fp == NULL) {
X	fclose(ff);
X	return -1;
X  }
X  if (fgets(s, STRING, fp) != 0) i++;
X  if ((s[0] == 1) && (s[1] == 3)) {	/* MAGIC NUMBER */
X	return -2;
X  }
X  fputs(s, ff);
X
X  while (fgets(s, STRING, fp) != NULL) {
X	fputs(s, ff);
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  return i;
X}
X
X
X
Xmain(argc, argv)
Xint argc;
Xunsigned char *argv[];
X{
X  unsigned char s[STRING];
X
X  int eof = 0;
X
X
X  UMLAUT = 0;
X
X  if (argc < 2) {
X	/*
X	printf("\nLED: Keine Datei angegeben.\n\n");
X	*/
X	printf("\nLED: %s\n\n", BLD22_MSG);
X	return;
X  }
X  /*
X  signal(SIGINT, sigcatch);
X  signal(SIGQUIT, sigcatch);
X  signal(SIGHUP, sigcatch);
X  signal(SIGABRT, sigcatch);
X  signal(SIGTERM, sigcatch);
X  */
X  signal(SIGINT,  SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGHUP,  SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X#ifndef _SYS7
X
X  setbuf(stdout, NULL);
X
X#endif
X
X  ansi( "INIT" );
X
X  sprintf(s, " %s ", VERSION);
X  headline(s);
X 
X  /*
X  printf("\nMomentchen ...");
X  */
X  printf("\n%s", BLD23_MSG);
X
X  sprintf(tmp1, "%s/bled1.%d", TMP, getpid());
X  sprintf(tmp2, "%s/bled2.%d", TMP, getpid());
X
X  sprintf(THE_FILE, "%s", argv[1]);
X  THE_LINE = 0;
X
X  eof = getfile(THE_FILE);
X  printf("%c", CR);
X  if (eof == -2) {
X	/*
X	printf("Datei \"%s\" enthaelt ein ausfuehrbares Programm.\n\n", THE_FILE);
X	*/
X	printf("%s \"%s\" %s\n\n", BLD24_MSG, THE_FILE, BLD25_MSG);
X	return;
X  }
X  if (eof == -1)
X	/*
X	printf("Datei wird angelegt.");
X	*/
X	printf("%s", BLD26_MSG);
X  else
X	/*
X	printf("Datei enthaelt %d Zeilen.", eof);
X	*/
X	printf("%s %d %s", BLD27_MSG, eof, BLD28_MSG);
X  
X  /*
X  printf(" Befehlsuebersicht: \".?\"\n");
X  */
X  printf(" %s: \".?\"\n", BLD04_MSG);
X
X  if (eof < 1) eof = 0;
X  melted = 0;
X  max_line = eof;
X  eof++;
X
X  imode = 'A';
X
X  if (erfassen(eof, APPEND) < 1) {
X	/*
X	printf("\n\nLED: Probleme ...\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD29_MSG);
X  }
X  bledmove(tmp1, THE_FILE);
X  unlink(tmp1);
X  unlink(tmp2);
X
X  /*
X  printf("\n\nUnd 'tschuess ...\n\n");
X  */
X  printf("\n\n%s\n\n", BLD30_MSG);
X}
END_OF_FILE
  if test 11597 -ne `wc -c <'src/bled.c'`; then
    echo shar: \"'src/bled.c'\" unpacked with wrong size!
  fi
  # end of 'src/bled.c'
fi
if test -f 'src/lesen2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lesen2.c'\"
else
  echo shar: Extracting \"'src/lesen2.c'\" \(10703 characters\)
  sed "s/^X//" >'src/lesen2.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  lesen2.c						   */
X/*        FUNKTIONEN  anzeigen(), lesen2(), inhalt2(), loeschen2()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  30.10.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
Xextern unsigned char headinfo[STRING];
X
X/***************************************************************************/
X/*      FUNKTION  anzeigen()						   */
X/*  BESCHREIBUNG  Artikel selektieren und anzeigen.			   */
X/*     PARAMETER  art  =  Artikel(-Nummer)                                 */
X/*		  von  =  Artikel-Nummer (Minimum)                         */
X/*		  bis  =  Artikel-Nummer (Maximum)                         */
X/*     RUECKGABE  siehe "show()"					   */
X/***************************************************************************/
X
Xint anzeigen(art, von, bis)
Xint art, von, bis;
X{
X  unsigned char entry[STRING];
X  unsigned char s[STRING];
X  int mr;
X  int ok;
X
X 
X  if (strcomp(BRETT, "PM") != 0) {
X	sprintf(entry, "%s/%d", BRETT, art);
X  }
X  else {
X	sprintf(entry, "%s/usr/%d/%d", HOME, USER.id, art);
X  }
X
X  mr = 0;
X  if ((USER.more == 1) || (USER.more == 3)) mr = 2;
X
X  sprintf(s, "%d", art);
X
X  if (((art >= von) && (art <= bis)) ||
X      ((art >= bis) && (art <= von))) {
X
X	ok = pruefe(s);	
X
X	if(ok == 0){
X		if(USER.more != 0){
X			sprintf(headinfo, " %s %d (%s) ", LE201_MSG, art, NG);
X			headline( headinfo );
X		}
X		else{
X			ansi("md");
X			printf("%s %d\n", LE202_MSG, art);
X			ansi("me");
X		}
X		show( "?", 99, 99 );
X		ok = show(entry, 9999, mr);
X		if(ok != -1){
X			if(USER.more != 0) more();
X		}
X		else return ok;
X	}
X  }
X  return ok;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  lesen2() 						   */
X/*  BESCHREIBUNG  Artikel selektieren (je nach Parameter) und anzeigen.    */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid lesen2(arg, mode)
Xunsigned char arg[];
Xunsigned char mode;
X{
X  FILE *fp;
X  unsigned char ex[255];
X  unsigned char s[STRING];
X  unsigned char entry[STRING];
X  int a = 56, b = 63;
X  int i, d, e;
X  int von, bis;
X  int ALLE;
X  int PM = 0;
X  int art[MAX_PER_NG];
X  int artp;
X  int k, l;
X  int LR = 0;
X
X
X  i = 0;
X  k = -1;
X  l = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	if (arg[i] == '*') l = i;
X	i++;
X  }
X
X  if ((arg[0] != '\0') && (k == -1) && (l == -1)) {
X	ansi("md");
X	printf(" %s\n", LE203_MSG);
X	ansi("me");
X	return;
X  }
X
X  von = 1;
X  bis = 32000;
X
X  if (l != -1) {
X	ALLE = 1;
X  }
X  if (k != -1) {
X	strcpy(s, (unsigned char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (unsigned char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X	ALLE = 1;
X  }
X  if ((k == -1) && (l == -1)) {
X	ALLE = 0;
X  }
X  if ((von == 1) && (bis == 32000)) LR++;
X
X  if ((USER.leserichtung != 1) && (LR != 0)) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X  if (strcomp(BRETT, "PM") != 0) {
X	PM = 0;
X  }
X  else {
X	PM = 1;
X  }
X
X  d = a + 10;
X  e = a + 14;
X
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	inhalt2(arg, mode);
X	return;
X  }
X  artp = -1;
X
X  while (fgets(ex, 250, fp) != NULL) {
X	if (ALLE == 1) {
X		artp++;
X		art[artp] = atoi(ex);
X	}
X	else {
X		strcpy(s, (unsigned char *) strcopy(ex, a, b));
X		if (LASTLOG < dateconv(s)) {
X			artp++;
X			art[artp] = atoi(ex);
X		}
X		if (LASTLOG == dateconv(s)) {
X			strcpy(s, (unsigned char *) strcopy(ex, d, e));
X			if (LASTTIME <= timeconv(s)) {
X				artp++;
X				art[artp] = atoi(ex);
X			}
X		}
X	}
X	if(artp >= MAX_PER_NG){
X		nerror("lesen2.c", 188, "lesen2", "Zuviele", "Artikel");
X	}
X  }
X  fclose(fp);
X
X
X
X  if (artp == -1) {
X	ansi("md");
X	printf(" %s", LE204_MSG);
X	ansi("me");
X	printf("\n");
X	return;
X  }
X  ansi("cl");
X
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X
X  show("?", 0, 99);
X
X  if (von > bis) {
X	for (i = artp; i >= 0; i--) {
X		if (anzeigen(art[i], von, bis) == -1) return;
X	}
X  }
X  else {
X	for (i = 0; i <= artp; i++) {
X		if (anzeigen(art[i], von, bis) == -1) return;
X	}
X  }
X
X  return;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  inhalt2() 						   */
X/*  BESCHREIBUNG  Inhalt selektieren (je nach Parameter) und anzeigen. 	   */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid inhalt2(arg, mode)
Xunsigned char arg[];
Xunsigned char mode;
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char ex[LONGSTRING];
X  unsigned char s[STRING];
X  unsigned char tmp[STRING];
X  int a = 56, b = 63;
X  int e, d, i;
X  int von, bis;
X  int k, l;
X  int plus, minus;
X  int PM;
X  int ALLE;
X  int LR = 0;
X
X
X  i = 0;
X  k = -1;
X  l = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	if (arg[i] == '*') l = i;
X	i++;
X  }
X
X  von = 1;
X  bis = 32000;
X
X  if ((arg[0] != '\0') && (k == -1) && (l == -1)) {
X	strcpy(s, (unsigned char *) strcopy(arg, 0, length(arg)));
X	von = atoi(s);	
X	bis = von;
X	ALLE = 1;
X  }
X
X  if (l != -1) {
X	ALLE = 1;
X  }
X  if (k != -1) {
X	strcpy(s, (unsigned char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (unsigned char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X	ALLE = 1;
X  }
X
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	brett( "~" );
X	return;
X  }
X  sprintf(tmp, "%s/I.%d", TMP, getpid());
X  ff = fopen(tmp, "w");
X
X  sprintf(ex, " %s (%s) ", LE205_MSG, NG);
X  ex[80] = '\0';
X  headline(ex);
X
X  fgets(ex, 250, fp);	/* alte Ueberschrift ausblenden */
X  fgets(ex, 250, fp);   /* dito */
X
X  if(strcomp(PDNG, NG) == 0){
X	printf("%s\n", GBL08_MSG); 
X  }
X  else{
X	printf("%s\n", GBL05_MSG);
X  }
X  printf("===============================================================================\n", ff);
X  
X
X  PM = 1;
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X	PM = 0;
X  }
X  plus = 0;
X  minus = 0;
X
X  d = a + 10;
X  e = a + 14;
X
X  if (((von == 1) && (bis == 32000)) || ((von == 32000) && (bis == 1))) LR++;
X
X  if ((USER.leserichtung != 1) && (LR != 0)) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X  if (von > bis) {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if(i != 0) minus++;
X		if (ALLE == 1) {
X			if ((i >= bis) && (i <= von)) {
X				fputs(ex, ff);
X				plus++;
X			}
X		} else {
X			strcpy(s, (unsigned char *) strcopy(ex, a, b));
X			if (LASTLOG < dateconv(s)) {
X				fputs(ex, ff);
X				plus++;
X			}
X			if (LASTLOG == dateconv(s)) {
X				strcpy(s, (unsigned char *) strcopy(ex, d, e));
X				if (LASTTIME <= timeconv(s)) {
X					fputs(ex, ff);
X					plus++;
X				}
X			}
X		}
X	}
X	fclose(ff);
X
X	if (PM == 1)
X		sprintf(s, "sort -nr -o %s %s", tmp, tmp);
X	else
X		sprintf(s, "sort -n -o %s %s", tmp, tmp);
X	system(s);
X  }
X  else {
X	while (fgets(ex, 250, fp) != 0) {
X		i = atoi(ex);
X		if(i != 0) minus++;
X		if (ALLE == 1) {
X			if ((i >= von) && (i <= bis)) {
X				fputs(ex, ff);
X				plus++;
X			}
X		} 
X		else {
X			strcpy(s, (unsigned char *) strcopy(ex, a, b));
X			if (LASTLOG < (long) dateconv(s)) {
X				fputs(ex, ff);
X				plus++;
X			}
X			if (LASTLOG == (long) dateconv(s)) {
X				strcpy(s, (unsigned char *) strcopy(ex, d, e));
X				if (LASTTIME <= (long) timeconv(s)) {
X					fputs(ex, ff);
X					plus++;
X				}
X			}
X		}
X	}
X	fclose(ff);
X  }
X  fclose(fp);
X
X  if (plus != 0) show(tmp, 9999, USER.more + 100);
X
X  unlink(tmp);
X
X  if (plus == 0) {
X	ansi("md");
X	printf("%s", LE206_MSG);
X	ansi("me");
X	if ((minus - plus) > 0)
X		printf("\n%s %d %s", LE207_MSG, minus, LE208_MSG);
X	else
X		printf("\n%s", LE209_MSG);
X  }
X  else if ((plus < 19) || (plus > 21)) {
X	if ((minus - plus) > 0)
X		printf("\n%s %d %s", LE210_MSG, (minus - plus), LE211_MSG);
X	else
X		printf("\n%s", LE212_MSG);
X  }
X  printf("\n");
X
X  return;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  loeschen2() 						   */
X/*  BESCHREIBUNG  Persoenliche Post selektieren (je nach Parameter) und    */
X/*                loeschen.						   */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid loeschen2(arg, mode)
Xunsigned char arg[];
Xunsigned char mode;
X{
X  FILE *fp;
X  FILE *ff;
X  unsigned char ex[255];
X  unsigned char s[STRING];
X  unsigned char tmp[STRING];
X  int a, b, i;
X  int von, bis;
X  int k;
X  int plus;
X  int PM;
X  int COPIES = 0;
X
X  if((USER.level == GUEST_LEV) || (arg[0] == '\0')){
X	return;
X  }
X
X  i = 0;
X  k = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	i++;
X  }
X
X  if ((arg[0] == '>') || (arg[0] == '<')){
X	COPIES++;
X	arg[0] = '\0';
X	k = -1;
X  }
X
X  if ((arg[0] != '\0') && (k == -1)) {
X	ansi("md");
X	printf(" %s\n", LE213_MSG);
X	ansi("me");
X	return;
X  }
X  von = 1;
X  bis = 32000;
X
X  if (k != -1) {
X	strcpy(s, (unsigned char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (unsigned char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X  }
X  if (strcomp(BRETT, "PM") != 0) {
X	a = 60;
X	b = 69;
X  } else {
X	a = 58;
X	b = 65;
X  }
X
X  maybe_locked(INHALT, "r");
X
X  sprintf(tmp, "%s/%d.l2", TMP, getpid());
X  sprintf(s, "cp %s %s > /dev/null", INHALT, tmp);
X  system(s);
X
X  fp = fopen(tmp, "r");
X  if (fp == NULL) {
X	nerror("lesen2.c", 217, "loeschen2", "Datei-Lesefehler", tmp);
X  }
X  fgets(ex, 250, fp);
X  fgets(ex, 250, fp);
X
X  PM = 1;
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X	PM = 0;
X  }
X  plus = 0;
X
X  if (von > bis) {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if (COPIES != 0) {
X			if(ex[5] != '>') i = -1;
X		}
X		if ((i >= bis) && (i <= von)) {
X			sprintf(s, "%d", i);
X			loeschen(s);
X			plus++;
X		}
X	}
X  }
X  else {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if (COPIES != 0) {
X			if(ex[5] != '>') i = -1;
X		}
X		if ((i >= von) && (i <= bis)) {
X			sprintf(s, "%d", i);
X			loeschen(s);
X			plus++;
X		}
X	}
X  }
X  fclose(fp);
X
X  if (plus == 0) {
X	ansi("md");
X	printf(" <- %s\n", LE214_MSG);
X	ansi("me");
X	return;
X  }
X 
X  unlink(tmp);
X
X  return;
X}
END_OF_FILE
  if test 10703 -ne `wc -c <'src/lesen2.c'`; then
    echo shar: \"'src/lesen2.c'\" unpacked with wrong size!
  fi
  # end of 'src/lesen2.c'
fi
if test -f 'src/mbox.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mbox.h'\"
else
  echo shar: Extracting \"'src/mbox.h'\" \(13205 characters\)
  sed "s/^X//" >'src/mbox.h' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/MBox						   */
X/*             DATEI  mbox.h						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  04.09.1992					   */
X/***************************************************************************/
X 
X#include "mbox.msg"
X#include "defs.h"
X#include "patchlevel.h"
X
X
X 
X/***************************************************************************/
X/* >ORGANIZATION  -  frei waehlbar (moeglichst identisch mit dem ent-      */
X/*		     sprechenden Eintrag fuer NEWS)			   */
X/* >SYSTEM        -  frei waehlbar (Name der Mailbox)     	  	   */
X/***************************************************************************/
X
X#define ORGANIZATION 	"THE UNDERGROUND NETWORK"
X#define SYSTEM       	"The Time Traveling Agency"  
X
X
X
X/***************************************************************************/
X/*  VERSION       -  wird vom Autor (und nur vom dem) geandert		   */
X/*                   Co-Autoren, Portierer etc. koennen sich gefaelligst   */
X/*		     ihren eigenen Eintrag basteln.		           */
X/*  AUTOR         -  das bin ich - Hallo auch !				   */
X/***************************************************************************/
X
X#define VERSION	     	"ix/MBox 1.6"
X#define AUTOR        	"by <volkers@unnet.w.open.DE>"
X
X
X
X
X/***************************************************************************/
X/* >UUCPSITE       - Systemname innerhalb der UUCP-Netze		   */
X/* >UUCPID2        - Adresse (Domain-) im Internet			   */
X/* >UUCPID1        - Adresse (Domain-) im lokalen UUCP-Netz 		   */
X/* >UUCPBANG       - Adresse als BANG-Pfad				   */
X/*  UUCPCOSTS      - Gebuehrenaufstellung				   */
X/* >SMARTHOST	   - 							   */
X/***************************************************************************/
X
X#define UUCPSITE     	"unnet"
X#define UUCPID2      	"unnet.w.open.DE"        
X#define UUCPID1	     	"unnet.ruhr.SUB.ORG"
X#define UUCPBANG     	"~!unido!horga!xenox!unnet!"
X#define UUCPCOSTS    	"/usr/spool/uucp/.costs"
X#define SMARTHOST	"xenox"
X
X
X
X/***************************************************************************/
X/*  X_MAIL_DEMON    - Name des X-Mail-Daemons (HAENDE WEG !!!) 		   */
X/***************************************************************************/
X
X#define X_MAIL_DEMON 	"X-Mail-Daemon"
X
X
X
X
X/***************************************************************************/
X/*  LIB		     - Pfad zum MBox-Directory LIB			   */
X/*  TMP              - Directory fuer temporaere Dateien		   */
X/* >NEWS	     - Pfad zum SPOOL-Directory fuer NEWS		   */
X/*  NEWSGROUPS       - Pfad zur Datei mit den Erlaeuterungen der Gruppen   */
X/*  ERRMBOX          - Mailbox des Error-Users (POSTMASTER)		   */
X/*  MAILDROP         - Pfad zu den Maildrops der SH-User		   */
X/* >NGROUPS          - Pfad zur "active"-Datei von NEWS			   */
X/*  AGROUPS	     - Pfad zur MBox-"active"-Datei			   */
X/***************************************************************************/
X
X#define LIB	     	"./lib"
X#define TMP	     	"/tmp"
X#define NEWS         	"/usr/spool/news"
X#define NEWSGROUPS	"/usr/lib/news/newsgroups"
X#define ERRMBOX      	"/usr/spool/mail/postmaster"
X#define MAILDROP     	"/usr/spool/mail"
X#define NGROUPS      	"/usr/lib/news/active"
X#define AGROUPS      	"./etc/active"
X
X
X
X
X
X/***************************************************************************/
X/* >CONSOLE	      - Geraet/Datei fuer die Logbuch-Ausgaben		   */
X/*			Ist CONSOLE als "REDIRECT" definiert, wird aus der */
X/*                      Datei CDIRECTFL der Name der Ausgabedatei gelesen  */
X/*			gelesen					           */
X/*  CDIRECTFL         - Geraet/Datei wohin CONSOLE-Info ausgeben wird	   */
X/*		        Die Datei ENTHAELT DEN NAMEN der Ausgabedatei !!!  */
X/* >CPRN              - Geraet/Datei fuer Fehler-Ausgaben		   */
X/* >POSTMASTER        - Name des SYSOPs (identisch mit dessen SH-Account)  */
X/*  MAX_BPS           - Maximale Modem-Ubertragungsrate in BPS             */
X/* >PMS_TTY           - Nummer des einzigen Terminals, auf dem sich "root" */
X/*			anmelden darf					   */
X/*  GUEST             - MBox-Account fuer Besucher			   */
X/*  UDBASE            - Pfad zur Teilnehmer-Datenbank			   */
X/*  UDSEQ             - Pfad zur Teilnehmer-SEQ-Datei			   */
X/***************************************************************************/
X
X#define CONSOLE	     	"REDIRECT"
X#define CDIRECTFL    	"/etc/mbox.out"
X#define CPRN	     	"/tmp/errlog"
X#define POSTMASTER   	"volkers"
X#define PMS_TTY      	"/dev/tty4"
X#define MAX_BPS      	19200
X#define GUEST        	"GAST"
X#define UDBASE       	"./etc/users.data"
X#define UDSEQ        	"./etc/users.seq"
X
X
X
X
X/***************************************************************************/
X/*  BEFEHLE 	   - Pfad zur Befehls-Tabelle				   */
X/*  HILFE          - Pfad zu den HELP-Texten				   */
X/*  KURZHILFE	   - Kurzuebersicht					   */
X/*  INTRO          - Pfad zur INTRO-Meldung				   */
X/*  LOGO           - Optionaler Text als Mailbox-LOGO 			   */
X/*  SYSINFO	   - Allgemeine Infos zur MBox				   */
X/***************************************************************************/
X
X#define BEFEHLE	     	"./etc/help.befehle"  
X#define HILFE	     	"./etc/help.hilfe"
X#define KURZHILFE    	"./etc/help.shorthelp"
X#define INTRO        	"./etc/intro"
X#define LOGO         	"./etc/logo"
X#define SYSINFO		"./etc/sysinfo"
X
X
X
X/***************************************************************************/
X/*  SEQ             - Pfad zur MBox-SEQ-Datei (Anzahl der Anrufe)	   */
X/*  CALLS           - Pfad zur MBox-CALLS-Datei (Logfile)		   */
X/*  WHO             - Pfad zur MBox-WHO-Datei (gerade aktive User)	   */
X/***************************************************************************/
X
X#define SEQ          	"./etc/mbox.seq"
X#define CALLS        	"./etc/mbox.calls"
X#define WHO          	"./etc/mbox.who"
X
X
X
X
X/***************************************************************************/
X/*  EDITORS          - Pfad zur Liste der verfuegbaren Eddies		   */
X/*  GAMES            - Pfad zur Liste der Online-Spiele			   */
X/*  MAX_GAMES 	     - Anzahl der max. angebotenen Spiele		   */
X/* >CHAT             - Pfad zum CHAT-Programm				   */
X/*  RSH              - MBox-RSH; NICHT identisch mit RemoteSH/RestrictedSH */
X/*  UDCS	     - Pfad zur Liste der 'User defined Commands'	   */
X/*  PACKERS	     - Pfad zur Liste der Komprimierer/Archivierer         */
X/***************************************************************************/
X
X#define EDITORS      	"./etc/mbox.editors"
X#define GAMES	     	"./etc/mbox.games"
X#define MAX_GAMES	10
X#define CHAT         	"/usr/bin/chat"
X#define RSH          	"./mbrsh"
X#define UDCS		"./etc/mbox.udc"
X#define PACKERS		"./etc/mbox.packers"
X
X
X
X
X/***************************************************************************/
X/*  ROOT_UID          - siehe "/etc/passwd"				   */
X/*  ROOT_GID          - dito						   */
X/*  GUEST_GID 	      - dito (unbedingt != GID fuer "normale" User)        */
X/***************************************************************************/
X
X#define ROOT_UID      	0
X#define ROOT_GID      	0
X#define GUEST_GID     	1
X
X
X
X
X
X/***************************************************************************/
X/* >FIRST_EX_TTY       - Nummer des ersten seriellen Terminals		   */
X/*  MAX_TERMINALS      - Max. Anzahl der aktiven Terminals 		   */
X/***************************************************************************/
X
X#define FIRST_EX_TTY	64
X#define MAX_TERMINALS	20
X
X
X
X
X/***************************************************************************/
X/* >SIGNATURE          - Name des '.signature'-File im $HOME eins SH-Users */
X/* >TSET               - Pfad zum TSET-Programm				   */
X/* >EXPIRE             - Pfad zum EXPIRE-Programm			   */
X/*  MB-DAEMON          - Pfad zum MB-DAEMON-Programm			   */
X/*  MB_DLOG            - Pfad zum MB-DAEMON-Statistik-File		   */
X/*  XMDLOG	       - Pfad zum XMD-Protokoll-File		           */
X/*  XMD_ALIAS	       - Pfad zur Alias-Datei des XMD			   */
X/*  RETURNED_MAIL      - Absender einer unzustellbaren Mail                */
X/***************************************************************************/
X
X#define SIGNATURE    	".wmailsign"
X#define TSET         	"./etc/tset"
X#define EXPIRE       	"/usr/lib/news/expire"
X#define MB_DAEMON    	"/usr/bin/mb-daemon"
X#define MB_DLOG      	"./etc/mbd.log"
X#define XMDLOG	     	"/usr/adm/xmd.log"
X#define XMD_ALIAS	"./etc/xmd.alias"
X#define RETURNED_MAIL   "From postmaster"
X
X
X
X/***************************************************************************/
X/* >COMPRESS		- Pfad zum Standard-COMPRESS			   */
X/* >GREP 		- Pfad zum SUCH-Programm (GREP -L: Filename only !)*/
X/* >SORTEDCUT           - Zaehlt die Downloads pro File			   */
X/* >SECONDCUT           - Zaehlt die Anrufe pro User			   */
X/* >UUX                 - Fuehrt Kommandos auf fremden Sites aus	   */
X/*  TAR			- Tar-Synopsis zum bilden eines neuen Archives     */
X/***************************************************************************/
X
X#define COMPRESS     	"/usr/bin/compress"
X#define GREP         	"/usr/bin/grep -l"
X#define SORTEDCUT       "cut -d' ' -i2 -f3 %s | sort - | uniq -c | sort -r - | sed '/ \\//s//   \\//g' > %s"
X#define SECONDCUT	"cut -c6-35 %s | sed '/  /s//    /g' | sort - | uniq -c | sort -r - > %s"
X#define UUX		"uux -r"
X#define TAR		"/usr/bin/tar cf"
X
X
X
X/***************************************************************************/
X/*  PDNG		 - Name der Freeware/Shareware/PD-NG		   */
X/*  PDLOG                - PD-Download-Protokoll			   */
X/*  PDSCRIPT		 - Pfad zum Protokoll der UPLOADs		   */
X/* >NEWS_MINIMUM         - Mindestens verfuegbare NGs			   */
X/*  MAX_PER_NG           - Maximale Anzahl der Eintraege pro NG		   */
X/*  EXPIRE_DAYS          - Ab wann loeschen, wenn MAX_PER_NG erreicht ist  */
X/*  MAX_XMD_ALIAS	 - Wieviele Namen kann XMD "umleiten"              */
X/*  NAT_DOMAIN1          - Nationale Domains (gebuehrenfrei)		   */
X/*  NAT_DOMAIN2          - (dito)					   */
X/*  NAT_DOMAIN3          - (dito)					   */
X/***************************************************************************/
X
X#define PDNG	     	"local.pd"
X#define PDLOG	     	"./etc/pd.log"
X#define PDSCRIPT     	"./etc/pd.script"
X#define NEWS_MINIMUM 	"local xenox de amnet zerberus"
X#define MAX_PER_NG   	2000
X#define EXPIRED_DAYS 	32
X#define MAX_XMD_ALIAS   20
X#define NAT_DOMAIN1  	".de"
X#define NAT_DOMAIN2  	".sub.org"
X#define NAT_DOMAIN3  	".de" 
X
X
X
X
X
X/***************************************************************************/
X/*  SZ  		  - ZModem Download				   */
X/*  SX			  - X-Modem					   */
X/*  SB		          - Y-Modem					   */
X/*  RZ			  - ZModem Upload				   */
X/*  RX                    - X-Modem 					   */
X/*  RB                    - Y-Modem					   */
X/***************************************************************************/
X
X#define SZ           	"/usr/bin/sz"
X#define SX           	"/usr/bin/sx"
X#define SB 	     	"/usr/bin/sb"
X
X#define RZ           	"/usr/bin/rz"
X#define RX	     	"/usr/bin/rx"
X#define RB	     	"/usr/bin/rb"
X
X
X
X
X
X/***************************************************************************/
X/*  TARIF           	  - Pfennige pro Einheit (Telefongebuehren)	   */
X/*  NZNT                  - Sekunden pro Einheit Nahzone/Normal-Tarif	   */
X/*  NZBT                  -                      Nahzone/Billig-Tarif	   */
X/*  RZNT                  - 		         Regionalzone/Normal-Tarif */
X/*  RZBT		  -			 Regionalzone/Billig-Tarif */
X/*  WZNT		  -			 Weitzone/Normal-Tarif     */
X/*  WZBT		  -			 Weitzone/Billig-Tarif     */
X/***************************************************************************/
X
X#define TARIF        	23
X#define NZNT         	360
X#define NZBT         	720
X#define RZNT 	     	60
X#define RZBT	    	120
X#define WZNT	     	21
X#define WZBT	     	42
X
X
X
X
X/***************************************************************************/
X/*  PRO_ENTRIES    	  - Maximal Eintraege in MBOX.CALLS      	   */
X/*  MAX_TAGE		  - Max. Eintraege im PRO-Diagramm		   */
X/***************************************************************************/
X
X#define PRO_ENTRIES  	999
X#define MAX_TAGE	16
X
X
X
X/***************************************************************************/
X/*  MVERSION		  - Version des MB-DAEMON			   */
X/*  REFLECT_NG		  - Auf diese Gruppe wird "reflektiert"		   */
X/*  REFLECT_LOG		  - LOG-File des Reflektors			   */
X/*  DIRLIST		  - Wird gesendet bei DIRLIST-Request 		   */
X/*  REFLECTUID		  - UID des Reflektors (siehe /etc/passwd)         */
X/*  TZS			  - ?? Fehler in der Zeitberechnung ??		   */
X/***************************************************************************/
X
X#define MVERSION    	"+++ Un.Net Reflecting Device - Version 1.6 (PL10j7) / MB-DAEMON +++"
X#define REFLECT_NG  	"xenox.test"
X#define REFLECT_LOG 	"/local/mbox/etc/reflector.log"
X#define DIRLIST     	"/public/pd/DIRLIST"
X#define REFLECTUID  	22
X#define TZS		1
X
X
X/***************************************************************************/
X/*  MIME-VERSION	  - MIME Versionsnummer (f. MultiMedia-Mail)	   */
X/***************************************************************************/
X
X#define MIME_VERSION	"1.0"
X
X
X
END_OF_FILE
  if test 13205 -ne `wc -c <'src/mbox.h'`; then
    echo shar: \"'src/mbox.h'\" unpacked with wrong size!
  fi
  # end of 'src/mbox.h'
fi
echo shar: End of archive 10 \(of 15\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
