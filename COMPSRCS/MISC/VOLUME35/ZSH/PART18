Newsgroups: comp.sources.misc
From: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Subject: v35i068:  zsh - The Z Shell, version 2.3.1, Part18/22
Message-ID: <1993Feb20.212820.29364@sparky.imd.sterling.com>
X-Md4-Signature: 025e7dcfe312099fc7d46c9c6cc19e87
Date: Sat, 20 Feb 1993 21:28:20 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Posting-number: Volume 35, Issue 68
Archive-name: zsh/part18
Environment: UNIX
Supersedes: zsh2.2: Volume 29, Issue 97-113

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  func/namedir help/typeset src/lex.c src/zle_main.c
#   src/zle_misc.c
# Wrapped by mattson@odin on Sat Feb  6 14:41:55 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 22)."'
if test -f 'func/namedir' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'func/namedir'\"
else
  echo shar: Extracting \"'func/namedir'\" \(412 characters\)
  sed "s/^X//" >'func/namedir' <<'END_OF_FILE'
X# give a name to a directory
X
X$1=~+
X: ~$1
X
X# for example, if we say: namedir foo
X# where the current directory is /usr/princeton/common/src/news/nntp/inews
X# this will do:
X#
X# foo=/usr/princeton/common/src/news/nntp/inews
X# : ~foo
X#
X# The : ~foo just evaluates ~foo, which declares foo as a named directory.
X# The first time a parameter is used with tilde expansion, it is declared
X# as the name of a named dir.
END_OF_FILE
  if test 412 -ne `wc -c <'func/namedir'`; then
    echo shar: \"'func/namedir'\" unpacked with wrong size!
  fi
  chmod +x 'func/namedir'
  # end of 'func/namedir'
fi
if test -f 'help/typeset' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/typeset'\"
else
  echo shar: Extracting \"'help/typeset'\" \(3168 characters\)
  sed "s/^X//" >'help/typeset' <<'END_OF_FILE'
X     declare [ arg ... ]
X          Same as typeset.
X     functions [ +-tu ] [ name ... ]
X          Equivalent to typeset -f.
X     integer
X          Same as typeset -i.
X     local
X          Same as typeset.
X     typeset [ +-LRZfilrtux [n]] [ name[=value] ] ...
X          Set attributes and values for shell  parameters.   When
X          invoked  inside  a  function,  if  name  is not already
X          defined, a new parameter is created which will be unset
X          when  the function completes.  The following attributes
X          are valid:
X          -L   Left justify and remove leading blanks from value.
X               If  n  is  nonzero,  it  defines  the width of the
X               field; otherwise it is determined by the width  of
X               the  value  of  the  first  assignment.   When the
X               parameter is printed, it is filled  on  the  right
X               with  blanks  or truncated if necessary to fit the
X               field.  Leading zeros are removed if the  -Z  flag
X               is also set.
X          -R   Right justify and fill with leading blanks.  If  n
X               is nonzero if defines the width of the field; oth-
X               erwise it is determined by the width of the  value
X               of  the  first  assignment.  When the parameter is
X               printed, the field is left filled with  blanks  or
X               truncated from the end.
X          -Z   Right justify and fill with leading zeros  if  the
X               first  non-blank  character  is a digit and the -L
X               flag has not been set.  If n is nonzero it defines
X               the width of the field; otherwise it is determined
X               by the width of the value of the first assignment.
X          -f   The names refer to functions rather  than  parame-
X               ters.   No  assignments  can be made, and the only
X               other valid flags are -t  and  -u.   The  flag  -t
X               turns on execution tracing for this function.  The
X               flag -u causes this  function  to  be  marked  for
X               autoloading.  The fpath parameter will be searched
X               to find the function definition when the  function
X               is first referenced.
X          -i   Use an internal integer representation.  If  i  is
X               nonzero  it  defines  the  output arithmetic base,
X               otherwise it is determined by  the  first  assign-
X               ment.
X          -l   Convert to lower case.
X          -r   The given names are marked readonly.
X          -t   Tags the named parameters.  Tags have  no  special
X               meaning to the shell.
X          -u   Convert to upper case.
X          -x   Mark for automatic export to  the  environment  of
X               subsequently executed commands.
X
X     Using + rather than - causes these flags to be  turned  off.
X     If no arguments are given but flags are specified, a list of
X     named parameters which have  these  flags  set  is  printed.
X     Using  + instead of - keeps their values from being printed.
X     If no arguments or options are given, the names  and  attri-
X     butes of all parameters are printed.
END_OF_FILE
  if test 3168 -ne `wc -c <'help/typeset'`; then
    echo shar: \"'help/typeset'\" unpacked with wrong size!
  fi
  # end of 'help/typeset'
fi
if test -f 'src/lex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lex.c'\"
else
  echo shar: Extracting \"'src/lex.c'\" \(16177 characters\)
  sed "s/^X//" >'src/lex.c' <<'END_OF_FILE'
X/*
X *
X * lex.c - lexical analysis
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
X/* lexical state */
X
Xstatic int xincmdpos,xincond,xincasepat,dbparens,xdbparens,xalstat;
Xstatic char *xhlastw;
X
Xstatic int xisfirstln, xisfirstch, xhistremmed, xhistdone,
X	xspaceflag, xstophist, xlithist, xalstackind,xhlinesz;
Xstatic char *xhline, *xhptr;
X
X/* save the lexical state */
X
X/* is this a hack or what? */
X
Xvoid lexsave() /**/
X{
X	xincmdpos = incmdpos;
X	xincond = incond;
X	xincasepat = incasepat;
X	xdbparens = dbparens;
X	xalstat = alstat;
X	xalstackind = alstackind;
X	xisfirstln = isfirstln;
X	xisfirstch = isfirstch;
X	xhistremmed = histremmed;
X	xhistdone = histdone;
X	xspaceflag = spaceflag;
X	xstophist = stophist;
X	xlithist = lithist;
X	xhline = chline;
X	xhptr = hptr;
X	xhlastw = hlastw;
X	xhlinesz = hlinesz;
X	inredir = 0;
X}
X
X/* restore lexical state */
X
Xvoid lexrestore() /**/
X{
X	incmdpos = xincmdpos;
X	incond = xincond;
X	incasepat = xincasepat;
X	dbparens = xdbparens;
X	alstat = xalstat;
X	isfirstln = xisfirstln;
X	isfirstch = xisfirstch;
X	histremmed = xhistremmed;
X	histdone = xhistdone;
X	spaceflag = xspaceflag;
X	stophist = xstophist;
X	lithist = xlithist;
X	chline = xhline;
X	hptr = xhptr;
X	hlastw = xhlastw;
X	clearalstack();
X	alstackind = xalstackind;
X	hlinesz = xhlinesz;
X	lexstop = errflag = 0;
X}
X
Xvoid yylex() /**/
X{
X	if (tok == LEXERR) return;
X	do
X		tok = gettok();
X	while (tok != ENDINPUT && exalias());
X	if (tok != NEWLIN) isnewlin = 0;
X	else isnewlin = (inbufct) ? -1 : 1;
X	if (tok == SEMI || tok == NEWLIN) tok = SEPER;
X}
X
Xvoid ctxtlex() /**/
X{
Xstatic int oldpos;
X
X	yylex();
X	switch (tok) {
X	case SEPER: case NEWLIN: case SEMI: case DSEMI: case AMPER:
X	case INPAR: case INBRACE: case DBAR: case DAMPER: case BAR:
X	case BARAMP: case INOUTPAR: case DO: case THEN: case ELIF:
X	case ELSE: incmdpos = 1; break;
X	case STRING: /* case ENVSTRING: */ case ENVARRAY: case OUTPAR:
X	case CASE: incmdpos = 0; break;
X	}
X	if (IS_REDIROP(tok) || tok == FOR || tok == FOREACH || tok == SELECT) {
X		inredir = 1;
X		oldpos = incmdpos;
X		incmdpos = 0;
X	} else if (inredir) {
X		incmdpos = oldpos;
X		inredir = 0;
X	}
X}
X
X#define LX1_BKSLASH 0
X#define LX1_COMMENT 1
X#define LX1_NEWLIN 2
X#define LX1_SEMI 3
X#define LX1_BANG 4
X#define LX1_AMPER 5
X#define LX1_BAR 6
X#define LX1_INPAR 7
X#define LX1_OUTPAR 8
X#define LX1_INBRACE 9
X#define LX1_OUTBRACE 10
X#define LX1_INBRACK 11
X#define LX1_OUTBRACK 12
X#define LX1_INANG 13
X#define LX1_OUTANG 14
X#define LX1_OTHER 15
X
X#define LX2_BREAK 0
X#define LX2_OUTPAR 1
X#define LX2_BAR 2
X#define LX2_STRING 3
X#define LX2_INBRACK 4
X#define LX2_OUTBRACK 5
X#define LX2_TILDE 6
X#define LX2_INPAR 7
X#define LX2_INBRACE 8
X#define LX2_OUTBRACE 9
X#define LX2_OUTANG 10
X#define LX2_INANG 11
X#define LX2_EQUALS 12
X#define LX2_BKSLASH 13
X#define LX2_QUOTE 14
X#define LX2_DQUOTE 15
X#define LX2_BQUOTE 16
X#define LX2_OTHER 17
X
Xunsigned char lexact1[256],lexact2[256],lextok2[256];
X
Xvoid initlextabs() /**/
X{
Xint t0;
Xstatic char *lx1 = "\\q\n;!&|(){}[]<>xx";
Xstatic char *lx2 = "x)|$[]~({}><=\\\'\"`x";
X
X	for (t0 = 0; t0 != 256; t0++) {
X		lexact1[t0] = LX1_OTHER;
X		lexact2[t0] = LX2_OTHER;
X		lextok2[t0] = t0;
X	}
X	for (t0 = 0; lx1[t0]; t0++)
X		if (lx1[t0] != 'x')
X			lexact1[(int)lx1[t0]] = t0;
X	for (t0 = 0; lx2[t0]; t0++)
X		if (lx2[t0] != 'x')
X			lexact2[(int)lx2[t0]] = t0;
X	lexact2[';'] = LX2_BREAK;
X	lexact2['&'] = LX2_BREAK;
X	lextok2[','] = Comma;
X	lextok2['*'] = Star;
X	lextok2['?'] = Quest;
X	lextok2['{'] = Inbrace;
X	lextok2['['] = Inbrack;
X	lextok2['$'] = String;
X}
X
X/* initialize lexical state */
X
Xvoid lexinit() /**/
X{
X	incond = incasepat = nocorrect =
X		dbparens = alstat = lexstop = 0;
X	incmdpos = 1;
X	tok = ENDINPUT;
X	if (isset(EXTENDEDGLOB))
X		{
X		lextok2['#'] = Pound;
X		lextok2['^'] = Hat;
X		}
X	else
X		{
X		lextok2['#'] = '#'; 
X		lextok2['^'] = '^';
X		}
X}
X
Xint len = 0,bsiz = 256;
Xchar *bptr;
X
X/* add a char to the string buffer */
X
Xvoid add(c) /**/
Xint c;
X{
X	*bptr++ = c;
X	if (bsiz == ++len)
X		{
X		int newbsiz;
X
X		newbsiz = bsiz * 8;
X		while (newbsiz < inbufct)
X			newbsiz *= 2;
X		bptr = len+(tokstr = hrealloc(tokstr,bsiz,newbsiz));
X		bsiz = newbsiz;
X		}
X}
X
Xstatic void unadd()
X{
X	bptr--; len--;
X}
X
Xint gettok() /**/
X{
Xint bct = 0,pct = 0,brct = 0;
Xint c,d,intpos = 1;
Xint peekfd = -1,peek,ninbracks;
X
Xbeginning:
X	hlastw = NULL;
X	tokstr = NULL;
X	parbegin = -1;
X	while (iblank(c = hgetc()) && !lexstop);
X	isfirstln = 0;
X	wordbeg = inbufct;
X	hwbegin();
X	hwaddc(c);
X	if (dbparens)	/* handle ((...)) */
X		{
X		pct = 2;
X		peek = STRING;
X		len = dbparens = 0;
X		bptr = tokstr = ncalloc(bsiz = 256);
X		for (;;)
X			{
X			if (c == '(')
X				pct++;
X			else if (c == ')')
X				pct--;
X			else if (c == '\n')
X				{
X				zerr("parse error: )) expected",NULL,0);
X				peek = LEXERR;
X				return peek;
X				}
X			else if (c == '$')
X				c = String;
X			if (pct >= 2)
X				add(c);
X			if (pct)
X				c = hgetc();
X			else
X				break;
X			}
X		*bptr = '\0';
X		return peek;
X		}
X	if (idigit(c))	/* handle 1< foo */
X		{
X		d = hgetc();
X		hungetc(d);
X		lexstop = 0;
X		if (d == '>' || d == '<')
X			{
X			peekfd = c-'0';
X			c = hgetc();
X			}
X		}
X
X	/* chars in initial position in word */
X
X	if (c == hashchar &&
X			(isset(INTERACTIVECOMMENTS) ||
X			(!zleparse && (!interact || unset(SHINSTDIN) || strin))))
X		{
X		/* History is handled here to prevent extra newlines
X		 * being inserted into the history.
X		 *
X		 * Also ignore trailing spaces to prevent history from
X		 * changing. If trailing spaces are not ignored then
X		 * each time a comment inside a command (a 'for' loop
X		 * is a good example) is seen an extra space is appended
X		 * to the end of the comment causing a new history entry
X		 * even if HISTIGNOREDUPS is set.
X		 */
X		int nsp = 0;		/* number of contiguos spaces */
X		while ((c = hgetch()) != '\n' && !lexstop) {
X			if (c == ' ')
X				++nsp;
X			else {
X				while (nsp) {
X					hwaddc(' ');
X					--nsp;
X				}
X				hwaddc(c);
X			}
X		}
X		if (c == '\n') {
X			hwadd();
X			hwbegin();
X			hwaddc(c);
X 			peek = NEWLIN;
X 		} else {
X 			peek = (errflag) ? LEXERR : ENDINPUT;
X 			errflag = 1;
X 		}
X		return peek;
X		}
X	if (lexstop)
X		return (errflag) ? LEXERR : ENDINPUT;
X	switch (lexact1[(unsigned char) c])
X		{
X		case LX1_BKSLASH:
X			d = hgetc();
X			if (d == '\n')
X				goto beginning;
X			hungetc(d);
X			break;
X		case LX1_NEWLIN: return NEWLIN;
X		case LX1_SEMI:
X			d = hgetc();
X			if (d != ';')
X				{
X				hungetc(d);
X				return SEMI;
X				}
X			return DSEMI;
X		case LX1_BANG:
X			d = hgetc();
X			hungetc(d);
X			if (!inblank(d))
X				break;
X			if (incmdpos || incond)
X				return BANG;
X			break;
X		case LX1_AMPER:
X			d = hgetc();
X			if (d != '&')
X				{
X				hungetc(d);
X				return AMPER;
X				}
X			return DAMPER;
X		case LX1_BAR:
X			d = hgetc();
X			if (d == '|')
X				return DBAR;
X			else if (d == '&')
X				return BARAMP;
X			hungetc(d);
X			return BAR;
X		case LX1_INPAR:
X			d = hgetc();
X			if (d == '(' && incmdpos)
X				{
X				tokstr = strdup("let");
X				dbparens = 1;
X				return STRING;
X				}
X			else if (d == ')')
X				return INOUTPAR;
X			hungetc(d);
X			if (!(incond || incmdpos))
X				break;
X			return INPAR;
X		case LX1_OUTPAR: return OUTPAR;
X		case LX1_INBRACE: if (!incmdpos) break; return INBRACE;
X		case LX1_OUTBRACE: return OUTBRACE;
X		case LX1_INBRACK:
X			if (!incmdpos)
X				break;
X			d = hgetc();
X			if (d == '[')
X				return DINBRACK;
X			hungetc(d);
X			break;
X		case LX1_OUTBRACK:
X			if (!incond)
X				break;
X			d = hgetc();
X			if (d == ']')
X				return DOUTBRACK;
X			hungetc(d);
X			break;
X		case LX1_INANG:
X			d = hgetc();
X			if ((!incmdpos && d == '(') || incasepat ||
X					idigit(d) || d == '-' || d == '>') {
X				hungetc(d);
X				break;
X			} else if (d == '<') {
X				int e = hgetc();
X
X				if (e == '(') {
X					hungetc(e);
X					hungetc(d);
X					peek = INANG;
X				} else if (e == '<')
X					peek = TRINANG;
X				else if (e == '-')
X					peek = DINANGDASH;
X				else {
X					hungetc(e);
X					peek = DINANG;
X				}
X			} else if (d == '&')
X				peek = INANGAMP;
X			else {
X				peek = INANG;
X				hungetc(d);
X			}
X			tokfd = peekfd;
X			return peek;
X		case LX1_OUTANG:
X			d = hgetc();
X			if (d == '(')
X				{
X				hungetc(d);
X				break;
X				}
X			else if (d == '&')
X				{
X				d = hgetc();
X				if (d == '!')
X					peek = OUTANGAMPBANG;
X				else
X					{
X					hungetc(d);
X					peek = OUTANGAMP;
X					}
X				}
X			else if (d == '!')
X				peek = OUTANGBANG;
X			else if (d == '>')
X				{
X				d = hgetc();
X				if (d == '&')
X					{
X					d = hgetc();
X					if (d == '!')
X						peek = DOUTANGAMPBANG;
X					else
X						{
X						hungetc(d);
X						peek = DOUTANGAMP;
X						}
X					}
X				else if (d == '!')
X					peek = DOUTANGBANG;
X				else if (d == '(')
X					{
X					hungetc(d);
X					hungetc('>');
X					peek = OUTANG;
X					}
X				else
X					{
X					hungetc(d);
X					peek = DOUTANG;
X					if (isset(NOCLOBBER)) hwaddc('!');
X					}
X				}
X			else
X				{
X				hungetc(d);
X				peek = OUTANG;
X				if (isset(NOCLOBBER)) hwaddc('!');
X				}
X			tokfd = peekfd;
X			return peek;
X		}
X
X	/* we've started a string, now get the rest of it, performing
X		tokenization */
X
X	peek = STRING;
X	len = 0;
X	bptr = tokstr = ncalloc(bsiz = 256);
X	for(;;)
X		{
X		int act;
X		int d;
X		
X		if (inblank(c) && !bct)
X			act = LX2_BREAK;
X		else
X			{
X			act = lexact2[(unsigned char) c];
X			c = lextok2[(unsigned char) c];
X			}
X		switch (act)
X			{
X			case LX2_BREAK: goto brk;
X			case LX2_OUTPAR:
X				if (!pct)
X					goto brk;
X				c = Outpar;
X				pct--;
X				break;
X			case LX2_BAR:
X				if (!pct && !incasepat)
X					goto brk;
X				c = Bar;
X				break;
X			case LX2_STRING:
X				d = hgetc();
X				if (d == '[')
X					{
X					add(String);
X					add(Inbrack);
X					ninbracks = 1;
X					while (ninbracks && (c = hgetc()) && !lexstop) {
X						if (c == '[') ninbracks++;
X						else if (c == ']') ninbracks--;
X						if (ninbracks) add(c);
X					}
X					c = Outbrack;
X					}
X				else if (d == '(')
X					{
X					add(String);
X					if (skipcomm()) { peek = LEXERR; goto brk; }
X					c = Outpar;
X					}
X				else
X					hungetc(d);
X				break;
X			case LX2_INBRACK: brct++; break;
X			case LX2_OUTBRACK:
X				if (incond && !brct)
X					goto brk;
X				brct--;
X				c = Outbrack;
X				break;
X			case LX2_TILDE: /* if (intpos) */ c = Tilde; break;
X			case LX2_INPAR:
X				d = hgetc();
X				hungetc(d);
X				if (d == ')' || (incmdpos && peek != ENVSTRING))
X					goto brk;
X				pct++;
X				c = Inpar;
X				break;
X			case LX2_INBRACE: bct++; break;
X			case LX2_OUTBRACE:
X				if (!bct)
X					goto brk;
X				bct--;
X				c = Outbrace;
X				break;
X			case LX2_OUTANG:
X				d = hgetc();
X				if (d != '(')
X					{
X					hungetc(d);
X					goto brk;
X					}
X				add(Outang);
X				if (skipcomm()) { peek = LEXERR; goto brk; }
X				c = Outpar;
X				break;
X			case LX2_INANG:
X				d = hgetc();
X				if (!(idigit(d) || d == '-' || d == '>' || d == '(' || d == ')'))
X					{
X					hungetc(d);
X					goto brk;
X					}
X				c = Inang;
X				if (d == '(')
X					{
X					add(c);
X					if (skipcomm()) { peek = LEXERR; goto brk; }
X					c = Outpar;
X					}
X				else if (d == ')')
X					hungetc(d);
X				else
X					{
X					add(c);
X					c = d;
X					while (c != '>' && !lexstop)
X						add(c),c = hgetc();
X					c = Outang;
X					}
X				break;
X			case LX2_EQUALS:
X				if (intpos)
X					{
X					d = hgetc();
X					if (d != '(')
X						{
X						hungetc(d);
X						c = Equals;
X						}
X					else
X						{
X						add(Equals);
X						if (skipcomm()) { peek = LEXERR; goto brk; }
X						c = Outpar;
X						}
X					}
X				else if (peek != ENVSTRING && incmdpos && !bct)
X					{
X					d = hgetc();
X					if (d == '(' && incmdpos)
X						{
X						*bptr = '\0';
X						return ENVARRAY;
X						}
X					hungetc(d);
X					peek = ENVSTRING;
X					intpos = 2;
X					}
X				break;
X			case LX2_BKSLASH:
X				c = hgetc();
X				if (c == '\n')
X					{
X					c = hgetc();
X					continue;
X					}
X				add(Bnull);
X				add(c);
X				c = hgetc();
X				continue;
X			case LX2_QUOTE:
X				add(Snull);
X
X				/* we add the Nularg to prevent this:
X
X				echo $PA'TH'
X
X				from printing the path. */
X
X				for (;;) {
X					while ((c = hgetc()) != '\'' && !lexstop) {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						add(c);
X					}
X					if (c != '\'') {
X						zerr("unmatched \'",NULL,0);
X						peek = LEXERR;
X						goto brk;
X					}
X					d = hgetc();
X					if (d != '\'' || unset(RCQUOTES)) break;
X					add(c);
X				}
X				hungetc(d);
X				c = Snull;
X				break;
X			case LX2_DQUOTE:
X				add(Dnull);
X				while ((c = hgetc()) != '\"' && !lexstop)
X					if (c == '\\')
X						{
X						c = hgetc();
X						if (c != '\n')
X							{
X							if (c != '$' && c != '\\' && c != '\"' && c != '`')
X								add('\\');
X							add(c);
X							}
X						}
X					else {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						if (c == '$') {
X							d = hgetc();
X							if (d == '(') {
X								add(Qstring);
X								if (skipcomm()) { peek = LEXERR; goto brk; }
X								c = Outpar;
X							} else if (d == '[') {
X								add(String);
X								add(Inbrack);
X								while ((c = hgetc()) != ']' && !lexstop)
X									add(c);
X								c = Outbrack;
X							} else {
X								c = Qstring;
X								hungetc(d);
X							}
X						} else if (c == '`')
X							c = Qtick;
X						add(c);
X					}
X				if (c != '\"') {
X					zerr("unmatched \"",NULL,0);
X					peek = LEXERR;
X					goto brk;
X				}
X				c = Dnull;
X				break;
X			case LX2_BQUOTE:
X				add(Tick);
X				parbegin = inbufct;
X				while ((c = hgetc()) != '`' && !lexstop)
X					if (c == '\\')
X						{
X						c = hgetc();
X						if (c != '\n')
X							{
X							if (c != '`' && c != '\\' && c != '$')
X								add('\\');
X							add(c);
X							}
X						}
X					else {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						add(c);
X					}
X				if (c != '`') {
X					if (!zleparse) zerr("unmatched `",NULL,0);
X					peek = LEXERR;
X					goto brk;
X				}
X				c = Tick;
X				parbegin = -1;
X				break;
X			}
X		add(c);
X		c = hgetc();
X		if (intpos)
X			intpos--;
X		if (lexstop)
X			break;
X		}
Xbrk:
X	hungetc(c);
X	*bptr = '\0';
X	return peek;
X}
X
X/* expand aliases, perhaps */
X
Xint exalias() /**/
X{
Xstruct alias *an;
Xchar *s,*t;
X
X	s = yytext = hwadd();
X	for (t = s; *t && *t != HISTSPACE; t++);
X	if (!*t)
X		t = NULL;
X	else
X		*t = '\0';
X	if (interact && isset(SHINSTDIN) && !strin && !incasepat && tok == STRING &&
X		(isset(CORRECTALL) || (isset(CORRECT) && incmdpos)) && !nocorrect)
X			spckword(&tokstr,&s,&t,!incmdpos,1);
X	if (zleparse && !alstackind) {
X		int zp = zleparse;
X		gotword(s);
X		if (zp && !zleparse) {
X			if (t) *t = HISTSPACE;
X			return 0;
X		}
X	}
X	an = gethnode(s,aliastab);
X	if (t) *t = HISTSPACE;
X	if (alstackind != MAXAL && an && !an->inuse)
X		if (!(an->cmd && !incmdpos && alstat != ALSTAT_MORE)) {
X			if (an->cmd < 0) {
X				tok = DO-an->cmd-1;
X				return 0;
X			} else {
X				an->inuse = 1;
X				hungets(ALPOPS);
X				hungets((alstack[alstackind++] = an)->text);
X				alstat = 0;
X				/* remove from history if it begins with space */
X				if (isset(HISTIGNORESPACE) && an->text[0] == ' ') remhist();
X				lexstop = 0;
X				return 1;
X			}
X		}
X	return 0;
X}
X
X/* skip (...) */
X
Xint skipcomm() /**/
X{
Xint pct = 1,c;
X
X	parbegin = inbufct;
X	c = Inpar;
X	do
X		{
X		add(c);
X		c = hgetc();
X		if (itok(c) || lexstop)
X			break;
X		else if (c == '(') pct++;
X		else if (c == ')') pct--;
X		else if (c == '\\')
X			{
X			add(c);
X			c = hgetc();
X			}
X		else if (c == '\'')
X			{
X			add(c);
X			while ((c = hgetc()) != '\'' && !lexstop)
X				add(c);
X			}
X		else if (c == '\"')
X			{
X			add(c);
X			while ((c = hgetc()) != '\"' && !lexstop)
X				if (c == '\\')
X					{
X					add(c);
X					add(hgetc());
X					}
X				else add(c);
X			}
X		else if (c == '`')
X			{
X			add(c);
X			while ((c = hgetc()) != '`' && !lexstop)
X				if (c == '\\') add(c), add(hgetc());
X				else add(c);
X			}
X		}
X	while(pct);
X	if (!lexstop) parbegin = -1;
X	return lexstop;
X}
END_OF_FILE
  if test 16177 -ne `wc -c <'src/lex.c'`; then
    echo shar: \"'src/lex.c'\" unpacked with wrong size!
  fi
  # end of 'src/lex.c'
fi
if test -f 'src/zle_main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zle_main.c'\"
else
  echo shar: Extracting \"'src/zle_main.c'\" \(15021 characters\)
  sed "s/^X//" >'src/zle_main.c' <<'END_OF_FILE'
X/*
X *
X * zle_main.c - main routines for line editor
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLEGLOBALS
X#define ZLE
X#include "zsh.h"
X#include <sys/types.h>
X#include <sys/errno.h>
X#ifdef HAS_SYS_SELECT
X#include <sys/select.h>
X#endif
X
Xstatic Key cky;
X
X/* set up terminal */
X
Xvoid setterm() /**/
X{
Xstruct ttyinfo ti;
X#ifdef CLOBBERS_TYPEAHEAD
X#ifdef FIONREAD
Xlong val;
X#endif
X#endif
X
X#ifdef CLOBBERS_TYPEAHEAD
X#ifdef FIONREAD
X	ioctl(SHTTY, FIONREAD, &val);
X	if (val) return;
X#endif
X#endif
X	inittty();
X	ti = shttyinfo;
X#ifdef TIO
X	ti.tio.c_lflag &= ~(ICANON|ECHO
X#ifdef FLUSHO
X		|FLUSHO
X#endif
X		);
X	ti.tio.c_cc[VQUIT] =
X#ifdef VDISCARD
X		ti.tio.c_cc[VDISCARD] = 
X#endif
X#ifdef VSUSP
X		ti.tio.c_cc[VSUSP] =
X#endif
X#ifdef VDSUSP
X		ti.tio.c_cc[VDSUSP] =
X#endif
X#ifdef VSWTCH
X		ti.tio.c_cc[VSWTCH] =
X#endif
X		VDISABLEVAL;
X	ti.tio.c_cc[VMIN] = 1;
X	ti.tio.c_cc[VTIME] = 0;
X	ti.tio.c_iflag &= ~(INLCR|ICRNL);
X#else
X	ti.sgttyb.sg_flags = (ti.sgttyb.sg_flags | CBREAK) & ~ECHO;
X	ti.lmodes &= ~LFLUSHO;
X	ti.tchars.t_quitc =
X		ti.ltchars.t_suspc =
X		ti.ltchars.t_flushc =
X		ti.ltchars.t_dsuspc = ti.ltchars.t_lnextc = -1;
X#endif
X#ifdef TTY_NEEDS_DRAINING
X	drainoutput();
X#endif
X	settyinfo(&ti);
X}
X
Xvoid unsetterm() /**/
X{
X	settyinfo(&shttyinfo);
X}
X
Xstatic char *kungetbuf;
Xstatic int kungetct,kungetsz;
X
Xvoid ungetkey(ch) /**/
Xint ch;
X{
X	if (kungetct == kungetsz)
X		kungetbuf = realloc(kungetbuf,kungetsz *= 2);
X	kungetbuf[kungetct++] = ch;
X}
X
Xvoid ungetkeys(s,len) /**/
Xchar *s;int len;
X{
X	s += len;
X	while (len--)
X		ungetkey(*--s);
X}
X
X#if (defined(hpux) || defined(pyr)) && defined(HAS_SELECT)
Xstatic int
Xbreakread(fd, buf, n)
Xint fd, n;
Xchar *buf;
X{
X	fd_set	f;
X
X	FD_ZERO(&f);
X	FD_SET(fd, &f);
X	return(select(fd+1, &f, NULL, NULL, NULL) == -1 ? -1 : read(fd, buf, n));
X}
X#define	read	breakread
X#endif
X
Xunsigned int getkey(tmok) /**/
Xint tmok;
X{
Xchar cc;
Xunsigned int ret;
Xint die = 0, r;
X
X	if (kungetct)
X		ret = (unsigned int) (unsigned char) kungetbuf[--kungetct];
X	else {
X		while ( (r = read(0,&cc,1)) != 1){
X			if ( r == 0 ){
X				stopmsg = 1;
X				zexit(1);
X			}
X			if (errno == EINTR) {
X				if (!errflag)
X					continue;
X				errflag = 0;
X				if (tmok)
X					return -1;
X				return 3;
X			} else if (errno == EWOULDBLOCK) {
X				fcntl(0,F_SETFL,0);
X			} else if (errno == EIO && !die) {
X				ret = jobbing;
X				jobbingv = 1;
X				attachtty(mypgrp);
X				refresh(); /* kludge! */
X				jobbingv = ret;
X				die = 1;
X			} else if (errno != 0) {
X				zerr("error on TTY read: %e",NULL,errno);
X				stopmsg = 1;
X				zexit(1);
X			}
X		}
X		ret = (unsigned int) (unsigned char) cc;
X	}
X	if (vichgflag) {
X		if (vichgbufptr == vichgbufsz)
X			vichgbuf = realloc(vichgbuf,vichgbufsz *= 2);
X		vichgbuf[vichgbufptr++] = ret;
X	}
X	return ret;
X}
X
X/* read a line */
X
Xunsigned char *zleread(ppt,ppt2,plen) /**/
Xunsigned char *ppt;unsigned char *ppt2;int plen;
X{
Xint z;
Xlong costmult;
Xunsigned char *s;
X#ifdef HAS_SELECT
Xstruct timeval tv;
Xfd_set foofd;
X
X	tv.tv_sec = 0;
X#endif
X	fflush(stdout);
X	fflush(stderr);
X	intr();
X	costmult = 3840000L/((baud) ? baud : 2400);
X	insmode = unset(OVERSTRIKE); eofsent = 0; resetneeded =0 ;
X	pmpt = (char *)ppt;
X	pmpt2 = (char *)ppt2;
X	permalloc();
X	histline = curhist;
X	pptlen = plen;
X	resetneeded = 1;
X#ifdef HAS_SELECT
X	FD_ZERO(&foofd);
X#endif
X	undoing = 1;
X	line = zalloc(linesz = 256);
X	*line = '\0';
X	virangeflag = lastcmd = done = cs = ll = mark = 0;
X	curhistline = NULL;
X	mult = 1;
X	vibufspec = 0;
X	bindtab = mainbindtab;
X	addedslash = vichgflag = 0;
X	viinsbegin = 0;
X	statusline = NULL;
X	if (s = getnode(bufstack))
X		{
X		setline((char *) s);
X		free(s);
X		if (stackcs != -1)
X			{
X			cs = stackcs;
X			stackcs = -1;
X			if (cs > ll)
X				cs = ll;
X			}
X		if (stackhist != -1)
X			{
X			histline = stackhist;
X			stackhist = -1;
X			}
X		}
X	initundo();
X	if (unset(NOPROMPTCR))
X		putchar('\r');
X	if (tmout)
X		alarm(tmout);
X	refresh();
X	errflag = retflag = 0;
X	while (!done && !errflag)
X		{
X		struct zlecmd *zc;
X		
X		statusline = NULL;
X		bindk = getkeycmd();
X		if (c == 4 && !ll)
X			{
X			eofsent = 1;
X			break;
X			}
X		if (bindk != -1)
X			{
X			zc = zlecmds+bindk;
X			if (!(lastcmd & ZLE_ARG))
X				mult = 1;
X			if ((lastcmd & ZLE_UNDO) != (zc->flags & ZLE_UNDO) && undoing)
X				addundo();
X			if (!(zc->flags & ZLE_MENUCMP)) {
X				if (menucmp) freemenu();
X				if (addedslash && !(zc->flags & ZLE_DELETE) &&
X						!((zc->flags & ZLE_INSERT) && c != ' ')) {
X					backdel(1);
X				}
X				addedslash = 0;
X			}
X			if (zc->func)
X				(*zc->func)();
X			lastcmd = zc->flags;
X			if (!(lastcmd & ZLE_UNDO) && undoing) addundo();
X			}
X		else
X			{
X			errflag = 1;
X			break;
X			}
X#ifdef HAS_SELECT
X		FD_SET(0,&foofd);
X		if ((tv.tv_usec = cost*costmult) > 500000)
X			tv.tv_usec = 500000;
X#endif
X		if (!kungetct
X#ifdef HAS_SELECT
X			&& select(1,&foofd,NULL,NULL,&tv) <= 0
X#endif
X			)
X			refresh();
X		}
X	if (menucmp)
X		freemenu();
X	statusline = NULL;
X	trashzle();
X	alarm(0);
X	z = strlen((char *)line);
X	line[z] = '\n';
X	line[z+1] = 0;
X	heapalloc();
X	if (curhistline)
X		free(curhistline);
X	if (eofsent)
X		{
X		free(line);
X		line = NULL;
X		}
X	zleactive = 0;
X	freeundo();
X	return line;
X}
X
Xint getkeycmd() /**/
X{
Xchar buf[10];
Xint t0,ret;
XKey ky;
X
X	t0 = 1;
X	cky = NULL;
X	if ((c = getkey(1)) == -1)
X		return -1;
X	if ((ret = bindtab[c]) == z_sequenceleadin)
X		{
X		buf[0] = (c) ? c : 0x80;
X		for (;;)
X			{
X			c = getkey(0);
X			buf[t0++] = (c) ? c : 0x80;
X			buf[t0] = '\0';
X			if (!(ky = (Key) gethnode(buf,xbindtab)))
X				return z_undefinedkey;
X			if (ky->func != z_sequenceleadin)
X				{
X				cky = ky;
X				ret = ky->func;
X				break;
X				}
X			}
X		}
X	if (ret == z_vidigitorbeginningofline)
X		ret = (lastcmd & ZLE_ARG) ? z_digitargument : z_beginningofline;
X	else if (ret == z_executenamedcmd)
X		ret = executenamedcommand();
X	else if (ret == z_executelastnamedcmd)
X		ret = lastnamed;
X	return ret;
X}
X
Xvoid sendstring() /**/
X{
Xchar buf[2];
X
X	buf[0] = c;
X	buf[1] = '\0';
X	if (!cky)
X		cky = (Key) gethnode(buf,xbindtab);
X	ungetkeys(cky->str,cky->len);
X}
X
XKey makefunckey(fun) /**/
Xint fun;
X{
XKey ky = zcalloc(sizeof *ky);
X
X	ky->func = fun;
X	return ky;
X}
X
X/* initialize the bindings */
X
Xvoid initxbindtab() /**/
X{
Xint t0,vi = 0;
Xchar buf[3],*s;
X
X	lastnamed = z_undefinedkey;
X	if (s = zgetenv("VISUAL")) {
X		if (ztrstr(s,"vi"))
X			vi = 1;
X	}
X	else if ((s = zgetenv("EDITOR")) && ztrstr(s,"vi"))
X		vi = 1;
X	if (vi) {
X		for (t0 = 0; t0 != 32; t0++)
X			mainbindtab[t0] = viinsbind[t0];
X		for (t0 = 32; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X		mainbindtab[127] = z_backwarddeletechar;
X	} else {
X		for (t0 = 0; t0 != 128; t0++)
X			mainbindtab[t0] = emacsbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X	}
X	for (t0 = 0200; t0 != 0240; t0++)
X		mainbindtab[t0] = z_undefinedkey;
X	for (t0 = 0; t0 != 128; t0++)
X		altbindtab[t0] = vicmdbind[t0];
X	for (t0 = 128; t0 != 256; t0++)
X		altbindtab[t0] = emacsbind[t0];
X	bindtab = mainbindtab;
X	kungetbuf = zalloc(kungetsz = 32);
X	kungetct = 0;
X	xbindtab = newhtable(67);
X	addhperm("\33\133C",makefunckey(z_forwardchar),xbindtab,(FFunc) 0);
X	addhperm("\33\133D",makefunckey(z_backwardchar),xbindtab,(FFunc) 0);
X	addhperm("\33\133A",makefunckey(z_uplineorhistory),xbindtab,(FFunc) 0);
X	addhperm("\33\133B",makefunckey(z_downlineorhistory),xbindtab,(FFunc) 0);
X	addhperm("\30*",makefunckey(z_expandword),xbindtab,(FFunc) 0);
X	addhperm("\30g",makefunckey(z_listexpand),xbindtab,(FFunc) 0);
X	addhperm("\30G",makefunckey(z_listexpand),xbindtab,(FFunc) 0);
X	addhperm("\30\16",makefunckey(z_infernexthistory),xbindtab,(FFunc) 0);
X	addhperm("\30\13",makefunckey(z_killbuffer),xbindtab,(FFunc) 0);
X	addhperm("\30\6",makefunckey(z_vifindnextchar),xbindtab,(FFunc) 0);
X	addhperm("\30\17",makefunckey(z_overwritemode),xbindtab,(FFunc) 0);
X	addhperm("\30\25",makefunckey(z_undo),xbindtab,(FFunc) 0);
X	addhperm("\30\26",makefunckey(z_vicmdmode),xbindtab,(FFunc) 0);
X	addhperm("\30\12",makefunckey(z_vijoin),xbindtab,(FFunc) 0);
X	addhperm("\30\2",makefunckey(z_vimatchbracket),xbindtab,(FFunc) 0);
X	addhperm("\30s",makefunckey(z_historyincrementalsearchforward),
X		xbindtab,(FFunc) 0);
X	addhperm("\30r",makefunckey(z_historyincrementalsearchbackward),
X		xbindtab,(FFunc) 0);
X	addhperm("\30u",makefunckey(z_undo),xbindtab,(FFunc) 0);
X	addhperm("\30\30",makefunckey(z_exchangepointandmark),
X		xbindtab,(FFunc) 0);
X	addhperm("run-help",mkanode(ztrdup("man"),1),aliastab,(FFunc) 0);
X	addhperm("which-command",mkanode(ztrdup("whence"),1),aliastab,(FFunc) 0);
X	strcpy(buf,"\33q");
X	for (t0 = 128; t0 != 256; t0++)
X		if (emacsbind[t0] != z_undefinedkey) {
X			buf[1] = t0 & 0x7f;
X			addhnode(ztrdup(buf),makefunckey(emacsbind[t0]),xbindtab,(FFunc) 0);
X		}
X	for (t0 = 0; t0 != 36; t0++) vibuf[t0] = NULL;
X	for (t0 = 0; t0 != 26; t0++) vimarkline[t0] = 0;
X	stackhist = stackcs = -1;
X	vichgbufsz = 0;
X	vichgbuf = NULL;
X	usernamescached=0;
X}
X
Xchar *getkeystring(s,len) /**/
Xchar *s;int *len;
X{
Xstatic char buf[512];
Xchar *t = buf;
Xint x,metanext = 0;
X
X	for (;*s;s++)
X		{
X		if (*s == '\\' && s[1])
X			switch(*++s)
X				{
X				case 'a': *t++ = '\07'; break;
X				case 'n': *t++ = '\n'; break;
X				case 'b': *t++ = '\010'; break;
X				case 't': *t++ = '\t'; break;
X				case 'v': *t++ = '\v'; break;
X				case 'f': *t++ = '\f'; break;
X				case 'r': *t++ = '\r'; break;
X				case 'e': *t++ = '\033'; break;
X				case 'M':
X					if (s[1] == '-')
X						s++;
X					metanext = 2;
X					break;
X				default:
X					if (idigit(*s))
X						{
X						for (x = 0; idigit(*s); s++)
X							x = x*8+(*s-'0');
X						s--;
X						*t++ = x;
X						}
X					else
X						*t++ = *s;
X					break;
X				}
X		else if (*s == '^')
X			if (*++s == '?')
X				*t++ = 0x7f;
X			else
X				*t++ = *s & 0x9f;
X		else
X			*t++ = *s;
X		if (metanext && !(--metanext))
X			{
X			t[-1] |= 0x80;
X			metanext = 0;
X			}
X		if (t > buf+500)
X			break;
X		}
X	*t = '\0';
X	*len = t-buf;
X	return buf;
X}
X
Xvoid printbind(s,len) /**/
Xchar *s;int len;
X{
Xint ch;
X
X	while (len--)
X		{
X		ch = (unsigned char) *s++;
X		if (ch & 0x80)
X			{
X			printf("\\M-");
X			ch &= 0x7f;
X			}
X		if (icntrl(ch))
X			switch(ch)
X				{
X				case 0x7f: printf("^?"); break;
X				default: printf("^%c",(ch|0x40)); break;
X				}
X		else
X			putchar(ch);
X		}
X}
X
Xvoid printbinding(str,k) /**/
Xchar *str;Key k;
X{
X	if (k->func == z_sequenceleadin)
X		return;
X	putchar('\"');
X	printbind(str,strlen(str));
X	printf("\"\t");
X	if (k->func == z_sendstring)
X		{
X		putchar('\"');
X		printbind(k->str,k->len);
X		printf("\"\n");
X		}
X	else
X		printf("%s\n",zlecmds[k->func].name);
X}
X
Xint bin_bindkey(name,argv,ops,junc) /**/
Xchar *name;char **argv;char *ops;int junc;
X{
Xint t0 = 0,len;
Xchar *s;
Xint func,*tab;
X
X	tab = (ops['a']) ? altbindtab : mainbindtab;
X	if (ops['v'] || ops['e'] || ops['d'])
X		{
X		if (*argv)
X			{
X			zerrnam(name,"too many arguments",NULL,0);
X			return 1;
X			}
X		if (ops['d'] || ops['e'])
X			if (ops['m'])
X				for (t0 = 0; t0 != 256; t0++)
X					tab[t0] = emacsbind[t0];
X			else
X				{
X				for (t0 = 0; t0 != 128; t0++)
X					tab[t0] = emacsbind[t0];
X				for (t0 = 128; t0 != 256; t0++)
X					tab[t0] = z_selfinsert;
X				}
X		else
X			{
X			for (t0 = 0; t0 != 32; t0++)
X				mainbindtab[t0] = viinsbind[t0];
X			for (t0 = 32; t0 != 256; t0++)
X				mainbindtab[t0] = z_selfinsert;
X			mainbindtab[127] = z_backwarddeletechar;
X			}
X		for (t0 = 0; t0 != 128; t0++)
X			altbindtab[t0] = vicmdbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			altbindtab[t0] = emacsbind[t0];
X		for (t0 = 0200; t0 != 0240; t0++)
X			tab[t0] = z_undefinedkey;
X		return 0;
X		}
X	if (!*argv)
X		{
X		char buf[2];
X		
X		buf[0] = 'x'; buf[1] = '\0';
X		for (t0 = 0; t0 != 256; t0++)
X			{
X			buf[0] = t0;
X			putchar('\"');
X			printbind(buf,1);
X			if (t0 < 254 && tab[t0] == tab[t0+1] && tab[t0] == tab[t0+2])
X				{
X				printf("\" to \"");
X				while (tab[t0] == tab[t0+1]) t0++;
X				buf[0] = t0;
X				printbind(buf,1);
X				}
X			printf("\"\t%s\n",zlecmds[tab[t0]].name);
X			}
X		listhtable(xbindtab,(HFunc) printbinding);
X		return 0;
X		}
X	while (*argv)
X		{
X		s = getkeystring(*argv++,&len);
X		if (len > 8)
X			{
X			zerrnam(name,"in-string too long",NULL,0);
X			return 1;
X			}
X		if (!*argv || ops['r'])
X			{
X			Key ky;
X
X			ky = gethnode(s,xbindtab);
X			if (len == 1)
X				func = tab[(unsigned char) *s];
X			else
X				func = (ky) ? ky->func : z_undefinedkey;
X			if (func == z_undefinedkey)
X				{
X				zerrnam(name,"in-string is not bound",NULL,0);
X				return 1;
X				}
X			if (ops['r'])
X				{
X				if (len == 1)
X					tab[(unsigned char) *s] = z_undefinedkey;
X				else
X					{
X					while (strlen(s) > 1)
X						{
X						free(remhnode(s,xbindtab));
X						s[strlen(s)-1] = '\0';
X						}
X					}
X				continue;
X				}
X			if (func == z_sendstring)
X				{
X				printbind(ky->str,ky->len);
X				putchar('\n');
X				return 0;
X				}
X			printf("%s\n",zlecmds[func].name);
X			return 0;
X			}
X		if (!ops['s'])
X			{
X			for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X				if (!strcmp(*argv,zlecmds[t0].name))
X					break;
X			if (t0 == ZLECMDCOUNT)
X				{
X				zerr("undefined function: %s",*argv,0);
X				return 1;
X				}
X			func = t0;
X			}
X		else
X			func = z_sendstring;
X		if (len == 1)
X			{
X			Key ky;
X
X			tab[(unsigned char) *s] = (ops['s']) ? z_sendstring : t0;
X			if (ops['s'])
X				{
X				addhnode(ztrdup(s),ky = makefunckey(z_sendstring),xbindtab,freekey);
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X				}
X			}
X		else
X			{
X			int t1;
X			Key ky;
X
X			if (tab[(unsigned char) *s] != z_undefinedkey &&
X					tab[(unsigned char) *s] != z_sequenceleadin)
X				{
X				zerrnam(name,"in-string has already bound prefix",NULL,0);
X				return 1;
X				}
X			tab[(unsigned char) *s] = z_sequenceleadin;
X			if (!s[1])
X				s[1] = 0x80;
X			for (t1 = 1; t1 != len-1; t1++)
X				{
X				char sav;
X
X				sav = s[t1+1];
X				s[t1+1] = '\0';
X				ky = gethnode(s,xbindtab);
X				if (ky && ky->func != z_sequenceleadin)
X					{
X					zerrnam(name,"in-string has already bound prefix",NULL,0);
X					return 1;
X					}
X				if (!ky)
X					addhnode(ztrdup(s),makefunckey(z_sequenceleadin),xbindtab,
X						freekey);
X				if (!sav)
X					sav = 0x80;
X				s[t1+1] = sav;
X				}
X			addhnode(ztrdup(s),ky = makefunckey(func),xbindtab,freekey);
X			if (ops['s'])
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X			}
X		argv++;
X		}
X	return 0;
X}
X
Xvoid freekey(x) /**/
Xvptr x;
X{
XKey k = x;
X
X	if (k->str)
X		free(k->str);
X	free(k);
X}
X
X/* this is mostly stolen from bash's draino() */
X
Xvoid drainoutput() /**/
X{
Xint n = 0;
X
X	if (!baud) return;
X#ifdef TIOCOUTQ
X#ifdef HAS_SELECT
X	while ((ioctl(SHTTY,TIOCOUTQ,&n) >= 0) && n) {
X		struct timeval tv;
X		tv.tv_sec = n/baud;
X		tv.tv_usec = ((n%baud)*1000000)/baud;
X		select (0,(fd_set *)0,(fd_set *)0,(fd_set *)0,&tv);
X	}
X#endif
X#endif
X}
X
END_OF_FILE
  if test 15021 -ne `wc -c <'src/zle_main.c'`; then
    echo shar: \"'src/zle_main.c'\" unpacked with wrong size!
  fi
  # end of 'src/zle_main.c'
fi
if test -f 'src/zle_misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zle_misc.c'\"
else
  echo shar: Extracting \"'src/zle_misc.c'\" \(15185 characters\)
  sed "s/^X//" >'src/zle_misc.c' <<'END_OF_FILE'
X/*
X *
X * zle_misc.c - miscellaneous editor routines
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X
Xvoid selfinsert() /**/
X{
Xint ncs = cs+mult;
X
X	if (mult < 0) { mult = -mult; ncs = cs; }
X	if (insmode || ll == cs)
X		spaceinline(mult);
X	else if (mult+cs > ll)
X		spaceinline(ll-(mult+cs));
X	while (mult--)
X		line[cs++] = c;
X	cs = ncs;
X}
X
Xvoid selfinsertunmeta() /**/
X{
X	c &= 0x7f;
X	if (c == '\r') c = '\n';
X	selfinsert();
X}
X
Xvoid deletechar() /**/
X{
X	if (mult < 0) { mult = -mult; backwarddeletechar(); return; }
X	if (c == 4 && !ll)
X		{
X		eofsent = 1;
X		return;
X		}
X	if (!(cs+mult > ll || line[cs] == '\n'))
X		{
X		cs += mult;
X		backdel(mult);
X		}
X	else
X		feep();
X}
X
Xvoid backwarddeletechar() /**/
X{
X	if (mult < 0) { mult = -mult; deletechar(); return; }
X	if (mult > cs)
X		mult = cs;
X	backdel(mult);
X}
X
Xvoid vibackwarddeletechar() /**/
X{
X	if (mult < 0) { mult = -mult; videletechar(); return; }
X	if (mult > cs)
X		mult = cs;
X	if (cs-mult < viinsbegin) { feep(); return; }
X	backkill(mult,1);
X}
X
Xvoid vikillline() /**/
X{
X	if (viinsbegin > cs) { feep(); return; }
X	backdel(cs-viinsbegin);
X}
X
Xvoid killwholeline() /**/
X{
Xint i,fg;
X
X	if (mult < 0) return;
X	while (mult--)
X		{
X		if (fg = (cs && cs == ll))
X			cs--;
X		while (cs && line[cs-1] != '\n') cs--;
X		for (i = cs; i != ll && line[i] != '\n'; i++);
X		forekill(i-cs+(i != ll),fg);
X		}
X}
X
Xvoid killbuffer() /**/
X{
X	cs = 0;
X	forekill(ll,0);
X}
X
Xvoid backwardkillline() /**/
X{
Xint i = 0;
X
X	if (mult < 0) { mult = -mult; killline(); return; }
X	while (mult--)
X		{
X		while (cs && line[cs-1] != '\n') cs--,i++;
X		if (mult && cs && line[cs-1] == '\n')
X			cs--,i++;
X		}
X	forekill(i,1);
X}
X
Xvoid gosmacstransposechars() /**/
X{
Xint cc;
X
X	if (cs < 2 || line[cs-1] == '\n' || line[cs-2] == '\n')
X		{
X		if (line[cs] == '\n' || line[cs+1] == '\n')
X			{
X			feep();
X			return;
X			}
X		cs += (cs == 0 || line[cs-1] == '\n') ? 2 : 1;
X		}
X	cc = line[cs-2];
X	line[cs-2] = line[cs-1];
X	line[cs-1] = cc;
X}
X
Xvoid transposechars() /**/
X{
Xint cc, ct;
Xint neg = mult < 0;
X
X	if (neg) mult = -mult;
X	while (mult--) {
X		if (!(ct = cs) || line[cs-1] == '\n') {
X			if (ll == cs || line[cs] == '\n') {
X				feep();
X				return;
X			}
X			if (!neg) cs++;
X		   ct++;
X		}
X		if (neg) {
X			if (cs && line[cs-1] != '\n') {
X			  cs--;
X			  if (ct > 1 && line[ct-2] != '\n') ct--;
X			}
X		} else {
X			if (cs != ll && line[cs] != '\n') cs++;
X		}
X		if (ct == ll || line[ct] == '\n') ct--;
X		if (ct < 1 || line[ct-1] == '\n') {
X		   feep();
X			return;
X		}
X		cc = line[ct-1];
X		line[ct-1] = line[ct];
X		line[ct] = cc;
X	}
X}
X
Xvoid poundinsert() /**/
X{
X	if (*line != '#') {
X		cs = 0;
X		spaceinline(1);
X		*line = '#';
X	} else {
X		cs = 0;
X		foredel(1);
X	}
X	done = 1;
X}
X
Xvoid acceptline() /**/
X{
X	done = 1;
X}
X
Xvoid acceptandhold() /**/
X{
X	pushnode(bufstack,ztrdup((char *) line));
X	stackcs = cs;
X	done = 1;
X}
X
Xvoid killline() /**/
X{
Xint i = 0;
X
X	if (mult < 0) { mult = -mult; backwardkillline(); return; }
X	while (mult--) {
X		if (line[cs] == '\n')
X			cs++,i++;
X		while (cs != ll && line[cs] != '\n') cs++,i++;
X	}
X	backkill(i,0);
X}
X
Xvoid killregion() /**/
X{
X	if (mark > ll)
X		mark = ll;
X	if (mark > cs)
X		forekill(mark-cs,0);
X	else
X		backkill(cs-mark,1);
X}
X
Xvoid copyregionaskill() /**/
X{
X	if (mark > ll)
X		mark = ll;
X	if (mark > cs)
X		cut(cs,mark-cs,0);
X	else
X		cut(mark,cs-mark,1);
X}
X
Xstatic int kct,yankb,yanke;
X
Xvoid yank() /**/
X{
Xint cc;
Xchar *buf = cutbuf;
X
X	if (!cutbuf) {
X		feep();
X		return;
X	}
X	if (mult < 0) return;
X	if (vibufspec) {
X		vibufspec = tolower(vibufspec);
X		vibufspec += (idigit(vibufspec)) ? -'1'+26 : -'a';
X		if (!(buf = vibuf[vibufspec])) {
X			feep();
X			vibufspec = 0;
X			return;
X		}
X		vibufspec = 0;
X	}
X	yankb = cs;
X	while (mult--) {
X		kct = kringnum;
X		cc = strlen(buf);
X		spaceinline(cc);
X		strncpy((char *) line+cs,buf,cc);
X		cs += cc;
X		yanke = cs;
X	}
X}
X
Xvoid viputafter() /**/
X{
Xint cc;
Xchar *buf = cutbuf;
X
X	if (!cutbuf) {
X		feep();
X		return;
X	}
X	if (mult < 0) return;
X	if (vibufspec) {
X		vibufspec = tolower(vibufspec);
X		vibufspec += (idigit(vibufspec)) ? -'1'+26 : -'a';
X		if (!(buf = vibuf[vibufspec])) {
X			feep();
X			vibufspec = 0;
X			return;
X		}
X		vibufspec = 0;
X	}
X	if (strchr(buf,'\n')) {
X		cs = findeol();
X		if (cs == ll) { spaceinline(1); line[cs] = '\n'; }
X	}
X	if (cs != ll) cs++;
X	yankb = cs;
X	while (mult--) {
X		kct = kringnum;
X		cc = strlen(buf);
X		spaceinline(cc);
X		strncpy((char *) line+cs,buf,cc);
X		cs += cc;
X		yanke = cs;
X	}
X	cs = yankb;
X}
X
Xvoid yankpop() /**/
X{
Xint cc;
X
X	if (!(lastcmd & ZLE_YANK) || !kring[kct]) {
X		feep();
X		return;
X	}
X	cs = yankb;
X	foredel(yanke-yankb);
X	cc = strlen(kring[kct]);
X	spaceinline(cc);
X	strncpy((char *) line+cs,kring[kct],cc);
X	cs += cc;
X	yanke = cs;
X	kct = (kct-1) & (KRINGCT-1);
X}
X
Xvoid overwritemode() /**/
X{
X	insmode ^= 1;
X}
X
Xvoid undefinedkey() /**/
X{
X	feep();
X}
X
Xvoid quotedinsert() /**/
X{
X#ifndef TIO
Xstruct sgttyb sob;
X	sob = shttyinfo.sgttyb;
X	sob.sg_flags = (sob.sg_flags|RAW) & ~ECHO;
X	ioctl(SHTTY,TIOCSETN,&sob);
X#endif
X	c = getkey(0);
X#ifndef TIO
X	setterm();
X#endif
X	if (c) selfinsert(); else feep();
X}
X
Xvoid digitargument() /**/
X{
X	int sign = (mult < 0 || (lastcmd & ZLE_NEGARG)) ? -1 : 1;
X	if ((lastcmd & (ZLE_ARG|ZLE_NEGARG)) != ZLE_ARG)
X		mult = 0;
X	mult = mult*10 + sign*(c&0xf);
X}
X
Xvoid negargument() /**/
X{
X	if (lastcmd & ZLE_ARG) feep();
X	mult = -1;
X}
X
Xvoid universalargument() /**/
X{
X	if (!(lastcmd & ZLE_ARG))
X		mult = 4;
X	else
X		mult *= 4;
X}
X
Xvoid copyprevword() /**/
X{
Xint len,t0;
X
X	for (t0 = cs-1; t0 >= 0; t0--)
X		if (iword(line[t0]))
X			break;
X	for (; t0 >= 0; t0--)
X		if (!iword(line[t0]))
X			break;
X	if (t0)
X		t0++;
X	len = cs-t0;
X	spaceinline(len);
X	strncpy((char *) line+cs,(char *) line+t0,len);
X	cs += len;
X}
X
Xvoid sendbreak() /**/
X{
X	errflag = done = 1;
X}
X
Xvoid undo() /**/
X{
Xchar *s;
Xstruct undoent *ue;
X
X	ue = undos+undoct;
X	if (!ue->change)
X		{
X		feep();
X		return;
X		}
X	line[ll] = '\0';
X	s = ztrdup((char *) line+ll-ue->suff);
X	sizeline((ll = ue->pref+ue->suff+ue->len)+1);
X	strncpy((char *) line+ue->pref,ue->change,ue->len);
X	strcpy((char *) line+ue->pref+ue->len,s);
X	free(s);
X	ue->change = NULL;
X	undoct = (undoct-1) & (UNDOCT-1);
X	cs = ue->cs;
X}
X
Xvoid quoteregion() /**/
X{
Xchar *s,*t;
Xint x,y;
X
X	if (mark > ll)
X		mark = ll;
X	if (mark < cs)
X		{
X		x = mark;
X		mark = cs;
X		cs = x;
X		}
X	s = hcalloc((y = mark-cs)+1);
X	strncpy(s,(char *) line+cs,y);
X	s[y] = '\0';
X	foredel(mark-cs);
X	t = makequote(s);
X	spaceinline(x = strlen(t));
X	strncpy((char *) line+cs,t,x);
X	mark = cs;
X	cs += x;
X}
X
Xvoid quoteline() /**/
X{
Xchar *s;
X
X	line[ll] = '\0';
X	s = makequote((char *) line);
X	setline(s);
X}
X
Xchar *makequote(s) /**/
Xchar *s;
X{
Xint qtct = 0;
Xchar *l,*ol;
X
X	for (l = s; *l; l++)
X		if (*l == '\'')
X			qtct++;
X	l = ol = halloc((qtct*3)+3+strlen(s));
X	*l++ = '\'';
X	for (; *s; s++)
X		if (*s == '\'')
X			{
X			*l++ = '\'';
X			*l++ = '\\';
X			*l++ = '\'';
X			*l++ = '\'';
X			}
X		else
X			*l++ = *s;
X	*l++ = '\'';
X	*l = '\0';
X	return ol;
X}
X
X#define NAMLEN 70
X
Xint executenamedcommand() /**/
X{
Xchar buf[NAMLEN],*ptr;
Xint len,ch,t0;
X
X	strcpy(buf,"execute: ");
X	ptr = buf+9;
X	len = 0;
X	statusline = buf;
X	refresh();
X	for (;ch = getkey(1);refresh())
X		{
X		switch (ch)
X			{
X			case 8: case 127:
X				if (len)
X					{
X					len--;
X					*--ptr = '\0';
X					}
X				break;
X			case 23:
X				while (len && (len--, *--ptr != '-'))
X					*ptr = '\0';
X				break;
X			case 21:
X				len = 0;
X				ptr = buf+9;
X				*ptr = '\0';
X				break;
X			case 10: case 13: goto brk;
X			case 7: case -1: statusline = NULL; return z_undefinedkey;
X			case 9: case 32:
X				{
X				Lklist ll;
X				int ambig = 100;
X
X				heapalloc();
X				ll = newlist();
X				for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X					if (strpfx(buf+9,zlecmds[t0].name))
X						{
X						int xx;
X
X						addnode(ll,zlecmds[t0].name);
X						xx = pfxlen(peekfirst(ll),zlecmds[t0].name);
X						if (xx < ambig)
X							ambig = xx;
X						}
X				permalloc();
X				if (empty(ll))
X					feep();
X				else if (!nextnode(firstnode(ll)))
X					{
X					strcpy(buf+9,peekfirst(ll));
X					ptr = buf+(len = strlen(buf));
X					}
X				else
X					{
X					strcpy(buf+9,peekfirst(ll));
X					len = ambig;
X					ptr = buf+9+len;
X					*ptr = '\0';
X					feep();
X					listmatches(ll,NULL);
X					}
X				break;
X				}
X			default:
X				if (len == NAMLEN-10 || icntrl(ch))
X					feep();
X				else
X					*ptr++ = ch, *ptr = '\0', len++;
X				break;
X			}
X		}
Xbrk:
X	statusline = NULL;
X	ptr = buf+9;
X	for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X		if (!strcmp(ptr,zlecmds[t0].name))
X			break;
X	if (t0 != ZLECMDCOUNT)
X		return lastnamed = t0;
X	else
X		return z_undefinedkey;
X}
X
Xvoid vijoin() /**/
X{
Xint x;
X
X	if ((x = findeol()) == ll)
X		{
X		feep();
X		return;
X		}
X	cs = x+1;
X	for (x = 1; cs != ll && iblank(line[cs]); cs++,x++);
X	backdel(x);
X	spaceinline(1);
X	line[cs] = ' ';
X}
X
Xvoid viswapcase() /**/
X{
X	if (cs < ll)
X		{
X		int ch = line[cs];
X
X		if (islower(ch))
X			ch = tuupper(ch);
X		else if (isupper(ch))
X			ch = tulower(ch);
X		line[cs++] = ch;
X		}
X}
X
Xvoid vicapslockpanic() /**/
X{
Xchar ch;
X
X	statusline = "press a lowercase key to continue";
X	refresh();
X	do
X		ch = getkey(0);
X	while (!islower(ch));
X}
X
Xvoid visetbuffer() /**/
X{
Xint ch;
X
X	ch = getkey(1);
X	if (!ialnum(ch)) {
X		feep();
X		return;
X	}
X	vibufspec = ch;
X}
X
Xstatic char *bp;
Xstatic int lensb,countp;
X
Xvoid stradd(d) /**/
Xchar *d;
X{
X	while (*bp++ = *d++);
X	bp--;
X}
X
Xint putstr(d) /**/
Xint d;
X{
X	*bp++ = d;
X	if (countp)
X		lensb++;
X	return 0;
X}
X
X#define tstradd(X) \
X	if (termok && unset(SINGLELINEZLE)) { \
X		char tbuf[2048],*tptr = tbuf; \
X		if (tgetstr(X,&tptr)) \
X			tputs(tbuf,1,putstr); \
X	} \
X	break
X
X/* get a prompt string */
X
Xchar *putprompt(fm,lenp,isspell) /**/
Xchar *fm;int *lenp;int isspell;
X{
Xchar *ss,*bl0;
Xstatic char buf0[256],buf1[256],buf2[256],*buf;
Xchar buf3[MAXPATHLEN];
Xint t0,bracepos = 0,arg;
Xstruct tm *tm;
Xtime_t timet;
X
X	lensb = 0; countp = 1;
X	if (!fm) { *lenp = 0; return ""; }
X	/* KLUDGE ALERT!  What we have here are three buffers:
X	 *  buf1 and buf2 alternate between PS1 and PS2, though which is
X	 *   which is indeterminate depending on spellchecking, "select",
X	 *   etc. -- those operations also share these two buffers.
X	 *  buf0 is used for any prompting that manages to happen while
X	 *   zleread() is in progress (signal traps, etc.), because
X	 *   zleread() re-uses the pointers returned to buf1 and buf2
X	 *   and will be confused if either of those is overwritten.
X	 */
X	buf = zleactive ? buf0 : ((buf == buf1) ? buf2 : buf1);
X	bp = bl0 = buf;
X	if (!columns) columns = 80;
X	clearerr(stdin);
X	for(;*fm;fm++) {
X		if (bp-buf >= 220)
X			break;
X		arg = 0;
X		if (*fm == '%')
X			{
X			if (idigit(*++fm))
X				{
X				arg = zstrtol(fm, &fm, 10);
X				}
X			switch (*fm)
X				{
X				case '~':
X					t0 = finddir(pwd);
X					if (t0 != -1) {
X						*bp++ = '~';
X						stradd(usernames[t0]);
X						stradd(pwd+strlen(userdirs[t0]));
X						break;
X					}
X				case 'd': case '/': stradd(pwd); break;
X				case 'c': case '.':
X					t0 = finddir(pwd);
X					if (t0 != -1) {
X						sprintf(buf3,"~%s%s",usernames[t0],
X							pwd+strlen(userdirs[t0]));
X					} else {
X						strcpy(buf3,pwd);
X					}
X					if (!arg) arg++;
X					for (ss = buf3+strlen(buf3); ss > buf3; ss--)
X						if (*ss == '/' && !--arg) {
X							ss++;
X							break;
X						}
X					if (*ss == '/' && ss[1] && (ss != buf3)) ss++;
X					stradd(ss);
X					break;
X				case 'C':
X					strcpy(buf3,pwd);
X					if (!arg) arg++;
X					for (ss = buf3+strlen(buf3); ss > buf3; ss--)
X						if (*ss == '/' && !--arg) {
X							ss++;
X							break;
X						}
X					if (*ss == '/' && ss[1] && (ss != buf3)) ss++;
X					stradd(ss);
X					break;
X				case 'h': case '!':
X					sprintf(bp,"%d",curhist);
X					bp += strlen(bp);
X					break;
X				case 'M': stradd(hostnam); break;
X				case 'm':
X					if (!arg) arg++;
X					for (ss = hostnam; *ss; ss++)
X						if (*ss == '.' && !--arg)
X							break;
X					t0 = *ss;
X					*ss = '\0';
X					stradd(hostnam);
X					*ss = t0;
X					break;
X				case 'S': tstradd("so"); /* <- this is a macro */
X				case 's': tstradd("se");
X				case 'B': tstradd("md");
X				case 'b': tstradd("me");
X				case 'U': tstradd("us");
X				case 'u': tstradd("ue");
X				case '{': bracepos = bp-buf; countp = 0; break;
X				case '}': lensb += (bp-buf)-bracepos; countp = 1; break;
X				case 't': case '@':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%l:%M%p",tm);
X					if (*bp == ' ')
X						chuck(bp);
X					bp += strlen(bp);
X					break;
X				case 'T':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%k:%M",tm);
X					bp += strlen(bp);
X					break;
X				case '*':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%k:%M:%S",tm);
X					bp += strlen(bp);
X					break;
X				case 'n': stradd(username); break;
X				case 'w':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%a %e",tm);
X					bp += strlen(bp);
X					break;
X				case 'W':
X					timet = time(NULL);
X					tm = localtime(&timet);
X					ztrftime(bp,16,"%m/%d/%y",tm);
X					bp += strlen(bp);
X					break;
X				case 'D':
X 					strcpy(buf3, "%y-%m-%d");
X 					if (fm[1] == '{') {
X 						for (ss = fm + 1, t0 = 0; *ss; ++ss)
X 							if (*ss == '{')
X 								++t0;
X 							else if (*ss == '}')
X 								if (--t0 == 0)
X 									break;
X 						if (*ss == '}' && t0 == 0) {
X 							t0 = (ss - 1) - (fm + 1);
X 							strncpy(buf3, fm + 2, t0);
X 							buf3[t0] = 0;
X 							fm = ss;
X 						}
X 					}
X  					timet = time(NULL);
X  					tm = localtime(&timet);
X 					ztrftime(bp,16,buf3,tm);
X  					bp += strlen(bp);
X  					break;
X				case 'l':
X					if (*ttystrname) stradd((strncmp(ttystrname,"/dev/tty",8) ? 
X						ttystrname+5 : ttystrname+8));
X					else stradd("()");
X					break;
X				case '?':
X					sprintf(bp,"%d",lastval);
X					bp += strlen(bp);
X					break;
X				case '%': *bp++ = '%'; break;
X				case '#': *bp++ = (geteuid()) ? '%' : '#'; break;
X				case 'v':
X					if (!arg) arg++;
X					/* The number 35 here comes from 256-220-1, where 256 is
X					 * sizeof(buf), 220 is from the overflow test made at the
X					 * top of the loop, and 1 is for the \0 byte at the end.
X					 */
X					if (arrlen(psvar) >= arg && strlen(psvar[arg-1]) < 35)
X						stradd(psvar[arg-1]);
X					else
X						stradd("");
X					break;
X				case 'r':
X					if (isspell)
X						{
X						stradd(rstring);
X						break;
X						}
X				case 'R':
X					if (isspell)
X						{
X						stradd(Rstring);
X						break;
X						}
X				default:
X					*bp++ = '%'; *bp++ = *fm;
X					break;
X				}
X			}
X		else if (*fm == '!') {
X			sprintf(bp,"%d",curhist);
X			bp += strlen(bp);
X		} else {
X			if (fm[0] == '\\' && fm[1])
X				fm++;
X			if ((*bp++ = *fm) == '\n')
X				bl0 = bp, lensb = 0;
X		}
X	}
X	*lenp = (bp-bl0)-lensb;
X	*lenp %= columns;
X	if (*lenp == columns-1) {
X		*lenp = 0;
X		*bp++ = ' ';
X	}
X	*bp = '\0';
X	return buf;
X}
X
END_OF_FILE
  if test 15185 -ne `wc -c <'src/zle_misc.c'`; then
    echo shar: \"'src/zle_misc.c'\" unpacked with wrong size!
  fi
  # end of 'src/zle_misc.c'
fi
echo shar: End of archive 18 \(of 22\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
