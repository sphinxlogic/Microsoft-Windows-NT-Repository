Newsgroups: comp.sources.misc
From: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Subject: v35i070:  zsh - The Z Shell, version 2.3.1, Part20/22
Message-ID: <1993Feb20.212909.29520@sparky.imd.sterling.com>
X-Md4-Signature: 5b503ac202a2325d8386bfc51e978f37
Date: Sat, 20 Feb 1993 21:29:09 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Posting-number: Volume 35, Issue 70
Archive-name: zsh/part20
Environment: UNIX
Supersedes: zsh2.2: Volume 29, Issue 97-113

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  doc/intro.txt.02 help/limit help/source src/funcs.h
#   src/text.c src/watch.c src/zle.h src/zle_vi.c src/zle_word.c
# Wrapped by mattson@odin on Sat Feb  6 14:41:55 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 20 (of 22)."'
if test -f 'doc/intro.txt.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/intro.txt.02'\"
else
  echo shar: Extracting \"'doc/intro.txt.02'\" \(8938 characters\)
  sed "s/^X//" >'doc/intro.txt.02' <<'END_OF_FILE'
XThus, you can view a file simply by typing:
X
X% <file
Xfoo!
X
X
XHowever, this is not csh or sh compatible.  To correct this,
Xchange  the  value of the parameter NULLCMD, which is cat by
Xdefault.
X
X% NULLCMD=:
X% >file
X% ls -l file
X-rw-r--r--  1 pfalstad        0 May 24 05:41 file
X
X
XIf NULLCMD is unset, the shell reports an error if  no  com-
Xmand is specified (like csh).
X
X
X
X
X
X
X
X                           - 36 -
X
X% unset NULLCMD
X% >file
Xzsh: redirection with no command
X
X
XActually, READNULLCMD is used whenever you have a null  com-
Xmand  reading  input  from a single file.  Thus, you can set
XREADNULLCMD to more or less rather than cat.  Also,  if  you
Xset  NULLCMD  to  : for sh compatibility, you can still read
Xfiles with < file if you leave READNULLCMD set to more.
X
XPrompting
X
XThe default prompt for zsh is:
X
Xphoenix% echo $PROMPT
X%m%#
X
X
XThe %m stands for the short form of  the  current  hostname,
Xand  the  %# stands for a % or a #, depending on whether the
Xshell is running as root or not.  zsh  supports  many  other
Xcontrol sequences in the PROMPT variable.
X
X% PROMPT='%/> '
X/u/pfalstad/etc/TeX/zsh>
X
X% PROMPT='%~> '
X~/etc/TeX/zsh>
X
X% PROMPT='%h %~> '
X6 ~/etc/TeX/zsh>
X
X
X%h represents the number of current history event.
X
X% PROMPT='%h %~ %M> '
X10 ~/etc/TeX/zsh apple-gunkies.gnu.ai.mit.edu>
X
X% PROMPT='%h %~ %m> '
X11 ~/etc/TeX/zsh apple-gunkies>
X
X% PROMPT='%h %t> '
X12 6:11am>
X
X% PROMPT='%n %w tty%l>'
Xpfalstad Fri 24 ttyp0>
X
X
XAlso available is the RPROMPT parameter.  If  this  is  set,
Xthe shell puts a prompt on the right side of the screen.
X
X
X
X
X
X
X
X
X
X
X
X
X
X                           - 37 -
X
X% RPROMPT='%t'
X%                                                      6:14am
X
X% RPROMPT='%~'
X%                                               ~/etc/TeX/zsh
X
X% PROMPT='%l %T %m[%h] ' RPROMPT=' %~'
Xp0 6:15 phoenix[5]                              ~/etc/TeX/zsh
X
X
XThese special escape sequences can also be used with the  -P
Xoption to print:
X
X% print -P %h tty%l
X15 ttyp1
X
X
X
XThe POSTEDIT parameter is printed whenever the editor exits.
XThis  can  be  useful  for termcap tricks.  To highlight the
Xprompt  and  command  line  while  leaving  command   output
Xunhighlighted, try this:
X
X% POSTEDIT=`echotc se`
X% PROMPT='%S%% '
X
X
X
XLogin/logout watching
X
XYou can specify login or logout events to monitor by setting
Xthe  watch variable.  Normally, this is done by specifying a
Xlist of usernames.
X
X% watch=( pfalstad subbarao sukthnkr egsirer )
X
X
XThe log command reports all people logged in  that  you  are
Xwatching for.
X
X% log
Xpfalstad has logged on p0 from mickey.
Xpfalstad has logged on p5 from mickey.
X% ...
Xsubbarao has logged on p8 from phoenix.
X% ...
Xsubbarao has logged off p8 from phoenix.
X% ...
Xsukthnkr has logged on p8 from dew.
X% ...
Xsukthnkr has logged off p8 from dew.
X
X
XIf you specify hostnames with an @ prepended, the shell will
Xwatch for all users logging in from the specified host.
X
X
X
X
X
X
X
X
X
X                           - 38 -
X
X% watch=( @mickey @phoenix )
X% log
Xdjthongs has logged on q2 from phoenix.
Xpfalstad has logged on p0 from mickey.
Xpfalstad has logged on p5 from mickey.
X
X
XIf you give a tty name with a % prepended,  the  shell  will
Xwatch for all users logging in on that tty.
X
X% watch=( %ttyp0 %console )
X% log
Xroot has logged on console from .
Xpfalstad has logged on p0 from mickey.
X
X
XThe format of the reports may also be changed.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X                           - 39 -
X
X% watch=( pfalstad gettes eps djthongs jcorr bdavis )
X% log
Xjcorr has logged on tf from 128.112.176.3:0.
Xjcorr has logged on r0 from 128.112.176.3:0.
Xgettes has logged on p4 from yo:0.0.
Xdjthongs has logged on pe from grumpy:0.0.
Xdjthongs has logged on q2 from phoenix.
Xbdavis has logged on qd from BRUNO.
Xeps has logged on p3 from csx30:0.0.
Xpfalstad has logged on p0 from mickey.
Xpfalstad has logged on p5 from mickey.
X% WATCHFMT='%n on tty%l from %M'
X% log
Xjcorr on ttytf from 128.112.176.3:0.
Xjcorr on ttyr0 from 128.112.176.3:0.
Xgettes on ttyp4 from yo:0.0
Xdjthongs on ttype from grumpy:0.0
Xdjthongs on ttyq2 from phoenix.Princeto
Xbdavis on ttyqd from BRUNO.pppl.gov
Xeps on ttyp3 from csx30:0.0
Xpfalstad on ttyp0 from mickey.Princeton
Xpfalstad on ttyp5 from mickey.Princeton
X% WATCHFMT='%n fm %m'
X% log
Xjcorr fm 128.112.176.3:0
Xjcorr fm 128.112.176.3:0
Xgettes fm yo:0.0
Xdjthongs fm grumpy:0.0
Xdjthongs fm phoenix
Xbdavis fm BRUNO
Xeps fm csx30:0.0
Xpfalstad fm mickey
Xpfalstad fm mickey
X% WATCHFMT='%n %a at %t %w.'
X% log
Xjcorr logged on at 3:15pm Mon 20.
Xjcorr logged on at 3:16pm Wed 22.
Xgettes logged on at 6:54pm Wed 22.
Xdjthongs logged on at 7:19am Thu 23.
Xdjthongs logged on at 7:20am Thu 23.
Xbdavis logged on at 12:40pm Thu 23.
Xeps logged on at 4:19pm Thu 23.
Xpfalstad logged on at 3:39am Fri 24.
Xpfalstad logged on at 3:42am Fri 24.
X
X
XIf you have a .friends file in your home directory,  a  con-
Xvenient  way to make zsh watch for all your friends is to do
Xthis:
X
X% watch=( $(< ~/.friends) )
X% echo $watch
Xsubbarao maruchck root sukthnkr ...
X
X
XIf watch is set to all, then all users  logging  in  or  out
Xwill be reported.
X
X
X
X
X
X
X
X                           - 40 -
XOptions
X
XSome options have already been mentioned;  here  are  a  few
Xmore:
X
X% cd /
X% setopt autocd
X% bin
X% pwd
X/bin
X% ../etc
X% pwd
X/etc
X
X
XUsing the AUTOCD option, you can simply type the name  of  a
Xdirectory, and it will become the current directory.
X
X% setopt cdablevars
X% foo=/tmp
X% cd foo
X/tmp
X
X
XWith CDABLEVARS, if the argument to cd  is  the  name  of  a
Xparameter  whose  value is a valid directory, it will become
Xthe current directory.
X
XCORRECT turns on spelling correction for commands,  and  the
XCORRECTALL option turns on spelling correction for all argu-
Xments.
X
X% setopt correct
X% sl
Xzsh: correct `sl' to `ls' [nyae]? y
X% setopt correctall
X% ls x.v11r4
Xzsh: correct `x.v11r4' to `X.V11R4' [nyae]? n
X/usr/princton/src/x.v11r4 not found
X% ls /etc/paswd
Xzsh: correct to `/etc/paswd' to `/etc/passwd' [nyae]? y
X/etc/passwd
X
X
XIf you press y when the  shell  asks  you  if  you  want  to
Xcorrect  a  word,  it will be corrected.  If you press n, it
Xwill be left alone.  Pressing  a  aborts  the  command,  and
Xpressing e brings the line up for editing again, in case you
Xagree the word is spelled  wrong  but  you  don't  like  the
Xcorrection.
X
XNormally, a quoted expression may contain a newline:
X
X% echo '
X> foo
X> '
X
Xfoo
X
X%
X
X
X
X
X
X                           - 41 -
XWith CSHJUNKIEQUOTES set, this is illegal, as it is in csh.
X
X% setopt cshjunkiequotes
X% ls 'foo
Xzsh: unmatched '
X
X
XGLOBDOTS lets files beginning with a .  be  matched  without
Xexplicitly specifying the dot.
X
X% ls -d *x*
XMailboxes
X% setopt globdots
X% ls -d *x*
X.exrc         .pnewsexpert  .xserverrc
X.mushexpert   .xinitrc      Mailboxes
X
X
XHISTIGNOREDUPS prevents the current line from being saved in
Xthe  history  if it is the same as the previous one; HISTIG-
XNORESPACE prevents the current line from being saved  if  it
Xbegins with a space.
X
X% PROMPT='%h> '
X39> setopt histignoredups
X40> echo foo
Xfoo
X41> echo foo
Xfoo
X41> echo foo
Xfoo
X41> echo bar
Xbar
X42> setopt histignorespace
X43>  echo foo
Xfoo
X43>  echo fubar
Xfubar
X43>  echo fubar
Xfubar
X
X
XIGNOREBRACES turns off csh-style brace expansion.
X
X% echo x{y{z,a},{b,c}d}e
Xxyze xyae xbde xcde
X% setopt ignorebraces
X% echo x{y{z,a},{b,c}d}e
Xx{y{z,a},{b,c}d}e
X
X
XIGNOREEOF forces the user to type exit or logout, instead of
Xjust pressing ^D.
X
X% setopt ignoreeof
X% ^D
Xzsh: use 'exit' to exit.
X
X
XINTERACTIVECOMMENTS turns on interactive comments;  comments
X
X
X
X
X
X                           - 42 -
Xbegin with a #.
X
X% setopt interactivecomments
X% date # this is a comment
XFri May 24 06:54:14 EDT 1991
X
X
XNOCLOBBER prevents  you  from  accidentally  overwriting  an
Xexisting file.
X
X% setopt noclobber
X% cat /dev/null >~/.zshrc
Xzsh: file exists: /u/pfalstad/.zshrc
X
X
XIf you really do want to clobber a file, you can use the  >!
Xoperator.   To  make  things  easier  in this case, the > is
Xstored in the history list as a >!:
X
X% cat /dev/null >! ~/.zshrc
X% cat /etc/motd > ~/.zshrc
Xzsh: file exists: /u/pfalstad/.zshrc
X% !!
Xcat /etc/motd >! ~/.zshrc
X% ...
X
X
XRCQUOTES lets you use a more elegant  method  for  including
Xsingle quotes in a singly quoted string:
X
X% echo '"don'\''t do that."'
X"don't do that."
X% echo '"don''t do that."'
X"dont do that."
X% setopt rcquotes
X% echo '"don''t do that."'
X"don't do that."
X
X
XFinally, SUNKEYBOARDHACK wins the award  for  the  strangest
Xoption.   If a line ends with `, and there are an odd number
Xof them on the line, the shell will ignore the  trailing  `.
XThis  is  provided  for  keyboards  whose  RETURN key is too
Xsmall, and too close to the ` key.
X
X% setopt sunkeyboardhack
X% date`
XFri May 24 06:55:38 EDT 1991
X
X
X
XClosing Comments
X
XI would be happy to receive mail if anyone has any tricks or
Xideas  to  add to this document, or if there are some points
Xthat could be  made  clearer  or  covered  more  thoroughly.
XPlease notify me of any errors in this document.
X
X
X
X
X
X
END_OF_FILE
  if test 8938 -ne `wc -c <'doc/intro.txt.02'`; then
    echo shar: \"'doc/intro.txt.02'\" unpacked with wrong size!
  fi
  # end of 'doc/intro.txt.02'
fi
if test -f 'help/limit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/limit'\"
else
  echo shar: Extracting \"'help/limit'\" \(1253 characters\)
  sed "s/^X//" >'help/limit' <<'END_OF_FILE'
X     limit [ -h ] [ resource [ limit ] ] ...
X     limit -s
X          Limit the  resource  consumption  of  children  of  the
X          current  shell.   If  limit is not specified, print the
X          current limit placed on  resource;  otherwise  set  the
X          limit to the specified value.  If the -h flag is given,
X          use hard limits instead of soft limits.  If no resource
X          is given, print all limits.
X
X          resource is one of:
X
X          cputime
X               Maximum CPU seconds per process.
X          filesize
X               Largest single file allowed.
X          datasize
X               Maximum data size (including stack) for each  pro-
X               cess.
X          stacksize
X               Maximum stack size for each process.
X          coredumpsize
X               Maximum size of a core dump.
X          resident
X               Maximum resident set size.
X          descriptors
X               Maximum value for a file descriptor.
X
X          limit is a number, with an optional scaling factor,  as
X          follows:
X
X          nh   hours.
X          nk   kilobytes. This is the default for  all  but  cpu-
X               time.
X          nm   megabytes or minutes.
X          mm:ss
X               minutes and seconds.
END_OF_FILE
  if test 1253 -ne `wc -c <'help/limit'`; then
    echo shar: \"'help/limit'\" unpacked with wrong size!
  fi
  # end of 'help/limit'
fi
if test -f 'help/source' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/source'\"
else
  echo shar: Extracting \"'help/source'\" \(552 characters\)
  sed "s/^X//" >'help/source' <<'END_OF_FILE'
X     source file [ arg ... ]
X     . file [ arg ... ]
X          Read and execute commands  from  file  in  the  current
X          shell  environment.   If file does not contain a slash,
X          the shell looks in the components of path to  find  the
X          directory  containing  file.   If any arguments arg are
X          given, they become the positional parameters;  the  old
X          positional  parameters  are  restored  when the file is
X          done executing.  The exit status is the exit status  of
X          the last command executed.
END_OF_FILE
  if test 552 -ne `wc -c <'help/source'`; then
    echo shar: \"'help/source'\" unpacked with wrong size!
  fi
  # end of 'help/source'
fi
if test -f 'src/funcs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/funcs.h'\"
else
  echo shar: Extracting \"'src/funcs.h'\" \(1219 characters\)
  sed "s/^X//" >'src/funcs.h' <<'END_OF_FILE'
Xstruct asgment;
Xstruct utmp;
Xstruct hp;
Xtypedef struct hp *Hp;
X
X#include "builtin.pro"
X#include "cond.pro"
X#include "exec.pro"
X#include "glob.pro"
X#include "hist.pro"
X#include "init.pro"
X#include "jobs.pro"
X#include "lex.pro"
X#include "loop.pro"
X#include "math.pro"
X#include "mem.pro"
X#include "params.pro"
X#include "parse.pro"
X#include "subst.pro"
X#include "table.pro"
X#include "text.pro"
X#include "utils.pro"
X#include "watch.pro"
X#include "zle_hist.pro"
X#include "zle_main.pro"
X#include "zle_misc.pro"
X#include "zle_move.pro"
X#include "zle_refresh.pro"
X#include "zle_tricky.pro"
X#include "zle_utils.pro"
X#include "zle_vi.pro"
X#include "zle_word.pro"
X
Xchar *mktemp DCLPROTO((char *));
X#ifndef HAS_STDLIB
Xchar *malloc DCLPROTO((int));
Xchar *realloc DCLPROTO((char *,int));
Xchar *calloc DCLPROTO((int,int));
X#endif
Xchar *ttyname DCLPROTO((int));
X
Xextern char PC, *BC, *UP;
Xextern short ospeed;
Xextern int tgetent DCLPROTO((char *bp, char *name));
Xextern int tgetnum DCLPROTO((char *id));
Xextern int tgetflag DCLPROTO((char *id));
Xextern char *tgetstr DCLPROTO((char *id, char **area));
Xextern char *tgoto DCLPROTO((char *cm, int destcol, int destline));
Xextern int tputs DCLPROTO((char *cp, int affcnt, int (*outc)()));
END_OF_FILE
  if test 1219 -ne `wc -c <'src/funcs.h'`; then
    echo shar: \"'src/funcs.h'\" unpacked with wrong size!
  fi
  # end of 'src/funcs.h'
fi
if test -f 'src/text.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/text.c'\"
else
  echo shar: Extracting \"'src/text.c'\" \(8624 characters\)
  sed "s/^X//" >'src/text.c' <<'END_OF_FILE'
X/*
X *
X * text.c - textual representations of syntax trees
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
Xstatic char *tptr,*tbuf,*tlim;
Xstatic int tsiz,tindent,tnewlins;
X
X/* add a character to the text buffer */
X
Xvoid taddchr(c) /**/
Xint c;
X{
X	*tptr++ = c;
X	if (tptr == tlim) {
X		if (!tbuf) { tptr--; return; }
X		tbuf = realloc(tbuf,tsiz *= 2);
X		tlim = tbuf+tsiz;
X		tptr = tbuf+tsiz/2;
X	}
X}
X
X/* add a string to the text buffer */
X
Xvoid taddstr(s) /**/
Xchar *s;
X{
Xint sl = strlen(s);
X
X	while (tptr+sl >= tlim) {
X		int x = tptr-tbuf;
X
X		if (!tbuf) return;
X		tbuf = realloc(tbuf,tsiz *= 2);
X		tlim = tbuf+tsiz;
X		tptr = tbuf+x;
X	}
X	strcpy(tptr,s);
X	tptr += sl;
X}
X
X/* add an integer to the text buffer */
X
Xvoid taddint(x) /**/
Xint x;
X{
Xchar buf[10];
X
X	sprintf(buf,"%d",x);
X	taddstr(buf);
X}
X
X/* add a newline, or something equivalent, to the text buffer */
X
Xvoid taddnl() /**/
X{
Xint t0;
X
X	if (tnewlins)
X		{
X		taddchr('\n');
X		for (t0 = 0; t0 != tindent; t0++)
X			taddchr('\t');
X		}
X	else
X		taddstr("; ");
X}
X
X/* get a permanent textual representation of n */
X
Xchar *getpermtext(n) /**/
Xstruct node *n;
X{
X	tnewlins = 1;
X	tbuf = zalloc(tsiz = 32);
X	tptr = tbuf;
X	tlim = tbuf+tsiz;
X	tindent = 1;
X	gettext2(n);
X	*tptr = '\0';
X	untokenize(tbuf);
X	return tbuf;
X}
X
X/* get a representation of n in a job text buffer */
X
Xchar *getjobtext(n) /**/
Xstruct node *n;
X{
Xstatic char jbuf[JOBTEXTSIZE];
X
X	tnewlins = 0;
X	tbuf = NULL;
X	tptr = jbuf;
X	tlim = tptr+JOBTEXTSIZE-1;
X	tindent = 1;
X	gettext2(n);
X	*tptr = '\0';
X	untokenize(jbuf);
X	return jbuf;
X}
X
X#define gt2(X) gettext2((struct node *) (X))
X
X/*
X	"gettext2" or "type checking and how to avoid it"
X	an epic function by Paul Falstad
X*/
X
X#define _Cond(X) ((Cond) (X))
X#define _Cmd(X) ((Cmd) (X))
X#define _Pline(X) ((Pline) (X))
X#define _Sublist(X) ((Sublist) (X))
X#define _List(X) ((List) (X))
X#define _casecmd(X) ((struct casecmd *) (X))
X#define _ifcmd(X) ((struct ifcmd *) (X))
X#define _whilecmd(X) ((struct whilecmd *) (X))
X
Xvoid gettext2(n) /**/
Xstruct node *n;
X{
XCmd nn;
XCond nm;
X
X	if (!n)
X		return;
X	switch (n->type)
X		{
X		case N_LIST:
X			gt2(_List(n)->left);
X			if (_List(n)->type == ASYNC)
X				taddstr(" &");
X			simplifyright(_List(n));
X			if (_List(n)->right)
X				{
X				if (tnewlins)
X					taddnl();
X				else
X					taddstr((_List(n)->type == ASYNC) ? " " : "; ");
X				gt2(_List(n)->right);
X				}
X			break;
X		case N_SUBLIST:
X			if (_Sublist(n)->flags & PFLAG_NOT)
X				taddstr("! ");
X			if (_Sublist(n)->flags & PFLAG_COPROC)
X				taddstr("coproc ");
X			gt2(_Sublist(n)->left);
X			if (_Sublist(n)->right)
X				{
X				taddstr((_Sublist(n)->type == ORNEXT) ? " || " : " && ");
X				gt2(_Sublist(n)->right);
X				}
X			break;
X		case N_PLINE:
X			gt2(_Pline(n)->left);
X			if (_Pline(n)->type == PIPE)
X				{
X				taddstr(" | ");
X				gt2(_Pline(n)->right);
X				}
X			break;
X		case N_CMD:
X			nn = _Cmd(n);
X			if (nn->flags & CFLAG_EXEC)
X				taddstr("exec ");
X			if (nn->flags & CFLAG_COMMAND)
X				taddstr("command ");
X			switch (nn->type)
X				{
X				case SIMPLE:
X					getsimptext(nn);
X					break;
X				case SUBSH:
X					taddstr("( ");
X					tindent++;
X					gt2(nn->u.list);
X					tindent--;
X					taddstr(" )");
X					break;
X				case ZCTIME:
X					taddstr("time ");
X					tindent++;
X					gt2(nn->u.pline);
X					tindent--;
X					break;
X				case FUNCDEF:
X					taddlist(nn->args);
X					taddstr(" () {");
X					tindent++;
X					taddnl();
X					gt2(nn->u.list);
X					tindent--;
X					taddnl();
X					taddstr("}");
X					break;
X				case CURSH:
X					taddstr("{ ");
X					tindent++;
X					gt2(nn->u.list);
X					tindent--;
X					taddstr(" }");
X					break;
X				case CFOR:
X				case CSELECT:
X					taddstr((nn->type == CFOR) ? "for " : "select ");
X					taddstr(nn->u.forcmd->name);
X					if (nn->u.forcmd->inflag)
X						{
X						taddstr(" in ");
X						taddlist(nn->args);
X						}
X					taddnl();
X					taddstr("do");
X					tindent++;
X					taddnl();
X					gt2(nn->u.forcmd->list);
X					taddnl();
X					tindent--;
X					taddstr("done");
X					break;
X				case CIF:
X					gt2(nn->u.ifcmd);
X					taddstr("fi");
X					break;
X				case CCASE:
X					taddstr("case ");
X					taddlist(nn->args);
X					taddstr(" in");
X					tindent++;
X					taddnl();
X					gt2(nn->u.casecmd);
X					tindent--;
X					if (tnewlins)
X						taddnl();
X					else
X						taddchr(' ');
X					taddstr("esac");
X					break;
X				case COND:
X					taddstr("[[ ");
X					gt2(nn->u.cond);
X					taddstr(" ]]");
X					break;
X				case CREPEAT:
X					taddstr("repeat ");
X					taddlist(nn->args);
X					taddnl();
X					taddstr("do");
X					tindent++;
X					taddnl();
X					gt2(nn->u.list);
X					tindent--;
X					taddnl();
X					taddstr("done");
X					break;
X				case CWHILE:
X					gt2(nn->u.whilecmd);
X					break;
X				}
X			getredirs(nn);
X			break;
X		case N_COND:
X			nm = _Cond(n);
X			switch (nm->type)
X				{
X				case COND_NOT:
X					taddstr("! ");
X					gt2(nm->left);
X					break;
X				case COND_AND:
X					taddstr("( ");
X					gt2(nm->left);
X					taddstr(" && ");
X					gt2(nm->right);
X					taddstr(" )");
X					break;
X				case COND_OR:
X					taddstr("( ");
X					gt2(nm->left);
X					taddstr(" || ");
X					gt2(nm->right);
X					taddstr(" )");
X					break;
X				default:
X					{
X					static char *c1[] = {
X						" = "," != "," < "," > "," -nt "," -ot "," -ef "," -eq ",
X						" -ne "," -lt "," -gt "," -le "," -ge "
X						};
X					if (nm->right)
X						taddstr(nm->left);
X					if (nm->type <= COND_GE)
X						taddstr(c1[nm->type-COND_STREQ]);
X					else
X						{
X						char c2[5];
X						c2[0] = ' '; c2[1] = '-';
X						c2[2] = nm->type;
X						c2[3] = ' '; c2[4] = '\0';
X						taddstr(c2);
X						}
X					taddstr((nm->right) ? nm->right : nm->left);
X					}
X					break;
X				}
X			break;
X		case N_CASE:
X			taddstr(_casecmd(n)->pat);
X			taddstr(") ");
X			tindent++;
X			gt2(_casecmd(n)->list);
X			tindent--;
X			taddstr(";;");
X			if (tnewlins)
X				taddnl();
X			else
X				taddchr(' ');
X			gt2(_casecmd(n)->next);
X			break;
X		case N_IF:
X			if (_ifcmd(n)->ifl)
X				{
X				taddstr("if ");
X				tindent++;
X				gt2(_ifcmd(n)->ifl);
X				tindent--;
X				taddnl();
X				taddstr("then");
X				}
X			else
X				taddchr('e');
X			tindent++;
X			taddnl();
X			gt2(_ifcmd(n)->thenl);
X			tindent--;
X			taddnl();
X			if (_ifcmd(n)->next)
X				{
X				taddstr("els");
X				gt2(_ifcmd(n)->next);
X				}
X			break;
X		case N_WHILE:
X			taddstr((_whilecmd(n)->cond) ? "until " : "while ");
X			tindent++;
X			gt2(_whilecmd(n)->cont);
X			tindent--;
X			taddnl();
X			taddstr("do");
X			tindent++;
X			taddnl();
X			gt2(_whilecmd(n)->loop);
X			tindent--;
X			taddnl();
X			taddstr("done");
X			break;
X		}
X}
X
Xvoid getsimptext(cmd) /**/
XCmd cmd;
X{
XLknode n;
X
X	for (n = firstnode(cmd->vars); n; incnode(n))
X		{
X		struct varasg *v = getdata(n);
X
X		taddstr(v->name);
X		taddchr('=');
X		if ((v->type & PMTYPE) == PMFLAG_A)
X			{
X			taddchr('(');
X			taddlist(v->arr);
X			taddstr(") ");
X			}
X		else
X			{
X			taddstr(v->str);
X			taddchr(' ');
X			}
X		}
X	taddlist(cmd->args);
X}
X
Xvoid getredirs(cmd) /**/
XCmd cmd;
X{
XLknode n;
Xstatic char *fstr[] = {
X	">",">!",">>",">>!",">&",">&!",">>&",">>&!","<","<<",
X	"<<-","<<<","<&",">&-","..",".."
X	};
X
X	taddchr(' ');
X	for (n = firstnode(cmd->redir); n; incnode(n))
X		{
X		struct redir *f = getdata(n);
X
X		switch(f->type)
X			{
X			case WRITE: case WRITENOW: case APP: case APPNOW: case READ:
X			case HERESTR:
X				if (f->fd1 != ((f->type == READ) ? 0 : 1))
X					taddchr('0'+f->fd1);
X				taddstr(fstr[f->type]);
X				taddchr(' ');
X				taddstr(f->name);
X				taddchr(' ');
X				break;
X			case MERGE: case MERGEOUT:
X				if (f->fd1 != ((f->type == MERGEOUT) ? 1 : 0))
X					taddchr('0'+f->fd1);
X				taddstr(fstr[f->type]);
X				if (f->fd2 == FD_COPROC)
X					taddchr('p');
X				else
X					taddint(f->fd2);
X				taddchr(' ');
X				break;
X			case CLOSE:
X				taddchr(f->fd1+'0');
X				taddstr(">&- ");
X				break;
X			case INPIPE:
X			case OUTPIPE:
X				if (f->fd1 != ((f->type == INPIPE) ? 0 : 1))
X					taddchr('0'+f->fd1);
X				taddstr((f->type == INPIPE) ? "< " : "> ");
X				taddstr(f->name);
X				taddchr(' ');
X				break;
X			}
X		}
X	tptr--;
X}
X
Xvoid taddlist(l) /**/
XLklist l;
X{
XLknode n;
X
X	for (n = firstnode(l); n; incnode(n))
X		{
X		taddstr(getdata(n));
X		taddchr(' ');
X		}
X	tptr--;
X}
END_OF_FILE
  if test 8624 -ne `wc -c <'src/text.c'`; then
    echo shar: \"'src/text.c'\" unpacked with wrong size!
  fi
  # end of 'src/text.c'
fi
if test -f 'src/watch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/watch.c'\"
else
  echo shar: Extracting \"'src/watch.c'\" \(7710 characters\)
  sed "s/^X//" >'src/watch.c' <<'END_OF_FILE'
X/*
X *
X * watch.c - login/logout watching
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
Xstatic int wtabsz;
Xstruct utmp *wtab;
Xstatic time_t lastutmpcheck;
X
X/* get the time of login/logout for WATCH */
X
Xtime_t getlogtime(u,inout) /**/
Xstruct utmp *u;int inout;
X{
XFILE *in;
Xstruct utmp uu;
Xint first = 1;
Xint srchlimit = 50; /* max number of wtmp records to search */
X
X	if (inout)
X		return u->ut_time;
X	if (!(in = fopen(WTMP_FILE,"r")))
X		return time(NULL);
X	fseek(in,0,2);
X	do
X		{
X		if (fseek(in,((first) ? -1 : -2)*sizeof(struct utmp),1))
X			{
X			fclose(in);
X			return time(NULL);
X			}
X		first = 0;
X		if (!fread(&uu,sizeof(struct utmp),1,in))
X			{
X			fclose(in);
X			return time(NULL);
X			}
X		if (uu.ut_time < lastwatch || !srchlimit--)
X			{
X			fclose(in);
X			return time(NULL);
X			}
X		}
X	while (memcmp(&uu,u,sizeof(struct utmp)));
X	do
X		if (!fread(&uu,sizeof(struct utmp),1,in))
X			{
X			fclose(in);
X			return time(NULL);
X			}
X	while (strncmp(uu.ut_line,u->ut_line,sizeof(u->ut_line)));
X	fclose(in);
X	return uu.ut_time;
X}
X
X/* print a login/logout event */
X
Xvoid watchlog2(inout,u,fmt) /**/
Xint inout;struct utmp *u;char *fmt;
X{
Xchar *p,buf[40],*bf;
Xint i;
Xtime_t timet;
Xstruct tm *tm;
X
X	while (*fmt)
X		if (*fmt != '%')
X			putchar(*fmt++);
X		else
X			{
X			fmt++;
X			switch(*fmt++)
X				{
X				case 'n':
X					printf("%.*s",sizeof(u->ut_name),u->ut_name);
X					break;
X				case 'a':
X					printf("%s",(!inout) ? "logged off" : "logged on");
X					break;
X				case 'l':
X					if (!strncmp(u->ut_line, "tty", 3))
X						printf("%.*s",sizeof(u->ut_line)-3,u->ut_line+3);
X					else
X						printf("%.*s",sizeof(u->ut_line),u->ut_line);
X					break;
X#ifdef UTMP_HOST
X				case 'm':
X					for (p = u->ut_host,i = sizeof(u->ut_host); i && *p;i--,p++)
X						{
X						if (*p == '.' && !idigit(p[1]))
X							break;
X						putchar(*p);
X						}
X					break;
X				case 'M':
X					printf("%.*s",sizeof(u->ut_host),u->ut_host);
X					break;
X#endif
X				case 't':
X				case '@':
X					timet = getlogtime(u,inout);
X					tm = localtime(&timet);
X					ztrftime(buf,40,"%l:%M%p",tm);
X					printf("%s",(*buf == ' ') ? buf+1 : buf);
X					break;
X				case 'T':
X					timet = getlogtime(u,inout);
X					tm = localtime(&timet);
X					ztrftime(buf,40,"%k:%M",tm);
X					printf("%s",buf);
X					break;
X				case 'w':
X					timet = getlogtime(u,inout);
X					tm = localtime(&timet);
X					ztrftime(buf,40,"%a %e",tm);
X					printf("%s",buf);
X					break;
X				case 'W':
X					timet = getlogtime(u,inout);
X					tm = localtime(&timet);
X					ztrftime(buf,40,"%m/%d/%y",tm);
X					printf("%s",buf);
X					break;
X				case 'D':
X					timet = getlogtime(u,inout);
X					tm = localtime(&timet);
X					ztrftime(buf,40,"%y-%m-%d",tm);
X					printf("%s",buf);
X					break;
X				case '%':
X					putchar('%');
X					break;
X				case 'S':
X					bf = buf;
X					if (tgetstr("so",&bf))
X						fputs(buf,stdout);
X					break;
X				case 's':
X					bf = buf;
X					if (tgetstr("se",&bf))
X						fputs(buf,stdout);
X					break;
X				case 'B':
X					bf = buf;
X					if (tgetstr("md",&bf))
X						fputs(buf,stdout);
X					break;
X				case 'b':
X					bf = buf;
X					if (tgetstr("me",&bf))
X						fputs(buf,stdout);
X					break;
X				case 'U':
X					bf = buf;
X					if (tgetstr("us",&bf))
X						fputs(buf,stdout);
X					break;
X				case 'u':
X					bf = buf;
X					if (tgetstr("ue",&bf))
X						fputs(buf,stdout);
X					break;
X				default:
X					putchar('%');
X					putchar(fmt[-1]);
X					break;
X				}
X			}
X	putchar('\n');
X}
X
X/* check the List for login/logouts */
X
Xvoid watchlog(inout,u,w,fmt) /**/
Xint inout;struct utmp *u;char **w;char *fmt;
X{
Xchar *v,*vv,sav;
Xint bad;
X
X	if (*w && !strcmp(*w,"all"))
X		{
X		watchlog2(inout,u,fmt);
X		return;
X		}
X	if (*w && !strcmp(*w,"notme") &&
X	  strncmp(u->ut_name, username, sizeof(u->ut_name)))
X		{
X		watchlog2(inout,u,fmt);
X		return;
X		}
X	for (; *w; w++)
X		{
X		bad = 0;
X		v = *w;
X		if (*v != '@' && *v != '%')
X			{
X			for (vv = v; *vv && *vv != '@' && *vv != '%'; vv++);
X			sav = *vv;
X			*vv = '\0';
X			if (strncmp(u->ut_name,v,sizeof(u->ut_name)))
X				bad = 1;
X			*vv = sav;
X			v = vv;
X			}
X		for (;;)
X			if (*v == '%')
X				{
X				for (vv = ++v; *vv && *vv != '@'; vv++);
X				sav = *vv;
X				*vv = '\0';
X				if (strncmp(u->ut_line,v,sizeof(u->ut_line)))
X					bad = 1;
X				*vv = sav;
X				v = vv;
X				}
X#ifdef UTMP_HOST
X			else if (*v == '@')
X				{
X				for (vv = ++v; *vv && *vv != '%'; vv++);
X				sav = *vv;
X				*vv = '\0';
X				if (strncmp(u->ut_host,v,strlen(v)))
X					bad = 1;
X				*vv = sav;
X				v = vv;
X				}
X#endif
X			else
X				break;
X		if (!bad)
X			{
X			watchlog2(inout,u,fmt);
X			return;
X			}
X		}
X}
X
X/* compare 2 utmp entries */
X
Xint ucmp(u,v) /**/
Xstruct utmp *u;struct utmp *v;
X{
X	if (u->ut_time == v->ut_time)
X		return strncmp(u->ut_line,v->ut_line,sizeof(u->ut_line));
X	return u->ut_time - v->ut_time;
X}
X
X/* initialize the user List */
X
Xvoid readwtab() /**/
X{
Xstruct utmp *uptr;
Xint wtabmax = 32;
XFILE *in;
X
X	wtabsz = 0;
X	if (!(in = fopen(UTMP_FILE,"r"))) return;
X	uptr = wtab = (struct utmp *) zalloc(wtabmax*sizeof(struct utmp));
X	while (fread(uptr,sizeof(struct utmp),1,in))
X#ifdef USER_PROCESS
X		if (uptr->ut_type == USER_PROCESS)
X#else
X		if (uptr->ut_name[0])
X#endif
X			{
X			uptr++;
X			if (++wtabsz == wtabmax)
X				uptr = (wtab = (struct utmp *) realloc((vptr) wtab,(wtabmax*=2)*
X					sizeof(struct utmp)))+wtabsz;
X			}
X	fclose(in);
X	if (wtabsz)
X		qsort((vptr)wtab,wtabsz,sizeof(struct utmp),
X				(int (*) DCLPROTO((const void *, const void *)))ucmp);
X}
X
X/* check for login/logout events; executed before each prompt
X	if WATCH is set */
X
Xvoid dowatch() /**/
X{
Xchar **s = watch;
Xchar *fmt = (watchfmt) ? watchfmt : DEFWATCHFMT;
XFILE *in;
Xint utabsz = 0,utabmax = wtabsz+4,uct,wct;
Xstruct utmp *utab,*uptr,*wptr;
Xstruct stat st;
X
X	holdintr();
X	if (!fmt)
X		fmt = "%n has %a %l from %m.";
X	if (!wtab) {
X		readwtab();
X		noholdintr();
X		return;
X	}
X	if ((stat(UTMP_FILE,&st) == -1) || (st.st_mtime <= lastutmpcheck))
X		return;
X	lastutmpcheck = st.st_mtime;
X	uptr = utab = (struct utmp *) zalloc(utabmax*sizeof(struct utmp));
X	if (!(in = fopen(UTMP_FILE,"r"))) {
X		free(utab);
X		return;
X	}
X	while (fread(uptr,sizeof *uptr,1,in))
X#ifdef USER_PROCESS
X		if (uptr->ut_type == USER_PROCESS)
X#else
X		if (uptr->ut_name[0])
X#endif
X			{
X			uptr++;
X			if (++utabsz == utabmax)
X				uptr = (utab = (struct utmp *) realloc((vptr) utab,(utabmax*=2)*
X					sizeof(struct utmp)))+utabsz;
X			}
X	fclose(in);
X	noholdintr();
X	if (errflag) {
X		free(utab);
X		return;
X	}
X	if (utabsz)
X		qsort((vptr)utab,utabsz,sizeof(struct utmp),
X				(int (*) DCLPROTO((const void *, const void *)))ucmp);
X
X	wct = wtabsz; uct = utabsz;
X	uptr = utab; wptr = wtab;
X	if (errflag) {
X		free(utab);
X		return;
X	}
X	while ((uct || wct) && !errflag)
X		if (!uct || (wct && ucmp(uptr,wptr) > 0))
X			wct--,watchlog(0,wptr++,s,fmt);
X		else if (!wct || (uct && ucmp(uptr,wptr) < 0))
X			uct--,watchlog(1,uptr++,s,fmt);
X		else
X			uptr++,wptr++,wct--,uct--;
X	free(wtab);
X	wtab = utab;
X	wtabsz = utabsz;
X	fflush(stdout);
X}
X
Xint bin_log(nam,argv,ops,func) /**/
Xchar *nam;char **argv;char *ops;int func;
X{
X	if (!watch)
X		return 1;
X	if (wtab)
X		free(wtab);
X	wtab = (struct utmp *) zalloc(1);
X	wtabsz = 0;
X	lastutmpcheck = 0;
X	dowatch();
X	return 0;
X}
X
END_OF_FILE
  if test 7710 -ne `wc -c <'src/watch.c'`; then
    echo shar: \"'src/watch.c'\" unpacked with wrong size!
  fi
  # end of 'src/watch.c'
fi
if test -f 'src/zle.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zle.h'\"
else
  echo shar: Extracting \"'src/zle.h'\" \(8560 characters\)
  sed "s/^X//" >'src/zle.h' <<'END_OF_FILE'
X/*
X *
X * zle.h - header file for line editor
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#ifdef ZLEGLOBALS
X#define ZLEXTERN
X#else
X#define ZLEXTERN extern
X#endif
X
X#ifdef ZLE
X
X/* cursor position */
XZLEXTERN int cs;
X
X/* line length */
XZLEXTERN int ll;
X
X/* size of line buffer */
XZLEXTERN int linesz;
X
X/* location of mark */
XZLEXTERN int mark;
X
X/* last character pressed */
XZLEXTERN int c;
X
X/* the z_ binding id for this key */
XZLEXTERN int bindk;
X
X/* command argument */
XZLEXTERN int mult;
X
X/* insert mode/overwrite mode flag */
XZLEXTERN int insmode;
X
X/* cost of last update */
XZLEXTERN int cost;
X
X/* flags associated with last command */
XZLEXTERN int lastcmd;
X
X/* column position before last LINEMOVE movement */
XZLEXTERN int lastcol;
X
X/* != 0 if we're getting a vi range */
XZLEXTERN int virangeflag;
X
X/* kludge to get cw and dw to work right */
XZLEXTERN int wordflag;
X
X/* Another kludge to lazy cache the usernames. Win on large systems */
XZLEXTERN int usernamescached;
X#endif
X
X/* last named command done */
XZLEXTERN int lastnamed;
X
X/* != 0 if we're done editing */
XZLEXTERN int done;
X
X/* length of prompt on screen */
XZLEXTERN int pptlen;
X
X/* current history line number */
XZLEXTERN int histline;
X
XZLEXTERN int eofsent;
X
X/* != 0 if we need to call resetvideo() */
XZLEXTERN int resetneeded;
X
X/* != 0 if the line editor is active */
XZLEXTERN int zleactive;
X
X/* the line buffer */
XZLEXTERN unsigned char *line;
X
X/* the cut buffer */
XZLEXTERN char *cutbuf;
X
X/* prompt and rprompt */
XZLEXTERN char *pmpt, *pmpt2;
X
X/* the last line in the history (the current one) */
XZLEXTERN char *curhistline;
X
X/* the status line */
XZLEXTERN char *statusline;
X
X/* 1 if a complete added a slash at the end of a directory name */
XZLEXTERN int addedslash;
X
X/*
X	the current history line and cursor position for the top line
X	on the buffer stack
X*/
X
XZLEXTERN int stackhist,stackcs;
X
X/* != 0 if we are in the middle of a menu completion */
XZLEXTERN int menucmp;
X
X/* != 0 if we are making undo records */
XZLEXTERN int undoing;
X
X/* last vi change buffer */
XZLEXTERN int vichgbufsz,vichgbufptr,vichgflag;
XZLEXTERN char *vichgbuf;
X
XZLEXTERN int viinsbegin;
X
Xtypedef void bindfunc DCLPROTO((void));
Xtypedef bindfunc *F;
X
Xstruct key {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	int func;			/* function code for this key */
X	char *str;			/* string corresponding to this key,
X								if func = z_sequenceleadin				 */
X	int len;				/* length of string */
X	};
Xstruct zlecmd {
X	char *name;			/* name of function */
X	F func;				/* handler function */
X	int flags;
X	};
X
X/* undo event */
X
Xstruct undoent {
X	int pref;		/* number of initial chars unchanged */
X	int suff;		/* number of trailing chars unchanged */
X	int len;			/* length of changed chars */
X	int cs;			/* cursor pos before change */
X	char *change;	/* NOT null terminated */
X	};
X
X#define UNDOCT 64
X
Xstruct undoent undos[UNDOCT];
X
X/* the line before last mod (for undo purposes) */
XZLEXTERN unsigned char *lastline;
X
X/* buffer specified with "x */
XZLEXTERN int vibufspec;
X
XZLEXTERN int undoct,lastcs;
X
XZLEXTERN char *visrchstr;
XZLEXTERN int visrchsense;
X
X#define ZLE_MOVEMENT  	 1
X#define ZLE_MENUCMP  	 2
X#define ZLE_UNDO      	 4
X#define ZLE_YANK     	 8
X#define ZLE_LINEMOVE 	 16
X#define ZLE_ARG      	 32
X#define ZLE_NAMEDBUFFER 128
X#define ZLE_KILL        (64|ZLE_NAMEDBUFFER)
X#define ZLE_HISTSEARCH  256
X#define ZLE_NEGARG      512
X#define ZLE_INSERT     1024
X#define ZLE_DELETE     2048
X
Xtypedef struct key *Key;
X
XZLEXTERN int *bindtab;
Xextern int emacsbind[256];
XZLEXTERN int altbindtab[256],mainbindtab[256];
Xextern int viinsbind[],vicmdbind[];
XZLEXTERN int vimarkcs[27],vimarkline[27];
X
X#define KRINGCT 8
XZLEXTERN char *kring[KRINGCT];
XZLEXTERN int kringnum;
XZLEXTERN char *vibuf[36];
X
X#define z_acceptandhold 0
X#define z_acceptandinfernexthistory 1
X#define z_acceptandmenucomplete 2
X#define z_acceptline 3
X#define z_acceptlineanddownhistory 4
X#define z_backwardchar 5
X#define z_backwarddeletechar 6
X#define z_backwarddeleteword 7
X#define z_backwardkillline 8
X#define z_backwardkillword 9
X#define z_backwardword 10
X#define z_beginningofbufferorhistory 11
X#define z_beginningofhistory 12
X#define z_beginningofline 13
X#define z_beginningoflinehist 14
X#define z_capitalizeword 15
X#define z_clearscreen 16
X#define z_completeword 17
X#define z_copyprevword 18
X#define z_copyregionaskill 19
X#define z_deletechar 20
X#define z_deletecharorlist 21
X#define z_deleteword 22
X#define z_digitargument 23
X#define z_downcaseword 24
X#define z_downhistory 25
X#define z_downlineorhistory 26
X#define z_endofbufferorhistory 27
X#define z_endofhistory 28
X#define z_endofline 29
X#define z_endoflinehist 30
X#define z_exchangepointandmark 31
X#define z_executelastnamedcmd 32
X#define z_executenamedcmd 33
X#define z_expandhistory 34
X#define z_expandorcomplete 35
X#define z_expandword 36
X#define z_forwardchar 37
X#define z_forwardword 38
X#define z_getline 39
X#define z_gosmacstransposechars 40
X#define z_historyincrementalsearchbackward 41
X#define z_historyincrementalsearchforward 42
X#define z_historysearchbackward 43
X#define z_historysearchforward 44
X#define z_infernexthistory 45
X#define z_insertlastword 46
X#define z_killbuffer 47
X#define z_killline 48
X#define z_killregion 49
X#define z_killwholeline 50
X#define z_listchoices 51
X#define z_listexpand 52
X#define z_magicspace 53
X#define z_menucompleteword 54
X#define z_menuexpandorcomplete 55
X#define z_overwritemode 56
X#define z_pushline 57
X#define z_quotedinsert 58
X#define z_quoteline 59
X#define z_quoteregion 60
X#define z_redisplay 61
X#define z_reversemenucomplete 62
X#define z_runhelp 63
X#define z_selfinsert 64
X#define z_selfinsertunmeta 65
X#define z_sendbreak 66
X#define z_sendstring 67
X#define z_sequenceleadin 68
X#define z_setmarkcommand 69
X#define z_spellword 70
X#define z_toggleliteralhistory 71
X#define z_transposechars 72
X#define z_transposewords 73
X#define z_undefinedkey 74
X#define z_undo 75
X#define z_universalargument 76
X#define z_upcaseword 77
X#define z_uphistory 78
X#define z_uplineorhistory 79
X#define z_viaddeol 80
X#define z_viaddnext 81
X#define z_vibackwardblankword 82
X#define z_vibackwardchar 83
X#define z_vibackwarddeletechar 84
X#define z_vibeginningofline 85
X#define z_vicapslockpanic 86
X#define z_vichange 87
X#define z_vichangeeol 88
X#define z_vichangewholeline 89
X#define z_vicmdmode 90
X#define z_videlete 91
X#define z_videletechar 92
X#define z_vidigitorbeginningofline 93
X#define z_viendofline 94
X#define z_vifetchhistory 95
X#define z_vifindnextchar 96
X#define z_vifindnextcharskip 97
X#define z_vifindprevchar 98
X#define z_vifindprevcharskip 99
X#define z_vifirstnonblank 100
X#define z_viforwardblankword 101
X#define z_viforwardblankwordend 102
X#define z_viforwardchar 103
X#define z_viforwardwordend 104
X#define z_vigotocolumn 105
X#define z_vigotomark 106
X#define z_vigotomarkline 107
X#define z_vihistorysearchbackward 108
X#define z_vihistorysearchforward 109
X#define z_viindent 110
X#define z_viinsert 111
X#define z_viinsertbol 112
X#define z_vijoin 113
X#define z_vimatchbracket 114
X#define z_viopenlineabove 115
X#define z_viopenlinebelow 116
X#define z_vioperswapcases 117
X#define z_viputafter 118
X#define z_virepeatchange 119
X#define z_virepeatfind 120
X#define z_virepeatsearch 121
X#define z_vireplace 122
X#define z_vireplacechars 123
X#define z_virevrepeatfind 124
X#define z_virevrepeatsearch 125
X#define z_visetbuffer 126
X#define z_visetmark 127
X#define z_visubstitute 128
X#define z_viswapcase 129
X#define z_viundochange 130
X#define z_viunindent 131
X#define z_viyank 132
X#define z_viyankeol 133
X#define z_whichcommand 134
X#define z_yank 135
X#define z_yankpop 136
X#define z_emacsbackwardword 137
X#define z_emacsforwardword 138
X#define z_killword 139
X#define z_vikillline 140
X#define z_vibackwardkillword 141
X#define z_expandcmdpath 142
X#define z_negargument 143
X#define z_poundinsert 144
X#define z_viforwardword 145
X#define z_vibackwardword 146
X#define z_uplineorsearch 147
X#define z_downlineorsearch 148
X#define ZLECMDCOUNT 149
X
Xextern struct zlecmd zlecmds[];
X
END_OF_FILE
  if test 8560 -ne `wc -c <'src/zle.h'`; then
    echo shar: \"'src/zle.h'\" unpacked with wrong size!
  fi
  # end of 'src/zle.h'
fi
if test -f 'src/zle_vi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zle_vi.c'\"
else
  echo shar: Extracting \"'src/zle_vi.c'\" \(5195 characters\)
  sed "s/^X//" >'src/zle_vi.c' <<'END_OF_FILE'
X/*
X *
X * zle_vi.c - vi-specific functions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X
Xstatic void startvichange(im)
Xint im;
X{
X	insmode = im;
X	if (vichgbuf) free(vichgbuf);
X	vichgbuf = zalloc(vichgbufsz = 16);
X	vichgbuf[0] = c;
X	vichgbufptr = 1;
X	vichgflag = 1;
X	viinsbegin = cs;
X}
X
Xstatic void startvitext(im)
Xint im;
X{
X	startvichange(im);
X	bindtab = mainbindtab;
X	undoing = 0;
X}
X
Xint vigetkey() /**/
X{
Xint ch;
X
X	if ((ch = getkey(0)) == -1)
X		return 0;
X	if (ch == 22)
X		{
X		if ((ch = getkey(0)) == -1)
X			return 0;
X		return ch;
X		}
X	else if (ch == 27)
X		return 0;
X	return ch;
X}
X
Xint getvirange(wf) /**/
Xint wf;
X{
Xint k2,t0,startline,endline;
X
X	startline = findbol();
X	endline = findeol();
X	for (;;) {
X		k2 = getkeycmd();
X		if (k2 == -1) {
X			feep();
X			return -1;
X		}
X		if (zlecmds[k2].flags & ZLE_ARG)
X			(*zlecmds[k2].func)();
X		else
X			break;
X	}
X	if (k2 == bindk) {
X		findline(&cs,&t0);
X		return (t0 == ll) ? t0 : t0+1;
X	}
X	if (!(zlecmds[k2].flags & ZLE_MOVEMENT)) {
X		feep();
X		return -1;
X	}
X	t0 = cs;
X
X	virangeflag = 1;
X	wordflag = wf;
X	(*zlecmds[k2].func)();
X	wordflag = virangeflag = 0;
X	if (cs == t0) {
X		feep();
X		return -1;
X	}
X	if (startline != findbol()) {
X		if (zlecmds[k2].flags & ZLE_LINEMOVE) {
X			if (cs < t0) {
X				cs = startline;
X				t0 = findeol()+1;
X			} else {
X				t0 = startline;
X				cs = findeol()+1;
X			}
X		} else {
X			if (cs < startline) cs = startline;
X			else if (cs >= endline) cs = endline-1;
X		}
X	}
X	if (cs > t0) {
X		k2 = cs;
X		cs = t0;
X		t0 = k2;
X	}
X	return t0;
X}
X
Xvoid viaddnext() /**/
X{
X	if (cs != ll)
X		cs++;
X	startvitext(1);
X}
X
Xvoid viaddeol() /**/
X{
X	cs = findeol();
X	startvitext(1);
X}
X
Xvoid viinsert() /**/
X{
X	startvitext(1);
X}
X
Xvoid viinsertbol() /**/
X{
X	cs = findbol();
X	startvitext(1);
X}
X
Xvoid videlete() /**/
X{
Xint c2;
X
X	startvichange(1);
X	if ((c2 = getvirange(0)) == -1)
X		{ vichgflag = 0; return; }
X	forekill(c2-cs,0);
X	vichgflag = 0;
X}
X
Xvoid videletechar() /**/
X{
X	if (mult < 0) { mult = -mult; vibackwarddeletechar(); return; }
X	if (c == 4 && !ll) {
X		eofsent = 1;
X		return;
X	}
X	if (!(cs+mult > ll || line[cs] == '\n')) {
X		if ( vichgbuf == NULL ) vichgbuf = zalloc ( vichgbufsz = 16 );
X		vichgbufptr = 1;
X		vichgbuf[0] = c;
X		cs += mult;
X		backkill(mult,0);
X		if (cs && (cs == ll || line[cs] == '\n')) cs--;
X	} else
X		feep();
X}
X
Xvoid vichange() /**/
X{
Xint c2;
X
X	startvichange(1);
X	if ((c2 = getvirange(1)) == -1)
X		{ vichgflag = 0; return; }
X	forekill(c2-cs,0);
X	bindtab = mainbindtab;
X	undoing = 0;
X}
X
Xvoid visubstitute() /**/
X{
X	if (mult < 0) return;
X	if (findeol()-cs < mult) mult = findeol()-cs;
X	if (mult) {
X		foredel(mult);
X		startvitext(1);
X	}
X}
X
Xvoid vichangeeol() /**/
X{
X	killline();
X	startvitext(1);
X}
X
Xvoid vichangewholeline() /**/
X{
Xint cq;
X
X	findline(&cs,&cq);
X	foredel(cq-cs);
X	startvitext(1);
X}
X
Xvoid viyank() /**/
X{
Xint c2;
X
X	if ((c2 = getvirange(0)) == -1) return;
X	cut(cs,c2-cs,0);
X}
X
Xvoid viyankeol() /**/
X{
Xint x = findeol();
X
X	if (x == cs)
X		feep();
X	else
X		cut(cs,x-cs,0);
X}
X
Xvoid vireplace() /**/
X{
X	startvitext(0);
X}
X
Xvoid vireplacechars() /**/
X{
Xint ch;
X
X	if (mult < 0) return;
X	if (mult+cs > ll) {
X		feep();
X		return;
X	}
X	startvichange(1);
X	if (ch = vigetkey()) while (mult--) line[cs++] = ch;
X	vichgflag = 0;
X	cs--;
X}
X
Xvoid vicmdmode() /**/
X{
X	bindtab = altbindtab;
X	if (cs) cs--;
X	undoing = 1;
X	if (vichgflag) vichgflag = 0;
X}
X
Xvoid viopenlinebelow() /**/
X{
X	cs = findeol();
X	spaceinline(1);
X	line[cs++] = '\n';
X	startvitext(1);
X}
X
Xvoid viopenlineabove() /**/
X{
X	cs = findbol();
X	spaceinline(1);
X	line[cs] = '\n';
X	startvitext(1);
X}
X
Xvoid vioperswapcase() /**/
X{
Xint c2;
X
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	while (cs < c2)
X		{
X		int ch = line[cs];
X
X		if (islower(ch))
X			ch = tuupper(ch);
X		else if (isupper(ch))
X			ch = tulower(ch);
X		line[cs++] = ch;
X		}
X}
X
Xvoid virepeatchange() /**/
X{
X	if (!vichgbuf || bindtab == mainbindtab || vichgflag) feep();
X	else ungetkeys(vichgbuf,vichgbufptr);
X}
X
Xvoid viindent() /**/
X{
Xint c2,endcs,t0,rmult;
X
X	if (mult < 0) { mult = -mult; viunindent(); return; }
X	rmult = mult;
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	if (cs != findbol()) { feep(); return; }
X	endcs = cs+rmult;
X	while (cs < c2) {
X		spaceinline(rmult);
X		for (t0 = 0; t0 != rmult; t0++) line[cs++] = '\t';
X		cs = findeol()+1;
X	}
X	cs = endcs;
X}
X
Xvoid viunindent() /**/
X{
Xint c2,endcs,t0,rmult;
X
X	rmult = mult;
X	if (mult < 0) { mult = -mult; viindent(); return; }
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	if (cs != findbol()) { feep(); return; }
X	endcs = cs;
X	while (cs < c2) {
X		for (t0 = 0; t0 != rmult && line[cs] == '\t'; t0++) foredel(1);
X		cs = findeol()+1;
X	}
X	cs = endcs;
X}
END_OF_FILE
  if test 5195 -ne `wc -c <'src/zle_vi.c'`; then
    echo shar: \"'src/zle_vi.c'\" unpacked with wrong size!
  fi
  # end of 'src/zle_vi.c'
fi
if test -f 'src/zle_word.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/zle_word.c'\"
else
  echo shar: Extracting \"'src/zle_word.c'\" \(6652 characters\)
  sed "s/^X//" >'src/zle_word.c' <<'END_OF_FILE'
X/*
X *
X * zle_word.c - word-related editor functions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X
Xvoid forwardword() /**/
X{
X	if (mult < 0) { mult = -mult; backwardword(); return; }
X	while (mult--) {
X		while (cs != ll && iword(line[cs])) cs++;
X		if (wordflag && !mult) return;
X		while (cs != ll && !iword(line[cs])) cs++;
X	}
X}
X
Xvoid viforwardword() /**/
X{
X	if (mult < 0) { mult = -mult; backwardword(); return; }
X	while (mult--) {
X		if (iident(line[cs])) while (cs != ll && iident(line[cs])) cs++;
X		else while (cs != ll && !iident(line[cs]) && !iblank(line[cs])) cs++;
X		if (wordflag && !mult) return;
X		while (cs != ll && iblank(line[cs])) cs++;
X	}
X}
X
Xvoid viforwardblankword() /**/
X{
X	if (mult < 0) { mult = -mult; vibackwardblankword(); return; }
X	while (mult--) {
X		while (cs != ll && !iblank(line[cs])) cs++;
X		if (wordflag && !mult) return;
X		while (cs != ll && iblank(line[cs])) cs++;
X	}
X}
X
Xvoid emacsforwardword() /**/
X{
X	if (mult < 0) { mult = -mult; emacsbackwardword(); return; }
X	while (mult--)
X		{
X		while (cs != ll && !iword(line[cs])) cs++;
X		if (wordflag && !mult) return;
X		while (cs != ll && iword(line[cs])) cs++;
X		}
X}
X
Xvoid viforwardblankwordend() /**/
X{
X	if (mult < 0) return;
X	while (mult--) {
X		while (cs != ll && iblank(line[cs+1])) cs++;
X		while (cs != ll && !iblank(line[cs+1])) cs++;
X	}
X	if (cs != ll && virangeflag) cs++;
X}
X
Xvoid viforwardwordend() /**/
X{
X	if (mult < 0) { mult = -mult; backwardword(); return; }
X	while (mult--) {
X		if (iblank(line[cs+1])) while (cs != ll && iblank(line[cs+1])) cs++;
X		if (iident(line[cs+1])) while (cs != ll && iident(line[cs+1])) cs++;
X		else while (cs != ll && !iident(line[cs+1]) && !iblank(line[cs+1])) cs++;
X	}
X	if (cs != ll && virangeflag) cs++;
X}
X
Xvoid backwardword() /**/
X{
X	if (mult < 0) { mult = -mult; forwardword(); return; }
X	while (mult--) {
X		while (cs && !iword(line[cs-1])) cs--;
X		while (cs && iword(line[cs-1])) cs--;
X	}
X}
X
Xvoid vibackwardword() /**/
X{
X	if (mult < 0) { mult = -mult; backwardword(); return; }
X	while (mult--) {
X		while (cs && iblank(line[cs-1])) cs--;
X		if (iident(line[cs-1])) while (cs && iident(line[cs-1])) cs--;
X		else while (cs && !iident(line[cs-1]) && !iblank(line[cs-1])) cs--;
X	}
X}
X
Xvoid vibackwardblankword() /**/
X{
X	if (mult < 0) { mult = -mult; viforwardblankword(); return; }
X	while (mult--) {
X		while (cs && iblank(line[cs-1])) cs--;
X		while (cs && !iblank(line[cs-1])) cs--;
X	}
X}
X
Xvoid emacsbackwardword() /**/
X{
X	if (mult < 0) { mult = -mult; emacsforwardword(); return; }
X	while (mult--) {
X		while (cs && !iword(line[cs-1])) cs--;
X		while (cs && iword(line[cs-1])) cs--;
X	}
X}
X
Xvoid backwarddeleteword() /**/
X{
Xint x = cs;
X
X	if (mult < 0) { mult = -mult; deleteword(); return; }
X	while (mult--) {
X		while (x && !iword(line[x-1])) x--;
X		while (x && iword(line[x-1])) x--;
X	}
X	backdel(cs-x);
X}
X
Xvoid vibackwardkillword() /**/
X{
Xint x = cs;
X
X        if (mult < 0) { feep(); return; }
X	/* this taken from "vibackwardword" */
X        while (mult--) {
X                while ((x > viinsbegin) && iblank(line[x-1])) x--;
X                if (iident(line[x-1])) while ((x > viinsbegin) && iident(line[x-1])) x--;
X                else while ((x > viinsbegin) && !iident(line[x-1]) && !iblank(line[x-1])) x--;
X        }
X        /* 
X        while (mult--) {
X                while ( (x > viinsbegin) && (iwordsep(line[x-1]))) x--;
X                while ( (x > viinsbegin) && (!iwordsep(line[x-1]))) x--;
X        }
X        */ 
X        backkill(cs-x,1);
X}
X
Xvoid backwardkillword() /**/
X{
Xint x = cs;
X
X        if (mult < 0) { mult = -mult; killword(); return; }
X        while (mult--) {                       
X                while (x && !iword(line[x-1])) x--;
X                while (x && iword(line[x-1])) x--;
X        }                                      
X        backkill(cs-x,1);                      
X}                                              
X
X
Xvoid upcaseword() /**/
X{
Xint neg = mult < 0, ocs = cs;
X
X	if (neg) mult = -mult;
X	while (mult--) {
X		while (cs != ll && !iword(line[cs])) cs++;
X		while (cs != ll && iword(line[cs])) {
X			line[cs] = tuupper(line[cs]);
X			cs++;
X		}
X	}
X	if (neg) cs = ocs;
X}
X
Xvoid downcaseword() /**/
X{
Xint neg = mult < 0, ocs = cs;
X
X	if (neg) mult = -mult;
X	while (mult--) {
X		while (cs != ll && !iword(line[cs])) cs++;
X		while (cs != ll && iword(line[cs])) {
X			line[cs] = tulower(line[cs]);
X			cs++;
X		}
X	}
X	if (neg) cs = ocs;
X}
X
Xvoid capitalizeword() /**/
X{
Xint first;
Xint neg = mult < 0, ocs = cs;
X	
X	if (neg) mult = -mult;
X	while (mult--) {
X		first = 1;
X		while (cs != ll && !iword(line[cs])) cs++;
X		while (cs != ll && iword(line[cs])) {
X			line[cs] = (first) ? tuupper(line[cs]) : tulower(line[cs]);
X			first = 0;
X			cs++;
X		}
X	}
X	if (neg) cs = ocs;
X}
X
Xvoid deleteword() /**/
X{
Xint x = cs;
X
X	if (mult < 0) { mult = -mult; backwarddeleteword(); return; }
X	while (mult--) {
X		while (x != ll && !iword(line[x])) x++;
X		while (x != ll && iword(line[x])) x++;
X	}
X	foredel(x-cs);
X}
X
Xvoid killword() /**/
X{
Xint x = cs;
X
X	if (mult < 0) { mult = -mult; backwardkillword(); return; }
X	while (mult--) {
X		while (x != ll && !iword(line[x])) x++;
X		while (x != ll && iword(line[x])) x++;
X	}
X	forekill(x-cs,0);
X}
X
Xvoid transposewords() /**/
X{
Xint p1,p2,p3,p4,x = cs;
Xchar *temp,*pp;
Xint neg = mult < 0, ocs = cs;
X
X	if (neg) mult = -mult;
X	while (mult--) {
X		while (x != ll && line[x] != '\n' && !iword(line[x]))
X			x++;
X		if (x == ll || line[x] == '\n') {
X			x = cs;
X			while (x && line[x-1] != '\n' && !iword(line[x]))
X				x--;
X			if (!x || line[x-1] == '\n') {
X				feep();
X				return;
X			}
X		}
X		for (p4 = x; p4 != ll && iword(line[p4]); p4++);
X		for (p3 = p4; p3 && iword(line[p3-1]); p3--);
X		if (!p3) {
X			feep();
X			return;
X		}
X		for (p2 = p3; p2 && !iword(line[p2-1]); p2--);
X		if (!p2) {
X			feep();
X			return;
X		}
X		for (p1 = p2; p1 && iword(line[p1-1]); p1--);
X		pp = temp = halloc(p4-p1+1);
X		struncpy(&pp,UTOSCP(line+p3),p4-p3);
X		struncpy(&pp,UTOSCP(line+p2),p3-p2);
X		struncpy(&pp,UTOSCP(line+p1),p2-p1);
X		strncpy((char *) line+p1,temp,p4-p1);
X		cs = p4;
X	}
X	if (neg) cs = ocs;
X}
END_OF_FILE
  if test 6652 -ne `wc -c <'src/zle_word.c'`; then
    echo shar: \"'src/zle_word.c'\" unpacked with wrong size!
  fi
  # end of 'src/zle_word.c'
fi
echo shar: End of archive 20 \(of 22\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
