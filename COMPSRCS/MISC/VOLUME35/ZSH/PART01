Newsgroups: comp.sources.misc
From: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Subject: v35i051:  zsh - The Z Shell, version 2.3.1, Part01/22
Message-ID: <csm-v35i051=zsh.151804@sparky.IMD.Sterling.COM>
X-Md4-Signature: 545f86c0cd079712a9cd636b8310f7e3
Date: Sat, 20 Feb 1993 21:18:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Posting-number: Volume 35, Issue 51
Archive-name: zsh/part01
Environment: UNIX
Supersedes: zsh2.2: Volume 29, Issue 97-113

Zsh is a shell designed for interactive use, although it is also a
powerful scripting language.  Many of the useful features of bash,
ksh, and tcsh were incorporated into zsh; many original features were
added.  See the doc/intro.{troff,txt} document for more details.

Zsh was originally written by Paul Falstad, who has transferred the 
current development of the shell to the zsh mailing list:

	zsh-list@cs.uow.edu.au

To subscribe to the list, send a request to "zsh-request@cs.uow.edu.au".  
This release consists of patches contributed to the mailing list, and 
the mailing list is continuing to work on zsh 2.4 as you read this.

--------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README doc dots func help man man/man1 scripts src
#   src/params.c
# Wrapped by mattson@odin on Sat Feb  6 14:41:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 22)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(22439 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XYou have permission to copy the zsh distribution in whole or in part
Xas long as you don't try to make money off of it, or pretend that you
Xwrote it.
X
XThis is zsh 2.3.1.
X
XTo get this shell running, cd into the src directory and type
X"buildzsh".  Someone recently tested it on the following machines,
Xwhere it compiled just by running this script:
X
XApollo (Motorola & PRISM) running Domain SR10.4 cc 6.9 
XBBN TC2000 running nX 3.0.1, 3.1.0
XCCI Tahoe running BSD 4.3-tahoe
XDEC (various) running Ultrix 4.2, 4.2A
XDEC Alpha running OSF-1
XFujitsu F2600 running SVR4
XHP 9000 (various) running HP-UX 7.0x, 8.0x, 9.01
XIBM RS6000 running AIX 3.2
XMIPS running RISC/OS 4.x
XNeXT running NeXTSTEP 2.x, 3.0
XSGI running IRIX 4.0.5
XSequent running DYNIX (additional work needed for DYNIX/PTX)
XSony running NeWS/OS 3.2 (BSD 4.3)
XSun-3, Sun-4 running SunOS 4.0.3, 4.1.x
X
XZsh was originally written by Paul Falstad, who has transferred the 
Xcurrent development of the shell to the zsh mailing list:
X
X	zsh-list@cs.uow.edu.au
X
XTo subscribe to the list, send a request to "zsh-request@cs.uow.edu.au".  
XThis release consists of patches contributed to the mailing list, and 
Xthe mailing list is continuing to work on zsh 2.4.
X
XThe following people contributed patches for the 2.3 release:
X
XHans Albertsson			Tero Kivinen
XEric Arnold			Karsten Kuenne
XBas de Bakker			Ben Liblit
XMarc Boucher			Rick Lyons
XCarlos Carvalho			Jim Mattson
XRobert Clare			Jean-Jacques Moreau
XDaniel Dignam			J.B. Nicholson-Owens
XStephen Dum			Rick Ohnemus
XCarl Edman			Wolf N. Paul
XChristian Finger		Bart Schaefer
XBrian Gregory			Dwight Shih
XJohn Guthrie			Peter Stephenson
XJohan Hagman			Klaus Wacker
XJonathan Hardwick		Irving Wolfe
X
XTabstops are 3 spaces.  If you're going to look at this code, run it
Xthough "expand -3" first, or set your tab stops every 3 spaces.
X
XModification history:
X
X2.3.1-2.3.0:
Xo fewer compilation warnings
Xo parsing error in function definition fixed
Xo problems with '.' in vi-mode fixed
Xo parsing bug with ! and coproc fixed
Xo strange while loop behavior fixed
Xo "TRAPx TRAPy {}; unfunction TRAPy" fixed
Xo array-size checking for integers was off by one (fixed)
X
X2.3.0-2.2.0:
Xo improved portability
Xo fewer compilation warnings
Xo texinfo documentation
Xo several memory leaks fixed, and a few references to freed memory eliminated
Xo several parsing bugs fixed, and now less illegal syntax is accepted
Xo improved (i.e. repaired) signal handling
Xo RFS support
Xo rc files reorganized (see INVOCATION in the man page)
Xo ksh compatibility mode when zsh is invoked as "ksh"
Xo nested variables (e.g. echo ${${var#?}%?})
Xo stringized array variables ("$a" where a is an array)
Xo can now set array slices and array elements by subscript
Xo 4 new glob identifiers:
X    -  a[[-|+]n]   files accessed within last n days (-), files accessed
X                   more than n days ago (+), or files accessed n days ago.
X    -  m[[-|+]n]   as above for modified files.
X    -  c[[-|+]n]   as above for the modification of an inode of a file.
X    -  L[[-|+]n]   files less than n bytes (-), more than n bytes (+),
X                   or exactly n bytes in length.
Xo new prompt escapes and new syntax for numeric arguments to prompt escapes
X   (e.g. %C3 -> %3C)
Xo %R and %r now only recognized in spell-checking prompts
Xo watch notme (like watch all, except for the user's own activity)
Xo hash table listings (from set, alias, compctl...) are now sorted
Xo New arguments to fc builtin:
X    -f  print full time stamp (including date)
X    -E  print date in European format (dd.mm.yyyy)
X    -I  incremental history update (with -A or -W)
Xo new EXTENDEDHISTORY option for saving timestamps to history file
Xo new {up,down}-line-or-search keybindings
Xo cd processing (chpwd, etc.) no longer occurs if new directory is the
X  same as the previous one
Xo filename completion works on named directories
Xo named directories now have to be strings
Xo username lookup more efficient, new username lookup routine for NIS
Xo sample run-help function to make use of the help directory
Xo sample zed function (use the zle line editor to edit a file)
Xo If compctl is just -h for a command, hostname completion will now be
X  performed after an @.  Compctl is set to just -h for commands in hostcmds.
Xo zsh no longer forks /bin/sh for any shell commands (e.g. STTY)
Xo old AUTOREMOVESLASH option documented and repaired.
Xo lexically significant quotes and backslashes are now retained by builtins
Xo backslashes now end variable names and suffice in a here document 
X  terminator to inhibit interpretation of the here document
Xo answering 'n' to 'remove all files in <arg>?' just removes the individual
X  argument from the rm command line, as long as other arguments remain
Xo ALLEXPORT now exports existing variables when they are modified
Xo whitespace now handled properly by read builtin
Xo ${#@} and ${#*} are now recognized
Xo colon modifers now work with array variables 
X  (except :x and :q, which only pretend to work)
Xo ${...=...} handling fixed
Xo cd xx/.. no longer takes you to first directory of $cdpath
Xo return in a loop in a function now exits the function
Xo return from a function in a loop no longer exits the loop
Xo several fixes to 'fc' builtin
Xo 'noglob rm *' no longer prompts for confirmation
Xo changes to cdpath, manpath, etc. are now reflected in the environment
Xo vibackwardkillword fixed to use vi style words
Xo not found message no longer printed if 'whence -a foo' doesn't find anything
Xo current dir is removed from directory stack if PUSHD_IGNORE_DUPS is set
Xo cd now complains of invalid directory stack arguments
Xo extra files are no longer left open on nullexec
Xo exit status is set correctly for shells started '-c'
Xo consistent handling of -i and -m options
Xo null arguments are now included in array expansion
Xo job text corrected for coprocesses
Xo a quoted command substitution that returns no text is no longer discarded
X  (e.g. set a "`echo`" b ; echo $#)
Xo IFS allows null fields
Xo read of more variables than available in the input no longer blocks shell
Xo dups of nonexistent file handles fixed
Xo confusion regarding controlling terminal fixed
Xo canonical directory naming fixed
Xo zsh no longer hangs on backquote expansion (e.g. echo `pwd`)
Xo echo foo >>(cat) now redirects stdin before closing the pipe
Xo problems with zsh not exiting fixed
Xo bad patterns now work when NOBADPATTERN is set
Xo exporting of special shell variables fixed
Xo history references now work only in interactive shells
Xo history file no longer saved if history is not established
Xo killing a command in a loop now kills the loop
Xo compctl -k now essentially ignores non-array arguments
Xo transpose-chars now works on one character lines and on the second 
X  character of a line
Xo neg-argument now works for multiple digits
Xo statusline no longer trashed when searching in vi mode
Xo print -P can now be invoked from a signal handler without confusing zle
Xo prototype files automatically generated during compilation
Xo GLOBALZSHENV now defined by default as "/etc/zshenv"
Xo off-by-one error in compiling signal list fixed
X
X2.2.0-2.1.0:
Xo should be faster in general
Xo fewer compilation warnings
Xo SPROMPT now uses %R instead of %s for the incorrect string
Xo no longer tries to create FIFOs on NeXTs (thereby causing a panic)
Xo now gets usernames from NIS on irises without crashing (SGI's getpwnam()
X  called my strdup(), the pricks.  Took me forever to find that.  :-) )
Xo fewer 7-bit assumptions
Xo which/whence/type have new options:
X  -a = all (find all occurrences of command in path)
X  -c = csh-style which (default for "which" command)
Xo error message for cd str1 str2 is fixed
Xo relative paths (including .) in cdpath now work
Xo exclusion patterns in glob: ls *.c~lex.c prints all .c files but lex.c
Xo bug with command substitution in chpwd fixed (buffers flushed twice)
Xo relative paths in $path now work
Xo "kill -9 -FOO" no longer kills shell
Xo new options to history/fc:
X	-d = prints date commands were entered
X	-D = prints running time of commands
Xo "history <num>" prints all commands SINCE <num> as well
Xo history stored differently - should be more efficient
Xo bg'ing a suspended zsh no longer causes problems
Xo "set" no longer prints ONLY exported params (duh)
Xo functions +t now allowed
Xo redirection is done AFTER filename generation
Xo print changes:
X  o print -u# prints to fd #
X  o print -p prints to coproc
X  o -D and -P perform \ substitution first
X  o print -0 changed to print -N
Xo read changes:
X  o read -u# reads from fd #
X  o read -p reads from coproc
X  o read -z waits for input if nothing on buffer stack
X  o no longer reads from fd 0 if shell is getting input from there
X  o echo -n foo | read x  now works
Xo getopts is now POSIX conformant
Xo compctl builtin added, replacing hostcmds, foocmds, etc.  Controls
X  completion of various commands in zle.
X  format: compctl -options cmdnams ...
X  options tell where to get possible matches from, and include:
X	 -c = command names
X	 -f = filenames
X	 -h = hostnames ($hosts)
X	 -o = options
X	 -v = vars
X	 -b = bindings
X	 -k name = elements of $name array
X  Any number of these options may be used together.
X  In addition, compctl -C -options will set the default completion
X  names when in command position (by default -c), and compctl -D -options
X  will set the default completion names used after unrecognized commands
X  or after redirections (by default -f).
Xo foo && bar || fuu now works
Xo ttyctl builtin added
X  ttyctl -f freezes the tty.  no changes made to the tty settings by
X	 external programs will be honored when this command is in effect.
X  ttyctl -u unfreezes the tty.
X  typically, "ttyctl -f" would be used in a zlogin or zshrc script after
X  "stty" has been called to set up the terminal.
Xo [[ -e file ]] is now equivalent to [[ -a file ]]
Xo [[ -h file ]] is now equivalent to [[ -L file ]]
Xo the path is now hashed incrementally.
X  o if the HASHCMDS option is unset, path hashing is not done at all.
X  o if the HASHCMDS option is set but HASHDIRS is unset, commands are placed
X	 in the hash table when first executed.
X  o if the HASHCMDS and HASHDIRS options are both set, commands are placed
X	 in the hash table when first executed, along with all commands in
X	 the directory that command was found in (and all directories earlier
X	 in the path).  This is the default situation.
Xo "for i (*.c) do /bin/echo $i ; done | more" no longer hangs
Xo coprocesses now work properly
Xo READNULLCMD is now used instead of NULLCMD for "< file"
Xo POSTEDIT is printed whenever the editor exits
Xo rm path/path/* is now reported by checkrmall()
Xo cmd >&- works
Xo cmd >>! file works
Xo time cmd no longer forks an extra process
Xo setopt printexitvalue ; echo `false` no longer prints anything
Xo here documents work inside eval, etc.
Xo $(...) works inside here documents
Xo "time" by itself prints the shell timings
Xo locals in precmd() or chpwd() work
Xo new glob qualifiers
X  o pat(M) sets markdirs, pat(^M) unsets it
X  o pat(N) sets nullglob, ...
X  o pat(D) sets globdots, ...
Xo ls * only sorts numeric filenames specially if NUMERICGLOBSORT is set
Xo setopt braceccl lets "echo {a-zA-Z}" work
Xo new options: pushdignoredups nohistbeep overstrike
Xo ls **/file is now equivalent to ls ****/file
Xo !'s in history are now escaped when you return to them
Xo history substitution is not done in script files
Xo echo $(!-2) works
Xo histverify and correct 'e' no longer put the edit line in the history
Xo the :x, :q, and :gs modifiers work properly now
Xo zsh -c 'ls =(ls)' no longer hangs
Xo VSWTCH is now set to ^Z on the irises
Xo zsh & no longer causes havoc
Xo USERNAME and LOGNAME are kept separate
Xo $manpath has been added for easy access to the $MANPATH components
Xo zsh now realizes if it is running under emacs, and resigns itself to
X  the fact rather than panicking
Xo SIGQUIT is ignored in the PRODUCTION version of zsh, and kills the shell
X  in the DEBUG version, rather than vice versa.
Xo GLOBALZSHENV has been added, and GLOBALZPROFILE is sourced in the
X  proper place
Xo "kill %" no longer causes the prompt to be printed 3 times if notify
X  is set on a NeXT
Xo REPORTTIME has been added; if a job runs longer than this many seconds,
X  timing statistics are reported
Xo timing statistics now include a job name (%J)
Xo no longer talks about SIGHUPed jobs if the kill failed
Xo no longer talks about running jobs which don't exist if you do eval exit
X  or if you have notify unset
Xo foo=bar comman[tab], for/select/foreach i (*.c[tab] both work
Xo [base]num inside $[...] works
Xo foo=pat(n|ern) works
Xo cd - prints the new directory
Xo l[tab] works if l is an alias
Xo select foo ; ... works (in $argv is assumed)
Xo select reads from the right input
Xo math identifiers can now contain numbers and _'s.
Xo lots of serious memory heap trashing and leaks fixed
Xo echo $HOME[*] no longer crashes the shell
Xo SIGWINCH now changes LINES and COLUMNS in the environment
Xo typeset +r TTY; TTY=foo no longer causes problems
Xo ~ substitution is no longer done in FIGNORE
Xo assignment to SECONDS works
Xo "else if" is no longer a synonym for "elif" <thud>
Xo lots of problems with null lists in flow constructs fixed
Xo no correction done for >file
Xo echo ${foo%bar is no longer weird
Xo modifying array substitutions works
Xo ^O can be bound to something
Xo command substitution in signal handlers no longer causes problems
Xo spelling correction is better ($PATH is corrected), and SPROMPT
X  allows all the regular PROMPT escapes
Xo new prompt escape sequence: %D{...} formats ... part using strftime
Xo shell input no longer butchered using IFS
Xo vi cmd mode has 's' bound to visubstitute, as it should be
Xo you can use ^XS and ^XR in i-search mode
Xo bindings to ^Z and ^@ work now on the irises
Xo ^V{^S,^Q,^Z,etc} now works on sgttyb victims
Xo nopromptclobber changed to nopromptcr
Xo vi 'u' undo works a little better (?)
Xo ESC-key bindings aren't screwed up if VISUAL is set to vi
Xo newline in prompt now works reliably
Xo vi change and delete work with forward-word/search, etc.
Xo somewhat suboptimal screen refresh on irises fixed (several seconds
X  per character inserted when TERM=xterm??)
Xo select list printing slightly different
Xo magic-space's handling of hatchars "fixed"
X
X0.03-1.0:
X	- "..../" is now "****/".  I know this isn't backward compatible,
X	  but I had no choice; the string "..../" was unquotable.
X	- parser was rewritten and improved
X	- completion was improved, several bugs fixed (including
X	  the "$([tab]" bug)
X	- vi mode editing is improved
X	- the value of PWD and OLDPWD in the environment now change
X	- the PROMPT formatting strings %W and %D now print the month
X	  correctly
X	- >&2 echo "error message" no longer prints "bad file number"
X	- ${foo%pat} no longer alters the value of foo
X	- $_ works
X	- ALL_EXPORT no longer causes let statements to crash the shell
X	- continue works
X	- echo $MAIL no longer dumps core if MAIL is null
X	- the new tty driver is selected by default
X	- the s modifier no longer complains if it can't find the string
X	  to substitute
X	- list-choices no longer fignores files
X	- cd is now smarter about symlinks
X	- negative subscripts other than -1 now work
X	- $(<filename) works better if filename contains $, ~, or =
X	- rehash no longer wastes memory
X	- with name=value assignments, name is checked to see if it is
X	  a valid identifier
X	- !1; !2 no longer eats the semicolon
X	- $foo:h never returns the empty string if foo starts with /
X	- select crashed with some compilers
X	- problems with aliases in <(...) constructs have been fixed
X	- links pointing to nowhere are denoted with an '&' in listtypes
X	- negative arguments are supported
X	- the shell does not screw around with the tty so much
X	- lots of other stuff
X
X0.02-0.03:
X	- two stupid bugs that were introduced in the last patch were fixed:
X	  - multiple command substitution on a line failed
X	  - a file descriptor leak caused the shell to crash after a while
X	- added 'An Introduction to the Z Shell'
X	- behaves properly when the tty session dies suddenly
X	- had a serious memory leak on some systems
X	- the test and [ builtins have been added, although [[...]]
X	  is more efficient
X	- in your prompt, %m2 now prints foo.bar, %m3 prints foo.bar.com, etc.
X	- the -D and -P options to print have been added
X	- the NULLCMD and ZDOTDIR parameters have been added
X	- ${*:-foo} works
X	- "$@" and "$arr[@]" work like ksh
X	- .zprofile is sourced before .zshrc in login shells
X	- the CSHJUNKIEQUOTES and PUSHDMINUS options have been added
X	- REAL_TTY compilation switch added
X	- aliases beginning with a space cause the history line to be junked
X	  if HISTIGNORESPACE is set
X	- echo prints bad options instead of complaining about them
X	- "set -o" no longer dumps core
X	- "alias a=alias; date >a" no longer creates a file called "alias"
X	- "function foo() \n { date }" is now legal (the () and the newline
X	  are allowed)
X	- nested brace expressions work properly
X	- disabled commands stay disabled after a rehash (or after the shell
X	  finishes sourcing your .zshrc)
X	- corrected aliases work
X	- executables in the currect directory are now completed
X	- in "case foo", "foo" is not interpreted as a directory name with autocd
X	- aliases were not always interpreted properly after a completion
X	- bindkey '^?' didn't work
X	- echo ${HOST:-{bar}} didn't work
X	- editor update is more efficient in some cases
X	- menucomplete works even better
X	- assign to an array element "foo[1]=bar" didn't always work
X	- doesn't print directories like "~tmp" if HOME=/
X	- quotes in case statement patterns caused problems
X	- pressing ^C right after typing "fc" caused the editor to share
X	  the tty with the shell
X	- echo $(echo 2) produced no output, but echo $(echo x) worked fine (weird)
X
X0.01-0.02:
X	- added script to convert most csh aliases to zsh aliases or functions
X	- fc -l (history) now appears in the history itself; HISTNOSTORE
X	  option added to get old behavior
X	- the POSIX process group race has been fixed; so 'w | more' should
X	  no longer hang
X	- FCEDIT added, to match the documentation
X	- %{...%} in the prompt added
X	- execute-named-cmd and execute-last-named-cmd bindings added
X	- sources ~/.zshenv in all shells, even if not interactive, unless
X	  -f is given
X	- ^ and # are no longer `magic' by default; use EXTENDEDGLOB option
X	  to use them
X	- now checks for tty sanity before each command
X	- if the right side of a variable assignment expands to more than
X	  one word, array assignment is assumed; so foo=*.c now works
X	- ~foo is no longer expanded in completion
X	- select now works even if the argument list is not sorted
X	- menucompletebeep option added
X	- emacs mode is now 8-bit clean by default; use bindkey -em
X	  to get your meta key back
X	- fc -R, fc -W added
X	- nocorrect added
X	- lines from history file are now split into words at spaces
X	- glob-complete, accept-and-menu-complete,
X	  beginning-of-line-hist, end-of-line-hist bindings added
X	- insert-last-word bound to M-. in emacs mode by default; now moves
X	  back through the history if run repeatedly
X	- J and K now bound to history search in vi mode
X	- delete-char no longer core dumps on an empty line
X	- menu-complete works better
X	- the editor checks the settings of VISUAL and EDITOR to set
X	  default bindings
X	- using [[ ... ]] expressions on a symbolic link works as expected
X	- various problems with globbing were fixed
X	- xx is now the same as !! if HISTCHARS=x
X	- added config.h entry for compilers that don't know about void *
X	- lexical analysis made more efficient
X	- "if echo $? ; then : ; fi" no longer always prints 0
X	- removed all enums, '\x7f's from code
X	- in "case foo in bar) xxx ;; esac", foo and bar are no longer subject
X	  to command alias expansion
X	- works on platforms where toupper('A') != 'A'
X	- \e sequence added to echo
X	- + options now work with set
X	- AUTORESUME and AUTOCD work better
X	- getopts works better (?)
X	- spell checking works better
X	- "let 2+3=" no longer crashes the shell
X	- "foo=bar; echo ${=foo}" no longer crashes the shell
X	- "zsh -c" or "zsh -o" no longer causes a core dump
X	- "unset MAIL; echo $MAIL" no longer causes a core dump
X	- "(xterm&xterm&)&" no longer causes a core dump
X	- "echo $HOM[tab]" beeps instead of deleting "$HOM"
X	- incremental history search works better
X	- the pwd of a fg'd job is now printed _before_ resuming it
X	- rv=`echo -n foo` no longer puts garbage in $rv
X	- "=1/*" now works as expected
X	- ^Z can now be bound to something
X	- the STTY parameter and the builtin builtin are now documented
X	- IFS=x; foo=`echo foo` no longer puts a newline in $foo
X	- $status added for csh compatibility
X	- arrays are automatically expanded if you say 'foo[1234]=x'
X	- shell now ignores SIGQUIT (it was commented out before :-)
X	- the times builtin works on systems where times() returns > 0
X	- no longer hangs the terminal if you ^S before flow control
X	  is turned off
X	- "date ; read foo" now works in interactive shells
X	- <<-foo is now parsed as <<- foo, not << -foo
X	- fixed various errors in the documentation
X
X0.00-0.01:
X	- %M and %m now work as documented.
X	- bad things no longer happen if COLUMNS is set to 0
X	- SH_WORD_SPLIT and ${=foo} now work
X	- the default value of WORDCHARS includes more characters
X	- if the cursor is at the end of the line, vi-cmd-mode
X	  moves it back one position.
X	- delete-char now acts more like x in vi.
X	- a "prompt" parameter has been added, which is equivalent to
X	  PROMPT and PS1.
X	- zsh no longer expands symbolic links.  The CHASELINKS option
X	  has been provided to get the old behavior.
X	- history searches ignore lines that are the same as the line
X	  in the buffer.
X	- you can get a literal ! in your prompt now with \!.
X	- -z, -n, and != in [[ ... ]] expressions work.
X	- the shell no longer hangs when inputting "[[ ]\n"
X	- the "menu-complete" and "menu-expand-or-complete" bindings have
X	  been added.
X	- menu-complete no longer beeps.
X	- reverse-menu-complete no longer dumps core if it gets called before
X	  a normal completion.
X	- typeahead lines are no longer thrown away on machines with sgttyb.
X	- !foo no longer matches lines with 'foo' in them (not at the beginning)
X	- kill -9 % no longer kills the shell
X	- no longer sources .zshrc from shell scripts or with -c
X	- no longer needs limits.h, strtol
X	- exporting HOSTTYPE, etc. works
X	- fixed serious bugs related to . in path
X	- numbers in weird bases now work
X
XKnown Bugs
X	- terminal acts weird under OpenWindows cmdtool
X	- xterm run in background inherits bad terminal modes
X
END_OF_FILE
  if test 22439 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test ! -d 'dots' ; then
    echo shar: Creating directory \"'dots'\"
    mkdir 'dots'
fi
if test ! -d 'func' ; then
    echo shar: Creating directory \"'func'\"
    mkdir 'func'
fi
if test ! -d 'help' ; then
    echo shar: Creating directory \"'help'\"
    mkdir 'help'
fi
if test ! -d 'man' ; then
    echo shar: Creating directory \"'man'\"
    mkdir 'man'
fi
if test ! -d 'man/man1' ; then
    echo shar: Creating directory \"'man/man1'\"
    mkdir 'man/man1'
fi
if test ! -d 'scripts' ; then
    echo shar: Creating directory \"'scripts'\"
    mkdir 'scripts'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/params.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/params.c'\"
else
  echo shar: Extracting \"'src/params.c'\" \(26353 characters\)
  sed "s/^X//" >'src/params.c' <<'END_OF_FILE'
X/*
X *
X * params.c - parameters
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X#include "version.h"
X#include <pwd.h>
X
X#define new(X) (X=(vptr)alloc(sizeof(*(X))))
X
Xstatic Param argvparam;
X
Xstruct iparam {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	vptr value;
X	int (*func1)(); /* set func */
X	int (*func2)(); /* get func */
X	int ct;				/* output base or field width */
X	int flags;
X	vptr data;			/* used by getfns */
X	char *env;			/* location in environment, if exported */
X	char *ename;		/* name of corresponding environment var */
X	};
X
X#define IFN(X) ((int (*)())(X))
X
X/* put predefined params in hash table */
X
Xvoid setupparams() /**/
X{
Xstatic struct iparam pinit[] = {
X#define IPDEF1(A,B,C,D) {NULL,0,A,NULL,IFN(C),IFN(B),10,\
X		PMFLAG_i|PMFLAG_SPECIAL|D,NULL,NULL,NULL}
X	IPDEF1("#",poundgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("ARGC",poundgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("ERRNO",errnogetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("GID",gidgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("HISTSIZE",histsizegetfn,histsizesetfn,0),
X	IPDEF1("LITHISTSIZE",lithistsizegetfn,lithistsizesetfn,0),
X	IPDEF1("RANDOM",randomgetfn,randomsetfn,0),
X	IPDEF1("SECONDS",secondsgetfn,secondssetfn,0),
X	IPDEF1("UID",uidgetfn,IFN(nullsetfn),PMFLAG_r),
X
X#define IPDEF2(A,B,C,D) {NULL,0,A,NULL,IFN(C),IFN(B),0,\
X		PMFLAG_SPECIAL|D,NULL,NULL,NULL}
X	IPDEF2("-",dashgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF2("HISTCHARS",histcharsgetfn,histcharssetfn,0),
X	IPDEF2("HOME",homegetfn,homesetfn,0),
X	IPDEF2("TERM",termgetfn,termsetfn,0),
X	IPDEF2("WORDCHARS",wordcharsgetfn,wordcharssetfn,0),
X	IPDEF2("IFS",ifsgetfn,ifssetfn,0),
X	IPDEF2("_",underscoregetfn,IFN(nullsetfn),PMFLAG_r),
X
X#define IPDEF3(A) {NULL,0,A,NULL,IFN(nullsetfn),IFN(strconstgetfn),0,PMFLAG_r|\
X		PMFLAG_SPECIAL,NULL,NULL,NULL}
X	IPDEF3("HOSTTYPE"),
X	IPDEF3("VERSION"),
X
X#define IPDEF4(A,B) {NULL,0,A,NULL,IFN(nullsetfn),IFN(intvargetfn),10,\
X		PMFLAG_r|PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF4("!",&lastpid),
X	IPDEF4("$",&mypid),
X	IPDEF4("?",&lastval),
X	IPDEF4("status",&lastval),
X	IPDEF4("LINENO",&lineno),
X	IPDEF4("PPID",&ppid),
X
X#define IPDEF5(A,B) {NULL,0,A,NULL,IFN(intvarsetfn),IFN(intvargetfn),10,\
X		PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF5("BAUD",&baud),
X	IPDEF5("COLUMNS",&columns),
X	IPDEF5("DIRSTACKSIZE",&dirstacksize),
X	IPDEF5("LINES",&lines),
X	IPDEF5("LISTMAX",&listmax),
X	IPDEF5("LOGCHECK",&logcheck),
X	IPDEF5("MAILCHECK",&mailcheck),
X	IPDEF5("OPTIND",&zoptind),
X	IPDEF5("PERIOD",&period),
X	IPDEF5("REPORTTIME",&reporttime),
X	IPDEF5("SAVEHIST",&savehist),
X	IPDEF5("SHLVL",&shlvl),
X	IPDEF5("TMOUT",&tmout),
X
X#define IPDEF6(A,B) {NULL,0,A,NULL,IFN(nullsetfn),IFN(strvargetfn),0,\
X		PMFLAG_r|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF6("LOGNAME",&logname),
X	IPDEF6("PWD",&pwd),
X	IPDEF6("TTY",&ttystrname),
X	IPDEF6("USERNAME",&username),
X
X#define IPDEF7(A,B) {NULL,0,A,NULL,IFN(strvarsetfn),IFN(strvargetfn),0,\
X		PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF7("FCEDIT",&fceditparam),
X	IPDEF7("HOST",&hostnam),
X	IPDEF7("OLDPWD",&oldpwd),
X	IPDEF7("OPTARG",&optarg),
X	IPDEF7("MAIL",&mailfile),
X	IPDEF7("NULLCMD",&nullcmd),
X	IPDEF7("POSTEDIT",&postedit),
X	IPDEF7("prompt",&prompt),
X	IPDEF7("PROMPT",&prompt),
X	IPDEF7("PROMPT2",&prompt2),
X	IPDEF7("PROMPT3",&prompt3),
X	IPDEF7("PROMPT4",&prompt4),
X	IPDEF7("READNULLCMD",&readnullcmd),
X	IPDEF7("RPROMPT",&rprompt),
X	IPDEF7("PS1",&prompt),
X	IPDEF7("PS2",&prompt2),
X	IPDEF7("PS3",&prompt3),
X	IPDEF7("PS4",&prompt4),
X	IPDEF7("RPS1",&rprompt),
X	IPDEF7("SPROMPT",&sprompt),
X	IPDEF7("TIMEFMT",&timefmt),
X	IPDEF7("TMPPREFIX",&tmpprefix),
X	IPDEF7("WATCHFMT",&watchfmt),
X	IPDEF7("0",&argzero),
X
X#define IPDEF8(A,B,C) {NULL,0,A,NULL,IFN(colonarrsetfn),IFN(colonarrgetfn),0,\
X		PMFLAG_SPECIAL,(vptr)C,NULL,B}
X	IPDEF8("CDPATH","cdpath",&cdpath),
X	IPDEF8("FIGNORE","fignore",&fignore),
X	IPDEF8("FPATH","fpath",&fpath),
X	IPDEF8("MAILPATH","mailpath",&mailpath),
X	IPDEF8("MANPATH","manpath",&manpath),
X	IPDEF8("WATCH","watch",&watch),
X	IPDEF8("HOSTS","hosts",&hosts),
X	IPDEF8("PSVAR","psvar",&psvar),
X	IPDEF8("PATH",NULL,NULL),
X
X#define IPDEF9(A,B,C,D) {NULL,0,A,NULL,IFN(arrvarsetfn),IFN(arrvargetfn),0,\
X		PMFLAG_A|PMFLAG_SPECIAL|C,(vptr)B,NULL,D}
X	IPDEF9("cdpath",&cdpath,0,"CDPATH"),
X	IPDEF9("fignore",&fignore,0,"FIGNORE"),
X	IPDEF9("fpath",&fpath,0,"FPATH"),
X	IPDEF9("mailpath",&mailpath,0,"MAILPATH"),
X	IPDEF9("manpath",&manpath,0,"MANPATH"),
X	IPDEF9("watch",&watch,0,"WATCH"),
X	IPDEF9("hosts",&hosts,0,"HOSTS"),
X	IPDEF9("psvar",&psvar,0,"PSVAR"),
X	IPDEF9("signals",&sigptr,PMFLAG_r,NULL),
X	IPDEF9("argv",&pparams,0,NULL),
X	IPDEF9("*",&pparams,0,NULL),
X	IPDEF9("@",&pparams,0,NULL),
X
X#define IPDEF10(A,C,D) {NULL,0,A,NULL,IFN(D),IFN(C),0,\
X		PMFLAG_A|PMFLAG_SPECIAL,NULL,NULL,NULL}
X	IPDEF10("path",pathgetfn,pathsetfn),
X	IPDEF10("hostcmds",nullgetfn,hostcmdssetfn),
X	IPDEF10("optcmds",nullgetfn,optcmdssetfn),
X	IPDEF10("bindcmds",nullgetfn,bindcmdssetfn),
X	IPDEF10("varcmds",nullgetfn,varcmdssetfn),
X	{NULL,}
X	};
Xstruct iparam *ip;
X
X	for (ip = pinit; ip->nam; ip++) addhperm(ip->nam,ip,paramtab,(FFunc) 0);
X	argvparam = gethnode("argv",paramtab);
X
X	((struct iparam *)gethnode("HOSTTYPE", paramtab))->data = ztrdup(HOSTTYPE);
X	((struct iparam *)gethnode("VERSION", paramtab))->data = ztrdup(VERSIONSTR);
X}
X
Xstatic int unsetflag;
X
Xstruct param *createparam(name,value,flags) /**/
Xchar *name;vptr value;int flags;
X{
Xstruct param *pm;
Xchar buf[20];
X
X	pm = zcalloc(sizeof *pm);
X	if (isset(ALLEXPORT))
X		flags |= PMFLAG_x;
X	pm->flags = flags;
X	if ((flags & PMTYPE) == PMFLAG_s) {
X		pm->u.str = value;
X		pm->sets.cfn = strsetfn;
X		pm->gets.cfn = strgetfn;
X	} else if ((flags & PMTYPE) == PMFLAG_A) {
X		pm->u.arr = value;
X		pm->sets.afn = arrsetfn;
X		pm->gets.afn = arrgetfn;
X	} else {
X		pm->u.val = (value) ? matheval(value) : 0;
X		pm->sets.ifn = intsetfn;
X		pm->gets.ifn = intgetfn;
X		sprintf(buf,"%ld",pm->u.val);
X		value = buf;
X	}
X	if (flags & PMFLAG_x)
X		pm->env = addenv(name,value);
X	addhnode(ztrdup(name),pm,paramtab,freepm);
X	return pm;
X}
X
Xint isident(s) /**/
Xchar *s;
X{
Xchar *ss;
X
X	for (ss = s; *ss; ss++) if (!iident(*ss)) break;
X	if (!*ss) return 1;
X	if (*ss != '[') return 0;
X	(void) mathevalarg(++ss, &ss);
X	if(*ss == ',' || *ss == Comma)
X		(void) mathevalarg(++ss,&ss);
X	if(*ss != ']' || ss[1]) return 0;
X	return 1;
X}
X
XValue getvalue(pptr,bracks) /**/
Xchar **pptr;int bracks;
X{
Xchar *s = *pptr,*t = *pptr;
Xchar sav;
XValue v;
X
X	if (idigit(*s)) while (idigit(*s)) s++;
X	else if (iident(*s)) while (iident(*s)) s++;
X	else if (*s == Quest) *s++ = '?';
X	else if (*s == Pound) *s++ = '#';
X	else if (*s == String) *s++ = '$';
X	else if (*s == Qstring) *s++ = '$';
X	else if (*s == Star) *s++ = '*';
X	else if (*s == '#' || *s == '-' || *s == '?' || *s == '$' ||
X				*s == '_' || *s == '!' || *s == '@' || *s == '*') s++;
X	else return NULL;
X	if (sav = *s) *s = '\0';
X	if (idigit(*t) && *t != '0') {
X		v = (Value) hcalloc(sizeof *v);
X		v->pm = argvparam;
X		v->a = v->b = atoi(t)-1;
X		if (sav)
X			*s = sav;
X	} else {
X		struct param *pm;
X		int isvarat = !strcmp(t, "@");
X
X		pm = gethnode(t,paramtab);
X		if (sav)
X			*s = sav;
X		*pptr = s;
X		if (!pm)
X			return NULL;
X		v = hcalloc(sizeof *v);
X		if (pmtype(pm) == PMFLAG_A)
X			v->isarr = isvarat ? -1 : 1;
X		v->pm = pm;
X		v->a = 0; v->b = -1;
X		if (bracks && (*s == '[' || *s == Inbrack)) {
X			int a,b;
X			char *olds = s,*t;
X
X			*s++ = '[';
X			for (t = s; *t && *t != ']' && *t != Outbrack; t++)
X				if (itok(*t))
X					*t = ztokens[*t-Pound];
X			if (*t == Outbrack)
X				*t = ']';
X			if ((s[0] == '*' || s[0] == '@')  && s[1] == ']') {
X				if (v->isarr) v->isarr = (s[0] == '*') ? 1 : -1;
X				v->a = 0;
X				v->b = -1;
X				s += 2;
X			} else {
X				a = mathevalarg(s,&s);
X				if (a > 0) a--;
X				if (*s == ',' || *s == Comma) {
X					s++;
X					b = mathevalarg(s,&s);
X					if (b > 0) b--;
X				} else
X					b = a;
X				if (*s == ']') {
X					s++;
X					if (v->isarr && a == b)
X						v->isarr = 0;
X					v->a = a;
X					v->b = b;
X				} else
X					s = olds;
X			}
X		}
X	}
X	if (!bracks && *s)
X		return NULL;
X	*pptr = s;
X	return v;
X}
X
Xchar *getstrvalue(v) /**/
XValue v;
X{
Xchar *s,**ss;
Xstatic char buf[20];
X
X	if (!v)
X		return "";
X	if (pmtype(v->pm) != PMFLAG_A) {
X		if ((pmtype(v->pm) == PMFLAG_i))
X			convbase(s = buf,v->pm->gets.ifn(v->pm),v->pm->ct);
X		else
X			s = v->pm->gets.cfn(v->pm);
X		if (v->a == 0 && v->b == -1) return s;
X		if (v->a < 0) v->a += strlen(s);
X		if (v->b < 0) v->b += strlen(s);
X		s = (v->a > strlen(s)) ? strdup("") : strdup(s+v->a);
X		if (v->b < v->a) s[0] = '\0';
X		else if (v->b-v->a < strlen(s)) s[v->b-v->a+1] = '\0';
X		return s;
X	}
X	if (v->isarr) return spacejoin(v->pm->gets.afn(v->pm));
X
X	ss = v->pm->gets.afn(v->pm);
X	if (v->a < 0) v->a += arrlen(ss);
X	s = (v->a >= arrlen(ss) || v->a < 0) ? "" : ss[v->a];
X	return s;
X}
X
Xchar **getarrvalue(v) /**/
XValue v;
X{
Xchar **s;
Xstatic char *nular[] = { "", NULL };
X
X	if (!v)
X		return arrdup(nular);
X	s = v->pm->gets.afn(v->pm);
X	if (v->a == 0 && v->b == -1) return s;
X	if (v->a < 0) v->a += arrlen(s);
X	if (v->b < 0) v->b += arrlen(s);
X	if (v->a > arrlen(s) || v->a < 0)
X		s = arrdup(nular);
X	else
X		s = arrdup(s)+v->a;
X	if (v->b < v->a) s[0] = NULL;
X	else if (v->b-v->a < arrlen(s)) s[v->b-v->a+1] = NULL;
X	return s;
X}
X
Xlong getintvalue(v) /**/
XValue v;
X{
Xchar **ss;
X
X	if (!v || v->isarr)
X		return 0;
X	if (pmtype(v->pm) != PMFLAG_A) {
X		if (pmtype(v->pm) == PMFLAG_i)
X			return v->pm->gets.ifn(v->pm);
X		return atol(v->pm->gets.cfn(v->pm));
X	}
X	ss = v->pm->gets.afn(v->pm);
X	if (v->a < 0) v->a += arrlen(ss);
X	if (v->a < 0 || v->a >= arrlen(ss)) return 0;
X	return atol(ss[v->a]);
X}
X
Xvoid setstrvalue(v,val) /**/
XValue v;char *val;
X{
X	if (v->pm->flags & PMFLAG_r) {
X		free(val);
X		return;
X	}
X	if (v->pm->env)
X		v->pm->env = replenv(v->pm->env,val);
X	else if (isset(ALLEXPORT)) {
X		v->pm->flags |= PMFLAG_x;
X		v->pm->env = addenv(v->pm->nam,val);
X	}
X	switch (pmtype(v->pm)) {
X		case PMFLAG_s:
X			if (v->a == 0 && v->b == -1)
X				(v->pm->sets.cfn)(v->pm,val);
X			else {
X				char *z,*y,*x;
X
X				z = strdup((v->pm->gets.cfn)(v->pm));
X				if (v->a < 0) {
X					v->a += strlen(z);
X					if (v->a < 0) v->a = 0;
X				}
X				if (v->a > strlen(z)) v->a = strlen(z);
X				if (v->b < 0) v->b += strlen(z);
X				if (v->b < v->a) v->b = v->a;
X				z[v->a] = '\0';
X				y = z+v->b+1;
X				x = zalloc(strlen(z)+strlen(y)+strlen(val)+1);
X				strcpy(x,z);
X				strcat(x,val);
X				strcat(x,y);
X				(v->pm->sets.cfn)(v->pm,x);
X			}
X			if (v->pm->flags & (PMFLAG_L|PMFLAG_R|PMFLAG_Z) && !v->pm->ct)
X				v->pm->ct = strlen(val);
X			break;
X		case PMFLAG_i:
X			(v->pm->sets.ifn)(v->pm,matheval(val));
X			if (!v->pm->ct && lastbase != 1)
X				v->pm->ct = lastbase;
X			free(val);
X			break;
X		case PMFLAG_A:
X			if (v->a != v->b)
X				zerr("illegal array assignment",NULL,0);
X			else {
X				char **ss = (v->pm->gets.afn)(v->pm);
X				int ac,ad,t0;
X
X				ac = arrlen(ss);
X				if (v->a < 0) {
X					v->a += ac;
X					if (v->a < 0) v->a = 0;
X				}
X				if (v->a >= ac) {
X					char **st = ss;
X
X					ad = v->a+1;
X					ss = zalloc((ad+1)*sizeof *ss);
X					for (t0 = 0; t0 != ac; t0++)
X						ss[t0] = ztrdup(st[t0]);
X					while (ac < ad)
X						ss[ac++] = ztrdup("");
X					ss[ac] = NULL;
X				}
X				if (ss[v->a]) free(ss[v->a]);
X				ss[v->a] = val;
X				(v->pm->sets.afn)(v->pm,ss);
X			}
X			break;
X	}
X}
X
Xvoid setintvalue(v,val) /**/
XValue v;long val;
X{
Xchar buf[20];
X
X	if (v->pm->flags & PMFLAG_r)
X		return;
X	sprintf(buf,"%ld",val);
X	if (v->pm->env) {
X		v->pm->env = replenv(v->pm->env,buf);
X	}
X	else if (isset(ALLEXPORT)) {
X		v->pm->flags |= PMFLAG_x;
X		v->pm->env = addenv(v->pm->nam,buf);
X	}
X	switch (pmtype(v->pm))
X		{
X		case PMFLAG_s:
X			(v->pm->sets.cfn)(v->pm,ztrdup(buf));
X			break;
X		case PMFLAG_i:
X			(v->pm->sets.ifn)(v->pm,val);
X			if (!v->pm->ct && lastbase != -1)
X				v->pm->ct = lastbase;
X			break;
X		case PMFLAG_A:
X			zerr("attempt to assign integer to array",NULL,0);
X			break;
X		}
X}
X
Xvoid setintenv(s,val) /**/
Xchar *s; long val;
X{
XParam pm;
Xchar buf[20];
X
X	if ((pm = gethnode(s,paramtab)) && pm->env) {
X		sprintf(buf,"%ld",val);
X		pm->env = replenv(pm->env,buf);
X	}
X}
X
Xvoid setarrvalue(v,val) /**/
XValue v;char **val;
X{
X	if (v->pm->flags & PMFLAG_r) {
X		freearray(val);
X		return;
X	}
X	if (pmtype(v->pm) != PMFLAG_A)
X		{
X		freearray(val);
X		zerr("attempt to assign array value to non-array",NULL,0);
X		return;
X		}
X	if (v->a == 0 && v->b == -1)
X		(v->pm->sets.afn)(v->pm,val);
X	else {
X		char **ss = (v->pm->gets.afn)(v->pm);
X		int ac,ad,t0;
X
X		ac = arrlen(ss);
X		if (v->a < 0) {
X			v->a += ac;
X			if (v->a < 0) v->a = 0;
X		}
X		if (v->b < 0) v->b += ac;
X		if (v->b < v->a) v->b = v->a;
X		t0 = arrlen(val) - (v->b - v->a + 1);
X		if (v->b >= ac || t0 != 0) {
X			char **st = ss;
X
X			ad = (v->b > (ac - 1) ? v->b : (ac - 1)) + t0 + 1;
X			ss = zalloc((ad+1)*sizeof *ss);
X			for (t0 = 0; t0 < v->a; t0++)
X				ss[t0] = ztrdup(t0 < ac ? st[t0] : "");
X			while (*val) ss[t0++] = *val++;
X			while (++v->b < ac) ss[t0++] = ztrdup(st[v->b]);
X			ss[t0] = NULL;
X		} else {
X			for (t0 = v->a; t0 <= v->b; t0++) {
X				if (ss[t0]) free(ss[t0]);
X				ss[t0] = val[t0];
X			}
X		}
X		(v->pm->sets.afn)(v->pm,ss);
X	}
X}
X
Xint getparamtype(s,l) /**/
Xchar *s;int l;
X{
Xchar sav,*t = s;
XValue v;
X
X	sav = t[l];
X	t[l] = '\0';
X
X	if (!(v = getvalue(&s,0)))
X		return -1;
X
X	t[l] = sav;
X	return (pmtype(v->pm));
X}
X
Xchar *getsparamval(s,l) /**/
Xchar *s;int l;
X{
Xchar sav,*t = s;
XValue v;
X
X	sav = t[l];
X	t[l] = '\0';
X	
X	if (!(v = getvalue(&s,0)))
X		return NULL;
X	t[l] = sav;
X	t = getstrvalue(v);
X	return t;
X}
X
Xlong getiparam(s) /**/
Xchar *s;
X{
XValue v;
X
X	if (!(v = getvalue(&s,0)))
X		return 0;
X	return getintvalue(v);
X}
X
Xchar *getsparam(s) /**/
Xchar *s;
X{
XValue v;
X
X	if (!(v = getvalue(&s,0)))
X		return NULL;
X	return getstrvalue(v);
X}
X
Xchar **getaparam(s) /**/
Xchar *s;
X{
XValue v;
X
X	if (!((v = getvalue(&s,0)) && v->isarr))
X		return NULL;
X	return getarrvalue(v);
X}
X
XParam setsparam(s,val) /**/
Xchar *s;char *val;
X{
XValue v;
Xchar *t = s;
Xchar *ss;
X
X	if (!isident(s)) {
X		zerr("not an identifier: %s",s,0);
X		free(val);
X		return NULL;
X	}
X	if (ss = strchr(s, '[')) {
X		*ss = '\0';
X		if (!(v = getvalue(&s,1)))
X			createparam(t,zcalloc(sizeof val),PMFLAG_A);
X		*ss = '[';
X		v = getvalue(&t,1);
X	} else {
X		if (!(v = getvalue(&s,1)))
X			return createparam(t,val,PMFLAG_s);
X		if ((v->pm->flags & PMTYPE) != PMFLAG_s &&
X				!(v->pm->flags & PMFLAG_SPECIAL)) {
X			unsetparam(t);
X			return createparam(t,val,PMFLAG_s);
X		}
X	}
X	setstrvalue(v,val);
X	return v->pm;
X}
X
XParam setaparam(s,val) /**/
Xchar *s;char **val;
X{
XValue v;
Xchar *t = s;
Xchar *ss;
X
X	if (!isident(s))
X		{
X		zerr("not an identifier: %s",s,0);
X		freearray(val);
X		return NULL;
X		}
X	if(ss = strchr(s, '[')) {
X		*ss = '\0';
X		if (!(v = getvalue(&s,1)))
X			createparam(t,zcalloc(sizeof val),PMFLAG_A);
X		*ss = '[';
X		v = getvalue(&t,1);
X	} else {
X		if (!(v = getvalue(&s,1)))
X			return createparam(t,val,PMFLAG_A);
X		if ((v->pm->flags & PMTYPE) != PMFLAG_A &&
X				!(v->pm->flags & PMFLAG_SPECIAL)) {
X			unsetparam(t);
X			return createparam(t,val,PMFLAG_A);
X		}
X	}
X	setarrvalue(v,val);
X	return v->pm;
X}
X
XParam setiparam(s,val) /**/
Xchar *s;long val;
X{
XValue v;
Xchar *t = s;
XParam pm;
X
X	if (!isident(s))
X		{
X		zerr("not an identifier: %s",s,0);
X		return NULL;
X		}
X	if (!(v = getvalue(&s,0)))
X		{
X		pm = createparam(t,NULL,PMFLAG_i);
X		pm->u.val = val;
X		return pm;
X		}
X	setintvalue(v,val);
X	return v->pm;
X}
X
Xvoid unsetparam(s) /**/
Xchar *s;
X{
XParam pm;
X
X	if (!(pm = gethnode(s,paramtab)))
X		return;
X	if (pm->flags & PMFLAG_r)
X		return;
X	unsetflag = 1;
X	switch (pmtype(pm))
X		{
X		case 0:
X			(pm->sets.cfn)(pm,ztrdup(""));
X			break;
X		case PMFLAG_i:
X			(pm->sets.ifn)(pm,0);
X			break;
X		case PMFLAG_A:
X			(pm->sets.afn)(pm,mkarray(NULL));
X			break;
X		}
X	if (pmtype(pm) == PMFLAG_s && (pm->flags & PMFLAG_x)) {
X		delenv(pm->env);
X		free(pm->env);
X		if (pm->flags & PMFLAG_SPECIAL)
X			pm->env = NULL;
X	}
X	if (!(pm->flags & PMFLAG_SPECIAL))
X		freepm(remhnode(s,paramtab));
X	unsetflag = 0;
X}
X
Xvoid intsetfn(pm,x) /**/
XParam pm;long x;
X{
X	pm->u.val = x;
X}
X
Xlong intgetfn(pm) /**/
XParam pm;
X{
X	return pm->u.val;
X}
X
Xvoid strsetfn(pm,x) /**/
XParam pm;char *x;
X{
X	if (x) 
X		{
X		if (pm->u.str)
X			free(pm->u.str);
X		pm->u.str = x;
X		}
X}
X
Xchar *strgetfn(pm) /**/
XParam pm;
X{
X	return pm->u.str;
X}
X
Xvoid nullsetfn(pm,x) /**/
XParam pm; char *x;
X{
X	free(x);
X}
X
Xvoid arrsetfn(pm,x) /**/
XParam pm;char **x;
X{
Xint ct;
X
X	if (x)
X		{
X		if (pm->u.arr && pm->u.arr != x)
X			freearray(pm->u.arr);
X		pm->u.arr = x;
X		for (ct = 0; *x; x++,ct++);
X		pm->ct = ct;
X		}
X}
X
Xchar **arrgetfn(pm) /**/
XParam pm;
X{
X	return pm->u.arr;
X}
X
Xvoid intvarsetfn(pm,x) /**/
XParam pm;long x;
X{
X	*((long *) pm->data) = x;
X}
X
Xlong intvargetfn(pm) /**/
XParam pm;
X{
X	return *((long *) pm->data);
X}
X
Xvoid strvarsetfn(pm,x) /**/
XParam pm;char *x;
X{
Xchar **q = ((char **) pm->data);
X
X	if (*q) free(*q);
X	*q = x;
X}
X
Xvoid strvarnonullsetfn(pm,x) /**/
XParam pm;char *x;
X{
Xchar **q = ((char **) pm->data);
X
X	if (*q) free(*q);
X	*q = (x) ? x : ztrdup("");
X}
X
Xchar *strvargetfn(pm) /**/
XParam pm;
X{
Xchar *s;
X
X	s = *((char **) pm->data);
X	if (!s) return "";
X	return s;
X}
X
Xchar *strconstgetfn(pm) /**/
XParam pm;
X{
X	return (char *) pm->data;
X}
X
Xvoid colonarrsetfn(pm,x) /**/
XParam pm;char *x;
X{
Xchar **s,**t,*u,*up;
X
X	s = colonsplit(x);
X	free(x);
X	if (pm->data != &fignore)
X		for (t = s; *t; t++) {
X			u = *t;
X			if (*u == '~') *u = Tilde;
X			if (*u == '=') *u = Equals;
X			up = hcalloc(strlen(u)+1);
X			strcpy(up,u);
X			u = up;
X			filesub(&u);
X			if (!*u) u = ".";
X			free(*t);
X			*t = ztrdup(u);
X		}
X	if (pm->data) {
X		freearray(*((char ***) pm->data));
X		*((char ***) pm->data) = s;
X		if (pm->ename)
X			arrfixenv(pm->ename,s);
X	} else {
X		freearray(path);
X		path = s;
X		newcmdnamtab();
X		arrfixenv("PATH",s);
X	}
X}
X
Xchar *colonarrgetfn(pm) /**/
XParam pm;
X{
X	if ((char **) pm->data)
X		return colonjoin(*(char ***) pm->data);
X	else
X		return colonjoin(path);
X}
X
Xchar **arrvargetfn(pm) /**/
XParam pm;
X{
X	return *((char ***) pm->data);
X}
X
Xvoid arrvarsetfn(pm,x) /**/
XParam pm;char **x;
X{
X	if ((*(char ***) pm->data) != x)
X		freearray(*(char ***) pm->data);
X	*((char ***) pm->data) = x;
X	if (pm->ename)
X		arrfixenv(pm->ename,x);
X}
X
Xchar **pathgetfn(pm) /**/
XParam pm;
X{
X	return path;
X}
X
Xvoid pathsetfn(pm,x) /**/
XParam pm;char **x;
X{
X	if (path != x) freearray(path);
X	path = x;
X	newcmdnamtab();
X	arrfixenv("PATH",x);
X}
X
Xvoid hostcmdssetfn(pm,x) /**/
XParam pm;char **x;
X{
X	compctl_process(x,CC_HOSTS,NULL);
X	freearray(x);
X}
X
Xvoid optcmdssetfn(pm,x) /**/
XParam pm;char **x;
X{
X	compctl_process(x,CC_OPTIONS,NULL);
X	freearray(x);
X}
X
Xvoid bindcmdssetfn(pm,x) /**/
XParam pm;char **x;
X{
X	compctl_process(x,CC_BINDINGS,NULL);
X	freearray(x);
X}
X
Xvoid varcmdssetfn(pm,x) /**/
XParam pm;char **x;
X{
X	compctl_process(x,CC_VARS,NULL);
X	freearray(x);
X}
X
Xchar **nullgetfn(pm) /**/
XParam pm;
X{
Xstatic char *nl = NULL; return &nl;
X}
X
Xvoid unsettablesetfn(pm,x) /**/
XParam pm;char *x;
X{ ; }
X
Xlong poundgetfn(pm) /**/
XParam pm;
X{
X	return arrlen(pparams);
X}
X
Xlong randomgetfn(pm) /**/
XParam pm;
X{
X	return rand() & 0x7fff;
X}
X
Xvoid randomsetfn(pm,v) /**/
XParam pm;long v;
X{
X	srand((unsigned int) v);
X}
X
Xlong secondsgetfn(pm) /**/
XParam pm;
X{
X	return time(NULL)-shtimer;
X}
X
Xvoid secondssetfn(pm,x) /**/
XParam pm;long x;
X{
X	shtimer = time(NULL)-x;
X}
X
Xlong uidgetfn(pm) /**/
XParam pm;
X{
X	return getuid();
X}
X
Xlong gidgetfn(pm) /**/
XParam pm;
X{
X	return getegid();
X}
X
Xchar *usernamegetfn(pm) /**/
XParam pm;
X{
Xstruct passwd *pwd;
X
X	pwd = getpwuid(getuid());
X	return pwd->pw_name;
X}
X
Xchar *hostgetfn(pm) /**/
XParam pm;
X{
Xstatic char hostnam[65];
Xstatic int got = 0;
X
X	if (!got)
X		{
X		gethostname(hostnam,64);
X		hostnam[64] = '\0';
X		got = 1;
X		}
X	return hostnam;
X}
X
Xchar *ifsgetfn(pm) /**/
XParam pm;
X{
X	return ifs;
X}
X
Xvoid ifssetfn(pm,x) /**/
XParam pm;char *x;
X{
X	if (x) { free(ifs); ifs = x; }
X	inittyptab();
X}
X
Xvoid histsizesetfn(pm,v) /**/
XParam pm;long v;
X{
X	if ((histsiz = v) <= 2) histsiz = 2;
X	resizehistents();
X}
X
Xlong histsizegetfn(pm) /**/
XParam pm;
X{
X	return histsiz;
X}
X
Xvoid lithistsizesetfn(pm,v) /**/
XParam pm;long v;
X{
X	if ((lithistsiz = v) <= 2) lithistsiz = 2;
X	resizehistents();
X}
X
Xlong lithistsizegetfn(pm) /**/
XParam pm;
X{
X	return lithistsiz;
X}
X
Xvoid mailchecksetfn(pm,x) /**/
XParam pm;long x;
X{
X	mailcheck = (unsetflag) ? 600 : x;
X}
X
Xvoid pathasetfn(pm,x) /**/
XParam pm;char **x;
X{
X	freearray(path);
X	path = x;
X	newcmdnamtab();
X}
X
Xchar **pathagetfn(pm) /**/
XParam pm;
X{
X	return path;
X}
X
Xlong errnogetfn(pm) /**/
XParam pm;
X{
X	return errno;
X}
X
Xchar *dashgetfn(pm) /**/
XParam pm;
X{
Xstatic char buf[100];
Xchar *val;
Xint t0;
X
X	for (val = buf, t0 = ' ';t0 <= 'z'; t0++)
X		if (isset(t0))
X			*val++ = t0;
X	*val = '\0';
X	return buf;
X}
X
Xvoid histcharssetfn(pm,x) /**/
XParam pm;char *x;
X{
X	if (x) {
X		bangchar = x[0];
X		hatchar = (bangchar) ? x[1] : '\0';
X		hashchar = (hatchar) ? x[2] : '\0';
X		free(x);
X	}
X}
X
Xchar *histcharsgetfn(pm) /**/
XParam pm;
X{
Xstatic char buf[4];
X
X	buf[0] = bangchar;
X	buf[1] = hatchar;
X	buf[2] = hashchar;
X	buf[3] = '\0';
X	return buf;
X}
X
Xchar *homegetfn(pm) /**/
XParam pm;
X{
X	return home;
X}
X
Xvoid homesetfn(pm,x) /**/
XParam pm;char *x;
X{
X	free(home);
X	if (isset(CHASELINKS) && (home = xsymlink(x))) free(x);
X	else home = x;
X}
X
Xchar *wordcharsgetfn(pm) /**/
XParam pm;
X{
X	return wordchars;
X}
X
Xvoid wordcharssetfn(pm,x) /**/
XParam pm;char *x;
X{
X	free(wordchars);
X	if (x) wordchars = x;
X	else wordchars = ztrdup(DEFWORDCHARS);
X	inittyptab();
X}
X
Xchar *underscoregetfn(pm) /**/
XParam pm;
X{
Xchar *s,*t;
X
X	if (!(s = qgetevent(curhist-1)))
X		return "";
X	for (t = s+strlen(s); t > s; t--)
X		if (*t == HISTSPACE)
X			break;
X	if (t != s)
X		t++;
X	return t;
X}
X
Xchar *termgetfn(pm) /**/
XParam pm;
X{
X	return term;
X}
X
Xvoid termsetfn(pm,x) /**/
XParam pm;char *x;
X{
X	if (term) free(term);
X	term = x;
X	if (!interact || unset(USEZLE))
X		return;
X	if (tgetent(termbuf,term) != 1)
X		{
X		zerr("can't find termcap info for %s",term,0);
X		errflag = 0;
X		termok = 0;
X		}
X	else
X		{
X		char tbuf[1024],*pp;
X		int t0;
X
X		termok = 1;
X		for (t0 = 0; t0 != TC_COUNT; t0++)
X			{
X			pp = tbuf;
X			if (tcstr[t0])
X				free(tcstr[t0]);
X			/* AIX tgetstr() ignores second argument */
X			if (!(pp = tgetstr(tccapnams[t0],&pp)))
X				tcstr[t0] = NULL, tclen[t0] = 0;
X			else
X				{
X				tcstr[t0] = zalloc(tclen[t0] = strlen(pp)+1);
X				memcpy(tcstr[t0],pp,tclen[t0]);
X				}
X			}
X
X/* if there's no termcap entry for cursor left, use \b. */
X
X		if (!tccan(TCLEFT))
X			{
X			tcstr[TCLEFT] = ztrdup("\b");
X			tclen[TCLEFT] = 1;
X			}
X
X/* if there's no termcap entry for clear, use ^L. */
X
X		if (!tccan(TCCLEARSCREEN))
X			{
X			tcstr[TCCLEARSCREEN] = ztrdup("\14");
X			tclen[TCCLEARSCREEN] = 1;
X			}
X
X/* if the termcap entry for down is \n, don't use it. */
X
X		if (tccan(TCDOWN) && tcstr[TCDOWN][0] == '\n')
X			{
X			tclen[TCDOWN] = 0;
X			free(tcstr[TCDOWN]);
X			tcstr[TCDOWN] = NULL;
X			}
X
X/* if there's no termcap entry for cursor up, forget it.
X	Use single line mode. */
X
X		if (!tccan(TCUP))
X			termok = 0;
X		}
X}
X
Xvoid setparams() /**/
X{
Xchar **envp,**envp2,**envp3,*str;
Xchar buf[50];
Xstruct param *pm;
Xint ct;
X
X	noerrs = 1;
X	for (envp = environ, ct = 2; *envp; envp++,ct++);
X	envp = environ;
X	envp2 = envp3 = (char **) zalloc(sizeof(char *)*ct);
X	for (; *envp; envp++)
X		*envp2++ = ztrdup(*envp);
X	*envp2 = NULL;
X	envp = environ;
X	environ = envp2 = envp3;
X	for (; *envp; envp++,envp2++) {
X		for (str = *envp; *str && *str != '='; str++);
X		if (*str == '=') {
X			char *iname = NULL;
X
X			*str = '\0';
X			pm = (isident(*envp) && !strchr(*envp, '[')) ?
X				setsparam(iname = *envp,ztrdup(str+1)) : NULL;
X			if (pm) {
X				pm->flags |= PMFLAG_x;
X				pm->env = *envp2;
X				if (pm->flags & PMFLAG_SPECIAL)
X					pm->env = replenv(pm->env,getsparam(iname));
X			}
X			*str = '=';
X		}
X	}
X	pm = gethnode("HOME",paramtab);
X	if (!(pm->flags & PMFLAG_x)) {
X		pm->flags |= PMFLAG_x;
X		pm->env = addenv("HOME",home);
X	}
X	pm = gethnode("PWD",paramtab);
X	if (!(pm->flags & PMFLAG_x)) {
X		pm->flags |= PMFLAG_x;
X		pm->env = addenv("PWD",pwd);
X	}
X	pm = gethnode("LOGNAME",paramtab);
X	if (!(pm->flags & PMFLAG_x)) {
X		pm->flags |= PMFLAG_x;
X		pm->env = addenv("LOGNAME",logname);
X	}
X	pm = gethnode("SHLVL",paramtab);
X	if (!(pm->flags & PMFLAG_x))
X		pm->flags |= PMFLAG_x;
X	sprintf(buf,"%d",++shlvl);
X	pm->env = addenv("SHLVL",buf);
X	noerrs = 0;
X}
X
Xchar *mkenvstr(x,y) /**/
Xchar *x;char *y;
X{
Xchar *z;
Xint xl = strlen(x),yl = strlen(y);
X
X	z = zalloc(xl+yl+2);
X	strcpy(z,x);
X	z[xl] = '=';
X	strcpy(z+xl+1,y);
X	z[xl+yl+1] = '\0';
X	return z;
X}
X
Xvoid arrfixenv(s,t) /**/
Xchar *s;char **t;
X{
Xchar **ep;
Xint sl = strlen(s);
X
X	for (ep = environ; *ep; ep++)
X		if (!strncmp(*ep,s,sl) && (*ep)[sl] == '=') {
X			char *u = colonjoin(t);
X			replenv(*ep,u);
X			break;
X		}
X}
X
Xchar *replenv(e,value) /**/
Xchar *e;char *value;
X{
Xchar **ep;
X
X	for (ep = environ; *ep; ep++)
X		if (*ep == e)
X			{
X			char *s = e;
X
X			while (*s++ != '=');
X			*s = '\0';
X			*ep = zalloc(strlen(e)+strlen(value)+2);
X			strcpy(*ep,e);
X			strcat(*ep,value);
X			free(e);
X			return *ep;
X			}
X	return NULL;
X}
X
Xchar *addenv(name,value) /**/
Xchar *name;char *value;
X{
Xchar **ep,**ep2,**ep3;
Xint envct;
X
X	for (ep = environ; *ep; ep++)
X		{
X		char *s = *ep,*t = name;
X
X		while (*s && *s == *t) s++,t++;
X		if (*s == '=' && !*t)
X			{
X			free(*ep);
X			return *ep = mkenvstr(name,value);
X			}
X		}
X	envct = arrlen(environ);
X	ep = ep2 = (char **) zalloc((sizeof (char *))*(envct+3));
X	for (ep3 = environ; *ep2 = *ep3; ep3++,ep2++);
X	*ep2 = mkenvstr(name,value);
X	ep2[1] = NULL;
X	free(environ);
X	environ = ep;
X	return *ep2;
X}
X
Xvoid delenv(x) /**/
Xchar *x;
X{
Xchar **ep;
X
X	ep = environ;
X	for (; *ep; ep++)
X		if (*ep == x)
X			break;
X	if (*ep)
X		for (; ep[0] = ep[1]; ep++);
X}
X
Xvoid convbase(s,v,base) /**/
Xchar *s;long v;int base;
X{
Xint digs = 0;
Xlong x;
X
X	if (base <= 1)
X		base = 10;
X	x = v;
X	if (x < 0)
X		{
X		x = -x;
X		digs++;
X		}
X	for (; x; digs++)
X		x /= base;
X	if (!digs)
X		digs = 1;
X	s[digs--] = '\0';
X	x = (v < 0) ? -v : v;
X	while (digs >= 0)
X		{
X		int dig = x%base;
X		s[digs--] = (dig < 10) ? '0'+dig : dig-10+'A';
X		x /= base;
X		}
X	if (v < 0)
X		s[0] = '-';
X}
END_OF_FILE
  if test 26353 -ne `wc -c <'src/params.c'`; then
    echo shar: \"'src/params.c'\" unpacked with wrong size!
  fi
  # end of 'src/params.c'
fi
echo shar: End of archive 1 \(of 22\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
