Newsgroups: comp.sources.misc
From: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Subject: v35i065:  zsh - The Z Shell, version 2.3.1, Part15/22
Message-ID: <1993Feb20.212627.29125@sparky.imd.sterling.com>
X-Md4-Signature: 8665e41aee9765e7da349210419eafd3
Date: Sat, 20 Feb 1993 21:26:27 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zsh-list@cs.uow.edu.au (The Zsh Mailing List)
Posting-number: Volume 35, Issue 65
Archive-name: zsh/part15
Environment: UNIX
Supersedes: zsh2.2: Volume 29, Issue 97-113

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  help/bindkey help/unalias help/unsetopt src/parse.c
# Wrapped by mattson@odin on Sat Feb  6 14:41:54 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 15 (of 22)."'
if test -f 'help/bindkey' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/bindkey'\"
else
  echo shar: Extracting \"'help/bindkey'\" \(19763 characters\)
  sed "s/^X//" >'help/bindkey' <<'END_OF_FILE'
X     bindkey -mevd
X     bindkey -r in-string ...
X     bindkey [ -a ] in-string [ command ] ...
X     bindkey -s [ -a ] in-string out-string ...
X          If one of the -e, -v, or -d options is given, reset the
X          keymaps  for  emacs mode, vi mode, or the default mode,
X          respectively; if the -m option is also given, allow the
X          use  of  a meta key.  If the -r option is given, remove
X          any binding for each in-string.  If the  -s  option  is
X          not  specified, bind each in-string to a specified com-
X          mand.  If no command is specified, print the binding of
X          in-string if it is bound, or return a nonzero exit code
X          if it is not bound.  If the  -s  option  is  specified,
X          bind each in-string to each specified out-string.  When
X          in-string is typed, out-string will be pushed back  and
X          treated  as input to the line editor.  If the -a option
X          is specified, bind the in-strings  in  the  alternative
X          keymap  instead  of  the standard one.  The alternative
X          keymap is used in vi command mode.
X
X          For either in-string or out-string, control  characters
X          may  be specified in the form ^X, and the backslash may
X          be used  to  introduce  one  of  the  following  escape
X          sequences:
X               \a   bell character
X               \n   linefeed (newline)
X               \b   backspace
X               \t   horizontal tab
X               \v   vertical tab
X               \f   form feed
X               \r   carriage return
X               \e   escape
X               \nnn character code in octal
X               \M-xxx
X                    character or escape sequence  with  meta  bit
X                    set
X
X          In all other cases, \ escapes the following  character.
X          Delete is written as `^?'.
X
X     vi-backward-blank-word (unbound) (B)
X          Move backward one word, where a word is  defined  as  a
X          series of non-blank characters.
X
X     backward-char (^B ESC-[D) ()
X          Move backward one character.
X
X     vi-backward-char () (h)
X          Move backward one character, without changing lines.
X
X     backward-word (ESC-B ESC-b) (unbound)
X          Move to the beginning of the previous word.
X
X     emacs-backward-word
X          Move to the beginning of the previous word.
X
X     vi-backward-word (unbound) (b)
X          Move to the beginning of the previous word, vi-style.
X
X     beginning-of-line (^A) (0)
X          Move to the beginning of the line.  If already  at  the
X          beginning  of  the  line,  move to the beginning of the
X          previous line, if any.
X
X     vi-beginning-of-line
X          Move to the beginning of  the  line,  without  changing
X          lines.
X
X     end-of-line (^E)
X          Move to the end of the line.  If already at the end  of
X          the line, move to the end of the next line, if any.
X
X     vi-end-of-line (unbound) ($)
X          Move to the end of the line.
X
X     vi-forward-blank-word (unbound) (W)
X          Move forward one word, where a word  is  defined  as  a
X          series of non-blank characters.
X
X     vi-forward-blank-word-end (unbound) (E)
X          Move to the end of the current word, or, if at the  end
X          of the current word, to the end of the next word, where
X          a word is defined as a series of non-blank characters.
X
X     forward-char (^F ESC-[C)
X          Move forward one character.
X
X     vi-forward-char (unbound) (space l)
X          Move forward one character.
X
X     vi-find-next-char (^X^F) (f)
X          Read a character from the keyboard,  and  move  to  the
X          next occurrence of it in the line.
X
X     vi-find-next-char-skip (unbound) (t)
X          Read a character from the keyboard,  and  move  to  the
X          position  just  before the next occurrence of it in the
X          line.
X
X     vi-find-prev-char (unbound) (F)
X          Read a character from the keyboard,  and  move  to  the
X          previous occurrence of it in the line.
X
X     vi-find-prev-char-skip (unbound) (T)
X          Read a character from the keyboard,  and  move  to  the
X          position  just  after  the previous occurrence of it in
X          the line.
X
X     vi-first-non-blank (unbound) (^)
X          Move to the first non-blank character in the line.
X
X     vi-forward-word (unbound) (w)
X          Move forward one word, vi-style.
X
X     forward-word (ESC-F ESC-f) (unbound)
X          Move to the beginning of the next word.   The  editor's
X          idea  of a word is specified with the WORDCHARS parame-
X          ter.
X
X     emacs-forward-word
X          Move to the end of the next word.
X
X     vi-forward-word-end (unbound) (e)
X          Move to the end of the next word.
X
X     vi-goto-column (ESC-|) (|)
X          Move to the column specified by the numeric argument.
X
X     vi-goto-mark (unbound) (`)
X          Move to the specified mark.
X
X     vi-goto-mark-line (unbound) (')
X          Move to beginning of the line containing the  specified
X          mark.
X
X     vi-repeat-find (unbound) (;)
X          Repeat the last vi-find command.
X
X     vi-rev-repeat-find (unbound) (,)
X          Repeat the last vi-find command in the opposite  direc-
X          tion.
X
X     beginning-of-buffer-or-history (ESC-<)
X          Move to the beginning of  the  buffer,  or  if  already
X          there, move to the first event in the history list.
X
X     beginning-of-line-hist
X          Move to the beginning of the line.  If already  at  the
X          beginning  of  the buffer, move to the previous history
X          line.
X
X     beginning-of-history
X          Move to the first event in the history list.
X
X     down-line-or-history (^N ESC-[B) (+ j)
X          Move down a line in the buffer, or if  already  at  the
X          bottom  line,  move  to  the  next event in the history
X          list.
X
X     down-line-or-search
X          Move down a line in the buffer, or if  already  at  the
X          bottom  line,  search forward in the history for a line
X          beginning with the first word in the buffer.
X
X     down-history (unbound) (^N)
X          Move to the next event in the history list.
X
X     end-of-buffer-or-history (ESC->)
X          Move to the end of the buffer,  or  if  already  there,
X          move to the last event in the history list.
X
X     end-of-line-hist
X          Move to the end of the line.  If already at the end  of
X          the buffer, move to the next history line.
X
X     end-of-history
X          Move to the last event in the history list.
X
X     vi-fetch-history (unbound) (G)
X          Fetch the history line specified by the  numeric  argu-
X          ment.
X
X     history-incremental-search-backward (^R ^Xr)
X          Search backward incrementally for a  specified  string.
X          The  string  may begin with `^' to anchor the search to
X          the beginning of the line.
X
X     history-incremental-search-forward (^Xs)
X          Search forward incrementally for  a  specified  string.
X          The  string  may begin with `^' to anchor the search to
X          the beginning of the line.
X
X     history-search-backward (ESC-P ESC-p) (K)
X          Search backward in the history  for  a  line  beginning
X          with the first word in the buffer.
X
X     vi-history-search-backward (unbound) (/)
X          Search backward in the history for a specified  string.
X          The  string  may begin with `^' to anchor the search to
X          the beginning of the line.
X
X     history-search-forward (ESC-N ESC-n) (J)
X          Search forward in the history for a line beginning with
X          the first word in the buffer.
X
X     vi-history-search-forward (unbound) (?)
X          Search forward in the history for a  specified  string.
X          The  string  may begin with `^' to anchor the search to
X          the beginning of the line.
X
X     infer-next-history (^X^N)
X          Search in the history list  for  a  line  matching  the
X          current one and fetch the event following it.
X
X     insert-last-word (ESC-_ ESC-.)
X          Insert the last word from the previous history event at
X          the cursor position.
X
X     vi-repeat-search (unbound) (n)
X          Repeat the last vi history search.
X
X     vi-rev-repeat-search (unbound) (N)
X          Repeat the last vi history search, but in reverse.
X
X     toggle-literal-history (ESC-R ESC-r)
X          Toggle  between  literal  and  lexical  history.    The
X          default is lexical history unless the HISTLIT option is
X          set.
X
X     up-line-or-history (^P ESC-[A) (- k)
X          Move up a line in the buffer, or if already at the  top
X          line, move to the previous event in the history list.
X
X     up-line-or-search
X          Move up a line in the buffer, or if already at the  top
X          line,  search backward in the history for a line begin-
X          ning with the first word in the buffer.
X
X     up-history (unbound) (^P)
X          Move to the previous event in the history list.
X
X     vi-add-eol (unbound) (A)
X          Move to the end of the line and enter insert mode.
X
X     vi-add-next (unbound) (a)
X          Move forward one character and enter insert mode.
X
X     backward-delete-char (^H ^?) (^?)
X          Delete the character behind the cursor.
X
X     vi-backward-delete-char (unbound) (X)
X          Delete the character behind the cursor, without  chang-
X          ing lines.
X
X     backward-delete-word
X          Delete the word behind the cursor.
X
X     backward-kill-line
X          Kill from the beginning of the line to the cursor posi-
X          tion.
X
X     backward-kill-word (^W ESC-^H ESC-^?)
X          Kill the word behind the cursor.
X
X     vi-backward-kill-word (unbound) (^W)
X          Kill the word behind the cursor.
X
X     capitalize-word (ESC-C ESC-c)
X          Capitalize the current word and move past it.
X
X     vi-change (unbound) (c)
X          Read a movement command from  the  keyboard,  and  kill
X          from  the  cursor position to the endpoint of the move-
X          ment.  Then enter insert mode.  If the command  is  vi-
X          change, kill the current line.
X
X     vi-change-eol (unbound) (C)
X          Kill to the end of the line and enter insert mode.
X
X     vi-change-whole-line (unbound) (S s)
X          Kill the current line and enter insert mode.
X
X     copy-region-as-kill (ESC-W ESC-w)
X          Copy the area from the cursor to the mark to  the  kill
X          buffer.
X
X     copy-prev-word (ESC-^_)
X          Duplicate the word behind the cursor.
X
X     vi-delete (unbound) (d)
X          Read a movement command from  the  keyboard,  and  kill
X          from  the  cursor position to the endpoint of the move-
X          ment.  If the command is vi-delete,  kill  the  current
X          line.
X
X     delete-char (unbound) (x)
X          Delete the character under the cursor.
X
X     vi-delete-char (unbound) (x)
X          Delete the character under the cursor.
X
X     delete-word (ESC-D ESC-d)
X          Delete the current word.
X
X     down-case-word (ESC-L ESC-l)
X          Convert the current word to all lowercase and move past
X          it.
X
X     kill-word
X          Kill the current word.
X
X     gosmacs-transpose-chars
X          Exchange the two characters behind the cursor.
X
X     vi-indent (unbound) (>)
X          Indent a number of lines.
X
X     vi-insert (unbound) (i)
X          Enter insert mode.
X
X     vi-insert-bol (unbound) (I)
X          Move to the beginning of  the  line  and  enter  insert
X          mode.
X
X     vi-join (^X^J)
X          Join the current line with the next one.
X
X     kill-line (^K) (D)
X          Kill from the cursor to the end of the line.
X
X     kill-region
X          Kill from the cursor to the mark.
X
X     kill-buffer (^X^U) (^U)
X          Kill the entire buffer.
X
X     kill-whole-line (^U) (unbound)
X          Kill the current line.
X
X     vi-match-bracket (^X^B) (%)
X          Move to the bracket character (one of {},  (),  or  [])
X          that matches the one under the cursor.
X
X     vi-open-line-above (unbound) (O)
X          Open a line above the cursor and enter insert mode.
X
X     vi-open-line-below (unbound) (o)
X          Open a line below the cursor and enter insert mode.
X
X     vi-oper-swap-case
X          Read a movement command from the keyboard, and swap the
X          case  of all characters from the cursor position to the
X          endpoint of the movement.  If the movement  command  is
X          vi-oper-swap-case,  swap  the case of all characters on
X          the current line.
X
X     overwrite-mode (^X^O)
X          Toggle between overwrite mode and insert mode.
X
X     vi-put-after (unbound) (p)
X          Insert the contents of the kill buffer after  the  cur-
X          sor.
X
X     quoted-insert (^V)
X          Insert  the  next  character  typed  into  the   buffer
X          literally.
X
X     quote-line (ESC-')
X          Quote the current line; that is, put a '  character  at
X          the beginning and the end, and convert all ' characters
X          to '\''.
X
X     quote-region (ESC-")
X          Quote the region from the cursor to the mark.
X
X     vi-replace (unbound) (R)
X          Enter overwrite mode.
X
X     vi-repeat-change (unbound) (.)
X          Repeat the last vi mode text modification.
X
X     vi-replace-chars (unbound) (r)
X          Replace the character under the cursor with a character
X          read from the keyboard.
X
X     self-insert (printable characters)
X          Put a character in the buffer at the cursor position.
X
X     self-insert-unmeta (ESC-^I ESC-^J ESC-^M)
X          Put a character in the buffer after stripping the  meta
X          bit and converting ^M to ^J.
X
X     vi-substitute (unbound) (s)
X          Substitute the next character(s).
X
X     vi-swap-case (unbound) (~)
X          Swap the case of the character  under  the  cursor  and
X          move past it.
X
X     transpose-chars (^T)
X          Exchange the two characters to the left of  the  cursor
X          if  at  end  of line, else exchange the character under
X          the cursor with the character to the left.
X
X     transpose-words (ESC-T ESC-t)
X          Exchange the current word with the one before it.
X
X     vi-unindent (unbound) (<)
X          Unindent a number of lines.
X
X     up-case-word (ESC-U ESC-u)
X          Convert the current word to all caps and move past it.
X
X     yank (^Y) (P)
X          Insert the contents of the kill buffer  at  the  cursor
X          position.
X
X     yank-pop (ESC-y) (unbound)
X          Remove the text just yanked, rotate the kill-ring,  and
X          yank  the  new top.  Only works following yank or yank-
X          pop.
X
X     vi-yank (unbound) (y)
X          Read a movement command from the keyboard, and copy the
X          region  from the cursor position to the endpoint of the
X          movement into the kill buffer.  If the command  is  vi-
X          yank, copy the current line.
X
X     vi-yank-eol (unbound) (Y)
X          Copy the region from the cursor position to the end  of
X          the line into the kill buffer.
X
X     digit-argument (ESC-0..ESC-9) (0-9)
X          Start a new numeric argument, or  add  to  the  current
X          one.
X
X     universal-argument
X          Multiply the argument of the next command by 4.
X
X     accept-and-menu-complete
X          In a menu completion,  insert  the  current  completion
X          into  the buffer, and advance to the next possible com-
X          pletion.
X
X     complete-word (unbound) (\)
X          Attempt completion on the current word.
X
X     delete-char-or-list (^D)
X          Delete the character under the cursor.  If  the  cursor
X          is  at  the  end of the line, list possible completions
X          for the current word.
X
X     execute-named-cmd (ESC-x)
X          Read the name of a editor command and execute it.
X
X     execute-last-named-cmd (ESC-z)
X          Redo the last function executed with execute-named-cmd.
X
X     expand-cmd-path
X          Expand the current command to its full pathname.
X
X     expand-or-complete (TAB) (TAB ^X)
X          Attempt shell expansion on the current word.   If  that
X          fails, attempt completion.
X
X     expand-history (ESC-space ESC-!)
X          Perform history expansion on the edit buffer.
X
X     expand-word (^X*)
X          Attempt shell expansion on the current word.
X
X     list-choices (ESC-^D) (^D =)
X          List possible completions for the current word.
X
X     list-expand (^Xg ^XG) (^G)
X          List the expansion of the current word.
X
X     magic-space
X          Perform history expansion and insert a space  into  the
X          buffer.  This is intended to be bound to space.
X
X     menu-complete
X          Like complete-word,  except  that  menu  completion  is
X          used.  See the MENU_COMPLETE option below.
X
X     menu-expand-or-complete
X          Like expand-or-complete, except that menu completion is
X          used.
X
X     reverse-menu-complete
X          See the MENU_COMPLETE option below.
X
X     accept-and-hold (ESC-A ESC-a)
X          Push the contents of the buffer on the buffer stack and
X          execute it.
X
X     accept-and-infer-next-history
X          Execute the contents of the buffer.   Then  search  the
X          history  list  for  a line matching the current one and
X          push the event following onto the buffer stack.
X
X     accept-line (^J ^M)
X          Execute the contents of the buffer.
X
X     accept-line-and-down-history (^O)
X          Execute the current line, and  push  the  next  history
X          event on the the buffer stack.
X
X     vi-cmd-mode (^X^V) (^[)
X          Enter command mode; that is, use the alternate  keymap.
X          Yes, this is bound by default in emacs mode.
X
X     vi-caps-lock-panic (unbound) (H K)
X          Hang until any lowercase key is pressed.  This  is  for
X          vi  users  without the mental capacity to keep track of
X          their caps lock key (like the author).
X
X     clear-screen (^L ESC-^L)
X          Clear the screen and redraw the prompt.
X
X     exchange-point-and-mark (^X^X)
X          Exchange the cursor position with the position  of  the
X          mark.
X
X     get-line (ESC-G ESC-g)
X          Pop the top line off the buffer stack and insert it  at
X          the cursor position.
X
X     pound-insert (unbound) (#)
X          If there is no # character  at  the  beginning  of  the
X          current line, add one.  If there is one, remove it.  In
X          either   case,   accept   the   current   line.     The
X          INTERACTIVE_COMMENTS  option  must  be  set for this to
X          have any usefulness.
X
X     push-line (^Q ESC-Q ESC-q)
X          Push the current buffer onto the buffer stack and clear
X          the buffer.  Next time the editor starts up, the buffer
X          will be popped off the top  of  the  buffer  stack  and
X          loaded into the editing buffer.
X
X     redisplay (unbound) (^R)
X          Redisplays the edit buffer.
X
X     run-help (ESC-H ESC-h)
X          Push the buffer onto the buffer stack, and execute  the
X          command  "run-help  cmd", where cmd is the current com-
X          mand.  run-help is normally aliased to man.
X
X     send-break (^C)
X          Abort the parsing of the current line.
X
X     vi-set-buffer (unbound) (")
X          Specify a buffer to be used in the following command.
X
X     vi-set-mark (unbound) (m)
X          Set the specified mark at the cursor position.
X
X     set-mark-command (^@)
X          Set the mark at the cursor position.
X
X     spell-word (ESC-$ ESC-S ESC-s)
X          Attempt spelling correction on the current word.
X
X     undefined-key
X          Beep.
X
X     undo (^_ ^X^U) (u)
X          Incrementally undo the last text modification.
X
X     which-command (ESC-?)
X          Push the buffer onto the buffer stack, and execute  the
X          command  "which-command  cmd", where cmd is the current
X          command.  which-command is normally aliased to whence.
END_OF_FILE
  if test 19763 -ne `wc -c <'help/bindkey'`; then
    echo shar: \"'help/bindkey'\" unpacked with wrong size!
  fi
  # end of 'help/bindkey'
fi
if test -f 'help/unalias' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/unalias'\"
else
  echo shar: Extracting \"'help/unalias'\" \(781 characters\)
  sed "s/^X//" >'help/unalias' <<'END_OF_FILE'
X     alias [ -g ] [ name[=value] ] ...
X          With no arguments, print the list  of  aliases  in  the
X          form  name=value on the standard output.  For each name
X          with a corresponding value, define an alias  with  that
X          value.   A trailing space in value causes the next word
X          to be checked for alias substitution.  If the  -g  flag
X          is  present,  define a global alias; global aliases are
X          expanded even if they do not occur in command position.
X          For  each  name with no value, print the value of name,
X          if any.  The exit status is nonzero if a name (with  no
X          value) given for which no alias has been defined.
X     unalias name ...
X          The alias definition, if any, for each name is removed.
END_OF_FILE
  if test 781 -ne `wc -c <'help/unalias'`; then
    echo shar: \"'help/unalias'\" unpacked with wrong size!
  fi
  # end of 'help/unalias'
fi
if test -f 'help/unsetopt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/unsetopt'\"
else
  echo shar: Extracting \"'help/unsetopt'\" \(11726 characters\)
  sed "s/^X//" >'help/unsetopt' <<'END_OF_FILE'
X     setopt [ +-options ] [ name ... ]
X          Set the options for the shell.  All  options  specified
X          either  with flags or by name are set.  If no arguments
X          are supplied, the names of all  options  currently  set
X          are  printed.   In option names, case is insignificant,
X          and all underscore characters are ignored.
X     unsetopt [ +-options ] [ name ... ]
X          Unset the options for the shell.  All options specified
X          either with flags or by name are unset.
X
X     The following options may be  set  upon  invocation  of  the
X     shell, or with the set or setopt builtins:
X          ALLEXPORT (-a)
X               All parameters subsequently defined are  automati-
X               cally exported.
X          AUTO_CD (-J)
X               If a command is not in the hash table,  and  there
X               exists  an executable directory by that name, per-
X               form the cd command to that directory.
X          AUTOLIST (-9)
X               Automatically list choices on an ambiguous comple-
X               tion.
X          AUTOMENU
X               Automatically use menu completion if the  TAB  key
X               is pressed repeatedly.
X          AUTO_PUSHD (-N)
X               Make cd act like pushd.
X          AUTO_RESUME (-W)
X               Treat single word simple commands without redirec-
X               tion  as  candidates for resumption of an existing
X               job.
X          BGNICE (-6)
X               Run all background jobs at a lower priority.  This
X               option is set by default.
X          BRACECCL
X               Allow brace expansions of the form {a-zA-Z}, etc.
X          CDABLEVARS (-T)
X               If the argument to a cd command is  not  a  direc-
X               tory,  but  a  parameter  exists  by the same name
X               whose value begins with a /, try to change to  the
X               directory specified by the parameter's value.
X          CHASELINKS (-w)
X               Resolve symbolic links to their true values.
X          CORRECT (-0)
X               Try to correct the spelling of commands.
X          CORRECT_ALL (-O)
X               Try to correct the spelling of all arguments in  a
X               line.
X          CSH_JUNKIE_LOOPS
X               Allow loop bodies to take  the  form  "list;  end"
X               instead of "do list; done".
X          CSH_JUNKIE_QUOTES
X               Complain if a quoted expression runs off  the  end
X               of  a  line;  prevent quoted expressions from con-
X               taining unescaped newlines.
X          CSH_NULL_GLOB
X               If  a  pattern  for  filename  generation  has  no
X               matches,  delete  the  pattern  from  the argument
X               list; do not report an error unless all  the  pat-
X               terns  in  a  command  have no matches.  Overrides
X               NULLGLOB.
X          ERREXIT (-e)
X               If a command has a non-zero exit  status,  execute
X               the ERR trap, if set, and exit.
X          EXTENDED_GLOB
X               Treat the # and ^ characters as part  of  patterns
X               for filename generation, etc.
X          GLOB_COMPLETE
X               Like MENU_COMPLETE, except that the  current  word
X               is  expanded  using normal shell expansion instead
X               of completion.  If no matches are found,  a  *  is
X               added  to  the  end  of the word, and expansion is
X               attempted again.
X          GLOB_DOTS (-4)
X               Do not require a leading . in  a  filename  to  be
X               matched explicitly.
X          HASH_CMDS
X               Place the location of each  command  in  the  hash
X               table  the  first  time  it  is executed.  If this
X               option is unset, no path hashing will be  done  at
X               all.
X          HASH_DIRS
X               Whenever a command is executed, hash the directory
X               containing  it,  as  well  as all directories that
X               occur earlier in  the  path.   Has  no  effect  if
X               HASH_CMDS is unset.
X          HASH_LIST_ALL
X               Whenever a command completion is  attempted,  make
X               sure  the  entire  command  path  is hashed first.
X               This makes the first completion slower.
X          HIST_IGNORE_DUPS (-h)
X               Do not enter command lines into the  history  list
X               if they are duplicates of the previous event.
X          HIST_IGNORE_SPACE (-g)
X               Do not enter command lines into the  history  list
X               if they begin with a blank.
X          HISTLIT (-j)
X               Use literal (unparsed)  versions  of  the  history
X               lines in the editor.
X          HIST_NO_STORE
X               Remove the history (fc -l) command from  the  his-
X               tory when invoked.
X          HIST_VERIFY
X               Whenever the user enters a line with history  sub-
X               stitution,   don't   execute  the  line  directly;
X               instead, perform history substitution  and  reload
X               the line into the editing buffer.
X          IGNORE_BRACES (-I)
X               Do not perform brace expansion.
X          IGNOREEOF (-7)
X               Do not exit on end-of-file.  Require  the  use  of
X               exit or logout instead.
X          INTERACTIVE (-i)
X               This is an interactive shell.
X          INTERACTIVE_COMMENTS (-k)
X               Allow comments even in interactive shells.
X          KSH_OPTION_PRINT
X               Alters the way options settings are printed.
X          LIST_TYPES (-X)
X               When listing files that are possible  completions,
X               show the type of each file with a trailing identi-
X               fying mark.
X          LOGIN (-l)
X               This is a login shell.
X          LONG_LIST_JOBS (-R)
X               List jobs in the long format by default.
X          MAIL_WARNING (-U)
X               Print a warning message if a mail  file  has  been
X               accessed since the shell last checked.
X          MARKDIRS (-8)
X               Append a trailing / to all directory names result-
X               ing from filename generation (globbing).
X          MENU_COMPLETE (-Y)
X               On an ambiguous  completion,  instead  of  listing
X               possibilities,  insert the first match.  Then when
X               completion is requested again,  remove  the  first
X               match  and  insert  the  second  match, etc.  When
X               there are no more matches, go back  to  the  first
X               one  again.   reverse-menu-complete may be used to
X               loop through the list in the other direction.
X          MENU_COMPLETE_BEEP
X               Beep on an ambiguous menu completion.
X          MONITOR (-m)
X               Allow job control.  Set by default in  interactive
X               shells.
X          NO_BAD_PATTERN (-2)
X               If a pattern  for  filename  generation  is  badly
X               formed,  leave  it  unchanged in the argument list
X               instead of printing an error.
X          NO_BANG_HIST (-K)
X               Do not perform textual history  substitution.   Do
X               not treat the ! character specially.
X          NOBEEP (-B)
X               Do not beep.
X          NO_CLOBBER (-1)
X               Prevents > redirection  from  truncating  existing
X               files.  >! may be used to truncate a file instead.
X               Also prevents >> from creating files.  >>! may  be
X               used instead.
X          NO_EQUALS
X               Don't perform = filename substitution.
X          NOEXEC (-n)
X               Read commands and check them  for  syntax  errors,
X               but do not execute them.
X          NOGLOB (-F)
X               Disable filename generation.
X          NO_HIST_BEEP
X               Don't beep when an attempt is  made  to  access  a
X               history entry which isn't there.
X          NOHUP
X               Don't send the HUP signal to running jobs when the
X               shell exits.
X          NO_LIST_BEEP
X               Don't beep on an ambiguous completion.
X          NO_NOMATCH (-3)
X               If  a  pattern  for  filename  generation  has  no
X               matches,  leave  it unchanged in the argument list
X               instead of printing an error.
X          NO_PROMPT_CR (-V)
X               Don't print a carriage return just before printing
X               a prompt in the line editor.
X          NO_RCS (-f)
X               Do not source the .zshenv, .zshrc, .zlogin,  .zlo-
X               gout, or .zprofile files.
X          NO_SHORT_LOOPS
X               Disallow the short forms of for, select,  if,  and
X               function constructs.
X          NOTIFY (-5)
X               Report the status of background jobs  immediately,
X               rather  than  waiting until just before printing a
X               prompt.
X          NOUNSET (-u)
X               Treat unset parameters as an error when substitut-
X               ing.
X          NULLGLOB (-G)
X               If  a  pattern  for  filename  generation  has  no
X               matches, delete the pattern from the argument list
X               instead  of   reporting   an   error.    Overrides
X               NO_NOMATCH.
X          NUMERICGLOBSORT
X               If numeric filenames are  matched  by  a  filename
X               generation pattern, sort the filenames numerically
X               rather than lexicographically.
X          OVERSTRIKE
X               Start up the line editor in overstrike mode.
X          PATH_DIRS (-Q)
X               Perform a path search even on command  names  with
X               slashes  in  them.  Thus if "/usr/local/bin" is in
X               the user's path, and  he  types  "X11/xinit",  the
X               command  "/usr/local/bin/X11/xinit"  will  be exe-
X               cuted (assuming it exists).
X          PRINT_EXIT_VALUE (-C)
X               Print the exit value  of  programs  with  non-zero
X               exit status.
X          PUSHD_IGNORE_DUPS
X               Don't push multiple copies of the  same  directory
X               onto the directory stack.
X          PUSHD_MINUS
X               See popd below.
X          PUSHD_SILENT (-E)
X               Do not print the directory stack  after  pushd  or
X               popd.
X          PUSHD_TO_HOME (-D)
X               Have pushd with no arguments act like pushd $HOME.
X          RC_EXPAND_PARAM (-P)
X               See Parameter Expansion.
X          RC_QUOTES
X               Allow the character sequence '' to signify a  sin-
X               gle quote within singly quoted strings.
X          RECEXACT (-S)
X               In completion, recognize  exact  matches  even  if
X               they are ambiguous.
X          RMSTARSILENT (-H)
X               Do not query the user before executing "rm  *"  or
X               "rm path/*".
X          SHINSTDIN (-s)
X               Read commands from the standard input.
X          SH_WORD_SPLIT (-y)
X               See Parameter Expansion.
X          SINGLE_LINE_ZLE (-M)
X               Use single-line command line  editing  instead  of
X               multi-line.
X          SUN_KEYBOARD_HACK (-L)
X               If a line ends with a backquote, and there are  an
X               odd  number  of backquotes on the line, ignore the
X               trailing backquote.  This is useful on  some  key-
X               boards  where the return key is too small, and the
X               backquote key lies annoyingly close to it.
X          VERBOSE (-v)
X               Print shell input lines as they are read.
X          XTRACE (-x)
X               Print commands and their  arguments  as  they  are
X               executed.
X          ZLE (-Z)
X               Use the zsh line editor.
END_OF_FILE
  if test 11726 -ne `wc -c <'help/unsetopt'`; then
    echo shar: \"'help/unsetopt'\" unpacked with wrong size!
  fi
  # end of 'help/unsetopt'
fi
if test -f 'src/parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/parse.c'\"
else
  echo shar: Extracting \"'src/parse.c'\" \(18751 characters\)
  sed "s/^X//" >'src/parse.c' <<'END_OF_FILE'
X/*
X *
X * parse.c - parser
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
X#define YYERROR { tok = LEXERR; return NULL; }
X#define YYERRORV { tok = LEXERR; return; }
X
X#define make_list() allocnode(N_LIST)
X#define make_sublist() allocnode(N_SUBLIST)
X#define make_pline() allocnode(N_PLINE)
X#define make_cmd() allocnode(N_CMD)
X#define make_forcmd() allocnode(N_FOR)
X#define make_casecmd() allocnode(N_CASE)
X#define make_ifcmd() allocnode(N_IF)
X#define make_whilecmd() allocnode(N_WHILE)
X#define make_varnode() allocnode(N_VARASG)
X#define make_cond() allocnode(N_COND)
X
X/*
X * event	: ENDINPUT
X *			| SEPER
X *			| sublist [ SEPER | AMPER ]
X */
XList parse_event() /**/
X{
X	tok = ENDINPUT;
X	incmdpos = 1;
X	yylex();
X	return par_event();
X}
X
XList par_event() /**/
X{
XSublist sl;
XList l = NULL;
X
X	while (tok == SEPER) {
X		if (isnewlin > 0) return NULL;
X		yylex();
X	}
X	if (tok == ENDINPUT) return NULL;
X	if (sl = par_sublist())
X		if (tok == ENDINPUT) {
X			l = make_list();
X			l->type = SYNC; l->left = sl;
X		} else if (tok == SEPER) {
X			l = make_list();
X			l->type = SYNC; l->left = sl;
X			if (isnewlin <= 0) yylex();
X		} else if (tok == AMPER) {
X			l = make_list();
X			l->type = ASYNC; l->left = sl;
X			yylex();
X		} else
X			l = NULL;
X	if (!l) {
X		if (errflag) { yyerror(); return NULL; }
X		yyerror();
X		errflag = 0;
X		if (isnewlin <= 0) {
X			int c;
X
X			hwbegin();
X			while ((c = hgetc()) != '\n' && !lexstop);
X			if (c == '\n') hungetc('\n');
X			hwaddc(HISTSPACE);
X			hwadd();
X		}
X		errflag = 1;
X		return NULL;
X	} else {
X		l->right = par_event();
X	}
X	return l;
X}
X
XList parse_list() /**/
X{
X	tok = ENDINPUT;
X	incmdpos = 1;
X	yylex();
X	return par_list();
X}
X
X/*
X * list	: { SEPER } [ sublist [ { SEPER | AMPER } list ] ]
X */
XList par_list() /**/
X{
XSublist sl;
XList l = NULL;
X
X	while (tok == SEPER) yylex();
X	if (sl = par_sublist())
X		if (tok == SEPER || tok == AMPER) {
X			l = make_list();
X			l->left = sl;
X			l->type = (tok == SEPER) ? SYNC : ASYNC;
X			incmdpos = 1;
X			while (tok == SEPER || tok == AMPER) yylex();
X			l->right = par_list();
X		} else {
X			l = make_list();
X			l->left = sl;
X			l->type = SYNC;
X		}
X	return l;
X}
X
XList par_list1() /**/
X{
XSublist sl;
XList l = NULL;
X
X	if (sl = par_sublist()) {
X		l = make_list();
X		l->type = SYNC;
X		l->left = sl;
X	}
X	return l;
X}
X
X/*
X * sublist	: sublist2 [ ( DBAR | DAMPER ) { SEPER } sublist ]
X */
XSublist par_sublist() /**/
X{
XSublist sl;
X
X	if (sl = par_sublist2())
X		if (tok == DBAR || tok == DAMPER) {
X			int qtok = tok;
X			yylex();
X			while (tok == SEPER) yylex();
X			sl->right = par_sublist();
X			sl->type = (qtok == DBAR) ? ORNEXT : ANDNEXT;
X		}
X	return sl;
X}
X
X/*
X * sublist2	: [ COPROC | BANG ] pline
X */
XSublist par_sublist2() /**/
X{
XSublist sl;
XPline p;
X
X	sl = make_sublist();
X	if (tok == COPROC) { sl->flags |= PFLAG_COPROC; yylex(); }
X	else if (tok == BANG) { sl->flags |= PFLAG_NOT; yylex(); }
X	if (!(p = par_pline()) && !sl->flags)
X		return NULL;
X	sl->left = p;
X	return sl;
X}
X
X/*
X * pline	: cmd [ ( BAR | BARAMP ) { SEPER } pline ]
X */
XPline par_pline() /**/
X{
XCmd c;
XPline p,p2;
X
X	if (!(c = par_cmd()))
X		return NULL;
X	if (tok == BAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		p2 = par_pline();
X		p = make_pline();
X		p->left = c; p->right = p2; p->type = PIPE;
X		return p;
X	} else if (tok == BARAMP) {
X		struct redir *rdr = alloc(sizeof *rdr);
X		rdr->type = MERGEOUT; rdr->fd1 = 2; rdr->fd2 = 1;
X		addnode(c->redir,rdr);
X
X		yylex();
X		p2 = par_pline();
X		p = make_pline();
X		p->left = c; p->right = p2; p->type = PIPE;
X		return p;
X	} else {
X		p = make_pline();
X		p->left = c; p->type = END;
X		return p;
X	}
X}
X
X/*
X * cmd	: { redir } ( for | case | if | while | repeat |
X *				subsh | funcdef | time | dinbrack | simple ) { redir }
X */
XCmd par_cmd() /**/
X{
XCmd c;
X
X	c = make_cmd();
X	c->args = newlist();
X	c->redir = newlist();
X	c->vars = newlist();
X	while (IS_REDIROP(tok))
X		par_redir(c->redir);
X	switch (tok) {
X	case FOR: case FOREACH: case SELECT: par_for(c); break;
X	case CASE: par_case(c); break;
X	case IF: par_if(c); break;
X	case WHILE: case UNTIL: par_while(c); break;
X	case REPEAT: par_repeat(c); break;
X	case INPAR: case INBRACE: par_subsh(c); break;
X	case FUNC: par_funcdef(c); break;
X	case TIME: par_time(c); break;
X	case DINBRACK: par_dinbrack(c); break;
X	default: if (!par_simple(c)) return NULL; break;
X	}
X	while (IS_REDIROP(tok))
X		par_redir(c->redir);
X	incmdpos = 1;
X	incasepat = 0;
X	incond = 0;
X	return c;
X}
X
X/*
X * for	: ( FOR[EACH] | SELECT ) name ( "in" wordlist | INPAR wordlist OUTPAR )
X				{ SEPER } ( DO list DONE | INBRACE list OUTBRACE |
X				list ZEND | list1 )
X */
Xvoid par_for(c) /**/
XCmd c;
X{
Xstruct forcmd *f;
Xint csh = (tok == FOREACH || isset(CSHJUNKIELOOPS));
X
X	f = make_forcmd();
X	c->type = (tok == SELECT) ? CSELECT : CFOR;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	f->name = tokstr;
X	incmdpos = 1;
X	yylex();
X	if (tok == STRING && !strcmp(tokstr,"in")) {
X		f->inflag = 1;
X		incmdpos = 0;
X		yylex();
X		c->args = par_wordlist();
X		if (tok != SEPER) YYERRORV;
X	} else if (tok == INPAR) {
X		f->inflag = 1;
X		incmdpos = 0;
X		yylex();
X		c->args = par_nl_wordlist();
X		if (tok != OUTPAR) YYERRORV;
X		incmdpos = 1;
X		yylex();
X	}
X	incmdpos = 1;
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		f->list = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else if (tok == INBRACE) {
X		yylex();
X		f->list = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (csh) {
X		f->list = par_list();
X		if (tok != ZEND) YYERRORV;
X		yylex();
X	} else if (isset(NOSHORTLOOPS)) {
X		YYERRORV;
X	} else
X		f->list = par_list1();
X	c->u.forcmd = f;
X}
X
X/*
X * case	: CASE STRING { SEPER } ( "in" | INBRACE )
X				{ { SEPER } STRING { BAR STRING } OUTPAR list [ DSEMI ] }
X				{ SEPER } ( "esac" | OUTBRACE )
X */
Xvoid par_case(c) /**/
XCmd c;
X{
Xstruct casecmd **ccp;
Xint brflag;
X
X	c->type = CCASE;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	addnode(c->args,tokstr);
X	incmdpos = 1;
X	yylex();
X	while (tok == SEPER) yylex();
X	if (!(tok == STRING && !strcmp(tokstr,"in")) && tok != INBRACE) YYERRORV;
X	brflag = (tok == INBRACE);
X	incasepat = 1;
X	incmdpos = 0;
X	yylex();
X	ccp = &c->u.casecmd;
X	for (;;) {
X		char *str;
X		struct casecmd *cc;
X
X		*ccp = cc = make_casecmd();
X		while (tok == SEPER) yylex();
X		if (tok == OUTBRACE) {
X			yylex();
X			break;
X		}
X		if (tok != STRING) YYERRORV;
X		if (!strcmp(tokstr,"esac")) {
X			yylex();
X			break;
X		}
X		str = tokstr;
X		yylex();
X		while (tok == BAR) {
X			char *str2;
X			int sl = strlen(str);
X
X			yylex();
X			if (tok != STRING) YYERRORV;
X			str2 = alloc(sl+strlen(tokstr)+1);
X			strcpy(str2,str);
X			str2[sl] = Bar;
X			strcpy(str2+sl+1,tokstr);
X			str = str2;
X			yylex();
X		}
X		if (tok != OUTPAR) YYERRORV;
X		incasepat = 0;
X		incmdpos = 1;
X		yylex();
X		cc->pat = str;
X		cc->list = par_list();
X		ccp = &cc->next;
X		if ((tok == ESAC && !brflag) || (tok == OUTBRACE && brflag)) {
X			yylex();
X			break;
X		}
X		if (tok != DSEMI) YYERRORV;
X		incasepat = 1;
X		incmdpos = 0;
X		yylex();
X	}
X	*ccp = NULL;
X}
X
X/*
X * if	: { ( IF | ELIF ) { SEPER } ( INPAR list OUTPAR | list )
X			{ SEPER } ( THEN list | INBRACE list OUTBRACE | list1 ) }
X			[ FI | ELSE list FI | ELSE { SEPER } INBRACE list OUTBRACE ]
X			(you get the idea...?)
X */
Xvoid par_if(c) /**/
XCmd c;
X{
Xstruct ifcmd *i,**ip;
Xint xtok;
X
X	c->type = CIF;
X	ip = &c->u.ifcmd;
X	for (;;) {
X		xtok = tok;
X		yylex();
X		if (xtok == FI)
X			break;
X		while (tok == SEPER) yylex();
X		if (xtok == ELSE)
X			break;
X		if (!(xtok == IF || xtok == ELIF)) YYERRORV;
X		*ip = i = make_ifcmd();
X		ip = &i->next;
X		if (tok == INPAR) {
X			yylex();
X			i->ifl = par_list();
X			if (tok != OUTPAR) YYERRORV;
X			incmdpos = 1;
X			yylex();
X		} else {
X			i->ifl = par_list();
X			incmdpos = 1;
X		}
X		while (tok == SEPER) yylex();
X		xtok = FI;
X		if (tok == THEN) {
X			yylex();
X			i->thenl = par_list();
X			incmdpos = 1;
X		} else if (tok == INBRACE) {
X			yylex();
X			i->thenl = par_list();
X			if (tok != OUTBRACE) YYERRORV;
X			yylex();
X			incmdpos = 1;
X			if (tok == SEPER) break;
X		} else if (isset(NOSHORTLOOPS)) {
X			YYERRORV;
X		} else {
X			i->thenl = par_list1();
X			incmdpos = 1;
X			break;
X		}
X	}
X	if (xtok == ELSE) {
X		*ip = i = make_ifcmd();
X		if (tok == INBRACE) {
X			yylex();
X			i->thenl = par_list();
X			if (tok != OUTBRACE) YYERRORV;
X			yylex();
X		} else {
X			i->thenl = par_list();
X			if (tok != FI) YYERRORV;
X			yylex();
X		}
X	}
X}
X
X/*
X * while	: ( WHILE | UNTIL ) ( INPAR list OUTPAR | list ) { SEPER }
X				( DO list DONE | INBRACE list OUTBRACE | list ZEND )
X */
Xvoid par_while(c) /**/
XCmd c;
X{
Xstruct whilecmd *w;
X
X	c->type = CWHILE;
X	w = c->u.whilecmd = make_whilecmd();
X	w->cond = (tok == UNTIL);
X	yylex();
X	if (tok == INPAR) {
X		yylex();
X		w->cont = par_list();
X		if (tok != OUTPAR) YYERRORV;
X		yylex();
X	} else {
X		w->cont = par_list();
X	}
X	incmdpos = 1;
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		w->loop = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else if (tok == INBRACE) {
X		yylex();
X		w->loop = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (isset(CSHJUNKIELOOPS)) {
X		w->loop = par_list();
X		if (tok != ZEND) YYERRORV;
X		yylex();
X	} else
X		YYERRORV;
X}
X
X/*
X * repeat	: REPEAT STRING { SEPER } ( DO list DONE | list1 )
X */
Xvoid par_repeat(c) /**/
XCmd c;
X{
X	c->type = CREPEAT;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	addnode(c->args,tokstr);
X	incmdpos = 1;
X	yylex();
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		c->u.list = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else {
X		c->u.list = par_list1();
X	}
X}
X
X/*
X * subsh	: ( INPAR | INBRACE ) list ( OUTPAR | OUTBRACE )
X */
Xvoid par_subsh(c) /**/
XCmd c;
X{
X	c->type = (tok == INPAR) ? SUBSH : CURSH;
X	yylex();
X	c->u.list = par_list();
X	if (tok != ((c->type == SUBSH) ? OUTPAR : OUTBRACE)) YYERRORV;
X	yylex();
X}
X
X/*
X * funcdef	: FUNCTION wordlist [ INOUTPAR ] { SEPER }
X *					( list1 | INBRACE list OUTBRACE )
X */
Xvoid par_funcdef(c) /**/
XCmd c;
X{
X	nocorrect = 1;
X	incmdpos = 0;
X	yylex();
X	c->type = FUNCDEF;
X	c->args = newlist();
X	incmdpos = 1;
X	while (tok == STRING) {
X		if (*tokstr == Inbrace && !tokstr[1]) { tok = INBRACE; break; }
X		addnode(c->args,tokstr);
X		yylex();
X	}
X	nocorrect = 0;
X	if (tok == INOUTPAR) yylex();
X	while (tok == SEPER) yylex();
X	if (tok == INBRACE) {
X		yylex();
X		c->u.list = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (isset(NOSHORTLOOPS)) {
X		YYERRORV;
X	} else
X		c->u.list = par_list1();
X}
X
X/*
X * time	: TIME sublist2
X */
Xvoid par_time(c) /**/
XCmd c;
X{
X	yylex();
X	c->type = ZCTIME;
X	c->u.pline = par_sublist2();
X}
X
X/*
X * dinbrack	: DINBRACK cond DOUTBRACK
X */
Xvoid par_dinbrack(c) /**/
XCmd c;
X{
X	c->type = COND;
X	incond = 1;
X	incmdpos = 0;
X	yylex();
X	c->u.cond = par_cond();
X	if (tok != DOUTBRACK) YYERRORV;
X	incond = 0;
X	incmdpos = 1;
X	yylex();
X}
X
X/*
X * simple	: { COMMAND | EXEC | NOGLOB | NOCORRECT | DASH }
X					{ STRING | ENVSTRING | ENVARRAY wordlist OUTPAR | redir }
X					[ INOUTPAR { SEPER } ( list1 | INBRACE list OUTBRACE ) ]
X */
XCmd par_simple(c) /**/
XCmd c;
X{
Xint isnull = 1;
X
X	c->type = SIMPLE;
X	for (;;) {
X		if (tok == COMMAND) c->flags |= CFLAG_COMMAND;
X		else if (tok == EXEC) c->flags |= CFLAG_EXEC;
X		else if (tok == NOGLOB) c->flags |= CFLAG_NOGLOB;
X		else if (tok == NOCORRECT) nocorrect = 1;
X		else if (tok == DASH) c->flags = CFLAG_DASH;
X		else break;
X		yylex();
X	}
X	if (tok == AMPER) YYERROR;
X	for (;;) {
X		if (tok == STRING) {
X			incmdpos = 0;
X			addnode(c->args,tokstr);
X			yylex();
X		} else if (tok == ENVSTRING) {
X			struct varasg *v = make_varnode();
X			v->type = PMFLAG_s;
X			equalsplit(v->name = tokstr,&v->str);
X			addnode(c->vars,v);
X			yylex();
X		} else if (tok == ENVARRAY) {
X			struct varasg *v = make_varnode();
X			int oldcmdpos = incmdpos;
X			v->type = PMFLAG_A;
X			incmdpos = 0;
X			v->name = tokstr;
X			yylex();
X			v->arr = par_nl_wordlist();
X			if (tok != OUTPAR) YYERROR;
X			incmdpos = oldcmdpos;
X			yylex();
X			addnode(c->vars,v);
X		} else if (IS_REDIROP(tok)) {
X			par_redir(c->redir);
X		} else if (tok == INOUTPAR) {
X			incmdpos = 1;
X			yylex();
X			while (tok == SEPER) yylex();
X			if (tok == INBRACE) {
X				yylex();
X				c->u.list = par_list();
X				if (tok != OUTBRACE) YYERROR;
X				yylex();
X			} else if (isset(NOSHORTLOOPS)) {
X				YYERROR;
X			} else
X				c->u.list = par_list1();
X			c->type = FUNCDEF;
X		} else break;
X		isnull = 0;
X	}
X	if (isnull && empty(c->redir)) return NULL;
X	if (full(c->args)) {
X		if (underscore)
X			free(underscore);
X		underscore = ztrdup(getdata(lastnode(c->args)));
X		untokenize(underscore);
X	}
X	incmdpos = 1;
X	return c;
X}
X
X/*
X * cond	: cond_1 { SEPER } [ DBAR { SEPER } cond ]
X */
XCond par_cond() /**/
X{
XCond c,c2;
X
X	c = par_cond_1();
X	while (tok == SEPER) yylex();
X	if (tok == DBAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c2 = make_cond();
X		c2->left = c;
X		c2->right = par_cond();
X		c2->type = COND_OR;
X		return c2;
X	}
X	return c;
X}
X
X/*
X * cond_1 : cond_2 { SEPER } [ DAMPER { SEPER } cond_1 ]
X */
XCond par_cond_1() /**/
X{
XCond c,c2;
X
X	c = par_cond_2();
X	while (tok == SEPER) yylex();
X	if (tok == DAMPER) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c2 = make_cond();
X		c2->left = c;
X		c2->right = par_cond_1();
X		c2->type = COND_AND;
X		return c2;
X	}
X	return c;
X}
X
X/*
X * cond_2	: BANG cond_2
X				| INPAR { SEPER } cond_2 { SEPER } OUTPAR
X				| STRING STRING STRING
X				| STRING STRING
X				| STRING ( INANG | OUTANG ) STRING
X */
XCond par_cond_2() /**/
X{
XCond c,c2;
Xchar *s1,*s2,*s3;
Xint xtok;
X
X	if (tok == BANG) {
X		yylex();
X		c = par_cond_2();
X		c2 = make_cond();
X		c2->left = c;
X		c2->type = COND_NOT;
X		return c2;
X	}
X	if (tok == INPAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c = par_cond();
X		while (tok == SEPER) yylex();
X		if (tok != OUTPAR) YYERROR;
X		yylex();
X		return c;
X	}
X	if (tok != STRING) YYERROR;
X	s1 = tokstr;
X	yylex();
X	xtok = tok;
X	if (tok == INANG || tok == OUTANG) {
X		yylex();
X		if (tok != STRING) YYERROR;
X		s3 = tokstr;
X		yylex();
X		c = make_cond();
X		c->left = s1;
X		c->right = s3;
X		c->type = (xtok == INANG) ? COND_STRLT : COND_STRGTR;
X		c->types[0] = c->types[1] = NT_STR;
X		return c;
X	}
X	if (tok != STRING) YYERROR;
X	s2 = tokstr;
X	yylex();
X	if (tok == STRING) {
X		s3 = tokstr;
X		yylex();
X		return par_cond_triple(s1,s2,s3);
X	} else
X		return par_cond_double(s1,s2);
X}
X
X/*
X * redir	: ( OUTANG | ... | TRINANG ) STRING
X */
Xvoid par_redir(l) /**/
XLklist l;
X{
Xchar *toks;
Xstruct redir *fn = allocnode(N_REDIR);
Xint mergerror = 0;
Xint oldcmdpos,oldnc;
X
X	oldcmdpos = incmdpos;
X	incmdpos = 0;
X	oldnc = nocorrect;
X	if (tok != INANG) nocorrect = 1;
X	fn->type = redirtab[tok-OUTANG];
X	fn->fd1 = tokfd;
X	yylex();
X	if (tok != STRING && tok != ENVSTRING) YYERRORV;
X	toks = tokstr;
X	incmdpos = oldcmdpos;
X	nocorrect = oldnc;
X	yylex();
X
X/* assign default fd */
X
X	if (fn->fd1 == -1)
X		fn->fd1 = IS_READFD(fn->type) ? 0 : 1;
X
X/* > >(...) or < <(...) */
X
X	if ((*toks == Inang || *toks == Outang) && toks[1] == Inpar) {
X		if ((fn->type & ~1) == WRITE) fn->type = OUTPIPE;
X		else if (fn->type == READ) fn->type = INPIPE;
X		else YYERRORV;
X		fn->name = toks;
X
X/* <<[-] name */
X
X	} else if (fn->type == HEREDOC || fn->type == HEREDOCDASH) {
X		char tbuf[256], *tlin = NULL;
X		int tsiz = 0, l;
X		/* Save the rest of the current line for later tokenization */
X		if (!isnewlin) {
X			while (hgets(tbuf, 256) != NULL) {
X				l = strlen(tbuf);
X				if (tsiz == 0) {
X					tlin = ztrdup(tbuf); /* Test for failure? */
X					tsiz = l;
X				} else {
X					tlin = realloc(tlin,tsiz+l+1); /* Test for failure? */
X					strcpy(&tlin[tsiz], tbuf);
X					tsiz += l;
X				}
X				if (tbuf[l-1] == '\n') break;
X			}
X		}
X		/* Now grab the document */
X		fn->name = gethere(toks,fn->type);
X		fn->type = HERESTR;
X		/* Put back the saved line to resume tokenizing */
X		if (tsiz > 0) {
X			hungets(tlin);
X			free(tlin);
X		}
X
X/* >& name or >>& name */
X
X	} else if (IS_ERROR_REDIR(fn->type) && getfdstr(toks) == FD_WORD) {
X		mergerror = 1;
X		fn->name = toks;
X		fn->type = UN_ERROR_REDIR(fn->type);
X
X/* >>& and >>&! are only valid with a name after them */
X
X	} else if (fn->type == ERRAPP || fn->type == ERRAPPNOW) {
X		YYERRORV;
X
X/* >& # */
X
X	} else if (fn->type == MERGE || fn->type == MERGEOUT) {
X		fn->fd2 = getfdstr(toks);
X		if (fn->fd2 == FD_CLOSE) fn->type = CLOSE;
X		else if (fn->fd2 == FD_WORD) fn->fd2 = (fn->type==MERGEOUT) ? 1 : 0;
X	} else
X		fn->name = toks;
X	addnode(l,fn);
X	if (mergerror)
X		{
X		struct redir *fe = allocnode(N_REDIR);
X
X		fe->fd1 = 2;
X		fe->fd2 = fn->fd1;
X		fe->type = MERGEOUT;
X		addnode(l,fe);
X		}
X}
X
X/*
X * wordlist	: { STRING }
X */
XLklist par_wordlist() /**/
X{
XLklist l;
X
X	l = newlist();
X	while (tok == STRING) {
X		addnode(l,tokstr);
X		yylex();
X	}
X	return l;
X}
X
X/*
X * nl_wordlist	: { STRING | SEPER }
X */
XLklist par_nl_wordlist() /**/
X{
XLklist l;
X
X	l = newlist();
X	while (tok == STRING || tok == SEPER) {
X		if (tok != SEPER)
X			addnode(l,tokstr);
X		yylex();
X	}
X	return l;
X}
X
X/* get fd associated with str */
X
Xint getfdstr(s) /**/
Xchar *s;
X{
X	if (s[1]) return FD_WORD;
X	if (idigit(*s)) return *s-'0';
X	if (*s == 'p') return FD_COPROC;
X	if (*s == '-') return FD_CLOSE;
X	return FD_WORD;
X}
X
XCond par_cond_double(a,b) /**/
Xchar *a;char *b;
X{
XCond n = make_cond();
X
X	if (a[0] != '-' || !a[1] || a[2])
X		{
X		zerr("parse error: condition expected: %s",a,0);
X		return NULL;
X		}
X	n->left = b;
X	n->type = a[1];
X	n->types[0] = n->types[1] = NT_STR;
X	return n;
X}
X
XCond par_cond_triple(a,b,c) /**/
Xchar *a;char *b;char *c;
X{
XCond n = make_cond();
Xstatic char *condstrs[] = {
X	"nt","ot","ef","eq","ne","lt","gt","le","ge",NULL
X	};
Xint t0;
X
X	if ((b[0] == Equals || b[0] == '=') && !b[1])
X		n->type = COND_STREQ;
X	else if (b[0] == '!' && b[1] == '=' && !b[2])
X		n->type = COND_STRNEQ;
X	else if (b[0] == '-')
X		{
X		for (t0 = 0; condstrs[t0]; t0++)
X			if (!strcmp(condstrs[t0],b+1))
X				break;
X		if (condstrs[t0])
X			n->type = t0+COND_NT;
X		else
X			zerr("unrecognized condition: %s",b,0);
X		}
X	else
X		zerr("condition expected: %s",b,0);
X	n->left = a;
X	n->right = c;
X	n->types[0] = n->types[1] = NT_STR;
X	return n;
X}
X
Xvoid yyerror() /**/
X{
Xint t0;
X
X	for (t0 = 0; t0 != 20; t0++)
X		if (!yytext[t0] || yytext[t0] == '\n' || yytext[t0] == HISTSPACE)
X			break;
X	if (t0 == 20)
X		zerr("parse error near `%l...'",yytext,20);
X	else if (t0)
X		zerr("parse error near `%l'",yytext,t0);
X	else
X		zerr("parse error",NULL,0);
X}
X
END_OF_FILE
  if test 18751 -ne `wc -c <'src/parse.c'`; then
    echo shar: \"'src/parse.c'\" unpacked with wrong size!
  fi
  # end of 'src/parse.c'
fi
echo shar: End of archive 15 \(of 22\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
