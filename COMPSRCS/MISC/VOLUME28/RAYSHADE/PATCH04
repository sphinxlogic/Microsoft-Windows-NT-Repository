Newsgroups: comp.sources.misc
From: Craig Kolb <rayshade-request@cs.princeton.edu>
Subject:  v28i030:  rayshade - A raytracing package for UNIX, Patch04
Message-ID: <1992Feb10.162026.5810@sparky.imd.sterling.com>
X-Md4-Signature: c0a893b6c041148a9801edd1aa2c3b24
Date: Mon, 10 Feb 1992 16:20:26 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Craig Kolb <rayshade-request@cs.princeton.edu>
Posting-number: Volume 28, Issue 30
Archive-name: rayshade/patch04
Environment: UNIX
Patch-To: rayshade: Volume 21, Issue 3-22

System: rayshade version 4.0
Patch #: 4
Priority: HIGH
Subject: patch #3, continued
Date: Mon Feb  3 13:23:58 EST 1992
From: Rayshade Construction Co. <rayshade-request@cs.princeton.edu>

Fix:	From rn, say "| patch -p -N -d DIR", where DIR is your rayshade source
	directory.  Outside of rn, say "cd DIR; patch -p -N <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch (version 2.0, latest patchlevel).

	After patching:
		*** DO NOTHING--INSTALL ALL PATCHES UP THROUGH #5 FIRST ***

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.

	If you are missing previous patches they can be obtained through
	anonymous ftp from weedeater.math.yale.edu (130.132.23.17) in
	pub/rayshade.4.0/patches.


Index: patchlevel.h
Prereq: 3
1c1
< #define PATCHLEVEL 3
---
> #define PATCHLEVEL 4

Index: Doc/Guide/options.tex
*** old/Doc/Guide/options.tex	Mon Feb  3 12:50:02 1992
--- new/Doc/Guide/options.tex	Fri Jan 17 10:29:14 1992
***************
*** 1,12 ****
  \chapter{Options}
  
! This appendix describes the command-line arguments accepted by {\em rayshade}.
  These options override defaults
  as well as any values or flags given in the input file,
  and are thus useful for generating test and other unusual, ``non-standard''
  renderings.
  
! The general form of a \rayshade command line is:
  \begin{quote}
  {\tt rayshade} [{\em Options}] [{\em filename}]
  \end{quote}
--- 1,12 ----
  \chapter{Options}
  
! This appendix describes the command-line arguments accepted by {\rayshade}.
  These options override defaults
  as well as any values or flags given in the input file,
  and are thus useful for generating test and other unusual, ``non-standard''
  renderings.
  
! The general form of a {\rayshade} command line is:
  \begin{quote}
  {\tt rayshade} [{\em Options}] [{\em filename}]
  \end{quote}
***************
*** 20,26 ****
  
  Command-line options fall into two broad categories: those that set
  numerical or other values and thus must be followed by further arguments,
! and those that simply turn features on and off.  {\em Rayshade}'s
  convention is to denote the value-setting arguments using capital letters,
  and feature-toggling arguments using lower-case letters.
  
--- 20,26 ----
  
  Command-line options fall into two broad categories: those that set
  numerical or other values and thus must be followed by further arguments,
! and those that simply turn features on and off.  {\Rayshade}'s
  convention is to denote the value-setting arguments using capital letters,
  and feature-toggling arguments using lower-case letters.
  
***************
*** 46,52 ****
  	Continue an interrupted rendering.
  \end{defkey}
  When given, this option indicates that the image file being written
! to contains a partially-completed image.  \Rayshade will read the
  image to determine the scanline from which to continue the rendering.
  This option is only available with the Utah Raster Toolkit.
  The {\tt -O} option must also be used.
--- 46,52 ----
  	Continue an interrupted rendering.
  \end{defkey}
  When given, this option indicates that the image file being written
! to contains a partially-completed image.  {\Rayshade} will read the
  image to determine the scanline from which to continue the rendering.
  This option is only available with the Utah Raster Toolkit.
  The {\tt -O} option must also be used.
***************
*** 74,79 ****
--- 74,87 ----
  \end{defkey}
  Overrides the value given using the {\tt report} keyword.
  
+ \begin{defkey}{-f}{}
+ 	Flip all computed polygon (and triangle) normals.
+ \end{defkey}
+ This option should be used when rendering polygons defined
+ by vertices given in {\em clockwise}
+ order, rather than counter-clockwise order as
+ expected by {\rayshade}.
+ 
  \begin{defkey}{-G}{{\em gamma}}
  	Use given gamma correction exponent writing writing
  	color information to the image file.
***************
*** 91,100 ****
  \end{defkey}
  
  \begin{defkey}{-j}{}
! 	Use jittered sampling to perform antialiasing.
  \end{defkey}
- This option overrides the {\tt adaptive} keyword, if present,
- in the input file.
  
  \begin{defkey}{-l}{}
  	Render the left stereo pair image.
--- 99,107 ----
  \end{defkey}
  
  \begin{defkey}{-j}{}
! 	Toggle the use of jittered sampling to perform antialiasing.
! 	If disabled, a fixed sampling pattern is used.
  \end{defkey}
  
  \begin{defkey}{-l}{}
  	Render the left stereo pair image.
***************
*** 129,144 ****
  	Toggle the effect of object opacity on shadows.
  \end{defkey}
  This option is equivalent to specifying {\tt shadowtransp}
! in the input file.  By default, \rayshade traces shadow
  rays through non-opaque objects.
  
! \begin{defkey}{-P}{}
  	Specify the options that should be passed to the C
  	preprocessor.
  \end{defkey}
  The C preprocessor, if available, is applied to all of the input
- 
  passed to {\em rayshade}.
  \begin{defkey}{-p}{}
  	Perform preview-quality rendering.
  \end{defkey}
--- 136,151 ----
  	Toggle the effect of object opacity on shadows.
  \end{defkey}
  This option is equivalent to specifying {\tt shadowtransp}
! in the input file.  By default, {\rayshade} traces shadow
  rays through non-opaque objects.
  
! \begin{defkey}{-P}{{\em cpp-arguments}}
  	Specify the options that should be passed to the C
  	preprocessor.
  \end{defkey}
  The C preprocessor, if available, is applied to all of the input
  passed to {\em rayshade}.
+ 
  \begin{defkey}{-p}{}
  	Perform preview-quality rendering.
  \end{defkey}
***************
*** 168,174 ****
  \begin{defkey}{-s}{}
  	Disable caching of  shadowing information.
  \end{defkey}
! It should not be necessary to ever use this option.
  
  \begin{defkey}{-T}{{\em r g b}}
  	Set the contrast threshold in the three
--- 175,181 ----
  \begin{defkey}{-s}{}
  	Disable caching of  shadowing information.
  \end{defkey}
! It should never be necessary to use this option.
  
  \begin{defkey}{-T}{{\em r g b}}
  	Set the contrast threshold in the three
***************
*** 177,182 ****
--- 184,197 ----
  This option overrides any value given through the use of
  the {\em contrast} keyword.
  
+ \begin{defkey}{-u}{}
+ 	Toggle the use of the C preprocessor.
+ \end{defkey}
+ {\Rayshade} usually feeds its input through a
+ C preprocessor if one is available on your system.
+ If this option is given, unadulterated input files will
+ be used.
+ 
  \begin{defkey}{-V}{{\em	filename}}
  	Write verbose output to the named file.
  \end{defkey}
***************
*** 190,198 ****
  selected and the objects defined to be included in the
  report file.
  
! \begin{defkey}{-W}{{\em minx miny maxx maxy}}
! 	Render the specified subwindow.  The parameters
! 	should fall between zero and one.
  \end{defkey}
  This option is provided to facilitate changing and/or examining a
  small portion of an image without having to re-render the entire
--- 205,219 ----
  selected and the objects defined to be included in the
  report file.
  
! \begin{defkey}{-W}{{\em minx maxx miny maxy}}
! 	Render the specified window.
! \end{defkey}
! The window must be properly contained within the screen.  This
! option overrides any window specified using the {\em window} keyword
! in the input file.
! 
! \begin{defkey}{-X}{{\em left right bottom top}}
! 	Crop the rendering window using the given normalized values.
  \end{defkey}
  This option is provided to facilitate changing and/or examining a
  small portion of an image without having to re-render the entire

Index: etc/rsconvert/yacc.y
Prereq: 4.0.1.1
*** old/etc/rsconvert/yacc.y	Mon Feb  3 12:49:50 1992
--- new/etc/rsconvert/yacc.y	Mon Feb  3 09:11:58 1992
***************
*** 11,23 ****
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: yacc.y,v 4.0.1.1 91/09/28 20:44:09 cek Exp Locker: cek $ */
  %{
  #include <stdio.h>
  #include "libcommon/common.h"
  
! /*#define NEWLINE()	WriteString("\n")*/
! #define NEWLINE()	printf("\n")
  #define LIST	0
  #define GRID	1
  char yyfilename[BUFSIZ];
--- 11,23 ----
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: yacc.y,v 4.0.1.2 91/11/26 21:13:36 cek Exp cek $ */
  %{
  #include <stdio.h>
  #include "libcommon/common.h"
  
! #define NEWLINE()	WriteNewline()
! /*#define NEWLINE()	printf("\n")*/
  #define LIST	0
  #define GRID	1
  char yyfilename[BUFSIZ];
***************
*** 31,42 ****
  	Vector v;
  };
  %token <d> tFLOAT
! %token <c> tSTRING
  %token <i> tINT
  %type <d> Fnumber sFnumber
  %type <col> sColor
  %type <v> sVector
! %token tADAPTIVE tAPERTURE 
  %token tBACKGROUND tBLOTCH tBOX tBUMP tCONE tCYL tDIRECTIONAL
  %token tENDDEF tEXTENDED tEYEP tFBM tFBMBUMP tFOCALDIST tFOG tFOV tGLOSS tGRID
  %token tHEIGHTFIELD tJITTERED tLIGHT tLIST tLOOKP tMARBLE tMAXDEPTH tMIST
--- 31,42 ----
  	Vector v;
  };
  %token <d> tFLOAT
! %token <c> tSTRING tHASHTHING
  %token <i> tINT
  %type <d> Fnumber sFnumber
  %type <col> sColor
  %type <v> sVector
! %token tADAPTIVE tAPERTURE
  %token tBACKGROUND tBLOTCH tBOX tBUMP tCONE tCYL tDIRECTIONAL
  %token tENDDEF tEXTENDED tEYEP tFBM tFBMBUMP tFOCALDIST tFOG tFOV tGLOSS tGRID
  %token tHEIGHTFIELD tJITTERED tLIGHT tLIST tLOOKP tMARBLE tMAXDEPTH tMIST
***************
*** 73,80 ****
--- 73,87 ----
  		| Object
  		| Fog
  		| Mist
+ 		| Hashthing
  		| ENDFILE		/* For backward compatibility */
  		;
+ Hashthing	: tHASHTHING
+ 		{
+ 			WriteVerbatim("\n#");
+ 			WriteVerbatim($1);
+ 			WriteNewline();
+ 		};
  List		: LIST
  		{
  			NEWLINE();
***************
*** 156,162 ****
  		{
  			NEWLINE();
  		}
! 		| FBM Fnumber Fnumber Fnumber Fnumber Int Fnumber tSTRING
  		{
  			NEWLINE();
  		}
--- 163,169 ----
  		{
  			NEWLINE();
  		}
! 		| FBM Fnumber Fnumber Fnumber Fnumber Int Fnumber String
  		{
  			NEWLINE();
  		}
***************
*** 401,406 ****
--- 408,414 ----
  				WriteFloat($10);
  				WriteString("1 1 1");
  				WriteFloat($11);
+ 				WriteNewline();
  			}
  		}
  		;
***************
*** 434,444 ****
--- 442,466 ----
  		;
  Cylinder	: CYL String sVector sVector sFnumber
  		{
+ 			Vector tmp;
+ 
  			/* Radius now goes first */
  			WriteFloat($5);
  			WriteVector(&$3);
  			WriteVector(&$4);
  			NEWLINE();
+ 			WriteString("#ifdef ENDCAPS\n");
+ 				VecSub($3, $4, &tmp);
+ 				WriteVerbatim("disc ");
+ 				WriteFloat($5);	/* radius */
+ 				WriteVector(&$3); /* pos */
+ 				WriteVector(&tmp);
+ 				WriteVerbatim("\ndisc ");
+ 				VecScale(-1, tmp, &tmp);
+ 				WriteFloat($5);	/* radius */
+ 				WriteVector(&$4); /* pos */
+ 				WriteVector(&tmp);
+ 			WriteString("\n#endif\n");
  		}
  		;
  Sphere		: SPHERE String Fnumber Vector
***************
*** 495,502 ****
  			NEWLINE();
  		}
  		;
! Fog		: FOG Fnumber Color
  		{
  			NEWLINE();
  		}
  		;
--- 517,526 ----
  			NEWLINE();
  		}
  		;
! Fog		: FOG sFnumber sColor
  		{
+ 			WriteColor(&$3);
+ 			WriteFloat($2); WriteFloat($2); WriteFloat($2);
  			NEWLINE();
  		}
  		;
***************
*** 542,548 ****
  FBM		: tFBM		{ WriteString("fbm"); }
  FBMBUMP		: tFBMBUMP	{ WriteString("fbmbump"); }
  FOCALDIST	: tFOCALDIST	{ WriteString("focaldist"); }
! FOG		: tFOG		{ WriteString("fog"); }
  FOV		: tFOV		{ WriteString("fov"); }
  GLOSS		: tGLOSS	{ WriteString("gloss"); }
  GRID		: tGRID	tINT tINT tINT	{ SetTypeGrid($2,$3,$4); }
--- 566,572 ----
  FBM		: tFBM		{ WriteString("fbm"); }
  FBMBUMP		: tFBMBUMP	{ WriteString("fbmbump"); }
  FOCALDIST	: tFOCALDIST	{ WriteString("focaldist"); }
! FOG		: tFOG		{ WriteString("atmosphere fog"); }
  FOV		: tFOV		{ WriteString("fov"); }
  GLOSS		: tGLOSS	{ WriteString("gloss"); }
  GRID		: tGRID	tINT tINT tINT	{ SetTypeGrid($2,$3,$4); }
***************
*** 553,559 ****
  LOOKP		: tLOOKP	{ WriteString("lookp"); }
  MARBLE		: tMARBLE	{ WriteString("marble"); }
  MAXDEPTH	: tMAXDEPTH	{ WriteString("maxdepth"); }
! MIST		: tMIST		{ WriteString("mist"); }
  OBJECT		: tOBJECT	{ WriteString("object"); }
  OUTFILE		: tOUTFILE	{ WriteString("outfile"); }
  PLANE		: tPLANE	{ WriteString("plane"); }
--- 577,583 ----
  LOOKP		: tLOOKP	{ WriteString("lookp"); }
  MARBLE		: tMARBLE	{ WriteString("marble"); }
  MAXDEPTH	: tMAXDEPTH	{ WriteString("maxdepth"); }
! MIST		: tMIST		{ WriteString("atmosphere mist"); }
  OBJECT		: tOBJECT	{ WriteString("object"); }
  OUTFILE		: tOUTFILE	{ WriteString("outfile"); }
  PLANE		: tPLANE	{ WriteString("plane"); }


Index: libshade/yacc.y
Prereq: 4.0.1.2
*** old/libshade/yacc.y	Mon Feb  3 12:49:51 1992
--- new/libshade/yacc.y	Fri Jan 17 10:30:13 1992
***************
*** 11,17 ****
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: yacc.y,v 4.0.1.2 91/10/08 20:40:35 cek Exp Locker: cek $ */
  %{
  #include "rayshade.h"
  
--- 11,17 ----
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: yacc.y,v 4.0.1.4 92/01/10 16:29:55 cek Exp Locker: cek $ */
  %{
  #include "rayshade.h"
  
***************
*** 514,519 ****
--- 514,520 ----
  				AnimExpr AnimExpr AnimExpr
  				AnimExpr AnimExpr AnimExpr
  		{
+ 			$$ = TransXformCreate();
  			TransXformSetX0($$, $2);
  			TransXformSetY0($$, $3);
  			TransXformSetZ0($$, $4);
***************
*** 648,653 ****
--- 649,659 ----
  				Options.window[HIGH][X] = $3;
  				Options.window[LOW][Y] = $4;
  				Options.window[HIGH][Y] = $5;
+ 				/*
+ 				 * We must let ViewingSetup know
+ 				 * that a window has been defined.
+ 				 */
+ 				Options.window_set = TRUE;
  			}
  		}
  		;
***************
*** 1002,1007 ****
--- 1008,1015 ----
  			Defstack = GeomStackPop(Defstack);
  			/* Pop current surface */
  			CurSurf = SurfPop(CurSurf);
+ 			/* Make current default surf aggregate's default */
+ 			$$->surf = CurSurf->surf;
  		}
  		;
  AggregateDef	: AggregateCreate Aggdefs tEND

Index: rayview/glmethods.c
Prereq: 4.0.1.2
*** old/rayview/glmethods.c	Mon Feb  3 12:49:50 1992
--- new/rayview/glmethods.c	Fri Jan 17 10:30:33 1992
***************
*** 14,22 ****
   * There is no warranty or other guarantee of fitness of this software
   * for any purpose.  It is provided solely "as is".
   *
!  * $Id: glmethods.c,v 4.0.1.2 91/10/10 22:45:27 cek Exp $
   *
   * $Log:	glmethods.c,v $
   * Revision 4.0.1.2  91/10/10  22:45:27  cek
   * patch1: Added spotlight support.
   * 
--- 14,29 ----
   * There is no warranty or other guarantee of fitness of this software
   * for any purpose.  It is provided solely "as is".
   *
!  * $Id: glmethods.c,v 4.0.1.4 92/01/10 17:17:39 cek Exp Locker: cek $
   *
   * $Log:	glmethods.c,v $
+  * Revision 4.0.1.4  92/01/10  17:17:39  cek
+  * patch3: Added heightfield support.
+  * 
+  * Revision 4.0.1.3  91/12/13  11:43:11  cek
+  * patch3: Spot direction and spread now set correctly.
+  * patch3: Set GLC_OLDPOLYGON to 0 on sgi machines to fix VGX weirdness.
+  * 
   * Revision 4.0.1.2  91/10/10  22:45:27  cek
   * patch1: Added spotlight support.
   * 
***************
*** 40,45 ****
--- 47,53 ----
  #include "libobj/csg.h"
  #include "libobj/cylinder.h"
  #include "libobj/disc.h"
+ #include "libobj/hf.h"
  #include "libobj/grid.h"
  #include "libobj/instance.h"
  #include "libobj/list.h"
***************
*** 117,123 ****
  	CylinderMethodRegister(GLCylinderDraw);
  	DiscMethodRegister(GLDiscDraw);
  	GridMethodRegister(GLGridDraw);
! 	/*HfMethodRegister(GLHfDraw);*/
  	InstanceMethodRegister(GLInstanceDraw);
  	ListMethodRegister(GLListDraw);
  	PlaneMethodRegister(GLPlaneDraw);
--- 125,133 ----
  	CylinderMethodRegister(GLCylinderDraw);
  	DiscMethodRegister(GLDiscDraw);
  	GridMethodRegister(GLGridDraw);
! #ifdef sgi
! 	HfMethodRegister(GLHfDraw);
! #endif
  	InstanceMethodRegister(GLInstanceDraw);
  	ListMethodRegister(GLListDraw);
  	PlaneMethodRegister(GLPlaneDraw);
***************
*** 186,191 ****
--- 196,202 ----
  	ScreenDrawInit();
  	ObjectInit();
  	LightDrawInit();
+ 
  	/*
  	 * Push the default surface.
  	 */
***************
*** 203,208 ****
--- 214,224 ----
  #endif
  	prefsize(Screen.xsize, Screen.ysize);
  	winopen("rayview");
+ 
+ #ifdef sgi
+ 	glcompat(GLC_OLDPOLYGON, 0);
+ #endif
+ 
  	RGBmode();
  	mmode(MVIEWING);
  
***************
*** 214,226 ****
  
  	gconfig();
  	blendfunction(BF_SA, BF_MSA);
  	/*
  	 * Initialize viewing matrix.
  	 */
  	GLViewingInit();
  
- 	zbuffer(TRUE);
- 
  	BackPack = (unsigned char)(255*Screen.background.r) |
  		((unsigned char)(255*Screen.background.g) << 8) |
  		((unsigned char)(255*Screen.background.b) << 16);
--- 230,242 ----
  
  	gconfig();
  	blendfunction(BF_SA, BF_MSA);
+ 	zbuffer(TRUE);
+ 
  	/*
  	 * Initialize viewing matrix.
  	 */
  	GLViewingInit();
  
  	BackPack = (unsigned char)(255*Screen.background.r) |
  		((unsigned char)(255*Screen.background.g) << 8) |
  		((unsigned char)(255*Screen.background.b) << 16);
***************
*** 564,570 ****
  }
  
  static void
! GLHfDraw(){}
  
  static void
  GLInstanceDraw(inst)
--- 580,653 ----
  }
  
  static void
! GLHfDraw(hf)
! Hf *hf;
! {
! 	int x, y;
! 	float n[3], v[3], del, del2, del4, dz1, delz, za, zb, zc;
! 	float bot, top, left, right, len;
! 
! 	del = 1. / (hf->size - 1);
! 	del2 = del*del;
! 	del4 = del2*del2;
! 
! 	bot = 0.;
! 	top = del;
! 
! 	for (y = 0; y < hf->size -1; y++) {
! 		za = hf->data[y+1][0];
! 		zb = hf->data[y][0];
! 		left = 0;
! 		right = del;
! 		for (x = 1; x < hf->size; x++) {
! 			/*
! 			 * A +-+ C
! 			 *   |/
! 			 * B +
! 			 */
! 		
! 			zc = hf->data[y+1][x];
! 			dz1 = za - zb;
! 			delz = za - zc;
! 			len = sqrt(del2*delz*delz + del2*dz1*dz1 + del4);
! 			bgnpolygon();
! 			n[0] = del*delz/len;
! 			n[1] = -del*dz1/len;
! 			n[2] = del2/len;
! 			n3f(n);
! 			v[0] = left; v[1] = top; v[2] = za; v3f(v);
! 			v[1] = bot; v[2] = zb; v3f(v);
! 			v[0] = right; v[1] = top; v[2] = zc; v3f(v);
! 			endpolygon();
! 
! 			/*
! 			 *   B +
! 			 *    /|
! 			 * A +-+ C
! 			 */
! 			za = zb; zb = zc; zc = hf->data[y][x];
! 			dz1 = zc - za;
! 			delz = zc - zb;
! 			len = sqrt(del2*dz1*dz1 + del2*delz*delz + del4);
! 			n[0] = -del*dz1/len;
! 			n[1] = del*delz/len;
! 			n[2] = del2/len;
! 			bgnpolygon();
! 			n3f(n);
! 			v[0] = left; v[1] = bot; v[2] = za; v3f(v);
! 			v[0] = right; v[2] = zc; v3f(v);
! 			v[1] = top; v[2] = zb; v3f(v);
! 			endpolygon();
! 			left = right;
! 			right += del;
! 			za = zb;
! 			zb = zc;
! 		}
! 		bot = top;
! 		top += del;
! 	}
! 	
! }
  
  static void
  GLInstanceDraw(inst)
***************
*** 762,774 ****
  	lpos[1] = spot->pos.y;
  	lpos[2] = spot->pos.z;
  	lpos[3] = 1.;
! 	spotdir[0] = spot->pos.x - spot->dir.x;
! 	spotdir[1] = spot->pos.y - spot->dir.y;
! 	spotdir[2] = spot->pos.z - spot->dir.z;
  	*spotexp = spot->coef;
! 	*spotspread = spot->falloff;
  	lmdef(DEFLIGHT, curlight++, sizeof(lightprops) / sizeof(float),
  			lightprops);
  	*spotspread = 180.;
  	*spotexp = 1.;
  }
--- 845,858 ----
  	lpos[1] = spot->pos.y;
  	lpos[2] = spot->pos.z;
  	lpos[3] = 1.;
! 	spotdir[0] = spot->dir.x;
! 	spotdir[1] = spot->dir.y;
! 	spotdir[2] = spot->dir.z;
  	*spotexp = spot->coef;
! 	*spotspread = 180 * acos(spot->falloff) / PI;
  	lmdef(DEFLIGHT, curlight++, sizeof(lightprops) / sizeof(float),
  			lightprops);
+ 	/* fix up spot defs so other source methods needn't reset them. */
  	*spotspread = 180.;
  	*spotexp = 1.;
  }

Index: README
*** old/README	Mon Feb  3 12:49:52 1992
--- new/README	Fri Jan 17 10:29:21 1992
***************
*** 35,41 ****
  conversion utility, rsconvert.  See Doc/Changes for a list of some of
  the more important changes.
  
! Rayshade v4.0 Beta has been tested on several different UNIX-based computers,
  including: SGI 4D, IBM RS6000, Sun Sparcstation 1, Sun 3, DECstation,
  Apollo DN10000, NeXT.  If your machine has a C compiler, enough memory
  (at least 2Mb), and runs something resembling UNIX, rayshade should be fairly
--- 35,41 ----
  conversion utility, rsconvert.  See Doc/Changes for a list of some of
  the more important changes.
  
! Rayshade v4.0 has been tested on many different UNIX-based computers,
  including: SGI 4D, IBM RS6000, Sun Sparcstation 1, Sun 3, DECstation,
  Apollo DN10000, NeXT.  If your machine has a C compiler, enough memory
  (at least 2Mb), and runs something resembling UNIX, rayshade should be fairly
***************
*** 54,60 ****
  
  Normally, rayshade makes use of the Utah Raster toolkit.  You are
  strongly encouraged to get a copy of the toolkit, as it provides a
! host of useful tools for image manipulation and a library for reading/reading
  the toolkit's "RLE" format image files.  "blurb.urt" is the "blurb" file from
  the latest distribution of the toolkit.  Also of interest is the
  "fbm" library, available from nl.cs.cmu.edu:/usr/mlm/ftp/fbm.tar.Z, which
--- 54,60 ----
  
  Normally, rayshade makes use of the Utah Raster toolkit.  You are
  strongly encouraged to get a copy of the toolkit, as it provides a
! host of useful tools for image manipulation and a library for reading/writing
  the toolkit's "RLE" format image files.  "blurb.urt" is the "blurb" file from
  the latest distribution of the toolkit.  Also of interest is the
  "fbm" library, available from nl.cs.cmu.edu:/usr/mlm/ftp/fbm.tar.Z, which
***************
*** 140,147 ****
  William Bouma, Allen Braunsdorf, Jeff Butterworth, Nick Carriero,
  Nancy Everson, Tom Friedel, Robert Funchess, David Gelernter, Mike Gigante,
  Ed Herderick, John Knuston, Raphael Manfredi, Lee Moore, Dietmar Saupe,
! Brian Wyvill, and everybody else for their bugfixes, suggestions, input files,
! encouragement, and other feedback.
  
  Thanks also to Mark Podlipec for providing the blob and torus objects.
  
--- 140,147 ----
  William Bouma, Allen Braunsdorf, Jeff Butterworth, Nick Carriero,
  Nancy Everson, Tom Friedel, Robert Funchess, David Gelernter, Mike Gigante,
  Ed Herderick, John Knuston, Raphael Manfredi, Lee Moore, Dietmar Saupe,
! Iain Sinclair, Brian Wyvill, and everybody else for their bugfixes,
! suggestions, input files, encouragement, and other feedback.
  
  Thanks also to Mark Podlipec for providing the blob and torus objects.
  
***************
*** 149,155 ****
  His code, and a host of other useful routines, can be found in
  "Graphics Gems", edited by Andrew Glassner.
  
! Thanks to Benoit Mandelbrot for his support and inspiration.
  
  If you find any bugs, make any useful extensions, have a nice input file,
  port rayshade to a new environment, or need assistance understanding a
--- 149,155 ----
  His code, and a host of other useful routines, can be found in
  "Graphics Gems", edited by Andrew Glassner.
  
! Thanks to Benoit Mandelbrot for the support he provided this project.
  
  If you find any bugs, make any useful extensions, have a nice input file,
  port rayshade to a new environment, or need assistance understanding a
***************
*** 162,169 ****
  
  Craig Kolb
  Rod Bogart
! 9 October 1991
! rayshade@weedeater.math.yale.edu
  
  Craig Kolb 
  Computer Science Department
--- 162,169 ----
  
  Craig Kolb
  Rod Bogart
! 10 January 1992
! rayshade-request@cs.yale.edu
  
  Craig Kolb 
  Computer Science Department


Index: raypaint/README
*** old/raypaint/README	Mon Feb  3 12:42:23 1992
--- new/raypaint/README	Fri Jan 17 10:30:23 1992
***************
*** 17,26 ****
  
  The middle mouse button may be used to sweep out a rectangular region to
  which raypaint should restrict its refinement:  Press and hold the middle
! mouse button while pointing at one corner of the region on interest,
  drag the cursor to the opposite corner and release the mouse button.
  Note that no rectangle will be drawn.  Refinement will continue inside
! of the indicated region, using whatever sampling
  
  When every pixel has been sampled, an image file is written.
  
--- 17,26 ----
  
  The middle mouse button may be used to sweep out a rectangular region to
  which raypaint should restrict its refinement:  Press and hold the middle
! mouse button while pointing at one corner of the region of interest,
  drag the cursor to the opposite corner and release the mouse button.
  Note that no rectangle will be drawn.  Refinement will continue inside
! of the indicated region.
  
  When every pixel has been sampled, an image file is written.
  

Index: etc/rsconvert/lex.l
Prereq: 4.0
*** old/etc/rsconvert/lex.l	Mon Feb  3 12:42:44 1992
--- new/etc/rsconvert/lex.l	Fri Jan 17 10:29:21 1992
***************
*** 10,16 ****
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: lex.l,v 4.0 91/07/17 14:29:16 kolb Exp Locker: kolb $ */
  %{
  #include "config.h"
  #include <stdio.h>
--- 10,16 ----
  /* 									   */
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
! /* $Id: lex.l,v 4.0.1.1 91/11/26 21:12:29 cek Exp Locker: cek $ */
  %{
  #include "config.h"
  #include <stdio.h>
***************
*** 29,37 ****
  string	({alpha}|"/")({alpha}|{digit}|{special}|"/")*
  %p 3000
  %%
! [\t\n]			{WriteVerbatim(yytext);};
  " "			{};
! ^#			{handlehash();}
  "/*"			{skipcomments();}
  adaptive		{return(tADAPTIVE);}
  aperture		{return(tAPERTURE);}
--- 29,38 ----
  string	({alpha}|"/")({alpha}|{digit}|{special}|"/")*
  %p 3000
  %%
! [\t]			{WriteVerbatim(yytext);};
! "\n"			{};
  " "			{};
! ^#			{return handlehash();}
  "/*"			{skipcomments();}
  adaptive		{return(tADAPTIVE);}
  aperture		{return(tAPERTURE);}
***************
*** 111,116 ****
--- 112,118 ----
  		WriteChar(c);
  		if ((c = input()) == '/') {
  			WriteChar(c);
+ 			WriteNewline();
  			return;
  		}
  		unput(c);
***************
*** 127,133 ****
  handlehash()
  {
  	char buf[BUFSIZ];
! 	int i;
  	extern int yylineno;
  	extern char yyfilename[];
  
--- 129,135 ----
  handlehash()
  {
  	char buf[BUFSIZ];
! 	int i, linenumber;
  	extern int yylineno;
  	extern char yyfilename[];
  
***************
*** 139,162 ****
  	unput(buf[i]);		/* To make sure consecutive # lines work. */
  	buf[i] = (char)NULL;	/* Replace newline with NULL. */
  
! 	/*
! 	 * Check to see if it's #include or
! 	 * #define.
! 	 * If so just spit out the line.
! 	 */
! 	if (strncmp("include", buf, 7) == 0 || strncmp("define", buf, 6) == 0) {
! 		WriteVerbatim("#");
! 		WriteVerbatim(buf);
! 		return;
! 	}
  	/*
! 	 * Complain if the line was not of the form #n "filename"
  	 */
! 	if ((i = sscanf(buf, "%d \"%[^\"]s\"", &yylineno, yyfilename)) == 0) {
! 		yyerror("Unknown '#' control.");
! 		exit(1);
! 	}
! 	if (i == 1) {
  #ifdef SYSV
  		if (strchr(buf, '"') != (char *)0) {
  #else
--- 141,153 ----
  	unput(buf[i]);		/* To make sure consecutive # lines work. */
  	buf[i] = (char)NULL;	/* Replace newline with NULL. */
  
! 	yylval.c = strsave(buf);
! 
  	/*
! 	 * Set file/line if the line was of the form #n "filename"
  	 */
! 	if ((i = sscanf(buf, "%d \"%[^\"]s\"", &linenumber, buf)) != 0) {
! 		yylineno = linenumber;
  #ifdef SYSV
  		if (strchr(buf, '"') != (char *)0) {
  #else
***************
*** 166,171 ****
  			 * Filename was "", which means stdin.
  			 */
  			strcpy(yyfilename, "stdin");
! 		}
  	}
  }
--- 157,164 ----
  			 * Filename was "", which means stdin.
  			 */
  			strcpy(yyfilename, "stdin");
! 		} else
! 			strcpy(yyfilename, buf);
  	}
+ 	return tHASHTHING;
  }


Index: libshade/lex.l
Prereq: 4.0.1.2
*** old/libshade/lex.l	Mon Feb  3 12:49:59 1992
--- new/libshade/lex.l	Fri Jan 17 10:30:08 1992
***************
*** 11,17 ****
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
  /*									   */
! /* $Id: lex.l,v 4.0.1.2 91/10/08 20:25:59 cek Exp Locker: cek $ */
  %{
  #include "config.h"
  #include "rayshade.h"
--- 11,17 ----
  /* There is no warranty or other guarantee of fitness of this software	   */
  /* for any purpose.  It is provided solely "as is".			   */
  /*									   */
! /* $Id: lex.l,v 4.0.1.3 92/01/14 18:28:38 cek Exp Locker: cek $ */
  %{
  #include "config.h"
  #include "rayshade.h"
***************
*** 201,217 ****
  	/*
  	 * Complain if the line was not of the form #n "filename"
  	 */
! 	if ((i = sscanf(buf, "%d \"%[^\"]s\"", &yylineno, yyfilename)) == 0) {
! 		RLerror(RL_PANIC, "Unknown '#' control (%s).",buf);
  		exit(1);
  	}
! 	if (i == 1) {
! 		if (index(buf, '"') != (char *)NULL) {
! 			/*
! 			 * Filename was "", which means stdin.
! 			 */
! 			(void)strcpy(yyfilename, "stdin");
! 		}
  	}
  	yylineno--;  /* The newline we unput will increment yylineno */
  }
--- 201,216 ----
  	/*
  	 * Complain if the line was not of the form #n "filename"
  	 */
! 	if ((i = sscanf(buf,"%d \"%[^\"]s\"", &yylineno, yyfilename)) == 0 &&
! 	    (i = sscanf(buf," line %d \"%[^\"]s\"",&yylineno,yyfilename))==0) {
! 		RLerror(RL_PANIC, "Unknown '#' control (%s).\n",buf);
  		exit(1);
  	}
! 	if (i == 1 && (index(buf,'"') != (char *)NULL)) {
! 		/*
! 		 * Filename was given as ""
! 		 */
! 		(void)strcpy(yyfilename, "stdin");
  	}
  	yylineno--;  /* The newline we unput will increment yylineno */
  }

Index: Doc/Guide/animate.tex
*** old/Doc/Guide/animate.tex	Mon Feb  3 12:49:57 1992
--- new/Doc/Guide/animate.tex	Fri Jan 17 10:29:12 1992
***************
*** 1,6 ****
  \chapter{Animation}
  
! \Rayshade provides basic animation animation support by
  allowing time-varying
  transformations to be associated with primitives and aggregate objects.
  Commands are provided for controlling the amount of time between each
--- 1,6 ----
  \chapter{Animation}
  
! {\Rayshade}\ provides basic animation animation support by
  allowing time-varying
  transformations to be associated with primitives and aggregate objects.
  Commands are provided for controlling the amount of time between each
***************
*** 7,15 ****
  frame, the speed of the camera shutter, and the total number of frames
  to be rendered.
  
! By default, rayshade renders a single frame, with the shutter open for
  an instant (0 units of time, in fact).  The shutter speed in no way
! changes the light-gathering properties of the camera, i.e. frames
  rendered using
  a longer exposure will not appear brighter than those with a shorter
  exposure.  The only change will be in the potential amount of movement
--- 7,15 ----
  frame, the speed of the camera shutter, and the total number of frames
  to be rendered.
  
! By default, {\rayshade} renders a single frame, with the shutter open for
  an instant (0 units of time, in fact).  The shutter speed in no way
! changes the light-gathering properties of the camera, i.e., frames
  rendered using
  a longer exposure will not appear brighter than those with a shorter
  exposure.  The only change will be in the potential amount of movement
***************
*** 16,22 ****
  that the
  frame ``sees'' during the time that the shutter is open.
  
! Each ray cast by \rayshade samples a particular moment in time.
  The time value assigned to a ray
  ranges from the starting time of the current frame to the starting
  time plus the amount of time the shutter is open.  When
--- 16,22 ----
  that the
  frame ``sees'' during the time that the shutter is open.
  
! Each ray cast by {\rayshade} samples a particular moment in time.
  The time value assigned to a ray
  ranges from the starting time of the current frame to the starting
  time plus the amount of time the shutter is open.  When
***************
*** 27,33 ****
  computations are performed.
  
  The starting time of the current frame is computed using the
! lenth of each frame
  the current frame number, and the starting time of the first frame.
  
  \begin{defkey}{shutter}{{\em t}}
--- 27,33 ----
  computations are performed.
  
  The starting time of the current frame is computed using the
! length of each frame
  the current frame number, and the starting time of the first frame.
  
  \begin{defkey}{shutter}{{\em t}}
***************
*** 73,79 ****
  The second animated variable, {\tt frame}, is equal to the current
  frame number.  Unlike the {\tt time} variable, {\tt frame} takes on
  a single value for the duration of each frame.  Thus, transforms
! animated through the use of the {\tt time} variable will not exhibit
  motion blurring.
  
  Also supported is the {\tt linear} function.  This function uses
--- 73,79 ----
  The second animated variable, {\tt frame}, is equal to the current
  frame number.  Unlike the {\tt time} variable, {\tt frame} takes on
  a single value for the duration of each frame.  Thus, transforms
! animated through the use of the {\tt frame} variable will not exhibit
  motion blurring.
  
  Also supported is the {\tt linear} function.  This function uses
***************
*** 81,87 ****
  
  \begin{defkey}{linear}{{\tt (} {\em Stime, Sval, Etime, Eval} {\tt )}}
  	Linearly interpolate between {\em Sval} at time
! 	{\em Stime} and {\em Etime} at time {\em Eval}.
  	If the current time is less than {\em Stime}, the function
  	returns {\em Sval}.  If the current time is greater than
  	{\em Etime}, {\em Eval} is returned.
--- 81,87 ----
  
  \begin{defkey}{linear}{{\tt (} {\em Stime, Sval, Etime, Eval} {\tt )}}
  	Linearly interpolate between {\em Sval} at time
! 	{\em Stime} and {\em Eval} at time {\em Etime}.
  	If the current time is less than {\em Stime}, the function
  	returns {\em Sval}.  If the current time is greater than
  	{\em Etime}, {\em Eval} is returned.
***************
*** 99,102 ****
  \end{verbatim}
  
  Further examples of animation may be found in the Examples directory
! of the \rayshade distribution.
--- 99,102 ----
  \end{verbatim}
  
  Further examples of animation may be found in the Examples directory
! of the {\rayshade} distribution.

Index: Doc/Guide/intro.tex
*** old/Doc/Guide/intro.tex	Mon Feb  3 12:42:31 1992
--- new/Doc/Guide/intro.tex	Fri Jan 17 10:29:12 1992
***************
*** 1,7 ****
  \chapter{Introduction}
  \pagenumbering{arabic}
  
! This document describes \rayshade in enough detail to enable
  the technical-minded to
  sit down and render some images.  In its current form,
  it is truly a draft, and even then
--- 1,7 ----
  \chapter{Introduction}
  \pagenumbering{arabic}
  
! This document describes {\rayshade} in enough detail to enable
  the technical-minded to
  sit down and render some images.  In its current form,
  it is truly a draft, and even then
***************
*** 10,34 ****
  This document does not provide any kind of thorough introduction
  to the basics of computer graphics or ray tracing.
  There are many other excellent sources for this kind of information.
! The technical and coding details of \rayshade and
  its libraries will be documented elsewhere.
  
  \section{Getting Started}
  
! The best way to learn how to use \rayshade is to dive right in and
  start making pictures.  Study the example
! input files that are packaged with {\em rayshade}.  Run them through
! rayshade to see what the images they produce look like.
  Change the input files; move the camera,
  change the field of view, modify surface properties, and see what differences
  your changes make, all the while referring to the appropriate portions
  of this document.  Browse through the individual chapters
! to see what \rayshade can and cannot do.  The \rayshade quick reference
  guide may also help you sort out syntactical nasties.
  
  Throughout this text, the {\tt typewriter} type style is used to indicate
  keywords and other items that should be passed
! directly {\em rayshade}.  Where appropriate,
  items in an {\em italic\/} style indicate
  places where you should provide an appropriate number or string.
  
--- 10,34 ----
  This document does not provide any kind of thorough introduction
  to the basics of computer graphics or ray tracing.
  There are many other excellent sources for this kind of information.
! The technical and coding details of {\rayshade} and
  its libraries will be documented elsewhere.
  
  \section{Getting Started}
  
! The best way to learn how to use {\rayshade} is to dive right in and
  start making pictures.  Study the example
! input files that are packaged with {\rayshade}.  Run them through
! {\rayshade} to see what the images they produce look like.
  Change the input files; move the camera,
  change the field of view, modify surface properties, and see what differences
  your changes make, all the while referring to the appropriate portions
  of this document.  Browse through the individual chapters
! to see what {\rayshade} can and cannot do.  The {\rayshade} quick reference
  guide may also help you sort out syntactical nasties.
  
  Throughout this text, the {\tt typewriter} type style is used to indicate
  keywords and other items that should be passed
! directly to {\rayshade}.  Where appropriate,
  items in an {\em italic\/} style indicate
  places where you should provide an appropriate number or string.
  
***************
*** 43,53 ****
  
  \section{A Simple Example}
  
! Because \rayshade provides a default camera description, surface properties,
  and a default light
  source, it is easy to construct short input files that allow you to
  experiment with objects, textures, and transformations.
! If you haven't already run \rayshade on one of the example input files,
  you might want to try producing an image using the following input:
  
  \begin{verbatim}
--- 43,53 ----
  
  \section{A Simple Example}
  
! Because {\rayshade} provides a default camera description, surface properties,
  and a default light
  source, it is easy to construct short input files that allow you to
  experiment with objects, textures, and transformations.
! If you haven't already run {\rayshade} on one of the example input files,
  you might want to try producing an image using the following input:
  
  \begin{verbatim}
***************
*** 54,60 ****
     sphere 2 0 0 0
  \end{verbatim}
  
! If you are running \rayshade on a UNIX\footnote{UNIX is a trademark
  of AT\&T Bell Laboratories}-like machine, the command:
  \begin{verbatim}
    echo "sphere 2 0 0 0" | rayshade > sphere.rle
--- 54,60 ----
     sphere 2 0 0 0
  \end{verbatim}
  
! If you are running {\rayshade} on a UNIX\footnote{UNIX is a trademark
  of AT\&T Bell Laboratories}-like machine, the command:
  \begin{verbatim}
    echo "sphere 2 0 0 0" | rayshade > sphere.rle

Index: libray/libsurf/surfshade.c
Prereq: 4.0
*** old/libray/libsurf/surfshade.c	Mon Feb  3 12:42:45 1992
--- new/libray/libsurf/surfshade.c	Fri Jan 17 10:29:47 1992
***************
*** 13,21 ****
   * There is no warranty or other guarantee of fitness of this software
   * for any purpose.  It is provided solely "as is".
   *
!  * $Id: surfshade.c,v 4.0 91/07/17 14:41:15 kolb Exp Locker: kolb $
   *
   * $Log:	surfshade.c,v $
   * Revision 4.0  91/07/17  14:41:15  kolb
   * Initial version.
   * 
--- 13,28 ----
   * There is no warranty or other guarantee of fitness of this software
   * for any purpose.  It is provided solely "as is".
   *
!  * $Id: surfshade.c,v 4.0.1.2 92/01/10 14:08:28 cek Exp Locker: cek $
   *
   * $Log:	surfshade.c,v $
+  * Revision 4.0.1.2  92/01/10  14:08:28  cek
+  * patch3: Fixed additional composition problems.
+  * 
+  * Revision 4.0.1.1  91/12/13  11:54:51  cek
+  * patch3: Fixed ordering of world/model xform composition.
+  * patch3: Geometric normal now transformed correctly.
+  * 
   * Revision 4.0  91/07/17  14:41:15  kolb
   * Initial version.
   * 
***************
*** 67,72 ****
--- 74,80 ----
  	 */
  	for (i = 0, hp = hitlist->data; i < hitlist->nodes -1; hp++, i++) {
  		obj = hp->obj;
+ 		texturing = texturing || obj->texture;
  		if (hp->dotrans) {
  			/*
  			 * Here we're actually computing prim2world.
***************
*** 73,87 ****
  			 * When finished, we invert it.
  			 */
  			if (transforming) {
! 				TransCompose(&hp->trans, &world2model,
  					&world2model);
  			} else {
  				TransCopy(&hp->trans, &world2model);
  			}
- 			transforming = TRUE;
  		}
- 		if (obj->texture)
- 			texturing = TRUE;
  	}
  
  	/*
--- 81,93 ----
  			 * When finished, we invert it.
  			 */
  			if (transforming) {
! 				TransCompose(&world2model, &hp->trans,
  					&world2model);
  			} else {
  				TransCopy(&hp->trans, &world2model);
+ 				transforming = TRUE;
  			}
  		}
  	}
  
  	/*
***************
*** 150,156 ****
  	TransInit(&prim2model);
  	rtmp = hitlist->data[0].ray;
  	/*
! 	 * Walk down hitlist.
  	 */
  	for (hp = hitlist->data, i = 0; i < hitlist->nodes -1; i++, hp++) {
  		obj = hp->obj;
--- 156,166 ----
  	TransInit(&prim2model);
  	rtmp = hitlist->data[0].ray;
  	/*
! 	 * Walk down hitlist (from primitive up to World object),
! 	 * transforming hit point and shading normal and applying textures.
! 	 * Note that the texturing routines want gnorm in object space,
! 	 * so we don't transform the geometric normal until texturing
! 	 * is complete.
  	 */
  	for (hp = hitlist->data, i = 0; i < hitlist->nodes -1; i++, hp++) {
  		obj = hp->obj;
***************
*** 161,169 ****
  				 * Compose prim<-->model and world<-->model
  				 * with current transformation.
  				 */
! 				TransCompose(&hp->trans, &prim2model,
  					&prim2model);
! 				TransCompose(&hp->trans, &world2model,
  					&world2model);
  				/*
  				 * Transform point and ray to model space.
--- 171,179 ----
  				 * Compose prim<-->model and world<-->model
  				 * with current transformation.
  				 */
! 				TransCompose(&prim2model, &hp->trans,
  					&prim2model);
! 				TransCompose(&world2model, &hp->trans,
  					&world2model);
  				/*
  				 * Transform point and ray to model space.
***************
*** 179,183 ****
--- 189,195 ----
  			TextApply(obj->texture, prim, &rtmp, pos, norm,
  				gnorm, surf, &prim2model, &world2model);
  	}
+ 	/* Transform geometric normal from object to world space. */
+ 	NormalTransform(gnorm, &world2model.trans);
  	return entering;
  }

Index: Doc/Guide/texture.tex
*** old/Doc/Guide/texture.tex	Mon Feb  3 12:50:02 1992
--- new/Doc/Guide/texture.tex	Fri Jan 17 10:29:15 1992
***************
*** 45,50 ****
--- 45,52 ----
  The returned normalized vector is weighted by {\em scale}
  and the result is added to the normal vector at the point of intersection.
  \end{defkey}
+ Using an image texture applied to the ``bump'' component offers a more
+ direct way to control the modification of surface normals (see below).
  
  \begin{defkey}{checker}{$<${\em Surface}$>$}
  Applies a 3D checkerboard texture.  Every point that falls within an
***************
*** 144,150 ****
  	of {\em bump} controls the extent to which the bump appears
  	to be displaced from the rest of the surface.  If negative,
  	the stripe will appear to
! 	sink into the surface; if negative, it will appear to stand
  	out of the surface.
  \end{defkey}
  Mapping functions are described below.
--- 146,152 ----
  	of {\em bump} controls the extent to which the bump appears
  	to be displaced from the rest of the surface.  If negative,
  	the stripe will appear to
! 	sink into the surface; if positive, it will appear to stand
  	out of the surface.
  \end{defkey}
  Mapping functions are described below.
***************
*** 157,163 ****
  
  \section {Image Texturing}
  
! {\em Rayshade} also supports an {\tt image} texture.  This texture
  allows you to use images to modify the characteristics of a surface.  You
  can use three-channel images to modify the any or all of
  the ambient, diffuse, and specular colors of a surface.
--- 159,165 ----
  
  \section {Image Texturing}
  
! {\Rayshade} also supports an {\tt image} texture.  This texture
  allows you to use images to modify the characteristics of a surface.  You
  can use three-channel images to modify the any or all of
  the ambient, diffuse, and specular colors of a surface.
***************
*** 222,228 ****
  	should be repeated along the $v$ axis.  If either value is zero,
  	the image is repeated infinitely along the appropriate axis.
  \end{defkey}
! Tiling is usually only a concern when linear mapping is being used,
  though it may also be used if image textures are being scaled.  By default
  {\em un} and {\em vn} are both zero.
   
--- 224,230 ----
  	should be repeated along the $v$ axis.  If either value is zero,
  	the image is repeated infinitely along the appropriate axis.
  \end{defkey}
! Tiling is usually only a concern when planar mapping is being used,
  though it may also be used if image textures are being scaled.  By default
  {\em un} and {\em vn} are both zero.
   


*** End of Patch 4 ***

exit 0 # Just in case...
