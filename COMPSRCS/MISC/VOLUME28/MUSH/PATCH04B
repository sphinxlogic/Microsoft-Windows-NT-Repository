Newsgroups: comp.sources.misc
From: bart@zigzag.z-code.com (Bart Schaefer)
Subject:  v28i068:  mush - Mail User's Shell, Patch04b/2
Message-ID: <1992Feb24.033819.12932@sparky.imd.sterling.com>
X-Md4-Signature: df73ebc2fcce81daa2ff599e817b4448
Date: Mon, 24 Feb 1992 03:38:19 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: bart@zigzag.z-code.com (Bart Schaefer)
Posting-number: Volume 28, Issue 68
Archive-name: mush/patch04b
Environment: UNIX
Patch-To: mush: Volume 18, Issue 58-79

This is Part 02 of Official Patch #4 for Mush 7.2.  To apply this patch,
save this message to a file in your mush source directory and type:

	patch -N -p1 < file

See Part 01 for a description of the changes in this patch.  You can apply
the two parts in any order, but you must apply both parts before applying
the additional Apollo patches that are included in Part 01.

Prereq: 7.2.3"
*** 7.2.3/mush.1	Wed May 22 23:29:51 1991
--- 7.2.4/mush.1	Sun Feb  2 14:35:12 1992
***************
*** 10,16 ****
  .if n .ds - --
  .if t .ds - \(em
  .nh
! .TH MUSH 1 "May 22, 1991" "Version 7.2.3"
  .SH NAME
  The Mail User's Shell \- Shell for electronic mail.
  .SH SYNOPSIS
--- 10,16 ----
  .if n .ds - --
  .if t .ds - \(em
  .nh
! .TH MUSH 1 "Feb 2, 1992" "Version 7.2.4"
  .SH NAME
  The Mail User's Shell \- Shell for electronic mail.
  .SH SYNOPSIS
***************
*** 578,583 ****
--- 578,584 ----
  .BR pager ,
  environment PAGER, or the default pager set up by the system administrator.
  This may be the internal pager.
+ To completely disable paging, set pager to \*QNONE\*U.
  .TP
  ~q
  Quit message; save in ~/dead.letter if
***************
*** 3057,3063 ****
  If it is set, but has no value, the first \*QFrom\ \*U line is used
  regardless of what headers the author's message contains.
  The \*QFrom\ \*U line may be specified explicitly as an item in the
! list of reply-to headers by specifying the header \*Q\fBFrom_\fB\*U.
  See the VARIABLES section for more information about
  .B reply_to_hdr.
  .sp
--- 3058,3064 ----
  If it is set, but has no value, the first \*QFrom\ \*U line is used
  regardless of what headers the author's message contains.
  The \*QFrom\ \*U line may be specified explicitly as an item in the
! list of reply-to headers by specifying the header \*Q\fBFrom_\fR\*U.
  See the VARIABLES section for more information about
  .B reply_to_hdr.
  .sp
***************
*** 3220,3226 ****
  mail \-i $reports boss
  .sp
  This command sends mail to \*Qboss\*U and includes the text of all the
! messages held in the \fIreports\fP variable.
  .TP
  .BR sh " [command]"
  Invokes an interactive version of the shell.
--- 3221,3227 ----
  mail \-i $reports boss
  .sp
  This command sends mail to \*Qboss\*U and includes the text of all the
! messages held in the \fIreports\fR variable.
  .TP
  .BR sh " [command]"
  Invokes an interactive version of the shell.
***************
*** 3486,3492 ****
  command are always ignored.
  Normally, ignored headers are not ignored when sending messages to
  the printer, when interpolating messages into letters with ~f or ~I,
! when the `P' or `T' command is given (see the \fBprint\f command),
  or with the \-I flag to the
  .B mail
  or
--- 3487,3493 ----
  command are always ignored.
  Normally, ignored headers are not ignored when sending messages to
  the printer, when interpolating messages into letters with ~f or ~I,
! when the `P' or `T' command is given (see the \fBprint\fR command),
  or with the \-I flag to the
  .B mail
  or
***************
*** 3664,3670 ****
  See the MAIL ADDRESSES section for more detailed information
  about legal mail addresses.
  .sp
! Note that the -r flag to \fBreply\fR and \fRreplyall\fR overrides the
  value of \fBauto_route\fR.
  .TP
  .B autosign
--- 3665,3671 ----
  See the MAIL ADDRESSES section for more detailed information
  about legal mail addresses.
  .sp
! Note that the -r flag to \fBreply\fR and \fBreplyall\fR overrides the
  value of \fBauto_route\fR.
  .TP
  .B autosign
*** 7.2.3/addrs.c	Thu May 16 18:28:22 1991
--- 7.2.4/addrs.c	Wed Nov 13 00:53:20 1991
***************
*** 654,660 ****
  	if (*str)
  	    *b++ = ',', *b++ = ' ', *b = '\0';
      } while (*str);
!     for (b--; b > start && (*b == ',' || isspace(*b)); b--)
  	*b = 0;
      (void) strcpy(start, buf);
  }
--- 654,660 ----
  	if (*str)
  	    *b++ = ',', *b++ = ' ', *b = '\0';
      } while (*str);
!     for (b--; b > buf && (*b == ',' || isspace(*b)); b--)
  	*b = 0;
      (void) strcpy(start, buf);
  }
*** 7.2.3/bind.c	Thu May 16 18:28:25 1991
--- 7.2.4/bind.c	Sat Dec  7 16:51:57 1991
***************
*** 292,300 ****
  	/* Subtract ret and iscurses to signal output */
  	return help(0, unbind? name+2 : name, cmd_help) - ret - iscurses;
  
-     if (iscurses)
- 	on_intr();
- 
      if (unbind) {
  	if (!*argv) {
  	    char savec = complete;
--- 292,297 ----
***************
*** 302,312 ****
  	    print("%s what? ", name);
  	    len = Getstr(buf, sizeof buf, 0);
  	    complete = savec;
! 	    if (len <= 0) {
! 		if (iscurses)
! 		    off_intr();
  		return -1;
- 	    }
  	    rawstr = m_xlate(buf);
  	} else
  	    rawstr = m_xlate(*argv);
--- 299,306 ----
  	    print("%s what? ", name);
  	    len = Getstr(buf, sizeof buf, 0);
  	    complete = savec;
! 	    if (len <= 0)
  		return -1;
  	    rawstr = m_xlate(buf);
  	} else
  	    rawstr = m_xlate(*argv);
***************
*** 314,321 ****
  	    (void) ctrl_strcpy(ascii, rawstr, TRUE);
  	    print("\"%s\" isn't bound to a command.\n", ascii);
  	}
- 	if (iscurses)
- 	    off_intr();
  	return ret;
      }
      if (argv && *argv) {
--- 308,313 ----
***************
*** 341,348 ****
  		print("\"%s\" isn't mapped.\n", ascii);
  	    else
  		print("\"%s\" isn't bound to a command.\n", ascii);
- 	    if (iscurses)
- 		off_intr();
  	    return ret;
  	}
      } else {
--- 333,338 ----
***************
*** 361,379 ****
  		add_to_ret = !c_macro(name, NULL, *map_list);
  	    else
  		add_to_ret = !c_bind(NULL, *map_list);
- 	    if (iscurses)
- 		off_intr();
  	    /* signal CTND_CMD if there was output */
  	    return ret - add_to_ret;
  	}
! 	if (len < 0) {
! 	    if (iscurses)
! 		off_intr();
  	    return ret;
- 	}
  	rawstr = m_xlate(string);
  	(void) ctrl_strcpy(ascii, rawstr, TRUE);
      }
      /* if a binding was given on the command line */
      if (argv && *argv && !map)
  	if (is_bind_macro)
--- 351,368 ----
  		add_to_ret = !c_macro(name, NULL, *map_list);
  	    else
  		add_to_ret = !c_bind(NULL, *map_list);
  	    /* signal CTND_CMD if there was output */
  	    return ret - add_to_ret;
  	}
! 	if (len < 0)
  	    return ret;
  	rawstr = m_xlate(string);
  	(void) ctrl_strcpy(ascii, rawstr, TRUE);
      }
+ 
+     if (iscurses)
+ 	on_intr();
+ 
      /* if a binding was given on the command line */
      if (argv && *argv && !map)
  	if (is_bind_macro)
*** 7.2.3/command2.c	Thu May 16 18:28:34 1991
--- 7.2.4/command2.c	Sun Dec 15 10:03:34 1991
***************
*** 56,62 ****
  char **argv;
  {
      register char *p;
!     char buf[128];
  
      if (*++argv && !strcmp(*argv, "-?"))
  	return help(0, "shell", cmd_help);
--- 56,62 ----
  char **argv;
  {
      register char *p;
!     char buf[BUFSIZ];
  
      if (*++argv && !strcmp(*argv, "-?"))
  	return help(0, "shell", cmd_help);
***************
*** 196,201 ****
--- 196,202 ----
  
      if (argv && argv[1] && !strcmp(argv[1], "-?"))
  	return help(0, "stty", cmd_help);
+     echo_on();
      turnon(glob_flags, ECHO_FLAG);
      execute(argv);
      if (save_echo)
*** 7.2.3/commands.c	Thu May 16 18:28:38 1991
--- 7.2.4/commands.c	Wed Nov 13 01:25:17 1991
***************
*** 302,308 ****
      register FILE	*mail_fp = NULL_FILE;
      register char 	*file = NULL, *mode, firstchar = **argv, *tmp = ".";
      int 		msg_number, force = 0, by_subj = 0, by_author = 0;
!     char		buf[MAXPATHLEN];
      long 		flg = 0;
  
      while (*++argv)
--- 302,308 ----
      register FILE	*mail_fp = NULL_FILE;
      register char 	*file = NULL, *mode, firstchar = **argv, *tmp = ".";
      int 		msg_number, force = 0, by_subj = 0, by_author = 0;
!     char		buf[MAXPATHLEN], fbuf[MAXPATHLEN];
      long 		flg = 0;
  
      while (*++argv)
***************
*** 350,356 ****
  	print("%s is a directory\n", file);
  	return -1;
      }
!     file = tmp;
      if (force || Access(file, F_OK))
  	mode = "w", force = 0;
      else
--- 350,356 ----
  	print("%s is a directory\n", file);
  	return -1;
      }
!     file = strcpy(fbuf, tmp); /* getpath() called again later, save result */
      if (force || Access(file, F_OK))
  	mode = "w", force = 0;
      else
***************
*** 549,555 ****
  	path = getpath(buf, &x);
  	if (x != 1 || chdir(path) == -1) {
  	    err = errno;
! 	    if (cdpath) {
  		char c;
  		if (p2 = any(cdpath, " \t:"))
  		    c = *p2, *p2 = 0;
--- 549,555 ----
  	path = getpath(buf, &x);
  	if (x != 1 || chdir(path) == -1) {
  	    err = errno;
! 	    if (cdpath && *cdpath) {
  		char c;
  		if (p2 = any(cdpath, " \t:"))
  		    c = *p2, *p2 = 0;
***************
*** 558,566 ****
  		    *p2 = c;
  		while (cdpath && (isspace(*cdpath) || *cdpath == ':'))
  		    cdpath++;
! 	    }
  	}
!     } while (err && cdpath && *cdpath);
      if (err)
  	error(p);
      set_cwd();
--- 558,567 ----
  		    *p2 = c;
  		while (cdpath && (isspace(*cdpath) || *cdpath == ':'))
  		    cdpath++;
! 	    } else
! 		break;
  	}
!     } while (err);
      if (err)
  	error(p);
      set_cwd();
*** 7.2.3/config.h-dist	Thu May 16 19:51:21 1991
--- 7.2.4/config.h-dist	Sun Feb  2 14:03:44 1992
***************
*** 135,158 ****
  #endif /* M_XENIX */
  #endif /* MMDF */
  
  /* If your mailer does not understand commas between addresses, you should
   * define NO_COMMAS.  This includes pre-3.0 smail and default MTAs used on
   * xenix, and sys-v systems.
!  * This does NOT apply to MMDF or sendmail, in most cases.
   */
  #ifdef SUN_4_1		/* SunOS 4.1 has warped sendmail.cf */
  #define NO_COMMAS /**/
! #endif /* SUN_4_1
  
  /*
!  * Most RFC822 compliant mailers (sendmail) will add the headers From:
   * and Date: on outgoing mail.  If the user or UA sends these headers,
!  * most MTAs will not append them automatically.  However, there are
!  * certain MTAs which will not allow this -- these "picky mailers" will
!  * precede such headers with a '>' and make the headers very ugly and
!  * somewhat redundant or contradictory.  It is advisable to set this
!  * *UNLESS* your MTA is not RFC822 compiant -- therefore you should NOT
!  * set this (xenix, sys-v).
   */
  /* #define PICKY_MAILER /**/
  
--- 135,180 ----
  #endif /* M_XENIX */
  #endif /* MMDF */
  
+ #ifdef HOMEMAIL
+ #define MAILFILE	"Mailbox"	/* or whatever */
+ #else /* HOMEMAIL */
+ #ifndef MAILDIR
+ #if defined(SYSV) && !defined(SVR4)
+ #define MAILDIR		"/usr/mail"
+ #else /* BSD || SVR4 */
+ #define MAILDIR		"/usr/spool/mail"
+ #endif /* SYSV && !SVR4 */
+ #endif /* MAILDIR */
+ #endif /* HOMEMAIL */
+ 
  /* If your mailer does not understand commas between addresses, you should
   * define NO_COMMAS.  This includes pre-3.0 smail and default MTAs used on
   * xenix, and sys-v systems.
!  * This does NOT apply to MMDF or sendmail, in most cases.  SunOS 4.1 as
!  * shipped needs this, but note that if you are allowing mush to default
!  * to SUN_4_1 (see the end of this file) you won't get this.
   */
  #ifdef SUN_4_1		/* SunOS 4.1 has warped sendmail.cf */
  #define NO_COMMAS /**/
! #endif /* SUN_4_1 */
  
  /*
!  * Most RFC822-compliant mailers (sendmail) will add the headers From:
   * and Date: on outgoing mail.  If the user or UA sends these headers,
!  * such MTAs will generally use the headers as the user or UA set them.
!  * Mailers that are not RFC822-compliant sometimes fail to add these
!  * headers at all, so the UA must supply them.  Mush normally does so.
!  *
!  * However, there are certain MTAs which will insist on adding new From:
!  * and Date: headers.  These "picky mailers" may remove the user or UA 
!  * From: and Date: headers, or they may leave them but insert a leading
!  * '>', which makes the headers very ugly and redundant or contradictory.
!  * PICKY_MAILER prevents mush from adding From: or Date:, so the MTA can.
!  *
!  * Many RFC822-compliant mailers are "picky", including certain sendmail
!  * configurations.  It is advisable to set PICKY_MAILER *UNLESS* your MTA
!  * is known not to be RFC822 compiant (xenix, older sys-v) or can be
!  * counted on to pass through user-defined headers without modification.
   */
  /* #define PICKY_MAILER /**/
  
***************
*** 169,176 ****
   */
  /* #define GETWD	/**/
  
! #ifdef HOMEMAIL
! #define MAILFILE	"Mailbox"	/* or whatever */
! #else /* HOMEMAIL */
! #define MAILDIR		"/usr/spool/mail"
! #endif /* HOMEMAIL */
--- 191,250 ----
   */
  /* #define GETWD	/**/
  
! /* If your system has the BSD-style directory routines (opendir/readdir),
!  * define DIRECTORY.  This happens automatically in glob.h for BSD.
!  */
! #ifdef SVR4
! #define DIRECTORY
! #endif /* SVR4 */
! 
! /* If your system has the POSIX "utimbuf" structure for utime(2),
!  * define POSIX_UTIME.  You may have to change <sys/utime.h> to <utime.h>
!  * in mush.h.
!  */
! #if defined(SVR4) && !defined(sun)
! #define POSIX_UTIME
! #endif /* SVR4 && !sun */
! 
! /* The remainder of this file attempt to automatically supply some sanity.
!  * You shouldn't need to change this part unless your system is really odd.
!  */
! 
! #ifdef BSD
! #    undef SYSV /* Sorry, can't do both BSD and SYSV */
! #    undef SVR4
! #    undef SVR3
! #    undef SVR2
! #endif /* BSD */
! #if defined(SUNTOOL) || defined(SUN_3_5) || defined(SUN_4_0) || defined(SUN_4_1)
! #if !defined(BSD) && !defined(SYSV)
! #    define BSD /* default to BSD */
! #endif /* !BSD && !SYSV */
! #if !defined(SUN_3_5) && !defined(SUN_4_0)
! #    ifndef SUN_4_1
! #        define SUN_4_1 /* default to sun 4.1 */
! #    endif /* SUN_4_1 */
! #    define SUN_4_0 /* 4.0 stuff needed too */
! #endif /* !SUN_3_5 && !SUN_4_0 */
! #ifdef SUN_4_0
! #    undef SUN_3_5
! #    undef SIGRET
! #    define SIGRET void
! #endif /* SUN_4_0 */
! #endif /* SUNTOOL || SUN_3_5 || SUN_4_0 || SUN_4_1 */
! #ifdef SVR4
! #    undef SVR3
! #    undef SYSV
! #    define SYSV
! #else
! #ifdef SYSV
! #    undef SVR3
! #    ifndef SVR2
! #        define SVR3
! #    endif /* SVR2 */
! #endif /* SYSV */
! #endif /* SVR4 */
! #ifdef SVR3
! #    undef SYSV
! #    define SYSV
! #endif /* SVR3 */
*** 7.2.3/curses.c	Thu May 16 18:28:46 1991
--- 7.2.4/curses.c	Wed Jan 29 23:52:31 1992
***************
*** 538,543 ****
--- 538,544 ----
  		c = Getstr(file, COLS-22, 0);
  		off_intr();
  		if (c > 0) {
+ 		    int do_up = 0;
  		    if (!strcmp(file, "?")) {
  			clr_bot_line();
  			iscurses = 0;
***************
*** 552,564 ****
  		     * then we need to reset the updatability of current folder
  		     */
  		    c = (ison(glob_flags, DO_UPDATE))? TRUE : FALSE;
! 		    if (strcmp(file, "-?")) {
! 			redo = 1; /* so vrfy_update() won't quit */
! 			(void) vrfy_update(&redo);
  		    }
  		    move(LINES-1, 0), refresh();
! 		    if (cmd_line(sprintf(buf, "folder ! -N %s", file),
! 			     msg_list) == -1) {
  			if (c) /* remember state of updatability of folder */
  			    turnon(glob_flags, DO_UPDATE);
  			if (ison(glob_flags, CNTD_CMD))
--- 553,565 ----
  		     * then we need to reset the updatability of current folder
  		     */
  		    c = (ison(glob_flags, DO_UPDATE))? TRUE : FALSE;
! 		    if (strcmp(file, "-?") != 0) {
! 			redo = -1; /* so vrfy_update() won't update or quit */
! 			do_up = vrfy_update(&redo);
  		    }
  		    move(LINES-1, 0), refresh();
! 		    if (cmd_line(sprintf(buf, "folder %s -N %s",
! 				    do_up? "" : "!", file), msg_list) == -1) {
  			if (c) /* remember state of updatability of folder */
  			    turnon(glob_flags, DO_UPDATE);
  			if (ison(glob_flags, CNTD_CMD))
***************
*** 789,794 ****
--- 790,797 ----
  		putchar('\n');
  	    return 0;
  	}
+ 	if (*redo < 0)
+ 	    return 1;
      } else if (*redo)
  	return 1;
      if (cmd_line(strcpy(buf, *redo? "update" : "quit"), msg_list) != -1
*** 7.2.3/digestify	Thu May  3 12:39:52 1990
--- 7.2.4/digestify	Mon Dec 16 10:59:23 1991
***************
*** 1,6 ****
! #! ../bin/mush -F!
  #
  # Mush digestifier.  Makes a folder or a list of messages into a digest.
  #
  # A "digest" is a collection of E-mail messages bundled together into a
  # single message for ease of redistribution.  The individual messages
--- 1,10 ----
! #! /bin/csh -f
  #
  # Mush digestifier.  Makes a folder or a list of messages into a digest.
+ #
+ if ! $?thisfolder then
+     exec mush -F! $0 $*
+ endif
  #
  # A "digest" is a collection of E-mail messages bundled together into a
  # single message for ease of redistribution.  The individual messages
*** 7.2.3/execute.c	Sun Oct 21 19:24:32 1990
--- 7.2.4/execute.c	Thu Jan 30 00:11:31 1992
***************
*** 1,13 ****
  /* execute.c 	(c) copyright	10/28/86 (Dan Heller) */
  
  #include "mush.h"
! #ifdef BSD
  #include <sys/wait.h>
  #else
  #ifndef SYSV
  #include <wait.h>
  #endif /* SYSV */
! #endif /* BSD */
  
  #ifdef lint
  #include <sys/resource.h>
--- 1,13 ----
  /* execute.c 	(c) copyright	10/28/86 (Dan Heller) */
  
  #include "mush.h"
! #if defined(BSD) || defined(IRIX4)
  #include <sys/wait.h>
  #else
  #ifndef SYSV
  #include <wait.h>
  #endif /* SYSV */
! #endif /* BSD || IRIX4 */
  
  #ifdef lint
  #include <sys/resource.h>
***************
*** 149,155 ****
  #endif /* SYSV */
      int	   pid;
  
! #ifdef BSD
      while ((pid = wait3(&status, WNOHANG, (struct rusage *)0)) > 0) {
  	Debug("%d died...\n", pid);
  	if (pid == exec_pid)
--- 149,155 ----
  #endif /* SYSV */
      int	   pid;
  
! #if defined(BSD) || defined(IRIX4)
      while ((pid = wait3(&status, WNOHANG, (struct rusage *)0)) > 0) {
  	Debug("%d died...\n", pid);
  	if (pid == exec_pid)
***************
*** 163,169 ****
      while ((pid = wait((int *)0)) > 0 && pid != exec_pid)
  	Debug("%d died...\n", pid);
  #endif /* SYSV */
! #endif /* BSD */
      if (pid == exec_pid && pid > 0) {
  	exec_pid = 0;
  	longjmp(execjbuf, 1);
--- 163,169 ----
      while ((pid = wait((int *)0)) > 0 && pid != exec_pid)
  	Debug("%d died...\n", pid);
  #endif /* SYSV */
! #endif /* BSD || IRIX4 */
      if (pid == exec_pid && pid > 0) {
  	exec_pid = 0;
  	longjmp(execjbuf, 1);
*** 7.2.3/file.c	Wed May 22 18:18:13 1991
--- 7.2.4/file.c	Thu Jan 30 20:50:48 1992
***************
*** 3,8 ****
--- 3,15 ----
  #include "mush.h"
  #include <pwd.h>
  
+ #ifdef SYSV
+ #ifdef EWOULDBLOCK
+ #undef EWOULDBLOCK
+ #endif /* EWOULDBLOCK */
+ #define EWOULDBLOCK     EAGAIN
+ #endif /* SYSV */
+ 
  /* takes string 'p' and address of int (isdir).  If p uses the ~ to reference
   * a home directory of some sort, then expand it.  find out what sort of
   * file final path is. set isdir to 1 if a directory, 0 if not, -1 on error
***************
*** 461,467 ****
  char *file, *mode;
  {
      int omask = umask(077);
!     FILE *fp = fopen(file, mode);
      (void) umask(omask);
      return fp;
  }
--- 468,489 ----
  char *file, *mode;
  {
      int omask = umask(077);
!     FILE *fp;
! #ifdef SYSV
!     /* XENIX and other older sytems can't handle "a+".	Even newer
!      * SysV systems define a+ such that all writes go at end-of-file,
!      * not at whatever the current seek position is.  Good grief.
!      */
!     if (strcmp(mode, "a+") == 0) {
! 	if (Access(file, F_OK) == 0)
! 	    mode = "r+";
! 	else
! 	    mode = "w+";
! 	if (fp = fopen(file, mode))
! 	    (void) fseek(fp, 0L, 2); /* assure we're at the end of the file */
!     } else
! #endif /* SYSV */
!     fp = fopen(file, mode);
      (void) umask(omask);
      return fp;
  }
*** 7.2.3/folders.c	Thu May 16 18:28:55 1991
--- 7.2.4/folders.c	Fri Jan 17 09:02:29 1992
***************
*** 227,238 ****
      if (msg_cnt && (!updating || current_msg < 0))
  	current_msg = (n == msg_cnt ? 0 : n);
  
-     if ((!istool || istool && !msg_cnt) && !iscurses)
- 	mail_status(0);
      /* be quiet if we're piping */
      if (!istool && !updating && !no_hdrs && msg_cnt
! 	    && isoff(glob_flags, DO_PIPE))
  	(void) cmd_line(sprintf(buf, "headers %d", current_msg+1), msg_list);
  #ifdef SUNTOOL
      if (istool > 1) {
  	if (!msg_cnt)
--- 227,239 ----
      if (msg_cnt && (!updating || current_msg < 0))
  	current_msg = (n == msg_cnt ? 0 : n);
  
      /* be quiet if we're piping */
      if (!istool && !updating && !no_hdrs && msg_cnt
! 	    && isoff(glob_flags, DO_PIPE)) {
! 	if ((!istool || istool && !msg_cnt) && !iscurses)
! 	    mail_status(0);
  	(void) cmd_line(sprintf(buf, "headers %d", current_msg+1), msg_list);
+     }
  #ifdef SUNTOOL
      if (istool > 1) {
  	if (!msg_cnt)
*** 7.2.3/hdrs.c	Thu May 16 18:29:00 1991
--- 7.2.4/hdrs.c	Wed Nov 13 01:27:59 1991
***************
*** 350,356 ****
  int cnt, show_to;
  char *hdr_fmt;
  {
!     static char		buf[256];
      register char	*p, *p2, *b;
      int			len, do_pad = FALSE, val, pad, got_dot, isauthor = 0, n;
      char from[HDRSIZ], subject[256], date[64], lines[16];
--- 350,356 ----
  int cnt, show_to;
  char *hdr_fmt;
  {
!     static char		buf[HDRSIZ];
      register char	*p, *p2, *b;
      int			len, do_pad = FALSE, val, pad, got_dot, isauthor = 0, n;
      char from[HDRSIZ], subject[256], date[64], lines[16];
***************
*** 357,362 ****
--- 357,366 ----
      char to[256], addr[256], name[256], user[256], status[4];
      char Day[3], Mon[4], Tm[8], Yr[5], Wkday[4], Zone[8], *date_p;
  
+     buf[0] = 0;
+     if (msg_cnt < 1)
+ 	return buf;
+ 
      /* status of the message */
      if (ison(msg[cnt].m_flags, DELETE))
  	status[0] = '*';
***************
*** 739,746 ****
      if (!*p)
  	if (p2) /* take_me_off() was not done */
  	    (void) strcpy(buf, login);
  	else
! 	    (void) sprintf(buf, "%s <%s>", name, addr);
      return buf;
  }
  
--- 743,752 ----
      if (!*p)
  	if (p2) /* take_me_off() was not done */
  	    (void) strcpy(buf, login);
+ 	else if (index(name, '"'))
+ 	    (void) sprintf(buf, "<%s> (%s)", addr, name);
  	else
! 	    (void) sprintf(buf, "\"%s\" <%s>", name, addr);
      return buf;
  }
  
*** 7.2.3/init.c	Wed May 22 21:57:02 1991
--- 7.2.4/init.c	Thu Jan 30 00:14:42 1992
***************
*** 4,16 ****
  #include "mush.h"
  #include <pwd.h>
  
! #ifdef BSD
  #include <netdb.h>
! #endif /* BSD */
  
! #if defined(SYSV) && !defined(HPUX)
  #include <sys/utsname.h>
! #endif /* SYSV && !HPUX */
  
  void
  init()
--- 4,16 ----
  #include "mush.h"
  #include <pwd.h>
  
! #if defined(BSD) || defined(HPUX) || defined(IRIX4)
  #include <netdb.h>
! #endif /* BSD || HPUX || IRIX4 */
  
! #if defined(SYSV) && !defined(HPUX) && !defined(IRIX4)
  #include <sys/utsname.h>
! #endif /* SYSV && !HPUX && !IRIX4 */
  
  void
  init()
***************
*** 18,35 ****
      char 		*home, *realname, *argv[4];
      extern char		*getlogin();
      char		buf[MAXPATHLEN];
! #if defined(SYSV) && !defined(HPUX)
      extern struct passwd *getpwuid();  /* sys-v forgot this in pwd.h! */
      struct utsname ourhost;
  #else
      char ourhost[128];
! #endif /* SYSV && !HPUX */
      register char 	*p;
      struct passwd 	*entry;
      int			cnt;
! #if defined(BSD) || defined(HPUX)
      struct hostent 	*hp;
! #endif /* BSD || HPUX */
  
      home = getenv("HOME");
      if (realname = getenv("NAME")) {
--- 18,35 ----
      char 		*home, *realname, *argv[4];
      extern char		*getlogin();
      char		buf[MAXPATHLEN];
! #if defined(SYSV) && !defined(HPUX) && !defined(IRIX4)
      extern struct passwd *getpwuid();  /* sys-v forgot this in pwd.h! */
      struct utsname ourhost;
  #else
      char ourhost[128];
! #endif /* SYSV && !HPUX && !IRIX4 */
      register char 	*p;
      struct passwd 	*entry;
      int			cnt;
! #if defined(BSD) || defined(HPUX) || defined(IRIX4)
      struct hostent 	*hp;
! #endif /* BSD || HPUX || IRIX4 */
  
      home = getenv("HOME");
      if (realname = getenv("NAME")) {
***************
*** 42,48 ****
  	if (p = getlogin())
  	    strdup(login, p);
  	else {
! 	    login = "unknown";
  	    print("I don't know you, but that's ok.\n");
  	}
      else {
--- 42,48 ----
  	if (p = getlogin())
  	    strdup(login, p);
  	else {
! 	    strdup(login, "unknown");
  	    print("I don't know you, but that's ok.\n");
  	}
      else {
***************
*** 66,77 ****
  	    error(home);
  	else
  	    print("No home!? ");
! 	print_more("Using \"%s\" as home.\n", ALTERNATE_HOME);
      } else {
  	argv[0] = "home";
  	argv[2] = home;
  	(void) add_option(&set_options, argv);
      }
      if (realname && *buf) {
  	/* realname has already been copied to buf */
  	argv[0] = "realname";
--- 66,88 ----
  	    error(home);
  	else
  	    print("No home!? ");
! 	print_more("Using \"%s\" as home.\n", home = ALTERNATE_HOME);
      } else {
  	argv[0] = "home";
  	argv[2] = home;
  	(void) add_option(&set_options, argv);
      }
+ 
+ #ifdef HOMEMAIL
+     strdup(spoolfile, sprintf(buf, "%s/%s", home, MAILFILE));
+ #else /* HOMEMAIL */
+     if ((p = getenv("MAIL")) && *p)
+ 	strdup(spoolfile, p);
+     else
+ 	strdup(spoolfile, sprintf(buf, "%s/%s", MAILDIR, login));
+ #endif /* HOMEMAIL */
+     mailfile = "";
+ 
      if (realname && *buf) {
  	/* realname has already been copied to buf */
  	argv[0] = "realname";
***************
*** 84,90 ****
      escape = DEF_ESCAPE;
      prompt = DEF_PROMPT;
  
! #if defined(BSD) || defined(HPUX)
      (void) gethostname(ourhost, sizeof ourhost);
      if (!(hp = gethostbyname(ourhost))) {
  	if (ourname = (char **)calloc((unsigned)2, sizeof (char *)))
--- 95,101 ----
      escape = DEF_ESCAPE;
      prompt = DEF_PROMPT;
  
! #if defined(BSD) || defined(HPUX) || defined(IRIX4)
      (void) gethostname(ourhost, sizeof ourhost);
      if (!(hp = gethostbyname(ourhost))) {
  	if (ourname = (char **)calloc((unsigned)2, sizeof (char *)))
***************
*** 103,110 ****
  	    strdup(ourname[0], ourhost); /* cnt better be 0! */
  	}
      }
! #endif /* BSD || HPUX */
! #if defined(SYSV) && !defined(HPUX)
      if (ourname = (char **)calloc((unsigned)2, sizeof (char *))) {
  	if ((uname (&ourhost) >= 0) && (*ourhost.nodename))
  	    ourname[0] = savestr(ourhost.nodename);
--- 114,121 ----
  	    strdup(ourname[0], ourhost); /* cnt better be 0! */
  	}
      }
! #else
! #ifdef SYSV
      if (ourname = (char **)calloc((unsigned)2, sizeof (char *))) {
  	if ((uname (&ourhost) >= 0) && (*ourhost.nodename))
  	    ourname[0] = savestr(ourhost.nodename);
***************
*** 124,130 ****
  	    }
  	}
      }
! #endif /* SYSV && !HPUX */
      if (ourname && ourname[0]) {
  	for (p = buf, cnt = 0; ourname[cnt]; cnt++) {
  	    if (cnt)
--- 135,142 ----
  	    }
  	}
      }
! #endif /* SYSV */
! #endif /* BSD || HPUX || IRIX4 */
      if (ourname && ourname[0]) {
  	for (p = buf, cnt = 0; ourname[cnt]; cnt++) {
  	    if (cnt)
***************
*** 251,259 ****
  
      exited = 0;
  
!     while (p = fgets(&line[cont_line], BUFSIZ - cont_line, fp)) {
  	(*line_no)++;
! 	if (*(p2 = no_newln(p)) == '\\') {
  	    *p2++ = ' ';
  	    cont_line = p2 - line;
  	    continue;
--- 263,279 ----
  
      exited = 0;
  
!     while (p = fgets(&line[cont_line], BUFSIZ - cont_line - 1, fp)) {
  	(*line_no)++;
! 	if (p2 = index(p, '\n'))
! 	    while (p2 > p && *p2 == '\n' || isspace(*p2))
! 		*p2-- = 0;  /* get rid of newline and trailing spaces */
! 	else {
! 	    print("%s: line %d:%s line too long, truncated at %d characters.\n",
! 		file, *line_no, cont_line? " continued" : "", BUFSIZ);
! 	    p2 = no_newln(p);
! 	}
! 	if (*p2 == '\\') {
  	    *p2++ = ' ';
  	    cont_line = p2 - line;
  	    continue;
*** 7.2.3/lock.c	Thu May 16 20:13:14 1991
--- 7.2.4/lock.c	Sun Feb  2 19:43:53 1992
***************
*** 15,25 ****
--- 15,126 ----
  #endif /* SYSV && !USG */
  
  #ifdef DOT_LOCK
+ 
+ #ifndef DOLOCK_PATH
+ #define DOLOCK_PATH	"dotlock"	/* Path to the executable */
+ #endif /* DOLOCK_PATH */
+ #ifndef DOLOCK_NAME
+ #define DOLOCK_NAME	"dotlock"	/* Name of the executable */
+ #endif /* DOLOCK_NAME */
+ #define DOLOCKIT	"-l"
+ #define UNLOCKIT	"-u"
+ 
+ #ifdef LOCK_PROG		/* Define for standalone locking program */
+ 
+ /* System V Release 2 does not support saved-set-group-id, so it is not
+  * sufficient for mush to be setgid mail (or whatever group has write
+  * permission on /usr/mail).  Instead, we need an external program that
+  * can be setgid, which mush then runs to create and remove lock files.
+  * Compiling this file with -DDOT_LOCK -DLOCK_PROG added to your CFLAGS
+  * will generate such a program.
+  *
+  * For mush purposes, you should hardwire the DOLOCK_PATH to the full path
+  * name of the installed executable.  This helps prevent malicious users
+  * from substituting a different program.
+  *
+  * The program generated can also be used to perform mail locking from
+  * shell scripts, so you may wish to consider installing it (or a copy)
+  * in a publicly accessible location, e.g. /usr/local/bin.  Note that
+  * this program is not compatible with Xenix mail locking!
+  */
+ 
+ #undef	on_intr()
+ #define	on_intr()	0
+ #undef	off_intr()
+ #define	off_intr()	0
+ #undef	print
+ #define	print		printf
+ #undef	print_more
+ #define	print_more	fflush(stdout), printf
+ #undef	error
+ #define	error		printf
+ #undef	sprintf
+ 
+ /* Simple dotlock program.  Exits 0 for success, nonzero for failure.
+  *
+  * Usage:
+  *	dotlock -lock filename
+  *	dotlock -unlock filename
+  *
+  * The options can be abbreviated to their first letter (-l or -u);
+  * any other usage fails silently.
+  */
+ 
+ main(argc, argv)
+ int argc;
+ char **argv;
+ {
+     char *myname = rindex(argv[0], '/');
+ 
+     if (!myname)
+ 	myname = argv[0];
+     if (strcmp(myname, DOLOCK_NAME) != 0 || argc != 3) 
+ 	exit(-1);
+     
+     if (strncmp(argv[1], DOLOCKIT, 2) == 0)
+ 	dot_lock(argv[2]);
+     else if (strncmp(argv[1], UNLOCKIT, 2) == 0)
+ 	dot_unlock(argv[2]);
+     exit(-1);
+ }
+ 
+ #else /* !LOCK_PROG */
+ 
  extern int sgid;
  #ifdef BSD
  extern int rgid;
  #endif /* BSD */
  
+ #ifdef SVR2
+ /* No saved-setgid, so fork just long enough to create the lockfile. */
+ lock_proc(filename, how)
+ char *filename, *how;
+ {
+     int kid, pid, status;
+ 
+     errno = 0;
+     switch (kid = fork()) {
+ 	case 0:
+ 	    execle(DOLOCK_PATH, DOLOCK_NAME, how, filename, NULL, environ);
+ 	    return kid;
+ 	case -1:
+ 	    error("Unable to fork to change group id");
+ 	    return -1;
+ 	default:
+ 	    /* For SYSV, we're not doing SIGCLD handling, so go ahead
+ 	     * and reap everything in sight until we get the one we want.
+ 	     */
+ 	    while ((pid = wait(&status)) != -1 && pid != kid)
+ 		;
+ 	    if (pid == kid)
+ 		errno = ((status & 0xf) == 0) ? (status >> 8) & 0xf : 0
+ 	    return errno ? -1 : 0;
+     }
+ }
+ #endif /* SVR2 */
+ 
+ #endif /* LOCK_PROG */
+ 
  dot_lock(filename)
  char *filename;
  {
***************
*** 27,32 ****
--- 128,134 ----
      int lockfd, cnt = 0;
      SIGRET (*oldint)(), (*oldquit)();
  
+ #ifndef LOCK_PROG
  #ifdef SYSV
      /* Only the spoolfile needs to be dot_locked -- other files are
       * handled by lock_fopen, below.  To avoid collisions with 14-char
***************
*** 34,45 ****
       */
      if (strcmp(spoolfile, filename) != 0)
  	return 0;
! #endif
  #ifdef BSD
      setregid(rgid, sgid);
  #else /* BSD */
      setgid(sgid);
  #endif /* BSD */
  #ifdef M_XENIX
      (void) sprintf(buf, "/tmp/%.10s.mlk", login);
  #else /* M_XENIX */
--- 136,151 ----
       */
      if (strcmp(spoolfile, filename) != 0)
  	return 0;
! #ifdef SVR2
!     return lock_proc(filename, DOLOCKIT);
! #endif /* SVR2 */
! #endif /* SYSV */
  #ifdef BSD
      setregid(rgid, sgid);
  #else /* BSD */
      setgid(sgid);
  #endif /* BSD */
+ #endif /* !LOCK_PROG */
  #ifdef M_XENIX
      (void) sprintf(buf, "/tmp/%.10s.mlk", login);
  #else /* M_XENIX */
***************
*** 67,72 ****
--- 173,183 ----
  	    print("done.\n");
  	(void) close(lockfd);
      }
+ #ifdef LOCK_PROG
+     if (lockfd < 0)
+ 	print_more("\n");
+     exit(lockfd < 0? errno : 0);
+ #else /* !LOCK_PROG */
  #ifdef BSD
      setregid(sgid, rgid);
  #else
***************
*** 73,81 ****
--- 184,251 ----
      setgid(getgid());
  #endif /* BSD */
      return lockfd == -1? -1 : 0;
+ #endif /* LOCK_PROG */
  }
+ 
+ dot_unlock(filename)
+ char *filename;
+ {
+     char buf[MAXPATHLEN], *p;
+ 
+ #if !defined(M_XENIX) || defined(LOCK_PROG)
+     (void) sprintf(buf, "%s.lock", filename);
+ #ifndef LOCK_PROG
+     {
+ 	/* If the file was locked through open_file(), we may not have
+ 	 * a complete pathname to work with here.  Expand it and test
+ 	 * whether we need to unlink at all.  This should really be
+ 	 * handled by having open_file() return the name it used, but
+ 	 * that breaks too many other things at the moment.
+ 	 */
+ 	int isdir = 0;
+ 	p = getpath(buf, &isdir);
+ 	if (isdir)
+ 	    return 0;
+ 	(void) strcpy(buf, p);
+     }
+ #ifdef SYSV
+     if (strncmp(spoolfile, buf, strlen(spoolfile)) != 0)
+ 	return 0;
+ #ifdef SVR2
+     p = rindex(buf, '.');
+     *p = 0;
+     return lock_proc(buf, UNLOCKIT);
+ #endif /* SVR2 */
+ #endif /* SYSV */
+ #else /* LOCK_PROG */
+     errno = 0;
+ #endif /* !LOCK_PROG */
+ #else /* M_XENIX && !LOCK_PROG */
+     (void) sprintf(buf, "/tmp/%.10s.mlk", login);
+ #endif /* !M_XENIX || LOCK_PROG */
+ #ifndef LOCK_PROG
+ #ifdef BSD
+     setregid(rgid, sgid);
+ #else /* BSD */
+     setgid(sgid);
+ #endif /* BSD */
+ #endif /* !LOCK_PROG */
+     (void) unlink(buf);
+ #ifdef LOCK_PROG
+     exit(errno);
+ #else /* !LOCK_PROG */
+ #ifdef BSD
+     setregid(sgid, rgid);
+ #else
+     setgid(getgid());
+ #endif /* BSD */
+ #endif /* LOCK_PROG */
+     return 0;
+ }
  #endif /* DOT_LOCK */
  
+ #ifndef LOCK_PROG
+ 
  #ifdef SYSV
  
  /*
***************
*** 139,144 ****
--- 309,322 ----
  	    errno = EWOULDBLOCK;
  	    return NULL_FILE;
  	}
+ #ifdef DOT_LOCK
+     /* For additional assurance that each file is opened only once,
+      * and for ease of recovery from interrupts and errors, do the
+      * dot-locking here and unlock in exclusive_fclose().
+      */
+     if (dot_lock(filename) != 0)
+ 	return NULL_FILE;
+ #endif /* DOT_LOCK */
      if (!(fp = mask_fopen(filename, mode)))
  	return NULL_FILE;
      if (tmp = (struct options *)malloc(sizeof(struct options))) {
***************
*** 171,176 ****
--- 349,357 ----
  		exclude_list = tmp1->next;
  	    else
  		tmp2->next = tmp1->next;
+ #ifdef DOT_LOCK
+ 	    dot_unlock(tmp1->option);
+ #endif /* DOT_LOCK */
  	    xfree(tmp1->option);
  #ifndef LCKDFLDIR
  	    /* LCKDFLDIR needs lk_fclose(), so let caller do it */
***************
*** 201,211 ****
  	return NULL_FILE;
      }
  
! #ifdef DOT_LOCK
!     if (dot_lock(filename) == 0)
! #endif /* DOT_LOCK */
!     mail_fp = exclusive_fopen(filename, mode);
!     if (!mail_fp)
  	return NULL_FILE;
      fd = fileno(mail_fp);
  
--- 382,388 ----
  	return NULL_FILE;
      }
  
!     if (!(mail_fp = exclusive_fopen(filename, mode)))
  	return NULL_FILE;
      fd = fileno(mail_fp);
  
***************
*** 244,250 ****
  		    print(".");
  	} else {
  	    error("Unable to lock \"%s\"", filename);
! 	    exclusive_fclose(mail_fp);
  	    off_intr();
  	    return NULL_FILE;
  	}
--- 421,427 ----
  		    print(".");
  	} else {
  	    error("Unable to lock \"%s\"", filename);
! 	    (void) exclusive_fclose(mail_fp);
  	    off_intr();
  	    return NULL_FILE;
  	}
***************
*** 256,262 ****
      cnt = (ison(glob_flags, WAS_INTR) != 0);
      off_intr();
      if (cnt) {
! 	exclusive_fclose(mail_fp);
  	return NULL_FILE;
      }
      return mail_fp;
--- 433,439 ----
      cnt = (ison(glob_flags, WAS_INTR) != 0);
      off_intr();
      if (cnt) {
! 	(void) exclusive_fclose(mail_fp);
  	return NULL_FILE;
      }
      return mail_fp;
***************
*** 266,316 ****
  close_lock(filename, fp)
  char *filename;
  FILE *fp;
- #ifdef LCKDFLDIR
  {
      (void) exclusive_fclose(fp); /* Only removes the list elem */
      return lk_fclose(fp, filename, NULL, NULL);
- }
  #else /* !LCKDFLDIR */
- {
- #ifdef DOT_LOCK
-     char buf[MAXPATHLEN];
- #endif /* DOT_LOCK */
- 
      fflush(fp);
- #ifdef DOT_LOCK
- #ifdef BSD
-     setregid(rgid, sgid);
- #else
-     setgid(sgid);
- #endif /* BSD */
- #ifdef SYSV
-     if (strcmp(spoolfile, filename) == 0)
- #endif /* SYSV */
- #ifdef M_XENIX
-     (void) unlink(sprintf(buf, "/tmp/%.10s.mlk", login));
- #else /* M_XENIX */
-     {
- 	/* If the file was locked through open_file(), we may not have
- 	 * a complete pathname to work with here.  Expand it and test
- 	 * whether we need to unlink at all.  This should really be
- 	 * handled by having open_file() return the name it used, but
- 	 * that breaks too many other things at the moment.
- 	 */
- 	int isdir = 0;
- 	char *p = getpath(sprintf(buf, "%s.lock", filename), &isdir);
- 	if (isdir == 0)
- 	    (void) unlink(p);
-     }
- #endif /* M_XENIX */
- #ifdef BSD
-     setregid(sgid, rgid);
- #else
-     setgid(getgid());
- #endif /* BSD */
- #endif /* DOT_LOCK */
- 
      (void) flock(fileno(fp), LOCK_UN);
      return exclusive_fclose(fp);
- }
  #endif /* LCKDFLDIR */
--- 443,465 ----
  close_lock(filename, fp)
  char *filename;
  FILE *fp;
  {
+ #ifdef LCKDFLDIR
      (void) exclusive_fclose(fp); /* Only removes the list elem */
      return lk_fclose(fp, filename, NULL, NULL);
  #else /* !LCKDFLDIR */
      fflush(fp);
      (void) flock(fileno(fp), LOCK_UN);
      return exclusive_fclose(fp);
  #endif /* LCKDFLDIR */
+ }
+ 
+ /* Make sure we don't leave dead lockfiles lying around */
+ void
+ droplocks()
+ {
+     while (exclude_list)
+ 	close_lock(exclude_list->option, (FILE *)exclude_list->value);
+ }
+ 
+ #endif /* LOCK_PROG */
*** 7.2.3/loop.c	Thu May 16 18:29:08 1991
--- 7.2.4/loop.c	Wed Nov 13 09:58:26 1991
***************
*** 73,78 ****
--- 73,80 ----
  	    }
  #endif /* CURSES */
  	}
+ 	/* If we got back to here, we shouldn't be holding any file locks */
+ 	droplocks();
  #ifdef CURSES
  	if (iscurses || c > -1) {
  	    /* if !iscurses, we know that we returned from a curses-based
*** 7.2.3/main.c	Thu May 16 18:29:17 1991
--- 7.2.4/main.c	Wed Jan 29 23:34:31 1992
***************
*** 65,81 ****
  	(void) setbuf(stdin, NULL);
  
      init(); /* must be done before checking mail since "login" is set here */
-     mailfile = "";
- #ifdef HOMEMAIL
-     {
- 	char *home = do_set(set_options, "home");
- 	if (!home)
- 	    home = ALTERNATE_HOME;
- 	strdup(spoolfile, sprintf(buf, "%s/%s", home, MAILFILE));
-     }
- #else /* HOMEMAIL */
-     strdup(spoolfile, sprintf(buf, "%s/%s", MAILDIR, login));
- #endif /* HOMEMAIL */
  
      n = preparse_opts(&argc,argv);
  
--- 65,70 ----
***************
*** 151,159 ****
  	(void) signal(SIGINT, catch);
  	(void) signal(SIGQUIT, catch);
  	(void) signal(SIGHUP, catch);
! 	if (istool)
  	    turnon(glob_flags, ECHO_FLAG);
! 	tty_settings();
  #ifdef SIGCONT
  	(void) signal(SIGTSTP, stop_start); /* this will take care of SIGCONT */
  #endif /* SIGCONT */
--- 140,149 ----
  	(void) signal(SIGINT, catch);
  	(void) signal(SIGQUIT, catch);
  	(void) signal(SIGHUP, catch);
! 	if (istool || hdrs_only)
  	    turnon(glob_flags, ECHO_FLAG);
! 	if (!hdrs_only)
! 	    tty_settings();
  #ifdef SIGCONT
  	(void) signal(SIGTSTP, stop_start); /* this will take care of SIGCONT */
  #endif /* SIGCONT */
*** 7.2.3/makefile.bsd	Thu May 16 18:29:18 1991
--- 7.2.4/makefile.bsd	Thu Jan 30 22:00:59 1992
***************
*** 12,19 ****
        folders.o dates.o loop.o viewopts.o curses.o curs_io.o bind.o \
        lock.o macros.o options.o addrs.o malloc.o glob.o command2.o
  
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 mush.1 \
! 	cmd_help Mushrc Mailrc Gnurc sample.mushrc advanced.mushrc digestify
  
  MAKES= makefile.bsd makefile.xenix makefile.sys.v makefile.hpux makefile.sun
  
--- 12,20 ----
        folders.o dates.o loop.o viewopts.o curses.o curs_io.o bind.o \
        lock.o macros.o options.o addrs.o malloc.o glob.o command2.o
  
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
! 	README-7.2.4 mush.1 cmd_help Mushrc Mailrc Gnurc \
! 	sample.mushrc advanced.mushrc digestify
  
  MAKES= makefile.bsd makefile.xenix makefile.sys.v makefile.hpux makefile.sun
  
***************
*** 22,28 ****
  CFLAGS= -O -DCURSES -DBSD
  LDFLAGS=
  LINTFLAGS= -bxah -Dlint -DCURSES -DBSD
! LIBES= -lcurses -ltermlib
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
--- 23,29 ----
  CFLAGS= -O -DCURSES -DBSD
  LDFLAGS=
  LINTFLAGS= -bxah -Dlint -DCURSES -DBSD
! LIBS= -lcurses -ltermlib
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
***************
*** 29,35 ****
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBES) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
--- 30,36 ----
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBS) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
*** 7.2.3/makefile.hpux	Thu May 16 18:29:19 1991
--- 7.2.4/makefile.hpux	Thu Jan 30 22:01:20 1992
***************
*** 16,23 ****
  OBJS2= bind.o curs_io.o curses.o file.o strings.o macros.o \
  	addrs.o malloc.o glob.o command2.o
  
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 mush.1 \
! 	cmd_help Mushrc Mailrc Gnurc sample.mushrc advanced.mushrc digestify
  
  # If your HP-UX version is older than 6.5, you will need remove -DDIRECTORY
  
--- 16,24 ----
  OBJS2= bind.o curs_io.o curses.o file.o strings.o macros.o \
  	addrs.o malloc.o glob.o command2.o
  
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
! 	README-7.2.4 mush.1 cmd_help Mushrc Mailrc Gnurc \
! 	sample.mushrc advanced.mushrc digestify
  
  # If your HP-UX version is older than 6.5, you will need remove -DDIRECTORY
  
*** 7.2.3/makefile.sun	Thu May 16 18:29:20 1991
--- 7.2.4/makefile.sun	Thu Jan 30 22:01:37 1992
***************
*** 20,26 ****
  IMAGES= mail.icon.1 mail.icon.2
  
  HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
!             mush.1 cmd_help tool_help Mushrc Mailrc Gnurc \
  	    advanced.mushrc sample.mushrc digestify
  
  MAKES= makefile.sun makefile.bsd makefile.sys.v makefile.xenix makefile.hpux
--- 20,26 ----
  IMAGES= mail.icon.1 mail.icon.2
  
  HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
!             README-7.2.4 mush.1 cmd_help tool_help Mushrc Mailrc Gnurc \
  	    advanced.mushrc sample.mushrc digestify
  
  MAKES= makefile.sun makefile.bsd makefile.sys.v makefile.xenix makefile.hpux
***************
*** 31,37 ****
  #	-DSUN_3_5, -DSUN_4_0, or -DSUN_4_1 to CFLAGS there.
  CFLAGS= -O -DSUNTOOL -DCURSES -DBSD
  LDFLAGS=
! LIBES= -lcurses -ltermlib -lsuntool -lsunwindow -lpixrect
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
--- 31,37 ----
  #	-DSUN_3_5, -DSUN_4_0, or -DSUN_4_1 to CFLAGS there.
  CFLAGS= -O -DSUNTOOL -DCURSES -DBSD
  LDFLAGS=
! LIBS= -lcurses -ltermlib -lsuntool -lsunwindow -lpixrect
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
***************
*** 39,45 ****
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBES) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
--- 39,45 ----
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBS) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
*** 7.2.3/makefile.sys.v	Thu May 16 18:29:21 1991
--- 7.2.4/makefile.sys.v	Thu Jan 30 22:02:19 1992
***************
*** 17,24 ****
  OBJS2= bind.o curs_io.o curses.o file.o strings.o macros.o \
  	addrs.o malloc.o glob.o command2.o
  
! HELP= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 mush.1 \
! 	cmd_help Mushrc Mailrc Gnurc sample.mushrc advanced.mushrc digestify
  
  # Sun OS systems who wish to compile with sys-v options:
  # CC= /usr/5bin/cc
--- 17,25 ----
  OBJS2= bind.o curs_io.o curses.o file.o strings.o macros.o \
  	addrs.o malloc.o glob.o command2.o
  
! HELP= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
! 	README-7.2.4 mush.1 cmd_help Mushrc Mailrc Gnurc \
! 	sample.mushrc advanced.mushrc digestify
  
  # Sun OS systems who wish to compile with sys-v options:
  # CC= /usr/5bin/cc
***************
*** 27,32 ****
--- 28,35 ----
  
  # IRIX 3.2 systems (SGI Iris workstations) should add -DDIRECTORY to CFLAGS
  # SCO UNIX 3.2 should add -DDIRECTORY -DSELECT and should avoid library -lx
+ # System V Release 4 (SunOS 5?) should add -DSVR4 -DDIRECTORY to CFLAGS and
+ #  should replace -lPW with -lgen
  
  CFLAGS= 	-O -DSYSV -DUSG -DCURSES -DREGCMP -DSIGRET=void
  LDFLAGS=
*** 7.2.3/makefile.xenix	Thu May 16 18:29:22 1991
--- 7.2.4/makefile.xenix	Thu Jan 30 22:02:41 1992
***************
*** 20,27 ****
        signals.o setopts.o msgs.o pick.o sort.o expr.o strings.o \
        folders.o dates.o loop.o viewopts.o bind.o curses.o curs_io.o \
        lock.o macros.o options.o addrs.o malloc.o glob.o command2.o
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 mush.1 \
! 	cmd_help Mushrc Mailrc Gnurc sample.mushrc advanced.mushrc digestify
  
  # Memory model.  Use -M3e for 80386 machines.
  # Use -M2le -Mt32 -LARGE for 80286 machines.
--- 20,28 ----
        signals.o setopts.o msgs.o pick.o sort.o expr.o strings.o \
        folders.o dates.o loop.o viewopts.o bind.o curses.o curs_io.o \
        lock.o macros.o options.o addrs.o malloc.o glob.o command2.o
! HELP_FILES= README README-7.0 README-7.1 README-7.2.0 README-7.2.2 \
! 	README-7.2.4 mush.1 cmd_help Mushrc Mailrc Gnurc \
! 	sample.mushrc advanced.mushrc digestify
  
  # Memory model.  Use -M3e for 80386 machines.
  # Use -M2le -Mt32 -LARGE for 80286 machines.
***************
*** 33,39 ****
  LDFLAGS= -X -lx -M3
  
  CFLAGS= $(MODEL) -O -DSYSV -DCURSES -DREGCMP -DUSG 
! LIBES= -lcurses -ltermlib
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
--- 34,40 ----
  LDFLAGS= -X -lx -M3
  
  CFLAGS= $(MODEL) -O -DSYSV -DCURSES -DREGCMP -DUSG 
! LIBS= -lcurses -ltermlib
  OTHERLIBS=
  # Use some variant of this one if you #define MMDF in config.h
  #OTHERLIBS=/usr/src/mmdf/lib/libmmdf.a
***************
*** 40,46 ****
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBES) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
--- 41,47 ----
  
  mush: $(OBJS)
  	@echo loading...
! 	@cc $(LDFLAGS) $(OBJS) $(LIBS) $(OTHERLIBS) -o mush
  
  $(OBJS): config.h mush.h
  loop.o: version.h
*** 7.2.3/misc.c	Thu Oct 25 17:46:38 1990
--- 7.2.4/misc.c	Thu Jan 30 23:25:10 1992
***************
*** 494,499 ****
--- 494,504 ----
  
      if (start_pager) {
  	turnon(glob_flags, IGN_SIGS);
+ 	cnt = len = 0;
+ 	if (buf && strcmp(buf, "NONE") == 0) {
+ 	    cnt = -1;	/* cnt < 0 disables c_more() */
+ 	    buf = NULL;
+ 	}
  	if (!buf) {
  	    /* internal pager */
  	    save_echo_flag = ison(glob_flags, ECHO_FLAG);
***************
*** 507,513 ****
  	    if (!(pp = popen(buf, "w")))
  		error(buf);
  	}
- 	cnt = len = 0;
      } else if (!buf) {
  	if (pp && pp != stdout)
  	    (void) pclose(pp);
--- 512,517 ----
***************
*** 518,524 ****
  	} else
  	    echo_off();
  	turnoff(glob_flags, IGN_SIGS);
!     } else if (pp != stdout)
  	return fputs(buf, pp); /* returns EOF if user exited pager */
      else {
  	register char c = 0, *cr = index(buf, '\n');
--- 522,528 ----
  	} else
  	    echo_off();
  	turnoff(glob_flags, IGN_SIGS);
!     } else if (pp != stdout || cnt < 0)
  	return fputs(buf, pp); /* returns EOF if user exited pager */
      else {
  	register char c = 0, *cr = index(buf, '\n');
***************
*** 666,675 ****
  	(void) fputc('\n', fp);
  	(void) fflush(fp);
  	if (*buf == '$')
! 	    if (!(p = do_set(set_options, buf)))
  		wprint("(%s isn't set -- letter not signed)\n", buf);
  	    else {
! 		putstring(p+1, fp);
  		if (noisy)
  		    wprint("\n");
  	    }
--- 670,679 ----
  	(void) fputc('\n', fp);
  	(void) fflush(fp);
  	if (*buf == '$')
! 	    if (!(p = do_set(set_options, buf+1)))
  		wprint("(%s isn't set -- letter not signed)\n", buf);
  	    else {
! 		putstring(p, fp);
  		if (noisy)
  		    wprint("\n");
  	    }
*** 7.2.3/msgs.c	Wed May 22 18:27:16 1991
--- 7.2.4/msgs.c	Sun Feb  2 13:59:14 1992
***************
*** 341,349 ****
  	    write_err = 1;	/* forces return 0; below */
  	    goto resume_timer;	/* blecch */
  	}
- #else /* !SUNTOOL */
- 	return 0;
  #endif /* SUNTOOL */
      }
      /* Make sure no mail arrived between the last check and when we
       * got the lock.  If it did, release the lock and try again.
--- 341,348 ----
  	    write_err = 1;	/* forces return 0; below */
  	    goto resume_timer;	/* blecch */
  	}
  #endif /* SUNTOOL */
+ 	return 0;
      }
      /* Make sure no mail arrived between the last check and when we
       * got the lock.  If it did, release the lock and try again.
***************
*** 505,513 ****
--- 504,519 ----
  	/* Reset the access time of the spool file to prevent
  	 * bogus "new mail" messages from the shell.
  	 */
+ #ifdef POSIX_UTIME
+ 	struct utimbuf times;
+ 	(void) fflush(mail_fp); /* just in case */
+ 	times.modtime = time(&times.actime) - 2;
+ 	times.ausec = times.modusec = 0;
+ #else /* !POSIX_UTIME */
  	long times[2];
  	(void) fflush(mail_fp); /* just in case */
  	times[1] = time(&times[0]) - (long)2;
+ #endif /* POSIX_UTIME */
  	if (!strcmp(mailfile, spoolfile) && utime(mailfile, times))
  	    error("utime");
      }
*** 7.2.3/mush.h	Wed May 22 18:15:57 1991
--- 7.2.4/mush.h	Sun Feb  2 13:50:50 1992
***************
*** 35,40 ****
--- 35,44 ----
  #endif /* SYSV && USG */
  #endif /* CURSES */
  
+ #if defined(SVR4)
+ #include <sys/ttold.h>
+ #endif /* SVR4 */
+ 
  #include <ctype.h>
  #include <errno.h>
  #include <setjmp.h>
***************
*** 49,71 ****
      free_vec(),		/* free a malloc'ed argv */
      xfree();		/* free malloc'ed pointers */
  
- #if defined(SUNTOOL) || defined(SUN_3_5) || defined(SUN_4_0) || defined(SUN_4_1)
- #if !defined(BSD) && !defined(SYSV)
- #    define BSD /* default to BSD */
- #endif /* !BSD && !SYSV */
- #if !defined(SUN_3_5) && !defined(SUN_4_0)
- #    ifndef SUN_4_1
- #        define SUN_4_1 /* default to sun 4.1 */
- #    endif /* SUN_4_1 */
- #    define SUN_4_0 /* 4.0 stuff needed too */
- #endif /* !SUN_3_5 && !SUN_4_0 */
- #ifdef SUN_4_0
- #    undef SUN_3_5
- #    undef SIGRET
- #    define SIGRET void
- #endif /* SUN_4_0 */
- #endif /* SUNTOOL || SUN_3_5 || SUN_4_0 || SUN_4_1 */
- 
  #ifdef BSD
  #define fputs Fputs	/* See comments in print.c */
  #endif /* BSD */
--- 53,58 ----
***************
*** 103,108 ****
--- 90,98 ----
  #    endif /* SYSV */
  #endif /* SUNTOOL */
  
+ #ifdef POSIX_UTIME
+ #include <sys/utime.h>
+ #endif /* POSIX_UTIME */
  #include <sys/stat.h>
  #include <sys/file.h>
  
*** 7.2.3/pick.c	Sun May 19 19:59:34 1991
--- 7.2.4/pick.c	Wed Nov 20 23:42:33 1991
***************
*** 219,225 ****
  		print_more(" from the message header \"%s:\"", search_hdr);
  	} else if (mdy[1]) {
  	    extern char *month_names[]; /* from dates.c */
! 	    print_more(" dated ");
  	    if (before || after)
  		if (xflg)
  		    print_more("%s ", (!before)? "before": "after");
--- 219,225 ----
  		print_more(" from the message header \"%s:\"", search_hdr);
  	} else if (mdy[1]) {
  	    extern char *month_names[]; /* from dates.c */
! 	    print_more("%s dated ", xflg && !(before || after)? " not" : "");
  	    if (before || after)
  		if (xflg)
  		    print_more("%s ", (!before)? "before": "after");
***************
*** 438,444 ****
      static char     *err = (char *)-1, direction;
      SIGRET	    (*oldint)(), (*oldquit)();
  #ifdef REGCMP
!     char *regcmp();
  #else /* REGCMP */
      char *re_comp();
  #endif /* REGCMP */
--- 438,444 ----
      static char     *err = (char *)-1, direction;
      SIGRET	    (*oldint)(), (*oldquit)();
  #ifdef REGCMP
!     char *regex(), *regcmp();
  #else /* REGCMP */
      char *re_comp();
  #endif /* REGCMP */
*** 7.2.3/setopts.c	Thu May 16 18:30:06 1991
--- 7.2.4/setopts.c	Thu Nov 21 10:06:23 1991
***************
*** 696,702 ****
  {
      register char *cmd = *argv, *p;
      struct options **list;
!     char firstchar = *cmd, buf[BUFSIZ];
  
      if (argc == 0)
  	return 0 - in_pipe();
--- 696,702 ----
  {
      register char *cmd = *argv, *p;
      struct options **list;
!     char firstchar = *cmd, buf[HDRSIZ];
  
      if (argc == 0)
  	return 0 - in_pipe();
*** 7.2.3/signals.c	Thu May 16 18:30:08 1991
--- 7.2.4/signals.c	Wed Jan 29 23:56:50 1992
***************
*** 231,236 ****
--- 231,237 ----
  
      if (ison(glob_flags, IS_GETTING))
  	turnoff(glob_flags, IS_GETTING), dead_letter(sig);
+     droplocks();
      if ((sig == SIGSEGV || sig == SIGBUS) && isoff(glob_flags, IGN_SIGS)
  	    && *tempfile && !istool) {
  	(void) fprintf(stderr, "remove %s [y]? ", tempfile), (void) fflush(stderr);
***************
*** 256,261 ****
--- 257,268 ----
  	    abort();
  	}
      }
+ #ifdef CSH_FILEC_FIX
+     if (isoff(glob_flags, ECHO_FLAG) && isoff(glob_flags, REDIRECT)) {
+ 	c = 0;
+ 	(void)ioctl(0, TIOCFLUSH, &c);
+     }
+ #endif /* CSH_FILEC_FIX */
      exit(sig);
  }
  

-- 
Bart Schaefer                                     schaefer@zigzag.z-code.com
Z-Code Software Corp.                             schaefer@z-code.com
New male in /home/schaefer:
  1  N  Benjamin Timothy Schaefer  Nov 26 1991 (3572g) Happy Birthday!

exit 0 # Just in case...
