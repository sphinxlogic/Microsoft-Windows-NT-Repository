From: aem@aber.ac.uk (Alec David Muffett)
Newsgroups: comp.sources.misc
Subject: v28i110: crack - The Unix Password Cracker, version 4.1, Part01/05
Message-ID: <csm-v28i110=crack.143636@aber.ac.uk>
Date: 18 Mar 92 14:37:42 GMT
Approved: aem@aber.ac.uk
X-Md4-Signature: 219e83137cc1c285e33e2e370c14f824

Submitted-by: aem@aber.ac.uk (Alec David Muffett)
Posting-number: Volume 28, Issue 110
Archive-name: crack/part01
Environment: UNIX
Supersedes: crack: Volume 25, Issue 5-9

This is Crack v4.1, the "Sensible" Unix Password Cracker. 

- Documentation is in the directory 'Docs' - go for it... 

dicts.rules is now up to 240 entries, mostly thanks to mycroft @
gnu.ai.mit.edu; don't lose heart, its not as bad as all that...  3 weeks
of CPU isn't all that long, really...  Seriously, most of the rules
generate really small dictionaries, so it's not all that bad.  8-)

There are several additions to the dictionary rules, notably the
character class commands and the i, o, = and @ commands. 

Use of "Crack -R" (as opposed to "Crack -r") is not recommended until I
write v5.0, unless you know exactly what you're doing and why it bombs
out on you... 

Also, Crack now fully supports UFC (the latest version of which is to be
posted concurrently with Crack v4.1) - all you should have to do is
unpack the latest version of UFC into the directory

			    ufc-crypt

which you should create in the Crack installation directory.  The
program should do the rest. 

--
|+ Alec David Edward Muffett, Unix Programmer and Unemployed Coffee Drinker. +|
|>  aem@aber.ac.uk aem@uk.ac.aber aem%aber@ukacrl.bitnet mcsun!ukc!aber!aem  <|
| "I didn't invent the Unix Password Security problem.  I just optimised it." |

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  BUGS DictSrc DictSrc/jargon Dicts Docs MANIFEST README
#   Runtime Scripts Scripts/RCrack Scripts/clean Scripts/crack.mf
#   Scripts/do_install Scripts/do_join Scripts/do_pwc Scripts/do_ufc
#   Scripts/gecos.rules Scripts/guess2fbk Scripts/install.mf
#   Scripts/mrgfbk Scripts/nastygram Scripts/network.conf
#   Scripts/plaster Scripts/saltcount Scripts/shadmrg Scripts/spotless
#   Scripts/status Sources Sources/Makefile Sources/bytesex.c
#   Sources/conf.h Sources/crack-glob.c Sources/crack-glob.h
#   Sources/crack-supp.c Sources/crack.h Sources/speeds.c
#   Sources/tester.c Sources/testrule.c TODO
# Wrapped by aem@aberfa on Wed Mar 18 14:08:25 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'BUGS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'BUGS'\"
else
echo shar: Extracting \"'BUGS'\" \(1112 characters\)
sed "s/^X//" >'BUGS' <<'END_OF_FILE'
XBugs as of 1 Mar 1992:-
X
X* Crack: is known to occasionally hang during a "Crack -network" whilst
Xrshing from machine to machine on some architectures.  It's a persistent
Xproblem at some sites, when Crack rsh'es to a particular machine and
Xstays there, and thus never calls the next machine.
X
XFIX: mark machines that hang Crack with the "-f" option in network.conf
Xfile, then the 'rsh' will be backgrounded and Crack will continue to the
Xnext machine.  The tweak in Crack v4.1 to close descriptors 0->9 on all
Xmachines (esp Apollos) may help this.
X
X* Beta testers on DEC 5500s have reported crack-pwc crashing when
Xcompiled with the optimiser.  This apparently doesn't happen using GCC
Xor when optimisation is turned off (heisenbug?)
X
XBe warned.
X
X* Earlyish System V type systems will have problems if the environment
Xvariable SHELL is not set to "/bin/sh" - this is because SV will
Xblithely ignore the "#!/bin/sh" line and invoke a csh anyway, if thats
Xwhat you prefer.
X
XThis is probably most easily diagnosed when Crack bails out like this:
X
X	CRACK_HOME=/your/crack/directory: Command not found.
X
X- or similar.
END_OF_FILE
if test 1112 -ne `wc -c <'BUGS'`; then
    echo shar: \"'BUGS'\" unpacked with wrong size!
fi
# end of 'BUGS'
fi
if test ! -d 'DictSrc' ; then
    echo shar: Creating directory \"'DictSrc'\"
    mkdir 'DictSrc'
fi
if test -f 'DictSrc/jargon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'DictSrc/jargon'\"
else
echo shar: Extracting \"'DictSrc/jargon'\" \(3677 characters\)
sed "s/^X//" >'DictSrc/jargon' <<'END_OF_FILE'
X# From: eric%snark.thyrsus.com%cbmvax@net.UU.uunet (Eric S. Raymond)
X# Subject: improved Jargon File wordlist for crack 4.0
X# Eric S. Raymond = eric@snark.thyrsus.com  (mad mastermind of TMN-Netnews)
XACK
XALT
XAOS
XBBS
XBFI
XBIFF
XBITNET
XBLT
XBOF
XBQS
XBRS
XBSD
XBWQ
XBartleMUD
XBerzerkeley
XBiCapitalization
XCI
XCLM
XCTY
XDDT
XDEADBEEF
XDEChead
XDP
XDPB
XDPer
XDRECNET
XDWIM
XDiscordianism
XEMACS
XENQ
XEOL
XEOU
XEXCH
XEXE
XEris
XFAQL
XFOAF
XFOD
XFTP
XFUBAR
XFUD
XFidoNet
XFoonly
XFortrash
XGC
XGECOS
XGFR
XGIGO
XGIPS
XGNUMACS
XGOSMACS
XGPL
XGPV
XGodzillagram
XGosperism
XHAKMEM
XHCF
XHHOK
XHHOS
XHLL
XHackintosh
XIMHO
XINTERCAL
XIRC
XIWBNI
XIYFEG
XJEDR
XJFCL
XJRST
XK&R
XKIPS
XLDB
XLER
XLERP
XLN
XLPT
XMEGO
XMFTL
XMIPS
XMOTAS
XMOTOS
XMOTSS
XMacintoy
XMacintrash
XMoof
XNAK
XNMI
XNeWS
XPBD
XPD
XPETSCII
XPOM
XPOPJ
XPPN
XPerl
XQWERTY
XRETI
XRFC
XRFE
XRL
XRSN
XRTFAQ
XRTFM
XRTI
XRTM
XSCSI
XSMOP
XSPACEWAR
XSysVile
XTCB
XTECO
XTELNET
XTLA
XTMRC
XTWENEX
XTeX
XTechRef
XUBD
XUSENET
XUTSL
XUUCPNET
XVAXectomy
XVAXen
XVMS
XVR
XWIBNI
XWOMBAT
XWYSIAYG
XWYSIWYG
XWeenix
XXOFF
XXXX
XYABA
XYAUN
XZork
Xabbrev
Xadger
Xadmin
Xannoybot
Xapp
Xattoparsec
Xautobogotiphobia
Xavatar
Xawk
Xbagbiter
Xbamf
Xbarf
Xbarfulation
Xbarfulous
Xbaz
Xbboard
Xberklix
Xbiff
Xbignum
Xbitblt
Xbixie
Xblargh
Xbletch
Xbletcherous
Xblinkenlights
Xblit
Xblitter
Xblivet
Xbogometer
Xbogon
Xbogosity
Xbogotify
Xboink
Xbonk
Xboxen
Xboxology
Xbozotic
Xbraino
Xbreedle
Xbroket
Xbuglix
Xbytesexual
Xcareware
Xcdr
Xchad
Xchanop
Xcharityware
Xclustergeeking
Xcodewalker
Xcokebottle
Xcomputron
Xcondom
Xcopybroke
Xcopyleft
Xcopywronged
Xcorge
Xcray
Xcrayola
Xcrippleware
Xcrlf
Xcrudware
Xcruft
Xcruftsmanship
Xcrufty
Xcryppie
Xcuspy
Xcybercrud
Xcyberpunk
Xcyberspace
Xdaemon
Xdd
Xdeckle
Xdehose
Xdelint
Xdepeditate
Xdevo
Xdink
Xdoc
Xdoco
Xdodgy
Xdogcow
Xdogwash
Xdongle
Xdonuts
Xdoorstop
Xdroid
Xdynner
Xemail
Xemoticon
Xerve
Xexcl
Xfab
Xfeaturectomy
Xfeep
Xfeeper
Xfilk
Xfinn
Xfirebottle
Xfirefighting
Xfirmy
Xflamage
Xflarp
Xflippy
Xflytrap
Xfollowup
Xfoo
Xfoobar
Xfora
Xfred
Xfrednet
Xfreeware
Xfriode
Xfritterware
Xfrob
Xfrobnicate
Xfrobnitz
Xfrotz
Xfrotzed
Xfrowney
Xfuggly
Xfuzzball
Xgabriel
Xgarply
Xgeef
Xgen
Xgensym
Xgillion
Xglark
Xglassfet
Xglork
Xgnarly
Xgonk
Xgonkulator
Xgonzo
Xgorp
Xgotcha
Xgrault
Xgritch
Xgrok
Xgronk
Xgronked
Xgrunge
Xgubbish
Xguiltware
Xgumby
Xgunch
Xgurfle
Xgweep
Xhackish
Xhackishness
Xhackitude
Xhakspek
Xhandwave
Xhardcoded
Xhardwarily
Xhardwired
Xheisenbug
Xhexit
Xhing
Xhobbit
Xhungus
Xi14y
Xi18n
Xinitgame
Xjupiter
Xkahuna
Xkgbvax
Xklone
Xkluge
Xkremvax
Xkyrka
Xlaundromat
Xlegalese
Xletterbomb
Xlexiphage
Xlivelock
Xliveware
Xlossage
Xluser
Xmacdink
Xmachoflops
Xmacrology
Xmacrotape
Xmaggotbox
Xmandelbug
Xmarketroid
Xmartian
Xmeatware
Xmeeces
Xmeg
Xmegapenny
Xmeme
Xmemetics
Xmenuitis
Xmeta
Xmickey
XmicroLenat
Xminifloppies
Xmoby
Xmoria
Xmouso
Xmudhead
Xmultician
Xmumblage
Xmunchkin
Xnano
Xnanoacre
Xnanobot
Xnanocomputer
Xnanofortnight
Xnanotechnology
Xnastygram
Xneophilia
Xnetburp
Xnetdead
Xnethack
Xnetiquette
Xnetlag
Xnetnews
Xnetrock
Xnewbie
Xnewsfroup
Xnewsgroup
Xnickle
Xnoddy
Xnooze
Xnotwork
Xnuke
Xnybble
Xnyetwork
Xoffline
Xoif
Xooblick
Xop
Xparam
Xparm
Xpayware
Xpdl
Xperf
Xphreaking
Xplayte
Xplingnet
Xplokta
Xplonk
Xplugh
Xpnambic
Xprestidigitization
Xprettyprint
Xproglet
Xpsychedelicware
Xpsyton
Xques
Xquux
Xqux
Xravs
Xregexp
Xretcon
Xretrocomputing
Xrot13
Xsagan
Xsalescritter
Xsalsman
Xsandbender
Xscrewage
Xscrog
Xscrool
Xscrozzle
Xsegfault
Xseggie
Xsegv
Xshareware
Xshelfware
Xshitogram
Xshowstopper
Xsitename
Xskrog
Xslopsucker
Xsmiley
Xsmurf
Xsnarf
Xsneakernet
Xsnivitz
Xsoftcopy
Xsoftwarily
Xsofty
Xspam
Xspl
Xspooge
Xstiffy
Xstubroutine
Xstudlycaps
Xsysadmin
Xsysop
Xtayste
Xterminak
Xterpri
Xthinko
Xthunk
Xtinycrud
Xtoeprint
Xtoto
Xtrit
Xtty
Xtunafish
Xturist
Xtwink
Xtwonkie
Xupload
Xupthread
Xvadding
Xvannevar
Xvaporware
Xvar
Xvaxherd
Xvaxism
Xvaxocentrism
Xvdiff
Xveeblefester
Xverbage
Xvgrep
Xvideotex
Xwabbit
Xwaldo
Xwango
Xwank
Xwannabee
Xwedgie
Xwedgitude
Xweeble
Xweenie
Xwetware
Xwhalesong
Xwhizzy
Xwinkey
Xwinnage
Xwinnitude
Xwirehead
Xwonky
Xworkaround
Xxor
Xxref
Xxyzzy
Xzen
Xzigamorph
Xzipperhead
Xzorch
Xzorkmid
END_OF_FILE
if test 3677 -ne `wc -c <'DictSrc/jargon'`; then
    echo shar: \"'DictSrc/jargon'\" unpacked with wrong size!
fi
# end of 'DictSrc/jargon'
fi
if test ! -d 'Dicts' ; then
    echo shar: Creating directory \"'Dicts'\"
    mkdir 'Dicts'
fi
if test ! -d 'Docs' ; then
    echo shar: Creating directory \"'Docs'\"
    mkdir 'Docs'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2395 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X APPENDIX                   2	miscellaneous information
X BUGS                       1	list of recent bugs and possible fixes
X Crack                      2	crack driver shellscript
X DictSrc                    1	directory
X DictSrc/bad_pws.dat        2	example extra dictionary
X DictSrc/jargon             1	jargon dictionary contributed by ESR
X Dicts                      1	empty directory
X Docs                       1	directory
X Docs/readme.ms             4	coarse nroff -ms format documentation
X Docs/readme.txt            5	ascii format documentation
X LICENCE                    2	licence document
X MANIFEST                   1	THIS FILE
X README                     1	EVERYBODY START HERE
X Runtime                    1	empty directory
X Scripts                    1	scripts directory
X Scripts/Crack.network      2	network driver script
X Scripts/RCrack             1	interface to 'rsh', 'remsh' - whatever
X Scripts/clean              1	tidy-up script
X Scripts/crack.mf           1	
X Scripts/dicts.rules        2	rules applied to dictionary words
X Scripts/do_install         1	
X Scripts/do_join            1	
X Scripts/do_pwc             1	
X Scripts/do_ufc             1	
X Scripts/gecos.rules        1	rules applied to gecos-generated words
X Scripts/guess2fbk          1	crash recovery script (see docs)
X Scripts/install.mf         1	
X Scripts/mrgfbk             1	
X Scripts/nastygram          1	
X Scripts/network.conf       1	
X Scripts/plaster            1	crack control script
X Scripts/saltcount          1	
X Scripts/shadmrg            1	
X Scripts/spotless           1	tidy up and delete script
X Scripts/status             1	
X Sources                    1	source code directory
X Sources/Makefile           1	
X Sources/bytesex.c          1	
X Sources/conf.h             1	configuration header file
X Sources/crack-fcrypt.c     4	
X Sources/crack-glob.c       1	
X Sources/crack-glob.h       1	
X Sources/crack-lib.c        3	
X Sources/crack-pwc.c        3	password cracker main file
X Sources/crack-sort.c       2	
X Sources/crack-supp.c       1	
X Sources/crack.h            1	
X Sources/speeds.c           1	benchmark program
X Sources/tester.c           1	fcrypt compatibility program
X Sources/testrule.c         1	dictionary tester program
X TODO                       1	List of good ideas I _already_ have
END_OF_FILE
if test 2395 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1243 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is Crack v4.1, the "Sensible" Unix Password Cracker. 
X
X- Documentation is in the directory 'Docs' - go for it... 
X
Xdicts.rules is now up to 240 entries, mostly thanks to mycroft @
Xgnu.ai.mit.edu; don't lose heart, its not as bad as all that...  3 weeks
Xof CPU isn't all that long, really...  Seriously, most of the rules
Xgenerate really small dictionaries, so it's not all that bad.  8-)
X
XThere are several additions to the dictionary rules, notably the
Xcharacter class commands and the i, o, = and @ commands. 
X
XUse of "Crack -R" (as opposed to "Crack -r") is not recommended until I
Xwrite v5.0, unless you know exactly what you're doing and why it bombs
Xout on you... 
X
XAlso, Crack now fully supports UFC (the latest version of which is to be
Xposted concurrently with Crack v4.1) - all you should have to do is
Xunpack the latest version of UFC into the directory
X
X				ufc-crypt
X
Xwhich you should create in the Crack installation directory.  The
Xprogram should do the rest. 
X
XHappy cracking !
X
X--
X|+ Alec David Edward Muffett, Unix Programmer and Unemployed Coffee Drinker. +|
X|>  aem@aber.ac.uk aem@uk.ac.aber aem%aber@ukacrl.bitnet mcsun!ukc!aber!aem  <|
X| "I didn't invent the Unix Password Security problem.  I just optimised it." |
END_OF_FILE
if test 1243 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'Runtime' ; then
    echo shar: Creating directory \"'Runtime'\"
    mkdir 'Runtime'
fi
if test ! -d 'Scripts' ; then
    echo shar: Creating directory \"'Scripts'\"
    mkdir 'Scripts'
fi
if test -f 'Scripts/RCrack' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/RCrack'\"
else
echo shar: Extracting \"'Scripts/RCrack'\" \(3370 characters\)
sed "s/^X//" >'Scripts/RCrack' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# For those ignorant of 'rsh', what I am trying to build is a line of
X# the form
X#	      rsh hostname [-n] [-l remoteuser] command [args ...]
X#
X###
X
Xmachine=`(uname) 2>&1`			# What architecture are we on ?
X
X###
X# Map architecture to rsh-equivalent...
X###
X
Xcase $machine in
X	"HP*UX")			# Hewlett Packard boxen
X		remote_shell="remsh"
X		;;
X# 	"XENIX"|"Xenix")		# Just a suggestion...
X#		remote_shell="rcmd"
X#		;;
X	*)				# default
X		remote_shell="rsh"
X		;;
Xesac
X
X###
X# Are we going to kick rsh into the background, or are we going to
X# background the thing on the remote end ?
X###
X
Xasynch_mode=""
X
Xif [ "x$1" = "x-asynch" ]
Xthen
X	echo "(asynchronous $remote_shell mode)"
X	asynch_mode="$1"
X	shift
Xelse
X	echo "(remotely backgrounded mode)"
Xfi
X
X###
X# Segments of input data to read.
X###
X
Xstartline=$1
Xshift
Xstopline=$1
Xshift
X
Xdatafile=/tmp/rcrk.$$		# temporary data file
X
X###
X# Awk reads from stdin... Create an input file for rsh...
X###
X
Xawk -F: '
XBEGIN {
X	usercount = 0;
X	saltcount = 0;
X	startsalt = '"$startline"';
X	stopsalt = '"$stopline"';
X}
X
X{
X	if (substr($3, 1, 2) != last)
X	{
X	    saltcount++;
X	    last = substr($3, 1, 2);
X	}
X
X	if (saltcount >= startsalt && saltcount <= stopsalt)
X	{
X		usercount++;
X		print $0;
X	}
X}' > $datafile
X
X###
X# Test that we should actually bother to do anything.
X###
X
Xnumlines=`wc -l < $datafile`
X
X###
X# Must not quote $numlines here for comparison to work
X###
X
Xif [ $numlines = 0 ]
Xthen
X	echo "RCrack: Nothing left to dispatch to remote host."
X	rm -f $datafile
X	exit 0
Xelse
X	echo Salted Segment comprises $numlines users	# Don't quote this...
Xfi
X
X###
X# Now for the important bits. Create a diefile pointing to a remote diefile
X# (It's easier to get Crack.network to wire $remotediefile into arglist)
X###
X
Xremhost=$1				# Name of remote host ($2 == Crack path)
Xremotediefile=$3			# Name of remote diefile
Xlocaldiefile=Runtime/DR$remhost$$	# Local pointer to above
X
Xawk -F: '
XBEGIN {
X	rshell = "'"$remote_shell"'";
X	rhost = "'"$remhost"'";
X	rdie = "'"$remotediefile"'";
X	rdie = substr(rdie,3,length(rdie) - 2);
X}
X
X$1 == rhost {
X	if ($4 != "")
X	{
X		rshf = "-l " $4 " -n";
X	} else
X	{
X		rshf = "-n";
X	}
X	if ($5 != "")
X	{
X		nf = split($5, path, "/");
X		ch = path[1];
X		for (i = 2; i < nf; i++)
X		{
X			ch = ch "/" path[i];
X		}
X	} else
X	{
X		ch = "'"$CRACK_HOME_UNRES"'";
X	}
X}
X
XEND {
X	print "#!/bin/sh";
X	print "rm $0 && " rshell, rhost, rshf, "\"cd " ch ";" rdie "\"";
X}' < Scripts/network.conf > $localdiefile
X
Xchmod 700 $localdiefile
X
Xif [ "x$asynch_mode" = "x-asynch" ]
Xthen
X	if [ "x$CRACK_OUT" != "x" ]
X	then
X		outfile=$CRACK_OUT/out.r$$
X	else
X		outfile=./out.r$$
X	fi
X
X	# 'rsh' traps SIGHUP and survives OK
X
X	echo "Invoking: $remote_shell $@ <$datafile >$outfile 2>&1 && rm -f $datafile $localdiefile &"
X	$remote_shell "$@" <$datafile >$outfile 2>&1 && rm -f $datafile $localdiefile &
Xelse
X	# Perfectly ordinary network crack.
X	echo "Invoking: $remote_shell $@ < $datafile"
X	$remote_shell "$@" < $datafile
X	rm -f $datafile
Xfi
X
Xexit 0
END_OF_FILE
if test 3370 -ne `wc -c <'Scripts/RCrack'`; then
    echo shar: \"'Scripts/RCrack'\" unpacked with wrong size!
fi
chmod +x 'Scripts/RCrack'
# end of 'Scripts/RCrack'
fi
if test -f 'Scripts/clean' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/clean'\"
else
echo shar: Extracting \"'Scripts/clean'\" \(447 characters\)
sed "s/^X//" >'Scripts/clean' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xmake -f Scripts/crack.mf clean
X
Xexit 0
END_OF_FILE
if test 447 -ne `wc -c <'Scripts/clean'`; then
    echo shar: \"'Scripts/clean'\" unpacked with wrong size!
fi
chmod +x 'Scripts/clean'
# end of 'Scripts/clean'
fi
if test -f 'Scripts/crack.mf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/crack.mf'\"
else
echo shar: Extracting \"'Scripts/crack.mf'\" \(315 characters\)
sed "s/^X//" >'Scripts/crack.mf' <<'END_OF_FILE'
XSRCDIR=		Sources
XBIGDICT=	Dicts/bigdict
XUFCDIR=		ufc-crypt
X
Xall:
X		@echo CALL TO CRACK.MF WITH NO TARGET
X
Xspotless:	clean
X		-rm -f out.* $(BIGDICT)* Dicts/.lock*
X		-Scripts/mrgfbk
X
Xclean:
X		-rm -f Runtime/D* Runtime/P* Runtime/RD* tmp.* nohup.out
X		-( cd $(SRCDIR) && make clean )
X		-( cd $(UFCDIR) && make clean )
END_OF_FILE
if test 315 -ne `wc -c <'Scripts/crack.mf'`; then
    echo shar: \"'Scripts/crack.mf'\" unpacked with wrong size!
fi
# end of 'Scripts/crack.mf'
fi
if test -f 'Scripts/do_install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/do_install'\"
else
echo shar: Extracting \"'Scripts/do_install'\" \(759 characters\)
sed "s/^X//" >'Scripts/do_install' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xcrack_arch=$1
X
X###
X# Is there a binaries directory ?
X###
X
Xif [ ! -d $crack_arch ]
Xthen
X	mkdir $crack_arch || exit 1
Xfi
X
Xcd $crack_arch || exit 1                        # Can we get there from here ?
X
X###
X# Install makefiles in our directory if necessary.
X###
X
Xif [ ! -f Makefile ]
Xthen
X	cp $CRACK_HOME/Scripts/install.mf Makefile || exit 1
Xfi
X
Xexit 0
END_OF_FILE
if test 759 -ne `wc -c <'Scripts/do_install'`; then
    echo shar: \"'Scripts/do_install'\" unpacked with wrong size!
fi
chmod +x 'Scripts/do_install'
# end of 'Scripts/do_install'
fi
if test -f 'Scripts/do_join' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/do_join'\"
else
echo shar: Extracting \"'Scripts/do_join'\" \(1910 characters\)
sed "s/^X//" >'Scripts/do_join' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# Empty the output file, Error if cannot create
X###
X
Xwarn=$1
Xshift
Xcp /dev/null $warn || exit 1
X
X###
X# Have we got feedback ?
X###
X
Xfbkfiles=`sh -c "echo Runtime/F*"`
Xif [ "$fbkfiles" = "Runtime/F*" ]
Xthen
X	fbkfiles=""
Xfi
X
X###
X# As Walt Disney would say, we start with a simple bracket:-
X###
X
X(
X	if [ "$fbkfiles" != "" ]
X	then
X		cat $fbkfiles
X	fi
X
X	(
X		for file in $*
X		do
X			awk '/^[A-Za-z0-9]/ {print "'"$file"':" $0}' < $file
X		done
X	) |
X	sort -t: +2
X) |
Xawk -F: '
XBEGIN {
X	FS = ":";
X	numf = 8;		# number of fields in a pwent, + 1
X	warn="'"$warn"'";
X	date = "'"`date`"'";
X	date = substr(date, 5, 15);
X}
X
X/^!fb!/ {
X	if ($3 == "N")
X	{
X		guessable[$2] = "N";
X	} else if ($3 == "Y")
X	{
X		guessable[$2] = "Y";
X		decrypt[$2] = $4;
X	} else
X	{
X		print "Strange feedback: ", $0 >> "/dev/tty";
X	}
X	next;
X}
X
XNF != numf {
X	printf("join: Rejected '%s': does not have %d fields\n", \
X		$0, numf) >> warn;
X	next;
X}
X
X$3 == "" {
X	printf("join: %s Warning! %s (%s in %s) has a NULL password!\n", \
X		date, $2, $7, $1) >> warn;
X	next;
X}
X
Xindex($3, "*") != 0 || \
Xindex($3, "!") != 0 || \
Xindex($3, " ") != 0 {
X	printf("join: %s User %s (in %s) has a locked password:- %s\n", \
X		date, $2, $1, $3) >> warn;
X	next;
X}
X
X{
X	if (guessable[$3] == "N")
X	{
X		next;
X	} else if (guessable[$3] == "Y")
X	{
X		if ($4 == 0)
X		{
X			msg = "ROOT PASSWORD ";
X		} else
X		{
X			msg = "";
X		}
X		printf("join: %s Guessed %s%s (%s in %s) [%s] %s\n", \
X			date, msg, $2, $8, $1, decrypt[$3], $3) >> warn;
X	} else
X	{
X		print $0;
X	}
X}'
X
Xexit 0
END_OF_FILE
if test 1910 -ne `wc -c <'Scripts/do_join'`; then
    echo shar: \"'Scripts/do_join'\" unpacked with wrong size!
fi
chmod +x 'Scripts/do_join'
# end of 'Scripts/do_join'
fi
if test -f 'Scripts/do_pwc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/do_pwc'\"
else
echo shar: Extracting \"'Scripts/do_pwc'\" \(658 characters\)
sed "s/^X//" >'Scripts/do_pwc' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xcrack_arch=$1
X
Xif [ ! -d $crack_arch ]
Xthen
X	Scripts/do_install $crack_arch || exit 1
Xfi
X
Xcd $crack_arch || exit 1                        # Can we get there from here ?
X
X###
X# Make the password cracker
X###
X
Xmake crack-pwc || exit 1
X
X# bye bye
Xexit 0
END_OF_FILE
if test 658 -ne `wc -c <'Scripts/do_pwc'`; then
    echo shar: \"'Scripts/do_pwc'\" unpacked with wrong size!
fi
chmod +x 'Scripts/do_pwc'
# end of 'Scripts/do_pwc'
fi
if test -f 'Scripts/do_ufc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/do_ufc'\"
else
echo shar: Extracting \"'Scripts/do_ufc'\" \(1437 characters\)
sed "s/^X//" >'Scripts/do_ufc' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# This script tries to provide an intelligent hook to the UFC-crypt library
X###
X
Xif [ "x$CRACK_HOME" = "x" ]
Xthen
X	CRACK_HOME=".."		# for would-be developers in the Sources dir
Xfi
X
XUFCLIB=libufc.a
XSRCDIR=$CRACK_HOME/Sources
XUFCDIR=$CRACK_HOME/ufc-crypt
X
Xrm -f $SRCDIR/libufc.a		# just in case
X
Xecho "Looking for UFC-crypt in $UFCDIR"
X
Xif [ ! -d $UFCDIR ]
Xthen
X	echo "Cannot find $UFCDIR - cannot use UFC-crypt on this platform"
X	exit 1
Xfi
X
Xcd $UFCDIR || exit 1
X
Xecho "Crack: Trying to compile UFC-crypt (external product by Michael Glad)"
Xecho "Crack: Working in $UFCDIR"
X
Xif [ -f libufc.a ]
Xthen
X	echo "Library libufc.a exists. Testing viability..."
X	rm -f ufc
X	make ufc
X	if [ $? = 0 ]
X	then
X		echo "Testing ufc"
X		./ufc 1
X		if [ $? = 0 ]
X		then
X			echo "Crack will use UFC-crypt on this platform"
X			exit 0
X		fi
X	fi
X	echo "Library is unviable on this architecture. Remaking"
Xfi
X
Xmake clean || exit 1
X
Xmake ufc || exit 1
X
Xecho "Testing ufc"
X./ufc 1 || exit 1
X
Xecho "Crack WILL use $UFCDIR/libufc.a on this platform."
Xexit 0
END_OF_FILE
if test 1437 -ne `wc -c <'Scripts/do_ufc'`; then
    echo shar: \"'Scripts/do_ufc'\" unpacked with wrong size!
fi
chmod +x 'Scripts/do_ufc'
# end of 'Scripts/do_ufc'
fi
if test -f 'Scripts/gecos.rules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/gecos.rules'\"
else
echo shar: Extracting \"'Scripts/gecos.rules'\" \(693 characters\)
sed "s/^X//" >'Scripts/gecos.rules' <<'END_OF_FILE'
X###
X# Try to avoid redundancy in this file... AEM
X###
X
X>2
X>2/?ul
X>2/?lu
X>2ud
X>2uf
X>2ur
X>2cf
X>2cr
X>2rc
X>2ld
X>2lf
X>2lr
X>2<8c$!
X>2<8c$.
X>2<8c$?
X>2^($)
X
X>2<8$!
X>2<8$.
X>2<8$0
X>2<8$1
X>2<8$2
X>2<8$3
X>2<8$4
X>2<8$5
X>2<8$6
X>2<8$7
X>2<8$8
X>2<8$9
X
X>2<8/?ul$!
X>2<8/?ul$.
X>2<8/?ul$?
X>2<8/?ul$0
X>2<8/?ul$1
X>2<8/?ul$2
X>2<8/?ul$3
X>2<8/?ul$4
X>2<8/?ul$5
X>2<8/?ul$6
X>2<8/?ul$7
X>2<8/?ul$8
X>2<8/?ul$9
X
X>2<8/?lu$!
X>2<8/?lu$.
X>2<8/?lu$?
X>2<8/?lu$0
X>2<8/?lu$1
X>2<8/?lu$2
X>2<8/?lu$3
X>2<8/?lu$4
X>2<8/?lu$5
X>2<8/?lu$6
X>2<8/?lu$7
X>2<8/?lu$8
X>2<8/?lu$9
X
X!?d>2^0
X!?d>2^1
X!?d>2^2
X!?d>2^3
X!?d>2^4
X!?d>2^5
X!?d>2^6
X!?d>2^7
X!?d>2^8
X!?d>2^9
X
X>2/?ul^0
X>2/?ul^1
X>2/?ul^2
X>2/?ul^3
X>2/?ul^4
X>2/?ul^5
X>2/?ul^6
X>2/?ul^7
X>2/?ul^8
X>2/?ul^9
END_OF_FILE
if test 693 -ne `wc -c <'Scripts/gecos.rules'`; then
    echo shar: \"'Scripts/gecos.rules'\" unpacked with wrong size!
fi
# end of 'Scripts/gecos.rules'
fi
if test -f 'Scripts/guess2fbk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/guess2fbk'\"
else
echo shar: Extracting \"'Scripts/guess2fbk'\" \(859 characters\)
sed "s/^X//" >'Scripts/guess2fbk' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# guess2fbk : generates a 'feedback' file on stdout from output format
X# data.  On occasions when emergency construction is useful.
X###
X
Xif [ $# = 0 ]
Xthen
X	echo "Usage:	$0 outputfile [...]"
X	exit 1
Xfi
X
X###
X# Had to modify this awk script now that passwords are turning up with spaces
X###
X
Xcat $* |
Xawk '
X/Guessed/{
X	start = index($0, "[");
X	stop = index($0, "]");
X	print "!fb!:" $NF ":Y:" substr($0, start+1, stop - start - 1)
X}
X' |
Xsort |
Xuniq
X
END_OF_FILE
if test 859 -ne `wc -c <'Scripts/guess2fbk'`; then
    echo shar: \"'Scripts/guess2fbk'\" unpacked with wrong size!
fi
chmod +x 'Scripts/guess2fbk'
# end of 'Scripts/guess2fbk'
fi
if test -f 'Scripts/install.mf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/install.mf'\"
else
echo shar: Extracting \"'Scripts/install.mf'\" \(726 characters\)
sed "s/^X//" >'Scripts/install.mf' <<'END_OF_FILE'
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
XSD=	../Sources
XSRC1=	$(SD)/conf.h $(SD)/crack-fcrypt.c $(SD)/crack-glob.c
XSRC2=	$(SD)/crack-glob.h $(SD)/crack-lib.c $(SD)/crack-pwc.c
XSRC3=	$(SD)/crack-sort.c $(SD)/crack-supp.c $(SD)/crack.h
XSRCS=	$(SRC1) $(SRC2) $(SRC3)
X
Xcrack-pwc: $(SRCS)
X	( cd $(SD) ; make clean )
X	( cd $(SD) ; make crack-pwc.which )
X	cp $(SD)/crack-pwc .
END_OF_FILE
if test 726 -ne `wc -c <'Scripts/install.mf'`; then
    echo shar: \"'Scripts/install.mf'\" unpacked with wrong size!
fi
# end of 'Scripts/install.mf'
fi
if test -f 'Scripts/mrgfbk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/mrgfbk'\"
else
echo shar: Extracting \"'Scripts/mrgfbk'\" \(1243 characters\)
sed "s/^X//" >'Scripts/mrgfbk' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# mrgfbk - a shell script to merge all of your feedback files into one
X# before starting a Crack -F on a set of new dictionaries. This program
X# is called from "Scripts/spotless"
X###
X# mrgfbk takes all the feedback files and filters out all the GUESSED
X# passwords, and saves them to a new feedback file.  The UNGUESSED
X# passwords are deleted, so that the new dictionaries can have a go at
X# them 
X###
X
Xtf=./mfb$$
X
Xecho ""
Xecho "Saving all CRACKABLE passwords.
XDo you also want to save your UNCRACKABLE passwords ?
XAnswer NO if you have changed some rules or modified source dictionaries
X(default: yes) "
X
Xread answer
X
Xcase $answer in
X	[Nn]*)
X		cat Runtime/F* |
X		awk -F: '$3 == "Y"' |
X		sort |
X		uniq > $tf
X		;;
X	*)
X		cat Runtime/F* |
X		sort |
X		uniq > $tf
X		;;
Xesac
X
Xrm -f Runtime/F*
X
Xcp $tf Runtime/F.merged
X
Xrm -f $tf
X
Xexit 0
END_OF_FILE
if test 1243 -ne `wc -c <'Scripts/mrgfbk'`; then
    echo shar: \"'Scripts/mrgfbk'\" unpacked with wrong size!
fi
chmod +x 'Scripts/mrgfbk'
# end of 'Scripts/mrgfbk'
fi
if test -f 'Scripts/nastygram' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/nastygram'\"
else
echo shar: Extracting \"'Scripts/nastygram'\" \(1452 characters\)
sed "s/^X//" >'Scripts/nastygram' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xfor username in $*
Xdo
X        mail $username <<EndOfLetter
X                                        `date`
X
XDear $username,
X
XThe login password you use for the account "$username" has been found to
Xbe insecure by the "Crack" password guessing program.  You must change
Xyour password as soon as possible. 
X
XPasswords which are not easily compromised by programs such as "Crack"
Xare based upon non-dictionary words, hence any word which might appear
Xin a dictionary, EVEN IF IT IS SUPPOSEDLY A OBSCURE WORD is unsuitable. 
X
XSimilarly, any password which is derived from your name, department or
Xother personal information is unsuitable because it can be easily
Xguessed. 
X
XIt is important that password security be maintained at a high level for
Xthe sake of ALL the people who use these computers.  We thank you for
Xyour co-operation in this matter. 
X
X                                Yours,
X
X                                        Alec Muffett, Aberystwyth, UK
X                                        pp Your System Administrator
XEndOfLetter
Xdone
END_OF_FILE
if test 1452 -ne `wc -c <'Scripts/nastygram'`; then
    echo shar: \"'Scripts/nastygram'\" unpacked with wrong size!
fi
chmod +x 'Scripts/nastygram'
# end of 'Scripts/nastygram'
fi
if test -f 'Scripts/network.conf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/network.conf'\"
else
echo shar: Extracting \"'Scripts/network.conf'\" \(2365 characters\)
sed "s/^X//" >'Scripts/network.conf' <<'END_OF_FILE'
X###
X# Format of this file:-
X###
X#
X# host:binary type:relative power:rsh user:crack path:crack flags:comment
X#
X#	host = hostname to 'rsh' to
X#	binary type = type of executable to build on this sort of machine
X#	relative power = power of host relative to weakest machine
X#	rsh user = username to 'rsh -l' to, if not same as current user.
X#	crack path = full path name of Crack on host (deft: $CRACK_HOME/Crack)
X#	crack flags = additional flags to add to crack command line on that host
X#	comment = anything, really, for your reference
X#
X#	1) Don't bother specifying "-F" amongst "crack flags" as the
X#	one which you use on the command line will be passed across.
X#
X#	2) You CAN specify "-f" here, to throw the remote password cracker
X#	into foreground mode for non-NFS working, but please read the docs
X#	thoroughly first.
X###
X# I have specified relative power here as the number of fcrypts per second
X# that each host is (roughly) capable of. This is a perfectly good way to
X# define relative power, but if you are at a loss, call your weakest machine
X# '1', and measure all others in terms of that.
X###
X
X#### Mainframe power boxes
X#aberda:mipsel:600:::-n10: Mainframe Dec 5830
X#aberdb:mipsel:600:::-n10: Mainframe Dec 5830
X##aberdc:mipsel:1200:::: Mainframe DecStation 5000/200
X#aberdq:sun4:1000:::: Mainframe Sun 4/330
X
X#### Some of the CS machines over an rsh link - souped up Sun 3/50s
X##odin:sun3:50::~aem/Crack/Crack:-n10 -f: Computer Science Server
X##thor:sun3:50::~aem/Crack/Crack:-n10 -f: Computer Science Server
X
X#### Colour DECStation 2100's
X#decgca:mipsel:700:::-n4: Graphics Room DecStation 2100
X#decgcb:mipsel:700:::-n4: Graphics Room DecStation 2100
X#decgcc:mipsel:700:::-n4: Graphics Room DecStation 2100
X#decgcd:mipsel:700:::-n4: Graphics Room DecStation 2100
X##decgce:mipsel:700:::-n4: Nigel's 2100 gets switched off nites
X
X#### Monochrome DECStation 2100's
X#decgma:mipsel:700:::-n4: Graphics Room DecStation 2100
X##decgmb:mipsel:700:::-n4:DecStation 2100 cannabalised for parts
X##decgmc:mipsel:700:::-n4: Graphics Room DecStation 2100
X##decgmd:mipsel:700:::-n4: Graphics Room DecStation 2100
X##decgme:mipsel:700:::-n4: Graphics Room DecStation 2100
X
X#### Sun 3/50C's which are barely worth bothering about
X##sunga:sun3:100:::-n4: Graphics Room Sun 3/50
X##sunga:sun3:100:::-n4: Graphics Room Sun 3/50
X##sunga:sun3:100:::-n4: Graphics Room Sun 3/50
END_OF_FILE
if test 2365 -ne `wc -c <'Scripts/network.conf'`; then
    echo shar: \"'Scripts/network.conf'\" unpacked with wrong size!
fi
# end of 'Scripts/network.conf'
fi
if test -f 'Scripts/plaster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/plaster'\"
else
echo shar: Extracting \"'Scripts/plaster'\" \(664 characters\)
sed "s/^X//" >'Scripts/plaster' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# This program provides a quick network murder if running "Crack -network"
X###
X# The name is Chris Samuel's fault... "Plaster the Cracks" indeed...
X# Mail admiration of this joke to ccs7@aber.ac.uk
X###
X
Xfor i in Runtime/D*
Xdo
X	echo $i
X	$i
Xdone
X
Xexit 0
END_OF_FILE
if test 664 -ne `wc -c <'Scripts/plaster'`; then
    echo shar: \"'Scripts/plaster'\" unpacked with wrong size!
fi
chmod +x 'Scripts/plaster'
# end of 'Scripts/plaster'
fi
if test -f 'Scripts/saltcount' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/saltcount'\"
else
echo shar: Extracting \"'Scripts/saltcount'\" \(627 characters\)
sed "s/^X//" >'Scripts/saltcount' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
X###
X# Count the number of individual salts in do_join format...
X###
X
Xawk -F: '
XBEGIN {
X	i = 0;		# Just in case there is no input
X}
Xsubstr($3, 1, 2) != last {
X	i++;
X	last = substr($3, 1, 2);
X}
XEND {
X	print i;
X}'
X
Xexit 0
END_OF_FILE
if test 627 -ne `wc -c <'Scripts/saltcount'`; then
    echo shar: \"'Scripts/saltcount'\" unpacked with wrong size!
fi
chmod +x 'Scripts/saltcount'
# end of 'Scripts/saltcount'
fi
if test -f 'Scripts/shadmrg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/shadmrg'\"
else
echo shar: Extracting \"'Scripts/shadmrg'\" \(948 characters\)
sed "s/^X//" >'Scripts/shadmrg' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xshadow=/etc/shadow
Xpasswd=/etc/passwd
X
X###
X# Merge /etc/shadow & /etc/passwd for Crack.  Assume 7 fields for /etc/passwd,
X# and other for /etc/shadow
X###
X
Xcat $passwd $shadow |
Xawk -F: '
XBEGIN {
X	OFS = ":";
X}
X
XNF == 7 {
X	pwents[$1] = $0;
X}
X
XNF != 7 {
X	shadow_pw[$1] = $2;
X}
X
XEND {
X	for (pw_name in pwents)
X	{
X		fields = split(pwents[pw_name], pwd, ":");
X
X		if (shadow_pw[pwd[1]] != "LOCKED")
X		{
X			print 	pwd[1], \
X				shadow_pw[pwd[1]], \
X				pwd[3], \
X				pwd[4], \
X			        pwd[5], \
X			        pwd[6], \
X			        pwd[7];
X		}
X	}
X}'
END_OF_FILE
if test 948 -ne `wc -c <'Scripts/shadmrg'`; then
    echo shar: \"'Scripts/shadmrg'\" unpacked with wrong size!
fi
chmod +x 'Scripts/shadmrg'
# end of 'Scripts/shadmrg'
fi
if test -f 'Scripts/spotless' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/spotless'\"
else
echo shar: Extracting \"'Scripts/spotless'\" \(554 characters\)
sed "s/^X//" >'Scripts/spotless' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xecho "Are you sure that you want to do this ? (no)"
Xread ans
X
Xcase $ans in
X	[Yy]*)
X		make -f Scripts/crack.mf spotless
X		;;
X	*)
X		;;
Xesac
X
Xexit 0
END_OF_FILE
if test 554 -ne `wc -c <'Scripts/spotless'`; then
    echo shar: \"'Scripts/spotless'\" unpacked with wrong size!
fi
chmod +x 'Scripts/spotless'
# end of 'Scripts/spotless'
fi
if test -f 'Scripts/status' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Scripts/status'\"
else
echo shar: Extracting \"'Scripts/status'\" \(630 characters\)
sed "s/^X//" >'Scripts/status' <<'END_OF_FILE'
X#!/bin/sh
X
X###
X# This program is copyright Alec Muffett 1991, and is provided as part of
X# the Crack v4.0 Password Cracking package.  The author disclaims all
X# responsibility or liability with respect to it's usage or its effect
X# upon hardware or computer systems, and maintains copyright as set out in
X# the "LICENCE" document which accompanies distributions of Crack v4.0 and
X# upwards. So there...
X###
X
Xcat Scripts/network.conf | 
Xawk -F: '
X/^[A-Za-z]/{
X	print "echo ::: Calling", $1, " :-";
X
X	if ($4 == "")
X	{
X		rshf = "-n";
X	} else
X	{
X		rshf = "-n -l " $4;
X	}
X	print "rsh ", $1, rshf, "\"uptime ; ps x\"";
X} ' |
Xsh
X
Xexit 0
END_OF_FILE
if test 630 -ne `wc -c <'Scripts/status'`; then
    echo shar: \"'Scripts/status'\" unpacked with wrong size!
fi
chmod +x 'Scripts/status'
# end of 'Scripts/status'
fi
if test ! -d 'Sources' ; then
    echo shar: Creating directory \"'Sources'\"
    mkdir 'Sources'
fi
if test -f 'Sources/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/Makefile'\"
else
echo shar: Extracting \"'Sources/Makefile'\" \(1905 characters\)
sed "s/^X//" >'Sources/Makefile' <<'END_OF_FILE'
X###
X# Revised Makefile for Crack v4.1 - AEM, Feb 14 1992
X###
X
XLIBS=
XCFLAGS=		-O
XPWC= 		crack-pwc
XFCRYPT= 	crack-fcrypt.o
XOBJS= 		crack-lib.o crack-glob.o crack-supp.o crack-sort.o
XUFCLIB=		../ufc-crypt/libufc.a
XTRUNS=		1000
X
X###
X# The reason for the direct reference to libufc.a is to get round
X# obnoxious problems with ranlibbing a file after copying it on some
X# architectures. 
X###
X
X$(PWC).which:
X	@echo Choosing between Crack.fcrypt and Crack.ufc
X	-((../Scripts/do_ufc && make $(PWC).ufc) || make $(PWC).fcrypt)
X
X$(PWC).fcrypt:	$(OBJS) $(FCRYPT) $(PWC).o
X		$(CC) $(CFLAGS) -o $(PWC) $(PWC).o $(OBJS) $(FCRYPT) $(LIBS)
X
X$(PWC).ufc:	$(OBJS) $(PWC).o
X		$(CC) $(CFLAGS) -o $(PWC) $(PWC).o $(OBJS) $(UFCLIB) $(LIBS)
X
Xtestrule:	testrule.o crack-lib.o
X		$(CC) $(CFLAGS) -o $@ testrule.o crack-lib.o
X
Xtester:		tester.o $(OBJS) $(FCRYPT)
X		$(CC) $(CFLAGS) -o $@ tester.o $(OBJS) $(FCRYPT)
X
Xspeedufc:	speeds.c $(OBJS) $(UFC)
X		../Scripts/do_ufc
X		$(CC) $(CFLAGS) -DT1 -o $@ speeds.c $(OBJS) $(UFCLIB)
X
Xspeedfcrypt:	speeds.c $(OBJS) $(FCRYPT)
X		$(CC) $(CFLAGS) -DT1 -o $@ speeds.c $(OBJS) $(FCRYPT)
X
Xspeedxform:	speeds.c $(OBJS) $(FCRYPT)
X		$(CC) $(CFLAGS) -DT2 -o $@ speeds.c $(OBJS) $(FCRYPT)
X
Xspeedcrypt:	speeds.c $(OBJS) $(FCRYPT)
X		$(CC) $(CFLAGS) -o $@ speeds.c $(OBJS) $(FCRYPT)
X
Xtests:		tester speedcrypt speedfcrypt speedxform speedufc
X		-tester $(TRUNS)
X		-speedcrypt
X		-speedfcrypt
X		-speedxform
X		-speedufc
X
Xbytesex: 	bytesex.o
X		$(CC) $(CFLAGS) -o $@ bytesex.o
X
X$(FCRYPT):	crack-fcrypt.c crack.h bytesex
X		$(CC) $(CFLAGS) `./bytesex` -c crack-fcrypt.c
X
X$(PWC).o:	crack.h conf.h
X
Xcrack-glob.o:	crack.h
X
Xcrack-lib.o:	crack.h conf.h
X
Xcrack-sort.o:	crack.h
X
Xcrack-supp.o:	crack.h conf.h
X
Xtestrule.o:	crack.h
X
Xcrack.h:	crack-glob.h
X		touch crack.h
X
Xconf.h:
X
Xclean:
X		-rm -f *.o *.u *.a *.pixie *.Addrs *.Counts
X		-rm -f $(PWC) tester bytesex testrule
X		-rm -f speedcrypt speedfcrypt speedxform speedufc
END_OF_FILE
if test 1905 -ne `wc -c <'Sources/Makefile'`; then
    echo shar: \"'Sources/Makefile'\" unpacked with wrong size!
fi
# end of 'Sources/Makefile'
fi
if test -f 'Sources/bytesex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/bytesex.c'\"
else
echo shar: Extracting \"'Sources/bytesex.c'\" \(564 characters\)
sed "s/^X//" >'Sources/bytesex.c' <<'END_OF_FILE'
X#include <stdio.h>
X
Xmain ()
X{
X    char *p;
X    long int l;
X
X    l = 'a' << 24 | 'b' << 16 | 'c' << 8 | 'd';
X    p = (char *) &l;
X
X    if (sizeof (long int) == 4)
X    {
X#ifndef GCC			/* gcc tends to make a botch of it */
X	puts ("-DFDES_4BYTE");
X#endif
X    } else if (sizeof (long int) == 8)
X    {
X	puts ("-DFDES_8BYTE");
X	l <<= 32;
X    } else
X    {
X	printf ("-DFDES_%dBYTE%c", sizeof (long int), 10);
X    }
X    if (!strncmp (p, "abcd", 4))
X    {
X	puts ("-DBIG_ENDIAN");
X    } else if (!strncmp (p, "dcba", 4))
X    {
X	puts ("-DLITTLE_ENDIAN");
X    }
X    exit (0);
X}
END_OF_FILE
if test 564 -ne `wc -c <'Sources/bytesex.c'`; then
    echo shar: \"'Sources/bytesex.c'\" unpacked with wrong size!
fi
# end of 'Sources/bytesex.c'
fi
if test -f 'Sources/conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/conf.h'\"
else
echo shar: Extracting \"'Sources/conf.h'\" \(2202 characters\)
sed "s/^X//" >'Sources/conf.h' <<'END_OF_FILE'
X/*
X * This program is copyright Alec Muffett 1991 except for some portions of
X * code in "crack-fcrypt.c" which are copyright Robert Baldwin, Icarus Sparry
X * and Alec Muffett.  The author(s) disclaims all responsibility or liability
X * with respect to it's usage or its effect upon hardware or computer
X * systems, and maintain copyright as set out in the "LICENCE" document which
X * accompanies distributions of Crack v4.0 and upwards.
X */
X
X#undef DEVELOPMENT_VERSION
X
X/*
X * define this symbol if you are on a system where you don't have the
X * strchr() function in your standard library (usually this means you are on
X * a BSD based system with no System 5isms) but you DO have the equivalent
X * index() function.
X */
X
X#undef INDEX_NOT_STRCHR
X
X/*
X * define this if you have a smart toupper() and tolower() (a-la ANSI), which
X * do not generate barf when something which is not a lowercase letter is
X * uppercased, or vice-versa (a-la K&R). Check your manpage or leave it
X * undefined
X */
X
X#undef FAST_TOCASE
X
X/*
X * define this if you are on a Sys V type system with a uname() system call
X * AND YOU HAVE NO gethostname() - it fakes up a BSD gethostname() so you can
X * use CRACK_NETWORK; see crack-port.c
X */
X
X#undef CRACK_UNAME
X
X/*
X * define CRACK_DOTFILES if you want to search the first 1Kb segment of users
X * .plan/.project/.signature files for potential passwords.
X * 
X * define CRACK_DOTSANE to likewise do (possibly non-portable) sanity testing
X * on the dotfiles before opening them (check that they are not named pipes,
X * etc...)
X */
X
X#undef CRACK_DOTFILES
X#undef CRACK_DOTSANE
X
X/*
X * define "COMPRESSION" if you have enabled compression in the Crack
X * Shellscript
X * 
X * this is enabled by default if you have /usr/ucb/compress; change the pathname
X * of the $compress variable in the Crack script if you use another pathname
X * to get to "compress" and then put the path name of the "pipe to stdout"
X * version of the compression prog here.
X */
X
X#define COMPRESSION
X#define ZCAT	"/usr/ucb/zcat"	/* as in "zcat Dicts/bigdict.Z" */
X#define PCAT	"/usr/bin/pcat"
X
X/*
X * define this if you are using fcrypt() - you might not want to if fcrypt()
X * doesn't work properly
X */
X
X#define FCRYPT
END_OF_FILE
if test 2202 -ne `wc -c <'Sources/conf.h'`; then
    echo shar: \"'Sources/conf.h'\" unpacked with wrong size!
fi
# end of 'Sources/conf.h'
fi
if test -f 'Sources/crack-glob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/crack-glob.c'\"
else
echo shar: Extracting \"'Sources/crack-glob.c'\" \(1388 characters\)
sed "s/^X//" >'Sources/crack-glob.c' <<'END_OF_FILE'
X#include "crack.h"
X
Xchar version[] = "4.1f";	/* version of prog */
Xchar runtime[] = "Runtime";
Xchar feedback_string[] = "!fb!";
Xchar rulefile[] = "Scripts/dicts.rules";
Xchar gecosfile[] = "Scripts/gecos.rules";
Xchar nastygram[] = "Scripts/nastygram";
Xchar zcat[] = ZCAT;
Xchar pcat[] = PCAT;
X
X/* runtime variable declarations */
X
Xint pid;			/* current process ID */
Xint pwlength = 8;		/* significant length of a password */
Xstruct USER *userroot;		/* root of linked list of users */
Xstruct RULE *ruleroot;		/* root of linked list of rules */
Xstruct RULE *gecosroot;		/* root of linked list of (gecos) rules */
Xstruct DICT *dictroot;		/* root of linked list of words */
X
X/* datafile variables */
X
Xchar diefile[STRINGSIZE];	/* where die output goes... */
Xchar feedbackfile[STRINGSIZE];	/* where feedback ouytput goes */
Xchar opfile[STRINGSIZE];	/* where Log() output goes */
Xchar pointfile[STRINGSIZE];	/* checkpointing */
Xchar this_hostname[STRINGSIZE];	/* gethostname() hack */
X
X/* recover variables */
X
Xchar old_hostname[STRINGSIZE];	/* next 4 vars used in recovery */
Xchar old_dictname[STRINGSIZE];
Xchar old_rule[STRINGSIZE];
Xint old_usernum;
Xchar old_username[STRINGSIZE];
X
X/* switches */
Xchar input_file[STRINGSIZE];
Xint foreground_bool;
Xint remote_bool;
Xint nice_value;
Xint recover_bool;
Xchar recover_file[STRINGSIZE];
Xint verbose_bool;
Xchar supplied_name[STRINGSIZE];
Xint mail_bool;
END_OF_FILE
if test 1388 -ne `wc -c <'Sources/crack-glob.c'`; then
    echo shar: \"'Sources/crack-glob.c'\" unpacked with wrong size!
fi
# end of 'Sources/crack-glob.c'
fi
if test -f 'Sources/crack-glob.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/crack-glob.h'\"
else
echo shar: Extracting \"'Sources/crack-glob.h'\" \(958 characters\)
sed "s/^X//" >'Sources/crack-glob.h' <<'END_OF_FILE'
Xextern char version[];
Xextern char runtime[];
Xextern char feedback_string[];
Xextern char rulefile[];
Xextern char gecosfile[];
Xextern char nastygram[];
Xextern char zcat[];
Xextern char pcat[];
Xextern int pid;
Xextern int pwlength;
Xextern struct USER *userroot;
Xextern struct RULE *ruleroot;
Xextern struct RULE *gecosroot;
Xextern struct DICT *dictroot;
Xextern char diefile[STRINGSIZE];
Xextern char feedbackfile[STRINGSIZE];
Xextern char opfile[STRINGSIZE];
Xextern char pointfile[STRINGSIZE];
Xextern char this_hostname[STRINGSIZE];
Xextern char old_hostname[STRINGSIZE];
Xextern char old_dictname[STRINGSIZE];
Xextern char old_rule[STRINGSIZE];
Xextern int old_usernum;
Xextern char old_username[STRINGSIZE];
Xextern char input_file[STRINGSIZE];
Xextern int foreground_bool;
Xextern int remote_bool;
Xextern int nice_value;
Xextern int recover_bool;
Xextern char recover_file[STRINGSIZE];
Xextern int verbose_bool;
Xextern char supplied_name[STRINGSIZE];
Xextern int mail_bool;
END_OF_FILE
if test 958 -ne `wc -c <'Sources/crack-glob.h'`; then
    echo shar: \"'Sources/crack-glob.h'\" unpacked with wrong size!
fi
# end of 'Sources/crack-glob.h'
fi
if test -f 'Sources/crack-supp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/crack-supp.c'\"
else
echo shar: Extracting \"'Sources/crack-supp.c'\" \(3409 characters\)
sed "s/^X//" >'Sources/crack-supp.c' <<'END_OF_FILE'
X/*
X * This program is copyright Alec Muffett 1991 except for some portions of
X * code in "crack-fcrypt.c" which are copyright Robert Baldwin, Icarus Sparry
X * and Alec Muffett.  The author(s) disclaims all responsibility or liability
X * with respect to it's usage or its effect upon hardware or computer
X * systems, and maintain copyright as set out in the "LICENCE" document which
X * accompanies distributions of Crack v4.0 and upwards.
X */
X
X#include "crack.h"
X
X#ifdef CRACK_UNAME
X#ifndef AMIGA
X#include <sys/utsname.h>
Xint
Xgethostname (name, namelen)
X    char *name;
X    int namelen;
X{
X    struct utsname uts;
X    if (uname (&uts))
X    {
X	return (-1);
X    }
X    strncpy (name, uts.nodename, namelen - 1);
X    return (0);
X}
X#else
Xint
Xgethostname (name, namelen)
X    char *name;
X    int namelen;
X{
X    strncpy (name, "dougal", namelen);
X    return (0);
X}
X#endif				/* AMIGA */
X#endif				/* CRACK_UNAME */
X
X/* log anything to datafile. */
X
Xvoid
XLog (fmt, a, b, c, d, e, f, g, h, i, j)
X    char *fmt;
X    long int a, b, c, d, e, f, g, h, i, j;
X{
X    long t;
X
X    time (&t);
X    printf ("pwc: %-15.15s ", ctime (&t) + 4);
X    printf (fmt, a, b, c, d, e, f, g, h, i, j);
X    fflush (stdout);
X}
X/* print a guess, giving a single place to mod where necessary */
X
Xvoid
XPrintGuess (eptr, guess)
X    register struct USER *eptr;
X    char *guess;
X{
X    eptr -> done = 1;
X    eptr -> passwd_txt = Clone (guess);	/* ESSENTIAL to FeedBack() */
X
X    if (!eptr -> passwd_txt)
X    {
X	eptr -> passwd_txt = "<Ran out of memory logging this password>";
X    }
X    Log ("Guessed %s%s (%s in %s) [%s] %s\n",
X	 (eptr -> passwd.pw_uid ? "" : "ROOT PASSWORD "),
X	 eptr -> passwd.pw_name,
X	 eptr -> passwd.pw_shell,
X	 eptr -> filename,
X	 guess,
X	 eptr -> passwd.pw_passwd);
X
X    if (mail_bool)
X    {
X	char dobuff[STRINGSIZE];
X
X	sprintf (dobuff, "%s %s", nastygram, eptr -> passwd.pw_name);
X	system (dobuff);
X    }
X}
X
X
X/* write a pointfile out */
X
Xint
XSetPoint (dict, rule, usernum, username)
X    char *dict;
X    char *rule;
X    int usernum;
X    char *username;
X{
X    FILE *fp;
X    long t;
X
X    if (!(fp = fopen (pointfile, "w")))
X    {
X	perror (pointfile);
X	return (-1);
X    }
X    time (&t);
X
X    fprintf (fp, "host=%s pid=%d pointtime=%s", this_hostname, pid, ctime (&t));
X    fprintf (fp, "%s\n", this_hostname);
X    fprintf (fp, "%s\n", dict);
X    fprintf (fp, "%s\n", rule);
X    fprintf (fp, "%d\n", usernum);
X    fprintf (fp, "%s\n", username);
X
X    fclose (fp);
X
X    return (0);
X}
X/* read a pointfile in... */
X
Xint
XGetPoint (pf)
X    char *pf;
X{
X    FILE *fp;
X    char buffer[STRINGSIZE];
X
X    if (!(fp = fopen (pf, "r")))
X    {
X	perror (pf);
X	return (-1);
X    }
X    /* junk */
X    if (!fgets (buffer, STRINGSIZE, fp))
X    {
X	return (-2);
X    }
X    /* hostname */
X    if (!fgets (old_hostname, STRINGSIZE, fp))
X    {
X	return (-3);
X    }
X    /* dictname */
X    if (!fgets (old_dictname, STRINGSIZE, fp))
X    {
X	return (-4);
X    }
X    /* rule */
X    if (!fgets (old_rule, STRINGSIZE, fp))
X    {
X	return (-5);
X    }
X    /* usernum */
X    if (!fgets (buffer, STRINGSIZE, fp))
X    {
X	return (-6);
X    }
X    /* username */
X    if (!fgets (old_username, STRINGSIZE, fp))
X    {
X	return (-7);
X    }
X    Trim (old_hostname);
X
X    if (strcmp (old_hostname, this_hostname))
X    {
X	return (-8);
X    }
X    Trim (old_dictname);
X    Trim (old_rule);
X
X    old_usernum = atoi (buffer);
X
X    Trim (old_username);
X
X    fclose (fp);
X
X    return (0);
X}
END_OF_FILE
if test 3409 -ne `wc -c <'Sources/crack-supp.c'`; then
    echo shar: \"'Sources/crack-supp.c'\" unpacked with wrong size!
fi
# end of 'Sources/crack-supp.c'
fi
if test -f 'Sources/crack.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/crack.h'\"
else
echo shar: Extracting \"'Sources/crack.h'\" \(1805 characters\)
sed "s/^X//" >'Sources/crack.h' <<'END_OF_FILE'
X/*
X * This program is copyright Alec Muffett 1991 except for some portions of
X * code in "crack-fcrypt.c" which are copyright Robert Baldwin, Icarus Sparry
X * and Alec Muffett.  The author(s) disclaims all responsibility or liability
X * with respect to it's usage or its effect upon hardware or computer
X * systems, and maintain copyright as set out in the "LICENCE" document which
X * accompanies distributions of Crack v4.0 and upwards.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <pwd.h>
X#include <signal.h>
X
X#include "conf.h"
X
X#define STRINGSIZE	256
X
X#ifdef DEVELOPMENT_VERSION
X#define BUILTIN_CLEAR
X#undef BRAINDEAD6
X#define CRACK_UNAME
X#endif
X
Xextern void Trim ();
Xextern char *Reverse ();
Xextern char *Uppercase ();
Xextern char *Lowercase ();
Xextern char *Clone ();
Xextern char *Mangle ();
Xextern int gethostname ();
X
X#ifdef FAST_TOCASE
X#define CRACK_TOUPPER(x)	(toupper(x))
X#define CRACK_TOLOWER(x)	(tolower(x))
X#else
X#define CRACK_TOUPPER(x)	(islower(x) ? toupper(x) : (x))
X#define CRACK_TOLOWER(x)	(isupper(x) ? tolower(x) : (x))
X#endif
X
X#ifdef FCRYPT
X#define crypt(a,b)		fcrypt(a,b)
X#endif
X
X#ifdef INDEX_NOT_STRCHR
X#define strchr(a,b) 		index(a,b)
X#endif
X
Xstruct USER
X{
X    struct USER *next;		/* next users with different salt */
X    struct USER *across;	/* line of users with same salt */
X    char *filename;		/* where we got it from */
X    char *passwd_txt;		/* plaintext of password */
X    struct passwd passwd;	/* ...guess... */
X    int done;			/* bool flag */
X};
X
Xstruct DICT
X{
X    struct DICT *next;		/* simple linked list */
X    char word[1];		/* ...<snigger>... */
X};
X
X/* include lyrics of "perfect circle" by R.E.M. at this point */
X
Xstruct RULE
X{
X    struct RULE *next;
X    char *rule;
X};
X
X#define STRCMP(x,y)		( *(x) == *(y) ? strcmp((x),(y)) : -1 )
X
X#include "crack-glob.h"
END_OF_FILE
if test 1805 -ne `wc -c <'Sources/crack.h'`; then
    echo shar: \"'Sources/crack.h'\" unpacked with wrong size!
fi
# end of 'Sources/crack.h'
fi
if test -f 'Sources/speeds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/speeds.c'\"
else
echo shar: Extracting \"'Sources/speeds.c'\" \(1886 characters\)
sed "s/^X//" >'Sources/speeds.c' <<'END_OF_FILE'
X/*
X * This program is copyright Alec Muffett 1991 except for some portions of
X * code in "crack-fcrypt.c" which are copyright Robert Baldwin, Icarus Sparry
X * and Alec Muffett. The author(s) disclaims all responsibility or liability
X * with respect to it's usage or its effect upon hardware or computer
X * systems, and maintain copyright as set out in the "LICENCE" document which
X * accompanies distributions of Crack v4.0 and upwards.
X */
X
X/*  Cray portions Copyright (c) 1992 Tom Hutton. */
X#ifdef cray
X#include <sys/types.h>
X#include <time.h>
X#include <unistd.h>
X#include <ctype.h>
X#else
X#include <sys/time.h>
X#include <signal.h>
X#endif
X#include <stdio.h>
X
X#ifdef cray
X/*
X * Clocks to seconds and seconds to clocks
X */
X
X#define CTOS(X)  ((long) ((unsigned) (X) / (long) hz))
X#define STOC(X)  ((long) ((X) * hz))
X
Xstatic long hz;
X#endif
X
Xstatic int cnt;
X#define ITIME	10		/* Number of seconds to run test. */
X
Xvoid
XStop ()
X{
X    printf ("Did %f %s()s per second.\n",
X	    ((float) cnt) / ((float) ITIME),
X#ifdef T1
X	    "fcrypt"
X#else
X#ifdef T2
X	    "XForm"
X#else
X	    "crypt"
X#endif
X#endif
X    );
X    exit (0);
X}
Xmain ()
X{
X#ifdef	cray
X    static long vtime;
X#else
X    struct itimerval itv;
X#endif
X    static int quarters[4];
X
X#ifdef cray
X    hz = sysconf(_SC_CLK_TCK);      /* get # ticks per second */
X    vtime = STOC(ITIME);
X#else
X    bzero (&itv, sizeof (itv));
X#endif
X
X    printf ("Running for %d seconds of virtual time ...\n", ITIME);
X
X#if defined(T1) || defined(T2)
X    init_des ();
X#endif
X
X#ifdef cray
X    for (cnt = 0;cpused() <= vtime; cnt++)
X#else
X    signal (SIGVTALRM, Stop);
X    itv.it_value.tv_sec = ITIME;
X    itv.it_value.tv_usec = 0;
X    setitimer (ITIMER_VIRTUAL, &itv, NULL);
X
X    for (cnt = 0;; cnt++)
X#endif
X    {
X#ifdef T1
X	fcrypt ("fredfred", "eek");
X#else
X#ifdef T2
X	XForm (quarters, 0);
X#else
X	crypt ("fredfred", "eek");
X#endif
X#endif
X    }
X    Stop();
X}
END_OF_FILE
if test 1886 -ne `wc -c <'Sources/speeds.c'`; then
    echo shar: \"'Sources/speeds.c'\" unpacked with wrong size!
fi
# end of 'Sources/speeds.c'
fi
if test -f 'Sources/tester.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/tester.c'\"
else
echo shar: Extracting \"'Sources/tester.c'\" \(640 characters\)
sed "s/^X//" >'Sources/tester.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <time.h>
X
Xmain (argc, argv)
X    int argc;
X    char *argv[];
X{
X    register int i;
X    long int t;
X
X    if (argc < 2)
X    {
X	exit (1);
X    }
X    init_des ();
X
X    printf ("%s\n", fcrypt ("fredfred", "fredfred"));
X
X    if (strcmp (fcrypt ("fredfred", "fredfred"), "frxWbx4IRuBBA"))
X    {
X	printf ("Version of fcrypt() is not compatible with standard.\n");
X	exit (0);
X    }
X    i = atoi (argv[1]);
X
X    printf ("Doing %d fcrypts()\n", i);
X
X    time (&t);
X    printf ("%s", ctime (&t));
X
X    while (i--)
X    {
X	fcrypt ("fredfred", "fredfred");
X    }
X
X    time (&t);
X    printf ("%s", ctime (&t));
X
X    return (0);
X}
END_OF_FILE
if test 640 -ne `wc -c <'Sources/tester.c'`; then
    echo shar: \"'Sources/tester.c'\" unpacked with wrong size!
fi
# end of 'Sources/tester.c'
fi
if test -f 'Sources/testrule.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Sources/testrule.c'\"
else
echo shar: Extracting \"'Sources/testrule.c'\" \(517 characters\)
sed "s/^X//" >'Sources/testrule.c' <<'END_OF_FILE'
X#include "crack.h"
X
Xvoid
XLog (a, b, c, d, e, f, g)
X    char *a, b, c, d, e, f, g;
X{
X    printf (a, b, c, d, e, f, g);
X}
X
Xint
Xmain (argc, argv)
X    int argc;
X    char *argv[];
X{
X    int i;
X    char *ptr;
X    char buffer[STRINGSIZE];
X
X    while (!feof (stdin))
X    {
X	fgets (buffer, STRINGSIZE - 1, stdin);
X
X	Trim (buffer);
X
X	for (i = 1; i < argc; i++)
X	{
X	    ptr = Mangle (buffer, argv[i]);
X
X	    printf ("'%s'('%s') = '%s'\n",
X		    argv[i],
X		    buffer,
X		    ptr ? ptr : "(rejected)");
X	}
X    }
X    return (0);
X}
END_OF_FILE
if test 517 -ne `wc -c <'Sources/testrule.c'`; then
    echo shar: \"'Sources/testrule.c'\" unpacked with wrong size!
fi
# end of 'Sources/testrule.c'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
echo shar: Extracting \"'TODO'\" \(349 characters\)
sed "s/^X//" >'TODO' <<'END_OF_FILE'
X* replace recover/checkpoint code in entirety
X* make work over rsh link entirely
X* dictionaries shipped from central machine
X* code shipped from central machine (!)
X* regexp rules (is this really necessary ? what syntax the commands ?)
X* bottles of glenmorangie always welcome
X* multiprocessing ability
X
X- most of these will be in v5.0
X						- alec
END_OF_FILE
if test 349 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
fi
# end of 'TODO'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
