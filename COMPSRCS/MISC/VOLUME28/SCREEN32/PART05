Newsgroups: comp.sources.misc
From: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Subject:  v28i022:  screen-3.2 - multiple windows on an ASCII terminal, v3.2, Part05/11
Message-ID: <1992Feb9.223612.6657@sparky.imd.sterling.com>
X-Md4-Signature: f0ec29b1efacd75871fe316395f2c9fb
Date: Sun, 9 Feb 1992 22:36:12 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jnweiger@immd4.informatik.uni-erlangen.de (Juergen Weigert)
Posting-number: Volume 28, Issue 22
Archive-name: screen-3.2/part05
Environment: UNIX

#!/bin/sh
# do not concatenate these parts, unpack them in order with /bin/sh
# file screen3.2/screen.1 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping screen3.2/screen.1'
else
echo 'x - continuing file screen3.2/screen.1'
sed 's/^X//' << 'SHAR_EOF' >> 'screen3.2/screen.1' &&
options, just as if
.B \-R
were not specified.
.TP 5
.B \-s
sets the default shell to the program specified, instead of the value
in the environment variable $SHELL (or \*Q/bin/sh\*U if not defined).
This can also be defined through the \*Qshell\*U .screenrc command.
.SH CUSTOMIZATION
The \*Qsocket directory\*U defaults either to $HOME/.screen or preferably
to /local/screens. If
.I screen
is installed setuid-root, then the administrator
should compile screen with an adequate (not NFS mounted) SOCKDIR. If
.I screen
is not running setuid-root, the user can specify any mode 777 directory
in the environment variable $SCREENDIR.
.PP
When
.I screen
is invoked, it executes initialization commands from the files
\*Q/local/etc/screenrc\*U and
\*Q.screenrc\*U in the user's home directory. These are the \*Qprogrammer's
defaults\*U that can be overridden in the following ways: For the 
global screenrc file 
.I screen
searches for the environment variable $SYSSCREENRC. The user specific
screenrc file is searchend in $ISCREENRC, then $SCREENRC, then $HOME/.iscreenrc
and finally defaults to $HOME/.screenrc. The command line option \fB-c\fP takes
precedence over the user specific screenrc file.
Commands in these files are used to set options, bind functions to
keys, and to automatically establish one or more extra windows at the
beginning of your
.I screen
session.
Commands are listed one per line, with empty lines being ignored.
A command's arguments are separated by tabs or spaces, and may be
surrounded by single or double quotes.
A `#' turns the rest of the line into a comment, except in quotes.
Unintelligible lines are warned about and ignored.
Commands may contain references to environment variables. The 
syntax is the shell-like "$VAR " or "${VAR}". Note that this causes 
incompatibilities with previous 
.I screen
versions, as now the '$'-sign has to be protected with '\' if no
variable substitution shall be performed.
.PP
Customization can also be done 'on-line'. To enter the command mode type
`C-a :'. Setting flags (like scrollback, login, etc.) on-line may not have
the desired effect, as e.\|g. the command "C-a : login on" will affect
only the settings for the creation of new windows (just like within .screenrc).
If you intend to change flags
of the current window, then prepend the command with the keyword "set". E.\|g.
"C-a : set login on" will log this window in.
.PP
The following initialization commands are available:
.PP
.ne 3
.B "activity \fImessage\fP"
.sp
When any activity occurs in a background window that is being monitored,
.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qactivity\*U
command.
Each occurrence of `%' in \fImessage\fP is replaced by
the number of the window in which activity has occurred,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
.sp
X	'Activity in window %'
.sp
Note that monitoring is off for all windows by default, but can be altered
by use of the \*Qmonitor\*U command (C-a M).
.PP
.ne 3
.B "autodetach on\fP|\fBoff"
.sp
Sets whether 
.I screen
will automatically detach upon hangup, which
saves all your running programs until they are resumed with a
.B "screen -r"
command.
When turned off, a hangup signal will terminate 
.I screen
and all the processes it contains. Autodetach is on by default.
.PP
.ne 3
.B "bell \fImessage\fP"
.sp
When a bell character is sent to a background window,
.I screen
displays a notification in the message line.
The notification message can be re-defined by means of the \*Qbell\*U
command.
Each occurrence of `%' in \fImessage\fP is replaced by
the number of the window to which a bell has been sent,
and each occurrence of `~' is replaced by the definition for bell
in your termcap (usually an audible bell).
The default message is
.sp
X	'Bell in window %'
.sp
An empty message can be supplied to the \*Qbell\*U command to suppress
output of a message line (bell "").
.PP
.ne 3
.B "bind \fP\fIkey\fP [\fIfunction\fP [\fIargs\fP]]"
.sp
Bind a function to a key.
By default, each function provided by
.I screen
is bound to one or more keys as indicated by the above table, e.\|g. the
function to create a new window is bound to \*QC-c\*U and \*Qc\*U.
The \*Qbind\*U command can be used to redefine the key bindings and to
define new bindings.
The \fIkey\fP argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The argument can also be quoted, if you like.
If no further argument is given, any previously established binding
for this key is removed.
The \fIfunction\fP argument can be one of the following keywords:
.PP
.nf
X	select0	Switch to window #0
X	\0\0...
X	select9	Switch to window #9
X	aka	Change the current window's a.\|k.\|a.
X	clear	Clear the screen
X	colon	Enter one \*Q.screenrc\*U command on-the-fly.
X	copy	Select a piece of text.
X	detach	Detach \fIscreen\fP
X	flow	Toggle the current window's flow-control setting
X	hardcopy	Make hardcopy of current window
X	history	Use cut&paste to fetch a recently displayed line.
X	help	Display a list of the key bindings in effect
X	info	Display the current window's status information
X	kill	Kill the current window
X	lastmsg	Redisplay the last message line
X	lock	Run a screenlock program. 
X	log	Begin/end logging of the current window's output
X	login	Toggle the window's \*Qlogin\*U setting (/etc/utmp entry)
X	monitor	Toggle activity monitoring of the current window
X	next	Switch to the next window
X	other	Switch to the window displayed previously
X	paste	Paste in a selected piece of text.
X	pow_detach	Detach \fIscreen\fP and logout.
X	prev	Switch to the previous window
X	quit	Kill all windows and terminate
X	readbuffer	Take text from the exchange file.
X	redisplay	Redisplay current window
X	reset	Reset the window to its \*Qpower-on\*U settings
X	screen	Create a new window with the specified command
X	shell	Create a new window with a shell
X	suspend	Suspend \fIscreen\fP
X	termcap	Write screen's termcap entry to $HOME/.screencap
X	vbell	Toggle the window's \*Qvbell\*U setting.
X  	version	Display the version numbers and date last modified
X	width	Toggle the terminal width between 80 and 132 columns
X	windows	Display a list of all windows
X	wrap	Toggle the current window's line-wrap setting
X	writebuffer	Store the selected text in the exchange file.
X	xoff	Send a control-s to the current program
X	xon	Send a control-q to the current program
.fi
.PP
Some examples:
.PP
.nf
X	bind ' ' windows
X	bind ^f screen telnet foobar
X	bind \e033 screen -ln -t root -h 1000 9 su
.fi
.PP
would bind the space key to the function that displays a list
of windows (so that the function usually invoked by \*QC-a C-w\*U
would also be available as \*QC-a space\*U),
bind \*QC-f\*U to the function \*Qcreate a window with a TELNET
connection to foobar\*U, and bind \*Qescape\*U to the function
that creates an non-login window with a.\|k.\|a. \*Qroot\*U in slot #9, with
a super-user shell and a scrollbackbuffer of 1000 lines.
.PP
.ne 3
.B "bufferfile \fIexchange-file\fP"
.sp
Change the filename used for reading and writing with the copybuffer.
The default is \*Q/tmp/screen-exchange\*U. The following example
will paste the system's password file into the screen window:
.PP
.nf
X	C-a : bufferfile /etc/passwd
X	C-a < C-a ]
.fi
.PP
.ne 3
.B "chdir \fP[\fIdirectory\fP]"
.sp
Change the \fIcurrent directory\fP of
.I screen
to the specified directory or, if called without an argument,
to your home directory (the value of the environment variable $HOME).
All windows that are created by means of the \*Qscreen\*U command
from within \*Q.screenrc\*U or by means of \*QC-a : screen ...\*U
or \*QC-a c\*U use this as their default directory.
Without a chdir command, this would be the directory from which
.I screen
was invoked.
Hardcopy and log files are always written to the \fIwindow's\fP default
directory, \fInot\fP the current directory of the process running in the
window.
You can use this command multiple times in your .screenrc to start various
windows in different default directories, but the last chdir value will
affect all the windows you create interactively.
.PP
.ne 3
.B "crlf on\fP|\fBoff"
.sp
This affects the copying of text regions with the `C-a [' command. If it is set
to `on', lines will be separated by the two character sequence `CR' - `LF'. 
Otherwise only `LF' is used.
.PP
.ne 3
.B "echo \fP[\fB-n\fP]\fB \fImessage\fP"
.sp
The echo command may be used to annoy 
.I screen
users with a 'message of the
day'. Typically installed in a global /usr/local/etc/screenrc. See also
\*Qsleep\*U.
Echo is also useful for online checking of environment variables.
.PP
.ne 3
.B "escape \fIxy\fP"
.sp
Set the command character to \fIx\fP and the character generating a literal
command character to \fIy\fP (just like in the \-e option).
Each argument is either a single character, a two-character sequence
of the form \*Q^x\*U (meaning \*QC-x\*U), a backslash followed by an octal
number (specifying the ASCII code of the character), or a backslash followed
by a second character, such as \*Q\e^\*U or \*Q\e\e\*U.
The default is \*Q^Aa\*U, but \*Q``\*U is recommended by one of the authors.
.PP
.ne 3
.B "flow on\fP|\fBoff\fP|\fBauto \fP[\fBinterrupt\fP]\fB"
.sp
Sets the default flow-control mode for new windows.
Specifying \*Qflow auto interrupt\*U is the same as the command-line options
.B \-fa
and
.BR \-i . 
See the discussion on FLOW-CONTROL later on in this document for full details
and note, that this is subject to change in future releases.
.PP
.ne 3
.B "hardcopy_append on\fP|\fBoff"
.sp
If set to "on", 
.I screen
will append to the "hardcopy.n" files created by the command \*QC-a h\*U, 
otherwise these files are overwritten each time.
.PP
.ne 3
.B "hardstatus on\fP|\fBoff"
.sp
Toggles the use of the terminals hardware status line. If "on", 
.I screen
will use this facility to display one line messages. Otherwise these messages
are overlayed in reverse video mode at the display line. Note that the 
hardstatus feature should only be used, if the termcap/terminfo capabilities
"hs", "ts", "fs" and "ds" are set properly.
.PP
.ne 3
.B "login on\fP|\fBoff"
.sp
Sets the login flag which determines if new windows should have /etc/utmp
entries added for them.
The login state is also changeable on-the-fly by using the bindable version
of the \*Qlogin\*U command (C-a L) of by means of "C-a : set login on|off".
The default should be \*Qon\*U for a 
.I screen
that runs under suid-root.
.PP
.ne 3
.B "markkeys \fIstring\fP"
.sp
This is a method of changing the keymap used for copy/history mode.
The string is made up of \fIoldchar\fP=\fInewchar\fP pairs which are
separated by `:'. Example: The string \*QB=^B:F=^F\*U will change the 
keys `C-b' and `C-f' from their (original emacs-style bindings) to the vi style
binding (scroll up/down full page), which is the default meaning of `B' and
`F'.
.PP
.ne 3
.B "mode \fImode\fP"
.sp
The mode of each newly allocated pseudo-tty is set to \fImode\fP.
\fIMode\fP is an octal number.
When no \*Qmode\*U command is given, mode 0622 is used.
.PP
.ne 3
.B "nethack on\fP|\fBoff"
.sp
Changes the kind of error messages used by
.IR screen .
When you are familiar with the game \*Qnethack\*U, you may enjoy the
nethack-style messages which will often blur the facts a little, but are
much funnier to read. Anyway, standard messages often tend to be unclear as
well.
.br
This option is only 
available, if screen was compiled with the NETHACK flag defined. The
default setting is then determined by the presence of the environment 
variable $NETHACKOPTIONS.
.PP
.ne 3
.B "msgminwait \fIsec\fP"
.sp
Defines the time 
.I screen 
delays all activity after a message was dispayled. The default is 1 second.
.PP
.ne 3
.B "msgwait \fIsec\fP"
.sp
Defines the time a message is displayed, if 
.I screen
is not disturbed by other activity. The default is 5 seconds.
.PP
.ne 3
.B "password \fP[\fIcrypted_pw\fP]"
.sp
Present a crypted password in your \*Q.screenrc\*U file and screen will ask
for it, whenever a detached session is tried to be resumed. This is useful,
if you have privileged programs running under
.I screen
and you want to protect your session from reattach attempts by users that 
managed to have your uid. (I.e. any superuser.)
.PP
.ne 3
.B "pow_detach_msg \fImessage\fP"
.sp
The \fImessage\fP specified here is output whenever a `Power detach' was
performed. It may be used as a replacement for a logout message or to reset 
baud rate, etc.
.PP
.ne 3
.B "screen \fP[\fI-opts\fP] [\fIn\fP] [\fIcmd\fP [\fIargs\fP]]"
.sp
Establish a new window.
The flow-control options (\fB\-f\fP, \fB\-fn\fP and \fB\-fa\fP),
title (a.\|k.\|a.) option (\fB\-t\fP), login options (\fB-l\fP and \fB-ln\fP)
, terminal type option (\fB-T <term>\fP) and scrollback option (\fB-h\fP <num>)
may be specified for each command.
If an optional number \fIn\fP in the range 0..9 is given, the window
number \fIn\fP is assigned to the newly created window (or, if this
number is already in-use, the next available number).
If a command is specified after \*Qscreen\*U, this command (with the given
arguments) is started in the window; otherwise, a shell is created.
Thus, if your \*Q.screenrc\*U contains the lines
.sp
.nf
X	# example for .screenrc:
X	screen 1
X	screen -fn -t foobar 2 telnet foobar
.fi
.sp
.I screen
creates a shell window (in window #1), a window with a TELNET connection
to the machine foobar (with no flow-control using the a.\|k.\|a. \*Qfoobar\*U
in window #2), and finally, a second shell window
(the default window) which gets a window number of zero.
When the initialization is completed,
.I screen
switches to the last window specified in your .screenrc file or, if none, it
opens a default window #0 that would be displayed in this
case.
.PP
.ne 3
.B "scrollback \fP\fInum\fP"
.sp
Set the size of the scrollback buffer for new windows to \fInum\fP lines.
The default scrollback is 50 lines.
Use "C-a : set scrollback \fInum\fP" to change the scrollback size of the
current window and use "C-a i" to view the current setting. 
.PP
.ne 3
.B "redraw on\fP|\fBoff"
.sp
Define whether the display should be refreshed (as done with "C-a l") after
switching to the current window. As usual when the "set" keyword is given,
this command only affects the current window. But unlike other commands,
"redraw off" (without "set") affects all windows, the window specific settings
come into effect again when "redraw on" (without "set") is entered.
.PP
.ne 3
.B "shell \fIcommand\fP"
.sp
Set the command to be used to create a new shell.
This overrides the value of the environment variable $SHELL, or \*Q/bin/sh\*U
if undefined.
This is useful if you'd like to run a tty-enhancer which is expecting to
execute the program specified in $SHELL.
.PP
.ne 3
.B "shellaka \fIa.\|k.\|a.\fP"
.sp
Set the a.\|k.\|a. for all shells created during startup or by
the C-A C-c command.
For details about what a.\|k.\|a.\|'s are, see the discussion
entitled ALSO KNOWN AS.
.PP
.ne
.B "sleep \fP\fInum\fP"
This command will pause the execution of a .screenrc file for \fInum\fP seconds.
It may be used to give users a chance to read the messages output by \*Qecho\*U.
.PP
.ne 3
.B "slowpaste \fIusec\fP"
.sp
Define the speed text is inserted by the paste ("C-a ]") command. For each
80 characters (IOSIZE) pasted 
.I screen
will make a pause of \fIusec\fP milliseconds to allow the application the
processing of input. Use that, if you have to fear that your underlying system
chokes on large pastes.
.PP
.ne 3
.B "term \fIterm\fP"
.sp
In each window's environment
.I screen
opens, it sets the $TERM variable to \*Qscreen\*U by default. 
But when no description for \*Qscreen\*U is installed in the local termcap
or terminfo data base, you can pretend that the terminal emulator is - say -
\*Qvt100\*U. This won't do much harm, as 
.I screen
is VT100/ANSI compatible.
The use of the \*Qterm\*U command is discouraged for non-default purpose.
That is, one may want to specify special $TERM settings (e.g. vt100) for the
next \*Qscreen rlogin othermachine\*U command. Use the command \*Qscreen -T vt100
rlogin othermachine\*U rather than setting (\*Qterm vt100\*U) and resetting
(\*Qterm screen\*U) the default before and after the \*Qscreen\*U command.
.PP
.ne 3
.B "termcap \fIterm\fP \fIterminal-tweaks\fP \fP[\fIwindow-tweaks\fP]"
.br
.B "terminfo \fIterm\fP \fIterminal-tweaks\fP \fP[\fIwindow-tweaks\fP]"
.sp
Use this command to modify your terminal's termcap entry without going through
all the hassles involved in creating a custom termcap entry.
Plus, you can optionally customize the termcap generated for the windows.
If your system works with terminfo-database rather than with
termcap
.I screen
will understand the `terminfo' command which has the same effects as
the `termcap' command. Thus users can write one .screenrc file that handles
both cases, although terminfo syntax is slightly different
from termcap syntax.
.PP
The first argument specifies which terminal(s) should be affected by this
definition.
You can specify multiple terminal names by separating them with `|'s.
Use `*' to match all terminals and `vt*' to match all terminals that begin
with \*Qvt\*U.
.PP
Each \fItweak\fP argument contains one or more termcap defines (separated
by `:'s) to be inserted at the start of the appropriate termcap entry,
enhancing it or overriding existing values.
The first tweak modifies your terminal's termcap, and contains definitions
that your terminal uses to perform certain functions.
Specify a null string to leave this unchanged (e.\|g. '').
The second (optional) tweak modifies all the window termcaps, and should
contain definitions that screen understands (see the \*QVIRTUAL TERMINAL\*U
section).
.PP
Some examples:
.IP
termcap xterm*  LP:hs@
.PP
Informs
.I screen
that all terminals that begin with `xterm' have firm auto-margins that
allow the last position on the screen to be updated (LP), but they don't
really have a status line (no 'hs' -- append `@' to turn entries off).
Note that we assume `LP' for all terminal names that start with \*Qvt\*U,
but only if you don't specify a termcap command for that terminal.
.sp
.nf
X	termcap vt*  LP
X	termcap vt102|vt220  Z0=\eE[?3h:Z1=\eE[?3l
.fi
.sp
Specifies the firm-margined `LP' capability for all terminals that begin with
`vt', and the second line will also add the escape-sequences to switch
into (Z0) and back out of (Z1) 132-character-per-line mode if this is
a vt102 or vt220.
(You must specify Z0 and Z1 in your termcap to use the width-changing
commands.)
.IP
termcap vt100  ""  l0=PF1:l1=PF2:l2=PF3:l3=PF4
.PP
This leaves your vt100 termcap alone and adds the function key labels to
each window's termcap entry.
.IP
termcap h19|z19  am@:im=\eE@:ei=\eEO  dc=\eE[P
.PP
Takes a h19 or z19 termcap and turns off auto-margins (am@) and enables the
insert mode (im) and end-insert (ei) capabilities (the `@' in the `im'
string is after the `=', so it is part of the string).
Having the `im' and `ei' definitions put into your terminal's termcap will
cause screen to automatically advertise the character-insert capability in
each window's termcap.
Each window will also get the delete-character capability (dc) added to its
termcap, which screen will translate into a line-update for the terminal
(we're pretending it doesn't support character deletion).
.PP
If you would like to fully specify each window's termcap entry, you should
instead set the $SCREENCAP variable prior to running
.IR screen .
See the discussion on the \*QVIRTUAL TERMINAL\*U in this manual, and the termcap(5)
man page for more information on termcap definitions.
.PP
.ne 3
.B "vbell on\fP|\fBoff"
.sp
Sets the visual bell setting for new windows. If your terminal does not support
a visual bell a message is printed to the status line. The default 
message is \*QWuff, Wuff!!\*U.
.PP
.ne 3
.B "vbell_msg \fImessage\fP"
.sp
Sets the visual bell message. \fImessage\fP is printed to the status line if
the window receives a bell character (^G) and vbell is set to \*Qon\*U.
.PP
.ne 3
.B "vbellwait \fIsec\fP"
.sp
Define a delay in seconds after each display of 
.I screen 's
visual bell message. The default is 0 seconds.
.PP
.ne 3
.B "wrap on\fP|\fBoff"
.sp
Sets the line-wrap setting for new windows.
When line-wrap is on, the second consecutive printable character output at
the last column of a line will wrap to the start of the following line.
As an added feature, backspace (^H) will also wrap through the left margin
to the previous line.
Line-wrap is on by default and can be toggled with the \*Qwrap\*U
command (\*QC-a r\*U) or by means of "C-a : set wrap on|off".
.SH "THE MESSAGE LINE"
.I Screen
displays informational messages and other diagnostics in a \fImessage line\fP
at the bottom of the screen.
If your terminal has a status line defined in its termcap, screen will use
this for displaying its messages, otherwise the last line of the screen will
be temporarily overwritten and output will be momentarily interrupted.
The message line is automatically removed after a few seconds delay, but it
can also be removed early (on terminals without a status line) by beginning
to type.
.PP
The message line facility can be used by an application running in
the current window by means of the ANSI \fIPrivacy message\fP
control sequence.
For instance, from within the shell, try something like:
.IP
echo '<esc>^Hello world<esc>\e\e'
.PP
where '<esc>' is an \fIescape\fP, '^' is a literal up-arrow,
and '\e\e' turns into a single backslash.
.SH "FLOW-CONTROL"
Each window has a flow-control setting that determines how screen deals with
the XON and XOFF characters (and perhaps the interrupt character).
When flow-control is turned off, screen ignores the XON and XOFF characters,
which allows the user to send them to the current program by simply typing
them (useful for the \fIemacs\fP editor, for instance).
The trade-off is that it will take longer for output from a \*Qnormal\*U
program to pause in response to an XOFF.
With flow-control turned on, XON and XOFF characters are used to immediately
pause the output of the current window.
You can still send these characters to the current program, but you must use
the appropriate two-character screen commands (typically \*QC-a q\*U (xon)
and \*QC-a s\*U (xoff)).
The xon/xoff commands are also useful for typing C-s and C-q past a terminal
that intercepts these characters.
.PP
Each window has an initial flow-control value set with either the
.B \-f
option or the \*Qflow\*U .screenrc command. Per default the windows
are set to automatic flow-switching.
It can then be toggled between the three states 'fixed on', 'fixed off' and
'automatic' interactively with the \*Qflow\*U command bound to "C-a f".
.PP
The automatic flow-switching mode deals with
flow control using the TIOCPKT mode (like \*Qrlogin\*U does). If
the tty driver does not support TIOCPKT, screen tries to find out
the right mode based on the current setting of the application
keypad -- when it is enabled, flow-control is turned off and visa versa.
Of course, you can still manipulate flow-control manually when needed.
.PP
If you're running with flow-control enabled and find that pressing the
interrupt key (usually C-c) does not interrupt the display until another
6-8 lines have scrolled by, try running screen with the \*Qinterrupt\*U
option (add the \*Qinterrupt\*U flag to the \*Qflow\*U command in
your .screenrc, or use the
.B \-i
command-line option).
This causes the output that
.I screen
has accumulated from the interrupted program to be flushed.
One disadvantage is that the virtual terminal's memory contains the
non-flushed version of the output, which in rare cases can cause
minor inaccuracies in the output.
For example, if you switch screens and return, or update the screen
with \*QC-a l\*U you would see the version of the output you would
have gotten without \*Qinterrupt\*U being on.
Also, you might need to turn off flow-control (or use auto-flow mode to turn
it off automatically) when running a program that expects you to type the
interrupt character as input, as it is possible to interrupt
the output of the virtual terminal to your physical terminal when flow-control
is enabled.
If this happens, a simple refresh of the screen with \*QC-a l\*U will
restore it.
Give each mode a try, and use whichever mode you find more comfortable.
.SH "ALSO KNOWN AS (A.\|K.\|A.\|s)"
You can customize each window's name in the window display (viewed with the
\*Qwindows\*U command (C-a w)) by setting it with one of
the a.\|k.\|a. commands.
Normally the name displayed is the actual command name of the program
created in the window.
However, it is sometimes useful to distinguish various programs of the same
name or to change the name on-the-fly to reflect the current state of
the window.
.PP
The default name for all shell windows can be set with the \*Qshellaka\*U
command in the .screenrc file, while all other windows are created with
a \*Qscreen\*U command and thus can have their name set with the
.B \-t
option.
Interactively, there is the AKA-string escape-sequence
(<esc>k\fIname\fP<esc>\e) and the \*Qaka\*U command (C-a A).
The former can be output from an application to control the window's name
under software control, and the latter will prompt for a name when typed.
You can also bind pre-defined names to keys with the \*Qaka\*U command
to set things quickly without prompting.
.PP
Finally,
.I screen
has a shell-specific heuristic that is enabled by setting the window's name
to \*Q\fIsearch|name\fP\*U and arranging to have a null aka escape-sequence
output as a part of your prompt.
The \fIsearch\fP portion specifies an end-of-prompt search string, while
the \fIname\fP portion specifies the default shell name for the window.
If the \fIname\fP ends in a `:'
.I screen
will add what it believes to be the current command running in the window
to the end of the window's shell name (e.\|g. \*Q\fIname:cmd\fP\*U).
Otherwise the current command name supersedes the shell name while it is
running.
.PP
Here's how it works:  you must modify your shell prompt to output a null
aka escape-sequence (<esc>k<esc>\e) as a part of your prompt.
The last part of your prompt must be the same as the string you specified
for the \fIsearch\fP portion of the a.\|k.\|a.
Once this is set up,
.I screen
will use the aka escape-sequence to clear the previous command name and
get ready for the next command.
Then, when a newline is received from the shell, a search is made for the
end of the prompt.
If found, it will grab the first word after the matched string and use it
as the command name.
If the command name begins with either '!', '%', or '^'
.I screen
will use the first word on the following line (if found) in preference to
the just-found name.
This helps csh users get better command names when using job control or
history recall commands.
.PP
Here's some .screenrc examples:
.IP
screen -t top 2 nice top
.PP
Adding this line to your .screenrc would start a niced version of the
\*Qtop\*U command in window 2 name \*Qtop\*U rather than \*Qnice\*U.
.sp
.nf
X	shellaka '> |csh'
X	screen 1
.fi
.sp
This file would start two shells (one specified, one default) using
the given shellaka.
The a.\|k.\|a. specified is an auto-aka that would expect the prompt and
the typed command to look something like the following:
.IP
/usr/joe/src/dir> trn
.PP
(it looks after the '> ' for the command name).
The window status would show the name \*Qtrn\*U while the command was
running, and revert to \*Qcsh\*U upon completion.
.IP
bind R screen -t '% |root:' su
.PP
Having this command in your .screenrc would bind the key
sequence \*QC-a R\*U to the \*Qsu\*U command and give it an
auto-aka name of \*Qroot:\*U.
For this auto-aka to work, the screen could look something
like this:
.sp
.nf
X	% !em
X	emacs file.c
.fi
.sp
Here the user typed the csh history command \*Q!em\*U which ran the
previously entered \*Qemacs\*U command.
The window status would show \*Qroot:emacs\*U during the execution
of the command, and revert to simply \*Qroot:\*U at its completion.
.PP
.nf
X	bind o aka
X	bind E aka ""
X	bind u aka (unknown)
.fi
.sp
The first binding doesn't have any arguments, so it would prompt you
for an a.\|k.\|a. when you type \*QC-a o\*U.
The second binding would clear an auto-aka's current setting (C-a E).
The third binding would set the current window's a.\|k.\|a. to \*Q(unknown)\*U
(C-a u).
.PP
One thing to keep in mind when adding a null aka escape-sequence to
your prompt is that some shells (like the csh) count all the non-control
characters as part of the prompt's length.
If these invisible characters aren't a multiple of 8 then backspacing over
a tab will result in an incorrect display.
One way to get around this is to use a prompt like this:
.IP
set prompt='^[[0000m^[k^[\e% '
.PP
The escape-sequence \*Q<esc>[0000m\*U not only normalizes the character
attributes, but all the zeros round the length of the invisible characters
up to 8.
Bash users will probably want to echo the escape sequence in the
PROMPT_COMMAND:
.IP
PROMPT_COMMAND='echo -n -e "\e033k\e033\e134"'
.PP
(I used \*Q\134\*U to output a `\e' because of a bug in v1.04).
.SH "THE VIRTUAL TERMINAL"
Usually
.I screen
tries to emulate as much of the VT100/ANSI standard
as possible. But if your terminal lacks certain capabilities
the emulation may not be complete. In these cases
.I screen
has to tell the applications that some of the features
are missing. This is no problem on machines using termcap,
because
.I screen
can use the $TERMCAP variable to
customize the standard screen termcap.
.br
But if you do a
rlogin on another machine or your machine supports only
terminfo this method fails. Because of this
.I screen
offers a way to deal with these cases. Here is how it works:
.br
When 
.I screen
tries to figure out a terminal name for itself,
it first looks
for an entry named \*Qscreen.<term>\*U, where <term> is
the contents of your $TERM variable.
If no such entry exists,
.I screen
tries \*Qscreen\*U (or \*Qscreen-w\*U, if the terminal is wide
(132 cols or more)).
If even this entry cannot be found, \*Qvt100\*U is used as a
substitute.
.br
The idea is that if you have a terminal which doesn't
support an important feature (e.g. delete char or clear to EOS)
you can build a new termcap/terminfo entry for
.I screen
(named \*Qscreen.<dumbterm>\*U) in which this capability
has been disabled.  If this entry is installed on your
machines you are able to do
a rlogin and still keep the correct termcap/terminfo entry.
The terminal name is put in the $TERM variable
of all new windows.
.I Screen
also sets the $TERMCAP variable reflecting the capabilities
of the virtual terminal emulated. Notice that, however, on machines
using the terminfo database this variable has no effect.
Furthermore, the variable $WINDOW is set to the window number
of each window.
.br
The actual set of capabilities supported by the virtual terminal
depends on the capabilities supported by the physical terminal.
If, for instance, the physical terminal does not support underscore mode,
.I screen
does not put the `us' and `ue' capabilities into the window's $TERMCAP
variable, accordingly.
However, a minimum number of capabilities must be supported by a
terminal in order to run
.IR screen ;
namely scrolling, clear screen, and direct cursor addressing
(in addition,
.I screen
does not run on hardcopy terminals or on terminals that over-strike).
.PP
Also, you can customize the $TERMCAP value used by
.I screen
by using the \*Qtermcap\*U .screenrc command, or
by defining the variable $SCREENCAP prior to startup.
When the latter defined, its value will be copied verbatim into each
window's $TERMCAP variable.
This can either be the full terminal definition, or a filename where the
terminal \*Qscreen\*U (and/or \*Qscreen-w\*U) is defined.
.PP
Note that 
.I screen
honors the \*Qterminfo\*U .screenrc command if the system uses the
terminfo database rather than termcap.
.PP
When the boolean `G0' capability is present in the termcap entry
for the terminal on which
.I screen
has been called, the terminal emulation of
.I screen
supports multiple character sets.
This allows an application to make use of, for instance,
the VT100 graphics character set or national character sets.
The following control functions from ISO 2022 are supported:
\fIlock shift G0\fP (\fISI\fP), \fIlock shift G1\fP (\fISO\fP),
\fIlock shift G2\fP, \fIlock shift G3\fP, \fIsingle shift G2\fP,
and \fIsingle shift G3\fP.
When a virtual terminal is created or reset, the ASCII character
set is designated as \fIG0\fP through \fIG3\fP.
When the `G0' capability is present, screen evaluates the capabilities
`S0', `E0', and `C0' if present. `S0' is the sequence the terminal uses
to enable and start the graphics character set rather than \fISI\fP. 
`E0' is the corresponding replacement for \fISO\fP. `C0' gives a character
by character translation string that is used during semi-graphics mode. This 
string is built like the `acsc' terminfo capability.
.PP
When the `po' and `pf' capabilities are present in the terminal's
termcap entry, applications running in a
.I screen
window can send output to the printer port of the terminal.
This allows a user to have an application in one window
sending output to a printer connected to the terminal, while all
other windows are still active (the printer port is enabled
and disabled again for each chunk of output).
As a side-effect, programs running in different windows can
send output to the printer simultaneously.
Data sent to the printer is not displayed in the window.
.PP
Some capabilities are only put into the $TERMCAP
variable of the virtual terminal if they can be efficiently
implemented by the physical terminal.
For instance, `dl' (delete line) is only put into the $TERMCAP
variable if the terminal supports either delete line itself or
scrolling regions. Note that this may provoke confusion, when 
the session is reattached on a different terminal, as the value
of $TERMCAP cannot be modified by parent processes.
.PP
The following is a list of control sequences recognized by
.IR screen .
\*Q(V)\*U and \*Q(A)\*U indicate VT100-specific and ANSI- or
ISO-specific functions, respectively.
.PP
.nf
.TP 20
.B "ESC E"
X	Next Line
.TP 20
.B "ESC D"
X	Index
.TP 20
.B "ESC M"
X	Reverse Index
.TP 20
.B "ESC H"
X	Horizontal Tab Set
.TP 20
.B "ESC 7"
(V)	Save Cursor and Attributes
.TP 20
.B "ESC 8"
(V)	Restore Cursor and Attributes
.TP 20
.B "ESC [s"
(A)	Save Cursor and Attributes
.TP 20
.B "ESC [u"
(A)	Restore Cursor and Attributes
.TP 20
.B "ESC c"
X	Reset to Initial State
.TP 20
.B "ESC ="
(V)	Application Keypad Mode
.TP 20
.B "ESC >"
(V)	Numeric Keypad Mode
.TP 20
.B "ESC # 8"
(V)	Fill Screen with E's
.TP 20
.B "ESC \e"
(A)	String Terminator
.TP 20
.B "ESC ^"
(A)	Privacy Message String (Message Line)
.TP 20
.B "ESC k"
X	A.\|k.\|a. Definition String
.TP 20
.B "ESC P"
(A)	Device Control String
X	Outputs a string directly to the host
X	terminal without interpretation.
.TP 20
.B "ESC _"
(A)	Application Program Command (not used)
.TP 20
.B "ESC ]"
(A)	Operating System Command (not used)
.TP 20
.B "Control-N"
(A)	Lock Shift G1 (SO)
.TP 20
.B "Control-O"
(A)	Lock Shift G0 (SI)
.TP 20
.B "ESC n"
(A)	Lock Shift G2
.TP 20
.B "ESC o"
(A)	Lock Shift G3
.TP 20
.B "ESC N"
(A)	Single Shift G2
.TP 20
.B "ESC O"
(A)	Single Shift G3
.TP 20
.B "ESC ( \fPPcs"
(A)	Designate character set as G0
.TP 20
.B "ESC ) \fPPcs"
(A)	Designate character set as G1
.TP 20
.B "ESC * \fPPcs"
(A)	Designate character set as G2
.TP 20
.B "ESC + \fPPcs"
(A)	Designate character set as G3
.TP 20
.B "ESC [ \fPPn\fB ; \fPPn\fB H"
X	Direct Cursor Addressing
.TP 20
.B "ESC [ \fPPn\fB ; \fPPn\fB f"
X	Direct Cursor Addressing
.TP 20
.B "ESC [ \fPPn\fB J"
X	Erase in Display
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
X	From Cursor to End of Screen
.TP 20
\h'\w'ESC Pn = 'u'\fB1\fP
X	From Beginning of Screen to Cursor
.TP 20
\h'\w'ESC Pn = 'u'\fB2\fP
X	Entire Screen
.TP 20
.B "ESC [ \fPPn\fB K"
X	Erase in Line
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
X	From Cursor to End of Line
.TP 20
\h'\w'ESC Pn = 'u'\fB1\fP
X	From Beginning of Line to Cursor
.TP 20
\h'\w'ESC Pn = 'u'\fB2\fP
X	Entire Line
.TP 20
.B "ESC [ \fPPn\fB A"
X	Cursor Up
.TP 20
.B "ESC [ \fPPn\fB B"
X	Cursor Down
.TP 20
.B "ESC [ \fPPn\fB C"
X	Cursor Right
.TP 20
.B "ESC [ \fPPn\fB D"
X	Cursor Left
.TP 20
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB m"
X	Select Graphic Rendition
.TP 20
\h'\w'ESC 'u'Ps = None or \fB0\fP
X	Default Rendition
.TP 20
\h'\w'ESC Ps = 'u'\fB1\fP
X	Bold
.TP 20
\h'\w'ESC Ps = 'u'\fB2\fP
(A)	Faint
.TP 20
\h'\w'ESC Ps = 'u'\fB3\fP
(A)	\fIStandout\fP Mode (ANSI: Italicized)
.TP 20
\h'\w'ESC Ps = 'u'\fB4\fP
X	Underlined
.TP 20
\h'\w'ESC Ps = 'u'\fB5\fP
X	Blinking
.TP 20
\h'\w'ESC Ps = 'u'\fB7\fP
X	Negative Image
.TP 20
\h'\w'ESC Ps = 'u'\fB22\fP
(A)	Normal Intensity
.TP 20
\h'\w'ESC Ps = 'u'\fB23\fP
(A)	\fIStandout\fP Mode off (ANSI: Italicized off)
.TP 20
\h'\w'ESC Ps = 'u'\fB24\fP
(A)	Not Underlined
.TP 20
\h'\w'ESC Ps = 'u'\fB25\fP
(A)	Not Blinking
.TP 20
\h'\w'ESC Ps = 'u'\fB27\fP
(A)	Positive Image
.TP 20
.B "ESC [ \fPPn\fB g"
X	Tab Clear
.TP 20
\h'\w'ESC 'u'Pn = None or \fB0\fP
X	Clear Tab at Current Position
.TP 20
\h'\w'ESC Ps = 'u'\fB3\fP
X	Clear All Tabs
.TP 20
.B "ESC [ \fPPn\fB ; \fPPn\fB r"
(V)	Set Scrolling Region
.TP 20
.B "ESC [ \fPPn\fB I"
(A)	Horizontal Tab
.TP 20
.B "ESC [ \fPPn\fB Z"
(A)	Backward Tab
.TP 20
.B "ESC [ \fPPn\fB L"
(A)	Insert Line
.TP 20
.B "ESC [ \fPPn\fB M"
(A)	Delete Line
.TP 20
.B "ESC [ \fPPn\fB @"
(A)	Insert Character
.TP 20
.B "ESC [ \fPPn\fB P"
(A)	Delete Character
.TP 20
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB h"
X	Set Mode
.TP 20
.B "ESC [ \fPPs\fB ;\fP...\fB; \fPPs\fB l"
X	Reset Mode
.TP 20
\h'\w'ESC 'u'Ps = \fB4\fP
(A)	Insert Mode
.TP 20
\h'\w'ESC Ps = 'u'\fB?3\fP
(V)	Change Terminal Width
.TP 20
\h'\w'ESC Ps = 'u'\fB?5\fP
(V)	Visible Bell (\fIOn\fP followed by \fIOff\fP)
.TP 20
\h'\w'ESC Ps = 'u'\fB?6\fP
(V)	\fIOrigin\fP Mode
.TP 20
\h'\w'ESC Ps = 'u'\fB?7\fP
(V)	\fIWrap\fP Mode
.TP 20
.B "ESC [ 5 i"
(A)	Start relay to printer (ANSI Media Copy)
.TP 20
.B "ESC [ 4 i"
(A)	Stop relay to printer (ANSI Media Copy)
.fi
.SH FILES
.nf
.ta 2i
$SYSSCREENRC
.br
/local/etc/screenrc		  \fIscreen\fP initialization commands
.br
$ISCREENRC
.br
$SCREENRC
.br
$HOME/.iscreenrc
.br
$HOME/.screenrc	  Read in after /usr/local/etc/screenrc
.br
$ISCREENDIR/S-<login>
.br
$SCREENDIR/S-<login>
.br
/local/screens/S-<login>		  Socket directories (default)
.br
/usr/tmp/screens/S-<login>		  Alternate socket directories.
.br
<socket directory>/.termcap		  Written by the "termcap" output function
.br
/usr/tmp/screens/screen-exchange		  or
.br
/tmp/screen-exchange		  \fIscreen\fP `interprocess communication buffer'
.br
hardcopy.[0-9]	  Screen images created by the hardcopy function
.br
screenlog.[0-9]	  Output log files created by the log function
.br
/usr/lib/terminfo/?/*		   or
.br
/etc/termcap	  Terminal capability databases
.br
/etc/utmp	  Login records
.br
$LOCKPRG	  Program that locks a terminal.
.fi
.SH "SEE ALSO"
termcap(5), utmp(5), vi(1), captoinfo(1), tic(1)
.SH AUTHORS
Originally created by Oliver Laumann, this latest version was
produced by Wayne Davison, Juergen Weigert and Michael Schroeder.
.SH CONTRIBUTORS
Allan Ball,
Bart Schaefer,
Doug Siebert,
Howard Chu,
Jay Vassos-Libove,  
John Kraft,
Larry Virden,
Marc Boucher,
Nathan Glasser,
Patrick Wolfe,
Rudolf Koenig.
Toerless Eckert, 
.SH VERSION
This is version 3.2. It's roots are a merge of a custom version
2.3PR7 by Wayne Davison
and several enhancements to Oliver Laumann's version 2.0. Note that all versions
numbered 2.x are copyright by Oliver Laumann. 
X
.SH BUGS
`dm' (delete mode), `xn', and `xs' are not handled
correctly (they are ignored).
.PP
The \fIGR\fP set of ISO 2022 is not supported.
.PP
There is no keyboard input translation to VT100 sequences.
.PP
It is not possible to change the environment variable $TERMCAP when 
reattaching under a different terminal type.
.PP
The support of terminfo based systems is very limited. Adding extra
capabilities to $TERMCAP may not have any effects.
.PP
.I Screen
does not make use of hardware tabs.
.PP
.I Screen
must be installed as set-uid with owner root in order to be able
to correctly change the owner of the tty device file for each
window.
Special permission may also be required to write the file \*Q/etc/utmp\*U.
.PP
Entries in \*Q/etc/utmp\*U are not removed when
.I screen
is killed with SIGKILL.
This will cause some programs (like "w" or "rwho")
to advertise that a user is logged on who really isn't.
SHAR_EOF
echo 'File screen3.2/screen.1 is complete' &&
chmod 0444 screen3.2/screen.1 ||
echo 'restore of screen3.2/screen.1 failed'
Wc_c="`wc -c < 'screen3.2/screen.1'`"
test 63790 -eq "$Wc_c" ||
	echo 'screen3.2/screen.1: original size 63790, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= screen3.2/screen.c ==============
if test -f 'screen3.2/screen.c' -a X"$1" != X"-c"; then
	echo 'x - skipping screen3.2/screen.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting screen3.2/screen.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'screen3.2/screen.c' &&
/* Copyright (c) 1991
X *      Juergen Weigert (jnweiger@immd4.informatik.uni-erlangen.de)
X *      Michael Schroeder (mlschroe@immd4.informatik.uni-erlangen.de)
X * Copyright (c) 1987 Oliver Laumann
X *
X * This program is free software; you can redistribute it and/or modify
X * it under the terms of the GNU General Public License as published by
X * the Free Software Foundation; either version 1, or (at your option)
X * any later version.
X *
X * This program is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X * GNU General Public License for more details.
X *
X * You should have received a copy of the GNU General Public License
X * along with this program (see the file COPYING); if not, write to the
X * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * Noteworthy contributors to screen's design and implementation:
X *	Wayne Davison (davison@borland.com)
X *	Patrick Wolfe (pat@kai.com, kailand!pat)
X *	Bart Schaefer (schaefer@cse.ogi.edu)
X *	Nathan Glasser (nathan@brokaw.lcs.mit.edu)
X *	Larry W. Virden (lwv27%cas.BITNET@CUNYVM.CUNY.Edu)
X *	Howard Chu (hyc@hanauma.jpl.nasa.gov)
X *	Tim MacKenzie (tym@dibbler.cs.monash.edu.au)
X *	Markku Jarvinen (mta@{cc,cs,ee}.tut.fi)
X *	Marc Boucher (marc@CAM.ORG)
X *
X ****************************************************************
X */
X
#ifndef lint
X  static char rcs_id[] = "$Id: screen.c,v 1.2 92/02/03 02:28:05 jnweiger Exp $ FAU";
#endif
X
X
#include <sys/param.h>
/* #include <signal.h> */
#include <ctype.h>
#include <pwd.h>
#include <fcntl.h>
#ifdef sgi
# include <sys/sysmacros.h>
#endif /* sgi */
#if !defined(sun) && !defined(B43) && !defined(ISC)
# include <time.h>
#endif
/*
X * Gee!! We should reverse that #if! 
X */
#if defined(sun) || defined(_AIX) || defined(sysV68) || defined(MIPS) || defined(GOULD_NP1) || defined(B43) || defined(ISC) || defined(apollo) || defined(BSDI) || defined(sgi)
# include <sys/time.h>
#endif
#if defined(M_XENIX) || defined(M_UNIX)
#include <sys/select.h> /* for timeval */
#endif
#include <sys/types.h>
#ifdef ISC
# include <sys/bsdtypes.h>
#endif
#if !defined(sysV68) && !defined(M_XENIX)
# include <sys/wait.h>
#endif
#include <sys/stat.h>
#ifndef sgi
# include <sys/file.h>
#endif /* sgi */
#ifndef sun
# include <sys/ioctl.h>
#endif /* sun */
X
#include <signal.h>
X
#include "config.h"
X
#ifdef SHADOWPW
# include <shadow.h>
#endif /* SHADOWPW */
X
#ifdef SVR4
# include <sys/stropts.h>
#endif
X
#ifdef SYSV
# include <sys/utsname.h>
#endif
X
#if defined(_SEQUENT_) 
/* for the FD.. stuff */
# include <sys/select.h>
#endif 
X
#if defined(sequent) || defined(SVR4)
# include <sys/resource.h>
#endif /* sequent || SVR4 */
X
#ifdef ISC
# include <sys/tty.h>
# include <sys/sioctl.h>
# include <sys/pty.h>
#endif
X
#include "screen.h"
X
#include "patchlevel.h"
X
#if defined(xelos) || defined(sysV68) || defined(M_XENIX)
X struct passwd *getpwuid __P((uid_t));
X struct passwd *getpwnam __P((char *));
#endif
X
#ifdef USEVARARGS
# if defined(__STDC__)
#  include <stdarg.h>
# else
#  include <varargs.h>
# endif
#endif
X
#ifdef DEBUG
FILE *dfp;
#endif
X
X
#ifdef COPY_PASTE
extern char *copybuffer;	/* def in mark.c jw. */
extern copylen;
#endif /* COPY_PASTE */
X
extern char *blank, *null, Term[], screenterm[], **environ, *Termcap;
int force_vt = 1, assume_LP = 0;
extern int in_ovl;
extern int ovl_blockfore;
extern void (*ovl_process)();
extern int help_page;
extern int screenwidth, screenheight;
extern char display_tty[];
extern int default_width, default_height;
extern int Z0width, Z1width;
extern int ISO2022;
extern int status, HS;
extern char *Z0, *WS, *LastMsg;
extern time_t TimeDisplayed;
int BellDisplayed;
int VBellWait, MsgWait, MsgMinWait;
X
/* tputs uses that: jw */
extern short ospeed;
X
extern int flow, default_flow, wrap, visual_bell, default_monitor;
extern int errno;
extern sys_nerr;
extern char *sys_errlist[];
extern char mark_key_tab[];
X
#if defined(TIOCSWINSZ) || defined(TIOCGWINSZ)
extern struct winsize glwz;
#endif
X
static char *MakeWinMsg __P((char *, int));
static void MakeNewEnv __P((void));
static int Attach __P((int));
static void Attacher __P((void));
static void SigHandler __P((void));
static sig_t AttacherSigInt __P(SIGPROTOARG);
static sig_t SigChld __P(SIGPROTOARG);
static sig_t SigInt __P(SIGPROTOARG);
static sig_t CoreDump __P((int));
static void DoWait __P((void));
static sig_t Finit __P((int));
static void InitKeytab __P((void));
static void SetForeWindow __P((int));
static int NextWindow __P((void));
static int PreviousWindow __P((void));
static int MoreWindows __P((void));
static void FreeWindow __P((struct win *));
static void execvpe __P((char *, char **, char **));
static void LogToggle __P((void));
static void ShowWindows __P((void));
static void ShowTime __P((void));
static void ShowInfo __P((void));
static int OpenPTY __P((void));
#ifdef PASSWORD
static void trysend __P((int, struct msg *, char *));
#endif
#if defined(SIGWINCH) && defined(TIOCGWINSZ)
static sig_t SigAttWinch __P(SIGPROTOARG);
#endif
static void fgtty __P((void));
static void freetty __P((void));
static void brktty __P((void));
X
#if defined(LOCK)
static sig_t DoLock __P(SIGPROTOARG);
static void LockTerminal __P((void));
#endif
X
#ifdef COPY_PASTE
static pastelen;
static char *pastebuffer;
#endif
#ifdef PASSWORD
extern char Password[];
#endif
X
static struct passwd *ppp;
X
/* used for opening a new pty-pair: */
static char PtyName[32], TtyName[32];
X
/* used for the attacher's tty: */
static char *attach_tty;
X
char *ShellProg;
char *ShellArgs[2];
static char inbuf[MAXWIN][IOSIZE];
static inlen[MAXWIN];
static inbuf_ct;
static ESCseen;
static GotSignal;
X
static char DefaultShell[] = "/bin/sh";
static char DefaultPath[] = ":/usr/ucb:/bin:/usr/bin";
X
#ifdef hpux
char PtyProto[] = "/dev/ptym/ptyXY";
char TtyProto[] = "/dev/pty/ttyXY";
#else
# if !(defined(sequent) || defined(_SEQUENT_) || defined(SVR4))
static char PtyProto[] = "/dev/ptyXY";
static char TtyProto[] = "/dev/ttyXY";
# endif
#endif /* hpux */
int TtyMode = 0622;
#ifdef SOCKDIR
char *SockDir = SOCKDIR;
#else
char *SockDir = ".iscreen";
#endif
extern char SockPath[], *SockNamePtr, *SockName;
int ServerSocket = -1;
static char **NewEnv;
X
char *RcFileName = NULL;
char Esc = Ctrl('a');
char MetaEsc = 'a';
char *home;
X
int HasWindow;
char *LoginName;
char *BellString;
char *VisualBellString;
char *ActivityString;
char *BufferFile;
char *PowDetachString;
int auto_detach = 1;
int iflag, rflag, dflag, lsflag, quietflag, wipeflag;
int adaptflag, loginflag = -1, allflag;
static intrc, startc, stopc;
char HostName[MAXSTR];
int Detached, Suspended;
int DeadlyMsg = 1;
int AttacherPid;	/* Non-Zero in child if we have an attacher */
int MasterPid;
int real_uid, real_gid, eff_uid, eff_gid;
int default_histheight;
int default_startup;
int slowpaste;
X
#if defined(BSDJOBS) && !(defined(POSIX) || defined(SYSV))
int DevTty = -1;
#endif
X
#ifdef NETHACK
int nethackflag = 0;
#endif
X
struct mode OldMode, NewMode;
X
struct win *fore = NULL;
int WinList = -1;
int ForeNum;
struct win *wtab[MAXWIN];
X
struct key ktab[256];
X
#ifndef FD_SET
typedef struct fd_set
{
X  int fd_bits[1];
}      fd_set;
# define FD_ZERO(fd) ((fd)->fd_bits[0] = 0)
# define FD_SET(b, fd) ((fd)->fd_bits[0] |= 1 << (b))
# define FD_ISSET(b, fd) ((fd)->fd_bits[0] & 1 << (b))
# define FD_SETSIZE 32
#endif
X
X
#ifndef WTERMSIG
# ifndef BSDWAIT /* if wait is NOT a union: */
#  define WTERMSIG(status) (status & 0177)
# else
#  define WTERMSIG(status) status.w_T.w_Termsig 
# endif
#endif
X
#ifndef WIFCORESIG
# ifndef BSDWAIT /* if wait is NOT a union: */
#  define WIFCORESIG(status) (status & 0200)
# else
#  define WIFCORESIG(status) status.w_T.w_Coredump
# endif
#endif
X
#ifndef WEXITSTATUS
# ifndef BSDWAIT /* if wait is NOT a union: */
#  define WEXITSTATUS(status) ((status >> 8) & 0377)
# else
#  define WEXITSTATUS(status) status.w_T.w_Retcode
# endif
#endif
X
char *shellaka = NULL;
X
/*
X * Do this last
X */
#include "extern.h"
X
/*
X * XXX: Missing system header files.
X */
#ifdef USEVARARGS
# ifndef VPRNT_DECLARED
int vsprintf __P((char *, char *, va_list));
# endif /* VPRNT_DECLARED */
#endif
int select __P((int, fd_set *, fd_set *, fd_set *, struct timeval *));
X
static void
brktty()
{
#ifdef POSIX
X  setsid();		/* will break terminal affiliation */
# ifdef BSD
X  ioctl(0, TIOCSCTTY, 0);
# endif /* BSD */
#else
# ifdef SYSV
X  setpgrp();		/* will break terminal affiliation */
# else
#  ifdef BSDJOBS
X  if (DevTty)
X    if (ioctl(DevTty, TIOCNOTTY, (char *) 0) != 0)
X      debug2("brktty: ioctl(DevTty=%d, TIOCNOTTY, 0) = %d\n", DevTty, errno);
#  endif
# endif
#endif
}
X
static void
freetty()
{
X  brktty();
#if defined(BSDJOBS) && !(defined(POSIX) || defined(SYSV))
X  if (DevTty >= 0)
X    {
X      close(DevTty);
X      DevTty = -1;
X    }
#endif
X  close(0);
X  close(1);
X  close(2);
X  debug("did freetty\n");
}
X
static void
fgtty()
{
#ifdef BSDJOBS
X  int mypid;
X
X  mypid = getpid();
X
# ifdef BSDI
X  setsid();
X  ioctl(0, TIOCSCTTY, 0);
# endif /* BSDI */
X
# ifdef POSIX
X  if (tcsetpgrp(0, mypid))
X    {
X      debug1("fgtty: tcsetpgrp: %d\n", errno);
X      /* error is likely to have side-effects -- better to warn our user */
X      SendErrorMsg("fgtty: Could not set process group id in tty");
X    }
# else
X  if (ioctl(0, TIOCSPGRP, &mypid) != 0)
X    debug1("fgtty: TIOSETPGRP: %d\n", errno);
X  /* posix setsid() in brktty() from freetty() already made us leader */
X  if (setpgrp(0, mypid))
X    debug1("fgtty: setpgrp: %d\n", errno);
# endif /* POSIX */
#endif /* BSDJOBS */
}
X
#ifdef hpux
/*
X * hpux has berkeley signal semantics if we use sigvector,
X * but not, if we use signal, so we define our own signal() routine.
X * (jw)
X */
void (*signal(sig, func)) ()
int sig;
void (*func) ();
{
X  struct sigvec osv, sv;
X
X  sv.sv_handler = func;
X  sv.sv_mask = sigmask(sig);
X  sv.sv_flags = SV_BSDSIG;
X  if (sigvector(sig, &sv, &osv) < 0)
X    return (BADSIG);
X  return (osv.sv_handler);
}
#endif	/* hpux */
X
#ifndef USEBCOPY
void bcopy(s1, s2, len)
register char *s1, *s2;
register int len;
{
X  if (s1 < s2 && s2 < s1 + len)
X    {
X      s1 += len;
X      s2 += len;
X      while (len-- > 0)
X	*--s2 = *--s1;
X    }
X  else
X    while (len-- > 0)
X      *s2++ = *s1++;
}
#endif	/* USEBCOPY */
X
void bclear(p, n)
int n;
char *p;
{
X  bcopy(blank, p, n);
}
X
static void
closeallfiles()
{
X  int f;
#ifdef SVR4
X  struct rlimit rl;
X  
X  if ((getrlimit(RLIMIT_NOFILE, &rl) == 0) && rl.rlim_max != RLIM_INFINITY)
X    f = rl.rlim_max;
X  else
#endif /* SVR4 */
#if defined(SYSV) && !defined(ISC)
X  f = NOFILE;
#else /* SYSV && !ISC */
X  f = getdtablesize();
#endif /* SYSV && !ISC */
X  while (--f > 2)
X    close(f);
}
X  
static int InterruptPlease = 0;
X
void main(ac, av)
int ac;
char **av;
{
X  register int n, len;
X  register struct win *p;
X  char *ap, *aka = NULL;
X  char *av0;
X  char socknamebuf[2 * MAXSTR];
X  int s = 0;
X  fd_set r, w, e;
X  int mflag = 0;
X  struct timeval tv;
X  int nsel;
X  char buf[IOSIZE], *bufp, *myname = (ac == 0) ? "screen" : av[0];
X  struct stat st;
X  int buflen, tmp;
#ifdef _MODE_T			/* (jw) */
X  mode_t oumask;
#else
X  int oumask;
#endif
#ifdef SYSV
X  struct utsname utsnam;
#endif
X
X  /*
X   *  First, close all unused descriptors
X   *  (otherwise, we might have problems with the select() call)
X   */
X  closeallfiles();
#ifdef DEBUG
X  (void) mkdir("/tmp/debug", 0777);
X  if ((dfp = fopen("/tmp/debug/screen.front", "w")) == NULL)
X    dfp = stderr;
X  else
X    (void) chmod("/tmp/debug/screen.front", 0666);
#endif
X  debug1("-- screen debug started %s\n", *av);
#ifdef POSIX
X  debug("POSIX\n");
#endif
#ifdef TERMIO
X  debug("TERMIO\n");
#endif
#ifdef SYSV
X  debug("SYSV\n");
#endif
#ifdef NAMEDPIPE
X  debug("NAMEDPIPE\n");
#endif
#if defined(SIGWINCH) && defined(TIOCGWINSZ)
X  debug("Window changing enabled\n");
#endif
#ifdef NOREUID
X  debug("NOREUID\n");
#endif
#ifdef hpux
X  debug("hpux\n");
#endif
#ifdef USEBCOPY
X  debug("USEBCOPY\n");
#endif
#ifdef UTMPOK
X  debug("UTMPOK\n");
#endif
#ifdef LOADAV
X  debug("LOADAV\n");
#endif
#ifdef NETHACK
X  debug("NETHACK\n");
#endif
#ifdef TERMINFO
X  debug("TERMINFO\n");
#endif
#ifdef NAME_MAX
X  debug1("NAME_MAX = %d\n", NAME_MAX);
#endif
X
X  BellString = SaveStr("Bell in window %");
X  VisualBellString = SaveStr("   Wuff,  Wuff!!  ");
X  ActivityString = SaveStr("Activity in window %");
X  BufferFile = SaveStr("/tmp/screen-exchange");
X  PowDetachString = 0;
X  default_histheight = DEFAULTHISTHEIGHT;
X  default_startup = (ac > 1) ? 0 : 1;
X  adaptflag = 0;
X  slowpaste = 0;
X  VBellWait = VBELLWAIT;
X  MsgWait = MSGWAIT;
X  MsgMinWait = MSGMINWAIT;
X  CompileKeys((char *)NULL, mark_key_tab);
X
X  av0 = *av;
X  while (ac > 0)
X    {
X      ap = *++av;
X      if (--ac > 0 && *ap == '-')
X	{
X	  switch (ap[1])
X	    {
X	    case 'a':
X	      allflag = 1;
X	      break;
X	    case 'A':
X	      adaptflag = 1;
X	      break;
X	    case 'c':
X	      if (ap[2])
X		RcFileName = ap + 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  RcFileName = *++av;
X		}
X	      break;
X	    case 'e':
X	      if (ap[2])
X		ap += 2;
X	      else
X		{
X		  if (--ac == 0)
X		    exit_with_usage(myname);
X		  ap = *++av;
X		}
X	      if (!ParseEscape(ap))
X		Msg(0, "Two characters are required with -e option.");
X	      break;
X	    case 'f':
SHAR_EOF
true || echo 'restore of screen3.2/screen.c failed'
fi
echo 'End of  part 5'
echo 'File screen3.2/screen.c is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
