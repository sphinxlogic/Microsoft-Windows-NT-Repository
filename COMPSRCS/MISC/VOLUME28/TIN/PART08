Newsgroups: comp.sources.misc
From: iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE (Iain Lea)
Subject:  v28i052:  tin - threaded full screen newsreader v1.1, Part08/11
Message-ID: <1992Feb18.043839.13302@sparky.imd.sterling.com>
X-Md4-Signature: 05fb4670b12dfc17c86e0bbfe255ff33
Date: Tue, 18 Feb 1992 04:38:39 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE (Iain Lea)
Posting-number: Volume 28, Issue 52
Archive-name: tin/part08
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 23, Issue 15-23

#!/bin/sh
# this is tin.shar.08 (part 8 of tin1.1)
# do not concatenate these parts, unpack them in order with /bin/sh
# file post.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 8; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping post.c'
else
echo 'x - continuing file post.c'
sed 's/^X//' << 'SHAR_EOF' >> 'post.c' &&
X
X	start_line_offset = 4;
X	
X	strcpy (mail_to, address);
X	clear_message ();
X	
X	set_real_uid_gid ();
X
X	sprintf (nam, "%s/.letter", homedir);
X	if ((fp = fopen (nam, "w")) == NULL) {
X		error_message (txt_cannot_open, nam);
X		set_tin_uid_gid ();
X		return (redraw_screen);
X	}
X	chmod (nam, 0600);
X
X	fprintf (fp, "To: %s\n", mail_to);
X	fprintf (fp, "Subject: (fwd) %s\n", note_h_subj);
X	if (*note_h_followup) {
X		fprintf (fp, "Newsgroups: %s\n\n", note_h_followup);
X	} else {
X		fprintf (fp, "Newsgroups: %s\n", note_h_newsgroups);
X	}
X	if (*my_org) {
X		fprintf (fp, "Organization: %s\n", my_org);
X		start_line_offset++;
X	}
X	if (*reply_to) {
X		fprintf (fp, "Reply-To: %s\n", reply_to);
X		start_line_offset++;
X	}
X	fputs ("\n", fp);
X	
X	fseek (note_fp, 0L, 0);
X	copy_fp (note_fp, fp, (char *) 0);
X
X	add_signature (fp, TRUE);
X	fclose (fp);
X	
X	while (1) {
X		do {
X			my_strncpy (buf, note_h_subj, COLS-30);
X			sprintf (msg, "%s [%s]: %c", txt_abort_edit_send, buf, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (msg)-1);
X			if ((ch = (char) ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'a' && ch != 'e' && ch != 's');
X
X		switch (ch) {
X		case 'e':
X			invoke_editor (nam);
X			set_real_uid_gid ();
X			redraw_screen = TRUE;
X			break;
X
X		case 'a':
X		case ESC:
X			unlink (nam);
X			clear_message ();
X			set_tin_uid_gid ();
X			return (redraw_screen);
X
X		case 's':
X			/*
X			 *  Open letter and get the To: line in case they changed
X			 *  it with the editor
X			 */
X			find_mail_header (HEADER_TO, nam, mail_to);
X			sprintf (msg, txt_mailing_to, mail_to);
X			wait_message (msg);
X			sprintf (buf, "%s \"%s\" < %s", mailer, mail_to, nam);
X			if (invoke_cmd (buf)) {
X				info_message (txt_message_sent);
X				goto mail_to_someone_done;
X			} else {
X				error_message (txt_command_failed_s, buf);
X				break;
X			}
X		}
X	}
X
mail_to_someone_done:
X	set_real_uid_gid ();
X	unlink (nam);
X	set_tin_uid_gid ();
X
X	return (redraw_screen);
}
X
X
int mail_bug_report ()
{
X	char nam[100];
X	FILE *fp;
X	FILE *fp_uname;
X	char ch;
X	char ch_default = 's';
X	char buf[LEN];
X	char mail_to[LEN];
X
X	start_line_offset = 5;
X	
X	wait_message (txt_mail_bug_report);
X	
X	set_real_uid_gid ();
X
X	sprintf (nam, "%s/.bugreport", homedir);
X	if ((fp = fopen (nam, "w")) == NULL) {
X		error_message (txt_cannot_open, nam);
X		set_tin_uid_gid ();
X		return FALSE;
X	}
X	chmod(nam, 0600);
X
X	fprintf (fp, "To: %s\n", bug_addr);
X	fprintf (fp, "Subject: BUG REPORT %s %s PL%d %s\n",	progname,
X		VERSION, PATCHLEVEL, (compiled_with_nntp ? "(NNTP)" : ""));
X	if (*my_org) {
X		fprintf (fp, "Organization: %s\n", my_org);
X		start_line_offset++;
X	}
X	if (*reply_to) {
X		fprintf (fp, "Reply-To: %s\n", reply_to);
X		start_line_offset++;
X	}
X
X	if ((fp_uname = popen ("uname -a", "r")) != NULL) {
X		fprintf (fp, "\n");
X		start_line_offset++;
X		while (fgets (buf, sizeof (buf), fp_uname) != NULL) {
X			fprintf (fp, "%s", buf);
X			start_line_offset++;
X		}
X		fclose (fp_uname);
X	} else {
X		fprintf (fp, "\nPlease enter the following information:\n");
X		fprintf (fp, "1) machine:\n");
X		fprintf (fp, "2) os type:\n");
X	}
X	fprintf (fp, "\nPlease enter bug report/gripe/comment:\n");
X
X	add_signature (fp, TRUE);
X	fclose (fp);
X	
X	ch = 'e';
X	while (1) {
X		switch (ch) {
X		case 'e':
X			invoke_editor (nam);
X			set_real_uid_gid ();
X			break;
X
X		case 'a':
X		case ESC:
X			unlink (nam);
X			clear_message ();
X			set_tin_uid_gid ();
X			return TRUE;
X
X		case 's':
X			strcpy (mail_to, bug_addr);
X			find_mail_header (HEADER_TO, nam, mail_to);
X			sprintf (msg, txt_mailing_to, mail_to);
X			wait_message (msg);
X			sprintf (buf, "%s \"%s\" < %s", mailer, mail_to, nam);
X			if (invoke_cmd (buf)) {
X				info_message (txt_message_sent);
X				goto mail_bug_report_done;
X			} else {
X				error_message (txt_command_failed_s, buf);
X				break;
X			}
X		}
X
X		do {
X			sprintf (msg, "%s: %c", txt_abort_edit_send, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (msg)-1);
X			if ((ch = (char) ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'a' && ch != 'e' && ch != 's');
X	}
X
mail_bug_report_done:
X	set_real_uid_gid ();
X	unlink (nam);
X	set_tin_uid_gid ();
X
X	return TRUE;
}
X
X
int mail_to_author (respnum, copy_text)
X	int respnum;
X	int copy_text;
{
X	char buf[LEN];
X	char nam[100];
X	char mail_to[LEN];
X	char ch, ch_default = 's';
X	FILE *fp;
X	int redraw_screen = FALSE;
X
X	start_line_offset = 4;
X	
X	wait_message (txt_reply_to_author);
X
X	set_real_uid_gid ();
X
X	sprintf (nam, "%s/.letter", homedir);
X	if ((fp = fopen (nam, "w")) == NULL) {
X		error_message (txt_cannot_open, nam);
X		set_tin_uid_gid ();
X		return (redraw_screen);
X	}
X	chmod (nam, 0600);
X
X	fprintf (fp, "To: %s%s (%s)\n",
X		arts[respnum].from, add_addr, arts[respnum].name);
X	fprintf (fp, "Subject: Re: %s\n", eat_re(note_h_subj) );
X	fprintf (fp, "Newsgroups: %s\n", note_h_newsgroups);
X	if (*my_org) {
X		fprintf (fp, "Organization: %s\n", my_org);
X		start_line_offset++;
X	}
X	if (*reply_to) {
X		fprintf (fp, "Reply-To: %s\n", reply_to);
X		start_line_offset++;
X	}
X	fputs ("\n", fp);
X
X	if (copy_text) {		/* if "copy_text" */
X		fprintf (fp, txt_in_art_you_write, note_h_messageid);
X		fseek (note_fp, note_mark[0], 0);
X		copy_fp (note_fp, fp, DEFAULT_COMMENT);
X	}
X
X	add_signature (fp, TRUE);
X	fclose (fp);
X
X	ch = 'e';
X	while (1) {
X		switch (ch) {
X		case 'e':
X			invoke_editor (nam);
X			set_real_uid_gid ();
X			redraw_screen = TRUE;
X			break;
X
X		case 'a':
X		case ESC:
X			unlink (nam);
X			clear_message ();
X			set_tin_uid_gid ();
X			return (redraw_screen);
X
X		case 's':
X			strcpy (mail_to, arts[respnum].from);
X			find_mail_header (HEADER_TO, nam, mail_to);
X			sprintf (msg, txt_mailing_to, mail_to);
X			wait_message (msg);
X			sprintf (buf, "%s \"%s\" < %s", mailer, mail_to, nam);
X			if (invoke_cmd (buf)) {
X				info_message (txt_message_sent);
X				goto mail_to_author_done;
X			} else {
X				error_message (txt_command_failed_s, buf);
X				break;
X			}
X		}
X
X		do {
X			sprintf (msg, "%s: %c", txt_abort_edit_send, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (msg)-1);
X			if ((ch = (char) ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'a' && ch != 'e' && ch != 's');
X	}
X
mail_to_author_done:
X	set_real_uid_gid ();
X	unlink (nam);
X	set_tin_uid_gid ();
X
X	return (redraw_screen);
}
X
/*
X *  Read a file grabbing the value of the specified mail header line
X */
X
void find_mail_header (header, file, value)
X	int header;
X	char *file;
X	char *value;
{
X	FILE *fp;
X	char buf[LEN];
X	char buf2[LEN];
X	char new_value[LEN];
X	char *p;
X
X	*new_value = '\0';
X
X	if ((fp = fopen (file, "r")) == NULL) {
X		error_message (txt_cannot_open, file);
X		return;
X	}
X
X	while (fgets (buf, sizeof (buf), fp) != NULL) {
X		for (p = buf; *p && *p != '\n'; p++)
X			continue;
X		*p = '\0';
X
X		if (*buf == '\0')
X			break;
X
X		switch (header) {
X			case HEADER_TO:
X				if (strncmp (buf, "To: ", 4) == 0) {
X					my_strncpy (buf2, &buf[4], LEN);
X					buf2[LEN-1] = '\0';
X					yank_to_addr (buf2, new_value);
X				} else if (strncmp (buf, "Cc: ", 4) == 0) {
X					my_strncpy (buf2, &buf[4], LEN);
X					buf2[LEN-1] = '\0';
X					yank_to_addr (buf2, new_value);
X				} 
X				break;
X
X			case HEADER_SUBJECT:
X				if (strncmp (buf, "Subject: ", 9) == 0) {
X					my_strncpy (new_value, &buf[9], LEN);
X					new_value[LEN-1] = '\0';
X				}
X				break;
X		}
X	}
X
X	fclose (fp);
X
X	if (new_value[0] == ' ') {
X		my_strncpy (value, &new_value[1], LEN);
X	} else {
X		my_strncpy (value, new_value, LEN);
X	}
}
X
X
int cancel_article ()
{
X	char ch, ch_default = 'c';
X	char buf[LEN];
X	char cancel[LEN];
X	FILE *fp;
X	int redraw_screen = FALSE;
X
X	start_line_offset = 4;
X	
X	clear_message ();
X	
X	set_real_uid_gid ();
X
X	sprintf (cancel, "%s/.cancel", homedir);
X	if ((fp = fopen (cancel, "w")) == NULL) {
X		error_message (txt_cannot_open, cancel);
X		set_tin_uid_gid ();
X		return (redraw_screen);
X	}
X	chmod (cancel, 0600);
X
X	fprintf (fp, "Subject: cancel %s\n", note_h_messageid);
X	if (*note_h_followup) {
X		fprintf (fp, "Newsgroups: %s\n", note_h_followup);
X	} else {
X		fprintf (fp, "Newsgroups: %s\n", note_h_newsgroups);
X	}
X	fprintf (fp, "Control: cancel %s\n", note_h_messageid);
X	if (*my_org) { 
X		fprintf (fp, "Organization: %s\n", my_org);
X		start_line_offset++;	
X	}
X	if (*reply_to) {
X		fprintf (fp, "Reply-To: %s\n", reply_to);
X		start_line_offset++;	
X	}
X	fputs ("\n", fp);
X
X	fprintf (fp, "Article cancelled from within tin\n");
X	
X	fclose (fp);
X	
X	while (1) {
X		do {
X			my_strncpy (buf, note_h_subj, COLS-30);
X			sprintf (msg, "%s [%s]: %c", txt_abort_edit_cancel, buf, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (msg)-1);
X			if ((ch = (char) ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'a' && ch != 'e' && ch != 'c');
X
X		switch (ch) {
X		case 'e':
X			invoke_editor (cancel);
X 			set_real_uid_gid ();
X			redraw_screen = TRUE;
X			break;
X
X		case 'a':
X		case ESC:
X			unlink (cancel);
X			clear_message ();
X			set_tin_uid_gid ();
X			return (redraw_screen);
X
X		case 'c':
X			wait_message (txt_cancelling);
X			if (submit_file (cancel)) {
X				info_message (txt_art_cancelled);
X				goto cancel_article_done;
X			} else {
X				error_message (txt_command_failed_s, buf);
X				break;
X			}
X		}
X	}
X
cancel_article_done:
X	set_real_uid_gid ();
X	unlink (cancel);
X	set_tin_uid_gid ();
X
X	return (redraw_screen);
}
X
X
int submit_file(name)
X	char *name;
{
X	char	buf[LEN];
X	char*	cp = buf;
X
#ifdef INEWSDIR
X	strcpy(buf, INEWSDIR);
X	strcat(buf, "/");
X	cp = &buf[strlen(buf)];
#endif
X
X	sprintf (cp, "inews -h < %s %s", name, redirect_output);
X	
X	if (invoke_cmd(buf)) {
X 		set_real_uid_gid ();
X		return TRUE;
X	}
X	set_real_uid_gid ();
X	return FALSE;
}
X
X
void add_signature (fp, flag)
X	FILE *fp;
X	int flag;
{
X	FILE *sigf;
X
X	if ((sigf = fopen (signature, "r")) != NULL) {
X		if (flag) {
X			fprintf (fp, "\n--\n");
X			copy_fp (sigf, fp, (char *) 0);
X		}
X		fclose (sigf);
X		return;
X	}
X
X	if ((sigf = fopen (sig, "r")) != NULL) {
X		fprintf (fp, "\n--\n");
X		copy_fp (sigf, fp, (char *) 0);
X		fclose (sigf);
X	}
}
SHAR_EOF
echo 'File post.c is complete' &&
chmod 0600 post.c ||
echo 'restore of post.c failed'
Wc_c="`wc -c < 'post.c'`"
test 19458 -eq "$Wc_c" ||
	echo 'post.c: original size 19458, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= prompt.c ==============
if test -f 'prompt.c' -a X"$1" != X"-c"; then
	echo 'x - skipping prompt.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting prompt.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'prompt.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : prompt.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 25-11-91
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Rich Skrenta & Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
/*
X *  prompt_num
X *  get a number from the user
X *  Return -1 if missing or bad number typed
X */
X
int prompt_num (ch, prompt)
X	char ch;
X	char *prompt;
{
X	char *p;
X	int num;
X
X	clear_message ();
X
X	sprintf (msg, "%c", ch);
X
X	if ((p = getline (prompt, TRUE, msg)) != (char *) 0) {
X		strcpy (msg, p);
X		num = atoi (msg);
X	} else {
X		num = -1;
X	}
X
X	clear_message ();
X	return (num);
}
X
/*
X *  prompt_string
X *  get a string from the user
X *  Return TRUE if a valid string was typed, FALSE otherwise
X */
X
int prompt_string (prompt, buf)
X	char *prompt;
X	char *buf;
{
X	char *p;
X
X	clear_message ();
X
X	if ((p = getline (prompt, FALSE, (char *) 0)) == (char *) 0) {
X		buf[0] = '\0';
X		clear_message ();
X		return FALSE;
X	}
X	strcpy (buf, p);
X	
X	clear_message ();
X
X	return TRUE;
}
X
/*
X *  prompt_menu_string
X *  get a string from the user
X *  Return TRUE if a valid string was typed, FALSE otherwise
X */
X
int prompt_menu_string (line, col, var)
X	int line;
X	int col;
X	char *var;
{
X	char *p;
X
X	MoveCursor (line, col);
X
X	if ((p = getline ((char *) 0, FALSE, var)) == (char *) 0) {
X		return FALSE;
X	}
X	strcpy (var, p);
X	
X	return TRUE;
X
#ifdef XXX
X	char buf[LEN];
X	char ch;
X	int i, len;
X	int max_len;
X
X	MoveCursor (line, col);
X	buf[0] = '\0';
X	len = 0;
X	max_len = (COLS - col)-2;
X	ch = (char) ReadCh();
X
X	while (ch != '\n' && ch != '\r') {
X		if (ch == ESC) {		/* Esc pressed so abort */
X			return FALSE;
X		}
X		if (ch == 8 || ch == 127) {
X			if (len) {
X				len--;
X				buf[len] = '\0';
X				putchar('\b');
X				putchar(' ');
X				putchar('\b');
X			} else {
X				strcpy (var, buf);
X				MoveCursor(line, col);
X				CleartoEOLN();
X			}
X		} else if (ch == 21) {	/* control-U	*/
X			for (i = len; i > 0; i--) {
X				putchar('\b');
X				putchar(' ');
X				putchar('\b');
X			}
X			buf[0] = '\0';
X			len = 0;
X		} else if (ch >= ' ' && len < max_len) {
X			buf[len++] = ch;
X			buf[len] = '\0';
X			putchar (ch);
X		} else
X			putchar(7);
X		fflush(stdout);
X		ch = (char) ReadCh();
X		if(ch == EOF)
X			return FALSE;
X		ch &= 0xFF;
X	}
X
X	if (buf[0]) {
X		strcpy (var, buf);
X	}
X	return TRUE;
#endif
}
X
X
int prompt_yn (line, prompt, default_ch)
X	int line;
X	char *prompt;
X	char default_ch;
{
X	char ch;
X
X	MoveCursor (line, 0);
X	CleartoEOLN ();
X	printf ("%s%c", prompt, default_ch);
X	fflush (stdout);
X	MoveCursor (line, (int) strlen (prompt));
X
X	if ((ch = (char) ReadCh()) == CR) {
X		ch = default_ch;
X	}	
X
X	if (line == LINES) {
X		clear_message();
X	} else {
X		MoveCursor (line, (int) strlen (prompt));
X		if (ch == ESC) {
X			printf ("%c", default_ch);
X		} else {
X			printf ("%c", ch);
X		}
X		fflush (stdout);
X	}
X
X	return (ch == 'y' ? TRUE : FALSE);
}
X
X
void prompt_on_off (row, col, var, help_text, prompt_text)
X	int row;
X	int col;
X	int *var;
X	char *help_text;
X	char *prompt_text;
{
X	int ch, var_orig;
X
X	var_orig = *var;
X
X	show_menu_help (help_text);
X	do {
X		MoveCursor (row, col + (int) strlen (prompt_text));
X		if ((ch = (char) ReadCh ()) == ' ') {
X			*var = !*var;
X			printf ("%s", (*var ? "ON " : "OFF"));
X			fflush (stdout);
X		}
X	} while (ch != CR && ch != ESC);
X
X	if (ch == ESC) {
X		*var = var_orig;
X		printf ("%s", (*var ? "ON " : "OFF"));
X		fflush (stdout);
X	}
}
X
X
void continue_prompt ()
{
X	char ch;
X	
X	info_message (txt_hit_any_key);
X	ch = (char) ReadCh ();
}
X
X
SHAR_EOF
chmod 0600 prompt.c ||
echo 'restore of prompt.c failed'
Wc_c="`wc -c < 'prompt.c'`"
test 3748 -eq "$Wc_c" ||
	echo 'prompt.c: original size 3748, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= rcfile.c ==============
if test -f 'rcfile.c' -a X"$1" != X"-c"; then
	echo 'x - skipping rcfile.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting rcfile.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'rcfile.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : rcfile.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 23-01-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *	            You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
extern char index_file[LEN];
extern int index_point;
X
static int COL1;
static int COL2;
static int COL3;
X
/*
X *  read_rcfile - read defaults from ~/.tin/tinrc
X */
X
int read_rcfile ()
{
X	char buf[LEN];
X	FILE *fp;
X
X	if ((fp = fopen (rcfile, "r")) != NULL) {
X		while (fgets (buf, sizeof buf, fp) != NULL) {
X			if (buf[0] != '#') { 
X				if (strncmp (buf, "save_archive=", 13) == 0) {
X					save_archive_name = (strncmp (&buf[13], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "save_separate=", 14) == 0) {
X					save_separate = (strncmp (&buf[14], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "mark_saved_read=", 16) == 0) {
X					mark_saved_read = (strncmp (&buf[16], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "kill_articles=", 14) == 0) {
X					kill_articles = (strncmp (&buf[14], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "draw_arrow=", 11) == 0) {
X					draw_arrow_mark = (strncmp (&buf[11], "ON", 2) == 0 ? TRUE : FALSE);
X					if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X						inverse_okay = TRUE;
X					}
X				} else if (strncmp (buf, "print_header=", 13) == 0) {
X					print_header = (strncmp (&buf[13], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "pos_first_unread=", 17) == 0) {
X					pos_first_unread = (strncmp (&buf[17], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "full_page_scroll=", 17) == 0) {
X					full_page_scroll = (strncmp (&buf[17], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "catchup_read_groups=", 20) == 0) {
X					catchup_read_groups = (strncmp (&buf[20], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "thread_articles=", 16) == 0) {
X					thread_arts = (strncmp (&buf[16], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "show_only_unread=", 17) == 0) {
X					show_only_unread = (strncmp (&buf[17], "ON", 2) == 0 ? TRUE : FALSE);
X				} else if (strncmp (buf, "show_author=", 12) == 0) {
X					default_show_author = atoi (&buf[12]);
X				} else if (strncmp (buf, "post_process_type=", 18) == 0) {
X					post_proc_type = atoi (&buf[18]);
X					switch (post_proc_type) {
X						case POST_PROC_NONE:
X							proc_ch_default = 'n';
X							break;
X						case POST_PROC_SHAR:
X							proc_ch_default = 's';
X							break;
X						case POST_PROC_UUDECODE:
X							proc_ch_default = 'u';
X							break;
X						case POST_PROC_UUD_LST_ZOO:
X							proc_ch_default = 'U';
X							break;
X						case POST_PROC_UUD_EXT_ZOO:
X							proc_ch_default = 'U';
X							break;
X					}
X				} else if (strncmp (buf, "sort_article_type=", 18) == 0) {
X					sort_art_type = atoi (&buf[18]);
X				} else if (strncmp (buf, "savedir=", 8) == 0) {
X					strncpy (savedir, &buf[8], LEN);
X					savedir[strlen (savedir) - 1] = '\0';
X					if (savedir[0] == '.' && strlen (savedir) == 1) {
#if defined(BSD) && ! defined(SINIX)
X						getwd (buf);	
#else
X						getcwd (buf, LEN);
#endif
X						my_strncpy (savedir, buf, LEN);
X					}
X				} else if (strncmp (buf, "maildir=", 8) == 0) {
X					strncpy (maildir, &buf[8], LEN);
X					maildir[strlen (maildir) - 1] = '\0';
X				} else if (strncmp (buf, "printer=", 8) == 0) {
X					strncpy (printer, &buf[8], LEN);
X					printer[strlen (printer) - 1] = '\0';
X				} else if (strncmp (buf, "spooldir=", 9) == 0) {
X					strncpy (spooldir, &buf[9], LEN);
X					spooldir[strlen (spooldir) - 1] = '\0';
X				} else if (strncmp (buf, "signature=", 10) == 0) {
X					strncpy (signature, &buf[10], LEN);
X					signature[strlen (signature) - 1] = '\0';
X				} else if (strncmp (buf, "sig=", 4) == 0) {
X					strncpy (sig, &buf[4], LEN);
X					sig[strlen (sig) - 1] = '\0';
X				}
X			}
X		}
X		fclose (fp);
X		return TRUE;		
X	}
X	return FALSE;		
}
X
/*
X *  write_rcfile - write defaults to ~/.tin/tinrc
X */
X
void write_rcfile ()
{
X	FILE *fp;
X
X	set_real_uid_gid ();
X	
X	if ((fp = fopen (rcfile, "w")) != NULL) {
X		wait_message (txt_saving);
X
X		fprintf (fp, "# if ON articles/threads with Archive-name: in mail header will\n");
X		fprintf (fp, "# be automatically saved with the Archive-name & part/patch no.\n");
X		fprintf (fp, "save_archive=%s\n\n", (save_archive_name ? "ON" : "OFF"));
X		fprintf (fp, "# if ON articles of a threads will be saved to separate files\n");
X		fprintf (fp, "# otherwise the whole thread will be saved to one file\n");
X		fprintf (fp, "save_separate=%s\n\n", (save_separate ? "ON" : "OFF"));
X		fprintf (fp, "# if ON mark articles that are saved as read\n");
X		fprintf (fp, "mark_saved_read=%s\n\n", (mark_saved_read ? "ON" : "OFF"));
X		fprintf (fp, "# if ON use -> otherwise highlighted bar for selection\n");
X		fprintf (fp, "draw_arrow=%s\n\n", (draw_arrow_mark ? "ON" : "OFF"));
X		fprintf (fp, "# if ON kill articles that match kill file\n");
X		fprintf (fp, "kill_articles=%s\n\n", (kill_articles ? "ON" : "OFF"));
X		fprintf (fp, "# if ON print all of mail header otherwise Subject: & From: lines\n");
X		fprintf (fp, "print_header=%s\n\n", (print_header ? "ON" : "OFF"));
X		fprintf (fp, "# if ON put cursor at first unread art in group otherwise last art\n");
X		fprintf (fp, "pos_first_unread=%s\n\n", (pos_first_unread ? "ON" : "OFF"));
X		fprintf (fp, "# if ON scroll full page of groups/articles otherwise half a page\n");
X		fprintf (fp, "full_page_scroll=%s\n\n", (full_page_scroll ? "ON" : "OFF"));
X		fprintf (fp, "# if ON ask user if read groups should all be marked read\n");
X		fprintf (fp, "catchup_read_groups=%s\n\n", (catchup_read_groups ? "ON" : "OFF"));
X		fprintf (fp, "# part of from field to display 0) none 1) address 2) full name 3) both\n");
X		fprintf (fp, "show_author=%d\n\n", default_show_author);
X		fprintf (fp, "# type of post processing to perform after saving articles.\n");
X		fprintf (fp, "# 0) none 1) shar 2) uudecode 3) uud & list zoo 4) uud & extract zoo 5) patch.\n");
X		fprintf (fp, "post_process_type=%d\n\n", post_proc_type);
X		fprintf (fp, "# if ON and group not in ~/.tin/unthread articles will be threaded.\n");
X		fprintf (fp, "thread_articles=%s\n\n", (thread_arts ? "ON" : "OFF"));
X		fprintf (fp, "# if ON show only new/unread articles otherwise show all.\n");
X		fprintf (fp, "show_only_unread=%s\n\n", (show_only_unread ? "ON" : "OFF"));
X		fprintf (fp, "# sort articles by 0) nothing 1) Subject (descending) 2) Subject (ascending)\n");
X		fprintf (fp, "# 3) From (descend) 4) From (ascend) 5) Date (descend) 6) Date (ascend)\n");
X		fprintf (fp, "sort_article_type=%d\n\n", sort_art_type);
X		fprintf (fp, "# (-d) directory where articles/threads are saved\n");
X		fprintf (fp, "savedir=%s\n\n", savedir);
X		fprintf (fp, "# (-M) directory where articles/threads are saved in mailbox format\n");	
X		fprintf (fp, "maildir=%s\n\n", maildir);	
X		fprintf (fp, "# (-p) print program with parameters used to print articles/threads\n");
X		fprintf (fp, "printer=%s\n\n", printer);
X		fprintf (fp, "# (-s) directory where news is spooled\n");
X		fprintf (fp, "spooldir=%s\n\n", spooldir);
X
X		fprintf (fp, "# .signature file used for replies, followups\n");
X		fprintf (fp, "signature=%s\n\n", signature);
X		fprintf (fp, "# .Sig file used for postings\n");
X		fprintf (fp, "sig=%s\n\n", sig);
X
X		fclose (fp);
X		chmod (rcfile, 0600);
X	}
X	set_tin_uid_gid ();
}
X
/*
X *  options menu so that the user can dynamically change parameters
X */
X 
int change_rcfile (group, kill_at_once)
X	char *group;
X	int kill_at_once;
{
X	char *str;
X	int ch, i;
X	int kill_changed = FALSE;
X	int orig_kill_state;
X	int orig_show_only_unread;
X	int orig_thread_arts;
X	int option;
X	int ret_code = NO_KILLING;
X	int var_orig;
X	
#ifdef SIGTSTP
X	SIGTYPE (*susp)();
X
X	if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X		sigemptyset (&rcfile_act.sa_mask);
X		rcfile_act.sa_flags = SA_RESTART | SA_RESETHAND;
X		rcfile_act.sa_handler = SIG_DFL;
X		sigaction (SIGTSTP, &rcfile_act, &old_act);
#else
X		susp = signal (SIGTSTP, SIG_DFL);
#endif
X	}
#endif
X
X	COL1 = 0;
X	COL2 = ((COLS / 3) * 1) + 1;
X	COL3 = ((COLS / 3) * 2) + 2;
X
X	show_rcfile_menu ();
X
X	while (1) {
X
#ifdef SIGTSTP
X		if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X			sigemptyset (&rcfile_act.sa_mask);
X			rcfile_act.sa_flags = SA_RESTART | SA_RESETHAND;
X			rcfile_act.sa_handler = rcfile_suspend;
X			sigaction (SIGTSTP, &rcfile_act, 0L);
#else
X			signal (SIGTSTP, rcfile_suspend);
#endif
X		}
#endif
X		MoveCursor (LINES, 0);
X		ch = ReadCh ();
X		if (ch >= '1' && ch <= '9') {
X			option = prompt_num (ch, "Enter option number> ");
X		} else {
X			if (ch == 'q' || ch == ESC) {
X				option = -1;
X			} else {
X				option = 0;
X			}
X		}
#ifdef SIGTSTP
X		if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X			sigemptyset (&rcfile_act.sa_mask);
X			rcfile_act.sa_flags = SA_RESTART | SA_RESETHAND;
X			rcfile_act.sa_handler = SIG_IGN;
X			sigaction (SIGTSTP, &rcfile_act, 0L);
#else
X			signal (SIGTSTP, SIG_IGN);
#endif
X		}
#endif
X		switch (option) {
X			case -1:
X				clear_note_area ();
X				return ret_code;
X				/*NOTREACHED*/				
X			case 0:
X				write_rcfile ();
X				if (kill_changed) {
X					if (kill_at_once) {
X						if (kill_articles) {
X							read_kill_file ();
X							if (kill_any_articles (group)) {
X								reload_index_file (group, TRUE);	/* kill arts */
X							}
X						} else {
X							reload_index_file (group, FALSE);	/* add killed arts */
X						}
X					}
X					ret_code = KILLING;
X				}
X				clear_note_area ();
#ifdef SIGTSTP
X				if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X					sigemptyset (&rcfile_act.sa_mask);
X					rcfile_act.sa_flags = SA_RESTART | SA_RESETHAND;
X					rcfile_act.sa_handler = SIG_IGN;
X					sigaction (SIGTSTP, &old_act, 0L);
#else
X					signal (SIGTSTP, susp);
#endif
X				}
#endif
X				return ret_code;
X			
X			case 1:		/* auto save */
X				prompt_on_off (INDEX_TOP, COL1, &save_archive_name, 
X					txt_help_autosave, txt_opt_autosave);
X				break;
X
X			case 2:		/* save sperate */
X				prompt_on_off (INDEX_TOP, COL2, &save_separate, 
X					txt_help_save_separate, txt_opt_save_separate);
X				break;
X			
X			case 3:		/* mark saved articles read */
X				prompt_on_off (INDEX_TOP, COL3, &mark_saved_read, 
X					txt_help_mark_saved_read, txt_opt_mark_saved_read);
X				break;
X
X			case 4:		/* kill articles */
X				orig_kill_state = kill_articles;
X				show_menu_help (txt_help_kill_articles);
X				do {
X					MoveCursor (INDEX_TOP+2, COL1 + (int) strlen (txt_opt_kill_articles));
X					if ((ch = ReadCh()) == ' ') {
X						kill_articles = !kill_articles;
X						kill_changed = (kill_articles != orig_kill_state ? TRUE : FALSE);
X						printf ("%s", (kill_articles ? "ON " : "OFF"));
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X				break;
X
X			case 5:		/* draw -> / highlighted bar */
X				prompt_on_off (INDEX_TOP+2, COL2, &draw_arrow_mark, 
X					txt_help_draw_arrow, txt_opt_draw_arrow);
X				if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X					inverse_okay = TRUE;
X				}
X				break;
X
X			case 6:		/* print header */
X				prompt_on_off (INDEX_TOP+2, COL3, &print_header, 
X					txt_help_print_header, txt_opt_print_header);
X				break;
X			
X			case 7:		/* position cursor at first / last unread art */
X				prompt_on_off (INDEX_TOP+4, COL1, &pos_first_unread, 
X					txt_help_pos_first_unread, txt_opt_pos_first_unread);
X				break;
X
X			case 8:		/* scroll half/full page of groups/articles */
X				prompt_on_off (INDEX_TOP+4, COL2, &full_page_scroll, 
X					txt_help_page_scroll, txt_opt_page_scroll);
X				break;
X
X			case 9:		/* catchup read groups when quitting */
X				prompt_on_off (INDEX_TOP+4, COL3, &catchup_read_groups, 
X					txt_help_catchup_groups, txt_opt_catchup_groups);
X				break;
X
X			case 10:	/* thread/unthread all groups except those in ~/.tin/unthreaded */
X				orig_thread_arts = thread_arts;	
X				prompt_on_off (INDEX_TOP+6, COL1, &thread_arts, 
X					txt_help_thread_arts, txt_opt_thread_arts);
X				if (thread_arts != orig_thread_arts || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X				}
X				break;
X
X			case 11:	/* show all arts or just new/unread arts */
X				orig_show_only_unread = show_only_unread;	
X				prompt_on_off (INDEX_TOP+6, COL2, &show_only_unread, 
X					txt_help_show_only_unread, txt_opt_show_only_unread);
X				if (show_only_unread != orig_show_only_unread || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X					if (space_mode) {
X						for (i = 0; i < top_base; i++) {
X							if (new_responses (i)) {
X								break;
X							}
X						}
X						if (i < top_base) {
X							index_point = i;
X						} else {
X							index_point = top_base - 1;
X						}
X					} else {
X						index_point = top_base - 1;
X					}
X				}
X				break;
X
X			case 13:		/* show subject & author / subject only */
X				var_orig = show_author;
X				show_menu_help (txt_help_show_author);
X				do {
X					MoveCursor (INDEX_TOP+8, COL1 + (int) strlen (txt_opt_show_author));
X					if ((ch	= ReadCh()) == ' ') {
X						if (show_author + 1 > SHOW_FROM_BOTH) {
X							show_author = SHOW_FROM_NONE;
X						} else {
X							show_author++;
X						}
X						switch (show_author) {
X							case SHOW_FROM_NONE:
X								str = txt_show_from_none;
X								break;
X							case SHOW_FROM_ADDR:
X								str = txt_show_from_addr;
X								break;
X							case SHOW_FROM_NAME:
X								str = txt_show_from_name;
X								break;
X							case SHOW_FROM_BOTH:
X								str = txt_show_from_both;
X								break;
X						}
X						printf ("%s", str);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					show_author = var_orig;
X					switch (show_author) {
X						case SHOW_FROM_NONE:
X							str = txt_show_from_none;
X							break;
X						case SHOW_FROM_ADDR:
X							str = txt_show_from_addr;
X							break;
X						case SHOW_FROM_NAME:
X							str = txt_show_from_name;
X							break;
X						case SHOW_FROM_BOTH:
X							str = txt_show_from_both;
X							break;
X					}
X					printf ("%s", str);
X					fflush (stdout);
X				} else {
X					default_show_author = show_author;	
X					if (show_author == SHOW_FROM_BOTH) {
X						max_subj = (COLS / 2) - 2;
X					} else {
X						max_subj = (COLS / 2) + 5;
X					}
X					max_from = (COLS - max_subj) - 17;
X				}
X				break;
X
X			case 14:
X				var_orig = post_proc_type;
X				show_menu_help (txt_help_post_proc_type);
X				do {
X					MoveCursor (INDEX_TOP+8, COL2 + (int) strlen (txt_opt_process_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (post_proc_type + 1 > POST_PROC_UUD_EXT_ZOO) {
X							post_proc_type = POST_PROC_NONE;
X						} else {
X							post_proc_type++;
X						}
X						switch (post_proc_type) {
X							case POST_PROC_NONE:
X								str = txt_post_process_none;
X								proc_ch_default = 'n';
X								break;
X							case POST_PROC_SHAR:
X								str = txt_post_process_sh;
X								proc_ch_default = 's';
X								break;
X							case POST_PROC_UUDECODE:
X								str = txt_post_process_uudecode;
X								proc_ch_default = 'u';
X								break;
X							case POST_PROC_UUD_LST_ZOO:
X								str = txt_post_process_uud_lst_zoo;
X								proc_ch_default = 'U';
X								break;
X							case POST_PROC_UUD_EXT_ZOO:
X								str = txt_post_process_uud_ext_zoo;
X								proc_ch_default = 'U';
X								break;
X						}
X						CleartoEOLN (); 
X						printf ("%s", str);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					post_proc_type = var_orig;
X					switch (post_proc_type) {
X						case POST_PROC_NONE:
X							str = txt_post_process_none;
X							proc_ch_default = 'n';
X							break;
X						case POST_PROC_SHAR:
X							str = txt_post_process_sh;
X							proc_ch_default = 's';
X							break;
X						case POST_PROC_UUDECODE:
X							str = txt_post_process_uudecode;
X							proc_ch_default = 'u';
X							break;
X						case POST_PROC_UUD_LST_ZOO:
X							str = txt_post_process_uud_lst_zoo;
X							proc_ch_default = 'U';
X							break;
X						case POST_PROC_UUD_EXT_ZOO:
X							str = txt_post_process_uud_ext_zoo;
X							proc_ch_default = 'U';
X							break;
X					}
X					CleartoEOLN (); 
X					printf ("%s", str);
X					fflush (stdout);
X				}
X				break;
X
X			case 15:
X				var_orig = sort_art_type;
X				show_menu_help (txt_help_sort_type);
X				do {
X					MoveCursor (INDEX_TOP+10, COL1 + (int) strlen (txt_opt_sort_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (sort_art_type + 1 > SORT_BY_DATE_ASCEND) {
X							sort_art_type = SORT_BY_NOTHING;
X						} else {
X							sort_art_type++;
X						}
X						switch (sort_art_type) {
X							case SORT_BY_NOTHING:
X								str = txt_sort_by_nothing;
X								break;
X							case SORT_BY_SUBJ_DESCEND:
X								str = txt_sort_by_subj_descend;
X								break;
X							case SORT_BY_SUBJ_ASCEND:
X								str = txt_sort_by_subj_ascend;
X								break;
X							case SORT_BY_FROM_DESCEND:
X								str = txt_sort_by_from_descend;
X								break;
X							case SORT_BY_FROM_ASCEND:
X								str = txt_sort_by_from_ascend;
X								break;
X							case SORT_BY_DATE_DESCEND:
X								str = txt_sort_by_date_descend;
X								break;
X							case SORT_BY_DATE_ASCEND:
X								str = txt_sort_by_date_ascend;
X								break;
X						}
X						CleartoEOLN (); 
X						printf ("%s", str);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					sort_art_type = var_orig;
X					switch (sort_art_type) {
X						case SORT_BY_NOTHING:
X							str = txt_sort_by_nothing;
X							break;
X						case SORT_BY_SUBJ_DESCEND:
X							str = txt_sort_by_subj_descend;
X							break;
X						case SORT_BY_SUBJ_ASCEND:
X							str = txt_sort_by_subj_ascend;
X							break;
X						case SORT_BY_FROM_DESCEND:
X							str = txt_sort_by_from_descend;
X							break;
X						case SORT_BY_FROM_ASCEND:
X							str = txt_sort_by_from_ascend;
X							break;
X						case SORT_BY_DATE_DESCEND:
X							str = txt_sort_by_date_descend;
X							break;
X						case SORT_BY_DATE_ASCEND:
X							str = txt_sort_by_date_ascend;
X							break;
X					}
X					CleartoEOLN (); 
X					printf ("%s", str);
X					fflush (stdout);
X				}
X				break;
X
X			case 16:
X				show_menu_help (txt_help_savedir);
X				prompt_menu_string (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), savedir);
X				expand_rel_abs_pathname (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), savedir);
X				break;
X
X			case 17:
X				show_menu_help (txt_help_maildir);
X				prompt_menu_string (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), maildir);
X				expand_rel_abs_pathname (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), maildir);
X				break;
X
X			case 18:
X				show_menu_help (txt_help_printer);
X				prompt_menu_string (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				expand_rel_abs_pathname (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				break;
X		}
X		show_menu_help (txt_select_rcfile_option);
X	}
}
X
X
void show_rcfile_menu ()
{
X	char *str;
X
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_options_menu);
X	
X	MoveCursor (INDEX_TOP, 0);
X	printf ("%s%s\r\n\r\n", txt_opt_autosave, (save_archive_name ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_kill_articles, (kill_articles ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_pos_first_unread, (pos_first_unread ? "ON " : "OFF"));
X	printf ("%s%s", txt_opt_thread_arts, (thread_arts ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL2);
X	printf ("%s%s", txt_opt_save_separate, (save_separate ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL2);
X	printf ("%s%s", txt_opt_draw_arrow, (draw_arrow_mark ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL2);
X	printf ("%s%s", txt_opt_page_scroll, (full_page_scroll ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+6, COL2);
X	printf ("%s%s", txt_opt_show_only_unread, (show_only_unread ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL3);
X	printf ("%s%s", txt_opt_mark_saved_read, (mark_saved_read ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL3);
X	printf ("%s%s", txt_opt_print_header, (print_header ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL3);
X	printf ("%s%s", txt_opt_catchup_groups, (catchup_read_groups ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP+8, COL1);
X	switch (show_author) {
X		case SHOW_FROM_NONE:
X			str = txt_show_from_none;
X			break;
X		case SHOW_FROM_ADDR:
X			str = txt_show_from_addr;
X			break;
X		case SHOW_FROM_NAME:
X			str = txt_show_from_name;
X			break;
X		case SHOW_FROM_BOTH:
X			str = txt_show_from_both;
X			break;
X		}
X	printf ("%s%s", txt_opt_show_author, str);
X	MoveCursor(INDEX_TOP+8, COL2);
X	switch (post_proc_type) {
X		case POST_PROC_NONE:
X			str = txt_post_process_none;
X			break;
X		case POST_PROC_SHAR:
X			str = txt_post_process_sh;
X			break;
X		case POST_PROC_UUDECODE:
X			str = txt_post_process_uudecode;
X			break;
X		case POST_PROC_UUD_LST_ZOO:
X			str = txt_post_process_uud_lst_zoo;
X			break;
X		case POST_PROC_UUD_EXT_ZOO:
X			str = txt_post_process_uud_ext_zoo;
X			break;
X	}
X	printf ("%s%s\r\n\r\n", txt_opt_process_type, str);
X	
X	MoveCursor(INDEX_TOP+10, COL1);
X	switch (sort_art_type) {
X		case SORT_BY_NOTHING:
X			str = txt_sort_by_nothing;
X			break;
X		case SORT_BY_SUBJ_DESCEND:
X			str = txt_sort_by_subj_descend;
X			break;
X		case SORT_BY_SUBJ_ASCEND:
X			str = txt_sort_by_subj_ascend;
X			break;
X		case SORT_BY_FROM_DESCEND:
X			str = txt_sort_by_from_descend;
X			break;
X		case SORT_BY_FROM_ASCEND:
X			str = txt_sort_by_from_ascend;
X			break;
X		case SORT_BY_DATE_DESCEND:
X			str = txt_sort_by_date_descend;
X			break;
X		case SORT_BY_DATE_ASCEND:
X			str = txt_sort_by_date_ascend;
X			break;
X	}
X	printf ("%s%s\r\n\r\n", txt_opt_sort_type, str);
X
X	printf ("%s%s\r\n\r\n", txt_opt_savedir, savedir);
X	printf ("%s%s\r\n\r\n", txt_opt_maildir, maildir);
X	printf ("%s%s\r\n\r\n", txt_opt_printer, printer);
X	fflush(stdout);
X
X	show_menu_help (txt_select_rcfile_option);
X	MoveCursor (LINES, 0);
}
X
/*
X *  expand ~/News to /usr/username/News and print to screen
X */
X 
void expand_rel_abs_pathname (line, col, str)
X	int line;
X	int col;
X	char *str;
{
X	char buf[LEN];
X	
X	if (str[0] == '~') {
X		if (strlen (str) == 1) {
X			strcpy (str, homedir);
X		} else {
X			sprintf (buf, "%s%s", homedir, str+1);
X			strcpy (str, buf);
X		}
X	}
X	MoveCursor (line, col);
X	CleartoEOLN ();
X	puts (str);
X	fflush (stdout);
}
X
/*
X *  show_menu_help
X */
X 
void show_menu_help (help_message)
X	char *help_message;
{
X	 MoveCursor (LINES-2, 0);
X	 CleartoEOLN ();
X	 center_line (LINES-2, FALSE, help_message);
}
SHAR_EOF
chmod 0600 rcfile.c ||
echo 'restore of rcfile.c failed'
Wc_c="`wc -c < 'rcfile.c'`"
test 22451 -eq "$Wc_c" ||
	echo 'rcfile.c: original size 22451, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= save.c ==============
if test -f 'save.c' -a X"$1" != X"-c"; then
	echo 'x - skipping save.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting save.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'save.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : save.c
X *  Author    : R.Skrenta / I.Lea
X *  Created   : 01-04-91
X *  Updated   : 15-12-91
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Rich Skrenta & Iain Lea
X *	            You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
#define	INITIAL		1
#define MIDDLE		2
#define OFF			3
#define END			4
X
int create_subdir = TRUE;
X
struct save_t *save;
int save_num=0;
int max_save;
X
/*
X * types of archive programs
X * 0=archiver, 1=extension, 2=extract option, 3=list option
X */
X 
struct archiver_t { 
X	char *name;
X	char *ext;
X	char *extract;
X	char *list;
};
X
struct archiver_t archiver[] = {
X	{ "",			"",			"",			"" },
X	{ "",			"",			"",			"" },
X	{ "",			"",			"",			"" },
X	{ "zoo",		"zoo",		"-extract",	"-list" },
X	{ (char *) 0,	(char *) 0,	(char *) 0,	(char *) 0 }
};
X
extern char *glob_group;
extern char note_h_path[LEN];	/* Path:	*/
extern char note_h_date[LEN];	/* Date:	*/
extern FILE	*note_fp;			/* the body of the current article */
extern int index_point;
extern int note_end;
extern int note_page;
extern long note_mark[MAX_PAGES];
X
X
/*
X *  Check for articles and say how many new/unread in each group.
X *  or
X *  Start if new/unread articles and return first group with new/unread.
X *  or
X *  Save any new articles to savedir and mark arts read and mail user
X *  and inform how many arts in which groups were saved.
X *  or
X *  Mail any new articles to specified user and mark arts read and mail
X *  user and inform how many arts in which groups were mailed.
X */
X
int check_start_save_any_news (check_start_save)
X	int check_start_save;
{
X	char buf[LEN], logfile[LEN], *p;
X	char group_path[LEN];
X	char savefile[LEN];
X	extern FILE *note_fp;
X	FILE *fp, *fp_log;
X	int i, j, print_group;
X	int check_arts = 0;
X	int	log_opened = TRUE;
X	int print_first = TRUE;
X	int saved_arts = 0;
X	int saved_groups = 0;
X	int unread_news = FALSE;	
X	long epoch;
X
X	switch (check_start_save) {
X		case CHECK_ANY_NEWS:
X			if (verbose) {
X				wait_message (txt_checking_for_news);
X			}
X			break;
X		case START_ANY_NEWS:
X			wait_message (txt_checking_for_news);
X			break;
X		case MAIL_ANY_NEWS:
X		case SAVE_ANY_NEWS:
X			sprintf (logfile, "%s/log", rcdir);
X			if ((fp_log = fopen (logfile, "w")) == NULL) {
X				error_message (txt_cannot_open, logfile);
X				fp_log = stdout;
X				verbose = FALSE;
X				log_opened = FALSE;
X			}
X			time (&epoch);
X			fprintf (fp_log, "To: %s\n", userid);
X			fprintf (fp_log, "Subject: NEWS LOG %s\n", ctime (&epoch));
X			break;
X	}
X	
X	for (i = 0; i < group_top; i++) {
X		strcpy (group_path, active[my_group[i]].name);
X		for (p = group_path; *p; p++) {
X			if (*p == '.') {
X				*p = '/';
X			}
X		}
X		
X		index_group (active[my_group[i]].name, group_path);
X		read_newsrc_line (active[my_group[i]].name);
X		print_group = TRUE;
X		check_arts = 0;
X
X		for (j = 0; j < top; j++) {
X			if (arts[j].unread == ART_UNREAD)  {
X				switch (check_start_save) {
X					case CHECK_ANY_NEWS:
X						if (print_first && verbose) {
X							putchar ('\n');
X							print_first = FALSE;
X						}
X						check_arts++;
X						break;
X					case START_ANY_NEWS:
X						return i;	/* return first group with unread news */ 
X						/* NOTREACHED */
X					case MAIL_ANY_NEWS:
X					case SAVE_ANY_NEWS:
X						if (print_group) {	
X							sprintf (buf, "Saved %s...\n", active[my_group[i]].name);
X							fprintf (fp_log, "%s", buf);
X							if (verbose) {
X								wait_message (buf);
X							}
X							print_group = FALSE;
X							saved_groups++;
X							if (check_start_save == SAVE_ANY_NEWS) {
X								sprintf (buf, "%s/dummy", group_path);
X								create_path (buf);
X							}
X						}
X						sprintf (buf, "[%5ld]  %s\n", arts[j].artnum, arts[j].subject);
X						fprintf (fp_log, "%s", buf);
X						if (verbose) {
X							wait_message (buf);
X						}
X						saved_arts++;
X
X						if (check_start_save == MAIL_ANY_NEWS) {
X							sprintf (savefile, "/tmp/tin.%d", getpid ());
X						} else {
X							sprintf (savefile, "%s/%s/%ld", savedir,
X									 group_path, arts[j].artnum);
X						}
X
X						if ((fp = fopen (savefile, "w")) == NULL) {
X							fprintf (fp_log, txt_cannot_open, savefile);
X							if (verbose) {
X								error_message (txt_cannot_open, savefile);
X							}
X							continue;
X						}
X				
X						if (check_start_save == MAIL_ANY_NEWS) {
X							fprintf (fp, "To: %s\n", mail_news_user);
X						}
X
X						art_open (arts[j].artnum, group_path);	
X						fseek (note_fp, 0L, 0);
X						copy_fp (note_fp, fp, (char *) 0);
X						art_close ();
X						fclose (fp);
X
X						if (check_start_save == MAIL_ANY_NEWS) {
X							sprintf (buf, "%s \"%s\" < %s", mailer,
X									mail_news_user, savefile);
X							if (! invoke_cmd (buf)) {
X								error_message (txt_command_failed_s, buf);
X							}
X							unlink (savefile);
X						}
X						if (catchup) {
X							arts[j].unread = ART_READ;
X						}
X						break;
X				}
X			}
X		}
X		
X		if (check_start_save == MAIL_ANY_NEWS ||
X			check_start_save == SAVE_ANY_NEWS) {
X			if (catchup) {
X				update_newsrc (active[my_group[i]].name, my_group[i], FALSE);
X			}
X		} else {
X			if (check_arts) {
X				if (verbose) {
X					sprintf (buf, "%4d unread articles in %s\n",
X						check_arts, active[my_group[i]].name);
X					wait_message (buf); 	
X				}
X				unread_news = TRUE;	
X			}
X		}
X	}
X	switch (check_start_save) {
X		case CHECK_ANY_NEWS:
X			if (unread_news) {
X				return 2;
X			} else {
X				if (verbose) {
X					wait_message (txt_there_is_no_news);
X				}
X				return 0;
X			}
X			/* NOTREACHED */ 
X		case START_ANY_NEWS:
X			wait_message (txt_there_is_no_news);
X			return -1;
X			/* NOTREACHED */ 
X		case MAIL_ANY_NEWS:
X		case SAVE_ANY_NEWS:
X			sprintf (buf, "\n%s %d article(s) from %d group(s)\n", 
X				(check_start_save == MAIL_ANY_NEWS ? "Mailed" : "Saved"),
X				saved_arts, saved_groups);
X			fprintf (fp_log, "%s", buf);
X			if (verbose) {
X				wait_message (buf);
X			}
X			if (log_opened) {
X				fclose (fp_log);
X				if (verbose) {
X					sprintf (buf, "Mailing log to %s\n",
X						(check_start_save == MAIL_ANY_NEWS ? mail_news_user : userid));
X					wait_message (buf);
X				}
X				sprintf (buf, "%s \"%s\" < %s", mailer,
X					(check_start_save == MAIL_ANY_NEWS ? mail_news_user : userid),
X					logfile);
X				if (! invoke_cmd (buf)) {
X					error_message (txt_command_failed_s, buf);
X				}
X			}
X			break;
X	}
X	return 0;
}
X
X
int save_art_to_file (respnum, index, mailbox, filename)
X	int respnum;
X	int index;
X	int mailbox;
X	char *filename;
{
X	char file[LEN];
X	char save_art_info[LEN];
X	FILE *fp;
X	int is_mailbox = FALSE;
X	int i = 0, ret_code = FALSE;
X	long epoch;
X	
X	if (filename) {
X		my_strncpy (file, filename, LEN);
X		is_mailbox = mailbox;
X		i = index;
X	} else if (save_archive_name && arts[respnum].archive) {
X			my_strncpy (file, arts[respnum].archive, LEN);
X	}
X
X	if (! append_to_existing_file (i)) {
X		save[i].saved = FALSE;
X		info_message (txt_art_not_saved);
X		sleep (1);
X		return (ret_code);
X	}
X
X	set_real_uid_gid ();
X
X	if ((fp = fopen (save_filename (i), "a+")) == NULL) {
X		save[i].saved = FALSE;
X		info_message (txt_art_not_saved);
X		set_tin_uid_gid ();
X		return (ret_code);
X	}
X
X 	time (&epoch);
X 	fprintf (fp, "From %s %s", note_h_path, ctime (&epoch));
X
X	if (fseek (note_fp, 0L, 0) == -1) {
X		error_message ("fseek() error on [%s]", arts[respnum].subject);
X	}
X	copy_fp (note_fp, fp, (char *) 0);
X	fputs ("\n", fp);
X	fclose (fp);
X	fseek (note_fp, note_mark[note_page], 0);
X
X	save[i].saved = TRUE;
X
X	set_tin_uid_gid ();
X
X	if (filename == (char *) 0) {
X		if (is_mailbox) {
X			sprintf (save_art_info, txt_saved_to_mailbox, get_first_savefile ());
X		} else {
X			sprintf (save_art_info, txt_art_saved_to, get_first_savefile ());
X		}
X		info_message(save_art_info);
X	}
X	return TRUE;
}
X
X
int save_thread_to_file (is_mailbox, group_path)
X	int is_mailbox;
X	char *group_path;
{
X	char buf[LEN];
X	char save_thread_info[LEN];
X	char *first_savefile;
X	int count = 0;
X	int i, ret_code = FALSE;
X	long epoch;
X
X	set_real_uid_gid ();
X
X	for (i=0 ; i < save_num ; i++) {
X		sprintf (msg, "%s%d", txt_saving, ++count);
X		wait_message (msg);
X
X		if (is_mailbox) {
X			buf[0] = 0;
X		}else {
X			sprintf (buf, "%s.%02d", save[i].file, i+1);
X		}
X
X		art_open (arts[save[i].index].artnum, group_path);
X		ret_code = save_art_to_file (save[i].index, i, is_mailbox, buf);
X		art_close ();			
X	}
X	set_tin_uid_gid ();
X	
X	first_savefile = get_first_savefile ();
X
X	if (first_savefile == (char *) 0) {
X		info_message (txt_thread_not_saved);
X	} else {
X		if (is_mailbox) {
X			sprintf (save_thread_info, txt_saved_to_mailbox, first_savefile);
X		} else {
X			if (save_num == 1) {
X				sprintf (save_thread_info, txt_art_saved_to, first_savefile);
X			} else {
X				if (save_separate) {
X					sprintf (save_thread_info, txt_thread_saved_to_many,
X						first_savefile, get_last_savefile ());
X				} else {
X					sprintf (save_thread_info, txt_thread_saved_to,
X						first_savefile);
X				}
X			}
X			if (first_savefile != (char *) 0) {
X				free (first_savefile);
X				first_savefile = (char *) 0;
X			}
X		}
X		info_message (save_thread_info);
X	}
X	return TRUE;
}
X
X
int save_regex_arts (is_mailbox, group_path)
X	int is_mailbox;
X	char *group_path;
{
X	char buf[LEN];
X	int i, ret_code; 	
X	
X	for (i=0 ; i < save_num ; i++) {
X		sprintf(msg, "%s%d", txt_saving, i+1);
X		wait_message (msg);
X
X		if (is_mailbox) {
X			buf[0] = 0;
X		}else {
X			sprintf (buf, "%s.%02d", save[i].file, i+1);
X		}
X
X		art_open (arts[save[i].index].artnum, group_path);
X		ret_code = save_art_to_file (save[i].index, i, is_mailbox, buf);
X		art_close ();			
X	}
X
X	if (! save_num) {	
X		info_message (txt_no_match);
X	} else {
X		if (is_mailbox) {
X			sprintf (buf, txt_saved_to_mailbox, get_first_savefile ());
X		} else {
X			sprintf (buf,txt_saved_pattern_to,
X				get_first_savefile (), get_last_savefile ());
X		}
X		info_message (buf);
X	}
X	return (ret_code);
}
X
X
int append_to_existing_file (i)
X	int i;
{
X	char buf[LEN];
X	char *file;
X	struct stat st;
X
X	if (! save[i].is_mailbox && save_separate) {
X		file = save_filename (i);
X		if (stat(file, &st) != -1) {	
X			sprintf (buf, txt_append_to_file, file); 
X			if (! prompt_yn (LINES, buf, 'n')) {
X				if (file != (char *) 0) {
X					free (file);
X					file = (char *) 0;
X				}
X				return FALSE;
X			}
X		}
X		if (file != (char *) 0) {
X			free (file);
X			file = (char *) 0;
X		}
X	}
X	
X	return TRUE;
}
X
X
int create_path (path)
X	char *path;
{
X	char buf[LEN];
X	char group[LEN];
X	char *env;
X	int i, j, len;
X	struct stat st;
X	
X	/*
X	 * save in mailbox format to ~/Mail/<group.name>
SHAR_EOF
true || echo 'restore of save.c failed'
fi
echo 'End of tin1.1 part 8'
echo 'File save.c is continued in part 9'
echo 9 > _shar_seq_.tmp
exit 0

--
NAME   Iain Lea
EMAIL  iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE
SNAIL  Bruecken Strasse 12, 8500 Nuernberg 90, Germany
PHONE  +49-911-331963 (home)  +49-911-3089-407 (work)
-- 
 Dr. med. dipl.-math Dieter Becker           Tel.: (0 / +49) 6841 - 16 3046
 Medizinische Universitaets- und Poliklinik  Fax.: (0 / +49) 6841 - 16 3369
 Innere Medizin III                         
 D - 6650 Homburg / Saar                     Email: becker@med-in.uni-sb.de
exit 0 # Just in case...
