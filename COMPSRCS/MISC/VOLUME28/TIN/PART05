Newsgroups: comp.sources.misc
From: iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE (Iain Lea)
Subject:  v28i049:  tin - threaded full screen newsreader v1.1, Part05/11
Message-ID: <1992Feb18.043724.13083@sparky.imd.sterling.com>
X-Md4-Signature: ab1fe184547579d29e9003e091f7674a
Date: Tue, 18 Feb 1992 04:37:24 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE (Iain Lea)
Posting-number: Volume 28, Issue 49
Archive-name: tin/part05
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 23, Issue 15-23

#!/bin/sh
# this is tin.shar.05 (part 5 of tin1.1)
# do not concatenate these parts, unpack them in order with /bin/sh
# file help.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping help.c'
else
echo 'x - continuing file help.c'
sed 's/^X//' << 'SHAR_EOF' >> 'help.c' &&
X				}
X			}
X		}
X
X		if (cur_page != old_page) {
X			center_line (LINES, FALSE, txt_hit_space_for_more);
X		}
X
X		old_page = cur_page;
X		
X		ch = (char) ReadCh ();
X		switch (ch) {
X			case ESC:	/* common arrow keys */
X				switch (get_arrow_key ()) {
X					case KEYMAP_UP:
X					case KEYMAP_PAGE_UP:
X						if (cur_page > 1) {
X							cur_page--;
X							pos_help = (cur_page-1)*NOTESLINES;
X						}
X						break;
X
X					case KEYMAP_DOWN:
X					case KEYMAP_PAGE_DOWN:
X						if (cur_page < max_page) {
X							pos_help = cur_page*NOTESLINES;
X							cur_page++;
X						}
X						break;
X
X					case KEYMAP_HOME:
X						if (cur_page != 1) {
X							cur_page = 1;
X							pos_help = 0;
X						}
X						break;
X					
X					case KEYMAP_END:
X						if (cur_page != max_page) {
X							cur_page = max_page;
X							pos_help = (max_page-1) * NOTESLINES;
X						}
X						break;
X				}
X				break;
X
X			case ctrl('D'):			/* page down */
X			case ' ':
X				if (cur_page < max_page) {
X					pos_help = cur_page*NOTESLINES;
X					cur_page++;
X				}
X				break;
X			
X			case ctrl('U'):			/* page up */
X			case 'b':
X				if (cur_page > 1) {
X					cur_page--;
X					pos_help = (cur_page-1)*NOTESLINES;
X				}
X				break;
X
X			case ctrl('R'):			/* Home */
X			case 'g':
X				if (cur_page != 1) {
X					cur_page = 1;
X					pos_help = 0;
X				}
X				break;
X
X			case '$':				/* End */
X			case 'G':
X				if (cur_page != max_page) {
X					cur_page = max_page;
X					pos_help = (max_page-1) * NOTESLINES;
X				}
X				break;
X
X			default:
#ifndef USE_CLEARSCREEN
X				ClearScreen ();
#endif	
X				return;
X		}	
X	}
}
SHAR_EOF
echo 'File help.c is complete' &&
chmod 0600 help.c ||
echo 'restore of help.c failed'
Wc_c="`wc -c < 'help.c'`"
test 5206 -eq "$Wc_c" ||
	echo 'help.c: original size 5206, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= init.c ==============
if test -f 'init.c' -a X"$1" != X"-c"; then
	echo 'x - skipping init.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting init.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'init.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : init.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 04-02-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
X
char rcdir[LEN];
char rcfile[LEN];
char indexdir[LEN];
char killfile[LEN];
char postfile[LEN];
char unthreadfile[LEN];
X
char active_file[LEN];
char homedir[LEN];
char userid[LEN];
char delgroups[LEN];
char newsrc[LEN];
char newnewsrc[LEN];
char add_addr[LEN];			/* address to add to rR reply to author with mail */
char bug_addr[LEN];			/* address to add send bug reports to */
char txt_help_bug_report[LEN];	/* address to add send bug reports to */
char reply_to[LEN];			/* reply-to address */
char my_org[LEN];			/* organization */
char sig[LEN];
char signature[LEN];
char default_shell_command[LEN];	/* offers user default choice */
char killsubj[LEN];			/* contains Subject:'s not to be shown */
char killfrom[LEN];			/* conatins From:'s not to be shown */
char page_header[LEN];		/* page header of pgm name and version */
char savedir[LEN];			/* directory to save articles to */
char spooldir[LEN];			/* directory where new is */
char mail_news_user[LEN];	/* mail new news to this user address */
char mailer[LEN];			/* mail program */
char maildir[LEN];			/* mailbox dir where = saves are stored */
char mailbox[LEN];			/* system mailbox for each user */
char printer[LEN];			/* printer program specified from tinrc */
char cmd_line_printer[LEN];	/* printer program specified on cmd line */
char article[LEN];			/* ~/.article file */
char dead_article[LEN];		/* ~/dead.article file */
char progname[LEN];			/* program name */
char redirect_output[LEN];	/* /dev/null or nothing if -D option */
int catchup_read_groups;	/* ask if read groups are to be marked read */
int cmd_line;				/* batch / interactive mode */
int created_rcdir;			/* checks if first time tin is started */
int default_printer;		/* set to false if user give a printer with -p switch */
int default_show_author;	/* show_author value from 'M' menu in tinrc */
int draw_arrow_mark;		/* draw -> or highlighted bar */
int full_page_scroll;		/* page half/full screen of articles/groups */
int kill_articles;			/* kill articles matching kill file contents */
int mark_saved_read;		/* mark saved article/thread as read */
int num_of_killed_files;
int num_of_tagged_files;
int pos_first_unread;		/* position cursor at first/last unread article */
int post_proc_type;			/* type of post processing to be performed */
int print_header;			/* print all of mail header or just Subject: & From lines */
int save_archive_name;		/* save thread with name from Archive-name: field */
int mail_news;				/* mail all arts to specified user */
int save_news;				/* save all arts to savedir structure */
int save_separate;			/* save a each part of a thread to a separate file */
int show_author;			/* show Subject & From or only Subject in group menu */
int show_only_unread;		/* show only new/unread arts or all arts */
int sort_art_type;			/* sort arts[] array by subject,from or date field */
int thread_arts;			/* thread/unthread articles for viewing */
struct passwd *myentry;
X
/*
X * init_selfinfo
X *   Deterimines users home directory, userid, and a path
X *   for an rc file in the home directory
X */
X
void init_selfinfo ()
{
X	extern char *getenv ();
X	extern char *getlogin ();
X	extern struct passwd *getpwuid ();
X	extern struct passwd *getpwnam ();
X	char nam[LEN];
X	char *p;
X	FILE *fp;
X	struct stat sb;
X
X	myentry = (struct passwd *) 0;
X	if ((p = getlogin ()) != (char *) 0) {
X		myentry = getpwnam (p);
X	} else {
X		myentry = getpwuid (getuid ());
X	}
X
X	strcpy (userid, myentry->pw_name);
X
X	if ((p = getenv ("HOME")) != NULL) {
X		strcpy (homedir, p);
X	} else {
X		strcpy (homedir, myentry->pw_dir);
X	}
X
X	catchup_read_groups = TRUE;
X	created_rcdir = FALSE;
#ifdef USE_INVERSE_HACK
X	draw_arrow_mark = TRUE;
#else
X	draw_arrow_mark = FALSE;
#endif
#ifdef BSD
X	default_printer = TRUE;
#else	
X	default_printer = FALSE;
#endif
X	full_page_scroll = TRUE;
X	kill_articles = FALSE;
X	mark_saved_read = TRUE;
X	num_of_killed_files = 0;
X	num_of_tagged_files = 0;
X	post_proc_type = POST_PROC_NONE;
X	pos_first_unread = TRUE;
X	print_header = FALSE;
X	save_separate = TRUE;
X	save_archive_name = TRUE;
X	default_show_author = SHOW_FROM_NAME;
X	show_only_unread = FALSE;
X	sort_art_type = SORT_BY_NOTHING;
X	save_news = FALSE;
X	thread_arts = TRUE;
X	
X	killsubj[0] = '\0';
X	killfrom[0] = '\0';
X	
X	nntp_server[0] = '\0';
X	author_search_string[0] = '\0';
X	group_search_string[0] = '\0';
X	subject_search_string[0] = '\0';
X	art_search_string[0] = '\0';
X	default_mail_address[0] = '\0';
X	default_regex_pattern[0] = '\0';
X	default_save_file[0] = '\0';
X	default_shell_command[0] = '\0';
X	default_post_subject[0] = '\0';
X	cmd_line_printer[0] = '\0';
X	
X	sprintf (rcdir,  "%s/%s", get_val ("TINDIR", homedir), RCDIR);
X	sprintf (indexdir, "%s/%s", rcdir, INDEXDIR);
X	sprintf (rcfile,   "%s/%s", rcdir, RCFILE);
X	sprintf (killfile, "%s/%s", rcdir, KILLFILE);
X	sprintf (postfile, "%s/%s", rcdir, POSTFILE);
X	sprintf (unthreadfile, "%s/%s", rcdir, UNTHREADFILE);
X
X	sprintf (signature, "%s/.signature", homedir);
X	sprintf (sig, "%s/.Sig", homedir);
X	sprintf (newsrc, "%s/.newsrc", homedir);
X	sprintf (newnewsrc, "%s/.newnewsrc", homedir);
X	sprintf (delgroups, "%s/.delgroups", homedir);
X	sprintf (active_file, "%s/active", LIBDIR);
X	sprintf (savedir, "%s/News", homedir);
X	sprintf (maildir, "%s/%s", homedir, DEFAULT_MAILDIR);
X	sprintf (mailbox, "%s/%s", DEFAULT_MAILBOX, userid);
X	sprintf (dead_article, "%s/dead.article", homedir);
X	sprintf (article, "%s/.article", homedir);
X
X	strcpy (mailer, DEFAULT_MAILER);
X	strcpy (printer, DEFAULT_PRINTER);
X	strcpy (spooldir, SPOOLDIR);
X	strcpy (bug_addr, BUG_REPORT_ADDRESS);
X	strcpy (redirect_output, "> /dev/null 2>&1");
X
X	set_real_uid_gid ();
X	
X	if (stat (rcdir, &sb) == -1) {
X		created_rcdir = TRUE;
X		mkdir (rcdir, 0755);
X	}
X	if (stat (indexdir, &sb) == -1) {
X		mkdir (indexdir, 0755);
X	}
X	if (stat (postfile, &sb) == -1) {
X		if ((fp = fopen (postfile, "w")) != NULL) {
X			fclose (fp);
X		}
X	}
X	if (stat (unthreadfile, &sb) == -1) {
X		if ((fp = fopen (unthreadfile, "w")) != NULL) {
X			fclose (fp);
X		}
X	}
X
X	read_rcfile ();
X
X	show_author = default_show_author;
X
X	if (stat (savedir, &sb) == -1) {
X		mkdir (savedir, 0755);
X	}
X	if (stat (maildir, &sb) == -1) {
X		mkdir (maildir, 0755);
X	}
X	if (stat (active_file, &sb) >= 0)
X		goto got_active;
X
/*
X *  I hate forgetting to define LIBDIR correctly.  Guess a
X *  couple of likely places if it's not where LIBDIR says it is.
X */
X
X	strcpy (active_file, "/usr/lib/news/active");
X	if (stat (active_file, &sb) >= 0)
X		goto got_active;
X
X	strcpy (active_file, "/usr/local/lib/news/active");
X	if (stat (active_file, &sb) >= 0)
X		goto got_active;
X
X	strcpy (active_file, "/usr/public/lib/news/active");
X	if (stat (active_file, &sb) >= 0)
X		goto got_active;
X
/*
X *  Oh well. Revert to what LIBDIR says it is to produce a
X *  useful error message when read_active () fails later.
X */
X
X	sprintf (active_file, "%s/active", LIBDIR);
X
got_active:
X
/*
X *  check enviroment for organization
X */
X	my_org[0] = '\0';
X	if ((p = getenv ("ORGANIZATION")) != NULL) {
X		my_strncpy (my_org, p, LEN);
X		goto got_org;
X	}
X
/*
X *  check ~/.org for organization
X */
X	sprintf (nam, "%s/organization", rcdir);
X	fp = fopen (nam, "r");
X
/*
X *  check LIBDIR/organization for system wide organization
X */
X	if (fp == NULL) {
X		sprintf (nam, "%s/organization", LIBDIR);
X		fp = fopen (nam, "r");
X	}
X
X	if (fp == NULL) {
X		sprintf (nam, "/usr/lib/news/organization");
X		fp = fopen (nam, "r");
X	}
X
X	if (fp == NULL) {
X		sprintf (nam, "/usr/local/lib/news/organization");
X		fp = fopen (nam, "r");
X	}
X
X	if (fp == NULL) {
X		sprintf (nam, "/usr/public/lib/news/organization");
X		fp = fopen (nam, "r");
X	}
X
X	if (fp == NULL) {
X		sprintf (nam, "/etc/organization");
X		fp = fopen (nam, "r");
X	}
X
X	if (fp != NULL) {
X		if (fgets (my_org, sizeof (my_org), fp) != NULL) {
X			for (p = my_org; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X		}
X		fclose (fp);
X	}
X
got_org:;
X
/*
X *  check enviroment for REPLYTO
X */
X	reply_to[0] = '\0';
X	if ((p = getenv ("REPLYTO")) != NULL) {
X		my_strncpy (reply_to, p, LEN);
X		goto got_reply;
X	}
X
X	sprintf (nam, "%s/replyto", rcdir);
X	if ((fp = fopen (nam, "r")) != NULL) {
X		if (fgets (reply_to, sizeof (reply_to), fp) != NULL) {
X			for (p = reply_to; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X		}
X		fclose (fp);
X	}
X
got_reply:;
X
/*
X *  check enviroment for ADD_ADDRESS
X */
X	add_addr[0] = '\0';
X	if ((p = getenv ("ADD_ADDRESS")) != NULL) {
X		my_strncpy (add_addr, p, LEN);
X		goto got_add_addr;
X	}
X
X	sprintf (nam, "%s/add_address", rcdir);
X	if ((fp = fopen (nam, "r")) != NULL) {
X		if (fgets (add_addr, sizeof (add_addr), fp) != NULL) {
X			for (p = add_addr; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X		}
X		fclose (fp);
X	}
X
got_add_addr:;
X
/*
X *  check enviroment for BUG_ADDRESS
X */
X	if ((p = getenv ("BUG_ADDRESS")) != NULL) {
X		my_strncpy (bug_addr, p, LEN);
X		goto got_bug_addr;
X	}
X
X	sprintf (nam, "%s/bug_address", rcdir);
X	if ((fp = fopen (nam, "r")) != NULL) {
X		if (fgets (bug_addr, sizeof (bug_addr), fp) != NULL) {
X			for (p = bug_addr; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X		}
X		fclose (fp);
X	}
X
got_bug_addr:;
X	sprintf (txt_help_bug_report, txt_help_bug, bug_addr);
X
X	set_tin_uid_gid ();
}
SHAR_EOF
chmod 0600 init.c ||
echo 'restore of init.c failed'
Wc_c="`wc -c < 'init.c'`"
test 9634 -eq "$Wc_c" ||
	echo 'init.c: original size 9634, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= kill.c ==============
if test -f 'kill.c' -a X"$1" != X"-c"; then
	echo 'x - skipping kill.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting kill.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'kill.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : kill.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 31-01-92
X *  Notes     : kill articles
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
extern char index_file[LEN];
X
struct kill_t *killf;
int kill_num = 0;
int max_kill;
X
/*
X *  read_kill_file - read ~/.tin/kill file contents into kill array
X */
X
int read_kill_file ()
{
X	char buf[LEN];
X	FILE *fp;
X
X	free_kill_array ();
X	
X	set_real_uid_gid ();
X
X	if ((fp = fopen (killfile, "r")) != NULL) {
X		kill_num=0;
X		while (fgets (buf, sizeof buf, fp) != NULL) {
X			if (buf[0] != '#') {
X				if (kill_num == max_kill-1) {
X					expand_kill ();
X				}
X				killf[kill_num].kill_type = (int) atoi (buf);
X				if (fgets (buf, sizeof buf, fp) != NULL) {
X					killf[kill_num].kill_group = (long) atol (buf);
X				} else {	
X					goto corrupt_killfile;
X				}	
X				switch (killf[kill_num].kill_type) {
X					case KILL_SUBJ:
X						if (fgets (buf, sizeof buf, fp) != NULL) {
X							buf[strlen (buf)-1] = '\0';
X							killf[kill_num].kill_subj = str_dup (buf);
X						}
X						break;
X					case KILL_FROM:
X						if (fgets (buf, sizeof buf, fp) != NULL) {
X							buf[strlen (buf)-1] = '\0';
X							killf[kill_num].kill_from = str_dup (buf);
X						}
X						break;
X					case KILL_BOTH:
X						if (fgets (buf, sizeof buf, fp) != NULL) {
X							buf[strlen (buf)-1] = '\0';
X							killf[kill_num].kill_subj = str_dup (buf);
X						}
X						if (fgets (buf, sizeof buf, fp) != NULL) {
X							buf[strlen (buf)-1] = '\0';
X							killf[kill_num].kill_from = str_dup (buf);
X						}
X						break;
X					default:
X						goto corrupt_killfile;
X				}
X				kill_num++;
X			}
X		}
X		fclose (fp);
X		set_tin_uid_gid ();
X		return TRUE;		
X	} else {
X		set_tin_uid_gid ();
X		return FALSE;
X	}
X
corrupt_killfile:
X	fclose (fp);
X	killf[kill_num].kill_type = 0;
X	error_message ("corrupt kill file %s", killfile);
X	set_tin_uid_gid ();
X	return FALSE;
}
X
/*
X *  write_kill_file - write kill strings to ~/.tin/kill
X */
X
void write_kill_file ()
{
X	FILE *fp;
X	int i;
X	
X	set_real_uid_gid ();
X
X	if (kill_num && (fp = fopen (killfile, "w")) != NULL) {
X		wait_message (txt_saving);
X		fprintf (fp, "# 1st line  1=(Subject: only)  2=(From: only)  3=(Subject: & From:)\n");
X		fprintf (fp, "# 2nd line  0=(kill on all newsgroups)  >0=(kill on specific newsgroup)\n");
X		for (i=0 ; i < kill_num ; i++) {
X			if (killf[i].kill_type && (killf[i].kill_subj || killf[i].kill_from)) {
X				fprintf (fp, "#\n# kill description %d\n", i+1);
X				fprintf (fp, "%d\n", killf[i].kill_type);
X				fprintf (fp, "%ld\n", killf[i].kill_group);
X				switch (killf[i].kill_type) {
X					case KILL_SUBJ:
X						fprintf (fp, "%s\n", killf[i].kill_subj);
X						break;
X					case KILL_FROM:
X						fprintf (fp, "%s\n", killf[i].kill_from);
X						break;
X					case KILL_BOTH:
X						fprintf (fp, "%s\n", killf[i].kill_subj);
X						fprintf (fp, "%s\n", killf[i].kill_from);
X						break;
X				}
X			}
X		}
X		fclose (fp);
X		chmod (killfile, 0600);
X	}
X	set_tin_uid_gid ();
}
X
/*
X *  options menu so that the user can dynamically change parameters
X */
X 
int kill_art_menu (group_name, index)
X	char *group_name;
X	int index;
{
X	char text[LEN];
X	char kill_from[LEN];
X	char kill_subj[LEN];
X	char kill_group[LEN];
X	char ch_default = 's';
X	char *str;	
X	int ch;
X	int counter;
X	int killed = TRUE;
X	int kill_from_ok = FALSE;
X	int kill_subj_ok = FALSE;
X	int kill_every_group;
X
#ifdef SIGTSTP
X	SIGTYPE (*susp)();
X
X	if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X		sigemptyset (&kill_act.sa_mask);
X		kill_act.sa_flags = SA_RESTART | SA_RESETHAND;
X		kill_act.sa_handler = SIG_DFL;
X		sigaction (SIGTSTP, &kill_act, &old_act);
X		kill_act.sa_handler = SIG_IGN;
X		sigaction (SIGTSTP, &kill_act, 0L);
#else
X		susp = signal (SIGTSTP, SIG_DFL);
X		signal (SIGTSTP, SIG_IGN);
#endif
X	}
#endif
X	
X	sprintf (kill_group, "%s only", group_name);
X	my_strncpy (text, arts[index].subject, COLS-35);
X	sprintf (kill_subj, txt_kill_subject, text);
X	if (arts[index].name != (char *) 0) {
X		sprintf (msg, "%s (%s)", arts[index].from, arts[index].name);
X		my_strncpy (text, msg, COLS-35);
X	} else {
X		my_strncpy (text, arts[index].from, COLS-35);
X	}
X	sprintf (kill_from, txt_kill_from, text);
X	text[0] = '\0';
X	
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_kill_menu);
X	
X	MoveCursor(INDEX_TOP, 0);
X	printf ("%s\r\n\r\n", txt_kill_text);
X	printf ("%s\r\n\r\n\r\n", txt_kill_text_type);
X	printf ("%s\r\n\r\n", kill_subj);
X	printf ("%s\r\n\r\n\r\n", kill_from);
X	printf ("%s%s", txt_kill_group, kill_group);
X	fflush(stdout);
X
X	show_menu_help (txt_help_kill_text);
X	if (! prompt_menu_string (INDEX_TOP, (int) strlen (txt_kill_text), text)) {
X		return FALSE;
X	}
X
X	if (text[0]) {
X		show_menu_help (txt_help_kill_text_type);
X		counter = 1;
X		MoveCursor (INDEX_TOP+2, (int) strlen (txt_kill_text_type));
X		str = "Subject: line only    ";
X		printf ("%s", str);
X		fflush(stdout);
X		do {
X			MoveCursor (INDEX_TOP+2, (int) strlen (txt_kill_text_type));
X			if ((ch	= ReadCh()) == ' ') {
X				counter++;
X				if (counter == KILL_BOTH+1) {
X					counter = KILL_SUBJ;
X				}
X				switch (counter) {
X					case KILL_SUBJ:
X						str = "Subject: line only    ";
X						break;
X					case KILL_FROM:
X						str = "From: line only       ";
X						break;
X					case KILL_BOTH:
X						str = "Subject: & From: lines";
X						break;
X				}
X				printf ("%s", str);
X				fflush(stdout);
X			}
X		} while (ch != CR && ch != ESC);
X		if (ch == ESC) {
X			return FALSE;
X		}
X	}
X
X	if (! text[0]) {
X		show_menu_help (txt_help_kill_subject);
X		kill_subj_ok = prompt_yn (INDEX_TOP+5, kill_subj, 'y');
X
X		show_menu_help (txt_help_kill_from);
X		kill_from_ok = prompt_yn (INDEX_TOP+7, kill_from, 'n');
X	}
X
X	if (text[0] || kill_subj_ok || kill_from_ok) {
X		show_menu_help (txt_help_kill_group);
X		kill_every_group = FALSE;
X		MoveCursor (INDEX_TOP+10, (int) strlen (txt_kill_group));
X		str = kill_group;
X		printf ("%s", str);
X		fflush (stdout);
X		do {
X			MoveCursor (INDEX_TOP+10, (int) strlen (txt_kill_group));
X			if ((ch	= ReadCh()) == ' ') {
X				kill_every_group = !kill_every_group;
X				if (kill_every_group) {
X					str = "All groups";
X				} else {
X					str = kill_group;
X				}
X				CleartoEOLN (); 
X				printf ("%s", str);
X				fflush(stdout);
X			}
X		} while (ch != CR && ch != ESC);
X		if (ch == ESC) {
X			return FALSE;
X		}
X	}
X
X	while (1) {
X		do {
X			sprintf (msg, "%s%c", txt_abort_edit_save_killfile, ch_default);
X			wait_message (msg);
X			MoveCursor(LINES, (int) strlen (txt_abort_edit_save_killfile));
X			if ((ch = ReadCh()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'a' && ch != 'e' && ch != 's');
X		switch (ch) {
X			case 'e':
X				start_line_offset = 2;
X				invoke_editor (killfile);
X				unkill_all_articles ();
X				read_kill_file ();
X				reload_index_file (group_name, FALSE);
X				killed = TRUE;
X				goto kill_done;
X
X			case 'a':
X			case ESC:
X				killed = FALSE;
X				goto kill_done;
X			
X			case 's':
X				if (kill_num > max_kill-1) {
X					expand_kill ();
X				}
X				if (text[0]) {
X					switch (counter) {
X						case KILL_SUBJ:
X							killf[kill_num].kill_subj = str_dup (text);
X							break;
X						case KILL_FROM:
X							killf[kill_num].kill_from = str_dup (text);
X							break;
X						case KILL_BOTH:
X							killf[kill_num].kill_subj = str_dup (text);
X							killf[kill_num].kill_from = str_dup (text);
X							break;
X					}
X					killf[kill_num].kill_type = counter;
X					if (kill_every_group) {
X						killf[kill_num].kill_group= 0L;
X					} else {
X						killf[kill_num].kill_group= hash_s (group_name);
X					}
X					kill_num++;
X				} else {
X					if (kill_subj_ok) {
X						killf[kill_num].kill_type = KILL_SUBJ;
X						killf[kill_num].kill_subj = str_dup (arts[index].subject);
X					}
X					if (kill_from_ok) {
X						killf[kill_num].kill_type |= KILL_FROM;
X						if (arts[index].name != (char *) 0) {
X							sprintf (msg, "%s (%s)", arts[index].from, arts[index].name);
X						} else {
X							strcpy (msg, arts[index].from);
X						}
X						killf[kill_num].kill_from = str_dup (msg);
X					}
X					if (killf[kill_num].kill_type) {		
X						if (kill_every_group) {
X							killf[kill_num].kill_group= 0L;
X						} else {
X							killf[kill_num].kill_group= hash_s (group_name);
X						}
X						kill_num++;
X					}
X				}
X				write_kill_file ();
X
kill_done:
X
#ifdef SIGTSTP
X				if (do_sigtstp) {
#ifdef POSIX_JOB_CONTROL
X					sigemptyset (&kill_act.sa_mask);
X					kill_act.sa_flags = SA_RESTART | SA_RESETHAND;
X					kill_act.sa_handler = SIG_IGN;
X					sigaction (SIGTSTP, &old_act, 0L);
#else
X					signal (SIGTSTP, susp);
#endif
X				}
#endif
X				return (killed);
X		}	
X	}
X	/* NOTREACHED */
}
X
X
int unkill_all_articles ()
{
X	int unkilled = FALSE;
X	register int i;
X
X	for (i=0 ; i < top ; i++) {
X		if (arts[i].killed) {
X			arts[i].killed = FALSE;
X			unkilled = TRUE;
X		}
X	}
X	num_of_killed_files = 0;
X
X	return (unkilled);
}
X
X
int kill_any_articles (group)
X	char *group;
{
X	int killed = FALSE;
X	int run_ok = FALSE;
X	long group_hash;
X	register int i, j;
X
X	if (! kill_articles) {
X		return killed;
X	}
X
X	if (kill_num) {
X		group_hash = hash_s (group);
X		for (i=0 ; i < kill_num ; i++) {
X				if (killf[i].kill_group == 0L ||
X					killf[i].kill_group == group_hash) {
X					run_ok = TRUE;	
X				}
X		}
X		if (! run_ok) {
X			return (killed);
X		}
X		if (debug && ! update) {
X			wait_message (txt_killing_arts);
X		}
X		for (i=0 ; i < top ; i++) {
X			for (j=0 ; j < kill_num && ! arts[i].tagged ; j++) {
X				if (killf[j].kill_group == 0L ||
X					killf[j].kill_group == group_hash) {
X					switch (killf[j].kill_type) {
X						case KILL_SUBJ:
#ifdef NO_REGEX 
X							if (str_str (arts[i].subject, killf[j].kill_subj,
X										strlen (killf[j].kill_subj)) != 0) {
#else		
X							if (wildmat (arts[i].subject, killf[j].kill_subj)) {
#endif		
X
X								arts[i].tagged = TRUE;
X								killed = TRUE;
X							}
X							break;
X						case KILL_FROM:
X							if (arts[i].name != (char *) 0) {
X								sprintf (msg, "%s (%s)", arts[i].from, arts[i].name);
X							} else {
X								strcpy (msg, arts[i].from);
X							}
#ifdef NO_REGEX 
X							if (str_str (msg, killf[j].kill_from
X										strlen (killf[j].kill_from)) != 0) {
#else		
X							if (wildmat (msg, killf[j].kill_from)) {
#endif		
X								arts[i].tagged = TRUE;
X								killed = TRUE;
X							}
X							break;
X						case KILL_BOTH:
#ifdef NO_REGEX 
X							if (str_str (arts[i].subject, killf[j].kill_subj,
X										strlen (killf[j].kill_subj)) != 0) {
#else		
X							if (wildmat (arts[i].subject, killf[j].kill_subj)) {
#endif		
X								arts[i].tagged = TRUE;
X								killed = TRUE;
X							}
X							if (arts[i].name != (char *) 0) {
X								sprintf (msg, "%s (%s)", arts[i].from, arts[i].name);
X							} else {
X								strcpy (msg, arts[i].from);
X							}
#ifdef NO_REGEX
X							if (str_str (msg, killf[j].kill_from,
X										strlen (killf[j].kill_from)) != 0) {
#else		
X							if (wildmat (msg, killf[j].kill_from)) {
#endif		
X								arts[i].tagged = TRUE;
X								killed = TRUE;
X							}
X							break;
X					}
X				}
X			}
X		}
X	}
X	return (killed);
}
SHAR_EOF
chmod 0600 kill.c ||
echo 'restore of kill.c failed'
Wc_c="`wc -c < 'kill.c'`"
test 11196 -eq "$Wc_c" ||
	echo 'kill.c: original size 11196, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= lang.c ==============
if test -f 'lang.c' -a X"$1" != X"-c"; then
	echo 'x - skipping lang.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting lang.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lang.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : lang.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 08-02-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
/*
X *  art.c
X */
X
char txt_group[] = "Group %s...";
char txt_cannot_open_art[] = "can't open article %s: ";
char txt_indexing[] = "Indexing %s...";
char txt_indexing_num[] = "Indexing %s...%4d";
char txt_corrupt_index[] = "Index file %s corrupted. error %d on article %d";
char txt_checking_for_news[] = "Checking for news...";
char txt_there_is_no_news[] = "There is no news\n";
char txt_killing_arts[] = "Killing articles...";
char txt_unkilling_arts[] = "Unkilling articles...";
X
/*
X *  feed.c
X */
X
char txt_art_thread_regex_tag[] = " a)rticle, t)hread, r)egex pattern, T)agged articles, e)xit: ";
char txt_post_process_type[] = "Process n)one, s)har, u)udecode, U)udecode & zoo: ";
#ifdef NO_REGEX 
char txt_feed_pattern[] = "Enter pattern [%s]> ";
#else
char txt_feed_pattern[] = "Enter regex pattern [%s]> ";
#endif
char txt_no_command[] = "No command";
char txt_piping[] = "Piping...";
X
/*
X *  group.c
X */
X
char txt_cannot_post[] = "*** Posting not allowed ***";
char txt_tagged_art[] = "tagged article";
char txt_untagged_art[] = "untagged article";
char txt_inverse_on[] = "Inverse video enabled";
char txt_inverse_off[] = "Inverse video disabled";
char txt_subscribed_to[] = "subscribed to %s";
char txt_unsubscribed_to[] = "unsubscribed from %s";
char txt_mark_all_read[] = "Mark everything as read? (y/n): ";
char txt_no_more_groups[] = "No more groups";
char txt_no_prev_group[] = "No previous group";
char txt_no_arts[] = "*** No Articles ***";
char txt_no_groups[] = "*** No Groups ***";
char txt_end_of_thread[] = "*** End of Thread ***";
char txt_end_of_arts[] = "*** End of Articles ***";
char txt_end_of_groups[] = "*** End of Groups ***";
char txt_no_next_unread_art[] = "No next unread article";
char txt_no_prev_unread_art[] = "No previous unread article";
char txt_no_last_message[] = "No last message";
char txt_bad_command[] = "Bad command.  Type 'h' for help.";
char txt_you_have_mail[] = "    You have mail\n";
/*
char txt_type_h_for_help[] = "Type 'h' for help\n";
*/
char txt_type_h_for_help[] = "           h=help\n";
char txt_read_art[] = "Read article> ";
char txt_search_forwards[] = "Search forwards [%s]> ";
char txt_search_backwards[] = "Search backwards [%s]> ";
char txt_author_search_forwards[] = "Author search forwards [%s]> ";
char txt_author_search_backwards[] = "Author search backwards [%s]> ";
char txt_no_search_string[] = "No search string";
char txt_no_match[] = "No match";
char txt_post_subject[] = "Post Subject [%s]> ";
char txt_no_subject[] = "No subject";
char txt_cannot_open[] = "can't open %s";
char txt_posting[] = "Posting...";
char txt_art_posted[] = "-- Article posted --";
char txt_art_rejected[] = "-- Article rejected (saved to %s) --";
char txt_abort_edit_post[] = "a)bort, e)dit, p)ost: ";
char txt_help_i_4[] = "4$       Goto article 4 ($=goto last article)\r\n";
char txt_help_ctrl_k[] = "^K       Kill current article\r\n";
char txt_help_ctrl_l[] = "^L       Redraw page\r\n";
char txt_help_ctrl_d[] = "^D^U     Down (^U=up) a page\r\n";
char txt_help_i_cr[] = "<CR>     Read current article\r\n";
char txt_help_i_tab[] = "<TAB>    Goto next unread article or group\r\n";
char txt_help_d[] = "d        Toggle display of subject only & subject/author\r\n";
char txt_help_l[] = "l        List articles within current thread\r\n";
char txt_help_m[] = "m        Move current group within group selection list\r\n";
char txt_help_M[] = "M        Menu of configurable options\r\n";
char txt_help_a[] = "aA       Author forward (A=backward) search\r\n";
char txt_help_sel_c[] = "cC       Mark group read (C=and goto next unread group)\r\n";
char txt_help_c[] = "c        Mark all articles as read and goto group selection menu\r\n";
char txt_help_g[] = "g        Choose a new group by name\r\n";
char txt_help_I[] = "I        Toggle inverse video\r\n";
char txt_help_K[] = "K        Mark article/thread as read & goto next unread\r\n";
char txt_help_j[] = "jk       Down (k=up) a line\r\n";
char txt_help_i_n[] = "np       Goto next (p=previous) group\r\n";
char txt_help_i_p[] = "NP       Goto next (P=previous) unread article\r\n";
char txt_help_q[] = "q        Quit\r\n";
char txt_help_s[] = "su       Subscribe (u=unsubscribe) to current group\r\n";
char txt_help_S[] = "SU       Subscribe (U=unsubscribe) to groups that match pattern\r\n";
char txt_help_t[] = "t        Return to group selection index\r\n";
char txt_help_T[] = "T        Tag current article for mailing/piping/printing/saving\r\n";
char txt_help_u[] = "u        toggle display of unthreaded & threaded articles\r\n";
char txt_help_U[] = "U        Untag all tagged articles\r\n";
char txt_help_v[] = "v        Show version information\r\n";
char txt_help_w[] = "w        Post an article to current group\r\n";
char txt_help_i_search[] = "/?       Subject forward (?=backward) search\r\n";
char txt_help_thread[] = "<>       Goto first (>=last) article in current thread";
#ifndef NO_SHELL_ESCAPE
char txt_help_shell[] = "!        Shell escape\r\n";
#endif
char txt_help_dash[] = "-        Show last message\r\n";
#ifdef NO_REGEX 
char txt_save_pattern[] = "Enter save pattern [%s]> ";
#else
char txt_save_pattern[] = "Enter regex save pattern [%s]> ";
#endif
char txt_saved_pattern_to[] = "-- Saved pattern to %s - %s --";
char txt_saved_to_mailbox[] = "-- Saved to mailbox %s --";
char txt_switch_on_kill_art_menu[] = "Kill Article Menu is switched OFF. Select Options Menu to switch it ON.";
X
/* 
X *  help.c:
X */
X
char txt_group_select_com[] = "Group Selection Commands (page %d of %d)";
char txt_index_page_com[] = "Index Page Commands (page %d of %d)";
char txt_thread_com[] = "Thread Commands (page %d of %d)";
char txt_art_pager_com[] = "Article Pager Commands (page %d of %d)";
char txt_hit_space_for_more[] = "PgDn,End,<SPACE>,^D - page down. PgUp,Home,b,^U - page up. <CR>,q - quit";
char txt_post_history_menu[] = "Posted articles history (page %d of %d)";
X
/* 
X *  kill.c:
X */
X
char txt_kill_menu[] = "Kill Article Menu";
char txt_kill_subject[] = "Kill Subject [%-45s] (y/n): ";
char txt_kill_from[] =    "Kill From    [%-45s] (y/n): ";
char txt_kill_text[] = "Kill text pattern : ";
char txt_kill_text_type[] = "Apply pattern to  : ";
char txt_kill_group[] =     "Kill pattern scope: ";
char txt_help_kill_subject[] = "Subject: line to add to kill file. Press backspace key to clear field.";
char txt_help_kill_from[] = "From: line to add to kill file. Press backspace key to clear field.";
char txt_help_kill_text[] = "Enter text pattern to kill if Subject: & From: lines are not what you want.";
char txt_help_kill_text_type[] = "Select where text pattern should be applied. <SPACE> toggles & <CR> sets.";
char txt_help_kill_group[] = "Apply kill to current group only or all groups. <SPACE> toggles & <CR> sets.";
char txt_abort_edit_save_killfile[] = "a)bort e)dit s)ave killfile: ";
X
X
/* 
X *  main.c:
X */
X
char txt_nntp_not_enabled[] = "Reading news via NNTP is not enabled. Recompile %s with -DUSE_NNTP.\n";
char txt_recompile_with_nntp_option[] = "Option not enabled. Recompile %s with -DUSE_NNTP.\n";
char txt_not_in_active_file[] = "Group %s not found in active file";
char txt_screen_init_failed[] = "%s: Screen initialization failed";
char txt_bad_active_file[] = "Active file corrupt - %s";
X
/*
X *  misc.c
X */
X
char txt_reading_active_file[] = "Reading active file...";
char txt_cannot_find_base_art[] = "Cannot find base article %s";
char txt_out_of_memory[] = "%s: out of memory";
char txt_rename_error[] = "Error: rename %s to %s";
char txt_shell_escape[] = "Enter shell command [%s]> ";
X
/*
X *  newsrc.c
X */
X
char txt_creating_newsrc[] = "Creating .newsrc...\n";
X
/*
X *  open.c
X */
X 
char txt_connecting[] = "Connecting to %s...";
char txt_cannot_get_nntp_server_name[] = "Cannot get nntp server name\n";
char txt_server_name_in_file_env_var[] = "Either put the name in the file %s,\nor put it in the environment variable NNTPSERVER\n";
char txt_failed_to_connect_to_server[] = "failed to connect to (%s) server\n";
char txt_rejected_by_nntpserver[] = "rejected by server, nntp error %d\n";
char txt_connection_to_server_broken[] = "connection to server broken\n";
char txt_stuff_nntp_cannot_open[] = "stuff_nntp: can't open %s: ";
char txt_nntp_to_fp_cannot_reopen[] = "nntp_to_fp: can't reopen %s: ";
char txt_nntp_to_fd_cannot_reopen[] = "nntp_to_fd: can't reopen %s: ";
X
/*
X *  page.c
X */
X
char txt_quit[] = "Do you really want to quit? (y/n): ";
char txt_art_unavailable[] = "[Article %ld unvailable]\r\r";
char txt_art_marked_as_unread[] = "Article marked as unread";
char txt_thread_marked_as_unread[] = "Thread marked as unread";
char txt_begin_of_art[] = "*** Beginning of article ***";
char txt_next_resp[] = "-- Next response --";
char txt_last_resp[] = "-- Last response --";
char txt_more[] = "--More--";
char txt_more_percent[] = "--More--(%d%%) [%ld/%ld]";
char txt_thread_x_of_n[] = "%sThread %3d of %3d\r\n";
char txt_art[] = "Article %ld  ";
char txt_resp_x_of_n[] = "Respno %3d of %3d\r\n";
char txt_no_resp[] = "No responses\r\n";
char txt_1_resp[] = "1 Response\r\n";
char txt_x_resp[] = "%d Responses\r\n";
char txt_s_at_s[] = "%s at %s";
char txt_thread_resp_page[] = "Thread %d of %d, Resp %d (page %d):  %s";
char txt_thread_page[] = "Thread %d of %d (page %d):  %s";
char txt_read_resp[] = "Read response> ";
char txt_help_p_0[] = "0        Read the base article in current thread\r\n";
char txt_help_p_4[] = "4        Read response 4 in current thread\r\n";
char txt_help_p_cr[] = "<CR>     Goto to next thread\r\n";
char txt_help_p_tab[] = "<TAB>    Goto next unread article\r\n";
char txt_help_b[] = "b<SPACE> Back (<SPACE>=forward) a page\r\n";
char txt_help_bug[] = "B        Mail bug/comment to %s\r\n";
char txt_help_p_f[] = "fF       Post (F=copy text) a followup\r\n";
char txt_help_C[] = "C        Cancel current article that must have been posted by you\r\n";
char txt_help_ctrl_h[] = "^H       Show articles header\r\n";
char txt_help_h[] =      "h        Command help\r\n";
char txt_help_p_i[] = "i        Return to index page\r\n";
char txt_help_p_k[] = "kK       Mark article (K=thread) as read & advance to next unread\r\n";
char txt_help_p_m[] = "m        Mail article/thread/pattern/tagged articles to someone\r\n";
char txt_help_p_n[] = "nN       Goto to the next (N=unread) article\r\n";
char txt_help_o[] = "o        Output article/thread/pattern/tagged articles to printer\r\n";
char txt_help_p_p[] = "pP       Goto the previous (P=unread) article\r\n";
char txt_help_p_r[] = "rR       Reply through mail (R=copy text) to author\r\n";
char txt_help_p_s[] = "s        Save article/thread/pattern/tagged articles to file\r\n";
char txt_help_p_z[] = "zZ       Mark article (Z=thread) as unread\r\n";
char txt_help_p_ctrl_r[] = "^R$      Redisplay first ($=last) page of article\r\n";
char txt_help_p_g[] = "gG       Goto first (G=last) page of article\r\n";
char txt_help_p_d[] = "d        Toggle rot-13 decoding for current article\r\n";
char txt_help_pipe[] = "|        Pipe article/thread/pattern/tagged articles into command\r\n";
char txt_help_p_search[] = "/        Article forward search\r\n";
char txt_mail_art_to[] = "Mail article to [%s]> ";
char txt_no_mail_address[] = "No mail address";
char txt_abort_edit_send[] = "a)bort, e)dit, s)end";
char txt_abort_edit_cancel[] = "a)bort, e)dit, c)ancel";
char txt_cancelling[] = "Cancelling article...";
char txt_art_cancelled[] = "Article cancelled";
char txt_mailing_to[] = "Mailing to %s...";
char txt_message_sent[] = "-- Article(s) Mailed --";
char txt_command_failed_s[] = "Command failed: %s\n";
char txt_in_art_you_write[] = "In article %s you write:\n";
char txt_resp_to_poster[] = "Responses have been directed to the poster. Post anyway? (y/n): ";
char txt_resp_redirect[] = "Responses have been directed to the following newsgroups";
char txt_continue[] = "Continue? (y/n): ";
char txt_writes[] = "%s writes:\n";
char txt_writes_name[] = "%s (%s) writes:\n";
char txt_save_filename[] = "Save filename [%s]> ";
char txt_art_not_saved[] = "-- Article not saved --";
char txt_no_filename[] = "No filename";
char txt_saving[] = "Saving...";
char txt_art_saved_to[] = "-- Article saved to %s --";
char txt_thread_not_saved[] = "-- Thread not saved --";
char txt_thread_saved_to_many[] = "-- Thread saved to %s - %s --";
char txt_thread_saved_to[] = "-- Thread saved to %s --";
char txt_pipe_to_command[] = "Pipe to command [%s]: ";
char txt_printing[] = "Printing...";
char txt_printed[] = "-- Article(s) printed --";
char txt_append_to_file[] = "File %s exists. Append? (y/n): ";
char txt_toggled_rot13[] = "Toggled rot13 encoding";
X
/*
X *  post.c
X */
X
char txt_no_arts_posted[] = "No articles have been posted";
char txt_post_an_article[] = "Post an article...";
char txt_post_a_followup[] = "Post a followup...";
char txt_mail_bug_report[] = "Mail bug report...";
char txt_reply_to_author[] = "Reply to author...";
X
/*
X *  prompt.c
X */
X
char txt_hit_any_key[] = "-- Press any key to continue --";
X
/*
X *  rcfile.c
X */
X 
char txt_opt_autosave[] = "1. Auto save       : ";
char txt_opt_save_separate[] = "2. Save separate   : ";
char txt_opt_mark_saved_read[] = "3. Mark saved read : ";
char txt_opt_kill_articles[] = "4. Kill articles   : ";
char txt_opt_draw_arrow[] = "5. Draw arrow      : ";
char txt_opt_print_header[] = "6. Print header    : ";
char txt_opt_pos_first_unread[] = "7. Goto 1st unread : ";
char txt_opt_page_scroll[] = "8. Scroll full page: ";
char txt_opt_catchup_groups[] = "9. Catchup on quit : ";
char txt_opt_thread_arts[] =   "10 Thread articles : ";
char txt_opt_show_only_unread[] = "11 Show only unread: ";
char txt_opt_show_author[] = "13 Show author     : ";
char txt_opt_process_type[] = "14 Process type    : ";
char txt_opt_sort_type[] = "15 Sort article by : ";
char txt_opt_savedir[] = "16 Save directory  : ";
char txt_opt_maildir[] = "17 Mail directory  : ";
char txt_opt_printer[] = "18 Printer         : ";
char txt_options_menu[] = "Options Menu";
char txt_show_from_none[] = "None";
char txt_show_from_addr[] = "Addr";
char txt_show_from_name[] = "Name";
char txt_show_from_both[] = "Both";
char txt_post_process_none[] = "None";
char txt_post_process_sh[] = "Shell archive";
char txt_post_process_uudecode[] = "Uudecode";
char txt_post_process_uud_lst_zoo[] = "Uudecode & list zoo archive";
char txt_post_process_uud_ext_zoo[] = "Uudecode & extract zoo archive";
char txt_sort_by_nothing[] = "Nothing";
char txt_sort_by_subj_descend[] = "Subject: field (descending)";
char txt_sort_by_subj_ascend[] = "Subject: field (ascending)";
char txt_sort_by_from_descend[] = "From: field (descending)";
char txt_sort_by_from_ascend[] = "From: field (ascending)";
char txt_sort_by_date_descend[] = "Date: field (descending)";
char txt_sort_by_date_ascend[] = "Date: field (ascending)";
char txt_help_autosave[] = "Auto save article/thread by Archive-name: header. <SPACE> toggles & <CR> sets.";
char txt_help_save_separate[] = "Save articles/threads to separate files. <SPACE> toggles & <CR> sets.";
char txt_help_print_header[] = "By printing print all/part of header. <SPACE> toggles & <CR> sets.";
char txt_help_pos_first_unread[] = "Put cursor at first/last unread art in groups. <SPACE> toggles & <CR> sets.";
char txt_help_show_author[] = "Show Subject & From (author) fields in group menu. <SPACE> toggles & <CR> sets.";
char txt_help_draw_arrow[] = "Draw -> or highlighted bar for selection. <SPACE> toggles & <CR> sets.";
char txt_help_kill_articles[] = "Kill articles that match entries in kill file. <SPACE> toggles & <CR> sets.";
char txt_help_mark_saved_read[] = "Mark saved articles/threads as read. <SPACE> toggles & <CR> sets."; 
char txt_help_page_scroll[] = "Scroll half/full page of groups/articles. <SPACE> toggles & <CR> sets."; 
char txt_help_catchup_groups[] = "Ask to mark groups read when quiting. <SPACE> toggles & <CR> sets."; 
char txt_help_thread_arts[] = "Enable/disable threading of articles in all groups. <SPACE> toggles & <CR> sets."; 
char txt_help_show_only_unread[] = "Show all articles or only unread articles. <SPACE> toggles & <CR> sets."; 
char txt_help_post_proc_type[] = "Post process (ie. unshar) saved article/thread. <SPACE> toggles & <CR> sets."; 
char txt_help_sort_type[] = "Sort articles by Subject, From or Date fields. <SPACE> toggles & <CR> sets.";
char txt_help_savedir[] = "The directory where you want articles/threads saved.";
char txt_help_maildir[] = "The directory where articles/threads are to be saved in mailbox format.";
char txt_help_printer[] = "The printer program with options that is to be used to print articles/threads.";
char txt_select_rcfile_option[] = "Select option by entering number before text. Any other key to save.";
X
/*
X *  save.c
X */
X
char txt_post_processing[] = "Post processing...";
char txt_post_processing_finished[] = "-- post processing completed --";
char txt_deleting[] = "Deleting...";
char txt_uudecoding[] = "Uudecoding...";
X
/*
X *  search.c
X */
X
char txt_searching[] = "Searching...";
X
/*
X *  select.c
X */
X
char txt_moving[] = "Moving...";
#ifdef NO_REGEX
char txt_subscribe_pattern[] = "Enter subscribe pattern> ";
char txt_unsubscribe_pattern[] = "Enter unsubscribe pattern> ";
#else
char txt_subscribe_pattern[] = "Enter regex subscribe pattern> ";
char txt_unsubscribe_pattern[] = "Enter regex unsubscribe pattern> ";
#endif
char txt_subscribing[] = "Subscribing...";
char txt_subscribing_to[] = "Subscribing to %s...";
char txt_unsubscribing[] = "Unsubscribing...";
char txt_unsubscribing_from[] = "Unsubscribing from %s...";
char txt_subscribed_num_groups[] = "subscribed to %d groups";
char txt_unsubscribed_num_groups[] = "unsubscribed from %d groups";
char txt_del_group_in_newsrc[] = "Delete %s from .newsrc? (y/n): ";
char txt_group_deleted[] = "Group %s deleted";
char txt_group_undeleted[] = "Group undeleted";
char txt_mark_group_read[] = "Mark group as read? (y/n): ";
char txt_no_groups_to_delete[] = "No groups to delete";
char txt_reset_newsrc[] = "Reset newsrc? (y/n): ";
char txt_post_newsgroup[] = "Post newsgroup> ";
char txt_yanking_all_groups[] = "Yanking in all groups...";
char txt_yanking_sub_groups[] = "Yanking in subscribed to groups...";
char txt_no_groups_to_read[] = "No more groups to read";
char txt_added_groups[] = "Added %d group%s";
char txt_plural[] = "s";
char txt_no_groups_to_yank_in[] = "No more groups to yank in";
char txt_group_selection[] = "Group Selection";
char txt_select_group[] = "Select group> ";
char txt_help_g_4[] = "4$       Select group 4 ($=select last group)\r\n";
char txt_help_g_ctrl_r[] = "^R       Reset .newsrc\r\n";
char txt_help_g_ctrl_k[] = "^KZ      Delete (Z=undelete) group from .newsrc\r\n";
char txt_help_g_cr[] = "<CR>     Read current group\r\n";
char txt_help_g_c[] = "c        Mark group as all read\r\n";
char txt_help_g_tab[] =   "n<TAB>   Goto next group with unread news and enter it\r\n";
char txt_help_n[] = "N        Goto next group with unread news\r\n";
char txt_help_W[] = "W        List articles posted by user\r\n";
char txt_help_g_z[] = "z        Mark current group as unread\r\n";
char txt_help_g_y[] = "y        Yank in unsubscribed groups that are not in .newsrc\r\n";
char txt_help_g_dollar[] = "Y        Yank in subscribed groups from .newsrc\r\n";
char txt_help_g_search[] = "/?       Group forward (?=backward) search\r\n";
char txt_newsgroup[] = "Newsgroup> ";
char txt_newsgroup_position[] = "Position %s in group list [1,2,..,$]> ";
X
/*
X *  signal.c
X */
X
char txt_resizing_window[] = "resizing window";
X
/*
X *  thread.c
X */
X
char txt_no_resps_in_thread[] = "No responses to list in current thread";
char txt_help_t_0[] = "0        Goto the base article in current thread\r\n";
char txt_help_t_4[] = "4$       Goto response 4 ($=goto last response) in current thread\r\n";
char txt_help_t_cr[] = "<CR>     Read current response\r\n";
char txt_help_t_tab[] = "<TAB>    Goto next unread response\r\n";
char txt_help_t_K[] =   "K        Mark thread as read & return\r\n";
SHAR_EOF
chmod 0600 lang.c ||
echo 'restore of lang.c failed'
Wc_c="`wc -c < 'lang.c'`"
test 20471 -eq "$Wc_c" ||
	echo 'lang.c: original size 20471, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : main.c
X *  Author    : R.Skrenta / I.Lea
X *  Created   : 01-04-91
X *  Updated   : 30-01-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Rich Skrenta & Iain Lea
X *	            You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	"tin.h"
X
char cvers[LEN];
char nntp_server[LEN];
X
int NOTESLINES;						/* set in set_win_size () */
int RIGHT_POS;						/* set in set_win_size () */
int MORE_POS;						/* set in set_win_size () */
int max_subj = 0;
int max_from = 0;
int max_active;
int group_hash[TABLE_SIZE];			/* group name --> active[] */
int num_active;						/* one past top of active */
int group_top;						/* one past top of my_group */
int catchup = FALSE;				/* mark all arts read in all subscribed groups */
int update = FALSE;					/* update index files only mode */
int update_fork = FALSE;			/* update index files by forked tin -u */
int verbose = FALSE;				/* update index files only mode */
int start_line_offset;				/* used by invoke_editor for line no. */
int read_news_via_nntp = FALSE;		/* read news locally or via NNTP */
int max_art;
int top = 0;
int top_base;
int tin_uid;
int tin_gid;
int real_uid;
int real_gid;
int local_index;					/* do private indexing? */
X
X
void main (argc, argv)
X	int argc;	
X	char *argv[];
{
X	extern int optind;
X	extern char *optarg;
X	int c, i, created;
X	int check_any_unread = FALSE;
X	int notify_new_groups = FALSE;
X	int start_any_unread = FALSE;
X	int start_groupnum = 0;
X	struct stat st;
X	
X	cmd_line = TRUE;
X	debug = FALSE;
X
X	set_signal_handlers ();
X
X	basename (argv[0], progname);
X
X	sprintf (page_header, "%s %s PL%d%s", progname, VERSION, PATCHLEVEL, is_remote ()); 	
X	sprintf (cvers, "%s (c) Copyright 1991-92 Iain Lea.", page_header);
X
X	if (progname[0] == 'r') {	/* rtin so read news remotely via NNTP */
#ifdef USE_NNTP			
X		read_news_via_nntp = TRUE;
#else
X		error_message (txt_nntp_not_enabled, progname);
X		exit (1);
#endif
X	}
X
X	tin_uid = geteuid ();
X	tin_gid = getegid ();
X	real_uid = getuid ();
X	real_gid = getgid ();
X
X	/*
X	 * we're setuid, so index in /usr/spool/news unless user root
X	 */
X	if (tin_uid != real_uid && real_uid != 0) {
X		local_index = FALSE;
X	} else {	/* index in users home directory ~/.tin/.index */
X		local_index = TRUE;
X	}
X
X	init_selfinfo ();	/* set up char *'s: homedir, newsrc, etc. */
X	init_alloc ();		/* allocate initial array sizes */
X
X	while ((c = getopt (argc, argv, "cd:Df:hHm:M:np:rRs:SuUvzZ")) != EOF) {
X		switch(c) {
X			case 'c':
X				catchup = TRUE;
X				update = TRUE;
X				break;
X				
X			case 'd':
X				my_strncpy (savedir, optarg, LEN);
X				set_real_uid_gid ();
X				if (stat (savedir, &st) == -1) {
X					mkdir (savedir, 0755);
X				}
X				set_tin_uid_gid ();
X				break;
X
X			case 'D':		/* debug mode */
X				redirect_output[0] = '\0';
X				debug = TRUE;
X				break;
X
X			case 'f':
X				my_strncpy (newsrc, optarg, LEN);
X				break;
X
X			case 'H':
X				show_intro_page ();
X				exit (1);
X				break;
X
X			case 'm':
X				my_strncpy (maildir, optarg, LEN);
X				set_real_uid_gid ();
X				if (stat (maildir, &st) == -1) {
X					mkdir (maildir, 0755);
X				}
X				set_tin_uid_gid ();
X				break;
X
X			case 'M':	/* mail new news to specified user */
X				my_strncpy (mail_news_user, optarg, LEN);
X				mail_news = TRUE;
X				update = TRUE;
X				catchup = TRUE;
X				break;
X
X			case 'n':
X				notify_new_groups = TRUE;
X				break;
X
X			case 'p':
X				my_strncpy (cmd_line_printer, optarg, LEN);
X				default_printer = FALSE;
X				break;
X
X			case 'r':	/* read news remotely from default NNTP server */
#ifdef USE_NNTP			
X				read_news_via_nntp = TRUE;
#else
X				error_message (txt_recompile_with_nntp_option, progname);
X				exit (1);
#endif
X				break;
X
X			case 'R':	/* read news saved by -S option */
X				error_message ("%s: -R option not yet implemented.", progname);
X				exit (1);
X				break;
X
X			case 's':
X				my_strncpy (spooldir, optarg, LEN);
X				break;
X
X			case 'S':	/* save new news to dir structure */
X				save_news = TRUE;
SHAR_EOF
true || echo 'restore of main.c failed'
fi
echo 'End of tin1.1 part 5'
echo 'File main.c is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0

--
NAME   Iain Lea
EMAIL  iain%estevax.uucp@unido.Informatik.Uni-Dortmund.DE
SNAIL  Bruecken Strasse 12, 8500 Nuernberg 90, Germany
PHONE  +49-911-331963 (home)  +49-911-3089-407 (work)
-- 
 Dr. med. dipl.-math Dieter Becker           Tel.: (0 / +49) 6841 - 16 3046
 Medizinische Universitaets- und Poliklinik  Fax.: (0 / +49) 6841 - 16 3369
 Innere Medizin III                         
 D - 6650 Homburg / Saar                     Email: becker@med-in.uni-sb.de
exit 0 # Just in case...
