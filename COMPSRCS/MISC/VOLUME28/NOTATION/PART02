Newsgroups: comp.sources.misc
From: hthomas@ph.tn.tudelft.nl (Henry Thomas)
Subject:  v28i037:  notation - chess preprocessor v3.9, Part02/04
Message-ID: <1992Feb11.204726.9098@sparky.imd.sterling.com>
X-Md4-Signature: e9767adb49564b826c4f481a004a0551
Date: Tue, 11 Feb 1992 20:47:26 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: hthomas@ph.tn.tudelft.nl (Henry Thomas)
Posting-number: Volume 28, Issue 37
Archive-name: notation/part02
Environment: UNIX
Supersedes: notation: Volume20, Issue 52-55

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  drivers.c lexer.c notation.hlp
# Wrapped by kent@sparky on Tue Feb 11 14:22:45 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 4)."'
if test -f 'drivers.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'drivers.c'\"
else
  echo shar: Extracting \"'drivers.c'\" \(20741 characters\)
  sed "s/^X//" >'drivers.c' <<'END_OF_FILE'
X/*
X  Notation program
X  @(#)drivers.c	3.9 (C) Henry Thomas	Release 3     Dated 12/10/91
X */
X
X#ifdef __STDC__
X#include <stdlib.h>
X#endif
X#include<stdio.h>
X
X#include <ctype.h>
X#include "chesstype.h"
X#include "notation.h"
X#include "drivers.h"
X
X/* postscript characters translation table
X   one entry per piece
X   each entry has four fields:
X   - white piece on white case
X   - white piece on black case
X   - black piece on ...
X   ..
X */
X#define PSINDEX(a,b) ((((a)==WHITE)?0:2)+(((b)%2)?0:1))
X
Xstatic char * postscript_table[][4] = {
X  { " ", "x",     " ", "x"     }, /* void */
X  { "k", "\\373", "K", "\\360" }, /* king */
X  { "q", "\\317", "Q", "\\316" }, /* queen */
X  { "r", "\\250", "R", "\\345" }, /* rook */
X  { "b", "\\272", "B", "\\365" }, /* bishop */
X  { "n", "\\265", "N", "\\366" }, /* knight */
X  { "p", "\\271", "P", "\\270" }  /* pawn */
X};
X
X/* TeX table for using the chess figure in board design */
Xstatic char * texboard_table[][4] = {
X  /*   W/W      W/B      B/W      B/B */
X  { " ", "*", " ", "*" }, /* void */
X  { "K", "K", "k", "k" }, /* king */
X  { "Q", "Q", "q", "q" }, /* queen */
X  { "R", "R", "r", "r" }, /* rook */
X  { "B", "B", "b", "b" }, /* bishop */
X  { "N", "N", "n", "n" }, /* knight */
X  { "P", "P", "p", "p" }  /* pawn */
X};
X
X/* TeX table for using the chess figures in move description */
X/* P.T. macros render this table useless as english symbols 
X   are active char in analysis mode
X   */
Xstatic char * latex_table[] = {
X  "", /* null */
X/*  "{\\Fig K}", "{\\Fig Q}", "{\\Fig R}", "{\\Fig B}", "{\\Fig N}",  "" */
X  "K", "Q", "R", "B", "N",  "" 
X    /* last entry = pawn; not represented, otherwise "{\\Fig P}" */
X};
X
X/* various tex symbols */
Xstatic char FigDash[] = "\\FigDash";
Xstatic char FigCapt[] = "*"; /* "*" is an active char with P.T. macros */
Xstatic char FigDots[] = ":"; /* ":" is an active char for "..." */
Xstatic char FigDot[] = "\\FigDot";
X
X#define G_ROQUE  "O-O-O" 
X#define P_ROQUE  "O-O" 
X
X/* variation symbols */
Xstatic char varsymb[][2] = { { '[', ']' }, { '(', ')' } };
X
Xstatic char * com_tex[] = {
X#define CHESSSYMB(LET,LASC,SASC,TEX,PS,ENG,FRA) TEX,
X#include "chesssymb.def"
X ""
X };
X#undef CHESSSYMB
X
Xstatic char * com_ps[] = {
X#define CHESSSYMB(LET,LASC,SASC,TEX,PS,ENG,FRA) PS,
X#include "chesssymb.def"
X ""
X };
X#undef CHESSSYMB
X
Xstatic FILE * ftmp ;
X
X
X/* ---------------- output functions ---------------- */
X
X/* convert a roque in term of king's move */
X#ifdef __STDC__
Xstatic int roque_to_move(depl *m)
X#else
Xstatic int roque_to_move(m)
X     depl * m;
X#endif
X{
X
X  m->piece = KING;
X  m->fromcol   = 5;
X  if (m->type == GRANDROQUE)  
X    m->tocol = 3;
X  else
X    m->tocol = 7;
X
X  if (m->whiteturn)
X    m->fromlig = m->tolig = 1;
X  else
X    m->fromlig = m->tolig = 8;
X
X  return(TRUE);
X}
X
X/* (kind of) buffering of output */
X#ifdef __STDC__
Xstatic void init_buffer(format *d, int side)
X#else
Xstatic void init_buffer(d,side)
X     format * d;
X     int side ;
X#endif
X{
X  switch (d->type) {
X  case D_ASCII:
X    if (side != BLACK) (void) sprintf(d->white_buffer,"...");
X    if (side != WHITE) (void) sprintf(d->black_buffer,"   ");
X    break;
X  case D_TEX:
X    if (side != BLACK) (void) sprintf(d->white_buffer,"%s",FigDots);
X    if (side != WHITE) (void) sprintf(d->black_buffer,"~");
X    break;
X  default:
X    if (side != BLACK) d->white_buffer[0] = '\0' ;
X    if (side != WHITE) d->black_buffer[0] = '\0' ;
X    break;
X  }
X}
X
X/* this procedure is responsible for PRINTING the move */
X#ifdef __STDC__
Xstatic void flush_buffer(format *d)
X#else
Xstatic void flush_buffer(d)
X     format * d;
X#endif
X{
X  
X  /* if we have been interupted (by a comment, a board display etc...
X     if the move is black
X     we display <movenumber> ... <blackmove>
X     */
X  if ((d->interrupt == TRUE) && (d->iswhiteturn == FALSE)) {
X    switch (d->type) {
X    case D_TEX:
X      (void) fprintf(d->outfile,
X		     "%s %s %s\n", 
X		     d->move_buffer,FigDots,d->black_buffer);
X      break;
X    case D_GNU:
X    case D_XCHESS:
X      /* no special case for GNU */
X      (void) fprintf(d->outfile,"\t%s\n",d->black_buffer);
X      break;    
X    default:
X      (void) fprintf(d->outfile,"\n%3s.%9s%9s", 
X		     d->move_buffer,"...",d->black_buffer);
X      break;
X    }
X    d->interrupt = FALSE ;
X  } else {
X  /* else (no interrupt)
X     we display either white or black move 
X     */
X    switch (d->type) {
X    case D_TEX:
X      if (d->iswhiteturn)
X	(void) fprintf(d->outfile,"%s %s", d->move_buffer,d->white_buffer);
X      else
X	(void) fprintf(d->outfile," %s\n",d->black_buffer);
X      break;
X    case D_XCHESS:
X      if (d->iswhiteturn)
X	(void) fprintf(d->outfile,"%3s.", d->move_buffer);
X    case D_GNU:
X      if (d->iswhiteturn)
X	(void) fprintf(d->outfile,"\t%s",d-> white_buffer);
X      else
X	(void) fprintf(d->outfile,"\t%s\n",d->black_buffer);
X      break;    
X    default:
X      if (d->iswhiteturn)
X	(void) fprintf(d->outfile,"\n%3s.%9s", d->move_buffer,d->white_buffer);
X      else
X	(void) fprintf(d->outfile,"%9s", d->black_buffer);
X      break;
X    }
X  } /* end printing */
X
X  /* reset buffer */
X  if (! d->iswhiteturn)
X    init_buffer(d,VOID);
X  d->interrupt = FALSE;
X}
X
X/* a generic parametrised driver for move output
X   */
X#ifdef __STDC__
Xstatic void output_move_generic(format *dr, depl *d)
X#else
Xstatic void output_move_generic(dr,d)
X     format * dr;
X     depl *d;
X#endif
X{
X  char ligne[128] ;
X  char themove[128] ;
X  char thepiece[16]  ;
X  char debcol[16];
X  char frommove[16]  ;
X  char tomove[16] ;
X  char captsymb[16] ;
X  char lie[16] ;
X  char prom[16];
X
X  int ambigue = FALSE ;
X  int ambigueline, ambiguecols;
X
X  ligne[0] = themove[0] = thepiece[0] = debcol[0]  = '\0';
X  frommove[0] = tomove[0] = lie[0] = prom[0] = '\0' ;
X
X  if (dr->type == D_TEX) 
X    (void) sprintf(captsymb,"%s", FigCapt);
X  else
X    (void) sprintf(captsymb,"%s", "x" );
X
X  if (dr->type == D_TEX) {
X    (void) sprintf (dr->move_buffer,"\\mn{%d}",d->move);
X  } else 
X    (void) sprintf (dr->move_buffer,"%d",d->move);
X
X  if ((d->type == PETITROQUE) && !dr->roque_alg)
X    (void) sprintf (themove,"%s",P_ROQUE);
X  if ((d->type == GRANDROQUE) && !dr->roque_alg)
X    (void) sprintf (themove,"%s",G_ROQUE);
X  if (dr->roque_alg && 
X      ((d->type == GRANDROQUE) || (d->type == PETITROQUE)))
X    (void) roque_to_move(d);
X
X  if (dr-> roque_alg || 
X      ((d->type != GRANDROQUE) && (d->type != PETITROQUE))) {
X
X    /* we check here for ambiguous move */
X    if ((d->type != GRANDROQUE) && (d->type != PETITROQUE)) {
X      ambigue = ambiguity (d, &ambigueline, &ambiguecols );
X      /* if ( (ambigue ) && (d->piece != PAWN ))
X       * (void) fprintf (stderr,"output ambiguity at move %d %d",
X       * d->move,d->whiteturn); 
X       */
X    }
X
X    themove[0] = '\0' ;
X    if ((dr->output_move_format == SHORTENED) 
X	&& (d->type == PRISE) && (d->piece == PAWN))
X      (void) sprintf (debcol, "%c",coltoletter(d->fromcol));
X
X    if (dr->print_piece)
X      if (d->piece != PAWN || dr->print_pawn) {
X        if (dr->type == D_TEX )
X          (void) sprintf(thepiece,"%s",latex_table[d->piece]);
X        else
X          (void) sprintf(thepiece,"%c",dr->out_table[d->piece]);
X      }
X
X    if ((dr->output_move_format == ALGEBRAIC))
X      (void)sprintf(frommove,"%c%c",
X		    coltoletter(d->fromcol),ligtoletter(d->fromlig));
X    if ( ambigue && dr->print_liaison ) {
X      /* is the ambiguity on lines ? -> print col */
X      if (ambigueline && !ambiguecols)
X	(void)sprintf(frommove,"%c", coltoletter(d->fromcol));
X      /* is the ambiguity on lines ? -> print lig */
X      if (ambiguecols && !ambigueline)
X	(void)sprintf(frommove,"%c", ligtoletter(d->fromlig));     
X      /* unable to find where is ambiguity ? print all */
X      /* ( I doubt this case ever occurs ... ) */
X      if ( ambigueline && ambiguecols) 
X	(void)sprintf(frommove,"%c%c",
X		      coltoletter(d->fromcol),ligtoletter(d->fromlig));
X      debcol[0] = '\0' ;
X    }
X
X    if (d->promotion) {
X      if (dr->print_liaison) {
X        if (dr->type == D_TEX )
X          (void) sprintf(prom,"=%s ",latex_table[d->promotion]);
X          else
X            (void) sprintf(prom,"=%c",dr->out_table[d->promotion]);
X      } else /* xchess - gnu output */
X	(void) sprintf(prom,"%c",dr->out_table[d->promotion]);
X    }
X          
X    if (dr->print_liaison) {
X      if ((d->type == PRISE) || (d->type == PROM_ET_PRISE) 
X	  || (d->type == EN_PASSANT) )
X	(void) sprintf(lie,"%s",captsymb);
X      else
X	if ((dr->output_move_format == ALGEBRAIC))
X	  (void) sprintf(lie,"%c",'-');
X    }
X    
X    (void) sprintf(tomove,"%c%c",coltoletter(d->tocol),ligtoletter(d->tolig));
X
X    (void) sprintf (themove,"%s%s%s%s%s%s",
X		    thepiece,debcol,frommove,lie, tomove,prom);
X  }
X
X  if (d->whiteturn)
X    (void) sprintf (dr->white_buffer, "%s",themove);
X  else
X    (void) sprintf (dr->black_buffer, "%s",themove);
X
X  dr->iswhiteturn = d->whiteturn; 
X
X  /*fprintf(dr->outfile, "=%d=%d= ",d->move,d->whiteturn);*/
X  flush_buffer(dr); 
X}
X
X/* variation handler */
X#ifdef __STDC__
Xstatic void output_variation_generic (format *dr, int inout)
X#else
Xstatic void output_variation_generic (dr,inout)
X     format * dr;
X     int inout;
X#endif
X{
X  char symbol;
X
X  if (dr->variation > 1)
X    symbol = varsymb[1][inout];
X  else
X    symbol = varsymb[0][inout];
X    
X  switch (dr->type) {
X  case D_TEX:
X    /* we must boldface the brackets for level 1 */
X    if (dr->variation == 1 ) {
X      /*(void) fprintf(dr->outfile, " {\\bf %c} ",symbol);*/
X      if (inout == 0 )
X        (void) fprintf(dr->outfile, "%%\n\\begin{Variation}%%\n ");
X      else
X        (void) fprintf(dr->outfile, "\\end{Variation} %%\n");
X    } else
X      (void) fprintf(dr->outfile, " %c ",symbol); 
X    break;
X  default:
X    (void) fprintf(dr->outfile, "  %c",symbol);
X    break;
X  };
X}
X
X#ifdef __STDC__
Xstatic void output_text_generic(format *dr, int type, char *string, int code)
X#else
Xstatic void output_text_generic(dr, type, string, code)
X     format *dr ;
X     int type;
X     char * string;
X     int code;
X#endif
X{
X  switch (type) {
X  case T_COMMENT:
X    if (com_short[code] != '\0' )
X      (void) fprintf(dr->outfile," %s ",com_short[code]);
X    else
X      (void) fprintf(dr->outfile," %s ",com_long[code]);
X      break;
X  case T_TEXT:
X    (void) fprintf(dr->outfile," %s ",string);
X    break;
X  case T_TITLE:
X    (void) fprintf(dr->outfile,"\n  %s\n",string);
X    break;
X  case T_SUBTITLE:
X    (void) fprintf(dr->outfile,"    %s\n",string);
X    break;
X  case T_SCORE:
X    (void) fprintf(dr->outfile,"  %s\n",string);
X  default:
X    break;
X  }
X}
X
X
X/* ---------------- ascii driver ----------  */
X#ifdef __STDC__
Xstatic void output_init_ascii(format *dr) 
X#else
Xstatic void output_init_ascii(dr) 
Xformat *dr;
X#endif
X{}
X    
X#ifdef __STDC__
Xstatic void output_board_ascii(format *dr,game *g)
X#else
Xstatic void output_board_ascii(dr,g)
X     format * dr;
X     game * g;
X#endif
X{
X  register int i,j;
X
X  dr->interrupt = TRUE;
X
X  (void) fprintf(dr->outfile,"\n\n");
X  for (i=8 ; i >=1 ; i--) {
X    if (dr->coordinates)
X      (void) fprintf(dr->outfile,"%d ",i);
X    (void) fputc('|',dr->outfile);
X    for (j=1 ; j<9 ; j++) {
X      if (g->board[i][j] != VOID) {
X	if (g->color[i][j] == WHITE) 
X	 (void) fputc(dr->out_table[g->board[i][j]], dr->outfile);
X	else 
X	  (void) fputc(tolower(dr->out_table[g->board[i][j]]),dr->outfile);
X      } else
X	(void) fputc ( ((i+j)% 2)?' ':'/', dr->outfile);
X      (void) fputc('|', dr->outfile);
X    }
X    (void) fputc('\n', dr->outfile);
X  }
X  if (dr->coordinates)
X    (void) fprintf(dr->outfile,"   a b c d e f g h\n");
X  (void) fprintf(dr->outfile,"\n");
X}
X
X/* ---------------- postscript --------- */
X
X#ifdef __STDC__
Xstatic void output_board_ps(format *dr,game *g)
X#else
Xstatic void output_board_ps(dr,g)
X     format *dr;
X     game * g;
X#endif
X{
X  register int i,j;
X  register int c;
X  char chaine[MAXTOKLEN];
X
X  /* header file */
X  (void) strcpy(chaine,LIB_DIR);
X  if ((ftmp = fopen(strcat(chaine,PS_HEADER),"r")) == NULL)
X    message((stderr,"Can't open ps header file.\n"));
X  else {
X    while ((c = getc(ftmp)) != EOF)
X      (void) fputc(c,dr->outfile);
X    (void) fclose(ftmp);
X  }
X
X  (void) fprintf(dr->outfile,"( ________) 72 714 T\n");
X  for (i=8 ; i >=1 ; i--) {
X    (void) fprintf(dr->outfile,"(/");
X    for (j=1 ; j<9 ; j++) {
X    (void) fprintf(dr->outfile,"%s",
X		   postscript_table[g->board[i][j]][PSINDEX(g->color[i][j],(i+j))]);
X    }
X    (void) fprintf(dr->outfile,"\\\\) 72 %d T\n",474 + (i-1)*30);
X  }
X  (void) fprintf(dr->outfile,"( --------) 72 444 T\n");
X
X  /* footer file */
X  (void) strcpy(chaine,LIB_DIR);
X  if ((ftmp = fopen(strcat(chaine,PS_FOOTER),"r")) == NULL)
X    message((stderr,"Can't open ps footer file.\n"));
X  else {
X    while ((c = getc(ftmp)) != EOF)
X      (void) fputc(c,dr->outfile);
X    (void) fclose(ftmp);
X  }
X}
X
X/* ---------------- nroff --------------- */
X#ifdef __STDC__
Xstatic void output_init_roff(format *dr)
X#else
Xstatic void output_init_roff(dr)
X     format *dr;
X#endif
X{
X}
X
X#ifdef __STDC__
Xstatic void output_board_roff(format *dr,game *g)
X#else
Xstatic void output_board_roff(dr, g)
X     format *dr;
X     game * g;
X#endif
X{
X  register int i,j;
X
X  dr->interrupt = TRUE;
X
X  (void) fprintf(dr->outfile,".br\n");
X  for (i=8 ; i >=1 ; i--) {
X    (void) fprintf(dr->outfile,".ce\n  ");
X    for (j=1 ; j<9 ; j++) {
X      if (g->board[i][j] != VOID) {
X	if (g->color[i][j] == WHITE) 
X	 (void) fputc(dr->out_table[g->board[i][j]], dr->outfile);
X	else 
X	  (void) fputc(tolower(dr->out_table[g->board[i][j]]),dr->outfile);
X      } else
X	/*(void) fputc ( ((i+j)% 2)?' ':'/', dr->outfile);*/
X	(void) fprintf(dr->outfile,".");
X    }
X    (void) fprintf(dr->outfile,"\n.br\n");
X  }
X  (void) fprintf(dr->outfile,"\n");
X}
X
X/* ---------------- tex -------------------- */
X#ifdef __STDC__
Xstatic void output_init_tex(format *dr)
X#else
Xstatic void output_init_tex(dr)
X     format *dr;
X#endif
X{
X  register int c;
X
X  /* header text */
X  fprintf(dr->outfile, "%% This file generated by the Notation program\n");
X  fprintf(dr->outfile, "%% @ Henry Thomas 1991\n");
X  fprintf(dr->outfile, "\\documentstyle[twocolumn,chess]{article}\n");
X  fprintf(dr->outfile, "\\input{notation.tex}\n");
X  fprintf(dr->outfile, "\n");
X  fprintf(dr->outfile, "\\begin{document}\n");
X  fprintf(dr->outfile, "\n");
X  fprintf(dr->outfile, "\\begin{Mainline}{}{}\n");
X}
X
X#ifdef __STDC__
Xstatic void output_text_tex(format *dr, int type, char * string, int code)
X#else
Xstatic void output_text_tex(dr, type, string, code)
X     format *dr ;
X     int type;
X     char * string;
X     int code;
X#endif
X{
X  if (type != T_COMMENT)
X    (void) fprintf(dr->outfile, " \\nochess");
X
X  switch (type) {
X  case T_COMMENT:
X    if (com_tex[code] != '\0' )
X      (void) fprintf(dr->outfile,"%s\\ ",com_tex[code]);
X    else
X      (void) fprintf(dr->outfile,"%s\\ ",com_short[code]);
X      break;
X  case T_TEXT:
X    (void) fprintf(dr->outfile," %s ",string);
X    break;
X  case T_TITLE:
X    (void) fprintf(dr->outfile,"\n\\ChessTitle{%s}\n",string);
X    break;
X  case T_SUBTITLE:
X    (void) fprintf(dr->outfile,"\n\\ChessSubTitle{%s}\n",string);
X    break;
X  case T_SCORE:
X    (void) fprintf(dr->outfile,"\n\\ChessScore{%s}\n",string);
X  default:
X    break;
X  };
X  if (type != T_COMMENT)
X    (void) fprintf(dr->outfile, "\\endnochess ");
X}
X
X#ifdef __STDC__
Xstatic void output_board_tex(format *dr,game *g)
X#else
Xstatic void output_board_tex(dr,g)
X     format *dr;
X     game * g;
X#endif
X{
X  register int i,j;
X
X  dr->interrupt = TRUE;
X
X  (void) fprintf(dr->outfile,"\n\n\\begin{diagram}\n");
X  (void)fprintf(dr->outfile,"\\board");
X  for (i=8 ; i >=1 ; i--) {
X    (void) fprintf(dr->outfile,"\t{");
X    for (j=1 ; j < 9 ; j++) {
X    (void) fprintf(dr->outfile,"%s",
X		   texboard_table[g->board[i][j]][PSINDEX(g->color[i][j],(i+j))]);
X    }
X    (void) fprintf(dr->outfile,"}\n");
X  }
X  (void) fprintf(dr->outfile,"\\end{diagram}\n\n");
X}
X
X#ifdef __STDC__
Xstatic void output_end_tex(format *dr)
X#else
Xstatic void output_end_tex(dr)
X     format *dr;
X#endif
X{ 
X  (void) fprintf(dr->outfile, "\n\\end{Mainline}\n");
X  (void) fprintf(dr->outfile, " \n\n\n\\end{document}\n");
X}
X
X/* ------------------ gnu - xchess ---------- */
X
X#ifdef __STDC__
Xstatic void output_init_gnu(format *dr)
X#else
Xstatic void output_init_gnu(dr)
X     format *dr;
X#endif
X{
X  (void) fprintf(dr->outfile, "X Chess -- Mon Dec 10 11:47:18 MET 1990\n");
X  (void) fprintf(dr->outfile,"\tGame played on dummkopft.irisa.fr:0.0\n");
X  (void) fprintf(dr->outfile,"\talgebraic\n");
X}
X
X/* ---------------- driver handler ---------- */
X/* dummy driver */
X#ifdef __STDC__
Xstatic void null_driver(void) {}
X#else
Xstatic void null_driver() {}
X#endif
X
X/* the drivers */
X#ifdef __STDC__
Xvoid output_init(format *dr)
X#else
Xvoid output_init(dr)
X     format *dr ;
X#endif
X{
X  if (dr->print_headers)
X    dr->out_init(dr);
X}
X
X#ifdef __STDC__
Xvoid output_move(format *dr,depl *d)
X#else
Xvoid output_move(dr,d)
X     format *dr ;
X     depl *d;
X#endif
X{
X  if (! (((dr->type == D_GNU) || (dr->type == D_XCHESS))
X	&& (dr->variation > 0)))
X    dr->out_move(dr,d);
X}
X
X#ifdef __STDC__
Xvoid output_variation(format *dr, int inout)
X#else
Xvoid output_variation(dr, inout)
X     format *dr ;
X     int inout;
X#endif
X{
X  dr->out_variation(dr,inout);
X}
X
X#ifdef __STDC__
Xvoid output_text(format *dr, int type, char *string, int code)
X#else
Xvoid output_text(dr, type, string, code)
X     format *dr ;
X     int type;
X     char * string;
X     int code;
X#endif
X{
X  if ((dr->type != D_GNU) && (dr->type != D_XCHESS))
X    dr->out_text(dr, type, string, code);
X}
X
X#ifdef __STDC__
Xvoid output_board(format *dr, game *g)
X#else
Xvoid output_board(dr,g)
X     format *dr ;
X     game *g ;
X#endif
X{
X  dr->out_board(dr,g);
X}
X
X#ifdef __STDC__
Xvoid output_end(format *dr)
X#else
Xvoid output_end(dr)
X     format *dr ;
X#endif
X{
X  if (dr->print_headers)
X    dr->out_end(dr);
X  (void) fprintf(dr->outfile,"\n");
X}
X
X
X#ifdef __STDC__
Xformat * new_driver(void)
X#else
Xformat * new_driver()
X#endif
X{
X  format * tmp;
X  int i; 
X
X  tmp = (format *) malloc (sizeof(format));
X  ALLOCP(tmp);
X  for (i=0; i < ((sizeof (format))/ sizeof (int)) ; i++)
X    ((int *) tmp)[i] = 0;
X  tmp->output_move_format = SHORTENED;
X  tmp->print_headers = TRUE;
X  return(tmp);
X}
X
X#ifdef __STDC__
Xvoid init_driver(format *dr,int driver)
X#else
Xvoid init_driver(dr,driver)
X     format * dr;
X     int driver;
X#endif
X{
X  dr->type = driver ;
X
X  init_buffer(dr, VOID);
X  switch (dr->type) {
X  case D_ASCII:
X    dr->print_move = TRUE;
X    dr->print_piece = TRUE;
X    dr->print_pawn = FALSE;
X    dr->roque_alg = FALSE;
X    dr->print_liaison = TRUE;
X    dr->out_init = output_init_ascii;
X    dr->out_move = output_move_generic;
X    dr->out_variation = output_variation_generic;
X    dr->out_text = output_text_generic;
X    dr->out_board = output_board_ascii;
X    dr->out_end = null_driver;
X    break;
X  case D_POST:
X    dr->out_init = null_driver;
X    dr->out_move = null_driver;
X    dr->out_variation = null_driver;
X    dr->out_text = null_driver;
X    dr->out_board = output_board_ps;
X    dr->out_end = null_driver;
X    break;
X  case D_TEX:
X    dr->print_move = TRUE;
X    dr->print_piece = TRUE;
X    dr->print_pawn = FALSE;
X    dr->roque_alg = FALSE;
X    dr->print_liaison = TRUE;
X    dr->out_init = output_init_tex;
X    dr->out_move = output_move_generic;
X    dr->out_variation = output_variation_generic;
X    dr->out_text = output_text_tex;
X    dr->out_board = output_board_tex;
X    dr->out_end = output_end_tex;
X    break;
X  case D_ROFF:
X    dr->print_move = TRUE;
X    dr->print_piece = TRUE;
X    dr->print_pawn = FALSE;
X    dr->roque_alg = FALSE;
X    dr->print_liaison = TRUE;
X    dr->out_init = output_init_roff;
X    dr->out_move = output_move_generic;
X    dr->out_variation = output_variation_generic;
X    dr->out_text = output_text_generic;
X    dr->out_board = output_board_roff;
X    dr->out_end = null_driver;
X    break;
X  case D_XCHESS:
X    dr->output_move_format = ALGEBRAIC;
X    dr->print_move = TRUE;
X    dr->print_piece = FALSE;
X    dr->print_pawn = FALSE;
X    dr->roque_alg = TRUE;
X    dr->print_liaison = FALSE;
X    dr->out_init = output_init_gnu;
X    dr->out_move = output_move_generic;
X    dr->out_variation = null_driver;
X    dr->out_text = null_driver;
X    dr->out_board = null_driver;
X    dr->out_end = null_driver;
X    break;
X  case D_GNU:
X    dr->output_move_format = ALGEBRAIC;
X    dr->print_move = FALSE;
X    dr->print_piece = FALSE;
X    dr->print_pawn = FALSE;
X    dr->roque_alg = TRUE;
X    dr->print_liaison = FALSE;
X    dr->out_init = null_driver;
X    dr->out_move = output_move_generic;
X    dr->out_variation = null_driver;
X    dr->out_text = null_driver;
X    dr->out_board = null_driver;
X    dr->out_end = null_driver;
X    break;
X  default:
X    error((stderr,"unknown driver"));
X    break;
X  }
X  if (dr->only_board)
X    dr->out_move = null_driver ;
X
X  dr->variation = 0;
X  dr->iswhiteturn = FALSE ;
X  dr->interrupt = FALSE;
X}
END_OF_FILE
  if test 20741 -ne `wc -c <'drivers.c'`; then
    echo shar: \"'drivers.c'\" unpacked with wrong size!
  fi
  # end of 'drivers.c'
fi
if test -f 'lexer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lexer.c'\"
else
  echo shar: Extracting \"'lexer.c'\" \(32987 characters\)
  sed "s/^X//" >'lexer.c' <<'END_OF_FILE'
X/* A lexical scanner generated by flex */
X
X/* scanner skeleton version:
X * $Header: /usr/fsys/odin/a/vern/flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36 vern Exp $
X */
X
X#define FLEX_SCANNER
X
X#include <stdio.h>
X
X
X/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
X#ifdef c_plusplus
X#ifndef __cplusplus
X#define __cplusplus
X#endif
X#endif
X
X
X#ifdef __cplusplus
X
X#include <stdlib.h>
X#include <osfcn.h>
X
X/* use prototypes in function declarations */
X#define YY_USE_PROTOS
X
X/* the "const" storage-class-modifier is valid */
X#define YY_USE_CONST
X
X#else	/* ! __cplusplus */
X
X#ifdef __STDC__
X
X#ifdef __GNUC__
X#include <stddef.h>
Xvoid *malloc( size_t );
Xvoid free( void* );
X#else
X#include <stdlib.h>
X#endif	/* __GNUC__ */
X
X#define YY_USE_PROTOS
X#define YY_USE_CONST
X
X#endif	/* __STDC__ */
X#endif	/* ! __cplusplus */
X
X
X#ifdef __TURBOC__
X#define YY_USE_CONST
X#endif
X
X
X#ifndef YY_USE_CONST
X#define const
X#endif
X
X
X#ifdef YY_USE_PROTOS
X#define YY_PROTO(proto) proto
X#else
X#define YY_PROTO(proto) ()
X/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
X * so it's got to be a K&R compiler, and therefore there's no standard
X * place from which to include these definitions
X */
Xchar *malloc();
Xint free();
Xint read();
X#endif
X
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X
X/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
X/* this used to be an fputs(), but since the string might contain NUL's,
X * we now use fwrite()
X */
X#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X#define YY_NULL 0
X
X/* no semi-colon after return; correct usage is to write "yyterminate();" -
X * we don't want an extra ';' after the "return" because that will cause
X * some compilers to complain about unreachable statements.
X */
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X
X/* The funky do-while is used to turn this macro definition into
X * a single C statement (which needs a semi-colon terminator).
X * This avoids problems with code like:
X *
X * 	if ( something_happens )
X *		YY_FATAL_ERROR( "oops, the something happened" );
X *	else
X *		everything_okay();
X *
X * Prior to using the do-while the compiler would get upset at the
X * "else" because it interpreted the "if" statement as being all
X * done when it reached the ';' after the YY_FATAL_ERROR() call.
X */
X
X#define YY_FATAL_ERROR(msg) \
X	do \
X		{ \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X		} \
X	while ( 0 )
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE \
X	do \
X		{ \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X		} \
X	while ( 0 )
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#define YY_DECL int yylex YY_PROTO(( void )) 
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
X#endif
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
X#define YY_CHAR char
X# line 1 "lexer.l"
X#define INITIAL 0
X/* DO NOT REMOVE THIS LINE                      */
X/*                                              */
X/* Notation program                             */
X/* @(#)lexer.l	3.9 (C) Henry Thomas   Release 3     Dated 12/10/91 */
X/*                                              */
X# line 7 "lexer.l"
X#include <stdio.h>
X
X#include "chesstype.h"
X#include"notation.h"
X
X#define NCURLINE 1024
Xchar curline [NCURLINE] ;
X
X#define LARGE_BUF 4096
Xstatic char commbuf[LARGE_BUF];
X
Xint column = 0;
Xint lineno = 1;
X
X#ifdef __STDC__
Xextern void count(void);
Xextern char * comment(int closing);
X#else
Xextern void count();
Xextern char * comment();
X#endif
X
X# line 34 "lexer.l"
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	do \
X		{ \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X		} \
X	while ( 0 )
X
X#define unput(c) yyunput( c, yytext )
X
X
Xstruct yy_buffer_state
X    {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters*/
X    int yy_buf_size;	
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
X#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
X#define EOF_PENDING 1
X#define EOF_DONE 2
X    };
X
Xstatic YY_BUFFER_STATE yy_current_buffer;
X
X/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic YY_CHAR yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X#ifndef YY_USER_INIT
X#define YY_USER_INIT
X#endif
X
Xextern YY_CHAR *yytext;
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
XYY_CHAR *yytext;
Xint yyleng;
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
X#define YY_END_OF_BUFFER 32
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[83] =
X    {   0,
X        0,    0,   32,   30,   29,   29,    8,    7,   30,    7,
X       25,   28,    7,    2,    2,   30,   30,   30,   30,   24,
X       30,   30,   30,   30,   26,   27,    6,    5,    5,    0,
X       13,    0,    0,    0,    0,    0,    2,    1,    2,    1,
X       18,   23,    0,    0,    0,    0,    1,    0,   14,    3,
X        0,    0,   20,    0,    0,    0,    1,    4,    0,   10,
X        9,   11,    3,    0,    1,    1,   22,    1,    0,    1,
X       12,    3,    3,    3,    0,   19,    0,   17,   21,   20,
X       15,    0
X    } ;
X
Xstatic const YY_CHAR yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        2,    2,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    4,    1,    5,    6,    1,    7,    1,    8,
X        9,   10,   11,   12,   13,   14,   15,   16,   17,   17,
X       17,   17,   17,   17,   17,   17,   18,    1,   12,    7,
X       19,    7,    4,   20,   21,   21,   21,   21,   21,   21,
X       21,   21,   21,   21,   21,   21,   21,   21,   22,   21,
X       21,   21,   21,   21,   21,   21,   21,   23,   21,   21,
X       24,    7,   25,   26,    7,    1,   27,   27,   28,   27,
X
X       29,   27,   27,   27,   27,   27,   27,   27,   27,   27,
X       30,   31,   27,   27,   27,   32,   27,   27,   27,   33,
X       27,   27,   34,    7,   35,    7,    1
X    } ;
X
Xstatic const YY_CHAR yy_meta[36] =
X    {   0,
X        1,    1,    1,    1,    2,    1,    2,    1,    1,    2,
X        2,    1,    3,    1,    2,    1,    4,    1,    2,    1,
X        1,    1,    5,    1,    1,    6,    7,    7,    7,    7,
X        7,    7,    7,    1,    1
X    } ;
X
Xstatic const short int yy_base[90] =
X    {   0,
X        0,    0,  154,  246,  246,  246,   32,   42,    0,   37,
X       30,  246,   42,   63,   46,  127,   65,   86,   71,   40,
X       73,  107,  128,   74,  246,  246,  246,    0,    0,    0,
X      246,  143,  140,  123,  114,   73,  246,  149,  109,  156,
X      246,   32,   88,    0,    0,  152,  167,  104,  246,  171,
X      111,   81,   93,  105,   86,   62,  182,  246,    0,  246,
X      246,  246,  154,  180,  189,  246,  246,  198,  197,   66,
X      246,  125,  246,    0,   68,  246,   37,  246,  246,  246,
X      246,  246,   52,  223,  228,  233,  239,   47,   31
X    } ;
X
Xstatic const short int yy_def[90] =
X    {   0,
X       82,    1,   82,   82,   82,   82,   82,   82,   83,    8,
X       82,   82,    8,   82,   82,   84,   85,   82,   85,   82,
X       86,   82,   82,   86,   82,   82,   82,   87,   87,   88,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82,   84,   86,   24,   24,   43,   24,   82,   82,   24,
X       43,   82,   82,   82,   82,   82,   82,   82,   89,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   43,   82,
X       82,   82,   82,   43,   82,   82,   82,   82,   82,   82,
X       82,    0,   82,   82,   82,   82,   82,   82,   82
X    } ;
X
Xstatic const short int yy_nxt[282] =
X    {   0,
X        4,    5,    6,    7,    8,    9,   10,   11,    4,   10,
X        8,   12,   13,   12,   10,   14,   15,   15,   10,   16,
X       17,   18,   19,   20,    4,   10,   21,   21,   22,   23,
X       21,   21,   24,   25,   26,   27,   27,   79,   31,   32,
X       82,   29,   27,   33,   27,   27,   28,   29,   29,   29,
X       48,   29,   28,   59,   28,   34,   29,   82,   30,   37,
X       29,   39,   39,   39,   49,   67,   81,   29,   35,   35,
X       35,   35,   35,   35,   35,   36,   37,   43,   38,   39,
X       39,   80,   63,   43,   40,   43,   43,   43,   40,   50,
X       50,   78,   40,   43,   40,   43,   43,   45,   46,   77,
X
X       82,   40,   40,   45,   82,   51,   51,   40,   43,   63,
X       82,   75,   44,   44,   44,   47,   44,   44,   45,   43,
X       52,   63,   37,   50,   39,   39,   39,   63,   71,   43,
X       63,   62,   76,   35,   35,   35,   35,   53,   54,   51,
X       46,   55,   56,   40,   50,   73,   73,   73,   61,   40,
X       43,   60,   41,   82,   35,   35,   35,   57,   35,   35,
X       51,   64,   37,   82,   65,   39,   39,   40,   64,   82,
X       66,   66,   72,   40,   73,   73,   73,   66,   66,   69,
X       82,   68,   66,   82,   82,   66,   82,   82,   66,   72,
X       82,   73,   73,   74,   64,   66,   70,   66,   63,   82,
X
X       82,   66,   37,   66,   39,   39,   39,   82,   82,   66,
X       64,   66,   66,   66,   63,   82,   82,   82,   66,   66,
X       82,   82,   82,   82,   82,   82,   70,   66,   42,   42,
X       44,   82,   44,   82,   44,   35,   35,   35,   82,   35,
X       58,   58,   82,   82,   58,    3,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82
X    } ;
X
Xstatic const short int yy_chk[282] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    7,    7,   89,   11,   11,
X       10,   10,    7,   11,    7,    8,    8,   10,    8,   10,
X       20,    8,    8,   88,    8,   11,    8,   42,   83,   15,
X        8,   15,   15,   15,   20,   42,   77,    8,   13,   13,
X       13,   13,   13,   13,   13,   14,   14,   17,   14,   14,
X       14,   75,   70,   19,   14,   21,   24,   17,   36,   21,
X       24,   56,   14,   19,   36,   21,   24,   17,   18,   55,
X
X       43,   18,   36,   19,   43,   21,   24,   18,   18,   53,
X       43,   52,   18,   18,   18,   18,   18,   18,   18,   22,
X       22,   54,   39,   22,   39,   39,   39,   51,   48,   22,
X       35,   34,   54,   22,   22,   22,   22,   22,   22,   22,
X       23,   23,   23,   23,   23,   72,   72,   72,   33,   23,
X       23,   32,   16,    3,   23,   23,   23,   23,   23,   23,
X       23,   38,   38,    0,   38,   38,   38,   46,   40,    0,
X       38,   40,   63,   46,   63,   63,   63,   40,   38,   47,
X        0,   46,   47,    0,    0,   40,    0,   50,   47,   50,
X        0,   50,   50,   50,   57,   64,   47,   57,   57,    0,
X
X        0,   64,   65,   57,   65,   65,   65,    0,    0,   64,
X       68,   57,   69,   68,   68,    0,    0,    0,   69,   68,
X        0,    0,    0,    0,    0,    0,   69,   68,   84,   84,
X       85,    0,   85,    0,   85,   86,   86,   86,    0,   86,
X       87,   87,    0,    0,   87,   82,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
X       82
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic YY_CHAR *yy_last_accepting_cpos;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X#define YY_MORE_ADJ 0
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
X/* points to current character in buffer */
Xstatic YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));
Xstatic yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
Xstatic int yy_get_next_buffer YY_PROTO(( void ));
Xstatic void yyunput YY_PROTO(( YY_CHAR c, YY_CHAR *buf_ptr ));
Xvoid yyrestart YY_PROTO(( FILE *input_file ));
Xvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
Xvoid yy_load_buffer_state YY_PROTO(( void ));
XYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
Xvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
Xvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
X
X#define yy_new_buffer yy_create_buffer
X
X#ifdef __cplusplus
Xstatic int yyinput YY_PROTO(( void ));
X#else
Xstatic int input YY_PROTO(( void ));
X#endif
X
XYY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
Xyy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 83 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 82 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
Xyy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
Xdo_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
Xcase 1:
X# line 35 "lexer.l"
X{ /* roque */ ; parse_roque(yytext); }
X	YY_BREAK
Xcase 2:
X# line 36 "lexer.l"
X{ /* move number */ parse_number(yytext); }
X	YY_BREAK
Xcase 3:
X# line 37 "lexer.l"
X{ /* move */  
X  (void) parse_move(yytext);
X  /*; fprintf(stderr,"%s, ",yytext);*/ 
X}
X	YY_BREAK
Xcase 4:
X# line 43 "lexer.l"
X{ /* comment */ ; 
X				parse_comment(yytext); }
X	YY_BREAK
Xcase 5:
X# line 45 "lexer.l"
X{ /* comment */ ; 
X				   parse_comment(yytext); }
X	YY_BREAK
Xcase 6:
X# line 47 "lexer.l"
X{ /* comment */ ; 
X				     parse_comment(yytext); }
X	YY_BREAK
Xcase 7:
X# line 49 "lexer.l"
X{ /* comment */ ; 
X			   parse_comment(yytext); }
X	YY_BREAK
Xcase 8:
X# line 51 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 9:
X# line 52 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 10:
X# line 53 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 11:
X# line 54 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 12:
X# line 55 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 13:
X# line 56 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 14:
X# line 57 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 15:
X# line 58 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 16:
X# line 59 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 17:
X# line 60 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 18:
X# line 61 "lexer.l"
X{ /* comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 19:
X# line 62 "lexer.l"
X{ /* comment */ ; parse_comment("etc"); }
X	YY_BREAK
Xcase 20:
X# line 63 "lexer.l"
X{ /* comment */ ; parse_comment("ep"); }
X	YY_BREAK
Xcase 21:
X# line 64 "lexer.l"
X{ /* game comment */ ; parse_comment(yytext); }
X	YY_BREAK
Xcase 22:
X# line 65 "lexer.l"
X{ /* keyword with arg */ 
X  yytext[yyleng -1] = '\0' ;
X  parse_keyword(yytext, comment('}'));
X}
X	YY_BREAK
Xcase 23:
X# line 69 "lexer.l"
X{ /* keyword without arg */ 
X  parse_keyword(yytext,NULL); }
X	YY_BREAK
Xcase 24:
X# line 71 "lexer.l"
X{ parse_text(comment(']')); }
X	YY_BREAK
Xcase 25:
X# line 72 "lexer.l"
X{ parse_text(comment(')')); }
X	YY_BREAK
Xcase 26:
X# line 73 "lexer.l"
X{ /* enter variation */ ; enter_variation(); }
X	YY_BREAK
Xcase 27:
X# line 74 "lexer.l"
X{ /* close variation */ ; exit_variation(); }
X	YY_BREAK
Xcase 28:
X# line 75 "lexer.l"
X{ /* skip , ; */ ; }
X	YY_BREAK
Xcase 29:
X# line 76 "lexer.l"
X{ /* skip blanks */; }
X	YY_BREAK
Xcase 30:
X# line 77 "lexer.l"
X{ /* ignore bad characters */ (void) fprintf(stderr,"I don't understand: %s\n",yytext);}
X	YY_BREAK
Xcase 31:
X# line 78 "lexer.l"
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    yy_current_state = yy_start;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 83 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
X#ifdef YY_USE_PROTOS
Xstatic yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
X#else
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X#endif
X
X    {
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 83 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 82);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
XYY_CHAR c;
Xregister YY_CHAR *yy_bp;
X#endif
X
X    {
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
X#ifdef __cplusplus
Xstatic int yyinput()
X#else
Xstatic int input()
X#endif
X
X    {
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X#ifdef __cplusplus
X		    return ( yyinput() );
X#else
X		    return ( input() );
X#endif
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X#ifdef __cplusplus
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X#else
X		    YY_FATAL_ERROR( "unexpected last match in input()" );
X#endif
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yyrestart( FILE *input_file )
X#else
Xvoid yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
X#else
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X#endif
X
X    {
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_load_buffer_state( void )
X#else
Xvoid yy_load_buffer_state()
X#endif
X
X    {
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X    }
X
X
X#ifdef YY_USE_PROTOS
XYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
X#else
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X#endif
X
X    {
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
X
X    if ( ! b )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );
X
X    if ( ! b->yy_ch_buf )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    yy_init_buffer( b, file );
X
X    return ( b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_delete_buffer( YY_BUFFER_STATE b )
X#else
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X#endif
X
X    {
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free( (char *) b->yy_ch_buf );
X    free( (char *) b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
X#else
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X#endif
X
X    {
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X    }
X# line 78 "lexer.l"
X
X
X#ifdef FLEX_SCANNER
X#undef yywrap
X#endif
X#ifdef __STDC__
Xint yywrap(void)
X#else
Xint yywrap()
X#endif
X{
X        return(1);
X}
X
X
X/* this procedure store comments in the text array commbuf
X   Escape char are allowed for putting the end-of-comment symbol
X   in the buffer
X   */
X#ifdef __STDC__
Xstatic char * comment(int closing)
X#else
Xstatic char * comment(closing)
X     char closing;
X#endif
X{
X  register char c;
X  register int i=0;
X
X  while ( ((c = input()) != closing)  && (c != 0) && (c != EOF)) {
X    commbuf[i] = c;
X    if (i <LARGE_BUF) i++ ;
X    
X    if (c == '\\') {
X      c = input() ;
X      if (c == closing)
X	commbuf[i-1] = c;
X      else
X	unput(c);
X    }
X  }
X  commbuf[i] = '\0' ;
X  return(commbuf);
X}
X
X#ifdef __STDC__
Xstatic void count(void)
X#else
Xstatic void count()
X#endif
X{
X  register int i;
X  register int k;
X
X  for (i = 0; yytext[i] != '\0'; i++) {
X    if (yytext[i] == '\n') {
X      column = 0;
X      for (k = 0 ; k< NCURLINE; k++) /*PANDORE*/
X        curline[k] = ' '; /*PANDORE*/
X      lineno++;
X    }
X    else if (yytext[i] == '\t') {
X      column += 8 - (column % 8);
X      curline[column] = yytext[i];
X    } else {
X      column++;
X      curline[column] = yytext[i];
X    }
X    curline[column+1]= '\0' ;
X  }
X  /*ECHO;*/
X}
END_OF_FILE
  if test 32987 -ne `wc -c <'lexer.c'`; then
    echo shar: \"'lexer.c'\" unpacked with wrong size!
  fi
  # end of 'lexer.c'
fi
if test -f 'notation.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'notation.hlp'\"
else
  echo shar: Extracting \"'notation.hlp'\" \(1011 characters\)
  sed "s/^X//" >'notation.hlp' <<'END_OF_FILE'
XCommand line options: 
X<inputfile>	: specify the input file. If none, keyboard is assumed
X-a		: algebraic move notation output
X-s		: shortened move notation output
X-f <language>	: specify the chess symbol input language: french,
X	english, italian, spanish, german, dutch, czech, hungarian, polish,
X	romanian, FIDE. (for portuguese, use spanish)  
X-t <language>	: specify the chess symbol output language (same
Xoptions as input language).
X-o <outputfile>	: specify the output file. If none, screen is assumed
X-c <number>[,<number]	: specify the number of the moves to display
X	the board. if none, board is diplayed at end of file
X-e <number>     : display the board at the move number and then stops
X-b		: display only the board, not the moves
X-d <drivername>	: specify the output driver: ascii,postscript, tex
X(latex), roff, xchess (xchess save format), gnu (gnuan input format) 
X-i              : suppress headers/footer in output (useful
X		for tex/ps drivers)
X-h		: shows this help
X-v		: shows version number
END_OF_FILE
  if test 1011 -ne `wc -c <'notation.hlp'`; then
    echo shar: \"'notation.hlp'\" unpacked with wrong size!
  fi
  # end of 'notation.hlp'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
