Newsgroups: comp.sources.misc
From: hthomas@ph.tn.tudelft.nl (Henry Thomas)
Subject:  v28i039:  notation - chess preprocessor v3.9, Part04/04
Message-ID: <1992Feb11.204806.9238@sparky.imd.sterling.com>
X-Md4-Signature: f36163333ab16295eef64e0a5a27247e
Date: Tue, 11 Feb 1992 20:48:06 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: hthomas@ph.tn.tudelft.nl (Henry Thomas)
Posting-number: Volume 28, Issue 39
Archive-name: notation/part04
Environment: UNIX
Supersedes: notation: Volume20, Issue 52-55

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  MANIFEST CHANGES Footer.ps Header.ps Makefile TODO
#   algebric.ntn boudy.ntn chesssymb.tex chesstype.h convsymb.tex
#   convsymb.txt drivers.h keywords.ntn lexer.h lexer.l symb.tex
#   symboles.tex symboles.txt
# Wrapped by kent@sparky on Tue Feb 11 14:22:46 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 4)."'
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(0 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
END_OF_FILE
  if test 0 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(1507 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
X** 10/02/92 version 3.9: make extensive use of new Chess macros
X(version 1.2 mandatory) by Piet Tutelaers. The TeX output is much more
Xreadable and edit-able by a human being.
X
X** 25/11/91 a bunch of changes: the shortened algebraic has been
Ximproved, with important code redesign. The shortened algebraic is no
Xreally shortened algebraic.
X
X** 21/11/91 Release 3.4 Corrected a bug introduced in versiopn 3.3,
Xthat cause algebraic notation to indicate promotion. Also rename
XHELPFILE to notation.hlp and demo files now end with .ntn instead of
X.txt. 
X
X** 13/11/91 Release 3.3. Corrected a bug that forbidded promotion.
XEnhanced errors messages. Now promotion is by default to a queen:
X"h8=" is equivalent to "h8=Q".
X
X** 11/05/91 NEW VERSION. Many many improvements: en-passant,
Xpromotion. Split the source in many differents file. Programming style
Ximproved etc...
X
X** 24/04/91 Cleaned-up a few bugs, and added -i and -v options. 
X
X** 16/04/91 NEW NEW version: now handles variations and codified
Xcomment, as well as specials strings as title, subtitle, score and
Xcomments.
X
X** 12/04/91 added the following languages: czech, hungarian, polish,
Xromanian, FIDE. Thank Lael.
X
X** 20/03/91 gnu driver has change. It is now named "xchess". The "gnu"
Xname is now used for "gnuan" type files.
X
X** much improved latex output
X
X** improved internal move generation
X
X** added @special keyword, to directly include text in output
X
X** 24/01/91 The program should be ANSI-C. At last, it compiles with "gcc
X-ansi -pedantic"
END_OF_FILE
  if test 1507 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'Footer.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Footer.ps'\"
else
  echo shar: Extracting \"'Footer.ps'\" \(196 characters\)
  sed "s/^X//" >'Footer.ps' <<'END_OF_FILE'
X2 ENDPAGE
X%%PageTrailer
X%%PageFonts: Times-Roman Cheq 
X%%PageBoundingBox: 20 20 576 756 
X%%Trailer
Xend %PROLOGUE
X%%Pages: 1 
X%%BoundingBox: 20 20 576 756 
X%%DocumentFonts: Times-Roman Cheq 
X%%EOF
END_OF_FILE
  if test 196 -ne `wc -c <'Footer.ps'`; then
    echo shar: \"'Footer.ps'\" unpacked with wrong size!
  fi
  # end of 'Footer.ps'
fi
if test -f 'Header.ps' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Header.ps'\"
else
  echo shar: Extracting \"'Header.ps'\" \(2180 characters\)
  sed "s/^X//" >'Header.ps' <<'END_OF_FILE'
X%!PS-Adobe-2.1
X%%% HOW TO USE:  from Unix, "cat Cheq Example | lpr -Pprintername "
X%%Title: Cheq.cheqtxtx
X%%Creator: Glenn Reid and still.ps (V 1.0d release 10 edit 08)
X%%BoundingBox: (atend)
X%%Pages: (atend)
X%%DocumentProcSets: Adobe_distill 0.95
X%%EndComments
X%%BeginProcSet: Adobe_distill 0.95
X/PROLOGUE 30 40 add dict def
X % 30 procedure entries + room for 40 cached font dictionaries
X PROLOGUE begin
X /clip { } def    % causes problems. remove if "clip" is needed
X /bdef { bind def } bind def	/ldef { load def } bdef
X /T { moveto show } bdef	/A { moveto ashow } bdef
X /W { moveto widthshow } bdef	/AW { moveto awidthshow } bdef
X /f /fill ldef			/R { { rlineto } repeat } bdef
X /r /rlineto ldef		/L { { lineto } repeat } bdef
X /m /moveto ldef		/l { moveto lineto stroke } bdef
X /x { 0 rlineto } bdef		/y { 0 exch rlineto } bdef
X /c /curveto ldef		/cp /closepath ldef
X /s /stroke ldef		/w /setlinewidth ldef
X /g /setgray ldef		/j /setlinejoin ldef
X /d /setdash ldef		/F /setfont ldef
X /C /setcmykcolor where { /setcmykcolor get }{ %ifelse
X   { %def
X     1 sub 3 { 3 index add neg dup 0 lt { pop 0 } if 3 1 roll } repeat
X     setrgbcolor
X   } bind
X } ifelse def
X /MF { findfont exch makefont setfont } bdef
X /DF { findfont exch scalefont setfont currentfont def } bdef
X /BEGINPAGE { pop /pagesave save def } bdef
X /ENDPAGE { pop pagesave restore showpage } def
X /REMAP { %def
X   FontDirectory 2 index known { pop pop pop } { %ifelse
X     findfont dup length dict begin
X       { 1 index /FID ne {def}{pop pop} ifelse } forall
X       exch dup length 0 gt { /Encoding exch def }{ pop } ifelse
X     currentdict end definefont pop
X   } ifelse
X } bdef
X /RECODE { %def
X    3 -1 roll 1 index findfont /Encoding get 256 array copy exch
X    0 exch { %forall
X     dup type/nametype eq
X       { 3 {2 index} repeat put pop 1 add }{ exch pop }ifelse
X    } forall pop 3 1 roll REMAP
X } bdef
X end %PROLOGUE
X%%EndProcSet: Adobe_distill 0.95
X%%EndProlog
X%%BeginSetup
XPROLOGUE begin
X
X%%EndSetup
X%%Page: 1 1
X%%PageFonts: (atend)
X%%PageBoundingBox: (atend)
X1 BEGINPAGE
X1 1 1 0 C
X/F1 12 /Times-Roman DF
X(output of program notation, using font Cheq \(gift of Adobe Systems\))
X72 756 T
X/F2 30 /Cheq DF
END_OF_FILE
  if test 2180 -ne `wc -c <'Header.ps'`; then
    echo shar: \"'Header.ps'\" unpacked with wrong size!
  fi
  # end of 'Header.ps'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(3827 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for notation program
X# (C) Henry Thomas 1990
X
XFILES      = notation.c drivers.c lexer.c lexer.l
XHEADERS	   = notation.h drivers.h lexer.h chesstype.h chesssymb.def
XLIBDIR     = $(HOME)/lib
XLIBTEX	   = $(HOME)/lib/tex
XMANDIR	   = $(HOME)/cygnus/man
XMANSEC     = n
XBINDIR	   = $(HOME)/bin/$(HOSTTYPE)
X
XOBJECTS    = notation.o drivers.o lexer.o
X
XOTHERFILES = Makefile notation.hlp \
X	keywords.ntn algebric.ntn shortened.ntn boudy.ntn\
X	notation.doc notation.n \
X	README TODO COPYING CHANGES \
X	Header.ps Footer.ps \
X	convsymb.txt convsymb.tex \
X	symboles.txt symboles.tex chesssymb.tex symb.tex
X
X
XSAVEFILES  = $(FILES) $(HEADERS) $(OTHERFILES)
X
XVERSION    = `sccs get -g notation.c`
XKITNAME	   = "Notation"
X# version ids used for producing patches
X#   -- caveat: as I started all over from 3.2, 1.0 = 3.2
XOLDVER	   = 1.0
XNEWVER	   = $(VERSION)
X
XSYMBKIT	   = ChessSymb
XSYMBFILES  = symboles.tex symb.tex chesssymb.tex
X
X############################################################
X# you might want to define the lib path : 
X#	do not forget the trailing /
X# ( the library is the place where the HELPFILE, Heading, fonts etc are)
X# also you can have default language for input/ouput
X# define DEFAULT_INPUT_LANGUAGE and DEFAULT_OUPUT_LANGUAGE
X# value can be:
X#	FRENCH, ENGLISH, GERMAN, ITALIAN, SPANISH, DUTCH
X# ANSI C/ TURBO C (MSDOS)
X# to compile with TURBO C or ANSI C, define TURBOC
XCFLAGS     = -DLIB_DIR=\"$(HOME)/lib/\" \
X	-DDEFAULT_INPUT_LANGUAGE=FRENCH \
X	-DDEFAULT_OUTPUT_LANGUAGE=FRENCH 
XLDFLAGS    = 
X
X
XLEX= flex
X
X#CC= gcc -ansi -pedantic
X
X############################################################
X
X.KEEPSTATE:
X
Xall: notation notation.doc symboles.txt
X
Xlexer.c: lexer.l chesstype.h
X	$(LEX) -t lexer.l > lexer.c
X
Xnotation: $(OBJECTS)
X	$(CC) $(CFLAGS) -o notation  $(OBJECTS) 
X
Xsymboles.txt:  chesssymb.def convsymb.txt
X	/lib/cpp -P convsymb.txt| sed -e "s/\\\\//" |\
X	sed -e 's/\"//g' | cat -s > symboles.txt
X
Xsymb.tex:  chesssymb.def convsymb.tex
X	/lib/cpp -P convsymb.tex | sed -e 's/\\\\/\\/g' |\
X	sed -e 's/\"//g' | cat -s > symb.tex
X
Xsymboles.dvi: symboles.tex symb.tex
X	latex symboles.tex
X
X
Xkit     : $(SAVEFILES)
X	makekit -n$(KITNAME) $(LIBDIR) $(SAVEFILES) MANIFEST > MANIFEST
X
Xshar     : $(SAVEFILES)
X	shar -o$(KITNAME).shar $(LIBDIR) $(SAVEFILES) 
X	compress -f $(KITNAME).shar
X
Xtar     : $(SAVEFILES)
X	tar -cvf - $(SAVEFILES) > $(KITNAME)$(VERSION).tar
X	compress -f $(KITNAME)$(VERSION).tar
X
Xzoo	: $(SAVEFILES)
X#	chmod +w $(KITNAME).zoo
X	zoo -freshen $(KITNAME).zoo $(SAVEFILES)
X	rm -f $(KITNAME).bak
X#	chmod -w $(KITNAME).zoo
X
Xpatch	: $(SAVEFILES)
X	chmod +w Notation.new/*
X	rm Notation.new/*
X	cp $(SAVEFILES) Notation.new
X	diff -c Notation.old Notation.new > patch$(NEWVER) 
X#	( cat FTP ; shar patch$(NEWVER) ) > patch$(NEWVER).shar
X
Xsauve   :
X	make zoo
X#	chmod +w $(KITNAME).zoo
X	cp $(KITNAME).zoo $(HOME)/local/sauve
X#	chmod -w $(KITNAME).zoo
X
Xsymboles: $(SYMBFILES)
X	shar -o$(SYMBKIT).shar $(SYMBFILES) 
X	compress -f $(SYMBKIT).shar
X	
X
Xfiles: notation.hlp chesssymb.def
X	make notation
X	strip notation
X#	chmod +x print-ps
X	make notation.doc 
X	make symboles.txt symb.tex
X
Xinstall:
X	make files
X	cp notation $(BINDIR)
X	cp chesssymb.tex notation.tex $(LIBTEX)
X	cp notation.n $(MANDIR)/man$(MANSEC)/notation.$(MANSEC)
X	cp notation.doc $(MANDIR)/cat$(MANSEC)/notation.$(MANSEC)
X	cp notation.hlp notation.doc Header.ps Footer.ps \
X		symboles.txt symboles.tex $(LIBDIR)
X
Xclean:
X	rm -f notation $(OBJECTS) lexer.c
X	rm -f $(KITNAME)*.shar[.Z] $(KITNAME)*.tar[.Z] \
X		$(KITNAME)0? MANIFEST $(SYMBKIT).shar
X
Xnotation.doc: notation.n
X	nroff -man notation.n > notation.doc
X
X
X# DO NOT DELETE THIS LINE -- make depend depends on it.
X
Xdrivers.o: chesstype.h notation.h drivers.h chesssymb.def
Xlexer.o: chesstype.h notation.h lexer.h chesssymb.def
Xnotation.o: chesstype.h drivers.h notation.h lexer.h chesssymb.def
END_OF_FILE
  if test 3827 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
  echo shar: Extracting \"'TODO'\" \(504 characters\)
  sed "s/^X//" >'TODO' <<'END_OF_FILE'
XThings to do:
XURGENT
X - fix chess/gnuan output for promotion
X - rebuild latex output to fit better with Piet Tutelaers macros.
X
XLATER
X - command line specification of chess symbols for a new language
X - to have configuration file
X - automatically add sufixes (.tex, ps, .asc, .roff .xboard.save ...) to
Xoutput file
X - add a xbord save-position format
X - detect check
X - a binary save format, allowing another program to interactively
Xreplay the game (this should lead to a kind of "ChessBase" program ).
END_OF_FILE
  if test 504 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
  fi
  # end of 'TODO'
fi
if test -f 'algebric.ntn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'algebric.ntn'\"
else
  echo shar: Extracting \"'algebric.ntn'\" \(958 characters\)
  sed "s/^X//" >'algebric.ntn' <<'END_OF_FILE'
X
X[WORLD CHESS CHAMPIONSHIP]
X[GAME 13 Adjourned]
X[November 24, 1990]
X
X[   KARPOV      KASPAROV]
X 1. d2-d4      g8-f6
X 2. c2-c4      g7-g6
X 3. b1-c3      d7-d5
X 4. c4Xd5      f6Xd5
X 5. e2-e4      d5Xc3
X 6. b2Xc3      f8-g7
X 7. c1-e3      c7-c5
X 8. d1-d2       O-O
X 9. a1-c1      d8-a5
X10. g1-f3      e7-e6
X11. d4-d5      e6Xd5
X12. e4Xd5      f8-e8
X13. f1-e2      c8-f5
X14.  O-O       b8-d7
X15. h2-h3      d7-b6
X16. g2-g4      f5-d7
X17. c3-c4      a5Xd2
X18. f3Xd2      b6-a4
X19. e2-f3      a4-c3
X20. c1Xc3      g7Xc3
X21. d2-e4      e8Xe4
X22. f3Xe4      a8-e8
X23. e4-d3      b7-b6
X24. g1-g2      f7-f5
X25. g4Xf5      d7Xf5
X26. d3Xf5      g6Xf5
X27. f1-d1      g8-f7
X28. d1-d3      c3-f6
X29. d3-a3      a7-a5
X30. a3-b3      f6-d8
X31. b3-c3      d8-c7
X32. a2-a4      f7-f6
X33. g2-f1      f5-f4
X34. e3-c1      f6-f5
X35. c3-c2      e8-g8
X36. c2-e2      c7-e5
X37. c1-b2      e5-d4
X38. b2Xd4      c5Xd4
X39. e2-e7      d4-d3
X40. f1-e1      g8-c8
X41. e1-d2      c8Xc4
X
X
X
END_OF_FILE
  if test 958 -ne `wc -c <'algebric.ntn'`; then
    echo shar: \"'algebric.ntn'\" unpacked with wrong size!
  fi
  # end of 'algebric.ntn'
fi
if test -f 'boudy.ntn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'boudy.ntn'\"
else
  echo shar: Extracting \"'boudy.ntn'\" \(864 characters\)
  sed "s/^X//" >'boudy.ntn' <<'END_OF_FILE'
X@title{Boudy vs Szabo, Varna 1979}
X@subtitle{See Informant XXVII game 452}
X@language{french}
X1. e4 c5 
X2 Cf3 Cc6 
X3 d4 cd4
X4  Cd4 Cf6
X5 Cc3 d6
X6. f4 a6 
X7. Cc6 bc6 
X8. e5 Cd7
X9. ed6 ed6 
X10. Df3 d5
X11. Fd2 Fd6 
X12. o-o-o 0-0
X13. g4 Fb7 { Tb8 !? ~ } 
X14. Tg1 Te8
X15. g5 f5 !? {Cc5}
X16. g6 h6
X17. Fd3 ?! { Fh3! +_} Tf8
X18. Dh3 Df6
X19. Tg5 Cc5
X20. Ff5 Fc8!
X21. Fc8 Tac8
X22. Tg4 Tb8 =~ 
X23. Tf1 Ce4
X24. Fe1 @showboard Tb2
X25. Rb2 { Ce4 de4 26 Fc3 Fa3! 27. Ff6 Tb3 _+ $end } Fa3!
X26. Ra3 {26 Ra1 Tb8 -+} Tb8 -+
X27. Ce4 De7 ?? {27. ... Db2 28. Ra4 Da2 29. Da3 Dc2 30. Ra5 Tb5 
X   31. Ra6 De4 /\[De8a8 -+]}
X28.  Cd6! { 28. Ra4 De4 -+} Dd6
X29. Ra4 c5
X30. Th4 { $bei 30. Tg1 c4 31 Dc3 Dd7 32. Ra3 Dd6 33 Dd4 -+ } c4
X31. Dc3 Dd7 
X32. Ra3 De7 
X33. Db4! +- Tb4 
X34. Fb4 Dh4
X35. Te1 Dd8 [] 
X36. c3! a5
X37. Fc5 || 
X
X@score{White won} [ somewhat luckily in the end at move 75.]
X
END_OF_FILE
  if test 864 -ne `wc -c <'boudy.ntn'`; then
    echo shar: \"'boudy.ntn'\" unpacked with wrong size!
  fi
  # end of 'boudy.ntn'
fi
if test -f 'chesssymb.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chesssymb.tex'\"
else
  echo shar: Extracting \"'chesssymb.tex'\" \(3734 characters\)
  sed "s/^X//" >'chesssymb.tex' <<'END_OF_FILE'
X% next definition we take from LaTeX
X\def\mbox#1{\leavevmode\hbox{#1}}
X
X%
X% Next part will be added to chess.sty version 1.2
X%
X
X% And now we define most symbols that are used in `\v{S}ahovski Informator'
X% (Chess Informant). For a complete list see Informant#51 (1991) pp 10-12.
X% If you add symbols realize that the macros should be usable by plain TeX
X% and LaTeX and that the (La)TeX names should be suggestive and clear!
X% Thanks go to John Saba (saba@ccit.arizona.edu) and Henry Thomas 
X% (hthomas@irisa.fr) for their help in defining next symbols.
X\font\symbolten=cmsy10 \font\smrm=cmr6 \font\symbolsix=cmsy6
X\def\Wbetter{\mbox{\baselineskip0pt$\vcenter{\vbox{\hbox{+}\hbox{=}}}$}}
X\def\Bbetter{\mbox{\baselineskip0pt
X   $\vcenter{\vbox{\hbox{=}\kern-.3ex\hbox{+}}}$}}
X\def\Wupperhand{\mbox{$\pm$}}
X\def\Bupperhand{\mbox{$\mp$}}
X\def\Wdecisive{\mbox{$+\hbox{}-$}}
X\def\Bdecisive{\mbox{$-\hbox{}+$}}
X\def\equal{=}
X\def\unclear{\mbox{$\infty$}}
X\def\compensation{\mbox{\baselineskip0pt$\vcenter{\vbox{%
X   \hbox{\kern.056em\vbox{\hrule width0.89em\kern0.35ex\hrule width0.89em}}
X   \kern.2ex\hbox{$\infty$}}}$}}
X% next symbol should be build using METAFONT
X\def\devadvantage{{\symbolten\char'015}\kern-4.8pt
X   \vrule width 2.4pt height6pt depth-5.6pt
X   \vrule width .4pt height8pt depth-5.6pt\kern2.4pt}
X\def\moreroom{{\symbolten\char'015}}
X\def\withattack{$\rightarrow$}
X\def\withinit{$\uparrow$}
X\def\counterplay{\hbox{\baselineskip0pt%
X   $\vcenter{\vbox{\hbox{$\leftarrow$}\hbox{$\rightarrow$}}}$}}
X\def\zugzwang{$\odot$}
X\def\mate{\kern.4pt\mbox{%
X   \vrule width2ex height1.18ex depth-1.1ex\kern-2ex
X   \vrule width2ex height.52ex depth-.44ex\kern-1.381ex
X   \vrule width.08ex height1.8ex depth.2ex\kern0.615ex
X   \vrule width.08ex height1.8ex depth.2ex\kern0.406ex}\kern.4pt}
X\def\withidea{$\triangle$}
X\def\onlymove{$\Box$}
X\def\betteris{\mbox{\baselineskip0pt
X   $\vcenter{\vbox{\hbox{$\frown$}\kern-0.35ex\hrule width0.95em}}$}}
X\def\file{$\Leftrightarrow$}
X% next symbol should be build using METAFONT
X\def\diagonal{$\nearrow$}
X\def\Center{$\Box$\kern-.6em\raise.54ex\hbox{\smrm\char'053}}
X\def\kside{$\gg$}
X\def\qside{$\ll$}
X\def\weakpt{$\times$}
X\def\ending{$\perp$}
X\def\bishoppair{\setbox0=\hbox{%
X   \vrule width1.4ex height1ex depth-.92ex\kern-1.4ex
X   \vrule width1.4ex height.08ex depth0pt\kern-1.4ex
X   \vrule width.08ex height1ex depth0ex\kern1.24ex
X   \vrule width.08ex height1ex depth0ex}%
X   \kern.4pt\mbox{\copy0\kern-.6ex\raise0.56ex\box0}\kern.4pt}
X\def\opposbishops{\kern.4pt\mbox{%
X   \vrule width1.4ex height1ex depth-.92ex\kern-1.4ex
X   \vrule width1.4ex height.08ex depth0pt\kern-1.4ex
X   \vrule width.08ex height1ex depth0ex\kern1.24ex
X   \vrule width.08ex height1ex depth0ex\kern-.6ex
X   \vrule width1.4ex height1.56ex depth-0.56ex}\kern.4pt }
X\def\samebishops{\kern.4pt\mbox{%
X   \vrule width1.4ex height1ex depth0ex\kern-.6ex
X   \vrule width1.4ex height1.56ex depth-0.56ex}\kern.4pt}
X\def\unitedpawns{$\circ\kern-.05em\circ$}
X\def\seppawns{$\circ\kern-.3em\cdot\kern-.35em\cdot\kern-.1em\circ$}
X\def\doublepawns{\mbox{\baselineskip0pt
X   $\vcenter{\vbox{\hbox{$\circ$}\vskip.8pt\hbox{$\circ$}}}$}}
X\def\passedpawns{\mbox{\baselineskip0pt
X   $\vcenter{\vbox{\hbox{\kern0.09em\symbolsix\char'042}\hbox{$\circ$}}}$}}
X\def\morepawns{$>$}
X\def\time{$\oplus$}
X\def\novelty{{\sc N}}
X\def\comment{{\sc RR}}
X\def\various{{\sc R}}
X\def\with{\kern.4pt\mbox{%
X   \vrule width 1ex height.08ex depth0ex\kern-0.08ex
X   \vrule width0.08ex height1.5ex depth0ex}\kern.4pt}
X\def\without{\kern.4pt\mbox{%
X   \vrule width 0.08ex height1.5ex depth0ex\kern-0.08ex
X   \vrule width 1ex height.08ex depth0ex}\kern.4pt}
X\def\etc{$\parallel$}
X\def\see{\kern.4pt\mbox{\vrule width 1em height.54ex depth-.46ex}\kern.4pt}
X
END_OF_FILE
  if test 3734 -ne `wc -c <'chesssymb.tex'`; then
    echo shar: \"'chesssymb.tex'\" unpacked with wrong size!
  fi
  # end of 'chesssymb.tex'
fi
if test -f 'chesstype.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chesstype.h'\"
else
  echo shar: Extracting \"'chesstype.h'\" \(3157 characters\)
  sed "s/^X//" >'chesstype.h' <<'END_OF_FILE'
X/*
X  Notation program
X  @(#)chesstype.h	3.9 (C) Henry Thomas   Release 3     Dated 12/10/91
X */
X
X/* types definition */
X#ifndef _HEADERS_TYPES
X#define _HEADERS_TYPES
X
X#define FALSE 0
X#define TRUE  1
X
X#ifndef NULL
X#define NULL    ((char *) 0)
X#endif
X
X#define MAX(a,b)  ((a)>(b)?(a):(b))
X#define MIN(a,b)  ((a)<(b)?(a):(b))
X#define ABS(a)	  ((a)>=0?(a):(-(a)))
X#define SIGN(a)   ((a)>=0?(1):-1)
X
X#define DUMMYCHAR '$'
X#define MAXTOKLEN 1024
X
X
X/* max number of move for displaying board */
X#define NB_MOVE_TO_DISP 128
X
X/* debugging help */
X#ifdef DEBUG
X#define MESSAGE(A) (void) fprintf A
X#define ACTION(A)  A
X#else
X#define MESSAGE(A)
X#define ACTION(A)
X#endif
X
X/* output move format */
X
X#define ALGEBRAIC 0
X#define SHORTENED 1
X
X/* text type */
X#define T_TEXT		1
X#define T_COMMENT	2
X#define T_TITLE		3
X#define T_SUBTITLE	4
X#define T_SCORE		5
X
X/* -------------------------------------------- */
X/*              chess data structures           */
X/* -------------------------------------------- */
X
X#define NUMPIECES 7
X
X#define KING   1
X#define QUEEN  2
X#define ROOK   3
X#define BISHOP 4
X#define KNIGHT 5
X#define PAWN   6
X
X#define VOID  0
X#define WHITE 1
X#define BLACK -1
X
X/* board and move representation */
X/* board size */
X#define SIZE 10 
X
X/* ---- structure to represent the game ---- */
Xtypedef struct {
X
X  /* board definition */
X  int board[SIZE][SIZE];
X  int color[SIZE][SIZE];
X
X} game ;
X/* ---- end of structure ---- */
X
X#define GULL (game *) 0
X
X/* french(roque) == english(castling) */
X
X#define MOVE		1  	/* un mouvement        */
X#define PRISE		2      	/* une prise           */
X#define GRANDROQUE	3 	/* grand roque         */
X#define PETITROQUE	4 	/* petit roque         */
X#define EN_PASSANT	5	/* prise en passant    */
X#define PROMOTION  	6	/* promotion           */
X#define PROM_ET_PRISE	7	/* promotion + capture */
X
X#define SHORT_COMMENT_LEN 4
X
X/* structure used to describe the current move */
Xstruct deplace {
X  /* system zone */
X  int uid ;             /* node id */
X
X  /* links used to chain moves   */
X  struct deplace * next ; /* next move     */
X  struct deplace * prev ; /* previous move */
X  struct deplace * sub  ; /* variation     */
X
X  /* user zone */
X  int move ;		/* number of the move */
X  int whiteturn ; 	/* boolean to tell if white's turn */
X
X  int type;		/* type of move: MOVE, PRISE, etc..   */
X  int piece;		/* type of the piece */
X
X  int fromcol, fromlig;	/* from position */
X  int tocol, tolig ;	/* destination   */
X
X  int prise;		/* captured piece */
X  int promotion;        /* name of the pice the pawn is promoted to */
X
X  int is_check ;	/* if does the move provides check ?*/
X
X  char comment[SHORT_COMMENT_LEN];	/* short text comment */
X  char * text ;         /* long text comment */
X
X
X} ;
Xtypedef struct deplace depl ;
X
X#define MULL (depl *) 0
X
X#define CURCOLOR(M) (((M)->whiteturn)?(WHITE):(BLACK))
X#define OPPCOLOR(M) (((M)->whiteturn)?(BLACK):(WHITE))
X
X
X/* structure used to hold a complete play 
X   this structure is
X   - an initial board 
X   - a chain of moves
X   moves are applied to the board, and coan also be undone
X   */
Xtypedef struct {
X  game * initial;
X  depl * chain ;
X} play ;
X
X
X/* end headers */
X#endif
END_OF_FILE
  if test 3157 -ne `wc -c <'chesstype.h'`; then
    echo shar: \"'chesstype.h'\" unpacked with wrong size!
  fi
  # end of 'chesstype.h'
fi
if test -f 'convsymb.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'convsymb.tex'\"
else
  echo shar: Extracting \"'convsymb.tex'\" \(149 characters\)
  sed "s/^X//" >'convsymb.tex' <<'END_OF_FILE'
X#define CHESSSYMB(LET,LASC,SASC,TEX,PS,ENG,FRA)\
XENG & \verb;LASC; & \verb;SASC;	& TEX &  \verb;TEX; \cr  
X#include "chesssymb.def"
X#undef CHESSSYMB
END_OF_FILE
  if test 149 -ne `wc -c <'convsymb.tex'`; then
    echo shar: \"'convsymb.tex'\" unpacked with wrong size!
  fi
  # end of 'convsymb.tex'
fi
if test -f 'convsymb.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'convsymb.txt'\"
else
  echo shar: Extracting \"'convsymb.txt'\" \(195 characters\)
  sed "s/^X//" >'convsymb.txt' <<'END_OF_FILE'
Xcomment	shorthand 	english translation
X------------------------------------------------
X#define CHESSSYMB(LET,LASC,SASC,TEX,PS,ENG,FRA)\
XLASC		SASC		ENG
X#include "chesssymb.def"
X#undef CHESSSYMB
END_OF_FILE
  if test 195 -ne `wc -c <'convsymb.txt'`; then
    echo shar: \"'convsymb.txt'\" unpacked with wrong size!
  fi
  # end of 'convsymb.txt'
fi
if test -f 'drivers.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'drivers.h'\"
else
  echo shar: Extracting \"'drivers.h'\" \(2473 characters\)
  sed "s/^X//" >'drivers.h' <<'END_OF_FILE'
X/*
X  Notation program
X  @(#)drivers.h	3.9 (C) Henry Thomas   Release 3     Dated 12/10/91
X */
X/* headers for output drivers */
X#ifndef _HEADERS_DRIVERS
X#define HEADERS_DRIVERS
X
X
X#define D_ASCII  0
X#define D_POST   1
X#define D_TEX    2
X#define D_ROFF   3
X#define D_XCHESS 4
X#define D_GNU    5
X
X#define NB_DRIVER 6
X
X/* variation convention */
X#define VARIATION_IN 0
X#define VARIATION_OUT 1
X
X
X#define PS_HEADER  "Header.ps"
X#define PS_FOOTER  "Footer.ps"
X#define TEX_HEADER "Header.tex"
X
X
X/* output buffers */
X#define TAMPON 256
X
Xtypedef struct {
X
X  /* type of driver */
X  int type ;
X
X  /* output_file */
X  FILE *outfile ;
X  /* these  booleans control the output format */
X  int print_move    ;  /* move numbering */
X  int print_piece   ;  /* print piece name */
X  int print_pawn    ; /* print the PAWN name */
X  int roque_alg     ; /*  roque in algebraic form Ke1g1 or O-O */
X  int print_liaison ; /* print the - or x in move output */
X  int only_board ;
X  int variation     ; /* variation level */
X  int print_headers ; /* include the header/footer file */
X
X  /* boolean to print the coordinates in ascii output of board */
X  int coordinates   ;
X  int output_move_format ;
X
X  char *out_table;	/* translation table */
X
X  /* procedures */
X  void (*out_init)() ;
X  void (*out_move)() ;
X  void (*out_variation)() ;
X  void (*out_text)() ;
X  void (*out_board)() ;
X  void (*out_end)() ;
X
X  /* temp vars  used by move buffering */
X
X  int iswhiteturn ; /*= FALSE */
X  int interrupt ; /*= FALSE */
X
X  char move_buffer[TAMPON]  /*= ""*/ ;
X  char white_buffer[TAMPON] /*= ""*/ ;
X  char black_buffer[TAMPON] /*= ""*/ ;
X
X
X} format ;
X
X
X/* fonctions ----------------- */
X
X#ifdef __STDC__
X
Xextern void output_init(format *dr);
Xextern void output_move(format *dr, depl *d);
Xextern void output_variation(format *dr, int inout);
Xextern void output_text(format *dr, int type, char *string, int code);
Xextern void output_board(format *dr, game *g);
Xextern void output_end(format *dr);
X
Xextern format *new_driver(void);
Xextern void init_driver(format *dr, int driver);
X
X#else
X
Xextern void output_init(/*format *dr*/);
Xextern void output_move(/*format *dr, depl *d*/);
Xextern void output_variation(/*format *dr, int inout*/);
Xextern void output_text(/*format *dr, int type, char *string, int code*/);
Xextern void output_board(/*format *dr, game *g*/);
Xextern void output_end(/*format *dr*/);
X
Xextern format *new_driver(/*void*/);
Xextern void init_driver(/*format *dr, int driver*/);
X#endif
X
X#endif
END_OF_FILE
  if test 2473 -ne `wc -c <'drivers.h'`; then
    echo shar: \"'drivers.h'\" unpacked with wrong size!
  fi
  # end of 'drivers.h'
fi
if test -f 'keywords.ntn' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'keywords.ntn'\"
else
  echo shar: Extracting \"'keywords.ntn'\" \(256 characters\)
  sed "s/^X//" >'keywords.ntn' <<'END_OF_FILE'
X[Example of keywords use]
X[absolutely non-sense game]
Xe2-e4 c7c6
X@showboard
X@clearboard
X@showboard
X@configwhite
X d4    Nf6
X Nc3   @showboard d5
X@configblack
X Kg8
X@startplay
X@whitesmove
XNc3-b1
X@showboard
X@blacksmove
XRg8-g7 @showboard d5-d6
XRg7-f6
X
X@null
X
X
X
END_OF_FILE
  if test 256 -ne `wc -c <'keywords.ntn'`; then
    echo shar: \"'keywords.ntn'\" unpacked with wrong size!
  fi
  # end of 'keywords.ntn'
fi
if test -f 'lexer.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lexer.h'\"
else
  echo shar: Extracting \"'lexer.h'\" \(312 characters\)
  sed "s/^X//" >'lexer.h' <<'END_OF_FILE'
X/*
X  Notation program
X  @(#)lexer.h	3.9 (C) Henry Thomas   Release 3     Dated 12/10/91
X */
X#ifndef _HEADER_LEXER
X#define _HEADER_LEXER
X
Xextern int column;
Xextern int lineno;
X
Xextern FILE * yyin;
Xextern FILE * yyout;
X
X#ifdef __STDC__
Xextern int yylex(/*void*/);
X#else
Xextern int yylex(/*void*/);
X#endif
X
X
X#endif
END_OF_FILE
  if test 312 -ne `wc -c <'lexer.h'`; then
    echo shar: \"'lexer.h'\" unpacked with wrong size!
  fi
  # end of 'lexer.h'
fi
if test -f 'lexer.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lexer.l'\"
else
  echo shar: Extracting \"'lexer.l'\" \(3990 characters\)
  sed "s/^X//" >'lexer.l' <<'END_OF_FILE'
X/* DO NOT REMOVE THIS LINE                      */
X/*                                              */
X/* Notation program                             */
X/* @(#)lexer.l	3.9 (C) Henry Thomas   Release 3     Dated 12/10/91 */
X/*                                              */
X%{
X#include <stdio.h>
X
X#include "chesstype.h"
X#include"notation.h"
X
X#define NCURLINE 1024
Xchar curline [NCURLINE] ;
X
X#define LARGE_BUF 4096
Xstatic char commbuf[LARGE_BUF];
X
Xint column = 0;
Xint lineno = 1;
X
X#ifdef __STDC__
Xextern void count(void);
Xextern char * comment(int closing);
X#else
Xextern void count();
Xextern char * comment();
X#endif
X
X%}
X
XLEXSHORT [-+!?#]
XLEXLONG  [-+=/\\\^\&\*\~<>_|#]
X
X%%
X[Oo0]\-?[Oo0](\-?[Oo0])? { /* roque */ ; parse_roque(yytext); }
X[0-9]+[\.]?	        { /* move number */ parse_number(yytext); }
X[A-Z]?([a-z]([1-8])?)?[-xX]?[a-z][1-8]=?[A-Z]?  { /* move */  
X  (void) parse_move(yytext);
X  /*; fprintf(stderr,"%s, ",yytext);*/ 
X}
X
X
X{LEXLONG}{LEXLONG}{LEXLONG}     { /* comment */ ; 
X				parse_comment(yytext); }
X{LEXLONG}{LEXLONG}      { /* comment */ ; 
X				   parse_comment(yytext); }
X{LEXSHORT}{LEXSHORT}    { /* comment */ ; 
X				     parse_comment(yytext); }
X{LEXLONG}               { /* comment */ ; 
X			   parse_comment(yytext); }
X{LEXSHORT}              { /* comment */ ; parse_comment(yytext); }
X"\(\.\)"                { /* comment */ ; parse_comment(yytext); }
X"\(\*\)"                { /* comment */ ; parse_comment(yytext); }
X"\(\^\)"                { /* comment */ ; parse_comment(yytext); }
X"\[\+\]"                { /* comment */ ; parse_comment(yytext); }
X"\(\)"                  { /* comment */ ; parse_comment(yytext); }
X"\[\]"                  { /* comment */ ; parse_comment(yytext); }
X"o\.\.o"                { /* comment */ ; parse_comment(yytext); }
X"oo"                    { /* comment */ ; parse_comment(yytext); }
X"o/o"                   { /* comment */ ; parse_comment(yytext); }
X"@\^"                   { /* comment */ ; parse_comment(yytext); }
X"etc"                   { /* comment */ ; parse_comment("etc"); }
X"ep"|"e\.p\."           { /* comment */ ; parse_comment("ep"); }
X\$[a-z][a-z][a-z]       { /* game comment */ ; parse_comment(yytext); }
X@[a-z]+\{		{ /* keyword with arg */ 
X  yytext[yyleng -1] = '\0' ;
X  parse_keyword(yytext, comment('}'));
X}
X@[a-z]+			{ /* keyword without arg */ 
X  parse_keyword(yytext,NULL); }
X"\["			{ parse_text(comment(']')); }
X"\("			{ parse_text(comment(')')); }
X"\{"                    { /* enter variation */ ; enter_variation(); }
X"\}"			{ /* close variation */ ; exit_variation(); }
X[\,;\.]			{ /* skip , ; */ ; }
X[ \t\v\n\f]             { /* skip blanks */; }
X.                      { /* ignore bad characters */ (void) fprintf(stderr,"I don't understand: %s\n",yytext);}
X%%
X
X#ifdef FLEX_SCANNER
X#undef yywrap
X#endif
X#ifdef __STDC__
Xint yywrap(void)
X#else
Xint yywrap()
X#endif
X{
X        return(1);
X}
X
X
X/* this procedure store comments in the text array commbuf
X   Escape char are allowed for putting the end-of-comment symbol
X   in the buffer
X   */
X#ifdef __STDC__
Xstatic char * comment(int closing)
X#else
Xstatic char * comment(closing)
X     char closing;
X#endif
X{
X  register char c;
X  register int i=0;
X
X  while ( ((c = input()) != closing)  && (c != 0) && (c != EOF)) {
X    commbuf[i] = c;
X    if (i <LARGE_BUF) i++ ;
X    
X    if (c == '\\') {
X      c = input() ;
X      if (c == closing)
X	commbuf[i-1] = c;
X      else
X	unput(c);
X    }
X  }
X  commbuf[i] = '\0' ;
X  return(commbuf);
X}
X
X#ifdef __STDC__
Xstatic void count(void)
X#else
Xstatic void count()
X#endif
X{
X  register int i;
X  register int k;
X
X  for (i = 0; yytext[i] != '\0'; i++) {
X    if (yytext[i] == '\n') {
X      column = 0;
X      for (k = 0 ; k< NCURLINE; k++) /*PANDORE*/
X        curline[k] = ' '; /*PANDORE*/
X      lineno++;
X    }
X    else if (yytext[i] == '\t') {
X      column += 8 - (column % 8);
X      curline[column] = yytext[i];
X    } else {
X      column++;
X      curline[column] = yytext[i];
X    }
X    curline[column+1]= '\0' ;
X  }
X  /*ECHO;*/
X}
END_OF_FILE
  if test 3990 -ne `wc -c <'lexer.l'`; then
    echo shar: \"'lexer.l'\" unpacked with wrong size!
  fi
  # end of 'lexer.l'
fi
if test -f 'symb.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'symb.tex'\"
else
  echo shar: Extracting \"'symb.tex'\" \(4157 characters\)
  sed "s/^X//" >'symb.tex' <<'END_OF_FILE'
X
X 	   check & \verb; +; & \verb; + ; &   + & \verb;  +; \cr
X
X 	   double check & \verb; ++; & \verb; ++ ; &   ++ & \verb;  ++; \cr
X
X 	   white stands lightly better & \verb; $wsb; & \verb; +=; &  \wbetter & \verb; \wbetter; \cr
X
X 	   black stands lightly better & \verb; $bsb; & \verb; =+; &  \bbetter & \verb; \bbetter; \cr
X
X 	   white has the upper hand & \verb; $wbe; & \verb; +_; &  \wupperhand & \verb; \wupperhand; \cr
X
X 	   black has the upper hand & \verb; $bbe; & \verb; _+; &  \bupperhand & \verb; \bupperhand; \cr
X
X 	   white has a decisive advantage & \verb; $wda; & \verb; +-; &  \wdecisive & \verb; \wdecisive; \cr
X
X 	   black has a decisive advantage & \verb; $bda; & \verb; -+; &  \bdecisive & \verb; \bdecisive; \cr
X
X 	   even & \verb; =  ; & \verb; =; &   \equal & \verb;  \equal; \cr
X
X 	   unclear & \verb; $ucr; & \verb; ~ ; &   \unclear & \verb;  \unclear; \cr
X
X 	   with compensation for the material & \verb; $wco; & \verb; =~ ; &   \compensation & \verb;  \compensation; \cr
X
X 	   development advantage & \verb; $dad; & \verb; (^) ; &   \devadvantage & \verb;  \devadvantage; \cr
X
X 	   greater space advantage & \verb; $spa; & \verb; () ; &   \moreroom & \verb;  \moreroom; \cr
X
X 	   with attack & \verb; $wta; & \verb; -> ; &   \withattack & \verb;  \withattack; \cr
X
X 	   with initiative & \verb; $win; & \verb; |^ ; &   \withinit & \verb;  \withinit; \cr
X
X 	   with counter-play & \verb; $wcp; & \verb; <-> ; &   \counterplay & \verb;  \counterplay; \cr
X
X 	   zugzwang & \verb; $zug; & \verb; (.) ; &   \zugzwang & \verb;  \zugzwang; \cr
X
X 	   mate & \verb; #; & \verb; # ; &   \mate & \verb;  \mate; \cr
X
X 	   very good move & \verb; !; & \verb; ! ; &   ! & \verb;  !; \cr
X
X 	   very bad move & \verb; ?; & \verb; ? ; &   ? & \verb;  ?; \cr
X
X 	   excellent move & \verb; !!; & \verb; !! ; &   !! & \verb;  !!; \cr
X
X 	   a mistake & \verb; ??; & \verb; ?? ; &   ?? & \verb;  ??; \cr
X
X 	   a move deserving attention & \verb; !?; & \verb; !? ; &   !? & \verb;  !?; \cr
X
X 	   a dubious move & \verb; ?!; & \verb; ?! ; &   ?! & \verb;  ?!; \cr
X
X 	   with the idea... & \verb; $wti; & \verb; /\ ; &   \withidea & \verb;  \withidea; \cr
X
X 	   only move & \verb; $olm; & \verb; [] ; &   \onlymove & \verb;  \onlymove; \cr
X
X 	   better is & \verb; $bei; & \verb; ^_ ; &   \betteris & \verb;  \betteris; \cr
X
X 	   file & \verb; $fil; & \verb; <=> ; &   \file & \verb;  \file; \cr
X
X 	   diagonal & \verb; $dia; & \verb; /^ ; &   \diagonal & \verb;  \diagonal; \cr
X
X 	   center & \verb; $cnt; & \verb; [+] ; &   \centre & \verb;  \centre; \cr
X
X 	   king's side & \verb; $kgs; & \verb; >> ; &   \kside & \verb;  \kside; \cr
X
X 	   queen's side & \verb; $qns; & \verb; << ; &   \qside & \verb;  \qside; \cr
X
X 	   weak point & \verb; $wkp; & \verb; >< ; &   \weakpt & \verb;  \weakpt; \cr
X
X 	   ending & \verb; $end; & \verb; _|_ ; &   \ending & \verb;  \ending; \cr
X
X 	   pair of bishops & \verb; $pob; & \verb; == ; &   \bishoppair & \verb;  \bishoppair; \cr
X
X 	   bishops of opposite colors & \verb; $opc; & \verb; =# ; &   \opposbishops & \verb;  \opposbishops; \cr
X
X 	   same coloured bishops & \verb; $scb; & \verb; ## ; &   \samebishops & \verb;  \samebishops; \cr
X
X 	   united pawns & \verb; $unp; & \verb; oo ; &   \unitedpawns & \verb;  \unitedpawns; \cr
X
X 	   separated pawns & \verb; $sep; & \verb; o..o ; &   \seppawns & \verb;  \seppawns; \cr
X
X 	   doubled pawns & \verb; $dop; & \verb; o/o ; &   \doublepawns & \verb;  \doublepawns; \cr
X
X 	   time & \verb; $tim; & \verb; (+) ; &   \timelimit & \verb;  \timelimit; \cr
X
X 	   novelty & \verb; $nov; & \verb; N ; &   \novelty & \verb;  \novelty; \cr
X
X 	   editorial comment & \verb; $com; & \verb; RR ; &   \comment & \verb;  \comment; \cr
X
X 	   various moves & \verb; $var; & \verb; R ; &   \various & \verb;  \various; \cr
X
X 	   without & \verb; $wto; & \verb; _| ; &   \without & \verb;  \without; \cr
X
X 	   etc & \verb; etc; & \verb; etc ; &   {etc} & \verb;  {etc}; \cr
X
X 	   etc & \verb; ||; & \verb; || ; &   \etc & \verb;  \etc; \cr
X
X 	   see & \verb; $see; & \verb;  ; &   \see & \verb;  \see; \cr
X
X 	   en passant & \verb; ep; & \verb; ep ; &   {ep} & \verb;  {ep}; \cr
X
END_OF_FILE
  if test 4157 -ne `wc -c <'symb.tex'`; then
    echo shar: \"'symb.tex'\" unpacked with wrong size!
  fi
  # end of 'symb.tex'
fi
if test -f 'symboles.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'symboles.tex'\"
else
  echo shar: Extracting \"'symboles.tex'\" \(396 characters\)
  sed "s/^X//" >'symboles.tex' <<'END_OF_FILE'
X\documentstyle[fullpage,chess]{article}
X\pagestyle{empty}
X\begin{document}
X%\title{A Menagerie of Chess Symbols}
X%\author{Henry Thomas}
X%\date{Mars 1990}
X%\maketitle
X
X\begin{nochess}
X\begin{center}
X\begin{tabular}{|c|c|c|c|l|}\hline
XComment & Abbrev.& Abbr. & Symbol & \LaTeX\ Keyword \\ \hline \hline
X\input{symb.tex}
X & & & & \\ \hline
X\end{tabular}
X\end{center}
X\end{nochess}
X
X\end{document}
X
END_OF_FILE
  if test 396 -ne `wc -c <'symboles.tex'`; then
    echo shar: \"'symboles.tex'\" unpacked with wrong size!
  fi
  # end of 'symboles.tex'
fi
if test -f 'symboles.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'symboles.txt'\"
else
  echo shar: Extracting \"'symboles.txt'\" \(1610 characters\)
  sed "s/^X//" >'symboles.txt' <<'END_OF_FILE'
Xcomment	shorthand 	english translation
X------------------------------------------------
X
X +  +   	   check
X
X ++  ++   	   double check
X
X $wsb  +=  	   white stands lightly better
X
X $bsb  =+  	   black stands lightly better
X
X $wbe  +_  	   white has the upper hand
X
X $bbe  _+  	   black has the upper hand
X
X $wda  +-  	   white has a decisive advantage
X
X $bda  -+  	   black has a decisive advantage
X
X =    =  	   even
X
X $ucr  ~   	   unclear
X
X $wco  =~   	   with compensation for the material
X
X $dad  (^)   	   development advantage
X
X $spa  ()   	   greater space advantage
X
X $wta  ->   	   with attack
X
X $win  |^   	   with initiative
X
X $wcp  <->   	   with counter-play
X
X $zug  (.)   	   zugzwang
X
X #  #   	   mate
X
X !  !   	   very good move
X
X ?  ?   	   very bad move
X
X !!  !!   	   excellent move
X
X ??  ??   	   a mistake
X
X !?  !?   	   a move deserving attention
X
X ?!  ?!   	   a dubious move
X
X $wti  /\   	   with the idea...
X
X $olm  []   	   only move
X
X $bei  ^_   	   better is
X
X $fil  <=>   	   file
X
X $dia  /^   	   diagonal
X
X $cnt  [+]   	   center
X
X $kgs  >>   	   king's side
X
X $qns  <<   	   queen's side
X
X $wkp  ><   	   weak point
X
X $end  _|_   	   ending
X
X $pob  ==   	   pair of bishops
X
X $opc  =#   	   bishops of opposite colors
X
X $scb  ##   	   same coloured bishops
X
X $unp  oo   	   united pawns
X
X $sep  o..o   	   separated pawns
X
X $dop  o/o   	   doubled pawns
X
X $tim  (+)   	   time
X
X $nov  N   	   novelty
X
X $com  RR   	   editorial comment
X
X $var  R   	   various moves
X
X $wto  _|   	   without
X
X etc  etc   	   etc
X
X ||  ||   	   etc
X
X $see     	   see
X
X ep  ep   	   en passant
X
END_OF_FILE
  if test 1610 -ne `wc -c <'symboles.txt'`; then
    echo shar: \"'symboles.txt'\" unpacked with wrong size!
  fi
  # end of 'symboles.txt'
fi
echo shar: End of archive 4 \(of 4\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
