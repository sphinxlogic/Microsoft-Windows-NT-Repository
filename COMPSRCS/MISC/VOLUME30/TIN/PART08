Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i008:  tin - threaded full screen newsreader, Part08/14
Message-ID: <1992May20.172708.29647@sparky.imd.sterling.com>
X-Md4-Signature: 1f08daadcd5d57916c35698dbeedda70
Date: Wed, 20 May 1992 17:27:08 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 8
Archive-name: tin/part08
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  TODO art.c lang.c
# Wrapped by kent@sparky on Tue May 19 13:38:04 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 8 (of 14)."'
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
  echo shar: Extracting \"'TODO'\" \(4958 characters\)
  sed "s/^X//" >'TODO' <<'END_OF_FILE'
X!!! PLEASE NOTE THAT ON CERTAIN MACHINES (ie. mostly RISC DEC,HP) TIN
X!!! WILL SOMETIMES CRASH WITH SIGBUS or SIGSEGV DUE TO THE HACK THAT
X!!! IS USED IN HASHING STRINGS IN hashstr.c. SORRY BUT I HAVE NO TIME
X!!! RIGHT NOW TO REIMPLEMENT THIS PART OF TIN WHICH IS A CARRY OVER
X!!! FROM TASS v3.2 (Any takers ?)
X
XFIX FEATURES V1.x
X-----------------
X
Xo  Fix spooldirs[] so it auto-expands as needed.
X
Xo  Fix num of hot arts in all/only unread mode. Calculate each time 'r'
X   is executed.
X
Xo  In inews.c also allow reply_to var to be used in From: field.
X
Xo  Fix -S option to create an active file when new articles are
X   saved to <savedir>. Also fix -R option to read ACTIVE file created
X   by -S command. Use minimax code from tony travis to help in -R cmd
X   line option.
X
Xo  In FAQ where it states machines that tin runs on, put a note about
X   people+net address that have ported to eg. Siemens MX2 but not
X   supported by main release.
X
Xo  Fix Sender: Path: headers within NNTP inews internally to tin
X   by a #define NNTP_INEWS
X
Xo  Fix Save in feed.c routines. 
X   Also fix so SAVING routines just use save_art_to_file() and print
X   *** X Articles saved *** & none of the BS done at the moment
X
Xo  Fix 'z' at group level so that as art is marked unread it is also 
X   checked to see if it is killed / hot.
X
Xo  Add option to 'M' menu to allow 'C' command to return/stay at
X   group level.
X
Xo  Fix 'c' at article level when within thread level?
X
Xo  Fix -n option to hash the groups read in from ~/.tin/active and
X   mark active[].flag as TRUE. then find flag=FALSE and ask user if
X   they want to subscribe to group. On xenix386 takes 15 seconds on
X   current -n option. Also of CNEWS just do a compare of active.times
X   UNDER CNEWS USE active.times FILE FROM NNTPSERVER
X   UNDER NNTP USE newnews COMMAND FROM NNTPSERVER
X
Xo  Add 'r' command to newsgroup level.
X
XFIX FEATURES V2.0
X-----------------
X
Xo  If saving in mailbox format and mailbox does not exist query the user?
X
Xo  In kill.c should kill_both only kill when subj & from are matched?
X
Xo  Add file ~/.tin/tinheaders for following headers to be stored:
X     Reply-To:
X     Organisation:
X     Distribution:
X 
Xo  Make binary as both standalone & NNTP as default
X
Xo  Add Ctrl-/ Ctrl-? to search the whole of an article (Subj,From & Body)
X   at Group & Page level
X
Xo  Add elm like mini-menu to tin for first time users.
X
Xo  Add option to 'M' menu to allow unlinking/not of ~/.article
X   after posting an article.
X
Xo  Add hashing to speedup valid_art() in big groups. Make it compile
X   option so tin is still usable on Minix/small memory machines.
X   -DSMALL_MEMORY_MACHINE
X
Xo  Add auto-aliasing of peoples mail addresses to mail aliases file.
X
Xo  Add Xref handling of articles so that read ones are marked read in 
X   other groups. Use update_group() to do it?
X   Needs to handle 'c' 'C' 'k' 'K' commands. Perhaps it should be an
X   option so that performance is not impaired. (JIM).
X
Xo  Add ^G command to skip to next Subject: in digests.
X
Xo  Try compiling with -D_POSIX_SOURCE
X
Xo  Add filename & groupname completion.
X
Xo  Fix uuscram code in uudecode.
X
Xo  Fix code to sort arts. At page level funny things happen.
X
XADD FEATURES
X------------
X
Xo  Add -P <pattern> or -P <file> to search for in new news and to
X   notify user by mail. Should understand 'subject=text' 'from=text'
X   'body=text' and .AND. && .OR. || for filtering purposes.
X
Xo  Add elm style print command with %s in it for printing in 'M'.
X
Xo  Add 'C' command at group level to catchup present group and
X   enter next group with unread news in it.
X
Xo  Sort .newsrc according to preference. (sort active file as it is read)
X
Xo  Add time period to killing articles
X
XOTHER STUFF
X-----------
Xo  Add rebindable keymaps and provide different terminal keymaps
X   (ie. keymap.ansi, keymap.wy50 etc.)
X
Xo  Add Virtual newsgroups (combination of newsgroups ie. virtual.ibm
X   consists of comp.sys.ibm.* groups).
X
Xo  Add threading on References like trn with mthreads database.
X
Xo  Add full curses support instead of using printf()'s or joetty.
X
Xo  Sub all not empty groups by looking at min max values in active array
X   and Unsub all empty groups by looking at min max values in active 
X   array. have a command to do this in a toggle effect.
X
Xo  Run tests of my_strncpy() and system strncpy()
X
Xo  Change defaults on a per group basis
XGroup        Connect   Read    Thread    Save  Savedir  Maildir  Sigfile    
X                       Unread  Unthread  Mail  ProcTyp  Mailbox
X-----------------------------------------------------------------------------
Xjunk         local     Unread  Thread    None  Default  Default  Default
Xalt.sources  1.3.3.3   Read    Thread    Save  $SRC/alt Default  ~/.Sig-alt
X
XAdd a menu interface to define all this. Also add edit menu for entries in
Xkill file.
X
XEach group could have a field to say which NNTP/local connection to use so
Xas to be able to plug into different NNTP servers for different newsgroups
END_OF_FILE
  if test 4958 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
  fi
  # end of 'TODO'
fi
if test -f 'art.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'art.c'\"
else
  echo shar: Extracting \"'art.c'\" \(22838 characters\)
  sed "s/^X//" >'art.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : art.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 12-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xchar index_file[PATH_LEN];
Xchar *glob_art_group;
Xstatic long last_read_article;
X
X
X/*
X *  Construct the pointers to the basenotes of each thread
X *  arts[] contains every article in the group.  inthread is
X *  set on each article that is after the first article in the
X *  thread.  Articles which have been expired have their thread
X *  set to -2 (ART_EXPIRED).
X */
X
Xvoid find_base (only_unread)
X	int only_unread;
X{
X	register int i;
X	register int j;
X
X	top_base = 0;
X
X	debug_print_arts ();
X
X	if (only_unread) {
X		for (i = 0; i < top; i++) {
X			if (IGNORE_ART(i) || arts[i].inthread != FALSE) {
X				continue;
X			}	
X			if (top_base >= max_art) {
X				expand_art ();
X			}
X			if (arts[i].unread == ART_UNREAD) {
X				base[top_base++] = i;
X			} else {
X				for (j = i ; j >= 0 ; j = arts[j].thread) {
X					if (arts[j].unread) {
X						base[top_base++] = i;
X						break;
X					}
X				}
X			}
X		}
X	} else {
X		for (i = 0; i < top; i++) {
X			if (IGNORE_ART(i) || arts[i].inthread != FALSE) {
X				continue;
X			}	
X			if (top_base >= max_art) {
X				expand_art ();
X			}
X			base[top_base++] = i;
X		}
X	}
X}
X
X/* 
X *  Count the number of non-expired articles in arts[]
X */
X
Xint num_of_arts ()
X{
X	int sum = 0;
X	register int i;
X
X	for (i = 0; i < top; i++) {
X		if (arts[i].thread != ART_EXPIRED) {
X			sum++;
X		}
X	}
X
X	return sum;
X}
X
X/*
X *  Do we have an entry for article art?
X */
X
Xint valid_artnum (art)
X	long art;
X{
X	register int i;
X
X	for (i = 0; i < top; i++)
X		if (arts[i].artnum == art)
X			return i;
X
X	return -1;
X}
X
X/*
X *  Return TRUE if arts[] contains any expired articles
X *  (articles we have an entry for which don't have a corresponding
X *   article file in the spool directory)
X */
X
Xint purge_needed ()
X{
X	register int i;
X
X	for (i = 0; i < top; i++)
X		if (arts[i].thread == ART_EXPIRED)
X			return TRUE;
X
X	return FALSE;
X}
X
X/*
X *  Main group indexing routine.  Group should be the name of the
X *  newsgroup, i.e. "comp.unix.amiga".  group_path should be the
X *  same but with the .'s turned into /'s: "comp/unix/amiga"
X *
X *  Will read any existing index, create or incrementally update
X *  the index by looking at the articles in the spool directory,
X *  and attempt to write a new index if necessary.
X */
X
Xvoid index_group (group, group_path)
X	char *group;
X	char *group_path;
X{
X	int killed = FALSE;
X	int modified = FALSE;
X	glob_art_group = group;
X
X	set_signals_art ();
X	
X	if (! update) {
X		sprintf (msg, txt_group, group);
X		wait_message (msg);
X	}
X	hash_reclaim ();
X	free_art_array ();
X
X	/*
X	 *  load articles from index file if it exists
X	 */
X	read_index_file (group);
X
X	/*
X	 *  add any articles to arts[] that are new or were killed
X	 */
X	modified = read_group (group, group_path);
X
X	if (modified || purge_needed ()) {
X		write_index_file (group);
X	}
X	read_newsrc_line (group);
X	killed = kill_any_articles (group); /* do after read_newsrc_line() */
X	make_threads (FALSE);
X	find_base (show_only_unread);
X	
X	if ((modified || killed) && ! update) {
X		clear_message ();
X	}
X}
X
X/*
X *  Index a group.  Assumes any existing index has already been
X *  loaded.
X */
X
Xint read_group (group, group_path)
X	char *group;
X	char *group_path;
X{
X	FILE *fp;
X	int count = 0;
X	int modified = FALSE;
X	int respnum;
X	long art;
X	register int i;
X
X	setup_base (group, group_path);	/* load article numbers into base[] */
X
X	for (i = 0; i < top_base; i++) {	/* for each article # */
X		art = base[i];
X
X/*
X *  Do we already have this article in our index?  Change thread from
X *  (ART_EXPIRED) to (ART_NORMAL) if so and skip the header eating.
X */
X
X		if ((respnum = valid_artnum (art)) >= 0 || art <= last_read_article) {
X			if (respnum >= 0) {
X				arts[respnum].thread = ART_NORMAL;
X				arts[respnum].unread = ART_UNREAD;
X			}	
X			continue;
X		}
X
X		if (! modified) {
X			modified = TRUE;   /* we've modified the index */
X							   /* it will need to be re-written */
X		}
X
X		if ((fp = open_header_fp (group_path, art)) == (FILE *) 0) {
X			continue;
X		}
X		
X		/*
X		 *  Add article to arts[]
X		 */
X		if (top >= max_art)
X			expand_art();
X
X		arts[top].artnum = art;
X		arts[top].thread = ART_NORMAL;
X
X		set_article (&arts[top]);
X
X		if (! parse_headers (fp, &arts[top])) {
X			debug_nntp ("read_group", "FAILED parse_header()");
X			continue;
X		}
X
X		fclose (fp);
X		last_read_article = arts[top].artnum;	/* used if arts are killed */
X		top++;
X
X		if (++count % MODULO_COUNT_NUM == 0 && ! update) {
X#ifndef SLOW_SCREEN_UPDATE
X			sprintf (msg, txt_indexing_num, group, count);
X#else
X			sprintf (msg, txt_indexing, group);
X#endif
X			wait_message (msg);
X		}
X	}
X
X	return modified;
X}
X
X
X/*
X *  Go through the articles in arts[] and use .thread to snake threads
X *  through them.  Use the subject line to construct threads.  The
X *  first article in a thread should have .inthread set to FALSE, the
X *  rest TRUE.  Only do unexprired articles we haven't visited yet
X *  (arts[].thread == -1 ART_NORMAL).
X */
X
Xvoid make_threads (rethread)
X	int rethread;
X{
X	extern int cur_groupnum;
X	register int i;
X	register int j;
X
X	if (!cmd_line) {
X		if (thread_arts) {
X			wait_message (txt_threading_arts);
X		} else {
X			wait_message (txt_unthreading_arts);
X		}
X	}
X
X	/*
X	 *  .thread & .inthread need to be reset if re-threading arts[]
X	 */
X	if (rethread && active[my_group[cur_groupnum]].attribute.thread) {
X		for (i=0 ; i < top ; i++) {
X			arts[i].thread = ART_NORMAL;
X			arts[i].inthread = FALSE;
X		}
X	}
X
X	switch (sort_art_type) {
X		case SORT_BY_NOTHING:		/* don't sort at all */
X			qsort ((char *) arts, top, sizeof (struct article_t), artnum_comp);
X			break;
X		case SORT_BY_SUBJ_DESCEND:
X		case SORT_BY_SUBJ_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), subj_comp);
X			break;
X		case SORT_BY_FROM_DESCEND:
X		case SORT_BY_FROM_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), from_comp);
X			break;
X		case SORT_BY_DATE_DESCEND:
X		case SORT_BY_DATE_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), date_comp);
X			break;
X		default:
X			break;
X	}
X
X	if (thread_arts == 0 || active[my_group[cur_groupnum]].attribute.thread == 0) {
X		return;
X	}
X
X	for (i = 0; i < top; i++) {
X		if (arts[i].thread != ART_NORMAL || IGNORE_ART(i)) {
X			continue;
X		}	
X		for (j = i+1; j < top; j++) {
X			if (! IGNORE_ART(j) && 
X			   ((arts[i].subject == arts[j].subject) ||
X			   ((arts[i].part || arts[i].patch) &&
X			   arts[i].archive == arts[j].archive))) {
X				arts[i].thread = j;
X				arts[j].inthread = TRUE;
X				break;
X			}
X		}
X	}
X}
X
X
Xint parse_headers (fp, h)
X	FILE *fp;
X	struct article_t *h;
X{
X	char buf[HEADER_LEN];
X	char buf2[HEADER_LEN];
X	char art_from_addr[LEN];
X	char art_full_name[LEN];
X	char *ptr, *ptrline, *s;
X	int n = 0, len = 0, lineno = 0;
X	int flag;
X	int got_subject = FALSE;
X	int got_from = FALSE;
X	int got_date = FALSE;
X	int got_archive = FALSE;
X	extern int errno;
X	
X	buf[HEADER_LEN-1] = '\0';
X
X	while (fread (buf, sizeof (buf)-1, 1, fp) != 1 && errno == EINTR)
X		;		/* spin on signal interrupts */
X
X	if ((n = strlen (buf)) == 0) {
X		return FALSE;
X	}
X
X	buf[n-1] = '\0';
X
X	ptr = buf;
X
X	while (1) {
X		for (ptrline = ptr; *ptr && *ptr != '\n'; ptr++) {
X			if (((*ptr) & 0xFF) < ' ') {
X				*ptr = ' ';
X			}
X		}
X		flag = *ptr;
X		*ptr++ = '\0';
X		lineno++;
X
X		if (! got_from && match_header (ptrline, "From", buf2, HEADER_LEN)) {
X			parse_from (buf2, art_from_addr, art_full_name); 
X			h->from = hash_str (art_from_addr);
X			h->name = hash_str (art_full_name);
X			got_from = TRUE;
X		} else if (! got_subject && match_header (ptrline, "Subject", buf2, HEADER_LEN)) {
X			s = eat_re (buf2);
X			h->subject = hash_str (eat_re (s));
X			got_subject = TRUE;
X		} else if (! got_date && match_header (ptrline, "Date", buf2, HEADER_LEN)) {
X			parse_date (buf2, h->date);
X			got_date = TRUE;
X		} else if (match_header (ptrline, "Archive-name", buf2, HEADER_LEN) ||
X					match_header (ptrline, "Archive-Name", buf2, HEADER_LEN)) {
X			if ((s = (char *) strchr (buf2, '/')) != NULL) {
X				if (strncmp (s+1, "part", 4) == 0 ||
X				    strncmp (s+1, "Part", 4) == 0) {
X					h->part = str_dup (s+5);
X					len = (int) strlen (h->part);
X					if (h->part[len-1] == '\n') {
X						h->part[len-1] = '\0';
X					}
X				} else {
X					if (strncmp (s+1,"patch",5) == 0 ||
X					    strncmp (s+1,"Patch",5) == 0) {
X						h->patch = str_dup (s+6);
X						len = (int) strlen (h->patch);
X						if (h->patch[len-1] == '\n') {
X							h->patch[len-1] = '\0';
X						}
X					}
X				}
X				if (h->part || h->patch) {
X					s = buf2;
X					while (*s && *s != '/')
X						s++;
X					*s = '\0';	
X					s = buf2;
X					h->archive = hash_str (s);
X					got_archive = TRUE;
X				}
X			}
X		}
X
X		if (! flag || lineno > 25 || got_archive) {
X			if (got_subject && got_from && got_date) {
X				debug_print_header (h);
X				return TRUE;
X			} else {
X				return FALSE;
X			}	
X		}
X	}
X	/* NOTREACHED */
X}
X
X/* 
X *  Write out  an index file.  Write the group name first so if
X *  local indexing is done so we can disambiguate between group
X *  name hash collisions by looking at the index file.
X */
X
Xvoid write_index_file (group)
X	char *group;
X{
X	char nam[LEN];
X	FILE *fp;
X	int *iptr;
X	int realnum;
X	register int i;
X
X	set_tin_uid_gid();
X
X        sprintf (nam, "%s.%d", index_file, process_id);
X	if ((fp = fopen (nam, "w")) == NULL) {
X		perror_message (txt_cannot_open, nam);
X		return;
X	}
X
X	/*
X	 *  dump group header info.
X	 */
X	if (sort_art_type != SORT_BY_NOTHING) {
X		qsort ((char *) arts, top, sizeof (struct article_t), artnum_comp);
X	}
X	fprintf (fp, "%s\n", group);
X	fprintf (fp, "%d\n", num_of_arts ());
X	if (top <= 0) {
X		fprintf (fp, "0\n");
X	} else {
X		if (last_read_article > arts[top-1].artnum) {
X			fprintf (fp, "%ld\n", last_read_article);
X		} else {
X			fprintf (fp, "%ld\n", arts[top-1].artnum);
X		}
X	}
X
X	/*
X	 *  dump articles
X	 */
X	realnum = 0; 
X	for (i = 0; i < top; i++) {
X		if (arts[i].thread == ART_EXPIRED) { 
X			continue;
X		}
X#ifdef DEBUG			
X		debug_print_header (&arts[i]);
X#endif
X		fprintf(fp, "%ld\n", arts[i].artnum);
X
X		iptr = (int *) arts[i].subject;
X		iptr--;
X
X		if (! arts[i].subject) {
X			fprintf(fp, " \n");
X		} else if (*iptr < 0 || *iptr > top) {
X			fprintf(fp, " %s\n", arts[i].subject);
X			*iptr = realnum;
X		} else if (*iptr == i) {
X			fprintf(fp, " %s\n", arts[i].subject);
X		} else {
X			fprintf(fp, "%%%d\n", *iptr);
X		}
X	
X		iptr = (int *) arts[i].from;
X		iptr--;
X
X		if (! arts[i].from) {
X			fprintf (fp, " \n");
X		} else if (*iptr < 0 || *iptr > top) {
X			fprintf (fp, " %s\n", arts[i].from);
X			*iptr = realnum;
X		} else if (*iptr == i) {
X			fprintf(fp, " %s\n", arts[i].from);
X		} else {
X			fprintf(fp, "%%%d\n", *iptr);
X		}
X
X		iptr = (int *) arts[i].name;
X		iptr--;
X
X		if (! arts[i].name) {
X			fprintf (fp, " \n");
X		} else if (*iptr < 0 || *iptr > top) {
X			fprintf (fp, " %s\n", arts[i].name);
X			*iptr = realnum;
X		} else if (*iptr == i) {
X			fprintf(fp, " %s\n", arts[i].name);
X		} else {
X			fprintf(fp, "%%%d\n", *iptr);
X		}
X
X		fprintf (fp, "%s\n", arts[i].date);
X			
X		iptr = (int *) arts[i].archive;
X		iptr--;
X
X		if (! arts[i].archive) {
X			fprintf (fp, "\n");
X		} else if (*iptr < 0 || *iptr > top) {
X			fprintf (fp, " %s\n", arts[i].archive);
X			*iptr = realnum;
X		} else if (arts[i].part || arts[i].patch) {
X			if (*iptr == i) {
X				fprintf(fp, " %s\n", arts[i].archive);
X			} else {
X				fprintf (fp, "%%%d\n", *iptr);
X			}
X		} else {
X			fprintf (fp, "\n");
X		}
X			
X		if (! arts[i].part) {
X			fprintf (fp, " \n");
X		} else {
X			fprintf (fp, "%s\n", arts[i].part);
X		}
X
X		if (! arts[i].patch) {
X			fprintf (fp, " \n");
X		} else {
X			fprintf (fp, "%s\n", arts[i].patch);
X		}
X
X		realnum++;
X	}
X	fclose (fp);
X	rename_file (nam, index_file);
X	chmod (index_file, 0644);
X	set_real_uid_gid();
X	if (debug == 2) {
X		sprintf (msg, "cp %s INDEX", index_file);
X		system (msg);
X	}
X}
X
X/*
X *  Read in an index file.
X *
X *  index file header 
X *    1.  newsgroup name (ie. alt.sources)
X *    2.  number of articles (ie. 26)
X *    3.  number of last read article (ie. 210)
X *    4.  Is this a complete/killed index file (ie. COMPLETE/KILLED)
X *
X *  index file record
X *    1.  article number    (ie. 183)               [mandatory]
X *    2.  Subject: line     (ie. Which newsreader?) [mandatory]
X *    3.  From: line (addr) (ie. iain@norisc)       [mandatory]
X *    4.  From: line (name) (ie. Iain Lea)          [mandatory]
X *    5.  Date: of posting  (ie. 911231125959)      [mandatory]
X *    6.  Archive: name     (ie. compiler)          [optional]
X *    7.  Part number of Archive: name  (ie. 01)    [optional]
X *    8.  Patch number of Archive: name (ie. 01)    [optional]
X */
X
Xint read_index_file (group_name)
X	char *group_name;
X{
X	int error = 0;
X	int i, n;
X	char buf[LEN], *p;
X	FILE *fp = NULL;
X
X	top = 0;
X	last_read_article = 0L;
X
X	if ((fp = open_index_fp (group_name)) == NULL) {
X		return FALSE;
X	}
X
X	/*
X	 *  load header - discard group name, num. of arts in index file after any arts were killed
X	 */
X	if (fgets(buf, sizeof buf, fp) == NULL ||
X		fgets(buf, sizeof buf, fp) == NULL) {
X		error = 0;			
X		goto corrupt_index;	
X	}
X	i = atoi (buf);
X
X	/*
X	 * num. of last_read_article including any that were killed
X	 */
X	if (fgets(buf, sizeof buf, fp) == NULL) {
X		error = 1;				
X		goto corrupt_index;	
X	}							
X	last_read_article = (long) atol (buf);
X	
X	/*
X	 *  load articles
X	 */
X	for (; top < i ; top++) {
X		if (top >= max_art) {
X			expand_art ();
X		}
X
X		arts[top].thread = ART_EXPIRED;
X		set_article (&arts[top]);
X
X		/*
X		 * Article no.
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 2;
X			goto corrupt_index;
X		}
X		arts[top].artnum = (long) atol (buf);
X
X		/*
X		 * Subject:
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 3;
X			goto corrupt_index;
X		}
X
X		if (buf[0] == '%') {
X			n = atoi (&buf[1]);
X			if (n >= top || n < 0) {
X				error = 4;
X				goto corrupt_index;
X			}
X			arts[top].subject = arts[n].subject;
X		} else if (buf[0] == ' ') {
X			for (p = &buf[1];  *p && *p != '\n'; p++)
X				continue;	
X			*p = '\0';
X			arts[top].subject = hash_str (&buf[1]);
X		} else {
X			error = 5;
X			goto corrupt_index;
X		}
X			
X		/*
X		 * From: (addr part)
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 6;
X			goto corrupt_index;
X		}
X
X		if (buf[0] == '%') {
X			n = atoi (&buf[1]);
X			if (n >= top || n < 0) {
X				error = 7;
X				goto corrupt_index;
X			}
X			arts[top].from = arts[n].from;
X		} else if (buf[0] == ' ') {
X			for (p = &buf[1];  *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X			arts[top].from = hash_str (&buf[1]);
X		} else {
X			error = 8;
X			goto corrupt_index;
X		}
X
X		/*
X		 * From: (full name)
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 9;
X			goto corrupt_index;
X		}
X
X		if (buf[0] == '%') {
X			n = atoi (&buf[1]);
X			if (n > top || n < 0) {
X				error = 10;
X				goto corrupt_index;
X			}
X			if (n == top) {		/* no full name so .name = .from */
X				arts[top].name = arts[top].from;
X			} else {
X				arts[top].name = arts[n].name;
X			}
X		} else if (buf[0] == ' ') {
X			for (p = &buf[1];  *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X			arts[top].name = hash_str (&buf[1]);
X		} else {
X			error = 11;
X			goto corrupt_index;
X		}
X
X		/*
X		 * Date:
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 12;
X			goto corrupt_index;
X		}
X
X		buf[strlen (buf)-1] = '\0';
X		my_strncpy (arts[top].date, buf, 12);
X
X		/*
X		 * Archive-name:
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 13;
X			goto corrupt_index;
X		}
X
X		if (buf[0] == '\n') {
X			arts[top].archive = (char *) 0;
X		} else if (buf[0] == '%') {
X			n = atoi (&buf[1]);
X			if (n > top || n < 0) {
X				error = 14;
X				goto corrupt_index;
X			}
X			arts[top].archive = arts[n].archive;
X		} else if (buf[0] == ' ') {
X			for (p = &buf[1]; *p && *p != '\n' ; p++)
X				continue;
X			*p = '\0';
X			arts[top].archive = hash_str (&buf[1]);
X		} else {
X			error = 15;
X			goto corrupt_index;
X		}
X
X		/*
X		 * part no.
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 16;
X			goto corrupt_index;
X		}
X
X		if (buf[0] != ' ') { 
X			buf[strlen (buf)-1] = '\0';
X			arts[top].part = str_dup (buf);
X		}
X
X		/*
X		 * patch no.
X		 */
X		if (fgets(buf, sizeof buf, fp) == NULL) {
X			error = 17;
X			goto corrupt_index;
X		}
X
X		if (buf[0] != ' ') { 
X			buf[strlen (buf)-1] = '\0';
X			arts[top].patch = str_dup (buf);
X		}
X
X		debug_print_header (&arts[top]);
X	}
X
X	fclose(fp);
X	return TRUE;
X
Xcorrupt_index:
X	if (! update) {
X		sprintf (msg, txt_corrupt_index, index_file, error, top); 
X		error_message (msg, "");
X	}
X
X	if (debug == 2) {
X		sprintf (msg, "cp %s INDEX.BAD", index_file);
X		system (msg);
X	}
X
X	last_read_article = 0L;
X	if (fp) {
X		fclose(fp);
X	}	
X	set_tin_uid_gid();
X	unlink (index_file);
X	set_real_uid_gid();
X	top = 0;
X	return FALSE;
X}
X
X
X/*
X *  Look in the local $HOME/RCDIR/INDEXDIR (or wherever) directory for the
X *  index file for the given group.  Hashing the group name gets
X *  a number.  See if that #.1 file exists; if so, read first line.
X *  Group we want?  If no, try #.2.  Repeat until no such file or
X *  we find an existing file that matches our group.
X */
X
Xvoid find_index_file (group)
X	char *group;
X{
X	char *p;
X	FILE *fp;
X	int i = 1;
X	static char buf[LEN];
X	char dir[PATH_LEN];
X	unsigned long h;
X
X	h = hash_groupname (group);
X
X	if (read_news_via_nntp && xindex_supported) {
X		sprintf (index_file, "/tmp/xindex.%d", process_id);
X		return;
X	}
X	
X	if (local_index) {
X		my_strncpy (dir, indexdir, sizeof (dir));
X	} else {
X		sprintf (dir, "%s/%s", spooldir, INDEXDIR);
X	}
X	
X	while (TRUE) {
X		sprintf (index_file, "%s/%lu.%d", dir, h, i);
X		
X		if ((fp = fopen (index_file, "r")) == (FILE *) 0) {
X			return;
X		}
X
X		if (fgets (buf, sizeof (buf), fp) == (char *) 0) {
X			fclose (fp);
X			return;
X		}
X		fclose (fp);
X
X		for (p = buf; *p && *p != '\n'; p++) {
X			continue;
X		}	
X		*p = '\0';
X
X		if (strcmp (buf, group) == 0) {
X			return;
X		}	
X		i++;
X	}	
X}
X
X/*
X *  Run the index file updater only for the groups we've loaded.
X */
X
Xvoid do_update ()
X{
X	int i, j;
X	char group_path[PATH_LEN];
X	char *p;
X	long beg_epoch, end_epoch;
X	
X	if (verbose) {
X		time (&beg_epoch);
X	}
X
X	for (i = 0; i < group_top; i++) {
X		my_strncpy (group_path, active[my_group[i]].name, sizeof (group_path));
X		for (p = group_path ; *p ; p++) {
X			if (*p == '.') {
X				*p = '/';
X			}
X		}
X		if (verbose) {
X			printf ("%s %s\n", (catchup ? "Catchup" : "Updating"),
X					active[my_group[i]].name);
X			fflush (stdout);
X		}
X		index_group (active[my_group[i]].name, group_path);
X		if (catchup) {
X			for (j = 0; j < top; j++) {
X				arts[j].unread = ART_READ;
X			}
X			update_newsrc (active[my_group[i]].name, my_group[i], FALSE);
X		}
X	}
X
X	if (verbose) {
X		time (&end_epoch);
X		sprintf (msg, "%s %d groups in %ld seconds\n", 
X			(catchup ? "Caughtup" : "Updated"), group_top, end_epoch - beg_epoch);
X		wait_message (msg);
X	}
X}
X
X/*
X * convert date from ctime format to sortable format
X * "24 Jul 91 12:59:59", "Mon, 24 Jul 91 12:59:59" and
X * "Mon, 24 Jul 1991 12:59:59" are parsed and produce
X * output of the form "910724125959"
X */
X
Xchar *parse_date (date, str)
X	char *date;
X	char *str;
X{
X	char buf[4];
X	int i = 0;
X
X	/* Check for extraneous day-of-week at start of date */
X	while (isalpha(date[i]) || date[i] == ',' || date[i] == ' ') {
X		i++;
X	}
X	
X	if (date[i+1] == ' ') {	/* ie. "2 Aug..." instead of "12 Aug... */
X		str[4] = '0';		/* day */
X		str[5] = date[i++];
X		i++;
X	} else {
X		str[4] = date[i++];		/* day */
X		str[5] = date[i++];
X		i++;
X	}
X	
X	buf[0] = date[i++];		/* month in Jan,Feb,.. form */
X	buf[1] = date[i++];
X	buf[2] = date[i++];
X	buf[3] = '\0';
X
X	i++;
X	
X	str[0] = date[i++];		/* year */
X	str[1] = date[i++];
X	if (isdigit(date[i])) {         /* 19xx format */
X		str[0] = date[i++];
X		str[1] = date[i++];
X	}
X	
X	i++;
X	
X	if (strcmp (buf, "Jan") == 0) {		/* convert Jan to 01 etc */
X		str[2] = '0';
X		str[3] = '1';
X	} else if (strcmp (buf, "Feb") == 0) {
X		str[2] = '0';
X		str[3] = '2';
X	} else if (strcmp (buf, "Mar") == 0) {
X		str[2] = '0';
X		str[3] = '3';
X	} else if (strcmp (buf, "Apr") == 0) {
X		str[2] = '0';
X		str[3] = '4';
X	} else if (strcmp (buf, "May") == 0) {
X		str[2] = '0';
X		str[3] = '5';
X	} else if (strcmp (buf, "Jun") == 0) {
X		str[2] = '0';
X		str[3] = '6';
X	} else if (strcmp (buf, "Jul") == 0) {
X		str[2] = '0';
X		str[3] = '7';
X	} else if (strcmp (buf, "Aug") == 0) {
X		str[2] = '0';
X		str[3] = '8';
X	} else if (strcmp (buf, "Sep") == 0) {
X		str[2] = '0';
X		str[3] = '9';
X	} else if (strcmp (buf, "Oct") == 0) {
X		str[2] = '1';
X		str[3] = '0';
X	} else if (strcmp (buf, "Nov") == 0) {
X		str[2] = '1';
X		str[3] = '1';
X	} else if (strcmp (buf, "Dec") == 0) {
X		str[2] = '1';
X		str[3] = '2';
X	} else {
X		str[2] = '0';
X		str[3] = '0';
X	}
X	
X	str[6] = date[i++];		/* hour */
X	str[7] = date[i++];
X
X	i++;
X	
X	str[8] = date[i++];		/* minutes */
X	str[9] = date[i++];
X	
X	i++;
X	
X	str[10] = date[i++];	/* seconds */
X	str[11] = date[i++];
X
X	str[12] = '\0';		/* terminate string */
X
X	return (str);
X}
X
X
Xint artnum_comp (p1, p2)
X	char *p1;
X	char *p2;
X{
X	struct article_t *s1 = (struct article_t *) p1;
X	struct article_t *s2 = (struct article_t *) p2;
X
X	/* s1->artnum less than s2->artnum */
X	if (s1->artnum < s2->artnum) {
X		return -1;
X	}
X	/* s1->artnum greater than s2->artnum */
X	if (s1->artnum > s2->artnum) {
X		return 1;
X	}
X	return 0;
X}
X
X
Xint subj_comp (p1, p2)
X	char *p1;
X	char *p2;
X{
X	struct article_t *s1 = (struct article_t *) p1;
X	struct article_t *s2 = (struct article_t *) p2;
X
X	/* return result of strcmp (reversed for descending) */
X	return (sort_art_type == SORT_BY_SUBJ_ASCEND 
X			? my_stricmp (s1->subject, s2->subject) 
X			: my_stricmp (s2->subject, s1->subject));
X}
X
X
Xint from_comp (p1, p2)
X	char *p1;
X	char *p2;
X{
X	struct article_t *s1 = (struct article_t *) p1;
X	struct article_t *s2 = (struct article_t *) p2;
X
X	/* return result of strcmp (reversed for descending) */
X	return (sort_art_type == SORT_BY_FROM_ASCEND 
X			? my_stricmp (s1->from, s2->from) 
X			: my_stricmp (s2->from, s1->from));
X}
X
X
Xint date_comp (p1, p2)
X	char *p1;
X	char *p2;
X{
X	struct article_t *s1 = (struct article_t *) p1;
X	struct article_t *s2 = (struct article_t *) p2;
X	/* return result of strcmp (reversed for descending) */
X	return (sort_art_type == SORT_BY_DATE_ASCEND 
X			? strcmp (s1->date, s2->date) 
X			: strcmp (s2->date, s1->date));
X}
X
X
Xvoid set_article (art)
X	struct article_t *art;
X{	
X	art->subject = (char *) 0;
X	art->from = (char *) 0;
X	art->name = (char *) 0;
X	art->date[0] = '\0';
X	art->archive = (char *) 0;
X	art->part = (char *) 0;
X	art->patch = (char *) 0;
X	art->unread = ART_UNREAD;
X	art->inthread = FALSE;
X	art->killed = FALSE;
X	art->tagged = FALSE;
X	art->hot = FALSE;
X}
END_OF_FILE
  if test 22838 -ne `wc -c <'art.c'`; then
    echo shar: \"'art.c'\" unpacked with wrong size!
  fi
  # end of 'art.c'
fi
if test -f 'lang.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lang.c'\"
else
  echo shar: Extracting \"'lang.c'\" \(22813 characters\)
  sed "s/^X//" >'lang.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : lang.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 12-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X/*
X * active.c
X */
X 
Xchar txt_subscribe_to_new_group[] = "Subscribe to %s (y/n): ";
Xchar txt_delete_bogus_group[] = "Remove bogus group %s (y/n): ";
X
X/*
X *  art.c
X */
X
Xchar txt_group[] = "Group %s...";
Xchar txt_cannot_open_art[] = "can't open article %s: ";
Xchar txt_indexing[] = "Indexing %s...";
Xchar txt_indexing_num[] = "Indexing %s...%4d";
Xchar txt_corrupt_index[] = "Index file %s corrupted. error %d on article %d";
Xchar txt_checking_for_news[] = "Checking for news...";
Xchar txt_there_is_no_news[] = "There is no news\n";
Xchar txt_killing_arts[] = "Selecting articles...";
Xchar txt_unkilling_arts[] = "Unselecting articles...";
X
X/*
X *  feed.c
X */
X
Xchar txt_art_thread_regex_tag[] = " a)rticle, t)hread, h)ot, p)attern, T)agged articles, q)uit: ";
Xchar txt_post_process_type[] = "Process n)one, s)har, u)udecode, U)udecode & zoo: ";
X#ifdef NO_REGEX 
Xchar txt_feed_pattern[] = "Enter pattern [%s]> ";
X#else
Xchar txt_feed_pattern[] = "Enter regex pattern [%s]> ";
X#endif
Xchar txt_no_command[] = "No command";
Xchar txt_piping[] = "Piping...";
Xchar txt_saved[] = "-- %d Article(s) saved --";
X
X/*
X *  group.c
X */
X
Xchar txt_cannot_post[] = "*** Posting not allowed ***";
Xchar txt_tagged_art[] = "Tagged article";
Xchar txt_untagged_art[] = "Uuntagged article";
Xchar txt_inverse_on[] = "Inverse video enabled";
Xchar txt_inverse_off[] = "Inverse video disabled";
Xchar txt_subscribed_to[] = "Subscribed to %s";
Xchar txt_unsubscribed_to[] = "Unsubscribed from %s";
Xchar txt_mark_all_read[] = "Mark all articles as read? (y/n): ";
Xchar txt_mark_thread_read[] = "Mark thread as read? (y/n): ";
Xchar txt_no_more_groups[] = "No more groups";
Xchar txt_no_prev_group[] = "No previous group";
Xchar txt_no_arts[] = "*** No Articles ***";
Xchar txt_no_groups[] = "*** No Groups ***";
Xchar txt_not_active_newsfeed[] = "Command only allowed on active news";
Xchar txt_end_of_thread[] = "*** End of Thread ***";
Xchar txt_end_of_arts[] = "*** End of Articles ***";
Xchar txt_end_of_groups[] = "*** End of Groups ***";
Xchar txt_no_next_unread_art[] = "No next unread article";
Xchar txt_no_prev_unread_art[] = "No previous unread article";
Xchar txt_no_last_message[] = "No last message";
Xchar txt_bad_command[] = "Bad command.  Type 'h' for help.";
Xchar txt_you_have_mail[] = "    You have mail\n";
Xchar txt_type_h_for_help[] = "           h=help\n";
Xchar txt_read_art[] = "Read article> ";
Xchar txt_search_forwards[] = "Search forwards [%s]> ";
Xchar txt_search_backwards[] = "Search backwards [%s]> ";
Xchar txt_author_search_forwards[] = "Author search forwards [%s]> ";
Xchar txt_author_search_backwards[] = "Author search backwards [%s]> ";
Xchar txt_no_search_string[] = "No search string";
Xchar txt_no_match[] = "No match";
Xchar txt_post_subject[] = "Post subject [%s]> ";
Xchar txt_no_subject[] = "No subject";
Xchar txt_cannot_open[] = "can't open %s";
Xchar txt_posting[] = "Posting article...";
Xchar txt_art_posted[] = "-- Article posted --";
Xchar txt_art_rejected[] = "-- Article rejected (saved to %s) --";
Xchar txt_quit_edit_post[] = "q)uit, e)dit, p)ost: ";
Xchar txt_help_4[] = "4$       Goto spooldir 4 ($=goto last spooldir)\r\n";
Xchar txt_help_i_4[] = "4$       Goto article 4 ($=goto last article)\r\n";
Xchar txt_help_ctrl_k[] = "^K       Kill / Auto select (hot) current article\r\n";
Xchar txt_help_ctrl_l[] = "^L       Redraw page\r\n";
Xchar txt_help_ctrl_d[] = "^D^U     Down (^U=up) a page\r\n";
Xchar txt_help_i_cr[] = "<CR>     Read current article\r\n";
Xchar txt_help_cr[] = "<CR>     Read news from selected spooldir\r\n";
Xchar txt_help_i_tab[] = "<TAB>    Goto next unread article or group\r\n";
Xchar txt_help_d[] = "d        Toggle display of subject only & subject/author\r\n";
Xchar txt_help_l[] = "l        List articles within current thread\r\n";
Xchar txt_help_m[] = "m        Move current group within group selection list\r\n";
Xchar txt_help_M[] = "M        Menu of configurable options\r\n";
Xchar txt_help_a[] = "aA       Author forward (A=backward) search\r\n";
Xchar txt_help_sel_c[] = "cC       Mark group read (C=and goto next unread group)\r\n";
Xchar txt_help_c[] = "c        Mark all articles as read and goto group selection menu\r\n";
Xchar txt_help_g[] = "g        Choose a new group by name\r\n";
Xchar txt_help_I[] = "I        Toggle inverse video\r\n";
Xchar txt_help_K[] = "K        Mark article/thread as read & goto next unread\r\n";
Xchar txt_help_j[] = "jk       Down (k=up) a line\r\n";
Xchar txt_help_i_n[] = "np       Goto next (p=previous) group\r\n";
Xchar txt_help_i_p[] = "NP       Goto next (P=previous) unread article\r\n";
Xchar txt_help_q[] = "Q        Quit\r\n";
Xchar txt_help_r[] = "r        Toggle display to show all / only unread articles\r\n";
Xchar txt_help_s[] = "su       Subscribe (u=unsubscribe) to current group\r\n";
Xchar txt_help_S[] = "SU       Subscribe (U=unsubscribe) to groups that match pattern\r\n";
Xchar txt_help_t[] = "t        Return to group selection level\r\n";
Xchar txt_help_T[] = "T        Tag current article for crossposting/mailing/piping/printing/saving\r\n";
Xchar txt_help_u[] = "u        Toggle display of unthreaded & threaded articles\r\n";
Xchar txt_help_U[] = "U        Untag all tagged articles\r\n";
Xchar txt_help_v[] = "v        Show version information\r\n";
Xchar txt_help_w[] = "w        Post an article to current group\r\n";
Xchar txt_help_x[] = "x        Crosspost current article to another group\r\n";
Xchar txt_help_i_search[] = "/?       Subject forward (?=backward) search\r\n";
Xchar txt_help_thread[] = "<>       Goto first (>=last) article in current thread";
X#ifndef NO_SHELL_ESCAPE
Xchar txt_help_shell[] = "!        Shell escape\r\n";
X#endif
Xchar txt_help_dash[] = "-        Show last message\r\n";
X#ifdef NO_REGEX 
Xchar txt_save_pattern[] = "Enter save pattern [%s]> ";
X#else
Xchar txt_save_pattern[] = "Enter regex save pattern [%s]> ";
X#endif
Xchar txt_saved_pattern_to[] = "-- Saved pattern to %s - %s --";
Xchar txt_saved_to_mailbox[] = "-- Saved to mailbox %s --";
Xchar txt_threading_arts[] = "Threading articles...";
Xchar txt_unthreading_arts[] = "Unthreading articles...";
X
X/* 
X *  help.c:
X */
X
Xchar txt_group_select_com[] = "Group Selection Commands (page %d of %d)";
Xchar txt_spooldir_com[] = "Spooldir Selection Commands (page %d of %d)";
Xchar txt_index_page_com[] = "Index Page Commands (page %d of %d)";
Xchar txt_thread_com[] = "Thread Commands (page %d of %d)";
Xchar txt_art_pager_com[] = "Article Pager Commands (page %d of %d)";
Xchar txt_hit_space_for_more[] = "PgDn,End,<SPACE>,^D - page down. PgUp,Home,b,^U - page up. <CR>,q - quit";
Xchar txt_post_history_menu[] = "Posted articles history (page %d of %d)";
X
X/* 
X *  kill.c:
X */
X
Xchar txt_corrupt_kill_file[] = "Corrupt kill file %s";
Xchar txt_kill_menu[] = "Kill Article Menu";
Xchar txt_kill_how[] = "Kill type : ";
Xchar txt_kill_subject[] = "Kill Subject [%-*.*s] (y/n): ";
Xchar txt_kill_from[] =    "Kill From    [%-*.*s] (y/n): ";
Xchar txt_kill_text[] = "Kill text pattern : ";
Xchar txt_kill_text_type[] = "Apply pattern to  : ";
Xchar txt_kill_group[] =     "Kill pattern scope: ";
Xchar txt_help_kill_how[] = "Choose kill or auto select. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_subject[] = "Subject: line to add to kill file. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_from[] = "From: line to add to kill file. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_text[] = "Enter text pattern to kill if Subject: & From: lines are not what you want.";
Xchar txt_help_kill_text_type[] = "Select where text pattern should be applied. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_group[] = "Kill/auto-select only current group or all groups. <SPACE> toggles & <CR> sets.";
Xchar txt_quit_edit_save_killfile[] = "q)uit e)dit s)ave kill/hot description: ";
X
X
X/* 
X *  main.c:
X */
X
Xchar txt_option_not_enabled[] = "Option not enabled. Recompile with %s.";
Xchar txt_not_in_active_file[] = "Group %s not found in active file";
Xchar txt_screen_init_failed[] = "%s: Screen initialization failed";
Xchar txt_bad_active_file[] = "Active file corrupt - %s";
X
X/*
X *  misc.c
X */
X
Xchar txt_cannot_open_active_file[] = "Cannot open %s. Try %s -r to read news via NNTP.\n";
Xchar txt_reading_active_file[] = "Reading active file...";
Xchar txt_active_file_is_empty[] = "%s contains no newsgroups. Exiting.";
Xchar txt_checking_active_file[] = "Checking for new newsgroups...";
Xchar txt_checking[] = "Checking...";
Xchar txt_cannot_find_base_art[] = "Cannot find base article %s";
Xchar txt_out_of_memory[] = "%s: out of memory";
Xchar txt_rename_error[] = "Error: rename %s to %s";
Xchar txt_shell_escape[] = "Enter shell command [%s]> ";
X
X/*
X *  newsrc.c
X */
X
Xchar txt_creating_newsrc[] = "Creating .newsrc...\n";
Xchar txt_deleting_from_newsrc[] = "Group %s not in active file. Deleting.";
X
X/*
X *  open.c
X */
X 
Xchar txt_connecting[] = "Connecting to %s...";
Xchar txt_cannot_get_nntp_server_name[] = "Cannot find NNTP server name";
Xchar txt_server_name_in_file_env_var[] = "Put the server name in the file %s,\nor set the environment variable NNTPSERVER";
Xchar txt_failed_to_connect_to_server[] = "Failed to connect to (%s) server";
Xchar txt_rejected_by_nntpserver[] = "Rejected by server, nntp error %d";
Xchar txt_connection_to_server_broken[] = "Connection to server broken";
Xchar txt_stuff_nntp_cannot_open[] = "stuff_nntp: can't open %s: ";
Xchar txt_nntp_to_fp_cannot_reopen[] = "nntp_to_fp: can't reopen %s: ";
Xchar txt_nntp_to_fd_cannot_reopen[] = "nntp_to_fd: can't reopen %s: ";
X
X/*
X *  page.c
X */
X
Xchar txt_quit[] = "Do you really want to quit? (y/n): ";
Xchar txt_art_unavailable[] = "Article %ld unavailable";
Xchar txt_art_marked_as_unread[] = "Article marked as unread";
Xchar txt_thread_marked_as_unread[] = "Thread marked as unread";
Xchar txt_begin_of_art[] = "*** Beginning of article ***";
Xchar txt_next_resp[] = "-- Next response --";
Xchar txt_last_resp[] = "-- Last response --";
Xchar txt_more[] = "--More--";
Xchar txt_more_percent[] = "--More--(%d%%) [%ld/%ld]";
Xchar txt_thread_x_of_n[] = "%sThread %4d of %4d\r\n";
Xchar txt_art[] = "Article %ld  ";
Xchar txt_resp_x_of_n[] = "Respno %3d of %3d\r\n";
Xchar txt_no_resp[] = "No responses\r\n";
Xchar txt_1_resp[] = "1 Response\r\n";
Xchar txt_x_resp[] = "%d Responses\r\n";
Xchar txt_s_at_s[] = "%s at %s";
Xchar txt_thread_resp_page[] = "Thread %d of %d, Resp %d (page %d):  %s";
Xchar txt_thread_page[] = "Thread %d of %d (page %d):  %s";
Xchar txt_read_resp[] = "Read response> ";
Xchar txt_help_p_0[] = "0        Read the base article in current thread\r\n";
Xchar txt_help_p_4[] = "4        Read response 4 in current thread\r\n";
Xchar txt_help_p_cr[] = "<CR>     Goto to next thread\r\n";
Xchar txt_help_p_tab[] = "<TAB>    Goto next unread article\r\n";
Xchar txt_help_b[] = "b<SPACE> Back (<SPACE>=forward) a page\r\n";
Xchar txt_help_bug[] = "B        Mail bug/comment to %s\r\n";
Xchar txt_help_p_f[] = "fF       Post (F=copy text) a followup\r\n";
Xchar txt_help_C[] = "C        Cancel current article that must have been posted by you\r\n";
Xchar txt_help_ctrl_h[] = "^H       Show articles header\r\n";
Xchar txt_help_h[] = "h        Command help\r\n";
Xchar txt_help_i[] = "q        Return to previous level\r\n";
Xchar txt_help_ck[] = "ck       Mark thread as read & return to previous level\r\n";
Xchar txt_help_p_k[] = "kK       Mark article (K=thread) as read & advance to next unread\r\n";
Xchar txt_help_p_m[] = "m        Mail article/thread/hot/pattern/tagged articles to someone\r\n";
Xchar txt_help_p_n[] = "nN       Goto to the next (N=unread) article\r\n";
Xchar txt_help_o[] = "o        Output article/thread/hot/pattern/tagged articles to printer\r\n";
Xchar txt_help_p_p[] = "pP       Goto the previous (P=unread) article\r\n";
Xchar txt_help_p_r[] = "rR       Reply through mail (R=copy text) to author\r\n";
Xchar txt_help_p_s[] = "s        Save article/thread/hot/pattern/tagged articles to file\r\n";
Xchar txt_help_p_z[] = "zZ       Mark article (Z=thread) as unread\r\n";
Xchar txt_help_p_ctrl_r[] = "^R$      Redisplay first ($=last) page of article\r\n";
Xchar txt_help_p_g[] = "gG       Goto first (G=last) page of article\r\n";
Xchar txt_help_p_d[] = "d        Toggle rot-13 decoding for current article\r\n";
Xchar txt_help_pipe[] = "|        Pipe article/thread/hot/pattern/tagged articles into command\r\n";
Xchar txt_help_p_search[] = "/        Article forward search\r\n";
Xchar txt_mail_art_to[] = "Mail article to [%.*s]> ";
Xchar txt_no_mail_address[] = "No mail address";
Xchar txt_quit_edit_send[] = "q)uit, e)dit, s)end";
Xchar txt_quit_edit_cancel[] = "q)uit, e)dit, c)ancel";
Xchar txt_mailing_to[] = "Mailing to %s...";
Xchar txt_mailed[] = "-- %d Article(s) mailed --";
Xchar txt_command_failed_s[] = "Command failed: %s\n";
Xchar txt_in_art_you_write[] = "In article %s you write:\n";
Xchar txt_resp_to_poster[] = "Responses have been directed to the poster. Post anyway? (y/n): ";
Xchar txt_resp_redirect[] = "Responses have been directed to the following newsgroups";
Xchar txt_continue[] = "Continue? (y/n): ";
Xchar txt_writes[] = "%s writes:\n";
Xchar txt_writes_name[] = "%s (%s) writes:\n";
Xchar txt_save_filename[] = "Save filename [%s]> ";
Xchar txt_art_not_saved[] = "-- Article not saved --";
Xchar txt_no_filename[] = "No filename";
Xchar txt_saving[] = "Saving...";
Xchar txt_art_saved_to[] = "-- Article saved to %s --";
Xchar txt_thread_not_saved[] = "-- Thread not saved --";
Xchar txt_thread_saved_to_many[] = "-- Thread saved to %s - %s --";
Xchar txt_thread_saved_to[] = "-- Thread saved to %s --";
Xchar txt_pipe_to_command[] = "Pipe to command [%.*s]> ";
Xchar txt_printing[] = "Printing...";
Xchar txt_printed[] = "-- %d Article(s) printed --";
Xchar txt_append_to_file[] = "File %s exists. Append? (y/n): ";
Xchar txt_toggled_rot13[] = "Toggled rot13 encoding";
X
X/*
X *  post.c
X */
X
Xchar txt_no_arts_posted[] = "No articles have been posted";
Xchar txt_post_an_article[] = "Post an article...";
Xchar txt_post_a_followup[] = "Post a followup...";
Xchar txt_mail_bug_report[] = "Mail bug report...";
Xchar txt_crosspost_group[] = "Crosspost article to group(s) [%s]> ";
Xchar txt_no_group[] = "No group";
Xchar txt_crosspost_an_article[] = "Crossposting article...";
Xchar txt_mail_bug_report_confirm[] = "Mail bug report to %s? (y/n): ";
Xchar txt_reply_to_author[] = "Reply to author...";
Xchar txt_no_blank_line[] = "No blank line found after header information. q)uit, e)dit: ";
Xchar txt_cancelling[] = "Cancelling article...";
Xchar txt_art_cancelled[] = "Article cancelled";
Xchar txt_art_cannot_cancel[] = "Article cannot be cancelled";
Xchar txt_quit_edit_xpost[] = "q)uit, e)dit, p)ost [%.*s]: %c";
X
X/*
X *  prompt.c
X */
X
Xchar txt_hit_any_key[] = "-- Press any key to continue --";
X
X/*
X *  rcfile.c
X */
X 
Xchar txt_opt_autosave[] = "1. Auto save       : ";
Xchar txt_opt_start_editor_offset[] = "2. Editor Offset   : ";
Xchar txt_opt_mark_saved_read[] = "3. Mark saved read : ";
Xchar txt_opt_confirm_action[] =  "4. Confirm command : ";
Xchar txt_opt_draw_arrow[] = "5. Draw arrow      : ";
Xchar txt_opt_print_header[] = "6. Print header    : ";
Xchar txt_opt_pos_first_unread[] = "7. Goto 1st unread : ";
Xchar txt_opt_page_scroll[] = "8. Scroll full page: ";
Xchar txt_opt_catchup_groups[] = "9. Catchup on quit : ";
Xchar txt_opt_thread_arts[] =   "10 Thread articles : ";
Xchar txt_opt_show_only_unread[] = "11 Show only unread: ";
Xchar txt_opt_show_author[] = "13 Show author     : ";
Xchar txt_opt_process_type[] = "14 Process type    : ";
Xchar txt_opt_sort_type[] = "15 Sort article by : ";
Xchar txt_opt_savedir[] = "16 Save directory  : ";
Xchar txt_opt_maildir[] = "17 Mail directory  : ";
Xchar txt_opt_printer[] = "18 Printer         : ";
Xchar txt_options_menu[] = "Options Menu";
Xchar txt_show_from_none[] = "None";
Xchar txt_show_from_addr[] = "Addr";
Xchar txt_show_from_name[] = "Name";
Xchar txt_show_from_both[] = "Both";
Xchar txt_post_process_none[] = "None";
Xchar txt_post_process_sh[] = "Shell archive";
Xchar txt_post_process_uudecode[] = "Uudecode";
Xchar txt_post_process_uud_lst_zoo[] = "Uudecode & list zoo archive";
Xchar txt_post_process_uud_ext_zoo[] = "Uudecode & extract zoo archive";
Xchar txt_sort_by_nothing[] = "Nothing";
Xchar txt_sort_by_subj_descend[] = "Subject: field (descending)";
Xchar txt_sort_by_subj_ascend[] = "Subject: field (ascending)";
Xchar txt_sort_by_from_descend[] = "From: field (descending)";
Xchar txt_sort_by_from_ascend[] = "From: field (ascending)";
Xchar txt_sort_by_date_descend[] = "Date: field (descending)";
Xchar txt_sort_by_date_ascend[] = "Date: field (ascending)";
Xchar txt_help_autosave[] = "Auto save article/thread by Archive-name: header. <SPACE> toggles & <CR> sets.";
Xchar txt_help_start_editor_offset[] = "Start editor with line offset. <SPACE> toggles & <CR> sets.";
Xchar txt_help_confirm_action[] = "Ask for command confirmation. <SPACE> toggles & <CR> sets.";
Xchar txt_help_print_header[] = "By printing print all/part of header. <SPACE> toggles & <CR> sets.";
Xchar txt_help_pos_first_unread[] = "Put cursor at first/last unread art in groups. <SPACE> toggles & <CR> sets.";
Xchar txt_help_show_author[] = "Show Subject & From (author) fields in group menu. <SPACE> toggles & <CR> sets.";
Xchar txt_help_draw_arrow[] = "Draw -> or highlighted bar for selection. <SPACE> toggles & <CR> sets.";
Xchar txt_help_mark_saved_read[] = "Mark saved articles/threads as read. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_page_scroll[] = "Scroll half/full page of groups/articles. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_catchup_groups[] = "Ask to mark groups read when quiting. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_thread_arts[] = "Enable/disable threading of articles in all groups. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_show_only_unread[] = "Show all articles or only unread articles. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_post_proc_type[] = "Post process (ie. unshar) saved article/thread. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_sort_type[] = "Sort articles by Subject, From or Date fields. <SPACE> toggles & <CR> sets.";
Xchar txt_help_savedir[] = "The directory where you want articles/threads saved.";
Xchar txt_help_maildir[] = "The directory where articles/threads are to be saved in mailbox format.";
Xchar txt_help_printer[] = "The printer program with options that is to be used to print articles/threads.";
Xchar txt_select_rcfile_option[] = "Select option by entering number before text. Any other key to save.";
X
X/*
X *  save.c
X */
X
Xchar txt_post_processing[] = "Post processing...";
Xchar txt_post_processing_finished[] = "-- post processing completed --";
Xchar txt_deleting[] = "Deleting...";
Xchar txt_uudecoding[] = "Uudecoding...";
Xchar txt_extracting_shar[] ="\r\nExtracting %s...\r\n";
Xchar txt_delete_processed_files[] = "Delete saved files that have been post processed? (y/n): ";
Xchar txt_post_processing_failed[] = "Post processing failed";
Xchar txt_listing_archive[] = "\r\n\r\nListing %s archive...\r\n"; 
Xchar txt_extracting_archive[] = "\r\n\r\nExtracting %s archive...\r\n";
Xchar txt_checksum_of_file[] = "\r\n\r\nChecksum of %s...\r\n\r\n"; 
X
X/*
X *  search.c
X */
X
Xchar txt_searching[] = "Searching...";
X
X/*
X *  select.c
X */
X
Xchar txt_moving[] = "Moving %s...";
X#ifdef NO_REGEX
Xchar txt_subscribe_pattern[] = "Enter subscribe pattern> ";
Xchar txt_unsubscribe_pattern[] = "Enter unsubscribe pattern> ";
X#else
Xchar txt_subscribe_pattern[] = "Enter regex subscribe pattern> ";
Xchar txt_unsubscribe_pattern[] = "Enter regex unsubscribe pattern> ";
X#endif
Xchar txt_subscribing[] = "Subscribing...";
Xchar txt_subscribing_to[] = "Subscribing to %s...";
Xchar txt_unsubscribing[] = "Unsubscribing...";
Xchar txt_unsubscribing_from[] = "Unsubscribing from %s...";
Xchar txt_subscribed_num_groups[] = "subscribed to %d groups";
Xchar txt_unsubscribed_num_groups[] = "unsubscribed from %d groups";
Xchar txt_del_group_in_newsrc[] = "Delete %s from .newsrc? (y/n): ";
Xchar txt_group_deleted[] = "Group %s deleted";
Xchar txt_group_undeleted[] = "Group undeleted";
Xchar txt_mark_group_read[] = "Mark group %s as read? (y/n): ";
Xchar txt_no_groups_to_delete[] = "No groups to delete";
Xchar txt_reset_newsrc[] = "Reset newsrc? (y/n): ";
Xchar txt_post_newsgroup[] = "Post newsgroup> ";
Xchar txt_yanking_all_groups[] = "Yanking in all groups...";
Xchar txt_yanking_sub_groups[] = "Yanking in subscribed to groups...";
Xchar txt_no_groups_to_read[] = "No more groups to read";
Xchar txt_added_groups[] = "Added %d group%s";
Xchar txt_plural[] = "s";
Xchar txt_no_groups_to_yank_in[] = "No more groups to yank in";
Xchar txt_group_selection[] = "Group Selection";
Xchar txt_spooldir_selection[] = "Spooldir Selection (%d)";
Xchar txt_select_group[] = "Select group> ";
Xchar txt_select_spooldir[] = "Select spooldir> ";
Xchar txt_help_g_4[] = "4$       Select group 4 ($=select last group)\r\n";
Xchar txt_help_g_ctrl_r[] = "^R       Reset .newsrc\r\n";
Xchar txt_help_g_ctrl_k[] = "^KZ      Delete (Z=undelete) group from .newsrc\r\n";
Xchar txt_help_g_cr[] = "<CR>     Read current group\r\n";
Xchar txt_help_g_c[] = "c        Mark group as all read\r\n";
Xchar txt_help_g_l[] = "l        List & select another spooldir\r\n";
Xchar txt_help_g_tab[] =   "n<TAB>   Goto next group with unread news and enter it\r\n";
Xchar txt_help_n[] = "N        Goto next group with unread news\r\n";
Xchar txt_help_g_q[] = "qQ       Quit\r\n";
Xchar txt_help_W[] = "W        List articles posted by user\r\n";
Xchar txt_help_g_y[] = "y        Yank in subscribed/unsubscribed from .newsrc\r\n";
Xchar txt_help_g_z[] = "z        Mark current group as unread\r\n";
Xchar txt_help_y[] = "Y        Yank in active file to see any new news\r\n";
Xchar txt_help_g_search[] = "/?       Group forward (?=backward) search\r\n";
Xchar txt_newsgroup[] = "Goto newsgroup [%s]> ";
Xchar txt_newsgroup_position[] = "Position %s in group list (1,2,..,$) [%d]> ";
X
X/*
X *  signal.c
X */
X
Xchar txt_resizing_window[] = "resizing window";
Xchar txt_suspended_message[] = "\nStopped. Type 'fg' to restart TIN\n";
X
X/*
X *  thread.c
X */
X
Xchar txt_no_resps_in_thread[] = "No responses to list in current thread";
Xchar txt_help_t_0[] = "0        Goto the base article in current thread\r\n";
Xchar txt_help_t_4[] = "4$       Goto response 4 ($=goto last response) in current thread\r\n";
Xchar txt_help_t_cr[] = "<CR>     Read current response\r\n";
Xchar txt_help_t_tab[] = "<TAB>    Goto next unread response\r\n";
Xchar txt_help_t_K[] =   "K        Mark thread as read & return\r\n";
END_OF_FILE
  if test 22813 -ne `wc -c <'lang.c'`; then
    echo shar: \"'lang.c'\" unpacked with wrong size!
  fi
  # end of 'lang.c'
fi
echo shar: End of archive 8 \(of 14\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
