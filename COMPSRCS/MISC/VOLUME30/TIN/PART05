Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i005:  tin - threaded full screen newsreader, Part05/14
Message-ID: <1992May20.172351.28777@sparky.imd.sterling.com>
X-Md4-Signature: 983c197f80bd5c5897d5a94f73961541
Date: Wed, 20 May 1992 17:23:51 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 5
Archive-name: tin/part05
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  proto.h rcfile.c
# Wrapped by kent@sparky on Tue May 19 13:38:03 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 14)."'
if test -f 'proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.h'\"
else
  echo shar: Extracting \"'proto.h'\" \(27832 characters\)
  sed "s/^X//" >'proto.h' <<'END_OF_FILE'
X#if __STDC__
X 
X/* active.c */
Xextern void resync_active_file(void);
Xextern int read_active_file(void);
Xextern int backup_active(int create);
Xextern void notify_groups(void);
Xextern void mark_unthreaded_groups(void);
X/* art.c */
Xextern void find_base(int only_unread);
Xextern int num_of_arts(void);
Xextern int valid_artnum(long art);
Xextern int purge_needed(void);
Xextern void index_group(char *group, char *group_path);
Xextern int read_group(char *group, char *group_path);
Xextern void make_threads(int rethread);
Xextern int parse_headers(FILE *fp, struct article_t *h);
Xextern void write_index_file(char *group);
Xextern int read_index_file(char *group_name);
Xextern void find_index_file(char *group);
Xextern void do_update(void);
Xextern char *parse_date(char *date, char *str);
Xextern int artnum_comp(char *p1, char *p2);
Xextern int subj_comp(char *p1, char *p2);
Xextern int from_comp(char *p1, char *p2);
Xextern int date_comp(char *p1, char *p2);
Xextern void set_article(struct article_t *art);
X/* curses.c */
Xextern int InitScreen(void);
Xextern void ScreenSize(int *num_lines, int *num_columns);
Xextern void InitWin(void);
Xextern void EndWin(void);
Xextern void ClearScreen(void);
Xextern void MoveCursor(int row, int col);
Xextern void CleartoEOLN(void);
Xextern void CleartoEOS(void);
Xextern void StartInverse(void);
Xextern void EndInverse(void);
Xextern int RawState(void);
Xextern void Raw(int state);
Xextern int ReadCh(void);
Xextern int outchar(int c);
X/* debug.c */
Xextern void debug_nntp(char *func, char *line);
Xextern void debug_nntp_respcode(int respcode);
Xextern void debug_print_arts(void);
Xextern void debug_print_header(struct article_t *s);
Xextern void debug_print_comment(char *comment);
Xextern void debug_print_base(void);
Xextern void debug_print_active(void);
X/* feed.c */
Xextern void feed_articles(int function, int level, char *prompt, int respnum, char *group_path);
Xextern int print_file(FILE *fp, int respnum, int count);
X/* getline.c */
Xextern char *getline(char *prompt, int number_only, char *str);
X/* group.c */
Xextern void group_page(char *group);
Xextern void fix_new_highest(int groupnum);
Xextern void show_group_page(char *group);
Xextern void draw_subject_arrow(void);
Xextern void erase_subject_arrow(void);
Xextern void prompt_subject_num(int ch, char *group);
Xextern void clear_note_area(void);
Xextern int find_new_pos(int old_top, long old_artnum, int cur_pos);
Xextern void mark_screen(int level, int screen_row, int screen_col, char *value);
Xextern void set_subj_from_size(int num_cols);
Xextern void toggle_subject_from(void);
X/* hashstr.c */
Xextern char *hash_str(char *s);
Xextern struct hashnode *add_string(char *s);
Xextern void hash_init(void);
Xextern void hash_reclaim(void);
X/* help.c */
Xextern void show_info_page(int type, char *help[], char *title);
X/* inews.c */
Xextern int submit_inews(char *name);
Xextern void get_host_name(char *host_name);
Xextern void get_from_name(char *from_name);
X/* init.c */
Xextern void init_selfinfo(void);
Xextern void set_tindir(void);
Xextern int create_mail_save_dirs(void);
X/* kill.c */
Xextern int read_kill_file(void);
Xextern void write_kill_file(void);
Xextern int kill_art_menu(char *group_name, int index);
Xextern int unkill_all_articles(void);
Xextern int kill_any_articles(char *group);
X/* lang.c */
X/* main.c */
Xextern void main(int argc, char *argv[]);
Xextern void read_cmd_line_options(int argc, char *argv[]);
Xextern void usage(char *progname);
Xextern int check_for_any_new_news(int check_any_unread, int start_any_unread);
Xextern void save_or_mail_new_news(void);
Xextern void update_index_files(void);
Xextern void show_intro_page(void);
X/* memory.c */
Xextern void init_alloc(void);
Xextern void expand_art(void);
Xextern void expand_active(void);
Xextern void expand_kill(void);
Xextern void expand_save(void);
Xextern void init_screen_array(int allocate);
Xextern void free_all_arrays(void);
Xextern void free_art_array(void);
Xextern void free_active_arrays(void);
Xextern void free_kill_array(void);
Xextern void free_save_array(void);
Xextern char *my_malloc(unsigned size);
Xextern char *my_realloc(char *p, unsigned size);
X/* misc.c */
Xextern void asfail(char *file, int line, char *cond);
Xextern void copy_fp(FILE *fp_ip, FILE *fp_op, char *prefix);
Xextern char *get_val(char *env, char *def);
Xextern int invoke_editor(char *nam);
Xextern void shell_escape(void);
Xextern void tin_done(int ret);
Xextern long hash_groupname(char *group);
Xextern void rename_file(char *old_filename, char *new_filename);
Xextern char *str_dup(char *str);
Xextern int invoke_cmd(char *nam);
Xextern void draw_percent_mark(int cur_num, int max_num);
Xextern void set_real_uid_gid(void);
Xextern void set_tin_uid_gid(void);
Xextern void basename(char *dirname, char *program);
Xextern void mail_setup(void);
Xextern int mail_check(void);
Xextern void parse_from(char *str, char *addr, char *name);
Xextern long my_atol(char *s, int n);
Xextern int my_stricmp(char *p, char *q);
Xextern char *eat_re(char *s);
Xextern long hash_s(char *s);
Xextern void my_strncpy(char *p, char *q, int n);
Xextern int untag_all_articles(void);
Xextern char *str_str(char *text, char *pattern, int patlen);
Xextern void get_author(int thread, int respnum, char *str);
Xextern void toggle_inverse_video(void);
Xextern int get_arrow_key(void);
X/* newsrc.c */
Xextern int auto_subscribe_groups(void);
Xextern void backup_newsrc(void);
Xextern void read_newsrc(int sub_only);
Xextern void write_newsrc(void);
Xextern void rewrite_newsrc(void);
Xextern void read_newsrc_line(char *group);
Xextern void update_newsrc(char *group, int groupnum, int mark_unread);
Xextern void subscribe(char *group, int ch, int num, int out_seq);
Xextern void reset_newsrc(void);
Xextern void delete_group(char *group);
Xextern int undel_group(void);
Xextern void mark_group_read(char *group, int groupnum);
Xextern void parse_seq(char *s);
Xextern int parse_unread(char *s, int groupnum);
Xextern int get_line_unread(char *group, int groupnum);
Xextern void print_seq(FILE *fp, int groupnum);
Xextern int pos_group_in_newsrc(char *group, int pos);
Xextern void mark_all_xref_read(char *xref_line);
X/* nntplib.c */
Xextern char *getserverbyfile(char *file);
Xextern int server_init(char *machine);
Xextern int get_tcp_socket(char *machine);
Xextern int handle_server_response(int response, char *nntpserver);
Xextern void put_server(char *string);
Xextern int get_server(char *string, int size);
Xextern void close_server(void);
X/* open.c */
Xextern void nntp_open(void);
Xextern void nntp_close(void);
Xextern FILE *open_active_fp(void);
Xextern FILE *open_subscription_fp(void);
Xextern FILE *open_index_fp(char *group_name);
Xextern FILE *open_art_fp(char *group_path, long art);
Xextern FILE *open_header_fp(char *group_path, long art);
Xextern int base_comp(char *p1, char *p2);
Xextern void setup_base(char *group, char *group_path);
Xextern int get_respcode(void);
Xextern int stuff_nntp(char *fnam);
Xextern FILE *nntp_to_fp(void);
Xextern int nntp_to_fd(void);
Xextern void log_user(void);
Xextern char *nntp_respcode(int respcode);
X/* page.c */
Xextern int show_page(int respnum, int *threadnum, char *group, char *group_path);
Xextern void redraw_page(int respnum, char *group);
Xextern void show_note_page(int respnum, char *group);
Xextern void show_first_header(int respnum, char *group);
Xextern void show_cont_header(int respnum);
Xextern int art_open(long art, char *group_path);
Xextern void art_close(void);
Xextern int prompt_response(int ch, int respnum);
Xextern void yank_to_addr(char *orig, char *addr);
Xextern int show_last_page(void);
Xextern int match_header(char *buf, char *pat, char *body, int len);
X/* post.c */
Xextern int user_posted_messages(void);
Xextern void update_art_posted_file(char *group, int action, char *subj);
Xextern int post_header_ok(char *article);
Xextern int post_base(char *group, int *posted);
Xextern int post_response(char *group, int respnum, int copy_text);
Xextern int mail_to_someone(char *address, int confirm_to_mail, int *mailed_ok);
Xextern int mail_bug_report(void);
Xextern int mail_to_author(char *group, int respnum, int copy_text);
Xextern void find_mail_header(int header, char *file, char *value);
Xextern int cancel_article(char *group, int respnum);
Xextern int crosspost_article(char *group, int respnum);
Xextern int submit_file(char *name);
Xextern void add_signature(FILE *fp, int flag);
Xextern void insert_x_headers(char *infile);
Xextern void find_reply_to_addr(int respnum, char *from_addr);
X/* prompt.c */
Xextern int prompt_num(int ch, char *prompt);
Xextern int prompt_string(char *prompt, char *buf);
Xextern int prompt_menu_string(int line, int col, char *var);
Xextern int prompt_yn(int line, char *prompt, int prompt_ch);
Xextern void prompt_on_off(int row, int col, int *var, char *help_text, char *prompt_text);
Xextern void continue_prompt(void);
X/* rcfile.c */
Xextern int read_rcfile(void);
Xextern void write_rcfile(void);
Xextern int change_rcfile(char *group, int kill_at_once);
Xextern void show_rcfile_menu(void);
Xextern void expand_rel_abs_pathname(int line, int col, char *str);
Xextern void show_menu_help(char *help_message);
Xextern int match_boolean(char *line, char *pat, int *dst);
Xextern int match_number(char *line, char *pat, int *dst);
Xextern int match_string(char *line, char *pat, char *dst, int dstlen);
X/* save.c */
Xextern int check_start_save_any_news(int check_start_save);
Xextern int save_art_to_file(int respnum, int index, int mailbox, char *filename);
Xextern int save_thread_to_file(int is_mailbox, char *group_path);
Xextern int save_regex_arts(int is_mailbox, char *group_path);
Xextern int append_to_existing_file(int i);
Xextern int create_path(char *path);
Xextern int create_sub_dir(int i);
Xextern void add_to_save_list(int index, struct article_t *article, int is_mailbox, char *path);
Xextern void sort_save_list(void);
Xextern int save_comp(char *p1, char *p2);
Xextern char *save_filename(int i);
Xextern char *get_first_savefile(void);
Xextern char *get_last_savefile(void);
Xextern int post_process_files(int proc_type_ch);
Xextern void post_process_uud(int pp);
Xextern void post_process_sh(void);
Xextern char *get_archive_file(char *dir, char *ext);
Xextern void delete_processed_files(void);
X/* screen.c */
Xextern void info_message(char *str);
Xextern void wait_message(char *str);
Xextern void error_message(char *template, char *str);
Xextern void perror_message(char *template, char *str);
Xextern void clear_message(void);
Xextern void center_line(int line, int inverse, char *str);
Xextern void draw_arrow(int line);
Xextern void erase_arrow(int line);
Xextern void show_title(char *title);
Xextern void ring_bell(void);
X/* search.c */
Xextern int search_author(int only_unread, int current_art, int forward);
Xextern void search_group(int forward);
Xextern void search_subject(int forward, char *group);
Xextern int search_article(int forward);
Xextern void make_lower(char *s, char *t);
X/* select.c */
Xextern void selection_index(int start_groupnum);
Xextern void group_selection_page(void);
Xextern int prompt_group_num(int ch);
Xextern void erase_group_arrow(void);
Xextern void draw_group_arrow(void);
Xextern int choose_new_group(void);
Xextern int add_group(char *s, int get_unread);
Xextern int reposition_group(char *group, int default_num);
Xextern void catchup_group(int goto_next_unread_group);
Xextern void next_unread_group(int enter_group);
Xextern void set_groupname_len(int all_groups);
X/* signal.c */
Xextern sigtype_t (*sigdisp(int sig, sigtype_t (*func)()))();
Xextern void set_signal_handlers(void);
Xextern void set_alarm_signal(void);
Xextern void signal_handler(int sig);
Xextern void set_win_size(int *num_lines, int *num_cols);
Xextern void set_signals_art(void);
Xextern void set_signals_group(void);
Xextern void set_signals_page(void);
Xextern void set_signals_select(void);
Xextern void set_signals_spooldir(void);
Xextern void set_signals_thread(void);
Xextern void art_suspend(int sig);
Xextern void main_suspend(int sig);
Xextern void select_suspend(int sig);
Xextern void spooldir_suspend(int sig);
Xextern void group_suspend(int sig);
Xextern void page_suspend(int sig);
Xextern void thread_suspend(int sig);
Xextern void rcfile_suspend(int sig);
Xextern void art_resize(int sig);
Xextern void main_resize(int sig);
Xextern void select_resize(int sig);
Xextern void spooldir_resize(int sig);
Xextern void group_resize(int sig);
Xextern void page_resize(int sig);
Xextern void thread_resize(int sig);
X/* spooldir.c */
Xextern int spooldir_index(void);
Xextern void show_spooldir_page(void);
Xextern int prompt_spooldir_num(int ch);
Xextern void erase_spooldir_arrow(void);
Xextern void draw_spooldir_arrow(void);
Xextern int load_spooldirs(void);
Xextern void get_spooldir(void);
Xextern int set_spooldir(char *name);
X/* thread.c */
Xextern int show_thread(int respnum, char *group, char *group_path);
Xextern void show_thread_page(void);
Xextern void draw_thread_arrow(void);
Xextern void erase_thread_arrow(void);
Xextern int prompt_thread_num(int ch);
Xextern int new_responses(int thread);
Xextern int which_thread(int n);
Xextern int which_response(int n);
Xextern int num_of_responses(int n);
Xextern int stat_thread(int n, struct art_stat_t *sbuf);
Xextern int next_response(int n);
Xextern int next_thread(int n);
Xextern int prev_response(int n);
Xextern int choose_response(int i, int n);
Xextern int next_unread(int n);
Xextern int prev_unread(int n);
X/* wildmat.c */
Xextern int wildmat(char *text, char *p);
X 
X#else
X 
X/* active.c */
Xextern void resync_active_file(/*void*/);
Xextern int read_active_file(/*void*/);
Xextern int backup_active(/*int create*/);
Xextern void notify_groups(/*void*/);
Xextern void mark_unthreaded_groups(/*void*/);
X/* art.c */
Xextern void find_base(/*int only_unread*/);
Xextern int num_of_arts(/*void*/);
Xextern int valid_artnum(/*long art*/);
Xextern int purge_needed(/*void*/);
Xextern void index_group(/*char *group, char *group_path*/);
Xextern int read_group(/*char *group, char *group_path*/);
Xextern void make_threads(/*int rethread*/);
Xextern int parse_headers(/*FILE *fp, struct article_t *h*/);
Xextern void write_index_file(/*char *group*/);
Xextern int read_index_file(/*char *group_name*/);
Xextern void find_index_file(/*char *group*/);
Xextern void do_update(/*void*/);
Xextern char *parse_date(/*char *date, char *str*/);
Xextern int artnum_comp(/*char *p1, char *p2*/);
Xextern int subj_comp(/*char *p1, char *p2*/);
Xextern int from_comp(/*char *p1, char *p2*/);
Xextern int date_comp(/*char *p1, char *p2*/);
Xextern void set_article(/*struct article_t *art*/);
X/* curses.c */
Xextern int InitScreen(/*void*/);
Xextern void ScreenSize(/*int *num_lines, int *num_columns*/);
Xextern void InitWin(/*void*/);
Xextern void EndWin(/*void*/);
Xextern void ClearScreen(/*void*/);
Xextern void MoveCursor(/*int row, int col*/);
Xextern void CleartoEOLN(/*void*/);
Xextern void CleartoEOS(/*void*/);
Xextern void StartInverse(/*void*/);
Xextern void EndInverse(/*void*/);
Xextern int RawState(/*void*/);
Xextern void Raw(/*int state*/);
Xextern int ReadCh(/*void*/);
Xextern int outchar(/*int c*/);
X/* debug.c */
Xextern void debug_nntp(/*char *func, char *line*/);
Xextern void debug_nntp_respcode(/*int respcode*/);
Xextern void debug_print_arts(/*void*/);
Xextern void debug_print_header(/*struct article_t *s*/);
Xextern void debug_print_comment(/*char *comment*/);
Xextern void debug_print_base(/*void*/);
Xextern void debug_print_active(/*void*/);
X/* feed.c */
Xextern void feed_articles(/*int function, int level, char *prompt, int respnum, char *group_path*/);
Xextern int print_file(/*FILE *fp, int respnum, int count*/);
X/* getline.c */
Xextern char *getline(/*char *prompt, int number_only, char *str*/);
X/* group.c */
Xextern void group_page(/*char *group*/);
Xextern void fix_new_highest(/*int groupnum*/);
Xextern void show_group_page(/*char *group*/);
Xextern void draw_subject_arrow(/*void*/);
Xextern void erase_subject_arrow(/*void*/);
Xextern void prompt_subject_num(/*int ch, char *group*/);
Xextern void clear_note_area(/*void*/);
Xextern int find_new_pos(/*int old_top, long old_artnum, int cur_pos*/);
Xextern void mark_screen(/*int level, int screen_row, int screen_col, char *value*/);
Xextern void set_subj_from_size(/*int num_cols*/);
Xextern void toggle_subject_from(/*void*/);
X/* hashstr.c */
Xextern char *hash_str(/*char *s*/);
Xextern struct hashnode *add_string(/*char *s*/);
Xextern void hash_init(/*void*/);
Xextern void hash_reclaim(/*void*/);
X/* help.c */
Xextern void show_info_page(/*int type, char *help[], char *title*/);
X/* inews.c */
Xextern int submit_inews(/*char *name*/);
Xextern void get_host_name(/*char *host_name*/);
Xextern void get_from_name(/*char *from_name*/);
X/* init.c */
Xextern void init_selfinfo(/*void*/);
Xextern void set_tindir(/*void*/);
Xextern int create_mail_save_dirs(/*void*/);
X/* kill.c */
Xextern int read_kill_file(/*void*/);
Xextern void write_kill_file(/*void*/);
Xextern int kill_art_menu(/*char *group_name, int index*/);
Xextern int unkill_all_articles(/*void*/);
Xextern int kill_any_articles(/*char *group*/);
X/* lang.c */
X/* main.c */
Xextern void main(/*int argc, char *argv[]*/);
Xextern void read_cmd_line_options(/*int argc, char *argv[]*/);
Xextern void usage(/*char *progname*/);
Xextern int check_for_any_new_news(/*int check_any_unread, int start_any_unread*/);
Xextern void save_or_mail_new_news(/*void*/);
Xextern void update_index_files(/*void*/);
Xextern void show_intro_page(/*void*/);
X/* memory.c */
Xextern void init_alloc(/*void*/);
Xextern void expand_art(/*void*/);
Xextern void expand_active(/*void*/);
Xextern void expand_kill(/*void*/);
Xextern void expand_save(/*void*/);
Xextern void init_screen_array(/*int allocate*/);
Xextern void free_all_arrays(/*void*/);
Xextern void free_art_array(/*void*/);
Xextern void free_active_arrays(/*void*/);
Xextern void free_kill_array(/*void*/);
Xextern void free_save_array(/*void*/);
Xextern char *my_malloc(/*unsigned size*/);
Xextern char *my_realloc(/*char *p, unsigned size*/);
X/* misc.c */
Xextern void asfail(/*char *file, int line, char *cond*/);
Xextern void copy_fp(/*FILE *fp_ip, FILE *fp_op, char *prefix*/);
Xextern char *get_val(/*char *env, char *def*/);
Xextern int invoke_editor(/*char *nam*/);
Xextern void shell_escape(/*void*/);
Xextern void tin_done(/*int ret*/);
Xextern long hash_groupname(/*char *group*/);
Xextern void rename_file(/*char *old_filename, char *new_filename*/);
Xextern char *str_dup(/*char *str*/);
Xextern int invoke_cmd(/*char *nam*/);
Xextern void draw_percent_mark(/*int cur_num, int max_num*/);
Xextern void set_real_uid_gid(/*void*/);
Xextern void set_tin_uid_gid(/*void*/);
Xextern void basename(/*char *dirname, char *program*/);
Xextern void mail_setup(/*void*/);
Xextern int mail_check(/*void*/);
Xextern void parse_from(/*char *str, char *addr, char *name*/);
Xextern long my_atol(/*char *s, int n*/);
Xextern int my_stricmp(/*char *p, char *q*/);
Xextern char *eat_re(/*char *s*/);
Xextern long hash_s(/*char *s*/);
Xextern void my_strncpy(/*char *p, char *q, int n*/);
Xextern int untag_all_articles(/*void*/);
Xextern char *str_str(/*char *text, char *pattern, int patlen*/);
Xextern void get_author(/*int thread, int respnum, char *str*/);
Xextern void toggle_inverse_video(/*void*/);
Xextern int get_arrow_key(/*void*/);
X/* newsrc.c */
Xextern int auto_subscribe_groups(/*void*/);
Xextern void backup_newsrc(/*void*/);
Xextern void read_newsrc(/*int sub_only*/);
Xextern void write_newsrc(/*void*/);
Xextern void rewrite_newsrc(/*void*/);
Xextern void read_newsrc_line(/*char *group*/);
Xextern void update_newsrc(/*char *group, int groupnum, int mark_unread*/);
Xextern void subscribe(/*char *group, int ch, int num, int out_seq*/);
Xextern void reset_newsrc(/*void*/);
Xextern void delete_group(/*char *group*/);
Xextern int undel_group(/*void*/);
Xextern void mark_group_read(/*char *group, int groupnum*/);
Xextern void parse_seq(/*char *s*/);
Xextern int parse_unread(/*char *s, int groupnum*/);
Xextern int get_line_unread(/*char *group, int groupnum*/);
Xextern void print_seq(/*FILE *fp, int groupnum*/);
Xextern int pos_group_in_newsrc(/*char *group, int pos*/);
Xextern void mark_all_xref_read(/*char *xref_line*/);
X/* nntplib.c */
Xextern char *getserverbyfile(/*char *file*/);
Xextern int server_init(/*char *machine*/);
Xextern int get_tcp_socket(/*char *machine*/);
Xextern int handle_server_response(/*int response, char *nntpserver*/);
Xextern void put_server(/*char *string*/);
Xextern int get_server(/*char *string, int size*/);
Xextern void close_server(/*void*/);
X/* open.c */
Xextern void nntp_open(/*void*/);
Xextern void nntp_close(/*void*/);
Xextern FILE *open_active_fp(/*void*/);
Xextern FILE *open_subscription_fp(/*void*/);
Xextern FILE *open_index_fp(/*char *group_name*/);
Xextern FILE *open_art_fp(/*char *group_path, long art*/);
Xextern FILE *open_header_fp(/*char *group_path, long art*/);
Xextern int base_comp(/*char *p1, char *p2*/);
Xextern void setup_base(/*char *group, char *group_path*/);
Xextern int get_respcode(/*void*/);
Xextern int stuff_nntp(/*char *fnam*/);
Xextern FILE *nntp_to_fp(/*void*/);
Xextern int nntp_to_fd(/*void*/);
Xextern void log_user(/*void*/);
Xextern char *nntp_respcode(/*int respcode*/);
X/* page.c */
Xextern int show_page(/*int respnum, int *threadnum, char *group, char *group_path*/);
Xextern void redraw_page(/*int respnum, char *group*/);
Xextern void show_note_page(/*int respnum, char *group*/);
Xextern void show_first_header(/*int respnum, char *group*/);
Xextern void show_cont_header(/*int respnum*/);
Xextern int art_open(/*long art, char *group_path*/);
Xextern void art_close(/*void*/);
Xextern int prompt_response(/*int ch, int respnum*/);
Xextern void yank_to_addr(/*char *orig, char *addr*/);
Xextern int show_last_page(/*void*/);
Xextern int match_header(/*char *buf, char *pat, char *body, int len*/);
X/* post.c */
Xextern int user_posted_messages(/*void*/);
Xextern void update_art_posted_file(/*char *group, int action, char *subj*/);
Xextern int post_header_ok(/*char *article*/);
Xextern int post_base(/*char *group, int *posted*/);
Xextern int post_response(/*char *group, int respnum, int copy_text*/);
Xextern int mail_to_someone(/*char *address, int confirm_to_mail, int *mailed_ok*/);
Xextern int mail_bug_report(/*void*/);
Xextern int mail_to_author(/*char *group, int respnum, int copy_text*/);
Xextern void find_mail_header(/*int header, char *file, char *value*/);
Xextern int cancel_article(/*char *group, int respnum*/);
Xextern int crosspost_article(/*char *group, int respnum*/);
Xextern int submit_file(/*char *name*/);
Xextern void add_signature(/*FILE *fp, int flag*/);
Xextern void insert_x_headers(/*char *infile*/);
Xextern void find_reply_to_addr(/*int respnum, char *from_addr*/);
X/* prompt.c */
Xextern int prompt_num(/*int ch, char *prompt*/);
Xextern int prompt_string(/*char *prompt, char *buf*/);
Xextern int prompt_menu_string(/*int line, int col, char *var*/);
Xextern int prompt_yn(/*int line, char *prompt, int prompt_ch*/);
Xextern void prompt_on_off(/*int row, int col, int *var, char *help_text, char *prompt_text*/);
Xextern void continue_prompt(/*void*/);
X/* rcfile.c */
Xextern int read_rcfile(/*void*/);
Xextern void write_rcfile(/*void*/);
Xextern int change_rcfile(/*char *group, int kill_at_once*/);
Xextern void show_rcfile_menu(/*void*/);
Xextern void expand_rel_abs_pathname(/*int line, int col, char *str*/);
Xextern void show_menu_help(/*char *help_message*/);
Xextern int match_boolean(/*char *line, char *pat, int *dst*/);
Xextern int match_number(/*char *line, char *pat, int *dst*/);
Xextern int match_string(/*char *line, char *pat, char *dst, int dstlen*/);
X/* save.c */
Xextern int check_start_save_any_news(/*int check_start_save*/);
Xextern int save_art_to_file(/*int respnum, int index, int mailbox, char *filename*/);
Xextern int save_thread_to_file(/*int is_mailbox, char *group_path*/);
Xextern int save_regex_arts(/*int is_mailbox, char *group_path*/);
Xextern int append_to_existing_file(/*int i*/);
Xextern int create_path(/*char *path*/);
Xextern int create_sub_dir(/*int i*/);
Xextern void add_to_save_list(/*int index, struct article_t *article, int is_mailbox, char *path*/);
Xextern void sort_save_list(/*void*/);
Xextern int save_comp(/*char *p1, char *p2*/);
Xextern char *save_filename(/*int i*/);
Xextern char *get_first_savefile(/*void*/);
Xextern char *get_last_savefile(/*void*/);
Xextern int post_process_files(/*int proc_type_ch*/);
Xextern void post_process_uud(/*int pp*/);
Xextern void post_process_sh(/*void*/);
Xextern char *get_archive_file(/*char *dir, char *ext*/);
Xextern void delete_processed_files(/*void*/);
X/* screen.c */
Xextern void info_message(/*char *str*/);
Xextern void wait_message(/*char *str*/);
Xextern void error_message(/*char *template, char *str*/);
Xextern void perror_message(/*char *template, char *str*/);
Xextern void clear_message(/*void*/);
Xextern void center_line(/*int line, int inverse, char *str*/);
Xextern void draw_arrow(/*int line*/);
Xextern void erase_arrow(/*int line*/);
Xextern void show_title(/*char *title*/);
Xextern void ring_bell(/*void*/);
X/* search.c */
Xextern int search_author(/*int only_unread, int current_art, int forward*/);
Xextern void search_group(/*int forward*/);
Xextern void search_subject(/*int forward, char *group*/);
Xextern int search_article(/*int forward*/);
Xextern void make_lower(/*char *s, char *t*/);
X/* select.c */
Xextern void selection_index(/*int start_groupnum*/);
Xextern void group_selection_page(/*void*/);
Xextern int prompt_group_num(/*int ch*/);
Xextern void erase_group_arrow(/*void*/);
Xextern void draw_group_arrow(/*void*/);
Xextern int choose_new_group(/*void*/);
Xextern int add_group(/*char *s, int get_unread*/);
Xextern int reposition_group(/*char *group, int default_num*/);
Xextern void catchup_group(/*int goto_next_unread_group*/);
Xextern void next_unread_group(/*int enter_group*/);
Xextern void set_groupname_len(/*int all_groups*/);
X/* signal.c */
Xextern sigtype_t (*sigdisp(/*int sig, sigtype_t (*func)()*/))();
Xextern void set_signal_handlers(/*void*/);
Xextern void set_alarm_signal(/*void*/);
Xextern void signal_handler(/*int sig*/);
Xextern void set_win_size(/*int *num_lines, int *num_cols*/);
Xextern void set_signals_art(/*void*/);
Xextern void set_signals_group(/*void*/);
Xextern void set_signals_page(/*void*/);
Xextern void set_signals_select(/*void*/);
Xextern void set_signals_spooldir(/*void*/);
Xextern void set_signals_thread(/*void*/);
Xextern void art_suspend(/*int sig*/);
Xextern void main_suspend(/*int sig*/);
Xextern void select_suspend(/*int sig*/);
Xextern void spooldir_suspend(/*int sig*/);
Xextern void group_suspend(/*int sig*/);
Xextern void page_suspend(/*int sig*/);
Xextern void thread_suspend(/*int sig*/);
Xextern void rcfile_suspend(/*int sig*/);
Xextern void art_resize(/*int sig*/);
Xextern void main_resize(/*int sig*/);
Xextern void select_resize(/*int sig*/);
Xextern void spooldir_resize(/*int sig*/);
Xextern void group_resize(/*int sig*/);
Xextern void page_resize(/*int sig*/);
Xextern void thread_resize(/*int sig*/);
X/* spooldir.c */
Xextern int spooldir_index(/*void*/);
Xextern void show_spooldir_page(/*void*/);
Xextern int prompt_spooldir_num(/*int ch*/);
Xextern void erase_spooldir_arrow(/*void*/);
Xextern void draw_spooldir_arrow(/*void*/);
Xextern int load_spooldirs(/*void*/);
Xextern void get_spooldir(/*void*/);
Xextern int set_spooldir(/*char *name*/);
X/* thread.c */
Xextern int show_thread(/*int respnum, char *group, char *group_path*/);
Xextern void show_thread_page(/*void*/);
Xextern void draw_thread_arrow(/*void*/);
Xextern void erase_thread_arrow(/*void*/);
Xextern int prompt_thread_num(/*int ch*/);
Xextern int new_responses(/*int thread*/);
Xextern int which_thread(/*int n*/);
Xextern int which_response(/*int n*/);
Xextern int num_of_responses(/*int n*/);
Xextern int stat_thread(/*int n, struct art_stat_t *sbuf*/);
Xextern int next_response(/*int n*/);
Xextern int next_thread(/*int n*/);
Xextern int prev_response(/*int n*/);
Xextern int choose_response(/*int i, int n*/);
Xextern int next_unread(/*int n*/);
Xextern int prev_unread(/*int n*/);
X/* wildmat.c */
Xextern int wildmat(/*char *text, char *p*/);
X 
X#endif
END_OF_FILE
  if test 27832 -ne `wc -c <'proto.h'`; then
    echo shar: \"'proto.h'\" unpacked with wrong size!
  fi
  # end of 'proto.h'
fi
if test -f 'rcfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcfile.c'\"
else
  echo shar: Extracting \"'rcfile.c'\" \(23814 characters\)
  sed "s/^X//" >'rcfile.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : rcfile.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 09-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern int index_point;
X
Xstatic int COL1;
Xstatic int COL2;
Xstatic int COL3;
X
X/*
X *  read_rcfile - read defaults from ~/.tin/tinrc
X */
X
Xint read_rcfile ()
X{
X	char buf[LEN];
X	FILE *fp;
X
X	if ((fp = fopen (rcfile, "r")) == NULL) {
X		return (FALSE);
X	}	
X
X	while (fgets (buf, sizeof (buf), fp) != NULL) {
X		if (buf[0] == '#' || buf[0] == '\n') { 
X			continue;
X		}	
X		if (match_boolean (buf, "save_archive=", &save_archive_name)) {
X			continue;
X		}	
X		if (match_boolean (buf, "start_editor_offset=", &start_editor_offset)) {
X			continue;
X		}	
X		if (match_boolean (buf, "mark_saved_read=", &mark_saved_read)) {
X			continue;
X		}	
X		if (match_boolean (buf, "draw_arrow=", &draw_arrow_mark)) {
X			if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X				inverse_okay = TRUE;
X			}
X			continue;
X		}	
X		if (match_boolean (buf, "print_header=", &print_header)) {
X			continue;
X		}
X		if (match_number (buf, "kill_level=", &kill_level)) {
X			continue;
X		}
X		if (match_boolean (buf, "pos_first_unread=", &pos_first_unread)) {
X			continue;
X		}	
X		if (match_boolean (buf, "full_page_scroll=", &full_page_scroll)) {
X			continue;
X		}	
X		if (match_boolean (buf, "catchup_read_groups=", &catchup_read_groups)) {
X			continue;
X		}	
X		if (match_boolean (buf, "thread_articles=", &thread_arts)) {
X			continue;
X		}	
X		if (match_boolean (buf, "unlink_article=", &unlink_article)) {
X			continue;
X		}	
X		if (match_boolean (buf, "show_only_unread=", &show_only_unread)) {
X			continue;
X		}	
X		if (match_boolean (buf, "confirm_action=", &confirm_action)) {
X			continue;
X		}
X		if (match_number (buf, "show_author=", &default_show_author)) {
X			continue;
X		}	
X		if (match_number (buf, "post_process_type=", &post_proc_type)) {
X			switch (post_proc_type) {
X				case POST_PROC_SHAR:
X					proc_ch_default = 's';
X					break;
X				case POST_PROC_UUDECODE:
X					proc_ch_default = 'u';
X					break;
X				case POST_PROC_UUD_LST_ZOO:
X					proc_ch_default = 'U';
X					break;
X				case POST_PROC_UUD_EXT_ZOO:
X					proc_ch_default = 'U';
X					break;
X				case POST_PROC_NONE:
X				default:
X					proc_ch_default = 'n';
X					break;
X			}
X			continue;
X		}	
X		if (match_number (buf, "sort_article_type=", &sort_art_type)) {
X			continue;
X		}	
X		if (match_string (buf, "savedir=", default_savedir, sizeof (default_savedir))) {
X			if (default_savedir[0] == '.' && strlen (default_savedir) == 1) {
X#if defined(BSD) && ! defined(sinix)
X				getwd (buf);	
X#else
X				getcwd (buf, LEN);
X#endif
X				my_strncpy (default_savedir, buf, sizeof (default_savedir));
X			}
X			continue;
X		}	
X		if (match_string (buf, "maildir=", default_maildir, sizeof (default_maildir))) {
X			continue;
X		}
X		if (match_string (buf, "printer=", printer, sizeof (printer))) {
X			continue;
X		}
X		if (match_string (buf, "default_spooldir_alias=", spooldir_alias, sizeof (spooldir_alias))) {
X			set_tindir ();
X			continue;
X		}
X		if (match_string (buf, "default_author_search=", default_author_search, sizeof (default_author_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_goto_group=", default_goto_group, sizeof (default_goto_group))) {
X			continue;
X		}
X		if (match_string (buf, "default_group_search=", default_group_search, sizeof (default_group_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_subject_search=", default_subject_search, sizeof (default_subject_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_art_search=", default_art_search, sizeof (default_art_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_crosspost_group=", default_crosspost_group, sizeof (default_crosspost_group))) {
X			continue;
X		}
X		if (match_string (buf, "default_mail_address=", default_mail_address, sizeof (default_mail_address))) {
X			continue;
X		}
X		if (match_number (buf, "default_move_group=", &default_move_group)) {
X			continue;
X		}
X		if (match_string (buf, "default_pipe_command=", default_pipe_command, sizeof (default_pipe_command))) {
X			continue;
X		}
X		if (match_string (buf, "default_post_subject=", default_post_subject, sizeof (default_post_subject))) {
X			continue;
X		}
X		if (match_string (buf, "default_regex_pattern=", default_regex_pattern, sizeof (default_regex_pattern))) {
X			continue;
X		}
X		if (match_string (buf, "default_save_file=", default_save_file, sizeof (default_save_file))) {
X			continue;
X		}
X		if (match_string (buf, "default_shell_command=", default_shell_command, sizeof (default_shell_command))) {
X			continue;
X		}
X	}
X	fclose (fp);
X	return TRUE;		
X}
X
X
X/*
X *  write_rcfile - write defaults to ~/.tin/tinrc
X */
X
Xvoid write_rcfile ()
X{
X	FILE *fp;
X
X	if ((fp = fopen (rcfile, "w")) == NULL) {
X		return;
X	}	
X	
X	if (! cmd_line) {
X		wait_message (txt_saving);
X	}
X	fprintf (fp, "# if ON articles/threads with Archive-name: in mail header will\n");
X	fprintf (fp, "# be automatically saved with the Archive-name & part/patch no.\n");
X	fprintf (fp, "save_archive=%s\n\n", (save_archive_name ? "ON" : "OFF"));
X	fprintf (fp, "# if ON articles of a threads will be saved to separate files\n");
X	fprintf (fp, "# otherwise the whole thread will be saved to one file\n");
X	fprintf (fp, "start_editor_offset=%s\n\n", (start_editor_offset ? "ON" : "OFF"));
X	fprintf (fp, "# if ON mark articles that are saved as read\n");
X	fprintf (fp, "mark_saved_read=%s\n\n", (mark_saved_read ? "ON" : "OFF"));
X	fprintf (fp, "# if 0 killed articles are simply marked as being read\n");
X	fprintf (fp, "# if 1 killed articles are removed and never seen\n");
X	fprintf (fp, "kill_level=%d\n\n", kill_level);
X	fprintf (fp, "# if ON use -> otherwise highlighted bar for selection\n");
X	fprintf (fp, "draw_arrow=%s\n\n", (draw_arrow_mark ? "ON" : "OFF"));
X	fprintf (fp, "# if ON print all of mail header otherwise Subject: & From: lines\n");
X	fprintf (fp, "print_header=%s\n\n", (print_header ? "ON" : "OFF"));
X	fprintf (fp, "# if ON put cursor at first unread art in group otherwise last art\n");
X	fprintf (fp, "pos_first_unread=%s\n\n", (pos_first_unread ? "ON" : "OFF"));
X	fprintf (fp, "# if ON scroll full page of groups/articles otherwise half a page\n");
X	fprintf (fp, "full_page_scroll=%s\n\n", (full_page_scroll ? "ON" : "OFF"));
X	fprintf (fp, "# if ON ask user if read groups should all be marked read\n");
X	fprintf (fp, "catchup_read_groups=%s\n\n", (catchup_read_groups ? "ON" : "OFF"));
X	fprintf (fp, "# if ON confirm certain commands with y/n before executing\n");
X	fprintf (fp, "confirm_action=%s\n\n", (confirm_action ? "ON" : "OFF"));
X	fprintf (fp, "# part of from field to display 0) none 1) address 2) full name 3) both\n");
X	fprintf (fp, "show_author=%d\n\n", default_show_author);
X	fprintf (fp, "# type of post processing to perform after saving articles.\n");
X	fprintf (fp, "# 0=(none) 1=(shar) 2=(uudecode) 3=(uud & list zoo) 4=(uud & extract zoo) 5=(patch).\n");
X	fprintf (fp, "post_process_type=%d\n\n", post_proc_type);
X	fprintf (fp, "# if ON and group not in ~/.tin/unthread articles will be threaded.\n");
X	fprintf (fp, "thread_articles=%s\n\n", (thread_arts ? "ON" : "OFF"));
X	fprintf (fp, "# if ON remove ~/.article after posting.\n");
X	fprintf (fp, "unlink_article=%s\n\n", (unlink_article ? "ON" : "OFF"));
X	fprintf (fp, "# if ON show only new/unread articles otherwise show all.\n");
X	fprintf (fp, "show_only_unread=%s\n\n", (show_only_unread ? "ON" : "OFF"));
X	fprintf (fp, "# sort articles by 0=(nothing) 1=(Subject descend) 2=(Subject ascend)\n");
X	fprintf (fp, "# 3=(From descend) 4=(From ascend) 5=(Date descend) 6=(Date ascend).\n");
X	fprintf (fp, "sort_article_type=%d\n\n", sort_art_type);
X	fprintf (fp, "# (-d) directory where articles/threads are saved\n");
X	fprintf (fp, "savedir=%s\n\n", default_savedir);
X	fprintf (fp, "# (-M) directory where articles/threads are saved in mailbox format\n");	
X	fprintf (fp, "maildir=%s\n\n", default_maildir);	
X	fprintf (fp, "# (-p) print program with parameters used to print articles/threads\n");
X	fprintf (fp, "printer=%s\n\n", printer);
X
X	fprintf (fp, "# default actions/prompt strings for questions\n");
X	fprintf (fp, "default_spooldir_alias=%s\n", spooldir_alias);
X	fprintf (fp, "default_author_search=%s\n", default_author_search);
X	fprintf (fp, "default_goto_group=%s\n", default_goto_group);
X	fprintf (fp, "default_group_search=%s\n", default_group_search);
X	fprintf (fp, "default_subject_search=%s\n", default_subject_search);
X	fprintf (fp, "default_art_search=%s\n", default_art_search);
X	fprintf (fp, "default_crosspost_group=%s\n", default_crosspost_group);
X	fprintf (fp, "default_mail_address=%s\n", default_mail_address);
X	fprintf (fp, "default_move_group=%d\n", default_move_group);
X	fprintf (fp, "default_pipe_command=%s\n", default_pipe_command);
X	fprintf (fp, "default_post_subject=%s\n", default_post_subject);
X	fprintf (fp, "default_regex_pattern=%s\n", default_regex_pattern);
X	fprintf (fp, "default_save_file=%s\n", default_save_file);
X	fprintf (fp, "default_shell_command=%s\n", default_shell_command);
X
X	fclose (fp);
X	chmod (rcfile, 0600);
X}
X
X/*
X *  options menu so that the user can dynamically change parameters
X */
X 
Xint change_rcfile (group, kill_at_once)
X	char *group;
X	int kill_at_once;
X{
X	char *str = (char *) 0;
X	int ch, i;
X	int kill_changed = FALSE;
X	int orig_kill_state;
X	int orig_show_only_unread;
X	int orig_thread_arts;
X	int option;
X	int ret_code = NO_KILLING;
X	int var_orig;
X	
X#ifdef SIGTSTP
X	sigtype_t (*susp)() = (sigtype_t *) 0;
X
X	if (do_sigtstp) {
X		susp = sigdisp (SIGTSTP, SIG_DFL);
X	}
X#endif
X
X	COL1 = 0;
X	COL2 = ((COLS / 3) * 1) + 1;
X	COL3 = ((COLS / 3) * 2) + 2;
X
X	show_rcfile_menu ();
X
X	while (1) {
X
X#ifdef SIGTSTP
X		if (do_sigtstp) {
X			sigdisp (SIGTSTP, rcfile_suspend);
X		}
X#endif
X		MoveCursor (LINES, 0);
X		ch = ReadCh ();
X		if (ch >= '1' && ch <= '9') {
X			option = prompt_num (ch, "Enter option number> ");
X		} else {
X			if (ch == 'q' || ch == ESC) {
X				option = -1;
X			} else {
X				option = 0;
X			}
X		}
X#ifdef SIGTSTP
X		if (do_sigtstp) {
X			sigdisp (SIGTSTP, SIG_IGN);
X		}
X#endif
X		switch (option) {
X			case 0:
X				write_rcfile ();
X				/* FALLTHRU */
X			case -1:
X				if (kill_changed) {
X					if (kill_at_once) {
X						if (killed_articles = read_kill_file ()) {
X							if (kill_any_articles (group)) {
X								make_threads (FALSE);
X								find_base (show_only_unread);
X							}
X						} else {
X							if (unkill_all_articles()) {
X								make_threads (FALSE);
X								find_base (show_only_unread);
X							}
X						}
X					}
X					ret_code = KILLING;
X				}
X
X				clear_note_area ();
X#ifdef SIGTSTP
X				if (do_sigtstp) {
X					sigdisp (SIGTSTP, susp);
X				}
X#endif
X				return ret_code;
X			
X			case 1:		/* auto save */
X				prompt_on_off (INDEX_TOP, COL1, &save_archive_name, 
X					txt_help_autosave, txt_opt_autosave);
X				break;
X
X			case 2:		/* start editor with line offset */
X				prompt_on_off (INDEX_TOP, COL2, &start_editor_offset, 
X					txt_help_start_editor_offset, txt_opt_start_editor_offset);
X				break;
X			
X			case 3:		/* mark saved articles read */
X				prompt_on_off (INDEX_TOP, COL3, &mark_saved_read, 
X					txt_help_mark_saved_read, txt_opt_mark_saved_read);
X				break;
X
X			case 4:		/* confirm action */
X				prompt_on_off (INDEX_TOP+2, COL1, &confirm_action, 
X					txt_help_confirm_action, txt_opt_confirm_action);
X				break;
X
X			case 5:		/* draw -> / highlighted bar */
X				prompt_on_off (INDEX_TOP+2, COL2, &draw_arrow_mark, 
X					txt_help_draw_arrow, txt_opt_draw_arrow);
X				if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X					inverse_okay = TRUE;
X				}
X				break;
X
X			case 6:		/* print header */
X				prompt_on_off (INDEX_TOP+2, COL3, &print_header, 
X					txt_help_print_header, txt_opt_print_header);
X				break;
X			
X			case 7:		/* position cursor at first / last unread art */
X				prompt_on_off (INDEX_TOP+4, COL1, &pos_first_unread, 
X					txt_help_pos_first_unread, txt_opt_pos_first_unread);
X				break;
X
X			case 8:		/* scroll half/full page of groups/articles */
X				prompt_on_off (INDEX_TOP+4, COL2, &full_page_scroll, 
X					txt_help_page_scroll, txt_opt_page_scroll);
X				break;
X
X			case 9:		/* catchup read groups when quitting */
X				prompt_on_off (INDEX_TOP+4, COL3, &catchup_read_groups, 
X					txt_help_catchup_groups, txt_opt_catchup_groups);
X				break;
X
X			case 10:	/* thread/unthread all groups except those in ~/.tin/unthreaded */
X				orig_thread_arts = thread_arts;	
X				prompt_on_off (INDEX_TOP+6, COL1, &thread_arts, 
X					txt_help_thread_arts, txt_opt_thread_arts);
X				if (thread_arts != orig_thread_arts || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X				}
X				break;
X
X			case 11:	/* show all arts or just new/unread arts */
X				orig_show_only_unread = show_only_unread;	
X				prompt_on_off (INDEX_TOP+6, COL2, &show_only_unread, 
X					txt_help_show_only_unread, txt_opt_show_only_unread);
X				if (show_only_unread != orig_show_only_unread || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X					if (space_mode) {
X						for (i = 0; i < top_base; i++) {
X							if (new_responses (i)) {
X								break;
X							}
X						}
X						if (i < top_base) {
X							index_point = i;
X						} else {
X							index_point = top_base - 1;
X						}
X					} else {
X						index_point = top_base - 1;
X					}
X				}
X				break;
X
X			case 13:		/* show subject & author / subject only */
X				var_orig = show_author;
X				show_menu_help (txt_help_show_author);
X				do {
X					MoveCursor (INDEX_TOP+8, COL1 + (int) strlen (txt_opt_show_author));
X					if ((ch	= ReadCh()) == ' ') {
X						if (show_author + 1 > SHOW_FROM_BOTH) {
X							show_author = SHOW_FROM_NONE;
X						} else {
X							show_author++;
X						}
X						switch (show_author) {
X							case SHOW_FROM_NONE:
X								str = txt_show_from_none;
X								break;
X							case SHOW_FROM_ADDR:
X								str = txt_show_from_addr;
X								break;
X							case SHOW_FROM_NAME:
X								str = txt_show_from_name;
X								break;
X							case SHOW_FROM_BOTH:
X								str = txt_show_from_both;
X								break;
X						}
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					show_author = var_orig;
X					switch (show_author) {
X						case SHOW_FROM_NONE:
X							str = txt_show_from_none;
X							break;
X						case SHOW_FROM_ADDR:
X							str = txt_show_from_addr;
X							break;
X						case SHOW_FROM_NAME:
X							str = txt_show_from_name;
X							break;
X						case SHOW_FROM_BOTH:
X							str = txt_show_from_both;
X							break;
X					}
X					fputs (str, stdout);
X					fflush (stdout);
X				} else {
X					default_show_author = show_author;
X					set_subj_from_size (COLS);
X				}
X				break;
X
X			case 14:
X				var_orig = post_proc_type;
X				show_menu_help (txt_help_post_proc_type);
X				do {
X					MoveCursor (INDEX_TOP+8, COL2 + (int) strlen (txt_opt_process_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (post_proc_type + 1 > POST_PROC_UUD_EXT_ZOO) {
X							post_proc_type = POST_PROC_NONE;
X						} else {
X							post_proc_type++;
X						}
X						switch (post_proc_type) {
X							case POST_PROC_NONE:
X								str = txt_post_process_none;
X								proc_ch_default = 'n';
X								break;
X							case POST_PROC_SHAR:
X								str = txt_post_process_sh;
X								proc_ch_default = 's';
X								break;
X							case POST_PROC_UUDECODE:
X								str = txt_post_process_uudecode;
X								proc_ch_default = 'u';
X								break;
X							case POST_PROC_UUD_LST_ZOO:
X								str = txt_post_process_uud_lst_zoo;
X								proc_ch_default = 'U';
X								break;
X							case POST_PROC_UUD_EXT_ZOO:
X								str = txt_post_process_uud_ext_zoo;
X								proc_ch_default = 'U';
X								break;
X						}
X						CleartoEOLN (); 
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					post_proc_type = var_orig;
X					switch (post_proc_type) {
X						case POST_PROC_NONE:
X							str = txt_post_process_none;
X							proc_ch_default = 'n';
X							break;
X						case POST_PROC_SHAR:
X							str = txt_post_process_sh;
X							proc_ch_default = 's';
X							break;
X						case POST_PROC_UUDECODE:
X							str = txt_post_process_uudecode;
X							proc_ch_default = 'u';
X							break;
X						case POST_PROC_UUD_LST_ZOO:
X							str = txt_post_process_uud_lst_zoo;
X							proc_ch_default = 'U';
X							break;
X						case POST_PROC_UUD_EXT_ZOO:
X							str = txt_post_process_uud_ext_zoo;
X							proc_ch_default = 'U';
X							break;
X					}
X					CleartoEOLN (); 
X					fputs (str, stdout);
X					fflush (stdout);
X				}
X				break;
X
X			case 15:
X				var_orig = sort_art_type;
X				show_menu_help (txt_help_sort_type);
X				do {
X					MoveCursor (INDEX_TOP+10, COL1 + (int) strlen (txt_opt_sort_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (sort_art_type + 1 > SORT_BY_DATE_ASCEND) {
X							sort_art_type = SORT_BY_NOTHING;
X						} else {
X							sort_art_type++;
X						}
X						switch (sort_art_type) {
X							case SORT_BY_NOTHING:
X								str = txt_sort_by_nothing;
X								break;
X							case SORT_BY_SUBJ_DESCEND:
X								str = txt_sort_by_subj_descend;
X								break;
X							case SORT_BY_SUBJ_ASCEND:
X								str = txt_sort_by_subj_ascend;
X								break;
X							case SORT_BY_FROM_DESCEND:
X								str = txt_sort_by_from_descend;
X								break;
X							case SORT_BY_FROM_ASCEND:
X								str = txt_sort_by_from_ascend;
X								break;
X							case SORT_BY_DATE_DESCEND:
X								str = txt_sort_by_date_descend;
X								break;
X							case SORT_BY_DATE_ASCEND:
X								str = txt_sort_by_date_ascend;
X								break;
X						}
X						CleartoEOLN (); 
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					sort_art_type = var_orig;
X					switch (sort_art_type) {
X						case SORT_BY_NOTHING:
X							str = txt_sort_by_nothing;
X							break;
X						case SORT_BY_SUBJ_DESCEND:
X							str = txt_sort_by_subj_descend;
X							break;
X						case SORT_BY_SUBJ_ASCEND:
X							str = txt_sort_by_subj_ascend;
X							break;
X						case SORT_BY_FROM_DESCEND:
X							str = txt_sort_by_from_descend;
X							break;
X						case SORT_BY_FROM_ASCEND:
X							str = txt_sort_by_from_ascend;
X							break;
X						case SORT_BY_DATE_DESCEND:
X							str = txt_sort_by_date_descend;
X							break;
X						case SORT_BY_DATE_ASCEND:
X							str = txt_sort_by_date_ascend;
X							break;
X					}
X					CleartoEOLN (); 
X					fputs (str, stdout);
X					fflush (stdout);
X				}
X				break;
X
X			case 16:
X				show_menu_help (txt_help_savedir);
X				prompt_menu_string (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), default_savedir);
X				expand_rel_abs_pathname (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), default_savedir);
X				break;
X
X			case 17:
X				show_menu_help (txt_help_maildir);
X				prompt_menu_string (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), default_maildir);
X				expand_rel_abs_pathname (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), default_maildir);
X				break;
X
X			case 18:
X				show_menu_help (txt_help_printer);
X				prompt_menu_string (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				expand_rel_abs_pathname (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				break;
X		}
X		show_menu_help (txt_select_rcfile_option);
X	}
X}
X
X
Xvoid show_rcfile_menu ()
X{
X	char *str = (char *) 0;
X
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_options_menu);
X	
X	MoveCursor (INDEX_TOP, 0);
X	printf ("%s%s\r\n\r\n", txt_opt_autosave, (save_archive_name ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_confirm_action, (confirm_action ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_pos_first_unread, (pos_first_unread ? "ON " : "OFF"));
X	printf ("%s%s", txt_opt_thread_arts, (thread_arts ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL2);
X	printf ("%s%s", txt_opt_start_editor_offset, (start_editor_offset ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL2);
X	printf ("%s%s", txt_opt_draw_arrow, (draw_arrow_mark ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL2);
X	printf ("%s%s", txt_opt_page_scroll, (full_page_scroll ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+6, COL2);
X	printf ("%s%s", txt_opt_show_only_unread, (show_only_unread ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL3);
X	printf ("%s%s", txt_opt_mark_saved_read, (mark_saved_read ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL3);
X	printf ("%s%s", txt_opt_print_header, (print_header ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL3);
X	printf ("%s%s", txt_opt_catchup_groups, (catchup_read_groups ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP+8, COL1);
X	switch (show_author) {
X		case SHOW_FROM_NONE:
X			str = txt_show_from_none;
X			break;
X		case SHOW_FROM_ADDR:
X			str = txt_show_from_addr;
X			break;
X		case SHOW_FROM_NAME:
X			str = txt_show_from_name;
X			break;
X		case SHOW_FROM_BOTH:
X			str = txt_show_from_both;
X			break;
X	}
X	printf ("%s%s", txt_opt_show_author, str);
X	MoveCursor(INDEX_TOP+8, COL2);
X	switch (post_proc_type) {
X		case POST_PROC_NONE:
X			str = txt_post_process_none;
X			break;
X		case POST_PROC_SHAR:
X			str = txt_post_process_sh;
X			break;
X		case POST_PROC_UUDECODE:
X			str = txt_post_process_uudecode;
X			break;
X		case POST_PROC_UUD_LST_ZOO:
X			str = txt_post_process_uud_lst_zoo;
X			break;
X		case POST_PROC_UUD_EXT_ZOO:
X			str = txt_post_process_uud_ext_zoo;
X			break;
X	}
X	printf ("%s%s\r\n\r\n", txt_opt_process_type, str);
X	
X	MoveCursor(INDEX_TOP+10, COL1);
X	switch (sort_art_type) {
X		case SORT_BY_NOTHING:
X			str = txt_sort_by_nothing;
X			break;
X		case SORT_BY_SUBJ_DESCEND:
X			str = txt_sort_by_subj_descend;
X			break;
X		case SORT_BY_SUBJ_ASCEND:
X			str = txt_sort_by_subj_ascend;
X			break;
X		case SORT_BY_FROM_DESCEND:
X			str = txt_sort_by_from_descend;
X			break;
X		case SORT_BY_FROM_ASCEND:
X			str = txt_sort_by_from_ascend;
X			break;
X		case SORT_BY_DATE_DESCEND:
X			str = txt_sort_by_date_descend;
X			break;
X		case SORT_BY_DATE_ASCEND:
X			str = txt_sort_by_date_ascend;
X			break;
X	}
X	printf ("%s%s\r\n\r\n", txt_opt_sort_type, str);
X
X	printf ("%s%s\r\n\r\n", txt_opt_savedir, default_savedir);
X	printf ("%s%s\r\n\r\n", txt_opt_maildir, default_maildir);
X	printf ("%s%s\r\n\r\n", txt_opt_printer, printer);
X	fflush(stdout);
X
X	show_menu_help (txt_select_rcfile_option);
X	MoveCursor (LINES, 0);
X}
X
X/*
X *  expand ~/News to /usr/username/News and print to screen
X */
X 
Xvoid expand_rel_abs_pathname (line, col, str)
X	int line;
X	int col;
X	char *str;
X{
X	char buf[LEN];
X	
X	if (str[0] == '~') {
X		if (strlen (str) == 1) {
X			strcpy (str, homedir);
X		} else {
X			sprintf (buf, "%s%s", homedir, str+1);
X			strcpy (str, buf);
X		}
X	}
X	MoveCursor (line, col);
X	CleartoEOLN ();
X	puts (str);
X	fflush (stdout);
X}
X
X/*
X *  show_menu_help
X */
X 
Xvoid show_menu_help (help_message)
X	char *help_message;
X{
X	 MoveCursor (LINES-2, 0);
X	 CleartoEOLN ();
X	 center_line (LINES-2, FALSE, help_message);
X}
X
X
Xint match_boolean (line, pat, dst)
X	char *line;
X	char *pat;
X	int *dst;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		*dst = (strncmp (&line[patlen], "ON", 2) == 0 ? TRUE : FALSE);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X
Xint match_number (line, pat, dst)
X	char *line;
X	char *pat;
X	int *dst;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		*dst = atoi (&line[patlen]);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X
Xint match_string (line, pat, dst, dstlen)
X	char *line;
X	char *pat;
X	char *dst;
X	int dstlen;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		strncpy (dst, &line[patlen], dstlen);
X		dst[strlen (dst) - 1] = '\0';
X		return TRUE;
X	}
X	return FALSE;
X}
X
END_OF_FILE
  if test 23814 -ne `wc -c <'rcfile.c'`; then
    echo shar: \"'rcfile.c'\" unpacked with wrong size!
  fi
  # end of 'rcfile.c'
fi
echo shar: End of archive 5 \(of 14\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
