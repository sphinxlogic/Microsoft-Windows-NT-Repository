Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i003:  tin - threaded full screen newsreader, Part03/14
Message-ID: <1992May20.172213.28619@sparky.imd.sterling.com>
X-Md4-Signature: 20ce6cf814ad2429d2ff7d346223b4bc
Date: Wed, 20 May 1992 17:22:13 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 3
Archive-name: tin/part03
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  server.patch thread.c
# Wrapped by kent@sparky on Tue May 19 13:38:02 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 14)."'
if test -f 'server.patch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server.patch'\"
else
  echo shar: Extracting \"'server.patch'\" \(34102 characters\)
  sed "s/^X//" >'server.patch' <<'END_OF_FILE'
Xdiff -rcs server.old/Makefile server/Makefile
X*** server.old/Makefile	Mon May  4 07:03:54 1992
X--- server/Makefile	Mon May  4 07:16:35 1992
X***************
X*** 6,18 ****
X  	ahbs.o globals.o group.o help.o ihave.o list.o misc.o netaux.o \
X  	newgroups.o newnews.o nextlast.o ngmatch.o post.o parsit.o scandir.o \
X  	slave.o spawn.o strcasecmp.o subnet.o time.o xhdr.o fakesyslog.o \
X! 	batch.o auth.o timer.o ../common/version.o
X  
X  SRVRSRC = main.c serve.c access.c access_inet.c access_dnet.c active.c \
X  	ahbs.c globals.c group.c help.c ihave.c list.c misc.c netaux.c \
X  	newgroups.c newnews.c nextlast.c ngmatch.c post.c parsit.c scandir.c \
X  	slave.c spawn.c strcasecmp.c subnet.c time.c xhdr.c fakesyslog.c \
X! 	batch.c auth.c timer.c ../common/version.c
X  
X  SRVRINC = common.h ../common/conf.h ../common/nntp.h timer.h
X  
X--- 6,18 ----
X  	ahbs.o globals.o group.o help.o ihave.o list.o misc.o netaux.o \
X  	newgroups.o newnews.o nextlast.o ngmatch.o post.o parsit.o scandir.o \
X  	slave.o spawn.o strcasecmp.o subnet.o time.o xhdr.o fakesyslog.o \
X! 	batch.o auth.o timer.o ../common/version.o xuser.o xindex.o
X  
X  SRVRSRC = main.c serve.c access.c access_inet.c access_dnet.c active.c \
X  	ahbs.c globals.c group.c help.c ihave.c list.c misc.c netaux.c \
X  	newgroups.c newnews.c nextlast.c ngmatch.c post.c parsit.c scandir.c \
X  	slave.c spawn.c strcasecmp.c subnet.c time.c xhdr.c fakesyslog.c \
X! 	batch.c auth.c timer.c ../common/version.c xuser.c xindex.c
X  
X  SRVRINC = common.h ../common/conf.h ../common/nntp.h timer.h
X  
XFiles server.old/README and server/README are identical
XFiles server.old/SYSLOG and server/SYSLOG are identical
Xdiff -rcs server.old/access.c server/access.c
X*** server.old/access.c	Mon May  4 07:03:55 1992
X--- server/access.c	Sat Mar  7 11:46:00 1992
X***************
X*** 44,50 ****
X  
X  #ifdef AUTH
X  extern	int Needauth;
X! #endif AUTH
X  
X  host_access(canread, canpost, canxfer, gdlist)
X  	int		*canread, *canpost, *canxfer;
X--- 44,50 ----
X  
X  #ifdef AUTH
X  extern	int Needauth;
X! #endif /* AUTH */
X  
X  host_access(canread, canpost, canxfer, gdlist)
X  	int		*canread, *canpost, *canxfer;
X***************
X*** 230,236 ****
X  	/* do we require a userid and password for this guy? */
X  	if (isupper(readperm[0]) || isupper(postperm[0]))
X  		Needauth = 1;
X! #endif AUTH
X  }
X  
X  #ifdef DOMAINMATCH
X--- 230,236 ----
X  	/* do we require a userid and password for this guy? */
X  	if (isupper(readperm[0]) || isupper(postperm[0]))
X  		Needauth = 1;
X! #endif /* AUTH */
X  }
X  
X  #ifdef DOMAINMATCH
X***************
X*** 267,270 ****
X  
X  	return (0);
X  }
X! #endif DOMAINMATCH
X--- 267,270 ----
X  
X  	return (0);
X  }
X! #endif /* DOMAINMATCH */
XFiles server.old/access_dnet.c and server/access_dnet.c are identical
Xdiff -rcs server.old/access_inet.c server/access_inet.c
X*** server.old/access_inet.c	Mon May  4 07:03:55 1992
X--- server/access_inet.c	Sat Mar  7 11:46:00 1992
X***************
X*** 77,83 ****
X  	}
X  #else
X  	subnet_name[0] = '\0';
X! #endif SUBNET
X  
X  	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
X  		sizeof (sin->sin_addr.s_addr), AF_INET);
X--- 77,83 ----
X  	}
X  #else
X  	subnet_name[0] = '\0';
X! #endif /* SUBNET */
X  
X  	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
X  		sizeof (sin->sin_addr.s_addr), AF_INET);
XFiles server.old/active.c and server/active.c are identical
XFiles server.old/ahbs.c and server/ahbs.c are identical
Xdiff -rcs server.old/auth.c server/auth.c
X*** server.old/auth.c	Mon May  4 07:03:55 1992
X--- server/auth.c	Sat Mar  7 11:46:00 1992
X***************
X*** 149,152 ****
X  	Needauth = 0;
X  }
X  
X! #endif AUTH
X--- 149,152 ----
X  	Needauth = 0;
X  }
X  
X! #endif /* AUTH */
Xdiff -rcs server.old/batch.c server/batch.c
X*** server.old/batch.c	Mon May  4 07:03:55 1992
X--- server/batch.c	Sat Mar  7 11:46:00 1992
X***************
X*** 255,265 ****
X  #ifdef SYSLOG
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif LOG
X  #endif
X  	(void) unlink(tempfile);
X  	exit(1);
X! #endif XFER_TIMEOUT
X  }
X  
X  /*
X--- 255,265 ----
X  #ifdef SYSLOG
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif /* LOG */
X  #endif
X  	(void) unlink(tempfile);
X  	exit(1);
X! #endif /* XFER_TIMEOUT */
X  }
X  
X  /*
Xdiff -rcs server.old/common.h server/common.h
X*** server.old/common.h	Mon May  4 07:03:55 1992
X--- server/common.h	Sun Mar  8 11:26:19 1992
X***************
X*** 48,53 ****
X--- 48,56 ----
X  #endif
X  #else /* not NDIR */
X  # include <sys/dir.h>
X+ # ifdef ISC
X+ #  include <sys/dirent.h>
X+ # endif
X  #endif /* not NDIR */
X  
X  #ifdef FCNTL
X***************
X*** 157,162 ****
X--- 160,166 ----
X  extern	char	spooldir[];
X  extern	char	activefile[];
X  extern	char	distributionsfile[];
X+ extern	char	subscriptionsfile[];
X  extern	char	newsgroupsfile[];
X  extern	char	accessfile[];
X  extern	char	historyfile[];
XOnly in server: cscope.out
Xdiff -rcs server.old/fakesyslog.c server/fakesyslog.c
X*** server.old/fakesyslog.c	Mon May  4 07:03:55 1992
X--- server/fakesyslog.c	Sat Mar  7 11:46:00 1992
X***************
X*** 138,144 ****
X  	(void) strcpy(buf, ctime(&clock)+4);
X  	*(bp = buf + 16) = '\0';
X  
X! 	(void) sprintf(bp, "localhost %s", ident ? ident : "");
X  	bp += strlen(bp);
X  
X  	if (opt&LOG_PID) {
X--- 138,145 ----
X  	(void) strcpy(buf, ctime(&clock)+4);
X  	*(bp = buf + 16) = '\0';
X  
X! /*	(void) sprintf(bp, "localhost %s", ident ? ident : ""); */
X! 	(void) sprintf(bp, "local %s", ident ? ident : "");
X  	bp += strlen(bp);
X  
X  	if (opt&LOG_PID) {
Xdiff -rcs server.old/fakesyslog.h server/fakesyslog.h
X*** server.old/fakesyslog.h	Mon May  4 07:03:55 1992
X--- server/fakesyslog.h	Thu Feb 20 08:27:03 1992
X***************
X*** 62,65 ****
X  #define LOG_NDELAY	0
X  #define LOG_NOWAIT	0
X  
X! #endif FAKESYSLOG
X--- 62,65 ----
X  #define LOG_NDELAY	0
X  #define LOG_NOWAIT	0
X  
X! #endif /* FAKESYSLOG */
Xdiff -rcs server.old/globals.c server/globals.c
X*** server.old/globals.c	Mon May  4 07:03:56 1992
X--- server/globals.c	Sun Mar  8 11:25:47 1992
X***************
X*** 16,21 ****
X--- 16,22 ----
X  char	activefile[] = ACTIVE_FILE;
X  char	accessfile[] = ACCESS_FILE;
X  char	distributionsfile[] = DISTRIBUTIONS_FILE;
X+ char	subscriptionsfile[] = SUBSCRIPTIONS_FILE;
X  char	newsgroupsfile[] = NEWSGROUPS_FILE;
X  char	historyfile[] = HISTORY_FILE;
X  #ifdef ACTIVE_TIMES_FILE
X***************
X*** 54,60 ****
X  #ifdef AUTH
X  int	Needauth;	/* 1 if we need to do authorization */
X  char	User[10];	/* username for authentication */
X! #endif AUTH
X  
X  #ifdef LOG
X  int	arts_acsd;
X--- 55,61 ----
X  #ifdef AUTH
X  int	Needauth;	/* 1 if we need to do authorization */
X  char	User[10];	/* username for authentication */
X! #endif /* AUTH */
X  
X  #ifdef LOG
X  int	arts_acsd;
Xdiff -rcs server.old/group.c server/group.c
X*** server.old/group.c	Mon May  4 07:03:56 1992
X--- server/group.c	Sat Mar  7 11:46:00 1992
X***************
X*** 49,54 ****
X--- 49,55 ----
X  		return;
X  	}
X  
X+ 
X  	reqlist[0] = argv[1];
X  	reqlist[1] = NULL;
X  
X***************
X*** 70,79 ****
X  	close_crnt();
X  	(void) chdir(spooldir);
X  
X- #ifdef LOG
X- 	syslog(LOG_INFO, "%s group %s", hostname, argv[1]);
X- #endif
X- 
X  	while ((cp = index(argv[1], '.')) != (char *) NULL)
X  		*cp = '/';
X  
X--- 71,76 ----
X***************
X*** 96,101 ****
X--- 93,103 ----
X  	art_ptr = 0;
X  
X  	ingroup = 1;
X+ 	
X+ #ifdef LOG	
X+ 	syslog(LOG_INFO, "%s group=%s  high=%d  low=%d  arts=%d",
X+ 		 hostname, argv[1], high_msg, low_msg, num_arts);
X+ #endif
X  
X  	while ((cp = index(argv[1], '/')) != (char *) NULL)
X  		*cp = '.';
Xdiff -rcs server.old/help.c server/help.c
X*** server.old/help.c	Mon May  4 07:03:56 1992
X--- server/help.c	Tue Mar 10 08:55:29 1992
X***************
X*** 21,28 ****
X  	printf("NEXT        POST         QUIT\r\n");
X  	printf("STAT        NEWGROUPS    HELP\r\n");
X  	printf("IHAVE       NEWNEWS      SLAVE\r\n");
X! 	printf("\r\nAdditionally, the following extention is supported:\r\n\r\n");
X  	printf("XHDR        Retrieve a single header line from a range of articles.\r\n");
X  	printf("\r\n");
X  	printf("Bugs to Stan Barber (Internet: nntp@tmc.edu; UUCP: ...!bcm!nntp)\r\n");
X  	printf(".\r\n");
X--- 21,38 ----
X  	printf("NEXT        POST         QUIT\r\n");
X  	printf("STAT        NEWGROUPS    HELP\r\n");
X  	printf("IHAVE       NEWNEWS      SLAVE\r\n");
X! #if defined(XHDR) || defined(XUSER) || defined(XINDEX)
X! 	printf("\r\nAdditionally, the following extentions are supported:\r\n\r\n");
X! #  ifdef XHDR
X  	printf("XHDR        Retrieve a single header line from a range of articles.\r\n");
X+ #  endif
X+ #  ifdef XUSER	
X+ 	printf("XUSER       Log a clients username to nntp logfile.\r\n");
X+ #  endif	
X+ #  ifdef XINDEX
X+ 	printf("XINDEX      Retrieve a tin group index file.\r\n");
X+ #  endif	
X+ #endif	
X  	printf("\r\n");
X  	printf("Bugs to Stan Barber (Internet: nntp@tmc.edu; UUCP: ...!bcm!nntp)\r\n");
X  	printf(".\r\n");
Xdiff -rcs server.old/ihave.c server/ihave.c
X*** server.old/ihave.c	Mon May  4 07:03:56 1992
X--- server/ihave.c	Sat Mar  7 11:46:00 1992
X***************
X*** 8,14 ****
X  int	ih_accepted;
X  int	ih_rejected;
X  int	ih_failed;
X! #endif LOG
X  
X  /*
X   * IHAVE <messageid>
X--- 8,14 ----
X  int	ih_accepted;
X  int	ih_rejected;
X  int	ih_failed;
X! #endif /* LOG */
X  
X  /*
X   * IHAVE <messageid>
X***************
X*** 50,57 ****
X  		ih_rejected++;
X  #ifdef IHAVE_DEBUG
X  		syslog(LOG_DEBUG, "%s ihave %s rejected", hostname, argv[1]);
X! #endif IHAVE_DEBUG
X! #endif LOG
X  		return;
X  	}
X  
X--- 50,57 ----
X  		ih_rejected++;
X  #ifdef IHAVE_DEBUG
X  		syslog(LOG_DEBUG, "%s ihave %s rejected", hostname, argv[1]);
X! #endif /* IHAVE_DEBUG */
X! #endif /* LOG */
X  		return;
X  	}
X  
X***************
X*** 100,106 ****
X  #ifdef IHAVE_DEBUG
X  	syslog(LOG_DEBUG, "%s ihave %s accepted %s",
X  		hostname, argv[1], retcode == 1 ? "succeeded" : "failed");
X! #endif IHAVE_DEBUG
X! #endif LOG
X  
X  }
X--- 100,106 ----
X  #ifdef IHAVE_DEBUG
X  	syslog(LOG_DEBUG, "%s ihave %s accepted %s",
X  		hostname, argv[1], retcode == 1 ? "succeeded" : "failed");
X! #endif /* IHAVE_DEBUG */
X! #endif /* LOG */
X  
X  }
Xdiff -rcs server.old/list.c server/list.c
X*** server.old/list.c	Mon May  4 07:03:56 1992
X--- server/list.c	Sun Mar  8 11:24:24 1992
X***************
X*** 7,14 ****
X  /*
X   * LIST
X   *
X!  * List active newsgroups, newsgroup descriptions, and distributions.
X   *
X   */
X  
X  list(argc, argv)
X--- 7,17 ----
X  /*
X   * LIST
X   *
X!  * List active newsgroups, newsgroup descriptions, distributions
X!  * and subscriptions.
X   *
X+  *
X+  *
X   */
X  
X  list(argc, argv)
X***************
X*** 45,52 ****
X  		filename = newsgroupsfile;
X  		items = "newsgroup descriptions";
X  		format = "Descriptions in form \"group description\".";
X  	} else {
X! 		printf("%d Usage: LIST [ACTIVE|NEWSGROUPS|DISTRIBUTIONS]\r\n",
X  			ERR_CMDSYN);
X  		(void) fflush(stdout);
X  		return;
X--- 48,59 ----
X  		filename = newsgroupsfile;
X  		items = "newsgroup descriptions";
X  		format = "Descriptions in form \"group description\".";
X+ 	} else if (argc == 2 && !strcasecmp(argv[1],"subscriptions")){
X+ 		filename = subscriptionsfile;
X+ 		items = "automatic group subscriptions";
X+ 		format = "Subscriptions in form \"group\".";
X  	} else {
X! 		printf("%d Usage: LIST [ACTIVE|NEWSGROUPS|DISTRIBUTIONS|SUBSCRIPTIONS]\r\n",
X  			ERR_CMDSYN);
X  		(void) fflush(stdout);
X  		return;
XFiles server.old/main.c and server/main.c are identical
Xdiff -rcs server.old/misc.c server/misc.c
X*** server.old/misc.c	Mon May  4 07:03:56 1992
X--- server/misc.c	Sat Mar  7 11:46:00 1992
X***************
X*** 90,98 ****
X  # ifndef DBM
X  #  ifndef USGHIST
X  #   define USGHIST
X! #  endif not USGHIST
X! # endif not DBM
X! #endif not DBM
X  
X  char *
X  gethistent(msg_id, lookup)
X--- 90,98 ----
X  # ifndef DBM
X  #  ifndef USGHIST
X  #   define USGHIST
X! #  endif /* not USGHIST */
X! # endif /* not DBM */
X! #endif /* not DBM */
X  
X  char *
X  gethistent(msg_id, lookup)
X***************
X*** 107,121 ****
X  #ifdef USGHIST
X  	char		*histfile();
X  	register int	len;
X! #else not USGHIST
X  #ifdef DBM
X  	static int	dbopen = 0;
X  	datum		fetch();
X! #else not DBM
X  	static DBM	*db = NULL;	/* History file, dbm version */
X! #endif DBM
X! 	datum		 key, content;
X! #endif USGHIST
X  	static FILE	*hfp = NULL;	/* history file, text version */
X  
X  #ifdef CNEWS
X--- 107,121 ----
X  #ifdef USGHIST
X  	char		*histfile();
X  	register int	len;
X! #else /* not USGHIST */
X  #ifdef DBM
X  	static int	dbopen = 0;
X  	datum		fetch();
X! #else /* not DBM */
X  	static DBM	*db = NULL;	/* History file, dbm version */
X! #endif /* DBM */
X!  	datum		 key, content;
X! #endif /* USGHIST */
X  	static FILE	*hfp = NULL;	/* history file, text version */
X  
X  #ifdef CNEWS
X***************
X*** 140,146 ****
X  	if (hfp == NULL) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "gethistent: histfile: %m");
X! #endif SYSLOG
X  		return (NULL);
X  	}
X  
X--- 140,146 ----
X  	if (hfp == NULL) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "gethistent: histfile: %m");
X! #endif /* SYSLOG */
X  		return (NULL);
X  	}
X  
X***************
X*** 153,159 ****
X  		(void) fclose(hfp);
X  		return (NULL);
X  	}
X! #else not USGHIST
X  #ifdef DBM
X  	if (!dbopen) {
X  		if (dbminit(historyfile) < 0) {
X--- 153,159 ----
X  		(void) fclose(hfp);
X  		return (NULL);
X  	}
X! #else /* not USGHIST */
X  #ifdef DBM
X  	if (!dbopen) {
X  		if (dbminit(historyfile) < 0) {
X***************
X*** 160,166 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbminit %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		} else
X  			dbopen = 1;
X--- 160,166 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbminit %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		} else
X  			dbopen = 1;
X***************
X*** 172,182 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbm_open %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		}
X  	}
X! #endif DBM
X  
X  	key.dptr = msg_id;
X  	key.dsize = strlen(msg_id) + 1;
X--- 172,182 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbm_open %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		}
X  	}
X! #endif /* DBM */
X  
X  	key.dptr = msg_id;
X  	key.dsize = strlen(msg_id) + 1;
X***************
X*** 185,191 ****
X  	content = fetch(key);
X  #else	/* ndbm */
X  	content = dbm_fetch(db, key);
X! #endif DBM
X  	if (content.dptr == NULL)
X  		return (NULL);
X  
X--- 185,191 ----
X  	content = fetch(key);
X  #else	/* ndbm */
X  	content = dbm_fetch(db, key);
X! #endif /* DBM */
X  	if (content.dptr == NULL)
X  		return (NULL);
X  
X***************
X*** 202,208 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "message: fopen %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		}
X  	} else {
X--- 202,208 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "message: fopen %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		}
X  	} else {
X***************
X*** 215,226 ****
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "message: %s: fseek to %ld on %d: %m", 
X  		       historyfile, ltmp, hfp);
X! #endif SYSLOG
X  		return (NULL);
X  	}
X  
X  	(void) fgets(line, sizeof(line), hfp);
X! #endif USGHIST
X  
X  	if ((cp = index(line, '\n')) != NULL)
X  		*cp = '\0';
X--- 215,226 ----
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "message: %s: fseek to %ld on %d: %m", 
X  		       historyfile, ltmp, hfp);
X! #endif /* SYSLOG */
X  		return (NULL);
X  	}
X  
X  	(void) fgets(line, sizeof(line), hfp);
X! #endif /* USGHIST */
X  
X  	if ((cp = index(line, '\n')) != NULL)
X  		*cp = '\0';
X***************
X*** 232,238 ****
X  	    syslog(LOG_ERR,
X  		"message: malformed line in history file at %ld bytes, id %s",
X  			ltmp, msg_id);
X! #endif SYSLOG
X  	if (cp == NULL) return(NULL); /* this article has expired */
X  	tmp = cp+1;
X  
X--- 232,238 ----
X  	    syslog(LOG_ERR,
X  		"message: malformed line in history file at %ld bytes, id %s",
X  			ltmp, msg_id);
X! #endif /* SYSLOG */
X  	if (cp == NULL) return(NULL); /* this article has expired */
X  	tmp = cp+1;
X  
X***************
X*** 613,619 ****
X  		chr = '0';
X  	return chr;
X  }
X! #endif USGHIST
X  #ifdef USG
X  #ifndef GAZETTE
X  bcopy(s, d, l)
X--- 613,619 ----
X  		chr = '0';
X  	return chr;
X  }
X! #endif /* USGHIST */
X  #ifdef USG
X  #ifndef GAZETTE
X  bcopy(s, d, l)
X***************
X*** 775,781 ****
X  #define blkavail(fs)	((fs).f_tfree)
X  				/* USG doesn't reserve blocks for root */
X  #define filfree(fs)	((fs).f_tinode)	
X! #endif USG
X  
X  #ifdef CMU_MACH
X  /* This code supplied by Tom Lane <tgl@cs.cmu.edu> */
X--- 775,781 ----
X  #define blkavail(fs)	((fs).f_tfree)
X  				/* USG doesn't reserve blocks for root */
X  #define filfree(fs)	((fs).f_tinode)	
X! #endif /* USG */
X  
X  #ifdef CMU_MACH
X  /* This code supplied by Tom Lane <tgl@cs.cmu.edu> */
X***************
X*** 799,805 ****
X  #define bombed(call)	((call) < 0)
X  #define blkfree(fs)	((fs).fsp_free-((fs).fsp_size*(fs).fsp_minfree+99)/100)
X  #define blkavail(fs)	(-1)
X! #endif MACH
X  
X  dfree(spool,free_space)
X  char *spool;
X--- 799,805 ----
X  #define bombed(call)	((call) < 0)
X  #define blkfree(fs)	((fs).fsp_free-((fs).fsp_size*(fs).fsp_minfree+99)/100)
X  #define blkavail(fs)	(-1)
X! #endif /* MACH */
X  
X  dfree(spool,free_space)
X  char *spool;
X***************
X*** 825,831 ****
X      return( DFREE_OK );
X  }
X  
X! #else READ_SUPER
X  /*
X   * This code is used if you've got to directly read the superblock
X   * to determine how much space you've got left.  It's copied from
X--- 825,831 ----
X      return( DFREE_OK );
X  }
X  
X! #else /* READ_SUPER */
X  /*
X   * This code is used if you've got to directly read the superblock
X   * to determine how much space you've got left.  It's copied from
X***************
X*** 919,925 ****
X     return( DFREE_OK );
X  }
X  
X! #endif READ_SUPER
X  
X  #ifdef LOAD
X  /*
X--- 919,925 ----
X     return( DFREE_OK );
X  }
X  
X! #endif /* READ_SUPER */
X  
X  #ifdef LOAD
X  /*
X***************
X*** 987,990 ****
X  # endif
X  }
X  #endif
X! #endif LOAD
X--- 987,990 ----
X  # endif
X  }
X  #endif
X! #endif /* LOAD */
Xdiff -rcs server.old/netaux.c server/netaux.c
X*** server.old/netaux.c	Mon May  4 07:03:56 1992
X--- server/netaux.c	Sat Mar  7 11:46:00 1992
X***************
X*** 12,25 ****
X  #include <netinet/in.h>
X  #ifndef EXCELAN
X  #include <netdb.h>
X! #endif not EXCELAN
X  #include <sys/ioctl.h>
X  #include <signal.h>
X  #ifdef USG
X  #include <time.h>
X! #else not USG
X  #include <sys/time.h>
X! #endif USG
X  
X  #ifdef ALONE
X  
X--- 12,25 ----
X  #include <netinet/in.h>
X  #ifndef EXCELAN
X  #include <netdb.h>
X! #endif /* not EXCELAN */
X  #include <sys/ioctl.h>
X  #include <signal.h>
X  #ifdef USG
X  #include <time.h>
X! #else /* not USG */
X  #include <sys/time.h>
X! #endif /* USG */
X  
X  #ifdef ALONE
X  
X***************
X*** 211,217 ****
X  	if (setitimer(ITIMER_REAL, &new, &old) < 0) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "set_timer: setitimer: %m\n");
X! #endif SYSLOG
X  		exit(1);
X  	}
X  #endif /* not USG */
X--- 211,217 ----
X  	if (setitimer(ITIMER_REAL, &new, &old) < 0) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "set_timer: setitimer: %m\n");
X! #endif /* SYSLOG */
X  		exit(1);
X  	}
X  #endif /* not USG */
XFiles server.old/newgroups.c and server/newgroups.c are identical
Xdiff -rcs server.old/newnews.c server/newnews.c
X*** server.old/newnews.c	Mon May  4 07:03:57 1992
X--- server/newnews.c	Sat Mar  7 11:49:07 1992
X***************
X*** 39,45 ****
X  	FILE		*tmplst;
X  	int		i;
X  	char		*tmpfile;
X! #endif USGHIST
X  
X  	if (argc < 4) {
X  		printf("%d Usage: NEWNEWS newsgroups yymmdd hhmmss [\"GMT\"] [<distributions>].\r\n",
X--- 39,45 ----
X  	FILE		*tmplst;
X  	int		i;
X  	char		*tmpfile;
X! #endif /* USGHIST */
X  
X  	if (argc < 4) {
X  		printf("%d Usage: NEWNEWS newsgroups yymmdd hhmmss [\"GMT\"] [<distributions>].\r\n",
X***************
X*** 131,137 ****
X  
X      for (i = 0; i < 9; i++) {
X  		sprintf(historyfile, "%s.d/%d", HISTORY_FILE, i);
X! #endif USGHIST
X  
X  	fp = fopen(historyfile, "r");
X  	if (fp == NULL) {
X--- 131,137 ----
X  
X      for (i = 0; i < 9; i++) {
X  		sprintf(historyfile, "%s.d/%d", HISTORY_FILE, i);
X! #endif /* USGHIST */
X  
X  	fp = fopen(historyfile, "r");
X  	if (fp == NULL) {
X***************
X*** 142,167 ****
X  		printf("%d Cannot open history file.\r\n", ERR_FAULT);
X  		(void) fflush(stdout);
X  		return;
X! #else USGHIST
X  		continue;
X! #endif USGHIST
X  	}
X  
X  #ifndef USGHIST
X  	printf("%d New news by message id follows\r\n", OK_NEWNEWS);
X! #endif not USGHIST
X  
X  	if (seekuntil(fp, key, line, sizeof (line)) < 0) {
X  #ifndef USGHIST
X  		printf(".\r\n");
X  		(void) fflush(stdout);
X! #endif not USGHIST
X  		(void) fclose(fp);
X  #ifndef USGHIST
X  		return;
X! #else USGHIST
X  		continue;
X! #endif USGHIST
X  	}
X  
X  /*
X--- 142,167 ----
X  		printf("%d Cannot open history file.\r\n", ERR_FAULT);
X  		(void) fflush(stdout);
X  		return;
X! #else /* USGHIST */
X  		continue;
X! #endif /* USGHIST */
X  	}
X  
X  #ifndef USGHIST
X  	printf("%d New news by message id follows\r\n", OK_NEWNEWS);
X! #endif /* not USGHIST */
X  
X  	if (seekuntil(fp, key, line, sizeof (line)) < 0) {
X  #ifndef USGHIST
X  		printf(".\r\n");
X  		(void) fflush(stdout);
X! #endif /* not USGHIST */
X  		(void) fclose(fp);
X  #ifndef USGHIST
X  		return;
X! #else /* USGHIST */
X  		continue;
X! #endif /* USGHIST */
X  	}
X  
X  /*
X***************
X*** 208,216 ****
X  #ifdef USGHIST
X  		fputs(line, tmplst);
X  		fputc('\n', tmplst);
X! #else not USGHIST
X  		putline(line);
X! #endif not USGHIST
X  #ifdef LOG
X  		nn_told++;
X  #endif
X--- 208,216 ----
X  #ifdef USGHIST
X  		fputs(line, tmplst);
X  		fputc('\n', tmplst);
X! #else /* not USGHIST */
X  		putline(line);
X! #endif /* not USGHIST */
X  #ifdef LOG
X  		nn_told++;
X  #endif
X***************
X*** 235,241 ****
X      (void) fflush(stdout);
X      (void) fclose(tmplst);
X      (void) unlink(tmpfile);
X! #endif USGHIST
X  }
X  
X  
X--- 235,241 ----
X      (void) fflush(stdout);
X      (void) fclose(tmplst);
X      (void) unlink(tmpfile);
X! #endif /* USGHIST */
X  }
X  
X  
XFiles server.old/nextlast.c and server/nextlast.c are identical
XFiles server.old/ngmatch.c and server/ngmatch.c are identical
XFiles server.old/parsit.c and server/parsit.c are identical
XFiles server.old/post.c and server/post.c are identical
XFiles server.old/profile.c and server/profile.c are identical
Xdiff -rcs server.old/scandir.c server/scandir.c
X*** server.old/scandir.c	Mon May  4 07:03:57 1992
X--- server/scandir.c	Sat Mar  7 11:46:00 1992
X***************
X*** 4,9 ****
X--- 4,13 ----
X  
X  #include "common.h"
X  
X+ #ifdef ISC
X+ #	include <dirent.h>
X+ #endif
X+ 
X  /*
X   * scan_dir -- scan the current directory for news articles,
X   *	loading the article numbers into art_array.  Return
X***************
X*** 26,32 ****
X--- 30,40 ----
X  scan_dir(low_msg, high_msg)
X  int	low_msg, high_msg;
X  {
X+ #ifdef ISC
X+ 	register struct dirent	*dirent;
X+ #else
X  	register struct direct	*dirent;
X+ #endif
X  	register DIR		*dirp;
X  	int			artnum;
X  
X***************
X*** 34,43 ****
X  
X  	dirp = opendir(".");
X  
X! 	if (dirp == NULL)
X  		return (0);
X  
X  	while ((dirent = readdir(dirp)) != NULL) {
X  		artnum = atoi(dirent->d_name);
X  #ifdef DYNAMIC_ART_ARRAY
X  		if (artnum == 0 || artnum < low_msg || artnum > high_msg)
X--- 42,73 ----
X  
X  	dirp = opendir(".");
X  
X! 	if (dirp == NULL) {
X! #ifdef LOG
X! 		syslog(LOG_ERR, "scan_dir(): opendir() failed. Returning num_arts=0");
X! #endif
X  		return (0);
X+ 	}
X  
X  	while ((dirent = readdir(dirp)) != NULL) {
X+ 
X+ #ifdef LOG
X+ /*
X+ {
X+ 		char pwd[256];
X+ 	
X+ 		getcwd (pwd, 255);
X+ #ifdef ISC
X+ 		syslog(LOG_INFO, "%s: d->d_name=%s  d->d_ino=%d  d->d_reclen=%d",
X+ 			pwd, dirent->d_name, dirent->d_ino, dirent->d_reclen);
X+ #else		
X+ 		syslog(LOG_INFO, "%s: d->d_name=%s  d->d_ino=%d",
X+ 			pwd, dirent->d_name, dirent->d_ino);
X+ #endif
X+ }
X+ */			
X+ #endif
X+ 	
X  		artnum = atoi(dirent->d_name);
X  #ifdef DYNAMIC_ART_ARRAY
X  		if (artnum == 0 || artnum < low_msg || artnum > high_msg)
X***************
X*** 70,75 ****
X--- 100,110 ----
X  		}
X  		art_array[num_arts] = artnum;
X   		++num_arts;
X+ 
X+ #ifdef LOG
X+ 		syslog(LOG_INFO, "scan_dir(): artnum=%d  num_arts=%d", artnum, num_arts);
X+ #endif
X+ 
X  #else
X  		if (artnum != 0 && artnum >= low_msg && artnum <= high_msg)
X  			art_array[num_arts++] = artnum;
Xdiff -rcs server.old/serve.c server/serve.c
X*** server.old/serve.c	Mon May  4 07:03:57 1992
X--- server/serve.c	Tue Mar 10 09:32:32 1992
X***************
X*** 17,23 ****
X  #ifdef LOG
X  # ifndef USG
X  #  include <sys/resource.h>
X! # endif not USG
X  #endif
X  
X  #ifdef TIMERS
X--- 17,23 ----
X  #ifdef LOG
X  # ifndef USG
X  #  include <sys/resource.h>
X! # endif /* not USG */
X  #endif
X  
X  #ifdef TIMERS
X***************
X*** 27,38 ****
X  extern	int	ahbs(), group(), help(), ihave();
X  extern	int	list(), newgroups(), newnews(), nextlast(), post();
X  extern	int	slave(), stat(), xhdr();
X  
X  extern int errno;
X  
X  #ifdef AUTH
X  extern	int	doauth();
X! #endif AUTH
X  
X  static struct cmdent {
X  	char	*cmd_name;
X--- 27,44 ----
X  extern	int	ahbs(), group(), help(), ihave();
X  extern	int	list(), newgroups(), newnews(), nextlast(), post();
X  extern	int	slave(), stat(), xhdr();
X+ #ifdef XUSER
X+ extern	int	xuser();
X+ #endif
X+ #ifdef XINDEX
X+ extern	int	xindex();
X+ #endif
X  
X  extern int errno;
X  
X  #ifdef AUTH
X  extern	int	doauth();
X! #endif /* AUTH */
X  
X  static struct cmdent {
X  	char	*cmd_name;
X***************
X*** 43,49 ****
X  	"authcap",	0,	doauth,
X  	"authinfo",	0,	doauth,
X  	"authsys",	0,	doauth,
X! #endif AUTH
X  	"article",	0,	ahbs,
X  	"body",		0,	ahbs,
X  	"group",	0,	group,
X--- 49,55 ----
X  	"authcap",	0,	doauth,
X  	"authinfo",	0,	doauth,
X  	"authsys",	0,	doauth,
X! #endif /* AUTH */
X  	"article",	0,	ahbs,
X  	"body",		0,	ahbs,
X  	"group",	0,	group,
X***************
X*** 60,66 ****
X  	"stat",		0,	ahbs,
X  #ifdef XHDR
X  	"xhdr",		0,	xhdr,
X! #endif XHDR
X  };
X  #define NUMCMDS (sizeof(cmdtbl) / sizeof(struct cmdent))
X  
X--- 66,78 ----
X  	"stat",		0,	ahbs,
X  #ifdef XHDR
X  	"xhdr",		0,	xhdr,
X! #endif /* XHDR */
X! #ifdef XUSER
X! 	"xuser",	0,	xuser,
X! #endif /* XUSER */
X! #ifdef XINDEX
X! 	"xindex",	0,	xindex,
X! #endif /* XINDEX */
X  };
X  #define NUMCMDS (sizeof(cmdtbl) / sizeof(struct cmdent))
X  
X***************
X*** 98,104 ****
X  #ifdef AUTH
X  extern int	Needauth;
X  extern char	User[];
X! #endif AUTH
X  
X  /*
X   * serve -- given a connection on stdin/stdout, serve
X--- 110,116 ----
X  #ifdef AUTH
X  extern int	Needauth;
X  extern char	User[];
X! #endif /* AUTH */
X  
X  /*
X   * serve -- given a connection on stdin/stdout, serve
X***************
X*** 152,158 ****
X  #ifdef ALONE
X  #ifndef USG
X  	(void) signal(SIGCHLD, SIG_IGN);
X! #endif not USG
X  #endif
X  
X  	/* Ignore SIGPIPE, since we'll see closed connections with read */
X--- 164,170 ----
X  #ifdef ALONE
X  #ifndef USG
X  	(void) signal(SIGCHLD, SIG_IGN);
X! #endif /* not USG */
X  #endif
X  
X  	/* Ignore SIGPIPE, since we'll see closed connections with read */
X***************
X*** 163,169 ****
X  #ifdef AUTH
X  	Needauth = 1;
X  	strcpy(User,"");
X! #endif AUTH
X  	host_access(&canread, &canpost, &canxfer, gdbuf);
X  
X  	if (gethostname(host, sizeof(host)) < 0)
X--- 175,181 ----
X  #ifdef AUTH
X  	Needauth = 1;
X  	strcpy(User,"");
X! #endif /* AUTH */
X  	host_access(&canread, &canpost, &canxfer, gdbuf);
X  
X  	if (gethostname(host, sizeof(host)) < 0)
X***************
X*** 302,308 ****
X  				(void) fflush(stdout);
X  				continue;
X  				}
X! #endif AUTH
X  			(*cmdtbl[i].cmd_fctn)(argnum, argp);
X  		} else {
X  #ifdef SYSLOG
X--- 314,320 ----
X  				(void) fflush(stdout);
X  				continue;
X  				}
X! #endif /* AUTH */
X  			(*cmdtbl[i].cmd_fctn)(argnum, argp);
X  		} else {
X  #ifdef SYSLOG
X***************
X*** 490,493 ****
X  		user, sys, Tfinish - Tstart);
X  	syslog(LOG_INFO, "%s times %s", hostname, buf);
X  }
X! #endif LOG
X--- 502,505 ----
X  		user, sys, Tfinish - Tstart);
X  	syslog(LOG_INFO, "%s times %s", hostname, buf);
X  }
X! #endif /* LOG */
XFiles server.old/slave.c and server/slave.c are identical
Xdiff -rcs server.old/spawn.c server/spawn.c
X*** server.old/spawn.c	Mon May  4 07:03:58 1992
X--- server/spawn.c	Sat Mar  7 11:46:00 1992
X***************
X*** 65,73 ****
X  #endif
X  #ifdef USG
X  	int		status;
X! #else not USG
X  	union wait	status;
X! #endif not USG
X  	register FILE	*fp;
X  
X  #ifdef CNEWS
X--- 65,73 ----
X  #endif
X  #ifdef USG
X  	int		status;
X! #else /* not USG */
X  	union wait	status;
X! #endif /* not USG */
X  	register FILE	*fp;
X  
X  #ifdef CNEWS
X***************
X*** 91,97 ****
X  	*/
X  	if (cont_code == CONT_POST)
X  		fprintf(fp, "Nntp-Posting-Host: %s\n", hostname);
X! #endif AUTH
X  
X  	printf("%d Ok\r\n", cont_code);
X  	(void) fflush(stdout);
X--- 91,97 ----
X  	*/
X  	if (cont_code == CONT_POST)
X  		fprintf(fp, "Nntp-Posting-Host: %s\n", hostname);
X! #endif /* AUTH */
X  
X  	printf("%d Ok\r\n", cont_code);
X  	(void) fflush(stdout);
X***************
X*** 332,338 ****
X  
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif LOG
X  
X  	(void) unlink(tempfile);
X  
X--- 332,338 ----
X  
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif /* LOG */
X  
X  	(void) unlink(tempfile);
X  
X***************
X*** 339,343 ****
X  	exit(1);
X  }
X  
X! #endif XFER_TIMEOUT
X  
X--- 339,343 ----
X  	exit(1);
X  }
X  
X! #endif /* XFER_TIMEOUT */
X  
XFiles server.old/strcasecmp.c and server/strcasecmp.c are identical
Xdiff -rcs server.old/subnet.c server/subnet.c
X*** server.old/subnet.c	Mon May  4 07:03:58 1992
X--- server/subnet.c	Sat Mar  7 11:46:00 1992
X***************
X*** 1,5 ****
X  #ifndef lint
X! static	char	*sccsid = "@(#)$Header: subnet.c,v 1.8 90/12/12 02:21:38 sob Exp $";
X  #endif
X  
X  #include "../common/conf.h"
X--- 1,5 ----
X  #ifndef lint
X! static	char	*sccsid = "@(#)$Header: subnet.c,v 1.9 91/03/19 03:02:30 sob Exp $";
X  #endif
X  
X  #include "../common/conf.h"
X***************
X*** 7,19 ****
X  #ifdef SUBNET
X  
X  #include <sys/types.h>
X  #include <sys/socket.h>
X  #include <netinet/in.h>
X  #ifndef NETMASK
X  #include <net/if.h>
X  #endif
X  #include <sys/ioctl.h>
X! 
X  /*
X   * The following routines provide a general interface for
X   * subnet support.  Like the library function "inet_netof",
X--- 7,26 ----
X  #ifdef SUBNET
X  
X  #include <sys/types.h>
X+ #ifdef LAI_TCP
X+ #include <sys/bsdtypes.h>
X+ #include <sys/stream.h>
X+ #endif
X  #include <sys/socket.h>
X  #include <netinet/in.h>
X  #ifndef NETMASK
X  #include <net/if.h>
X  #endif
X+ #ifdef LAI_TCP
X+ #include <sys/sioctl.h>
X+ #else
X  #include <sys/ioctl.h>
X! #endif
X  /*
X   * The following routines provide a general interface for
X   * subnet support.  Like the library function "inet_netof",
Xdiff -rcs server.old/time.c server/time.c
X*** server.old/time.c	Mon May  4 07:03:58 1992
X--- server/time.c	Sat Mar  7 11:46:00 1992
X***************
X*** 10,18 ****
X  #include "common.h"
X  #ifdef USG
X  #include <time.h>
X! #else not USG
X  #include <sys/time.h>
X! #endif not USG
X  
X  /*
X   * dtol -- convert date to long integer.  This is not implicitly
X--- 10,18 ----
X  #include "common.h"
X  #ifdef USG
X  #include <time.h>
X! #else /* not USG */
X  #include <sys/time.h>
X! #endif /* not USG */
X  
X  /*
X   * dtol -- convert date to long integer.  This is not implicitly
XFiles server.old/time.h and server/time.h are identical
Xdiff -rcs server.old/timer.c server/timer.c
X*** server.old/timer.c	Mon May  4 07:03:58 1992
X--- server/timer.c	Sat Mar  7 11:46:00 1992
X***************
X*** 6,17 ****
X  #ifdef TIMERS
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.2 90/12/27 22:16:27 sob Exp $ (NNTP with TIMERS)";
X  #endif
X  #else
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.2 90/12/27 22:16:27 sob Exp $ (NNTP without TIMERS)";
X  #endif
X  #endif
X  
X--- 6,17 ----
X  #ifdef TIMERS
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.3 91/03/19 03:02:41 sob Exp $ (NNTP with TIMERS)";
X  #endif
X  #else
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.3 91/03/19 03:02:41 sob Exp $ (NNTP without TIMERS)";
X  #endif
X  #endif
X  
X***************
X*** 18,24 ****
X  #ifdef TIMERS
X  #include <sys/time.h>
X  #include "timer.h"
X! #ifndef USG
X  #ifndef FD_SETSIZE
X  /* Forward compatability */
X  #define FD_SET(n, p)    ((p)->fds_bits[0] |= (1<<(n)))
X--- 18,29 ----
X  #ifdef TIMERS
X  #include <sys/time.h>
X  #include "timer.h"
X! #ifdef USG
X! #ifdef LAI_TCP
X! #include <sys/bsdtypes.h>
X! #define BSDSELECT
X! #endif
X! #else
X  #ifndef FD_SETSIZE
X  /* Forward compatability */
X  #define FD_SET(n, p)    ((p)->fds_bits[0] |= (1<<(n)))
X***************
X*** 25,30 ****
X--- 30,36 ----
X  #define FD_CLR(n, p)    ((p)->fds_bits[0] &= ~(1<<(n)))
X  #define FD_ISSET(n, p)  ((p)->fds_bits[0] & (1<<(n)))
X  #define FD_ZERO(p)      ((p)->fds_bits[0] = 0)
X+ #define BSDSELECT
X  #endif
X  #endif
X  /* non-portable */
X***************
X*** 69,75 ****
X  	register int i, n;
X  	register struct timer *tp;
X  	register long secs;
X! #ifdef USG
X  	long timeout;
X  	long readfds;
X  #else
X--- 75,81 ----
X  	register int i, n;
X  	register struct timer *tp;
X  	register long secs;
X! #ifndef BSDSELECT
X  	long timeout;
X  	long readfds;
X  #else
X***************
X*** 83,89 ****
X  		return(1);
X  
X  	/* Length of next timeout is minimum of all "timers" */
X! #ifdef USG
X  	timeout = -1;
X  	for (i = ntimer, tp = timers; i > 0; --i, ++tp)
X  		if (tp->left >= 0 &&
X--- 89,95 ----
X  		return(1);
X  
X  	/* Length of next timeout is minimum of all "timers" */
X! #ifndef BSDSELECT
X  	timeout = -1;
X  	for (i = ntimer, tp = timers; i > 0; --i, ++tp)
X  		if (tp->left >= 0 &&
X***************
X*** 114,122 ****
X  	/* Do select */
X  	FD_ZERO(&readfds);
X  	FD_SET(fileno(stdin), &readfds);
X! #endif /* !USG */
X  	errno = 0;
X! #ifdef EXCELAN
X  	n = select(fileno(stdin) + 1, &readfds, (long*)0, timeout);
X  #else
X  	n = select(fileno(stdin) + 1,
X--- 120,128 ----
X  	/* Do select */
X  	FD_ZERO(&readfds);
X  	FD_SET(fileno(stdin), &readfds);
X! #endif /* BSDSELECT */
X  	errno = 0;
X! #if defined(EXCELAN) || defined(ULTRIX)
X  	n = select(fileno(stdin) + 1, &readfds, (long*)0, timeout);
X  #else
X  	n = select(fileno(stdin) + 1,
XFiles server.old/timer.h and server/timer.h are identical
Xdiff -rcs server.old/xhdr.c server/xhdr.c
X*** server.old/xhdr.c	Mon May  4 07:03:58 1992
X--- server/xhdr.c	Sat Mar  7 11:46:00 1992
X***************
X*** 158,164 ****
X  	}
X  }
X  
X! #else not XHDR
X  
X  /* Kludge to get around Greenhills C compiler */
X  
X--- 158,164 ----
X  	}
X  }
X  
X! #else /* not XHDR */
X  
X  /* Kludge to get around Greenhills C compiler */
X  
X***************
X*** 166,169 ****
X  {
X  }
X  
X! #endif not XHDR
X--- 166,169 ----
X  {
X  }
X  
X! #endif /* not XHDR */
XOnly in server: xindex.c
XOnly in server: xuser.c
END_OF_FILE
  if test 34102 -ne `wc -c <'server.patch'`; then
    echo shar: \"'server.patch'\" unpacked with wrong size!
  fi
  # end of 'server.patch'
fi
if test -f 'thread.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'thread.c'\"
else
  echo shar: Extracting \"'thread.c'\" \(17796 characters\)
  sed "s/^X//" >'thread.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : thread.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 11-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern int index_point;
Xint threaded_on_subject;
Xstatic int top_thread = 0;
Xstatic int thread_index_point = 0;
Xstatic int thread_basenote = 0;
Xstatic int thread_respnum = 0;
Xstatic int first_thread_on_screen = 0;
Xstatic int last_thread_on_screen = 0;
X
X
X/*
X * show current thread. If threaded on Subject: show
X *   <respnum> <name>    <respnum> <name>
X * If threaded on Archive-name: show
X *   <respnum> <subject> <name>
X */
X 
Xint show_thread (respnum, group, group_path)
X	int respnum;
X	char *group;
X	char *group_path;
X{
X	int ret_code = TRUE;
X#ifndef INDEX_DAEMON
X	int ch;
X	int i, index, n;
X	int scroll_lines;
X
X	thread_respnum = respnum;
X	thread_basenote = which_thread (thread_respnum);
X	top_thread = num_of_responses (thread_basenote) + 1;
X
X	if (top_thread <= 0) {
X		info_message (txt_no_resps_in_thread);
X		return FALSE;
X	}
X
X	if (arts[thread_respnum].archive != (char *) 0) {
X		threaded_on_subject = FALSE;
X	} else {
X		threaded_on_subject = TRUE;
X	}
X
X	thread_index_point = top_thread;
X	if (space_mode) {
X		if (i = new_responses (thread_basenote)) {
X			for (n=0, i = base[thread_basenote]; i >= 0 ;
X				 i = arts[i].thread, n++) {
X				if (arts[i].unread == ART_UNREAD) {
X					thread_index_point = n;
X					break;
X				}
X			}
X		}
X	}
X
X	if (thread_index_point < 0) {
X		thread_index_point = 0;
X	}
X
X	show_thread_page ();
X
X	while (TRUE) {
X		ch = (char) ReadCh();
X
X		if (ch >= '0' && ch <= '9') {	/* 0 goes to basenote */
X			prompt_thread_num (ch);
X		} else switch (ch) {
X			case ESC:	/* common arrow keys */
X				switch (get_arrow_key ()) {
X					case KEYMAP_UP:
X						goto thread_up;
X
X					case KEYMAP_DOWN:
X						goto thread_down;
X
X					case KEYMAP_PAGE_UP:
X						goto thread_page_up;
X
X					case KEYMAP_PAGE_DOWN:
X						goto thread_page_down;
X
X					case KEYMAP_HOME:
X						if (thread_index_point != 0) {
X							if (0 < first_thread_on_screen) {
X#ifndef USE_CLEARSCREEN
X								erase_thread_arrow ();
X#endif
X								thread_index_point = 0;
X								show_thread_page ();
X							} else {
X								erase_thread_arrow ();
X								thread_index_point = 0;
X								draw_thread_arrow ();
X							}
X						}
X						break;
X					
X					case KEYMAP_END:
X						goto end_of_thread;
X				}
X				break;
X
X			case '$':	/* show last page of threads */
Xend_of_thread:			
X				if (thread_index_point < top_thread - 1) {
X					if (top_thread > last_thread_on_screen) {
X#ifndef USE_CLEARSCREEN
X						erase_thread_arrow ();
X#endif					
X						thread_index_point = top_thread - 1;
X						show_thread_page ();
X					} else {
X						erase_thread_arrow ();
X						thread_index_point = top_thread - 1;
X						draw_thread_arrow ();
X					}
X				}
X				break;
X				
X			case '\r':
X			case '\n':	/* read current article within thread */
X				n = choose_response (thread_basenote, thread_index_point);
X				n = show_page (n, &thread_index_point, group, group_path);
X				if (n == thread_basenote) {
X					show_thread_page ();
X				} else {
X					index_point = n;	
X					goto thread_done;
X				}
X				break;
X
X			case '\t':
X 				space_mode = TRUE;
X				if (thread_index_point == 0) {
X					n = thread_respnum;
X				} else {
X					n = choose_response (thread_basenote, thread_index_point);
X				}
X				index = thread_index_point;
X				for (i = n ; i != -1 ; i = arts[i].thread) {
X					if (arts[i].unread == ART_UNREAD) {
X						n = show_page (i, &thread_index_point, group, group_path);
X						break;
X					}
X					index++;
X				}
X				if (n == thread_basenote) {
X					show_thread_page ();
X				} else {
X					index_point = n;	
X					goto thread_done;
X				}
X				break;
X	
X			case ' ':		/* page down */
X			case ctrl('D'):		/* vi style */
X			case ctrl('V'):		/* emacs style */
Xthread_page_down:
X				if (thread_index_point + 1 == top_thread) {
X#ifdef NO_LOOP_AROUND
X					break;
X#else
X					if (0 < first_thread_on_screen) {
X#	ifndef USE_CLEARSCREEN
X						erase_thread_arrow ();
X#	endif					
X						thread_index_point = 0;
X						show_thread_page ();
X					} else {
X						erase_thread_arrow ();
X						thread_index_point = 0;
X						draw_thread_arrow ();
X					}
X					break;
X#endif					
X				}
X				erase_thread_arrow ();
X				scroll_lines = (full_page_scroll ? NOTESLINES : NOTESLINES / 2);
X				thread_index_point = ((thread_index_point + scroll_lines) /
X							scroll_lines) * scroll_lines;
X				if (thread_index_point >= top_thread) {
X					thread_index_point = (top_thread / scroll_lines) * scroll_lines;
X					if (thread_index_point < top_thread - 1) {
X						thread_index_point = top_thread - 1;
X					}
X				}
X				if (thread_index_point < first_thread_on_screen ||
X					thread_index_point >= last_thread_on_screen) {
X					show_thread_page ();
X				} else {
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('L'):		/* redraw screen */
X			case ctrl('R'):
X			case ctrl('W'):
X#ifndef USE_CLEARSCREEN
X				ClearScreen ();
X#endif
X				show_thread_page ();
X				break;
X
X			case ctrl('N'):
X			case 'j':		/* line down */
Xthread_down:
X				if (thread_index_point + 1 >= top_thread) {
X#ifdef NO_LOOP_AROUND
X					break;
X#else
X					if (0 < first_thread_on_screen) {
X						thread_index_point = 0;
X						show_thread_page ();
X					} else {
X						erase_thread_arrow ();
X						thread_index_point = 0;
X						draw_thread_arrow ();
X					}
X					break;
X#endif					
X				}
X				if (thread_index_point + 1 >= last_thread_on_screen) {
X#ifndef USE_CLEARSCREEN
X					erase_thread_arrow ();
X#endif					
X					thread_index_point++;
X					show_thread_page ();
X				} else {
X					erase_thread_arrow ();
X					thread_index_point++;
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('P'):
X			case 'k':		/* line up */
Xthread_up:
X				if (thread_index_point == 0) {
X#ifdef NO_LOOP_AROUND
X					break;
X#else
X					if (top_thread > last_thread_on_screen) {
X						thread_index_point = top_thread - 1;
X						show_thread_page ();
X					} else {
X						erase_thread_arrow ();
X						thread_index_point = top_thread - 1;
X						draw_thread_arrow ();
X					}
X					break;
X#endif
X				}
X				if (thread_index_point <= first_thread_on_screen) {
X					thread_index_point--;
X					show_thread_page ();
X				} else {
X					erase_thread_arrow ();
X					thread_index_point--;
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('U'):		/* page up */
X			case 'b':
Xthread_page_up:
X				if (thread_index_point == 0) {
X#ifdef NO_LOOP_AROUND
X					break;
X#else
X					if (top_thread > last_thread_on_screen) {
X						thread_index_point = top_thread - 1;
X						show_thread_page ();
X					} else {
X						erase_thread_arrow ();
X						thread_index_point = top_thread - 1;
X						draw_thread_arrow ();
X					}
X					break;
X#endif					
X				}
X#ifndef USE_CLEARSCREEN
X				clear_message ();
X#endif
X				erase_thread_arrow ();
X				scroll_lines = (full_page_scroll ? NOTESLINES : NOTESLINES / 2);
X				if ((n = thread_index_point % scroll_lines) > 0) {
X					thread_index_point = thread_index_point - n;
X				} else {
X					thread_index_point = ((thread_index_point - scroll_lines) / scroll_lines) * scroll_lines;
X				}
X				if (thread_index_point < 0) {
X					thread_index_point = 0;
X				}
X				if (thread_index_point < first_thread_on_screen
X				|| thread_index_point >= last_thread_on_screen)
X					show_thread_page ();
X				else
X					draw_thread_arrow ();
X				break;
X
X			case 'B':	/* bug/gripe/comment mailed to author */
X				mail_bug_report ();
X#ifndef USE_CLEARSCREEN
X				ClearScreen ();
X#endif
X				show_thread_page ();
X				break;
X
X			case 'c':	/* catchup thread but ask for confirmation */
X			case 'K':	/* mark thread as read immediately */
X				if (ch == 'c') {
X					if (confirm_action && !prompt_yn (LINES, txt_mark_thread_read, 'y')) {
X						break;
X					}
X				}
X				for (i = (int) base[thread_basenote] ; i != -1 ; i = arts[i].thread) {
X					arts[i].unread = ART_READ;
X				}
X				goto thread_done;
X				break;
X
X			case 'd':	/* toggle display of subject & subj/author */
X				if (! threaded_on_subject) {
X					toggle_subject_from ();
X					show_thread_page ();
X				}	
X				break;
X				
X			case 'h':	/* help */
X				show_info_page (HELP_INFO, help_thread, txt_thread_com);
X				show_thread_page ();
X				break;
X
X			case 'I':	/* toggle inverse video */
X				toggle_inverse_video ();
X				show_thread_page ();
X				break;
X
X			case 'q':	/* return to previous level */
X				goto thread_done;
X
X			case 'Q':	/* quit */
X				ret_code = -2;
X				goto thread_done;
X
X 			case 'T':	/* tag/untag art for mailing/piping/printing/saving */
X 				if (thread_index_point == 0) {
X 					n = thread_respnum;
X 				} else {
X 					n = choose_response (thread_basenote, thread_index_point);
X 				}
X 				if (n < 0)
X 					break;
X 
X 				if (arts[n].tagged) {
X 					arts[n].tagged = 0;
X 					info_message (txt_untagged_art);
X 				} else {
X 					arts[n].tagged = ++num_of_tagged_arts;
X					info_message (txt_tagged_art);
X 				}
X 				show_thread_page ();
X 				goto thread_down;
X				break;
X
X			case 'v':	/* version */
X				info_message (cvers);
X				break;
X
X			case 'z':	/* mark article as unread */
X				if (thread_index_point == 0) {
X					n = thread_respnum;
X				} else {
X					n = choose_response (thread_basenote, thread_index_point);
X				}
X				if (n >= 0) {
X					arts[n].unread = ART_UNREAD;
X					show_thread_page ();
X					info_message (txt_art_marked_as_unread);
X				}
X				break;
X
X			case 'Z':	/* mark thread as unread */
X				for (i = (int) base[thread_basenote] ; i != -1 ; i = arts[i].thread) {
X					arts[i].unread = ART_UNREAD;
X				}
X				show_thread_page ();
X				info_message (txt_thread_marked_as_unread);
X				break;
X				
X			default:
X			    info_message (txt_bad_command);
X		}
X	}
X
Xthread_done:
X	clear_note_area ();
X
X#endif /* INDEX_DAEMON */
X
X	return (ret_code);
X}
X
X
Xvoid show_thread_page ()
X{
X#ifndef INDEX_DAEMON
X
X	extern int index_point;
X	char new_resps[8];
X	char from[LEN];
X	int i, j;
X	int len_from;
X	int len_subj = 0;
X	int off_subj = 0;
X	int off_both = 0;
X	static int index = 0;
X
X	set_signals_thread ();
X	
X	ClearScreen ();
X
X	if (threaded_on_subject) {
X		sprintf (msg, "Thread (%.*s)", COLS-23, arts[thread_respnum].subject);
X	} else {
X		sprintf (msg, "List Thread (%d of %d)", index_point+1, top_base);
X	}
X	show_title (msg);
X
X	MoveCursor (INDEX_TOP, 0);
X	if (thread_index_point > top_thread - 1) {
X		thread_index_point = top_thread - 1;
X	}
X
X	if (NOTESLINES <= 0) {
X		first_thread_on_screen = 0;
X	} else {
X		first_thread_on_screen = (thread_index_point / NOTESLINES) * NOTESLINES;
X		if (first_thread_on_screen < 0) {
X			first_thread_on_screen = 0;
X		}
X	}
X
X	last_thread_on_screen = first_thread_on_screen + NOTESLINES;
X
X	if (last_thread_on_screen >= top_thread) {
X		last_thread_on_screen = top_thread;
X		first_thread_on_screen = (top_thread / NOTESLINES) * NOTESLINES;
X
X		if (first_thread_on_screen == last_thread_on_screen ||
X			first_thread_on_screen < 0) {
X			if (first_thread_on_screen < 0) {
X				first_thread_on_screen = 0;
X			} else {
X				first_thread_on_screen = last_thread_on_screen - NOTESLINES;
X			}
X		}
X	}
X
X	if (top_thread == 0) {
X		first_thread_on_screen = 0;
X		last_thread_on_screen = 0;
X	}
X
X	index = choose_response (thread_basenote, first_thread_on_screen);
X	assert(first_thread_on_screen != 0 || index == thread_respnum);
X
X	if (! draw_arrow_mark) {
X		off_subj = 2;
X		off_both = 5;
X	}	
X
X	if (threaded_on_subject) {
X		len_from = max_subj+max_from+off_both;
X	} else {
X		if (show_author != SHOW_FROM_NONE) {
X			len_from = max_from;
X			len_subj = max_subj+off_subj;
X		} else {
X			len_from = 0;
X			len_subj = max_from+max_subj+off_subj;
X		}
X	}	
X
X	for (j=0, i = first_thread_on_screen; j < NOTESLINES && i < last_thread_on_screen; i++, j++) {
X		if (arts[index].tagged) {
X			sprintf (new_resps, "%3d", arts[index].tagged);
X		} else if (arts[index].unread == ART_UNREAD) {
X			if (arts[index].hot == 0)
X				sprintf (new_resps, "  %c", UNREAD_ART_MARK);
X			else
X				sprintf (new_resps, "  %c", HOT_ART_MARK);
X		} else if (arts[index].unread == ART_WILL_RETURN) {
X			sprintf (new_resps, "  %c", RETURN_ART_MARK);
X		} else {
X			strcpy (new_resps, "   ");
X		}
X
X		if (threaded_on_subject) {
X			get_author (TRUE, index, from);
X			sprintf (screen[j].col, "  %4d%3s  %-*.*s\r\n",
X				i, new_resps, len_from, len_from, from);
X		} else {
X			if (show_author != SHOW_FROM_NONE) {
X				get_author (TRUE, index, from);
X			}
X			sprintf (screen[j].col, "  %4d%3s  %-*.*s   %-*.*s\r\n",
X				i, new_resps, len_subj, len_subj,
X				arts[index].subject, len_from, len_from, from);
X		}
X		
X		fputs (screen[j].col, stdout);
X		
X		if ((index = next_response (index)) == -1) {
X			break;
X		}	
X	}
X
X#ifndef USE_CLEARSCREEN
X	CleartoEOS ();
X#endif
X
X	if (last_thread_on_screen == top_thread) {
X		info_message (txt_end_of_thread);
X	}
X
X	draw_thread_arrow ();
X
X#endif /* INDEX_DAEMON */
X}
X
X
Xvoid draw_thread_arrow ()
X{
X	draw_arrow (INDEX_TOP + (thread_index_point-first_thread_on_screen));
X}
X
X
Xvoid erase_thread_arrow ()
X{
X	erase_arrow (INDEX_TOP + (thread_index_point-first_thread_on_screen));
X}
X
X
Xint prompt_thread_num (ch)
X	char ch;
X{
X	int num;
X
X	clear_message ();
X
X	if ((num = prompt_num (ch, txt_read_art)) == -1) {
X		clear_message ();
X		return FALSE;
X	}
X
X	if (num >= top_thread)
X		num = top_thread - 1;
X
X	if (num >= first_thread_on_screen
X	&&  num < last_thread_on_screen) {
X		erase_thread_arrow ();
X		thread_index_point = num;
X		draw_thread_arrow ();
X	} else {
X#ifndef USE_CLEARSCREEN
X		erase_thread_arrow ();
X#endif		
X		thread_index_point = num;
X		show_thread_page ();
X	}
X	return TRUE;
X}
X
X/*
X *  Return the number of unread articles there are within a thread
X */
X
Xint new_responses (thread)
X	int thread;
X{
X	int i;
X	int sum = 0;
X
X	for (i = (int) base[thread]; i >= 0; i = arts[i].thread) {
X		if (arts[i].unread) {
X			sum++;
X		}
X	}
X	
X	return sum;
X}
X
X/*
X *  Which base note (an index into base[]) does a respnum
X *  (an index into arts[]) corresponsd to?
X *
X *  In other words, base[] points to an entry in arts[] which is
X *  the head of a thread, linked with arts[].thread.  For any q: arts[q],
X *  find i such that base[i]->arts[n]->arts[o]->...->arts[q]
X *
X *  Note that which_thread() can return -1 if in show_read_only mode and
X *  the article of interest has been read as well as all other articles in
X *  the thread,  thus resulting in no base[] entry for it.
X */
X
Xint which_thread (n)
X	int n;
X{
X	register int i, j;
X
X	for (i = 0; i < top_base; i++) {
X		for (j = (int) base[i] ; j >= 0 ; j = arts[j].thread) {
X			if (j == n) {
X				return i;
X			}
X		}
X	}
X
X	sprintf (msg, "%d", n);
X	error_message (txt_cannot_find_base_art, msg);
X	return -1;
X}
X
X/*
X *  Find how deep in a thread a response is.  Start counting at zero
X */
X
Xint which_response (n)
X	int n;
X{
X	int i, j;
X	int num = 0;
X
X	i = which_thread (n);
X	assert(i >= 0);
X
X	for (j = (int) base[i]; j != -1; j = arts[j].thread)
X		if (j == n)
X			break;
X		else
X			num++;
X
X	return num;
X}
X
X/*
X *  Given an index into base[], find the number of responses for
X *  that basenote
X */
X
Xint num_of_responses (n)
X	int n;
X{
X	int i;
X	int oldi = -3;
X	int sum = 0;
X
X	assert (n < top_base);
X
X	for (i = (int) base[n]; i != -1; i = arts[i].thread) {
X		assert (i != -2);
X		assert (i != oldi);
X		oldi = i;
X		sum++;
X	}
X
X	return sum - 1;
X}
X
X/*
X * Given an index into base[], return relevant statistics
X */
X
Xint stat_thread (n, sbuf)
X	int n;
X	struct art_stat_t *sbuf;
X{
X	int i;
X
X	sbuf->total  = 0;
X	sbuf->unread = 0;
X	sbuf->seen   = 0;
X	sbuf->hot_total = 0;
X	sbuf->hot_unread= 0;
X	sbuf->hot_seen  = 0;
X
X	for (i = (int) base[n]; i != -1; i = arts[i].thread) {
X		++sbuf->total;
X		if (arts[i].unread == ART_UNREAD)
X			++sbuf->unread;
X		else if (arts[i].unread == ART_WILL_RETURN)
X			++sbuf->seen;
X
X		if (arts[i].hot) {
X			++sbuf->hot_total;
X			if (arts[i].unread == ART_UNREAD)
X				++sbuf->hot_unread;
X			else if (arts[i].unread == ART_WILL_RETURN)
X				++sbuf->hot_seen;
X		}
X
X#if 0
X		if (arts[i].killed) {
X			++sbuf->killed;
X		}
X#endif
X	}
X
X
X	if (sbuf->hot_unread)
X		sbuf->art_mark = HOT_ART_MARK;
X	else if (sbuf->unread)
X		sbuf->art_mark = UNREAD_ART_MARK;
X	else if (sbuf->seen)
X		sbuf->art_mark = RETURN_ART_MARK;
X	else
X		sbuf->art_mark = READ_ART_MARK;
X
X	return(sbuf->total);
X}
X
X
X/*
X *  Find the next response.  Go to the next basenote if there
X *  are no more responses in this thread
X */
X
Xint next_response (n)
X	int n;
X{
X	int i;
X
X	if (arts[n].thread >= 0)
X		return arts[n].thread;
X
X	i = which_thread (n) + 1;
X
X	if (i >= top_base)
X		return -1;
X
X	return (int) base[i];
X}
X
X/*
X *  Given a respnum (index into arts[]), find the respnum of the
X *  next basenote
X */
X
Xint next_thread (n)
X	int n;
X{
X	int i;
X
X	i = which_thread (n) + 1;
X	if (i >= top_base)
X		return -1;
X
X	return (int) base[i];
X}
X
X/*
X *  Find the previous response.  Go to the last response in the previous
X *  thread if we go past the beginning of this thread.
X */
X
Xint prev_response (n)
X	int n;
X{
X	int resp;
X	int i;
X
X	resp = which_response (n);
X
X	if (resp > 0)
X		return choose_response (which_thread (n), resp-1);
X
X	i = which_thread (n) - 1;
X
X	if (i < 0)
X		return -1;
X
X	return choose_response (i, num_of_responses (i));
X}
X
X/*
X *  return response number n from thread i
X */
X
Xint choose_response (i, n)
X	int i;
X	int n;
X{
X	int j;
X
X	j = (int) base[i];
X
X	while (n-- && arts[j].thread >= 0) {
X		j = arts[j].thread;
X	}
X
X	return j;
X}
X
X/*
X *  Find the next unread response in this group 
X */
X
Xint next_unread (n)
X	int n;
X{
X	while (n >= 0) {
X		if (arts[n].unread == ART_UNREAD) {
X			return n;
X		}
X		n = next_response (n);
X	}
X
X	return -1;
X}
X
X
X/*
X *  Find the previous unread response in this thread
X */
X
Xint prev_unread (n)
X	int n;
X{
X	while (n >= 0) {
X		if (arts[n].unread == ART_UNREAD) {
X			return n;
X		}
X		n = prev_response (n);
X	}
X
X	return -1;
X}
END_OF_FILE
  if test 17796 -ne `wc -c <'thread.c'`; then
    echo shar: \"'thread.c'\" unpacked with wrong size!
  fi
  # end of 'thread.c'
fi
echo shar: End of archive 3 \(of 14\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
