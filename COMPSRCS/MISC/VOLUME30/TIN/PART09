Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i009:  tin - threaded full screen newsreader, Part09/14
Message-ID: <1992May20.172734.29722@sparky.imd.sterling.com>
X-Md4-Signature: 34b0a330415b8e1bbfc7670a2d6e7725
Date: Wed, 20 May 1992 17:27:34 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 9
Archive-name: tin/part09
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  extern.h newsrc.c tin.h
# Wrapped by kent@sparky on Tue May 19 13:38:04 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 14)."'
if test -f 'extern.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extern.h'\"
else
  echo shar: Extracting \"'extern.h'\" \(17525 characters\)
  sed "s/^X//" >'extern.h' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : extern.h
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 12-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X/*
X * Library prototypes
X */
X
X#if defined(__GNUC__) && defined(DEBUG)
X
Xextern unsigned int alarm (unsigned int seconds);
Xextern int close (int fildes);
Xextern int fork (void);
Xextern int getpid (void);
Xextern char *getcwd (char *buf, int size);
X#ifndef DGUX
Xextern unsigned short getuid (void);
Xextern unsigned short getegid (void);
Xextern unsigned short geteuid (void);
X#endif /* DGUX */
Xextern int getopt (int argc, char **argv, char *optstring);
Xextern int kill (int pid, int sig);
Xextern int link (char *path1, char *path2);
Xextern int open (char *path, int oflag);
Xextern FILE *popen (char *command, char *type);
Xextern int pclose (FILE *stream);
Xextern int read (int fildes, char *buf, unsigned int nbyte);
Xextern int setgid (int gid);
Xextern int setuid (int uid);
Xextern int tgetent (char *bp, char *name);
Xextern int tputs (register char *cp, int count, int (*outc)());
Xextern int unlink (char *path);
X
X#ifndef sony
X#	ifndef DGUX
Xextern unsigned short getgid (void);
X#	endif /* DGUX */
Xextern void setpgrp (void);
Xextern unsigned int sleep (unsigned int seconds);
X#endif
X
X#endif
X
X#if !defined(__STDC__)
Xextern char *getenv ();
X#endif
X
Xextern int optind;
Xextern char *optarg;
X
X/*
X * Local variables
X */
X 
Xextern char *help_group[];
Xextern char *help_page[];
Xextern char *help_select[];
Xextern char *help_spooldir[];
Xextern char *help_thread[];
Xextern char active_file[PATH_LEN];
Xextern char add_addr[LEN];
Xextern char default_art_search[LEN];
Xextern char article[PATH_LEN];
Xextern char default_author_search[LEN];
Xextern char bug_addr[LEN];
Xextern char cvers[LEN];
Xextern char dead_article[PATH_LEN];
Xextern char default_crosspost_group[LEN];
Xextern char default_mail_address[LEN];
Xextern char default_pipe_command[LEN];
Xextern char default_post_subject[LEN];
Xextern char default_regex_pattern[LEN];
Xextern char default_save_file[PATH_LEN];
Xextern char default_shell_command[LEN];
Xextern char delgroups[LEN];
Xextern char default_goto_group[LEN];
Xextern char default_group_search[LEN];
Xextern char default_maildir[PATH_LEN];
Xextern char homedir[PATH_LEN];
Xextern char indexdir[PATH_LEN];
Xextern char killfile[PATH_LEN];
Xextern char killfrom[LEN];
Xextern char killsubj[LEN];
Xextern char mail_news_user[LEN];
Xextern char mailbox[PATH_LEN];
Xextern char mailer[PATH_LEN];
Xextern char msg[LEN];
Xextern char my_distribution[LEN];
Xextern char my_org[LEN];
Xextern char newnewsrc[PATH_LEN];
Xextern char newsrc[PATH_LEN];
Xextern char nntp_server[LEN];
Xextern char page_header[LEN];
Xextern char postfile[PATH_LEN];
Xextern char printer[LEN];
Xextern char cmd_line_printer[LEN];
Xextern char proc_ch_default;				/* set in change_rcfile () */
Xextern char progname[PATH_LEN];
Xextern char rcdir[PATH_LEN];
Xextern char rcfile[PATH_LEN];
Xextern char redirect_output[LEN];
Xextern char reply_to[LEN];
Xextern char default_savedir[PATH_LEN];
Xextern char default_sigfile[PATH_LEN];
Xextern char default_signature[PATH_LEN];
Xextern char spooldir[PATH_LEN];
Xextern char spooldir_alias[PATH_LEN];
Xextern char default_subject_search[LEN];
Xextern char subscriptions_file[PATH_LEN];
Xextern char txt_help_bug_report[LEN];
Xextern char unthreadfile[PATH_LEN];
Xextern char userid[LEN];
X
Xextern char txt_1_resp[];
Xextern char txt_active_file_is_empty[];
Xextern char txt_added_groups[];
Xextern char txt_append_to_file[];
Xextern char txt_art[];
Xextern char txt_art_cancelled[];
Xextern char txt_art_cannot_cancel[];
Xextern char txt_art_marked_as_unread[];
Xextern char txt_art_not_saved[];
Xextern char txt_art_pager_com[];
Xextern char txt_art_posted[];
Xextern char txt_art_rejected[];
Xextern char txt_art_saved_to[];
Xextern char txt_art_thread_regex_tag[];
Xextern char txt_art_unavailable[];
Xextern char txt_author_search_backwards[];
Xextern char txt_author_search_forwards[];
Xextern char txt_bad_active_file[];
Xextern char txt_bad_command[];
Xextern char txt_begin_of_art[];
Xextern char txt_cancelling[];
Xextern char txt_cannot_find_base_art[];
Xextern char txt_cannot_get_nntp_server_name[];
Xextern char txt_cannot_open[];
Xextern char txt_cannot_open_active_file[];
Xextern char txt_cannot_open_art[];
Xextern char txt_cannot_post[];
Xextern char txt_checking[];
Xextern char txt_checking_active_file[];
Xextern char txt_checking_for_news[];
Xextern char txt_checksum_of_file[];
Xextern char txt_command_failed[];
Xextern char txt_command_failed_s[];
Xextern char txt_connecting[];
Xextern char txt_connection_to_server_broken[];
Xextern char txt_continue[];
Xextern char txt_corrupt_index[];
Xextern char txt_corrupt_kill_file[];
Xextern char txt_creating_newsrc[];
Xextern char txt_crosspost_an_article[];
Xextern char txt_crosspost_group[];
Xextern char txt_del_group_in_newsrc[];
Xextern char txt_delete_bogus_group[];
Xextern char txt_deleting[];
Xextern char txt_deleting_from_newsrc[];
Xextern char txt_delete_processed_files[];
Xextern char txt_end_of_arts[];
Xextern char txt_end_of_groups[];
Xextern char txt_end_of_thread[];
Xextern char txt_extracting_archive[];
Xextern char txt_extracting_shar[];
Xextern char txt_failed_to_connect_to_server[];
Xextern char txt_feed_pattern[];
Xextern char txt_group[];
Xextern char txt_group_deleted[];
Xextern char txt_group_select_com[];
Xextern char txt_spooldir_com[];
Xextern char txt_group_selection[];
Xextern char txt_group_undeleted[];
Xextern char txt_help_4[];
Xextern char txt_help_C[];
Xextern char txt_help_I[];
Xextern char txt_help_K[];
Xextern char txt_help_M[];
Xextern char txt_help_S[];
Xextern char txt_help_T[];
Xextern char txt_help_U[];
Xextern char txt_help_W[];
Xextern char txt_help_a[];
Xextern char txt_help_autosave[];
Xextern char txt_help_b[];
Xextern char txt_help_bug[];
Xextern char txt_help_c[];
Xextern char txt_help_ck[];
Xextern char txt_help_cr[];
Xextern char txt_help_catchup_groups[];
Xextern char txt_help_confirm_action[];
Xextern char txt_help_ctrl_d[];
Xextern char txt_help_ctrl_h[];
Xextern char txt_help_ctrl_k[];
Xextern char txt_help_ctrl_l[];
Xextern char txt_help_d[];
Xextern char txt_help_dash[];
Xextern char txt_help_draw_arrow[];
Xextern char txt_help_g[];
Xextern char txt_help_g_4[];
Xextern char txt_help_g_c[];
Xextern char txt_help_g_cr[];
Xextern char txt_help_cr[];
Xextern char txt_help_g_ctrl_k[];
Xextern char txt_help_g_ctrl_r[];
Xextern char txt_help_g_l[];
Xextern char txt_help_g_q[];
Xextern char txt_help_g_search[];
Xextern char txt_help_g_tab[];
Xextern char txt_help_g_y[];
Xextern char txt_help_g_z[];
Xextern char txt_help_h[];
Xextern char txt_help_i[];
Xextern char txt_help_i_4[];
Xextern char txt_help_i_cr[];
Xextern char txt_help_i_n[];
Xextern char txt_help_i_p[];
Xextern char txt_help_i_search[];
Xextern char txt_help_i_tab[];
Xextern char txt_help_j[];
Xextern char txt_help_kill_from[];
Xextern char txt_help_kill_group[];
Xextern char txt_help_kill_how[];
Xextern char txt_help_kill_subject[];
Xextern char txt_help_kill_text[];
Xextern char txt_help_kill_text_type[];
Xextern char txt_help_l[];
Xextern char txt_help_m[];
Xextern char txt_help_maildir[];
Xextern char txt_help_mark_saved_read[];
Xextern char txt_help_n[];
Xextern char txt_help_o[];
Xextern char txt_help_p_0[];
Xextern char txt_help_p_4[];
Xextern char txt_help_p_cr[];
Xextern char txt_help_p_ctrl_r[];
Xextern char txt_help_p_d[];
Xextern char txt_help_p_f[];
Xextern char txt_help_p_g[];
Xextern char txt_help_p_k[];
Xextern char txt_help_p_m[];
Xextern char txt_help_p_n[];
Xextern char txt_help_p_p[];
Xextern char txt_help_p_r[];
Xextern char txt_help_p_s[];
Xextern char txt_help_p_search[];
Xextern char txt_help_p_tab[];
Xextern char txt_help_p_z[];
Xextern char txt_help_page_scroll[];
Xextern char txt_help_pipe[];
Xextern char txt_help_pos_first_unread[];
Xextern char txt_help_post_proc_type[];
Xextern char txt_help_print_header[];
Xextern char txt_help_printer[];
Xextern char txt_help_q[];
Xextern char txt_help_r[];
Xextern char txt_help_s[];
Xextern char txt_help_savedir[];
Xextern char txt_help_sel_c[];
X#ifndef NO_SHELL_ESCAPE
Xextern char txt_help_shell[];
X#endif
Xextern char txt_help_show_author[];
Xextern char txt_help_show_only_unread[];
Xextern char txt_help_sort_type[];
Xextern char txt_help_start_editor_offset[];
Xextern char txt_help_t[];
Xextern char txt_help_t_0[];
Xextern char txt_help_t_4[];
Xextern char txt_help_t_K[];
Xextern char txt_help_t_cr[];
Xextern char txt_help_t_tab[];
Xextern char txt_help_thread[];
Xextern char txt_help_thread_arts[];
Xextern char txt_help_u[];
Xextern char txt_help_v[];
Xextern char txt_help_w[];
Xextern char txt_help_x[];
Xextern char txt_help_y[];
Xextern char txt_hit_any_key[];
Xextern char txt_hit_space_for_more[];
Xextern char txt_in_art_you_write[];
Xextern char txt_index_page_com[];
Xextern char txt_indexing[];
Xextern char txt_indexing_num[];
Xextern char txt_inverse_off[];
Xextern char txt_inverse_on[];
Xextern char txt_kill_from[];
Xextern char txt_kill_group[];
Xextern char txt_kill_how[];
Xextern char txt_kill_menu[];
Xextern char txt_kill_subject[];
Xextern char txt_kill_text[];
Xextern char txt_kill_text_type[];
Xextern char txt_killing_arts[];
Xextern char txt_last_resp[];
Xextern char txt_listing_archive[];
Xextern char txt_mail_art_to[];
Xextern char txt_mail_bug_report[];
Xextern char txt_mail_bug_report_confirm[];
Xextern char txt_mailed[];
Xextern char txt_mailing_to[];
Xextern char txt_mark_all_read[];
Xextern char txt_mark_thread_read[];
Xextern char txt_mark_group_read[];
Xextern char txt_more[];
Xextern char txt_more_percent[];
Xextern char txt_moving[];
Xextern char txt_newsgroup[];
Xextern char txt_newsgroup_position[];
Xextern char txt_next_resp[];
Xextern char txt_nntp_to_fd_cannot_reopen[];
Xextern char txt_nntp_to_fp_cannot_reopen[];
Xextern char txt_no_arts[];
Xextern char txt_no_arts_posted[];
Xextern char txt_no_blank_line[];
Xextern char txt_no_command[];
Xextern char txt_no_filename[];
Xextern char txt_no_group[];
Xextern char txt_no_groups[];
Xextern char txt_no_groups_to_delete[];
Xextern char txt_no_groups_to_read[];
Xextern char txt_no_groups_to_yank_in[];
Xextern char txt_no_last_message[];
Xextern char txt_no_mail_address[];
Xextern char txt_no_match[];
Xextern char txt_no_more_groups[];
Xextern char txt_no_next_unread_art[];
Xextern char txt_no_prev_group[];
Xextern char txt_no_prev_unread_art[];
Xextern char txt_no_resp[];
Xextern char txt_no_resps_in_thread[];
Xextern char txt_no_search_string[];
Xextern char txt_no_subject[];
Xextern char txt_not_active_newsfeed[];
Xextern char txt_not_in_active_file[];
Xextern char txt_opt_autosave[];
Xextern char txt_opt_catchup_groups[];
Xextern char txt_opt_confirm_action[];
Xextern char txt_opt_draw_arrow[];
Xextern char txt_opt_maildir[];
Xextern char txt_opt_mark_saved_read[];
Xextern char txt_opt_page_scroll[];
Xextern char txt_opt_pos_first_unread[];
Xextern char txt_opt_post_process[];
Xextern char txt_opt_print_header[];
Xextern char txt_opt_printer[];
Xextern char txt_opt_process_type[];
Xextern char txt_opt_savedir[];
Xextern char txt_opt_show_author[];
Xextern char txt_opt_show_only_unread[];
Xextern char txt_opt_sort_type[];
Xextern char txt_opt_start_editor_offset[];
Xextern char txt_opt_thread_arts[];
Xextern char txt_option_not_enabled[];
Xextern char txt_options_menu[];
Xextern char txt_out_of_memory[];
Xextern char txt_pipe_to_command[];
Xextern char txt_piping[];
Xextern char txt_plural[];
Xextern char txt_post_a_followup[];
Xextern char txt_post_an_article[];
Xextern char txt_post_history_menu[];
Xextern char txt_post_newsgroup[];
Xextern char txt_post_process_none[];
Xextern char txt_post_process_sh[];
Xextern char txt_post_process_type[];
Xextern char txt_post_process_uud_ext_zoo[];
Xextern char txt_post_process_uud_lst_zoo[];
Xextern char txt_post_process_uudecode[];
Xextern char txt_post_processing[];
Xextern char txt_post_processing_failed[];
Xextern char txt_post_processing_finished[];
Xextern char txt_post_subject[];
Xextern char txt_posting[];
Xextern char txt_printed[];
Xextern char txt_printing[];
Xextern char txt_quit[];
Xextern char txt_quit_edit_cancel[];
Xextern char txt_quit_edit_post[];
Xextern char txt_quit_edit_xpost[];
Xextern char txt_quit_edit_save_killfile[];
Xextern char txt_quit_edit_send[];
Xextern char txt_read_art[];
Xextern char txt_read_resp[];
Xextern char txt_reading_active_file[];
Xextern char txt_rejected_by_nntpserver[];
Xextern char txt_rename_error[];
Xextern char txt_reply_to_author[];
Xextern char txt_reset_newsrc[];
Xextern char txt_resizing_window[];
Xextern char txt_resp_redirect[];
Xextern char txt_resp_to_poster[];
Xextern char txt_resp_x_of_n[];
Xextern char txt_s_at_s[];
Xextern char txt_save_filename[];
Xextern char txt_save_pattern[];
Xextern char txt_saved[];
Xextern char txt_saved_pattern_to[];
Xextern char txt_saved_to_mailbox[];
Xextern char txt_saving[];
Xextern char txt_screen_init_failed[];
Xextern char txt_search_backwards[];
Xextern char txt_search_forwards[];
Xextern char txt_searching[];
Xextern char txt_select_group[];
Xextern char txt_select_rcfile_option[];
Xextern char txt_select_spooldir[];
Xextern char txt_server_name_in_file_env_var[];
Xextern char txt_shell_escape[];
Xextern char txt_show_from_addr[];
Xextern char txt_show_from_both[];
Xextern char txt_show_from_name[];
Xextern char txt_show_from_none[];
Xextern char txt_spooldir_selection[];
Xextern char txt_sort_by_date_ascend[];
Xextern char txt_sort_by_date_descend[];
Xextern char txt_sort_by_from_ascend[];
Xextern char txt_sort_by_from_descend[];
Xextern char txt_sort_by_nothing[];
Xextern char txt_sort_by_subj_ascend[];
Xextern char txt_sort_by_subj_descend[];
Xextern char txt_stuff_nntp_cannot_open[];
Xextern char txt_subscribe_pattern[];
Xextern char txt_subscribe_to_new_group[];
Xextern char txt_subscribed_num_groups[];
Xextern char txt_subscribed_to[];
Xextern char txt_subscribing[];
Xextern char txt_subscribing_to[];
Xextern char txt_suspended_message[];
Xextern char txt_tagged_art[];
Xextern char txt_there_is_no_news[];
Xextern char txt_threading_arts[];
Xextern char txt_thread_com[];
Xextern char txt_thread_marked_as_unread[];
Xextern char txt_thread_not_saved[];
Xextern char txt_thread_page[];
Xextern char txt_thread_resp_page[];
Xextern char txt_thread_saved_to[];
Xextern char txt_thread_saved_to_many[];
Xextern char txt_thread_x_of_n[];
Xextern char txt_toggled_rot13[];
Xextern char txt_type_h_for_help[];
Xextern char txt_unkilling_arts[];
Xextern char txt_unsubscribe_pattern[];
Xextern char txt_unsubscribed_num_groups[];
Xextern char txt_unsubscribed_to[];
Xextern char txt_unsubscribing[];
Xextern char txt_unsubscribing_from[];
Xextern char txt_untagged_art[];
Xextern char txt_unthreading_arts[];
Xextern char txt_uudecoding[];
Xextern char txt_writes[];
Xextern char txt_writes_name[];
Xextern char txt_x_resp[];
Xextern char txt_yanking_all_groups[];
Xextern char txt_yanking_sub_groups[];
Xextern char txt_you_have_mail[];
X
Xextern int LINES, COLS;
Xextern int MORE_POS;
Xextern int NOTESLINES;
Xextern int RIGHT_POS;
Xextern int *my_group;
Xextern int *unread;
Xextern int can_post;
Xextern int catchup;
Xextern int catchup_read_groups;
Xextern int cmd_line;
Xextern int compiled_with_nntp;
Xextern int confirm_action;
Xextern int created_rcdir;
Xextern int debug;
Xextern int default_move_group;
Xextern int default_printer;
Xextern int default_show_author;
X#ifdef SIGTSTP
Xextern int do_sigtstp;
X#endif
Xextern int draw_arrow_mark;
Xextern int full_page_scroll;
Xextern int group_hash[TABLE_SIZE];
Xextern int group_top;
Xextern int groupname_len;
Xextern int index_file_killed;
Xextern int inn_nntp_server;
Xextern int inverse_okay;
Xextern int killed_articles;
Xextern int kill_level;
Xextern int kill_num;
Xextern int local_index;
Xextern int mail_news;
Xextern int mark_saved_read;
Xextern int max_active;
Xextern int max_art;
Xextern int max_from;
Xextern int max_subj;
Xextern int max_kill;
Xextern int max_save;
Xextern int nntp_codeno;
Xextern int num_active;
Xextern int num_of_hot_arts;
Xextern int num_of_killed_arts;
Xextern int num_of_tagged_arts;
Xextern int pos_first_unread;
Xextern int post_proc_type;
Xextern int print_header;
Xextern int process_id;
Xextern int read_news_via_nntp;
Xextern int real_gid;
Xextern int real_uid;
Xextern int real_umask;
Xextern int save_archive_name;
Xextern int save_news;
Xextern int save_num;
Xextern int show_author;
Xextern int show_only_unread;
Xextern int sort_art_type;
Xextern int space_mode;
Xextern int spooldir_is_active;
Xextern int start_editor_offset;
Xextern int start_line_offset;
Xextern int thread_arts;
Xextern int tin_gid;
Xextern int tin_uid;
Xextern int top;
Xextern int top_base;
Xextern int unlink_article;
Xextern int update;
Xextern int verbose;
Xextern int update_fork;
Xextern int check_any_unread;
Xextern int start_any_unread;
Xextern int notify_new_groups;
Xextern int xindex_supported;
Xextern int xuser_supported;
Xextern int xspooldir_supported;
X
Xextern long *base;
X
Xextern struct passwd *myentry;
Xextern struct article_t *arts;
Xextern struct group_t *active;
Xextern struct kill_t *killf;
Xextern struct posted_t *posted;
Xextern struct save_t *save;
Xextern struct screen_t *screen;
X
X#ifdef POSIX_JOB_CONTROL
Xextern struct sigaction art_act;
Xextern struct sigaction group_act;
Xextern struct sigaction kill_act;
Xextern struct sigaction main_act;
Xextern struct sigaction old_act;
Xextern struct sigaction page_act;
Xextern struct sigaction rcfile_act;
Xextern struct sigaction select_act;
Xextern struct sigaction thread_act;
X#endif
END_OF_FILE
  if test 17525 -ne `wc -c <'extern.h'`; then
    echo shar: \"'extern.h'\" unpacked with wrong size!
  fi
  # end of 'extern.h'
fi
if test -f 'newsrc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newsrc.c'\"
else
  echo shar: Extracting \"'newsrc.c'\" \(20406 characters\)
  sed "s/^X//" >'newsrc.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : newsrc.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 19-04-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X
X/*
X * Automatically subscribe user to newsgroups specified in
X * /usr/lib/news/subscribe (locally) or same file but from
X * NNTP server (LIST AUTOSUBSCRIBE) and create .newsrc
X */
X
Xint auto_subscribe_groups ()
X{
X	char buf[LEN];
X	FILE *fp_newsrc;
X	FILE *fp_subs;
X	int len;
X	int ret_code = FALSE;
X	
X	if ((fp_subs = open_subscription_fp ()) != NULL) {
X		if ((fp_newsrc = fopen (newsrc, "w")) != NULL) {
X			while (fgets (buf, sizeof (buf), fp_subs) != NULL) {
X				len = strlen (buf);
X				if (len > 1) {
X					buf[len-1] = '\0';
X					fprintf (fp_newsrc, "%s:\n", buf);
X				}	
X			}	
X			fclose (fp_newsrc);
X			ret_code = TRUE;
X		}	
X		fclose (fp_subs);
X	}
X
X	return (ret_code);
X}
X
X/*
X * make a backup of users .newsrc in case of the bogie man
X */
X
Xvoid backup_newsrc ()
X{
X	char buf[8192];
X	FILE *fp_newsrc, *fp_backup;
X	
X	if ((fp_newsrc = fopen (newsrc, "r")) != NULL) {
X		sprintf (buf, "%s/.oldnewsrc", homedir);
X		unlink (buf);	/* because rn makes a link of .newsrc -> .oldnewsrc */
X		if ((fp_backup = fopen (buf, "w")) != NULL) {
X			while (fgets (buf, sizeof (buf), fp_newsrc) != NULL) {
X				fputs (buf, fp_backup);
X			}
X			fclose (fp_backup);
X		}
X		fclose (fp_newsrc);
X	}
X}
X
X/*
X *  Read $HOME/.newsrc into my_group[]. my_group[] ints point to
X *  active[] entries.  Sub_only determines  whether to just read
X *  subscribed groups or all of them.
X */
X
Xvoid read_newsrc (sub_only)
X	int sub_only;		/* TRUE=subscribed groups only, FALSE=all groups */
X{
X	char c, *p, buf[8192];
X	char old_groups[LEN];
X	FILE *fp = (FILE *) 0;
X	FILE *fp_old = (FILE *) 0;
X	int i;
X	int remove_old_groups = FALSE;
X
X	group_top = 0;
X
Xreread_newsrc:
X
X	if ((fp = fopen (newsrc, "r")) == NULL) {	/* attempt to make a .newsrc */
X		if (auto_subscribe_groups ()) {		/* attempt to auto create newsrc */
X			goto reread_newsrc;
X		}	
X		for (i = 0; i < num_active; i++) {
X			if (group_top >= max_active) {
X				expand_active ();
X			}
X			my_group[group_top] = i;
X			active[i].flag = 0;
X			unread[group_top] = -1;
X			group_top++;
X		}
X		write_newsrc ();
X		return;
X	}
X
X	sprintf (old_groups, "%s/.newsrc.%d", homedir, process_id);
X
X	while (fgets (buf, sizeof buf, fp) != NULL) {
X		p = buf;
X		while (*p && *p != '\n' && *p != ' ' && *p != ':' && *p != '!')
X			p++;
X		c = *p;
X		*p++ = '\0';
X
X		if (c == '!' && sub_only)
X			continue;		/* unsubscribed */
X
X		if ((i = add_group (buf, FALSE)) < 0) {
X			if (! remove_old_groups) {
X				if ((fp_old = fopen (old_groups, "w")) == NULL) {
X					perror_message (txt_cannot_open, old_groups);
X				    continue;
X				}
X				remove_old_groups = TRUE;
X			}
X		    fprintf (fp_old, "%s\n", buf);
X		    continue;
X		}
X
X		if (c != '!')		/* if we're subscribed to it */
X			active[my_group[i]].flag |= SUBSCRIBED;
X
X		unread[i] = parse_unread (p, my_group[i]);
X	}
X	fclose (fp);
X
X	/*
X	 *  rewrite newsrc to get rid of any non-existant groups 
X	 */
X	if (remove_old_groups) {
X		fclose (fp_old);
X		rewrite_newsrc ();
X	}
X}
X
X/*
X *  Write a new newsrc from my_group[] and active[] mygroup if
X *  rewriting to get rid of groups that don't exist any longer. Used
X *  to a create a new .newsrc if there isn't one already, or when
X *  the newsrc is reset.
X */
X
Xvoid write_newsrc ()
X{
X	FILE *fp;
X	int i;
X
X	if ((fp = fopen (newsrc, "w")) == NULL) {
X		return;
X	}
X
X	wait_message (txt_creating_newsrc);
X
X	for (i=0 ; i < num_active ; i++) {
X		fprintf (fp, "%s! \n", active[i].name);
X	}
X
X	fclose (fp);
X}
X
X/*
X *  Rewrite newsrc to get rid of groups that don't exist any longer.
X */
X
Xvoid rewrite_newsrc ()
X{
X	char buf[8192], old[LEN];
X	char old_groups[LEN];
X	FILE *fp, *fp_old, *fp_new;
X	int found_old_group, len;	
X
X	sprintf (old_groups, "%s/.newsrc.%d", homedir, process_id);
X
X	if ((fp = fopen (newsrc, "r")) == NULL)
X		goto removed_old_groups_done;
X
X	if ((fp_old = fopen (old_groups, "r")) == NULL)
X		goto removed_old_groups_done;
X
X	if ((fp_new = fopen (newnewsrc, "w")) == NULL)
X		goto removed_old_groups_done;
X
X	while (fgets (buf, sizeof buf, fp) != NULL) {			/* read group from newsrc */
X		rewind (fp_old);
X		found_old_group = FALSE;	
X		while (fgets (old, sizeof old, fp_old) != NULL) {	/* read group from oldgroups */
X			len = strlen (old)-1;
X			if ((buf[len] == ':' || buf[len] == '!') &&
X				strncmp (buf, old, len) == 0) {
X				old[len] = '\0';
X				sprintf (msg, txt_deleting_from_newsrc, old);
X				wait_message (msg);
X				if (cmd_line) {
X					wait_message ("\n");
X				}	
X				found_old_group = TRUE;	
X			}
X		}
X		if (! found_old_group) {
X			fprintf (fp_new, "%s", buf);
X		}
X	}
X	
X	fclose (fp);
X	fclose (fp_old);
X	fclose (fp_new);
X
X	rename_file (newnewsrc, newsrc);
X
Xremoved_old_groups_done:
X	unlink (old_groups);
X}
X
X/*
X *  Load the sequencer rang lists and mark arts[] according to the
X *  .newsrc info for a particular group.  i.e.  rec.arts.comics: 1-94,97
X */
X
Xvoid read_newsrc_line (group)
X	char *group;
X{
X	FILE *fp;
X	char buf[8192];
X	char *p;
X
X	if ((fp = fopen (newsrc, "r")) == NULL)
X		return;
X
X	while (fgets (buf, sizeof buf, fp) != NULL) {
X		p = buf;
X		while (*p && *p != '\n' && *p != ' ' && *p != ':' && *p != '!')
X			p++;
X		*p++ = '\0';
X		if (strcmp (buf, group) != 0)
X			continue;
X		parse_seq (p);
X		break;
X	}
X
X	fclose (fp);
X}
X
X/*
X *  For our current group, update the sequencer information in .newsrc
X */
X
Xvoid update_newsrc (group, groupnum, mark_unread)
X	char *group;
X	int groupnum;			/* index into active[] for this group */
X	int mark_unread;
X{
X	FILE *fp;
X	FILE *newfp;
X	char buf[8192];
X	char *p;
X	char c;
X
X	if ((newfp = fopen (newnewsrc, "w")) == NULL) {
X		goto update_done;
X	}
X
X	if ((fp = fopen (newsrc, "r")) != NULL) {
X		while (fgets (buf, sizeof buf, fp) != NULL) {
X			for (p = buf; *p; p++)
X				if (*p == '\n') {
X					*p = '\0';
X					break;
X				}
X
X			p = buf;
X			while (*p && *p != ' ' && *p != ':' && *p != '!')
X					p++;
X			c = *p;
X			if (c != '\0')
X				*p++ = '\0';
X
X			if (c != '!' && c != ' ')
X				c = ':';
X
X			if (strcmp (buf, group) == 0) {
X				if (mark_unread) {
X					fprintf (newfp, "%s%c\n", buf, c);
X				} else {
X					fprintf (newfp, "%s%c ", buf, c);
X					print_seq (newfp, groupnum);
X					fprintf (newfp, "\n");
X				}
X			} else
X				fprintf (newfp, "%s%c%s\n", buf, c, p);
X		}
X		fclose (fp);
X	}
X
X	fclose (newfp);
X	rename_file (newnewsrc, newsrc);
X
Xupdate_done:
X	;
X}
X
X/*
X *  Subscribe/unsubscribe to a group in .newsrc.  ch should either be
X *  '!' to unsubscribe or ':' to subscribe.  num is the group's index
X *  in active[].
X */
X
Xvoid subscribe (group, ch, num, out_seq)
X	char *group;
X	char ch;
X	int num;
X	int out_seq;				/* output sequencer info? */
X{
X	FILE *fp;
X	FILE *newfp;
X	char buf[8192];
X	char *p;
X	char c;
X	int gotit = FALSE;
X
X	if (ch == '!')
X		active[num].flag &= ~SUBSCRIBED;
X	else
X		active[num].flag |= SUBSCRIBED;
X
X	if ((newfp = fopen (newnewsrc, "w")) == NULL)
X		goto subscribe_done;
X
X	if ((fp = fopen (newsrc, "r")) != NULL) {
X		while (fgets (buf, sizeof buf, fp) != NULL) {
X			if (strncmp ("options ", buf, 8) == 0) {
X				fprintf (newfp, buf);
X			} else {
X				for (p = buf; *p; p++) {
X					if (*p == '\n') {
X						*p = '\0';
X						break;
X					}
X				}	
X
X				p = buf;
X				while (*p && *p != ' ' && *p != ':' && *p != '!')
X						p++;
X				c = *p;
X				if (c != '\0')
X					*p++ = '\0';
X
X				if (c != '!')
X					c = ':';
X
X				if (strcmp (buf, group) == 0) {
X					fprintf (newfp, "%s%c%s\n", buf, ch, p);
X					gotit = TRUE;
X				} else {
X					fprintf (newfp, "%s%c%s\n", buf, c, p);
X				}
X			}
X		}
X		fclose (fp);
X	}
X
X	if (! gotit) {
X		if (out_seq) {
X			fprintf (newfp, "%s%c ", group, ch);
X			print_seq (newfp, num);
X			fprintf (newfp, "\n");
X		} else
X			fprintf (newfp, "%s%c\n", group, ch);
X	}
X
X	fclose (newfp);
X	rename_file (newnewsrc, newsrc);
X
Xsubscribe_done:
X	;
X}
X
X
Xvoid reset_newsrc ()
X{
X	FILE *fp;
X	FILE *newfp;
X	char buf[8192];
X	char *p;
X	char c;
X	int i;
X
X	if ((newfp = fopen (newnewsrc, "w")) == NULL)
X		goto update_done;
X
X	if ((fp = fopen (newsrc, "r")) != NULL) {
X		while (fgets (buf, sizeof (buf), fp) != NULL) {
X			for (p = buf; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X
X			p = buf;
X			while (*p && *p != ' ' && *p != ':' && *p != '!')
X					p++;
X			c = *p;
X			if (c != '\0')
X				*p++ = '\0';
X
X			if (c != '!')
X				c = ':';
X
X			fprintf (newfp, "%s%c\n", buf, c);
X		}
X		fclose (fp);
X	}
X
X	fclose (newfp);
X	rename_file (newnewsrc, newsrc);
X
Xupdate_done:
X	for (i = 0; i < group_top; i++)
X		unread[i] = -1;
X}
X
X
Xvoid delete_group (group)
X	char *group;
X{
X	FILE *fp;
X	FILE *newfp;
X	char buf[8192];
X	char *p;
X	char c;
X	int gotit = FALSE;
X	FILE *del;
X
X	if ((newfp = fopen (newnewsrc, "w")) == NULL)
X		goto del_done;
X
X	if ((del = fopen (delgroups, "a+")) == NULL)
X		goto del_done;
X
X	if ((fp = fopen (newsrc, "r")) != NULL) {
X		while (fgets (buf, sizeof (buf), fp) != NULL) {
X			for (p = buf; *p && *p != '\n'; p++)
X				continue;
X			*p = '\0';
X
X			p = buf;
X			while (*p && *p != ' ' && *p != ':' && *p != '!')
X					p++;
X			c = *p;
X			if (c != '\0')
X				*p++ = '\0';
X
X			if (c != '!')
X				c = ':';
X
X			if (strcmp (buf, group) == 0) {
X				fprintf (del, "%s%c%s\n", buf, c, p);
X				gotit = TRUE;
X			} else
X				fprintf (newfp, "%s%c%s\n", buf, c, p);
X		}
X		fclose (fp);
X	}
X
X	fclose (newfp);
X
X	if (! gotit)
X		fprintf (del, "%s! \n", group);
X
X	fclose (del);
X	rename_file (newnewsrc, newsrc);
X
Xdel_done:
X	;
X}
X
X
Xint undel_group ()
X{
X	FILE *del;
X	FILE *newfp;
X	FILE *fp;
X	char buf[2][8192];
X	char *p;
X	int which = 0;
X	long h;
X	extern int cur_groupnum;
X	int i, j;
X	char c;
X
X	if ((del = fopen(delgroups, "r")) == NULL) {
X		return FALSE;
X	}
X
X	unlink(delgroups);
X	
X	if ((newfp = fopen(delgroups, "w")) == NULL) {
X		return FALSE;
X	}
X
X	buf[0][0] = '\0';
X	buf[1][0] = '\0';
X
X	while (fgets(buf[which], sizeof (buf[which]), del) != NULL) {
X		which = !which;
X		if (*buf[which])
X			fputs(buf[which], newfp);
X	}
X
X	fclose(del);
X	fclose(newfp);
X	which = !which;
X
X	if (!*buf[which]) {
X		return FALSE;
X	}
X
X	for (p = buf[which]; *p && *p != '\n'; p++)
X		continue;
X	*p = '\0';
X
X	p = buf[which];
X	while (*p && *p != ' ' && *p != ':' && *p != '!')
X		p++;
X	c = *p;
X	if (c != '\0')
X		*p++ = '\0';
X
X	if (c != '!')
X		c = ':';
X
X	h = hash_groupname (buf[which]);
X
X	for (i = group_hash[h]; i >= 0; i = active[i].next) {
X		if (strcmp(buf[which], active[i].name) == 0) {
X			for (j = 0; j < group_top; j++)
X				if (my_group[j] == i) {
X					return j;
X				}
X
X			active[i].flag &= ~UNSUBSCRIBED;   /* mark that we got it */
X			if (c != '!')
X				active[i].flag |= SUBSCRIBED;
X
X			if (group_top >= max_active)
X				expand_active ();
X			group_top++;
X			for (j = group_top; j > cur_groupnum; j--) {
X				my_group[j] = my_group[j-1];
X				unread[j] = unread[j-1];
X			}
X			my_group[cur_groupnum] = i;
X			unread[cur_groupnum] = parse_unread(p, i);
X
X			if ((fp = fopen(newsrc, "r")) == NULL) {
X				return FALSE;
X			}
X			if ((newfp = fopen(newnewsrc, "w")) == NULL) {
X				fclose(fp);
X				return FALSE;
X			}
X			i = 0;
X			while (fgets(buf[!which], sizeof (buf[!which]), fp) != NULL) {
X				for (p = buf[!which]; *p && *p != '\n'; p++)
X					continue;
X				*p = '\0';
X
X				p = buf[!which];
X				while (*p && *p!=' ' && *p != ':' && *p != '!')
X					p++;
X				c = *p;
X				if (c != '\0')
X					*p++ = '\0';
X
X				if (c != '!')
X					c = ':';
X
X				while (i < cur_groupnum) {
X					if (strcmp(buf[!which],
X					  active[my_group[i]].name) == 0) {
X						fprintf(newfp, "%s%c%s\n",
X							buf[!which], c, p);
X						goto foo_cont;
X					}
X					i++;
X				}
X				fprintf(newfp, "%s%c%s\n", buf[which], c, p);
X				fprintf(newfp, "%s%c%s\n", buf[!which], c, p);
X				break;
Xfoo_cont:;
X			}
X
X			while (fgets (buf[!which], sizeof (buf[!which]), fp) != NULL)
X				fputs (buf[!which], newfp);
X
X			fclose (newfp);
X			fclose (fp);
X			rename_file (newnewsrc, newsrc);
X			return TRUE;
X		}
X	}
X	return FALSE;
X}
X
X
Xvoid mark_group_read (group, groupnum)
X	char *group;
X	int groupnum;			/* index into active[] for this group */
X{
X	FILE *fp;
X	FILE *newfp;
X	char buf[8192];
X	char *p;
X	char c;
X
X	if (active[groupnum].max < 2)
X		return;
X
X	if ((newfp = fopen (newnewsrc, "w")) == NULL)
X		goto mark_group_read_done;
X
X	if ((fp = fopen (newsrc, "r")) != NULL) {
X		while (fgets(buf, sizeof (buf), fp) != NULL) {
X			for (p = buf; *p; p++)
X				if (*p == '\n') {
X					*p = '\0';
X					break;
X				}
X
X			p = buf;
X			while (*p && *p != ' ' && *p != ':' && *p != '!')
X					p++;
X			c = *p;
X			if (c != '\0')
X				*p++ = '\0';
X
X			if (c != '!')
X				c = ':';
X
X			if (strcmp (buf, group) == 0) {
X				fprintf (newfp, "%s%c 1-%ld\n", buf, c, active[groupnum].max);
X			} else
X				fprintf(newfp, "%s%c%s\n", buf, c, p);
X		}
X		fclose (fp);
X	}
X
X	fclose (newfp);
X	rename_file (newnewsrc, newsrc);
X
Xmark_group_read_done:
X	;
X}
X
X
Xvoid parse_seq(s)
X	char *s;
X{
X	long low, high;
X	int i;
X
X	while (*s) {
X		while (*s && (*s < '0' || *s > '9'))
X			s++;
X
X		if (*s && *s >= '0' && *s <= '9') {
X			low = (long) atol (s);
X			while (*s && *s >= '0' && *s <= '9')
X				s++;
X			if (*s == '-') {
X				s++;
X				high = (long) atol (s);
X				while (*s && *s >= '0' && *s <= '9')
X					s++;
X			}  else
X				high = low;
X
X			for (i = 0; i < top; i++)
X				if (arts[i].artnum >= low && arts[i].artnum <= high)
X					arts[i].unread = ART_READ;
X		}
X	}
X}
X
X/*
X *  Read the first range from the .newsrc sequencer information.
X *  If the top of the first range is higher than what the active
X *  file claims is the bottom, use it as the new bottom instead.
X */
X
Xint parse_unread (s, groupnum)
X	char *s;
X	int groupnum;			/* index for group in active[] */
X{
X	long low, high;
X	long last_high;
X	int sum = 0;
X	int gotone = FALSE;
X	int n;
X
X	high = 0;
X
X	if (*s) {
X		while (*s && (*s < '0' || *s > '9')) {
X			s++;
X		}	
X
X		if (*s && *s >= '0' && *s <= '9') {
X			low = (long) atol (s);
X			while (*s && *s >= '0' && *s <= '9')
X				s++;
X			if (*s == '-') {
X				s++;
X				high = (long) atol (s);
X				while (*s && *s >= '0' && *s <= '9')
X					s++;
X			}  else
X				high = low;
X			gotone = TRUE;
X		}
X	}
X
X	/* Note that in the active file min will be one greater than max
X	 * when there are no articles in the spool directory. ie., it is
X 	 * always true that "max - min + 1 = article count (including
X 	 * expired articles)"
X 	 */
X
X	if (high < active[groupnum].min - 1)
X		high = active[groupnum].min - 1;
X
X	while (*s) {
X		last_high = high;
X
X		while (*s && (*s < '0' || *s > '9'))
X			s++;
X
X		if (*s && *s >= '0' && *s <= '9') {
X			low = (long) atol (s);
X			while (*s && *s >= '0' && *s <= '9')
X				s++;
X			if (*s == '-') {
X				s++;
X				high = (long) atol (s);
X				while (*s && *s >= '0' && *s <= '9')
X					s++;
X			}  else
X				high = low;
X
X			if (low > last_high)	/* otherwise seq out of order */
X				sum += (low - last_high) - 1;
X		}
X	}
X
X	if (gotone) {
X		if (active[groupnum].max > high)
X			sum += active[groupnum].max - high;
X		return sum;
X	}
X
X	n = (int) (active[groupnum].max - active[groupnum].min) + 1;
X	
X	if (n < 0)
X		return -1;
X	else
X		return (n);
X}
X
X
Xint get_line_unread(group, groupnum)
X	char *group;
X	int groupnum;				/* index for group in active[] */
X{
X	FILE *fp;
X	char buf[8192];
X	char *p;
X	int ret = -1;
X
X	if ((fp = fopen(newsrc, "r")) == NULL)
X		return -1;
X
X	while (fgets(buf, sizeof (buf), fp) != NULL) {
X		p = buf;
X		while (*p && *p != '\n' && *p != ' ' && *p != ':' && *p != '!')
X			p++;
X		*p++ = '\0';
X		
X		if (strcmp (buf, group) != 0)
X			continue;
X			
X		ret = parse_unread (p, groupnum);
X		break;
X	}
X
X	fclose (fp);
X	return ret;
X}
X
X
Xvoid print_seq (fp, groupnum)
X	FILE *fp;
X	int groupnum;			/* index into active[] for this group */
X{
X	long int artnum, last_read, artmax;
X	int i;
X	int flag = FALSE;
X	
X	assert(top >= 0);
X
X  	/*
X  	 *  sort into the same order as in the spool area for writing
X  	 *  read article numbers to ~/.newsrc
X  	 */
X 	if (top > 0)
X 		qsort ((char *) arts, top, sizeof (struct article_t), artnum_comp);
X  
X 	/*
X 	 * Note that killed and expired articles do not appear in arts[].
X 	 * So, even if top is 0 there may be sequencer info to output.
X	 */
X 	if (top > 0 && arts[top-1].artnum > active[groupnum].max)
X 		artmax = arts[top-1].artnum;
X 	else
X 		artmax = active[groupnum].max;
X 	for (artnum=1, i=0; artnum <= artmax; ++artnum, ++i) {
X 		assert(i<=top);
X 		if (i==top || arts[i].unread == ART_READ || artnum != arts[i].artnum) {
X  			if (flag)
X  				fprintf(fp, ",");
X  			else
X  				flag = TRUE;
X 			fprintf (fp, "%ld", artnum);
X 
X 			while (i < top && arts[i].unread == ART_READ)
X 				++i;
X 
X 			last_read = (i<top ? arts[i].artnum - 1 : artmax);
X 
X 			if (last_read != artnum) {
X 				fprintf(fp, "-%ld", last_read);
X  			}
X
X 			assert(i <= top);
X 			if (i == top)
X 				break;
X 			artnum = arts[i].artnum;
X  		}
X  	}
X  
X  	fflush (fp);
X 	if (top == 0)
X 		return;
X
X	/*
X	 *  resort into required sort order
X	 */
X	switch (sort_art_type) {
X		case SORT_BY_NOTHING:		/* already sorted above */
X			break;
X		case SORT_BY_SUBJ_DESCEND:
X		case SORT_BY_SUBJ_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), subj_comp);
X			break;
X		case SORT_BY_FROM_DESCEND:
X		case SORT_BY_FROM_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), from_comp);
X			break;
X		case SORT_BY_DATE_DESCEND:
X		case SORT_BY_DATE_ASCEND:
X			qsort ((char *) arts, top, sizeof (struct article_t), date_comp);
X			break;
X	}
X}
X
X/*
X *  rewrite .newsrc and position group at specifed position
X */
X
Xint pos_group_in_newsrc (group, pos)
X	char *group;
X	int pos;
X{
X	char sub[1024];
X	char unsub[1024];
X	char buf[1024];
X	char newsgroup[1024];
X	extern int cur_groupnum;
X	FILE *fp_in, *fp_out;
X	FILE *fp_sub, *fp_unsub;
X	int repositioned = FALSE;
X	int subscribed_pos = 1;
X	int group_len;
X	int option_line = FALSE;
X	int ret_code = FALSE;
X
X	if ((fp_in = fopen (newsrc, "r")) == NULL) {
X		goto rewrite_group_done;
X	}
X	if ((fp_out = fopen (newnewsrc, "w")) == NULL) {
X		goto rewrite_group_done;
X	}
X
X	sprintf (sub, "/tmp/.subrc.%d", process_id);
X	sprintf (unsub, "/tmp/.unsubrc.%d", process_id);
X
X	if ((fp_sub = fopen (sub, "w")) == NULL) {
X		goto rewrite_group_done;
X	}
X	if ((fp_unsub = fopen (unsub, "w")) == NULL) {
X		goto rewrite_group_done;
X	}
X
X	/*
X	 *  split newsrc into subscribed and unsubscribed to files
X	 */
X	group_len = strlen (group);
X
X	while (fgets (buf, sizeof (buf), fp_in) != NULL) {
X		if (strncmp (group, buf, group_len) == 0 && buf[group_len] == ':') {
X			my_strncpy (newsgroup, buf, sizeof (newsgroup));
X		} else if (strchr (buf, ':') != NULL) {
X			fprintf (fp_sub, "%s", buf);
X		} else if (strchr (buf, '!') != NULL) {
X			fprintf (fp_unsub, "%s", buf);
X		} else {	/* options line at beginning of .newsrc */
X			fprintf (fp_sub, "%s", buf);
X			option_line = TRUE;
X		}
X	}
X
X	fclose (fp_in);
X	fclose (fp_sub);
X	fclose (fp_unsub);
X
X	/*
X	 *  write subscribed groups & position group to newnewsrc
X	 */
X	if ((fp_sub = fopen (sub, "r")) == NULL) {
X		unlink (sub);
X		goto rewrite_group_done;
X	}
X	while (fgets (buf, sizeof (buf), fp_sub) != NULL) {
X		if (option_line) {
X			if (strchr (buf, ':') == NULL && strchr (buf, '!') == NULL) {
X				fprintf (fp_out, "%s", buf);
X				continue;
X			} else {
X				option_line = FALSE;
X			}
X		}
X
X		if (pos == subscribed_pos) {
X			fprintf (fp_out, "%s\n", newsgroup);
X			repositioned = TRUE;
X		}
X		
X		fprintf (fp_out, "%s", buf);
X
X		subscribed_pos++;
X	}
X	if (! repositioned) {
X		fprintf (fp_out, "%s\n", newsgroup);
X		repositioned = TRUE;
X	}
X	
X	fclose (fp_sub);
X 	unlink (sub);
X
X	/*
X	 *  write unsubscribed groups to newnewsrc
X	 */
X	if ((fp_unsub = fopen (unsub, "r")) == NULL) {
X		unlink (unsub);
X		goto rewrite_group_done;
X	}
X	while (fgets (buf, sizeof (buf), fp_unsub) != NULL) {
X		fprintf (fp_out, "%s", buf);
X	}
X
X	fclose (fp_unsub);
X	unlink (unsub);
X	fclose (fp_out);
X
X	if (repositioned) {
X		cur_groupnum = pos;
X		rename_file (newnewsrc, newsrc);
X		ret_code = TRUE;
X	}
X
Xrewrite_group_done:
X	return ret_code;
X}
X
X/*
X *  mark all orther Xref: articles as read when one article read
X *  Xref: sitename newsgroup:artnum newsgroup:artnum [newsgroup:artnum ...]
X */
X 
Xvoid mark_all_xref_read (xref_line)
X	char *xref_line; 
X{
X/*
X	char group[LEN];
X	long artnum;
X*/	
X	if (xref_line == (char *) 0) {
X		return;
X	}
X
X	/*
X	 *  check sitename macthes nodename of current machine
X	 */
X
X	/*
X	 *  tokenize each pair and update that newsgroup if it
X	 *  is in users my_group[].
X	 */
X	 
X}
END_OF_FILE
  if test 20406 -ne `wc -c <'newsrc.c'`; then
    echo shar: \"'newsrc.c'\" unpacked with wrong size!
  fi
  # end of 'newsrc.c'
fi
if test -f 'tin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tin.h'\"
else
  echo shar: Extracting \"'tin.h'\" \(13510 characters\)
  sed "s/^X//" >'tin.h' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : tin.h
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 10-05-92
X *  Notes     : #include files, #defines & struct's
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	<stdio.h>
X
X#include	<signal.h>
X#include	<errno.h>
X#include	<sys/types.h>
X#include	<sys/stat.h>
X#include	<pwd.h>
X#include	<ctype.h>
X#include	<time.h>
X#ifndef apollo
X#	include	<unistd.h>
X#endif
X
X#ifdef BSD
X#	include	<strings.h>
X#	include	<fcntl.h>
X#else
X/*
X#	ifndef apollo
X#		include	<stdlib.h>
X#	endif
X#	include	<string.h>
X*/
X#endif
X
X#ifndef MINIX
X#	include <sys/ioctl.h>
X#endif
X
X#ifdef M_XENIX
X#	include	<prototypes.h>
X#endif
X
X#ifdef SVR4
X#	include <locale.h>
X#endif
X
X#if !defined(BSD) && !defined(sinix) && !defined(RS6000)
X#	include	<sys/utsname.h>
X#endif
X
X/*
X * Needed for resizing under an xterm
X */
X
X#if defined(SIGWINCH)
X#	if !defined(TIOCGWINSZ) && !defined(TIOCGSIZE)
X#		if !defined(sinix) && !defined(nsc)
X#			include <sys/stream.h>
X#			ifdef PTX
X#				include <termio.h>
X#			else
X#				ifndef apollo
X#					include <sys/ptem.h>
X#					include <sys/tty.h>
X#				endif
X#				if !defined(SCO_UNIX) && !defined(SVR4) && !defined(apollo)
X#					include <sys/pty.h>
X#				endif
X#			endif
X#		endif
X#	endif
X#endif
X
X/*
X * Setup support for reading from CD-ROM
X */
X
X#ifdef CDROM_ONLY
X#	define CDROM_ABLE
X#endif
X 
X#ifdef CDROM_ABLE
X#	define XSPOOLDIR
X#	define NNTP_ABLE
X#	undef NNTP_ONLY
X#	undef NNTP_INEWS
X#endif
X
X/*
X * Setup support for reading from NNTP
X */
X 
X#if defined(NNTP_ABLE) || defined(NNTP_ONLY)
X#	ifndef NNTP_ABLE
X#		define	NNTP_ABLE
X#	endif
X#	ifndef NNTP_INEWS
X#		define	NNTP_INEWS
X#	endif
X#endif
X
X/*
X * Index file daemon version of tin. Will create/update index files from cron
X * on NNTP server machine so clients can retreive index file with NNTP XINDEX
X * command from server. Also can be used on machines that just want one copy
X * of all the index files in one place. In this case the normal tin must have
X * access to the index directory (-I dir option) or be setuid news.
X */
X 
X#ifdef INDEX_DAEMON
X#	undef NNTP_ABLE
X#	undef NNTP_ONLY
X#	undef NNTP_INEWS
X#endif
X
X/*
X * Determine signal return type
X */
X 
X#ifdef __GNUC__
Xtypedef void sigtype_t;
X#else	
X#	if defined(sony)
Xtypedef int sigtype_t;
X#	else
X#		if __STDC__ || defined(sinix) || defined(sun) || \
X		   defined(ultrix) || defined(atthcx) || defined(PTX)
Xtypedef void sigtype_t;
X#		else
Xtypedef int sigtype_t;
X#		endif
X#	endif
X#endif
X
X/*
X * Specify News spool & control directories
X */
X 
X#ifndef SPOOLDIR
X#	define		SPOOLDIR	"/usr/spool/news"
X#endif
X#ifndef LIBDIR
X#	define		LIBDIR		"/usr/lib/news"
X#endif
X#ifndef INEWSDIR
X#	define		INEWSDIR	LIBDIR
X#endif
X
X/*
X * Determine machine configuration for external programs & directories
X */
X
X#ifdef BSD
X#	ifdef _SEQUENT_
X#		define		memcmp(s1, s2, n)	bcmp(s2, s1, n)
X#	endif
X#	define		strchr(str, ch)	index(str, ch)
X#	define		DEFAULT_SHELL	"/bin/csh"
X#	define		DEFAULT_MAILER	"/bin/mail"
X#	define		DEFAULT_EDITOR	"/usr/ucb/vi"
X#	define		DEFAULT_PRINTER	"/usr/ucb/lpr"
X#	define		DEFAULT_SUM	"sum"
X#	ifdef DGUX
X#		define		DEFAULT_MAILBOX	"/usr/mail"
X#		define		POSIX_JOB_CONTROL
X#		define		USE_INVERSE_HACK
X#	else
X#		define		DEFAULT_MAILBOX	"/usr/spool/mail"
X#	endif
X#	ifndef USE_LONG_FILENAMES
X#		define USE_LONG_FILENAMES
X#	endif
X#else
X#	ifdef M_XENIX
X#		define		DEFAULT_EDITOR	"/bin/vi"
X#		define		DEFAULT_MAILER	"/usr/bin/mail"
X#		define		DEFAULT_MAILBOX	"/usr/spool/mail"
X#	endif
X#	if defined(NCR) || defined(atthcx) || defined(HPUX)
X#		define		DEFAULT_MAILER	"/usr/bin/mailx"
X#	endif
X#	ifdef PTX
X#		define		DEFAULT_MAILER	"/usr/bin/mailx"
X#		ifndef USE_LONG_FILENAMES
X#			define	USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef RS6000
X#		define		DEFAULT_MAILER	"/usr/bin/mail"
X#		define		DEFAULT_PRINTER	"/bin/lp"
X#	endif
X#	ifdef sinix
X#		define		DEFAULT_MAILER	"/bin/rmail"
X#		define		DEFAULT_PRINTER	"/bin/lpr"
X#		ifndef USE_LONG_FILENAMES
X#			define USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef SVR4
X#		ifndef USE_LONG_FILENAMES
X#			define	USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef UNIXPC
X#		define		DEFAULT_MAILER	"/bin/rmail"
X#	endif
X#	ifndef DEFAULT_SHELL
X#		define		DEFAULT_SHELL	"/bin/sh"
X#	endif
X#	ifndef DEFAULT_EDITOR
X#		define		DEFAULT_EDITOR	"/usr/bin/vi"
X#	endif
X#	ifndef DEFAULT_MAILBOX
X#		define		DEFAULT_MAILBOX	"/usr/mail"
X#	endif
X#	ifndef DEFAULT_MAILER
X#		define		DEFAULT_MAILER	"/bin/mail"
X#	endif
X#	ifndef DEFAULT_PRINTER
X#		define		DEFAULT_PRINTER	"/usr/bin/lp"
X#	endif
X#	define		DEFAULT_SUM		"sum -r"
X#endif
X
X#ifdef USE_LONG_FILENAMES
X#	define		LONG_PATH_PART	"part"
X#	define		LONG_PATH_PATCH	"patch"
X#else
X#	define		LONG_PATH_PART	""
X#	define		LONG_PATH_PATCH	"p"
X#endif
X
X/*
X * Useful for logging user usage
X */
X 
X#ifdef LOG_USER
X#	define		LOG_USER_FILE	"/tmp/.tin_log" 
X#endif
X
X/*
X * Should active file be rereaf for new news & if so how often
X */
X 
X#ifndef NO_RESYNC_ACTIVE_FILE
X#	ifndef RESYNC_ACTIVE_SECS
X#		define	RESYNC_ACTIVE_SECS	300	/* reread active every n secs */
X#	endif
X#endif
X
X/*
X * Initial sizes of internal arrays for small (<4MB) & large memory machines
X */
X 
X#ifdef SMALL_MEMORY_MACHINE
X#	define		DEFAULT_ACTIVE_NUM	1800	
X#	define		DEFAULT_ARTICLE_NUM	400	
X#	define		DEFAULT_KILL_NUM	10	
X#	define		DEFAULT_SAVE_NUM	10	
X#else
X#	define		DEFAULT_ACTIVE_NUM	1800	
X#	define		DEFAULT_ARTICLE_NUM	1200	
X#	define		DEFAULT_KILL_NUM	30	
X#	define		DEFAULT_SAVE_NUM	30	
X#endif
X
X#define		RCDIR			".tin"
X#define		RCFILE			"tinrc"
X#define		INDEXDIR		".index"
X#define		KILLFILE		"kill"
X#define		POSTFILE		"posted"
X#define		UNTHREADFILE	"unthread"
X#define		DEFAULT_MAILDIR	"Mail"
X
X#define BUG_REPORT_ADDRESS	"iain%anl433.uucp@Germany.EU.net"
X
X#ifdef TRUE
X#	undef TRUE
X#endif
X#define		TRUE		1
X
X#ifdef FALSE
X#	undef FALSE
X#endif
X#define		FALSE		0
X
X#define		LEN				1024
X#define		PATH_LEN			256
X#define		HEADER_LEN			1024
X#define		MODULO_COUNT_NUM		5
X#define		TABLE_SIZE			1409
X#define		MAX_PAGES			1000
X#define		ctrl(c)				((c) & 0x1F)
X
X#ifndef DEFAULT_COMMENT
X#	define		DEFAULT_COMMENT	": "	/* used when by follow-ups & replys */
X#endif
X#ifndef UNREAD_ART_MARK
X#	define		UNREAD_ART_MARK	'+'	/* used to show that an art is unread */
X#endif
X#ifndef RETURN_ART_MARK
X#	define		RETURN_ART_MARK	'-'	/* used to show that an art will return */
X#endif
X#ifndef HOT_ART_MARK
X#	define		HOT_ART_MARK	'*'	/* used to show that an art was auto selected */
X#endif
X#ifndef READ_ART_MARK
X#	define		READ_ART_MARK	' '	/* used to show that an art was not read or seen  */
X#endif
X
X#ifdef USE_INVERSE_HACK
X#	define		SELECT_MISC_COLS	21
X#	define		BLANK_GROUP_COLS	2
X#	define		BLANK_PAGE_COLS		2
X#else
X#	define		SELECT_MISC_COLS	21
X#	define		BLANK_GROUP_COLS	0
X#	define		BLANK_PAGE_COLS		0
X#endif
X
X#define		SCREEN_READ_UNREAD		6		/* position for "  +" / "   " */
X#define		INDEX_TOP				2
X
X#ifdef NO_REGEX 
X#	define STR_MATCH(s1,s2)	(str_str (s1, s2, strlen (s2)) != 0)
X#else		
X#	define STR_MATCH(s1,pat)	(wildmat (s1, pat))
X#endif
X
X#define IGNORE_ART(i)	((arts[i].thread == ART_EXPIRED) || \
X			 (arts[i].killed && kill_level > 0))
X
X/*
X *  used by get_arrow_key()
X */
X
X#define		KEYMAP_UNKNOWN			0
X#define		KEYMAP_UP				1
X#define		KEYMAP_DOWN				2
X#define		KEYMAP_PAGE_UP			3
X#define		KEYMAP_PAGE_DOWN		4
X#define		KEYMAP_HOME				5
X#define		KEYMAP_END				6
X
X/*
X *  used by feed.c - feed_articles()
X */
X 
X#define		SELECT_LEVEL				1
X#define		GROUP_LEVEL				2
X#define		PAGE_LEVEL				3
X
X#define		FEED_MAIL				1
X#define		FEED_PIPE				2
X#define		FEED_PRINT				3
X#define		FEED_SAVE				4
X#define		FEED_XPOST				5
X
X/*
X *  used in art.c & rcfile.c
X */
X 
X#define		SORT_BY_NOTHING			0		/* sort types on arts[] array */
X#define		SORT_BY_SUBJ_DESCEND	1
X#define		SORT_BY_SUBJ_ASCEND		2
X#define		SORT_BY_FROM_DESCEND	3
X#define		SORT_BY_FROM_ASCEND		4
X#define		SORT_BY_DATE_DESCEND	5
X#define		SORT_BY_DATE_ASCEND		6
X
X#define		SHOW_FROM_NONE			0
X#define		SHOW_FROM_ADDR			1
X#define		SHOW_FROM_NAME			2
X#define		SHOW_FROM_BOTH			3
X
X/*
X *  used in help.c
X */
X
X#define		HELP_INFO				0
X#define		POST_INFO				1
X
X/*
X *  used in save.c
X */
X
X#define		CHECK_ANY_NEWS			0
X#define		START_ANY_NEWS			1
X#define		MAIL_ANY_NEWS			2
X#define		SAVE_ANY_NEWS			3
X
X/*
X *  used in help.c
X */
X
X#define		HEADER_TO				0
X#define		HEADER_SUBJECT			1
X
X/*
X *  used in page.c & post.c
X */
X
X#define		POSTED_NONE				0
X#define		POSTED_REDRAW			1
X#define		POSTED_OK				2
X
X/*
X *  Assertion verifier
X */
X
X#if __STDC__ && !defined(apollo)
X#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, #p); else
X#else
X#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, "p"); else
X#endif
X
X#define		ESC		27
X#if defined(BSD) || defined(MINIX) || defined(apollo)
X#	define		CR		'\r'
X#else
X#	define		CR		10
X#endif
X
X/*
X * return codes for change_rcfile ()
X */
X
X#define		NO_KILLING		0
X#define		KILLING			1
X
X/*
X *  art.thread
X */
X
X#define		ART_NORMAL		-1
X#define		ART_EXPIRED		-2
X
X/*
X *  art.unread
X */
X
X#define		ART_READ		0
X#define		ART_UNREAD		1
X#define		ART_WILL_RETURN	2
X
X/*
X * used by group_t & my_group[]
X */
X 
X#define		UNSUBSCRIBED	0x01	/* haven't put in my_group[] yet */
X#define		SUBSCRIBED		0x02	/* subscribed to */
X
X/*
X * kill_type used in struct kill_t
X */
X 
X#define KILL_SUBJ	1
X#define KILL_FROM	2
X#define KILL_BOTH	3
X
X/*
X * usedin group.c & page.c
X */
X 
X#define	ART_UNAVAILABLE	-1
X
X
X/*
X * used in feed.c & save.c
X */
X 
X#define POST_PROC_NONE			0
X#define POST_PROC_SHAR			1
X#define POST_PROC_UUDECODE		2
X#define POST_PROC_UUD_LST_ZOO	3
X#define POST_PROC_UUD_EXT_ZOO	4
X
X/*
X *  struct article_t - article header
X *
X *  article.artnum:
X *	article number in spool directory for group
X *
X *  article.thread:
X *	-1 initial default
X *	-2 means article has expired (wasn't found in file search
X *	of spool directory for the group)
X *	>=0 points to another arts[] (struct article_t)
X *
X *  article.inthread:
X *	FALSE for the first article in a thread, TRUE for all
X *	following articles in thread
X *
X *  article.unread:
X *	boolean, has this article been read or not
X *
X *  article.killed:
X *	boolean, has this article been killed
X *
X *  article.hot:
X *	boolean, has this article been auto-selected
X *
X *  article.tagged:
X *	count, has this article been tagged for saving (>0) or not (=0)
X *
X *  article.date
X *	date: line used for sorting articles by date order
X *
X *  article.archive:
X *	archive name used in *source* groups
X *
X *  article.part:
X *	part no. of archive
X *
X *  article.patch:
X *	patch no. of archive
X *
X */
X
Xstruct article_t {
X	long artnum;
X	char *subject;		/* Subject: line from mail header */
X	char *from;		/* From: line from mail header (address) */
X	char *name;		/* From: line from mail header (full name) */
X	int thread;
X	int inthread;
X	unsigned int unread:2;	/* 0 = read, 1 = unread, 2 = will return */
X	unsigned int killed:1;	/* 0 = not killed, 1 = killed */
X	unsigned int hot:1;	/* 0 = not hot, 1 = hot */
X	int tagged;		/* 0 = not tagged, >0 = tagged */
X	char date[16];		/* Date: line from mail header */
X	char *archive;		/* Archive-name: line from mail header */
X	char *part;		/* part no. of archive */
X	char *patch;		/* patch no. of archive */
X};
X
X/*
X *  struct attribute_t - configurable attributes on a per group basis
X */
X
Xstruct attribute_t {
X	char *server;			/* read group locally/via nntp server */
X	char *maildir;			/* mail dir if other than ~/Mail */
X	char *savedir;			/* save dir if other than ~/News */
X	char *sigfile;			/* sig file if other than ~/.Sig */
X	unsigned int read:1;		/* marked TRUE if group was entered during session */
X	unsigned int showall:1;		/* 0 = only unread, 1 = all */
X	unsigned int thread:1;		/* 0 = unthread, 1 = thread */
X	unsigned int sortby:4;		/* 0 = none, 1 = , 2 = , 3 = , 4 = , */
X	unsigned int author:4;		/* 0 = none, 1 = name, 2 = addr, 3 = both */
X	unsigned int autosave:1;	/* 0 = none, 1 = save */
X	unsigned int process:4;		/* 0 = none, 1 = shar, 2 = uudecode, 
X				  	   3 = uud & list zoo, 4 = uud & ext zoo*/
X};
X
X/*
X *  struct group_t - newsgroup info from active file
X */
X
Xstruct group_t {
X	char *name;
X	long max;
X	long min;
X	char moderated;
X	int next;			/* next active entry in hash chain */
X	int flag;
X	struct attribute_t attribute;	/* per group attributes */ 
X};
X
X/*
X *  used in hashstr.c
X */
X 
Xstruct hashnode {
X	char *s;						/* the string we're saving */
X	struct hashnode *next;			/* chain for spillover */
X};
X
X/*
X *  used in kill.c
X */
X 
Xstruct kill_t {
X	unsigned int kill_type:8;
X	unsigned int kill_how:8;	/* kill/auto select */
X	long kill_group;
X	char *kill_subj;
X	char *kill_from;
X};
X
Xstruct save_t {
X	char *subject;
X	char *dir;
X	char *file;
X	char *archive;
X	char *part;
X	char *patch;
X	int index;	
X	int saved;	
X	int is_mailbox;	
X};
X
Xstruct screen_t {
X	char *col;
X};
X
Xstruct posted_t {
X	char date[10];
X	char group[80];
X	char action;
X	char subj[120];
X};
X
Xstruct art_stat_t {
X	int total;	/* total article count */
X	int unread;	/* number of unread articles (does not include seen) arts */
X	int seen;	/* number of seen articles (ART_WILL_RETURN) */
X	int hot_total;	/* total hot count */
X	int hot_unread; /* hot and unread */
X	int hot_seen;	/* hot and seen */
X	char art_mark;	/* mark to use for this thread - not used for groups */
X};
X
Xstruct spooldir_t {
X	int state;
X	char *name;
X	char *comment;
X};
X
X/*
X *  function prototypes	& extern definitions	
X */ 
X
X#include	"patchlev.h"
X#include	"extern.h"
X#include	"proto.h"
END_OF_FILE
  if test 13510 -ne `wc -c <'tin.h'`; then
    echo shar: \"'tin.h'\" unpacked with wrong size!
  fi
  # end of 'tin.h'
fi
echo shar: End of archive 9 \(of 14\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
