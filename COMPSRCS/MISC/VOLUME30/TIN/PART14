Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i014:  tin - threaded full screen newsreader, Part14/14
Message-ID: <1992May20.173051.236@sparky.imd.sterling.com>
X-Md4-Signature: 54bb81c5eedeec6b90b74b63e4ec7cae
Date: Wed, 20 May 1992 17:30:51 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 14
Archive-name: tin/part14
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  FTP INSTALL.NNTP common.patch debug.c hashstr.c inews.c
#   patchlev.h prompt.c screen.c search.c wildmat.3 xindex.c xuser.c
# Wrapped by kent@sparky on Tue May 19 13:38:07 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 14)."'
if test -f 'FTP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FTP'\"
else
  echo shar: Extracting \"'FTP'\" \(2568 characters\)
  sed "s/^X//" >'FTP' <<'END_OF_FILE'
XThis document informs you how to get tin source & binaries in one of 3 ways.
X
X1) Via FTP.
X2) Source code via mail.
X3) Pre-compiled Binaries. 
X
X--------------------------------------------------------------------------------
X
X1) FTP sites that carry the latest version of tin are:
X  
X    ftp.Germany.EU.net  [192.76.144.129]  cd pub/news/tin
X    src.doc.ic.ac.uk    [146.169.2.1]     cd ??
X
XNOTE1: Both sites are in Europe (Germany & England respectively).
XNOTE2: There will be a small time lag before each of these sites makes
X       the newest version available as I post firstly to alt.sources
X
X--------------------------------------------------------------------------------
X
X2) For people that do not have FTP access I am willing to send a copy of the 
X   latest released version (or a beta version of the next patchlevel if so 
X   desired).
X
X2.1) I can handle the following media formats. Specify:
X    5.25 & 3.5 inch floppy disks.
X    0.25 (1/4) inch cartridge tapes (you supply it).
X    5.25 inch ISO Read/Write optical disks (you supply it).
X
X2.2) I can handle the following software formats. Specify:
X    Unix   *.tar *.tar.Z *.tar.z *.tar.zoo
X    Msdos  *.zoo *.zip formats 
X
X2.3) I make a small handling charge for this service as listed below:
X    Germany  15 Deustche Marks
X    England   5 Pounds Sterling
X    USA      10 Dollars 
X
XIf you find the above points 2.1 - 2.3 OK send money/cheque with a self-addressed
Xenvelope stating which media & software format you want to the following address:
X
X    Iain J. Lea
X    BrueckenStr. 12
X    8500 Nuernberg 90
X    Germany.
X
X    Phone. +49-911-331963 (home) +49-911-3089-407 (work) +49-911-3089-290 (FAX)
X    Email. iain%anl433.uucp@Germany.EU.net
X
X--------------------------------------------------------------------------------
X
X3) For people that are having problems compiling tin I am willing to send a 
X   copy of a pre-compiled binary for the following machines:
X
X    i386/486 + SCO Xenix 2.3
X    i386/486 + SCO Unix 3.2
X    i386/486 + ISC Unix 3.2 v3.0
X    SunSparc + SunOS 4.1
X    SonyMIPS + NewsOS 4.1
X    DecMIPS  + Ultrix 4.2
X    DG Avion + DG/UX 4.3
X    Apollo68xxx + DomainOS10.3
X    Siemens MX330 + Sinix v5.23
X    Siemens MX350i + Sinix v5.4
X
X    NOTE: Specify how you want tin to be compiled to access news:
X          1) local spool directory (specify path for newsspool & newslib)
X          2) local spool directory & via NNTP
X          3) via NNTP only
X          4) local spool directory & via news archived on CD-ROM
X    
XFor conditions & shipping read points 2.1 - 2.3 above. 
X
XEnjoy
X	Iain.
END_OF_FILE
  if test 2568 -ne `wc -c <'FTP'`; then
    echo shar: \"'FTP'\" unpacked with wrong size!
  fi
  # end of 'FTP'
fi
if test -f 'INSTALL.NNTP' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL.NNTP'\"
else
  echo shar: Extracting \"'INSTALL.NNTP'\" \(3160 characters\)
  sed "s/^X//" >'INSTALL.NNTP' <<'END_OF_FILE'
XThis document explains the install procedure for the supplied patch to the
XNNTP server nntpd & to the TIN newsreader to retrieve index files from the
XNNTP server. 
X
XNNTP server
X-----------
X1) Copy the following files to <nntp-source-dir>/server
X     cp xindex.c <nntp-source-dir>/server
X     cp xuser.c <nntp-source-dir>/server
X
X2) Copy the following files to <nntp-source-dir>
X     cp server.patch <nntp-source-dir>
X     cp common.patch <nntp-source-dir>
X
X3) Patch the files in <nntp-source-dir>/common & <nntp-source-dir>/server
X     cd <nntp-source-dir>
X     patch < common.patch
X     patch < server.patch
X
X4) Copy <nntp-source-dir>/common/conf.h.dist to <nntp-source-dir>/common/conf.h
X     cd <nntp-source-dir>/common
X     cp conf.h.dist conf.h
X
X5) Edit <nntp-source-dir>/common/conf.h to suit your sites needs. The XINDEX
X   & XUSER are #defined by default. You may need to change the path for
X   the #define SUBSCRIBTIONS. The default is /usr/lib/news/subscriptions.
X     cd <nntp-source-dir>/common
X     [vi|emacs] conf.h
X
X6) Recompile & install the NNTP server nntpd
X     cd  <nntp-source-dir>
X     make server
X     make install_server
X
XTIN client
X----------
X1) Edit tin Makefile to enable XINDEX & XUSER functionality.
X     cd <tin-dir>
X     [vi|emacs] Makefile
X     Add -DNNTP_XINDEX to CFLAGS if you want tin to retrieve index files 
X     from the server.
X     Add -DNNTP_XUSER to CFLAGS if you want tin to log the username to
X     the NNTP logfile.
X     Add -DNNTP_EXTS to CFLAGS if you want both NNTP_XINDEX & NNTP_XUSER
X     enabled.
X
X2) Recompile & install tin.
X     cd <tin-dir>
X     make <system>
X     make install
X
XTIN daemon (on NNTP server)
X---------------------------
X1) Edit tin Makefile to enable index daemon functionality.
X     cd <tin-dir>
X     [vi|emacs] Makefile
X     Add -DINDEX_DAEMON to CFLAGS to create a version of tin 'tind' to
X     create & update index files on the NNTP server.
X
X2) Compile & install tind.
X     cd <tin-dir>
X     make <system>
X     make install_daemon
X
X3) Add entry to crontab to start 'tind' index daemon every so often.
X     cd /usr/spool/cron/crontabs
X     [vi|emacs] root
X     Add following line to run tind every 30 minutes: 
X       0,30 * * * * su news -c '/usr/lib/news/tind'
X
XOK. If you have gotten this far you will have the following configuration:
X  o  tind will run every 30 minutes to update a central directory (usually
X     /usr/spool/news/.index) of tin index files for all groups in the active
X     file. The directory can be changed by 'tind -I dir' if so desired.
X
X  o  The NNTP server nntpd will service all requests for tin index files
X     from tin clients. It will do this by returning the contents of the
X     group index file in the index directory (ie. /usr/spool/news/.index/*)
X
X  o  The tin client will issue requests for index files to the NNTP server
X     therefore saving space on the client machine and ensuring that there
X     are only one copy of index files on the whole network.  Also clients
X     will not have to wait while index files are built locally as the index
X     daemon tind runs frequently on the news server.
X             
XEnjoy & happy newsreading
X
X  Iain
END_OF_FILE
  if test 3160 -ne `wc -c <'INSTALL.NNTP'`; then
    echo shar: \"'INSTALL.NNTP'\" unpacked with wrong size!
  fi
  # end of 'INSTALL.NNTP'
fi
if test -f 'common.patch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'common.patch'\"
else
  echo shar: Extracting \"'common.patch'\" \(2369 characters\)
  sed "s/^X//" >'common.patch' <<'END_OF_FILE'
XFiles common.old/Makefile and common/Makefile are identical
XFiles common.old/README and common/README are identical
XFiles common.old/README.HPUX and common/README.HPUX are identical
XFiles common.old/README.IRIX and common/README.IRIX are identical
XFiles common.old/README.LIB and common/README.LIB are identical
XFiles common.old/README.MTXNIU and common/README.MTXNIU are identical
XFiles common.old/README.SYSV and common/README.SYSV are identical
XFiles common.old/README.XENIX and common/README.XENIX are identical
XFiles common.old/clientlib.c and common/clientlib.c are identical
XFiles common.old/clientlib.h and common/clientlib.h are identical
XOnly in common: conf.h
Xdiff -rcs common.old/conf.h.dist common/conf.h.dist
X*** common.old/conf.h.dist	Wed May  6 09:01:11 1992
X--- common/conf.h.dist	Mon May  4 07:31:14 1992
X***************
X*** 7,12 ****
X--- 7,20 ----
X   * Compile time options.
X   */
X    
X+ /*
X+  * Extensions to NNTP RFC977 (I.Lea 07-03-92)
X+  */
X+ 
X+ #define XUSER			/* log clients username to nntp logfile */
X+ #define XINDEX			/* retieve tin index files from server */
X+ #define SUBSCRIPTIONS_FILE	"/usr/lib/news/subscriptions"
X+ 
X  
X  #undef	ALONE		/* True if we're running without inetd */
X  
XOnly in common: conf.h.dst.old
XOnly in common: conf.h.norisc
Xdiff -rcs common.old/nntp.h common/nntp.h
X*** common.old/nntp.h	Wed May  6 09:01:11 1992
X--- common/nntp.h	Tue Mar 10 08:52:12 1992
X***************
X*** 38,43 ****
X--- 38,46 ----
X  #define	OK_GOODBYE	205	/* Closing connection */
X  #define	OK_GROUP	211	/* Group selected */
X  #define	OK_GROUPS	215	/* Newsgroups follow */
X+ #ifdef XINDEX
X+ #define	OK_XINDEX	218	/* Group index file follows */
X+ #endif
X  #define	OK_ARTICLE	220	/* Article (head & body) follows */
X  #define	OK_HEAD		221	/* Head follows */
X  #define	OK_BODY		222	/* Body follows */
X***************
X*** 57,62 ****
X--- 60,68 ----
X  #define	ERR_GOODBYE	400	/* Have to hang up for some reason */
X  #define	ERR_NOGROUP	411	/* No such newsgroup */
X  #define	ERR_NCING	412	/* Not currently in newsgroup */
X+ #ifdef XINDEX
X+ #define	ERR_XINDEX	418	/* No index file for newsgroup */
X+ #endif
X  #define	ERR_NOCRNT	420	/* No current article selected */
X  #define	ERR_NONEXT	421	/* No next article in this group */
X  #define	ERR_NOPREV	422	/* No previous article in this group */
XFiles common.old/version.c and common/version.c are identical
END_OF_FILE
  if test 2369 -ne `wc -c <'common.patch'`; then
    echo shar: \"'common.patch'\" unpacked with wrong size!
  fi
  # end of 'common.patch'
fi
if test -f 'debug.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'debug.c'\"
else
  echo shar: Extracting \"'debug.c'\" \(4195 characters\)
  sed "s/^X//" >'debug.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : debug.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 10-05-92
X *  Notes     : debug routines
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include "tin.h"
X#include "nntplib.h"
X
Xint debug;
X
X/*
X *  nntp specific debug routines
X */
X 
Xvoid debug_nntp (func, line)
X	char *func;	
X	char *line;	
X{
X#ifdef DEBUG
X	FILE *fp;
X
X	if (debug != 1)
X		return;
X
X	if ((fp = fopen ("/tmp/NNTP","a+")) != NULL) {
X		fprintf (fp,"%s: %s\n", func, line);
X		fclose (fp);
X		chmod ("/tmp/NNTP", 0666);
X	}
X#endif
X}
X
X
Xvoid debug_nntp_respcode (respcode)
X	int respcode;
X{
X#ifdef DEBUG
X	debug_nntp ("get_respcode", nntp_respcode (respcode));
X#endif
X}	
X
X/*
X *  tin specific debug routines
X */
X 
Xvoid debug_print_arts ()
X{
X#ifdef DEBUG
X	int i;
X
X	if (debug != 2)
X		return;
X
X	for (i = 0; i < top; i++) {	/* for each group */
X		debug_print_header (&arts[i]);
X	}
X#endif
X}
X
X
Xvoid debug_print_header (s)
X	struct article_t *s;
X{
X#ifdef DEBUG
X	FILE *fp;
X
X	if (debug != 2)
X		return;
X
X	if ((fp = fopen ("/tmp/ARTS","a+")) != NULL) {
X		fprintf (fp,"art=[%5ld] tag=[%s] kill=[%s] hot=[%s]\n", s->artnum,
X			(s->tagged ? "TRUE" : "FALSE"),
X			(s->killed ? "TRUE" : "FALSE"),
X			(s->hot ? "TRUE" : "FALSE"));
X		fprintf (fp,"subj=[%-38s]\n", s->subject);
X		fprintf (fp,"date=[%s]  from=[%s]  name=[%s]\n", s->date, s->from, s->name);
X 		if (s->archive) {
X 		    fprintf (fp, "arch=[%-38s]  ", s->archive);
X 		} else {
X 		    fprintf (fp, "arch=[]  ");
X 		}
X 		if (s->part) {
X 		    fprintf (fp, "part=[%s]  ", s->part);
X 		} else {
X 		    fprintf (fp, "part=[]  ");
X 		}
X 		if (s->patch) {
X 		    fprintf (fp, "patch=[%s]\n", s->patch);
X		} else {
X 		    fprintf (fp, "patch=[]\n");
X 		}
X		fprintf (fp,"thread=[%d]  inthread=[%d]  unread=[%d]\n\n",
X			s->thread, s->inthread, s->unread);
X/*		fprintf (fp,"thread=[%s]  inthread=[%s]  unread=[%s]\n",
X			(s->thread == ART_NORMAL ? "ART_NORMAL" : "ART_EXPIRED"),
X			(s->inthread ? "TRUE" : "FALSE"),
X			(s->unread ? "TRUE" : "FALSE"));
X*/
X		fflush (fp);
X		fclose (fp);
X		chmod ("/tmp/DUMP", 0666);
X	}
X#endif
X}
X
X
Xvoid debug_print_comment (comment)
X	char *comment;
X{
X#ifdef DEBUG
X	FILE *fp;
X
X	if (debug != 2)
X		return;
X
X	if ((fp = fopen ("/tmp/BASE","a+")) != NULL) {
X		fprintf (fp,"\n%s\n\n", comment);
X		fflush (fp);
X		fclose (fp);
X		chmod ("/tmp/BASE", 0666);
X	}
X#endif
X}
X
X
Xvoid debug_print_base ()
X{
X#ifdef DEBUG
X	FILE *fp;
X	int i;
X
X	if (debug != 2)
X		return;
X
X	if ((fp = fopen ("/tmp/BASE","a+")) != NULL) {
X		for (i = 0; i < top_base; i++) {
X			fprintf (fp, "base[%3d]=[%5ld]\n",i,base[i]);
X		}
X		fflush (fp);
X		fclose (fp);
X		chmod ("/tmp/BASE", 0666);
X	}
X#endif
X}
X
X
Xvoid debug_print_active ()
X{
X#ifdef DEBUG
X	FILE *fp;
X	int i;
X
X	if (debug != 2)
X		return;
X
X	if ((fp = fopen ("/tmp/ACTIVE","w")) != NULL) {
X		for (i = 0; i < num_active; i++) {	/* for each group */
X			fprintf (fp, "[%4d]=[%-28s] max=[%4ld] min=[%4ld] mod=[%c] nxt=[%4d] flag=[%d]\n",
X				i, active[i].name, active[i].max, active[i].min,
X				active[i].moderated, active[i].next, active[i].flag);
X			fprintf (fp, "read=[%d] show=[%d] thread=[%d] sort=[%d] author=[%d] auto=[%d] process=[%d]\n",
X				active[i].attribute.read,    active[i].attribute.showall,
X				active[i].attribute.thread,  active[i].attribute.sortby,
X				active[i].attribute.author,  active[i].attribute.autosave,
X				active[i].attribute.process);
X			fprintf (fp, "server=[%s] ", (active[i].attribute.server  == (char *) 0 ? "" : active[i].attribute.server));
X			fprintf (fp, "maildir=[%s] ",(active[i].attribute.maildir == (char *) 0 ? "" : active[i].attribute.maildir));			
X			fprintf (fp, "savedir=[%s] ",(active[i].attribute.savedir == (char *) 0 ? "" : active[i].attribute.savedir));
X			fprintf (fp, "sigfile=[%s]\n\n",(active[i].attribute.sigfile == (char *) 0 ? "" : active[i].attribute.sigfile));
X		}
X		fflush (fp);
X		fclose (fp);
X		chmod ("/tmp/ACTIVE", 0666);
X	}
X#endif
X}
END_OF_FILE
  if test 4195 -ne `wc -c <'debug.c'`; then
    echo shar: \"'debug.c'\" unpacked with wrong size!
  fi
  # end of 'debug.c'
fi
if test -f 'hashstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hashstr.c'\"
else
  echo shar: Extracting \"'hashstr.c'\" \(2510 characters\)
  sed "s/^X//" >'hashstr.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : hashstr.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 21-03-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X/*
X *  Maintain a table of all strings we have seen.
X *  If a new string comes in, add it to the table and return a pointer
X *  to it.  If we've seen it before, just return the pointer to it.
X *
X *  Usage:  hash_str("some string") returns char *
X *
X *  Spillovers are chained on the end
X */
X
X/*
X *  Arbitrary table size, but make sure it's prime!
X */
X
X#define		HASHNODE_TABLE_SIZE	2411
X
Xstruct hashnode *table[HASHNODE_TABLE_SIZE];
X
X
Xchar *hash_str (s)
X	char *s;
X{
X	long h;				/* result of hash:  index into hash table */
X	struct hashnode *p;	/* used to descend the spillover structs */
X
X	if (s == (char *) 0) {
X		return ((char *) 0);
X	}
X
X	{
X		unsigned char *t = (unsigned char *) s;
X
X		h = *t++;
X		while (*t)
X			h = ((h << 1) ^ *t++) % (long) HASHNODE_TABLE_SIZE;
X	}
X
X	p = table[h];
X
X	if (p == (struct hashnode *) 0) {
X		table[h] = add_string (s);
X		return table[h]->s;
X	}
X
X	while (1) {
X		if (strcmp (s, p->s) == 0) {
X			return (p->s);
X		}
X
X		if (p->next == (struct hashnode *) 0) {
X			p->next = add_string (s);
X			return p->next->s;
X		} else {
X			p = p->next;
X		}
X	}
X	/* NOTREACHED */
X}
X
X
Xstruct hashnode *add_string (s)
X	char *s;
X{
X	int *iptr;
X	struct hashnode *p;
X
X	p = (struct hashnode *) my_malloc ((unsigned) sizeof (struct hashnode));
X
X	p->next = (struct hashnode *) 0;
X	iptr = (int *) my_malloc ((unsigned) strlen (s) + sizeof (int) + 1);
X	*iptr++ = -1;
X	p->s = (char *) iptr;
X	strcpy (p->s, s);
X	return (p);
X}
X
X
Xvoid hash_init ()
X{
X	int i;
X
X	for (i = 0; i < HASHNODE_TABLE_SIZE; i++) {
X		table[i] = (struct hashnode *) 0;
X	}
X}
X
X
Xvoid hash_reclaim ()
X{
X	int i;
X	int *iptr;
X	struct hashnode *p, *next;
X
X	for (i = 0; i < HASHNODE_TABLE_SIZE; i++)
X		if (table[i] != (struct hashnode *) 0) {
X			p = table[i];
X			while (p != (struct hashnode *) 0) {
X				next = p->next;
X				if (p->s != (char *) 0) {
X					iptr = (int *) p->s;
X					iptr--;
X					free ((char *) iptr);
X				}
X				free ((char *) p);
X				p = next;
X			}
X			table[i] = (struct hashnode *) 0;
X		}
X}
END_OF_FILE
  if test 2510 -ne `wc -c <'hashstr.c'`; then
    echo shar: \"'hashstr.c'\" unpacked with wrong size!
  fi
  # end of 'hashstr.c'
fi
if test -f 'inews.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews.c'\"
else
  echo shar: Extracting \"'inews.c'\" \(3615 characters\)
  sed "s/^X//" >'inews.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : inews.c
X *  Author    : I.Lea
X *  Created   : 17-03-92
X *  Updated   : 06-05-92
X *  Notes     : NNTP builtin version of inews
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X#include	"nntplib.h"
X
X#ifdef BSD
X#	ifdef apollo
X#		include	</bsd4.3/usr/include/netdb.h>
X#	else
X#		include	<netdb.h>
X#	endif
X#endif
X
X
Xint submit_inews (name)
X	char *name;
X{
X	int	ret_code = FALSE;
X
X#if !defined(INDEX_DAEMON) && !defined(XSPOOLDIR)
X
X#ifdef NNTP_INEWS
X	char	from_name[256];
X	char	host_name[128];
X	char	line[NNTP_STRLEN];
X	FILE	*fp;
X	int	len = 0;
X	int	respcode;
X
X	if ((fp = fopen (name, "r")) == NULL) {
X		return (ret_code);
X	}
X
X	/*
X	 * Send POST command to NNTP server
X	 */
X	put_server ("post");
X
X	/*
X	 * Receive CONT_POST or ERROR response code from NNTP server
X	 */
X	if ((respcode = get_respcode ()) != CONT_POST) {
X		error_message ("%s", nntp_respcode (respcode));
X		debug_nntp ("submit_inews", nntp_respcode (respcode));
X		return (ret_code);
X	}
X
X	get_host_name (host_name);	
X	get_from_name (from_name);
X	
X	/*
X	 * Send Path: and From: article headers
X	 */
X#ifdef NNTP_INEWS_GATEWAY
X	sprintf (line, "Path: %s", userid);
X#else
X	sprintf (line, "Path: %s!%s", host_name, userid);
X#endif	
X	put_server (line);
X	sprintf (line, "From: %s", from_name);
X	put_server (line);
X
X	/*
X	 * Send article 1 line at a time ending with "."
X	 */
X	while (fgets (line, sizeof (line), fp) != NULL) {
X		len = strlen (line);
X		line[len-1] = '\0';
X		fprintf (ser_wr_fp, "%s\r\n", line);
X	}
X	
X	put_server (".");
X
X	/*
X	 * Receive OK_POSTED or ERROR response code from NNTP server
X	 */
X	if ((respcode = get_respcode ()) != OK_POSTED) {
X		error_message ("%s", nntp_respcode (respcode));
X		debug_nntp ("submit_inews", nntp_respcode (respcode));
X		return (ret_code);
X  	}
X  	
X	ret_code = TRUE;
X
X#endif /* NNTP_ABLE */
X
X#endif /* INDEX_DAEMON */
X
X	return (ret_code);
X}
X
X/*
X * Find real hostname / substitute hostname if news gateway name 
X */
X 
Xvoid get_host_name (host_name)
X	char *host_name;
X{
X#ifndef INDEX_DAEMON
X
X#ifdef NNTP_INEWS_GATEWAY
X	strcpy (host_name, NNTP_INEWS_GATEWAY);
X#else
X	char host[256];
X
X#	if defined(BSD) || defined(sinix) || defined(RS6000) || defined(HPUX)
X	{
X		struct hostent *host_entry;
X
X		gethostname (host, sizeof (host)); 
X		host_entry = gethostbyname (host);
X		my_strncpy (host, host_entry->h_name, sizeof (host)); 
X	}	
X#	else	
X	{
X		struct utsname uts_name;
X
X		uname (&uts_name);
X		my_strncpy (host, uts_name.nodename, sizeof (host));
X	}
X#	endif
X
X	strcpy (host_name, host);
X#endif
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X * Find users & hosts name
X */
X
Xvoid get_from_name (from_name)
X	char *from_name;
X{
X#ifndef INDEX_DAEMON
X
X	char full_name[128];
X	char host_name[256];
X	char *ptr;
X	
X	if ((ptr = (char *) getenv ("NAME")) != (char *) 0) {
X		my_strncpy (full_name, ptr, sizeof (full_name));
X	} else {	
X		my_strncpy (full_name, myentry->pw_gecos, sizeof (full_name));
X		if ((ptr = (char *) strchr (full_name, ','))) {
X			*ptr = '\0';			
X		}
X	}
X
X	get_host_name (host_name);
X
X#ifdef NNTP_INEWS_DOMAIN
X	sprintf (from_name, "%s@%s%s (%s)",
X		userid, host_name, NNTP_INEWS_DOMAIN, full_name);
X#else	
X	sprintf (from_name, "%s@%s (%s)", userid, host_name, full_name);
X#endif
X
X	if (debug == 2) {
X		error_message ("FROM: %s", from_name);
X	}	
X
X#endif /* INDEX_DAEMON */
X}
END_OF_FILE
  if test 3615 -ne `wc -c <'inews.c'`; then
    echo shar: \"'inews.c'\" unpacked with wrong size!
  fi
  # end of 'inews.c'
fi
if test -f 'patchlev.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlev.h'\"
else
  echo shar: Extracting \"'patchlev.h'\" \(585 characters\)
  sed "s/^X//" >'patchlev.h' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : patchlev.h
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 12-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#define VERSION		"1.1"		/* Beta versions are "1.n Beta" */
X#define PATCHLEVEL	3
END_OF_FILE
  if test 585 -ne `wc -c <'patchlev.h'`; then
    echo shar: \"'patchlev.h'\" unpacked with wrong size!
  fi
  # end of 'patchlev.h'
fi
if test -f 'prompt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prompt.c'\"
else
  echo shar: Extracting \"'prompt.c'\" \(3818 characters\)
  sed "s/^X//" >'prompt.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : prompt.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 12-04-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X/*
X *  prompt_num
X *  get a number from the user
X *  Return -1 if missing or bad number typed
X */
X
Xint prompt_num (ch, prompt)
X	char ch;
X	char *prompt;
X{
X	char *p;
X	int num;
X	int time_remaining;
X
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X	
X	clear_message ();
X
X	sprintf (msg, "%c", ch);
X
X	if ((p = getline (prompt, TRUE, msg)) != (char *) 0) {
X		strcpy (msg, p);
X		num = atoi (msg);
X	} else {
X		num = -1;
X	}
X
X	clear_message ();
X
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X	
X	return (num);
X}
X
X/*
X *  prompt_string
X *  get a string from the user
X *  Return TRUE if a valid string was typed, FALSE otherwise
X */
X
Xint prompt_string (prompt, buf)
X	char *prompt;
X	char *buf;
X{
X	char *p;
X	int time_remaining;
X
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X
X	clear_message ();
X
X	if ((p = getline (prompt, FALSE, (char *) 0)) == (char *) 0) {
X		buf[0] = '\0';
X		clear_message ();
X#ifndef NO_RESYNC_ACTIVE_FILE
X		alarm (time_remaining);
X#endif
X		return FALSE;
X	}
X	strcpy (buf, p);
X	
X	clear_message ();
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X	
X	return TRUE;
X}
X
X/*
X *  prompt_menu_string
X *  get a string from the user
X *  Return TRUE if a valid string was typed, FALSE otherwise
X */
X
Xint prompt_menu_string (line, col, var)
X	int line;
X	int col;
X	char *var;
X{
X	char *p;
X	int time_remaining;
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X
X	MoveCursor (line, col);
X
X	if ((p = getline ("", FALSE, var)) == (char *) 0) {
X#ifndef NO_RESYNC_ACTIVE_FILE
X		alarm (time_remaining);
X#endif
X		return FALSE;
X	}
X	strcpy (var, p);
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X	
X	return TRUE;
X}
X
X
Xint prompt_yn (line, prompt, prompt_ch)
X	int line;
X	char *prompt;
X	int prompt_ch;
X{
X	char ch;
X	int time_remaining;
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X
X	MoveCursor (line, 0);
X	CleartoEOLN ();
X	printf ("%s%c", prompt, prompt_ch);
X	fflush (stdout);
X	MoveCursor (line, (int) strlen (prompt));
X
X	if ((ch = (char) ReadCh()) == CR) {
X		ch = prompt_ch;
X	}	
X
X	if (line == LINES) {
X		clear_message();
X	} else {
X		MoveCursor (line, (int) strlen (prompt));
X		if (ch == ESC) {
X			fputc (prompt_ch, stdout);
X		} else {
X			fputc (ch, stdout);
X		}
X		fflush (stdout);
X	}
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X
X	return (ch == 'y' ? TRUE : FALSE);
X}
X
X
Xvoid prompt_on_off (row, col, var, help_text, prompt_text)
X	int row;
X	int col;
X	int *var;
X	char *help_text;
X	char *prompt_text;
X{
X	int ch, var_orig;
X	int time_remaining;
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X
X	var_orig = *var;
X
X	show_menu_help (help_text);
X	do {
X		MoveCursor (row, col + (int) strlen (prompt_text));
X		if ((ch = (char) ReadCh ()) == ' ') {
X			*var = !*var;
X			printf ("%s", (*var ? "ON " : "OFF"));
X			fflush (stdout);
X		}
X	} while (ch != CR && ch != ESC);
X
X	if (ch == ESC) {
X		*var = var_orig;
X		printf ("%s", (*var ? "ON " : "OFF"));
X		fflush (stdout);
X	}
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X}
X
X
Xvoid continue_prompt ()
X{
X	char ch;
X	int time_remaining;
X#ifndef NO_RESYNC_ACTIVE_FILE
X	time_remaining = alarm (0);
X#endif
X	
X	info_message (txt_hit_any_key);
X	ch = (char) ReadCh ();
X#ifndef NO_RESYNC_ACTIVE_FILE
X	alarm (time_remaining);
X#endif
X}
X
X
END_OF_FILE
  if test 3818 -ne `wc -c <'prompt.c'`; then
    echo shar: \"'prompt.c'\" unpacked with wrong size!
  fi
  # end of 'prompt.c'
fi
if test -f 'screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'screen.c'\"
else
  echo shar: Extracting \"'screen.c'\" \(2916 characters\)
  sed "s/^X//" >'screen.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : screen.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 18-04-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern int errno;
X
Xchar msg[LEN];
Xstruct screen_t *screen;
X
X
Xvoid info_message (str)
X	char *str;
X{
X	clear_message ();				/* Clear any old messages hanging around */
X	center_line (LINES, FALSE, str);	/* center the message at screen bottom */
X	if (! cmd_line) {
X		MoveCursor (LINES, 0);
X	}
X}
X
X
Xvoid wait_message (str)
X	char *str;
X{
X	clear_message ();	  /* Clear any old messages hanging around */
X	fputs (str, stdout);
X	fflush (stdout);
X}
X
X
Xvoid error_message (template, str)
X	char *template;
X	char *str;
X{
X	errno = 0;
X
X	clear_message ();	  /* Clear any old messages hanging around */
X	
X	fprintf (stderr, template, str);
X	fflush (stderr);
X
X	if (cmd_line) {
X		fputc ('\n', stderr);
X		fflush (stderr);
X	} else {
X		MoveCursor (LINES, 0);
X		sleep (2);
X	}
X}
X
X
Xvoid perror_message (template, str)
X	char *template;
X	char *str;
X{
X	char str2[512];
X
X	clear_message ();	  /* Clear any old messages hanging around */
X	
X	sprintf (str2, template, str);
X	perror (str2);
X	errno = 0;
X
X	if (cmd_line) {
X		fputc ('\n', stderr);
X		fflush (stderr);
X	} else {
X		MoveCursor (LINES, 0);
X		sleep (2);
X	}
X}
X
X
Xvoid clear_message ()
X{
X	if (! cmd_line) {
X		MoveCursor (LINES, 0);
X		CleartoEOLN ();
X	}
X}
X
X
Xvoid center_line (line, inverse, str)
X	int line;
X	int inverse;
X	char *str;
X{
X	int pos;
X
X	if (! cmd_line) {
X		pos = (COLS - (int) strlen (str)) / 2;
X		MoveCursor (line, pos);
X		if (inverse) {
X			StartInverse ();
X		}
X	}
X
X	fputs (str, stdout);
X	fflush (stdout);
X
X	if (! cmd_line) {
X		if (inverse) {
X			EndInverse ();
X		}
X	}
X}
X
X
Xvoid draw_arrow (line)
X	int line;
X{
X	MoveCursor (line, 0);
X
X	if (draw_arrow_mark) {
X		fputs ("->", stdout);
X		fflush (stdout);
X	} else {
X		StartInverse ();
X		fputs (screen[line-INDEX_TOP].col, stdout);
X		fflush (stdout);
X		EndInverse ();
X	}
X	MoveCursor (LINES, 0);
X}
X
X
Xvoid erase_arrow (line)
X	int line;
X{
X	MoveCursor (line, 0);
X
X	if (draw_arrow_mark) {
X		fputs ("  ", stdout);
X	} else {
X		EndInverse ();
X		fputs (screen[line-INDEX_TOP].col, stdout);
X	}
X	fflush (stdout);
X}
X
X
Xvoid show_title (title)
X	char *title;
X{	
X	int col;
X	
X	col = (COLS - (int) strlen (txt_type_h_for_help))+1;
X	if (col) {
X		MoveCursor (0, col);
X		if (mail_check ()) {		/* you have mail message in */
X			fputs (txt_you_have_mail, stdout);
X		} else {
X			fputs (txt_type_h_for_help, stdout);
X		}
X	}
X	center_line (0, TRUE, title);
X}
X
X
Xvoid ring_bell ()
X{
X	fputc ('\007', stdout);
X	fflush (stdout);
X}
END_OF_FILE
  if test 2916 -ne `wc -c <'screen.c'`; then
    echo shar: \"'screen.c'\" unpacked with wrong size!
  fi
  # end of 'screen.c'
fi
if test -f 'search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'search.c'\"
else
  echo shar: Extracting \"'search.c'\" \(7173 characters\)
  sed "s/^X//" >'search.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : search.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 13-03-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern FILE *note_fp;
Xextern int cur_groupnum;
Xextern int first_group_on_screen;
Xextern int last_group_on_screen;
Xextern int first_subj_on_screen;
Xextern int last_subj_on_screen;
Xextern int index_point;
Xextern int note_line;
Xextern int note_page;
Xextern int note_end;
Xextern long note_mark[MAX_PAGES];
X
X/*
X * last search patterns
X */
X
Xchar default_author_search[LEN];
Xchar default_group_search[LEN];
Xchar default_subject_search[LEN];
Xchar default_art_search[LEN];
X
X
X/*
X *  group.c & page.c
X */
X 
Xint search_author (only_unread, current_art, forward)
X	int only_unread;
X	int current_art;
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, patlen;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_author_search_forwards, default_author_search);
X	} else {
X		sprintf (buf2, txt_author_search_backwards, default_author_search);
X	}
X	
X	if (! prompt_string (buf2, buf)) {
X		return -1;
X	}
X	
X	if (strlen (buf)) {
X		strcpy (default_author_search, buf);
X	} else {
X		if (default_author_search[0]) {
X			strcpy (buf, default_author_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return -1;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_author_search, buf);
X
X	patlen = strlen (default_author_search);
X
X	i = current_art;
X
X	do {
X		if (forward) {
X			i = next_response (i);
X			if (i < 0)
X				i = base[0];
X		} else {
X			i = prev_response (i);
X			if (i < 0)
X				i = base[top_base - 1] + 
X					num_of_responses (top_base - 1);
X		}
X
X		if (only_unread && arts[i].unread != ART_UNREAD) {
X			continue;
X		}
X			
X		if (arts[i].name == (char *) 0) {
X			make_lower (arts[i].from, buf2);
X		} else {
X			sprintf (msg, "%s (%s)", arts[i].from, arts[i].name);
X			make_lower (msg, buf2);
X		}
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			clear_message ();
X			return i;
X		}
X	} while (i != current_art);
X
X	info_message (txt_no_match);
X	return -1;
X}
X
X/*
X * select.c
X */
X 
Xvoid search_group (forward)
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, patlen;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_group_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_group_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_group_search, buf);
X	} else {
X		if (default_group_search[0]) {
X			strcpy (buf, default_group_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_group_search, buf);
X
X	patlen = strlen (default_group_search);
X
X	i = cur_groupnum;
X
X	do {
X		if (forward)
X			i++;
X		else
X			i--;
X
X		if (i >= group_top)
X			i = 0;
X		if (i < 0)
X			i = group_top - 1;
X
X		make_lower (active[my_group[i]].name, buf2);
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			if (i >= first_group_on_screen
X			&&  i < last_group_on_screen) {
X				clear_message ();
X				erase_group_arrow ();
X				cur_groupnum = i;
X				draw_group_arrow ();
X			} else {
X				cur_groupnum = i;
X				group_selection_page ();
X			}
X			return;
X		}
X	} while (i != cur_groupnum);
X
X	info_message (txt_no_match);
X}
X
X/*
X * group.c
X */
X
Xvoid search_subject (forward, group)
X	int forward;
X	char *group;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, j, patlen;
X
X	if (index_point < 0) {
X		info_message (txt_no_arts);
X		return;
X	}
X	
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_subject_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_subject_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_subject_search, buf);
X	} else {
X		if (default_subject_search[0]) {
X			strcpy (buf, default_subject_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_subject_search, buf);
X
X	patlen = strlen (default_subject_search);
X
X	i = index_point;
X
X	do {
X		if (forward)
X			i++;
X		else
X			i--;
X
X		if (i >= top_base)
X			i = 0;
X		if (i < 0)
X			i = top_base - 1;
X
X		j = (int) base[i];
X
X		make_lower (arts[j].subject, buf2);
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			if (i >= first_subj_on_screen
X			    &&  i < last_subj_on_screen) {
X				clear_message ();
X				erase_subject_arrow ();
X				index_point = i;
X				draw_subject_arrow ();
X			} else {
X				index_point = i;
X				show_group_page (group);
X			}
X			return;
X		}
X	} while (i != index_point);
X
X	info_message (txt_no_match);
X}
X
X/*
X *  page.c (search article body)
X */
X
Xint search_article (forward)
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	char string[LEN];
X	char pattern[LEN];
X	char *p, *q;
X	int ctrl_L;
X	int i, j, patlen;
X	int orig_note_end;
X	int orig_note_page;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_art_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_art_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return FALSE;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_art_search, buf);
X	} else {
X		if (default_art_search[0]) {
X			strcpy (buf, default_art_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return FALSE;
X		}
X	}
X
X	wait_message (txt_searching);
X	
X	make_lower (default_art_search, pattern);
X
X	patlen = strlen (default_art_search);
X
X	/*
X	 *  save current position in article
X	 */
X	orig_note_end = note_end;
X	orig_note_page = note_page;
X	
X	while (! note_end) {
X		note_line = 1;
X		ctrl_L = FALSE;
X
X		if (note_page == 0) {
X			note_line += 4;
X		} else {
X			note_line += 2;
X		}
X		while (note_line < LINES) {
X			if (fgets (buf, sizeof buf, note_fp) == NULL) {
X				note_end = TRUE;
X				break;
X			}
X			buf[LEN-1] = '\0';
X			for (p = buf, q = buf2;	*p && *p != '\n' && q<&buf2[LEN]; p++) {
X				if (*p == '\b' && q > buf2) {
X					q--;
X				} else if (*p == '\f') {		/* ^L */
X					*q++ = '^';
X					*q++ = 'L';
X					ctrl_L = TRUE;
X				} else if (*p == '\t') {
X					i = q - buf2;
X					j = (i|7) + 1;
X
X					while (i++ < j) {
X						*q++ = ' ';
X					}
X				} else if (((*p) & 0xFF) < ' ') {
X					*q++ = '^';
X					*q++ = ((*p) & 0xFF) + '@';
X				} else {
X					*q++ = *p;
X				}
X			}
X			*q = '\0';
X
X			make_lower (buf2, string);
X
X			if (str_str (string, pattern, patlen) != 0) {
X				fseek (note_fp, note_mark[note_page], 0);
X				return TRUE;
X			}
X
X			note_line += ((int) strlen(buf2) / COLS) + 1;
X
X			if (ctrl_L) {
X				break;
X			}
X		}
X		if (! note_end) {
X			note_mark[++note_page] = ftell (note_fp);
X		}
X	}
X
X	note_end = orig_note_end;
X	note_page = orig_note_page;
X	fseek (note_fp, note_mark[note_page], 0);
X	info_message (txt_no_match);
X	return FALSE;
X}
X
X
Xvoid make_lower (s, t)
X	char *s;
X	char *t;
X{
X
X	while (*s) {
X		if (isupper(*s))
X			*t = tolower(*s);
X		else
X			*t = *s;
X		s++;
X		t++;
X	}
X	*t = 0;
X}
END_OF_FILE
  if test 7173 -ne `wc -c <'search.c'`; then
    echo shar: \"'search.c'\" unpacked with wrong size!
  fi
  # end of 'search.c'
fi
if test -f 'wildmat.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wildmat.3'\"
else
  echo shar: Extracting \"'wildmat.3'\" \(2247 characters\)
  sed "s/^X//" >'wildmat.3' <<'END_OF_FILE'
X.TH WILDMAT 3
X.SH NAME
Xwildmat \- perform shell-style wildcard matching
X.SH SYNOPSIS
X.nf
X.B "int"
X.B "wildmat(text, pattern)"
X.B "    char		*text;"
X.B "    char		*pattern;"
X.fi
X.SH DESCRIPTION
X.I Wildmat
Xcompares the
X.I text
Xagainst the
X.I pattern
Xand
Xreturns non-zero if the pattern matches the text.
XThe pattern is interpreted similar to shell filename wildcards, and not
Xas a full regular expression such as those handled by the
X.IR grep (1)
Xfamily of programs or the
X.IR regex (3)
Xor
X.IR regexp (3)
Xset of routines.
X.PP
XThe pattern is interpreted according to the following rules:
X.TP
X.BI \e x
XTurns off the special meaning of
X.I x
Xand matches it directly; this is used mostly before a question mark or
Xasterisk, and is not valid inside square brackets.
X.TP
X.B ?
XMatches any single character.
X.TP
X.B *
XMatches any sequence of zero or more characters.
X.TP
X.BI [ x...y ]
XMatches any single character specified by the set
X.IR x...y .
XA minus sign may be used to indicate a range of characters.
XThat is,
X.I [0\-5abc]
Xis a shorthand for
X.IR [012345abc] .
XMore than one range may appear inside a character set;
X.I [0-9a-zA-Z._]
Xmatches almost all of the legal characters for a host name.
XThe close bracket,
X.IR ] ,
Xmay be used if it is the first character in the set.
XThe minus sign,
X.IR \- ,
Xmay be used if it is either the first or last character in the set.
X.TP
X.BI [^ x...y ]
XThis matches any character
X.I not
Xin the set
X.IR x...y ,
Xwhich is interpreted as described above.
XFor example,
X.I [^]\-]
Xmatches any character other than a close bracket or minus sign.
X.SH "BUGS AND LIMITATIONS"
XThere is no way to end a range with a close bracket.
X.SH HISTORY
XWritten by Rich $alz <rsalz@bbn.com> in 1986, and posted to Usenet
Xseveral times since then, most notably in comp.sources.misc in
XMarch, 1991.
X.PP
XLars Mathiesen <thorinn@diku.dk> enhanced the multi-asterisk failure
Xmode in early 1991.
X.PP
XRich and Lars increased the efficiency of star patterns and reposted it
Xto comp.sources.misc in April, 1991.
X.PP
XRobert Elz <kre@munnari.oz.au> added minus sign and close bracket handling
Xin June, 1991.
X.PP
X.de R$
XThis is revision \\$3, dated \\$4.
X..
X.R$ $Id: wildmat.3,v 1.7 91/07/05 17:50:16 rsalz Exp $
X.SH "SEE ALSO"
Xgrep(1), regex(3), regexp(3).
END_OF_FILE
  if test 2247 -ne `wc -c <'wildmat.3'`; then
    echo shar: \"'wildmat.3'\" unpacked with wrong size!
  fi
  # end of 'wildmat.3'
fi
if test -f 'xindex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xindex.c'\"
else
  echo shar: Extracting \"'xindex.c'\" \(3476 characters\)
  sed "s/^X//" >'xindex.c' <<'END_OF_FILE'
X/*
X *  Project   : NNTP (RFC 977) extension
X *  Module    : xindex.c
X *  Author    : I.Lea
X *  Created   : 07-03-92
X *  Updated   : 22-03-92
X *  Notes     : Add a command to retieve index files from the
X *              NNTP server so as to save space on the client.
X *              Ideas borrowed from XTHREAD nntp extension code
X *              posted by Tim Iverson to alt.sources in mid'91.
X *  Copyright : (c) Copyright 1992 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include "common.h"
X
X#ifdef XINDEX
X
X#undef	DEBUG_XINDEX		/* set to define to turn on more debug info */
X#define HASH_VALUE 1409		/* mod value for hashing group name */
X
X#ifdef __STDC__
Xvoid xindex (int argc, char *argv[]);
Xstatic void find_index_file (char *group, char *index_file);
Xstatic long hash_groupname (char *group);
X#else
Xvoid xindex ();
Xstatic void find_index_file ();
Xstatic long hash_groupname ();
X#endif
X
X/*
X *  Usage: XINDEX GROUP
X *
X *  GROUP    Group for which to retrieve index file
X *
X *  This command is NOT documented in RFC977.
X */
X
Xvoid xindex (argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	char	line[NNTP_STRLEN];
X	char	group[256];
X	char	index_file[256];
X	char	*cp;
X	FILE	*fp;
X	
X	/*
X	 * "parse" the argument list
X	 */
X	if (argc == 1) {
X		printf("%d Usage: XINDEX group\r\n", ERR_CMDSYN);
X		(void) fflush(stdout);
X		return;
X	} else {
X		strncpy (group, argv[1], sizeof (group)-1);
X#if defined(SYSLOG) && defined(DEBUG_XINDEX)
X		syslog(LOG_INFO, "%s xindex %s", hostname, group);
X#endif
X
X		find_index_file(group, index_file);
X		
X		if ((fp = fopen(index_file, "r")) == NULL) {
X#ifdef SYSLOG
X			syslog(LOG_INFO, "%s xindex cannot open %s (%s)",
X				hostname, group, index_file);
X#endif
X			printf("%d XINDEX Cannot open %s\r\n",
X				ERR_XINDEX, group);
X			(void) fflush(stdout);
X			return;
X		}
X
X		printf("%d XINDEX group in index format\r\n", OK_XINDEX);
X		(void) fflush(stdout);
X		
X		while (fgets(line, sizeof(line), fp) != NULL) {
X			if ((cp = index(line, '\n')) != NULL)
X				*cp = '\0';
X			putline(line);
X		}
X		(void) fclose(fp);
X	
X		putline(".");
X		(void) fflush(stdout);
X	}
X}
X
X/*
X *  Look in <SPOOLDIR>/.index directory for the index file for the
X *  given group.  Hashing the group name gets a number. See if that
X *  #.1 file exists; if so, read first line. Group we want? If not,
X *  try #.2.  Repeat until no such file or we find the right file.
X */
X
Xstatic void find_index_file (group, index_file)
X	char *group;
X	char *index_file;
X{
X	char buf[256], *p;
X	FILE *fp;
X	int i = 1;
X	unsigned long hash;
X
X	hash = hash_groupname (group);
X
X	while (1) {
X		sprintf (index_file, "%s/.index/%lu.%d", SPOOLDIR, hash, i);
X		
X		if ((fp = fopen (index_file, "r")) == NULL) {
X			return;
X		}
X
X		if (fgets (buf, sizeof (buf), fp) == NULL) {
X			fclose (fp);
X			return;
X		}
X		fclose (fp);
X
X		for (p = buf; *p && *p != '\n'; p++) {
X			continue;
X		}	
X		*p = '\0';
X
X		if (strcmp (buf, group) == 0) {
X			return;
X		}	
X		i++;
X	}	
X}
X
X/*
X * hash group name for filename of group
X */
X
Xstatic long hash_groupname (group)
X	char *group;
X{
X	unsigned long hash_value;
X	unsigned char *ptr = (unsigned char *) group;
X
X	hash_value = *ptr++;
X
X	while (*ptr)
X		hash_value = ((hash_value << 1) ^ *ptr++) % HASH_VALUE;
X
X	return (hash_value);
X}
X
X
X#endif /* XINDEX */
X
END_OF_FILE
  if test 3476 -ne `wc -c <'xindex.c'`; then
    echo shar: \"'xindex.c'\" unpacked with wrong size!
  fi
  # end of 'xindex.c'
fi
if test -f 'xuser.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xuser.c'\"
else
  echo shar: Extracting \"'xuser.c'\" \(1344 characters\)
  sed "s/^X//" >'xuser.c' <<'END_OF_FILE'
X/*
X *  Project   : NNTP (RFC 977) extension
X *  Module    : xuser.c
X *  Author    : I.Lea / T.Iverson (iverson@xstor.com)
X *  Created   : 07-03-92
X *  Updated   : 07-03-92
X *  Notes     : Add a command to log nntp clients username.
X *              Ideas borrowed from XTHREAD nntp extension code
X *              posted by Tim Iverson to alt.sources in mid'91.
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include "common.h"
X
X#ifdef XUSER
X
X/*
X *  Usage: XUSER USER
X *
X *  USER    log clients username to nntp logfile
X *
X *  This command is NOT documented in RFC977.
X */
X
Xvoid xuser (argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	char	userinfo[NNTP_STRLEN];
X	int	i;
X	
X	/*
X	 * "parse" the argument list
X	 */
X	if (argc == 1) {
X		printf("%d Usage: XUSER user\r\n", ERR_CMDSYN);
X		(void) fflush(stdout);
X		return;
X	} else {
X		sprintf (userinfo, "user %s", argv[1]);
X		for (i = 2 ; i < argc ; i++) {
X			strcat (userinfo,  " ");
X			strcat (userinfo,  argv[i]);
X		}
X	}
X
X#ifdef SYSLOG
X		syslog(LOG_INFO, "%s %s", hostname, userinfo);
X#endif
X}
X
X#endif /* XUSER */
X
END_OF_FILE
  if test 1344 -ne `wc -c <'xuser.c'`; then
    echo shar: \"'xuser.c'\" unpacked with wrong size!
  fi
  # end of 'xuser.c'
fi
echo shar: End of archive 14 \(of 14\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
