Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v30i012:  tin - threaded full screen newsreader, Part12/14
Message-ID: <1992May20.172901.29947@sparky.imd.sterling.com>
X-Md4-Signature: ccb36227426acf8d6a4ad28c3a436482
Date: Wed, 20 May 1992 17:29:01 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 30, Issue 12
Archive-name: tin/part12
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 29, Issue 19-30

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  MANIFEST CHANGES Makefile kill.c main.c
# Wrapped by kent@sparky on Tue May 19 13:38:06 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 14)."'
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(939 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
XMANIFEST for tin newsreader (Thu May 14 00:26:48 MET DST 1992)
X----------------------------------------------------------
X   12658 Makefile
X     122 MANIFEST
X    3600 README
X   12810 CHANGES
X    8397 INSTALL
X    4958 TODO
X   14588 FAQ
X    2568 FTP
X   38440 tin.1
X    2247 wildmat.3
X   48215 tin.nrf
X   13510 tin.h
X   17525 extern.h
X    4658 nntplib.h
X   27832 proto.h
X     585 patchlev.h
X    8546 active.c
X   22838 art.c
X    7985 curses.c
X    4195 debug.c
X   14936 feed.c
X   11458 getline.c
X   24125 group.c
X    2510 hashstr.c
X    5603 help.c
X    3615 inews.c
X   14261 init.c
X   11832 kill.c
X   22813 lang.c
X   12398 main.c
X    7630 memory.c
X   15398 misc.c
X   20406 newsrc.c
X   14882 nntplib.c
X   13908 open.c
X   22466 page.c
X   26765 post.c
X    3818 prompt.c
X   23814 rcfile.c
X   25838 save.c
X    2916 screen.c
X    7173 search.c
X   24488 select.c
X    8395 signal.c
X   14239 spooldir.c
X   17796 thread.c
X    4798 wildmat.c
X  634558 total
END_OF_FILE
  if test 939 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(12810 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XCHANGES tin v1.1 PL2 -> tin 1.1 PL3
X-----------------------------------
X
X1)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. STUPID error (I was the culprit) stopped group selection screen
X         being redisplayed.
X    FIX. select.c - changed 2 #ifdef's to #ifndef NO_RESYNC_ACTIVE_FILE.
X
X2)  Wolfgang Zenker (wolfgang@lyxys.ka.sub.org) 
X    BUG. Replying through mail does not check Reply-To: mail header.
X    FIX. post.c - added find_reply_to_addr() to find Reply-To: / From: address.
X
X3)  Hakan Lennestal (hakanl@lulea.telesoft.se)
X    BUG. Makefile does not chown & chgrp for setuid version of tin.
X    FIX. Makefile - applied supplied patch.
X
X4)  Michael Traub (traub@rtf.bt.co.uk)
X    BUG. No support for PgUp PgDn Home End on vt200 terminals.
X    FIX. misc.c - applied supplied patch.   
X
X5)  Chris Steinbroner (hesh@hpos102.cup.hp.com)
X    BUG. Long groupnames (>40) will overwrite the screen[] array. 
X    FIX. select.c - applied supplied patch.
X
X6)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. #include <sys/ioctl.h> is included twice and causes compile
X         error on ISC Unix (#include files should be protected Sigh!).
X    FIX. tin.h curses.c - removed #include from curses.c
X
X7)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. select.c - added default prompt to 'g' command.
X
X8)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. nntplib.c - added & intergrated NNTP clientlib.c
X
X9)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. group.c - 'd' command now toggles between Subject: & selected
X         From: field combination. Save toggling through all four
X         combinations to get back to original choice on slow terminals.
X
X10) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Builtin inews is slow posting big articles because it uses
X         put_server() routine with fflush() for every line.
X    FIX. inews.c - replaced put_server() routine with fprintf() and
X         single fflush() after loop.
X
X11) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. feed.c - added code to print num of arts mailed/printed.
X
X12) Kazushi Marukawa (kazushi@kocb.astem.or.jp)
X    BUG. When reading news locally tin should use external inews and when 
X         reading via nntp use builtin inews.
X    FIX. inews.c - check to see if reading via nntp and use correct inews .
X
X13) Andy Jackson (arj@cam-orl.co.uk)
X    BUG. 'o' command prints the same author for all articles within a thread.
X    FIX. feed.c - pass correct artnum to print_file() routine.
X
X14) Andy Jackson (arj@cam-orl.co.uk)
X    BUG. Unthreading groups specified in ~/.tin/unthread does not always work.
X    FIX. misc.c - If group is beginning of hash chain it was not marked read.
X         Check is made if active[].next == -1 and if so active[].threa is set
X         to FALSE.
X
X15) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. thread.c - added 'd' command to toggle subject & author at thread level.
X
X16) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. init.c rcfile.c - added auto-saving of default prompt strings for next 
X         session.
X
X18) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. post.c help.c - added action field to 'W' history of posted/followups
X         so one can see if 'w' posted / 'f' followed up an article.
X
X19) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. SPOOLDIR is incorrectly used instead of spooldir.
X    FIX. open.c init.c - replaced all SPOOLDIR's with spooldir.
X
X20) Jim Robinson (robinson@mdivax1.mdd.comm.mot.com)
X    FIXES. rcfile.c - change_rcfile() when 'q' or 'ESC' are used to
X           exist, SIGTSTP disposition is is not being reset to it's
X           status upon enterring the routine, as is done when exiting
X           routine otherwise.
X           art.c - parse_header() stopped from being interrupted by
X           SIGALRM signal.
X           curses.c - ReadCh() code for READ_CHAR_HACK was wrong. On
X           EOF or error getc() returns EOF, but code loop checks for 0.
X    ENHANCEMENTS curses.c - InitScreen() if terminal has no inverse
X           will now use underline.
X           kill.c - kill_art_menu() implemented hot (auto select) of
X           interesting arts.
X           kill.c - kill menu has been enhanced to allow user to specify
X           killing or auto-selection of articles.
X           group.c - show_group_page() - modified to indicate 'hot' and
X           'seen' articles.
X    CHANGES rcfile.c - change_rcfile() when exiting by 'q' or 'ESC' we
X           now do killing as is done when exiting otherwise.
X           signal.c kill.c misc.c rcfile.c - Cleaned up files with use
X           of sigaction() vs signal() which *greatly* enhances readability
X           in places.
X           signal.c - Changed handling of SIGTSP. Now when SIGTSTP is 
X           caught we simply send ourself a SIGSTOP which is uncatchable.
X           active.c -  notify_groups() now runs in raw mode.
X           kill.c art.c - killing is now done by marking article as unread.
X           This means that index files are now *not* modified on the basis
X           of kills. 
X           art.c - reload_index_file() is no longer needed and so has been
X           deleted. 
X           group.c - show_group_page() worked on to increase readability.
X
X21) Steve Starck (sstarck@nv6.uswnvg.com)
X    ADD. Support for Sequent PTX. Applied supplied patch.
X
X22) Leila Burrell-Davis (lielabd@syma.sussex.ac.uk)
X    BUG. Sequent Dynix is based on BSD4.2 so a few things are different
X         for BSD configuration.
X    FIX. Applied supplied patch.
X
X23) Preston Bannister (preston@felix.filenet.com)
X    BUG. tin will hang if '|' piping command of articles is interrupted.
X    FIX. misc.c - check if errno = EPIPE and if so return to calling function.
X
X24) Lloyd Wright (lloyd@hpcvaac.cv.hp.com)
X    BUG. HPUX was using wrong mailer & should use gethostname() in inews.c
X    FIX. applied supplied patch.
X
X25) G. Woodbury (news%wolves.cs.duke.edu)
X    BUG. Good idea to put INDEXDIR on another filesystem then NEWSSPOOL to
X         save space & inodes for news.
X    FIX. main.c - added '-I dir' command line option.
X
X26) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. You have to explicity add *'s for regex killing/auto-selecting.
X    FIX. kill.c - added *'s behind the scenes to make esier to use regexes.
X
X27) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. When having advanced through a thread at page level & returned to 
X         thread level one is still positioned at start position in thread.
X    FIX. thread.c - added code to move to current respnum when returning.
X
X28) Bill de Beaubien (wjb@moscom.com)
X    BUG. Enviroment variable MAILER is not checked for mailer to use.
X    FIX. init.c - added check for MAILER enviroment variable.
X
X29) Kuo-Chien Kai (kckai@cc.nthu.edu)
X    BUG. A user can cancel any article.
X    FIX. post.c - added check to make sure user has same address & name 
X         as the From: header in article to cancel.
X
X30) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. SysV systems using uname() where not using utsname struct.
X    FIX. inews.c - changed uname() to use utsname struct instead of array.
X
X31) Jean-Marc Bonnaudet (Jean.Marc.Bonnaudet@sniap.mchp.sni.de) 
X    BUG. When viewing help pages 'j' & 'k' keys don't work.
X    FIX. help.c - Added 'j' & 'k' keys for PgDn & PgUp operation.
X
X32) Leila Burrell-Davis (lielabd@syma.sussex.ac.uk)
X    BUG. Line-editing produces $$ and does not auto-scroll horizontly if
X         editing window <30 characters.
X    FIX. feed.c - fixed so line prompt always leaves >=30 editing space.
X
X33) Stefan Rathmann (rathmann%anl433.uucp@Germany.EU.net)
X    BUG. Only first 4 characters of mail address are given over to mailer.
X    FIX. post.c - changed sizeof (pointer) to sizeof (buffer).
X
X34) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Won't compile on Apollo DN4500 & DomainOS 10.3
X    FIX. Added support to compile above configuration.
X
X35) Paul Halsema (phalsema@x102a.ess.harris.com)
X    BUG. Won't compile on Harris HCX & CX/UX.
X    FIX. Applied part of supplied patch. 
X
X36) Paul Halsema (phalsema@x102a.ess.harris.com)
X    BUG. '^Y' command does not work because shell uses it as suspend signal.
X    FIX. select.c - Changed '^Y' command to 'Y' command.
X
X37) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. Added basic support for per group configurable parameters.
X
X38) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Built-in NNTP inews does not allow Gateway machines / Domain
X         address to be specified for users posting address.
X    FIX. tin.h inews.c - Added #define's NNTP_INEWS_GATEWAY and
X         NNTP_INEWS_DOMAIN. For more info read the INSTALL document.
X
X39) Daemon Schaefer (damon@hpvcldm.vcd.hp.com)
X    BUG. Make all of the confirmation prompts a confurable option. 
X    FIX. init.c rcfile.c - added option to 'M' menu to allow prompts
X         to be switched ON/OFF.
X
X40) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Old versions of Unix(bsd42?) will not resize screen automatically
X         because TIOCGWINSZ ioctl is not supported.
X    FIX. signal.c - Added code to support TIOCGSIZE.
X
X41) Jonas Regmyr (dat91jre@ludat.lth.se)
X    BUG. Should wrap around to first group when at last group at group
X         selection level & vic versa when at first group.
X    FIX. select.c group.c thread.c - Added #ifdef NO_WRAP_AROUND to allow
X         old behaviour and also support for new.
X
X42) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. feed.c - Added same interface to 'x' crosspost command as used
X         by mail,print,pipe & save commands.
X
X43) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. open.c - Added support for reading news from an INN NNTP server.
X
X44) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Won't compile on SCO Unix 3.2.2
X    FIX. Added support to compile above configuration.
X
X45) Adri Verhoef (a3@tintin.rivm.nl)
X    BUG. Under BSD type systems builtin inews does not post with FQDN.
X    FIX. inews.c - Call gethostbyname() to get fully qualified domain name. 
X
X46) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Apollo DomainOS uses the ORGANIZATION environment variable. 
X    FIX. init.c - Changed environment variable to NEWSORG when on apollo.
X
X47) Etienne Bido (ebido@bio.vu.nl)
X    BUG. Should allow Distribution: field to be set from environment variable.
X    FIX. init.c - Uses the value of the DISTRIBUTION env. variable for the
X         Distribution: field when posting articles.
X
X48) Murray Laing (murray@uk.ac.ed.chemeng)
X    BUG. Inconsistant commands for quitting and returning to upper levels.
X    FIX. Standardised on 'Q' to quit tin & 'q' to quit to previous level.
X
X49) Murray Laing (murray@uk.ac.ed.chemeng)
X    BUG. Should allow groups to be specified as regex on command line.
X    FIX. main.c - changed code to do regex matching on specified groups.
X
X50) Jim Robinson (robinson@mdivax1.mdd.comm.mot.com)
X    BUG. show_page() returns an index into base[] but was been used as an
X         index into arts[].
X    FIX. thread.c - applied supplied patch.
X
X51) Tom Theel (tom@imd.sterling.com)
X    ADD. Applied supplied patch to allow reading news from CD-ROM.
X 
X52) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Articles in spooldir can be recieved out of order (not nice).
X    FIX. init.c - changed default sorting of articles to date ascending.
X
X    BUG. Usernames surrounded by "'s are shown like that on screen.
X    FIX. misc.c - changed parse_from() to parse out "'s from ("name").
X
X54) John Schmitz (schmitz@hpscdc.hp.com)
X    BUG. Manual page does not say that -u & -U options don't work if index
X         are retieved via NNTP.
X    FIX. tin.1 - added comment to clarify above.
X
X55) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. nntplib.h - added new #defines from NNTP 1.6 & CD-ROM SPOOLDIR.
X 
X56) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. SPOOLDIR defined from Makefile is not always used.
X    FIX. rcfile.c - spooldir variable was used in a much earlier version
X         of tin for something else (bitch cost 4 hours to find - sigh!)
X 
X57) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. With > 1000 arts viewing 1000 of 1000 overwrites part of displayed
X         page header info.
X    FIX. page.c signal.c - increased size of RIGHT_POS variable by 2.
X
X58) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. 'l' command to allow selection of different spooldir.
X
X59) Orest Zboroski (obz@sisd.Kodak.COM)
X    BUG. The interface for quitting from prompts sometimes uses a)bort
X         or e)xit. Its hard to remember & should always be the same.
X    FIX. Changed all prompts to use 'q' to abort current action.
X
X60) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Unreal errors that killed stack traces when debugging with sdb.
X    FIX. art.c - changed fread() in parse_header() to read buffer-1 chars.
END_OF_FILE
  if test 12810 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(12658 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for tin - for tin compiler flag options read INSTALL and README.
XEXE	= tin
XEXED	= tind
XBINDIR	= /usr/local/bin
XMANDIR	= /usr/man/man1
X
X# Define if you want the multi SPOOLDIR extensions & library
XCDROM	= -DCDROM_ABLE
X# sun01
X#CDLIB	= -ldbm -L/home/lea/.src/cllib/clientlib -lcllib 
X# anl433
XCDLIB	= /usr/local/src/cnews/dbz/dbz.o -L/usr/home/admin/iain/.src/cllib/clientlib -lcllib -lcposix
X
XCC	= cc
XSTRIP	= strip
XROFF	= + drf -F Helvetica -man3 
XPRINT	= -Pps0
XBASE_VER= ../112
XPATCH_VER = 113
XMAIL_ADDR = "iain%anl433.uucp@Germany.EU.net (Iain Lea)"
X
XHFILES	= tin.h extern.h nntplib.h proto.h
X
XCFILES	= active.c art.c curses.c debug.c feed.c getline.c group.c \
X		hashstr.c help.c inews.c init.c kill.c lang.c main.c memory.c \
X		misc.c newsrc.c nntplib.c open.c page.c post.c prompt.c \
X		rcfile.c save.c screen.c search.c select.c signal.c spooldir.c \
X		thread.c wildmat.c
X
XOFILES	= active.o art.o curses.o debug.o feed.o getline.o group.o \
X		hashstr.o help.o inews.o init.o kill.o lang.o main.o memory.o \
X		misc.o newsrc.o nntplib.o open.o page.o post.o prompt.o \
X		rcfile.o save.o screen.o search.o select.o signal.o spooldir.o \
X		thread.o wildmat.o 
X
XSUPPORT = Makefile MANIFEST README CHANGES INSTALL TODO FAQ FTP *.[13] $(EXE).nrf
X
XLINTFLAGS=-a -c -h -n -x 
X
X.c.o:
X	$(CC) $(CFLAGS) $*.c
X
Xall: 
X	@echo "There is no default. Specify one of the following targets."
X	@echo "    make bsd       (BSD/Dec/DG/Next/Sun)"
X	@echo "    make sysv      (SysV)"
X	@echo "    make sysvr4    (SysV R4)"
X	@echo "    make sco       (SCO Unix)"
X	@echo "    make aix       (IBM AIX)"
X	@echo "    make xenix     (Xenix 386)"
X	@echo "    make sinix     (SNI SysV)"
X	@echo "    make tower     (NCR Tower)"
X	@echo "    make minix     (Minix 386)"
X	@echo "    make ptx       (Sequent PTX)"
X	@echo "    make apollo    (Apollo Domain)"
X
X# For BSD-derived systems
Xbsd:
X	@echo "Compiling for BSD/Dec/DG/Next/Sun..."
X	@$(MAKE) CFLAGS='-c -O -DBSD -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# For System V
X#			 NETLIBS="-lnet -lnsl_s" \
X#
Xsysv:
X	@echo "Compiling for System V..."
X	@$(MAKE) CFLAGS='-c -O -DSYSV -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# For System V Release 4
X#			 NETLIBS="-lnsl -lsocket" \
X#
Xsysvr4:
X	@echo "Compiling for System V Release 4..."
X	@$(MAKE) CFLAGS='-c -O -DSVR4 -DPOSIX_JOB_CONTROL -DUSE_INVERSE_HACK -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermlib" \
X			 EXE=tin linkit
X
X# For SCO Unix
X#			 NETLIBS="-lnsl_s -lsocket" \
X#
Xsco:
X	@echo "Compiling for SCO Unix..."
X	@$(MAKE) CFLAGS='-c -O -DSYSV -DSCO_UNIX -UM_XENIX -DUSE_INVERSE_HACK -DLIBDIR="\"/usr/lib/news\"" -DSPOOLDIR="\"/usr/spool/news\""' \
X			 LIBS="-lcurses -lgen -lc_s" \
X			 EXE=tin linkit
X
X# For IBM AIX
Xaix:
X	@echo "Compiling for AIX..."
X	@$(MAKE) CFLAGS='-c -O -DSYSV -DRS6000 -DREAD_CHAR_HACK -DUSE_LONG_FILENAMES -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# For Xenix 386
X#			 NETLIBS="-lsocket" \
X#
Xxenix:
X	@echo "Compiling for Xenix 386..."
X	@$(MAKE) CFLAGS='-c -Zi -DSYSV -DLIBDIR="\\"/usr/lib/news\\"" -DSPOOLDIR="\\"/usr/spool/news\\""' \
X			 LIBS="-lcurses -ltinfo -lx" \
X			 LFLAGS=-Zi EXE=tin linkit
X
X# For SNI Sinix
Xsinix:
X	@echo "Compiling for SNI Sinix..."
X	@$(MAKE) CFLAGS='-c -O -DUSE_MKDIR -DLIBDIR=\\"/usr/lib/news\\" -DSPOOLDIR=\\"/usr/spool/news\\"' \
X			 LIBS="-lcurses" \
X			 EXE=tin linkit
X
X# For NCR Tower
X#			 NETLIBS="-lnet -lnsl_s" \
X#
Xtower:
X	@echo "Compiling for NCR Tower..."
X	@$(MAKE) CFLAGS='-c -O -DSYSV -DNCR -DISTRING -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# For Minix 386
Xminix:
X	@echo "Compiling for Minix 386..."
X	@$(MAKE) CFLAGS='-c -O -DMINIX -D_POSIX_SOURCE -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses" \
X			 EXE=tin linkit
X	chmem +131072 $(EXE) 
X
X# For Sequent PTX
X#			 NETLIBS="-lsocket -linet -lnsl_s" \
X#
Xptx:
X	@echo "Compiling for Sequent PTX..."
X	@$(MAKE) CFLAGS='-c -O -DPTX -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# For Apollo 
Xapollo:
X	@echo "Compiling for Apollo..."
X	@$(MAKE) CFLAGS='-c -O -DLIBDIR=\"/usr/lib/news\" -DSPOOLDIR=\"/usr/spool/news\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
X# !!!  THE FOLLOWING ARE SITE SPECIFIC - IGNORE  !!!
Xanl432:
X	@echo "Compiling for ANL432 with NNTP ONLY, NO POSTING, NO SHELL ESCAPE..."
X	@$(MAKE) CC=gcc CFLAGS='-c -O2 -Wall -DSYSV -DNNTP_ONLY -DNNTP_EXTS -DNO_POSTING -DNO_SHELL_ESCAPE  -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 NETLIBS="-linet -lnsl_s" \
X			 EXE=tin linkit
X
Xlocal:
X	@echo "Compiling for ANL433..."
X	@$(MAKE) CC=cc CFLAGS='-c -g -DSYSV -DDEBUG -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\"' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
Xanl433:
X	@echo "Compiling for ANL433 with NNTP..."
X	@$(MAKE) CC=gcc CFLAGS='-c -O2 -Wall -DSYSV -DNNTP_ABLE -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 NETLIBS="-linet -lnsl_s" \
X			 EXE=tin linkit
X
Xanl433cd:
X	@echo "Compiling for ANL433 with CDROM..."
X	@$(MAKE) CC=gcc CFLAGS='-c -O2 -Wall -DSYSV -DCDROM_ABLE -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap $(CDLIB)" \
X			 NETLIBS="-linet -lnsl_s" \
X			 EXE=tin linkit
X
Xapollo02:
X	@echo "Compiling for APOLLO02 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
Xos2unix:
X	@echo "Compiling for OS2UNIX with NNTP ONLY..."
X	@$(MAKE) CC=/usr2/gcc/bin/gcc CFLAGS='-c -O2 -Wall -DSYSV -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 NETLIBS="-linet -lnsl_s" \
X			 EXE=tin linkit
X
Xdaemon:
X	@echo "Compiling for ANL433 with INDEX DAEMON..."
X	@$(MAKE) CC=cc CFLAGS='-c -g -DSYSV -DINDEX_DAEMON -DDEBUG' \
X			 EXE=$(EXED) linkit
X
Xdec02:
X	@echo "Compiling for DEC02 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DBSD -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
Xdg01:
X	@echo "Compiling for DG01 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DBSD -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			LIBS="-lcurses -ltermcap" \
X			EXE=tin linkit
X
Xhome:
X	@echo "Compiling for (HOME) Xenix 386..."
X	@$(MAKE) CFLAGS='-c -W2 -Zi -DSYSV -DDEBUG -DLIBDIR="\\"/usr/lib/news\\"" -DSPOOLDIR="\\"/usr/spool/news\\""' \
X			 LIBS="-lcurses -ltinfo -lx" \
X			 LFLAGS=-Zi EXE=tin linkit
X
Xmx331:
X	@echo "Compiling for MX331 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\\"anl433\\" -DNNTP_INEWS_DOMAIN=\\".uucp\\" -DUSE_MKDIR -DDEBUG' \
X			 LIBS="-lcurses" \
X			 EXE=tin linkit
X
Xmx351:
X	@echo "Compiling for MX351 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DSVR4 -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DPOSIX_JOB_CONTROL -DUSE_INVERSE_HACK -DEBUG' \
X			 NETLIBS="-lnsl -lsocket" \
X			 LIBS="-lcurses -ltermlib" \
X			 EXE=tin linkit
X
Xsony01:
X	@echo "Compiling for SONY01 with NNTP ONLY..."
X	@$(MAKE) CC=gcc CFLAGS='-c -O2 -Wall -DBSD -DNNTP_ONLY -DLIBDIR=\"/a/usr/lib/news\" -DSPOOLDIR=\"/a/usr/spool/news\" -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			LIBS="-lcurses -ltermcap" \
X			EXE=tin linkit
X
Xsun01:
X	@echo "Compiling for SUN01 with NNTP ONLY..."
X	@$(MAKE) CFLAGS='-c -O -DBSD -DNNTP_ONLY -DNNTP_INEWS_GATEWAY=\"anl433\" -DNNTP_INEWS_DOMAIN=\".uucp\" -DDEBUG' \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
Xsun01cd:
X	@echo "Compiling for SUN01 with CDROM ABLE..."
X	@$(MAKE) CFLAGS='-c -g -DBSD -DCDROM_ABLE -DLIBDIR=\"/home/sun02/iain/lib\" -DDEBUG' \
X 			 NNTPLIB="$(CDLIB)" \
X			 LIBS="-lcurses -ltermcap" \
X			 EXE=tin linkit
X
Xlinkit: $(OFILES)
X	@echo "Linking $(EXE)..."
X	$(CC) $(LFLAGS) -o $(EXE) $(OFILES) $(NNTPLIB) $(NETLIBS) $(LIBS) 
X	@ls -l $(EXE)
X
Xinstall:
X	@echo "Installing $(EXE)..."
X	@$(STRIP) $(EXE)
X	@-mv $(EXE) $(BINDIR)
X	@-rm $(BINDIR)/r$(EXE)
X	@ln $(BINDIR)/$(EXE) $(BINDIR)/r$(EXE)
X	@chmod 755 $(BINDIR)/$(EXE) $(BINDIR)/r$(EXE)  
X	@ls -l $(BINDIR)/$(EXE) $(BINDIR)/r$(EXE)
X	@cp $(EXE).1 $(MANDIR)
X
Xinstall_setuid:
X	@echo "Installing SETUID $(EXE)..."
X	@$(STRIP) $(EXE)
X	@-mv $(EXE) $(BINDIR)
X	@chown news $(BINDIR)/$(EXE) 
X	@chown news $(BINDIR)/r$(EXE) 
X	@chgrp news $(BINDIR)/$(EXE) 
X	@chgrp news $(BINDIR)/r$(EXE) 
X	@-rm $(BINDIR)/r$(EXE)
X	@ln $(BINDIR)/$(EXE) $(BINDIR)/r$(EXE)
X	@su news -c "chmod 6755 $(BINDIR)/$(EXE)"
X	@su news -c "chmod 6755 $(BINDIR)/r$(EXE)"
X	@ls -l $(BINDIR)/$(EXE) $(BINDIR)/r$(EXE)
X	@cp $(EXE).1 $(MANDIR)
X
Xinstall_daemon:
X	@echo "Installing index daemon $(EXED)..."
X	@$(STRIP) $(EXED)
X	@-mv $(EXED) $(BINDIR)
X	@chown news $(BINDIR)/$(EXED) 
X	@chmod 0755 $(BINDIR)/$(EXED)"
X	@ls -l $(BINDIR)/$(EXED)
X
Xproto:
X	@echo "Generating function prototypes for proto.h..."
X	@echo "#if __STDC__" > PROTO.H
X	@echo " " >> PROTO.H
X	@cproto -e $(CFILES) >> PROTO.H
X	@echo " " >> PROTO.H
X	@echo "#else" >> PROTO.H
X	@echo " " >> PROTO.H
X	@cproto -e -f1 $(CFILES) >> PROTO.H
X	@echo " " >> PROTO.H
X	@echo "#endif" >> PROTO.H
X	@-mv PROTO.H proto.h
X
Xnroff:
X	@echo "Creating nroff man page..."
X	@nroff -man $(EXE).1 > $(EXE).nrf
X
Xmanifest:
X	@echo "Creating MANIFEST..."
X	@echo "MANIFEST for tin newsreader (`date`)" > MANIFEST
X	@echo "----------------------------------------------------------" >> MANIFEST
X	@wc -c $(SUPPORT) $(HFILES) patchlev.h $(CFILES) >> MANIFEST
X
Xshar:
X	@echo "Generating shell archive..."
X	@make nroff
X	@make manifest
X	@shar -a -n $(EXE)1.1 -s $(MAIL_ADDR) -L50 -o ../$(EXE).shar $(SUPPORT) $(CFILES) $(HFILES) patchlev.h
X
Xuuencode:
X	@make tar
X	@echo "Uuencoding $(EXE).tar.Z..."
X	@uuencode $(EXE).tar.Z $(EXE).tar.Z > $(EXE).tar.Z.uue
X	@ls -l $(EXE).tar.Z.uue
X 
Xdiff:
X	@echo "Generating diffs against $(BASE_VER)..."
X	@make nroff
X	@make manifest
X	@-mv -f $(EXE).diff $(EXE).diff-
X	@-diff -rcs $(BASE_VER) . > $(EXE).diff
X	@ls -l $(EXE).diff
X
Xpatch:
X	@make diff
X	@echo "Generating patch against $(BASE_VER)..."
X	@-mv $(EXE).diff $(EXE).patch$(PATCH_VER)
X	@shar -a -n $(EXE) -s $(MAIL_ADDR) -L50 -o ../patch$(PATCH_VER).shar $(EXE).patch$(PATCH_VER)
X	@ls -l ../patch$(PATCH_VER).shar*
X
Xtar:
X	@echo "Generating compressed tar file..."
X	@-rm $(EXE).tar $(EXE).tar.Z > /dev/null 2>&1
X	@tar cvf $(EXE).tar $(SUPPORT) $(CFILES) $(HFILES) patchlev.h 
X	@echo "Compressing $(EXE).tar..."
X	@compress $(EXE).tar 
X	@ls -l $(EXE).tar.Z
X
Xzoo:
X	@echo "Generating zoo archive file..."
X	@-rm $(EXE).zoo > /dev/null 2>&1
X	@zoo ah $(EXE).zoo  $(SUPPORT) $(CFILES) $(HFILES) patchlev.h
X	@ls -l $(EXE).zoo
X
Xtags:
X	@echo "Generating tags (results in ./tags)..."
X	@-rm tags
X	@ctags $(HFILES) patchlev.h $(CFILES) 
X
Xlint:
X	@echo "Linting source (results in ./LINT)..."
X	@lint $(LINTFLAGS) -DNNTP_ABLE $(CFILES) > LINT
X
Xclean:
X	@echo "Cleaning..."
X	@-'rm' -rf $(OFILES) '#*' $(EXE).diff*
X
Xclobber:
X	@echo "Clobbering..."
X	@-'rm' -rf $(OFILES) '#*' tags $(EXE) $(EXE).diff* patch.shar*
X
Xcflow:
X	@echo "Creating cflow for $(EXE)..."
X	@cflow $(CFILES) > cflow.$(EXE) &
X
Xcscope:
X	@echo "Creating cscope database $(EXE)..."
X	@cscope $(SUPPORT) $(HFILES) patchlev.h $(CFILES)
X
Xman:
X	@echo "Printing $(EXE) manual to $(PRINT)..."
X	@$(ROFF) $(PRINT) $(EXE).1
X
Xprint:
X	/bin/sh for FILE in $(HFILES) patchlev.h $(CFILES) $(SUPPORT); do \
X	echo "Printing $$FILE to $(PRINT)..."; \
X	a2ps -t4 $$FILE | lpr; \
X	done
X
Xactive.o:	active.c $(HFILES)
Xart.o:		art.c $(HFILES)
Xcurses.o:	curses.c $(HFILES)
Xdebug.o:	debug.c $(HFILES)
Xfeed.o:		feed.c $(HFILES)
Xgetline.o:	getline.c $(HFILES)
Xgroup.o:	group.c $(HFILES)
Xhashstr.o:	hashstr.c $(HFILES)
Xhelp.o:		help.c $(HFILES)
Xinews.o:	inews.c $(HFILES)
Xinit.o:		init.c $(HFILES)
Xkill.o:		kill.c $(HFILES)
Xlang.o:		lang.c $(HFILES)
Xmain.o:		main.c $(HFILES) patchlev.h
Xmemory.o:	memory.c $(HFILES)
Xmisc.o:		misc.c $(HFILES)
Xnewsrc.o:	newsrc.c $(HFILES)
Xnntplib.o:	nntplib.c $(HFILES)
Xopen.o:		open.c nntplib.h
Xpage.o:		page.c $(HFILES)
Xpost.o:		post.c $(HFILES)
Xprompt.o:	prompt.c $(HFILES)
Xrcfile.o:	rcfile.c $(HFILES)
Xsave.o:		save.c $(HFILES)
Xscreen.o:	screen.c $(HFILES)
Xsearch.o:	search.c $(HFILES)
Xselect.o:	select.c $(HFILES)
Xsignal.o:	signal.c $(HFILES)
Xspooldir.o:	spooldir.c $(HFILES)
Xthread.o:	thread.c $(HFILES)
Xwildmat.o:	wildmat.c
END_OF_FILE
  if test 12658 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'kill.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kill.c'\"
else
  echo shar: Extracting \"'kill.c'\" \(11832 characters\)
  sed "s/^X//" >'kill.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : kill.c
X *  Author    : I.Lea & J.Robinson
X *  Created   : 01-04-91
X *  Updated   : 10-05-92
X *  Notes     : kill & auto select (hot) articles
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Jim Robinson
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X#ifdef NO_REGEX 
Xchar *stars = "";
X#else		
Xchar *stars = "*";
X#endif
X
X#define SET_KILLED(i)		(arts[i].unread = ART_READ, arts[i].killed = 1, num_of_killed_arts++)
X#define SET_HOT(i)		(arts[i].hot = 1, num_of_hot_arts++)
X#define IS_READ(i)		(arts[i].unread == ART_READ)
X#define IS_KILLED(i)		(arts[i].killed == 1)
X
X#define KILL_CHAR	'K'
X#define HOT_CHAR	'H'
X
X#define K_KILL		0
X#define K_HOT		1
X
Xint kill_level = 1;
Xint kill_num = 0;
Xint max_kill;
Xstruct kill_t *killf;
X
X/*
X *  read_kill_file - read ~/.tin/kill file contents into kill array
X */
X
Xint read_kill_file ()
X{
X	char buf[LEN];
X	FILE *fp;
X	int n;
X	char c;
X	unsigned int type;
X
X	free_kill_array ();
X	
X	set_real_uid_gid ();
X
X	if ((fp = fopen (killfile, "r")) == NULL) {
X		set_tin_uid_gid ();
X		return FALSE;
X	}
X
X	kill_num=0;
X	while (fgets (buf, sizeof buf, fp) != NULL) {
X		if (buf[0] == '#') {
X			continue;
X		}	
X		if (kill_num == max_kill-1) {
X			expand_kill ();
X		}
X		n = sscanf(buf, "%d %c", &type, &c);
X		if (n == 0) {
X			goto corrupt_killfile;
X		}	
X		if (n > 1 && c == HOT_CHAR) {	/* hot */
X			 killf[kill_num].kill_how = K_HOT;
X		} else {
X			 killf[kill_num].kill_how = K_KILL;
X		}	 
X		killf[kill_num].kill_type = type;
X
X		if (fgets (buf, sizeof buf, fp) == NULL)  {
X			goto corrupt_killfile;
X		}
X		
X		killf[kill_num].kill_group = (long) atol (buf);
X
X		switch (killf[kill_num].kill_type) {
X		case KILL_SUBJ:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_subj = str_dup (buf);
X			}
X			break;
X		case KILL_FROM:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_from = str_dup (buf);
X			}
X			break;
X		case KILL_BOTH:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_subj = str_dup (buf);
X			}
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_from = str_dup (buf);
X			}
X			break;
X		default:
X			goto corrupt_killfile;
X		}
X		kill_num++;
X	}
X
X	fclose (fp);
X	set_tin_uid_gid ();
X	return (kill_num);
X
Xcorrupt_killfile:
X	fclose (fp);
X	killf[kill_num].kill_type = 0;
X	error_message (txt_corrupt_kill_file, killfile);
X	set_tin_uid_gid ();
X	return FALSE;
X}
X
X/*
X *  write_kill_file - write kill strings to ~/.tin/kill
X */
X
Xvoid write_kill_file ()
X{
X	FILE *fp;
X	int i;
X	
X	set_real_uid_gid ();
X
X	if (kill_num == 0 || (fp = fopen (killfile, "w")) == NULL) {
X		set_tin_uid_gid ();
X		return;
X	}
X
X	wait_message (txt_saving);
X	fprintf (fp, "# 1st line  1=(Subject: only)  2=(From: only)  3=(Subject: & From:)\n");
X	fprintf (fp, "#           %c=(kill) %c=(auto-selection)\n", KILL_CHAR, HOT_CHAR);
X	fprintf (fp, "# 2nd line  0=(kill on all newsgroups)  >0=(kill on specific newsgroup)\n");
X	for (i=0 ; i < kill_num ; i++) {
X		if (killf[i].kill_type == 0 || (killf[i].kill_subj == 0 
X		    &&  killf[i].kill_from == 0)) 
X			continue;
X
X		if (killf[i].kill_how == K_KILL) {
X			fprintf (fp, "#\n# %03d KILL\n", i+1);
X			fprintf (fp, "%d\t%c\n", killf[i].kill_type, KILL_CHAR);
X		} else {
X			fprintf (fp, "#\n# %03d HOT\n", i+1);
X			fprintf (fp, "%d\t%c\n", killf[i].kill_type, HOT_CHAR);
X		}	
X		fprintf (fp, "%ld\n", killf[i].kill_group);
X
X		switch (killf[i].kill_type) {
X			case KILL_SUBJ:
X				fprintf (fp, "%s\n", killf[i].kill_subj);
X				break;
X			case KILL_FROM:
X				fprintf (fp, "%s\n", killf[i].kill_from);
X				break;
X			case KILL_BOTH:
X				fprintf (fp, "%s\n", killf[i].kill_subj);
X				fprintf (fp, "%s\n", killf[i].kill_from);
X				break;
X		}
X	}
X
X	fclose (fp);
X	chmod (killfile, 0600);
X
X	set_tin_uid_gid ();
X}
X
Xstatic int get_choice (x, help, prompt, opt1, opt2, opt3, opt4)
X	int x;
X	char *help, *prompt, *opt1, *opt2, *opt3, *opt4;
X{
X	int ch, n = 0, i = 0;
X	char *argv[4];
X	
X	if (opt1)
X		argv[n++] = opt1;
X	if (opt2)
X		argv[n++] = opt2;
X	if (opt3)
X		argv[n++] = opt3;
X	if (opt4)
X		argv[n++] = opt4;
X	assert(n > 0);
X
X	if (help)
X		show_menu_help (help);
X		
X	do {
X		MoveCursor(x, (int) strlen (prompt));
X		fputs (argv[i], stdout);
X		fflush (stdout);
X		CleartoEOLN (); 
X		if ((ch = ReadCh ()) != ' ')
X			continue;
X		if (++i == n)
X			i = 0;
X	} while (ch != CR && ch != ESC);
X
X	if (ch == ESC)
X		return (-1);
X	return (i);
X}
X
X/*
X *  options menu so that the user can dynamically change parameters
X */
X 
Xint kill_art_menu (group_name, index)
X	char *group_name;
X	int index;
X{
X	char buf[LEN];
X	char text[LEN];
X	char kill_from[LEN];
X	char kill_subj[LEN];
X	char kill_group[LEN];
X	char ch_default = 's';
X	int ch;
X	int counter = 0;
X	int killed = TRUE;
X	int kill_from_ok = FALSE;
X	int kill_subj_ok = FALSE;
X	int kill_every_group = FALSE;
X	int i;
X	int kill_how;
X
X#ifdef SIGTSTP
X	sigtype_t (*susp)() = (sigtype_t *) 0;
X
X	if (do_sigtstp) {
X		susp = sigdisp (SIGTSTP, SIG_DFL);
X		sigdisp (SIGTSTP, SIG_IGN);
X	}
X#endif
X	
X	sprintf (kill_group, "%s only", group_name);
X	sprintf (kill_subj, txt_kill_subject, COLS-35, COLS-35, arts[index].subject);
X	if (arts[index].name != (char *) 0) {
X		sprintf (text, "%s (%s)", arts[index].from, arts[index].name);
X	} else {
X		strcpy (text, arts[index].from);
X	}
X	sprintf (kill_from, txt_kill_from, COLS-35, COLS-35, text);
X	text[0] = '\0';
X	
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_kill_menu);
X	
X	MoveCursor (INDEX_TOP, 0);
X	printf ("%s\r\n\r\n\r\n", txt_kill_how);
X	printf ("%s\r\n\r\n", txt_kill_text);
X	printf ("%s\r\n\r\n\r\n", txt_kill_text_type);
X	printf ("%s\r\n\r\n", kill_subj);
X	printf ("%s\r\n\r\n\r\n", kill_from);
X	printf ("%s%s", txt_kill_group, kill_group);
X	fflush (stdout);
X
X	i = get_choice (INDEX_TOP, txt_help_kill_how, txt_kill_how, 
X		       "Kill       ", "Auto Select", NULL, NULL);
X	if (i == -1) {
X		return FALSE;
X	}	
X	kill_how = (i == 0 ? K_KILL : K_HOT);
X
X	show_menu_help (txt_help_kill_text);
X	
X	if (! prompt_menu_string (INDEX_TOP+3, (int) strlen (txt_kill_text), text)) {
X		return FALSE;
X	}
X
X	if (text[0]) {
X		i = get_choice(INDEX_TOP+5, txt_help_kill_text_type, 
X			       txt_kill_text_type, "Subject: line only    ", 
X			       "From: line only       ", "Subject: & From: lines", 
X			       NULL);
X		if (i == -1) {
X			return FALSE;
X		}	
X		counter = ((i == 0 ? KILL_SUBJ : (i == 1 ? KILL_FROM : KILL_BOTH)));
X	}
X
X	if (! text[0]) {
X		i = get_choice (INDEX_TOP+8, txt_help_kill_subject, 
X			        kill_subj, "Yes", "No ", NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		} else {
X			kill_subj_ok = (i ? FALSE : TRUE);
X		}
X		i = get_choice (INDEX_TOP+10, txt_help_kill_from, 
X			        kill_from, "No ", "Yes", NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		} else {
X			kill_from_ok = (i ? TRUE : FALSE);
X		}
X	}
X
X	if (text[0] || kill_subj_ok || kill_from_ok) {
X		i = get_choice (INDEX_TOP+13, txt_help_kill_group, 
X			       txt_kill_group, kill_group, "All groups", 
X			       NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		}	
X		kill_every_group = (i == 0 ? FALSE : TRUE);
X	}
X
X	while (1) {
X		do {
X			sprintf (msg, "%s%c", txt_quit_edit_save_killfile, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (txt_quit_edit_save_killfile));
X			if ((ch = ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'q' && ch != 'e' && ch != 's');
X		switch (ch) {
X		case 'e':
X			start_line_offset = 2;
X			invoke_editor (killfile);
X			unkill_all_articles ();
X			killed_articles = read_kill_file ();
X			killed = TRUE;
X			goto kill_done;
X
X		case 'a':
X		case ESC:
X			killed = FALSE;
X			goto kill_done;
X			
X		case 's':
X			if (kill_num > max_kill-1) {
X				expand_kill ();
X			}
X
X			killf[kill_num].kill_how = kill_how;
X
X			if (text[0]) {
X				sprintf (buf, "%s%s%s", stars, text, stars);
X				switch (counter) {
X				case KILL_SUBJ:
X					killf[kill_num].kill_subj = str_dup (buf);
X					break;
X				case KILL_FROM:
X					killf[kill_num].kill_from = str_dup (buf);
X					break;
X				case KILL_BOTH:
X					killf[kill_num].kill_subj = str_dup (buf);
X					killf[kill_num].kill_from = killf[kill_num].kill_subj; 
X					break;
X				}
X				killf[kill_num].kill_type = counter;
X				if (kill_every_group) {
X					killf[kill_num].kill_group = 0L;
X				} else {
X					killf[kill_num].kill_group = hash_s (group_name);
X				}
X				kill_num++;
X			} else {
X				if (kill_subj_ok) {
X					killf[kill_num].kill_type = KILL_SUBJ;
X					sprintf (buf, "%s%s%s", 
X						stars, arts[index].subject, stars);
X					killf[kill_num].kill_subj = str_dup (buf);
X				}
X				if (kill_from_ok) {
X					killf[kill_num].kill_type |= KILL_FROM;
X					if (arts[index].name != (char *) 0) {
X						sprintf (buf, "%s%s (%s)%s", 
X							stars, arts[index].from, arts[index].name, stars);
X					} else {
X						sprintf (buf, "%s%s%s", 
X							stars, arts[index].from, stars);
X					}
X					killf[kill_num].kill_from = str_dup (buf);
X				}
X				if (killf[kill_num].kill_type) {		
X					if (kill_every_group) {
X						killf[kill_num].kill_group= 0L;
X					} else {
X						killf[kill_num].kill_group= hash_s (group_name);
X					}
X					kill_num++;
X				}
X			}
X			write_kill_file ();
X			
X		kill_done:
X			
X#ifdef SIGTSTP
X			if (do_sigtstp) {
X				sigdisp (SIGTSTP, susp);
X			}
X#endif
X			return (killed);
X		}	
X	}
X	/* NOTREACHED */
X}
X
X
X/*
X * We assume that any articles which are tagged as killed are also
X * tagged as being read BECAUSE they were killed. So, we retag
X * them as being unread.
X */
X 
Xint unkill_all_articles ()
X{
X	int unkilled = FALSE;
X	register int i;
X
X	for (i=0 ; i < top ; i++) {
X		if (arts[i].killed) {
X			arts[i].killed = FALSE;
X			arts[i].unread = ART_UNREAD;
X			unkilled = TRUE;
X		}
X	}
X	num_of_killed_arts = 0;
X
X	return (unkilled);
X}
X
X
Xint kill_any_articles (group)
X	char *group;
X{
X	char buf[LEN];
X	int killed = FALSE;
X	int run_ok = FALSE;
X	int is_hot;
X	long newsgroup_hash;
X	register int i, j;
X
X	if (! kill_num) {
X		return (killed);
X	}
X
X	num_of_killed_arts = 0;
X	num_of_hot_arts = 0;
X
X	newsgroup_hash = hash_s (group);
X
X	for (i=0 ; i < kill_num ; i++) {
X		if (killf[i].kill_group == 0L ||
X		    killf[i].kill_group == newsgroup_hash) {
X			run_ok = TRUE;	
X		}
X	}
X	if (! run_ok) {
X		return (killed);
X	}
X	if (debug && ! update) {
X		wait_message (txt_killing_arts);
X	}
X	for (i=0 ; i < top ; i++) {
X		if (IS_READ(i) && kill_level == 0) {
X			continue;
X		}	
X		for (j=0 ; j < kill_num ; j++) {
X			if (killf[j].kill_group != 0L &&
X			    killf[j].kill_group != newsgroup_hash)
X				continue;
X
X			is_hot = (killf[j].kill_how == K_HOT ? TRUE : FALSE);
X			switch (killf[j].kill_type) {
X			case KILL_SUBJ:
X				if (STR_MATCH (arts[i].subject, killf[j].kill_subj)) {
X					if (!is_hot)
X						SET_KILLED(i);
X					else
X						SET_HOT(i);
X				}
X				break;
X			case KILL_FROM:
X				if (arts[i].name != (char *) 0) {
X					sprintf (buf, "%s (%s)", arts[i].from, arts[i].name);
X				} else {
X					strcpy (buf, arts[i].from);
X				}
X				if (STR_MATCH (buf, killf[j].kill_from)) {
X					if (!is_hot)
X						SET_KILLED(i);
X					else
X						SET_HOT(i);
X				}
X				break;
X			case KILL_BOTH:
X				if (STR_MATCH (arts[i].subject, killf[j].kill_subj)) {
X					if (!is_hot)
X						SET_KILLED(i);
X					else
X						SET_HOT(i);
X					break;		/* XXX ? - JBR */
X				}
X				if (arts[i].name != (char *) 0) {
X					sprintf (buf, "%s (%s)", arts[i].from, arts[i].name);
X				} else {
X					strcpy (buf, arts[i].from);
X				}
X
X				if (STR_MATCH (buf, killf[j].kill_from)) {
X					if (!is_hot)
X						SET_KILLED(i);
X					else
X						SET_HOT(i);
X				}
X				break;
X			}
X			if (IS_KILLED(i) || ! killed)
X				killed = TRUE;
X		}
X	}
X	return (killed);
X}
END_OF_FILE
  if test 11832 -ne `wc -c <'kill.c'`; then
    echo shar: \"'kill.c'\" unpacked with wrong size!
  fi
  # end of 'kill.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(12398 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : main.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 15-05-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X/*
X * OK lets start the ball rolling...
X */
X 
Xvoid main (argc, argv)
X	int argc;	
X	char *argv[];
X{
X	int created, i;
X	int start_groupnum = 0;
X
X	cmd_line = TRUE;
X	debug = 0;	/* debug OFF */
X
X	set_signal_handlers ();
X
X	basename (argv[0], progname);
X
X	sprintf (page_header, "%s %s PL%d", progname, VERSION, PATCHLEVEL); 	
X	sprintf (cvers, "%s (c) Copyright 1991-92 Iain Lea.", page_header);
X
X#if defined(NNTP_ONLY) || defined(CDROM_ONLY)
X	read_news_via_nntp = TRUE;
X#else
X	/* 
X	 * rtin/cdtin so read news remotely via NNTP 
X	 */
X	if (progname[0] == 'r' || (progname[0] == 'c' && progname[1] == 'd' )) {
X#		ifdef NNTP_ABLE			
X			read_news_via_nntp = TRUE;
X#		else
X			error_message (txt_option_not_enabled, "-DNNTP_ABLE");
X			exit (1);
X#		endif
X	}
X#endif
X
X	/*
X	 * set up char *'s: homedir, newsrc, etc. 
X	 */
X	init_selfinfo ();
X
X	/*
X	 * process command line options
X	 */
X	read_cmd_line_options (argc, argv);
X	if (update_fork || (update && verbose) || !update) {
X		error_message (cvers, "");
X	}
X
X	/*
X	 *  if specified connect to (cdrom pseudo) nntp server
X	 */
X	nntp_open ();
X
X	/*
X	 *  allocate initial array sizes
X	 */
X	init_alloc ();
X	hash_init ();
X
X	/*
X	 *  load the active file into active[]
X	 */
X	created = read_active_file ();
X
X	/*
X	 *  log username info to local/central logfile (NNTP XUSER)
X	 */
X	log_user ();
X
X	if (create_mail_save_dirs ()) {
X		write_rcfile ();
X	}	
X
X	if (optind < argc) {
X		while (optind < argc) {
X			for (i = 0 ; i < num_active ; i++) {
X				if (wildmat(active[i].name, argv[optind])) {		
X					if (add_group (active[i].name, TRUE) < 0) {
X						error_message (txt_not_in_active_file, active[i].name);
X					}
X				}	
X			}	
X			optind++;
X		}
X	} else {
X		backup_newsrc ();
X		read_newsrc (TRUE);
X		mark_unthreaded_groups ();
X	}
X
X	/*
X	 *  read in users kill/auto-select (hot) file
X	 */
X	killed_articles = read_kill_file ();
X	
X	/*
X	 *  check/start if any new/unread articles
X	 */
X	start_groupnum = check_for_any_new_news (check_any_unread, start_any_unread);
X
X	/*
X	 *  mail any new articles to specified user
X	 *  or
X	 *  save any new articles to savedir structure for later reading
X	 */
X	save_or_mail_new_news ();
X	
X	/*
X	 *  update index files
X	 */
X	update_index_files ();
X	
X	if (! InitScreen ()) {
X		error_message (txt_screen_init_failed, progname);
X		exit (1);
X	}
X
X	/*
X	 *   get screen size from termcap entry 
X	 */
X	ScreenSize (&LINES, &COLS);
X	cmd_line = FALSE;
X	Raw (TRUE);
X
X	/* 
X	 *  check & set actual screen size
X	 */
X	set_win_size (&LINES, &COLS);
X
X	/*
X	 *  check for any newly created newsgroups
X	 */
X	if (notify_new_groups && ! created) {
X		notify_groups ();
X	}
X
X	/*
X	 *  if first time print welcome screen
X	  and auto-subscribe
X	 *  to groups specified in /usr/lib/news/subscribe locally
X	 *  or via NNTP if reading news remotely (LIST SUBSCRIBE)
X	 */
X	if (created_rcdir && update == FALSE) {
X		show_intro_page ();
X	}
X	
X	selection_index (start_groupnum);
X
X	tin_done (0);
X}
X
X/*
X * process command line options
X */
X
Xvoid read_cmd_line_options (argc, argv)
X	int argc;
X	char *argv[];
X{
X	int ch;
X
X#ifdef INDEX_DAEMON
X	while ((ch = getopt (argc, argv, "D:f:hI:vV")) != EOF) {
X#else
X	while ((ch = getopt (argc, argv, "cD:f:hHI:m:M:np:rRs:SuUvVzZ")) != EOF) {
X#endif
X		switch (ch) {
X			case 'c':
X				catchup = TRUE;
X				update = TRUE;
X				break;
X				
X			case 'D':		/* debug mode 1=NNTP 2=ALL */
X#ifdef DEBUG			
X				redirect_output[0] = '\0';
X				debug = atoi (optarg);
X#else
X				error_message (txt_option_not_enabled, "-DDEBUG");
X				exit (1);
X#endif
X				break;
X
X			case 'f':
X				my_strncpy (newsrc, optarg, sizeof (newsrc));
X				break;
X
X			case 'H':
X				show_intro_page ();
X				exit (1);
X				break;
X
X#if !defined(NNTP_ONLY) || !defined(NNTP_XINDEX)
X			case 'I':
X				my_strncpy (indexdir, optarg, sizeof (indexdir));
X				mkdir (indexdir, 0777);
X				break;
X#endif
X			case 'm':
X				my_strncpy (default_maildir, optarg, sizeof (default_maildir));
X				break;
X
X			case 'M':	/* mail new news to specified user */
X				my_strncpy (mail_news_user, optarg, sizeof (mail_news_user));
X				mail_news = TRUE;
X				update = TRUE;
X				catchup = TRUE;
X				break;
X
X			case 'n':
X				notify_new_groups = TRUE;
X				break;
X
X			case 'p':
X				my_strncpy (cmd_line_printer, optarg, sizeof (cmd_line_printer));
X				default_printer = FALSE;
X				break;
X
X			case 'r':	/* read news remotely from default NNTP server */
X#ifdef NNTP_ABLE			
X				read_news_via_nntp = TRUE;
X#else
X				error_message (txt_option_not_enabled, "-DNNTP_ABLE");
X				exit (1);
X#endif
X				break;
X
X			case 'R':	/* read news saved by -S option */
X				error_message ("%s: Option -R not yet implemented.", progname);
X				exit (1);
X				break;
X
X			case 's':
X				my_strncpy (default_savedir, optarg, sizeof (default_savedir));
X				break;
X
X			case 'S':	/* save new news to dir structure */
X				save_news = TRUE;
X				update = TRUE;
X				break;
X
X			case 'u':	/* update index files */
X				update = TRUE;
X				break;
X
X			case 'U':	/* update index files in background */
X				update_fork = TRUE;
X				update = TRUE;
X				break;
X
X			case 'v':	/* verbose mode */
X				verbose = TRUE;
X				break;
X
X			case 'V':
X#if defined(__DATE__) && defined(__TIME__)			
X				sprintf (msg, "Version: %s PL%d  %s %s",
X					VERSION, PATCHLEVEL, __DATE__, __TIME__);
X#else
X				sprintf (msg, "Version: %s PL%d",
X					VERSION, PATCHLEVEL);
X#endif					
X				error_message (msg, "");
X				exit (1);
X				break;
X
X			case 'z':
X				start_any_unread = TRUE;
X				update = TRUE;
X				break;
X
X			case 'Z':
X				check_any_unread = TRUE;
X				update = TRUE;
X				break;
X
X			case 'h':
X			case '?':
X			default:
X				usage (progname);
X				exit (1);
X		}
X	}
X}
X
X/*
X * usage
X */
X
Xvoid usage (progname)
X	char *progname;
X{
X#ifndef INDEX_DAEMON
X	error_message ("%s A threaded Netnews reader.\n", cvers);
X#else
X	error_message ("%s Tin index file daemon.\n", cvers);
X#endif
X	error_message ("Usage: %s [options] [newsgroups]", progname);
X#ifndef INDEX_DAEMON
X	error_message ("  -c       mark all news as read in subscribed newsgroups (batch mode)", "");
X#endif
X	error_message ("  -f file  subscribed to newsgroups file [default=%s]", newsrc);
X	error_message ("  -h       help", "");
X#ifndef INDEX_DAEMON
X	error_message ("  -H       help information about %s", progname);
X#endif
X	error_message ("  -I dir   index file directory [default=%s]", indexdir);
X#ifndef INDEX_DAEMON
X	error_message ("  -m dir   mailbox directory [default=%s]", default_maildir);
X	error_message ("  -M user  mail new news to specified user (batch mode)", "");
X	error_message ("  -n       notify user of any newly created newsgroups", "");
X	error_message ("  -p file  print program with options [default=%s]", DEFAULT_PRINTER);
X#  if defined(NNTP_ABLE) && !defined(NNTP_ONLY)
X	if (! read_news_via_nntp) {
X		error_message ("  -r       read news remotely from default NNTP server", "");
X	}
X#  endif /* NNTP_ABLE */	
X	error_message ("  -R       read news saved by -S option (not yet implemented)", "");
X	error_message ("  -s dir   save news directory [default=%s]", default_savedir);
X	error_message ("  -S       save new news for later reading (batch mode)", "");
X#  if !defined(NNTP_ONLY) || !defined(NNTP_XINDEX)
X	error_message ("  -u       update index files (batch mode)", "");
X	error_message ("  -U       update index files in the background while reading news", "");
X#  endif /* NNTP_XINDEX */
X#endif /* INDEX_DAEMON */
X	error_message ("  -v       verbose output for batch mode options", "");
X#ifndef INDEX_DAEMON
X	error_message ("  -z       start if any unread news", "");
X	error_message ("  -Z       return status indicating if any unread news (batch mode)", "");
X#endif
X	error_message ("\nMail bug reports/comments to %s", BUG_REPORT_ADDRESS);
X}
X
X/*
X *  check/start if any new/unread articles
X */
X
Xint check_for_any_new_news (check_any_unread, start_any_unread)
X	int check_any_unread;
X	int start_any_unread;
X{
X	int i = 0;
X	
X	if (check_any_unread) {
X		i = check_start_save_any_news (CHECK_ANY_NEWS);
X		exit (i);
X	}
X	
X	if (start_any_unread) {
X		i = check_start_save_any_news (START_ANY_NEWS);
X		if (i == -1) {		/* no new/unread news so exit */
X			exit (0);
X		}
X		update = FALSE;
X	}
X	return (i);
X}
X
X/*
X *  mail any new articles to specified user
X *  or
X *  save any new articles to savedir structure for later reading
X */
X
Xvoid save_or_mail_new_news ()
X{
X	int i;
X	
X	if (mail_news || save_news) {
X		i = catchup;			/* set catchup to FALSE */
X		catchup = FALSE;
X		do_update ();
X		catchup = i;			/* set catchup to previous value */
X		if (mail_news) {
X			check_start_save_any_news (MAIL_ANY_NEWS);
X		} else {
X			check_start_save_any_news (SAVE_ANY_NEWS);
X		}
X		tin_done (0);
X	}
X}
X
X/*
X *  update index files
X */
X
Xvoid update_index_files ()
X{
X	if (update || update_fork) {
X		if (read_news_via_nntp && xindex_supported) {
X			error_message ("%s: Updating of index files not supported", progname);
X			tin_done (1);
X		}
X
X		COLS = 132;					/* set because curses has not started */ 
X		if (update_fork) {
X			catchup = FALSE;		/* turn off msgs when running forked */ 
X			verbose = FALSE;
X			switch (fork ()) {		/* fork child to update indexes in background */
X				case -1:	/* error forking */	
X					perror_message ("Failed to start background indexing process", "");
X					break;
X				case 0:		/* child process */	
X					process_id = getpid ();
X#ifdef BSD
X					setpgrp (0, process_id);	/* reset process group leader to this process */
X#	ifdef TIOCNOTTY
X					{
X						int fd;
X	
X						if ((fd = open ("/dev/tty", O_RDWR)) >= 0) {
X							ioctl (fd, TIOCNOTTY, (char *) NULL);
X							close (fd);
X						}	
X					}	
X#	endif
X#else
X					setpgrp ();
X					signal (SIGHUP, SIG_IGN);	/* make immune from process group leader death */
X#endif
X					signal (SIGQUIT, SIG_IGN);	/* stop indexing being interrupted */			
X					signal (SIGALRM, SIG_IGN);	/* stop indexing resyning active file */			
X					nntp_open ();			/* connect server if we are using nntp */
X					thread_arts = FALSE;	/* stop threading to run faster */
X					do_update ();
X					nntp_close ();			/* connect server if we are using nntp */
X					exit (0);
X					break;
X				default:	/* parent process*/
X					break;					
X			}	
X			update = FALSE;
X		} else {
X			thread_arts = FALSE;	/* stop threading to run faster */
X			do_update ();
X			exit (0);
X		}
X	}
X}
X
X/*
X *  display page of general info. for first time user.
X */
X
Xvoid show_intro_page ()
X{
X	if (cmd_line) {
X		wait_message (cvers); 	
X	} else {
X		ClearScreen ();
X		center_line (0, TRUE, cvers); 
X		Raw (FALSE);	
X	}
X
X	printf ("\n\nWelcome to tin, a full screen threaded Netnews reader. It can read news locally\n");
X	printf ("(ie. <spool>/news) or remotely (-r option) from a NNTP  (Network News Transport\n");
X	printf ("Protocol) server. tin -h lists the available command line options.\n\n");
X
X	printf ("Tin has four newsreading levels, the newsgroup selection page,  the group index\n");
X	printf ("page, the thread listing page and the article viewer. Help is available at each\n");
X	printf ("level by pressing the 'h' command.\n\n");
X
X	printf ("Move up/down by using the terminal arrow keys or 'j' and 'k'.  Use PgUp/PgDn or\n");
X	printf ("Ctrl-U and Ctrl-D to page up/down. Enter a newsgroup by pressing RETURN.\n\n");
X
X	printf ("Articles, threads, tagged articles or articles matching a pattern can be mailed\n");
X	printf ("('m' command), printed ('o' command), saved ('s' command), piped ('|' command).\n");
X	printf ("Use the 'w' command  to post  a news  article,  the 'f'/'F' commands to  post a\n");
X	printf ("follow-up  to  an existing  news article and the 'r'/'R' commands to  reply via\n");
X	printf ("mail to an existing news articles author.  The 'M' command allows the operation\n");
X	printf ("of tin to be configured via a menu.\n\n");
X
X	printf ("For more information read the manual page, README, INSTALL, TODO and FTP files.\n\n");
X	printf ("Please send bug reports/comments to the programs author with the 'B' command.\n");
X	fflush (stdout);
X
X	if (! cmd_line) {
X		Raw (TRUE);	
X		continue_prompt ();
X	}
X}
X
END_OF_FILE
  if test 12398 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
echo shar: End of archive 12 \(of 14\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
