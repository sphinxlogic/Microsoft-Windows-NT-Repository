Newsgroups: comp.sources.misc
From: lwall@netlabs.com (Larry Wall)
Subject:  v30i034:  perl - The perl programming language, Patch23
Message-ID: <1992Jun11.180236.274@sparky.imd.sterling.com>
X-Md4-Signature: 9ba8543c0d261ef89ac13147a64ef027
Date: Thu, 11 Jun 1992 18:02:36 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: lwall@netlabs.com (Larry Wall)
Posting-number: Volume 30, Issue 34
Archive-name: perl/patch23
Environment: UNIX, MS-DOS, OS2
Patch-To: perl: Volume 18, Issue 19-54

System: perl version 4.0
Patch #: 23
Priority: highish
Subject: patch #20, continued

Description:
	See patch #20.

Fix:	From rn, say "| patch -p -N -d DIR", where DIR is your perl source
	directory.  Outside of rn, say "cd DIR; patch -p -N <thisarticle".
	If you don't have the patch program, apply the following by hand,
	or get patch (version 2.0, latest patchlevel).

	After patching:
		*** DO NOTHING--INSTALL ALL PATCHES UP THROUGH #33 FIRST ***

	If patch indicates that patchlevel is the wrong version, you may need
	to apply one or more previous patches, or the patch may already
	have been applied.  See the patchlevel.h file to find out what has or
	has not been applied.  In any event, don't continue with the patch.

	If you are missing previous patches they can be obtained from me:

	Larry Wall
	lwall@netlabs.com

	If you send a mail message of the following form it will greatly speed
	processing:

	Subject: Command
	@SH mailpatch PATH perl 4.0 LIST
		   ^ note the c

	where PATH is a return path FROM ME TO YOU either in Internet notation,
	or in bang notation from some well-known host, and LIST is the number
	of one or more patches you need, separated by spaces, commas, and/or
	hyphens.  Saying 35- says everything from 35 to the end.


Index: patchlevel.h
Prereq: 22
1c1
< #define PATCHLEVEL 22
---
> #define PATCHLEVEL 23

Index: atarist/config.h
*** atarist/config.h.old	Mon Jun  8 17:35:07 1992
--- atarist/config.h	Mon Jun  8 17:35:07 1992
***************
*** 0 ****
--- 1,912 ----
+ #ifndef config_h
+ #define config_h
+ /* config.h
+  * This file was produced by running the config.h.SH script, which
+  * gets its values from config.sh, which is generally produced by
+  * running Configure.
+  *
+  * Feel free to modify any of this as the need arises.  Note, however,
+  * that running config.h.SH again will wipe out any changes you've made.
+  * For a more permanent change edit config.sh and rerun config.h.SH.
+  */
+  /*SUPPRESS 460*/
+ 
+ 
+ /* EUNICE
+  *	This symbol, if defined, indicates that the program is being compiled
+  *	under the EUNICE package under VMS.  The program will need to handle
+  *	things like files that don't go away the first time you unlink them,
+  *	due to version numbering.  It will also need to compensate for lack
+  *	of a respectable link() command.
+  */
+ /* VMS
+  *	This symbol, if defined, indicates that the program is running under
+  *	VMS.  It is currently only set in conjunction with the EUNICE symbol.
+  */
+ /*#undef	EUNICE		/**/
+ /*#undef	VMS		/**/
+ 
+ /* ALIGNBYTES
+  *	This symbol contains the number of bytes required to align a double.
+  *	Usual values are 2, 4, and 8.
+  */
+ #define ALIGNBYTES 2		/**/
+ 
+ /* BIN
+  *	This symbol holds the name of the directory in which the user wants
+  *	to keep publicly executable images for the package in question.  It
+  *	is most often a local directory such as /usr/local/bin.
+  */
+ #define BIN "/bin"             /**/
+ 
+ /* BYTEORDER
+  *	This symbol contains an encoding of the order of bytes in a long.
+  *	Usual values (in hex) are 0x1234, 0x4321, 0x2143, 0x3412...
+  */
+ #define BYTEORDER 0x4321		/**/
+ 
+ /* CPPSTDIN
+  *	This symbol contains the first part of the string which will invoke
+  *	the C preprocessor on the standard input and produce to standard
+  *	output.	 Typical value of "cc -E" or "/lib/cpp".
+  */
+ /* CPPMINUS
+  *	This symbol contains the second part of the string which will invoke
+  *	the C preprocessor on the standard input and produce to standard
+  *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
+  *	to specify standard input, otherwise the value is "".
+  */
+ #define CPPSTDIN "gcc -E"
+ #define CPPMINUS ""
+ 
+ /* HAS_BCMP
+  *	This symbol, if defined, indicates that the bcmp routine is available
+  *	to compare blocks of memory.  If undefined, use memcmp.  If that's
+  *	not available, roll your own.
+  */
+ #define	HAS_BCMP		/**/
+ 
+ /* HAS_BCOPY
+  *	This symbol, if defined, indicates that the bcopy routine is available
+  *	to copy blocks of memory.  Otherwise you should probably use memcpy().
+  *	If neither is defined, roll your own.
+  */
+ /* SAFE_BCOPY
+  *	This symbol, if defined, indicates that the bcopy routine is available
+  *	to copy potentially overlapping copy blocks of bcopy.  Otherwise you
+  *	should probably use memmove() or memcpy().  If neither is defined,
+  *	roll your own.
+  */
+ #define	HAS_BCOPY		/**/
+ #define	SAFE_BCOPY		/**/
+ 
+ /* HAS_BZERO
+  *	This symbol, if defined, indicates that the bzero routine is available
+  *	to zero blocks of memory.  Otherwise you should probably use memset()
+  *	or roll your own.
+  */
+ #define	HAS_BZERO		/**/
+ 
+ /* CASTNEGFLOAT
+  *	This symbol, if defined, indicates that this C compiler knows how to
+  *	cast negative or large floating point numbers to unsigned longs, ints
+  *	and shorts.
+  */
+ /* CASTFLAGS
+  *	This symbol contains flags that say what difficulties the compiler
+  *	has casting odd floating values to unsigned long:
+  *		1 = couldn't cast < 0
+  *		2 = couldn't cast >= 0x80000000
+  */
+ #define	CASTNEGFLOAT	/**/
+ #define	CASTFLAGS 0	/**/
+ 
+ /* CHARSPRINTF
+  *	This symbol is defined if this system declares "char *sprintf()" in
+  *	stdio.h.  The trend seems to be to declare it as "int sprintf()".  It
+  *	is up to the package author to declare sprintf correctly based on the
+  *	symbol.
+  */
+ /* #define	CHARSPRINTF 	/**/
+ 
+ /* HAS_CHSIZE
+  *	This symbol, if defined, indicates that the chsize routine is available
+  *	to truncate files.  You might need a -lx to get this routine.
+  */
+ /*#undef	HAS_CHSIZE		/**/
+ 
+ /* HAS_CRYPT
+  *	This symbol, if defined, indicates that the crypt routine is available
+  *	to encrypt passwords and the like.
+  */
+ /* #define	HAS_CRYPT		/**/
+ 
+ /* CSH
+  *	This symbol, if defined, indicates that the C-shell exists.
+  *	If defined, contains the full pathname of csh.
+  */
+ /* #define CSH "/bin/csh"		/**/
+ 
+ /* DOSUID
+  *	This symbol, if defined, indicates that the C program should
+  *	check the script that it is executing for setuid/setgid bits, and
+  *	attempt to emulate setuid/setgid on systems that have disabled
+  *	setuid #! scripts because the kernel can't do it securely.
+  *	It is up to the package designer to make sure that this emulation
+  *	is done securely.  Among other things, it should do an fstat on
+  *	the script it just opened to make sure it really is a setuid/setgid
+  *	script, it should make sure the arguments passed correspond exactly
+  *	to the argument on the #! line, and it should not trust any
+  *	subprocesses to which it must pass the filename rather than the
+  *	file descriptor of the script to be executed.
+  */
+ /*#undef DOSUID		/**/
+ 
+ /* HAS_DUP2
+  *	This symbol, if defined, indicates that the dup2 routine is available
+  *	to dup file descriptors.  Otherwise you should use dup().
+  */
+ #define	HAS_DUP2		/**/
+ 
+ /* HAS_FCHMOD
+  *	This symbol, if defined, indicates that the fchmod routine is available
+  *	to change mode of opened files.  If unavailable, use chmod().
+  */
+ /* #define	HAS_FCHMOD		/**/
+ 
+ /* HAS_FCHOWN
+  *	This symbol, if defined, indicates that the fchown routine is available
+  *	to change ownership of opened files.  If unavailable, use chown().
+  */
+ /* #define	HAS_FCHOWN		/**/
+ 
+ /* HAS_FCNTL
+  *	This symbol, if defined, indicates to the C program that
+  *	the fcntl() function exists.
+  */
+ /* #define	HAS_FCNTL		/**/
+ 
+ /* FLEXFILENAMES
+  *	This symbol, if defined, indicates that the system supports filenames
+  *	longer than 14 characters.
+  */
+ /* #define	FLEXFILENAMES		/**/
+ 
+ /* HAS_FLOCK
+  *	This symbol, if defined, indicates that the flock() routine is
+  *	available to do file locking.
+  */
+ /* #define	HAS_FLOCK		/**/
+ 
+ /* HAS_GETGROUPS
+  *	This symbol, if defined, indicates that the getgroups() routine is
+  *	available to get the list of process groups.  If unavailable, multiple
+  *	groups are probably not supported.
+  */
+ /* #define	HAS_GETGROUPS		/**/
+ 
+ /* HAS_GETHOSTENT
+  *	This symbol, if defined, indicates that the gethostent() routine is
+  *	available to lookup host names in some data base or other.
+  */
+ /* #define	HAS_GETHOSTENT		/**/
+ 
+ /* HAS_GETPGRP
+  *	This symbol, if defined, indicates that the getpgrp() routine is
+  *	available to get the current process group.
+  */
+ #define	HAS_GETPGRP		/**/
+ 
+ /* HAS_GETPGRP2
+  *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
+  *	routine is available to get the current process group.
+  */
+ /*#undef	HAS_GETPGRP2		/**/
+ 
+ /* HAS_GETPRIORITY
+  *	This symbol, if defined, indicates that the getpriority() routine is
+  *	available to get a process's priority.
+  */
+ /* #define	HAS_GETPRIORITY		/**/
+ 
+ /* HAS_HTONS
+  *	This symbol, if defined, indicates that the htons routine (and friends)
+  *	are available to do network order byte swapping.
+  */
+ /* HAS_HTONL
+  *	This symbol, if defined, indicates that the htonl routine (and friends)
+  *	are available to do network order byte swapping.
+  */
+ /* HAS_NTOHS
+  *	This symbol, if defined, indicates that the ntohs routine (and friends)
+  *	are available to do network order byte swapping.
+  */
+ /* HAS_NTOHL
+  *	This symbol, if defined, indicates that the ntohl routine (and friends)
+  *	are available to do network order byte swapping.
+  */
+ /* #define	HAS_HTONS	/**/
+ /* #define	HAS_HTONL	/**/
+ /* #define	HAS_NTOHS	/**/
+ /* #define	HAS_NTOHL	/**/
+ 
+ /* index
+  *	This preprocessor symbol is defined, along with rindex, if the system
+  *	uses the strchr and strrchr routines instead.
+  */
+ /* rindex
+  *	This preprocessor symbol is defined, along with index, if the system
+  *	uses the strchr and strrchr routines instead.
+  */
+ /* #define	index strchr	/* cultural */
+ /* #define	rindex strrchr	/*  differences? */
+ #include <string.h>
+ 
+ /* HAS_ISASCII
+  *	This symbol, if defined, indicates that the isascii routine is available
+  *	to test characters for asciiness.
+  */
+ #define	HAS_ISASCII		/**/
+ 
+ /* HAS_KILLPG
+  *	This symbol, if defined, indicates that the killpg routine is available
+  *	to kill process groups.  If unavailable, you probably should use kill
+  *	with a negative process number.
+  */
+ /* #define	HAS_KILLPG		/**/
+ 
+ /* HAS_LSTAT
+  *	This symbol, if defined, indicates that the lstat() routine is
+  *	available to stat symbolic links.
+  */
+ #define	HAS_LSTAT		/**/
+ 
+ /* HAS_MEMCMP
+  *	This symbol, if defined, indicates that the memcmp routine is available
+  *	to compare blocks of memory.  If undefined, roll your own.
+  */
+ #define	HAS_MEMCMP		/**/
+ 
+ /* HAS_MEMCPY
+  *	This symbol, if defined, indicates that the memcpy routine is available
+  *	to copy blocks of memory.  Otherwise you should probably use bcopy().
+  *	If neither is defined, roll your own.
+  */
+ /* SAFE_MEMCPY
+  *	This symbol, if defined, indicates that the memcpy routine is available
+  *	to copy potentially overlapping copy blocks of memory.  Otherwise you
+  *	should probably use memmove() or bcopy().  If neither is defined,
+  *	roll your own.
+  */
+ #define	HAS_MEMCPY		/**/
+ /*#undef	SAFE_MEMCPY		/**/
+ 
+ /* HAS_MEMMOVE
+  *	This symbol, if defined, indicates that the memmove routine is available
+  *	to move potentially overlapping blocks of memory.  Otherwise you
+  *	should use bcopy() or roll your own.
+  */
+ /*#undef	HAS_MEMMOVE		/**/
+ 
+ /* HAS_MEMSET
+  *	This symbol, if defined, indicates that the memset routine is available
+  *	to set a block of memory to a character.  If undefined, roll your own.
+  */
+ #define	HAS_MEMSET		/**/
+ 
+ /* HAS_MKDIR
+  *	This symbol, if defined, indicates that the mkdir routine is available
+  *	to create directories.  Otherwise you should fork off a new process to
+  *	exec /bin/mkdir.
+  */
+ #define	HAS_MKDIR		/**/
+ 
+ /* HAS_MSG
+  *	This symbol, if defined, indicates that the entire msg*(2) library is
+  *	supported.
+  */
+ /* #define	HAS_MSG		/**/
+ 
+ /* HAS_MSGCTL
+  *	This symbol, if defined, indicates that the msgctl() routine is
+  *	available to control message passing.
+  */
+ /* #define	HAS_MSGCTL		/**/
+ 
+ /* HAS_MSGGET
+  *	This symbol, if defined, indicates that the msgget() routine is
+  *	available to get messages.
+  */
+ /* #define	HAS_MSGGET		/**/
+ 
+ /* HAS_MSGRCV
+  *	This symbol, if defined, indicates that the msgrcv() routine is
+  *	available to receive messages.
+  */
+ /* #define	HAS_MSGRCV		/**/
+ 
+ /* HAS_MSGSND
+  *	This symbol, if defined, indicates that the msgsnd() routine is
+  *	available to send messages.
+  */
+ /* #define	HAS_MSGSND		/**/
+ 
+ /* HAS_NDBM
+  *	This symbol, if defined, indicates that ndbm.h exists and should
+  *	be included.
+  */
+ /* #define	HAS_NDBM		/**/
+ 
+ /* HAS_ODBM
+  *	This symbol, if defined, indicates that dbm.h exists and should
+  *	be included.
+  */
+ /* #define	HAS_ODBM		/**/
+ 
+ /* HAS_OPEN3
+  *	This manifest constant lets the C program know that the three
+  *	argument form of open(2) is available.
+  */
+ #define	HAS_OPEN3		/**/
+ 
+ /* HAS_READDIR
+  *	This symbol, if defined, indicates that the readdir routine is available
+  *	from the C library to read directories.
+  */
+ #define	HAS_READDIR		/**/
+ 
+ /* HAS_RENAME
+  *	This symbol, if defined, indicates that the rename routine is available
+  *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
+  *	trick.
+  */
+ #define	HAS_RENAME		/**/
+ 
+ /* HAS_REWINDDIR
+  *	This symbol, if defined, indicates that the rewindir routine is
+  *	available to rewind directories.
+  */
+ #define	HAS_REWINDDIR		/**/
+ 
+ /* HAS_RMDIR
+  *	This symbol, if defined, indicates that the rmdir routine is available
+  *	to remove directories.  Otherwise you should fork off a new process to
+  *	exec /bin/rmdir.
+  */
+ #define	HAS_RMDIR		/**/
+ 
+ /* HAS_SEEKDIR
+  *	This symbol, if defined, indicates that the seekdir routine is
+  *	available to seek into directories.
+  */
+ #define	HAS_SEEKDIR		/**/
+ 
+ /* HAS_SELECT
+  *	This symbol, if defined, indicates that the select() subroutine
+  *	exists.
+  */
+ /* #define	HAS_SELECT	/**/
+ 
+ /* HAS_SEM
+  *	This symbol, if defined, indicates that the entire sem*(2) library is
+  *	supported.
+  */
+ /* #define	HAS_SEM		/**/
+ 
+ /* HAS_SEMCTL
+  *	This symbol, if defined, indicates that the semctl() routine is
+  *	available to control semaphores.
+  */
+ /* #define	HAS_SEMCTL		/**/
+ 
+ /* HAS_SEMGET
+  *	This symbol, if defined, indicates that the semget() routine is
+  *	available to get semaphores ids.
+  */
+ /* #define	HAS_SEMGET		/**/
+ 
+ /* HAS_SEMOP
+  *	This symbol, if defined, indicates that the semop() routine is
+  *	available to perform semaphore operations.
+  */
+ /* #define	HAS_SEMOP		/**/
+ 
+ /* HAS_SETEGID
+  *	This symbol, if defined, indicates that the setegid routine is available
+  *	to change the effective gid of the current program.
+  */
+ #define	HAS_SETEGID		/**/
+ 
+ /* HAS_SETEUID
+  *	This symbol, if defined, indicates that the seteuid routine is available
+  *	to change the effective uid of the current program.
+  */
+ #define	HAS_SETEUID		/**/
+ 
+ /* HAS_SETPGRP
+  *	This symbol, if defined, indicates that the setpgrp() routine is
+  *	available to set the current process group.
+  */
+ #define	HAS_SETPGRP		/**/
+ 
+ /* HAS_SETPGRP2
+  *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
+  *	routine is available to set the current process group.
+  */
+ /*#undef	HAS_SETPGRP2		/**/
+ 
+ /* HAS_SETPRIORITY
+  *	This symbol, if defined, indicates that the setpriority() routine is
+  *	available to set a process's priority.
+  */
+ /* #define	HAS_SETPRIORITY		/**/
+ 
+ /* HAS_SETREGID
+  *	This symbol, if defined, indicates that the setregid routine is
+  *	available to change the real and effective gid of the current program.
+  */
+ /* HAS_SETRESGID
+  *	This symbol, if defined, indicates that the setresgid routine is
+  *	available to change the real, effective and saved gid of the current
+  *	program.
+  */
+ /* #define	HAS_SETREGID		/**/
+ /*#undef	HAS_SETRESGID		/**/
+ 
+ /* HAS_SETREUID
+  *	This symbol, if defined, indicates that the setreuid routine is
+  *	available to change the real and effective uid of the current program.
+  */
+ /* HAS_SETRESUID
+  *	This symbol, if defined, indicates that the setresuid routine is
+  *	available to change the real, effective and saved uid of the current
+  *	program.
+  */
+ /* #define	HAS_SETREUID		/**/
+ /*#undef	HAS_SETRESUID		/**/
+ 
+ /* HAS_SETRGID
+  *	This symbol, if defined, indicates that the setrgid routine is available
+  *	to change the real gid of the current program.
+  */
+ /* #define	HAS_SETRGID		/**/
+ 
+ /* HAS_SETRUID
+  *	This symbol, if defined, indicates that the setruid routine is available
+  *	to change the real uid of the current program.
+  */
+ /* #define	HAS_SETRUID		/**/
+ 
+ /* HAS_SHM
+  *	This symbol, if defined, indicates that the entire shm*(2) library is
+  *	supported.
+  */
+ /* #define	HAS_SHM		/**/
+ 
+ /* HAS_SHMAT
+  *	This symbol, if defined, indicates that the shmat() routine is
+  *	available to attach a shared memory segment.
+  */
+ /* VOID_SHMAT
+  *	This symbol, if defined, indicates that the shmat() routine
+  *	returns a pointer of type void*.
+  */
+ /* #define	HAS_SHMAT		/**/
+ 
+ /*#undef	VOIDSHMAT		/**/
+ 
+ /* HAS_SHMCTL
+  *	This symbol, if defined, indicates that the shmctl() routine is
+  *	available to control a shared memory segment.
+  */
+ /* #define	HAS_SHMCTL		/**/
+ 
+ /* HAS_SHMDT
+  *	This symbol, if defined, indicates that the shmdt() routine is
+  *	available to detach a shared memory segment.
+  */
+ /* #define	HAS_SHMDT		/**/
+ 
+ /* HAS_SHMGET
+  *	This symbol, if defined, indicates that the shmget() routine is
+  *	available to get a shared memory segment id.
+  */
+ /* #define	HAS_SHMGET		/**/
+ 
+ /* HAS_SOCKET
+  *	This symbol, if defined, indicates that the BSD socket interface is
+  *	supported.
+  */
+ /* HAS_SOCKETPAIR
+  *	This symbol, if defined, indicates that the BSD socketpair call is
+  *	supported.
+  */
+ /* OLDSOCKET
+  *	This symbol, if defined, indicates that the 4.1c BSD socket interface
+  *	is supported instead of the 4.2/4.3 BSD socket interface.
+  */
+ /* #define	HAS_SOCKET		/**/
+ 
+ /* #define	HAS_SOCKETPAIR	/**/
+ 
+ /*#undef	OLDSOCKET	/**/
+ 
+ /* STATBLOCKS
+  *	This symbol is defined if this system has a stat structure declaring
+  *	st_blksize and st_blocks.
+  */
+ #define	STATBLOCKS 	/**/
+ 
+ /* STDSTDIO
+  *	This symbol is defined if this system has a FILE structure declaring
+  *	_ptr and _cnt in stdio.h.
+  */
+ /* #define	STDSTDIO 	/**/ /* we do, but semantics are different */
+ 
+ /* STRUCTCOPY
+  *	This symbol, if defined, indicates that this C compiler knows how
+  *	to copy structures.  If undefined, you'll need to use a block copy
+  *	routine of some sort instead.
+  */
+ #define	STRUCTCOPY	/**/
+ 
+ /* HAS_STRERROR
+  *	This symbol, if defined, indicates that the strerror() routine is
+  *	available to translate error numbers to strings.
+  */
+ #define	HAS_STRERROR		/**/
+ 
+ /* HAS_SYMLINK
+  *	This symbol, if defined, indicates that the symlink routine is available
+  *	to create symbolic links.
+  */
+ #define	HAS_SYMLINK		/**/
+ 
+ /* HAS_SYSCALL
+  *	This symbol, if defined, indicates that the syscall routine is available
+  *	to call arbitrary system calls.  If undefined, that's tough.
+  */
+ #define	HAS_SYSCALL		/**/
+ 
+ /* HAS_TELLDIR
+  *	This symbol, if defined, indicates that the telldir routine is
+  *	available to tell your location in directories.
+  */
+ #define	HAS_TELLDIR		/**/
+ 
+ /* HAS_TRUNCATE
+  *	This symbol, if defined, indicates that the truncate routine is
+  *	available to truncate files.
+  */
+ /* #define	HAS_TRUNCATE		/**/
+ 
+ /* HAS_VFORK
+  *	This symbol, if defined, indicates that vfork() exists.
+  */
+ #ifdef __MINT__
+ #define	HAS_VFORK	/**/
+ #endif
+ 
+ /* VOIDSIG
+  *	This symbol is defined if this system declares "void (*signal())()" in
+  *	signal.h.  The old way was to declare it as "int (*signal())()".  It
+  *	is up to the package author to declare things correctly based on the
+  *	symbol.
+  */
+ /* TO_SIGNAL
+  *	This symbol's value is either "void" or "int", corresponding to the
+  *	appropriate return "type" of a signal handler.  Thus, one can declare
+  *	a signal handler using "TO_SIGNAL (*handler())()", and define the
+  *	handler using "TO_SIGNAL handler(sig)".
+  */
+ #define	VOIDSIG 	/**/
+ #define	TO_SIGNAL	void 	/**/
+ 
+ /* HASVOLATILE
+  *	This symbol, if defined, indicates that this C compiler knows about
+  *	the volatile declaration.
+  */
+ #define	HASVOLATILE	/**/
+ 
+ /* HAS_VPRINTF
+  *	This symbol, if defined, indicates that the vprintf routine is available
+  *	to printf with a pointer to an argument list.  If unavailable, you
+  *	may need to write your own, probably in terms of _doprnt().
+  */
+ /* CHARVSPRINTF
+  *	This symbol is defined if this system has vsprintf() returning type
+  *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
+  *	is up to the package author to declare vsprintf correctly based on the
+  *	symbol.
+  */
+ #define	HAS_VPRINTF	/**/
+ /* #define	CHARVSPRINTF 	/**/
+ 
+ /* HAS_WAIT4
+  *	This symbol, if defined, indicates that wait4() exists.
+  */
+ /* #define	HAS_WAIT4	/**/
+ 
+ /* HAS_WAITPID
+  *	This symbol, if defined, indicates that waitpid() exists.
+  */
+ /*#undef	HAS_WAITPID	/**/
+ 
+ /* GIDTYPE
+  *	This symbol has a value like gid_t, int, ushort, or whatever type is
+  *	used to declare group ids in the kernel.
+  */
+ #define GIDTYPE gid_t		/**/
+ 
+ /* GROUPSTYPE
+  *	This symbol has a value like gid_t, int, ushort, or whatever type is
+  *	used in the return value of getgroups().
+  */
+ /* #define GROUPSTYPE unsigned short		/**/
+ 
+ /* I_FCNTL
+  *	This manifest constant tells the C program to include <fcntl.h>.
+  */
+ #define	I_FCNTL	/**/
+ 
+ /* I_GDBM
+  *	This symbol, if defined, indicates that gdbm.h exists and should
+  *	be included.
+  */
+ #define	I_GDBM		/**/
+ #define HAS_GDBM
+ 
+ /* I_GRP
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include grp.h.
+  */
+ /* #define	I_GRP		/**/
+ 
+ /* I_NETINET_IN
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include netinet/in.h.
+  */
+ /* I_SYS_IN
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include sys/in.h.
+  */
+ /* #define	I_NETINET_IN		/**/
+ /*#undef	I_SYS_IN		/**/
+ 
+ /* I_PWD
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include pwd.h.
+  */
+ /* PWQUOTA
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_quota.
+  */
+ /* PWAGE
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_age.
+  */
+ /* PWCHANGE
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_change.
+  */
+ /* PWCLASS
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_class.
+  */
+ /* PWEXPIRE
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_expire.
+  */
+ /* PWCOMMENT
+  *	This symbol, if defined, indicates to the C program that struct passwd
+  *	contains pw_comment.
+  */
+ #define	I_PWD		/**/
+ /* #define	PWQUOTA		/**/
+ /*#undef	PWAGE		/**/
+ /*#undef	PWCHANGE	/**/
+ /*#undef	PWCLASS		/**/
+ /*#undef	PWEXPIRE	/**/
+ /* #define	PWCOMMENT	/**/
+ 
+ /* I_SYS_FILE
+  *	This manifest constant tells the C program to include <sys/file.h>.
+  */
+ /* #define	I_SYS_FILE	/**/
+ 
+ /* I_SYSIOCTL
+  *	This symbol, if defined, indicates that sys/ioctl.h exists and should
+  *	be included.
+  */
+ #define	I_SYSIOCTL		/**/
+ 
+ /* I_TIME
+  *	This symbol is defined if the program should include <time.h>.
+  */
+ /* I_SYS_TIME
+  *	This symbol is defined if the program should include <sys/time.h>.
+  */
+ /* SYSTIMEKERNEL
+  *	This symbol is defined if the program should include <sys/time.h>
+  *	with KERNEL defined.
+  */
+ /* I_SYS_SELECT
+  *	This symbol is defined if the program should include <sys/select.h>.
+  */
+ #define	I_TIME	 	/**/
+ /* #define	I_SYS_TIME 	/**/
+ /*#undef	SYSTIMEKERNEL 	/**/
+ /*#undef	I_SYS_SELECT 	/**/
+ 
+ /* I_UTIME
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include utime.h.
+  */
+ /*#undef	I_UTIME		/**/
+ 
+ /* I_VARARGS
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include varargs.h.
+  */
+ #define	I_VARARGS		/**/
+ 
+ /* I_VFORK
+  *	This symbol, if defined, indicates to the C program that it should
+  *	include vfork.h.
+  */
+ /* #define	I_VFORK		/**/
+ 
+ /* INTSIZE
+  *	This symbol contains the size of an int, so that the C preprocessor
+  *	can make decisions based on it.
+  */
+ #ifdef __MSHORT__
+ #define INTSIZE 2		/**/
+ #else
+ #define INTSIZE 4		/**/
+ #endif
+ 
+ /* I_DIRENT
+  *	This symbol, if defined, indicates that the program should use the
+  *	P1003-style directory routines, and include <dirent.h>.
+  */
+ /* I_SYS_DIR
+  *	This symbol, if defined, indicates that the program should use the
+  *	directory functions by including <sys/dir.h>.
+  */
+ /* I_NDIR
+  *	This symbol, if defined, indicates that the program should include the
+  *	system's version of ndir.h, rather than the one with this package.
+  */
+ /* I_SYS_NDIR
+  *	This symbol, if defined, indicates that the program should include the
+  *	system's version of sys/ndir.h, rather than the one with this package.
+  */
+ /* I_MY_DIR
+  *	This symbol, if defined, indicates that the program should compile
+  *	the ndir.c code provided with the package.
+  */
+ /* DIRNAMLEN
+  *	This symbol, if defined, indicates to the C program that the length
+  *	of directory entry names is provided by a d_namlen field.  Otherwise
+  *	you need to do strlen() on the d_name field.
+  */
+ #define	I_DIRENT	/**/
+ /*#undef	I_SYS_DIR	/**/
+ /*#undef	I_NDIR		/**/
+ /*#undef	I_SYS_NDIR	/**/
+ /*#undef	I_MY_DIR	/**/
+ /*#undef	DIRNAMLEN	/**/
+ 
+ /* MYMALLOC
+  *	This symbol, if defined, indicates that we're using our own malloc.
+  */
+ /* MALLOCPTRTYPE
+  *	This symbol defines the kind of ptr returned by malloc and realloc.
+  */
+ /*  #define MYMALLOC			/**/
+ #define MALLOCPTRTYPE void         /**/
+ 
+ 
+ 
+ /* RANDBITS
+  *	This symbol contains the number of bits of random number the rand()
+  *	function produces.  Usual values are 15, 16, and 31.
+  */
+ #ifdef __MSHORT__
+ #define RANDBITS 15		/**/
+ #else
+ #define RANDBITS 31		/**/
+ #endif
+ 
+ /* SCRIPTDIR
+  *	This symbol holds the name of the directory in which the user wants
+  *	to keep publicly executable scripts for the package in question.  It
+  *	is often a directory that is mounted across diverse architectures.
+  */
+ #define SCRIPTDIR "/bin"             /**/
+ 
+ /* SIG_NAME
+  *	This symbol contains an list of signal names in order.
+  */
+ #define SIG_NAME "NULL","HUP","INT","QUIT","ILL","TRAP","ABRT","PRIV","FPE","KILL","BUS","SEGV","SYS","PIPE","ALRM","TERM","URG","STOP","TSTP","CONT","CHLD","TTIN","TTOU","IO","XCPU","XFSZ","VTALRM","PROF","WINCH","USR1","USR2"
+ 
+ /* STDCHAR
+  *	This symbol is defined to be the type of char used in stdio.h.
+  *	It has the values "unsigned char" or "char".
+  */
+ #define STDCHAR unsigned char	/**/
+ 
+ /* UIDTYPE
+  *	This symbol has a value like uid_t, int, ushort, or whatever type is
+  *	used to declare user ids in the kernel.
+  */
+ #define UIDTYPE uid_t		/**/
+ 
+ /* VOIDHAVE
+  *	This symbol indicates how much support of the void type is given by this
+  *	compiler.  What various bits mean:
+  *
+  *	    1 = supports declaration of void
+  *	    2 = supports arrays of pointers to functions returning void
+  *	    4 = supports comparisons between pointers to void functions and
+  *		    addresses of void functions
+  *
+  *	The package designer should define VOIDWANT to indicate the requirements
+  *	of the package.  This can be done either by #defining VOIDWANT before
+  *	including config.h, or by defining voidwant in Myinit.U.  If the level
+  *	of void support necessary is not present, config.h defines void to "int",
+  *	VOID to the empty string, and VOIDP to "char *".
+  */
+ /* void
+  *	This symbol is used for void casts.  On implementations which support
+  *	void appropriately, its value is "void".  Otherwise, its value maps
+  *	to "int".
+  */
+ /* VOID
+  *	This symbol's value is "void" if the implementation supports void
+  *	appropriately.  Otherwise, its value is the empty string.  The primary
+  *	use of this symbol is in specifying void parameter lists for function
+  *	prototypes.
+  */
+ /* VOIDP
+  *	This symbol is used for casting generic pointers.  On implementations
+  *	which support void appropriately, its value is "void *".  Otherwise,
+  *	its value is "char *".
+  */
+ #ifndef VOIDWANT
+ #define VOIDWANT 7
+ #endif
+ #define VOIDHAVE 7
+ #if (VOIDHAVE & VOIDWANT) != VOIDWANT
+ #define void int		/* is void to be avoided? */
+ #define VOID
+ #define VOIDP (char *)
+ #define M_VOID		/* Xenix strikes again */
+ #else
+ #define VOID void
+ #define VOIDP (void *)
+ #endif
+ 
+ /* PRIVLIB
+  *	This symbol contains the name of the private library for this package.
+  *	The library is private in the sense that it needn't be in anyone's
+  *	execution path, but it should be accessible by the world.  The program
+  *	should be prepared to do ~ expansion.
+  */
+ /* #define PRIVLIB "/usr/lib/perl"		/**/
+ extern char *PRIVLIB;	/* $PERLIB or /lib */
+ 
+ /* param.h does'nt really need types, but is #define'ed to make sure types.h
+  * is included
+  */
+ #define PARAM_NEEDS_TYPES
+ 
+ /* These are selective unix services in the gcc-st lib
+  */
+ #define HAS_GETLOGIN
+ #define HAS_GETPPID
+ #define HAS_KILL
+ #define HAS_UMASK
+ #define HAS_PASSWD
+ #endif

Index: config_h.SH
*** config_h.SH.old	Mon Jun  8 17:46:11 1992
--- config_h.SH	Mon Jun  8 17:46:12 1992
***************
*** 41,46 ****
--- 41,51 ----
  #$d_eunice	EUNICE		/**/
  #$d_eunice	VMS		/**/
  
+ /* LOC_SED
+  *     This symbol holds the complete pathname to the sed program.
+  */
+ #define LOC_SED "$sed"             /**/
+ 
  /* ALIGNBYTES
   *	This symbol contains the number of bytes required to align a double.
   *	Usual values are 2, 4, and 8.
***************
*** 84,91 ****
--- 89,104 ----
  /* HAS_BCOPY
   *	This symbol, if defined, indicates that the bcopy routine is available
   *	to copy blocks of memory.  Otherwise you should probably use memcpy().
+  *	If neither is defined, roll your own.
   */
+ /* SAFE_BCOPY
+  *	This symbol, if defined, indicates that the bcopy routine is available
+  *	to copy potentially overlapping copy blocks of bcopy.  Otherwise you
+  *	should probably use memmove() or memcpy().  If neither is defined,
+  *	roll your own.
+  */
  #$d_bcopy	HAS_BCOPY		/**/
+ #$d_safebcpy	SAFE_BCOPY		/**/
  
  /* HAS_BZERO
   *	This symbol, if defined, indicates that the bzero routine is available
***************
*** 248,253 ****
--- 261,272 ----
  #$d_index	index strchr	/* cultural */
  #$d_index	rindex strrchr	/*  differences? */
  
+ /* HAS_ISASCII
+  *	This symbol, if defined, indicates that the isascii routine is available
+  *	to test characters for asciiness.
+  */
+ #$d_isascii	HAS_ISASCII		/**/
+ 
  /* HAS_KILLPG
   *	This symbol, if defined, indicates that the killpg routine is available
   *	to kill process groups.  If unavailable, you probably should use kill
***************
*** 272,279 ****
--- 291,318 ----
   *	to copy blocks of memory.  Otherwise you should probably use bcopy().
   *	If neither is defined, roll your own.
   */
+ /* SAFE_MEMCPY
+  *	This symbol, if defined, indicates that the memcpy routine is available
+  *	to copy potentially overlapping copy blocks of memory.  Otherwise you
+  *	should probably use memmove() or bcopy().  If neither is defined,
+  *	roll your own.
+  */
  #$d_memcpy	HAS_MEMCPY		/**/
+ #$d_safemcpy	SAFE_MEMCPY		/**/
  
+ /* HAS_MEMMOVE
+  *	This symbol, if defined, indicates that the memmove routine is available
+  *	to move potentially overlapping blocks of memory.  Otherwise you
+  *	should use bcopy() or roll your own.
+  */
+ #$d_memmove	HAS_MEMMOVE		/**/
+ 
+ /* HAS_MEMSET
+  *	This symbol, if defined, indicates that the memset routine is available
+  *	to set a block of memory to a character.  If undefined, roll your own.
+  */
+ #$d_memset	HAS_MEMSET		/**/
+ 
  /* HAS_MKDIR
   *	This symbol, if defined, indicates that the mkdir routine is available
   *	to create directories.  Otherwise you should fork off a new process to
***************
*** 289,313 ****
  
  /* HAS_MSGCTL
   *	This symbol, if defined, indicates that the msgctl() routine is
!  *	available to stat symbolic links.
   */
  #$d_msgctl	HAS_MSGCTL		/**/
  
  /* HAS_MSGGET
   *	This symbol, if defined, indicates that the msgget() routine is
!  *	available to stat symbolic links.
   */
  #$d_msgget	HAS_MSGGET		/**/
  
  /* HAS_MSGRCV
   *	This symbol, if defined, indicates that the msgrcv() routine is
!  *	available to stat symbolic links.
   */
  #$d_msgrcv	HAS_MSGRCV		/**/
  
  /* HAS_MSGSND
   *	This symbol, if defined, indicates that the msgsnd() routine is
!  *	available to stat symbolic links.
   */
  #$d_msgsnd	HAS_MSGSND		/**/
  
--- 328,352 ----
  
  /* HAS_MSGCTL
   *	This symbol, if defined, indicates that the msgctl() routine is
!  *	available to control message passing.
   */
  #$d_msgctl	HAS_MSGCTL		/**/
  
  /* HAS_MSGGET
   *	This symbol, if defined, indicates that the msgget() routine is
!  *	available to get messages.
   */
  #$d_msgget	HAS_MSGGET		/**/
  
  /* HAS_MSGRCV
   *	This symbol, if defined, indicates that the msgrcv() routine is
!  *	available to receive messages.
   */
  #$d_msgrcv	HAS_MSGRCV		/**/
  
  /* HAS_MSGSND
   *	This symbol, if defined, indicates that the msgsnd() routine is
!  *	available to send messages.
   */
  #$d_msgsnd	HAS_MSGSND		/**/
  
***************
*** 342,347 ****
--- 381,392 ----
   */
  #$d_rename	HAS_RENAME		/**/
  
+ /* HAS_REWINDDIR
+  *	This symbol, if defined, indicates that the rewindir routine is
+  *	available to rewind directories.
+  */
+ #$d_rewindir	HAS_REWINDDIR		/**/
+ 
  /* HAS_RMDIR
   *	This symbol, if defined, indicates that the rmdir routine is available
   *	to remove directories.  Otherwise you should fork off a new process to
***************
*** 349,354 ****
--- 394,405 ----
   */
  #$d_rmdir	HAS_RMDIR		/**/
  
+ /* HAS_SEEKDIR
+  *	This symbol, if defined, indicates that the seekdir routine is
+  *	available to seek into directories.
+  */
+ #$d_seekdir	HAS_SEEKDIR		/**/
+ 
  /* HAS_SELECT
   *	This symbol, if defined, indicates that the select() subroutine
   *	exists.
***************
*** 363,381 ****
  
  /* HAS_SEMCTL
   *	This symbol, if defined, indicates that the semctl() routine is
!  *	available to stat symbolic links.
   */
  #$d_semctl	HAS_SEMCTL		/**/
  
  /* HAS_SEMGET
   *	This symbol, if defined, indicates that the semget() routine is
!  *	available to stat symbolic links.
   */
  #$d_semget	HAS_SEMGET		/**/
  
  /* HAS_SEMOP
   *	This symbol, if defined, indicates that the semop() routine is
!  *	available to stat symbolic links.
   */
  #$d_semop	HAS_SEMOP		/**/
  
--- 414,432 ----
  
  /* HAS_SEMCTL
   *	This symbol, if defined, indicates that the semctl() routine is
!  *	available to control semaphores.
   */
  #$d_semctl	HAS_SEMCTL		/**/
  
  /* HAS_SEMGET
   *	This symbol, if defined, indicates that the semget() routine is
!  *	available to get semaphores ids.
   */
  #$d_semget	HAS_SEMGET		/**/
  
  /* HAS_SEMOP
   *	This symbol, if defined, indicates that the semop() routine is
!  *	available to perform semaphore operations.
   */
  #$d_semop	HAS_SEMOP		/**/
  
***************
*** 453,459 ****
  
  /* HAS_SHMAT
   *	This symbol, if defined, indicates that the shmat() routine is
!  *	available to stat symbolic links.
   */
  /* VOID_SHMAT
   *	This symbol, if defined, indicates that the shmat() routine
--- 504,510 ----
  
  /* HAS_SHMAT
   *	This symbol, if defined, indicates that the shmat() routine is
!  *	available to attach a shared memory segment.
   */
  /* VOID_SHMAT
   *	This symbol, if defined, indicates that the shmat() routine
***************
*** 465,483 ****
  
  /* HAS_SHMCTL
   *	This symbol, if defined, indicates that the shmctl() routine is
!  *	available to stat symbolic links.
   */
  #$d_shmctl	HAS_SHMCTL		/**/
  
  /* HAS_SHMDT
   *	This symbol, if defined, indicates that the shmdt() routine is
!  *	available to stat symbolic links.
   */
  #$d_shmdt	HAS_SHMDT		/**/
  
  /* HAS_SHMGET
   *	This symbol, if defined, indicates that the shmget() routine is
!  *	available to stat symbolic links.
   */
  #$d_shmget	HAS_SHMGET		/**/
  
--- 516,534 ----
  
  /* HAS_SHMCTL
   *	This symbol, if defined, indicates that the shmctl() routine is
!  *	available to control a shared memory segment.
   */
  #$d_shmctl	HAS_SHMCTL		/**/
  
  /* HAS_SHMDT
   *	This symbol, if defined, indicates that the shmdt() routine is
!  *	available to detach a shared memory segment.
   */
  #$d_shmdt	HAS_SHMDT		/**/
  
  /* HAS_SHMGET
   *	This symbol, if defined, indicates that the shmget() routine is
!  *	available to get a shared memory segment id.
   */
  #$d_shmget	HAS_SHMGET		/**/
  
***************
*** 535,540 ****
--- 586,597 ----
   *	to call arbitrary system calls.  If undefined, that's tough.
   */
  #$d_syscall	HAS_SYSCALL		/**/
+ 
+ /* HAS_TELLDIR
+  *	This symbol, if defined, indicates that the telldir routine is
+  *	available to tell your location in directories.
+  */
+ #$d_telldir	HAS_TELLDIR		/**/
  
  /* HAS_TRUNCATE
   *	This symbol, if defined, indicates that the truncate routine is

Index: os2/crypt.c
*** os2/crypt.c.old	Mon Jun  8 17:49:49 1992
--- os2/crypt.c	Mon Jun  8 17:49:50 1992
***************
*** 0 ****
--- 1,276 ----
+ /*      From Andy Tanenbaum's book "Computer Networks",
+         rewritten in C
+ */
+ 
+ struct block {
+         unsigned char b_data[64];
+ };
+ 
+ struct ordering {
+         unsigned char o_data[64];
+ };
+ 
+ static struct block key;
+ 
+ static struct ordering InitialTr = {
+         58,50,42,34,26,18,10, 2,60,52,44,36,28,20,12, 4,
+         62,54,46,38,30,22,14, 6,64,56,48,40,32,24,16, 8,
+         57,49,41,33,25,17, 9, 1,59,51,43,35,27,19,11, 3,
+         61,53,45,37,29,21,13, 5,63,55,47,39,31,23,15, 7,
+ };
+ 
+ static struct ordering FinalTr = {
+         40, 8,48,16,56,24,64,32,39, 7,47,15,55,23,63,31,
+         38, 6,46,14,54,22,62,30,37, 5,45,13,53,21,61,29,
+         36, 4,44,12,52,20,60,28,35, 3,43,11,51,19,59,27,
+         34, 2,42,10,50,18,58,26,33, 1,41, 9,49,17,57,25,
+ };
+ 
+ static struct ordering swap = {
+         33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
+         49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
+          1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,16,
+         17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
+ };
+ 
+ static struct ordering KeyTr1 = {
+         57,49,41,33,25,17, 9, 1,58,50,42,34,26,18,
+         10, 2,59,51,43,35,27,19,11, 3,60,52,44,36,
+         63,55,47,39,31,23,15, 7,62,54,46,38,30,22,
+         14, 6,61,53,45,37,29,21,13, 5,28,20,12, 4,
+ };
+ 
+ static struct ordering KeyTr2 = {
+         14,17,11,24, 1, 5, 3,28,15, 6,21,10,
+         23,19,12, 4,26, 8,16, 7,27,20,13, 2,
+         41,52,31,37,47,55,30,40,51,45,33,48,
+         44,49,39,56,34,53,46,42,50,36,29,32,
+ };
+ 
+ static struct ordering etr = {
+         32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9,
+          8, 9,10,11,12,13,12,13,14,15,16,17,
+         16,17,18,19,20,21,20,21,22,23,24,25,
+         24,25,26,27,28,29,28,29,30,31,32, 1,
+ };
+ 
+ static struct ordering ptr = {
+         16, 7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,
+          2, 8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25,
+ };
+ 
+ static unsigned char s_boxes[8][64] = {
+ {       14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
+          0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
+          4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
+         15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13,
+ },
+ 
+ {       15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
+          3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
+          0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
+         13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9,
+ },
+ 
+ {       10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
+         13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
+         13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
+          1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12,
+ },
+ 
+ {        7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
+         13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
+         10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
+          3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14,
+ },
+ 
+ {        2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
+         14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
+          4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
+         11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3,
+ },
+ 
+ {       12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
+         10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8,
+          9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
+          4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13,
+ },
+ 
+ {        4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
+         13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6,
+          1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
+          6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12,
+ },
+ 
+ {       13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
+          1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
+          7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
+          2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11,
+ },
+ };
+ 
+ static int rots[] = {
+         1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,
+ };
+ 
+ static void transpose(struct block *data, struct ordering *t, int n)
+ {
+         struct block x;
+ 
+         x = *data;
+ 
+         while (n-- > 0) {
+                 data->b_data[n] = x.b_data[t->o_data[n] - 1];
+         }
+ }
+ 
+ static void rotate(struct block *key)
+ {
+         register unsigned char *p = key->b_data;
+         register unsigned char *ep = &(key->b_data[55]);
+         int data0 = key->b_data[0], data28 = key->b_data[28];
+ 
+         while (p++ < ep) *(p-1) = *p;
+         key->b_data[27] = (char) data0;
+         key->b_data[55] = (char) data28;
+ }
+ 
+ static struct ordering *EP = &etr;
+ 
+ static void f(int i, struct block *key, struct block *a, struct block *x)
+ {
+         struct block e, ikey, y;
+         int k;
+         register unsigned char *p, *q, *r;
+ 
+         e = *a;
+         transpose(&e, EP, 48);
+         for (k = rots[i]; k; k--) rotate(key);
+         ikey = *key;
+         transpose(&ikey, &KeyTr2, 48);
+         p = &(y.b_data[48]);
+         q = &(e.b_data[48]);
+         r = &(ikey.b_data[48]);
+         while (p > y.b_data) {
+                 *--p = *--q ^ *--r;
+         }
+         q = x->b_data;
+         for (k = 0; k < 8; k++) {
+                 register int xb, r;
+ 
+                 r = *p++ << 5;
+                 r += *p++ << 3;
+                 r += *p++ << 2;
+                 r += *p++ << 1;
+                 r += *p++;
+                 r += *p++ << 4;
+ 
+                 xb = s_boxes[k][r];
+ 
+                 *q++ = (char) (xb >> 3) & 1;
+                 *q++ = (char) (xb>>2) & 1;
+                 *q++ = (char) (xb>>1) & 1;
+                 *q++ = (char) (xb & 1);
+         }
+         transpose(x, &ptr, 32);
+ }
+ 
+ void definekey(char *k)
+ {
+ 
+         key = *((struct block *) k);
+         transpose(&key, &KeyTr1, 56);
+ }
+ 
+ void encrypt(char *blck, int edflag)
+ {
+         register struct block *p = (struct block *) blck;
+         register int i;
+ 
+         transpose(p, &InitialTr, 64);
+         for (i = 15; i>= 0; i--) {
+                 int j = edflag ? i : 15 - i;
+                 register int k;
+                 struct block b, x;
+ 
+                 b = *p;
+                 for (k = 31; k >= 0; k--) {
+                         p->b_data[k] = b.b_data[k + 32];
+                 }
+                 f(j, &key, p, &x);
+                 for (k = 31; k >= 0; k--) {
+                         p->b_data[k+32] = b.b_data[k] ^ x.b_data[k];
+                 }
+         }
+         transpose(p, &swap, 64);
+         transpose(p, &FinalTr, 64);
+ }
+ 
+ char *crypt(char *pw, char *salt)
+ {
+ 
+         char pwb[66];
+         static char result[16];
+         register char *p = pwb;
+         struct ordering new_etr;
+         register int i;
+ 
+         while (*pw && p < &pwb[64]) {
+                 register int j = 7;
+ 
+                 while (j--) {
+                         *p++ = (*pw >> j) & 01;
+                 }
+                 pw++;
+                 *p++ = 0;
+         }
+         while (p < &pwb[64]) *p++ = 0;
+ 
+         definekey(p = pwb);
+ 
+         while (p < &pwb[66]) *p++ = 0;
+ 
+         new_etr = etr;
+         EP = &new_etr;
+         for (i = 0; i < 2; i++) {
+                 register char c = *salt++;
+                 register int j;
+ 
+                 result[i] = c;
+                 if ( c > 'Z') c -= 6 + 7 + '.'; /* c was a lower case letter */
+                 else if ( c > '9') c -= 7 + '.';/* c was upper case letter */
+                 else c -= '.';                  /* c was digit, '.' or '/'. */
+                                                 /* now, 0 <= c <= 63 */
+                 for (j = 0; j < 6; j++) {
+                         if ((c >> j) & 01) {
+                                 int t = 6*i + j;
+                                 int temp = new_etr.o_data[t];
+                                 new_etr.o_data[t] = new_etr.o_data[t+24];
+                                 new_etr.o_data[t+24] = (char) temp;
+                         }
+                 }
+         }
+ 
+         if (result[1] == 0) result[1] = result[0];
+ 
+         for (i = 0; i < 25; i++) encrypt(pwb,0);
+         EP = &etr;
+ 
+         p = pwb;
+         pw = result+2;
+         while (p < &pwb[66]) {
+                 register int c = 0;
+                 register int j = 6;
+ 
+                 while (j--) {
+                         c <<= 1;
+                         c |= *p++;
+                 }
+                 c += '.';               /* becomes >= '.' */
+                 if (c > '9') c += 7;    /* not in [./0-9], becomes upper */
+                 if (c > 'Z') c += 6;    /* not in [A-Z], becomes lower */
+                 *pw++ = (char) c;
+         }
+         *pw = 0;
+         return result;
+ }

Index: usub/curses.mus
*** usub/curses.mus.old	Mon Jun  8 17:52:28 1992
--- usub/curses.mus	Mon Jun  8 17:52:29 1992
***************
*** 1,6 ****
! /* $RCSfile: curses.mus,v $$Revision: 4.0.1.1 $$Date: 91/11/05 19:06:19 $
   *
   * $Log:	curses.mus,v $
   * Revision 4.0.1.1  91/11/05  19:06:19  lwall
   * patch11: usub/curses.mus now supports SysV curses
   * 
--- 1,9 ----
! /* $RCSfile: curses.mus,v $$Revision: 4.0.1.2 $$Date: 92/06/08 16:06:12 $
   *
   * $Log:	curses.mus,v $
+  * Revision 4.0.1.2  92/06/08  16:06:12  lwall
+  * patch20: function key support added to curses.mus
+  * 
   * Revision 4.0.1.1  91/11/05  19:06:19  lwall
   * patch11: usub/curses.mus now supports SysV curses
   * 
***************
*** 518,524 ****
  		st[0] = &str_undef;
  	    else {
  		retch = retval;
! 		str_nset(st[0], &retch, 1);
  	    }
  	}
  	return sp;
--- 521,530 ----
  		st[0] = &str_undef;
  	    else {
  		retch = retval;
! 		if (retval > 0377)
! 			str_numset(st[0], (double) retval);
! 		else
! 			str_nset(st[0], &retch, 1);
  	    }
  	}
  	return sp;
***************
*** 536,542 ****
  		st[0] = &str_undef;
  	    else {
  		retch = retval;
! 		str_nset(st[0], &retch, 1);
  	    }
  	}
  	return sp;
--- 542,551 ----
  		st[0] = &str_undef;
  	    else {
  		retch = retval;
! 		if (retval > 0377)
! 			str_numset(st[0], (double) retval);
! 		else
! 			str_nset(st[0], &retch, 1);
  	    }
  	}
  	return sp;

Index: t/op/dbm.t
Prereq: 4.0
*** t/op/dbm.t.old	Mon Jun  8 17:52:04 1992
--- t/op/dbm.t	Mon Jun  8 17:52:04 1992
***************
*** 1,8 ****
  #!./perl
  
! # $Header: dbm.t,v 4.0 91/03/20 01:51:52 lwall Locked $
  
! if (!-r '/usr/include/dbm.h' && !-r '/usr/include/ndbm.h') {
      print "1..0\n";
      exit;
  }
--- 1,9 ----
  #!./perl
  
! # $RCSfile: dbm.t,v $$Revision: 4.0.1.1 $$Date: 92/06/08 15:43:02 $
  
! if (!-r '/usr/include/dbm.h' && !-r '/usr/include/ndbm.h'
!     && !-r '/usr/include/rpcsvc/dbm.h') {
      print "1..0\n";
      exit;
  }

Index: hints/dgux.sh
*** hints/dgux.sh.old	Mon Jun  8 17:47:50 1992
--- hints/dgux.sh	Mon Jun  8 17:47:50 1992
***************
*** 0 ****
--- 1,7 ----
+ cppstdin='/lib/cpp'
+ gidtype='gid_t'
+ groupstype='gid_t'
+ libs='-ldgc'
+ uidtype='uid_t'
+ d_index='define'
+ cc='gcc'

Index: hints/dynix.sh
*** hints/dynix.sh.old	Mon Jun  8 17:47:52 1992
--- hints/dynix.sh	Mon Jun  8 17:47:52 1992
***************
*** 1 ****
--- 1,2 ----
  d_castneg=undef
+ libswanted=`echo $libswanted | sed -e 's/socket /socket seq inet /'`

Index: atarist/test/err
*** atarist/test/err.old	Mon Jun  8 17:45:01 1992
--- atarist/test/err	Mon Jun  8 17:45:02 1992
***************
*** 0 ****
--- 1,4 ----
+ $! = 0 + 0;
+ print $!, "\n";
+ $e = $! + 0;
+ print $e, "\n";

Index: atarist/test/glob
*** atarist/test/glob.old	Mon Jun  8 17:45:08 1992
--- atarist/test/glob	Mon Jun  8 17:45:09 1992
***************
*** 0 ****
--- 1,4 ----
+ while(<*.pl>)
+ {
+     print $_, "\n";
+ }

*** End of Patch 23 ***
exit 0 # Just in case...
