Newsgroups: comp.sources.misc
From: anita@bouw.tno.nl (Anita Eijs)
Subject:  v30i022:  linkedlist - Generic Linked List Tool, Part01/01
Message-ID: <1992May29.203013.129@sparky.imd.sterling.com>
X-Md4-Signature: 4ae1a71b6b6fd8ab870145ebe504b8b9
Date: Fri, 29 May 1992 20:30:13 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: anita@bouw.tno.nl (Anita Eijs)
Posting-number: Volume 30, Issue 22
Archive-name: linkedlist/part01
Environment: UNIX, MS-DOS, VAX/VMS, Macintosh

The subject of 'Generic Linked Lists' has raised several times now, so I
decided to announce my Linked List Tool to the net.

The Linked List Tool is a package to define, create, update, query and
delete one or more (nodes of) linked lists. The user doesn't have to take
care of allocating a number of bytes for a node, inserting on the right
place, deleting and freeing a node and so on.

Different kind of linked lists can be defined. In a singly linked list
each node points to the next node, in a doubly linked list each node
points also to the previous node. A chain is a list in which the last
node has a NULL-pointer and in a circular linked list the last node
points back to the first node.

The package consists of a set of C-functions :
	lDef		define linked list
	lInsNode	insert node
	lGetNode	get node
	lFndNode	find node
	lUpdNode	update current node
	lDelNode	delete node
	lIndxNode	get node by index
	lFlagNode	get node by flag
	lInfo		get information about linked list
	lInfoNode	get information about node
	lDel		delete linked list
	lDelAll		delete all linked lists
	lDump		dump a linked list to a file
	lUndump		undump a linked list from a file

Linked List Tool is ported to UNIX, MS-DOS, VAX/VMS and Macintosh.
Please look at README and the manual pages for more detailed information !

		Anita

	+--------------------------------------------------------+
	| TNO - BOUW, PO-box 49, 2600 AA  Delft, the Netherlands |
	| FAX : +31 15 843990					 |
	| E-MAIL : anita@bouw.tno.nl, Anita.Eijs@bouw.tno.nl	 |
	+--------------------------------------------------------+
---------- cut here ------------------------------------------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README Doc Doc/Intro.1 Doc/lDef.1 Doc/lDel.1 Doc/lDelAll.1
#   Doc/lDelNode.1 Doc/lDump.1 Doc/lFlagNode.1 Doc/lFndNode.1
#   Doc/lGetNode.1 Doc/lIndxNode.1 Doc/lInfo.1 Doc/lInfoNode.1
#   Doc/lInsNode.1 Doc/lUndump.1 Doc/lUpdNode.1 Makefile
#   Tools_makerule example.c list.c list.h
# Wrapped by kent@sparky on Fri May 29 15:25:17 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1541 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X				Linked List Tool
X				================
X
X
XThe distribution of the Linked List Tool (Version 0.7, March 1992) includes
Xthe following files:
X
X	Doc/Intro.1		- [nt]roff manual pages
X	Doc/lDef.1
X	Doc/lDel.1
X	Doc/lDelAll.1
X	Doc/lDelNode.1
X	Doc/lDump.1
X	Doc/lFlagNode.1
X	Doc/lFndNode.1
X	Doc/lGetNode.1
X	Doc/lIndxNode.1
X	Doc/lInfo.1
X	Doc/lInfoNode.1
X	Doc/lInsNode.1
X	Doc/lUndump.1
X	Doc/lUpdNode.1
X	Makefile		- Berkeley or System V Makefile
X	README			- this file !
X	Tools_makerule		- make rules for Makefile
X	example.c		- example of use of Linked List routines
X	list.c			- Linked List sources
X	list.h			- Linked List defines and prototypes
X
X
XThe installation of the Linked List Tool library is pretty simple :
X
X1)	Check the environment settings (TOOLS_HOME, DIR, LIB and RULE) in
X	the Makefile.
X
X2)	Check the environment settings (RANLIB) in the Tools_makerule.
X
X3)	Enter 'make newlib' at the UNIX prompt.
X
X4)	Enter 'make test' or 'make example' to create the executable of
X	the program 'example' at the UNIX prompt.
X
X
XI also ported the Linked List Tool to MSDOS, to VAX-VMS and to Macintosh.
XI didn't create a library on those machines, but I treated list.c and list.h
Xthe same as all the other source-files (*.[ch]) of the program.
X
X
XThe Linked List Tool is in the public domain. If you have any comments,
Xsuggestions, or find any bugs, or make any changes you'd like to share,
Xplease let me know.
X
X
XAnita Eijs	(anita@bouw.tno.nl, Anita.Eijs@bouw.tno.nl)
XTNO - BOUW - BouwInformatica
XP.O. Box 49
X2600 AA Delft
XThe Netherlands
XFAX : +31 15 843990
END_OF_FILE
  if test 1541 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test ! -d 'Doc' ; then
    echo shar: Creating directory \"'Doc'\"
    mkdir 'Doc'
fi
if test -f 'Doc/Intro.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/Intro.1'\"
else
  echo shar: Extracting \"'Doc/Intro.1'\" \(6595 characters\)
  sed "s/^X//" >'Doc/Intro.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "Intro"
X.IX Intro
X.SH NAME
XIntro - Introduction to Linked List Tool.
X.SH DESCRIPTION
XThe Linked List Tool is a package to define, create, update, query and
Xdelete one or more (nodes of) linked lists. The user doesn't have to take
Xcare of allocating a number of bytes
Xfor a node, inserting on the right place, deleting and freeing a
Xnode and so on.
X.br
XDifferent kind of linked lists can be defined.
XIn a \fIsingly\fP linked list each node
Xpoints to the next node, in a \fIdoubly\fP linked list each node points also to
Xthe previous node. A \fIchain\fP is a list in which the last
Xnode has a NULL-pointer and in a \fIcircular\fP linked list the last node
Xpoints back to the first node.
X.br
XThe package consists of the following routines :
X.nf
X.if t .ta 0.2i 1.3i
X	lDef	define linked list
X	lInsNode	insert node
X	lGetNode	get node
X	lFndNode	find node
X	lUpdNode	update current node
X	lDelNode	delete node
X	lIndxNode	get node by index
X	lFlagNode	get node by flag
X	lInfo	get information about linked list
X	lInfoNode	get information about node
X	lDel	delete linked list
X	lDelAll	delete all linked lists
X	lDump	dump a linked list to a file
X	lUndump	undump a linked list from a file
X.fi
X.SH ERROR CODES
X.if t .ta 0.2i 0.6i
XHere follows an enumeration of the possible error codes, for each
Xfunction-call is specified which error codes could be expected. The marked
Xerrors (*) will also be written to the error-file \fI=listError=\fP.
X.nf
X	-1	parameter \fIsd\fP has wrong value (*)
X	-2	parameter \fIcc\fP has wrong value (*)
X	-3	parameter \fIwhere\fP has wrong value (*)
X	-4	parameter \fIwhich\fP has wrong value (*)
X	-5	list identifier is unknown (*)
X	-6	function name is unknown (*)
X	-7	there are no linked lists defined (*)
X	-8	linked list doesn't contain any nodes
X	-9	end of list reached
X	-10	node not found
X	-11	backward searching / retrieving not possible for singly linked list (*)
X	-12	size of expected data and size of node are not equal (*)
X	-13	index out of range (*)
X	-14	can't open linked list dump file for writing or reading (*)
X.fi
X.SH LIBRARY
X~anita/Tools/Lib/list.a
X.SH INCLUDE FILE
X~anita/Tools/List/list.h
X.SH PORTABILITY
XThe Linked List Tool is a very portable tool. The tool is developed on UNIX
Xand ported to MSDOS, to VAX-VMS and to Macintosh. On those 'ported' machines
Xthe library isn't created, but list.c and list.h were treated the same as
Xall the other source-files (*.[ch]) of the program, which used the Linked
XList Tool.
X.SH EXAMPLE
X.if t .ta 0.3i 0.6i 0.9i 1.2i 3.2i 4.2i 4.5i 4.8i
X.nf
X#include	"list.h"
X
Xint	search();
X
Xtypedef struct rapport {
X	char		nummer[9];
X	char		title[30];
X	char		author[15];
X	int		date;
X} rapport;
X
Xmain()
X{
X	int			id, code, dat, size = sizeof(rapport);
X	rapport		rap;
X
X	id = lDef(SINGLY, CHAIN);
X
X	strcpy(rap.nummer, "B-89-100");
X	strcpy(rap.title, "Book 1");
X	strcpy(rap.author, "People");
X	rap.date = 890129;
X	lInsNode(id, FIRST, &rap, size, 1);
X
X	strcpy(rap.nummer, "B-89-101");
X	strcpy(rap.title, "Book 2");
X	strcpy(rap.author, "More People");
X	rap.date = 890130;
X	lInsNode(id, FIRST, &rap, size, 2);
X
X	strcpy(rap.nummer, "B-89-102");
X	strcpy(rap.title, "Book 3");
X	strcpy(rap.author, "Lots of People");
X	rap.date = 890131;
X	lInsNode(id, LAST, &rap, size, 3);
X
X	printf("lGetNode\\n");
X	code = lGetNode(id, FIRST, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X
X	printf("lIndxNode\\n");
X	code = lIndxNode(id, 4, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, 2, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, -1, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, 3, &rap, size);
X	prRap(code, &rap);
X
X	printf("lFndNode\\n");
X	dat = 890129;
X	code = lFndNode(id, FIRST, search, &dat, &rap, size);
X	prRap(code, &rap);
X	code = lFndNode(id, NEXT, search, &dat, &rap, size);
X	prRap(code, &rap);
X	code = lFndNode(id, NEXT, search, &dat, &rap, size);
X	prRap(code, &rap);
X
X	code = lDump(id, "/tmp/.dump");
X	printf("lDump : %d\\n", code);
X
X	lDel(id);
X
X	id = lUndump("/tmp/.dump");
X	printf("lUndump : %d\\n", id);
X	
X	strcpy(rap.nummer, "B-89-001");
X	strcpy(rap.title, "Book 4");
X	strcpy(rap.author, "The Author");
X	rap.date = 891127;
X	lInsNode(id, FIRST, &rap, size, 4);
X	
X	printf("lGetNode\n");
X	code = lGetNode(id, FIRST, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X
X	printf("lFlagNode\n");
X	code = lFlagNode(id, FIRST, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X
X	lDelAll();
X}
X
Xint
Xsearch(date, rpprt)
Xint			*date;
Xrapport		*rpprt;
X{
X	if (rpprt->date > *date)
X		return(FOUND);
X	else
X		return(NOT_FOUND);
X}
X
XprRap(code, rpprt)
Xint			code;
Xrapport		*rpprt;
X{
X	if (code >= 0)
X		printf("rapport :'%s' '%s' '%s' '%d'\\n", rpprt->nummer, rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		printf("Return code = %d\\n", code);
X}
X.fi
X.sp 2
XThis example program produces the following output :
X.nf
X	lGetNode
X	rapport :'B-89-101' 'Book 2' 'More People' '890130'
X	rapport :'B-89-100' 'Book 1' 'People' '890129'
X	rapport :'B-89-102' 'Book 3' 'Lots of People' '890131'
X	Return code = -9
X	lIndxNode
X	Return code = -13
X	rapport :'B-89-100' 'Book 1' 'People' '890129'
X	Return code = -13
X	rapport :'B-89-102' 'Book 3' 'Lots of People' '890131'
X	lFndNode
X	rapport :'B-89-101' 'Book 2' 'More People' '890130'
X	rapport :'B-89-102' 'Book 3' 'Lots of People' '890131'
X	Return code = -10
X	lDump : 0
X	lUndump : 1
X	lGetNode
X	rapport :'B-89-001' 'Book 4' 'The Author' '891127'
X	rapport :'B-89-101' 'Book 2' 'More People' '890130'
X	rapport :'B-89-100' 'Book 1' 'People' '890129'
X	rapport :'B-89-102' 'Book 3' 'Lots of People' '890131'
X	lFlagNode
X	rapport :'B-89-100' 'Book 1' 'People' '890129'
X	rapport :'B-89-102' 'Book 3' 'Lots of People' '890131'
X	rapport :'B-89-101' 'Book 2' 'More People' '890130'
X	Return code = -10
X.fi
X.SH VERSION
XLinked List Tool 0.7, March 1992.
X.SH PUBLIC DOMAIN
XThe Linked List Tool is in the public domain. If you have any comments,
Xsuggestions, or find any bugs, or make any changes you'd like to share,
Xplease let me know.
X.SH AUTHOR
XCopyright (c) 1992 by Anita Eijs (anita@bouw.tno.nl, Anita.Eijs@bouw.tno.nl).
X.sp 1
X.nf
XTNO - Bouw - BouwInformatica
XP.O. Box 49
X2600 AA Delft
XThe Netherlands
X.fi
END_OF_FILE
  if test 6595 -ne `wc -c <'Doc/Intro.1'`; then
    echo shar: \"'Doc/Intro.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/Intro.1'
fi
if test -f 'Doc/lDef.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDef.1'\"
else
  echo shar: Extracting \"'Doc/lDef.1'\" \(927 characters\)
  sed "s/^X//" >'Doc/lDef.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDef"
X.IX lDef
X.SH NAME
XlDef - Define linked list.
X.SH SYNOPSIS
Xint
X.BR "lDef" "(sd, cc)"
X.br
X.RT
X.RP
XIn	int	sd	singly or doubly linked list
X.RP
XIn	int	cc	chain or circular linked list
X.DT
X.SH DESCRIPTION
XTo define a linked list use \fBlDef\fP. It is possible to define a
Xsingly or doubly linked list and a chain or circular linked list.
XThe routine returns the identifier of the defined linked list (\(>= 1),
Xwhich must be used in the other routines of the linked list tool.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIsd\fP :
X.nf
X	SINGLY	singly linked list, each node points to the next node
X	DOUBLY	doubly linked list, each node points to the previous and
X		the next node
X.fi
X\fIcc\fP :
X.nf
X	CHAIN	chain linked list, last node has a NULL-pointer
X	CIRCULAR	circular linked list, last node points back to the first node
X.fi
X.SH ERROR CODES
X-1, -2
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 927 -ne `wc -c <'Doc/lDef.1'`; then
    echo shar: \"'Doc/lDef.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDef.1'
fi
if test -f 'Doc/lDel.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDel.1'\"
else
  echo shar: Extracting \"'Doc/lDel.1'\" \(322 characters\)
  sed "s/^X//" >'Doc/lDel.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDel"
X.IX lDel
X.SH NAME
XlDel - Delete linked list.
X.SH SYNOPSIS
Xint
X.BR "lDel" "(id)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.DT
X.SH DESCRIPTION
X\fBlDel\fP deletes a linked list. The routine returns 0 (zero) on success.
X.SH ERROR CODES
X-5
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 322 -ne `wc -c <'Doc/lDel.1'`; then
    echo shar: \"'Doc/lDel.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDel.1'
fi
if test -f 'Doc/lDelAll.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelAll.1'\"
else
  echo shar: Extracting \"'Doc/lDelAll.1'\" \(299 characters\)
  sed "s/^X//" >'Doc/lDelAll.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelAll"
X.IX lDelAll
X.SH NAME
XlDelAll - Delete all linked lists.
X.SH SYNOPSIS
Xint
X.BR "lDelAll" "()"
X.br
X.DT
X.SH DESCRIPTION
X\fBlDelAll\fP deletes all linked lists. The routine returns 0 (zero)
Xon success.
X.SH ERROR CODES
X-7
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 299 -ne `wc -c <'Doc/lDelAll.1'`; then
    echo shar: \"'Doc/lDelAll.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelAll.1'
fi
if test -f 'Doc/lDelNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelNode.1'\"
else
  echo shar: Extracting \"'Doc/lDelNode.1'\" \(664 characters\)
  sed "s/^X//" >'Doc/lDelNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelNode"
X.IX lDelNode
X.SH NAME
XlDelNode - Delete node.
X.SH SYNOPSIS
Xint
X.BR "lDelNode" "(id, which)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be deleted
X.DT
X.SH DESCRIPTION
X\fBlDelNode\fP deletes a node from a linked list. Which node must be
Xdeleted can be specified by \fIwhich\fP. The first, the current
Xand the last node of a linked list can be deleted. The routine returns
X0 (zero) on success.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	FIRST	first node
X	CURRENT	current node
X	LAST	last node
X.fi
X.SH ERROR CODES
X-4, -5, -8
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 664 -ne `wc -c <'Doc/lDelNode.1'`; then
    echo shar: \"'Doc/lDelNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelNode.1'
fi
if test -f 'Doc/lDump.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDump.1'\"
else
  echo shar: Extracting \"'Doc/lDump.1'\" \(755 characters\)
  sed "s/^X//" >'Doc/lDump.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDump"
X.IX lDump
X.SH NAME
XlDump - Dump a linked list to a file.
X.SH SYNOPSIS
Xint
X.BR "lDump" "(id, file)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlDump\fP is a linked list dumping utility. It allows the user to store
Xlinked list data in a specially formatted file, so the linked list data can
Xbe used within another program session. This file can be read by the linked
Xlist undumping utility lUndump. The routine returns 0 (zero) on success.
X.br
XDon't use pointers within your data structure, because only the pointers
Xwill be written in the dump file, not the data pointed to.
X.SH ERROR CODES
X-5, -14
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 755 -ne `wc -c <'Doc/lDump.1'`; then
    echo shar: \"'Doc/lDump.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDump.1'
fi
if test -f 'Doc/lFlagNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFlagNode.1'\"
else
  echo shar: Extracting \"'Doc/lFlagNode.1'\" \(725 characters\)
  sed "s/^X//" >'Doc/lFlagNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFlagNode"
X.IX lFlagNode
X.SH NAME
XlFlagNode - Get node by flag.
X.SH SYNOPSIS
Xint
X.BR "lFlagNode" "(id, flag, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	flag	flag of node which must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFlagNode\fP gets the data of a 'flagged' node of a linked list. Which
Xnode must be retrieved can be specified by a \fIflag\fP. The first node with
Xthe specified flag will be returned.
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value FIRST or LAST, otherwise zero.
X.SH ERROR CODES
X-5, -8, -10, -12
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 725 -ne `wc -c <'Doc/lFlagNode.1'`; then
    echo shar: \"'Doc/lFlagNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFlagNode.1'
fi
if test -f 'Doc/lFndNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFndNode.1'\"
else
  echo shar: Extracting \"'Doc/lFndNode.1'\" \(1383 characters\)
  sed "s/^X//" >'Doc/lFndNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFndNode"
X.IX lFndNode
X.SH NAME
XlFndNode - Find node.
X.SH SYNOPSIS
Xint
X.BR "lFndNode" "(id, where, func, ptr, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	where	from where must be searched
X.RP
XIn	int	(*func)()	function for checking the data on conditions
X.RP
XIn	Byte	*ptr	data for comparison in function
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFndNode\fP searches a node from the linked list, using the user
Xdefined function \fIfunc\fP, which checks the data of a node on conditions.
XThis function must have two parameters, a pointer to the data to compare with
Xand a pointer to the data of a node. The possible return values are FOUND or
XNOT_FOUND. From where the node must be
Xsearched can be specified by \fIwhere\fP. A node can be searched forward
Xfrom the
Xbeginning of the list or from the current node and backward from the current
Xnode or from the end of the list.
X.br
XWhen a singly linked list is defined only forward searching is possible.
X.br
XWhen the found node is the first or the last node, the return code will
Xhave the value FIRST or LAST.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhere\fP :
X.nf
X	FIRST	first node
X	PREVIOUS	previous node
X	NEXT	next node
X	LAST	last node
X.fi
X.SH ERROR CODES
X-3, -5, -6, -8, -10, -11
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1383 -ne `wc -c <'Doc/lFndNode.1'`; then
    echo shar: \"'Doc/lFndNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFndNode.1'
fi
if test -f 'Doc/lGetNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lGetNode.1'\"
else
  echo shar: Extracting \"'Doc/lGetNode.1'\" \(1095 characters\)
  sed "s/^X//" >'Doc/lGetNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lGetNode"
X.IX lGetNode
X.SH NAME
XlGetNode - Get node.
X.SH SYNOPSIS
Xint
X.BR "lGetNode" "(id, which, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlGetNode\fP gets the data of a node of a linked list. Which node must be
Xretrieved can be specified by \fIwhich\fP. The first node,
Xthe current node, the node before or after the current node
Xand the node at the end of the list can be retrieved.
X.br
XWhen a singly linked list is defined only forward retrieving is possible,
Xthe previous node can't be get.
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value FIRST or LAST. For the other nodes the routine returns
X0 (zero) on success.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	FIRST	first node
X	PREVIOUS	previous node
X	CURRENT	current node
X	NEXT	next node
X	LAST	last node
X.fi
X.SH ERROR CODES
X-4, -5, -8, -9, -11, -12
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1095 -ne `wc -c <'Doc/lGetNode.1'`; then
    echo shar: \"'Doc/lGetNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lGetNode.1'
fi
if test -f 'Doc/lIndxNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lIndxNode.1'\"
else
  echo shar: Extracting \"'Doc/lIndxNode.1'\" \(719 characters\)
  sed "s/^X//" >'Doc/lIndxNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lIndxNode"
X.IX lIndxNode
X.SH NAME
XlIndxNode - Get node by index.
X.SH SYNOPSIS
Xint
X.BR "lIndxNode" "(id, index, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlIndxNode\fP gets the data of an indexed node of a linked list. Which
Xnode must be retrieved can be specified by \fIindex\fP (\(>= 1).
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value FIRST or LAST. For the other nodes the routine returns
X0 (zero) on success.
X.SH ERROR CODES
X-5, -8, -13
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 719 -ne `wc -c <'Doc/lIndxNode.1'`; then
    echo shar: \"'Doc/lIndxNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lIndxNode.1'
fi
if test -f 'Doc/lInfo.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfo.1'\"
else
  echo shar: Extracting \"'Doc/lInfo.1'\" \(646 characters\)
  sed "s/^X//" >'Doc/lInfo.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfo"
X.IX lInfo
X.SH NAME
XlInfo - Get information about linked list.
X.SH SYNOPSIS
Xint
X.BR "lInfo" "(id, sd, cc, n)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XOut	int	*sd	singly or doubly linked list
X.RP
XOut	int	*cc	chain or circular linked list
X.RP
XOut	int	*n	number of nodes
X.DT
X.SH DESCRIPTION
X\fBlInfo\fP returns some information about a linked list. The type of
Xthe linked list (\fIsd\fP and \fIcc\fP, defined by the user)
Xand the number of nodes added
Xto the linked list (\fIn\fP). The routine returns 0 (zero) on success.
X.SH ERROR CODES
X.if t .ta 0.5i
X-5
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 646 -ne `wc -c <'Doc/lInfo.1'`; then
    echo shar: \"'Doc/lInfo.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfo.1'
fi
if test -f 'Doc/lInfoNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfoNode.1'\"
else
  echo shar: Extracting \"'Doc/lInfoNode.1'\" \(1135 characters\)
  sed "s/^X//" >'Doc/lInfoNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfoNode"
X.IX lInfoNode
X.SH NAME
XlInfoNode - Get information about node.
X.SH SYNOPSIS
Xint
X.BR "lInfoNode" "(id, which, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be inspected
X.RP
XOut	int	*size	size of data of node
X.RP
XOut	int	*flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInfoNode\fP returns some information about a node.
XThe size of the data of the node (\fIsize\fP)
Xand the user information flag (\fIflag\fP).
XOf which node the information must be given can be specified by \fIwhich\fP.
XThe first node, the current node, the node before or
Xafter the current node and the node at the end of the list can be inspected.
XThe routine returns 0 (zero) on success.
X.br
XWhen a singly linked list is defined only forward information retrieving
Xis possible, the previous node can't be inspected.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	FIRST	first node
X	PREVIOUS	previous node
X	CURRENT	current node
X	NEXT	next node
X	LAST	last node
X.fi
X.SH ERROR CODES
X.if t .ta 0.5i
X-4, -5, -8 -9, -11
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1135 -ne `wc -c <'Doc/lInfoNode.1'`; then
    echo shar: \"'Doc/lInfoNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfoNode.1'
fi
if test -f 'Doc/lInsNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInsNode.1'\"
else
  echo shar: Extracting \"'Doc/lInsNode.1'\" \(1031 characters\)
  sed "s/^X//" >'Doc/lInsNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInsNode"
X.IX lInsNode
X.SH NAME
XlInsNode - Insert node.
X.SH SYNOPSIS
Xint
X.BR "lInsNode" "(id, where, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	where	place where node must be inserted
X.RP
XIn	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInsNode\fP inserts a node in a linked list. Where the node must be
Xinserted can be specified by \fIwhere\fP. A node can be added at the
Xfront of the list, before or after the current node
Xand at the end of the list.
XFor each node a flag can be set by the user, e.g. to identify the node or
Xthe type of node. When the flag identifies the node you can retrieve the
Xnodes by flag (lFlagNode). The routine returns 0 (zero) on success.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhere\fP :
X.nf
X	FIRST	as first node
X	BEFORE	before current node
X	AFTER	after current node
X	LAST	as last node
X.fi
X.SH ERROR CODES
X-3, -5
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1031 -ne `wc -c <'Doc/lInsNode.1'`; then
    echo shar: \"'Doc/lInsNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInsNode.1'
fi
if test -f 'Doc/lUndump.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUndump.1'\"
else
  echo shar: Extracting \"'Doc/lUndump.1'\" \(719 characters\)
  sed "s/^X//" >'Doc/lUndump.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUndump"
X.IX lUndump
X.SH NAME
XlUndump - Undump a linked list from a file.
X.SH SYNOPSIS
Xint
X.BR "lUndump" "(file)"
X.br
X.RT
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlUndump\fP is a linked list undumping utility. The user will be able to
Xuse linked list data that was saved by lDump in the same or an earlier
Xprogram session. The linked list data was saved in a specially formatted
Xfile by lDump. The routine returns the identifier of the undumped linked
Xlist (\(>= 1), which must be used in the other routines of the linked list
Xtool. This identifier doesn't have to be the same as used by lDump.
X.SH ERROR CODES
X-14
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 719 -ne `wc -c <'Doc/lUndump.1'`; then
    echo shar: \"'Doc/lUndump.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUndump.1'
fi
if test -f 'Doc/lUpdNode.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUpdNode.1'\"
else
  echo shar: Extracting \"'Doc/lUpdNode.1'\" \(634 characters\)
  sed "s/^X//" >'Doc/lUpdNode.1' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUpdNode"
X.IX lUpdNode
X.SH NAME
XlUpdNode - Update current node.
X.SH SYNOPSIS
Xint
X.BR "lUpdNode" "(id, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	Byte	*data	updated data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlUpdNode\fP updates the current node in a linked list, in fact
Xthis routine replaces the data of the current node by the data of the
Xupdated node.
XThe flag for user information can also be updated. The routine returns
X0 (zero) on success.
X.SH ERROR CODES
X-5, -8
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 634 -ne `wc -c <'Doc/lUpdNode.1'`; then
    echo shar: \"'Doc/lUpdNode.1'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUpdNode.1'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(1730 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Linked List Tool
X#
X# Anita Eijs, TNO-BOUW, BouwInformatica, September 1989
X
XTOOLS_HOME	= /usr1/user/anita/Tools
X
X# Name of current directory
XDIR	= List
X
X# Name of library
XLIB	= $(TOOLS_HOME)/Lib/list.a
X
X# Include rules for package
XMAKERULE= Tools_makerule
XRULE	= $(TOOLS_HOME)/$(MAKERULE)
Xinclude $(RULE)
X
X# Contents of current directory
XLIST	= Makefile README example.c list.c list.h
X
X# Documentation
XDOC	= \
X	Doc/Intro.1		Doc/lDef.1		Doc/lDel.1 \
X	Doc/lDelAll.1		Doc/lDelNode.1		Doc/lDump.1 \
X	Doc/lFlagNode.1		Doc/lFndNode.1		Doc/lGetNode.1 \
X	Doc/lIndxNode.1		Doc/lInfo.1		Doc/lInfoNode.1 \
X	Doc/lInsNode.1		Doc/lUndump.1		Doc/lUpdNode.1
X
XDOC_ALL = \
X	Doc/list_doc.ps		Doc/*.man
X
X# Object dependencies
XOBJ	= list.o
X
XLIB_OBJ	= $(LIB)(list.o)
X
X# The targets
Xusge:
X		$(ECHO)
X		$(ECHO) $(USAGE_ID)
X		$(ECHO) $(USAGE_TARGETS)
X		$(ECHO) $(USAGE_USAGE)
X		$(ECHO) $(USAGE_LIB)
X		$(ECHO) $(USAGE_NEWLIB)
X		$(ECHO) $(USAGE_OFILES)
X		$(ECHO) $(USAGE_TEST)
X		$(ECHO) $(USAGE_TAR)
X		$(ECHO)
X		$(ECHO) $(USAGE_DEFLTS1)
X		$(ECHO) $(USAGE_DEFLTS2)
X		$(ECHO) $(USAGE_DEFLTS3)
X
Xlib:		$(LIB_OBJ)
X		$(RANLIB) $(LIB)
X
Xnewlib:		$(OBJ)
X		$(AR) r $(LIB) *.o
X		rm -f *.o
X		$(RANLIB) $(LIB)
X
Xofiles:		$(OBJ)
X
Xtest:		example
X
Xexample:	$(LIB) example.o
X		cc -o example example.o $(LIB)
X
Xtar:
X		$(ECHO) "Making tar-file in $(TARFILE)"
X		cp ../$(MAKERULE) $(MAKERULE)
X		tar cvf $(TARFILE) $(MAKERULE) $(LIST) $(DOC)
X		rm $(MAKERULE)
X
Xshar:
X		$(ECHO) "Making shar-file in $(SHARFILE)"
X		cp ../$(MAKERULE) $(MAKERULE)
X		shar $(MAKERULE) $(LIST) Doc $(DOC) $(DOC_ALL) > $(SHARFILE)
X		rm $(MAKERULE)
X
Xshort_shar:
X		$(ECHO) "Making shar-file in $(SHARFILE)"
X		cp ../$(MAKERULE) $(MAKERULE)
X		shar $(MAKERULE) $(LIST) Doc $(DOC) > $(SHARFILE)
X		rm $(MAKERULE)
END_OF_FILE
  if test 1730 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'Tools_makerule' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tools_makerule'\"
else
  echo shar: Extracting \"'Tools_makerule'\" \(826 characters\)
  sed "s/^X//" >'Tools_makerule' <<'END_OF_FILE'
XTARFILE		= /tmp/Tools$(DIR).tar
XSHARFILE	= /tmp/Tools$(DIR).shar
XAR		= ar
X# RANLIB should be :
X# echo :	IRIX System V Release 3.3.1, Silicon Graphics, Inc.
X# ranlib :	Sun Sparc2 SunOS, Berkeley UNIX
X#	(AE, Dec 91)
X#RANLIB		= echo "Ready with"
XRANLIB		= ranlib
XCOFLAGS		= -q
XCFLAGS		= -O
X
X# Set defaults for macro's
XECHO		= echo $(INDNTTN)
XARG_INDNTTN	= INDNTTN="$(INDNTTN)'	'"
X
X# Help macro
XUSAGE_ID	= "Makefile of directory $(DIR)"
XUSAGE_TARGETS	= "Targets are:"
XUSAGE_USAGE	= "usge		= Prints this"
XUSAGE_LIB	= "lib		= Make objects for LIB"
XUSAGE_NEWLIB	= "newlib		= Make objects and place them in LIB"
XUSAGE_OFILES	= "ofiles		= Make objects"
XUSAGE_TEST	= "test/example	= Make test program"
XUSAGE_TAR	= "tar		= Make TARFILE"
XUSAGE_DEFLTS1	= "defaults:"
XUSAGE_DEFLTS2	= "	TARFILE = $(TARFILE)"
XUSAGE_DEFLTS3	= "	LIB = $(LIB)"
END_OF_FILE
  if test 826 -ne `wc -c <'Tools_makerule'`; then
    echo shar: \"'Tools_makerule'\" unpacked with wrong size!
  fi
  # end of 'Tools_makerule'
fi
if test -f 'example.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example.c'\"
else
  echo shar: Extracting \"'example.c'\" \(2666 characters\)
  sed "s/^X//" >'example.c' <<'END_OF_FILE'
X#include	"list.h"
X
Xint	search();
X
Xtypedef struct rapport {
X	char		nummer[9];
X	char		title[30];
X	char		author[15];
X	int		date;
X} rapport;
X
Xmain()
X{
X	int			id, code, dat, size = sizeof(rapport);
X	rapport		rap;
X
X	id = lDef(SINGLY, CHAIN);
X
X	strcpy(rap.nummer, "B-89-100");
X	strcpy(rap.title, "Book 1");
X	strcpy(rap.author, "People");
X	rap.date = 890129;
X	lInsNode(id, FIRST, &rap, size, 1);
X
X	strcpy(rap.nummer, "B-89-101");
X	strcpy(rap.title, "Book 2");
X	strcpy(rap.author, "More People");
X	rap.date = 890130;
X	lInsNode(id, FIRST, &rap, size, 2);
X
X	strcpy(rap.nummer, "B-89-102");
X	strcpy(rap.title, "Book 3");
X	strcpy(rap.author, "Lots of People");
X	rap.date = 890131;
X	lInsNode(id, LAST, &rap, size, 3);
X
X	printf("lGetNode\n");
X	code = lGetNode(id, FIRST, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X
X	printf("lIndxNode\n");
X	code = lIndxNode(id, 4, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, 2, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, -1, &rap, size);
X	prRap(code, &rap);
X	code = lIndxNode(id, 3, &rap, size);
X	prRap(code, &rap);
X
X	printf("lFndNode\n");
X	dat = 890129;
X	code = lFndNode(id, FIRST, search, &dat, &rap, size);
X	prRap(code, &rap);
X	code = lFndNode(id, NEXT, search, &dat, &rap, size);
X	prRap(code, &rap);
X	code = lFndNode(id, NEXT, search, &dat, &rap, size);
X	prRap(code, &rap);
X
X	code = lDump(id, "/tmp/.dump");
X	printf("lDump : %d\n", code);
X
X	lDel(id);
X
X	id = lUndump("/tmp/.dump");
X	printf("lUndump : %d\n", id);
X
X	strcpy(rap.nummer, "B-89-001");
X	strcpy(rap.title, "Book 4");
X	strcpy(rap.author, "The Author");
X	rap.date = 891127;
X	lInsNode(id, FIRST, &rap, size, 4);
X
X	printf("lGetNode\n");
X	code = lGetNode(id, FIRST, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X	code = lGetNode(id, NEXT, &rap, size);
X	prRap(code, &rap);
X
X	printf("lFlagNode\n");
X	code = lFlagNode(id, 1, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, 3, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, 2, &rap, size);
X	prRap(code, &rap);
X	code = lFlagNode(id, 7, &rap, size);
X	prRap(code, &rap);
X
X	lDelAll();
X}
X
Xint
Xsearch(date, rpprt)
Xint			*date;
Xrapport		*rpprt;
X{
X	if (rpprt->date > *date)
X		return(FOUND);
X	else
X		return(NOT_FOUND);
X}
X
XprRap(code, rpprt)
Xint			code;
Xrapport		*rpprt;
X{
X	if (code >= 0)
X		printf("rapport :'%s' '%s' '%s' '%d'\n", rpprt->nummer, rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		printf("Return code = %d\n", code);
X}
END_OF_FILE
  if test 2666 -ne `wc -c <'example.c'`; then
    echo shar: \"'example.c'\" unpacked with wrong size!
  fi
  # end of 'example.c'
fi
if test -f 'list.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list.c'\"
else
  echo shar: Extracting \"'list.c'\" \(21105 characters\)
  sed "s/^X//" >'list.c' <<'END_OF_FILE'
X/*
X *	Anita Eijs	TNO-BOUW, BouwInformatica	May 1989
X *
X *	Linked List Tool
X *
X *	Updates:
X *	900402	new routine 'lIndxNode' : 'get node by index'
X *
X *	900925	new routine 'lError' : 'print error message in ERROR_FILE'
X *
X *	901129	new routines 'lDump' : 'dump a linked list to a file'
X *		and 'lUndump' : 'undump a linked list from a file'
X *
X *	910301	'Mac'ed by Vinnie : ListPtr=ListyPtr, Byte = byte, includes and
X *		typecasts
X *
X *	910316	new routine 'lFlagNode' : 'get node by flag'
X */
X
X#ifdef MAC
X#define	MAC_OR_VAXC
X#endif
X#ifdef VAXC
X#define	MAC_OR_VAXC
X#endif
X
X#ifdef MAC
X#include	<unix.h>	/* open, creat, write, read, close */
X#include	<stddef.h>	/* sizeof */
X#endif
X
X#ifdef MAC_OR_VAXC
X#include	<stdlib.h>
X#else
X#include	<malloc.h>
X#endif
X
X#include	<stdio.h>
X#include	"list.h"
X
X#undef	FREE
X#define FREE(VAR) if (VAR != NULL) free((char *)VAR);
X#undef	MALLOC
X#define MALLOC(VAR, TYPE) \
X	if ((VAR = (TYPE *)malloc(sizeof(TYPE))) == NULL) { \
X		fprintf(stderr, "No more memory for malloc().\n"); \
X	}
X#undef	CALLOC
X#define CALLOC(VAR, TYPE, NR) \
X	if ((VAR = (TYPE *)calloc(NR, sizeof(TYPE))) == NULL) {\
X		fprintf(stderr, "No more memory for calloc().\n"); \
X	}
X
X#undef	BYTE_COPY
X#define BYTE_COPY(FROM, TO, SIZE) \
X	{ \
X		register Byte	*frm = FROM, \
X				*to = TO; \
X		int		i = SIZE; \
X		while (i--) *to++ = *frm++; \
X	}
X
X#ifndef ANSI
Xtypedef	int		(*Func)();
Xtypedef	unsigned char	Byte;
X#endif
X
Xtypedef struct lnode {
X	Byte		*data;	/* data of user */
X	int		size;	/* size (number of bytes) of data */
X	int		flag;	/* user information flag */
X	struct lnode	*prv;	/* previous node */
X	struct lnode	*nxt;	/* next node */
X} ListNode, *NodePtr;
X
Xtypedef struct listhdr {
X	int		id;		/* identifier of linked list */
X	int		sd;		/* singly or doubly linked */
X	int		cc;		/* chain or circular list */
X	int		n;		/* number of nodes */
X	NodePtr		first;		/* address of first node */
X	NodePtr		current;	/* address of current node */
X	NodePtr		last;		/* address of last node */
X	struct listhdr	*nxt;		/* next linked list */
X} ListHdr, *ListPtr;
X
Xtypedef struct header {	/* general info of linked list for dump file */
X	int	sd;
X	int	cc;
X	int	n;
X} Header;
X
Xtypedef struct info {	/* general info of node for dump file */
X	int	size;
X	int	flag;
X} Info;
X
X#define	BIN_WRITE	1	/* necessary for binary file access */
X#define	BIN_READ	0
X#define	PMODE		0666
X
Xstatic ListHdr	firstlist = { 1, 0, 0, 0, NULL, NULL, NULL, NULL };
X
Xstatic ListPtr	ld = &firstlist;
Xstatic int	idMax = 2;
X
Xstatic ListPtr	getAddress();
Xstatic void	lError();
X
X/* define a new linked list and create info about it */
X#ifdef ANSI
Xint
XlDef(int sd, int cc)
X#else
Xint
XlDef(sd, cc)
Xint	sd, cc;
X#endif
X{
X	ListPtr	list, new;
X
X	if (sd != SINGLY && sd != DOUBLY) {
X		lError("lDef", WRONG_SD, sd, 0, NULL);
X		return(WRONG_SD);
X	}
X	if (cc != CHAIN && cc != CIRCULAR) {
X		lError("lDef", WRONG_CC, cc, 0, NULL);
X		return(WRONG_CC);
X	}
X
X	list = ld;
X	while (list->nxt != NULL && list->sd != 0)
X		list = list->nxt;
X	if (list->sd != 0) {	/* new list */
X		MALLOC(new, ListHdr);
X		new->id = idMax++;
X		new->sd = sd;
X		new->cc = cc;
X		new->n = 0;
X		new->first = new->current = new->last = NULL;
X		new->nxt = NULL;
X		list->nxt = new;
X		return(new->id);
X	} else {		/* new list on existing place */
X		list->sd = sd;
X		list->cc = cc;
X		return(list->id);
X	}
X}
X
X/* insert a node in linked list */
X#ifdef ANSI
Xint
XlInsNode(int id, int where, Byte *data, int size, int flag)
X#else
Xint
XlInsNode(id, where, data, size, flag)
Xint	id, where, size, flag;
XByte	*data;
X#endif
X{
X	ListPtr	list;
X	NodePtr	node, new;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lInsNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (where != FIRST && where != BEFORE && where != AFTER
X			&& where != LAST) {
X		lError("lInsNode", WRONG_WHERE, where, 0, NULL);
X		return(WRONG_WHERE);
X	}
X
X		/* create new node */
X	MALLOC(new, ListNode);
X	CALLOC(new->data, Byte, size);
X	BYTE_COPY(data, new->data, size);
X	new->size = size;
X	new->flag = flag;
X
X		/* specific insert cases */
X	if (list->first == NULL)
X		where = ONE_NODE;	/* first node in list */
X	else if (list->current == list->first && where == BEFORE)
X		where = FIRST;		/* before first is like insert first */
X	else if (list->current == list->last && where == AFTER)
X		where = LAST;		/* after last is like insert last */
X
X	switch (where) {
X	case ONE_NODE :
X		if (list->cc == CHAIN)
X			new->prv = new->nxt = NULL;
X		else {
X			if (list->sd == DOUBLY)
X				new->prv = new;
X			else
X				new->prv = NULL;
X			new->nxt = new;
X		}
X		list->first = list->last = new;
X		break;
X	case FIRST :
X		new->prv = (list->first)->prv;
X		new->nxt = list->first;
X		if (list->cc == CIRCULAR)
X			(list->last)->nxt = new;
X		else
X			(list->last)->nxt = NULL;
X		if (list->sd == DOUBLY)
X			(list->first)->prv = new;
X		list->first = new;
X		break;
X	case BEFORE :
X		new->prv = (list->current)->prv;	/* == NULL if SINGLY */
X		new->nxt = list->current;
X
X		if (list->sd == DOUBLY) {
X			((list->current)->prv)->nxt = new;
X			(list->current)->prv = new;
X		} else {
X			node = list->first;
X				/* search for last before current */
X			while (node->nxt != list->current && node != list->last)
X				node = node->nxt;
X			node->nxt = new;
X		}
X		if (list->current == list->first)
X			list->first = new;
X		break;
X	case AFTER :
X		if (list->sd == DOUBLY)
X			new->prv = list->current;
X		else
X			new->prv = NULL;
X		new->nxt = (list->current)->nxt;
X		if (list->sd == DOUBLY) {
X			((list->current)->nxt)->prv = new;
X			(list->current)->prv = new;
X		}
X		(list->current)->nxt = new;
X		if (list->current == list->last)
X			list->last = new;
X		break;
X	case LAST :
X		node = list->last;
X		if (list->sd == DOUBLY)
X			new->prv = node;
X		else
X			new->prv = NULL;
X		if (list->cc == CIRCULAR)
X			new->nxt = list->first;
X		else
X			new->nxt = NULL;
X		if (list->sd == DOUBLY && list->cc == CIRCULAR)
X			(list->first)->prv = new;
X		node->nxt = new;
X		list->last = new;
X		break;
X	}
X	list->n++;
X	list->current = new;
X	return(0);
X}
X
X/* update current node in linked list */
X#ifdef ANSI
Xint
XlUpdNode(int id, Byte *data, int size, int flag)
X#else
Xint
XlUpdNode(id, data, size, flag)
Xint	id, size, flag;
XByte	*data;
X#endif
X{
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lUpdNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->current == NULL) {
X		lError("lUpdNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X
X		/* if same size, replace node by updated node */
X		/* if not same size, insert updated node on current place */
X	if ((list->current)->size != size) {
X		FREE((list->current)->data);
X		CALLOC((list->current)->data, Byte, size);
X		(list->current)->size = size;
X	}
X	(list->current)->flag = flag;
X	BYTE_COPY(data, (list->current)->data, size);
X	return(0);
X}
X
X/* get data of node */
X#ifdef ANSI
Xint
XlGetNode(int id, int which, Byte *data, int size)
X#else
Xint
XlGetNode(id, which, data, size)
Xint	id, which, size;
XByte	*data;
X#endif
X{
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lGetNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->first == NULL) {
X		lError("lGetNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X
X	switch (which) {
X	case FIRST :
X		list->current = list->first;
X		break;
X	case NEXT :
X		if ((list->current)->nxt == NULL) {
X			lError("lGetNode", EOL, id, 0, NULL);
X			return(EOL);
X		}
X		list->current = (list->current)->nxt;
X		break;
X	case CURRENT :
X		break;
X	case PREVIOUS :
X		if (list->sd != DOUBLY) {
X			lError("lGetNode", NOT_DOUBLY, id, 0, NULL);
X			return(NOT_DOUBLY);
X		}
X		if ((list->current)->prv == NULL) {
X			lError("lGetNode", EOL, id, 0, NULL);
X			return(EOL);
X		}
X		list->current = (list->current)->prv;
X		break;
X	case LAST :
X		list->current = list->last;
X		break;
X	default :
X		lError("lGetNode", WRONG_WHICH, which, 0, NULL);
X		return(WRONG_WHICH);
X	}
X		/* expected data and node must have same size */
X	if ((list->current)->size != size) {
X		lError("lGetNode", SIZE_NE, size, (list->current)->size, NULL);
X		return(SIZE_NE);
X	} else {
X		BYTE_COPY((list->current)->data, data, size);
X		if (list->current == list->last)
X			return(LAST);
X		else if (list->current == list->first)
X			return(FIRST);
X		else
X			return(0);
X	}
X}
X
X/* get data of node 'index' */
X#ifdef ANSI
Xint
XlIndxNode(int id, int index, Byte *data, int size)
X#else
Xint
XlIndxNode(id, index, data, size)
Xint	id, index, size;
XByte	*data;
X#endif
X{
X	ListPtr	list;
X	int	i;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lIndxNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->first == NULL) {
X		lError("lIndxNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X	if (0 >= index || list->n < index) {
X		lError("lIndxNode", WRONG_INDEX, index, list->n, NULL);
X		return(WRONG_INDEX);
X	}
X
X	if (index == 1)
X		list->current = list->first;
X	else if (index == list->n)
X		list->current = list->last;
X	else {
X		list->current = list->first;
X		for (i=1; i<index; i++)
X			list->current = (list->current)->nxt;
X	}
X
X	BYTE_COPY((list->current)->data, data, size);
X	if (list->current == list->last)
X		return(LAST);
X	else if (list->current == list->first)
X		return(FIRST);
X	else
X		return(0);
X}
X
X/* find data of node for which the function returns FOUND */
X#ifdef ANSI
Xint
XlFndNode(int id, int where, Func func, Byte *ptr, Byte *data, int size)
X#else
Xint
XlFndNode(id, where, func, ptr, data, size)
Xint	id, where, size;
XFunc	func;
XByte	*ptr, *data;
X#endif
X{
X	NodePtr	node;
X	ListPtr	list;
X	int	code = NOT_FOUND;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lFndNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->first == NULL) {
X		lError("lFndNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X	if (func == NULL) {
X		lError("lFndNode", UNKNOWN_FUNC, func, 0, NULL);
X		return(UNKNOWN_FUNC);
X	}
X	
X	switch (where) {
X	case FIRST :
X		node = list->first;
X		break;
X	case NEXT :
X	case PREVIOUS :
X		node = list->current;
X		break;
X	case LAST :
X		node = list->last;
X		break;
X	default :
X		lError("lFndNode", WRONG_WHERE, where, 0, NULL);
X		return(WRONG_WHERE);
X	}
X
X		/* expected data and node must have same size */
X	if ((where == FIRST || where == LAST) && node->size == size) {
X		BYTE_COPY(node->data, data, size);
X		code = (*func)(ptr, data);
X	}
X
X	switch (where) {
X	case FIRST :
X	case NEXT :
X		while (code != FOUND && node->nxt != NULL
X				&& node != list->last) {
X			node = node->nxt;
X				/* expected data and node must have same size */
X			if (node->size == size) {
X				BYTE_COPY(node->data, data, size);
X				code = (*func)(ptr, data);
X			}
X		}
X		if (code == FOUND) {
X			list->current = node;
X			if (list->current == list->last)
X				return(LAST);
X		}
X		break;
X	case PREVIOUS :
X	case LAST :
X		if (list->sd != DOUBLY && code == NOT_FOUND) {
X			lError("lFndNode", NOT_DOUBLY, id, 0, NULL);
X			return(NOT_DOUBLY);
X		}
X		while (code != FOUND && node->prv != NULL
X				&& node->prv != list->first) {
X			node = node->prv;
X				/* expected data and node must have same size */
X			if (node->size == size) {
X				BYTE_COPY(node->data, data, size);
X				code = (*func)(ptr, data);
X			}
X		}
X		if (code == FOUND) {
X			list->current = node;
X			if (list->current == list->first)
X				return(FIRST);
X		}
X		break;
X	}
X	return(code);
X}
X
X/* delete node from linked list */
X#ifdef ANSI
Xint
XlDelNode(int id, int which)
X#else
Xint
XlDelNode(id, which)
Xint	id, which;
X#endif
X{
X	NodePtr	node, prv, nxt;
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lDelNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->first == NULL) {
X		lError("lDelNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X
X		/* specific delete cases */
X	if (list->n == 1)
X		which = ONE_NODE;	/* one node in linked list */
X        else if (which == CURRENT && list->first == list->current)
X                which = FIRST;		/* current is also first node */
X        else if (which == CURRENT && list->last == list->current)
X                which = LAST;		/* current is also last node */
X
X	switch (which) {
X	case ONE_NODE :
X		node = list->first;
X		list->first = list->current = list->last = NULL;
X		break;
X	case FIRST :
X		node = list->first;
X		nxt = node->nxt;
X		if (list->cc == CIRCULAR) {
X			prv = list->last;
X			prv->nxt = nxt;
X		} else
X			prv = node->prv;	/* == NULL if SINGLY */
X		if (list->sd == DOUBLY)
X			nxt->prv = prv;
X		list->first = list->current = nxt;
X		break;
X	case CURRENT :
X		node = list->current;
X		nxt = node->nxt;
X		if (list->sd == DOUBLY) {
X			prv = node->prv;
X			nxt->prv = prv;
X		} else {
X			prv = node = list->first;
X			while (node != list->current) {
X				prv = node;
X				node = node->nxt;
X			}
X			if (prv == node)
X				prv = list->last;
X		}
X		prv->nxt = nxt;
X		list->current = nxt;
X		break;
X	case LAST :
X		node = list->last;
X		if (list->sd == DOUBLY)
X			prv = node->prv;
X		else {
X			if (list->current != list->last)
X				prv = node = list->current;
X			else
X				prv = node = list->first;
X			while (node != list->last) {
X				prv = node;
X				node = node->nxt;
X			}
X		}
X		nxt = node->nxt;
X		if (list->sd == DOUBLY && list->cc == CIRCULAR)
X			nxt->prv = prv;
X		prv->nxt = nxt;
X		list->last = list->current = prv;
X		break;
X	default :
X		lError("lDelNode", WRONG_WHICH, which, 0, NULL);
X		return(WRONG_WHICH);
X	}
X	FREE(node->data);
X	FREE(node);
X	list->n--;
X	return(0);
X}
X
X/* get info of linked list */
X#ifdef ANSI
Xint
XlInfo(int id, int *sd, int *cc, int *n)
X#else
Xint
XlInfo(id, sd, cc, n)
Xint	id, *sd, *cc, *n;
X#endif
X{
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lInfo", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X
X	*sd = list->sd;
X	*cc = list->cc;
X	*n = list->n;
X	return(0);
X}
X
X/* get info of node of linked list */
X#ifdef ANSI
Xint
XlInfoNode(int id, int which, int *size, int *flag)
X#else
Xint
XlInfoNode(id, which, size, flag)
Xint	id, which, *size, *flag;
X#endif
X{
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lInfoNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->n == 0) {
X		lError("lInfoNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X
X	switch (which) {
X	case FIRST :
X		list->current = list->first;
X		break;
X	case NEXT :
X		if ((list->current)->nxt == NULL) {
X			lError("lInfoNode", EOL, id, 0, NULL);
X			return(EOL);
X		}
X		list->current = (list->current)->nxt;
X		break;
X	case CURRENT :
X		break;
X	case PREVIOUS :
X		if (list->sd != DOUBLY) {
X			lError("lInfoNode", NOT_DOUBLY, id, 0, NULL);
X			return(NOT_DOUBLY);
X		}
X		if ((list->current)->prv == NULL) {
X			lError("lInfoNode", EOL, id, 0, NULL);
X			return(EOL);
X		}
X		list->current = (list->current)->prv;
X		break;
X	case LAST :
X		list->current = list->last;
X		break;
X	default :
X		lError("lInfoNode", WRONG_WHICH, which, 0, NULL);
X		return(WRONG_WHICH);
X	}
X	*size = (list->current)->size;
X	*flag = (list->current)->flag;
X	return(0);
X}
X
X/* delete a linked list and clear info about it */
X#ifdef ANSI
Xint
XlDel(int id)
X#else
Xint
XlDel(id)
Xint	id;
X#endif
X{
X	static void	delNodes();
X
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lDel", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X
X	delNodes(list->first, list->n);
X	list->sd = list->cc = list->n = 0;
X	list->first = list->current = list->last = NULL;
X	return(0);
X}
X
X/* delete all linked list and all info about those lists */
X#ifdef ANSI
Xint
XlDelAll(void)
X#else
Xint
XlDelAll()
X#endif
X{
X	static void	delListInfo();
X
X	ListPtr	list, nxt;
X
X	if (ld == NULL) {
X		lError("lDelAll", NO_LIST, 0, 0, NULL);
X		return(NO_LIST);
X	}
X
X	list = ld;
X	while (list != NULL) {
X		nxt = list->nxt;
X		lDel(list->id);
X		list = nxt;
X	}
X	delListInfo(ld->nxt);
X		/* save info of initial list */
X	firstlist.id = 1;
X	firstlist.sd = firstlist.cc = firstlist.n = 0;
X	firstlist.first = firstlist.current = firstlist.last = NULL;
X	firstlist.nxt = NULL;
X	ld = &firstlist;
X	idMax = 2;
X	return(0);
X}
X
X/* get address of list data */
X#ifdef ANSI
Xstatic ListPtr
XgetAddress(int id)
X#else
Xstatic ListPtr
XgetAddress(id)
Xint	id;
X#endif
X{
X	ListPtr	list;
X
X	list = ld;
X	while (list != NULL && list->id != id)
X		list = list->nxt;
X	return(list);
X}
X
X/* delete nodes of a linked list */
X#ifdef ANSI
Xstatic void
XdelNodes(NodePtr node, int n)
X#else
Xstatic void
XdelNodes(node, n)
XNodePtr	node;
Xint	n;
X#endif
X{
X	NodePtr	nxt;
X	int	i;
X
X	for (i=0; i<n; i++) {
X		nxt = node->nxt;
X		FREE(node->data);
X		FREE(node);
X		node = nxt;
X	}
X}
X
X/* delete info about linked list */
X#ifdef ANSI
Xstatic void
XdelListInfo(ListPtr list)
X#else
Xstatic void
XdelListInfo(list)
XListPtr	list;
X#endif
X{
X	ListPtr	nxt;
X
X	while (list != NULL) {
X		nxt = list->nxt;
X		FREE(list);
X		list = nxt;
X	}
X}
X
X/* print error message in ERROR_FILE */
X#ifdef ANSI
Xstatic void
XlError(char *str, int code, int int1, int int2, char *str1)
X#else
Xstatic void
XlError(str, code, int1, int2, str1)
Xchar	*str, *str1;
Xint	code, int1, int2;
X#endif
X{
X#ifndef MSDOS
X	char	mess[60];
X	FILE	*fpError, *fopen();
X
X	switch (code) {
X	case WRONG_SD :
X		sprintf(mess, "Parameter 'sd' has wrong value : %d", int1);
X		break;
X	case WRONG_CC :
X		sprintf(mess, "Parameter 'cc' has wrong value : %d", int1);
X		break;
X	case WRONG_WHERE :
X		sprintf(mess, "Parameter 'where' has wrong value : %d", int1);
X		break;
X	case WRONG_WHICH :
X		sprintf(mess, "Parameter 'which' has wrong value : %d", int1);
X		break;
X	case UNKNOWN_ID :
X		sprintf(mess, "List id '%d' is unknown", int1);
X		break;
X	case UNKNOWN_FUNC :
X		sprintf(mess, "Function '%d' is unknown", int1);
X		break;
X	case NO_LIST :
X		sprintf(mess, "There are no lists defined");
X		break;
X	case EMPTY_LIST :
X#ifdef DEBUG
X		sprintf(mess, "List '%d' is empty", int1);
X		break;
X#else
X		return;
X#endif
X	case EOL :
X#ifdef DEBUG
X		sprintf(mess, "End of list '%d' reached", int1);
X		break;
X#else
X		return;
X#endif
X	case NOT_FOUND :
X#ifdef DEBUG
X		sprintf(mess, "Node not found in list '%d'", int1);
X		break;
X#else
X		return;
X#endif
X	case NOT_DOUBLY :
X		sprintf(mess, "List '%d' is not doubly linked", int1);
X		break;
X	case SIZE_NE :
X		sprintf(mess,
X			"Size of expected data '%d' and node '%d' not equal",
X			int1, int2);
X		break;
X	case WRONG_INDEX :
X		sprintf(mess, "Index '%d' out of range [1:%d]", int1, int2);
X		break;
X	case OPEN_ERROR :
X		sprintf(mess, "Can't open dump-file '%s'\n", str1);
X		break;
X	}
X
X	fpError = fopen(ERROR_FILE, "a");
X	if (fpError == NULL) {
X		fprintf(stderr, "Can't open error-file '%s'\n", ERROR_FILE);
X		fprintf(stderr, "Error, '%s': %s\n", str, mess);
X	} else {
X		fprintf(fpError, "Error, '%s': %s\n", str, mess);
X		fclose(fpError);
X	}
X#endif
X}
X
X/* dump a linked list to a file */
X/* file structure :
X *	<header> { <info> <data> }
X *	header.n	number of <info>-<data>-combinations (nodes)
X *	info.size	size of <data>
X */
X#ifdef ANSI
Xint
XlDump(int id, char *file)
X#else
Xint
XlDump(id, file)
Xint	id;
Xchar	*file;
X#endif
X{
X	int	open(), creat(), write(), close();
X
X	int	fdDump, i;
X	ListPtr	list;
X	NodePtr	node;
X	Info	info;
X	Header	header;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lDump", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X
X	fdDump = open(file, BIN_WRITE);
X	if (fdDump == -1) {
X		fdDump = creat(file, PMODE);
X		if (fdDump == -1) {
X			lError("lDump", OPEN_ERROR, 0, 0, file);
X			return(OPEN_ERROR);
X		}
X	}
X
X	header.sd = list->sd;
X	header.cc = list->cc;
X	header.n = list->n;
X	write(fdDump, (char *) &header, sizeof(Header));
X
X	node = list->first;
X	for (i=0; i<header.n; i++) {
X		info.size = node->size;
X		info.flag = node->flag;
X		write(fdDump, (char *) &info, sizeof(Info));
X		write(fdDump, (char *) node->data, node->size);
X		node = node->nxt;
X	}
X
X	close(fdDump);
X	return(0);
X}
X
X/* undump a linked list from a file */
X#ifdef ANSI
Xint
XlUndump(char *file)
X#else
Xint
XlUndump(file)
Xchar	*file;
X#endif
X{
X	int	open(), read(), close();
X
X	int	fdDump, i, id;
X	Info	info;
X	Header	header;
X	Byte	*data;
X
X	fdDump = open(file, BIN_READ);
X	if (fdDump == -1) {
X		lError("lDump", OPEN_ERROR, 0, 0, file);
X		return(OPEN_ERROR);
X	}
X
X	read(fdDump, (char *) &header, sizeof(Header));
X	id = lDef(header.sd, header.cc);
X
X	for (i=0; i<header.n; i++) {
X		read(fdDump, (char *) &info, sizeof(Info));
X		CALLOC(data, Byte, info.size);
X		read(fdDump, (char *) data, info.size);
X		lInsNode(id, LAST, data, info.size, info.flag);
X		FREE(data);
X	}
X
X	close(fdDump);
X	return(id);
X}
X
X/* get data of node */
X#ifdef ANSI
Xint
XlFlagNode(int id, int flag, Byte *data, int size)
X#else
Xint
XlFlagNode(id, flag, data, size)
Xint	id, flag, size;
XByte	*data;
X#endif
X{
X	ListPtr	list;
X
X	if ((list = getAddress(id)) == NULL) {
X		lError("lFlagNode", UNKNOWN_ID, id, 0, NULL);
X		return(UNKNOWN_ID);
X	}
X	if (list->first == NULL) {
X		lError("lFlagNode", EMPTY_LIST, id, 0, NULL);
X		return(EMPTY_LIST);
X	}
X
X		/* search till end of list */
X	list->current = list->first;
X	while ((list->current)->flag != flag && list->current != list->last) {
X		list->current = (list->current)->nxt;
X	}
X
X		/* extra flag-check for last node of list */
X	if ((list->current)->flag != flag) {
X		lError("lFlagNode", NOT_FOUND, id, 0, NULL);
X		return(NOT_FOUND);
X	}
X
X		/* expected data and node must have same size */
X	if ((list->current)->size != size) {
X		lError("lFlagNode", SIZE_NE, size, (list->current)->size, NULL);
X		return(SIZE_NE);
X	} else {
X		BYTE_COPY((list->current)->data, data, size);
X		if (list->current == list->last)
X			return(LAST);
X		else if (list->current == list->first)
X			return(FIRST);
X		else
X			return(0);
X	}
X}
END_OF_FILE
  if test 21105 -ne `wc -c <'list.c'`; then
    echo shar: \"'list.c'\" unpacked with wrong size!
  fi
  # end of 'list.c'
fi
if test -f 'list.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list.h'\"
else
  echo shar: Extracting \"'list.h'\" \(2301 characters\)
  sed "s/^X//" >'list.h' <<'END_OF_FILE'
X#define	SINGLY		1	/* singly linked list */
X#define	DOUBLY		2	/* doubly linked list */
X#define	CHAIN		3	/* chain linked list */
X#define	CIRCULAR	4	/* circular linked list */
X
X#define	FIRST		1	/* add at front of list */
X				/* get/find/delete first node */
X#define	PREVIOUS	2	/* get/find previous node */
X#define	BEFORE		3	/* add before current node */
X#define	CURRENT		4	/* get/delete current node */
X#define	AFTER		5	/* add after current node */
X#define	NEXT		6	/* get/find next node */
X#define	LAST		7	/* add at end of list */
X				/* get/find/delete last node */
X
X#define	ONE_NODE	10	/* add first node to list / delete last node */
X
X#ifndef NULL
X#define	NULL		0
X#endif
X
X#define	WRONG_SD	-1	/* parameter 'sd' has wrong value */
X#define	WRONG_CC	-2	/* parameter 'cc' has wrong value */
X#define	WRONG_WHERE	-3	/* parameter 'where' has wrong value */
X#define	WRONG_WHICH	-4	/* parameter 'which' has wrong value */
X#define	UNKNOWN_ID	-5	/* list id is unknown */
X#define	UNKNOWN_FUNC	-6	/* function name is unknown */
X#define	NO_LIST		-7	/* there are no lists defined */
X#define	EMPTY_LIST	-8	/* list is empty */
X#define	EOL		-9	/* end of list reached */
X#define	NOT_FOUND	-10	/* node not found */
X#define	NOT_DOUBLY	-11	/* list is not doubly linked */
X#define	SIZE_NE		-12	/* size of expected data and node not equal */
X#define	WRONG_INDEX	-13	/* 'index' out of range */
X#define	OPEN_ERROR	-14	/* can't open dump-file */
X
X#define	FOUND		0	/* node found */
X
X#define	ERROR_FILE	"=listError="
X
X#ifdef ANSI
Xtypedef	int		(*Func)();
Xtypedef	unsigned char	Byte;
Xint	lDef(int sd, int cc),
X	lInsNode(int id, int where, Byte *data, int size, int flag),
X	lUpdNode(int id, Byte *data, int size, int flag),
X	lGetNode(int id, int which, Byte *data, int size),
X	lIndxNode(int id, int index, Byte *data, int size),
X	lFndNode(int id, int where, Func func, Byte *ptr, Byte *data, int size),
X	lDelNode(int id, int which),
X	lInfo(int id, int *sd, int *cc, int *n),
X	lInfoNode(int id, int which, int *size, int *flag),
X	lDel(int id),
X	lDelAll(void),
X	lDump(int id, char *file),
X	lUndump(char *file),
X	lFlagNode(int id, int flag, Byte *data, int size);
X#else
Xint	lDef(), lInsNode(), lUpdNode(), lGetNode(), lIndxNode(), lFndNode(),
X	lDelNode(), lInfo(), lInfoNode(), lDel(), lDelAll(), lDump(), lUndump(),
X	lFlagNode();
X#endif
END_OF_FILE
  if test 2301 -ne `wc -c <'list.h'`; then
    echo shar: \"'list.h'\" unpacked with wrong size!
  fi
  # end of 'list.h'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
