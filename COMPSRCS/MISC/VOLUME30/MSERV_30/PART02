Newsgroups: comp.sources.misc
From: jv@mh.nl (Johan Vromans)
Subject:  v30i047:  mserv-3.0 - Squirrel Mail Server Software, Part02/04
Message-ID: <1992Jun14.005847.18781@sparky.imd.sterling.com>
X-Md4-Signature: 1d68190bfa47a089722768cc576488ce
Date: Sun, 14 Jun 1992 00:58:47 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jv@mh.nl (Johan Vromans)
Posting-number: Volume 30, Issue 47
Archive-name: mserv-3.0/part02
Environment: Perl

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  INSTALL chkconfig.pl dorequest.pl dr_mail.pl
#   mserv_config.pl unpack.pl
# Wrapped by kent@sparky on Sat Jun 13 19:46:22 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 4)."'
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
  echo shar: Extracting \"'INSTALL'\" \(12682 characters\)
  sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
X@(#)@ INSTALL	3.14 - INSTALL
X
XInstallation
X============
X
X 1. Preparation
X
X    As distributed, perl is expected to reside in /usr/local/bin.  You
X    can change this in the Makefile if your perl resides somewhere
X    else.
X
X    The mail server needs a user id to own the programs, and a place
X    where the programs and files can be stored.
X    Pre-configured values are "mserv" and "/usr/local/lib/mserv"
X    respectively. We'll call the library LIBDIR in this document.
X    LIBDIR could be the HOME directory of the mail server owner, but it
X    need not.
X    If you prefer a different value for LIBDIR, change the appropriate
X    line in the Makefile.
X    The name of the mail server owner can be changed in step 2, as
X    described below.
X
X    Since all messages sent by the mail server are sent under the
X    server owner uid, its full name (the GCOS or comment field in
X    /etc/passwd) should be descriptive.
X
X    The mail server owner does not need any privileges, except for
X    read access to the archives, and read/write access to LIBDIR.
X
X    Do not use the root account for server owner!
X
X 2. Configure and build
X
X    Tailor "mserv_config.pl" to reflect your specific needs. It has
X    extensive descriptions for configuration variables and values.
X    Do not forget to tailor the Makefile also, if needed.
X
X    It may be a good habit to generate differences using the 'diff'
X    program so you can apply your modifications to a new version of
X    the mail server software easily.
X
X    Issue "make" to prepare the programs. 
X
X    If you select the index file feature, you need GNU find / locate.
X    As of GNU find version 3.6, you can use the locate program 'as is'.
X    For version 3.5, change GNUFIND in the Makefile to designate where
X    your GNU find sourcetree is, and issue "make ixlookup".
X    This will build a customized version of GNU locate, called
X    "ixlookup".
X
X    Issue "make listener" to generate and compile the listener
X    program. This command uses mserv_config.pl (from the current
X    directory) to determine how to build the listener program.
X
X 3. Installation
X
X    Now "su mserv" and execute "make install".
X
X    This will install all programs and files in LIBDIR.
X    It will not install programs ixlookup and listener, since they
X    need special treatment.
X
X    If you select the index file feature, issue "make install-ixlookup"
X    if you need the customized version of GNU locate 3.5. 
X    Note that whoever creates the index files, must have write access
X    to the location the index files are stored.
X
X    If you configured the listener to use the setruid/setrgid system
X    calls, you need to "su mserv" before executing "make
X    install-listener".
X
X    If you do not have setruid/setrgid, the program must be installed
X    setuid root.  In this case, you have to "su root" before doing
X    "make install-listener".  Look at the source of the listener.c
X    program to verify it will not harm your system security.
X
X 4. Adding aliases
X
X    Create a suitable alias in /usr/lib/aliases (or wherever your
X    aliases are kept):
X
X      mail-server : "|LIBDIR/listener"
X
X    To get rid of bounced mail, the mail server fakes "bit-bucket" as
X    its return address. To avoid bounced mails filling your
X    filesystems, add another alias:
X
X      bit-bucket: /dev/null
X
X 5. Verification of the installation
X
X    All the following steps should be executed under the mail server
X    owner!
X
X    * Run program LIBDIR/chkconfig. It shows most of the
X      configuration values, and verifies the existence of files and
X      programs.
X
X      You may need to run the perl tool "h2ph" to supply system
X      include files needed for locking.
X
X    * Verify your locking strategy. Execute
X     
X        % perl -s testlock.pl -test1 &
X     
X      It should say "Got the lock -- waiting ...".
X      Now execute
X     
X        % perl -s testlock.pl -test2 &
X     
X      It should say "Good. Could not lock -- waiting ...".
X      Now kill the first process. The second process should print "ret = 1" 
X      and exit.
X
X    * Verify the working of the "dorequest" program:
X
X        % LIBDIR/dorequest <youraddress> <arealfile>
X
X      You should receive mail(s) containing the indicated file.
X      NOTE: If your site is running sendmail, the mail(s) are queued
X      for delivery. They can take some time before they arrive,
X      depoending on how often the sendmail queue is run.
X      You may want to inspect the sendmail queue to see if your
X      mail(s) are in it.
X
X      If no mail(s) arrive, try
X
X        % LIBDIR/dorequest -debug <youraddress> <arealfile>
X
X      and see what happens.
X
X    * Execute the "process" script by hand:
X
X        % LIBDIR/process
X        From bla
X        From: <youraddress>
X
X        test
X        send HELP
X        end
X
X      (The program should terminate after processing the "end"
X      command). 
X      Now you should receive a mail (from yourself!) telling that your
X      request has been processed.
X      NOTE: If your site is running sendmail, and sendmail is
X      configured to use 'queued' delivery, the mail(s) are not
X      delivered immediately.
X      You may want to inspect the sendmail queue to see if your
X      mail is in it, or run the queue by hand.
X
X      In case of trouble: run LIBDIR/process with "-debug" to find out
X      what happens.
X
X    * Execute the "process" script again with the same input, but
X      leave out the line "test".
X
X      Again you should receive a mail (from yourself!) telling that your
X      request has been processed. It should also tell you that your
X      request has been queued.
X
X      If you configured $auto_runrequest, program "dorequest" will be
X      run to handle your request. You should receive a mail with the
X      requested file.
X
X      In case of trouble: run LIBDIR/process with "-debug" to find out
X      what happens. This will prevent "dorequest" from being invoked,
X      so you can study the contents of LIBDIR/queue.
X
X    * Execute the "listener" program with the same input.
X
X      Again you should receive a mail message.
X
X      If you configured $auto_runrequest, program "dorequest" will be
X      run to handle your request. You should receive a mail with the
X      requested file.
X
X    * As another user, run the "listener" program with the same input.
X
X      Again you should receive a mail, still originating from the
X      mail server owner.
X
X    * Still going strong? Now, as another user, send a mail message to
X      your mail server:
X
X      % mail mail-server
X      send foo bar INDEX
X      end
X      ^D
X
X      (Mail programs usually do not terminate after reading the "end"
X      line. Issue Control-D or whatever you local EndOfFile setting is). 
X      
X      You will receive a return mail, indicating which archive entries
X      were found, and how they would be transmitted.
X
X    * If you did not configure $auto_runrequest, change back to the
X      mail server user, and inspect LIBDIR/queue to see that your
X      request is in it.
X      Run LIBDIR/dorequest without arguments; the selected file should
X      be sent to you by email.
X
X    If you receive the requests, your mail server is fully
X    operational! 
X
X 6. If you don't want to keep of log of transactions, remove the file
X    "LIBDIR/logfile" that was created by the Makefile.
X
X 7. As a service: place the files "HELP" and "unpack.pl" in one of
X    your archives. The Makefile prepares PUBDIR (defaults to
X    LIBDIR/pub) for this purpose.
X
X    Also, supply shar-files with the btoa/atob handling
X    programs, uudecode/uuencode, and compress/uncompress.
X
X    The contents of file LIBDIR/mserv.notes is prepended to every
X    reply the mail server sends. This file can be used to supply a
X    daily message about the server, new entries, etc.
X
X    The contents of file LIBDIR/mserv.hints is appended to every reply
X    the mail server sends.
X
X    Make sure your archives have a decent copy of Dumas uud/uue and
X    xxencode/xxdecode if you intent to support these.
X    Likewise, zoo, zip, etc.
X
X    Also, provide a file "INDEX" that more or less describes what is
X    in your archives. People are going to ask for it.
X
X    Since people usually don't read the documentation, link "help" to
X    "HELP", "index" to "INDEX", "atob.shar" to "btoa.shar", etc.
X
X 8. Install crontab entries for the mail server processes. A sample
X    crontab is included in the distribution as CRONTAB.sample.
X
X	30 0,2,4,6,18,20,22 * * * LIBDIR/do_runq
X	0 3 * * * LIBDIR/makeindex
X	0 7 * * * LIBDIR/do_report -errors -since .errrun
X	10 7 * * 7 LIBDIR/do_report -full -collect
X
X    The above example runs the mail server queue every two hours,
X    except during working hours. Once a day any mail server errors are
X    reported, once a week the logfile data is accumulated and a usage
X    report is generated.
X
X    CHECK AND MODIFY THESE SCRIPTS SINCE THEY WILL PROBABLY NOT
X    DO WHAT YOU WANT!
X
X    Every night a three o'clock new index files are generated. You may
X    leave this line out if you do not use index files.
X
X    If you configured auto_runrequest in mserv_common.pl, there is no
X    need to run the queue that often; once or twice a day will be
X    sufficient.
X
XInteraction of programs
X=======================
X
XAn email message directed to the mail server will be passed to program
X`listener'. This program disguises itself as the mail server owner and
Xexecutes `process'.
X
X`process' parses the mail message, and extracts commands. Requests are
Xlooked up, and --if viable-- written to the mail server queue.
X
XSome other time, `dorequest' will be run, either automatically from
X`process' or via cron. This program will lock the queue and read all
Xentries from it. It will also read any pending entries in queue~. Then
Xit will empty the queue and release it.  Next, it will handle all
Xentries it has read. Before handling a request, all in-core entries
Xare written to file queue~ just in case the system goes down.
XUpon completion of a request, a logfile entry is written and the
Xrequest is removed from memory. Upon sucessful completion of
X`dorequest' the file queue~ will be removed.
X
XEach queue entry takes one record from the queue file, with space
Xseparated files as follows:
X
X  type		M for email, U for UUCP transfer, MP for packed email,
X		UP for packed UUCP.
X  recipient	the reply address used
X  destination	(type M* only): email address
X  host!path	(type U* only) UUCP host and path
X  notify	(type U* only) UUCP notification user
X  request	the request
X  file		the name of the file
X  encoding	(type M* only) encoding (B = btoa, U = uuencode, X = xxencode,
X		    D = Dumas' uue)
X  limit		max size (in Kb) per chunk
X  parts		comma-separated parts list.
X
XLogging
X=======
X
XIf you select logging, all transfers that are sent are logged in the
Xlogfile. Each record has a number of (space separated) fields as
Xfollows:
X
X  date		e.g. 920501
X  time		e.g. 15:22
X  type		M for email, U for UUCP transfer
X  destination	email address, or host!notify for UUCP transfers
X  request	the name of the requested file
X  Xnn/mm	X = encoding (B = btoa, U = uuencode, X = xxencode,
X		    D = Dumas' uue)
X		    Note: no encoding is specfied for UUCP transfers.
X  		nn/mm = part nn of mm parts
X  size		the size of the transfer
X
XThe programs report.pl and do_report.pl can be used to generate
Xreports from the logfile.
X
XErrors are logged with type `F'. The remainder of the record contains
Xthe error message. 
XIf an error is detected due to a user request, the queue entry for
Xthis request is entered in the logfile with type `Q'.
XIf the failure is temporary, the queue entry can be extracted from the
Xlogfile and added to the queue (or better: queue~) file.
X
Xdo_report.pl can also be used to cleanup the logfile.
X
XDesign and Maintenance of the Archives
X======================================
X
XThe mail server software can handle multiple archive directories.
XEvery directory specified in @libdirs is treated equal.
X
XPlease consider the following points:
X
X - Hidden files (filenames starting with `.') and files that are not
X   readable to `mserv' cannot be retrieved. They might show in the
X   index, however.
X
X - If a file occurs multiple (e.g. "INDEX" in more than one archive
X   directory) the first occurrence is retrieved.
X
X - If a directory occurs multiple it can not be retrieved.
X
X - For best results: name archives similar to "foo-XXX.tar.Z", where
X   XXX is a version number, e.g. emacs-18.58.tar.Z or xdvi-12.zoo.
X   This will aid people in finding the right version for a specific
X   archive entry.
X
XPlease share your experiences and programs.
X
XGood Luck!
X
X	Johan Vromans
X	Multihouse Research
X	Doesburgweg 7
X	2803 PL  Gouda
X	The Netherlands
X	Phone: +31 1820 62911
X	E-mail: jv@mh.nl
END_OF_FILE
  if test 12682 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
  fi
  # end of 'INSTALL'
fi
if test -f 'chkconfig.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chkconfig.pl'\"
else
  echo shar: Extracting \"'chkconfig.pl'\" \(8630 characters\)
  sed "s/^X//" >'chkconfig.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X# chkconfig.pl -- check mserv configuration
X# SCCS Status     : @(#)@ chkconfig	1.11
X# Author          : Johan Vromans
X# Created On      : Mon Apr 27 21:47:41 1992
X# Last Modified By: Johan Vromans
X# Last Modified On: Sat Jun  6 21:27:19 1992
X# Update Count    : 94
X# Status          : Development
X
X# DISCLAIMER: This prograim aids in finding configuration values
X# and potential problems. No guarantees, however.
X
X$my_name = "chkconfig";
X$my_version = "1.11";
X#
X################ Common stuff ################
X
X$libdir = $ENV{"MSERVLIB"} || "/usr/local/lib/mserv";
Xunshift (@INC, $libdir);
Xrequire "mserv_common.pl";
X
X################ Options handling ################
X
X&options if @ARGV > 0 && $ARGV[0] =~ /^-+[^-]+/;
X@ARGV = ("-") unless @ARGV > 0;
Xprint ($my_package, " [", $my_name, " ", $my_version, "]\n");
X
X################ Main ################
X
Xprint ("MSERVLIB = ", $ENV{"MSERVLIB"} || "(not set)", "\n");
Xprint ("Program library: ", $libdir, " ", &fstat($libdir,1,1), "\n");
Xprint ("\n");
X
Xif ( defined $mserv_owner && $mserv_owner ) {
X    if ( @u = getpwnam ($mserv_owner) ) {
X	print ("Server owner: ", $mserv_owner, ", uid = $u[2], gid = $u[3]",
X	       ", \"", $u[6], "\"\n");
X    }
X    else {
X	print ("Server owner: ", $mserv_owner, " *** Unknown ***\n");
X    }
X}
Xelse {
X    die ("\$mserv_owner is not defined!\n");
X}
Xif ( defined $mserv_bcc && $mserv_bcc ) {
X    if ( @u = getpwnam ($mserv_bcc) ) {
X	print ("Bcc user: ", $mserv_bcc, ", uid = $u[2], gid = $u[3]",
X	       ", \"", $u[6], "\"\n");
X    }
X    else {
X	print ("Bcc user: ", $mserv_bcc, " *** Unknown ***\n");
X    }
X}
Xprint ("\n");
X
Xif ( $have_setruid ) {
X    print ("The 'listener' program will use the setruid system call\n");
X    print ("  It will change identity to compiled-in uid $u[2]\n")
X	if $use_uid;
X    print ("  (setenv will be used to set USER, LOGNAME and HOME)\n")
X	if $have_setenv;
X    if ( -x "$libdir/listener" ) {
X	@st = stat (_);
X	unless ( $st[4] == $u[2] && $st[2] & 0004000 == 0004000 ) {
X	    print ("The 'listener' program is not installed correctly!\n",
X		   "  It should be installed setuid $mserv_owner\n");
X	}
X    }
X    else {
X	print ("The 'listener' program is not yet installed.\n",
X	       "  Do not forget to install it setuid $mserv_owner\n");
X    }
X}
Xelse {
X    print ("The 'listener' program will use 'su' to change identity\n");
X    if ( -x "$libdir/listener" ) {
X	@st = stat (_);
X	unless ( $st[4] == 0 && $st[2] & 0004000 == 0004000 ) {
X	    print ("The 'listener' program is not installed correctly!\n",
X		   "  It should be installed setuid root\n");
X	}
X    }
X    else {
X	print ("The 'listener' program is not yet installed\n",
X	       "  Do not forget to install it setuid root\n");
X    }
X}
Xprint "\n";
X
X$f = $sendmail;
X$f = $` if $f =~ / /;
Xprint ("Replies will be sent using \"$sendmail\" ", &fstat($f,0,1), "\n");
Xprint ("Preset mail headers:\n");
Xprint (defined $sender ? "  $sender\n" : "  *** sender not defined ***\n");
Xprint ("  ", join ("\n  ", @x_headers), "\n") if defined @x_headers;
Xprint ("\n");
X
Xprint ("Transfer strategies:\n");
Xif ( defined $chunkmail ) {
X    $f = $chunkmail;
X    $f = $` if $f =~ / /;
X    print ("  email: \"$chunkmail\" ", &fstat($f,0,1), "\n");
X    print ("         wait ", $mailer_delay, " seconds between chunks\n")
X	if defined $mailer_delay;
X    print ("         limits: ", $email_limits[1], "K (default), ",
X	   $email_limits[0], "K (min), ", $email_limits[2], "K (max)\n");
X}
Xif ( defined $uucp ) {
X    $f = $uucp;
X    $f = $` if $f =~ / /;
X    print ("  uucp : \"$uucp\" ", &fstat($f,0,1), "\n");
X    $f = $uuname;
X    $f = $` if $f =~ / /;
X    print ("         check host names using \"$uuname\" ", &fstat($f,0,1), "\n")
X	if $uuname ne "";
X    print ("         limits: ", $uucp_limits[1], "K (default), ",
X	   $uucp_limits[0], "K (min), ", $uucp_limits[2], "K (max)\n");
X}
Xprint ("\n");
X
Xprint ("Search strategies:");
Xprint (" File") if $dofilesearch;
Xprint (" Directory") if $dodirsearch;
Xprint (" Index") if $doindexsearch;
Xprint ("\n");
Xprint ("\n");
X
Xif ( ! ($dofilesearch || $dodirsearch || $doindexsearch) ) {
X    print ("*** No search strategy defined ***\n\n");
X}
X
Xprint ("Archives:\n");
Xforeach $lib ( @libdirs ) {
X    print ("  ", $lib, " ", &fstat($lib,1,1), "\n");
X}
Xif ( defined $indexfile && defined $indexlib ) {
X    print ("Archive for Index:\n");
X    print ("  ", $indexlib, " ", &fstat($indexlib,1,1), "\n");
X}
Xprint ("\n");
X
Xif ( $doindexsearch && !( defined $indexfile ) ) {
X    print ("*** No value for `indexfile' ***\n\n");
X}
X
Xif ( $doindexsearch && defined $indexfile ) {
X    print ("Indexfiles:\n");
X    if ( $indexfile =~ m|^/| ) {
X	print ("  ", $indexfile, " ", &fstat($indexfile), "\n");
X	print ("  Archive for this index: ", $indexlib, "\n")
X	    if defined $indexlib;
X    }
X    else {
X	foreach $lib ( @libdirs ) {
X	    local ($indexfile) = $lib . "/" . $indexfile;
X	    print ("  ", $indexfile, " ", &fstat($indexfile), "\n");
X	}
X    }
X    print ("Limit per index request: ", $maxindexlines, " lines.\n")
X	if $maxindexlines > 0;
X    print ("\n");
X    print ("Index tools:\n");
X    print ("  gfind      ", $gfind, " ", &fstat($gfind,0,1), "\n");
X    print ("  ixlookup   ", $ixlookup, " ", &fstat($ixlookup,0,1), "\n");
X    print ("  locatelib  ", $locatelib, " ", &fstat($locatelib,1,1), "\n");
X    print ("\n");
X}
X
Xprint ("Server files:\n");
Xprint ("  queue      ", $queue, " ", &fstat($queue), "\n");
Xprint ("  logfile    ", $logfile, " ", &fstat($logfile), "\n");
Xprint ("  lockfile   ", $lockfile, " ", &fstat($lockfile), "\n");
Xprint ("  notes      ", $notesfile, " ", &fstat($notesfile), "\n");
Xprint ("  hints      ", $hintsfile, " ", &fstat($hintsfile), "\n");
Xprint ("\n");
X
X# Locking
Xif ( defined $lock_fcntl ) {
X    print ("Locking with fcntl(2).\n");
X}
Xif ( defined $lock_flock ) {
X    print ("Locking with flock(2).\n");
X}
Xif ( defined $lock_lockf ) {
X    print ("Locking with syscall(2)/lockf(2).\n");
X}
Xif ( defined $lock_fcntl + defined $lock_flock + defined $lock_lockf > 1 ) {
X    print ("*** Select one lock method.\n");
X}
Xif ( defined $lock_fcntl + defined $lock_flock + defined $lock_lockf == 0 ) {
X    print ("No locking selected. Proceed at your own risk\n");
X}
Xelse {
X    # Just a quick test to see if things fit.
X    local ($lf) = "/usr/tmp/fl$$";
X    open (LF, ">$lf");
X    eval { &locking (*LF, 0); };
X    print "$@" if "$@";
X    close (LF);
X    unlink ($lf);
X    print ("Use the 'testlock' program to verify the locking! (See INSTALL)\n");
X}
Xprint ("\n");
X
X%enctab = ("B", "btoa", "U", "uuencode", "X", "xxencode", "D", "uue");
X
Xprint ("Default encoding is ", $default_encoding, 
X       " (", $enctab{$default_encoding}, ")\n");
Xprint ("Encoders:\n");
Xforeach $f ( "btoa", "uuencode", "uue", "xxencode" ) {
X    $exec = eval("\$$f");
X    printf ("  %-10s %s %s\n", $f, $exec, 
X	    &fstat($exec,0,
X		   $f eq "uuencode" || $f eq $enctab{$default_encoding}),
X	    "\n");
X}
X
X# print ("Tools:\n");
Xprint ("\n");
X
Xif ( defined $packing_limit ) {
X    print ("Support for packing is included.\n",
X	   "  Packing limit = $packing_limit blocks.\n",
X	   "  Dusk usage obtained using \"$du\" ", &fstat($du,0,1), "\n",
X	   "  File list obtained using \"$find\" ", &fstat($find,0,1), "\n",
X	   "  Methods:");
X    if ( defined $pdtar ) {
X	print (" tar ", &fstat($pdtar,0,1));
X    }
X    else {
X	print (" tar ", &fstat($tar,0,1));
X    }
X    print (" zip ", &fstat($zip,0,1));
X    print (" zoo ", &fstat($zoo,0,1));
X    print ("\n");
X    if ( defined $pdtar ) {
X	print ("  Compress/Tar using \"$pdtar\" ", &fstat($pdtar,0,1), "\n");
X    }
X    else {
X	print ("  Compress/Tar using \"$tar\" ", &fstat($tar,0,1), " and ",
X	       "\"$compress\" ", &fstat($compress,0,1), "\n");
X    }
X    print ("\n");
X}
Xelse {
X    print ("Packing functionality not selected.\n\n");
X}
Xprint ("Working storage: $tmpdir ", &fstat($tmpdir,1,1), "\n\n");
Xprint ("The queue will ", $auto_runrequest ? "automatically" : "not",
X       " be run upon completion of process.\n\n");
X
X################ Subroutines ################
X
Xsub fstat {
X    local ($file, $dir, $mustexist) = @_;
X    return "[*** Not found ***]" if ! -e $file && $mustexist;
X    return "[Not found, but that's OK]" unless -e _;
X    return "[*** Not a directory ***]" if $dir && ! -d _;
X    "[OK]";
X}
X
Xsub options {
X    require "newgetopt.pl";
X    $opt_ident = $opt_help = 0;
X    if ( !&NGetOpt ("ident", "help")
X	|| $opt_help
X	|| (@ARGV > 0)) {
X	&usage;
X    }
X}
X
Xsub usage {
X    print STDERR <<EndOfUsage;
X$my_package [$my_name $my_version]
X
XUsage: $my_name [-help] [-ident]
X
XOptions:
X    -help	this message
X    -ident	print identification
XEndOfUsage
X    exit (1);
X}
END_OF_FILE
  if test 8630 -ne `wc -c <'chkconfig.pl'`; then
    echo shar: \"'chkconfig.pl'\" unpacked with wrong size!
  fi
  # end of 'chkconfig.pl'
fi
if test -f 'dorequest.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dorequest.pl'\"
else
  echo shar: Extracting \"'dorequest.pl'\" \(8518 characters\)
  sed "s/^X//" >'dorequest.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X# dorequest.pl -- 
X# SCCS Status     : @(#)@ dorequest	3.17
X# Author          : Johan Vromans
X# Created On      : ***
X# Last Modified By: Johan Vromans
X# Last Modified On: Sat Jun  6 21:11:24 1992
X# Update Count    : 135
X# Status          : Going steady
X
X# Usage: dorequest [options] -- to run the queue
X#
X#	 dorequest [options] address file [ encoding [ limit [ list ] ] ]
X#		-- to send a file 'by hand'.
X#
X#   address : where to send the information to.
X#	      If left empty, no splitting is done, and the result
X#	      is written to stdout.
X#
X#   file    : the file to send.
X#
X#   encoding: how to encode it: U (uuencode), B (btoa), D (Dumas uue)
X#	      or A (plain).
X#             Default is btoa.
X#
X#   limit   : how many bytes per transmission.
X#             Default is 32768
X#
X#   parts   : comma-separated list of part numbers.
X#             When used, only these parts are sent.
X#
X$my_name = "dorequest";
X$my_version = "3.17";
X#
X################ Common stuff ################
X
X$libdir = $ENV{"MSERVLIB"} || "/usr/local/lib/mserv";
Xunshift (@INC, $libdir);
Xrequire "mserv_common.pl";
X
X################ Options handling ################
X
X&options if @ARGV > 0 && $ARGV[0] =~ /^-+[^-]+/;
Xundef $mailer_delay if $opt_debug;
X
X################ Setting up ################
X
Xif ( @ARGV > 0 ) {
X    &usage unless @ARGV > 1;
X    local ($rcpt, $address, $request, $file, $encoding, $limit, $parts);
X    ($rcpt, $file, $encoding, $limit, $parts) = @ARGV;
X    $request = $file;
X    $address = $rcpt;
X    require "$libdir/dr_mail.pl";
X    &mail_request ($rcpt, $address, $request, $file, $encoding, $limit, $parts);
X}
Xelse {
X    &synchronize;
X    &seize_queue;
X    while ( @queue > 0 ) {
X	local ($current_queue_entry) = &shift_queue;
X	local (@arg) = split (/[ \t\n]/, $current_queue_entry);
X	$current_queue_entry = join (" ", @arg);
X	local ($cmd) = shift (@arg);
X
X	if ( $cmd eq "M" ) {
X	    require "$libdir/dr_mail.pl";
X	    eval { &mail_request (@arg); };
X	}
X	elsif ( $cmd eq "U" ) {
X	    require "$libdir/dr_uucp.pl";
X	    eval { &uucp_request (@arg); };
X	}
X	elsif ( $cmd eq "MP" ) {
X	    require "$libdir/dr_pack.pl";
X	    eval { &pack_mail_request (@arg); };
X	}
X	elsif ( $cmd eq "UP" ) {
X	    require "$libdir/dr_pack.pl";
X	    eval { &pack_uucp_request (@arg); };
X	}
X	else {
X	    # This is fatal!
X	    &die ("Illegal request in queue: $cmd @arg");
X	}
X    }
X    # Get rid of queue backup file.
X    unlink ("$queue~");
X}
X
Xexit (0);
X
X################ Subroutines ################
X
Xsub synchronize {
X
X    # NOTE: It is very important to prevent multiple copies
X    #	    of this program to run at the same time!
X
X    # Proceed at your own risk here...
X    return unless defined $lockfile;
X
X    # Create lockfile if it does not exists.
X    if ( ! -e $lockfile ) {
X	open (LF, ">$lockfile");
X	close (LF);
X    }
X
X    # Open it, and get exclusive access.
X    open (LF, "+<$lockfile")
X	|| &die ("Cannot gain lock [$!]");
X    local ($ret) = &locking (*LF, 0);
X    # Exit gracefully if some other invocation has the lock.
X    exit (0) if $ret == 0;
X    &die ("Cannot lock lockfile [$!]") unless $ret == 1;
X
X    # We keep it locked until process termination.
X}
X
Xsub seize_queue {
X
X    local ($queuecnt);
X
X    # First, check the queue backup. This file can exists only
X    # if a previous run failed to terminate normally.
X    if (open (QUEUE, "$queue~")) {
X	@queue = <QUEUE>;	# Slurp.
X	close (QUEUE);
X	unlink ("$queue~")
X	    || &die ("Cannot unlink queue~ [$!]");
X	$queuecnt = @queue;
X	print STDERR ("Got $queuecnt entries from $queue~\n")
X	    if $opt_debug;
X    }
X    else {
X	@queue = ();
X	$queuecnt = 0;
X    }
X
X    # Now check the current queue. We use exclusive access to make
X    # sure no other process is updating it.
X    # Again, proceed at your own risk if you're not using locks.
X    if (open (QUEUE, "+<$queue" )) {
X	# We cannot use rename queue -> queue~, since some other process
X	# may already be waiting for the queue to become free.
X	# Therefore slurp + truncate it.
X	if ( &locking (*QUEUE, 1) ) {
X	    push (@queue, <QUEUE>); # Slurp.
X	    truncate ($queue, 0)
X		|| &die ("Cannot truncate queue [$!]");
X	    close (QUEUE);
X	}
X	else {
X	    &die ("Cannot seize queue [$!]");
X	}
X	print STDERR ("Got ",  @queue-$queuecnt, " entries from $queue\n")
X	    if $opt_debug;
X    }
X    # 'No queue' is a normal situation....
X}
X
Xsub shift_queue {
X    # Sync the memory copy of the queue to disk (in the queue backup
X    # file), and extract the first entry of it.
X
X    open (QUEUE, ">$queue~")
X	|| &die ("Cannot sync queue [$!]");
X    print QUEUE @queue;		# Blurb.
X    close (QUEUE);
X
X    # Get entry from queue and return it.
X    shift (@queue);
X}
X
Xsub check_file {
X    local ($file, $dir) = @_;
X
X    # Check if a given file still exists. Non-existent files are
X    # trapped anyway, but this gives a better error message.
X
X    return 1 if -r $file && ( $dir ? ( -d _ && -x _ ) : -f _ );
X    &die (($dir ? "Directory" : "File") . 
X	  " \"$file\" is no longer available");
X}
X
X################ subroutines ################
X
Xsub fnsplit {
X    local ($file) = @_;
X    # Normalize $file -> ($dir, $basename)
X    local (@path) = split (/\/+/, $file);
X    (join ("/", @path[0..$#path-1]), $path[$#path]);
X}
X
Xsub system {
X    local ($cmd) = (@_);
X    local ($ret);
X    local ($opt_nolog) = 0;
X    print STDERR ("+ $cmd\n") if $opt_trace;
X    $ret = system ($cmd);
X    &die (sprintf ("Return 0x%x from \"$cmd\"", $ret))
X	unless $ret == 0;
X    $ret;
X}
X
Xsub symlink {
X    local ($old, $new) = @_;
X    print STDERR ("+ symlink $old $new\n") if $opt_trace;
X    symlink ($old, $new)
X	|| &die ("Cannot symlink $old to $new [$!]\n");
X}
X
Xsub die {
X    local ($msg) = (@_);
X    local ($opt_nolog) = 0;	# Will force logging
X    local ($opt_debug) = 1;	# Will force msg to STDERR
X    &writelog ("F $msg");
X    if ( defined $current_queue_entry ) {
X	&writelog ("Q $current_queue_entry");
X	&feedback ($current_queue_entry, $msg);
X    }
X    die ("Aborted\n");
X}
X
Xsub writelog {
X
X    # Write message to logfile, if possible, Otherwise use STDERR.
X
X    local (@tm) = localtime (time);
X    local ($msg) = sprintf ("%02d%02d%02d %02d:%02d %s\n", 
X			    $tm[5], $tm[4]+1, $tm[3], $tm[2], $tm[1], $_[0]);
X
X    if ( !$opt_nolog && defined $logfile && ( -w $logfile ) && 
X	open (LOG, ">>" . $logfile) ) {
X	if ( &locking (*LOG, 1) ) {
X	    seek (LOG, 0, 2);
X	    print LOG $msg;
X	    close LOG;
X	    return unless $opt_debug;
X	}
X    }
X
X    print STDERR $msg;
X}
X
Xsub feedback {
X    local ($q, $msg) = @_;
X
X    # Try to send a message to the requestor indicating
X    # something went wrong.
X
X    local ($type, $rcpt, @q) = split (/ /, $q);
X    local ($file, $req, $method);
X    if ( $type =~ /^U/ ) {
X	($req, $file) = @q[2,3];
X	$method = "via UUCP to \"$q[0]\"";
X    }
X    else {
X	($req, $file) = @q[1,2];
X	$method = "via email to \"$q[0]\"";
X    }
X
X    local ($cmd) = "$sendmail '" . $rcpt . "'";
X
X    print STDERR ("+ |", $cmd, "\n") if $opt_trace;
X
X    return unless open (MAIL, "|" . $cmd);
X    print MAIL <<EOD;
XTo: $rcpt
XSubject: Mail Server error
XX-Server: $my_package [$my_name $my_version]
XX-Oops: I am sorry for the inconvenience
X
XDear user,
X
XEOD
X    $message = "A mail server error has occurred while trying to transfer ".
X	"\"$file\" $method in response to your request for \"$req\".";
X    select (MAIL); 
X    $~ = "fill";
X    write;
X    print MAIL <<EOD;
X
XThe error message was:
X   $msg
X
XYou may wish to resubmit your request, or consult the mail server 
Xmaintainer. 
X(He knows about the error already, no need to inform him.)
X
XEOD
X    close (MAIL);
X    select (STDOUT);
X}
X
Xformat fill =
X^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~~
X$message
X.
X
Xsub options {
X    require "newgetopt.pl";
X    if ( !&NGetOpt ("nomail", "keep=s",
X		    "debug", "trace", "help")
X	|| defined $opt_help ) {
X	&usage;
X    }
X    $opt_trace |= $opt_debug;
X}
X
Xsub usage {
X    print STDERR <<EndOfUsage;
X$my_package [$my_name $my_version]
X
XUsage: $my_name [options] [address file [coding [size [parts]]]]
X
XOptions:
X    -nomail	do not deliver
X    -keep XXX	keep temporary files, using prefix XXX (for debugging)
X    -help	this message
X    -trace	show commands
X    -debug	for debugging
X
Xaddress		destination for this request.
X		If empty: do not split and write to STDOUT.
Xfile		the file to send.
Xcoding		encoding (Btoa, Uuencode, Dumas uue or Plain, def Btoa).
Xsize		max. size per chunk, def 32K.
Xparts		comma-separated list of parts to re-send.
X		If omitted: send all parts
XEndOfUsage
X    exit (!defined $opt_help);
X}
END_OF_FILE
  if test 8518 -ne `wc -c <'dorequest.pl'`; then
    echo shar: \"'dorequest.pl'\" unpacked with wrong size!
  fi
  # end of 'dorequest.pl'
fi
if test -f 'dr_mail.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dr_mail.pl'\"
else
  echo shar: Extracting \"'dr_mail.pl'\" \(7155 characters\)
  sed "s/^X//" >'dr_mail.pl' <<'END_OF_FILE'
X# dr_mail.pl -- handle request via email
X# SCCS Status     : @(#)@ dr_mail.pl	3.1
X# Author          : Johan Vromans
X# Created On      : Thu Jun  4 22:22:20 1992
X# Last Modified By: Johan Vromans
X# Last Modified On: Thu Jun  4 23:06:48 1992
X# Update Count    : 8
X# Status          : OK
X
Xsub mail_request {
X
X    local ($rcpt, $address, $request, $file, $encoding, $limit, $parts) = @_;
X
X    if ( $opt_debug ) {
X	print STDERR ("&mail_request(rcpt=$rcpt, address=$address, ",
X		      "request=$request,\n",
X		      "    file=$file,\n",
X		      "    encoding=$encoding, limit=$limit, parts=$parts)\n");
X    }
X
X    # This routine handles the requests.
X    # Handling includes encoding, splitting and transmitting.
X
X    &check_file ($file, 0);
X
X    local ($fname);		# Basename of file to send
X    local ($cmd);		# Command to handle encoding
X    local ($code);		# Verbose description of encoding
X    local ($files);		# Number of files to send
X    local (@files);		# List of files to send
X    local ($the_file);		# Current part be send
X    local ($the_part);		# Sequence number thereof
X    local ($size);		# Size of chunk
X    local ($tmpfile_prefix) = $opt_keep || "$tmpdir/drq$$.";
X    local ($Dtmpdir);		# Private dir for Dumas uue
X    local ($opt_nolog) = $opt_nolog;
X    local ($opt_keep) = $opt_keep;
X
X    if ( $address eq "" || $address eq "-" ) {
X	# Use this e.g. to include an encoded archive in email.
X	$limit = "0";
X	$opt_nolog = 1;		# Local.
X	$address = "";
X    }
X    $limit = 32*1024 if $limit eq "";
X    if ( $limit ne "0" ) {
X	# Limit must be between 10 and 256K, with 32K default.
X	$limit =  $`*1024 if $limit =~ /K$/;
X	$limit =  10*1024 if $limit <  10*1024;
X	$limit = 256*1024 if $limit > 256*1024;
X    }
X    print STDERR ("Using limit = $limit\n") if $opt_debug;
X
X    $encoding = $default_encoding unless defined $encoding;
X
X    # Get dir and basename of the requested file.
X    local ($dir, $fname) = &fnsplit ($file);
X
X    # Prepare the command to use.
X    # The result of command should be the encoded file, written
X    # to standard output.
X
X    if ( $encoding =~ /^u/i ) {
X
X	# Standard UU encoding.
X	$encoding = "U";
X	$code = "uuencoded";
X	$cmd = "$uuencode $file '$fname'";
X    }
X    elsif ( $encoding =~ /^x/i ) {
X
X	# Modified UU encoding.
X	$encoding = "X";
X	$code = "xxencoded";
X	$cmd = "$xxencode $file '$fname'";
X    }
X    elsif ( $encoding =~ /^d/i ) {
X
X	# Dumas' modified UU encoding.
X	# Uue has a built-in facility to generate multi-part
X	# files. The customer wants to use this feature...
X	local ($split) = '';
X	$encoding = "D";
X	$code = "uue-encoded";
X	$split = '-' . (int ($limit / 63) - 2) if $limit;
X
X	# Prepare a private directory for uue to work in.
X	$Dtmpdir = "$tmpdir/D$$";
X	&system ("rm -fr $Dtmpdir");
X	&system ("mkdir $Dtmpdir");
X	&symlink ($file, "$Dtmpdir/$fname");
X	$cmd = "cd $Dtmpdir; $uue $split '$fname'";
X    }
X    elsif ( $encoding =~ /^[pa]/i || $encoding eq "" ) {
X	
X	# No decoding.
X	$encoding = "A";
X	$code = "ascii";
X	$cmd = "";
X    }
X    else {
X
X	# Binary-to-Ascii encoding.
X	$encoding = "B";
X	$code = "btoa encoded";
X	$cmd = "$btoa < $file";
X    }
X    print STDERR ("Using encoding = $encoding ($code)\n") if $opt_debug;
X
X    if ( $encoding eq "A" && ($limit == 0 || (-s $file <= $limit)) ) {
X	# A simple ascii file smaller than $limit -> use it.
X	@files = ($file);
X	$opt_keep = 1;		# Local copy!
X    }
X    elsif ( $encoding eq "D" ) {
X	local ($path) = ($Dtmpdir);
X
X	# Encode and split.
X	&system ($cmd);
X
X	# Now gather all the parts, and tally them.
X	opendir (DIR, $path)
X	    || &die ("Cannot read $path/ [$!]");
X	@files = sort (grep (/\.u[a-z][a-z]$/o, readdir (DIR)));
X	close (DIR);
X	foreach ( @files ) {
X	    # Note: $_ is a *ref* into @files!
X	    $_ = "$path/$_";
X	}
X    }
X    else {
X	# It is tempting to use 'split' to cut the request into
X	# pieces. Until recently, I did.
X	# Splitting ourselves makes it possible to split ascii files
X	# also. In this case we can spare another process.
X	local ($suffix) = "aa";
X	local ($size) = $limit + 1;
X
X	if ( $cmd ) {
X	    print STDERR ("+ $cmd|\n") if $opt_trace;
X	    open (FEED, "$cmd|")
X		|| die ("Error opening pipe \"$cmd|\" [$!]\n");
X	}
X	else {
X	    print STDERR ("+ <$file\n") if $opt_trace;
X	    open (FEED, "$file")
X		|| die ("Error opening file \"$file\" [$!]\n");
X	}
X
X	@files = ();
X	while ( <FEED> ) {
X	    if ( $limit > 0 && ($size += length ($_)) > $limit ) {
X		close (OUT);
X		open (OUT, ">$tmpfile_prefix$suffix")
X		    || die ("Cannot create $tmpfile_prefix$suffix: [$!]\n");
X		push (@files, "$tmpfile_prefix$suffix");
X		$size = length ($_);
X		$suffix++;
X	    }
X	    print OUT;
X	}
X	close (OUT);
X	close (FEED);
X    }
X
X    $files = @files;
X
X    if ( $opt_debug ) {
X	if ( $files > 1 ) {
X	    print STDERR ("Sending ", $files, " files: ",
X			  $files[0], " .. ", $files[$#files], "\n");
X	}
X	elsif ( $files == 1 ) {
X	    print STDERR ("Sending file: ", $files[0], "\n");
X	}
X	else {
X	    printf STDERR ("No files to send.\n");
X	}    
X    }
X
X    $the_part = 0;
X    foreach $the_file ( @files ) {
X
X	$the_part++;
X
X	if ( $parts && $parts !~ /\b$the_part\b/ ) {
X	    unlink ($the_file) unless $opt_keep;
X	    print STDERR ("Skipping part $the_part (not requested).\n")
X		if $opt_debug;
X	    next;
X	}
X	else {
X	    print STDERR ("Sending part $the_part of $files.\n")
X		if $opt_debug;
X	}
X
X	# Form "part xx of yy" message.
X	$part = ( $files == 1 ) ? "complete" : "part $the_part of $files";
X
X	# Send it.
X	if ( open (PART, $the_file) ) {
X	    if ( $address eq "" ) {
X		$size = &copy (*STDOUT);
X	    }
X	    else {
X		# Suppress sleep after the last part.
X		local ($mailer_delay) = $mailer_delay;
X		undef $mailer_delay if $the_part == $files;
X		$size = &xfer;
X	    }
X	    close (PART);
X	}
X
X	# Write a log message.
X	&writelog ("M \"$address\" $request $encoding$the_part/$files $size")
X	    if $address ne "";
X
X	unlink ($the_file) unless $opt_keep;
X    }
X
X    &system ("rm -fr $Dtmpdir") if $encoding eq "D" && !$opt_keep;
X}
X
Xsub headers {
X    local (*FILE, $full) = @_;
X
X    # Provide some RFC822 compliant headers.
X
X    local ($size) = 0;
X
X    if ( defined $sender ) {
X	print FILE "$sender\n";
X	$size += length ($sender) + 1;
X    }
X
X    $ln = "To: $address\n";
X    $ln .= "Subject: $fname ($part) $code\n";
X    $ln .= "Precedence: bulk\n";
X    $ln .= join ("\n", @x_headers) . "\n" if defined @x_headers;
X    print FILE ($ln, "\n");
X    $size += length ($ln) + 1;
X}
X
Xsub copy {
X    local (*FILE) = shift (@_);
X    local ($size);
X    local ($ln);
X
X    $ln = "Request: $request\n\n".
X	"------ begin of $fname -- $code -- $part ------\n";
X    $size = length ($ln);
X    print FILE $ln;
X    while ( <PART> ) {
X	print FILE $_;
X	$size += length ($_);
X    }
X    $ln = "------ end of $fname -- $code -- $part ------\n";
X    print FILE $ln;
X    $size + length ($ln);
X}
X
Xsub xfer {
X
X    # Send the file via e-mail.
X    local ($size);
X
X    if ( $opt_nomail ) {
X	print STDERR "[Would call \"$chunkmail\"]\n";
X	&headers (*STDOUT, 0);
X    }
X    elsif ( open (MAILER, "|$chunkmail '$address'") ) {
X	$size = &headers (*MAILER, 0);
X	$size += &copy (*MAILER);
X	close MAILER;
X
X	# Allow system to stabilize.
X	sleep ($mailer_delay) if defined $mailer_delay;
X    }
X    $size;
X}
X
X1;
END_OF_FILE
  if test 7155 -ne `wc -c <'dr_mail.pl'`; then
    echo shar: \"'dr_mail.pl'\" unpacked with wrong size!
  fi
  # end of 'dr_mail.pl'
fi
if test -f 'mserv_config.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mserv_config.pl'\"
else
  echo shar: Extracting \"'mserv_config.pl'\" \(9253 characters\)
  sed "s/^X//" >'mserv_config.pl' <<'END_OF_FILE'
X# mserv_config.pl -- config info for mail server
X# Author          : Johan Vromans
X# Created On      : ***
X# Last Modified By: Johan Vromans
X# Last Modified On: Wed Jun 10 12:57:22 1992
X# Update Count    : 10
X# Status          : OK
X
X################ Preamble ################
X #
X # Owner of the mail server. Must be set.
X # This user need no special privileges, except for write access to the
X # mail server files, and read access to the archives.
X # It will get email about problem situations.
X$mserv_owner = "mserv";
X
X################ Reply section ################
X #
X # The mail server sends replies to the sender of messages.
X # It could use the current user id as its own address, but usually it
X # is better to substitute something else to prevent bounced mail
X # messages clobbering your system.
X #
X # Your domain. Unfortunately there is no reliable way of fetching this
X # from the system info.
X$domain = "mh.nl";
X #
X # Sender of the messages. Try to prevent annoying bounced messages.
X$mserv_sender = (getpwnam($mserv_owner))[6] || "Mail Server";
X$sender = "From: $mserv_sender <bit-bucket@$domain>";
X #
X # Mail server bcc id.
X # If set, this user gets a Bcc of each request. Can be used for
X # accounting, or to keep track of functionality.
X$mserv_bcc = $mserv_owner;
X #
X # Sendmail functionality. Will be called with the recipients on the
X # command line, and a pre-formatted message (including some headers) on 
X # standard input.
X # NOTE: Do not use `-t' if you're running smail3. It will exclude the
X #	named recipients from delivery.
X$sendmail = "/usr/lib/sendmail";
X #
X # Optional mail headers.
X # Undefine if not wanted.
X@x_headers = ("X-Server: $my_package [$my_name $my_version]",
X	      "X-Info: Send mail to <postmaster@$domain>");
X
X################ Listener section ################
X #
X # When a mail message is received by the mail server, it is piped into
X # program 'listener'.
X # This program changes uid to the mail server owner, and executes
X # the 'process' program.
X #
X # Define $have_setruid if you have the setruid/setguid system calls.
X # In this case, the program needs to be installed setuid to the
X # mail server owner. If you do not define $have_setruid, the program has to
X # be installed setuid 'root'.
X$have_setruid = 1;
X #
X # Define $have_setenv if you have the setenv(3) library call. Using
X # setenv is optional.
X$have_setenv = 1;
X #
X # If you $have_setruid, you may define $use_uid also.
X # In this case the getpw* routines will not be used and
X # your executable will be significantly smaller and faster.
X$use_uid = 1;
X
X################ Email section ################
X #
X # The default strategy for the mail server is to transfer requests via
X # email. 
X #
X # Sendmail functionality. Will be called with the recipients on the
X # command line, and a pre-formatted message (including some headers) on 
X # standard input.
X # NOTE: Do not use `-t' if you're running smail3. It will exclude the
X #	named recipients from delivery.
X # Used by "dorequest" to transmit chunks of data via email.
X$chunkmail = "/usr/lib/sendmail -odq";
X #
X # The minimum,default,maximum size of email chunks in K.
X@email_limits = (10,64,1024);
X #
X # To prevent overloading the system by firing too many sendmails,
X # use this amount to sleep between sending chunks.
X$mailer_delay = 30;
X
X################ UUCP section ################
X #
X # The mail server can transfer requests via uucp to systems that are
X # connected that way. This is very efficient compared to email, e.g. 
X # no encoding overhead.
X #
X # Define '$uucp' if you want to use the uucp feature.
X # Append uucp grade, if desired (and your uucp supports it).
X$uucp = "/usr/bin/uucp -ga";
X #
X # Uucp host names can be checked for validity, if desired.
X # This is how to get a list of uucp host names. 
X # Set it to empty if you do not want to check the host names.
X$uuname = "/usr/bin/uuname";	# Check host names.
X #$uuname = "";			# Do not check host names.
X #
X # The minimum,default,maximum size of uucp chunks in K.
X@uucp_limits = (10,256,2048);
X
X################ Archives section ################
X #
X # Where to find the archive entries.
X@libdirs = ("/usr/local/src", "/beethoven/arch", "/users/jv/PD");
X # Please add mail server 'pub'!
Xpush (@libdirs, "$libdir/pub");
X #
X # Extensions we recognize. See "$dofilesearch" below.
X@exts = (".TZ", ".tar.Z", ".tar", ".shar.Z", ".shar", ".Z",
X	 ".zoo", ".zip", ".arc", ".sit");
X
X################ Search strategies ################
X #
X # $dofilesearch: 
X #   Look for file: XXX must exist as file XXX in some lib dir.
X #   Known extensions are also tried.
X #   This is default if no other strategies are selected.
X #
X # $doindexsearch:
X #   Lookup XXXNNNYYY in $indexfile. 
X #   If $indexfile is a relative filename, every lib dir is supposed to
X #   have one. 
X #   If $indexfile is an absolute filename, the location it appears in
X #   will be considered part of the archives. This can be overridden with
X #   $indexlib.
X #
X # $dodirsearch:
X #   Look in dir: XXX or XXXNNNYYY (where NNN is a version indicator,
X #   e.g. '-1.02' and YYY a known extension, e.g. '.tar.Z') must exist
X #   in some lib dir, or subdir XXXNNN.
X #   Example: 'gcc' matches 'gcc', 'gcc.tar.Z', 'gcc-2.1.tar.Z',
X #            'gcc-2.1/gcc.tar.Z' etc.
X #
X # If your index matches the archives (as specified in @libdirs), you
X # can safely set $dodirsearch to 0.
X #
X$indexfile = "ix.codes";	# index file per archive directory
X#$indexfile = "$libdir/ix.codes";	# separate index file 
X#$indexlib  = $libdirs[0];		# archive for index file
X$dofilesearch = 1;
X$doindexsearch = defined $indexfile;
X$dodirsearch = 1;
X #
X # If doindexsearch is selected, index searches can return a huge amount
X # of information. Therefore enforce a limit on the max. number of lines
X # an index request can return. Zero means: no limit.
X$maxindexlines = 200;
X
X################ The mail server files ################
X #
X # No need to change these, I suppose.
X #
X # Where to store requests.
X$queue = $libdir . "/queue";
X # Where to log. Undefine if you do not want logging.
X # Note -- you can override this at run-time with 'doreqest -nolog'.
X #         'chmod -w $logfile' also works.
X$logfile = $libdir . "/logfile";
X # Lock file to guard against multiple executions of 'dorequest'.
X$lockfile = $libdir . "/lockfile";
X # notes file. Will be prepended to each confirmation message.
X # NOTE: if you change this, you'll need to change the Makefile also.
X$notesfile = $libdir . "/mserv.notes";
X # hints file. Will be appended to each confirmation message.
X # NOTE: if you change this, you'll need to change the Makefile also.
X$hintsfile = $libdir . "/mserv.hints";
X
X################ Locking section ################
X #
X # Select a locking method. Not selecting a locking method
X # voids your warranty.
X #
X # fcntl(2) locking. Requires "errno.ph" and "fcntl.ph".
X$lock_fcntl = 1;
X #
X # BSD style flock(2). Requires "errno.ph" and "sys/file.h".
X#$lock_flock = 1;
X #
X # lockf(2) locking. Requires "errno.ph", "unistd.ph" and "sys/syscall.ph".
X#$lock_lockf = 1;
X
X################ Encoding programs ################
X #
X # Default encoding. Select one of B, U, D, X and make sure the
X # corresponding encoding tool exists.
X$default_encoding = "B";	# btoa
X #
X # Encoding programs. Supply a full pathname.
X # Encoding commands will be disallowed if the corresponding
X # encoding program is not available.
X # Since uuencode is fixed, it should better be there!
X$btoa     = "/usr/local/bin/btoa";	# btoa/atob
X$uuencode = "/usr/bin/uuencode";	# uu{en.de}code
X$uue      = "/usr/local/bin/uue"; 	# Dumas uue/uud program
X$xxencode = "/usr/local/bin/xxencode"; 	# xx{en.de}code
X
X################ Index section ################
X #
X # The following are only needed if you select indexsearch.
X # `makeindex' uses the GNU find program and locate tools.
X # The actual index lookup is performed by GNU locate 3.6 (or later)
X # or a customized version of GNU locate 3.5. In the latter case,
X # you need to "make ixlookup" and "make install-ixlookup".
X$gfind = "/usr/local/bin/gfind";
X # The GNU locate library (used to find bigram and code).
X$locatelib = "/usr/local/lib/locate";
X#$ixlookup = $libdir . "/ixlookup";	# based on GNU locate 3.5
X$ixlookup = "/usr/local/bin/locate";	# as of GNU locate 3.6
X
X################ Packing section ################
X #
X # The following are only needed if you want to support the packing 
X # of directories.
X #
X # Max number of blocks in a directory (as returned by 'du -s').
X # Undefine (or set to zero) if you do not want to support packing.
X$packing_limit = 4100;
X #
X # Tools.
X$du       = "/bin/du";			# get size of dir
X$find     = "/usr/local/bin/gfind";	# find
X$pdtar    = "/usr/local/bin/pdtar";	# create compressed ustar
X$tar      = "/bin/tar";			# if no $pdtar...
X$compress = "/usr/ucb/compress";	# if no $pdtar...
X$zoo      = "/usr/local/bin/zoo";	# zoo
X$zip      = "/usr/local/bin/zip";	# zip
X
X################ Miscellaneous ################
X #
X # Working directory. Should have space for at least 1.5 times the
X # biggest file in the archives...
X #
X$tmpdir = $ENV{"TMPDIR"} || "/usr/tmp";
X
X # Should "dorequest" be run automatically after completion of
X # "process"?
X$auto_runrequest = 1;
X
X################ End of configuation info ################
X
X1;
END_OF_FILE
  if test 9253 -ne `wc -c <'mserv_config.pl'`; then
    echo shar: \"'mserv_config.pl'\" unpacked with wrong size!
  fi
  # end of 'mserv_config.pl'
fi
if test -f 'unpack.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unpack.pl'\"
else
  echo shar: Extracting \"'unpack.pl'\" \(4170 characters\)
  sed "s/^X//" >'unpack.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X# unpack.pl -- unpack files
X# SCCS Status     : @(#)@ unpack	2.4
X# Author          : Johan Vromans
X# Created On      : Oct  2 21:33:00 1989
X# Last Modified By: Johan Vromans
X# Last Modified On: Sun May  3 17:37:22 1992
X# Update Count    : 5
X# Status          : Going steady
X
X# Unpack a set of files sent by the mail server with a tiny bit
X# of error detection.
X#
X# Usage: save all the parts in one big file (in the correct order), 
X# say "foo", and then execute:
X#
X#   perl unpack.pl foo
X#
X# Note: if the filename contains a path, all subdirectories should 
X# exist!
X# Multiple files in one input stream are allowed: e.g:
X#
X#------ begin of INDEX -- ascii -- complete ------
X#------ end of INDEX -- ascii -- complete ------
X#------ begin of zoo.TZ -- btoa encoded -- part 1 of 2 ------
X#------ end of zoo.TZ -- btoa encoded -- part 1 of 2 ------
X#------ begin of zoo.TZ -- btoa encoded -- part 2 of 2 ------
X#------ end of zoo.TZ -- btoa encoded -- part 2 of 2 ------
X#
X#
X################ configuration section ################
X#
X# Where to find these...
X#
X$atob = "atob";			# Ascii -> Binary
X$uudecode = "uudecode";		# UU
X$xxdecode = "xxdecode";		# XX
X$uud = "uud";			# Dumas' uue/uud programs.
X#
X################ end of configuration section ################
X
X&init;
X
Xwhile ( $line = <> ) {
X
X    if ( $line =~ /^------ begin of (.+) -- (.+) -- (.+) ------/ ) {
X	print STDERR $line;
X
X	# If a filename is known, it must be the same.
X	if ( $file ) {
X	    if ( $file != $1 ) {
X		&errmsg ("Filename mismatch");
X	    }
X	}
X	else {
X	    $file = $1;
X	}
X
X	# If an encoding is known, it must be the same.
X	if ( $encoding ) {
X	    if ( $encoding != $2 ) {
X		&errmsg ("Encoding mismatch");
X	    }
X	}
X	else {
X	    # Determine encoding and build command.
X	    $encoding = $2;
X	    if ( $encoding eq "uuencoded" ) {
X		$cmd = "|$uudecode";
X	    }
X	    elsif ( $encoding eq "xxencoded" ) {
X		$cmd = "|$xxdecode";
X	    }
X	    elsif ( $encoding eq "btoa encoded" ) {
X		$cmd = "|$atob > $file";
X	    }
X	    elsif ( $encoding eq "uue-encoded" ) {
X		$cmd = "|$uud - ";
X	    }
X	    else {
X		$cmd = ">$file";
X	    }
X	}
X
X	# If a 'parts' section is known, it must match.
X	# A bit more complex ...
X	$tparts = $3;
X	if ( $parts ) {
X	    if ( $tparts =~ /part (\d+) of (\d+)/ ) {
X
X		$thispart++;	# Increment part number and check.
X		if ( $thispart != $1 ) {
X		    &errmsg ("Sequence mismatch");
X		}
X
X		# Total number must match also.
X		if ( $numparts ) {
X		    if ( $numparts != $2 ) {
X			&errmsg ("Numparts mismatch");
X		    }
X		}
X		else {
X		    $numparts = $2;
X		}
X	    }
X	    elsif ( $parts ne $tparts ) {
X		&errmsg ("Parts mismatch");
X	    }
X	}
X	else {
X
X	    # No 'parts' known yet.
X	    $parts = $tparts;
X	    if ( $tparts =~ /part (\d+) of (\d+)/ ) {
X		$thispart = $1;
X		# Should be first part.
X		if ( $thispart != 1 ) {
X		    &errmsg ("Sequence mismatch");
X		}
X		$numparts = $2;
X	    }
X	    else {
X		$numparts = $thispart = 1;
X	    }
X	}
X
X	# If we have a file open, enable copying.
X	if ( $fileok ) {
X	    $copy = 1;
X	}
X	elsif ( open (OUTFILE, $cmd) ) {
X	    $fileok = 1;
X	    $copy = 1;
X	}
X	else {
X	    &errmsg ("Cannot create $cmd");
X	}
X
X	# Matching end header to look for.
X	$trailer = "------ end " . substr ($line, 13, length($line)-13);
X
X    }
X    elsif ( $line =~ /^------ end of (.+) -- (.+) -- (.+) ------/ ) {
X
X	print STDERR $line;
X
X	# Check that the header matches.
X	if ( $line ne $trailer ) {
X	    &errmsg ("Header/trailer mismatch");
X	}
X
X	# Wrap up if this was the last part.
X	&wrapup if $thispart == $numparts;
X
X	# Stop copying.
X	$copy = 0;
X    }
X    else {
X	if ( $copy ) {
X	    print OUTFILE $line;
X	}
X    }
X}
X
Xif ( $numparts && ( $thispart != $numparts )) {
X    &errmsg ("Only $thispart of $numparts parts found");
X}
X
Xif ( $fileok) {
X    &errmsg ("Unterminated section") if $?;
X}
X
X################ Subroutines ################
X
Xsub init {
X    $encoding = "";
X    $parts = "";
X    $numparts = "";
X    $file = "";
X    $copy = 0;
X    $thispart = 0;
X    $fileok = "";
X}
X
Xsub wrapup {
X    close (OUTFILE);
X    &errmsg ("Output close error [$?]") if $?;
X    &init;
X}
X
Xsub errmsg {
X    print STDERR ($my_name, ": ", pop(@_), " at input line $..\n");
X    exit 1;
X}
END_OF_FILE
  if test 4170 -ne `wc -c <'unpack.pl'`; then
    echo shar: \"'unpack.pl'\" unpacked with wrong size!
  fi
  # end of 'unpack.pl'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
