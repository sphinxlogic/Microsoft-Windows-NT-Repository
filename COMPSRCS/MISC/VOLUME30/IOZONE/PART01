Newsgroups: comp.sources.misc
From: bill@hood.tsg.tandem.com (Bill Norcott)
Subject:  v30i016:  iozone - IOzone V1.15 benchmark of sequential file I/O, Part01/01
Message-ID: <1992May23.180500.18153@sparky.imd.sterling.com>
X-Md4-Signature: d65ae07ff94005350b62c4dd08f3409b
Date: Sat, 23 May 1992 18:05:00 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: bill@tandem.com (Bill Norcott)
Posting-number: Volume 30, Issue 16
Archive-name: iozone/part01
Environment: AIX, BSD, HP-UX, MS-DOS, POSIX, SVR3.2, ULTRIX, UNIX, VMS
Supersedes: iozone: Volume 28, Issue 16

Attached is version V1.15 of my IOzone benchmark of sequential file
I/O.  IOzone measures the speed at which your system can read and write
files of various sizes and record lengths.  It prints out the measurement
in bytes-per-second.  IOzone is highly portable and now runs on about two
dozen different types of systems.

This version adds support for a few more systems, and also ANSI C
which will work on any operating system.  Another notable feature of
this release is support for UNIX RAW DEVICES such as tape drives,
floppy disk drives, and disk partitions.  This lets you test the
device without going through the file system buffer cache.

This distribution is a shell archive file containing two files: REAME &
iozone.c 

As always, I appreciate your comments and suggestions for IOzone.

Regards,
Bill Norcott
norcott_bill@tandem.com

#--------------------------------CUT HERE-------------------------------------
#! /bin/sh
#
# This is a shell archive.  Save this into a file, edit it
# and delete all lines above this comment.  Then give this
# file to sh by executing the command "sh file".  The files
# will be extracted into the current directory owned by
# you with default permissions.
#
# The files contained herein are:
#
# -rw-rw----   1 bill     posix      10024 May  1  1992 README
# -rw-rw-rw-   1 bill     posix      34629 May  1  1992 iozone.c
#
echo 'x - README'
if test -f README; then echo 'shar: not overwriting README'; else
sed 's/^X//' << '________This_Is_The_END________' > README
X
X	IOZONE: Performance Test of Sequential File I/O  --  V1.15 (5/1/92)
X		By Bill Norcott
X
X	Operating System: MIPS RISC/os (System V libraries)
X
XIOZONE: help mode
X
X       'IO Zone' Benchmark Program
X 
X       Author: Bill Norcott (norcott_bill@tandem.com)
X               1060 Hyde Avenue
X               San Jose, CA  95129
X 
X  Copyright 1991, 1992   William D. Norcott
X 
X  License to freely use and distribute this software is hereby granted 
X  by the author, subject to the condition that this copyright notice 
X  remains intact.  The author retains the exclusive right to publish 
X  derivative works based on this work, including, but not limited to, 
X  revised versions of this work
X 
X  This test writes a X MEGABYTE sequential file in Y byte chunks, then
X  rewinds it  and reads it back.  [The size of the file should be
X  big enough to factor out the effect of any disk cache.].  Finally,
X  IOZONE deletes the temporary file
X        
X  The file is written (filling any cache buffers), and then read.  If the
X  cache is >= X MB, then most if not all the reads will be satisfied from
X  the cache.  However, if it is less than or equal to .5X MB, then NONE of
X  the reads will be satisfied from the cache.  This is becase after the 
X  file is written, a .5X MB cache will contain the upper .5 MB of the test
X  file, but we will start reading from the beginning of the file (data
X  which is no longer in the cache)
X        
X  In order for this to be a fair test, the length of the test file must
X  be AT LEAST 2X the amount of disk cache memory for your system.  If
X  not, you are really testing the speed at which your CPU can read blocks
X  out of the cache (not a fair test)
X        
X  IOZONE does not normally test the raw I/O speed of your disk or system.
X  It tests the speed of sequential I/O to actual files.  Therefore, this
X  measurement factors in the efficiency of you machines file system,
X  operating system, C compiler, and C runtime library.  It produces a 
X  measurement which is the number of bytes per second that your system
X  can read or write to a file.  
X 
X  You use IOZONE to test the I/O speed of a UNIX 'RAW DEVICE' such
X  as a tape drive, hard disk drive, floppy disk drive, etc.  To do this,
X  you must define the symbol NO_DELETE when you compile IOZONE.  If you
X  fail to define NO_DELETE, IOZONE will treat the raw device as a 
X  temporary file, and WILL DELETE THE RAW DEVICE after the test completes!
X  When testing raw devices, any UNIX buffer caching is bypassed.  IOZONE
X  still is using the read()/write() system calls, so you are not quite
X  testing the device at the low level of say, disk controller diagnostics.
X  On the other hand, that kind of testing is highly system- and device-
X  specific, and my goal for IOZONE has been to build a highly portable
X  benchmark -- not one which is tied to a particular operating system or
X  hardware configuration.  In practice, I have tested raw disk and tape
X  peripherals and the results are very close to the manufacturer's specs
X  for those devices.
X 
X  For V1.06, IOZONE adds the 'auto test' feature.  This is activated
X  by the command:  'iozone auto' .  The auto test runs IOZONE repeatedly  
X  using record sizes from 512 to 8192 bytes, and file sizes from 1 to 16
X  megabytes.  It creates a table of results.
X        
X  For V1.06, IOZONE lets you specify the number of file system sizes and      
X  record lengths to test when using auto mode.  Define the constants
X  MEGABYTES_ITER_LIMIT and RECLEN_ITER_LIMIT as seen below      
X        
X  For V1.09 you can show the development help by typing 'iozone help'
X        
X  For V1.10 IOzone traps SIGINT (user interrupt) and SIGTERM
X  (kill from shell) signals and deletes the temporary file
X        
X  For V1.11 IOzone requires no compilation flags for AIX
X  Also, come miscellaneous cleanups have been made to the source
X        
X  For V1.12 IOzone support has been added for the MIPS RISCos,
X  Tandem Non-StopUX, and Tandem GUARDIAN 90 operating systems.
X  IOzone is now a 'Conforming POSIX.1 Application'  (IEEE Std 1003.1-1988)
X        
X  For V1.14 IOzone supports Next and QNX systems.  It also prints out
X  the name of the operating system when run.  There is now the option
X  to force IOzone to flush all writes to disk via fsync()
X  Defining USE_FSYNC will make IOzone include in its measurements the time
X  it takes to actually write the data onto disk, as opposed to
X  just writing into the system cache.  BSD UNIX and SVR4 support fsync(),
X  but SVR3 and generic POSIX systems do not.  I have enabled USE_FSYNC
X  for the systems which support it
X        
X  For V1.14, we now officially support AT&T SVR4.  It has worked just
X  fine using SVR4 with previous versions of IOzone.  Also, for systems
X  which use the times() function, we calculate the 'base time' the first
X  time we ever call time_so_far(), then subtract this time from all
X  future measurements.  This increases the precision of our measurement
X  and fixes a loss-of-precision problem which occurred on some systems
X        
X  For V1.15, add the NO_DELETE symbol.  If you define NO_DELETE during
X  the compilation (e.g., for UNIX systems compile with cc -DNO_DELETE),
X  IOzone will not delete the 'temporary' file which it reads & writes.
X  This is REQUIRED when testing RAW DEVICES such as disks and tape drives!
X        
X 
X  This program has been ported and tested on the following computer
X  operating systems:
X 
X    Vendor             Operating System    Notes on compiling IOzone
X    -------------------------------------------------------------------------
X    Apollo		  Domain/OS           no cc switches -- BSD domain
X    AT&T               UNIX System V Release 4
X    AT&T 6386WGS       AT&T UNIX 5.3.2     define SYSTYPE_SYSV
X    Generic AT&T       UNIX System V R3    may need cc -DSVR3
X    Convergent         Unisys/AT&T Sys5r3  cc -DCONVERGENT -o iozone iozone.c
X    Digital Equipment  ULTRIX V4.1 
X    Digital Equipment  VAX/VMS V5.4        see below **         
X    Digital Equipment  VAX/VMS (POSIX) 
X    Hewlett-Packard    HP-UX 7.05
X    IBM                AIX Ver. 3 rel. 1
X    Interactive        UNIX System V R3    
X    Microsoft          MS-DOS 3.3          tested Borland, Microsoft C
X    MIPS               RISCos 4.52
X    NeXt               NeXt OS 2.x
X    OSF                OSF/1
X    Portable!          POSIX 1003.1-1988   may need to define _POSIX_SOURCE 
X    QNX                QNX 4.0
X    SCO                UNIX System V/386 3.2.2
X    SCO                XENIX 2.3
X    SCO                XENIX 3.2
X    Silicon Graphics   UNIX                cc -DSGI -o iozone iozone.c
X    Sony Microsystems  UNIX                same as MIPS
X    Sun Microsystems   SUNOS 4.1.1
X    Tandem Computers   GUARDIAN 90         1. call the source file IOZONEC
X                                           2. C/IN IOZONEC/IOZONE;RUNNABLE
X                                           3. RUN IOZONE
X    Tandem Computers   Non-Stop UX
X        
X    ** for VMS, define iozone as a foreign command via this DCL command:       
X 
X       $IOZONE :== $SYS$DISK:[]IOZONE.EXE      
X 
X       this lets you pass the command line arguments to IOZONE
X 
X  Acknowledgements to the following persons for their feedback on IOzone:       
X 
X  Andy Puchrik, Michael D. Lawler, Krishna E. Bera, Sam Drake, John H. Hartman, 
X  Ted Lyszczarz, Bill Metzenthen, Jody Winston, Clarence Dold, Axel
X  Dan Hildebrand, Joe Nordman, Bob Fritz, Jeff Johnson
X        
X  --- MODIFICATION HISTORY:
X 
X 
X    3/7/91 William D. Norcott (Bill.Norcott@nuo.mts.dec.com)
X                               created
X 
X    3/22/91 Bill Norcott       tested on OSF/1 ... it works
X 
X    3/24/91 Bill Norcott       V1.02 -- use calloc in TURBOC to
X                                       fix bug with their malloc
X 
X    3/25/91 Bill Norcott       V1.03 -- add ifdef for XENIX
X                                       
X    3/27/91 Bill Norcott       V1.04 -- Includes for SCO UNIX
X                                       
X    4/26/91 Bill Norcott       V1.05 -- support AIX and SUNos, check
X                                       length of read() and write()
X    4/26/91 Bill Norcott       V1.06 -- tabulate results of a series 
X                                       of tests
X    5/17/91 Bill Norcott       V1.07 -- use time() for VMS
X    5/20/91 Bill Norcott       V1.08 -- use %ld for Turbo C and
X                                       use #ifdef sun to bypass
X                                       inclusion of limits.h
X    6/19/91 Bill Norcott       V1.09 -- rid #elif to support HP-UX and 
X                                       Silicon Graphics UNIX, and
X                                       add #ifdef SGI
X                                       add #ifdef CONVERGENT
X                                       for Convergent Technologies
X                                       also add help option
X    7/2/91 Bill Norcott        V1.10 -- delete file if get SIGINT
X                                       or SIGTERM
X    8/20/91 Bill Norcott       V1.11 -- require no flags with AIX
X    11/4/91 Bill Norcott       V1.12 -- support MIPS RISCos
X                                         Tandem NonStop-UX, and
X                                        IEEE Std POSIX 1003.1-1988
X    12/4/91 Bill Norcott       V1.13 -- support NeXT; tell host OS type
X    1/23/92 Bill Norcott      V1.14 -- support QNX & use calloc() for buffer
X    5/1/92 Bill Norcott      V1.15 -- support SVR4; fix loss of precision
X                                       in times() function.  
X                                       support Interactive UNIX
X                                       detect ANSI if no O/S
X                                       Also, define for generic SVR3
X                                       Apollo Domain/OS
X                                       Define NO_DELETE and iozone wont
X                                       delete the temp file.  Needed to
X                                       test raw devices without deleting
X                                       them
________This_Is_The_END________
if test `wc -l < README` -ne 197 ; then
	echo 'shar: README was damaged during transit (should have been 197  bytes)'
fi
fi		; : end of overwriting check
echo 'x - iozone.c'
if test -f iozone.c; then echo 'shar: not overwriting iozone.c'; else
sed 's/^X//' << '________This_Is_The_END________' > iozone.c
Xchar *help[] = {
X  "       'IO Zone' Benchmark Program",
X  " ",
X  "       Author: Bill Norcott (norcott_bill@tandem.com)",
X  "               1060 Hyde Avenue",
X  "               San Jose, CA  95129",
X  " ",
X  "  Copyright 1991, 1992   William D. Norcott",
X  " ",
X  "  License to freely use and distribute this software is hereby granted ",
X  "  by the author, subject to the condition that this copyright notice ",
X  "  remains intact.  The author retains the exclusive right to publish ",
X  "  derivative works based on this work, including, but not limited to, ",
X  "  revised versions of this work",
X  " ",
X  "  This test writes a X MEGABYTE sequential file in Y byte chunks, then",
X  "  rewinds it  and reads it back.  [The size of the file should be",
X  "  big enough to factor out the effect of any disk cache.].  Finally,",
X  "  IOZONE deletes the temporary file",
X  "        ",
X  "  The file is written (filling any cache buffers), and then read.  If the",
X  "  cache is >= X MB, then most if not all the reads will be satisfied from",
X  "  the cache.  However, if it is less than or equal to .5X MB, then NONE of",
X  "  the reads will be satisfied from the cache.  This is becase after the ",
X  "  file is written, a .5X MB cache will contain the upper .5 MB of the test",
X  "  file, but we will start reading from the beginning of the file (data",
X  "  which is no longer in the cache)",
X  "        ",
X  "  In order for this to be a fair test, the length of the test file must",
X  "  be AT LEAST 2X the amount of disk cache memory for your system.  If",
X  "  not, you are really testing the speed at which your CPU can read blocks",
X  "  out of the cache (not a fair test)",
X  "        ",
X  "  IOZONE does not normally test the raw I/O speed of your disk or system.",
X  "  It tests the speed of sequential I/O to actual files.  Therefore, this",
X  "  measurement factors in the efficiency of you machines file system,",
X  "  operating system, C compiler, and C runtime library.  It produces a ",
X  "  measurement which is the number of bytes per second that your system",
X  "  can read or write to a file.  ",
X  " ",
X  "  You use IOZONE to test the I/O speed of a UNIX 'RAW DEVICE' such",
X  "  as a tape drive, hard disk drive, floppy disk drive, etc.  To do this,",
X  "  you must define the symbol NO_DELETE when you compile IOZONE.  If you",   
X  "  fail to define NO_DELETE, IOZONE will treat the raw device as a ",
X  "  temporary file, and WILL DELETE THE RAW DEVICE after the test completes!",
X  "  When testing raw devices, any UNIX buffer caching is bypassed.  IOZONE",
X  "  still is using the read()/write() system calls, so you are not quite",
X  "  testing the device at the low level of say, disk controller diagnostics.",
X  "  On the other hand, that kind of testing is highly system- and device-",
X  "  specific, and my goal for IOZONE has been to build a highly portable",
X  "  benchmark -- not one which is tied to a particular operating system or",
X  "  hardware configuration.  In practice, I have tested raw disk and tape",
X  "  peripherals and the results are very close to the manufacturer's specs",
X  "  for those devices.", 
X  " ",
X  "  For V1.06, IOZONE adds the 'auto test' feature.  This is activated",
X  "  by the command:  'iozone auto' .  The auto test runs IOZONE repeatedly  ",
X  "  using record sizes from 512 to 8192 bytes, and file sizes from 1 to 16",
X  "  megabytes.  It creates a table of results.",
X  "        ",
X  "  For V1.06, IOZONE lets you specify the number of file system sizes and      ",
X  "  record lengths to test when using auto mode.  Define the constants",
X  "  MEGABYTES_ITER_LIMIT and RECLEN_ITER_LIMIT as seen below      ",
X  "        ",
X  "  For V1.09 you can show the development help by typing 'iozone help'",
X  "        ",
X  "  For V1.10 IOzone traps SIGINT (user interrupt) and SIGTERM",
X  "  (kill from shell) signals and deletes the temporary file",
X  "        ",
X  "  For V1.11 IOzone requires no compilation flags for AIX",
X  "  Also, come miscellaneous cleanups have been made to the source",
X  "        ",
X  "  For V1.12 IOzone support has been added for the MIPS RISCos,",
X  "  Tandem Non-StopUX, and Tandem GUARDIAN 90 operating systems.",
X  "  IOzone is now a 'Conforming POSIX.1 Application'  (IEEE Std 1003.1-1988)",
X  "        ",
X  "  For V1.14 IOzone supports Next and QNX systems.  It also prints out", 
X  "  the name of the operating system when run.  There is now the option",
X  "  to force IOzone to flush all writes to disk via fsync()",
X  "  Defining USE_FSYNC will make IOzone include in its measurements the time",
X  "  it takes to actually write the data onto disk, as opposed to",
X  "  just writing into the system cache.  BSD UNIX and SVR4 support fsync(),",
X  "  but SVR3 and generic POSIX systems do not.  I have enabled USE_FSYNC",
X  "  for the systems which support it",
X  "        ",
X  "  For V1.14, we now officially support AT&T SVR4.  It has worked just",
X  "  fine using SVR4 with previous versions of IOzone.  Also, for systems",
X  "  which use the times() function, we calculate the 'base time' the first",
X  "  time we ever call time_so_far(), then subtract this time from all",
X  "  future measurements.  This increases the precision of our measurement",
X  "  and fixes a loss-of-precision problem which occurred on some systems",
X  "        ",
X  "  For V1.15, add the NO_DELETE symbol.  If you define NO_DELETE during",
X  "  the compilation (e.g., for UNIX systems compile with cc -DNO_DELETE),",
X  "  IOzone will not delete the 'temporary' file which it reads & writes.",
X  "  This is REQUIRED when testing RAW DEVICES such as disks and tape drives!",
X  "        ",
X  " ",
X  "  This program has been ported and tested on the following computer",
X  "  operating systems:",
X  " ",
X  "    Vendor             Operating System    Notes on compiling IOzone",
X  "    -------------------------------------------------------------------------",
X  "    Apollo		  Domain/OS           no cc switches -- BSD domain", 
X  "    AT&T               UNIX System V Release 4",
X  "    AT&T 6386WGS       AT&T UNIX 5.3.2     define SYSTYPE_SYSV",
X  "    Generic AT&T       UNIX System V R3    may need cc -DSVR3",
X  "    Convergent         Unisys/AT&T Sys5r3  cc -DCONVERGENT -o iozone iozone.c",
X  "    Digital Equipment  ULTRIX V4.1 ",
X  "    Digital Equipment  VAX/VMS V5.4        see below **         ",
X  "    Digital Equipment  VAX/VMS (POSIX) ",
X  "    Hewlett-Packard    HP-UX 7.05",
X  "    IBM                AIX Ver. 3 rel. 1",
X  "    Interactive        UNIX System V R3    ",
X  "    Microsoft          MS-DOS 3.3          tested Borland, Microsoft C",
X  "    MIPS               RISCos 4.52",
X  "    NeXt               NeXt OS 2.x",
X  "    OSF                OSF/1",
X  "    Portable!          POSIX 1003.1-1988   may need to define _POSIX_SOURCE ",
X  "    QNX                QNX 4.0",
X  "    SCO                UNIX System V/386 3.2.2",
X  "    SCO                XENIX 2.3",
X  "    SCO                XENIX 3.2",
X  "    Silicon Graphics   UNIX                cc -DSGI -o iozone iozone.c",
X  "    Sony Microsystems  UNIX                same as MIPS",
X  "    Sun Microsystems   SUNOS 4.1.1",
X  "    Tandem Computers   GUARDIAN 90         1. call the source file IOZONEC",
X  "                                           2. C/IN IOZONEC/IOZONE;RUNNABLE",
X  "                                           3. RUN IOZONE",
X  "    Tandem Computers   Non-Stop UX",
X  "        ",
X  "    ** for VMS, define iozone as a foreign command via this DCL command:       ",
X  " ",
X  "       $IOZONE :== $SYS$DISK:[]IOZONE.EXE      ",
X  " ",
X  "       this lets you pass the command line arguments to IOZONE",
X  " ",
X  "  Acknowledgements to the following persons for their feedback on IOzone:       ",
X  " ",
X  "  Andy Puchrik, Michael D. Lawler, Krishna E. Bera, Sam Drake, John H. Hartman, ",
X  "  Ted Lyszczarz, Bill Metzenthen, Jody Winston, Clarence Dold, Axel",
X  "  Dan Hildebrand, Joe Nordman, Bob Fritz, Jeff Johnson",
X  "        ",
X  "  --- MODIFICATION HISTORY:",
X  " ",
X  " ",
X  "    3/7/91 William D. Norcott (Bill.Norcott@nuo.mts.dec.com)",
X  "                               created",
X  " ",
X  "    3/22/91 Bill Norcott       tested on OSF/1 ... it works",
X  " ",
X  "    3/24/91 Bill Norcott       V1.02 -- use calloc in TURBOC to",
X  "                                       fix bug with their malloc",
X  " ",
X  "    3/25/91 Bill Norcott       V1.03 -- add ifdef for XENIX",
X  "                                       ",
X  "    3/27/91 Bill Norcott       V1.04 -- Includes for SCO UNIX",
X  "                                       ",
X  "    4/26/91 Bill Norcott       V1.05 -- support AIX and SUNos, check",
X  "                                       length of read() and write()",
X  "    4/26/91 Bill Norcott       V1.06 -- tabulate results of a series ",
X  "                                       of tests",
X  "    5/17/91 Bill Norcott       V1.07 -- use time() for VMS",
X  "    5/20/91 Bill Norcott       V1.08 -- use %ld for Turbo C and",
X  "                                       use #ifdef sun to bypass",
X  "                                       inclusion of limits.h",
X  "    6/19/91 Bill Norcott       V1.09 -- rid #elif to support HP-UX and ",
X  "                                       Silicon Graphics UNIX, and",
X  "                                       add #ifdef SGI",
X  "                                       add #ifdef CONVERGENT",
X  "                                       for Convergent Technologies",
X  "                                       also add help option",
X  "    7/2/91 Bill Norcott        V1.10 -- delete file if get SIGINT",
X  "                                       or SIGTERM",
X  "    8/20/91 Bill Norcott       V1.11 -- require no flags with AIX",
X  "    11/4/91 Bill Norcott       V1.12 -- support MIPS RISCos",
X  "                                         Tandem NonStop-UX, and",
X  "                                        IEEE Std POSIX 1003.1-1988",
X  "    12/4/91 Bill Norcott       V1.13 -- support NeXT; tell host OS type",
X  "    1/23/92 Bill Norcott      V1.14 -- support QNX & use calloc() for buffer",
X  "    5/1/92 Bill Norcott      V1.15 -- support SVR4; fix loss of precision",
X  "                                       in times() function.  ",
X  "                                       support Interactive UNIX",
X  "                                       detect ANSI if no O/S",
X  "                                       Also, define for generic SVR3",
X  "                                       Apollo Domain/OS",
X  "                                       Define NO_DELETE and iozone wont",
X  "                                       delete the temp file.  Needed to",
X  "                                       test raw devices without deleting",
X  "                                       them",
X  "" };
X
X/******************************************************************
X  
X  INCLUDE FILES (system-dependent)
X  
X  ******************************************************************/
X/* 
XV1.15 -- Define the symbol NO_DELETE if you plan to use IOzone to test
Xthe speed of UNIX raw devices such as disk- and tape drives.  This will
Xtell IOzone NOT to delete the file after the test completes
X*/
X/* #define NO_DELETE */
X/* 
XV1.15 -- If you have a generic System V R3 not on my list of supported
Xsystems, define SVR3 when you compile IOzone. If you have to use this, please
Xsend tell me what preprocessor symbols your C compiler defines which
Xwill help me test for your particular system... do a 'man cc' on a
XUNIX system to check, or just do a 'man cc > cc.txt' and mail me
Xcc.txt
X*/
X/*  Define the following if you have a generic System V R3 system which
Xis not one of the specific versions listed above
X*/
X/* #define SVR3 */
X#ifdef SVR3
X#ifndef OS_TYPE
X#define OS_TYPE "'Generic' UNIX System V Release 3 -- vendor unknown" 
X#endif
X#include <fcntl.h>
X#include <sys/types.h>
X#define SysVtime
X#endif
X/* V1.15 -- add Apollo Domain O/S to the list -- it also worked in previous
Xversions, now it will print its identity
X*/
X#ifdef apollo
X#ifndef OS_TYPE
X#define OS_TYPE "Apollo Domain/OS -- using BSD libraries"
X#define BSDtime
X#define USE_FSYNC
X#endif
X#endif
X
X/* V1.14 -- use calloc instead of stack for buffer, on all platforms */
X#define usecalloc
X/* 
XV1.14b -- check for ultrix which uses sysconf in newer POSIX version 
Xbut uses BSD-style time in the pre-POSIX versions
XV1.15 use fsync() for ultrix even though V4.2 will pick up other options
Xfrom POSIX
X*/
X#ifdef ultrix
X#ifndef OS_TYPE
X#define OS_TYPE "ULTRIX 4.0 or earlier"
X#define BSDtime
X#define USE_FSYNC
X#endif
X#endif
X/* V1.13 -- support NeXT by treating it like a Sun... Thanks Axel! */
X#ifdef __NeXT__
X#ifndef OS_TYPE
X#define OS_TYPE "NeXT OS"
X#endif
X#define sun
X#endif
X/*
X  define nolimits if your system has no limits.h.  Sun's don't but I
X  take care of this explicitly beginning with V1.08 of IOzone.
X  */
X#ifdef sun
X#ifndef OS_TYPE
X#define OS_TYPE "SunOS"
X#endif
X#define nolimits
X#define BSDtime
X#define USE_FSYNC
X#endif
X/* V1.09 -- Silicon Graphics compile with -DSGI  */
X#ifdef SGI
X#ifndef OS_TYPE
X#define OS_TYPE "Silicon Graphics"
X#endif
X#define nolimits
X#define BSDtime
X#endif
X
X/* V1.13 For MIPS RISC/OS and Tandem NonStop-UX*/
X#ifdef SYSTYPE_BSD43
X#define bsd4_3
X#ifndef OS_TYPE
X#define OS_TYPE "MIPS RISC/os (BSD 4.3 libraries)"
X#endif
X#endif
X
X#ifdef SYSTYPE_SYSV
X#include <sys/utsname.h>
X#define nolimits
X#ifdef T_NONSTOP
X#define OS_TYPE "TANDEM NonStop-UX (System V libraries)"
X#endif
X#ifndef OS_TYPE
X#define OS_TYPE "MIPS RISC/os (System V libraries)"
X#endif
X#define SysVtime
X#include <sys/types.h>
X#include <sys/times.h>
X#include <sys/fcntl.h>
X#endif
X/* V1.14 -- define nolimits and BSDtime for Xenix 2.3.3 */
X/* incl definitions of O_* flags for XENIX */
X#ifdef M_UNIX
X#define SCOunix
X#else
X#ifdef M_XENIX
X#define SCOxenix
X#endif
X#endif
X
X/* SCO Unix System V */
X#ifdef SCOunix
X#define OS_TYPE "SCO UNIX System V/386"
X#include <sys/types.h>
X#include <sys/fcntl.h>
X#endif
X
X#ifdef SCOxenix
X#ifdef XENIX_2_3
X#define OS_TYPE "SCO XENIX 2.3.x"
X#define BSDtime
X#else
X#define OS_TYPE "SCO XENIX 3.x"
X#define SysVtime
X#endif
X#endif
X
X/* V1.12 -- test for POSIX-conformant operating system; requires limits.h */
X/*
XV1.15 -- I have been told that there is a problem in the times() POSIX 
Xfunction in Ultrix V4.1 and greater.  It seems to return the time in
Xwhole seconds (expressed in terms of clock ticks) instead of correctly
Xreturning the elapsed time in clock ticks ALTHOUGH POSIX 1003.1-1988 
Xand ISO 9945 CLEARLY STATE that "times() shall return the elapsed real 
Xtime, in clock ticks."  
X
XThis means calling times() twice in the same second and subtracting
Xthe two values, produces an answer of 0, which IOzone detects as an error.
X
XI thought I had a problem in V1.14 under Ultrix with loss of precision, 
Xi.e. taking the difference of two large floating point numbers, 
Xbut the problem seems be that Ultrix times() *inherently* has a 
Xloss of precision, so my "fix" can't fix the broken system call.  
XUntil they fix it in Ultrix I am going to use BSD-style everything
Xfor Ultrix
X*/
X#ifndef nolimits
X
X#include <limits.h>
X#ifdef _POSIX_ARG_MAX
X#ifndef ultrix
X#ifndef OS_TYPE
X#define OS_TYPE "POSIX 1003.1-1988"
X#endif
X#define isposix
X#undef USE_FSYNC
X#else
X/* It's ultrix disguised as POSIX; still use BSD calls until they fix it */
X#undef OS_TYPE
X#define OS_TYPE "ULTRIX 4.1 or later"
X#endif
X#endif
X#endif
X
X/* Tandem's GUARDIAN operating system */
X#include <stdio.h>
X#ifdef __TANDEM
X#ifndef OS_TYPE
X#define OS_TYPE "TANDEM GUARDIAN 90"
X#endif
X#define nosignals
X#define ANSItime
X#define ANSI_MAIN
X#include <fcntl.h>
X#include <stdlib.h>
X#include <string.h>
X#include <time.h>
X#endif
X#ifndef nosignals
X#include <signal.h>
X#endif
X#ifdef  __MSDOS__               /* Turbo C define this way for PCs... */
X#define MSDOS                   /* Microsoft C defines this */
X#endif
X/* VMS and MS-DOS both have ANSI C compilers and use rand()/srand() */
X#ifdef  VMS_POSIX
X#undef   VMS
X#define ANSI_RANDOM     1
X#endif
X#ifdef  MSDOS
X#define ANSI_RANDOM     1
X#endif
X/* Convergent Technologies M680xx based with Unisys/AT&T Sys5r3 */
X#ifdef CONVERGENT
X#ifndef OS_TYPE
X#define OS_TYPE "Convergent Technologies" 
X#endif
X#include <fcntl.h>
X#define SysVtime
X#endif
X/* Interactive UNIX System V Release 3.2 */
X#ifdef isc386
X#ifndef OS_TYPE
X#define OS_TYPE "Interactive UNIX System V/386" 
X#endif
X#include <fcntl.h>
X#define SysVtime
X#endif
X
X/* V1.11 -- With the following includes, AIX no longer requires -Dunix */
X#ifdef _AIX
X#ifndef OS_TYPE
X#define OS_TYPE "AIX"
X#endif
X#include <fcntl.h>
X#include <sys/time.h>
X#endif
X
X#if defined(VMS)
X#ifndef OS_TYPE
X#define OS_TYPE "VAX/VMS"
X#endif
X#define ANSItime
X#define ANSI_RANDOM     1
X#include    <math.h>
X#include    <unixio.h>
X#include    <ssdef.h>
X#include    <file.h>
X#include    <time.h>
X
X#else
X/* ... either MSDOS, POSIX, or a generic non-POSIX UNIX */
X#ifdef MSDOS
X#ifndef OS_TYPE
X#define OS_TYPE "MS-DOS"
X#endif
X#define usecalloc
X#include <fcntl.h>
X#include <time.h>
X#endif
X/* nope, not MS-DOS, try POSIX */
X#ifdef isposix
X#include <time.h>
X#include <sys/times.h>
X#include <fcntl.h>
X#include <unistd.h>
X#else
X#ifdef unix
X#include <fcntl.h>
X#else 
X#define O_RDONLY 0
X#endif
X#endif
X#endif
X
X/* for systems with System V-style time, define SysVtime */
X#ifdef M_SYSV
X#define SysVtime
X#endif
X
X/* for systems with BSD style time, define BSDtime */
X#ifdef bsd4_2
X#define USE_FSYNC
X#ifndef OS_TYPE
X#define OS_TYPE "BSD 4.2"
X#endif
X#define BSDtime
X#endif
X#ifdef bsd4_3
X#define USE_FSYNC
X#ifndef OS_TYPE
X#define OS_TYPE "BSD 4.3"
X#endif
X#define BSDtime
X#endif
X/*
XIf we made it this far and still don't know which operating system
Xwe are running, check if we at least have ANSI C so we can do some
Xkind of time functions.  On the other hand, if we know what O/S
Xwe are running use the (more precise) time routines for that O/S,
Xeven if we do have ANSI C.  If we don't know what O/S we are and
Xwe don't have ANSI C, but we are some flavor of UNIX, I will use
Xtime() which any UNIX will have.  For the worst case we are not 
Xany form of UNIX nor a supported proprietary O/S, and we don't have 
XANSI C either,  one of two things will happen:
X1. If you define NOTIMER then you will have to use a stopwatch
X2. If NOTIMER not defined, we will assume we can use time()
X*/
X#ifndef OS_TYPE
X#ifdef __STDC__
X#define OS_TYPE "ANSI C"
X#define ANSItime
X#include    <time.h>
X#endif
X#endif
X
X#ifndef OS_TYPE
X#ifdef unix
X#define OS_TYPE "UNIX (can't tell if System V or BSD) -- using time()"
X#define ANSItime
X#include    <time.h>
X#endif
X#endif
X
X#ifndef OS_TYPE
X#if NOTIMER
X#define OS_TYPE "System type unknown & not ANSI C -- disabling timing"
X#define noclock 1
X#else
X#define OS_TYPE "System type unknown & not ANSI C -- using time()"
X#define ANSItime
X#include    <time.h>
X#endif
X#endif
X
X#ifdef SysVtime
X#undef BSDtime
X#include <sys/times.h>
X#include <sys/param.h>
X#ifndef CLK_TCK
X#define CLK_TCK HZ
X#endif
X#endif
X
X#ifdef BSDtime
X#undef SysVtime
X#include <sys/time.h>
X#endif
X
X/******************************************************************
X  
X  DEFINED CONSTANTS
X  
X  ******************************************************************/
X/* Define NULL in case we don't have it... */
X#ifndef NULL
X#define NULL 0
X#endif
X/* 
X  V1.14: Define ONETEST to run a single test at runtime as the default
X  V1.14: Define AUTOTEST to run in auto test mode as the default
X  i.e. the behavior of IOzone when it is invoked with no arguments.  ONETEST
X  makes IOzone run a single test using a 1 MB file and 512 byte records.
X  AUTOTEST causes IOzone to use auto test mode.
X  For compatibility with previous versions of IOZONE, ONETEST is the default
X  setting
X*/
X#define ONETEST 1
X#ifndef ONETEST
X#define AUTOTEST
X#endif
X
X/* 
X  V1.14: Define USE_FSYNC to force writes to disk during the write phase
X  BSD and BSD-derived UNIX variants and also SVR4 are known to have fsync 
X  UNIX).  After the file is written and before it is closed, call fsync()
X  to force the data to be written from cache to disk.  This (mostly) cancels
X  the fact that systems with a lot of memory for cache buffers or memory
X  mapping display artificially high transfer rates during the write phase
X  of IOzone, because the data never makes it onto the disk.  
X
X*/
X#if 0
X#define USE_FSYNC
X#endif
X
X#define MEGABYTES 1                     /* number of megabytes in file */
X#define RECLEN 512                      /* number of bytes in a record */
X#define FILESIZE 1048576                /*size of file in bytes*/
X#define NUMRECS 2048                    /* number of records */
X#define MAXBUFFERSIZE 16*1024           /*maximum buffer size*/
X#define MINBUFFERSIZE 128
X#define TOOFAST 10
X#define IOZONE_USAGE \
X"\tUsage:\tiozone [megabytes] [record_length_in_bytes] [[path]filename]\n\t\tiozone auto\n\t\tiozone help\n\n"
X#define THISVERSION "V1.15"
X#define RELEASEDATE "5/1/92"
X  /* Define only one of the following two.  All modern operating systems
X     have time functions so let TIME be defined */
X#ifndef noclock
X#define TIME 1
X#endif
X  
X#define MAXNAMESIZE 1000                /* max # of characters in filename */
X#define CONTROL_STRING1 "\t%-8ld%-8ld%-20ld%-20ld\n"
X#define CONTROL_STRING2 "\t%-8s%-8s%-20s%-20s\n"
X  /*
X    For 'auto mode', these defines determine the number of iterations
X    to perform for both the file size and the record length.
X    I.e., if MEGABYTES_ITER_LIMIT = 5 use 1, 2, 4, 8 & 16 megabyte files
X    if RECLEN_ITER_LIMIT = 5 use 512, 1024, 2048, 4096 & 8192 byte records
X    */
X#define MEGABYTES_ITER_LIMIT 5
X#define RECLEN_ITER_LIMIT 5
X/******************************************************************
X  
X  MACRO DEFINITIONS
X  
X  ******************************************************************/
X#define abs(X) ( (X) < 0 ? (-(X)) : (X) )  /* Absolute value of X */
X  /******************************************************************
X    
X    FUNCTION DECLARATIONS
X    
X
X    ******************************************************************/
Xvoid auto_test();               /* perform automatic test series */
Xvoid show_help();               /* show development help*/
Xdouble time_so_far();    	/* time since start of program */
Xvoid signal_handler();          /* clean up if user interrupts us */
X/******************************************************************
X  
X  GLOBAL VARIABLES
X  
X  ******************************************************************/
Xint auto_mode;
Xchar filename [MAXNAMESIZE];            /* name of temporary file */
X/******************************************************************
X  
X  MAIN -- entry point
X  
X  ******************************************************************/
X#ifdef ANSI_MAIN
Xint 
Xmain(int argc, char *argv[], char *env[])    /* main body of code */
X#else
Xint
X     main(argc,argv)
X     int argc;
X     char *argv[];
X#endif
X{
X#ifdef ANSI_MAIN
X  char *fooenv;
X#endif
X  int fd;
X  char *default_filename;
X  
X#ifdef  usecalloc
X  char *buffer;
X#else
X  char buffer [MAXBUFFERSIZE];            /*a temporary data buffer*/
X#endif
X  unsigned i;
X  unsigned megabytes = MEGABYTES;
X  unsigned reclen = RECLEN;
X  unsigned long filesize;
X  unsigned long numrecs;
X  unsigned long thisrec;
X#ifdef TIME
X  unsigned long filebytes;
X  unsigned long readrate, writerate;
X  unsigned goodmegs;
X  unsigned goodrecl;
X  double starttime;
X  double writetime, readtime;
X  double totaltime;
X#endif
X#ifdef usecalloc
X    buffer = (char *) calloc(1, MAXBUFFERSIZE);
X#endif
X  
X#if defined (ANSI_MAIN)
X  fooenv= env[0];       /* dummy so we make some use of env (to avoid warnings) */
X#endif
X  
X#if defined (__TANDEM)
X  default_filename ="IOZONET"; /* TANDEM GUARDIAN 90 has max 8 char filenames */
X#else
X  default_filename ="iozone.tmp"; /*default name of temporary file*/
X#endif
X  if (!auto_mode)
X    {
X      printf("\n\tIOZONE: Performance Test of Sequential File I/O  --  %s (%s)\n",
X	     THISVERSION, RELEASEDATE);
X      printf("\t\tBy Bill Norcott\n\n");
X#ifdef USE_FSYNC
X      printf("\tOperating System: %s -- using fsync()\n\n", OS_TYPE);
X#else
X      printf("\tOperating System: %s\n\n", OS_TYPE);
X#endif
X#ifndef nosignals
X      signal(SIGINT, signal_handler);      /* handle user interrupt */
X      signal(SIGTERM, signal_handler);     /* handle kill from shell */
X#endif
X    }
X  strcpy(filename,default_filename);
X  switch (argc) {
X  case 1:     /* no args, take all defaults */ 
X    printf(IOZONE_USAGE);
X#ifdef AUTOTEST
X    auto_mode = 1;
X    auto_test();
X    printf("Completed series of tests\n");
X    exit(0);
X#endif
X    break;
X  case 2:     /* <megabytes|filename> */
X    i = (unsigned) abs(atoi(argv[1])); 
X    if (i) {
X      megabytes = i;
X    } else {
X      /*
X	'Auto mode' will be enabled if the first command line argument is
X	the word 'auto'.  This will trigger a series of tests
X	*/
X      if ( (strcmp(argv[1], "auto") == 0) ||
X	  (strcmp(argv[1], "AUTO") == 0) )
X	{
X	  auto_mode = 1;
X	  auto_test();
X	  printf("Completed series of tests\n");
X	  exit(0);
X	} else {
X	  auto_mode = 0;
X	}
X      if ( (strcmp(argv[1], "help") == 0) ||
X	  (strcmp(argv[1], "HELP") == 0) )
X	{
X	  show_help();
X	  exit(0);
X	}
X      strcpy(filename,argv[1]);
X    }
X    break;
X  case 3:     /* <megabytes> <reclen|filename> */
X    megabytes = (unsigned) atoi(argv[1]);
X    if (atoi(argv[2])) {
X      reclen = atoi(argv[2]);
X    } else {
X      strcpy(filename,argv[2]);
X    }
X    break;
X  case 4:     /* <megabytes> <reclen> <filename> */
X    megabytes = (unsigned) atoi(argv[1]);
X    reclen = atoi(argv[2]);
X    strcpy(filename,argv[3]);
X    break;
X  default:
X    printf("IOZONE: bad usage\n");
X    printf(IOZONE_USAGE);
X    exit(1);
X    
X  }
X  if (!auto_mode)
X    {
X      printf("\tSend comments to:\tnorcott_bill@tandem.com\n\n");
X    }
X  filesize = (unsigned long) (1024L*1024L*megabytes);
X  numrecs =  filesize/(unsigned long) reclen;
X  if (reclen >  MAXBUFFERSIZE) {
X    printf("<Error: Maximum record length is %d bytes\n", MAXBUFFERSIZE);
X    exit(1);
X  }
X  if (reclen < MINBUFFERSIZE) {
X    printf("Error: Minimum record length is %d bytes\n", MINBUFFERSIZE);
X    exit(1);
X  }
X  if (!auto_mode)
X    {
X      printf("\tIOZONE writes a %ld Megabyte sequential file consisting of\n",
X	     megabytes);
X      printf("\t%ld records which are each %ld bytes in length.\n",
X	     numrecs, reclen);
X      printf("\tIt then reads the file.  It prints the bytes-per-second\n");
X      printf("\trate at which the computer can read and write files.\n\n");
X      printf("\nWriting the %ld Megabyte file, '%s'...", megabytes, filename);
X    }
X  
X#if defined (__TANDEM)
X  /*
X    Tandem's GUARDIAN preallocates file space based on primary- and secondary extents.
X    The last 2 parameters to open are the sizes of the primary- and secondary extents,
X    in blocks which are 2K bytes each.  After the primary extent is filled, GUARDIAN
X    allocates up to 15 additional extents, one at a time.
X    */
X#define SPECIAL_CREAT
X#define PRI_EXT_BLOCKS 1024
X#define SEC_EXT_BLOCKS 1024
X  if((fd = creat(filename, 0640,
X		 PRI_EXT_BLOCKS, SEC_EXT_BLOCKS))<0){
X    printf("Cannot create temporary file: %s\n", filename);
X    exit(1);
X  }
X#endif
X#ifndef SPECIAL_CREAT
X  if((fd = creat(filename, 0640))<0){
X    printf("Cannot create temporary file: %s\n", filename);
X    exit(1);
X  }
X#endif
X#ifdef TIME
X  starttime = time_so_far();
X#endif
X#ifndef TIME
X  printf("\nstart timing\n");
X#endif
X  for(thisrec=0; thisrec<numrecs; thisrec++){
X#ifndef DEBUG_ME
X    if(write(fd, buffer, (unsigned) reclen) != reclen)
X      {
X	printf("Error writing block %d\n", thisrec);
X	perror("iozone");
X	close(fd);
X#ifndef VMS
X#ifndef NO_DELETE
X	unlink(filename);   /* delete the file */
X#endif
X	/*stop timer*/
X#endif
X	exit(1);
X      }
X#endif
X  }
X#ifdef USE_FSYNC
X  fsync(fd);
X#endif
X#ifdef TIME
X  writetime = time_so_far() - starttime;
X  if (!auto_mode)
X    {
X      printf("%f seconds", writetime);
X    }
X#endif
X#ifndef TIME
X  printf("\nstop timing\n");
X#endif
X  close(fd);
X#if defined (VMS)
X#define SPECIAL_OPEN_READ
X  if((fd = open(filename, O_RDONLY, 0640))<0){
X    printf("Cannot open temporary file for read\n");
X    exit(1);
X  }
X#endif
X  
X#ifdef MSDOS
X#define SPECIAL_OPEN_READ
X  if((fd = open(filename, O_RDONLY, 0640))<0){
X    printf("Cannot open temporary file for read\n");
X    exit(1);
X  }
X#endif
X  
X  /*
X    'Generic' case, compiled if no operating system-specific case was invoked
X    */
X#ifndef SPECIAL_OPEN_READ
X  if((fd = open(filename, O_RDONLY))<0){
X    printf("Cannot open temporary file for read\n");
X    exit(1);
X  }
X#endif
X  
X  
X  
X  /*start timing*/
X  if (!auto_mode)
X    {
X      printf("\nReading the file...");
X    }
X#ifndef TIME
X  printf("\nstart timing\n");
X#endif
X#ifdef TIME
X  starttime = time_so_far();
X#endif
X  for(thisrec=0; thisrec<numrecs; thisrec++) {
X#ifndef DEBUG_ME
X    if(read(fd, buffer, (unsigned) reclen) != reclen)
X      {
X	printf("Error reading block %d\n", thisrec);
X	exit(1);
X      }
X#endif
X  }
X#ifndef TIME
X  printf("\nstop timing\n");
X#endif
X#ifdef TIME
X  readtime = time_so_far() - starttime;
X  if (!auto_mode)
X    {
X      printf("%f seconds\n", readtime);
X    }
X#ifdef DEBUG_ME
X  readtime = 1;
X  writetime = 1;
X#endif
X  if(readtime!=0)
X    {
X      filebytes = numrecs* (unsigned long) reclen;
X      readrate = (unsigned long) ((double) filebytes / readtime);
X      writerate = (unsigned long) ((double) filebytes / writetime);
X      if (auto_mode)
X	{
X	  printf(CONTROL_STRING1,
X		 megabytes,
X		 reclen,
X		 writerate,
X		 readrate);
X	  
X	} else {
X	  printf("\nIOZONE performance measurements:\n");
X	  printf("\t%ld bytes/second for writing the file\n", writerate);
X	  printf("\t%ld bytes/second for reading the file\n", readrate);
X	  totaltime = readtime + writetime;
X	  if (totaltime < TOOFAST)
X	    {
X	      goodmegs = (TOOFAST/totaltime)*2*megabytes;
X	      printf("\nThe test completed too quickly to give a good result\n");
X	      printf("You will get a more precise measure of this machine's\n");
X	      printf("performance by re-running IOZONE using the command:\n");
X	      printf("\n\tiozone %ld ", goodmegs);
X	      printf("\t(i.e., file size = %ld megabytes)\n", goodmegs);
X	    }
X	}
X    } else {
X      goodrecl = reclen/2;
X      printf("\nI/O error during read.  Try again with the command:\n");
X      printf("\n\tiozone %ld %ld ", megabytes,  goodrecl);
X      printf("\t(i.e. record size = %ld bytes)\n",  goodrecl);
X    }
X#endif
X  close(fd);
X#ifndef VMS
X#ifndef NO_DELETE
X  unlink(filename);   /* delete the file */
X#endif
X  /*stop timer*/
X#endif
X#ifdef  usecalloc
X  free(buffer);           /* deallocate the memory */
X#endif
X#ifdef VMS
X  return SS$_NORMAL;
X#else
X  return 0;
X#endif
X}
X/******************************************************************
X  
X  SHOW_HELP -- show development help of this program
X  
X  ******************************************************************/
Xvoid 
X  show_help()
X{
X  int i;
X  printf("IOZONE: help mode\n\n");
X  for(i=0; strlen(help[i]); i++)
X    {
X      printf("%s\n", help[i]);
X    }
X}
X/******************************************************************
X  
X  SIGNAL_HANDLER -- clean up if user interrupts the program
X  
X  ******************************************************************/
Xvoid 
X  signal_handler()
X{
X  printf("\nIOZONE: interrupted\n\n");
X#ifndef VMS
X#ifndef NO_DELETE
X  printf("deleting file: %s\n", filename);
X  unlink(filename);   /* delete the file */
X#endif
X#endif
X  printf("exiting IOzone\n\n");
X  exit(0);
X}
X/******************************************************************
X  
X  AUTO_TEST -- perform series of tests and tabulate results
X  
X  ******************************************************************/
Xvoid 
X  auto_test()
X{
X  
X  int megsi, recszi;
X  char megs[10];
X  char recsz[10];
X  int i,j;
X  int autoArgc = 3;
X  char *autoArgv[3];
X  
X  printf("IOZONE: auto-test mode\n\n");
X  printf(CONTROL_STRING2,
X	 "MB",
X	 "reclen",
X	 "bytes/sec written",
X	 "bytes/sec read");
X  autoArgv[0] = "IOzone auto-test";
X  autoArgv[1] = megs;
X  autoArgv[2] = recsz;
X  /*
X    Start with file size of 1 megabyte and repeat the test MEGABYTES_ITER_LIMIT
X    times.  Each time we run, the file size is doubled
X    */
X  for(i=0,megsi=1;i<MEGABYTES_ITER_LIMIT;i++,megsi*=2)
X    {
X      sprintf(megs, "%d", megsi);
X      /*
X	Start with record size of 512 bytes and repeat the test RECLEN_ITER_LIMIT
X	times.  Each time we run, the record size is doubled
X	*/
X      for (j=0,recszi=512;j<RECLEN_ITER_LIMIT;j++,recszi*=2)
X        {
X	  sprintf(recsz, "%d", recszi);
X#ifdef ANSI_MAIN
X	  main(autoArgc, autoArgv, NULL);
X#else
X	  main(autoArgc, autoArgv);
X#endif
X        }
X    }
X}
X
X#ifdef TIME
X/******************************************************************
X  
X  TIME_SO_FAR -- return elapsed time
X
X  5/17/91 Bill Norcott        V1.07 -- use time() for VMS
X  The times() function in VMS returns proc & user CPU time in 10-millisecond
X  ticks.  Instead, use time() which lacks the precision but gives clock
X  time in seconds.
X  V1.14 make val of type clock_t if we are dealing with POSIX
X  V1.15 first time this is called, set base to initial number of clock
X  ticks, then subtract this value from all subsequent calculations.  This
X  will fix a loss of precision when times returns very big numbers;
X  
X  Here is what we check for (in order).  Each returns so we do not
X  have to nest the #ifdefs -- should satisfy even the dumbest 
X  pre-processor.  Note that each has its own flavor of timekeeping
X  1. ANSI C
X  2. POSIX - with and without CLK_TCK defined
X  3. System V variants
X  4. MS-DOS
X  5. BSD variants
X  ******************************************************************/
Xdouble
X  time_so_far()
X{
X#if defined(ANSItime)
X  return (double) time(NULL);
X#endif
X
X#ifdef isposix
X  {
X    static clock_t base, val;
X    struct tms tms;
X    
X    if (base == 0)
X      {
X	base = times(&tms);
X	if (base == (clock_t) -1)
X	  {
X	    perror("times");
X	  }
X      }
X    val = times(&tms);
X    if (val == (clock_t) -1)
X      {
X	perror("times");
X      }
X    val = val - base;
X#ifndef CLK_TCK
X    return ((double) val) / ((double) sysconf(_SC_CLK_TCK));
X#else
X    return ((double) val) / ((double) CLK_TCK);
X#endif
X  }
X#endif
X
X#ifdef SysVtime
X  {
X    static long base, val;
X    struct tms tms;
X    
X    if (base == 0)
X      {
X	if ((base = times(&tms)) == -1)
X	  {
X	    perror("times");
X	  }
X      }
X    if ((val = times(&tms)) == -1)
X      {
X	perror("times");
X      }
X    val = val - base;
X    return ((double) val) / ((double) CLK_TCK);
X  }
X#endif
X
X#if defined(MSDOS)
X  return ((double) clock()) / ((double) CLK_TCK);
X#endif
X
X#ifdef BSDtime
X  {
X    struct timeval tp;
X    
X    if (gettimeofday(&tp, (struct timezone *) NULL) == -1)
X      perror("gettimeofday");
X    return ((double) (tp.tv_sec)) +
X      (((double) tp.tv_usec) / 1000000.0);
X  }
X#endif
X}
X#endif
________This_Is_The_END________
if test `wc -l < iozone.c` -ne 1114 ; then
	echo 'shar: iozone.c was damaged during transit (should have been 1114  bytes)'
fi
fi		; : end of overwriting check
exit 0

-- 
---------------------------------------------------------------------|
Bill Norcott			GUARDIAN POSIX project
Tandem Computers, Inc.		
10600 N. Tantau Avenue		PHONE:  (408) 285-3253
Cupertino, CA   95014			EMAIL: norcott_bill@tandem.com



exit 0 # Just in case...
