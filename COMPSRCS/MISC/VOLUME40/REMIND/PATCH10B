Newsgroups: comp.sources.misc
From: dfs@doe.carleton.ca (David F. Skoll)
Subject: v40i049:  remind - A replacement for calendar, Patch10b/3
Message-ID: <1993Oct25.224730.7485@sparky.sterling.com>
X-Md4-Signature: eb4eb85d1bdfe58f6958c3186c97b865
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Dept. of Electronics, Carleton University
Date: Mon, 25 Oct 1993 22:47:30 GMT
Approved: kent@sparky.sterling.com

Submitted-by: dfs@doe.carleton.ca (David F. Skoll)
Posting-number: Volume 40, Issue 49
Archive-name: remind/patch10b
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lnk.bcc makefile.bcc patch.10.A patch.10.C test-rem.bat
#   test-rem.cmd
# Wrapped by kent@sparky on Mon Oct 25 17:25:43 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'lnk.bcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lnk.bcc'\"
else
  echo shar: Extracting \"'lnk.bcc'\" \(205 characters\)
  sed "s/^X//" >'lnk.bcc' <<'END_OF_FILE'
Xcalendar.obj
Xdorem.obj
Xdosubst.obj
Xexpr.obj
Xfiles.obj
Xfuncs.obj
Xglobals.obj
Xhbcal.obj
Xinit.obj
Xmain.obj
Xmoon.obj
Xomit.obj
Xos2func.obj
Xqueue.obj
Xsort.obj
Xtoken.obj
Xtrigger.obj
Xuserfns.obj
Xutils.obj
Xvar.obj
END_OF_FILE
  if test 205 -ne `wc -c <'lnk.bcc'`; then
    echo shar: \"'lnk.bcc'\" unpacked with wrong size!
  fi
  # end of 'lnk.bcc'
fi
if test -f 'makefile.bcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.bcc'\"
else
  echo shar: Extracting \"'makefile.bcc'\" \(2567 characters\)
  sed "s/^X//" >'makefile.bcc' <<'END_OF_FILE'
X# Makefile for REMIND for Borland C++
X
XVERSION= 03.00.10
X
XMODEL=l
X
X!if $d(__OS2__)
XCFLAGS= -DOS2 -w-pia -O2
XBINDIR= ..\OS2-EX
XDELFLAG= /f
X!else
XCFLAGS= -w-pia -O2 -m$(MODEL)
XBINDIR= ..\MSDOS-EX
XDELFLAG=
X!endif
X
XHDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
Xlang.h english.h german.h dutch.h finnish.h french.h norwgian.h
X
XSTDHDRS= config.h types.h protos.h globals.h err.h lang.h
X
XLANGHDRS= english.h german.h dutch.h finnish.h french.h norwgian.h
X
XSRCS= calendar.c dorem.c dosubst.c expr.c files.c funcs.c globals.c init.c \
Xmain.c omit.c sort.c token.c trigger.c userfns.c utils.c var.c hbcal.c \
Xqueue.c moon.c os2func.c
X
XOBJS=calendar.obj dorem.obj dosubst.obj expr.obj files.obj funcs.obj \
Xglobals.obj init.obj main.obj omit.obj sort.obj token.obj trigger.obj \
Xutils.obj userfns.obj var.obj hbcal.obj queue.obj moon.obj os2func.obj
X
XMANIFEST= readme.uni readme.dos copyrigh $(HDRS) $(SRCS) makefile rem rem.1 \
Xremind.1 remind-a.csh remind-a.sh test.rem test-rem test.cmp makefile.tc \
Xmakefile.msc lnk.msc lnk.tc manifest.dos manifest.unx whatsnew.30 kall kall.1 \
Xtstlang.rem defs.rem readme.os2 makefile.os2 rem2ps.c rem2ps.h remind.def \
Xrem2ps.1 makefile.bcc lnk.bcc test-rem.cmd test2.cmp
X
Xall: exes test-rem.cmd test-rem.bat
X	test-rem
X
Xclean:
X	-del $(DELFLAG) *.obj
X	-del $(DELFLAG) $(BINDIR)\*.exe
X
Xexes: $(BINDIR)\remind.exe $(BINDIR)\rem2ps.exe
X
X..\os2-ex\remind.exe: $(OBJS)
X	bcc -e..\os2-ex\remind @lnk.bcc -lap;Toe
X
X..\msdos-ex\remind.exe: $(OBJS)
X	bcc -e..\msdos-ex\remind -m$(MODEL) @lnk.bcc
X
X..\os2-ex\rem2ps.exe: rem2ps.obj
X	bcc -e..\os2-ex\rem2ps rem2ps.obj -lap;Toe
X
X..\msdos-ex\rem2ps.exe: rem2ps.obj
X	bcc -e..\msdos-ex\rem2ps -m$(MODEL) rem2ps.obj
X
X.c.obj:
X	bcc $(CFLAGS) -c {$< }
X
Xrem2ps.obj: rem2ps.c rem2ps.h config.h lang.h
X
Xcalendar.obj: calendar.c $(STDHDRS) expr.h
X
Xdorem.obj: dorem.c $(STDHDRS) expr.h
X
Xdosubst.obj: dosubst.c $(STDHDRS) $(LANGHDRS)
X
Xexpr.obj: expr.c $(STDHDRS) expr.h
X
Xfiles.obj: files.c $(STDHDRS)
X
Xfuncs.obj: funcs.c $(STDHDRS) expr.h version.h
X
Xglobals.obj: globals.c config.h types.h globals.h err.h lang.h
X
Xinit.obj: init.c $(STDHDRS) expr.h version.h
X
Xmain.obj: main.c $(STDHDRS) expr.h
X
Xmoon.obj: moon.c $(STDHDRS) expr.h
X
Xomit.obj: omit.c $(STDHDRS)
X
Xos2func.obj: os2func.c $(STDHDRS)
X
Xqueue.obj: queue.c $(STDHDRS)
X
Xsort.obj: sort.c $(STDHDRS)
X
Xtoken.obj: token.c $(STDHDRS)
X
Xtrigger.obj: trigger.c $(STDHDRS) expr.h
X
Xuserfns.obj: userfns.c $(STDHDRS) expr.h
X
Xutils.obj: utils.c $(STDHDRS)
X
Xvar.obj: var.c $(STDHDRS) expr.h
X
Xremind.zoo: $(MANIFEST)
X	zoo aI remind.zoo < manifest.dos
X
END_OF_FILE
  if test 2567 -ne `wc -c <'makefile.bcc'`; then
    echo shar: \"'makefile.bcc'\" unpacked with wrong size!
  fi
  # end of 'makefile.bcc'
fi
if test -f 'patch.10.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.10.A'\"
else
  echo shar: Extracting \"'patch.10.A'\" \(558 characters\)
  sed "s/^X//" >'patch.10.A' <<'END_OF_FILE'
XThis is Official Patch 10 for Remind 3.0.  See WHATSNEW.30 for details
XPrereq: "03.00.09"
X*** ../prev/version.h	Tue Aug 31 13:22:25 1993
X--- ./version.h	Wed Oct 20 14:47:27 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.09"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.10"
END_OF_FILE
  if test 558 -ne `wc -c <'patch.10.A'`; then
    echo shar: \"'patch.10.A'\" unpacked with wrong size!
  elif test -f 'patch.10.B' && test -f 'patch.10.C'; then
    echo shar: Combining  \"'patch.10'\" \(95017 characters\)
    cat 'patch.10.A' 'patch.10.B' 'patch.10.C' > 'patch.10'
    if test 95017 -ne `wc -c <'patch.10'`; then
      echo shar: \"'patch.10'\" combined with wrong size!
    else
      rm patch.10.A patch.10.B patch.10.C
    fi
  fi
  # end of 'patch.10.A'
fi
if test -f 'patch.10.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.10.C'\"
else
  echo shar: Extracting \"'patch.10.C'\" \(50141 characters\)
  sed "s/^X//" >'patch.10.C' <<'END_OF_FILE'
X*** ../prev/makefile.os2	Mon Sep 20 15:00:08 1993
X--- ./makefile.os2	Tue Oct 12 16:28:52 1993
X***************
X*** 25,31 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.09
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finish.h french.h norwgian.h
X--- 25,31 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.10
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finish.h french.h norwgian.h
X***************
X*** 41,47 ****
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc MANIFEST.UNX MANIFEST.DOS WHATSNEW.30 kall kall.1 \
X  defs.rem README.OS2 makefile.os2 rem2ps.c rem2ps.h remind.def rem2ps.1 \
X! tstlang.rem
X  
X  OBJS= $(SRCS:.c=$O)
X  
X--- 41,49 ----
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc MANIFEST.UNX MANIFEST.DOS WHATSNEW.30 kall kall.1 \
X  defs.rem README.OS2 makefile.os2 rem2ps.c rem2ps.h remind.def rem2ps.1 \
X! tstlang.rem README.BCC lnk.bcc makefile.bcc os2func.c \
X! test-rem.bat test-rem.cmd test1.cmp test2.cmp
X! 
X  
X  OBJS= $(SRCS:.c=$O)
X  
X*** ../prev/makefile.tc	Thu Sep 30 15:50:25 1993
X--- ./makefile.tc	Tue Oct 12 16:28:35 1993
X***************
X*** 1,6 ****
X  # Makefile for REMIND for Turbo C for MSDOS
X  
X! VERSION= 03.00.09
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h french.h norwgian.h
X--- 1,7 ----
X  # Makefile for REMIND for Turbo C for MSDOS
X  
X! CC= tcc
X! VERSION= 03.00.10
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h french.h norwgian.h
X***************
X*** 20,37 ****
X  remind.1 remind-a.csh remind-a.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc manifest.dos manifest.unx whatsnew.30 kall kall.1 \
X  tstlang.rem defs.rem readme.os2 makefile.os2 rem2ps.c rem2ps.h remind.def \
X! rem2ps.1
X  
X  all: remind.exe rem2ps.exe
X  
X  remind.exe: $(OBJS)
X! 	tcc @lnk.tc
X  
X  rem2ps.exe: rem2ps.obj
X! 	tcc -erem2ps.exe rem2ps.obj
X  
X  .c.obj:
X! 	tcc -A -w-pia -c -O -mm {$< }
X  
X  rem2ps.obj: rem2ps.c rem2ps.h config.h lang.h
X  
X--- 21,40 ----
X  remind.1 remind-a.csh remind-a.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc manifest.dos manifest.unx whatsnew.30 kall kall.1 \
X  tstlang.rem defs.rem readme.os2 makefile.os2 rem2ps.c rem2ps.h remind.def \
X! rem2ps.1 README.BCC lnk.bcc makefile.bcc os2func.c \
X! test-rem.bat test-rem.cmd test1.cmp test2.cmp
X  
X+ 
X  all: remind.exe rem2ps.exe
X  
X  remind.exe: $(OBJS)
X! 	$(CC) @lnk.tc
X  
X  rem2ps.exe: rem2ps.obj
X! 	$(CC) -erem2ps.exe rem2ps.obj
X  
X  .c.obj:
X! 	$(CC) -w-pia -c -O -mm {$< }
X  
X  rem2ps.obj: rem2ps.c rem2ps.h config.h lang.h
X  
X*** ../prev/moon.c	Thu Sep 30 15:50:08 1993
X--- ./moon.c	Tue Oct 12 16:22:48 1993
X***************
X*** 274,288 ****
X  double *usek;
X  #endif
X  {
X-    int yy, mm, dd;
X     double k, t, t2, t3, nt1;
X  
X!    jyear(sdate, &yy, &mm, &dd);
X  
X!    k = (yy + ((mm - 1) * (1.0 / 12.0)) - 1900) * 12.3685;
X  
X     /* Time in Julian centuries from 1900 January 0.5 */
X!    t = (sdate - 2415020.0) / 36525;
X     t2 = t * t;		   /* Square for frequent use */
X     t3 = t2 * t;		   /* Cube for frequent use */
X  
X--- 274,291 ----
X  double *usek;
X  #endif
X  {
X     double k, t, t2, t3, nt1;
X  
X! /*** The following was the original code:  It gave roundoff errors
X!      causing moonphase info to fail for Dec 1994.  ***/
X! /*    jyear(sdate, &yy, &mm, &dd);
X!       k = (yy + (mm/12.0) - 1900) * 12.368531; */
X  
X! /*** The next line is the replacement ***/
X!    k = (sdate - 2415020.0) / synmonth;
X  
X     /* Time in Julian centuries from 1900 January 0.5 */
X!    t = (sdate - 2415020.0) / 36525.0;
X     t2 = t * t;		   /* Square for frequent use */
X     t3 = t2 * t;		   /* Cube for frequent use */
X  
X***************
X*** 316,322 ****
X     int apcor = 0;
X  
X     k += phase;		   /* Add phase to new moon time */
X!    t = k / 1236.85;	   /* Time in Julian centuries from
X     			      1900 January 0.5 */
X     t2 = t * t;		   /* Square for frequent use */
X     t3 = t2 * t;		   /* Cube for frequent use */
X--- 319,325 ----
X     int apcor = 0;
X  
X     k += phase;		   /* Add phase to new moon time */
X!    t = k / 1236.8531;	   /* Time in Julian centuries from
X     			      1900 January 0.5 */
X     t2 = t * t;		   /* Square for frequent use */
X     t3 = t2 * t;		   /* Cube for frequent use */
X***************
X*** 602,616 ****
X     int d1, t1;
X     double k1, k2, jd, jdorig;
X     double nt1, nt2;
X     /* Convert from local to UTC */
X     LocalToUTC(startdate, starttim, &utcd, &utct);
X  
X     /* Convert from Remind representation to year/mon/day */
X     FromJulian(utcd, &y, &m, &d);
X- 
X     /* Convert to a true Julian date -- sorry for the name clashes! */
X     jdorig = jtime(y, m, d, (utct / 60), (utct % 60), 0);   
X!    jd = jdorig - 45;
X     nt1 = meanphase(jd, 0.0, &k1);
X     while(1) {
X        jd += synmonth;
X--- 605,619 ----
X     int d1, t1;
X     double k1, k2, jd, jdorig;
X     double nt1, nt2;
X+ 
X     /* Convert from local to UTC */
X     LocalToUTC(startdate, starttim, &utcd, &utct);
X  
X     /* Convert from Remind representation to year/mon/day */
X     FromJulian(utcd, &y, &m, &d);
X     /* Convert to a true Julian date -- sorry for the name clashes! */
X     jdorig = jtime(y, m, d, (utct / 60), (utct % 60), 0);   
X!    jd = jdorig - 45.0;
X     nt1 = meanphase(jd, 0.0, &k1);
X     while(1) {
X        jd += synmonth;
X*** ../prev/omit.c	Thu Aug 19 16:16:33 1993
X--- ./omit.c	Tue Oct 12 16:22:49 1993
X***************
X*** 324,329 ****
X--- 324,330 ----
X  	 case T_Empty:
X  	 case T_Comment:
X  	 case T_RemType:
X+ 	 case T_Priority:
X  	    parsing = 0;
X  	    break;
X  
X***************
X*** 353,359 ****
X           NumFullOmits++;
X        }
X     }
X!    if (tok.type == T_RemType) return E_PARSE_AS_REM;
X     return OK;
X  
X  }
X--- 354,360 ----
X           NumFullOmits++;
X        }
X     }
X!    if (tok.type == T_RemType || tok.type == T_Priority) return E_PARSE_AS_REM;
X     return OK;
X  
X  }
X*** ../prev/protos.h	Mon Sep 20 16:53:13 1993
X--- ./protos.h	Wed Oct 20 11:54:30 1993
X***************
X*** 86,92 ****
X  int PopOmitContext ARGS ((ParsePtr p));
X  int IsOmitted ARGS ((int jul, int localomit));
X  int DoOmit ARGS ((ParsePtr p));
X! int QueueReminder ARGS ((ParsePtr p, int typ, TimeTrig *tim));
X  void HandleQueuedReminders ARGS ((void));
X  char *FindInitialToken ARGS ((Token *tok, char *s));
X  void FindToken ARGS ((const char *s, Token *tok));
X--- 86,92 ----
X  int PopOmitContext ARGS ((ParsePtr p));
X  int IsOmitted ARGS ((int jul, int localomit));
X  int DoOmit ARGS ((ParsePtr p));
X! int QueueReminder ARGS ((ParsePtr p, int typ, TimeTrig *tim, const char *sched));
X  void HandleQueuedReminders ARGS ((void));
X  char *FindInitialToken ARGS ((Token *tok, char *s));
X  void FindToken ARGS ((const char *s, Token *tok));
X***************
X*** 113,119 ****
X  unsigned int HashVal ARGS ((const char *str));
X  int DateOK ARGS ((int y, int m, int d));
X  Operator *FindFunc ARGS ((char *name, Operator where[], int num));
X! int InsertIntoSortBuffer ARGS ((int jul, int tim, char *body, int typ));
X  void IssueSortedReminders ARGS ((void));    
X  int UserFuncExists ARGS ((char *fn));
X  void JulToHeb ARGS((int jul, int *hy, int *hm, int *hd));
X--- 113,119 ----
X  unsigned int HashVal ARGS ((const char *str));
X  int DateOK ARGS ((int y, int m, int d));
X  Operator *FindFunc ARGS ((char *name, Operator where[], int num));
X! int InsertIntoSortBuffer ARGS ((int jul, int tim, char *body, int typ, int prio));
X  void IssueSortedReminders ARGS ((void));    
X  int UserFuncExists ARGS ((char *fn));
X  void JulToHeb ARGS((int jul, int *hy, int *hm, int *hd));
X***************
X*** 136,138 ****
X--- 136,148 ----
X  void UTCToLocal ARGS ((int utcdate, int utctime, int *locdate, int *loctime));
X  int MoonPhase ARGS ((int date, int time));
X  void HuntPhase ARGS ((int startdate, int starttim, int phas, int *date, int *time));
X+ int CompareRems ARGS ((int dat1, int tim1, int prio1, int dat2, int tim2, int prio2, int bydate, int bytime, int byprio));
X+ 
X+ #if defined(__OS2__)
X+ int fork ARGS ((void));
X+ void StartPopUp ARGS ((void));
X+ void EndPopUp ARGS ((void));
X+ int PutcPopUp ARGS ((int c));
X+ int PutlPopUp ARGS ((char *s));
X+ int PutsPopUp ARGS ((char *s));
X+ #endif
X*** ../prev/queue.c	Thu Aug 19 16:12:20 1993
X--- ./queue.c	Wed Oct 20 13:16:43 1993
X***************
X*** 22,31 ****
X--- 22,39 ----
X  #ifdef HAVE_UNISTD
X  #include <unistd.h>
X  #endif
X+ 
X+ #ifdef __BORLANDC__
X+ #include <io.h>
X+ #include <dos.h>
X+ #include <process.h>
X+ #endif
X+ 
X  #include "globals.h"
X  #include "err.h"
X  #include "types.h"
X  #include "protos.h"
X+ #include "expr.h"
X  
X  /* List structure for holding queued reminders */
X  typedef struct queuedrem {
X***************
X*** 32,38 ****
X--- 40,48 ----
X     struct queuedrem *next;
X     int typ;
X     int RunDisabled;
X+    int ntrig;
X     char *text;
X+    char sched[VAR_NAME_LEN+1];
X     TimeTrig tt;
X  } QueuedRem;
X  
X***************
X*** 45,51 ****
X--- 55,67 ----
X  PRIVATE void CheckInitialFile ARGS ((void));
X  PRIVATE int CalculateNextTime ARGS ((QueuedRem *q));
X  PRIVATE QueuedRem *FindNextReminder ARGS ((void));
X+ PRIVATE int CalculateNextTimeUsingSched ARGS ((QueuedRem *q));
X+ 
X+ #ifdef __OS2__
X+ void (__cdecl SigIntHandler(int));
X+ #else
X  PRIVATE void SigIntHandler ARGS ((void));
X+ #endif
X  
X  /***************************************************************/
X  /*                                                             */
X***************
X*** 56,67 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int QueueReminder(ParsePtr p, int typ, TimeTrig *tim)
X  #else
X! int QueueReminder(p, typ, tim)
X  ParsePtr p;
X  int typ;
X  TimeTrig *tim;
X  #endif
X  {
X     QueuedRem *qelem;
X--- 72,84 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int QueueReminder(ParsePtr p, int typ, TimeTrig *tim, const char *sched)
X  #else
X! int QueueReminder(p, typ, tim, sched)
X  ParsePtr p;
X  int typ;
X  TimeTrig *tim;
X+ char *sched;
X  #endif
X  {
X     QueuedRem *qelem;
X***************
X*** 85,90 ****
X--- 102,109 ----
X     qelem->tt = *tim;
X     qelem->next = QueueHead;
X     qelem->RunDisabled = RunDisabled;
X+    qelem->ntrig = 0;
X+    strcpy(qelem->sched, sched);
X     QueueHead = qelem;
X     NumQueued++;
X     return OK;
X***************
X*** 191,196 ****
X--- 210,218 ----
X  /*                                                             */
X  /*  Calculate the next time when a reminder should be issued.  */
X  /*  Return NO_TIME if reminder expired.                        */
X+ /*  Strategy is:  If a sched() function is defined, call it.   */
X+ /*  Otherwise, use AT time with delta and rep.  If sched()     */
X+ /*  fails, revert to AT with delta and rep.                    */
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X***************
X*** 204,210 ****
X--- 226,239 ----
X     int rep = q->tt.rep;
X     int delta = q->tt.delta;
X     int curtime = q->tt.nexttime+1;
X+    int r;
X  
X+ /* Increment number of times this one has been triggered */
X+    q->ntrig++;
X+    if (q->sched[0]) {
X+       r = CalculateNextTimeUsingSched(q);
X+       if (r != NO_TIME) return r;
X+    }
X     if (delta == NO_DELTA)
X        if (tim < curtime) return NO_TIME; else return tim;
X  
X***************
X*** 253,263 ****
X--- 282,296 ----
X  /* command-line flag is supplied.                              */
X  /*                                                             */
X  /***************************************************************/
X+ #ifdef __OS2__
X+ void __cdecl SigIntHandler(int d)
X+ #else
X  #ifdef HAVE_PROTOS
X  PRIVATE void SigIntHandler(void)
X  #else
X  static void SigIntHandler()
X  #endif
X+ #endif
X  {
X     QueuedRem *q = QueueHead;
X  
X***************
X*** 269,278 ****
X  
X     while (q) {
X        if (q->tt.nexttime != NO_TIME) {
X!          printf("Trigger: %02d%c%02d  Activate: %02d%c%02d  Rep: %d  Delta: %d%s",
X                   q->tt.ttime / 60, TIMESEP, q->tt.ttime % 60,
X                   q->tt.nexttime / 60, TIMESEP, q->tt.nexttime % 60,
X!                  q->tt.rep, q->tt.delta, NL);
X                   printf("Text: %s %s%s%s", ((q->typ == MSG_TYPE) ? "MSG" :
X  		                           ((q->typ == MSF_TYPE) ? "MSF" :"RUN")),
X                   q->text,
X--- 302,311 ----
X  
X     while (q) {
X        if (q->tt.nexttime != NO_TIME) {
X!          printf("Trigger: %02d%c%02d  Activate: %02d%c%02d  Rep: %d  Delta: %d  Sched: %s%s",
X                   q->tt.ttime / 60, TIMESEP, q->tt.ttime % 60,
X                   q->tt.nexttime / 60, TIMESEP, q->tt.nexttime % 60,
X!                  q->tt.rep, q->tt.delta, q->sched, NL);
X                   printf("Text: %s %s%s%s", ((q->typ == MSG_TYPE) ? "MSG" :
X  		                           ((q->typ == MSF_TYPE) ? "MSF" :"RUN")),
X                   q->text,
X***************
X*** 306,308 ****
X--- 339,401 ----
X            execvp(ArgV[0], ArgV);
X  }
X  
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  CalculateNextTimeUsingSched                                */
X+ /*                                                             */
X+ /*  Call the scheduling function.                              */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int CalculateNextTimeUsingSched(QueuedRem *q)
X+ #else
X+ static int CalculateNextTimeUsingSched(q)
X+ QueuedRem *q;
X+ #endif
X+ {
X+    /* Use LineBuffer for temp. string storage. */
X+    int r;
X+    Value v;
X+    char *s;
X+    int LastTime = -1;
X+    int ThisTime;
X+ 
X+    if (UserFuncExists(q->sched) != 1) {
X+       q->sched[0] = 0;
X+       return NO_TIME;
X+    }
X+ 
X+    RunDisabled = q->RunDisabled;  /* Don't want weird scheduling functions
X+ 				     to be a security hole!                */
X+    while(1) {
X+       sprintf(LineBuffer, "%s(%d)", q->sched, q->ntrig);
X+       s = LineBuffer;
X+       r = EvalExpr(&s, &v);
X+       if (r) {
X+          q->sched[0] = 0;
X+          return NO_TIME;
X+       }
X+       if (v.type == TIM_TYPE) {
X+          ThisTime = v.v.val;
X+       } else if (v.type == INT_TYPE) {
X+          if (v.v.val > 0) 
X+ 	    ThisTime = q->tt.nexttime + v.v.val;
X+          else
X+ 	    ThisTime = q->tt.ttime + v.v.val;
X+ 
X+       } else {
X+          DestroyValue(&v);
X+ 	 q->sched[0] = 0;
X+ 	 return NO_TIME;
X+       }
X+       if (ThisTime < 0) ThisTime = 0;        /* Can't be less than 00:00 */
X+       if (ThisTime > 1439) ThisTime = 1439;  /* or greater than 11:59 */
X+       if (ThisTime > q->tt.nexttime) return ThisTime;
X+       if (ThisTime <= LastTime) {
X+          q->sched[0] = 0;
X+ 	 return NO_TIME;
X+       }
X+       LastTime = ThisTime;
X+       q->ntrig++;
X+    }
X+ }
X*** ../prev/rem2ps.c	Tue Sep 28 12:33:59 1993
X--- ./rem2ps.c	Wed Oct 13 10:46:21 1993
X***************
X*** 24,29 ****
X--- 24,33 ----
X  #include <stdlib.h>
X  #endif
X  
X+ #ifdef __TURBOC__
X+ #include <io.h>
X+ #endif
X+ 
X  #ifdef HAVE_PROTOS
X  #define ARGS(x) x
X  #else
X***************
X*** 183,189 ****
X     int is_ps;
X     CalEntry *c, *d;
X  
X-    printf("%%%%Page: %d %d\n", validfile, validfile);
X  /* Read the month and year name, followed by # days in month and 1st day of
X     month, followed by the MondayFirst flag */
X     gets(LineBuffer);
X--- 187,192 ----
X***************
X*** 195,200 ****
X--- 198,206 ----
X     MaxDay = days;
X     FirstWkDay = wkday;
X  
X+    printf("%%%%Page: %c%c%c%c%c %d\n", month[0], month[1], month[2],
X+ 		     year[2], year[3], validfile);
X+ 
X  /* Emit PostScript to do the heading */
X     if (!PortraitMode) printf("XSIZE 0 translate 90 rotate\n");
X     printf("/SAVESTATE save def (%s) (%s) PreCal SAVESTATE restore\n", month, year);
X***************
X*** 255,262 ****
X        if (is_ps) {
X  /* Save the 'P' or 'F' flag */
X           *(c->entry) = *LineBuffer;
X! 	 c->next = PsEntries[DayNum];
X! 	 PsEntries[DayNum] = c;
X        } else {
X  /* Put on linked list */
X           if (!CurEntries) CurEntries = c;
X--- 261,272 ----
X        if (is_ps) {
X  /* Save the 'P' or 'F' flag */
X           *(c->entry) = *LineBuffer;
X!          if (!PsEntries[DayNum]) PsEntries[DayNum] = c;
X! 	 else {
X! 	    d = PsEntries[DayNum];
X! 	    while(d->next) d = d->next;
X! 	    d->next = c;
X!          }
X        } else {
X  /* Put on linked list */
X           if (!CurEntries) CurEntries = c;
X*** ../prev/remind.1	Thu Sep 30 15:25:03 1993
X--- ./remind.1	Wed Oct 20 13:27:12 1993
X***************
X*** 1,4 ****
X! .TH REMIND 1 "30 September 1993"
X  .UC 4
X  .SH NAME
X  remind \- a sophisticated reminder service
X--- 1,4 ----
X! .TH REMIND 1 "13 October 1993"
X  .UC 4
X  .SH NAME
X  remind \- a sophisticated reminder service
X***************
X*** 119,130 ****
X  Echo lines when displaying error messages
X  .RE
X  .TP
X! \fB\-g\fR[\fBa|d\fR[\fBa|d\fR]]
X  Normally, reminders are issued in the order in which they are encountered
X  in the reminder script.  The \fB\-g\fR option cause \fBRemind\fR to
X  sort reminders by date and time prior to issuing them.  The optional
X  \fBa\fR and \fBd\fR characters specify the sort order (ascending or
X! descending) for the date and time fields.  See the section "Sorting
X  Reminders" for more information.
X  .TP
X  \fB\-b\fR[\fIn\fR]
X--- 119,130 ----
X  Echo lines when displaying error messages
X  .RE
X  .TP
X! \fB\-g\fR[\fBa|d\fR[\fBa|d\fR[\fBa|d\fR]]]
X  Normally, reminders are issued in the order in which they are encountered
X  in the reminder script.  The \fB\-g\fR option cause \fBRemind\fR to
X  sort reminders by date and time prior to issuing them.  The optional
X  \fBa\fR and \fBd\fR characters specify the sort order (ascending or
X! descending) for the date, time and priority fields.  See the section "Sorting
X  Reminders" for more information.
X  .TP
X  \fB\-b\fR[\fIn\fR]
X***************
X*** 257,265 ****
X--- 257,267 ----
X  [\fIback\fR]
X  [\fIdelta\fR]
X  [\fIrepeat\fR]
X+ [\fBPRIORITY\fR \fIprio\fR]
X  [\fBSKIP\fR | \fBBEFORE\fR | \fBAFTER\fR]
X  [\fBOMIT\fR \fIomit_list\fR]
X  [\fBAT\fR \fItime\fR [\fItdelta\fR] [\fItrepeat\fR]]
X+ [\fBSCHED\fR \fIsched_function\fR]
X  [\fBUNTIL\fR \fIexpiry_date\fR]
X  [\fBSCANFROM\fR \fIscan_date\fR]
X  \fBMSG\fR | \fBMSF\fR | \fBRUN\fR | \fBCAL\fR | \fBSATISFY\fR |
X***************
X*** 602,607 ****
X--- 604,617 ----
X  near the end of this manual.  Note that \fBSCANFROM\fR is available only
X  in versions of \fBRemind\fR from 03.00.04 up.
X  .PP
X+ .B PRIORITY
X+ .PP
X+ The \fBPRIORITY\fR keyword must be followed by a number from 0 to 9999.
X+ It is used in calendar mode and when sorting reminders.  If two reminders
X+ have the same trigger date and time, then they are sorted by priority.
X+ If the \fBPRIORITY\fR keyword is not supplied, a default priority of 5000
X+ is used.
X+ .PP
X  .B EXPIRY DATES
X  .PP
X  Some reminders should be issued periodically for a certain time, but then
X***************
X*** 767,772 ****
X--- 777,789 ----
X  \fInot\fR necessarily be those which were in effect at the time the reminder
X  was queued.
X  .PP
X+ .B THE SCHED KEYWORD
X+ .PP
X+ The \fBSCHED\fR keyword allows more precise control over the triggering
X+ of timed reminders.  However, discussion must be deferred until after
X+ expressions and user-defined functions are explained.  See the subsection
X+ "Precise Scheduling" further on.
X+ .PP
X  .SH THE SUBSTITUTION FILTER
X  .PP
X  Before being processed, the body of a
X***************
X*** 1503,1512 ****
X  .TP
X  .B $CalcUTC 
X  If 1 (the default), then \fBRemind\fR uses C library functions
X! to calculate the number of minutes between local and universal time.
X  This affects astronomical calculations (\fBsunrise()\fR for example.)
X  If 0, then you must supply the number of minutes between local and
X! universal time in the \fB$MinsFromUTC\fR system variable.
X  .TP
X  .B $CalMode (read-only)
X  If non-zero, then the \fB\-c\fR option was supplied on the command line.
X--- 1520,1530 ----
X  .TP
X  .B $CalcUTC 
X  If 1 (the default), then \fBRemind\fR uses C library functions
X! to calculate the number of minutes between local and Universal Time
X! Coordinated.
X  This affects astronomical calculations (\fBsunrise()\fR for example.)
X  If 0, then you must supply the number of minutes between local and
X! Universal Time Coordinated in the \fB$MinsFromUTC\fR system variable.
X  .TP
X  .B $CalMode (read-only)
X  If non-zero, then the \fB\-c\fR option was supplied on the command line.
X***************
X*** 1613,1619 ****
X  (described later.)  Must be at least 10.
X  .TP
X  .B $MinsFromUTC
X! The number of minutes between Universal Time and local time.  If
X  \fB$CalcUTC\fR is non-zero, this is calculated upon startup of \fBRemind\fR.
X  Otherwise, you must set it explicitly.  If \fB$CalcUTC\fR is zero,
X  then \fB$MinsFromUTC\fR is used in the astronomical calculations.  You
X--- 1631,1637 ----
X  (described later.)  Must be at least 10.
X  .TP
X  .B $MinsFromUTC
X! The number of minutes between Universal Time Coordinated and local time.  If
X  \fB$CalcUTC\fR is non-zero, this is calculated upon startup of \fBRemind\fR.
X  Otherwise, you must set it explicitly.  If \fB$CalcUTC\fR is zero,
X  then \fB$MinsFromUTC\fR is used in the astronomical calculations.  You
X***************
X*** 1656,1661 ****
X--- 1674,1691 ----
X  Set to a non-zero value if \fIeither\fR of the \fB\-p\fR or \fB\-s\fR
X  command-line options was supplied.
X  .TP
X+ .B $SortByDate (read-only)
X+ Set to 0 if no \fB\-g\fR option is used, 1 if sorting by date in ascending
X+ order, or 2 if sorting by date in descending order.
X+ .TP
X+ .B $SortByPrio (read-only)
X+ Set to 0 if no \fB\-g\fR option is used, 1 if sorting by priority in ascending
X+ order, or 2 if sorting by priority in descending order.
X+ .TP
X+ .B $SortByTime (read-only)
X+ Set to 0 if no \fB\-g\fR option is used, 1 if sorting by time in ascending
X+ order, or 2 if sorting by time in descending order.
X+ .TP
X  .B $SubsIndent
X  The number of spaces by which all lines (except the first) of an
X  \fBMSF\fR-type reminder should be indented.  The default is 0.
X***************
X*** 1935,1944 ****
X  as with the < operator.
X  .TP
X  .B minsfromutc([d_date [,t_time]])
X! Returns the number of minutes from Universal Time (formerly GMT) to
X  local time on the specified date and time.  \fIDate\fR defaults to
X  \fBtoday()\fR and \fItime\fR defaults to midnight.  If local time
X! is before UT, the result is negative.  Otherwise, the result is
X  positive.
X  .RS
X  .PP
X--- 1965,1975 ----
X  as with the < operator.
X  .TP
X  .B minsfromutc([d_date [,t_time]])
X! Returns the number of minutes from Universal Time Coordinated 
X! (formerly GMT) to
X  local time on the specified date and time.  \fIDate\fR defaults to
X  \fBtoday()\fR and \fItime\fR defaults to midnight.  If local time
X! is before UTC, the result is negative.  Otherwise, the result is
X  positive.
X  .RS
X  .PP
X***************
X*** 1982,1989 ****
X  quarter, 2 full moon, and 3 third quarter.  If \fIdate\fR is omitted,
X  it defaults to \fBtoday()\fR.  If \fItime\fR is omitted, it defaults
X  to midnight.  \fBMoontime()\fR is intended to be used in conjunction
X! with \fBmoondate()\fR.  Don't take the time too seriously - it's only
X! accurate to within 15-20 minutes.
X  .RS
X  .PP
X  For example, the following returns the date and time of the next full moon:
X--- 2013,2021 ----
X  quarter, 2 full moon, and 3 third quarter.  If \fIdate\fR is omitted,
X  it defaults to \fBtoday()\fR.  If \fItime\fR is omitted, it defaults
X  to midnight.  \fBMoontime()\fR is intended to be used in conjunction
X! with \fBmoondate()\fR.  The \fBmoondate()\fR and \fBmoontime()\fR
X! functions are accurate to within a couple of minutes of the
X! times in "Old Farmer's Almanac" for Ottawa, Ontario.
X  .RS
X  .PP
X  For example, the following returns the date and time of the next full moon:
X***************
X*** 2122,2131 ****
X  or \fBIFTRIG\fR command.  If used
X  in the \fIbody\fR of a \fBREM\fR command, returns that command's trigger date.
X  .TP
X! .B trigger(d_date)
X  Returns a string suitable for use in a \fBREM\fR command, allowing you to
X! calculate trigger dates in advance.  See the section "Expression pasting"
X! for more information.
X  .TP
X  .B trigtime()
X  Returns the time of the last \fBREM\fR command with an \fBAT\fR clause.
X--- 2154,2181 ----
X  or \fBIFTRIG\fR command.  If used
X  in the \fIbody\fR of a \fBREM\fR command, returns that command's trigger date.
X  .TP
X! .B trigger(d_date [,t_time [,i_utcflag]])
X  Returns a string suitable for use in a \fBREM\fR command, allowing you to
X! calculate trigger dates in advance.  (See the section "Expression pasting"
X! for more information.)  Normally, the \fIdate\fR and \fItime\fR are
X! the local date and time; however, if \fIutcflag\fR is non-zero, the
X! \fIdate\fR and \fItime\fR are interpreted as UTC times, and are
X! converted to local time.  Examples:
X! .RS
X! .PP
X! trigger('1993/04/01')
X! .PP
X! returns "1 April 1993",
X! .PP
X! trigger('1994/08/09', 12:33)
X! .PP
X! returns "9 August 1994 AT 12:33", and
X! .PP
X! trigger('1994/12/01', 03:00, 1)
X! .PP
X! returns "30 November 1994 AT 22:00" for EST, which is 5 hours behind UTC.
X! The value for your time zone may differ.
X! .RE
X  .TP
X  .B trigtime()
X  Returns the time of the last \fBREM\fR command with an \fBAT\fR clause.
X***************
X*** 2410,2415 ****
X--- 2460,2533 ----
X  functions), you may wish to name all user-defined functions beginning
X  with an underscore.
X  .PP
X+ .SH PRECISE SCHEDULING
X+ .PP
X+ The \fBSCHED\fR keyword allows precise control over the scheduling of timed
X+ reminders.  It should be followed by the name of a user-defined function,
X+ \fIsched_function\fR.
X+ .PP
X+ If a scheduling function is supplied, then it must take one argument of
X+ type \fBINT\fR.  Rather than using the \fBAT\fR time, time \fIdelta\fR, and
X+ time \fIrepeat\fR, \fBRemind\fR calls the scheduling function to determine
X+ when to trigger the reminder.  The first time the reminder is queued, the
X+ scheduling function is called with an argument of 1.  Each time the reminder
X+ is triggered, it is re-scheduled by calling the scheduling function again.
X+ On each call, the argument is incremented by one.
X+ .PP
X+ The return value of the scheduling function must be an \fBINT\fR or a
X+ \fBTIME\fR.  If the return value is a \fBTIME\fR, then the reminder is
X+ re-queued to trigger at that time.  If it is a positive integer \fIn\fR,
X+ then the reminder is re-queued to trigger at the previous trigger time
X+ plus \fIn\fR minutes.  Finally, if it is a negative integer or zero, then
X+ the reminder is re-queued to trigger \fIn\fR minutes before the \fBAT\fR
X+ time.  Note that there must be an \fBAT\fR clause for the \fBSCHED\fR
X+ clause to do anything.
X+ .PP
X+ Here's an example:
X+ .PP
X+ .nf
X+ 	FSET _sfun(x) choose(x, -60, 30, 15, 10, 3, 1, 1, 1, 1, 0)
X+ 	REM AT 13:00 SCHED _sfun MSG foo
X+ .fi
X+ .PP
X+ The reminder would first be triggered at 13:00-60 minutes, or at 12:00.
X+ It would next be triggered 30 minutes later, at 12:30.  Then, it would
X+ be triggered at 12:45, 12:55, 12:58, 12:59, 13:00, 13:01 and 13:02.
X+ .PP
X+ .B NOTES
X+ .TP
X+ 1
X+ If an error occurs during the evaluation of \fIsched_func\fR, then
X+ \fBRemind\fR reverts to using the \fBAT\fR time and the \fIdelta\fR
X+ and \fIrepeat\fR values, and never calls \fIsched_func\fR again.
X+ .TP
X+ 2
X+ If processing \fIsched_func\fR yields a time earlier than the current
X+ system time, it is repeatedly called with increasing argument until it
X+ yields a value greater than or equal to the current time.  However, if
X+ the sequence of values calculated during the repetition is not strictly
X+ increasing, then \fBRemind\fR reverts to the default behaviour and
X+ never calls \fIsched_func\fR again.
X+ .TP
X+ 3
X+ It is quite possible using \fIsched_func\fR to keep triggering a reminder
X+ even after the \fBAT\fR-time.  However, it is not possible to reschedule
X+ a reminder past midnight \- no crossing of date boundaries is allowed.
X+ Also, it is quite possible to \fBnot\fR trigger a reminder on the \fBAT\fR
X+ time when you use a scheduling function.  However, if your scheduling
X+ function is terminated (for reasons 1 and 2) before the \fBAT\fR time of
X+ the reminder, it \fIwill\fR be triggered at the \fBAT\fR time, because
X+ normal processing takes over.
X+ .TP
X+ 4
X+ Your scheduling functions should (as a matter of good style) return
X+ 0 when no more scheduling is required.  See the example.
X+ .TP
X+ 5
X+ All scheduling functions are evaluated \fIafter\fR the entire Remind
X+ script has been read in.  So whatever function definitions are in effect
X+ at the end of the script are used.
X+ .PP
X  .SH THE SATISFY CLAUSE
X  .PP
X  The form of \fBREM\fR which uses \fBSATISFY\fR is as follows:
X***************
X*** 2699,2705 ****
X  Timed reminders are sorted and placed into the calendar in time order.
X  These are followed by non-timed reminders.  \fBRemind\fR automatically
X  places the time of timed reminders in the calendar according to the
X! \fB\-b\fR command-line option.
X  .PP
X  .B REPEATED EXECUTION
X  .PP
X--- 2817,2826 ----
X  Timed reminders are sorted and placed into the calendar in time order.
X  These are followed by non-timed reminders.  \fBRemind\fR automatically
X  places the time of timed reminders in the calendar according to the
X! \fB\-b\fR command-line option.  Reminders in calendar mode are sorted as
X! if the \fB\-g\fR option had been used; you can change the sort order
X! in calendar mode by explicitly using the \fB\-g\fR option to specify
X! a different order from the default.
X  .PP
X  .B REPEATED EXECUTION
X  .PP
X***************
X*** 2763,2770 ****
X  the PostScript output.
X  .PP
X  The PostScript-type reminders for a particular day are included in the
X! PostScript output in the same order they were triggered in the \fBRemind\fR
X! script file.  All of the PostScript code for a particular date is enclosed
X  in a \fBsave\fR-\fBrestore\fR pair.  However, if several PostScript-type
X  reminders are triggered for a single day, each section of PostScript is
X  not enclosed in a \fBsave\fR-\fBrestore\fR pair - instead, the entire
X--- 2884,2902 ----
X  the PostScript output.
X  .PP
X  The PostScript-type reminders for a particular day are included in the
X! PostScript output in sorted order of priority.  Note that the order
X! of PostScript commands has a \fImajor\fR impact on the appearance of the
X! calendars.  For example, PostScript code to shade a calendar box will
X! obliterate code to draw a moon symbol if the moon symbol code is placed
X! in the calendar first.  For this reason, you should not provide \fBPS\fR
X! or \fBPSFILE\fR-type reminders with priorities; instead, you should
X! ensure that they appear in the reminder script in the correct order.
X! PostScript code should draw objects working from the background to the
X! foreground, so that foreground objects properly overlay background ones.
X! If you prioritize these reminders and run the script using descending
X! sort order for priorities, the PostScript output will not work.
X! .PP
X! All of the PostScript code for a particular date is enclosed
X  in a \fBsave\fR-\fBrestore\fR pair.  However, if several PostScript-type
X  reminders are triggered for a single day, each section of PostScript is
X  not enclosed in a \fBsave\fR-\fBrestore\fR pair - instead, the entire
X***************
X*** 2855,2875 ****
X  .SH SORTING REMINDERS
X  .PP
X  The \fB\-g\fR option causes \fBRemind\fR to sort reminders by
X! trigger date and time before issuing them.  Note that reminders are
X  still calculated in the order encountered in the script.  However, rather
X  than being issued immediately, they are saved in an internal buffer.
X  When \fBRemind\fR has finished processing the script, it issues the
X  saved reminders in sorted order.  The \fB\-g\fR option can be followed
X! by one or two characters, which must be "a" or "d".  The first character
X! specifies the sort order by trigger date (ascending or descending) and
X! the second specifies the sort order by trigger time.  The default is
X! to sort both fields in ascending order.
X  .PP
X  In ascending order, reminders are issued with the most imminent first.
X  Descending order is the reverse.  Reminders are always sorted by
X  trigger date, and reminders with the same trigger date are then sorted
X  by trigger time.  Non-timed reminders are always issued after timed
X! reminders in this mode.
X  .PP
X  You can define a user-defined function called SORTBANNER which takes one
X  \fBDATE\fR-type argument.  In sort mode, the following sequence happens:
X--- 2987,3010 ----
X  .SH SORTING REMINDERS
X  .PP
X  The \fB\-g\fR option causes \fBRemind\fR to sort reminders by
X! trigger date, time and priority before issuing them.  Note that reminders are
X  still calculated in the order encountered in the script.  However, rather
X  than being issued immediately, they are saved in an internal buffer.
X  When \fBRemind\fR has finished processing the script, it issues the
X  saved reminders in sorted order.  The \fB\-g\fR option can be followed
X! by up to three characters, which must be "a" or "d".  The first character
X! specifies the sort order by trigger date (ascending or descending),
X! the second specifies the sort order by trigger time and the third
X! specifies the sort order by priority.  The default is
X! to sort all fields in ascending order.
X  .PP
X  In ascending order, reminders are issued with the most imminent first.
X  Descending order is the reverse.  Reminders are always sorted by
X  trigger date, and reminders with the same trigger date are then sorted
X  by trigger time.  Non-timed reminders are always issued after timed
X! reminders in this mode.  If two reminders have the same date and time,
X! then the priority is used to break ties.  Reminders with the same date,
X! time and priority are issued in the order they were encountered.
X  .PP
X  You can define a user-defined function called SORTBANNER which takes one
X  \fBDATE\fR-type argument.  In sort mode, the following sequence happens:
X***************
X*** 2926,2931 ****
X--- 3061,3121 ----
X  	endif
X  .fi
X  .PP
X+ .SH MSGPREFIX() AND MSGSUFFIX()
X+ .PP
X+ You can define two functions in your script called \fBmsgprefix()\fR
X+ and \fBmsgsuffix()\fR.  They should each accept one argument, a number
X+ from 0 to 9999.
X+ .PP
X+ In normal mode, for \fBMSG\fR- and \fBMSF\fR-type reminders,
X+ the following sequence occurs when
X+ \fBRemind\fR triggers a reminder:
X+ .TP
X+ o
X+ If \fBmsgprefix()\fR is defined, it is evaluated with the priority
X+ of the reminder as its argument.  The result is printed.  It is
X+ \fInot\fR passed through the substitution filter.
X+ .TP
X+ o
X+ The body of the reminder is printed.
X+ .TP
X+ o
X+ If \fBmsgsuffix()\fR is defined, it is evaluated with the priority
X+ of the reminder as its argument.  The result is printed.  It is
X+ \fInot\fR passed through the substitution filter.
X+ .PP
X+ Here's an example:  The following definition causes priority-0
X+ reminders to be preceded by "URGENT", and priority-6000 reminders to
X+ be preceded by "(not important)".
X+ .PP
X+ .nf
X+ 	fset msgprefix(x) iif(x==0, "URGENT: ", \\
X+ 	     x==6000, "(not important) ", "")
X+ .fi
X+ .PP
X+ In Calendar Mode (with the \fB\-c\fR, \fB\-s\fR or \fB\-p\fR options),
X+ an analagous pair of functions named \fBcalprefix()\fR and
X+ \fBcalsuffix()\fR can be defined.  They work with all reminders which
X+ produce an entry in the calendar (i.e., \fBCAL\fR- and possibly
X+ \fBRUN\fR-type reminders as well as \fBMSG\fR-type reminders.)
X+ .PP
X+ .B NOTES
X+ .PP
X+ Normally, the body of a reminder is followed by a carriage return.
X+ Thus, the results of \fBmsgsuffix()\fR will appear on the next
X+ line.  If you don't want this, end the body of the reminder with a
X+ percentage sign, "%".  If you want a space between your reminders,
X+ simply include a carriage return (\fBchar(13)\fR) as part of the
X+ \fBmsgsuffix()\fR return value.
X+ .PP
X+ If \fBRemind\fR has problems evaluating \fBmsgprefix()\fR,
X+ \fBmsgsuffix()\fR or \fBsortbanner()\fR, you will see a lot of
X+ error messages.  For an example of this, define the following:
X+ .PP
X+ .nf
X+ 	fset msgprefix(x) x/0
X+ .fi
X+ .PP
X  .SH FOREIGN LANGUAGE SUPPORT
X  .PP
X  Your version of \fBRemind\fR may have been compiled to support a
X***************
X*** 2992,2998 ****
X  .TP
X  .B hebdate(i_day, s_hebmon [,id_yrstart [,i_jahr [,i_aflag]]])
X  The \fBhebdate()\fR function is the most complex of the Hebrew support
X! functions.  It can take from 2 to 4 arguments.  It returns a \fBDATE\fR
X  corresponding to the Hebrew date.
X  .PP
X  .RS
X--- 3182,3188 ----
X  .TP
X  .B hebdate(i_day, s_hebmon [,id_yrstart [,i_jahr [,i_aflag]]])
X  The \fBhebdate()\fR function is the most complex of the Hebrew support
X! functions.  It can take from 2 to 5 arguments.  It returns a \fBDATE\fR
X  corresponding to the Hebrew date.
X  .PP
X  .RS
X***************
X*** 3307,3316 ****
X  versions of \fBRemind\fR prior to 03.00.01.
X  .SH AUTHOR
X  .PP
X! David F. Skoll wrote \fBRemind\fR.  The moon code was copied largely verbatim
X! from "moontool" by John Walker.  The Hebrew calendar support was taken
X! from "hdate" by Amos Shapir.  The authors of the language files are
X! listed in the header file "lang.h" which comes with \fBRemind\fR.
X  .SH BUGS
X  .PP
X  There's no good reason why read-only system variables are not
X--- 3497,3508 ----
X  versions of \fBRemind\fR prior to 03.00.01.
X  .SH AUTHOR
X  .PP
X! David F. Skoll wrote \fBRemind\fR.  The moon code was copied largely
X! unmodified from "moontool" by John Walker.  The Hebrew calendar
X! support was taken from "hdate" by Amos Shapir.  The authors of the
X! language files are listed in the header file "lang.h" which comes with
X! \fBRemind\fR.  OS/2 support was provided initially by Darrel
X! Hankerson; more complete OS/2 support was done by Russ Herman.
X  .SH BUGS
X  .PP
X  There's no good reason why read-only system variables are not
X***************
X*** 3321,3327 ****
X  .PP
X  The UTC functions are not reliable under MS-DOS.
X  .PP
X! The MS-DOS and OS/2 versions of \fBRemind\fR do not support queuing or timed
X  activation of reminders.
X  .PP
X  \fBRemind\fR has some built-in limits on total line length,
X--- 3513,3519 ----
X  .PP
X  The UTC functions are not reliable under MS-DOS.
X  .PP
X! The MS-DOS version of \fBRemind\fR does not support queuing or timed
X  activation of reminders.
X  .PP
X  \fBRemind\fR has some built-in limits on total line length,
X*** ../prev/sort.c	Tue Aug 31 16:28:20 1993
X--- ./sort.c	Tue Oct 19 11:19:14 1993
X***************
X*** 33,44 ****
X     int trigdate;
X     int trigtime;
X     int typ;
X  } Sortrem;
X  
X  /* The sorted reminder queue */
X  static Sortrem *SortedQueue = (Sortrem *) NULL;
X  
X! PRIVATE Sortrem *MakeSortRem ARGS ((int jul, int tim, char *body, int typ));
X  PRIVATE void IssueSortBanner ARGS ((int jul));
X  
X  /***************************************************************/
X--- 33,45 ----
X     int trigdate;
X     int trigtime;
X     int typ;
X+    int priority;
X  } Sortrem;
X  
X  /* The sorted reminder queue */
X  static Sortrem *SortedQueue = (Sortrem *) NULL;
X  
X! PRIVATE Sortrem *MakeSortRem ARGS ((int jul, int tim, char *body, int typ, int prio));
X  PRIVATE void IssueSortBanner ARGS ((int jul));
X  
X  /***************************************************************/
X***************
X*** 49,60 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PRIVATE Sortrem *MakeSortRem(int jul, int tim, char *body, int typ)
X  #else
X! static Sortrem *MakeSortRem(jul, tim, body, typ)
X  int jul, tim;
X  char *body;
X! int typ;
X  #endif
X  {
X     Sortrem *new = NEW(Sortrem);
X--- 50,61 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PRIVATE Sortrem *MakeSortRem(int jul, int tim, char *body, int typ, int prio)
X  #else
X! static Sortrem *MakeSortRem(jul, tim, body, typ, prio)
X  int jul, tim;
X  char *body;
X! int typ, prio;
X  #endif
X  {
X     Sortrem *new = NEW(Sortrem);
X***************
X*** 69,74 ****
X--- 70,76 ----
X     new->trigdate = jul;
X     new->trigtime = tim;
X     new->typ = typ;
X+    new->priority = prio;
X     new->next = NULL;
X     return new;
X  }
X***************
X*** 81,96 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int InsertIntoSortBuffer(int jul, int tim, char *body, int typ)
X  #else
X! int InsertIntoSortBuffer(jul, tim, body, typ)
X  int jul;
X  int tim;
X  char *body;
X! int typ;
X  #endif
X  {
X!    Sortrem *new = MakeSortRem(jul, tim, body, typ);
X     Sortrem *cur = SortedQueue, *prev = NULL;
X     int ShouldGoAfter;
X  
X--- 83,98 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int InsertIntoSortBuffer(int jul, int tim, char *body, int typ, int prio)
X  #else
X! int InsertIntoSortBuffer(jul, tim, body, typ, prio)
X  int jul;
X  int tim;
X  char *body;
X! int typ, prio;
X  #endif
X  {
X!    Sortrem *new = MakeSortRem(jul, tim, body, typ, prio);
X     Sortrem *cur = SortedQueue, *prev = NULL;
X     int ShouldGoAfter;
X  
X***************
X*** 99,104 ****
X--- 101,107 ----
X        IssueSortedReminders();
X        SortByDate = 0;
X        SortByTime = 0;
X+       SortByPrio = 0;
X        return E_NO_MEM;
X     }
X  
X***************
X*** 108,126 ****
X        return OK;
X     }
X     while (cur) {
X!       if (cur->trigdate == new->trigdate) {
X!          ShouldGoAfter =
X! 	    (SortByTime == SORT_ASCEND) ?
X! 	       (new->trigtime >= cur->trigtime) :
X! 	       ((new->trigtime == NO_TIME) || (new->trigtime <= cur->trigtime));
X!       } else {
X!          ShouldGoAfter =
X! 	    (SortByDate == SORT_ASCEND) ?
X! 	       (new->trigdate >= cur->trigdate) :
X! 	       (new->trigdate <= cur->trigdate);
X!       }
X! 
X!       if (ShouldGoAfter) {
X           prev = cur;
X  	 cur = cur->next;
X        } else {
X--- 111,121 ----
X        return OK;
X     }
X     while (cur) {
X!       ShouldGoAfter = CompareRems(new->trigdate, new->trigtime, new->priority,
X! 		      cur->trigdate, cur->trigtime, cur->priority,
X! 		      SortByDate, SortByTime, SortByPrio);
X! 		      
X!       if (ShouldGoAfter <= 0) {
X           prev = cur;
X  	 cur = cur->next;
X        } else {
X***************
X*** 160,183 ****
X  
X     while (cur) {
X        next = cur->next;
X!       if (cur->typ == MSG_TYPE || cur->typ == MSF_TYPE) {
X! 	if (!MsgCommand) {
X!             if (cur->trigdate != olddate) {
X!                IssueSortBanner(cur->trigdate);
X! 	       olddate = cur->trigdate;
X              }
X! 	    if (cur->typ == MSG_TYPE)
X!                printf("%s\n", cur->text);
X!             else
X! 	       FillParagraph(cur->text);
X!          } else {
X!             char buf[LINELEN+TOKSIZE];
X!             sprintf(buf, MsgCommand, cur->text);
X! 	    system(buf);
X!          }
X!       } else { /* Must be RUN_TYPE */
X!          system(cur->text);
X        }
X        free(cur->text);
X        free(cur);
X        cur = next;
X--- 155,194 ----
X  
X     while (cur) {
X        next = cur->next;
X!       switch(cur->typ) {
X!          case MSG_TYPE:
X! 	    if (MsgCommand) {
X! 	       char buf[LINELEN+TOKSIZE];
X! 	       sprintf(buf, MsgCommand, cur->text);
X! 	       system(buf);
X!             } else {
X! 	       if (cur->trigdate != olddate) {
X! 	          IssueSortBanner(cur->trigdate);
X! 		  olddate = cur->trigdate;
X!                }
X! #ifdef __OS2__
X!                PutlPopUp(cur->text);
X! #else
X!                printf("%s", cur->text);
X! #endif
X              }
X! 	    break;
X! 
X! 	 case MSF_TYPE:
X! #ifdef __OS2__
X!             StartPopUp();
X! #endif
X! 	    FillParagraph(cur->text);
X! #ifdef __OS2__
X!             EndPopUp();
X! #endif
X! 	    break;
X! 
X! 	 case RUN_TYPE:
X! 	    system(cur->text);
X! 	    break;
X        }
X+ 
X        free(cur->text);
X        free(cur);
X        cur = next;
X***************
X*** 214,217 ****
X--- 225,267 ----
X     if (!DoSubstFromString(v.v.str, SubstBuffer, jul, NO_TIME))
X        if (*SubstBuffer) printf("%s\n", SubstBuffer);
X     DestroyValue(&v);
X+ }
X+ 
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  CompareRems                                                */
X+ /*                                                             */
X+ /*  Compare two reminders for sorting.  Return 0 if they       */
X+ /*  compare equal; 1 if rem2 should come after rem1, -1 if     */
X+ /*  rem1 should come after rem2.  bydate and bytime control    */
X+ /*  sorting direction by date and time, resp.                  */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PUBLIC int CompareRems(int dat1, int tim1, int prio1,
X+                        int dat2, int tim2, int prio2,
X+ 		       int bydate, int bytime, int byprio)
X+ #else
X+ int CompareRems(dat1, tim1, prio1, dat2, tim2, prio2, bydate, bytime, byprio)
X+ int dat1, tim1, prio1, dat2, tim2, prio2, bydate, bytime, byprio;
X+ #endif
X+ {
X+    int dafter, tafter, pafter;
X+ 
X+    dafter = (bydate != SORT_DESCEND) ? 1 : -1;
X+    tafter = (bytime != SORT_DESCEND) ? 1 : -1;
X+    pafter = (byprio != SORT_DESCEND) ? 1 : -1;
X+ 
X+    if (dat1 < dat2) return dafter;
X+    if (dat1 > dat2) return -dafter;
X+ 
X+    if (tim1 == NO_TIME && tim2 != NO_TIME) return -1;
X+    if (tim1 != NO_TIME && tim2 == NO_TIME) return 1;
X+    if (tim1 < tim2) return tafter;
X+    if (tim1 > tim2) return -tafter;
X+ 
X+    if (prio1 < prio2) return pafter;
X+    if (prio1 > prio2) return -pafter;
X+ 
X+    return 0;
X  }
X*** ../prev/test.cmp	Tue Aug 31 13:22:46 1993
X--- ./test.cmp	Tue Oct 12 16:22:53 1993
X***************
X*** 631,637 ****
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.09"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X--- 631,637 ----
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.10"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X***************
X*** 772,778 ****
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.09"
X          a077  "1992 92
X  "
X          a049  21
X--- 772,778 ----
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.10"
X          a077  "1992 92
X  "
X          a049  21
X*** ../prev/token.c	Fri Sep  3 11:50:53 1993
X--- ./token.c	Wed Oct 20 11:45:09 1993
X***************
X*** 11,16 ****
X--- 11,17 ----
X  /***************************************************************/
X  #include "config.h"
X  #include <stdio.h>
X+ #include <string.h>
X  #include <ctype.h>
X  #ifdef HAVE_STDLIB_H
X  #include <stdlib.h>
X***************
X*** 77,82 ****
X--- 78,84 ----
X     { "once", 		3, 	T_Once,		0 },
X     { "pop-omit-context", 3,	T_Pop,		0 },
X     { "preserve",        8,      T_Preserve,     0 },
X+    { "priority",	8,	T_Priority,	0 },
X     { "ps", 		2, 	T_RemType, 	PS_TYPE },
X     { "psfile", 		6, 	T_RemType, 	PSF_TYPE },
X     { "push-omit-context", 4, 	T_Push,		0 },
X***************
X*** 85,90 ****
X--- 87,93 ----
X     { "satisfy",		7,	T_RemType,      SAT_TYPE },
X     { "saturday",	3,	T_WkDay,	5 },
X     { "scanfrom",	4,	T_Scanfrom,	0 },
X+    { "sched",		5,	T_Sched,	0 },
X     { "september", 	3, 	T_Month, 	8 },
X     { "set",		3,	T_Set,		0 },
X     { "skip", 		3, 	T_Skip, 	SKIP_SKIP },
X*** ../prev/types.h	Fri Sep  3 11:50:48 1993
X--- ./types.h	Wed Oct 20 11:50:55 1993
X***************
X*** 52,57 ****
X--- 52,59 ----
X     int typ;
X     int once;
X     int scanfrom;
X+    int priority;
X+    char sched[VAR_NAME_LEN+1];  /* Scheduling function */
X  } Trigger;
X  
X  /* A time trigger */
X***************
X*** 93,98 ****
X--- 95,102 ----
X  
X  #define NO_TIME 1500 /* >1440, ie > than the largest possible legal time */
X  
X+ #define NO_PRIORITY 5000 /* Default priority is midway between 0 and 9999 */
X+ 
X  #define NO_TYPE  0
X  #define MSG_TYPE 1
X  #define RUN_TYPE 2
X***************
X*** 127,133 ****
X    T_Debug,
X    T_Dumpvars,
X    T_Scanfrom,
X!   T_Flush
X  };
X  
X  /* The structure of a token */
X--- 131,139 ----
X    T_Debug,
X    T_Dumpvars,
X    T_Scanfrom,
X!   T_Flush,
X!   T_Priority,
X!   T_Sched
X  };
X  
X  /* The structure of a token */
X***************
X*** 162,166 ****
X  #define SC_NOTIME 2   /* Do not display time in SC format. */
X  
X  /* Flags for sorting */
X! #define SORT_ASCEND 1
X  #define SORT_DESCEND 2
X--- 168,173 ----
X  #define SC_NOTIME 2   /* Do not display time in SC format. */
X  
X  /* Flags for sorting */
X! #define SORT_NONE    0
X! #define SORT_ASCEND  1
X  #define SORT_DESCEND 2
X*** ../prev/var.c	Tue Sep 28 16:16:07 1993
X--- ./var.c	Thu Oct 14 10:21:45 1993
X***************
X*** 474,479 ****
X--- 474,482 ----
X     {   "PSCal",		  0,	INT_TYPE,	&PsCal,		0,	0   },
X     {   "RunOff",	  0,	INT_TYPE,	&RunDisabled,	0,	0   },
X     {   "SimpleCal",	  0,	INT_TYPE,	&DoSimpleCalendar,	0,  0 },
X+    {   "SortByDate",	  0,	INT_TYPE,	&SortByDate,	0,	0},
X+    {   "SortByPrio",	  0,	INT_TYPE,	&SortByPrio,	0,	0},
X+    {   "SortByTime",	  0,	INT_TYPE,	&SortByTime,	0,	0},
X     {   "SubsIndent",	  1,	INT_TYPE,	&SubsIndent,	0,	132}
X  };
X  
END_OF_FILE
  if test 50141 -ne `wc -c <'patch.10.C'`; then
    echo shar: \"'patch.10.C'\" unpacked with wrong size!
  elif test -f 'patch.10.A' && test -f 'patch.10.B'; then 
    echo shar: Combining  \"'patch.10'\" \(95017 characters\) 
    cat 'patch.10.A' 'patch.10.B' 'patch.10.C' > 'patch.10' 
    if test 95017 -ne `wc -c <'patch.10'`; then 
      echo shar: \"'patch.10'\" combined with wrong size! 
    else 
      rm patch.10.A patch.10.B patch.10.C 
    fi 
  fi
  # end of 'patch.10.C'
fi
if test -f 'test-rem.bat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test-rem.bat'\"
else
  echo shar: Extracting \"'test-rem.bat'\" \(763 characters\)
  sed "s/^X//" >'test-rem.bat' <<'END_OF_FILE'
X@echo off
Xrem ---------------------------------------------------------------------------
Xrem TEST-REM
Xrem
Xrem This file runs an MSDOS acceptance test for Remind.  To use it, type:
Xrem	 test-rem
Xrem in the build directory.
Xrem
Xrem This file is part of REMIND.
Xrem Copyright (C) 1992, 1993 by David F. Skoll
Xrem ---------------------------------------------------------------------------
X
Xdel test.out > nul
Xset TEST_GETENV=foo bar baz
X..\msdos-ex\remind -e -dxte .\test.rem 16 feb 1991 > test.out
Xecho n | comp test.out test1.cmp
Xif errorlevel 1 goto oops
Xecho "Remind:  Acceptance test PASSED"
Xgoto quit
X:oops
Xecho "Remind:  Acceptance test FAILED"
Xecho ""
Xecho "Examine the file test.out to see where it differs from the"
Xecho "reference file test1.cmp."
X:quit
END_OF_FILE
  if test 763 -ne `wc -c <'test-rem.bat'`; then
    echo shar: \"'test-rem.bat'\" unpacked with wrong size!
  fi
  # end of 'test-rem.bat'
fi
if test -f 'test-rem.cmd' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test-rem.cmd'\"
else
  echo shar: Extracting \"'test-rem.cmd'\" \(782 characters\)
  sed "s/^X//" >'test-rem.cmd' <<'END_OF_FILE'
X@echo off
Xrem ---------------------------------------------------------------------------
Xrem TEST-REM
Xrem
Xrem This file runs an OS/2 acceptance test for Remind.	To use it, type:
Xrem	 test-rem
Xrem in the build directory.
Xrem
Xrem This file is part of REMIND.
Xrem Copyright (C) 1992, 1993 by David F. Skoll
Xrem ---------------------------------------------------------------------------
X
Xdel /f test.out > nul
Xsetlocal
Xset TEST_GETENV=foo bar baz
X..\os2-ex\remind -e -dxte .\test.rem 16 feb 1991 > .\test.out
Xecho n | comp test.out test2.cmp
Xif errorlevel 1 goto oops
Xecho "Remind:  Acceptance test PASSED"
Xgoto quit
X:oops
Xecho "Remind:  Acceptance test FAILED"
Xecho ""
Xecho "Examine the file test.out to see where it differs from the"
Xecho "reference file test2.cmp."
X:quit
Xendlocal
END_OF_FILE
  if test 782 -ne `wc -c <'test-rem.cmd'`; then
    echo shar: \"'test-rem.cmd'\" unpacked with wrong size!
  fi
  # end of 'test-rem.cmd'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
