Newsgroups: comp.sources.misc
From: dfs@doe.carleton.ca (David F. Skoll)
Subject: v40i167:  remind - A replacement for calendar, Patch11a/5
Message-ID: <csm-v40i167=remind.105615@sparky.Sterling.COM>
X-Md4-Signature: 5114f89c24770131ddaac4399a0b15f3
Sender: kent@sparky.sterling.com (Kent Landfield)
Reply-To: dfs@doe.carleton.ca (David F. Skoll)
Organization: Dept. of Electronics, Carleton University
Date: Fri, 26 Nov 1993 16:56:44 GMT
Approved: kent@sparky.sterling.com

Submitted-by: dfs@doe.carleton.ca (David F. Skoll)
Posting-number: Volume 40, Issue 167
Archive-name: remind/patch11a
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

This is patch 11 for version 3.0 of Remind.

Remind is a sophisticated calendar/alarm program, which runs under
MS-DOS, UNIX and OS/2.

This patch is primarily to fix bugs and improve OS/2 support.
A couple of minor features have been added.

AVAILABILITY: Remind is available via anonymous ftp at ftp.doe.carleton.ca
(134.117.9.35) in the directory /pub/remind-3.0 - see the file README.1st
in that directory for a list of files.

TeX OUTPUT: Norman Walsh has written a program caleld 'rem2tex' which
takes the output of 'remind -p ...' and produces a TeX calendar rather
than a PostScript calendar.  This program is supported by Mr. Walsh
and is not part of the official Remind release.  For more information,
write to Norman Walsh <norm@ora.com>.

 From the WHATSNEW file:

CHANGES TO REMIND

* Version 3.0 Patch 11

+ MINOR ENHANCEMENTS

- Added release notes to README.UNIX and README.OS2 describing one
  way to make pop-up alarms under X-Windows and Presentation Manager.

- Added the $DefaultPrio system variable

- Improved OS/2 support, thanks to Darrel Hankerson, Russ Herman
  and Norman Walsh.

- Made the pushing and popping of operators and operands during
  expression evaluation in-line code instead of function calls.  Did the
  same for DestroyValue.  I'm not sure if this was a good idea -- on the
  Sparc using gcc, this slowed things down... go figure.

+ BUG FIXES

- Fixed a potential memory leak in the char() function.

- Made the TRIGGER() built-in function return its answer in English even
  for the foreign-language versions -- this was required for compilers which
  are not 8-bit clean, and for languages with accented letters.

- Made expression evaluation slightly faster by eliminating some unnecessary
  copying of string values.

- Corrected some non-portable definitions of the macro UPPER(c)

- Fixed typos in french.h

-------------- Cut Here ---------- Cut Here ---------- Cut Here -------------
#!/bin/sh
# This is Remind-3.0/Patch-11/part, a shell archive (shar 3.32)
# made 11/23/1993 16:02 UTC by <dfs@doe.carleton.ca> (David F. Skoll)
# Source directory /tmp_mnt/home/dfs/work/.rem/Remind-3.0/cur
#
# existing files WILL be overwritten
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
# 169648 -rw------- patch.11
#
if touch 2>&1 | fgrep 'amc' > /dev/null
 then TOUCH=touch
 else TOUCH=true
fi
if test -r shar3_seq_.tmp; then
	echo "Must unpack archives in sequence!"
	next=`cat shar3_seq_.tmp`; echo "Please unpack part $next next"
	exit 1
fi
# ============= patch.11 ==============
echo "x - extracting patch.11 (Text)"
sed 's/^X//' << 'SHAR_EOF' > patch.11 &&
XOfficial Patch 11 for Remind 03.00.
XMostly small fixes and better OS/2 support.
X
XPrereq: "03.00.10"
X*** ../prev/version.h	Wed Oct 20 14:47:27 1993
X--- ./version.h	Thu Oct 21 12:38:51 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.10"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.11"
X*** ../prev/Makefile	Tue Oct 12 16:29:09 1993
X--- ./Makefile	Thu Oct 21 12:40:51 1993
X***************
X*** 53,59 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.10
X  MATHLIB= -lm
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X--- 53,59 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.11
X  MATHLIB= -lm
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X***************
X*** 119,126 ****
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.10.tar $(MANIFEST)
X! 	compress -v remind-3.0.10.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X--- 119,126 ----
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.11.tar $(MANIFEST)
X! 	compress -v remind-3.0.11.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X***************
X*** 192,200 ****
X  release:
X  	-mkdir RELEASE
X  	-rm -f RELEASE/*
X! 	mkpatch ../prev . patch.10 Shar "Remind-3.0/Patch-10/part"
X  	mv Shar* RELEASE
X! 	rm -f patch.10
X  	for i in *.1; do nroff -man $$i | sed -e 's/_//g' > `basename $$i .1`.man; done
X  	mv *.man RELEASE
X  	for i in *.1; do groff -man -Tps $$i > `basename $$i .1`.ps; done
X--- 192,200 ----
X  release:
X  	-mkdir RELEASE
X  	-rm -f RELEASE/*
X! 	mkpatch ../prev . patch.11 Shar "Remind-3.0/Patch-11/part"
X  	mv Shar* RELEASE
X! 	rm -f patch.11
X  	for i in *.1; do nroff -man $$i | sed -e 's/_//g' > `basename $$i .1`.man; done
X  	mv *.man RELEASE
X  	for i in *.1; do groff -man -Tps $$i > `basename $$i .1`.ps; done
X*** ../prev/README.BCC	Tue Oct 12 16:24:02 1993
X--- ./README.BCC	Tue Nov 16 13:59:14 1993
X***************
X*** 22,30 ****
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X  
X! OS/2 support is courtesy of DARREL HANKERSON <HANK@DUCVAX.AUBURN.EDU>.
X! BCC support is courtesy of Russ Herman <rwh@gov.on.ca>.
X! However, if you have problems, please contact me and not Darrel.
X  
X  OTHER LANGUAGE SUPPORT
X  
X--- 22,30 ----
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X  
X! OS/2 support is courtesy of Russ Herman <rwh@gov.on.ca>, Norman Walsh 
X! <norm@ora.com>, and Darrel Hankerson <hankedr@mail.auburn.edu>. 
X! However, if you have problems, please contact me.
X  
X  OTHER LANGUAGE SUPPORT
X  
X*** ../prev/README.OS2	Wed Oct 13 10:51:42 1993
X--- ./README.OS2	Wed Nov 17 11:56:10 1993
X***************
X*** 1,10 ****
X  REMIND version 3.0 for OS/2
X  
X! This file contains instructions for compiling Remind with the
X! Microsoft C compiler under OS/2.  However, there is better support
X! for OS/2 using the Borland C compiler -- see the file README.BCC
X! for details.
X  
X  REMIND is a sophisticated alarm/calendar program.  Details are given
X  in the man page, "remind.1".
X  
X--- 1,13 ----
X  REMIND version 3.0 for OS/2
X  
X! This file contains instructions for compiling Remind under OS/2 with
X! Eberhard Mattes' emx/gcc compiler and with the Microsoft C compiler.
X! There are a number of targets in Makefile.os2, including OS/2-only 
X! versions and bound versions (programs which run under OS/2 and DOS).
X  
X+ Note that there is also support for OS/2 using the Borland C 
X+ compiler--see the file README.BCC for details.
X+ 
X  REMIND is a sophisticated alarm/calendar program.  Details are given
X  in the man page, "remind.1".
X  
X***************
X*** 11,30 ****
X  1 - Read the file COPYRIGHT.  (This may be called COPYRIGH on your
X      MS-DOS system.)
X  
X! 2 - To compile Remind for OS/2, you must use the Microsoft C compiler.
X!     You must also have a decent version of 'make', such as dmake.
X  
X  3 - Examine the file config.h and adjust parameters as needed
X  
X! 4 - Examine the file makefile.os2 and adjust parameters as needed.
X  
X  5 - Type:
X  
X! 	make -f makefile.os2
X  
X! This will make 'remind.exe' which is an OS/2 1.x--2.0 executable, and
X! 'remindb.exe' which is an OS/2 and MSDOS bound executable.
X  
X  The file "defs.rem" has some sample Remind definitions and commands,
X  as well as U.S. and Jewish holidays.
X  
X--- 14,37 ----
X  1 - Read the file COPYRIGHT.  (This may be called COPYRIGH on your
X      MS-DOS system.)
X  
X! 2 - To compile Remind for OS/2, you must use the Microsoft C compiler
X!     or emx/gcc. You must also have a decent version of 'make', such 
X!     as dmake or GNU make.
X  
X  3 - Examine the file config.h and adjust parameters as needed
X  
X! 4 - Examine the file Makefile.os2 and adjust parameters as needed.
X  
X  5 - Type:
X  
X! 	make -f Makefile.os2
X  
X! to see a list of targets. For example, 
X  
X+ 	make -f Makefile.os2 emx
X+ 
X+ will build a 32-bit emx version which runs under OS/2 2.x and DOS.
X+ 
X  The file "defs.rem" has some sample Remind definitions and commands,
X  as well as U.S. and Jewish holidays.
X  
X***************
X*** 31,38 ****
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X  
X! OS/2 support is courtesy of DARREL HANKERSON <HANK@DUCVAX.AUBURN.EDU>.
X! However, if you have problems, please contact me and not Darrel.
X  
X  OTHER LANGUAGE SUPPORT
X  
X--- 38,46 ----
X  NOTE that I do not have access to an OS/2 system, so support for this
X  system may not be as good as I'd like.
X  
X! OS/2 support is courtesy of Russ Herman <rwh@gov.on.ca>, Norman Walsh 
X! <norm@ora.com>, and Darrel Hankerson <hankedr@mail.auburn.edu>. 
X! However, if you have problems, please contact me.
X  
X  OTHER LANGUAGE SUPPORT
X  
X***************
X*** 61,66 ****
X--- 69,130 ----
X  
X  - You should define L_LANGNAME to be the full English name of your language,
X    with the first letter capitalized and the rest lower-case.
X+ 
X+ RELEASE NOTES -- miscellaneous info that couldn't go anywhere else!
X+ 
X+ 1. POPUP REMINDERS
X+ 
X+ If you define the symbol OS2_POPUP in the OS/2 Makefile, you get
X+ "full-screen popups" (as implemented by Russ Herman) for all MSG-
X+ and MSF-type reminders.  You may or may not like this feature.
X+ 
X+ One way of implementing popup reminders is to get the program
X+ "pmpopup.exe" from ftp-os2.cdrom.com, and using Remind with the
X+ '-k' option as follows from C:\STARTUP.CMD:
X+ 
X+ start /pm /inv /n remind "-kstart pmpopup %%s" remfile
X+ 
X+ Alternatively, if you have the Vrexx package, you can use this
X+ procedure suggested by Norman Walsh:
X+ 
X+ Start remind like this in C:\STARTUP.CMD:
X+ 
X+ start /pm /inv /n \bin\remind -faz "-kstart popupmsg %%s" .reminders
X+ 
X+ The popups are done by POPUPMSG.CMD which looks like this:
X+ 
X+ -------------- Cut Here ---------- Cut Here ---------- Cut Here --------
X+ /* PopUpMsg */
X+ 
X+ '@echo off'
X+ 
X+ parse arg theargs
X+ if theargs = "" then
X+   theargs = "Empty message"
X+ 
X+ call RxFuncAdd 'VInit', 'VREXX', 'VINIT'
X+ initcode = VInit()
X+ if initcode = 'ERROR' then signal CLEANUP
X+ 
X+ signal on failure name CLEANUP
X+ signal on halt name CLEANUP
X+ signal on syntax name CLEANUP
X+ 
X+ /* example VMsgBox call */
X+ 
X+ msg.0 = 1
X+ msg.1 = theargs
X+ 
X+ call VDialogPos 50, 50
X+ call VMsgBox 'Popup Message', msg, 1
X+ 
X+ /* end of CMD file */
X+ 
X+ CLEANUP:
X+    call VExit
X+ 
X+ exit
X+ -------------- Cut Here ---------- Cut Here ---------- Cut Here --------
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X*** ../prev/README.UNIX	Tue Oct 12 16:22:35 1993
X--- ./README.UNIX	Tue Nov 16 13:51:51 1993
X***************
X*** 88,93 ****
X--- 88,134 ----
X    name of your language, with the first letter capitalized and the rest
X    lower-case.
X  
X+ RELEASE NOTES -- miscellaneous info that couldn't go anywhere else!
X+ 
X+ 1. POPUP REMINDERS
X+ 
X+ If you're running under X-Windows and you have the TCL tools,
X+ you can create simple pop-up reminders by creating the following
X+ TCL script called 'popup'.  It pops a message on to the screen and
X+ waits for you to press the 'OK' button.  If you don't press the OK button
X+ within 15 seconds, it exits anyway.  To use it, you can use the '-k' option
X+ for Remind as follows:
X+ 
X+ 	remind "-kpopup '%s'&" .reminders
X+ 
X+ Or use the following in your Remind script:
X+ 
X+ 	REM AT 17:00 RUN popup 'Time to go home.' &
X+ 
X+ This TCL script is a slightly modified version of one submitted by
X+ Norman Walsh.  TCL is available via FTP at ftp.uu.net in /languages/tcl.
X+ 
X+ -------------- Cut Here ---------- Cut Here ---------- Cut Here -------------
X+ #!/usr/local/bin/wish -f
X+ 
X+ wm withdraw .
X+ 
X+ if { [ llength $argv ] == 1 } {
X+   eval set msg $argv
X+ } else {
X+   eval set msg [ list $argv ]
X+ }
X+ 
X+ after 15000 { destroy . ; exit }
X+ 
X+ tk_dialog .d { Message } $msg warning 0 { OK } 
X+ 
X+ destroy .
X+ 
X+ exit
X+ -------------- Cut Here ---------- Cut Here ---------- Cut Here -------------
X+ 
X+ 
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X  986 Eiffel Avenue
X*** ../prev/WHATSNEW.30	Wed Oct 20 12:23:25 1993
X--- ./WHATSNEW.30	Tue Nov 16 17:42:21 1993
X***************
X*** 1,5 ****
X--- 1,37 ----
X  CHANGES TO REMIND
X  
X+ * Version 3.0 Patch 11
X+ 
X+ + MINOR ENHANCEMENTS
X+ 
X+ - Added release notes to README.UNIX and README.OS2 describing one
X+   way to make pop-up alarms under X-Windows and Presentation Manager.
X+ 
X+ - Added the $DefaultPrio system variable
X+ 
X+ - Improved OS/2 support, thanks to Darrel Hankerson, Russ Herman
X+   and Norman Walsh.
X+ 
X+ - Made the pushing and popping of operators and operands during
X+   expression evaluation in-line code instead of function calls.  Did the
X+   same for DestroyValue.  I'm not sure if this was a good idea -- on the
X+   Sparc using gcc, this slowed things down... go figure.
X+ 
X+ + BUG FIXES
X+ 
X+ - Fixed a potential memory leak in the char() function.
X+ 
X+ - Made the TRIGGER() built-in function return its answer in English even
X+   for the foreign-language versions -- this was required for compilers which
X+   are not 8-bit clean, and for languages with accented letters.
X+ 
X+ - Made expression evaluation slightly faster by eliminating some unnecessary
X+   copying of string values.
X+ 
X+ - Corrected some non-portable definitions of the macro UPPER(c)
X+ 
X+ - Fixed typos in french.h
X+ 
X  * Version 3.0 Patch 10
X  
X  + MAJOR ENHANCEMENT
X*** ../prev/calendar.c	Tue Oct 12 16:22:37 1993
X--- ./calendar.c	Tue Nov 16 17:41:51 1993
X***************
X*** 688,694 ****
X  	       strcat(s, v.v.str);
X  	       s += strlen(s);
X              }
X! 	    DestroyValue(&v);
X           }
X        }
X        if ( (r=DoSubst(p, s, &trig, &tim, jul, CAL_MODE)) ) return r;
X--- 688,694 ----
X  	       strcat(s, v.v.str);
X  	       s += strlen(s);
X              }
X! 	    DestroyValue(v);
X           }
X        }
X        if ( (r=DoSubst(p, s, &trig, &tim, jul, CAL_MODE)) ) return r;
X***************
X*** 703,709 ****
X  	       strcat(s, v.v.str);
X  	       s += strlen(s);
X              }
X! 	    DestroyValue(&v);
X           }
X        }
X        s = obuf;
X--- 703,709 ----
X  	       strcat(s, v.v.str);
X  	       s += strlen(s);
X              }
X! 	    DestroyValue(v);
X           }
X        }
X        s = obuf;
X*** ../prev/config.h	Wed Oct 13 10:47:47 1993
X--- ./config.h	Mon Nov 15 14:25:26 1993
X***************
X*** 169,179 ****
X  /*---------------------------------------------------------------------*/
X  /* Do we handle queued reminders?                                      */
X  /*---------------------------------------------------------------------*/
X! #ifdef UNIX
X! #define HAVE_QUEUED 1
X! #endif
X! 
X! #if defined(__BORLANDC__) && defined(__OS2__)
X  #define HAVE_QUEUED 1
X  #endif
X  
X--- 169,175 ----
X  /*---------------------------------------------------------------------*/
X  /* Do we handle queued reminders?                                      */
X  /*---------------------------------------------------------------------*/
X! #if defined(UNIX) || defined(__OS2__)
X  #define HAVE_QUEUED 1
X  #endif
X  
X*** ../prev/defs.rem	Wed Oct 13 11:55:57 1993
X--- ./defs.rem	Fri Nov  5 15:57:33 1993
X***************
X*** 326,331 ****
X--- 326,345 ----
X  [trigger(moondate(2))] PS [psmoon(2)]
X  [trigger(moondate(3))] PS [psmoon(3)]
X  
X+ # The following example puts sunrise and sunset times in PostScript in the
X+ # calendar - the sizes are hard-coded, however, and work best in landscape.
X+ REM PS Border Border 5 sub moveto \
X+ 	/SmallFont findfont 4 scalefont setfont \
X+ 	(Sunrise: [sunrise(trigdate())] Sunset: [sunset(trigdate())]) show
X+ 
X+ # The next one puts the day number (1-366) and days left in the year at the
X+ # bottom of the post-script calendar.  Again, the hard-coded sizes work best
X+ # in landscape.
X+ FSET _DayOfYear(x) x-(date(year(x),1,1) - 1)
X+ REM PS BoxWidth 3 mul 4 div Border 5 sub moveto \
X+ 	/SmallFont findfont 4 scalefont setfont \
X+ 	([_DayOfYear(today())]([365+isleap(today())-_DayOfYear(today())])) show
X+ 
X  #USHOLS
X  #############################################################################
X  #       								    #
X*** ../prev/dorem.c	Wed Oct 20 12:14:48 1993
X--- ./dorem.c	Tue Nov 16 17:41:46 1993
X***************
X*** 88,95 ****
X  
X  
X     if (ShouldTriggerReminder(&trig, &tim, jul)) {
X!       if ( (r=TriggerReminder(p, &trig, &tim, jul)) ) return r;
X     }
X  
X     return OK;
X  }   
X--- 88,101 ----
X  
X  
X     if (ShouldTriggerReminder(&trig, &tim, jul)) {
X! #ifdef OS2_POPUP
X!       if ( (r=TriggerReminder(p, &trig, &tim, jul, 0)) ) {
X! #else
X!       if ( (r=TriggerReminder(p, &trig, &tim, jul)) ) {
X! #endif
X! 	 return r;
X     }
X+    }
X  
X     return OK;
X  }   
X***************
X*** 127,133 ****
X     trig->once = NO_ONCE;
X     trig->typ = NO_TYPE;
X     trig->scanfrom = NO_DATE;
X!    trig->priority = NO_PRIORITY;
X     trig->sched[0] = 0;
X     tim->ttime = NO_TIME;
X     tim->delta = NO_DELTA;
X--- 133,139 ----
X     trig->once = NO_ONCE;
X     trig->typ = NO_TYPE;
X     trig->scanfrom = NO_DATE;
X!    trig->priority = DefaultPrio;
X     trig->sched[0] = 0;
X     tim->ttime = NO_TIME;
X     tim->delta = NO_DELTA;
X***************
X*** 445,458 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X  PUBLIC int TriggerReminder(ParsePtr p, Trigger *t, TimeTrig *tim, int jul)
X! #else
X  int TriggerReminder(p, t, tim, jul)
X  ParsePtr p;
X  Trigger *t;
X  TimeTrig *tim;
X  int jul;
X! #endif
X  {
X     int r, y, m, d;
X     char PrioExpr[25];
X--- 451,478 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X+ #ifdef OS2_POPUP
X+ PUBLIC int TriggerReminder(ParsePtr p, Trigger *t, TimeTrig *tim, int jul,
X+ 			   int AsPopUp)
X+ #else /* ! OS2_POPUP */
X  PUBLIC int TriggerReminder(ParsePtr p, Trigger *t, TimeTrig *tim, int jul)
X! #endif /* OS2_POPUP */
X! #else /* ! HAVE_PROTOS */
X! #ifdef OS2_POPUP
X! int TriggerReminder(p, t, tim, jul, AsPopUp)
X! ParsePtr p;
X! Trigger *t;
X! TimeTrig *tim;
X! int jul;
X! int AsPopUp;
X! #else /* ! OS2_POPUP */
X  int TriggerReminder(p, t, tim, jul)
X  ParsePtr p;
X  Trigger *t;
X  TimeTrig *tim;
X  int jul;
X! #endif /* OS2_POPUP */
X! #endif /* HAVE_PROTOS */
X  {
X     int r, y, m, d;
X     char PrioExpr[25];
X***************
X*** 468,475 ****
X     if ((t->typ == MSG_TYPE || t->typ == MSF_TYPE) 
X         && !NumTriggered && !NextMode && !MsgCommand) {
X        if (!DoSubstFromString(Banner, SubstBuffer, JulianToday, NO_TIME) && *SubstBuffer)
X! #ifdef __OS2__
X              PutlPopUp(SubstBuffer);
X  #else
X  	    printf("%s\n", SubstBuffer);
X  #endif
X--- 488,498 ----
X     if ((t->typ == MSG_TYPE || t->typ == MSF_TYPE) 
X         && !NumTriggered && !NextMode && !MsgCommand) {
X        if (!DoSubstFromString(Banner, SubstBuffer, JulianToday, NO_TIME) && *SubstBuffer)
X! #ifdef OS2_POPUP
X! 	    if (AsPopUp)
X              PutlPopUp(SubstBuffer);
X+ 	    else
X+ 	       printf("%s\n", SubstBuffer);
X  #else
X  	    printf("%s\n", SubstBuffer);
X  #endif
X***************
X*** 481,492 ****
X        if ( (r=DoSubst(p, SubstBuffer, t, tim, jul, CAL_MODE)) ) return r;
X        if (!*SubstBuffer) return OK;
X        FromJulian(jul, &y, &m, &d);
X! #ifdef __OS2__
X!       sprintf(buf, "%04d%c%02d%c%02d %s", y, DATESEP, m+1, DATESEP, d,
X  					SimpleTime(tim->ttime, NULL));
X!       StartPopUp();
X!       PutsPopUp(buf);
X!       PutlPopUp(SubstBuffer);
X  #else
X        printf("%04d%c%02d%c%02d %s%s\n", y, DATESEP, m+1, DATESEP, d,
X                                        SimpleTime(tim->ttime, NULL),
X--- 504,521 ----
X        if ( (r=DoSubst(p, SubstBuffer, t, tim, jul, CAL_MODE)) ) return r;
X        if (!*SubstBuffer) return OK;
X        FromJulian(jul, &y, &m, &d);
X! #ifdef OS2_POPUP
X!       if (AsPopUp) {
X!          sprintf(buf, "%04d%c%02d%c%02d %s", y, DATESEP, m+1, DATESEP, d,
X  					SimpleTime(tim->ttime, NULL));
X!          StartPopUp();
X!          PutsPopUp(buf);
X!          PutlPopUp(SubstBuffer);
X!       }
X!       else
X! 	  printf("%04d%c%02d%c%02d %s%s\n", y, DATESEP, m+1, DATESEP, d,
X! 					  SimpleTime(tim->ttime, NULL),
X! 					  SubstBuffer);
X  #else
X        printf("%04d%c%02d%c%02d %s%s\n", y, DATESEP, m+1, DATESEP, d,
X                                        SimpleTime(tim->ttime, NULL),
X***************
X*** 507,513 ****
X  	    sprintf(s2, "%s", v.v.str);
X  	    s2 += strlen(s2);
X           }
X! 	 DestroyValue(&v);
X        }
X     }
X     if ( (r=DoSubst(p, s2, t, tim, jul, NORMAL_MODE)) ) return r;
X--- 536,542 ----
X  	    sprintf(s2, "%s", v.v.str);
X  	    s2 += strlen(s2);
X           }
X! 	 DestroyValue(v);
X        }
X     }
X     if ( (r=DoSubst(p, s2, t, tim, jul, NORMAL_MODE)) ) return r;
X***************
X*** 521,534 ****
X  	    sprintf(s2, "%s", v.v.str);
X  	    s2 += strlen(s2);
X           }
X! 	 DestroyValue(&v);
X        }
X     }
X- #ifndef __OS2__
X     if (t->typ == MSG_TYPE || t->typ == MSF_TYPE) {
X- #else
X-    if (t->typ == MSF_TYPE) {
X- #endif
X        *s2++ = '\n';
X     }
X     *s2 = 0;
X--- 550,559 ----
X  	    sprintf(s2, "%s", v.v.str);
X  	    s2 += strlen(s2);
X           }
X! 	 DestroyValue(v);
X        }
X     }
X     if (t->typ == MSG_TYPE || t->typ == MSF_TYPE) {
X        *s2++ = '\n';
X     }
X     *s2 = 0;
X***************
X*** 549,556 ****
X              sprintf(SubstBuffer, MsgCommand, buf);
X  	    system(SubstBuffer);
X           } else {
X! #ifdef __OS2__
X              PutlPopUp(buf);
X  #else
X              printf("%s", buf);
X  #endif
X--- 574,584 ----
X              sprintf(SubstBuffer, MsgCommand, buf);
X  	    system(SubstBuffer);
X           } else {
X! #ifdef OS2_POPUP
X! 	    if (AsPopUp)
X              PutlPopUp(buf);
X+ 	    else
X+ 	       printf("%s", buf);
X  #else
X              printf("%s", buf);
X  #endif
X***************
X*** 558,569 ****
X  	 break;
X  
X        case MSF_TYPE:
X! #ifdef __OS2__
X           StartPopUp();
X! #endif
X!          FillParagraph(buf);
X! #ifdef __OS2__
X           EndPopUp();
X  #endif
X  	 break;
X  
X--- 586,601 ----
X  	 break;
X  
X        case MSF_TYPE:
X! #ifdef OS2_POPUP
X! 	 if (AsPopUp) {
X           StartPopUp();
X! 	     FillParagraph(buf, 1);
X           EndPopUp();
X+ 	 } else {
X+ 	     FillParagraph(buf, 0);
X+ 	 }
X+ #else
X+ 	 FillParagraph(buf);
X  #endif
X  	 break;
X  
X*** ../prev/dosubst.c	Tue Oct 12 16:22:38 1993
X--- ./dosubst.c	Tue Nov  2 14:50:16 1993
X***************
X*** 25,31 ****
X  #include "types.h"
X  #include "protos.h"
X  
X! #define UPPER(c) ( ((c) >= 'a' && (c) <= 'z') ? (c) - 'a' + 'A' : (c) )
X  #define ABS(x) ( (x) < 0 ? -(x) : (x) )
X  #ifndef NL
X  #define NL "\n"
X--- 25,31 ----
X  #include "types.h"
X  #include "protos.h"
X  
X! #define UPPER(c) (islower(c) ? toupper(c) : c)
X  #define ABS(x) ( (x) < 0 ? -(x) : (x) )
X  #ifndef NL
X  #define NL "\n"
X*** ../prev/expr.c	Tue Oct 12 16:22:39 1993
X--- ./expr.c	Tue Nov 16 17:41:38 1993
X***************
X*** 53,60 ****
X  #endif
X  
X  PRIVATE int MakeValue ARGS ((char *s, Value *v, Var *locals));
X- PRIVATE int PushOpStack ARGS ((Operator *op));
X- PRIVATE int PopOpStack ARGS ((Operator *op));
X  PRIVATE int ParseLiteralDate ARGS ((char **s, int *jul));
X  
X  /* Binary operators - all left-associative */
X--- 53,58 ----
X***************
X*** 145,151 ****
X  {
X     int i;
X  
X!    for (i=0; i<ValStackPtr; i++) DestroyValue(&ValStack[i]);
X     ValStackPtr = 0;
X  }
X  
X--- 143,149 ----
X  {
X     int i;
X  
X!    for (i=0; i<ValStackPtr; i++) DestroyValue(ValStack[i]);
X     ValStackPtr = 0;
X  }
X  
X***************
X*** 286,293 ****
X        CleanStack();
X        return r;
X     }
X!    r = CopyValue(v, ValStack);
X!    DestroyValue(ValStack);
X     return r;
X  }
X  
X--- 284,291 ----
X        CleanStack();
X        return r;
X     }
X!    *v = *ValStack;
X!    ValStack[0].type = ERR_TYPE;
X     return r;
X  }
X  
X***************
X*** 363,370 ****
X        } else { /* Unary operator */
X  	 f = FindFunc(ExprBuf, UnOp, NUM_UN_OPS);
X           if (f) {
X!             r = PushOpStack(f);
X!             if (r) return r;
X  	    continue;  /* Still looking for an atomic vlue */
X  	 } else if (!ISID(*ExprBuf) && *ExprBuf != '$' 
X  	            && *ExprBuf != '"' && *ExprBuf != '\'') {
X--- 361,367 ----
X        } else { /* Unary operator */
X  	 f = FindFunc(ExprBuf, UnOp, NUM_UN_OPS);
X           if (f) {
X!             PushOpStack(*f);
X  	    continue;  /* Still looking for an atomic vlue */
X  	 } else if (!ISID(*ExprBuf) && *ExprBuf != '$' 
X  	            && *ExprBuf != '"' && *ExprBuf != '\'') {
X***************
X*** 373,380 ****
X  	 } else { /* Must be a literal value */
X  	    r = MakeValue(ExprBuf, &va, locals);
X  	    if (r) return r;
X! 	    r = PushValStack(&va);
X! 	    if (r) return r;
X  	 }
X        }
X  /* OK, we've got a literal value; now, we're looking for the end of the
X--- 370,376 ----
X  	 } else { /* Must be a literal value */
X  	    r = MakeValue(ExprBuf, &va, locals);
X  	    if (r) return r;
X! 	    PushValStack(va);
X  	 }
X        }
X  /* OK, we've got a literal value; now, we're looking for the end of the
X***************
X*** 385,392 ****
X     /* We've hit the end of the expression.  Pop off and evaluate until
X           OpStackPtr = OpBase and ValStackPtr = ValBase+1 */
X           while (OpStackPtr > OpBase) {
X!             r = PopOpStack(&op);
X!             if (r) return r;
X  	    if (DebugFlag & DB_PRTEXPR)
X  	       r=DebugPerform(&op);
X  	    else
X--- 381,387 ----
X     /* We've hit the end of the expression.  Pop off and evaluate until
X           OpStackPtr = OpBase and ValStackPtr = ValBase+1 */
X           while (OpStackPtr > OpBase) {
X!             PopOpStack(op);
X  	    if (DebugFlag & DB_PRTEXPR)
X  	       r=DebugPerform(&op);
X  	    else
X***************
X*** 405,411 ****
X        /* While operators of higher or equal precedence are on the stack,
X           pop them off and evaluate */
X        while (OpStackPtr > OpBase && OpStack[OpStackPtr-1].prec >= f->prec) {
X!          r = PopOpStack(&op2);
X           if (r) return r;
X  	 if (DebugFlag & DB_PRTEXPR)
X  	    r=DebugPerform(&op2);
X--- 400,406 ----
X        /* While operators of higher or equal precedence are on the stack,
X           pop them off and evaluate */
X        while (OpStackPtr > OpBase && OpStack[OpStackPtr-1].prec >= f->prec) {
X!          PopOpStack(op2);
X           if (r) return r;
X  	 if (DebugFlag & DB_PRTEXPR)
X  	    r=DebugPerform(&op2);
X***************
X*** 416,423 ****
X  	    return r;
X           }
X        }
X!       r = PushOpStack(f);
X!       if (r) return r;
X     }
X  }
X     
X--- 411,417 ----
X  	    return r;
X           }
X        }
X!       PushOpStack(*f);
X     }
X  }
X     
X***************
X*** 509,602 ****
X  
X  /***************************************************************/
X  /*                                                             */
X- /*  PushOpStack                                                */
X- /*                                                             */
X- /*  Push an operator onto the operator stack.                  */
X- /*                                                             */
X- /***************************************************************/
X- #ifdef HAVE_PROTOS
X- PRIVATE int PushOpStack(Operator *op)
X- #else
X- static int PushOpStack(op)
X- Operator *op;
X- #endif
X- {
X-    if (OpStackPtr >= OP_STACK_SIZE)
X-       return E_OP_STK_OVER;
X-    else {
X-       OpStack[OpStackPtr++] = *op;
X-       return OK;
X-    }
X- }
X- 
X- /***************************************************************/
X- /*                                                             */
X- /*  PushValStack                                               */
X- /*                                                             */
X- /*  Push a value onto the value stack.                         */
X- /*                                                             */
X- /***************************************************************/
X- #ifdef HAVE_PROTOS
X- PUBLIC int PushValStack(Value *val)
X- #else
X- int PushValStack(val)
X- Value *val;
X- #endif
X- {
X-    if (ValStackPtr >= VAL_STACK_SIZE)
X-       return E_VA_STK_OVER;
X-    else {
X-       ValStack[ValStackPtr++] = *val;
X-       return OK;
X-    }
X- }
X- 
X- /***************************************************************/
X- /*                                                             */
X- /*  PopOpStack                                                 */
X- /*                                                             */
X- /*  Pop an operator from the operator stack.                   */
X- /*                                                             */
X- /***************************************************************/
X- #ifdef HAVE_PROTOS
X- PRIVATE int PopOpStack(Operator *op)
X- #else
X- static int PopOpStack(op)
X- Operator *op;
X- #endif
X- {
X-    if (OpStackPtr <= 0)
X-       return E_OP_STK_UNDER;
X-    else {
X-       *op = OpStack[--OpStackPtr];
X-       return OK;
X-    }
X- }
X- 
X- /***************************************************************/
X- /*                                                             */
X- /*  PopValStack                                               */
X- /*                                                             */
X- /*  Pop a value onto the value stack.                         */
X- /*                                                             */
X- /***************************************************************/
X- #ifdef HAVE_PROTOS
X- PUBLIC int PopValStack(Value *val)
X- #else
X- int PopValStack(val)
X- Value *val;
X- #endif
X- {
X-    if (ValStackPtr <= 0)
X-       return E_VA_STK_UNDER;
X-    else {
X-       *val = ValStack[--ValStackPtr];
X-       return OK;
X-    }
X- }
X- 
X- /***************************************************************/
X- /*                                                             */
X  /*  DoCoerce - actually coerce a value to the specified type.  */
X  /*                                                             */
X  /***************************************************************/
X--- 503,508 ----
X***************
X*** 726,749 ****
X  
X  /***************************************************************/
X  /*                                                             */
X- /*  DestroyValue                                               */
X- /*                                                             */
X- /*  If value is of type string, deallocate string memory.      */
X- /*                                                             */
X- /***************************************************************/
X- #ifdef HAVE_PROTOS
X- PUBLIC void DestroyValue(Value *v)
X- #else
X- void DestroyValue(v)
X- Value *v;
X- #endif
X- {
X-    if (v->type == STR_TYPE && v->v.str) free(v->v.str);
X-    v->type = ERR_TYPE;
X- }
X- 
X- /***************************************************************/
X- /*                                                             */
X  /*  Add                                                        */
X  /*                                                             */
X  /*  Perform addition.                                          */
X--- 632,637 ----
X***************
X*** 758,766 ****
X     Value v1, v2, v3;
X     int r;
X     
X!    if ( (r = PopValStack(&v2)) )return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X     
X--- 646,654 ----
X     Value v1, v2, v3;
X     int r;
X     
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X     
X***************
X*** 767,773 ****
X  /* If both are ints, just add 'em */
X     if (v2.type == INT_TYPE && v1.type == INT_TYPE) {
X        v2.v.val += v1.v.val;
X!       return (PushValStack(&v2));
X     }
X  
X  /* If it's a date plus an int, add 'em */
X--- 655,662 ----
X  /* If both are ints, just add 'em */
X     if (v2.type == INT_TYPE && v1.type == INT_TYPE) {
X        v2.v.val += v1.v.val;
X!       PushValStack(v2);
X!       return OK;
X     }
X  
X  /* If it's a date plus an int, add 'em */
X***************
X*** 776,782 ****
X        v1.v.val += v2.v.val;
X        if (v1.v.val < 0) return E_DATE_OVER;
X        v1.type = DATE_TYPE;
X!       return PushValStack(&v1);
X     }
X     
X  /* If it's a time plus an int, add 'em mod 1440 */
X--- 665,672 ----
X        v1.v.val += v2.v.val;
X        if (v1.v.val < 0) return E_DATE_OVER;
X        v1.type = DATE_TYPE;
X!       PushValStack(v1);
X!       return OK;
X     }
X     
X  /* If it's a time plus an int, add 'em mod 1440 */
X***************
X*** 785,813 ****
X        v1.v.val = (v1.v.val + v2.v.val) % 1440;
X        if (v1.v.val < 0) v1.v.val += 1440;
X        v1.type = TIM_TYPE;
X!       return PushValStack(&v1);
X     }   	
X  
X  /* If either is a string, coerce them both to strings and concatenate */
X     if (v1.type == STR_TYPE || v2.type == STR_TYPE) {
X        if ( (r = DoCoerce(STR_TYPE, &v1)) ) {
X!       	 DestroyValue(&v1); DestroyValue(&v2);
X           return r;
X        }
X        if ( (r = DoCoerce(STR_TYPE, &v2)) ) {
X!       	 DestroyValue(&v1); DestroyValue(&v2);
X        	 return r;
X        }
X        v3.type = STR_TYPE;
X        v3.v.str = (char *) malloc(strlen(v1.v.str) + strlen(v2.v.str) + 1);
X        if (!v3.v.str) {
X!       	 DestroyValue(&v1); DestroyValue(&v2);
X  	 return E_NO_MEM;
X        }
X        strcpy(v3.v.str, v1.v.str);
X        strcat(v3.v.str, v2.v.str);
X!       DestroyValue(&v1); DestroyValue(&v2);
X!       return (PushValStack(&v3));
X     }
X  
X     /* Don't handle other types yet */
X--- 675,705 ----
X        v1.v.val = (v1.v.val + v2.v.val) % 1440;
X        if (v1.v.val < 0) v1.v.val += 1440;
X        v1.type = TIM_TYPE;
X!       PushValStack(v1);
X!       return OK;
X     }   	
X  
X  /* If either is a string, coerce them both to strings and concatenate */
X     if (v1.type == STR_TYPE || v2.type == STR_TYPE) {
X        if ( (r = DoCoerce(STR_TYPE, &v1)) ) {
X!       	 DestroyValue(v1); DestroyValue(v2);
X           return r;
X        }
X        if ( (r = DoCoerce(STR_TYPE, &v2)) ) {
X!       	 DestroyValue(v1); DestroyValue(v2);
X        	 return r;
X        }
X        v3.type = STR_TYPE;
X        v3.v.str = (char *) malloc(strlen(v1.v.str) + strlen(v2.v.str) + 1);
X        if (!v3.v.str) {
X!       	 DestroyValue(v1); DestroyValue(v2);
X  	 return E_NO_MEM;
X        }
X        strcpy(v3.v.str, v1.v.str);
X        strcat(v3.v.str, v2.v.str);
X!       DestroyValue(v1); DestroyValue(v2);
X!       PushValStack(v3);
X!       return OK;
X     }
X  
X     /* Don't handle other types yet */
X***************
X*** 830,838 ****
X     Value v1, v2;
X     int r;
X     
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X--- 722,730 ----
X     Value v1, v2;
X     int r;
X     
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X***************
X*** 839,845 ****
X     /* If they're both INTs, do subtraction */
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val -= v2.v.val;
X!       return PushValStack(&v1);
X     }
X  
X     /* If it's a date minus an int, do subtraction, checking for underflow */
X--- 731,738 ----
X     /* If they're both INTs, do subtraction */
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val -= v2.v.val;
X!       PushValStack(v1);
X!       return OK;
X     }
X  
X     /* If it's a date minus an int, do subtraction, checking for underflow */
X***************
X*** 846,852 ****
X     if (v1.type == DATE_TYPE && v2.type == INT_TYPE) {
X        v1.v.val -= v2.v.val;
X        if (v1.v.val < 0) return E_DATE_OVER;
X!       return PushValStack(&v1);
X     }
X  
X     /* If it's a time minus an int, do subtraction mod 1440 */
X--- 739,746 ----
X     if (v1.type == DATE_TYPE && v2.type == INT_TYPE) {
X        v1.v.val -= v2.v.val;
X        if (v1.v.val < 0) return E_DATE_OVER;
X!       PushValStack(v1);
X!       return OK;
X     }
X  
X     /* If it's a time minus an int, do subtraction mod 1440 */
X***************
X*** 853,859 ****
X     if (v1.type == TIM_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val - v2.v.val) % 1440;
X        if (v1.v.val < 0) v1.v.val += 1440;
X!       return PushValStack(&v1);
X     }
X  
X     /* If it's a time minus a time or a date minus a date, do it */
X--- 747,754 ----
X     if (v1.type == TIM_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val - v2.v.val) % 1440;
X        if (v1.v.val < 0) v1.v.val += 1440;
X!       PushValStack(v1);
X!       return OK;
X     }
X  
X     /* If it's a time minus a time or a date minus a date, do it */
X***************
X*** 861,871 ****
X         (v1.type == DATE_TYPE && v2.type == DATE_TYPE)) {
X        v1.v.val -= v2.v.val;
X        v1.type = INT_TYPE;
X!       return PushValStack(&v1);
X     }
X  
X     /* Must be types illegal for subtraction */
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 756,767 ----
X         (v1.type == DATE_TYPE && v2.type == DATE_TYPE)) {
X        v1.v.val -= v2.v.val;
X        v1.type = INT_TYPE;
X!       PushValStack(v1);
X!       return OK;
X     }
X  
X     /* Must be types illegal for subtraction */
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 885,901 ****
X     Value v1, v2;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val *= v2.v.val;
X!       return PushValStack(&v1);
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 781,798 ----
X     Value v1, v2;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val *= v2.v.val;
X!       PushValStack(v1);
X!       return OK;
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 915,923 ****
X     Value v1, v2;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X--- 812,820 ----
X     Value v1, v2;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X***************
X*** 924,932 ****
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        if (v2.v.val == 0) return E_DIV_ZERO;
X        v1.v.val /= v2.v.val;
X!       return PushValStack(&v1);
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 821,830 ----
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        if (v2.v.val == 0) return E_DIV_ZERO;
X        v1.v.val /= v2.v.val;
X!       PushValStack(v1);
X!       return OK;
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 946,954 ****
X     Value v1, v2;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X--- 844,852 ----
X     Value v1, v2;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X***************
X*** 955,963 ****
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        if (v2.v.val == 0) return E_DIV_ZERO;
X        v1.v.val %= v2.v.val;
X!       return PushValStack(&v1);
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 853,862 ----
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        if (v2.v.val == 0) return E_DIV_ZERO;
X        v1.v.val %= v2.v.val;
X!       PushValStack(v1);
X!       return OK;
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 1002,1010 ****
X     Value v1, v2, v3;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X--- 901,909 ----
X     Value v1, v2, v3;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X***************
X*** 1012,1024 ****
X  
X     v3.type = INT_TYPE;
X     if (v1.type != v2.type) {
X!       DestroyValue(&v1); DestroyValue(&v2);
X        if (how == EQ) {
X           v3.v.val = 0;
X! 	 return PushValStack(&v3);
X        } else if (how == NE) {
X           v3.v.val = 1;
X! 	 return PushValStack(&v3);
X        } else return E_BAD_TYPE;
X     }
X  
X--- 911,925 ----
X  
X     v3.type = INT_TYPE;
X     if (v1.type != v2.type) {
X!       DestroyValue(v1); DestroyValue(v2);
X        if (how == EQ) {
X           v3.v.val = 0;
X! 	 PushValStack(v3);
X!          return OK;
X        } else if (how == NE) {
X           v3.v.val = 1;
X! 	 PushValStack(v3);
X!          return OK;
X        } else return E_BAD_TYPE;
X     }
X  
X***************
X*** 1041,1048 ****
X           case GE: v3.v.val = (v1.v.val >= v2.v.val); break;
X        }
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X!    return PushValStack(&v3);
X  }
X  
X  /***************************************************************/
X--- 942,950 ----
X           case GE: v3.v.val = (v1.v.val >= v2.v.val); break;
X        }
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X!    PushValStack(v3);
X!    return OK;
X  }
X  
X  /***************************************************************/
X***************
X*** 1061,1077 ****
X     Value v1, v2;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val || v2.v.val) ? 1 : 0;
X!       return PushValStack(&v1);
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 963,980 ----
X     Value v1, v2;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val || v2.v.val) ? 1 : 0;
X!       PushValStack(v1);
X!       return OK;
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 1091,1107 ****
X     Value v1, v2;
X     int r;
X  
X!    if ( (r = PopValStack(&v2)) ) return r;
X!    if ( (r = PopValStack(&v1)) ) {
X!       DestroyValue(&v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val && v2.v.val) ? 1 : 0;
X!       return PushValStack(&v1);
X     }
X!    DestroyValue(&v1); DestroyValue(&v2);
X     return E_BAD_TYPE;
X  }
X  
X--- 994,1011 ----
X     Value v1, v2;
X     int r;
X  
X!    PopValStack(v2);
X!    if ( (r = FnPopValStack(&v1)) ) {
X!       DestroyValue(v2);
X        return r;
X     }
X  
X     if (v1.type == INT_TYPE && v2.type == INT_TYPE) {
X        v1.v.val = (v1.v.val && v2.v.val) ? 1 : 0;
X!       PushValStack(v1);
X!       return OK;
X     }
X!    DestroyValue(v1); DestroyValue(v2);
X     return E_BAD_TYPE;
X  }
X  
X***************
X*** 1276,1278 ****
X--- 1180,1207 ----
X  
X     return OK;
X  }
X+ 
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  FnPopValStack                                              */
X+ /*                                                             */
X+ /*  Pop a value from the value stack - implemented as a        */
X+ /*  function for situations where we don't want an immediate   */
X+ /*  return upon failure.                                       */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PUBLIC int FnPopValStack(Value *val)
X+ #else
X+ int FnPopValStack(val)
SHAR_EOF
echo "End of Remind-3.0/Patch-11/part part 1"
echo "File patch.11 is continued in part 2"
echo "2" > shar3_seq_.tmp
exit 0


exit 0 # Just in case...
