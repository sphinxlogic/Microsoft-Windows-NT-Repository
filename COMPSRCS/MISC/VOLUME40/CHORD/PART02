Newsgroups: comp.sources.misc
From: martin@canada.sun.com (Martin Leclerc - Sun Montreal SE)
Subject: v40i085:  chord - self-descriptive music sheet from text files, Part02/05
Message-ID: <1993Nov6.171547.8574@sparky.sterling.com>
X-Md4-Signature: d6fb1a1437044958847bb99ff494e982
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sat, 6 Nov 1993 17:15:47 GMT
Approved: kent@sparky.sterling.com

Submitted-by: martin@canada.sun.com (Martin Leclerc - Sun Montreal SE)
Posting-number: Volume 40, Issue 85
Archive-name: chord/part02
Environment: UNIX, DOS, VMS, Amiga

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  chord_guide.ps.A getopt.h
# Wrapped by kent@sparky on Tue Nov  2 17:49:45 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 5)."'
if test -f 'chord_guide.ps.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chord_guide.ps.A'\"
else
  echo shar: Extracting \"'chord_guide.ps.A'\" \(53713 characters\)
  sed "s/^X//" >'chord_guide.ps.A' <<'END_OF_FILE'
X%!
X%%BoundingBox: (atend)
X%%Pages: (atend)
X%%DocumentFonts: (atend)
X%%EndComments
X%
X% FrameMaker PostScript Prolog 3.0, for use with FrameMaker 3.0
X% Copyright (c) 1986,87,89,90,91 by Frame Technology Corporation.
X% All rights reserved.
X%
X% Known Problems:
X%	Due to bugs in Transcript, the 'PS-Adobe-' is omitted from line 1
X/FMversion (3.0) def 
X% Set up Color vs. Black-and-White
X	/FMPrintInColor systemdict /colorimage known
X		systemdict /currentcolortransfer known or def
X% Uncomment this line to force b&w on color printer
X%   /FMPrintInColor false def
X/FrameDict 195 dict def 
Xsystemdict /errordict known not {/errordict 10 dict def
X		errordict /rangecheck {stop} put} if
X% The readline in 23.0 doesn't recognize cr's as nl's on AppleTalk
XFrameDict /tmprangecheck errordict /rangecheck get put 
Xerrordict /rangecheck {FrameDict /bug true put} put 
XFrameDict /bug false put 
Xmark 
X% Some PS machines read past the CR, so keep the following 3 lines together!
Xcurrentfile 5 string readline
X00
X0000000000
Xcleartomark 
Xerrordict /rangecheck FrameDict /tmprangecheck get put 
XFrameDict /bug get { 
X	/readline {
X		/gstring exch def
X		/gfile exch def
X		/gindex 0 def
X		{
X			gfile read pop 
X			dup 10 eq {exit} if 
X			dup 13 eq {exit} if 
X			gstring exch gindex exch put 
X			/gindex gindex 1 add def 
X		} loop
X		pop 
X		gstring 0 gindex getinterval true 
X		} def
X	} if
X/FMVERSION {
X	FMversion ne {
X		/Times-Roman findfont 18 scalefont setfont
X		100 100 moveto
X		(FrameMaker version does not match postscript_prolog!)
X		dup =
X		show showpage
X		} if
X	} def 
X/FMLOCAL {
X	FrameDict begin
X	0 def 
X	end 
X	} def 
X	/gstring FMLOCAL
X	/gfile FMLOCAL
X	/gindex FMLOCAL
X	/orgxfer FMLOCAL
X	/orgproc FMLOCAL
X	/organgle FMLOCAL
X	/orgfreq FMLOCAL
X	/yscale FMLOCAL
X	/xscale FMLOCAL
X	/manualfeed FMLOCAL
X	/paperheight FMLOCAL
X	/paperwidth FMLOCAL
X/FMDOCUMENT { 
X	array /FMfonts exch def 
X	/#copies exch def
X	FrameDict begin
X	0 ne dup {setmanualfeed} if
X	/manualfeed exch def
X	/paperheight exch def
X	/paperwidth exch def
X	/yscale exch def
X	/xscale exch def
X	currenttransfer cvlit /orgxfer exch def
X	currentscreen cvlit /orgproc exch def
X	/organgle exch def /orgfreq exch def
X	setpapername 
X	manualfeed {true} {papersize} ifelse 
X	{manualpapersize} {false} ifelse 
X	{desperatepapersize} if
X	end 
X	} def 
X	/pagesave FMLOCAL
X	/orgmatrix FMLOCAL
X	/landscape FMLOCAL
X/FMBEGINPAGE { 
X	FrameDict begin 
X	/pagesave save def
X	3.86 setmiterlimit
X	/landscape exch 0 ne def
X	landscape { 
X		90 rotate 0 exch neg translate pop 
X		}
X		{pop pop}
X		ifelse
X	xscale yscale scale
X	/orgmatrix matrix def
X	gsave 
X	} def 
X/FMENDPAGE {
X	grestore 
X	pagesave restore
X	end 
X	showpage
X	} def 
X/FMFONTDEFINE { 
X	FrameDict begin
X	findfont 
X	ReEncode 
X	1 index exch 
X	definefont 
X	FMfonts 3 1 roll 
X	put
X	end 
X	} def 
X/FMFILLS {
X	FrameDict begin
X	array /fillvals exch def
X	end 
X	} def 
X/FMFILL {
X	FrameDict begin
X	 fillvals 3 1 roll put
X	end 
X	} def 
X/FMNORMALIZEGRAPHICS { 
X	newpath
X	0.0 0.0 moveto
X	1 setlinewidth
X	0 setlinecap
X	0 0 0 sethsbcolor
X	0 setgray 
X	} bind def
X	/fx FMLOCAL
X	/fy FMLOCAL
X	/fh FMLOCAL
X	/fw FMLOCAL
X	/llx FMLOCAL
X	/lly FMLOCAL
X	/urx FMLOCAL
X	/ury FMLOCAL
X/FMBEGINEPSF { 
X	end 
X	/FMEPSF save def 
X	/showpage {} def 
X	FMNORMALIZEGRAPHICS 
X	[/fy /fx /fh /fw /ury /urx /lly /llx] {exch def} forall 
X	fx fy translate 
X	rotate
X	fw urx llx sub div fh ury lly sub div scale 
X	llx neg lly neg translate 
X	} bind def
X/FMENDEPSF {
X	FMEPSF restore
X	FrameDict begin 
X	} bind def
XFrameDict begin 
X/setmanualfeed {
X%%BeginFeature *ManualFeed True
X	 statusdict /manualfeed true put
X%%EndFeature
X	} def
X/max {2 copy lt {exch} if pop} bind def
X/min {2 copy gt {exch} if pop} bind def
X/inch {72 mul} def
X/pagedimen { 
X	paperheight sub abs 16 lt exch 
X	paperwidth sub abs 16 lt and
X	{/papername exch def} {pop} ifelse
X	} def
X	/papersizedict FMLOCAL
X/setpapername { 
X	/papersizedict 14 dict def 
X	papersizedict begin
X	/papername /unknown def 
X		/Letter 8.5 inch 11.0 inch pagedimen
X		/LetterSmall 7.68 inch 10.16 inch pagedimen
X		/Tabloid 11.0 inch 17.0 inch pagedimen
X		/Ledger 17.0 inch 11.0 inch pagedimen
X		/Legal 8.5 inch 14.0 inch pagedimen
X		/Statement 5.5 inch 8.5 inch pagedimen
X		/Executive 7.5 inch 10.0 inch pagedimen
X		/A3 11.69 inch 16.5 inch pagedimen
X		/A4 8.26 inch 11.69 inch pagedimen
X		/A4Small 7.47 inch 10.85 inch pagedimen
X		/B4 10.125 inch 14.33 inch pagedimen
X		/B5 7.16 inch 10.125 inch pagedimen
X	end
X	} def
X/papersize {
X	papersizedict begin
X		/Letter {lettertray letter} def
X		/LetterSmall {lettertray lettersmall} def
X		/Tabloid {11x17tray 11x17} def
X		/Ledger {ledgertray ledger} def
X		/Legal {legaltray legal} def
X		/Statement {statementtray statement} def
X		/Executive {executivetray executive} def
X		/A3 {a3tray a3} def
X		/A4 {a4tray a4} def
X		/A4Small {a4tray a4small} def
X		/B4 {b4tray b4} def
X		/B5 {b5tray b5} def
X		/unknown {unknown} def
X	papersizedict dup papername known {papername} {/unknown} ifelse get
X	end
X	/FMdicttop countdictstack 1 add def 
X	statusdict begin stopped end 
X	countdictstack -1 FMdicttop {pop end} for 
X	} def
X/manualpapersize {
X	papersizedict begin
X		/Letter {letter} def
X		/LetterSmall {lettersmall} def
X		/Tabloid {11x17} def
X		/Ledger {ledger} def
X		/Legal {legal} def
X		/Statement {statement} def
X		/Executive {executive} def
X		/A3 {a3} def
X		/A4 {a4} def
X		/A4Small {a4small} def
X		/B4 {b4} def
X		/B5 {b5} def
X		/unknown {unknown} def
X	papersizedict dup papername known {papername} {/unknown} ifelse get
X	end
X	stopped 
X	} def
X/desperatepapersize {
X	statusdict /setpageparams known
X		{
X		paperwidth paperheight 0 1 
X		statusdict begin
X		{setpageparams} stopped pop 
X		end
X		} if
X	} def
X/savematrix {
X	orgmatrix currentmatrix pop
X	} bind def
X/restorematrix {
X	orgmatrix setmatrix
X	} bind def
X/dmatrix matrix def
X/dpi    72 0 dmatrix defaultmatrix dtransform
X    dup mul exch   dup mul add   sqrt def
X/freq dpi 18.75 div 8 div round dup 0 eq {pop 1} if 8 mul dpi exch div def
X/sangle 1 0 dmatrix defaultmatrix dtransform exch atan def
X/DiacriticEncoding [
X/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X/.notdef /.notdef /.notdef /.notdef /space /exclam /quotedbl
X/numbersign /dollar /percent /ampersand /quotesingle /parenleft
X/parenright /asterisk /plus /comma /hyphen /period /slash /zero /one
X/two /three /four /five /six /seven /eight /nine /colon /semicolon
X/less /equal /greater /question /at /A /B /C /D /E /F /G /H /I /J /K
X/L /M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft /backslash
X/bracketright /asciicircum /underscore /grave /a /b /c /d /e /f /g /h
X/i /j /k /l /m /n /o /p /q /r /s /t /u /v /w /x /y /z /braceleft /bar
X/braceright /asciitilde /.notdef /Adieresis /Aring /Ccedilla /Eacute
X/Ntilde /Odieresis /Udieresis /aacute /agrave /acircumflex /adieresis
X/atilde /aring /ccedilla /eacute /egrave /ecircumflex /edieresis
X/iacute /igrave /icircumflex /idieresis /ntilde /oacute /ograve
X/ocircumflex /odieresis /otilde /uacute /ugrave /ucircumflex
X/udieresis /dagger /.notdef /cent /sterling /section /bullet
X/paragraph /germandbls /registered /copyright /trademark /acute
X/dieresis /.notdef /AE /Oslash /.notdef /.notdef /.notdef /.notdef
X/yen /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef
X/ordfeminine /ordmasculine /.notdef /ae /oslash /questiondown
X/exclamdown /logicalnot /.notdef /florin /.notdef /.notdef
X/guillemotleft /guillemotright /ellipsis /.notdef /Agrave /Atilde
X/Otilde /OE /oe /endash /emdash /quotedblleft /quotedblright
X/quoteleft /quoteright /.notdef /.notdef /ydieresis /Ydieresis
X/fraction /currency /guilsinglleft /guilsinglright /fi /fl /daggerdbl
X/periodcentered /quotesinglbase /quotedblbase /perthousand
X/Acircumflex /Ecircumflex /Aacute /Edieresis /Egrave /Iacute
X/Icircumflex /Idieresis /Igrave /Oacute /Ocircumflex /.notdef /Ograve
X/Uacute /Ucircumflex /Ugrave /dotlessi /circumflex /tilde /macron
X/breve /dotaccent /ring /cedilla /hungarumlaut /ogonek /caron
X] def
X/ReEncode { 
X	dup 
X	length 
X	dict begin 
X	{
X	1 index /FID ne 
X		{def} 
X		{pop pop} ifelse 
X	} forall 
X	0 eq {/Encoding DiacriticEncoding def} if 
X	currentdict 
X	end 
X	} bind def
X/graymode true def
X	/bwidth FMLOCAL
X	/bpside FMLOCAL
X	/bstring FMLOCAL
X	/onbits FMLOCAL
X	/offbits FMLOCAL
X	/xindex FMLOCAL
X	/yindex FMLOCAL
X	/x FMLOCAL
X	/y FMLOCAL
X/setpattern {
X	 /bwidth  exch def
X	 /bpside  exch def
X	 /bstring exch def
X	 /onbits 0 def  /offbits 0 def
X	 freq sangle landscape {90 add} if 
X		{/y exch def
X		 /x exch def
X		 /xindex x 1 add 2 div bpside mul cvi def
X		 /yindex y 1 add 2 div bpside mul cvi def
X		 bstring yindex bwidth mul xindex 8 idiv add get
X		 1 7 xindex 8 mod sub bitshift and 0 ne
X		 {/onbits  onbits  1 add def 1}
X		 {/offbits offbits 1 add def 0}
X		 ifelse
X		}
X		setscreen
X	 {} settransfer
X	 offbits offbits onbits add div FMsetgray
X	/graymode false def
X	} bind def
X/grayness {
X	FMsetgray
X	graymode not {
X		/graymode true def
X		orgxfer cvx settransfer
X		orgfreq organgle orgproc cvx setscreen
X		} if
X	} bind def
X	/HUE FMLOCAL
X	/SAT FMLOCAL
X	/BRIGHT FMLOCAL
X	/Colors FMLOCAL
XFMPrintInColor 
X	
X	{
X	/HUE 0 def
X	/SAT 0 def
X	/BRIGHT 0 def
X	% array of arrays Hue and Sat values for the separations [HUE BRIGHT]
X	/Colors   
X	[[0    0  ]    % black
X	 [0    0  ]    % white
X	 [0.00 1.0]    % red
X	 [0.37 1.0]    % green
X	 [0.60 1.0]    % blue
X	 [0.50 1.0]    % cyan
X	 [0.83 1.0]    % magenta
X	 [0.16 1.0]    % comment / yellow
X	 ] def
X      
X	/BEGINBITMAPCOLOR { 
X		BITMAPCOLOR} def
X	/BEGINBITMAPCOLORc { 
X		BITMAPCOLORc} def
X	/BEGINBITMAPTRUECOLOR { 
X		BITMAPTRUECOLOR } def
X	/BEGINBITMAPTRUECOLORc { 
X		BITMAPTRUECOLORc } def
X	/K { 
X		Colors exch get dup
X		0 get /HUE exch store 
X		1 get /BRIGHT exch store
X		  HUE 0 eq BRIGHT 0 eq and
X			{1.0 SAT sub setgray}
X			{HUE SAT BRIGHT sethsbcolor} 
X		  ifelse
X		} def
X	/FMsetgray { 
X		/SAT exch 1.0 exch sub store 
X		  HUE 0 eq BRIGHT 0 eq and
X			{1.0 SAT sub setgray}
X			{HUE SAT BRIGHT sethsbcolor} 
X		  ifelse
X		} bind def
X	}
X	
X	{
X	/BEGINBITMAPCOLOR { 
X		BITMAPGRAY} def
X	/BEGINBITMAPCOLORc { 
X		BITMAPGRAYc} def
X	/BEGINBITMAPTRUECOLOR { 
X		BITMAPTRUEGRAY } def
X	/BEGINBITMAPTRUECOLORc { 
X		BITMAPTRUEGRAYc } def
X	/FMsetgray {setgray} bind def
X	/K { 
X		pop
X		} def
X	}
Xifelse
X/normalize {
X	transform round exch round exch itransform
X	} bind def
X/dnormalize {
X	dtransform round exch round exch idtransform
X	} bind def
X/lnormalize { 
X	0 dtransform exch cvi 2 idiv 2 mul 1 add exch idtransform pop
X	} bind def
X/H { 
X	lnormalize setlinewidth
X	} bind def
X/Z {
X	setlinecap
X	} bind def
X	/fillvals FMLOCAL
X/X { 
X	fillvals exch get
X	dup type /stringtype eq
X	{8 1 setpattern} 
X	{grayness}
X	ifelse
X	} bind def
X/V { 
X	gsave eofill grestore
X	} bind def
X/N { 
X	stroke
X	} bind def
X/M {newpath moveto} bind def
X/E {lineto} bind def
X/D {curveto} bind def
X/O {closepath} bind def
X	/n FMLOCAL
X/L { 
X 	/n exch def
X	newpath
X	normalize
X	moveto 
X	2 1 n {pop normalize lineto} for
X	} bind def
X/Y { 
X	L 
X	closepath
X	} bind def
X	/x1 FMLOCAL
X	/x2 FMLOCAL
X	/y1 FMLOCAL
X	/y2 FMLOCAL
X	/rad FMLOCAL
X/R { 
X	/y2 exch def
X	/x2 exch def
X	/y1 exch def
X	/x1 exch def
X	x1 y1
X	x2 y1
X	x2 y2
X	x1 y2
X	4 Y 
X	} bind def
X/RR { 
X	/rad exch def
X	normalize
X	/y2 exch def
X	/x2 exch def
X	normalize
X	/y1 exch def
X	/x1 exch def
X	newpath
X	x1 y1 rad add moveto
X	x1 y2 x2 y2 rad arcto
X	x2 y2 x2 y1 rad arcto
X	x2 y1 x1 y1 rad arcto
X	x1 y1 x1 y2 rad arcto
X	closepath
X	16 {pop} repeat
X	} bind def
X/C { 
X	grestore
X	gsave
X	R 
X	clip
X	} bind def
X	/FMpointsize FMLOCAL
X/F { 
X	FMfonts exch get
X	FMpointsize scalefont
X	setfont
X	} bind def
X/Q { 
X	/FMpointsize exch def
X	F 
X	} bind def
X/T { 
X	moveto show
X	} bind def
X/RF { 
X	rotate
X	0 ne {-1 1 scale} if
X	} bind def
X/TF { 
X	gsave
X	moveto 
X	RF
X	show
X	grestore
X	} bind def
X/P { 
X	moveto
X	0 32 3 2 roll widthshow
X	} bind def
X/PF { 
X	gsave
X	moveto 
X	RF
X	0 32 3 2 roll widthshow
X	grestore
X	} bind def
X/S { 
X	moveto
X	0 exch ashow
X	} bind def
X/SF { 
X	gsave
X	moveto
X	RF
X	0 exch ashow
X	grestore
X	} bind def
X/B { 
X	moveto
X	0 32 4 2 roll 0 exch awidthshow
X	} bind def
X/BF { 
X	gsave
X	moveto
X	RF
X	0 32 4 2 roll 0 exch awidthshow
X	grestore
X	} bind def
X/G { 
X	gsave
X	newpath
X	normalize translate 0.0 0.0 moveto 
X	dnormalize scale 
X	0.0 0.0 1.0 5 3 roll arc 
X	closepath fill
X	grestore
X	} bind def
X/A { 
X	gsave
X	savematrix
X	newpath
X	2 index 2 div add exch 3 index 2 div sub exch 
X	normalize 2 index 2 div sub exch 3 index 2 div add exch 
X	translate 
X	scale 
X	0.0 0.0 1.0 5 3 roll arc 
X	restorematrix
X	stroke
X	grestore
X	} bind def
X	/x FMLOCAL
X	/y FMLOCAL
X	/w FMLOCAL
X	/h FMLOCAL
X	/xx FMLOCAL
X	/yy FMLOCAL
X	/ww FMLOCAL
X	/hh FMLOCAL
X	/FMsaveobject FMLOCAL
X	/FMoptop FMLOCAL
X	/FMdicttop FMLOCAL
X/BEGINPRINTCODE { 
X	/FMdicttop countdictstack 1 add def 
X	/FMoptop count 4 sub def 
X	/FMsaveobject save def
X	userdict begin 
X	/showpage {} def 
X	FMNORMALIZEGRAPHICS 
X	3 index neg 3 index neg translate
X	} bind def
X/ENDPRINTCODE {
X	count -1 FMoptop {pop pop} for 
X	countdictstack -1 FMdicttop {pop end} for 
X	FMsaveobject restore 
X	} bind def
X/gn { 
X	0 
X	{	46 mul 
X		cf read pop 
X		32 sub 
X		dup 46 lt {exit} if 
X		46 sub add 
X		} loop
X	add 
X	} bind def
X	/str FMLOCAL
X/cfs { 
X	/str sl string def 
X	0 1 sl 1 sub {str exch val put} for 
X	str def 
X	} bind def
X/ic [ 
X	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
X	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0223
X	0
X	{0 hx} {1 hx} {2 hx} {3 hx} {4 hx} {5 hx} {6 hx} {7 hx} {8 hx} {9 hx}
X	{10 hx} {11 hx} {12 hx} {13 hx} {14 hx} {15 hx} {16 hx} {17 hx} {18 hx}
X	{19 hx} {gn hx} {0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}
X	{13} {14} {15} {16} {17} {18} {19} {gn} {0 wh} {1 wh} {2 wh} {3 wh}
X	{4 wh} {5 wh} {6 wh} {7 wh} {8 wh} {9 wh} {10 wh} {11 wh} {12 wh}
X	{13 wh} {14 wh} {gn wh} {0 bl} {1 bl} {2 bl} {3 bl} {4 bl} {5 bl} {6 bl}
X	{7 bl} {8 bl} {9 bl} {10 bl} {11 bl} {12 bl} {13 bl} {14 bl} {gn bl}
X	{0 fl} {1 fl} {2 fl} {3 fl} {4 fl} {5 fl} {6 fl} {7 fl} {8 fl} {9 fl}
X	{10 fl} {11 fl} {12 fl} {13 fl} {14 fl} {gn fl}
X	] def
X	/sl FMLOCAL
X	/val FMLOCAL
X	/ws FMLOCAL
X	/im FMLOCAL
X	/bs FMLOCAL
X	/cs FMLOCAL
X	/len FMLOCAL
X	/pos FMLOCAL
X/ms { 
X	/sl exch def 
X	/val 255 def 
X	/ws cfs 
X	/im cfs 
X	/val 0 def 
X	/bs cfs 
X	/cs cfs 
X	} bind def
X400 ms 
X/ip { 
X	is 
X	0 
X	cf cs readline pop 
X	{	ic exch get exec 
X		add 
X		} forall 
X	pop 
X	
X	} bind def
X/wh { 
X	/len exch def 
X	/pos exch def 
X	ws 0 len getinterval im pos len getinterval copy pop
X	pos len 
X	} bind def
X/bl { 
X	/len exch def 
X	/pos exch def 
X	bs 0 len getinterval im pos len getinterval copy pop
X	pos len 
X	} bind def
X/s1 1 string def
X/fl { 
X	/len exch def 
X	/pos exch def 
X	/val cf s1 readhexstring pop 0 get def
X	pos 1 pos len add 1 sub {im exch val put} for
X	pos len 
X	} bind def
X/hx { 
X	3 copy getinterval 
X	cf exch readhexstring pop pop 
X	} bind def
X	/h FMLOCAL
X	/w FMLOCAL
X	/d FMLOCAL
X	/lb FMLOCAL
X	/bitmapsave FMLOCAL
X	/is FMLOCAL
X	/cf FMLOCAL
X/wbytes { 
X	dup 
X	8 eq {pop} {1 eq {7 add 8 idiv} {3 add 4 idiv} ifelse} ifelse
X	} bind def
X/BEGINBITMAPBWc { 
X	1 {} COMMONBITMAPc
X	} bind def
X/BEGINBITMAPGRAYc { 
X	8 {} COMMONBITMAPc
X	} bind def
X/BEGINBITMAP2BITc { 
X	2 {} COMMONBITMAPc
X	} bind def
X/COMMONBITMAPc { 
X	/r exch def
X	/d exch def
X	gsave
X	translate rotate scale /h exch def /w exch def
X	/lb w d wbytes def 
X	sl lb lt {lb ms} if 
X	/bitmapsave save def 
X	r                    
X	/is im 0 lb getinterval def 
X	ws 0 lb getinterval is copy pop 
X	/cf currentfile def 
X	w h d [w 0 0 h neg 0 h] 
X	{ip} image 
X	bitmapsave restore 
X	grestore
X	} bind def
X/BEGINBITMAPBW { 
X	1 {} COMMONBITMAP
X	} bind def
X/BEGINBITMAPGRAY { 
X	8 {} COMMONBITMAP
X	} bind def
X/BEGINBITMAP2BIT { 
X	2 {} COMMONBITMAP
X	} bind def
X/COMMONBITMAP { 
X	/r exch def
X	/d exch def
X	gsave
X	translate rotate scale /h exch def /w exch def
X	/bitmapsave save def 
X	r                    
X	/is w d wbytes string def
X	/cf currentfile def 
X	w h d [w 0 0 h neg 0 h] 
X	{cf is readhexstring pop} image
X	bitmapsave restore 
X	grestore
X	} bind def
X	/proc1 FMLOCAL
X	/proc2 FMLOCAL
X	/newproc FMLOCAL
X/Fmcc {
X    /proc2 exch cvlit def
X    /proc1 exch cvlit def
X    /newproc proc1 length proc2 length add array def
X    newproc 0 proc1 putinterval
X    newproc proc1 length proc2 putinterval
X    newproc cvx
X} bind def
X/ngrayt 256 array def
X/nredt 256 array def
X/nbluet 256 array def
X/ngreent 256 array def
X	/gryt FMLOCAL
X	/blut FMLOCAL
X	/grnt FMLOCAL
X	/redt FMLOCAL
X	/indx FMLOCAL
X	/cynu FMLOCAL
X	/magu FMLOCAL
X	/yelu FMLOCAL
X	/k FMLOCAL
X	/u FMLOCAL
X/colorsetup {
X	currentcolortransfer
X	/gryt exch def
X	/blut exch def
X	/grnt exch def
X	/redt exch def
X	0 1 255 {
X		/indx exch def
X		/cynu 1 red indx get 255 div sub def
X		/magu 1 green indx get 255 div sub def
X		/yelu 1 blue indx get 255 div sub def
X		/k cynu magu min yelu min def
X		/u k currentundercolorremoval exec def
X		nredt indx 1 0 cynu u sub max sub redt exec put
X		ngreent indx 1 0 magu u sub max sub grnt exec put
X		nbluet indx 1 0 yelu u sub max sub blut exec put
X		ngrayt indx 1 k currentblackgeneration exec sub gryt exec put
X	} for
X	{255 mul cvi nredt exch get}
X	{255 mul cvi ngreent exch get}
X	{255 mul cvi nbluet exch get}
X	{255 mul cvi ngrayt exch get}
X	setcolortransfer
X	{pop 0} setundercolorremoval
X	{} setblackgeneration
X	} bind def
X	/tran FMLOCAL
X/fakecolorsetup {
X	/tran 256 string def
X	0 1 255 {/indx exch def 
X		tran indx
X		red indx get 77 mul
X		green indx get 151 mul
X		blue indx get 28 mul
X		add add 256 idiv put} for
X	currenttransfer
X	{255 mul cvi tran exch get 255.0 div}
X	exch Fmcc settransfer
X} bind def
X/BITMAPCOLOR { 
X	/d 8 def
X	gsave
X	translate rotate scale /h exch def /w exch def
X	/bitmapsave save def 
X	colorsetup
X	/is w d wbytes string def
X	/cf currentfile def 
X	w h d [w 0 0 h neg 0 h] 
X	{cf is readhexstring pop} {is} {is} true 3 colorimage 
X	bitmapsave restore 
X	grestore
X	} bind def
X/BITMAPCOLORc { 
X	/d 8 def
X	gsave
X	translate rotate scale /h exch def /w exch def
X	/lb w d wbytes def 
X	sl lb lt {lb ms} if 
X	/bitmapsave save def 
X	colorsetup
X	/is im 0 lb getinterval def 
X	ws 0 lb getinterval is copy pop 
X	/cf currentfile def 
X	w h d [w 0 0 h neg 0 h] 
X	{ip} {is} {is} true 3 colorimage
X	bitmapsave restore 
X	grestore
X	} bind def
X/BITMAPTRUECOLORc { 
X        gsave
X        translate rotate scale /h exch def /w exch def
X        /bitmapsave save def 
X        
X        /is w string def
X        
X        ws 0 w getinterval is copy pop 
X        /cf currentfile def 
X        w h 8 [w 0 0 h neg 0 h] 
X        {ip} {gip} {bip} true 3 colorimage
X        bitmapsave restore 
X        grestore
X        } bind def
X/BITMAPTRUECOLOR { 
X        gsave
X        translate rotate scale /h exch def /w exch def
X        /bitmapsave save def 
X        /is w string def
X        /gis w string def
X        /bis w string def
X        /cf currentfile def 
X        w h 8 [w 0 0 h neg 0 h] 
X        { cf is readhexstring pop } 
X        { cf gis readhexstring pop } 
X        { cf bis readhexstring pop } 
X        true 3 colorimage 
X        bitmapsave restore 
X        grestore
X        } bind def
X/BITMAPTRUEGRAYc { 
X        gsave
X        translate rotate scale /h exch def /w exch def
X        /bitmapsave save def 
X        
X        /is w string def
X        
X        ws 0 w getinterval is copy pop 
X        /cf currentfile def 
X        w h 8 [w 0 0 h neg 0 h] 
X        {ip gip bip w gray} image
X        bitmapsave restore 
X        grestore
X        } bind def
X/ww FMLOCAL
X/r FMLOCAL
X/g FMLOCAL
X/b FMLOCAL
X/i FMLOCAL
X/gray { 
X        /ww exch def
X        /b exch def
X        /g exch def
X        /r exch def
X        0 1 ww 1 sub { /i exch def r i get .299 mul g i get .587 mul
X			b i get .114 mul add add r i 3 -1 roll floor cvi put } for
X        r
X        } bind def
X/BITMAPTRUEGRAY { 
X        gsave
X        translate rotate scale /h exch def /w exch def
X        /bitmapsave save def 
X        /is w string def
X        /gis w string def
X        /bis w string def
X        /cf currentfile def 
X        w h 8 [w 0 0 h neg 0 h] 
X        { cf is readhexstring pop 
X          cf gis readhexstring pop 
X          cf bis readhexstring pop w gray}  image
X        bitmapsave restore 
X        grestore
X        } bind def
X/BITMAPGRAY { 
X	8 {fakecolorsetup} COMMONBITMAP
X	} bind def
X/BITMAPGRAYc { 
X	8 {fakecolorsetup} COMMONBITMAPc
X	} bind def
X/ENDBITMAP {
X	} bind def
Xend 
X	/ALDsave FMLOCAL
X	/ALDmatrix matrix def ALDmatrix currentmatrix pop
X/StartALD {
X	/ALDsave save def
X	 savematrix
X	 ALDmatrix setmatrix
X	} bind def
X/InALD {
X	 restorematrix
X	} bind def
X/DoneALD {
X	 ALDsave restore
X	} bind def
X%%EndProlog
X%%BeginSetup
X(3.0) FMVERSION
X1 1 612 792 0 1 13 FMDOCUMENT
X0 0 /Helvetica-Bold FMFONTDEFINE
X1 0 /Times-Roman FMFONTDEFINE
X2 0 /Times-Bold FMFONTDEFINE
X3 0 /Helvetica FMFONTDEFINE
X4 0 /Courier FMFONTDEFINE
X5 0 /Courier-Bold FMFONTDEFINE
X6 0 /ZapfChancery-MediumItalic FMFONTDEFINE
X7 0 /Bookman-Demi FMFONTDEFINE
X8 0 /Bookman-Light FMFONTDEFINE
X32 FMFILLS
X0 0 FMFILL
X1 0.1 FMFILL
X2 0.3 FMFILL
X3 0.5 FMFILL
X4 0.7 FMFILL
X5 0.9 FMFILL
X6 0.97 FMFILL
X7 1 FMFILL
X8 <0f1e3c78f0e1c387> FMFILL
X9 <0f87c3e1f0783c1e> FMFILL
X10 <cccccccccccccccc> FMFILL
X11 <ffff0000ffff0000> FMFILL
X12 <8142241818244281> FMFILL
X13 <03060c183060c081> FMFILL
X14 <8040201008040201> FMFILL
X16 1 FMFILL
X17 0.9 FMFILL
X18 0.7 FMFILL
X19 0.5 FMFILL
X20 0.3 FMFILL
X21 0.1 FMFILL
X22 0.03 FMFILL
X23 0 FMFILL
X24 <f0e1c3870f1e3c78> FMFILL
X25 <f0783c1e0f87c3e1> FMFILL
X26 <3333333333333333> FMFILL
X27 <0000ffff0000ffff> FMFILL
X28 <7ebddbe7e7dbbd7e> FMFILL
X29 <fcf9f3e7cf9f3f7e> FMFILL
X30 <7fbfdfeff7fbfdfe> FMFILL
X%%EndSetup
X%%Page: "15" 16
X%%BeginPaperSize: Letter
X%%EndPaperSize
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-15-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X1 14 Q
X( -t text_font size) 72 710.67 T
X( Sets the size, in points, of the font used to display the lyrics to the) 108 694.67 T
X(speci\336ed integer value. The title line is displayed using that point size) 108 678.67 T
X(+ 5. The sub-title is displayed using that point size -2.) 108 662.67 T
X( -T T) 72 625.67 T
X(ext_font) 99.78 625.67 T
X( Sets the font used to print text to the speci\336ed name. That name must) 108 609.67 T
X(be known to your PostScript Interpreter) 108 593.67 T
X(.) 329.13 593.67 T
X( -V) 72 556.67 T
X(Prints version and patch level) 108 540.67 T
X( -x halftones) 72 503.67 T
X-0.2 ( Sets up transposition to that number of halftones. Can not be zero. All) 108 487.67 P
X(CHORD names must be build in the following way in order to be rec-) 108 471.67 T
X(ognized:) 108 455.67 T
X( {note-name}[#|b][^/]* [ \324/\325 {note-name}[#|b][^/]* ]) 108 418.67 T
X( That is, a valid note name, possibly followed by \324#\325 or \324b\325, followed) 108 376.67 T
X-0.18 (by other modi\336er \050\3247\325, \324m\325, etc...\051. Many such construct can make up a) 108 360.67 P
X(CHORD name, as long as they are separated by \324/\325.) 108 344.67 T
X( {note-name} must appear in the list \324A) 108 302.67 T
X(\325,\325B\325,\325C\325,\325D\325,\325E\325,\325F\325,\325G\325.) 327.79 302.67 T
X(-2) 72 260.67 T
X(Prints two logical pages per physical page.) 108 244.67 T
X( -4) 72 207.67 T
X(Prints four logical pages per physical page.) 108 191.67 T
XFMENDPAGE
X%%EndPage: "15" 15
X%%Page: "14" 15
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-14-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X1 14 Q
X( - g) 72 710.67 T
X(Disable printing of grids for \322easy\323 chords.) 108 694.67 T
X(Whether a built-in chord is easy or not has been arbitrarily decided by) 108 662.67 T
X(the authors. The general rule was that any chord in its major) 108 646.67 T
X(, minor) 443.97 646.67 T
X(,) 483.83 646.67 T
X(7th or minor 7th was \322easy\323 while everything else \050maj7, aug, dim,) 108 630.67 T
X-0.5 (sus, etc...\051 was \322tough\323. All chords de\336ned in the $HOME/.chordrc \336le) 108 614.67 P
X(or in the input \336le are de\336ned as \322tough\323.) 108 598.67 T
X( -h) 72 561.67 T
X(Prints a short options summary) 108 545.67 T
X(.) 281.23 545.67 T
X( -i) 72 508.67 T
X(Generates a table of contents with the song titles and page numbers. It) 108 492.67 T
X(implies page numbering through the document. Index pages are not) 108 476.67 T
X(numbered.) 108 460.67 T
X( -L) 72 423.67 T
X(Places the odd page numbers on the left.) 108 407.67 T
X( -l) 72 370.67 T
X(Prints only the lyrics of the song.) 108 354.67 T
X( -o \336lename) 72 317.67 T
X( Sends output to <\336lename>.) 108 301.67 T
X( -p \336rst_page) 72 264.67 T
X( Numbers the pages consecutively starting with \336rst_page \050e.g. 1\051.) 108 248.67 T
X(W) 108 232.67 T
X(ithout this option, each song restarts the page numbering at 1, and) 120.65 232.67 T
X(page numbers are only put on subsequent pages of multiple page) 108 216.67 T
X(songs.) 108 200.67 T
X( -R) 72 163.67 T
X(Places the odd and even page numbers in the lower right and left cor-) 108 147.67 T
X(ners respectively \050for two-sided output\051. The default is all page num-) 108 131.67 T
X(bers on the right.) 108 115.67 T
XFMENDPAGE
X%%EndPage: "14" 14
X%%Page: "13" 14
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-13-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X2 14 Q
X(Options and Switches) 72 710.67 T
X1 F
X(Here are the options you can specify when invoking CHORD;) 72 673.67 T
X( -A) 72 657.67 T
X(W) 108 641.67 T
X(ill print the \322About CHORD...\323 message.) 120.65 641.67 T
X( -a) 72 604.67 T
X(Automatically single spaces lines that have no chords.) 108 588.67 T
X( -c CHORD_font size) 72 551.67 T
X( Sets the size, in points, of the font used to display chords to the speci-) 108 535.67 T
X(\336ed integer value.) 108 519.67 T
X( -C CHORD_font) 72 477.67 T
X( Sets the font used to print chords to the speci\336ed name. That name) 108 461.67 T
X(must be known to your PostScript Interpreter) 108 445.67 T
X(.) 359.85 445.67 T
X( -d) 72 408.67 T
X-0.31 ( Generates a text Chord Chart of all internally known chords as well as) 108 392.67 P
X(chords de\336ned in the $HOME/.chordrc \336le. Chords de\336ned in the) 108 376.67 T
X(.chordrc \336le are identi\336ed with the \322\050local\051\323 caption. The printout is) 108 360.67 T
X(suitable for input to the .chordrc \336le.) 108 344.67 T
X( -D) 72 307.67 T
X(Generates a PostScript Chord Chart of all internally known chords as) 108 291.67 T
X(well as chords de\336ned in the $HOME/.chordrc \336le. chords de\336ned in) 108 275.67 T
X-0.16 (the .chordrc \336le are identi\336ed with a small asterisk after the chord grid.) 108 259.67 P
X( -s grid_size) 72 222.67 T
X( Sets the size of the chord grids.) 108 206.67 T
X( -G) 72 169.67 T
X(Disable printing of the chord grids for the whole input \336le\050s\051. The) 108 153.67 T
X-0.19 (ef) 108 137.67 P
X-0.19 (fect can be disable for any particular song by the usage of the grid or) 118.62 137.67 P
X(g directive.) 108 121.67 T
XFMENDPAGE
X%%EndPage: "13" 13
X%%Page: "12" 13
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-12-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X2 14 Q
X(How do I install) 72 710.67 T
X3 12 Q
X(CHORD) 170.74 710.67 T
X2 14 Q
X( on my machine?) 214.71 710.67 T
X3 12 Q
X(CHORD) 72 689.67 T
X1 14 Q
X( is distributed in source format. That means you will need to compile it on) 115.97 689.67 T
X-0.27 (your machine. Doing so requires a C compiler) 72 673.67 P
X-0.27 (. This compiler can implement one of) 328.15 673.67 P
X(two norms about the C language: ANSI or K&R. Both types of compilers will do,) 72 657.67 T
X(but we prefer the \336rst type.) 72 641.67 T
X-0.11 (The \336rst step is to modify the \336le called \322Make\336le\323 to let the system know of some) 72 609.67 P
X(basic preferences:) 72 593.67 T
X(1. If you are running on a system that has a routine called \322getopt\323, make sure the) 72 561.67 T
X(line that says) 72 545.67 T
X4 12 Q
X(GETOPT = getopt.o) 90 531 T
X1 14 Q
X(is commented OUT) 72 515.67 T
X(. T) 181.34 515.67 T
X(o do so, add a \324#\325 at the very beginning of the line. If you do) 195.9 515.67 T
X(not know what we are talking about you should leave the line untouched.) 72 499.67 T
X(2. Select ONE format of paper: US \0508.5 by 1) 72 467.67 T
X(1 inches\051 or A4. The other line should) 321.36 467.67 T
X(be commented out, as outlined in the previous point.) 72 451.67 T
X-0.21 (3. Select the directory in which) 72 419.67 P
X3 12 Q
X-0.2 (CHORD) 249.14 419.67 P
X1 14 Q
X-0.21 ( will be installed, by modifying the value of) 293.11 419.67 P
X(the variable BINDIR. In case of doubt, leave the line unchanged.) 72 403.67 T
X(4.Select the directory in which the manual page for) 72 371.67 T
X3 12 Q
X(CHORD) 361.89 371.67 T
X1 14 Q
X( will be installed, by) 405.86 371.67 T
X(modifying the value of the variable MANDIR. In case of doubt, leave the line) 72 355.67 T
X(unchanged.) 72 339.67 T
X(Save the Make\336le \336le, and invoke the \322make\323 utility) 72 291.67 T
X4 12 Q
X(% make) 90 277 T
X1 14 Q
X(This should build the) 72 245.67 T
X3 12 Q
X(CHORD) 194.05 245.67 T
X1 14 Q
X( utility correctly) 238.02 245.67 T
X(. If you have problems at this point,) 327.28 245.67 T
X(\336rst try to contact someone who may be an experienced system administrator or) 72 229.67 T
X(programmer for assistance. If all else fails, send a detailed message to the authors,) 72 213.67 T
X(and they will do their best to help) 72 197.67 T
X(If the \322make\323 succeeded, invoke) 72 165.67 T
X4 12 Q
X(% make install) 90 151 T
X1 14 Q
X(to have the utility installed in the right spot. Y) 72 135.67 T
X(ou could also manually install the) 328.69 135.67 T
X(CHORD binary in the location of your choice.) 72 119.67 T
X(Included with the distribution are two sample \336les, under the \322song\323 subdirectory) 72 87.67 T
X(.) 527.34 87.67 T
XFMENDPAGE
X%%EndPage: "12" 12
X%%Page: "11" 12
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-11-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X2 14 Q
X(Wher) 72 710.67 T
X(e to \336nd CHORD \336les) 105.94 710.67 T
X1 F
X(CHORD having been around since 1991 there is a number of CHORD input \336les) 72 689.67 T
X(freely available if you have access to the Internet.) 72 673.67 T
X2 F
X(FTP) 353.32 673.67 T
X(.NEV) 378.46 673.67 T
X(ADA.EDU) 409.69 673.67 T
X1 F
X(\050131.216.1.1) 72 657.67 T
X(1\051 contains chord and tab \336les for a great many pop and traditional) 142.6 657.67 T
X(songs. Many of the songs are in CHORD format. Look for \336le with the extensions) 72 641.67 T
X(CRD, .CHO, .CRDPRO, .CHOPRO or .CHORDPRO. The songs are in the direc-) 72 625.67 T
X(tory /pub/guitar) 72 609.67 T
X(. This site is available for anonymous FTP) 158.68 609.67 T
X(.) 394.21 609.67 T
X(The following USENET newsgroup are often used to post or request chord and tab) 72 577.67 T
X(\336les:) 72 561.67 T
X2 F
X( r) 99.21 561.67 T
X(ec.music.makers.guitar) 108.67 561.67 T
X(.tablatur) 246.12 561.67 T
X(e) 298.34 561.67 T
X1 F
X(,) 304.55 561.67 T
X2 F
X(alt.guitar) 311.55 561.67 T
X(.tab) 365.84 561.67 T
X(The authors) 72 531.67 T
X1 F
X(CHORD has been developed by Martin Leclerc and Mario Dorion, both systems) 72 510.67 T
X(engineer with the Montr\216al \050Canada\051 subsidiary of Sun Microsystems. W) 72 494.67 T
X(e\325re still) 481.26 494.67 T
X(developing and supporting CHORD.) 72 478.67 T
X(Feel free to contact us via e-mail to suggest improvements and report bug \336xes.) 72 446.67 T
X(Our email addresses are) 72 430.67 T
X2 F
X(Martin.Lecler) 209.54 430.67 T
X(c@Sun.Com) 293.61 430.67 T
X1 F
X( and) 368.43 430.67 T
X2 F
X(Mario.Dorion@Sun.Com) 72 414.67 T
X(Copyright) 72 384.67 T
X1 F
X(CHORD is a Share-W) 72 363.67 T
X(are that is licensed following the conditions of the general) 195.62 363.67 T
X(GNU license. Y) 72 347.67 T
X(ou are authorized to use this program free of char) 160.36 347.67 T
X(ge. Y) 436.37 347.67 T
X(ou are autho-) 465.28 347.67 T
X-0.12 (rized to distribute this program freely as long as the full source is included. Y) 72 331.67 P
X-0.12 (ou are) 502.17 331.67 P
X-0.16 (not allowed to remove the \324copyright\325 notices from the authors nor are you allowed) 72 315.67 P
X-0.29 (to pretend you wrote it. Y) 72 299.67 P
X-0.29 (ou are not allowed to char) 213.73 299.67 P
X-0.29 (ge any money for CHORD. Y) 357.76 299.67 P
X-0.29 (ou) 522.8 299.67 P
X(are not allowed to use parts of CHORD in any other commercial or public-domain) 72 283.67 T
X(software.) 72 267.67 T
X-0.5 (As we said, CHORD is a Share-W) 72 235.67 P
X-0.5 (are. The authors spent a great deal of time making) 260.99 235.67 P
X(it as feature-full and usable as possible. If you like this program, please take the) 72 219.67 T
X(time to send a postcard from your home town or locality to each of the two authors) 72 203.67 T
X(and let them know what you think of CHORD. Please send the cards to the follow-) 72 187.67 T
X(ing addresses:) 72 171.67 T
X(Martin Leclerc) 144 155.67 T
X(Mario Dorion) 324 155.67 T
X(19 Browning) 144 139.67 T
X(18 Geor) 324 139.67 T
X(gia Crescent) 369.21 139.67 T
X(Dollard des Ormeaux) 144 123.67 T
X(Pointe Claire) 324 123.67 T
X(Quebec, H9G 2K5) 144 107.67 T
X(Quebec, H9R 5V7) 324 107.67 T
X(CANADA) 144 91.67 T
X(CANADA) 324 91.67 T
XFMENDPAGE
X%%EndPage: "11" 11
X%%Page: "10" 11
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-10-) 295.34 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X2 14 Q
X(About the chords) 72 710.67 T
X3 12 Q
X(CHORD) 178.89 710.67 T
X2 14 Q
X( knows about:) 222.85 710.67 T
X3 12 Q
X-0.15 (CHORD) 72 689.67 P
X1 14 Q
X-0.16 ( knows of about 360 chords. Now) 115.97 689.67 P
X-0.16 (, we KNOW your favorite chord won\325) 303.35 689.67 P
X-0.16 (t be) 516.23 689.67 P
X(in there, and if it is, it will be all wrong. So we put in a facility for people to de\336ne) 72 673.67 T
X-0.22 (their own chords. This facility will also let you rede\336ne already de\336ned chords. For) 72 657.67 P
X(the details, look in the \322Directives\323 section of this guide, for the \322de\336ne\323 directive.) 72 641.67 T
X2 F
X(About your pr) 72 595.67 T
X(efer) 158.04 595.67 T
X(ences:) 181.08 595.67 T
X1 F
X(Y) 72 574.67 T
X(ou can store your preferences about fonts and chords in a \336le that is unique to) 80.7 574.67 T
X(every user) 72 558.67 T
X(. This \336le is called \322.chordrc\323 and should be in your home directory) 129.12 558.67 T
X(. For) 506.71 558.67 T
X(the list of the preferences you can have, see the \322Directives\323 section.) 72 542.67 T
X2 F
X(Putting comments in your \336les) 72 496.67 T
X1 F
X(A line starting with a \324#\325 is interpreted as a comment, and generates no output.) 72 475.67 T
X(\050although all your comments are automatically mailed to the authors, and we read) 72 459.67 T
X(them at parties...\051) 72 443.67 T
XFMENDPAGE
X%%EndPage: "10" 10
X%%Page: "9" 10
X612 792 0 FMBEGINPAGE
X0 12 Q
X0 X
X0 K
X(Version 3.5) 72 748 T
X(-9-) 298.67 748 T
X(The Chord User Guide) 412.71 748 T
X72 63 540 63 2 L
X0.5 H
X2 Z
XN
X0 5 5 605 787 510.99 665.99 45 72 FMBEGINEPSF
X%%BeginDocument: /home/martin/wrk/chord-martin/ex2.eps
X%!PS-Adobe-3.0 EPSF-3.0
X%%Title: A song
X%%Creator: Martin Leclerc & Mario Dorion
X%%Pages: (atend)
X%%BoundingBox: 5 5 605 787
X%%EndComments
X/inch {72 mul } def
X
X/CHORD_FONT { /Helvetica-Oblique findfont 9 scalefont } def
X/TEXT_FONT { /Times-Roman findfont 12 scalefont } def
X/MONO_FONT { /Courier findfont 10 scalefont } def
X% routines for the drawing of the chords
X/grid { 
X	gsave currentpoint
X	6 { 0 cagesizeX rlineto incr cagesize neg incr add rmoveto } repeat
X	moveto
X	5 { cagesize 0 rlineto 0 cagesize sub incr rmoveto } repeat
X	1 setlinewidth stroke grestore
X	gsave
X	0 cagesizeX rmoveto cagesize 0 rlineto
X	cagesize 30 div setlinewidth stroke
X	grestore	
X} def
X
X/dot {
X	gsave
X	/fret exch def /str exch def
X	/x 5  fret abs sub incr mul half-incr sub def
X	/y 6 str sub incr mul def
X	y x rmoveto
X	0 setgray
X	fret -1 eq
X	  {
X	  0 incr rmoveto
X	  check neg  check neg rmoveto
X	  check check rlineto check check rlineto
X	  check neg check neg rmoveto check neg check rmoveto
X  	  check check neg rlineto check check neg rlineto
X	  cagesize 50 div setlinewidth stroke
X	  }
X	  {  fret 0 ne
X	    { currentpoint dot-size 0 360 arc fill}
X	    { currentpoint
X	      check 0 360 newpath arc
X	      cagesize 50 div setlinewidth
X	    }
X	    ifelse 
X	    stroke 
X	  }
X	  ifelse
X	grestore
X} def	
X
X/dots {
X	grid
X	/origin exch def
X	/fret-displ exch def
X	  1 1 6
X	  {
X	    /str exch def
X	    /fret exch def
X	    fret -2 ne {str fret dot} if
X	  } for
X
X	fret-displ 1 ne
X	{
X    	  gsave displ-font setfont
X    	  0 cagesize fret-displ 10 ge {1.75} {3} ifelse div sub
X	  cagesizeX incr sub rmoveto
X    	  /char 6 string def fret-displ char cvs show grestore 
X	} if
X
X	/chord-name exch def
X	gsave displ-font setfont
X	0 cagesizeX cagesizeX 15 div add dot-size 3 mul add rmoveto
X	chord-name stringwidth pop 2 div cagesize 2 div exch sub 0 rmoveto
X	chord-name show
X	0 cagesize 10 div rmoveto
X	origin 1 eq { (*) show} if
X	origin 2 eq { (**) show} if
X	chord-font setfont grestore
X} def
X
X/cagesize 30 def
X/incr cagesize 5 div def
X/cagesizeX incr 4 mul def
X/half-incr incr 2 div def
X/dot-size cagesize 15 div def
X/check cagesize 20 div def
X
X/chord-font /Times-Roman findfont cagesize 5 div scalefont def
X/displ-font /Times-Roman findfont cagesize 3 div scalefont def
X% end of the routines for the drawing of the chords
X
X%%EndProlog
X%%Page: "1" 1
X%%BeginPageSetup
X/pgsave save def
X1.000000 1.000000 scale
X0.000000 rotate
X%%EndPageSetup
X/TEXT_FONT { /Times-Roman findfont 17 scalefont } def
X/MONO_FONT { /Courier findfont 15 scalefont } def
XTEXT_FONT setfont
X( Everybody Hurts) dup stringwidth pop 2 div
X612 2 div exch sub 756 moveto
Xshow
X/TEXT_FONT { /Times-Roman findfont 12 scalefont } def
X/MONO_FONT { /Courier findfont 10 scalefont } def
XTEXT_FONT setfont
X( REM) dup stringwidth pop 2 div
X612 2 div exch sub 739 moveto
Xshow
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X717 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Intro    ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X717 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(Intro              ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X717 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Intro                       ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X717 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 706 moveto
X(Intro                       ) show
X/minhpos 0 def
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X676 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When your day is ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X676 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(When your day is long and the ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X676 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When your day is long and the night, the night is ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X676 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(When your day is long and the night, the night is yours a) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X676 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 665 moveto
X(When your day is long and the night, the night is yours alone) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X655 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When you're sure you've had e) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X655 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(When you're sure you've had enough of this ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X655 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When you're sure you've had enough of this life, well ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X655 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 644 moveto
X(When you're sure you've had enough of this life, well hang on) show
XMONO_FONT setfont
X72 633 moveto
X(   E\(low\)-3-2-0-) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Don't let yourself ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Don't let yourself go, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Don't let yourself go, cause everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Don't let yourself go, cause everybody cries ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Don't let yourself go, cause everybody cries and everybody) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Don't let yourself go, cause everybody cries and everybody hurts some) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Don't let yourself go, cause everybody cries and everybody hurts sometimes ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X623 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 612 moveto
X(Don't let yourself go, cause everybody cries and everybody hurts sometimes ) show
X/minhpos 0 def
XTEXT_FONT setfont
X(Sometimes everything is ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X602 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Sometimes everything is wrong,   ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X602 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(Sometimes everything is wrong,   now it's time to sing a) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X602 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 591 moveto
X(Sometimes everything is wrong,   now it's time to sing along) show
X/minhpos 0 def
XTEXT_FONT setfont
X(When your day is night alone ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X581 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(When your day is night alone           \(hold ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X581 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 570 moveto
X(When your day is night alone           \(hold on, hold on\)) show
X/minhpos 0 def
XTEXT_FONT setfont
X(If you feel like letting go ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X560 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(If you feel like letting go            \(hold ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X560 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 549 moveto
X(If you feel like letting go            \(hold on\)) show
X/minhpos 0 def
XTEXT_FONT setfont
X(If you think you've had too ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X539 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(If you think you've had too much of this ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X539 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(If you think you've had too much of this life, well hang ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X539 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 528 moveto
X(If you think you've had too much of this life, well hang on) show
X/minhpos 0 def
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X498 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Cause everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X498 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Cause everybody hurts, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X498 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Cause everybody hurts, take comfort in your ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X498 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X72 487 moveto
X(Cause everybody hurts, take comfort in your friends) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Everybody hurts, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Everybody hurts, don't throw your ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Everybody hurts, don't throw your hands, oh ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Everybody hurts, don't throw your hands, oh now, don't throw your ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X477 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X72 466 moveto
X(Everybody hurts, don't throw your hands, oh now, don't throw your hands) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (C) stringwidth pop add def
X456 moveto
XCHORD_FONT setfont
X(C) show
XTEXT_FONT setfont
X(If you feel like you're ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D4) stringwidth pop add def
X456 moveto
XCHORD_FONT setfont
X(D4) show
XTEXT_FONT setfont
X(If you feel like you're alone, no, no, no, you're not ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X456 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X72 445 moveto
X(If you feel like you're alone, no, no, no, you're not alone) show
XMONO_FONT setfont
X72 434 moveto
X(           D4 ->   E-0-----0-----0-----0--) show
XMONO_FONT setfont
X72 423 moveto
X(                   B---3-----3-----3------) show
XMONO_FONT setfont
X72 412 moveto
X(                   G-----0-----0-----0----) show
X/minhpos 0 def
XTEXT_FONT setfont
X( ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X402 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X( If you're on your ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X402 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X( If you're on your own in this ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X402 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X( If you're on your own in this life, the days and nights are ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X402 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 391 moveto
X( If you're on your own in this life, the days and nights are long) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X381 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When you think you've had too ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X381 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(When you think you've had too much, with this ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X381 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(When you think you've had too much, with this life, to hang ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X381 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 370 moveto
X(When you think you've had too much, with this life, to hang on) show
X/minhpos 0 def
XTEXT_FONT setfont
X() stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X360 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Well everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X360 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Well everybody hurts, some) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X360 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X72 349 moveto
X(Well everybody hurts, sometimes ) show
X/minhpos 0 def
XTEXT_FONT setfont
X(Everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Everybody cries, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (E) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(E) show
XTEXT_FONT setfont
X(Everybody cries, and everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (A) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(A) show
XTEXT_FONT setfont
X(Everybody cries, and everybody hurts,) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (N.C.) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(N.C.) show
XTEXT_FONT setfont
X(Everybody cries, and everybody hurts, ...      some) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Everybody cries, and everybody hurts, ...      sometimes ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X339 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X72 328 moveto
X(Everybody cries, and everybody hurts, ...      sometimes ) show
X1  setlinewidth
Xnewpath
X62 369 moveto
X0 -41 rlineto
Xclosepath
Xstroke
X/minhpos 0 def
XTEXT_FONT setfont
X(But everybody ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X318 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(But everybody hurts ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X318 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(But everybody hurts sometimes so hold ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X318 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(But everybody hurts sometimes so hold on, hold ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X318 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(But everybody hurts sometimes so hold on, hold on, hold ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X318 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 307 moveto
X(But everybody hurts sometimes so hold on, hold on, hold on) show
X/minhpos 0 def
XTEXT_FONT setfont
X(Hold on, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X297 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(Hold on, hold on, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X297 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X(Hold on, hold on, hold on, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (G) stringwidth pop add def
X297 moveto
XCHORD_FONT setfont
X(G) show
XTEXT_FONT setfont
X(Hold on, hold on, hold on, hold on, ) stringwidth  pop 72 add 
Xdup minhpos lt
X     {pop minhpos} if
Xdup /minhpos exch (D) stringwidth pop add def
X297 moveto
XCHORD_FONT setfont
X(D) show
XTEXT_FONT setfont
X72 286 moveto
X(Hold on, hold on, hold on, hold on, hold on) show
X/minhpos 0 def
XTEXT_FONT setfont
END_OF_FILE
  if test 53713 -ne `wc -c <'chord_guide.ps.A'`; then
    echo shar: \"'chord_guide.ps.A'\" unpacked with wrong size!
  elif test -f 'chord_guide.ps.B'; then
    echo shar: Combining  \"'chord_guide.ps'\" \(104651 characters\)
    cat 'chord_guide.ps.A' 'chord_guide.ps.B' > 'chord_guide.ps'
    if test 104651 -ne `wc -c <'chord_guide.ps'`; then
      echo shar: \"'chord_guide.ps'\" combined with wrong size!
    else 
      rm chord_guide.ps.A chord_guide.ps.B
    fi
  fi
  # end of 'chord_guide.ps.A'
fi
if test -f 'getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.h'\"
else
  echo shar: Extracting \"'getopt.h'\" \(4412 characters\)
  sed "s/^X//" >'getopt.h' <<'END_OF_FILE'
X/* Declarations for getopt.
X   Copyright (C) 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
X
X   This program is free software; you can redistribute it and/or modify it
X   under the terms of the GNU General Public License as published by the
X   Free Software Foundation; either version 2, or (at your option) any
X   later version.
X
X   This program is distributed in the hope that it will be useful,
X   but WITHOUT ANY WARRANTY; without even the implied warranty of
X   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X   GNU General Public License for more details.
X
X   You should have received a copy of the GNU General Public License
X   along with this program; if not, write to the Free Software
X   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
X
X#ifndef _GETOPT_H
X#define _GETOPT_H 1
X
X#ifdef	__cplusplus
Xextern "C" {
X#endif
X
X/* For communication from `getopt' to the caller.
X   When `getopt' finds an option that takes an argument,
X   the argument value is returned here.
X   Also, when `ordering' is RETURN_IN_ORDER,
X   each non-option ARGV-element is returned here.  */
X
Xextern char *optarg;
X
X/* Index in ARGV of the next element to be scanned.
X   This is used for communication to and from the caller
X   and for communication between successive calls to `getopt'.
X
X   On entry to `getopt', zero means this is the first call; initialize.
X
X   When `getopt' returns EOF, this is the index of the first of the
X   non-option elements that the caller should itself scan.
X
X   Otherwise, `optind' communicates from one call to the next
X   how much of ARGV has been scanned so far.  */
X
Xextern int optind;
X
X/* Callers store zero here to inhibit the error message `getopt' prints
X   for unrecognized options.  */
X
Xextern int opterr;
X
X/* Set to an option character which was unrecognized.  */
X
Xextern int optopt;
X
X/* Describe the long-named options requested by the application.
X   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
X   of `struct option' terminated by an element containing a name which is
X   zero.
X
X   The field `has_arg' is:
X   no_argument		(or 0) if the option does not take an argument,
X   required_argument	(or 1) if the option requires an argument,
X   optional_argument 	(or 2) if the option takes an optional argument.
X
X   If the field `flag' is not NULL, it points to a variable that is set
X   to the value given in the field `val' when the option is found, but
X   left unchanged if the option is not found.
X
X   To have a long-named option do something other than set an `int' to
X   a compiled-in constant, such as set a value from `optarg', set the
X   option's `flag' field to zero and its `val' field to a nonzero
X   value (the equivalent single-letter option character, if there is
X   one).  For long options that have a zero `flag' field, `getopt'
X   returns the contents of the `val' field.  */
X
Xstruct option
X{
X#if	__STDC__
X  const char *name;
X#else
X  char *name;
X#endif
X  /* has_arg can't be an enum because some compilers complain about
X     type mismatches in all the code that assumes it is an int.  */
X  int has_arg;
X  int *flag;
X  int val;
X};
X
X/* Names for the values of the `has_arg' field of `struct option'.  */
X
X#define	no_argument		0
X#define required_argument	1
X#define optional_argument	2
X
X#if __STDC__
X#if defined(__GNU_LIBRARY__)
X/* Many other libraries have conflicting prototypes for getopt, with
X   differences in the consts, in stdlib.h.  To avoid compilation
X   errors, only prototype getopt for the GNU C library.  */
Xextern int getopt (int argc, char *const *argv, const char *shortopts);
X#else /* not __GNU_LIBRARY__ */
Xextern int getopt ();
X#endif /* not __GNU_LIBRARY__ */
Xextern int getopt_long (int argc, char *const *argv, const char *shortopts,
X		        const struct option *longopts, int *longind);
Xextern int getopt_long_only (int argc, char *const *argv,
X			     const char *shortopts,
X		             const struct option *longopts, int *longind);
X
X/* Internal only.  Users should not call this directly.  */
Xextern int _getopt_internal (int argc, char *const *argv,
X			     const char *shortopts,
X		             const struct option *longopts, int *longind,
X			     int long_only);
X#else /* not __STDC__ */
Xextern int getopt ();
Xextern int getopt_long ();
Xextern int getopt_long_only ();
X
Xextern int _getopt_internal ();
X#endif /* not __STDC__ */
X
X#ifdef	__cplusplus
X}
X#endif
X
X#endif /* _GETOPT_H */
END_OF_FILE
  if test 4412 -ne `wc -c <'getopt.h'`; then
    echo shar: \"'getopt.h'\" unpacked with wrong size!
  fi
  # end of 'getopt.h'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
