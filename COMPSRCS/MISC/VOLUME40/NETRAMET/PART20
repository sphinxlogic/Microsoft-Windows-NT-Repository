Newsgroups: comp.sources.misc
From: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Subject: v40i108:  netramet - Network Traffic Accounting Meter, Part20/25
Message-ID: <1993Nov9.020415.18757@sparky.sterling.com>
X-Md4-Signature: 1331df52aa07a6e4b7a68481eb704dd8
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 9 Nov 1993 02:04:15 GMT
Approved: kent@sparky.sterling.com

Submitted-by: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Posting-number: Volume 40, Issue 108
Archive-name: netramet/part20
Environment: INET, UNIX, DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  netramet/src/apps/snmp_vars.h netramet/src/apps/snmpagnt.c
#   netramet/src/snmplib/mib.c netramet/src/snmplib/snmpagnt.c
# Wrapped by kent@sparky on Tue Nov  2 18:17:12 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 20 (of 25)."'
if test -f 'netramet/src/apps/snmp_vars.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/apps/snmp_vars.h'\"
else
  echo shar: Extracting \"'netramet/src/apps/snmp_vars.h'\" \(5636 characters\)
  sed "s/^X//" >'netramet/src/apps/snmp_vars.h' <<'END_OF_FILE'
X/*
X * Definitions for SNMP (RFC 1067) agent variable finder.
X *
X *
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
Xu_char	*var_system();
Xu_char	*var_ifEntry();
Xu_char	*var_atEntry();
Xu_char	*var_ip();
Xu_char	*var_ipAddrEntry();
Xu_char	*var_ipRouteEntry();
Xu_char	*var_icmp();
Xu_char	*var_tcp();
Xu_char	*var_udp();
Xu_char	*var_process();
Xu_char	*var_event();
Xu_char	*getStatPtr();
X
Xextern long long_return;
Xextern u_char return_buf[];
X
X#define INST	0xFFFFFFFF	/* used to fill out the instance field of the variables table */
X
X/*
X * These are unit magic numbers for each variable.
X */
X
X#define VERSION_DESCR	0
X#define VERSION_ID	1
X#define IFNUMBER	2
X#define UPTIME		3
X#define EVENTNEXTINDEX	4
X
X
X#define IFINDEX		1
X#define IFDESCR		2
X#define IFTYPE		3
X#define IFMTU		4
X#define IFSPEED		5
X#define IFPHYSADDRESS	6
X#define IFADMINSTATUS	7
X#define IFOPERSTATUS	8
X#define IFLASTCHANGE	9
X#define IFINOCTETS	10
X#define IFINUCASTPKTS	11
X#define IFINNUCASTPKTS	12
X#define IFINDISCARDS	13
X#define IFINERRORS	14
X#define IFINUNKNOWNPROTOS 15
X#define IFOUTOCTETS	16
X#define IFOUTUCASTPKTS	17
X#define IFOUTNUCASTPKTS 18
X#define IFOUTDISCARDS	19
X#define IFOUTERRORS	20
X#define IFOUTQLEN	21
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	1
X#define ATNETADDRESS	2
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	1
X#define IPINRECEIVES	2
X#define IPINHDRERRORS	3
X#define IPINADDRERRORS	4
X#define IPFORWDATAGRAMS 5
X#define IPINUNKNOWNPROTOS 6
X#define IPINDISCARDS	7
X#define IPINDELIVERS	8
X#define IPOUTREQUESTS	9
X#define IPOUTDISCARDS	10
X#define IPOUTNOROUTES	11
X#define IPREASMTIMEOUT	12
X#define IPREASMREQDS	13
X#define IPREASMOKS	14
X#define IPREASMFAILS	15
X#define IPFRAGOKS	16
X#define IPFRAGFAILS	17
X#define IPFRAGCREATES	18
X
X#define IPADADDR	1
X#define IPADIFINDEX	2
X#define IPADNETMASK	3
X#define IPADBCASTADDR	4
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	1
X#define IPROUTEMETRIC1	2
X#define IPROUTEMETRIC2	3
X#define IPROUTEMETRIC3	4
X#define IPROUTEMETRIC4	5
X#define IPROUTENEXTHOP	6
X#define IPROUTETYPE	7
X#define IPROUTEPROTO	8
X#define IPROUTEAGE	9
X
X#define ICMPINMSGS	     0
X#define ICMPINERRORS	     1
X#define ICMPINDESTUNREACHS   2
X#define ICMPINTIMEEXCDS      3
X#define ICMPINPARMPROBS      4
X#define ICMPINSRCQUENCHS     5
X#define ICMPINREDIRECTS      6
X#define ICMPINECHOS	     7
X#define ICMPINECHOREPS	     8
X#define ICMPINTIMESTAMPS     9
X#define ICMPINTIMESTAMPREPS 10
X#define ICMPINADDRMASKS     11
X#define ICMPINADDRMASKREPS  12
X#define ICMPOUTMSGS	    13
X#define ICMPOUTERRORS	    14
X#define ICMPOUTDESTUNREACHS 15
X#define ICMPOUTTIMEEXCDS    16
X#define ICMPOUTPARMPROBS    17
X#define ICMPOUTSRCQUENCHS   18
X#define ICMPOUTREDIRECTS    19
X#define ICMPOUTECHOS	    20
X#define ICMPOUTECHOREPS     21
X#define ICMPOUTTIMESTAMPS   22
X#define ICMPOUTTIMESTAMPREPS 23
X#define ICMPOUTADDRMASKS    24
X#define ICMPOUTADDRMASKREPS 25
X
X#define TCPRTOALGORITHM      1
X#define TCPRTOMIN	     2
X#define TCPRTOMAX	     3
X#define TCPMAXCONN	     4
X#define TCPACTIVEOPENS	     5
X#define TCPPASSIVEOPENS      6
X#define TCPATTEMPTFAILS      7
X#define TCPESTABRESETS	     8
X#define TCPCURRESTAB	     9
X#define TCPINSEGS	    10
X#define TCPOUTSEGS	    11
X#define TCPRETRANSSEGS	    12
X#define TCPCONNSTATE	    13
X#define TCPCONNLOCALADDRESS 14
X#define TCPCONNLOCALPORT    15
X#define TCPCONNREMADDRESS   16
X#define TCPCONNREMPORT	    17
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    1
X#define UDPINERRORS	    2
X#define UDPOUTDATAGRAMS     3
X
X#define EVENTCLASS		    0
X#define EVENTINSTANCE		    1
X#define EVENTALARMTYPE		    2
X#define EVENTTIME		    3
X#define EVENTPROBCAUSE		    4
X#define EVENTSPECIFICPROBLEM	    5
X#define EVENTSEVERITY		    6
X#define EVENTBACKUPSTATUS	    7
X#define EVENTBACKUPINSTANCE	    8
X#define EVENTTREND		    9
X#define EVENTTHRESHOLD		    10
X#define EVENTTHRESHOLDLEVEL	    11
X#define EVENTTHRESHOLDOBSVALUE	    12
X#define EVENTID			    13
X#define EVENTCORRELATIONS	    14
X#define EVENTOPERSTATE		    16
X#define EVENTADMINSTATE		    17
X#define EVENTMONATTRIBUTES	    18
X#define EVENTREPAIRACTION	    19
X#define EVENTDATA		    20
X#define EVENTTEXT		    21
X#define EVENTCREDIBILITY	    22
X#define EVENTINDEX		    23
X#define EVENTVALID		    24
X
X
Xstruct variable {
X    oid		    name[26];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char	    *(*findVar)();  /* function that finds variable */
X};
END_OF_FILE
  if test 5636 -ne `wc -c <'netramet/src/apps/snmp_vars.h'`; then
    echo shar: \"'netramet/src/apps/snmp_vars.h'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/apps/snmp_vars.h'
fi
if test -f 'netramet/src/apps/snmpagnt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/apps/snmpagnt.c'\"
else
  echo shar: Extracting \"'netramet/src/apps/snmpagnt.c'\" \(18099 characters\)
  sed "s/^X//" >'netramet/src/apps/snmpagnt.c' <<'END_OF_FILE'
X/*
X * Simple Network Management Protocol (RFC 1067).
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X
X#include "ausnmp.h"
X
X#ifdef KINETICS
X#include "gw.h"
X#include "ab.h"
X#include "inet.h"
X#include "fp4/cmdmacro.h"
X#include "fp4/pbuf.h"
X#include "glob.h"
X#endif
X
X#if (defined(unix) && !defined(KINETICS))
X#include <sys/types.h>
X#include <netinet/in.h>
X#ifndef NULL
X#define NULL 0
X#endif
X#endif
X
X#include "snmp.h"
X#include "snmpimpl.h"  /* AU */
X#include "asn1.h"
X
X#include "mib.h"
X
Xvoid	snmp_input();
Xvoid	snmp_trap();
Xint	create_identical();
Xint	parse_var_op_list();
Xint	snmp_access();
X
X#if kinetics
Xchar	version_descr[];
Xoid	version_id[];
Xint	version_id_len;
X#endif
X
Xstruct pbuf *definitelyGetBuf();
X
X#define NUM_COMMUNITIES	5
Xchar	*communities[NUM_COMMUNITIES] = {
X    "public", 
X    "proxy",
X    "private",
X    "regional",
X    "core"
X};
X
X/* these can't be global in a multi-process router */
X    u_char	sid[SID_MAX_LEN + 1];
X    int		sidlen;
X    u_char	*packet_end;
X    int		community;
X
X
X#ifdef KINETICS
Xvoid
Xsnmp_input(p)
X    struct pbuf *p;
X{
X    struct ip	    *ip = (struct ip *)p->p_off;
X    int		    hlen = (int)ip->ip_hl << 2;
X    register struct udp	    *udp;
X    register u_char *data;  /* pointer to the rest of the unread data */
X    int		    length; /* bytes of data left in msg after the "data" pointer */
X    struct pbuf	    *out_packet;
X    register u_char *out_data;
X    int		    out_length;
X    u_short	    udp_src;
X    extern struct mib_udp   mib_udp;
X
X    
X    udp = (struct udp *)(p->p_off + hlen);
X    if (ntohs(ip->ip_len) - hlen < sizeof(struct udp) ||    /* IP length < minimum UDP packet */
X	    ntohs(udp->length) > ntohs(ip->ip_len) - hlen){ /* UDP length > IP data */
X	ERROR("dropped packet with bad length");    /* delete me */
X	return; /* drop packet */
X    }
X    data = (u_char *)udp + sizeof(struct udp);
X    length = ntohs(udp->length) - sizeof(struct udp);
X
X    out_packet = definitelyGetBuf(); /* drop packets off input queue if necessary */
X    out_data = (u_char *)(out_packet->p_off + sizeof (struct ip) + sizeof (struct udp));
X    out_length = MAXDATA - sizeof(struct ip) - sizeof (struct udp);
X
XK_LEDON();
X    if (!snmp_agent_parse(data, length, out_data, &out_length, (u_long)ip->ip_src)){
X	K_PFREE(out_packet);
XK_LEDOFF();
X	return;
X    }
XK_LEDOFF();
X    out_packet->p_len = packet_end - (u_char *)out_packet->p_off;
X    setiphdr(out_packet, ip->ip_src);	/* address to source of request packet (ntohl ??? ) */
X    udp_src = ntohs(udp->src);
X    udp = (struct udp *)(out_packet->p_off + sizeof (struct ip));
X    udp->src = htons(SNMP_PORT);
X    udp->dst = htons(udp_src);
X    udp->length = out_packet->p_len - sizeof(struct ip);
X    udp->checksum = 0;	/* this should be computed */
X
X    mib_udp.udpOutDatagrams++;
X    routeip(out_packet, 0, 0);
X}
X
X
Xvoid
Xsnmp_trap(destAddr, trapType, specificType)
X    u_long  destAddr;
X    int	    trapType;
X    int	    specificType;
X{
X    struct pbuf	    *out_packet;
X    register u_char *out_data;
X    register struct udp	    *udp;
X    int		    out_length;
X    static oid	    sysDescrOid[] = {1, 3, 6, 1, 2, 1, 1, 1, 0};
X    
X    out_packet = definitelyGetBuf(); /* drop packets off input queue if necessary */
X    out_data = (u_char *)(out_packet->p_off + sizeof (struct ip) + sizeof (struct udp));
X    out_length = MAXDATA - sizeof(struct ip) - sizeof (struct udp);
X
XK_LEDON();
X    out_packet->p_len = snmp_build_trap(out_data, out_length, version_id, version_id_len,
X	conf.ipaddr, trapType, specificType, TICKS2MS(tickclock)/10, sysDescrOid, sizeof(sysDescrOid)/sizeof(oid),
X	ASN_OCTET_STR, strlen(version_descr), (u_char *)version_descr);
X    if (out_packet->p_len == 0){
X	K_PFREE(out_packet);
XK_LEDOFF();
X	return;
X    }
XK_LEDOFF();
X    out_packet->p_len += sizeof(struct ip) + sizeof(struct udp);
X    setiphdr(out_packet, destAddr);	/* address to source of request packet (ntohl ??? ) */
X    udp = (struct udp *)(out_packet->p_off + sizeof (struct ip));
X    udp->src = htons(SNMP_PORT);
X    udp->dst = htons(SNMP_TRAP_PORT);
X    udp->length = out_packet->p_len - sizeof(struct ip);
X    udp->checksum = 0;	/* this should be computed */
X
X    mib_udp.udpOutDatagrams++;
X    routeip(out_packet, 0, 0);
X}
X#endif
X
Xint
Xsnmp_agent_parse(data, length, out_data, out_length, sourceip)
X    register u_char	*data;
X    int			length;
X    register u_char	*out_data;
X    int			*out_length;
X    u_long		sourceip;	/* possibly for authentication */
X{
X    u_char	    msg_type, type;
X    long	    zero = 0;
X    long	    reqid, errstat, errindex;
X    register u_char *out_auth, *out_header, *out_reqid;
X    u_char	    *startData = data;
X    int		    startLength = length;
X    long	    version;
X    int		    header_shift, auth_shift;
X
X    sidlen = SID_MAX_LEN;
X    data = snmp_auth_parse(data, &length, sid, &sidlen, &version); /* authenticates message and returns length if valid */
X    if (data == NULL){
X	ERROR("bad authentication");
X	/* send auth fail trap */
X	return 0;
X    }
X    if (version != SNMP_VERSION_1){
X	ERROR("wrong version");
X	return NULL;
X    }
X    community = get_community(sid);
X    if (community == -1)
X	return NULL;
X    data = asn_parse_header(data, &length, &msg_type);
X    if (data == NULL){
X	ERROR("bad header");
X	return 0;
X    }
X    if (msg_type != GET_REQ_MSG && msg_type != GETNEXT_REQ_MSG && msg_type != SET_REQ_MSG){
X	return 0;
X    }
X    data = asn_parse_int(data, &length, &type, &reqid, sizeof(reqid));
X    if (data == NULL){
X	ERROR("bad parse of reqid");
X	return 0;
X    }
X
X    data = asn_parse_int(data, &length, &type, &errstat, sizeof(errstat));
X    if (data == NULL){
X	ERROR("bad parse of errstat");
X	return 0;
X    }
X        data = asn_parse_int(data, &length, &type, &errindex, sizeof(errindex));
X    if (data == NULL){
X	ERROR("bad parse of errindex");
X	return 0;
X    }
X    /*
X     * Now start cobbling together what is known about the output packet.
X     * The final lengths are not known now, so they will have to be recomputed
X     * later.
X     */
X    out_auth = out_data;
X    out_header = snmp_auth_build(out_auth, out_length, sid, &sidlen, &zero, 0);
X    if (out_header == NULL){
X	ERROR("snmp_auth_build failed");
X	return 0;
X    }
X    out_reqid = asn_build_header(out_header, out_length, (u_char)GET_RSP_MSG, 0);
X    if (out_reqid == NULL){
X	ERROR("");
X	return 0;
X    }
X
X    type = (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
X    /* return identical request id */
X    out_data = asn_build_int(out_reqid, out_length, type, &reqid, sizeof(reqid));
X    if (out_data == NULL){
X	ERROR("build reqid failed");
X	return 0;
X    }
X
X    /* assume that error status will be zero */
X    out_data = asn_build_int(out_data, out_length, type, &zero, sizeof(zero));
X    if (out_data == NULL){
X	ERROR("build errstat failed");
X	return 0;
X    }
X
X    /* assume that error index will be zero */
X    out_data = asn_build_int(out_data, out_length, type, &zero, sizeof(zero));
X    if (out_data == NULL){
X	ERROR("build errindex failed");
X	return 0;
X    }
X    errstat = parse_var_op_list(data, length, out_data, *out_length, msg_type, &errindex, 0);
X    if (msg_type == SET_REQ_MSG && errstat == SNMP_ERR_NOERROR){
X	/*
X	 * SETS require 2 passes through the var_op_list.  The first pass verifies that
X	 * all types, lengths, and values are valid, and the second does the set.  Then
X	 * the identical GET RESPONSE packet is returned.
X	 */
X	errstat = parse_var_op_list(data, length, out_data, *out_length, msg_type, &errindex, 1);
X	if (create_identical(startData, out_auth, startLength, 0L, 0L)) {
X	    *out_length = packet_end - out_auth;  /* AU: Have to set this! */
X	    return 1;
X	}
X	return 0;
X    }
X    switch((short)errstat){
X	case SNMP_ERR_NOERROR:
X	    /*
X	     * Because of the assumption above that header lengths would be encoded
X	     * in one byte, things need to be fixed, now that the actual lengths are known.
X	     */
X	    header_shift = 0;
X	    *out_length = packet_end - out_reqid;
X	    if (*out_length >= 0x80){
X		header_shift++;
X		if (*out_length > 0xFF)
X		    header_shift++;
X	    }
X	    auth_shift = 0;
X	    *out_length = (packet_end - out_auth) - 2 + header_shift;
X	    if (*out_length >= 0x80){
X		auth_shift++;
X		if (*out_length > 0xFF)
X		    auth_shift++;
X	    }
X	    if (auth_shift + header_shift){
X		/*
X		 * Shift packet (from request id to end of packet) by the sum of the
X		 * necessary shift counts.
X		 */
X		shift_array(out_reqid, packet_end - out_reqid, auth_shift + header_shift);
X		/* Now adjust pointers into the packet */
X		packet_end += auth_shift + header_shift;
X		out_reqid += auth_shift + header_shift;
X		out_header += auth_shift;
X	    }
X	    
X	    /* re-encode the headers with the real lengths */
X	    out_data = out_header;
X	    *out_length = packet_end - out_reqid;
X	    out_data = asn_build_header(out_data, out_length, GET_RSP_MSG, *out_length);
X	    if (out_data != out_reqid){
X		ERROR("internal error: header");
X		return 0;
X	    }
X
X	    out_data = out_auth;
X	    *out_length = packet_end - out_auth;
X	    out_data = snmp_auth_build(out_data, out_length, sid, &sidlen, &zero, packet_end - out_header);
X	    if (out_data != out_header){
X		ERROR("internal error");
X		return 0;
X	    }
X	    break;
X	case SNMP_ERR_NOSUCHNAME:
X	case SNMP_ERR_TOOBIG:
X	case SNMP_ERR_BADVALUE:
X	case SNMP_ERR_READONLY:
X	case SNMP_ERR_GENERR:
X	    if (create_identical(startData, out_auth, startLength, errstat, errindex))
X		break;
X	    return 0;
X	default:
X	    return 0;
X    }
X    *out_length = packet_end - out_auth;
X    return 1;
X}
X
X/*
X * Parse_var_op_list goes through the list of variables and retrieves each one,
X * placing it's value in the output packet.  If doSet is non-zero, the variable is set
X * with the value in the packet.  If any error occurs, an error code is returned.
X */
Xint
Xparse_var_op_list(data, length, out_data, out_length, msgtype, index, doSet)
X    register u_char	*data;
X    int			length;
X    register u_char	*out_data;
X    int			out_length;
X    u_char		msgtype;
X    register long	*index;
X    int			doSet;
X{
X    u_char  type;
X    oid	    var_name[MAX_NAME_LEN];
X    int	    var_name_len, var_val_len;
X    u_char  var_val_type, *var_val, statType;
X    u_char far *statP;
X    int	    statLen;
X    u_short acl;
X    int	    rw, exact;
X    int	    (*write_method)();
X    u_char  *headerP, *var_list_start;
X    int	    dummyLen;
X    int	    header_shift;
X    u_char far *getStatPtr();
X
X    if (msgtype == SET_REQ_MSG)
X	rw = WRITE;
X    else
X	rw = READ;
X    if (msgtype == GETNEXT_REQ_MSG)
X	exact = FALSE;
X    else
X	exact = TRUE;
X    data = asn_parse_header(data, &length, &type);
X    if (data == NULL){
X	ERROR("not enough space for varlist");
X	return PARSE_ERROR;
X    }
X    if (type != (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR)){
X	ERROR("wrong type");
X	return PARSE_ERROR;
X    }
X    headerP = out_data;
X    out_data = asn_build_header(out_data, &out_length, (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
X    if (out_data == NULL){
X    	ERROR("not enough space in output packet");
X	return BUILD_ERROR;
X    }
X    var_list_start = out_data;
X
X    *index = 1;
X    while((int)length > 0){
X	/* parse the name, value pair */
X	var_name_len = MAX_NAME_LEN;
X	data = snmp_parse_var_op(data, var_name, &var_name_len, &var_val_type, &var_val_len, &var_val, (int *)&length);
X	if (data == NULL)
X	    return PARSE_ERROR;
X	/* now attempt to retrieve the variable on the local entity */
X	statP = getStatPtr(var_name, &var_name_len, &statType, &statLen, &acl, exact, &write_method);
X	if (statP == NULL)
X	    return SNMP_ERR_NOSUCHNAME;
X	/* Check if this user has access rights to this variable */
X	if (!snmp_access(acl, community, rw))
X	    return SNMP_ERR_NOSUCHNAME;	/* bogus */
X	if (msgtype == SET_REQ_MSG){
X	    if (write_method == 0){
X		/* see if the type and value is consistent with this entities variable */
X		if (!goodValue(var_val_type, var_val_len, statType, statLen)){
X		    return SNMP_ERR_BADVALUE;
X		}
X		/* actually do the set if necessary */
X		if (doSet)
X		    setVariable(var_val, var_val_type, var_val_len, statP, statLen);
X	    } else {
X		if (!(*write_method)(doSet, var_val, var_val_type, var_val_len, statP))
X		    return SNMP_ERR_BADVALUE;
X	    }
X	}
X	/* retrieve the value of the variable and place it into the outgoing packet */
X	out_data = snmp_build_var_op(out_data, var_name, &var_name_len, statType, statLen, statP, &out_length);
X	if (out_data == NULL){
X	    return SNMP_ERR_TOOBIG;
X	}
X
X	(*index)++;
X    }
X    packet_end = out_data;  /* save a pointer to the end of the packet */
X
X    /*
X     * Because of the assumption above that header lengths would be encoded
X     * in one byte, things need to be fixed, now that the actual lengths are known.
X     */
X    header_shift = 0;
X    out_length = packet_end - var_list_start;
X    if (out_length >= 0x80){
X	header_shift++;
X	if (out_length > 0xFF)
X	    header_shift++;
X    }
X    if (header_shift){
X	shift_array(var_list_start, packet_end - var_list_start, header_shift);
X	packet_end += header_shift;
X	var_list_start += header_shift;
X    }
X
X    /* Now rebuild header with the actual lengths */
X    dummyLen = packet_end - var_list_start;
X    if (asn_build_header(headerP, &dummyLen, (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), dummyLen) == NULL){
X	return SNMP_ERR_TOOBIG;	/* bogus error ???? */
X    }
X    *index = 0;
X    return SNMP_ERR_NOERROR;
X}
X
X/*
X * create a packet identical to the input packet, except for the error status
X * and the error index which are set according to the input variables.
X * Returns 1 upon success and 0 upon failure.
X */
Xint
Xcreate_identical(snmp_in, snmp_out, snmp_length, errstat, errindex)
X    u_char	    *snmp_in;
X    u_char	    *snmp_out;
X    int		    snmp_length;
X    long	    errstat, errindex;
X{
X    register u_char *data;
X    u_char	    type;
X    u_long	    dummy;
X    int		    length, headerLength;
X    register u_char *headerPtr, *reqidPtr, *errstatPtr, *errindexPtr, *varListPtr;
X
X    bcopy((char far *)snmp_in, (char far *)snmp_out, snmp_length);
X    length = snmp_length;
X    headerPtr = snmp_auth_parse(snmp_out, &length, sid, &sidlen, (long *)&dummy);
X    if (headerPtr == NULL)
X	return 0;
X    reqidPtr = asn_parse_header(headerPtr, &length, (u_char *)&dummy);
X    if (reqidPtr == NULL)
X	return 0;
X    headerLength = length;
X    errstatPtr = asn_parse_int(reqidPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* request id */
X    if (errstatPtr == NULL)
X	return 0;
X    errindexPtr = asn_parse_int(errstatPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* error status */
X    if (errindexPtr == NULL)
X	return 0;
X    varListPtr = asn_parse_int(errindexPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* error index */
X    if (varListPtr == NULL)
X	return 0;
X
X    data = asn_build_header(headerPtr, &headerLength, GET_RSP_MSG, headerLength);
X    if (data != reqidPtr)
X	return 0;
X    length = snmp_length;
X    type = (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
X    data = asn_build_int(errstatPtr, &length, type, &errstat, sizeof errstat);
X    if (data != errindexPtr)
X	return 0;
X    data = asn_build_int(errindexPtr, &length, type, &errindex, sizeof errindex);
X    if (data != varListPtr)
X	return 0;
X    packet_end = snmp_out + snmp_length;
X    return 1;
X}
X
X#ifdef KINETICS
Xstruct pbuf *
XdefinitelyGetBuf(){
X    register struct pbuf *p;
X
X    K_PGET(PT_DATA, p);
X    while(p == 0){
X#ifdef notdef
X	if (pq->pq_head != NULL){
X	    K_PDEQ(SPLIMP, pq, p);
X	    if (p) K_PFREE(p);
X	} else if (sendq->pq_head != NULL){
X	    K_PDEQ(SPLIMP, sendq, p);
X	    if (p) K_PFREE(p);
X	}
X#endif
X	K_PGET(PT_DATA, p);
X    }
X    return p;
X}
X#endif
X
Xint
Xsnmp_access(acl, community, rw)
X    u_short 	acl;
X    int		community;
X    int		rw;
X{
X    /*
X     * Each group has 2 bits, the more significant one is for read access,
X     * the less significant one is for write access.
X     */
X
X    community <<= 1;	/* multiply by two two shift two bits at a time */
X    if (rw == READ){
X	return (acl & (2 << community));    /* return the correct bit */
X    } else {
X	return (acl & (1 << community));
X    }
X}
X
Xint
Xget_community(sessionid)
X    u_char	*sessionid;
X{
X    int	count;
X
X    for(count = 0; count < NUM_COMMUNITIES; count++){
X	if (!strcmp(communities[count], (char *)sessionid))
X	    break;
X    }
X    if (count == NUM_COMMUNITIES)
X	return -1;
X    return count;
X}
X
Xint
XgoodValue(inType, inLen, actualType, actualLen)
X    u_char	inType, actualType;
X    int		inLen, actualLen;
X{
X    if (inLen > actualLen)
X	return FALSE;
X    return (inType == actualType);
X}
X
XsetVariable(var_val, var_val_type, var_val_len, statP, statLen)
X    u_char  *var_val;
X    u_char  var_val_type;
X    int	    var_val_len;
X    u_char far *statP;
X    int	    statLen;
X{
X    int	    buffersize = 1000;
X
X    switch(var_val_type){
X	case ASN_INTEGER:
X	case COUNTER:
X	case GAUGE:
X	case TIMETICKS:
X	    asn_parse_int(var_val, &buffersize, &var_val_type, (long *)statP, statLen);
X	    break;
X	case ASN_OCTET_STR:
X	case IPADDRESS:
X	case OPAQUE:
X	    asn_parse_string(var_val, &buffersize, &var_val_type, statP, &statLen);
X	    break;
X	case ASN_OBJECT_ID:
X	    asn_parse_objid(var_val, &buffersize, &var_val_type, (oid *)statP, &statLen);
X	    break;
X    }
X}
X
X
END_OF_FILE
  if test 18099 -ne `wc -c <'netramet/src/apps/snmpagnt.c'`; then
    echo shar: \"'netramet/src/apps/snmpagnt.c'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/apps/snmpagnt.c'
fi
if test -f 'netramet/src/snmplib/mib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/snmplib/mib.c'\"
else
  echo shar: Extracting \"'netramet/src/snmplib/mib.c'\" \(17927 characters\)
  sed "s/^X//" >'netramet/src/snmplib/mib.c' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <sys/time.h>
X#include "ausnmp.h"
X#include "asn1.h"
X#include "snmpimpl.h"
X#include "snmpapi.h"
X#include "parse.h"
X
Xstatic void sprint_by_type();
X
Xstatic char *
XuptimeString(timeticks, buf)
X    register long timeticks;
X    char *buf;
X{
X    int	seconds, minutes, hours, days;
X
X    timeticks /= 100;
X    days = timeticks / (60 * 60 * 24);
X    timeticks %= (60 * 60 * 24);
X
X    hours = timeticks / (60 * 60);
X    timeticks %= (60 * 60);
X
X    minutes = timeticks / 60;
X    seconds = timeticks % 60;
X
X    if (days == 0){
X	sprintf(buf, "%d:%02d:%02d", hours, minutes, seconds);
X    } else if (days == 1) {
X	sprintf(buf, "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
X    } else {
X	sprintf(buf, "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
X    }
X    return buf;
X}
X
Xstatic sprint_hexstring(buf, cp, len)
X    char *buf;
X    u_char  *cp;
X    int	    len;
X{
X
X    for(; len >= 16; len -= 16){
X	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X ", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
X	buf += strlen(buf);
X	cp += 8;
X	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
X	buf += strlen(buf);
X	cp += 8;
X    }
X    for(; len > 0; len--){
X	sprintf(buf, "%02X ", *cp++);
X	buf += strlen(buf);
X    }
X    *buf = '\0';
X}
X
Xstatic sprint_asciistring(buf, cp, len)
X    char *buf;
X    u_char  *cp;
X    int	    len;
X{
X    int	x;
X
X    for(x = 0; x < len; x++){
X	if (isprint(*cp)){
X	    *buf++ = *cp++;
X	} else {
X	    *buf++ = '.';
X	    cp++;
X	}
X	if ((x % 48) == 47)
X	    *buf++ = '\n';
X    }
X    *buf = '\0';
X}
X
X#ifdef UNUSED
Xint
Xread_rawobjid(input, output, out_len)
X    char *input;
X    oid *output;
X    int	*out_len;
X{
X    char    buf[12], *cp;
X    oid	    *op = output;
X    u_long  subid;
X
X    while(*input != '\0'){
X	if (!isdigit(*input))
X	    break;
X	cp = buf;
X	while(isdigit(*input))
X	    *cp++ = *input++;
X	*cp = '\0';
X	subid = atoi(buf);
X	if(subid > MAX_SUBID){
X	    fprintf(stderr, "sub-identifier too large: %s\n", buf);
X	    return 0;
X	}
X	if((*out_len)-- <= 0){
X	    fprintf(stderr, "object identifier too long\n");
X	    return 0;
X	}
X	*op++ = subid;
X	if(*input++ != '.')
X	    break;
X    }
X    *out_len = op - output;
X    if (*out_len == 0)
X	return 0;
X    return 1;
X}
X
X#endif /* UNUSED */
X
Xstatic void
Xsprint_octet_string(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    int hex, x;
X    u_char *cp;
X
X    if (var->type != ASN_OCTET_STR){
X	sprintf(buf, "Wrong Type (should be OCTET STRING): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    hex = 0;
X    for(cp = var->val.string, x = 0; x < var->val_len; x++, cp++){
X	if (!(isprint(*cp) || isspace(*cp)))
X	    hex = 1;
X    }
X    if (var->val_len <= 4)
X	hex = 1;    /* not likely to be ascii */
X    if (hex){
X	sprintf(buf, "OCTET STRING-   (hex):\t");
X	buf += strlen(buf);
X	sprint_hexstring(buf, var->val.string, var->val_len);
X    } else {
X	sprintf(buf, "OCTET STRING- (ascii):\t");
X	buf += strlen(buf);
X	sprint_asciistring(buf, var->val.string, var->val_len);
X    }
X}
X
Xstatic void
Xsprint_opaque(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X
X    if (var->type != OPAQUE){
X	sprintf(buf, "Wrong Type (should be Opaque): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "OPAQUE -   (hex):\t");
X    buf += strlen(buf);
X    sprint_hexstring(buf, var->val.string, var->val_len);
X}
X
Xstatic void
Xsprint_object_identifier(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_OBJECT_ID){
X	sprintf(buf, "Wrong Type (should be OBJECT IDENTIFIER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "OBJECT IDENTIFIER:\t");
X    buf += strlen(buf);
X    sprint_objid(buf, (oid *)(var->val.objid), var->val_len / sizeof(oid));
X}
X
Xstatic void
Xsprint_timeticks(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    char timebuf[32];
X
X    if (var->type != TIMETICKS){
X	sprintf(buf, "Wrong Type (should be Timeticks): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Timeticks: (%d) %s", *(var->val.integer), uptimeString(*(var->val.integer), timebuf));
X}
X
Xstatic void
Xsprint_integer(buf, var, enums)
X    char *buf;
X    struct variable_list *var;
X    struct enum_list	    *enums;
X{
X    char    *enum_string = NULL;
X
X    if (var->type != ASN_INTEGER){
X	sprintf(buf, "Wrong Type (should be INTEGER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    for (; enums; enums = enums->next)
X	if (enums->value == *var->val.integer){
X	    enum_string = enums->label;
X	    break;
X	}
X    if (enum_string == NULL)
X	sprintf(buf, "INTEGER: %d", *var->val.integer);
X    else
X	sprintf(buf, "INTEGER: %s(%d)", enum_string, *var->val.integer);
X}
X
Xstatic void
Xsprint_gauge(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != GAUGE){
X	sprintf(buf, "Wrong Type (should be Gauge): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Gauge: %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_counter(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != COUNTER){
X	sprintf(buf, "Wrong Type (should be Counter): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Counter: %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_networkaddress(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    int x, len;
X    u_char *cp;
X
X    sprintf(buf, "Network Address:\t");
X    buf += strlen(buf);
X    cp = var->val.string;    
X    len = var->val_len;
X    for(x = 0; x < len; x++){
X	sprintf(buf, "%02X", *cp++);
X	buf += strlen(buf);
X	if (x < (len - 1))
X	    *buf++ = ':';
X    }
X}
X
Xstatic void
Xsprint_ipaddress(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    u_char *ip;
X
X    if (var->type != IPADDRESS){
X	sprintf(buf, "Wrong Type (should be Ipaddress): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    ip = var->val.string;
X    sprintf(buf, "IpAddress:\t%d.%d.%d.%d",ip[0], ip[1], ip[2], ip[3]);
X}
X
Xstatic void
Xsprint_unsigned_short(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_INTEGER){
X	sprintf(buf, "Wrong Type (should be INTEGER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "INTEGER (0..65535): %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_null(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_NULL){
X	sprintf(buf, "Wrong Type (should be NULL): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "NULL");
X}
X
Xstatic void
Xsprint_unknowntype(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X/*    sprintf(buf, "Variable has bad type"); */
X    sprint_by_type(buf, var, NULL);
X}
X
Xstatic void
Xsprint_badtype(buf)
X    char *buf;
X{
X    sprintf(buf, "Variable has bad type");
X}
X
Xstatic void
Xsprint_by_type(buf, var, enums)
X    char *buf;
X    struct variable_list *var;
X    struct enum_list	    *enums;
X{
X    switch (var->type){
X	case ASN_INTEGER:
X	    sprint_integer(buf, var, enums);
X	    break;
X	case ASN_OCTET_STR:
X	    sprint_octet_string(buf, var);
X	    break;
X	case OPAQUE:
X	    sprint_opaque(buf, var);
X	    break;
X	case ASN_OBJECT_ID:
X	    sprint_object_identifier(buf, var);
X	    break;
X	case TIMETICKS:
X	    sprint_timeticks(buf, var);
X	    break;
X	case GAUGE:
X	    sprint_gauge(buf, var);
X	    break;
X	case COUNTER:
X	    sprint_counter(buf, var);
X	    break;
X	case IPADDRESS:
X	    sprint_ipaddress(buf, var);
X	    break;
X	case ASN_NULL:
X	    sprint_null(buf, var);
X	    break;
X	default:
X	    sprint_badtype(buf);
X	    break;
X    }
X}
X
Xstruct tree *get_symbol();
X
Xoid RFC1066_MIB[] = { 1, 3, 6, 1, 2, 1 };
Xunsigned char RFC1066_MIB_text[] = ".iso.org.dod.internet.mgmt.mib";
Xstruct tree *Mib;
X
Xinit_mib()
X{
X    char *file, *getenv();
X
X    Mib = 0;
X    file = getenv("MIBFILE");
X    if (file)
X	Mib = read_mib(file);
X    if (!Mib)
X	Mib = read_mib("mib.txt");
X    if (!Mib)
X	Mib = read_mib("/etc/mib.txt");
X    if (!Mib){
X	fprintf(stderr, "Couldn't find mib file\n");
X	exit(2);
X    }
X    set_functions(Mib);
X}
X
Xstatic
Xset_functions(subtree)
X    struct tree *subtree;
X{
X    for(; subtree; subtree = subtree->next_peer){
X	switch(subtree->type){
X	    case TYPE_OBJID:
X		subtree->printer = sprint_object_identifier;
X		break;
X	    case TYPE_OCTETSTR:
X		subtree->printer = sprint_octet_string;
X		break;
X	    case TYPE_INTEGER:
X		subtree->printer = sprint_integer;
X		break;
X	    case TYPE_NETADDR:
X		subtree->printer = sprint_networkaddress;
X		break;
X	    case TYPE_IPADDR:
X		subtree->printer = sprint_ipaddress;
X		break;
X	    case TYPE_COUNTER:
X		subtree->printer = sprint_counter;
X		break;
X	    case TYPE_GAUGE:
X		subtree->printer = sprint_gauge;
X		break;
X	    case TYPE_TIMETICKS:
X		subtree->printer = sprint_timeticks;
X		break;
X	    case TYPE_OPAQUE:
X		subtree->printer = sprint_opaque;
X		break;
X	    case TYPE_NULL:
X		subtree->printer = sprint_null;
X		break;
X	    case TYPE_OTHER:
X	    default:
X		subtree->printer = sprint_unknowntype;
X		break;
X	}
X	set_functions(subtree->child_list);
X    }
X}
X
X#ifdef testing
Xint snmp_dump_packet = 0;
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X    oid objid[64];
X    int objidlen = sizeof (objid);
X    int count;
X    struct variable variable;
X
X    init_mib(&Mib);
X    if (argc < 2)
X	print_subtree(Mib, 0);
X    variable.type = ASN_INTEGER;
X    variable.val.integer = 3;
X    variable.val_len = 4;
X    for (argc--; argc; argc--, argv++) {
X	objidlen = sizeof (objid);
X	printf("read_objid(%s) = %d\n",
X	       argv[1], read_objid(argv[1], objid, &objidlen));
X	for(count = 0; count < objidlen; count++)
X	    printf("%d.", objid[count]);
X	printf("\n");
X	print_variable(objid, objidlen, &variable);
X    }
X}
X
X#endif testing
X
X
Xstatic struct tree *
Xfind_rfc1066_mib(root)
X    struct tree *root;
X{
X    oid *op = RFC1066_MIB;
X    struct tree *tp;
X    int len;
X
X    for(len = sizeof(RFC1066_MIB)/sizeof(oid); len; len--, op++){
X	for(tp = root; tp; tp = tp->next_peer){
X	    if (tp->subid == *op){
X		root = tp->child_list;
X		break;
X	    }
X	}
X	if (tp == NULL)
X	    return NULL;
X    }
X    return root;
X}
X
Xint read_objid(input, output, out_len)
X    char *input;
X    oid *output;
X    int	*out_len;   /* number of subid's in "output" */
X{
X    struct tree *root = Mib;
X    oid *op = output;
X    int i;
X
X    if (*input == '.')
X	input++;
X    else {
X	root = find_rfc1066_mib(root);
X	for (i = 0; i < sizeof (RFC1066_MIB)/sizeof(oid); i++) {
X	    if ((*out_len)-- > 0)
X		*output++ = RFC1066_MIB[i];
X	    else {
X		fprintf(stderr, "object identifier too long\n");
X		return (0);
X	    }
X	}
X    }
X
X    if (root == NULL){
X	fprintf(stderr, "Mib not initialized.  Exiting.\n");
X	exit(1);
X    }
X    if ((*out_len =
X	 parse_subtree(root, input, output, out_len)) == 0)
X	return (0);
X    *out_len += output - op;
X
X    return (1);
X}
X
Xstatic
Xparse_subtree(subtree, input, output, out_len)
X    struct tree *subtree;
X    char *input;
X    oid	*output;
X    int	*out_len;   /* number of subid's */
X{
X    char buf[128], *to = buf;
X    u_long subid = 0;
X    struct tree *tp;
X
X    /*
X     * No empty strings.  Can happen if there is a trailing '.' or two '.'s
X     * in a row, i.e. "..".
X     */
X    if ((*input == '\0') ||
X	(*input == '.'))
X	return (0);
X
X    if (isdigit(*input)) {
X	/*
X	 * Read the number, then try to find it in the subtree.
X	 */
X	while (isdigit(*input)) {
X	    subid *= 10;
X	    subid += *input++ - '0';
X	}
X	for (tp = subtree; tp; tp = tp->next_peer) {
X	    if (tp->subid == subid)
X		goto found;
X	}
X	tp = NULL;
X    }
X    else {
X	/*
X	 * Read the name into a buffer.
X	 */
X	while ((*input != '\0') &&
X	       (*input != '.')) {
X	    *to++ = *input++;
X	}
X	*to = '\0';
X
X	/*
X	 * Find the name in the subtree;
X	 */
X	for (tp = subtree; tp; tp = tp->next_peer) {
X	    if (lc_cmp(tp->label, buf) == 0) {
X		subid = tp->subid;
X		goto found;
X	    }
X	}
X
X	/*
X	 * If we didn't find the entry, punt...
X	 */
X	if (tp == NULL) {
X	    fprintf(stderr, "sub-identifier not found: %s\n", buf);
X	    return (0);
X	}
X    }
X
Xfound:
X    if(subid > (u_long)MAX_SUBID){
X	fprintf(stderr, "sub-identifier too large: %s\n", buf);
X	return (0);
X    }
X
X    if ((*out_len)-- <= 0){
X	fprintf(stderr, "object identifier too long\n");
X	return (0);
X    }
X    *output++ = subid;
X
X    if (*input != '.')
X	return (1);
X    if ((*out_len =
X	 parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
X	return (0);
X    return (++*out_len);
X}
X
Xprint_objid(objid, objidlen)
X    oid	    *objid;
X    int	    objidlen;	/* number of subidentifiers */
X{
X    char    buf[256];
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    get_symbol(objid, objidlen, subtree, buf + 1);
X    printf("%s\n", buf);
X        
X}
X
Xsprint_objid(buf, objid, objidlen)
X    char *buf;
X    oid	    *objid;
X    int	    objidlen;	/* number of subidentifiers */
X{
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    get_symbol(objid, objidlen, subtree, buf + 1);
X}
X
X
Xprint_variable(objid, objidlen, variable)
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    buf[512], *cp;
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    subtree = get_symbol(objid, objidlen, subtree, buf + 1);
X    cp = buf;
X    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !bcmp(buf, (char *)RFC1066_MIB_text,
X	strlen((char *)RFC1066_MIB_text))){
X	    cp += sizeof(RFC1066_MIB_text);
X    }
X    printf("Name: %s\n", cp);
X    *buf = '\0';
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X    printf("%s\n", buf);
X}
X
Xsprint_variable(buf, objid, objidlen, variable)
X    char *buf;
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512], *cp;
X    struct tree    *subtree = Mib;
X
X    *tempbuf = '.';	/* this is a fully qualified name */
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf + 1);
X    cp = tempbuf;
X    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !bcmp(buf, (char *)RFC1066_MIB_text,
X	strlen((char *)RFC1066_MIB_text))){
X	    cp += sizeof(RFC1066_MIB_text);
X    }
X    sprintf(buf, "Name: %s\n", cp);
X    buf += strlen(buf);
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X    strcat(buf, "\n");
X}
X
Xsprint_value(buf, objid, objidlen, variable)
X    char *buf;
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512];
X    struct tree    *subtree = Mib;
X
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf);
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X}
X
Xprint_value(objid, objidlen, variable)
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512];
X    struct tree    *subtree = Mib;
X
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf);
X    if (subtree->printer)
X	(*subtree->printer)(tempbuf, variable, subtree->enums);
X    else {
X	sprint_by_type(tempbuf, variable, subtree->enums);
X    }
X    printf("%s\n", tempbuf);
X}
X
Xstruct tree *
Xget_symbol(objid, objidlen, subtree, buf)
X    oid	    *objid;
X    int	    objidlen;
X    struct tree    *subtree;
X    char    *buf;
X{
X    struct tree    *return_tree = NULL;
X
X    for(; subtree; subtree = subtree->next_peer){
X	if (*objid == subtree->subid){
X	    strcpy(buf, subtree->label);
X	    goto found;
X	}
X    }
X
X    /* subtree not found */
X    while(objidlen--){	/* output rest of name, uninterpreted */
X	sprintf(buf, "%u.", *objid++);
X	while(*buf)
X	    buf++;
X    }
X    *(buf - 1) = '\0'; /* remove trailing dot */
X    return NULL;
X
Xfound:
X    if (objidlen > 1){
X	while(*buf)
X	    buf++;
X	*buf++ = '.';
X	*buf = '\0';
X	return_tree = get_symbol(objid + 1, objidlen - 1, subtree->child_list, buf);
X    } 
X    if (return_tree != NULL)
X	return return_tree;
X    else
X	return subtree;
X}
X
X
Xstatic int
Xlc_cmp(s1, s2)
X    char *s1, *s2;
X{
X    char c1, c2;
X
X    while(*s1 && *s2){
X	if (isupper(*s1))
X	    c1 = tolower(*s1);
X	else
X	    c1 = *s1;
X	if (isupper(*s2))
X	    c2 = tolower(*s2);
X	else
X	    c2 = *s2;
X	if (c1 != c2)
X	    return ((c1 - c2) > 0 ? 1 : -1);
X	s1++;
X	s2++;
X    }
X
X    if (*s1)
X	return -1;
X    if (*s2)
X	return 1;
X    return 0;
X}
X
END_OF_FILE
  if test 17927 -ne `wc -c <'netramet/src/snmplib/mib.c'`; then
    echo shar: \"'netramet/src/snmplib/mib.c'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/snmplib/mib.c'
fi
if test -f 'netramet/src/snmplib/snmpagnt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/snmplib/snmpagnt.c'\"
else
  echo shar: Extracting \"'netramet/src/snmplib/snmpagnt.c'\" \(18099 characters\)
  sed "s/^X//" >'netramet/src/snmplib/snmpagnt.c' <<'END_OF_FILE'
X/*
X * Simple Network Management Protocol (RFC 1067).
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X
X#include "ausnmp.h"
X
X#ifdef KINETICS
X#include "gw.h"
X#include "ab.h"
X#include "inet.h"
X#include "fp4/cmdmacro.h"
X#include "fp4/pbuf.h"
X#include "glob.h"
X#endif
X
X#if (defined(unix) && !defined(KINETICS))
X#include <sys/types.h>
X#include <netinet/in.h>
X#ifndef NULL
X#define NULL 0
X#endif
X#endif
X
X#include "snmp.h"
X#include "snmpimpl.h"  /* AU */
X#include "asn1.h"
X
X#include "mib.h"
X
Xvoid	snmp_input();
Xvoid	snmp_trap();
Xint	create_identical();
Xint	parse_var_op_list();
Xint	snmp_access();
X
X#if kinetics
Xchar	version_descr[];
Xoid	version_id[];
Xint	version_id_len;
X#endif
X
Xstruct pbuf *definitelyGetBuf();
X
X#define NUM_COMMUNITIES	5
Xchar	*communities[NUM_COMMUNITIES] = {
X    "public", 
X    "proxy",
X    "private",
X    "regional",
X    "core"
X};
X
X/* these can't be global in a multi-process router */
X    u_char	sid[SID_MAX_LEN + 1];
X    int		sidlen;
X    u_char	*packet_end;
X    int		community;
X
X
X#ifdef KINETICS
Xvoid
Xsnmp_input(p)
X    struct pbuf *p;
X{
X    struct ip	    *ip = (struct ip *)p->p_off;
X    int		    hlen = (int)ip->ip_hl << 2;
X    register struct udp	    *udp;
X    register u_char *data;  /* pointer to the rest of the unread data */
X    int		    length; /* bytes of data left in msg after the "data" pointer */
X    struct pbuf	    *out_packet;
X    register u_char *out_data;
X    int		    out_length;
X    u_short	    udp_src;
X    extern struct mib_udp   mib_udp;
X
X    
X    udp = (struct udp *)(p->p_off + hlen);
X    if (ntohs(ip->ip_len) - hlen < sizeof(struct udp) ||    /* IP length < minimum UDP packet */
X	    ntohs(udp->length) > ntohs(ip->ip_len) - hlen){ /* UDP length > IP data */
X	ERROR("dropped packet with bad length");    /* delete me */
X	return; /* drop packet */
X    }
X    data = (u_char *)udp + sizeof(struct udp);
X    length = ntohs(udp->length) - sizeof(struct udp);
X
X    out_packet = definitelyGetBuf(); /* drop packets off input queue if necessary */
X    out_data = (u_char *)(out_packet->p_off + sizeof (struct ip) + sizeof (struct udp));
X    out_length = MAXDATA - sizeof(struct ip) - sizeof (struct udp);
X
XK_LEDON();
X    if (!snmp_agent_parse(data, length, out_data, &out_length, (u_long)ip->ip_src)){
X	K_PFREE(out_packet);
XK_LEDOFF();
X	return;
X    }
XK_LEDOFF();
X    out_packet->p_len = packet_end - (u_char *)out_packet->p_off;
X    setiphdr(out_packet, ip->ip_src);	/* address to source of request packet (ntohl ??? ) */
X    udp_src = ntohs(udp->src);
X    udp = (struct udp *)(out_packet->p_off + sizeof (struct ip));
X    udp->src = htons(SNMP_PORT);
X    udp->dst = htons(udp_src);
X    udp->length = out_packet->p_len - sizeof(struct ip);
X    udp->checksum = 0;	/* this should be computed */
X
X    mib_udp.udpOutDatagrams++;
X    routeip(out_packet, 0, 0);
X}
X
X
Xvoid
Xsnmp_trap(destAddr, trapType, specificType)
X    u_long  destAddr;
X    int	    trapType;
X    int	    specificType;
X{
X    struct pbuf	    *out_packet;
X    register u_char *out_data;
X    register struct udp	    *udp;
X    int		    out_length;
X    static oid	    sysDescrOid[] = {1, 3, 6, 1, 2, 1, 1, 1, 0};
X    
X    out_packet = definitelyGetBuf(); /* drop packets off input queue if necessary */
X    out_data = (u_char *)(out_packet->p_off + sizeof (struct ip) + sizeof (struct udp));
X    out_length = MAXDATA - sizeof(struct ip) - sizeof (struct udp);
X
XK_LEDON();
X    out_packet->p_len = snmp_build_trap(out_data, out_length, version_id, version_id_len,
X	conf.ipaddr, trapType, specificType, TICKS2MS(tickclock)/10, sysDescrOid, sizeof(sysDescrOid)/sizeof(oid),
X	ASN_OCTET_STR, strlen(version_descr), (u_char *)version_descr);
X    if (out_packet->p_len == 0){
X	K_PFREE(out_packet);
XK_LEDOFF();
X	return;
X    }
XK_LEDOFF();
X    out_packet->p_len += sizeof(struct ip) + sizeof(struct udp);
X    setiphdr(out_packet, destAddr);	/* address to source of request packet (ntohl ??? ) */
X    udp = (struct udp *)(out_packet->p_off + sizeof (struct ip));
X    udp->src = htons(SNMP_PORT);
X    udp->dst = htons(SNMP_TRAP_PORT);
X    udp->length = out_packet->p_len - sizeof(struct ip);
X    udp->checksum = 0;	/* this should be computed */
X
X    mib_udp.udpOutDatagrams++;
X    routeip(out_packet, 0, 0);
X}
X#endif
X
Xint
Xsnmp_agent_parse(data, length, out_data, out_length, sourceip)
X    register u_char	*data;
X    int			length;
X    register u_char	*out_data;
X    int			*out_length;
X    u_long		sourceip;	/* possibly for authentication */
X{
X    u_char	    msg_type, type;
X    long	    zero = 0;
X    long	    reqid, errstat, errindex;
X    register u_char *out_auth, *out_header, *out_reqid;
X    u_char	    *startData = data;
X    int		    startLength = length;
X    long	    version;
X    int		    header_shift, auth_shift;
X
X    sidlen = SID_MAX_LEN;
X    data = snmp_auth_parse(data, &length, sid, &sidlen, &version); /* authenticates message and returns length if valid */
X    if (data == NULL){
X	ERROR("bad authentication");
X	/* send auth fail trap */
X	return 0;
X    }
X    if (version != SNMP_VERSION_1){
X	ERROR("wrong version");
X	return NULL;
X    }
X    community = get_community(sid);
X    if (community == -1)
X	return NULL;
X    data = asn_parse_header(data, &length, &msg_type);
X    if (data == NULL){
X	ERROR("bad header");
X	return 0;
X    }
X    if (msg_type != GET_REQ_MSG && msg_type != GETNEXT_REQ_MSG && msg_type != SET_REQ_MSG){
X	return 0;
X    }
X    data = asn_parse_int(data, &length, &type, &reqid, sizeof(reqid));
X    if (data == NULL){
X	ERROR("bad parse of reqid");
X	return 0;
X    }
X
X    data = asn_parse_int(data, &length, &type, &errstat, sizeof(errstat));
X    if (data == NULL){
X	ERROR("bad parse of errstat");
X	return 0;
X    }
X        data = asn_parse_int(data, &length, &type, &errindex, sizeof(errindex));
X    if (data == NULL){
X	ERROR("bad parse of errindex");
X	return 0;
X    }
X    /*
X     * Now start cobbling together what is known about the output packet.
X     * The final lengths are not known now, so they will have to be recomputed
X     * later.
X     */
X    out_auth = out_data;
X    out_header = snmp_auth_build(out_auth, out_length, sid, &sidlen, &zero, 0);
X    if (out_header == NULL){
X	ERROR("snmp_auth_build failed");
X	return 0;
X    }
X    out_reqid = asn_build_header(out_header, out_length, (u_char)GET_RSP_MSG, 0);
X    if (out_reqid == NULL){
X	ERROR("");
X	return 0;
X    }
X
X    type = (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
X    /* return identical request id */
X    out_data = asn_build_int(out_reqid, out_length, type, &reqid, sizeof(reqid));
X    if (out_data == NULL){
X	ERROR("build reqid failed");
X	return 0;
X    }
X
X    /* assume that error status will be zero */
X    out_data = asn_build_int(out_data, out_length, type, &zero, sizeof(zero));
X    if (out_data == NULL){
X	ERROR("build errstat failed");
X	return 0;
X    }
X
X    /* assume that error index will be zero */
X    out_data = asn_build_int(out_data, out_length, type, &zero, sizeof(zero));
X    if (out_data == NULL){
X	ERROR("build errindex failed");
X	return 0;
X    }
X    errstat = parse_var_op_list(data, length, out_data, *out_length, msg_type, &errindex, 0);
X    if (msg_type == SET_REQ_MSG && errstat == SNMP_ERR_NOERROR){
X	/*
X	 * SETS require 2 passes through the var_op_list.  The first pass verifies that
X	 * all types, lengths, and values are valid, and the second does the set.  Then
X	 * the identical GET RESPONSE packet is returned.
X	 */
X	errstat = parse_var_op_list(data, length, out_data, *out_length, msg_type, &errindex, 1);
X	if (create_identical(startData, out_auth, startLength, 0L, 0L)) {
X	    *out_length = packet_end - out_auth;  /* AU: Have to set this! */
X	    return 1;
X	}
X	return 0;
X    }
X    switch((short)errstat){
X	case SNMP_ERR_NOERROR:
X	    /*
X	     * Because of the assumption above that header lengths would be encoded
X	     * in one byte, things need to be fixed, now that the actual lengths are known.
X	     */
X	    header_shift = 0;
X	    *out_length = packet_end - out_reqid;
X	    if (*out_length >= 0x80){
X		header_shift++;
X		if (*out_length > 0xFF)
X		    header_shift++;
X	    }
X	    auth_shift = 0;
X	    *out_length = (packet_end - out_auth) - 2 + header_shift;
X	    if (*out_length >= 0x80){
X		auth_shift++;
X		if (*out_length > 0xFF)
X		    auth_shift++;
X	    }
X	    if (auth_shift + header_shift){
X		/*
X		 * Shift packet (from request id to end of packet) by the sum of the
X		 * necessary shift counts.
X		 */
X		shift_array(out_reqid, packet_end - out_reqid, auth_shift + header_shift);
X		/* Now adjust pointers into the packet */
X		packet_end += auth_shift + header_shift;
X		out_reqid += auth_shift + header_shift;
X		out_header += auth_shift;
X	    }
X	    
X	    /* re-encode the headers with the real lengths */
X	    out_data = out_header;
X	    *out_length = packet_end - out_reqid;
X	    out_data = asn_build_header(out_data, out_length, GET_RSP_MSG, *out_length);
X	    if (out_data != out_reqid){
X		ERROR("internal error: header");
X		return 0;
X	    }
X
X	    out_data = out_auth;
X	    *out_length = packet_end - out_auth;
X	    out_data = snmp_auth_build(out_data, out_length, sid, &sidlen, &zero, packet_end - out_header);
X	    if (out_data != out_header){
X		ERROR("internal error");
X		return 0;
X	    }
X	    break;
X	case SNMP_ERR_NOSUCHNAME:
X	case SNMP_ERR_TOOBIG:
X	case SNMP_ERR_BADVALUE:
X	case SNMP_ERR_READONLY:
X	case SNMP_ERR_GENERR:
X	    if (create_identical(startData, out_auth, startLength, errstat, errindex))
X		break;
X	    return 0;
X	default:
X	    return 0;
X    }
X    *out_length = packet_end - out_auth;
X    return 1;
X}
X
X/*
X * Parse_var_op_list goes through the list of variables and retrieves each one,
X * placing it's value in the output packet.  If doSet is non-zero, the variable is set
X * with the value in the packet.  If any error occurs, an error code is returned.
X */
Xint
Xparse_var_op_list(data, length, out_data, out_length, msgtype, index, doSet)
X    register u_char	*data;
X    int			length;
X    register u_char	*out_data;
X    int			out_length;
X    u_char		msgtype;
X    register long	*index;
X    int			doSet;
X{
X    u_char  type;
X    oid	    var_name[MAX_NAME_LEN];
X    int	    var_name_len, var_val_len;
X    u_char  var_val_type, *var_val, statType;
X    u_char far *statP;
X    int	    statLen;
X    u_short acl;
X    int	    rw, exact;
X    int	    (*write_method)();
X    u_char  *headerP, *var_list_start;
X    int	    dummyLen;
X    int	    header_shift;
X    u_char far *getStatPtr();
X
X    if (msgtype == SET_REQ_MSG)
X	rw = WRITE;
X    else
X	rw = READ;
X    if (msgtype == GETNEXT_REQ_MSG)
X	exact = FALSE;
X    else
X	exact = TRUE;
X    data = asn_parse_header(data, &length, &type);
X    if (data == NULL){
X	ERROR("not enough space for varlist");
X	return PARSE_ERROR;
X    }
X    if (type != (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR)){
X	ERROR("wrong type");
X	return PARSE_ERROR;
X    }
X    headerP = out_data;
X    out_data = asn_build_header(out_data, &out_length, (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), 0);
X    if (out_data == NULL){
X    	ERROR("not enough space in output packet");
X	return BUILD_ERROR;
X    }
X    var_list_start = out_data;
X
X    *index = 1;
X    while((int)length > 0){
X	/* parse the name, value pair */
X	var_name_len = MAX_NAME_LEN;
X	data = snmp_parse_var_op(data, var_name, &var_name_len, &var_val_type, &var_val_len, &var_val, (int *)&length);
X	if (data == NULL)
X	    return PARSE_ERROR;
X	/* now attempt to retrieve the variable on the local entity */
X	statP = getStatPtr(var_name, &var_name_len, &statType, &statLen, &acl, exact, &write_method);
X	if (statP == NULL)
X	    return SNMP_ERR_NOSUCHNAME;
X	/* Check if this user has access rights to this variable */
X	if (!snmp_access(acl, community, rw))
X	    return SNMP_ERR_NOSUCHNAME;	/* bogus */
X	if (msgtype == SET_REQ_MSG){
X	    if (write_method == 0){
X		/* see if the type and value is consistent with this entities variable */
X		if (!goodValue(var_val_type, var_val_len, statType, statLen)){
X		    return SNMP_ERR_BADVALUE;
X		}
X		/* actually do the set if necessary */
X		if (doSet)
X		    setVariable(var_val, var_val_type, var_val_len, statP, statLen);
X	    } else {
X		if (!(*write_method)(doSet, var_val, var_val_type, var_val_len, statP))
X		    return SNMP_ERR_BADVALUE;
X	    }
X	}
X	/* retrieve the value of the variable and place it into the outgoing packet */
X	out_data = snmp_build_var_op(out_data, var_name, &var_name_len, statType, statLen, statP, &out_length);
X	if (out_data == NULL){
X	    return SNMP_ERR_TOOBIG;
X	}
X
X	(*index)++;
X    }
X    packet_end = out_data;  /* save a pointer to the end of the packet */
X
X    /*
X     * Because of the assumption above that header lengths would be encoded
X     * in one byte, things need to be fixed, now that the actual lengths are known.
X     */
X    header_shift = 0;
X    out_length = packet_end - var_list_start;
X    if (out_length >= 0x80){
X	header_shift++;
X	if (out_length > 0xFF)
X	    header_shift++;
X    }
X    if (header_shift){
X	shift_array(var_list_start, packet_end - var_list_start, header_shift);
X	packet_end += header_shift;
X	var_list_start += header_shift;
X    }
X
X    /* Now rebuild header with the actual lengths */
X    dummyLen = packet_end - var_list_start;
X    if (asn_build_header(headerP, &dummyLen, (u_char)(ASN_SEQUENCE | ASN_CONSTRUCTOR), dummyLen) == NULL){
X	return SNMP_ERR_TOOBIG;	/* bogus error ???? */
X    }
X    *index = 0;
X    return SNMP_ERR_NOERROR;
X}
X
X/*
X * create a packet identical to the input packet, except for the error status
X * and the error index which are set according to the input variables.
X * Returns 1 upon success and 0 upon failure.
X */
Xint
Xcreate_identical(snmp_in, snmp_out, snmp_length, errstat, errindex)
X    u_char	    *snmp_in;
X    u_char	    *snmp_out;
X    int		    snmp_length;
X    long	    errstat, errindex;
X{
X    register u_char *data;
X    u_char	    type;
X    u_long	    dummy;
X    int		    length, headerLength;
X    register u_char *headerPtr, *reqidPtr, *errstatPtr, *errindexPtr, *varListPtr;
X
X    bcopy((char far *)snmp_in, (char far *)snmp_out, snmp_length);
X    length = snmp_length;
X    headerPtr = snmp_auth_parse(snmp_out, &length, sid, &sidlen, (long *)&dummy);
X    if (headerPtr == NULL)
X	return 0;
X    reqidPtr = asn_parse_header(headerPtr, &length, (u_char *)&dummy);
X    if (reqidPtr == NULL)
X	return 0;
X    headerLength = length;
X    errstatPtr = asn_parse_int(reqidPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* request id */
X    if (errstatPtr == NULL)
X	return 0;
X    errindexPtr = asn_parse_int(errstatPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* error status */
X    if (errindexPtr == NULL)
X	return 0;
X    varListPtr = asn_parse_int(errindexPtr, &length, &type, (long *)&dummy, sizeof dummy);	/* error index */
X    if (varListPtr == NULL)
X	return 0;
X
X    data = asn_build_header(headerPtr, &headerLength, GET_RSP_MSG, headerLength);
X    if (data != reqidPtr)
X	return 0;
X    length = snmp_length;
X    type = (u_char)(ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
X    data = asn_build_int(errstatPtr, &length, type, &errstat, sizeof errstat);
X    if (data != errindexPtr)
X	return 0;
X    data = asn_build_int(errindexPtr, &length, type, &errindex, sizeof errindex);
X    if (data != varListPtr)
X	return 0;
X    packet_end = snmp_out + snmp_length;
X    return 1;
X}
X
X#ifdef KINETICS
Xstruct pbuf *
XdefinitelyGetBuf(){
X    register struct pbuf *p;
X
X    K_PGET(PT_DATA, p);
X    while(p == 0){
X#ifdef notdef
X	if (pq->pq_head != NULL){
X	    K_PDEQ(SPLIMP, pq, p);
X	    if (p) K_PFREE(p);
X	} else if (sendq->pq_head != NULL){
X	    K_PDEQ(SPLIMP, sendq, p);
X	    if (p) K_PFREE(p);
X	}
X#endif
X	K_PGET(PT_DATA, p);
X    }
X    return p;
X}
X#endif
X
Xint
Xsnmp_access(acl, community, rw)
X    u_short 	acl;
X    int		community;
X    int		rw;
X{
X    /*
X     * Each group has 2 bits, the more significant one is for read access,
X     * the less significant one is for write access.
X     */
X
X    community <<= 1;	/* multiply by two two shift two bits at a time */
X    if (rw == READ){
X	return (acl & (2 << community));    /* return the correct bit */
X    } else {
X	return (acl & (1 << community));
X    }
X}
X
Xint
Xget_community(sessionid)
X    u_char	*sessionid;
X{
X    int	count;
X
X    for(count = 0; count < NUM_COMMUNITIES; count++){
X	if (!strcmp(communities[count], (char *)sessionid))
X	    break;
X    }
X    if (count == NUM_COMMUNITIES)
X	return -1;
X    return count;
X}
X
Xint
XgoodValue(inType, inLen, actualType, actualLen)
X    u_char	inType, actualType;
X    int		inLen, actualLen;
X{
X    if (inLen > actualLen)
X	return FALSE;
X    return (inType == actualType);
X}
X
XsetVariable(var_val, var_val_type, var_val_len, statP, statLen)
X    u_char  *var_val;
X    u_char  var_val_type;
X    int	    var_val_len;
X    u_char far *statP;
X    int	    statLen;
X{
X    int	    buffersize = 1000;
X
X    switch(var_val_type){
X	case ASN_INTEGER:
X	case COUNTER:
X	case GAUGE:
X	case TIMETICKS:
X	    asn_parse_int(var_val, &buffersize, &var_val_type, (long *)statP, statLen);
X	    break;
X	case ASN_OCTET_STR:
X	case IPADDRESS:
X	case OPAQUE:
X	    asn_parse_string(var_val, &buffersize, &var_val_type, statP, &statLen);
X	    break;
X	case ASN_OBJECT_ID:
X	    asn_parse_objid(var_val, &buffersize, &var_val_type, (oid *)statP, &statLen);
X	    break;
X    }
X}
X
X
END_OF_FILE
  if test 18099 -ne `wc -c <'netramet/src/snmplib/snmpagnt.c'`; then
    echo shar: \"'netramet/src/snmplib/snmpagnt.c'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/snmplib/snmpagnt.c'
fi
echo shar: End of archive 20 \(of 25\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
