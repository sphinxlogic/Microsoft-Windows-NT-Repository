Newsgroups: comp.sources.misc
From: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Subject: v40i106:  netramet - Network Traffic Accounting Meter, Part18/25
Message-ID: <1993Nov7.221348.12493@sparky.sterling.com>
X-Md4-Signature: 9142c693dfcf3aa7a22d10a4dff5b170
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sun, 7 Nov 1993 22:13:48 GMT
Approved: kent@sparky.sterling.com

Submitted-by: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Posting-number: Volume 40, Issue 106
Archive-name: netramet/part18
Environment: INET, UNIX, DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  netramet/src/manager/nmc_snmp.c
#   netramet/src/snmplib/~snmp_vars.c.kip
# Wrapped by kent@sparky on Tue Nov  2 18:17:10 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 25)."'
if test -f 'netramet/src/manager/nmc_snmp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/manager/nmc_snmp.c'\"
else
  echo shar: Extracting \"'netramet/src/manager/nmc_snmp.c'\" \(27166 characters\)
  sed "s/^X//" >'netramet/src/manager/nmc_snmp.c' <<'END_OF_FILE'
X/* 1427, Wed 5 Oct 93
X
X   NMC_SNMP.C:  NMC's SNMP interface with the meter
X
X   Copyright (C) 1992,1993 by Nevil Brownlee,
X   Computer Centre,  University of Auckland */
X
X/***********************************************************
X	Copyright 1988 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <sys/param.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <netdb.h>
X
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/time.h>
X#include <errno.h>
X
X#include <string.h>
X#include <malloc.h>
X
X#include "ausnmp.h"
X
X#include "snmp.h"
X#include "snmpimpl.h"
X#include "asn1.h"
X#include "snmpclnt.h"
X#include "snmpapi.h"
X#include "mib.h"
X
X#include "nmc.h"
X
X#ifndef BSD4_3
X#define BSD4_2
X#endif
X
X
X#define  INT_ACCT    1, 3, 6, 1, 3, 99
X#define  U_AUCKLAND  1, 3, 6, 1, 4, 1, 411
X
Xoid o_sysDescr[]	  = {MIB, 1, 1, 0};
Xoid o_sysUpTime[]	  = {MIB, 1, 3, 0};
Xoid o_ifNumber[]	  = {MIB, 2, 1, 0};
X
Xoid o_HighWaterMark[]     = {INT_ACCT, 1,  1, 0};
Xoid o_FloodMark[]         = {INT_ACCT, 1,  2, 0};
Xoid o_InactivityTimeout[] = {INT_ACCT, 1,  3, 0};
Xoid o_LastCollectTime[]   = {INT_ACCT, 1,  6, 0};
Xoid o_riRuleSize[]        = {INT_ACCT, 1,  7, 1, 2, 0xFF};
Xoid o_riActionSize[]      = {INT_ACCT, 1,  7, 1, 3, 0xFF};
Xoid o_CurrentRuleSet[]    = {INT_ACCT, 1,  8, 0};
Xoid o_EmergencyRuleSet[]  = {INT_ACCT, 1,  9, 0};
X
Xoid o_ftFlowIndex[]            = {INT_ACCT, 2, 1, 1,  1, 0xFFFF};
Xoid o_ftFlowStatus[]           = {INT_ACCT, 2, 1, 1,  2, 0xFFFF};
Xoid o_ftLowInterface[]         = {INT_ACCT, 2, 1, 1,  3, 0xFFFF};
Xoid o_ftLowAdjacentType[]      = {INT_ACCT, 2, 1, 1,  4, 0xFFFF};
Xoid o_ftLowAdjacentAddress[]   = {INT_ACCT, 2, 1, 1,  5, 0xFFFF};
Xoid o_ftLowAdjacentMask[]      = {INT_ACCT, 2, 1, 1,  6, 0xFFFF};
Xoid o_ftLowPeerType[]          = {INT_ACCT, 2, 1, 1,  7, 0xFFFF};
Xoid o_ftLowPeerTypeMask[]      = {INT_ACCT, 2, 1, 1,  8, 0xFFFF};
Xoid o_ftLowPeerAddress[]       = {INT_ACCT, 2, 1, 1,  9, 0xFFFF};
Xoid o_ftLowPeerMask[]          = {INT_ACCT, 2, 1, 1, 10, 0xFFFF};
Xoid o_ftLowDetailType[]        = {INT_ACCT, 2, 1, 1, 11, 0xFFFF};
Xoid o_ftLowDetailTypeMask[]    = {INT_ACCT, 2, 1, 1, 12, 0xFFFF};
Xoid o_ftLowDetailAddress[]     = {INT_ACCT, 2, 1, 1, 13, 0xFFFF};
Xoid o_ftLowDetailMask[]        = {INT_ACCT, 2, 1, 1, 14, 0xFFFF};
Xoid o_ftHighInterface[]        = {INT_ACCT, 2, 1, 1, 17, 0xFFFF};
Xoid o_ftHighAdjacentType[]     = {INT_ACCT, 2, 1, 1, 18, 0xFFFF};
Xoid o_ftHighAdjacentAddress[]  = {INT_ACCT, 2, 1, 1, 19, 0xFFFF};
Xoid o_ftHighAdjacentMask[]     = {INT_ACCT, 2, 1, 1, 20, 0xFFFF};
Xoid o_ftHighPeerType[]         = {INT_ACCT, 2, 1, 1, 21, 0xFFFF};
Xoid o_ftHighPeerTypeMask[]     = {INT_ACCT, 2, 1, 1, 22, 0xFFFF};
Xoid o_ftHighPeerAddress[]      = {INT_ACCT, 2, 1, 1, 23, 0xFFFF};
Xoid o_ftHighPeerMask[]         = {INT_ACCT, 2, 1, 1, 24, 0xFFFF};
Xoid o_ftHighDetailType[]       = {INT_ACCT, 2, 1, 1, 25, 0xFFFF};
Xoid o_ftHighDetailTypeMask[]   = {INT_ACCT, 2, 1, 1, 26, 0xFFFF};
Xoid o_ftHighDetailAddress[]    = {INT_ACCT, 2, 1, 1, 27, 0xFFFF};
Xoid o_ftHighDetailMask[]       = {INT_ACCT, 2, 1, 1, 28, 0xFFFF};
Xoid o_ftPDUScale[]             = {INT_ACCT, 2, 1, 1, 33, 0xFFFF};
Xoid o_ftOctetScale[]           = {INT_ACCT, 2, 1, 1, 34, 0xFFFF};
Xoid o_ftRuleSet[]              = {INT_ACCT, 2, 1, 1, 35, 0xFFFF};
Xoid o_ftFlowType[]             = {INT_ACCT, 2, 1, 1, 36, 0xFFFF};
Xoid o_ftUpOctets[]             = {INT_ACCT, 2, 1, 1, 37, 0xFFFF};
Xoid o_ftUpPDUs[]               = {INT_ACCT, 2, 1, 1, 38, 0xFFFF};
Xoid o_ftDownOctets[]           = {INT_ACCT, 2, 1, 1, 39, 0xFFFF};
Xoid o_ftDownPDUs[]             = {INT_ACCT, 2, 1, 1, 40, 0xFFFF};
Xoid o_ftFirstTime[]            = {INT_ACCT, 2, 1, 1, 41, 0xFFFF};
Xoid o_ftLastTime[]             = {INT_ACCT, 2, 1, 1, 42, 0xFFFF};
X
Xoid o_ftCreateTime[]	  = {INT_ACCT, 2, 2, 1, 1, 0xFFFFFFFF, 0xFFFF};
Xoid o_ftCreateIndex[]	  = {INT_ACCT, 2, 2, 1, 2, 0xFFFFFFFF, 0xFFFF};
X
Xoid o_ftActiveTime[]	  = {INT_ACCT, 2, 3, 1, 1, 0xFFFFFFFF, 0xFFFF};
Xoid o_ftActiveIndex[]	  = {INT_ACCT, 2, 3, 1, 2, 0xFFFFFFFF, 0xFFFF};
Xoid o_ftActiveFlowBlob[]  = {INT_ACCT, 2, 3, 1, 3, 0xFFFFFFFF, 0xFFFF};
X
Xoid o_ftColumnBlob[]  = {INT_ACCT, 2, 4, 1, 4, 0xFF, 0xFFFFFFFF, 0xFFFF};
X
Xoid o_rtSelector[]        = {INT_ACCT, 3, 1, 1, 3, 0xFF, 0xFFFF};
Xoid o_rtRuleMask[]        = {INT_ACCT, 3, 1, 1, 4, 0xFF, 0xFFFF};
Xoid o_rtMatchedValue[]    = {INT_ACCT, 3, 1, 1, 5, 0xFF, 0xFFFF};
Xoid o_rtRuleAction[]      = {INT_ACCT, 3, 1, 1, 6, 0xFF, 0xFFFF};
Xoid o_rtJumpIndex[]       = {INT_ACCT, 3, 1, 1, 7, 0xFF, 0xFFFF};
X
Xoid o_atLowInterface[]         = {INT_ACCT, 4, 1, 1,  3, 0xFF, 0xFFFF};
Xoid o_atLowAdjacentType[]      = {INT_ACCT, 4, 1, 1,  4, 0xFF, 0xFFFF};
Xoid o_atLowAdjacentAddress[]   = {INT_ACCT, 4, 1, 1,  5, 0xFF, 0xFFFF};
Xoid o_atLowAdjacentMask[]      = {INT_ACCT, 4, 1, 1,  6, 0xFF, 0xFFFF};
Xoid o_atLowPeerType[]          = {INT_ACCT, 4, 1, 1,  7, 0xFF, 0xFFFF};
Xoid o_atLowPeerTypeMask[]      = {INT_ACCT, 4, 1, 1,  8, 0xFF, 0xFFFF};
Xoid o_atLowPeerAddress[]       = {INT_ACCT, 4, 1, 1,  9, 0xFF, 0xFFFF};
Xoid o_atLowPeerMask[]          = {INT_ACCT, 4, 1, 1, 10, 0xFF, 0xFFFF};
Xoid o_atLowDetailType[]        = {INT_ACCT, 4, 1, 1, 11, 0xFF, 0xFFFF};
Xoid o_atLowDetailTypeMask[]    = {INT_ACCT, 4, 1, 1, 12, 0xFF, 0xFFFF};
Xoid o_atLowDetailAddress[]     = {INT_ACCT, 4, 1, 1, 13, 0xFF, 0xFFFF};
Xoid o_atLowDetailMask[]        = {INT_ACCT, 4, 1, 1, 14, 0xFF, 0xFFFF};
Xoid o_atHighInterface[]        = {INT_ACCT, 4, 1, 1, 17, 0xFF, 0xFFFF};
Xoid o_atHighAdjacentType[]     = {INT_ACCT, 4, 1, 1, 18, 0xFF, 0xFFFF};
Xoid o_atHighAdjacentAddress[]  = {INT_ACCT, 4, 1, 1, 19, 0xFF, 0xFFFF};
Xoid o_atHighAdjacentMask[]     = {INT_ACCT, 4, 1, 1, 20, 0xFF, 0xFFFF};
Xoid o_atHighPeerType[]         = {INT_ACCT, 4, 1, 1, 21, 0xFF, 0xFFFF};
Xoid o_atHighPeerTypeMask[]     = {INT_ACCT, 4, 1, 1, 22, 0xFF, 0xFFFF};
Xoid o_atHighPeerAddress[]      = {INT_ACCT, 4, 1, 1, 23, 0xFF, 0xFFFF};
Xoid o_atHighPeerMask[]         = {INT_ACCT, 4, 1, 1, 24, 0xFF, 0xFFFF};
Xoid o_atHighDetailType[]       = {INT_ACCT, 4, 1, 1, 25, 0xFF, 0xFFFF};
Xoid o_atHighDetailTypeMask[]   = {INT_ACCT, 4, 1, 1, 26, 0xFF, 0xFFFF};
Xoid o_atHighDetailAddress[]    = {INT_ACCT, 4, 1, 1, 27, 0xFF, 0xFFFF};
Xoid o_atHighDetailMask[]       = {INT_ACCT, 4, 1, 1, 28, 0xFF, 0xFFFF};
Xoid o_atPDUScale[]             = {INT_ACCT, 4, 1, 1, 33, 0xFF, 0xFFFF};
Xoid o_atOctetScale[]           = {INT_ACCT, 4, 1, 1, 34, 0xFF, 0xFFFF};
Xoid o_atRuleSet[]              = {INT_ACCT, 4, 1, 1, 35, 0xFF, 0xFFFF};
X
Xoid o_msStatsReset[]      = {U_AUCKLAND, 1,  1, 0};
Xoid o_msStatsTime[]       = {U_AUCKLAND, 1,  2, 0};
Xoid o_msNbrPackets[]      = {U_AUCKLAND, 1,  3, 0};
Xoid o_msTotPktBacklog[]   = {U_AUCKLAND, 1,  4, 0};
Xoid o_msMaxPktRate[]      = {U_AUCKLAND, 1,  5, 0};
Xoid o_msMaxPktBacklog[]   = {U_AUCKLAND, 1,  6, 0};
Xoid o_msNbrFlows[]        = {U_AUCKLAND, 1,  7, 0};
Xoid o_msFlowsRecovered[]  = {U_AUCKLAND, 1,  8, 0};
Xoid o_msRuleMatches[]     = {U_AUCKLAND, 1,  9, 0};
Xoid o_msHashSearches[]    = {U_AUCKLAND, 1, 10, 0};
Xoid o_msHashCompares[]    = {U_AUCKLAND, 1, 11, 0};
Xoid o_msTotalHashSize[]   = {U_AUCKLAND, 1, 12, 0};
Xoid o_msNbrHashEntries[]  = {U_AUCKLAND, 1, 13, 0};
Xoid o_msGCInterval[]      = {U_AUCKLAND, 1, 14, 0};
Xoid o_msMaxFlows[]        = {U_AUCKLAND, 1, 15, 0};
Xoid o_msAvIdle1000[]      = {U_AUCKLAND, 1, 16, 0};
Xoid o_msMinIdle1000[]     = {U_AUCKLAND, 1, 17, 0};
X
Xoid o_pcNearMem[]         = {U_AUCKLAND, 2, 1, 0};
Xoid o_pcFarMem[]          = {U_AUCKLAND, 2, 2, 0};
Xoid o_pcBadPackets[]      = {U_AUCKLAND, 2, 3, 0};
Xoid o_pcNoBufPackets[]    = {U_AUCKLAND, 2, 4, 0};
Xoid o_pcLostPackets[]     = {U_AUCKLAND, 2, 5, 0};
X
X
Xint start_snmp_session(struct meter_status *ms)
X{
X   struct snmp_session session, *ssp;
X
X   bzero((char *)&session, sizeof(struct snmp_session));
X   session.peername = ms->name;
X   session.community = ms->community;
X   session.community_len = strlen((char *)ms->community);
X   session.retries = SNMP_DEFAULT_RETRIES;
X   session.timeout = SNMP_DEFAULT_TIMEOUT;
X   session.authenticator = NULL;
X   snmp_synch_setup(&session);
X   ssp = snmp_open(&session);
X   if (ssp == NULL) {
X      printf("Couldn't open snmp to %s\n", session.peername);
X      return 0;
X      }
X   ms->ss = ssp;
X   return 1;
X   }
X
X#define ADD_VAR(v)            snmp_add_null_var(pdu, v, sizeof(v)/sizeof(oid))
X#define ADD_X_VAR(v,n1)         { v[sizeof(v)/sizeof(oid) - 1] = n1; \
X            ADD_VAR(v); }
X#define ADD_X2_VAR(v,n1,n2)     { v[sizeof(v)/sizeof(oid) - 2] = n1; \
X            v[sizeof(v)/sizeof(oid) - 1] = n2; \
X            ADD_VAR(v); }
X#define ADD_X3_VAR(v,n1,n2,n3)  { v[sizeof(v)/sizeof(oid) - 3] = n1; \
X            v[sizeof(v)/sizeof(oid) - 2] = n2; \
X            v[sizeof(v)/sizeof(oid) - 1] = n3; \
X            ADD_VAR(v); }
X
X#define SET_INT(v)            { vars->type = INTEGER; \
X  	    vars->val.integer = (long *)malloc(vars->val_len = sizeof(long)); \
X	    *(vars->val.integer) = (long)v; }
X#define SET_TIMETICKS(v)      { vars->type = TIMETICKS; \
X  	    vars->val.integer = (long *)malloc(vars->val_len = sizeof(long)); \
X	    *(vars->val.integer) = (long)v; }
X#define SET_STRING(v,len)     { vars->type = STRING; \
X	    vars->val.string = (u_char *)malloc(RULE_ADDR_LEN) ;\
X	    bcopy(v, (char *)vars->val.string, vars->val_len = len); }
X
X#define STRING_VAL(v)         bcopy(vars->val.string, v, vars->val_len)
X#define INT_VAL(v)            v = *(vars->val.integer)
X
X
Xint set_meter_params(struct meter_status *ms)
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X
X   if (ms->GCIntervalReqd == 0 && ms->HighWaterMark == 0 && 
X      ms->InactivityTime == 0) return 1;  /* Nothing to do */
X
X   pdu = snmp_pdu_create(SET_REQ_MSG);
X   i = 0;
X   if (ms->GCInterval != 0) {
X      ADD_VAR(o_msGCInterval);
X      vars = pdu->variables;  i = 1;
X      SET_INT(ms->GCIntervalReqd);
X      }
X   if (ms->HighWaterMark != 0) {
X      ADD_VAR(o_HighWaterMark);
X      vars = i ? vars->next_variable : pdu->variables;  i = 1;
X      SET_INT(ms->HighWaterMark);
X      }
X   if (ms->InactivityTime != 0) {
X      ADD_VAR(o_InactivityTimeout);
X      vars = i ? vars->next_variable : pdu->variables;
X      SET_INT(ms->InactivityTime);
X      }
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X         if (verbose) printf("Meter parameters set: GCI=%u, HWM=%u, IAT=%u\n",
X            ms->GCIntervalReqd,ms->HighWaterMark,ms->InactivityTime);
X         fprintf(log, "Meter parameters set: GCI=%u, HWM=%u, IAT=%u\n",
X            ms->GCIntervalReqd,ms->HighWaterMark,ms->InactivityTime);
X         fflush(log);
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return 1;
X   }
X
Xint set_collect_time(ms,v)  /* Set LastCollectTime for meter - */
Xstruct meter_status *ms;  /* this tells meter a collection is starting */
Xint v;
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X   pdu = snmp_pdu_create(SET_REQ_MSG);
X   ADD_VAR(o_LastCollectTime);
X   vars = pdu->variables;
X   SET_TIMETICKS(v);
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X         printf("Set %d: starting collection\n", ms->ruleset);
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return 1;
X   }
X
Xint set_rule_info(ms,setset)  /* 1 to set rule+action set */
Xstruct meter_status *ms;      /* 0 to set rule and actions tables sizes */
Xint setset;
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X   pdu = snmp_pdu_create(SET_REQ_MSG);
X   if (setset) {
X      ADD_VAR(o_CurrentRuleSet);
X         vars = pdu->variables;
X         SET_INT(ms->ruleset);
X      }
X   else {
X      ADD_X_VAR(o_riRuleSize, ms->ruleset);
X         vars = pdu->variables;
X         SET_INT(ms->nrules);
X      ADD_X_VAR(o_riActionSize, ms->ruleset);
X         vars = vars->next_variable;
X         SET_INT(ms->nactions);
X      }
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X         if (setset) printf(
X            "Meter is now using rule+action set %d\n", ms->ruleset);
X         else printf("Set %d: sizes set to %d rules + %d actions\n", 
X            ms->ruleset,ms->nrules,ms->nactions);
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return 1;
X   }
X
Xint add_rule(ms,ri)
Xstruct meter_status *ms;
Xstruct rule_info *ri;
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X
X   pdu = snmp_pdu_create(SET_REQ_MSG);
X   ADD_X2_VAR(o_rtSelector, ri->RuleSet,ri->RuleNbr);
X      vars = pdu->variables;
X      SET_INT(ri->RuleSelector);
X   ADD_X2_VAR(o_rtRuleMask, ri->RuleSet,ri->RuleNbr);
X      vars = vars->next_variable;
X      SET_STRING(ri->RuleMask,RULE_ADDR_LEN);
X   ADD_X2_VAR(o_rtMatchedValue, ri->RuleSet,ri->RuleNbr);
X      vars = vars->next_variable;
X      SET_STRING(ri->RuleMatchedValue,RULE_ADDR_LEN);
X   ADD_X2_VAR(o_rtRuleAction, ri->RuleSet,ri->RuleNbr);
X      vars = vars->next_variable;
X      SET_INT(ri->RuleAction);
X   ADD_X2_VAR(o_rtJumpIndex, ri->RuleSet,ri->RuleNbr);
X      vars = vars->next_variable;
X      SET_INT(ri->RuleJumpIndex);
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X         printf("Rule %d added to table %d\n", ri->RuleNbr,ri->RuleSet);
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return 1;
X   }
X
Xint add_action(struct meter_status *ms, struct flow_info *ai,
X   unsigned char ActionSet,unsigned char ActionNbr,
X   unsigned char *required)
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X
X   pdu = snmp_pdu_create(SET_REQ_MSG);
X   ADD_X2_VAR(o_atLowPeerType, ActionSet,ActionNbr);
X      vars = pdu->variables;
X      SET_INT(ai->LowPeerType);
X
X   if (required[FTLOWINTERFACE]) {
X      ADD_X2_VAR(o_atLowInterface, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->LowInterface);
X      }
X   if (required[FTLOWADJACENTTYPE]) {
X      ADD_X2_VAR(o_atLowAdjacentType, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->LowAdjType);
X      }
X   if (required[FTLOWADJACENTADDRESS]) {
X      ADD_X2_VAR(o_atLowAdjacentAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowAdjAddress,MAC_ADDR_LEN);
X      }
X   if (required[FTLOWADJACENTMASK]) {
X       ADD_X2_VAR(o_atLowAdjacentMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowAdjMask,MAC_ADDR_LEN);
X      }
X   if (required[FTLOWPEERTYPEMASK]) {
X      ADD_X2_VAR(o_atLowPeerTypeMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->LowPeerTypeMask);
X      }
X   if (required[FTLOWPEERADDRESS]) {
X      ADD_X2_VAR(o_atLowPeerAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowPeerAddress,PEER_ADDR_LEN);
X      }
X   if (required[FTLOWPEERMASK]) {
X      ADD_X2_VAR(o_atLowPeerMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowPeerMask,PEER_ADDR_LEN);
X      }
X   if (required[FTLOWDETAILTYPE]) {
X      ADD_X2_VAR(o_atLowDetailType, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->LowDetailType);
X      }
X   if (required[FTLOWDETAILTYPEMASK]) {
X      ADD_X2_VAR(o_atLowDetailTypeMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->LowDetailTypeMask);
X      }
X   if (required[FTLOWDETAILADDRESS]) {
X      ADD_X2_VAR(o_atLowDetailAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowDetailAddress,DETAIL_ADDR_LEN);
X      }
X   if (required[FTLOWDETAILMASK]) {
X      ADD_X2_VAR(o_atLowDetailMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->LowDetailMask,DETAIL_ADDR_LEN);
X      }
X   if (required[FTHIINTERFACE]) {
X      ADD_X2_VAR(o_atHighInterface, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighInterface);
X      }
X   if (required[FTHIADJACENTTYPE]) {
X      ADD_X2_VAR(o_atHighAdjacentType, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighAdjType);
X      }
X   if (required[FTHIADJACENTADDRESS]) {
X      ADD_X2_VAR(o_atHighAdjacentAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighAdjAddress,MAC_ADDR_LEN);
X      }
X   if (required[FTHIADJACENTMASK]) {
X      ADD_X2_VAR(o_atHighAdjacentMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighAdjMask,MAC_ADDR_LEN);
X      }
X   if (required[FTHIPEERTYPE]) {
X      ADD_X2_VAR(o_atHighPeerType, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighPeerType);
X      }
X   if (required[FTHIPEERTYPEMASK]) {
X      ADD_X2_VAR(o_atHighPeerTypeMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighPeerTypeMask);
X      }
X   if (required[FTHIPEERADDRESS]) {
X      ADD_X2_VAR(o_atHighPeerAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighPeerAddress,PEER_ADDR_LEN);
X      }
X   if (required[FTHIPEERMASK]) {
X      ADD_X2_VAR(o_atHighPeerMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighPeerMask,PEER_ADDR_LEN);
X      }
X   if (required[FTHIDETAILTYPE]) {
X      ADD_X2_VAR(o_atHighDetailType, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighDetailType);
X      }
X   if (required[FTHIDETAILTYPEMASK]) {
X      ADD_X2_VAR(o_atHighDetailTypeMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_INT(ai->HighDetailTypeMask);
X      }
X   if (required[FTHIDETAILADDRESS]) {
X      ADD_X2_VAR(o_atHighDetailAddress, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighDetailAddress,DETAIL_ADDR_LEN);
X      }
X   if (required[FTHIDETAILMASK]) {
X      ADD_X2_VAR(o_atHighDetailMask, ActionSet,ActionNbr);
X      vars = vars->next_variable;
X      SET_STRING(ai->HighDetailMask,DETAIL_ADDR_LEN);
X      }
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X         printf("Action %d added to table %d\n", ActionNbr,ActionSet);
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return 1;
X   }
X
Xint same_acct_oid(oid *a, oid *b)  
X   /* Compare oids for equality within internet-accounting MIB */
X{
X   int j;
X   for (j = 6; j != 10; ++j) {
X      if (a[j] != b[j]) return 0;
X      }
X   return 1;
X   }
X
Xint column_info(struct meter_status *ms, unsigned char *fb,
X   unsigned char a, unsigned long ft, int *fn)
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X   int result;
X
X   if (testing) printf("column_info(ms,fb,a=%d,ft=%lu,fn=%d)\n",a,ft,*fn);
X   pdu = snmp_pdu_create(GETNEXT_REQ_MSG);
X   ADD_X3_VAR(o_ftColumnBlob,a,ft,*fn)
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X	 vars = response->variables;
X         if (!same_acct_oid(vars->name,o_ftColumnBlob)) 
X            return 0;  /* No more flows with last-active time > ft */
X	 STRING_VAL(fb);  result = vars->val_len;
X	 }
X      else if (response->errstat == SNMP_ERR_NOSUCHNAME) return 0;
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 printf("This name does not exist: ");
X	 for (count=1, vars = response->variables;
X	    vars && count != response->errindex;
X	 vars = vars->next_variable, count++) ;
X	 if (vars) print_objid(vars->name, vars->name_length);
X	 printf("\n");
X         result = 0;
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X   return result;
X   }
X
Xint meter_info(ms)
Xstruct meter_status *ms;
X{
X   int i, count, status;
X   struct snmp_pdu *pdu, *response;
X   struct variable_list *vars;
X
X   if (testing) printf("meter_info(ms)\n");
X   pdu = snmp_pdu_create(GET_REQ_MSG);
X   ADD_VAR(o_sysDescr);
X   ADD_VAR(o_sysUpTime);
X   ADD_VAR(o_LastCollectTime);
X   ADD_VAR(o_CurrentRuleSet);
X   ADD_VAR(o_msMaxFlows);
X   if (ms->statsreqd) {
X      ADD_VAR(o_msStatsTime);
X      ADD_VAR(o_msNbrPackets);
X      ADD_VAR(o_msTotPktBacklog);
X      ADD_VAR(o_msMaxPktRate);
X      ADD_VAR(o_msMaxPktBacklog);
X      ADD_VAR(o_msNbrFlows);
X      ADD_VAR(o_msFlowsRecovered);
X      ADD_VAR(o_msRuleMatches);
X      ADD_VAR(o_msHashSearches);
X      ADD_VAR(o_msHashCompares);
X      ADD_VAR(o_msTotalHashSize);
X      ADD_VAR(o_msNbrHashEntries);
X      ADD_VAR(o_msGCInterval);
X      ADD_VAR(o_msAvIdle1000);
X      ADD_VAR(o_msMinIdle1000);
X      ADD_VAR(o_pcLostPackets);
X      }
X
X   status = snmp_synch_response(ms->ss, pdu, &response);
X   if (status == STAT_SUCCESS) {
X      if (response->errstat == SNMP_ERR_NOERROR) {
X	 vars = response->variables;
X	 STRING_VAL(ms->descr);
X         vars = vars->next_variable;
X	 INT_VAL(ms->uptime);
X         vars = vars->next_variable;
X	 INT_VAL(ms->LastCollectTime);
X         vars = vars->next_variable;
X	 INT_VAL(ms->CurrentRuleSet);
X         vars = vars->next_variable;
X	 INT_VAL(ms->MaxFlows);
X         if (ms->statsreqd) {
X            vars = vars->next_variable;
X            INT_VAL(ms->StatsTime);
X            vars = vars->next_variable;
X            INT_VAL(ms->NbrPackets);
X            vars = vars->next_variable;
X            INT_VAL(ms->TotPktBacklog);
X            vars = vars->next_variable;
X            INT_VAL(ms->MaxPktRate);
X            vars = vars->next_variable;
X            INT_VAL(ms->MaxPktBacklog);
X            vars = vars->next_variable;
X            INT_VAL(ms->NbrFlows);
X            vars = vars->next_variable;
X            INT_VAL(ms->FlowsRecovered);
X            vars = vars->next_variable;
X            INT_VAL(ms->RuleMatches);
X            vars = vars->next_variable;
X            INT_VAL(ms->HashSearches);
X            vars = vars->next_variable;
X            INT_VAL(ms->HashCompares);
X            vars = vars->next_variable;
X            INT_VAL(ms->TotalHashSize);
X            vars = vars->next_variable;
X            INT_VAL(ms->NbrHashEntries);
X            vars = vars->next_variable;
X            INT_VAL(ms->GCInterval);
X            vars = vars->next_variable;
X            INT_VAL(ms->AvIdle1000);
X            vars = vars->next_variable;
X            INT_VAL(ms->MinIdle1000);
X            vars = vars->next_variable;
X            INT_VAL(ms->LostPackets);
X            if (testing) printf("  stats read: StatsTime=%lu\n",ms->StatsTime);
X            }
X	 }
X      else {
X	 printf("Error in packet, reason = %s\n",
X	    snmp_errstring(response->errstat));
X	 if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	    printf("This name does not exist: ");
X	    for (count=1, vars = response->variables;
X	       vars && count != response->errindex;
X		  vars = vars->next_variable, count++) ;
X	    if (vars) print_objid(vars->name, vars->name_length);
X	    printf("\n");
X	    }
X	 }
X      }
X   else return 0;
X   snmp_free_pdu(response);
X   mswait(ms->snmp_delay);
X
X   if (ms->statsreqd) {  /* Zero meter statistics */
X      pdu = snmp_pdu_create(SET_REQ_MSG);
X      ADD_VAR(o_msStatsReset);
X      vars = pdu->variables;
X      SET_INT(1);
X      status = snmp_synch_response(ms->ss, pdu, &response);
X      if (status == STAT_SUCCESS) {
X         if (testing) printf("  stats zeroed\n");
X         if (response->errstat != SNMP_ERR_NOERROR) {
X            printf("Error in packet, reason = %s\n",
X	       snmp_errstring(response->errstat));
X	    if (response->errstat == SNMP_ERR_NOSUCHNAME) {
X	       printf("This name does not exist: ");
X	       for (count=1, vars = response->variables;
X	          vars && count != response->errindex;
X		     vars = vars->next_variable, count++) ;
X	       if (vars) print_objid(vars->name, vars->name_length);
X	       printf("\n");
X	       }
X	    }
X         }
X      else return 0;
X      snmp_free_pdu(response);
X      mswait(ms->snmp_delay);
X      }
X   return 1;
X   }
X
END_OF_FILE
  if test 27166 -ne `wc -c <'netramet/src/manager/nmc_snmp.c'`; then
    echo shar: \"'netramet/src/manager/nmc_snmp.c'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/manager/nmc_snmp.c'
fi
if test -f 'netramet/src/snmplib/~snmp_vars.c.kip' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/snmplib/~snmp_vars.c.kip'\"
else
  echo shar: Extracting \"'netramet/src/snmplib/~snmp_vars.c.kip'\" \(33903 characters\)
  sed "s/^X//" >'netramet/src/snmplib/~snmp_vars.c.kip' <<'END_OF_FILE'
X/*
X * snmp_vars.c - return a pointer to the named variable.
X *
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#ifdef KINETICS
X#include "gw.h"
X#include "fp4/pbuf.h"
X#include "fp4/cmdmacro.h"
X#include "ab.h"
X#include "glob.h"
X#endif
X
X#if (defined(unix) && !defined(KINETICS))
X#include <sys/types.h>
X#include <netinet/in.h>
X#ifndef NULL
X#define NULL 0
X#endif
X#endif
X
X
X#include "asn1.h"
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "mib.h"
X#include "inet.h"
X#include "snmp_vars.h"
X/*
X *	Each variable name is placed in the variable table, without the terminating
X * substring that determines the instance of the variable.  When a string is found that
X * is lexicographicly preceded by the input string, the function for that entry is
X * called to find the method of access of the instance of the named variable.  If
X * that variable is not found, NULL is returned, and the search through the table
X * continues (it should stop at the next entry).  If it is found, the function returns
X * a character pointer and a length or a function pointer.  The former is the address
X * of the operand, the latter is an access routine for the variable.
X *
X * u_char *
X * findVar(name, length, exact, var_len, access_method)
X * oid	    *name;	    IN/OUT - input name requested, output name found
X * int	    length;	    IN/OUT - number of sub-ids in the in and out oid's
X * int	    exact;	    IN - TRUE if an exact match was requested.
X * int	    len;	    OUT - length of variable or 0 if function returned.
X * int	    access_method; OUT - 1 if function, 0 if char pointer.
X *
X * accessVar(rw, var, varLen)
X * int	    rw;	    IN - request to READ or WRITE the variable
X * u_char   *var;   IN/OUT - input or output buffer space
X * int	    *varLen;IN/OUT - input and output buffer len
X */
X
Xstruct variable {
X    oid		    name[16];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char	    *(*findVar)();  /* function that finds variable */
X};
X
Xchar		version_descr[30] = "Kinetics FastPath4";
Xoid		version_id[] = {1, 3, 6, 1, 4, 1, 3, 1, 1};
Xint		version_id_len = sizeof(version_id);
Xu_long		uptime;
Xlong		cfg_nnets = MAX_INTERFACES;
Xlong		long_return;
Xu_char		return_buf[64];
X
X
Xstruct mib_ifEntry  mib_ifEntry_proto[MAX_INTERFACES] = {
X    {1, "Kinetics KFPS2 Ethernet", MIB_IFTYPE_ETHERNETCSMACD, 
X    	1500, 10000000L, "", 
X	6, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
X    {2, "Kinetics KFPS2 Appletalk", MIB_IFTYPE_OTHER,
X    	1500, 230000L, "", 
X	3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
X};
Xstruct mib_ifEntry mib_ifEntry[MAX_INTERFACES];
X
Xstruct mib_ip mib_ip_proto = {
X    1, IPFRAGTTL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
X};
Xstruct mib_ip mib_ip;
X
X#define ROUTE_DEFAULT	0
X#define ROUTE_LOCAL	1
Xstruct mib_ipRouteEntry mib_ipRouteEntry_proto[2] = {
X    {0, 1, 1, -1, -1, -1, 0, MIB_IPROUTETYPE_REMOTE, MIB_IPROUTEPROTO_LOCAL, 0},    /* default route */
X    {0, 1, 0, -1, -1, -1, 0, MIB_IPROUTETYPE_DIRECT, MIB_IPROUTEPROTO_LOCAL, 0}	    /* local route */
X};
Xstruct mib_ipRouteEntry mib_ipRouteEntry[2];
X
Xstruct mib_udp mib_udp_proto = {
X    0, 0, 0, 0
X};
Xstruct mib_udp mib_udp;
X
Xlong	mib_icmpInMsgs;
Xlong	mib_icmpOutMsgs;
Xlong	mib_icmpInErrors;	/* not checked in KIP */
Xlong	mib_icmpOutErrors;	/* not checked in KIP */
Xlong	mib_icmpInCount[ICMP_MAXTYPE + 1];
Xlong	mib_icmpOutCount[ICMP_MAXTYPE + 1];
X
X
Xinit_snmp(){
X    bcopy((char *)mib_ifEntry_proto, (char *)mib_ifEntry, sizeof(mib_ifEntry));
X    bcopy((char *)&mib_ip_proto, (char *)&mib_ip, sizeof(mib_ip));
X    bcopy((char *)mib_ipRouteEntry_proto, (char *)mib_ipRouteEntry, sizeof(mib_ipRouteEntry));
X    bcopy((char *)&mib_udp_proto, (char *)&mib_udp, sizeof(mib_udp));
X}
X
X/*
X * These are byte offsets into their structures.
X * This really should be computed by the compiler, but the
X * compiler I'm using doesn't want to do this.
X */
X#define VERSION_DESCR	0
X#define VERSION_ID	32
X#define CFG_NNETS	48
X#define UPTIME		52
X
X#define IFINDEX		0
X#define IFDESCR		4
X#define IFTYPE		36
X#define IFMTU		40
X#define IFSPEED		44
X#define IFPHYSADDRESS	48
X#define IFADMINSTATUS	60
X#define IFOPERSTATUS	64
X#define IFLASTCHANGE	68
X#define IFINOCTETS	72
X#define IFINUCASTPKTS	76
X#define	IFINNUCASTPKTS	80
X#define	IFINDISCARDS	84
X#define	IFINERRORS	88
X#define	IFINUNKNOWNPROTOS   92
X#define	IFOUTOCTETS	96
X#define	IFOUTUCASTPKTS	100
X#define	IFOUTNUCASTPKTS	104
X#define	IFOUTDISCARDS	108
X#define	IFOUTERRORS	112
X#define	IFOUTQLEN	116
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	4
X#define ATNETADDRESS	16
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	4
X#define IPINRECEIVES	8
X#define IPINHDRERRORS	12
X#define IPINADDRERRORS	16
X#define IPFORWDATAGRAMS	20
X#define IPINUNKNOWNPROTOS   24
X#define IPINDISCARDS	28
X#define IPINDELIVERS	32
X#define IPOUTREQUESTS	36
X#define IPOUTDISCARDS	40
X#define IPOUTNOROUTES	44
X#define IPREASMTIMEOUT	48
X#define IPREASMREQDS	52
X#define IPREASMOKS	56
X#define IPREASMFAILS	60
X#define IPFRAGOKS	64
X#define IPFRAGFAILS	68
X#define IPFRAGCREATES	72
X
X#define IPADADDR	0
X#define IPADIFINDEX	4
X#define IPADNETMASK	8
X#define IPADBCASTADDR	12
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	4
X#define IPROUTEMETRIC1	8
X#define IPROUTEMETRIC2	12
X#define IPROUTEMETRIC3	16
X#define IPROUTEMETRIC4	20
X#define IPROUTENEXTHOP	24
X#define IPROUTETYPE	28
X#define IPROUTEPROTO	32
X#define IPROUTEAGE	36
X
X#define	ICMPINMSGS	    0
X#define	ICMPINERRORS	    4
X#define	ICMPINDESTUNREACHS  8
X#define	ICMPINTIMEEXCDS	    12
X#define	ICMPINPARMPROBS	    16
X#define	ICMPINSRCQUENCHS    20
X#define	ICMPINREDIRECTS	    24
X#define	ICMPINECHOS	    28
X#define	ICMPINECHOREPS	    32
X#define	ICMPINTIMESTAMPS    36
X#define	ICMPINTIMESTAMPREPS 40
X#define	ICMPINADDRMASKS	    44
X#define	ICMPINADDRMASKREPS  48
X#define	ICMPOUTMSGS	    52
X#define	ICMPOUTERRORS	    56
X#define	ICMPOUTDESTUNREACHS 60
X#define	ICMPOUTTIMEEXCDS    64
X#define	ICMPOUTPARMPROBS    68
X#define	ICMPOUTSRCQUENCHS   72
X#define	ICMPOUTREDIRECTS    76
X#define	ICMPOUTECHOS	    80
X#define	ICMPOUTECHOREPS	    84
X#define	ICMPOUTTIMESTAMPS   88
X#define	ICMPOUTTIMESTAMPREPS	92
X#define	ICMPOUTADDRMASKS    96
X#define	ICMPOUTADDRMASKREPS 100
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    4
X#define	UDPINERRORS	    8
X#define UDPOUTDATAGRAMS	    12
X
Xstruct variable	    variables[] = {
X    /* these must be lexicographly ordered by the name field */
X    {{MIB, 1, 1, 0},		9, STRING,  VERSION_DESCR, RONLY, var_system },
X    {{MIB, 1, 2, 0},		9, OBJID,   VERSION_ID, RONLY, var_system },
X    {{MIB, 1, 3, 0},		9, TIMETICKS, UPTIME, RONLY, var_system },
X    {{MIB, 2, 1, 0},		9, INTEGER, CFG_NNETS, RONLY, var_system },
X    {{MIB, 2, 2, 1, 1, 0xFF},  11, INTEGER, IFINDEX, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 2, 0xFF},  11, STRING,  IFDESCR, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 3, 0xFF},  11, INTEGER, IFTYPE, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 4, 0xFF},  11, INTEGER, IFMTU, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 5, 0xFF},  11, GAUGE,   IFSPEED, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 6, 0xFF},  11, STRING,  IFPHYSADDRESS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 7, 0xFF},  11, INTEGER, IFADMINSTATUS, RWRITE, var_ifEntry },
X    {{MIB, 2, 2, 1, 8, 0xFF},  11, INTEGER, IFOPERSTATUS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 9, 0xFF},  11, TIMETICKS, IFLASTCHANGE, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 10, 0xFF}, 11, COUNTER, IFINOCTETS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 11, 0xFF}, 11, COUNTER, IFINUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 12, 0xFF}, 11, COUNTER, IFINNUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 13, 0xFF}, 11, COUNTER, IFINDISCARDS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 14, 0xFF}, 11, COUNTER, IFINERRORS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 15, 0xFF}, 11, COUNTER, IFINUNKNOWNPROTOS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 16, 0xFF}, 11, COUNTER, IFOUTOCTETS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 17, 0xFF}, 11, COUNTER, IFOUTUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 18, 0xFF}, 11, COUNTER, IFOUTNUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 19, 0xFF}, 11, COUNTER, IFOUTDISCARDS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 20, 0xFF}, 11, COUNTER, IFOUTERRORS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 21, 0xFF}, 11, GAUGE,   IFOUTQLEN, RONLY, var_ifEntry },
X    {{MIB, 3, 1, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, INTEGER,    ATIFINDEX, RWRITE, var_atEntry }, 
X    {{MIB, 3, 1, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, STRING,	    ATPHYSADDRESS, RWRITE, var_atEntry }, 
X    {{MIB, 3, 1, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, IPADDRESS,  ATNETADDRESS, RWRITE, var_atEntry },
X    {{MIB, 4, 1, 0},	    9, INTEGER, IPFORWARDING, RONLY, var_ip },
X    {{MIB, 4, 2, 0},	    9, INTEGER, IPDEFAULTTTL, RWRITE, var_ip },
X    {{MIB, 4, 3, 0},	    9, COUNTER, IPINRECEIVES, RONLY, var_ip },
X    {{MIB, 4, 4, 0},	    9, COUNTER, IPINHDRERRORS, RONLY, var_ip },
X    {{MIB, 4, 5, 0},	    9, COUNTER, IPINADDRERRORS, RONLY, var_ip },
X    {{MIB, 4, 6, 0},	    9, COUNTER, IPFORWDATAGRAMS, RONLY, var_ip },
X    {{MIB, 4, 7, 0},	    9, COUNTER, IPINUNKNOWNPROTOS, RONLY, var_ip },
X    {{MIB, 4, 8, 0},	    9, COUNTER, IPINDISCARDS, RONLY, var_ip },
X    {{MIB, 4, 9, 0},	    9, COUNTER, IPINDELIVERS, RONLY, var_ip },
X    {{MIB, 4, 10, 0},	    9, COUNTER, IPOUTREQUESTS, RONLY, var_ip },
X    {{MIB, 4, 11, 0},	    9, COUNTER, IPOUTDISCARDS, RONLY, var_ip },
X    {{MIB, 4, 12, 0},	    9, COUNTER, IPOUTNOROUTES, RONLY, var_ip },
X    {{MIB, 4, 13, 0},	    9, INTEGER, IPREASMTIMEOUT, RONLY, var_ip },
X    {{MIB, 4, 14, 0},	    9, COUNTER, IPREASMREQDS, RONLY, var_ip },
X    {{MIB, 4, 15, 0},	    9, COUNTER, IPREASMOKS, RONLY, var_ip },
X    {{MIB, 4, 16, 0},	    9, COUNTER, IPREASMFAILS, RONLY, var_ip },
X    {{MIB, 4, 17, 0},	    9, COUNTER, IPFRAGOKS, RONLY, var_ip },
X    {{MIB, 4, 18, 0},	    9, COUNTER, IPFRAGFAILS, RONLY, var_ip },
X    {{MIB, 4, 19, 0},	    9, COUNTER, IPFRAGCREATES, RONLY, var_ip },
X    {{MIB, 4, 20, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPADADDR, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPADIFINDEX, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPADNETMASK, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 4, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPADBCASTADDR, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 21, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPROUTEDEST, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEIFINDEX, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC1, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 4, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC2, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 5, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC3, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 6, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC4, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 7, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPROUTENEXTHOP, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 8, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTETYPE, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 9, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEPROTO, RONLY, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 10, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEAGE, RWRITE, var_ipRouteEntry },
X    {{MIB, 5, 1, 0},	    9, COUNTER, ICMPINMSGS, RONLY, var_icmp },
X    {{MIB, 5, 2, 0},	    9, COUNTER, ICMPINERRORS, RONLY, var_icmp },
X    {{MIB, 5, 3, 0},	    9, COUNTER, ICMPINDESTUNREACHS, RONLY, var_icmp },
X    {{MIB, 5, 4, 0},	    9, COUNTER, ICMPINTIMEEXCDS, RONLY, var_icmp },
X    {{MIB, 5, 5, 0},	    9, COUNTER, ICMPINPARMPROBS, RONLY, var_icmp },
X    {{MIB, 5, 6, 0},	    9, COUNTER, ICMPINSRCQUENCHS, RONLY, var_icmp },
X    {{MIB, 5, 7, 0},	    9, COUNTER, ICMPINREDIRECTS, RONLY, var_icmp },
X    {{MIB, 5, 8, 0},	    9, COUNTER, ICMPINECHOS, RONLY, var_icmp },
X    {{MIB, 5, 9, 0},	    9, COUNTER, ICMPINECHOREPS, RONLY, var_icmp },
X    {{MIB, 5, 10, 0},	    9, COUNTER, ICMPINTIMESTAMPS, RONLY, var_icmp },
X    {{MIB, 5, 11, 0},	    9, COUNTER, ICMPINTIMESTAMPREPS, RONLY, var_icmp },
X    {{MIB, 5, 12, 0},	    9, COUNTER, ICMPINADDRMASKS, RONLY, var_icmp },
X    {{MIB, 5, 13, 0},	    9, COUNTER, ICMPINADDRMASKREPS, RONLY, var_icmp },
X    {{MIB, 5, 14, 0},	    9, COUNTER, ICMPOUTMSGS, RONLY, var_icmp },
X    {{MIB, 5, 15, 0},	    9, COUNTER, ICMPOUTERRORS, RONLY, var_icmp },
X    {{MIB, 5, 16, 0},	    9, COUNTER, ICMPOUTDESTUNREACHS, RONLY, var_icmp },
X    {{MIB, 5, 17, 0},	    9, COUNTER, ICMPOUTTIMEEXCDS, RONLY, var_icmp },
X    {{MIB, 5, 18, 0},	    9, COUNTER, ICMPOUTPARMPROBS, RONLY, var_icmp },
X    {{MIB, 5, 19, 0},	    9, COUNTER, ICMPOUTSRCQUENCHS, RONLY, var_icmp },
X    {{MIB, 5, 20, 0},	    9, COUNTER, ICMPOUTREDIRECTS, RONLY, var_icmp },
X    {{MIB, 5, 21, 0},	    9, COUNTER, ICMPOUTECHOS, RONLY, var_icmp },
X    {{MIB, 5, 22, 0},	    9, COUNTER, ICMPOUTECHOREPS, RONLY, var_icmp },
X    {{MIB, 5, 23, 0},	    9, COUNTER, ICMPOUTTIMESTAMPS, RONLY, var_icmp },
X    {{MIB, 5, 24, 0},	    9, COUNTER, ICMPOUTTIMESTAMPREPS, RONLY, var_icmp },
X    {{MIB, 5, 25, 0},	    9, COUNTER, ICMPOUTADDRMASKS, RONLY, var_icmp },
X    {{MIB, 5, 26, 0},	    9, COUNTER, ICMPOUTADDRMASKREPS, RONLY, var_icmp },
X    {{MIB, 7, 1, 0},	    9, COUNTER, UDPINDATAGRAMS, RONLY, var_udp }, 
X    {{MIB, 7, 2, 0},	    9, COUNTER, UDPNOPORTS, RONLY, var_udp },
X    {{MIB, 7, 3, 0},	    9, COUNTER, UDPINERRORS, RONLY, var_udp }, 
X    {{MIB, 7, 4, 0},	    9, COUNTER, UDPOUTDATAGRAMS, RONLY, var_udp }
X};
X
X
X
X
X/*
X * getStatPtr - return a pointer to the named variable, as well as it's
X * type, length, and access control list.
X *
X * If an exact match for the variable name exists, it is returned.  If not,
X * and exact is false, the next variable lexicographically after the
X * requested one is returned.
X *
X * If no appropriate variable can be found, NULL is returned.
X */
Xu_char  *
XgetStatPtr(name, namelen, type, len, acl, exact, access_method)
X    oid		*name;	    /* IN - name of var, OUT - name matched */
X    int		*namelen;   /* IN -number of sub-ids in name, OUT - subid-is in matched name */
X    u_char	*type;	    /* OUT - type of matched variable */
X    int		*len;	    /* OUT - length of matched variable */
X    u_short	*acl;	    /* OUT - access control list */
X    int		exact;	    /* IN - TRUE if exact match wanted */
X    int		*access_method; /* OUT - 1 if function, 0 if char * */
X{
X
X    register struct variable	*vp;
X
X    register int	x;
X    register u_char	*access;
X    int			result;
X
X    for(x = 0, vp = variables; x < sizeof(variables)/sizeof(struct variable); vp++, x++){
X	/*
X	 * compare should be expanded inline.
X	 */
X	result = compare(name, *namelen, vp->name, (int)vp->namelen);
X	if ((result < 0) || (exact && (result == 0))){
X	    access = (*(vp->findVar))(vp, name, namelen, exact, len, access_method);
X	    if (access != NULL)
X		break;
X	}
X    }
X    if (x == sizeof(variables)/sizeof(struct variable))
X	return NULL;
X
X    /* vp now points to the approprate struct */
X    *type = vp->type;
X    *acl = vp->acl;
X    return access;
X}
X
X
X
Xint
Xcompare(name1, len1, name2, len2)
X    register oid	    *name1, *name2;
X    register int	    len1, len2;
X{
X    register int    len;
X
X    /* len = minimum of len1 and len2 */
X    if (len1 < len2)
X	len = len1;
X    else
X	len = len2;
X    /* find first non-matching byte */
X    while(len-- > 0){
X	if (*name1 < *name2)
X	    return -1;
X	if (*name2++ < *name1++)
X	    return 1;
X    }
X    /* bytes match up to length of shorter string */
X    if (len1 < len2)
X	return -1;  /* name1 shorter, so it is "less" */
X    if (len2 < len1)
X	return 1;
X    return 0;	/* both strings are equal */
X}
X
X
Xu_char *
Xvar_system(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method;	/* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);	/* default length */
X    switch (vp->magic){
X	case VERSION_DESCR:
X	    *var_len = strlen(version_descr);
X	    return (u_char *)version_descr;
X	case VERSION_ID:
X	    *var_len = sizeof(version_id);
X	    return (u_char *)version_id;
X	case CFG_NNETS:
X	    return (u_char *)&cfg_nnets;
X	case UPTIME:
X	    return (u_char *)&uptime;
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_ifEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid			newname[MAX_NAME_LEN];
X    register int	interface;
X    register struct mib_ifEntry	*ifp;
X    extern struct conf	conf;
X    int			result;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* find "next" interface */
X    for(interface = 1; interface <= MAX_INTERFACES; interface++){
X	newname[10] = (oid)interface;
X	result = compare(name, *length, newname, (int)vp->namelen);
X	if ((exact && (result == 0)) || (!exact && (result < 0)))
X	    break;
X    }
X    if (interface > MAX_INTERFACES)
X	return NULL;
X    interface--; /* translate into internal index of interfaces */
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    ifp = &mib_ifEntry[interface];
X    switch (vp->magic){
X        case IFDESCR:
X	    *var_len = strlen(ifp->ifDescr);
X	    return (u_char *)ifp->ifDescr;
X	case IFPHYSADDRESS:
X	    *var_len = ifp->PhysAddrLen;
X	    if (interface == 0)
X	    	return (u_char *)ifie.if_haddr;
X	    else {
X		/*
X		 * As far as IP is concerned, the "physical" address includes the Appletalk
X		 * network address as well as node number.
X		 */
X		return_buf[0] = ((u_char *)&conf.atneta)[0];
X		return_buf[1] = ((u_char *)&conf.atneta)[1];
X		return_buf[2] = ifab.if_dnode;
X	    	return (u_char *)return_buf;
X	    }
X	case IFOUTQLEN:
X#ifdef notdef
X	    if (interface == 0)
X		long_return = sendq->pq_len;
X	    else
X		long_return = 0;	/* There is no appletalk transmit queue */
X#else
X	    long_return = 0;
X#endif
X	    return (u_char *)&long_return;
X	default:
X	    return (u_char *)(((char *)ifp) + vp->magic);
X    }
X}
X
X/* 
X * from arp.c:
X * There is no arp.h, so this must be recreated here.
X */
X#define	ARPHLNMAX	6	/* largest arp_hln value needed */
X#define	ARPPLN		4	/* length of protocol address (IP) */
Xstruct	arptab {
X	iaddr_t at_iaddr;		/* internet address */
X	u_char	at_haddr[ARPHLNMAX];	/* hardware address */
X	u_char	at_timer;		/* minutes since last reference */
X	u_char	at_flags;		/* flags */
X	struct	pbuf *at_hold;		/* last packet until resolved/timeout */
X};
X/* at_flags field values */
X#define	ATF_INUSE	1		/* entry in use */
X#define ATF_COM		2		/* completed entry (haddr valid) */
X
X#define	ARPTAB_BSIZ	5		/* bucket size */
X#define	ARPTAB_NB	11		/* number of buckets */
X#define	ARPTAB_SIZE	(ARPTAB_BSIZ * ARPTAB_NB)
X
X
Xu_char *
Xvar_atEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;	/* IN - pointer to variable entry that points here */
X    register oid	    *name;	/* IN/OUT - input name requested, output name found */
X    register int	    *length;	/* IN/OUT - length of input and output oid's */
X    int			    exact;	/* IN - TRUE if an exact match was requested. */
X    int			    *var_len;	/* OUT - length of variable or 0 if function returned. */
X    int			    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    /*
X     * object identifier is of form:
X     * 1.3.6.1.2.1.3.1.1.1.interface.1.A.B.C.D,  where A.B.C.D is IP address.
X     * Interface is at offset 10,
X     * IPADDR starts at offset 12.
X     */
X    oid			    lowest[16];
X    oid			    current[16];
X    register struct arptab  *arp;
X    struct arptab	    *lowarp = 0;
X    extern struct arptab    arptab[];
X    register struct ipdad   *ipdp;
X    struct ipdad	    *lowipdp = 0;
X    extern struct ipdad	    ipdad[];
X    long		    ipaddr;
X    int			    addrlen;
X    extern struct conf	    conf;
X    register u_char	    *cp;
X    register oid	    *op;
X    register int	    count;
X
X    /* fill in object part of name for current (less sizeof instance part) */
X    bcopy((char *)vp->name, (char *)current, (int)(vp->namelen - 6) * sizeof(oid));
X    for(arp = arptab; arp < arptab + ARPTAB_SIZE; arp++){
X	if (!(arp->at_flags & ATF_COM))	/* if this entry isn't valid */
X	    continue;
X	/* create new object id */
X	current[10] = 1;	/* ifIndex == 1 (ethernet) */
X	current[11] = 1;
X	cp = (u_char *)&(arp->at_iaddr);
X	op = current + 12;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	if (exact){
X	    if (compare(current, 16, name, *length) == 0){
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowarp = arp;
X		break;	/* no need to search further */
X	    }
X	} else {
X	    if ((compare(current, 16, name, *length) > 0) && (!lowarp || (compare(current, 16, lowest, 16) < 0))){
X		/*
X		 * if new one is greater than input and closer to input than
X		 * previous lowest, save this one as the "next" one.
X		 */
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowarp = arp;
X	    }
X	}
X    }
X    ipaddr = conf.ipaddr + conf.ipstatic + 1;
X    for(ipdp = ipdad; ipdp < ipdad + NIPDAD; ipdp++, ipaddr++){
X	if (ipdp->timer == 0)	/* if this entry is unused, continue */
X	    continue;
X	/* create new object id */
X	current[10] = 2;	/* ifIndex == 2 (appletalk) */
X	current[11] = 1;
X	cp = (u_char *)&ipaddr;
X	op = current + 12;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	if (exact){
X	    if (compare(current, 16, name, *length) == 0){
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowipdp = ipdp;
X		lowarp = 0;
X		break;	/* no need to search further */
X	    }
X	} else {
X	    if ((compare(current, 16, name, *length) > 0) && ((!lowarp && !lowipdp) || (compare(current, 16, lowest, 16) < 0))){
X		/*
X		 * if new one is greater than input and closer to input than
X		 * previous lowest, save this one as the "next" one.
X		 */
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowipdp = ipdp;
X		/* ipdad entry is lower, so invalidate arp entry */
X		lowarp = 0;
X	    }
X	}
X    }
X    if (lowarp != 0){	/* arp entry was lowest */
X	addrlen = 6;
X	bcopy((char *)lowarp->at_haddr, (char *)return_buf, 6);
X    } else if (lowipdp != 0) {
X	addrlen = 3;
X	/*
X	 * As far as IP is concerned, the "physical" address includes the Appletalk
X	 * network address as well as node number.
X	 */
X	return_buf[0] = ((u_char *)&lowipdp->net)[0];
X	return_buf[1] = ((u_char *)&lowipdp->net)[1];
X	return_buf[2] = lowipdp->node;
X    } else
X	return NULL;	/* no match */
X    bcopy((char *)lowest, (char *)name, 16 * sizeof(oid));
X    *length = 16;
X    *access_method = 0;
X    switch(vp->magic){
X	case ATIFINDEX:
X	    *var_len = sizeof long_return;
X	    long_return = lowest[10];
X	    return (u_char *)&long_return;
X	case ATPHYSADDRESS:
X	    *var_len = addrlen;
X	    return (u_char *)return_buf;
X	case ATNETADDRESS:
X	    *var_len = sizeof long_return;
X	    cp = (u_char *)&long_return;
X	    op = lowest + 12;
X	    for(count = 4; count > 0; count--)
X		*cp++ = *op++;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X   }
X   return NULL;
X}
X
Xu_char *
Xvar_ip(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X    return ((u_char *)&mib_ip) + vp->magic;
X}
X
Xu_char *
Xvar_ipRouteEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid    	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output strings */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid			    newname[MAX_NAME_LEN];
X    register int	    entry;
X    register struct mib_ipRouteEntry	*routep;
X    int			    result;
X    register int	    count;
X    register u_char	    *cp;
X    register oid	    *op;
X    extern struct conf	    conf;
X
X    /* set up a routing table to search. All other values are set at startup. */
X    routep = mib_ipRouteEntry;
X    routep[ROUTE_DEFAULT].ipRouteDest = 0;
X    routep[ROUTE_DEFAULT].ipRouteNextHop = conf.iproutedef;
X    routep[ROUTE_LOCAL].ipRouteDest = ipnetpart(conf.ipaddr);
X    routep[ROUTE_LOCAL].ipRouteNextHop = conf.ipaddr;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* find "next" route */
X    for(entry = 0; entry < ROUTE_ENTRIES; entry++){
X	cp = (u_char *)&routep->ipRouteDest;
X	op = newname + 10;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	result = compare(name, *length, newname, (int)vp->namelen);
X	if ((exact && (result == 0)) || (!exact && (result < 0)))
X	    break;
X	routep++;
X    }
X    if (entry >= ROUTE_ENTRIES)
X	return NULL;
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    routep = &mib_ipRouteEntry[entry];
X    switch (vp->magic){
X	case IPROUTENEXTHOP:
X	    if (entry == ROUTE_DEFAULT)
X		return (u_char *)&conf.iproutedef;
X	    else
X		return (u_char *)&conf.ipaddr;
X	default:
X	    return (u_char *)(((u_char *)routep) + vp->magic);
X    }
X}
X
Xu_char *
Xvar_ipAddrEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid		    newname[14];
X    int		    result;
X    extern struct conf	conf;
X    register int    count;
X    register u_char *cp;
X    register oid    *op;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* now find "next" ipaddr */
X    /*
X     * foreach ipaddress entry, cobble up newname with its IP address,
X     * by copying the ipaddress into the 10 - 13't subid's
X     * then compare with name.  If greater than name and less than lowest,
X     * save as new lowest.
X     * Having said all that, I'm now going to cheat because I only have one
X     * IP address (on both interfaces).
X     */
X    cp = (u_char *)&conf.ipaddr;
X    op = newname + 10;
X    for(count = sizeof(conf.ipaddr); count > 0; count--)
X	*op++ = *cp++;
X    result = compare(name, *length, newname, (int)vp->namelen);
X    if ((exact && (result != 0)) || (!exact && (result >= 0)))
X	return NULL;	/* no match */
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    switch (vp->magic){
X    	case IPADADDR:
X	    return (u_char *)&conf.ipaddr;
X        case IPADIFINDEX:
X	    /*
X	     * Always return ethernet interface. SNMP
X	     * has no access method to access instances
X	     * on different interfaces with same IP address.
X	     */
X	    long_return = 1;
X	    return (u_char *)&long_return;
X	case IPADNETMASK:
X	    long_return = (IN_CLASSA(conf.ipaddr) ? IN_CLASSA_NET :
X			(IN_CLASSB(conf.ipaddr) ? IN_CLASSB_NET : IN_CLASSC_NET));
X	    return (u_char *)&long_return;
X	case IPADBCASTADDR:
X	    long_return = conf.ipbroad & 1;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_icmp(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long); /* all following variables are sizeof long */
X    switch (vp->magic){
X	case ICMPINMSGS:
X	    return (u_char *)&mib_icmpInMsgs;
X	case ICMPINERRORS:
X	    return (u_char *)&mib_icmpInErrors;
X	case ICMPINDESTUNREACHS:
X	    return (u_char *)&mib_icmpInCount[3];
X	case ICMPINTIMEEXCDS:
X	    return (u_char *)&mib_icmpInCount[11];
X	case ICMPINPARMPROBS:
X	    return (u_char *)&mib_icmpInCount[12];
X	case ICMPINSRCQUENCHS:
X	    return (u_char *)&mib_icmpInCount[4];
X	case ICMPINREDIRECTS:
X	    return (u_char *)&mib_icmpInCount[5];
X	case ICMPINECHOS:
X	    return (u_char *)&mib_icmpInCount[8];
X	case ICMPINECHOREPS:
X	    return (u_char *)&mib_icmpInCount[0];
X	case ICMPINTIMESTAMPS:
X	    return (u_char *)&mib_icmpInCount[13];
X	case ICMPINTIMESTAMPREPS:
X	    return (u_char *)&mib_icmpInCount[14];
X	case ICMPINADDRMASKS:
X	    return (u_char *)&mib_icmpInCount[17];
X	case ICMPINADDRMASKREPS:
X	    return (u_char *)&mib_icmpInCount[18];
X	case ICMPOUTMSGS:
X	    return (u_char *)&mib_icmpOutMsgs;
X	case ICMPOUTERRORS:
X	    return (u_char *)&mib_icmpOutErrors;
X	case ICMPOUTDESTUNREACHS:
X	    return (u_char *)&mib_icmpOutCount[3];
X	case ICMPOUTTIMEEXCDS:
X	    return (u_char *)&mib_icmpOutCount[11];
X	case ICMPOUTPARMPROBS:
X	    return (u_char *)&mib_icmpOutCount[12];
X	case ICMPOUTSRCQUENCHS:
X	    return (u_char *)&mib_icmpOutCount[4];
X	case ICMPOUTREDIRECTS:
X	    return (u_char *)&mib_icmpOutCount[5];
X	case ICMPOUTECHOS:
X	    return (u_char *)&mib_icmpOutCount[8];
X	case ICMPOUTECHOREPS:
X	    return (u_char *)&mib_icmpOutCount[0];
X	case ICMPOUTTIMESTAMPS:
X	    return (u_char *)&mib_icmpOutCount[13];
X	case ICMPOUTTIMESTAMPREPS:
X	    return (u_char *)&mib_icmpOutCount[14];
X	case ICMPOUTADDRMASKS:
X	    return (u_char *)&mib_icmpOutCount[17];
X	case ICMPOUTADDRMASKREPS:
X	    return (u_char *)&mib_icmpOutCount[18];
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_udp(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X    return ((u_char *)&mib_udp) + vp->magic;
X}
END_OF_FILE
  if test 33903 -ne `wc -c <'netramet/src/snmplib/~snmp_vars.c.kip'`; then
    echo shar: \"'netramet/src/snmplib/~snmp_vars.c.kip'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/snmplib/~snmp_vars.c.kip'
fi
echo shar: End of archive 18 \(of 25\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
