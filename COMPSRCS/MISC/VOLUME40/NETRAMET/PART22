Newsgroups: comp.sources.misc
From: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Subject: v40i110:  netramet - Network Traffic Accounting Meter, Part22/25
Message-ID: <1993Nov9.020716.19136@sparky.sterling.com>
X-Md4-Signature: ad7fc0ab101f7ae1a36e3b8fbffa1700
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 9 Nov 1993 02:07:16 GMT
Approved: kent@sparky.sterling.com

Submitted-by: nevil@ccu1.aukuni.ac.nz (J Nevil Brownlee)
Posting-number: Volume 40, Issue 110
Archive-name: netramet/part22
Environment: INET, UNIX, DOS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  netramet/doc/NeTraMet/copyright.notice
#   netramet/doc/snmp/snmp_api.3 netramet/examples/rules.UofA
#   netramet/mib/mib.UofA.txt netramet/src/apps/snmp_var_route.c
#   netramet/src/meter/include/met_vars.h
#   netramet/src/snmplib/include/snmpapi.h
#   netramet/src/snmplib/include/snmpvars.h
# Wrapped by kent@sparky on Tue Nov  2 18:17:13 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 22 (of 25)."'
if test -f 'netramet/doc/NeTraMet/copyright.notice' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/doc/NeTraMet/copyright.notice'\"
else
  echo shar: Extracting \"'netramet/doc/NeTraMet/copyright.notice'\" \(8103 characters\)
  sed "s/^X//" >'netramet/doc/NeTraMet/copyright.notice' <<'END_OF_FILE'
XNeTraMet is free software, distributed under the terms of
Xthe GNU Emacs general public license.  A copy of this is attached; for
X'GNU Emacs' read 'NeTraMet,' for 'Richard M. Stallman' read 'Nevil
XBrownlee,' and for 'Free Software Foundation, Inc.' read 'The
XUniversity of Auckland.'
X
X--------------------------------------------------------------------------
X
X		 GNU EMACS GENERAL PUBLIC LICENSE
X		    (Clarified 11 Feb 1988)
X
X Copyright (C) 1985, 1987, 1988 Richard M. Stallman
X Everyone is permitted to copy and distribute verbatim copies
X of this license, but changing it is not allowed.  You can also
X use this wording to make the terms for other programs.
X
X  The license agreements of most software companies keep you at the
Xmercy of those companies.  By contrast, our general public license is
Xintended to give everyone the right to share GNU Emacs.  To make
Xsure that you get the rights we want you to have, we need to make
Xrestrictions that forbid anyone to deny you these rights or to ask you
Xto surrender the rights.  Hence this license agreement.
X
X  Specifically, we want to make sure that you have the right to give
Xaway copies of Emacs, that you receive source code or else can get it
Xif you want it, that you can change Emacs or use pieces of it in new
Xfree programs, and that you know you can do these things.
X
X  To make sure that everyone has such rights, we have to forbid you to
Xdeprive anyone else of these rights.  For example, if you distribute
Xcopies of Emacs, you must give the recipients all the rights that you
Xhave.  You must make sure that they, too, receive or can get the
Xsource code.  And you must tell them their rights.
X
X  Also, for our own protection, we must make certain that everyone
Xfinds out that there is no warranty for GNU Emacs.  If Emacs is
Xmodified by someone else and passed on, we want its recipients to know
Xthat what they have is not what we distributed, so that any problems
Xintroduced by others will not reflect on our reputation.
X
X  Therefore we (Richard Stallman and the Free Software Fundation,
XInc.) make the following terms which say what you must do to be
Xallowed to distribute or change GNU Emacs.
X
X			COPYING POLICIES
X
X  1. You may copy and distribute verbatim copies of GNU Emacs source code
Xas you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy a valid copyright notice "Copyright
X(C) 1988 Free Software Foundation, Inc." (or with whatever year is
Xappropriate); keep intact the notices on all files that refer to this
XLicense Agreement and to the absence of any warranty; and give any
Xother recipients of the GNU Emacs program a copy of this License
XAgreement along with the program.  You may charge a distribution fee
Xfor the physical act of transferring a copy.
X
X  2. You may modify your copy or copies of GNU Emacs source code or
Xany portion of it, and copy and distribute such modifications under
Xthe terms of Paragraph 1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating
X    that you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish,
X    that in whole or in part contains or is a derivative of GNU Emacs
X    or any part thereof, to be licensed at no charge to all third
X    parties on terms identical to those contained in this License
X    Agreement (except that you may choose to grant more extensive
X    warranty protection to some or all third parties, at your option).
X
X    c) if the modified program serves as a text editor, cause it when
X    started running in the simplest and usual way, to print an
X    announcement including a valid copyright notice "Copyright (C)
X    1988 Free Software Foundation, Inc." (or with the year that is
X    appropriate), saying that there is no warranty (or else, saying
X    that you provide a warranty) and that users may redistribute the
X    program under these conditions, and telling the user how to view a
X    copy of this License Agreement.
X
X    d) You may charge a distribution fee for the physical act of
X    transferring a copy, and you may at your option offer warranty
X    protection in exchange for a fee.
X
XMere aggregation of another unrelated program with this program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other program under the scope of these terms.
X
X  3. You may copy and distribute GNU Emacs (or a portion or derivative of it,
Xunder Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal
X    shipping charge) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XFor an executable file, complete source code means all the source code for
Xall modules it contains; but, as a special exception, it need not include
Xsource code for modules which are standard libraries that accompany the
Xoperating system on which the executable file runs.
X
X  4. You may not copy, sublicense, distribute or transfer GNU Emacs
Xexcept as expressly provided under this License Agreement.  Any attempt
Xotherwise to copy, sublicense, distribute or transfer GNU Emacs is void and
Xyour rights to use GNU Emacs under this License agreement shall be
Xautomatically terminated.  However, parties who have received computer
Xsoftware programs from you with this License Agreement will not have
Xtheir licenses terminated so long as such parties remain in full compliance.
X
X  5. If you wish to incorporate parts of GNU Emacs into other free programs
Xwhose distribution conditions are different, write to the Free Software
XFoundation.  We have not yet worked out a simple rule that can be stated
Xhere, but we will often permit this.  We will be guided by the two goals of
Xpreserving the free status of all derivatives of our free software and of
Xpromoting the sharing and reuse of software.
X
XYour comments and suggestions about our licensing policies and our
Xsoftware are welcome!  Please contact the Free Software Foundation, Inc.,
X675 Mass Ave, Cambridge, MA 02139, or call (617) 876-3296.
X
X			   NO WARRANTY
X
X  BECAUSE GNU EMACS IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY
XNO WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT
XWHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,
XRICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE GNU EMACS "AS IS"
XWITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
XBUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
XFITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY
XAND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE GNU EMACS
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
XSERVICING, REPAIR OR CORRECTION.
X
X IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL FREE SOFTWARE
XFOUNDATION, INC., RICHARD M. STALLMAN, AND/OR ANY OTHER PARTY WHO MAY
XMODIFY AND REDISTRIBUTE GNU EMACS AS PERMITTED ABOVE, BE LIABLE TO YOU
XFOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER
XSPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
XINABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
XBEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A
XFAILURE OF THE PROGRAM TO OPERATE WITH PROGRAMS NOT DISTRIBUTED BY
XFREE SOFTWARE FOUNDATION, INC.) THE PROGRAM, EVEN IF YOU HAVE BEEN
XADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR ANY CLAIM BY ANY
XOTHER PARTY.
X
END_OF_FILE
  if test 8103 -ne `wc -c <'netramet/doc/NeTraMet/copyright.notice'`; then
    echo shar: \"'netramet/doc/NeTraMet/copyright.notice'\" unpacked with wrong size!
  fi
  # end of 'netramet/doc/NeTraMet/copyright.notice'
fi
if test -f 'netramet/doc/snmp/snmp_api.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/doc/snmp/snmp_api.3'\"
else
  echo shar: Extracting \"'netramet/doc/snmp/snmp_api.3'\" \(8220 characters\)
  sed "s/^X//" >'netramet/doc/snmp/snmp_api.3' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMP_API 3 "Sept 17, 1989"
X.UC 5
X.SH NAME
Xsnmp_open, snmp_close, snmp_send, snmp_read, snmp_free_pdu, snmp_select_info, snmp_timeout \- send and receive SNMP messages
X.SH SYNOPSIS
X.B "#include <sys/types>
X.br
X.B "#include <netinet/in.h>
X.br
X.B "#include <sys/time.h>
X.br
X.B #include """snmp.h""
X.br
X.B #include """snmp_impl.h""
X.br
X.B #include """asn1.h""
X.br
X.B #include """snmp_api.c""
X.PP
X.B "extern int snmp_errno;
X.PP
X.B "struct snmp_session *snmp_open(session)
X.br
X.B "struct snmp_session *session;
X.PP
X.B "int snmp_close(session)
X.br
X.B "struct snmp_session *session;
X.PP
X.B "int snmp_send(session, pdu)
X.br
X.B "struct snmp_session *session;
X.br
X.B "struct snmp_pdu *pdu;
X.PP
X.B "void snmp_read(fdset)
X.br
X.B "fd_set *fdset;
X.PP
X.B "int snmp_select_info(numfds, fdset, timeout, block)
X.br
X.B "int *numfds;
X.br
X.B "fd_set *fdset;
X.br
X.B "struct timeval *timeout;
X.br
X.B "int *block;
X.PP
X.B "void snmp_timeout()
X.PP
X.B "void snmp_free_pdu(pdu)
X.br
X.B "struct snmp_pdu *pdu;
X.PP
X.SH DESCRIPTION
X.I Snmp_open, snmp_close,
Xand
X.I snmp_send
Xeach take as input a pointer to an object with the
Xfollowing structure.  In addition,
X.I snmp_open
Xalso returns a pointer to an object with this structure.
XThis structure contains information for a set of transactions that
Xwill share similar transport characteristics.
X.RS
X.PP
X.nf
Xtypedef struct sockaddr_in  ipaddr;
X
Xstruct snmp_session {
X    u_char  *community;	/* community for outgoing requests. */
X    int	    community_len;  /* Length of community name. */
X    int	    retries;	/* Number of retries before timeout. */
X    long    timeout;    /* Number of uS until first timeout, then exponential backoff */
X    char    *peername;	/* Domain name or dotted IP address of default peer */
X    u_short remote_port;/* UDP port number of peer. */
X    u_short local_port; /* My UDP port number, 0 for default, picked randomly */
X
X    /* Authentication function or NULL if null authentication is used */
X    u_char  *(*authenticator)();
X
X    int	    (*callback)();  /* Function to interpret incoming data */
X
X    /* Pointer to data that the callback function may consider important */
X    void    *callback_magic;
X};
X
X/*
X * Set fields in session and pdu to the following to get a default or unconfigured value.
X */
X#define SNMP_DEFAULT_COMMUNITY_LEN  0/* for default community name */
X#define SNMP_DEFAULT_RETRIES	    -1
X#define SNMP_DEFAULT_TIMEOUT	    -1
X#define SNMP_DEFAULT_REMPORT	    0
X#define SNMP_DEFAULT_REQID	    0
X#define SNMP_DEFAULT_ERRSTAT	    -1
X#define SNMP_DEFAULT_ERRINDEX	    -1
X#define SNMP_DEFAULT_ADDRESS	    0
X#define SNMP_DEFAULT_PEERNAME	    NULL
X#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
X#define SNMP_DEFAULT_TIME	    0
X
X/*
X * This routine must be supplied by the application:
X *
X * u_char *authenticator(pdu, length, community, community_len)
X * u_char *pdu;		The rest of the PDU to be authenticated
X * int *length;		The length of the PDU (updated by the authenticator)
X * u_char *community;	The community name to authenticate under.
X * int	community_len	The length of the community name.
X *
X * Returns the authenticated pdu, or NULL if authentication failed.
X * If null authentication is used, the authenticator in snmp_session can be
X * set to NULL(0).
X */
X
X/*
X * This routine must be supplied by the application:
X *
X * int callback(operation, session, reqid, pdu, magic)
X * int operation;
X * struct snmp_session *session;    The session authenticated under.
X * int reqid;			    The request id of this pdu (0 for TRAP)
X * struct snmp_pdu *pdu;	    The pdu information.
X * void *magic			    A link to the data for this routine.
X *
X * Returns 1 if request was successful, 0 if it should be kept pending.
X * Any data in the pdu must be copied because it will be freed elsewhere.
X * Operations are defined below:
X */
X#define RECEIVED_MESSAGE   1
X#define TIMED_OUT	   2
X.ft R
X.ad
X.fi
X.RE
X.PP
X.I Snmp_send
Xand
X.I snmp_free_pdu
Xeach take as input a pointer to an object with the
Xfollowing structure.
XThis structure contains information that describes a transaction
Xthat will be performed over an open session.
X.RS
X.PP
X.nf
Xstruct snmp_pdu {
X    ipaddr  address;	/* Address of peer */
X
X    int	    command;	/* Type of this PDU */
X
X    u_long  reqid;	/* Request id */
X    u_long  errstat;	/* Error status */
X    u_long  errindex;	/* Error index */
X
X    /* Trap information */
X    oid	    *enterprise;/* System OID */
X    int	    enterprise_length;
X    ipaddr  agent_addr;	/* address of object generating trap */
X    int	    trap_type;	/* trap type */
X    int	    specific_type;  /* specific type */
X    u_long  time;	/* Uptime */
X
X    struct variable_list *variables;
X};
X
X
Xstruct variable_list {
X    struct variable_list *next_variable;    /* NULL for last variable */
X    oid	    *name;  /* Object identifier of variable */
X    int	    name_length;    /* number of subid's in name */
X    u_char  type;   /* ASN type of variable */
X    union { /* value of variable */
X	long	*integer;
X	u_char	*string;
X	oid	*objid;
X    } val;
X    int	    val_len;
X};
X.ft R
X.ad
X.fi
X.RE
X.PP
X.I Snmp_read, snmp_select_info,
Xand
X.I snmp_timeout
Xprovide an interface for the use of the
X.IR select (2)
Xsystem call so that SNMP transactions can occur asynchronously.
X.PP
X.I Snmp_select_info
Xis given the information that would have been passed to
X.I select
Xin the absence of SNMP.  For example, this might include window update information.
XThis information is modified so that SNMP will get the service it requires from the
Xcall to
X.I select.
XIn this case,
X.I numfds, fdset,
Xand
X.I timeout
Xcorrespond to the
X.I nfds, readfds,
Xand
X.I timeout
Xarguments to
X.I select,
Xrespectively.  The only exception is that timeout must always point to an allocated (but perhaps uninitialized)
X.I struct timeval.
XIf
X.I timeout
Xwould have been passed as NULL,
X.I block
Xis set to true, and
X.I timeout
Xis treated as undefined.  This same rule applies upon return from
X.I snmp_select_info.
X.PP
XAfter calling
X.I snmp_select_info, select
Xis called with the returned data.  When select returns,
X.I snmp_read
Xis called with the
X.I fd_set
Xreturned from
X.I select.
XThis will read all SNMP sockets with input.
XIf
X.I select
Xtimes out,
X.I snmp_timeout
Xshould be called to see if the timeout was intended for SNMP.
X.SH DIAGNOSTICS
X.PP
XError return status from 
X.I snmp_open
Xis indicated by return of a null pointer.
XError return status from 
X.I snmp_close
Xand
X.I snmp_send
Xis indicated by return of 0.  A successful status will return a 1.
XThe external integer
X.IR snmp_errno
Xmay then be checked to see what type of error has occurred
X.PP
X.IR snmp_errno
Xcan have the following values:
X.RS
X.IP SNMPERR_GENERR \w'SNMPERR_BAD_LOCPORT'u+2n
XA generic error occurred.
X.IP SNMPERR_BAD_LOCPORT \w'SNMPERR_BAD_LOCPORT'u+2n
XThe local port was bad because it had already been
Xallocated or permission was denied.
X.IP SNMPERR_BAD_ADDRESS \w'SNMPERR_BAD_LOCPORT'u+2n
XThe host name or address given was not useable.
X.IP SNMPERR_BAD_SESSION \w'SNMPERR_BAD_SESSION'u+2n
XThe specified session was not open.
X.RE
X.SH "SEE ALSO"
Xselect(2), snmp_api.h
END_OF_FILE
  if test 8220 -ne `wc -c <'netramet/doc/snmp/snmp_api.3'`; then
    echo shar: \"'netramet/doc/snmp/snmp_api.3'\" unpacked with wrong size!
  fi
  # end of 'netramet/doc/snmp/snmp_api.3'
fi
if test -f 'netramet/examples/rules.UofA' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/examples/rules.UofA'\"
else
  echo shar: Extracting \"'netramet/examples/rules.UofA'\" \(6310 characters\)
  sed "s/^X//" >'netramet/examples/rules.UofA' <<'END_OF_FILE'
X#  1440, Fri 1 Oct 93
X#
X#  Rule specification file to tally traffic for Auckland, using
X#     three groups of sites: UA, Local, NZ
X#
X#  Nevil Brownlee,  Computer Centre,  University of Auckland
X#
XSET 8  # Rule + action set number
X#
XRULES
X#
XSourcePeerType & 255 = IP :   Pushto,  7;  #   1
XNull & 0 = 0 :               Succeed,  0;  #   2  Ignore
X#
XNull & 0 = 0 :               Succeed,  0;  #   3  Ignore
XNull & 0 = 0 :               Succeed,  0;  #   4  Ignore
XNull & 0 = 0 :               Succeed,  0;  #   5  Ignore
XNull & 0 = 0 :               Succeed,  0;  #   6  Ignore
X#
XSourcePeerAddress & 255.255.0.0 = 130.216.0.0 :  Pushto, 33  #   7  UA
X#
XSourcePeerAddress & 255.255.255.0 = 192.156.165.0 :  Pushto, 31  #  8 decus
XSourcePeerAddress & 255.255.255.0 = 192.251.230.0 :  Pushto, 31  #  9 clearfield
XSourcePeerAddress & 255.255.255.0 = 202.12.104.0 :  Pushto, 31  # 10 dse
XSourcePeerAddress & 255.255.255.0 = 202.12.105.0 :  Pushto, 31  # 11 f&p
XSourcePeerAddress & 255.255.255.0 = 202.14.100.0 :  Pushto, 31  # 12 status
XSourcePeerAddress & 255.255.255.0 = 202.14.102.0 :  Pushto, 31  # 13 kcbbs
XSourcePeerAddress & 255.255.255.0 = 202.14.216.0 :  Pushto, 31  # 14 manakau
XSourcePeerAddress & 255.255.255.0 = 202.14.217.0 :  Pushto, 31  # 15 maleficarun
XSourcePeerAddress & 255.255.255.0 = 202.14.252.0 :  Pushto, 31  # 16 cray 1
XSourcePeerAddress & 255.255.255.0 = 202.14.253.0 :  Pushto, 31  # 17 cray 2
XSourcePeerAddress & 255.255.255.0 = 202.14.254.0 :  Pushto, 31  # 18 cray 3
X#
XSourcePeerAddress & 255.255.0.0 = 156.62.0.0 :  Pushto, 31  #  19 ati
X#
X# Source isn't UA or local
X#
XNull & 0 = 0 :                  Fail,  0;  #  20  Try match again
X#
XNull & 0 = 0 :               Succeed,  0;  #  21
XNull & 0 = 0 :               Succeed,  0;  #  22
XNull & 0 = 0 :               Succeed,  0;  #  23
XNull & 0 = 0 :               Succeed,  0;  #  24
XNull & 0 = 0 :               Succeed,  0;  #  25
XNull & 0 = 0 :               Succeed,  0;  #  26
XNull & 0 = 0 :               Succeed,  0;  #  27
XNull & 0 = 0 :               Succeed,  0;  #  28
XNull & 0 = 0 :               Succeed,  0;  #  29
XNull & 0 = 0 :               Succeed,  0;  #  30
X#
X# Source is local
X#
XDestPeerAddress & 255.255.0.0 = 130.216.0.0 :  Fail,  0;  #  31  Retry match
XNull & 0 = 0 :                 Pushto,  34;  #  32  Tally packet
X#
X# Source is UA
X#
XDestPeerAddress & 255.255.0.0 = 130.216.0.0 :  Count, 0;  #  33  UA-UA
X#
X# Direction determined; tally the packet
X#
XDestPeerAddress & 140.200.0.0 = 255.255.0.0 : Pushto, 48;  #  34  Tuia: tally C
X#
XDestPeerAddress & 192.0.0.0 = 192.0.0.0 :   Pushto, 49;  #  35  Tally C
XDestPeerAddress & 192.0.0.0 = 128.0.0.0 :   Pushto, 43;  #  36  Tally B
X#
XSourceDetailType & 255 = icmp :            Tally,   4;  #  37  Tally A
XSourceDetailAddress & 255.255 = domain :   Tally,   7;  #  38
XDestDetailAddress & 255.255 = domain :     Tally,   7;  #  39
XDestDetailAddress & 255.255 = ftpdata :    Tally,  10;  #  40
XSourceDetailAddress & 255.255 = ftpdata :  Tally,  13;  #  41
XNull & 0 = 0 :                             Tally,   1;  #  42
X#
XSourceDetailType & 255 = icmp :            Tally,   5;  #  43  Tally B
XSourceDetailAddress & 255.255 = domain :   Tally,   8;  #  44
XDestDetailAddress & 255.255 = domain :     Tally,   8;  #  45
XDestDetailAddress & 255.255 = ftpdata :    Tally,  11;  #  46
XSourceDetailAddress & 255.255 = ftpdata :  Tally,  14;  #  47
XNull & 0 = 0 :                             Tally,   2;  #  48
X#
XSourceDetailType & 255 = icmp :            Tally,   6;  #  49 Tally C
XSourceDetailAddress & 255.255 = domain :   Tally,   9;  #  50
XDestDetailAddress & 255.255 = domain :     Tally,   9;  #  51
XDestDetailAddress & 255.255 = ftpdata :    Tally,  12;  #  52
XSourceDetailAddress & 255.255 = ftpdata :  Tally,  15;  #  53
XNull & 0 = 0 :                             Tally,   3;  #  54
X#
XACTIONS
X#
XSourcePeerMask=255.255.255.0, DestPeerMask=255.0.0.0,  #  1 Tally ports A
X   SourceDetailTypeMask=255, 
X   SourceDetailMask=255.255, DestDetailMask=255.255;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.0.0,  #  2 Tally ports B
X   SourceDetailTypeMask=255, 
X   SourceDetailMask=255.255, DestDetailMask=255.255;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.255.0,  #  3 Tally ports C
X   SourceDetailTypeMask=255, 
X   SourceDetailMask=255.255, DestDetailMask=255.255;
X#
XSourcePeerMask=255.255.255.0, DestPeerMask=255.0.0.0,  #  4 Tally icmp A
X   SourceDetailType=icmp, DestDetailType=icmp;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.0.0,  #  5 Tally icmp B
X   SourceDetailType=icmp, DestDetailType=icmp;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.255.0,  #  6 Tally icmp C
X   SourceDetailType=icmp, DestDetailType=icmp;
X#
XSourcePeerMask=255.255.255.0, DestPeerMask=255.0.0.0,  #  7 Tally domain A
X   SourceDetailTypeMask=255, 
X   SourceDetailAddress=domain, DestDetailAddress=domain;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.0.0,  #  8 Tally domain B
X   SourceDetailTypeMask=255, 
X   SourceDetailAddress=domain, DestDetailAddress=domain;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.255.0,  #  9 Tally domain C
X   SourceDetailTypeMask=255, 
X   SourceDetailAddress=domain, DestDetailAddress=domain;
X#
XSourcePeerMask=255.255.255.0, DestPeerMask=255.0.0.0,  # 10 Tally ftp in A
X   SourceDetailTypeMask=255, DestDetailAddress=ftpdata;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.0.0,  # 11 Tally ftp in B
X   SourceDetailTypeMask=255, DestDetailAddress=ftpdata;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.255.0,  # 12 Tally ftp in C
X   SourceDetailTypeMask=255, DestDetailAddress=ftpdata;
X#
XSourcePeerMask=255.255.255.0, DestPeerMask=255.0.0.0,  # 13 Tally ftp out A
X   SourceDetailTypeMask=255, SourceDetailAddress=ftpdata;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.0.0,  # 14 Tally ftp out B
X   SourceDetailTypeMask=255, SourceDetailAddress=ftpdata;
XSourcePeerMask=255.255.255.0, DestPeerMask=255.255.255.0,  # 15 Tally ftp out C
X   SourceDetailTypeMask=255, SourceDetailAddress=ftpdata;
X#
XFORMAT FlowRuleSet FlowIndex FirstTime "  "
X#  SourceAdjacentAddress DestAdjacentAddress "  "
X#  SourcePeerType 
X   SourcePeerAddress DestPeerAddress "  "
X   SourceDetailType SourceDetailAddress DestDetailAddress "  "
X   ToPDUs FromPDUs "  " ToOctets FromOctets;
X#
XSTATISTICS  #  Collect meter statistics
X#
X# end of file
END_OF_FILE
  if test 6310 -ne `wc -c <'netramet/examples/rules.UofA'`; then
    echo shar: \"'netramet/examples/rules.UofA'\" unpacked with wrong size!
  fi
  # end of 'netramet/examples/rules.UofA'
fi
if test -f 'netramet/mib/mib.UofA.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/mib/mib.UofA.txt'\"
else
  echo shar: Extracting \"'netramet/mib/mib.UofA.txt'\" \(3743 characters\)
  sed "s/^X//" >'netramet/mib/mib.UofA.txt' <<'END_OF_FILE'
X   -- Auckland University Monitor MIB
X   -- Nevil Brownlee, 5 Oct 93
X
X   UofAuckland OBJECT IDENTIFIER ::= { enterprises 411 }
X
X   MeterStats OBJECT IDENTIFIER ::= { UofAuckland 1 }
X
X   msStatsReset OBJECT-TYPE	-- Write to zero statistics counters
X      SYNTAX  INTEGER
X      ACCESS  read-write
X      STATUS  mandatory
X      ::= { MeterStats 1 }
X
X   msStatsTime OBJECT-TYPE	-- Seconds since stats counters were zeroed
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 2 }
X
X   msNbrPackets OBJECT-TYPE	-- Nbr of packets this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 3 }
X
X   msTotalPacketBacklog OBJECT-TYPE  -- Sum of pkt backlogs this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 4 }
X
X   msMaxPacketRate OBJECT-TYPE	-- Max packet rate this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 5 }
X
X   msMaxPacketBacklog OBJECT-TYPE  -- Max packet backlog this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 6 }
X
X   msNbrFlows OBJECT-TYPE		-- Nbr of flows currently in use
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 7 }
X
X   msFlowsRecovered OBJECT-TYPE	-- Flows recovered during this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 8 }
X
X   msRuleMatches OBJECT-TYPE	-- Rules matched during this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 9 }
X
X   msHashSearches OBJECT-TYPE	-- Tally hash searches this stats interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 10 }
X
X   msHashCompares OBJECT-TYPE	-- Compares for tally searches this interval
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 11 }
X
X   msTotalHashSize OBJECT-TYPE	-- Current sum of tally hash table sizes
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 12 }
X
X   msNbrHashEntries OBJECT-TYPE	-- Nbr of in-use slots in tally hash tables
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 13 }
X
X   msGarbageCollectInterval OBJECT-TYPE  -- Seconds between G.C. invocations
X      SYNTAX  INTEGER
X      ACCESS  read-write
X      STATUS  mandatory
X      ::= { MeterStats 14 }
X
X   msMaxFlows OBJECT-TYPE  -- Max nbr of flows in meter's flows table
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 15 }
X
X   msAvIdlePer1000 OBJECT-TYPE  -- Average idle processor % * 10
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 16 }
X
X   msMinIdlePer1000 OBJECT-TYPE  -- Minimum idels processor % * 10
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { MeterStats 17 }
X
X
X   pcSystem OBJECT IDENTIFIER ::= { UofAuckland 2 }
X
X   pcNearMem OBJECT-TYPE
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { pcSystem 1 }
X
X   pcFarMem OBJECT-TYPE
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { pcSystem 2 }
X
X   pcBadPackets OBJECT-TYPE
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { pcSystem 3 }
X
X   pcNoBufPackets OBJECT-TYPE
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { pcSystem 4 }
X
X   pcLostPackets OBJECT-TYPE
X      SYNTAX  INTEGER
X      ACCESS  read-only
X      STATUS  mandatory
X      ::= { pcSystem 5 }
END_OF_FILE
  if test 3743 -ne `wc -c <'netramet/mib/mib.UofA.txt'`; then
    echo shar: \"'netramet/mib/mib.UofA.txt'\" unpacked with wrong size!
  fi
  # end of 'netramet/mib/mib.UofA.txt'
fi
if test -f 'netramet/src/apps/snmp_var_route.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/apps/snmp_var_route.c'\"
else
  echo shar: Extracting \"'netramet/src/apps/snmp_var_route.c'\" \(8556 characters\)
  sed "s/^X//" >'netramet/src/apps/snmp_var_route.c' <<'END_OF_FILE'
X/*
X * snmp_var_route.c - return a pointer to the named variable.
X *
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
X#define GATEWAY			/* MultiNet is always configured this way! */
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include <syslog.h>
X/* #include <sys/mbuf.h> */
X#include <net/if.h>
X#define KERNEL		/* to get routehash and RTHASHSIZ */
X#include <net/route.h>
X#undef	KERNEL
X#define rt_unit rt_hash		       /* Reuse this field for device # */
X#include <nlist.h>
X#ifndef NULL
X#define NULL 0
X#endif
X
X#define CACHE_TIME (120)	    /* Seconds */
X
X#include "ausnmp.h"
X
X#include "asn1.h"
X#include "snmp.h"
X#include "snmpimpl.h"
X#include "mib.h"
X#include "snmp_vars.h"
X
Xstatic struct rtentry **rthead=0;
Xstatic int rtsize=0, rtalloc=0;
X
Xstatic struct nlist nl[] = {
X#define N_RTHOST       0
X	{ "_rthost" },
X#define N_RTNET        1
X	{ "_rtnet" },
X#define N_RTHASHSIZE	2
X	{ "_rthashsize" },
X	0,
X};
X
Xu_char *
Xvar_ipRouteEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output strings */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    /*
X     * object identifier is of form:
X     * 1.3.6.1.2.1.4.21.1.1.A.B.C.D,  where A.B.C.D is IP address.
X     * IPADDR starts at offset 10.
X     */
X    register int Save_Valid, result, RtIndex;
X    static int saveNameLen=0, saveExact=0, saveRtIndex=0;
X    static oid saveName[14], Current[14];
X    u_char *cp;
X    oid *op;
X
X
X    /*
X     *	OPTIMIZATION:
X     *
X     *	If the name was the same as the last name, with the possible
X     *	exception of the [9]th token, then don't read the routing table
X     *
X     */
X
X    if ((saveNameLen == *length) && (saveExact == exact)) {
X	register int temp=name[9];
X	name[9] = 0;
X	Save_Valid = (compare(name, *length, saveName, saveNameLen) == 0);
X	name[9] = temp;
X    } else Save_Valid = 0;
X
X    if (Save_Valid) {
X	register int temp=name[9];    /* Fix up 'lowest' found entry */
X	bcopy((char *) Current, (char *) name, 14 * sizeof(oid));
X	name[9] = temp;
X	*length = 14;
X	RtIndex = saveRtIndex;
X    } else {
X	/* fill in object part of name for current (less sizeof instance part) */
X
X	bcopy((char *)vp->name, (char *)Current, (int)(vp->namelen - 4) * sizeof(oid));
X
X#if 0
X	/*
X	 *  Only reload if this is the start of a wildcard
X	 */
X	if (*length < 14) {
X	    Route_Scan_Reload();
X	}
X#else
X        Route_Scan_Reload();
X#endif
X	for(RtIndex=0; RtIndex < rtsize; RtIndex++) {
X	    cp = (u_char *)&(((struct sockaddr_in *) &(rthead[RtIndex]->rt_dst))->sin_addr.s_addr);
X	    op = Current + 10;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X
X	    result = compare(name, *length, Current, 14);
X	    if ((exact && (result == 0)) || (!exact && (result < 0)))
X		break;
X	}
X	if (RtIndex >= rtsize) return(NULL);
X	/*
X	 *  Save in the 'cache'
X	 */
X	bcopy((char *) name, (char *) saveName, *length * sizeof(oid));
X	saveName[9] = '\0';
X	saveNameLen = *length;
X	saveExact = exact;
X	saveRtIndex = RtIndex;
X	/*
X	 *  Return the name
X	 */
X	bcopy((char *) Current, (char *) name, 14 * sizeof(oid));
X	*length = 14;
X    }
X
X    *access_method = 0;
X    *var_len = sizeof(long_return);
X    switch(vp->magic){
X	case IPROUTEDEST:
X	    return(u_char *) &((struct sockaddr_in *) &rthead[RtIndex]->rt_dst)->sin_addr.s_addr;
X	case IPROUTEIFINDEX:
X	    long_return = rthead[RtIndex]->rt_unit;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC1:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_GATEWAY) ? 1 : 0;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC2:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC3:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC4:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTENEXTHOP:
X	    return(u_char *) &((struct sockaddr_in *) &rthead[RtIndex]->rt_gateway)->sin_addr.s_addr;
X	case IPROUTETYPE:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_GATEWAY) ? 4 : 3;
X	    return (u_char *)&long_return;
X	case IPROUTEPROTO:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_DYNAMIC) ? 4 : 2;
X	    return (u_char *)&long_return;
X	case IPROUTEAGE:
X	    long_return = 0;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X   }
X   return NULL;
X}
X
Xinit_routes(){
X
X    nlist("/vmunix",nl);
X}
X
Xstatic Route_Scan_Reload()
X{
X#ifdef XXYYZZ
X	struct mbuf **routehash, mb;
X	register struct mbuf *m;
X	struct ifnet ifnet;
X	struct rtentry *rt;
X	int i, table, qsort_compare();
X	register char *cp;
X	char name[16], temp[16];
X	static int Time_Of_Last_Reload=0;
X	struct timeval now;
X	int hashsize;
X
X	gettimeofday(&now, (struct timezone *)0);
X	if (Time_Of_Last_Reload+CACHE_TIME > now.tv_sec)
X	    return;
X	Time_Of_Last_Reload =  now.tv_sec;
X
X	/*
X	 *  Makes sure we have SOME space allocated for new routing entries
X	 */
X	if (!rthead) {
X	    rthead = (struct rtentry **) malloc(100 * sizeof(struct rtentry *));
X	    bzero((char *)rthead, 100 * sizeof(struct rtentry *));
X	    rtalloc = 100;
X	}
X
X	for (table=N_RTHOST; table<=N_RTNET; table++) {
X	    klseek(nl[N_RTHASHSIZE].n_value);
X	    klread((char *)&hashsize, sizeof(hashsize));
X	    routehash = (struct mbuf **)malloc(hashsize * sizeof(struct mbuf *));
X	    klseek(nl[table].n_value);
X	    klread((char *)routehash, hashsize * sizeof(struct mbuf *));
X	    for (i = 0; i < hashsize; i++) {
X		if (routehash[i] == 0)
X			continue;
X		m = routehash[i];
X		while (m) {
X		    /*
X		     *	Dig the route out of the kernel...
X		     */
X		    klseek(m);
X		    klread(&mb, sizeof (mb));
X		    m = mb.m_next;
X		    rt = mtod(&mb, struct rtentry *);
X		    if (rt->rt_ifp != 0) {
X			klseek(rt->rt_ifp);
X			klread((char *)&ifnet, sizeof (ifnet));
X			klseek((int)ifnet.if_name);
X			klread(name, 16);
X			name[15] = '\0';
X			cp = (char *) index(name, '\0');
X			*cp++ = ifnet.if_unit + '0';
X			*cp = '\0';
X/*			if (strcmp(name,"lo0") == 0) continue; */
X			Interface_Scan_Init();
X			while (Interface_Scan_Next(&rt->rt_unit, temp, 0, 0) != 0) {
X			    if (strcmp(name, temp) == 0) break;
X			}
X		    }
X		    /*
X		     *	Allocate a block to hold it and add it to the database
X		     */
X		    if (rtsize >= rtalloc) {
X			rthead = (struct rtentry **) realloc((char *)rthead, 2 * rtalloc * sizeof(struct rtentry *));
X			bzero((char *) &rthead[rtalloc], rtalloc * sizeof(struct rtentry *));
X			rtalloc *= 2;
X		    }
X		    if (!rthead[rtsize])
X			rthead[rtsize] = (struct rtentry *) malloc(sizeof(struct rtentry));
X		    /*
X		     *	Add this to the database
X		     */
X		    bcopy((char *)rt, (char *)rthead[rtsize], sizeof(struct rtentry));
X		    rtsize++;
X		}
X	    }
X	}
X	/*
X	 *  Sort it!
X	 */
X	qsort((char *)rthead,rtsize,sizeof(rthead[0]),qsort_compare);
X#endif /* $$$ */
X}
X
X
X
X/*
X *	Create a host table
X */
Xstatic int qsort_compare(r1,r2)
Xstruct rtentry **r1, **r2;
X{
X	register u_long dst1 = ntohl(((struct sockaddr_in *) &((*r1)->rt_dst))->sin_addr.s_addr);
X	register u_long dst2 = ntohl(((struct sockaddr_in *) &((*r2)->rt_dst))->sin_addr.s_addr);
X
X	/*
X	 *	Do the comparison
X	 */
X	if (dst1 == dst2) return(0);
X	if (dst1 > dst2) return(1);
X	return(-1);
X}
END_OF_FILE
  if test 8556 -ne `wc -c <'netramet/src/apps/snmp_var_route.c'`; then
    echo shar: \"'netramet/src/apps/snmp_var_route.c'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/apps/snmp_var_route.c'
fi
if test -f 'netramet/src/meter/include/met_vars.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/meter/include/met_vars.h'\"
else
  echo shar: Extracting \"'netramet/src/meter/include/met_vars.h'\" \(8490 characters\)
  sed "s/^X//" >'netramet/src/meter/include/met_vars.h' <<'END_OF_FILE'
X/* 1125, Tue 5 Oct 93
X
X   MET_VARS.H:  Data structures for AU Meter SNMP interface
X
X   Copyright (C) 1992,1993 by Nevil Brownlee,
X   Computer Centre,  University of Auckland */
X
X/* Definitions for SNMP (RFC 1067) agent variable finder.
X *
X *
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
Xu_char far *var_system();
Xu_char far *var_ifEntry();
Xu_char far *var_atEntry();
Xu_char far *var_ip();
Xu_char far *var_ipAddrEntry();
Xu_char far *var_ipRouteEntry();
Xu_char far *var_icmp();
Xu_char far *var_tcp();
Xu_char far *var_udp();
Xu_char far *var_process();
Xu_char far *var_event();
Xu_char far *var_rinfo();  /* Internet Accounting .. */
Xu_char far *var_col_tbl();
Xu_char far *var_ft();
Xu_char far *var_flow_index();
Xu_char far *var_rt();
Xu_char far *getStatPtr();
X
Xextern long long_return;
Xextern u_char return_buf[];
X
X#define INST	0xFFFFFFFF	/* used to fill out the instance field of the variables table */
X
X/*
X * These are unit magic numbers for each variable.
X */
X
X#define VERSION_DESCR	      0
X#define VERSION_ID	      1
X#define UPTIME		      3
X#define IFNUMBER	      2
X
X#define HIGHWATERMARK        11  /* 1 in SNMP */
X#define FLOODMARK            12
X#define INACT_TIMEOUT        13
X#define LAST_COLLECT_TIME    16
X#define CURRENT_RULE_SET     18
X#define EMERGENCY_RULE_SET   19
X
X#define MSSTATSRESET         31
X#define MSSTATSTIME          32
X#define MSNPACKETS           33
X#define MSTBACKLOG           34
X#define MSMXPKTRATE          35
X#define MSMXBACKLOG          36
X#define MSNFLOWS             37
X#define MSFLOWSRCV           38
X#define MSNMATCHES           39
X#define MSHASHSRCHS          40
X#define MSHASHCMPS           41
X#define MSTHASHSZ            42
X#define MSNHASHENTS          43
X#define MSGCINTERVAL         44
X#define MSMXFLOWS            45
X#define MSAVIDLEPER1000      46
X#define MSMINIDLEPER1000     47
X
X#define PCNEARMEM	     61
X#define PCFARMEM             62
X#define PCBADPKTS	     63
X#define PCNOBUFPKTS	     64
X#define PCLOSTPKTS	     65
X
X#define IFINDEX		 1
X#define IFDESCR		 2
X#define IFTYPE	         3
X#define IFMTU		 4
X#define IFSPEED		 5
X#define IFPHYSADDRESS	 6
X#define IFADMINSTATUS	 7
X#define IFOPERSTATUS	 8
X#define IFLASTCHANGE	 9
X#define IFINOCTETS	10
X#define IFINUCASTPKTS	11
X#define IFINNUCASTPKTS	12
X#define IFINDISCARDS	13
X#define IFINERRORS	14
X#define IFINUNKNOWNPROTOS 15
X#define IFOUTOCTETS	16
X#define IFOUTUCASTPKTS	17
X#define IFOUTNUCASTPKTS 18
X#define IFOUTDISCARDS	19
X#define IFOUTERRORS	20
X#define IFOUTQLEN	21
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	1
X#define ATNETADDRESS	2
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	1
X#define IPINRECEIVES	2
X#define IPINHDRERRORS	3
X#define IPINADDRERRORS	4
X#define IPFORWDATAGRAMS 5
X#define IPINUNKNOWNPROTOS 6
X#define IPINDISCARDS	7
X#define IPINDELIVERS	8
X#define IPOUTREQUESTS	9
X#define IPOUTDISCARDS	10
X#define IPOUTNOROUTES	11
X#define IPREASMTIMEOUT	12
X#define IPREASMREQDS	13
X#define IPREASMOKS	14
X#define IPREASMFAILS	15
X#define IPFRAGOKS	16
X#define IPFRAGFAILS	17
X#define IPFRAGCREATES	18
X
X#define IPADADDR	1
X#define IPADIFINDEX	2
X#define IPADNETMASK	3
X#define IPADBCASTADDR	4
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	1
X#define IPROUTEMETRIC1	2
X#define IPROUTEMETRIC2	3
X#define IPROUTEMETRIC3	4
X#define IPROUTEMETRIC4	5
X#define IPROUTENEXTHOP	6
X#define IPROUTETYPE	7
X#define IPROUTEPROTO	8
X#define IPROUTEAGE	9
X
X#define ICMPINMSGS	     0
X#define ICMPINERRORS	     1
X#define ICMPINDESTUNREACHS   2
X#define ICMPINTIMEEXCDS      3
X#define ICMPINPARMPROBS      4
X#define ICMPINSRCQUENCHS     5
X#define ICMPINREDIRECTS      6
X#define ICMPINECHOS	     7
X#define ICMPINECHOREPS	     8
X#define ICMPINTIMESTAMPS     9
X#define ICMPINTIMESTAMPREPS 10
X#define ICMPINADDRMASKS     11
X#define ICMPINADDRMASKREPS  12
X#define ICMPOUTMSGS	    13
X#define ICMPOUTERRORS	    14
X#define ICMPOUTDESTUNREACHS 15
X#define ICMPOUTTIMEEXCDS    16
X#define ICMPOUTPARMPROBS    17
X#define ICMPOUTSRCQUENCHS   18
X#define ICMPOUTREDIRECTS    19
X#define ICMPOUTECHOS	    20
X#define ICMPOUTECHOREPS     21
X#define ICMPOUTTIMESTAMPS   22
X#define ICMPOUTTIMESTAMPREPS 23
X#define ICMPOUTADDRMASKS    24
X#define ICMPOUTADDRMASKREPS 25
X
X#define TCPRTOALGORITHM      1
X#define TCPRTOMIN	     2
X#define TCPRTOMAX	     3
X#define TCPMAXCONN	     4
X#define TCPACTIVEOPENS	     5
X#define TCPPASSIVEOPENS      6
X#define TCPATTEMPTFAILS      7
X#define TCPESTABRESETS	     8
X#define TCPCURRESTAB	     9
X#define TCPINSEGS	    10
X#define TCPOUTSEGS	    11
X#define TCPRETRANSSEGS	    12
X#define TCPCONNSTATE	    13
X#define TCPCONNLOCALADDRESS 14
X#define TCPCONNLOCALPORT    15
X#define TCPCONNREMADDRESS   16
X#define TCPCONNREMPORT	    17
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    1
X#define UDPINERRORS	    2
X#define UDPOUTDATAGRAMS     3
X
X#define EVENTCLASS		    0
X#define EVENTINSTANCE		    1
X#define EVENTALARMTYPE		    2
X#define EVENTTIME		    3
X#define EVENTPROBCAUSE		    4
X#define EVENTSPECIFICPROBLEM	    5
X#define EVENTSEVERITY		    6
X#define EVENTBACKUPSTATUS	    7
X#define EVENTBACKUPINSTANCE	    8
X#define EVENTTREND		    9
X#define EVENTTHRESHOLD		    10
X#define EVENTTHRESHOLDLEVEL	    11
X#define EVENTTHRESHOLDOBSVALUE	    12
X#define EVENTID			    13
X#define EVENTCORRELATIONS	    14
X#define EVENTOPERSTATE		    16
X#define EVENTADMINSTATE		    17
X#define EVENTMONATTRIBUTES	    18
X#define EVENTREPAIRACTION	    19
X#define EVENTDATA		    20
X#define EVENTTEXT		    21
X#define EVENTCREDIBILITY	    22
X#define EVENTINDEX		    23
X#define EVENTVALID		    24
X
X#define RIINDEX		 1
X#define RIRULESIZE	 2
X#define RIACTIONSIZE	 3
X
X#define CIINDEX 	11
X#define CIPEERADDR	12
X#define CILASTTIME	13
X#define CIPREVTIME	14
X
X/* FT defines for flow table moved to flowhash.h */
X
X#define FTCRFIRSTTIME	        0
X#define FTCRFLOWINDEX	        1
X#define FTACFIRSTTIME	        2
X#define FTACFLOWINDEX	        3
X
X#define FTCOLATTRIB	       11
X#define FTCOLTIME	       12
X#define FTCOLINDEX	       13
X#define FTCOLBLOB	       14
X
X#define RTRULESET  	 	1
X#define RTRULEINDEX	 	2
X#define RTSELECTOR	 	3
X#define RTRULEMASK	 	4
X#define RTMATCHVALUE	 	5
X#define RTRULEACTION	 	6
X#define RTJUMPINDEX	 	7
X
X#define ATACTIONINDEX	      101
X#define ATLOWINTERFACE        103
X#define ATLOWADJACENTTYPE     104
X#define ATLOWADJACENTADDRESS  105
X#define ATLOWADJACENTMASK     106
X#define ATLOWPEERTYPE	      107
X#define ATLOWPEERTYPEMASK     108
X#define ATLOWPEERADDRESS      109
X#define ATLOWPEERMASK         110
X#define ATLOWDETAILTYPE       111
X#define ATLOWDETAILTYPEMASK   112
X#define ATLOWDETAILADDRESS    113
X#define ATLOWDETAILMASK       114
X#define ATHIINTERFACE         117
X#define ATHIADJACENTTYPE      118
X#define ATHIADJACENTADDRESS   119
X#define ATHIADJACENTMASK      120
X#define ATHIPEERTYPE	      121
X#define ATHIPEERTYPEMASK      122
X#define ATHIPEERADDRESS       123
X#define ATHIPEERMASK          124
X#define ATHIDETAILTYPE        125
X#define ATHIDETAILTYPEMASK    126
X#define ATHIDETAILADDRESS     127
X#define ATHIDETAILMASK        128
X#define ATPDUSCALE            133
X#define ATOCTETSCALE          134
X#define ATACTIONSET	      135
X
Xstruct variable {
X    oid		    name[26];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char far	    *(*findVar)();  /* function that finds variable */
X};
END_OF_FILE
  if test 8490 -ne `wc -c <'netramet/src/meter/include/met_vars.h'`; then
    echo shar: \"'netramet/src/meter/include/met_vars.h'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/meter/include/met_vars.h'
fi
if test -f 'netramet/src/snmplib/include/snmpapi.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/snmplib/include/snmpapi.h'\"
else
  echo shar: Extracting \"'netramet/src/snmplib/include/snmpapi.h'\" \(8565 characters\)
  sed "s/^X//" >'netramet/src/snmplib/include/snmpapi.h' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X/*
X * snmp_api.h - API for access to snmp.
X */
X
X
Xtypedef struct sockaddr_in  ipaddr;
X
Xstruct snmp_session {
X    u_char  *community;	/* community for outgoing requests. */
X    int	    community_len;  /* Length of community name. */
X    int	    retries;	/* Number of retries before timeout. */
X    long    timeout;    /* Number of uS until first timeout, then exponential backoff */
X    char    *peername;	/* Domain name or dotted IP address of default peer */
X    u_short remote_port;/* UDP port number of peer. */
X    u_short local_port; /* My UDP port number, 0 for default, picked randomly */
X    /* Authentication function or NULL if null authentication is used */
X    u_char    *(*authenticator)();
X    int	    (*callback)();  /* Function to interpret incoming data */
X    /* Pointer to data that the callback function may consider important */
X    void    *callback_magic;
X};
X
X/*
X * Set fields in session and pdu to the following to get a default or unconfigured value.
X */
X#define SNMP_DEFAULT_COMMUNITY_LEN  0	/* to get a default community name */
X#define SNMP_DEFAULT_RETRIES	    -1
X#define SNMP_DEFAULT_TIMEOUT	    -1
X#define SNMP_DEFAULT_REMPORT	    0
X#define SNMP_DEFAULT_REQID	    0
X#define SNMP_DEFAULT_ERRSTAT	    -1
X#define SNMP_DEFAULT_ERRINDEX	    -1
X#define SNMP_DEFAULT_ADDRESS	    0
X#define SNMP_DEFAULT_PEERNAME	    NULL
X#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
X#define SNMP_DEFAULT_TIME	    0
X
Xextern int snmp_errno;
X/* Error return values */
X#define SNMPERR_GENERR		-1
X#define SNMPERR_BAD_LOCPORT	-2  /* local port was already in use */
X#define SNMPERR_BAD_ADDRESS	-3
X#define SNMPERR_BAD_SESSION	-4
X#define SNMPERR_TOO_LONG	-5
X
X
Xstruct snmp_pdu {
X    ipaddr  address;	/* Address of peer */
X
X    int	    command;	/* Type of this PDU */
X
X    u_long  reqid;	/* Request id */
X    u_long  errstat;	/* Error status */
X    u_long  errindex;	/* Error index */
X
X    /* Trap information */
X    oid	    *enterprise;/* System OID */
X    int	    enterprise_length;
X    ipaddr  agent_addr;	/* address of object generating trap */
X    int	    trap_type;	/* trap type */
X    int	    specific_type;  /* specific type */
X    u_long  time;	/* Uptime */
X
X    struct variable_list *variables;
X};
X
X
Xstruct variable_list {
X    struct variable_list *next_variable;    /* NULL for last variable */
X    oid	    *name;  /* Object identifier of variable */
X    int	    name_length;    /* number of subid's in name */
X    u_char  type;   /* ASN type of variable */
X    union { /* value of variable */
X	long	*integer;
X	u_char	*string;
X	oid	*objid;
X    } val;
X    int	    val_len;
X};
X
X/*
X * struct snmp_session *snmp_open(session)
X *	struct snmp_session *session;
X * 
X * Sets up the session with the snmp_session information provided
X * by the user.  Then opens and binds the necessary UDP port.
X * A handle to the created session is returned (this is different than
X * the pointer passed to snmp_open()).  On any error, NULL is returned
X * and snmp_errno is set to the appropriate error code.
X */
Xstruct snmp_session *snmp_open();
X
X/*
X * int snmp_close(session)
X *     struct snmp_session *session;
X * 
X * Close the input session.  Frees all data allocated for the session,
X * dequeues any pending requests, and closes any sockets allocated for
X * the session.  Returns 0 on error, 1 otherwise.
X */
Xint snmp_close();
X
X
X/*
X * int snmp_send(session, pdu)
X *     struct snmp_session *session;
X *     struct snmp_pdu	*pdu;
X * 
X * Sends the input pdu on the session after calling snmp_build to create
X * a serialized packet.  If necessary, set some of the pdu data from the
X * session defaults.  Add a request corresponding to this pdu to the list
X * of outstanding requests on this session, then send the pdu.
X * Returns the request id of the generated packet if applicable, otherwise 1.
X * On any error, 0 is returned.
X * The pdu is freed by snmp_send() unless a failure occured.
X */
Xint snmp_send();
X
X
X/*
X * void snmp_read(fdset)
X *     fd_set  *fdset;
X * 
X * Checks to see if any of the fd's set in the fdset belong to
X * snmp.  Each socket with it's fd set has a packet read from it
X * and snmp_parse is called on the packet received.  The resulting pdu
X * is passed to the callback routine for that session.  If the callback
X * routine returns successfully, the pdu and it's request are deleted.
X */
Xvoid snmp_read();
X
X
X/*
X * void
X * snmp_free_pdu(pdu)
X *     struct snmp_pdu *pdu;
X * 
X * Frees the pdu and any malloc'd data associated with it.
X */
Xvoid snmp_free_pdu();
X
X/*
X * int snmp_select_info(numfds, fdset, timeout, block)
X * int *numfds;
X * fd_set   *fdset;
X * struct timeval *timeout;
X * int *block;
X *
X * Returns info about what snmp requires from a select statement.
X * numfds is the number of fds in the list that are significant.
X * All file descriptors opened for SNMP are OR'd into the fdset.
X * If activity occurs on any of these file descriptors, snmp_read
X * should be called with that file descriptor set.
X *
X * The timeout is the latest time that SNMP can wait for a timeout.  The
X * select should be done with the minimum time between timeout and any other
X * timeouts necessary.  This should be checked upon each invocation of select.
X * If a timeout is received, snmp_timeout should be called to check if the
X * timeout was for SNMP.  (snmp_timeout is idempotent)
X *
X * Block is 1 if the select is requested to block indefinitely, rather than time out.
X * If block is input as 1, the timeout value will be treated as undefined, but it must
X * be available for setting in snmp_select_info.  On return, if block is true, the value
X * of timeout will be undefined.
X *
X * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
X */
Xint snmp_select_info();
X
X/*
X * void snmp_timeout();
X * 
X * snmp_timeout should be called whenever the timeout from snmp_select_info expires,
X * but it is idempotent, so snmp_timeout can be polled (probably a cpu expensive
X * proposition).  snmp_timeout checks to see if any of the sessions have an
X * outstanding request that has timed out.  If it finds one (or more), and that
X * pdu has more retries available, a new packet is formed from the pdu and is
X * resent.  If there are no more retries available, the callback for the session
X * is used to alert the user of the timeout.
X */
Xvoid snmp_timeout();
X
X
X/*
X * This routine must be supplied by the application:
X *
X * u_char *authenticator(pdu, length, community, community_len)
X * u_char *pdu;		The rest of the PDU to be authenticated
X * int *length;		The length of the PDU (updated by the authenticator)
X * u_char *community;	The community name to authenticate under.
X * int	community_len	The length of the community name.
X *
X * Returns the authenticated pdu, or NULL if authentication failed.
X * If null authentication is used, the authenticator in snmp_session can be
X * set to NULL(0).
X */
X
X/*
X * This routine must be supplied by the application:
X *
X * int callback(operation, session, reqid, pdu, magic)
X * int operation;
X * struct snmp_session *session;    The session authenticated under.
X * int reqid;			    The request id of this pdu (0 for TRAP)
X * struct snmp_pdu *pdu;	    The pdu information.
X * void *magic			    A link to the data for this routine.
X *
X * Returns 1 if request was successful, 0 if it should be kept pending.
X * Any data in the pdu must be copied because it will be freed elsewhere.
X * Operations are defined below:
X */
X#define RECEIVED_MESSAGE   1
X#define TIMED_OUT	   2
X
X
Xextern int snmp_dump_packet;
END_OF_FILE
  if test 8565 -ne `wc -c <'netramet/src/snmplib/include/snmpapi.h'`; then
    echo shar: \"'netramet/src/snmplib/include/snmpapi.h'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/snmplib/include/snmpapi.h'
fi
if test -f 'netramet/src/snmplib/include/snmpvars.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'netramet/src/snmplib/include/snmpvars.h'\"
else
  echo shar: Extracting \"'netramet/src/snmplib/include/snmpvars.h'\" \(6610 characters\)
  sed "s/^X//" >'netramet/src/snmplib/include/snmpvars.h' <<'END_OF_FILE'
X/*
X * Definitions for SNMP (RFC 1067) agent variable finder.
X *
X *
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
Xu_char	*var_system();
Xu_char	*var_ifEntry();
Xu_char	*var_atEntry();
Xu_char	*var_ip();
Xu_char	*var_ipAddrEntry();
Xu_char	*var_ipRouteEntry();
Xu_char	*var_icmp();
Xu_char	*var_tcp();
Xu_char	*var_udp();
Xu_char	*var_process();
Xu_char	*var_event();
Xu_char	*var_pt();  /* AU: packet types table */
Xu_char	*var_ft();  /* AU: flow table */
Xu_char	*var_rt();  /* AU: rule table */
Xu_char	*getStatPtr();
X
Xextern long long_return;
Xextern u_char return_buf[];
X
X#define INST	0xFFFFFFFF	/* used to fill out the instance field of the variables table */
X
X/*
X * These are unit magic numbers for each variable.
X */
X
X#define VERSION_DESCR	0
X#define VERSION_ID	1
X#define IFNUMBER	2
X#define UPTIME		3
X#define EVENTNEXTINDEX	4
X
X#define PTTYPES		5  /* Don't really need this in var_system */
X
X#define FTFLOWCOUNT	6
X#define FTCHKTIME	7
X#define FTCHKFLOWCOUNT	8
X#define FTPREVCHKTIME	9
X
X#define IFINDEX		1
X#define IFDESCR		2
X#define IFTYPE		3
X#define IFMTU		4
X#define IFSPEED		5
X#define IFPHYSADDRESS	6
X#define IFADMINSTATUS	7
X#define IFOPERSTATUS	8
X#define IFLASTCHANGE	9
X#define IFINOCTETS	10
X#define IFINUCASTPKTS	11
X#define IFINNUCASTPKTS	12
X#define IFINDISCARDS	13
X#define IFINERRORS	14
X#define IFINUNKNOWNPROTOS 15
X#define IFOUTOCTETS	16
X#define IFOUTUCASTPKTS	17
X#define IFOUTNUCASTPKTS 18
X#define IFOUTDISCARDS	19
X#define IFOUTERRORS	20
X#define IFOUTQLEN	21
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	1
X#define ATNETADDRESS	2
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	1
X#define IPINRECEIVES	2
X#define IPINHDRERRORS	3
X#define IPINADDRERRORS	4
X#define IPFORWDATAGRAMS 5
X#define IPINUNKNOWNPROTOS 6
X#define IPINDISCARDS	7
X#define IPINDELIVERS	8
X#define IPOUTREQUESTS	9
X#define IPOUTDISCARDS	10
X#define IPOUTNOROUTES	11
X#define IPREASMTIMEOUT	12
X#define IPREASMREQDS	13
X#define IPREASMOKS	14
X#define IPREASMFAILS	15
X#define IPFRAGOKS	16
X#define IPFRAGFAILS	17
X#define IPFRAGCREATES	18
X
X#define IPADADDR	1
X#define IPADIFINDEX	2
X#define IPADNETMASK	3
X#define IPADBCASTADDR	4
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	1
X#define IPROUTEMETRIC1	2
X#define IPROUTEMETRIC2	3
X#define IPROUTEMETRIC3	4
X#define IPROUTEMETRIC4	5
X#define IPROUTENEXTHOP	6
X#define IPROUTETYPE	7
X#define IPROUTEPROTO	8
X#define IPROUTEAGE	9
X
X#define ICMPINMSGS	     0
X#define ICMPINERRORS	     1
X#define ICMPINDESTUNREACHS   2
X#define ICMPINTIMEEXCDS      3
X#define ICMPINPARMPROBS      4
X#define ICMPINSRCQUENCHS     5
X#define ICMPINREDIRECTS      6
X#define ICMPINECHOS	     7
X#define ICMPINECHOREPS	     8
X#define ICMPINTIMESTAMPS     9
X#define ICMPINTIMESTAMPREPS 10
X#define ICMPINADDRMASKS     11
X#define ICMPINADDRMASKREPS  12
X#define ICMPOUTMSGS	    13
X#define ICMPOUTERRORS	    14
X#define ICMPOUTDESTUNREACHS 15
X#define ICMPOUTTIMEEXCDS    16
X#define ICMPOUTPARMPROBS    17
X#define ICMPOUTSRCQUENCHS   18
X#define ICMPOUTREDIRECTS    19
X#define ICMPOUTECHOS	    20
X#define ICMPOUTECHOREPS     21
X#define ICMPOUTTIMESTAMPS   22
X#define ICMPOUTTIMESTAMPREPS 23
X#define ICMPOUTADDRMASKS    24
X#define ICMPOUTADDRMASKREPS 25
X
X#define TCPRTOALGORITHM      1
X#define TCPRTOMIN	     2
X#define TCPRTOMAX	     3
X#define TCPMAXCONN	     4
X#define TCPACTIVEOPENS	     5
X#define TCPPASSIVEOPENS      6
X#define TCPATTEMPTFAILS      7
X#define TCPESTABRESETS	     8
X#define TCPCURRESTAB	     9
X#define TCPINSEGS	    10
X#define TCPOUTSEGS	    11
X#define TCPRETRANSSEGS	    12
X#define TCPCONNSTATE	    13
X#define TCPCONNLOCALADDRESS 14
X#define TCPCONNLOCALPORT    15
X#define TCPCONNREMADDRESS   16
X#define TCPCONNREMPORT	    17
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    1
X#define UDPINERRORS	    2
X#define UDPOUTDATAGRAMS     3
X
X#define EVENTCLASS		    0
X#define EVENTINSTANCE		    1
X#define EVENTALARMTYPE		    2
X#define EVENTTIME		    3
X#define EVENTPROBCAUSE		    4
X#define EVENTSPECIFICPROBLEM	    5
X#define EVENTSEVERITY		    6
X#define EVENTBACKUPSTATUS	    7
X#define EVENTBACKUPINSTANCE	    8
X#define EVENTTREND		    9
X#define EVENTTHRESHOLD		    10
X#define EVENTTHRESHOLDLEVEL	    11
X#define EVENTTHRESHOLDOBSVALUE	    12
X#define EVENTID			    13
X#define EVENTCORRELATIONS	    14
X#define EVENTOPERSTATE		    16
X#define EVENTADMINSTATE		    17
X#define EVENTMONATTRIBUTES	    18
X#define EVENTREPAIRACTION	    19
X#define EVENTDATA		    20
X#define EVENTTEXT		    21
X#define EVENTCREDIBILITY	    22
X#define EVENTINDEX		    23
X#define EVENTVALID		    24
X
X#define PTPACKETTYPE	    1
X#define PTPACKETCOUNT	    2
X#define PTBYTECOUNT	    3
X
X#define FTFLOWNBR	 1
X#define FTFLOWSTATUS	 2
X#define FTNEXTACTIVEFLOW 3
X#define FTADDRTYPE	 4
X#define FTFROMADDR	 5
X#define FTFROMMASK	 6
X#define FTFROMTALLY	 7
X#define FTTOADDR	 8
X#define FTTOMASK	 9
X#define FTTOTALLY	10
X#define FTFWDPACKETS	11
X#define FTFWDBYTES	12
X#define FTBACKPACKETS	13
X#define FTBACKBYTES	14
X#define FTCHKFWDPKTS	15
X#define FTCHKFWDBYTES	16
X#define FTCHKBACKPKTS	17
X#define FTCHKBACKBYTES	18
X
X#define RTINDEX  	 1
X#define RTTREENBR	 2
X#define RTADDRTYPE	 3
X#define RTFROMADDR	 4
X#define RTFROMMASK	 5
X#define RTFROMTALLY	 6
X#define RTTOADDR	 7
X#define RTTOMASK	 8
X#define RTTOTALLY	 9
X
Xstruct variable {
X    oid		    name[26];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char	    *(*findVar)();  /* function that finds variable */
X};
END_OF_FILE
  if test 6610 -ne `wc -c <'netramet/src/snmplib/include/snmpvars.h'`; then
    echo shar: \"'netramet/src/snmplib/include/snmpvars.h'\" unpacked with wrong size!
  fi
  # end of 'netramet/src/snmplib/include/snmpvars.h'
fi
echo shar: End of archive 22 \(of 25\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
