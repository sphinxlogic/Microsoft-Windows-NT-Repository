Newsgroups: comp.sources.misc
From: mgleason@cse.unl.edu (Mike Gleason)
Subject: v40i080:  ncftp - Alternative User Interface for FTP, v1.6, Part05/06
Message-ID: <1993Nov2.232451.6539@sparky.sterling.com>
X-Md4-Signature: b6d7fd2222a04a997fff3647a2742d32
Keywords: ncftp
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: NCEMRSoft
Date: Tue, 2 Nov 1993 23:24:51 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mgleason@cse.unl.edu (Mike Gleason)
Posting-number: Volume 40, Issue 80
Archive-name: ncftp/part05
Environment: UNIX, ANSI-C, !SVR4
Supersedes: ncftp: Volume 39, Issue 53-57

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Blurb cmds.h cmdtab.c defaults.h ftp.h getpass.c glob.c
#   sys.h tips.c util.h v2_Note
# Wrapped by kent@sparky on Mon Nov  1 16:19:17 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 6)."'
if test -f 'Blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Blurb'\"
else
  echo shar: Extracting \"'Blurb'\" \(2188 characters\)
  sed "s/^X//" >'Blurb' <<'END_OF_FILE'
XSubject:  NcFTP 1.6.0 - Alternative User Interface for FTP
X
XArchive-name: ncftp/part01
XEnvironment: UNIX, ANSI-C, !SVR4
XSupersedes: ncftp: Volume 39, Issue 53-57
X
XNcFTP - Alternative user interface for FTP
XVersion 1.6.0 by Mike Gleason, NCEMRSoft.
X
XI used to list the features of ncftp in this blurb, but there are just
Xtoo many to list.  Even if you only ftp occasionally, it is worth your
Xtime to install ncftp (or atleast bug your sysadmin to).  If you won't take
Xmy word for it, just ask around, or extract this archive and read the
Xman page.
X
X1.6.0 is an "evolutionary" upgrade, which consolidates all the previous
Xpatches and adds a little.  1.6, like 1.5 are "interim" versions between
X2.0 which has been suspended indefinitely due to time constraints.
X
XMajor changes since 1.5.6:
X-------------------------
X
X* Built-in support for the "term" package, used by Linux, etc.
X
X* SCO Xenix, Besta, AIX 2, AIX 3, Dynix/PTX support
X
X* Better ISC Unix support.
X
X* Several bug fixes.
X
X
XMajor changes since 1.0.2:
X-------------------------
X
X* Supports the Getline (input-edit) and GNU Readline command-line
X  editing and history libraries.
X
X* Supports the Socks firewall library, and another firewall gateway
X  implementation.
X
X* Terrific new "recent-sites" file that automatically saves the
X  sites you call;  when you open a site in the recent-sites file
X  (of course you can abbreviate the names), you start in the
X  same directory you were in last time.
X
X* Improved on-line help, and tips on how to use the program better
X  are printed each time you run the program.
X
X* Rewritten man page.
X
X* Faster ascii transfers.
X
X* Typing 'open' by itself lists all the sites the program knows
X  about (the ones in your .netrc and the recent-sites list) so
X  you can just pick one.
X
X* Enhanced colon-mode, that can dump a file to stdout (ftpcat mode)
X  or to a pager.  (i.e. ncftp -c wu:/README >/dev/null).
X
X* You can choose whether an open is anonymous by default (like it
X  had always been) or a user login by default by setting a new
X  program variable.
X
X* Bugs fixed.
X
XRead the enclosed file, v2_Notes, which explains why I won't be
Xable to work on the nearly finished, and much improved v2.0.
X
END_OF_FILE
  if test 2188 -ne `wc -c <'Blurb'`; then
    echo shar: \"'Blurb'\" unpacked with wrong size!
  fi
  # end of 'Blurb'
fi
if test -f 'cmds.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmds.h'\"
else
  echo shar: Extracting \"'cmds.h'\" \(3287 characters\)
  sed "s/^X//" >'cmds.h' <<'END_OF_FILE'
X/* cmds.h */
X
X#ifndef _cmd_h_
X#define _cmd_h_
X
X/*  $RCSfile: cmds.h,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/07/09 10:58:19 $
X */
X
X/* Verbosity levels. */
X#define V_QUIET		-1
X#define V_ERRS		0
X#define V_TERSE		1
X#define V_VERBOSE	2
X#define V_IMPLICITCD 4
X#define IS_VQUIET	(verbose <= V_QUIET)
X#define IS_VERRS	(verbose == V_ERRS)
X#define IS_VTERSE	(verbose == V_TERSE)
X#define IS_VVERBOSE	(verbose == V_VERBOSE)
X#define NOT_VQUIET	(verbose > V_QUIET)
X
X/* Open modes. */
X#define OPEN_A 1
X#define OPEN_U 0
X
X#define LS_FLAGS_AND_FILE '\1'
X
X/* Command result codes. */
X#define USAGE (88)
X#define NOERR (0)
X#define CMDERR (-1)
X
X/*
X * Format of command table.
X */
Xstruct cmd {
X	char	*c_name;	/* name of command */
X	char	c_conn;		/* must be connected to use command */
X	char	c_hidden;	/* a hidden command or alias (won't show up in help) */
X	int		(*c_handler)(int, char **);	/* function to call */
X	char	*c_help;	/* help string */
X	char	*c_usage;	/* usage string or NULL, to ask the function itself. */
X};
X
X#define NCMDS ((int) ((sizeof (cmdtab) / sizeof (struct cmd)) - 1))
X
Xstruct macel {
X	char mac_name[9];	/* macro name */
X	char *mac_start;	/* start of macro in macbuf */
X	char *mac_end;		/* end of macro in macbuf */
X};
X
Xstruct types {
X	char	*t_name;
X	char	*t_mode;
X	int		t_type;
X	char	*t_arg;
X};
X
Xstruct lslist {
X	char			*string;
X	struct lslist	*next;
X};
X
Xint settype(int argc, char **argv);
Xint _settype(char *typename);
Xint setbinary(int argc, char **argv);
Xint setascii(int argc, char **argv);
Xint put(int argc, char **argv);
Xint mput(int argc, char **argv);
Xint rem_glob_one(char *pattern);
Xint get(int argc, char **argv);
Xvoid mabort SIG_PARAMS;
Xint mget(int argc, char **argv);
Xchar *remglob(char *argv[]);
Xint setverbose(int argc, char **argv);
Xint setprompt(int argc, char **argv);
Xint setdebug(int argc, char **argv);
Xvoid fix_options(void);
Xint cd(int argc, char **argv);
Xint implicit_cd(char *dir);
Xint _cd(char *dir);
Xint lcd(int argc, char **argv);
Xint do_delete(int argc, char **argv);
Xint mdelete(int argc, char **argv);
Xint renamefile(int argc, char **argv);
Xint ls(int argc, char **argv);
Xint shell(int argc, char **argv);
Xint do_user(int argc, char **argv);
Xint pwd(int argc, char **argv);
Xint makedir(int argc, char **argv);
Xint removedir(int argc, char **argv);
Xint quote(int argc, char **argv);
Xint rmthelp(int argc, char **argv);
Xint quit(int argc, char **argv);
Xvoid close_streams(int wantShutDown);
Xint disconnect(int argc, char **argv);
Xvoid close_up_shop(void);
Xint globulize(char **cpp);
Xint cdup(int argc, char **argv);
Xint syst(int argc, char **argv);
Xint make_macro(char *name, FILE *fp);
Xint macdef(int argc, char **argv);
Xint domacro(int argc, char **argv);
Xint sizecmd(int argc, char **argv);
Xint modtime(int argc, char **argv);
Xint lookup(int argc, char **argv);
Xint rmtstatus(int argc, char **argv);
Xint create(int argc, char **argv);
Xint getlocalhostname(char *host, size_t size);
Xint show_version(int argc, char **argv);
Xvoid PurgeLineBuffer(void);
Xint ShowLineBuffer(int argc, char **argv);
Xint unimpl(int argc, char **argv);
Xlong GetDateAndSize(char *fName, unsigned long *mod_time);
Xint SetTypeByNumber(int i);
X
X/* In util.c: */
Xvoid cmd_help(struct cmd *c);
Xvoid cmd_usage(struct cmd *c);
Xstruct cmd *getcmd(char *name);
X
X#endif	/* _cmd_h_ */
END_OF_FILE
  if test 3287 -ne `wc -c <'cmds.h'`; then
    echo shar: \"'cmds.h'\" unpacked with wrong size!
  fi
  # end of 'cmds.h'
fi
if test -f 'cmdtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmdtab.c'\"
else
  echo shar: Extracting \"'cmdtab.c'\" \(10893 characters\)
  sed "s/^X//" >'cmdtab.c' <<'END_OF_FILE'
X/* cmdtab.c */
X
X/*  $RCSfile: cmdtab.c,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/07/09 11:04:56 $
X */
X
X#include "sys.h"
X#include "util.h"
X#include "cmds.h"
X#include "main.h"
X#include "ftp.h"
X#include "ftprc.h"
X#include "glob.h"
X#include "open.h"
X#include "set.h"
X#include "copyright.h"
X
X#define REMOTEFILE " remote-file-name"
X#define REMOTEFILES " remote-file-names and/or UNIX-style-wildcards"
X#define LOCALFILE " local-file-name"
X#define LOCALFILES " local-file-names and/or UNIX-style-wildcards"
X#define LDIRNAME " local-directory-name"
X#define RMTDIRNAME " remote-directory-name"
X#define EMPTYSTR ""
X#define TOGGLE " [on | off] (no argument toggles the switch)"
X
X#define BINARYHELP "transfer files as binary files, without CR/LF translation"
X#define BINARYUSAGE EMPTYSTR
X
X#define CHDIRHELP "changes the current remote working directory"
X#define CHDIRUSAGE RMTDIRNAME
X
X#define CLOSEHELP "closes FTP connection to current remote host"
X#define CLOSEUSAGE EMPTYSTR
X
X#define DELETEHELP "deletes the specified file on the remote host"
X#define DELETEUSAGE REMOTEFILE
X
X#define DIRUSAGE " \
X[flags] [remote-items] [>outfile or \"|pipecmd [cmd-args]\"]\n\
X    Note that there must be no whitespace between > and outfile, or | and\n\
X    pipecmd, and if the pipe-command needs arguments, you must enclose the\n\
X    whole thing with double quotes.\n\
XExamples:\n\
X    dir -s\n\
X    dir remoteFile\n\
X    dir /pub/mac \"|head -20\"\n\
X    dir -rtR file1 file2 dir1 >contents.txt"
X
X#define GETUSAGE " remote-file-name [local-file-name or |pipecommand]\n\
XExamples:\n\
X    get myfile.txt\n\
X    get MYFILE.ZIP myfile.zip\n\
X	get myfile.txt |head\n\
X	get myfile.txt \"|head -20\"\n\
X    get ./help/newuser.txt    (./newuser.txt will be local-file-name)\n\
X    get ./help/newuser.txt ./docs/newbie.help\n\
X    get my*.txt  (pseudo-filename-completion if match is unique, i.e. myfile.txt)"
X
X#define	HELPHELP "shows commands, and optionally tell you how to use a specific one"
X#define	HELPUSAGE " [command-name | showall (shows hidden commands) | helpall"
X
X#define LSHELP "prints remote directory contents (short-mode)"
X#define LSUSAGE " \
X[flags] [remote-items] [>outfile or \"|pipecmd [cmd-args]\"]\n\
X    Note that there must be no whitespace between > and outfile, or | and\n\
X    pipecmd, and if the pipe-command needs arguments, you must enclose the\n\
X    whole thing with double quotes.\n\
XExamples:\n\
X    ls -s\n\
X    ls remoteFile\n\
X    ls /pub/mac \"|head -20\"\n\
X    ls -lrtR file1 file2 dir1 >contents.txt"
X
X#define OPENHELP "connects to a new remote host, and optionally fetches a file\n\
X    or sets the current remote working directory"
X#define OPENUSAGE " \
X[-a | -u] [-i] [-p N] [-r [-d N] [-g N]] hostname[:pathname]\n\
X    -a     : Open anonymously (this is the default).\n\
X    -u     : Open, specify user/password.\n\
X    -i     : Ignore machine entry in your .netrc.\n\
X    -p N   : Use port #N for connection.\n\
X    -r     : \"Redial\" until connected.\n\
X    -d N   : Redial, pausing N seconds between tries.\n\
X    -g N   : Redial, giving up after N tries.\n\
X    :path  : Open site, then retrieve file \"path.\""
X
X#define PAGEHELP "view a file on the remote host with your $PAGER"
X#define PAGEUSAGE REMOTEFILE
X
X#define PDIRUSAGE " [flags] [remote-files]"
X
X#define PUTHELP "sends a local file to the current remote host"
X#define PUTUSAGE " local-file-name [remote-file-name]"
X
X#define QUITHELP "quits the program"
X#define QUITUSAGE EMPTYSTR
X
X#define RHELPHELP "asks the remote-server for help"
X#define RHELPUSAGE " [help-topic (i.e. FTP command)]"
X
X#define UNIMPLHELP "this command is not supported"
X#define UNIMPLUSAGE (NULL)
X
Xstruct cmd cmdtab[] = {
X	/* name ; must-be-connected ; hidden ; help-string ; usage-string */
X	{ "!", 			   0,  0,  shell,
X		"spawns a shell for you to run other commands",
X		" [single-command-and-arguments]" },
X	{ "$", 			   0,  0,  domacro,
X		"runs a macro previously defined in your NETRC, or with the macdef cmd",
X		"macro-number" },
X	{ "account",       0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "append",        0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "ascii", 		   1,  1,  setascii,
X		"transfer files as text files, with proper CR/LF translation",
X		"" },
X	{ "bell",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "binary",		   1,  1,  setbinary, BINARYHELP, BINARYUSAGE },
X	{ "bye",   		   0,  1,  quit, QUITHELP, QUITUSAGE },
X	{ "case",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "cd",			   1,  0,  cd, CHDIRHELP, CHDIRUSAGE },
X	{ "cdup",  		   1,  0,  cdup,
X		"changes the current remote working directory to it's parent",
X		"" },
X	{ "chdir", 		   1,  1,  cd, CHDIRHELP, CHDIRUSAGE },
X	{ "close", 		   1,  1,  disconnect, CLOSEHELP, CLOSEUSAGE },
X	{ "connect",   	   0,  1,  cmdOpen, OPENHELP, OPENUSAGE },
X	{ "cr",            0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "create",		   1,  0,  create,
X		"create an empty file on the remote host",
X		REMOTEFILE },
X	{ "delete",		   1,  0,  do_delete, DELETEHELP, DELETEUSAGE },
X	{ "debug", 		   0,  1,  setdebug,
X		"to print debugging messages during execution of the program",
X		TOGGLE },
X	{ "dir",   		   1,  0,  ls,
X		"prints remote directory contents (long-mode)",
X		DIRUSAGE },
X	{ "erase", 		   1,  1,  do_delete, DELETEHELP, DELETEUSAGE },
X	{ "exit",  		   0,  1,  quit, QUITHELP, QUITUSAGE },
X	{ "form",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "get",   		   1,  0,  get,
X		"fetches a file from the current remote host", GETUSAGE },
X	{ "glob",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "hash",  		   0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "help",  		   0,  0,  help, HELPHELP, HELPUSAGE },
X	{ "idle",  		   0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "image", 		   1,  1,  setbinary, BINARYHELP, BINARYUSAGE },
X	{ "lcd",   		   0,  0,  lcd,
X		"changes the current local directory", LDIRNAME },
X	{ "lookup",		   0,  0,  lookup,
X		"uses the name-server to tell you a host's IP number given it's\n\
X    name, or it's name given it's IP number",
X    	" hostname | host-IP-number" },
X	{ "ls",			   1,  0,  ls, LSHELP, LSUSAGE },
X	{ "macdef",		   0,  0,  macdef,
X		"defines a macro which is expanded when you use the $ command",
X		" new-macro-name" },
X	{ "mdelete",   	   1,  0,  mdelete,
X		"deletes multiple files on the remote host", REMOTEFILES  },
X	{ "mdir",  		   1,  1,  ls, LSHELP, LSUSAGE },
X	{ "mget",  		   1,  0,  mget,
X		"fetches multiple files from the remote host", REMOTEFILES },
X	{ "mkdir", 		   1,  0,  makedir,
X		"creates a new sub-directory on the current remote host",
X		RMTDIRNAME },
X	{ "mls",   		   1,  0,  ls, LSHELP, LSUSAGE },
X	{ "mode",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "modtime",   	   1,  0,  modtime,
X		"shows the last modification date for a remote file",
X		REMOTEFILE },
X	{ "more",  		   1,  1,  get, PAGEHELP, PAGEUSAGE },
X	{ "mput",  		   1,  0,  mput,
X		"sends multiple local files to the current remote host",
X		LOCALFILES },
X	{ "newer",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "nlist", 		   1,  1,  ls, LSHELP, LSUSAGE },
X	{ "nmap",          0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "ntrans",        0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "open",  		   0,  0,  cmdOpen, OPENHELP, OPENUSAGE },
X	{ "p",  		   1,  1,  get, PAGEHELP, PAGEUSAGE },
X	{ "page",  		   1,  0,  get, PAGEHELP, PAGEUSAGE },
X	{ "pdir",  		   1,  0,  ls,
X		"view a remote directory listing (long mode) with your $PAGER",
X		PDIRUSAGE },
X	{ "pls",   		   1,  0,  ls,
X		"view a remote directory listing (short mode) with your $PAGER",
X		PDIRUSAGE },
X	{ "predir",		   1,  0,  ShowLineBuffer,
X		"view the last remote directory listing with your $PAGER",
X		EMPTYSTR },
X	{ "prompt",		   0,  1,  setprompt,
X		"toggle interactive prompting on multiple commands",
X		TOGGLE },
X	{ "proxy",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "put",   		   1,  0,  put, PUTHELP, PUTUSAGE },
X	{ "pwd",   		   1,  0,  pwd,
X		"prints the name of the current remote directory",
X		EMPTYSTR },
X	{ "quit",  		   0,  0,  quit, QUITHELP, QUITUSAGE },
X	{ "quote", 		   1,  0,  quote,
X		"allows advanced users to directly enter FTP commands verbatim",
X		" FTP-commands" },
X	{ "redir", 		   1,  0,  ShowLineBuffer,
X		"re-prints the last directory listing",
X		EMPTYSTR },
X	{ "reget",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "remotehelp",	   1,  0,  rmthelp, RHELPHELP, RHELPUSAGE },
X	{ "reset",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "restart",       0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "rm",			   1,  1,  do_delete, DELETEHELP, DELETEUSAGE },
X	{ "rstatus",   	   1,  0,  rmtstatus,
X		"asks the remote-server for it's status",
X		EMPTYSTR },
X	{ "rhelp", 		   1,  1,  rmthelp, RHELPHELP, RHELPUSAGE },
X	{ "rename",		   1,  0,  renamefile,
X		"changes the name of a file on the current remote host",
X		" old-name new-name" },
X	{ "rmdir", 		   1,  0,  removedir,
X		"deletes a directory on the current remote host",
X		RMTDIRNAME },
X	{ "runique",       0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "send",  		   1,  1,  put, PUTHELP, PUTUSAGE },
X	{ "sendport",      0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "show",  		   0,  0,  do_show,
X		"prints the value of some or all program variables",
X		" all | variable-names" },
X	{ "set",   		   0,  0,  set,
X		"changes the value of a program variable; for numeric/boolean\n\
X    variables sets them to 1/true",
X		" variable-name [= new-value]" },
X	{ "site", 		   1,  0,  quote,
X		"allows advanced users to send site-specific commands to the host",
X		" site-specific-commands\n\
XExample (to try on wuarchive.wustl.edu):\n\
X	site locate emacs" },
X	{ "size",  		   1,  0,  sizecmd,
X		"shows the size of a remote file",
X		REMOTEFILE },
X	{ "struct",        0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "sunique",       0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "system",		   1,  0,  syst,
X		"tells you what type of machine the current remote host is",
X		EMPTYSTR },
X	{ "tenex",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "umask",         0,  1,  unimpl, UNIMPLHELP, UNIMPLUSAGE },
X	{ "unset", 		   0,  0,  set,
X		"resets the value of a program variable to it's default state, or for\n\
X    numeric/boolean variables, sets them to 0/false",
X		" variable-name" },
X	{ "user",  		   1,  0,  do_user,
X		"lets you login as a new user (with appropriate password)",
X		" new-user-name [new-password]" },
X	{ "type",  		   1,  0,  settype,
X		"changes the current file transfer method",
X		" ascii | binary | ebcdic | tenex" },
X	{ "verbose",   	   0,  0,  setverbose,
X		"controls how many message the program prints in response to commands",
X		" -1 (quiet) | 0 (errs) | 1 (terse) | 2 (verbose)" },
X	{ "version",   	   0,  0,  show_version,
X		"prints information about the program",
X		EMPTYSTR },
X	{ "?", 			   0,  1,  help, HELPHELP, HELPUSAGE },
X	{ NULL,			   0,  0,  NULL, NULL, NULL }
X};
X
X/* eof cmdtab.c */
END_OF_FILE
  if test 10893 -ne `wc -c <'cmdtab.c'`; then
    echo shar: \"'cmdtab.c'\" unpacked with wrong size!
  fi
  # end of 'cmdtab.c'
fi
if test -f 'defaults.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defaults.h'\"
else
  echo shar: Extracting \"'defaults.h'\" \(2811 characters\)
  sed "s/^X//" >'defaults.h' <<'END_OF_FILE'
X/* Defaults.h: default values for ftp's common variables */
X
X/* These are all surrounded by #ifndef blocks so you can just use
X * the -D flag with your compiler (i.e. -DZCAT=\"/usr/local/bin/zcat\").
X */
X
X#ifndef _DEFAULTS_H_
X#define _DEFAULTS_H_
X
X/*  $RCSfile: defaults.h,v $
X *  $Revision: 14020.13 $
X *  $Date: 93/07/09 10:58:27 $
X */
X
X#ifndef NEWMAILMESSAGE			/* For english speakers, "You have new mail." */
X#define NEWMAILMESSAGE "You have new mail."
X#endif
X
X#ifndef ZCAT					/* Usually "zcat," but use the full pathname */
X								/* if possible. */
X#	ifdef GZCAT					/* If you said you had gnu's zcat, use it
X								 * since it can do .Z files too.
X								 */
X
X#		define ZCAT GZCAT
X#	else /* !GZCAT */
X#		define ZCAT "zcat"
X#	endif	/* ifdef GZCAT */
X#endif	/* ifndef ZCAT */
X
X#ifndef MAX_XFER_BUFSIZE
X#define MAX_XFER_BUFSIZE 32768
X#endif
X
X#ifndef dANONOPEN				/* 1 or 0, usually 1 */
X#define dANONOPEN	1
X#endif
X
X#ifndef dDEBUG					/* 1 or 0, usually 0 */
X#define dDEBUG 0
X#endif
X
X#ifndef dMPROMPT				/* Usually 1, I prefer 0... */
X#define dMPROMPT 0
X#endif
X
X#ifndef dVERBOSE				/* V_QUIET, V_ERRS, V_TERSE, V_VERBOSE */
X#define dVERBOSE V_TERSE
X#endif
X
X#ifndef dPROMPT					/* short: "@Bftp@P>" */
X								/* long: "@B@E @UNcFTP@P @B@M@D@P ->" */
X#define dPROMPT "@B@c@Mncftp@P>" /* new two line prompt */
X#endif
X
X#ifndef dPAGER					/* if set to empty string, act like 'cat' */
X#define dPAGER "more"
X#endif
X
X#ifndef dLOGNAME				/* usu. put in the user's home directory. */
X#define dLOGNAME "~/.ftplog"
X#endif
X
X#ifndef dRECENTF				/* usu. put in the user's home directory. */
X#define dRECENTF "~/.ncrecent"
X#endif
X
X#ifndef dMAXRECENTS				/* limit to how many recent sites to save. */
X#define dMAXRECENTS 16
X#endif
X
X#ifndef dRECENT_ON				/* Do you want the recent log on? */
X								/* usually 1. */
X#define dRECENT_ON 1
X#endif
X
X								/* Do you want logging on by default? */
X#ifndef dLOGGING				/* usually 0 */
X#define dLOGGING 0
X#endif
X
X#ifndef dTYPE					/* usually TYPE_A */
X#define dTYPE TYPE_A
X#endif
X
X#ifndef dTYPESTR				/* usually "ascii" */
X#define dTYPESTR "ascii"
X#endif
X
X#ifndef dREDIALDELAY			/* usu. 60 (seconds). */
X#define dREDIALDELAY 60
X#endif
X
X#ifndef CMDLINELEN
X#define CMDLINELEN 256
X#endif
X
X#ifndef RECEIVEDLINELEN
X#define RECEIVEDLINELEN 256
X#endif
X
X#ifndef MAXMACROS
X#define MAXMACROS 16
X#endif
X
X#ifndef MACBUFLEN				/* usually 4096. */
X#define MACBUFLEN 4096
X#endif
X
X/* Do you want binary transfers by default? */
X#ifndef dAUTOBINARY				/* usually 1 */
X#define dAUTOBINARY 1
X#endif
X
X#ifndef dPROGRESS
X#define dPROGRESS pr_philbar	/* can be: pr_none, pr_percent, pr_philbar,
X								 * or pr_kbytes
X								 */
X#endif
X
X/* Default login name at gateway */
X#ifdef GATEWAY
X#	ifndef dGATEWAY_LOGIN
X#		define dGATEWAY_LOGIN "ftp"
X#	endif
X#endif
X
X#endif	/* _DEFAULTS_H_ */
X
X/* eof */
END_OF_FILE
  if test 2811 -ne `wc -c <'defaults.h'`; then
    echo shar: \"'defaults.h'\" unpacked with wrong size!
  fi
  # end of 'defaults.h'
fi
if test -f 'ftp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ftp.h'\"
else
  echo shar: Extracting \"'ftp.h'\" \(1714 characters\)
  sed "s/^X//" >'ftp.h' <<'END_OF_FILE'
X/* ftp.h */
X
X#ifndef _ftp_h_
X#define _ftp_h_
X
X/*  $RCSfile: ftp.h,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/07/09 11:04:12 $
X */
X
X#define IS_FILE 1
X#define IS_STREAM 0
X#define IS_PIPE -1
X
X/* Progress-meter types. */
X#define pr_none 0
X#define pr_percent 1
X#define pr_philbar 2
X#define pr_kbytes 3
X#define pr_dots 4
X#define pr_last pr_dots
X
X/* Values sent to CommandWithFlags() to determine whether to read a reply
X * from the remote host after sending the command.
X */
X#define DONT_WAIT_FOR_REPLY 0
X#define WAIT_FOR_REPLY 1
X
X/* Expect EOF values for getreply() */
X#define DONT_EXPECT_EOF		0
X#define EXPECT_EOF			1
X
Xint hookup(char *, unsigned int);
Xint Login(char *userNamePtr, char *passWordPtr, char *accountPtr, int doInit);
Xvoid cmdabort SIG_PARAMS;
Xint CommandWithFlags(char *, int);
Xint command(char *);
Xint command_noreply(char *);
Xint quiet_command(char *);
Xint verbose_command(char *);
Xint getreply(int);
Xint start_progress(int, char *);
Xint progress_report(int);
Xvoid end_progress(char *, char *, char *);
Xvoid close_file(FILE **, int);
Xvoid abortsend SIG_PARAMS;
Xint sendrequest(char *, char *, char *);
Xvoid abortrecv SIG_PARAMS;
Xvoid GetLSRemoteDir(char *, char *);
Xint AdjustLocalFileName(char *);
Xint SetToAsciiForLS(int, int);
Xint IssueCommand(char *, char *);
XFILE *OpenOutputFile(int, char *, char *, Sig_t *);
Xvoid ReceiveBinary(FILE *, FILE *, int *, char *);
Xvoid AddRedirLine(char *);
Xvoid ReceiveAscii(FILE *, FILE *, int *, char *, int);
Xvoid CloseOutputFile(FILE *, int, char *, time_t);
Xvoid ResetOldType(int);
Xint FileType(char *);
Xvoid CloseData(void);
Xint recvrequest(char *, char *, char *, char *);
Xint initconn(void);
XFILE *dataconn(char *);
X
X#endif /* _ftp_h_ */
X
X/* eof ftp.h */
END_OF_FILE
  if test 1714 -ne `wc -c <'ftp.h'`; then
    echo shar: \"'ftp.h'\" unpacked with wrong size!
  fi
  # end of 'ftp.h'
fi
if test -f 'getpass.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpass.c'\"
else
  echo shar: Extracting \"'getpass.c'\" \(2942 characters\)
  sed "s/^X//" >'getpass.c' <<'END_OF_FILE'
X/* Getpass.c */
X
X/*  $RCSfile: getpass.c,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/05/21 05:44:36 $
X */
X
X#include "sys.h"
X
X#include <signal.h>
X
X#include "util.h"
X#include "cmds.h"
X#include "getpass.h"
X#include "copyright.h"
X
X#ifndef GETPASS
X
X#ifndef sun	/* ...both unnecessary, and conflicting with <termios.h> */
X#include <sys/ioctl.h>
X#endif
X
X#ifdef TERMIOS
X#		include <termios.h>
X#else
X#	ifdef SGTTYB
X#		include <sgtty.h>
X#	else
X#		include <termio.h>
X#	endif
X#endif /* !TERMIOS */
X
X#ifdef STRICT_PROTOS
Xint ioctl(int, int, ...);
X#endif
X
X#endif	/* GETPASS */
X
X
X
X
Xvoid echo(FILE *fp, int on)
X{
X#ifndef GETPASS		/* Otherwise just do nothing which is ok. */
X
X#ifdef TERMIOS
X	static struct termios orig, noecho, *tp;
X#else
X#	ifdef SGTTYB
X	static struct sgttyb orig, noecho, *tp;
X#	else
X	static struct termio orig, noecho, *tp;
X#	endif
X#endif
X	static int state = 0;
X	int fd = fileno(fp);
X	
X	if (!isatty(fd))
X		return;
X
X	if (state == 0) {
X#ifdef TERMIOS
X		if (tcgetattr(fd, &orig) < 0)
X			PERROR("echo", "tcgetattr");
X		noecho = orig;
X		noecho.c_lflag &= ~ECHO;
X#else
X#	ifdef SGTTYB
X		if (ioctl(fd, TIOCGETP, &orig) < 0)
X			PERROR("echo", "ioctl");
X		noecho = orig;
X		noecho.sg_flags &= ~ECHO;
X#	else
X		if (ioctl(fd, TCGETA, &orig) < 0)
X			PERROR("echo", "ioctl");
X		noecho = orig;
X		noecho.c_lflag &= ~ECHO;
X#	endif
X#endif
X		state = 1;
X	}
X	tp = NULL;
X	if (on && state == 2) {
X		/* Turn echo back on. */
X		tp = &orig;
X		state = 1;
X	} else if (!on && state == 1) {
X		/* Turn echo off. */
X		tp = &noecho;
X		state = 2;
X	}
X	if (tp != NULL) {
X#ifdef TERMIOS
X		if (tcsetattr(fd, TCSAFLUSH, tp) < 0)
X			PERROR("echo", "tcsetattr");
X#else
X#	ifdef SGTTYB
X		if (ioctl(fd, TIOCSETP, tp) < 0)
X			PERROR("echo", "ioctl");
X#	else
X		if (ioctl(fd, TCSETA, tp) < 0)
X			PERROR("echo", "ioctl");
X#	endif
X#endif	/* !TERMIOS */
X	}
X
X#endif	/* GETPASS */
X}	/* echo */
X
X
X
X#ifndef GETPASS
X
Xchar *Getpass(char *promptstr)
X{
X	register int ch;
X	register char *p;
X	FILE *fp, *outfp;
X	Sig_t oldintr;
X	static char buf[kMaxPassLen + 1];
X
X	/*
X	 * read and write to /dev/tty if possible; else read from
X	 * stdin and write to stderr.
X	 */
X#if !defined(BOTCHED_FOPEN_RW)
X  	if ((outfp = fp = fopen("/dev/tty", "w+")) == NULL) {
X  		outfp = stderr;
X  		fp = stdin;
X  	}
X#else
X	/* SCO 32v2 botches "w+" open */
X	if ((fp = fopen("/dev/tty", "r")) == NULL)
X		fp = stdin;
X	if ((outfp = fopen("/dev/tty", "w")) == NULL)
X		outfp = stderr;
X#endif
X	oldintr = Signal(SIGINT, SIG_IGN);
X	echo(fp, 0);		/* Turn echoing off. */
X	(void) fputs(promptstr, outfp);
X	(void) rewind(outfp);			/* implied flush */
X	for (p = buf; (ch = getc(fp)) != EOF && ch != '\n';)
X		if (p < buf + kMaxPassLen)
X			*p++ = ch;
X	*p = '\0';
X	(void)write(fileno(outfp), "\n", 1);
X	echo(fp, 1);
X	(void) Signal(SIGINT, oldintr);
X	if (fp != stdin)
X		(void)fclose(fp);
X#if defined(BOTCHED_FOPEN_RW)
X	if (outfp != stderr)
X		(void)fclose(outfp);
X#endif
X	return(buf);
X}	/* Getpass */
X
X#endif /* GETPASS */
X
X/* eof Getpass.c */
END_OF_FILE
  if test 2942 -ne `wc -c <'getpass.c'`; then
    echo shar: \"'getpass.c'\" unpacked with wrong size!
  fi
  # end of 'getpass.c'
fi
if test -f 'glob.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'glob.c'\"
else
  echo shar: Extracting \"'glob.c'\" \(10224 characters\)
  sed "s/^X//" >'glob.c' <<'END_OF_FILE'
X/* glob.c */
X
X/*  $RCSfile: glob.c,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/05/21 05:44:32 $
X */
X
X#include "sys.h"
X
X#include <sys/stat.h>
X
X/* Dir.h.  Try <sys/dir.h> (add -DSYSDIRH) if <dirent.h> doesn't exist. */
X
X#ifndef SYSDIRH
X#   include <dirent.h>
X#else
X#   include <sys/dir.h>
X#endif
X
X#ifdef SCO324
X#   define direct dirent
X#endif
X
X#include <errno.h>
X#include <pwd.h>
X#include "util.h"
X#include "glob.h"
X#include "cmds.h"
X#include "copyright.h"
X
X#ifndef NCARGS
X#	define NCARGS  4096 /* # characters in exec arglist */
X#endif
X
X#define	L_CURLY	'{'
X#define	R_CURLY	'}'
X
X#define	QUOTE 0200
X#define	TRIM 0177
X#define	eq(a,b)		(strcmp(a, b)==0)
X#define	GAVSIZ		(NCARGS/6)
X#define	isdir(d)	((d.st_mode & S_IFMT) == S_IFDIR)
X
Xstatic void ginit(char **agargv);
Xstatic void collect(char *as);
Xstatic void acollect(char *as);
Xstatic void sort(void);
Xstatic void expand(char *as);
Xstatic void matchdir(char *pattern);
Xstatic int execbrc(char *p, char *s);
Xstatic match(char *s, char *p);
Xstatic amatch(char *s, char *p);
X#if UNUSED
Xstatic Gmatch(char *s, char *p);
X#endif
Xstatic void Gcat(char *s1, char *s2);
Xstatic void addpath(char c);
Xstatic void rscan(char **t, int (*f )(char));
Xstatic tglob(char c);
Xstatic char *strspl(char *cp, char *dp);
Xstatic char *strend(char *cp);
X
Xstatic	char **gargv;	/* Pointer to the (stack) arglist */
Xstatic	int gargc;		/* Number args in gargv */
Xstatic	int gnleft;
Xstatic	short gflag;
Xchar	*globerr;
Xchar	*home;			/* you must initialize this elsewhere! */
Xextern	int errno;
X
Xstatic	int globcnt;
X
Xchar	*globchars = "`{[*?";
X
Xstatic	char *gpath, *gpathp, *lastgpathp;
Xstatic	int globbed;
Xstatic	char *entp;
Xstatic	char **sortbas;
X
Xchar **
Xglob(char *v)
X{
X	char agpath[BUFSIZ];
X	char *agargv[GAVSIZ];
X	char *vv[2];
X	vv[0] = v;
X	vv[1] = 0;
X	gflag = (short) 0;
X	rscan(vv, tglob);
X	if (gflag == (short) 0)
X		return (copyblk(vv));
X
X	globerr = 0;
X	gpath = agpath; gpathp = gpath; *gpathp = 0;
X	lastgpathp = &gpath[sizeof agpath - 2];
X	ginit(agargv); globcnt = 0;
X	collect(v);
X	if (globcnt == 0 && (gflag & (short)1)) {
X		blkfree(gargv), gargv = 0;
X		return (0);
X	} else
X		return (gargv = copyblk(gargv));
X}
X
Xstatic
Xvoid ginit(char **agargv)
X{
X	agargv[0] = 0; gargv = agargv; sortbas = agargv; gargc = 0;
X	gnleft = NCARGS - 4;
X}
X
Xstatic
Xvoid collect(char *as)
X{
X	if (eq(as, "{") || eq(as, "{}")) {
X		Gcat(as, "");
X		sort();
X	} else
X		acollect(as);
X}
X
Xstatic
Xvoid acollect(char *as)
X{
X	register int ogargc = gargc;
X
X	gpathp = gpath; *gpathp = 0; globbed = 0;
X	expand(as);
X	if (gargc != ogargc)
X		sort();
X}
X
Xstatic
Xvoid sort(void)
X{
X	register char **p1, **p2, *c;
X	char **Gvp = &gargv[gargc];
X
X	p1 = sortbas;
X	while (p1 < Gvp-1) {
X		p2 = p1;
X		while (++p2 < Gvp)
X			if (strcmp(*p1, *p2) > 0)
X				c = *p1, *p1 = *p2, *p2 = c;
X		p1++;
X	}
X	sortbas = Gvp;
X}
X
Xstatic
Xvoid expand(char *as)
X{
X	register char *cs;
X	register char *sgpathp, *oldcs;
X	struct stat stb;
X
X	sgpathp = gpathp;
X	cs = as;
X	if (*cs == '~' && gpathp == gpath) {
X		addpath('~');
X		for (cs++; letter(*cs) || digit(*cs) || *cs == '-';)
X			addpath(*cs++);
X		if (!*cs || *cs == '/') {
X			if (gpathp != gpath + 1) {
X				*gpathp = 0;
X				if (gethdir(gpath + 1))
X					globerr = "Unknown user name after ~";
X				(void) strcpy(gpath, gpath + 1);
X			} else
X				(void) strcpy(gpath, home);
X			gpathp = strend(gpath);
X		}
X	}
X	while (!any(*cs, globchars)) {
X		if (*cs == 0) {
X			if (!globbed)
X				Gcat(gpath, "");
X			else if (stat(gpath, &stb) >= 0) {
X				Gcat(gpath, "");
X				globcnt++;
X			}
X			goto endit;
X		}
X		addpath(*cs++);
X	}
X	oldcs = cs;
X	while (cs > as && *cs != '/')
X		cs--, gpathp--;
X	if (*cs == '/')
X		cs++, gpathp++;
X	*gpathp = 0;
X	if (*oldcs == L_CURLY) {
X		(void) execbrc(cs, ((char *)0));
X		return;
X	}
X	matchdir(cs);
Xendit:
X	gpathp = sgpathp;
X	*gpathp = 0;
X}
X
Xstatic
Xvoid matchdir(char *pattern)
X{
X	struct stat stb;
X#ifdef SYSDIRH
X	register struct direct *dp;
X#else
X	register struct dirent *dp;
X#endif
X	DIR *dirp;
X
X	dirp = opendir((*gpath ? gpath : "."));
X	if (dirp == NULL) {
X		if (globbed)
X			return;
X		goto patherr2;
X	}
X	if (fstat(dirp->dd_fd, &stb) < 0)
X		goto patherr1;
X	if (!isdir(stb)) {
X		errno = ENOTDIR;
X		goto patherr1;
X	}
X	while ((dp = readdir(dirp)) != NULL) {
X		if (dp->d_ino == 0)
X			continue;
X		if (match(dp->d_name, pattern)) {
X			Gcat(gpath, dp->d_name);
X			globcnt++;
X		}
X	}
X	(void) closedir(dirp);
X	return;
X
Xpatherr1:
X	(void) closedir(dirp);
Xpatherr2:
X	globerr = "Bad directory components";
X}
X
Xstatic
Xint execbrc(char *p, char *s)
X{
X	char restbuf[BUFSIZ + 2];
X	register char *pe, *pm, *pl;
X	int brclev = 0;
X	char *lm, savec, *sgpathp;
X
X	for (lm = restbuf; *p != L_CURLY; *lm++ = *p++)
X		continue;
X	for (pe = ++p; *pe; pe++)
X	switch (*pe) {
X
X	case L_CURLY:
X		brclev++;
X		continue;
X
X	case R_CURLY:
X		if (brclev == 0)
X			goto pend;
X		brclev--;
X		continue;
X
X	case '[':
X		for (pe++; *pe && *pe != ']'; pe++)
X			continue;
X		continue;
X	}
Xpend:
X	brclev = 0;
X	for (pl = pm = p; pm <= pe; pm++)
X	switch (*pm & (QUOTE|TRIM)) {
X
X	case L_CURLY:
X		brclev++;
X		continue;
X
X	case R_CURLY:
X		if (brclev) {
X			brclev--;
X			continue;
X		}
X		goto doit;
X
X	case ','|QUOTE:
X	case ',':
X		if (brclev)
X			continue;
Xdoit:
X		savec = *pm;
X		*pm = 0;
X		(void) strcpy(lm, pl);
X		(void) strcat(restbuf, pe + 1);
X		*pm = savec;
X		if (s == 0) {
X			sgpathp = gpathp;
X			expand(restbuf);
X			gpathp = sgpathp;
X			*gpathp = 0;
X		} else if (amatch(s, restbuf))
X			return (1);
X		sort();
X		pl = pm + 1;
X		if (brclev)
X			return (0);
X		continue;
X
X	case '[':
X		for (pm++; *pm && *pm != ']'; pm++)
X			continue;
X		if (!*pm)
X			pm--;
X		continue;
X	}
X	if (brclev)
X		goto doit;
X	return (0);
X}
X
Xstatic
Xint match(char *s, char *p)
X{
X	register int c;
X	register char *sentp;
X	char sglobbed = globbed;
X
X	if (*s == '.' && *p != '.')
X		return (0);
X	sentp = entp;
X	entp = s;
X	c = amatch(s, p);
X	entp = sentp;
X	globbed = sglobbed;
X	return (c);
X}
X
Xstatic
Xint amatch(char *s, char *p)
X{
X	register int scc;
X	int ok, lc;
X	char *sgpathp;
X	struct stat stb;
X	int c, cc;
X
X	globbed = 1;
X	for (;;) {
X		scc = *s++ & TRIM;
X		switch (c = *p++) {
X
X		case L_CURLY:
X			return (execbrc(p - 1, s - 1));
X
X		case '[':
X			ok = 0;
X			lc = 077777;
X			while ((cc = *p++) != '\0') {
X				if (cc == ']') {
X					if (ok)
X						break;
X					return (0);
X				}
X				if (cc == '-') {
X					if (lc <= scc && scc <= *p++)
X						ok++;
X				} else
X					if (scc == (lc = cc))
X						ok++;
X			}
X			if (cc == 0)
X				if (ok)
X					p--;
X				else
X					return 0;
X			continue;
X
X		case '*':
X			if (!*p)
X				return (1);
X			if (*p == '/') {
X				p++;
X				goto slash;
X			}
X			s--;
X			do {
X				if (amatch(s, p))
X					return (1);
X			} while (*s++);
X			return (0);
X
X		case 0:
X			return (scc == 0);
X
X		default:
X			if (c != scc)
X				return (0);
X			continue;
X
X		case '?':
X			if (scc == 0)
X				return (0);
X			continue;
X
X		case '/':
X			if (scc)
X				return (0);
Xslash:
X			s = entp;
X			sgpathp = gpathp;
X			while (*s)
X				addpath(*s++);
X			addpath('/');
X			if (stat(gpath, &stb) == 0 && isdir(stb))
X				if (*p == 0) {
X					Gcat(gpath, "");
X					globcnt++;
X				} else
X					expand(p);
X			gpathp = sgpathp;
X			*gpathp = 0;
X			return (0);
X		}
X	}
X}
X
X#if UNUSED
Xstatic
XGmatch(char *s, char *p)
X{
X	register int scc;
X	int ok, lc;
X	int c, cc;
X
X	for (;;) {
X		scc = *s++ & TRIM;
X		switch (c = *p++) {
X
X		case '[':
X			ok = 0;
X			lc = 077777;
X			while (cc = *p++) {
X				if (cc == ']') {
X					if (ok)
X						break;
X					return (0);
X				}
X				if (cc == '-') {
X					if (lc <= scc && scc <= *p++)
X						ok++;
X				} else
X					if (scc == (lc = cc))
X						ok++;
X			}
X			if (cc == 0)
X				if (ok)
X					p--;
X				else
X					return 0;
X			continue;
X
X		case '*':
X			if (!*p)
X				return (1);
X			for (s--; *s; s++)
X				if (Gmatch(s, p))
X					return (1);
X			return (0);
X
X		case 0:
X			return (scc == 0);
X
X		default:
X			if ((c & TRIM) != scc)
X				return (0);
X			continue;
X
X		case '?':
X			if (scc == 0)
X				return (0);
X			continue;
X
X		}
X	}
X}
X#endif
X
Xstatic
Xvoid Gcat(char *s1, char *s2)
X{
X	register int len = strlen(s1) + strlen(s2) + 1;
X
X	if (len >= gnleft || gargc >= GAVSIZ - 1)
X		globerr = "Arguments too long";
X	else {
X		gargc++;
X		gnleft -= len;
X		gargv[gargc] = 0;
X		gargv[gargc - 1] = strspl(s1, s2);
X	}
X}
X
Xstatic
Xvoid addpath(char c)
X{
X
X	if (gpathp >= lastgpathp)
X		globerr = "Pathname too long";
X	else {
X		*gpathp++ = c;
X		*gpathp = 0;
X	}
X}
X
Xstatic
Xvoid rscan(char **t, int (*f )(char))
X{
X	register char *p, c;
X
X	while ((p = *t++) != 0) {
X		if (f == tglob)
X			if (*p == '~')
X				gflag |= (short) 2;
X			else if (eq(p, "{") || eq(p, "{}"))
X				continue;
X		while ((c = *p++) != '\0')
X			(*f)(c);
X	}
X}
X/*
Xstatic
Xscan(t, f)
X	register char **t;
X	int (*f)(char);
X{
X	register char *p, c;
X
X	while (p = *t++)
X		while (c = *p)
X			*p++ = (*f)(c);
X} */
X
Xstatic
Xint tglob(char c)
X{
X
X	if (any(c, globchars))
X		gflag |= (c == L_CURLY ? (short)2 : (short)1);
X	return (c);
X}
X/*
Xstatic
Xtrim(c)
X	char c;
X{
X
X	return (c & TRIM);
X} */
X
X
Xint letter(char c)
X{
X	return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_');
X}
X
Xint digit(char c)
X{
X	return (c >= '0' && c <= '9');
X}
X
Xint any(int c, char *s)
X{
X	while (*s)
X		if (*s++ == c)
X			return(1);
X	return(0);
X}
X
Xint blklen(char **av)
X{
X	register int i = 0;
X
X	while (*av++)
X		i++;
X	return (i);
X}
X
Xchar **
Xblkcpy(char **oav, char **bv)
X{
X	register char **av = oav;
X
X	while ((*av++ = *bv++) != 0)
X		continue;
X	return (oav);
X}
X
Xvoid blkfree(char **av0)
X{
X	register char **av = av0;
X
X	while (*av)
X		free(*av++);
X}
X
Xstatic
Xchar *
Xstrspl(char *cp, char *dp)
X{
X	register char *ep = (char *) malloc((size_t)(strlen(cp) + strlen(dp) + 1L));
X
X	if (ep == (char *)0)
X		fatal("Out of memory");
X	(void) strcpy(ep, cp);
X	(void) strcat(ep, dp);
X	return (ep);
X}
X
Xchar **
Xcopyblk(char **v)
X{
X	register char **nv = (char **)malloc((size_t)((blklen(v) + 1) *
X						sizeof(char **)));
X	if (nv == (char **)0)
X		fatal("Out of memory");
X
X	return (blkcpy(nv, v));
X}
X
Xstatic
Xchar *
Xstrend(char *cp)
X{
X	while (*cp)
X		cp++;
X	return (cp);
X}
X
X/*
X * Extract a home directory from the password file
X * The argument points to a buffer where the name of the
X * user whose home directory is sought is currently.
X * We write the home directory of the user back there.
X */
Xint gethdir(char *home_dir)
X{
X	register struct passwd *pp = getpwnam(home_dir);
X
X	if (pp == 0)
X		return (1);
X	(void) strcpy(home_dir, pp->pw_dir);
X	return (0);
X}	/* gethdir */
X
X/* eof glob.c */
END_OF_FILE
  if test 10224 -ne `wc -c <'glob.c'`; then
    echo shar: \"'glob.c'\" unpacked with wrong size!
  fi
  # end of 'glob.c'
fi
if test -f 'sys.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sys.h'\"
else
  echo shar: Extracting \"'sys.h'\" \(9960 characters\)
  sed "s/^X//" >'sys.h' <<'END_OF_FILE'
X/* Sys.h
X * See the README for details.
X */
X
X/*  $RCSfile: sys.h,v $
X *  $Revision: 14020.13 $
X *  $Date: 93/06/21 06:42:11 $
X */
X
X#ifdef SVR4
X#	define System "System V.4"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	define VOID void
X#	ifndef HERROR
X#		define HERROR 1
X#	endif
X#	ifdef TERMH
X#		define TERMH 1
X#	endif
X#	define Gettimeofday gettimeofday
X#endif  /* SVR4 */
X
X#ifdef __sun
X#	ifndef sun
X#		define sun 1
X#	endif
X#endif
X
X#ifdef sun
X#	if !defined(__GNUC__) && !defined(__STDC__) && !defined(SunOverride)
X	^^^ "You need to use an ANSI C compiler.  Try using gcc or acc." ^^^
X#	endif
X#	define System "SunOS"
X#	ifndef RINDEX
X#		define RINDEX 1
X#	endif
X#	ifndef TERMIOS
X#		define TERMIOS 1
X#	endif
X#	ifndef HAS_DOMAINNAME
X#		define HAS_DOMAINNAME 1
X#	endif
X#endif /* sun */
X
X#ifdef __sgi
X#	ifndef sgi
X#		define sgi 1
X#	endif
X#endif
X
X#ifdef sgi
X#	define System "IRIX"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	ifndef HERROR
X#		define HERROR 1
X#	endif
X#	ifndef U_WAIT
X#		define U_WAIT 1
X#	endif
X#	ifndef STRICT_PROTOS
X#		define STRICT_PROTOS 1
X#	endif
X#	ifndef TERMIOS
X#		define TERMIOS 1
X#	endif
X#endif /* sgi */
X
X#ifdef	AIX
X#	define System "AIX 2.2.1"
X#	define BSD_INCLUDES
X#	define SYSV
X#	define NO_STDLIB
X#	define NO_UTIME_H
X#	define NO_STRFTIME
X#	define NO_STRSTR
X#	define NO_MKTIME
X#endif	/* AIX */
X
X#ifdef _AIX
X#	define System "AIX 3.x"
X#	define SYSSELECTH 1
X#endif	/* _AIX */
X
X#ifdef SCOXNX
X#	define System "SCO Xenix"
X#	define LAI_TCP
X#	define NO_UTIMEH
X#	define NO_MKTIME
X#	define NO_STRFTIME
X#	define NO_STRSTR
X#	define NO_RENAME
X#	define LINGER   /* else SCO bug causes incomplete transfers */
X#	define SYSV 1
X#endif	/* SCOXNX */
X
X#ifdef SCO322
X#	define System "SCO Unix 3.2v2"
X#	define BOTCHED_FOPEN_RW
X#	define NO_RENAME	/* it exists, but it corrupts filesystems */
X#	define BROKEN_MEMCPY 1
X#	define SYSV 1
X#endif	/* SCO322 */
X
X#ifdef SCO324
X#	define System "SCO Unix 3.2v4"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	ifndef BROKEN_MEMCPY
X#		define BROKEN_MEMCPY 1
X#	endif
X#endif	/* SCO324 */
X
X#ifdef linux
X#	define System "Linux"
X/* Anyone want to fill the rest in? */
X#endif
X
X#ifdef ISC
X#	define System "Interactive Unix"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	ifndef BROKEN_MEMCPY
X#		define BROKEN_MEMCPY 1
X#	endif
X#	ifndef NET_ERRNO_H
X#		define NET_ERRNO_H 1
X#	endif
X#endif  /* ISC */
X
X#ifdef aux
X#	define System "A/UX"
X#	ifndef BROKEN_MEMCPY
X#		define BROKEN_MEMCPY 1
X#	endif
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#endif
X
X#ifdef NeXT
X#	define System "NeXTStep"
X#	ifndef RINDEX
X#		define RINDEX 1
X#	endif
X#	ifndef BSD
X#		define BSD 1
X#	endif
X#	ifndef NO_UNISTDH
X#		define NO_UNISTDH 1
X#	endif
X#	ifndef NO_UTIMEH
X#		define NO_UTIMEH
X#	endif
X#endif
X
X#ifdef pyr
X#	define System "OSx"
X#	ifndef BSD
X#		define BSD 1
X#	endif
X#	ifndef SGTTYB
X#		define SGTTYB 1
X#	endif
X#	ifndef NO_STDLIBH
X#		define NO_STDLIBH 1
X#	endif
Xextern int errno;
X#endif	/* pyr */
X
X#ifdef DYNIXPTX
X#	define System "Dynix/PTX"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	ifndef TRY_NOREPLY
X#		define TRY_NOREPLY 1
X#	endif
X#	define gettimeofday(a, b) get_process_stats(a, getpid(), 0, 0)
X#endif  /* DYNIXPTX */
X
X#ifdef DYNIX
X#	define System "Dynix"
X#	ifndef BSD
X#		define BSD 1
X#	endif
X#	ifndef SGTTYB
X#		define SGTTYB 1
X#	endif
X#	ifndef NO_UTIMEH
X#		define NO_UTIMEH 1
X#	endif
X#	ifndef NO_STDLIBH
X#		define NO_STDLIBH 1
X#	endif
X#	ifndef NO_VARARGS
X#		define NO_VARARGS 1
X#	endif
X#endif	/* DYNIX */
X
X#ifdef ultrix
X#	define System "Ultrix"
X#	ifndef BSD
X#		define BSD 1
X#	endif
X#	ifndef __GNUC__
X#		ifndef NO_CONST
X#			define NO_CONST 1
X#		endif
X#	endif
X#endif	/* ultrix */
X
X#ifdef __hpux
X#	ifndef HPUX
X#		define HPUX 1
X#	endif
X#	define Select(a,b,c,d,e) select((a), (int *)(b), (c), (d), (e))
X#endif
X
X#ifdef HPUX 
X#	define System "HP-UX"
X#	ifndef _HPUX_SOURCE
X#		define _HPUX_SOURCE 1
X#	endif
X#	ifndef GETCWDSIZET
X#		define GETCWDSIZET 1
X#	endif
X#	define SYSV 1
X#endif	/* HPUX */
X
X#ifdef SINIX
X#	define System "SINIX"
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X/* You may need to add -lresolv, -lport, -lcurses to MORELIBS in Makefile. */
X#endif
X
X#ifdef BULL          /* added 23nov92 for Bull DPX/2 */
X#	define _POSIX_SOURCE
X#	define _XOPEN_SOURCE
X#	define _BULL_SOURCE
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#	define bull
X#	define System "Bull DPX/2 BOS"
X#	define SYSSELECTH
X#endif  /* BULL */   /* added 23nov92 for Bull DPX/2 */
X
X#ifdef __dgux
X#     ifndef DGUX
X#             define DGUX 1
X#     endif
X#endif
X
X#ifdef DGUX
X#     ifndef _DGUX_SOURCE
X#             define _DGUX_SOURCE
X#     endif
X#     define GETCWDSIZET 1
X#     define BAD_INETADDR 1
X#     define SYSV 1
X#     define System "DG/UX"
X#endif  /* DGUX */
X
X#ifdef apollo
X#	ifndef BSD
X#		define BSD 43
X#	endif
X#	define SIG_PARAMS (int sig, ...)
X#	define NO_UTIMEH 1
X#	define System "Apollo"
X#endif
X
X#ifdef __Besta__
X#       define SYSV 1
X#       define SYSSELECTH 1
X#       define NO_UNISTDH 1
X#       define NO_STDLIBH 1
X#       define NO_UTIMEH 1
X#	ifndef BROKEN_MEMCPY
X#		define BROKEN_MEMCPY 1
X#	endif
X#       include <sys/types.h>
X#endif
X
X/* -------------------------------------------------------------------- */
X
X#ifdef _SYSV
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#endif
X
X#ifdef USG
X#	ifndef SYSV
X#		define SYSV 1
X#	endif
X#endif
X
X#ifdef _BSD
X#	ifndef BSD
X#		define BSD 1
X#	endif
X#endif
X
X#ifdef SYSV
X#	ifndef RINDEX
X#		define RINDEX 1
X#	endif
X#	define bcopy(s,d,l) memcpy((d),(s),(l))
X#	define bzero(cp,l) memset((cp),0,(l))
X#	ifndef HAS_GETCWD
X#		define HAS_GETCWD 1
X#	endif
X#endif
X
X#ifdef __386BSD__
X#	define TERMIOS
X#	ifndef BSD
X#		define BSD
X#	endif
X#endif
X
X#ifdef BSD
X#	ifndef __386BSD__
X#		ifndef SYSDIRH
X#			define SYSDIRH 1
X#		endif
X#		ifndef SGTTYB
X#			define SGTTYB
X#		endif
X#	endif
X#	ifndef SGTTYB
X#		define SGTTYB
X#	endif
X#	ifndef RINDEX
X#		define RINDEX 1
X#	endif
X#endif
X
X/*
X * Generic pointer type, e.g. as returned by malloc().
X */
X#ifndef PTRTYPE
X#	define PTRTYPE void
X#endif
X
X#ifndef Free
X#	define Free(a) free((PTRTYPE *)(a))
X#endif
X
X/*
X * Some systems besides System V don't use rindex/index (like SunOS).
X * Add -DRINDEX to your SDEFS line if you need to.
X */
X#ifdef RINDEX
X	/* or #include <strings.h> if you have it. */
X#	define rindex strrchr
X#	define index strchr
X#endif /* RINDEX */
X
X#ifdef SOCKS
X#define Getsockname(d,a,l) Rgetsockname((d), (struct sockaddr *)(a), (l))
X#else
X#ifdef SYSV
X#	define Getsockname(d,a,l) getsockname((d), (void *)(a), (l))
X#else
X#	define Getsockname(d,a,l) getsockname((d), (struct sockaddr *)(a), (l))
X#endif
X#endif
X
X#ifndef Select
X#	define Select(a,b,c,d,e) select((a), (b), (c), (d), (e))
X#endif
X
X#ifndef Connect
X#ifndef SVR4
X#	define Connect(a,b,c) (connect((a), (struct sockaddr *)(b), (int)(c)))
X#	define Bind(a,b,c) (bind((a), (struct sockaddr *)(b), (int)(c)))
X#	define Accept(a,b,c) (accept((a), (struct sockaddr *)(b), (int *)(c)))
X#else  /* SVR4 */
X#	define Connect(a,b,c) (connect((a), (addr_t)(b), (int)(c)))
X#	define Bind(a,b,c) (bind((a), (caddr_t)(b), (int)(c)))
X#	define Accept(a,b,c) (accept((a), (caddr_t)(b), (int *)(c)))
X#endif	/* SVR4 */
X#endif	/* Connect */
X
X#ifndef Gettimeofday
X#	define Gettimeofday(a) gettimeofday(a, (struct timezone *)0)
X#endif /* Gettimeofday */
X
X#ifdef GETPASS
X#	define Getpass getpass
X#endif
X
X/* Enable connections through firewall gateways */
X#ifndef GATEWAY
X#	define GATEWAY 1
X#endif
X
X#ifdef _POSIX_SOURCE
X#	define TERMIOS
X#endif
X
X/* Include frequently used headers: */
X
X#include <sys/types.h>
X
X#include <sys/param.h>
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/socket.h>
X
X#include <sys/time.h>
X#include <time.h>
X
X#ifndef NO_STDLIBH
X#	include <stdlib.h>
X#else
Xextern PTRTYPE *malloc(size_t);
Xextern PTRTYPE *calloc(size_t, size_t);
Xextern PTRTYPE *malloc(size_t);
Xextern void	free(PTRTYPE *);
Xextern PTRTYPE *realloc(PTRTYPE *, size_t);
Xextern void	exit(int);
X
X#ifdef NO_CONST
Xextern char *getenv(char *);
Xextern int atoi(char *);
X#else
Xextern char *getenv(const char *);
Xextern int atoi(const char *);
X#endif
X
X#endif	/* NO_STDLIBH */
X
X#ifndef NO_UNISTDH
X#	include <unistd.h>
X#else
Xchar *getlogin (void);
X#	ifdef NO_CONST
Xextern char *getenv(char *);
X#	else
Xextern char *getenv(const char *);
X#	endif
X#endif	/* NO_UNISTDH */
X
X#ifdef NO_STD_PROTOS
Xextern	int     _filbuf(FILE *);
Xextern	int     _flsbuf(int, FILE *);
Xextern	int     fflush(FILE *);
Xextern	int     fgetc(FILE *);
Xextern	int     fprintf(FILE *, char *, ...);
Xextern	int     fputc(int, FILE *);
Xextern	int     fputs(char *, FILE *);
Xextern	int     fclose(FILE *);
Xextern	int     pclose(FILE *);
Xextern	void    perror(char *);
Xextern	int     printf(char *, ...);
Xextern	int     rewind(FILE *);
Xextern	int     sscanf(char *, char *, ...);
Xextern	int     vfprintf(FILE *, char *, char *);
X
Xextern	char *  mktemp(char *);
Xextern	int     rename(char *, char *);
X
Xextern	int     gettimeofday(struct timeval *, struct timezone *);
Xextern	time_t  mktime(struct tm *);
Xextern	int     strftime(char *, int, char *, struct tm *);
Xextern	time_t  time(time_t *);
X
Xextern	int     tolower(int);
Xextern	int     toupper(int);
X
X#ifndef bcopy
Xextern	void    bcopy(char *, char *, size_t);
X#endif
X#ifndef bzero
Xextern	void    bzero(char *, size_t);
X#endif
X
X#ifdef SOCKS 
Xextern	int     Raccept(int, struct sockaddr *, int *);
Xextern	int     Rbind(int, struct sockaddr *, int, unsigned long);
Xextern	int     Rconnect(int, struct sockaddr *, int);
Xextern	int     Rlisten(int, int);
Xextern	int     Rgetsockname(int, struct sockaddr *, int *);
X#else
Xextern	int     accept(int, struct sockaddr *, int *);
Xextern	int     bind(int, struct sockaddr *, int);
Xextern	int     connect(int, struct sockaddr *, int);
Xextern	int     listen(int, int);
Xextern	int     getsockname(int, struct sockaddr *, int *);
X#endif
Xextern	int     gethostname(char *, int), getdomainname(char *, int);
Xextern	int     select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
Xextern	int     send(int, char *, int, int);
Xextern	int     setsockopt(int, int, int, char *, int);
Xextern	int     shutdown(int, int);
Xextern	int     socket(int, int, int);
X#endif	/* NO_STD_PROTOS */
X
X/* eof sys.h */
END_OF_FILE
  if test 9960 -ne `wc -c <'sys.h'`; then
    echo shar: \"'sys.h'\" unpacked with wrong size!
  fi
  # end of 'sys.h'
fi
if test -f 'tips.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tips.c'\"
else
  echo shar: Extracting \"'tips.c'\" \(5221 characters\)
  sed "s/^X//" >'tips.c' <<'END_OF_FILE'
X/* tips.c */
X
X/*  $RCSfile: tips.c,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/05/21 05:44:39 $
X */
X
X#include "sys.h"
X
X#ifndef NO_TIPS
X
X#include "util.h"
X
X/* Make sure that the indentations are spaces, not tabs.
X * Try newform -i-4 < tips.c > tips.c.new
X *
X * Always add new tips right above the last one.
X */
X
Xstatic char *tiplist[] = {
X    "Have you tried typing 'open' by itself lately?",
X
X    "If you don't want a .ncrecent file in your home directory, put the \n\
X     command '#unset recent-list' in your .ncftprc file.",
X
X    "pseudo-filename-completion is supported in some commands.  To use it,\n\
X     use a wildcard expression that will match exactly one file.  I.e., if you\n\
X     want to fetch obnoxiouslylongfilename.zip, try 'get obn*.zip.'  Note that\n\
X     you can't use the cd command with this feature (yet).",
X
X    "You don't need to type the exact site name with open.  If a site is in\n\
X     your .ncftprc or the recent-file (.ncrecent), just type a unique\n\
X     abbreviation (substring really).   I.e. 'open wuar' if you have the site\n\
X     wuarchive.wustl.edu in your rc or recent-file.",
X
X    "You can put set commands in your .ncftprc, by adding lines such\n\
X     as '#set local-dir /usr/tmp' to the file, which will be run at startup.",
X
X    "Use the .ncftprc file to set variables at startup and to add sites that \n\
X     need init macros.\n\
X     Sample .ncftprc:\n\
X     #set pager \"less -M\"\n\
X     \n\
X     machine wuarchive.wustl.edu\n\
X         macdef init\n\
X         cd /pub\n\
X         get README\n\
X         dir\n\
X         (blank line to end macro)",
X    
X    "If you want to keep your .netrc's for ftp and ncftp separate, name\n\
X     ncftp's rc to .ncftprc.",
X
X    "Type 'open' by itself to get a list of the sites in your recent-file and\n\
X     your .ncftprc.  You can then supply '#5' at the prompt, or use 'open #5'\n\
X     later.",
X
X    "Colon-mode is a quick way to get a file from your shell.  Try something\n\
X     like 'ncftp wuarchive.wustl.edu:/pub/README.'",
X
X    "The open command accepts several flags.  Do a 'help open' for details.",
X
X    "Sometimes a directory listing is several screens long and you won't\n\
X     remember the thing you wanted.  Use the 'predir' command to re-view the\n\
X     listing.  The program keeps the copy locally, so you won't have to wait\n\
X     for the remote server to re-send it to you.",
X
X    "Use the 'page' (or 'more') command to view a remote file with your pager.",
X
X    "ncftp may be keeping detailed information on everything you transfer.\n\
X     Run the 'version' command and if you see SYSLOG, your actions are being\n\
X     recorded on the system log.",
X
X    "Try the 'redir' command to re-display the last directory listing (ls,\n\
X     dir, ls -lrt, etc).  'predir' does the same, only with your pager.",
X
X    "This program is pronounced Nik-F-T-P.  NCEMRSoft is Nik'-mer-soft.",
X
X    "Never pick Nebraska to win a big game.",
X
X#ifdef GETLINE
X    "NcFTP was compiled with the Getline command-line/history editor! (by\n\
X     Chris Thewalt <thewalt@ce.berkeley.edu>).  To activate it, use the up\n\
X     and down arrows to scroll through the history, and/or use EMACS-style\n\
X     commands to edit the line.",
X#endif
X
X#ifdef READLINE
X    "NcFTP was compiled with the GNU Readline command-line/history editor!\n\
X     To activate it, use the up & down arrows to scroll through the history,\n\
X     and/or use EMACS-style (or maybe VI-style) commands to edit the line.",
X#endif
X
X    "You can get the newest version of NcFTP from cse.unl.edu, in the\n\
X     /pub/mgleason directory.",
X
X    "The type of progress-meter that will be used depends if the remote host\n\
X     supports the SIZE command, and whether your terminal is capable of ANSI\n\
X     escape codes.",
X
X    "To report a bug, mail your message to mgleason@cse.unl.edu.  Include the\n\
X     output of the 'version' command in your message.  An easy way to do that\n\
X     is to compose your message, then do a 'ncftp -H >> msg.'",
X
X    "Don't put a site in your .ncftprc unless you want an 'init' macro.  The \n\
X     recent-file saves sites with the last directory you were in, unlike \n\
X     the rc file, while still letting you use sitename abbreviations.",
X
X    "Sick and tired of these tips?  Put '#unset tips' in your .ncftprc."
X};
X
X/* Not another dinky header, por favor. */
X#define NTIPS ((int) (sizeof(tiplist) / sizeof(char *)))
Xvoid PrintTip(void);
Xextern int fromatty, debug;
X
Xint tips = 1;
X#endif  /* NO_TIPS */
X
Xvoid PrintTip(void)
X{
X#ifndef NO_TIPS
X    int cheap_rn, i, tn;
X    string str;
X
X    if (tips && fromatty) {
X        cheap_rn = (int) getpid() % NTIPS;
X        if (debug) {
X            (void) printf("pid: %d;  ntips: %d\n", getpid(), NTIPS);
X            (void) Gets("*** Tip# (-1 == all): ", str, sizeof(str));
X            tn = atoi(str) - 1;
X			if (tn == -1)
X				tn = 0;
X            if (tn < -1)
X                for(i=0; i<NTIPS; i++)
X                    (void) printf("Tip: %s\n", tiplist[i]);
X            else if (tn < NTIPS)
X                (void) printf("Tip: %s\n", tiplist[tn]);
X        } else
X            (void) printf("Tip: %s\n", tiplist[cheap_rn]);
X    }
X#endif  /* NO_TIPS */
X}   /* PrintTip */
X
X/* tips.c */
END_OF_FILE
  if test 5221 -ne `wc -c <'tips.c'`; then
    echo shar: \"'tips.c'\" unpacked with wrong size!
  fi
  # end of 'tips.c'
fi
if test -f 'util.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util.h'\"
else
  echo shar: Extracting \"'util.h'\" \(2304 characters\)
  sed "s/^X//" >'util.h' <<'END_OF_FILE'
X/* Util.h */
X
X#ifndef _util_h_
X#define _util_h_
X
X/*  $RCSfile: util.h,v $
X *  $Revision: 14020.12 $
X *  $Date: 93/07/09 11:32:49 $
X */
X
Xtypedef char string[128], str32[32], longstring[512];
Xtypedef char Hostname[64];
X
X/* For Perror. */
X#ifdef DB_ERRS
X#	ifdef __LINE__
X#		define PERROR(p,e) Perror(p, __LINE__, e)
X		void Perror(char *, int, char *);
X#	else
X#		define PERROR(p,e) Perror(p, e)
X		void Perror(char *, char *);
X#	endif
X#else
X#	define PERROR(p,e) Perror(e)
X	void Perror(char *);
X#endif
X
X#ifdef NO_VARARGS
X#	define dbprintf if (debug) (void) printf
X#else
X#	ifndef DB_STREAM
X#		define DB_STREAM stdout
X#	endif
X	void dbprintf(char *fmt, ...);
X#endif
X
X/* For 'Getopt.' */
X#define BADCH   ((int)'?')
X#define EMSG    ""
X
X/* Handy macros. */
X#define Strncpy(d,s) _Strncpy((char *) (d), (char *) (s), (size_t) sizeof(d))
X#define Strncat(d,s) _Strncat((char *) (d), (char *) (s), (size_t) sizeof(d))
X#define FGets(a,b) fgets((a), (int) (sizeof(a) - 2), (b))
X
X#ifndef NO_CONST
Xtypedef int (*cmp_t)(const void *, const void *);
X#else
Xtypedef int (*cmp_t)(void *, void *);
X#endif
X
X#define QSort(base,n,sz,cmp) \
X	qsort(base, (size_t)(n), (size_t)(sz), (cmp_t)(cmp))
X
X#ifndef SIG_PARAMS
X#define SIG_PARAMS (int sig)
X#endif
Xtypedef void (*Sig_t) SIG_PARAMS;
X
X#define Signal(a,proc) signal((a), (Sig_t)(proc))
X
X/* Quiets warnings */
X#if defined(sun)	/* ...actually, any UNIX system */
X# if defined(__GNUC__)
X#  undef  SIG_DFL
X#  undef  SIG_IGN
X#  define SIG_DFL	(Sig_t)0
X#  define SIG_IGN	(Sig_t)1
X# endif
X#endif
X
X/* Protos. */
Xchar *_Strncat(char *dst, char *src, register size_t n);
Xchar *_Strncpy(char *dst, char *src, register size_t n);
Xchar *NewString(char *oldstr);
Xchar **re_makeargv(char *promptstr, int *argc);
Xchar *onoff(int);
Xint StrToBool(char *s);
Xint confirm(char *cmd, char *file);
Xvoid fatal(char *msg);
Xchar *get_cwd(char *buf, int size);
Xint tmp_name(char *str);
Xint Getopt(int argc, char **argv, char *opstring);
Xvoid Getopt_Reset(void);
Xchar *Gets(char *promptstr, char *sline, size_t size);
Xsize_t RemoveTrailingNewline(char *cp, int *stripped);
Xunsigned long UnLSDate(char *dstr);
Xchar *Strpcpy(char *dst, char *src);
Xint UserLoggedIn(void);
Xchar *LocalPath(char *path);
Xchar *LocalDotPath(char *path);
X
X#ifdef NO_STRSTR
Xchar *strstr(char *s1, char *s2);
X#endif
X
X#endif	/* _util_h_ */
END_OF_FILE
  if test 2304 -ne `wc -c <'util.h'`; then
    echo shar: \"'util.h'\" unpacked with wrong size!
  fi
  # end of 'util.h'
fi
if test -f 'v2_Note' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'v2_Note'\"
else
  echo shar: Extracting \"'v2_Note'\" \(2732 characters\)
  sed "s/^X//" >'v2_Note' <<'END_OF_FILE'
XVersion 1.6 of NcFTP is an interim release.  Version 2.0 is much cooler,
Xbut it wasn't ready to go by my self-imposed deadline of September 1, 1993.
XThe reason for that deadline is that my senior year will be getting under
Xway, and I don't want to work on the program during that period.  Last year
XI spent too much time on NcFTP and other projects, and not enough time on
Xstudies.  As a result, my grades slipped a bit.  Therefore I will be
Xstudying more and programming, reading news, and reading email less.  If
Xyou send me email, I _will_ read it, but it may take me awhile to get to it,
Xand I may not answer.  Please don't be offended.  I really regret having
Xto release code that is such a mess.  I should have wrote the code from
Xscratch, rather than built it upon the original BSD code (which is a mess
Xitself!).
X
XThis version is based on 1.5, which in turn was based on the betas of 1.4.
X1.4 was almost finished when I decided to add some significant features, and
Xclean up the code so it is better organized and easier to read. That version
Xis called 2.0, and isn't finished yet. The innards are totally different
Xfrom the 1.4 family, so patches to 1.6 won't work at all on 2.0. During the
Xprocess of adding stuff and cleaning up, a couple of bugs creeped in that
Xwill take time to resolve. Maybe I can work on it during Christmas break.
X
XI apologize in advance for bugs I fixed in 2.0 but forgot to re-fix
Xin 1.6 (I think I got'em all, though).
X
XHere is a list of things that are in the 2.0 code but not this version:
X
X* Easy-to-read, better organized, commented code.
X* Using my own "style guide," so source is coded uniformly.
X* Unlimited global macros.  These are really nice!  They take arguments,
X  so you can make mini-scripts.  The macros can be typed as if they
X  were commands; no more $macroname crap.
X* No-longer using .netrc and it's format.  This was necessary for the
X  global macros anyway, and it allowed me to add some other features,
X  like host aliases.  Old .netrc's won't work.  Sorry!
X* Improved command line parser, that lets any command use > and |, so
X  it behaves like a real shell command line (almost).
X* Improved 'redir' that works automatically, can reformat listings with
X  different ls flags, all without refetching it over the network.  It
X  will also facilitate remote globbing... AND remote filename completion!
X* Many little things I can't begin to list.
X
XKeep that in mind if you want to make a feature enhancement.  I'm telling
Xyou this now so you don't spend your time programming something that is
Xalready done for the 2.0 release.  Also note that patches for 1.6 will
Xhave to be re-coded for 2.0.  (The gist is that you should wait until
X2.0 is done before doing anything major).
END_OF_FILE
  if test 2732 -ne `wc -c <'v2_Note'`; then
    echo shar: \"'v2_Note'\" unpacked with wrong size!
  fi
  # end of 'v2_Note'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
