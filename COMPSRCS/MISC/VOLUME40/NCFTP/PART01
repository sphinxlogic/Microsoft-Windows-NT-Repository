Newsgroups: comp.sources.misc
From: mgleason@cse.unl.edu (Mike Gleason)
Subject: v40i076:  ncftp - Alternative User Interface for FTP, v1.6, Part01/06
Message-ID: <csm-v40i076=ncftp.172127@sparky.Sterling.COM>
X-Md4-Signature: fc310f282b2429355117ad2b56e180f7
Keywords: ncftp
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: NCEMRSoft
Date: Tue, 2 Nov 1993 23:21:57 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mgleason@cse.unl.edu (Mike Gleason)
Posting-number: Volume 40, Issue 76
Archive-name: ncftp/part01
Environment: UNIX, ANSI-C, !SVR4
Supersedes: ncftp: Volume 39, Issue 53-57

NcFTP - Alternative user interface for FTP
Version 1.6.0 by Mike Gleason, NCEMRSoft.

I used to list the features of ncftp in this blurb, but there are just
too many to list.  Even if you only ftp occasionally, it is worth your
time to install ncftp (or atleast bug your sysadmin to).  If you won't take
my word for it, just ask around, or extract this archive and read the
man page.

1.6.0 is an "evolutionary" upgrade, which consolidates all the previous
patches and adds a little.  1.6 and 1.5 are "interim" versions between
2.0 which has been suspended indefinitely due to time constraints.

Major changes since 1.5.6:

* Built-in support for the "term" package, used by Linux, etc.

* SCO Xenix, Besta, AIX 2, AIX 3, Dynix/PTX support

* Better ISC Unix support.

* Several bug fixes.

Major changes since 1.0.2:

* Supports the Getline (input-edit) and GNU Readline command-line
  editing and history libraries.

* Supports the Socks firewall library, and another firewall gateway
  implementation.

* Terrific new "recent-sites" file that automatically saves the
  sites you call;  when you open a site in the recent-sites file
  (of course you can abbreviate the names), you start in the
  same directory you were in last time.

* Improved on-line help, and tips on how to use the program better
  are printed each time you run the program.

* Rewritten man page.

* Faster ascii transfers.

* Typing 'open' by itself lists all the sites the program knows
  about (the ones in your .netrc and the recent-sites list) so
  you can just pick one.

* Enhanced colon-mode, that can dump a file to stdout (ftpcat mode)
  or to a pager.  (i.e. ncftp -c wu:/README >/dev/null).

* You can choose whether an open is anonymous by default (like it
  had always been) or a user login by default by setting a new
  program variable.

* Bugs fixed.

Read the enclosed file, v2_Notes, which explains why I won't be
able to work on the nearly finished, and much improved v2.0.
---------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README cmds.c
# Wrapped by kent@sparky on Mon Nov  1 16:19:16 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 6)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(15291 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XIf you are a novice user, and don't know how to compile things, try
Xcontacting your local guru first (get them to do it for you :-).  Please
Xunderstand that I don't have time to walk newbies through the whole
Xinstallation procedure.
X
XOne of these months, I will write a Configure script that does all this for
Xyou. I just don't have time to learn another language (dist-3.0) just to
Xwrite the script! Perhaps for 2.0.
X
X1. READ this entire file.  Part A, below, tells what to do if you want to
X   use NcFTP with a command-line editor.  Part B tells you how to configure
X   the Makefile to compile the program for your system.  Part C tells you
X   how to configure NcFTP's optional features.  Part D tells you how to
X   contact me if you want to report a bug or submit new code to the
X   program.
X
X2. EDIT the Makefile, making any necessary changes described in parts
X   A, B, or C.  Don't forget to read the directions in the Makefile,
X   so you don't forget any needed libraries, etcetera.
X
X3. You can also change the program's default behavior by editing defaults.h.
X   99% of the time you don't need to do this, so you can skip this step.
X
XIf you have problems, you can mail me, but please try your best to install
Xit without my help.  I'm quite tired of responding to lazy SunOS users
Xbecause they didn't bother reading the directions so that they would have
Xknown that they needed to use GCC.  
X
XI _do_ want to hear from you if you have comments or bug reports/fixes.  I
Xwould also like to hear from you if you had a system that wasn't covered
Xin sys.h, so I can add an entry for other users of your system.
X
XThe latest version of ncftp is available in the directory:
X	cse.unl.edu:/pub/mgleason
XThis machine is heavily used by students and faculty alike, so please
Xdo not call during working hours (9AM - 5PM American Central time).  In fact,
XI have a cron entry that changes all the file permissions to public
Xunreadable during that period, so you won't be able to download anyway.
X
XI am grateful to Shari Deiana and the University of Nebraska for making this
Xpossible!
X
X
XPart A.  Installing with a command line editor:
X----------------------------------------------
X
XAs of this release, GNU Readline and Chris Thewalt's Getline command-line
Xediting and history facilities are supported.  Neither are included with the
Xncftp sources.  You can find Getline at:
X  ce.berkeley.edu:/pub/thewalt/getline.tar.Z  (note: use 'ls', not 'dir!')
Xand Readline is in the directory:
X  prep.ai.mit.edu:/pub/gnu
X
XTo install Readline, you will need to know where libreadline.a and the
Xheader <readline/readline.h> are.  You will need to link libreadline.a and
Xlibcurses.a (or libtermcap.a) with ncftp (see the Makefile).  Good luck on
Xtrying to compile it.  It is not an easy thing to do!  In the Makefile, you
Xwill need to add -DREADLINE to PDEFS, add -lreadline -lcurses to LIBS, and
Xedit the HDRDIRS and LIBDIRS lines.  This stuff is already in the Makefile,
Xso you can just uncomment it.
X
XTo install Getline, you need to know where libgetline.a and it's header
X(getline.h) are.  In the Makefile, you'll need to add -lgetline to LIBS and
Xedit the HDRDIRS and LIBDIRS lines.  This stuff is already in the Makefile,
Xso you can just uncomment it.
X
XDO NOT bug me if you can't figure out how to compile Getline or Readline.
XContact their respective authors instead.  It is not essential that you use
Xthem.
X
X
XPart B.  System Dependencies:
X----------------------------
X
XNcFTP may need work-arounds for some things due to the differences
Xin implementations of unix.  The following systems are taken care
Xof automatically.  For these systems, you should just be able to type
X'make' (but proceed to part C):
X
X   Silicon Graphics IRIX
X   AIX
X   SINIX
X   Ultrix
X   NeXT
X   Pyramid OSx
X
XOtherwise you will have to configure ncftp manually.
X
XImportant for "Yellow Pages" users:  Don't forget to link the library
Xthat includes the YP/NIS version of getpwuid(), etc.  Otherwise the program
Xwon't be able to expand ~username/path/name type pathnames, and maybe even
X~/path/name types of pathnames.  If you're wondering why the program isn't
Xopening your rc file, this could be the cause.
X
XYou will need to add these things to the SDEFS line in the Makefile
Xas applicable.  As an example, if I say 'add -DFoobar to SDEFS,' find
Xthe line in the Makefile that reads 'SDEFS=' (or 'SDEFS=-DFoo2') and
Xchange it to 'SDEFS=-DFoobar' (or 'SDEFS=-DFoo2 -DFoobar).  If your
Xsystem is listed below, follow the directions and then you ready to
Xgo to part C, below.
X
X    Sun Microsystems' SunOS/Solaris:  Use an ANSI compiler such as
X      gcc (set CC=gcc in the Makefile), or acc (set CC=acc).
X      The regular 'cc' is not an ANSI compiler.  You could also run
X      something like 'ansi2knr' on the sources and hope it works.
X	  You will probably need to link both the curses and termcap
X	  libraries if you use -DCURSES (see below).
X
X    Hewlett-Packard HP-UX:  If you have 7.0, you'll need to find
X      a copy of <ftp.h> from somewhere (8.0 has it though). Then
X      set CFLAGS= -Aa.  You may also need to use gcc if your
X      compiler is non-ANSI.  Note that for HP-UX, the default
X	  terminal escape codes are for HP terminals, so you should
X	  probably link termcap/curses in so it will get the ANSI
X	  sequences if you're on a vt100, etc., terminal connected
X	  to your HP-UX machine.
X
X	Linux:  For 'term' support, from what I can tell just add
X	  the path of 'client.a' to LIBS, and add -DTERM_FTP to SDEFS,
X	  to turn on the term specific ftp code.  srivasta@pilgrim.umass.edu
X	  supplied the term patch.
X      
X    SCO Unix:  Add -DSCO324 or -DSCO322 (as appropriate) to SDEFS,
X      and -lsocket to LIBS.
X
X    SCO Xenix 2.3.4: Add -DSCOXNX to SDEFS;
X		Try adding -DLINGER if puts don't work.
X		Add "-lsocket -ldir" to LIBS.
X
X    Bull DPX/2: Add -DBULL to SDEFS, add -linet to LIBS, and
X      use gcc.
X
X    Sequent's DYNIX: Use gcc and add -DDYNIX (if necessary) to SDEFS.
X      You may also be short several string functions which you will
X      have to get elsewhere, and perhaps mktime and strftime.
X	  You can get all that stuff from the BSD sources (like ftp.uu.net).
X	  Please bug Sequent to update their libc library!
X
X	Sequent's Dynix/PTX:  Add -DDYNIXPTX to SDEFS.
X	  Add -lsocket -linet -lnsl -lseq to LIBS.
X
X    DEC OSF1/1.3:  Use gcc, Add -DGETCWDSIZET to SDEFS.
X
XIf your system doesn't fit any of those, things will be trickier.  Answer
Xall these questions and add to the SDEFS line.  You may want to try
Xeach option one at a time until everything works.
X
X*  Is your system closer to System V or BSD?  Your SDEFS line should have
Xeither -DBSD or -DSYSV.  If you don't know, try leaving it blank first;
Xsome compilers automatically define it for you.
X
X*  Add -DNO_CONST if your compiler chokes on the const directive.  You
Xwill know if you need to add this if the compiler spits out errors saying
Xit doesn't know what 'const' is.
X
X*  As I said above, you will need to link special libraries if your system
Xis running Yellow Pages.
X
X*  Add -DSYSSELECTH if you need <sys/select.h> included for definitions
Xof fd_set, etc.
X
X*  Add -DNO_UNISTDH if you don't have <unistd.h>.  If the compiler complains
Xabout not being able to open <unistd.h> add this.
X
X*  Add -DNO_STDLIBH if you don't have <stdlib.h>.  If the compiler complains
Xabout not being able to open <stdlib.h> add this.
X
X*  Add -DNO_UTIMEH if you don't have <utime.h>.  If the compiler complains
Xabout not being able to open <utime.h> add this.
X
X*  Add -DNO_MKTIME if you don't have the mktime() system call, and don't
Xfeel like getting the source for it and compiling it in with the program.
XIf you define this, the program will not set the file modification times
Xto match the ones on the remote host (no big deal).
X
X*  Add -DGETPASS if you would rather use the standard getpass() system
Xcall, instead of our version, Getpass(), which takes more than 8
Xcharacters.  You may want to define this if you are having problems
Xcompiling getpass.c.
X
XIf you haven't given up on our Getpass(), you can try adding -DSGTTYB
Xif you want to use a struct sgttyb instead of a struct termio.  By default,
XBSD systems define SGTTYB automatically.  You can also try adding -DTERMIOS
Xto use a POSIX compliant struct termios instead.  Don't pull your hair out
Xtrying to get the Getpass code to compile;  if it gives you problems just
Xdefine -DGETPASS and hope your system's getpass can handle passwords
Xlonger than 8 characters.
X
X*  Add -DBAD_INETADDR if your inet_addr() function returns a struct in_addr
Xinstead of a u_long, as it should (in DG/UX 5.4.1).
X
X*  Add -DBROKEN_MEMCPY if ncftp mysteriously dumps core when trying to open
Xa remote host.  I'm told that this happens because of some problem in System
XV's sockets don't like fprintf (and memcpy).
X
X*  Add -DPTRTYPE=char if your pre-ANSI compiler complains about the
Xway malloc() or free() are used, and in general does not like (void *)
Xas a generic pointer type.
X
X*  Add -DNO_STRFTIME if your system does not have strftime().  If you do,
Xwe won't try to use it.  This means, however, you cannot use ``%'' values
Xin your prompt.
X
X*  Add -DNO_RENAME if your system does not have rename() (or the one it
Xhas is broken).  If you do, we will use our own.
X
X*  Add -DNO_STRSTR if your system does not have strstr().  If you do, we
Xwill use our own.
X
X*  Add -DLINGER if puts to the remote system are incomplete.
X
X*  Add -DNET_ERRNO_H if you need to include <net/errno.h> for definitions
X   of ECONNREFUSED, etcetera.
X
X*  (Optional) Add -DGETCWDSIZET if your system's getcwd() takes a size_t
Xas the second parameter instead of an int.
X
X*  (Optional) Add -DHERROR if you know you have the herror() system
Xcall.
X
X*  (Optional) Add -DU_WAIT if you know your wait system call takes
Xa pointer to a 'union wait.'  Defined automatically if you define
XBSD.
X
X*  (Optional) Add -DHOSTNAME=\"machine.domain.nam\" if your system
Xdoesn't generate it's own hostname.  To check this, compile ncftp
Xthen run it and type 'set.'  Look at the variable anon-password.
XIf the hostname is wrong, or if it is in the form of 'yourlogin' or
X'yourlogin@machine' instead of 'yourlogin@machine.xxx.yyy,'
Xre-compile it with HOSTNAME set to your machine's address, in the
Xform of 'machine.xxx.yyy.'
X
X*  (Optional) Add -DSTRICT_PROTOS if your compiler wants function prototypes
Xfor all functions, not just non-int-returning ones.
X
X
XPart C.  Program Options:
X------------------------
X
XAdd these as applicable to the PDEFS line in the Makefile.
X
X* -DGZCAT=\"path\": If you have the GNU gzip package installed on your system,
X	the program can try paging remote files compressed with gzip _and_ 
X	compress (instead of just compress).  Add -DGZCAT=\"/full/path/to/zcat\"
X	with GZCAT set to the path name of GNU's zcat/gzcat.
X
X*   -DCURSES:  Uses curses library to display boldface, underline, etc.
X    By default ncftp uses hard-coded ANSI escapes (^[[1m etc.) to
X    save the 100k or so the curses library adds.  You will also need
X    to edit the LIBS line in the Makefile to add -lcurses.  You may
X	need to add -ltermcap instead, or both -lcurses and -ltermcap.
X	If you choose to use the termcap library, you may want to also add
X	-DNO_CURSES_H so it does not try to include <curses.h>.
X
X*   -DSYSLOG:  Define this to have ncftp log connections and transfers
X    to the syslog.
X
X*   -DNO_TIPS:  Define if you want to cut a little fat at the expense of
X     novice users.
X
X*   -DGETLINE: If you want to use Chris Thewalt's getline input line editor
X    and history facility, add this (and see below).
X
X*   -DREADLINE:  If you want to use GNU's readline input line editor and
X    history facility, add this (and see the Makefile). If you do this, you
X    also need to add -DCURSES (see above).
X
X*	-DSOCKS: NcFTP is now compatible with the Socks library by David Koblas,
X	at koblas@sgi.com.  This lets you use NcFTP with a "firewall" gateway
X	for enhanced site security.  You can get the latest version from
X	netcom.com:/pub/koblas.  After you have compiled it, compile NcFTP
X	with -DSOCKS added to PDEFS, and the pathname of the Rconnect.o file
X	added to LIBS.
X	
X*	-DTRY_ABOR:  Define if you want to try the 'ABOR' command from ncftp;
X	The aborting code has had some problems, so by default the program
X	'aborts' by continuing to read input but not echoing output.
X
X*   -DDB_ERRS:  Define this if you want my Perror() function to be more
X	verbose.  You may want to do this if you are a programmer examining this
X	code, and want to know where in the source the Perror's are coming
X	from.
X
XPart D.  Sending me patches:
X---------------------------
X
XI apologize in advance for problems that my coding style may cause.  The code
Xitself is formatted such that each indent-level is a tab (intended to be
Xequivalent to 4 spaces), and not spaces nor a combination of tabs and spaces.
XThe reason for this, besides being more logical to me, is that I use a
XMacintosh editor to compose the code and I prefer it's indenting method.
XAnother problem in my coding-style is that I write C-code intended for ANSI
XC compilers.  This means that I will use the new-style function declarations
Xand function prototypes, like:
X
X
X   long Foobar(long, long, char *);
X   long Foobar(long t0, long t1, char *str)
X   {
X   }
X
Xas opposed to:
X
X   long Foobar();
X   long Foobar(t0, t1, str)
X	   long t0, t1;
X	   char *str;
X   {
X   }
X
XAnother thing may annoy you is that I always use function prototypes for any
Xfunction I call, including functions that return an int.  This is a good
Xpractice that I learned from the Macintosh programming world.  
X
XSo if you send me patches, please conform to my coding style so that 'patch'
Xwon't screw up, and also that some continuity will be preserved.
X
XBefore you make your patch, you should be sure that you are using the most
Xcurrent version of the program.  This is especially important if you are
Xreporting a bug; I may have already fixed it!  See the above info to get it
Xvia ftp.  Major versions are always posted to comp.sources.misc.  Bug reports
Xare posted to comp.sources.bugs.  Patches that need to be posted ASAP are
Xposted to this group first, so it is advisable that you check this group.
X
XIf you make changes to the code, surround your code in #ifdef/#endif blocks.
XInstead of doing things like #ifdef SunOS, use a name that describes the
Xbug fix or feature, and not your system type, like #ifdef NO_UNISTDH,
Xor #ifdef GETLINE.  That way in case another system has the same problem,
Xit can be added to sys.h without cluttering up the source code.  Then, add
Xthe symbol you used to the end of cmds.c, in the 'CPP Hell' part of the
Xversion() command.  You'll see a list of CPP symbols, so just add yours in
Xa similar fashion, like #ifdef GETLINE/DStrs[nDStrs++] = "GETLINE";/#endif.
X
XIf you don't know how to make a patch, here's how to do it.  Things are easy
Xif you've only changed one file.  Then all you need to do pipe the output of
Xdiff -c into a file and send it to me, i.e. "diff -c cmds.c cmds.c.hack >pch."
XIf you've hacked several files, the way I do it is to keep the originals in
Xone directory (you did make a copy of everything first didn't you?) and the
Xrevisions in another directory.  Then you change directory to the one with the
Xoriginals and do "diff -c . ../revisions > ../pch."
X
X--mg (mgleason@cse.unl.edu)
END_OF_FILE
  if test 15291 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'cmds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmds.c'\"
else
  echo shar: Extracting \"'cmds.c'\" \(40489 characters\)
  sed "s/^X//" >'cmds.c' <<'END_OF_FILE'
X/* cmds.c */
X
X/*  $RCSfile: cmds.c,v $
X *  $Revision: 14020.14 $
X *  $Date: 93/07/09 11:31:53 $
X */
X
X#include "sys.h"
X
X#include <sys/wait.h>
X
X#include <sys/stat.h>
X#include <arpa/ftp.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <errno.h>
X#include <netdb.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <ctype.h>
X
X#ifdef SYSLOG
X#	include <syslog.h>
X#endif
X
X#include "util.h"
X#include "cmds.h"
X#include "main.h"
X#include "ftp.h"
X#include "ftprc.h"
X#include "getpass.h"
X#include "glob.h"
X#include "open.h"
X#include "set.h"
X#include "defaults.h"
X#include "copyright.h"
X
X/* cmds.c globals */
Xint					curtype;			/* file transfer type */
Xchar				*typeabbrs = "abiet";
Xstr32				curtypename;		/* name of file transfer type */
Xint					verbose; 			/* verbosity level of output */
Xint					mprompt;			/* interactively prompt on m* cmds */
Xint					debug;				/* debugging level */
Xint					options;			/* used during socket creation */
Xint					macnum;				/* number of defined macros */
Xint					paging = 0;
Xint					creating = 0;
Xstruct macel		macros[MAXMACROS];
Xchar				*macbuf;			/* holds ALL macros */
Xjmp_buf				jabort;
Xchar				*mname;				/* name of current m* command */
Xint					activemcmd;			/* flag: if != 0, then active multi command */
Xint					warnNoLSFlagsWithWildcards = 0;
X										/* Tells whether the user has been
X										 * warned about not being able to use
X										 * flags with ls when using wildcards.
X										 */
Xlongstring			cwd;				/* current remote directory */
Xlongstring			lcwd;				/* current local directory */
XHostname			lasthostname;		/* name of last host w/ lookup(). */
Xint					logged_in = 0;		/* TRUE if connected and user/pw OK. */
Xint					is_ls = 0;			/* are we doing an ls?  if so, then
X										   read input into a line buffer
X										   for re-use. */
Xextern int					buffer_only;
Xstruct lslist       		*lshead = NULL;	/* hold last output from host */
Xstruct lslist       		*lstail = NULL;
X
X/* cmds.c externs */
Xextern char					*globerr, *home, *reply_string;
Xextern int					margc, connected, ansi_escapes;
Xextern int					code, connected;
Xextern int					toatty, fromatty;
Xextern int					data, progress_meter, remote_is_unix;
Xextern int					parsing_rc, keep_recent;
Xextern char					*altarg, *line, *margv[];
Xextern char					*globchars;
Xextern Hostname				hostname;
Xextern string				progname, pager, anon_password;
Xextern string				prompt, version, indataline;
Xextern longstring			logfname;
Xextern long					logsize;
Xextern size_t				xferbufsize;
Xextern struct servent		serv;
Xextern struct cmd			cmdtab[];
Xextern struct userinfo		uinfo;
Xextern FILE					*cin, *cout, *logf;
Xextern int					Optind;
Xextern char					*Optarg;
Xextern int					Optind;
Xextern char					*Optarg;
X
X#ifdef STRICT_PROTOS
Xextern int gethostname(char *, int), getdomainname(char *, int);
X#endif
X
X
Xstruct types types[] = {
X    { "ascii",  "A",    TYPE_A, 0 },
X    { "binary", "I",    TYPE_I, 0 },
X    { "image",  "I",    TYPE_I, 0 },
X    { "ebcdic", "E",    TYPE_E, 0 },
X    { "tenex",  "L",    TYPE_L, "8" },
X    { 0 }
X};
X
X
X
Xlong GetDateAndSize(char *fName, unsigned long *mod_time)
X{
X	char *cp, *np;
X	string lsline;
X	long size = 0L;
X	int n, v;
X	struct lslist *savedh, *savedt;
X	
X	*mod_time = 0;
X	v = verbose; verbose = V_QUIET;
X	is_ls = 1;
X	buffer_only = 1;
X	savedh = lshead;
X	savedt = lstail;
X	lshead = NULL;
X	(void) recvrequest("LIST", "-", fName, "w");
X	is_ls = 0;
X	buffer_only = 0;
X	verbose = v;
X	if (lshead == NULL) {
X		PurgeLineBuffer();
X		lshead = savedh;
X		lstail = savedt;
X		goto aa;
X	}
X	(void) Strncpy(lsline, lshead->string);
X	PurgeLineBuffer();
X	lshead = savedh;
X	lstail = savedt;
X
X	if (code >= 400 && code < 500)
X		goto aa;
X
X	/* See if this line looks like a unix-style ls line. 
X	 * If so, we can grab the date and size from it.
X	 */	
X	if (strpbrk(lsline, "-dlsbcp") == lsline) {
X		/* See if it looks like a typical '-rwxrwxrwx' line. */
X		cp = lsline + 1;
X		if (*cp != 'r' && *cp != '-')
X			goto aa;
X		++cp;
X		if (*cp != 'w' && *cp != '-')
X			goto aa;
X		cp += 2;
X		if (*cp != 'r' && *cp != '-')
X			goto aa;
X 
X 		/* skip mode, links, owner (and possibly group) */
X 		for (n = 0; n < 4; n++) {
X 			np = cp;
X 			while (*cp != '\0' && !isspace(*cp))
X 				cp++;
X 			while (*cp != '\0' &&  isspace(*cp))
X 				cp++;
X 		}
X 		if (!isdigit(*cp))
X 			cp = np;	/* back up (no group) */
X 		(void) sscanf(cp, "%ld%n", &size, &n);
X 
X 		*mod_time = UnLSDate(cp + n + 1);
X
X		if (size < 100) {
X			/* May be the size of a link to the file, instead of the file. */
X			if ((cp = strstr(lsline, " -> ")) != NULL) {
X				/* Yes, it was a link. */
X				size = GetDateAndSize(cp + 4, mod_time); /* Try the file. */
X			}
X		}
X	}	
Xaa:
X	return (size);
X}	/* GetDateAndSize */
X
X
X
X
Xint _settype(char *typename)
X{
X	register struct types	*p;
X	int						comret, c;
X	string					cmd;
X	char					*cp;
X 
X	c = isupper(*typename) ? tolower(*typename) : (*typename);
X	if ((cp = index(typeabbrs, c)) != NULL)
X		p = &types[(int) (cp - typeabbrs)];
X	else {
X		(void) printf("%s: unknown type\n", typename);
X		return USAGE;
X	}
X	if (c == 't')
X		(void) strcpy(cmd, "TYPE L 8");
X	else	
X		(void) sprintf(cmd, "TYPE %s", p->t_mode);
X	comret = command(cmd);
X	if (comret == COMPLETE) {
X		(void) Strncpy(curtypename, p->t_name);
X		curtype = p->t_type;
X	}
X	return NOERR;
X}	/* _settype */
X
X
X
X
Xint SetTypeByNumber(int i)
X{
X	char tstr[4], *tp = tstr, c;
X
X	tp[1] = c = 0;
X	switch (i) {
X		case TYPE_A: c = 'a'; break;
X		case TYPE_I: c = 'b'; break;
X		case TYPE_E: c = 'e'; break;
X		case TYPE_L: c = 't';
X	}
X	*tp = c;
X	return (_settype(tp));
X}	/* SetTypeByNumber */
X
X
X
X
X/*
X * Set transfer type.
X */
Xint settype(int argc, char **argv)
X{
X	int result = NOERR;
X
X	if (argc > 2) {
X		result = USAGE;
X	} else {
X		if (argc < 2)
X			goto xx;
X		result = _settype(argv[1]);
X		if (IS_VVERBOSE)
Xxx:			(void) printf("Using %s mode to transfer files.\n", curtypename);
X	}
X	return result;
X}	/* settype */
X
X
X
X
X/*ARGSUSED*/
Xint setbinary(int argc, char **argv) {	return (_settype("binary")); }
X/*ARGSUSED*/
Xint setascii(int argc, char **argv) {	return (_settype("ascii")); }
X
X
X
X/*
X * Send a single file.
X */
Xint put(int argc, char **argv)
X{
X	char *cmd;
X
X	if (argc == 2) {
X		argc++;
X		argv[2] = argv[1];
X	}
X	if (argc < 2)
X		argv = re_makeargv("(local-file) ", &argc);
X	if (argc < 2) {
Xusage:
X		return USAGE;
X	}
X	if (argc < 3)
X		argv = re_makeargv("(remote-file) ", &argc);
X	if (argc < 3) 
X		goto usage;
X	cmd = (argv[0][0] == 'a') ? "APPE" : "STOR";
X	(void) sendrequest(cmd, argv[1], argv[2]);
X	return NOERR;
X}	/* put */
X
X
X
X
X/*
X * Send multiple files.
X */
Xint mput(int argc, char **argv)
X{
X	register int i;
X	Sig_t oldintr;
X	char *tp;
X
X	if (argc < 2)
X		argv = re_makeargv("(local-files) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	mname = argv[0];
X	activemcmd = 1;
X	oldintr = Signal(SIGINT, mabort);
X	(void) setjmp(jabort);
X	for (i = 1; i < argc; i++) {
X		register char **cpp, **gargs;
X		char *icopy;
X		
X		/* Make a copy of the argument, because glob() will just copy
X		 * the pointer you give it to the glob-arg vector, and blkfree()
X		 * will want to free each element of the glob-arg vector
X		 * later.
X		 */
X		if ((icopy = NewString(argv[i])) == NULL)
X			break;
X		gargs = glob(icopy);
X		if (globerr != NULL) {
X			(void) printf("%s\n", globerr);
X			if (gargs) {
X				blkfree(gargs);
X				Free(gargs);
X			}
X			continue;
X		}
X		for (cpp = gargs; cpp && *cpp != NULL; cpp++) {
X			if (activemcmd && confirm(argv[0], *cpp)) {
X				tp = *cpp;
X				(void) sendrequest("STOR", *cpp, tp);
X				if (!activemcmd && fromatty) {
X					if (confirm("Continue with","mput")) {
X						activemcmd++;
X					}
X				}
X			}
X		}
X		if (gargs != NULL) {
X			blkfree(gargs);
X			Free(gargs);
X		}
X	}
X	(void) Signal(SIGINT, oldintr);
X	activemcmd = 0;
X	return NOERR;
X}	/* mput */
X
X
X
X
Xint rem_glob_one(char *pattern)
X{
X	int			oldverbose, result = 0;
X	char		*cp;
X	string		str, tname;
X	FILE		*ftemp;
X
X	/* Check for wildcard characters. */
X	if (*pattern == '|' || strpbrk(pattern, globchars) == NULL)
X		return 0;
X
X	(void) tmp_name(tname);
X	oldverbose = verbose;
X	verbose = V_QUIET;
X	(void) recvrequest ("NLST", tname, pattern, "w");
X	verbose = oldverbose;
X	ftemp = fopen(tname, "r");
X	if (ftemp == NULL || FGets(str, ftemp) == NULL) {
X		if (NOT_VQUIET)
X			(void) printf("%s: no match.\n", pattern);
X		result = -1;
X		goto done;
X	}
X	if ((cp = index(str, '\n')) != NULL)
X		*cp = '\0';
X	(void) strcpy(pattern, str);
X	cp = FGets(str, ftemp);
X	/* It is an error if the pattern matched more than one file. */
X	if (cp != NULL) {
X		if (NOT_VQUIET)
X			(void) printf("?Ambiguous remote file name.\n");
X		result = -2;
X	}
Xdone:
X	if (ftemp != NULL)
X		(void) fclose(ftemp);
X	(void) unlink(tname);
X	return (result);
X}	/* rem_glob_one */
X
X
X
X
X/*
X * Receive (and maybe page) one file.
X */
Xint get(int argc, char **argv)
X{
X	string local_file;
X	char remote_file[256];
X	char *cp;
X	int oldtype = curtype, try_zcat;
X	size_t len;
X
X	/* paging mode is set if the command name is 'page' or 'more.' */
X	paging = (**argv != 'g');
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-file) ", &argc);
X
X	if (argc < 2) {
X		return USAGE;
X	}
X	cp = Strncpy(remote_file, argv[1]);
X	argv[1] = cp;
X	if (rem_glob_one(argv[1]) < 0)
X		return CMDERR;
X
X	if (paging) {
X		try_zcat = 0;
X		len = strlen(remote_file);
X
X		if (len > (size_t) 2) {
X 		    if (remote_file[len-2] == '.') {
X				/* Check for .Z files. */
X				if (remote_file[len-1] == 'Z')
X					try_zcat = 1;
X#ifdef GZCAT
X				/* Check for .z (gzip) files. */
X				if (remote_file[len-1] == 'z')
X					try_zcat = 1;
X#endif	/* GZCAT */
X			}
X		}
X
X#ifdef GZCAT
X		if (len > (size_t) 3) {
X			/* Check for ".gz" (gzip) files. */
X			if (strcmp(remote_file + len - 3, ".gz") == 0)
X				try_zcat = 1;
X		}
X#endif	/* GZCAT */
X
X		/* Run compressed remote files through zcat, then the pager.
X		 * If GZCAT was defined, we also try paging gzipped files.
X		 * Note that ZCAT is defined to be GZCAT if you defined
X		 * GZCAT.
X		 */
X		
X 		if (try_zcat) {
X			(void) _settype("b");
X			(void) sprintf(local_file, "|%s ", ZCAT);
X			argv[2] = Strncat(local_file, pager);
X		} else {
X			/* Try to use text mode for paging, so newlines get converted. */
X			(void) _settype("a");
X			argv[2] = pager;
X		}
X	} else {
X		/* normal get */
X		if (argc == 2) {
X			(void) Strncpy(local_file, argv[1]);
X			argv[2] = local_file;
X		} else {
X			if (argc < 3)
X				argv = re_makeargv("(local-file) ", &argc);
X			if (argc < 3) 
X				return USAGE;
X			(void) LocalDotPath(argv[2]);
X		}
X	}
X	(void) recvrequest("RETR", argv[2], argv[1], "w");
X	if (paging) {
X		(void) SetTypeByNumber(oldtype);	/* Restore it to what it was. */
X		paging = 0;
X	}
X	return NOERR;
X}	/* get */
X
X
X
X/*ARGSUSED*/
Xvoid mabort SIG_PARAMS
X{
X	(void) printf("\n");
X	(void) fflush(stdout);
X	if (activemcmd && fromatty) {
X		if (confirm("Continue with", mname)) {
X			longjmp(jabort,0);
X		}
X	}
X	activemcmd = 0;
X	longjmp(jabort,0);
X}	/* mabort */
X
X
X
X
X/*
X * Get multiple files.
X */
Xint mget(int argc, char **argv)
X{
X	char *cp;
X	longstring local;
X	Sig_t oldintr;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-files) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	mname = argv[0];
X	activemcmd = 1;
X	oldintr = Signal(SIGINT, mabort);
X	(void) setjmp(jabort);
X	while ((cp = remglob(argv)) != NULL) {
X		if (*cp == '\0') {
X			activemcmd = 0;
X			continue;
X		}
X		if (activemcmd && confirm(argv[0], cp)) {
X			(void) Strncpy(local, cp);
X			(void) recvrequest("RETR", local, cp, "w");
X			if (!activemcmd && fromatty) {
X				if (confirm("Continue with","mget")) {
X					activemcmd++;
X				}
X			}
X		}
X	}
X	(void) Signal(SIGINT,oldintr);
X	activemcmd = 0;
X	return NOERR;
X}	/* mget */
X
X
X
X
Xchar *remglob(char *argv[])
X{
X	static FILE			*ftemp = NULL;
X	int					oldverbose, i;
X	char				*cp, *mode;
X	static string		tmpname, str;
X	int					result, errs;
X
X	if (!activemcmd) {
Xxx:
X		if (ftemp) {
X			(void) fclose(ftemp);
X			ftemp = NULL;
X			(void) unlink(tmpname);
X		}
X		return(NULL);
X	}
X	if (ftemp == NULL) {
X		(void) tmp_name(tmpname);
X		oldverbose = verbose, verbose = V_QUIET;
X		errs = 0;
X		for (mode = "w", i=1; argv[i] != NULL; i++, mode = "a") {
X			result = recvrequest ("NLST", tmpname, argv[i], mode);
X			if (result < 0) {
X				fprintf(stderr, "%s: %s.\n",
X					argv[i],
X					(strpbrk(argv[i], globchars) != NULL) ? "No match" :
X						"No such file"
X				);
X				errs++;
X			}
X		}
X		if (errs == (i - 1)) {
X			/* Every pattern was in error, so we can't try anything. */
X			(void) unlink(tmpname);		/* Shouldn't be there anyway. */
X			return NULL;
X		}
X		verbose = oldverbose;
X		ftemp = fopen(tmpname, "r");
X		if (ftemp == NULL) {
X			PERROR("remglob", tmpname);
X			return (NULL);
X		}
X	}
X	if (FGets(str, ftemp) == NULL) 
X		goto xx;
X	if ((cp = index(str, '\n')) != NULL)
X		*cp = '\0';
X	return (str);
X}	/* remglob */
X
X
X/*
X * Turn on/off printing of server echo's, messages, and statistics.
X */
Xint setverbose(int argc, char **argv)
X{
X	if (argc > 1)
X		set_verbose(argv[1], 0);
X	else set_verbose(argv[1], -1);
X	return NOERR;
X}	/* setverbose */
X
X
X
X/*
X * Toggle interactive prompting
X * during mget, mput, and mdelete.
X */
Xint setprompt(int argc, char **argv)
X{
X	if (argc > 1)
X		mprompt = StrToBool(argv[1]);
X	else mprompt = !mprompt;
X	if (IS_VVERBOSE)
X		(void) printf("Interactive prompting for m* commmands %s.\n", onoff(mprompt));
X	return NOERR;
X}	/* setprompt */
X
X
X
X
Xvoid fix_options(void)
X{
X	if (debug)
X		options |= SO_DEBUG;
X	else
X	options &= ~SO_DEBUG;
X}   /* fix_options */
X
X
X/*
X * Set debugging mode on/off and/or
X * set level of debugging.
X */
Xint setdebug(int argc, char **argv)
X{
X	int val;
X
X	if (argc > 1) {
X		val = StrToBool(argv[1]);
X		if (val < 0) {
X			(void) printf("%s: bad debugging value.\n", argv[1]);
X			return USAGE;
X		}
X	} else
X		val = !debug;
X	debug = val;
X	fix_options();
X	if (IS_VVERBOSE)
X		(void) printf("Debugging %s (debug=%d).\n", onoff(debug), debug);
X	return NOERR;
X}	/* debug */
X
X
X
X/*
X * Set current working directory
X * on remote machine.
X */
Xint cd(int argc, char **argv)
X{
X	if (argc < 2)
X		argv = re_makeargv("(remote-directory) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	(void) _cd(argv[1]);
X	return NOERR;
X}	/* cd */
X
X
X
X
Xint implicit_cd(char *dir)
X{
X	int i, j = 0;
X	
X	if (connected) {
X		i = verbose;
X		/* Special verbosity level that ignores errors and prints other stuff,
X		 * so you will get just the unknown command message and not an error
X		 * message from cd.
X		 */
X		verbose = V_IMPLICITCD;
X		j = _cd(dir);
X		verbose = i;
X	}
X	return j;
X}	/* implicit_cd */
X
X
X
X
Xint _cd(char *dir)
X{
X	register char *cp;
X	int result = 0;
X	string str;
X
X	if (dir == NULL)
X		goto getrwd;
X	/* Won't work because glob really is a ls, so 'cd pu*' will match
X	 * pub/README, pub/file2, etc.
X	 *	if (result = rem_glob_one(dir) < 0)
X	 *	return result;
X	 */
X	if (strncmp(dir, "CDUP", (size_t) 4) == 0)
X		(void) Strncpy(str, dir);
X	else
X		(void) sprintf(str, "CWD %s", dir);
X	if (command(str) != 5) {
Xgetrwd:
X		(void) quiet_command("PWD");
X		cp = rindex(reply_string, '\"');
X		if (cp != NULL) {
X			result = 1;
X			*cp = '\0';
X			cp = index(reply_string, '\"');
X			if (cp != NULL)
X				(void) Strncpy(cwd, ++cp);
X		}
X	}
X	dbprintf("Current remote directory is \"%s\"\n", cwd);
X	return (result);
X}	/* _cd */
X
X
X
X
X/*
X * Set current working directory
X * on local machine.
X */
Xint lcd(int argc, char **argv)
X{
X	if (argc < 2)
X		argc++, argv[1] = home;
X	if (argc != 2) {
X		return USAGE;
X	}
X	if (chdir(LocalDotPath(argv[1])) < 0) {
X		PERROR("lcd", argv[1]);
X		return CMDERR;
X	}
X	(void) get_cwd(lcwd, (int) sizeof(lcwd));
X	if (NOT_VQUIET) 
X		(void) printf("Local directory now %s\n", lcwd);
X	return NOERR;
X}	/* lcd */
X
X
X
X
X/*
X * Delete a single file.
X */
Xint do_delete(int argc, char **argv)
X{
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote file to delete) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	if (rem_glob_one(argv[1]) == 0) {
X		(void) sprintf(str, "DELE %s", argv[1]);
X		(void) command(str);
X	}
X	return NOERR;
X}	/* do_delete */
X
X
X
X
X/*
X * Delete multiple files.
X */
Xint mdelete(int argc, char **argv)
X{
X	char *cp;
X	Sig_t oldintr;
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-files) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	mname = argv[0];
X	activemcmd = 1;
X	oldintr = Signal(SIGINT, mabort);
X	(void) setjmp(jabort);
X	while ((cp = remglob(argv)) != NULL) {
X		if (*cp == '\0') {
X			activemcmd = 0;
X			continue;
X		}
X		if (activemcmd && confirm(argv[0], cp)) {
X			(void) sprintf(str, "DELE %s", cp);
X			(void) command(str);
X			if (!activemcmd && fromatty) {
X				if (confirm("Continue with", "mdelete")) {
X					activemcmd++;
X				}
X			}
X		}
X	}
X	(void) Signal(SIGINT, oldintr);
X	activemcmd = 0;
X	return NOERR;
X}	/* mdelete */
X
X
X
X
X/*
X * Rename a remote file.
X */
Xint renamefile(int argc, char **argv)
X{
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(from-name) ", &argc);
X	if (argc < 2) {
Xusage:
X		return USAGE;
X	}
X	if (argc < 3)
X		argv = re_makeargv("(to-name) ", &argc);
X	if (argc < 3)
X		goto usage;
X	if (rem_glob_one(argv[1]) < 0)
X		return CMDERR;
X	(void) sprintf(str, "RNFR %s", argv[1]);
X	if (command(str) == CONTINUE) {
X		(void) sprintf(str, "RNTO %s", argv[2]);
X		(void) command(str);
X	}
X	return NOERR;
X}	/* renamefile */
X
X
X
X/*
X * Get a directory listing
X * of remote files.
X */
Xint ls(int argc, char **argv)
X{
X	char		*whichcmd, *cp;
X	str32		lsflags;
X	string		remote, local, str;
X	int			listmode, pagemode, i;
X
X	PurgeLineBuffer();
X	pagemode = 0;
X	switch (**argv) {
X		case 'p':							/* pls, pdir, pnlist */
X			pagemode = 1;
X			listmode = argv[0][1] == 'd';
X			break;
X		case 'd':							/* dir */
X			listmode = 1;
X			break;
X		default:							/* ls, nlist */
X			listmode = 0;
X	}
X	whichcmd = listmode ? "LIST" : "NLST";
X
X	(void) strncpy(local, (pagemode ? pager : "-"), sizeof(local));
X	remote[0] = lsflags[0] = 0;
X	
X	/* Possible scenarios:
X	 *  1.	ls
X	 *  2.	ls -flags
X	 *  3.	ls directory
X	 *  4.  ls -flags >outfile
X	 *  5.  ls directory >outfile
X     *  6.  ls -flags directory
X	 *  7.  ls -flags directory >outfile
X	 *
X	 * Note that using a wildcard will choke with flags.  I.e., don't do
X	 * "ls -CF *.tar," but instead do "ls *.tar."
X	 */
X
X	for (i=1; i<argc; i++) {
X		switch (argv[i][0]) {
X			case '-': 
X				/*
X				 * If you give more than one set of flags, concat the each
X				 * additional set to the first one (without the dash).
X				 */
X				(void) strncat(lsflags, (argv[i] + (lsflags[0] == '-')), sizeof(lsflags));
X				break;
X			case '|':
X				(void) Strncpy(local, argv[i]);
X				LocalDotPath(local + 1);
X				break;
X			case '>':
X				/* We don't want the '>'. */
X				(void) Strncpy(local, argv[i] + 1);
X				LocalDotPath(local);
X				break;
X			default:  
X				cp = argv[i];
X				/*
X				 * In case you want to get a remote file called '--README--'
X				 * or '>README,' you can use '\--README--' and '\>README.'
X				 */
X				if ((cp[1] != 0) && (*cp == '\\'))
X					++cp;
X				if (remote[0] != 0) {
X					(void) Strncat(remote, " ");
X					(void) Strncat(remote, cp);
X				} else {
X					(void) Strncpy(remote, cp);
X				}
X		}	/* end switch */	
X	}		/* end loop */
X
X	/*
X	 *	If we are given an ls with some flags, make sure we use 
X	 *	columnized output (-C) unless one column output (-1) is
X	 *	specified.
X	 */
X	if (!listmode) {
X		if (lsflags[0] != 0) {
X			(void) Strncpy(str, lsflags);
X			for (cp = str + 1; *cp; cp++)
X				if (*cp == '1')
X					goto aa;
X			(void) sprintf(lsflags, "-FC%s", str + 1);
X		} else {
X			if (remote_is_unix)
X				(void) strcpy(lsflags, "-FC");
X		}
X		/* As noted above, we can't use -flags if the user gave a
X		 * wildcard expr.
X		 */
X		if (remote_is_unix && (strpbrk(remote, globchars) != NULL)) {
X			lsflags[0] = 0;
X			/* Warn the user what's going on. */
X			if ((warnNoLSFlagsWithWildcards == 0) && NOT_VQUIET) {
X				(void) fprintf(stderr, "Warning: ls flags disabled with wildcard expressions.\n");
X				warnNoLSFlagsWithWildcards++;
X			}
X		}
X	}
X
Xaa:	if ((strcmp(local, "-") != 0) && (local[0] != '|')) {
X		if (!confirm("Output to local-file: ", local))
X			return CMDERR;
X	}
X	is_ls = 1; /* tells getreply() to start saving input to a buffer. */
X	(void) Strncpy(str, remote);
X	if (lsflags[0] && remote[0])
X		(void) sprintf(remote, "%s%c%s", lsflags, LS_FLAGS_AND_FILE, str);
X	else
X		(void) strncpy(remote, lsflags[0] ? lsflags : str, sizeof(remote));
X	(void) recvrequest(whichcmd, local, (remote[0] == 0 ? NULL : remote), "w");
X	is_ls=0;
X	return NOERR;
X}	/* ls */
X
X
X
X/*
X * Do a shell escape
X */
X/*ARGSUSED*/
Xint shell(int argc, char **argv)
X{
X	int				pid;
X	Sig_t			old1, old2;
X	char			*theShell, *namep;
X#ifndef U_WAIT
X	int				Status;
X#else
X	union wait		Status;
X#endif
X	string			str;
X
X	old1 = signal (SIGINT, SIG_IGN);
X	old2 = signal (SIGQUIT, SIG_IGN);
X	if ((pid = fork()) == 0) {
X		for (pid = 3; pid < 20; pid++)
X			(void) close(pid);
X		(void) Signal(SIGINT, SIG_DFL);
X		(void) Signal(SIGQUIT, SIG_DFL);
X		if ((theShell = getenv("SHELL")) == NULL)
X			theShell = uinfo.shell;
X		if (theShell == NULL)
X			theShell = "/bin/sh";
X		namep = rindex(theShell, '/');
X		if (namep == NULL)
X			namep = theShell;
X		(void) strcpy(str, "-");
X		(void) strcat(str, ++namep);
X		if (strcmp(namep, "sh") != 0)
X			str[0] = '+';
X		dbprintf ("%s\n", theShell);
X		if (argc > 1)
X			(void) execl(theShell, str, "-c", altarg, (char *)0);
X		else
X			(void) execl(theShell, str, (char *)0);
X		PERROR("shell", theShell);
X		exit(1);
X		}
X	if (pid > 0)
X		while (wait((void *) &Status) != pid)
X			;
X	(void) Signal(SIGINT, old1);
X	(void) Signal(SIGQUIT, old2);
X	if (pid == -1) {
X		PERROR("shell", "Try again later");
X	}
X	return NOERR;
X}	/* shell */
X
X
X
X
X/*
X * Send new user information (re-login)
X */
Xint do_user(int argc, char **argv)
X{
X	char			acct[80];
X	int				n, aflag = 0;
X	string			str;
X
X	if (argc < 2)
X		argv = re_makeargv("(username) ", &argc);
X	if (argc > 4) {
X		return USAGE;
X	}
X	(void) sprintf(str, "USER %s", argv[1]);
X	n = command(str);
X	if (n == CONTINUE) {
X		if (argc < 3 )
X			argv[2] = Getpass("Password: "), argc++;
X		(void) sprintf(str, "PASS %s", argv[2]);
X		n = command(str);
X	}
X	if (n == CONTINUE) {
X		if (argc < 4) {
X			(void) printf("Account: "); (void) fflush(stdout);
X			(void) FGets(acct, stdin);
X			acct[strlen(acct) - 1] = '\0';
X			argv[3] = acct; argc++;
X		}
X		(void) sprintf(str, "ACCT %s", argv[3]);
X		n = command(str);
X		aflag++;
X	}
X	if (n != COMPLETE) {
X		(void) fprintf(stdout, "Login failed.\n");
X		logged_in = 0;
X		return (0);
X	}
X	if (!aflag && argc == 4) {
X		(void) sprintf(str, "ACCT %s", argv[3]);
X		(void) command(str);
X	}
X	logged_in = 1;
X	CheckRemoteSystemType(0);
X	return NOERR;
X}	/* do_user */
X
X
X
X
X/*
X * Print working directory.
X */
X/*ARGSUSED*/
Xint pwd(int argc, char **argv)
X{
X	(void) verbose_command("PWD");
X	return NOERR;
X}	/* pwd */
X
X
X
X
X/*
X * Make a directory.
X */
Xint makedir(int argc, char **argv)
X{
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(directory-name) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	(void) sprintf(str, "MKD %s", argv[1]);
X	(void) command(str);
X	return NOERR;
X}	/* makedir */
X
X
X
X
X/*
X * Remove a directory.
X */
Xint removedir(int argc, char **argv)
X{
X	string str;
X	if (argc < 2)
X		argv = re_makeargv("(directory-name) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	if (rem_glob_one(argv[1]) == 0) {
X		(void) sprintf(str, "RMD %s", argv[1]);
X		(void) command(str);
X	}
X	return NOERR;
X}	/* removedir */
X
X
X
X
X/*
X * Send a line, verbatim, to the remote machine.
X */
Xint quote(int argc, char **argv)
X{
X	int i, tmpverbose;
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(command line to send) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	str[0] = 0;
X	if (*argv[0] == 's')	/* Command was 'site' instead of 'quote.' */
X		(void) Strncpy(str, "site ");
X	(void) Strncat(str, argv[1]);
X	for (i = 2; i < argc; i++) {
X		(void) Strncat(str, " ");
X		(void) Strncat(str, argv[i]);
X	}
X	tmpverbose = verbose;
X	verbose = V_VERBOSE;
X	if (command(str) == PRELIM) {
X		while (getreply(0) == PRELIM);
X	}
X	verbose = tmpverbose;
X	return NOERR;
X}	/* quote */
X
X
X
X
X/*
X * Ask the other side for help.
X */
Xint rmthelp(int argc, char **argv)
X{
X	string str;
X
X	if (argc == 1) (void) verbose_command("HELP");
X	else {
X		(void) sprintf(str, "HELP %s", argv[1]);
X		(void) verbose_command(str);
X	}
X	return NOERR;
X}	/* rmthelp */
X
X
X
X
X/*
X * Terminate session and exit.
X */
X/*ARGSUSED*/
Xint quit(int argc, char **argv)
X{
X	close_up_shop();
X	trim_log();
X	exit(0);
X}	/* quit */
X
X
X
Xvoid close_streams(int wantShutDown)
X{
X	if (cout != NULL) {
X		if (wantShutDown)
X			(void) shutdown(fileno(cout), 1+1);
X		(void) fclose(cout);
X		cout = NULL;
X	}
X	if (cin != NULL) {
X		if (wantShutDown)
X			(void) shutdown(fileno(cin), 1+1);
X		(void) fclose(cin);
X		cin = NULL;
X	}
X}	/* close_streams */
X
X
X
X
X/*
X * Terminate session, but don't exit.
X */
X/*ARGSUSED*/
Xint disconnect(int argc, char **argv)
X{
X#ifdef SYSLOG
X	syslog (LOG_INFO, "%s disconnected from %s.", uinfo.username, hostname);
X#endif
X
X	(void) command("QUIT");
X	close_streams(0);
X	UpdateRecentSitesList(hostname, cwd);
X	hostname[0] = cwd[0] = 0;
X	logged_in = connected = 0;
X	data = -1;
X	macnum = 0;
X	return NOERR;
X}	/* disconnect */
X
X
X
Xvoid
Xclose_up_shop(void)
X{
X	static int only_once = 0;
X	if (only_once++ > 0)
X		return;
X	if (connected)
X		(void) disconnect(0, NULL);
X	WriteRecentSitesFile();
X	if (logf != NULL) {
X		(void) fclose(logf);
X		logf = NULL;
X	}
X}	/* close_up_shop */
X
X
X
X
X/*
X * Glob a local file name specification with
X * the expectation of a single return value.
X * Can't control multiple values being expanded
X * from the expression, we return only the first.
X */
Xint globulize(char **cpp)
X{
X	char **globbed;
X
X	(void) LocalPath(*cpp);
X	globbed = glob(*cpp);
X	if (globerr != NULL) {
X		(void) printf("%s: %s\n", *cpp, globerr);
X		if (globbed) {
X			blkfree(globbed);
X			Free(globbed);
X		}
X		return (0);
X	}
X	if (globbed) {
X		*cpp = *globbed++;
X		/* don't waste too much memory */
X		if (*globbed) {
X			blkfree(globbed);
X			Free(globbed);
X		}
X	}
X	return (1);
X}	/* globulize */
X
X
X
X/* change directory to perent directory */
X/*ARGSUSED*/
Xint cdup(int argc, char **argv)
X{
X	(void) _cd("CDUP");
X	return NOERR;
X}	/* cdup */
X
X
X/* show remote system type */
X/*ARGSUSED*/
Xint syst(int argc, char **argv)
X{
X	(void) verbose_command("SYST");
X	return NOERR;
X}	/* syst */
X
X
X
X
Xint make_macro(char *name, FILE *fp)
X{
X	char			*tmp;
X	char			*cp;
X	string			str;
X	size_t			len;
X	int				i;
X
X	if (macnum == MAXMACROS) {
X		(void) fprintf(stderr, "Limit of %d macros have already been defined.\n", MAXMACROS);
X		return -1;
X	}
X
X	/* Make sure macros have unique names.  If 'init' was attempted to be
X	 * redefined, just return, since it was probably cmdOpen() in a redial
X	 * mode which tried to define it again.
X	 */
X	for (i = 0; i<macnum; i++) {
X		if (strncmp(name, macros[i].mac_name, (size_t)8) == 0) {
X			if (parsing_rc) {
X				/* Just shut up and read in the macro, but don't save it,
X				 * because we already have it.
X				 */
X				while ((cp = FGets(str, fp)) != NULL) {
X					/* See if we have a 'blank' line: just whitespace. */
X					while (*cp && isspace(*cp)) ++cp;
X					if (!*cp)
X						break;
X				}
X			} else
X				(void) fprintf(stderr,
X					"There is already a macro named '%s.'\n", name);
X			return -1;
X		}
X	}
X	(void) strncpy(macros[macnum].mac_name, name, (size_t)8);
X	if (macnum == 0)
X		macros[macnum].mac_start = macbuf;
X	else
X		macros[macnum].mac_start = macros[macnum - 1].mac_end + 1;
X	tmp = macros[macnum].mac_start;
X	while (1) {
X		cp = FGets(str, fp);
X		if (cp == NULL) {
X			/*
X			 * If we had started a macro, we will say it is
X			 * okay to skip the blank line delimiter if we
X			 * are at the EOF.
X			 */
X			if (tmp > macros[macnum].mac_start)
X				goto endmac;
X			(void) fprintf(stderr, "No text supplied for macro \"%s.\"\n", name);
X		}
X		/* see if we have a 'blank' line: just whitespace. */
X		while (*cp && isspace(*cp)) ++cp;
X		if (*cp == '\0') {
X			/* Blank line; end this macro. */
Xendmac:
X			macros[macnum++].mac_end = tmp;
X			return 0;
X		}
X		/* Add the text of this line to the macro. */
X		len = strlen(cp) + 1;	/* we need the \0 too. */
X		if (tmp + len >= macbuf + MACBUFLEN) {
X			(void) fprintf(stderr, "Macro \"%s\" not defined -- %d byte buffer exceeded.\n", name, MACBUFLEN);
X			return -1;
X		}
X		(void) strcpy(tmp, cp);
X		tmp += len;
X	}
X}	/* make_macro */
X
X
X
X
Xint macdef(int argc, char **argv)
X{
X	if (argc < 2)
X		argv = re_makeargv("(macro name) ", &argc);
X	if (argc != 2) {
X		(void) domacro(0, NULL);
X		return USAGE;
X	}
X	(void) printf("Enter macro line by line, terminating it with a blank line\n");
X	(void) make_macro(argv[1], stdin);
X	return NOERR;
X}	/* macdef */
X
X
X
X
Xint domacro(int argc, char **argv)
X{
X	register int			i, j;
X	register char			*cp1, *cp2;
X	int						count = 2, loopflg = 0;
X	string					str;
X	struct cmd				*c;
X
X	if (argc < 2) {
X		/* print macros. */
X		if (macnum == 0)
X			(void) printf("No macros defined.\n");
X		else {
X			(void) printf("Current macro definitions:\n");
X			for (i = 0; i < macnum; ++i) {
X				(void) printf("%s:\n", macros[i].mac_name);
X				cp1 = macros[i].mac_start;
X				cp2 = macros[i].mac_end;
X				while (cp1 < cp2) {
X					(void) printf("   > ");
X					while (cp1 < cp2 && *cp1)
X						putchar(*cp1++);
X					++cp1;
X				}
X			}
X		}
X		if (argc == 0) return (NOERR);	/* called from macdef(), above. */
X		argv = re_makeargv("(macro to run) ", &argc);
X	}			
X	if (argc < 2) {
X		return USAGE;
X	}
X	for (i = 0; i < macnum; ++i) {
X		if (!strncmp(argv[1], macros[i].mac_name, (size_t) 9)) {
X			break;
X		}
X	}
X	if (i == macnum) {
X		(void) printf("'%s' macro not found.\n", argv[1]);
X		return USAGE;
X	}
X	(void) Strncpy(str, line);
XTOP:
X	cp1 = macros[i].mac_start;
X	while (cp1 != macros[i].mac_end) {
X		while (isspace(*cp1)) {
X			cp1++;
X		}
X		cp2 = line;
X		while (*cp1 != '\0') {
X		      switch(*cp1) {
X		   	    case '\\':
X				 *cp2++ = *++cp1;
X				 break;
X			    case '$':
X				 if (isdigit(*(cp1+1))) {
X				    j = 0;
X				    while (isdigit(*++cp1)) {
X					  j = 10*j +  *cp1 - '0';
X				    }
X				    cp1--;
X				    if (argc - 2 >= j) {
X					(void) strcpy(cp2, argv[j+1]);
X					cp2 += strlen(argv[j+1]);
X				    }
X				    break;
X				 }
X				 if (*(cp1+1) == 'i') {
X					loopflg = 1;
X					cp1++;
X					if (count < argc) {
X					   (void) strcpy(cp2, argv[count]);
X					   cp2 += strlen(argv[count]);
X					}
X					break;
X				}
X				/* intentional drop through */
X			    default:
X				*cp2++ = *cp1;
X				break;
X		      }
X		      if (*cp1 != '\0') {
X					cp1++;
X		      }
X		}
X		*cp2 = '\0';
X		makeargv();
X		c = getcmd(margv[0]);
X		if ((c == (struct cmd *) -1) && !parsing_rc) {
X			(void) printf("?Ambiguous command\n");
X		} else if (c == NULL && !parsing_rc) {
X			(void) printf("?Invalid command\n");
X		} else if (c->c_conn && !connected) {
X			(void) printf("Not connected.\n");
X		} else {
X			if (IS_VVERBOSE)
X				(void) printf("%s\n",line);
X			if ((*c->c_handler)(margc, margv) == USAGE)
X				cmd_usage(c);
X			(void) strcpy(line, str);
X			makeargv();
X			argc = margc;
X			argv = margv;
X		}
X		if (cp1 != macros[i].mac_end) {
X			cp1++;
X		}
X	}
X	if (loopflg && ++count < argc) {
X		goto TOP;
X	}
X	return NOERR;
X}	/* domacro */
X
X
X
X/*
X * get size of file on remote machine
X */
Xint sizecmd(int argc, char **argv)
X{
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-file) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	if (rem_glob_one(argv[1]) == 0) {
X		(void) sprintf(str, "SIZE %s", argv[1]);
X		(void) verbose_command(str);
X	}
X	return NOERR;
X}	/* sizecmd */
X
X
X
X
X/*
X * get last modification time of file on remote machine
X */
Xint modtime(int argc, char **argv)
X{
X	int overbose;
X	string str;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-file) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	if (rem_glob_one(argv[1]) == 0) {
X		overbose = verbose;
X		if (debug == 0)
X			verbose = V_QUIET;
X		(void) sprintf(str, "MDTM %s", argv[1]);
X		if (command(str) == COMPLETE) {
X			int yy, mo, day, hour, min, sec;
X			(void) sscanf(reply_string, "%*s %04d%02d%02d%02d%02d%02d", &yy, &mo,
X				&day, &hour, &min, &sec);
X			/* might want to print this in local time */
X			(void) printf("%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n", argv[1],
X				mo, day, yy, hour, min, sec);
X		} else
X			(void) fputs(reply_string, stdout);
X		verbose = overbose;
X	}
X	return NOERR;
X}	/* modtime */
X
X
X
Xint lookup(int argc, char **argv)
X{
X	int i, j, by_name, result = NOERR;
X	struct hostent *host;		/* structure returned by gethostbyaddr() */
X	extern int h_errno;
X#ifdef BAD_INETADDR
X	struct in_addr addr;		/* address in host order */
X# define ADDR	addr.s_addr
X#else
X	unsigned long addr;			/* address in host order */
X# define ADDR	addr
X#endif
X
X	if (argc < 2)
X		argv = re_makeargv("(sitename) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X
X 	lasthostname[0] = 0;
X	for (i=1; i<argc; i++) {
X		/* does the argument look like an address? */
X		if (4 == sscanf (argv[i], "%d.%d.%d.%d", &j, &j, &j, &j)) {
X			/* ip */
X  			addr = inet_addr (argv[i]);
X  			if (ADDR == 0xffffffff) {
X     			(void) fprintf(stderr, "## could not convert \"%s\" into a valid IP address.\n", argv[i]);
X     			continue;
X     		}
X			host = gethostbyaddr ((char *) &ADDR, 4, AF_INET);
X			by_name = 0;
X		} else {
X			/* name */
X			host = gethostbyname (argv[i]);
X			by_name = 1;
X		}
X		if (host == NULL) {
X			if (NOT_VQUIET) {
X				/* gethostxxx error */				
X				if (h_errno == HOST_NOT_FOUND) {
X	     			(void) printf("%s: lookup error (%d).\n",
X	     				argv[i], h_errno);
X	     			result = h_errno;
X	 			} else {
X	     			(void) printf("%s \"%s\"\n",
X	     				(by_name==0 ? "unknown address" : "unknown host"),
X	     				argv[i]);
X	     			result = 
X	     				h_errno != 0 ? h_errno :
X	     				-1;
X				}
X			}
X 		} else {
X 			if (*host->h_name)
X 				(void) Strncpy(lasthostname, host->h_name);
X			if (NOT_VQUIET) {
X				(void) printf("%-32s  ", *host->h_name ? host->h_name : "???");
X				if (*host->h_addr_list) {
X					unsigned long horder;
X	
X					horder = ntohl (*(unsigned long *) *(char **)host->h_addr_list);
X					(void) printf ("%lu.%lu.%lu.%lu\n",
X						(horder >> 24),
X						(horder >> 16) & 0xff,
X						(horder >> 8) & 0xff,
X						horder & 0xff);
X				}
X				else (void) printf("???\n");
X			}
X		}
X    }	/* loop thru all sites */
X    return result;
X}	/* lookup */
X
X
X
X
Xint getlocalhostname(char *host, size_t size)
X{
X	int oldv, r;
X	char *argv[2];
X#ifdef HAS_DOMAINNAME
X	char domain[64];
X#endif
X
X#ifdef HOSTNAME
X	(void) strncpy(host, HOSTNAME, size);
X	return NOERR;
X#else
X	*host = 0;
X	if ((r = gethostname(host, size)) == 0) {
X		oldv = verbose;
X		verbose = V_QUIET;
X		argv[0] = "lookup";
X		(void) sprintf(line, "lookup %s", host);
X		(void) makeargv();
X		if (lookup(margc, margv) == 0 && lasthostname[0]) {
X			(void) _Strncpy(host, lasthostname, size);
X#ifdef HAS_DOMAINNAME
X			if (index(host, '.') == NULL) {
X				if (getdomainname(domain + 1, sizeof(domain) - 1) == 0) {
X					domain[0] = '.';
X					(void) _Strncat(host, domain, size);
X				}
X			}
X#endif
X		}
X		verbose = oldv;
X	}
X	return r;
X#endif
X}	/* getlocalhostname */
X
X
X
X
X/*
X * show status on remote machine
X */
Xint rmtstatus(int argc, char **argv)
X{
X	string str;
X
X	if (argc > 1) {
X		(void) sprintf(str, "STAT %s" , argv[1]);
X		(void) verbose_command(str);
X	} else (void) verbose_command("STAT");
X	return NOERR;
X}	/* rmtstatus */
X
X
X
X
X/*
X * create an empty file on remote machine.
X */
Xint create(int argc, char **argv)
X{
X	string			str;
X	FILE			*ftemp;
X
X	if (argc < 2)
X		argv = re_makeargv("(remote-file) ", &argc);
X	if (argc < 2) {
X		return USAGE;
X	}
X	(void) tmp_name(str);
X	ftemp = fopen(str, "w");
X	/* (void) fputc('x', ftemp); */
X	(void) fclose(ftemp);
X	creating = 1;
X	(void) sendrequest("STOR", str, argv[1]);
X	creating = 0;
X	(void) unlink(str);
X	return NOERR;
X}	/* create */
X
X
X
X
X/* show version info */
X/*ARGSUSED*/
Xint show_version(int argc, char **argv)
X{
X	char	*DStrs[80];
X	int		nDStrs = 0, i, j;
X
X	(void) printf("%-30s %s\n", "NcFTP Version:", version);
X	(void) printf("%-30s %s\n", "Author:",
X		"Mike Gleason, NCEMRSoft (mgleason@cse.unl.edu).");
X
X/* Now entering CPP hell... */
X#ifdef __DATE__
X	(void) printf("%-30s %s\n", "Compile Date:", __DATE__);
X#endif
X	(void) printf("%-30s %s (%s)\n", "Operating System:",
X#ifdef System
X	System,
X#else
X#	ifdef unix
X	"UNIX",
X#	else
X	"??",
X#	endif
X#endif
X#ifdef SYSV
X		"SYSV");
X#else
X#	ifdef BSD
X			"BSD");
X#	else
X			"neither BSD nor SYSV?");
X#	endif
X#endif
X
X	/* Show which CPP symbols were used in compilation. */
X#ifdef __GNUC__
X	DStrs[nDStrs++] = "__GNUC__";
X#endif
X#ifdef RINDEX
X	DStrs[nDStrs++] = "RINDEX";
X#endif
X#ifdef CURSES
X	DStrs[nDStrs++] = "CURSES";
X#endif
X#ifdef NO_CURSES_H
X	DStrs[nDStrs++] = "NO_CURSES_H";
X#endif
X#ifdef HERROR
X	DStrs[nDStrs++] = "HERROR";
X#endif
X#ifdef U_WAIT
X	DStrs[nDStrs++] = "U_WAIT";
X#endif
X#if defined(NO_CONST) || defined(const)
X	DStrs[nDStrs++] = "NO_CONST";
X#endif
X#ifdef GETPASS
X	DStrs[nDStrs++] = "GETPASS";
X#endif
X#ifdef HAS_GETCWD
X	DStrs[nDStrs++] = "HAS_GETCWD";
X#endif
X#ifdef GETCWDSIZET
X	DStrs[nDStrs++] = "GETCWDSIZET";
X#endif
X#ifdef HAS_DOMAINNAME
X	DStrs[nDStrs++] = "HAS_DOMAINNAME";
X#endif
X#ifdef HOSTNAME
X	DStrs[nDStrs++] = "HOSTNAME";
X#endif
X#ifdef SYSDIRH
X	DStrs[nDStrs++] = "SYSDIRH";
X#endif
X#ifdef SYSSELECTH
X	DStrs[nDStrs++] = "SYSSELECTH";
X#endif
X#ifdef TERMH
X	DStrs[nDStrs++] = "TERMH";
X#endif
X#ifdef NO_UNISTDH 
X	DStrs[nDStrs++] = "NO_UNISTDH";
X#endif
X#ifdef NO_STDLIBH
X	DStrs[nDStrs++] = "NO_STDLIBH";
X#endif
X#ifdef SYSLOG 
X	DStrs[nDStrs++] = "SYSLOG";
X#endif
X#ifdef BAD_INETADDR
X	DStrs[nDStrs++] = "BAD_INETADDR";
X#endif
X#ifdef SGTTYB
X	DStrs[nDStrs++] = "SGTTYB";
X#endif
X#ifdef TERMIOS
X	DStrs[nDStrs++] = "TERMIOS";
X#endif
X#ifdef STRICT_PROTOS
X	DStrs[nDStrs++] = "STRICT_PROTOS";
X#endif
X#ifdef dFTP_PORT
X	DStrs[nDStrs++] = "dFTP_PORT";
X#endif
X#ifdef BROKEN_MEMCPY
X	DStrs[nDStrs++] = "BROKEN_MEMCPY";
X#endif
X#ifdef READLINE
X	DStrs[nDStrs++] = "READLINE";
X#endif
X#ifdef GETLINE 
X	DStrs[nDStrs++] = "GETLINE";
X#endif
X#ifdef _POSIX_SOURCE
X	DStrs[nDStrs++] = "_POSIX_SOURCE";
X#endif
X#ifdef NO_TIPS
X	DStrs[nDStrs++] = "NO_TIPS";
X#endif
X#ifdef GZCAT
X	DStrs[nDStrs++] = "GZCAT";
X#endif
X#ifdef LINGER
X	DStrs[nDStrs++] = "LINGER";
X#endif
X#ifdef TRY_NOREPLY
X	DStrs[nDStrs++] = "TRY_NOREPLY";
X#endif
X#ifdef NO_UTIMEH 
X	DStrs[nDStrs++] = "NO_UTIMEH";
X#endif
X#ifdef DB_ERRS
X	DStrs[nDStrs++] = "DB_ERRS";
X#endif
X#ifdef NO_VARARGS 
X	DStrs[nDStrs++] = "NO_VARARGS";
X#endif
X#ifdef NO_MKTIME
X	DStrs[nDStrs++] = "NO_MKTIME";
X#endif
X#ifdef NO_STRSTR
X	DStrs[nDStrs++] = "NO_STRSTR";
X#endif
X#ifdef NO_STRFTIME
X	DStrs[nDStrs++] = "NO_STRFTIME";
X#endif
X#ifdef NO_RENAME
X	DStrs[nDStrs++] = "NO_RENAME";
X#endif
X#ifdef TRY_ABOR
X	DStrs[nDStrs++] = "TRY_ABOR";
X#endif
X#ifdef GATEWAY
X	DStrs[nDStrs++] = "GATEWAY";
X#endif
X#ifdef SOCKS
X	DStrs[nDStrs++] = "SOCKS";
X#endif
X#ifdef TERM_FTP
X	DStrs[nDStrs++] = "TERM_FTP";
X#endif
X#ifdef NET_ERRNO_H
X	DStrs[nDStrs++] = "NET_ERRNO_H";
X#endif
X
X/* DONE with #ifdefs for now! */
X
X	(void) printf ("\nCompile Options:\n");
X	for (i=j=0; i<nDStrs; i++) {
X		if (j == 0)
X			(void) printf("    ");
X		(void) printf("%-15s", DStrs[i]);
X		if (++j == 4) {
X			j = 0;
X			(void) putchar('\n');
X		}
X	}
X	if (j != 0)
X		(void) putchar('\n');
X
X#ifdef MK
X	(void) printf("\nMK: %s\n", MK);
X#endif /* MK */
X
X	(void) printf("\nDefaults:\n");
X	(void) printf("\
X    Xfer Buf Size: %8d   Debug: %d   MPrompt: %d   Verbosity: %d\n\
X    Prompt: %s   Pager: %s  ZCat: %s\n\
X    Logname: %s   Logging: %d   Type: %s   Cmd Len: %d\n\
X    Recv Line Len: %d   #Macros: %d   Macbuf: %d  Auto-Binary: %d\n\
X    Recent File: %s   Recent On: %d   nRecents: %d\n\
X    Redial Delay: %d  Anon Open: %d  New Mail Message: \"%s\"\n",
X		MAX_XFER_BUFSIZE, dDEBUG, dMPROMPT, dVERBOSE,
X		dPROMPT, dPAGER, ZCAT,
X		dLOGNAME, dLOGGING, dTYPESTR, CMDLINELEN,
X		RECEIVEDLINELEN, MAXMACROS, MACBUFLEN, dAUTOBINARY,
X		dRECENTF, dRECENT_ON, dMAXRECENTS,
X		dREDIALDELAY, dANONOPEN, NEWMAILMESSAGE
X	);
X#ifdef GATEWAY
X	(void) printf("\
X    Gateway Login: %s\n", dGATEWAY_LOGIN);
X#endif
X	return NOERR;
X}	/* show_version */
X
X
X
Xvoid PurgeLineBuffer(void)
X{
X	register struct lslist *a, *b;
X		 
X	for (a = lshead; a != NULL; ) {
X		b = a->next;
X		if (a->string)
X			free(a->string);    /* free string */
X		Free(a);         /* free node */
X		a = b;
X	}
X	lshead = lstail = NULL;
X}	/* PurgeLineBuffer */
X
X
X
X
X/*ARGSUSED*/
Xint ShowLineBuffer(int argc, char **argv)
X{
X	register struct lslist *a = lshead;
X	int pagemode;
X	FILE *fp;
X	Sig_t oldintp;
X
X	if (a == NULL)
X		return CMDERR;
X	pagemode= (**argv) == 'p' && pager[0] == '|';
X	if (pagemode) {
X		fp = popen(pager + 1, "w");
X		if (!fp) {
X			PERROR("ShowLineBuffer", pager + 1);
X			return CMDERR;
X		}
X	} else
X		fp = stdout;
X	oldintp = Signal(SIGPIPE, SIG_IGN);
X	while (a) {
X		if (a->string)
X			(void) fprintf(fp, "%s\n", a->string);
X		a = a->next;
X	}
X	if (pagemode)
X		(void) pclose(fp);
X	if (oldintp)
X		(void) Signal(SIGPIPE, oldintp);
X	return NOERR;
X}	/* ShowLineBuffer */
X
X
X
X
X/*ARGSUSED*/
Xint unimpl(int argc, char **argv)
X{
X	if (!parsing_rc)
X		(void) printf("%s: command not supported. (and probably won't ever be).\n", argv[0]);
X	return (NOERR);
X}	/* unimpl */
X
X/* eof cmds.c */
END_OF_FILE
  if test 40489 -ne `wc -c <'cmds.c'`; then
    echo shar: \"'cmds.c'\" unpacked with wrong size!
  fi
  # end of 'cmds.c'
fi
echo shar: End of archive 1 \(of 6\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
