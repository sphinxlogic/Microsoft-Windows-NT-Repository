Newsgroups: comp.sources.misc
From: mgleason@cse.unl.edu (Mike Gleason)
Subject: v40i078:  ncftp - Alternative User Interface for FTP, v1.6, Part03/06
Message-ID: <1993Nov2.232348.6380@sparky.sterling.com>
X-Md4-Signature: e61de168560bd974970fb040dc3b4380
Keywords: ncftp
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: NCEMRSoft
Date: Tue, 2 Nov 1993 23:23:48 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mgleason@cse.unl.edu (Mike Gleason)
Posting-number: Volume 40, Issue 78
Archive-name: ncftp/part03
Environment: UNIX, ANSI-C, !SVR4
Supersedes: ncftp: Volume 39, Issue 53-57

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile getpass.h ncftp.1 open.c
# Wrapped by kent@sparky on Mon Nov  1 16:19:17 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 6)."'
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(6637 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for ncftp
X# 
X# Major sections delimited by a dash lines.  If several lines set the same
X# make variable, you can choose between the commented #samples, or just
X# type what you want manually.
X#--------------------------------------------------------------------------
X
X
X# System dependent definitions.  See the README, part B.
X#--------------------------------------------------------------------------
XSDEFS = 
X
X
X# Program definitions.  See the README, part C.
X#--------------------------------------------------------------------------
XPDEFS =
X#PDEFS = -DGETLINE
X#PDEFS = -DREADLINE -DCURSES
X#PDEFS = -DSOCKS
X#PDEFS = -DDEBUG -DDB_ERRS
X
X
X# Choose your compiler and flags below.  Make sure you use an ANSI compiler
X# that handles new style function declarations and prototypes (gcc should).
X#--------------------------------------------------------------------------
XCC = cc
X#CC = gcc
X
X#CFLAGS = -O
XCFLAGS = -O2
X#CFLAGS = -g
X
XLFLAGS = -s
X#LFLAGS =
X
X
X# Additional libraries and/or object files.
X# 
X# For each library, add -lLIBNAME to the LIBS line below, for a library
X#   named libLIBNAME.a.
X#
X# For each object file, just add the pathname of the object file.
X#
X# Some may need any of -lsocket, -lnet, -linet, -lintl, or -lnsl. 
X# You'll need -lcurses or -ltermcap if CURSES is defined.
X# You'll need -lreadline AND either -lcurses or -ltermcap if you
X#   want to use the GNU Readline library.
X# You'll need -lgetline (compile it as a library) if you want to use
X#   getline.
X# If your system is running Yellow Pages, you'll need to add the library
X#   that has the YP/NIS version of getpwuid() in it (Important!)
X# You'll need to know where the Rconnect.o object file is if you want
X#   to use Socks.
X#--------------------------------------------------------------------------
XLIBS =
X#LIBS = -ldbmalloc
X#LIBS = -lgetline
X#LIBS = -lreadline -lcurses
X#LIBS = ../lib/Rconnect.o
X#LIBS = -lnet -lnsl -lsocket -lcurses
X
X
X# If the libraries are in a non-standard directory, or you if want to use
X# getline or readline and they aren't installed system-wide, add the
X# extra directories to look in here, using -L's.
X#--------------------------------------------------------------------------
XLIBDIRS =
X#LIBDIRS = -L../getline
X#LIBDIRS = -L../readline
X
X
X# Additional headers.
X#
X# If you defined READLINE or GETLINE, you have to tell where it's header
X# file can be found.
X#
X# For READLINE, provide a path which would find <readline/readline.h>,
X#   so you would put the parent directory of the readline directory below.
X#   If you had '/usr/local/readline/readline.h' you would use
X#   -I/usr/local.
X#
X# For GETLINE, a little different. Just supply a path that would find
X#   <getline.h>.  If you had '/usr/local/getline/getline.h' you would use
X#   -I/usr/local/getline.
X#--------------------------------------------------------------------------
XHDRDIRS =
X#HDRDIRS = -I../getline
X#HDRDIRS = -I..
X
X
X# If you want to 'make install,' edit these variables, otherwise don't
X# worry about it.
X# To install MAN style pages, set MANDIR to the proper location.
X# To install CATMAN style pages, set CATMANDIR, NROFF, and PACK to the proper
X# locations.
X# To inhibit the installation of either, unset MANDIR/CATMANDIR.
X#--------------------------------------------------------------------------
XBINDIR = /usr/lbin
XMANDIR = /usr/man/man1
X#MANDIR = 
XCATMANDIR = /usr/catman/LOCAL/g1
X#CATMANDIR =
XNROFF	= /usr/ucb/nroff
XPACK	= pack
XTEST	= test
XRM = rm -f
XCP = cp
X
X
X#************************************************
X#*** SHOULD NOT NEED TO EDIT BELOW THIS POINT ***
X#************************************************
X
XDEFS = $(PDEFS) $(SDEFS)
XMK = $(CC) $(CFLAGS) $(DEFS) $(HDRDIRS) $(LFLAGS) $(LIBDIRS) $(LIBS)
X 
XSRCS = cmds.c cmdtab.c ftp.c ftprc.c getpass.c glob.c main.c open.c set.c \
Xtips.c util.c
X  
XHEADERS = cmds.h copyright.h defaults.h ftp.h ftprc.h getpass.h glob.h \
Xmain.h open.h set.h sys.h util.h
X   
XOBJS = cmds.o cmdtab.o ftp.o ftprc.o getpass.o glob.o main.o open.o set.o \
Xtips.o util.o
X
XNAME = ncftp
XMAN = ncftp.1
XCATMAN = ncftp.z
XALL = $(SRCS) $(HEADERS) patchlevel.h Blurb README Makefile $(MAN) \
Xv2_Note
X
XC_COMPILE = $(CC) $(CFLAGS) $(DEFS) $(HDRDIRS)
XC_COMPILE2 = $(CC) $(CFLAGS) $(DEFS) -DMK='"$(MK)"' $(HDRDIRS)
X
Xall: $(NAME) done
X
X$(NAME): $(OBJS)
X	$(CC) $(LFLAGS) $(LIBDIRS) $(OBJS)  -o $(NAME) $(LIBS)
X
Xinstall: $(NAME)
X	$(CP) $(NAME) $(BINDIR)/$(NAME)
X	@if $(TEST) -n '$(MANDIR)'; then \
X		$(MAKE) install_man ; else true ;  fi
X	@if $(TEST) -n '$(CATMANDIR)'; then \
X		$(MAKE) install_catman ; else true ;  fi
X
Xinstall_man: 
X	$(CP) $(MAN)  $(MANDIR)/$(MAN)
X
Xinstall_catman:  $(CATMAN)
X	$(CP) $(CATMAN)  $(CATMANDIR)/$(CATMAN)
X
Xuninstall:
X	$(RM) $(BINDIR)/$(NAME)
X	$(RM) $(MANDIR)/$(MAN)
X	$(RM) $(CATMANDIR)/$(CATMAN)
X
X$(CATMAN): $(MAN)
X	rm -f tmp
X	$(NROFF) -man -Tlp $(MAN) > tmp
X	$(PACK) -f tmp
X	mv tmp.z $(CATMAN)
X
Xcmds.o:
X	$(C_COMPILE2) cmds.c -c
X
X.c.o:
X	$(C_COMPILE) -c $<
X
Xdone: $(NAME)
X	-@ls -l $(NAME)
X	-@echo 'Done.'
X
Xclean:
X	rm -f $(OBJS) $(NAME)
X
X# Dependencies:
Xcmds.o: cmds.c 
Xcmds.o: sys.h 
Xcmds.o: util.h 
Xcmds.o: cmds.h 
Xcmds.o: main.h 
Xcmds.o: ftp.h 
Xcmds.o: ftprc.h 
Xcmds.o: getpass.h 
Xcmds.o: glob.h 
Xcmds.o: open.h 
Xcmds.o: set.h 
Xcmds.o: defaults.h 
Xcmds.o: copyright.h 
Xcmdtab.o: cmdtab.c 
Xcmdtab.o: sys.h 
Xcmdtab.o: util.h 
Xcmdtab.o: cmds.h 
Xcmdtab.o: main.h 
Xcmdtab.o: ftp.h 
Xcmdtab.o: ftprc.h 
Xcmdtab.o: glob.h 
Xcmdtab.o: open.h 
Xcmdtab.o: set.h 
Xcmdtab.o: copyright.h 
Xftp.o: ftp.c 
Xftp.o: sys.h 
Xftp.o: util.h 
Xftp.o: ftp.h 
Xftp.o: cmds.h 
Xftp.o: main.h 
Xftp.o: ftprc.h 
Xftp.o: getpass.h 
Xftp.o: defaults.h 
Xftp.o: copyright.h 
Xftprc.o: ftprc.c 
Xftprc.o: sys.h 
Xftprc.o: util.h 
Xftprc.o: ftprc.h 
Xftprc.o: main.h 
Xftprc.o: cmds.h 
Xftprc.o: set.h 
Xftprc.o: defaults.h 
Xftprc.o: copyright.h 
Xgetpass.o: getpass.c 
Xgetpass.o: sys.h 
Xgetpass.o: util.h 
Xgetpass.o: cmds.h 
Xgetpass.o: getpass.h 
Xgetpass.o: copyright.h 
Xglob.o: glob.c 
Xglob.o: sys.h 
Xglob.o: util.h 
Xglob.o: glob.h 
Xglob.o: cmds.h 
Xglob.o: copyright.h 
Xmain.o: main.c 
Xmain.o: sys.h 
Xmain.o: util.h 
Xmain.o: cmds.h 
Xmain.o: main.h 
Xmain.o: ftp.h 
Xmain.o: ftprc.h 
Xmain.o: open.h 
Xmain.o: set.h 
Xmain.o: defaults.h 
Xmain.o: copyright.h 
Xopen.o: open.c 
Xopen.o: sys.h 
Xopen.o: util.h 
Xopen.o: open.h 
Xopen.o: cmds.h 
Xopen.o: ftp.h 
Xopen.o: ftprc.h 
Xopen.o: main.h 
Xopen.o: defaults.h 
Xopen.o: copyright.h 
Xset.o: set.c 
Xset.o: sys.h 
Xset.o: util.h 
Xset.o: cmds.h 
Xset.o: main.h 
Xset.o: set.h 
Xset.o: defaults.h 
Xset.o: copyright.h 
Xtips.o: tips.c 
Xtips.o: sys.h 
Xtips.o: util.h 
Xutil.o: util.c 
Xutil.o: sys.h 
Xutil.o: util.h 
Xutil.o: cmds.h 
Xutil.o: main.h 
Xutil.o: ftp.h 
Xutil.o: ftprc.h 
Xutil.o: defaults.h 
Xutil.o: copyright.h 
END_OF_FILE
  if test 6637 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'getpass.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpass.h'\"
else
  echo shar: Extracting \"'getpass.h'\" \(278 characters\)
  sed "s/^X//" >'getpass.h' <<'END_OF_FILE'
X/* Getpass.h */
X
X#ifndef _getpass_h_
X#define _getpass_h_
X
X/*  $RCSfile: getpass.h,v $
X *  $Revision: 14020.11 $
X *  $Date: 93/05/21 05:45:36 $
X */
X
X#define kMaxPassLen 127
X
Xchar *Getpass(char *prompt);
Xvoid echo(FILE *fp, int on);
X
X#endif	/* _getpass_h_ */
X
X/* eof Getpass.h */
END_OF_FILE
  if test 278 -ne `wc -c <'getpass.h'`; then
    echo shar: \"'getpass.h'\" unpacked with wrong size!
  fi
  # end of 'getpass.h'
fi
if test -f 'ncftp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ncftp.1'\"
else
  echo shar: Extracting \"'ncftp.1'\" \(33759 characters\)
  sed "s/^X//" >'ncftp.1' <<'END_OF_FILE'
X.\"-------
X.\" Man page portability notes
X.\"
X.\" These are some notes on conventions to maintain for greatest
X.\" portability of this man page to various other versions of
X.\" nroff.
X.\"
X.\" When you want a \ to appear in the output, use \e in the man page.
X.\" (NOTE this comes up in the rc grammar, where to print out '\n' the
X.\" man page must contain '\en'.)
X.\"
X.\" Evidently not all versions of nroff allow the omission of the
X.\" terminal " on a macro argument.  Thus what could be written
X.\"
X.\" .Cr "exec >[2] err.out
X.\"
X.\" in true nroffs must be written
X.\"
X.\" .Cr "exec >[2] err.out"
X.\"
X.\" instead.
X.\"
X.\" Use symbolic font names (e.g. R, I, B) instead of the standard
X.\" font positions 1, 2, 3.  Note that for Xf to work the standard
X.\" font names must be single characters.
X.\"
X.\" Note that sentences should end at the end of a line.  nroff and
X.\" troff will supply the correct intersentence spacing, but only if
X.\" the sentences end at the end of a line.  Explicit spaces, if given,
X.\" are apparently honored and the normal intersentence spacing is
X.\" supressed.
X.\"
X.\" DaviD W. Sanderson
X.\"-------
X.\" Dd	distance to space vertically before a "display"
X.\" These are what n/troff use for interparagraph distance
X.\"-------
X.if t .nr Dd .4v
X.if n .nr Dd 1v
X.\"-------
X.\" Sp	space down the interparagraph distance
X.\"-------
X.de Sp
X.sp \\n(Ddu
X..
X.\"-------
X.\" Ds	begin a display, indented .5 inches from the surrounding text.
X.\"
X.\" Note that uses of Ds and De may NOT be nested.
X.\"-------
X.de Ds
X.Sp
X.in +0.5i
X.nf
X..
X.\"-------
X.\" De	end a display (no trailing vertical spacing)
X.\"-------
X.de De
X.fi
X.in
X..
X.TH NcFTP 1 "" NCEMRSoft
X.\"-------
X.SH "NAME"
X.\"-------
XNcFTP \(em Internet file transfer program
X.\"-------
X.SH "SYNOPSIS"
X.\"-------
X.B ncftp
X.RI [ "program options" ]
X.RI [[ "open options" ]
X.IR hostname [\c
X.B :\c
X.IR pathname ]]
X.\"-------
X.SH "DESCRIPTION"
X.\"-------
X.I NcFTP
Xis a user interface to the Internet standard
X.IR "File Transfer Protocol" .
XThis program allows a user to transfer files to and from a remote network
Xsite, and offers additional features that are not found in the standard
Xinterface,
X.IR ftp .
X.\"-------
X.SH "FEATURES"
X.\"-------
XProgram options will be explained later in this document.
XLet's get down to business and go over the features
Xthat make this program worthwhile.
X.PP
XHere is the list of section headers; I have my $MANPAGER environment
Xvariable set to use
X.RB `` "less \-i" ''
Xso that I can skip to the section I
Xwant (otherwise,
X.BI / regex
Xcommands to the pager won't match the section
Xheaders because of the formatting codes;
Xthe
X.RB `` \-i ''
Xcan search through the formatting codes)
X.Ds
XEstablishing the remote connection
XFormat of the RC file
XThe Recent-sites file
XRedialing a busy remote site
XSupplying a sitename from your shell's command line
XUsing Colon-mode
XUsing FTP-cat and FTP-more mode
XSupplying a port number with the open command
XDisplaying and changing program variables
XProgram variables
XListing a remote directory
XViewing a remote directory with your pager
XRedisplaying the last directory listing
XFetching files from the remote host
XViewing a remote file with your pager
XCreating a message file on the remote host
XLooking up site names and addresses
XChecking the configuration of the program
XUsing the command shell
XCustomizing the prompt
XKeeping a log of your file transfers
XProgram options
XA sample RC file
X.De
X.\"-------
X.SH "Establishing the remote connection"
X.\"-------
XJust opening a connection to a remote server was inconvenient enough in the
Xstock
X.I ftp
Xprogram to justify writing this program.
XHere at
X.IR NCEMRSoft ,
Xwe want to do our business as quickly and painlessly as possible.
XWe'd
Xrather save time and wear and tear on our metacarpals than bother typing
Xentire site names, usernames, and email addresses masquerading as passwords,
Xand setting binary mode.
X.PP
XWe made all connections anonymous by default, and we automatically send our
Xemail address for the password on those connections.
XWe allowed for site
Xnames to be abbreviated.
X.PP
XFor each commonly accessed site, you can put an entry in your program
Xpreferences file (let's call it the ``ncftprc file'' or ``RC file'' for short).
XTo open the site, from the command shell all you do is type:
X.Ds
Xopen wuarchive.wustl.edu
X.De
X.PP
Xor
X.Ds
Xo wuarchive.wustl.edu
X.De
X.PP
XAs promised, you can abbreviate that further.
XJust use any abbreviation that
Xwould match only the site you had in mind.
XFor the previous example, you
Xcould try:
X.Ds
Xo wuarc
Xo wustl
Xo stl
Xo wu
X.De
X.PP
XAny of those abbreviations would open wuarchive.wustl.edu anonymously,
Xsending your anon-password (usually set to your email address) as the
Xpassword.
XKeep in mind that the program tries opening the first site
Xthat matches the abbreviation you supplied.
XSo:
X.Ds
Xo w
X.De
X.PP
Xmight match a site named bowser.nintendo.jp if that site appeared before
Xyour entry for wuarchive.wustl.edu.
X.PP
XMost of the time we open remote sites anonymously, but
Xthere are times where you need to specifically open a site with an actual
Xusername and password.
XLet's say my partner, Phil Dietz, wants to FTP
Xsomething out of my account.
XPerhaps he wants to fetch the latest version
Xof the source code to
X.I NcFTP
Xso he can optimize something or add a new feature behind my back.
XSince the
Xprogram opens remote sites anonymously by default (actually, you can change
Xthis behavior; more on that later), he would have to specify a flag to the
X.I open
Xcommand so he can supply my username and password.
XHe would try:
X.Ds
Xo \-u sphygmomanometer.unl.edu
X.De
X.PP
Xor, more likely:
X.Ds
Xo \-u sph
X.De
X.PP
XThen the program would prompt him for a username (login, whatever) and a
Xpassword:
X.Ds
XLogin Name (pdietz): mgleason
XPassword: ********
X.De
X.PP
XIf he got it right, he could raid my stuff.
XIf not, he'd probably drop
Xme an email asking me to quit changing my password so often.
X.PP
XThere are even times where you want to FTP from your own account, like if
Xyou are debugging an FTP client you wrote.
XAt this prompt:
X.Ds
XLogin Name (mgleason):
X.De
X.PP
XI could just hit return to tell the program that I want ``mgleason'' as my
Xusername, then I would enter my password.
X.\"-------
X.SH "Format of the RC file"
X.\"-------
XThis release of the program is somewhat compatible with the stock
X.I ftp
Xprogram's
X.B ".netrc"
Xfile.
XHowever, I can promise you that in the near future the program will
Xuse a new format, so don't invest too much time in it.
X.PP
XThe RC file can be named
X.RB `` ncftprc '',
X.RB `` netrc '',
Xor
X.RB `` .ncftprc '',
Xbut it is usually named
X.RB `` .netrc ''
Xso it can be used with the stock
X.I ftp
Xprogram.
X.I NcFTP
Xlooks in the current working directory for any of those files, and then in
Xyour home directory, and after that it gives up (which is OK, because RC
Xfiles aren't mandatory).
X.PP
XThe file usually starts with
X.I #set
Xand
X.I #unset
Xcommands that do things
Xto the programs variables.
XThe reason for the ``#'' is so the stock
X.I ftp
Xprogram will think they are comments.
XYou might have this appearing as
Xthe first few lines in your RC file (I'll explain later):
X.Ds
X#set debug 1
X#set pager "less \-EMi"
X#unset startup\-msg
X.De
X.PP
XAfter those, you put in machine entries for each of your favorite sites.
XLet's put in an entry for wuarchive.wustl.edu.
XFirst you would put:
X.Ds
Xmachine wuarchive.wustl.edu
X.De
X.PP
XThen you could put in your username, password, and account if you like:
X.Ds
Xuser anonymous
Xpassword \-mgleason@cse.unl.edu
Xaccount wuarc.does.not.use.accounts
X.De
X.PP
XFollowing that, you would add the startup macro that is run
Xeach time you connect to wuarchive.
XYou must start it with this line:
X.Ds
Xmacdef init
X.De
X.PP
XThen put in the commands you want to do:
X.Ds
Xcd /graphics/gif
Xls \-lt
X.De
X.PP
XAfter that, you end the macro with a blank line (important!).
XThe finished machine entry would look like the following.
XTo make the transition to the impending new format less painful,
XI recommend you adhere to this format:
X.ta 6m +6m
X.Ds
Xmachine wuarchive.wustl.edu
X	user anonymous
X	password \-mgleason@cse.unl.edu
X	account wuarc.does.not.use.accounts
X	macdef init
X		cd /graphics/gif
X		ls \-lt
X.RI \t( "mandatory blank line to end the macro" )
X.De
X.PP
XOf course, if all you want to do is open wuarchive anonymously, you
Xneedn't bother with the ``user'', ``password'', and ``account'' lines.
XYou may want to put them in if you plan on using the stock
X.I ftp
Xprogram, though.
XTry something like this:
X.ta 6m +6m
X.Ds
Xmachine wuarchive.wustl.edu
X	macdef init
X		cd /graphics/gif
X		ls \-lt
X.RI \t( "mandatory blank line to end the macro" )
X.De
X.PP
XYou can tell the program to not run the startup macro if you supply
X.B "\-i"
Xto the
X.I open
Xcommand.
X.PP
XReally, you should only bother adding entries for sites that you want to
Xrun startup macros upon connection.
XThe next section explains why.
X.\"-------
X.SH "The Recent-sites file"
X.\"-------
XEach time you open a site, the program saves the name of the site and the
Xlast directory you were in to the
X.I recent-sites file
Xwhich is named
X.B ".ncrecent"
Xand placed in your home directory.
XThe program saves a
Xpredetermined number of these sites in the file, and when it reaches the
Xlimit, it discards the oldest entry so it can add a new one.
X.PP
XYou can just go ahead and use the name of the site you want with the
X.I open
Xcommand if you know it is in the
X.I recent\-file
X(and you can abbreviate the
Xname, just like those in the RC file).
XBut if you cannot remember what the
Xname of the site you want, all you do is run the
X.I open
Xcommand with
Xno site parameter:
X.Ds
Xopen
X.De
X.PP
XThis will pop up a list of the sites in the
X.IR "recent-file" ,
Xand sites in your RC file.
XAt the open prompt, just type the name (or an
Xabbreviation of that name) or the number preceding the site name to open
Xthat site.
XAfter opening the site you wanted, the program sets the remote
Xworking directory to the same one you left in the last time you called.
X.PP
XIf you don't like the idea of having the sites you called stored on disk,
Xyou can turn this feature off using an
X.I unset
Xcommand, explained later.
X.\"-------
X.SH "Redialing a busy remote site"
X.\"-------
XSome remote sites limit the number of leeches, er, anonymous connections
Xat a time to reduce the load on the host computer.
XYou can use the
X.I open
Xcommand's redial feature to keep attempting connections until you get on,
Xalthough that is not a very polite thing to do.
XThe simplest way to do
Xthis would be to just supply the
X.B \-r
Xoption:
X.Ds
Xopen \-r wuarc
X.De
X.PP
XThere are also options you can use to tweak redial.
XThe
X.B \-d
Xflag sets
Xthe delay between dials, and the
X.B \-g
Xflag sets a limit on how many dials
Xshould be attempting before giving up.
XIf you don't supply
X.B \-g
Xthe program will dial a day and forever (which my Number Theory professor,
XDr. Mientka, says is longer than forever and a day)
Xuntil it connects successfully, or until you get sick of waiting and hit the
Xinterrupt key (usually ^C).
X.PP
XThis example dials wuarchive every ten minutes, giving up after twenty
Xattempts.
XNote that the redial delay is specified in seconds:
X.Ds
Xopen \-r \-d 600 \-g 20 wuarc
X.De
X.PP
XPlease be considerate when you use redialing, so you won't tax the network.
XSite administrators can and do get angry when they get flooded with
Xconnections.
X.\"-------
X.SH "Supplying a sitename from your shell's command line"
X.\"-------
XWhen you run the program:
X.Ds
Xncftp
X.De
X.PP
Xby itself does nothing and waits for you to type commands to the program's
Xown shell.
XJust like the stock
X.I ftp
Xprogram, you can supply a site name
Xon the command line:
X.Ds
Xncftp wuarchive.wustl.edu
X.De
X.PP
XYou can also use abbreviations as usual:
X.Ds
Xncftp wuarc
X.De
X.PP
XThis is equivalent to running the program, then issuing an
X.I open
Xcommand to open wuarchive.
X.\"-------
X.SH "Using Colon-mode"
X.\"-------
XThe
X.I open
Xcommand is not a one-trick pony.
XAnother option is what I call
X.IR "colon-mode" .
XThis feature is used (most of the time) from your shell's
Xcommand line.
X.PP
XIn ancient times, way back during the Disco era, you could use a program
Xcalled
X.I tftp
Xto fetch a file using the Internet standard
X.I Trivial File Transfer Protocol.
XYou could use that program to do something like this
Xfrom within its shell:
X.Ds
Xget wuarchive.wustl.edu:/graphics/gif/README
X.De
X.PP
Xand that would call wuarchive and fetch the
X.B README
Xfile.
X.PP
XYou can use this program to do the same thing from your shell's command
Xline:
X.Ds
Xcsh> ncftp wuarchive.wustl.edu:/graphics/gif/README
Xcsh> head README
X.De
X.PP
XThis tells your shell, in this case the ``c-shell'' to run
X.IR NcFTP ,
Xwhich
Xwould open wuarchive, fetch
X.B /graphics/gif/README
Xand write the file
X.B ./README
Xin the current working directory, and then exits.
XThis is nice if you don't
Xwant to browse around the remote site, and you know exactly want you want.
XIt would also come in handy in shell scripts, where you don't want to
Xenter the command shell, and might not want the program to spew output.
X.PP
XYou can use
X.I colon-mode
Xto set the starting remote working directory also:
X.Ds
Xcsh> ncftp wuarchive.wustl.edu:/graphics/gif
X.De
X.PP
XThis would run the program, open wuarchive, and
X.I cd
Xto the gif directory, then run the program's command shell so you can
Xbrowse.
X.PP
X.I Colon-mode
Xis also available from within the program's command shell.
XAt a prompt you can do stuff like this:
X.Ds
Xncftp> open wuarchive.wustl.edu:/graphics/gif/README
Xncftp> o wuarc:/graphics/gif
X.De
X.\"-------
X.SH "Using FTP-cat and FTP-more mode"
X.\"-------
XThere are times where you might not want the program to write a
X.I colon-mode
Xfile in the current working directory, or perhaps you want to pipe the
Xoutput of a remote file into something else.
X.I Colon-mode
Xhas options to
Xdo this.
XIt was inspired by the guy who wrote the
X.I ftpcat
Xperl script.
XThe
X.B \-c
Xoption tells the program to write on the standard
Xoutput stream.
XThe
X.B \-m
Xoption pipes the file into your pager (like
X.IR more ")"
XOf course this won't work if the thing you give
X.I colon-mode
Xis a directory!  This example just dumps a remote file to stdout:
X.Ds
Xcsh> ncftp \-c wuarc:/graphics/gif/README
X\&...
Xcsh>
X.De
X.PP
XThis example redirects a remote file into a different
Xlocation:
X.Ds
Xcsh> ncftp \-c wu:/README > ~pdietz/thesis.tex
X.De
X.PP
XThis one shows how to use a pipeline:
X.Ds
Xcsh> ncftp \-c wuarc:/README | tail | wc \-l
X10
Xcsh>
X.De
X.PP
XThis shows how to page a remote file:
X.Ds
Xcsh> ncftp \-m wuarc:/graphics/gif/README
X\&...
Xcsh>
X.De
X.\"-------
X.SH "Supplying a port number with the open command"
X.\"-------
XThis option just didn't fit anywhere else, so to finish out the open command,
X.B \-p
Xlets you supply a port number if you have to
X.I ftp
Xto a site using an nonstandard port number.
XPersonally, I have yet to use this feature, but it is
Xthere for compatibility with the stock
X.I ftp
Xprogram.
X.\"-------
X.SH "Displaying and changing program variables"
X.\"-------
XNow I'll explain the commands unique to
X.IR NcFTP .
XThe others should perform the
Xsame as they would in the stock
X.I ftp
Xprogram;
Xconsult the man page for it if you want those explained,
Xor use the
X.I help
Xcommand for a brief blurb.
X.PP
XThe
X.I show
Xcommand is used to display program variables and their values.
X.Ds
Xshow all
X.De
X.PP
Xor
X.Ds
Xshow
X.De
X.PP
Xwould display all the variables with their values.
X.Ds
X.RI show " var1 var2 ... varN"
X.De
X.PP
Xwould display each specified variable and its value.
X.PP
XThe
X.I set
Xcommand changes the value of a program variable.
XIts syntax is:
X.Ds
X.RI set " varname value"
X.De
X.PP
XFor Boolean or Integer variables,
X.Ds
X.RI set " varname"
X.De
X.PP
Xwould set the value of the variable
X.I varname
Xto
X.B 1
X.RB ( true ).
X.PP
XThe
X.I unset
Xcommand can be used to set the variable to its default value,
Xor for Boolean and Integer variables, set the value of the variable to
X.B 0
X.RB ( false ).
XFor String variables, you can use this to set the value to an
Xempty string.
X.PP
XYou can use any of those three commands in both the command shell,
Xor in the RC file with a ``#'' prepended.
X.\"-------
X.SH "Program variables"
X.\"-------
XEach variable can be one of the following types:
X.TP
XBoolean:
XCan be
X.RB `` on ''
Xor
X.RB `` off ''
X(you can also use
X.RB `` 1 ''
Xor
X.RB `` 0 '').
X.TP
XInteger:
XCan be any positive or negative number, or
X.BR 0 .
X.TP
XString:
XIs a string of characters.
XIf the string needs to have a space
Xin it, make sure you surround the whole string with double quotes in a
X.I set
Xcommand.
X.PP
XVariables follow.
XSome variables are explained later in the relevant sections.
X.TP
X.IR anon\-open " (Boolean)"
XTells whether the default login mode is anonymous if
Xon, or if off, will prompt for a username/password.
XYou can always override this by using either
X.B \-a
Xor
X.B \-u
Xwith the
X.I open
Xcommand.
X.TP
X.IR anon\-password " (String)"
XSends this as the password when you login anonymously.
XBy default this is your email address.
X.TP
X.IR ansi\-escapes " (Boolean)"
XIf on, the program can use boldface, underline,
Xand inverse text.
X.TP
X.IR auto\-binary " (Boolean)"
XIf on, sets the transfer type to binary mode
Ximmediately after connection.
X.TP
X.IR debug " (Integer)"
XSets the debugging level.
X.TP
X.IR gateway\-login " (String)"
XTells which username to use when logging in to
Xyour firewall gateway host.
X.TP
X.IR gateway\-host " (String)"
XThe site which is acting as your firewall gateway,
Xor empty if you aren't using one.
X.TP
X.IR local\-dir " (String)"
XThe current local working directory.
XI like to set this from my RC file,
Xso all my files go into my download directory.
X.TP
X.IR logfile " (String)"
XThe name of your personal transfer log, or empty
Xif you aren't using a transfer log.
X.TP
X.IR logsize " (Integer)"
XThe maximum ceiling of your log file, before the program
Xremoves old entries.
X.TP
X.IR mprompt " (Boolean)"
XIf on, prompts for each remote file expanded from a
Xwildcard globbing expression.
X.TP
X.IR netrc " (String, Read-only)"
XTells you the name of the RC file in use.
X.TP
X.IR pager " (String)"
XThe pathname and flags of the program used to display
Xoutput one screenful at a time.
XThe default is the value of your $PAGER
Xenvironment variable.
X.TP
X.IR prompt " (String)"
XThe prompt specification that expands into the prompt.
X.TP
X.IR progress\-reports " (Integer)"
XWhich progress meter to use, or
X.B 0
Xif you don't want progress reports during file transfers.
XSet it to
X.B 1
Xfor a simple percentage meter;
X.B 2
Xfor a fancy bar graph indicator;
X.B 3
Xto print just the number of kilobytes transferred; or
X.B 4
Xto print one dot for each 10% transferred, if you
Xwant to avoid the use of backspaces.  Note that the program
Xmay use a different meter depending on how cooperative the
Xremote host is, and what you have the
X.I ansi\-escapes
Xvariable set to.
X.TP
X.IR recent\-list " (Boolean)"
XIf on, uses and updates the
X.I recent\-file.
X.TP
X.IR remote\-is\-unix " (Boolean)"
XSet automatically by the program upon connection,
Xyou may need to use this in a startup macro if the program guessed
Xthat a remote site was UNIX when it really is not.
X.TP
X.IR startup\-msg " (Boolean)"
XIf on, prints the opening message and tip.
X.TP
X.IR tips " (Boolean)"
XIf on, prints a tip on how to use the program better each
Xtime you run the program.
X.TP
X.IR type " (String)"
XThe name of the file transfer mode in use,
Xsuch as
X.RB `` binary ''
Xor
X.RB `` ascii ''.
X.TP
X.IR verbose " (String/Integer)"
XControls the amount of output spewed by the program.
XYou can supply either the first character of the name of the
Xverbosity level, or its number:
X.RS
X.TP
X.IR "Q" "uiet (\-1)"
XWon't print any output at all, even if an error occurs.
X.TP
X.IR "E" "rrors Only (0)"
XNo output, except when errors occur.
X.TP
X.IR "T" "erse (1)"
XPrints errors, and useful output from the remote host.
X.TP
X.IR "V" "erbose (2)"
XPrints everything, even junk output from the remote end.
X.RE
X.\"-------
X.SH "Listing a remote directory"
X.\"-------
XThe
X.I ls
Xand
X.I dir
Xcommands perform in a similar manner to those of the
Xstock
X.I ftp
Xprogram.
X.PP
XThe
X.I ls
Xcommand sends the FTP command ``NLST'' for you.
XThis command has been set so that it defaults
Xto always listing files in columns (this is the
X.B \-C
Xoption given to the UNIX
X.I ls
Xcommand) and appending
Xmetacharacters to each item name (this is the
X.B \-F
Xoption), so you can
Xsee which items are directories, files, links, etcetera.
XIf you don't want
Xyour items columnized, you can try using the
X.B \-1
Xoption with
X.I ls
Xto print one item per line.
X.PP
XThe
X.I dir
Xcommand sends the FTP command ``LIST'' for you, which instead
Xof printing just item names, it prints item sizes, owners, dates, and
Xpermissions as well.
XThis command is equivalent to
X.RB `` "ls \-l" ''
Xon most remote systems.
X.PP
XThe usage for both commands is the same.
XHere is the one for
X.IR ls :
X.PP
X.RS
X.B ls
X.RI [ \-flags ]
X.RI [ "directory and file names" ]
X.RI [ redirection ]
X.RE
X.PP
XNote that in this program, you can supply both flags and items to list in
Xthe same command.
XThe stock version of
X.I ftp
Xdoesn't let you do this:
X.Ds
Xls \-lrt /info\-mac/help
X.De
X.PP
XAnother thing that the program does which the others should have done is
Xlet you supply more than one item:
X.Ds
Xls \-lrt /info\-mac/help /pub /info\-mac/README
X.De
X.PP
XYou can also redirect the output into a file, or pipe it into something.
XThis example shows how to list the contents of the current remote directory,
Xand save the output into a file in the current local directory:
X.Ds
Xls \-t >ls.out
X.De
X.PP
XNote that for this to work, there must be no whitespace between the ``>''
Xand the filename, unlike your shell command line which allows for extra
Xwhitespace.
XThis will be (actually, is) fixed in a future version of the
Xprogram.
X.PP
XThese examples show how to use a pipe:
X.Ds
Xls \-t |tail
Xdir \-t "|less \-CM"
Xls \-t "|tail | wc"
X.De
X.PP
XLike the redirection example, there must be no whitespace between the first
Xpipe character and the rest of the stuff.
XThe trick is that it has to
Xappear as one argument to the commands.
XThe second and third examples
Xillustrate the use of double quotes to squeeze extra parameters in.
XThe second example can be done without all that typing.
XSee the descriptions of the
X.I pdir
Xand
X.I pls
Xcommands below.
X.\"-------
X.SH "Viewing a remote directory with your pager"
X.\"-------
XDidn't you hate it when you listed a remote directory, only to have most of
Xthe stuff scrolled off your terminal before you could read it?
XThe
X.I pls
Xand
X.I pdir
Xcommands take care of this for you.
XAs you might have guessed,
Xthey perform exactly like their regular counterparts,
Xonly you view them with your pager.
XThe pager to use is controlled by the
X.I pager
Xprogram variable.
X.\"-------
X.SH "Redisplaying the last directory listing"
X.\"-------
XThe program saves the listing into a local buffer,
Xso if you need to see it again (probably forgot about
X.IR pdir )
Xyou can use the
X.I redir
Xand
X.I predir
Xcommands for this.
X.\"-------
X.SH "Fetching files from the remote host"
X.\"-------
XThe
X.I get
Xand
X.I mget
Xretrieve remote files for you.
XThe usage for
X.I get
Xis:
X.Ds
Xget remote\-file [local\-file or redirection]
X.De
X.PP
XTo fetch
X.B /pub/README
Xand write it as a file named
X.BR ./junk/readme ,
Xtry:
X.Ds
Xget /pub/README ./junk/readme
X.De
X.PP
XTo fetch
X.B /pub/README
Xand write it as
X.BR ./README ,
Xjust do:
X.Ds
Xget /pub/README
X.De
X.PP
XThis lets you fetch a file using its whole pathname, and write a copy of
Xit in the current directory, without having to bother with typing a local
Xfilename.
XIn the unlikely event that you have write permission to a
Xdirectory called
X.B /pub
Xon your local machine, it would write
X.RB `` README ''
Xin that directory.
X.PP
XMost of the time the file you want will be in the current remote directory,
Xso you can just do these:
X.Ds
Xget README
Xget README ./junk/readme
X.De
X.PP
XYou can also use a redirection for
X.IR get ,
Xjust like you can with the
X.IR ls ", " dir ", and " redir
Xcommands.
XAs described earlier, you have
Xto conform to the format below for this release of the program:
X.Ds
Xget README >/dev/null
Xget README |head
Xget README "|head \-8"
Xget README "|less \-EMi"
X.De
X.PP
XThe last example is facilitated by the
X.I page
Xcommand described later.
X.PP
XThe
X.I get
Xcommand can also use a wildcard expression in an attempt to
Xmatch exactly one remote file.
XI call it ``Poor Man's File Completion.''
XIf you've done a remote listing, and you decide you want to download a
Xfile by the name of
X.RB `` obnoxiouslylongpackagename.tar.Z '',
Xyou can use
X``PMFC'' to save some keystrokes.
XChoose an expression that will only
Xmatch that one file, then use it with
X.IR get :
X.Ds
Xget obn*.Z a.tar.Z
X.De
X.PP
XIf your pattern was unique,
X.I get
Xwill fetch that file only.
XIf the pattern matched more than one file, the program will bitch and moan.
X.PP
XThe
X.I mget
Xcommand is used to fetch many files at a time.
XThe difference between
X.I get
Xand
X.I mget
Xis that
X.I get
Xlets you write only one file,
Xbut you can put it in a different directory, while
X.I mget
Xfetches many files,
Xalways writing them in the current local directory.
XThis example fetches several remote files at once:
X.Ds
Xmget a.file.Z b.file.Z c.tar d.tar.Z
X.De
X.PP
XThe
X.I mget
Xcommand, and its ugly sisters,
X.I mput
Xand
X.I mdelete
Xlet you use wildcard expressions.
XI could have done the previous example as:
X.Ds
Xmget *.Z c.tar
X.De
X.PP
Xinstead.
XThe ``m'' commands will verify each file,
Xif you have the program variable
X.I mprompt
Xset.
X.\"-------
X.SH "Viewing a remote file with your pager"
X.\"-------
XIf you would like to read a file on the remote host without saving a copy
Xof it on your machine, you can use the
X.I page
X(or
X.I more
Xif you wish) command:
X.Ds
Xpage README
Xpage obn*README
Xpage README.Z
X.De
X.PP
XThe second example show that you can use ``PMFC'' like you can for
X.IR get.
XThe third example will work also, because if the program knows how to
Xdecompress the file, it will do so before feeding it to your pager.
XAs stated earlier,
Xyou can change the program to use to page by setting the program variable
X.IR pager.
X.\"-------
X.SH "Creating a message file on the remote host"
X.\"-------
XUse the
X.I create
Xan empty file on the remote site.
XSometimes it is necessary to leave a note if you can't get in touch
Xwith the remote site's administrator.
XFor example if a file is corrupted, you could try:
X.Ds
Xcreate Foo.tar_is_corrupt
X.De
X.PP
Xin hopes that the original uploader will replace it.
X.\"-------
X.SH "Looking up site names and addresses"
X.\"-------
XYou can use the program's builtin
X.RI mini- nslookup
Xfacility.
XIf you wanted to know the site's IP number, but only knew the name you
Xcould do:
X.Ds
Xlookup cse.unl.edu
X.De
X.PP
XThis would spit out IP number for that site, in this case ``129.93.1.12''.
XIf you needed to know what a site's name was, but only knew the IP number,
Xtry:
X.Ds
Xlookup 129.93.1.12
X.De
X.PP
XThis would spit out the name for that site, in this case ``cse.unl.edu''.
X.\"-------
X.SH "Checking the configuration of the program"
X.\"-------
XUse the
X.I version
Xcommand to print version and compilation information about the program.
XThis will also tell you which optional features are
Xcompiled into the program, such as logging to the system log and which
Xcommand line editor (if any) has been installed.
X.PP
XThe author's email address is listed, and if you need to report something,
Xsend the output of this command along with your message.
X.\"-------
X.SH "Using the command shell"
X.\"-------
XJust like the stock
X.I ftp
Xprogram, you type commands to it until you get
Xbored and hit either ^D or type the
X.I quit
Xcommand.
X.PP
XThe program supports links to popular command line editing libraries.
XIf the person who compiled it went to the effort, you will be able to
Xedit the command line with arrow keys and other editing commands, and also
Xscroll up and down in the command line history, usually with the up and
Xdown arrows.
XYou can check the
X.I version
Xcommand to see if either
X``GETLINE'' or ``READLINE'' are installed.
X.\"-------
X.SH "Customizing the prompt"
X.\"-------
XYou can set the shell's prompt string to whatever you like.
XYou can use several metacharacters that expand into something each prompt.
XThe
X.RB `` % ''
Xflags are passed to
X.IR strftime (3),
Xso you can put the date or time in the prompt formatted as you like it:
X.Ds
Xset prompt "%I:%M ncftp>"
X.De
X.PP
XThat would insert the current time in the prompt.
X.PP
XThe
X.RB `` @ ''
Xflags are expanded by the program itself.
XHere's the list of them.
X.PP
XIf you have an ANSI-compatible terminal, or you have the program variable
X.I ansi\-escapes
Xset, you can use
X.BR @B ,
X.BR @I ,
Xand
X.B @U
Xto turn on boldface,
Xinverse, and underline text respectively (otherwise they won't insert
Xanything).
XYou can also use
X.B @R
Xto turn on inverse (reverse) text.
X.B @P
Xsets the text back to plain text.
X.PP
X.B @D
XInserts the full path of the current remote directory.
XThe
X.B @J
Xflag is similar except it inserts only the directory name.
X.PP
X.B @H
XInserts the name of the remote host.
X.B @C
Xinserts the host and current
Xdirectory path in
X.I "colon-mode"
Xformat, such as
X``cse.unl.edu:/pub/mgleason'', or ``(not connected)''.
XThe
X.B @c
Xflag is similar, only it will insert ``cse.unl.edu:/pub/mgleason'' and a
Xnewline if connected, otherwise it prints nothing.
XThe default prompt uses
Xthis flag to print a two line prompt when connected and a one line prompt
Xwhen not connected.
X.PP
X.BR @E " or " @!
Xinserts the event number (how many commands you've typed).
X.PP
X.B @M
Xinserts ``(Mail)\0'' if mail has arrived since running the program.
X.PP
X.B @N
Xinserts a newline character.
X.\"-------
X.SH "Keeping a log of your file transfers"
X.\"-------
XYou can have the program keep a personal log file.
XI find it is useful so I can see where I got a certain file,
Xor what the name of that site was I called two weeks ago.
X.PP
XTo use a log, add:
X.Ds
X#set logfile ~/.ftplog
X.De
X.PP
X(or whatever you want to name the log) to your RC file.
XI don't want my log growing too large and using up all my disk space,
Xso I also have:
X.Ds
X#set logsize 10240
X.De
X.PP
Xin my RC file.
XIf you set the limit on the maximum log size, the program will
Xkeep the log file at or below that size, discarding old entries.
X.PP
XNote that this is different from having SYSLOG appear in the
X.I version
Xcommand's output.
XWhen this is on, your actions are recorded to the system
Xlog, so your system administrator can make sure you aren't doing anything
X``bad.''
X.\"-------
X.SH "Program options"
X.\"-------
XRemember that you can treat the command line like an
X.I open
Xcommand,
Xso all lowercase options are passed to the
X.I open
Xcommand, and the
Xuppercase options are handled by the main program.
XThe uppercase options
Xare described below; refer to the
X.I open
Xcommand for descriptions of its options.
X.TP
X.BI \-D " x"
Xsets the debugging level to
X.IR x .
X.TP
X.B \-H
Xruns the
X.I version
Xcommand and exits, so you can save the output of
Xit to use when you need to mail me something.
X.TP
X.B \-I
Xtoggles the mprompt variable; this is provided for compatibility with
X.RB `` "ftp \-i" ''.
X.TP
X.B \-N
Xdisables reading of the RC file;
Xthis is provided for compatibility with
X.RB `` "ftp \-n" ''.
X.TP
X.BI \-V " x"
Xsets verbosity to level
X.I x
X.RB ( \-1 ,
X.BR 0 ,
X.BR 1 ,
X.BR 2 )
Xor
X.RB ( quiet ,
X.BR errs ,
X.BR terse ,
X.BR verbose ).
XSee the description of the
X.I verbose
Xprogram variable for more information.
X.PP
XHere are some example command lines.
XAgain, see the description of the
X.I open
Xcommand (especially
X.IR "colon-mode" " and " "FTP\-cat mode" ")"
Xand all its functions for more information.
X.PP
XThis just enters the
X.I NcFTP
Xcommand shell:
X.Ds
Xcsh> ncftp
X.De
X.PP
XThis fetches
X.B CONTENTS
Xand then quits:
X.Ds
Xcsh> ncftp cse.unl.edu:/pub/mgleason/CONTENTS
X.De
X.PP
XSome others examples, with open options and main program options mixed in:
X.Ds
Xcsh> ncftp \-V quiet \-u ftp.unl.edu
Xcsh> ncftp \-c cse.unl.edu:/pub/mgleason/CONTENTS
Xcsh> ncftp \-D 2 \-r \-d 120 \-g 10 \-N ftp.unl.edu
X.De
X.\"-------
X.SH "A sample RC file"
X.\"-------
XHere is a sample RC file:
X.ta 6m +6m
X.Ds
X#set logfile ~/.ftplog
X#set progress\-reports 2
X#set local\-dir /usr/tmp/zz
X#set prompt "@B@E @UNcFTP@P @B@M@D@P \->"
X.sp
Xmachine sumex\-aim.stanford.edu
X	macdef init
X		cd /info\-mac
X		get ./help/recent\-files.txt "|grep \-v '.abs' > sumex"
X		!less sumex
X		pwd
X.sp
X# This site is in here just so I can use ``apple''
X# as an abbreviation.
Xmachine ftp.apple.com
X.sp
X# NcFTP will only ask for your password:
Xmachine cse.unl.edu
X	login mgleason
X.sp
X# You can supply a login and a password:
Xmachine fake.machine.unl.edu
X	login mgleason
X	password mypass
X	macdef init
X	cd ./foo/bar
X.sp
X# If an antiquated non-UNIX machine doesn't use
X# the "SYST" command, you may need to unset
X# remote\-is\-unix, if the remote host complains
X# about ``ls \-CF''.
Xmachine some.vms.unl.edu
X	macdef init
X	unset remote\-is\-unix
X.sp
X.De
X.\"-------
X.SH "AUTHORS"
X.\"-------
X.I NcFTP
Xwas written by Mike Gleason,
X.I NCEMRSoft
X(mgleason@cse.unl.edu), and based on code by the authors of the
X.I ftp
Xfrom the BSD 4.3 distribution.
X.I NcFTP
Xis copyrighted 1992, 1993 by NCEMRSoft
Xand 1985, 1989 by the Regents of California.
X.PP
XIdeas and some code contributed by Phil Dietz,
X.I NCEMRSoft
X(pdietz@cse.unl.edu).
XTesting and debugging done by Phil and
XKok Hon Yin (hkok@cse.unl.edu).
X.PP
XExtensive man page formatting work
Xby DaviD W. Sanderson (dws@ssec.wisc.edu).
X.\"-------
X.SH "BUGS"
X.\"-------
XCorrect execution of many commands depends upon proper behavior
Xby the remote server.
X.PP
XThe remote server may drop the connection if you take a long time to
Xpage remote files.
X.PP
XTermcap padding is not correctly displayed.
X.PP
XThere are no such sites named
X.I bowser.nintendo.jp
Xor
X.IR sphygmomanometer.unl.edu .
X.\"-------
X.SH "SEE ALSO"
X.\"-------
X.IR strftime (3),
X.IR ftpd (8),
X.IR ftp (1),
X.IR nslookup (1),
X.IR compress (1),
X.IR gzip (1),
X.IR zcat (1),
X.IR fsp (1),
X.IR archie (1),
X.IR tftp (1).
END_OF_FILE
  if test 33759 -ne `wc -c <'ncftp.1'`; then
    echo shar: \"'ncftp.1'\" unpacked with wrong size!
  fi
  # end of 'ncftp.1'
fi
if test -f 'open.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'open.c'\"
else
  echo shar: Extracting \"'open.c'\" \(16566 characters\)
  sed "s/^X//" >'open.c' <<'END_OF_FILE'
X/* open.c */
X
X/*  $RCSfile: open.c,v $
X *  $Revision: 1.1 $
X *  $Date: 93/07/09 11:27:07 $
X */
X
X#include "sys.h"
X
X#include <netdb.h>
X#include <netinet/in.h>
X#include <arpa/ftp.h>
X
X#include <errno.h>
X
X#include "util.h"
X#include "open.h"
X#include "cmds.h"
X#include "ftp.h"
X#include "ftprc.h"
X#include "main.h"
X#include "defaults.h"
X#include "copyright.h"
X
X/* open.c globals */
Xint					remote_is_unix;		/* TRUE if remote host is unix. */
Xint					auto_binary = dAUTOBINARY;
Xint					anon_open = dANONOPEN;
X										/* Anonymous logins by default? */
Xint					connected = 0;		/* TRUE if connected to server */
X										/* If TRUE, set binary each connection. */
XHostname			hostname;			/* Name of current host */
X#ifdef GATEWAY
Xstring				gateway;			/* node name of firewall gateway */
Xstring				gate_login;			/* login at firewall gateway */
X#endif
X
X/* open.c externs */
Xextern char					*reply_string, *line, *Optarg, *margv[];
Xextern int					Optind, margc, verbose, macnum;
Xextern long					eventnumber;
Xextern struct servent		serv;
Xextern FILE					*cout;
Xextern string				anon_password;
X
X/* Given a pointer to an OpenOptions (structure containing all variables
X * that can be set from the command line), this routine makes sure all
X * the variables have valid values by setting them to their defaults.
X */
X 
Xvoid InitOpenOptions(OpenOptions *openopt)
X{
X	/* How do you want to open a site if neither -a or -u are given?
X	 * anon_open is true (default to anonymous login), unless
X	 * defaults.h was edited to set dANONOPEN to 0 instead.
X	 */
X	openopt->openmode = anon_open ? openImplicitAnon : openImplicitUser;
X
X	/* Normally you don't want to ignore the entry in your netrc. */
X	openopt->ignore_rc = 0;
X
X	/* Set the default delay if the user specifies redial mode without
X	 * specifying the redial delay.
X	 */
X	openopt->redial_delay = dREDIALDELAY;
X
X	/* Normally, you only want to try once. If you specify redial mode,
X	 * this is changed.
X	 */
X	openopt->max_dials = 1;
X	
X	/* You don't want to cat the file to stdout by default. */
X	openopt->ftpcat = NO_FTPCAT;
X
X	/* Setup the port number to try. */
X#ifdef dFTP_PORT
X	/* If dFTP_PORT is defined, we use a different port number by default
X	 * than the one supplied in the servent structure.
X	 */
X	openopt->port = dFTP_PORT;
X	/* Make sure the correct byte order is supplied! */
X	openopt->port = htons(openopt->port);
X#else
X	/* Use the port number supplied by the operating system's servent
X	 * structure.
X	 */
X	openopt->port = serv.s_port;
X#endif
X
X	/* We are not in colon-mode (yet). */
X	openopt->colonmodepath[0] = 0;
X
X	/* Set the hostname to a null string, since there is no default host. */
X	openopt->hostname[0] = 0;
X	
X	/* Set the opening directory path to a null string. */
X	openopt->cdpath[0] = 0;
X}	/* InitOpenOptions */
X
X
X
X
X/* This is responsible for parsing the command line and setting variables
X * in the OpenOptions structure according to the user's flags.
X */
X
Xint GetOpenOptions(int argc, char **argv, OpenOptions *openopt)
X{
X	int					opt;
X	char				*cp;
X
X	/* First setup the openopt variables. */
X	InitOpenOptions(openopt);
X
X	/* Tell Getopt() that we want to start over with a new command. */
X	Getopt_Reset();
X	while ((opt = Getopt(argc, argv, "aiup:rd:g:cm")) >= 0) {
X		switch (opt) {		
X			case 'a':
X				/* User wants to open anonymously. */
X				openopt->openmode = openExplicitAnon;
X				break;
X				
X			case 'u':
X				/* User wants to open with a login and password. */
X				openopt->openmode = openExplicitUser;
X				break;
X				
X			case 'i':
X				/* User wants to ignore the entry in the netrc. */
X				openopt->ignore_rc = 1;
X				break;
X				
X			case 'p':
X				/* User supplied a port number different from the default
X				 * ftp port.
X				 */
X				openopt->port = atoi(Optarg);
X				if (openopt->port <= 0) {
X					/* Probably never happen, but just in case. */
X					(void) printf("%s: bad port number (%s).\n", argv[0], Optarg);
X					goto usage;
X				}
X				/* Must ensure that the port is in the correct byte order! */
X				openopt->port = htons(openopt->port);
X				break;
X				
X			case 'd':
X				/* User supplied a delay (in seconds) that differs from
X				 * the default.
X				 */
X				openopt->redial_delay = atoi(Optarg);
X				break;
X				
X			case 'g':
X				/* User supplied an upper-bound on the number of redials
X				 * to try.
X				 */
X				openopt->max_dials = atoi(Optarg);
X				break;
X
X			case 'r':
X				openopt->max_dials = -1;
X				break;
X
X			case 'm':
X				/* ftpcat mode is only available from your shell command-line,
X				 * not from the ncftp shell.  Do that yourself with 'more zz'.
X				 */
X				if (eventnumber == 0L) {
X					/* If eventnumber is zero, then we were called directly
X					 * from main(), and before the ftp shell has started.
X					 */
X					openopt->ftpcat = FTPMORE;
X					/* ftpcat mode is really ftpmore mode. */
X					break;
X				} else {
X					fprintf(stderr,
X"You can only use this form of colon-mode (-m) from your shell command line.\n\
XTry 'ncftp -m wuarchive.wustl.edu:/README'\n");
X					goto usage;
X				}
X				break;
X
X			case 'c':
X				/* ftpcat mode is only available from your shell command-line,
X				 * not from the ncftp shell.  Do that yourself with 'get zz -'.
X				 */
X				if (eventnumber == 0L) {
X					/* If eventnumber is zero, then we were called directly
X					 * from main(), and before the ftp shell has started.
X					 */
X					openopt->ftpcat = FTPCAT;
X					break;
X				} else {
X					fprintf(stderr,
X"You can only use ftpcat/colon-mode from your shell command line.\n\
XTry 'ncftp -c wuarchive.wustl.edu:/README > file.'\n");
X					goto usage;
X				}
X				break;
X				
X			default:
X			usage:
X				return USAGE;
X		}
X	}
X
X	if (argv[Optind] == NULL) {
X		/* No host was supplied.  Print out the list of sites we know
X		 * about and ask the user for one.
X		 */
X		PrintSiteList();
X		(void) Gets("(site to open) ", openopt->hostname, sizeof(openopt->hostname));
X		/* Make sure the user just didn't hit return, in which case we
X		 * just give up and go home.
X		 */
X		if (openopt->hostname[0] == 0)
X			goto usage;
X	} else {
X		/* The user gave us a host to open.
X		 *
X		 * First, check to see if they gave us a colon-mode path
X		 * along with the hostname.
X		 */
X		if ((cp = index(argv[Optind], ':')) != NULL) {
X			*cp++ = 0;
X			(void) Strncpy(openopt->colonmodepath, cp);
X		}	
X		(void) Strncpy(openopt->hostname, argv[Optind]);
X	}
X	return NOERR;
X}	/* GetOpenOptions */
X
X
X
X
X/* This examines the format of the string stored in the hostname
X * field of the OpenOptions, and sees if has to strip out a colon-mode
X * pathname (to store in the colonmodepath field).  Since colon-mode
X * is run quietly (without any output being generated), we init the
X * login_verbosity variable here to quiet if we are running colon-mode.
X */
Xint CheckForColonMode(OpenOptions *openopt, int *login_verbosity)
X{
X	/* Usually the user doesn't supply hostname in colon-mode format,
X	 * and wants to interactively browse the remote host, so set the
X	 * login_verbosity to whatever it is set to now.
X	 */
X	*login_verbosity = verbose;
X
X	if (openopt->colonmodepath[0] != 0) {
X		/* But if the user does use colon-mode, we want to do our business
X		 * and leave, without all the login messages, etc., so set
X		 * login_verbosity to quiet so we won't print anything until
X		 * we finish.  Colon-mode can be specified from the shell command
X		 * line, so we would like to be able to execute ncftp as a one
X		 * line command from the shell without spewing gobs of output.
X		 */
X		*login_verbosity = V_QUIET;
X	} else if (openopt->ftpcat != 0) {
X		/* User specified ftpcat mode, but didn't supply the host:file. */
X		(void) fprintf(stderr, "You didn't use colon mode correctly.\n\
XIf you use -c or -m, you need to do something like this:\n\
X	ncftp -c wuarchive.wustl.edu:/pub/README (to cat this file to stdout).\n");
X		return USAGE;
X	}
X	return NOERR;
X}	/* CheckForColonMode */
X
X
X
X
X/* All this short routine does is to hookup a socket to either the
X * remote host or the firewall gateway host.
X */
Xint HookupToRemote(OpenOptions *openopt)
X{
X	int hErr;
X
X#ifdef GATEWAY
X	/* Try connecting to the gateway host. */
X	if (*gateway) {
X		hErr = hookup(gateway, openopt->port);
X		(void) Strncpy(hostname, openopt->hostname);
X	} else
X#endif
X		hErr = hookup(openopt->hostname, openopt->port);
X	
X	return hErr;
X}	/* HookupToRemote */
X
X
X
X
Xvoid CheckRemoteSystemType(int force_binary)
X{
X	int tmpverbose;
X	char *cp, c;
X
X	/* As of this writing, UNIX is pretty much standard. */
X	remote_is_unix = 1;
X
X	/* Do a SYSTem command quietly. */
X	tmpverbose = verbose;
X	verbose = V_QUIET;
X	if (command("SYST") == COMPLETE) {
X		if (tmpverbose == V_VERBOSE) {		
X			/* Find the system type embedded in the reply_string,
X			 * and separate it from the rest of the junk.
X			 */
X			cp = index(reply_string+4, ' ');
X			if (cp == NULL)
X				cp = index(reply_string+4, '\r');
X			if (cp) {
X				if (cp[-1] == '.')
X					cp--;
X				c = *cp;
X				*cp = '\0';
X			}
X
X			(void) printf("Remote system type is %s.\n",
X				reply_string+4);
X			if (cp)
X				*cp = c;
X		}
X		remote_is_unix = !strncmp(reply_string + 4, "UNIX", (size_t) 4);
X	}
X
X	/* Set to binary mode if any of the following are true:
X	 * (a) The user has auto-binary set;
X	 * (b) The user is using colon-mode (force_binary);
X	 * (c) The reply-string from SYST said it was UNIX with 8-bit chars.
X	 */
X	if (auto_binary || force_binary
X		|| !strncmp(reply_string, "215 UNIX Type: L8", (size_t) 17)) {
X		(void) _settype("binary");
X		if (tmpverbose > V_TERSE)
X		    (void) printf("Using binary mode to transfer files.\n");
X	}
X
X	/* Print a warning for that (extremely) rare Tenex machine. */
X	if (tmpverbose >= V_ERRS && 
X	    !strncmp(reply_string, "215 TOPS20", (size_t) 10)) {
X		(void) _settype("tenex");
X		(void) printf("Using tenex mode to transfer files.\n");
X	}
X	verbose = tmpverbose;
X}	/* CheckRemoteSystemType */
X
X
X
X/* This is called if the user opened the host with a file appended to
X * the host's name, like "wuarchive.wustl.edu:/pub/readme," or
X * "wuarchive.wustl.edu:/pub."  In the former case, we open wuarchive,
X * and fetch "readme."  In the latter case, we open wuarchive, then set
X * the current remote directory to "/pub."  If we are fetching a file,
X * we can do some other tricks if "ftpcat mode" is enabled.  This mode
X * must be selected from your shell's command line, and this allows you
X * to use the program as a one-liner to pipe a remote file into something,
X * like "ncftp -c wu:/pub/README | wc."  If the user uses ftpcat mode,
X * the program immediately quits instead of going into it's own command
X * shell.
X */
Xvoid ColonMode(OpenOptions *openopt)
X{
X	int tmpverbose;
X
X	/* How do we tell if colonmodepath is a file or a directory?
X	 * We first try cd'ing to the path first.  If we can, then it
X	 * was a directory.  If we could not, we'll assume it was a file.
X	 */
X
X	/* Shut up, so cd won't print 'foobar: Not a directory.' */
X	tmpverbose = verbose;
X	verbose = V_QUIET;
X
X	/* If we are using ftpcat|more mode, or we couldn't cd to the
X	 * colon-mode path (then it must be a file to fetch), then
X	 * we need to fetch a file.
X	 */
X	if (openopt->ftpcat || ! _cd(openopt->colonmodepath)) {
X		/* We call the appropriate fetching routine, so we have to
X		 * have the argc and argv set up correctly.  To do this,
X		 * we just make an entire command line, then let makeargv()
X		 * convert it to argv/argc.
X		 */
X		if (openopt->ftpcat == FTPCAT)
X			(void) sprintf(line, "get %s -", openopt->colonmodepath);
X		else if (openopt->ftpcat == FTPMORE)
X			(void) sprintf(line, "more %s", openopt->colonmodepath);
X		else {
X			/* Regular colon-mode, where we fetch the file, putting the
X			 * copy in the current local directory.
X			 */
X			(void) sprintf(line, "mget %s", openopt->colonmodepath);
X		}
X		makeargv();
X
X		/* Turn on messaging if we aren't catting. */
X		if (openopt->ftpcat == 0)
X			verbose = tmpverbose;
X		
X		/* get() also handles 'more'. */
X		if (openopt->ftpcat)
X			(void) get(margc, margv);
X		else
X			(void) mget(margc, margv);
X
X		/* If we were invoked from the command line, quit
X		 * after we got this file.
X		 */
X		if (eventnumber == 0L) {
X			(void) quit(0, NULL);
X		}
X	}
X	verbose = tmpverbose;
X}	/* ColonMode */
X
X
X
X
X/* Given a properly set up OpenOptions, we try connecting to the site,
X * redialing if necessary, and do some initialization steps so the user
X * can send commands.
X */
Xint Open(OpenOptions *openopt)
X{
X	int					hErr;
X	int					dials;
X	char				*ruser, *rpass, *racct;
X	int					siteInRC;
X	char				*user, *pass, *acct;	
X	int					login_verbosity, oldv;
X
X	macnum = 0;	 /* Reset macros. */
X
X	/* If the hostname supplied is in the form host.name.str:/path/file,
X	 * then colon mode was used, and we need to fix the hostname to be
X	 * just the hostname, copy the /path/file to colonmode path, and init
X	 * the login_verbosity variable.
X	 */
X	if (CheckForColonMode(openopt, &login_verbosity) == USAGE)
X		return USAGE;
X
X	/* If the hostname supplied was an abbreviation, such as just
X	 * "wu" (wuarchive.wustl.edu), look through the list of sites
X	 * we know about and get the whole name.  We also would like
X	 * the path we want to start out in, if it is available.
X	 */
X	GetFullSiteName(openopt->hostname, openopt->cdpath);
X
X#ifdef GATEWAY
X	/* Make sure the gateway host name is a full name and not an
X	 * abbreviation.
X	 */
X	if (*gateway)
X		GetFullSiteName(gateway, NULL);
X#endif
X
X	ruser = rpass = racct = NULL;
X	/* This also loads the init macro. */
X	siteInRC = ruserpass2(openopt->hostname, &ruser, &rpass, &racct);
X	if (ISANONOPEN(openopt->openmode)) {
X		user = "anonymous";
X		pass = anon_password;
X	} else {
X		user = NULL;
X		pass = NULL;
X	}
X	acct = NULL;
X	
X	if (siteInRC && !openopt->ignore_rc) {
X		acct = racct;
X		if (ruser != NULL) {
X			/* We were given a username.  If we were given explicit
X			 * instructions from the command line, follow those and
X			 * ignore what the RC had.  Otherwise if no -a or -u
X			 * was specified, we use whatever was in the RC.
X			 */
X			if (ISIMPLICITOPEN(openopt->openmode)) {
X				user = ruser;
X				pass = rpass;
X			}
X		}		
X	}
X
X	for (
X			dials = 0;
X			openopt->max_dials < 0 || dials < openopt->max_dials;
X			dials++)
X	{
X		if (dials > 0) {
X			/* If this is the second dial or higher, sleep a bit. */
X			(void) sleep(openopt->redial_delay);
X			(void) fprintf(stderr, "Retry Number: %d\n", dials + 1);
X		}
X
X		if ((hErr = HookupToRemote(openopt)) == -2)	
X			/* Recoverable, so we can try re-dialing. */
X			continue;
X		else if (hErr == NOERR) {
X			/* We were hookup'd successfully. */
X			connected = 1;
X
X		oldv = verbose;  verbose = login_verbosity;
X		
X#ifdef GATEWAY
X			if (*gateway) {
X				if ((Login(
X					user,
X					pass,
X					acct,
X					(!openopt->ignore_rc && !openopt->colonmodepath[0])
X				) != NOERR) || cout == NULL)
X					goto nextdial;		/* error! */
X			}
X#endif
X
X#ifdef GATEWAY
X			if (!*gateway) {
X#endif
X				/* We don't want to run the init macro for colon-mode. */
X				if ((Login(
X						user,
X						pass,
X						acct,
X						(!openopt->ignore_rc && !openopt->colonmodepath[0])
X					) != NOERR) || cout == NULL)
X				{
X					goto nextdial;		/* error! */
X				}
X#ifdef GATEWAY
X			}
X#endif
X
X			verbose = oldv;
X
X			/* We need to check for unix and see if we should set binary
X			 * mode automatically.
X			 */
X			CheckRemoteSystemType(openopt->colonmodepath[0] != (char)0);
X
X			if (openopt->colonmodepath[0]) {
X				ColonMode(openopt);
X			} else if (openopt->cdpath[0]) {
X				/* If we didn't have a colon-mode path, we try setting
X				 * the current remote directory to cdpath.  cdpath is
X				 * usually the last directory we were in the previous
X				 * time we called this site.
X				 */
X				(void) _cd(openopt->cdpath);
X			} else {
X				/* Freshen 'cwd' variable for the prompt. 
X				 * We have to do atleast one 'cd' so our variable
X				 * cwd (which is saved by _cd()) is set to something
X				 * valid.
X				 */
X				(void) _cd(NULL);
X			}
X			break;	/* we are connected, so break the redial loop. */
X			/* end if we are connected */
X		} else {
X			/* Irrecoverable error, so don't bother redialing. */
X			/* The error message should have already been printed
X			 * from Hookup().
X			 */
X			break;
X		}
Xnextdial: continue;	/* Try re-dialing. */
X	}
X	return (NOERR);
X}	/* Open */
X
X
X
X/* This stub is called by our command parser. */
Xint cmdOpen(int argc, char **argv)
X{
X	OpenOptions			openopt;
X
X	/* If there is already a site open, close that one so we can
X	 * open a new one.
X	 */
X	if (connected && NOT_VQUIET && hostname[0]) {
X		(void) printf("Closing %s...\n", hostname);
X		(void) disconnect(0, NULL);
X	}
X
X	if ((GetOpenOptions(argc, argv, &openopt) == USAGE) ||
X		(Open(&openopt) == USAGE))
X		return USAGE;
X	return NOERR;
X}	/* cmdOpen */
X
X/* eof open.c */
END_OF_FILE
  if test 16566 -ne `wc -c <'open.c'`; then
    echo shar: \"'open.c'\" unpacked with wrong size!
  fi
  # end of 'open.c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
