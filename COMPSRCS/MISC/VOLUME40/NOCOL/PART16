Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i146:  nocol - Network Monitoring System, Part16/26
Message-ID: <1993Nov23.212715.21794@sparky.sterling.com>
X-Md4-Signature: 6ef5a56089ff8473e6a93cd3fa2036fb
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 23 Nov 1993 21:27:15 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 146
Archive-name: nocol/part16
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c
#   nocol-3.0/src/cmu-snmp/man/snmpget.1
#   nocol-3.0/src/cmu-snmp/snmplib/mib.c
#   nocol-3.0/src/perlnocol/nocollib.pl
#   nocol-3.0/src/pingmon/pingmon.c nocol-3.0/src/tpmon/main.c
# Wrapped by kent@sparky on Tue Nov  9 22:22:21 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 16 (of 26)."'
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c'\" \(14030 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X/*
X * Copyright (c) 1983,1988 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms are permitted
X * provided that this notice is preserved and that due credit is given
X * to the University of California at Berkeley. The name of the University
X * may not be used to endorse or promote products derived from this
X * software without specific prior written permission. This software
X * is provided ``as is'' without express or implied warranty.
X */
X
X#include <strings.h>
X#include <stdio.h>
X
X#include <sys/param.h>
X#include <sys/socket.h>
X
X#include <netinet/in.h>
X
X#include <netdb.h>
X
X#include "main.h"
X#include "asn1.h"
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "snmp_api.h"
X#include "snmp_client.h"
X#include "mib.h"
X
Xextern	int aflag;
Xextern	int nflag;
Xextern	char *plural();
Xextern	char *malloc();
Xextern	struct snmp_session *Session;
Xextern	struct variable_list *getvarbyname();
X
X
Xchar	*inetname();
X
Xstruct stat_table {
X    int	    entry;  /* entry number in table */
X    /* format string to printf(description, value, plural(value)); */
X    /* warning: the %d must be before the %s */
X    char    description[80];
X};
X
Xstatic oid oid_ipstats[] = {1, 3, 6, 1, 2, 1, 4, 0, 0};
Xstruct stat_table ip_stattab[] = {
X    {3, "%d total datagram%s received"},
X    {4, "%d datagram%s with header errors"},
X    {5, "%d datagram%s with an invalid destination address"},
X    {6, "%d datagram%s forwarded"},
X    {7, "%d datagram%s with unknown protocol"},
X    {8, "%d datagram%s discarded"},
X    {9, "%d datagram%s delivered"},
X    {10, "%d output datagram request%s"},
X    {11, "%d output datagram%s discarded"},
X    {12, "%d datagram%s with no route"},
X    {14, "%d fragment%s received"},
X    {15, "%d datagram%s reassembled"},
X    {16, "%d reassembly failure%s"},
X    {17, "%d datagram%s fragmented"},
X    {18, "%d fragmentation failure%s"},
X    {19, "%d fragment%s created"}
X};
X
Xstatic oid oid_udpstats[] = {1, 3, 6, 1, 2, 1, 7, 0, 0};
Xstruct stat_table udp_stattab[] = {
X    {1, "%d total datagram%s received"},
X    {2, "%d datagram%s to invalid port"},
X    {3, "%d datagram%s dropped due to errors"},
X    {4, "%d output datagram request%s"}
X};
X
Xstatic oid oid_tcpstats[] = {1, 3, 6, 1, 2, 1, 6, 0, 0};
Xstruct stat_table tcp_stattab[] = {
X    {5, "%d active open%s"},
X    {6, "%d passive open%s"},
X    {7, "%d failed attempt%s"},
X    {8, "%d reset%s of established connections"},
X    {9, "%d current established connection%s"},
X    {10, "%d segment%s received"},
X    {11, "%d segment%s sent"},
X    {12, "%d segment%s retransmitted"}
X};
X
Xstatic oid oid_icmpstats[] = {1, 3, 6, 1, 2, 1, 5, 0, 0};
Xstruct stat_table icmp_stattab[] = {
X    {1, "%d total message%s received"},
X    {2, "%d message%s dropped due to errors"},
X    {14, "%d ouput message request%s"},
X    {15, "%d output message%s discarded"}
X};
X
Xstruct stat_table icmp_inhistogram[] = {
X    {3, "Destination unreachable: %d"},
X    {4, "Time Exceeded: %d"},
X    {5, "Parameter Problem: %d"},
X    {6, "Source Quench: %d"},
X    {7, "Redirect: %d"},
X    {8, "Echo Request: %d"},
X    {9, "Echo Reply: %d"},
X    {10, "Timestamp Request: %d"},
X    {11, "Timestamp Reply: %d"},
X    {12, "Address Mask Request: %d"},
X    {13, "Addrss Mask Reply:%d"},
X};
X
Xstruct stat_table icmp_outhistogram[] = {
X    {16, "Destination unreachable: %d"},
X    {17, "Time Exceeded: %d"},
X    {18, "Parameter Problem: %d"},
X    {19, "Source Quench: %d"},
X    {20, "Redirect: %d"},
X    {21, "Echo Request: %d"},
X    {22, "Echo Reply: %d"},
X    {23, "Timestamp Request: %d"},
X    {24, "Timestamp Reply: %d"},
X    {25, "Address Mask Request: %d"},
X    {26, "Addrss Mask Reply:%d"},
X};
X
Xstruct tcpconn_entry {
X    oid	    instance[10];
X    struct in_addr  localAddress;
X    int	    locAddrSet;
X    u_short localPort;
X    int	    locPortSet;
X    struct in_addr  remoteAddress;
X    int	    remAddrSet;
X    u_short remotePort;
X    int	    remPortSet;
X    int	    state;
X    int	    stateSet;
X    struct tcpconn_entry *next;
X};
X
X#define TCPCONN_STATE	1
X#define TCPCONN_LOCADDR	2
X#define TCPCONN_LOCPORT	3
X#define TCPCONN_REMADDR	4
X#define TCPCONN_REMPORT	5
X
X
X
Xstatic oid oid_tcpconntable[] = {1, 3, 6, 1, 2, 1, 6, 13, 1};
X#define ENTRY 9
X
Xchar *tcpstates[] = {
X    "",		    "CLOSED",	    "LISTEN",   "SYNSENT",
X    "SYNRECEIVED",  "ESTABLISHED",  "FINWAIT1", "FINWAIT2",
X    "CLOSEWAIT",    "LASTACK",	    "CLOSING",	"TIMEWAIT"
X};
X#define TCP_NSTATES 11
X
X/*
X * Print a summary of connections related to an Internet
X * protocol (currently only TCP).  For TCP, also give state of connection.
X */
Xprotopr(){
X    struct tcpconn_entry *tcpconn = NULL, *tp, *newp;
X    struct snmp_pdu *request, *response;
X    struct variable_list *vp;
X    oid *instance;
X    int first, status;
X
X    request = snmp_pdu_create(GETNEXT_REQ_MSG);
X
X    snmp_add_null_var(request, oid_tcpconntable, sizeof(oid_tcpconntable)/sizeof(oid));
X
X    while(1){
X	status = snmp_synch_response(Session, request, &response);
X	if (status != STAT_SUCCESS || response->errstat != SNMP_ERR_NOERROR){
X	    fprintf(stderr, "SNMP request failed\n");
X	    break;
X	}
X	vp = response->variables;
X	if (vp->name_length != 20 ||
X	    bcmp((char *)vp->name, (char *)oid_tcpconntable, sizeof(oid_tcpconntable))){
X		break;
X	}
X	
X	request = snmp_pdu_create(GETNEXT_REQ_MSG);
X	snmp_add_null_var(request, vp->name, vp->name_length);
X
X	instance = vp->name + 10;
X	for(tp = tcpconn; tp != NULL; tp = tp->next){
X	    if (!bcmp((char *)instance, (char *)tp->instance,
X		sizeof(tp->instance)))
X		    break;
X	}
X	if (tp == NULL){
X	    newp = (struct tcpconn_entry *)malloc(sizeof(struct tcpconn_entry));
X	    if (tcpconn == NULL){
X		tcpconn = newp;
X	    } else {
X		for(tp = tcpconn; tp->next != NULL; tp = tp->next)
X		    ;
X		tp->next = newp;
X	    }
X	    tp = newp;
X	    bzero((char *)tp, sizeof(*tp));
X	    tp->next = NULL;
X	    bcopy((char *)instance, (char *)tp->instance, sizeof(tp->instance));
X	}
X
X	if (vp->name[ENTRY] == TCPCONN_STATE){
X	    tp->state = *vp->val.integer;
X	    tp->stateSet = 1;
X
X	}
X
X	if (vp->name[ENTRY] == TCPCONN_LOCADDR){
X	    bcopy((char *)vp->val.string, (char *)&tp->localAddress, sizeof(u_long));
X	    tp->locAddrSet = 1;
X
X	}
X
X	if (vp->name[ENTRY] == TCPCONN_LOCPORT){
X	    tp->localPort = *vp->val.integer;
X	    tp->locPortSet = 1;
X
X	}
X
X	if (vp->name[ENTRY] == TCPCONN_REMADDR){
X	    bcopy((char *)vp->val.string, (char *)&tp->remoteAddress, sizeof(u_long));
X	    tp->remAddrSet = 1;
X
X	}
X
X	if (vp->name[ENTRY] == TCPCONN_REMPORT){
X	    tp->remotePort = *vp->val.integer;
X	    tp->remPortSet = 1;
X
X	}
X
X    }
X
X    for(first = 1, tp = tcpconn; tp != NULL; tp = tp->next){
X	if (!(tp->stateSet && tp->locAddrSet
X	    && tp->locPortSet && tp->remAddrSet && tp->remPortSet)){
X		printf("incomplete entry\n");
X		continue;
X	}
X	if (!aflag && tp->state == MIB_TCPCONNSTATE_LISTEN)
X		    continue;
X	if (first){
X	    printf("Active Internet Connections");
X	    if (aflag)
X		printf(" (including servers)");
X	    putchar('\n');
X	    printf("%-5.5s %-6.6s %-6.6s  %-22.22s %-22.22s %s\n",
X		    "Proto", "Recv-Q", "Send-Q",
X		    "Local Address", "Foreign Address", "(state)");
X	    first = 0;
X	}
X	printf("%-5.5s %6d %6d ", "tcp", 0, 0);
X	inetprint(&tp->localAddress, tp->localPort, "tcp");
X	inetprint(&tp->remoteAddress, tp->remotePort, "tcp");
X	if (tp->state < 1 || tp->state > TCP_NSTATES)
X	    printf(" %d", tp->state);
X	else
X	    printf(" %s", tcpstates[tp->state]);
X	putchar('\n');
X    }
X
X}
X
X
X/*
X * Dump UDP statistics structure.
X */
Xudp_stats()
X{
X    oid varname[MAX_NAME_LEN], *udpentry;
X    int varname_len;
X    struct variable_list *var;
X    int count;
X    struct stat_table *sp = udp_stattab;
X
X    bcopy((char *)oid_udpstats, (char *)varname, sizeof(oid_udpstats));
X    varname_len = sizeof(oid_udpstats) / sizeof(oid);
X    udpentry = varname + 7;
X    printf("udp:\n");
X    count = sizeof(udp_stattab) / sizeof (struct stat_table);
X    while (count--){
X	*udpentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var){
X	    putchar('\t');
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X
X}
X
X/*
X * Dump TCP statistics structure.
X */
Xtcp_stats()
X{
X    oid varname[MAX_NAME_LEN], *tcpentry;
X    int varname_len;
X    struct variable_list *var;
X    int count;
X    struct stat_table *sp = tcp_stattab;
X
X    bcopy((char *)oid_tcpstats, (char *)varname, sizeof(oid_tcpstats));
X    varname_len = sizeof(oid_tcpstats) / sizeof(oid);
X    tcpentry = varname + 7;
X    printf("tcp:\n");
X    count = sizeof(tcp_stattab) / sizeof (struct stat_table);
X    while (count--){
X	*tcpentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var){
X	    putchar('\t');
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X
X}
X
X/*
X * Dump IP statistics structure.
X */
Xip_stats()
X{
X    oid varname[MAX_NAME_LEN], *ipentry;
X    int varname_len;
X    struct variable_list *var;
X    int count;
X    struct stat_table *sp = ip_stattab;
X
X    bcopy((char *)oid_ipstats, (char *)varname, sizeof(oid_ipstats));
X    varname_len = sizeof(oid_ipstats) / sizeof(oid);
X    ipentry = varname + 7;
X    printf("ip:\n");
X    count = sizeof(ip_stattab) / sizeof (struct stat_table);
X    while (count--){
X	*ipentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var){
X	    putchar('\t');
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X
X}
X
X/*
X * Dump ICMP statistics.
X */
Xicmp_stats()
X{
X    oid varname[MAX_NAME_LEN], *icmpentry;
X    int varname_len;
X    struct variable_list *var;
X    int count, first;
X    struct stat_table *sp;
X
X    bcopy((char *)oid_icmpstats, (char *)varname, sizeof(oid_icmpstats));
X    varname_len = sizeof(oid_icmpstats) / sizeof(oid);
X    icmpentry = varname + 7;
X    printf("icmp:\n");
X    sp = icmp_stattab;
X    count = sizeof(icmp_stattab) / sizeof (struct stat_table);
X    while (count--){
X	*icmpentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var){
X	    putchar('\t');
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X
X    sp = icmp_outhistogram;
X    first = 1;
X    count = sizeof(icmp_outhistogram) / sizeof (struct stat_table);
X    while (count--){
X	*icmpentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var && *var->val.integer != 0){
X	    if (first){
X		printf("\tOutput Histogram:\n");
X		first = 0;
X	    }
X	    printf("\t\t");
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X
X    sp = icmp_inhistogram;
X    first = 1;
X    count = sizeof(icmp_inhistogram) / sizeof (struct stat_table);
X    while (count--){
X	*icmpentry = sp->entry;
X	var = getvarbyname(Session, varname, varname_len);
X	if (var && *var->val.integer != 0){
X	    if (first){
X		printf("\tInput Histogram:\n");
X		first = 0;
X	    }
X	    printf("\t\t");
X	    printf(sp->description, *var->val.integer, plural((int)*var->val.integer));
X	    putchar('\n');
X	}
X	sp++;
X    }
X}
X
X/*
X * Pretty print an Internet address (net address + port).
X * If the nflag was specified, use numbers instead of names.
X */
Xinetprint(in, port, proto)
X	register struct in_addr *in;
X	u_short port; 
X	char *proto;
X{
X	struct servent *sp = 0;
X	char line[80], *cp, *index();
X	int width;
X
X	sprintf(line, "%.*s.", 16, inetname(*in));
X	cp = index(line, '\0');
X	if (!nflag && port)
X		sp = getservbyport((int)port, proto);
X	if (sp || port == 0)
X		sprintf(cp, "%.8s", sp ? sp->s_name : "*");
X	else
X		sprintf(cp, "%d", ntohs((u_short)port));
X	width = 22;
X	printf(" %-*.*s", width, width, line);
X}
X
X/*
X * Construct an Internet address representation.
X * If the nflag has been supplied, give 
X * numeric value, otherwise try for symbolic name.
X */
Xchar *
Xinetname(in)
X	struct in_addr in;
X{
X	register char *cp;
X	static char line[50];
X	struct hostent *hp;
X	struct netent *np;
X	static char domain[MAXHOSTNAMELEN + 1];
X	static int first = 1;
X
X	if (first && !nflag) {
X		first = 0;
X		if (gethostname(domain, MAXHOSTNAMELEN) == 0 &&
X		    (cp = index(domain, '.')))
X			(void) strcpy(domain, cp + 1);
X		else
X			domain[0] = 0;
X	}
X	cp = 0;
X	if (!nflag && in.s_addr != INADDR_ANY) {
X		u_long net = inet_netof(in);
X		u_long lna = inet_lnaof(in);
X
X		if (lna == INADDR_ANY) {
X			np = getnetbyaddr(net, AF_INET);
X			if (np)
X				cp = np->n_name;
X		}
X		if (cp == 0) {
X			hp = gethostbyaddr((char *)&in, sizeof (in), AF_INET);
X			if (hp) {
X				if ((cp = index(hp->h_name, '.')) &&
X				    !strcmp(cp + 1, domain))
X					*cp = 0;
X				cp = hp->h_name;
X			}
X		}
X	}
X	if (in.s_addr == INADDR_ANY)
X		strcpy(line, "*");
X	else if (cp)
X		strcpy(line, cp);
X	else {
X		in.s_addr = ntohl(in.s_addr);
X#define C(x)	((x) & 0xff)
X		sprintf(line, "%u.%u.%u.%u", C(in.s_addr >> 24),
X			C(in.s_addr >> 16), C(in.s_addr >> 8), C(in.s_addr));
X	}
X	return (line);
X}
END_OF_FILE
  if test 14030 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/inet.c'
fi
if test -f 'nocol-3.0/src/cmu-snmp/man/snmpget.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/man/snmpget.1'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/man/snmpget.1'\" \(2626 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/man/snmpget.1' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1988, 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMPGET 1 "17 September 1989"
X.UC 4
X.SH NAME
Xsnmpget - communicates with a network entity using SNMP GET Requests.
X.SH SYNOPSIS
Xsnmpget host community variable-name [variable-name]...
X.SH DESCRIPTION
XSnmpget is an SNMP application that uses the GET Request to query for
Xinformation on a network entity.  One or more fully qualified object
Xidentifiers may be given as arguments on the command line.
XEach variable name is given in the format specified in
X.IR variables (5).
X.PP
XThe
X.I host
Xspecification may be either a host name or an internet address
Xspecified in "dot notation"
X.PP
XThe
X.I community
Xspecifies the community name for the transaction with the remote system.
X.PP
XFor example
X.PP
X.I snmpget netdev-kbox.cc.cmu.edu public system.sysdescr.0 system.sysUpTime.0
X.PP
Xwill retrieve the variables sysDescr.0 and sysUpTime.0:
X.PP
X.I Name: system.sysDescr.0
X.br
X.I OCTET STRING- (ascii):	Kinetics FastPath2
X.PP
X.I Name: system.sysUpTime.0
X.br
X.I Timeticks: (2270351) 6:18:23
X.PP
XIf the network entity has an error processing the request packet, an error
Xpacket will be returned and a message will be shown, helping to pinpoint in what
Xway the request was malformed.  If there were other variables in the request,
Xthe request will be resent without the bad variable.
X.PP
XAdding a "-d" to the argument list will cause the application to dump input and output packets.
X.PP
X.SH "SEE ALSO"
Xvariables(5), RFC 1065, RFC 1066, RFC 1067
END_OF_FILE
  if test 2626 -ne `wc -c <'nocol-3.0/src/cmu-snmp/man/snmpget.1'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/man/snmpget.1'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/man/snmpget.1'
fi
if test -f 'nocol-3.0/src/cmu-snmp/snmplib/mib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/snmplib/mib.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/snmplib/mib.c'\" \(17909 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/snmplib/mib.c' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <sys/time.h>
X#include "asn1.h"
X#include "snmp_impl.h"
X#include "snmp_api.h"
X#include "parse.h"
X
Xstatic void sprint_by_type();
X
Xstatic char *
XuptimeString(timeticks, buf)
X    register long timeticks;
X    char *buf;
X{
X    int	seconds, minutes, hours, days;
X
X    timeticks /= 100;
X    days = timeticks / (60 * 60 * 24);
X    timeticks %= (60 * 60 * 24);
X
X    hours = timeticks / (60 * 60);
X    timeticks %= (60 * 60);
X
X    minutes = timeticks / 60;
X    seconds = timeticks % 60;
X
X    if (days == 0){
X	sprintf(buf, "%d:%02d:%02d", hours, minutes, seconds);
X    } else if (days == 1) {
X	sprintf(buf, "%d day, %d:%02d:%02d", days, hours, minutes, seconds);
X    } else {
X	sprintf(buf, "%d days, %d:%02d:%02d", days, hours, minutes, seconds);
X    }
X    return buf;
X}
X
Xstatic sprint_hexstring(buf, cp, len)
X    char *buf;
X    u_char  *cp;
X    int	    len;
X{
X
X    for(; len >= 16; len -= 16){
X	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X ", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
X	buf += strlen(buf);
X	cp += 8;
X	sprintf(buf, "%02X %02X %02X %02X %02X %02X %02X %02X\n", cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
X	buf += strlen(buf);
X	cp += 8;
X    }
X    for(; len > 0; len--){
X	sprintf(buf, "%02X ", *cp++);
X	buf += strlen(buf);
X    }
X    *buf = '\0';
X}
X
Xstatic sprint_asciistring(buf, cp, len)
X    char *buf;
X    u_char  *cp;
X    int	    len;
X{
X    int	x;
X
X    for(x = 0; x < len; x++){
X	if (isprint(*cp)){
X	    *buf++ = *cp++;
X	} else {
X	    *buf++ = '.';
X	    cp++;
X	}
X	if ((x % 48) == 47)
X	    *buf++ = '\n';
X    }
X    *buf = '\0';
X}
X
X#ifdef UNUSED
Xint
Xread_rawobjid(input, output, out_len)
X    char *input;
X    oid *output;
X    int	*out_len;
X{
X    char    buf[12], *cp;
X    oid	    *op = output;
X    u_long  subid;
X
X    while(*input != '\0'){
X	if (!isdigit(*input))
X	    break;
X	cp = buf;
X	while(isdigit(*input))
X	    *cp++ = *input++;
X	*cp = '\0';
X	subid = atoi(buf);
X	if(subid > MAX_SUBID){
X	    fprintf(stderr, "sub-identifier too large: %s\n", buf);
X	    return 0;
X	}
X	if((*out_len)-- <= 0){
X	    fprintf(stderr, "object identifier too long\n");
X	    return 0;
X	}
X	*op++ = subid;
X	if(*input++ != '.')
X	    break;
X    }
X    *out_len = op - output;
X    if (*out_len == 0)
X	return 0;
X    return 1;
X}
X
X#endif /* UNUSED */
X
Xstatic void
Xsprint_octet_string(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    int hex, x;
X    u_char *cp;
X
X    if (var->type != ASN_OCTET_STR){
X	sprintf(buf, "Wrong Type (should be OCTET STRING): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    hex = 0;
X    for(cp = var->val.string, x = 0; x < var->val_len; x++, cp++){
X	if (!(isprint(*cp) || isspace(*cp)))
X	    hex = 1;
X    }
X    if (var->val_len <= 4)
X	hex = 1;    /* not likely to be ascii */
X    if (hex){
X	sprintf(buf, "OCTET STRING-   (hex):\t");
X	buf += strlen(buf);
X	sprint_hexstring(buf, var->val.string, var->val_len);
X    } else {
X	sprintf(buf, "OCTET STRING- (ascii):\t");
X	buf += strlen(buf);
X	sprint_asciistring(buf, var->val.string, var->val_len);
X    }
X}
X
Xstatic void
Xsprint_opaque(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X
X    if (var->type != OPAQUE){
X	sprintf(buf, "Wrong Type (should be Opaque): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "OPAQUE -   (hex):\t");
X    buf += strlen(buf);
X    sprint_hexstring(buf, var->val.string, var->val_len);
X}
X
Xstatic void
Xsprint_object_identifier(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_OBJECT_ID){
X	sprintf(buf, "Wrong Type (should be OBJECT IDENTIFIER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "OBJECT IDENTIFIER:\t");
X    buf += strlen(buf);
X    sprint_objid(buf, (oid *)(var->val.objid), var->val_len / sizeof(oid));
X}
X
Xstatic void
Xsprint_timeticks(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    char timebuf[32];
X
X    if (var->type != TIMETICKS){
X	sprintf(buf, "Wrong Type (should be Timeticks): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Timeticks: (%d) %s", *(var->val.integer), uptimeString(*(var->val.integer), timebuf));
X}
X
Xstatic void
Xsprint_integer(buf, var, enums)
X    char *buf;
X    struct variable_list *var;
X    struct enum_list	    *enums;
X{
X    char    *enum_string = NULL;
X
X    if (var->type != ASN_INTEGER){
X	sprintf(buf, "Wrong Type (should be INTEGER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    for (; enums; enums = enums->next)
X	if (enums->value == *var->val.integer){
X	    enum_string = enums->label;
X	    break;
X	}
X    if (enum_string == NULL)
X	sprintf(buf, "INTEGER: %d", *var->val.integer);
X    else
X	sprintf(buf, "INTEGER: %s(%d)", enum_string, *var->val.integer);
X}
X
Xstatic void
Xsprint_gauge(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != GAUGE){
X	sprintf(buf, "Wrong Type (should be Gauge): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Gauge: %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_counter(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != COUNTER){
X	sprintf(buf, "Wrong Type (should be Counter): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "Counter: %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_networkaddress(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    int x, len;
X    u_char *cp;
X
X    sprintf(buf, "Network Address:\t");
X    buf += strlen(buf);
X    cp = var->val.string;    
X    len = var->val_len;
X    for(x = 0; x < len; x++){
X	sprintf(buf, "%02X", *cp++);
X	buf += strlen(buf);
X	if (x < (len - 1))
X	    *buf++ = ':';
X    }
X}
X
Xstatic void
Xsprint_ipaddress(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    u_char *ip;
X
X    if (var->type != IPADDRESS){
X	sprintf(buf, "Wrong Type (should be Ipaddress): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    ip = var->val.string;
X    sprintf(buf, "IpAddress:\t%d.%d.%d.%d",ip[0], ip[1], ip[2], ip[3]);
X}
X
Xstatic void
Xsprint_unsigned_short(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_INTEGER){
X	sprintf(buf, "Wrong Type (should be INTEGER): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "INTEGER (0..65535): %lu", *var->val.integer);
X}
X
Xstatic void
Xsprint_null(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X    if (var->type != ASN_NULL){
X	sprintf(buf, "Wrong Type (should be NULL): ");
X	buf += strlen(buf);
X	sprint_by_type(buf, var, (struct enum_list *)NULL);
X	return;
X    }
X    sprintf(buf, "NULL");
X}
X
Xstatic void
Xsprint_unknowntype(buf, var)
X    char *buf;
X    struct variable_list *var;
X{
X/*    sprintf(buf, "Variable has bad type"); */
X    sprint_by_type(buf, var, NULL);
X}
X
Xstatic void
Xsprint_badtype(buf)
X    char *buf;
X{
X    sprintf(buf, "Variable has bad type");
X}
X
Xstatic void
Xsprint_by_type(buf, var, enums)
X    char *buf;
X    struct variable_list *var;
X    struct enum_list	    *enums;
X{
X    switch (var->type){
X	case ASN_INTEGER:
X	    sprint_integer(buf, var, enums);
X	    break;
X	case ASN_OCTET_STR:
X	    sprint_octet_string(buf, var);
X	    break;
X	case OPAQUE:
X	    sprint_opaque(buf, var);
X	    break;
X	case ASN_OBJECT_ID:
X	    sprint_object_identifier(buf, var);
X	    break;
X	case TIMETICKS:
X	    sprint_timeticks(buf, var);
X	    break;
X	case GAUGE:
X	    sprint_gauge(buf, var);
X	    break;
X	case COUNTER:
X	    sprint_counter(buf, var);
X	    break;
X	case IPADDRESS:
X	    sprint_ipaddress(buf, var);
X	    break;
X	case ASN_NULL:
X	    sprint_null(buf, var);
X	    break;
X	default:
X	    sprint_badtype(buf);
X	    break;
X    }
X}
X
Xstruct tree *get_symbol();
X
Xoid RFC1066_MIB[] = { 1, 3, 6, 1, 2, 1 };
Xunsigned char RFC1066_MIB_text[] = ".iso.org.dod.internet.mgmt.mib";
Xstruct tree *Mib;
X
Xinit_mib()
X{
X    char *file, *getenv();
X
X    Mib = 0;
X    file = getenv("MIBFILE");
X    if (file)
X	Mib = read_mib(file);
X    if (!Mib)
X	Mib = read_mib("mib.txt");
X    if (!Mib)
X	Mib = read_mib("/etc/mib.txt");
X    if (!Mib){
X	fprintf(stderr, "Couldn't find mib file\n");
X	exit(2);
X    }
X    set_functions(Mib);
X}
X
Xstatic
Xset_functions(subtree)
X    struct tree *subtree;
X{
X    for(; subtree; subtree = subtree->next_peer){
X	switch(subtree->type){
X	    case TYPE_OBJID:
X		subtree->printer = sprint_object_identifier;
X		break;
X	    case TYPE_OCTETSTR:
X		subtree->printer = sprint_octet_string;
X		break;
X	    case TYPE_INTEGER:
X		subtree->printer = sprint_integer;
X		break;
X	    case TYPE_NETADDR:
X		subtree->printer = sprint_networkaddress;
X		break;
X	    case TYPE_IPADDR:
X		subtree->printer = sprint_ipaddress;
X		break;
X	    case TYPE_COUNTER:
X		subtree->printer = sprint_counter;
X		break;
X	    case TYPE_GAUGE:
X		subtree->printer = sprint_gauge;
X		break;
X	    case TYPE_TIMETICKS:
X		subtree->printer = sprint_timeticks;
X		break;
X	    case TYPE_OPAQUE:
X		subtree->printer = sprint_opaque;
X		break;
X	    case TYPE_NULL:
X		subtree->printer = sprint_null;
X		break;
X	    case TYPE_OTHER:
X	    default:
X		subtree->printer = sprint_unknowntype;
X		break;
X	}
X	set_functions(subtree->child_list);
X    }
X}
X
X#ifdef testing
Xint snmp_dump_packet = 0;
X
Xmain(argc, argv)
X     int argc;
X     char *argv[];
X{
X    oid objid[64];
X    int objidlen = sizeof (objid);
X    int count;
X    struct variable variable;
X
X    init_mib(&Mib);
X    if (argc < 2)
X	print_subtree(Mib, 0);
X    variable.type = ASN_INTEGER;
X    variable.val.integer = 3;
X    variable.val_len = 4;
X    for (argc--; argc; argc--, argv++) {
X	objidlen = sizeof (objid);
X	printf("read_objid(%s) = %d\n",
X	       argv[1], read_objid(argv[1], objid, &objidlen));
X	for(count = 0; count < objidlen; count++)
X	    printf("%d.", objid[count]);
X	printf("\n");
X	print_variable(objid, objidlen, &variable);
X    }
X}
X
X#endif testing
X
X
Xstatic struct tree *
Xfind_rfc1066_mib(root)
X    struct tree *root;
X{
X    oid *op = RFC1066_MIB;
X    struct tree *tp;
X    int len;
X
X    for(len = sizeof(RFC1066_MIB)/sizeof(oid); len; len--, op++){
X	for(tp = root; tp; tp = tp->next_peer){
X	    if (tp->subid == *op){
X		root = tp->child_list;
X		break;
X	    }
X	}
X	if (tp == NULL)
X	    return NULL;
X    }
X    return root;
X}
X
Xint read_objid(input, output, out_len)
X    char *input;
X    oid *output;
X    int	*out_len;   /* number of subid's in "output" */
X{
X    struct tree *root = Mib;
X    oid *op = output;
X    int i;
X
X    if (*input == '.')
X	input++;
X    else {
X	root = find_rfc1066_mib(root);
X	for (i = 0; i < sizeof (RFC1066_MIB)/sizeof(oid); i++) {
X	    if ((*out_len)-- > 0)
X		*output++ = RFC1066_MIB[i];
X	    else {
X		fprintf(stderr, "object identifier too long\n");
X		return (0);
X	    }
X	}
X    }
X
X    if (root == NULL){
X	fprintf(stderr, "Mib not initialized.  Exiting.\n");
X	exit(1);
X    }
X    if ((*out_len =
X	 parse_subtree(root, input, output, out_len)) == 0)
X	return (0);
X    *out_len += output - op;
X
X    return (1);
X}
X
Xstatic
Xparse_subtree(subtree, input, output, out_len)
X    struct tree *subtree;
X    char *input;
X    oid	*output;
X    int	*out_len;   /* number of subid's */
X{
X    char buf[128], *to = buf;
X    u_long subid = 0;
X    struct tree *tp;
X
X    /*
X     * No empty strings.  Can happen if there is a trailing '.' or two '.'s
X     * in a row, i.e. "..".
X     */
X    if ((*input == '\0') ||
X	(*input == '.'))
X	return (0);
X
X    if (isdigit(*input)) {
X	/*
X	 * Read the number, then try to find it in the subtree.
X	 */
X	while (isdigit(*input)) {
X	    subid *= 10;
X	    subid += *input++ - '0';
X	}
X	for (tp = subtree; tp; tp = tp->next_peer) {
X	    if (tp->subid == subid)
X		goto found;
X	}
X	tp = NULL;
X    }
X    else {
X	/*
X	 * Read the name into a buffer.
X	 */
X	while ((*input != '\0') &&
X	       (*input != '.')) {
X	    *to++ = *input++;
X	}
X	*to = '\0';
X
X	/*
X	 * Find the name in the subtree;
X	 */
X	for (tp = subtree; tp; tp = tp->next_peer) {
X	    if (lc_cmp(tp->label, buf) == 0) {
X		subid = tp->subid;
X		goto found;
X	    }
X	}
X
X	/*
X	 * If we didn't find the entry, punt...
X	 */
X	if (tp == NULL) {
X	    fprintf(stderr, "sub-identifier not found: %s\n", buf);
X	    return (0);
X	}
X    }
X
Xfound:
X    if(subid > (u_long)MAX_SUBID){
X	fprintf(stderr, "sub-identifier too large: %s\n", buf);
X	return (0);
X    }
X
X    if ((*out_len)-- <= 0){
X	fprintf(stderr, "object identifier too long\n");
X	return (0);
X    }
X    *output++ = subid;
X
X    if (*input != '.')
X	return (1);
X    if ((*out_len =
X	 parse_subtree(tp ? tp->child_list : NULL, ++input, output, out_len)) == 0)
X	return (0);
X    return (++*out_len);
X}
X
Xprint_objid(objid, objidlen)
X    oid	    *objid;
X    int	    objidlen;	/* number of subidentifiers */
X{
X    char    buf[256];
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    get_symbol(objid, objidlen, subtree, buf + 1);
X    printf("%s\n", buf);
X        
X}
X
Xsprint_objid(buf, objid, objidlen)
X    char *buf;
X    oid	    *objid;
X    int	    objidlen;	/* number of subidentifiers */
X{
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    get_symbol(objid, objidlen, subtree, buf + 1);
X}
X
X
Xprint_variable(objid, objidlen, variable)
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    buf[512], *cp;
X    struct tree    *subtree = Mib;
X
X    *buf = '.';	/* this is a fully qualified name */
X    subtree = get_symbol(objid, objidlen, subtree, buf + 1);
X    cp = buf;
X    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !bcmp(buf, (char *)RFC1066_MIB_text,
X	strlen((char *)RFC1066_MIB_text))){
X	    cp += sizeof(RFC1066_MIB_text);
X    }
X    printf("Name: %s\n", cp);
X    *buf = '\0';
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X    printf("%s\n", buf);
X}
X
Xsprint_variable(buf, objid, objidlen, variable)
X    char *buf;
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512], *cp;
X    struct tree    *subtree = Mib;
X
X    *tempbuf = '.';	/* this is a fully qualified name */
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf + 1);
X    cp = tempbuf;
X    if ((strlen(buf) >= strlen((char *)RFC1066_MIB_text)) && !bcmp(buf, (char *)RFC1066_MIB_text,
X	strlen((char *)RFC1066_MIB_text))){
X	    cp += sizeof(RFC1066_MIB_text);
X    }
X    sprintf(buf, "Name: %s\n", cp);
X    buf += strlen(buf);
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X    strcat(buf, "\n");
X}
X
Xsprint_value(buf, objid, objidlen, variable)
X    char *buf;
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512];
X    struct tree    *subtree = Mib;
X
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf);
X    if (subtree->printer)
X	(*subtree->printer)(buf, variable, subtree->enums);
X    else {
X	sprint_by_type(buf, variable, subtree->enums);
X    }
X}
X
Xprint_value(objid, objidlen, variable)
X    oid     *objid;
X    int	    objidlen;
X    struct  variable_list *variable;
X{
X    char    tempbuf[512];
X    struct tree    *subtree = Mib;
X
X    subtree = get_symbol(objid, objidlen, subtree, tempbuf);
X    if (subtree->printer)
X	(*subtree->printer)(tempbuf, variable, subtree->enums);
X    else {
X	sprint_by_type(tempbuf, variable, subtree->enums);
X    }
X    printf("%s\n", tempbuf);
X}
X
Xstruct tree *
Xget_symbol(objid, objidlen, subtree, buf)
X    oid	    *objid;
X    int	    objidlen;
X    struct tree    *subtree;
X    char    *buf;
X{
X    struct tree    *return_tree = NULL;
X
X    for(; subtree; subtree = subtree->next_peer){
X	if (*objid == subtree->subid){
X	    strcpy(buf, subtree->label);
X	    goto found;
X	}
X    }
X
X    /* subtree not found */
X    while(objidlen--){	/* output rest of name, uninterpreted */
X	sprintf(buf, "%u.", *objid++);
X	while(*buf)
X	    buf++;
X    }
X    *(buf - 1) = '\0'; /* remove trailing dot */
X    return NULL;
X
Xfound:
X    if (objidlen > 1){
X	while(*buf)
X	    buf++;
X	*buf++ = '.';
X	*buf = '\0';
X	return_tree = get_symbol(objid + 1, objidlen - 1, subtree->child_list, buf);
X    } 
X    if (return_tree != NULL)
X	return return_tree;
X    else
X	return subtree;
X}
X
X
Xstatic int
Xlc_cmp(s1, s2)
X    char *s1, *s2;
X{
X    char c1, c2;
X
X    while(*s1 && *s2){
X	if (isupper(*s1))
X	    c1 = tolower(*s1);
X	else
X	    c1 = *s1;
X	if (isupper(*s2))
X	    c2 = tolower(*s2);
X	else
X	    c2 = *s2;
X	if (c1 != c2)
X	    return ((c1 - c2) > 0 ? 1 : -1);
X	s1++;
X	s2++;
X    }
X
X    if (*s1)
X	return -1;
X    if (*s2)
X	return 1;
X    return 0;
X}
X
END_OF_FILE
  if test 17909 -ne `wc -c <'nocol-3.0/src/cmu-snmp/snmplib/mib.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/snmplib/mib.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/snmplib/mib.c'
fi
if test -f 'nocol-3.0/src/perlnocol/nocollib.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/perlnocol/nocollib.pl'\"
else
  echo shar: Extracting \"'nocol-3.0/src/perlnocol/nocollib.pl'\" \(11972 characters\)
  sed "s/^X//" >'nocol-3.0/src/perlnocol/nocollib.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X#
X# $Header: /home/aggarwal/lsrc/nocol/src/perlnocol/RCS/nocollib.pl,v 1.5 1993/11/01 23:51:53 aggarwal Exp $
X#
X# 	nocollib.pl - perl library of NOCOL routines
X#
X# Date: September 21, 1993
X# Programmer: John Wobus, jmwobus@mailbox.syr.edu
X#  Modifications:  vikas@jvnc.net
X#
X#    (c) Syracuse University Computing & Network Services 1993
X#
X# No warranty is expressed or implied.  Permission to copy and use is
X# extended to all.  Permission to redistribute is granted under the
X# following conditions: it is not sold for profit; this copyright
X# notice remains intact; the same permissions extend to the recipient;
X# and if any changes are made, a notice is added so stating.
X#
X
X## The following is a list of associative arrays used globally to
X#  refer to the fields in the EVENT structure.
X#	sender, sitename, siteaddr,
X#	varname, varval, varthres, varunits,
X#	mon, day, hour, min, severity, loglevel, nocop
X#
X#  Define $libdebug=1 to turn on verbose debugging messages.
X#  Might need to fix the '$event_t' description for null padding
X#  (since some systems might align structure fields on different
X#  boundaries).
X#
X# Usage:
X#
X#  require "nocollib.pl";
X#
X#
X# Subroutines:
X#
X#   unpackevent -	Extracts packed EVENT fields into various arrays
X#   packevent -		Converts array fields into a packed EVENT structure
X#   readevent -		Read EVENT from open IEVENT file desc and unpack it.
X#   writeevent -	Pack various arrays into EVENT struct and write out.
X#   gettime -		Get local month/day/hour/min
X#   standalone -	Kill earlier running processes and setup signals
X#   init_events -	Fill in various arrays with initial (global) values
X#   update_event -	Given status, updates array fields and logs if needed
X#   eventlog -		Logs event to 'noclogd' daemon
X#   
X#
X####################################################################
X# 
X
X#######################
X##  Customize these  ##
X#######################
X$nocolroot = "/nocol"  unless $nocolroot;
X$etcdir  = "$nocolroot/etc"  unless $etcdir;	# location of config file
X$bindir  = "$nocolroot/bin"  unless $bindir;
X$datadir = "$nocolroot/data" unless $datadir;	# output data file
X
Xpush(@INC, $bindir); push(@INC, $etcdir); # add to search paths for 'require'
X
X$NLOG_HOST = "minnie.jvnc.net" ;	# Used for logging to noclogd
X$NLOG_SERVICE = "noclog" ;		# if port is in /etc/services
X$NLOG_PORT = 5354 ;			# default port if NOT in /etc/services
X
X## Need to pad (actual length is 195, have to align on word? boundary)
X$event_t = "a12 a16 a128  a16 L L a8  CCCC CC C x" ;  # event structure format
X$levent = length( pack($event_t, 0, '') );	    # sizeof structure
X
Xif ($libdebug) {print "(libdebug) Sizeof event= $levent\n" ;}
X
X######################
X##  GLOBAL DEFINES  ##
X######################
X
X$E_CRITICAL = 1;
X$E_ERROR    = 2;
X$E_WARNING  = 3;
X$E_INFO     = 4;
X
X$n_UP          = 0x01;
X$n_DOWN        = 0x02;
X$n_UNKNOWN     = 0x04;
X$n_TEST        = 0x08;
X$n_NODISPLAY   = 0x10;
X
X#######################
X##
X
X##
X# Given an index (to the list of associative arrays that are globally
X# declared), and an event structure, it unpacks and fills in the arrays
X# with the values from the event structure.
X
Xsub unpackevent {
X    local($i, $event) = @_ ;		# index and event
X    local($vpad);
X    ($sender{$i},$sitename{$i},$siteaddr{$i},
X     $varname{$i},$varvalue{$i},$varthres{$i},$varunits{$i},
X     $mon{$i},$day{$i},$hour{$i},$min{$i},
X     $severity{$i},$loglevel{$i},$nocop{$i}, $vpad)
X	=unpack($event_t, $event);
X    
X    if ($libdebug) { print "(debug) unpackevent: $i\n"; }
X    
X}
X
X##
X# Given an index (to the list of associative arrays that are globally
X# declared), it creates an EVENT structure and returns it.
X# Note the 'vpad' to align the structure on an even byte boundary.
Xsub packevent {
X    local($i) = @_ ;		#index to associative arrays
X    local($event) ;
X    local($vpad) = "" ;
X    $event = pack($event_t, 
X		  $sender{$i},$sitename{$i},$siteaddr{$i},
X		  $varname{$i},$varvalue{$i},$varthres{$i},$varunits{$i},
X		  $mon{$i},$day{$i},$hour{$i},$min{$i},
X		  $severity{$i},$loglevel{$i},$nocop{$i}, $vpad) ;
X    
X    if ($libdebug) { print "(debug) packevent: $i\n"; }
X    return($event) ;
X}
X
X##
X## Subroutines to read and write from the datafile.
X#
Xsub readevent {
X    local($index) = @_ ;
X    local($bl,$event);
X    
X    $index = 'TEMP' unless $index ;		# use TEMP storage by default
X    if ($bl = read(IEVENTS, $event, $levent))
X    {
X	&unpackevent($index, $event);		# fills in the various arrays
X    }
X    return($bl);
X}
X
Xsub writeevent {
X    local($index) = @_ ;
X    local($event) ;
X    
X    $event = &packevent($index);
X    
X    print OEVENTS $event ;
X}
X
X##
X#  printevent()  to display the event arrays given an index 
Xsub printevent {
X    local($i) = @_ ;
X    
X    print "
X      SENDER= $sender{$i},$sitename{$i},$siteaddr{$i},
X      VAR= $varname{$i},$varvalue{$i},$varthres{$i},$varunits{$i},
X      DATE= $mon{$i},$day{$i},$hour{$i},$min{$i},
X      SEV= $severity{$i},$loglevel{$i},$nocop{$i}\n" ;
X    
X}
X
X
X##	gettime()
X#
Xsub gettime {
X    local($mon,$day,$hour,$min,@time);
X    
X    @time=localtime(time);
X    $mon=substr("00".(1+$time[4]),-2);
X    $day=substr("00".$time[3],-2);
X    $hour=substr("00".$time[2],-2);
X    $min=substr("00".$time[1],-2);
X    return($mon,$day,$hour,$min);
X}
X
X## Another cheesy way to do a 'gettime'
X#
X#sub gettime {
X#  local($date);
X#  chop($date=`$bindate +"%m %d %H %M"`);
X#  return(split(/\s+/,$date));
X#}
X
X##	standalone()
X# Checks to see if PIDFILE exists and kills any earlier running process.
X# Created new PIDFILE and sets up signal handlers. Incidentally, pidfile
X# cannot be local since it is unlinked by the signal handler routines.
X#
Xsub standalone {
X    local($me,$dir)=@_;
X    local($localhost)=`hostname`; chop ($localhost);
X    local($pid,$host);
X    
X    ($pidfile)="$dir/$me.pid";
X
X    if(open(PID,"<$pidfile"))
X    {
X	chop($pid=<PID>); chop($host=<PID>); close(PID);
X	if ("$host" ne "$localhost") {
X	    die("Program probably running on $host, else delete $pidfile\n");
X	}
X	
X	if($pid =~/^\d+$/)
X	{
X	    foreach (`ps $pid`)
X	    {
X		chop;
X		if(/$pid.*$me/){ kill(9,$pid); print "killing process $pid\n" };
X	    }
X	}
X    }
X    if(open(PID,">$pidfile")){print PID "$$\n$localhost\n"; close(PID);}
X
X    $SIG{"QUIT"} = clean_out ;
X    $SIG{"TERM"} = clean_out ;
X    $SIG{"INT"}  = clean_out ;
X    $SIG{"USR1"} = toggle_libdebug ;
X}
X
Xsub clean_out {
X   unlink $pidfile ;
X   unlink $datafile ; 
X   die "Terminating on signal\n" ;
X}
X
Xsub toggle_libdebug {
X    if ($libdebug) { --$libdebug ;}
X    else {++$libdebug ;}
X
X    if ($libdebug) { print "(nocollib): libdebug ON\n"; }
X
X}
X
X
X## Fill in default values for the item arrays. Inserts the following 'global'
X#  variables:   $sender  $varname  $varunits
X#  Gets the sitename/siteaddr from the args passed to it.
Xsub init_event {
X    local($sitename, $siteaddr, $i) = @_ ;	# index into assoc arrays
X    
X    if ($libdebug){print "(debug) init_event: Inserting- $i, Sitename= $sitename, Siteaddr= $siteaddr\n"; }
X    
X    
X    $sender{$i} = $sender ;
X    $sitename{$i} = $sitename ;
X    $siteaddr{$i} = "$siteaddr";
X    
X    $varname{$i}  = $varname ;
X    $varvalue{$i} = 0 ;
X    $varthres{$i} = 0 ;
X    $varunits{$i} = $varunits ;
X    
X    ($mon{$i},$day{$i},$hour{$i},$min{$i}) = &gettime ;
X    
X    $severity{$i} = $E_INFO;
X    $loglevel{$i} = $E_INFO;
X    $nocop{$i}    = $nocop{$i} | $n_UNKNOWN ;
X    
X} # end init_event()
X
X
X##	update_event()
X# Given index to events, status (0 or 1), new value, max severity to escalate
X# to,   this subroutine will update the various associative arrays and log
X# the event also (if the state has changed).
Xsub update_event {
X    local($i, $status, $value, $maxsev) = @_ ;	# $i is index to arrays
X    
X    if ($libdebug) {
X	print "(debug) update_event: ITEM $i, stat=$status, maxsev=$maxsev \n";
X    }
X    if ($maxsev < $E_CRITICAL) { $maxsev = $E_CRITICAL; }
X    if ($status)	# status is UP
X    {
X	($mon{$i},$day{$i},$hour{$i},$min{$i}) = &gettime ;
X	$varvalue{$i} = $value ;
X	if (!($nocop{$i} & $n_UP))			# recent state change
X	{
X	    $nocop{$i} = $nocop{$i} & ~($n_UP | $n_DOWN | $n_UNKNOWN) | $n_UP;
X	    $loglevel{$i} = $severity{$i} ;	# loglevel set to old level
X	    $severity{$i} = $E_INFO;
X	    &eventlog(&packevent($i)) ;		# log to noclogd daemon
X	}
X    }
X    else		# status is DOWN, escalate severity
X    {
X	if (!($nocop{$i} & $n_DOWN))			# recent state change
X	{
X	    ($mon{$i},$day{$i},$hour{$i},$min{$i}) = &gettime ;
X	}
X	$varvalue{$i} = $value ;
X	$nocop{$i} = $nocop{$i} & ~($n_UP | $n_DOWN | $n_UNKNOWN) | $n_DOWN;
X	if ($severity{$i} > $maxsev)
X	{
X	    --$severity{$i} ;		# escalate severity
X	}
X	
X	if ($loglevel{$i} != $severity{$i})		# new change
X	{
X	    $loglevel{$i} = $severity{$i};
X	    &eventlog(&packevent($i));
X	}
X    }
X    
X    if ($libdebug) {print "(debug) update_event:\n"; &printevent($i); }
X    
X}  # end update_event()
X
X##
X##	eventlog()
X#
X#
X
X$NLOG_HOST = "noclog.jvnc.net" unless $NLOG_HOST ;
X$NLOG_SERVICE = "noclog" unless $NLOG_SERVICE ;
X$NLOG_PORT = 2325 unless $NLOG_PORT ;
X$RETRY_REOPEN = 1*60 ;
X$isopenlogfd = 0 ;				# init this to negative value
X$logclosetime = -1 ;			# when logging last failed
X
Xsub eventlog {
X    local($event) = @_ ;
X    local($bytesleft) ;
X    
X    local($AF_INET) = 2;
X    local($SOCK_DGRAM) = 2;
X    
X    if ($isopenlogfd == 0)
X    {
X	local($curtime) = time ;
X	if (($curtime  - $logclosetime) < RETRY_REOPEN)
X	{
X	    return (-1) ;	# don't try again until RETRY_REOPEN secs
X	}
X	($junk, $junk, $proto) = getprotobyname('udp');
X	if (! socket(logfd, $AF_INET, $SOCK_DGRAM, $proto))
X	{
X	    print "socket() call failed: $!\n";
X	    $logclosetime = time ;	# record time of last attempt
X	    return (-1);
X	}
X	
X	## Get port number, host address to use
X	($name, $aliases, $port) = getservbyname($NLOG_SERVICE, 'udp');
X	if (! $port) { $port = $NLOG_PORT ; }
X	
X	if ($NLOG_HOST =~ /^\d+/)
X	{		# IP address, not name
X	    ($junk,$junk,$junk,$junk, $remoteaddr) = gethostbyaddr($NLOG_HOST, $AF_INET);
X	}
X	else
X	{
X	    ($junk,$junk,$junk,$junk, $remoteaddr) = gethostbyname($NLOG_HOST);
X	}
X	
X        if ($libdebug) { print "(debug) eventlog: Port= $port, proto= $proto\n";}
X	$sockaddr = 'S n a4 x8' ;
X	$remote = pack($sockaddr, $AF_INET, $port, $remoteaddr);
X	if (! connect(logfd, $remote))
X	{
X	    print ("Cannot connect to $NLOG_HOST: $!\n");
X	    close(logfd);
X	    $logclosetime = time ;	# record time of last attempt
X	    $isopenlogfd = 0 ;	 	# reset
X	    return(-1) ;
X	}
X	
X        if ($libdebug) {print "(debug) eventlog: socket opened\n"; }
X	$isopenlogfd = 1;		# open
X    }  	# end: if(socket not open)
X    
X    ## Here only if socket has been opened and have to write out EVENT.
X    $bytesleft = length ($event) ;
X    while ($bytesleft)
X    {
X	local($written);
X	local($offset) = 0;
X        $written = syswrite(logfd, $event, $bytesleft, $offset );
X	if ($written <= 0)
X	{
X	    if ($libdebug) {print ("eventlog syswrite error: $!\n");}
X	    close(logfd);
X	    return(-1);
X        }
X	
X	$bytesleft -= $written;
X	$offset += $written
X	}			# end:  while($bytesleft)
X    
X}
X
X
X##
X##
X# Standard main.. just create subroutines in your new
X# nocol monitor and call nocol_main from your monitor's main()
X# This is a sample.
X#
Xsub nocol_main {
X    
X    @me=split(/\//,$0); $me=pop(@me);
X    $piddir=join("/",@me); if ($piddir eq "") {$piddir=$etcdir;}
X    $cfile="$etcdir/$me-confg";
X    $datafile="$datadir/$me-output";
X
X    $sender= $me ;                          # filled in the EVENT sender
X
X    if ($p=fork){print "$p\n"; exit;}
X    &standalone($me, $piddir);
X    
X    &readconf;
X    
X    foreach $item (@items) {
X	&init_events($item);		# fill in initial values
X    }
X    while (1)
X    {
X	foreach $item (@items) {
X	    &dotest;
X	    &update_event($v, $status, $value, $maxseverity);
X	}
X	open(OEVENTS,">$datafile");
X	foreach $item (@items)
X	{
X	    if(!$forget{$item})
X	    {
X		&writeevent($item);
X	    }
X	}
X	close(OEVENTS);
X	sleep($sleepint);
X    }				# end: while(1)
X    
X}	# end nocol_main()
X
X##
X#
X##
END_OF_FILE
  if test 11972 -ne `wc -c <'nocol-3.0/src/perlnocol/nocollib.pl'`; then
    echo shar: \"'nocol-3.0/src/perlnocol/nocollib.pl'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/perlnocol/nocollib.pl'
  # end of 'nocol-3.0/src/perlnocol/nocollib.pl'
fi
if test -f 'nocol-3.0/src/pingmon/pingmon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/pingmon/pingmon.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/pingmon/pingmon.c'\" \(11711 characters\)
  sed "s/^X//" >'nocol-3.0/src/pingmon/pingmon.c' <<'END_OF_FILE'
X/*
X**	$Header: /home/aggarwal/lsrc/nocol/src/pingmon/RCS/pingmon.c,v 2.1 1993/10/30 03:15:21 aggarwal Exp $
X*/
X
X/*+
X**
X** DESCRIPTION
X**
X**	Runs the "ping" program to monitor a site. Marks a site as UP
X**	DOWN or UNKNOWN. It writes directly to the 'pingoutput' file
X**	instead of to a temporary file. Uses raw i/o calls.
X**
X**	This program opens the 'data file' supplied by the user and then
X**	creates the 'pingoutput' file. It then directly reads and writes
X**	from this file. On recieving a HUP signal, it rescans the 'data
X**	file' supplied by the user and continues.
X**
X**
X** AUTHOR
X**	Vikas Aggarwal, October 16, 1989
X**
X*/
X
X/*  Copyright 1992 JvNCnet
X
X Permission to use, copy, modify and distribute this software and its
X documentation for any purpose is hereby granted without fee, provided that
X the above copyright notice appear in all copies and that both that copyright
X notice and this permission notice appear in supporting documentation, and
X that the name of JvNCnet not be used in advertising or publicity pertaining
X to distribution of the software without specific, written prior permission.
X JvNCnet makes no representations about the suitability of this software for
X any purpose.  It is provided "as is" without express or implied warranty.
X
X JvNCnet DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL JvNCnet
X BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING DAMAGES RESULTING FROM LOSS
X OF USE, DATA OR PROFITS, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
X OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X*/
X
X
X/*
X * MODIFICATIONS
X *
X * $Log: pingmon.c,v $
X * Revision 2.1  1993/10/30  03:15:21  aggarwal
X * Fixed definitions of signal handler programs. Also appends directory
X * name to the pidfile while trying to unlink it.
X *
X * Revision 2.0  1992/06/18  21:18:16  aggarwal
X * Checked sleep logic. Cleaned up for release.
X *
X * Revision 1.11  1992/05/13  16:13:59  aggarwal
X * Altered for automatic output datafile, etc depending on its own
X * runtime name.
X *
X * Revision 1.5  90/04/16  18:12:21  aggarwal
X * Added stuff so that the config file can have comments.
X * Also can now send a SIGUSR1 to the program whose pid
X * is stored in 'program.pid' file.
X * 
X * Revision 1.4  90/03/15  15:27:22  aggarwal
X * Closed the fdout if it was not zero (if getting a SIGHUP signal, then
X * it should close the open output file before reopening it).
X * 
X * Revision 1.3  90/03/09  12:52:02  aggarwal
X * Major changes so that it can read in SIGNAL progname to send a
X * signal to another process when a site goes to CRITICAL the first
X * time.
X * 
X * Revision 1.1  89/12/13  14:16:09  aggarwal
X * Initial revision
X * 
X */ 
X#ifndef lint
X static char rcsid[] = "$RCSfile: pingmon.c,v $ $Revision: 2.1 $ $Date: 1993/10/30 03:15:21 $" ;
X#endif
X
X#include "pingmon.h"			/* program specific defines	*/
X
X#include <string.h>			/* For strcat() definitions	*/
X#include <sys/file.h>
X#include <signal.h>			/* For signal numbers		*/
X#include <setjmp.h>
X
X
X/*+ 
X** Global variables
X**/
X
Xstatic char  nodesfile[MAXLINE];	/* Filename with list of nodes */
Xstatic char  datafile[MAXLINE];		/* Name of output data file */
Xstatic time_t pollinterval ;		/* Time between polls */
Xjmp_buf	env;				/* For longjmp and setjmp 	*/
X
Xmain (ac, av)
X     int ac;
X     char **av;
X{
X    extern char	*prognm ;			/* in pingmon.h	 */
X    extern int debug ;
X    extern char *optarg;
X    extern int optind;
X    int	fdout = 0;			/* File desc for output data file */
X    register int c ;
X    char *p ;
X    time_t starttm, polltime ;
X    void done(), restart();			/* For the signals	*/
X
X    prognm = av[0] ;				/* Save the program name */
X
X#ifdef SENDER
X    sender = SENDER ;
X#else						/* delete the directory name */
X    if ((sender = (char *)strrchr (prognm , '/')) == NULL)
X      sender = prognm ;				/* no path in program name */
X    else
X      sender++ ;				/* skip leading '/' */
X#endif
X
X    /* the output data filename */    
X    sprintf(datafile,  "%s/%s%s\0",
X	    DATADIR,  sender, PINGOUTPUTEXT); 
X    sprintf(nodesfile, "%s\0", NODESFILE) ;	/* the name of IP hosts file */
X
X    ping = PING ;
X
X    while ((c = getopt(ac, av, "do:p:")) != EOF)
X      switch (c)
X      {
X       case 'd':
X	  debug++ ;
X	  break ;
X       case 'o':				/* output datafile */
X	  sprintf(datafile, "%s\0", optarg) ;
X	  break ;
X       case 'p':				/* ping command to use */
X	  ping = (char *)malloc (strlen(optarg) + 1) ;
X	  strcpy(ping, optarg);
X	  break ;
X       case '?':
X       default:
X	  fprintf (stderr, "%s: Unknown flag: %c\n", prognm, optarg);
X	  help() ;
X	  goto Cleanup ;
X      }
X
X    switch ( ac - optind )
X    {
X     case 0:					/* default input file */
X	break ;
X     case 1:
X	sprintf(nodesfile, "%s\0", av[optind]) ;
X	break ;
X     default:
X	fprintf (stderr, "%s Error: Too many 'hosts' files\n\n", prognm);
X	help() ;
X	goto Cleanup;
X    }
X
X    if (access(ping, F_OK | X_OK) != 0)	/* check if PING is executable	*/
X    {
X	perror (ping);
X	done();
X    }
X
X    p = malloc (strlen(sender) + strlen(ETCDIR) + 2) ;
X    sprintf(p, "%s/%s\0", ETCDIR, sender) ;
X    if (standalone(p) == -1) 	/* Kill prev running process	*/
X    {
X	fprintf(stderr, "%s: Error in standalone...exiting\n", prognm);
X	exit (1);
X    }
X    else
X      free(p) ;		/* not needed anymore */
X
X    if (debug)
X      fprintf(stderr,
X	      "(debug) %s: PING= '%s', NODESFILE= '%s', DATAFILE= '%s'\n",
X	      prognm, ping, nodesfile, datafile) ;
X    
X    setjmp (env);			/* Save the environment in case	*/
X
X    signal (SIGQUIT, done);		/* Delete pid file while dying	*/
X    signal (SIGTERM, done);
X    signal (SIGINT, done);
X    signal (SIGHUP, restart);		/* Re-read the nodesfile file	*/
X
X    if (getenv(DEBUG_FLG) != NULL)      /* see ifdebug mode desired     */
X      debug = debug ^ 1 ;
X
X    umask (002);			/* write access to the group	*/
X    if (fdout != 0)			/* Say, recovering from longjmp	*/
X      close(fdout);
X
X    openeventlog() ;			/* for logging */
X    if ( (fdout = open(datafile, O_RDWR | O_CREAT | O_TRUNC, 0664)) < 0)
X    {
X	fprintf(stderr, "(%s) ERROR in open datafile ", prognm);
X	perror (datafile);
X	goto Cleanup ;
X    }
X
X    if (init_sites(fdout, nodesfile) == -1 )
X      goto Cleanup ;
X
X    /* poll_sites makes one complete pass over the list of nodes */
X    while (1)			      		/* forever */
X    {
X	starttm = time((time_t *)NULL) ;	/* time started this cycle */
X	if (poll_sites(fdout) == -1)		/* Polling error */
X	  break ;
X
X	if ( (polltime = time((time_t *)NULL) - starttm) < pollinterval)
X	  sleep ((unsigned)(pollinterval - polltime));
X    }
X    /* HERE ONLY IF ERROR */
X Cleanup:
X    done();
X
X}	/***************** End of main *******************/
X    
X/*+ 
X** FUNCTION:
X** 	Brief usage
X**/
Xhelp ()
X{
X    static char usage[] = " [-d (debug)]  [-o <output file>] [-p <ping command>] [nodesfile file]\n";
X
X    fprintf(stderr, "\nUSAGE: %s %s\n\n", prognm, usage);
X    fprintf(stderr,"\tThis program finds out the status of sites by ");
X    fprintf(stderr,"sending out an ICMP ping request and writing\n");
X    fprintf(stderr,"\tthe output into the file %s.\n", datafile);
X
X    fprintf(stderr,"\tBy default, the list of nodes to monitor is %s\n", 
X	    nodesfile);
X    fprintf(stderr,"\tbut can be changed on the command line.\n");
X
X    fprintf(stderr,"\tThe 'node-file' format is:\n");
X    fprintf(stderr,"\t\t POLLINTERVAL  <#secs>\n");
X    fprintf(stderr,"\t\t <node> <ip-address>  [TEST]\n\n");
X    fprintf(stderr,"\tThe program writes its pid in %s.pid and \n",prognm);
X    fprintf(stderr,"\tif a new process starts, it kills the earlier one.\n");
X    fprintf(stderr,"\tIf a HUP signal is sent to the process, it rescans ");
X    fprintf(stderr,"the nodes file. \n");
X    fprintf(stderr,"\nTo run in debug mode, do a 'setenv %s 1'\n",DEBUG_FLG);
X    return (1);
X}
X
X
X/*
X** FUNCTION
X**
X**	init_sites
X**
X**	This function writes to the LSTFILE. All sites in the NODESFILE
X**	file are set to UNKNOWN status.
X**
X**	Careful while using 'localtime': the calue of the month varies from
X**	0 - 11 and hence has to be incremented for the correct month.
X*/
X
Xinit_sites(fdout, nodesfile)
X     int fdout ;			/* Output file descriptor	*/
X     char *nodesfile;			/* Filename of the nodes file	*/
X{
X    extern char *sender ;
X    FILE *p_nodes ;
X    EVENT v;				/* Defined in NOCOL.H		*/
X    char record[MAXLINE];
X    struct tm *loctime ;
X    time_t locclock ;			/* Careful, don't use 'long'	*/
X
X    if ((p_nodes = fopen(nodesfile, "r")) == NULL)
X    {
X	fprintf(stderr, "%s error (init_sites) ", prognm) ;
X	perror (nodesfile);
X	return (-1);
X    }
X
X    /*
X     * Fill in the static data stuff
X     */
X    bzero (&v, sizeof(v)) ;
X
X    locclock = time((time_t *)0);
X    loctime = localtime((long *)&locclock);
X
X    v.mon = loctime->tm_mon + 1;	v.day = loctime->tm_mday;
X    v.hour = loctime->tm_hour;		v.min = loctime->tm_min;
X
X    strncpy (v.sender, sender, sizeof(v.sender) - 1);
X
X    strncpy (v.var.name, VARNM, sizeof (v.var.name) - 1);
X    strncpy (v.var.units, VARUNITS, sizeof (v.var.units) - 1);
X    v.var.threshold = PING_THRES ;		/* num of packets lost	*/
X
X    v.nocop = SETF_UPDOUN (v.nocop, n_UNKNOWN);	/* Set all to UNKNOWN	*/
X    v.severity = E_INFO ;
X
X    while(fgetline(p_nodes,record,MAXLINE) > 0 ) 
X    {
X#ifdef IP
X	u_long inet_addr() ;
X#endif
X	char w1[MAXLINE], w2[MAXLINE], w3[MAXLINE];	/* Confg words	*/
X	int rc;						/* return code	*/
X
X	v.nocop = 0 ;				/* Init options to zero	*/
X	*w1 = *w2 = *w3 = NULL ;
X	rc = sscanf(record,"%s %s %s", w1, w2, w3);
X	if (rc == 0 || *w1 == NULL || *w1 == '#')  /* Comment or blank 	*/
X	  continue;
X
X        if (strncmp(w1, "POLLINTERVAL", 12) == 0 || strncmp(w1, "pollinterval", 12) == 0)
X        {
X            char *p;                                    /* for strtol */
X            pollinterval = (u_long)strtol(w2, &p, 0) ;
X            if (p == w2)
X            {
X                fprintf(stderr,"(%s): Error in format for POLLINTERVAL '%s'\n",
X                        prognm, w2) ;
X                pollinterval = 0 ;              /* reset to default above */
X            }
X            continue ;
X        }
X
X	strncpy(v.site.name, w1, sizeof(v.site.name) - 1);
X	strncpy(v.site.addr, w2, sizeof(v.site.addr) - 1);  /* no checks */
X
X#ifdef	IP		/* For IP, check the IP address */
X
X	if (inet_addr(w2) == -1)	/* bad address */
X	{
X	    fprintf(stderr,
X		    "(%s): Error in address '%s' for site '%s', ignoring\n",
X		    prognm, w2, w1);
X	    continue ;
X	}
X#endif
X	if (*w3 != NULL)			/* Some other keyword	*/
X	{
X	    if (strcmp(w3, "test") == 0 || strcmp(w3, "TEST") == 0)
X	      v.nocop = v.nocop | n_TEST ;
X	    else
X	      fprintf(stderr, "%s: Ignoring unknown keyword- %s\n", prognm,w3);
X	}
X
X	if (write (fdout, (char *)&v, sizeof(v)) != sizeof(v))
X	{
X	    fprintf(stderr, "%s (write): %s\n", prognm, sys_errlist[errno]);
X	    exit (1) ;
X	}
X
X    }					/* end: while			*/
X    fclose (p_nodes);			/* Not needed any more		*/    
X    return(1);				/* All OK			*/
X}		/* end:  init_sites()		*/
X
X
X/*+ 		restart
X** FUNCTION:
X**
X** 	If a SIGHUP is sent, it rescans the nodesfile file and starts all
X** over without exiting from the program.
X**/
X
Xvoid restart ()
X{
X    closeeventlog();
X    longjmp (env, 1);
X}
X
X/*+ 		done
X** FUNCTION:
X**
X** Delete the PID and the data file.
X** Called just before exiting. Only if error. Exits since it can be called
X** on recieving a signal.
X**/
Xvoid done ()
X{
X    char pidfile[MAXLINE] ;
X
X    closeeventlog() ;
X
X    fprintf (stderr, "%s: removing data, pid file.... ", prognm);
X    sprintf (pidfile, "%s/%s.pid\0", ETCDIR, prognm);
X    unlink (pidfile);				/* remove the PID file	*/
X    unlink (datafile);				/* delete the data file */
X    fprintf (stderr, "Done\n");
X    exit (1);
X}
END_OF_FILE
  if test 11711 -ne `wc -c <'nocol-3.0/src/pingmon/pingmon.c'`; then
    echo shar: \"'nocol-3.0/src/pingmon/pingmon.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/pingmon/pingmon.c'
fi
if test -f 'nocol-3.0/src/tpmon/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/tpmon/main.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/tpmon/main.c'\" \(11468 characters\)
  sed "s/^X//" >'nocol-3.0/src/tpmon/main.c' <<'END_OF_FILE'
X/*
X * $Header: /home/aggarwal/lsrc/nocol/src/tpmon/RCS/main.c,v 2.1 1993/10/30 03:27:42 aggarwal Exp $
X *
X * DESCRIPTION: throughput monitor
X *
X *   This program connects to the 'discard' port on a remote host and
X *   sends random data to the remote host and calculates the throughput
X *   (in bits per second).
X *
X *   For interfacing with 'nocol', it opens the data file supplied by 
X *   the user and then creates a 'tpmon-output' file for use with netmon.
X *   It then directly reads and writes from this file.  If it gets SIGHUP,
X *   it rescans the data file before continuing.
X *
X *   Derived in part from the pingmon code, RCS v1.11
X *
X *   S. Spencer Sun, Princeton Univ. / JvNCnet, June 1992
X *
X * MODIFICATIONS
X *
X * $Log: main.c,v $
X * Revision 2.1  1993/10/30  03:27:42  aggarwal
X * Deleted watchdog info. Fixed defines of the signal handlers
X *
X * Revision 2.0  1992/06/18  21:20:43  aggarwal
X * Just increased the revision number for rcsid[] and releasing.
X *
X * Revision 1.3  1992/06/14  23:38:56  aggarwal
X * Had to increment 'sender' after 'strrchr'
X *
X * Revision 1.2  1992/06/12  04:15:47  aggarwal
X * Fixed scanning of keyword 'pollinterval'
X *
X * Revision 1.1  1992/06/12  04:06:46  aggarwal
X * Initial revision
X *
X *
X */
X/*  Copyright 1992 JvNCnet
X
X Permission to use, copy, modify and distribute this software and its
X documentation for any purpose is hereby granted without fee, provided that
X the above copyright notice appear in all copies and that both that copyright
X notice and this permission notice appear in supporting documentation, and
X that the name of JvNCnet not be used in advertising or publicity pertaining
X to distribution of the software without specific, written prior permission.
X JvNCnet makes no representations about the suitability of this software for
X any purpose.  It is provided "as is" without express or implied warranty.
X
X JvNCnet DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL JvNCnet
X BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING DAMAGES RESULTING FROM LOSS
X OF USE, DATA OR PROFITS, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
X OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X*/
X
X/* ^L */
X
X#ifndef lint
X static char rcsid[] = "$RCSfile: main.c,v $ $Revision: 2.1 $ $Date: 1993/10/30 03:27:42 $" ;
X#endif
X
X
X
X#include "nocol.h"			/*	common structures	*/
X
X#include <string.h>			/* For strcat() definitions	*/
X#include <sys/file.h>
X#include <signal.h>			/* For signal numbers		*/
X#include <setjmp.h>
X
X#define GLOBALS				/* for global variables */
X#include "tpmon.h"			/* program specific defines	*/
X#undef GLOBALS
X
X
X/*+ 
X * Variables definitions
X */
X
Xjmp_buf	env;				/* For longjmp and setjmp 	*/
X
Xmain (ac, av)
X     int ac;
X     char **av;
X{
X    extern char *prognm ;                       /* in pingmon.h  */
X    extern int debug ;
X    extern char *optarg;
X    extern int optind;
X    int	fdout = 0;			/* File desc for output data file */
X    register int c ;
X    char *p;
X    time_t starttm, polltime ;
X    void done(), restart();			/* For the signals	*/
X
X    prognm = av[0] ;				/* Save the program name */
X
X#ifdef SENDER
X    sender = SENDER ;
X#else						/* delete the directory name */
X    if ((sender = (char *)strrchr (prognm , '/')) == NULL)
X      sender = prognm ;				/* no path in program name */
X    else
X      sender++ ;				/* skip leading '/' */
X#endif
X
X    /* the output data filename */    
X    sprintf(datafile,  "%s/%s%s\0", DATADIR,  sender, TPMONOUTPUTEXT); 
X    sprintf(ipnodes, "%s\0", NODESFILE);    /* the name of the config file */
X
X    while ((c = getopt(ac, av, "do:")) != EOF)
X      switch (c) {
X        case 'd':
X	  debug++ ;
X	  break ;
X        case 'o':				/* output datafile */
X	  sprintf(datafile, "%s\0", optarg) ;
X	  break ;
X        case '?':
X        default:
X	  fprintf (stderr, "%s: Unknown flag: %c\n", prognm, optarg);
X	  help() ;
X	  goto Cleanup ;
X      }
X
X    switch (ac - optind) {
X      case 0:					/* default input file */
X	break ;
X      case 1:
X	sprintf(ipnodes, "%s\0", av[optind]) ;
X	break ;
X      default:
X	fprintf (stderr, "%s Error: Too many 'hosts' files\n\n", prognm);
X	help() ;
X	goto Cleanup;
X    }
X
X
X    p = malloc (sizeof(sender) + sizeof(ETCDIR) + 1) ;
X    sprintf(p, "%s/%s\0", ETCDIR, sender) ;
X    if (standalone(p) == -1) {		/* Kill prev running process	*/
X      fprintf(stderr, "%s: Error in standalone...exiting\n", prognm);
X      exit (1);
X    }
X    else
X      free(p);		/* not needed anymore */
X
X    if (debug)
X      fprintf(stderr,
X	"(debug) %s: NODESFILE= '%s', DATAFILE= '%s'\n",
X	  prognm, ipnodes, datafile) ;
X    
X    setjmp (env);			/* Save the environment in case	*/
X
X    signal (SIGQUIT, done);		/* Delete pid file while dying	*/
X    signal (SIGTERM, done);
X    signal (SIGINT, done);
X    signal (SIGHUP, restart);		/* Re-read the ipnodes file	*/
X
X    if (getenv(DEBUG_FLG) != NULL)      /* see ifdebug mode desired     */
X      debug = debug ^ 1 ;
X
X    umask (002);			/* write access to the group	*/
X    if (fdout != 0)			/* Say, recovering from longjmp	*/
X      close(fdout);
X
X    openeventlog() ;			/* noclogd for logging */
X
X    if ( (fdout = open(datafile, O_RDWR | O_CREAT | O_TRUNC, 0664)) < 0) {
X      fprintf(stderr, "(%s) ERROR in open datafile ", prognm);
X      perror (datafile);
X      goto Cleanup ;
X    }
X
X    if (init_sites(fdout, ipnodes) == -1 )
X      goto Cleanup ;
X
X    if (!pollinterval)
X      pollinterval = POLLINTERVAL ;		/* default value */
X
X
X    /* poll_sites makes one complete pass over the list of nodes */
X    while (1)                                   /* forever */
X    {
X        starttm = time((time_t *)NULL) ;        /* time started this cycle */
X        if (poll_sites(fdout) == -1)            /* Polling error */
X          break ;
X
X        if ( (polltime = time((time_t *)NULL) - starttm) < pollinterval)
X          sleep ((unsigned)(pollinterval - polltime));
X    }
X
X    /* HERE ONLY IF ERROR */
X  Cleanup:
X    done();
X
X}	/***************** End of main *******************/
X    
X/*+ 
X** FUNCTION:
X** 	Brief usage
X**/
Xhelp ()
X{
X    static char usage[] = " [-d (debug)] [-o <output file>] [<config file>]\n";
X
X    fprintf(stderr, "\nUSAGE: %s %s\n\n", prognm, usage);
X    fprintf(stderr, "\tThis program tests the throughput to sites by connecting\n");
X    fprintf(stderr, "\tto the discard port (TCP port 9) and writing data into\n");
X    fprintf(stderr, "\tit as fast as it can and measuring the transfer rate.\n");
X
X    fprintf(stderr,"\tBy default, the list of sites to monitor is in %s\n",
X	    ipnodes);
X    fprintf(stderr,"\tbut can be changed on the command line.\n");
X
X    fprintf(stderr,"\tThe 'config file' format is:\n");
X    fprintf(stderr,"\t\t <hostname> <ip-address>  <threshold> [TEST]\n");
X    fprintf(stderr,"\t\t POLLINTERVAL <number of secs>\n");
X    fprintf(stderr,"\tThe program writes its pid in %s.pid and \n",prognm);
X    fprintf(stderr,"\tif a new process starts, it kills the earlier one.\n");
X    fprintf(stderr,"\tIf a HUP signal is sent to the process, it rescans ");
X    fprintf(stderr,"the config file. \n");
X    return (1);
X}
X
X
X/*
X** FUNCTION
X**
X**	init_sites
X**
X**	This function writes to the LSTFILE. All sites in the NODESFILE
X**	file are set to UNINIT status.
X**
X**	Careful while using 'localtime': the calue of the month varies from
X**	0 - 11 and hence has to be incremented for the correct month.
X*/
X
Xinit_sites(fdout, ipnodes)
X     int fdout ;			/* Output file descriptor	*/
X     char *ipnodes;			/* Filename of the ipnodes file	*/
X{
X    extern char sigtoprog[];		/* In pingmon.h			*/
X    extern char *sender ;
X    FILE *p_nodes ;
X    EVENT v;				/* Defined in NOCOL.H		*/
X    char record[MAXLINE];
X    struct tm *loctime ;
X    time_t locclock ;			/* Careful, don't use 'long'	*/
X
X    if ((p_nodes = fopen(ipnodes, "r")) == NULL)
X    {
X	fprintf(stderr, "%s error (init_sites) ", prognm) ;
X	perror (ipnodes);
X	return (-1);
X    }
X
X    /*
X     * Fill in the static data stuff
X     */
X    bzero (&v, sizeof(v)) ;
X    locclock = time((time_t *)0);
X    loctime = localtime((long *)&locclock);
X
X    v.mon = loctime->tm_mon + 1;        v.day = loctime->tm_mday;
X    v.hour = loctime->tm_hour;          v.min = loctime->tm_min;
X
X    /*
X     * in the following strncpy's, the NULL is already appended because
X     * of the bzero, and copying one less than size of the arrays.
X     */
X    strncpy (v.sender, sender, sizeof(v.sender) - 1);
X
X    strncpy (v.var.name, VARNM, sizeof (v.var.name) - 1);
X    strncpy (v.var.units, VARUNITS, sizeof (v.var.units) - 1);
X    v.var.value = 0 ; v.var.threshold = 0 ;	/* threshold reset below */
X    v.nocop = SETF_UPDOUN (v.nocop, n_UNKNOWN); /* Set all to UNKNOWN   */
X    v.severity = E_INFO ;
X
X    while(fgetline(p_nodes,record,MAXLINE) > 0 ) 
X    {
X	u_long inet_addr() ;
X	char *p;		/* for strtol */
X	u_long thresh;
X	char w1[MAXLINE], w2[MAXLINE], w3[MAXLINE], w4[MAXLINE];
X		/* Confg words	*/
X	int rc;						/* return code	*/
X
X	v.nocop = 0 ;				/* Init options to zero	*/
X	*w1 = *w2 = *w3 = *w4 = NULL ;
X        /* line should look like "<name>  <IP#>  <threshold>  [TEST]" */
X	rc = sscanf(record,"%s %s %s %s", w1, w2, w3, w4);
X	if (rc == 0 || *w1 == NULL || *w1 == '#')  /* Comment or blank 	*/
X	  continue;
X
X	if (strncmp(w1, "POLLINT", 7) == 0 || strncmp(w1, "pollint", 7) == 0)
X	{
X	    pollinterval = (u_long)strtol(w2, &p, 0) ;
X	    if (p == w2)
X	    {
X		fprintf(stderr,"(%s): Error in format for POLLINTERVAL '%s'\n",
X			prognm, w2) ;
X		pollinterval = 0 ;		/* reset to default above */
X	    }
X	    continue ;
X	}
X
X	strncpy(v.site.name, w1, sizeof(v.site.name) - 1);
X	strncpy(v.site.addr, w2, sizeof(v.site.addr) - 1);	/* no checks */
X
X	if (inet_addr(w2) == -1)	/* bad address */
X	{
X	    fprintf(stderr,
X		    "(%s): Error in address '%s' for site '%s', ignoring\n",
X		    prognm, w2, w1);
X	    continue ;
X	}
X
X        thresh = (u_long)strtol(w3, &p, 0);
X        if (p == w3) { 			/* strtod() couldn't convert */
X          fprintf(stderr,
X            "(%s): Error in format of threshold '%s' for site '%s'\n", 
X		  prognm, w3, w1);
X	  fprintf(stderr,
X            "\t(should be a long integer representing bits per second)\n");
X        } else
X          v.var.threshold = thresh;
X          	
X	if (*w4 != NULL)			/* Some other keyword	*/
X	{
X	    if (strcmp(w4, "test") == 0 || strcmp(w3, "TEST") == 0)
X	      v.nocop = v.nocop | n_TEST ;
X	    else
X	      fprintf(stderr, "%s: Ignoring unknown keyword- %s\n", prognm,w3);
X	}
X
X	write (fdout, (char *)&v, sizeof(v)) ;
X
X    }					/* end: while			*/
X    fclose (p_nodes);			/* Not needed any more		*/    
X    return(1);				/* All OK			*/
X}		/* end:  init_sites()		*/
X
X
X/*+ 		restart
X** FUNCTION:
X**
X** 	If a SIGHUP is sent, it rescans the ipnodes file and starts all
X** over without exiting from the program.
X**/
X
Xvoid restart ()
X{
X    closeeventlog() ;
X    longjmp (env, 1);
X}
X
X/*+             done
X** FUNCTION:
X**
X** Delete the PID and data file.
X** Called just before exiting. Only if error. Exits since it can be called
X** on recieving a signal.
X**/
Xvoid done ()
X{
X    char pidfile[MAXLINE] ;
X
X    closeeventlog() ;				/* Logging */
X    fprintf (stderr, "%s: removing pid, data file.... ", prognm);
X    sprintf (pidfile, "%s/%s.pid\0", ETCDIR, prognm);
X    unlink (pidfile);                           /* remove the PID file  */
X    unlink (datafile);                          /* delete the data file */
X    fprintf (stderr, "Done\n");
X    exit (1);
X}		/* end  done() */
END_OF_FILE
  if test 11468 -ne `wc -c <'nocol-3.0/src/tpmon/main.c'`; then
    echo shar: \"'nocol-3.0/src/tpmon/main.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/tpmon/main.c'
fi
echo shar: End of archive 16 \(of 26\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
