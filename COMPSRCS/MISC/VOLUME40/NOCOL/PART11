Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i141:  nocol - Network Monitoring System, Part11/26
Message-ID: <1993Nov23.035340.6556@sparky.sterling.com>
X-Md4-Signature: 88261bb1cddafcb6a83b1291f411f7e4
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 23 Nov 1993 03:53:40 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 141
Archive-name: nocol/part11
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/cmu-snmp/mib.txt.cmu
#   nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip
#   nocol-3.0/src/include/noclogd.h
# Wrapped by kent@sparky on Tue Nov  9 22:22:18 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 26)."'
if test -f 'nocol-3.0/src/cmu-snmp/mib.txt.cmu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/mib.txt.cmu'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/mib.txt.cmu'\" \(37470 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/mib.txt.cmu' <<'END_OF_FILE'
X		  mgmt	     OBJECT IDENTIFIER ::= { iso org(3) dod(6) internet(1) mgmt(2) }
X                  mib        OBJECT IDENTIFIER ::= { mgmt 1 }
X		  directory  OBJECT IDENTIFIER ::= { internet 1 }
X		  experimental   OBJECT IDENTIFIER ::= { internet 3 }
X		  private    OBJECT IDENTIFIER ::= { internet 4 }
X		  enterprises OBJECT IDENTIFIER ::= { private 1 }
X
X                  system     OBJECT IDENTIFIER ::= { mib 1 }
X                  interfaces OBJECT IDENTIFIER ::= { mib 2 }
X                  at         OBJECT IDENTIFIER ::= { mib 3 }
X                  ip         OBJECT IDENTIFIER ::= { mib 4 }
X                  icmp       OBJECT IDENTIFIER ::= { mib 5 }
X                  tcp        OBJECT IDENTIFIER ::= { mib 6 }
X                  udp        OBJECT IDENTIFIER ::= { mib 7 }
X                  egp        OBJECT IDENTIFIER ::= { mib 8 }
X
X                  -- object types
X
X                  -- the System group
X
X                  sysDescr OBJECT-TYPE
X                          SYNTAX  OCTET STRING
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { system 1 }
X
X                  sysObjectID OBJECT-TYPE
X                          SYNTAX  OBJECT IDENTIFIER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { system 2 }
X
X                  sysUpTime OBJECT-TYPE
X                          SYNTAX  TimeTicks
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { system 3 }
X
X                  -- the Interfaces group
X
X                  ifNumber OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { interfaces 1 }
X
X                  -- the Interfaces table
X
X                  ifTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF IfEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { interfaces 2 }
X
X                  ifEntry OBJECT-TYPE
X                          SYNTAX  IfEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ifTable 1 }
X
X                  IfEntry ::= SEQUENCE {
X                      ifIndex
X                          INTEGER,
X                      ifDescr
X                          OCTET STRING,
X                      ifType
X                          INTEGER,
X                      ifMtu
X                          INTEGER,
X                      ifSpeed
X                          Gauge,
X                      ifPhysAddress
X                          OCTET STRING,
X                      ifAdminStatus
X                          INTEGER,
X                      ifOperStatus
X                          INTEGER,
X                      ifLastChange
X                          TimeTicks,
X                      ifInOctets
X                          Counter,
X                      ifInUcastPkts
X                          Counter,
X                      ifInNUcastPkts
X                          Counter,
X                      ifInDiscards
X                          Counter,
X                      ifInErrors
X                          Counter,
X                      ifInUnknownProtos
X                          Counter,
X                      ifOutOctets
X                          Counter,
X                      ifOutUcastPkts
X                          Counter,
X                      ifOutNUcastPkts
X                          Counter,
X                      ifOutDiscards
X                          Counter,
X                      ifOutErrors
X                          Counter,
X                      ifOutQLen
X                          Gauge
X                  }
X
X                  ifIndex OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 1 }
X
X                  ifDescr OBJECT-TYPE
X                          SYNTAX  OCTET STRING
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 2 }
X
X                  ifType OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                                  other(1),     -- none of the following
X                                  regular1822(2),
X                                  hdh1822(3),
X                                  ddn-x25(4),
X                                  rfc877-x25(5),
X                                  ethernet-csmacd(6),
X                                  iso88023-csmacd(7),
X                                  iso88024-tokenBus(8),
X                                  iso88025-tokenRing(9),
X                                  iso88026-man(10),
X                                  starLan(11),
X                                  proteon-10MBit(12),
X                                  proteon-80MBit(13),
X                                  hyperchannel(14),
X                                  fddi(15),
X                                  lapb(16),
X                                  sdlc(17),
X                                  t1-carrier(18),
X                                  cept(19),
X                                  basicIsdn(20),
X                                  primaryIsdn(21),
X                                                   -- proprietary serial
X                                  propPointToPointSerial(22)
X                              }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 3 }
X
X                  ifMtu OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 4 }
X
X                  ifSpeed OBJECT-TYPE
X                          SYNTAX  Gauge
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 5 }
X
X                  ifPhysAddress OBJECT-TYPE
X                          SYNTAX  OCTET STRING
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 6 }
X
X                  ifAdminStatus OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                                  up(1),        -- ready to pass packets
X                                  down(2),
X                                  testing(3)    -- in some test mode
X                                  }
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ifEntry 7 }
X
X                  ifOperStatus OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                                  up(1),        -- ready to pass packets
X                                  down(2),
X                                  testing(3)    -- in some test mode
X                                  }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 8 }
X
X                  ifLastChange OBJECT-TYPE
X                          SYNTAX  TimeTicks
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 9 }
X
X                  ifInOctets OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 10 }
X
X                  ifInUcastPkts OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::=  { ifEntry 11 }
X
X                  ifInNUcastPkts OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 12 }
X
X                  ifInDiscards OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 13 }
X
X                  ifInErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 14 }
X
X                  ifInUnknownProtos OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 15 }
X
X                  ifOutOctets OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 16 }
X
X                  ifOutUcastPkts OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 17 }
X
X                  ifOutNUcastPkts OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 18 }
X
X                  ifOutDiscards OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 19 }
X
X                  ifOutErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 20 }
X
X                  ifOutQLen OBJECT-TYPE
X                          SYNTAX  Gauge
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ifEntry 21 }
X
X                  -- the Address Translation group
X
X                  atTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF AtEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { at 1 }
X
X                  atEntry OBJECT-TYPE
X                          SYNTAX  AtEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { atTable 1 }
X
X                  AtEntry ::= SEQUENCE {
X                      atIfIndex
X                          INTEGER,
X                      atPhysAddress
X                          OCTET STRING,
X                      atNetAddress
X                          NetworkAddress
X                  }
X
X                  atIfIndex OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { atEntry 1 }
X
X                  atPhysAddress OBJECT-TYPE
X                          SYNTAX  OCTET STRING
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { atEntry 2 }
X
X                  atNetAddress OBJECT-TYPE
X                          SYNTAX  NetworkAddress
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { atEntry 3 }
X
X                  -- the IP group
X
X                  ipForwarding OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                        gateway(1), -- entity forwards datagrams
X                        host(2)     -- entity does NOT forward datagrams
X                                  }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 1 }
X
X                  ipDefaultTTL OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ip 2 }
X
X                  ipInReceives OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 3 }
X
X                  ipInHdrErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 4 }
X
X                  ipInAddrErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 5 }
X
X                  ipForwDatagrams OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 6 }
X
X                  ipInUnknownProtos OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 7 }
X
X                  ipInDiscards OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 8 }
X
X                  ipInDelivers OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 9 }
X
X                  ipOutRequests OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 10 }
X
X                  ipOutDiscards OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 11 }
X
X                  ipOutNoRoutes OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 12 }
X
X                  ipReasmTimeout OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 13 }
X
X                  ipReasmReqds OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 14 }
X
X                  ipReasmOKs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 15 }
X
X                  ipReasmFails OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 16 }
X
X                  ipFragOKs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 17 }
X
X                  ipFragFails OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 18 }
X
X                  ipFragCreates OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 19 }
X
X                  -- the IP Interface table
X
X                  ipAddrTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF IpAddrEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ip 20 }
X
X                  ipAddrEntry OBJECT-TYPE
X                          SYNTAX  IpAddrEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ipAddrTable 1 }
X
X                  IpAddrEntry ::= SEQUENCE {
X                      ipAdEntAddr
X                          IpAddress,
X                      ipAdEntIfIndex
X                          INTEGER,
X                      ipAdEntNetMask
X                          IpAddress,
X                      ipAdEntBcastAddr
X                          INTEGER
X                  }
X
X                  ipAdEntAddr OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::=  { ipAddrEntry 1 }
X
X                  ipAdEntIfIndex OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::=  { ipAddrEntry 2 }
X
X                  ipAdEntNetMask OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::=  { ipAddrEntry 3 }
X
X                  ipAdEntBcastAddr OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ipAddrEntry 4 }
X
X                  -- the IP Routing table
X
X                  ipRoutingTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF IpRouteEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ip 21 }
X
X                  ipRouteEntry OBJECT-TYPE
X                          SYNTAX  IpRouteEntry
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRoutingTable 1 }
X
X                  IpRouteEntry ::= SEQUENCE {
X                      ipRouteDest
X                          IpAddress,
X                      ipRouteIfIndex
X                          INTEGER,
X                      ipRouteMetric1
X                          INTEGER,
X                      ipRouteMetric2
X                          INTEGER,
X                      ipRouteMetric3
X                          INTEGER,
X                      ipRouteMetric4
X                          INTEGER,
X                      ipRouteNextHop
X                          IpAddress,
X                      ipRouteType
X                          INTEGER,
X                      ipRouteProto
X                          INTEGER,
X                      ipRouteAge
X                          INTEGER
X                  }
X
X                  ipRouteDest OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 1 }
X
X                  ipRouteIfIndex  OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 2 }
X
X                  ipRouteMetric1 OBJECT-TYPE
X
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 3 }
X
X                  ipRouteMetric2 OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 4 }
X
X                  ipRouteMetric3 OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 5 }
X
X                  ipRouteMetric4 OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 6 }
X
X                  ipRouteNextHop OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 7 }
X
X                  ipRouteType OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                            other(1),      -- none of the following
X
X                            invalid(2),    -- an invalidated route
X
X                                           -- route to directly
X                            direct(3),     -- connected (sub-)network
X
X                                           -- route to a non-local
X                            remote(4),     -- host/network/sub-network
X                              }
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 8 }
X
X                  ipRouteProto OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                            other(1),     -- none of the following
X
X                                          -- non-protocol information
X                                          --   e.g., manually
X                            local(2),     --   configured entries
X
X                                          -- set via a network
X                            netmgmt(3),   --   management protocol
X
X                                          -- obtained via ICMP,
X                            icmp(4),      --   e.g., Redirect
X
X                                          -- the following are
X                                          -- gateway routing protocols
X                            egp(5),
X                            ggp(6),
X                            hello(7),
X                            rip(8),
X                            is-is(9),
X                            es-is(10),
X                            ciscoIgrp(11),
X                            bbnSpfIgp(12),
X                            oigp(13)
X                              }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 9 }
X
X                  ipRouteAge OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-write
X                          STATUS  mandatory
X                          ::= { ipRouteEntry 10 }
X
X                  -- the ICMP group
X
X                  icmpInMsgs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 1 }
X
X                  icmpInErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 2 }
X
X                  icmpInDestUnreachs OBJECT-TYPE
X                          SYNTAX  Counter
X
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 3 }
X
X                  icmpInTimeExcds OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 4 }
X
X                  icmpInParmProbs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 5 }
X
X                  icmpInSrcQuenchs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 6 }
X
X                  icmpInRedirects OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 7 }
X
X                  icmpInEchos OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 8 }
X
X                  icmpInEchoReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 9 }
X
X                  icmpInTimestamps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 10 }
X
X                  icmpInTimestampReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 11 }
X
X                  icmpInAddrMasks OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 12 }
X
X                  icmpInAddrMaskReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 13 }
X
X                  icmpOutMsgs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 14 }
X
X                  icmpOutErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 15 }
X
X                  icmpOutDestUnreachs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 16 }
X
X                  icmpOutTimeExcds OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 17 }
X
X                  icmpOutParmProbs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 18 }
X
X                  icmpOutSrcQuenchs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 19 }
X
X                  icmpOutRedirects OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 20 }
X
X                  icmpOutEchos OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 21 }
X
X                  icmpOutEchoReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 22 }
X
X                  icmpOutTimestamps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 23 }
X
X                  icmpOutTimestampReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 24 }
X
X                  icmpOutAddrMasks OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 25 }
X
X                  icmpOutAddrMaskReps OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { icmp 26 }
X
X                  -- the TCP group
X
X                  tcpRtoAlgorithm OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                          other(1),    -- none of the following
X                          constant(2), -- a constant rto
X                          rsre(3),     -- MIL-STD-1778, Appendix B
X                          vanj(4)      -- Van Jacobson's algorithm [11]
X                                  }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 1 }
X
X                  tcpRtoMin OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 2 }
X
X                  tcpRtoMax OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 3 }
X
X                  tcpMaxConn OBJECT-TYPE
X                          SYNTAX  INTEGER
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 4 }
X
X                  tcpActiveOpens OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 5 }
X
X                  tcpPassiveOpens OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 6 }
X
X                  tcpAttemptFails OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 7 }
X
X                  tcpEstabResets OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 8 }
X
X                  tcpCurrEstab OBJECT-TYPE
X                          SYNTAX  Gauge
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 9 }
X
X                  tcpInSegs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 10 }
X
X                  tcpOutSegs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 11 }
X
X                  tcpRetransSegs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 12 }
X
X                  -- the TCP connections table
X
X                  tcpConnTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF TcpConnEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcp 13 }
X
X                  tcpConnEntry OBJECT-TYPE
X                          SYNTAX  TcpConnEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnTable 1 }
X
X                  TcpConnEntry ::= SEQUENCE {
X                      tcpConnState
X                          INTEGER,
X                      tcpConnLocalAddress
X                          IpAddress,
X                      tcpConnLocalPort
X                          INTEGER (0..65535),
X                      tcpConnRemAddress
X                          IpAddress,
X                      tcpConnRemPort
X                          INTEGER (0..65535)
X                  }
X
X                  tcpConnState OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                                      closed(1),
X                                      listen(2),
X                                      synSent(3),
X                                      synReceived(4),
X                                      established(5),
X                                      finWait1(6),
X                                      finWait2(7),
X                                      closeWait(8),
X                                      lastAck(9),
X                                      closing(10),
X                                      timeWait(11)
X                                  }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnEntry 1 }
X
X                  tcpConnLocalAddress OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnEntry 2 }
X
X                  tcpConnLocalPort OBJECT-TYPE
X                          SYNTAX  INTEGER (0..65535)
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnEntry 3 }
X
X                  tcpConnRemAddress OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnEntry 4 }
X
X                  tcpConnRemPort OBJECT-TYPE
X                          SYNTAX  INTEGER (0..65535)
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { tcpConnEntry 5 }
X
X                  -- the UDP group
X
X                  udpInDatagrams OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { udp 1 }
X
X                  udpNoPorts OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { udp 2 }
X
X                  udpInErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { udp 3 }
X
X                  udpOutDatagrams OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { udp 4 }
X
X                  -- the EGP group
X
X                  egpInMsgs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egp 1 }
X
X                  egpInErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egp 2 }
X
X                  egpOutMsgs OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egp 3 }
X
X                  egpOutErrors OBJECT-TYPE
X                          SYNTAX  Counter
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egp 4 }
X
X                  -- the EGP Neighbor table
X
X                  egpNeighTable OBJECT-TYPE
X                          SYNTAX  SEQUENCE OF EgpNeighEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egp 5 }
X
X                  egpNeighEntry OBJECT-TYPE
X                          SYNTAX  EgpNeighEntry
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egpNeighTable 1 }
X
X                  EgpNeighEntry ::= SEQUENCE {
X                      egpNeighState
X                          INTEGER,
X                      egpNeighAddr
X                          IpAddress
X                  }
X
X                  egpNeighState OBJECT-TYPE
X                          SYNTAX  INTEGER {
X                                      idle(1),
X                                      acquisition(2),
X                                      down(3),
X                                      up(4),
X                                      cease(5)
X                                  }
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egpNeighEntry 1 }
X
X                  egpNeighAddr OBJECT-TYPE
X                          SYNTAX  IpAddress
X                          ACCESS  read-only
X                          STATUS  mandatory
X                          ::= { egpNeighEntry 2 }
X
X		  cmu OBJECT IDENTIFIER ::= { enterprises 3 }
X		  systems OBJECT IDENTIFIER ::= { cmu 1 }
X		  mibs OBJECT IDENTIFIER ::= { cmu 2 }
X		  cmuSNMP OBJECT IDENTIFIER ::= { systems 1 }
X		  cmuKip OBJECT IDENTIFIER ::= { systems 2 }
X		  cmuRouter OBJECT IDENTIFIER ::= { systems 3 }
END_OF_FILE
  if test 37470 -ne `wc -c <'nocol-3.0/src/cmu-snmp/mib.txt.cmu'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/mib.txt.cmu'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/mib.txt.cmu'
fi
if test -f 'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip'\" \(33903 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip' <<'END_OF_FILE'
X/*
X * snmp_vars.c - return a pointer to the named variable.
X *
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#ifdef KINETICS
X#include "gw.h"
X#include "fp4/pbuf.h"
X#include "fp4/cmdmacro.h"
X#include "ab.h"
X#include "glob.h"
X#endif
X
X#if (defined(unix) && !defined(KINETICS))
X#include <sys/types.h>
X#include <netinet/in.h>
X#ifndef NULL
X#define NULL 0
X#endif
X#endif
X
X
X#include "asn1.h"
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "mib.h"
X#include "inet.h"
X#include "snmp_vars.h"
X/*
X *	Each variable name is placed in the variable table, without the terminating
X * substring that determines the instance of the variable.  When a string is found that
X * is lexicographicly preceded by the input string, the function for that entry is
X * called to find the method of access of the instance of the named variable.  If
X * that variable is not found, NULL is returned, and the search through the table
X * continues (it should stop at the next entry).  If it is found, the function returns
X * a character pointer and a length or a function pointer.  The former is the address
X * of the operand, the latter is an access routine for the variable.
X *
X * u_char *
X * findVar(name, length, exact, var_len, access_method)
X * oid	    *name;	    IN/OUT - input name requested, output name found
X * int	    length;	    IN/OUT - number of sub-ids in the in and out oid's
X * int	    exact;	    IN - TRUE if an exact match was requested.
X * int	    len;	    OUT - length of variable or 0 if function returned.
X * int	    access_method; OUT - 1 if function, 0 if char pointer.
X *
X * accessVar(rw, var, varLen)
X * int	    rw;	    IN - request to READ or WRITE the variable
X * u_char   *var;   IN/OUT - input or output buffer space
X * int	    *varLen;IN/OUT - input and output buffer len
X */
X
Xstruct variable {
X    oid		    name[16];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char	    *(*findVar)();  /* function that finds variable */
X};
X
Xchar		version_descr[30] = "Kinetics FastPath4";
Xoid		version_id[] = {1, 3, 6, 1, 4, 1, 3, 1, 1};
Xint		version_id_len = sizeof(version_id);
Xu_long		uptime;
Xlong		cfg_nnets = MAX_INTERFACES;
Xlong		long_return;
Xu_char		return_buf[64];
X
X
Xstruct mib_ifEntry  mib_ifEntry_proto[MAX_INTERFACES] = {
X    {1, "Kinetics KFPS2 Ethernet", MIB_IFTYPE_ETHERNETCSMACD, 
X    	1500, 10000000L, "", 
X	6, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
X    {2, "Kinetics KFPS2 Appletalk", MIB_IFTYPE_OTHER,
X    	1500, 230000L, "", 
X	3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
X};
Xstruct mib_ifEntry mib_ifEntry[MAX_INTERFACES];
X
Xstruct mib_ip mib_ip_proto = {
X    1, IPFRAGTTL, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
X};
Xstruct mib_ip mib_ip;
X
X#define ROUTE_DEFAULT	0
X#define ROUTE_LOCAL	1
Xstruct mib_ipRouteEntry mib_ipRouteEntry_proto[2] = {
X    {0, 1, 1, -1, -1, -1, 0, MIB_IPROUTETYPE_REMOTE, MIB_IPROUTEPROTO_LOCAL, 0},    /* default route */
X    {0, 1, 0, -1, -1, -1, 0, MIB_IPROUTETYPE_DIRECT, MIB_IPROUTEPROTO_LOCAL, 0}	    /* local route */
X};
Xstruct mib_ipRouteEntry mib_ipRouteEntry[2];
X
Xstruct mib_udp mib_udp_proto = {
X    0, 0, 0, 0
X};
Xstruct mib_udp mib_udp;
X
Xlong	mib_icmpInMsgs;
Xlong	mib_icmpOutMsgs;
Xlong	mib_icmpInErrors;	/* not checked in KIP */
Xlong	mib_icmpOutErrors;	/* not checked in KIP */
Xlong	mib_icmpInCount[ICMP_MAXTYPE + 1];
Xlong	mib_icmpOutCount[ICMP_MAXTYPE + 1];
X
X
Xinit_snmp(){
X    bcopy((char *)mib_ifEntry_proto, (char *)mib_ifEntry, sizeof(mib_ifEntry));
X    bcopy((char *)&mib_ip_proto, (char *)&mib_ip, sizeof(mib_ip));
X    bcopy((char *)mib_ipRouteEntry_proto, (char *)mib_ipRouteEntry, sizeof(mib_ipRouteEntry));
X    bcopy((char *)&mib_udp_proto, (char *)&mib_udp, sizeof(mib_udp));
X}
X
X/*
X * These are byte offsets into their structures.
X * This really should be computed by the compiler, but the
X * compiler I'm using doesn't want to do this.
X */
X#define VERSION_DESCR	0
X#define VERSION_ID	32
X#define CFG_NNETS	48
X#define UPTIME		52
X
X#define IFINDEX		0
X#define IFDESCR		4
X#define IFTYPE		36
X#define IFMTU		40
X#define IFSPEED		44
X#define IFPHYSADDRESS	48
X#define IFADMINSTATUS	60
X#define IFOPERSTATUS	64
X#define IFLASTCHANGE	68
X#define IFINOCTETS	72
X#define IFINUCASTPKTS	76
X#define	IFINNUCASTPKTS	80
X#define	IFINDISCARDS	84
X#define	IFINERRORS	88
X#define	IFINUNKNOWNPROTOS   92
X#define	IFOUTOCTETS	96
X#define	IFOUTUCASTPKTS	100
X#define	IFOUTNUCASTPKTS	104
X#define	IFOUTDISCARDS	108
X#define	IFOUTERRORS	112
X#define	IFOUTQLEN	116
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	4
X#define ATNETADDRESS	16
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	4
X#define IPINRECEIVES	8
X#define IPINHDRERRORS	12
X#define IPINADDRERRORS	16
X#define IPFORWDATAGRAMS	20
X#define IPINUNKNOWNPROTOS   24
X#define IPINDISCARDS	28
X#define IPINDELIVERS	32
X#define IPOUTREQUESTS	36
X#define IPOUTDISCARDS	40
X#define IPOUTNOROUTES	44
X#define IPREASMTIMEOUT	48
X#define IPREASMREQDS	52
X#define IPREASMOKS	56
X#define IPREASMFAILS	60
X#define IPFRAGOKS	64
X#define IPFRAGFAILS	68
X#define IPFRAGCREATES	72
X
X#define IPADADDR	0
X#define IPADIFINDEX	4
X#define IPADNETMASK	8
X#define IPADBCASTADDR	12
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	4
X#define IPROUTEMETRIC1	8
X#define IPROUTEMETRIC2	12
X#define IPROUTEMETRIC3	16
X#define IPROUTEMETRIC4	20
X#define IPROUTENEXTHOP	24
X#define IPROUTETYPE	28
X#define IPROUTEPROTO	32
X#define IPROUTEAGE	36
X
X#define	ICMPINMSGS	    0
X#define	ICMPINERRORS	    4
X#define	ICMPINDESTUNREACHS  8
X#define	ICMPINTIMEEXCDS	    12
X#define	ICMPINPARMPROBS	    16
X#define	ICMPINSRCQUENCHS    20
X#define	ICMPINREDIRECTS	    24
X#define	ICMPINECHOS	    28
X#define	ICMPINECHOREPS	    32
X#define	ICMPINTIMESTAMPS    36
X#define	ICMPINTIMESTAMPREPS 40
X#define	ICMPINADDRMASKS	    44
X#define	ICMPINADDRMASKREPS  48
X#define	ICMPOUTMSGS	    52
X#define	ICMPOUTERRORS	    56
X#define	ICMPOUTDESTUNREACHS 60
X#define	ICMPOUTTIMEEXCDS    64
X#define	ICMPOUTPARMPROBS    68
X#define	ICMPOUTSRCQUENCHS   72
X#define	ICMPOUTREDIRECTS    76
X#define	ICMPOUTECHOS	    80
X#define	ICMPOUTECHOREPS	    84
X#define	ICMPOUTTIMESTAMPS   88
X#define	ICMPOUTTIMESTAMPREPS	92
X#define	ICMPOUTADDRMASKS    96
X#define	ICMPOUTADDRMASKREPS 100
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    4
X#define	UDPINERRORS	    8
X#define UDPOUTDATAGRAMS	    12
X
Xstruct variable	    variables[] = {
X    /* these must be lexicographly ordered by the name field */
X    {{MIB, 1, 1, 0},		9, STRING,  VERSION_DESCR, RONLY, var_system },
X    {{MIB, 1, 2, 0},		9, OBJID,   VERSION_ID, RONLY, var_system },
X    {{MIB, 1, 3, 0},		9, TIMETICKS, UPTIME, RONLY, var_system },
X    {{MIB, 2, 1, 0},		9, INTEGER, CFG_NNETS, RONLY, var_system },
X    {{MIB, 2, 2, 1, 1, 0xFF},  11, INTEGER, IFINDEX, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 2, 0xFF},  11, STRING,  IFDESCR, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 3, 0xFF},  11, INTEGER, IFTYPE, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 4, 0xFF},  11, INTEGER, IFMTU, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 5, 0xFF},  11, GAUGE,   IFSPEED, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 6, 0xFF},  11, STRING,  IFPHYSADDRESS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 7, 0xFF},  11, INTEGER, IFADMINSTATUS, RWRITE, var_ifEntry },
X    {{MIB, 2, 2, 1, 8, 0xFF},  11, INTEGER, IFOPERSTATUS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 9, 0xFF},  11, TIMETICKS, IFLASTCHANGE, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 10, 0xFF}, 11, COUNTER, IFINOCTETS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 11, 0xFF}, 11, COUNTER, IFINUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 12, 0xFF}, 11, COUNTER, IFINNUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 13, 0xFF}, 11, COUNTER, IFINDISCARDS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 14, 0xFF}, 11, COUNTER, IFINERRORS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 15, 0xFF}, 11, COUNTER, IFINUNKNOWNPROTOS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 16, 0xFF}, 11, COUNTER, IFOUTOCTETS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 17, 0xFF}, 11, COUNTER, IFOUTUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 18, 0xFF}, 11, COUNTER, IFOUTNUCASTPKTS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 19, 0xFF}, 11, COUNTER, IFOUTDISCARDS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 20, 0xFF}, 11, COUNTER, IFOUTERRORS, RONLY, var_ifEntry },
X    {{MIB, 2, 2, 1, 21, 0xFF}, 11, GAUGE,   IFOUTQLEN, RONLY, var_ifEntry },
X    {{MIB, 3, 1, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, INTEGER,    ATIFINDEX, RWRITE, var_atEntry }, 
X    {{MIB, 3, 1, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, STRING,	    ATPHYSADDRESS, RWRITE, var_atEntry }, 
X    {{MIB, 3, 1, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 16, IPADDRESS,  ATNETADDRESS, RWRITE, var_atEntry },
X    {{MIB, 4, 1, 0},	    9, INTEGER, IPFORWARDING, RONLY, var_ip },
X    {{MIB, 4, 2, 0},	    9, INTEGER, IPDEFAULTTTL, RWRITE, var_ip },
X    {{MIB, 4, 3, 0},	    9, COUNTER, IPINRECEIVES, RONLY, var_ip },
X    {{MIB, 4, 4, 0},	    9, COUNTER, IPINHDRERRORS, RONLY, var_ip },
X    {{MIB, 4, 5, 0},	    9, COUNTER, IPINADDRERRORS, RONLY, var_ip },
X    {{MIB, 4, 6, 0},	    9, COUNTER, IPFORWDATAGRAMS, RONLY, var_ip },
X    {{MIB, 4, 7, 0},	    9, COUNTER, IPINUNKNOWNPROTOS, RONLY, var_ip },
X    {{MIB, 4, 8, 0},	    9, COUNTER, IPINDISCARDS, RONLY, var_ip },
X    {{MIB, 4, 9, 0},	    9, COUNTER, IPINDELIVERS, RONLY, var_ip },
X    {{MIB, 4, 10, 0},	    9, COUNTER, IPOUTREQUESTS, RONLY, var_ip },
X    {{MIB, 4, 11, 0},	    9, COUNTER, IPOUTDISCARDS, RONLY, var_ip },
X    {{MIB, 4, 12, 0},	    9, COUNTER, IPOUTNOROUTES, RONLY, var_ip },
X    {{MIB, 4, 13, 0},	    9, INTEGER, IPREASMTIMEOUT, RONLY, var_ip },
X    {{MIB, 4, 14, 0},	    9, COUNTER, IPREASMREQDS, RONLY, var_ip },
X    {{MIB, 4, 15, 0},	    9, COUNTER, IPREASMOKS, RONLY, var_ip },
X    {{MIB, 4, 16, 0},	    9, COUNTER, IPREASMFAILS, RONLY, var_ip },
X    {{MIB, 4, 17, 0},	    9, COUNTER, IPFRAGOKS, RONLY, var_ip },
X    {{MIB, 4, 18, 0},	    9, COUNTER, IPFRAGFAILS, RONLY, var_ip },
X    {{MIB, 4, 19, 0},	    9, COUNTER, IPFRAGCREATES, RONLY, var_ip },
X    {{MIB, 4, 20, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPADADDR, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPADIFINDEX, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPADNETMASK, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 20, 1, 4, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPADBCASTADDR, RONLY, var_ipAddrEntry },
X    {{MIB, 4, 21, 1, 1, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPROUTEDEST, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 2, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEIFINDEX, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 3, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC1, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 4, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC2, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 5, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC3, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 6, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEMETRIC4, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 7, 0xFF, 0xFF, 0xFF, 0xFF}, 14, IPADDRESS, IPROUTENEXTHOP, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 8, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTETYPE, RWRITE, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 9, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEPROTO, RONLY, var_ipRouteEntry },
X    {{MIB, 4, 21, 1, 10, 0xFF, 0xFF, 0xFF, 0xFF}, 14, INTEGER,	IPROUTEAGE, RWRITE, var_ipRouteEntry },
X    {{MIB, 5, 1, 0},	    9, COUNTER, ICMPINMSGS, RONLY, var_icmp },
X    {{MIB, 5, 2, 0},	    9, COUNTER, ICMPINERRORS, RONLY, var_icmp },
X    {{MIB, 5, 3, 0},	    9, COUNTER, ICMPINDESTUNREACHS, RONLY, var_icmp },
X    {{MIB, 5, 4, 0},	    9, COUNTER, ICMPINTIMEEXCDS, RONLY, var_icmp },
X    {{MIB, 5, 5, 0},	    9, COUNTER, ICMPINPARMPROBS, RONLY, var_icmp },
X    {{MIB, 5, 6, 0},	    9, COUNTER, ICMPINSRCQUENCHS, RONLY, var_icmp },
X    {{MIB, 5, 7, 0},	    9, COUNTER, ICMPINREDIRECTS, RONLY, var_icmp },
X    {{MIB, 5, 8, 0},	    9, COUNTER, ICMPINECHOS, RONLY, var_icmp },
X    {{MIB, 5, 9, 0},	    9, COUNTER, ICMPINECHOREPS, RONLY, var_icmp },
X    {{MIB, 5, 10, 0},	    9, COUNTER, ICMPINTIMESTAMPS, RONLY, var_icmp },
X    {{MIB, 5, 11, 0},	    9, COUNTER, ICMPINTIMESTAMPREPS, RONLY, var_icmp },
X    {{MIB, 5, 12, 0},	    9, COUNTER, ICMPINADDRMASKS, RONLY, var_icmp },
X    {{MIB, 5, 13, 0},	    9, COUNTER, ICMPINADDRMASKREPS, RONLY, var_icmp },
X    {{MIB, 5, 14, 0},	    9, COUNTER, ICMPOUTMSGS, RONLY, var_icmp },
X    {{MIB, 5, 15, 0},	    9, COUNTER, ICMPOUTERRORS, RONLY, var_icmp },
X    {{MIB, 5, 16, 0},	    9, COUNTER, ICMPOUTDESTUNREACHS, RONLY, var_icmp },
X    {{MIB, 5, 17, 0},	    9, COUNTER, ICMPOUTTIMEEXCDS, RONLY, var_icmp },
X    {{MIB, 5, 18, 0},	    9, COUNTER, ICMPOUTPARMPROBS, RONLY, var_icmp },
X    {{MIB, 5, 19, 0},	    9, COUNTER, ICMPOUTSRCQUENCHS, RONLY, var_icmp },
X    {{MIB, 5, 20, 0},	    9, COUNTER, ICMPOUTREDIRECTS, RONLY, var_icmp },
X    {{MIB, 5, 21, 0},	    9, COUNTER, ICMPOUTECHOS, RONLY, var_icmp },
X    {{MIB, 5, 22, 0},	    9, COUNTER, ICMPOUTECHOREPS, RONLY, var_icmp },
X    {{MIB, 5, 23, 0},	    9, COUNTER, ICMPOUTTIMESTAMPS, RONLY, var_icmp },
X    {{MIB, 5, 24, 0},	    9, COUNTER, ICMPOUTTIMESTAMPREPS, RONLY, var_icmp },
X    {{MIB, 5, 25, 0},	    9, COUNTER, ICMPOUTADDRMASKS, RONLY, var_icmp },
X    {{MIB, 5, 26, 0},	    9, COUNTER, ICMPOUTADDRMASKREPS, RONLY, var_icmp },
X    {{MIB, 7, 1, 0},	    9, COUNTER, UDPINDATAGRAMS, RONLY, var_udp }, 
X    {{MIB, 7, 2, 0},	    9, COUNTER, UDPNOPORTS, RONLY, var_udp },
X    {{MIB, 7, 3, 0},	    9, COUNTER, UDPINERRORS, RONLY, var_udp }, 
X    {{MIB, 7, 4, 0},	    9, COUNTER, UDPOUTDATAGRAMS, RONLY, var_udp }
X};
X
X
X
X
X/*
X * getStatPtr - return a pointer to the named variable, as well as it's
X * type, length, and access control list.
X *
X * If an exact match for the variable name exists, it is returned.  If not,
X * and exact is false, the next variable lexicographically after the
X * requested one is returned.
X *
X * If no appropriate variable can be found, NULL is returned.
X */
Xu_char  *
XgetStatPtr(name, namelen, type, len, acl, exact, access_method)
X    oid		*name;	    /* IN - name of var, OUT - name matched */
X    int		*namelen;   /* IN -number of sub-ids in name, OUT - subid-is in matched name */
X    u_char	*type;	    /* OUT - type of matched variable */
X    int		*len;	    /* OUT - length of matched variable */
X    u_short	*acl;	    /* OUT - access control list */
X    int		exact;	    /* IN - TRUE if exact match wanted */
X    int		*access_method; /* OUT - 1 if function, 0 if char * */
X{
X
X    register struct variable	*vp;
X
X    register int	x;
X    register u_char	*access;
X    int			result;
X
X    for(x = 0, vp = variables; x < sizeof(variables)/sizeof(struct variable); vp++, x++){
X	/*
X	 * compare should be expanded inline.
X	 */
X	result = compare(name, *namelen, vp->name, (int)vp->namelen);
X	if ((result < 0) || (exact && (result == 0))){
X	    access = (*(vp->findVar))(vp, name, namelen, exact, len, access_method);
X	    if (access != NULL)
X		break;
X	}
X    }
X    if (x == sizeof(variables)/sizeof(struct variable))
X	return NULL;
X
X    /* vp now points to the approprate struct */
X    *type = vp->type;
X    *acl = vp->acl;
X    return access;
X}
X
X
X
Xint
Xcompare(name1, len1, name2, len2)
X    register oid	    *name1, *name2;
X    register int	    len1, len2;
X{
X    register int    len;
X
X    /* len = minimum of len1 and len2 */
X    if (len1 < len2)
X	len = len1;
X    else
X	len = len2;
X    /* find first non-matching byte */
X    while(len-- > 0){
X	if (*name1 < *name2)
X	    return -1;
X	if (*name2++ < *name1++)
X	    return 1;
X    }
X    /* bytes match up to length of shorter string */
X    if (len1 < len2)
X	return -1;  /* name1 shorter, so it is "less" */
X    if (len2 < len1)
X	return 1;
X    return 0;	/* both strings are equal */
X}
X
X
Xu_char *
Xvar_system(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method;	/* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);	/* default length */
X    switch (vp->magic){
X	case VERSION_DESCR:
X	    *var_len = strlen(version_descr);
X	    return (u_char *)version_descr;
X	case VERSION_ID:
X	    *var_len = sizeof(version_id);
X	    return (u_char *)version_id;
X	case CFG_NNETS:
X	    return (u_char *)&cfg_nnets;
X	case UPTIME:
X	    return (u_char *)&uptime;
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_ifEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid			newname[MAX_NAME_LEN];
X    register int	interface;
X    register struct mib_ifEntry	*ifp;
X    extern struct conf	conf;
X    int			result;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* find "next" interface */
X    for(interface = 1; interface <= MAX_INTERFACES; interface++){
X	newname[10] = (oid)interface;
X	result = compare(name, *length, newname, (int)vp->namelen);
X	if ((exact && (result == 0)) || (!exact && (result < 0)))
X	    break;
X    }
X    if (interface > MAX_INTERFACES)
X	return NULL;
X    interface--; /* translate into internal index of interfaces */
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    ifp = &mib_ifEntry[interface];
X    switch (vp->magic){
X        case IFDESCR:
X	    *var_len = strlen(ifp->ifDescr);
X	    return (u_char *)ifp->ifDescr;
X	case IFPHYSADDRESS:
X	    *var_len = ifp->PhysAddrLen;
X	    if (interface == 0)
X	    	return (u_char *)ifie.if_haddr;
X	    else {
X		/*
X		 * As far as IP is concerned, the "physical" address includes the Appletalk
X		 * network address as well as node number.
X		 */
X		return_buf[0] = ((u_char *)&conf.atneta)[0];
X		return_buf[1] = ((u_char *)&conf.atneta)[1];
X		return_buf[2] = ifab.if_dnode;
X	    	return (u_char *)return_buf;
X	    }
X	case IFOUTQLEN:
X#ifdef notdef
X	    if (interface == 0)
X		long_return = sendq->pq_len;
X	    else
X		long_return = 0;	/* There is no appletalk transmit queue */
X#else
X	    long_return = 0;
X#endif
X	    return (u_char *)&long_return;
X	default:
X	    return (u_char *)(((char *)ifp) + vp->magic);
X    }
X}
X
X/* 
X * from arp.c:
X * There is no arp.h, so this must be recreated here.
X */
X#define	ARPHLNMAX	6	/* largest arp_hln value needed */
X#define	ARPPLN		4	/* length of protocol address (IP) */
Xstruct	arptab {
X	iaddr_t at_iaddr;		/* internet address */
X	u_char	at_haddr[ARPHLNMAX];	/* hardware address */
X	u_char	at_timer;		/* minutes since last reference */
X	u_char	at_flags;		/* flags */
X	struct	pbuf *at_hold;		/* last packet until resolved/timeout */
X};
X/* at_flags field values */
X#define	ATF_INUSE	1		/* entry in use */
X#define ATF_COM		2		/* completed entry (haddr valid) */
X
X#define	ARPTAB_BSIZ	5		/* bucket size */
X#define	ARPTAB_NB	11		/* number of buckets */
X#define	ARPTAB_SIZE	(ARPTAB_BSIZ * ARPTAB_NB)
X
X
Xu_char *
Xvar_atEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;	/* IN - pointer to variable entry that points here */
X    register oid	    *name;	/* IN/OUT - input name requested, output name found */
X    register int	    *length;	/* IN/OUT - length of input and output oid's */
X    int			    exact;	/* IN - TRUE if an exact match was requested. */
X    int			    *var_len;	/* OUT - length of variable or 0 if function returned. */
X    int			    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    /*
X     * object identifier is of form:
X     * 1.3.6.1.2.1.3.1.1.1.interface.1.A.B.C.D,  where A.B.C.D is IP address.
X     * Interface is at offset 10,
X     * IPADDR starts at offset 12.
X     */
X    oid			    lowest[16];
X    oid			    current[16];
X    register struct arptab  *arp;
X    struct arptab	    *lowarp = 0;
X    extern struct arptab    arptab[];
X    register struct ipdad   *ipdp;
X    struct ipdad	    *lowipdp = 0;
X    extern struct ipdad	    ipdad[];
X    long		    ipaddr;
X    int			    addrlen;
X    extern struct conf	    conf;
X    register u_char	    *cp;
X    register oid	    *op;
X    register int	    count;
X
X    /* fill in object part of name for current (less sizeof instance part) */
X    bcopy((char *)vp->name, (char *)current, (int)(vp->namelen - 6) * sizeof(oid));
X    for(arp = arptab; arp < arptab + ARPTAB_SIZE; arp++){
X	if (!(arp->at_flags & ATF_COM))	/* if this entry isn't valid */
X	    continue;
X	/* create new object id */
X	current[10] = 1;	/* ifIndex == 1 (ethernet) */
X	current[11] = 1;
X	cp = (u_char *)&(arp->at_iaddr);
X	op = current + 12;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	if (exact){
X	    if (compare(current, 16, name, *length) == 0){
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowarp = arp;
X		break;	/* no need to search further */
X	    }
X	} else {
X	    if ((compare(current, 16, name, *length) > 0) && (!lowarp || (compare(current, 16, lowest, 16) < 0))){
X		/*
X		 * if new one is greater than input and closer to input than
X		 * previous lowest, save this one as the "next" one.
X		 */
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowarp = arp;
X	    }
X	}
X    }
X    ipaddr = conf.ipaddr + conf.ipstatic + 1;
X    for(ipdp = ipdad; ipdp < ipdad + NIPDAD; ipdp++, ipaddr++){
X	if (ipdp->timer == 0)	/* if this entry is unused, continue */
X	    continue;
X	/* create new object id */
X	current[10] = 2;	/* ifIndex == 2 (appletalk) */
X	current[11] = 1;
X	cp = (u_char *)&ipaddr;
X	op = current + 12;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	if (exact){
X	    if (compare(current, 16, name, *length) == 0){
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowipdp = ipdp;
X		lowarp = 0;
X		break;	/* no need to search further */
X	    }
X	} else {
X	    if ((compare(current, 16, name, *length) > 0) && ((!lowarp && !lowipdp) || (compare(current, 16, lowest, 16) < 0))){
X		/*
X		 * if new one is greater than input and closer to input than
X		 * previous lowest, save this one as the "next" one.
X		 */
X		bcopy((char *)current, (char *)lowest, 16 * sizeof(oid));
X		lowipdp = ipdp;
X		/* ipdad entry is lower, so invalidate arp entry */
X		lowarp = 0;
X	    }
X	}
X    }
X    if (lowarp != 0){	/* arp entry was lowest */
X	addrlen = 6;
X	bcopy((char *)lowarp->at_haddr, (char *)return_buf, 6);
X    } else if (lowipdp != 0) {
X	addrlen = 3;
X	/*
X	 * As far as IP is concerned, the "physical" address includes the Appletalk
X	 * network address as well as node number.
X	 */
X	return_buf[0] = ((u_char *)&lowipdp->net)[0];
X	return_buf[1] = ((u_char *)&lowipdp->net)[1];
X	return_buf[2] = lowipdp->node;
X    } else
X	return NULL;	/* no match */
X    bcopy((char *)lowest, (char *)name, 16 * sizeof(oid));
X    *length = 16;
X    *access_method = 0;
X    switch(vp->magic){
X	case ATIFINDEX:
X	    *var_len = sizeof long_return;
X	    long_return = lowest[10];
X	    return (u_char *)&long_return;
X	case ATPHYSADDRESS:
X	    *var_len = addrlen;
X	    return (u_char *)return_buf;
X	case ATNETADDRESS:
X	    *var_len = sizeof long_return;
X	    cp = (u_char *)&long_return;
X	    op = lowest + 12;
X	    for(count = 4; count > 0; count--)
X		*cp++ = *op++;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X   }
X   return NULL;
X}
X
Xu_char *
Xvar_ip(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X    return ((u_char *)&mib_ip) + vp->magic;
X}
X
Xu_char *
Xvar_ipRouteEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid    	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output strings */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid			    newname[MAX_NAME_LEN];
X    register int	    entry;
X    register struct mib_ipRouteEntry	*routep;
X    int			    result;
X    register int	    count;
X    register u_char	    *cp;
X    register oid	    *op;
X    extern struct conf	    conf;
X
X    /* set up a routing table to search. All other values are set at startup. */
X    routep = mib_ipRouteEntry;
X    routep[ROUTE_DEFAULT].ipRouteDest = 0;
X    routep[ROUTE_DEFAULT].ipRouteNextHop = conf.iproutedef;
X    routep[ROUTE_LOCAL].ipRouteDest = ipnetpart(conf.ipaddr);
X    routep[ROUTE_LOCAL].ipRouteNextHop = conf.ipaddr;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* find "next" route */
X    for(entry = 0; entry < ROUTE_ENTRIES; entry++){
X	cp = (u_char *)&routep->ipRouteDest;
X	op = newname + 10;
X	for(count = 4; count > 0; count--)
X	    *op++ = *cp++;
X	result = compare(name, *length, newname, (int)vp->namelen);
X	if ((exact && (result == 0)) || (!exact && (result < 0)))
X	    break;
X	routep++;
X    }
X    if (entry >= ROUTE_ENTRIES)
X	return NULL;
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    routep = &mib_ipRouteEntry[entry];
X    switch (vp->magic){
X	case IPROUTENEXTHOP:
X	    if (entry == ROUTE_DEFAULT)
X		return (u_char *)&conf.iproutedef;
X	    else
X		return (u_char *)&conf.ipaddr;
X	default:
X	    return (u_char *)(((u_char *)routep) + vp->magic);
X    }
X}
X
Xu_char *
Xvar_ipAddrEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output oid's */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    oid		    newname[14];
X    int		    result;
X    extern struct conf	conf;
X    register int    count;
X    register u_char *cp;
X    register oid    *op;
X
X    bcopy((char *)vp->name, (char *)newname, (int)vp->namelen * sizeof(oid));
X    /* now find "next" ipaddr */
X    /*
X     * foreach ipaddress entry, cobble up newname with its IP address,
X     * by copying the ipaddress into the 10 - 13't subid's
X     * then compare with name.  If greater than name and less than lowest,
X     * save as new lowest.
X     * Having said all that, I'm now going to cheat because I only have one
X     * IP address (on both interfaces).
X     */
X    cp = (u_char *)&conf.ipaddr;
X    op = newname + 10;
X    for(count = sizeof(conf.ipaddr); count > 0; count--)
X	*op++ = *cp++;
X    result = compare(name, *length, newname, (int)vp->namelen);
X    if ((exact && (result != 0)) || (!exact && (result >= 0)))
X	return NULL;	/* no match */
X    bcopy((char *)newname, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X
X    switch (vp->magic){
X    	case IPADADDR:
X	    return (u_char *)&conf.ipaddr;
X        case IPADIFINDEX:
X	    /*
X	     * Always return ethernet interface. SNMP
X	     * has no access method to access instances
X	     * on different interfaces with same IP address.
X	     */
X	    long_return = 1;
X	    return (u_char *)&long_return;
X	case IPADNETMASK:
X	    long_return = (IN_CLASSA(conf.ipaddr) ? IN_CLASSA_NET :
X			(IN_CLASSB(conf.ipaddr) ? IN_CLASSB_NET : IN_CLASSC_NET));
X	    return (u_char *)&long_return;
X	case IPADBCASTADDR:
X	    long_return = conf.ipbroad & 1;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_icmp(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long); /* all following variables are sizeof long */
X    switch (vp->magic){
X	case ICMPINMSGS:
X	    return (u_char *)&mib_icmpInMsgs;
X	case ICMPINERRORS:
X	    return (u_char *)&mib_icmpInErrors;
X	case ICMPINDESTUNREACHS:
X	    return (u_char *)&mib_icmpInCount[3];
X	case ICMPINTIMEEXCDS:
X	    return (u_char *)&mib_icmpInCount[11];
X	case ICMPINPARMPROBS:
X	    return (u_char *)&mib_icmpInCount[12];
X	case ICMPINSRCQUENCHS:
X	    return (u_char *)&mib_icmpInCount[4];
X	case ICMPINREDIRECTS:
X	    return (u_char *)&mib_icmpInCount[5];
X	case ICMPINECHOS:
X	    return (u_char *)&mib_icmpInCount[8];
X	case ICMPINECHOREPS:
X	    return (u_char *)&mib_icmpInCount[0];
X	case ICMPINTIMESTAMPS:
X	    return (u_char *)&mib_icmpInCount[13];
X	case ICMPINTIMESTAMPREPS:
X	    return (u_char *)&mib_icmpInCount[14];
X	case ICMPINADDRMASKS:
X	    return (u_char *)&mib_icmpInCount[17];
X	case ICMPINADDRMASKREPS:
X	    return (u_char *)&mib_icmpInCount[18];
X	case ICMPOUTMSGS:
X	    return (u_char *)&mib_icmpOutMsgs;
X	case ICMPOUTERRORS:
X	    return (u_char *)&mib_icmpOutErrors;
X	case ICMPOUTDESTUNREACHS:
X	    return (u_char *)&mib_icmpOutCount[3];
X	case ICMPOUTTIMEEXCDS:
X	    return (u_char *)&mib_icmpOutCount[11];
X	case ICMPOUTPARMPROBS:
X	    return (u_char *)&mib_icmpOutCount[12];
X	case ICMPOUTSRCQUENCHS:
X	    return (u_char *)&mib_icmpOutCount[4];
X	case ICMPOUTREDIRECTS:
X	    return (u_char *)&mib_icmpOutCount[5];
X	case ICMPOUTECHOS:
X	    return (u_char *)&mib_icmpOutCount[8];
X	case ICMPOUTECHOREPS:
X	    return (u_char *)&mib_icmpOutCount[0];
X	case ICMPOUTTIMESTAMPS:
X	    return (u_char *)&mib_icmpOutCount[13];
X	case ICMPOUTTIMESTAMPREPS:
X	    return (u_char *)&mib_icmpOutCount[14];
X	case ICMPOUTADDRMASKS:
X	    return (u_char *)&mib_icmpOutCount[17];
X	case ICMPOUTADDRMASKREPS:
X	    return (u_char *)&mib_icmpOutCount[18];
X	default:
X	    ERROR("");
X    }
X    return NULL;
X}
X
X
Xu_char *
Xvar_udp(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;    /* IN - pointer to variable entry that points here */
X    oid	    *name;	    /* IN/OUT - input name requested, output name found */
X    int	    *length;	    /* IN/OUT - length of input and output oid's */
X    int	    exact;	    /* IN - TRUE if an exact match was requested. */
X    int	    *var_len;	    /* OUT - length of variable or 0 if function returned. */
X    int	    *access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    if (exact && (compare(name, *length, vp->name, (int)vp->namelen) != 0))
X	return NULL;
X    bcopy((char *)vp->name, (char *)name, (int)vp->namelen * sizeof(oid));
X    *length = vp->namelen;
X    *access_method = 0;
X    *var_len = sizeof(long);
X    return ((u_char *)&mib_udp) + vp->magic;
X}
END_OF_FILE
  if test 33903 -ne `wc -c <'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/snmplib/snmp_vars.c.kip'
fi
if test -f 'nocol-3.0/src/include/noclogd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/include/noclogd.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/include/noclogd.h'\" \(1332 characters\)
  sed "s/^X//" >'nocol-3.0/src/include/noclogd.h' <<'END_OF_FILE'
X/* $Header: /home/aggarwal/lsrc/nocol/src/include/RCS/noclogd.h,v 2.1 1993/10/30 03:01:43 aggarwal Exp $ */
X
X
X#ifndef __noclogd_h
X# define __noclogd_h
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/un.h>
X#include <sys/wait.h>
X#include <sys/time.h>
X#include <signal.h>
X#include <errno.h>
X#include <netdb.h>
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X
X#include "nocol.h"
X
X/* For config file, Unix socket, pidfile, etc. */
X#ifndef ETCDIR
X# define ETCDIR  "/nocol/etc"
X#endif
X
X#define NLOG_CONFIGFILE(s) *s= '\0'; strcat(strcat(s, ETCDIR),"/noclogd-confg")
X#define NLOG_PIDFILE(s)	   *s= '\0'; strcat(strcat(s, ETCDIR),"/noclogd.pid")
X
X/* File for daemon error messages  */
X#define NLOG_ERRORFILE(s)  *s= '\0'; strcat(strcat(s, ETCDIR),"/noclogd.error")
X
X/*
X * Host where the NOCOL logging daemon runs. Needed by clients.
X * Can give an IP address instead of a name
X */
X#ifndef NLOG_HOST
X# define NLOG_HOST		"noclog.jvnc.net"	/* as a hostname */
X/*  # define NLOG_HOST		"128.121.50.2" 		/* as IP addr */
X#endif
X
X/* For extracting the port from /etc/services */
X#ifndef NLOG_SERVICE
X# define NLOG_SERVICE		"noclog"
X#endif
X
X/* Port in case not available from /etc/services */
X#ifndef NLOG_PORT
X# define NLOG_PORT		5354
X#endif
X
X#ifndef NLOG_UMASK
X# define NLOG_UMASK		022
X#endif
X
X
X#endif  /* !__noclogd_h  */
END_OF_FILE
  if test 1332 -ne `wc -c <'nocol-3.0/src/include/noclogd.h'`; then
    echo shar: \"'nocol-3.0/src/include/noclogd.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/include/noclogd.h'
fi
echo shar: End of archive 11 \(of 26\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
