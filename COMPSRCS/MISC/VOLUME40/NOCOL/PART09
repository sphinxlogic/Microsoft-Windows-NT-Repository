Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i139:  nocol - Network Monitoring System, Part09/26
Message-ID: <1993Nov23.034843.5860@sparky.sterling.com>
X-Md4-Signature: 9d03326afe4196f3345bd47886dd550c
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 23 Nov 1993 03:48:43 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 139
Archive-name: nocol/part09
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/cmu-snmp/mib.txt.C
#   nocol-3.0/src/cmu-snmp/snmplib/parse.c
#   nocol-3.0/src/support/multiping/multiping.h
# Wrapped by kent@sparky on Tue Nov  9 22:22:16 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 26)."'
if test -f 'nocol-3.0/src/cmu-snmp/mib.txt.C' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/mib.txt.C'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/mib.txt.C'\" \(46940 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/mib.txt.C' <<'END_OF_FILE'
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               tsLineAutobaud OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 3 }
X
X               tsLineSpeedin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 4 }
X
X               tsLineSpeedout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 5 }
X
X               tsLineFlow OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        unknown(1),
X                        none(2),
X                        software-input(3),
X                        software-output(4),
X                        software-both(5),
X                        hardware-input(6),
X                        hardware-output(7),
X                        hardware-both(8)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 6 }
X
X               tsLineModem OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        unknown(1),
X
X
X
X
X
X          -- cisco MIB                                         [Page 65]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                        none(2),
X                        call-in(3),
X                        call-out(4),
X                        cts-required(5),
X                        rs-is-cd(6)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 7 }
X
X               tsLineLoc OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 8 }
X
X               tsLineTerm OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 9 }
X
X               tsLineScrlen OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 10 }
X
X               tsLineScrwid OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 11 }
X
X               tsLineEsc OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 12 }
X
X               tsLineTmo OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 13 }
X
X               tsLineSestmo OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 14 }
X
X               tsLineRotary OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 15 }
X
X               tsLineUses OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 16 }
X
X               tsLineNses OBJECT-TYPE
X
X
X
X
X
X          -- cisco MIB                                         [Page 67]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 17 }
X
X               tsLineUser OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 18 }
X
X               tsLineNoise OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineEntry 19 }
X
X               -- End of table
X
X
X
X               -- Local Terminal Server Line Session Table
X
X          -- This group contains terminal server specific
X          -- information on a per line and per session basis.
X
X               ltsLineSessionTable OBJECT-TYPE
X                   SYNTAX  SEQUENCE OF LTsLineSessionEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X                   ::= { lts 3 }
X
X               ltsLineSessionEntry OBJECT-TYPE
X
X
X
X
X
X          -- cisco MIB                                         [Page 68]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   SYNTAX LTsLineSessionEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X               ::= { ltsLineSessionTable 1 }
X
X               LTsLineSessionEntry ::=
X                   SEQUENCE {
X                       tslineSesType
X                           INTEGER,
X                       tslineSesDir
X                           INTEGER,
X                       tslineSesAddr
X                           IpAddress,
X                       tslineSesName
X                           DisplayString,
X                       tslineSesCur
X                           INTEGER,
X                       tslineSesIdle
X                           INTEGER
X                   }
X
X
X          -- The following section describes the components of the
X          -- table.
X
X               tslineSesType OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        unknown(1),
X                        pad(2),
X                        stream(3),
X                        rlogin(4),
X                        telnet(5),
X                        tcp(6),
X                        lat(7),
X                        mop(8),
X                        slip(9),
X                        xremote(10)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 69]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { ltsLineSessionEntry 1 }
X
X               tslineSesDir OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        unknown(1),
X                        incoming(2),
X                        outgoing(3)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineSessionEntry 2 }
X
X               tslineSesAddr OBJECT-TYPE
X                   SYNTAX  IpAddress
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineSessionEntry 3 }
X
X               tslineSesName OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineSessionEntry 4 }
X
X               tslineSesCur OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { ltsLineSessionEntry 5 }
X
X               tslineSesIdle OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X
X
X
X
X
X          -- cisco MIB                                         [Page 70]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   STATUS  mandatory
X                   ::= { ltsLineSessionEntry 6 }
X
X               -- End of table
X
X
X               tsMsgTtyLine OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-write
X                   STATUS  mandatory
X                   ::= { lts 4 }
X
X               tsMsgIntervaltim OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-write
X                   STATUS  mandatory
X                   ::= { lts 5 }
X
X               tsMsgDuration OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-write
X                   STATUS  mandatory
X                   ::= { lts 6 }
X
X               tsMsgText OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-write
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 71]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { lts 7 }
X
X               tsMsgTmpBanner OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        no(1),
X                        additive(2)
X                   }
X                   ACCESS  read-write
X                   STATUS  mandatory
X                   ::= { lts 8 }
X
X               tsMsgSend OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        nothing(1),
X                        reload(2),
X                        messagedone(3),
X                        abort(4)
X                   }
X                   ACCESS  read-write
X                   STATUS  mandatory
X                   ::= { lts 9 }
X
X
X               -- Local cisco Flash Group
X
X          -- This group is present in all products which contain flash"
X
X               flashSize OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 1 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 72]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               flashFree OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 2 }
X
X               flashcontoller OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  write-only
X                   STATUS  mandatory
X                   ::= { lflash 3 }
X
X               flashcard OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  write-only
X                   STATUS  mandatory
X                   ::= { lflash 4 }
X
X               flashVPP OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        installed(1),
X                        missing(2)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 5 }
X
X               flashErase OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  write-only
X                   STATUS  mandatory
X                   ::= { lflash 6 }
X
X               flashEraseTime OBJECT-TYPE
X                   SYNTAX  TimeTicks
X
X
X
X
X
X          -- cisco MIB                                         [Page 73]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 7 }
X
X               flashEraseStatus OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 8 }
X
X               flashToNet OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  write-only
X                   STATUS  mandatory
X                   ::= { lflash 9 }
X
X               flashToNetTime OBJECT-TYPE
X                   SYNTAX  TimeTicks
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 10 }
X
X               flashToNetStatus OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 11 }
X
X               netToFlash OBJECT-TYPE
X                   SYNTAX  DisplayString
X
X
X
X
X
X          -- cisco MIB                                         [Page 74]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ACCESS  write-only
X                   STATUS  mandatory
X                   ::= { lflash 12 }
X
X               netToFlashTime OBJECT-TYPE
X                   SYNTAX  TimeTicks
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 13 }
X
X               netToFlashStatus OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 14 }
X
X               flashStatus OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 15 }
X
X               flashEntries OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflash 16 }
X
X
X               -- Local Flash file Table
X
X
X
X
X
X          -- cisco MIB                                         [Page 75]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X          -- This group contains information on a per file basis
X
X               lflashFileDirTable OBJECT-TYPE
X                   SYNTAX  SEQUENCE OF LFlashFileDirEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X                   ::= { lflash 17 }
X
X               lflashFileDirEntry OBJECT-TYPE
X                   SYNTAX LFlashFileDirEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X               ::= { lflashFileDirTable 1 }
X
X               LFlashFileDirEntry ::=
X                   SEQUENCE {
X                       flashDirName
X                           DisplayString,
X                       flashDirSize
X                           INTEGER,
X                       flashDirStatus
X                           INTEGER
X                   }
X
X
X          -- The following section describes the components of the
X          -- table.
X
X               flashDirName OBJECT-TYPE
X                   SYNTAX  DisplayString
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflashFileDirEntry 1 }
X
X               flashDirSize OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 76]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { lflashFileDirEntry 2 }
X
X               flashDirStatus OBJECT-TYPE
X                   SYNTAX  INTEGER {
X                        valid(1),
X                        deleted(2)
X                   }
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { lflashFileDirEntry 3 }
X
X               -- End of table
X
X
X
X               -- Temporary Variable Section
X
X          -- This section is equivalent to the experimental
X          -- space defined by the SMI. It contains variables
X          -- that are useful to have but are beyond cisco's
X          -- ability to control and maintain. This section can
X          -- change from release to release without warning.
X          -- This document controls what is contained here for
X          -- this version.
X
X
X          -- Temporary DECNET Section
X
X          -- This group is present in all router based products.
X
X               dnForward OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 1 }
X
X               dnReceived OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X
X
X
X
X
X          -- cisco MIB                                         [Page 77]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   STATUS  mandatory
X                   ::= { decnet 2 }
X
X               dnFormaterr OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 3 }
X
X               dnNotgateway OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 4 }
X
X               dnNotimp OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 5 }
X
X               dnHellos OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 6 }
X
X               dnBadhello OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 7 }
X
X               dnNotlong OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 8 }
X
X               dnDatas OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 9 }
X
X               dnBigaddr OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 10 }
X
X               dnNoroute OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 11 }
X
X               dnNoencap OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 12 }
X
X
X
X
X
X          -- cisco MIB                                         [Page 79]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               dnLevel1s OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 13 }
X
X               dnBadlevel1 OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 14 }
X
X               dnToomanyhops OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 15 }
X
X               dnHellosent OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 16 }
X
X               dnLevel1sent OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 17 }
X
X               dnNomemory OBJECT-TYPE
X
X
X
X
X
X          -- cisco MIB                                         [Page 80]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 18 }
X
X               dnOtherhello OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 19 }
X
X               dnOtherlevel1 OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 20 }
X
X               dnLevel2s OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 21 }
X
X               dnLevel2sent OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 22 }
X
X               dnNovector OBJECT-TYPE
X                   SYNTAX  INTEGER
X
X
X
X
X
X          -- cisco MIB                                         [Page 81]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 23 }
X
X               dnOtherlevel2 OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 24 }
X
X               dnNoaccess OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { decnet 25 }
X
X               dnAreaTable OBJECT-TYPE
X                   SYNTAX  SEQUENCE OF DnAreaTableEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X                   ::= { decnet 26 }
X
X               dnAreaTableEntry OBJECT-TYPE
X                   SYNTAX DnAreaTableEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X               ::= { dnAreaTable 1 }
X
X               DnAreaTableEntry ::=
X                   SEQUENCE {
X                       dnArea
X                           INTEGER,
X
X
X
X
X
X          -- cisco MIB                                         [Page 82]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                       dnACost
X                           INTEGER,
X                       dnAHop
X                           INTEGER,
X                       dnAIfIndex
X                           INTEGER,
X                       dnANextHop
X                           OCTET STRING,
X                       dnAAge
X                           INTEGER,
X                       dnAPrio
X                           INTEGER
X                   }
X
X
X          -- The following section describes the components of the
X          -- table.
X
X               dnArea OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 1 }
X
X               dnACost OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 2 }
X
X               dnAHop OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 3 }
X
X               dnAIfIndex OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X
X
X
X
X
X          -- cisco MIB                                         [Page 83]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 4 }
X
X               dnANextHop OBJECT-TYPE
X                   SYNTAX  OCTET STRING
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 5 }
X
X               dnAAge OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 6 }
X
X               dnAPrio OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnAreaTableEntry 7 }
X
X               -- End of table
X
X
X               dnHostTable OBJECT-TYPE
X                   SYNTAX  SEQUENCE OF DnHostTableEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X                   ::= { decnet 27 }
X
X               dnHostTableEntry OBJECT-TYPE
X                   SYNTAX DnHostTableEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 84]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               ::= { dnHostTable 1 }
X
X               DnHostTableEntry ::=
X                   SEQUENCE {
X                       dnHost
X                           INTEGER,
X                       dnHCost
X                           INTEGER,
X                       dnHHop
X                           INTEGER,
X                       dnHIfIndex
X                           INTEGER,
X                       dnHNextHop
X                           OCTET STRING,
X                       dnHAge
X                           INTEGER,
X                       dnHPrio
X                           INTEGER
X                   }
X
X
X          -- The following section describes the components of the
X          -- table.
X
X               dnHost OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 1 }
X
X               dnHCost OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 2 }
X
X               dnHHop OBJECT-TYPE
X                   SYNTAX  INTEGER
X
X
X
X
X
X          -- cisco MIB                                         [Page 85]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 3 }
X
X               dnHIfIndex OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 4 }
X
X               dnHNextHop OBJECT-TYPE
X                   SYNTAX  OCTET STRING
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 5 }
X
X               dnHAge OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 6 }
X
X               dnHPrio OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnHostTableEntry 7 }
X
X               -- End of table
X
X
X               dnIfTable OBJECT-TYPE
X                   SYNTAX  SEQUENCE OF DnIfTableEntry
X
X
X
X
X
X          -- cisco MIB                                         [Page 86]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X                   ::= { decnet 28 }
X
X               dnIfTableEntry OBJECT-TYPE
X                   SYNTAX DnIfTableEntry
X                   ACCESS  not-accessible
X                   STATUS  mandatory
X               ::= { dnIfTable 1 }
X
X               DnIfTableEntry ::=
X                   SEQUENCE {
X                       dnIfCost
X                           INTEGER
X                   }
X
X
X          -- The following section describes the components of the
X          -- table.
X
X               dnIfCost OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { dnIfTableEntry 1 }
X
X               -- End of table
X
X
X
X               -- Temporary XNS Section
X
X          -- This group is present in all router based products.
X
X               xnsInput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 87]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { xns 1 }
X
X               xnsLocal OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 2 }
X
X               xnsBcastin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 3 }
X
X               xnsForward OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 4 }
X
X               xnsBcastout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 5 }
X
X               xnsErrin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 6 }
X
X               xnsErrout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 7 }
X
X               xnsFormerr OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 8 }
X
X               xnsChksum OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 9 }
X
X               xnsNotgate OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 10 }
X
X               xnsHopcnt OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 11 }
X
X               xnsNoroute OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 12 }
X
X               xnsNoencap OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 13 }
X
X               xnsOutput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 14 }
X
X               xnsInmult OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 15 }
X
X               xnsUnknown OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 16 }
X
X               xnsFwdbrd OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 17 }
X
X               xnsEchoreqin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 18 }
X
X               xnsEchoreqout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 19 }
X
X               xnsEchorepin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 20 }
X
X               xnsEchorepout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { xns 21 }
X
X
X               -- Temporary AppleTalk Section
X
X          -- This group is present in all router based products.
X
X               atInput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 1 }
X
X               atLocal OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 2 }
X
X               atBcastin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 3 }
X
X               atForward OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 4 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 92]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atBcastout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 5 }
X
X               atChksum OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 7 }
X
X               atNotgate OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 8 }
X
X               atHopcnt OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 9 }
X
X               atNoaccess OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 10 }
X
X
X
X
X
X          -- cisco MIB                                         [Page 93]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atNoroute OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 11 }
X
X               atNoencap OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 12 }
X
X               atOutput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 13 }
X
X               atInmult OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 14 }
X
X               atRtmpin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 15 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 94]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atRtmpout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 16 }
X
X               atNbpin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 17 }
X
X               atNbpout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 18 }
X
X               atAtp OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 19 }
X
X               atZipin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 20 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 95]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atZipout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 21 }
X
X               atEcho OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 22 }
X
X               atEchoill OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 23 }
X
X               atDdpshort OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 24 }
X
X               atDdplong OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 25 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 96]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atDdpbad OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 26 }
X
X               atNobuffer OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 27 }
X
X               atArpreq OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 28 }
X
X               atArpreply OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 29 }
X
X               atArpprobe OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 30 }
X
X
X
X
X
X
X          -- cisco MIB                                         [Page 97]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X               atUnknown OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { appletalk 31 }
X
X
X               -- Temporary Novell Section
X
X          -- This group is present in all router based products.
X
X               novellInput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 1 }
X
X               novellBcastin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 2 }
X
X               novellForward OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 3 }
X
X               novellBcastout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                         [Page 98]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { novell 4 }
X
X               novellFormerr OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 5 }
X
X               novellChksum OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 6 }
X
X               novellHopcnt OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 7 }
X
X               novellNoroute OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 8 }
X
X               novellNoencap OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X
X
X
X
X
X          -- cisco MIB                                         [Page 99]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   STATUS  mandatory
X                   ::= { novell 9 }
X
X               novellOutput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 10 }
X
X               novellInmult OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 11 }
X
X               novellLocal OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 12 }
X
X               novellUnknown OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 13 }
X
X               novellSapreqin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X
X
X
X
X
X          -- cisco MIB                                        [Page 100]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   STATUS  mandatory
X                   ::= { novell 14 }
X
X               novellSapresin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 15 }
X
X               novellSapout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 16 }
X
X               novellSapreply OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { novell 17 }
X
X
X               -- Temporary Vines Section
X
X          -- This group is present in all router based products.
X
X               vinesInput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 1 }
X
X               vinesOutput OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 2 }
X
X               vinesLocaldest OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 3 }
X
X               vinesForwarded OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 4 }
X
X               vinesBcastin OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 5 }
X
X               vinesBcastout OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 6 }
X
X               vinesBcastfwd OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 7 }
X
X               vinesNotlan OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 8 }
X
X               vinesNotgt4800 OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 9 }
X
X               vinesNocharges OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 10 }
X
X               vinesFormaterror OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                        [Page 103]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { vines 11 }
X
X               vinesCksumerr OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 12 }
X
X               vinesHopcount OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 13 }
X
X               vinesNoroute OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 14 }
X
X               vinesEncapsfailed OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 15 }
X
X               vinesUnknown OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                        [Page 104]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { vines 16 }
X
X               vinesIcpIn OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 17 }
X
X               vinesIcpOut OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 18 }
X
X               vinesMetricOut OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 19 }
X
X               vinesMacEchoIn OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 20 }
X
X               vinesMacEchoOut OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X
X
X
X
X
X          -- cisco MIB                                        [Page 105]
X--
X
X
X
X
X
X          -- Request for Comments: Draft             cisco Systems, Inc.
X
X
X                   ::= { vines 21 }
X
X               vinesEchoIn OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 22 }
X
X               vinesEchoOut OBJECT-TYPE
X                   SYNTAX  INTEGER
X                   ACCESS  read-only
X                   STATUS  mandatory
X                   ::= { vines 23 }
X               END
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X          -- cisco MIB                                        [Page 106]
X--
X
END_OF_FILE
  if test 46940 -ne `wc -c <'nocol-3.0/src/cmu-snmp/mib.txt.C'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/mib.txt.C'\" unpacked with wrong size!
  elif test -f 'nocol-3.0/src/cmu-snmp/mib.txt.A' && test -f 'nocol-3.0/src/cmu-snmp/mib.txt.B'; then
    echo shar: Combining  \"'nocol-3.0/src/cmu-snmp/mib.txt'\" \(164470 characters\)
    cat 'nocol-3.0/src/cmu-snmp/mib.txt.A' 'nocol-3.0/src/cmu-snmp/mib.txt.B' 'nocol-3.0/src/cmu-snmp/mib.txt.C' > 'nocol-3.0/src/cmu-snmp/mib.txt'
    if test 164470 -ne `wc -c <'nocol-3.0/src/cmu-snmp/mib.txt'`; then
      echo shar: \"'nocol-3.0/src/cmu-snmp/mib.txt'\" combined with wrong size!
    else
      rm nocol-3.0/src/cmu-snmp/mib.txt.A nocol-3.0/src/cmu-snmp/mib.txt.B nocol-3.0/src/cmu-snmp/mib.txt.C
    fi
  fi
  # end of 'nocol-3.0/src/cmu-snmp/mib.txt.C'
fi
if test -f 'nocol-3.0/src/cmu-snmp/snmplib/parse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/snmplib/parse.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/snmplib/parse.c'\" \(22322 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/snmplib/parse.c' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X/*
X * parse.c
X */
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include "parse.h"
X
X/*
X * This is one element of an object identifier with either an integer subidentifier,
X * or a textual string label, or both.
X * The subid is -1 if not present, and label is NULL if not present.
X */
Xstruct subid {
X    int subid;
X    char *label;
X};
X
Xint Line = 1;
X
X/* types of tokens */
X#define	CONTINUE    -1
X#define LABEL	    1
X#define SUBTREE	    2
X#define SYNTAX	    3
X#define OBJID	    4
X#define OCTETSTR    5
X#define INTEGER	    6
X#define NETADDR	    7
X#define	IPADDR	    8
X#define COUNTER	    9
X#define GAUGE	    10
X#define TIMETICKS   11
X#define OPAQUE	    12
X#define NUL	    13
X#define SEQUENCE    14
X#define OF	    15	/* SEQUENCE OF */
X#define OBJTYPE	    16
X#define ACCESS	    17
X#define READONLY    18
X#define READWRITE   19
X#define	WRITEONLY   20
X#define NOACCESS    21
X#define STATUS	    22
X#define MANDATORY   23
X#define OPTIONAL    24
X#define OBSOLETE    25
X#define RECOMMENDED 26
X#define PUNCT	    27
X#define EQUALS	    28
X
Xstruct tok {
X	char *name;			/* token name */
X	int len;			/* length not counting nul */
X	int token;			/* value */
X	int hash;			/* hash of name */
X	struct tok *next;		/* pointer to next in hash table */
X};
X
X
Xstruct tok tokens[] = {
X	{ "obsolete", sizeof ("obsolete")-1, OBSOLETE },
X	{ "Opaque", sizeof ("Opaque")-1, OPAQUE },
X	{ "recommended", sizeof("recommended")-1, RECOMMENDED }, 
X	{ "optional", sizeof ("optional")-1, OPTIONAL },
X	{ "mandatory", sizeof ("mandatory")-1, MANDATORY },
X	{ "not-accessible", sizeof ("not-accessible")-1, NOACCESS },
X	{ "write-only", sizeof ("write-only")-1, WRITEONLY },
X	{ "read-write", sizeof ("read-write")-1, READWRITE },
X	{ "TimeTicks", sizeof ("TimeTicks")-1, TIMETICKS },
X	{ "OBJECTIDENTIFIER", sizeof ("OBJECTIDENTIFIER")-1, OBJID },
X	/*
X	 * This CONTINUE appends the next word onto OBJECT,
X	 * hopefully matching OBJECTIDENTIFIER above.
X	 */
X	{ "OBJECT", sizeof ("OBJECT")-1, CONTINUE },
X	{ "NetworkAddress", sizeof ("NetworkAddress")-1, NETADDR },
X	{ "Gauge", sizeof ("Gauge")-1, GAUGE },
X	{ "OCTETSTRING", sizeof ("OCTETSTRING")-1, OCTETSTR },
X	{ "OCTET", sizeof ("OCTET")-1, -1 },
X	{ "OF", sizeof ("OF")-1, OF },
X	{ "SEQUENCE", sizeof ("SEQUENCE")-1, SEQUENCE },
X	{ "NULL", sizeof ("NULL")-1, NUL },
X	{ "IpAddress", sizeof ("IpAddress")-1, IPADDR },
X	{ "INTEGER", sizeof ("INTEGER")-1, INTEGER },
X	{ "Counter", sizeof ("Counter")-1, COUNTER },
X	{ "read-only", sizeof ("read-only")-1, READONLY },
X	{ "ACCESS", sizeof ("ACCESS")-1, ACCESS },
X	{ "STATUS", sizeof ("STATUS")-1, STATUS },
X	{ "SYNTAX", sizeof ("SYNTAX")-1, SYNTAX },
X	{ "OBJECT-TYPE", sizeof ("OBJECT-TYPE")-1, OBJTYPE },
X	{ "{", sizeof ("{")-1, PUNCT },
X	{ "}", sizeof ("}")-1, PUNCT },
X	{ "::=", sizeof ("::=")-1, EQUALS },
X	{ NULL }
X};
X
X#define	HASHSIZE	32
X#define	BUCKET(x)	(x & 0x01F)
X
Xstruct tok	*buckets[HASHSIZE];
X
Xstatic
Xhash_init()
X{
X	register struct tok	*tp;
X	register char	*cp;
X	register int	h;
X	register int	b;
X
X	for (tp = tokens; tp->name; tp++) {
X		for (h = 0, cp = tp->name; *cp; cp++)
X			h += *cp;
X		tp->hash = h;
X		b = BUCKET(h);
X		if (buckets[b])
X			tp->next = buckets[b];
X		buckets[b] = tp;
X	}
X}
X
X
Xstatic char *
XMalloc(num)
X    unsigned num;
X{
X    char *cp;
X    char *malloc();
X    
X    /* this is to fix (what seems to be) a problem with the IBM RT C library malloc */
X    if (num < 16)
X	num = 16;
X    cp = malloc(num);
X    return cp;
X}
X
Xstatic
Xprint_error(string, token)
X    char *string;
X    char *token;
X{
X    if (token)
X	fprintf(stderr, "%s(%s): On or around line %d\n", string, token, Line);
X    else
X	fprintf(stderr, "%s: On or around line %d\n", string, Line);
X}
X
X#ifdef TEST
Xprint_subtree(tree, count)
X    struct tree *tree;
X    int count;
X{
X    struct tree *tp;
X    int i;
X
X    for(i = 0; i < count; i++)
X	printf("  ");
X    printf("Children of %s:\n", tree->label);
X    count++;
X    for(tp = tree->child_list; tp; tp = tp->next_peer){
X	for(i = 0; i < count; i++)
X	    printf("  ");
X	printf("%s\n", tp->label);
X    }
X    for(tp = tree->child_list; tp; tp = tp->next_peer){
X	print_subtree(tp, count);
X    }
X}
X#endif /* TEST */
X
X
Xstatic struct tree *
Xbuild_tree(nodes)
X    struct node *nodes;
X{
X    struct node *np;
X    struct tree *tp;
X    
X    /* build root node */
X    tp = (struct tree *)Malloc(sizeof(struct tree));
X    tp->parent = NULL;
X    tp->next_peer = NULL;
X    tp->child_list = NULL;
X    tp->enums = NULL;
X    strcpy(tp->label, "iso");
X    tp->subid = 1;
X    tp->type = 0;
X    /* grow tree from this root node */
X    do_subtree(tp, &nodes);
X#ifdef TEST
X    print_subtree(tp, 0);
X#endif /* TEST */
X    /* If any nodes are left, the tree is probably inconsistent */
X    if (nodes){
X	fprintf(stderr, "The mib description doesn't seem to be consistent.\n");
X	fprintf(stderr, "Some nodes couldn't be linked under the \"iso\" tree.\n");
X	fprintf(stderr, "these nodes are left:\n");
X	for(np = nodes; np; np = np->next)
X	    fprintf(stderr, "%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
X		    np->type);
X    }
X    return tp;
X}
X
X
X/*
X * Find all the children of root in the list of nodes.  Link them into the
X * tree and out of the nodes list.
X */
Xstatic
Xdo_subtree(root, nodes)
X    struct tree *root;
X    struct node **nodes;
X{
X    register struct tree *tp;
X    struct tree *peer = NULL;
X    register struct node *np;
X    struct node *oldnp = NULL, *child_list = NULL, *childp = NULL;
X    
X    tp = root;
X    /*
X     * Search each of the nodes for one whose parent is root, and
X     * move each into a separate list.
X     */
X    for(np = *nodes; np; np = np->next){
X	if ((tp->label[0] == np->parent[0]) && !strcmp(tp->label, np->parent)){
X	    if (child_list == NULL){
X		child_list = childp = np;   /* first entry in child list */
X	    } else {
X		childp->next = np;
X		childp = np;
X	    }
X	    /* take this node out of the node list */
X	    if (oldnp == NULL){
X		*nodes = np->next;  /* fix root of node list */
X	    } else {
X		oldnp->next = np->next;	/* link around this node */
X	    }
X	} else {
X	    oldnp = np;
X	}
X    }
X    if (childp)
X	childp->next = 0;	/* re-terminate list */
X    /*
X     * Take each element in the child list and place it into the tree.
X     */
X    for(np = child_list; np; np = np->next){
X	tp = (struct tree *)Malloc(sizeof(struct tree));
X	tp->parent = root;
X	tp->next_peer = NULL;
X	tp->child_list = NULL;
X	strcpy(tp->label, np->label);
X	tp->subid = np->subid;
X	switch(np->type){
X	    case OBJID:
X		tp->type = TYPE_OBJID;
X		break;
X	    case OCTETSTR:
X		tp->type = TYPE_OCTETSTR;
X		break;
X	    case INTEGER:
X		tp->type = TYPE_INTEGER;
X		break;
X	    case NETADDR:
X		tp->type = TYPE_IPADDR;
X		break;
X	    case IPADDR:
X		tp->type = TYPE_IPADDR;
X		break;
X	    case COUNTER:
X		tp->type = TYPE_COUNTER;
X		break;
X	    case GAUGE:
X		tp->type = TYPE_GAUGE;
X		break;
X	    case TIMETICKS:
X		tp->type = TYPE_TIMETICKS;
X		break;
X	    case OPAQUE:
X		tp->type = TYPE_OPAQUE;
X		break;
X	    case NUL:
X		tp->type = TYPE_NULL;
X		break;
X	    default:
X		tp->type = TYPE_OTHER;
X		break;
X	}
X	tp->enums = np->enums;
X	np->enums = NULL;	/* so we don't free them later */
X	if (root->child_list == NULL){
X	    root->child_list = tp;
X	} else {
X	    peer->next_peer = tp;
X	}
X	peer = tp;
X	do_subtree(tp, nodes);	/* recurse on this child */
X    }
X    /* free all nodes that were copied into tree */
X    for(np = child_list; np;){
X	oldnp = np;
X	np = np->next;
X	free_node(oldnp);
X    }
X}
X
X
X/*
X * Takes a list of the form:
X * { iso org(3) dod(6) 1 }
X * and creates several nodes, one for each parent-child pair.
X * Returns NULL on error.
X */
Xstatic int
Xgetoid(fp, oid,  length)
X    register FILE *fp;
X    register struct subid *oid;	/* an array of subids */
X    int length;	    /* the length of the array */
X{
X    register int count;
X    int type;
X    char token[64], label[32];
X    register char *cp, *tp;
X
X    if ((type = get_token(fp, token)) != PUNCT){
X	if (type == -1)
X	    print_error("Unexpected EOF", (char *)NULL);
X	else
X	    print_error("Unexpected", token);
X	return NULL;
X    }
X    if (*token != '{'){
X	print_error("Unexpected", token);
X	return NULL;
X    }
X    for(count = 0; count < length; count++, oid++){
X	oid->label = 0;
X	oid->subid = -1;
X	if ((type = get_token(fp, token)) != LABEL){
X	    if (type == -1){
X		print_error("Unexpected EOF", (char *)NULL);
X		return NULL;
X	    }
X	    else if (type == PUNCT && *token == '}'){
X		return count;
X	    } else {
X		print_error("Unexpected", token);
X		return NULL;
X	    }
X	}
X	tp = token;
X	if (!isdigit(*tp)){
X	    /* this entry has a label */
X	    cp = label;
X	    while(*tp && *tp != '(')
X		*cp++ = *tp++;
X	    *cp = 0;
X	    cp = (char *)Malloc((unsigned)strlen(label));
X	    strcpy(cp, label);
X	    oid->label = cp;
X	    if (*tp == '('){
X		/* this entry has a label-integer pair in the form label(integer). */
X		cp = ++tp;
X		while(*cp && *cp != ')')
X		    cp++;
X		if (*cp == ')')
X		    *cp = 0;
X		else {
X		    print_error("No terminating parenthesis", (char *)NULL);
X		    return NULL;
X		}
X		oid->subid = atoi(tp);
X	    }
X	} else {
X	    /* this entry  has just an integer sub-identifier */
X	    oid->subid = atoi(tp);
X	}
X    }
X    return count;
X
X
X}
X
Xstatic
Xfree_node(np)
X    struct node *np;
X{
X    struct enum_list *ep, *tep;
X
X    ep = np->enums;
X    while(ep){
X	tep = ep;
X	ep = ep->next;
X	free((char *)tep);
X    }
X    free((char *)np);
X}
X
X/*
X * Parse an entry of the form:
X * label OBJECT IDENTIFIER ::= { parent 2 }
X * The "label OBJECT IDENTIFIER" portion has already been parsed.
X * Returns 0 on error.
X */
Xstatic struct node *
Xparse_objectid(fp, name)
X    FILE *fp;
X    char *name;
X{
X    int type;
X    char token[64];
X    register int count;
X    register struct subid *op, *nop;
X    int length;
X    struct subid oid[16];
X    struct node *np, *root, *oldnp = NULL;
X
X    type = get_token(fp, token);
X    if (type != EQUALS){
X	print_error("Bad format", token);
X	return 0;
X    }
X    if (length = getoid(fp, oid, 16)){
X	np = root = (struct node *)Malloc(sizeof(struct node));
X	/*
X	 * For each parent-child subid pair in the subid array,
X	 * create a node and link it into the node list.
X	 */
X	for(count = 0, op = oid, nop=oid+1; count < (length - 2); count++,
X	    op++, nop++){
X	    /* every node must have parent's name and child's name or number */
X	    if (op->label && (nop->label || (nop->subid != -1))){
X		strcpy(np->parent, op->label);
X		if (nop->label)
X		    strcpy(np->label, nop->label);
X		if (nop->subid != -1)
X		    np->subid = nop->subid;
X		np ->type = 0;
X		np->enums = 0;
X		/* set up next entry */
X		np->next = (struct node *)Malloc(sizeof(*np->next));
X		oldnp = np;
X		np = np->next;
X	    }
X	}
X	np->next = (struct node *)NULL;
X	/*
X	 * The above loop took care of all but the last pair.  This pair is taken
X	 * care of here.  The name for this node is taken from the label for this
X	 * entry.
X	 * np still points to an unused entry.
X	 */
X	if (count == (length - 2)){
X	    if (op->label){
X		strcpy(np->parent, op->label);
X		strcpy(np->label, name);
X		if (nop->subid != -1)
X		    np->subid = nop->subid;
X		else
X		    print_error("Warning: This entry is pretty silly", token);
X	    } else {
X		free_node(np);
X		if (oldnp)
X		    oldnp->next = NULL;
X		else
X		    return NULL;
X	    }
X	} else {
X	    print_error("Missing end of oid", (char *)NULL);
X	    free_node(np);   /* the last node allocated wasn't used */
X	    if (oldnp)
X		oldnp->next = NULL;
X	    return NULL;
X	}
X	/* free the oid array */
X	for(count = 0, op = oid; count < length; count++, op++){
X	    if (op->label)
X		free(oid->label);
X	    op->label = 0;
X	}
X	return root;
X    } else {
X	print_error("Bad object identifier", (char *)NULL);
X	return 0;
X    }
X}
X
X/*
X * Parses an asn type.  This structure is ignored by this parser.
X * Returns NULL on error.
X */
Xstatic int
Xparse_asntype(fp)
X    FILE *fp;
X{
X    int type;
X    char token[64];
X
X    type = get_token(fp, token);
X    if (type != SEQUENCE){
X	print_error("Not a sequence", (char *)NULL); /* should we handle this */
X	return NULL;
X    }
X    while((type = get_token(fp, token)) != NULL){
X	if (type == -1)
X	    return NULL;
X	if (type == PUNCT && (token[0] == '}' && token[1] == '\0'))
X	    return -1;
X    }
X    print_error("Premature end of file", (char *)NULL);
X    return NULL;
X}
X
X/*
X * Parses an OBJECT TYPE macro.
X * Returns 0 on error.
X */
Xstatic struct node *
Xparse_objecttype(fp, name)
X    register FILE *fp;
X    char *name;
X{
X    register int type;
X    char token[64];
X    int count, length;
X    struct subid oid[16];
X    char syntax[32];
X    int nexttype;
X    char nexttoken[64];
X    register struct node *np;
X    register struct enum_list *ep;
X    register char *cp;
X    register char *tp;
X
X    type = get_token(fp, token);
X    if (type != SYNTAX){
X	print_error("Bad format for OBJECT TYPE", token);
X	return 0;
X    }
X    np = (struct node *)Malloc(sizeof(struct node));
X    np->next = 0;
X    np->enums = 0;
X    type = get_token(fp, token);
X    nexttype = get_token(fp, nexttoken);
X    np->type = type;
X    switch(type){
X	case SEQUENCE:
X	    strcpy(syntax, token);
X	    if (nexttype == OF){
X		strcat(syntax, " ");
X		strcat(syntax, nexttoken);
X		nexttype = get_token(fp, nexttoken);
X		strcat(syntax, " ");
X		strcat(syntax, nexttoken);
X		nexttype = get_token(fp, nexttoken);
X	    }
X	    break;
X	case INTEGER:
X	    strcpy(syntax, token);
X	    if (nexttype == PUNCT &&
X		(nexttoken[0] == '{' && nexttoken[1] == '\0')) {
X		/* if there is an enumeration list, parse it */
X		while((type = get_token(fp, token)) != NULL){
X		    if (type == -1){
X			free_node(np);
X			return 0;
X		    }
X		    if (type == PUNCT &&
X			(token[0] == '}' && token[1] == '\0'))
X			break;
X		    if (type == 1){
X			/* this is an enumerated label */
X			if (np->enums == 0){
X			    ep = np->enums = (struct enum_list *)
X					Malloc(sizeof(struct enum_list));
X			} else {
X			    ep->next = (struct enum_list *)
X					Malloc(sizeof(struct enum_list));
X			    ep = ep->next;
X			}
X			ep->next = 0;
X			/* a reasonable approximation for the length */
X			ep->label = (char *)Malloc((unsigned)strlen(token));
X			cp = ep->label;
X			tp = token;
X			while(*tp != '(' && *tp != 0)
X			    *cp++ = *tp++;
X			*cp = 0;
X			if (*tp == 0){
X			    type = get_token(fp, token);
X			    if (type != LABEL){
X				print_error("Expected \"(\"", (char *)NULL);
X				free_node(np);
X				return 0;
X			    }
X			    tp = token;
X			}
X			if (*tp == '('){
X			    tp++;
X			} else {
X			    print_error("Expected \"(\"", token);
X			    free_node(np);
X			    return 0;
X			}
X			if (*tp == 0){
X			    type = get_token(fp, token);
X			    if (type != LABEL){
X				print_error("Expected integer", token);
X				free_node(np);
X				return 0;
X			    }
X			    tp = token;
X			}
X
X			cp = tp;
X			if (!isdigit(*cp)){
X			    print_error("Expected integer", token);
X			    free_node(np);
X			    return 0;
X			}
X			while(isdigit(*tp) && *tp != 0)
X			    tp++;
X			if (*tp == ')')
X			    *tp = '\0';	/* terminate number */
X			else if (*tp == 0){
X			    type = get_token(fp, token);
X			    if (type != LABEL || *token != ')'){
X				print_error("Expected \")\"", token);
X				free_node(np);
X				return 0;
X			    }
X			} else {
X			    print_error("Expected \")\"", token);
X			    free_node(np);
X			    return 0;
X			}
X			ep->value = atoi(cp);
X		    }
X		}
X		if (type == NULL){
X		    print_error("Premature end of file", (char *)NULL);
X		    free_node(np);
X		    return 0;
X		}
X		nexttype = get_token(fp, nexttoken);
X	    } else if (nexttype == LABEL && *nexttoken == '('){
X		/* ignore the "constrained integer" for now */
X		nexttype = get_token(fp, nexttoken);
X	    }
X	    break;
X	case OBJID:
X	case OCTETSTR:
X	case NETADDR:
X	case IPADDR:
X	case COUNTER:
X	case GAUGE:
X	case TIMETICKS:
X	case OPAQUE:
X	case NUL:
X	case LABEL:
X	    strcpy(syntax, token);
X	    break;
X	default:
X	    print_error("Bad syntax", token);
X	    free_node(np);
X	    return 0;
X    }
X    if (nexttype != ACCESS){
X	print_error("Should be ACCESS", nexttoken);
X	free_node(np);
X	return 0;
X    }
X    type = get_token(fp, token);
X    if (type != READONLY && type != READWRITE && type != WRITEONLY
X	&& type != NOACCESS){
X	print_error("Bad access type", nexttoken);
X	free_node(np);
X	return 0;
X    }
X    type = get_token(fp, token);
X    if (type != STATUS){
X	print_error("Should be STATUS", token);
X	free_node(np);
X	return 0;
X    }
X    type = get_token(fp, token);
X    if (type != MANDATORY && type != OPTIONAL && type != OBSOLETE && type != RECOMMENDED){
X	print_error("Bad status", token);
X	free_node(np);
X	return 0;
X    }
X    type = get_token(fp, token);
X    if (type != EQUALS){
X	print_error("Bad format", token);
X	free_node(np);
X	return 0;
X    }
X    length = getoid(fp, oid, 16);
X    if (length > 1 && length <= 16){
X	/* just take the last pair in the oid list */
X	if (oid[length - 2].label)
X	    strncpy(np->parent, oid[length - 2].label, 32);
X	strcpy(np->label, name);
X	if (oid[length - 1].subid != -1)
X	    np->subid = oid[length - 1].subid;
X	else
X	    print_error("Warning: This entry is pretty silly", (char *)NULL);
X    } else {
X	print_error("No end to oid", (char *)NULL);
X	free_node(np);
X	np = 0;
X    }
X    /* free oid array */
X    for(count = 0; count < length; count++){
X	if (oid[count].label)
X	    free(oid[count].label);
X	oid[count].label = 0;
X    }
X    return np;
X}
X
X
X/*
X * Parses a mib file and returns a linked list of nodes found in the file.
X * Returns NULL on error.
X */
Xstatic struct node *
Xparse(fp)
X    FILE *fp;
X{
X    char token[64];
X    char name[32];
X    int	type = 1;
X    struct node *np, *root = NULL;
X
X    hash_init();
X
X    while(type != NULL){
X	type = get_token(fp, token);
X	if (type != LABEL){
X	    if (type == NULL){
X		return root;
X	    }
X	    print_error(token, "is a reserved word");
X	    return NULL;
X	}
X	strncpy(name, token, 32);
X	type = get_token(fp, token);
X	if (type == OBJTYPE){
X	    if (root == NULL){
X		/* first link in chain */
X		np = root = parse_objecttype(fp, name);
X		if (np == NULL){
X		    print_error("Bad parse of object type", (char *)NULL);
X		    return NULL;
X		}
X	    } else {
X		np->next = parse_objecttype(fp, name);
X		if (np->next == NULL){
X		    print_error("Bad parse of objecttype", (char *)NULL);
X		    return NULL;
X		}
X	    }
X	    /* now find end of chain */
X	    while(np->next)
X		np = np->next;
X	} else if (type == OBJID){
X	    if (root == NULL){
X		/* first link in chain */
X		np = root = parse_objectid(fp, name);
X		if (np == NULL){
X		    print_error("Bad parse of object id", (char *)NULL);
X		    return NULL;
X		}
X	    } else {
X		np->next = parse_objectid(fp, name);
X		if (np->next == NULL){
X		    print_error("Bad parse of object type", (char *)NULL);
X		    return NULL;
X		}
X	    }
X	    /* now find end of chain */
X	    while(np->next)
X		np = np->next;
X	} else if (type == EQUALS){
X	    type = parse_asntype(fp);
X	} else if (type == NULL){
X	    break;
X	} else {
X	    print_error("Bad operator", (char *)NULL);
X	    return NULL;
X	}
X    }
X#ifdef TEST
X{
X    struct enum_list *ep;
X    
X    for(np = root; np; np = np->next){
X	printf("%s ::= { %s %d } (%d)\n", np->label, np->parent, np->subid,
X		np->type);
X	if (np->enums){
X	    printf("Enums: \n");
X	    for(ep = np->enums; ep; ep = ep->next){
X		printf("%s(%d)\n", ep->label, ep->value);
X	    }
X	}
X    }
X}
X#endif /* TEST */
X    return root;
X}
X
X/*
X * Parses a token from the file.  The type of the token parsed is returned,
X * and the text is placed in the string pointed to by token.
X */
Xstatic int
Xget_token(fp, token)
X    register FILE *fp;
X    register char *token;
X{
X    static char last = ' ';
X    register int ch;
X    register char *cp = token;
X    register int hash = 0;
X    register struct tok *tp;
X
X    *cp = 0;
X    ch = last;
X    /* skip all white space */
X    while(isspace(ch) && ch != -1){
X	ch = getc(fp);
X	if (ch == '\n')
X	    Line++;
X    }
X    if (ch == -1)
X	return NULL;
X
X    /*
X     * Accumulate characters until white space is found.  Then attempt to match this
X     * token as a reserved word.  If a match is found, return the type.  Else it is
X     * a label.
X     */
X    do {
X	if (!isspace(ch)){
X	    hash += ch;
X	    *cp++ = ch;
X	    if (ch == '\n')
X		Line++;
X	} else {
X	    last = ch;
X	    *cp = '\0';
X
X	    for (tp = buckets[BUCKET(hash)]; tp; tp = tp->next) {
X		if ((tp->hash == hash) && (strcmp(tp->name, token) == 0))
X			break;
X	    }
X	    if (tp){
X		if (tp->token == CONTINUE)
X		    continue;
X		return (tp->token);
X	    }
X
X	    if (token[0] == '-' && token[1] == '-'){
X		/* strip comment */
X		while ((ch = getc(fp)) != -1)
X		    if (ch == '\n'){
X			Line++;
X			break;
X		    }
X		if (ch == -1)
X		    return NULL;
X		last = ch;
X		return get_token(fp, token);		
X	    }
X	    return LABEL;
X	}
X    
X    } while ((ch = getc(fp)) != -1);
X    return NULL;
X}
X
Xstruct tree *
Xread_mib(filename)
X    char *filename;
X{
X    FILE *fp;
X    struct node *nodes;
X    struct tree *tree;
X    struct node *parse();
X
X    fp = fopen(filename, "r");
X    if (fp == NULL)
X	return NULL;
X    nodes = parse(fp);
X    if (!nodes){
X	fprintf(stderr, "Mib table is bad.  Exiting\n");
X	exit(1);
X    }
X    tree = build_tree(nodes);
X    fclose(fp);
X    return tree;
X}
X
X
X#ifdef TEST
Xmain(argc, argv)
X    int argc;
X    char *argv[];
X{
X    FILE *fp;
X    struct node *nodes;
X    struct tree *tp;
X
X    fp = fopen("mib.txt", "r");
X    if (fp == NULL){
X	fprintf(stderr, "open failed\n");
X	return 1;
X    }
X    nodes = parse(fp);
X    tp = build_tree(nodes);
X    print_subtree(tp, 0);
X    fclose(fp);
X}
X
X#endif /* TEST */
END_OF_FILE
  if test 22322 -ne `wc -c <'nocol-3.0/src/cmu-snmp/snmplib/parse.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/snmplib/parse.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/snmplib/parse.c'
fi
if test -f 'nocol-3.0/src/support/multiping/multiping.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/support/multiping/multiping.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/support/multiping/multiping.h'\" \(2826 characters\)
  sed "s/^X//" >'nocol-3.0/src/support/multiping/multiping.h' <<'END_OF_FILE'
X/*
X * multiping.h -- header file for multiping.c
X */
X
X#ifndef __PING_H__ /* __PING_H__ */
X#define __PING_H__ 
X
X#define	DEFDATALEN	(64 - 8)	/* default data length */
X#define	MAXIPLEN	60
X#define	MAXICMPLEN	76
X#define	MAXPACKET	(65536 - 60 - 8)/* max packet size */
X#define	MAXWAIT		10		/* max seconds to wait for response */
X#define	NROUTES		9		/* number of record route slots */
X
X/*
X * Macros for bitwise operations, for use in maintaining and
X * checking the duplicate table
X */
X#define	A(x, bit)	(dest[x]->rcvd_tbl[(bit)>>3]) /* idtfy byte in array */
X#define	B(bit)		(1 << ((bit) & 0x07))	/* identify bit in byte */
X#define	SET(x, bit)	(A((x), (bit)) |= B(bit))
X#define	CLR(x, bit)	(A((x), (bit)) &= (~B(bit)))
X#define	TST(x, bit)	(A((x), (bit)) & B(bit))
X
X/**************************************************************************
X This section no longer applies because I'm no longer using the upper 4
X bits to keep track of the index into the dest[] array.
X
X#define MAXREMOTE 16  * max # remote systems that can be pinged at once *
X#define WHERESHIFT 12 * # of bits to shift to extract dest. ID *
X#define WHEREFROM(x)  ((x) >> WHERESHIFT)
X#define SEQUENCE(dst) ((dest[dst]->ntransmitted++) | ((dst) << WHERESHIFT))
X  * gives next sequence number for destination dest *
X#define SEQMASK               (1 << WHERESHIFT)-1     * mask out dest. ID *
X***************************************************************************/
X
X
X/*
X * MAX_DUP_CHK is the number of bits in received table, i.e. the maximum
X * number of received sequence numbers we can keep track of.  Change 128
X * to 8192 for complete accuracy...
X *
X * MAXREMOTE is the max # of systems you can ping simultaneously.  This
X * number can actually be arbitrarily large but your system performance
X * will begin to suffer.  You will probably never ping anywhere close to
X * 128 sites simultaneously anyway.
X */
X#define	MAX_DUP_CHK	8192
X#define MAXREMOTE 256
X
X/*
X * Define a structure to keep track internally of the various remote sites
X */
Xtypedef struct destrec {     /* in earlier revisions, destrec.sockad was a */
X  struct sockaddr_in sockad; /* struct sockaddr, in case you have problems */
X  char *rcvd_tbl;
X  long nreceived, 	/* # packets we got back */
X       nrepeats, 	/* # packets duplicated */
X       ntransmitted,	/* # packets xmitted */
X       tmin,  		/* minimum round-trip time */
X       tmax;		/* max RTT */
X  u_long tsum;		/* sum of all RTT's */
X  char hostname[MAXHOSTNAMELEN];
X} destrec;
X
X/*
X * Flags for the various command-line options
X */
X
X#define	F_FLOOD			0x0001
X#define	F_INTERVAL		0x0002
X#define	F_NUMERIC		0x0004
X#define	F_PINGFILLED		0x0008
X#define	F_QUIET			0x0010
X#define	F_RROUTE		0x0020
X#define	F_SO_DEBUG		0x0040
X#define	F_SO_DONTROUTE		0x0080
X#define	F_VERBOSE		0x0100
X#define F_TABULAR_OUTPUT	0x0200
X
X#endif /* __PING_H__ */
END_OF_FILE
  if test 2826 -ne `wc -c <'nocol-3.0/src/support/multiping/multiping.h'`; then
    echo shar: \"'nocol-3.0/src/support/multiping/multiping.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/support/multiping/multiping.h'
fi
echo shar: End of archive 9 \(of 26\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
