Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i152:  nocol - Network Monitoring System, Part22/26
Message-ID: <1993Nov24.163830.1912@sparky.sterling.com>
X-Md4-Signature: 9e9b9aba6a32b4346c7a49e33adb0806
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 24 Nov 1993 16:38:30 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 152
Archive-name: nocol/part22
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/cmu-snmp/apps/snmp_vars.h
#   nocol-3.0/src/cmu-snmp/apps/snmpwalk.c nocol-3.0/src/doc/noclogd.8
#   nocol-3.0/src/eventselect/proc_datafile.c
#   nocol-3.0/src/lib/bstring.c nocol-3.0/src/netmon/setup_display.c
#   nocol-3.0/src/nsmon/nsmon.c nocol-3.0/src/perlnocol/idlemodemmon
#   nocol-3.0/src/perlnocol/modemmon nocol-3.0/src/perlnocol/novellmon
#   nocol-3.0/src/pingmon/Makefile
#   nocol-3.0/src/support/mping/msummary
#   nocol-3.0/src/support/mping/t-msummary
# Wrapped by kent@sparky on Tue Nov  9 22:22:26 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 22 (of 26)."'
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h'\" \(5636 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h' <<'END_OF_FILE'
X/*
X * Definitions for SNMP (RFC 1067) agent variable finder.
X *
X *
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
Xu_char	*var_system();
Xu_char	*var_ifEntry();
Xu_char	*var_atEntry();
Xu_char	*var_ip();
Xu_char	*var_ipAddrEntry();
Xu_char	*var_ipRouteEntry();
Xu_char	*var_icmp();
Xu_char	*var_tcp();
Xu_char	*var_udp();
Xu_char	*var_process();
Xu_char	*var_event();
Xu_char	*getStatPtr();
X
Xextern long long_return;
Xextern u_char return_buf[];
X
X#define INST	0xFFFFFFFF	/* used to fill out the instance field of the variables table */
X
X/*
X * These are unit magic numbers for each variable.
X */
X
X#define VERSION_DESCR	0
X#define VERSION_ID	1
X#define IFNUMBER	2
X#define UPTIME		3
X#define EVENTNEXTINDEX	4
X
X
X#define IFINDEX		1
X#define IFDESCR		2
X#define IFTYPE		3
X#define IFMTU		4
X#define IFSPEED		5
X#define IFPHYSADDRESS	6
X#define IFADMINSTATUS	7
X#define IFOPERSTATUS	8
X#define IFLASTCHANGE	9
X#define IFINOCTETS	10
X#define IFINUCASTPKTS	11
X#define IFINNUCASTPKTS	12
X#define IFINDISCARDS	13
X#define IFINERRORS	14
X#define IFINUNKNOWNPROTOS 15
X#define IFOUTOCTETS	16
X#define IFOUTUCASTPKTS	17
X#define IFOUTNUCASTPKTS 18
X#define IFOUTDISCARDS	19
X#define IFOUTERRORS	20
X#define IFOUTQLEN	21
X
X#define ATIFINDEX	0
X#define ATPHYSADDRESS	1
X#define ATNETADDRESS	2
X
X#define IPFORWARDING	0
X#define IPDEFAULTTTL	1
X#define IPINRECEIVES	2
X#define IPINHDRERRORS	3
X#define IPINADDRERRORS	4
X#define IPFORWDATAGRAMS 5
X#define IPINUNKNOWNPROTOS 6
X#define IPINDISCARDS	7
X#define IPINDELIVERS	8
X#define IPOUTREQUESTS	9
X#define IPOUTDISCARDS	10
X#define IPOUTNOROUTES	11
X#define IPREASMTIMEOUT	12
X#define IPREASMREQDS	13
X#define IPREASMOKS	14
X#define IPREASMFAILS	15
X#define IPFRAGOKS	16
X#define IPFRAGFAILS	17
X#define IPFRAGCREATES	18
X
X#define IPADADDR	1
X#define IPADIFINDEX	2
X#define IPADNETMASK	3
X#define IPADBCASTADDR	4
X
X#define IPROUTEDEST	0
X#define IPROUTEIFINDEX	1
X#define IPROUTEMETRIC1	2
X#define IPROUTEMETRIC2	3
X#define IPROUTEMETRIC3	4
X#define IPROUTEMETRIC4	5
X#define IPROUTENEXTHOP	6
X#define IPROUTETYPE	7
X#define IPROUTEPROTO	8
X#define IPROUTEAGE	9
X
X#define ICMPINMSGS	     0
X#define ICMPINERRORS	     1
X#define ICMPINDESTUNREACHS   2
X#define ICMPINTIMEEXCDS      3
X#define ICMPINPARMPROBS      4
X#define ICMPINSRCQUENCHS     5
X#define ICMPINREDIRECTS      6
X#define ICMPINECHOS	     7
X#define ICMPINECHOREPS	     8
X#define ICMPINTIMESTAMPS     9
X#define ICMPINTIMESTAMPREPS 10
X#define ICMPINADDRMASKS     11
X#define ICMPINADDRMASKREPS  12
X#define ICMPOUTMSGS	    13
X#define ICMPOUTERRORS	    14
X#define ICMPOUTDESTUNREACHS 15
X#define ICMPOUTTIMEEXCDS    16
X#define ICMPOUTPARMPROBS    17
X#define ICMPOUTSRCQUENCHS   18
X#define ICMPOUTREDIRECTS    19
X#define ICMPOUTECHOS	    20
X#define ICMPOUTECHOREPS     21
X#define ICMPOUTTIMESTAMPS   22
X#define ICMPOUTTIMESTAMPREPS 23
X#define ICMPOUTADDRMASKS    24
X#define ICMPOUTADDRMASKREPS 25
X
X#define TCPRTOALGORITHM      1
X#define TCPRTOMIN	     2
X#define TCPRTOMAX	     3
X#define TCPMAXCONN	     4
X#define TCPACTIVEOPENS	     5
X#define TCPPASSIVEOPENS      6
X#define TCPATTEMPTFAILS      7
X#define TCPESTABRESETS	     8
X#define TCPCURRESTAB	     9
X#define TCPINSEGS	    10
X#define TCPOUTSEGS	    11
X#define TCPRETRANSSEGS	    12
X#define TCPCONNSTATE	    13
X#define TCPCONNLOCALADDRESS 14
X#define TCPCONNLOCALPORT    15
X#define TCPCONNREMADDRESS   16
X#define TCPCONNREMPORT	    17
X
X#define UDPINDATAGRAMS	    0
X#define UDPNOPORTS	    1
X#define UDPINERRORS	    2
X#define UDPOUTDATAGRAMS     3
X
X#define EVENTCLASS		    0
X#define EVENTINSTANCE		    1
X#define EVENTALARMTYPE		    2
X#define EVENTTIME		    3
X#define EVENTPROBCAUSE		    4
X#define EVENTSPECIFICPROBLEM	    5
X#define EVENTSEVERITY		    6
X#define EVENTBACKUPSTATUS	    7
X#define EVENTBACKUPINSTANCE	    8
X#define EVENTTREND		    9
X#define EVENTTHRESHOLD		    10
X#define EVENTTHRESHOLDLEVEL	    11
X#define EVENTTHRESHOLDOBSVALUE	    12
X#define EVENTID			    13
X#define EVENTCORRELATIONS	    14
X#define EVENTOPERSTATE		    16
X#define EVENTADMINSTATE		    17
X#define EVENTMONATTRIBUTES	    18
X#define EVENTREPAIRACTION	    19
X#define EVENTDATA		    20
X#define EVENTTEXT		    21
X#define EVENTCREDIBILITY	    22
X#define EVENTINDEX		    23
X#define EVENTVALID		    24
X
X
Xstruct variable {
X    oid		    name[26];	    /* object identifier of variable */
X    u_char	    namelen;	    /* length of above */
X    char	    type;	    /* type of variable, INTEGER or (octet) STRING */
X    u_char	    magic;	    /* passed to function as a hint */
X    u_short	    acl;	    /* access control list for variable */
X    u_char	    *(*findVar)();  /* function that finds variable */
X};
END_OF_FILE
  if test 5636 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmp_vars.h'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c'\" \(4780 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c' <<'END_OF_FILE'
X/*
X * snmpwalk.c - send snmp GETNEXT requests to a network entity, walking a subtree.
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "asn1.h"
X#include "snmp_api.h"
X#include "snmp_client.h"
X
Xoid objid_mib[] = {1, 3, 6, 1, 2, 1};
X
Xint	snmp_dump_packet = 0;
X
X
Xmain(argc, argv)
X    int	    argc;
X    char    *argv[];
X{
X    struct snmp_session	session, *ss;
X    struct snmp_pdu *pdu, *response;
X    struct variable_list *vars;
X    int	arg;
X    char *gateway = NULL;
X    char *community = NULL;
X    int gotroot = 0;
X    oid	name[32];
X    int name_length;
X    oid root[MAX_NAME_LEN];
X    int	rootlen, count;
X    int running;
X    int status;
X
X    init_mib();
X    /*
X     * usage: snmpwalk gateway-name community-name [object-id]
X     */
X    for(arg = 1; arg < argc; arg++){
X	if (argv[arg][0] == '-'){
X	    switch(argv[arg][1]){
X		case 'd':
X		    snmp_dump_packet++;
X		    break;
X		default:
X		    printf("invalid option: -%c\n", argv[arg][1]);
X		    break;
X	    }
X	    continue;
X	}
X	if (gateway == NULL){
X	    gateway = argv[arg];
X	} else if (community == NULL){
X	    community = argv[arg]; 
X	} else {
X	    rootlen = MAX_NAME_LEN;
X	    if (read_objid(argv[arg], root, &rootlen)){
X		gotroot = 1;
X	    } else {
X		printf("Invalid object identifier: %s\n", argv[arg]);
X	    }
X	}
X    }
X
X    if (gotroot == 0){
X	bcopy((char *)objid_mib, (char *)root, sizeof(objid_mib));
X	rootlen = sizeof(objid_mib) / sizeof(oid);
X	gotroot = 1;
X    }
X
X    if (!(gateway && community && gotroot == 1)){
X	printf("usage: snmpwalk gateway-name community-name object-identifier\n");
X	exit(1);
X    }
X
X    bzero((char *)&session, sizeof(struct snmp_session));
X    session.peername = gateway;
X    session.community = (u_char *)community;
X    session.community_len = strlen((char *)community);
X    session.retries = SNMP_DEFAULT_RETRIES;
X    session.timeout = SNMP_DEFAULT_TIMEOUT;
X    session.authenticator = NULL;
X    snmp_synch_setup(&session);
X    ss = snmp_open(&session);
X    if (ss == NULL){
X	printf("Couldn't open snmp\n");
X	exit(-1);
X    }
X
X    bcopy((char *)root, (char *)name, rootlen * sizeof(oid));
X    name_length = rootlen;
X
X    running = 1;
X    while(running){
X	running = 0;
X	pdu = snmp_pdu_create(GETNEXT_REQ_MSG);
X
X	snmp_add_null_var(pdu, name, name_length);
X
X	status = snmp_synch_response(ss, pdu, &response);
X	if (status == STAT_SUCCESS){
X	    if (response->errstat == SNMP_ERR_NOERROR){
X		for(vars = response->variables; vars; vars = vars->next_variable){
X		    if (vars->name_length < rootlen || bcmp(root, vars->name, rootlen * sizeof(oid)))
X			continue;	/* not part of this subtree */
X		    print_variable(vars->name, vars->name_length, vars);
X		    bcopy((char *)vars->name, (char *)name, vars->name_length * sizeof(oid));
X		    name_length = vars->name_length;
X		    running = 1; /* restart so we can get next variable */
X		}
X	    } else {
X		if (response->errstat == SNMP_ERR_NOSUCHNAME){
X		    printf("End of MIB.\n");
X		} else {
X		    printf("Error in packet.\nReason: %s\n", snmp_errstring(response->errstat));
X		    if (response->errstat == SNMP_ERR_NOSUCHNAME){
X			printf("The request for this object identifier failed: ");
X			for(count = 1, vars = response->variables; vars && count != response->errindex;
X			    vars = vars->next_variable, count++)
X				;
X			if (vars)
X			    print_objid(vars->name, vars->name_length);
X			printf("\n");
X		    }
X		}
X	    }
X
X	} else if (status == STAT_TIMEOUT){
X	    printf("No Response from %s\n", gateway);
X	} else {    /* status == STAT_ERROR */
X	    printf("An error occurred, Quitting\n");
X	}
X
X	if (response)
X	    snmp_free_pdu(response);
X    }
X    snmp_close(ss);
X}
X
END_OF_FILE
  if test 4780 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpwalk.c'
fi
if test -f 'nocol-3.0/src/doc/noclogd.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/doc/noclogd.8'\"
else
  echo shar: Extracting \"'nocol-3.0/src/doc/noclogd.8'\" \(5371 characters\)
  sed "s/^X//" >'nocol-3.0/src/doc/noclogd.8' <<'END_OF_FILE'
X.\" $Header: /home/aggarwal/lsrc/nocol/src/doc/RCS/noclogd.8,v 1.2 1993/10/28 16:38:03 aggarwal Exp $
X.\"
X.TH NOCLOGD 8 "Oct 1 1993"
X.SH NAME
Xnoclogd \- NOCOL event logging daemon
X.SH SYNOPSIS
X.B noclogd
X[
X.B \-d
X] [
X.B \-e
X.I output-error-filename
X] [
X.B \-f
X.I config-filename
X]
X.LP
XThe
X.I noclogd
Xdaemon logs NOCOL events to the files specified in the config file, based
Xon the loglevels specified. Alternately, it can open a pipe to a process
Xand run that process instead of writing to a file.
X.SH OPTIONS
X.TP
X.B \-d
XFor debug mode. Will not daemonize and writes errrors to terminal.
X.TP
X.B \-e 
X.I <errorfile>
XFor writing out errors to. Default is \fI ETCDIR/noclogd.errors\fR
X.TP
X.B \-f 
X.I <config filename>
XLocation of the configuration file. Default is \fI ETCDIR/noclogd.cf\fR
X
X.SH DESCRIPTION
X.LP
XThe
X.B noclogd
Xdaemon is the logging daemon for the NOCOL network monitoring program.
XIt listens on a UDP port (2325) for the various nocol monitors to send
Xit EVENT structures. It then logs these events (as
X.I text
Xlines), to various output files depending of the configuration file
Xfor the daemon. Alternatively, the output can be piped to a program
Xto be executed. The logging methodology is similar to the Unix
X.B syslog
Xfacility.
XThe format of the
X.I noclogd
Xlog lines are:
X.RS
X.I date
X[
X.I sender
X]: SITE
X.I sitename address
XVAR
X.I varname value threshold units
XLEVEL
X.I severity
XLOGLEVEL
X.I log severity
XNOCOP
X.I up down unknown test
X.RE
X.LP
XSending a HUP signal to the server closes all streams currently open, and
Xreopens them. This is useful if you move the old log files every night
Xor so.
X
XFor security, only the hosts specified in the configuration file
Xare allowed to send log messages.
X
X.SH DESIGN CONSIDERATIONS
X.LP
XThe following are important 'features' about
X.B noclogd
Xthat should be kept in mind while logging and running programs through it:
X.RS
X.TP 3
X1.
XSince the sockets used are of the UDP type, datagrams can be lost if
Xtoo many events are sent to the daemon at the same time. However, since
Xthe monitors only log events when a state changes, this is usually not
Xa problem. Additionally, there is a counter in the
X.I eventlog()
Xcall to pause for a second after logging 100 events.
X.TP 3
X2.
XSecurity is implemented by allowing only a select list of IP addresses
Xto log (specified in the configuration file). The IP address of the
Xhost sending the packets is verified using the 
X.IR recvfrom (2)
Xsystem call. Note however, that there is no way to prevent malicious
Xusers on a permitted system from sending invalid junk data to the monitor
X(there is no password scheme implemented). Anyone from a valid machine
Xcan log events to the 
X.I noclogd
Xdaemon.
X.TP 3
X3.
XThe daemon does not
X.I fork(2)
Xoff a child for each packet that comes in. It processes each event 
Xitself. Thus,if you are piping the output to a program 
X(instead of logging to a file), then make sure that the program being 
Xrun does its main procesing in the background and returns control to
Xthe noclogd daemon as soon as possible.
X.I i.e.
Xthe various output programs being executed are responsible for doing
Xtheir own "fork-ing", the daemon will not do it for them, and might
Xlose other incoming log packets if the piped process does not release the
Xstdin.
X.TP 3
X4.
XThe hostname on which the 
X.I noclogd
Xdaemon runs, is compiled during runtime so that the various NOCOL
Xmonitors know the system on which the logging daemon runs. Typically,
Xit is easier to define this (in 
X.IR noclogd.h )
Xas
X.I noclog.your.domain
Xand create a CNAME for it in the nameserver.
X.TP 3
X5.
XThe server might not be running when the various monitors startup.
XHence, the library subroutine
X.I eventlog()
Xtries to log to the server only if it hasn't attempted to do so in 
Xthe past 60 secs (RETRY_REOPEN).
X.RE
X
X.SH CONFIG FILE
XThe configuration file format is:
X.RS
X.sp .5
X.nf
X# Comments begin with a # character.
X#
X# The following hosts are permitted to log entries to this daemon:
Xpermithosts     127.0.0.1  128.121.50.2 128.121.50.7
Xpermithosts     128.121.50.145
X##
X## Give full pathnames in filenames since the daemon changes dir.
X##
X## SENDER       LEVEL           LOGFILE or PIPEFILE
X##
X*               critical        /nocol/logs/log-critical
Xnsmon           error           /nocol/logs/log-error
Xtest            warning         /nocol/logs/log-warning
X*               info            /nocol/logs/log-info
X#
Xpingmon         critical        |/nocol/bin/beeper
X.fi
X.RE
XComments begin with a '#' and sender names can be specified as '*' to
Xindicate a wildcard. Keep in mind that an event is logged to all streams
Xwith a severity lower than its severity/loglevel. Thus, in the above example,
Xevents with a loglevel of ERROR will be logged to all the 3 files
X.I log-info, log-warning & log-error.
X
X.SH FUTURE DEVELOPMENTS
X.LP
XPossible future enhancements are:
X.RS
X.TP 3
X1.
XCreating another daemon that does all the time consuming 'work' with a 
Xsort of queue mechanism.
X.TP 3
X2.
XListening on a STREAM socket also, so that some monitors (who so desire)
Xcan open a STREAM connection and spew events down this reliable connection.
X
X.SH AUTHOR
X.nf
XVikas Aggarwal, JvNCnet, GES (vikas@jvnc.net) 
XDavid Wagner (wagner@jvnc.net).
X.fi
X.SH SEE ALSO
Xnocol(1) nocol-prog(3) perlnocol(3)
Xeventselect(8) genmon(8) noclogd(8) nocol-overview(8)
Xnocol-utility(8) nsmon(8) pingmon(8) portmon(8) 
Xtpmon(8) trapmon(8)
END_OF_FILE
  if test 5371 -ne `wc -c <'nocol-3.0/src/doc/noclogd.8'`; then
    echo shar: \"'nocol-3.0/src/doc/noclogd.8'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/doc/noclogd.8'
fi
if test -f 'nocol-3.0/src/eventselect/proc_datafile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/eventselect/proc_datafile.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/eventselect/proc_datafile.c'\" \(4498 characters\)
  sed "s/^X//" >'nocol-3.0/src/eventselect/proc_datafile.c' <<'END_OF_FILE'
X/*+ 
X * $Header: /home/aggarwal/lsrc/nocol/src/eventselect/RCS/proc_datafile.c,v 1.2 1993/10/30 03:18:33 aggarwal Exp $
X */
X
X/* Copyright 1993 JvNCnet, Global Enterprise Services */
X
X/*+ 
X * FUNCTION:
X * 	This program processes each open file descriptor that is
X * passed to it. If the severity + sender string + sitename + time
X * match, then it prints/logs the line in the NOCOL format.
X *
X */
X
X/*+
X * $Log: proc_datafile.c,v $
X * Revision 1.2  1993/10/30  03:18:33  aggarwal
X * Now uses get_date() instead of the Sun specific  timelocal() call
X *
X * Revision 1.1  1993/10/02  05:23:56  aggarwal
X * Initial revision
X *
X *
X */
X
X#include <stdio.h>
X#ifdef ultrix
X#include <time.h>
X#else
X#include <sys/time.h>
X#endif
X
X#include "nocol.h"
X
Xstatic struct tm curtm;			/* present time in tm structure	*/
Xchar   *event_to_logstr();		/* format event in string format */  
X
Xextern  char	**senderlist, **sitenamelist ;	/* defined in main() */
Xextern  int	minseverity, logevents, debugflag ;
Xextern  time_t	fromtime, totime;
X
Xproc_datafile (fd)
X     int fd;				/* file descriptor  */
X{
X    static EVENT null_event ;		/* all null for testing	*/
X    EVENT v;				/* storage for the event  */
X    int status, bufsize;		/* for exit status   */
X    time_t locclock ;
X
X    /* get present time and keep it constant while processing the entire
X    ** data file (don't add processing delay to the delta times).
X    */
X    
X    locclock = time ((long *)NULL);
X    bcopy(localtime ((long *)&locclock), &curtm, sizeof curtm);
X
X    /*+
X     * Need a bcmp test to ensure that the read event was not a NULL
X     * event (all zeroes) as could happen if a NFS file was moved
X     * while another process (e.g. display) is processing the file
X     * and has it open for reading.
X     */
X
X    /*
X     * Now read in a event and check severity, sender, sitename, times
X     */
X    while ((bufsize=read (fd, (char *)&v, sizeof(v))) == sizeof (v))
X      if (bcmp(v, null_event, sizeof(v)) != 0)		/* Not null event  */
X      {
X	  if ((int)v.severity  <= minseverity)
X	    if (check_strlist(&senderlist, v.sender))
X	      if (check_strlist(&sitenamelist, v.site.name))
X		if (check_event_time(&v))
X		{
X		    if (logevents)
X		      eventlog(&v);
X		    else
X		      printf("%s", event_to_logstr(&v));
X		}
X      }	/* end:  if (!null event)  */
X
X    if (bufsize == 0)			/* end of the file  */
X      status = 0;
X    else				/* some read error  */
X      status = -1;
X    return (status);	
X
X}	/* end:  proc_datafile()  */
X
X/*+ 
X * FUNCTION:
X * 	Check string list for matching string. Use of 'strncasecmp' looks
X * for a match from the beginning of the string, whereas 'strstr' looks
X * for a substring match but does not do ignore-case.
X */
Xcheck_strlist(slist, S)
X     char **slist, *S ;	/* command line list of strings vs. EVENT string */
X{
X    register i = 0 ; 
X    static char s[256];
X
X    /* nothing to compare against */
X    if (slist == NULL || *slist == NULL || s == NULL)
X      return (1);
X
X    while ( (s[i] =  tolower(S[i]) )  )		/* lowercase the string */
X      ++i ;
X
X    i = 0;
X
X#ifdef DEBUG
X    if (debugflag)
X      fprintf(stderr,
X	      "debug (check_strlist): checking for '%s' in list '%s'...\n",
X	      s, slist[0]);
X#endif
X    while (slist[i])
X      if (strstr(s, slist[i]) != NULL)	/* cmd line 'slist' can be substring */
X/*      if (strncasecmp(s, slist[i], strlen(slist[i]))  == 0 ) /* */
X      {
X#ifdef DEBUG
X	  fprintf(stderr, "debug (check_strlist): matched %s\n", slist[i]);
X#endif
X	  return (1);
X      }
X      else
X      {
X#ifdef DEBUG
X	  fprintf(stderr, "debug (check_strlist): failed %s\n", slist[i]);
X#endif
X	  ++i ;
X      }
X
X    return(0) ;				/* failure */
X}
X
X/*+ 
X * FUNCTION:
X * 	Check event time to see if they fall in the user specified
X * command line time ranges.
X**/
Xcheck_event_time(pv)
X     EVENT  *pv;
X{
X    struct tm tm ;
X    time_t eventtime ;
X
X    bcopy (&curtm, &tm, sizeof(tm));	/* current time */
X
X    if (tm.tm_mon < (int)pv->mon - 1)
X      tm.tm_year -= 1 ;			/* previous year */
X
X    tm.tm_mon = pv->mon - 1;	tm.tm_mday = pv->day ;
X    tm.tm_hour = pv->hour ;	tm.tm_min = pv->min ;
X
X/*    eventtime = timelocal(&tm) ;	/* Only on SunOS ? */
X    eventtime = get_date(asctime(&tm), NULL); /* convert to secs since 1970 */
X
X#ifdef DEBUG
X    if (debugflag)
X      fprintf(stderr,
X	      "debug (event_time): fromtime/eventtime/totime = %ld/%ld/%ld\n",
X	      fromtime, eventtime, totime);
X#endif
X    if (eventtime > fromtime  &&  eventtime < totime)
X      return (1);
X    else
X      return(0);
X}
X
END_OF_FILE
  if test 4498 -ne `wc -c <'nocol-3.0/src/eventselect/proc_datafile.c'`; then
    echo shar: \"'nocol-3.0/src/eventselect/proc_datafile.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/eventselect/proc_datafile.c'
fi
if test -f 'nocol-3.0/src/lib/bstring.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/lib/bstring.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/lib/bstring.c'\" \(4857 characters\)
  sed "s/^X//" >'nocol-3.0/src/lib/bstring.c' <<'END_OF_FILE'
X/* $Header: /home/aggarwal/lsrc/nocol/src/lib/RCS/bstring.c,v 1.1 1993/10/30 03:22:47 aggarwal Exp $ */
X/*
X * Merged bcmp(),  bzero(),  bcopy()  from BSD distribution. -vikas
X */
X/*
X * Copyright (c) 1987 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#if defined(LIBC_SCCS) && !defined(lint)
X/*static char *sccsid = "from: @(#)bcmp.c	5.6 (Berkeley) 2/24/91";*/
Xstatic char *rcsid = "bcmp.c,v 1.3 1993/08/26 00:51:35 jtc Exp";
X#endif /* LIBC_SCCS and not lint */
X
X#include <string.h>
X/* #include <sys/cdefs.h>	/* */
X
X/*
X * bcmp -- vax cmpc3 instruction
X */
Xbcmp(b1, b2, length)
X	const void *b1, *b2;
X	register size_t length;
X{
X	register char *p1, *p2;
X
X	if (length == 0)
X		return(0);
X	p1 = (char *)b1;
X	p2 = (char *)b2;
X	do
X		if (*p1++ != *p2++)
X			break;
X	while (--length);
X	return(length);
X}
X
X
X/* static char *rcsid = "bcopy.c,v 1.3 1993/08/26 00:51:36 jtc Exp"; */
X
X/*
X * sizeof(word) MUST BE A POWER OF TWO
X * SO THAT wmask BELOW IS ALL ONES
X */
Xtypedef	int word;		/* "word" used for optimal copy speed */
X
X#define	wsize	sizeof(word)
X#define	wmask	(wsize - 1)
X
X/*
X * Copy a block of memory, handling overlap.
X * This is the routine that actually implements
X * (the portable versions of) bcopy, memcpy, and memmove.
X */
X#ifdef MEMCOPY
Xvoid *
Xmemcpy(dst0, src0, length)
X#else
X#ifdef MEMMOVE
Xvoid *
Xmemmove(dst0, src0, length)
X#else
Xvoid
Xbcopy(src0, dst0, length)
X#endif
X#endif
X	void *dst0;
X	const void *src0;
X	register size_t length;
X{
X	register char *dst = dst0;
X	register const char *src = src0;
X	register size_t t;
X
X	if (length == 0 || dst == src)		/* nothing to do */
X		goto done;
X
X	/*
X	 * Macros: loop-t-times; and loop-t-times, t>0
X	 */
X#define	TLOOP(s) if (t) TLOOP1(s)
X#define	TLOOP1(s) do { s; } while (--t)
X
X	if ((unsigned long)dst < (unsigned long)src) {
X		/*
X		 * Copy forward.
X		 */
X		t = (int)src;	/* only need low bits */
X		if ((t | (int)dst) & wmask) {
X			/*
X			 * Try to align operands.  This cannot be done
X			 * unless the low bits match.
X			 */
X			if ((t ^ (int)dst) & wmask || length < wsize)
X				t = length;
X			else
X				t = wsize - (t & wmask);
X			length -= t;
X			TLOOP1(*dst++ = *src++);
X		}
X		/*
X		 * Copy whole words, then mop up any trailing bytes.
X		 */
X		t = length / wsize;
X		TLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);
X		t = length & wmask;
X		TLOOP(*dst++ = *src++);
X	} else {
X		/*
X		 * Copy backwards.  Otherwise essentially the same.
X		 * Alignment works as before, except that it takes
X		 * (t&wmask) bytes to align, not wsize-(t&wmask).
X		 */
X		src += length;
X		dst += length;
X		t = (int)src;
X		if ((t | (int)dst) & wmask) {
X			if ((t ^ (int)dst) & wmask || length <= wsize)
X				t = length;
X			else
X				t &= wmask;
X			length -= t;
X			TLOOP1(*--dst = *--src);
X		}
X		t = length / wsize;
X		TLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);
X		t = length & wmask;
X		TLOOP(*--dst = *--src);
X	}
Xdone:
X#if defined(MEMCOPY) || defined(MEMMOVE)
X	return (dst0);
X#else
X	return;
X#endif
X}
X
X
X/*
X * bzero -- vax movc5 instruction
X */
Xvoid
Xbzero(b, length)
X	void *b;
X	register size_t length;
X{
X	register char *p;
X
X	for (p = b; length--;)
X		*p++ = '\0';
X}
X
END_OF_FILE
  if test 4857 -ne `wc -c <'nocol-3.0/src/lib/bstring.c'`; then
    echo shar: \"'nocol-3.0/src/lib/bstring.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/lib/bstring.c'
fi
if test -f 'nocol-3.0/src/netmon/setup_display.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/netmon/setup_display.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/netmon/setup_display.c'\" \(4602 characters\)
  sed "s/^X//" >'nocol-3.0/src/netmon/setup_display.c' <<'END_OF_FILE'
X/*+ 
X** $Header: /nocol/src/netmon/RCS/setup_display.c,v 1.3 1992/06/18 21:09:10 aggarwal Exp $
X**/
X
X/* Copyright 1992 JvNCnet, Princeton */
X
X/*+ 
X** FUNCTION
X**	To create all necessary windows.
X**
X** Subwindows within 'wmain' are created and changes made in them.
X** Then only 'wmain' needs to be refreshed. Each window can be treated
X** individually (and with respect (!!)).
X**
X**/
X
X/*
X * $Log: setup_display.c,v $
X * Revision 1.3  1992/06/18  21:09:10  aggarwal
X * Added check for columns also.
X *
X * Revision 1.2  1992/04/22  22:59:58  aggarwal
X * Lot of cleaning up for releasing. Organized things right.
X *
X * Revision 1.1  1990/03/09  13:06:33  aggarwal
X * Initial revision
X *
X *
X */
X#include	"netmon.h"
X
Xsetup_display()
X{
X    extern int LINES, COLS;			/* defined in curses.h	*/
X    extern struct allwins aw;			/* defined in netmon.h	*/
X    extern int level, options; 			/* defined in netmon.h	*/
X    extern char *prognm ;			/* defined in netmon.h	*/
X
X    initscr ();
X    noecho();					/* else messes up curses */
X    cbreak();					/* don't buffer input */
X
X    if ( COLS < MNCOLS )
X    {
X	endwin ();
X	fprintf (stderr, 
X		 "%s: Terminal ('%s') too small (need %d cols, have %d)\n\n", 
X		 prognm, ttytype, MNCOLS, COLS);
X	exit (1);
X    }
X
X    if (compute_window_sizes() == -1)
X    {
X	endwin();			/* error printed in compute_.. */
X	exit(1);
X    }
X
X    bzero(&aw, sizeof(aw));
X    aw.wmain = newwin (0,0,0,0);		/* Create main window	*/
X    create_sub_windows (aw.wmain) ;		/* create all sub-wins	*/
X
X    scrollok (aw.wmain, TRUE);			/* Allow scrolling	*/
X    leaveok (aw.wmain, FALSE);			/* leave cursor at curxy */
X
X}						/* end: setup_display()	*/
X
X/*+ 		compute_window_sizes
X** FUNCTION:
X** 	Calculates the sizes of the various variable windows like the
X** EVENT window and then the corresponding size of the message window.
X** The minimum size of the event window is 2 rows and the maximum
X** size is LINES - (sum of all fixed sized windows). It returns a -1
X** if the size of the screen is too small. Minimum message window size
X** is 1 line (this is added to the fixedsz and then added to the msg
X** window size. Thus, the minimum window size is fixedsz + min(event sz)
X**
X**/
Xcompute_window_sizes()
X{
X    extern int titlesz, hdrsz, promptsz, 
X           eventsz, msgtitlesz, msgsz, LINES ;	/* In netmon.c		*/
X    int fixedsz ;				/* total fixed win size	*/
X
X    titlesz = TITLESZ;				/* Fixed window sizes	*/
X    hdrsz   = HDRSZ ;				/* Fixed  ..		*/
X    promptsz = PROMPTSZ ;			/* Fixed ..		*/
X    msgtitlesz = MSGTITLESZ ;			/* Fixed ..		*/
X
X    fixedsz = titlesz + hdrsz + promptsz + msgtitlesz + 1 ;
X
X    if (eventsz <= 0)				/* first time setting	*/
X      eventsz = EVENTSZ ;
X
X    if (eventsz > (LINES - fixedsz))		/* Now verify size	*/
X      eventsz = LINES - fixedsz ;		/* Maximum size		*/
X    else if (eventsz < 2)
X      eventsz = 2;				/* minimum size		*/
X
X    msgsz = LINES - fixedsz - eventsz + 1 ;	/* all remaining lines	*/
X    
X    if (msgsz < 1)				/* msg win atleast 1 	*/
X    {
X	fprintf(stderr, "window_sizes: Lines lesser than %d\n", 
X		fixedsz + eventsz);
X	return (-1);				/* screen too small	*/
X    }
X    return (0);
X}					/* end: compute_win_sizes	*/
X
X
X/*+ 		create_sub_windows
X** 
X** FUNCTION
X**
X** This function creates subwindows within the main window. The main
X** window is passed as a parameter to the module. The reason behind
X** creating sub-windows is that the sub-windows alter the main window
X** also and after making all the alterations, we need call only one
X** refresh to display all the changes.
X** 
X** The idea behind creating many windows instead of working with just
X** one is that each window represents a header, title, etc. and we can
X** manipulate the screen better.
X**
X** The location and number of the windows are found from the definition of
X** the 'allwins' structure and the '..SZ' definitions in the netmon.h
X** header file.
X**/
X
Xcreate_sub_windows (wmain)
X     WINDOW *wmain ;				/* Main window (parent)	*/
X{
X    extern int COLS;
X    extern struct allwins aw ;			/* defined in netmon.h	*/
X
X    aw.wtitle = subwin (wmain, titlesz, COLS, 0, 0) ;
X    aw.whdr   = subwin (wmain, hdrsz, COLS, titlesz, 0) ;
X    aw.wevent = subwin (wmain, eventsz, COLS, titlesz + hdrsz, 0);
X    aw.wmsgtitle = subwin (wmain, msgtitlesz, COLS, titlesz+hdrsz+eventsz, 0);
X    aw.wmsg = subwin (wmain, msgsz, COLS, titlesz+hdrsz+eventsz+msgtitlesz, 0);
X    aw.wprompt = subwin(wmain,promptsz,COLS, 
X			titlesz+hdrsz+eventsz+msgtitlesz+msgsz, 0);
X
X    scrollok (aw.wmsg, TRUE);		/* Message window can scroll	*/
X    return (1);
X}					/* end:  create_sub_windows()	*/
X
END_OF_FILE
  if test 4602 -ne `wc -c <'nocol-3.0/src/netmon/setup_display.c'`; then
    echo shar: \"'nocol-3.0/src/netmon/setup_display.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/netmon/setup_display.c'
fi
if test -f 'nocol-3.0/src/nsmon/nsmon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/nsmon/nsmon.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/nsmon/nsmon.c'\" \(5107 characters\)
  sed "s/^X//" >'nocol-3.0/src/nsmon/nsmon.c' <<'END_OF_FILE'
X/*
X * $Header: /home/aggarwal/lsrc/nocol/src/nsmon/RCS/nsmon.c,v 1.5 1993/11/03 20:51:03 aggarwal Exp $
X */
X/*+ 
X** FUNCTION:
X** 	Make a domain nameserver query and send it off to the server.
X** Used as part of the 'nocol' nsmon nameserver monitoring program.
X** Query options customized to test if the nameserver is up and running.
X**
X**
X** AUTHOR
X**	S. Spencer Sun, Princeton Univ. / JvNCnet, June 1992
X**/
X
X/* Copyright 1993 JvNCnet, Global Enterprise Services */
X
X/*
X * $Log: nsmon.c,v $
X * Revision 1.5  1993/11/03  20:51:03  aggarwal
X * Added ifdef for h_addr (defined in netdb.h) in case its defined.
X *
X * Revision 1.4  1993/10/30  03:41:25  aggarwal
X * *** empty log message ***
X *
X * Revision 1.3  1993/10/29  23:15:25  aggarwal
X * Changed to use UDP instead of TCP. The timeout mechanism in
X * TCP was kinda ugly (using setjmp)
X *
X * Revision 1.2  1993/10/29  22:04:39  aggarwal
X * Cleaned up. Also set the setjmp env parameter to diff from
X * the one in main().
X *
X * Revision 1.1  1992/06/11  05:03:14  aggarwal
X * Initial revision
X *
X */
X
X
X#include <stdio.h>
X#include <netdb.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/param.h>
X#include <netinet/in.h>
X#include <arpa/nameser.h>
X#include <resolv.h>		/* definition of 'state' */
X
X#include "nsmon.h"
X
Xstatic int n_debug ;		/* debugging within this module */
X
Xstatic char *rcode_bindings[] = {
X  "NOERROR",		/* 0 */
X  "FORMERR",		/* 1 */
X  "SERVFAIL",		/* 2 */
X  "NXDOMAIN",		/* 3 */
X  "NOTIMP",		/* 4 */
X  "REFUSED",		/* 5 */
X  "<unknown rcode>",	/* 6 */
X  "<unknown rcode>",	/* 7 */
X  "<unknown rcode>",	/* 8 */
X  "<unknown rcode>",	/* 9 */
X  "<unknown rcode>",	/* A */
X  "<unknown rcode>",	/* B */
X  "<unknown rcode>",	/* C */
X  "<unknown rcode>",	/* D */
X  "<unknown rcode>",	/* E */
X  "NOCHANGE"		/* F */
X};
X
X/*
X * nsmon -- builds the query using res_mkquery() and then sends it using
X * res_send().  Calling parameters and return values are detailed in nsmon.h.
X */
X
Xnsmon (server, request, class, type, timeout, aa_only, debug)
X  char *server, *request;
X  int class, type, timeout, aa_only, debug;
X{
X  int n, ch;
X  HEADER *hp;
X  char buf[BUFSIZ], answer[BUFSIZ], *p;
X  struct sockaddr_in sa, *psin ;
X  extern struct state _res;		/* defined in resolv.conf ? */
X  
X  psin = &(_res.nsaddr) ;
X  /* insert server address into _res structure */
X  bzero(psin, sizeof (*psin));
X  psin->sin_family = AF_INET ;
X  psin->sin_port = htons(NAMESERVER_PORT);
X  if (isdigit (*server))
X    psin->sin_addr.s_addr = inet_addr(server);
X  else
X  {
X      struct hostent *hp ;	/* gethostbyname returns in_addr structures */
X      if ((hp = gethostbyname(server)) == NULL)
X      {
X	  fprintf (stderr, "gethostbyname () failed for '%s'- ", server);
X	  perror("nsmon");
X	  return ERROR ;
X      }
X#ifdef h_addr		/* in netdb.h */
X      bcopy ((char *)hp->h_addr, (char *)&(psin->sin_addr), hp->h_length) ;
X#else
X      bcopy ((char *)hp->h_addr_list[0], (char *)&(psin->sin_addr), 
X	     hp->h_length) ;
X#endif
X  }
X
X  if (debug) 
X    printf ("Nameserver is %s, port %d\n",
X      inet_ntoa(_res.nsaddr.sin_addr), ntohs(_res.nsaddr.sin_port));
X
X  /*
X   * set various flags for _res options
X   */
X  _res.options = RES_INIT;		/* don't call res_init() */
X/*  _res.options |= RES_USEVC ;		/* use TCP and not UDP */
X  _res.options |= RES_PRIMARY;		/* only query primary server */
X  _res.options &= ~RES_RECURSE ;	/* no recursion */
X  _res.options &= ~RES_DNSRCH ;		/* don't search parent, etc. */
X  if (aa_only)
X    _res.options |= RES_AAONLY; 	/* only authoritative answers */
X  if (timeout)
X     _res.retrans = timeout ;		/* timeout in seconds */
X
X  if (debug > 1) {
X    _res.options |= RES_DEBUG;
X    fprintf(stderr, "     _res.options = %ld\n", _res.options);
X    fprintf(stderr, "     _res.defdname = %s\n", _res.defdname);
X    fprintf(stderr, "About to call res_mkquery()\n");
X  }
X
X  /* First ask res_mkquery() to build a query structure */
X  /* Types defined in nameser.h  T_A, T_NS, T_SOA, T_PTR */
X  n = res_mkquery(QUERY, request, class, type, 
X		  (char *)NULL, 0, NULL, (char *)buf, sizeof(buf));
X  /* query in buf */
X  
X  if (n < 0) {
X      if (debug) {
X	  fprintf(stderr, "nsmon: problem with site %s\n", server);
X	  perror("res_mkquery");
X      }
X      return ERROR;
X  }
X
X  if (debug > 1) {
X      fprintf(stderr, "     _res.options = %ld\n", _res.options);
X      fprintf(stderr, "     _res.defdname = %s\n", _res.defdname);
X      fprintf(stderr, "About to call res_send()\n");
X  }
X
X  /* Now send the query using res_send() */
X
X  n = res_send(buf, n, answer, sizeof(answer) ) ;
X  
X  if (n < 0) {
X      if (debug) {
X	  printf("nsmon: problem with site %s\n",  server);
X	  perror("res_send");
X      }
X      return ERROR;
X  }
X  else
X    if (debug > 1)
X      fprintf (stderr, "nsmon: Returned from res_send\n");
X  
X  hp = (HEADER *)answer ;
X  
X  if (hp->rcode != NOERROR) {
X      if (debug)
X	fprintf(stderr, "got rcode of %s from nameserver\n",
X		rcode_bindings[hp->rcode]);
X      return ERROR;
X  }
X
X  if (aa_only && !(hp->aa))
X    return NOT_AUTHORITATIVE;
X  
X  return ALL_OK;		/* Don't check the response, must be okay */
X}			/* end nsmon() */
END_OF_FILE
  if test 5107 -ne `wc -c <'nocol-3.0/src/nsmon/nsmon.c'`; then
    echo shar: \"'nocol-3.0/src/nsmon/nsmon.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/nsmon/nsmon.c'
fi
if test -f 'nocol-3.0/src/perlnocol/idlemodemmon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/perlnocol/idlemodemmon'\"
else
  echo shar: Extracting \"'nocol-3.0/src/perlnocol/idlemodemmon'\" \(5917 characters\)
  sed "s/^X//" >'nocol-3.0/src/perlnocol/idlemodemmon' <<'END_OF_FILE'
X#!/usr/local/bin/perl 
X# $Header$
X#
X#     idlemodemmon - perl monitor for flagging IDLE modem lines on 
X#			Cisco Terminal Servers
X#
X#  -Vikas Aggarwal, vikas@jvnc.net
X#
X#	Copyright 1993 JvNCnet, Global Enterprise Services
X#
X#  THIS IS AN SNMP based program and uses the CMU-SNMP 'snmpwalk' program.
X#
X# To Install:
X#
X#	Compile the CMU-SNMP programs and install snmpwalk and the
X#	mib.txt file in desired locations. Then set the variables
X#	as described in the 'Customize' section.
X#
X# Reads a list of cisco terminal servers to monitor (from
X# a config file) and thresholds. Flags idle lines via NOCOL.
X#
X#
X# Files used:
X#   snmpwalk -		From CMU-SNMP distribution
X#   mib.txt  -		MIB file in ASN syntax with merged Cisco MIB.
X#
X# Nocol event elements used:
X#   sender                     "idlemodemmon"
X#   severity                   as read from the config file
X#   site
X#    name                      the cisco name
X#    addr                      cisco IP address
X#   var                       
X#    name                      "ModemIdle"
X#    value                     1 means at Info level
X#    threshold                 as read from the config file
X#    units                     always "Secs"
X#
X## 
X##
X#
X############################
X## Variables customization #  overrides values in the nocollib.pl library
X############################
X$SNMP = "../cmu-snmp" ;			# To find binary and MIBFILW
X$prog =  "$SNMP/bin/snmpwalk" ;		# location of 'snmpwalk'
X$mibfile = "$SNMP/mib.txt" ;	# Location of MIB file
X
X# Cisco MIB ASN
X# cisco.local...tsLineActive = 9.2.9.2.1.1
X$mibcisco  = ".iso.org.dod.internet.private.enterprises.cisco.local" ;
X$miblineidle = $mibcisco.".lts.ltsLineSessionTable.ltsLineSessionEntry.tslineSesIdle" ;
X$community=  "public";
X
X$varname="ModemIdle";
X$varunits="Secs" ;			# the var.units field in EVENT struct
X$sleepint=60*10;       			# Seconds to sleep between tries.
X############################
X$debug = 1;				# set to 1 for debugging output
X$libdebug = 0;				# set to 1 for debugging output
X
Xrequire  "nocollib.pl" ;
X
X-x $prog || die("Could not find executable $prog, exiting");
X-f $mibfile || die("Could not find MIB file $rprog, exiting");
X$ENV{"MIBFILE"}= $mibfile ;
X
X@me=split(/\//,$0); $me=pop(@me);
X#$piddir=join("/",@me); if ($piddir eq "") {$piddir=$etcdir;}
X$piddir=$etcdir;
X$cfile="$etcdir/$me-confg";
X$datafile="$datadir/$me-output";
X
X$sender= $me ;				# filled in the EVENT sender
X
X
X##
X# Read the config file. Use '\t' as a separator for 'item'
Xsub readconf {
X    local ($nets, $interface, $zone) ;
X
X    open(CONFIG,"<$cfile")||die("Couldn't find $cfile, exiting");
X    while(<CONFIG>)
X    {
X	chop;
X	if(/^\s*#/) {next;}   # skip comments
X	if(/^\s*$/) {next;}   # skip blank lines
X	if (/\s*(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$/)
X	{
X	    $item="$1\t$2" ;	 # the name and address
X	    $wlevel{$item} = $3; # Warning level
X	    $elevel{$item} = $4; # Error level
X	    $clevel{$item} = $5; # Critical level
X	    push(@items,$item);
X	}
X	else {print "Ignoring illegal line: $_\n";}
X
X    }	# end while(CONFIG)
X
X    close(CONFIG);
X    if(0>$#items){die("Nothing to monitor in $cfile, exiting")};
X    if ($debug) {
X	print "Items are:\n"; foreach (@items) { print "\t$_\n" } ;
X    }
X}				# end: readconf
X
X
X# 
X## Check state of each router
X##
X#
X# Walks the TServer ltsLineActive/ltsLineType  mib trees (cisco specific) 
X# and collects TERMINAL type lines that are ACTIVE.
X# Prints number of active lines and total number of TTY lines.
X# Prints '-1' on error.
X#
X# CAVEATS:
X#   - Walking entire mib tree over UDP can be iffy. This is tested by seeing
X#     if any responses are missing in the TYPE list and the ACTIVE list.
X#
X###	
X#
Xsub dotest {
X    local ($router) = @_ ;
X    local ($maxidle) = -1 ;
X    local ($walkidle); 
X
X    if ($debug) { print "Checking $router\n"; }
X
X    -x $prog || die("Could not find executable $prog, exiting");
X
X    $walkidle = "$prog $router $community $miblineidle";
X#
X# Output of Check-active SNMP command is:
X#    Name: .iso.org.dod........lts.ltsLineSessionEntry.tslineSesIdle.2.1
X#    INTEGER: 1
X
X    open (ACTIVE, "$walkidle |") || die "Can't check active lines.";
X    while(<ACTIVE>){
X	chop;
X	if (/^\s*INTEGER:\s*(\d+)\s*$/)
X	{
X	    if ($1 > $maxidle) { $maxidle = $1 ; }
X	    if ($debug) { print "$1 secs, "; }
X	}
X    }
X    close(ACTIVE);
X
X    if ($debug) {print "(debug) Max idle line= $maxidle\n"; }
X
X    return ($maxidle) ;
X
X}	# end &dotest()
X
X
X###
X### main
X###
X
X# Fork and get rid of old process.
Xif($p=fork){print "$p\n";exit;}
X&standalone($me,$piddir);
X
X&readconf ;
X
Xforeach $item (@items) {
X    local ($host, $addr) = split( /\t/, $item );
X    &init_event ($host, $addr, $item);
X}
X
Xwhile (1)
X{
X    foreach $item (@items) {
X	local ($host, $addr) = split( /\t/, $item );
X	local ($lineidle) =  &dotest ($addr);
X
X	if ($lineidle < 0)
X	{
X	    print "$me: dotest failed for $host ($addr) , skipping\n";
X	    next ;
X	}
X	if ($lineidle >= $clevel{$item} ) # critical level
X	{
X	    if ($debug) {print "(debug): Maxlevel is Critical\n";}
X	    $varthres{$item} = $clevel{$item} ; # threshold
X	    &update_event($item, 0, $lineidle, $E_CRITICAL);
X	}
X	elsif ($lineidle >= $elevel{$item} )
X	{
X	    if ($debug) {print "(debug): Maxlevel is Error\n";}
X	    $varthres{$item} = $elevel{$item} ; # threshold
X	    &update_event($item, 0, $lineidle, $E_ERROR);
X	}
X	elsif ($lineidle >= $wlevel{$item} )
X	{
X	    if ($debug) {print "(debug): Maxlevel is Warning\n";}
X	    $varthres{$item} = $wlevel{$item} ; # threshold
X	    &update_event($item, 0, $lineidle, $E_WARNING);
X	}
X	else
X	{
X	    if ($debug) {print "(debug): Level is INFO\n";}
X	    $varthres{$item} = $wlevel{$item} ; # threshold is warning level
X	    &update_event($item, 1, $lineidle, $E_WARNING); # status UP
X	}	
X    }
X
X    ; ## Note: we want to write the file quickly.
X
X    open(OEVENTS,">$datafile");
X    foreach $item (@items) {
X	&writeevent($item);
X    }
X    close(OEVENTS);
X    sleep($sleepint);
X}
X
END_OF_FILE
  if test 5917 -ne `wc -c <'nocol-3.0/src/perlnocol/idlemodemmon'`; then
    echo shar: \"'nocol-3.0/src/perlnocol/idlemodemmon'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/perlnocol/idlemodemmon'
  # end of 'nocol-3.0/src/perlnocol/idlemodemmon'
fi
if test -f 'nocol-3.0/src/perlnocol/modemmon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/perlnocol/modemmon'\"
else
  echo shar: Extracting \"'nocol-3.0/src/perlnocol/modemmon'\" \(5111 characters\)
  sed "s/^X//" >'nocol-3.0/src/perlnocol/modemmon' <<'END_OF_FILE'
X#!/usr/local/bin/perl 
X
X# $Header: /home/aggarwal/lsrc/nocol/src/perlnocol/RCS/modemmon,v 1.1 1993/10/30 04:05:07 aggarwal Exp $
X#
X#        modemmon - perl monitor for modem line's usage on cisco's
X#
X#  Vikas Aggarwal,  vikas@jvnc.net
X#
X#	Copyright 1993 JvNCnet, Global Enterprise Services
X#
X# Modemmon  reads a list of cisco terminal servers to monitor (from
X# a config file) and thresholds. It then logs into the cisco's and
X# counts the number of lines in use. When the used lines exceeds the
X# thresholds, the lines are displayed in NOCOL data format.
X# Requires the 'rcisco' program for logging into the cisco specified.
X#
X# Nocol event elements used:
X#   sender                     "modemmon"
X#   severity                   as read from the config file
X#   site
X#    name                      the cisco name
X#    addr                      cisco IP address
X#   var                       
X#    name                      "ModemLines"
X#    value                     1 means at Info level
X#    threshold                 as read from the config file
X#    units                     always "Usage"
X#
X## 
X##
X#
X#
X############################
X## Variables customization #  overrides values in the nocollib.pl library
X############################
X$rprog="rcisco";			# Path for rcisco.
X$rpasswd="";				# if NULL, uses the default in rcisco
X$rcommand="who";
X$varname="ModemLines";
X$varunits="Usage" ;			# the var.units field in EVENT struct
X$sleepint=60*5;       			# Seconds to sleep between tries.
X############################
X$debug = 0;				# set to 1 for debugging output
X$libdebug = 0;				# set to 1 for debugging output
X
Xrequire  "nocollib.pl" ;
X
X-x $rprog || die("Could not find executable $rprog, exiting");
X
X@me=split(/\//,$0); $me=pop(@me);
X#$piddir=join("/",@me); if ($piddir eq "") {$piddir=$etcdir;}
X$piddir=$etcdir;
X$cfile="$etcdir/$me-confg";
X$datafile="$datadir/$me-output";
X
X$sender= $me ;				# filled in the EVENT sender
X
X
X##
X# Read the config file. Use '\t' as a separator for 'item'
Xsub readconf {
X    local ($nets, $interface, $zone) ;
X
X    open(CONFIG,"<$cfile")||die("Couldn't find $cfile, exiting");
X    while(<CONFIG>)
X    {
X	chop;
X	if(/^\s*#/) {next;}   # skip comments
X	if(/^\s*$/) {next;}   # skip blank lines
X	if (/\s*(\S+)\s+(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s*$/)
X	{
X	    $item="$1\t$2" ;	 # the name and address
X	    $wlevel{$item} = $3; # Warning level
X	    $elevel{$item} = $4; # Error level
X	    $clevel{$item} = $5; # Critical level
X	    push(@items,$item);
X	}
X	else {print "Ignoring illegal line: $_\n";}
X
X    }	# end while(CONFIG)
X
X    close(CONFIG);
X    if(0>$#items){die("Nothing to monitor in $cfile, exiting")};
X    if ($debug) {
X	print "Items are:\n"; foreach (@items) { print "\t$_\n" } ;
X    }
X}				# end: readconf
X
X## Check state of each router
X#
Xsub dotest {
X    local ($router) = @_ ;
X    local ($nusers) = 0;
X    local ($loginok) = 0;
X
X    if ($debug) { print "Checking $router\n"; }
X    $command="$rprog $router ".' "'."$rpasswd".'" '.'"'."$rcommand".'"';
X    if ($debug) {print "(debug) dotest: running command $command\n" ;}
X
X    open (ROUTER, "$command|") ;
X	
X    while(<ROUTER>) {
X	tr/\r\n//d;
X	if ( />/ ) {$loginok = 1 ;} # got the 'Router>' prompt
X	if ( /Dial-in/ )  {$nusers += 1 ;}
X	elsif ($debug) {
X#	    print "(debug) skipping line: $_\n" ;
X	}
X    }  # end while
X    close (ROUTER);
X#    sleep 5 ;			# process needs to die off ??
X
X    if ($loginok == 0) { 
X	print "Login into remote host failed\n" ;
X	$nusers = -1 ;
X    }
X    if ($debug) {print "Number of users= $nusers\n" ;}
X    return ($nusers) ;		# not caring about timeouts
X
X} # end: dotest()
X
X
X
X###
X### main
X###
X
X# Fork and get rid of old process.
Xif($p=fork){print "$p\n";exit;}
X&standalone($me,$piddir);
X
X&readconf ;
X
Xforeach $item (@items) {
X    local ($host, $addr) = split( /\t/, $item );
X    &init_event ($host, $addr, $item);
X}
X
Xwhile (1)
X{
X    foreach $item (@items) {
X	local ($host, $addr) = split( /\t/, $item );
X	local ($linesused) =  &dotest ($addr);
X
X	if ($linesused < 0)
X	{
X	    print "$me: dotest failed for $host ($addr) , skipping\n";
X	    next ;
X	}
X	if ($linesused >= $clevel{$item} ) # critical level
X	{
X	    if ($debug) {print "(debug): Maxlevel is Critical\n";}
X	    $varthres{$item} = $clevel{$item} ; # threshold
X	    &update_event($item, 0, $linesused, $E_CRITICAL);
X	}
X	elsif ($linesused >= $elevel{$item} )
X	{
X	    if ($debug) {print "(debug): Maxlevel is Error\n";}
X	    $varthres{$item} = $elevel{$item} ; # threshold
X	    &update_event($item, 0, $linesused, $E_ERROR);
X	}
X	elsif ($linesused >= $wlevel{$item} )
X	{
X	    if ($debug) {print "(debug): Maxlevel is Warning\n";}
X	    $varthres{$item} = $wlevel{$item} ; # threshold
X	    &update_event($item, 0, $linesused, $E_WARNING);
X	}
X	else
X	{
X	    if ($debug) {print "(debug): Level is INFO\n";}
X	    $varthres{$item} = $wlevel{$item} ; # threshold is warning level
X	    &update_event($item, 1, $linesused, $E_WARNING); # status UP
X	}	
X    }
X
X    ; ## Note: we want to write the file quickly.
X
X    open(OEVENTS,">$datafile");
X    foreach $item (@items) {
X	&writeevent($item);
X    }
X    close(OEVENTS);
X    sleep($sleepint);
X}
X
END_OF_FILE
  if test 5111 -ne `wc -c <'nocol-3.0/src/perlnocol/modemmon'`; then
    echo shar: \"'nocol-3.0/src/perlnocol/modemmon'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/perlnocol/modemmon'
  # end of 'nocol-3.0/src/perlnocol/modemmon'
fi
if test -f 'nocol-3.0/src/perlnocol/novellmon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/perlnocol/novellmon'\"
else
  echo shar: Extracting \"'nocol-3.0/src/perlnocol/novellmon'\" \(5881 characters\)
  sed "s/^X//" >'nocol-3.0/src/perlnocol/novellmon' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X#
X# $Header: /home/aggarwal/lsrc/nocol/src/perlnocol/RCS/novellmon,v 1.3 1993/10/28 17:42:45 aggarwal Exp $
X#
X#	novellmon - perl nocol Novell service monitor
X#
X# Date: September 21, 1993
X# Programmer: John Wobus, jmwobus@mailbox.syr.edu
X#  Modifications:  vikas@jvnc.net
X#
X#    (c) Syracuse University Computing & Network Services 1993
X#
X# No warranty is expressed or implied.  Permission to copy and use is
X# extended to all.  Permission to redistribute is granted under the
X# following conditions: it is not sold for profit; this copyright
X# notice remains intact; the same permissions extend to the recipient;
X# and if any changes are made, a notice is added so stating.
X#
X# Command Format:
X#
X#  novellmon
X#
X#    Automatically kills old process and forks a new one, reading
X#    the configuration file in the process.
X#
X# What it does:
X#
X#    novellmon reads the list of Novell servers from a Cisco router and
X#    checks for the appearance of the services listed in its own
X#    configuration file and reports any that are missing.  Example:
X#
X#    Site      Address      Time   +-Variable-+ +-Value-+  Condition
X#    DINAH  4(files)        09:58    IPX server        0    Critical
X#
X#    This line states that a file server called DINAH is not available.
X#
X# Files used:
X#
X#   rcisco                      perl program to do a Cisco router
X#                               command remotely.
X#   nocol/data/novellmon-output path to which to write nocol events.
X#   novellmon-confg             configuration file.
X#   novellmon.pid               file holding novellmon's current process id.
X#
X# Nocol event elements used:
X#   sender                     "novellmon"
X#   mon, day, hour, min        time at which entity went up or down
X#   severity                   up: 4; down: 3,2,1; test & down: 2;
X#   nocop                      up, down, unknown
X#   site
X#    name                      the Server name
X#    addr                      the numerical type of service and an
X#                               interpretation in parenthesis, e.g.
X#                               "4(files)" for file service.
X#   var                       
X#    name                      "IPX server"
X#    value                     1 means up, 0 means down
X#    threshold                 always 2
X#    units                     always "entry"
X#
X# To install this:
X#   (1) Choose where to put this file and the above 4 files and
X#       assign the perl variables below appropriately.
X#   (2) Create your novellmon-confg file in its chosen place.
X#   (3) Edit rcisco to include your Cisco router's password and put
X#       rcisco in its chosen place.
X#   (4) Put this file in its chosen place.
X#   (5) Add appropriate code to rc.local to start this monitor.
X#
X# Configuration file format:
X#    #<text>                                   Comment line.
X#    router=<router>                           Name of Cisco router.
X#    <servername> <servicetype>                IPX service, name & numerical
X#                                               type.
X#
X# Sample configuration file:
X#    # novellmon configuration
X#    router=mycisco.excellent.edu
X#    DINAH   4
X#
X## 
X##
X#
X#
X############################
X## Variables customization #  overrides values in the nocollib.pl library
X############################
X$rprog="./rcisco";		# Path for rcisco.
X$rpasswd="";			# if NULL, uses the default in rcisco
X$rcommand="show novell servers";
X$varname="IPX_server";		# Registered appletalk route
X$varunits="Entry" ;		# the var.units field in EVENT structure
X$sleepint=60*5;			# Seconds to sleep between tries.
X############################
X$debug = 0;			# set to 1 for debugging output
X$libdebug = 0;			# set to 1 for library debug output
X
Xrequire  "nocollib.pl" ;
X
X-x $rprog || die("Could not find executable $rprog, exiting");
X
X@me=split(/\//,$0); $me=pop(@me);
X#$piddir=join("/",@me); if ($piddir eq "") {$piddir=$etcdir;}
X$piddir=$etcdir;
X$cfile="$etcdir/$me-confg";
X$datafile="$datadir/$me-output";
X
X$sender= $me ;				# filled in the EVENT sender
X$maxseverity = $E_ERROR ;		# max severity of events
X
X%tname=("4","files","47","printing","10C","net3270","7050","ipxbootp");
X
X##
X# Read the config file. Use '\t' as a separator.
X#
Xsub readconf {
X    open(CONFIG,"<$cfile")||die("Couldn't find $cfile, exiting");
X    while(<CONFIG>){
X	chop;
X	if(/^\s*#/) {next;}   # skip comments
X	if(/^\s*$/) {next;}   # skip blank lines
X	if(/^\s*router\s*=\s*(\S+)(\s.*)?$/) {$router=$1;}
X	elsif(/^\s*(\S+)\s+(\S+)(\s.*)?$/) {push(@items,"$1\t$2");}
X    }
X    close(CONFIG);
X    if(!$router){die("No router specified in $cfile, exiting")};
X    if(0>$#items){die("Nothing to monitor in $cfile, exiting")};
X}
X
X
X## Check the current state of the router
X#
Xsub dotest {
X    local($loginok) = 0 ;
X    foreach(@items){$found{$_}=0;}
X
X    $command="$rprog $router ".' "'."$rpasswd".'" '.'"'."$rcommand".'"';
X    open(ROUTER,"$command|");
X
X    while(<ROUTER>){
X	tr/\r\n//d;
X	if ( />/ ) {$loginok = 1 ;} # got the 'Router>' prompt
X	if(/^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)$/) {
X	    $type=$1; $name=$2; $addr=$3; $hops=$4; $interface=$5;
X	    $item="$name\t$type";
X	    $found{$item}=1;
X	}
X    }
X    close(ROUTER);
X    if ($loginok == 0) { print "Login into remote host failed\n" ;}
X}
X
X
X###
X### Main program:
X###
X
X#Fork and get rid of old process.
X
Xif($p=fork){print "$p\n";exit;}
X&standalone($me,$piddir);
X
X&readconf;
X
Xforeach $item (@items) {
X    local($name,$type)=split(/\t/,$item);
X    &init_event("$name", "$type(".$tname{$type}.")", $item);
X}
X
X
Xwhile (1)
X{
X    &dotest;
X    foreach $item (@items)
X    {
X	if ($found{$item}) { &update_event($item, 1, 1, $maxseverity); }
X	else { &update_event($item, 0, 0, $maxseverity); }
X    }
X    #Note: we want to write the file quickly.
X    open(OEVENTS,">$datafile");
X    foreach $item (@items)
X    {
X	&writeevent($item);
X    }
X    close(OEVENTS);
X    sleep($sleepint);
X}
END_OF_FILE
  if test 5881 -ne `wc -c <'nocol-3.0/src/perlnocol/novellmon'`; then
    echo shar: \"'nocol-3.0/src/perlnocol/novellmon'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/perlnocol/novellmon'
  # end of 'nocol-3.0/src/perlnocol/novellmon'
fi
if test -f 'nocol-3.0/src/pingmon/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/pingmon/Makefile'\"
else
  echo shar: Extracting \"'nocol-3.0/src/pingmon/Makefile'\" \(3543 characters\)
  sed "s/^X//" >'nocol-3.0/src/pingmon/Makefile' <<'END_OF_FILE'
X# $Id: Makefile,v 1.12 1993/10/30 03:12:52 aggarwal Exp $
X#
X# Makefile for 'pingmon'
X#
X# This file is pretty complicated because the same objects create OSIpingmon
X# as well as IPpingmon. Only the compile time definitions are different.
X# One way was to have two separate Makefile's but passing the definitions
X# between three layers of 'make' is kinda hairy (3 layers since invoked from
X# the main 'nocol' makefile).
X#
X# Anyway, you can do the following:
X#
X# 	make PROTOCOL=IP
X#	make PROTOCOL=OSI
X#
X## SET THIS
X# Directories needed by the Makefile
XTOP =           /usr/nocol
XSRCDIR =	$(TOP)/src
X
XBINDIR =        $(TOP)/bin
XETCDIR =        $(TOP)/etc
XINCLUDEDIR =    $(SRCDIR)/include
XLIBDIR =	$(SRCDIR)/lib
X
X## SET THIS
X# Directories needed by the program.
X# 	DATADIR			for creating the PING-OUTPUT
X#	IPNODESFILE		location of IP nodes/hosts file
X#	IPPING			location of the IP ping program
X#	OSINODESFILE		location of the OSI nodes/hosts file
XDATADIR =       $(TOP)/data
X
XIPNODESFILE =	$(ETCDIR)/ipnodes
XIPPING =	/usr/etc/ping
X
XOSINODESFILE =	$(ETCDIR)/osinodes
XOSIPING =	/usr/sunlink/bin/osiping
X
X## Default protocol is IP Set to OSI for OSIpingmon.
XPROTOCOL = 	IP
X
X## SET THIS
X# Set the various defines for compile time defines:
X# 	-DMULTIPING	if using IPPING = 'multiping'
X#
XSYSDEFS =	# -DMULTIPING
X
X####
X#### Can leave the rest alone #######
X####
X
X##
X# The various directories that are needed in the program. Should NOT
X# have trailing '/'.
XIPDIRDEFS =	-DETCDIR=\"$(ETCDIR)\" \
X		-DDATADIR=\"$(DATADIR)\" \
X                -DNODESFILE=\"$(IPNODESFILE)\" \
X		-DPING=\"$(IPPING)\"
X
X
XOSIDIRDEFS =	-DETCDIR=\"$(ETCDIR)\" \
X		-DDATADIR=\"$(DATADIR)\" \
X                -DNODESFILE=\"$(OSINODESFILE)\" \
X		-DPING=\"$(OSIPING)\"
X
X
XCC =		cc
XIP_CDEFS = 	$(SYSDEFS) $(IPDIRDEFS)  -DIP
XOSI_CDEFS = 	$(SYSDEFS) $(OSIDIRDEFS) -DOSI
XLIBS =		-lnocol $(SYSLIBS)
XCFLAGS = 	-g -I$(INCLUDEDIR) -L$(LIBDIR)
X
XPINGMONS =	ippingmon osipingmon
XOBJECTS = 	pingmon.o poll_sites.o
X
X
X$(PINGMONS): pingmon
X
Xpingmon: reset $(OBJECTS) Makefile
X	$(CC) $(CFLAGS) $(OBJECTS) $(LIBS) -o pingmon
X	@if [ "$(PROTOCOL)" = "IP" ]; then \
X		make $(IPPING) IPPING=$(IPPING) ;\
X		cp pingmon ippingmon ;\
X		echo "Made $(PROTOCOL) version of pingmon" ;\
X		ls -lg ippingmon ;\
X	 else \
X		make $(OSIPING) OSIPING=$(OSIPING)  ;\
X		cp pingmon osipingmon ;\
X		echo "Made $(PROTOCOL) version of pingmon" ;\
X		ls -lg osipingmon ;\
X	 fi
X
X## The dependencies in case 'mkdep' not used
X#
X$(OBJECTS): $(INCLUDEDIR)/nocol.h  $(INCLUDEDIR)/pingmon.h 
X
X.c.o:
X	@if [ "$(PROTOCOL)" = "IP" ]; then \
X		$(CC) -c $(CFLAGS) $(IP_CDEFS)  $< ;\
X		echo "$(CC) -c $(CFLAGS) $(IP_CDEFS)  $<" ;\
X	 elif [ "$(PROTOCOL)" = "OSI" ]; then \
X		$(CC) -c $(CFLAGS) $(OSI_CDEFS) $< ;\
X		echo "$(CC) -c $(CFLAGS) $(OSI_CDEFS)  $<" ;\
X	 fi
X
X
X$(IPPING) $(OSIPING): IFC
X	@-[ -x "$@" ] || \
X	 { \
X		echo "WARNING: $@ does not exist" ;\
X		echo "      Install $@ with proper owner and mode"; \
X		echo '      (Mode should be 4751 and owner should be root) '; \
X	exit 1 ;\
X	 }
X
X# To force checking
XIFC:
X
Xinstall: 	$(PINGMONS)
X	-for i in $(PINGMONS); \
X	   do [ -f $$i ] && $(INSTALL) -c -m 751 $$i $(BINDIR)/ ;done
X	@echo "___Update $(IPNODESFILE), $(OSINODESFILE) with hostnames ___"
X
X## Clean up all except the newly created required binary. This cleanup allows
X# the same Makefile to make ippingmon and osipingmon
Xreset:
X	/bin/rm -f $(OBJECTS) core a.out
X
Xclean:
X	/bin/rm -f $(PINGMONS) $(OBJECTS) pingmon core a.out
X
Xrcs:
X	@echo "Doing 'rcs' in 'pingmon'"
X	@-for i in $(OBJS); do \
X		$(CO) -q `basename $$i .o`.c ;\
X	  done
END_OF_FILE
  if test 3543 -ne `wc -c <'nocol-3.0/src/pingmon/Makefile'`; then
    echo shar: \"'nocol-3.0/src/pingmon/Makefile'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/pingmon/Makefile'
fi
if test -f 'nocol-3.0/src/support/mping/msummary' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/support/mping/msummary'\"
else
  echo shar: Extracting \"'nocol-3.0/src/support/mping/msummary'\" \(5524 characters\)
  sed "s/^X//" >'nocol-3.0/src/support/mping/msummary' <<'END_OF_FILE'
X#! /usr/local/bin/perl
X
X#
X# Run ping connectivity tests.   Ping list of addresses every 60
X# seconds and keep a reachability metric for each address.  This
X# is intended to (1) help isolate problem links, and (2) give a
X# better idea of long term trends than just the immediate results
X# of the most recent test.
X#
X
X# Command to run test
X$dataFile = "msummary.out";
X$confFile = "msummary.dat";
X$command = "mping -f $confFile |";
X$napTime = 60;		# should be 60
X$iter = 0;		# iteration count
X$cycleTime = 0;		# time for most recent poll
X
X
X#
X# These values were empiricially arrived at.  They differ markedly
X# from those used in the UNIX kernal to smooth load averages.  Those
X# values result in averages over much longer intervals than the comments
X# indicate.
X#
X# 0.00499999999999999 is the value such that when multiplied by the
X# maximum valid data value (100) produces a result less than 0.5.
X# The three values are the 5th, 15th, and 60th roots respectively.
X#
X@exp = (
X	0.3465724216,	#  5 intervals  [0.0049999999999**(1/5)]
X	0.7024218302,	# 15 intervals  [0.0049999999999**(1/15)]
X	0.9154813473,	# 60 intervals  [0.0049999999999**(1/60)]
X	
X);
X@invexp = (
X	1.0 - $exp[0],
X	1.0 - $exp[1],
X	1.0 - $exp[2],
X);
X
X#
X# Smooth a value over three intervals, depending on the value
X# of the @exp array above.  Change the averages in-place and
X# return an array of rounded values.
X#
Xsub smooth {
X	local (@tmp);
X	local ($val) = $_[3];
X	local ($i);
X
X	foreach $i (0 .. 2) {
X		$_[$i] = ($_[$i]*$exp[$i] + $invexp[$i]*$val) ;
X	}
X
X	# round to nearest whole value
X	@tmp = @_[0..2];
X	foreach (@tmp) { $_ += 0.5; }
X
X	return @tmp;
X}
X
X
X%summary = ();
X%done = ();
X
X#
X# sort things by the value associated with them in the order
X# array.  This will preserve the original order in the configuration
X# file.
X#
Xsub sortByOrder {
X	$done{$a} <=> $done{$b};
X}
X
X{
X	local ($k,$v);
X	local ($bTime, $eTime);
X	for (;;) {
X		$iter++;
X		%done = ();
X		
X		$bTime = time();
X		&getStats(*summary, *done);
X		# Delete old nodes
X		while (($k,$v) = each(%summary)) {
X			delete $summary{$k} unless defined $done{$k};
X		}
X		$eTime = time();
X		$cycleTime = $eTime - $bTime;
X		&printResults(*summary, $dataFile);
X
X		$eTime = time();
X		$cycleTime = $eTime - $bTime;
X		sleep($cycleTime >= $napTime ? $napTime : ($napTime-$cycleTime));
X	}
X}
X
Xsub getStats {
X	local (*db, *mark) = @_;
X	local (*FILE);
X	local (@j,$k,$v);
X	local ($ns,$nr,$rtt);
X	local (@avgBad,@avgRTT,@atBat,@tmp);
X
X	open(FILE, $command) || die "Can't pipe: $!";
X
X	while ($_ = <FILE>) {
X		@j = split(' ', $_);
X		$k = "$j[0]:$j[1]";
X		$ns  = $j[2];
X		$nr  = $j[3];
X		$bad = ($ns-$nr)*100/$ns;
X
X		
X		if ($v = $db{$k}) {
X			@tmp = split (':', $v);
X			@avgBad = splice(@tmp, 2, 3);
X			@avgRTT = splice(@tmp, 2, 3);
X			@atBat = splice(@tmp, 2, 2);
X		}
X		else { @avgBad = @avgRTT = (0,0,0); @atBat = (0,0); }
X
X		# if no packets were returned, putting any value in
X		# for rtt is a bit of a lie.  A zero value perturbs
X		# the long-term average.  So in this case we just
X		# copy the last average value.  In the case of a
X		# temporary disruption, the RTT average will converge
X		# toward the last valid short term average.
X		$rtt = $nr ? ($j[4] / $nr)/1000 : $avgRTT[0];
X
X		&smooth (@avgBad, $bad);
X		&smooth (@avgRTT, $rtt);
X
X		# Count how many times this system hits the reporting
X		# list
X		$atBat[0]++;
X		$atBat[1]++
X			if ($avgBad[0] >= 0.5 || $avgBad[1] >= 0.5
X				|| $avgBad[2] >= 0.5);
X		$db{$k} = join(':', $bad, $rtt, @avgBad, @avgRTT, @atBat);
X
X		# store the line number of this entry in the mark
X		# array.  This is used later in the sort procedure.
X		$mark{$k} = $.;
X	}
X	close (FILE);
X}
X
Xsub printResults {
X	local (*db, $file) = @_;
X	local ($k,$v);
X	local ($sn, $sa, $ns, $nr, $rtt);
X	local (@avgBad, @avgRTT,@atBat,@tmp);
X	local ($nskipped) = 0;
X	local (*STREAM);
X	local ($bars) = "-" x 24;
X	local ($fmt) = "%-18.18s %-15.15s %3.3s %5.5s "
X		. "%3.3s %5.5s %3.3s %5.5s %3.3s %5.5s %3.3s\n",
X
X	open (STREAM, ">$file") || die "Can't open output file '$file': $!";
X	$heading = sprintf ("%-11s %-5s %5d %-6s %3d", &myctime(time()),
X		"Iter:", $iter,
X		"Cycle:", $cycleTime);
X		"current", "avg. 5", "avg. 15", "avg. 60";
X	printf STREAM
X		"%-34s %9s %9s %9s %9s\n", $heading,
X		"current", "avg. 5", "avg. 15", "avg. 60";
X	printf STREAM $fmt, "System Name", "IP Address",
X		"bad", "RTT", "bad", "RTT", "bad", "RTT", "bad", "RTT", "RPT";
X	printf STREAM $fmt, $bars, $bars, $bars, $bars, $bars, $bars, $bars,
X		$bars, $bars, $bars, $bars;
X	foreach $k (sort sortByOrder keys(%db)) {
X		$v = $db{$k};
X		($sn, $sa) = split(":",$k);
X		($bad,$rtt,@tmp) = split (":", $v);
X		@avgBad = splice (@tmp, 0, 3);
X		@avgRTT = splice (@tmp, 0, 3);
X		@atBat = splice (@tmp, 0, 2);
X		foreach (@avgBad) { $_ += 0.5; }
X		($nskipped++,next) if ($avgBad[2] < 1);
X		printf STREAM
X		 "%-18s %-15s %3d %5.1f %3d %5.1f %3d %5.1f %3d %5.1f %3d\n", 
X			$sn, $sa, $bad, $rtt,
X			$avgBad[0], $avgRTT[0],
X			$avgBad[1], $avgRTT[1],
X			$avgBad[2], $avgRTT[2],
X			($atBat[1]*100/$atBat[0]);
X	}
X	print STREAM $nskipped, " entries skipped for all-0 error averages\n\n";
X	close (STREAM);
X}
X
XCONFIG: {
X    package myctime;
X
X    @DoW = ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
X    @MoY = ('Jan','Feb','Mar','Apr','May','Jun',
X	    'Jul','Aug','Sep','Oct','Nov','Dec');
X}
X
Xsub myctime {
X    package myctime;
X
X    local($time) = @_;
X    local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
X
X    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
X	localtime($time);
X
X    sprintf("%2d:%02d:%02d", $hour, $min, $sec);
X}
END_OF_FILE
  if test 5524 -ne `wc -c <'nocol-3.0/src/support/mping/msummary'`; then
    echo shar: \"'nocol-3.0/src/support/mping/msummary'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/support/mping/msummary'
  # end of 'nocol-3.0/src/support/mping/msummary'
fi
if test -f 'nocol-3.0/src/support/mping/t-msummary' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/support/mping/t-msummary'\"
else
  echo shar: Extracting \"'nocol-3.0/src/support/mping/t-msummary'\" \(5567 characters\)
  sed "s/^X//" >'nocol-3.0/src/support/mping/t-msummary' <<'END_OF_FILE'
X#! /usr/local/bin/perl
X
X#
X# Run ping connectivity tests.   Ping list of addresses every 60
X# seconds and keep a reachability metric for each address.  This
X# is intended to (1) help isolate problem links, and (2) give a
X# better idea of long term trends than just the immediate results
X# of the most recent test.
X#
X
X# Command to run test
X$dataFile = "msummary.out";
X$confFile = "msummary.dat";
X$command = "mping -f $confFile |";
X$napTime = 60;		# should be 60
X$iter = 0;		# iteration count
X$cycleTime = 0;		# time for most recent poll
X
X
X#
X# These values were empiricially arrived at.  They differ markedly
X# from those used in the UNIX kernal to smooth load averages.  Those
X# values result in averages over much longer intervals than the comments
X# indicate.
X#
X# 0.00499999999999999 is the value such that when multiplied by the
X# maximum valid data value (100) produces a result less than 0.5.
X# The three values are the 5th, 15th, and 60th roots respectively.
X#
X@exp = (
X	0.3465724216,	#  5 intervals  [0.0049999999999**(1/5)]
X	0.7024218302,	# 15 intervals  [0.0049999999999**(1/15)]
X	0.9154813473,	# 60 intervals  [0.0049999999999**(1/60)]
X	
X);
X@invexp = (
X	1.0 - $exp[0],
X	1.0 - $exp[1],
X	1.0 - $exp[2],
X);
X
X#
X# Smooth a value over three intervals, depending on the value
X# of the @exp array above.  Change the averages in-place and
X# return an array of rounded values.
X#
Xsub smooth {
X	local (@tmp);
X	local ($val) = $_[3];
X	local ($i);
X
X	foreach $i (0 .. 2) {
X		$_[$i] = ($_[$i]*$exp[$i] + $invexp[$i]*$val) ;
X	}
X
X	# round to nearest whole value
X	@tmp = @_[0..2];
X	foreach (@tmp) { $_ += 0.5; }
X
X	return @tmp;
X}
X
X
X%summary = ();
X%done = ();
X
X#
X# sort things by the value associated with them in the order
X# array.  This will preserve the original order in the configuration
X# file.
X#
Xsub sortByOrder {
X	$done{$a} <=> $done{$b};
X}
X
X{
X	local ($k,$v);
X	local ($bTime, $eTime);
X	for (;;) {
X		$iter++;
X		%done = ();
X		
X		$bTime = time();
X		&getStats(*summary, *done);
X		# Delete old nodes
X		while (($k,$v) = each(%summary)) {
X			delete $summary{$k} unless defined $done{$k};
X		}
X		$eTime = time();
X		$cycleTime = $eTime - $bTime;
X		&printResults(*summary, $dataFile);
X
X		$eTime = time();
X		$cycleTime = $eTime - $bTime;
X		sleep($cycleTime >= $napTime ? $napTime : ($napTime-$cycleTime));
X	}
X}
X
Xsub getStats {
X	local (*db, *mark) = @_;
X	local (*FILE);
X	local (@j,$k,$v);
X	local ($ns,$nr,$rtt);
X	local (@avgBad,@avgRTT,@atBat,@tmp);
X
X	open(FILE, $command) || die "Can't pipe: $!";
X
X	while ($_ = <FILE>) {
X		@j = split(' ', $_);
X		$k = "$j[0]:$j[1]";
X		$ns  = $j[2];
X		$nr  = $j[3];
X		$bad = ($ns-$nr)*100/$ns;
X
X		
X		if ($v = $db{$k}) {
X			@tmp = split (':', $v);
X			@avgBad = splice(@tmp, 2, 3);
X			@avgRTT = splice(@tmp, 2, 3);
X			@atBat = splice(@tmp, 2, 2);
X		}
X		else { @avgBad = @avgRTT = (0,0,0); @atBat = (0,0); }
X
X		# if no packets were returned, putting any value in
X		# for rtt is a bit of a lie.  A zero value perturbs
X		# the long-term average.  So in this case we just
X		# copy the last average value.  In the case of a
X		# temporary disruption, the RTT average will converge
X		# toward the last valid short term average.
X		$rtt = $nr ? ($j[4] / $nr)/1000 : $avgRTT[0];
X
X		&smooth (@avgBad, $bad);
X		&smooth (@avgRTT, $rtt);
X
X		# Count how many times this system hits the reporting
X		# list
X		$atBat[0]++;
X		$atBat[1]++
X			if ($avgBad[0] >= 0.5 || $avgBad[1] >= 0.5
X				|| $avgBad[2] >= 0.5);
X		$db{$k} = pack ("d10", $bad, $rtt, @avgBad, @avgRTT, @atBat);
X
X		# store the line number of this entry in the mark
X		# array.  This is used later in the sort procedure.
X		$mark{$k} = $.;
X	}
X	close (FILE);
X}
X
Xsub printResults {
X	local (*db, $file) = @_;
X	local ($k,$v);
X	local ($sn, $sa, $ns, $nr, $rtt);
X	local (@avgBad, @avgRTT,@atBat,@tmp);
X	local ($nskipped) = 0;
X	local (*STREAM);
X	local ($bars) = "-" x 24;
X	local ($fmt) = "%-18.18s %-15.15s %3.3s %5.5s "
X		. "%3.3s %5.5s %3.3s %5.5s %3.3s %5.5s %3.3s\n",
X
X	open (STREAM, ">$file") || die "Can't open output file '$file': $!";
X	$heading = sprintf ("%-11s %-5s %5d %-6s %3d", &myctime(time()),
X		"Iter:", $iter,
X		"Cycle:", $cycleTime);
X		"current", "avg. 5", "avg. 15", "avg. 60";
X	printf STREAM
X		"%-34s %9s %9s %9s %9s\n", $heading,
X		"current", "avg. 5", "avg. 15", "avg. 60";
X	printf STREAM $fmt, "System Name", "IP Address",
X		"bad", "RTT", "bad", "RTT", "bad", "RTT", "bad", "RTT", "RPT";
X	printf STREAM $fmt, $bars, $bars, $bars, $bars, $bars, $bars, $bars,
X		$bars, $bars, $bars, $bars;
X	foreach $k (sort sortByOrder keys(%db)) {
X		$v = $db{$k};
X		($sn, $sa) = split(":",$k);
X		($bad,$rtt,@tmp) = unpack ("d10", $v);
X		@avgBad = splice (@tmp, 0, 3);
X		@avgRTT = splice (@tmp, 0, 3);
X		@atBat = splice (@tmp, 0, 2);
X		foreach (@avgBad) { $_ += 0.5; }
X		($nskipped++,next)
X			if $avgBad[0] < 1 && $avgBad[1] < 1 && $avgBad[2] < 1;
X		printf STREAM
X		 "%-18s %-15s %3d %5.1f %3d %5.1f %3d %5.1f %3d %5.1f %3d\n", 
X			$sn, $sa, $bad, $rtt,
X			$avgBad[0], $avgRTT[0],
X			$avgBad[1], $avgRTT[1],
X			$avgBad[2], $avgRTT[2],
X			($atBat[1]*100/$atBat[0]);
X	}
X	print STREAM $nskipped, " entries skipped for all-0 error averages\n\n";
X	close (STREAM);
X}
X
XCONFIG: {
X    package myctime;
X
X    @DoW = ('Sun','Mon','Tue','Wed','Thu','Fri','Sat');
X    @MoY = ('Jan','Feb','Mar','Apr','May','Jun',
X	    'Jul','Aug','Sep','Oct','Nov','Dec');
X}
X
Xsub myctime {
X    package myctime;
X
X    local($time) = @_;
X    local($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst);
X
X    ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) =
X	localtime($time);
X
X    sprintf("%2d:%02d:%02d", $hour, $min, $sec);
X}
END_OF_FILE
  if test 5567 -ne `wc -c <'nocol-3.0/src/support/mping/t-msummary'`; then
    echo shar: \"'nocol-3.0/src/support/mping/t-msummary'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/support/mping/t-msummary'
  # end of 'nocol-3.0/src/support/mping/t-msummary'
fi
echo shar: End of archive 22 \(of 26\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
