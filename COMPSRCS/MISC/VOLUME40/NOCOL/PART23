Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i153:  nocol - Network Monitoring System, Part23/26
Message-ID: <1993Nov24.163854.1993@sparky.sterling.com>
X-Md4-Signature: 4c645ee2b5fcb78588c3a1b628328e80
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 24 Nov 1993 16:38:54 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 153
Archive-name: nocol/part23
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/cmu-snmp/README
#   nocol-3.0/src/cmu-snmp/apps/snmpd.c
#   nocol-3.0/src/cmu-snmp/apps/snmpget.c
#   nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c
#   nocol-3.0/src/cmu-snmp/man/snmpstatus.1
#   nocol-3.0/src/cmu-snmp/man/snmptest.1
#   nocol-3.0/src/cmu-snmp/man/snmptrap.1
#   nocol-3.0/src/doc/perlnocol.3 nocol-3.0/src/doc/trapmon.8
#   nocol-3.0/src/include/nocol.h nocol-3.0/src/include/trapmon.h
#   nocol-3.0/src/lib/standalone.c nocol-3.0/src/netmon/fill_window.c
#   nocol-3.0/src/netmon/parse_input.c
#   nocol-3.0/src/netmon/read_filter.c nocol-3.0/src/perlnocol/bgpmon
#   nocol-3.0/src/tpmon/tptest.c
# Wrapped by kent@sparky on Tue Nov  9 22:22:26 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 23 (of 26)."'
if test -f 'nocol-3.0/src/cmu-snmp/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/README'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/README'\" \(4489 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/README' <<'END_OF_FILE'
X
X  The files in this directory compromise the 1.0 release of the CMU SNMP
Xdistribution.  This includes the SNMP/ASN.1 library, many client
Xapplications, and supporting documentation.  The snmp agent for the Kinetics
Xbox is included in this distribution, but the KIP code it links against is not
Xyet distributable (this is not the released KIP code).  This will probably
Xbe distributed at another time if there is sufficient demand.
X
XThis code was written with efficiency and portability in mind.  The
Xapplications compile and run on the following systems: IBM PC/RT running ACIS
XRelease 3, Sun3/60 running SUNOS 3.5, DEC microVax running Ultrix 2.2, and
XDECStation 3100's runing Ultrix 3.0.  They are expected to run on any system
Xwith a Berkeley socket interface.
X
XThe agent compiles into about 10 KB of 68000 code.  The machine independent
Xportions of this agent also run on CMU's IBM PC/AT based router.
X
XThe applications are designed to be useful in the real world.  Snmpnetstat
Xis a port of the Berkeley Unix netstat that gathers it's information using
XSNMP.  (Many people will enjoy "snmpnetstat mygateway public -r").  Snmpstatus
Xcollects several pieces of information and presents them in a useful format
Xand is good for everyday status monitoring.  The rest of the tools are simpler,
Xbut still interpret input and output symbolicly (they can be used without
Xreferencing the RFC's!).
X
XFor instance, 
Xsnmpnetstat mygateway public -r returns:
XRouting tables
XDestination      Gateway            Flags   Interface
Xbbn-net-temp     psc-gw3.psc.edu    UG      Ethernet0
Xarpanet          prpnet-gw.cc.cmu.e UG      Ethernet0
Xxerox-net        psc-gw3.psc.edu    UG      Ethernet0
Xhp-internet      psc-gw3.psc.edu    UG      Ethernet0
X...
X
Xsnmpstatus returns:
X[128.2.56.220]=>[Kinetics Fastpath2] Up: 1 day, 4:43:31
XRecv/Trans packets - Interface: 262874/39867 | IP 47432/34587
X
XThe rest of the applications typically present a variable in a form similar
Xto the following:
XName: interfaces.ifTable.ifEntry.ifType.1
XINTEGER: ethernet-csmacd(6)
X
XThe parsing and printing of symbolic object identifiers and the printing of
Xtyped variables is driven by a database that describes the MIB.
XThe MIB database is now retrieved from a text file in the ASN.1 format used in
Xthe RFC1066 MIB.  This makes adding new (enterprise specific) mibs to the database
Xvery simple.  I will solicit description files from other SNMP vendors and redistribute
Xthem via anonymous FTP.  Initially, the mib.txt file contains a discription of the
XRFC 1066 MIB and portions of the CMU enterprise specific MIB.  I had help in optimizing
Xthe parser from Phil Lapsley of Berkeley (Thanks Phil!).
X
XFor further information, please consult the man pages.  There are man pages for
Xeach of the applications, as well as for the Application Programming Interface (API).
X
XThe API has been redesigned to present a very convenient and useful asynchronous
Xinterface to the SNMP transport.  In addition, snmp_client.c contains a toolkit
Xof routines that simplify writing client applications.  In particular, there is
Xa synchronous interface built on top of the asyncronous interface that makes
Xwriting applications very easy.
X
XThis distribution is coprighted by CMU, but may be used and sold without
Xpermission.  The snmpnetstat application is derived from the Berkeley 4.3 netstat,
Xand is therefore also copyrighted by Berkeley.  Consult the copyright notices for
Xfurther information.
X
XThe distribution is available by anonymous FTP from the host
Xlancaster.andrew.cmu.edu (128.2.13.21) as the file pub/cmu-snmp1.0.tar.  I will
Xmaintain a repository of mib description files in the directory pub/mibs.
X
XPlease direct questions, comments, and bug reports to sw0l+snmp@andrew.cmu.edu.
XI have received very helpful feedback in the past that has been integrated into 
Xthe current release.  This wil continue in the future.
X
XIf you pick up this package, please send me a note to the above address, so
Xthat I may notify you of future enhancements/changes and additions to the
Xset of applications (several are planned).  I will also redistribute applications
Xusing the CMU SNMP library that were written elsewhere and placed in the public domain.
XThere are already several such applications pending such a distribution.
X
XThere is a gateway at CMU running the agent.  Feel free to query it.  You
Xcan access as netdev-kbox.cc.cmu.edu (128.2.56.220) with community name
X"public".
X
X
XSteve Waldbusser
XNetwork Development
XCarnegie-Mellon University
END_OF_FILE
  if test 4489 -ne `wc -c <'nocol-3.0/src/cmu-snmp/README'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/README'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/README'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpd.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpd.c'\" \(3738 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpd.c' <<'END_OF_FILE'
X/*
X * snmpd.c - send snmp GET requests to a network entity.
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X#include <sys/socket.h>
X#include <errno.h>
X
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "asn1.h"
X
Xextern int  errno;
Xint	snmp_dump_packet = 0;
X
Xmain(argc, argv)
X    int	    argc;
X    char    *argv[];
X{
X    int	arg;
X    int sd;
X    struct sockaddr_in	me;
X
X
X    /*
X     * usage: snmpd
X     */
X    for(arg = 1; arg < argc; arg++){
X	if (argv[arg][0] == '-'){
X	    switch(argv[arg][1]){
X		case 'd':
X		    snmp_dump_packet++;
X		    break;
X		default:
X		    printf("invalid option: -%c\n", argv[arg][1]);
X		    break;
X	    }
X	    continue;
X	}
X    }
X    /* Set up connections */
X    sd = socket(AF_INET, SOCK_DGRAM, 0);
X    if (sd < 0){
X	perror("socket");
X	return 0;
X    }
X    me.sin_family = AF_INET;
X    me.sin_addr.s_addr = INADDR_ANY;
X    me.sin_port = htons(SNMP_PORT);
X    if (bind(sd, (struct sockaddr *)&me, sizeof(me)) != 0){
X	perror("bind");
X	return 0;
X    }
X    init_snmp();
X    receive(sd);
X}
X
Xreceive(sd)
X    int sd;
X{
X    int numfds;
X    fd_set fdset;
X    int count;
X
X    while(1){
X	numfds = 0;
X	FD_ZERO(&fdset);
X	numfds = sd + 1;
X	FD_SET(sd, &fdset);
X	count = select(numfds, &fdset, 0, 0, 0);
X	if (count > 0){
X	    if(FD_ISSET(sd, &fdset))
X		snmp_read(sd);
X	} else switch(count){
X	    case 0:
X		break;
X	    case -1:
X		if (errno == EINTR){
X		    continue;
X		} else {
X		    perror("select");
X		}
X		return -1;
X	    default:
X		printf("select returned %d\n", count);
X		return -1;
X	}
X    }
X}
X
Xsnmp_read(sd)
X    int sd;
X{
X    struct sockaddr_in	from;
X    int length, out_length, fromlength;
X    u_char  packet[1500], outpacket[1500];
X
X    fromlength = sizeof from;
X    length = recvfrom(sd, packet, 1500, 0, (struct sockaddr *)&from, &fromlength);
X    if (length == -1)
X	perror("recvfrom");
X    if (snmp_dump_packet){
X	int count;
X
X	printf("recieved %d bytes from %s:\n", length, inet_ntoa(from.sin_addr));
X	for(count = 0; count < length; count++){
X	    printf("%02X ", packet[count]);
X	    if ((count % 16) == 15)
X		printf("\n");
X	}
X	printf("\n\n");
X    }
X    out_length = 1500;
X    if (snmp_agent_parse(packet, length, outpacket, &out_length, from.sin_addr)){
X	if (snmp_dump_packet){
X	    int count;
X
X	    printf("sent %d bytes to %s:\n", out_length, inet_ntoa(from.sin_addr));
X	    for(count = 0; count < out_length; count++){
X		printf("%02X ", outpacket[count]);
X		if ((count % 16) == 15)
X		    printf("\n");
X	    }
X	    printf("\n\n");
X	}
X	if (sendto(sd, (char *)outpacket, out_length, 0, (struct sockaddr *)&from,
X	    sizeof(from)) < 0){
X		perror("sendto");
X		return 0;
X	}
X
X    }
X    
X}
X
END_OF_FILE
  if test 3738 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpd.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpd.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpd.c'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpget.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpget.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpget.c'\" \(4136 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpget.c' <<'END_OF_FILE'
X/*
X * snmpget.c - send snmp GET requests to a network entity.
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "asn1.h"
X#include "snmp_api.h"
X#include "snmp_client.h"
X
Xextern int  errno;
Xint	snmp_dump_packet = 0;
X
Xmain(argc, argv)
X    int	    argc;
X    char    *argv[];
X{
X    struct snmp_session session, *ss;
X    struct snmp_pdu *pdu, *response;
X    struct variable_list *vars;
X    int	arg;
X    char *gateway = NULL;
X    char *community = NULL;
X    int	count, current_name = 0;
X    char *names[128];
X    oid name[MAX_NAME_LEN];
X    int name_length;
X    int status;
X
X    init_mib();
X    /*
X     * usage: snmpget gateway-name community-name
X     */
X    for(arg = 1; arg < argc; arg++){
X	if (argv[arg][0] == '-'){
X	    switch(argv[arg][1]){
X		case 'd':
X		    snmp_dump_packet++;
X		    break;
X		default:
X		    printf("invalid option: -%c\n", argv[arg][1]);
X		    break;
X	    }
X	    continue;
X	}
X	if (gateway == NULL){
X	    gateway = argv[arg];
X	} else if (community == NULL){
X	    community = argv[arg]; 
X	} else {
X	    names[current_name++] = argv[arg];
X	}
X    }
X
X    if (!(gateway && community && current_name > 0)){
X	printf("usage: snmpget gateway-name community-name object-identifier [object-identifier ...]\n");
X	exit(1);
X    }
X
X    bzero((char *)&session, sizeof(struct snmp_session));
X    session.peername = gateway;
X    session.community = (u_char *)community;
X    session.community_len = strlen((char *)community);
X    session.retries = SNMP_DEFAULT_RETRIES;
X    session.timeout = SNMP_DEFAULT_TIMEOUT;
X    session.authenticator = NULL;
X    snmp_synch_setup(&session);
X    ss = snmp_open(&session);
X    if (ss == NULL){
X	printf("Couldn't open snmp\n");
X	exit(-1);
X    }
X
X    pdu = snmp_pdu_create(GET_REQ_MSG);
X
X    for(count = 0; count < current_name; count++){
X	name_length = MAX_NAME_LEN;
X	if (!read_objid(names[count], name, &name_length)){
X	    printf("Invalid object identifier: %s\n", names[count]);
X	}
X	
X	snmp_add_null_var(pdu, name, name_length);
X    }
X
Xretry:
X    status = snmp_synch_response(ss, pdu, &response);
X    if (status == STAT_SUCCESS){
X	if (response->errstat == SNMP_ERR_NOERROR){
X	    for(vars = response->variables; vars; vars = vars->next_variable)
X		print_variable(vars->name, vars->name_length, vars);
X	} else {
X	    printf("Error in packet.\nReason: %s\n", snmp_errstring(response->errstat));
X	    if (response->errstat == SNMP_ERR_NOSUCHNAME){
X		printf("This name doesn't exist: ");
X		for(count = 1, vars = response->variables; vars && count != response->errindex;
X		    vars = vars->next_variable, count++)
X			;
X		if (vars)
X		    print_objid(vars->name, vars->name_length);
X		printf("\n");
X	    }
X	    if ((pdu = snmp_fix_pdu(response, GET_REQ_MSG)) != NULL)
X		goto retry;
X	}
X
X    } else if (status == STAT_TIMEOUT){
X	printf("No Response from %s\n", gateway);
X    } else {    /* status == STAT_ERROR */
X	printf("An error occurred, Quitting\n");
X    }
X
X    if (response)
X	snmp_free_pdu(response);
X    snmp_close(ss);
X}
X
END_OF_FILE
  if test 4136 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpget.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpget.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpget.c'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c'\" \(4218 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c' <<'END_OF_FILE'
X/*
X * snmpgetnext.c - send snmp GETNEXT requests to a network entity.
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "asn1.h"
X#include "snmp_api.h"
X#include "snmp_client.h"
X
Xextern int  errno;
Xint	snmp_dump_packet = 0;
X
Xmain(argc, argv)
X    int	    argc;
X    char    *argv[];
X{
X    struct snmp_session session, *ss;
X    struct snmp_pdu *pdu, *response;
X    struct variable_list *vars;
X    int	arg;
X    char *gateway = NULL;
X    char *community = NULL;
X    int	count, current_name = 0;
X    char *names[128];
X    oid name[MAX_NAME_LEN];
X    int name_length;
X    int status;
X
X    init_mib();
X    /*
X     * usage: snmpgetnext gateway-name community-name object-id-list
X     */
X    for(arg = 1; arg < argc; arg++){
X	if (argv[arg][0] == '-'){
X	    switch(argv[arg][1]){
X		case 'd':
X		    snmp_dump_packet++;
X		    break;
X		default:
X		    printf("invalid option: -%c\n", argv[arg][1]);
X		    break;
X	    }
X	    continue;
X	}
X	if (gateway == NULL){
X	    gateway = argv[arg];
X	} else if (community == NULL){
X	    community = argv[arg]; 
X	} else {
X	    names[current_name++] = argv[arg];
X	}
X    }
X
X    if (!(gateway && community && current_name > 0)){
X	printf("usage: snmpgetnext gateway-name community-name object-identifier [object-identifier ...]\n");
X	exit(1);
X    }
X
X    bzero((char *)&session, sizeof(struct snmp_session));
X    session.peername = gateway;
X    session.community = (u_char *)community;
X    session.community_len = strlen((char *)community);
X    session.retries = SNMP_DEFAULT_RETRIES;
X    session.timeout = SNMP_DEFAULT_TIMEOUT;
X    session.authenticator = NULL;
X    snmp_synch_setup(&session);
X    ss = snmp_open(&session);
X    if (ss == NULL){
X	printf("Couldn't open snmp\n");
X	exit(-1);
X    }
X
X    pdu = snmp_pdu_create(GETNEXT_REQ_MSG);
X
X    for(count = 0; count < current_name; count++){
X	name_length = MAX_NAME_LEN;
X	if (!read_objid(names[count], name, &name_length)){
X	    printf("Invalid object identifier: %s\n", names[count]);
X	}
X	
X	snmp_add_null_var(pdu, name, name_length);
X    }
X
X    status = snmp_synch_response(ss, pdu, &response);
X    if (status == STAT_SUCCESS){
X	if (response->errstat == SNMP_ERR_NOERROR){
X	    for(vars = response->variables; vars; vars = vars->next_variable)
X		print_variable(vars->name, vars->name_length, vars);
X	} else {
X	    if (response->errstat == SNMP_ERR_NOSUCHNAME){
X		printf("You have reached the end of the MIB.\n");
X	    } else {
X		printf("Error in packet.\nReason: %s\n", snmp_errstring(response->errstat));
X		if (response->errstat == SNMP_ERR_NOSUCHNAME){
X		    printf("This name doesn't exist: ");
X		    for(count = 1, vars = response->variables; vars && count != response->errindex;
X			vars = vars->next_variable, count++)
X			    ;
X		    if (vars)
X			print_objid(vars->name, vars->name_length);
X		    printf("\n");
X		}
X	    }
X	}
X
X    } else if (status == STAT_TIMEOUT){
X	printf("No Response from %s\n", gateway);
X    } else {    /* status == STAT_ERROR */
X	printf("An error occurred, Quitting\n");
X    }
X
X    if (response)
X	snmp_free_pdu(response);
X    snmp_close(ss);
X}
X
END_OF_FILE
  if test 4218 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpgetnext.c'
fi
if test -f 'nocol-3.0/src/cmu-snmp/man/snmpstatus.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/man/snmpstatus.1'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/man/snmpstatus.1'\" \(3422 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/man/snmpstatus.1' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1988, 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMPSTATUS 1 "17 September 1989"
X.UC 4
X.SH NAME
Xsnmpstatus - Retrieves important information from a network entity.
X.SH SYNOPSIS
Xsnmpstatus host [community]
X.SH DESCRIPTION
XSnmpstatus is an SNMP application that retrieves several important
Xstatistics from a network entity.
X.PP
XThe
X.I host
Xspecification may be either a host name or an internet address
Xspecified in "dot notation"
X.PP
XThe
X.I community
Xspecifies the community name for the transaction with the remote system.
XIf this argument is not given, the community name will default to
X.I "public".
X.PP
XThe information returned is:
X.PP
XThe IP address of the entity.
X.br
XA textual description of the entity
X.I (sysDescr.0)
X.br
XThe uptime of the entity
X.I (sysUpTime.0)
X.br
XThe sum of received packets on all interfaces
X.I (ifInUCastPkts.* + ifInNUCastPkts.*)
X.br
XThe sum of transmitted packets on all interfaces
X.I (ifOutUCastPkts.* + ifOutNUCastPkts.*)
X.br
XThe number of IP input packets
X.I (ipInReceives.0)
X.br
XThe number of IP output packets
X.I (ipOutRequests.0)
X.PP
XFor example
X.PP
X.I snmpstatus netdev-kbox.cc.cmu.edu public
X.PP
Xwill produce output similar to the following:
X.PP
X.I [128.2.56.220]=>[Kinetics FastPath2] Up: 1 day, 4:43:31
X.br
X.I IF recv/trans packets 262874/39867 |
X.I IP recv/trans packets 31603/15805
X.PP
XSnmpstatus also checks the operational status of all interfaces (ifOperStatus.*),
Xand if it finds any that are not running, it will report in a manner similar to this:
X.PP
X.I 2 interfaces are down!
XThe
X.I host
Xspecification may be either a host name or an internet address
Xspecified in "dot notation"
X.PP
XThe
X.I community
Xspecifies the community name for the transaction with the remote system.  If none is
Xgiven, the community name defaults to
X.I "public".
X.PP
XIf the network entity has an error processing the request packet, an error
Xpacket will be returned and a message will be shown, helping to pinpoint in what way
Xthe request was malformed.  Snmpstatus will attempt to reform it's request to eliminate
Xthe malformed variable, but this variable will then be missing from the displayed data.
X.PP
XAdding a "-d" to the argument list will cause the application to dump input and output packets.
X.PP
X.SH "SEE ALSO"
XRFC 1065, RFC 1066, RFC 1067
END_OF_FILE
  if test 3422 -ne `wc -c <'nocol-3.0/src/cmu-snmp/man/snmpstatus.1'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/man/snmpstatus.1'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/man/snmpstatus.1'
fi
if test -f 'nocol-3.0/src/cmu-snmp/man/snmptest.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/man/snmptest.1'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/man/snmptest.1'\" \(3555 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/man/snmptest.1' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1988, 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMPTEST 1 "17 September 1989"
X.UC 4
X.SH NAME
Xsnmptest - communicates with a network entity using SNMP GET Requests.
X.SH SYNOPSIS
Xsnmptest host community
X.SH DESCRIPTION
XSnmptest is a flexible SNMP application that can monitor and manage
Xinformation on a network entity.
X.PP
XThe
X.I host
Xspecification may be either a host name or an internet address
Xspecified in "dot notation"
X.PP
XThe
X.I community
Xspecifies the community name for the transaction with the remote system.
X.PP
XAfter invoking the program, a command line
Xinterpreter proceeds to accept commands.  It will prompt with:
X.PP
X.I Please enter the variable name:
X.PP
XAt this point you can enter one or more variable names, one per line.
XA blank line is a command to send a request for each of the variables (in a single
Xpacket) to the remote entity. Each variable name is given in the format specified in
X.IR variables (5).
XFor example
X.PP
X.I snmpget netdev-kbox.cc.cmu.edu public
X.br
X.I Please enter the variable name: system.sysdescr.0
X.br
X.I Please enter the variable name: 
X.PP
XWill return some information about the request and reply packets, as well as the
Xinformation:
X.PP
X.I Name: system.sysDescr.0
X.br
X.I OCTET STRING- (ascii):	Kinetics FastPath2
X.PP
XUpon startup, the program defaults to sending a GET Request packet.  This can be changed
Xto a GET NEXT Request or a SET Request by typing the commands "$N" or "$S" repectively.  Typing
X"$G" will go back to the GET Request mode.
X.PP
XThe command "$D" will toggle the dumping of each sent and received packet.
X.PP
XWhen in the "SET Request" mode, more information is requested by the prompt for each variable.  The prompt:
X.PP
X.I Please enter variable type [i|s|n]: 
X.PP
Xrequests the type of the variable be entered.  Type "i" for an integer, "s" for an octet string,
Xand "n" for a null value.
X.br
XAt this point a value will be prompted for:
X.PP
X.I Please enter new value: 
X.PP
XIf this is an integer value, just type the integer (in decimal).  If it is a string, type in
Xwhite-space seperated decimal numbers, one per byte of the string.  Again type a blank line at
Xthe prompt for the variable name to send the packet.
X.PP
XAt the variable name line, typing "$Q" will quit the program.
X.PP
XAdding a "-d" to the argument list will cause the application to dump input and output packets.
X.PP
X.SH "SEE ALSO"
Xvariables(5), RFC 1065, RFC 1066, RFC 1067
END_OF_FILE
  if test 3555 -ne `wc -c <'nocol-3.0/src/cmu-snmp/man/snmptest.1'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/man/snmptest.1'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/man/snmptest.1'
fi
if test -f 'nocol-3.0/src/cmu-snmp/man/snmptrap.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/man/snmptrap.1'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/man/snmptrap.1'\" \(3877 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/man/snmptrap.1' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1988, 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMPTRAP 1 "17 September 1989"
X.UC 4
X.SH NAME
Xsnmptrap - Send an SNMP TRAP message to a host.
X.SH SYNOPSIS
Xsnmptrap host community trap-type specific-type device-description [ -a agent-addr ]
X.SH DESCRIPTION
Xsnmptrap is an SNMP application that forms and sends an SNMP TRAP message to
Xa host.
X.PP
XThe
X.I host
Xspecification may be either a host name or an internet address
Xspecified in "dot notation"
X.PP
XThe
X.I community
Xspecifies the community name for the transaction with the remote system.
X.PP
XThe
X.I trap-type
Xand
X.I specific-type
Xare integers that specify the type of trap message being sent.
X.PP
XThe
X.I device-description
Xis a textual description of the device sending this trap, to be used as the value of
Xa system.sysDescr.0 variable sent in the variable list of this trap message.
XThe optional argument
X.I -a agent-addr
Xcan be used to change the address from which the trap reports it is being sent.  Otherwise
Xthe sending host's address is used.
X.PP
XFor example
X.PP
X.I snmptrap nic.andrew.cmu.edu public 0 0
X.I 'SUN 3/60: SUNOS4.0'
X.PP
Xwill send a Cold Start trap to the specified machine.
X.PP
XThe defined trap types are:
X.TP
X.B 0
XcoldStart \- signifies that the sending protocol entity is
Xreinitializing itself such that the agent's configuration or the
Xprotocol entity implementation may be altered.
X.TP
X.B 1
XwarmStart \- signifies that the sending protocol entity is
Xreinitializing itself such that neither the agent configuration nor
Xthe protocol entity implementation is altered.
X.TP
X.B 2
XlinkDown \- signifies that the sending protocol entity
Xrecognizes a failure in one of the communication links represented in
Xthe agent's configuration.
X.TP
X.B 3
XlinkUp \- signifies that the sending protocol entity
Xrecognizes that one of the communication links represented in the
Xagent's configuration has come up.
X.TP
X.B 4
XauthenticationFailure \- signifies that the sending protocol
Xentity is the addressee of a protocol message that is not properly
Xauthenticated.  While implementations of the SNMP must be capable of
Xgenerating this trap, they must also be capable of suppressing the
Xemission of such traps via an implementation-specific mechanism.
X.TP
X.B 5
XegpNeighborLoss \- signifies that an EGP neighbor for whom
Xthe sending protocol entity was an EGP peer has been marked down and
Xthe peer relationship no longer obtains.
X.TP
X.B 6
XenterpriseSpecific \- signifies that the sending protocol
Xentity recognizes that some enterprise-specific event has occurred.
XThe specific-trap field identifies the particular trap which
Xoccurred.
X.PP
XAdding a "-d" to the argument list will cause the application to dump the output packet.
X.PP
X.SH "SEE ALSO"
XRFC 1065, RFC 1066, RFC 1067
END_OF_FILE
  if test 3877 -ne `wc -c <'nocol-3.0/src/cmu-snmp/man/snmptrap.1'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/man/snmptrap.1'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/man/snmptrap.1'
fi
if test -f 'nocol-3.0/src/doc/perlnocol.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/doc/perlnocol.3'\"
else
  echo shar: Extracting \"'nocol-3.0/src/doc/perlnocol.3'\" \(4164 characters\)
  sed "s/^X//" >'nocol-3.0/src/doc/perlnocol.3' <<'END_OF_FILE'
X.\" $Header: /home/aggarwal/lsrc/nocol/src/doc/RCS/perlnocol.3,v 1.1 1993/10/28 16:38:03 aggarwal Exp $
X.\"
X.TH PERLNOCOL 3 "Oct 1, 1993"
X.SH NAME
Xperlnocol \- PERL interface to NOCOL
X.SH SYNOPSIS
X.I nocollib.pl
Xis a library of useful PERL routines to facilitate writing PERL monitoring
Xscripts for NOCOL.
X.\"
X.SH DESCRIPTION
X.LP
XThere is a collection of useful 
X.I perl
Xsubroutines in the file
X.I nocollib.pl
Xwhich can be used to write new NOCOL monitors in the perl language.
XSome samples are provided with the distribution (monitors for Novell,
XAppletalk, modem-lines from a Cisco router). Use these as examples to
Xcreate new monitors.
X
XThe PERL interface can be used to parse the output of any Unix program
X(or command) and create NOCOL format data files. The program 
X.B rcisco
Xcan be used to log into a cisco router and run a command on it. The
Xappletalk
X.I armon
Xmonitor runs the command "show apple route" and then parses the output
Xto detect unregistered and missing routes.
X.LP
XThe 
X.I nocollib.pl
Xinterface relies on a list of associative arrays (one for
Xeach field on the nocol EVENT structure\-
X.I $sender, $siteaddr, $varname, etc.
X) which are global in the
Xmain routines. Given an 'index' into this set of arrays, they
Xwork on all these arrays as a set (packing, unpacking, updating, etc.).
XThe index is controlled by the 
X.I main
Xof the programs and is typically an element of the list 
X.IR @items .
X.RS
X.IP &standalone
Xkills any currently running process and writes its new pid to a pidfile.
X.IP &init_event
Xtakes an index and fills in startup default values for each of the
Xassociative arrays mentioned above. It uses the 
X.I $varunits, $varname
Xvalues initially set in the monitor.
X.IP &update_event
Xtakes an index, status (up/down), value and severity as arguments.
XIt then updates the associative arrays (changes the severity, loglevel
Xand logs to
X.IR noclogd )
Xbased on the level change.
X.IP &writeevent
XThis routine takes an index and packs the associative arrays into
Xa nocol packed structure. It then writes this structure out to 
Xthe output file.
X.RE
X.LP
XThe monitors are structured as follows:
X.RS
X.IP -
XInitialize the variables such as program to be run, directories, etc.
X.IP -
XCreate a subroutine\-
X.B readconf
Xto read a configuration file and create a list of items to monitor.
X.IP -
XCreate a subroutine\-
X.B dotest
Xto do the test. The results of the test can be returned immediately
Xto the main calling routine (for individual tests) or else pushed into
Xa list (if extracting multiple parameters in a single run).
X.IP -
XCreate a 
X.I main
Xroutine which calls the above sub-routines, calls \fIinit_event\fR and then
Xwrites out the datafile using \fIwriteevent\fR.
X.RE
X.LP
XNote that the status of the items being monitored are stored and tracked
Xby the perl monitors (and not read from the data-file in each pass as some
Xother C monitors
Xdo). The monitors simply overwrite the datafile each time (each pass).
X.\"
X.SH INSTALLATION
X.LP
X.IP -
XEdit the variables at the top of the file \-
X.B nocollib.pl
Xwhere indicated (more importantly, set
X.I $nocolroot, $NLOG_HOST
Xat the minimum).
X.IP -
XUse the existing samples (
X.I armon, modemmon, novellmon
X) to create new monitors.
X.IP -
XYou might need to tweak the
X.I $event_t
Xtemplate and change the null padding for the packed
X.I $event
Xstructure (see CAVEATS below).
X.IP -
XSome of the monitoring agents use 
X.B rcisco
Xto log into a remote host and run a command. Edit this program and put
Xyour router's password in this file. Then install this with mode 750.
X.LP
XThe PERL package is available from most popular archives on the Internet (
X.I ftp.uu.net ftp.netlabs.com
X).
X.\"
X.SH CAVEATS
X.I C 
Xcompilers tend to align structure fields on even byte boundaries. In
Xpacking a structure in PERL, the fields might not align evenly and
Xnull byte(s) padding might be necessary in the
X.I $event_t
Xtemplate.
X.SH AUTHOR
X.nf
XJim Wobus, Syracuse University (jmwobus@mailbox.syr.edu).
XVikas Aggarwal, JvNCnet, (vikas@jvnc.net).
X.fi
X.SH SEE ALSO
Xnnocol(1) nocol-prog(3) perlnocol(3)
Xeventselect(8) genmon(8) noclogd(8) nocol-overview(8)
Xnocol-utility(8) nsmon(8) pingmon(8) portmon(8) 
Xtpmon(8) trapmon(8)
X
END_OF_FILE
  if test 4164 -ne `wc -c <'nocol-3.0/src/doc/perlnocol.3'`; then
    echo shar: \"'nocol-3.0/src/doc/perlnocol.3'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/doc/perlnocol.3'
fi
if test -f 'nocol-3.0/src/doc/trapmon.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/doc/trapmon.8'\"
else
  echo shar: Extracting \"'nocol-3.0/src/doc/trapmon.8'\" \(2721 characters\)
  sed "s/^X//" >'nocol-3.0/src/doc/trapmon.8' <<'END_OF_FILE'
X.\" $Header: /home/aggarwal/lsrc/nocol/src/doc/RCS/trapmon.8,v 1.7 1993/10/28 16:38:03 aggarwal Exp $
X.\"
X.TH TRAPMON 8 "June 10, 1992"
X.SH NAME
X.B trapmon
X\- inform
X.BR nocol (1)
Xof outstanding SNMP trap messages
X.SH USAGE
X.B trapmon [\-v] [\-p] [\-n] [\-l]
X.TP
X.B \-p
XPrint a one-line summary to stderr for each trap received.
X.TP
X.B \-n
XSend output to a file formatted so that
X.BR nocol (1)
Xcan read and display it.
XOne EVENT structure is written for each trap that
X.B trapmon
Xreceives.
X.TP
X.B \-l
XSend a one-line summary to the
X.BR syslogd (8)
Xfacility, using the same format as the \-p switch.
X.TP
X.B \-v
XSend various debugging output to stdout.  It is unlikely that
Xthis switch will be of any real use, except in tracking down bugs.
X.LP
XMultiple options may be specified.
X.B trapmon
X\-pn is equivalent to
X.B trapmon
X\-n \-p.
X.SH DESCRIPTION
X.LP
X.B trapmon
Xwas developed specifically for use with the JvNCnet
X.BR nocol (1)
Xsystem- the \-n switch enables reporting designed for
Xprocessing by
X.B nocol.
X.B trapmon
Xprocesses traps asynchronously using
X.BR select (2).
XAs each trap is received, the user is notified
Xon stderr, through
X.B syslogd,
Xor through
X.BR nocol .
XWith the \-n option, an EVENT structure is appended
Xto the output file for each trap, and then
Xis deleted when 30 minutes later.
XThis timeout feature ensures that information
Xabout the traps will not grow without limit and
Xoverwhelm
X.B nocol
Xand the user.
X.LP
X.B trapmon
Xbinds to the SNMP port, so it must be executed by the superuser.
X.LP
XFor facilitating 
X.I enterprise
Xspecific traps, trapmon appends the value in the 
X.I specific_type
Xfield of the trap packet to the word 'Enterprise' in the 
X.I variable 
Xfield of the EVENT structure for NOCOL.
X.SH CAVEATS
X.LP
XIf the output file for
X.B nocol
Xis on NFS, then 
X.B trapmon
Xwill not be able to create the output file unless it is in a world-writable
Xdirectory.  This is because NFS will not honor superuser privileges on the
Xremote filesystem where the directory exists. 
X\fI Thus, the output file must exist on the local machine and not on
Xan NFS mounted partition.\fR
X
XThe 
X.I enterprise
Xspecific traps are not converted into text- only the number representing the
X.I specific_type
X(from the RFC trap PDU specification) is displayed.
X.SH AUTHOR
XDavid Wagner, wagner@jvnc.net, June 10 1992
X.LP
X.B trapmon
Xis derived from snmptrapd, a similar program without
X.B nocol
Xsupport that was written by Carnegie Mellon University, and is part of the
XCMU snmp distribution available via
X.I anonymous
Xftp.
X.SH SEE ALSO
Xnocol(1) nocol-prog(3) perlnocol(3)
Xeventselect(8) genmon(8) noclogd(8) nocol-overview(8)
Xnocol-utility(8) nsmon(8) pingmon(8) portmon(8) 
Xtpmon(8) trapmon(8)
XRFC 1065, RFC 1066, RFC 1067
END_OF_FILE
  if test 2721 -ne `wc -c <'nocol-3.0/src/doc/trapmon.8'`; then
    echo shar: \"'nocol-3.0/src/doc/trapmon.8'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/doc/trapmon.8'
fi
if test -f 'nocol-3.0/src/include/nocol.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/include/nocol.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/include/nocol.h'\" \(3694 characters\)
  sed "s/^X//" >'nocol-3.0/src/include/nocol.h' <<'END_OF_FILE'
X/*	$Header: /home/aggarwal/lsrc/nocol/src/include/RCS/nocol.h,v 1.13 1993/10/30 03:02:20 aggarwal Exp $	*/
X
X/* Copyright 1992 JvNCnet, Princeton */
X
X/*************************/
X/* 	NOCOL.H          /
X/***********************/
X
X#ifndef __nocol_h
X# define __nocol_h
X
X/* need these include files for inet routines */
X#include <sys/types.h>
X#include <stdio.h>
X#include <errno.h>			/* doesn't define sys_errlist */
X#ifdef NeXT
X#  include <sys/malloc.h>
X#else
X#  include <malloc.h>
X#  include <unistd.h>                             /* for access(), lseek()  */
X#endif	/* NeXT */
X#include <time.h>
X#include <sys/time.h>
X#ifdef sun
X#  include <sys/socket.h>
X#endif
X#include <netinet/in.h>
X#include <arpa/inet.h>
X
X#include <sys/file.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X
X
Xextern char *sys_errlist[] ;
X
Xtypedef char BYTE;		/* an 8-bit field */
X
X#define MAXPROGNM	12	/* Name of monitoring program */
X#define	MAXNMLEN	16	/* For site's name, can be nickname */
X#define MAXADDRLEN	128	/* Ok for IP, decnet, OSI */
X#define MAXCOMMENT	16	/* For comments that the programs might have */
X#define MAXTAGLEN	8	/* For classifying/troubleshooting ? */
X
X/* data structure of NOCOL event message */
X
X/* site identifier */
Xtypedef struct 
X{
X    char	name[MAXNMLEN];		/* site name (can also be a pseudo) */ 
X    char	addr[MAXADDRLEN];	/* Okay for IP, DECnet, OSI */
X/*    char	tag[MAXTAGLEN];		/* For tagging sites. Optional */
X} SITE;	
X
X/* problem identifier */
X/* typedef struct
X/* {
X/*	unsigned char	class:8;	 problem class */
X/*	short 		id;		 problem id from 001 to 999
X/*					 for each class */
X/* } PROB;
X*/
X
X/* variable info */
Xtypedef struct
X{
X    char	name[MAXNMLEN];		/* name or keyword of variable */
X    u_long	value;			/* variable value */
X    u_long	threshold;		/* variable threshold, if applicable */
X    char	units[8];		/* units of variable (pkts, ms) */
X} VAR;
X
X/* event format */
Xtypedef struct 
X{
X    char	sender[MAXPROGNM];	/* 8 bytes of sender name */
X    SITE		site;		/* site identifier */
X    VAR			var;		/* variable info */
X    unsigned char	mon:8;		/* 1 to 12; can be reduced to 4 bits */
X    unsigned char	day:8;		/* 1 to 31; can be reduced to 5 bits */
X    unsigned char	hour:8;		/* 0 to 23; can be reduced to 5 bits */
X    unsigned char	min:8;		/* 0 to 59; can be reduced to 6 bits */
X    unsigned char	severity:8;	/* event severity; need only 2 bits */
X    unsigned char	loglevel:8;	/* for logging; need only 2 bits */
X    unsigned char	nocop:8;	/* operations flag indicating STATE */
X/*    char	comment[MAXCOMMENT];	/* Generic comment, for future... */
X} EVENT;
X
X/* Event severities. */
X#define E_CRITICAL	1
X#define E_ERROR		2
X#define E_WARNING	3
X#define E_INFO		4
X
X/* Text used to refer to severity levels. First is null since start with 1 */
Xstatic char *severity_txt[] = {
X    "BAD-0", "Critical", "Error", "Warning", "Info", "BAD-5"} ;
X
X/* 'nocop' flags indicating various 'STATE's that a site can be in */
X
X#define n_UP		0x01
X#define n_DOWN		0x02
X#define n_UNKNOWN	0x04			/* not tested yet ? */
X#define n_TEST		0x08			/* Site in test mode */
X#define n_NODISPLAY	0x10			/* Ignore while displaying */
X
X/*
X * Some flag operations on mask 'm'. Since UP, DOWN, UNKNOWN are mutually
X * exclusive, this macro sets the desired mask and clears the others
X * (No, the DOUN is not a typo, it stands for DOwn and UNknown
X */
X#define SETF_UPDOUN(mask, f)	( (mask & ~(n_UP | n_DOWN | n_UNKNOWN)) | f )
X
Xstruct nocop_txt_s
X{
X    int		v ;
X    char	*str ;		/* Text used to refer to nocop flags */
X};
Xstatic struct nocop_txt_s nocop_txt[] = {
X  {n_UP, "up"},
X  {n_DOWN, "down"},
X  {n_UNKNOWN, "unknown"},
X  {n_TEST, "test"},
X  {n_NODISPLAY ,"nodisplay"},
X  {0, ""}
X} ;
X
X
X
X#endif	/* __nocol_h  */
END_OF_FILE
  if test 3694 -ne `wc -c <'nocol-3.0/src/include/nocol.h'`; then
    echo shar: \"'nocol-3.0/src/include/nocol.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/include/nocol.h'
fi
if test -f 'nocol-3.0/src/include/trapmon.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/include/trapmon.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/include/trapmon.h'\" \(4009 characters\)
  sed "s/^X//" >'nocol-3.0/src/include/trapmon.h' <<'END_OF_FILE'
X/*
X * $Header: /home/aggarwal/lsrc/nocol/src/include/RCS/trapmon.h,v 1.8 1993/11/04 07:40:13 aggarwal Exp $
X */
X
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <stdio.h>
X#include <time.h>
X#include <sys/time.h>
X#include <errno.h>
X#include <syslog.h>
X#include <fcntl.h>
X#include <string.h>
X#include <sys/socket.h>
X#include <netdb.h>
X
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "asn1.h"
X#include "snmp_api.h"
X#include "snmp_client.h"
X
X#include "nocol.h"				/* For O_NETMON output */
X
X#ifndef HAVE_FD_MACROS
X# ifdef BSD4_3					/* BSD4.3 already has these */
X#  define HAVE_FD_MACROS
X# endif
X# ifdef FD_SET
X#  define HAVE_FD_MACROS
X# endif
X#endif
X
X/* Macros for use with snmp_select_info() and select() */
X#ifndef HAVE_FD_MACROS
Xtypedef long    fd_mask;
X#define NFDBITS (sizeof(fd_mask) * NBBY)        /* bits per mask */
X#define FD_SET(n, p)    ((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
X#define FD_CLR(n, p)    ((p)->fds_bits[(n)/NFDBITS] &= ~(1 << ((n) % NFDBITS)))
X#define FD_ISSET(n, p)  ((p)->fds_bits[(n)/NFDBITS] & (1 << ((n) % NFDBITS)))
X#define FD_ZERO(p)      bzero((char *)(p), sizeof(*(p)))
X#endif /*end of #ifdef HAVE_FD_MACROS */
X
X/* These #define's handle 4.2 systems without additional syslog facilities. */
X#ifndef LOG_CONS
X#define LOG_CONS        0       /* Don't bother if not defined... */
X#endif
X#ifndef LOG_LOCAL0
X#define LOG_LOCAL0      0
X#endif
X
X
X/* Output data dir for the NOCOL style output */
X#ifndef DATADIR
X#define DATADIR		"../../data"
X#endif
X
X/*
X** SNMP_TRAP_MAX is the largest valid SNMP_TRAP_* number
X** SNMP_TRAP_MAX + 1 is the canonical unknown/invalid trap number
X** This really belongs in "snmp.h" with the SNMP_TRAP_* define's there
X#define SNMP_TRAP_MAX	0x6
X
X/*
X * Describe all the possible traps here and their severity levels here.
X * Note that the location of the traps in the array depends on the int
X * value assigned to the various trap types in 'snmp.h'
X */
X
Xstruct t_desc {
X    char  *tname ;		/* Trap name */
X    int   tseverity ;		/* Trap severity as described in nocol.h */
X    char  *tseverity_str ;	/* Severity description strings */
X    int   nocop ;		/* Operation status n_UP, n_DOWN, n_UNKNOWN */
X    int   loglevel ;		/* For noclogd logging level */
X} ;
X
Xstruct t_desc trap_desc[] = {
X  { "Cold_Start", E_WARNING, "Warning", n_UP, E_WARNING },	/* trap 0 */
X  { "Warm_Start", E_WARNING, "Warning", n_UP, E_WARNING },	/* trap 1 */
X  { "Link_Down",  E_ERROR,   "ERROR", n_DOWN, E_ERROR},		/* trap 2 */
X  { "Link_Up",    E_ERROR,   "ERROR", n_UP, E_ERROR},		/* trap 3 */
X  { "Auth_Failure", E_WARNING, "Warning", n_UP, E_WARNING},	/* trap 4 */
X  { "EGP_Peer_Loss", E_CRITICAL, "CRITICAL", n_DOWN, E_CRITICAL}, /* trap 5 */
X  { "Enterprise", E_WARNING, "Warning", n_UNKNOWN, E_WARNING},	/* trap 6 */
X  { "Unknown_Type", E_WARNING, "Warning", n_UNKNOWN, E_WARNING}	/* trap 7 */
X} ;
X
X
X
X/*
X** Possible options:
X**  O_NETMON:	output EVENT structures to file for use with netmon
X**  O_LOG:	output to syslog()
X**  O_PRINT:	output to stderr
X**  O_DEBUG:	debugging output to stdout
X** See the 'options' global variable below
X*/
X#define O_NETMON	0x1
X#define O_LOG		0x2
X#define O_PRINT		0x4
X#define O_DEBUG		0x8
X
X/*
X * Timeout for each EVENT in seconds - currently set to 30 minutes.
X * Trap events older than this will be deleted from the data file.
X */
X#define TIME_TO_LIVE	(30*60)		/* convert to seconds */
X
X/* Timeout for select() in seconds - currently set to 5 minutes */
X#define SELECT_TIMEOUT	(5*60)
X
X#define MAX_PATH_LEN	256			/* Longest path expected */
X#define DATAFILE_MODE	0664			/* Mode for EVENT file */
X#define OUTPUT_EXTENSION "-output"		/* Extension for EVENT file */
X#define MAX_TRAPS	256			/* Max # of unresolved traps */
X
Xextern int	errno;
Xint		snmp_dump_packet = 0;
Xint		options;			/* Command line options */
Xchar		*progname;			/* Program name, no path */
Xchar		datafname[MAX_PATH_LEN];	/* Filename for O_NETMON */
Xtime_t		die_at[MAX_TRAPS];		/* When this EVENT times out */
Xint		numtraps;			/* # of outstanding EVENTs */
END_OF_FILE
  if test 4009 -ne `wc -c <'nocol-3.0/src/include/trapmon.h'`; then
    echo shar: \"'nocol-3.0/src/include/trapmon.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/include/trapmon.h'
fi
if test -f 'nocol-3.0/src/lib/standalone.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/lib/standalone.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/lib/standalone.c'\" \(3663 characters\)
  sed "s/^X//" >'nocol-3.0/src/lib/standalone.c' <<'END_OF_FILE'
X/*+ 	$Header: /home/aggarwal/lsrc/nocol/src/lib/RCS/standalone.c,v 1.7 1993/10/02 05:26:53 aggarwal Exp $
X *
X */
X
X/* Copyright 1992 JvNCnet, Princeton */
X
X/*+
X**
X** FUNCTION:
X**
X**	Kill any other process and write the present PID into the
X** PidFile. If cannot write to the file or if the file is locked
X** by another process, it returns a value of -1 (in which case the
X** calling program should EXIT).
X**
X** It assumes that the PidFile is "program.pid", where the pointer
X** to the string "program" is passed to it.
X**
X** (Observe that unless the program name has been stripped of the 
X**  path, the pid file is created in the same directory as the
X**  program).
X**
X**  Method:
X**		See if pid file exists, create if none
X**	        try to lock
X**		if cannot lock 
X**		   kill process
X**		   if (cannot kill)
X**		     return (-1)
X**		   else
X**		     lock file
X**		write pid, return to caller
X**
X** NOTE:
X** 	I *do* know about the 'access' system call for the existability
X** of a file. It just tended to screw up on the sun, so I used the simple
X** 'fopen' call to test if the file exists.
X**/
X
X/*
X * $Log: standalone.c,v $
X * Revision 1.7  1993/10/02  05:26:53  aggarwal
X * Now requires path to the PIDfile. Also assumes that 'prog' is the
X * name of the program being run.
X *
X * Revision 1.6  1992/06/18  21:15:00  aggarwal
X * Completely rewritten. No fancy stuff anymore (using fcntl or all
X * that).
X *
X * 
X * Revision 1.3  90/06/15  11:58:40  network
X * After sending out kill signal, wait for a while so that
X * the process can die and release the file.
X *
X */
X#include <stdio.h>
X#include <signal.h>				/* signal numbers	*/
X#include <sys/file.h>
X#include <errno.h>
X
X#ifndef MAXLINE
X#define MAXLINE	256
X#endif
X
Xstandalone (prognm_pidf)
X     char *prognm_pidf;			/* Path of PID file without suffix */
X{
X    FILE *pidf ;
X    int oldpid = 0, newpid = 0;
X    int fd ;
X    char *pidfile, *prog;
X    char hostname[MAXLINE], thishostname[MAXLINE] ;
X    
X    pidfile = (char *)malloc(strlen(prognm_pidf) + 6) ;
X    sprintf(pidfile, "%s.pid\0", prognm_pidf);	/* add suffix to name	*/
X    if ((prog = (char *)strrchr (prognm_pidf, '/')) == NULL)
X      prog = prognm_pidf ;			/* no path in name */
X    else
X      prog++ ;					/* skip leading '/' */
X    
X    gethostname(thishostname, sizeof(thishostname) -1) ;
X    thishostname[MAXLINE - 1] = '\0' ;
X
X    if ( (pidf =fopen (pidfile, "r")) != NULL)	/* file exists...	*/
X    {
X	if (fscanf(pidf, "%d %s", &oldpid, hostname) == EOF)
X	{
X	    fprintf(stderr, "(standalone): fscanf ");
X	    perror(pidfile) ;			/* couldn't read */
X	    return (-1);
X	}
X	fclose(pidf);
X
X	if (strcmp(thishostname, hostname) != 0)	/* wrong host */
X	{
X	    fprintf(stderr,
X		    "(standalone) %s: Program probably running on '%s'\n",
X		    prog, hostname) ;
X	    fprintf(stderr, "Kill and delete '%s' file and restart\n",pidfile);
X	    return (-1) ;
X	}
X	else					/* on proper host */
X	{
X	    if (kill (oldpid, SIGKILL) != 0 && errno != ESRCH)
X	    {
X		fprintf(stderr,
X			"(standalone) %s: Couldn't kill earlier process\n",
X			prog);
X		perror("signal");
X		return (-1) ;
X	    }
X	    else
X	      sleep (5) ;		/* Let other process die */
X	}
X    }			/* end if (pidfile could be opened) */
X
X    /*
X     * Here only if all other processes have been killed
X     */
X
X    newpid=getpid();
X    if ( (pidf = fopen(pidfile, "w")) == NULL)	/* create file	*/
X    {
X	fprintf(stderr, "(standalone): fopen ");
X	perror(pidfile);	
X	return(-1);
X    }
X    fprintf (pidf,  "%d\n%s\n", newpid, thishostname);	/* Store present pid */
X    fflush(pidf);
X    fclose(pidf) ;
X    fprintf(stderr, "(%s).. locked pid-file, started new process\n", prog);
X    
X    return (0) ;
X}
END_OF_FILE
  if test 3663 -ne `wc -c <'nocol-3.0/src/lib/standalone.c'`; then
    echo shar: \"'nocol-3.0/src/lib/standalone.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/lib/standalone.c'
fi
if test -f 'nocol-3.0/src/netmon/fill_window.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/netmon/fill_window.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/netmon/fill_window.c'\" \(4125 characters\)
  sed "s/^X//" >'nocol-3.0/src/netmon/fill_window.c' <<'END_OF_FILE'
X/*
X**	$Header: /home/aggarwal/lsrc/nocol/src/netmon/RCS/fill_window.c,v 1.7 1993/10/30 03:52:08 aggarwal Exp $
X*/
X
X/*+ 
X** 	This function fills the window given with files from the
X** specified directory pointer. A pointer to the funtion that is to be
X** called to display one line from the data files is passed. This is
X** done to make this function usable for both the EVENT window as well
X** as the MESSAGES window.
X**
X** LOGIC
X**	1) Skip over any file that begins with a "." or named 'core'
X**	2) Reset to start of window (needed since we are using WFULL
X**	   to decide when to stop putting out lines.
X**	3) Get next file in directory
X**	   - if directory type then skip
X**     	   - open file
X**	4) If end of directory, close and return 1
X**	5) If not FULL, call display_function
X**	   else return(0)
X**	6) If end of file,
X**	    - close file
X**	    - open next file
X**	    - if end of dir, clrtobot, return(1)
X**
X** 
X** RETURN VALUE
X**	1 if all files in directory are displayed.
X**	0 if all files have not yet been displayed.
X**/
X
X
X/*
X *
X *	$Log: fill_window.c,v $
X * Revision 1.7  1993/10/30  03:52:08  aggarwal
X * Now uses dirent(). Deleted include dir.h
X *
X * Revision 1.6  1993/10/05  04:17:41  aggarwal
X * Now skips over 'core' files.
X *
X * Revision 1.5  1992/06/18  21:03:22  aggarwal
X * Cleaned up for releasing.
X *
X * Revision 1.4  1992/04/22  22:59:58  aggarwal
X * Lot of cleaning up for releasing. Organized things right.
X *
X * Revision 1.3  1990/05/23  17:21:21  aggarwal
X * Uncommented wmove() - see preamble (comments).
X *
X * Revision 1.2  90/05/13  22:27:02  aggarwal
X * Commented out the line for resetting the window position to (0,0) 
X * since that should depend on the window being operated upon - the msg
X * win can scroll so I don't want to reset the cursor position for the 
X * msg window. Have moved the line to the event_dpy.c module instead.
X * Added ' fstat' so that a directory is skipped and not treated as a 
X * data file. 
X * 
X * Revision 1.1  90/03/09  13:05:47  aggarwal
X * Initial revision
X * 
X */
X
X#include	"netmon.h"
X
X#define WFULL(w)  	(w->_cury == (w->_maxy - 1)) ? 1:0
X
Xfill_window(win, dirp, dir, pcurfd, dpy_func)
X     WINDOW *win;			/* Window to be filled		*/
X     char *dir ;			/* Name of the directory	*/
X     DIR *dirp;				/* opened directory pointer	*/
X     int *pcurfd;			/* Present opened file desc	*/
X     int (*dpy_func)();			/* Display function		*/
X{
X    struct dirent *direntry ;
X    char file[MAXLINE];
X    int opennew = 0;				/* boolean to open file	*/
X
X
X    wmove(win, 0, 0);				/* reset to start pos	*/
X    
X    if (*pcurfd == 0)				/* No file open...	*/
X      opennew = 1 ;
X
Xopen_file:
X    while (opennew)			/* open new file until successful */
X    {
X	struct stat buf ;		/* for fstat */
X
X	if (*pcurfd > 0)		/* close any currently open file */
X	  close(*pcurfd);
X
X	if ((direntry = readdir(dirp)) == NULL)
X	{					/* All files are done	*/
X	    wclrtobot(win);			/* Clear win to bottom	*/
X	    *pcurfd = 0;			/* reset to zero	*/
X	    return (1);				/* All files displayed	*/
X	}
X
X	/* name begins with a dot or 'core' or is not a file */
X	if (*(direntry->d_name) == '.' || strcmp(direntry->d_name, "core") ==0)
X	  goto open_file ;		      	/* ...so skip it	*/
X
X	sprintf (file, "%s/%s", (char *)dir, (char *)direntry->d_name);
X	
X	if ((*pcurfd = open(file, O_RDONLY)) == -1)	/* error */
X	{
X	    wprintw (aw.wmsg,
X		     "\nERROR fill_win(open): '%s'- %s",
X		     direntry->d_name, sys_errlist[errno]);
X	    continue ;
X	}
X
X	/*
X	 * Here if safely opened data file
X	 */
X	fstat (*pcurfd, &buf);		/* Get info about fd	*/
X	if ((buf.st_mode & S_IFMT) == S_IFDIR)	/* It is a dir	*/
X	{					/* ..so open another	*/
X	    close(*pcurfd);
X	    goto open_file ;
X	}
X
X	opennew = 0;			/* Don't open another	*/
X	if (options & debug)
X	  wprintw (aw.wmsg, 
X		   "\n(DEBUG) fill_win: Opened file %s... ", direntry->d_name);
X
X    }		/* end:  while opennew	*/
X
X    while (!(WFULL(win)))
X      if (dpy_func(*pcurfd, win) == 0)		/* end of file		*/
X      {
X	  opennew = 1;				/* open another file	*/
X	  goto open_file ;
X      }
X    return (0) ;				/* Window full		*/
X
X}						/* end: fill_window	*/
END_OF_FILE
  if test 4125 -ne `wc -c <'nocol-3.0/src/netmon/fill_window.c'`; then
    echo shar: \"'nocol-3.0/src/netmon/fill_window.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/netmon/fill_window.c'
fi
if test -f 'nocol-3.0/src/netmon/parse_input.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/netmon/parse_input.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/netmon/parse_input.c'\" \(3223 characters\)
  sed "s/^X//" >'nocol-3.0/src/netmon/parse_input.c' <<'END_OF_FILE'
X/*+ 
X** $Header: /home/aggarwal/lsrc/nocol/src/netmon/RCS/parse_input.c,v 1.5 1992/06/18 21:06:55 aggarwal Exp $
X**/
X
X/* Copyright 1992 JvNCnet, Princeton */
X
X/*+ 
X** Parse the user input and act accordingly (call appropriate
X** function). Note that it might modify the values of 'options' and 'level'
X** which are defined in 'netmon.h'
X**/
X
X/*
X * $Log: parse_input.c,v $
X * Revision 1.5  1992/06/18  21:06:55  aggarwal
X * Updated for search filter.
X *
X * Revision 1.4  1992/04/23  15:43:42  aggarwal
X * Added ^S and ^Q also.
X *
X * Revision 1.3  1992/04/22  22:59:58  aggarwal
X * Lot of cleaning up for releasing. Organized things right.
X *
X * Revision 1.2  1990/04/17  17:28:36  network
X * Added the 'N' option for "netlog" ( it had better be in your
X * path...).
X *
X * Revision 1.1  90/03/09  16:25:51  aggarwal
X * Initial revision
X * 
X * 
X */
X
X#include	"netmon.h"
X#include	<ctype.h>
X
Xparse_input(response)
X     char response;
X{
X    extern int options, level;			/* defined in netmon.h	*/
X    extern bool frozen;
X    extern struct allwins aw;			/* defined in netmon.h	*/
X    int poll_input(), newresponse;
X
X    switch (response)
X    {
X     case 'b':					/* toggle beep/bell	*/
X	options = options ^ quiet ;
X	break ;
X
X     case 'c': 					/* Contract event win	*/
X	--eventsz;
X	endwin();
X	all_doer();
X	break ;
X
X     case 'd':					/* toggle debug mode	*/
X	options = options ^ debug;		/* XOR the debug bit	*/
X	wprintw(aw.wmsg, "\n Debug mode ");
X	if ( options & debug)
X	  wprintw(aw.wmsg, "on");
X	else
X	  wprintw(aw.wmsg, "off");
X	display_screenful() ;
X	break ;
X
X     case 'w':
X     case 'e':					/* toggle wide mode	*/
X	options = options ^ emode ;		/* XOR the extended bit	*/
X	endwin ();
X	all_doer() ;
X	break ;
X
X     case CTRL('s'): case CTRL('q'):
X     case 'f':					/* Freeze display	*/
X	frozen = !frozen ;			/* Invert the bit	*/
X	msgtitle_dpy(aw.wmsgtitle);		/* To indicate frozen	*/
X	display_screenful() ;			/* Show on terminal	*/
X	parse_input(poll_input());		/* To redisplay present	*/
X	break ;
X
X     case 'l':					/* new display level	*/
X	wprintw(aw.wmsg, "\nEnter new level [%d-%d]", E_CRITICAL, E_INFO);
X	display_screenful();
X	newresponse = poll_input() - '0';	/* character to number	*/
X	if (newresponse >= E_CRITICAL && newresponse <= E_INFO )
X	  level = newresponse ;
X	wprintw(aw.wmsg, " %d OK", level);
X	display_screenful() ;
X	break ;
X
X      case 'q':					/* quit			*/
X	done ();
X	break ;
X
X      case '?': case 'h':			/* Help page		*/
X	help_page();
X	display_screenful();			/* Main window again	*/
X	break;
X	
X#ifdef NETLOG
X      case 'n':		                       /* Run NETLOG           */
X	endwin();
X	system ("netlog");                      /* better be in path    */
X	wrefresh(curscr);
X	break;
X#endif
X     case CTRL('l'):
X     case 'r':					/* redraw screen	*/
X	wrefresh (curscr);
X	parse_input (poll_input());
X	break ;
X
X     case 's':					/* search filter */
X     case '/': case '|':
X	read_filter();
X	msgtitle_dpy(aw.wmsgtitle);		/* indicate filter in effect */
X	display_screenful();
X	break ;
X
X     case 'x':					/* Expand window	*/
X	++eventsz;
X	endwin();
X	all_doer();
X	break;
X
X     default:					/* return for next scr	*/
X	break ;
X    }					    	/* End switch()		*/
X
X    return (1);	
X}						/* End:  parse_input()	*/
END_OF_FILE
  if test 3223 -ne `wc -c <'nocol-3.0/src/netmon/parse_input.c'`; then
    echo shar: \"'nocol-3.0/src/netmon/parse_input.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/netmon/parse_input.c'
fi
if test -f 'nocol-3.0/src/netmon/read_filter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/netmon/read_filter.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/netmon/read_filter.c'\" \(3636 characters\)
  sed "s/^X//" >'nocol-3.0/src/netmon/read_filter.c' <<'END_OF_FILE'
X/*
X * $Header: /home/aggarwal/lsrc/nocol/src/netmon/RCS/read_filter.c,v 1.2 1993/10/30 03:54:31 aggarwal Exp $
X */
X
X/* Copyright 1993 JvNCnet, Global Enterprise Services */
X
X/*
X * Creates a new window and reads in the user entered string which is used
X * as the filter. All EVENT structures that match this pattern will then
X * be displayed by the NOCOL display program
X *
X * AUTHOR
X *	David Wagner, wagner@jvnc.net, June 8, 1992
X *
X */
X
X/*
X * $Log: read_filter.c,v $
X * Revision 1.2  1993/10/30  03:54:31  aggarwal
X * using _tty.sg_erase is kinda non-portable. Using erasechar() instead
X *
X * Revision 1.1  1992/06/18  21:08:29  aggarwal
X * Initial revision
X *
X */
X
X#include "netmon.h"
X
X#define MAXLINELEN	256			/* Max length of new pattern */
X/*
X * Global variables
X */
Xchar pattern[MAXLINELEN];		/* Save the pattern */
Xint isdefined_pattern=0;		/* Is pattern specified yet? */
X
X
X/*+	read_filter
X ** Creates a new window and reads in a new pattern string for filtering
X ** out unwanted information.
X ** Compiles that pattern for later use by filter().
X */
X
Xread_filter()
X{
X  WINDOW *npatwin;				/* Where to get pattern from */
X
X  npatwin = newwin(0,0,0,0);			/* Create new window */
X  touchwin(npatwin);				/* Bring it to the front */
X  wstandout(npatwin);				/* Print the title header */
X  mvwprintw(npatwin, 0, (int) (COLS/2 - 9), "NEW FILTER PATTERN\n\n");
X  wstandend(npatwin);
X
X  if (isdefined_pattern) {
X    /*
X    ** There is a pattern compiled already - use it as the default,
X    ** and let the user edit it as the starting point for a new one.
X    */
X    wprintw(npatwin, "Use ^U to erase filter\n");
X    wprintw(npatwin, "Enter filter (<word> [&] [|] <word>..): %s", pattern);
X    wrefresh(npatwin);
X    get_filter(npatwin, pattern, strlen(pattern));
X  } else {
X    /*
X    ** This is the first call to new_pattern(), so there is no
X    ** saved pattern available.
X    */
X    wprintw(npatwin, "Use ^U to erase filter\n");
X    wprintw(npatwin, "Enter filter (<word> [&] [|] <word>..): ");
X    wrefresh(npatwin);
X    get_filter(npatwin, pattern, 0);
X  }
X
X  if (*pattern == '\0')
X    isdefined_pattern = 0;			/* clear pattern ? */
X  else
X  {
X      isdefined_pattern = 1;			/* Remember we set pattern[] */
X      wprintw(npatwin, "\n\nFilter accepted!\n");	/* Notify the user. */
X  }
X  wrefresh(npatwin);
X
X  compile_pattern(pattern);			/* Defined in filter.c */
X  werase(npatwin);			/* Return to the main display */
X}			/* end:   read_filter */
X
X/*
X** Takes the string listed in pat[] as the starting point for a
X** new pattern and allows the user to edit that one to create a new one.
X** The backspace and erase keys are accepted - right now there is no
X** fancy editing.
X**
X** Places the newly entered string into pat[] upon returning.
X*/
Xget_filter(w, pat, patlen)
X     WINDOW *w;
X     char pat[MAXLINELEN];
X     int patlen;
X{
X  int i;
X
X  i = patlen;
X
X  while ((pat[i]=wgetch(w)) != '\n')		/* Read one char at a time */
X      if (i>0 && (pat[i]=='\b' || pat[i]==erasechar())) 
X      {
X	  wprintw(w, "\b");			/* Backspace over last char */
X	  wdelch(w);				/* and delete it */
X	  wrefresh(w);
X	  i--;
X      } else if (i < MAXLINELEN) {		/* Limit line length */
X	  if (pat[i] == CTRL('u'))		/* erase line using ^u */
X	  {
X	      do 
X		wprintw(w, "\b"), wdelch(w) ;	/* backspace to beginning */
X	      while (--i) ;
X	      wrefresh(w);
X	      continue ;			/* get next character */
X	  }
X	  if (iscntrl(pat[i]))			/* Ignore ctrl chars */
X	    continue ;
X	  wprintw(w, "%c", pat[i++]);
X	  wrefresh(w);
X      } /* end of if */
X
X  /* By the way, we are NOT in the while loop anymore */
X
X  pat[i] = '\0';				/* Don't forget '\0'! */
X}
END_OF_FILE
  if test 3636 -ne `wc -c <'nocol-3.0/src/netmon/read_filter.c'`; then
    echo shar: \"'nocol-3.0/src/netmon/read_filter.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/netmon/read_filter.c'
fi
if test -f 'nocol-3.0/src/perlnocol/bgpmon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/perlnocol/bgpmon'\"
else
  echo shar: Extracting \"'nocol-3.0/src/perlnocol/bgpmon'\" \(4062 characters\)
  sed "s/^X//" >'nocol-3.0/src/perlnocol/bgpmon' <<'END_OF_FILE'
X#!/usr/local/bin/perl 
X#
X# $Header: /home/aggarwal/lsrc/nocol/src/perlnocol/RCS/bgpmon,v 1.1 1993/10/30 03:59:49 aggarwal Exp $
X#
X#        bgpmon - perl monitor for BGP processes on cisco's
X#
X# Runs the command 'show ip bgp summary' on cisco routers and parses
X# the output to see if any peer is 'Idle/Active/Down' state (i.e. not
X# connected). If so, it marks the event as down. (NOTE: cisco router's
X# indicate the time that a BGP peer has been active, so its easy to
X# tell if a peer is not connected).
X#
X# Part of the NOCOL monitoring package.
X#
X# Author: Vikas Aggarwal,  vikas@jvnc.net
X#
X# 	Copyright 1993 JvNCnet, Global Enterprise Services
X#
X## 
X##
X#
X#
X############################
X## Variables customization #  overrides values in the nocollib.pl library
X############################
X$rprog="rcisco";			# Path for rcisco.
X$rpasswd="";				# if NULL, uses the default in rcisco
X$rcommand="show ip bgp summary";
X$varname="BGPpeerDown";
X$varunits="State" ;			# the var.units field in EVENT struct
X$sleepint=60*10;       			# Seconds to sleep between tries.
X############################
X$debug = 0;				# set to 1 for debugging output
X$libdebug = 0;				# set to 1 for debugging output
X
Xrequire  "nocollib.pl" ;
X
X-x $rprog || die("Could not find executable $rprog, exiting");
X
X@me=split(/\//,$0); $me=pop(@me);
X#$piddir=join("/",@me); if ($piddir eq "") {$piddir=$etcdir;}
X$piddir=$etcdir;
X$cfile="$etcdir/$me-confg";
X$datafile="$datadir/$me-output";
X
X$sender= $me ;				# filled in the EVENT sender
X
X
X##
X# Read the config file. Use '\t' as a separator for 'item'
Xsub readconf {
X    open(CONFIG,"<$cfile")||die("Couldn't find $cfile, exiting");
X    while(<CONFIG>)
X    {
X	chop;
X	if(/^\s*#/) {next;}   # skip comments
X	if(/^\s*$/) {next;}   # skip blank lines
X	if (/\s*(\S+)\s+(\S+)\s*$/)
X	{
X	    $item="$1\t$2" ;	 # the name and address
X	    push(@items,$item);
X	}
X	else {print "Ignoring illegal line: $_\n";}
X
X    }	# end while(CONFIG)
X
X    close(CONFIG);
X    if(0>$#items){die("Nothing to monitor in $cfile, exiting")};
X    if ($debug) {
X	print "Items are:\n"; foreach (@items) { print "\t$_\n" } ;
X    }
X}				# end: readconf
X
X## Check state of each router
X#
Xsub dotest {
X    local ($router) = @_ ;
X    local ($peer, $state, $peersdown);
X    local ($loginok) = 0;
X
X    if ($debug) { print "Checking $router\n"; }
X    $command="$rprog $router ".' "'."$rpasswd".'" '.'"'."$rcommand".'"';
X    if ($debug) {print "(debug) dotest: running command $command\n" ;}
X
X    open (ROUTER, "$command |") ;
X	
X    while(<ROUTER>) {
X	tr/\r\n//d;
X	if ( />/ ) {$loginok = 1 ;} # got the 'Router>' prompt
X	if ( /^\s*(\d+\.\d+.\d+.\d+).*\s+(\S+)\s*$/ )
X	{
X#	    if ($debug) {print "(debug) processing line: $_\n" ;}
X	    $peer = $1;
X	    $state = $2;
X	    if ($debug) { print "(debug): Peer= $peer, State= $state\n"; }
X	    if ( $2 =~ /Active|Idle|Down/ ) { ++$peersdown ;}
X	}
X	elsif ($debug) {
X#	    print "(debug) skipping line: $_\n" ;
X	}
X    }  # end while
X    close (ROUTER);
X
X    if ($loginok == 0) { 
X	print "Login into remote host failed\n" ;
X	return(-1);
X    }
X    if ($debug) {print "Peers Down= $peersdown\n" ;}
X    return ($peersdown) ;		# not caring about timeouts
X
X} # end: dotest()
X
X
X
X###
X### main
X###
X
X# Fork and get rid of old process.
Xif($p=fork){print "$p\n";exit;}
X&standalone($me,$piddir);
X
X&readconf ;
X
Xforeach $item (@items) {
X    local ($host, $addr) = split( /\t/, $item );
X    &init_event ($host, $addr, $item);
X}
X
Xwhile (1)
X{
X    local ($peersdown);
X    foreach $item (@items) {
X	local ($host, $addr) = split( /\t/, $item );
X	$peersdown = &dotest ($addr);
X        if ($linesused < 0)
X        {
X            print "$me: dotest failed for $host ($addr) , skipping\n";
X            next ;
X        }
X	if ($peersdown) {
X	    &update_event($item, 0, $peersdown, $E_CRITICAL); # State DOWN
X	}
X	else {
X	    &update_event($item, 1, $peersdown, $E_CRITICAL); # All OKAY
X	}
X    }
X
X    ; ## Note: we want to write the file quickly.
X
X    open(OEVENTS,">$datafile");
X    foreach $item (@items) {
X	&writeevent($item);
X    }
X    close(OEVENTS);
X    sleep($sleepint);
X}
X
END_OF_FILE
  if test 4062 -ne `wc -c <'nocol-3.0/src/perlnocol/bgpmon'`; then
    echo shar: \"'nocol-3.0/src/perlnocol/bgpmon'\" unpacked with wrong size!
  fi
  chmod +x 'nocol-3.0/src/perlnocol/bgpmon'
  # end of 'nocol-3.0/src/perlnocol/bgpmon'
fi
if test -f 'nocol-3.0/src/tpmon/tptest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/tpmon/tptest.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/tpmon/tptest.c'\" \(3327 characters\)
  sed "s/^X//" >'nocol-3.0/src/tpmon/tptest.c' <<'END_OF_FILE'
X/*
X * $Header: /nocol/src/tpmon/RCS/tptest.c,v 1.1 1992/06/12 21:01:19 aggarwal Exp $
X */
X
X/*
X * Thruput tester - standalone version.
X * tptest.c -- testing stub program for tpmon.c
X *
X * AUTHOR
X *	S. Spencer Sun, spencer@jvnc.net, June 1992
X *
X *
X * $Log: tptest.c,v $
X * Revision 1.1  1992/06/12  21:01:19  aggarwal
X * Initial revision
X *
X */
X/*  Copyright 1992 JvNCnet
X
X Permission to use, copy, modify and distribute this software and its
X documentation for any purpose is hereby granted without fee, provided that
X the above copyright notice appear in all copies and that both that copyright
X notice and this permission notice appear in supporting documentation, and
X that the name of JvNCnet not be used in advertising or publicity pertaining
X to distribution of the software without specific, written prior permission.
X JvNCnet makes no representations about the suitability of this software for
X any purpose.  It is provided "as is" without express or implied warranty.
X
X JvNCnet DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL JvNCnet
X BE LIABLE FOR ANY DAMAGES WHATSOEVER, INCLUDING DAMAGES RESULTING FROM LOSS
X OF USE, DATA OR PROFITS, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
X OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X*/
X
X#include <stdio.h>
X
X#include "tptest.h"
X
Xchar *prognm;
X
Xvoid
Xusage()
X{
X  fprintf(stderr, "Usage: %s [ -b numbytes ] [ -s blocksize ] [ -t secs ]\n",
X    prognm);
X  fprintf(stderr,
X    "\t[ -p fillpattern ] [ -P port# ] [ -v ] host [ host ... ]\n\n");
X  fprintf(stderr,
X    "\tIf both -b and -t are used, then the -b part is ignored.\n");
X}
X
Xint
Xmain(argc, argv)
X  int argc;
X  char *argv[];
X{
X  extern char *optarg;
X  extern int optind;
X
X  int ch, blocksize, time, verbose;
X  long numbytes;
X  short int port;
X  char *pattern;
X  double tp;
X
X  prognm=argv[0];
X  numbytes = 0x00400000;
X  blocksize = 1024;
X  time = 0;
X  port = 9;
X  pattern = NULL;
X  verbose = 0;
X
X  while ((ch = getopt(argc, argv, "b:P:p:s:t:v")) != EOF) {
X    switch(ch) {
X      case 'b':
X        numbytes = atol(optarg);
X        if (numbytes < 0) {
X          fprintf(stderr,
X            "%s: error in numbytes parameter to -b flag, must be >= 0\n",
X            prognm);
X          return 1;
X        }
X        break;
X      case 'p':
X        pattern = optarg;
X        break;
X      case 'P':
X        port = (short int)atoi(optarg);
X        break;
X      case 's':
X        blocksize = atoi(optarg);
X        if (blocksize < 1) {
X          fprintf(stderr, "%s: blocksize parameter to -s must be non-zero\n");
X          return 1;
X        }
X      case 't':
X        time = atoi(optarg);
X        if (time < 1) {
X          fprintf(stderr, "%s: time must be at least 1 second\n", prognm);
X          return 1;
X        }
X        break;
X      case 'v':
X        verbose = 1;
X        break;
X      default:
X        usage();
X        return 1;
X        break;
X    }
X  }
X  argc -= optind;
X  if (argc < 1) {
X    fprintf(stderr, "%s: no hosts were specified\n", prognm);
X    usage();
X    return 1;
X  }
X  argv += optind;
X  do {
X    tp = throughput(*argv, port, numbytes, blocksize, pattern, time, verbose);
X    if (tp >= 0)
X      printf("Throughput for %s is %7.5g bps\n", *argv, tp);
X    ++argv;
X  } while (--argc);
X  return 0;
X}
END_OF_FILE
  if test 3327 -ne `wc -c <'nocol-3.0/src/tpmon/tptest.c'`; then
    echo shar: \"'nocol-3.0/src/tpmon/tptest.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/tpmon/tptest.c'
fi
echo shar: End of archive 23 \(of 26\).
cp /dev/null ark23isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
