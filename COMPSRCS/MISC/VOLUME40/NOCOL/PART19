Newsgroups: comp.sources.misc
From: vikas@jvnc.net (Vikas Aggarwal)
Subject: v40i149:  nocol - Network Monitoring System, Part19/26
Message-ID: <1993Nov23.212823.22031@sparky.sterling.com>
X-Md4-Signature: 1804dc18545fe7748b4f05494a3b13e1
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 23 Nov 1993 21:28:23 GMT
Approved: kent@sparky.sterling.com

Submitted-by: vikas@jvnc.net (Vikas Aggarwal)
Posting-number: Volume 40, Issue 149
Archive-name: nocol/part19
Environment: INET, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  nocol-3.0/src/INSTALL
#   nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c
#   nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h
#   nocol-3.0/src/cmu-snmp/man/snmp_api.3
#   nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h
#   nocol-3.0/src/doc/nocol-overview.8 nocol-3.0/src/genmon/genmon.c
#   nocol-3.0/src/lib/event_utils.c nocol-3.0/src/support/mping/MAIL
# Wrapped by kent@sparky on Tue Nov  9 22:22:23 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 19 (of 26)."'
if test -f 'nocol-3.0/src/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/INSTALL'\"
else
  echo shar: Extracting \"'nocol-3.0/src/INSTALL'\" \(8608 characters\)
  sed "s/^X//" >'nocol-3.0/src/INSTALL' <<'END_OF_FILE'
X## $Header: /home/aggarwal/lsrc/nocol/src/RCS/INSTALL,v 1.4 1993/11/03 22:38:32 aggarwal Exp $
X
XINSTALLATION INSTRUCTIONS FOR 'NOCOL'
X=====================================
X
XNOTE:  Please look at the file PORTING for special instructions that
X       might pertain to your operating system.
X
XNOTE:	You will have to install the PERL monitors manually (in perlnocol).
X	See the perlnocol/README for more information.
X
XMost/all of the configuration is done in the top level 'Makefile' (under
Xnocol/src). All customizable parameters are well documented. Edit this file
Xbefore typing 'make'.
X
XTo build only a subset of the monitoring programs, use the following syntax:
X
X   make TOP=/usr/nocol SRCDIR=`pwd` SRCS="netmon pingmon trapmon"
X
XSample config files are also provided for each monitor. These are copied
Xover in the nocol/etc/samples directory during installation. Copy these
Xto nocol/etc/ and edit for each monitor.
X
X
XMakefile
X--------
X1. Decide on a toplevel directory under which the software will be installed.
X   Define TOP to this toplevel directory.
X
X   Note that the program creates the following directories under this
X   toplevel directory:
X
X	    data		output from all the monitors
X	    bin			for installation of all the binaries
X	    etc			location of all the config files
X   It is advised that the location of these sudirectories be left as they
X   are. However, if you must make changes, then the various subdirectory
X   names can also be set individually in the Makefile.
X
X2. Set the value of SRCDIR to the location of the 'src' (current) directory.
X   By default the Makefile sets the value to TOP/src
X
X3. Set NEEDOBJS to the missing functions on your system. A list of provided
X   functions is provided in the Makefile (putenv.o bstring.o etc.).
X
X4. Set SYSLIBS to the libraries needed to link with on your system.
X   This is mainly for curses/resolver/bsd sockets. These are well 
X   documented in the Makefile.
X
X5. The 'pingmon' directory can generate the OSI version as well as the IP
X   version of the 'pingmon' monitor. If you want the OSI 'osipingmon' monitor
X   also, then set MAKEOSI to YES.
X
X   Set SYSDEFS to MULTIPING if you are using the multiple ping program for IP
X   'ippingmon'. Remember to set the value of IPPING to the location of this
X   ping program (multiping) also if you are defining this.
X   The 'multiping' program is located under 'src/support', and can ping
X   multiple sites simultaneously. Compile and install this program
X   separately. Make sure that it is installed 'suid' root in the location
X   specified by IPPING.
X
X   Set the value of IPPING and OSIPING to the exact location of the 'ping'
X   programs for IP and OSI (typically under /etc or /usr/etc). If the output
X   from the ping commands is as described below, then you are in luck, else
X   you will need to make minor modifications in the 'src/pingmon/poll_sites.c' 
X   module (the area to modify is well commented so it should be easy).
X
X	r2d2-vikas> /usr/etc/ping -s nisc.jvnc.net 1000  5 | tail -2
X	  5 packets transmitted, 5 packets received, 0% packet loss
X	  round-trip (ms)  min/avg/max = 4/4/5
X
X   If using 'multiping', the program automatically uses the '-t' option 
X   (for tabular output). No modifications are needed.
X
X6. Set the value of NLOG_HOST to be the host that receives all the
X   NOCOL log messages. Ideally, you should create a CNAME entry for
X   'nocol.your.domain' in your nameserver. The default logging port
X   is defined in 'noclog.h' to 5354. You can change it in the file
X   you desire some other port number (preferably >1023 so that the program
X   does not have to run as 'root').
X   Add the following line in your /etc/services:
X
X	noclog		5354/udp
X
X7. Set the definition of SRCS to the programs that you want to compile.
X   Check the values of CC (for the compiler type) and CFLAGS. Set INSTALL
X   to '$(SRCDIR)/utility/myinstall', if you have a new version of 
X   'install' on your system (the syntax is different on these). Use:
X
X	install -c -m 751 thisfile dest
X
X   to see if your 'install' is compatible.
X
X10. Type in:
X
X       % make 
X       % make install
X
X    It is advised to save the output of the make command to a temporary output
X    file so that it can be perused later for any errors.
X
X11. Install 'trapmon' (and 'multiping') as 'suid' root since they needs 
X    to access priveleged ports:
X
X	chown root.network  trapmon multiping
X	chmod 4710  trapmon multiping
X
X12. Copy the config files in the TOP/etc/samples directory to the TOP/etc
X    directory. List the hosts which can log to 'noclogd' in the config
X    file (make the directory for the log files if needed). Edit all other
X    config files.
X
X12. Miscellaneous:
X   - The sample 'TOP/bin/keepalive_monitors' program should be modified
X     and run from your crontab periodically (you can distribute the 
X     monitors on two systems and share the /nocol disk via NFS).
X     List all the monitors that you want to run in this file.
X
X   - edit the 'bin/notifier' program. This is useful to send email
X     when a site is in critical mode for an extended period of time.
X     Modify and put in your crontab to run once an hour.
X
X   - Remember to put an entry in your crontab to move the NOCOL log
X     files (or delete them) and send a HUP signal to the 'noclogd'
X     daemon every night.
X
X13. Test 'noclogd' by starting it up in debug mode (-d). See if it
X    complains about anything.
X    Start up the various monitors using 'keepalive_monitors'.
X    Use 'nocol -l 4' to see if any data is being collected under the 
X    DATA directory. Look in the TOP/etc/*.error files for any errors.
X
X14. You can add user 'nocol'  to your password file to allow anyone to
X    log in as user 'nocol' and see the state of the network. A typical
X    entry is:
X
X	nocol::65534:65534:JvNC NETMON:/tmp:/nocol/bin/nocol
X
X
XPERLNOCOL
X---------
X
XThere is a new PERL ('Pattern Extraction and Programming Language')
Xinterface for developing additional NOCOL monitors. To use this,
Xyou need to have PERL installed on your system (perl is available
Xfrom ftp.uu.net or from ftp.netlabs.com).
X
X1.  Edit perlnocol/nocollib.pl  and set the values of:
X	$nocolroot , $NLOG_HOST, $NLOG_PORT
X
X    Edit the location of the perl program on your system (the first line
X    in the perl scripts).
X
X2.  Watch out for the padding in the '$event_t'  template. Compilers tend
X    to align the fields of structures on even boundaries, so you might
X    have to add some additional 'null' padding using 'x'. Set
X    $libdebug = 1 to see the size of the $event structure. The size of
X    the data files produced by the C monitors should be a multiple of the
X    perl $event structure.
X
X3.  If the monitor that you want to run uses 'rcisco', then enter your 
X    router's password in it and install it in nocol/bin  with mode 710.
X    If the monitor uses 'snmpwalk', compile the applications under 
X    src/cmu-snmp/ and install it in nocol/bin. Edit the SNMP community
X    string to the perl script.
X
X4.  Create the config file.  You might need small adjustments to the
X    regular expressions in &dotest()  depending upon your site.
X
X
X5.  For troubleshooting, set the $debug and $libdebug values to '1'.
X
X
XTROUBLESHOOTING
X---------------
X
X1. Some warnings are to be expected, but there should be no major errors.
X
X2. If the errors are about include files or variable types, look for the file
X   that is being included under the  /usr/include sub-directories. The
X   various systems love to move include files back and forth between the
X   include and the include/sys directories (especially 'time.h').
X
X3. For the nameserver monitor, old versions of the resolver library might
X   complain. Some include files defined the '_res' variable differently, so
X   try changing all occurences of '_res.nsaddr' to '_res.nsaddr_list[0]'
X   in the src/nsmon/nsmon.c module (look in your /usr/include/resolv.h).
X   Make sure that the 'libresolv' library exists while linking.
X
X4. For trapmon, the CMU SNMP library is used. Make sure that it was properly
X   built under 'src/cmu-snmp/lib'
X
X5. Most monitors have a '-d' option for debugging, or create error
X   files in the TOP/etc.
X
X6. If you get a 'h_addr_list[0]' not defined error, simply edit 
X   nocol.h and add the following line in it:
X
X	#define h_addr 1
X
X  This is because of the difference in the hostent() structure of netdb.h
X  in very old systems.
X
XBest of luck. Comments to 'nocol-info@jvnc.net' and bugs to
X'nocol-bugs@jvnc.net'.
X
XREADME file has more information. For documentation on overview, look under
Xdoc/nocol-overview.8.
X
X
X	Vikas Aggarwal
X	Network Engineering
X	JvNCnet, GES
X	------------
X
END_OF_FILE
  if test 8608 -ne `wc -c <'nocol-3.0/src/INSTALL'`; then
    echo shar: \"'nocol-3.0/src/INSTALL'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/INSTALL'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c'\" \(8499 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c' <<'END_OF_FILE'
X/*
X * snmp_var_route.c - return a pointer to the named variable.
X *
X *
X */
X/***********************************************************
X	Copyright 1988, 1989 by Carnegie Mellon University
X	Copyright 1989	TGV, Incorporated
X
X		      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of CMU and TGV not be used
Xin advertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.
X
XCMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
XEVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
XUSE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
XPERFORMANCE OF THIS SOFTWARE.
X******************************************************************/
X
X#define GATEWAY			/* MultiNet is always configured this way! */
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include <syslog.h>
X#include <sys/mbuf.h>
X#include <net/if.h>
X#define KERNEL		/* to get routehash and RTHASHSIZ */
X#include <net/route.h>
X#undef	KERNEL
X#define rt_unit rt_hash		       /* Reuse this field for device # */
X#include <nlist.h>
X#ifndef NULL
X#define NULL 0
X#endif
X
X#define CACHE_TIME (120)	    /* Seconds */
X
X#include "asn1.h"
X#include "snmp.h"
X#include "snmp_impl.h"
X#include "mib.h"
X#include "snmp_vars.h"
X
Xstatic struct rtentry **rthead=0;
Xstatic int rtsize=0, rtalloc=0;
X
Xstatic struct nlist nl[] = {
X#define N_RTHOST       0
X	{ "_rthost" },
X#define N_RTNET        1
X	{ "_rtnet" },
X#define N_RTHASHSIZE	2
X	{ "_rthashsize" },
X	0,
X};
X
Xu_char *
Xvar_ipRouteEntry(vp, name, length, exact, var_len, access_method)
X    register struct variable *vp;   /* IN - pointer to variable entry that points here */
X    register oid	*name;	    /* IN/OUT - input name requested, output name found */
X    register int	*length;    /* IN/OUT - length of input and output strings */
X    int			exact;	    /* IN - TRUE if an exact match was requested. */
X    int			*var_len;   /* OUT - length of variable or 0 if function returned. */
X    int			*access_method; /* OUT - 1 if function, 0 if char pointer. */
X{
X    /*
X     * object identifier is of form:
X     * 1.3.6.1.2.1.4.21.1.1.A.B.C.D,  where A.B.C.D is IP address.
X     * IPADDR starts at offset 10.
X     */
X    register int Save_Valid, result, RtIndex;
X    static int saveNameLen=0, saveExact=0, saveRtIndex=0;
X    static oid saveName[14], Current[14];
X    u_char *cp;
X    oid *op;
X
X
X    /*
X     *	OPTIMIZATION:
X     *
X     *	If the name was the same as the last name, with the possible
X     *	exception of the [9]th token, then don't read the routing table
X     *
X     */
X
X    if ((saveNameLen == *length) && (saveExact == exact)) {
X	register int temp=name[9];
X	name[9] = 0;
X	Save_Valid = (compare(name, *length, saveName, saveNameLen) == 0);
X	name[9] = temp;
X    } else Save_Valid = 0;
X
X    if (Save_Valid) {
X	register int temp=name[9];    /* Fix up 'lowest' found entry */
X	bcopy((char *) Current, (char *) name, 14 * sizeof(oid));
X	name[9] = temp;
X	*length = 14;
X	RtIndex = saveRtIndex;
X    } else {
X	/* fill in object part of name for current (less sizeof instance part) */
X
X	bcopy((char *)vp->name, (char *)Current, (int)(vp->namelen - 4) * sizeof(oid));
X
X#if 0
X	/*
X	 *  Only reload if this is the start of a wildcard
X	 */
X	if (*length < 14) {
X	    Route_Scan_Reload();
X	}
X#else
X        Route_Scan_Reload();
X#endif
X	for(RtIndex=0; RtIndex < rtsize; RtIndex++) {
X	    cp = (u_char *)&(((struct sockaddr_in *) &(rthead[RtIndex]->rt_dst))->sin_addr.s_addr);
X	    op = Current + 10;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X	    *op++ = *cp++;
X
X	    result = compare(name, *length, Current, 14);
X	    if ((exact && (result == 0)) || (!exact && (result < 0)))
X		break;
X	}
X	if (RtIndex >= rtsize) return(NULL);
X	/*
X	 *  Save in the 'cache'
X	 */
X	bcopy((char *) name, (char *) saveName, *length * sizeof(oid));
X	saveName[9] = '\0';
X	saveNameLen = *length;
X	saveExact = exact;
X	saveRtIndex = RtIndex;
X	/*
X	 *  Return the name
X	 */
X	bcopy((char *) Current, (char *) name, 14 * sizeof(oid));
X	*length = 14;
X    }
X
X    *access_method = 0;
X    *var_len = sizeof(long_return);
X    switch(vp->magic){
X	case IPROUTEDEST:
X	    return(u_char *) &((struct sockaddr_in *) &rthead[RtIndex]->rt_dst)->sin_addr.s_addr;
X	case IPROUTEIFINDEX:
X	    long_return = rthead[RtIndex]->rt_unit;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC1:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_GATEWAY) ? 1 : 0;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC2:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC3:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTEMETRIC4:
X	    long_return = -1;
X	    return (u_char *)&long_return;
X	case IPROUTENEXTHOP:
X	    return(u_char *) &((struct sockaddr_in *) &rthead[RtIndex]->rt_gateway)->sin_addr.s_addr;
X	case IPROUTETYPE:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_GATEWAY) ? 4 : 3;
X	    return (u_char *)&long_return;
X	case IPROUTEPROTO:
X	    long_return = (rthead[RtIndex]->rt_flags & RTF_DYNAMIC) ? 4 : 2;
X	    return (u_char *)&long_return;
X	case IPROUTEAGE:
X	    long_return = 0;
X	    return (u_char *)&long_return;
X	default:
X	    ERROR("");
X   }
X   return NULL;
X}
X
Xinit_routes(){
X
X    nlist("/vmunix",nl);
X}
X
Xstatic Route_Scan_Reload()
X{
X	struct mbuf **routehash, mb;
X	register struct mbuf *m;
X	struct ifnet ifnet;
X	struct rtentry *rt;
X	int i, table, qsort_compare();
X	register char *cp;
X	char name[16], temp[16];
X	static int Time_Of_Last_Reload=0;
X	struct timeval now;
X	int hashsize;
X
X	gettimeofday(&now, (struct timezone *)0);
X	if (Time_Of_Last_Reload+CACHE_TIME > now.tv_sec)
X	    return;
X	Time_Of_Last_Reload =  now.tv_sec;
X
X	/*
X	 *  Makes sure we have SOME space allocated for new routing entries
X	 */
X	if (!rthead) {
X	    rthead = (struct rtentry **) malloc(100 * sizeof(struct rtentry *));
X	    bzero((char *)rthead, 100 * sizeof(struct rtentry *));
X	    rtalloc = 100;
X	}
X
X	for (table=N_RTHOST; table<=N_RTNET; table++) {
X	    klseek(nl[N_RTHASHSIZE].n_value);
X	    klread((char *)&hashsize, sizeof(hashsize));
X	    routehash = (struct mbuf **)malloc(hashsize * sizeof(struct mbuf *));
X	    klseek(nl[table].n_value);
X	    klread((char *)routehash, hashsize * sizeof(struct mbuf *));
X	    for (i = 0; i < hashsize; i++) {
X		if (routehash[i] == 0)
X			continue;
X		m = routehash[i];
X		while (m) {
X		    /*
X		     *	Dig the route out of the kernel...
X		     */
X		    klseek(m);
X		    klread(&mb, sizeof (mb));
X		    m = mb.m_next;
X		    rt = mtod(&mb, struct rtentry *);
X		    if (rt->rt_ifp != 0) {
X			klseek(rt->rt_ifp);
X			klread((char *)&ifnet, sizeof (ifnet));
X			klseek((int)ifnet.if_name);
X			klread(name, 16);
X			name[15] = '\0';
X			cp = (char *) index(name, '\0');
X			*cp++ = ifnet.if_unit + '0';
X			*cp = '\0';
X/*			if (strcmp(name,"lo0") == 0) continue; */
X			Interface_Scan_Init();
X			while (Interface_Scan_Next(&rt->rt_unit, temp, 0, 0) != 0) {
X			    if (strcmp(name, temp) == 0) break;
X			}
X		    }
X		    /*
X		     *	Allocate a block to hold it and add it to the database
X		     */
X		    if (rtsize >= rtalloc) {
X			rthead = (struct rtentry **) realloc((char *)rthead, 2 * rtalloc * sizeof(struct rtentry *));
X			bzero((char *) &rthead[rtalloc], rtalloc * sizeof(struct rtentry *));
X			rtalloc *= 2;
X		    }
X		    if (!rthead[rtsize])
X			rthead[rtsize] = (struct rtentry *) malloc(sizeof(struct rtentry));
X		    /*
X		     *	Add this to the database
X		     */
X		    bcopy((char *)rt, (char *)rthead[rtsize], sizeof(struct rtentry));
X		    rtsize++;
X		}
X	    }
X	}
X	/*
X	 *  Sort it!
X	 */
X	qsort((char *)rthead,rtsize,sizeof(rthead[0]),qsort_compare);
X}
X
X
X
X/*
X *	Create a host table
X */
Xstatic int qsort_compare(r1,r2)
Xstruct rtentry **r1, **r2;
X{
X	register u_long dst1 = ntohl(((struct sockaddr_in *) &((*r1)->rt_dst))->sin_addr.s_addr);
X	register u_long dst2 = ntohl(((struct sockaddr_in *) &((*r2)->rt_dst))->sin_addr.s_addr);
X
X	/*
X	 *	Do the comparison
X	 */
X	if (dst1 == dst2) return(0);
X	if (dst1 > dst2) return(1);
X	return(-1);
X}
END_OF_FILE
  if test 8499 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmp_var_route.c'
fi
if test -f 'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h'\" \(151 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h' <<'END_OF_FILE'
X
X#ifndef MAXHOSTNAMELEN
X#define MAXHOSTNAMELEN	64
X#endif
X
X
Xextern char *community;
Xextern struct sockaddr_in address;
Xextern int reqid;
Xextern int sd;
END_OF_FILE
  if test 151 -ne `wc -c <'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/apps/snmpnetstat/main.h'
fi
if test -f 'nocol-3.0/src/cmu-snmp/man/snmp_api.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/man/snmp_api.3'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/man/snmp_api.3'\" \(8220 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/man/snmp_api.3' <<'END_OF_FILE'
X.\* /***********************************************************
X.\" 	Copyright 1989 by Carnegie Mellon University
X.\" 
X.\"                       All Rights Reserved
X.\" 
X.\" Permission to use, copy, modify, and distribute this software and its 
X.\" documentation for any purpose and without fee is hereby granted, 
X.\" provided that the above copyright notice appear in all copies and that
X.\" both that copyright notice and this permission notice appear in 
X.\" supporting documentation, and that the name of CMU not be
X.\" used in advertising or publicity pertaining to distribution of the
X.\" software without specific, written prior permission.  
X.\" 
X.\" CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
X.\" ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
X.\" CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
X.\" ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X.\" WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
X.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
X.\" SOFTWARE.
X.\" ******************************************************************/
X.TH SNMP_API 3 "Sept 17, 1989"
X.UC 5
X.SH NAME
Xsnmp_open, snmp_close, snmp_send, snmp_read, snmp_free_pdu, snmp_select_info, snmp_timeout \- send and receive SNMP messages
X.SH SYNOPSIS
X.B "#include <sys/types>
X.br
X.B "#include <netinet/in.h>
X.br
X.B "#include <sys/time.h>
X.br
X.B #include """snmp.h""
X.br
X.B #include """snmp_impl.h""
X.br
X.B #include """asn1.h""
X.br
X.B #include """snmp_api.c""
X.PP
X.B "extern int snmp_errno;
X.PP
X.B "struct snmp_session *snmp_open(session)
X.br
X.B "struct snmp_session *session;
X.PP
X.B "int snmp_close(session)
X.br
X.B "struct snmp_session *session;
X.PP
X.B "int snmp_send(session, pdu)
X.br
X.B "struct snmp_session *session;
X.br
X.B "struct snmp_pdu *pdu;
X.PP
X.B "void snmp_read(fdset)
X.br
X.B "fd_set *fdset;
X.PP
X.B "int snmp_select_info(numfds, fdset, timeout, block)
X.br
X.B "int *numfds;
X.br
X.B "fd_set *fdset;
X.br
X.B "struct timeval *timeout;
X.br
X.B "int *block;
X.PP
X.B "void snmp_timeout()
X.PP
X.B "void snmp_free_pdu(pdu)
X.br
X.B "struct snmp_pdu *pdu;
X.PP
X.SH DESCRIPTION
X.I Snmp_open, snmp_close,
Xand
X.I snmp_send
Xeach take as input a pointer to an object with the
Xfollowing structure.  In addition,
X.I snmp_open
Xalso returns a pointer to an object with this structure.
XThis structure contains information for a set of transactions that
Xwill share similar transport characteristics.
X.RS
X.PP
X.nf
Xtypedef struct sockaddr_in  ipaddr;
X
Xstruct snmp_session {
X    u_char  *community;	/* community for outgoing requests. */
X    int	    community_len;  /* Length of community name. */
X    int	    retries;	/* Number of retries before timeout. */
X    long    timeout;    /* Number of uS until first timeout, then exponential backoff */
X    char    *peername;	/* Domain name or dotted IP address of default peer */
X    u_short remote_port;/* UDP port number of peer. */
X    u_short local_port; /* My UDP port number, 0 for default, picked randomly */
X
X    /* Authentication function or NULL if null authentication is used */
X    u_char  *(*authenticator)();
X
X    int	    (*callback)();  /* Function to interpret incoming data */
X
X    /* Pointer to data that the callback function may consider important */
X    void    *callback_magic;
X};
X
X/*
X * Set fields in session and pdu to the following to get a default or unconfigured value.
X */
X#define SNMP_DEFAULT_COMMUNITY_LEN  0/* for default community name */
X#define SNMP_DEFAULT_RETRIES	    -1
X#define SNMP_DEFAULT_TIMEOUT	    -1
X#define SNMP_DEFAULT_REMPORT	    0
X#define SNMP_DEFAULT_REQID	    0
X#define SNMP_DEFAULT_ERRSTAT	    -1
X#define SNMP_DEFAULT_ERRINDEX	    -1
X#define SNMP_DEFAULT_ADDRESS	    0
X#define SNMP_DEFAULT_PEERNAME	    NULL
X#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
X#define SNMP_DEFAULT_TIME	    0
X
X/*
X * This routine must be supplied by the application:
X *
X * u_char *authenticator(pdu, length, community, community_len)
X * u_char *pdu;		The rest of the PDU to be authenticated
X * int *length;		The length of the PDU (updated by the authenticator)
X * u_char *community;	The community name to authenticate under.
X * int	community_len	The length of the community name.
X *
X * Returns the authenticated pdu, or NULL if authentication failed.
X * If null authentication is used, the authenticator in snmp_session can be
X * set to NULL(0).
X */
X
X/*
X * This routine must be supplied by the application:
X *
X * int callback(operation, session, reqid, pdu, magic)
X * int operation;
X * struct snmp_session *session;    The session authenticated under.
X * int reqid;			    The request id of this pdu (0 for TRAP)
X * struct snmp_pdu *pdu;	    The pdu information.
X * void *magic			    A link to the data for this routine.
X *
X * Returns 1 if request was successful, 0 if it should be kept pending.
X * Any data in the pdu must be copied because it will be freed elsewhere.
X * Operations are defined below:
X */
X#define RECEIVED_MESSAGE   1
X#define TIMED_OUT	   2
X.ft R
X.ad
X.fi
X.RE
X.PP
X.I Snmp_send
Xand
X.I snmp_free_pdu
Xeach take as input a pointer to an object with the
Xfollowing structure.
XThis structure contains information that describes a transaction
Xthat will be performed over an open session.
X.RS
X.PP
X.nf
Xstruct snmp_pdu {
X    ipaddr  address;	/* Address of peer */
X
X    int	    command;	/* Type of this PDU */
X
X    u_long  reqid;	/* Request id */
X    u_long  errstat;	/* Error status */
X    u_long  errindex;	/* Error index */
X
X    /* Trap information */
X    oid	    *enterprise;/* System OID */
X    int	    enterprise_length;
X    ipaddr  agent_addr;	/* address of object generating trap */
X    int	    trap_type;	/* trap type */
X    int	    specific_type;  /* specific type */
X    u_long  time;	/* Uptime */
X
X    struct variable_list *variables;
X};
X
X
Xstruct variable_list {
X    struct variable_list *next_variable;    /* NULL for last variable */
X    oid	    *name;  /* Object identifier of variable */
X    int	    name_length;    /* number of subid's in name */
X    u_char  type;   /* ASN type of variable */
X    union { /* value of variable */
X	long	*integer;
X	u_char	*string;
X	oid	*objid;
X    } val;
X    int	    val_len;
X};
X.ft R
X.ad
X.fi
X.RE
X.PP
X.I Snmp_read, snmp_select_info,
Xand
X.I snmp_timeout
Xprovide an interface for the use of the
X.IR select (2)
Xsystem call so that SNMP transactions can occur asynchronously.
X.PP
X.I Snmp_select_info
Xis given the information that would have been passed to
X.I select
Xin the absence of SNMP.  For example, this might include window update information.
XThis information is modified so that SNMP will get the service it requires from the
Xcall to
X.I select.
XIn this case,
X.I numfds, fdset,
Xand
X.I timeout
Xcorrespond to the
X.I nfds, readfds,
Xand
X.I timeout
Xarguments to
X.I select,
Xrespectively.  The only exception is that timeout must always point to an allocated (but perhaps uninitialized)
X.I struct timeval.
XIf
X.I timeout
Xwould have been passed as NULL,
X.I block
Xis set to true, and
X.I timeout
Xis treated as undefined.  This same rule applies upon return from
X.I snmp_select_info.
X.PP
XAfter calling
X.I snmp_select_info, select
Xis called with the returned data.  When select returns,
X.I snmp_read
Xis called with the
X.I fd_set
Xreturned from
X.I select.
XThis will read all SNMP sockets with input.
XIf
X.I select
Xtimes out,
X.I snmp_timeout
Xshould be called to see if the timeout was intended for SNMP.
X.SH DIAGNOSTICS
X.PP
XError return status from 
X.I snmp_open
Xis indicated by return of a null pointer.
XError return status from 
X.I snmp_close
Xand
X.I snmp_send
Xis indicated by return of 0.  A successful status will return a 1.
XThe external integer
X.IR snmp_errno
Xmay then be checked to see what type of error has occurred
X.PP
X.IR snmp_errno
Xcan have the following values:
X.RS
X.IP SNMPERR_GENERR \w'SNMPERR_BAD_LOCPORT'u+2n
XA generic error occurred.
X.IP SNMPERR_BAD_LOCPORT \w'SNMPERR_BAD_LOCPORT'u+2n
XThe local port was bad because it had already been
Xallocated or permission was denied.
X.IP SNMPERR_BAD_ADDRESS \w'SNMPERR_BAD_LOCPORT'u+2n
XThe host name or address given was not useable.
X.IP SNMPERR_BAD_SESSION \w'SNMPERR_BAD_SESSION'u+2n
XThe specified session was not open.
X.RE
X.SH "SEE ALSO"
Xselect(2), snmp_api.h
END_OF_FILE
  if test 8220 -ne `wc -c <'nocol-3.0/src/cmu-snmp/man/snmp_api.3'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/man/snmp_api.3'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/man/snmp_api.3'
fi
if test -f 'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h'\"
else
  echo shar: Extracting \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h'\" \(8565 characters\)
  sed "s/^X//" >'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h' <<'END_OF_FILE'
X/***********************************************************
X	Copyright 1989 by Carnegie Mellon University
X
X                      All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the name of CMU not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XCMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XCMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X******************************************************************/
X/*
X * snmp_api.h - API for access to snmp.
X */
X
X
Xtypedef struct sockaddr_in  ipaddr;
X
Xstruct snmp_session {
X    u_char  *community;	/* community for outgoing requests. */
X    int	    community_len;  /* Length of community name. */
X    int	    retries;	/* Number of retries before timeout. */
X    long    timeout;    /* Number of uS until first timeout, then exponential backoff */
X    char    *peername;	/* Domain name or dotted IP address of default peer */
X    u_short remote_port;/* UDP port number of peer. */
X    u_short local_port; /* My UDP port number, 0 for default, picked randomly */
X    /* Authentication function or NULL if null authentication is used */
X    u_char    *(*authenticator)();
X    int	    (*callback)();  /* Function to interpret incoming data */
X    /* Pointer to data that the callback function may consider important */
X    void    *callback_magic;
X};
X
X/*
X * Set fields in session and pdu to the following to get a default or unconfigured value.
X */
X#define SNMP_DEFAULT_COMMUNITY_LEN  0	/* to get a default community name */
X#define SNMP_DEFAULT_RETRIES	    -1
X#define SNMP_DEFAULT_TIMEOUT	    -1
X#define SNMP_DEFAULT_REMPORT	    0
X#define SNMP_DEFAULT_REQID	    0
X#define SNMP_DEFAULT_ERRSTAT	    -1
X#define SNMP_DEFAULT_ERRINDEX	    -1
X#define SNMP_DEFAULT_ADDRESS	    0
X#define SNMP_DEFAULT_PEERNAME	    NULL
X#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
X#define SNMP_DEFAULT_TIME	    0
X
Xextern int snmp_errno;
X/* Error return values */
X#define SNMPERR_GENERR		-1
X#define SNMPERR_BAD_LOCPORT	-2  /* local port was already in use */
X#define SNMPERR_BAD_ADDRESS	-3
X#define SNMPERR_BAD_SESSION	-4
X#define SNMPERR_TOO_LONG	-5
X
X
Xstruct snmp_pdu {
X    ipaddr  address;	/* Address of peer */
X
X    int	    command;	/* Type of this PDU */
X
X    u_long  reqid;	/* Request id */
X    u_long  errstat;	/* Error status */
X    u_long  errindex;	/* Error index */
X
X    /* Trap information */
X    oid	    *enterprise;/* System OID */
X    int	    enterprise_length;
X    ipaddr  agent_addr;	/* address of object generating trap */
X    int	    trap_type;	/* trap type */
X    int	    specific_type;  /* specific type */
X    u_long  time;	/* Uptime */
X
X    struct variable_list *variables;
X};
X
X
Xstruct variable_list {
X    struct variable_list *next_variable;    /* NULL for last variable */
X    oid	    *name;  /* Object identifier of variable */
X    int	    name_length;    /* number of subid's in name */
X    u_char  type;   /* ASN type of variable */
X    union { /* value of variable */
X	long	*integer;
X	u_char	*string;
X	oid	*objid;
X    } val;
X    int	    val_len;
X};
X
X/*
X * struct snmp_session *snmp_open(session)
X *	struct snmp_session *session;
X * 
X * Sets up the session with the snmp_session information provided
X * by the user.  Then opens and binds the necessary UDP port.
X * A handle to the created session is returned (this is different than
X * the pointer passed to snmp_open()).  On any error, NULL is returned
X * and snmp_errno is set to the appropriate error code.
X */
Xstruct snmp_session *snmp_open();
X
X/*
X * int snmp_close(session)
X *     struct snmp_session *session;
X * 
X * Close the input session.  Frees all data allocated for the session,
X * dequeues any pending requests, and closes any sockets allocated for
X * the session.  Returns 0 on error, 1 otherwise.
X */
Xint snmp_close();
X
X
X/*
X * int snmp_send(session, pdu)
X *     struct snmp_session *session;
X *     struct snmp_pdu	*pdu;
X * 
X * Sends the input pdu on the session after calling snmp_build to create
X * a serialized packet.  If necessary, set some of the pdu data from the
X * session defaults.  Add a request corresponding to this pdu to the list
X * of outstanding requests on this session, then send the pdu.
X * Returns the request id of the generated packet if applicable, otherwise 1.
X * On any error, 0 is returned.
X * The pdu is freed by snmp_send() unless a failure occured.
X */
Xint snmp_send();
X
X
X/*
X * void snmp_read(fdset)
X *     fd_set  *fdset;
X * 
X * Checks to see if any of the fd's set in the fdset belong to
X * snmp.  Each socket with it's fd set has a packet read from it
X * and snmp_parse is called on the packet received.  The resulting pdu
X * is passed to the callback routine for that session.  If the callback
X * routine returns successfully, the pdu and it's request are deleted.
X */
Xvoid snmp_read();
X
X
X/*
X * void
X * snmp_free_pdu(pdu)
X *     struct snmp_pdu *pdu;
X * 
X * Frees the pdu and any malloc'd data associated with it.
X */
Xvoid snmp_free_pdu();
X
X/*
X * int snmp_select_info(numfds, fdset, timeout, block)
X * int *numfds;
X * fd_set   *fdset;
X * struct timeval *timeout;
X * int *block;
X *
X * Returns info about what snmp requires from a select statement.
X * numfds is the number of fds in the list that are significant.
X * All file descriptors opened for SNMP are OR'd into the fdset.
X * If activity occurs on any of these file descriptors, snmp_read
X * should be called with that file descriptor set.
X *
X * The timeout is the latest time that SNMP can wait for a timeout.  The
X * select should be done with the minimum time between timeout and any other
X * timeouts necessary.  This should be checked upon each invocation of select.
X * If a timeout is received, snmp_timeout should be called to check if the
X * timeout was for SNMP.  (snmp_timeout is idempotent)
X *
X * Block is 1 if the select is requested to block indefinitely, rather than time out.
X * If block is input as 1, the timeout value will be treated as undefined, but it must
X * be available for setting in snmp_select_info.  On return, if block is true, the value
X * of timeout will be undefined.
X *
X * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
X */
Xint snmp_select_info();
X
X/*
X * void snmp_timeout();
X * 
X * snmp_timeout should be called whenever the timeout from snmp_select_info expires,
X * but it is idempotent, so snmp_timeout can be polled (probably a cpu expensive
X * proposition).  snmp_timeout checks to see if any of the sessions have an
X * outstanding request that has timed out.  If it finds one (or more), and that
X * pdu has more retries available, a new packet is formed from the pdu and is
X * resent.  If there are no more retries available, the callback for the session
X * is used to alert the user of the timeout.
X */
Xvoid snmp_timeout();
X
X
X/*
X * This routine must be supplied by the application:
X *
X * u_char *authenticator(pdu, length, community, community_len)
X * u_char *pdu;		The rest of the PDU to be authenticated
X * int *length;		The length of the PDU (updated by the authenticator)
X * u_char *community;	The community name to authenticate under.
X * int	community_len	The length of the community name.
X *
X * Returns the authenticated pdu, or NULL if authentication failed.
X * If null authentication is used, the authenticator in snmp_session can be
X * set to NULL(0).
X */
X
X/*
X * This routine must be supplied by the application:
X *
X * int callback(operation, session, reqid, pdu, magic)
X * int operation;
X * struct snmp_session *session;    The session authenticated under.
X * int reqid;			    The request id of this pdu (0 for TRAP)
X * struct snmp_pdu *pdu;	    The pdu information.
X * void *magic			    A link to the data for this routine.
X *
X * Returns 1 if request was successful, 0 if it should be kept pending.
X * Any data in the pdu must be copied because it will be freed elsewhere.
X * Operations are defined below:
X */
X#define RECEIVED_MESSAGE   1
X#define TIMED_OUT	   2
X
X
Xextern int snmp_dump_packet;
END_OF_FILE
  if test 8565 -ne `wc -c <'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h'`; then
    echo shar: \"'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/cmu-snmp/snmplib/snmp_api.h'
fi
if test -f 'nocol-3.0/src/doc/nocol-overview.8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/doc/nocol-overview.8'\"
else
  echo shar: Extracting \"'nocol-3.0/src/doc/nocol-overview.8'\" \(8941 characters\)
  sed "s/^X//" >'nocol-3.0/src/doc/nocol-overview.8' <<'END_OF_FILE'
X.\" $Header: /home/aggarwal/lsrc/nocol/src/doc/RCS/nocol-overview.8,v 1.6 1993/10/28 16:38:03 aggarwal Exp $
X.\"
X.TH NOCOL-OVERVIEW 8 "October 1, 1993"
X.SH NAME
Xnocol-overview \- Unix based network monitoring package.
X.SH SYNOPSIS
XThis is an overview of the NOCOL software. See
X.IR nocol-prog (3)
Xfor more information on the design and initiatives behind NOCOL.
X.SH DESCRIPTION
X.LP
X.B NOCOL
X.I (Network Operations Center On-Line)
Xis a collection of network monitoring programs that run on Unix systems.
XThe software consists of a number of monitoring agents that poll various
Xparameters from any system and put it in a format suitable for
Xpost-processing. The post-processors can be a 
X.I display
Xagent, an automated
X.I troubleshooting
Xprogram, an event
X.I logging
Xprogram, etc. Presently, monitors for tracking
X.I reachability, SNMP traps, data throughput rate,
Xand
X.I nameservers
Xhave been developed and are in use. Addition of more monitoring agents is
Xeasy and they will be added as necessary. A display agent-
X.IR nocol (1)
Xusing curses displays the data generated by the various monitoring
Xagents. A logging daemon (similar to syslogd) logs events from the
Xvarious monitors and can optionally run a program  (for automatic
Xtroubleshooting or notification).
X
XAll data collected by the monitoring agents follows a fixed (non-readable)
Xformat. Each data entry is termed an
X.I event
Xin NOCOL, and each event has certain flags and 
X.I severity
Xassociated with it. 
X
XThe display agent
X.IR nocol (1),
Xdisplays the output of these monitoring agents depending on the severity
Xof the event. There can be multiple displays running simultaneously and all
Xof these process and display the same set of monitored data.
X
XThere are four levels of 
X.I severity
Xassociated with an event- CRITICAL, ERROR, WARNING and INFO. The severity
Xlevel is controlled independently by the monitoring agents, and the decision
Xto raise or set an event's severity to any level depends on the logic
Ximbedded in the monitoring agent.
X
XAs an example, for the 
X.BR pingmon (8)
Xmonitor, if a site is unreachable via
X.IR ping ,
Xit would be assigned a severity of WARNING by pingmon, which would then elevate
Xto CRITICAL if the site is still unreachable after some time. In the case of
X.BR trapmon (8),
Xan SNMP trap message of
X.I EGP neighbor lost
Xwould be directly assigned a severity level of CRITICAL, while an 
X.I Warm Start
Xtrap is assigned a severity of WARNING.
X
XThe display agent (and other data post-processors) use this event
Xseverity to decide whether to display it (or troubleshoot/log it) depending
Xon the user selected \fIdisplay\fR severity level.
X
XThe software is very flexible and modular, which allows enhancements and 
Xdevelopment with a minimum amount of effort. 
XThe display module processes all the files
Xpresent in the data directory, and displays them sequentially. This
Xallows new monitoring programs to simply start generating data in the data
Xdirectory and the display module will automatically start displaying the new
Xdata. The monitoring tools can be changed, and the only element that has to
Xremain common between all the modules is the EVENT data structure.
X
X.SH CURRENT MODULES
XThe NOCOL package presently consists of the following modules:
X.IP nocol
Xwhich simply \fIdisplays\fR the data collected by the monitoring agents. 
XIt uses the
X.I curses
Xscreen management system to support a wide variety of terminal types. The
Xcriterion for displaying an event is:
X.RS
X.TP 3
X1.
XSeverity level of the \fIevent\fR is higher than the severity level set in
Xthe \fIdisplay\fR.
X.TP 3
X2.
XThe display filter (if set) matches some string in the event line.
X.RE
X.IP
XThe display can be in regular 80 column mode or in extended 132 column mode.
XCritical events are displayed in reverse video (if the terminal type supports
Xit). Additional features like displaying informational
Xmessages in a part of the window, automatic resizing window sizes, operator
Xacknowledgement via a bell when a new event goes critical are also available.
X
X.IP ippingmon
Xwhich monitors the reachability of a site via "ICMP" ping packets (ICMP was
Xpreferred over SNMP for many obvious reasons). 
XThis program can use the default output from the system's 
X.I ping
Xprogram, but an accompanying program (
X.IR multiping )
Xcan ping multiple IP sites at the same time and is preferable for monitoring
Xa large list of sites.
XA site is marked unreachable if the number of lost packets exceeds a fixed
Xthreshold (set to 3 out of 10 sent), and the
Xseverity level is increased each time that the site tests as  unreachable.
X.IP osipingmon
Xwhich is similar to the 
X.I ippingmon
Xmodule but uses the OSI \fIping\fR program instead. No multiple ping program
Xfor OSI sites has been developed at this time. The only requirement is that
Xthe system's \fIping\fR program output match the typical BSD IP ping
Xprogram's output.
X.IP nsmon
Xwhich monitors the nameservers (
X.IR named )
Xon the list of specified hosts. It periodically sends an SOA query for the
Xdefault domain and if the queried nameservers cannot resolve the query, then
Xthe site is elevated to CRITICAL status.
X.IP tpmon
XFor monitoring the throughput (kbits per second) to a list of hosts. The
Xprogram connects to the discard socket on the remote machine (using a STREAM
Xsocket) and sends large packets for a small amount of time to evaluate the
Xeffective throughput. It elevates a site to WARNING level if the throughput
Xdrops below a certain threshold (set in the configuration file).
X.IP trapmon
XConverts all SNMP traps into a format suitable for displaying using NOCOL.
XThe severity of the various traps is preset (and can be changed during
Xcompilation time).
X.IP noclogd
XThis is the NOCOL logging daemon. It listens on a UDP port for the various
Xmonitors to log events to it. It then writes out the event (in text line
Xformat), to various log files specified in a configuration file. Alternatively,
Xit can pipe the text line to a program specified in the config file (this
Xfacilitates automatic notification, troubleshooting, etc.).
X.IP genmon
XThis is a generic monitor interface for adding additional monitors. It
Xreads in text lines (in the 
X.IR noclogd (8)
Xformat) and writes them in the NOCOL datafile format. It is meant to
Xfacilitate development of additional monitors.
X.IP eventselect
XThis program parses all the NOCOL datafiles specified on the command line
Xand extracts those events that match the criterion specified on the
Xcommand line. The events can be selected by sendername, severity, time
Xor variable name. This process can be run periodically from the 
X.IR cron (1)
Xand be used to do any postprocessing (sending email, page
Xsomeone)  if a site is in critical state for a period of time, etc.
X.IP perlnocol
XThere is a collection of utility PERL routines (library) called
X.I nocollib.pl
Xthat can be used to develop monitors in the PERL programming language.
XMonitors for Novell routes,  appletalk routes,  bootp servers, modem
Xline usage on cisco terminal-servers  have been developed and included.
XThese might require slight changes for your environment. See
X.IR perlnocol (8).
X
X.SH PLATFORM
X.LP
XAny Unix system with the 
X.I curses
Xscreen management library and IP
X.I (Internet Protocol)
Xprogramming facility. Sockets are needed for the logging facility.
XIt has been tested on Sun Sparc 4.1.1, Ultrix, and
XNeXT systems. Porting to other platforms might require minor adjustments
Xdepending on the vagaries of the different vendors (mostly in the include
Xfiles).
X.SH AVAILABILITY
X.LP
X.B NOCOL
Xwas developed at JvNCnet and has been in use for monitoring the JvNCnet
Xwide area network since 1989.
X.br
XIt is available via anonymous FTP from
X.I ftp.jvnc.net
Xunder
X.IR pub/jvncnet-packages/nocol.tar.Z .
XThe system running at JvNCet can be viewed by logging into the host
X.I nocol.jvnc.net
Xwith username
X.I nocol
X(an \fIrlogin\fR instead of \fItelnet\fR will handle your X window terminal
Xtypes better).
X.br
XTo be added to the NOCOL mailing list (for future updates and bug fixes),
Xsend a message to
X.B nocol-users-request@jvnc.net
Xwith your email address.
X.SH FUTURE DEVELOPMENTS
X.LP
XPossible future enhancements are:
X.RS
X.TP 3
X1.
XMonitors for ethernet traffic (load, errors, etc.)
X.TP 3
X2.
XSNMP monitors to watch the state of certain variables 
X.RI ( "interface errors,"
X.IR "packet rate, route state changes" ).
X.RE
X.\"--------------------------------------------
X.SH AUTHOR
XThe software was developed at JvNCnet over a period of time. The overall
Xdesign and initial development was done by Vikas Aggarwal and Sze-Ying Wuu.
XAdditional development is being done and coordinated by Vikas Aggarwal
X(vikas@jvnc.net). Perl monitors contributed by John Wobus at Syracuse
XUniversity.
X.br
XCopyright 1992 JvNCnet. (See the file \fICOPYRIGHT\fR for full details)
X.SH SEE ALSO
Xnocol(1) nocol-prog(3) perlnocol(3)
Xeventselect(8) genmon(8) noclogd(8) nocol-overview(8)
Xnocol-utility(8) nsmon(8) pingmon(8) portmon(8) 
Xtpmon(8) trapmon(8)
X
END_OF_FILE
  if test 8941 -ne `wc -c <'nocol-3.0/src/doc/nocol-overview.8'`; then
    echo shar: \"'nocol-3.0/src/doc/nocol-overview.8'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/doc/nocol-overview.8'
fi
if test -f 'nocol-3.0/src/genmon/genmon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/genmon/genmon.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/genmon/genmon.c'\" \(8179 characters\)
  sed "s/^X//" >'nocol-3.0/src/genmon/genmon.c' <<'END_OF_FILE'
X/* $Header: /home/aggarwal/lsrc/nocol/src/genmon/RCS/genmon.c,v 1.2 1993/10/30 03:20:39 aggarwal Exp $ */
X
X/* Copyright 1993 JvNCnet, Global Enterprise Services */
X
X/*+ 
X * FUNCTION:
X * 	A generic monitor for nocol, to allow people to develop
X * monitors using shell scripts, etc.
X *
X * Does the initial opening of the datafile,
X * etc. and then does a popen() to the  program specified on the
X * command line. Reads back data line by line from the program and
X * stuffs it into the NOCOL structure and writes out the structure to
X * the datafile.
X *
X * Without any command line arguments, it acts like a filter, reading
X * NOCOL text lines from stdin and writing out the structure to stdout.
X *
X * Recognizes two additional keywords-  LOG and APPEND.  'LOG' means
X * that this program should do an eventlog()  and APPEND means to add
X * at the end of the existing DATAFILE on open(). Typically, the program
X * overwrites the datafile each time.
X *
X * AUTHOR:
X *
X *	Vikas Aggarwal, vikas@jvnc.net
X *
X */
X
X/*+ 
X * $Log: genmon.c,v $
X * Revision 1.2  1993/10/30  03:20:39  aggarwal
X * Added copyright.
X *
X * Revision 1.1  1993/10/08  19:16:55  aggarwal
X * Initial revision
X *
X *
X *
X */
X#include "nocol.h"
X#include <sys/file.h>			/* for access() defines */
X#include <string.h>
X
X#ifndef SLEEPTIME
X# define SLEEPTIME  15			/* after each popen()  */
X#endif
X
Xstatic int   debugflag;
Xstatic char  *myname, *pidfile, *datafile ;
Xstatic char  *execprogpath, *execprog, *execargs ; /* program to be executed */
Xextern char *skip_spaces() ;		/* in libnocol */
X
Xmain (ac, av)
X     int ac;
X     char **av;
X{
X    extern char *optarg;
X    extern int  optind;
X    int         c;
X
X    myname = av[0] ;
X
X    while ((c = getopt(ac, av, "da:e:")) != EOF)
X      switch(c)
X      {
X       case 'd':
X          debugflag++;
X          break;
X       case 'a':
X          execargs = optarg ;		/* command line args to execprog */
X          break ;
X       case 'e':
X	  execprogpath = optarg ;	/* full path to prog being run */
X          break ;
X       case '?':
X       default:
X          fprintf(stderr, "%s: Unknown flag: %c\n", myname, optarg);
X          fprintf(stderr, "Usage: %s [-d] [-e <prog to exec>] ", myname);
X          fprintf(stderr, "[-a <'args to above prog'>]\n");
X	  fprintf(stderr, "OR: use as filter in a pipe process flow\n");
X          exit (1);
X      }
X
X    switch ( ac - optind )
X    {
X     case 0:                                    /* default input file */
X        break ;
X     default:
X        fprintf (stderr, "%s: Bad arg '%s'\nUse -h for help, exiting\n",
X		 myname, av[optind]);
X    }
X
X    if (debugflag)
X#ifndef DEBUG
X      fprintf(stderr,"%s: WARNING- program NOT compiled with DEBUG option\n",
X	      myname);
X#else
X    fprintf(stderr, "%s: Debug turned on\n", myname);
X#endif
X
X    if (debugflag)
X      fprintf(stderr, "(debug) %s:  execprogpath= '%s', execargs= '%s'\n\n",
X	      myname, execprogpath, execargs);
X
X    if (execprogpath != NULL && *execprogpath != '\0')
X      mastermode();
X    else			/* read from stdin  */
X      slavemode() ;
X
X}	/* end:  main()  */
X
X/*+ 
X * FUNCTION:
X * 	If this program is going to run the program specified on the
X * command line (execprogpath). Creates PIDFILE, and daemonizes.
X */
Xmastermode()
X{
X    int  fd ;	    	/* data file descriptor */
X    char *pf ;		/* pid filename ptr */
X    char cmd[1024];	/* command to be run */
X    FILE *cmdf ;	/* for popen() */
X
X    if (access(execprogpath, F_OK | X_OK) != 0) /* check if prog executable  */
X    {
X	fprintf(stderr, "%s: Fatal error in access() ", myname) ;
X        perror (execprogpath);
X        exit(1);
X    }
X
X    if ((execprog = (char *)strrchr (execprogpath, '/')) == NULL)
X      execprog = execprogpath ;		/* no path in program name */
X    else
X      execprog++ ;                                /* skip leading '/' */
X
X    pf = malloc (strlen(execprog) + strlen(ETCDIR) + 2) ;
X    sprintf(pf, "%s/%s\0", ETCDIR, execprog) ;
X    if (standalone(pf) == -1)    /* Kill prev running process    */
X    {
X        fprintf(stderr, "%s: Error in standalone...exiting\n", myname);
X        exit (1);
X    }
X    else
X      free(pf) ;         /* not needed anymore */
X
X    if (!debugflag)
X      daemon() ;
X
X    datafile = malloc(strlen(DATADIR) + strlen (execprog) + 2) ;
X    sprintf(datafile,  "%s/%s-output\0",
X             DATADIR,  execprog); 
X
X redo:
X    if ((fd = open(datafile, O_WRONLY | O_CREAT, 0640)) < 0)
X    {
X	perror(datafile);
X	fatal ("Open failed, exiting...");
X    }
X
X    sprintf(cmd, "%s %s\0", execprogpath, execargs);
X    if ((cmdf = popen (cmd, "r")) == NULL)
X    {
X	perror("popen");
X	fatal("Exiting...");
X    }
X
X    dostream(cmdf, fd);
X
X    if (fd >= 0)
X      close (fd);
X    if (cmdf)
X      pclose(cmdf);
X
X#ifdef DEBUG
X    fprintf(stderr, "(debug) mastermode: sleeping\n");
X#endif
X    sleep (SLEEPTIME);
X    goto redo ;
X
X}	/* end:  mastermode() */
X
X/*+ 
X * FUNCTION:
X * 	When this program is called at the end of a pipe, then it has
X * to read nocol event text lines from the stdin.
X * Does not 'sleep' or anything because the invoking process will
X * probably want control right away.
X */
X
Xslavemode()
X{
X#ifdef DEBUG
X    if (debugflag)
X      fprintf(stderr, "(debug) %s: Entered slavemode, reading from stdin\n",
X	      myname);
X#endif
X
X    dostream(stdin,fileno(stdout));	/* work with stdin/stdout */
X
X}	/* end:  slavemode()  */
X
X/*+ 
X * FUNCTION:
X * 	Read text lines from the indicated file stream and write out
X * to the open file descriptor  in the nocol format
X*/
Xdostream(fptr, fd)
X     FILE *fptr ;		/* to read text lines from */
X     int  fd;			/* to write nocol structures to */
X{
X    EVENT *pv ;
X    char  line[1024] ;		/* read line */
X
X    if (fptr == NULL  ||  fd < 0)
X      return(0);
X
X
X    while (fgets(line, sizeof (line), fptr) != NULL)
X    {
X	int   doneappend =0, dolog =0;
X	char  *tstr ;	/* temp pointer */
X
X	if ((tstr = strrchr(line, '\n')) )
X	  *tstr = '\0' ;	/* chop off newline */
X#ifdef DEBUG
X	if (debugflag)
X	  fprintf(stderr, "(debug) dostream: read '%s'\n", line);
X#endif
X	tstr = line ;
X	tstr = skip_spaces(tstr);
X
X	/*
X	 * look for keywords such as APPEND or LOG
X	 */
X	if (strncasecmp(tstr, "APPEND", strlen("APPEND")) == 0)
X	{
X	    if (!doneappend)
X	    {
X		/* Check if output device can be lseeked, etc. ?? */
X		if (debugflag)
X		  fprintf(stderr, "(debug) dostream: scanned APPEND, appending to output\n") ;
X		lseek(fd, 0L, SEEK_END);	/* end of file */
X		doneappend = 1;
X	    }
X	    tstr = tstr + strlen("APPEND") ;
X	    tstr = skip_spaces(tstr);
X	}
X
X	if (strncasecmp(tstr, "LOG", strlen("LOG")) == 0)
X	{
X	    dolog = 1;
X	    tstr = tstr + strlen("LOG") ;
X	    tstr = (char *)skip_spaces(tstr);
X	}
X
X	pv= (EVENT *)logstr_to_event(tstr) ;	/* create an event struct */
X	if (pv == NULL)
X	  return (-1);
X
X	if (dolog)
X	  eventlog(pv);
X
X	if (write(fd, pv, sizeof (EVENT)) != sizeof (EVENT) )
X	{
X	    perror("write");
X	    return(-1);
X	}
X
X    }	/* end:  while()  */
X
X    
X}  /* end:  dostream()  */
X
X
X/*
X * Become a daemon: go into the background, reset our process group,
X * and clobber the current directory and stdin, stdout, stderr.
X * Ideas for what needs to be done more or less stolen from BSD sources.
X * Exits on failure, and complains vigorously!
X */
Xdaemon()
X{
X    int  retval, fd, errfd;
X    
X    if ((retval=fork()) < 0)                    /* Go into the background */
X      fatal("daemon(): fork() failed");
X    else if (retval)
X      exit(0);					/* parent process */
X    
X    if ((int) setsid() < 0)                     /* Reset the process group */
X      fatal("daemon(): setsid() failed");
X    
X    if (chdir("/") < 0)                         /* Clobber current directory */
X      fatal("daemon(): chdir() failed");
X    
X    fd = open("/dev/null", O_RDWR, 0);          /* Clobber stdin, stdout, .. */
X
X    if (fd < 0)
X      fatal("daemon(): open() failed for errorfile");
X    if (dup2(fd, 1) < 0 || dup2(fd, 2) < 0)	/* dup stdout and stderr */
X      fatal("daemon(): dup2() failed");
X
X}	/* daemon() */
X    
X
Xfatal(s)	
Xchar *s;
X{
X    fprintf(stderr, "(fatal) %s: ", myname) ;
X    if (s)
X      fprintf(stderr, "%s\n", s);
X    else
X      fprintf(stderr, "\n");
X
X    unlink (pidfile);
X    unlink (datafile);
X
X    exit(1);
X
X}		/* fatal()  */
X
END_OF_FILE
  if test 8179 -ne `wc -c <'nocol-3.0/src/genmon/genmon.c'`; then
    echo shar: \"'nocol-3.0/src/genmon/genmon.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/genmon/genmon.c'
fi
if test -f 'nocol-3.0/src/lib/event_utils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/lib/event_utils.c'\"
else
  echo shar: Extracting \"'nocol-3.0/src/lib/event_utils.c'\" \(8888 characters\)
  sed "s/^X//" >'nocol-3.0/src/lib/event_utils.c' <<'END_OF_FILE'
X/* $Header: /home/aggarwal/lsrc/nocol/src/lib/RCS/event_utils.c,v 1.3 1993/10/30 03:24:58 aggarwal Exp $ */
X
X/* Copyright 1993 JvNCnet, Global Enterprise Services */
X
X/*
X * Small collection of common routines for the NOCOL monitors, etc.
X *
X *	-vikas@jvnc.net
X *
X * $Log: event_utils.c,v $
X * Revision 1.3  1993/10/30  03:24:58  aggarwal
X * Added check for bad or illegal severity values.
X *
X *
X */
X
X#include "nocol.h"
X#include <string.h>
X
X
X/*+ 
X * FUNCTION:
X * 	Skip leading spaces.
X */
Xchar *  skip_spaces(str)
X    char *str ;
X{
X    if (str == NULL)
X      return (str);
X    while (*str == ' '  || *str == '\t')
X      ++str ;				/* skip leading spaces */
X
X    return(str) ;
X}
X
X
X/*
X * Macro to escalate the severity of a site.
X * Change E_CRITICAL to E_ERROR if you don't want this program to put
X * events in the critical state.
X */
X#define ESC_SEVERITY(olds,maxs) ((olds == maxs)? maxs:(olds - 1))
X
X
X
X/*+ FUNCTION:
X * 	To update the event structure and log to noclogd based on the
X * 	'status' (0 or 1) and  'value' which is simply inserted.
X * 	The severity is escalated if the status is down till it
X *	reaches 'maxsev'.
X *	The 'loglevel' is set to the new severity level when the status
X *	is DOWN, and set to the old severity level when the status
X *	is UP. This is done so that if a site goes critical and is
X *	logged at priority CRITICAL, then when it comes back up, it
X *	is logged at priority CRITICAL also.
X *
X *	Time is updated only when status comes back up or when the
X *	status goes down the very first time.
X */
Xupdate_event(v, status, value, maxsev)
X     EVENT *v;
X     long status;			/* site status */
X     int value, maxsev ;		/* Event.value, max severity */
X{
X    struct tm *ltime ;    
X    time_t locclock ;			/* careful: don't use 'long'	*/
X    
X    locclock = time((time_t *) NULL);
X    ltime = localtime((long *)&locclock);
X
X    switch (status)
X    {
X     case 1:				/* Site responded, is up */
X	v->mon = ltime->tm_mon + 1;	/* update time */
X	v->day = ltime->tm_mday;
X	v->hour = ltime->tm_hour;
X	v->min = ltime->tm_min;
X
X	v->var.value = value ;		/* update pkts recvd. */
X	if (!(v->nocop & n_UP))		/* recent change of state */
X	{
X	    v->nocop = SETF_UPDOUN(v->nocop, n_UP) ;
X	    v->loglevel = v->severity; /* log at earlier level */
X	    v->severity = E_INFO ;	/* change severity */
X	    eventlog(v);
X	}
X	break;
X
X     case 0:			/* site down,  escalate the severity */
X	if (!(v->nocop & n_DOWN))	/* recent change of state.. */
X	{
X	    v->mon = ltime->tm_mon + 1;
X	    v->day = ltime->tm_mday;
X	    v->hour = ltime->tm_hour;
X	    v->min = ltime->tm_min;
X	}
X	
X	/*
X	 * escalate severity level, and log if the severity level
X	 * changes.
X	 */
X	v->var.value = value;			/* new value  */
X	v->nocop = SETF_UPDOUN (v->nocop, n_DOWN);
X	v->severity = ESC_SEVERITY(v->severity, maxsev);
X	
X	if (v->loglevel != v->severity) 	/* new change */
X	{
X	    v->loglevel = v->severity ;  /* set to new severity */
X	    eventlog(v);
X	}
X	break;
X    }		/* end switch */
X
X}
X
X/*  */
X
X/*+ 		event_to_logstr()
X ** FUNCTION:
X ** Formats an event structure as an ascii string that is written
X ** out to the various logfiles. Change here to get different
X ** format log lines. Not using EFMT, etc. since the log lines
X ** can have a TAG and other strings that might not be displayed.
X **
X ** Note that you should not change this function because 
X ** report generating functions might depend on this format.
X **/
Xchar *event_to_logstr(v)
X     EVENT  *v ;
X{
X    register int  i ;
X    static char  fmts[512];	/* Okay, so its a looonnng string !! */
X    char nocops[32];
X    char datestr[32] ;
X    struct tm *tm ;
X    time_t locclock ;
X
X    /*
X     * Create a string from the nocops flag
X     */
X    *nocops = '\0';
X    for (i=0 ; *(nocop_txt[i].str) != '\0' ; ++i)
X      if (v->nocop & nocop_txt[i].v)
X	strcat(strcat(nocops, nocop_txt[i].str), " ") ;
X
X    if (*nocops)
X      *(nocops + strlen(nocops) - 1) = '\0' ; 	/* strip trailing blank */
X
X    /*
X     * Format the date string. Do any date format conversions here
X     */
X
X    /* Convert into Unix asctime format */
X    locclock = time((time_t *) NULL);
X    tm = localtime((long *)&locclock);		/* gets the year, etc. */
X
X    tm->tm_mon = v->mon - 1 ; tm->tm_mday = v->day ; 
X    tm->tm_hour = v->hour   ; tm->tm_min = v->min  ;
X    sprintf(datestr, "%s", (char *)asctime(tm) );
X    *(strchr(datestr, '\n')) = '\0' ;		/* delete the newline */
X
X/*   sprintf(datestr,"%02d/%02d %02d:%02d\0",v->mon,v->day,v->hour,v->min);/* */
X
X    if (v->severity < E_CRITICAL || v->severity > E_INFO)
X    {
X	fprintf(stderr, 
X		"(event_to_logstr): Bad severity %d, setting to CRITICAL\n", 
X		v->severity);
X	v->severity = E_CRITICAL ;
X    }
X    if (v->loglevel < E_CRITICAL || v->loglevel > E_INFO)
X    {
X	fprintf(stderr, 
X		"(event_to_logstr): Bad loglevel %d, setting to CRITICAL\n", 
X		v->loglevel);
X	v->loglevel = E_CRITICAL ;
X    }
X
X    /*
X     * IF YOU CHANGE THIS LINE, CHANGE THE CORRESPONDING CODE IN
X     * logstr_to_event()
X     */
X    sprintf(fmts,
X	    "%s [%s]: SITE %s %s VAR %s %ld %ld %s LEVEL %s LOGLEVEL %s NOCOP %s\n",
X	    datestr, v->sender, v->site.name, v->site.addr, 
X	    v->var.name, v->var.value, v->var.threshold, v->var.units,
X	    severity_txt[v->severity], severity_txt[v->loglevel],
X	    nocops) ;
X
X    return(fmts) ;
X}
X
X/*+ 		logstr_to_event
X * FUNCTION:
X * 	Read in a line of the logstr format and create a nocol
X * EVENT structure out of it.
X * WILL NEED TO CHANGE IF THE logstr_format() FUNCTION CHANGES.
X */
X
XEVENT *logstr_to_event(s)
X     char *s ;			/* text string with the nocol fields */
X{
X    static char  *monthlist[] = 
X    {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"} ;
X    int a, b, c ;	/* for scanning dates */
X    char  *psender, *psite, *pvar, *plevel, *ploglevel, *pnocop ;
X    char  tmps[32], *tstr;
X    register int i;
X    static EVENT v ;		/* needs to be static */
X    time_t nsecs ;
X    struct tm *ptm ;
X
X    psender   = strstr(s, "[") ; ++psender ;	/* skip past '[' */
X    psite     = strstr(s, "SITE") ;
X    pvar      = strstr(s, "VAR") ;
X    plevel    = strstr(s, "LEVEL") ;
X    ploglevel = strstr(s, "LOGLEVEL") ;
X    pnocop    = strstr(s, "NOCOP") ;
X
X    /*
X     * Parse date
X     */
X    for (i=0; s[i] != '[' ; ++i )	/* try to grab the date part */
X      tmps[i] = s[i];
X    tmps[i] = '\0' ;
X    while (tmps[--i] == ' ')		/* delete trailing spaces */
X      tmps[i] = '\0';
X
X    /*
X     * Calling get_date for robustness in parsing date's of various formats.
X     */
X       
X/*    nsecs = get_date(tmps);
X *   fprintf(stderr, "Converted date '%s'\n", ctime(&nsecs));
X *    ptm = localtime((time_t)nsecs) ;
X *    v.mon = ptm->tm_mon + 1; v.day = ptm->tm_mday; 
X *    v.hour =  ptm->tm_hour; v.min = ptm->tm_min ;
X */
X    /** Parse date:  Tue Sep 24 14:10:26 1993 **/
X    tstr = strchr(tmps, ' ');	/* Get to the month string */
X    tstr = skip_spaces(tstr);
X    for (v.mon=0 ;v.mon <12 && strncmp(tstr,monthlist[v.mon],3) != 0 ; ++v.mon)
X      ;
X    if (v.mon < 12)
X      v.mon++ ;		/* from 1 to 12 instead of 0-11 */
X    else
X    {
X	fprintf(stderr,
X		"Error (scan_logstr_format): Bad month in date string '%s'\n",
X		tstr);
X	return (NULL);
X    }
X
X/*  sscanf(tstr, "%*s %d %d:%d", v.day, (v.hour), (v.min) ); /* skip month */
X    sscanf (tstr, "%*s %d %d:%d", &a, &b, &c);
X    v.day = a ; v.hour = b ; v.min = c;
X
X    /*
X     * Sender field (in the square brackets[])
X     */
X    for (i=0 ; psender[i] != ']' ; ++i)
X      v.sender[i] = psender[i] ;
X    v.sender[i] = '\0';
X
X    strtok (psite, " \t") ;		/* Skip over keyword 'SITE' */
X    strcpy(v.site.name, strtok(NULL, " \t"));
X    strcpy(v.site.addr, strtok(NULL, " \t"));  /* hope no spaces in addr */
X
X    strtok(pvar, " \t");		/* Skip over keyword 'VAR' */
X    strcpy(v.var.name, strtok(NULL, " \t"));
X    v.var.value = atol (strtok(NULL, " \t"));
X    v.var.threshold = atol (strtok(NULL, " \t"));
X    strcpy(v.var.units, strtok(NULL, " \t")) ;
X
X    strtok (plevel, " \t");		/* skip leading keyword */
X    tstr = strtok(NULL, " \t");
X    for (a=E_CRITICAL ; severity_txt[a] != "" ; ++a)
X      if (strncmp(severity_txt[a], tstr, strlen(severity_txt[a])) == 0)
X	break;
X    v.severity = a ;
X
X    strtok(ploglevel, " \t");		/* skip leading keyword */
X    tstr = strtok(NULL, " \t");
X    for (a=E_CRITICAL ; severity_txt[a] != "" ; ++a)
X      if (strncasecmp(severity_txt[a], tstr, strlen(severity_txt[a])) == 0)
X	break;
X    v.loglevel = a ;
X
X    strtok(pnocop, " \t");		/* Skip over keyword */
X    v.nocop = 0;
X    while ((tstr = strtok(NULL, " \t")) != NULL)
X    {
X	register i = 0;
X	while (nocop_txt[i].str != "")
X	  if (strncasecmp(nocop_txt[i].str,  tstr,  strlen(nocop_txt[i].str)) == 0)
X	  {
X	      v.nocop = v.nocop | nocop_txt[i].v ;
X	      break;
X	  }
X	  else
X	    ++i ;
X    }
X
X#ifdef DEBUG
X    fprintf(stderr, "(debug): %s\n", event_to_logstr(&v)) ;	/*  */
X#endif
X
X    return(&v) ;
X
X}	/* end:  logstr_to_event() */
X
END_OF_FILE
  if test 8888 -ne `wc -c <'nocol-3.0/src/lib/event_utils.c'`; then
    echo shar: \"'nocol-3.0/src/lib/event_utils.c'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/lib/event_utils.c'
fi
if test -f 'nocol-3.0/src/support/mping/MAIL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nocol-3.0/src/support/mping/MAIL'\"
else
  echo shar: Extracting \"'nocol-3.0/src/support/mping/MAIL'\" \(8786 characters\)
  sed "s/^X//" >'nocol-3.0/src/support/mping/MAIL' <<'END_OF_FILE'
XFrom Watt-Alan@Yale.EDU Fri Jun 12 08:27:44 1992
XReceived: from r2d2.jvnc.net by bambi.jvnc.net (5.65/1.34)
X	id AA04773; Fri, 12 Jun 92 08:27:42 -0400
XReceived: from MICKEY.YCC.YALE.EDU by r2d2.jvnc.net (5.65/1.34)
X	id AA12548; Fri, 12 Jun 92 08:27:28 -0400
XFrom: Watt-Alan@Yale.EDU
XReceived: by mickey.ycc.yale.edu; Fri, 12 Jun 92 08:27:26 EDT
XDate: Fri, 12 Jun 92 08:27:26 EDT
XMessage-Id: <9206121227.AA01802@mickey.ycc.yale.edu>
XTo: jvncnet-tech@jvnc.net, aggarwal@r2d2.jvnc.net
XSubject: Re: New monitoring capability - NOCOL testing
XCc: jvncnet-ops@jvnc.net, net@jvnc.net
XStatus: OR
X
X
X
XRe: ICMP ping monitor with capability to ping upto 64 sites at time.
X
XI have a program "mping" which can ping an arbitrary number of sites
Xan arbitrary number of times with specifiable packet sizes, packet
Xdata pattern, and timeout interval.
X
XThe program imposes a minimum pause between outgoing packets to
Xavoid flooding gateways.  I use 50 milliseconds here, but it can
Xbe set up or down to suit local needs.
X
XThis program is actually run from within another program (a Perl
Xscript), which continuously pings nodes according to a configuration
Xfile and outputs a running summary showing long-term error averages.
X
XThis is available via anonymous FTP from:
X
X	mickey.ycc.yale.edu	(130.132.21.200)
X	~ftp/pub/spqr.tar
X
XDescription follows.
X
X
X	- Alan S. Watt
X	  High Speed Networking, Yale University
X	  Computing and Information Systems
X	  Box 2112 Yale Station
X	  New Haven, CT  06520-2112
X	  (203) 432-6602
X	  Watt-Alan@Yale.Edu
X
X
XDisclaimer:	We used to have the best Congress money could buy,
X		but like everything else these days the quality
X		has declined even as the price has risen.
X----------------------------------------------------------------------------
X
XSPQR
X
XSuccessive Ping Quality Regression	 (Okay, you think of a better name)
X
X
Xspqr is a tool which can spot "low intensity" problems in LAN or WAN
Xfunctioning.  Based on the venerable "ping" (ICMP_ECHO) facility, it
Xcontinuously monitors stations based on a configuration file and keeps
Xa cumulative problem metric averaged over 5, 15, and 60 minute intervals.
X
Xspqr consists of three parts: a driver/reporting program which initiaties
Xa poll every minute and averages the results, a parallel pinger program
X(which can send ICMP_ECHO packets to an arbitrarily large number of targets
Xin parallel), and a simple display program which continuously prints the
Xcurrent status to the screen.  The display program is suitable to run
Xas a restricted shell.
X
Xmping -- the parallel pinger program
X------------------------------------
XMping is driven from a configuration file (or standard input) which
Xlists the addresses to ping, and optionally:
X
X	packet length	(default 56 bytes of ICMP data)
X	packet data	(default all zeros)
X	# packets	(default 1)
X	# retries	(default 5)
X	retry interval	(default 1 second)
X
XThe format of the file is simple, consisting of two or three fields
Xfor each entry.  The fields are:
X
X	name	address	[options]
X
XIf given, <options> is one or more comma-separated fields in the order:
X
X	size,pattern,numToGet,retry,timeout
X
XThis parses option fields left to right, as indicated by commas.  Missing
Xor empty fields use the default value (see below).  For example, the
Xoption string to specify just the size (128) and pattern (0x15) would be
X"128,0x15": the remaining fields would default.  To specify a size (128)
Xand a retry count (2), the option field would be "128,,,2".  To specify
Xjust a timeout of 2 seconds, the option string would be ",,,,2000".
X
X
X size [default: 56]:		Decimal number giving the size of the ICMP
X				data portion of the packet.  The actual IP
X				packet will be at least 8 octets larger.
X
Xpattern [default: 0x0]:	A hex number specifying a byte value to
X				initialize the ICMP data portion of the
X				packet.
X
XnumToGet [default: 1]:	Number of return packets to require.
X
Xretry [default: 5]:		Number of retries to make before declaring
X				a packet lost.  Note that if <numToGet> is
X				greater than 1, the retry limit applies to
X				each attempt.  That is if the first attempt
X				requires 4 tries before a successful return,
X				then next attempt will still make up to 5
X				tries.
X
Xtimeout [default: 1000]	Number of milliseconds to wait before
X				assuming packet lost and retrying.  The
X				default timeout is fine within an all
X				ethernet environment, but you need a longer
X				one for WAN links.
X
XThe <name> field is not used for anything except producing the report.
X
XThe <address> field can be either an IP address in any of the notations
Xacceptable to the inet_addr() function, or it can be a domain name.
XIf a domain name is used, and the gethostbyname() function returns
Xmore than one address, it is treated like multiple configuration lines,
Xone for each address.  For example the configuration line:
X
X	NS-NIC	ns.nic.ddn.mil	56,0,2
X
Xis treated as if read:
X
X	NS-NIC	192.112.36.4	56,0,2
X	NS-NIC	192.67.67.53	56,0,2
X
X
Xbased on the configuration, the parallel pinger sends packets to every
Xtarget on the list, retrying as necessary until all targets have either
X(a) returned the required number of packets or (b) failed to return a
Xpacket in the specified number of timeouts.
X
XIt then reports for each target: how many packets sent, how many returned,
Xand the total packet round trip time (in microseconds) for all returned
Xpackets.
X
Xmsummary -- the driver program
X------------------------------
XThe driver program invokes mping once each cycle (default 60 seconds)
Xand reads its output to produce a summary of all targets showing less
Xthan perfect connectivity.   There are four columns of bad/RTT pairs,
Xand a single RPT column.  The bad/RTT pairs show the percentage of
Xdropped packets and the average round trip time for: (1) the most
Xrecent poll, (2) the most recent 5 polls, (3) the most recent 15 polls,
Xand (4) the most recent 60 polls.  Thus temporary problems eventually
Xget averaged out and dropped from the report, but persistent low-level
Xproblems remain prominent.
X
XThe "RPT" column shows what percentage of the time this system has been
Xreported.  A target is dropped from the report when all averages become
X0.  Thus a target with.
X
XHere is a sample report:
X
X------------------------------------------------------------------------------
X16:19:27    Iter: 16288 Cycle:  14   current    avg. 5   avg. 15   avg. 60
XSystem Name        IP Address      bad   RTT bad   RTT bad   RTT bad   RTT RPT
X------------------ --------------- --- ----- --- ----- --- ----- --- ----- ---
Xcupid              130.132.21.192    0   1.6   2   1.8  13   1.8  18   1.8  99
Xcalvin             130.132.21.195   33   1.2  27   1.4  23   1.4  18   1.4  98
Xdual               130.132.21.211    0   1.8  14   1.8  16   1.9  12   1.7  47
Xyaleads            130.132.21.130    0   3.9   0   4.2   0   4.6   1   5.2   8
Xcondor             130.132.21.141  100   0.0 100   0.0 100   0.0 100   0.0 100
Xvenus              130.132.1.5       0   5.4   0   5.5   2   5.6   7   5.8  94
Xbiomed.med         130.132.19.48     0   5.0   0   5.2   0   5.3   4   5.5  30
Xgucci.stat         130.132.16.16     0   3.7   0   4.0   1   4.0   6   4.0 100
Xhermes.stat        130.132.16.19   100   3.9 100   3.9 100   3.9  95   3.8 100
Xsysc.eng           130.132.20.240    0   4.2   0   4.2   0   4.3   1   4.3  19
Xcld3.eng           130.132.20.251    0   4.0   0   4.0   1   4.1   2   4.1   4
X74 entries skipped for all-0 error averages
X
X------------------------------------------------------------------------------
X
XThis report shows systems "condor" is dropping all packets, and has
Xbeen for the last 60 cycles.  "hermes.stat" has been dropping all
Xpackets for at least the last 15 cycles, but sometime in the last 60
Xcycles some packets got through.  (Both situations are consistent with
Xthe target machine being down).
X
XThe more interesting reports are for machines like venus, calvin, gucci.stat,
Xand cupid.  They all show persistent long-term drop rates, evidenced by the
Xhigh value in the "RPT" column.  In a LAN environment, nodes should show
Xa 0% packet drop rate virtually all the time.  An occasional dropped packet
Xis generally not anything to worry about.  Persistent non-zero drop rates
Xto certain nodes indicates an error condition either at the end nodes or
Xon a network segment somewhere between the station running SPQR and the
Xend nodes.  Running SPQR on several nodes on different segments is a good
Xway to "triangulate" in on a problem bridge or router.  Its first use
X(actually, reason for development) was to establish that a specific
Xethernet interface on a cisco router had a 1% packet drop rate that didn't
Xshow up in the SNMP data.
X
XThe "Iter" value in the heading is the number of iterations this driver
Xprogram has made; the "Cycle" value is how many seconds it takes to run
Xeach cycle.
X
END_OF_FILE
  if test 8786 -ne `wc -c <'nocol-3.0/src/support/mping/MAIL'`; then
    echo shar: \"'nocol-3.0/src/support/mping/MAIL'\" unpacked with wrong size!
  fi
  # end of 'nocol-3.0/src/support/mping/MAIL'
fi
echo shar: End of archive 19 \(of 26\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
