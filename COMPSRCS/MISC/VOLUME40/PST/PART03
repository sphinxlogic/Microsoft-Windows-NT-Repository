Newsgroups: comp.sources.misc
From: Panos Tsirigotis (panos@cs.colorado.edu)
Subject: v40i174:  pst - extract text from a postscript file, Part03/06
Message-ID: <1993Nov26.170731.6476@sparky.sterling.com>
X-Md4-Signature: b266621814b57b5f588228e906dae7b7
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 26 Nov 1993 17:07:31 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Panos Tsirigotis (panos@cs.colorado.edu)
Posting-number: Volume 40, Issue 174
Archive-name: pst/part03
Environment: BSD, SUNOS, ULTRIX, SYSVR4, SYSVR3, POSIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  libs/src/sio/README libs/src/sio/Sprint.3
#   libs/src/sio/impl.h libs/src/sio/sioconf.h
#   libs/src/sio/suite/copytest.c libs/src/sio/suite/tester
#   libs/src/str/Makefile libs/src/str/strparse.c libs/src/str/strs.3
#   pst/dvi.c
# Wrapped by kent@sparky on Fri Nov 26 11:02:46 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 6)."'
if test -f 'libs/src/sio/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/README'\"
else
  echo shar: Extracting \"'libs/src/sio/README'\" \(4699 characters\)
  sed "s/^X//" >'libs/src/sio/README' <<'END_OF_FILE'
X======================================================================
XNOTE: I use vi with a tabstop value of 3. Using the same tabstop
X		value will make the text/code look properly indented.
X======================================================================
X
X
X1. What is SIO ?
X
XSIO is a library that provides _stream_ I/O which is what most Unix
Xprograms do. As such it is a competitor to stdio.
X
X
X2. Why would you care to use it ?
X
Xa. SIO is a little faster than stdio
Xb. SIO provides an easier-to-use interface (IMHO)
Xc. SIO is capable of using memory mapping for reading files if the operating
X	system supports it.
Xd. If you have a program that uses read(2)/write(2) it is trivial
X   to convert it to use SIO (just replace read with Sread and 
X   write with Swrite)
Xe. You get source
X
X
X
X3. Setting up the Stream I/O (SIO) library
X
XThere are 3 steps to the process:
X	1) compiling SIO for your system
X	2) testing SIO
X	3) installing the library and manpages
X
X
X3.1. How to compile the Stream I/O (SIO) library
X
XAll the system-dependent stuff of SIO is placed in the sioconf.h file.
XIf your system is not among those listed below, you will need to read
Xthat file to see what flags you need to set to properly compile SIO.
X
X	SunOS 4.x:
X		make "DEFS=-DHAS_MMAP -DHAS_ONEXIT -DHAS_MEMOPS -DHAS_ISATTY"
X
X	SunOS 5.x (aka Solaris 2.y):
X		make "DEFS=-DHAS_MMAP -DHAS_ATEXIT -DHAS_MEMOPS -DHAS_ISATTY"
X	(I don't have access to a system running Solaris 2.y so I have not
X	tested this)
X
X	Ultrix 4.x:
X		make "DEFS=-DHAS_MEMOPS -DHAS_ATEXIT -DHAS_ISATTY"
X
XIf your system is one of the above, then you can skip to the next subsection.
XHowever, I should mention that the library compiles by default with
Xdebugging enabled (i.e. uses the -g flag of cc). You can override this
Xby appending to the above invocations of 'make' the argument "DEBUG=-O"
X
XIf your system is not among the above, then you will need to modify the
Xsioconf.h file. You do this by uncommenting the inclusion of
Xcustomconf.h. Then, you can override all constants/macros defined in
Xsioconf.h by defining them first in customconf.h.  Please read
Xsioconf.h for more information on what constants/macros can be
Xdefined.
X
XThe Makefile has a header that explains what the Makefile can do.
XThe only flag that you may want to define is -DDEBUG which enables 
Xassertions in the SIO code (if an assertion fails, the program is 
Xterminated with an error message that lists the SIO file and line 
Xnumber where the error occured).
X
X
X3.2. Testing SIO
X
XAfter you have successfully compiled SIO, you can use the programs in
Xthe "suite" directory to test the SIO functions. It may make you feel
Xbetter if you test the library before installing it.
XThe script testlib does everything; just type:
X
X	testlib all
X
XThe script sprint_test (invoked by testlib) tests Sprint by using a variety 
Xof formats and comparing its output with that of an ANSI-compatible printf.
XAt least on Ultrix 4.1 and 4.2 this test fails because printf is not 
XANSI-compatible.
XIn such a case, you can test the rest of the SIO functions by typing:
X
X	testlib all Sprint
X
X(anything after the 'all' argument is interpreted as a function that
Xshould not be tested).
X
XThe README file in the "suite" directory describes how to do a
Xfew more tests that cannot be done automatically.
X
X
X3.3. Installing the library and manpages
X
XThe default 'make' target will create libsio.a in the current directory.
XThe Makefile includes an "install" target. Doing a 'make install' will 
Xcause the following:
X
Xa) libsio.a will be installed in LIBDIR
Xb) the necessary SIO header files will be installed in INCLUDEDIR
Xc) the SIO man pages will be installed in MANDIR
X
XLIBDIR, INCLUDEDIR, and MANDIR are Makefile variables that you can edit in
Xthe Makefile or override when you invoke 'make'.
XHere is a sample command to install SIO:
X
X	make install LIBDIR=/usr/local/lib INCLUDEDIR=/usr/local/include MANDIR=/usr/local/man/man3
X
X
X4. Epilogue
X
XFeel free to modify SIO to suit your needs. Please let me know if you
Xfind any bugs (my email address is panos@cs.colorado.edu).
X
XIf you want to distribute your modifications, please read the COPYRIGHT
Xfile.  It basically says that you are free to redistribute as long as
Xyou retain the original copyright notice and you make sure that your
Xmodifications are identifiable. In order to achieve this I have
Xreserved the first 3 components of the version number (for example,
X1.4.2) and you can identify your mods by appending another component to
Xthat version number (for example, 1.4.2.A2). Also, if you distribute a
Xmodified version of the library, you take full responsibility for any
Xbugs in the code (not just your code; the whole thing).
X
X
X	** Panos Tsirigotis **
X
END_OF_FILE
  if test 4699 -ne `wc -c <'libs/src/sio/README'`; then
    echo shar: \"'libs/src/sio/README'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/README'
fi
if test -f 'libs/src/sio/Sprint.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/Sprint.3'\"
else
  echo shar: Extracting \"'libs/src/sio/Sprint.3'\" \(5277 characters\)
  sed "s/^X//" >'libs/src/sio/Sprint.3' <<'END_OF_FILE'
X.\"(c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X.\"All rights reserved.  The file named COPYRIGHT specifies the terms 
X.\"and conditions for redistribution.
X.\"
X.\" $Id: Sprint.3,v 8.1 1993/03/13 01:15:34 panos Exp $
X.TH Sprint 3X "29 May 1992"
X.SH NAME
XSprint -- formatted stream output
X.SH SYNOPSIS
X.LP
X.nf
X.ft B
Xint Sprint( fd, format [ , ... ] )
Xint fd ;
Xchar *format ;
X.SH DESCRIPTION
X\fBSprint()\fR provides formatted output conversion. The formatting is
Xcontrolled by the \fIformat\fR argument. All characters in
X\fIformat\fR that do not specify a conversion are printed. A conversion
Xis specified by a '%' followed by a string that ends with a
Xconversion type character. The string may contain flags, a field width,
Xa precision, and a modifier.
X.LP
XPossible flags (more that one can be specified and they can be in any order)
Xinclude:
X.TP 10
X.B \'-'
Xspecifies left adjustment of the converted argument. The default
Xis right adjustment. This flag is meaningful only if a field width
Xis specified.
X.TP
X.B \'+'
Xspecifies that a number will always have a sign as a prefix (this
Xforces a '+' sign to appear if the number is positive).
X.TP
X.B \' '
Xprefixes a \fIspace\fR to the number if the number has not a sign
X(therefore the '+' flag overrides this flag).
X.TP
X.B \'#'
XThe meaning of '#' depends on the conversion type character: for \fBo\fR 
Xconversions the first digit will be 0; for \fBx\fR or \fBX\fR conversions
X\fB0x\fR or \fB0X\fR respectively will be prefixed to the number (if it
Xis not zero); for \fBe\fR, \fBE\fR, \fBf\fR, \fBg\fR, and \fBG\fR conversions
Xthe number will always have a decimal point.
X.TP
X.B \'0'
Xspecifies padding with zeros instead of spaces.
X.LP
XThe field width is specified by a number. This number indicates the
X\fIminimum\fR width for the field. A '*' may be used instead of the number.
XIn that case the width is the value of the next argument which should
Xbe an \fBint\fR. 
XA negative width value specifies left adjustment with a width equal
Xto the absolute width value.
X.LP
XA precision is specified by a '.' followed by a number. The meaning of
Xthe precision depends on the type conversion character. For a string
Xconversion, precision determines how many characters are printed from
Xthe string. For integer conversions, precision determines the 
Xnumber of digits used to print the number (zero padding is done if
Xthe precision exceeds the length of the number). For floating point
Xconversions, precision determines the number of digits after the
Xdecimal point (\fBe\fR, \fBE\fR, \fBf\fR) or the number of
Xsignificant digits (\fBg\fR, \fBG\fR).
XA '*' may be used instead of a number to specify the precision. In that
Xcase the precision is the value of the next argument which should
Xbe an \fBint\fR.
XThe behavior of \fBSprint()\fR is undefined if the precision is negative.
X.LP
XThe length modifier is \fBl\fR and indicates that the argument is
Xa \fBlong\fR integer.
X.LP
XThe type conversion characters are:
X\fBd, i, o, x, X, u, c, s, f, e, E, g, G, p, n, %\fR.
XFor floating point conversions the argument should be of type \fIdouble\fR.
X.TP 10
X.B d,i
Xspecify signed decimal conversion.
X.TP
X.B u
Xspecifies unsigned decimal conversion.
X.TP
X.B o
Xspecifies octal conversion.
X.TP
X.B x,X
Xspecify hexadecimal conversion. For 
X.B x
Xthe hex digits used are 0123456789abcdef. For
X.B X
Xthe hex digits used are 0123456789ABCDEF.
XThere is no leading
X.B 0x
Xor
X.B 0X
X(use the '#' flag for that).
X.TP
X.B c
Xspecifies character conversion; the argument should be of type
X\fIchar\fR.
X.TP
X.B s
Xspecifies string conversion; the argument should be of type
X\fIchar *\fR.
X.TP
X.B f
Xspecifies conversion to the form [-]ddd.dddd. The number
Xof digits after the decimal point depends on precision; the default is 6.
XIf the precision is 0, the decimal point is not printed (this can
Xbe overriden with the '#' flag).
X.B e,E
Xspecify conversion to the form [-]ddd.dddd[eE][+-]ddd.
XThe number of digits after the decimal point depends on precision;
Xthe default is 6. If the precision is 0, the decimal point is not printed
X(this can be overriden with the '#' flag).
XThe exponent is at least 2 digit wide.
X.TP
X.B g,G
Xspecify a conversion using the
X.B e,E
Xformat respectively if the
Xexponent is less than -4 or greater than or equal to the precision;
Xotherwise the 
X.B f
Xformat is used.
X.TP
X.B p
Xis used to print pointers (type \fIvoid *\fR,
Xor \fIchar *\fR if the compiler does not support the former).
X.TP
X.B n
Xexpects a \fIint *\fR argument and puts in that integer 
Xthe number of characters already printed by this call.
X.TP
X.B %
Xis used to print a \fI%\fR.
X.LP
XIf an unknown conversion character is specified, the percent sign
Xfollowed by that character will be printed.
X.SH RETURN VALUE
X.LP
XIf no error occured, \fBSprint()\fR returns the number of characters
Xprinted. In case of error, it returns \fBSIO_ERR\fR.
X.SH BUGS
X.LP
XThis is a list of differences between \fBSprint()\fR and the ANSI C Standard
X\fBprintf()\fR:
X.LP
X\fBSprint()\fR does not support non-removal of trailing zeroes for
X\fBg\fR and \fBG\fR conversions when the '#' flag is used.
X.LP
X\fBSprint()\fR does not support the h and L modifiers.
X.LP
XThe current implementation assumes that \fIsizeof(int)==sizeof(long)\fR.
X.LP
X\fBSprint()\fR supports "%p" only if \fIsizeof(pointer)<=sizeof(int)\fR.
END_OF_FILE
  if test 5277 -ne `wc -c <'libs/src/sio/Sprint.3'`; then
    echo shar: \"'libs/src/sio/Sprint.3'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/Sprint.3'
fi
if test -f 'libs/src/sio/impl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/impl.h'\"
else
  echo shar: Extracting \"'libs/src/sio/impl.h'\" \(5528 characters\)
  sed "s/^X//" >'libs/src/sio/impl.h' <<'END_OF_FILE'
X/*
X * (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X * All rights reserved.  The file named COPYRIGHT specifies the terms 
X * and conditions for redistribution.
X */
X
X/*
X * $Id: impl.h,v 8.1 1993/03/13 01:15:06 panos Exp $
X */
X
X#ifndef SIO_BUFFER_SIZE
X
X#include "sioconf.h"
X
X#ifdef HAS_MMAP
X#include <sys/types.h>
X
X
X/*
X * A struct map_unit describes a memory mapped area of a file.
X *
X * addr is the address where the file is mapped. If addr is NULL
X * the other fields are meaningless.
X * valid_bytes indicates how many bytes are _valid_ in that unit
X * mapped_bytes of a unit is how many bytes are mapped in that
X * unit ( valid <= mapped ).
X * Normally mapped_bytes will be equal to valid_bytes until
X * we reach the end of the file. Then if the file size is not a multiple
X * of the unit size, only the rest of the file will be mapped at the
X * unit, leaving part of what was mapped at the unit before still
X * visible (this happens because I chose not to unmap a unit before
X * remapping it). In that case valid_bytes shows the size of the "new"
X * mapping and mapped_bytes shows how many bytes are really mapped.
X * mapped_bytes is used in Sdone() to unmap the units.
X */
Xstruct map_unit
X{
X	caddr_t addr ;
X	size_t valid_bytes ;
X	size_t mapped_bytes ;
X} ;
X
X
X/*
X * Meaning of fields used when memory mapping:
X *
X *    file_offset:      it is the offset in the file where the next
X *                      mapping should be done
X *
X *    file_size:        size of the file (obtained from stat(2))
X */
Xstruct mmap_descriptor
X{
X   off_t file_offset ;
X   off_t file_size ;
X	struct map_unit first_unit ;
X	struct map_unit second_unit ;
X} ;
X
Xtypedef struct mmap_descriptor mapd_s ;
X
X#endif /* HAS_MMAP */
X
Xtypedef enum { FAILURE, SUCCESS } status_e ;
X
X/*
X * Descriptor management: convert a descriptor pointer to an input or
X * output descriptor pointer
X */
X#define IDP( dp )						(&(dp)->descriptor.input_descriptor)
X#define ODP( dp )						(&(dp)->descriptor.output_descriptor)
X
X#define DESCRIPTOR_INITIALIZED( dp )	((dp)->initialized)
X
X/*
X * Internal constants
X */
X#define SIO_BUFFER_SIZE       	8192
X#define SIO_NO_TIED_FD				(-1)
X
Xtypedef enum { NO = 0, YES = 1 } boolean_e ;
X
X#ifndef FALSE
X#define FALSE			0
X#define TRUE			1
X#endif
X
X#ifndef NULL
X#define NULL			0
X#endif
X
X#ifdef MIN
X#undef MIN
X#endif
X#define MIN( a, b )					( (a) < (b) ? (a) : (b) )
X
X#define NUL								'\0'
X
X#define PRIVATE						static
X
X#ifdef DEBUG
X
Xstatic char *itoa( num )
X	unsigned num ;
X{
X#define NUMBUF_SIZE		15
X	static char numbuf[ NUMBUF_SIZE ] ;
X	register char *p = &numbuf[ NUMBUF_SIZE ] ;
X
X	*--p = '\0' ;
X	do
X	{
X		*--p = num % 10 + '0' ;
X		num /= 10 ;
X	}
X	while ( num ) ;
X	return( p ) ;
X}
X
X#	define ASSERT( expr )														\
X		if ( ! (expr) )															\
X		{																				\
X			char *s1 = "SIO assertion << expr >> failed: File: " ;	\
X			char *s2 = __FILE__ ;												\
X			char *s3 = ", line: " ;												\
X			char *s4 = itoa( __LINE__ ) ;										\
X			char *s5 = "\n" ;														\
X			(void) write( 2, s1, strlen( s1 ) ) ;							\
X			(void) write( 2, s2, strlen( s2 ) ) ;							\
X			(void) write( 2, s3, strlen( s3 ) ) ;							\
X			(void) write( 2, s4, strlen( s4 ) ) ;							\
X			(void) write( 2, s5, strlen( s5 ) ) ;							\
X			exit ( 1 ) ;															\
X		}
X#else
X#	define ASSERT( expr )
X#endif
X
X
X#include <errno.h>
Xextern int errno ;
X
X/*
X * IO_SETUP initializes a descriptor if it is not already initialized.
X * It checks if the stream is of the right type (input or output).
X * CONTROL_SETUP checks if the descriptor is initialized and if the
X * stream is of the right type (input or output). 
X *
X * 	fd: file descriptor
X * 	dp: descriptor pointer
X * 	op: operation
X * 	ev: error value (if __sio_init fails; __sio_init should set errno) 
X *
X * IO_SETUP will call __sio_init if the descriptor is not initialized.
X * Possible errors:
X *		1. Using CONTROL_SETUP on an uninitialized descriptor.
X *		2. The operation is not appropriate for the descriptor (e.g.
X *			a read operation on an descriptor used for writing). 
X * Both errors set errno to EBADF.
X */
X#define CONTROL_SETUP( dp, type, ev )														\
X			{																							\
X				if ( ! DESCRIPTOR_INITIALIZED( dp ) || dp->stream_type != type )	\
X				{																						\
X					errno = EBADF ;																\
X					return( ev ) ;																	\
X				}																						\
X			}
X
X
X#define IO_SETUP( fd, dp, type, ev )														\
X			{																							\
X				if ( DESCRIPTOR_INITIALIZED( dp ) ) 										\
X				{																						\
X					if ( dp->stream_type != type )											\
X					{																					\
X						errno = EBADF ;															\
X						return( ev ) ;																\
X					}																					\
X				}																						\
X				else if ( __sio_init( dp, fd, type ) == SIO_ERR )						\
X					return( ev ) ;																	\
X			}
X
X
X/*
X * Internal functions that are visible
X */
Xint __sio_readf(), __sio_writef(), __sio_pwritef() ;
Xint __sio_extend_buffer(), __sio_init(), __sio_converter(), __sio_more() ;
Xstatus_e __sio_switch() ;
X
X
X#ifdef HAS_MEMOPS
X#include <memory.h>
X#define sio_memcopy( from, to, nbytes )   	(void) memcpy( to, from, nbytes )
X#define sio_memscan( from, nbytes, ch )      memchr( from, ch, nbytes )
X#endif
X
X#ifdef HAS_BCOPY
X#define sio_memcopy( from, to, nbytes )      (void) bcopy( from, to, nbytes )
X#endif
X
X#ifndef sio_memcopy
X#define sio_memcopy		__sio_memcopy
X#define NEED_MEMCOPY
Xvoid __sio_memcopy() ;
X#endif
X
X#ifndef sio_memscan
Xchar *sio_memscan() ;
X#endif
X
X#endif /* SIO_BUFFER_SIZE */
X
END_OF_FILE
  if test 5528 -ne `wc -c <'libs/src/sio/impl.h'`; then
    echo shar: \"'libs/src/sio/impl.h'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/impl.h'
fi
if test -f 'libs/src/sio/sioconf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/sioconf.h'\"
else
  echo shar: Extracting \"'libs/src/sio/sioconf.h'\" \(5101 characters\)
  sed "s/^X//" >'libs/src/sio/sioconf.h' <<'END_OF_FILE'
X/*
X * (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X * All rights reserved.  The file named COPYRIGHT specifies the terms 
X * and conditions for redistribution.
X */
X
X
X/*
X * $Id: sioconf.h,v 8.5 1993/03/17 02:54:47 panos Exp $
X */
X
X/*
X * This file has 2 sections:
X *		1. a OS-specific section
X *		2. a CPU/compiler-specific section
X *
X * You can override/redefing any of the constants/macros in this file.
X * by uncommenting the inclusion of customconf.h and placing your own
X * definitions in that file.
X */
X
X/* #include "customconf.h" */
X
X
X
X/*
X * OS-specific section.
X *
X * Features here use the flag HAS_<feature>.
X * List of flags (check the following for macros that can be overriden):
X *
X *			HAS_MMAP (overridable macros)
X *
X *			HAS_ATEXIT
X *			HAS_ONEXIT
X *			HAS_OTHER_FINALIZER	(must define macros)
X *
X *			HAS_MEMOPS
X *			HAS_BCOPY 			(HAS_MEMOPS will be preferred if both are defined)
X *
X *	At least one of the following flags must be defined. The 2nd and 3rd
X * flags are incompatible.
X *			HAS_ISATTY
X *			HAS_SYSVTTY
X *			HAS_BSDTTY
X */
X
X/*
X * Memory mapping.
X *		The library requires 3 macros: SIO_MMAP, SIO_MUNMAP, SIO_MNEED.
X *		You can selectively override any of them.
X *		Notice that the SIO_MNEED macro is not required. If your system
X *		does not have madvise, you can define the macro as:
X *			#define SIO_MNEED( addr, len )
X */
X#ifdef HAS_MMAP
X
X#if !defined( SIO_MMAP ) || !defined( SIO_MUNMAP ) || !defined( SIO_MNEED )
X#include <sys/types.h>
X#include <sys/mman.h>
X#endif
X
X#ifndef SIO_MMAP
X#define SIO_MMAP( addr, len, fd, off )                                  \
X         mmap( addr, len, PROT_READ,                                    \
X            ( addr == 0 ) ? MAP_PRIVATE : MAP_PRIVATE + MAP_FIXED,      \
X               fd, off )
X#endif
X
X#ifndef SIO_MUNMAP
X#define SIO_MUNMAP( addr, len )  munmap( addr, len )
X#endif
X
X#ifndef SIO_MNEED
X#define SIO_MNEED( addr, len )      (void) madvise( addr, len, MADV_WILLNEED )
X#endif
X
X#endif	/* HAS_MMAP */
X
X/*
X * N_SIO_DESCRIPTORS is the maximum number of file descriptors
X * supported by the OS
X */
X#ifndef N_SIO_DESCRIPTORS
X#include <sys/param.h>
X#define N_SIO_DESCRIPTORS		NOFILE
X#endif
X
X
X
X/*
X * Finalization function. 
X *
X * The purpose of this function is to do work after your program has
X * called exit(3). In the case of SIO, this means flushing the SIO
X * output buffers.
X *
X * If your system does not support atexit or onexit but has some other
X * way of installing a finalization function, you define the flag 
X * HAS_FINALIZER. Then you must define the macros 
X *			SIO_FINALIZE and SIO_DEFINE_FIN
X *
X * SIO_FINALIZE attempts to install a finalization function and returns TRUE 
X * if successful, FALSE if unsuccessful.
X * SIO_DEFINE_FIN defines the finalization function (the reason for this macro
X * s that different systems pass different number/type of arguments to the
X * finalization function; the SIO finalization function does not use any
X * arguments).
X */
X#if defined(HAS_ONEXIT) || defined(HAS_ATEXIT) || defined(HAS_FINALIZER)
X
X#define HAS_FINALIZATION_FUNCTION
X
X#if defined( HAS_ONEXIT ) && defined( HAS_ATEXIT )
X#undef HAS_ONEXIT
X#endif
X
X#ifdef HAS_ONEXIT
X#define SIO_FINALIZE( func )        ( on_exit( func, (caddr_t) 0 ) == 0 )
X#define SIO_DEFINE_FIN( func )      static void func ( exit_status, arg )  \
X                                          int exit_status ;                \
X                                          caddr_t arg ;
X#endif	/* HAS_ONEXIT */
X
X#ifdef HAS_ATEXIT
X#define SIO_FINALIZE( func )        ( atexit( func ) == 0 )
X#define SIO_DEFINE_FIN( func )      static void func ()
X#endif	/* HAS_ATEXIT */
X
X#endif	/* HAS_ONEXIT || HAS_ATEXIT || HAS_FINALIZER */
X
X
X/*
X * HAS_MEMOPS should be defined if your OS supports the mem* functions
X * (memcpy etc). If not, then you can define HAS_BCOPY if your OS supports 
X * bcopy.
X */
X#if defined( HAS_MEMOPS ) && defined( HAS_BCOPY )
X#undef HAS_BCOPY
X#endif
X
X
X/*
X * Support for the isatty(3) function. This function identifies if a 
X * desciptor refers to a terminal.
X *
X * Case 1: isatty(3) is in the C library
X *		--> define HAS_ISATTY
X *	Case 2: no isatty(3), BSD 4.3 tty handling
X *		--> define HAS_BSDTTY
X * Case 3: no isatty(3), System V tty handling
X *		--> define HAS_SYSVTTY
X *
X * The following code checks:
X *		1) that at least one of the flags is defined
X *		2) only one of the BSD, SYS V flags is defined
X */
X#if !defined(HAS_ISATTY) && !defined(HAS_BSDTTY) && !defined(HAS_SYSVTTY)
XERROR function_isatty_not_available ;
X#endif
X
X#ifdef HAS_ISATTY
X#undef HAS_BSDTTY
X#undef HAS_SYSVTTY
X#endif
X
X#if defined(HAS_BSDTTY) && defined(HAS_SYSVTTY)
XERROR HAS_BSDTTY_and_HAS_SYSVTTY_both_defined ;
X#endif
X
X
X
X/*
X * CPU/compiler-specific section.
X *
X * The following constant affects the behavior of Sprint.
X *
X * Sprint performs integer->string conversions by first converting
X * the integer to the widest int type supported by the CPU/compiler.
X * By default, this is the "long int" type. If your machine has
X * a wider type, you can specify it by defining the WIDE_INT constant.
X * For example:
X *		#define WIDE_INT					long long
X */
X
END_OF_FILE
  if test 5101 -ne `wc -c <'libs/src/sio/sioconf.h'`; then
    echo shar: \"'libs/src/sio/sioconf.h'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/sioconf.h'
fi
if test -f 'libs/src/sio/suite/copytest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/suite/copytest.c'\"
else
  echo shar: Extracting \"'libs/src/sio/suite/copytest.c'\" \(4308 characters\)
  sed "s/^X//" >'libs/src/sio/suite/copytest.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X * All rights reserved.  The file named COPYRIGHT specifies the terms 
X * and conditions for redistribution.
X */
X
Xstatic char RCSid[] = "$Id: copytest.c,v 8.2 1993/09/08 05:59:46 panos Exp $" ;
X
X#include "sio.h"
X#include <stdio.h>
X#include <syscall.h>
X
X#ifndef RANDOM
X#define RANDOM		random
X#endif
X
X
X/*************************************************************/
X
X#ifdef TEST_Sread
X
X#define BUFFER_SIZE  4096
X
Xmain()
X{
X	char buf[ BUFFER_SIZE ] ;
X	int cc ;
X	int nbytes ;
X
X	for ( ;; )
X	{
X		nbytes = RANDOM() & ( BUFFER_SIZE - 1 ) ;
X		if ( nbytes == 0 )
X			nbytes = 1 ;
X		cc = Sread( 0, buf, nbytes ) ;
X		if ( cc == 0 )
X			break ;
X		if ( cc == SIO_ERR )
X			exit( 1 ) ;
X		write( 1, buf, cc ) ;
X	}
X	exit( 0 ) ;
X}
X#endif /* TEST_Sread */
X
X/*************************************************************/
X
X#ifdef TEST_Swrite
X
X#define BUFFER_SIZE  4096
X
Xmain()
X{
X	char buf[ BUFFER_SIZE ] ;
X	int cc ;
X	int nbytes ;
X
X	for ( ;; )
X	{
X		nbytes = RANDOM() & ( BUFFER_SIZE - 1 ) ;
X		if ( nbytes == 0 )
X			nbytes = 1 ;
X		cc = read( 0, buf, nbytes ) ;
X		if ( cc == 0 )
X			break ;
X		if ( Swrite( 1, buf, cc ) != cc )
X			exit( 1 ) ;
X	}
X	exit( 0 ) ;
X}
X#endif /* TEST_Swrite */
X
X/*************************************************************/
X
X#ifdef TEST_Srdline
X
Xmain()
X{
X	char *s ;
X	int count=0 ;
X
X	while ( s = Srdline( 0 ) )
X	{
X		puts( s ) ;
X		count++ ;
X	}
X	Sdone( 0 ) ;
X	exit( 0 ) ;
X}
X
X#endif  /* TEST_Srdline */
X
X/*************************************************************/
X
X#ifdef TEST_Sputchar
X
Xmain()
X{
X	int c ;
X
X	while ( ( c = getchar() ) != EOF )
X		if ( Sputchar( 1, c ) != c )
X			exit( 1 ) ;
X	exit( 0 ) ;
X}
X
X#endif /* TEST_Sputchar */
X
X/*************************************************************/
X
X#ifdef TEST_Sgetchar
X
Xmain()
X{
X	int c ;
X
X	while ( ( c = Sgetchar( 0 ) ) != SIO_EOF )
X		putchar( c ) ;
X	exit( 0 ) ;
X}
X
X#endif	/* TEST_Sgetchar */
X
X/*************************************************************/
X
X#ifdef TEST_Sputc
X
Xmain()
X{
X   int c ;
X 
X   while ( ( c = getchar() ) != EOF )
X      if ( Sputc( 1, c ) != c )
X         exit( 1 ) ;
X   exit( 0 ) ;
X}
X
X#endif /* TEST_Sputc */
X
X/*************************************************************/
X
X#ifdef TEST_Sgetc
X
Xmain()
X{
X   int c ;
X
X   while ( ( c = Sgetc( 0 ) ) != SIO_EOF )
X      putchar( c ) ;
X   exit( 0 ) ;
X}
X
X#endif /* TEST_Sgetc */
X
X/*************************************************************/
X
X#ifdef TEST_Sfetch
X
Xmain()
X{
X	char *s ;
X	int len ;
X
X	while ( s = Sfetch( 0, &len ) )
X		fwrite( s, 1, len, stdout ) ;
X	exit( 0 ) ;
X}
X
X#endif /* TEST_Sfetch */
X
X/*************************************************************/
X
X#ifdef TEST_Sflush
X
X#define MAX_COUNT		100
X
Xmain()
X{
X	int c ;
X	int errval ;
X	int count = 0 ;
X	int max_count = RANDOM() % MAX_COUNT + 1 ;
X
X	while ( ( c = getchar() ) != EOF )
X		if ( Sputchar( 1, c ) != c )
X			exit( errval ) ;
X		else
X		{
X			count++ ;
X			if ( count >= max_count )
X			{
X				errval = Sflush( 1 ) ;
X				if ( errval != 0 )
X					exit( 1 ) ;
X				max_count = RANDOM() % MAX_COUNT + 1 ;
X				count = 0 ;
X			}
X		}
X	exit( 0 ) ;
X}
X
X#endif /* TEST_Sflush */
X
X/*************************************************************/
X
X#ifdef TEST_Sundo
X
Xmain()
X{
X	int c ;
X	char *s ;
X	int errval ;
X
X	for ( ;; )
X	{
X		if ( RANDOM() % 1 )
X		{
X			s = Srdline( 0 ) ;
X			if ( s == NULL )
X				break ;
X			if ( RANDOM() % 16 < 5 )
X			{
X				errval = Sundo( 0, SIO_UNDO_LINE ) ;
X				if ( errval == SIO_ERR )
X					exit( 1 ) ;
X			}
X			else
X				puts( s ) ;
X		}
X		else
X		{
X			c = Sgetchar( 0 ) ;
X			if ( c == SIO_EOF )
X				break ;
X			if ( RANDOM() % 16 < 5 )
X			{
X				errval = Sundo( 0, SIO_UNDO_CHAR ) ;
X				if ( errval == SIO_ERR )
X					exit( 2 ) ;
X			}
X			else
X				putchar( c ) ;
X		}
X	}
X	exit( 0 ) ;
X}
X
X#endif /* TEST_Sundo */
X
X
X#if defined( TEST_switch ) || defined( TEST_switch2 )
X
Xmain()
X{
X	int c ;
X	char *s ;
X	int lines = 4000 ;
X
X	for ( ;; )
X	{
X		c = Sgetchar( 0 ) ;
X		if ( c == SIO_EOF )
X			exit( 0 ) ;
X		if ( c == SIO_ERR )
X			exit( 1 ) ;
X		putchar( c ) ;
X		if ( c == '\n' )
X		{
X			lines-- ;
X			if ( lines == 0 )
X				break ;
X		}
X	}
X	while ( s = Srdline( 0 ) )
X		puts( s ) ;
X	exit( 0 ) ;
X}
X
X#ifdef TEST_switch2
X
Xchar *mmap( addr, len, prot, type, fd, off )
X	char *addr ;
X	int len, prot, type, fd, off ;
X{
X	return( (char *)-1 ) ;
X}
X
X#endif	/* TEST_switch2 */
X
X#endif 	/* TEST_switch */
X
X
X
END_OF_FILE
  if test 4308 -ne `wc -c <'libs/src/sio/suite/copytest.c'`; then
    echo shar: \"'libs/src/sio/suite/copytest.c'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/suite/copytest.c'
fi
if test -f 'libs/src/sio/suite/tester' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/sio/suite/tester'\"
else
  echo shar: Extracting \"'libs/src/sio/suite/tester'\" \(3962 characters\)
  sed "s/^X//" >'libs/src/sio/suite/tester' <<'END_OF_FILE'
X#!/bin/sh
X
X# (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X# All rights reserved.  The file named COPYRIGHT specifies the terms 
X# and conditions for redistribution.
X
X
X#
X# $Id: tester,v 8.3 1993/09/08 05:59:30 panos Exp $
X#
X
X#
X# Usage:
X#			tester [all] [function-name function-name ...]
X#
X# function-name is the name of a sio function (or macro)
X#
X# If "all" is used, functions after it will *not* be tested.
X#
X
Xscript_name=`basename $0`
X
Xcopy_file=/usr/dict/words
Xtemp_file=/tmp/w
Xmake_log=MAKE.LOG
X
Xif test ! -f $copy_file ; then
X	echo "The file '$copy_file' is not available."
X	echo "Please edit the '$script_name' script and change set the"
X	echo "variable 'copy_file' to the name of a publicly readable file"
X	echo "with at least a few tens of thousands of lines."
X	exit 1
Xfi
X
Xtrap_function()
X{
X	rm -f $temp_file $make_log
X	echo
X	exit 1
X}
X
X
Xmake_program()
X{
X	target=$1
X	cflags="$2"
X	if test -f $1 -a ! -x $1 ; then rm -f $1 ; fi
X	if test "$cflags"
X	then
X		make -s "$cflags" $target >$make_log 2>&1
X	else
X		make -s $target >$make_log 2>&1
X	fi
X	exit_code=$?
X	if test $exit_code -eq 0 -a -x $1
X	then
X		rm -f $make_log
X	else
X		echo "FAILED"
X		echo "   The make failed. Check the make log file << $make_log >>"
X		exit
X	fi
X}
X
X
X
X#
X# test_function expects a single argument, the name of the function
X# it will test.
X# It creates a program that has the name of the function by invoking
X# make with the symbol -DTEST_<function_name>
X#
Xtest_function()
X{
X	expression="echo $"$1
X	var=`eval $expression`
X	if test "$var" = "no" -o "$var" = "" -a "$all" = "no" ; then return ; fi
X
X	echo -n "TESTING $1 "
X	make_program $1 "DEFS=-DTEST_$1"
X
X	./$1 < $copy_file >$temp_file
X	exit_code=$?
X	if test $exit_code -ne 0
X	then
X		echo "FAILED"
X		echo "   Test program exited with exit code $exit_code"
X		echo "   Temporary file << $temp_file >> not deleted"
X		exit
X	fi
X	cmp -s $copy_file $temp_file
X	if test $? -ne 0
X	then
X		echo "FAILED"
X		echo "   The files << $copy_file >> and << $temp_file >> are not the same"
X		exit
X	else
X		echo PASSED
X	fi
X	rm -f $temp_file
X}
X
X
Xtest_sprint()
X{
X	var=$Sprint
X	program=Sprint
X	if test "$var" = "no" -o "$var" = "" -a "$all" = "no" ; then return ; fi
X
X	echo TESTING Sprint
X	make_program $program ""
X	$TESTSHELL sprint_test
X}
X
X
Xtest_smorefds()
X{
X	var=$Smorefds
X	program=fdtest
X	if test "$var" = "no" -o "$var" = "" -a "$all" = "no" ; then return ; fi
X
X	echo -n "TESTING Smorefds "
X	make_program $program "DEFS="
X	v=`fdtest 2>&1`
X	if test $? -eq 0 ; then
X		echo PASSED
X	else
X		echo "FAILED: $v"
X	fi
X}
X
X
Xtrap trap_function 1 2 3 15
X
X#
X# There is a variable for every function to be tested. That variable
X# can have the values "yes", "no" or "".
X# When a function is specified, it takes the value of $run. Initially $run 
X# is "yes", so a specified function has its variable set to "yes". 
X# If "all" is specified, $run becomes "no", so subsequently specified
X# functions, have their variables set to "no".
X#
X# We test a function iff:
X#		its variable is "yes" OR its variable is "" and $all is "yes"
X# We don't test a function iff:
X#		its variable is "no" OR its variable is "" and $all is "no"
X#		
X# Therefore, all functions specified after "all" will NOT be tested.
X#
Xrun=yes
Xall=no
X
Xwhile test $# -gt 0
Xdo
X	case $1 in
X		Sputchar)	Sputchar=$run ;;
X		Sgetchar)	Sgetchar=$run ;;
X		Srdline)		Srdline=$run ;;
X		Sfetch)		Sfetch=$run ;;
X		Sread)		Sread=$run ;;
X		Swrite)		Swrite=$run ;;
X		Sgetc)		Sgetc=$run ;;
X		Sputc)		Sputc=$run ;;
X		Sflush)		Sflush=$run ;;
X		Sundo)		Sundo=$run ;;
X		Sprint)		Sprint=$run ;;
X		switch)		switch=$run ;;
X		switch2)		switch2=$run ;;
X		Smorefds)	Smorefds=$run ;;
X		all)			all=yes ; run="no" ;;
X		*) echo Bad argument: $1
X	esac
X	shift
Xdone
X
Xtest_function Sgetchar
Xtest_function Sputchar
Xtest_function Sread
Xtest_function Swrite
Xtest_function Srdline
Xtest_function Sfetch
Xtest_function Sgetc
Xtest_function Sputc
Xtest_function Sflush
Xtest_function Sundo
Xtest_function switch
Xtest_function switch2
Xtest_smorefds
Xtest_sprint
X
END_OF_FILE
  if test 3962 -ne `wc -c <'libs/src/sio/suite/tester'`; then
    echo shar: \"'libs/src/sio/suite/tester'\" unpacked with wrong size!
  fi
  # end of 'libs/src/sio/suite/tester'
fi
if test -f 'libs/src/str/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/str/Makefile'\"
else
  echo shar: Extracting \"'libs/src/str/Makefile'\" \(4534 characters\)
  sed "s/^X//" >'libs/src/str/Makefile' <<'END_OF_FILE'
X# (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X# All rights reserved.  The file named COPYRIGHT specifies the terms 
X# and conditions for redistribution.
X
X#
X# $Id: Makefile,v 3.3 1993/11/12 20:15:25 panos Exp $
X#
X# Based on Library makefile template: *Revision: 1.15 *
X#
X
X# 
X# Available entries:
X# 		lib 			--> creates the library
X#		install		--> installs the library (archive, man page(s), header(s))
X#		uninstall	--> uninstall the library
X#		clean			--> removes all .o and .a files
X#		spotless		--> clean + uninstall
X# 		lint			--> lints a file (usage: make lint MODULE=foo.c)
X#		tags			--> creates a tags file (from the SOURCES and HEADERS)
X#		checkout 	--> checkout all files
X#		dist			--> distribution support
X#
X
XNAME				= str
XVERSION			= 1.4.2
X
XHEADERS			= str.h strparse.h \
X						ss_impl.h ss_rk.h ss_kmp.h ss_sbm.h ss_bmh.h ss_so.h
XSOURCES			= strutil.c strprint.c strparse.c strs.c \
X						ss_rk.c ss_kmp.c ss_bf.c ss_sbm.c ss_bmh.c ss_so.c
XOBJECTS			= strutil.o strprint.o strparse.o strs.o \
X						ss_rk.o ss_kmp.o ss_bf.o ss_sbm.o ss_bmh.o ss_so.o
X
XMANFILES			= strparse.3 strprint.3 strutil.3 strs.3
XINCLUDEFILES	= str.h
X
X# The following variables are used by the 'install' entry and
X# should be customized:
X#     LIBDIR:     where the library will be placed
X#     INCUDEDIR:  where the include files will be placed
X#     MANDIR:     where the man pages will be placed
X#
XLIBDIR			= $(HOME)/.links/libraries/$(ARCH)
XMANDIR			= $(HOME)/.links/manpages/man3
XINCLUDEDIR		= $(HOME)/.links/includes
X
X#
X# Available flags
X#	NBIC				: number of bits in a character variable (defaults to 8)
X#	WIDE_INT			: widest integer supported by the CPU/compiler
X#						  (defaults to 'long')
X#	WIDE_INT_SIZE  : size of the WIDE_INT type in bits (defaults to 32);
X#						  effective (and required) only when WIDE_INT is defined
X#	NO_SIO			: if the SIO library is not available (results in turning
X#						  all the string printing functions to no-ops)
X#
XDEFS				= 		# for example, -DNO_SIO
XDEBUG				= -g				# -g or -O
XVERSION_DEF		= -DVERSION=\"STR\ Version\ $(VERSION)\"
X
XCPP_DEFS			= $(VERSION_DEF) $(DEFS)
X
X#
X# The following variables shouldn't need to be changed
X#
XLINT_FLAGS		= -hbux
XCPP_FLAGS		= $(CPP_DEFS) -I$(INCLUDEDIR)
XCC_FLAGS			= $(DEBUG)
XCFLAGS			= $(CPP_FLAGS) $(CC_FLAGS)
X
XINSTALL			= install -c
XFMODE				= -m 640			# used by install
XRANLIB			= ranlib
X
XPAGER				= less
X
X
XLIBNAME			= lib$(NAME).a
X
Xlib: $(LIBNAME)
X
Xlibopt: clean
X	make DEBUG=-O "DEFS=$(DEFS)" lib
X	$(INSTALL) $(FMODE) $(LIBNAME) $(LIBDIR)-O
X
X$(LIBNAME): $(OBJECTS)
X	ar r $@ $?
X	$(RANLIB) $@
X
XLINT_IGNORE=possible pointer alignment|RCSid unused
X
Xlint:
X	lint $(CPP_FLAGS) $(LINT_FLAGS) $(MODULE) 2>&1 | egrep -v '$(LINT_IGNORE)' | $(PAGER)
X
Xinstall: $(LIBNAME)
X	@if test "$(LIBDIR)" -a "$(INCLUDEDIR)" -a "$(MANDIR)" ;\
X	then \
X		$(INSTALL) $(FMODE) $(LIBNAME) $(LIBDIR) ;\
X		echo "Installed $(LIBNAME) to $(LIBDIR)" ;\
X		for i in $(INCLUDEFILES); do $(INSTALL) $(FMODE) $$i $(INCLUDEDIR) ; done ;\
X		echo Installed $(INCLUDEFILES) to $(INCLUDEDIR) ;\
X		for i in $(MANFILES) ; do $(INSTALL) $(FMODE) $$i $(MANDIR) ; done ;\
X		echo Installed $(MANFILES) to $(MANDIR) ;\
X	else \
X		echo "You forgot to set one of the following variables: LIBDIR,INCLUDEDIR,MANDIR" ;\
X	fi
X
Xuninstall:
X	a=`pwd` ; cd $(INCLUDEDIR) ;\
X	if test $$a != `pwd` ; then rm -f $(INCLUDEFILES) ; fi
X	a=`pwd` ; cd $(LIBDIR) ;\
X	if test $$a != `pwd` ; then rm -f $(LIBNAME) ; fi
X	a=`pwd` ; cd $(MANDIR) ;\
X	if test $$a != `pwd` ; then rm -f $(MANFILES) ; fi
X
Xclean:
X	rm -f $(OBJECTS) $(LIBNAME) core
X
Xspotless: clean uninstall
X
Xtags: $(SOURCES) $(HEADERS)
X	ctags -w $(SOURCES) $(HEADERS)
X
Xcheckout:
X	co $(SOURCES) $(HEADERS) $(MANFILES)
X
X#
X# Distribution section
X# This section contains the 2 targets for distribution support: dist, dirs
X# "dist" checks out all files to be distributed
X# "dirs" prints a list of directories to be included in the distribution.
X# These directories should have a Makefile with a "dist" target
X#
XDISTRIBUTION_FILES	= $(SOURCES) $(HEADERS) $(MANFILES) COPYRIGHT README
XDIRS						=
X
Xdist:
X	-co -q $(DISTRIBUTION_FILES)
X
Xdirs:
X	@echo $(DIRS)
X
X#
X# PUT HERE THE RULES TO MAKE THE OBJECT FILES
X#
Xstrparse.o:		strparse.h str.h
Xstrprint.o:		str.h
Xstrutil.o:		str.h
Xstrs.o:			ss_impl.h str.h
Xss_bf.o:			ss_impl.h
Xss_rk.o:			ss_impl.h ss_rk.h
Xss_kmp.o:		ss_impl.h ss_kmp.h
Xss_sbm.o:		ss_impl.h ss_sbm.h
Xss_bmh.o:		ss_impl.h ss_bmh.h
Xss_so.o:			ss_impl.h ss_so.h
X
X
X#
X# Test program
X#
Xtt: tt.c $(LIBNAME)
X	$(CC) -I$(INCDIR) -g -o $@ tt.c $(LIBNAME) -L$(LIBDIR) -lsio -lmisc
X
END_OF_FILE
  if test 4534 -ne `wc -c <'libs/src/str/Makefile'`; then
    echo shar: \"'libs/src/str/Makefile'\" unpacked with wrong size!
  fi
  # end of 'libs/src/str/Makefile'
fi
if test -f 'libs/src/str/strparse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/str/strparse.c'\"
else
  echo shar: Extracting \"'libs/src/str/strparse.c'\" \(4683 characters\)
  sed "s/^X//" >'libs/src/str/strparse.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X * All rights reserved.  The file named COPYRIGHT specifies the terms 
X * and conditions for redistribution.
X */
X
Xstatic char RCSid[] = "$Id: strparse.c,v 3.1 1993/06/13 02:48:19 panos Exp $" ;
Xstatic char version[] = VERSION ;
X
X#include "str.h"
X#include "strparse.h"
X
Xchar *strcpy() ;
Xchar *strncpy() ;
Xchar *strpbrk() ;
X
Xchar *malloc() ;
X
Xint str_errno ;
X
X
XPRIVATE char *new_string( s )
X	register char *s ;
X{
X	register char *p = malloc( (unsigned)strlen( s ) + 1 ) ;
X
X	return( p ? strcpy( p, s ) : p ) ;
X}
X
X
Xstr_h str_parse( str, separ, flags, errnop )
X	register char	*str ;
X	char				*separ ;
X	int				flags ;
X	int				*errnop ;
X{
X	register struct str_handle *hp ;
X	int *errp = ( errnop == NULL ) ? &str_errno : errnop ;
X
X	if ( separ == NULL )
X		HANDLE_ERROR( flags, NULL, errp, STR_ENULLSEPAR,
X								"STR str_parse: NULL separator\n" ) ;
X
X	hp = (struct str_handle *) malloc( sizeof( struct str_handle ) ) ;
X	if ( hp == NULL )
X		HANDLE_ERROR( flags, NULL, errp, STR_ENOMEM,
X								"STR str_parse: malloc failed\n" ) ;
X
X	hp->string = str ;
X	hp->pos = str ;
X	hp->separator = new_string( separ ) ;
X	if ( hp->separator == NULL )
X		if ( flags & STR_RETURN_ERROR )
X		{
X			free( (char *) hp ) ;
X			*errp = STR_ENOMEM ;
X			return( NULL ) ;
X		}
X		else
X			TERMINATE( "STR str_parse: malloc failed\n" ) ;
X	
X	hp->flags = flags ;
X	hp->errnop = errp ;
X	hp->no_more = ( str == NULL ) ;
X	return( (str_h) hp ) ;
X}
X
X
Xvoid str_endparse( handle )
X	str_h handle ;
X{
X	register struct str_handle *hp = (struct str_handle *) handle ;
X
X	free( hp->separator ) ;
X	free( (char *) handle ) ;
X}
X
X
X/*
X * Change the string
X */
Xint str_setstr( handle, newstr )
X	str_h handle ;
X	char *newstr ;
X{
X	register struct str_handle *hp = (struct str_handle *) handle ;
X	
X	if ( newstr == NULL )
X		HANDLE_ERROR( hp->flags, STR_ERR, hp->errnop, STR_ENULLSTRING,
X								"STR str_setstr: NULL string\n" ) ;
X	
X	hp->string = newstr ;
X	hp->pos = newstr ;
X	hp->no_more = FALSE ;
X	return( STR_OK ) ;
X}
X
X
X
X/*
X * Change the separator
X */
Xint str_separator( handle, separator )
X	str_h handle ;
X	char *separator ;
X{
X	register struct str_handle *hp = (struct str_handle *) handle ;
X	char *new_separator ;
X
X	if ( separator == NULL )
X		HANDLE_ERROR( hp->flags, STR_ERR, hp->errnop, STR_ENULLSEPAR,
X								"STR str_separator: NULL separator\n" ) ;
X	new_separator = new_string( separator ) ;
X	if ( new_separator == NULL )
X		HANDLE_ERROR( hp->flags, STR_ERR, hp->errnop, STR_ENOMEM,
X			"STR str_separator: malloc failed\n" ) ;
X
X	free( hp->separator ) ;
X	hp->separator = new_separator ;
X	return( STR_OK ) ;
X}
X
X
Xchar *str_nextpos( handle )
X	str_h handle ;
X{
X	struct str_handle *hp = (struct str_handle *) handle ;
X
X	if ( hp->no_more || *hp->pos == '\0' )
X		return( NULL ) ;
X	else
X		return( hp->pos ) ;
X}
X
X
Xchar *str_component( handle )
X	str_h handle ;
X{
X	register char						*start ;
X	register char						*last ;
X	register int						sep_count ;
X	char									*retval ;
X	int									last_char ;
X	register struct str_handle		*hp			= (struct str_handle *) handle ;
X	register int						first_call	= ( hp->pos == hp->string ) ;
X
X	if ( hp->no_more )
X		return( NULL ) ;
X
X	/*
X	 * Get number of separator characters.
X	 * Find beginning of component.
X	 */
X	sep_count = strspn( hp->pos, hp->separator ) ;
X
X	/*
X	 * If this is the first call, and there are separator characters
X	 * at the beginning of the string and the STR_NULL_START flag is set
X	 * we return a 0-length string.
X	 */
X	if ( first_call && sep_count > 0 && ( hp->flags & STR_NULL_START ) )
X	{
X		start = hp->pos ;
X		last = hp->pos ;
X	}
X	else
X	{
X		start = hp->pos + sep_count ;
X
X		if ( *start == '\0' )
X		{
X			last = start ;
X			hp->no_more = TRUE ;
X			if ( ! ( hp->flags & STR_NULL_END ) )
X				return( NULL ) ;
X		}
X		else
X		{
X			last = strpbrk( start, hp->separator ) ;
X			if ( last == NULL )
X				last = start + strlen( start ) ;
X		}
X	}
X
X	/*
X	 * At this point, the following variables must be set:
X	 *		start:	beginning of component
X	 *		last:   	end of component + 1
X	 *
X	 * If STR_MALLOC is set, allocate space for the new string.
X	 *
X	 * NOTE: If STR_MALLOC is not set, the processed string is trashed.
X	 */
X	last_char = *last ;
X	if ( hp->flags & STR_MALLOC )
X	{
X		int len = last - start ;
X
X		retval = malloc( (unsigned)len + 1 ) ;
X		if ( retval == NULL )
X			HANDLE_ERROR( hp->flags, NULL, hp->errnop, STR_ENOMEM,
X											"STR str_component: malloc failed\n" ) ;
X		strncpy( retval, start, len )[ len ] = '\0' ;
X	}
X	else
X	{
X		retval = start ;
X		*last = '\0' ;
X	}
X
X	/*
X	 * Check if last_char is NUL to avoid setting hp->pos past the
X	 * end of the string
X	 */
X	hp->pos = ( last_char == '\0' ) ? last : last+1 ;
X	return( retval ) ;
X}
X
X
END_OF_FILE
  if test 4683 -ne `wc -c <'libs/src/str/strparse.c'`; then
    echo shar: \"'libs/src/str/strparse.c'\" unpacked with wrong size!
  fi
  # end of 'libs/src/str/strparse.c'
fi
if test -f 'libs/src/str/strs.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libs/src/str/strs.3'\"
else
  echo shar: Extracting \"'libs/src/str/strs.3'\" \(4394 characters\)
  sed "s/^X//" >'libs/src/str/strs.3' <<'END_OF_FILE'
X.\"(c) Copyright 1992, 1993 by Panagiotis Tsirigotis
X.\"All rights reserved.  The file named COPYRIGHT specifies the terms 
X.\"and conditions for redistribution.
X.\"
X.\" $Id: strs.3,v 3.1 1993/06/13 02:49:50 panos Exp $
X.TH STRS 3X "12 June 1993"
X.SH NAME
Xstrs_setup, strs_match, strs_done, strs_search - string matching functions
X.SH SYNOPSIS
X.LP
X.nf
X.ft B
X#include "str.h"
X.LP
X.ft B
Xstrs_h strs_setup( flags, pattern [, patlen] )
Xint flags ;
Xchar *pattern ;
X.LP
X.ft B
Xchar *strs_match( handle, str, len )
Xstrs_h handle ;
Xchar *str ;
Xint len ;
X.LP
X.ft B
Xvoid strs_done( handle )
Xstrs_h handle ;
X.LP
X.ft B
Xchar *strs_search( flags, str, len, pattern [, patlen] )
Xint flags ;
Xchar *str ;
Xint len ;
Xchar *pattern ;
X.SH DESCRIPTION
X.LP
XThese functions perform string matching. They have been designed with
Xthe assumption that one needs to find a certain pattern in a set of
Xstrings. It is also possible to use them to find if a pattern occurs
Xin a specific string.
X.LP
X.B strs_setup()
Xis used to specify the pattern to look for. It returns a
X.I handle
Xwhich is used in subsequent string matching operations against
Xthe specified
X.I pattern.
XThe
X.I flags
Xargument has two parts: a search method and generic flags.
XThe available search methods include the following algorithms:
X.RS
X.TP 15
X.SB STRS_BF
Xbrute force algorithm (also called naive in the literature). 
X.TP
X.SB STRS_RK
XRabin-Karp algorithm (probabilistic).
X.TP
X.SB STRS_KMP
XKnuth-Morris-Pratt algorithm.
X.TP
X.SB STRS_SBM
XSimple Boyer-Moore (uses only the last occurrence heuristic).
X.TP
X.SB STRS_BMH
XThis is the Boyer-Moore algorithm using the last occurrence heuristic
Xas modified by Horspool (this is faster than the simple Boyer-Moore).
X.TP
X.SB STRS_SO
XShift-Or algorithm (this algorithm works only for patterns whose length
Xdoes not exceed the number of bits in a word).
X.RE
X.LP
XThe default algorithm is the brute force method.
XIn practice, the fastest algorithm is the
XBoyer-Moore-Horspool one.
X.LP
XThe flags that can be specified include:
X.RS
X.TP 15
X.SB STRS_NOMALLOC
Xdo not allocate space for the pattern. This can be specified if
Xthe pattern space will be available during the matching phase
X(i.e. do not use this flag if the pattern space was malloc'ed and
Xyou free it before doing any matching).
X.TP
X.SB STRS_IGNCASE
Xperform case-insensitive string matching
X(the default is case-sensitive matching).
X.TP
X.SB STRS_NOSWITCH
Xdisallows switching to another search method; a switch to the brute
Xforce algorithm happens if the length of the pattern is less than 4
Xor if the initialization of the specified search algorithm fails (for
Xexample, when using the shift-or algorithm with a very long pattern).
XWhen this flag is used, no switch happens.
X.TP
X.SB STRS_PATLEN
Xis used to explicitly specify the length of the pattern
X(with the
X.I patlen
Xargument); normally the pattern is assumed to be NUL-terminated.
X.RE
X.LP
X.B strs_match()
Xtries to match the string specified by
X.I str
Xagainst the pattern identified by
X.I handle.
XSince the length of the string is given by the
X.I len
Xargument the string does not need to be NUL-terminated.
X.B strs_done()
Xshould be invoked after all matching against the pattern identified by
X.I handle
Xis done.
X.LP
X.B strs_search()
Xis equivalent to:
X.LP
X.PD .1v
X.nf
X.RS
Xh = strs_setup( flags, pattern ) ;
Xp = strs_match( h, str, len ) ;
Xstrs_done( h ) ;
Xreturn( p ) ;
X.RE
X.PD
X.SH "RETURN VALUES"
X.LP
X.B strs_setup()
Xreturns a search handle on success or
X.SM NULL
Xon failure.
X.LP
X.B strs_match()
Xand
X.B strs_search()
Xreturn a pointer to the first occurrence of the pattern in the string or
X.SM NULL
Xif the pattern does not occur in the string.
X.SH "SEE ALSO"
XDonald E. Knuth, James H. Morris, Vaughan R. Pratt.
XFast pattern matching in strings.
XSIAM Journal on Computing, 6(2):323-350, 1977.
X.LP
XRichard M. Karp, Michael O. Rabin.
XEfficient randomized pattern-matching algorithms.
XTechnical Report TR-31-81,
XAiken Computation Laboratory, Harvard University, 1981.
X.LP
XRobert S. Boyer, J. Strother Moore.
XA fast string-searching algorithm.
XCommunications of the ACM, 20(10):762-772, 1977.
X.LP
XN. Horspool.
XPractical fast searching in strings.
XSoftware - Practice and Experience, 10:501-506, 1980.
X.LP
XR. Baeza-Yates, G.H. Gonnet.
XA new approach to text searching.
XProceedings of 12th SIGIR, June 1989.
X.LP
XThomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest.
XIntroduction to Algorithms.
XMcGraw-Hill 1990.
END_OF_FILE
  if test 4394 -ne `wc -c <'libs/src/str/strs.3'`; then
    echo shar: \"'libs/src/str/strs.3'\" unpacked with wrong size!
  fi
  # end of 'libs/src/str/strs.3'
fi
if test -f 'pst/dvi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pst/dvi.c'\"
else
  echo shar: Extracting \"'pst/dvi.c'\" \(5447 characters\)
  sed "s/^X//" >'pst/dvi.c' <<'END_OF_FILE'
X/*
X * (c) Copyright 1993 by Panagiotis Tsirigotis
X * All rights reserved.  The file named COPYRIGHT specifies the terms 
X * and conditions for redistribution.
X */
X
Xstatic char RCSid[] = "$Id: dvi.c,v 1.3 1993/02/10 21:16:36 panos Exp $" ;
X
X#include <ctype.h>
X
X#include "sio.h"
X
X#include "defs.h"
X
X
Xint get_file_char( fdp )
X	int *fdp ;
X{
X	return( next_char( *fdp ) ) ;
X}
X
X
X/*
X * This function is called for lines starting with '%'
X */
XPRIVATE int check_for_new_page( fd )
X	int fd ;
X{
X	char *line ;
X	char *page_id = "Page:" ;
X	int id_len = strlen( page_id ) ;
X	int new_page = FALSE ;
X	void start_paragraph() ;
X
X	while ( line = Srdline( fd ) )
X	{
X		if ( line[0] != '%' )
X		{
X			Sundo( fd, SIO_UNDO_LINE ) ;
X			break ;
X		}
X		line_count++ ;
X		if ( line[1] != '%' )
X			continue ;
X		if ( strncmp( &line[2], page_id, id_len ) == 0 )
X		{
X			if ( ! new_page )
X				start_paragraph() ;
X			new_page = TRUE ;
X		}
X	}
X	return( new_page ) ;
X}
X
X
Xvoid dvi_process( fd )
X	int fd ;
X{
X	int c ;
X	int num ;
X	int output_string = FALSE ;
X	int last_cmd = SPACE ;
X	token_e last_token = TOK_OTHER ;
X	void process_string() ;
X	void skip_until() ;
X	void skip_bracket() ;
X	void decode_string() ;
X
X	for ( ;; )
X	{
X		NEXT_CHAR( fd, c ) ;
X		if ( c == SIO_EOF )
X			break ;
X		
X		if ( c == '%' )
X		{
X			skip_until( fd, NEWLINE ) ;
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X
X		if ( c == SPACE )
X			continue ;
X
X		if ( c == NEWLINE )
X		{
X			/*
X			 * Peek at the next character to check if it is a line beginning 
X			 * with '%%'
X			 */
X			NEXT_CHAR( fd, c ) ;
X			if ( c == SIO_EOF )
X				break ;
X			PUTBACK( fd, c ) ;
X
X			if ( c != '%' )
X				continue ;
X
X			if ( check_for_new_page( fd ) )
X				output_string = FALSE ;
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X		
X		if ( c == SLASH )
X		{
X			for ( ;; )
X			{
X				NEXT_CHAR( fd, c ) ;
X				if ( c == SIO_EOF )
X					error( "Reached EOF reading literal\n" ) ;
X				if ( ! isalnum( c ) )
X				{
X					PUTBACK( fd, c ) ;
X					break ;
X				}
X			}
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X
X		/*
X		 * This piece of code has been commented out because I have found
X		 * valid Postscript files that contain an unbalanced number of '['.
X		 * Specifically, this is what was found:
X		 *
X		 *		81[31 52[28 3[31 19 22 25 31 1[28 31 47 16 2[16 31 28 19 25
X		 *
X		 * The reason may be that the '[' between numbers has a different
X		 * meaning but I could not find such a reference in the
X		 * Postscript Language Reference Manual
X		 *
X		if ( c == OPEN_BRACKET )
X		{
X			skip_bracket( fd, OPEN_BRACKET, CLOSED_BRACKET ) ;
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X		 *
X		 */
X
X		if ( c == OPEN_CURLY_BRACKET )
X		{
X			skip_bracket( fd, OPEN_CURLY_BRACKET, CLOSED_CURLY_BRACKET ) ;
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X
X		if ( c == LESS_THAN )
X		{
X			skip_until( fd, GREATER_THAN ) ;
X			last_token = TOK_OTHER ;
X			continue ;
X		}
X
X		if ( c == OPEN_PAREN )
X		{
X			decode_string( get_file_char, (void *)&fd ) ;
X			output_string = TRUE ;
X			last_token = TOK_STRING ;
X			continue ;
X		}
X
X		if ( c == MINUS )
X		{
X			/*
X			 * Check for a negative number
X			 */
X			NEXT_CHAR( fd, c ) ;
X			if ( ! isdigit( c ) )
X			{
X				PUTBACK( fd, c ) ;
X				continue ;
X			}
X			num = -get_num( fd, c ) ;
X			last_token = TOK_NUMBER ;
X			continue ;
X		}
X
X		if ( isdigit( c ) )
X		{
X			num = get_num( fd, c ) ;
X
X			/*
X			 * Check if we got 2 number tokens in a row
X			 */
X			if ( last_token == TOK_NUMBER )
X			{
X				/*
X				 * We got an (x,y) pair denoting the beginning of a line.
X				 * Do a line-feed if the last output was a string
X				 */
X				if ( output_string )
X				{
X					printout( NEWLINE ) ;
X					output_string = FALSE ;
X				}
X			}
X			last_token = TOK_NUMBER ;
X			continue ;
X		}
X
X		if ( isalpha( c ) )
X		{
X			char letter_buf[ 16 ] ;
X			int li = 0 ;			/* letter buf index */
X			int n_letters = 0 ;
X
X			letter_buf[ li++ ] = c ;
X			n_letters++ ;
X
X			for ( ;; )
X			{
X				NEXT_CHAR( fd, c ) ;
X				if ( c == SIO_EOF )
X					break ;
X				if ( ! isalnum( c ) )
X				{
X					PUTBACK( fd, c ) ;
X					break ;
X				}
X				letter_buf[ li++ ] = c ;
X				li %= sizeof( letter_buf ) ;
X				n_letters++ ;
X			}
X
X			if ( n_letters > 2 )			/* ignore */
X			{
X				last_token = TOK_OTHER ;
X				continue ;
X			}
X
X			/*
X			 * We have a command: identify it
X			 */
X			switch ( letter_buf[ 0 ] )
X			{
X				case 'l':
X				case 'm':
X				case 'n':
X				case 'o':
X				case 'p':
X				case 'q':
X				case 'r':
X				case 's':
X				case 't':
X					break ;			/* command requires no action */
X				
X				default:
X					if ( output_string )
X					{
X						int print_space = FALSE ;
X
X						switch ( last_token )
X						{
X							case TOK_NUMBER:
X								if ( num >= 0 )
X									print_space = TRUE ;
X								break ;
X
X							case TOK_CMD:
X								if ( last_cmd != 'p' )
X									print_space = TRUE ;
X								break ;
X
X							default:
X								print_space = TRUE ;
X						}
X
X						if ( print_space )
X						{
X							printout( SPACE ) ;
X							output_string = FALSE ;
X						}
X					}
X			}
X			last_cmd = letter_buf[ 0 ] ;
X			last_token = TOK_CMD ;
X		}
X	}
X}
X
X
XPRIVATE int get_num( fd, c )
X	int fd ;
X	int c ;
X{
X	int num = NUM( c ) ;
X
X	for ( ;; )
X	{
X		NEXT_CHAR( fd, c ) ;
X		if ( c == SIO_EOF )
X			error( "Unexpected end of file while reading number\n" ) ;
X
X		if ( isdigit( c ) )
X		{
X			num *= 10 ;
X			num += NUM( c ) ;
X		}
X		else if ( isalpha( c ) )
X			error( "Unexpected character terminating number: '%c'\n", c ) ;
X		else if ( c == SPACE || c == NEWLINE )
X			break ;
X		else
X		{
X			PUTBACK( fd, c ) ;
X			break ;
X		}
X	}
X	return( num ) ;
X}
X
END_OF_FILE
  if test 5447 -ne `wc -c <'pst/dvi.c'`; then
    echo shar: \"'pst/dvi.c'\" unpacked with wrong size!
  fi
  # end of 'pst/dvi.c'
fi
echo shar: End of archive 3 \(of 6\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
