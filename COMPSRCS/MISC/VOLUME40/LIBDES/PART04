From: eay@psych.psy.uq.oz.au (Eric Young)
Newsgroups: comp.sources.misc
Subject: v40i011: libdes - DES encryption library, Part04/05
Date: 14 Oct 1993 18:02:03 +0100
Sender: aem@aber.ac.uk
Approved: aem@aber.ac.uk
Message-ID: <29k0mb$1mf@uk-usenet.uk.sun.com>
X-Md4-Signature: 8bef35f5ae2281ee43bbbbc760c475f4

Submitted-by: eay@psych.psy.uq.oz.au (Eric Young)
Posting-number: Volume 40, Issue 11
Archive-name: libdes/part04
Environment: C
Supersedes: libdes: Volume 29, Issue 43-46

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  ARTISTIC FILES MODES.DES des.h des.man ecb_enc.c
#   enc_read.c makefile pcbc_enc.c set_key.c speed.c str2key.c times
#   vms.com
# Wrapped by alecm@uk-usenet on Wed Oct 13 10:33:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 5)."'
if test -f 'ARTISTIC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ARTISTIC'\"
else
  echo shar: Extracting \"'ARTISTIC'\" \(4642 characters\)
  sed "s/^X//" >'ARTISTIC' <<'END_OF_FILE'
X
X			 The "Artistic License"
X
X				Preamble
X
XThe intent of this document is to state the conditions under which a
XPackage may be copied, such that the Copyright Holder maintains some
Xsemblance of artistic control over the development of the package,
Xwhile giving the users of the package the right to use and distribute
Xthe Package in a more-or-less customary fashion, plus the right to make
Xreasonable modifications.
X
XDefinitions:
X
X	"Package" refers to the collection of files distributed by the
X	Copyright Holder, and derivatives of that collection of files
X	created through textual modification.
X
X	"Standard Version" refers to such a Package if it has not been
X	modified, or has been modified in accordance with the wishes
X	of the Copyright Holder as specified below.
X
X	"Copyright Holder" is whoever is named in the copyright or
X	copyrights for the package.
X
X	"You" is you, if you're thinking about copying or distributing
X	this Package.
X
X	"Reasonable copying fee" is whatever you can justify on the
X	basis of media cost, duplication charges, time of people involved,
X	and so on.  (You will not be required to justify it to the
X	Copyright Holder, but only to the computing community at large
X	as a market that must bear the fee.)
X
X	"Freely Available" means that no fee is charged for the item
X	itself, though there may be fees involved in handling the item.
X	It also means that recipients of the item may redistribute it
X	under the same conditions they received it.
X
X1. You may make and give away verbatim copies of the source form of the
XStandard Version of this Package without restriction, provided that you
Xduplicate all of the original copyright notices and associated disclaimers.
X
X2. You may apply bug fixes, portability fixes and other modifications
Xderived from the Public Domain or from the Copyright Holder.  A Package
Xmodified in such a way shall still be considered the Standard Version.
X
X3. You may otherwise modify your copy of this Package in any way, provided
Xthat you insert a prominent notice in each changed file stating how and
Xwhen you changed that file, and provided that you do at least ONE of the
Xfollowing:
X
X    a) place your modifications in the Public Domain or otherwise make them
X    Freely Available, such as by posting said modifications to Usenet or
X    an equivalent medium, or placing the modifications on a major archive
X    site such as uunet.uu.net, or by allowing the Copyright Holder to include
X    your modifications in the Standard Version of the Package.
X
X    b) use the modified Package only within your corporation or organization.
X
X    c) rename any non-standard executables so the names do not conflict
X    with standard executables, which must also be provided, and provide
X    a separate manual page for each non-standard executable that clearly
X    documents how it differs from the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X4. You may distribute the programs of this Package in object code or
Xexecutable form, provided that you do at least ONE of the following:
X
X    a) distribute a Standard Version of the executables and library files,
X    together with instructions (in the manual page or equivalent) on where
X    to get the Standard Version.
X
X    b) accompany the distribution with the machine-readable source of
X    the Package with your modifications.
X
X    c) give non-standard executables non-standard names, and clearly
X    document the differences in manual pages (or equivalent), together
X    with instructions on where to get the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X5. You may charge a reasonable copying fee for any distribution of this
XPackage.  You may charge any fee you choose for support of this
XPackage.  You may not charge a fee for this Package itself.  However,
Xyou may distribute this Package in aggregate with other (possibly
Xcommercial) programs as part of a larger (possibly commercial) software
Xdistribution provided that you do not advertise this Package as a
Xproduct of your own.
X
X6. Any programs linked with this library do not automatically fall
Xunder the copyright of this Package, but belong to whomever generated
Xthem, and may be sold commercially, and may be aggregated with this
XPackage.
X
X7. The name of the Copyright Holder may not be used to endorse or promote
Xproducts derived from this software without specific prior written permission.
X
X8. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
XIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
XWARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
X				The End
X
END_OF_FILE
  if test 4642 -ne `wc -c <'ARTISTIC'`; then
    echo shar: \"'ARTISTIC'\" unpacked with wrong size!
  fi
  # end of 'ARTISTIC'
fi
if test -f 'FILES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FILES'\"
else
  echo shar: Extracting \"'FILES'\" \(2333 characters\)
  sed "s/^X//" >'FILES' <<'END_OF_FILE'
X/* General stuff */
XCHANGES		- Changes since the last posting to comp.sources.misc.
XARTISTIC	- Copying info.
XCOPYING		- Copying info.
XMODES.DES	- A description of the features of the different modes of DES.
XFILES		- This file.
XINSTALL		- How to make things compile.
XImakefile	- For use with kerberos.
XREADME		- What this package is.
XVERSION		- Which version this is.
XKERBEROS	- Kerberos version 4 notes.
Xmakefile	- The make file.
Xtimes		- Some outputs from 'speed' on my local machines.
Xvms.com		- For use when compiling under VMS
X
X/* My sunOS des(1) replacement */
Xdes.c		- des(1) source code.
Xdes.man		- des(1) manual.
X
X/* Testing and timing programs. */
Xdestest.c	- Source for libdes.a test program.
Xspeed.c		- Source for libdes.a timing program.
Xrpw.c		- Source for libdes.a testing password reading routines.
X
X/* libdes.a source code */
Xdes_crypt.man	- libdes.a manual page.
Xdes.h		- Public libdes.a header file.
Xecb_enc.c	- des_ecb_encrypt() source, this contains the basic DES code.
X3ecb_enc.c	- des_3ecb_encrypt() source.
Xcbc_ckm.c	- des_cbc_cksum() source.
Xcbc_enc.c	- des_cbc_encrypt() source.
X3cbc_enc.c	- des_3cbc_encrypt() source.
Xcfb_enc.c	- des_cfb_encrypt() source.
Xofb_enc.c	- des_cfb_encrypt() source.
Xenc_read.c	- des_enc_read() source.
Xenc_writ.c	- des_enc_write() source.
Xpcbc_enc.c	- des_pcbc_encrypt() source.
Xqud_cksm.c	- quad_cksum() source.
Xrand_key.c	- des_random_key() source.
Xread_pwd.c	- Source for des_read_password() plus related functions.
Xset_key.c	- Source for des_set_key().
Xstr2key.c	- Covert a string of any length into a key.
Xfcrypt.c	- A small, fast version of crypt(3).
Xdes_locl.h	- Internal libdes.a header file.
Xpodd.h		- Odd parity tables - used in des_set_key().
Xsk.h		- Lookup tables used in des_set_key().
Xspr.h		- What is left of the S tables - used in ecb_encrypt().
X
X/* The perl scripts - you can ignore these files they are only
X * included for the curious */
Xdes.pl		- des in perl anyone? des_set_key and des_ecb_encrypt
X		  both done in a perl library.
Xtestdes.pl	- Testing program for des.pl
XdoIP		- Perl script used to develop IP xor/shift code.
XdoPC1		- Perl script used to develop PC1 xor/shift code.
XdoPC2		- Generates sk.h.
XPC1		- Output of doPC1 should be the same as output from PC1.
XPC2		- used in development of doPC2.
Xshifts.pl	- Perl library used by my perl scripts.
X
END_OF_FILE
  if test 2333 -ne `wc -c <'FILES'`; then
    echo shar: \"'FILES'\" unpacked with wrong size!
  fi
  # end of 'FILES'
fi
if test -f 'MODES.DES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MODES.DES'\"
else
  echo shar: Extracting \"'MODES.DES'\" \(4262 characters\)
  sed "s/^X//" >'MODES.DES' <<'END_OF_FILE'
XModes of DES
XQuite a bit of the following information has been taken from
X	AS 2805.5.2
X	Australian Standard
X	Electronic funds transfer - Requirements for interfaces,
X	Part 5.2: Modes of operation for an n-bit block cipher algorithm
X	Appendix A
X
XThere are several different modes in which DES can be used, they are
Xas follows.
X
XElectronic Codebook Mode (ECB) (des_ecb_encrypt())
X- 64 bits are enciphered at a time.
X- The order of the blocks can be rearranged without detection.
X- The same plaintext block always produces the same ciphertext block
X  (for the same key) making it vulnerable to a 'dictionary attack'.
X- An error will only affect one ciphertext block.
X
XCipher Block Chaining Mode (CBC) (des_cbc_encrypt())
X- a multiple of 64 bits are enciphered at a time.
X- The CBC mode produces the same ciphertext whenever the same
X  plaintext is encrypted using the same key and starting variable.
X- The chaining operation makes the ciphertext blocks dependent on the
X  current and all preceding plaintext blocks and therefore blocks can not
X  be rearranged.
X- The use of different starting variables prevents the same plaintext
X  enciphering to the same ciphertext.
X- An error will affect the current and the following ciphertext blocks.
X
XCipher Feedback Mode (CFB) (des_cfb_encrypt())
X- a number of bits (j) <= 64 are enciphered at a time.
X- The CFB mode produces the same ciphertext whenever the same
X  plaintext is encrypted using the same key and starting variable.
X- The chaining operation makes the ciphertext variables dependent on the
X  current and all preceding variables and therefore j-bit variables are
X  chained together and con not be rearranged.
X- The use of different starting variables prevents the same plaintext
X  enciphering to the same ciphertext.
X- The strength of the CFB mode depends on the size of k (maximal if
X  j == k).  In my implementation this is always the case.
X- Selection of a small value for j will require more cycles through
X  the encipherment algorithm per unit of plaintext and thus cause
X  greater processing overheads.
X- Only multiples of j bits can be enciphered.
X- An error will affect the current and the following ciphertext variables.
X
XOutput Feedback Mode (OFB) (des_ofb_encrypt())
X- a number of bits (j) <= 64 are enciphered at a time.
X- The OFB mode produces the same ciphertext whenever the same
X  plaintext enciphered using the same key and starting variable.  More
X  over, in the OFB mode the same key stream is produced when the same
X  key and start variable are used.  Consequently, for security reasons
X  a specific start variable should be used only once for a given key.
X- The absence of chaining makes the OFB more vulnerable to specific attacks.
X- The use of different start variables values prevents the same
X  plaintext enciphering to the same ciphertext, by producing different
X  key streams.
X- Selection of a small value for j will require more cycles through
X  the encipherment algorithm per unit of plaintext and thus cause
X  greater processing overheads.
X- Only multiples of j bits can be enciphered.
X- OFB mode of operation does not extend ciphertext errors in the
X  resultant plaintext output.  Every bit error in the ciphertext causes
X  only one bit to be in error in the deciphered plaintext.
X- OFB mode is not self-synchronising.  If the two operation of
X  encipherment and decipherment get out of synchronism, the system needs
X  to be re-initialised.
X- Each re-initialisation should use a value of the start variable
Xdifferent from the start variable values used before with the same
Xkey.  The reason for this is that an identical bit stream would be
Xproduced each time from the same parameters.  This would be
Xsusceptible to a ' known plaintext' attack.
X
XTriple ECB Mode (des_3ecb_encrypt())
X- Encrypt with key1, decrypt with key2 and encrypt with key1 again.
X- As for ECB encryption but increases the effective key length to 112 bits.
X- If both keys are the same it is equivalent to encrypting once with
X  just one key.
X
XTriple CBC Mode (des_3cbc_encrypt())
X- Encrypt with key1, decrypt with key2 and encrypt with key1 again.
X- As for CBC encryption but increases the effective key length to 112 bits.
X- If both keys are the same it is equivalent to encrypting once with
X  just one key.
END_OF_FILE
  if test 4262 -ne `wc -c <'MODES.DES'`; then
    echo shar: \"'MODES.DES'\" unpacked with wrong size!
  fi
  # end of 'MODES.DES'
fi
if test -f 'des.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.h'\"
else
  echo shar: Extracting \"'des.h'\" \(4062 characters\)
  sed "s/^X//" >'des.h' <<'END_OF_FILE'
X/* des.h */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#ifndef DES_DEFS
X#define DES_DEFS
X
Xtypedef unsigned char des_cblock[8];
Xtypedef struct des_ks_struct
X	{
X	union	{
X		des_cblock _;
X		/* make sure things are correct size on machines with
X		 * 8 byte longs */
X		unsigned long pad[2];
X		} ks;
X#define _	ks._
X	} des_key_schedule[16];
X
X#define DES_KEY_SZ 	(sizeof(des_cblock))
X#define DES_ENCRYPT	1
X#define DES_DECRYPT	0
X
X#define DES_CBC_MODE	0
X#define DES_PCBC_MODE	1
X
X#define C_Block des_cblock
X#define Key_schedule des_key_schedule
X#define ENCRYPT DES_ENCRYPT
X#define DECRYPT DES_DECRYPT
X#define KEY_SZ DES_KEY_SZ
X#define string_to_key des_string_to_key
X#define read_pw_string des_read_pw_string
X#define random_key des_random_key
X#define pcbc_encrypt des_pcbc_encrypt
X#define set_key des_set_key
X#define key_sched des_key_sched
X#define ecb_encrypt des_ecb_encrypt
X#define cbc_encrypt des_cbc_encrypt
X#define cbc_cksum des_cbc_cksum
X#define quad_cksum des_quad_cksum
X
X/* For compatibility with the MIT lib - eay 20/05/92 */
Xtypedef struct des_ks_struct bit_64;
X
Xextern int des_check_key;	/* defaults to false */
Xextern int des_rw_mode;		/* defaults to DES_PCBC_MODE */
X
X/* The next line is used to disable full ANSI prototypes, if your
X * compiler has problems with the prototypes, make sure this line always
X * evaluates to true :-) */
X#if !defined(MSDOS) && !defined(__STDC__)
X#ifndef KERBEROS
Xint des_3ecb_encrypt();
Xint des_cbc_encrypt();
Xint des_3cbc_encrypt();
Xint des_cfb_encrypt();
Xint des_ecb_encrypt();
Xint des_encrypt();
Xint des_enc_read();
Xint des_enc_write();
Xint des_ofb_encrypt();
Xint des_pcbc_encrypt();
Xint des_random_key();
Xint des_read_password();
Xint des_read_2passwords();
Xint des_read_pw_string();
Xint des_is_weak_key();
Xint des_set_key();
Xint des_key_sched();
Xint des_string_to_key();
Xint des_string_to_2keys();
X#endif
Xchar *crypt();
Xunsigned long des_cbc_cksum();
Xunsigned long des_quad_cksum();
Xunsigned long des_cbc_cksum();
Xvoid des_set_odd_parity();
X#else /* PROTO */
Xint des_3ecb_encrypt(des_cblock *input,des_cblock *output,\
X	des_key_schedule ks1,des_key_schedule ks2,int encrypt);
Xunsigned long des_cbc_cksum(des_cblock *input,des_cblock *output,\
X	long length,des_key_schedule schedule,des_cblock *ivec);
Xint des_cbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xint des_3cbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule sk1,des_key_schedule sk2,\
X	des_cblock *ivec1,des_cblock *ivec2,int encrypt);
Xint des_cfb_encrypt(unsigned char *in,unsigned char *out,int numbits,\
X	long length,des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xint des_ecb_encrypt(des_cblock *input,des_cblock *output,\
X	des_key_schedule ks,int encrypt);
Xint des_encrypt(unsigned long *input,unsigned long *output,
X	des_key_schedule ks, int encrypt);
Xint des_enc_read(int fd,char *buf,int len,des_key_schedule sched,\
X	des_cblock *iv);
Xint des_enc_write(int fd,char *buf,int len,des_key_schedule sched,\
X	des_cblock *iv);
Xchar *crypt(char *buf,char *salt);
Xint des_ofb_encrypt(unsigned char *in,unsigned char *out,\
X	int numbits,long length,des_key_schedule schedule,des_cblock *ivec);
Xint des_pcbc_encrypt(des_cblock *input,des_cblock *output,long length,\
X	des_key_schedule schedule,des_cblock *ivec,int encrypt);
Xunsigned long des_quad_cksum(des_cblock *input,des_cblock *output,\
X	long length,int out_count,des_cblock *seed);
Xint des_random_key(des_cblock ret);
Xint des_read_password(des_cblock *key,char *prompt,int verify);
Xint des_read_2passwords(des_cblock *key1,des_cblock *key2, \
X	char *prompt,int verify);
Xint des_read_pw_string(char *buf,int length,char *prompt,int verify);
Xvoid des_set_odd_parity(des_cblock *key);
Xint des_is_weak_key(des_cblock *key);
Xint des_set_key(des_cblock *key,des_key_schedule schedule);
Xint des_key_sched(des_cblock *key,des_key_schedule schedule);
Xint des_string_to_key(char *str,des_cblock *key);
Xint des_string_to_2keys(char *str,des_cblock *key1,des_cblock *key2);
X#endif
X#endif
END_OF_FILE
  if test 4062 -ne `wc -c <'des.h'`; then
    echo shar: \"'des.h'\" unpacked with wrong size!
  fi
  # end of 'des.h'
fi
if test -f 'des.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.man'\"
else
  echo shar: Extracting \"'des.man'\" \(4709 characters\)
  sed "s/^X//" >'des.man' <<'END_OF_FILE'
X.TH DES 1 
X.SH NAME
Xdes - encrypt or decrypt data using Data Encryption Standard
X.SH SYNOPSIS
X.B des
X(
X.B \-e
X|
X.B \-E
X) | (
X.B \-d
X|
X.B \-D
X) | (
X.B \-\fR[\fPcC\fR][\fPckname\fR]\fP
X) |
X[
X.B \-b3hfs
X] [
X.B \-k
X.I key
X]
X] [
X.B \-u\fR[\fIuuname\fR]
X[
X.I input-file
X[
X.I output-file
X] ]
X.SH DESCRIPTION
X.B des
Xencrypts and decrypts data using the
XData Encryption Standard algorithm.
XOne of
X.B \-e, \-E
X(for encrypt) or
X.B \-d, \-D
X(for decrypt) must be specified.
XIt is also possible to use
X.B \-c
Xor
X.B \-C
Xin conjunction or instead of the a encrypt/decrypt option to generate
Xa 16 character hexadecimal checksum, generated via the
X.I des_cbc_cksum.
X.LP
XTwo standard encryption modes are supported by the
X.B des
Xprogram, Cipher Block Chaining (the default) and Electronic Code Book
X(specified with
X.B \-b
X).
X.LP
XThe key used for the DES
Xalgorithm is obtained by prompting the user unless the
X.B `\-k
X.I key'
Xoption is given.
XIf the key is an argument to the
X.B des
Xcommand, it is potentially visible to users executing
X.BR ps (1)
Xor a derivative.  To minimise this possibility,
X.B des
Xtakes care to destroy the key argument immediately upon entry.
XIf your shell keeps a history file be careful to make sure it is not
Xworld readable.
X.LP
XSince this program attempts to maintain compatability with sunOS's
Xdes(1) command, there are 2 different methods used to convert the user
Xsupplied key to a des key.
XWhenever and one or more of
X.B \-E, \-D, \-C
Xor
X.B \-3
Xoptions are used, the key conversion procedure will not be compatible
Xwith the sunOS des(1) version but will use all the user supplied
Xcharacter to generate the des key.
X.B des
Xcommand reads from standard input unless
X.I input-file
Xis specified and writes to standard output unless
X.I output-file
Xis given.
X.SH OPTIONS
X.TP
X.B \-b
XSelect ECB
X(eight bytes at a time) encryption mode.
X.TP
X.B \-3
XEncrypt using triple encryption.
XBy default triple cbc encryption is used but if the
X.B \-b
Xoption is used then triple ecb encryption is performed.
XIf the key is less than 8 characters long, the flag has no effect.
X.TP
X.B \-e
XEncrypt data using an 8 byte key in a manner compatible with sunOS
Xdes(1).
X.TP
X.B \-E
XEncrypt data using a key of nearly unlimited length (1024 bytes).
XThis will product a more secure encryption.
X.TP
X.B \-d
XDecrypt data that was encrypted with the \-e option.
X.TP
X.B \-D
XDecrypt data that was encrypted with the \-E option.
X.TP
X.B \-c
XGenerate a 16 character hexadecimal cbc checksum and output this to
Xstderr.
XIf a filename was specified after the
X.B \-c
Xoption, the checksum is output to that file.
XThe checksum is generated using a key generated in a sunOS compatible
Xmanner.
X.TP
X.B \-C
XA cbc checksum is generated in the same manner as described for the
X.B \-c
Xoption but the DES key is generated in the same manner as used for the
X.B \-E
Xand
X.B \-D
Xoptions
X.TP
X.B \-f
XDoes nothing - allowed for compatibility with sunOS des(1) command.
X.TP
X.B \-s
XDoes nothing - allowed for compatibility with sunOS des(1) command.
X.TP
X.B "\-k \fIkey\fP"
XUse the encryption 
X.I key
Xspecified.
X.TP
X.B "\-h"
XThe
X.I key
Xis assumed to be a 16 character hexadecimal number.
XIf the
X.B "\-3"
Xoption is used the key is assumed to be a 32 character hexadecimal
Xnumber.
X.TP
X.B \-u
XThis flag is used to read and write uuencoded files.  If decrypting,
Xthe input file is assumed to contain uuencoded, DES encrypted data.
XIf encrypting, the characters following the -u are used as the name of
Xthe uuencoded file to embed in the begin line of the uuencoded
Xoutput.  If there is no name specified after the -u, the name text.des
Xwill be embedded in the header.
X.SH SEE ALSO
X.B ps (1)
X.B des_crypt(3)
X.SH BUGS
X.LP
XThe problem with using the
X.B -e
Xoption is the short key length.
XIt would be better to use a real 56-bit key rather than an
XASCII-based 56-bit pattern.  Knowing that the key was derived from ASCII
Xradically reduces the time necessary for a brute-force cryptographic attack.
XMy attempt to remove this problem is to add an alternative text-key to
XDES-key function.  This alternative function (accessed via
X.B -E, -D, -S
Xand
X.B -3
X)
Xuses DES to help generate the key.
X.LP
XBe carefully when using the -u option.  Doing des -ud <filename> will
Xnot decrypt filename (the -u option will gobble the d option).
X.LP
XThe VMS operating system operates in a world where files are always a
Xmultiple of 512 bytes.  This causes problems when encrypted data is
Xsend from unix to VMS since a 88 byte file will suddenly be padded
Xwith 424 null bytes.  To get around this problem, use the -u option
Xto uuencode the data before it is send to the VMS system.
X.SH AUTHOR
X.LP
XEric Young (eay@psych.psy.uq.oz.au), Psychology Department,
XUniversity of Queensland, Australia.
END_OF_FILE
  if test 4709 -ne `wc -c <'des.man'`; then
    echo shar: \"'des.man'\" unpacked with wrong size!
  fi
  # end of 'des.man'
fi
if test -f 'ecb_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ecb_enc.c'\"
else
  echo shar: Extracting \"'ecb_enc.c'\" \(2525 characters\)
  sed "s/^X//" >'ecb_enc.c' <<'END_OF_FILE'
X/* ecb_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X#include "spr.h"
X
Xint des_ecb_encrypt(input,output,ks,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule ks;
Xint encrypt;
X	{
X	register unsigned long l0,l1;
X	register unsigned char *in,*out;
X	unsigned long ll[2];
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	c2l(in,l0);
X	c2l(in,l1);
X	ll[0]=l0;
X	ll[1]=l1;
X	des_encrypt(ll,ll,ks,encrypt);
X	l0=ll[0];
X	l1=ll[1];
X	l2c(l0,out);
X	l2c(l1,out);
X	l0=l1=ll[0]=ll[1]=0;
X	return(0);
X	}
X
Xint des_encrypt(input,output,ks,encrypt)
Xunsigned long *input;
Xunsigned long *output;
Xdes_key_schedule ks;
Xint encrypt;
X	{
X	register unsigned long l,r,t,u;
X#ifdef ALT_ECB
X	register unsigned char *des_SP=(unsigned char *)des_SPtrans;
X#endif
X#ifdef MSDOS
X	union fudge {
X		unsigned long  l;
X		unsigned short s[2];
X		unsigned char  c[4];
X		} U,T;
X#endif
X	register int i;
X	register unsigned long *s;
X
X	l=input[0];
X	r=input[1];
X
X	/* do IP */
X	PERM_OP(r,l,t, 4,0x0f0f0f0f);
X	PERM_OP(l,r,t,16,0x0000ffff);
X	PERM_OP(r,l,t, 2,0x33333333);
X	PERM_OP(l,r,t, 8,0x00ff00ff);
X	PERM_OP(r,l,t, 1,0x55555555);
X	/* r and l are reversed - remember that :-) - fix
X	 * it in the next step */
X
X	/* Things have been modified so that the initial rotate is
X	 * done outside the loop.  This required the
X	 * des_SPtrans values in sp.h to be rotated 1 bit to the right.
X	 * One perl script later and things have a 5% speed up on a sparc2.
X	 * Thanks to Richard Outerbridge <71755.204@CompuServe.COM>
X	 * for pointing this out. */
X	t=(r<<1)|(r>>31);
X	r=(l<<1)|(l>>31);
X	l=t;
X
X	/* clear the top bits on machines with 8byte longs */
X	l&=0xffffffff;
X	r&=0xffffffff;
X
X	s=(unsigned long *)ks;
X	/* I don't know if it is worth the effort of loop unrolling the
X	 * inner loop */
X	if (encrypt)
X		{
X		for (i=0; i<32; i+=4)
X			{
X			D_ENCRYPT(l,r,i+0); /*  1 */
X			D_ENCRYPT(r,l,i+2); /*  2 */
X			}
X		}
X	else
X		{
X		for (i=30; i>0; i-=4)
X			{
X			D_ENCRYPT(l,r,i-0); /* 16 */
X			D_ENCRYPT(r,l,i-2); /* 15 */
X			}
X		}
X	l=(l>>1)|(l<<31);
X	r=(r>>1)|(r<<31);
X	/* clear the top bits on machines with 8byte longs */
X	l&=0xffffffff;
X	r&=0xffffffff;
X
X	/* swap l and r
X	 * we will not do the swap so just remember they are
X	 * reversed for the rest of the subroutine
X	 * luckily FP fixes this problem :-) */
X
X	PERM_OP(r,l,t, 1,0x55555555);
X	PERM_OP(l,r,t, 8,0x00ff00ff);
X	PERM_OP(r,l,t, 2,0x33333333);
X	PERM_OP(l,r,t,16,0x0000ffff);
X	PERM_OP(r,l,t, 4,0x0f0f0f0f);
X
X	output[0]=l;
X	output[1]=r;
X	l=r=t=u=0;
X	return(0);
X	}
X
END_OF_FILE
  if test 2525 -ne `wc -c <'ecb_enc.c'`; then
    echo shar: \"'ecb_enc.c'\" unpacked with wrong size!
  fi
  # end of 'ecb_enc.c'
fi
if test -f 'enc_read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'enc_read.c'\"
else
  echo shar: Extracting \"'enc_read.c'\" \(3343 characters\)
  sed "s/^X//" >'enc_read.c' <<'END_OF_FILE'
X/* enc_read.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include <errno.h>
X#include "des_locl.h"
X
X/* This has some uglies in it but it works - even over sockets. */
Xextern int errno;
Xint des_rw_mode=DES_PCBC_MODE;
X
Xint des_enc_read(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X	{
X	/* data to be unencrypted */
X	int net_num=0;
X	unsigned char net[BSIZE];
X	/* extra unencrypted data 
X	 * for when a block of 100 comes in but is des_read one byte at
X	 * a time. */
X	static char unnet[BSIZE];
X	static int unnet_start=0;
X	static int unnet_left=0;
X	int i;
X	long num=0,rnum;
X	unsigned char *p;
X
X	/* left over data from last decrypt */
X	if (unnet_left != 0)
X		{
X		if (unnet_left < len)
X			{
X			/* we still still need more data but will return
X			 * with the number of bytes we have - should always
X			 * check the return value */
X			bcopy(&(unnet[unnet_start]),buf,unnet_left);
X			/* eay 26/08/92 I had the next 2 lines
X			 * reversed :-( */
X			i=unnet_left;
X			unnet_start=unnet_left=0;
X			}
X		else
X			{
X			bcopy(&(unnet[unnet_start]),buf,len);
X			unnet_start+=len;
X			unnet_left-=len;
X			i=len;
X			}
X		return(i);
X		}
X
X	/* We need to get more data. */
X	if (len > MAXWRITE) len=MAXWRITE;
X
X	/* first - get the length */
X	net_num=0;
X	while (net_num < HDRSIZE) 
X		{
X		i=read(fd,&(net[net_num]),HDRSIZE-net_num);
X		if ((i == -1) && (errno == EINTR)) continue;
X		if (i <= 0) return(0);
X		net_num+=i;
X		}
X
X	/* we now have at net_num bytes in net */
X	p=net;
X	num=0;
X	n2l(p,num);
X	/* num should be rounded up to the next group of eight
X	 * we make sure that we have read a multiple of 8 bytes from the net.
X	 */
X	if ((num > MAXWRITE) || (num < 0)) /* error */
X		return(-1);
X	rnum=(num < 8)?8:((num+7)/8*8);
X
X	net_num=0;
X	while (net_num < rnum)
X		{
X		i=read(fd,&(net[net_num]),rnum-net_num);
X		if ((i == -1) && (errno == EINTR)) continue;
X		if (i <= 0) return(0);
X		net_num+=i;
X		}
X
X	/* Check if there will be data left over. */
X	if (len < num)
X		{
X		if (des_rw_mode & DES_PCBC_MODE)
X			pcbc_encrypt((des_cblock *)net,(des_cblock *)unnet,
X				num,sched,iv,DES_DECRYPT);
X		else
X			cbc_encrypt((des_cblock *)net,(des_cblock *)unnet,
X				num,sched,iv,DES_DECRYPT);
X		bcopy(unnet,buf,len);
X		unnet_start=len;
X		unnet_left=num-len;
X
X		/* The following line is done because we return num
X		 * as the number of bytes read. */
X		num=len;
X		}
X	else
X		{
X		/* >output is a multiple of 8 byes, if len < rnum
X		 * >we must be careful.  The user must be aware that this
X		 * >routine will write more bytes than he asked for.
X		 * >The length of the buffer must be correct.
X		 * FIXED - Should be ok now 18-9-90 - eay */
X		if (len < rnum)
X			{
X			char tmpbuf[BSIZE];
X
X			if (des_rw_mode & DES_PCBC_MODE)
X				pcbc_encrypt((des_cblock *)net,
X					(des_cblock *)tmpbuf,
X					num,sched,iv,DES_DECRYPT);
X			else
X				cbc_encrypt((des_cblock *)net,
X					(des_cblock *)tmpbuf,
X					num,sched,iv,DES_DECRYPT);
X
X			/* eay 26/08/92 fix a bug that returned more
X			 * bytes than you asked for (returned len bytes :-( */
X			bcopy(tmpbuf,buf,num);
X			}
X		else
X			{
X			if (des_rw_mode & DES_PCBC_MODE)
X				pcbc_encrypt((des_cblock *)net,
X					(des_cblock *)buf,num,sched,iv,
X					DES_DECRYPT);
X			else
X				cbc_encrypt((des_cblock *)net,
X					(des_cblock *)buf,num,sched,iv,
X					DES_DECRYPT);
X			}
X		}
X	return(num);
X	}
X
END_OF_FILE
  if test 3343 -ne `wc -c <'enc_read.c'`; then
    echo shar: \"'enc_read.c'\" unpacked with wrong size!
  fi
  # end of 'enc_read.c'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
  echo shar: Extracting \"'makefile'\" \(3215 characters\)
  sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# Turn this option on if using a SGI Iris running IRIX.
X# IRIX does not appear to define sgttyb anywhere :-(
X#OPTS0= -D_IRIX 
X
X# Version 1.94 has changed the strings_to_key function so that it is
X# now compatible with MITs when the string is longer than 8 characters.
X# If you wish to keep the old version, uncomment the following line.
X# This will affect the -E/-D options on des(1).
X#OPTS1= -DOLD_STR_TO_KEY
X
X# This #define specifies the use of an alternative D_ENCRYPT macro in
X# ecb_encrypt.  The choice of macro can make a %20 difference in the
X# speed.  Unfortunatly the choise of the best macro appears to be very
X# dependant on the compiler and the machine in question.
X# For the following combinations use the ALT_ECB option.
X# Sparc 2 (cc -O4), sun 3/260 (cc -O4)
X# For the following combinations do not use the ALT_ECB option.
X# Sparc 2 (gcc2 -O2), sun 3/260 (cc -O2), mvax2 (cc -O), MSDOS (Turbo Cv2)
X# For other machines, experiment with changing the option and run
X# ./speed to see which is faster.
X# DO NOT TURN THIS OPTION ON WHEN COMPILING THIS CODE ON A 64 BIT MACHINE
X#OPTS2= -DALT_ECB
X
XOPTS= $(OPTS0) $(OPTS1) $(OPTS2)
X#CC=cc
X#CFLAGS= -g $(OPTS)
XCC=gcc
XCFLAGS= -O2 $(OPTS)
X
XLIBDIR=/usr/local/lib
XBINDIR=/usr/local/bin
XINCDIR=/usr/include
XMANDIR=/usr/local/man
XMAN1=1
XMAN3=3
XSHELL=/bin/sh
X
XOBJS=	cbc_cksm.o cbc_enc.o ecb_enc.o pcbc_enc.o \
X	qud_cksm.o rand_key.o read_pwd.o set_key.o str2key.o \
X	enc_read.o enc_writ.o fcrypt.o cfb_enc.o \
X	3ecb_enc.o ofb_enc.o 3cbc_enc.o
X
XGENERAL=ARTISTIC COPYING FILES INSTALL Imakefile README VERSION makefile times \
X	vms.com KERBEROS MODES.DES CHANGES
XDES=	des.c des.man
XTESTING=destest.c speed.c rpw.c
XLIBDES=	des_crypt.man des.h cbc_cksm.c cbc_enc.c ecb_enc.c \
X	enc_read.c enc_writ.c pcbc_enc.c qud_cksm.c rand_key.c \
X	read_pwd.c set_key.c str2key.c fcrypt.c des_locl.h \
X	podd.h sk.h spr.h cfb_enc.c 3ecb_enc.c \
X	ofb_enc.c 3cbc_enc.c
X
XPERL=	des.pl testdes.pl doIP doPC1 doPC2 PC1 PC2 shifts.pl
X
XALL=	$(GENERAL) $(DES) $(TESTING) $(LIBDES) $(PERL)
X
XLIB=	libdes.a
X
Xall: $(LIB) destest rpw des speed
X
X$(LIB):	$(OBJS)
X	/bin/rm -f $(LIB)
X	ar cr $(LIB) $(OBJS)
X	-if test -s /bin/ranlib; then /bin/ranlib $(LIB); \
X	else if test -s /usr/bin/ranlib; then /usr/bin/ranlib $(LIB); \
X	else exit 0; fi; fi
X
Xdestest: destest.o libdes.a
X	$(CC) $(CFLAGS) -o destest destest.o libdes.a
X
Xrpw: rpw.o libdes.a
X	$(CC) $(CFLAGS) -o rpw rpw.o libdes.a
X
Xspeed: speed.o libdes.a
X	$(CC) $(CFLAGS) -o speed speed.o libdes.a
X
Xdes: des.o libdes.a
X	$(CC) $(CFLAGS) -o des des.o libdes.a
X
Xtar:
X	tar cf libdes.tar $(ALL)
X
Xshar:
X	shar $(ALL) >libdes.shar
X
Xclean:
X	/bin/rm -f *.o rpw destest des speed $(LIB)
X
Xinstall: $(LIB) des
X	cp $(LIB) $(LIBDIR)/$(LIB)
X	-if test -s /bin/ranlib; then /bin/ranlib $(LIBDIR)/$(LIB); \
X	else if test -s /usr/bin/ranlib; then /usr/bin/ranlib $(LIBDIR)/$(LIB); \
X	fi; fi
X	chmod 644 $(LIBDIR)/$(LIB)
X	cp des $(BINDIR)/des
X	chmod 711 $(BINDIR)/des
X	cp des_crypt.man $(MANDIR)/man$(MAN3)/des_crypt.$(MAN3)
X	chmod 644 $(MANDIR)/man$(MAN3)/des_crypt.$(MAN3)
X	cp des.man $(MANDIR)/man$(MAN1)/des.$(MAN1)
X	chmod 644 $(MANDIR)/man$(MAN1)/des.$(MAN1)
X	cp des.h $(INCDIR)/des.h
X	chmod 644 $(INCDIR)/des.h
X# DO NOT DELETE THIS LINE -- make depend depends on it.
END_OF_FILE
  if test 3215 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
  fi
  # end of 'makefile'
fi
if test -f 'pcbc_enc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcbc_enc.c'\"
else
  echo shar: Extracting \"'pcbc_enc.c'\" \(1447 characters\)
  sed "s/^X//" >'pcbc_enc.c' <<'END_OF_FILE'
X/* pcbc_enc.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xint des_pcbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X	{
X	register unsigned long sin0,sin1,xor0,xor1,tout0,tout1;
X	unsigned long tin[2],tout[2];
X	unsigned char *in,*out,*iv;
X
X	in=(unsigned char *)input;
X	out=(unsigned char *)output;
X	iv=(unsigned char *)ivec;
X
X	if (encrypt)
X		{
X		c2l(iv,xor0);
X		c2l(iv,xor1);
X		for (; length>0; length-=8)
X			{
X			if (length >= 8)
X				{
X				c2l(in,sin0);
X				c2l(in,sin1);
X				}
X			else
X				c2ln(in,sin0,sin1,length);
X			tin[0]=sin0^xor0;
X			tin[1]=sin1^xor1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0];
X			tout1=tout[1];
X			xor0=sin0^tout[0];
X			xor1=sin1^tout[1];
X			l2c(tout0,out);
X			l2c(tout1,out);
X			}
X		}
X	else
X		{
X		c2l(iv,xor0); c2l(iv,xor1);
X		for (; length>0; length-=8)
X			{
X			c2l(in,sin0);
X			c2l(in,sin1);
X			tin[0]=sin0;
X			tin[1]=sin1;
X			des_encrypt((unsigned long *)tin,(unsigned long *)tout,
X				schedule,encrypt);
X			tout0=tout[0]^xor0;
X			tout1=tout[1]^xor1;
X			if (length >= 8)
X				{
X				l2c(tout0,out);
X				l2c(tout1,out);
X				}
X			else
X				l2cn(tout0,tout1,out,length);
X			xor0=tout0^sin0;
X			xor1=tout1^sin1;
X			}
X		}
X	tin[0]=tin[1]=tout[0]=tout[1]=0;
X	sin0=sin1=xor0=xor1=tout0=tout1=0;
X	return(0);
X	}
END_OF_FILE
  if test 1447 -ne `wc -c <'pcbc_enc.c'`; then
    echo shar: \"'pcbc_enc.c'\" unpacked with wrong size!
  fi
  # end of 'pcbc_enc.c'
fi
if test -f 'set_key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'set_key.c'\"
else
  echo shar: Extracting \"'set_key.c'\" \(4706 characters\)
  sed "s/^X//" >'set_key.c' <<'END_OF_FILE'
X/* set_key.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* set_key.c v 1.4 eay 24/9/91
X * 1.4 Speed up by 400% :-)
X * 1.3 added register declarations.
X * 1.2 unrolled make_key_sched a bit more
X * 1.1 added norm_expand_bits
X * 1.0 First working version
X */
X#include "des_locl.h"
X#include "podd.h"
X#include "sk.h"
X
Xstatic int check_parity();
X
Xint des_check_key=0;
X
Xvoid des_set_odd_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		(*key)[i]=odd_parity[(*key)[i]];
X	}
X
Xstatic int check_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		{
X		if ((*key)[i] != odd_parity[(*key)[i]])
X			return(0);
X		}
X	return(1);
X	}
X
X/* Weak and semi week keys as take from
X * %A D.W. Davies
X * %A W.L. Price
X * %T Security for Computer Networks
X * %I John Wiley & Sons
X * %D 1984
X * Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
X * (and actual cblock values).
X */
X#define NUM_WEAK_KEY	16
Xstatic des_cblock weak_keys[NUM_WEAK_KEY]={
X	/* weak keys */
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
X	0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
X	0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
X	/* semi-weak keys */
X	0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,
X	0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,
X	0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1,
X	0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E,
X	0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,
X	0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01,
X	0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE,
X	0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,
X	0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,
X	0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1};
X
Xint des_is_weak_key(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<NUM_WEAK_KEY; i++)
X		/* Added == 0 to comparision, I obviously don't run
X		 * this section very often :-(, thanks to
X		 * engineering@MorningStar.Com for the fix
X		 * eay 93/06/29 */
X		if (memcmp(weak_keys[i],key,sizeof(key)) == 0) return(1);
X	return(0);
X	}
X
X/* NOW DEFINED IN des_local.h
X * See ecb_encrypt.c for a pseudo description of these macros. 
X * #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
X * 	(b)^=(t),\
X * 	(a)=((a)^((t)<<(n))))
X */
X
X#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
X	(a)=(a)^(t)^(t>>(16-(n))))
X
Xstatic char shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
X
X/* return 0 if key parity is odd (correct),
X * return -1 if key parity error,
X * return -2 if illegal weak key.
X */
Xint des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	register unsigned long c,d,t,s;
X	register unsigned char *in;
X	register unsigned long *k;
X	register int i;
X
X	if (des_check_key)
X		{
X		if (!check_parity(key))
X			return(-1);
X
X		if (des_is_weak_key(key))
X			return(-2);
X		}
X
X	k=(unsigned long *)schedule;
X	in=(unsigned char *)key;
X
X	c2l(in,c);
X	c2l(in,d);
X
X	/* do PC1 in 60 simple operations */ 
X/*	PERM_OP(d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2, 0xcccc0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(c,t, 8, 0x00ff0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(d,t,-8, 0xff000000);
X	HPERM_OP(d,t, 8, 0x00ff0000);
X	HPERM_OP(d,t, 2, 0x33330000);
X	d=((d&0x00aa00aa)<<7)|((d&0x55005500)>>7)|(d&0xaa55aa55);
X	d=(d>>8)|((c&0xf0000000)>>4);
X	c&=0x0fffffff; */
X
X	/* I now do it in 47 simple operations :-)
X	 * Thanks to John Fletcher (john_fletcher@lccmail.ocf.llnl.gov)
X	 * for the inspiration. :-) */
X	PERM_OP (d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2,0xcccc0000);
X	HPERM_OP(d,t,-2,0xcccc0000);
X	PERM_OP (d,c,t,1,0x55555555);
X	PERM_OP (c,d,t,8,0x00ff00ff);
X	PERM_OP (d,c,t,1,0x55555555);
X	d=	(((d&0x000000ff)<<16)| (d&0x0000ff00)     |
X		 ((d&0x00ff0000)>>16)|((c&0xf0000000)>>4));
X	c&=0x0fffffff;
X
X	for (i=0; i<ITERATIONS; i++)
X		{
X		if (shifts2[i])
X			{ c=((c>>2)|(c<<26)); d=((d>>2)|(d<<26)); }
X		else
X			{ c=((c>>1)|(c<<27)); d=((d>>1)|(d<<27)); }
X		c&=0x0fffffff;
X		d&=0x0fffffff;
X		/* could be a few less shifts but I am to lazy at this
X		 * point in time to investigate */
X		s=	des_skb[0][ (c    )&0x3f                ]|
X			des_skb[1][((c>> 6)&0x03)|((c>> 7)&0x3c)]|
X			des_skb[2][((c>>13)&0x0f)|((c>>14)&0x30)]|
X			des_skb[3][((c>>20)&0x01)|((c>>21)&0x06) |
X						  ((c>>22)&0x38)];
X		t=	des_skb[4][ (d    )&0x3f                ]|
X			des_skb[5][((d>> 7)&0x03)|((d>> 8)&0x3c)]|
X			des_skb[6][ (d>>15)&0x3f                ]|
X			des_skb[7][((d>>21)&0x0f)|((d>>22)&0x30)];
X
X		/* table contained 0213 4657 */
X		*(k++)=((t<<16)|(s&0x0000ffff))&0xffffffff;
X		s=     ((s>>16)|(t&0xffff0000));
X		
X		s=(s<<4)|(s>>28);
X		*(k++)=s&0xffffffff;
X		}
X	return(0);
X	}
X
Xint des_key_sched(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	return(des_set_key(key,schedule));
X	}
END_OF_FILE
  if test 4706 -ne `wc -c <'set_key.c'`; then
    echo shar: \"'set_key.c'\" unpacked with wrong size!
  fi
  # end of 'set_key.c'
fi
if test -f 'speed.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'speed.c'\"
else
  echo shar: Extracting \"'speed.c'\" \(4296 characters\)
  sed "s/^X//" >'speed.c' <<'END_OF_FILE'
X/* speed.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X/* 11-Sep-92 Andrew Daviel   Support for Silicon Graphics IRIX added */
X/* 06-Apr-92 Luke Brennan    Support for VMS and add extra signal calls */
X
X#ifndef MSDOS
X#define TIMES
X#endif
X
X#include <stdio.h>
X#include <signal.h>
X#ifndef VMS
X#ifndef _IRIX
X#include <time.h>
X#endif
X#ifdef TIMES
X#include <sys/types.h>
X#include <sys/times.h>
X#endif /* TIMES */
X#else /* VMS */
X#include <types.h>
Xstruct tms {
X	time_t tms_utime;
X	time_t tms_stime;
X	time_t tms_uchild;	/* I dunno...  */
X	time_t tms_uchildsys;	/* so these names are a guess :-) */
X	}
X#endif
X#ifndef TIMES
X#include <sys/timeb.h>
X#endif
X#include "des.h"
X
X/* The following if from times(3) man page.  It may need to be changed */
X#ifndef CLK_TCK
X#ifndef VMS
X#define HZ	60.0
X#else /* VMS */
X#define HZ	100.0
X#endif
X#else /* CLK_TCK */
X#define HZ ((double)CLK_TCK)
X#endif
X
X#define BUFSIZE	((long)1024*8)
Xlong run=0;
X
X#ifdef SIGALRM
X#ifdef __STDC__
X#define SIGRETTYPE void
X#else
X#define SIGRETTYPE int
X#endif 
X
XSIGRETTYPE sig_done(sig)
Xint sig;
X	{
X	signal(SIGALRM,sig_done);
X	run=0;
X	}
X#endif
X
X#define START	0
X#define STOP	1
X
Xdouble Time_F(s)
Xint s;
X	{
X	double ret;
X#ifdef TIMES
X	static struct tms tstart,tend;
X
X	if (s == START)
X		{
X		times(&tstart);
X		return(0);
X		}
X	else
X		{
X		times(&tend);
X		ret=((double)(tend.tms_utime-tstart.tms_utime))/HZ;
X		return((ret == 0.0)?1e-6:ret);
X		}
X#else /* !times() */
X	static struct timeb tstart,tend;
X	long i;
X
X	if (s == START)
X		{
X		ftime(&tstart);
X		return(0);
X		}
X	else
X		{
X		ftime(&tend);
X		i=(long)tend.millitm-(long)tstart.millitm;
X		ret=((double)(tend.time-tstart.time))+((double)i)/1000.0;
X		return((ret == 0.0)?1e-6:ret);
X		}
X#endif
X	}
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X	{
X	long count;
X	static unsigned char buf[BUFSIZE];
X	static des_cblock key={0x12,0x34,0x56,0x78,0x9a,0xbc,0xde,0xf0};
X	des_key_schedule sch;
X	double d,a,b,c;
X	long ca,cb,cc,cd;
X
X#ifndef TIMES
X	printf("To get the most acurate results, try to run this\n");
X	printf("program when this computer is idle.\n");
X#endif
X
X#ifndef SIGALRM
X	printf("First we calculate the aproximate speed ...\n");
X	des_set_key((C_Block *)key,sch);
X	count=10;
X	do	{
X		int i;
X		count*=2;
X		Time_F(START);
X		for (i=count; i; i--)
X			des_ecb_encrypt((C_Block *)buf,(C_Block *)buf,
X				&(sch[0]),DES_ENCRYPT);
X		d=Time_F(STOP);
X		} while (d <3);
X	ca=count;
X	cb=count*10;
X	cc=count*10*8/BUFSIZE+1;
X	cd=count/20+1;
X	printf("Doing set_key %ld times\n",ca);
X#define COND(d)	(count != (d))
X#define COUNT(d) (d)
X#else
X#define COND(c)	(run)
X#define COUNT(d) (count)
X	signal(SIGALRM,sig_done);
X	printf("Doing set_key for 10 seconds\n");
X	alarm(10);
X#endif
X
X	Time_F(START);
X	for (count=0,run=1; COND(ca); count++)
X		des_set_key((C_Block *)key,sch);
X	d=Time_F(STOP);
X	printf("%ld set_key's in %.2f seconds\n",count,d);
X	a=((double)COUNT(ca))/d;
X
X#ifdef SIGALRM
X	printf("Doing des_ecb_encrypt's for 10 seconds\n");
X	alarm(10);
X#else
X	printf("Doing des_ecb_encrypt %ld times\n",cb);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cb); count++)
X		des_ecb_encrypt((C_Block *)buf,(C_Block *)buf,
X			&(sch[0]),DES_ENCRYPT);
X	d=Time_F(STOP);
X	printf("%ld des_ecb_encrypt's in %.2f second\n",count,d);
X	b=((double)COUNT(cb)*8)/d;
X
X#ifdef SIGALRM
X	printf("Doing des_cbc_encrypt on %ld byte blocks for 10 seconds\n",
X		BUFSIZE);
X	alarm(10);
X#else
X	printf("Doing des_cbc_encrypt %ld times on %ld byte blocks\n",cc,
X		BUFSIZE);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cc); count++)
X		des_cbc_encrypt((C_Block *)buf,(C_Block *)buf,BUFSIZE,&(sch[0]),
X			(C_Block *)&(key[0]),DES_ENCRYPT);
X	d=Time_F(STOP);
X	printf("%ld des_cbc_encrypt's of %ld byte blocks in %.2f second\n",
X		count,BUFSIZE,d);
X	c=((double)COUNT(cc)*BUFSIZE)/d;
X
X#ifdef SIGALRM
X	printf("Doing crypt for 10 seconds\n");
X	alarm(10);
X#else
X	printf("Doing crypt %ld times\n",cd);
X#endif
X	Time_F(START);
X	for (count=0,run=1; COND(cd); count++)
X		crypt("testing1","ef");
X	d=Time_F(STOP);
X	printf("%ld crypts in %.2f second\n",count,d);
X	d=((double)COUNT(cd))/d;
X
X	printf("set_key       per sec = %12.2f (%5.1fuS)\n",a,1.0e6/a);
X	printf("DES ecb bytes per sec = %12.2f (%5.1fuS)\n",b,8.0e6/b);
X	printf("DES cbc bytes per sec = %12.2f (%5.1fuS)\n",c,8.0e6/c);
X	printf("crypt         per sec = %12.2f (%5.1fuS)\n",d,1.0e6/d);
X	}
END_OF_FILE
  if test 4296 -ne `wc -c <'speed.c'`; then
    echo shar: \"'speed.c'\" unpacked with wrong size!
  fi
  # end of 'speed.c'
fi
if test -f 'str2key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'str2key.c'\"
else
  echo shar: Extracting \"'str2key.c'\" \(2341 characters\)
  sed "s/^X//" >'str2key.c' <<'END_OF_FILE'
X/* str2key.c */
X/* Copyright (C) 1993 Eric Young - see README for more details */
X#include "des_locl.h"
X
Xextern int des_check_key;
X
Xint des_string_to_key(str,key)
Xchar *str;
Xdes_cblock *key;
X	{
X	des_key_schedule ks;
X	int i,length;
X	register unsigned char j;
X
X	bzero(key,8);
X	length=strlen(str);
X#ifdef OLD_STR_TO_KEY
X	for (i=0; i<length; i++)
X		(*key)[i%8]^=(str[i]<<1);
X#else /* MIT COMPATIBLE */
X	for (i=0; i<length; i++)
X		{
X		j=str[i];
X		if ((i%16) < 8)
X			(*key)[i%8]^=(j<<1);
X		else
X			{
X			/* Reverse the bit order 05/05/92 eay */
X			j=((j<<4)&0xf0)|((j>>4)&0x0f);
X			j=((j<<2)&0xcc)|((j>>2)&0x33);
X			j=((j<<1)&0xaa)|((j>>1)&0x55);
X			(*key)[7-(i%8)]^=j;
X			}
X		}
X#endif
X	des_set_odd_parity((des_cblock *)key);
X	i=des_check_key;
X	des_check_key=0;
X	des_set_key((des_cblock *)key,ks);
X	des_check_key=i;
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key,(long)length,ks,
X		(des_cblock *)key);
X	bzero(ks,sizeof(ks));
X	des_set_odd_parity((des_cblock *)key);
X	return(0);
X	}
X
Xint des_string_to_2keys(str,key1,key2)
Xchar *str;
Xdes_cblock *key1,*key2;
X	{
X	des_key_schedule ks;
X	int i,length;
X	register unsigned char j;
X
X	bzero(key1,8);
X	bzero(key2,8);
X	length=strlen(str);
X#ifdef OLD_STR_TO_KEY
X	if (length <= 8)
X		{
X		for (i=0; i<length; i++)
X			{
X			(*key2)[i]=(*key1)[i]=(str[i]<<1);
X			}
X		}
X	else
X		{
X		for (i=0; i<length; i++)
X			{
X			if ((i/8)&1)
X				(*key2)[i%8]^=(str[i]<<1);
X			else
X				(*key1)[i%8]^=(str[i]<<1);
X			}
X		}
X#else /* MIT COMPATIBLE */
X	for (i=0; i<length; i++)
X		{
X		j=str[i];
X		if ((i%32) < 16)
X			{
X			if ((i%16) < 8)
X				(*key1)[i%8]^=(j<<1);
X			else
X				(*key2)[i%8]^=(j<<1);
X			}
X		else
X			{
X			j=((j<<4)&0xf0)|((j>>4)&0x0f);
X			j=((j<<2)&0xcc)|((j>>2)&0x33);
X			j=((j<<1)&0xaa)|((j>>1)&0x55);
X			if ((i%16) < 8)
X				(*key1)[7-(i%8)]^=j;
X			else
X				(*key2)[7-(i%8)]^=j;
X			}
X		}
X	if (length <= 8) bcopy(key1,key2,8);
X#endif
X	des_set_odd_parity((des_cblock *)key1);
X	des_set_odd_parity((des_cblock *)key2);
X	i=des_check_key;
X	des_check_key=0;
X	des_set_key((des_cblock *)key1,ks);
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key1,(long)length,ks,
X		(des_cblock *)key1);
X	des_set_key((des_cblock *)key2,ks);
X	des_cbc_cksum((des_cblock *)str,(des_cblock *)key2,(long)length,ks,
X		(des_cblock *)key2);
X	des_check_key=i;
X	bzero(ks,sizeof(ks));
X	des_set_odd_parity(key1);
X	des_set_odd_parity(key2);
X	return(0);
X	}
END_OF_FILE
  if test 2341 -ne `wc -c <'str2key.c'`; then
    echo shar: \"'str2key.c'\" unpacked with wrong size!
  fi
  # end of 'str2key.c'
fi
if test -f 'times' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'times'\"
else
  echo shar: Extracting \"'times'\" \(2688 characters\)
  sed "s/^X//" >'times' <<'END_OF_FILE'
XDEC Alpha DEC 4000/610 AXP OSF/1 v 1.3 - gcc v 2.3.3
Xset_key       per sec =    101840.19 (  9.8uS)
XDES ecb bytes per sec =   1223712.35 (  6.5uS)
XDES cbc bytes per sec =   1230542.98 (  6.5uS)
Xcrypt         per sec =      6428.75 (155.6uS)
X
XDEC Alpha DEC 4000/610 APX OSF/1 v 1.3 - cc -O2 - OSF/1 AXP
Xset_key       per sec =    114198.91 (  8.8uS)
XDES ecb bytes per sec =   1022710.93 (  7.8uS)
XDES cbc bytes per sec =   1008821.93 (  7.9uS)
Xcrypt         per sec =      5454.13 (183.3uS)
X
XDEC Alpha - DEC 3000/500 AXP OSF/1 - cc -O2 - 02/12/92
Xset_key       per sec =     83587.04 ( 12.0uS)
XDES ecb bytes per sec =    822620.82 (  9.7uS)
XDES cbc bytes per sec =    832929.60 (  9.6uS)
Xcrypt         per sec =      4807.62 (208.0uS)
X
Xsun sparc 10/30 - gcc -O2
Xset_key       per sec =     42005.24 ( 23.8uS)
XDES ecb bytes per sec =    555949.47 ( 14.4uS)
XDES cbc bytes per sec =    549440.28 ( 14.6uS)
Xcrypt         per sec =      2580.25 (387.6uS)
X
XPA-RISC 1.1 HP 710
Xset_key       per sec =     38916.86
XDES ecb bytes per sec =    505971.82
XDES cbc bytes per sec =    515381.13
Xcrypt         per sec =      2438.24
X
Xsun sparc 10/30 - cc -O4
Xset_key       per sec =     38379.86 ( 26.1uS)
XDES ecb bytes per sec =    460051.34 ( 17.4uS)
XDES cbc bytes per sec =    464970.54 ( 17.2uS)
Xcrypt         per sec =      2092.64 (477.9uS)
X
Xsun sparc 2 - gcc2 -O2
Xset_key       per sec =     21559.10
XDES ecb bytes per sec =    305566.92
XDES cbc bytes per sec =    303497.50
Xcrypt         per sec =      1410.48
X
XRS/6000 model 320
Xset_key       per sec =     14371.93
XDES ecb bytes per sec =    222231.26
XDES cbc bytes per sec =    223926.79
Xcrypt         per sec =       981.20
X
X68030 HP400
Xset_key       per sec =      5251.28
XDES ecb bytes per sec =     56186.56
XDES cbc bytes per sec =     58681.53
Xcrypt         per sec =       276.15
X
X80486sx/33MHz MSDOS Turbo C v 2.0
Xset_key       per sec =      1883.22 (531.0uS)
XDES ecb bytes per sec =     63393.31 (126.2uS)
XDES cbc bytes per sec =     63416.83 (126.1uS)
Xcrypt         per sec =       158.71 (6300.6uS)
X
X80486sx/33MHz MSDOS djgpp gcc 1.39 (32bit compiler)
Xset_key       per sec =     12603.08 (79.3)
XDES ecb bytes per sec =    158875.15 (50.4)
XDES cbc bytes per sec =    159893.85 (50.0)
Xcrypt         per sec =       780.24 (1281.7)
X
XVersion 1.99 26/08/92
X8MHz 68000 Atari-ST gcc 2.1 -O2 MiNT 0.94
Xset_key       per sec =       325.68 (3070.5uS)
XDES ecb bytes per sec =      4173.67 (1916.8uS)
XDES cbc bytes per sec =      4249.89 (1882.4uS)
Xcrypt         per sec =        20.19 (49521.6uS)
X
X8088/4.77mh MSDOS Turbo C v 2.0
Xset_key       per sec =        35.09
XDES ecb bytes per sec =       563.63
Xcrypt         per sec =         2.69
END_OF_FILE
  if test 2688 -ne `wc -c <'times'`; then
    echo shar: \"'times'\" unpacked with wrong size!
  fi
  # end of 'times'
fi
if test -f 'vms.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms.com'\"
else
  echo shar: Extracting \"'vms.com'\" \(2311 characters\)
  sed "s/^X//" >'vms.com' <<'END_OF_FILE'
X$! --- VMS.com ---
X$!
X$ GoSub defines
X$ GoSub linker_options
X$ If (P1 .nes. "")
X$ Then 
X$   GoSub 'P1'
X$ Else
X$   GoSub lib
X$   GoSub destest
X$   GoSub rpw
X$   GoSub speed
X$   GoSub des
X$ EndIF
X$!
X$ Exit
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DEFINES:
X$ OPT_FILE := "VAX_LINKER_OPTIONS.OPT"
X$!
X$ CC_OPTS := "/NODebug/OPTimize/NOWarn"
X$!
X$ LINK_OPTS := "/NODebug/NOTraceback/Contiguous"
X$!
X$ OBJS  = "cbc_cksm.obj,cbc_enc.obj,ecb_enc.obj,pcbc_enc.obj," + -
X          "qud_cksm.obj,rand_key.obj,read_pwd.obj,set_key.obj,"      + -
X          "str2key.obj,enc_read.obj,enc_writ.obj,fcrypt.obj,"           + -
X	  "cfb_enc.obj,3ecb_enc.obj,ofb_enc.obj"
X	   
X	   
X$!
X$ LIBDES = "cbc_cksm.c,cbc_enc.c,ecb_enc.c,enc_read.c,"           + -
X           "enc_writ.c,pcbc_enc.c,qud_cksm.c,rand_key.c,"         + -
X           "read_pwd.c,set_key.c,str2key.c,fcrypt.c,"                + -
X	   "cfb_enc.c,3ecb_enc.c,ofb_enc.c"
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$LINKER_OPTIONS:
X$ If (f$search(OPT_FILE) .eqs. "")
X$ Then
X$   Create 'OPT_FILE'
X$DECK
X! Default system options file to link against the sharable C runtime library
X!
XSys$Share:VAXcRTL.exe/Share
X$EOD
X$ EndIF
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$LIB:
X$ CC 'CC_OPTS' 'LIBDES'
X$ If (f$search("LIBDES.OLB") .nes. "")
X$ Then Library /Object /Replace libdes 'OBJS'
X$ Else Library /Create /Object  libdes 'OBJS'
X$ EndIF
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DESTEST:
X$ CC 'CC_OPTS' destest
X$ Link 'link_opts' /Exec=destest destest.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$RPW:
X$ CC 'CC_OPTS' rpw
X$ Link 'link_opts' /Exec=rpw  rpw.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$SPEED:
X$ CC 'CC_OPTS' speed
X$ Link 'link_opts' /Exec=speed speed.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
X$!
X$!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X$!
X$DES:
X$ CC 'CC_OPTS' des
X$ Link 'link_opts' /Exec=des des.obj,libdes/LIBRARY,'opt_file'/Option
X$ Return
END_OF_FILE
  if test 2311 -ne `wc -c <'vms.com'`; then
    echo shar: \"'vms.com'\" unpacked with wrong size!
  fi
  # end of 'vms.com'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
