Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i019:  gnuplot - interactive function plotting utility, Part07/33
Message-ID: <1993Oct21.144414.1785@sparky.sterling.com>
X-Md4-Signature: 77b14b6bec5b53b7431a8cf0cc78d06b
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 21 Oct 1993 14:44:14 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 19
Archive-name: gnuplot/part07
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/klein.dat gnuplot/graphics.c
# Wrapped by kent@sparky on Wed Oct 20 17:14:40 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 33)."'
if test -f 'gnuplot/demo/klein.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/klein.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/klein.dat'\" \(20117 characters\)
  sed "s/^X//" >'gnuplot/demo/klein.dat' <<'END_OF_FILE'
X1 0 0
X0.924 -0.383 0
X0.707 -0.707 0
X0.383 -0.924 0
X0 -1 0
X-0.383 -0.924 0
X-0.707 -0.707 0
X-0.924 -0.383 0
X-1 0 0
X-0.924 0.383 0
X-0.707 0.707 0
X-0.383 0.924 0
X0 1 0
X0.383 0.924 0
X0.707 0.707 0
X0.924 0.383 0
X1 0 0
X
X1.076 0 0.673
X0.994 -0.412 0.673
X0.761 -0.761 0.673
X0.412 -0.994 0.673
X0 -1.076 0.673
X-0.412 -0.994 0.673
X-0.761 -0.761 0.673
X-0.994 -0.412 0.673
X-1.076 0 0.673
X-0.994 0.412 0.673
X-0.761 0.761 0.673
X-0.412 0.994 0.673
X0 1.076 0.673
X0.412 0.994 0.673
X0.761 0.761 0.673
X0.994 0.412 0.673
X1.076 0 0.673
X
X1.304 0 1.315
X1.205 -0.499 1.315
X0.922 -0.922 1.315
X0.499 -1.205 1.315
X0 -1.304 1.315
X-0.499 -1.205 1.315
X-0.922 -0.922 1.315
X-1.205 -0.499 1.315
X-1.304 0 1.315
X-1.205 0.499 1.315
X-0.922 0.922 1.315
X-0.499 1.205 1.315
X0 1.304 1.315
X0.499 1.205 1.315
X0.922 0.922 1.315
X1.205 0.499 1.315
X1.304 0 1.315
X
X1.757 0 2.206
X1.623 -0.672 2.206
X1.242 -1.242 2.206
X0.672 -1.623 2.206
X0 -1.757 2.206
X-0.672 -1.623 2.206
X-1.242 -1.242 2.206
X-1.623 -0.672 2.206
X-1.757 0 2.206
X-1.623 0.672 2.206
X-1.242 1.242 2.206
X-0.672 1.623 2.206
X0 1.757 2.206
X0.672 1.623 2.206
X1.242 1.242 2.206
X1.623 0.672 2.206
X1.757 0 2.206
X
X2.21 0 3.097
X2.042 -0.846 3.097
X1.563 -1.563 3.097
X0.846 -2.042 3.097
X0 -2.21 3.097
X-0.846 -2.042 3.097
X-1.563 -1.563 3.097
X-2.042 -0.846 3.097
X-2.21 0 3.097
X-2.042 0.846 3.097
X-1.563 1.563 3.097
X-0.846 2.042 3.097
X0 2.21 3.097
X0.846 2.042 3.097
X1.563 1.563 3.097
X2.042 0.846 3.097
X2.21 0 3.097
X
X2.663 0 3.988
X2.46 -1.019 3.988
X1.883 -1.883 3.988
X1.019 -2.46 3.988
X0 -2.663 3.988
X-1.019 -2.46 3.988
X-1.883 -1.883 3.988
X-2.46 -1.019 3.988
X-2.663 0 3.988
X-2.46 1.019 3.988
X-1.883 1.883 3.988
X-1.019 2.46 3.988
X0 2.663 3.988
X1.019 2.46 3.988
X1.883 1.883 3.988
X2.46 1.019 3.988
X2.663 0 3.988
X
X3.116 0 4.879
X2.879 -1.192 4.879
X2.203 -2.203 4.879
X1.192 -2.879 4.879
X0 -3.116 4.879
X-1.192 -2.879 4.879
X-2.203 -2.203 4.879
X-2.879 -1.192 4.879
X-3.116 0 4.879
X-2.879 1.192 4.879
X-2.203 2.203 4.879
X-1.192 2.879 4.879
X0 3.116 4.879
X1.192 2.879 4.879
X2.203 2.203 4.879
X2.879 1.192 4.879
X3.116 0 4.879
X
X3.569 0 5.77
X3.297 -1.366 5.77
X2.524 -2.524 5.77
X1.366 -3.297 5.77
X0 -3.569 5.77
X-1.366 -3.297 5.77
X-2.524 -2.524 5.77
X-3.297 -1.366 5.77
X-3.569 0 5.77
X-3.297 1.366 5.77
X-2.524 2.524 5.77
X-1.366 3.297 5.77
X0 3.569 5.77
X1.366 3.297 5.77
X2.524 2.524 5.77
X3.297 1.366 5.77
X3.569 0 5.77
X
X4.022 0 6.661
X3.716 -1.539 6.661
X2.844 -2.844 6.661
X1.539 -3.716 6.661
X0 -4.022 6.661
X-1.539 -3.716 6.661
X-2.844 -2.844 6.661
X-3.716 -1.539 6.661
X-4.022 0 6.661
X-3.716 1.539 6.661
X-2.844 2.844 6.661
X-1.539 3.716 6.661
X0 4.022 6.661
X1.539 3.716 6.661
X2.844 2.844 6.661
X3.716 1.539 6.661
X4.022 0 6.661
X
X4.475 0 7.552
X4.134 -1.713 7.552
X3.164 -3.164 7.552
X1.713 -4.134 7.552
X0 -4.475 7.552
X-1.713 -4.134 7.552
X-3.164 -3.164 7.552
X-4.134 -1.713 7.552
X-4.475 0 7.552
X-4.134 1.713 7.552
X-3.164 3.164 7.552
X-1.713 4.134 7.552
X0 4.475 7.552
X1.713 4.134 7.552
X3.164 3.164 7.552
X4.134 1.713 7.552
X4.475 0 7.552
X
X4.928 0 8.443
X4.553 -1.886 8.443
X3.485 -3.485 8.443
X1.886 -4.553 8.443
X0 -4.928 8.443
X-1.886 -4.553 8.443
X-3.485 -3.485 8.443
X-4.553 -1.886 8.443
X-4.928 0 8.443
X-4.553 1.886 8.443
X-3.485 3.485 8.443
X-1.886 4.553 8.443
X0 4.928 8.443
X1.886 4.553 8.443
X3.485 3.485 8.443
X4.553 1.886 8.443
X4.928 0 8.443
X
X5.381 0 9.334
X4.971 -2.059 9.334
X3.805 -3.805 9.334
X2.059 -4.971 9.334
X0 -5.381 9.334
X-2.059 -4.971 9.334
X-3.805 -3.805 9.334
X-4.971 -2.059 9.334
X-5.381 0 9.334
X-4.971 2.059 9.334
X-3.805 3.805 9.334
X-2.059 4.971 9.334
X0 5.381 9.334
X2.059 4.971 9.334
X3.805 3.805 9.334
X4.971 2.059 9.334
X5.381 0 9.334
X
X5.834 0 10.225
X5.39 -2.233 10.225
X4.125 -4.125 10.225
X2.233 -5.39 10.225
X0 -5.834 10.225
X-2.233 -5.39 10.225
X-4.125 -4.125 10.225
X-5.39 -2.233 10.225
X-5.834 0 10.225
X-5.39 2.233 10.225
X-4.125 4.125 10.225
X-2.233 5.39 10.225
X0 5.834 10.225
X2.233 5.39 10.225
X4.125 4.125 10.225
X5.39 2.233 10.225
X5.834 0 10.225
X
X6.287 0 11.116
X5.808 -2.406 11.116
X4.446 -4.446 11.116
X2.406 -5.808 11.116
X0 -6.287 11.116
X-2.406 -5.808 11.116
X-4.446 -4.446 11.116
X-5.808 -2.406 11.116
X-6.287 0 11.116
X-5.808 2.406 11.116
X-4.446 4.446 11.116
X-2.406 5.808 11.116
X0 6.287 11.116
X2.406 5.808 11.116
X4.446 4.446 11.116
X5.808 2.406 11.116
X6.287 0 11.116
X
X6.74 0 12.007
X6.227 -2.579 12.007
X4.766 -4.766 12.007
X2.579 -6.227 12.007
X0 -6.74 12.007
X-2.579 -6.227 12.007
X-4.766 -4.766 12.007
X-6.227 -2.579 12.007
X-6.74 0 12.007
X-6.227 2.579 12.007
X-4.766 4.766 12.007
X-2.579 6.227 12.007
X0 6.74 12.007
X2.579 6.227 12.007
X4.766 4.766 12.007
X6.227 2.579 12.007
X6.74 0 12.007
X
X7.193 0 12.898
X6.645 -2.753 12.898
X5.086 -5.086 12.898
X2.753 -6.645 12.898
X0 -7.193 12.898
X-2.753 -6.645 12.898
X-5.086 -5.086 12.898
X-6.645 -2.753 12.898
X-7.193 0 12.898
X-6.645 2.753 12.898
X-5.086 5.086 12.898
X-2.753 6.645 12.898
X0 7.193 12.898
X2.753 6.645 12.898
X5.086 5.086 12.898
X6.645 2.753 12.898
X7.193 0 12.898
X
X7.648 0 13.97
X7.066 -2.927 13.97
X5.408 -5.408 13.97
X2.927 -7.066 13.97
X0 -7.648 13.97
X-2.927 -7.066 13.97
X-5.408 -5.408 13.97
X-7.066 -2.927 13.97
X-7.648 0 13.97
X-7.066 2.927 13.97
X-5.408 5.408 13.97
X-2.927 7.066 13.97
X0 7.648 13.97
X2.927 7.066 13.97
X5.408 5.408 13.97
X7.066 2.927 13.97
X7.648 0 13.97
X
X7.946 0 14.887
X7.341 -3.041 14.887
X5.619 -5.619 14.887
X3.041 -7.341 14.887
X0 -7.946 14.887
X-3.041 -7.341 14.887
X-5.619 -5.619 14.887
X-7.341 -3.041 14.887
X-7.946 0 14.887
X-7.341 3.041 14.887
X-5.619 5.619 14.887
X-3.041 7.341 14.887
X0 7.946 14.887
X3.041 7.341 14.887
X5.619 5.619 14.887
X7.341 3.041 14.887
X7.946 0 14.887
X
X7.982 0 15.851
X7.375 -3.055 15.851
X5.644 -5.644 15.851
X3.055 -7.375 15.851
X0 -7.982 15.851
X-3.055 -7.375 15.851
X-5.644 -5.644 15.851
X-7.375 -3.055 15.851
X-7.982 0 15.851
X-7.375 3.055 15.851
X-5.644 5.644 15.851
X-3.055 7.375 15.851
X0 7.982 15.851
X3.055 7.375 15.851
X5.644 5.644 15.851
X7.375 3.055 15.851
X7.982 0 15.851
X
X7.754 0 16.788
X7.164 -2.967 16.788
X5.483 -5.483 16.788
X2.967 -7.164 16.788
X0 -7.754 16.788
X-2.967 -7.164 16.788
X-5.483 -5.483 16.788
X-7.164 -2.967 16.788
X-7.754 0 16.788
X-7.164 2.967 16.788
X-5.483 5.483 16.788
X-2.967 7.164 16.788
X0 7.754 16.788
X2.967 7.164 16.788
X5.483 5.483 16.788
X7.164 2.967 16.788
X7.754 0 16.788
X
X7.279 0 17.628
X6.725 -2.786 17.628
X5.147 -5.147 17.628
X2.786 -6.725 17.628
X0 -7.279 17.628
X-2.786 -6.725 17.628
X-5.147 -5.147 17.628
X-6.725 -2.786 17.628
X-7.279 0 17.628
X-6.725 2.786 17.628
X-5.147 5.147 17.628
X-2.786 6.725 17.628
X0 7.279 17.628
X2.786 6.725 17.628
X5.147 5.147 17.628
X6.725 2.786 17.628
X7.279 0 17.628
X
X6.593 0 18.305
X6.091 -2.523 18.305
X4.662 -4.662 18.305
X2.523 -6.091 18.305
X0 -6.593 18.305
X-2.523 -6.091 18.305
X-4.662 -4.662 18.305
X-6.091 -2.523 18.305
X-6.593 0 18.305
X-6.091 2.523 18.305
X-4.662 4.662 18.305
X-2.523 6.091 18.305
X0 6.593 18.305
X2.523 6.091 18.305
X4.662 4.662 18.305
X6.091 2.523 18.305
X6.593 0 18.305
X
X5.747 0 18.77
X5.31 -2.199 18.77
X4.064 -4.064 18.77
X2.199 -5.31 18.77
X0 -5.747 18.77
X-2.199 -5.31 18.77
X-4.064 -4.064 18.77
X-5.31 -2.199 18.77
X-5.747 0 18.77
X-5.31 2.199 18.77
X-4.064 4.064 18.77
X-2.199 5.31 18.77
X0 5.747 18.77
X2.199 5.31 18.77
X4.064 4.064 18.77
X5.31 2.199 18.77
X5.747 0 18.77
X
X4.807 0 18.986
X4.442 -1.84 18.986
X3.399 -3.399 18.986
X1.84 -4.442 18.986
X0 -4.807 18.986
X-1.84 -4.442 18.986
X-3.399 -3.399 18.986
X-4.442 -1.84 18.986
X-4.807 0 18.986
X-4.442 1.84 18.986
X-3.399 3.399 18.986
X-1.84 4.442 18.986
X0 4.807 18.986
X1.84 4.442 18.986
X3.399 3.399 18.986
X4.442 1.84 18.986
X4.807 0 18.986
X
X3.844 0 18.938
X3.552 -1.471 18.938
X2.718 -2.718 18.938
X1.471 -3.552 18.938
X0 -3.844 18.938
X-1.471 -3.552 18.938
X-2.718 -2.718 18.938
X-3.552 -1.471 18.938
X-3.844 0 18.938
X-3.552 1.471 18.938
X-2.718 2.718 18.938
X-1.471 3.552 18.938
X0 3.844 18.938
X1.471 3.552 18.938
X2.718 2.718 18.938
X3.552 1.471 18.938
X3.844 0 18.938
X
X2.931 0 18.628
X2.708 -1.122 18.628
X2.072 -2.072 18.628
X1.122 -2.708 18.628
X0 -2.931 18.628
X-1.122 -2.708 18.628
X-2.072 -2.072 18.628
X-2.708 -1.122 18.628
X-2.931 0 18.628
X-2.708 1.122 18.628
X-2.072 2.072 18.628
X-1.122 2.708 18.628
X0 2.931 18.628
X1.122 2.708 18.628
X2.072 2.072 18.628
X2.708 1.122 18.628
X2.931 0 18.628
X
X2.136 0 18.081
X1.974 -0.818 18.081
X1.511 -1.511 18.081
X0.818 -1.974 18.081
X0 -2.136 18.081
X-0.818 -1.974 18.081
X-1.511 -1.511 18.081
X-1.974 -0.818 18.081
X-2.136 0 18.081
X-1.974 0.818 18.081
X-1.511 1.511 18.081
X-0.818 1.974 18.081
X0 2.136 18.081
X0.818 1.974 18.081
X1.511 1.511 18.081
X1.974 0.818 18.081
X2.136 0 18.081
X
X1.522 0 17.338
X1.406 -0.582 17.338
X1.076 -1.076 17.338
X0.582 -1.406 17.338
X0 -1.522 17.338
X-0.582 -1.406 17.338
X-1.076 -1.076 17.338
X-1.406 -0.582 17.338
X-1.522 0 17.338
X-1.406 0.582 17.338
X-1.076 1.076 17.338
X-0.582 1.406 17.338
X0 1.522 17.338
X0.582 1.406 17.338
X1.076 1.076 17.338
X1.406 0.582 17.338
X1.522 0 17.338
X
X1.133 0 16.455
X1.047 -0.434 16.455
X0.801 -0.801 16.455
X0.434 -1.047 16.455
X0 -1.133 16.455
X-0.434 -1.047 16.455
X-0.801 -0.801 16.455
X-1.047 -0.434 16.455
X-1.133 0 16.455
X-1.047 0.434 16.455
X-0.801 0.801 16.455
X-0.434 1.047 16.455
X0 1.133 16.455
X0.434 1.047 16.455
X0.801 0.801 16.455
X1.047 0.434 16.455
X1.133 0 16.455
X
X1 0 15.5
X0.924 -0.383 15.5
X0.707 -0.707 15.5
X0.383 -0.924 15.5
X0 -1 15.5
X-0.383 -0.924 15.5
X-0.707 -0.707 15.5
X-0.924 -0.383 15.5
X-1 0 15.5
X-0.924 0.383 15.5
X-0.707 0.707 15.5
X-0.383 0.924 15.5
X0 1 15.5
X0.383 0.924 15.5
X0.707 0.707 15.5
X0.924 0.383 15.5
X1 0 15.5
X
X0.911 0 14.515
X0.836 -0.383 14.528
X0.623 -0.707 14.567
X0.304 -0.924 14.625
X-0.073 -1 14.694
X-0.449 -0.924 14.762
X-0.768 -0.707 14.821
X-0.982 -0.383 14.859
X-1.057 0 14.873
X-0.982 0.383 14.859
X-0.768 0.707 14.821
X-0.449 0.924 14.762
X-0.073 1 14.694
X0.304 0.924 14.625
X0.623 0.707 14.567
X0.836 0.383 14.528
X0.911 0 14.515
X
X0.647 0 13.561
X0.576 -0.383 13.588
X0.373 -0.707 13.665
X0.069 -0.924 13.779
X-0.289 -1 13.914
X-0.647 -0.924 14.049
X-0.951 -0.707 14.163
X-1.153 -0.383 14.239
X-1.225 0 14.266
X-1.153 0.383 14.239
X-0.951 0.707 14.163
X-0.647 0.924 14.049
X-0.289 1 13.914
X0.069 0.924 13.779
X0.373 0.707 13.665
X0.576 0.383 13.588
X0.647 0 13.561
X
X0.205 0 12.653
X0.14 -0.383 12.693
X-0.043 -0.707 12.808
X-0.318 -0.924 12.98
X-0.643 -1 13.182
X-0.968 -0.924 13.384
X-1.243 -0.707 13.556
X-1.426 -0.383 13.671
X-1.491 0 13.711
X-1.426 0.383 13.671
X-1.243 0.707 13.556
X-0.968 0.924 13.384
X-0.643 1 13.182
X-0.318 0.924 12.98
X-0.043 0.707 12.808
X0.14 0.383 12.693
X0.205 0 12.653
X
X-0.324 0 11.805
X-0.389 -0.383 11.845
X-0.572 -0.707 11.96
X-0.847 -0.924 12.132
X-1.172 -1 12.334
X-1.497 -0.924 12.536
X-1.772 -0.707 12.708
X-1.955 -0.383 12.823
X-2.02 0 12.863
X-1.955 0.383 12.823
X-1.772 0.707 12.708
X-1.497 0.924 12.536
X-1.172 1 12.334
X-0.847 0.924 12.132
X-0.572 0.707 11.96
X-0.389 0.383 11.845
X-0.324 0 11.805
X
X-0.853 0 10.957
X-0.918 -0.383 10.997
X-1.101 -0.707 11.112
X-1.376 -0.924 11.284
X-1.701 -1 11.486
X-2.026 -0.924 11.688
X-2.301 -0.707 11.86
X-2.484 -0.383 11.975
X-2.549 0 12.015
X-2.484 0.383 11.975
X-2.301 0.707 11.86
X-2.026 0.924 11.688
X-1.701 1 11.486
X-1.376 0.924 11.284
X-1.101 0.707 11.112
X-0.918 0.383 10.997
X-0.853 0 10.957
X
X-1.382 0 10.109
X-1.447 -0.383 10.149
X-1.63 -0.707 10.264
X-1.905 -0.924 10.436
X-2.23 -1 10.638
X-2.555 -0.924 10.84
X-2.83 -0.707 11.012
X-3.013 -0.383 11.127
X-3.078 0 11.167
X-3.013 0.383 11.127
X-2.83 0.707 11.012
X-2.555 0.924 10.84
X-2.23 1 10.638
X-1.905 0.924 10.436
X-1.63 0.707 10.264
X-1.447 0.383 10.149
X-1.382 0 10.109
X
X-1.911 0 9.261
X-1.976 -0.383 9.301
X-2.159 -0.707 9.416
X-2.434 -0.924 9.588
X-2.759 -1 9.79
X-3.084 -0.924 9.992
X-3.359 -0.707 10.164
X-3.542 -0.383 10.279
X-3.607 0 10.319
X-3.542 0.383 10.279
X-3.359 0.707 10.164
X-3.084 0.924 9.992
X-2.759 1 9.79
X-2.434 0.924 9.588
X-2.159 0.707 9.416
X-1.976 0.383 9.301
X-1.911 0 9.261
X
X-2.44 0 8.413
X-2.505 -0.383 8.453
X-2.688 -0.707 8.568
X-2.963 -0.924 8.74
X-3.288 -1 8.942
X-3.613 -0.924 9.144
X-3.888 -0.707 9.316
X-4.071 -0.383 9.431
X-4.136 0 9.471
X-4.071 0.383 9.431
X-3.888 0.707 9.316
X-3.613 0.924 9.144
X-3.288 1 8.942
X-2.963 0.924 8.74
X-2.688 0.707 8.568
X-2.505 0.383 8.453
X-2.44 0 8.413
X
X-2.969 0 7.565
X-3.034 -0.383 7.605
X-3.217 -0.707 7.72
X-3.492 -0.924 7.892
X-3.817 -1 8.094
X-4.142 -0.924 8.296
X-4.417 -0.707 8.468
X-4.6 -0.383 8.583
X-4.665 0 8.623
X-4.6 0.383 8.583
X-4.417 0.707 8.468
X-4.142 0.924 8.296
X-3.817 1 8.094
X-3.492 0.924 7.892
X-3.217 0.707 7.72
X-3.034 0.383 7.605
X-2.969 0 7.565
X
X-3.498 0 6.717
X-3.563 -0.383 6.757
X-3.746 -0.707 6.872
X-4.021 -0.924 7.044
X-4.346 -1 7.246
X-4.671 -0.924 7.448
X-4.946 -0.707 7.62
X-5.129 -0.383 7.735
X-5.194 0 7.775
X-5.129 0.383 7.735
X-4.946 0.707 7.62
X-4.671 0.924 7.448
X-4.346 1 7.246
X-4.021 0.924 7.044
X-3.746 0.707 6.872
X-3.563 0.383 6.757
X-3.498 0 6.717
X
X-4.027 0 5.869
X-4.092 -0.383 5.909
X-4.275 -0.707 6.024
X-4.55 -0.924 6.196
X-4.875 -1 6.398
X-5.2 -0.924 6.6
X-5.475 -0.707 6.772
X-5.658 -0.383 6.887
X-5.723 0 6.927
X-5.658 0.383 6.887
X-5.475 0.707 6.772
X-5.2 0.924 6.6
X-4.875 1 6.398
X-4.55 0.924 6.196
X-4.275 0.707 6.024
X-4.092 0.383 5.909
X-4.027 0 5.869
X
X-4.556 0 5.021
X-4.621 -0.383 5.061
X-4.804 -0.707 5.176
X-5.079 -0.924 5.348
X-5.404 -1 5.55
X-5.729 -0.924 5.752
X-6.004 -0.707 5.924
X-6.187 -0.383 6.039
X-6.252 0 6.079
X-6.187 0.383 6.039
X-6.004 0.707 5.924
X-5.729 0.924 5.752
X-5.404 1 5.55
X-5.079 0.924 5.348
X-4.804 0.707 5.176
X-4.621 0.383 5.061
X-4.556 0 5.021
X
X-5.085 0 4.173
X-5.15 -0.383 4.213
X-5.333 -0.707 4.328
X-5.608 -0.924 4.5
X-5.933 -1 4.702
X-6.258 -0.924 4.904
X-6.533 -0.707 5.076
X-6.716 -0.383 5.191
X-6.781 0 5.231
X-6.716 0.383 5.191
X-6.533 0.707 5.076
X-6.258 0.924 4.904
X-5.933 1 4.702
X-5.608 0.924 4.5
X-5.333 0.707 4.328
X-5.15 0.383 4.213
X-5.085 0 4.173
X
X-5.614 0 3.325
X-5.679 -0.383 3.365
X-5.862 -0.707 3.48
X-6.137 -0.924 3.652
X-6.462 -1 3.854
X-6.787 -0.924 4.056
X-7.062 -0.707 4.228
X-7.245 -0.383 4.343
X-7.31 0 4.383
X-7.245 0.383 4.343
X-7.062 0.707 4.228
X-6.787 0.924 4.056
X-6.462 1 3.854
X-6.137 0.924 3.652
X-5.862 0.707 3.48
X-5.679 0.383 3.365
X-5.614 0 3.325
X
X-6.143 0 2.477
X-6.208 -0.383 2.517
X-6.391 -0.707 2.632
X-6.666 -0.924 2.804
X-6.991 -1 3.006
X-7.316 -0.924 3.208
X-7.591 -0.707 3.38
X-7.774 -0.383 3.495
X-7.839 0 3.535
X-7.774 0.383 3.495
X-7.591 0.707 3.38
X-7.316 0.924 3.208
X-6.991 1 3.006
X-6.666 0.924 2.804
X-6.391 0.707 2.632
X-6.208 0.383 2.517
X-6.143 0 2.477
X
X-6.573 0 1.543
X-6.638 -0.383 1.582
X-6.824 -0.707 1.694
X-7.102 -0.924 1.861
X-7.43 -1 2.058
X-7.758 -0.924 2.255
X-8.036 -0.707 2.422
X-8.222 -0.383 2.533
X-8.288 0 2.572
X-8.222 0.383 2.533
X-8.036 0.707 2.422
X-7.758 0.924 2.255
X-7.43 1 2.058
X-7.102 0.924 1.861
X-6.824 0.707 1.694
X-6.638 0.383 1.582
X-6.573 0 1.543
X
X-6.822 0 1.019
X-6.893 -0.383 1.045
X-7.097 -0.707 1.119
X-7.402 -0.924 1.229
X-7.762 -1 1.359
X-8.122 -0.924 1.489
X-8.427 -0.707 1.599
X-8.631 -0.383 1.672
X-8.703 0 1.698
X-8.631 0.383 1.672
X-8.427 0.707 1.599
X-8.122 0.924 1.489
X-7.762 1 1.359
X-7.402 0.924 1.229
X-7.097 0.707 1.119
X-6.893 0.383 1.045
X-6.822 0 1.019
X
X-6.965 0 0.457
X-7.04 -0.383 0.468
X-7.255 -0.707 0.501
X-7.575 -0.924 0.551
X-7.953 -1 0.609
X-8.332 -0.924 0.667
X-8.652 -0.707 0.716
X-8.867 -0.383 0.749
X-8.942 0 0.761
X-8.867 0.383 0.749
X-8.652 0.707 0.716
X-8.332 0.924 0.667
X-7.953 1 0.609
X-7.575 0.924 0.551
X-7.255 0.707 0.501
X-7.04 0.383 0.468
X-6.965 0 0.457
X
X-6.997 0 -0.123
X-7.074 -0.383 -0.126
X-7.29 -0.707 -0.135
X-7.614 -0.924 -0.148
X-7.997 -1 -0.164
X-8.379 -0.924 -0.18
X-8.703 -0.707 -0.193
X-8.92 -0.383 -0.202
X-8.996 0 -0.205
X-8.92 0.383 -0.202
X-8.703 0.707 -0.193
X-8.379 0.924 -0.18
X-7.997 1 -0.164
X-7.614 0.924 -0.148
X-7.29 0.707 -0.135
X-7.074 0.383 -0.126
X-6.997 0 -0.123
X
X-6.918 0 -0.698
X-6.992 -0.383 -0.716
X-7.203 -0.707 -0.766
X-7.518 -0.924 -0.842
X-7.89 -1 -0.931
X-8.262 -0.924 -1.02
X-8.578 -0.707 -1.095
X-8.789 -0.383 -1.145
X-8.863 0 -1.163
X-8.789 0.383 -1.145
X-8.578 0.707 -1.095
X-8.262 0.924 -1.02
X-7.89 1 -0.931
X-7.518 0.924 -0.842
X-7.203 0.707 -0.766
X-6.992 0.383 -0.716
X-6.918 0 -0.698
X
X-6.729 0 -1.247
X-6.798 -0.383 -1.278
X-6.995 -0.707 -1.368
X-7.29 -0.924 -1.503
X-7.638 -1 -1.662
X-7.986 -0.924 -1.821
X-8.281 -0.707 -1.956
X-8.479 -0.383 -2.046
X-8.548 0 -2.078
X-8.479 0.383 -2.046
X-8.281 0.707 -1.956
X-7.986 0.924 -1.821
X-7.638 1 -1.662
X-7.29 0.924 -1.503
X-6.995 0.707 -1.368
X-6.798 0.383 -1.278
X-6.729 0 -1.247
X
X-6.438 0 -1.749
X-6.499 -0.383 -1.793
X-6.675 -0.707 -1.92
X-6.939 -0.924 -2.109
X-7.25 -1 -2.332
X-7.561 -0.924 -2.555
X-7.825 -0.707 -2.744
X-8.001 -0.383 -2.87
X-8.063 0 -2.915
X-8.001 0.383 -2.87
X-7.825 0.707 -2.744
X-7.561 0.924 -2.555
X-7.25 1 -2.332
X-6.939 0.924 -2.109
X-6.675 0.707 -1.92
X-6.499 0.383 -1.793
X-6.438 0 -1.749
X
X-6.055 0 -2.186
X-6.107 -0.383 -2.241
X-6.256 -0.707 -2.399
X-6.478 -0.924 -2.635
X-6.74 -1 -2.914
X-7.002 -0.924 -3.193
X-7.225 -0.707 -3.429
X-7.373 -0.383 -3.587
X-7.425 0 -3.643
X-7.373 0.383 -3.587
X-7.225 0.707 -3.429
X-7.002 0.924 -3.193
X-6.74 1 -2.914
X-6.478 0.924 -2.635
X-6.256 0.707 -2.399
X-6.107 0.383 -2.241
X-6.055 0 -2.186
X
X-5.596 0 -2.54
X-5.636 -0.383 -2.605
X-5.752 -0.707 -2.788
X-5.924 -0.924 -3.063
X-6.128 -1 -3.387
X-6.331 -0.924 -3.711
X-6.504 -0.707 -3.986
X-6.619 -0.383 -4.17
X-6.66 0 -4.234
X-6.619 0.383 -4.17
X-6.504 0.707 -3.986
X-6.331 0.924 -3.711
X-6.128 1 -3.387
X-5.924 0.924 -3.063
X-5.752 0.707 -2.788
X-5.636 0.383 -2.605
X-5.596 0 -2.54
X
X-5.077 0 -2.8
X-5.104 -0.383 -2.871
X-5.182 -0.707 -3.074
X-5.298 -0.924 -3.376
X-5.436 -1 -3.734
X-5.573 -0.924 -4.091
X-5.689 -0.707 -4.394
X-5.767 -0.383 -4.596
X-5.794 0 -4.667
X-5.767 0.383 -4.596
X-5.689 0.707 -4.394
X-5.573 0.924 -4.091
X-5.436 1 -3.734
X-5.298 0.924 -3.376
X-5.182 0.707 -3.074
X-5.104 0.383 -2.871
X-5.077 0 -2.8
X
X-4.517 0 -2.955
X-4.53 -0.383 -3.03
X-4.568 -0.707 -3.244
X-4.624 -0.924 -3.563
X-4.69 -1 -3.94
X-4.756 -0.924 -4.317
X-4.812 -0.707 -4.637
X-4.849 -0.383 -4.85
X-4.862 0 -4.925
X-4.849 0.383 -4.85
X-4.812 0.707 -4.637
X-4.756 0.924 -4.317
X-4.69 1 -3.94
X-4.624 0.924 -3.563
X-4.568 0.707 -3.244
X-4.53 0.383 -3.03
X-4.517 0 -2.955
X
X-3.938 0 -2.999
X-3.937 -0.383 -3.075
X-3.932 -0.707 -3.292
X-3.926 -0.924 -3.617
X-3.918 -1 -3.999
X-3.91 -0.924 -4.382
X-3.903 -0.707 -4.706
X-3.899 -0.383 -4.923
X-3.897 0 -4.999
X-3.899 0.383 -4.923
X-3.903 0.707 -4.706
X-3.91 0.924 -4.382
X-3.918 1 -3.999
X-3.926 0.924 -3.617
X-3.932 0.707 -3.292
X-3.937 0.383 -3.075
X-3.938 0 -2.999
X
X-3.362 0 -2.931
X-3.346 -0.383 -3.006
X-3.3 -0.707 -3.218
X-3.231 -0.924 -3.535
X-3.149 -1 -3.909
X-3.068 -0.924 -4.282
X-2.999 -0.707 -4.599
X-2.953 -0.383 -4.811
X-2.937 0 -4.886
X-2.953 0.383 -4.811
X-2.999 0.707 -4.599
X-3.068 0.924 -4.282
X-3.149 1 -3.909
X-3.231 0.924 -3.535
X-3.3 0.707 -3.218
X-3.346 0.383 -3.006
X-3.362 0 -2.931
X
X-2.809 0 -2.754
X-2.779 -0.383 -2.824
X-2.693 -0.707 -3.023
X-2.564 -0.924 -3.32
X-2.413 -1 -3.672
X-2.261 -0.924 -4.023
X-2.132 -0.707 -4.321
X-2.046 -0.383 -4.52
X-2.016 0 -4.589
X-2.046 0.383 -4.52
X-2.132 0.707 -4.321
X-2.261 0.924 -4.023
X-2.413 1 -3.672
X-2.564 0.924 -3.32
X-2.693 0.707 -3.023
X-2.779 0.383 -2.824
X-2.809 0 -2.754
X
X-2.301 0 -2.473
X-2.258 -0.383 -2.536
X-2.136 -0.707 -2.714
X-1.952 -0.924 -2.982
X-1.735 -1 -3.297
X-1.519 -0.924 -3.613
X-1.335 -0.707 -3.88
X-1.212 -0.383 -4.059
X-1.169 0 -4.121
X-1.212 0.383 -4.059
X-1.335 0.707 -3.88
X-1.519 0.924 -3.613
X-1.735 1 -3.297
X-1.952 0.924 -2.982
X-2.136 0.707 -2.714
X-2.258 0.383 -2.536
X-2.301 0 -2.473
X
X-1.857 0 -2.099
X-1.803 -0.383 -2.153
X-1.648 -0.707 -2.304
X-1.416 -0.924 -2.531
X-1.143 -1 -2.799
X-0.869 -0.924 -3.067
X-0.638 -0.707 -3.294
X-0.483 -0.383 -3.446
X-0.428 0 -3.499
X-0.483 0.383 -3.446
X-0.638 0.707 -3.294
X-0.869 0.924 -3.067
X-1.143 1 -2.799
X-1.416 0.924 -2.531
X-1.648 0.707 -2.304
X-1.803 0.383 -2.153
X-1.857 0 -2.099
X
X-1.493 0 -1.647
X-1.429 -0.383 -1.689
X-1.248 -0.707 -1.808
X-0.977 -0.924 -1.986
X-0.657 -1 -2.197
X-0.337 -0.924 -2.407
X-0.066 -0.707 -2.585
X0.115 -0.383 -2.704
X0.179 0 -2.746
X0.115 0.383 -2.704
X-0.066 0.707 -2.585
X-0.337 0.924 -2.407
X-0.657 1 -2.197
X-0.977 0.924 -1.986
X-1.248 0.707 -1.808
X-1.429 0.383 -1.689
X-1.493 0 -1.647
X
X-1.223 0 -1.134
X-1.152 -0.383 -1.163
X-0.951 -0.707 -1.245
X-0.651 -0.924 -1.367
X-0.297 -1 -1.512
X0.058 -0.924 -1.656
X0.358 -0.707 -1.779
X0.559 -0.383 -1.861
X0.629 0 -1.89
X0.559 0.383 -1.861
X0.358 0.707 -1.779
X0.058 0.924 -1.656
X-0.297 1 -1.512
X-0.651 0.924 -1.367
X-0.951 0.707 -1.245
X-1.152 0.383 -1.163
X-1.223 0 -1.134
X
X-1.056 0 -0.578
X-0.981 -0.383 -0.592
X-0.769 -0.707 -0.634
X-0.45 -0.924 -0.697
X-0.075 -1 -0.77
X0.301 -0.924 -0.844
X0.619 -0.707 -0.906
X0.832 -0.383 -0.948
X0.906 0 -0.963
X0.832 0.383 -0.948
X0.619 0.707 -0.906
X0.301 0.924 -0.844
X-0.075 1 -0.77
X-0.45 0.924 -0.697
X-0.769 0.707 -0.634
X-0.981 0.383 -0.592
X-1.056 0 -0.578
X
X-1 0 0
X-0.924 -0.383 0
X-0.707 -0.707 0
X-0.383 -0.924 0
X0 -1 0
X0.383 -0.924 0
X0.707 -0.707 0
X0.924 -0.383 0
X1 0 0
X0.924 0.383 0
X0.707 0.707 0
X0.383 0.924 0
X0 1 0
X-0.383 0.924 0
X-0.707 0.707 0
X-0.924 0.383 0
X-1 0 0
X
END_OF_FILE
  if test 20117 -ne `wc -c <'gnuplot/demo/klein.dat'`; then
    echo shar: \"'gnuplot/demo/klein.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/klein.dat'
fi
if test -f 'gnuplot/graphics.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/graphics.c'\"
else
  echo shar: Extracting \"'gnuplot/graphics.c'\" \(55795 characters\)
  sed "s/^X//" >'gnuplot/graphics.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: graphics.c%v 3.50.1.9 1993/08/05 05:38:59 woo Exp $";
X#endif
X
X
X/* GNUPLOT - graphics.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X *
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X#include <stdio.h>
X#include <math.h>
X#include <assert.h>
X#if !defined(u3b2)
X#include <time.h>
X#endif
X#include "plot.h"
X#include "setshow.h"
X
X#if defined(DJGPP)||defined(sun386)
X#define time_t unsigned long
X#endif
X
X#ifndef AMIGA_SC_6_1
Xextern char *strcpy(),*strncpy(),*strcat(),*ctime();
X#endif /* !AMIGA_SC_6_1 */
Xchar *tdate;
X#ifdef AMIGA_AC_5
Xtime_t dated;
X#else
X#if defined(apollo) || defined(sequent) || defined(u3b2) || defined(alliant) || defined(sun386)
X#include <sys/types.h> /* typedef long time_t; */
X#endif
Xtime_t dated; /* ,time(); */
X#include <time.h>
X#endif
X
Xvoid plot_impulses();
Xvoid plot_lines();
Xvoid plot_points();
Xvoid plot_dots();
Xvoid plot_bars();
Xvoid plot_boxes();
Xvoid edge_intersect();
XTBOOLEAN two_edge_intersect();
X
Xvoid plot_steps();			/* JG */
Xvoid edge_intersect_steps();     	/* JG */
XTBOOLEAN two_edge_intersect_steps();	/* JG */
X
X/* for plotting error bars */
X#define ERRORBARTIC (t->h_tic/2) /* half the width of error bar tic mark */
X
X#ifndef max		/* Lattice C has max() in math.h, but shouldn't! */
X#define max(a,b) ((a > b) ? a : b)
X#endif
X
X#ifndef min
X#define min(a,b) ((a < b) ? a : b)
X#endif
X
X#define inrange(z,min,max) ((min<max) ? ((z>=min)&&(z<=max)) : ((z>=max)&&(z<=min)) )
X
X/* True if a and b have the same sign or zero (positive or negative) */
X#define samesign(a,b) ((a) * (b) >= 0)
X
X/* Define the boundary of the plot
X * These are computed at each call to do_plot, and are constant over
X * the period of one do_plot. They actually only change when the term
X * type changes and when the 'set size' factors change. 
X */
Xstatic int xleft, xright, ybot, ytop;
X
X/* Boundary and scale factors, in user coordinates */
X/* x_min, x_max, y_min, y_max are local to this file and
X * are not the same as variables of the same names in other files
X */
Xstatic double x_min, x_max, y_min, y_max;
Xstatic double xscale, yscale;
X
X/* And the functions to map from user to terminal coordinates */
X#define map_x(x) (int)(xleft+(x-x_min)*xscale+0.5) /* maps floating point x to screen */ 
X#define map_y(y) (int)(ybot+(y-y_min)*yscale+0.5)	/* same for y */
X
X/* (DFK) Watch for cancellation error near zero on axes labels */
X#define SIGNIF (0.01)		/* less than one hundredth of a tic mark */
X#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
X#define NearlyEqual(x,y,tic) (fabs((x)-(y)) < ((tic) * SIGNIF))
X
X/* (DFK) For some reason, the Sun386i compiler screws up with the CheckLog 
X * macro, so I write it as a function on that machine.
X */
X#ifndef sun386
X/* (DFK) Use 10^x if logscale is in effect, else x */
X#define CheckLog(is_log, base_log, x) ((is_log) ? pow(base_log, (x)) : (x))
X#else
Xstatic double
XCheckLog(is_log, base_log, x)
X     TBOOLEAN is_log;
X     double base_log;
X     double x;
X{
X  if (is_log)
X    return(pow(base_log, x));
X  else
X    return(x);
X}
X#endif /* sun386 */
X
Xdouble
XLogScale(coord, is_log, log_base_log, what, axis)
X	double coord;			/* the value */
X	TBOOLEAN is_log;			/* is this axis in logscale? */
X        double log_base_log;		/* if so, the log of its base */
X	char *what;			/* what is the coord for? */
X	char *axis;			/* which axis is this for ("x" or "y")? */
X{
X    if (is_log) {
X	   if (coord <= 0.0) {
X		  char errbuf[100];		/* place to write error message */
X		(void) sprintf(errbuf,"%s has %s coord of %g; must be above 0 for log scale!",
X				what, axis, coord);
X		  (*term_tbl[term].text)();
X		  (void) fflush(outfile);
X		  int_error(errbuf, NO_CARET);
X	   } else
X		return(log(coord)/log_base_log);
X    }
X    return(coord);
X}
X
X/* borders of plotting area */
X/* computed once on every call to do_plot */
Xboundary(scaling)
X	TBOOLEAN scaling;		/* TRUE if terminal is doing the scaling */
X{
X    register struct termentry *t = &term_tbl[term];
X    /* luecken@udel.edu modifications 
X       sizes the plot according to the presence of labels, title,... */
X    if (strlen(ylabel) == 0)
X        xleft = (t->h_char)*8;
X    else
X        xleft = (t->h_char)*10;
X    xright = (scaling ? 1 : xsize) * (t->xmax) - (t->h_char)*2 - (t->h_tic);
X    if ((strlen(xlabel) != 0) || timedate)
X        if ((*t->text_angle)(1))
X            ybot = (t->v_char)*5/2 + 1;
X        else
X            ybot = (t->v_char)*7/2 + 1;	/* allow space for time at bottom */
X    else
X        ybot = (t->v_char)*3/2 + 1;
X    if ( (strlen(title) != 0) || timedate ||
X      ((strlen(ylabel) != 0) && ((*t->text_angle)(1) == FALSE)) )
X        ytop = (scaling ? 1 : ysize) * (t->ymax) - (t->v_char)*3/2 - 1;
X    else
X        ytop = (scaling ? 1 : ysize) * (t->ymax) - (t->v_char)/2 - 1;
X    (void)(*t->text_angle)(0);
X}
X
X
Xdouble dbl_raise(x,y)
Xdouble x;
Xint y;
X{
Xregister int i;
Xdouble val;
X
X	val = 1.0;
X	for (i=0; i < abs(y); i++)
X		val *= x;
X	if (y < 0 ) return (1.0/val);
X	return(val);
X}
X
X
Xdouble make_tics(tmin,tmax,logscale,base_log)
Xdouble tmin,tmax;
XTBOOLEAN logscale;
Xdouble base_log;
X{
Xregister double xr,xnorm,tics,tic,l10;
X
X	xr = fabs(tmin-tmax);
X	
X	l10 = log10(xr);
X	if (logscale) {
X		tic = dbl_raise(base_log,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X		if (tic < 1.0)
X			tic = 1.0;
X	} else {
X		xnorm = pow(10.0,l10-(double)((l10 >= 0.0 ) ? (int)l10 : ((int)l10-1)));
X		if (xnorm <= 2)
X			tics = 0.2;
X		else if (xnorm <= 5)
X			tics = 0.5;
X		else tics = 1.0;	
X		tic = tics * dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X	}
X	return(tic);
X}
X
X
Xdo_plot(plots, pcount, min_x, max_x, min_y, max_y)
Xstruct curve_points *plots;
Xint pcount;			/* count of plots in linked list */
Xdouble min_x, max_x;
Xdouble min_y, max_y;
X{
Xregister struct termentry *t = &term_tbl[term];
Xregister int curve, xaxis_y, yaxis_x;
Xregister struct curve_points *this_plot;
Xregister double ytic, xtic;
Xregister int xl, yl;
X			/* only a Pyramid would have this many registers! */
Xdouble xtemp, ytemp;
Xstruct text_label *this_label;
Xstruct arrow_def *this_arrow;
XTBOOLEAN scaling;
X
X
X/* store these in variables global to this file */
X/* otherwise, we have to pass them around a lot */
X     x_min = min_x;
X     x_max = max_x; 
X     y_min = min_y;
X     y_max = max_y;
X
X	if (polar) {
X	    /* will possibly change x_min, x_max, y_min, y_max */
X	    polar_xform(plots,pcount);
X	}
X
X	if (y_min == VERYLARGE || y_max == -VERYLARGE ||
X	    x_min == VERYLARGE || x_max == -VERYLARGE)
X		int_error("all points undefined!", NO_CARET);
X
X/*	Apply the desired viewport offsets. */
X     if (y_min < y_max) {
X	    y_min -= boff;
X	    y_max += toff;
X	} else {
X	    y_max -= boff;
X	    y_min += toff;
X	}
X     if (x_min < x_max) {
X	    x_min -= loff;
X	    x_max += roff;
X	} else {
X	    x_max -= loff;
X	    x_min += roff;
X	}
X
X/* SETUP RANGES, SCALES AND TIC PLACES */
X    if (ytics && yticdef.type == TIC_COMPUTED) {
X	   ytic = make_tics(y_min,y_max,is_log_y,base_log_y);
X    
X	   if (autoscale_ly) {
X		  if (y_min < y_max) {
X			 y_min = ytic * floor(y_min/ytic);       
X			 y_max = ytic * ceil(y_max/ytic);
X		  }
X		  else {			/* reverse axis */
X			 y_min = ytic * ceil(y_min/ytic);       
X			 y_max = ytic * floor(y_max/ytic);
X		  }
X	   }
X    }
X
X    if (xtics && xticdef.type == TIC_COMPUTED) {
X	   xtic = make_tics(x_min,x_max,is_log_x,base_log_x);
X	   
X	   if (autoscale_lx) {
X		  if (x_min < x_max) {
X			 x_min = xtic * floor(x_min/xtic);	
X			 x_max = xtic * ceil(x_max/xtic);
X		  } else {
X			 x_min = xtic * ceil(x_min/xtic);
X			 x_max = xtic * floor(x_max/xtic);	
X		  }
X	   }
X    }
X
X/*	This used be x_max == x_min, but that caused an infinite loop once. */
X	if (fabs(x_max - x_min) < zero)
X		int_error("x_min should not equal x_max!",NO_CARET);
X	if (fabs(y_max - y_min) < zero)
X		int_error("y_min should not equal y_max!",NO_CARET);
X
X/* INITIALIZE TERMINAL */
X	if (!term_init) {
X		(*t->init)();
X		term_init = TRUE;
X	}
X	screen_ok = FALSE;
X	scaling = (*t->scale)(xsize, ysize);
X	(*t->graphics)();
X
X     /* now compute boundary for plot (xleft, xright, ytop, ybot) */
X     boundary(scaling);
X
X/* SCALE FACTORS */
X	yscale = (ytop - ybot)/(y_max - y_min);
X	xscale = (xright - xleft)/(x_max - x_min);
X	
X/* DRAW AXES */
X	(*t->linetype)(-1);	/* axis line type */
X	xaxis_y = map_y(0.0);
X	yaxis_x = map_x(0.0); 
X
X	if (xaxis_y < ybot)
X		xaxis_y = ybot;				/* save for impulse plotting */
X	else if (xaxis_y >= ytop)
X		xaxis_y = ytop ;
X	else if (xzeroaxis && !is_log_y) {
X		(*t->move)(xleft,xaxis_y);
X		(*t->vector)(xright,xaxis_y);
X	} else if (is_log_y){
X		xaxis_y = ybot;
X	}
X
X	if (yzeroaxis && !is_log_x && yaxis_x >= xleft && yaxis_x < xright ) {
X		(*t->move)(yaxis_x,ybot);
X		(*t->vector)(yaxis_x,ytop);
X	}
X
X/* DRAW TICS */
X	(*t->linetype)(-2); /* border linetype */
X
X    /* label y axis tics */
X     if (ytics) {
X	    switch (yticdef.type) {
X		   case TIC_COMPUTED: {
X 			  if (y_min < y_max)
X			    draw_ytics(ytic * floor(y_min/ytic),
X						ytic,
X						ytic * ceil(y_max/ytic));
X			  else
X			    draw_ytics(ytic * floor(y_max/ytic),
X						ytic,
X						ytic * ceil(y_min/ytic));
X
X			  break;
X		   }
X		    case TIC_MONTH:{
X			draw_month_ytics();
X			break;
X		    }
X		    case TIC_DAY: {
X			draw_day_ytics();
X			break;
X		    }
X		   case TIC_SERIES: {
X			  draw_series_ytics(yticdef.def.series.start, 
X							yticdef.def.series.incr, 
X							yticdef.def.series.end);
X			  break;
X		   }
X		   case TIC_USER: {
X			  draw_set_ytics(yticdef.def.user);
X			  break;
X		   }
X		   default: {
X			  (*t->text)();
X	  		  (void) fflush(outfile);
X			  int_error("unknown tic type in yticdef in do_plot", NO_CARET);
X			  break;		/* NOTREACHED */
X		   }
X	    }
X	}
X
X    /* label x axis tics */
X     if (xtics) {
X	    switch (xticdef.type) {
X		   case TIC_COMPUTED: {
X 			  if (x_min < x_max)
X			    draw_xtics(xtic * floor(x_min/xtic),
X						xtic,
X						xtic * ceil(x_max/xtic));
X			  else
X			    draw_xtics(xtic * floor(x_max/xtic),
X						xtic,
X						xtic * ceil(x_min/xtic));
X
X			  break;
X		   }
X		    case TIC_MONTH: {
X			draw_month_xtics();
X			break;
X		    }
X		    case TIC_DAY : {
X			draw_day_xtics();
X			break;
X		    }
X		   case TIC_SERIES: {
X			  draw_series_xtics(xticdef.def.series.start, 
X							xticdef.def.series.incr, 
X							xticdef.def.series.end);
X			  break;
X		   }
X		   case TIC_USER: {
X			  draw_set_xtics(xticdef.def.user);
X			  break;
X		   }
X		   default: {
X			  (*t->text)();
X			  (void) fflush(outfile);
X			  int_error("unknown tic type in xticdef in do_plot", NO_CARET);
X			  break;		/* NOTREACHED */
X		   }
X	    }
X	}
X
X/* DRAW PLOT BORDER */
X	(*t->linetype)(-2); /* border linetype */
X	if (draw_border) {
X		(*t->move)(xleft,ybot);
X		(*t->vector)(xright,ybot);
X		(*t->vector)(xright,ytop);
X		(*t->vector)(xleft,ytop);
X		(*t->vector)(xleft,ybot);
X	}
X
X/* PLACE YLABEL */
X	if (strlen(ylabel) > 0) {
X		int x, y;
X
X		x = ylabel_xoffset * t->h_char;
X		y = ylabel_yoffset * t->v_char;
X		if ((*t->text_angle)(1)) {
X			if ((*t->justify_text)(CENTRE)) {
X				(*t->put_text)(x+(t->v_char),
X						 y+(ytop+ybot)/2, ylabel);
X			}
X			else {
X				(*t->put_text)(x+(t->v_char),
X					       y+(ytop+ybot)/2-(t->h_char)*strlen(ylabel)/2, 
X						 ylabel);
X			}
X		}
X		else {
X			(void)(*t->justify_text)(LEFT);
X			(*t->put_text)(x,y+ytop+(t->v_char), ylabel);
X		}
X		(void)(*t->text_angle)(0);
X	}
X
X/* PLACE XLABEL */
X    if (strlen(xlabel) > 0) {
X		int x, y;
X
X		x = xlabel_xoffset * t->h_char;
X		y = xlabel_yoffset * t->v_char;
X
X    		if ((*t->justify_text)(CENTRE)) 
X			(*t->put_text)(x+(xleft+xright)/2,
X				       y+ybot-2*(t->v_char), xlabel);
X    		else
X			(*t->put_text)(x+(xleft+xright)/2 - strlen(xlabel)*(t->h_char)/2,
X    				       y+ybot-2*(t->v_char), xlabel);
X    }
X
X/* PLACE TITLE */
X    if (strlen(title) > 0) {
X		int x, y;
X
X		x = title_xoffset * t->h_char;
X		y = title_yoffset * t->v_char;
X
X    		if ((*t->justify_text)(CENTRE))
X			(*t->put_text)(x+(xleft+xright)/2,
X				       y+ytop+(t->v_char), title);
X    		else
X			(*t->put_text)(x+(xleft+xright)/2 - strlen(title)*(t->h_char)/2,
X				       y+ytop+(t->v_char), title);
X    }
X
X
X/* PLACE TIMEDATE */
X	if (timedate) {
X		int x, y;
X
X		x = time_xoffset * t->h_char;
X		y = time_yoffset * t->v_char;
X		dated = time( (time_t *) 0);
X		tdate = ctime( &dated);
X		tdate[24]='\0';
X		(void)(*t->justify_text)(LEFT);
X		if ((*t->text_angle)(1)) {
X			(void)(*t->text_angle)(0);
X			(*t->put_text)(x, y+ytop+(t->v_char), tdate);
X		}
X		else {
X			(void)(*t->text_angle)(0);
X			(*t->put_text)(x,
X						 y+ybot-3*(t->v_char), tdate);
X		}
X	}
X
X/* PLACE LABELS */
X    for (this_label = first_label; this_label!=NULL;
X			this_label=this_label->next ) {
X	     xtemp = LogScale(this_label->x, is_log_x, log_base_log_x, "label", "x");
X	     ytemp = LogScale(this_label->y, is_log_y, log_base_log_y, "label", "y");
X		if ((*t->justify_text)(this_label->pos)) {
X			(*t->put_text)(map_x(xtemp),map_y(ytemp),this_label->text);
X		}
X		else {
X			switch(this_label->pos) {
X				case  LEFT:
X					(*t->put_text)(map_x(xtemp),map_y(ytemp),
X						this_label->text);
X					break;
X				case CENTRE:
X					(*t->put_text)(map_x(xtemp)-
X						(t->h_char)*strlen(this_label->text)/2,
X						map_y(ytemp), this_label->text);
X					break;
X				case RIGHT:
X					(*t->put_text)(map_x(xtemp)-
X						(t->h_char)*strlen(this_label->text),
X						map_y(ytemp), this_label->text);
X					break;
X			}
X		 }
X	 }
X
X/* PLACE ARROWS */
X    (*t->linetype)(0);	/* arrow line type */
X    for (this_arrow = first_arrow; this_arrow!=NULL;
X	    this_arrow = this_arrow->next ) {
X	   int sx = map_x(LogScale(this_arrow->sx, is_log_x, log_base_log_x, "arrow", "x"));
X	   int sy = map_y(LogScale(this_arrow->sy, is_log_y, log_base_log_y, "arrow", "y"));
X	   int ex = map_x(LogScale(this_arrow->ex, is_log_x, log_base_log_x, "arrow", "x"));
X	   int ey = map_y(LogScale(this_arrow->ey, is_log_y, log_base_log_y, "arrow", "y"));
X	   
X	   (*t->arrow)(sx, sy, ex, ey, this_arrow->head);
X    }
X
X
X/* DRAW CURVES */
X	if (key == -1) {
X	    xl = xright  - (t->h_tic) - (t->h_char)*5;
X	    yl = ytop - (t->v_tic) - (t->v_char);
X	}
X	if (key == 1) {
X	    xl = map_x( LogScale(key_x, is_log_x, log_base_log_x, "key", "x") );
X	    yl = map_y( LogScale(key_y, is_log_y, log_base_log_y, "key", "y") );
X	}
X
X	this_plot = plots;
X	for (curve = 0; curve < pcount; this_plot = this_plot->next_cp, curve++) {
X		int oldkey = key;
X
X		(*t->linetype)(this_plot->line_type);
X
X		if (this_plot->title && !*this_plot->title) {
X		    key = 0;
X		} else {
X		if (key != 0 && this_plot->title) {
X			if ((*t->justify_text)(RIGHT)) {
X				(*t->put_text)(xl,
X					yl,this_plot->title);
X			}
X			else {
X			    if (inrange(xl-(t->h_char)*strlen(this_plot->title), 
X						 xleft, xright))
X				 (*t->put_text)(xl-(t->h_char)*strlen(this_plot->title),
X							 yl,this_plot->title);
X			}
X		}
X		}
X
X		switch(this_plot->plot_style) {
X		    case IMPULSES: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->move)(xl+(t->h_char),yl);
X				  (*t->vector)(xl+4*(t->h_char),yl);
X			   }
X			   plot_impulses(this_plot, yaxis_x, xaxis_y);
X			   break;
X		    }
X		    case LINES: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->move)(xl+(int)(t->h_char),yl);
X				  (*t->vector)(xl+(int)(4*(t->h_char)),yl);
X			   }
X			   plot_lines(this_plot);
X			   break;
X		    }
X/* JG */	    case STEPS: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->move)(xl+(int)(t->h_char),yl);
X				  (*t->vector)(xl+(int)(4*(t->h_char)),yl);
X			   }
X			   plot_steps(this_plot);
X			   break;
X		    }
X		    case POINTSTYLE: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->point)(xl+2*(t->h_char),yl,
X						    this_plot->point_type);
X			   }
X			   plot_points(this_plot);
X			   break;
X		    }
X		    case LINESPOINTS: {
X			   /* put lines */
X			   if (key != 0 && this_plot->title) {
X				  (*t->move)(xl+(t->h_char),yl);
X				  (*t->vector)(xl+4*(t->h_char),yl);
X			   }
X			   plot_lines(this_plot);
X
X			   /* put points */
X			   if (key != 0 && this_plot->title) {
X				  (*t->point)(xl+2*(t->h_char),yl,
X						    this_plot->point_type);
X			   }
X			   plot_points(this_plot);
X			   break;
X		    }
X		    case DOTS: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->point)(xl+2*(t->h_char),yl, -1);
X			   }
X			   plot_dots(this_plot);
X			   break;
X		    }
X		    case ERRORBARS: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->point)(xl+2*(t->h_char),yl,
X						    this_plot->point_type);
X			   }
X			   plot_points(this_plot);
X
X			   /* for functions, just like POINTSTYLE */
X			   if (this_plot->plot_type == DATA) {
X				  if (key != 0 && this_plot->title) {
X					 (*t->move)(xl+(t->h_char),yl);
X					 (*t->vector)(xl+4*(t->h_char),yl);
X					 (*t->move)(xl+(t->h_char),yl+ERRORBARTIC);
X					 (*t->vector)(xl+(t->h_char),yl-ERRORBARTIC);
X					 (*t->move)(xl+4*(t->h_char),yl+ERRORBARTIC);
X					 (*t->vector)(xl+4*(t->h_char),yl-ERRORBARTIC);
X				  }
X				  plot_bars(this_plot);
X			   }
X			   break;
X		    }
X			case BOXERROR: {
X			   if (this_plot->plot_type == DATA) {
X				  if (key != 0 && this_plot->title) {
X					 (*t->move)(xl+(t->h_char),yl+ERRORBARTIC);
X					 (*t->vector)(xl+(t->h_char),yl-ERRORBARTIC);
X					 (*t->move)(xl+4*(t->h_char),yl+ERRORBARTIC);
X					 (*t->vector)(xl+4*(t->h_char),yl-ERRORBARTIC);
X				  }
X				  plot_bars(this_plot);
X			   }
X			}
X			/* no break */
X		    case BOXES: {
X			   if (key != 0 && this_plot->title) {
X				  (*t->move)(xl+(t->h_char),yl);
X				  (*t->vector)(xl+4*(t->h_char),yl);
X			   }
X			   plot_boxes(this_plot,xaxis_y);
X			   break;
X		    }
X
X		}
X		if (key && this_plot->title) {
X		    yl = yl - (t->v_char);
X		}
X		key = oldkey;
X	}
X	(*t->text)();
X	(void) fflush(outfile);
X}
X
X/* plot_impulses:
X * Plot the curves in IMPULSES style
X */
Xvoid
Xplot_impulses(plot, yaxis_x, xaxis_y)
X	struct curve_points *plot;
X	int yaxis_x, xaxis_y;
X{
X    int i;
X    int x,y;
X    struct termentry *t = &term_tbl[term];
X
X    for (i = 0; i < plot->p_count; i++) {
X	   switch (plot->points[i].type) {
X		  case INRANGE: {
X			 x = map_x(plot->points[i].x);
X			 y = map_y(plot->points[i].y);
X			 break;
X		  }
X		  case OUTRANGE: {
X			 if (!inrange(plot->points[i].x, x_min,x_max))
X			   continue;
X			 x = map_x(plot->points[i].x);
X			 if ((y_min < y_max 
X				 && plot->points[i].y < y_min)
X				|| (y_max < y_min 
X				    && plot->points[i].y > y_min))
X			   y = map_y(y_min);
X			 if ((y_min < y_max 
X				 && plot->points[i].y > y_max)
X				|| (y_max<y_min 
X				    && plot->points[i].y < y_max))
X			   y = map_y(y_max);
X			 break;
X		  }
X		  default:		/* just a safety */
X		  case UNDEFINED: {
X			 continue;
X		  }
X	   }
X				    
X	   if (polar)
X	      (*t->move)(yaxis_x,xaxis_y);
X	   else
X	      (*t->move)(x,xaxis_y);
X	   (*t->vector)(x,y);
X    }
X
X}
X
X/* plot_lines:
X * Plot the curves in LINES style
X */
Xvoid
Xplot_lines(plot)
X	struct curve_points *plot;
X{
X    int i;				/* point index */
X    int x,y;				/* point in terminal coordinates */
X    struct termentry *t = &term_tbl[term];
X    enum coord_type prev = UNDEFINED; /* type of previous point */
X    double ex, ey;			/* an edge point */
X    double lx[2], ly[2];		/* two edge points */
X
X    for (i = 0; i < plot->p_count; i++) {
X	   switch (plot->points[i].type) {
X		  case INRANGE: {
X			 x = map_x(plot->points[i].x);
X			 y = map_y(plot->points[i].y);
X
X			 if (prev == INRANGE) {
X				(*t->vector)(x,y);
X			 } else if (prev == OUTRANGE) {
X				/* from outrange to inrange */
X				if (!clip_lines1) {
X				    (*t->move)(x,y);
X				} else {
X				    edge_intersect(plot->points, i, &ex, &ey);
X				    (*t->move)(map_x(ex), map_y(ey));
X				    (*t->vector)(x,y);
X				}
X			 } else {		/* prev == UNDEFINED */
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X			 }
X				    
X			 break;
X		  }
X		  case OUTRANGE: {
X			 if (prev == INRANGE) {
X				/* from inrange to outrange */
X				if (clip_lines1) {
X				    edge_intersect(plot->points, i, &ex, &ey);
X				    (*t->vector)(map_x(ex), map_y(ey));
X				}
X			 } else if (prev == OUTRANGE) {
X				/* from outrange to outrange */
X				if (clip_lines2) {
X				    if (two_edge_intersect(plot->points, i, lx, ly)) {
X					   (*t->move)(map_x(lx[0]), map_y(ly[0]));
X					   (*t->vector)(map_x(lx[1]), map_y(ly[1]));
X				    }
X				}
X			 }
X			 break;
X		  }
X		  default:		/* just a safety */
X		  case UNDEFINED: {
X			 break;
X		  }
X	   }
X	   prev = plot->points[i].type;
X    }
X}
X
X/* XXX - JG  */
X/* plot_steps:				
X * Plot the curves in STEPS style
X */
Xvoid
Xplot_steps(plot)
Xstruct curve_points *plot;
X{
X    int i;				/* point index */
X    int x,y;				/* point in terminal coordinates */
X    struct termentry *t = &term_tbl[term];
X    enum coord_type prev = UNDEFINED;	/* type of previous point */
X    double ex, ey;			/* an edge point */
X    double lx[2], ly[2];		/* two edge points */
X    int xprev, yprev;			/* previous point coordinates */
X
X    for (i = 0; i < plot->p_count; i++) {
X	   switch (plot->points[i].type) {
X		  case INRANGE: {
X			 x = map_x(plot->points[i].x);
X			 y = map_y(plot->points[i].y);
X
X			 if (prev == INRANGE) {
X				(*t->vector)(x,yprev);
X				(*t->vector)(x,y);
X			 } else if (prev == OUTRANGE) {
X				/* from outrange to inrange */
X				if (!clip_lines1) {
X				    (*t->move)(x,y);
X				} else {		/* find edge intersection */
X				    edge_intersect_steps(plot->points, i, &ex, &ey);
X				    (*t->move)(map_x(ex), map_y(ey));
X				    (*t->vector)(x,map_y(ey));
X				    (*t->vector)(x,y);
X				}
X			 } else {		/* prev == UNDEFINED */
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X			 }
X			 break;
X		  }
X		  case OUTRANGE: {
X			 if (prev == INRANGE) {
X				/* from inrange to outrange */
X				if (clip_lines1) {
X				    edge_intersect_steps(plot->points, i, &ex, &ey);
X				    (*t->vector)(map_x(ex), yprev);
X				    (*t->vector)(map_x(ex), map_y(ey));
X				}
X			 } else if (prev == OUTRANGE) {
X				/* from outrange to outrange */
X				if (clip_lines2) {
X				    if (two_edge_intersect_steps(plot->points, i, lx, ly)) {
X					   (*t->move)(map_x(lx[0]), map_y(ly[0]));
X					   (*t->vector)(map_x(lx[1]), map_y(ly[0]));
X					   (*t->vector)(map_x(lx[1]), map_y(ly[1]));
X				    }
X				}
X			 }
X			 break;
X		  }
X		  default:		/* just a safety */
X		  case UNDEFINED: {
X			 break;
X		  }
X	   }
X	   prev  = plot->points[i].type;
X	   xprev = x;
X	   yprev = y;
X    }
X}
X
X/* plot_bars:
X * Plot the curves in ERRORBARS style
X *  we just plot the bars; the points are plotted in plot_points
X */
Xvoid
Xplot_bars(plot)
X	struct curve_points *plot;
X{
X    int i;				/* point index */
X    struct termentry *t = &term_tbl[term];
X    double x;				/* position of the bar */
X    double ylow, yhigh;		/* the ends of the bars */
X    unsigned int xM, ylowM, yhighM; /* the mapped version of above */
X    TBOOLEAN low_inrange, high_inrange;
X    int tic = ERRORBARTIC;
X    
X    for (i = 0; i < plot->p_count; i++) {
X	   /* undefined points don't count */
X	   if (plot->points[i].type == UNDEFINED)
X		continue;
X
X	   /* check to see if in xrange */
X	   x = plot->points[i].x;
X	   if (! inrange(x, x_min, x_max))
X		continue;
X	   xM = map_x(x);
X
X	   /* find low and high points of bar, and check yrange */
X	   yhigh = plot->points[i].yhigh;
X	   ylow = plot->points[i].ylow;
X
X	   high_inrange = inrange(yhigh, y_min,y_max);
X	   low_inrange = inrange(ylow, y_min,y_max);
X
X	   /* compute the plot position of yhigh */
X	   if (high_inrange)
X		yhighM = map_y(yhigh);
X	   else if (samesign(yhigh-y_max, y_max-y_min))
X		yhighM = map_y(y_max);
X	   else
X		yhighM = map_y(y_min);
X	   
X	   /* compute the plot position of ylow */
X	   if (low_inrange)
X		ylowM = map_y(ylow);
X	   else if (samesign(ylow-y_max, y_max-y_min))
X		ylowM = map_y(y_max);
X	   else
X		ylowM = map_y(y_min);
X
X	   if (!high_inrange && !low_inrange && ylowM == yhighM)
X		/* both out of range on the same side */
X		  continue;
X
X	   /* by here everything has been mapped */
X	   (*t->move)(xM, ylowM);
X	   (*t->vector)(xM, yhighM); /* draw the main bar */
X	   (*t->move)(xM-tic, ylowM); /* draw the bottom tic */
X	   (*t->vector)(xM+tic, ylowM);
X	   (*t->move)(xM-tic, yhighM); /* draw the top tic */
X	   (*t->vector)(xM+tic, yhighM);
X    }
X}
X
X/* plot_boxes:
X * Plot the curves in BOXES style
X */
Xvoid
Xplot_boxes(plot,xaxis_y)
X	struct curve_points *plot;
X	int xaxis_y;
X{
X    int i;				/* point index */
X    int xl,xr,yt;			/* point in terminal coordinates */
X	double dxl,dxr,dyt;
X    struct termentry *t = &term_tbl[term];
X    enum coord_type prev = UNDEFINED; /* type of previous point */
X
X    for (i = 0; i < plot->p_count; i++) {
X	   switch (plot->points[i].type) {
X		  case OUTRANGE:
X		  case INRANGE: {
X			if (plot->points[i].z<0.0) {
X			   if (boxwidth<0.0) {
X					/* calculate width */
X					if (prev!=UNDEFINED)
X						dxl = (plot->points[i-1].x - plot->points[i].x)/2.0;
X					else
X						dxl = 0.0;
X					if (i < plot->p_count-1) {
X						if (plot->points[i+1].type!=UNDEFINED)
X							dxr = (plot->points[i+1].x - plot->points[i].x)/2.0;
X						else
X							dxr = -dxl;
X					}
X					else {
X						dxr = -dxl;
X					}
X					if (prev==UNDEFINED)
X						dxl = -dxr;
X				}
X				else {
X					dxr = boxwidth/2.0;
X					dxl = -dxr;
X				}
X			}
X			else {
X				dxr = plot->points[i].z/2.0;
X				dxl = -dxr;
X			}
X
X			dxl= plot->points[i].x+dxl;
X			dxr= plot->points[i].x+dxr;
X			dyt= plot->points[i].y;
X
X			/* clip to border */
X			if ((y_min < y_max  && dyt < y_min)
X				|| (y_max < y_min  && dyt > y_min))
X			   dyt = y_min;
X			if ((y_min < y_max  && dyt > y_max)
X				|| (y_max<y_min  && dyt < y_max))
X			   dyt = y_max;
X			if ((x_min < x_max  && dxr < x_min)
X				|| (x_max < x_min  && dxr > x_min))
X			   dxr = x_min;
X			if ((x_min < x_max  && dxr > x_max)
X				|| (x_max<x_min  && dxr < x_max))
X			   dxr = x_max;
X			if ((x_min < x_max  && dxl < x_min)
X				|| (x_max < x_min  && dxl > x_min))
X			   dxl = x_min;
X			if ((x_min < x_max  && dxl > x_max)
X				|| (x_max<x_min  && dxl < x_max))
X			   dxl = x_max;
X
X			xl= map_x(dxl);
X			xr= map_x(dxr);
X			yt = map_y(dyt);
X
X			(*t->move)(xl,xaxis_y);
X			(*t->vector)(xl,yt);
X			(*t->vector)(xr,yt);
X			(*t->vector)(xr,xaxis_y);
X			(*t->vector)(xl,xaxis_y);
X			break;
X		  }
X		  default:		/* just a safety */
X		  case UNDEFINED: {
X			 break;
X		  }
X	   }
X	   prev = plot->points[i].type;
X    }
X}
X
X/* plot_points:
X * Plot the curves in POINTSTYLE style
X */
Xvoid
Xplot_points(plot)
X	struct curve_points *plot;
X{
X    int i;
X    int x,y;
X    struct termentry *t = &term_tbl[term];
X
X    for (i = 0; i < plot->p_count; i++) {
X	   if (plot->points[i].type == INRANGE) {
X		  x = map_x(plot->points[i].x);
X		  y = map_y(plot->points[i].y);
X		  /* do clipping if necessary */
X		  if (!clip_points ||
X			 (   x >= xleft + t->h_tic  && y >= ybot + t->v_tic 
X			  && x <= xright - t->h_tic && y <= ytop - t->v_tic))
X		    (*t->point)(x,y, plot->point_type);
X	   }
X    }
X}
X
X/* plot_dots:
X * Plot the curves in DOTS style
X */
Xvoid
Xplot_dots(plot)
X	struct curve_points *plot;
X{
X    int i;
X    int x,y;
X    struct termentry *t = &term_tbl[term];
X
X    for (i = 0; i < plot->p_count; i++) {
X	   if (plot->points[i].type == INRANGE) {
X		  x = map_x(plot->points[i].x);
X		  y = map_y(plot->points[i].y);
X		  /* point type -1 is a dot */
X		  (*t->point)(x,y, -1);
X	   }
X    }
X}
X
X/* single edge intersection algorithm */
X/* Given two points, one inside and one outside the plot, return
X * the point where an edge of the plot intersects the line segment defined 
X * by the two points.
X */
Xvoid
Xedge_intersect(points, i, ex, ey)
X	struct coordinate GPHUGE *points; /* the points array */
X	int i;				/* line segment from point i-1 to point i */
X	double *ex, *ey;		/* the point where it crosses an edge */
X{
X    /* global x_min, x_max, y_min, x_max */
X    double ax = points[i-1].x;
X    double ay = points[i-1].y;
X    double bx = points[i].x;
X    double by = points[i].y;
X    double x, y;			/* possible intersection point */
X
X    if (by == ay) {
X	   /* horizontal line */
X	   /* assume inrange(by, y_min, y_max) */
X	   *ey = by;		/* == ay */
X
X	   if (inrange(x_max, ax, bx))
X		*ex = x_max;
X	   else if (inrange(x_min, ax, bx))
X		*ex = x_min;
X	   else {
X		(*term_tbl[term].text)();
X	    (void) fflush(outfile);
X		int_error("error in edge_intersect", NO_CARET);
X	   }
X	   return;
X    } else if (bx == ax) {
X	   /* vertical line */
X	   /* assume inrange(bx, x_min, x_max) */
X	   *ex = bx;		/* == ax */
X
X	   if (inrange(y_max, ay, by))
X		*ey = y_max;
X	   else if (inrange(y_min, ay, by))
X		*ey = y_min;
X	   else {
X		(*term_tbl[term].text)();
X	    (void) fflush(outfile);
X		int_error("error in edge_intersect", NO_CARET);
X	   }
X	   return;
X    }
X
X    /* slanted line of some kind */
X
X    /* does it intersect y_min edge */
X    if (inrange(y_min, ay, by) && y_min != ay && y_min != by) {
X	   x = ax + (y_min-ay) * ((bx-ax) / (by-ay));
X	   if (inrange(x, x_min, x_max)) {
X		  *ex = x;
X		  *ey = y_min;
X		  return;			/* yes */
X	   }
X    }
X    
X    /* does it intersect y_max edge */
X    if (inrange(y_max, ay, by) && y_max != ay && y_max != by) {
X	   x = ax + (y_max-ay) * ((bx-ax) / (by-ay));
X	   if (inrange(x, x_min, x_max)) {
X		  *ex = x;
X		  *ey = y_max;
X		  return;			/* yes */
X	   }
X    }
X
X    /* does it intersect x_min edge */
X    if (inrange(x_min, ax, bx) && x_min != ax && x_min != bx) {
X	   y = ay + (x_min-ax) * ((by-ay) / (bx-ax));
X	   if (inrange(y, y_min, y_max)) {
X		  *ex = x_min;
X		  *ey = y;
X		  return;
X	   }
X    }
X
X    /* does it intersect x_max edge */
X    if (inrange(x_max, ax, bx) && x_max != ax && x_max != bx) {
X	   y = ay + (x_max-ax) * ((by-ay) / (bx-ax));
X	   if (inrange(y, y_min, y_max)) {
X		  *ex = x_max;
X		  *ey = y;
X		  return;
X	   }
X    }
X
X    /* It is possible for one or two of the [ab][xy] values to be -VERYLARGE.
X	* If ax=bx=-VERYLARGE or ay=by=-VERYLARGE we have already returned 
X	* FALSE above. Otherwise we fall through all the tests above. 
X	* If two are -VERYLARGE, it is ax=ay=-VERYLARGE or bx=by=-VERYLARGE 
X	* since either a or b must be INRANGE. 
X	* Note that for ax=ay=-VERYLARGE or bx=by=-VERYLARGE we can do nothing.
X	* Handle them carefully here. As yet we have no way for them to be 
X	* +VERYLARGE.
X	*/
X    if (ax == -VERYLARGE) {
X	   if (ay != -VERYLARGE) {
X		  *ex = min(x_min, x_max);
X		  *ey = by;
X		  return;
X	   }
X    } else if (bx == -VERYLARGE) {
X	   if (by != -VERYLARGE) {
X		  *ex = min(x_min, x_max);
X		  *ey = ay;
X		  return;
X	   }
X    } else if (ay == -VERYLARGE) {
X	   /* note we know ax != -VERYLARGE */
X	   *ex = bx;
X	   *ey = min(y_min, y_max);
X	   return;
X    } else if (by == -VERYLARGE) {
X	   /* note we know bx != -VERYLARGE */
X	   *ex = ax;
X	   *ey = min(y_min, y_max);
X	   return;
X    }
X
X    /* If we reach here, then either one point is (-VERYLARGE,-VERYLARGE), 
X	* or the inrange point is on the edge, and
X     * the line segment from the outrange point does not cross any 
X	* other edges to get there. In either case, we return the inrange 
X	* point as the 'edge' intersection point. This will basically draw
X	* line.
X	*/
X    if (points[i].type == INRANGE) {
X	   *ex = bx; 
X	   *ey = by;
X    } else {
X	   *ex = ax; 
X	   *ey = ay;
X    }
X    return;
X}
X
X/* XXX - JG  */
X/* single edge intersection algorithm for "steps" curves */
X/* 
X * Given two points, one inside and one outside the plot, return
X * the point where an edge of the plot intersects the line segments
X * forming the step between the two points. 
X *
X * Recall that if P1 = (x1,y1) and P2 = (x2,y2), the step from  
X * P1 to P2 is drawn as two line segments: (x1,y1)->(x2,y1) and 
X * (x2,y1)->(x2,y2). 
X */
Xvoid
Xedge_intersect_steps(points, i, ex, ey)
X	struct coordinate *points; /* the points array */
X	int i;				/* line segment from point i-1 to point i */
X	double *ex, *ey;		/* the point where it crosses an edge */
X{
X    /* global x_min, x_max, y_min, x_max */
X    double ax = points[i-1].x;
X    double ay = points[i-1].y;
X    double bx = points[i].x;
X    double by = points[i].y;
X
X    if (points[i].type == INRANGE) {	/* from OUTRANGE to INRANG */
X	    if (inrange(ay,y_min,y_max)) {
X		*ey = ay;
X		if (ax > x_max)
X			*ex = x_max;
X		else			/* x < x_min */
X			*ex = x_min;
X	    } else {
X	    	*ex = bx;
X		if (ay > y_max)     
X			*ey = y_max;
X		else			/* y < y_min */
X			*ey = y_min;
X	    }
X    } else {				/* from INRANGE to OUTRANGE */
X	    if (inrange(bx,x_min,x_max)) {
X		*ex = bx;
X		if (by > y_max)
X			*ey = y_max;
X		else			/* y < y_min */
X			*ey = y_min;
X	    } else {
X	    	*ey = ay;
X		if (bx > x_max)     
X			*ex = x_max;
X		else			/* x < x_min */
X			*ex = x_min;
X	    }
X    }
X    return;
X}
X
X/* XXX - JG  */
X/* double edge intersection algorithm for "steps" plot */
X/* Given two points, both outside the plot, return the points where an 
X * edge of the plot intersects the line segments forming a step 
X * by the two points. There may be zero, one, two, or an infinite number
X * of intersection points. (One means an intersection at a corner, infinite
X * means overlaying the edge itself). We return FALSE when there is nothing
X * to draw (zero intersections), and TRUE when there is something to 
X * draw (the one-point case is a degenerate of the two-point case and we do 
X * not distinguish it - we draw it anyway).
X *
X * Recall that if P1 = (x1,y1) and P2 = (x2,y2), the step from  
X * P1 to P2 is drawn as two line segments: (x1,y1)->(x2,y1) and 
X * (x2,y1)->(x2,y2). 
X */
XTBOOLEAN				/* any intersection? */
Xtwo_edge_intersect_steps(points, i, lx, ly)
X	struct coordinate *points; /* the points array */
X	int i;				/* line segment from point i-1 to point i */
X	double *lx, *ly;		/* lx[2], ly[2]: points where it crosses edges */
X{
X    /* global x_min, x_max, y_min, x_max */
X    double ax = points[i-1].x;
X    double ay = points[i-1].y;
X    double bx = points[i].x;
X    double by = points[i].y;
X
X    if ( max(ax,bx) < x_min || min(ax,bx) > x_max || 
X         max(ay,by) < y_min || min(ay,by) > y_max ||
X         ( (ay  > y_max || ay < y_min)            &&
X           (bx  > x_max || bx < x_min)  ) ) {
X	return(FALSE);				
X    } else if (inrange(ay,y_min,y_max) && inrange(bx,x_min,x_max)) {	/* corner of step inside plotspace */
X    	*ly++ = ay;
X	if (ax < x_min) 
X		*lx++ = x_min;
X	else 
X		*lx++ = x_max;
X
X	*lx++ = bx;
X	if (by < x_min) 
X		*ly++ = y_min;
X	else 
X		*ly++ = y_max;
X
X	return(TRUE);
X    } else if (inrange(ay,y_min,y_max)) {	/* cross plotspace in x-direction */
X	*lx++ = x_min;
X	*ly++ = ay;
X	*lx++ = x_max;
X	*ly++ = ay;
X	return(TRUE);
X    } else if (inrange(ax,x_min,x_max)) {	/* cross plotspace in y-direction */
X	*lx++ = bx;
X	*ly++ = y_min;
X	*lx++ = bx;
X	*ly++ = y_max;
X	return(TRUE);
X    } else
X	return(FALSE);
X}
X
X/* double edge intersection algorithm */
X/* Given two points, both outside the plot, return
X * the points where an edge of the plot intersects the line segment defined 
X * by the two points. There may be zero, one, two, or an infinite number
X * of intersection points. (One means an intersection at a corner, infinite
X * means overlaying the edge itself). We return FALSE when there is nothing
X * to draw (zero intersections), and TRUE when there is something to 
X * draw (the one-point case is a degenerate of the two-point case and we do 
X * not distinguish it - we draw it anyway).
X */
XTBOOLEAN				/* any intersection? */
Xtwo_edge_intersect(points, i, lx, ly)
X	struct coordinate GPHUGE *points; /* the points array */
X	int i;				/* line segment from point i-1 to point i */
X	double *lx, *ly;		/* lx[2], ly[2]: points where it crosses edges */
X{
X    /* global x_min, x_max, y_min, x_max */
X    double ax = points[i-1].x;
X    double ay = points[i-1].y;
X    double bx = points[i].x;
X    double by = points[i].y;
X    double x, y;			/* possible intersection point */
X    TBOOLEAN intersect = FALSE;
X
X    if (by == ay) {
X	   /* horizontal line */
X	   /* y coord must be in range, and line must span both x_min and x_max */
X	   /* note that spanning x_min implies spanning x_max */
X	   if (inrange(by, y_min, y_max) && inrange(x_min, ax, bx)) {
X		  *lx++ = x_min;
X		  *ly++ = by;
X		  *lx++ = x_max;
X		  *ly++ = by;
X		  return(TRUE);
X	   } else
X		return(FALSE);
X    } else if (bx == ax) {
X	   /* vertical line */
X	   /* x coord must be in range, and line must span both y_min and y_max */
X	   /* note that spanning y_min implies spanning y_max */
X	   if (inrange(bx, x_min, x_max) && inrange(y_min, ay, by)) {
X		  *lx++ = bx;
X		  *ly++ = y_min;
X		  *lx++ = bx;
X		  *ly++ = y_max;
X		  return(TRUE);
X	   } else
X		return(FALSE);
X    }
X
X    /* slanted line of some kind */
X    /* there can be only zero or two intersections below */
X
X    /* does it intersect y_min edge */
X    if (inrange(y_min, ay, by)) {
X	   x = ax + (y_min-ay) * ((bx-ax) / (by-ay));
X	   if (inrange(x, x_min, x_max)) {
X		  *lx++ = x;
X		  *ly++ = y_min;
X		  intersect = TRUE;
X	   }
X    }
X    
X    /* does it intersect y_max edge */
X    if (inrange(y_max, ay, by)) {
X	   x = ax + (y_max-ay) * ((bx-ax) / (by-ay));
X	   if (inrange(x, x_min, x_max)) {
X		  *lx++ = x;
X		  *ly++ = y_max;
X		  intersect = TRUE;
X	   }
X    }
X
X    /* does it intersect x_min edge */
X    if (inrange(x_min, ax, bx)) {
X	   y = ay + (x_min-ax) * ((by-ay) / (bx-ax));
X	   if (inrange(y, y_min, y_max)) {
X		  *lx++ = x_min;
X		  *ly++ = y;
X		  intersect = TRUE;
X	   }
X    }
X
X    /* does it intersect x_max edge */
X    if (inrange(x_max, ax, bx)) {
X	   y = ay + (x_max-ax) * ((by-ay) / (bx-ax));
X	   if (inrange(y, y_min, y_max)) {
X		  *lx++ = x_max;
X		  *ly++ = y;
X		  intersect = TRUE;
X	   }
X    }
X
X    if (intersect)
X	 return(TRUE);
X
X    /* It is possible for one or more of the [ab][xy] values to be -VERYLARGE.
X	* If ax=bx=-VERYLARGE or ay=by=-VERYLARGE we have already returned
X	* FALSE above.
X	* Note that for ax=ay=-VERYLARGE or bx=by=-VERYLARGE we can do nothing.
X	* Otherwise we fall through all the tests above. 
X	* Handle them carefully here. As yet we have no way for them to be +VERYLARGE.
X	*/
X    if (ax == -VERYLARGE) {
X	   if (ay != -VERYLARGE
X		  && inrange(by, y_min, y_max) && inrange(x_max, ax, bx)) {
X		  *lx++ = x_min;
X		  *ly = by;
X		  *lx++ = x_max;
X		  *ly = by;
X		  intersect = TRUE;
X	   }
X    } else if (bx == -VERYLARGE) {
X	   if (by != -VERYLARGE
X		  && inrange(ay, y_min, y_max) && inrange(x_max, ax, bx)) {
X		  *lx++ = x_min;
X		  *ly = ay;
X		  *lx++ = x_max;
X		  *ly = ay;
X		  intersect = TRUE;
X	   }
X    } else if (ay == -VERYLARGE) {
X	   /* note we know ax != -VERYLARGE */
X	   if (inrange(bx, x_min, x_max) && inrange(y_max, ay, by)) {
X		  *lx++ = bx;
X		  *ly = y_min;
X		  *lx++ = bx;
X		  *ly = y_max;
X		  intersect = TRUE;
X	   }
X    } else if (by == -VERYLARGE) {
X	   /* note we know bx != -VERYLARGE */
X	   if (inrange(ax, x_min, x_max) && inrange(y_max, ay, by)) {
X		  *lx++ = ax;
X		  *ly = y_min;
X		  *lx++ = ax;
X		  *ly = y_max;
X		  intersect = TRUE;
X	   }
X    }
X
X    return(intersect);
X}
X
X/* Polar transform of all curves */
X/* Original code by John Campbell (CAMPBELL@NAUVAX.bitnet) */
Xpolar_xform (plots, pcount)
X	struct curve_points *plots;
X	int pcount;			/* count of curves in plots array */
X{
X     struct curve_points *this_plot;
X     int curve;			/* loop var, for curves */
X     register int i, p_cnt;	/* loop/limit var, for points */
X     struct coordinate GPHUGE *pnts;	/* abbrev. for points array */
X	double x, y;			/* new cartesian value */
X	TBOOLEAN anydefined = FALSE;
X	double d2r;
X
X	if(angles_format == ANGLES_DEGREES){
X		d2r = DEG2RAD;
X	} else {
X		d2r = 1.0;
X	}
X
X/*
X	Cycle through all the plots converting polar to rectangular.
X     If autoscaling, adjust max and mins. Ignore previous values.
X	If not autoscaling, use the yrange for both x and y ranges.
X*/
X	if (autoscale_ly) {
X	    x_min = VERYLARGE;
X	    y_min = VERYLARGE;
X	    x_max = -VERYLARGE;
X	    y_max = -VERYLARGE;
X	    autoscale_lx = TRUE;
X	} else {
X	    x_min = y_min;
X	    x_max = y_max;
X	}
X    
X	this_plot = plots;
X	for (curve = 0; curve < pcount; this_plot = this_plot->next_cp, curve++) {
X		p_cnt = this_plot->p_count;
X        pnts = &(this_plot->points[0]);
X
X	/*	Convert to cartesian all points in this curve. */
X		for (i = 0; i < p_cnt; i++) {
X			if (pnts[i].type != UNDEFINED) {
X			     anydefined = TRUE;
X			     /* modify points to reset origin and from degrees */
X			     pnts[i].y -= rmin;
X			     pnts[i].x *= d2r;
X			     /* convert to cartesian coordinates */
X				x = pnts[i].y*cos(pnts[i].x);
X				y = pnts[i].y*sin(pnts[i].x);
X				pnts[i].x = x;
X				pnts[i].y = y;
X				if (autoscale_ly) {
X				    if (x_min > x) x_min = x;
X				    if (x_max < x) x_max = x;
X				    if (y_min > y) y_min = y;
X				    if (y_max < y) y_max = y;
X				    pnts[i].type = INRANGE;
X				} else if(inrange(x, x_min, x_max) && inrange(y, y_min, y_max))
X				  pnts[i].type = INRANGE;
X				else
X				  pnts[i].type = OUTRANGE;
X			}
X		}	
X	}
X
X	if (autoscale_lx && anydefined && fabs(x_max - x_min) < zero) {
X	    /* This happens at least for the plot of 1/cos(x) (vertical line). */
X	    fprintf(stderr, "Warning: empty x range [%g:%g], ", x_min,x_max);
X	    if (x_min == 0.0) {
X		   x_min = -1; 
X		   x_max = 1;
X	    } else {
X		   x_min *= 0.9;
X		   x_max *= 1.1;
X	    }
X	    fprintf(stderr, "adjusting to [%g:%g]\n", x_min,x_max);
X	}
X	if (autoscale_ly && anydefined && fabs(y_max - y_min) < zero) {
X	    /* This happens at least for the plot of 1/sin(x) (horiz. line). */
X	    fprintf(stderr, "Warning: empty y range [%g:%g], ", y_min, y_max);
X	    if (y_min == 0.0) {
X		   y_min = -1;
X		   y_max = 1;
X	    } else {
X		   y_min *= 0.9;
X		   y_max *= 1.1;
X	    }
X	    fprintf(stderr, "adjusting to [%g:%g]\n", y_min, y_max);
X	}
X}
X
X/* DRAW_YTICS: draw a regular tic series, y axis */
Xdraw_ytics(start, incr, end)
X		double start, incr, end; /* tic series definition */
X		/* assume start < end, incr > 0 */
X{
X	double ticplace;
X	int ltic;			/* for mini log tics */
X	double lticplace;	/* for mini log tics */
X	double ticmin, ticmax;	/* for checking if tic is almost inrange */
X
X	if (end == VERYLARGE)            /* for user-def series */
X		end = max(y_min,y_max);
X
X	/* limit to right side of plot */
X	end = min(end, max(y_min,y_max));
X
X	/* to allow for rounding errors */
X	ticmin = min(y_min,y_max) - SIGNIF*incr;
X	ticmax = max(y_min,y_max) + SIGNIF*incr;
X	end = end + SIGNIF*incr; 
X
X	for (ticplace = start; ticplace <= end; ticplace +=incr) {
X		if ( inrange(ticplace,ticmin,ticmax) )
X			ytick(ticplace, yformat, incr, 1.0);
X		if (is_log_y && incr == 1.0) {
X			/* add mini-ticks to log scale ticmarks */
X		    int lstart, linc;
X		    if ((end - start) >= 10)
X		    {
X			lstart = 10; /* No little ticks */
X			linc = 5;
X		    }
X		    else if((end - start) >= 5)
X		    {
X			lstart = 2; /* 4 per decade */
X			linc = 3;
X		    }
X		    else
X		    {
X			lstart = 2; /* 9 per decade */
X			linc = 1;
X		    }
X		    for (ltic = lstart; ltic < (int)base_log_y; ltic += linc) {
X				lticplace = ticplace+log((double)ltic)/log_base_log_y;
X				if ( inrange(lticplace,ticmin,ticmax) )
X					ytick(lticplace, "\0", incr, 0.5);
X		    }
X		}
X	}
X}
X
X/* DRAW_XTICS: draw a regular tic series, x axis */
Xdraw_xtics(start, incr, end)
X		double start, incr, end; /* tic series definition */
X		/* assume start < end, incr > 0 */
X{
X	double ticplace;
X	int ltic;			/* for mini log tics */
X	double lticplace;	/* for mini log tics */
X	double ticmin, ticmax;	/* for checking if tic is almost inrange */
X
X	if (end == VERYLARGE)            /* for user-def series */
X		end = max(x_min,x_max);
X
X	/* limit to right side of plot */
X	end = min(end, max(x_min,x_max));
X
X	/* to allow for rounding errors */
X	ticmin = min(x_min,x_max) - SIGNIF*incr;
X	ticmax = max(x_min,x_max) + SIGNIF*incr;
X	end = end + SIGNIF*incr; 
X
X	for (ticplace = start; ticplace <= end; ticplace +=incr) {
X		if ( inrange(ticplace,ticmin,ticmax) )
X			if(!polar || ticplace == start || ticplace == end) 
X				xtick(ticplace, xformat, incr, 1.0);
X		if (is_log_x && incr == 1.0) {
X			/* add mini-ticks to log scale ticmarks */
X		    int lstart, linc;
X		    if ((end - start) >= 10)
X		    {
X			lstart = 10; /* No little ticks */
X			linc = 5;
X		    }
X		    else if((end - start) >= 5)
X		    {
X			lstart = 2; /* 4 per decade */
X			linc = 3;
X		    }
X		    else
X		    {
X			lstart = 2; /* 9 per decade */
X			linc = 1;
X		    }
X		    for (ltic = lstart; ltic < (int)base_log_x; ltic += linc) {
X				lticplace = ticplace+log((double)ltic)/log_base_log_x;
X				if ( inrange(lticplace,ticmin,ticmax) )
X					xtick(lticplace, "\0", incr, 0.5);
X			}
X		}
X	}
X}
X
X/* DRAW_SERIES_YTICS: draw a user tic series, y axis */
Xdraw_series_ytics(start, incr, end)
X		double start, incr, end; /* tic series definition */
X		/* assume start < end, incr > 0 */
X{
X	double ticplace, place;
X	double ticmin, ticmax;	/* for checking if tic is almost inrange */
X	double spacing = is_log_y ? log(incr)/log_base_log_y : incr;
X
X	if (end == VERYLARGE)
X		end = max(CheckLog(is_log_y, base_log_y, y_min),
X			  CheckLog(is_log_y, base_log_y, y_max));
X	else
X	  /* limit to right side of plot */
X	  end = min(end, max(CheckLog(is_log_y, base_log_y, y_min),
X			     CheckLog(is_log_y, base_log_y, y_max)));
X
X	/* to allow for rounding errors */
X	ticmin = min(y_min,y_max) - SIGNIF*incr;
X	ticmax = max(y_min,y_max) + SIGNIF*incr;
X	end = end + SIGNIF*incr; 
X
X	for (ticplace = start; ticplace <= end; ticplace +=incr) {
X	    place = (is_log_y ? log(ticplace)/log_base_log_y : ticplace);
X	    if ( inrange(place,ticmin,ticmax) )
X		 ytick(place, yformat, spacing, 1.0);
X	}
X}
X
X
X/* DRAW_SERIES_XTICS: draw a user tic series, x axis */
Xdraw_series_xtics(start, incr, end)
X		double start, incr, end; /* tic series definition */
X		/* assume start < end, incr > 0 */
X{
X	double ticplace, place;
X	double ticmin, ticmax;	/* for checking if tic is almost inrange */
X	double spacing = is_log_x ? log(incr)/log_base_log_x : incr;
X
X	if (end == VERYLARGE)
X		end = max(CheckLog(is_log_x, base_log_x, x_min),
X			  CheckLog(is_log_x, base_log_x, x_max));
X	else
X	  /* limit to right side of plot */
X	  end = min(end, max(CheckLog(is_log_x, base_log_x, x_min),
X			     CheckLog(is_log_x, base_log_x, x_max)));
X
X	/* to allow for rounding errors */
X	ticmin = min(x_min,x_max) - SIGNIF*incr;
X	ticmax = max(x_min,x_max) + SIGNIF*incr;
X	end = end + SIGNIF*incr; 
X
X	for (ticplace = start; ticplace <= end; ticplace +=incr) {
X	    place = (is_log_x ? log(ticplace)/log_base_log_x : ticplace);
X	    if ( inrange(place,ticmin,ticmax) )
X		 xtick(place, xformat, spacing, 1.0);
X	}
X}
Xchar GPFAR * GPFAR month[]={
X    "Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"
X};
Xdraw_month_ytics()
X{ 
X    long l_tickplace,l_incr,l_end,m_calc;
X
X    l_tickplace = (long)y_min;
X    if((double)l_tickplace<y_min)l_tickplace++;
X    l_end=(double)y_max;
X    l_incr=(l_end-l_tickplace+1)/12;
X    if(l_incr<1)l_incr=1;
X    while(l_tickplace<=l_end)
X    {
X	m_calc = (l_tickplace-1)%12;
X	if(m_calc<0)m_calc += 12;
X	ytick((double)l_tickplace,month[m_calc],(double)l_incr,1.0);
X	l_tickplace += l_incr;
X    }
X}
Xdraw_month_xtics()
X{
X    long l_tickplace,l_incr,l_end,m_calc;
X
X    l_tickplace = (long)x_min;
X    if((double)l_tickplace<x_min)l_tickplace++;
X    l_end=(double)x_max;
X    l_incr=(l_end-l_tickplace+1)/12;
X    if(l_incr<1)l_incr=1;
X    while(l_tickplace<=l_end)
X    {
X	m_calc = (l_tickplace-1)%12;
X	if(m_calc<0)m_calc += 12;
X	xtick((double)l_tickplace,month[m_calc],(double)l_incr,1.0);
X	l_tickplace += l_incr;
X    }
X}
Xchar *day[]={
X    "Sun","Mon","Tue","Wed","Thu","Fri","Sat"
X};
Xdraw_day_ytics()
X{ 
X    long l_tickplace,l_incr,l_end,m_calc;
X
X    l_tickplace = (long)y_min;
X    if((double)l_tickplace<y_min)l_tickplace++;
X    l_end=(double)y_max;
X    l_incr=(l_end-l_tickplace+1)/14;
X    if(l_incr<1)l_incr=1;
X    while(l_tickplace<=l_end)
X    {
X	m_calc = l_tickplace%7;
X	if(m_calc<0)m_calc += 7;
X	ytick((double)l_tickplace,day[m_calc],(double)l_incr,1.0);
X	l_tickplace += l_incr;
X    }
X}
Xdraw_day_xtics()
X{ 
X    long l_tickplace,l_incr,l_end,m_calc;
X
X    l_tickplace = (long)x_min;
X    if((double)l_tickplace<x_min)l_tickplace++;
X    l_end=(double)x_max;
X    l_incr=(l_end-l_tickplace+1)/14;
X    if(l_incr<1)l_incr=1;
X    while(l_tickplace<=l_end)
X    {
X	m_calc = l_tickplace%7;
X	if(m_calc<0)m_calc += 7;
X	xtick((double)l_tickplace,day[m_calc],(double)l_incr,1.0);
X	l_tickplace += l_incr;
X    }
X}
X/* DRAW_SET_YTICS: draw a user tic set, y axis */
Xdraw_set_ytics(list)
X	struct ticmark *list;	/* list of tic marks */
X{
X    double ticplace;
X    double incr = (y_max - y_min) / 10;
X    /* global x_min, x_max, xscale, y_min, y_max, yscale */
X
X    while (list != NULL) {
X	   ticplace = (is_log_y ? log(list->position)/log_base_log_y
X				: list->position);
X	   if ( inrange(ticplace, y_min, y_max) 		/* in range */
X		  || NearlyEqual(ticplace, y_min, incr)	/* == y_min */
X		  || NearlyEqual(ticplace, y_max, incr))	/* == y_max */
X		ytick(ticplace, list->label, incr, 1.0);
X
X	   list = list->next;
X    }
X}
X
X/* DRAW_SET_XTICS: draw a user tic set, x axis */
Xdraw_set_xtics(list)
X	struct ticmark *list;	/* list of tic marks */
X{
X    double ticplace;
X    double incr = (x_max - x_min) / 10;
X    /* global x_min, x_max, xscale, y_min, y_max, yscale */
X
X    while (list != NULL) {
X	   ticplace = (is_log_x ? log(list->position)/log_base_log_x
X				: list->position);
X	   if ( inrange(ticplace, x_min, x_max) 		/* in range */
X		  || NearlyEqual(ticplace, x_min, incr)	/* == x_min */
X		  || NearlyEqual(ticplace, x_max, incr))	/* == x_max */
X		xtick(ticplace, list->label, incr, 1.0);
X
X	   list = list->next;
X    }
X}
X
X/* draw and label a y-axis ticmark */
Xytick(place, text, spacing, ticscale)
X        double place;                   /* where on axis to put it */
X        char *text;                     /* optional text label */
X        double spacing;         /* something to use with checkzero */
X        double ticscale;         /* scale factor for tic mark (0..1] */
X{
X    register struct termentry *t = &term_tbl[term];
X    char ticlabel[101];
X    int ticsize = (int)((t->h_tic) * ticscale);
X
X	place = CheckZero(place,spacing); /* to fix rounding error near zero */
X    if (grid) {
X           (*t->linetype)(-1);  /* axis line type */
X           /* do not put a rectangular grid on a polar plot */
X	   if( !polar){
X	     (*t->move)(xleft, map_y(place));
X	     (*t->vector)(xright, map_y(place));
X           } else {   /* put a circular grid for polar -- not clipped! */
X             int i;
X		(*t->move)(map_x(ZERO), map_y(place));
X		for( i=0; i <= 360; i++)
X		   (*t->vector)( map_x(place*sin( (double) DEG2RAD*i)),
X			map_y(place*cos( (double) DEG2RAD*i)) );
X		}
X	   (*t->linetype)(-2); /* border linetype */
X    }
X    if (tic_in) {
X      /* if polar plot, put the tics along the axes */
X      if( polar){
X           (*t->move)(map_x(ZERO),map_y(place));
X           (*t->vector)(map_x(ZERO) + ticsize, map_y(place));
X           (*t->move)(map_x(ZERO), map_y(place));
X           (*t->vector)(map_x(ZERO) - ticsize, map_y(place));
X	 } else {
X	   (*t->move)(xleft, map_y(place));
X           (*t->vector)(xleft + ticsize, map_y(place));
X           (*t->move)(xright, map_y(place));
X           (*t->vector)(xright - ticsize, map_y(place));
X	 }
X    } else {
X      if( polar){
X           (*t->move)(map_x(ZERO), map_y(place));
X           (*t->vector)(map_x(ZERO) - ticsize, map_y(place));
X	 }else{
X           (*t->move)(xleft, map_y(place));
X           (*t->vector)(xleft - ticsize, map_y(place));
X	 }
X    }
X
X    /* label the ticmark */
X    if (text == NULL) 
X	 text = yformat;
X    
X    if( polar){
X      (void) sprintf(ticlabel, text,
X		CheckLog(is_log_y, base_log_y, fabs( place)+rmin));
X      if ((*t->justify_text)(RIGHT)) {
X	   (*t->put_text)(map_x(ZERO)-(t->h_char),
X				   map_y(place), ticlabel);
X	 } else {
X	   (*t->put_text)(map_x(ZERO)-(t->h_char)*(strlen(ticlabel)+1),
X				   map_y(place), ticlabel);
X	 }
X    } else {
X    
X      (void) sprintf(ticlabel, text, CheckLog(is_log_y, base_log_y, place));
X      if ((*t->justify_text)(RIGHT)) {
X	   (*t->put_text)(xleft-(t->h_char),
X				   map_y(place), ticlabel);
X	 } else {
X	   (*t->put_text)(xleft-(t->h_char)*(strlen(ticlabel)+1),
X				   map_y(place), ticlabel);
X	 }
X    }
X}
X
X/* draw and label an x-axis ticmark */
Xxtick(place, text, spacing, ticscale)
X        double place;                   /* where on axis to put it */
X        char *text;                     /* optional text label */
X        double spacing;         /* something to use with checkzero */
X        double ticscale;         /* scale factor for tic mark (0..1] */
X{
X    register struct termentry *t = &term_tbl[term];
X    char ticlabel[101];
X    int ticsize = (int)((t->v_tic) * ticscale);
X
X	place = CheckZero(place,spacing); /* to fix rounding error near zero */
X    if (grid) {
X           (*t->linetype)(-1);  /* axis line type */
X           if( !polar){  /* do not place a rectangular grid */
X	     (*t->move)(map_x(place), ybot);
X	     (*t->vector)(map_x(place), ytop);
X           } else { /* angular lines only for start and stop */
X	     int i;
X	     for( i=0; i < 360; i+=10){
X		 (*t->move)(map_x(ZERO),map_y(ZERO) );
X		 (*t->vector)(map_x(-place*cos((double) DEG2RAD*i)),
X			 map_y(-place*sin( (double)DEG2RAD*i)));
X		 if( i%90 == 0){
X			 (void) sprintf(ticlabel, "%d", i);
X		 (*t->put_text)(map_x(-1.05*place*cos((double) DEG2RAD*i))
X			 +(t->h_char)*strlen(ticlabel)/2,
X			 map_y(-1.05*place*sin( (double)DEG2RAD*i))
X				 , ticlabel);
X		 }
X	     }
X           }
X	   (*t->linetype)(-2); /* border linetype */
X    }
X    if (tic_in) {
X      if( polar){
X           (*t->move)(map_x(place), map_y(ZERO));
X           (*t->vector)(map_x(place), map_y(ZERO) + ticsize);
X           (*t->move)(map_x(place), map_y(ZERO));
X           (*t->vector)(map_x(place), map_y(ZERO) - ticsize);
X	 } else{
X           (*t->move)(map_x(place), ybot);
X           (*t->vector)(map_x(place), ybot + ticsize);
X           (*t->move)(map_x(place), ytop);
X           (*t->vector)(map_x(place), ytop - ticsize);
X	 }
X    } else {
X      if( polar){
X           (*t->move)(map_x(place), map_y(ZERO));
X           (*t->vector)(map_x(place), map_y(ZERO) - ticsize);
X	 }else{
X           (*t->move)(map_x(place), ybot);
X           (*t->vector)(map_x(place), ybot - ticsize);
X	 }
X    }
X    
X    /* label the ticmark */
X    if (text == NULL)
X	 text = xformat;
X
X    if(polar){
X      (void) sprintf(ticlabel, text, CheckLog(is_log_x, base_log_x, fabs(place)+rmin));
X      if ((*t->justify_text)(CENTRE)) {
X	   (*t->put_text)(map_x(place),
X				   map_y(ZERO)-(t->v_char), ticlabel);
X	 } else {
X	   (*t->put_text)(map_x(place)-(t->h_char)*strlen(ticlabel)/2,
X				   map_y(ZERO)-(t->v_char), ticlabel);
X	 }
X    }else{
X
X      (void) sprintf(ticlabel, text, CheckLog(is_log_x, base_log_x, place));
X      if ((*t->justify_text)(CENTRE)) {
X	   (*t->put_text)(map_x(place),
X				   ybot-(t->v_char), ticlabel);
X	 } else {
X	   (*t->put_text)(map_x(place)-(t->h_char)*strlen(ticlabel)/2,
X				   ybot-(t->v_char), ticlabel);
X	 }
X    }
X}
END_OF_FILE
  if test 55795 -ne `wc -c <'gnuplot/graphics.c'`; then
    echo shar: \"'gnuplot/graphics.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/graphics.c'
fi
echo shar: End of archive 7 \(of 33\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
