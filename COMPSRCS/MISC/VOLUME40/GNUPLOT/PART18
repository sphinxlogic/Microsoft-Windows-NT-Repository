Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i030:  gnuplot - interactive function plotting utility, Part18/33
Message-ID: <1993Oct22.163646.24204@sparky.sterling.com>
X-Md4-Signature: a629fd6fcbc790fd479cbaf2f9b82ff5
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:36:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 30
Archive-name: gnuplot/part18
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/antenna.dat gnuplot/standard.c
#   gnuplot/term/latex.trm gnuplot/term/metafont.trm
# Wrapped by kent@sparky on Wed Oct 20 17:14:52 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 33)."'
if test -f 'gnuplot/demo/antenna.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/antenna.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/antenna.dat'\" \(20641 characters\)
  sed "s/^X//" >'gnuplot/demo/antenna.dat' <<'END_OF_FILE'
X#
X# $Id: antenna.dat 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X#
X   0.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X   2.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X   4.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X   6.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X   8.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X  10.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X  12.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X  14.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X  16.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X  18.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X  20.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X  22.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X  24.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X  26.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X  28.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X  30.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X  32.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X  34.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X  36.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X  38.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X  40.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X  42.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X  44.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X  46.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X  48.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X  50.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X  52.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X  54.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X  56.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X  58.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X  60.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X  62.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X  64.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X  66.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X  68.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X  70.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X  72.000 -41.802E+00 -37.180E+00 -39.114E+00 -24.830E+00
X  74.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X  76.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X  78.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X  80.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X  82.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X  84.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X  86.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X  88.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X  90.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X  92.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X  94.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X  96.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X  98.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 100.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 102.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 104.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 106.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 108.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 110.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 112.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 114.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 116.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 118.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 120.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 122.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 124.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 126.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 128.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 130.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 132.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 134.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 136.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 138.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 140.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 142.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 144.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 146.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 148.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 150.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 152.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 154.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 156.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 158.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 160.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 162.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 164.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 166.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 168.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 170.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 172.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 174.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 176.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 178.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 180.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X 182.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 184.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 186.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 188.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 190.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 192.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 194.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 196.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 198.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 200.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 202.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 204.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 206.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 208.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 210.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 212.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 214.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 216.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 218.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 220.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 222.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 224.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 226.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 228.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 230.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 232.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 234.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 236.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 238.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 240.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 242.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 244.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 246.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 248.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 250.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 252.000 -41.802E+00 -37.180E+00 -39.114E+00 -24.830E+00
X 254.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 256.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 258.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 260.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 262.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 264.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 266.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 268.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 270.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X 272.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 274.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 276.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 278.000  13.099E-02  42.554E-01 -25.105E+00  59.101E-01
X 280.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 282.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 284.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 286.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 288.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 290.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 292.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 294.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 296.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 298.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 300.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 302.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 304.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 306.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 308.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 310.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 312.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 314.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 316.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 318.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 320.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 322.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 324.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 326.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 328.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 330.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 332.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 334.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 336.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 338.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 340.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 342.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 344.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 346.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 348.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 350.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 352.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 354.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 356.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 358.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 360.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X   2.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X   4.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X   6.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X   8.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X  10.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X  12.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X  14.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X  16.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X  18.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X  20.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X  22.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X  24.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X  26.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X  28.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X  30.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X  32.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X  34.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X  36.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X  38.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X  40.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X  42.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X  44.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X  46.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X  48.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X  50.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X  52.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X  54.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X  56.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X  58.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X  60.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X  62.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X  64.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X  66.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X  68.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X  70.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X  72.000 -41.802E+00 -37.180E+00 -39.114E+00 -24.830E+00
X  74.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X  76.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X  78.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X  80.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X  82.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X  84.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X  86.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X  88.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X  90.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X  92.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X  94.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X  96.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X  98.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 100.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 102.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 104.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 106.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 108.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 110.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 112.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 114.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 116.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 118.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 120.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 122.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 124.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 126.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 128.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 130.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 132.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 134.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 136.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 138.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 140.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 142.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 144.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 146.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 148.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 150.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 152.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 154.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 156.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 158.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 160.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 162.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 164.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 166.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 168.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 170.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 172.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 174.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 176.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 178.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 180.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X 182.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 184.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 186.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 188.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 190.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 192.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 194.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 196.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 198.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 200.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 202.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 204.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 206.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 208.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 210.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 212.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 214.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 216.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 218.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 220.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 222.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 224.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 226.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 228.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 230.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 232.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 234.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 236.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 238.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 240.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 242.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 244.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 246.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 248.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 250.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 252.000 -41.802E+00 -37.180E+00 -39.114E+00 -24.830E+00
X 254.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 256.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 258.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 260.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 262.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 264.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 266.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 268.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 270.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
X 272.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 274.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 276.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 278.000  13.099E-02  42.554E-01 -25.105E+00  59.101E-01
X 280.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 282.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 284.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 286.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 288.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 290.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 292.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 294.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 296.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 298.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 300.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 302.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 304.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 306.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 308.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 310.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 312.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 314.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 316.000 -39.287E+00 -23.397E+00 -38.646E+00 -60.943E-01
X 318.000 -38.418E+00 -14.735E+00 -29.897E+00 -76.375E-01
X 320.000 -36.549E+00 -12.197E+00 -27.142E+00 -11.075E+00
X 322.000 -35.220E+00 -12.594E+00 -27.052E+00 -15.787E+00
X 324.000 -35.691E+00 -16.286E+00 -29.566E+00 -13.578E+00
X 326.000 -37.632E+00 -21.690E+00 -37.458E+00 -96.424E-01
X 328.000 -33.989E+00 -13.340E+00 -38.930E+00 -75.039E-01
X 330.000 -28.216E+00 -83.757E-01 -29.576E+00 -64.985E-01
X 332.000 -24.356E+00 -58.580E-01 -26.299E+00 -60.712E-01
X 334.000 -22.103E+00 -48.803E-01 -25.429E+00 -59.416E-01
X 336.000 -21.258E+00 -52.193E-01 -26.432E+00 -62.183E-01
X 338.000 -22.060E+00 -71.064E-01 -29.743E+00 -74.312E-01
X 340.000 -25.979E+00 -11.868E+00 -38.677E+00 -10.860E+00
X 342.000 -41.802E+00 -37.181E+00 -39.114E+00 -24.830E+00
X 344.000 -20.405E+00 -10.185E+00 -30.112E+00 -11.564E+00
X 346.000 -12.849E+00 -36.543E-01 -26.702E+00 -36.253E-01
X 348.000 -76.407E-01  15.917E-02 -25.211E+00  82.257E-02
X 350.000 -34.589E-01  26.769E-01 -24.794E+00  38.084E-01
X 352.000  13.100E-02  42.554E-01 -25.105E+00  59.101E-01
X 354.000  33.053E-01  48.742E-01 -26.062E+00  73.795E-01
X 356.000  60.696E-01  40.782E-01 -28.040E+00  83.501E-01
X 358.000  81.667E-01  13.355E-02 -32.735E+00  89.007E-01
X 360.000  90.007E-01 -35.926E+00 -71.297E+00  90.783E-01
END_OF_FILE
  if test 20641 -ne `wc -c <'gnuplot/demo/antenna.dat'`; then
    echo shar: \"'gnuplot/demo/antenna.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/antenna.dat'
fi
if test -f 'gnuplot/standard.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/standard.c'\"
else
  echo shar: Extracting \"'gnuplot/standard.c'\" \(20414 characters\)
  sed "s/^X//" >'gnuplot/standard.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: standard.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X
X/* GNUPLOT - standard.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X * 
X */
X
X#include <math.h>
X#include <stdio.h>
X#include "plot.h"
X
X#ifdef vms
X#include <errno.h>
X#else
Xextern int errno;
X#endif /* vms */
X
X
Xextern struct value stack[STACK_DEPTH];
Xextern int s_p;
Xextern double zero;
X
Xstruct value *pop(), *Gcomplex(), *Ginteger();
X
Xdouble magnitude(), angle(), real(), imag();
X
X/* The bessel function approximations here are from
X * "Computer Approximations"
X * by Hart, Cheney et al.
X * John Wiley & Sons, 1968
X */
X
X/* There appears to be a mistake in Hart, Cheney et al. on page 149.
X * Where it list Qn(x)/x ~ P(z*z)/Q(z*z), z = 8/x, it should read
X *               Qn(x)/z ~ P(z*z)/Q(z*z), z = 8/x
X * In the functions below, Qn(x) is implementated using the later
X * equation.
X * These bessel functions are accurate to about 1e-13
X */
X
X#if defined (ATARI) && defined(__PUREC__)
X/* Sorry. But PUREC bugs here.
X * These bessel functions are NOT accurate to about 1e-13
X */
X
X#define PI_ON_FOUR	 0.785398163397448309615661
X#define PI_ON_TWO	 1.570796326794896619231313
X#define THREE_PI_ON_FOUR 2.356194490192344928846982
X#define TWO_ON_PI	 0.636619772367581343075535
X
Xstatic double dzero = 0.0;
X
X/* jzero for x in [0,8]
X * Index 5849, 19.22 digits precision
X */
Xstatic double pjzero[] = {
X	 0.493378725179413356181681e+21,
X	-0.117915762910761053603844e+21,
X	 0.638205934107235656228943e+19,
X	-0.136762035308817138686542e+18,
X	 0.143435493914034611166432e+16,
X	-0.808522203485379387119947e+13,
X	 0.250715828553688194555516e+11,
X	-0.405041237183313270636066e+8,
X	 0.268578685698001498141585e+5
X};
X
Xstatic double qjzero[] = {
X	 0.493378725179413356211328e+21,
X	 0.542891838409228516020019e+19,
X	 0.302463561670946269862733e+17,
X	 0.112775673967979850705603e+15,
X	 0.312304311494121317257247e+12,
X	 0.669998767298223967181403e+9,
X	 0.111463609846298537818240e+7,
X	 0.136306365232897060444281e+4,
X	 0.1e+1
X};
X
X/* pzero for x in [8,inf]
X * Index 6548, 18.16 digits precision
X */
Xstatic double ppzero[] = {
X	 0.227790901973046843022700e+5,
X	 0.413453866395807657967802e+5,
X	 0.211705233808649443219340e+5,
X	 0.348064864432492703474453e+4,
X	 0.153762019090083542957717e+3,
X	 0.889615484242104552360748e+0
X};
X
Xstatic double qpzero[] = {
X	 0.227790901973046843176842e+5,
X	 0.413704124955104166398920e+5,
X	 0.212153505618801157304226e+5,
X	 0.350287351382356082073561e+4,
X	 0.157111598580808936490685e+3,
X	 0.1e+1
X};
X
X/* qzero for x in [8,inf]
X * Index 6948, 18.33 digits precision
X */
Xstatic double pqzero[] = {
X	-0.892266002008000940984692e+2,
X	-0.185919536443429938002522e+3,
X	-0.111834299204827376112621e+3,
X	-0.223002616662141984716992e+2,
X	-0.124410267458356384591379e+1,
X	-0.8803330304868075181663e-2,
X};
X
Xstatic double qqzero[] = {
X	 0.571050241285120619052476e+4,
X	 0.119511315434346136469526e+5,
X	 0.726427801692110188369134e+4,
X	 0.148872312322837565816135e+4,
X	 0.905937695949931258588188e+2,
X	 0.1e+1
X};
X
X
X/* yzero for x in [0,8]
X * Index 6245, 18.78 digits precision
X */
Xstatic double pyzero[] = {
X	-0.275028667862910958370193e+20,
X	 0.658747327571955492599940e+20,
X	-0.524706558111276494129735e+19,
X	 0.137562431639934407857134e+18,
X	-0.164860581718572947312208e+16,
X	 0.102552085968639428450917e+14,
X	-0.343637122297904037817103e+11,
X	 0.591521346568688965427383e+8,
X	-0.413703549793314855412524e+5
X};
X
Xstatic double qyzero[] = {
X	 0.372645883898616588198998e+21,
X	 0.419241704341083997390477e+19,
X	 0.239288304349978185743936e+17,
X	 0.916203803407518526248915e+14,
X	 0.261306575504108124956848e+12,
X	 0.579512264070072953738009e+9,
X	 0.100170264128890626566665e+7,
X	 0.128245277247899380417633e+4,
X	 0.1e+1
X};
X
X
X/* jone for x in [0,8]
X * Index 6050, 20.98 digits precision
X */
Xstatic double pjone[] = {
X	 0.581199354001606143928051e+21,
X	-0.667210656892491629802094e+20,
X	 0.231643358063400229793182e+19,
X	-0.358881756991010605074364e+17,
X	 0.290879526383477540973760e+15,
X	-0.132298348033212645312547e+13,
X	 0.341323418230170053909129e+10,
X	-0.469575353064299585976716e+7,
X	 0.270112271089232341485679e+4
X};
X
Xstatic double qjone[] = {
X	 0.116239870800321228785853e+22,
X	 0.118577071219032099983711e+20,
X	 0.609206139891752174610520e+17,
X	 0.208166122130760735124018e+15,
X	 0.524371026216764971540673e+12,
X	 0.101386351435867398996705e+10,
X	 0.150179359499858550592110e+7,
X	 0.160693157348148780197092e+4,
X	 0.1e+1
X};
X
X
X/* pone for x in [8,inf]
X * Index 6749, 18.11 digits precision
X */
Xstatic double ppone[] = {
X	 0.352246649133679798341724e+5,
X	 0.627588452471612812690057e+5,
X	 0.313539631109159574238670e+5,
X	 0.498548320605943384345005e+4,
X	 0.211152918285396238210572e+3,
X	 0.12571716929145341558495e+1
X};
X
Xstatic double qpone[] = {
X	 0.352246649133679798068390e+5,
X	 0.626943469593560511888834e+5,
X	 0.312404063819041039923016e+5,
X	 0.493039649018108897938610e+4,
X	 0.203077518913475932229357e+3,
X	 0.1e+1
X};
X
X/* qone for x in [8,inf]
X * Index 7149, 18.28 digits precision
X */
Xstatic double pqone[] = {
X	 0.351175191430355282253332e+3,
X	 0.721039180490447503928086e+3,
X	 0.425987301165444238988699e+3,
X	 0.831898957673850827325226e+2,
X	 0.45681716295512267064405e+1,
X	 0.3532840052740123642735e-1
X};
X
Xstatic double qqone[] = {
X	 0.749173741718091277145195e+4,
X	 0.154141773392650970499848e+5,
X	 0.915223170151699227059047e+4,
X	 0.181118670055235135067242e+4,
X	 0.103818758546213372877664e+3,
X	 0.1e+1
X};
X
X
X/* yone for x in [0,8]
X * Index 6444, 18.24 digits precision
X */
Xstatic double pyone[] = {
X	-0.292382196153296254310105e+20,
X	 0.774852068218683964508809e+19,
X	-0.344104806308411444618546e+18,
X	 0.591516076049007061849632e+16,
X	-0.486331694256717507482813e+14,
X	 0.204969667374566218261980e+12,
X	-0.428947196885524880182182e+9,
X	 0.355692400983052605669132e+6
X};
X
Xstatic double qyone[] = {
X	 0.149131151130292035017408e+21,
X	 0.181866284170613498688507e+19,
X	 0.113163938269888452690508e+17,
X	 0.475517358888813771309277e+14,
X	 0.150022169915670898716637e+12,
X	 0.371666079862193028559693e+9,
X	 0.726914730719888456980191e+6,
X	 0.107269614377892552332213e+4,
X	 0.1e+1
X};
X
X#else
X
X#define PI_ON_FOUR       0.78539816339744830961566084581987572
X#define PI_ON_TWO        1.57079632679489661923131269163975144
X#define THREE_PI_ON_FOUR 2.35619449019234492884698253745962716
X#define TWO_ON_PI        0.63661977236758134307553505349005744
X
Xstatic double dzero = 0.0;
X
X/* jzero for x in [0,8]
X * Index 5849, 19.22 digits precision
X */
Xstatic double pjzero[] = {
X	 0.4933787251794133561816813446e+21,
X	-0.11791576291076105360384408e+21,
X	 0.6382059341072356562289432465e+19,
X	-0.1367620353088171386865416609e+18,
X	 0.1434354939140346111664316553e+16,
X	-0.8085222034853793871199468171e+13,
X	 0.2507158285536881945555156435e+11,
X	-0.4050412371833132706360663322e+8,
X	 0.2685786856980014981415848441e+5
X};
X
Xstatic double qjzero[] = {
X	0.4933787251794133562113278438e+21,
X	0.5428918384092285160200195092e+19,
X	0.3024635616709462698627330784e+17,
X	0.1127756739679798507056031594e+15,
X	0.3123043114941213172572469442e+12,
X	0.669998767298223967181402866e+9,
X	0.1114636098462985378182402543e+7,
X	0.1363063652328970604442810507e+4,
X	0.1e+1
X};
X
X/* pzero for x in [8,inf]
X * Index 6548, 18.16 digits precision
X */
Xstatic double ppzero[] = {
X	0.2277909019730468430227002627e+5,
X	0.4134538663958076579678016384e+5,
X	0.2117052338086494432193395727e+5,
X	0.348064864432492703474453111e+4,
X	0.15376201909008354295771715e+3,
X	0.889615484242104552360748e+0
X};
X
Xstatic double qpzero[] = {
X	0.2277909019730468431768423768e+5,
X	0.4137041249551041663989198384e+5,
X	0.2121535056188011573042256764e+5,
X	0.350287351382356082073561423e+4,
X	0.15711159858080893649068482e+3,
X	0.1e+1
X};
X
X/* qzero for x in [8,inf]
X * Index 6948, 18.33 digits precision
X */
Xstatic double pqzero[] = {
X	-0.8922660020080009409846916e+2,
X	-0.18591953644342993800252169e+3,
X	-0.11183429920482737611262123e+3,
X	-0.2230026166621419847169915e+2,
X	-0.124410267458356384591379e+1,
X	-0.8803330304868075181663e-2,
X};
X
Xstatic double qqzero[] = {
X	0.571050241285120619052476459e+4,
X	0.1195113154343461364695265329e+5,
X	0.726427801692110188369134506e+4,
X	0.148872312322837565816134698e+4,
X	0.9059376959499312585881878e+2,
X	0.1e+1
X};
X
X
X/* yzero for x in [0,8]
X * Index 6245, 18.78 digits precision
X */
Xstatic double pyzero[] = {
X	-0.2750286678629109583701933175e+20,
X	 0.6587473275719554925999402049e+20,
X	-0.5247065581112764941297350814e+19,
X	 0.1375624316399344078571335453e+18,
X	-0.1648605817185729473122082537e+16,
X	 0.1025520859686394284509167421e+14,
X	-0.3436371222979040378171030138e+11,
X	 0.5915213465686889654273830069e+8,
X	-0.4137035497933148554125235152e+5
X};
X
Xstatic double qyzero[] = {
X	0.3726458838986165881989980739e+21,
X	0.4192417043410839973904769661e+19,
X	0.2392883043499781857439356652e+17,
X	0.9162038034075185262489147968e+14,
X	0.2613065755041081249568482092e+12,
X	0.5795122640700729537380087915e+9,
X	0.1001702641288906265666651753e+7,
X	0.1282452772478993804176329391e+4,
X	0.1e+1
X};
X
X
X/* jone for x in [0,8]
X * Index 6050, 20.98 digits precision
X */
Xstatic double pjone[] = {
X	 0.581199354001606143928050809e+21,
X	-0.6672106568924916298020941484e+20,
X	 0.2316433580634002297931815435e+19,
X	-0.3588817569910106050743641413e+17,
X	 0.2908795263834775409737601689e+15,
X	-0.1322983480332126453125473247e+13,
X	 0.3413234182301700539091292655e+10,
X	-0.4695753530642995859767162166e+7,
X	 0.270112271089232341485679099e+4
X};
X
Xstatic double qjone[] = {
X	0.11623987080032122878585294e+22,
X	0.1185770712190320999837113348e+20,
X	0.6092061398917521746105196863e+17,
X	0.2081661221307607351240184229e+15,
X	0.5243710262167649715406728642e+12,
X	0.1013863514358673989967045588e+10,
X	0.1501793594998585505921097578e+7,
X	0.1606931573481487801970916749e+4,
X	0.1e+1
X};
X
X
X/* pone for x in [8,inf]
X * Index 6749, 18.11 digits precision
X */
Xstatic double ppone[] = {
X	0.352246649133679798341724373e+5,
X	0.62758845247161281269005675e+5,
X	0.313539631109159574238669888e+5,
X	0.49854832060594338434500455e+4,
X	0.2111529182853962382105718e+3,
X	0.12571716929145341558495e+1
X};
X
Xstatic double qpone[] = {
X	0.352246649133679798068390431e+5,
X	0.626943469593560511888833731e+5,
X	0.312404063819041039923015703e+5,
X	0.4930396490181088979386097e+4,
X	0.2030775189134759322293574e+3,
X	0.1e+1
X};
X
X/* qone for x in [8,inf]
X * Index 7149, 18.28 digits precision
X */
Xstatic double pqone[] = {
X	0.3511751914303552822533318e+3,
X	0.7210391804904475039280863e+3,
X	0.4259873011654442389886993e+3,
X	0.831898957673850827325226e+2,
X	0.45681716295512267064405e+1,
X	0.3532840052740123642735e-1
X};
X
Xstatic double qqone[] = {
X	0.74917374171809127714519505e+4,
X	0.154141773392650970499848051e+5,
X	0.91522317015169922705904727e+4,
X	0.18111867005523513506724158e+4,
X	0.1038187585462133728776636e+3,
X	0.1e+1
X};
X
X
X/* yone for x in [0,8]
X * Index 6444, 18.24 digits precision
X */
Xstatic double pyone[] = {
X	-0.2923821961532962543101048748e+20,
X	 0.7748520682186839645088094202e+19,
X	-0.3441048063084114446185461344e+18,
X	 0.5915160760490070618496315281e+16,
X	-0.4863316942567175074828129117e+14,
X	 0.2049696673745662182619800495e+12,
X	-0.4289471968855248801821819588e+9,
X	 0.3556924009830526056691325215e+6
X};
X
Xstatic double qyone[] = {
X	0.1491311511302920350174081355e+21,
X	0.1818662841706134986885065935e+19,
X	0.113163938269888452690508283e+17,
X	0.4755173588888137713092774006e+14,
X	0.1500221699156708987166369115e+12,
X	0.3716660798621930285596927703e+9,
X	0.726914730719888456980191315e+6,
X	0.10726961437789255233221267e+4,
X	0.1e+1
X};
X
X#endif /* ATARI && __PUREC__ */
X
Xf_real()
X{
Xstruct value a;
X	push( Gcomplex(&a,real(pop(&a)), 0.0) );
X}
X
Xf_imag()
X{
Xstruct value a;
X	push( Gcomplex(&a,imag(pop(&a)), 0.0) );
X}
X
Xf_arg()
X{
Xstruct value a;
X	push( Gcomplex(&a,angle(pop(&a)), 0.0) );
X}
X
Xf_conjg()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,real(&a),-imag(&a) ));
X}
X
Xf_sin()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,sin(real(&a))*cosh(imag(&a)), cos(real(&a))*sinh(imag(&a))) );
X}
X
Xf_cos()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,cos(real(&a))*cosh(imag(&a)), -sin(real(&a))*sinh(imag(&a))));
X}
X
Xf_tan()
X{
Xstruct value a;
Xregister double den;
X	(void) pop(&a);
X	if (imag(&a) == 0.0)
X		push( Gcomplex(&a,tan(real(&a)),0.0) );
X	else {
X		den = cos(2*real(&a))+cosh(2*imag(&a));
X		if (den == 0.0) {
X			undefined = TRUE;
X			push( &a );
X		}
X		else
X			push( Gcomplex(&a,sin(2*real(&a))/den, sinh(2*imag(&a))/den) );
X	}
X}
X
Xf_asin()
X{
Xstruct value a;
Xregister double alpha, beta, x, y;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0) {
X		if (fabs(x) > 1.0) {
X			undefined = TRUE;
X			push(Gcomplex(&a,0.0, 0.0));
X		} else
X			push( Gcomplex(&a,asin(x),0.0) );
X	} else {
X		beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
X		alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
X		push( Gcomplex(&a,asin(beta), log(alpha + sqrt(alpha*alpha-1))) );
X	}
X}
X
Xf_acos()
X{
Xstruct value a;
Xregister double alpha, beta, x, y;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0) {
X		if (fabs(x) > 1.0) {
X			undefined = TRUE;
X			push(Gcomplex(&a,0.0, 0.0));
X		} else
X			push( Gcomplex(&a,acos(x),0.0) );
X	} else {
X		alpha = sqrt((x + 1)*(x + 1) + y*y)/2 + sqrt((x - 1)*(x - 1) + y*y)/2;
X		beta  = sqrt((x + 1)*(x + 1) + y*y)/2 - sqrt((x - 1)*(x - 1) + y*y)/2;
X		push( Gcomplex(&a,acos(beta), log(alpha + sqrt(alpha*alpha-1))) );
X	}
X}
X
Xf_atan()
X{
Xstruct value a;
Xregister double x, y, u, v, w, z;
X	(void) pop(&a);
X	x = real(&a); y = imag(&a);
X	if (y == 0.0)
X		push( Gcomplex(&a,atan(x), 0.0) );
X	else if (x == 0.0 && fabs(y) == 1.0) {
X		undefined = TRUE;
X		push(Gcomplex(&a,0.0, 0.0));
X	} else {
X	        if (x >= 0) {
X		        u = x;
X			v = y;
X		} else {
X		        u = -x;
X			v = -y;
X		}
X		
X	        z = atan(2*u/(1-u*u-v*v));
X		w = log((u*u+(v+1)*(v+1))/(u*u+(v-1)*(v-1)))/4;
X		if (z < 0)
X		        z = z + 2*PI_ON_TWO;
X		if (x < 0) {
X		        z = -z;
X			w = -w;
X		}
X		push( Gcomplex(&a,0.5*z, w) );
X	}
X}
X
Xf_sinh()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,sinh(real(&a))*cos(imag(&a)), cosh(real(&a))*sin(imag(&a))) );
X}
X
Xf_cosh()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,cosh(real(&a))*cos(imag(&a)), sinh(real(&a))*sin(imag(&a))) );
X}
X
Xf_tanh()
X{
Xstruct value a;
Xregister double den;
X	(void) pop(&a);
X	den = cosh(2*real(&a)) + cos(2*imag(&a));
X	push( Gcomplex(&a,sinh(2*real(&a))/den, sin(2*imag(&a))/den) );
X}
X
Xf_int()
X{
Xstruct value a;
X	push( Ginteger(&a,(int)real(pop(&a))) );
X}
X
X
Xf_abs()
X{
Xstruct value a;
X	(void) pop(&a);
X	switch (a.type) {
X		case INTGR:
X			push( Ginteger(&a,abs(a.v.int_val)) );			
X			break;
X		case CMPLX:
X			push( Gcomplex(&a,magnitude(&a), 0.0) );
X	}
X}
X
Xf_sgn()
X{
Xstruct value a;
X	(void) pop(&a);
X	switch(a.type) {
X		case INTGR:
X			push( Ginteger(&a,(a.v.int_val > 0) ? 1 : 
X					(a.v.int_val < 0) ? -1 : 0) );
X			break;
X		case CMPLX:
X			push( Ginteger(&a,(a.v.cmplx_val.real > 0.0) ? 1 : 
X					(a.v.cmplx_val.real < 0.0) ? -1 : 0) );
X			break;
X	}
X}
X
X
Xf_sqrt()
X{
Xstruct value a;
Xregister double mag, ang;
X	(void) pop(&a);
X	mag = sqrt(magnitude(&a));
X	if (imag(&a) == 0.0 && real(&a) < 0.0)
X		push( Gcomplex(&a,0.0,mag) );
X	else
X	{
X		if ( (ang = angle(&a)) < 0.0)
X			ang += 2*Pi;
X		ang /= 2;
X		push( Gcomplex(&a,mag*cos(ang), mag*sin(ang)) );
X	}
X}
X
X
Xf_exp()
X{
Xstruct value a;
Xregister double mag, ang;
X	(void) pop(&a);
X	mag = exp(real(&a));
X	ang = imag(&a);
X	push( Gcomplex(&a,mag*cos(ang), mag*sin(ang)) );
X}
X
X
Xf_log10()
X{
Xstruct value a;
Xregister double l10;;
X	(void) pop(&a);
X	l10 = log(10.0);	/***** replace with a constant! ******/
X	push( Gcomplex(&a,log(magnitude(&a))/l10, angle(&a)/l10) );
X}
X
X
Xf_log()
X{
Xstruct value a;
X	(void) pop(&a);
X	push( Gcomplex(&a,log(magnitude(&a)), angle(&a)) );
X}
X
X
Xf_floor()
X{
Xstruct value a;
X
X	(void) pop(&a);
X	switch (a.type) {
X		case INTGR:
X			push( Ginteger(&a,(int)floor((double)a.v.int_val)));			
X			break;
X		case CMPLX:
X			push( Ginteger(&a,(int)floor(a.v.cmplx_val.real)));
X	}
X}
X
X
Xf_ceil()
X{
Xstruct value a;
X
X	(void) pop(&a);
X	switch (a.type) {
X		case INTGR:
X			push( Ginteger(&a,(int)ceil((double)a.v.int_val)));			
X			break;
X		case CMPLX:
X			push( Ginteger(&a,(int)ceil(a.v.cmplx_val.real)));
X	}
X}
X
X/* bessel function approximations */
Xdouble jzero(x)
Xdouble x;
X{
Xdouble p, q, x2;
Xint n;
X
X	x2 = x * x;
X	p = pjzero[8];
X	q = qjzero[8];
X	for (n=7; n>=0; n--) {
X		p = p*x2 + pjzero[n];
X		q = q*x2 + qjzero[n];
X	}
X	return(p/q);
X}
X
Xdouble pzero(x)
Xdouble x;
X{
Xdouble p, q, z, z2;
Xint n;
X
X	z = 8.0 / x;
X	z2 = z * z;
X	p = ppzero[5];
X	q = qpzero[5];
X	for (n=4; n>=0; n--) {
X		p = p*z2 + ppzero[n];
X		q = q*z2 + qpzero[n];
X	}
X	return(p/q);
X}
X
Xdouble qzero(x)
Xdouble x;
X{
Xdouble p, q, z, z2;
Xint n;
X
X	z = 8.0 / x;
X	z2 = z * z;
X	p = pqzero[5];
X	q = qqzero[5];
X	for (n=4; n>=0; n--) {
X		p = p*z2 + pqzero[n];
X		q = q*z2 + qqzero[n];
X	}
X	return(p/q);
X}
X
Xdouble yzero(x)
Xdouble x;
X{
Xdouble p, q, x2;
Xint n;
X
X	x2 = x * x;
X	p = pyzero[8];
X	q = qyzero[8];
X	for (n=7; n>=0; n--) {
X		p = p*x2 + pyzero[n];
X		q = q*x2 + qyzero[n];
X	}
X	return(p/q);
X}
X
Xdouble rj0(x)
Xdouble x;
X{
X	if ( x <= 0.0 )
X		x = -x;
X	if ( x < 8.0 )
X		return(jzero(x));
X	else
X		return( sqrt(TWO_ON_PI/x) *
X			(pzero(x)*cos(x-PI_ON_FOUR) - 8.0/x*qzero(x)*sin(x-PI_ON_FOUR)) );
X
X}
X
Xdouble ry0(x)
Xdouble x;
X{
X	if ( x < 0.0 )
X		return(dzero/dzero); /* error */
X	if ( x < 8.0 )
X		return( yzero(x) + TWO_ON_PI*rj0(x)*log(x) );
X	else
X		return( sqrt(TWO_ON_PI/x) *
X			(pzero(x)*sin(x-PI_ON_FOUR) + 
X			(8.0/x)*qzero(x)*cos(x-PI_ON_FOUR)) );
X
X}
X
X
Xdouble jone(x)
Xdouble x;
X{
Xdouble p, q, x2;
Xint n;
X
X	x2 = x * x;
X	p = pjone[8];
X	q = qjone[8];
X	for (n=7; n>=0; n--) {
X		p = p*x2 + pjone[n];
X		q = q*x2 + qjone[n];
X	}
X	return(p/q);
X}
X
Xdouble pone(x)
Xdouble x;
X{
Xdouble p, q, z, z2;
Xint n;
X
X	z = 8.0 / x;
X	z2 = z * z;
X	p = ppone[5];
X	q = qpone[5];
X	for (n=4; n>=0; n--) {
X		p = p*z2 + ppone[n];
X		q = q*z2 + qpone[n];
X	}
X	return(p/q);
X}
X
Xdouble qone(x)
Xdouble x;
X{
Xdouble p, q, z, z2;
Xint n;
X
X	z = 8.0 / x;
X	z2 = z * z;
X	p = pqone[5];
X	q = qqone[5];
X	for (n=4; n>=0; n--) {
X		p = p*z2 + pqone[n];
X		q = q*z2 + qqone[n];
X	}
X	return(p/q);
X}
X
Xdouble yone(x)
Xdouble x;
X{
Xdouble p, q, x2;
Xint n;
X
X	x2 = x * x;
X	p = 0.0;
X	q = qyone[8];
X	for (n=7; n>=0; n--) {
X		p = p*x2 + pyone[n];
X		q = q*x2 + qyone[n];
X	}
X	return(p/q);
X}
X
Xdouble rj1(x)
Xdouble x;
X{
Xdouble v,w;
X	v = x;
X	if ( x < 0.0 )
X		x = -x;
X	if ( x < 8.0 )
X		return(v*jone(x));
X	else {
X		w = sqrt(TWO_ON_PI/x) *
X			(pone(x)*cos(x-THREE_PI_ON_FOUR) - 
X			   8.0/x*qone(x)*sin(x-THREE_PI_ON_FOUR)) ;
X		if (v < 0.0)
X			w = -w;
X		return( w );
X	}
X}
X
Xdouble ry1(x)
Xdouble x;
X{
X	if ( x <= 0.0 )
X		return(dzero/dzero); /* error */
X	if ( x < 8.0 )
X		return( x*yone(x) + TWO_ON_PI*(rj1(x)*log(x) - 1.0/x) );
X	else
X		return( sqrt(TWO_ON_PI/x) *
X			(pone(x)*sin(x-THREE_PI_ON_FOUR) + 
X			(8.0/x)*qone(x)*cos(x-THREE_PI_ON_FOUR)) );
X}
X
X
Xf_besj0()	
X{
Xstruct value a;
X	(void) pop(&a);
X	if (fabs(imag(&a)) > zero)
X		int_error("can only do bessel functions of reals",NO_CARET);
X	push( Gcomplex(&a,rj0(real(&a)),0.0) );
X}
X
X
Xf_besj1()	
X{
Xstruct value a;
X	(void) pop(&a);
X	if (fabs(imag(&a)) > zero)
X		int_error("can only do bessel functions of reals",NO_CARET);
X	push( Gcomplex(&a,rj1(real(&a)),0.0) );
X}
X
X
Xf_besy0()	
X{
Xstruct value a;
X	(void) pop(&a);
X	if (fabs(imag(&a)) > zero)
X		int_error("can only do bessel functions of reals",NO_CARET);
X	if (real(&a) > 0.0)
X		push( Gcomplex(&a,ry0(real(&a)),0.0) );
X	else {
X		push( Gcomplex(&a,0.0,0.0) );
X		undefined = TRUE ;
X	}
X}
X
X
Xf_besy1()	
X{
Xstruct value a;
X	(void) pop(&a);
X	if (fabs(imag(&a)) > zero)
X		int_error("can only do bessel functions of reals",NO_CARET);
X	if (real(&a) > 0.0)
X		push( Gcomplex(&a,ry1(real(&a)),0.0) );
X	else {
X		push( Gcomplex(&a,0.0,0.0) );
X		undefined = TRUE ;
X	}
X}
END_OF_FILE
  if test 20414 -ne `wc -c <'gnuplot/standard.c'`; then
    echo shar: \"'gnuplot/standard.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/standard.c'
fi
if test -f 'gnuplot/term/latex.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/latex.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/latex.trm'\" \(20098 characters\)
  sed "s/^X//" >'gnuplot/term/latex.trm' <<'END_OF_FILE'
X/*
X * $Id: latex.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - latex.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   LaTeX pictures (latex).
X *   LaTeX pictures with emTeX specials (emtex). 
X *
X * AUTHORS
X *   David Kotz, Russell Lang
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/* modified to optimize use of \rule for long lines */
X/* TLDC: modified to have nice line types */
X
X/* the following LATEX driver has been modified by 
X   Russell Lang, eln272v@monu1.cc.monash.oz from the
X   GnuTeX 1.3 driver by David Kotz, David.Kotz@Dartmouth.edu.
X   Since then it has been further extended by David Kotz.
X   EmTeX driver by Russell Lang. */
X
X/*  9 Dec 1992  LATEX_put_text rewritten to handle \\ newlines
X                Daniel S. Lewart (d-lewart@uiuc.edu) */
X
X#define TINY_STEP 0.5	/* tiny steps for high quality lines */
X
X#define LATEX_PTS_PER_INCH (72.27)
X#define DOTS_PER_INCH (300)	/* resolution of printer we expect to use */
X#define LATEX_UNIT (LATEX_PTS_PER_INCH/DOTS_PER_INCH) /* dot size in pt */
X
X/* 5 inches wide by 3 inches high (default) */
X#define LATEX_XMAX (5*DOTS_PER_INCH)  /* (LATEX_PTS_PER_INCH/LATEX_UNIT*5.0) */
X#define LATEX_YMAX (3*DOTS_PER_INCH)  /* (LATEX_PTS_PER_INCH/LATEX_UNIT*3.0) */
X
X#define LATEX_HTIC (5*DOTS_PER_INCH/72)		/* (5./LATEX_UNIT) */
X#define LATEX_VTIC (5*DOTS_PER_INCH/72)		/* (5./LATEX_UNIT) */
X#define LATEX_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3/LATEX_UNIT) */
X#define LATEX_VCHAR (DOTS_PER_INCH*11/72)	/* (11./LATEX_UNIT) */
X
Xstatic int LATEX_posx;
Xstatic int LATEX_posy;
Xint LATEX_fontsize = 10;
Xchar LATEX_font[MAX_ID_LEN+1] = "cmr";
Xstatic enum JUSTIFY latex_justify=LEFT;
Xstatic int latex_angle=0;
X
X/* Default line-drawing character */
X/* the definition of plotpoint varies with linetype */
X#define LATEX_DOT "\\usebox{\\plotpoint}"
X#define LATEX_TINY_DOT "\\rule{1pt}{1pt}" /* for dots plot style */
X
X/* POINTS */
X#define LATEX_POINT_TYPES 12	/* we supply more point types */
Xstatic char GPFAR * GPFAR LATEX_points[] = {
X    "\\raisebox{-.8pt}{\\makebox(0,0){$\\Diamond$}}",
X    "\\makebox(0,0){$+$}",
X    "\\raisebox{-.8pt}{\\makebox(0,0){$\\Box$}}",
X    "\\makebox(0,0){$\\times$}",
X    "\\makebox(0,0){$\\triangle$}",
X    "\\makebox(0,0){$\\star$}",
X    "\\circle{12}", "\\circle{18}", "\\circle{24}",
X    "\\circle*{12}", "\\circle*{18}", "\\circle*{24}"
X};
X
X/* LINES */
Xstatic float LATEX_size = 0;	/* current thick of line in points */
Xstatic float LATEX_dotspace = 0; /* current dotspace of line in points */
X#define LATEX_LINE_TYPES 6	/* number of line types below */
X#define LATEX_THIN_LINE 0	/* the thinnest solid line type */
Xstatic struct {
X    float size;			/* size of dot, or thick of line in points */
X    float dotspace;			/* inter-dot space in points; 0 for lines */
X  } GPFAR LATEX_lines[] = {
X      {0.4, 0.0},			/* thin solid line */
X      {0.4, 5.0},			/* thin dotted line */
X      {0.8, 0.0},			/* thick solid line */
X      {1.0, 5.0},			/* thick dotted line */
X      {1.2, 0.0},			/* Thick solid line */
X      {1.0, 10.0},			/* thick widely dotted line */
X  };
X
X/* for drawing dotted and solid lines */
Xstatic void LATEX_dot_line();
Xstatic void LATEX_solid_line();
Xstatic void LATEX_rule();
Xstatic void LATEX_flushdot();
X#define LATEX_flushrule() LATEX_rule(2, 0.,0.,0.,0.) /* flush old rule */
Xstatic TBOOLEAN LATEX_moved = TRUE;	/* pen is up after move */
Xstatic float LATEX_dotsize;	/* size of LATEX_DOT in units */
Xstatic TBOOLEAN LATEX_needsdot = FALSE;/* does dotted line need termination? */
X
X#ifdef EMTEX
XTBOOLEAN emtex=FALSE; /* not currently using emtex */
Xstatic void EMTEX_solid_line();
X#endif
X
X/* ARROWS */
X/* the set of non-vertical/non-horizontal LaTeX vector slopes */
X/* except negatives - they are handled specially */
Xstatic struct vslope {
X    int dx, dy;
X} GPFAR LATEX_slopes[] = {
X    {1,1}, {1,2}, {1,3}, {1,4},
X    {2,1}, {2,3},
X    {3,1}, {3,2}, {3,4},
X    {4,1}, {4,3},
X    {0,0}					/* terminator */
X};
Xstatic void best_latex_arrow(); /* figure out the best arrow */
X
XLATEX_options()
X{
X	extern struct value *const_express();
X	extern double real();
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"c$ourier")) {
X			strcpy(LATEX_font,"cmtt");
X			c_token++;
X		}
X		else if (almost_equals(c_token,"r$oman")) {
X			strcpy(LATEX_font,"cmr");
X			c_token++;
X		}
X		else if (almost_equals(c_token,"d$efault")) {
X			strcpy(LATEX_font,"cmr");
X			LATEX_fontsize = 10;
X			c_token++;
X		}
X	}
X	
X	if (!END_OF_COMMAND) {
X		struct value a;
X		LATEX_fontsize = (int)real(const_express(&a));
X		term_tbl[term].v_char = (unsigned int)(LATEX_fontsize);
X		term_tbl[term].h_char = (unsigned int)(LATEX_fontsize);
X	}
X	sprintf(term_options,"%s %d point", LATEX_font ? "courier" : "roman",
X		LATEX_fontsize);
X}
X
X
XLATEX_init()
X{
X#ifdef EMTEX
X    emtex = FALSE;
X#endif
X    LATEX_posx = LATEX_posy = 0;
X    fprintf(outfile, "%% GNUPLOT: LaTeX picture\n");
X    fprintf(outfile, "\\setlength{\\unitlength}{%fpt}\n", LATEX_UNIT);
X    fprintf(outfile, 
X		  "\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n");
X    LATEX_linetype(-1);
X	LATEX_size =0;
X}
X
X
XLATEX_scale(xs, ys)
X	double xs, ys;			/* scaling factors */
X{
X    register struct termentry *t = &term_tbl[term];
X
X    /* we change the table for use in graphics.c and LATEX_graphics */
X    t->xmax = (unsigned int)(LATEX_XMAX * xs);
X    t->ymax = (unsigned int)(LATEX_YMAX * ys);
X
X    return(TRUE);
X}
X
XLATEX_graphics()
X{
X    register struct termentry *t = &term_tbl[term];
X
X    fprintf(outfile, "\\begin{picture}(%d,%d)(0,0)\n", t->xmax, t->ymax);
X    fprintf(outfile, "\\font\\gnuplot=%s10 at %dpt\n", LATEX_font, LATEX_fontsize);
X    fprintf(outfile, "\\gnuplot\n");
X}
X
X
XLATEX_text()
X{
X    LATEX_flushrule();
X    LATEX_flushdot();
X    fprintf(outfile, "\\end{picture}\n");
X    LATEX_posx = LATEX_posy = 0; /* current position */
X    LATEX_moved = TRUE;	/* pen is up after move */
X}
X
XLATEX_linetype(linetype)
X	int linetype;
X{
X    float size;
X
X    if (linetype >= LATEX_LINE_TYPES)
X	 linetype %= LATEX_LINE_TYPES;
X
X#ifdef EMTEX
X    if (!emtex)
X#endif
X    LATEX_flushrule();
X    LATEX_flushdot();
X
X    /* Find the new desired line thickness. */
X    /* negative linetypes (for axes) use a thin line */
X    /* only relevant for drawing axes/border in 3d */
X    size = (linetype >= 0 ? LATEX_lines[linetype].size 
X		  : LATEX_lines[LATEX_THIN_LINE].size);
X
X    /* If different from current size, redefine \plotpoint */
X    if (size != LATEX_size) {
X	   fprintf(outfile, 
X			 "\\sbox{\\plotpoint}{\\rule[%.3fpt]{%.3fpt}{%.3fpt}}%%\n",
X			 -size/2, size, size);
X#ifdef EMTEX
X        if (emtex)         /* change line width */
X		fprintf(outfile, "\\special{em:linewidth %.1fpt}%%\n", size);
X#endif
X    }
X    
X    LATEX_size = size;
X    LATEX_dotsize = size / LATEX_UNIT;
X    LATEX_dotspace = (linetype >= 0) ? LATEX_lines[linetype].dotspace : 0;
X    LATEX_moved = TRUE;			/* reset */
X}
X
XLATEX_move(x,y)
X	unsigned int x,y;
X{
X    LATEX_flushdot();
X
X    LATEX_posx = x;
X    LATEX_posy = y;
X    LATEX_moved = TRUE;			/* reset */
X}
X
X
XLATEX_point(x,y, number)		/* version of line_and_point */
X	unsigned int x,y;
X	int number;				/* type of point */
X{
X    LATEX_move(x,y);
X    
X    /* Print the character defined by 'number'; number < 0 means 
X	  to use a dot, otherwise one of the defined points. */
X    fprintf(outfile, "\\put(%d,%d){%s}\n", x, y, 
X		  (number < 0 ? LATEX_TINY_DOT
X		   : LATEX_points[number % LATEX_POINT_TYPES]));
X}
X
X
XLATEX_vector(ux,uy)
X	unsigned int ux,uy;
X{
X    if (LATEX_dotspace == 0.0) {
X	   /* solid line */
X#ifdef EMTEX
X	   if (emtex)
X		EMTEX_solid_line(LATEX_posx, (int)ux, LATEX_posy, (int)uy);
X	   else
X#endif
X		LATEX_solid_line(LATEX_posx, (int)ux, LATEX_posy, (int)uy);
X    } else
X	 /* dotted line */
X	 LATEX_dot_line(LATEX_posx, (int)ux, LATEX_posy, (int)uy);
X
X    LATEX_posx = ux;
X    LATEX_posy = uy;
X}
X
Xstatic void
XLATEX_solid_line(x1,x2, y1,y2)
X	int x1,x2, y1,y2;
X{
X    float slope;
X    int inc;
X    float dx,dy,x,y;
X    float offset,length;
X    int code;				/* possibly combine with previous rule */
X
X    /* we draw a solid line using the current line thickness (size) */
X    /* we do it with lots of \\rules */
X
X    if (x1 == x2 && y1 == y2) { /* zero-length line - just a dot */
X	   if (LATEX_moved) {
X		  LATEX_flushrule();
X		  /* plot a dot */
X		  fprintf(outfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
X	   }
X    } else {
X	   code = (LATEX_moved ? 0 : 1); /* no combine after move */
X    	   LATEX_moved = FALSE;
X	   if (x1 == x2)		/* vertical line - special case */
X		LATEX_rule(code, (double)x1, (double)y1,
X			   LATEX_dotsize, (double)y2-y1);
X	   else if (y1 == y2)	/* horizontal line - special case */
X		LATEX_rule(code, (double)x1, (double)y1, (double)x2-x1,
X			   LATEX_dotsize);
X	   else {
X		  dx = (float)x2-x1;
X		  dy = (float)y2-y1;
X		  slope = dy/dx;
X		  if (abs(slope) <= 1.0) {
X			/* longer than high */
X			x = min(abs(dx),(0.25+1.0/abs(slope))*LATEX_dotsize);
X			offset = sign(dy)*min(LATEX_dotsize,abs(dy));
X			dy = dy - offset;
X			length = x*LATEX_UNIT;
X			inc = (x == abs(dx) ? 1 : max(1,abs(dy)/TINY_STEP+0.5));
X			if (inc == 1) {
X	 	     fprintf(outfile,"\\put(%u,%.2f){\\rule{%.3fpt}{%.3fpt}}\n",
X			 (x2>=x1? x1 : x2), ((float)y1+y2-LATEX_dotsize)/2,
X			 length, LATEX_dotsize*LATEX_UNIT);
X			} else {
X			  dy = dy/inc;
X			  dx = (dx-sign(dx)*x)/(inc-1);
Xfprintf(outfile,"\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
X			   (dx>=0.0? (float)x1 : x1-x), 
X			   (float)y1-(abs(dy)-offset)/2, 
X			   dx, dy, inc, length, abs(dy)*LATEX_UNIT);
X			}
X/* done with one section, now smooth it */
X			x = x/2;
X			dx = sign(dx) * x;
X			dx = (float)x2 - x1 - dx;
X			dy = (float)y2 - y1;
Xfprintf(outfile,"\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
X			 (dx>=0.0? (float)x1 : x1-x), (float)y1-LATEX_dotsize/2,
X			 dx, dy, x*LATEX_UNIT, LATEX_dotsize*LATEX_UNIT);
X    			LATEX_moved = TRUE;
X		  } else {
X			/* higher than long */
X			y = min(abs(dy),(0.25+abs(slope))*LATEX_dotsize);
X			offset = sign(dx)*min(LATEX_dotsize,abs(dx));
X			dx = dx - offset;
X			length = y*LATEX_UNIT;
X			inc = (y == abs(dy) ? 1 : max(1,abs(dx)/TINY_STEP+0.5));
X			if (inc == 1) {
X		     fprintf(outfile,"\\put(%.2f,%u){\\rule{%.3fpt}{%.3fpt}}\n",
X			 ((float)x1+x2-LATEX_dotsize)/2, (y2>=y1? y1 : y2),
X			 LATEX_dotsize*LATEX_UNIT, length);
X			} else {
X			  dx = dx/inc;
X			  dy = (dy-sign(dy)*y)/(inc-1);
Xfprintf(outfile,"\\multiput(%.2f,%.2f)(%.3f,%.3f){%u}{\\rule{%.3fpt}{%.3fpt}}\n",
X			   (float)x1-(abs(dx)-offset)/2, 
X			   (dy>=0? (float)y1 : y1-y), 
X			   dx, dy, inc, abs(dx)*LATEX_UNIT, length);
X			}
X/* done with one section, now smooth it */
X			y = y/2;
X			dx = (float)x2 - x1;
X			dy = sign(dy) * y;
X			dy = (float)y2 - y1 - dy;
Xfprintf(outfile,"\\multiput(%.2f,%.2f)(%.3f,%.3f){2}{\\rule{%.3fpt}{%.3fpt}}\n",
X			 (float)x1-LATEX_dotsize/2, (dy>=0.0? (float)y1 : y1-y),
X			 dx, dy, LATEX_dotsize*LATEX_UNIT, y*LATEX_UNIT);
X    			LATEX_moved = TRUE;
X		  }
X	   }
X    }
X}
X
X/* Draw a \rule. Width or height may be negative; we can correct.
X * The rule is never output immediately. The previous rule is output
X * as-is if code is 0, and the previous rule is
X * combined with the current rule (if possible) if code is 1.
X * The previous rule is output, and the new one ignored, if code is 2.
X */
Xstatic void
XLATEX_rule(code, x,y, width, height)
X	int code;				/* how do we treat this rule? */
X	double x, y;
X	double width;
X	double height;
X{  
X    static float lastx, lasty;
X    static float lastw, lasth;
X    static TBOOLEAN valid = FALSE; /* is 'last' data valid? */
X    TBOOLEAN combine = (code == 1);
X    TBOOLEAN flush = (code == 2);
X
X    if (!flush)
X	 if (width == 0 || height == 0)
X	   return;			/* ignore this rule */
X
X    if (valid && combine) {
X	   /* try to combine new rule with old rule */
X	   if ((int)lastx == (int)x && lastw == width) { /* vertical rule */
X		  if (lasth * height >= 0) { /* same sign */
X			 lasth += height;
X			 return;
X		  }
X	   } else if ((int)lasty == (int)y && lasth == height){ /* horiz rule */
X		  if (lastw * width >= 0) { /* same sign */
X			 lastw += width;
X			 return;
X		  }
X	   }
X	   /* oh well, output last and remember the new one */
X    }
X
X    if (valid) {
X	   /* output the rule */
X	   if (lastw < 0) {
X		  lastx += lastw;
X		  lastw = -lastw;
X	   }
X	   if (lasth < 0) {
X		  lasty += lasth;
X		  lasth = -lasth;
X	   }
X
X	   /* if very small use canned dot */
X	   if (lastw < LATEX_dotsize || lasth < LATEX_dotsize)
X		fprintf(outfile, "\\put(%.1f,%.1f){%s}\n",	   
X			   lastx, lasty, LATEX_DOT);
X	   else
X		fprintf(outfile, "\\put(%.1f,%.1f){\\rule[%.3fpt]{%.3fpt}{%.3fpt}}\n",
X			   lastx, lasty, -LATEX_dotsize*LATEX_UNIT/2,
X			   lastw*LATEX_UNIT, lasth*LATEX_UNIT);
X    }
X    
X    if (flush) {
X	   valid = FALSE;
X    } else {
X	   lastx = x; lasty = y;
X	   lastw = width; lasth = height;
X	   valid = TRUE;
X    }
X}
X
Xstatic void
XLATEX_dot_line(x1,x2, y1,y2)
X	int x1,x2, y1,y2;
X{
X    static float LATEX_left;	/* fraction of space left after last dot */
X#ifndef AMIGA_AC_5
X    extern double sqrt();
X#endif
X    /* we draw a dotted line using the current dot spacing */
X
X    if (LATEX_moved)
X	 LATEX_left = 1.0;		/* reset after a move */
X
X    /* zero-length line? */
X    if (x1 == x2 && y1 == y2) {
X	   if (LATEX_moved)
X		/* plot a dot */
X		fprintf(outfile, "\\put(%u,%u){%s}\n", x1, y1, LATEX_DOT);
X    } else {
X	   float dotspace = LATEX_dotspace / LATEX_UNIT;
X	   float x,y;			/* current position */
X	   float xinc, yinc;	/* increments */
X	   float slope;		/* slope of line */
X	   float lastx = -1;	/* last x point plotted */
X	   float lasty = -1;	/* last y point plotted */
X	   int numdots = 0;	/* number of dots in this section */
X
X	   /* first, figure out increments for x and y */
X	   if (x2 == x1) {
X		  xinc = 0.0;
X		  yinc = (y2-y1>0)?dotspace:-dotspace;
X	   } else {
X		  slope = ((float)y2-y1)/((float)x2-x1);
X		  xinc = dotspace / sqrt(1 + slope*slope) * sign(x2-x1);
X		  yinc = slope * xinc;
X	   }
X	   
X	   /* now draw the dotted line */
X	   /* we take into account where we last placed a dot */
X	   for (x=x1 + xinc*(1-LATEX_left), y=y1 + yinc*(1-LATEX_left);
X		   (x2-x)*xinc >= 0 && (y2-y)*yinc >= 0; /* same sign or zero */
X		   lastx = x, x += xinc, 
X		   lasty = y, y += yinc)
X		numdots++;
X	   if (numdots == 1)
X		fprintf(outfile, "\\put(%.2f,%.2f){%s}\n",
X		   lastx, lasty, LATEX_DOT);
X	   else
X		fprintf(outfile, "\\multiput(%u,%u)(%.3f,%.3f){%u}{%s}\n",
X			   x1, y1, xinc, yinc, numdots, LATEX_DOT);
X
X	   /* how much is left over, as a fraction of dotspace? */
X	   if (xinc != 0.0)			/* xinc must be nonzero */
X		if (lastx >= 0)
X		  LATEX_left = abs(x2 - lastx) / abs(xinc);
X		else
X		  LATEX_left += abs(x2-x1) / abs(xinc);
X	   else
X		if (lasty >= 0)
X		  LATEX_left = abs(y2 - lasty) / abs(yinc);
X		else
X		  LATEX_left += abs(y2-y1) / abs(yinc);
X    }
X
X    LATEX_needsdot = (LATEX_left > 0);
X
X    LATEX_moved = FALSE;
X}
X
Xstatic void
XLATEX_flushdot()
X{
X    if (LATEX_needsdot) 
X	 fprintf(outfile, "\\put(%d,%d){%s}\n", 
X		    LATEX_posx, LATEX_posy, LATEX_DOT);
X    LATEX_needsdot = FALSE;
X}
X
XLATEX_arrow(sx,sy, ex,ey, head)
X	int sx,sy, ex,ey;
X	TBOOLEAN head;
X{
X    best_latex_arrow(sx,sy, ex,ey, 1, head);
X
X    LATEX_posx = ex;
X    LATEX_posy = ey;
X}
X
Xstatic void best_latex_arrow(sx,sy, ex,ey, who, head)
X	int sx,sy, ex,ey;		/* start and end points */
X	int who;				/* 1=LATEX, 2=EEPIC */
X	TBOOLEAN head;
X{
X    int dx = ex - sx;
X    int dy = ey - sy;
X    float m;				/* slope of line */
X    float arrowslope;		/* slope of arrow */
X    float minerror = 0;		/* best-case error */
X    struct vslope *slope;	/* one of the slopes */
X    struct vslope *bestslope;	/* the slope with min error */
X
X    /* We try to draw a real arrow (ie, \vector). If we can't get
X	* a slope that is close, we draw a bent arrow.
X	*/
X
X    if (dx == 0) {
X	   /* vertical arrow */
X	   fprintf(outfile, "\\put(%d,%d){\\%s(0,%d){%d}}\n",
X			 sx, sy, head ? "vector":"line", 
X			 sign(ey-sy), abs(ey-sy));
X    } else if (dy == 0) {
X	   /* horizontal arrow */
X	   fprintf(outfile, "\\put(%d,%d){\\%s(%d,0){%d}}\n",
X			 sx, sy, head ? "vector":"line",
X			 sign(ex-sx), abs(ex-sx));
X    } else {
X	   /* Slanted arrow. We'll give it a try.
X	    * we try to find the closest-slope arrowhead.
X	    */
X	   bestslope = NULL;
X	   minerror = 0; /* to shut up turbo C */
X	   m = abs((float)dy/dx); /* the slope we want */
X	   for (slope = LATEX_slopes; slope->dx != 0.0; slope++) {
X		  /* find the slope of the arrow */
X		  arrowslope = (float) slope->dy / slope->dx;
X		  if (bestslope == NULL || abs(m-arrowslope) < minerror) {
X			 minerror = abs(m-arrowslope);
X			 bestslope = slope;
X		  }
X	   }
X
X	   /* now we have the best slope arrow */
X	   /* maybe it's exactly the right slope! */
X	   if (minerror == 0.0)	/* unlikely but possible */
X		fprintf(outfile, "\\put(%d,%d){\\%s(%d,%d){%d}}\n",
X			   sx, sy, head ? "vector" : "line",
X			   bestslope->dx*sign(ex-sx), bestslope->dy*sign(ey-sy),
X			   abs(ex-sx));
X	   else {
X		  /* we draw the line the usual way, with thin lines */
X#ifdef EMTEX
X		  if (emtex) {
X			 LATEX_linetype(LATEX_THIN_LINE);
X			 EMTEX_solid_line(sx,ex,sy,ey);
X		  } else 
X#endif
X			if (who == 1) {
X			   LATEX_linetype(LATEX_THIN_LINE);
X			   LATEX_solid_line(sx,ex,sy,ey);
X			}
X#ifdef EEPIC
X			else {
X			   EEPIC_move(sx,sy);
X			   EEPIC_vector(ex,ey);
X			}
X#endif /* EEPIC */
X		  /* and then draw an arrowhead (a short vector) there */
X			if (head)
X		  		fprintf(outfile, "\\put(%d,%d){\\vector(%d,%d){0}}\n",
X				ex, ey, 
X				bestslope->dx*sign(ex-sx), bestslope->dy*sign(ey-sy));
X	   }
X    }
X}
X
XLATEX_put_text(x, y, str)
X    int x,y;            /* reference point of string */
X    char str[];         /* the text */
X{
X    static char *justify[] = { "[l]", "", "[r]" };
X    int flag,i;
X
X    /* ignore empty strings */
X    if (str[0] == '\0')
X        return(0);
X
X    for (flag=FALSE,i=0; str[i] && !flag;)
X        flag = (str[i++] == '\\') && (str[i++] == '\\');
X
X    fprintf(outfile, "\\put(%d,%d)", x, y);
X    if (flag)
X        fprintf(outfile, "{\\makebox(0,0)%s{\\shortstack{%s}}}\n",
X            justify[latex_justify], str);
X    else
X        fprintf(outfile, "{\\makebox(0,0)%s{%s}}\n",
X            justify[latex_justify], str);
X}
X
Xint LATEX_justify_text(mode)
X	enum JUSTIFY mode;
X{
X    latex_justify = mode;
X    return (TRUE);
X}
X
Xint LATEX_text_angle(angle)
X	int angle;
X{
X    /* we can't really write text vertically, but this will 
X	  put the ylabel centred at the left of the plot, and
X	  then we'll make a \shortstack */
X    latex_angle = angle;
X    return (TRUE);
X}
X
XLATEX_reset()
X{
X    LATEX_posx = LATEX_posy = 0; /* current position */
X    LATEX_moved = TRUE;	/* pen is up after move */
X}
X
X
X#ifdef EMTEX
X
XEMTEX_init()
X{
X    emtex=TRUE;
X    LATEX_posx = LATEX_posy = 0;
X    fprintf(outfile, "%% GNUPLOT: LaTeX picture with emtex specials\n");
X    fprintf(outfile, "\\setlength{\\unitlength}{%fpt}\n", LATEX_UNIT);
X    fprintf(outfile, 
X		  "\\ifx\\plotpoint\\undefined\\newsavebox{\\plotpoint}\\fi\n");
X    LATEX_linetype(-1);
X}
X
X
XEMTEX_reset()
X{
X    emtex=FALSE;
X    LATEX_posx = LATEX_posy = 0;
X}
X
X
XEMTEX_text()
X{
X    fprintf(outfile, "\\end{picture}\n");
X}
X
X
Xstatic void
XEMTEX_solid_line(x1,x2, y1,y2)
X	int x1,x2, y1,y2;
X{
X    /* emtex special solid line */
X	if (LATEX_moved)
X		fprintf(outfile, "\\put(%d,%d){\\special{em:moveto}}\n", x1, y1);
X	if ( (x1!=x2) || (y1!=y2) )
X		fprintf(outfile, "\\put(%d,%d){\\special{em:lineto}}\n", x2, y2);
X    LATEX_posx = x2;
X    LATEX_posy = y2;
X    LATEX_moved = FALSE;
X}
X
X
X#endif /* EMTEX */
END_OF_FILE
  if test 20098 -ne `wc -c <'gnuplot/term/latex.trm'`; then
    echo shar: \"'gnuplot/term/latex.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/latex.trm'
fi
if test -f 'gnuplot/term/metafont.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/metafont.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/metafont.trm'\" \(14593 characters\)
  sed "s/^X//" >'gnuplot/term/metafont.trm' <<'END_OF_FILE'
X/*
X * $Id: metafont.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/*
X *			  GNUPLOT -- mf.trm
X *
X *		    This terminal driver supports:
X *		       Metafont Plot Commands
X *
X * Written by : Pl Hedne
X *		Trondheim, Norway
X *		Pal.Hedne@termo.unit.no
X */
X
X/*
X * Improvements and bug fixes by Carsten Steger:
X * - Set default plot size to 5 by 3 inches as in the latex- and eepic-
X *   drivers
X * - Fixed some bugs concerning resolution dependent output
X * - Added MF_scale function
X * - Added MF_justify_text function and modified MF_put_text function and
X *   put_text macro accordingly
X * - Modified MF_move and MF_vector to make output shorter and modified
X *   MF_text accordingly
X * - Added various linetypes by plotting dashed lines; had to modify
X *   MF_linetype and MF_vector for this
X * - Added MF_arrow function
X * - All global variables and #define'd names begin with MF_ now
X * As a consequence almost nothing of the original code by Pl Hedne remains
X * but credit goes to him for the ingenious trick of storing the character
X * images into picture variables, without which this driver would have been
X * impossible for me to write.
X */
X
X#define MF_DPI (300)
X/* resolution of printer we expect to use; the value itself is not
X * particularly important... it is here only for compatibility to the
X * LaTeX-driver and to get the spacing right. */
X
X/* 5 inches wide by 3 inches high (default) */
X#define MF_XSIZE 5.0
X#define MF_YSIZE 3.0
X#define MF_XMAX (MF_XSIZE*MF_DPI)
X#define MF_YMAX (MF_YSIZE*MF_DPI)
X
X#define MF_HTIC (5*MF_DPI/72)
X#define MF_VTIC (5*MF_DPI/72)
X#define MF_HCHAR (MF_DPI*53/10/72)
X#define MF_VCHAR (MF_DPI*11/72)
X
X/* Plot size in inches */
Xstatic double MF_xsize = MF_XSIZE;
Xstatic double MF_ysize = MF_YSIZE;
Xstatic int MF_char_code;
Xstatic int MF_ang;
Xstatic int MF_line_type;
Xstatic enum JUSTIFY MF_justify;
Xstatic double MF_dist_left;
Xstatic int MF_is_solid;
Xstatic int MF_picked_up_pen;
X/* 
X * We keep track of where we are with respect to dashed lines by using
X * the next five variables. MF_dash_index indicates which element of
X * MF_lines[..].dashlen should be used. The MF_last.. variables keep
X * track of the position of the pen.
X */
Xstatic int MF_dash_index;
Xstatic unsigned int MF_last_x, MF_last_y;
X
Xstatic struct {
X  int solid;         /* Is the line solid? */
X  float thickness;   /* Thickness of pen we are going to use */
X  int dashlen[4];    /* Length of individual segments; even: line; odd: gap */
X} MF_lines[10] = {
X  {1,1.5,0,0,0,0},
X  {0,1.0,MF_DPI/60,MF_DPI/50,MF_DPI/60,MF_DPI/50},
X  {1,1.5,0,0,0,0},
X  {0,1.5,MF_DPI/20,MF_DPI/30,MF_DPI/20,MF_DPI/30},
X  {0,1.5,MF_DPI/30,MF_DPI/20,MF_DPI/30,MF_DPI/20},
X  {0,1.5,MF_DPI/15,MF_DPI/30,MF_DPI/60,MF_DPI/30},
X  {0,1.5,MF_DPI/30,MF_DPI/50,MF_DPI/30,MF_DPI/50},
X  {0,1.5,MF_DPI/20,MF_DPI/50,MF_DPI/60,MF_DPI/30},
X  {0,1.5,MF_DPI/30,MF_DPI/50,MF_DPI/30,MF_DPI/30},
X  {0,1.5,MF_DPI/60,MF_DPI/50,MF_DPI/60,MF_DPI/30}
X  /* dash: line,     gap,      line,     gap      */
X};
X
X
X
Xint MF_init ()
X{
X  MF_char_code = 0;
X  MF_ang = 0;
X
X  fputs ("if unknown cmbase: input cmbase fi\n\n", outfile);
X  fputs ("tracingstats:=1;\n", outfile);
X  fputs ("picture r[];\n", outfile);
X  fputs ("\ndef openit = openwindow currentwindow\n", outfile);
X  fputs ("  from (0,0) to (400,800) at (-50,500) enddef;\n", outfile);
X
X  fputs ("\nmode_setup;\n", outfile);
X
X  fputs ("\n%Include next eight lines if you have problems with the mode on your system..\n", outfile);
X  fputs ("%proofing:=0;\n", outfile);
X  fputs ("%fontmaking:=1;\n", outfile);
X  fputs ("%tracingtitles:=0;\n", outfile);
X  fputs ("%pixels_per_inch:=300;\n", outfile);
X  fputs ("%blacker:=0;\n", outfile);
X  fputs ("%fillin:=.2;\n", outfile);
X  fputs ("%o_correction:=.6;\n", outfile);
X  fputs ("%fix_units;\n", outfile);
X
X  /* Next lines must be included if text support is needed (CM base used) */
X  fputs ("\ndef put_text(expr ts,xstart,ystart,rot,justification) =\n", outfile);
X  fputs ("  begingroup\n", outfile);
X  fputs ("    text_width:=0;text_height:=0;\n", outfile);
X  fputs ("    for ind:=0 step 1 until length(ts)-1:\n", outfile);
X  fputs ("      dec_num:=ASCII substring (ind,ind+1) of ts;\n", outfile);
X  fputs ("      if unknown r[dec_num]: dec_num:=32; fi\n", outfile);
X  fputs ("      if dec_num=32: \n", outfile);
X  fputs ("        text_width:=text_width+wd[65];\n", outfile);
X  fputs ("        text_height:=max(text_height,ht[65]+dp[65]);\n", outfile);
X  fputs ("      elseif dec_num>=0: \n", outfile);
X  fputs ("        text_width:=text_width+wd[dec_num];\n", outfile);
X  fputs ("        text_height:=max(text_height,ht[dec_num]+dp[dec_num]);\n", outfile);
X  fputs ("      fi\n", outfile);
X  fputs ("    endfor\n", outfile);
X  fputs ("    if rot=90:\n", outfile);
X  fputs ("      if justification=1: ynext:=ystart;\n", outfile);
X  fputs ("      elseif justification=2: ynext:=round(ystart-text_width/2);\n", outfile);
X  fputs ("      else: ynext:=round(ystart-text_width);\n", outfile);
X  fputs ("      fi\n", outfile);
X  fputs ("      xnext:=xstart+text_height/2;\n", outfile);
X  fputs ("    else:\n", outfile);
X  fputs ("      if justification=1: xnext:=xstart;\n", outfile);
X  fputs ("      elseif justification=2: xnext:=round(xstart-text_width/2);\n", outfile);
X  fputs ("      else: xnext:=round(xstart-text_width);\n", outfile);
X  fputs ("      fi\n", outfile);
X  fputs ("      ynext:=ystart-text_height/2;\n", outfile);
X  fputs ("    fi\n", outfile);
X  fputs ("    for ind:=0 step 1 until length(ts)-1:\n", outfile);
X  fputs ("      dec_num:=ASCII substring (ind,ind+1) of ts;\n", outfile);
X  fputs ("      if unknown r[dec_num]: dec_num:=32; fi\n", outfile);
X  fputs ("      if dec_num=32: \n", outfile);
X  fputs ("        xnext:=xnext+wd[65]*cosd rot;\n", outfile);
X  fputs ("        ynext:=ynext+wd[65]*sind rot;\n", outfile);
X  fputs ("      elseif dec_num>=0: \n", outfile);
X  fputs ("        currentpicture:=currentpicture+r[dec_num] shifted(xnext,ynext)\n", outfile);
X  fputs ("          rotatedaround ((xnext,ynext),rot); \n", outfile);
X  fputs ("        xnext:=xnext+wd[dec_num]*cosd rot;\n", outfile);
X  fputs ("        ynext:=ynext+wd[dec_num]*sind rot;\n", outfile);
X  fputs ("      fi\n", outfile);
X  fputs ("    endfor\n", outfile);
X  fputs ("  endgroup \n", outfile);
X  fputs ("enddef;\n", outfile);
X
X  fputs ("\ndef endchar =\n", outfile);
X  fputs ("  r[charcode]:=currentpicture;\n", outfile);
X  fputs ("  wd[charcode]:=w;ht[charcode]:=h;dp[charcode]:=d;\n", outfile);
X  fputs ("  message \"Picture of charcode no.\" & decimal charcode;\n", outfile);
X  fputs ("  endgroup;\n", outfile);
X  fputs ("enddef;\n", outfile);
X  fputs ("let endchar_ = endchar;\n", outfile);
X  fputs ("let generate = relax;\n", outfile);
X  fputs ("let roman = relax;\n", outfile);
X
X  fputs ("input cmr10.mf\n", outfile);
X  fputs ("if ligs>1: font_coding_scheme:=\"TeX text\";\n", outfile);
X  fputs ("  spanish_shriek=oct\"074\"; spanish_query=oct\"076\";\n", outfile);
X  fputs ("else: font_coding_scheme:=\n", outfile);
X  fputs ("  if ligs=0: \"TeX typewriter text\"\n", outfile);
X  fputs ("  else: \"TeX text without f-ligatures\" fi;\n", outfile);
X  fputs ("  spanish_shriek=oct\"016\"; spanish_query=oct\"017\"; fi\n", outfile);
X  fputs ("font_setup;\n", outfile);
X  fputs ("input romanu.mf %Roman uppercase.\n", outfile);
X  fputs ("input romanl.mf %Roman lowerrcase.\n", outfile);
X  fputs ("input greeku.mf %Greek uppercase.\n", outfile);
X  fputs ("input romand.mf %Numerals.\n", outfile);
X  fputs ("input romanp.mf %Ampersand, question marks, currency sign.\n", outfile);
X  fputs ("input romspl.mf %Lowercase specials (dotless \\i, ligature \\ae, etc.)\n", outfile);
X  fputs ("input romspu.mf %Uppercase specials (\\AE, \\OE, \\O)\n", outfile);
X  fputs ("input punct.mf %Punctuation symbols.\n", outfile);
X  fputs ("\nminus=ASCII\"-\"; cmchar \"Minus sign\";\n", outfile);
X  fputs ("beginarithchar(minus); \n", outfile);
X  fputs ("  pickup rule.nib;\n", outfile);
X  fputs ("  lft x1=hround 1.5u-eps;\n", outfile);
X  fputs ("  x2=w-x1; y1=y2=math_axis;\n", outfile);
X  fputs ("  draw z1--z2;	 % bar\n", outfile);
X  fputs ("  labels(1,2); \n", outfile);
X  fputs ("endchar;\n", outfile);
X
X  fputs ("\ncmchar \"Period\";\n", outfile);
X  fputs ("  numeric dot_diam#; dot_diam#:=if monospace: 5/4 fi\\ dot_size#;\n", outfile);
X  fputs ("  define_whole_blacker_pixels(dot_diam);\n", outfile);
X  fputs ("  beginchar(\".\",5u#,dot_diam#,0);\n", outfile);
X  fputs ("  adjust_fit(0,0); pickup fine.nib;\n", outfile);
X  fputs ("  pos1(dot_diam,0); pos2(dot_diam,90);\n", outfile);
X  fputs ("  lft x1l=hround(.5w-.5dot_diam); bot y2l=0; z1=z2; dot(1,2);	% dot\n", outfile);
X  fputs ("  penlabels(1,2);\n", outfile);
X  fputs ("endchar;\n", outfile);
X
X  fputs ("\ndef endchar =\n", outfile);
X  fputs ("  % Next line should probably be removed if CM base is used\n", outfile);
X  fputs ("  l:=0; r:=w;\n", outfile);
X  fputs ("  %Include the next two lines if you want to\n", outfile);
X  fputs ("  %rotate the picture 90 deg.(Portrait to Landscape)\n", outfile);
X  fputs ("  %currentpicture:=currentpicture rotated 90 shifted (h,0);\n", outfile);
X  fputs ("  %tmp:=charht; charht:=charwd; charwd:=tmp;\n", outfile);
X  fputs ("  scantokens extra_endchar;\n", outfile);
X  fputs ("  if proofing>0: makebox(proofrule); fi\n", outfile);
X  fputs ("  chardx:=w;\n", outfile);
X  fputs ("  shipit;\n", outfile);
X  fputs ("  if displaying>0: makebox(screenrule); showit; fi\n", outfile);
X  fputs ("  endgroup \n", outfile);
X  fputs ("enddef;\n", outfile);
X  fputs ("let endchar_ = endchar;\n", outfile);
X  fputs ("let generate = input;\n", outfile);
X  fputs ("let roman = roman;\n", outfile);
X
X  fputs ("\n\nfont_identifier:=\"GNUPLOT\";\n", outfile);
X  /* font_size must be bigger than em#/16 by METAFONT rules.
X   * Therefore make it pretty big so big figures will be
X   * handled correctly. Setting font_size to 72pt# lets us
X   * handle characters up to 15.94 by 15.94 inches. */
X  fputs ("font_size 72pt#;\n", outfile);
X  fputs ("th#=0.4pt#; define_whole_pixels(th);\n", outfile);
X  fputs ("\npath arrowhead;\n", outfile);
X  fputs ("arrowhead = (-7pt,-2pt){dir30}..(-6pt,0pt)..", outfile);
X  fputs ("{dir150}(-7pt,2pt) &\n", outfile);
X  fputs ("  (-7pt,2pt)--(0pt,0pt)--(-7pt,-2pt) & cycle;\n", outfile);
X}
X
X
Xint MF_graphics ()
X{
X  register struct termentry *t = &term_tbl[term];
X
X  fprintf (outfile, "\n\nbeginchar(%d,%gin#,%gin#,0);\n",
X           MF_char_code, MF_xsize, MF_ysize);
X  MF_char_code++;
X  fprintf (outfile, "a:=w/%d;b:=h/%d;\n", t->xmax, t->ymax);
X  MF_picked_up_pen = 0;
X}
X
X
Xint MF_text ()
X{
X  fprintf (outfile, "endchar;\n");
X}
X
X
Xint MF_justify_text (mode)
Xenum JUSTIFY mode;
X{
X  MF_justify = mode;
X  return TRUE;
X}
X
X
Xint MF_text_angle (ang)
Xint ang;
X{
X  if (ang > 0) MF_ang = 90;
X  else MF_ang = 0;
X  return TRUE;
X}
X
X
Xint MF_linetype (linetype)
Xint linetype;
X{
X  if (linetype >=8) linetype %= 8;
X  linetype += 2;
X  /* Only output change in pens if it actually affects the pen used */
X  if ((MF_lines[linetype].thickness != MF_lines[MF_line_type].thickness) ||
X      (!MF_picked_up_pen)) {
X    fprintf (outfile, "pickup pencircle scaled %gth;\n",
X             MF_lines[linetype].thickness);
X    MF_picked_up_pen = 1;
X  }
X  MF_line_type = linetype;
X  MF_dash_index = 0;
X  MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
X  MF_is_solid = MF_lines[MF_line_type].solid;
X}
X
X
Xint MF_scale (xs, ys)
Xdouble xs, ys;
X{
X  struct termentry *t = &term_tbl[term];
X
X  t->xmax = (unsigned int) (MF_XMAX * xs);
X  t->ymax = (unsigned int) (MF_YMAX * ys);
X  MF_xsize = MF_XSIZE * xs;
X  MF_ysize = MF_YSIZE * ys;
X  return TRUE;
X}
X
X
Xint MF_move (x, y)
Xunsigned int x, y;
X{
X  MF_last_x = x;
X  MF_last_y = y;
X  MF_dash_index = 0;
X  MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
X}
X
X
Xint MF_vector (x, y)
Xunsigned int x, y;
X{
X  double sqrt(), floor();
X
X  if (MF_is_solid) {
X    if (x == MF_last_x && y == MF_last_y)
X      fprintf (outfile, "drawdot (%da,%db);\n", x, y);
X    else
X      fprintf (outfile, "draw (%da,%db)--(%da,%db);\n",
X               MF_last_x, MF_last_y, x, y);
X  } else {
X    double dist_to_go, delta_x, delta_y, inc_x, inc_y;
X    double last_x_d, last_y_d, next_x_d, next_y_d;
X    unsigned int next_x, next_y;
X
X    if (x == MF_last_x && y == MF_last_y) {
X      if (! (MF_dash_index & 1))
X        fprintf (outfile, "drawdot (%da,%db);\n", x, y);
X    } else {
X      last_x_d = MF_last_x;
X      last_y_d = MF_last_y;
X      delta_x = x - last_x_d;
X      delta_y = y - last_y_d;
X      dist_to_go = sqrt (delta_x * delta_x + delta_y * delta_y);
X      inc_x = delta_x / dist_to_go;
X      inc_y = delta_y / dist_to_go;
X      while (MF_dist_left < dist_to_go) {
X        next_x_d = last_x_d + inc_x * MF_dist_left;
X        next_y_d = last_y_d + inc_y * MF_dist_left;
X        next_x = floor (next_x_d + 0.5);
X        next_y = floor (next_y_d + 0.5);
X        /* MF_dash_index & 1 == 0 means: draw a line; otherwise just move */
X        if (! (MF_dash_index & 1))
X          fprintf (outfile, "draw (%da,%db)--(%da,%db);\n",
X                   MF_last_x, MF_last_y, next_x, next_y);
X        MF_last_x = next_x;
X        MF_last_y = next_y;
X        last_x_d = next_x_d;
X        last_y_d = next_y_d;
X        dist_to_go -= MF_dist_left;
X        MF_dash_index = (MF_dash_index + 1) & 3;
X        MF_dist_left = MF_lines[MF_line_type].dashlen[MF_dash_index];
X      }
X      delta_x = x - last_x_d;
X      delta_y = y - last_y_d;
X      MF_dist_left -= sqrt (delta_x * delta_x + delta_y * delta_y);
X      if (! (MF_dash_index & 1)) {
X        if (x == MF_last_x && y == MF_last_y)
X          fprintf (outfile, "drawdot (%da,%db);\n", x, y);
X        else
X          fprintf (outfile, "draw (%da,%db)--(%da,%db);\n",
X                   MF_last_x, MF_last_y, x, y);
X      }
X    }
X  }
X  MF_last_x = x;
X  MF_last_y = y;
X}
X
X
Xint MF_arrow (sx, sy, ex, ey, head)
Xunsigned int sx, sy, ex, ey;
XTBOOLEAN head;
X{
X  int delta_x, delta_y;
X
X  MF_move (sx, sy);
X  MF_vector (ex, ey);
X  if (head) {
X    delta_x = ex - sx;
X    delta_y = ey - sy;
X    fprintf (outfile, "fill arrowhead rotated angle(%d,%d) shifted (%da,%db);\n",
X             delta_x, delta_y, ex, ey);
X  } 
X}
X
X
Xint MF_put_text (x, y, str)
Xunsigned int x, y;
Xchar *str;
X{
X  int i, j;
X
X  for (i = 0; i < strlen (str); i++)
X    if (str[i] == '"')
X      str[i] = '\'';		/* Replace " with ' */
X  switch (MF_justify) {
X    case LEFT:
X      j = 1;
X      break;
X    case CENTRE:
X      j = 2;
X      break;
X    case RIGHT:
X      j = 3;
X      break;
X  }
X  fprintf (outfile, "put_text(\"%s\",%da,%db,%d,%d);\n",
X           str, x, y, MF_ang, j);
X}
X
X
Xint MF_reset ()
X{
X  fprintf (outfile, "end.\n");
X}
END_OF_FILE
  if test 14593 -ne `wc -c <'gnuplot/term/metafont.trm'`; then
    echo shar: \"'gnuplot/term/metafont.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/metafont.trm'
fi
echo shar: End of archive 18 \(of 33\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
