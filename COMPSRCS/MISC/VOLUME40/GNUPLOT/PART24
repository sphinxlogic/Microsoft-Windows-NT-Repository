Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i036:  gnuplot - interactive function plotting utility, Part24/33
Message-ID: <1993Oct22.163905.24742@sparky.sterling.com>
X-Md4-Signature: b976a75cd41faeed91c6246da9bdd4b6
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:39:05 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 36
Archive-name: gnuplot/part24
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/glass.dat gnuplot/demo/surface2.dem
#   gnuplot/docs/doc2rtf.c gnuplot/os2/gnupmdrv.itl
#   gnuplot/term/amiga.trm gnuplot/term/dxf.trm gnuplot/term/rgip.trm
#   gnuplot/term/x11.trm gnuplot/win/winmain.c
# Wrapped by kent@sparky on Wed Oct 20 17:14:57 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 24 (of 33)."'
if test -f 'gnuplot/demo/glass.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/glass.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/glass.dat'\" \(8596 characters\)
  sed "s/^X//" >'gnuplot/demo/glass.dat' <<'END_OF_FILE'
X#
X# $Id: glass.dat 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X# 16x16 grid Glass shape. Created Using DRAWFN3D, Gershon Elber 1990.
X#
X  0.568000   0.000000  -0.911000
X  0.518894   0.231026  -0.911000
X  0.380066   0.422106  -0.911000
X  0.175522   0.540200  -0.911000
X -0.059372   0.564888  -0.911000
X -0.284000   0.491902  -0.911000
X -0.459522   0.333862  -0.911000
X -0.555588   0.118094  -0.911000
X -0.555588  -0.118094  -0.911000
X -0.459522  -0.333862  -0.911000
X -0.284000  -0.491902  -0.911000
X -0.059372  -0.564888  -0.911000
X  0.175522  -0.540200  -0.911000
X  0.380066  -0.422106  -0.911000
X  0.518894  -0.231027  -0.911000
X  0.568000  -0.000000  -0.911000
X
X  0.341741   0.000000  -0.905215
X  0.312196   0.138999  -0.905215
X  0.228669   0.253963  -0.905215
X  0.105604   0.325015  -0.905215
X -0.035722   0.339869  -0.905215
X -0.170870   0.295956  -0.905215
X -0.276474   0.200870  -0.905215
X -0.334273   0.071052  -0.905215
X -0.334273  -0.071052  -0.905215
X -0.276474  -0.200870  -0.905215
X -0.170871  -0.295956  -0.905215
X -0.035722  -0.339869  -0.905215
X  0.105604  -0.325015  -0.905215
X  0.228669  -0.253963  -0.905215
X  0.312196  -0.138999  -0.905215
X  0.341741  -0.000000  -0.905215
X
X  0.212153   0.000000  -0.863178
X  0.193812   0.086290  -0.863178
X  0.141958   0.157661  -0.863178
X  0.065559   0.201770  -0.863178
X -0.022176   0.210991  -0.863178
X -0.106077   0.183730  -0.863178
X -0.171636   0.124701  -0.863178
X -0.207517   0.044109  -0.863178
X -0.207517  -0.044109  -0.863178
X -0.171636  -0.124701  -0.863178
X -0.106077  -0.183730  -0.863178
X -0.022176  -0.210991  -0.863178
X  0.065559  -0.201770  -0.863178
X  0.141958  -0.157661  -0.863178
X  0.193812  -0.086291  -0.863178
X  0.212153  -0.000000  -0.863178
X
X  0.138097   0.000000  -0.764660
X  0.126157   0.056169  -0.764660
X  0.092405   0.102626  -0.764660
X  0.042674   0.131338  -0.764660
X -0.014435   0.137340  -0.764660
X -0.069048   0.119595  -0.764660
X -0.111722   0.081171  -0.764660
X -0.135079   0.028712  -0.764660
X -0.135079  -0.028712  -0.764660
X -0.111722  -0.081171  -0.764660
X -0.069048  -0.119595  -0.764660
X -0.014435  -0.137340  -0.764660
X  0.042674  -0.131338  -0.764660
X  0.092405  -0.102626  -0.764660
X  0.126157  -0.056169  -0.764660
X  0.138097  -0.000000  -0.764660
X
X  0.098588   0.000000  -0.618872
X  0.090065   0.040099  -0.618872
X  0.065968   0.073265  -0.618872
X  0.030465   0.093763  -0.618872
X -0.010305   0.098048  -0.618872
X -0.049294   0.085380  -0.618872
X -0.079760   0.057949  -0.618872
X -0.096434   0.020498  -0.618872
X -0.096434  -0.020498  -0.618872
X -0.079760  -0.057949  -0.618872
X -0.049294  -0.085380  -0.618872
X -0.010305  -0.098048  -0.618872
X  0.030465  -0.093763  -0.618872
X  0.065968  -0.073265  -0.618872
X  0.090065  -0.040099  -0.618872
X  0.098588  -0.000000  -0.618872
X
X  0.084164   0.000000  -0.452254
X  0.076887   0.034232  -0.452254
X  0.056317   0.062546  -0.452254
X  0.026008   0.080044  -0.452254
X -0.008798   0.083703  -0.452254
X -0.042082   0.072888  -0.452254
X -0.068090   0.049470  -0.452254
X -0.082325   0.017499  -0.452254
X -0.082325  -0.017499  -0.452254
X -0.068090  -0.049470  -0.452254
X -0.042082  -0.072888  -0.452254
X -0.008798  -0.083703  -0.452254
X  0.026008  -0.080045  -0.452254
X  0.056317  -0.062546  -0.452254
X  0.076887  -0.034233  -0.452254
X  0.084164  -0.000000  -0.452254
X
X  0.092386   0.000000  -0.291706
X  0.084399   0.037577  -0.291706
X  0.061819   0.068656  -0.291706
X  0.028549   0.087865  -0.291706
X -0.009657   0.091880  -0.291706
X -0.046193   0.080009  -0.291706
X -0.074742   0.054303  -0.291706
X -0.090368   0.019208  -0.291706
X -0.090368  -0.019208  -0.291706
X -0.074742  -0.054303  -0.291706
X -0.046193  -0.080009  -0.291706
X -0.009657  -0.091880  -0.291706
X  0.028549  -0.087865  -0.291706
X  0.061819  -0.068656  -0.291706
X  0.084399  -0.037577  -0.291706
X  0.092386  -0.000000  -0.291706
X
X  0.124988   0.000000  -0.153861
X  0.114183   0.050837  -0.153861
X  0.083634   0.092885  -0.153861
X  0.038624   0.118871  -0.153861
X -0.013065   0.124304  -0.153861
X -0.062494   0.108243  -0.153861
X -0.101118   0.073466  -0.153861
X -0.122257   0.025987  -0.153861
X -0.122257  -0.025987  -0.153861
X -0.101118  -0.073466  -0.153861
X -0.062494  -0.108243  -0.153861
X -0.013065  -0.124304  -0.153861
X  0.038624  -0.118871  -0.153861
X  0.083634  -0.092885  -0.153861
X  0.114183  -0.050837  -0.153861
X  0.124988  -0.000000  -0.153861
X
X  0.185015   0.000000  -0.041791
X  0.169020   0.075253  -0.041791
X  0.123799   0.137493  -0.041791
X  0.057173   0.175960  -0.041791
X -0.019339   0.184002  -0.041791
X -0.092508   0.160228  -0.041791
X -0.149681   0.108749  -0.041791
X -0.180972   0.038467  -0.041791
X -0.180972  -0.038467  -0.041791
X -0.149681  -0.108749  -0.041791
X -0.092508  -0.160228  -0.041791
X -0.019339  -0.184002  -0.041791
X  0.057173  -0.175960  -0.041791
X  0.123799  -0.137493  -0.041791
X  0.169020  -0.075253  -0.041791
X  0.185015  -0.000000  -0.041791
X
X  0.273264   0.000000   0.053395
X  0.249639   0.111146   0.053395
X  0.182849   0.203075   0.053395
X  0.084443   0.259889   0.053395
X -0.028564   0.271767   0.053395
X -0.136632   0.236653   0.053395
X -0.221075   0.160620   0.053395
X -0.267292   0.056815   0.053395
X -0.267292  -0.056815   0.053395
X -0.221075  -0.160620   0.053395
X -0.136632  -0.236653   0.053395
X -0.028564  -0.271767   0.053395
X  0.084443  -0.259889   0.053395
X  0.182849  -0.203075   0.053395
X  0.249639  -0.111146   0.053395
X  0.273264  -0.000000   0.053395
X
X  0.384384   0.000000   0.149114
X  0.351152   0.156343   0.149114
X  0.257203   0.285653   0.149114
X  0.118781   0.365570   0.149114
X -0.040179   0.382278   0.149114
X -0.192192   0.332886   0.149114
X -0.310973   0.225935   0.149114
X -0.375984   0.079918   0.149114
X -0.375984  -0.079918   0.149114
X -0.310973  -0.225935   0.149114
X -0.192192  -0.332886   0.149114
X -0.040179  -0.382278   0.149114
X  0.118781  -0.365571   0.149114
X  0.257203  -0.285653   0.149114
X  0.351152  -0.156343   0.149114
X  0.384384  -0.000000   0.149114
X
X  0.504089   0.000000   0.267473
X  0.460508   0.205031   0.267473
X  0.337301   0.374611   0.267473
X  0.155772   0.479417   0.267473
X -0.052692   0.501327   0.267473
X -0.252044   0.436554   0.267473
X -0.407816   0.296296   0.267473
X -0.493073   0.104806   0.267473
X -0.493073  -0.104806   0.267473
X -0.407816  -0.296296   0.267473
X -0.252044  -0.436554   0.267473
X -0.052692  -0.501327   0.267473
X  0.155772  -0.479417   0.267473
X  0.337301  -0.374611   0.267473
X  0.460508  -0.205031   0.267473
X  0.504089  -0.000000   0.267473
X
X  0.609609   0.000000   0.430046
X  0.556906   0.247950   0.430046
X  0.407908   0.453028   0.430046
X  0.188380   0.579773   0.430046
X -0.063721   0.606270   0.430046
X -0.304805   0.527937   0.430046
X -0.493184   0.358319   0.430046
X -0.596288   0.126745   0.430046
X -0.596288  -0.126745   0.430046
X -0.493184  -0.358319   0.430046
X -0.304805  -0.527937   0.430046
X -0.063722  -0.606270   0.430046
X  0.188380  -0.579773   0.430046
X  0.407908  -0.453028   0.430046
X  0.556906  -0.247951   0.430046
X  0.609609  -0.000000   0.430046
X
X  0.675154   0.000000   0.647779
X  0.616784   0.274610   0.647779
X  0.451766   0.501737   0.647779
X  0.208634   0.642110   0.647779
X -0.070573   0.671455   0.647779
X -0.337577   0.584700   0.647779
X -0.546211   0.396846   0.647779
X -0.660400   0.140372   0.647779
X -0.660400  -0.140372   0.647779
X -0.546211  -0.396845   0.647779
X -0.337577  -0.584700   0.647779
X -0.070573  -0.671455   0.647779
X  0.208634  -0.642110   0.647779
X  0.451766  -0.501737   0.647779
X  0.616784  -0.274610   0.647779
X  0.675154  -0.000000   0.647779
X
X  0.681825   0.000000   0.900691
X  0.622878   0.277323   0.900691
X  0.456230   0.506695   0.900691
X  0.210696   0.648454   0.900691
X -0.071270   0.678090   0.900691
X -0.340913   0.590478   0.900691
X -0.551608   0.400767   0.900691
X -0.666926   0.141760   0.900691
X -0.666926  -0.141759   0.900691
X -0.551608  -0.400767   0.900691
X -0.340913  -0.590478   0.900691
X -0.071270  -0.678090   0.900691
X  0.210695  -0.648454   0.900691
X  0.456230  -0.506695   0.900691
X  0.622878  -0.277324   0.900691
X  0.681825  -0.000000   0.900691
X
X  0.626000   0.000000   1.101000
X  0.571879   0.254617   1.101000
X  0.418876   0.465209   1.101000
X  0.193445   0.595361   1.101000
X -0.065435   0.622571   1.101000
X -0.313000   0.542132   1.101000
X -0.506445   0.367954   1.101000
X -0.612320   0.130153   1.101000
X -0.612320  -0.130153   1.101000
X -0.506445  -0.367953   1.101000
X -0.313000  -0.542132   1.101000
X -0.065435  -0.622571   1.101000
X  0.193444  -0.595361   1.101000
X  0.418876  -0.465209   1.101000
X  0.571879  -0.254617   1.101000
X  0.626000  -0.000000   1.101000
X
END_OF_FILE
  if test 8596 -ne `wc -c <'gnuplot/demo/glass.dat'`; then
    echo shar: \"'gnuplot/demo/glass.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/glass.dat'
fi
if test -f 'gnuplot/demo/surface2.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/surface2.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/surface2.dem'\" \(1760 characters\)
  sed "s/^X//" >'gnuplot/demo/surface2.dem' <<'END_OF_FILE'
X#
X# $Id: surface2.dem%v 3.38.2.139 1993/06/19 01:03:49 woo Exp woo $
X#
Xset parametric
Xset isosamples 50,10
Xset hidden
X
Xset title "Parametric Sphere"
Xset urange [-pi/2:pi/2]
Xset vrange [0:2*pi]
Xset zrange [-1:1]
Xset ztics -1.0,0.25,1.0
Xset view 45,50,,2.5
Xsplot cos(u)*cos(v),cos(u)*sin(v),sin(u)
Xpause -1 "Hit return to continue (1)"
X
Xset view ,,,0.8
Xreplot
Xpause -1 "Hit return to continue (2)"
X
Xset view ,,,1.6
Xreplot
Xpause -1 "Hit return to continue (3)"
X
Xset view ,,,1.0
X
Xset title "Parametric Torus"
Xset urange [0:2*pi]
Xset vrange [0:2*pi]
Xsplot (1-0.2*cos(v))*cos(u),(1-0.2*cos(v))*sin(u),0.2*sin(v)
Xpause -1 "Hit return to continue (4)"
X
X
Xset title "Parametric Hexagon"
Xset urange [-1.3:1.3]
Xset vrange [0:2*pi]
Xset zrange [-0.6:0.6]
Xset ztics
Xsplot cos(v)**3*cos(u)**3,sin(v)**3*cos(u)**3,sin(u)**3
Xpause -1 "Hit return to continue (5)"
X
Xset title "Parametric Helix"
Xset isosamples 100,20
Xset urange [0:10*pi]
Xset vrange [0:2*pi]
Xset zrange [-0.6:0.6]
Xsplot (1-0.1*cos(v))*cos(u),(1-0.1*cos(v))*sin(u),0.1*(sin(v)+u/1.7-10)
Xpause -1 "Hit return to continue (6)"
X
Xset title "Parametric Shell"
Xset isosamples 40,20
Xset view 50,30,1.0
Xset urange [0:2*pi]
Xset vrange [0:2*pi]
Xset zrange [-3:1.5]
Xsplot cos(u)*u*(1+cos(v)/2),sin(v)*u/2,sin(u)*u*(1+cos(v)/2)
Xpause -1 "Hit return to continue (7)"
X
Xset title "Interlocking Tori"
X
Xset urange [-pi:pi]
Xset vrange [-pi:pi]
Xset isosamples 50,20
Xsplot cos(u)+.5*cos(u)*cos(v),sin(u)+.5*sin(u)*cos(v),.5*sin(v) with lines, 1+cos(u)+.5*cos(u)*cos(v),.5*sin(v),sin(u)+.5*sin(u)*cos(v) with lines
Xpause -1 "Hit return to continue (8)"
X
X#
X# Clean up:
X#
Xset noparametric
Xset dummy x,y
Xset isosamples 10,10
Xset view 60,30,1,1
Xset urange [-5:5]
Xset vrange [-5:5]
Xset zrange [-10:10]
Xset auto
Xset title "" 0,0
Xset nohidden
END_OF_FILE
  if test 1760 -ne `wc -c <'gnuplot/demo/surface2.dem'`; then
    echo shar: \"'gnuplot/demo/surface2.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/surface2.dem'
fi
if test -f 'gnuplot/docs/doc2rtf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/doc2rtf.c'\"
else
  echo shar: Extracting \"'gnuplot/docs/doc2rtf.c'\" \(8811 characters\)
  sed "s/^X//" >'gnuplot/docs/doc2rtf.c' <<'END_OF_FILE'
X/*
X * doc2rtf.c  -- program to convert Gnuplot .DOC format to MS windows
X * help (.rtf) format.
X *
X * This involves stripping all lines with a leading digit or
X * a leading @, #, or %.
X * Modified by Maurice Castro from doc2gih.c by Thomas Williams 
X *
X * usage:  doc2rtf file.doc file.rtf [-d]
X *
X */
X
X/* note that tables must begin in at least the second column to */
X/* be formatted correctly and tabs are forbidden */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#include <stdlib.h>
X
X#define MAX_LINE_LEN	1024
X#define TRUE 1
X#define FALSE 0
X
Xstruct LIST
X{
X	int level;
X	int line;
X	char *string;
X	struct LIST *next;
X	};
X
Xstruct LIST *list = NULL;
Xstruct LIST *head = NULL;
X
Xstruct LIST *keylist = NULL;
Xstruct LIST *keyhead = NULL;
X
Xint debug = FALSE;
X
Xvoid footnote();
Xvoid parse();
Xvoid refs();
Xvoid convert();
Xvoid process_line();
Xint lookup();
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
XFILE * infile;
XFILE * outfile;
X	if (argc==4 && argv[3][0]=='-' && argv[3][1]=='d')
X		debug = TRUE;
X
X	if (argc != 3 && !debug) {
X		fprintf(stderr,"Usage: %s infile outfile\n", argv[0]);
X		return(1);
X	}
X	if ( (infile = fopen(argv[1],"r")) == (FILE *)NULL) {
X		fprintf(stderr,"%s: Can't open %s for reading\n",
X			argv[0], argv[1]);
X		return(1);
X	}
X	if ( (outfile = fopen(argv[2],"w")) == (FILE *)NULL) {
X		fprintf(stderr,"%s: Can't open %s for writing\n",
X			argv[0], argv[2]);
X	}
X	parse(infile);
X	convert(infile,outfile);
X	return(0);
X}
X
X/* scan the file and build a list of line numbers where particular levels are */
Xvoid parse(a)
XFILE *a;
X{
X    static char line[MAX_LINE_LEN];
X	char *c;
X	int lineno=0;
X	int lastline=0;
X
X    while (fgets(line,MAX_LINE_LEN,a)) 
X    {
X	lineno++;
X	if (isdigit(line[0]))
X	{
X		if (list == NULL)	
X			head = (list = (struct LIST *) malloc(sizeof(struct LIST)));
X		else
X			list = (list->next = (struct LIST *) malloc(sizeof(struct LIST)));
X		list->line = lastline = lineno;
X		list->level = line[0] - '0';
X		list->string = (char *) malloc (strlen(line)+1);
X		c = strtok(&(line[1]),"\n");
X		strcpy(list->string, c);
X		list->next = NULL;
X	}
X	if (line[0]=='?')
X	{
X		if (keylist == NULL)	
X			keyhead = (keylist = (struct LIST *) malloc(sizeof(struct LIST)));
X		else
X			keylist = (keylist->next = (struct LIST *) malloc(sizeof(struct LIST)));
X		keylist->line = lastline;
X		keylist->level = line[0] - '0';
X		keylist->string = (char *) malloc (strlen(line)+1);
X		c = strtok(&(line[1]),"\n");
X		strcpy(keylist->string, c);
X		keylist->next = NULL;
X	}
X	}
X	rewind(a);
X    }
X
X/* look up an in text reference */
Xint
Xlookup(s)
Xchar *s;
X{
X	char *c;
X	char tokstr[MAX_LINE_LEN];
X	char *match; 
X	int l;
X
X	strcpy(tokstr, s);
X
X	/* first try the ? keyword entries */
X	keylist = keyhead;
X	while (keylist != NULL)
X	{
X		c = keylist->string;
X		while (isspace(*c)) c++;
X		if (!strcmp(s, c)) return(keylist->line);
X		keylist = keylist->next;
X		}
X
X	/* then try titles */
X	match = strtok(tokstr, " \n\t");
X	l = 0; /* level */
X	
X	list = head;
X	while (list != NULL)
X	{
X		c = list->string;
X		while (isspace(*c)) c++;
X		if (!strcmp(match, c)) 
X		{
X			l = list->level;
X			match = strtok(NULL, "\n\t ");
X			if (match == NULL)
X			{
X				return(list->line);
X				}
X			}
X		if (l > list->level)
X			break;
X		list = list->next;
X		}
X	return(-1);
X	}
X
X/* search through the list to find any references */
Xvoid
Xrefs(l, f)
Xint l;
XFILE *f;
X{
X	int curlevel;
X	char str[MAX_LINE_LEN];
X	char *c;
X
X	/* find current line */
X	list = head;
X	while (list->line != l)
X		list = list->next;
X	curlevel = list->level;
X	list = list->next;		/* look at next element before going on */
X	while (list != NULL)
X	{
X		/* we are onto the next topic so stop */
X		if (list->level == curlevel)
X			break;
X		/* these are the next topics down the list */
X		if (list->level == curlevel+1)
X		{
X			c = list->string;
X			while (isspace(*c)) c++;
X			fprintf(f,"\\par{\\uldb %s}",c);
X			fprintf(f,"{\\v loc%d}\n",list->line);
X			}
X		list = list->next;
X		}
X	}
X
X/* generate an RTF footnote with reference char c and text s */
Xvoid footnote(c, s, b)
Xchar c;
Xchar *s;
XFILE *b;
X{
X	fprintf(b,"%c{\\footnote %c %s}\n",c,c,s);
X	}
X
Xvoid
Xconvert(a,b)
X	FILE *a,*b;
X{
X    static char line[MAX_LINE_LEN];
X	
X	/* generate rtf header */
X	fprintf(b,"{\\rtf1\\ansi ");		/* vers 1 rtf, ansi char set */
X	fprintf(b,"\\deff0");				/* default font font 0 */
X	/* font table: font 0 proportional, font 1 fixed */
X	fprintf(b,"{\\fonttbl{\\f0\\fswiss Helv;}{\\f1\\fmodern Courier;}{\\f2\\fmodern Pica;}}\n");
X
X	/* process each line of the file */
X    while (fgets(line,MAX_LINE_LEN,a)) {
X	   process_line(line, b);
X	   }
X
X	/* close final page and generate trailer */
X	fprintf(b,"}{\\plain \\page}\n");
X	fprintf(b,"}\n");
X}
X
Xvoid
Xprocess_line(line, b)
X	char *line;
X	FILE *b;
X{
X    static int line_count = 0;
X    static char line2[MAX_LINE_LEN];
X    static int last_line;
X	int i;
X	int j;
X	static int startpage = 1;
X	char str[MAX_LINE_LEN];
X	char topic[MAX_LINE_LEN];
X	int k, l;
X	static int tabl=0;
X	static int para=0;
X	static int llpara=0;
X	static int inquote = FALSE;
X	static int inref = FALSE;
X
X	line_count++;
X
X	i = 0;
X	j = 0;
X	while (line[i] != '\0')
X	{
X		switch(line[i])
X		{
X			case '\\':
X			case '{':
X			case '}':
X				line2[j] = '\\';
X				j++;
X				line2[j] = line[i];
X				break;
X			case '\r':
X			case '\n':
X				break;
X			case '`':	/* backquotes mean boldface or link */
X				if (line[1]==' ')	/* tabular line */
X					line2[j] = line[i];
X				else if ((!inref) && (!inquote))
X				{
X					k=i+1;	/* index into current string */
X					l=0;	/* index into topic string */
X					while ((line[k] != '`') && (line[k] != '\0'))
X					{
X						topic[l] = line[k];
X						k++;
X						l++;
X						}
X					topic[l] = '\0';
X					k = lookup(topic);
X					if ((k > 0) && (k != last_line))
X					{
X						line2[j++] = '{';
X						line2[j++] = '\\';
X						line2[j++] = 'u';
X						line2[j++] = 'l';
X						line2[j++] = 'd';
X						line2[j++] = 'b';
X						line2[j] = ' ';
X						inref = k;
X						}
X					else
X					{
X						if (debug)
X							fprintf(stderr,"Can't make link for \042%s\042 on line %d\n",topic,line_count);
X						line2[j++] = '{';
X						line2[j++] = '\\';
X						line2[j++] = 'b';
X						line2[j] = ' ';
X						inquote = TRUE;
X						}
X					}
X				else
X				{
X					if (inquote && inref)
X						fprintf(stderr, "Warning: Reference Quote conflict line %d\n", line_count);
X					if (inquote)
X					{
X						line2[j] = '}';
X						inquote = FALSE;
X						}
X					if (inref)
X					{
X						/* must be inref */
X						sprintf(topic,"%d",inref);
X						line2[j++] = '}';
X						line2[j++] = '{';
X						line2[j++] = '\\';
X						line2[j++] = 'v';
X						line2[j++] = ' ';
X						line2[j++] = 'l';
X						line2[j++] = 'o';
X						line2[j++] = 'c';
X						k = 0;
X						while (topic[k] != '\0')
X						{
X							line2[j++] = topic[k];
X							k++;
X							}
X						line2[j] = '}';
X						inref = 0;
X						}
X				}
X				break;
X			default:
X				line2[j] = line[i];
X			}
X		i++;
X		j++;
X		line2[j] = '\0';
X		}
X
X	i = 1;
X
X    switch(line[0]) {		/* control character */
X	   case '?': {			/* interactive help entry */
X		if ((line2[1] != '\0') && (line2[1] != ' '))
X			footnote('K',&(line2[1]),b);
X		  break;
X	   }
X	   case '@': {			/* start/end table */
X		  break;			/* ignore */
X	   }
X	   case '#': {			/* latex table entry */
X		  break;			/* ignore */
X	   }
X	   case '%': {			/* troff table entry */
X		  break;			/* ignore */
X	   }
X	   case '\n':			/* empty text line */
X			fprintf(b,"\\par\n");
X			llpara = para;
X			para = 0;
X			tabl = 0;
X			break;
X	   case ' ': {			/* normal text line */
X		  if ((line2[1] == '\0') || (line2[1] == '\n'))
X		  {
X				fprintf(b,"\\par\n"); 
X				llpara = para;
X				para = 0;
X				tabl = 0;
X				}
X		  if (line2[1] == ' ') 
X		  {
X				if (!tabl)
X				{
X					fprintf(b,"\\par\n"); 
X					}
X				fprintf(b,"{\\pard \\plain \\f1\\fs20 ");
X			  	fprintf(b,"%s",&line2[1]); 
X				fprintf(b,"}\\par\n");
X				llpara = 0;
X				para = 0;
X				tabl = 1;
X				}
X		  else
X		  {
X				if (!para)
X				{
X					if (llpara)
X						fprintf(b,"\\par\n"); /* blank line between paragraphs */
X					llpara = 0;
X					para = 1;		/* not in para so start one */
X					tabl = 0;
X					fprintf(b,"\\pard \\plain \\qj \\fs20 \\f0 ");
X					}
X			  	fprintf(b,"%s \n",&line2[1]); 
X				}
X		  break;
X	   }
X	   default: {
X		  if (isdigit(line[0])) { /* start of section */
X			if (!startpage)
X			{
X				refs(last_line,b);
X				fprintf(b,"}{\\plain \\page}\n");
X				}
X			para = 0;					/* not in a paragraph */
X			tabl = 0;
X			last_line = line_count;
X			startpage = 0;
X			fprintf(b,"{\n");
X			sprintf(str,"browse:%05d", line_count);
X			footnote('+',str,b);
X			footnote('$',&(line2[1]),b); /* title */
X			fprintf(b,"{\\b \\fs24 %s}\\plain\\par\\par\n",&(line2[1]));
X			/* output unique ID */
X			sprintf(str,"loc%d", line_count);
X			footnote('#',str,b);
X		  } else
X		    fprintf(stderr, "unknown control code '%c' in column 1, line %d\n",
X			    line[0], line_count);
X		  break;
X	   }
X    }
X}
X
END_OF_FILE
  if test 8811 -ne `wc -c <'gnuplot/docs/doc2rtf.c'`; then
    echo shar: \"'gnuplot/docs/doc2rtf.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/doc2rtf.c'
fi
if test -f 'gnuplot/os2/gnupmdrv.itl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/os2/gnupmdrv.itl'\"
else
  echo shar: Extracting \"'gnuplot/os2/gnupmdrv.itl'\" \(9564 characters\)
  sed "s/^X//" >'gnuplot/os2/gnupmdrv.itl' <<'END_OF_FILE'
X.imd dialogs.h
X:userdoc.
X#ifdef GENHELP  /**/
X:docprof toc=1.
X#else
X:prolog.
X:title.Gnushell
X:docprof toc=12.
X:eprolog.
X#endif
X
X#ifdef GENHELP
X:h1 res=5. Extended Help
X:p.This program is a display interface for Gnuplot.
X:p.When it starts up, it spawns a new session which contains 
Xthe :hp2.GNUPLOT:ehp2. program. This new session provides the usual
XGnuplot command line.
X#endif
X
X#ifndef GENHELP
X:h1. Options Menu
X:p.This section describes the options available from the :hp2.Options:ehp2. menu.
X#endif
X
X#ifdef GENHELP
X:h1 res=&IDM_FILE.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. The options menu
X#endif
X:i1 id=mfile. Options menu
X:i2 refid=mfile. The options menu
X:p.The :hp2.Options:ehp2. menu enables you to change various options on the
Xdisplayed plot, and to control printing of the plot via the OS/2 print
Xsystem.
X
X#ifdef GENHELP
X:h1 res=&IDM_ABOUT..  Help Menu Help
X#endif
X#ifndef GENHELP
X:h2. About 
X#endif
X:i1 id=mabout. Help menu
X:i2 refid=mabout. About 
X:p.The :hp2.About:ehp2. menu item displays the About box, which
Xjust identifies the program.
X
X#ifdef GENHELP
X:h1 res=&IDM_FONTS.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Font selection 
X#endif
X:i1 id=mfonts. Options menu
X:i2 refid=mfonts. Fonts 
X:p.The :hp2.Fonts:ehp2. menu item from the :hp2.Options:ehp2.
Xpulldown menu enables you to change the font used in the displayed plot. 
X:p.You can also 'drag and drop' a font from a Font Palette onto the Gnushell
Xwindow.
X
X#ifdef GENHELP
X:h1 res=&IDM_PRINT.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Print
X#endif
X:i1 id=mprint. Options menu
X:i2 refid=mprint. Print
X:p.The :hp2.Print:ehp2. menu item from the :hp2.Options:ehp2.
Xpulldown menu enables you to print the current window on the default
Xprinter.
X
X#ifdef GENHELP
X:h1 res=&IDM_PRINTSETUP.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Printer selection
X#endif
X:i1 id=mprint. Options menu
X:i2 refid=mprint. Printers
X:p.The :hp2.Printers:ehp2. menu item from the :hp2.Options:ehp2.
Xpulldown menu enables you to select the printer to which
Xoutput is directed.
X
X#ifdef GENHELP
X:h1 res=&IDM_LINES.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Line options
X#endif
X:i1 id=mlines. Options menu
X:i2 refid=mlines. Linetype option
X:p.Selecting the :hp2.Lines:ehp2. menu item from the :hp2.Options:ehp2.
Xenables you to choose various options for the lines used for the plots.
X
X#ifdef GENHELP
X:h1 res=&IDM_LINES_THICK.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Thick line option
X#endif
X:i1 id=mlinesth. Options menu
X:i2 refid=mlinesth. Thick line option
X:p.Selecting the :hp2.Thick:ehp2. option of the :hp2.Lines:ehp2.
Xmenu item toggles the :hp2.thick line:ehp2. option on and off.
XThe selection is active if the menu item is checked.
X:p.The thick line option can give better output on high-resolution
Xdevices like laser printers.
X
X#ifdef GENHELP
X:h1 res=&IDM_LINES_SOLID.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Solid Line option
X#endif
X:i1 id=mlinessol. Options menu
X:i2 refid=mlinessol. Solid lines option
X:p.Selecting the :hp2.Solid:ehp2. option of the :hp2.Lines:ehp2.
Xmenu item toggles the :hp2.solid line:ehp2. option on and off.
XThe selection is active if the menu item is checked.
X:p.If the :hp2.Solid:ehp2. option is not active, curves on graphs will be
Xplotted in various styles of broken lines. 
X:p.This option can be combined with the :hp2.Colours.:ehp2. option. 
XWhen a plot is printed on a printer that does not support colour, the 
X:hp2.Solid:ehp2. option is disabled.
X
X#ifdef GENHELP
X:h1 res=&IDM_COLOURS.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Colours
X#endif
X:i1 id=mcolour. Options menu
X:i2 refid=mcolour. Colours
X:p.Selecting the :hp2.Colours:ehp2. menu item from the :hp2.Options:ehp2.
Xpulldown menu causes lines used for graphs to be plotted in various
Xcolours. This is the default option for plotting on the screen.
XIt can be combined with the :hp2.Lines:ehp2. option. 
X
X#ifdef GENHELP
X:h1 res=&IDM_PAUSEOPT.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Pause options
X#endif
X:i1 id=mpauseopt. Options menu
X:i2 refid=mpauseopt. Pause option
X:p.Selecting the :hp2.Pause mode:ehp2. menu item from the :hp2.Options:ehp2.
Xmenu enables you to choose how the Gnuplot 'pause' command is handled.
X
X#ifdef GENHELP
X:h1 res=&IDM_PAUSEDLG.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Pause options
X#endif
X:i1 id=mpausedlg. Options menu
X:i2 refid=mpausedlg. Pause with dialog box
X:p.Selecting the :hp2.Dialog box:ehp2. menu item from the :hp2.Pause options:ehp2.
Xmenu causes the Gnuplot 'pause' command to print a message in a dialog box,
Xand wait for you to end the dialog before continuing.
X
X#ifdef GENHELP
X:h1 res=&IDM_PAUSEBTN.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Pause options
X#endif
X:i1 id=mpausebtn. Options menu
X:i2 refid=mpausebtn. Pause with menu item
X:p.Selecting the :hp2.Menu bar:ehp2. menu item from the :hp2.Pause options:ehp2.
Xmenu causes the Gnuplot 'pause' command to enable the :hp2.Continue:ehp2.
Xmenu item. 
X:p.Plotting will be resumed when this item is selected.
X:p.Any text message is ignored.
X
X#ifdef GENHELP
X:h1 res=&IDM_PAUSEGNU.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Pause options
X#endif
X:i1 id=mpausegnu. Options menu
X:i2 refid=mpausegnu. Pause in Gnuplot
X:p.Selecting the :hp2.Gnuplot:ehp2. menu item from the :hp2.Pause options:ehp2.
Xmenu causes the Gnuplot 'pause' command to be handled by the Gnuplot
Xprogram.
X:p.In order to resume plotting, you will have to select the Gnuplot command line
Xwindow, and press the enter key.
X 
X
X#ifdef GENHELP
X:h1 res=&IDM_SAVE.. Options Menu Help
X#endif
X#ifndef GENHELP
X:h2. Save option
X#endif
X:i1 id=msave. Options menu
X:i1 refid=msave. gnushell.ini
X:i2 refid=msave. Save settings
X:p.Selecting the :hp2.Save settings:ehp2. menu item from the :hp2.Options:ehp2.
Xpulldown menu causes the current line, colour and font options to be saved.
XThe positions and sizes of the windows are also saved.
X:p.The data is saved in the file :hp2.gnushell.ini:ehp2. file in the 
Xprogram&csq.s working directory. You can delete the file if you want to restore
Xall settings to their default values. (This file is created even if
Xno settings are saved.) 
X
X#ifdef GENHELP
X:h1 res=&IDM_COMMAND.. Gnuplot Menu Help
X#endif
X#ifndef GENHELP
X:h2. The Gnuplot menu
X#endif
X:i1 id=mgnu. Gnuplot menu
X:i1 refid=mgnu. Moving to GNUPLOT window
X:p.Selecting the :hp2.Gnuplot:ehp2. menu item causes the GNUPLOT
Xcommand window to be brought to the foreground. The same result can be
Xbe obtained by pressing the ESC key when the Gnushell window is active.
X
X 
X#ifdef GENHELP
X:h1 res=&ID_QPRINT.. Printer setup dialog box help
X#else
X:h2. Printer setup
X#endif
X:i1 id=qprint. Printing
X:p.This dialog box enables you to setup the printer.
X:p.The printer that output will be sent to is indicated in the 
X:hp2.Current printer:ehp2. field. You can select a different
Xprinter by using the :hp2.Printers:ehp2. item of the :hp2.Options:ehp2.
Xmenu.
X:p.The setup can be selected by clicking on the :hp2.OK:ehp2. button.
X:p.The setup can be cancelled by selecting :hp2.Cancel:ehp2. .
X:p.If your printer driver supports printing to a file, the
X:hp2.Print to file named:ehp2. field will not be greyed out. In this case,
Xyou may enter a filename here for sending output to a file rather than to 
Xa printer. Some printer drivers also support this option from the
Xprinter setup dialog box accessible with the :hp2.Set printer:ehp2.
Xoption. You may choose either method. Some printer drivers (e.g. Postscript)
Xwill not overwrite a file if you use the second method.
X:p.The area of the page in which the plot will be displayed is
Xindicated. You can change this by selecting the :hp2.Set Page:ehp2. button.
XYou can then adjust the area with the mouse, and click on button 1
Xto select the new area. Another way of doing this is by typing
Xthe appropriate data into the entry windows which give the size of the
Xplot area, either in centimeters or relative to the page size. 
X:p.If you wish to adjust the default behaviour of the printer,
Xchoose the :hp2.Job properties:ehp2. option. This will bring up your
Xprinter setup dialog box. This is part of the printer driver, and the 
Xfeatures you can adjust will depend on your printer. You can generally
Xuse this to swich between landscape and portrait mode, for instance.
XNote that some drivers might not have any options.
X 
X#ifdef GENHELP
X:h1 res=&IDD_QUERYPRINT.. Printer selection dialog box help
X#else
X:h2. Printer selection
X#endif
X:i1 id=qprinters. Printing
X:p.This dialog box enables you to select the printer on which
Xyour output will appear.
X:p.Choose a printer from the displayed list. The chosen printer
Xis highlighted.
X:p.The printer is selected by clicking on the :hp2.OK:ehp2. button.
X:p.The new selection is ignored by selecting :hp2.Cancel:ehp2. .
X
X#ifdef GENHELP
X:h1 res=&IDD_PAUSEBOX.. Pause dialog box help
X#else
X:h2. Puase
X#endif
X:i1 id=pausebox. Pause
X:p.This dialog box is (optionally) displayed when a 
X'pause -1 <text>' command is issued to Gnuplot.
XPlotting is paused until you:
X:p.Select :hp2.Continue:ehp2. to resume plotting.
X:p.Select :hp2.Cancel:ehp2. to cancel plotting and return to the Gnuplot
Xcommand line.
X
X#ifdef GENHELP
X:h1 res=&IDD_FONTS.. Fonts dialog box help
X#else
X:h2. Font selection
X#endif
X:i1 id=fonts. Font selection
X:p.This dialog box enables you to change the font used on the displayed plot.
X:p.The font is selected by clicking on the :hp2.OK:ehp2. button.
X:p.The new selection is ignored by selecting :hp2.Cancel:ehp2. .
X:p.Choose a font from the displayed list. The chosen font
Xis previwed in the :hp2.Example:ehp2. window.
X 
X
X:euserdoc.
END_OF_FILE
  if test 9564 -ne `wc -c <'gnuplot/os2/gnupmdrv.itl'`; then
    echo shar: \"'gnuplot/os2/gnupmdrv.itl'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/os2/gnupmdrv.itl'
fi
if test -f 'gnuplot/term/amiga.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/amiga.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/amiga.trm'\" \(9608 characters\)
  sed "s/^X//" >'gnuplot/term/amiga.trm' <<'END_OF_FILE'
X/*
X * $Id: amiga.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - amiga.trm */
X/*
X * Copyright (C) 1991, 1992
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   Amiga Custom Screen
X *
X * AUTHORS
X *   Carsten Steger
X * 
X *   Pat R. Empleo      Slightly modified for Aztec C v5.2a (beta); sort of
X *   08/27/91           supports overscan; for large WB 2.0 virtual screens,
X *                      we limit the plot size so we don't have to scroll
X *                      around (not fun).
X *
X *   Carsten Steger     Modified to support Kickstart 2.0.
X *   09/11/91           Opens a text overscan screen when used with WB 2.0.
X *                      Discerns between NTSC and PAL Amigas when used with
X *                      WB 1.3 and lower.
X *
X *   Pat R. Empleo      Defined some 2.0 stuff in order to get Aztec C to
X *   09/20/91           work with Carsten's new code (see above).  When
X *                      KS/WB 2.0 support gets implemented in Aztec C, this
X *                      kludge will get deleted! 
X *                      (Aztec C release 5.2 beta)
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X#ifdef AMIGA_AC_5
X#include <intuition/intuitionbase.h>
X#include <intuition/screens.h>
X#include <graphics/text.h>
X#include <graphics/gfxbase.h>
X#else
X/* You will have to use the Kickstart 2.0 header files for this to compile */
X#include <exec/types.h>
X#include <intuition/intuitionbase.h>
X#include <graphics/gfxbase.h>
X#include <proto/intuition.h>
X#include <proto/graphics.h>
X#include <proto/exec.h>
X#include <proto/diskfont.h>
X#endif
X
Xextern char *getenv();
X#ifndef AMIGA_AC_5
Xextern char *strchr();
X#endif
X
X#define AMIGA_XMAX 640
X#define AMIGA_YMAX 512
X
X#define AMIGA_VCHAR (12)
X#define AMIGA_HCHAR (8)
X#define AMIGA_VTIC (AMIGA_YMAX/80)
X#define AMIGA_HTIC (AMIGA_XMAX/80)
X/* The origin is in the upper left hand corner, so we have to translate */
X/* and flip the coordinates: */
X#define AMIGA_VTF(y) (AMIGA_ymax-1-(y))
X
X
Xstruct IntuitionBase *IntuitionBase;
Xstruct GfxBase *GfxBase;
Xstruct Library *DiskfontBase;
Xstatic struct TextAttr AMIGA_Font = {
X  "topaz.font",TOPAZ_EIGHTY,FS_NORMAL,FPF_ROMFONT
X};
Xstatic struct TextFont *AMIGA_TextFont;
Xstatic struct NewScreen AMIGA_NewScreen = {
X  0,0,AMIGA_XMAX,AMIGA_YMAX,4,15,0,HIRES|LACE,
X  CUSTOMSCREEN|SCREENBEHIND|SCREENQUIET,NULL,NULL,NULL,NULL
X};
Xstatic struct Screen *AMIGA_Screen;
Xstatic UWORD AMIGA_Colors [] = {
X  0x000,0xfff,0xbbb,0x0f0,0xf00,0x00f,0x3ca,0xf0f,
X  0x94d,0x0ff,0x82f,0xff0,0x0af,0xc5e,0xfa2,0xf44
X};
Xstatic int AMIGA_slinetype;
Xstatic enum JUSTIFY AMIGA_justify = LEFT;
Xstatic unsigned int AMIGA_ymax,AMIGA_xmax; 
Xstatic WORD AMIGA_cwd,AMIGA_cht,AMIGA_bsl,AMIGA_vadj;
Xstatic struct TagItem AMIGA_ScrTagList[] = {
X  {SA_Overscan,OSCAN_TEXT},{TAG_DONE,0}
X};
X
X
XAMIGA_reset()
X{
X  if (AMIGA_TextFont != NULL) CloseFont(AMIGA_TextFont);
X  if (DiskfontBase != NULL) CloseLibrary(DiskfontBase);
X  if (AMIGA_Screen != NULL) CloseScreen(AMIGA_Screen);
X  if (IntuitionBase != NULL) CloseLibrary(IntuitionBase);
X  if (GfxBase != NULL) CloseLibrary(GfxBase);
X  AMIGA_TextFont = NULL;
X  DiskfontBase = NULL;
X  AMIGA_Screen = NULL;
X  IntuitionBase = NULL;
X  GfxBase = NULL;
X}
X
X
XAMIGA_init()
X{
X  static char fontname[80],*gnufont,*search;
X  static int fsize;
X  static char *test_str =
X    " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~";
X  static WORD test_len,test_pxl;
X
X
X#ifdef AMIGA_SC_6_1
X  /* Install exit trap in case of abnormal termination (see below). */
X  int AMIGA_exit();
X  if (!onexit(&AMIGA_exit)) {
X    fprintf(stderr,"Couldn't set exit trap\n");
X    exit(20);
X  }
X#endif
X  GfxBase = (struct GfxBase *) OpenLibrary("graphics.library",0);
X  if (GfxBase == NULL) {
X    fprintf(stderr,"No Graphics-Library\n");
X    AMIGA_reset();
X    exit(20);
X  }
X  IntuitionBase = (struct IntuitionBase *) OpenLibrary("intuition.library",0);
X  if (IntuitionBase == NULL) {
X    fprintf(stderr,"No Intuition-Library\n");
X    AMIGA_reset();
X    exit(20);
X  }
X  if (IntuitionBase->LibNode.lib_Version <= 34) {
X    /* We compute the vertical resolution for those poor NTSC-souls   :-)   */
X    if (GfxBase->DisplayFlags & PAL) AMIGA_ymax = 512;
X    else AMIGA_ymax = 400;
X    AMIGA_xmax = 640;
X    AMIGA_NewScreen.Width = AMIGA_xmax;
X    AMIGA_NewScreen.Height = AMIGA_ymax;
X    AMIGA_Screen = OpenScreen(&AMIGA_NewScreen);
X    if (AMIGA_Screen == NULL) {
X      fprintf(stderr,"No Screen\n");
X      AMIGA_reset();
X      exit(20);
X    }
X  } else {
X    /* Kickstart 2.0 support */
X    AMIGA_NewScreen.Width = STDSCREENWIDTH;
X    AMIGA_NewScreen.Height = STDSCREENHEIGHT;
X    AMIGA_Screen = OpenScreenTagList(&AMIGA_NewScreen,AMIGA_ScrTagList);
X    if (AMIGA_Screen == NULL) {
X      fprintf(stderr,"No Screen\n");
X      AMIGA_reset();
X      exit(20);
X    }
X    AMIGA_xmax = AMIGA_Screen->Width;
X    AMIGA_ymax = AMIGA_Screen->Height;
X  }
X  term_tbl[term].xmax = AMIGA_xmax;
X  term_tbl[term].ymax = AMIGA_ymax;
X  gnufont = getenv("GNUFONT");
X  if (gnufont != NULL ) {
X    search = strchr(gnufont,'/');
X    if (search != NULL) {
X      *search++ = '\0';
X      strncpy(fontname,gnufont,74);
X      strcat(fontname,".font");
X      sscanf(search,"%d",&fsize);
X      /* Avoid opening "diskfont.library" if a built-in font is desired */
X      if ((strcmp("topaz.font",fontname) == 0) &&
X        ((fsize == TOPAZ_EIGHTY) || (fsize == TOPAZ_SIXTY))) {
X        AMIGA_Font.ta_Name = fontname;
X        AMIGA_Font.ta_YSize = fsize;
X        AMIGA_Font.ta_Style = FS_NORMAL;
X        AMIGA_Font.ta_Flags = FPF_ROMFONT;
X        AMIGA_TextFont = OpenFont(&AMIGA_Font);
X        if (AMIGA_TextFont != NULL) 
X          SetFont(&AMIGA_Screen->RastPort,AMIGA_TextFont);
X      } else {
X        DiskfontBase = OpenLibrary("diskfont.library",0);
X        if (DiskfontBase != NULL) {
X          AMIGA_Font.ta_Name = fontname;
X          AMIGA_Font.ta_YSize = fsize;
X          AMIGA_Font.ta_Style = FS_NORMAL;
X          AMIGA_Font.ta_Flags = FPF_ROMFONT|FPF_DISKFONT;
X          AMIGA_TextFont = OpenDiskFont(&AMIGA_Font);
X          if (AMIGA_TextFont != NULL)
X            SetFont(&AMIGA_Screen->RastPort,AMIGA_TextFont);
X        }
X      }
X    }
X  }
X  /* Width of characters: This works better for proportional fonts than */
X  /* AMIGA_Screen->RastPort.TxWidth + AMIGA_Screen->RastPort.TxSpacing */
X  test_len = strlen(test_str);
X  test_pxl = TextLength(&AMIGA_Screen->RastPort,test_str,test_len);
X  AMIGA_cwd = test_pxl / test_len;
X  AMIGA_cht = AMIGA_Screen->RastPort.TxHeight; /* Height of characters */
X  AMIGA_bsl = AMIGA_Screen->RastPort.TxBaseline; /* Reference line */
X  /* Amount by which characters have to be shifted upwards to be */
X  /* vertically justified: */
X  AMIGA_vadj = AMIGA_bsl / 2;
X  term_tbl[term].v_char = AMIGA_cht + 4; /* So lines won't be too close */
X  term_tbl[term].h_char = AMIGA_cwd;
X  LoadRGB4(&AMIGA_Screen->ViewPort,AMIGA_Colors,16);
X  RemakeDisplay();
X  AMIGA_slinetype = 1;
X  SetAPen(&AMIGA_Screen->RastPort,AMIGA_slinetype);
X  SetDrMd(&AMIGA_Screen->RastPort,JAM1);
X}
X
X
XAMIGA_text()
X{
X  char c;
X
X  c = getc(stdin);
X  ungetc(c,stdin);
X  ScreenToBack(AMIGA_Screen);
X}
X
X
XAMIGA_graphics()
X{
X  SetRast(&AMIGA_Screen->RastPort,0);
X  SetAPen(&AMIGA_Screen->RastPort,AMIGA_slinetype);
X  ScreenToFront(AMIGA_Screen);
X}
X
X
XAMIGA_move(x,y)
Xunsigned int x,y;
X{
X  if ((x>=AMIGA_xmax) || (y>=AMIGA_ymax)) return;
X  Move(&AMIGA_Screen->RastPort,x,AMIGA_VTF(y));
X}
X
X
XAMIGA_vector(x,y)
Xunsigned int x,y;
X{
X  if ((x>=AMIGA_xmax) || (y>=AMIGA_ymax)) return;
X  Draw(&AMIGA_Screen->RastPort,x,AMIGA_VTF(y));
X}
X
X
XAMIGA_linetype(linetype)
Xint linetype;
X{
X  if (linetype >= 13) linetype %= 13;
X  if (linetype < -2) linetype = -2;
X  AMIGA_slinetype = linetype+3;
X  SetAPen(&AMIGA_Screen->RastPort,AMIGA_slinetype);
X}
X
X
XAMIGA_put_text(x,y,str)
Xunsigned int x,y;
Xchar *str;
X{
X  LONG len,tx_len;
X  WORD xmin,xmax,ymin,ymax;
X
X  len = strlen(str);
X  tx_len = TextLength(&AMIGA_Screen->RastPort,str,len);
X  switch (AMIGA_justify) {
X    case LEFT:
X      xmin = x;
X      xmax = x + tx_len;
X      break;
X    case CENTRE:
X      xmin = x - tx_len / 2;
X      xmax = x + tx_len - tx_len / 2; /* aviod roundoff errors ! */
X      break;
X    case RIGHT:
X      xmin = x - tx_len;
X      xmax = x;
X      break;
X  }
X  ymin = AMIGA_VTF(y) - AMIGA_vadj;
X  ymax = ymin + AMIGA_cht;
X  /* Check if character-string lies completely within the screen: */
X  if ((xmax >= AMIGA_xmax) || (ymin < 0) || (ymax >= AMIGA_ymax)) return;
X  Move(&AMIGA_Screen->RastPort,xmin,ymin+AMIGA_bsl);
X  Text(&AMIGA_Screen->RastPort,str,len);
X}
X
X
Xint AMIGA_justify_text(mode)
Xenum JUSTIFY mode;
X{
X  AMIGA_justify = mode;
X  return TRUE;
X}
X
X
X/* This function is mainly included if the program terminates abnormally */
X/* and the screen and libraries are still open. It closes down all opened */
X/* libraries and screens. This happens e.g. when loading "bivariat.demo" */
X/* and the stack is smaller than 120000 bytes. */
X#ifdef AMIGA_SC_6_1
Xint AMIGA_exit(rc)
Xint rc;
X{
X  AMIGA_reset();
X  return rc;
X}
X#endif
END_OF_FILE
  if test 9608 -ne `wc -c <'gnuplot/term/amiga.trm'`; then
    echo shar: \"'gnuplot/term/amiga.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/amiga.trm'
fi
if test -f 'gnuplot/term/dxf.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/dxf.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/dxf.trm'\" \(9202 characters\)
  sed "s/^X//" >'gnuplot/term/dxf.trm' <<'END_OF_FILE'
X/*
X * $Id: dxf.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - dxf.trm */
X/*
X * Copyright (C) 1991, 1992
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   AutoCad (Release 10.x) dxf file format (import with AutoCad dxfin command)
X *
X *
X * AUTHOR
X *   Florian Hiss  (fhis1231@w204zrz.zrz.tu-berlin.de)
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X*/
X
X#define DXF_UNIT 60.0
X#define LINEWIDTH 0.0351  /* default line width is 1 pt */
X
X/* 120 (autocad units) wide by 80 (autocad units) high (default)
X   use the GNUPLOT 'set size' command to change the defaults */
X#define DXF_XMAX (120.0 * DXF_UNIT)
X#define DXF_YMAX (80.0 * DXF_UNIT)
X#define DXF_HTIC (0.01 * DXF_XMAX)  /* 1.0 percent */
X#define DXF_VTIC (0.01 * DXF_YMAX)  /* 1.0 percent */
X#define DXF_HCHAR (0.014 * DXF_XMAX) /* 1.4 percent */
X#define DXF_VCHAR (0.026 * DXF_YMAX) /* 2.6 percent */
X#define DXF_TEXTHEIGHT (0.7 * DXF_VCHAR) /* actual text height */
X#define DXF_TEXTWIDTH (0.7 * DXF_HCHAR) /* actual text width,
X only a guess, we don't know the width of a character of given height
X of the AutoCad STANDARD text font, so change it if you like */
X#define DXF_LINE_TYPES 7 /* number of line types we support. see below  */
X#define MAX_LAYER 7  /* number of layers used for the drawing. see below */
X#define LT_SCALE 1  /* line type scaling */
X
Xstatic unsigned int DXF_posx;
Xstatic unsigned int DXF_posy;
Xstatic unsigned int dxf_linetype; /* linetype is mapped to a layer. see below. */
Xenum JUSTIFY dxf_justify = LEFT;
Xstatic float dxf_angle = 0.0; /* either 0 (horizontal) or 90.0 (vertical) */
X
X/* text style used in the entire drawing */
Xstatic char *text_style = "STANDARD";
X/* text always resides on layer 0 */
X#define TEXT_LAYER 0
X/* each linetype resides on its own layer. each layer has its own color.
X   this avoids difficulties that AutoCad has with proper scaling of
X   the linetypes.
X   change the colors according to your needs */
Xstatic char *layer_name[] = {"0","1","2","3","4","5","6"};
X/* the colours are white, red, yellow, green, cyan, blue, magenta.
X   change them according to your needs.
X   when using a black and white plotting device the colours map to different
X   line thicknesses. see description of AutoCad print / plot command */
Xstatic char *layer_colour[] = {"7","1","2","3","4","5","6"};
X/* support line types AutoCad has to offer by default. */
Xstatic char *layer_lines[] = {"CONTINUOUS","DASHED","HIDDEN","CENTER","PHANTOM",
X			    "DOT","DASHDOT"};
X
Xstatic TBOOLEAN vector_was_last = FALSE;
X
XDXF_init()
X{
X	DXF_posx = DXF_posy = 0;
X	dxf_linetype = 0;
X	dxf_angle = 0.0;
X	vector_was_last = FALSE;
X}
X
XDXF_graphics()
X{
X	register struct termentry *t = &term_tbl[term];
X	int i;
X	static char GPFAR dxfi1[] = "\
X999\n\
X%% GNUPLOT: dxf file for AutoCad\n\
X  0\nSECTION\n  2\nHEADER\n\
X  9\n$EXTMIN\n\
X 10\n0.000\n 20\n0.000\n\
X  9\n$EXTMAX\n\
X 10\n%-6.3f\n 20\n%-6.3f\n\
X  9\n$LIMMIN\n\
X 10\n0.000\n 20\n0.000\n\
X  9\n$LIMMAX\n\
X 10\n%-6.3f\n 20\n%-6.3f\n\
X  9\n$TEXTSTYLE\n  7\n%s\n\
X  9\n$TEXTSIZE\n 40\n%-6.3f\n\
X  9\n$PLINEWID\n 40\n%-6.4f\n\
X  9\n$LTSCALE\n  40\n%-6.3f\n\
X  9\n$COORDS\n 70\n  1\n\
X  9\n$CELTYPE\n 6\nBYLAYER\n\
X  9\n$CLAYER\n  8\n0\n\
X  9\n$CECOLOR\n 62\n   %s\n\
X  9\n$MENU\n  1\nacad\n\
X  0\nENDSEC\n\
X  0\nSECTION\n  2\nTABLES\n";
Xstatic char GPFAR dxfi2[] = "\
X0\nTABLE\n  2\nLTYPE\n 70\n    %d\n\
X0\nLTYPE\n  2\nCONTINUOUS\n 70\n    64\n\
X  3\nSolid line\n 72\n    65\n 73\n      0\n 40\n0.0\n\
X  0\nLTYPE\n  2\nDASHED\n 70\n    64\n\
X  3\n__ __ __ __ __ __ __ __ __ __ __ __ __ __ __\n\
X 72\n    65\n 73\n     2\n 40\n0.75\n 49\n0.5\n 49\n-0.25\n\
X  0\nLTYPE\n  2\nHIDDEN\n 70\n    64\n\
X  3\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\
X 72\n    65\n 73\n     2\n 40\n0.375\n 49\n0.25\n 49\n-0.125\n\
X  0\nLTYPE\n  2\nCENTER\n 70\n    64\n\
X  3\n____ _ ____ _ ____ _ ____ _ ____ _ ____ _ ____\n\
X 72\n    65\n 73\n     4\n 40\n2.0\n 49\n1.25\n 49\n-0.25\n\
X 49\n0.25\n 49\n-0.25\n\
X  0\nLTYPE\n  2\nPHANTOM\n 70\n    64\n\
X  3\n_____ _ _ _____ _ _ _____ _ _ _____ _ _ ____\n\
X 72\n    65\n 73\n     6\n 40\n2.5\n 49\n1.25\n\
X 49\n-0.25\n 49\n0.25\n 49\n-0.25\n 49\n0.25\n 49\n-0.25\n\
X  0\nLTYPE\n  2\nDOT\n 70\n    64\n\
X  3\n...............................................\n\
X 72\n    65\n 73\n     2\n 40\n0.25\n 49\n0.0\n 49\n-0.25\n\
X  0\nLTYPE\n  2\nDASHDOT\n 70\n    64\n\
X  3\n__ . __ . __ . __ . __ . __ . __ . __ . __ . __\n\
X 72\n    65\n 73\n     4\n 40\n1.0\n 49\n0.5\n 49\n-0.25\n\
X 49\n0.0\n 49\n-0.25\n\
X  0\nENDTAB\n";
X
X	fprintf(outfile, dxfi1,
X		t->xmax/DXF_UNIT,t->ymax/DXF_UNIT,
X		t->xmax/DXF_UNIT,t->ymax/DXF_UNIT,
X		text_style,
X		DXF_TEXTHEIGHT/DXF_UNIT,
X		LINEWIDTH,
X		LT_SCALE,
X		layer_colour[0]);
X	/* the linetype table */
X	fprintf(outfile, dxfi2, DXF_LINE_TYPES);
X	/* the layer table */
X	fprintf(outfile,"  0\nTABLE\n  2\nLAYER\n 70\n   %-d\n",MAX_LAYER);
X	for (i = 1; i <= MAX_LAYER; i++)
X		fprintf(outfile,"  0\nLAYER\n  2\n%s\n 70\n   64\n62\n   %s\n  6\n%s\n",
X			layer_name[i-1],layer_colour[i-1],layer_lines[i-1]);
X	fprintf(outfile,"  0\nENDTAB\n0\nENDSEC\n");
X	/* no blocks for insertion */
X	fprintf(outfile,"  0\nSECTION\n  2\nBLOCKS\n  0\nENDSEC\n");
X	/* start the entity section */
X	fprintf(outfile,"  0\nSECTION\n");
X	fprintf(outfile,"  2\nENTITIES\n");
X}
X
XDXF_text()
X{
X	if (vector_was_last) fprintf(outfile,"  0\nSEQEND\n");
X	fprintf(outfile,"  0\nENDSEC\n  0\nEOF\n");
X}
X
XDXF_linetype(linetype)
X	int linetype;
X{
X	linetype = abs(linetype);
X	linetype = linetype%DXF_LINE_TYPES;
X	dxf_linetype = linetype;
X}
X
XDXF_move(x, y)
X	unsigned int x, y;
X{
X	DXF_posx = x;
X	DXF_posy = y;
X	if (vector_was_last) fprintf(outfile,"  0\nSEQEND\n");
X	vector_was_last = FALSE;
X	fprintf(outfile,"  0\nPOLYLINE\n  8\n%s\n 66\n   1\n",layer_name[dxf_linetype]);
X	fprintf(outfile,"  6\n%s\n",layer_lines[dxf_linetype]);
X	fprintf(outfile,"  0\nVERTEX\n  8\n%s\n",layer_name[dxf_linetype]);
X	fprintf(outfile,"  6\n%s\n",layer_lines[dxf_linetype]);
X	fprintf(outfile," 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n",DXF_posx/DXF_UNIT,DXF_posy/DXF_UNIT);
X}
X
XDXF_vector(ux, uy)
X	unsigned int ux, uy;
X{
X	DXF_posx = ux;
X	DXF_posy = uy;
X	vector_was_last = TRUE;
X	fprintf(outfile,"  0\nVERTEX\n  8\n%s\n",layer_name[dxf_linetype]);
X	fprintf(outfile,"  6\n%s\n",layer_lines[dxf_linetype]);
X	fprintf(outfile,"  10\n%-6.3f\n  20\n%-6.3f\n  30\n0.000\n",
X					DXF_posx/DXF_UNIT,DXF_posy/DXF_UNIT);
X}
X
XDXF_put_text(x, y, str)
X	int x, y;
X	char str[];
X{
X	int stl;
X	float xleftpos, yleftpos, xrightpos,yrightpos;
X	/* ignore empty strings */
X	if (str[0] == '\0') return;
X
X	stl = 0; while (str[stl] != '\0') ++stl; /* get string length */
X
X	if (vector_was_last) fprintf(outfile,"  0\nSEQEND\n");
X	vector_was_last = FALSE;
X	fprintf(outfile,"  0\nTEXT\n  8\n%s\n",layer_name[TEXT_LAYER]);
X	if (dxf_angle != 90.0)
X	{
X	   switch (dxf_justify)
X	   {
X	   	case LEFT  : xleftpos = (float) x;
X			     yleftpos = (float)(y-DXF_VCHAR/4.0);
X			     xrightpos = (float)(x+stl*DXF_TEXTWIDTH);
X			     yrightpos = yleftpos; break;
X	   	case RIGHT : xleftpos = (float)(x-stl*DXF_TEXTWIDTH);
X			     yleftpos = (float)(y-DXF_VCHAR/4.0);
X			     xrightpos = (float) x;
X			     yrightpos = yleftpos; break;
X		case CENTRE: xleftpos = (float)(x-stl*DXF_TEXTWIDTH/2.0);
X			     yleftpos = (float)(y-DXF_VCHAR/4.0);
X			     xrightpos = (float) x;  /* center point */
X			     yrightpos = yleftpos;
X			     break;
X	    }
X	}
X	else
X	{
X	    switch (dxf_justify)
X	    {
X	   	case LEFT  : xleftpos = (float)(x+DXF_VCHAR/4.0);
X			     yleftpos = (float) y;
X			     xrightpos = xleftpos;
X			     yrightpos = (float)(y+stl*DXF_TEXTWIDTH); break;
X	   	case RIGHT : xleftpos = (float)(x+DXF_VCHAR/4.0);
X			     yleftpos = (float)(y-stl*DXF_HCHAR);
X			     xrightpos = xleftpos;
X			     yrightpos = (float) y; break;
X		case CENTRE: xleftpos = (float)(x+DXF_VCHAR/4.0);
X			     yleftpos = (float)(y-stl*DXF_TEXTWIDTH/2.0);
X			     xrightpos = xleftpos;
X			     yrightpos = (float) y;  /* center point */
X			     break;
X	    }
X	}
X	fprintf(outfile," 10\n%-6.3f\n 20\n%-6.3f\n 30\n0.000\n",
X				xleftpos/DXF_UNIT,yleftpos/DXF_UNIT);
X	fprintf(outfile," 40\n%-6.3f\n  1\n%s\n 50\n%-6.3f\n",
X			DXF_TEXTHEIGHT/DXF_UNIT,str,dxf_angle);
X	fprintf(outfile,"  7\n%s\n",text_style);
X	if (dxf_justify != LEFT)
X	{
X		fprintf(outfile," 72\n%d\n",dxf_justify);
X		fprintf(outfile," 11\n%-6.3f\n 21\n%-6.3f\n 31\n0.000\n",
X				xrightpos/DXF_UNIT,yrightpos/DXF_UNIT);
X	}
X}
X
XDXF_text_angle(angle)
X	int angle;
X{
X	dxf_angle = 0.0;
X	if (angle == 1) dxf_angle = 90.0;
X	return(TRUE);
X}
X
XDXF_justify_text(mode)
X	enum JUSTIFY mode;
X{
X	dxf_justify = mode;
X	return(TRUE);
X}
X
XDXF_reset()
X{
X	DXF_posx = DXF_posy = 0;
X}
X
X
END_OF_FILE
  if test 9202 -ne `wc -c <'gnuplot/term/dxf.trm'`; then
    echo shar: \"'gnuplot/term/dxf.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/dxf.trm'
fi
if test -f 'gnuplot/term/rgip.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/rgip.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/rgip.trm'\" \(8514 characters\)
  sed "s/^X//" >'gnuplot/term/rgip.trm' <<'END_OF_FILE'
X/*
X * $Id: rgip.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - rgip.trm Uniplex graphics metafile */
X/*
X * Copyright (C) 1990
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   RGIP metafile
X *
X * AUTHORS
X *   Hans Olav Eggestad
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X/*
X * Original for direct RGIP Metafile output.
X */
X/* 
X * Max pixels for X and Y in one window is 10000.
X */
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#define RGIP_X_MAX 10000
X#define RGIP_Y_MAX 10000
X#define RGIP_XMAX 9900
X#define RGIP_YMAX 9900
X
X#define RGIPDOTS 0
X#define RGIPMARK 1
X#define RGIPTEXT 2
X#define RGIPLINE 3
X#define RGIPPOLY 4
Xstatic char *RGIP_Obj[6] = { "DOTS", "MARK", "TEXT", "LINE", "POLY" };
X
X/* 
X * RGIP fontsises range from 1 to 8 
X */
X
X#define RGIP_SC (300)
X#define RGIP_FONTSIZE 1
X#define RGIP_FACES 3
X#define RGIP_FSTYLES 4
X#define RGIP_FSIZES 8
X#define RGIP_HELVETICA 0
X#define RGIP_TIMES 1
X#define RGIP_COURIER 2
X#define RGIP_LINE_WIDTHS 8 /* future, currently invisible and visible 0
Xand 1 */
X#define RGIP_LINE_TYPES 8
X#define RGIP_COLORS 16
X#define RGIP_POINT_TYPES 8
X
X
X
X#define RGIP_HTIC (100)
X#define RGIP_VTIC (100)
X#define RGIP_VCHAR (RGIP_FONTSIZE*RGIP_SC) 
X#define RGIP_HCHAR (RGIP_VCHAR*3/7)   
X
Xstatic int RGIP_orgx;		/* absolute-pixel-ORIgin of graph.	*/
Xstatic int RGIP_orgy;
Xstatic int RGIP_posx;		/* current drawing position (lines).	*/
Xstatic int RGIP_posy;
Xstatic int RGIP_inplot;
Xstatic int RGIP_xmax;		/* width of graph in pixels.		*/
Xstatic int RGIP_ymax;		/* height of graph in pixels.		*/
Xstatic int RGIP_blofs;		/* BaseLine OFfSet from bounding box.	*/
Xstatic int RGIP_angle = 0;	/* 0 for horizontal text, 90 for vertical */
Xstatic enum JUSTIFY RGIP_justify = LEFT; /* left/center/right */
Xstatic int RGIP_fface = 2;  /* Times */
Xstatic int RGIP_ftype = 1; /* style roman */
Xstatic int RGIP_fontsize = RGIP_FONTSIZE; /*  */
Xstatic int RGIP_tcol = 7;  /* text color */
Xstatic int RGIP_lsty = 1;  /* line style */
Xstatic int RGIP_lcol = 7;  /* line color */
Xstatic int RGIP_lwid = 1;  /* line width */
Xstatic int RGIP_fsty = 1;  /* fill style */
Xstatic int RGIP_fcol = 7;  /* fill color */
Xstatic int RGIP_mcol = 7;  /* marker color */
Xstatic int RGIP_msty = 1;  /* marker style */
Xstatic int RGIP_msize = 1;  /* marker size */
X
X
Xstatic unsigned char *RGIP_cvts();
X
X
XRGIP_init()
X{
X    RGIP_posx = RGIP_posy = 0;
X
X    RGIP_orgx = (RGIP_X_MAX - RGIP_XMAX) / 2;
X    RGIP_orgy = (RGIP_Y_MAX - RGIP_YMAX) / 2;
X
X}
X
XRGIP_graphics()
X{
X    static int Gnr = 0;
X    struct stat buf;
X    unsigned char *p, fn[128];
X
X    fstat(fileno(outfile),&buf);
X    if ( S_ISREG(buf.st_mode)) {
X	    if (p=(unsigned char *)strchr(outstr,'X')) { /* substitute X with graphnr */
X		if ( ! Gnr ) { /* delete the base file */
X		    sprintf(fn,"%s",&outstr[1]);
X		    fn[strlen(fn)-1]='\0';
X		    unlink(fn);
X		} else {
X        		fputs("%RI_GROUPEND\n", outfile);
X			fclose(outfile);
X		}
X		*p = '\0';
X		sprintf(fn,"%s%1d%s",&outstr[1],++Gnr,p+1);
X	   	fn[strlen(fn)-1]='\0';
X                if ( (outfile = fopen(fn,"w")) == (FILE *)NULL ) {
X                     os_error("cannot reopen file with binary type; output unknown",
X                           NO_CARET);
X                }
X		*p = 'X';  /* put back X */
X            }
X    }
X    fputs("%RGIP_METAFILE: 1.0a\n", outfile);
X    fputs("%RI_GROUPSTART\n", outfile);
X    fputs("%RI_GROUPSTART\n", outfile);
X
X    /* RGIP_linetype(-1); */
X}
X
XRGIP_text()
X{
X}
X
XRGIP_linetype(lt)
Xint lt;
X{
X    int pen, pattern;
X
X/*  -2: axis
X *  -1: border
X *   0: arrow
X *   1-7: graph
X*/
X    if ( lt == -2 ) {
X	lt = 1;
X	RGIP_lwid = 3;
X    } else if ( lt == -1 ) {
X	lt = 5;
X	RGIP_lwid = 1;
X    } else {
X	RGIP_lwid = (int) (lt/RGIP_LINE_TYPES);
X	if ( RGIP_lwid <= 0 ) RGIP_lwid = 1;
X    	lt  = (lt % RGIP_LINE_TYPES) + 1;
X    }
X    fputs("%RI_GROUPEND\n", outfile);
X    fputs("%RI_GROUPSTART\n", outfile);
X
X    /* RGIP_lsty  = (lt == 0 || lt == 2) ? 1 : lt; */
X
X    RGIP_lsty = lt;
X}
X
X
XRGIP_move(x,y)
X	unsigned int x,y;
X{
X/*
X    fputs("%RI_GROUPEND\n", outfile);
X    fputs("%RI_GROUPSTART\n", outfile);
X*/
X    RGIP_posx = x;
X    RGIP_posy = y;
X}
X
X
XRGIP_vector(ux,uy)
X	unsigned int ux,uy;
X{
X    /* Create line */
X
X    fprintf(outfile,"%1d %1d %1d %1d",
X        RGIP_posx + RGIP_orgx,
X        RGIP_posy + RGIP_orgy,
X    	ux + RGIP_orgx,
X    	uy + RGIP_orgy);
X
X    fprintf(outfile," %1d %d %1d %s\n", RGIP_lwid, RGIP_lsty,
X        RGIP_lcol, RGIP_Obj[RGIPLINE]);
X
X    RGIP_posx = ux;
X    RGIP_posy = uy;
X    /* RGIP_move(ux, uy); */
X}
X
X
XRGIP_text_angle(angle)
X	int angle;
X{
X    if (RGIP_angle != angle) {
X	   RGIP_angle = angle;	/* record for later use */
X    }
X
X    return(TRUE);
X}
X
XRGIP_justify_text(mode)
X	enum JUSTIFY mode;
X{
X    RGIP_justify = mode;
X    return(TRUE);
X}
X
Xstatic unsigned char *
XRGIP_cvts(str,lcnt)
X	unsigned char		*str;
X	int *lcnt;			/* lines */
X{
X    unsigned char		*cp1;
X    unsigned char		*cp2;
X    static unsigned char	*buf = NULL;
X    int lc = 1;
X
X    lc = 1;
X    /* Free up old buffer, if there is one, get a new one.  Since	*/
X    /* all transformations shorten the string, get a buffer that is	*/
X    /* the same size as the input string.				*/
X
X    if (buf != NULL)
X	 (void) free(buf);
X    buf = (unsigned char *) alloc(strlen(str), "converted label string");
X
X    /* Do the transformations. */
X
X    cp1 = str;
X    cp2 = buf;
X    while (strlen(cp1) > 0) {
X	   switch (*cp1) {
X		    case  '\\' :	/* Escape sequence. */
X			 if (*++cp1 == '\\') {
X				/* Begin new line. */
X				*cp2++ = '\n';
X				lc++;
X				break;
X			 }
X		
X		    /* Fall through to just copy next char out.	*/
X		
X		    default :
X			 *cp2++ = *cp1;
X		    break;
X		}
X	   cp1++;
X    }
X 
X    *cp2++ = '\n';
X    *cp2 = '\0';
X    *lcnt = lc; 
X    return (buf);
X}
X
XRGIP_put_text(x, y, str)
X	int x,y;				/* reference point of string */
X	unsigned char str[];			/* the text */
X{
X    register struct termentry *t = &term_tbl[term];
X    unsigned char *cvstr, *p;
X    int xlines;		/* lines */
X 
X    cvstr = RGIP_cvts(str,&xlines);
X
X    x += RGIP_orgx,
X    y += RGIP_orgy;
X
X    if (! RGIP_angle) {  	/* horisontal */
X	y += (int)(t->v_char)*(xlines-2)/2;
X	/* y += (t->v_char)*xlines; */
X	y += (int)(t->v_char)/4;
X    } else {
X	x -= (int)(t->v_char)*(xlines-2)/2;
X	x -= (int)(t->v_char)/4;
X    }
X
X    while ( p=(unsigned char *)strchr(cvstr,'\n' )) {
X	*p = '\0';
X	if (strlen(cvstr)) 
X    	    fprintf(outfile,"%1d %1d %1d  %1d (%s) %1d %1d %1d %1d %s\n",
X            	x,y,RGIP_justify, RGIP_angle*90, cvstr, RGIP_fface, RGIP_ftype,
X            	RGIP_fontsize, RGIP_tcol, RGIP_Obj[RGIPTEXT]);
X	cvstr = ++p;
X	if (RGIP_angle) { 	/* vertical */
X		x += (t->v_char);
X	} else {
X		y -= (t->v_char);
X	}
X    }
X}
X
X
XRGIP_reset()
X{
X    fputs("%RI_GROUPEND\n", outfile);
X    fputs("%RI_GROUPEND\n", outfile);
X}
X
Xstatic void
XRGIP_setfont(sz)
X    int sz;
X{
X    RGIP_fontsize = (int) (sz);
X    if ( RGIP_fontsize < 1 ) RGIP_fontsize = 1;
X    term_tbl[term].v_char = (unsigned int)(RGIP_fontsize*RGIP_SC);
X    term_tbl[term].h_char = (unsigned int)(RGIP_fontsize*RGIP_SC*3/7);
X}
X 
XRGIP_do_point(x,y,number)
Xint x,y;
Xint number;
X{
X
X    x += RGIP_orgx,
X    y += RGIP_orgy;
X
X    if (number < 0) {		/* do dot */
X        fprintf(outfile,"%1d %1d %1d %s\n",
X               x,y,RGIP_mcol,RGIP_Obj[RGIPDOTS]);
X	    return;
X	}
X
X	RGIP_msty = (number % RGIP_POINT_TYPES) + 1;
X	RGIP_msize = ((int)(number / RGIP_POINT_TYPES)) + 1;
X
X    fprintf(outfile,"%1d %1d %1d %1d %1d %s\n",
X               x,y,RGIP_msize, RGIP_msty, RGIP_mcol, RGIP_Obj[RGIPMARK]);
X}
X
XRGIP_options()
X{
X	extern struct value *const_express();
X	extern double real();
X
X	if (!END_OF_COMMAND) {
X		/* We have font size specified */
X		struct value a;
X		RGIP_fontsize = (int)real(const_express(&a));
X		if ( RGIP_fontsize < 1 ) 
X			RGIP_fontsize = 1;
X		term_tbl[term].v_char = (unsigned int)(RGIP_fontsize*RGIP_SC);
X		term_tbl[term].h_char = (unsigned int)(RGIP_fontsize*RGIP_SC*3/7);
X	}
X	sprintf(term_options,"%d",RGIP_fontsize);
X}
END_OF_FILE
  if test 8514 -ne `wc -c <'gnuplot/term/rgip.trm'`; then
    echo shar: \"'gnuplot/term/rgip.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/rgip.trm'
fi
if test -f 'gnuplot/term/x11.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/x11.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/x11.trm'\" \(8636 characters\)
  sed "s/^X//" >'gnuplot/term/x11.trm' <<'END_OF_FILE'
X/*
X * $Id: x11.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/*
X *    x11.trm  --- inboard terminal driver for X11
X */
X
X#define X11_XMAX 4096
X#define X11_YMAX 4096
X
X/* approximations for typical font/screen sizes */
X#define X11_VCHAR (X11_YMAX/25) 
X#define X11_HCHAR (X11_XMAX/100) 
X#define X11_VTIC (X11_YMAX/100)
X#define X11_HTIC (X11_XMAX/150)
X
Xint X11_Display = 0; /* non-zero if '-display' found on command line */
X
X#define X11_nopts 27
Xchar X11_opts[X11_nopts][20] = {
X   "-mono", "-gray", "-clear", "-tvtwm", "-pointsize",
X   "-iconic", "-rv", "-reverse", "+rv", "-synchronous", 
X   "-display", "-geometry", "-bg", "-background", "-bd", "-bordercolor", "-bw",
X   "-borderwidth", "-fg", "-foreground", "-fn", "-font", "-name", 
X   "-selectionTimeout", "-title", "-xnllanguage", "-xrm" 
X   };
Xint X11_optarg[X11_nopts] = { 
X   0, 0, 0, 0, 1,
X   0, 0, 0, 0, 0,
X   1, 1, 1, 1, 1, 1, 1,
X   1, 1, 1, 1, 1, 1, 
X   1, 1, 1, 1
X   };
X
XFILE *X11_ipc; 
Xchar X11_command[1024]= "gnuplot_x11";
X
X/*   X11_args - scan gnuplot command line for standard X Toolkit options */
X
XX11_args(argc, argv) int argc; char *argv[]; {
X   int nx11 = 0, n;
X
X   while(++argv, --argc > 0) {
X      for (n=0; n<X11_nopts; n++) {
X	 if (!strcmp(*argv, X11_opts[n])) {
X	    strcat(X11_command, " ");
X	    strcat(X11_command, *argv); 
X	    !strcmp(*argv, "-display") && X11_Display++;
X	    if (X11_optarg[n]) {
X	       if (--argc <= 0) return(nx11);
X	       strcat(X11_command, " \"");
X	       strcat(X11_command, *++argv); 
X	       strcat(X11_command, "\"");
X	       nx11++;
X	       }
X	    nx11++; break;
X	    }
X	 }
X      if (n == X11_nopts) break; 
X      }
X   return(nx11);
X   }
X
X/*-----------------------------------------------------------------------------
X *   Three different versions of the remainder of the X11 terminal driver
X *   are provided to support three different types of IPC with the
X *   gnuplot_x11 outboard terminal driver:
X * 
X *   DEFAULT_X11:      popen() pipe for most un*x platforms
X *
X *   CRIPPLED_SELECT : file IPC for un*x platforms with incomplete or faulty
X *                     implementation of BSD select()
X *
X *   VMS :             mailbox/spawn IPC
X *---------------------------------------------------------------------------*/
X
X#define DEFAULT_X11
X#if defined(VMS) || defined(CRIPPLED_SELECT)
X#undef DEFAULT_X11
X#endif
X#if defined(VMS) && defined(CRIPPLED_SELECT)
XError. Incompatible options.
X#endif
X
X
X#ifdef DEFAULT_X11
X/*-----------------------------------------------------------------------------
X *   DEFAULT_X11 popen() pipe IPC
X *---------------------------------------------------------------------------*/
XFILE *popen();
X
XX11_init() { X11_ipc = popen(X11_command, "w"); }
X
XX11_graphics() { 
X   fprintf(X11_ipc, "G\n"); 
X   fprintf(X11_ipc, "P7%04d%04d\n", /* size of point symbols */
X	   term_tbl[term].h_tic / 2, term_tbl[term].v_tic / 2); 
X#ifdef ULTRIX_KLUDGE
X   fflush(X11_ipc);
X#endif
X   }
X
XX11_text() { 
X   fprintf(X11_ipc, "E\n"); fflush(X11_ipc);
X#ifdef ULTRIX_KLUDGE
X   fprintf(X11_ipc, "E\n"); fflush(X11_ipc);
X#endif
X   }
X
XX11_reset() { fprintf(X11_ipc, "R\n"); fflush(X11_ipc); pclose(X11_ipc); }
X
XX11_move(x,y) unsigned int x,y; { fprintf(X11_ipc, "M%04d%04d\n", x, y); }
X
XX11_vector(x,y) unsigned int x,y; { fprintf(X11_ipc, "V%04d%04d\n", x, y); }
X
XX11_linetype(lt) int lt; { fprintf(X11_ipc, "L%04d\n", lt); }
X
XX11_put_text(x,y,str) unsigned int x,y; char str[]; {
X   fprintf(X11_ipc, "T%04d%04d%s\n", x, y, str);
X   }
X
XX11_justify_text(mode) enum JUSTIFY mode; {
X   fprintf(X11_ipc, "J%04d\n", mode);
X   return(TRUE);
X   }
X
XX11_point(x,y,number) unsigned int x,y; int number; {
X   if (number>=0)
X      number %= POINT_TYPES;
X   number += 1;
X   fprintf(X11_ipc, "P%01d%04d%04d\n", number, x, y);
X   }
X
X#endif /* DEFAULT_X11 */
X
X
X#ifdef CRIPPLED_SELECT
X/*-----------------------------------------------------------------------------
X *   CRIPPLED_SELECT file IPC
X *---------------------------------------------------------------------------*/
X
Xchar X11_tmp[32], X11_tmp0[32], X11_shutdown[32];
Xint X11_pid;
X
XX11_init() { 
X   if (!(X11_pid = fork())) {
X      execl("/bin/sh", "sh", "-c", X11_command, NULL);
X      _exit(1);
X      }
X   sprintf(X11_tmp, "/tmp/Gnuplot_%d", X11_pid);
X   sprintf(X11_tmp0, "%s-", X11_tmp);
X   sprintf(X11_shutdown, "echo R >%s", X11_tmp);
X   }
X
XX11_graphics() { 
X   X11_ipc = fopen(X11_tmp0, "w"); 
X   if (!X11_ipc) { perror(X11_tmp0); system(X11_shutdown); exit(1); }
X   fprintf(X11_ipc, "G\n"); 
X   fprintf(X11_ipc, "P7%04d%04d\n", /* size of point symbols */
X	   term_tbl[term].h_tic / 2, term_tbl[term].v_tic / 2); 
X#ifdef ULTRIX_KLUDGE
X   fflush(X11_ipc);
X#endif
X   }
X
XX11_text() { 
X   fprintf(X11_ipc, "E\n"); 
X#ifdef ULTRIX_KLUDGE
X   fprintf(X11_ipc, "E\n");
X#endif
X   fclose(X11_ipc);
X   rename(X11_tmp0, X11_tmp);
X   }
X
XX11_reset() { system(X11_shutdown); }
X
XX11_move(x,y) unsigned int x,y; { fprintf(X11_ipc, "M%04d%04d\n", x, y); }
X
XX11_vector(x,y) unsigned int x,y; { fprintf(X11_ipc, "V%04d%04d\n", x, y); }
X
XX11_linetype(lt) int lt; { fprintf(X11_ipc, "L%04d\n", lt); }
X
XX11_put_text(x,y,str) unsigned int x,y; char str[]; {
X   fprintf(X11_ipc, "T%04d%04d%s\n", x, y, str);
X   }
X
XX11_justify_text(mode) enum JUSTIFY mode; {
X   fprintf(X11_ipc, "J%04d\n", mode);
X   return(TRUE);
X   }
X
XX11_point(x,y,number) unsigned int x,y; int number; {
X   if (number>=0)
X      number %= POINT_TYPES;
X   number += 1;
X   fprintf(X11_ipc, "P%01d%04d%04d\n", number, x, y);
X   }
X#endif /* CRIPPLED_SELECT */
X
X
X#ifdef VMS
X/*-----------------------------------------------------------------------------
X *   VMS mailbox/spawn IPC - Yehavi Bourvine - YEHAVI@VMS.HUJI.AC.IL
X *---------------------------------------------------------------------------*/
X
X#include <iodef.h>
X#include <descrip.h>
X#define MAILBOX "PLOT_X11$MAILBOX"
X
Xint vaxc$errno;
Xstatic short X11_channel;
Xstatic $DESCRIPTOR(lognamedsc,MAILBOX);
X
XX11_init() {
X
X   /* Create a descriptor for the command. $DESCRIP doesn't work in 
X   this context... */
X   struct { 
X      short size, type; 
X      char *address;
X      } pgmdsc = { strlen(X11_command), 0, X11_command };
X
X
X   /* Create a mailbox which will be used as a pipe for commands to the 
X   subprocess.  What we'll write to it will be read by the subprocess as 
X   its STDIN. */
X   vaxc$errno = sys$crembx(0,&X11_channel,128,128,0,0,&lognamedsc,0);
X   if (!(vaxc$errno)&1) {
X      printf("SYS$CreMbx failed with status=%d\r\n", vaxc$errno);
X      os_error("sys$crembx failed",NO_CARET);
X      }
X
X   /* Assign an I/O channel to it */
X   vaxc$errno = sys$assign(&lognamedsc,&X11_channel,0,0,0);
X   if (!(vaxc$errno & 1)) {
X      printf("SYS$Assign failed with status=%d\r\n", vaxc$errno);
X      os_error("sys$crembx failed",NO_CARET);
X      }
X
X   /* Create a subprocess whose input is this mailbox. */
X   vaxc$errno = lib$spawn(&pgmdsc,&lognamedsc,0,&1,0,0,0,0,0,0,0,0,0);
X   if (!((vaxc$errno) & 1)) {
X      printf("LIB$SPAWN failed with status=%d\r\n", vaxc$errno);
X      os_error("lib$spawn failed",NO_CARET);
X      }
X   }
X
X/*   We use $QIO in order to avoid buffering problems, although it might 
X *   work  as well with simple Fprintf calls.  */
X
XX11_vmsqiow(buf) char *buf; {
X   int status = sys$qiow(0, X11_channel, IO$_WRITEVBLK, 0, 0, 0, 
X			 buf, strlen(buf), 0, 0, 0, 0);
X   if((status & 0x1) == 0) exit(status);
X   }
X
Xchar   X11_vmsbuf[512];
X
XX11_graphics() { 
X   sprintf(X11_vmsbuf, "G\n");
X   X11_vmsqiow(X11_vmsbuf);
X   sprintf(X11_vmsbuf, "P7%04d%04d\n", /* size of point symbols */
X	   term_tbl[term].h_tic / 2, term_tbl[term].v_tic / 2); 
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_text() {
X   sprintf(X11_vmsbuf, "E\n");
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_reset() { 
X   sprintf(X11_vmsbuf, "R\n");
X   X11_vmsqiow(X11_vmsbuf);
X   sleep(2);		/* Wait for subprocess to finish */
X   sys$dassgn(X11_channel);
X   }
X
XX11_move(x,y) unsigned int x,y; { 
X   sprintf(X11_vmsbuf, "M%04d%04d\n", x, y);
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_vector(x,y) unsigned int x,y; { 
X   sprintf(X11_vmsbuf, "V%04d%04d\n", x, y);
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_linetype(lt) int lt; { 
X   sprintf(X11_vmsbuf, "L%04d\n", lt);
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_put_text(x,y,str) unsigned int x,y; char str[]; { 
X   sprintf(X11_vmsbuf, "T%04d%04d%s\n", x, y, str);
X   X11_vmsqiow(X11_vmsbuf);
X   }
X
XX11_justify_text(mode) enum JUSTIFY mode; { 
X   sprintf(X11_vmsbuf, "J%04d\n", mode);
X   X11_vmsqiow(X11_vmsbuf);
X   return(TRUE);
X   }
X
XX11_point(x,y,number) unsigned int x,y; int number; {
X   if (number>=0)
X      number %= POINT_TYPES;
X   number += 1;
X   sprintf(X11_vmsbuf, "P%01d%04d%04d\n", number, x, y);
X   X11_vmsqiow(X11_vmsbuf);
X   }
X#endif /* VMS */
END_OF_FILE
  if test 8636 -ne `wc -c <'gnuplot/term/x11.trm'`; then
    echo shar: \"'gnuplot/term/x11.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/x11.trm'
fi
if test -f 'gnuplot/win/winmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/winmain.c'\"
else
  echo shar: Extracting \"'gnuplot/win/winmain.c'\" \(9026 characters\)
  sed "s/^X//" >'gnuplot/win/winmain.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: winmain.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X/* GNUPLOT - win/winmain.c */
X/*
X * Copyright (C) 1992   Maurice Castro, Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Maurice Castro
X *   Russell Lang
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X */
X
X/* This file implements the initialization code for running gnuplot   */
X/* under Microsoft Windows. The code currently compiles only with the */
X/* Borland C++ 3.1 compiler. 
X/*                                                                    */
X/* The modifications to allow Gnuplot to run under Windows were made  */
X/* by Maurice Castro. (maurice@bruce.cs.monash.edu.au)  3 Jul 1992    */
X/* and Russell Lang (rjl@monu1.cc.monash.edu.au) 30 Nov 1992          */
X/*                                                                    */
X 
X#define STRICT
X#include <windows.h>
X#include <windowsx.h>
X#include <dos.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X#ifdef __MSC__
X#include <malloc.h>
X#else
X#include <alloc.h>
X#endif
X#include <io.h>
X#include "plot.h"
X#include "setshow.h"
X#include "wgnuplib.h"
X#include "wtext.h"
X
X/* limits */
X#define MAXSTR 255
X#define MAXPRINTF 1024
X
X/* globals */
XTW textwin;
XGW graphwin;
XPW pausewin;
XMW menuwin;
XLPSTR szModuleName;
XLPSTR winhelpname;
XLPSTR szMenuName;
X#define MENUNAME "wgnuplot.mnu"
X
Xextern char version[];
Xextern char patchlevel[];
Xextern char date[];
Xextern char *authors[];
Xextern char copyright[];
Xextern void close_printer();
Xvoid WinExit(void);
Xint gnu_main(int argc, char *argv[], char *env[]);
X
Xvoid
XCheckMemory(LPSTR str)
X{
X	if (str == (LPSTR)NULL) {
X		MessageBox(NULL, "out of memory", "gnuplot", MB_ICONSTOP | MB_OK);
X		exit(1);
X	}
X}
X
Xint
XPause(LPSTR str)
X{
X	pausewin.Message = str;
X	return (PauseBox(&pausewin) == IDOK);
X}
X
X/* atexit procedure */
Xvoid
XWinExit(void)
X{
X	if (term && term_init)
X		(*term_tbl[term].reset)();
X	if ( !strcmp(outstr,"'PRN'") )
X		close_printer();
X	fcloseall();
X	if (graphwin.hWndGraph && IsWindow(graphwin.hWndGraph))
X		GraphClose(&graphwin);
X	TextMessage();	/* process messages */
X 	WinHelp(textwin.hWndText,(LPSTR)winhelpname,HELP_QUIT,(DWORD)NULL);
X	TextClose(&textwin);
X	TextMessage();	/* process messages */
X	return;
X}
X
X/* call back function from Text Window WM_CLOSE */
Xint CALLBACK _export
XShutDown(void)
X{
X	WinExit();
X	exit(0);
X	return 0;
X}
X
Xint PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
X		LPSTR lpszCmdLine, int nCmdShow)
X{
X	WNDCLASS wndclass;
X	LPSTR tail;
X	
X#if defined(__MSC__)    /* MSC doesn't give us _argc and _argv[] so ...   */
X#define MAXCMDTOKENS 128
X	int     _argc=0;
X	LPSTR   _argv[MAXCMDTOKENS];
X	_argv[_argc] = "wgnuplot.exe";
X	_argv[++_argc] = _fstrtok( lpszCmdLine, " ");
X	while (_argv[_argc] != NULL)
X		_argv[++_argc] = _fstrtok( NULL, " ");
X#endif
X
X  	szModuleName = (LPSTR)farmalloc(MAXSTR+1);
X  	CheckMemory(szModuleName);
X	szModuleName = (LPSTR)farmalloc(MAXSTR+1);
X	CheckMemory(szModuleName);
X
X	/* get path to EXE */
X	GetModuleFileName(hInstance, (LPSTR) szModuleName, MAXSTR);
X	if (CheckWGNUPLOTVersion(WGNUPLOTVERSION)) {
X		MessageBox(NULL, "Wrong version of WGNUPLOT.DLL", szModuleName, MB_ICONSTOP | MB_OK);
X		exit(1);
X	}
X	if ((tail = _fstrrchr(szModuleName,'\\')) != (LPSTR)NULL)
X	{
X		tail++;
X		*tail = NULL;
X	}
X	szModuleName = farrealloc(szModuleName, _fstrlen(szModuleName)+1);
X	CheckMemory(szModuleName);
X
X	winhelpname = (LPSTR)farmalloc(_fstrlen(szModuleName)+_fstrlen(HELPFILE)+1);
X	CheckMemory(winhelpname);
X	_fstrcpy(winhelpname,szModuleName);
X	_fstrcat(winhelpname,HELPFILE);
X
X	szMenuName = (LPSTR)farmalloc(_fstrlen(szModuleName)+_fstrlen(MENUNAME)+1);
X	CheckMemory(szMenuName);
X	_fstrcpy(szMenuName,szModuleName);
X	_fstrcat(szMenuName,MENUNAME);
X
X	textwin.hInstance = hInstance;
X	textwin.hPrevInstance = hPrevInstance;
X	textwin.nCmdShow = nCmdShow;
X	textwin.Title = "gnuplot";
X	textwin.IniFile = "wgnuplot.ini";
X	textwin.IniSection = "WGNUPLOT";
X	textwin.DragPre = "load '";
X	textwin.DragPost = "'\n";
X	textwin.lpmw = &menuwin;
X	textwin.ScreenSize.x = 80;
X	textwin.ScreenSize.y = 80;
X	textwin.KeyBufSize = 2048;
X	textwin.CursorFlag = 1;	/* scroll to cursor after \n & \r */
X	textwin.shutdown = MakeProcInstance((FARPROC)ShutDown, hInstance);
X	textwin.AboutText = (LPSTR)farmalloc(1024);
X	CheckMemory(textwin.AboutText);
X	sprintf(textwin.AboutText,"Version %s\nPatchlevel %s\nLast Modified %s\n%s\n%s, %s",
X		version, patchlevel, date, copyright, authors[1], authors[0]);
X	textwin.AboutText = farrealloc(textwin.AboutText, _fstrlen(textwin.AboutText)+1);
X	CheckMemory(textwin.AboutText);
X
X	menuwin.szMenuName = szMenuName;
X
X	pausewin.hInstance = hInstance;
X	pausewin.hPrevInstance = hPrevInstance;
X	pausewin.Title = "gnuplot pause";
X
X	graphwin.hInstance = hInstance;
X	graphwin.hPrevInstance = hPrevInstance;
X	graphwin.Title = "gnuplot graph";
X	graphwin.lptw = &textwin;
X	graphwin.IniFile = textwin.IniFile;
X	graphwin.IniSection = textwin.IniSection;
X	graphwin.color=TRUE;
X	graphwin.fontsize = WINFONTSIZE;
X
X	if (TextInit(&textwin))
X		exit(1);
X	textwin.hIcon = LoadIcon(hInstance, "texticon");
X#ifdef WIN32
X	SetClassLong(textwin.hWndParent, GCL_HICON, (DWORD)textwin.hIcon);
X#else
X	SetClassWord(textwin.hWndParent, GCW_HICON, (WORD)textwin.hIcon);
X#endif
X	if (_argc>1)
X		ShowWindow(textwin.hWndParent,SW_SHOWMINIMIZED);
X	if (IsIconic(textwin.hWndParent)) { /* update icon */
X		RECT rect;
X		GetClientRect(textwin.hWndParent, (LPRECT) &rect);
X		InvalidateRect(textwin.hWndParent, (LPRECT) &rect, 1);
X		UpdateWindow(textwin.hWndParent);
X	}
X
X
X	atexit(WinExit);
X
X	gnu_main(_argc, _argv, environ);
X
X	return 0;
X}
X
X
X/* replacement stdio routines that use Text Window for stdin/stdout */
X/* WARNING: Do not write to stdout/stderr with functions not listed 
X   in win/wtext.h */
X
X#undef kbhit
X#undef getche
X#undef getch
X#undef putch
X
X#undef fgetc
X#undef getchar
X#undef getc
X#undef fgets
X#undef gets
X
X#undef fputc
X#undef putchar
X#undef putc
X#undef fputs
X#undef puts
X
X#undef fprintf
X#undef printf
X#undef vprintf
X#undef vfprintf
X
X#undef fwrite
X#undef fread
X
X#ifdef __MSC__
X#define isterm(f) (f==stdin || f==stdout || f==stderr)
X#else
X#define isterm(f) isatty(fileno(f))
X#endif
X
Xint
XMyPutCh(int ch)
X{
X	return TextPutCh(&textwin, (BYTE)ch);
X}
X
Xint
XMyKBHit(void)
X{
X	return TextKBHit(&textwin);
X}
X
Xint
XMyGetCh(void)
X{
X	return TextGetCh(&textwin);
X}
X
Xint
XMyGetChE(void)
X{
X	return TextGetChE(&textwin);
X}
X
Xint
XMyFGetC(FILE *file)
X{
X	if (isterm(file)) {
X		return MyGetChE();
X	}
X	return fgetc(file);
X}
X
Xchar *
XMyGetS(char *str)
X{
X	TextPutS(&textwin,"\nDANGER: gets() used\n");
X	MyFGetS(str,80,stdin);
X	if (strlen(str) > 0 
X	 && str[strlen(str)-1]=='\n')
X		str[strlen(str)-1] = '\0';
X	return str;
X}
X
Xchar *
XMyFGetS(char *str, unsigned int size, FILE *file)
X{
Xchar FAR *p;
X	if (isterm(file)) {
X		p = TextGetS(&textwin, str, size);
X		if (p != (char FAR *)NULL)
X			return str;
X		return (char *)NULL;
X	}	
X	return fgets(str,size,file);
X}
X
Xint
XMyFPutC(int ch, FILE *file)
X{
X	if (isterm(file)) {
X		MyPutCh((BYTE)ch);
X		TextMessage();
X		return ch;
X	}
X	return fputc(ch,file);
X}
X
Xint
XMyFPutS(char *str, FILE *file)
X{
X	if (isterm(file)) {
X		TextPutS(&textwin, str);
X		TextMessage();
X		return (*str);	/* different from Borland library */
X	}
X	return fputs(str,file);
X}
X
Xint
XMyPutS(char *str)
X{
X	TextPutS(&textwin, str);
X	MyPutCh('\n');
X	TextMessage();
X	return 0;	/* different from Borland library */
X}
X
Xint MyFPrintF(FILE *file, char *fmt, ...)
X{
Xint count;
Xva_list args;
X	va_start(args,fmt);
X	if (isterm(file)) {
X		char buf[MAXPRINTF];
X		count = vsprintf(buf,fmt,args);
X		TextPutS(&textwin,buf);
X	}
X	else
X		count = vfprintf(file, fmt, args);
X	va_end(args);
X	return count;
X}
X
Xint MyPrintF(char *fmt, ...)
X{
Xint count;
Xchar buf[MAXPRINTF];
Xva_list args;
X	va_start(args,fmt);
X	count = vsprintf(buf,fmt,args);
X	TextPutS(&textwin,buf);
X	va_end(args);
X	return count;
X}
X
Xsize_t MyFWrite(const void *ptr, size_t size, size_t n, FILE *file)
X{
X	if (isterm(file)) {
X		int i;
X		for (i=0; i<n; i++)
X			TextPutCh(&textwin, ((BYTE *)ptr)[i]);
X		TextMessage();
X		return n;
X	}
X	return fwrite(ptr, size, n, file);
X}
X
Xsize_t MyFRead(void *ptr, size_t size, size_t n, FILE *file)
X{
X	if (isterm(file)) {
X		int i;
X		for (i=0; i<n; i++)
X			((BYTE *)ptr)[i] = TextGetChE(&textwin);
X		TextMessage();
X		return n;
X	}
X	return fread(ptr, size, n, file);
X}
END_OF_FILE
  if test 9026 -ne `wc -c <'gnuplot/win/winmain.c'`; then
    echo shar: \"'gnuplot/win/winmain.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/winmain.c'
fi
echo shar: End of archive 24 \(of 33\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
