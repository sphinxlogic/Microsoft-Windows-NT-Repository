Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i040:  gnuplot - interactive function plotting utility, Part28/33
Message-ID: <1993Oct25.030214.2621@sparky.sterling.com>
X-Md4-Signature: e9306ee2e9f1519dd9672a285ef6eb1f
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 25 Oct 1993 03:02:14 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 40
Archive-name: gnuplot/part28
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/using.dat gnuplot/docs/doc2ms.c
#   gnuplot/docs/doc2tex.c gnuplot/gnuplot.el gnuplot/makefile.nt
#   gnuplot/makefile.tc gnuplot/makefile.win gnuplot/setshow.h
#   gnuplot/term/iris4d.trm gnuplot/term/pslatex.trm
#   gnuplot/term/tgif.trm gnuplot/win/wgnuplib.rc
#   gnuplot/win/wgnuplot.rc
# Wrapped by kent@sparky on Wed Oct 20 17:15:01 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 28 (of 33)."'
if test -f 'gnuplot/demo/using.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/using.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/using.dat'\" \(5630 characters\)
  sed "s/^X//" >'gnuplot/demo/using.dat' <<'END_OF_FILE'
X#
X# $Id: using.dat 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X#
X891101 00   1.00  14   8.6  94.0
X891101 01   1.04  10  17.5  94.4
X891101 02   1.08   9   9.7  97.1
X891101 03   1.13   9  10.1  94.3
X891101 04   1.17   9   5.7  98.3
X891101 05   1.21   8   8.1  99.7
X891101 06   1.25   7   3.2  99.6
X891101 07   1.29   6   2.5  99.8
X891101 08   1.33  20   2.3  99.4
X891101 09   1.38  30   3.5  96.1
X891101 10   1.42  37   7.7  96.4
X891101 11   1.46  36   9.8  97.4
X891101 12   1.50  30   8.8  97.4
X891101 13   1.54  32   9.1  96.5
X891101 14   1.58  37   6.3  97.0
X891101 15   1.63  35   6.1  97.3
X891101 16   1.67  41   8.6  97.2
X891101 17   1.71  28   7.6  97.3
X891101 18   1.75  16   4.3  97.6
X891101 19   1.79  21   4.2  97.5
X891101 20   1.83  20   5.6  96.9
X891101 21   1.88  24   6.6  96.2
X891101 22   1.92  19   5.8  97.1
X891101 23   1.96  16   7.4  97.1
X891102 00   2.00  13   7.4  96.4
X891102 01   2.04   8   6.6  95.6
X891102 02   2.08   6   7.4  94.1
X891102 03   2.13   6   6.4  95.9
X891102 04   2.17   7   6.4  95.5
X891102 05   2.21   6   6.7  95.5
X891102 06   2.25   6   6.3  94.6
X891102 07   2.29   7   6.5  93.1
X891102 08   2.33  15   6.5  92.8
X891102 09   2.38  22   7.2  93.2
X891102 10   2.42  31   9.1  93.9
X891102 11   2.46  37  11.0  95.6
X891102 12   2.50  40   9.8  98.7
X891102 13   2.54  45   9.5  97.3
X891102 14   2.58  46  11.4  98.5
X891102 15   2.63  46  11.9  99.1
X891102 16   2.67  43  13.0  98.8
X891102 17   2.71  28  14.5  99.1
X891102 18   2.75  25  13.4  99.1
X891102 19   2.79  24   9.9  99.7
X891102 20   2.83  25   8.1  99.5
X891102 21   2.88  24  10.3  99.4
X891102 22   2.92  24  12.0  98.7
X891102 23   2.96  23  18.2  98.7
X891103 00   3.00  20  16.8  99.0
X891103 01   3.04  16  14.8  99.2
X891103 02   3.08  17  15.5  98.0
X891103 03   3.13  17  14.4  99.4
X891103 04   3.17  16  14.4  99.4
X891103 05   3.21  14  11.3  99.4
X891103 06   3.25  13   8.0  99.7
X891103 07   3.29  13   6.1  99.9
X891103 08   3.33  18   6.4  99.8
X891103 09   3.38  31   6.5  98.9
X891103 10   3.42  39   7.5  99.0
X891103 11   3.46  37   9.1  98.8
X891103 12   3.50  33   9.0  99.2
X891103 13   3.54  40  10.4  98.7
X891103 14   3.58  45  12.9  98.3
X891103 15   3.63  45  13.8  98.5
X891103 16   3.67  37  16.1  98.9
X891103 17   3.71  29  16.0  99.3  57
X891103 18   3.75  21  17.4  97.9  55
X891103 19   3.79  14  14.6  97.7
X891103 20   3.83  11  14.3  97.8  57
X891103 21   3.88  15  14.7  96.2  59
X891103 22   3.92  10  12.8  95.1  57
X891103 23   3.96   8  10.2  97.6
X891104 00   4.00   6   7.3  98.6
X891104 01   4.04   4   4.7  99.8
X891104 02   4.08   3   3.4  98.0
X891104 03   4.13   4   2.9  99.6
X891104 04   4.17   4   2.1  99.8
X891104 05   4.21   4  11.7  99.9
X891104 06   4.25   4   4.5  99.9
X891104 07   4.29   4   1.6  88.4
X891104 08   4.33   4   1.3  65.2
X891104 09   4.38   7   1.4  71.4
X891104 10   4.42   9   1.3  70.7
X891104 11   4.46  14   8.1  99.5
X891104 12   4.50  12   4.2  75.3
X891104 13   4.54  18  10.9  95.3
X891104 14   4.58  16   7.1  87.6
X891104 15   4.63  18   3.3  98.9
X891104 16   4.67  15   3.4  99.6
X891104 17   4.71   8   2.4  99.9
X891104 18   4.75   8   2.2  99.8
X891104 19   4.79  11   2.2  99.7
X891104 20   4.83  14   2.3  99.7
X891104 21   4.88  13   2.5  99.7
X891104 22   4.92  10   3.1  99.8
X891104 23   4.96  12   4.5  99.7
X891105 00   5.00   9   4.8  99.7
X891105 01   5.04   8   4.9  99.8
X891105 02   5.08   5   5.7  97.5
X891105 03   5.13   5   5.2  97.6
X891105 04   5.17   4   3.3  85.9
X891105 05   5.21   5   1.2  71.4
X891105 06   5.25   5   1.1  61.8
X891105 07   5.29   5   1.0  71.8
X891105 08   5.33   5   1.0  55.7
X891105 09   5.38   6   1.0  62.2
X891105 10   5.42   7   1.1  61.9
X891105 11   5.46   9   1.4  65.6
X891105 12   5.50  14   2.8  99.6
X891105 13   5.54  16   2.1  94.0
X891105 14   5.58  16   2.2  85.1
X891105 15   5.63  17   2.5  99.7
X891105 16   5.67  19   2.2  90.8
X891105 17   5.71  16   1.5  61.3
X891105 18   5.75  12   1.6  71.8
X891105 19   5.79  16   2.8  98.3
X891105 20   5.83  17   3.3  88.8
X891105 21   5.88  18   1.3  56.5
X891105 22   5.92  20   0.9  38.8
X891105 23   5.96  12   1.1  50.8
X891106 00   6.00  10   2.2  68.4
X891106 01   6.04   8   1.2  54.4
X891106 02   6.08   8   1.6  58.4
X891106 03   6.13   7   1.1  52.2
X891106 04   6.17   6   1.1  56.4
X891106 05   6.21   6   1.2  55.7
X891106 06   6.25   6   1.0  46.2
X891106 07   6.29   7   0.5   7.2
X891106 08   6.33  17   0.7  13.8
X891106 09   6.38  31   1.1  41.5
X891106 10   6.42  37   1.5  52.7
X891106 11   6.46  36   3.1  83.7
X891106 12   6.50  29   2.0  70.0
X891106 13   6.54  28   1.6  71.4
X891106 14   6.58  38   3.1  99.1
X891106 15   6.63  39   5.6  98.2
X891106 16   6.67  43   5.7  98.7  59
X891106 17   6.71  27   5.7  99.4
X891106 18   6.75  15   4.3  99.8
X891106 19   6.79  17   4.1  99.7
X891106 20   6.83  20   2.9  99.3
X891106 21   6.88  16   3.1  96.3
X891106 22   6.92  16   2.8  86.1
X891106 23   6.96  16   3.3  96.5
X891107 00   7.00  12   3.2  98.2
X891107 01   7.04  12   1.6  77.7
X891107 02   7.08  10   3.0  98.7
X891107 03   7.13   8   1.7  71.1
X891107 04   7.17   8   2.8  81.4
X891107 05   7.21   8   5.4  92.4
X891107 06   7.25   9   5.3  87.7
X891107 07   7.29  11   5.6  94.0
X891107 08   7.33  15   2.0  74.0
X891107 09   7.38  25   2.7  84.3
X891107 10   7.42  32   3.0  92.9
X891107 11   7.46  41   5.5  97.4
X891107 12   7.50  39   6.5  97.5
X891107 13   7.54  31   4.4  95.9
X891107 14   7.58  35   7.3  98.6
X891107 15   7.63  37   8.3  96.3
X891107 16   7.67  34   9.2  97.6
X891107 17   7.71  20   7.5  99.3
X891107 18   7.75  14   7.1  99.5
X891107 19   7.79  15   7.1  99.7
X891107 20   7.83  16   4.9  99.7
X891107 21   7.88  18   4.3  99.7
X891107 22   7.92  15   3.1  99.7
X891107 23   7.96  11   3.3  99.6
END_OF_FILE
  if test 5630 -ne `wc -c <'gnuplot/demo/using.dat'`; then
    echo shar: \"'gnuplot/demo/using.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/using.dat'
fi
if test -f 'gnuplot/docs/doc2ms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/doc2ms.c'\"
else
  echo shar: Extracting \"'gnuplot/docs/doc2ms.c'\" \(5822 characters\)
  sed "s/^X//" >'gnuplot/docs/doc2ms.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: doc2ms.c%v 3.38.2.70 1993/02/08 02:19:29 woo Exp woo $";
X#endif
X
X
X/*
X * doc2ms.c  -- program to convert Gnuplot .DOC format to *roff -ms document
X * From hlp2ms by Thomas Williams 
X *
X * Modified by Russell Lang, 2nd October 1989
X * to make vms help level 1 and 2 create the same ms section level.
X *
X * Modified to become doc2ms by David Kotz (David.Kotz@Dartmouth.edu) 12/89
X * Added table and backquote support.
X *
X * usage:  doc2ms [file.doc [file.ms]]
X *
X *   where file.doc is a VMS .DOC file, and file.ms will be a [nt]roff
X *     document suitable for printing with nroff -ms or troff -ms
X *
X * typical usage for GNUPLOT:
X *
X *   doc2ms gnuplot.doc | tbl | eqn | troff -ms
X *
X * or
X *
X *   doc2ms gnuplot.doc | groff -ms -et >gnuplot.ps
X */
X
X#include <stdio.h>
X#include <ctype.h>
X
X#define MAX_NAME_LEN	256
X#define MAX_LINE_LEN	256
X#define LINE_SKIP		3
X
X#define TRUE 1
X#define FALSE 0
X
Xtypedef int boolean;
X
Xstatic boolean intable = FALSE;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
XFILE * infile;
XFILE * outfile;
X	infile = stdin;
X	outfile = stdout;
X	if (argc > 3) {
X		fprintf(stderr,"Usage: %s [infile [outfile]]\n", argv[0]);
X		exit(1);
X	}
X	if (argc >= 2) 
X		if ( (infile = fopen(argv[1],"r")) == (FILE *)NULL) {
X			fprintf(stderr,"%s: Can't open %s for reading\n",
X				argv[0], argv[1]);
X			exit(1);
X		}
X	if (argc == 3)
X		if ( (outfile = fopen(argv[2],"w")) == (FILE *)NULL) {
X			fprintf(stderr,"%s: Can't open %s for writing\n",
X				argv[0], argv[2]);
X		}
X	
X	init(outfile);
X	convert(infile,outfile);
X	finish(outfile);
X	exit(0);
X}
X
X
Xinit(b)
XFILE *b;
X{
X    /* in nroff, increase line length by 8 and don't adjust lines */
X    (void) fputs(".if n \\{.nr LL +8m\n.na \\}\n",b);
X    (void) fputs(".nr PO +0.3i\n",b);
X    (void) fputs(".so titlepag.ms\n",b);
X    (void) fputs(".pn 1\n",b);
X    (void) fputs(".bp\n",b);
X    (void) fputs(".ta 1.5i 3.0i 4.5i 6.0i 7.5i\n",b);
X    (void) fputs("\\&\n.sp 3\n.PP\n",b);
X    /* following line commented out by rjl
X	  (void) fputs(".so intro\n",b);
X	  */
X}
X
X
Xconvert(a,b)
X	FILE *a,*b;
X{
X    static char line[MAX_LINE_LEN];
X
X    while (fgets(line,MAX_LINE_LEN,a)) {
X	   process_line(line, b);
X    }
X}
X
Xprocess_line(line, b)
X	char *line;
X	FILE *b;
X{
X    switch(line[0]) {		/* control character */
X	   case '?': {			/* interactive help entry */
X		  break;			/* ignore */
X	   }
X	   case '@': {			/* start/end table */
X		  if (intable) {
X			 (void) fputs(".TE\n.KE\n", b);
X			 (void) fputs(".EQ\ndelim off\n.EN\n\n",b);
X			 intable = FALSE;
X		  } else {
X			 (void) fputs("\n.EQ\ndelim $$\n.EN\n",b);
X			 (void) fputs(".KS\n.TS\ncenter box tab (@) ;\n", b);
X			 (void) fputs("c c l .\n", b);
X			 intable = TRUE;
X		  }
X		  /* ignore rest of line */
X		  break;
X	   }
X	   case '#': {			/* latex table entry */
X		  break;			/* ignore */
X	   }
X	   case '%': {			/* troff table entry */
X		  if (intable)
X		    (void) fputs(line+1, b); /* copy directly */
X		  else
X		    fprintf(stderr, "error: % line found outside of table\n");
X		  break;
X	   }
X	   case '\n':			/* empty text line */
X	   case ' ': {			/* normal text line */
X		  if (intable)
X		    break;		/* ignore while in table */
X		  switch(line[1]) {
X			 case ' ': {
X				/* verbatim mode */
X				fputs(".br\n",b); 
X				putms_verb(line+1,b); 
X				fputs(".br\n",b);
X				break;
X			 }
X			 case '\'': {
X				fputs("\\&",b);
X				putms(line+1,b); 
X				break;
X			 }
X			 default: {
X				if (line[0] == '\n')
X				  putms(line,b); /* handle totally blank line */
X				else
X				  putms(line+1,b);
X				break;
X			 }
X			 break;
X		  }
X		  break;
X	   }
X	   default: {
X		  if (isdigit(line[0])) { /* start of section */
X			 if (!intable)	/* ignore while in table */
X			   section(line, b);
X		  } else
X		    fprintf(stderr, "unknown control code '%c' in column 1\n", 
X				  line[0]);
X		  break;
X	   }
X    }
X}
X
X
X/* process a line with a digit control char */
X/* starts a new [sub]section */
X
Xsection(line, b)
X	char *line;
X	FILE *b;
X{
X    static char string[MAX_LINE_LEN];
X    int sh_i;
X    static int old = 1;
X
X  
X    (void) sscanf(line,"%d %[^\n]s",&sh_i,string);
X    
X    (void) fprintf(b,".sp %d\n",(sh_i == 1) ? LINE_SKIP : LINE_SKIP-1);
X    
X    if (sh_i > old) {
X	   do
X		if (old!=1)	/* this line added by rjl */
X		  (void) fputs(".RS\n.IP\n",b);
X	   while (++old < sh_i);
X    }
X    else if (sh_i < old) {
X	   do
X			   if (sh_i!=1) /* this line added by rjl */
X				(void) fputs(".RE\n.br\n",b);
X	   while (--old > sh_i);
X    }
X    
X    /* added by dfk to capitalize section headers */
X    if (islower(string[0]))
X	 string[0] = toupper(string[0]);
X    
X    /* next 3 lines added by rjl */
X    if (sh_i!=1) 
X	 (void) fprintf(b,".NH %d\n%s\n.sp 1\n.LP\n",sh_i-1,string);
X    else 
X	 (void) fprintf(b,".NH %d\n%s\n.sp 1\n.LP\n",sh_i,string);
X    old = sh_i;
X    
X    (void) fputs(".XS\n",b);
X    (void) fputs(string,b);
X    (void) fputs("\n.XE\n",b);
X}
X
Xputms(s, file)
X	char *s;
X	FILE *file;
X{
X    static boolean inquote = FALSE;
X
X    while (*s != '\0') {
X	   switch (*s) {
X		  case '`': {		/* backquote -> boldface */
X			 if (inquote) {
X				fputs("\\fR", file);
X				inquote = FALSE;
X			 } else {
X				fputs("\\fB", file);
X				inquote = TRUE;
X			 }
X			 break;
X		  }
X		  case '\\': {		/* backslash */
X			 fputs("\\\\", file);
X			 break;
X		  }
X		  default: {
X			 fputc(*s, file);
X			 break;
X		  }
X	   }
X	   s++;
X    }
X}
X
X/*
X * convert a verbatim line to troff input style, i.e. convert "\" to "\\"
X * (added by Alexander Lehmann 01/30/93)
X */
X
Xputms_verb(s, file)
X	char *s;
X	FILE *file;
X{
X    static boolean inquote = FALSE;
X
X    while (*s != '\0') {
X	   if (*s == '\\') {
X		 fputc('\\', file);
X	   }
X	   fputc(*s, file);
X	   s++;
X    }
X}
X
Xfinish(b)		/* spit out table of contents */
XFILE *b;
X{
X	(void) fputs(".pn 1\n",b);
X	(void) fputs(".ds RH %\n",b);
X	(void) fputs(".af % i\n",b);
X	(void) fputs(".bp\n.PX\n",b);
X}
END_OF_FILE
  if test 5822 -ne `wc -c <'gnuplot/docs/doc2ms.c'`; then
    echo shar: \"'gnuplot/docs/doc2ms.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/doc2ms.c'
fi
if test -f 'gnuplot/docs/doc2tex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/doc2tex.c'\"
else
  echo shar: Extracting \"'gnuplot/docs/doc2tex.c'\" \(5314 characters\)
  sed "s/^X//" >'gnuplot/docs/doc2tex.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: doc2tex.c%v 3.38.2.70 1993/02/08 02:19:29 woo Exp woo $";
X#endif
X
X
X/*
X * doc2tex.c  -- program to convert Gnuplot .DOC format to LaTeX document
X * Also will work for VMS .HLP files. 
X * Modified by Russell Lang from hlp2ms.c by Thomas Williams 
X * Extended by David Kotz to support quotes ("), backquotes, tables.
X *
X * usage:  doc2tex [file.doc [file.tex]]
X *
X *   where file.doc is a Gnuplot .DOC file, and file.tex will be an
X *     article document suitable for printing with LaTeX.
X *
X * typical usage for GNUPLOT:
X *
X *   doc2tex gnuplot.doc gnuplot.tex 
X *   latex gnuplot.tex ; latex gnuplot.tex
X */
X
X#include <stdio.h>
X#include <ctype.h>
X
X#define MAX_NAME_LEN	256
X#define MAX_LINE_LEN	256
X#define TRUE 1
X#define FALSE 0
X
Xtypedef int boolean;
X
Xboolean intable = FALSE;
Xboolean verb = FALSE;
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
XFILE * infile;
XFILE * outfile;
X	infile = stdin;
X	outfile = stdout;
X	if (argc > 3) {
X		fprintf(stderr,"Usage: %s [infile [outfile]]\n", argv[0]);
X		exit(1);
X	}
X	if (argc >= 2) 
X		if ( (infile = fopen(argv[1],"r")) == (FILE *)NULL) {
X			fprintf(stderr,"%s: Can't open %s for reading\n",
X				argv[0], argv[1]);
X			exit(1);
X		}
X	if (argc == 3)
X		if ( (outfile = fopen(argv[2],"w")) == (FILE *)NULL) {
X			fprintf(stderr,"%s: Can't open %s for writing\n",
X				argv[0], argv[2]);
X		}
X	
X	init(outfile);
X	convert(infile,outfile);
X	finish(outfile);
X	exit(0);
X}
X
X
Xinit(b)
XFILE *b;
X{
X	(void) fputs("\\input{titlepag.tex}\n",b);
X}
X
X
Xconvert(a,b)
X	FILE *a,*b;
X{
X    static char line[MAX_LINE_LEN];
X
X    while (fgets(line,MAX_LINE_LEN,a)) {
X	   process_line(line, b);
X    }
X}
X
Xprocess_line(line, b)
X	char *line;
X	FILE *b;
X{
X    switch(line[0]) {		/* control character */
X	   case '?': {			/* interactive help entry */
X		  break;			/* ignore */
X	   }
X	   case '@': {			/* start/end table */
X		  if (intable) {
X			 (void) fputs("\\hline\n\\end{tabular}\n", b);
X			 (void) fputs("\\end{center}\n",b);
X			 intable = FALSE;
X		  } else {
X			 if (verb) {
X				(void) fputs("\\end{verbatim}\n",b);
X				verb=FALSE;
X			 } 
X			 (void) fputs("\n\\begin{center}\n", b);
X			 (void) fputs("\\begin{tabular}{|ccl|} \\hline\n", b);
X			 intable = TRUE;
X		  }
X		  /* ignore rest of line */
X		  break;
X	   }
X	   case '#': {			/* latex table entry */
X		  if (intable)
X		    (void) fputs(line+1, b); /* copy directly */
X		  else
X		    fprintf(stderr, "error: # line found outside of table\n");
X		  break;
X	   }
X	   case '%': {			/* troff table entry */
X		  break;			/* ignore */
X	   }
X	   case '\n':			/* empty text line */
X	   case ' ': {			/* normal text line */
X		  if (intable)
X		    break;		/* ignore while in table */
X		  if (line[1] == ' ') {
X			 /* verbatim mode */
X			 if (!verb) {
X				(void) fputs("\\begin{verbatim}\n",b);
X				verb=TRUE;
X			 }
X			 (void) fputs(line+1,b); 
X		  } else {
X			 if (verb) {
X				(void) fputs("\\end{verbatim}\n",b);
X				verb=FALSE;
X			 } 
X			 if (line[0] == '\n')
X			   puttex(line,b); /* handle totally blank line */
X			 else
X			   puttex(line+1,b);
X		  }
X		  break;
X	   }
X	   default: {
X		  if (isdigit(line[0])) { /* start of section */
X			 if (!intable)	/* ignore while in table */
X			   section(line, b);
X		  } else
X		    fprintf(stderr, "unknown control code '%c' in column 1\n", 
X				  line[0]);
X		  break;
X	   }
X    }
X}
X
X/* process a line with a digit control char */
X/* starts a new [sub]section */
X
Xsection(line, b)
X	char *line;
X	FILE *b;
X{
X    static char string[MAX_LINE_LEN];
X    int sh_i;
X
X    if (verb) {
X	   (void) fputs("\\end{verbatim}\n",b);
X	   verb=FALSE;
X    } 
X    (void) sscanf(line,"%d %[^\n]s",&sh_i,string);
X    switch(sh_i)
X	 {
X		case 1: 
X		(void) fprintf(b,"\\section{");
X		break;
X		case 2: 
X		(void) fprintf(b,"\\section{");
X		break;
X		case 3:
X		(void) fprintf(b,"\\subsection{");
X		break;
X		case 4: 
X		(void) fprintf(b,"\\subsubsection{");
X		break;
X		default:
X		case 5: 
X		(void) fprintf(b,"\\paragraph{");
X		break;
X	 }
X    if (islower(string[0]))
X	 string[0] = toupper(string[0]);
X    puttex(string,b);
X    (void) fprintf(b,"}\n");
X}
X
X/* put text in string str to file while buffering special TeX characters */
Xputtex(str,file)
XFILE *file;
Xregister char *str;
X{
Xregister char ch;
Xstatic boolean inquote = FALSE;
X
X	 while( (ch = *str++) != '\0') {
X		 switch(ch) {
X			 case '#':
X			 case '$':
X			 case '%':
X			 case '&':
X			 case '_':
X			 case '{':
X			 case '}':
X				 (void) fputc('\\',file);
X				 (void) fputc(ch,file);
X				 break;
X			 case '\\':
X				 (void) fputs("$\\backslash$",file);
X				 break;
X			 case '~':
X				 (void) fputs("\\~{\\ }",file);
X				 break;
X			 case '^':
X				 (void) fputs("\\verb+^+",file);
X				 break;
X			 case '>':
X			 case '<':
X			 case '|':
X				 (void) fputc('$',file);
X				 (void) fputc(ch,file);
X				 (void) fputc('$',file);
X				 break;
X			 case '"': 
X				 /* peek at next character: if space, end of quote */
X				 if (*str == '\0' || isspace(*str) || ispunct(*str))
X				   (void) fputs("''", file);
X				 else
X				   (void) fputs("``", file);
X				 break;
X			 case '`':	/* backquotes mean boldface */
X				 if (inquote) {
X					fputs("}", file);
X					inquote = FALSE;
X				 } else {
X					fputs("{\\bf ", file);
X					inquote = TRUE;
X				 }
X				 break;
X			 default:
X				 (void) fputc(ch,file);
X				 break;
X		 }
X	 }
X}
X
X
Xfinish(b)
XFILE *b;
X{
X	(void) fputs("\\end{document}\n",b);
X}
END_OF_FILE
  if test 5314 -ne `wc -c <'gnuplot/docs/doc2tex.c'`; then
    echo shar: \"'gnuplot/docs/doc2tex.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/doc2tex.c'
fi
if test -f 'gnuplot/gnuplot.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/gnuplot.el'\"
else
  echo shar: Extracting \"'gnuplot/gnuplot.el'\" \(5562 characters\)
  sed "s/^X//" >'gnuplot/gnuplot.el' <<'END_OF_FILE'
X;;
X;; $Id: gnuplot.el%v 3.50 1993/07/09 05:35:24 woo Exp $
X;;
X;;
X; 
X; gnu-plot.el - Definitions of GNU-PLOT mode for emacs editor.
X; 
X; Author:	Gershon Elber
X; 		Computer Science Dept.
X; 		University of Utah
X; Date:	Tue May 14 1991
X; Copyright (c) 1991, 1992, Gershon Elber
X;
X; This file defines an environment to run edit and execute GNU-PLOT programs.
X; Such a program should have a '.gp' extension in order it to be in
X; gnu-plot-mode major mode. Two new functions are provided to communicate
X; between the editted file and the plotting program:
X; 1. send-line-to-gnu-plot - sends a single line to the plotting program for
X;    execution. The line sent is the line the cursor is on,
X;    Bounded to Meta-E by default.
X; 2. send-region-to-gnu-plot - sends the region from the current mark
X;    (mark-marker) to current position (point-marker) to the plotting program.
X;    This function is convenient for sending a large block of commands.
X;    Bounded to Meta-R by default.
X; Both functions checks for existance of a buffer named gnu-plot-program
X; and a process named "gnu-plot" hooked to it, and will restart a new process
X; or buffer if none exists. The program to execute as process "gnu-plot" is
X; defined by the gnu-plot-program constant below.
X;
X
X(defvar gnu-plot-program "gnuplot"
X  "*The executable to run for gnu-plot-program buffer.")
X
X(defvar gnu-plot-echo-program t
X  "*Control echo of executed commands to gnu-plot-program buffer.")
X
X(defvar gnu-plot-mode-map nil "")
X(if gnu-plot-mode-map
X    ()
X  (setq gnu-plot-mode-map (make-sparse-keymap))
X  (define-key gnu-plot-mode-map "\M-e" 'send-line-to-gnu-plot)
X  (define-key gnu-plot-mode-map "\M-r" 'send-region-to-gnu-plot))
X
X;;;
X;;; Define the gnu-plot-mode
X;;;
X(defun gnu-plot-mode ()
X  "Major mode for editing and executing GNU-PLOT files.
X
Xsee send-line-to-gnu-plot and send-region-to-gnu-plot for more."
X  (interactive)
X  (use-local-map gnu-plot-mode-map)
X  (setq major-mode 'gnu-plot-mode)
X  (setq mode-name "Gnu-Plot")
X  (run-hooks 'gnu-plot-mode-hook))
X
X;;;
X;;; Define send-line-to-gnu-plot - send from current cursor position to next
X;;; semicolin detected.
X;;;
X(defun send-line-to-gnu-plot ()
X  "Sends one line of code from current buffer to the GNU-PLOT program.
X
XUse to execute a line in the GNU-PLOT plotting program. The line sent is
Xthe line the cursor (point) is on.
X
XThe GNU-PLOT plotting program buffer name is gnu-plot-program and the 
Xprocess name is 'gnu-plot'. If none exists, a new one is created.
X
XThe name of the gnu-plot program program to execute is stored in
Xgnu-plot-program variable and may be changed."
X  (interactive)
X  (if (equal major-mode 'gnu-plot-mode)
X    (progn
X      (make-gnu-plot-buffer)        ; In case we should start a new one.
X      (beginning-of-line)
X      (let ((start-mark (point-marker)))
X	(next-line 1)
X	(let* ((crnt-buffer (buffer-name))
X	       (end-mark (point-marker))
X	       (string-copy (buffer-substring start-mark end-mark)))
X	  (switch-to-buffer-other-window (get-buffer "gnu-plot-program"))
X	  (end-of-buffer)
X	  (if gnu-plot-echo-program
X	    (insert string-copy))
X	  (set-marker (process-mark (get-process "gnu-plot")) (point-marker))
X	  (if (not (pos-visible-in-window-p))
X	    (recenter 3))
X	  (switch-to-buffer-other-window (get-buffer crnt-buffer))
X	  (process-send-region "gnu-plot" start-mark end-mark)
X	  (goto-char end-mark))))
X    (message "Should be invoked in gnu-plot-mode only.")))
X
X;;;
X;;; Define send-region-to-gnu-plot - send from current cursor position to
X;;; current marker.
X;;;
X(defun send-region-to-gnu-plot ()
X  "Sends a region of code from current buffer to the GNU-PLOT program.
X
XWhen this function is invoked on an GNU-PLOT file it send the region
Xfrom current point to current mark to the gnu-plot plotting program.
X
XThe GNU-PLOT plotting program buffer name is gnu-plot-program and the
Xprocess name is 'gnu-plot'. If none exists, a new one is created.
X
XThe name of the gnu-plot program program to execute is stored in
Xgnu-plot-program variable and may be changed."
X  (interactive)
X  (if (equal major-mode 'gnu-plot-mode)
X    (progn
X      (make-gnu-plot-buffer)     ; In case we should start a new one.
X      (copy-region-as-kill (mark-marker) (point-marker))
X      (let ((crnt-buffer (buffer-name)))
X	(switch-to-buffer-other-window (get-buffer "gnu-plot-program"))
X	(end-of-buffer)
X	(if gnu-plot-echo-program
X	  (yank))
X	(set-marker (process-mark (get-process "gnu-plot")) (point-marker))
X	(if (not (pos-visible-in-window-p))
X	  (recenter 3))
X	(switch-to-buffer-other-window (get-buffer crnt-buffer))
X	(process-send-region "gnu-plot" (mark-marker) (point-marker))))
X    (message "Should be invoked in gnu-plot-mode only.")))
X
X;;;
X;;; Switch to "gnu-plot-program" buffer if exists. If not, creates one and
X;;; execute the program defined by gnu-plot-program.
X;;;
X(defun make-gnu-plot-buffer ()
X  "Switch to gnu-plot-program buffer or create one if none exists"
X  (interactive)
X  (if (get-buffer "gnu-plot-program")
X    (if (not (get-process "gnu-plot"))
X      (progn
X	(message "Starting GNU-PLOT plotting program...")
X	(start-process "gnu-plot" "gnu-plot-program" gnu-plot-program)
X	(process-send-string "gnu-plot" "\n")
X	(message "Done.")))
X    (progn
X      (message "Starting GNU-PLOT plotting program...")
X      (start-process "gnu-plot" "gnu-plot-program" gnu-plot-program)
X      (process-send-string "gnu-plot" "\n")
X      (message "Done."))))
X
X;;;
X;;; Autoload gnu-plot-mode on any file with gp extension. 
X;;;
X(setq auto-mode-alist (append '(("\\.gp$" . gnu-plot-mode))
X			      auto-mode-alist))
END_OF_FILE
  if test 5562 -ne `wc -c <'gnuplot/gnuplot.el'`; then
    echo shar: \"'gnuplot/gnuplot.el'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/gnuplot.el'
fi
if test -f 'gnuplot/makefile.nt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.nt'\"
else
  echo shar: Extracting \"'gnuplot/makefile.nt'\" \(5755 characters\)
  sed "s/^X//" >'gnuplot/makefile.nt' <<'END_OF_FILE'
X#
X# Make file for Microsoft C  Version 7.0 Windows NT Version
X# and Microsoft Program Maintenance Utility  Version 1.20
X# 
X
X# This has never been tried
X
X# I do not have access to Windows NT so I have not tested any of this.
X# I don't even know if WIN32 is the appropriate #define to use!  
X# If it isn't feel free to change all occurences to the standard #define.
X# If you make changes further changes for Windows NT, make sure that 
X# gnuplot still works with Windows 3.0.
X# Also, gnuplot for Windows NT should be built WITHOUT using a DLL - compile 
X# without setting __DLL__ and then link all modules into a single EXE.
X# rjl 1993-02-01
X
X# where to place gnuplot.gih helpfile
XHELPFILE = wgnuplot.hlp
XTOP = .
X
X# /c  means don't link
X# /AL means large memory model (large code, large data)
X# /W1 means lower warning level
X# /I  means extra include directory
X# /GA means windows application
X# /Fm means produce link map
X# /Od means suppress optimizations (esp. for debug)
X# /Zi mean prepare for codeview
XCFLAGS = /c /ALw /FmGNUPLOT /GA /W1 /D__MSC__ /DREADLINE /DWIN32 /I$(TOP) #/Zi #/Od
X
X# see other terminal defines in term.h
XTERMFLAGS = 
X
X# /NOE means NO EXTernal Dictionary
X# /NOI means NO ignore case
X# /NOD means no default library (or :specified)
X# /CO prepare for codeview
XLINKFLAGS = /NOE /NOI /NOD:LLIBCE /ONERROR:NOEXE #/CO 
X
XOBJS =  bitmap.obj command.obj contour.obj eval.obj graphics.obj graph3d.obj \
X	internal.obj misc.obj parse.obj plot.obj readline.obj scanner.obj \
X	setshow.obj specfun.obj standard.obj term.obj util.obj version.obj \
X	gnubin.obj binary.obj winmain.obj
X
XCSOURCE5 = term\aed.trm term\cgi.trm term\dumb.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm 
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term/pbm.trm term\win.trm
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm
XCSOURCE8 = contour.c specfun.c gnubin.c binary.c
XWINDOWS = makefile.win makefile.msw README.win win\wcommon.h \
X	win\wgnuplib.c win\wgnuplib.def win\wgnuplib.h win\wgnuplib.rc\
X	win\wgnuplot.def win\wgnuplot.hpj win\wgnuplot.mnu win\wgnuplot.rc \
X	win\wgraph.c win\winmain.c win\wmenu.c win\wpause.c \
X	win\wprinter.c win\wresourc.h win\wtext.c win\wtext.h \
X	win\geticon.c docs\doc2rtf.c term\win.trm
X
Xdefault: wgnuplot.exe $(HELPFILE) wgnuplot.mnu demo\bf_test.exe
X
X# default rules
X.c.obj:
X	cl $(CFLAGS) $*.c
X
Xlinkopt1.msw: makefile.msw
X	echo winmain+bitmap+command+eval+graphics+ >linkopt1.msw
X	echo graph3d+internal+misc+parse+ >>linkopt1.msw
X	echo plot+scanner+setshow+specfun+ >>linkopt1.msw
X	echo standard+term+util+version+contour+ >>linkopt1.msw
X	echo gnubin+binary+readline+ >>linkopt1.msw
X	echo wgnuplib+wtext+wmenu+wpause+wgraph+wprinter > linkopt1.msw
X	echo wgnuplot,wgnuplot, >>linkopt1.msw
X	echo libw+commdlg+shell+ldllcew >> linkopt1.msw
X	echo win\wgnuplot.def >>linkopt1.msw
X	echo ; >>linkopt1.msw
X
Xwgnuplot.exe: $(OBJS) win\wgnuplot.def win\wgnuplot.rc win\wgnuplib.rc winmain.obj linkopt1.msw texticon.ico grpicon.ico
X	link $(LINKFLAGS) @linkopt1.msw
X	rc -k -dMSRC win\wgnuplot.rc wgnuplot.exe
X
X# rules
X
Xbinary.obj: binary.c 
X
Xbitmap.obj: bitmap.c bitmap.h plot.h
X
Xcommand.obj: command.c plot.h setshow.h help.h
X	cl $(CFLAGS) /DHELPFILE=\"$(HELPFILE)\" command.c
X
Xcontour.obj: contour.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgnubin.obj: gnubin.c
X
Xgraphics.obj: graphics.c plot.h setshow.h
X
Xgraph3d.obj: graphics.c plot.h setshow.h
X
Xhelp.obj: help.c plot.h help.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h setshow.h
X
Xparse.obj: parse.c plot.h
X
Xplot.obj: plot.c plot.h setshow.h
X
Xreadline.obj: readline.c
X
Xscanner.obj: scanner.c plot.h
X
Xsetshow.obj: setshow.c plot.h setshow.h
X
Xstandard.obj: standard.c plot.h
X
Xspecfun.obj: specfun.c plot.h
X
Xterm.obj: term.c term.h plot.h setshow.h bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	cl $(CFLAGS) $(TERMFLAGS) /Iterm term.c
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
Xwinmain.obj: win\winmain.c win\wgnuplib.h win\wtext.h plot.h
X	cl $(CFLAGS) /DHELPFILE=\"$(HELPFILE)\"  win\winmain.c
X
Xwgnuplib.obj: win/wgnuplib.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	
Xwmenu.obj: win/wmenu.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X
Xwtext.obj: win/wtext.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	
Xwpause.obj: win/wpause.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	
Xwprinter.obj: win/wprinter.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	
Xwgraph.obj: win/wgraph.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	
Xwgnuplot.mnu: win\wgnuplot.mnu
X	copy win\wgnuplot.mnu wgnuplot.mnu
X
X# extract icons from wgnuplot.rc
Xtexticon.ico: grpicon.ico
X
Xgrpicon.ico: geticon.exe win\wgnuplot.rc
X	geticon win\wgnuplot.rc
X
Xgeticon.exe: win\geticon.c
X	cl /AL /DMSDOS /F 5000 /Gt /W1 win\geticon.c
X
X
X# convert gnuplot.doc to gnuplot.gih
X$(HELPFILE): doc2rtf.exe docs\gnuplot.doc win\wgnuplot.hpj
X	doc2rtf docs\gnuplot.doc win\gnuplot.rtf
X	hc31 win\wgnuplot.hpj 
X
Xdoc2rtf.exe: docs\doc2rtf.c
X	cl /AL /DMSDOS /F 5000 /Gt /W1 docs\doc2rtf.c
X
X#make binary demo files
Xdemo\bf_test.exe: bf_test.c dbinary.obj
X        cl /AL /D__MSC__ /F 5000 /Gt /W1 /Fedemo\bf_test.exe bf_test.c dbinary.obj
X	cd demo
X	bf_test
X	cd ..
X
Xdbinary.obj: binary.c
X        cl /c /AL /D__MSC__ /F 5000 /Gt /W1 /Fodbinary.obj binary.c
X
X# clean up temporary files
Xclean:
X	del *.obj
X	del wgnuplot.map
X	del win\wgnuplot.res
X	del win\gnuplot.rtf
X	del doc2rtf.exe
X	del demo\bf_test.exe
X	del linkopt1.msw
X        del *.ico
X        del geticon.exe
X	
Xveryclean: clean
X	del wgnuplot.exe
X	del wgnuplot.hlp
X	del wgnuplot.mnu
X	del demo\binary1
X	del demo\binary2
X	del demo\binary3
END_OF_FILE
  if test 5755 -ne `wc -c <'gnuplot/makefile.nt'`; then
    echo shar: \"'gnuplot/makefile.nt'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.nt'
fi
if test -f 'gnuplot/makefile.tc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.tc'\"
else
  echo shar: Extracting \"'gnuplot/makefile.tc'\" \(5714 characters\)
  sed "s/^X//" >'gnuplot/makefile.tc' <<'END_OF_FILE'
X# make file for Borland C++ 3.x
X# uses Borland proprietary overlay manager
X# Modified from the TurboC makefile by Maurice Castro
X# The compile and link includes debug flags.  Take them out if you
X# do not want them included  (-y -v -M, /m /s /v /l)
X#
X# the makefile no longer depends on a linker options file.
X# this file will be created as needed.				(AL 07/17/92)
X
X# where to place gnuplot.gih helpfile
XHELPFILE = gnuplot.gih
X# location of Turbo C compiler
XTC = c:\borlandc
X#TC = c:\tc
X# name of C compiler
XCC = bcc
X#CC = tcc
X# location of TLINK.EXE and TCC.EXE or BCC.EXE
XBIN = $(TC)\bin\\
X#BIN =
X# location of BGI files,
X# change this line if not in TC directory, i.e. $(TC)\bgi
XBGI = $(TC)\bgi
X# location of bgiobj.exe tool - convertion of BGI to a linkable OBJ file.
XBGIOBJ = $(TC)\bgi\\
X#BGIOBJ =
X# location of the system libraries
XLIB = $(TC)\lib\\
X
X# the memory model to use (l = large code, large data; h = huge)
XMODEL = l
X
X# -c means don't link, -f means emulate 8087 if not present
X# -m? says which model to use
X# -M means produce link map
X# -y means include line numbers for debugger
X# -v means include debug info
X# -w- means ignore warnings and do not report them
X# -DREADLINE to use the history/line editing capability. If you want this
X#    capability add -DREADLINE to CFLAGS
X# -DLITE means no hiddenline removal to conserve memory
XCFLAGS = -Ff=256 -c -f -m$(MODEL) -w- -I$(TC)\include -DLITE -DMSDOS -DPC -DREADLINE
XTERMFLAGS =
X
X# With Overlay Support
XOVLY1 = -Y
XOVLY2 = -Yo
XOVERLIB = $(LIB)overlay
XSLASHO = /o
XODASH = /o-
X# Without Overlay Support
X#OVLY1 =
X#OVLY2 =
X#OVERLIB =
X#SLASHO =
X#ODASH =
X
XOBJ1 =  bitmap.obj command.obj contour.obj eval.obj graphics.obj graph3d.obj
XOBJ2 =	help.obj internal.obj misc.obj parse.obj plot.obj readline.obj
XOBJ3 =	scanner.obj setshow.obj specfun.obj standard.obj term.obj util.obj
XOBJ4 =	version.obj gnubin.obj binary.obj
XOBJBGI=	cgaf.obj egavgaf.obj hercf.obj attf.obj
X
XOBJS =	$(OBJ1) $(OBJ2) $(OBJ3) $(OBJ4) $(OBJBGI)
X
XCSOURCE5 = term\aed.trm term\cgi.trm term\dumb.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term\pc.trm
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm
XCSOURCE8 = contour.c specfun.c gnubin.c binary.c
X
Xall: gnuplot.exe $(HELPFILE) demo\bf_test.exe
X
X# use linkopt.tc to avoid command-line overflow
X
Xgnuplot.exe: $(OBJS) linkopt.tc
X# With or without debug information (select one)
X#	$(BIN)tlink /m /s /v /l @linkopt.tc
X	$(BIN)tlink @linkopt.tc
X
X# create linker options file
X# note that when you change the model or switch overlaying,
X# you will have to execute 'make clean'
X
Xlinkopt.tc: makefile.tc
X	echo  >linkopt.tc $(LIB)C0$(MODEL) +
X	echo >>linkopt.tc $(SLASHO) $(OBJ1) +
X	echo >>linkopt.tc $(OBJ2) +
X	echo >>linkopt.tc $(OBJ3) +
X	echo >>linkopt.tc $(OBJ4) +
X	echo >>linkopt.tc $(ODASH) $(OBJBGI) +
X	echo >>linkopt.tc ,gnuplot,gnuplot, +
X	echo >>linkopt.tc $(OVERLIB) +
X	echo >>linkopt.tc $(LIB)emu +
X	echo >>linkopt.tc $(LIB)math$(MODEL) +
X	echo >>linkopt.tc $(LIB)c$(MODEL) +
X	echo >>linkopt.tc $(LIB)graphics
X#	echo >>linkopt.tc -----
X#	echo >>linkopt.tc this file is generated automatically. don't change it, change the makefile.
X
X# default rules
X
X.c.obj:
X	$(BIN)$(CC) $(OVLY2) $(CFLAGS) $<
X
X# The default for files is to be compiled for overlaying if OVLY1 and
X# OVLY2 are defined.  plot.c and parse.c are not suitable for overlaying.
X
Xbitmap.obj: bitmap.c bitmap.h plot.h
X
Xcommand.obj: command.c plot.h setshow.h help.h
X	$(BIN)$(CC) $(OVLY2) $(CFLAGS) -DHELPFILE="$(HELPFILE)" command.c
X
Xcontour.obj: contour.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgraphics.obj: graphics.c plot.h setshow.h
X
Xgraph3d.obj: graphics.c plot.h setshow.h
X
Xhelp.obj: help.c plot.h help.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h setshow.h help.h
X
Xparse.obj: parse.c plot.h
X	$(BIN)$(CC) $(OVLY1) $(CFLAGS) parse.c
X
Xplot.obj: plot.c plot.h setshow.h
X	$(BIN)$(CC) $(OVLY1) $(CFLAGS) plot.c
X
Xreadline.obj: readline.c
X
Xscanner.obj: scanner.c plot.h
X
Xsetshow.obj: setshow.c plot.h setshow.h
X
Xspecfun.obj: specfun.c
X
Xstandard.obj: standard.c plot.h
X
X# the CSOURCE? dependencies are not up to date (but who cares)
Xterm.obj: term.c term.h plot.h setshow.c bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	$(BIN)$(CC) $(OVLY2) $(CFLAGS) $(TERMFLAGS) -Iterm term.c
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
X# convert gnuplot.doc to gnuplot.gih
X$(HELPFILE): doc2gih.exe docs\gnuplot.doc
X	doc2gih docs\gnuplot.doc $(HELPFILE)
X
Xdoc2gih.exe: docs\doc2gih.c
X    $(BIN)$(CC) -w- -ml -I$(TC)\include -L$(TC)\lib docs\doc2gih.c
X
Xdoc2tex.exe: docs\doc2tex.c
X    $(BIN)$(CC) -w- -ml -I$(TC)\include -L$(TC)\lib docs\doc2tex.c
X
Xdemo\bf_test.exe: bf_test.c binary.obj
X    $(BIN)$(CC) -edemo\bf_test.exe -w- -m$(MODEL) -I$(TC)\include -L$(TC)\lib bf_test.c binary.obj
X
X# convert Borland Graphics Interface files to object for linking
Xcgaf.obj: $(BGI)\cga.bgi
X	$(BGIOBJ)bgiobj /F $(BGI)\cga
X
Xegavgaf.obj: $(BGI)\egavga.bgi
X	$(BGIOBJ)bgiobj /F $(BGI)\egavga
X
Xhercf.obj: $(BGI)\herc.bgi
X	$(BGIOBJ)bgiobj /F $(BGI)\herc
X
Xattf.obj: $(BGI)\att.bgi
X	$(BGIOBJ)bgiobj /F $(BGI)\att
X
X# clean target - remove all temp files, but leave executable intact
X# needed when changing configuration (model or overlaying)
X
Xclean:
X	del *.obj
X	del gnuplot.map
X	del linkopt.tc
X	del doc2gih.exe
X
X# realclean target - remove all files created by the makefile
X
Xrealclean: clean
X	del gnuplot.exe
X	del gnuplot.gih
X	del demo\bf_test.exe
X	del demo\binary1
X	del demo\binary2
X	del demo\binary3
END_OF_FILE
  if test 5714 -ne `wc -c <'gnuplot/makefile.tc'`; then
    echo shar: \"'gnuplot/makefile.tc'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.tc'
fi
if test -f 'gnuplot/makefile.win' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.win'\"
else
  echo shar: Extracting \"'gnuplot/makefile.win'\" \(5839 characters\)
  sed "s/^X//" >'gnuplot/makefile.win' <<'END_OF_FILE'
X# make file for Borland C++ 3.1 Windows version
X# The compile and link includes debug flags.  Take them out if you
X# do not want them included  (-y -v -M, /m /s /v /l)
X
X# where to place wgnuplot.hlp helpfile
XHELPFILE = wgnuplot.hlp
X# location of Borland C compiler
XTC = c:\borlandc
X# name of C compiler
XCC = bcc
X# location of TLINK.EXE and BCC.EXE
XBIN = $(TC)\bin\\
X
X# -c means don't link
X# -ml means use large model (large code, large data)
X# -M means produce link map
X# -y means include line numbers for debugger
X# -v means include debug info
X# -w- means ignore warnings and do not report them
X# -w-rvl ignore function must return a value error
X# -Ff=128 means make data object > 128 FAR
X# -W means window application
X# -DREADLINE to use the history/line editing capability. If you want this 
X#    capability add -DREADLINE to CFLAGS then add 'readline' to the /o
X#    section of the linker call.
XCFLAGS = -c -W -ml -M -y -v -w-rvl -w-pro -Ff=128 -I$(TC)\include -Iwin -DREADLINE -zEGPFAR_DATA
XTERMFLAGS =
X
XOBJS = 	bitmap.obj command.obj contour.obj eval.obj graphics.obj graph3d.obj \
X	internal.obj misc.obj parse.obj plot.obj readline.obj scanner.obj \
X	setshow.obj specfun.obj standard.obj term.obj util.obj version.obj \
X	gnubin.obj binary.obj winmain.obj
X
XCSOURCE5 = term\aed.trm term\cgi.trm term\dumb.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm 
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term/pbm.trm term\win.trm
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm
XCSOURCE8 = contour.c specfun.c gnubin.c binary.c
XWINDOWS = makefile.win makefile.msw README.win win\wcommon.h \
X	win\wgnuplib.c win\wgnuplib.def win\wgnuplib.h win\wgnuplib.rc\
X	win\wgnuplot.def win\wgnuplot.hpj win\wgnuplot.mnu win\wgnuplot.rc \
X	win\wgraph.c win\winmain.c win\wmenu.c win\wpause.c \
X	win\wprinter.c win\wresourc.h win\wtext.c win\wtext.h \
X	win\geticon.c docs\doc2rtf.c term\win.trm
X
Xall: wgnuplot.exe wgnuplot.dll $(HELPFILE) wgnuplot.mnu demo\bf_test.exe
X
Xwgnuplot.exe: $(OBJS) win\wgnuplot.def win\wgnuplot.rc winmain.obj wgnuplot.lib
X#	$(BIN)tlink /Twe /c @&&!
X	$(BIN)tlink /Twe /c /m /s /v /l @&&!
X$(TC)\lib\C0Wl +
Xbitmap command eval graphics graph3d internal misc parse +
Xplot scanner setshow specfun standard term util version contour +
Xgnubin binary +
Xwinmain +
Xreadline +
X,wgnuplot,wgnuplot, +
Xwgnuplot.lib +
X$(TC)\lib\import +
X$(TC)\lib\mathwl +
X$(TC)\lib\cwl, +
Xwin\wgnuplot.def
X!
X	$(BIN)brc -30 -k -i$(TC)\include win\wgnuplot.rc wgnuplot.exe
X
X# default rules
X
X.c.obj:
X	$(BIN)$(CC) @&&!
X$(CFLAGS)
X! $<
X
X# rules
X
Xbitmap.obj: bitmap.c bitmap.h plot.h
X
Xcommand.obj: command.c plot.h setshow.h 
X	$(BIN)$(CC) @&&!
X$(CFLAGS) -DHELPFILE="$(HELPFILE)"
X! command.c
X
Xcontour.obj: contour.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgraphics.obj: graphics.c plot.h setshow.h
X
Xgraph3d.obj: graphics.c plot.h setshow.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h setshow.h 
X
Xparse.obj: parse.c plot.h
X	$(BIN)$(CC) @&&!
X$(CFLAGS)
X! parse.c
X
Xplot.obj: plot.c plot.h setshow.h
X	$(BIN)$(CC) @&&!
X$(CFLAGS)
X! plot.c
X
Xreadline.obj: readline.c plot.h
X
Xscanner.obj: scanner.c plot.h
X
Xsetshow.obj: setshow.c plot.h setshow.h
X
Xspecfun.obj: specfun.c
X
Xstandard.obj: standard.c plot.h
X
Xterm.obj: term.c term.h plot.h setshow.c bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7) win\wgnuplib.h
X	$(BIN)$(CC) @&&!
X$(CFLAGS)
X! $(TERMFLAGS) -Iterm term.c
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
Xwinmain.obj: win\winmain.c win\wgnuplib.h win\wtext.h plot.h
X	$(BIN)$(CC) @&&!
X$(CFLAGS) -DHELPFILE="$(HELPFILE)"
X! win\winmain.c
X
Xwgnuplot.mnu: win\wgnuplot.mnu
X	copy win\wgnuplot.mnu wgnuplot.mnu
X
X
X# different compiler options for DLL's */
XDLLCC = $(BIN)bcc -c -ms! -M -y -v -WD -I$(TC)\include -Iwin
XDLLOBJS = wgnuplib.obj wtext.obj wmenu.obj wpause.obj wgraph.obj wprinter.obj 
X
Xwgnuplot.lib: wgnuplot.dll
X	$(BIN)implib wgnuplot.lib wgnuplot.dll
X
Xwgnuplot.dll: $(DLLOBJS) win/wgnuplib.def win/wgnuplib.rc
X	$(BIN)tlink /c /n /Twd /L$(TC)\lib /m /s /v /l @&&!
Xc0ds +
Xwgnuplib wtext wmenu wpause wgraph wprinter, +
Xwgnuplot.dll, +
Xwgnuplib.map, +
Ximport mathws cws, +
Xwin\wgnuplib.def
X!
X	$(BIN)brc -30 -i$(TC)\include -t win\wgnuplib.rc wgnuplot.dll
X
Xwgnuplib.obj: win/wgnuplib.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wgnuplib.c
X	
Xwmenu.obj: win/wmenu.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wmenu.c
X
Xwtext.obj: win/wtext.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wtext.c
X	
Xwpause.obj: win/wpause.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wpause.c
X	
Xwprinter.obj: win/wprinter.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wprinter.c
X	
Xwgraph.obj: win/wgraph.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wgraph.c
X	
X# convert gnuplot.doc to gnuplot.gih
X$(HELPFILE): doc2rtf.exe docs\gnuplot.doc win\wgnuplot.hpj
X	doc2rtf docs\gnuplot.doc win\gnuplot.rtf
X	$(BIN)hc win\wgnuplot.hpj 
X
Xdoc2rtf.exe: docs\doc2rtf.c
X	$(BIN)$(CC) -ml -w-pro -I$(TC)\include -L$(TC)\lib docs\doc2rtf.c
X
X# make binary demo files
Xdemo\bf_test.exe: bf_test.c dbinary.obj
X	$(BIN)$(CC) -edemo\bf_test.exe -w-pro -ml -I$(TC)\include -L$(TC)\lib bf_test.c dbinary.obj
X	cd demo
X	bf_test
X	cd ..
X
Xdbinary.obj: binary.c
X	$(BIN)$(CC) -c -w-pro -ml -I$(TC)\include -odbinary.obj binary.c
X
X# clean up temporary files
Xclean:
X	del *.obj
X	del wgnuplot.map
X	del win\wgnuplot.res
X	del win\gnuplot.rtf
X	del doc2rtf.exe
X	del win\wgnuplib.res
X	del wgnuplib.map
X	del wgnuplot.lib
X	del demo\bf_test.exe
X	
Xveryclean: clean
X	del wgnuplot.exe
X	del wgnuplot.hlp
X	del wgnuplot.mnu
X	del wgnuplot.dll
X	del demo\binary1
X	del demo\binary2
X	del demo\binary3
END_OF_FILE
  if test 5839 -ne `wc -c <'gnuplot/makefile.win'`; then
    echo shar: \"'gnuplot/makefile.win'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.win'
fi
if test -f 'gnuplot/setshow.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/setshow.h'\"
else
  echo shar: Extracting \"'gnuplot/setshow.h'\" \(5236 characters\)
  sed "s/^X//" >'gnuplot/setshow.h' <<'END_OF_FILE'
X/*
X * $Id: setshow.h%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - setshow.h */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X *
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X/*
X * global variables to hold status of 'set' options
X *
X */
Xextern TBOOLEAN			autoscale_r;
Xextern TBOOLEAN			autoscale_t;
Xextern TBOOLEAN			autoscale_u;
Xextern TBOOLEAN			autoscale_v;
Xextern TBOOLEAN			autoscale_x;
Xextern TBOOLEAN			autoscale_y;
Xextern TBOOLEAN			autoscale_z;
Xextern TBOOLEAN			autoscale_lt;
Xextern TBOOLEAN			autoscale_lu;
Xextern TBOOLEAN			autoscale_lv;
Xextern TBOOLEAN			autoscale_lx;
Xextern TBOOLEAN			autoscale_ly;
Xextern TBOOLEAN			autoscale_lz;
Xextern double			boxwidth;
Xextern TBOOLEAN			clip_points;
Xextern TBOOLEAN			clip_lines1;
Xextern TBOOLEAN			clip_lines2;
Xextern TBOOLEAN			draw_border;
Xextern TBOOLEAN			draw_surface;
Xextern TBOOLEAN			timedate;
Xextern char			dummy_var[MAX_NUM_VAR][MAX_ID_LEN+1];
Xextern char			xformat[];
Xextern char			yformat[];
Xextern char			zformat[];
Xextern enum PLOT_STYLE data_style, func_style;
Xextern TBOOLEAN			grid;
Xextern int			key;
Xextern double			key_x, key_y, key_z; /* user specified position for key */
Xextern TBOOLEAN			is_log_x, is_log_y, is_log_z;
Xextern double			base_log_x, base_log_y, base_log_z;
X				/* base, for computing pow(base,x) */
Xextern double			log_base_log_x, log_base_log_y, log_base_log_z;
X				/* log of base, for computing logbase(base,x) */
Xextern FILE*			outfile;
Xextern char			outstr[];
Xextern TBOOLEAN			parametric;
Xextern TBOOLEAN			polar;
Xextern TBOOLEAN			hidden3d;
Xextern int			angles_format;
Xextern int			mapping3d;
Xextern int			samples;
Xextern int			samples_1;
Xextern int			samples_2;
Xextern int			iso_samples_1;
Xextern int			iso_samples_2;
Xextern float			xsize; /* scale factor for size */
Xextern float			ysize; /* scale factor for size */
Xextern float			zsize; /* scale factor for size */
Xextern float			surface_rot_z;
Xextern float			surface_rot_x;
Xextern float			surface_scale;
Xextern float			surface_zscale;
Xextern int			term; /* unknown term is 0 */
Xextern char			term_options[];
Xextern char			title[];
Xextern char			xlabel[];
Xextern char			ylabel[];
Xextern char			zlabel[];
Xextern int			time_xoffset;
Xextern int			time_yoffset;
Xextern int			title_xoffset;
Xextern int			title_yoffset;
Xextern int			xlabel_xoffset;
Xextern int			xlabel_yoffset;
Xextern int			ylabel_xoffset;
Xextern int			ylabel_yoffset;
Xextern int			zlabel_xoffset;
Xextern int			zlabel_yoffset;
Xextern double			rmin, rmax;
Xextern double			tmin, tmax, umin, umax, vmin, vmax;
Xextern double			xmin, xmax, ymin, ymax, zmin, zmax;
Xextern double			loff, roff, toff, boff;
Xextern int			draw_contour;
Xextern TBOOLEAN      label_contours;
Xextern int			contour_pts;
Xextern int			contour_kind;
Xextern int			contour_order;
Xextern int			contour_levels;
Xextern double			zero; /* zero threshold, not 0! */
Xextern int			levels_kind;
Xextern double		levels_list[MAX_DISCRETE_LEVELS];
X
Xextern int			dgrid3d_row_fineness;
Xextern int			dgrid3d_col_fineness;
Xextern int			dgrid3d_norm_value;
Xextern TBOOLEAN			dgrid3d;
X
Xextern TBOOLEAN xzeroaxis;
Xextern TBOOLEAN yzeroaxis;
X
Xextern TBOOLEAN xtics;
Xextern TBOOLEAN ytics;
Xextern TBOOLEAN ztics;
X
Xextern float ticslevel;
X
Xextern struct ticdef xticdef;
Xextern struct ticdef yticdef;
Xextern struct ticdef zticdef;
X
Xextern TBOOLEAN			tic_in;
X
Xextern struct text_label *first_label;
Xextern struct arrow_def *first_arrow;
X
X/* The set and show commands, in setshow.c */
Xextern void set_command();
Xextern void show_command();
X/* and some accessible support functions */
Xextern enum PLOT_STYLE get_style();
Xextern TBOOLEAN load_range();
Xextern void show_version();
END_OF_FILE
  if test 5236 -ne `wc -c <'gnuplot/setshow.h'`; then
    echo shar: \"'gnuplot/setshow.h'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/setshow.h'
fi
if test -f 'gnuplot/term/iris4d.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/iris4d.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/iris4d.trm'\" \(5410 characters\)
  sed "s/^X//" >'gnuplot/term/iris4d.trm' <<'END_OF_FILE'
X/*
X * $Id: iris4d.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - iris4d.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   IRIS terminals
X *
X * AUTHORS
X *   John H. Merritt 
X *           (Applied Research Corporation) 7/1/89
X *           INTERNET: merritt@iris613.gsfc.nasa.gov
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X#include <gl.h>
X
X#define IRIS4DRC    ".gnuplot_iris4d"
X
X#define IRIS4D_XMAX 1024
X#define IRIS4D_YMAX 1024
X
X#define IRIS4D_XLAST (IRIS4D_XMAX - 1)
X#define IRIS4D_YLAST (IRIS4D_YMAX - 1)
X
X#define IRIS4D_VCHAR (IRIS4D_YMAX/30)
X#define IRIS4D_HCHAR (IRIS4D_XMAX/72)
X#define IRIS4D_VTIC (IRIS4D_YMAX/80)
X#define IRIS4D_HTIC (IRIS4D_XMAX/80)
X
Xstatic short colors24bits[][3] =
X{
X    { 85,  85,  85  },  /* 0. BACK GROUND ( DARKGRAY ) */
X    { 0,   0,   0   },  /* 1. BLACK */
X    { 170, 0,   170 },  /* 2. MAGENTA */
X    { 85,  255, 255 },  /* 3. LIGHTCYAN */
X    { 170, 0,   0   },  /* 4. RED */
X    { 0,   170, 0   },  /* 5. GREEN */
X    { 255, 85,  255 },  /* 6. LIGHTMAGENTA */
X    { 255, 255, 85  },  /* 7. YELLOW */
X    { 255, 85,  85  },  /* 8. LIGHTRED */
X    { 85,  255, 85  },  /* 9. LIGHTGREEN */
X    { 0,   170, 170 },  /* 10. CYAN */
X    { 170, 170, 0   },  /* 11. BROWN */
X};
X#define COLOR24_SIZE (sizeof(colors24bits) / (sizeof(short) * 3))
X
Xstatic iris24bits = FALSE;
X
X#define IRIS4D_BACKGROUND	0
X#define IRIS4D_BLACK		1
X#define IRIS4D_MAGENTA		2
X#define IRIS4D_LIGHTCYAN	3
X#define IRIS4D_RED		4
X#define IRIS4D_GREEN		5
X#define IRIS4D_LIGHTMAGENTA	6
X#define IRIS4D_YELLOW		7
X#define IRIS4D_LIGHTRED		8
X#define IRIS4D_LIGHTGREEN	9
X#define IRIS4D_CYAN		10
X#define IRIS4D_BROWN		11
X
XIRIS4D_options()
X{
X  int i = 0;
X  struct value a;
X  extern struct value *const_express();
X  extern double real();
X
X  if (!END_OF_COMMAND) {
X    i = (int) real(const_express(&a));
X  }
X
X  iris24bits = (i == 24);
X
X  sprintf(term_options, "%s",iris24bits ? "24" : "8");
X}
X
XIRIS4D_init()
X{
X  int i;
X  char homedirfile[80], line[80];
X  FILE *f;
X
X  foreground();
X  winopen("Gnuplot");
X  if (iris24bits)
X  {
X    RGBmode();
X    gconfig();
X  }
X
X  strcat(strcat(strcpy(homedirfile,getenv("HOME")),"/"),IRIS4DRC);
X  if ((f = fopen(IRIS4DRC, "r")) != NULL ||
X      (f = fopen(homedirfile, "r")) != NULL) {
X    int c1, c2, c3;
X    for (i = 0; i < COLOR24_SIZE; i++) {
X      if (fgets(line, 79, f) == NULL ||
X	  sscanf(line, "%d %d %d", &c1, &c2, &c3) != 3)
X	int_error("Iris4d color file terminated prematurely or wrong format.\n", NO_CARET);
X      colors24bits[i][0] = c1;
X      colors24bits[i][1] = c2;
X      colors24bits[i][2] = c3;
X    }
X      
X    fclose(f);
X  }
X  deflinestyle(1, 0x3FFF); /* long dash */
X  deflinestyle(2, 0x5555); /* dotted */
X  deflinestyle(3, 0x3333); /* short dash */
X  deflinestyle(4, 0xB5AD); /* dotdashed */
X  deflinestyle(5, 0x0F0F); /* dashed */
X  deflinestyle(6, 0xBBBB); /* dotdashed */
X  deflinestyle(7, 0x3F3F); /* mid-long dash */
X  deflinestyle(8, 0x7777); /* mid-long dash */
X
X  return;
X}
X
XIRIS4D_graphics()
X{
X  reshapeviewport();
X  ortho2((Coord)0, (Coord)IRIS4D_XMAX, (Coord)0, (Coord)IRIS4D_YMAX);
X  if (iris24bits)
X    RGBcolor(colors24bits[IRIS4D_BACKGROUND][0],
X	     colors24bits[IRIS4D_BACKGROUND][1],
X	     colors24bits[IRIS4D_BACKGROUND][2]);
X  else
X    color(WHITE);
X
X  clear();
X  
X  return;
X}
X
XIRIS4D_text()
X{
X  gflush(); /* flush buffer */
X  return; /* enter text from another window!!! */
X}
X
XIRIS4D_linetype(linetype)
Xint linetype;
X{
X  static int pen_color_24[11] =
X    {
X      IRIS4D_BLACK,		/* reserved for border and numbers */
X      IRIS4D_MAGENTA,		/* reserved for axis traces */
X      IRIS4D_LIGHTCYAN,
X      IRIS4D_RED,
X      IRIS4D_GREEN,
X      IRIS4D_LIGHTMAGENTA,
X      IRIS4D_YELLOW,
X      IRIS4D_LIGHTRED,
X      IRIS4D_LIGHTGREEN,
X      IRIS4D_CYAN,
X      IRIS4D_BROWN,
X    };
X  static int pen_color[8] = {0 ,1, 4, 5, 6, 1, 2, 4};
X
X  if (iris24bits)
X  {
X    int pencolor = pen_color_24[linetype < 0 ? linetype + 2 : linetype % 9 + 2];
X
X    RGBcolor(colors24bits[pencolor][0],
X	     colors24bits[pencolor][1],
X	     colors24bits[pencolor][2]);
X    /* Make all lines solid (linestyle 0) upto to the ninth. If more than
X     * 9 colors are needed, start to use the different line styles (1 to 8).
X     */
X    setlinestyle(linetype < 9 ? 0 : (linetype + 2) % 8 + 1);
X  }
X  else
X  {
X    linetype = linetype % 8;
X    color((Colorindex) pen_color[linetype]);
X    setlinestyle(linetype);
X  }
X  return;
X}
X
XIRIS4D_move(x, y)
Xunsigned int x, y;
X{
X  move2i(x, y);
X  return;
X}
X
XIRIS4D_cmove(x, y)
Xunsigned int x, y;
X{
X  cmov2i(x, y);
X  return;
X}
X
XIRIS4D_vector(x, y)
Xunsigned x, y;
X{
X  draw2i(x, y);
X  return;
X}
X
X
XIRIS4D_put_text(x,y,str)
Xint x, y;
Xchar *str;
X{
X  IRIS4D_cmove(x,y - IRIS4D_VCHAR/2);
X  charstr(str);
X  return;
X}
X
X
XIRIS4D_reset()
X{
X  return;
X}
X
END_OF_FILE
  if test 5410 -ne `wc -c <'gnuplot/term/iris4d.trm'`; then
    echo shar: \"'gnuplot/term/iris4d.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/iris4d.trm'
fi
if test -f 'gnuplot/term/pslatex.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/pslatex.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/pslatex.trm'\" \(5487 characters\)
  sed "s/^X//" >'gnuplot/term/pslatex.trm' <<'END_OF_FILE'
X/*
X * $Id: pslatex.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - pslatex.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *     latex with embedded postscript
X *
X * AUTHORS
X *  George Phillips
X *  Russell Lang
X *  David Kotz
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X */
X
X/* Driver by George Phillips */
X
X#define PSLATEX_XMAX (5*720)
X#define PSLATEX_YMAX (3*720)
X
X/* 10 pt char is about 10 pts high (say) */
X#define PSLATEX_VCHAR (100)
X/* 10 pt char is about 6 pts wide (say) */
X#define PSLATEX_HCHAR (60)
X
Xstatic int PSLATEX_angle;
Xstatic int PSLATEX_justify;
Xstatic int PSLATEX_rotate = TRUE;
X
Xstruct text_command {
X    int x, y, angle, justify;
X    char* label;
X    struct text_command* next;
X};
X
Xstatic struct text_command* PSLATEX_labels;
X
XPSLATEX_options()
X{
X    if (!END_OF_COMMAND) {
X	if (almost_equals(c_token, "d$efault")) {
X	    ps_color = FALSE;
X	    PSLATEX_rotate = TRUE;
X	    c_token++;
X	}
X    }
X
X    if (!END_OF_COMMAND) {
X	if (almost_equals(c_token, "c$olor")) {
X	    ps_color = TRUE;
X	    c_token++;
X	}
X    }
X
X    if (!END_OF_COMMAND) {
X	if (almost_equals(c_token, "m$onochrome")) {
X	    ps_color = FALSE;
X	    c_token++;
X	}
X    }
X
X    if (!END_OF_COMMAND) {
X	if (almost_equals(c_token, "r$otate")) {
X	    PSLATEX_rotate = TRUE;
X	    c_token++;
X	}
X    }
X
X    if (!END_OF_COMMAND) {
X	if (almost_equals(c_token, "n$orotate")) {
X	    PSLATEX_rotate = FALSE;
X	    c_token++;
X	}
X    }
X
X    sprintf(term_options, "%s %s", ps_color ? "color" : "monochrome",
X	PSLATEX_rotate ? "rotate" : "norotate");
X}
X
XPSLATEX_init()
X{
X    /* reset PostScript driver variables */
X    ps_portrait = TRUE;
X    ps_eps = FALSE;
X    ps_color = FALSE;
X
X    fprintf(outfile, "%% GNUPLOT: LaTeX picture with Postscript\n");
X    fprintf(outfile, "\\setlength{\\unitlength}{0.1bp}\n");
X    fprintf(outfile, "\\special{!\n");
X    PS_init();
X    fprintf(outfile, "}\n");
X
X    PSLATEX_angle = 0;
X    PSLATEX_justify = 0;
X    PSLATEX_labels = 0;
X}
X
XPSLATEX_scale(xs, ys)
Xdouble xs, ys;
X{
X    register struct termentry *t = &term_tbl[term];
X
X    t->xmax = (unsigned int)(PSLATEX_XMAX * xs);
X    t->ymax = (unsigned int)(PSLATEX_YMAX * ys);
X
X    return TRUE;
X}
X
XPSLATEX_graphics()
X{
X    struct termentry *t = &term_tbl[term];
X
X    fprintf(outfile, "\\begin{picture}(%d,%d)(0,0)\n", t->xmax, t->ymax);
X
X    fprintf(outfile, "\\special{\"\n");
X    PS_graphics();
X    /* thwart the translation done by PS_graphics() */
X	fprintf(outfile, "%f %f translate\n",
X		-PS_XOFF * (float)PS_SC, -PS_YOFF * (float)PS_SC);
X    PSLATEX_labels = (struct text_command *)NULL;
X}
X
XPSLATEX_put_text(x, y, str)
Xint x, y;
Xchar str[];
X{
X    struct text_command* tc;
X
X    /* ignore empty strings */
X    if (str[0] == '\0')
X	return(0);
X	
X    tc = (struct text_command*)alloc(sizeof(struct text_command),"pslatex");
X    tc->x = x;
X    tc->y = y;
X    tc->label = (char *)alloc(strlen(str) + 1,"pslatex");
X    strcpy(tc->label, str);
X    tc->justify = PSLATEX_justify;
X    tc->angle = PSLATEX_angle;
X
X    tc->next = PSLATEX_labels;
X    PSLATEX_labels = tc;
X}
X
XPSLATEX_justify_text(mode)
Xenum JUSTIFY mode;
X{
X    PSLATEX_justify = mode;
X    return TRUE;
X}
X
Xint PSLATEX_text_angle(angle)
Xint angle;
X{
X    /* rotated text is put in a short stack, and optionally uses 
X     * postscript specials depending on PSLATEX_rotate */
X    PSLATEX_angle = angle;
X    return TRUE;
X}
X
X
XPSLATEX_reset()
X{
X}
X
XPSLATEX_text()
X{
X    struct text_command* tc;
X
X    PS_text();
X    fprintf(outfile, "}\n");
X
X    for (tc = PSLATEX_labels; tc != (struct text_command*)NULL; tc = tc->next) {
X	fprintf(outfile, "\\put(%d,%d){", tc->x, tc->y);
X	switch (tc->angle) {
X	case 0:
X	    switch (tc->justify) {
X	    case LEFT:
X		fprintf(outfile, "\\makebox(0,0)[l]{%s}", tc->label);
X		break;
X	    case CENTRE:
X		fprintf(outfile, "\\makebox(0,0){%s}", tc->label);
X		break;
X	    case RIGHT:
X		fprintf(outfile, "\\makebox(0,0)[r]{%s}", tc->label);
X		break;
X	    }
X	    break;
X	case 1: /* put text in a short stack */
X	    if (PSLATEX_rotate) {
X	        fprintf(outfile, "%%\n\\special{ps: gsave currentpoint currentpoint translate\n");
X	        fprintf(outfile, "270 rotate neg exch neg exch translate}%%\n");
X	    }
X	    switch (tc->justify) {
X	    case LEFT:
X		fprintf(outfile, "\\makebox(0,0)[lb]{\\shortstack{%s}}",
X			tc->label);
X		break;
X	    case CENTRE:
X		fprintf(outfile, "\\makebox(0,0)[b]{\\shortstack{%s}}",
X			tc->label);
X		break;
X	    case RIGHT:
X		fprintf(outfile, "\\makebox(0,0)[lt]{\\shortstack{%s}}",
X			tc->label);
X		break;
X	    }
X	    if (PSLATEX_rotate) {
X	        fprintf(outfile, "%%\n\\special{ps: currentpoint grestore moveto}%%\n");
X	    }
X	}
X	fprintf(outfile, "}\n");
X    }
X
X    while (PSLATEX_labels) {
X	tc = PSLATEX_labels->next;
X	free(PSLATEX_labels->label);
X	free(PSLATEX_labels);
X	PSLATEX_labels = tc;
X    }
X
X    fprintf(outfile, "\\end{picture}\n");
X}
END_OF_FILE
  if test 5487 -ne `wc -c <'gnuplot/term/pslatex.trm'`; then
    echo shar: \"'gnuplot/term/pslatex.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/pslatex.trm'
fi
if test -f 'gnuplot/term/tgif.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/tgif.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/tgif.trm'\" \(5401 characters\)
  sed "s/^X//" >'gnuplot/term/tgif.trm' <<'END_OF_FILE'
X/*
X * $Id: tgif.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* N O T   F I N I S H E D ! ! ! ! ! ! ! */
X
X/* GNUPLOT - tgif.trm */
X/*
X * Copyright (C) 1990   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *     tgif
X *
X * AUTHORS
X *  Neal Holtz
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X
X/* tgif driver by Neal Holtz, holtz@civeng.carleton.ca */
X
X#include "tgif.h"
X
X#define TGIF_XMAX 750
X#define TGIF_YMAX 750
X
X#define TGIF_XLAST (TGIF_XMAX - 1)
X#define TGIF_YLAST (TGIF_YMAX - 1)
X
X#define TGIF_VTIC (TGIF_YMAX/80)
X#define TGIF_HTIC (TGIF_YMAX/80)
X
X/* TGIF Courier size 5 = 15x24, size 4 = 11x19, size 3 = 9x16
X    ascender+descender = 19+5,           15+4,           13+3 */
X
X#define TGIF_VCHAR1	19
X#define TGIF_HCHAR1	11
X#define TGIF_CHAR_ASC	15
X#define TGIF_CHAR_DESC 	(TGIF_VCHAR1-TGIF_CHAR_ASC)
X
X#define YTRANS(y) (TGIF_YMAX-(y))
X                         
Xtypedef struct {
X	int	x, y;
X} Tgif_point;
X
Xint	tgif_fileVersion = 10;
Xint	tgif_just = JUST_L;
Xint	tgif_ang = ROTATE0;
Xint	tgif_font = FONT_HEL;
Xint	tgif_style = STYLE_NR;	/* text style */
Xint	tgif_size = 4;		/* text size */
Xint	tgif_asc = TGIF_CHAR_ASC;		/* text ascender, descender */
Xint	tgif_des = TGIF_CHAR_DESC;
X
Xint	tgif_linewidth = LINE_MEDIUM;
Xint	tgif_dash = 0;
X
Xchar	*tgif_colour = "yellow";
Xint	tgif_objId = 100;
X
X#define TGIF_VSINIT	100
X#define TGIF_VSINCR	100
Xint	tgif_vsmax = 0;			/* max possible number of vertices */
Xint	tgif_nv = 0;			/* current number of vertices */
XTgif_point	*tgif_v = NULL;		/* coordinates of vertices of polyline */
X
X
X
XTGIF_AddVertex( x, y )
Xint	x, y;
X{
X	Tgif_point	*p;
X
X	if( tgif_v == NULL ) {
X		tgif_v = (Tgif_point *)malloc( TGIF_VSINIT*sizeof(Tgif_point) );
X		tgif_nv = 0;
X		if( tgif_v == NULL ) {
X			fprintf( stderr, "Unable to malloc() space for vertices.\n" );
X			exit( 1 );
X		}
X		tgif_vsmax = TGIF_VSINIT;
X	}
X	if( tgif_nv >= tgif_vsmax ) {
X		tgif_v = (Tgif_point *)realloc( tgif_v, (tgif_vsmax+TGIF_VSINCR)*sizeof(Tgif_point) ); 
X		if( tgif_v == NULL ) {
X			fprintf( stderr, "Unable to realloc() space for vertices.\n" );
X			exit( 1 );
X		}
X		tgif_vsmax += TGIF_VSINCR;
X	}
X	p = tgif_v + tgif_nv++;
X	p->x = x;
X	p->y = YTRANS(y);
X	if( tgif_nv > 1 && p[-1].x == p[0].x && p[-1].y == p[0].y )
X		tgif_nv--;
X}
X
X
XTGIF_Flush( lstyle )
Xint	lstyle;		/* line style */
X{
X	int	i;
X
X	if( tgif_nv >= 2 ) {
X		fprintf( outfile, "poly('%s',%d,[%d,%d",
X			tgif_colour, tgif_nv, tgif_v[0].x, tgif_v[0].y );
X		for( i = 1; i < tgif_nv; i++ )
X			fprintf( outfile, ",%d,%d", tgif_v[i].x, tgif_v[i].y );
X		fprintf( outfile, "],%d,%d,%d,%d,%d,%d,%d,[\n]).\n",
X			lstyle, tgif_linewidth, 1,	/* style, width, pen */
X			tgif_objId++,
X			0, 0,		/* curved, fill */
X			tgif_dash );
X	}
X	tgif_nv = 0;
X}
X	
X	
X
X
XTGIF_init()
X{
X	tgif_just = JUST_L;
X	tgif_ang = ROTATE0;
X	tgif_font = FONT_HEL;
X	tgif_style = STYLE_NR;
X	tgif_linewidth = LINE_MEDIUM;
X	tgif_dash = 0;
X	tgif_nv = 0; 
X}
X
X
XTGIF_graphics()
X{
X	fprintf(outfile,"state(0,%d,0,0,0,16,1,0,2,1,0,0,1,0,1,0,1,0,3,0,0).\n", tgif_fileVersion);
X	fprintf(outfile,"%%\n");
X	fprintf(outfile,"%% @(#)$Header: /a/woo/src/gwork/term/RCS/tgif.trm%v 3.50 1993/07/09 05:35:24 woo Exp $\n");
X	fprintf(outfile,"%%\n");
X	tgif_nv = 0;
X}
X
X
XTGIF_text()
X{
X	TGIF_Flush(LS_PLAIN);
X}
X
X
XTGIF_reset()
X{
X	TGIF_Flush(LS_PLAIN);
X}
X
X
XTGIF_linetype(linetype)
Xint linetype;
X{
X	TGIF_Flush(LS_PLAIN);
X	if( linetype == -2 )		/* use thinner lines for border and axis */
X		tgif_dash = 0, tgif_linewidth = LINE_THIN;
X	else if( linetype == -1 )
X		tgif_dash = 1, tgif_linewidth = LINE_THIN;
X	else
X		tgif_dash = linetype % MAXDASHES, tgif_linewidth = LINE_MEDIUM;
X}
X
X
XTGIF_move(x,y)
Xunsigned int x,y;
X{
X	TGIF_Flush(LS_PLAIN);
X	TGIF_AddVertex( x, y );
X}
X
X
XTGIF_vector(x,y)
Xunsigned int x,y;
X{
X	TGIF_AddVertex( x, y );
X}
X
X
XTGIF_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	TGIF_Flush(LS_PLAIN);
X	fprintf( outfile, "text('%s',%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,[\n\t\"%s\"]).\n",
X		tgif_colour, 
X		x, YTRANS(y)-(TGIF_CHAR_DESC+(TGIF_CHAR_ASC/2)),
X		tgif_font, tgif_style, tgif_size,
X		1,	/* number of lines */
X		tgif_just, tgif_ang,
X		1,    	/* pen */
X		TGIF_HCHAR1*strlen(str), TGIF_VCHAR1,
X		tgif_objId++,
X                0, 	/* dpi */
X		tgif_asc, tgif_des,
X		str );
X}
X
Xint TGIF_text_angle(ang)
Xint ang;
X{
X	TGIF_Flush(LS_PLAIN);
X	if( ang == 1 )
X		tgif_ang = ROTATE270;
X	else
X		tgif_ang = ROTATE0;
X	return TRUE;
X}
X
Xint TGIF_justify_text(mode)
Xenum JUSTIFY mode;
X{
X	TGIF_Flush(LS_PLAIN);
X	switch(mode) {
X	case LEFT:	
X		tgif_just = JUST_L; 	
X		break;
X	case CENTRE:	
X		tgif_just = JUST_C;	
X		break;
X	case RIGHT:	
X		tgif_just = JUST_R;	
X		break;
X	default:	
X		tgif_just = JUST_L;	
X		break;
X	}
X	return TRUE;
X}
X
XTGIF_arrow( sx, sy, ex, ey )
Xint	sx, sy, ex, ey;
X{
X	TGIF_Flush(LS_PLAIN);
X	TGIF_AddVertex( sx, sy );
X	TGIF_AddVertex( ex, ey );
X	TGIF_Flush(LS_RIGHT);
X}
END_OF_FILE
  if test 5401 -ne `wc -c <'gnuplot/term/tgif.trm'`; then
    echo shar: \"'gnuplot/term/tgif.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/tgif.trm'
fi
if test -f 'gnuplot/win/wgnuplib.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wgnuplib.rc'\"
else
  echo shar: Extracting \"'gnuplot/win/wgnuplib.rc'\" \(5471 characters\)
  sed "s/^X//" >'gnuplot/win/wgnuplib.rc' <<'END_OF_FILE'
X#ifndef WIN32
X#include <windows.h>
X#endif
X#include "wresourc.h"
X
XInputDlgBox DIALOG 64, 32, 150, 57
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
XCAPTION "Input"
XBEGIN
X    CONTROL "",        ID_PROMPT, "static", SS_LEFT | WS_GROUP | WS_CHILD,                   6,  5, 138, 10
X    CONTROL "",        ID_ANSWER, "edit",   ES_LEFT | ES_AUTOHSCROLL | WS_BORDER | WS_TABSTOP | WS_CHILD,    6, 17, 138, 12
X    CONTROL "&Ok",     IDOK,      "button", BS_DEFPUSHBUTTON | WS_GROUP | WS_TABSTOP | WS_CHILD,        30, 36,  30, 15
X    CONTROL "&Cancel", IDCANCEL,  "button", BS_PUSHBUTTON | WS_GROUP | WS_TABSTOP | WS_CHILD,           90, 36,  30, 15
XEND
X
XPrintDlgBox DIALOG 40, 40, 120, 40
XSTYLE WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE
XBEGIN
X	CTEXT			"Cancel Printing", -1, 4, 6, 120, 12
X	DEFPUSHBUTTON	"Cancel", IDCANCEL, 44, 22, 32, 14, WS_GROUP
XEND
X
XPrintSizeDlgBox DIALOG 16, 32, 210, 96
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE
XCAPTION "Print Size"
XBEGIN
X	DEFPUSHBUTTON "OK", IDOK, 168, 16, 33, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP
X	PUSHBUTTON "Cancel", IDCANCEL, 168, 40, 34, 14
X	CONTROL "Size", PSIZE_SBOX, "BUTTON", BS_GROUPBOX | WS_CHILD | WS_VISIBLE | WS_GROUP, 6, 2, 153, 58
X	CONTROL "&Default Size", PSIZE_DEF, "BUTTON", BS_AUTORADIOBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 12, 11, 52, 10
X	CONTROL "&Other Size", PSIZE_OTHER, "BUTTON", BS_AUTORADIOBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 12, 34, 52, 10
X	RTEXT "Width", -1, 30, 23, 24, 8, SS_RIGHT | WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "", PSIZE_DEFX, "STATIC", SS_LEFT | WS_CHILD | WS_VISIBLE, 57, 23, 16, 8
X	LTEXT "mm", -1, 74, 23, 12, 8
X	RTEXT "Height", -1, 97, 23, 24, 8, SS_RIGHT | WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "", PSIZE_DEFY, "STATIC", SS_LEFT | WS_CHILD | WS_VISIBLE, 125, 23, 16, 8
X	LTEXT "mm", -1, 142, 23, 12, 8
X	RTEXT "Width", -1, 30, 46, 24, 8, SS_RIGHT | WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "120", PSIZE_X, "EDIT", ES_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 56, 44, 16, 12
X	LTEXT "mm", -1, 74, 46, 12, 8
X	LTEXT "Height", -1, 100, 46, 24, 8
X	CONTROL "90", PSIZE_Y, "EDIT", ES_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 124, 44, 16, 12
X	LTEXT "mm", -1, 142, 46, 12, 8
X	CONTROL "Page Offset", PSIZE_OFFBOX, "BUTTON", BS_GROUPBOX | WS_CHILD | WS_VISIBLE | WS_GROUP, 6, 64, 153, 27
X	RTEXT "Left", -1, 29, 76, 24, 8, SS_RIGHT | WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "0", PSIZE_OFFX, "EDIT", ES_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 56, 74, 16, 12
X	LTEXT "mm", -1, 74, 76, 12, 8
X	RTEXT "Top", -1, 100, 76, 21, 8, SS_RIGHT | WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "0", PSIZE_OFFY, "EDIT", ES_LEFT | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP, 124, 74, 16, 12
X	LTEXT "mm", -1, 142, 76, 12, 8
XEND
X
XSpoolDlgBox DIALOG 32, 40, 110, 63
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
XCAPTION "Select Printer Port"
XBEGIN
X	CONTROL "&Ok", IDOK, "button", BS_DEFPUSHBUTTON | WS_GROUP | WS_TABSTOP | WS_CHILD, 72, 14, 32, 14
X	CONTROL "&Cancel", IDCANCEL, "button", BS_PUSHBUTTON | WS_GROUP | WS_TABSTOP | WS_CHILD, 72, 36, 32, 14
X	CONTROL "", SPOOL_PORT, "LISTBOX", LBS_NOTIFY | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 8, 8, 56, 50
XEND
X
XCancelDlgBox DIALOG 32, 40, 120, 48
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE
XBEGIN
X	CTEXT "Printing", -1, 8, 4, 104, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	CTEXT "", CANCEL_PCDONE, 8, 16, 104, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "&Cancel", IDCANCEL, "button", BS_PUSHBUTTON | WS_GROUP | WS_TABSTOP | WS_CHILD, 44, 30, 32, 14
XEND
X
XLineStyleDlgBox DIALOG 16, 32, 172, 137
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
XCAPTION "Line Styles"
XBEGIN
X	CONTROL "", LS_LINENUM, "LISTBOX", LBS_NOTIFY | WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 8, 8, 49, 47
X	CONTROL "Monochrome", LS_MONOBOX, "button", BS_GROUPBOX | WS_CHILD | WS_VISIBLE, 72, 4, 92, 52
X	CONTROL "Color", LS_COLORBOX, "button", BS_GROUPBOX | WS_CHILD | WS_VISIBLE, 8, 60, 156, 52
X	LTEXT "Style", -1, 80, 20, 22, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "", LS_MONOSTYLE, "COMBOBOX", CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP, 106, 18, 52, 52
X	LTEXT "Width", -1, 80, 40, 20, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	EDITTEXT LS_MONOWIDTH, 106, 38, 16, 12
X	PUSHBUTTON "&Choose Color", LS_CHOOSECOLOR, 16, 92, 52, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP
X	CONTROL "", LS_COLORSAMPLE, "BUTTON", BS_OWNERDRAW | WS_CHILD | WS_VISIBLE, 36, 75, 12, 8
X	LTEXT "Style", -1, 80, 76, 20, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	CONTROL "", LS_COLORSTYLE, "COMBOBOX", CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP, 106, 74, 52, 52
X	LTEXT "Width", -1, 80, 96, 19, 8, WS_CHILD | WS_VISIBLE | WS_GROUP
X	EDITTEXT LS_COLORWIDTH, 106, 94, 16, 12
X	PUSHBUTTON "OK", IDOK, 16, 118, 32, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP
X	PUSHBUTTON "Cancel", IDCANCEL, 70, 118, 32, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP
X	PUSHBUTTON "&Default", LS_DEFAULT, 124, 118, 32, 14, WS_CHILD | WS_VISIBLE | WS_TABSTOP
XEND
X
XAboutDlgBox DIALOG 32, 32, 180, 80
XSTYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
XCAPTION "About"
XBEGIN
X    CONTROL "", AB_ICON, "BUTTON", BS_OWNERDRAW | WS_CHILD | WS_VISIBLE, 4, 4, 16, 16
X    LTEXT   "", AB_TEXT1,  24,  8, 96, 10
X    PUSHBUTTON "OK", IDOK,  142, 6,  32, 12
X    LTEXT   "", AB_TEXT2,  4, 22, 172, 48
X    LTEXT   "", AB_TEXT3,  4, 70, 172, 48
XEND
X
END_OF_FILE
  if test 5471 -ne `wc -c <'gnuplot/win/wgnuplib.rc'`; then
    echo shar: \"'gnuplot/win/wgnuplib.rc'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wgnuplib.rc'
fi
if test -f 'gnuplot/win/wgnuplot.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wgnuplot.rc'\"
else
  echo shar: Extracting \"'gnuplot/win/wgnuplot.rc'\" \(5362 characters\)
  sed "s/^X//" >'gnuplot/win/wgnuplot.rc' <<'END_OF_FILE'
X#include <windows.h>
X#ifdef WIN32
X#include "wgnuplib.rc"
X#endif
X
X#ifdef MSRC
X/* using Microsoft RC.EXE */
X  /* texticon.ico and grpicon.ico are created from the */
X  /* Borland ascii format icons below using geticon.c */
X  /* cl win\geticon.c
X   * geticon win\wgnuplot.rc
X   * rc -30 -k -dMSRC win\wgnuplot.rc wgnuplot.exe
X   */
Xgrpicon ICON "grpicon.ico"
Xtexticon ICON  "texticon.ico"
X
X#else
X/* using Borland BRC.EXE */
Xgrpicon ICON 
XBEGIN
X	'00 00 01 00 01 00 20 20 10 00 00 00 00 00 E8 02'
X	'00 00 16 00 00 00 28 00 00 00 20 00 00 00 40 00'
X	'00 00 01 00 04 00 00 00 00 00 80 02 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 80 00 00 80 00 00 00 80 80 00 80 00'
X	'00 00 80 00 80 00 80 80 00 00 80 80 80 00 C0 C0'
X	'C0 00 00 00 FF 00 00 FF 00 00 00 FF FF 00 FF 00'
X	'00 00 FF 00 FF 00 FF FF 00 00 FF FF FF 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 0F FC'
X	'FF 0F FF FF F8 FF FF FF F8 FF FF FF F8 F0 0F FF'
X	'CF 0F FF FF F8 FF FF FF F8 FF FF FF F8 90 0F FF'
X	'FC 0F FF FF F8 FF FF FF F8 FF FF FF F9 F0 0F FF'
X	'FF 0C FF FF F8 FF 9F FF F8 FF FF FF 98 F0 0F FF'
X	'FF 0F CF FF F8 99 F9 FF F8 FF FF F9 F8 F0 0F FF'
X	'FF 0F CF FF F9 FF FF 9F F8 FF FF 9F F8 F0 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 0F FF'
X	'FF 0F FC FF 98 FF FF F9 F8 FF F9 FF F8 F0 0F FF'
X	'FF 0F FF C9 F8 FF FF FF 98 FF 9F FF F8 F0 0F FF'
X	'AF 0F FF F9 F8 FF FF FF F9 F9 FF FF F8 F0 0F FA'
X	'FA 0F FF 9F C8 FF FF FF F9 9F CF FF F8 F0 0F AF'
X	'FF 0A F9 FF FC FF FF FF F8 9C FC FF F8 F0 0F AF'
X	'FF 0F AF FF F8 CF FF FF F8 FC FF CF F8 F0 0A FF'
X	'FF 0F AF FF F8 FC FF FF F8 CF FF FC F8 F0 0F FF'
X	'FF 09 FA FF F8 FF CF FF FC FF FF FF C8 F0 08 88'
X	'89 08 88 A8 88 88 8C 88 C8 88 88 88 C8 80 0F FF'
X	'9F 0F FF AF F8 FF FF CF C8 FF FF FF FC F0 0F FF'
X	'9F 0F FF FA F8 FF AF FC F8 FF FF FF F8 C0 0F F9'
X	'FF 0F FF FF A8 FA FA FF F8 FF FF FF F8 F0 0F 9F'
X	'FF 0F FF FF A8 AF FA FF F8 FF FF FF F8 F0 0F 9F'
X	'FF 0F FF FF FA FF FF AF F8 FF FF FF F8 F0 09 FF'
X	'FF 0F FF FF F8 FF FF FA F8 FF FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FA F8 FF FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FF A8 FF FF FF F8 F0 08 88'
X	'88 08 88 88 88 88 88 88 8A 88 88 88 88 80 0F FF'
X	'FF 0F FF FF F8 FF FF FF FA FF FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FF F8 AF FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FF F8 FA FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FF F8 FA FF FF F8 F0 0F FF'
X	'FF 0F FF FF F8 FF FF FF F8 FF AF FF F8 F0 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00'
XEND
X
Xtexticon ICON 
XBEGIN
X	'00 00 01 00 01 00 20 20 10 00 00 00 00 00 E8 02'
X	'00 00 16 00 00 00 28 00 00 00 20 00 00 00 40 00'
X	'00 00 01 00 04 00 00 00 00 00 80 02 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 80 00 00 80 00 00 00 80 80 00 80 00'
X	'00 00 80 00 80 00 80 80 00 00 80 80 80 00 C0 C0'
X	'C0 00 00 00 FF 00 00 FF 00 00 00 FF FF 00 FF 00'
X	'00 00 FF 00 FF 00 FF FF 00 00 FF FF FF 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 08 00'
X	'08 80 80 88 08 88 00 80 88 08 00 88 88 80 08 08'
X	'08 80 80 88 08 88 08 88 00 88 80 88 88 80 08 88'
X	'08 80 80 88 08 88 08 88 00 88 80 88 88 80 08 80'
X	'08 80 80 08 08 88 08 80 88 08 80 88 88 80 08 00'
X	'88 00 80 80 08 88 08 88 88 88 80 88 88 80 08 08'
X	'88 88 88 88 88 88 08 88 88 88 80 88 88 80 08 08'
X	'08 80 88 88 88 88 08 88 88 88 80 88 88 80 08 00'
X	'08 88 88 88 88 88 00 88 88 88 00 88 88 80 08 88'
X	'88 88 88 88 88 88 88 88 88 88 88 88 88 80 0F FF'
X	'FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0F FF'
X	'FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0F FF'
X	'FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0F 0F'
X	'FF FF F0 FF 00 0F FF 0F FF FF FF FF FF F0 0F 0F'
X	'FF FF F0 F0 FF F0 F0 FF FF FF FF FF FF F0 0F 0F'
X	'FF FF F0 F0 FF F0 F0 FF FF FF FF FF FF F0 0F 0F'
X	'FF FF F0 F0 FF F0 F0 FF FF FF FF FF FF F0 0F 00'
X	'00 0F F0 F0 FF F0 F0 FF FF FF FF FF FF F0 0F 0F'
X	'FF F0 F0 FF 00 0F F0 0F FF FF FF FF FF F0 0F 0F'
X	'FF F0 F0 FF FF FF F0 FF FF FF FF FF FF F0 0F 0F'
X	'FF F0 F0 FF FF FF F0 FF FF FF FF FF FF F0 0F 00'
X	'00 0F F0 FF FF FF FF FF FF FF FF FF FF F0 0F FF'
X	'FF FF FF FF FF FF FF FF FF FF FF FF FF F0 0F FF'
X	'FF FF FF FF FF FF FF FF FF FF FF FF FF F0 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00'
X	'00 00 00 00 00 00 00 00 00 00 00 00 00 00'
XEND
X#endif
END_OF_FILE
  if test 5362 -ne `wc -c <'gnuplot/win/wgnuplot.rc'`; then
    echo shar: \"'gnuplot/win/wgnuplot.rc'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wgnuplot.rc'
fi
echo shar: End of archive 28 \(of 33\).
cp /dev/null ark28isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
