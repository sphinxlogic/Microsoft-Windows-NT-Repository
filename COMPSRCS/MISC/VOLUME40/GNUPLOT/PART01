Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i013:  gnuplot - interactive function plotting utility, Part01/33
Message-ID: <csm-v40i013=gnuplot.093446@sparky.Sterling.COM>
X-Md4-Signature: 810dd7590222cbae3037d4be4f366287
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Stanford University
Date: Thu, 21 Oct 1993 14:41:37 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 13
Archive-name: gnuplot/part01
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

This is version 3.5 of gnuplot.

Gnuplot is a command-line driven interactive function plotting utility
for UNIX, MSDOS, and VMS platforms.  The software is copyrighted but
freely distributed (i.e., you don't have to pay for it).  It was
originally intended as graphical program which would allow scientists
and students to visualize mathematical functions and data.  Additions
to this version of the software allow plots of three-dimensional
functions and data files.  Gnuplot supports many different types of
terminals, plotters, and printers and is easily extensible to include
new devices.  [ The "GNU" in Gnuplot is NOT related to the Free
Software Foundation, the naming is just a coincidence (and a long
story). Thus gnuplot is not covered by the Gnu copyleft, but rather
by its own copyright statement, included in all source code files.]

Gnuplot handles both curves (2 dimensions) and surfaces (3
dimensions). Surfaces can be plotted as a mesh fitting the specified
function, floating in the 3-d coordinate space, or as a contour plot
on the x-y plane. For 2-d plots, there are also many plot styles,
including lines, points, lines with points, error bars, and impulses
(crude bar graphs). Graphs may be labeled with arbitrary labels and
arrows, axes labels, a title, date and time, and a key.  The interface
includes command-line editing and history on most platforms.

This release marks the end of my tenure as the coordinator of the
gnuplot effort.  I have learned a great deal with this effort and
you and I should both appreciate the contributions for all the
volunteers who have worked on gnuplot and tried to make it better.

Alexander Lehmann has graciously volunteered to coordinate the
next release with contributions from Lars Henke, Nick Stroebel 
and many others.  New contributions should be sent
to bug-gnuplot@dartmouth.edu.   

 ========================================================================
 Alex Woo                         woo@playfair.stanford.edu
 Disclaimer: These comments are not official statements of any organization.
 ========================================================================
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot gnuplot/README.3p5 gnuplot/demo gnuplot/docs
#   gnuplot/docs/latextut gnuplot/os2 gnuplot/term gnuplot/term.c
#   gnuplot/win
# Wrapped by kent@sparky on Wed Oct 20 17:14:37 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 33)."'
if test ! -d 'gnuplot' ; then
    echo shar: Creating directory \"'gnuplot'\"
    mkdir 'gnuplot'
fi
if test -f 'gnuplot/README.3p5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/README.3p5'\"
else
  echo shar: Extracting \"'gnuplot/README.3p5'\" \(3356 characters\)
  sed "s/^X//" >'gnuplot/README.3p5' <<'END_OF_FILE'
XThis is a bugfix to version 3.4.
X
X
X# $Id: makefile.r%v 3.50.1.17 1993/08/27 05:21:33 woo Exp woo $
X#
X# $Log: makefile.r%v $
X# Revision 3.50.1.17  1993/08/27  05:21:33  woo
X# V. Khera's fig patch
X#
X# Revision 3.50.1.16  1993/08/27  05:04:42  woo
X# Added <errno.h> to help.c and added support routines to binary.c
X#
X# Revision 3.50.1.15  1993/08/21  15:23:42  woo
X# Rewrote print_3dtable
X#
X# Revision 3.50.1.14  1993/08/19  04:10:23  woo
X# V. Broman sun_mgr driver
X#
X# Revision 3.50.1.13  1993/08/19  03:21:26  woo
X# R. Lang fix to MS-Windows print driver
X#
X# Revision 3.50.1.11  1993/08/10  03:55:03  woo
X# R. Lang mod to change location of plot in hppj.trm
X#
X# Revision 3.50.1.10  1993/08/07  16:06:34  woo
X# Fix using n bug, configure 1.3
X#
X# Revision 3.50.1.9  1993/08/05  05:38:59  woo
X# Fix timedate location for splot and plot + CONFIGURE ROUTINE
X#
X# Revision 3.50.1.8  1993/07/27  05:37:15  woo
X# More mods for SOLARIS 2.2 using gcc
X#
X# Revision 3.50.1.7  1993/07/27  04:57:58  woo
X# Fix impulse plot style if logscale y
X#
X# Revision 3.50.1.6  1993/07/27  03:35:12  woo
X# Fix epsviewe.m 
X#
X# Revision 3.50.1.4  1993/07/26  06:17:24  woo
X# Solaris mods to sun_x11 and gplt_x11.c
X#
X# Revision 3.50.1.3  1993/07/26  05:38:19  woo
X# DEC ALPHA OSF1 mods
X#
X# Revision 3.50.1.2  1993/07/26  05:12:42  woo
X# fix of replot of replot bug
X#
X# Revision 3.50.1.1  1993/07/26  04:59:54  woo
X# fix of splot notitle bug
X#
X# Revision 3.50  1993/07/09  05:35:24  woo
X# Baseline version 3.5 version
X#
X# Revision 3.38.2.153  1993/07/08  03:43:32  woo
X# Added dgrid3d save to misc.c and updated titlepages
X#
X# Revision 3.38.2.153  1993/07/08  03:43:32  woo
X# Added dgrid3d save to misc.c and updated titlepages
X#
X# Revision 3.38.2.152  1993/07/06  15:03:56  woo
X# A. Lehmann cleanup of 3_5b1
X#
X# Revision 3.38.2.151  1993/07/06  14:33:51  woo
X# New 0FAQ and AXPVMS fix to gplt_x11.c
X#
X# Revision 3.38.2.150  1993/07/02  16:42:43  woo
X# A. Reeh fix for monochrome X11 under VMS
X#
X# Revision 3.38.2.149  1993/07/01  20:31:55  woo
X# New version of GRASS makefile
X#
X# Revision 3.38.2.148  1993/07/01  13:54:25  woo
X# T. Collins changes to Latex line types
X#
X# Revision 3.38.2.147  1993/07/01  13:41:44  woo
X# A. Lehmann fix for hpux internal.c
X#
X# Revision 3.38.2.146  1993/06/30  21:24:08  woo
X# Fix to flash graphics, rosenbrock function in contours.dem
X#
X# Revision 3.38.2.145  1993/06/30  20:16:22  woo
X# Yehavi fixes for AXPVMS
X#
X# Revision 3.38.2.144  1993/06/23  00:34:39  woo
X# Reordered latex line types -- lighter default line
X#
X# Revision 3.38.2.143  1993/06/23  00:10:28  woo
X# R. Shouman fix of blank title induced linetype bug
X#
X# Revision 3.38.2.142  1993/06/21  14:43:21  woo
X# P. Egghart check on PLOSS for matherr and pass MY_FLAGS to subdirectories
X#
X# Revision 3.38.2.141  1993/06/19  13:00:21  woo
X# Okidata driver and time_t for sun386 mod
X#
X# Revision 3.38.2.140  1993/06/19  12:29:34  woo
X# J. Abbey fixes for Alliant
X#
X# Revision 3.38.2.139  1993/06/19  01:03:49  woo
X# Fix for 3d clipping bug
X#
X# Revision 3.38.2.138  1993/06/16  00:38:14  woo
X# O. Franksson MIF mod for vertical text and better char size
X#
X# Revision 3.38.2.137  1993/06/15  23:57:02  woo
X# Linux fixes
X#
X# Revision 3.38.2.136  1993/06/15  23:33:29  woo
X# V. Khera non-interactive stderr fix
X#
X# Revision 3.38.2.135  1993/06/15  22:02:26  woo
X# splot fix for x & y tics and labels
END_OF_FILE
  if test 3356 -ne `wc -c <'gnuplot/README.3p5'`; then
    echo shar: \"'gnuplot/README.3p5'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/README.3p5'
fi
if test ! -d 'gnuplot/demo' ; then
    echo shar: Creating directory \"'gnuplot/demo'\"
    mkdir 'gnuplot/demo'
fi
if test ! -d 'gnuplot/docs' ; then
    echo shar: Creating directory \"'gnuplot/docs'\"
    mkdir 'gnuplot/docs'
fi
if test ! -d 'gnuplot/docs/latextut' ; then
    echo shar: Creating directory \"'gnuplot/docs/latextut'\"
    mkdir 'gnuplot/docs/latextut'
fi
if test ! -d 'gnuplot/os2' ; then
    echo shar: Creating directory \"'gnuplot/os2'\"
    mkdir 'gnuplot/os2'
fi
if test ! -d 'gnuplot/term' ; then
    echo shar: Creating directory \"'gnuplot/term'\"
    mkdir 'gnuplot/term'
fi
if test -f 'gnuplot/term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term.c'\"
else
  echo shar: Extracting \"'gnuplot/term.c'\" \(69784 characters\)
  sed "s/^X//" >'gnuplot/term.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: term.c%v 3.50.1.17 1993/08/27 05:21:33 woo Exp woo $";
X#endif
X
X
X/* GNUPLOT - term.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X * 
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include "plot.h"
X#include "setshow.h"
X#include "term.h"
X#include "bitmap.h"
X#ifdef NEXT
X#include <stdlib.h>
X#include "epsviewe.h"
X#endif /* NEXT */
X
X#ifdef _Windows
X#ifdef __MSC__
X#include <malloc.h>
X#else
X#include <alloc.h>
X#endif
X#endif
X
X#if defined(__TURBOC__) && defined(MSDOS)
X#ifndef _Windows
X#include <dos.h>
X#endif
X#endif
X
X/* for use by all drivers */
X#define sign(x) ((x) >= 0 ? 1 : -1)
X#define abs(x) ((x) >= 0 ? (x) : -(x))
X
X#ifndef max	/* GCC uses inline functions */
X#define max(a,b) ((a) > (b) ? (a) : (b))
X#endif
X#ifndef min
X#define min(a,b) ((a) < (b) ? (a) : (b))
X#endif
X
XTBOOLEAN term_init;			/* true if terminal has been initialized */
X
Xextern FILE *outfile;
Xextern char outstr[];
Xextern TBOOLEAN term_init;
Xextern int term;
Xextern float xsize, ysize;
X
Xextern char input_line[];
Xextern struct lexical_unit token[];
Xextern int num_tokens, c_token;
Xextern struct value *const_express();
X
Xextern TBOOLEAN interactive;
X
X/*
X * instead of <strings.h>
X */
X
X#if defined(_Windows) || ( defined(__TURBOC__) && defined(MSDOS) )
X# include <string.h>
X#else
X#ifdef ATARI
X#include <string.h>
X#include <math.h>
X#else
X#ifndef AMIGA_SC_6_1
Xextern char *strcpy();
X#ifdef ANSI
Xextern size_t   strlen();
X#else
Xextern int      strlen();
X#endif
Xextern int  strcmp(), strncmp();
X#endif /* !AMIGA_SC_6_1 */
X#endif
X#endif
X
X#ifndef AMIGA_AC_5
Xextern double sqrt();
X#endif
X
Xchar *getenv();
X
X#if defined(__TURBOC__) && defined(MSDOS) && !defined(_Windows)
Xchar *turboc_init();
X#endif
X
X#ifdef __ZTC__
Xchar *ztc_init();
X/* #undef TGIF */
X#endif
X
X
X#if defined(MSDOS)||defined(ATARI)||defined(OS2)||defined(_Windows)||defined(DOS386)
Xvoid reopen_binary();
X#define REOPEN_BINARY
X#endif
X#ifdef vms
Xchar *vms_init();
Xvoid vms_reset();
Xvoid term_mode_tek();
Xvoid term_mode_native();
Xvoid term_pasthru();
Xvoid term_nopasthru();
Xvoid reopen_binary();
Xvoid fflush_binary();
X#define REOPEN_BINARY
X#endif
X
X/* This is needed because the unixplot library only writes to stdout. */
X#ifdef UNIXPLOT
XFILE save_stdout;
X#endif
Xint unixplot=0;
X
X#define NICE_LINE		0
X#define POINT_TYPES		6
X
X
Xdo_point(x,y,number)
Xint x,y;
Xint number;
X{
Xregister int htic,vtic;
Xregister struct termentry *t = &term_tbl[term];
X
X     if (number < 0) {		/* do dot */
X	    (*t->move)(x,y);
X	    (*t->vector)(x,y);
X	    return(0);
X	}
X
X	number %= POINT_TYPES;
X	htic = (t->h_tic/2);	/* should be in term_tbl[] in later version */
X	vtic = (t->v_tic/2);	
X
X	switch(number) {
X		case 0: /* do diamond */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x+htic,y);
X				(*t->vector)(x,y+vtic);
X				(*t->vector)(x-htic,y);
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 1: /* do plus */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x-htic,y);
X				(*t->vector)(x+htic,y);
X				(*t->move)(x,y-vtic);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x,y+vtic);
X				break;
X		case 2: /* do box */ 
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 3: /* do X */ 
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->move)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x+htic,y-vtic);
X				break;
X		case 4: /* do triangle */ 
X				(*t->move)(x,y+(4*vtic/3));
X				(*t->vector)(x-(4*htic/3),y-(2*vtic/3));
X				(*t->vector)(x+(4*htic/3),y-(2*vtic/3));
X				(*t->vector)(x,y+(4*vtic/3));
X				(*t->move)(x,y);
X				(*t->vector)(x,y);
X				break;
X		case 5: /* do star */ 
X				(*t->move)(x-htic,y);
X				(*t->vector)(x-htic,y);
X				(*t->vector)(x+htic,y);
X				(*t->move)(x,y-vtic);
X				(*t->vector)(x,y-vtic);
X				(*t->vector)(x,y+vtic);
X				(*t->move)(x-htic,y-vtic);
X				(*t->vector)(x-htic,y-vtic);
X				(*t->vector)(x+htic,y+vtic);
X				(*t->move)(x-htic,y+vtic);
X				(*t->vector)(x-htic,y+vtic);
X				(*t->vector)(x+htic,y-vtic);
X				break;
X	}
X}
X
X
X/*
X * general point routine
X */
Xline_and_point(x,y,number)
Xint x,y,number;
X{
X	/* temporary(?) kludge to allow terminals with bad linetypes 
X		to make nice marks */
X
X	(*term_tbl[term].linetype)(NICE_LINE);
X	do_point(x,y,number);
X}
X
X/* 
X * general arrow routine
X */
X#define ROOT2 (1.41421)		/* sqrt of 2 */
X
Xdo_arrow(sx, sy, ex, ey, head)
X	int sx,sy;			/* start point */
X	int ex, ey;			/* end point (point of arrowhead) */
X	TBOOLEAN head;
X{
X    register struct termentry *t = &term_tbl[term];
X    int len = (t->h_tic + t->v_tic)/2; /* arrowhead size = avg of tic sizes */
X
X    /* draw the line for the arrow. That's easy. */
X    (*t->move)(sx, sy);
X    (*t->vector)(ex, ey);
X
X    if (head) {
X    /* now draw the arrow head. */
X    /* we put the arrowhead marks at 45 degrees to line */
X       if (sx == ex) {
X	   /* vertical line, special case */
X	      int delta = ((float)len / ROOT2 + 0.5);
X	      if (sy < ey)
X		      delta = -delta;	/* up arrow goes the other way */
X	      (*t->move)(ex - delta, ey + delta);
X	      (*t->vector)(ex,ey);
X	      (*t->vector)(ex + delta, ey + delta);
X       } else {
X	      int dx = sx - ex;
X	      int dy = sy - ey;
X	      double coeff = len / sqrt(2.0*((double)dx*(double)dx 
X				   + (double)dy*(double)dy));
X	      int x,y;			/* one endpoint */
X
X	      x = (int)( ex + (dx + dy) * coeff );
X	      y = (int)( ey + (dy - dx) * coeff );
X	      (*t->move)(x,y);
X	      (*t->vector)(ex,ey);
X
X	      x = (int)( ex + (dx - dy) * coeff );
X	      y = (int)( ey + (dy + dx) * coeff );
X	      (*t->vector)(x,y);
X       }
X    }
X}
X
X#ifdef DUMB                    /* paper or glass dumb terminal */
X#include "term/dumb.trm"
X#endif
X
X
X#ifndef _Windows
X# ifdef PC			/* all PC types except MS WINDOWS*/
X#  include "term/pc.trm"
X# endif
X#else
X#  include "term/win.trm"
X#endif
X
X#ifdef __ZTC__
X#include "term/fg.trm"
X#endif
X
X#ifdef DJSVGA
X#include "term/djsvga.trm"	/* DJGPP SVGA */
X#endif
X
X#ifdef EMXVGA
X#include "term/emxvga.trm"	/* EMX VGA */
X#endif
X
X#ifdef OS2PM                    /* os/2 presentation manager */
X#include "term/pm.trm"
X#endif
X
X#ifdef ATARI			/* ATARI-ST */
X#include "term/atari.trm"
X#endif
X
X/*
X   all TEK types (TEK,BITGRAPH,KERMIT,VTTEK,SELANAR) are ifdef'd in tek.trm,
X   but most require various TEK routines.  Hence TEK must be defined for
X   the others to compile.
X*/
X#ifdef BITGRAPH
X# ifndef TEK
X#  define TEK
X# endif
X#endif
X
X#ifdef SELENAR
X# ifndef TEK
X#  define TEK
X# endif
X#endif
X
X#ifdef KERMIT
X# ifndef TEK
X#  define TEK
X# endif
X#endif
X
X#ifdef LN03P
X# ifndef TEK
X#  define TEK
X# endif
X#endif
X
X#ifdef VTTEK
X# ifndef TEK
X#  define TEK
X# endif
X#endif
X
X#ifdef T410X		/* Tektronix 4106, 4107, 4109 and 420x terminals */
X#include "term/t410x.trm"
X#endif
X
X#ifdef TEK			/* all TEK types, TEK, BBN, SELANAR, KERMIT, VTTEK */
X#include "term/tek.trm"
X#endif
X
X#ifdef OKIDATA
X#define EPSONP
X#endif
X
X#ifdef EPSONP	/* bit map types, EPSON, NEC, PROPRINTER, STAR Color */
X#include "term/epson.trm"
X#endif
X
X#ifdef HP500C  /* HP 500 deskjet Colour */
X#include "term/hp500c.trm"
X#endif
X
X#ifdef HPLJII		/* HP LaserJet II */
X#include "term/hpljii.trm"
X#endif
X
X#ifdef PCL /* HP LaserJet III in HPGL mode */
X#  ifndef HPGL
X#    define HPGL
X#  endif
X#endif
X
X#ifdef HPPJ		/* HP PaintJet */
X#include "term/hppj.trm"
X#endif
X
X#ifdef FIG			/* Fig 2.1 Interactive graphics program */
X#include "term/fig.trm"
X#include "term/bigfig.trm"
X#endif
X  
X#ifdef GPR              /* Apollo Graphics Primitive Resource (fixed-size window) */
X#include "term/gpr.trm"
X#endif /* GPR */
X
X#ifdef GRASS              /* GRASS (geographic info system) monitor */
X#include "term/grass.trm"
X#endif /* GRASS */
X
X#ifdef APOLLO           /* Apollo Graphics Primitive Resource (resizable window) */
X#include "term/apollo.trm"
X#endif /* APOLLO */
X
X#ifdef IMAGEN		/* IMAGEN printer */
X#include "term/imagen.trm"
X#endif
X
X#ifdef MIF			/* Framemaker MIF  driver */
X#include "term/mif.trm"
X#endif
X
X#ifdef MF			/* METAFONT driver */
X#include "term/metafont.trm"
X#endif
X
X#ifdef TEXDRAW
X#include "term/texdraw.trm"
X#endif
X
X#ifdef EEPIC		/* EEPIC (LATEX) type */
X#include "term/eepic.trm"
X# ifndef LATEX
X#  define LATEX
X# endif
X#endif
X
X#ifdef EMTEX		/* EMTEX (LATEX for PC) type */
X# ifndef LATEX
X#  define LATEX
X# endif
X#endif
X
X#ifdef LATEX		/* LATEX type */
X#include "term/latex.trm"
X#endif
X
X#ifdef GPIC		/* GPIC (groff) type */ 
X#include "term/gpic.trm"
X#endif
X
X#ifdef PBM		/* PBMPLUS portable bitmap */
X#include "term/pbm.trm"
X#endif
X
X#ifdef POSTSCRIPT	/* POSTSCRIPT type */
X#include "term/post.trm"
X#endif
X
X#ifdef PRESCRIBE	/* PRESCRIBE type */
X#include "term/kyo.trm"
X#endif
X
X/* note: this must come after term/post.trm */
X#ifdef PSLATEX		/* LaTeX with embedded PostScript */
X#include "term/pslatex.trm"
X#endif
X
X#ifdef PSTRICKS
X#include "term/pstricks.trm"
X#endif
X
X#ifdef TPIC		/* TPIC (LATEX) type */
X#include "term/tpic.trm"
X# ifndef LATEX
X#  define LATEX
X# endif
X#endif
X
X#ifdef UNIXPC     /* unix-PC  ATT 7300 or 3b1 machine */
X#include "term/unixpc.trm"
X#endif /* UNIXPC */
X
X#ifdef AED
X#include "term/aed.trm"
X#endif /* AED */
X
X#ifdef AIFM
X#include "term/ai.trm"
X#endif /* AIFM */
X
X#ifdef COREL
X#include "term/corel.trm"
X#endif /* COREL */
X
X#ifdef CGI
X#include "term/cgi.trm"
X#endif /* CGI */
X
X#ifdef DEBUG
X#include "term/debug.trm"
X#endif /* DEBUG */
X
X#ifdef EXCL
X#include "term/excl.trm"
X#endif /* EXCL */
X
X#ifdef HP2648
X/* also works for HP2647 */
X#include "term/hp2648.trm"
X#endif /* HP2648 */
X
X#ifdef HP26
X#include "term/hp26.trm"
X#endif /* HP26 */
X
X#ifdef HP75
X#ifndef HPGL
X#define HPGL
X#endif
X#endif
X
X/* HPGL - includes HP75 and HPLJIII in HPGL mode */
X#ifdef HPGL
X#include "term/hpgl.trm"
X#endif /* HPGL */
X
X/* Roland DXY800A plotter driver by Martin Yii, eln557h@monu3.OZ 
X	and Russell Lang, rjl@monu1.cc.monash.oz */
X#ifdef DXY800A
X#include "term/dxy.trm"
X#endif /* DXY800A */
X
X#ifdef IRIS4D
X#include "term/iris4d.trm"
X#endif /* IRIS4D */
X
X#ifdef NEXT
X#include "term/next.trm"
X#endif /* NEXT */
X
X#ifdef QMS
X#include "term/qms.trm"
X#endif /* QMS */
X
X#ifdef REGIS
X#include "term/regis.trm"
X#endif /* REGIS */
X
X#ifdef RGIP
X#include "term/rgip.trm"
X#endif /* RGIP UNIPLEX */
X
X#ifdef MGR
X#include "term/mgr.trm"
X#endif /* MGR */
X
X#ifdef SUN
X#include "term/sun.trm"
X#endif /* SUN */
X
X#ifdef VWS
X#include "term/vws.trm"
X#endif /* VWS */
X
X#ifdef V384
X#include "term/v384.trm"
X#endif /* V384 */
X
X#ifdef TGIF
X#include "term/tgif.trm"
X#endif /* TGIF */
X
X#ifdef UNIXPLOT
X#ifdef GNUGRAPH
X#include "term/gnugraph.trm"
X#else
X#include "term/unixplot.trm"
X#endif /* GNUGRAPH */
X#endif /* UNIXPLOT */
X
X#ifdef X11
X#include "term/x11.trm"
X#include "term/xlib.trm"
X#endif /* X11 */
X
X#ifdef DXF
X#include "term/dxf.trm"
X#endif /* DXF */
X  
X#ifdef AMIGASCREEN
X#include "term/amiga.trm"
X#endif /* AMIGASCREEN */
X
X/* Dummy functions for unavailable features */
X
X/* change angle of text.  0 is horizontal left to right.
X* 1 is vertical bottom to top (90 deg rotate)  
X*/
Xstatic int null_text_angle()
X{
Xreturn FALSE ;	/* can't be done */
X}
X
X/* change justification of text.  
X * modes are LEFT (flush left), CENTRE (centred), RIGHT (flush right)
X */
Xstatic int null_justify_text()
X{
Xreturn FALSE ;	/* can't be done */
X}
X
X
X/* Change scale of plot.
X * Parameters are x,y scaling factors for this plot.
X * Some terminals (eg latex) need to do scaling themselves.
X */
Xstatic int null_scale()
X{
Xreturn FALSE ;	/* can't be done */
X}
X
Xstatic int do_scale()
X{
Xreturn TRUE ;	/* can be done */
X}
X
Xoptions_null()
X{
X	term_options[0] = '\0';	/* we have no options */
X}
X
Xstatic UNKNOWN_null()
X{
X}
X
X/*
X * term_tbl[] contains an entry for each terminal.  "unknown" must be the
X *   first, since term is initialized to 0.
X */
Xstruct termentry term_tbl[] = {
X    {"unknown", "Unknown terminal type - not a plotting device",
X	  100, 100, 1, 1,
X	  1, 1, options_null, UNKNOWN_null, UNKNOWN_null, 
X	  UNKNOWN_null, null_scale, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, 
X	  UNKNOWN_null, UNKNOWN_null, null_text_angle, 
X	  null_justify_text, UNKNOWN_null, UNKNOWN_null}
X
X    ,{"table", "Dump ASCII table of X Y [Z] values to output",
X	  100, 100, 1, 1,
X	  1, 1, options_null, UNKNOWN_null, UNKNOWN_null, 
X	  UNKNOWN_null, null_scale, UNKNOWN_null, UNKNOWN_null, UNKNOWN_null, 
X	  UNKNOWN_null, UNKNOWN_null, null_text_angle, 
X	  null_justify_text, UNKNOWN_null, UNKNOWN_null}
X
X#ifdef AMIGASCREEN
X    ,{"amiga", "Amiga Custom Screen",
X	   AMIGA_XMAX, AMIGA_YMAX, AMIGA_VCHAR, AMIGA_HCHAR, 
X	   AMIGA_VTIC, AMIGA_HTIC, options_null, AMIGA_init, AMIGA_reset, 
X	   AMIGA_text, null_scale, AMIGA_graphics, AMIGA_move, AMIGA_vector,
X	   AMIGA_linetype, AMIGA_put_text, null_text_angle, 
X	   AMIGA_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef ATARI
X    ,{"atari", "Atari ST/TT",
X	   ATARI_XMAX, ATARI_YMAX, ATARI_VCHAR, ATARI_HCHAR, 
X	   ATARI_VTIC, ATARI_HTIC, ATARI_options, ATARI_init, ATARI_reset, 
X	   ATARI_text, null_scale, ATARI_graphics, ATARI_move, ATARI_vector, 
X	   ATARI_linetype, ATARI_put_text, ATARI_text_angle, 
X	   null_justify_text, ATARI_point, do_arrow}
X#endif
X
X#ifdef DUMB
X    ,{"dumb", "printer or glass dumb terminal",
X         DUMB_XMAX, DUMB_YMAX, 1, 1,
X         1, 1, DUMB_options, DUMB_init, DUMB_reset,
X         DUMB_text, null_scale, DUMB_graphics, DUMB_move, DUMB_vector,
X         DUMB_linetype, DUMB_put_text, null_text_angle,
X         null_justify_text, DUMB_point, DUMB_arrow}
X#endif
X
X#ifdef PC
X#ifndef _Windows
X# ifdef __TURBOC__
X#ifdef ATT6300
X    ,{"att", "IBM PC/Clone with AT&T 6300 graphics board",
X	   ATT_XMAX, ATT_YMAX, ATT_VCHAR, ATT_HCHAR,
X	   ATT_VTIC, ATT_HTIC, options_null, ATT_init, ATT_reset,
X	   ATT_text, null_scale, ATT_graphics, ATT_move, ATT_vector,
X	   ATT_linetype, ATT_put_text, ATT_text_angle, 
X	   ATT_justify_text, line_and_point, do_arrow}
X#endif
X
X    ,{"cga", "IBM PC/Clone with CGA graphics board",
X	   CGA_XMAX, CGA_YMAX, CGA_VCHAR, CGA_HCHAR,
X	   CGA_VTIC, CGA_HTIC, options_null, CGA_init, CGA_reset,
X	   CGA_text, null_scale, CGA_graphics, CGA_move, CGA_vector,
X	   CGA_linetype, CGA_put_text, MCGA_text_angle, 
X	   CGA_justify_text, line_and_point, do_arrow}
X
X    ,{"egalib", "IBM PC/Clone with EGA graphics board",
X	   EGALIB_XMAX, EGALIB_YMAX, EGALIB_VCHAR, EGALIB_HCHAR,
X	   EGALIB_VTIC, EGALIB_HTIC, options_null, EGALIB_init, EGALIB_reset,
X	   EGALIB_text, null_scale, EGALIB_graphics, EGALIB_move, EGALIB_vector,
X	   EGALIB_linetype, EGALIB_put_text, EGALIB_text_angle, 
X	   EGALIB_justify_text, do_point, do_arrow}
X
X    ,{"hercules", "IBM PC/Clone with Hercules graphics board",
X	   HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
X	   HERC_VTIC, HERC_HTIC, options_null, HERC_init, HERC_reset,
X	   HERC_text, null_scale, HERC_graphics, HERC_move, HERC_vector,
X	   HERC_linetype, HERC_put_text, MCGA_text_angle, 
X	   HERC_justify_text, line_and_point, do_arrow}
X
X    ,{"mcga", "IBM PC/Clone with MCGA graphics board",
X	   MCGA_XMAX, MCGA_YMAX, MCGA_VCHAR, MCGA_HCHAR,
X	   MCGA_VTIC, MCGA_HTIC, options_null, MCGA_init, MCGA_reset,
X	   MCGA_text, null_scale, MCGA_graphics, MCGA_move, MCGA_vector,
X	   MCGA_linetype, MCGA_put_text, MCGA_text_angle, 
X	   MCGA_justify_text, line_and_point, do_arrow}
X
X    ,{"svga", "IBM PC/Clone with Super VGA graphics board",
X	   SVGA_XMAX, SVGA_YMAX, SVGA_VCHAR, SVGA_HCHAR,
X	   SVGA_VTIC, SVGA_HTIC, options_null, SVGA_init, SVGA_reset,
X	   SVGA_text, null_scale, SVGA_graphics, SVGA_move, SVGA_vector,
X	   SVGA_linetype, SVGA_put_text, SVGA_text_angle, 
X	   SVGA_justify_text, do_point, do_arrow}
X
X    ,{"vgalib", "IBM PC/Clone with VGA graphics board",
X	   VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X	   VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, VGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X	   VGA_justify_text, do_point, do_arrow}
X
X    ,{"vgamono", "IBM PC/Clone with VGA Monochrome graphics board",
X	   VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X	   VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, VGA_graphics, VGA_move, VGA_vector,
X	   VGAMONO_linetype, VGA_put_text, VGA_text_angle, 
X	   VGA_justify_text, line_and_point, do_arrow}
X#else					/* TURBO */
X
X#ifdef ATT6300
X    ,{"att", "AT&T PC/6300 graphics",
X	   ATT_XMAX, ATT_YMAX, ATT_VCHAR, ATT_HCHAR,
X	   ATT_VTIC, ATT_HTIC, options_null, ATT_init, ATT_reset,
X	   ATT_text, null_scale, ATT_graphics, ATT_move, ATT_vector,
X	   ATT_linetype, ATT_put_text, ATT_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X    ,{"cga", "IBM PC/Clone with CGA graphics board",
X	   CGA_XMAX, CGA_YMAX, CGA_VCHAR, CGA_HCHAR,
X	   CGA_VTIC, CGA_HTIC, options_null, CGA_init, CGA_reset,
X	   CGA_text, null_scale, CGA_graphics, CGA_move, CGA_vector,
X	   CGA_linetype, CGA_put_text, CGA_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X
X#ifdef CORONA
X    ,{"corona325", "Corona graphics ???",
X	   COR_XMAX, COR_YMAX, COR_VCHAR, COR_HCHAR,
X	   COR_VTIC, COR_HTIC, options_null, COR_init, COR_reset,
X	   COR_text, null_scale, COR_graphics, COR_move, COR_vector,
X	   COR_linetype, COR_put_text, COR_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif					/* CORONA */
X
X    ,{"egabios", "IBM PC/Clone with EGA graphics board (BIOS)",
X	   EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
X	   EGA_VTIC, EGA_HTIC, options_null, EGA_init, EGA_reset,
X	   EGA_text, null_scale, EGA_graphics, EGA_move, EGA_vector,
X	   EGA_linetype, EGA_put_text, EGA_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X
X#ifdef EGALIB
X    ,{"egalib", "IBM PC/Clone with EGA graphics board (LIB)",
X	   EGALIB_XMAX, EGALIB_YMAX, EGALIB_VCHAR, EGALIB_HCHAR,
X	   EGALIB_VTIC, EGALIB_HTIC, options_null, EGALIB_init, EGALIB_reset,
X	   EGALIB_text, null_scale, EGALIB_graphics, EGALIB_move, EGALIB_vector,
X	   EGALIB_linetype, EGALIB_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef HERCULES
X    ,{"hercules", "IBM PC/Clone with Hercules graphics board",
X	   HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
X	   HERC_VTIC, HERC_HTIC, options_null, HERC_init, HERC_reset,
X	   HERC_text, null_scale, HERC_graphics, HERC_move, HERC_vector,
X	   HERC_linetype, HERC_put_text, HERC_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif					/* HERCULES */
X
X    ,{"vgabios", "IBM PC/Clone with VGA graphics board (BIOS)",
X	   VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X	   VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, VGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X
X#endif					/* TURBO */
X#endif					/* _Windows */
X#endif					/* PC */
X
X#ifdef __ZTC__		 /* zortech C flashgraphics for 386 */
X	,{"hercules", "IBM PC/Clone with Hercules graphics board",
X	   HERC_XMAX, HERC_YMAX, HERC_VCHAR, HERC_HCHAR,
X	   HERC_VTIC, HERC_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, HERC_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X
X	,{"egamono", "IBM PC/Clone with monochrome EGA graphics board",
X	   EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
X	   EGA_VTIC, EGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, EGAMONO_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X
X	,{"egalib", "IBM PC/Clone with color EGA graphics board",
X	   EGA_XMAX, EGA_YMAX, EGA_VCHAR, EGA_HCHAR,
X	   EGA_VTIC, EGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, EGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X
X	,{"vgalib", "IBM PC/Clone with VGA graphics board",
X	   VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X	   VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, VGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X
X	,{"vgamono", "IBM PC/Clone with monochrome VGA graphics board",
X	   VGA_XMAX, VGA_YMAX, VGA_VCHAR, VGA_HCHAR,
X	   VGA_VTIC, VGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, VGAMONO_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X
X	,{"svgalib", "IBM PC/Clone with VESA Super VGA graphics board",
X	   SVGA_XMAX, SVGA_YMAX, SVGA_VCHAR, SVGA_HCHAR,
X	   SVGA_VTIC, SVGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, SVGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X	   VGA_justify_text, do_point, do_arrow}
X
X	,{"ssvgalib", "IBM PC/Clone with VESA 256 color 1024 by 768 super VGA",
X	   SSVGA_XMAX, SSVGA_YMAX, SSVGA_VCHAR, SSVGA_HCHAR,
X	   SSVGA_VTIC, SSVGA_HTIC, options_null, VGA_init, VGA_reset,
X	   VGA_text, null_scale, SSVGA_graphics, VGA_move, VGA_vector,
X	   VGA_linetype, VGA_put_text, VGA_text_angle, 
X       VGA_justify_text, do_point, do_arrow}
X#endif	/* __ZTC__ */
X
X#ifdef AED
X    ,{"aed512", "AED 512 Terminal",
X	   AED5_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
X	   AED_VTIC, AED_HTIC, options_null, AED_init, AED_reset, 
X	   AED_text, null_scale, AED_graphics, AED_move, AED_vector, 
X	   AED_linetype, AED_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X    ,{"aed767", "AED 767 Terminal",
X	   AED_XMAX, AED_YMAX, AED_VCHAR, AED_HCHAR,
X	   AED_VTIC, AED_HTIC, options_null, AED_init, AED_reset, 
X	   AED_text, null_scale, AED_graphics, AED_move, AED_vector, 
X	   AED_linetype, AED_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef AIFM
X    ,{"aifm", "Adobe Illustrator 3.0 Format",
X	   AI_XMAX, AI_YMAX, AI_VCHAR, AI_HCHAR, 
X	   AI_VTIC, AI_HTIC, AI_options, AI_init, AI_reset, 
X	   AI_text, null_scale, AI_graphics, AI_move, AI_vector, 
X	   AI_linetype, AI_put_text, AI_text_angle, 
X	   AI_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef APOLLO
X   	,{"apollo", "Apollo Graphics Primitive Resource, rescaling of subsequent plots after window resizing",
X	   0, 0, 0, 0, /* APOLLO_XMAX, APOLLO_YMAX, APOLLO_VCHAR, APOLLO_HCHAR, are filled in at run-time */
X	   APOLLO_VTIC, APOLLO_HTIC, options_null, APOLLO_init, APOLLO_reset,
X	   APOLLO_text, null_scale, APOLLO_graphics, APOLLO_move, APOLLO_vector,
X	   APOLLO_linetype, APOLLO_put_text, APOLLO_text_angle,
X	   APOLLO_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef GPR
X   	,{"gpr", "Apollo Graphics Primitive Resource, fixed-size window",
X	   GPR_XMAX, GPR_YMAX, GPR_VCHAR, GPR_HCHAR,
X	   GPR_VTIC, GPR_HTIC, options_null, GPR_init, GPR_reset,
X	   GPR_text, null_scale, GPR_graphics, GPR_move, GPR_vector,
X	   GPR_linetype, GPR_put_text, GPR_text_angle,
X	   GPR_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef BITGRAPH
X    ,{"bitgraph", "BBN Bitgraph Terminal",
X	   BG_XMAX,BG_YMAX,BG_VCHAR, BG_HCHAR, 
X	   BG_VTIC, BG_HTIC, options_null, BG_init, BG_reset, 
X	   BG_text, null_scale, BG_graphics, BG_move, BG_vector,
X	   BG_linetype, BG_put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef COREL
X    ,{"corel","EPS format for CorelDRAW",
X     CORELD_XMAX, CORELD_YMAX, CORELD_VCHAR, CORELD_HCHAR,
X     CORELD_VTIC, CORELD_HTIC, COREL_options, COREL_init, COREL_reset,
X     COREL_text, null_scale, COREL_graphics, COREL_move, COREL_vector,
X     COREL_linetype, COREL_put_text, COREL_text_angle,
X     COREL_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef CGI
X    ,{"cgi", "SCO CGI drivers (requires CGIDISP or CGIPRNT env variable)",
X	   CGI_XMAX, CGI_YMAX, 0, 0, 
X	   CGI_VTIC, 0, options_null, CGI_init, CGI_reset, 
X	   CGI_text, null_scale, CGI_graphics, CGI_move, CGI_vector, 
X	   CGI_linetype, CGI_put_text, CGI_text_angle, 
X	   CGI_justify_text, CGI_point, do_arrow}
X
X    ,{"hcgi", "SCO CGI drivers (hardcopy, requires CGIPRNT env variable)",
X	   CGI_XMAX, CGI_YMAX, 0, 0, 
X	   CGI_VTIC, 0, options_null, HCGI_init, CGI_reset, 
X	   CGI_text, null_scale, CGI_graphics, CGI_move, CGI_vector, 
X	   CGI_linetype, CGI_put_text, CGI_text_angle, 
X	   CGI_justify_text, CGI_point, do_arrow}
X#endif
X
X#ifdef DEBUG
X    ,{"debug", "debugging driver",
X	   DEBUG_XMAX, DEBUG_YMAX, DEBUG_VCHAR, DEBUG_HCHAR,
X	   DEBUG_VTIC, DEBUG_HTIC, options_null, DEBUG_init, DEBUG_reset,
X	   DEBUG_text, null_scale, DEBUG_graphics, DEBUG_move, DEBUG_vector,
X	   DEBUG_linetype, DEBUG_put_text, null_text_angle, 
X	   DEBUG_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef DJSVGA
X    ,{"svga", "IBM PC/Clone with Super VGA graphics board",
X	   DJSVGA_XMAX, DJSVGA_YMAX, DJSVGA_VCHAR, DJSVGA_HCHAR,
X	   DJSVGA_VTIC, DJSVGA_HTIC, options_null, DJSVGA_init, DJSVGA_reset,
X	   DJSVGA_text, null_scale, DJSVGA_graphics, DJSVGA_move, DJSVGA_vector,
X	   DJSVGA_linetype, DJSVGA_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef DXF
X    ,{"dxf", "dxf-file for AutoCad (default size 120x80)",
X       DXF_XMAX,DXF_YMAX,DXF_VCHAR, DXF_HCHAR,
X       DXF_VTIC, DXF_HTIC, options_null,DXF_init, DXF_reset,
X       DXF_text, null_scale, DXF_graphics, DXF_move, DXF_vector,
X       DXF_linetype, DXF_put_text, DXF_text_angle,
X       DXF_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef DXY800A
X    ,{"dxy800a", "Roland DXY800A plotter",
X	   DXY_XMAX, DXY_YMAX, DXY_VCHAR, DXY_HCHAR,
X	   DXY_VTIC, DXY_HTIC, options_null, DXY_init, DXY_reset,
X	   DXY_text, null_scale, DXY_graphics, DXY_move, DXY_vector,
X	   DXY_linetype, DXY_put_text, DXY_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef EEPIC
X    ,{"eepic", "EEPIC -- extended LaTeX picture environment",
X	   EEPIC_XMAX, EEPIC_YMAX, EEPIC_VCHAR, EEPIC_HCHAR, 
X	   EEPIC_VTIC, EEPIC_HTIC, options_null, EEPIC_init, EEPIC_reset, 
X	   EEPIC_text, EEPIC_scale, EEPIC_graphics, EEPIC_move, EEPIC_vector, 
X	   EEPIC_linetype, EEPIC_put_text, EEPIC_text_angle, 
X	   EEPIC_justify_text, EEPIC_point, EEPIC_arrow}
X#endif
X
X#ifdef EMTEX
X    ,{"emtex", "LaTeX picture environment with emTeX specials",
X	   LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR, 
X	   LATEX_VTIC, LATEX_HTIC, LATEX_options, EMTEX_init, EMTEX_reset, 
X	   EMTEX_text, LATEX_scale, LATEX_graphics, LATEX_move, LATEX_vector, 
X	   LATEX_linetype, LATEX_put_text, LATEX_text_angle, 
X	   LATEX_justify_text, LATEX_point, LATEX_arrow}
X#endif
X
X#ifdef EPS180
X    ,{"epson_180dpi", "Epson LQ-style 180-dot per inch (24 pin) printers",
X	   EPS180XMAX, EPS180YMAX, EPSON180VCHAR, EPSON180HCHAR,
X	   EPSON180VTIC, EPSON180HTIC, options_null, EPSONinit, EPSONreset,
X	   EPS180text, null_scale, EPS180graphics, EPSONmove, EPSONvector,
X	   EPSONlinetype, EPSONput_text, EPSON_text_angle,
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef EPS60
X    ,{"epson_60dpi", "Epson-style 60-dot per inch printers",
X	   EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
X	   EPSONVTIC, EPSONHTIC, options_null, EPSONinit, EPSONreset,
X	   EPS60text, null_scale, EPS60graphics, EPSONmove, EPSONvector,
X	   EPSONlinetype, EPSONput_text, EPSON_text_angle,
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef EPSONP
X    ,{"epson_lx800", "Epson LX-800, Star NL-10, NX-1000, PROPRINTER ...",
X	   EPSONXMAX, EPSONYMAX, EPSONVCHAR, EPSONHCHAR, 
X	   EPSONVTIC, EPSONHTIC, options_null, EPSONinit, EPSONreset, 
X	   EPSONtext, null_scale, EPSONgraphics, EPSONmove, EPSONvector, 
X	   EPSONlinetype, EPSONput_text, EPSON_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef EXCL
X    ,{"excl", "Talaris EXCL Laser printer (also Talaris 1590 and others)",
X	   EXCL_XMAX,EXCL_YMAX, EXCL_VCHAR, EXCL_HCHAR, 
X	   EXCL_VTIC, EXCL_HTIC, options_null, EXCL_init,EXCL_reset, 
X	   EXCL_text, null_scale, EXCL_graphics, EXCL_move, EXCL_vector,
X	   EXCL_linetype,EXCL_put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X
X#ifdef FIG
X    ,{"fig", "FIG 2.1 graphics language: SunView or X graphics editor",
X	   FIG_XMAX, FIG_YMAX, FIG_VCHAR, FIG_HCHAR, 
X	   FIG_VTIC, FIG_HTIC, FIG_options, FIG_init, FIG_reset, 
X	   FIG_text, null_scale, FIG_graphics, FIG_move, FIG_vector, 
X	   FIG_linetype, FIG_put_text, FIG_text_angle, 
X	   FIG_justify_text, line_and_point, FIG_arrow}
X    ,{"bfig", "FIG 2.1 graphics lang: SunView or X graphics editor. Large Graph",
X	   BFIG_XMAX, BFIG_YMAX, BFIG_VCHAR, BFIG_HCHAR, 
X	   BFIG_VTIC, BFIG_HTIC, FIG_options, FIG_init, FIG_reset, 
X	   FIG_text, null_scale, FIG_graphics, FIG_move, BFIG_vector, 
X	   FIG_linetype, BFIG_put_text, FIG_text_angle, 
X	   FIG_justify_text, line_and_point, BFIG_arrow}
X#endif
X
X#ifdef GPIC
X    ,{"gpic", "GPIC -- Produce graphs in groff using the gpic preprocessor",
X	   GPIC_XMAX, GPIC_YMAX, GPIC_VCHAR, GPIC_HCHAR, 
X	   GPIC_VTIC, GPIC_HTIC, GPIC_options, GPIC_init, GPIC_reset, 
X	   GPIC_text, GPIC_scale, GPIC_graphics, GPIC_move, GPIC_vector, 
X	   GPIC_linetype, GPIC_put_text, GPIC_text_angle, 
X	   GPIC_justify_text, line_and_point, GPIC_arrow}
X#endif
X
X#ifdef GRASS
X    ,{"grass", "GRASS Graphics Monitor",
X           GRASS_XMAX, GRASS_YMAX, GRASS_VCHAR, GRASS_HCHAR,
X           GRASS_VTIC, GRASS_HTIC, GRASS_options, GRASS_init, GRASS_reset,
X           GRASS_text, null_scale, GRASS_graphics, GRASS_move, GRASS_vector,
X           GRASS_linetype, GRASS_put_text, GRASS_text_angle,
X           GRASS_justify_text, GRASS_point, GRASS_arrow}
X#endif
X
X#ifdef HP26
X    ,{"hp2623A", "HP2623A and maybe others",
X	   HP26_XMAX, HP26_YMAX, HP26_VCHAR, HP26_HCHAR,
X	   HP26_VTIC, HP26_HTIC, options_null, HP26_init, HP26_reset,
X	   HP26_text, null_scale, HP26_graphics, HP26_move, HP26_vector,
X	   HP26_linetype, HP26_put_text, HP26_text_angle, 
X	   null_justify_text, HP26_line_and_point, do_arrow}
X#endif
X
X#ifdef HP2648
X    ,{"hp2648", "HP2648 and HP2647",
X	   HP2648XMAX, HP2648YMAX, HP2648VCHAR, HP2648HCHAR, 
X	   HP2648VTIC, HP2648HTIC, options_null, HP2648init, HP2648reset, 
X	   HP2648text, null_scale, HP2648graphics, HP2648move, HP2648vector, 
X	   HP2648linetype, HP2648put_text, HP2648_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef HP75
X    ,{"hp7580B", "HP7580, and probably other HPs (4 pens)",
X	   HPGL_XMAX, HPGL_YMAX, HPGL_VCHAR, HPGL_HCHAR,
X	   HPGL_VTIC, HPGL_HTIC, options_null, HPGL_init, HPGL_reset,
X	   HPGL_text, null_scale, HPGL_graphics, HPGL_move, HPGL_vector,
X	   HP75_linetype, HPGL_put_text, HPGL_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef HP500C
X      ,{"hp500c", "HP DeskJet 500c, [75 100 150 300] [rle tiff]",
X       HP500C_75PPI_XMAX, HP500C_75PPI_YMAX, HP500C_75PPI_VCHAR,
X       HP500C_75PPI_HCHAR, HP500C_75PPI_VTIC, HP500C_75PPI_HTIC, HP500Coptions,
X       HP500Cinit, HP500Creset, HP500Ctext, null_scale,
X       HP500Cgraphics, HP500Cmove, HP500Cvector, HP500Clinetype,
X       HP500Cput_text, HP500Ctext_angle, null_justify_text, do_point,
X       do_arrow}
X#endif
X
X#ifdef HPGL
X    ,{"hpgl", "HP7475 and (hopefully) lots of others (6 pens)",
X	   HPGL_XMAX, HPGL_YMAX, HPGL_VCHAR, HPGL_HCHAR,
X	   HPGL_VTIC, HPGL_HTIC, options_null, HPGL_init, HPGL_reset,
X	   HPGL_text, null_scale, HPGL_graphics, HPGL_move, HPGL_vector,
X	   HPGL_linetype, HPGL_put_text, HPGL_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef HPLJII
X    ,{"hpljii", "HP Laserjet series II, [75 100 150 300]",
X       HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
X       HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJIIoptions,
X       HPLJIIinit, HPLJIIreset, HPLJIItext, null_scale,
X       HPLJIIgraphics, HPLJIImove, HPLJIIvector, HPLJIIlinetype,
X       HPLJIIput_text, HPLJIItext_angle, null_justify_text, line_and_point,
X       do_arrow}
X    ,{"hpdj", "HP DeskJet 500, [75 100 150 300]",
X       HPLJII_75PPI_XMAX, HPLJII_75PPI_YMAX, HPLJII_75PPI_VCHAR,
X       HPLJII_75PPI_HCHAR, HPLJII_75PPI_VTIC, HPLJII_75PPI_HTIC, HPLJIIoptions,
X       HPLJIIinit, HPLJIIreset, HPDJtext, null_scale,
X       HPDJgraphics, HPLJIImove, HPLJIIvector, HPLJIIlinetype,
X       HPDJput_text, HPDJtext_angle, null_justify_text, line_and_point,
X       do_arrow}
X#endif
X
X#ifdef HPPJ
X    ,{"hppj", "HP PaintJet and HP3630 [FNT5X9 FNT9X17 FNT13X25]",
X       HPPJ_XMAX, HPPJ_YMAX,
X       HPPJ_9x17_VCHAR, HPPJ_9x17_HCHAR, HPPJ_9x17_VTIC, HPPJ_9x17_HTIC,
X       HPPJoptions, HPPJinit, HPPJreset, HPPJtext, null_scale, HPPJgraphics,
X       HPPJmove, HPPJvector, HPPJlinetype, HPPJput_text, HPPJtext_angle,
X       null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef IMAGEN
X    ,{"imagen", "Imagen laser printer",
X	   IMAGEN_XMAX, IMAGEN_YMAX, IMAGEN_VCHAR, IMAGEN_HCHAR, 
X	   IMAGEN_VTIC, IMAGEN_HTIC, options_null, IMAGEN_init, IMAGEN_reset, 
X	   IMAGEN_text, null_scale, IMAGEN_graphics, IMAGEN_move, 
X	   IMAGEN_vector, IMAGEN_linetype, IMAGEN_put_text, IMAGEN_text_angle,
X	   IMAGEN_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef IRIS4D
X    ,{"iris4d", "Silicon Graphics IRIS 4D Series Computer",
X	   IRIS4D_XMAX, IRIS4D_YMAX, IRIS4D_VCHAR, IRIS4D_HCHAR, 
X	   IRIS4D_VTIC, IRIS4D_HTIC, IRIS4D_options, IRIS4D_init, IRIS4D_reset, 
X	   IRIS4D_text, null_scale, IRIS4D_graphics, IRIS4D_move, IRIS4D_vector,
X	   IRIS4D_linetype, IRIS4D_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef KERMIT
X    ,{"kc_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - color",
X	   TEK40XMAX,TEK40YMAX,TEK40VCHAR, KTEK40HCHAR, 
X	   TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset, 
X	   KTEK40Ctext, null_scale, KTEK40graphics, TEK40move, TEK40vector, 
X	   KTEK40Clinetype, TEK40put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X    ,{"km_tek40xx", "MS-DOS Kermit Tek4010 terminal emulator - monochrome",
X	   TEK40XMAX,TEK40YMAX,TEK40VCHAR, KTEK40HCHAR, 
X	   TEK40VTIC, TEK40HTIC, options_null, TEK40init, KTEK40reset, 
X	   TEK40text, null_scale, KTEK40graphics, TEK40move, TEK40vector, 
X	   KTEK40Mlinetype, TEK40put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef LATEX
X    ,{"latex", "LaTeX picture environment",
X	   LATEX_XMAX, LATEX_YMAX, LATEX_VCHAR, LATEX_HCHAR, 
X	   LATEX_VTIC, LATEX_HTIC, LATEX_options, LATEX_init, LATEX_reset, 
X	   LATEX_text, LATEX_scale, LATEX_graphics, LATEX_move, LATEX_vector, 
X	   LATEX_linetype, LATEX_put_text, LATEX_text_angle, 
X	   LATEX_justify_text, LATEX_point, LATEX_arrow}
X#endif
X
X#ifdef LN03P
X     ,{"ln03", "LN03-plus laser printer in tektronix (EGM) mode",
X	LN03PXMAX, LN03PYMAX, LN03PVCHAR, LN03PHCHAR,
X	LN03PVTIC, LN03PHTIC, options_null, LN03Pinit, LN03Preset,
X	LN03Ptext, null_scale, TEK40graphics, LN03Pmove, LN03Pvector,
X	LN03Plinetype, LN03Pput_text, null_text_angle,
X	null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef MF
X    ,{"mf", "Metafont plotting standard",
X	   MF_XMAX, MF_YMAX, MF_VCHAR, MF_HCHAR, 
X       MF_VTIC, MF_HTIC, options_null, MF_init, MF_reset, 
X	   MF_text, MF_scale, MF_graphics, MF_move, MF_vector, 
X	   MF_linetype, MF_put_text, MF_text_angle, 
X	   MF_justify_text, line_and_point, MF_arrow}
X#endif
X
X#ifdef MGR
X    ,{"mgr", "Mgr window system",
X	/* dimensions nominal, replaced during MGR_graphics call */
X	   MGR_XMAX, MGR_YMAX, MGR_VCHAR, MGR_HCHAR, 
X	   MGR_VTIC, MGR_HTIC, options_null, MGR_init, MGR_reset, 
X	   MGR_text, null_scale, MGR_graphics, MGR_move, MGR_vector,
X	   MGR_linetype, MGR_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef MIF
X    ,{"mif", "Frame maker MIF 3.00 format",
X      	MIF_XMAX, MIF_YMAX, MIF_VCHAR, MIF_HCHAR, 
X 	    MIF_VTIC, MIF_HTIC, MIF_options, MIF_init, MIF_reset, 
X	    MIF_text, null_scale, MIF_graphics, MIF_move, MIF_vector, 
X	    MIF_linetype, MIF_put_text, MIF_text_angle, 
X	    MIF_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef NEC
X    ,{"nec_cp6", "NEC printer CP6, Epson LQ-800 [monocrome color draft]",
X	   NECXMAX, NECYMAX, NECVCHAR, NECHCHAR, 
X	   NECVTIC, NECHTIC, NECoptions, NECinit, NECreset, 
X	   NECtext, null_scale, NECgraphics, NECmove, NECvector, 
X	   NEClinetype, NECput_text, NEC_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef NEXT
X    ,{"next", "NeXTstep window system",
X	   NEXT_XMAX, NEXT_YMAX, NEXT_VCHAR, NEXT_HCHAR, 
X	   NEXT_VTIC, NEXT_HTIC, NEXT_options, NEXT_init, NEXT_reset, 
X	   NEXT_text, do_scale, NEXT_graphics, NEXT_move, NEXT_vector, 
X	   NEXT_linetype, NEXT_put_text, NEXT_text_angle, 
X	   NEXT_justify_text, NEXT_point, do_arrow}
X#endif /* The PostScript driver with NXImage displaying the PostScript on screen */
X
X#ifdef OKIDATA
X    ,{"okidata", "OKIDATA 320/321 Standard",
X	   EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
X	   EPSONVTIC, EPSONHTIC, options_null, EPSONinit, EPSONreset,
X	   OKIDATAtext, null_scale, EPS60graphics, EPSONmove, EPSONvector,
X	   EPSONlinetype, EPSONput_text, EPSON_text_angle,
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef OS2PM
X    ,{"pm", "OS/2 Presentation Manager",
X	   PM_XMAX, PM_YMAX, PM_VCHAR, PM_HCHAR, 
X	   PM_VTIC, PM_HTIC, PM_args, PM_init, PM_reset, 
X	   PM_text, null_scale, PM_graphics, PM_move, PM_vector,
X	   PM_linetype, PM_put_text, PM_text_angle, 
X	   PM_justify_text, PM_point, do_arrow}
X#endif
X
X#ifdef PBM
X    ,{"pbm", "Portable bitmap [small medium large] [monochrome gray color]",
X       PBM_XMAX, PBM_YMAX, PBM_VCHAR,
X       PBM_HCHAR, PBM_VTIC, PBM_HTIC, PBMoptions,
X       PBMinit, PBMreset, PBMtext, null_scale,
X       PBMgraphics, PBMmove, PBMvector, PBMlinetype,
X       PBMput_text, PBMtext_angle, null_justify_text, PBMpoint,
X       do_arrow}
X#endif
X
X#ifdef PCL
X ,{"pcl5", "HP LaserJet III [mode] [font] [point]",
X   PCL_XMAX, PCL_YMAX, HPGL2_VCHAR, HPGL2_HCHAR,
X   PCL_VTIC, PCL_HTIC, PCL_options, PCL_init, PCL_reset,
X   PCL_text, null_scale, PCL_graphics, HPGL2_move, HPGL2_vector,
X   HPGL2_linetype, HPGL2_put_text, HPGL2_text_angle,
X   HPGL2_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef POSTSCRIPT
X    ,{"postscript", "PostScript graphics language [mode \042fontname\042 font_size]",
X	   PS_XMAX, PS_YMAX, PS_VCHAR, PS_HCHAR, 
X	   PS_VTIC, PS_HTIC, PS_options, PS_init, PS_reset, 
X	   PS_text, null_scale, PS_graphics, PS_move, PS_vector, 
X	   PS_linetype, PS_put_text, PS_text_angle, 
X	   PS_justify_text, PS_point, do_arrow}
X#endif
X
X#ifdef PRESCRIBE
X    ,{"prescribe", "Prescribe - for the Kyocera Laser Printer",
X	PRE_XMAX, PRE_YMAX, PRE_VCHAR, PRE_HCHAR, 
X	PRE_VTIC, PRE_HTIC, options_null, PRE_init, PRE_reset, 
X	PRE_text, null_scale, PRE_graphics, PRE_move, PRE_vector, 
X	PRE_linetype, PRE_put_text, null_text_angle, 
X	PRE_justify_text, line_and_point, do_arrow}
X    ,{"kyo", "Kyocera Laser Printer with Courier font",
X	PRE_XMAX, PRE_YMAX, KYO_VCHAR, KYO_HCHAR, 
X	PRE_VTIC, PRE_HTIC, options_null, KYO_init, PRE_reset, 
X	PRE_text, null_scale, PRE_graphics, PRE_move, PRE_vector, 
X	PRE_linetype, PRE_put_text, null_text_angle, 
X	PRE_justify_text, line_and_point, do_arrow}
X#endif /* PRESCRIBE */
X
X#ifdef PSLATEX
X    ,{"pslatex", "LaTeX picture environment with PostScript \\specials",
X	PS_XMAX, PS_YMAX, PSLATEX_VCHAR, PSLATEX_HCHAR,
X	PS_VTIC, PS_HTIC, PSLATEX_options, PSLATEX_init, PSLATEX_reset,
X	PSLATEX_text, PSLATEX_scale, PSLATEX_graphics, PS_move, PS_vector,
X	PS_linetype, PSLATEX_put_text, PSLATEX_text_angle,
X	PSLATEX_justify_text, PS_point, do_arrow}
X#endif
X
X#ifdef	PSTRICKS
X    ,{"pstricks", "LaTeX picture environment with PSTricks macros",
X	   PSTRICKS_XMAX, PSTRICKS_YMAX, PSTRICKS_VCHAR, PSTRICKS_HCHAR, 
X	   PSTRICKS_VTIC, PSTRICKS_HTIC, options_null, PSTRICKS_init, PSTRICKS_reset, 
X	   PSTRICKS_text, PSTRICKS_scale, PSTRICKS_graphics, PSTRICKS_move, PSTRICKS_vector, 
X	   PSTRICKS_linetype, PSTRICKS_put_text, PSTRICKS_text_angle, 
X	   PSTRICKS_justify_text, PSTRICKS_point, PSTRICKS_arrow}
X#endif
X    
X#ifdef QMS
X    ,{"qms", "QMS/QUIC Laser printer (also Talaris 1200 and others)",
X	   QMS_XMAX,QMS_YMAX, QMS_VCHAR, QMS_HCHAR, 
X	   QMS_VTIC, QMS_HTIC, options_null, QMS_init,QMS_reset, 
X	   QMS_text, null_scale, QMS_graphics, QMS_move, QMS_vector,
X	   QMS_linetype,QMS_put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef REGIS
X    ,{"regis", "REGIS graphics language",
X	   REGISXMAX, REGISYMAX, REGISVCHAR, REGISHCHAR, 
X	   REGISVTIC, REGISHTIC, REGISoptions, REGISinit, REGISreset, 
X	   REGIStext, null_scale, REGISgraphics, REGISmove, REGISvector,
X	   REGISlinetype, REGISput_text, REGIStext_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef RGIP
X    ,{"rgip", "RGIP metafile (Uniplex). Option: fontsize (1-8)",
X	   RGIP_XMAX, RGIP_YMAX, RGIP_VCHAR, RGIP_HCHAR,
X	   RGIP_VTIC, RGIP_HTIC, RGIP_options, RGIP_init, RGIP_reset,
X	   RGIP_text, null_scale, RGIP_graphics, RGIP_move,
X	   RGIP_vector, RGIP_linetype, RGIP_put_text, RGIP_text_angle,
X	   RGIP_justify_text, RGIP_do_point, do_arrow}
X    ,{"uniplex", "RGIP metafile (Uniplex). Option: fontsize (1-8)",
X	   RGIP_XMAX, RGIP_YMAX, RGIP_VCHAR, RGIP_HCHAR,
X	   RGIP_VTIC, RGIP_HTIC, RGIP_options, RGIP_init, RGIP_reset,
X	   RGIP_text, null_scale, RGIP_graphics, RGIP_move,
X	   RGIP_vector, RGIP_linetype, RGIP_put_text, RGIP_text_angle,
X	   RGIP_justify_text, RGIP_do_point, do_arrow}
X#endif
X
X#ifdef SELANAR
X    ,{"selanar", "Selanar",
X	   TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR, 
X	   TEK40VTIC, TEK40HTIC, options_null, SEL_init, SEL_reset, 
X	   SEL_text, null_scale, SEL_graphics, TEK40move, TEK40vector, 
X	   TEK40linetype, TEK40put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef STARC
X    ,{"starc", "Star Color Printer",
X	   STARCXMAX, STARCYMAX, STARCVCHAR, STARCHCHAR, 
X	   STARCVTIC, STARCHTIC, options_null, STARCinit, STARCreset, 
X	   STARCtext, null_scale, STARCgraphics, STARCmove, STARCvector, 
X	   STARClinetype, STARCput_text, STARC_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef SUN
X    ,{"sun", "SunView window system",
X	   SUN_XMAX, SUN_YMAX, SUN_VCHAR, SUN_HCHAR, 
X	   SUN_VTIC, SUN_HTIC, options_null, SUN_init, SUN_reset, 
X	   SUN_text, null_scale, SUN_graphics, SUN_move, SUN_vector,
X	   SUN_linetype, SUN_put_text, null_text_angle, 
X	   SUN_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef VWS
X    ,{"VWS", "VAX Windowing System (UIS)",
X           VWS_XMAX, VWS_YMAX, VWS_VCHAR, VWS_HCHAR,
X           VWS_VTIC, VWS_HTIC, options_null, VWS_init, VWS_reset,
X           VWS_text, null_scale, VWS_graphics, VWS_move, VWS_vector,
X           VWS_linetype, VWS_put_text, VWS_text_angle,
X           VWS_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef TANDY60
X    ,{"tandy_60dpi", "Tandy DMP-130 series 60-dot per inch graphics",
X	   EPS60XMAX, EPS60YMAX, EPSONVCHAR, EPSONHCHAR,
X	   EPSONVTIC, EPSONHTIC, options_null, EPSONinit, EPSONreset,
X	   TANDY60text, null_scale, EPS60graphics, EPSONmove, EPSONvector,
X	   EPSONlinetype, EPSONput_text, EPSON_text_angle,
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef T410X
X    ,{"tek410x", "Tektronix 4106, 4107, 4109 and 420X terminals",
X	   T410XXMAX, T410XYMAX, T410XVCHAR, T410XHCHAR, 
X	   T410XVTIC, T410XHTIC, options_null, T410X_init, T410X_reset, 
X	   T410X_text, null_scale, T410X_graphics, T410X_move, T410X_vector, 
X	   T410X_linetype, T410X_put_text, T410X_text_angle, 
X	   null_justify_text, T410X_point, do_arrow}
X#endif
X
X#ifdef TEK
X    ,{"tek40xx", "Tektronix 4010 and others; most TEK emulators",
X	   TEK40XMAX, TEK40YMAX, TEK40VCHAR, TEK40HCHAR, 
X	   TEK40VTIC, TEK40HTIC, options_null, TEK40init, TEK40reset, 
X	   TEK40text, null_scale, TEK40graphics, TEK40move, TEK40vector, 
X	   TEK40linetype, TEK40put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef TEXDRAW
X    ,{"texdraw", "LaTeX texdraw environment",
X	   TEXDRAW_XMAX, TEXDRAW_YMAX, TEXDRAW_VCHAR, TEXDRAW_HCHAR,
X	TEXDRAW_VTIC, TEXDRAW_HTIC, options_null, TEXDRAW_init, TEXDRAW_reset,
X	TEXDRAW_text, TEXDRAW_scale, TEXDRAW_graphics, TEXDRAW_move, TEXDRAW_vector,
X	TEXDRAW_linetype, TEXDRAW_put_text, TEXDRAW_text_angle,
X	TEXDRAW_justify_text, TEXDRAW_point, TEXDRAW_arrow}
X#endif
X  
X#ifdef TGIF
X    ,{"tgif", "TGIF X-Window draw tool (file version 10)",
X	   TGIF_XMAX, TGIF_YMAX, TGIF_VCHAR1, TGIF_HCHAR1, 
X	   TGIF_VTIC, TGIF_HTIC, options_null, TGIF_init, TGIF_reset, 
X	   TGIF_text, null_scale, TGIF_graphics, TGIF_move, TGIF_vector, 
X	   TGIF_linetype, TGIF_put_text, TGIF_text_angle, 
X	   TGIF_justify_text, line_and_point, TGIF_arrow}
X#endif
X
X#ifdef TPIC
X    ,{"tpic", "TPIC -- LaTeX picture environment with tpic \\specials",
X	   TPIC_XMAX, TPIC_YMAX, TPIC_VCHAR, TPIC_HCHAR, 
X	   TPIC_VTIC, TPIC_HTIC, TPIC_options, TPIC_init, TPIC_reset, 
X	   TPIC_text, TPIC_scale, TPIC_graphics, TPIC_move, TPIC_vector, 
X	   TPIC_linetype, TPIC_put_text, TPIC_text_angle, 
X	   TPIC_justify_text, TPIC_point, TPIC_arrow}
X#endif
X
X#ifdef UNIXPLOT
X#ifdef GNUGRAPH
X    ,{"unixplot", "GNU plot(1) format [\042fontname\042 font_size]",
X	   UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR,
X	   UP_VTIC, UP_HTIC, UP_options, UP_init, UP_reset,
X	   UP_text, null_scale, UP_graphics, UP_move, UP_vector,
X	   UP_linetype, UP_put_text, UP_text_angle,
X	   UP_justify_text, line_and_point, do_arrow}
X#else
X    ,{"unixplot", "Unix plotting standard (see plot(1))",
X	   UP_XMAX, UP_YMAX, UP_VCHAR, UP_HCHAR, 
X	   UP_VTIC, UP_HTIC, options_null, UP_init, UP_reset, 
X	   UP_text, null_scale, UP_graphics, UP_move, UP_vector, 
X	   UP_linetype, UP_put_text, null_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif /* GNUGRAPH */
X#endif
X	
X#ifdef UNIXPC
X    ,{"unixpc", "AT&T 3b1 or AT&T 7300 Unix PC",
X	   uPC_XMAX, uPC_YMAX, uPC_VCHAR, uPC_HCHAR, 
X	   uPC_VTIC, uPC_HTIC, options_null, uPC_init, uPC_reset, 
X	   uPC_text, null_scale, uPC_graphics, uPC_move, uPC_vector,
X	   uPC_linetype, uPC_put_text, uPC_text_angle, 
X	   null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef EMXVGA
X#ifdef EMXVESA
X    ,{"vesa", "IBM PC/Clone with VESA SVGA graphics board [vesa mode]",
X	   EMXVGA_XMAX, EMXVGA_YMAX, EMXVGA_VCHAR, EMXVGA_HCHAR,
X	   EMXVGA_VTIC, EMXVGA_HTIC, EMXVESA_options, EMXVESA_init, EMXVESA_reset,
X	   EMXVESA_text, null_scale, EMXVESA_graphics, EMXVGA_move, EMXVGA_vector,
X	   EMXVGA_linetype, EMXVGA_put_text, EMXVGA_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X    ,{"vgal", "IBM PC/Clone with VGA graphics board",
X	   EMXVGA_XMAX, EMXVGA_YMAX, EMXVGA_VCHAR, EMXVGA_HCHAR,
X	   EMXVGA_VTIC, EMXVGA_HTIC, options_null, EMXVGA_init, EMXVGA_reset,
X	   EMXVGA_text, null_scale, EMXVGA_graphics, EMXVGA_move, EMXVGA_vector,
X	   EMXVGA_linetype, EMXVGA_put_text, EMXVGA_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef V384
X    ,{"vx384", "Vectrix 384 and Tandy color printer",
X	   V384_XMAX, V384_YMAX, V384_VCHAR, V384_HCHAR, 
X	   V384_VTIC, V384_HTIC, options_null, V384_init, V384_reset, 
X	   V384_text, null_scale, V384_graphics, V384_move, V384_vector, 
X	   V384_linetype, V384_put_text, null_text_angle, 
X	   null_justify_text, do_point, do_arrow}
X#endif
X
X#ifdef VTTEK
X    ,{"vttek", "VT-like tek40xx terminal emulator",
X       TEK40XMAX,TEK40YMAX,TEK40VCHAR, TEK40HCHAR,
X       TEK40VTIC, TEK40HTIC, options_null, VTTEK40init, VTTEK40reset,
X       TEK40text, null_scale, TEK40graphics, TEK40move, TEK40vector,
X       VTTEK40linetype, VTTEK40put_text, null_text_angle,
X       null_justify_text, line_and_point, do_arrow}
X#endif
X
X#ifdef _Windows
X    ,{"windows", "Microsoft Windows",
X	   WIN_XMAX, WIN_YMAX, WIN_VCHAR, WIN_HCHAR, 
X	   WIN_VTIC, WIN_HTIC, WIN_options, WIN_init, WIN_reset, 
X	   WIN_text, WIN_scale, WIN_graphics, WIN_move, WIN_vector,
X	   WIN_linetype, WIN_put_text, WIN_text_angle, 
X	   WIN_justify_text, WIN_point, do_arrow}
X#endif
X
X#ifdef X11
X    ,{"x11", "X11 Window System",
X	   X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR, 
X	   X11_VTIC, X11_HTIC, options_null, X11_init, X11_reset, 
X	   X11_text, null_scale, X11_graphics, X11_move, X11_vector, 
X	   X11_linetype, X11_put_text, null_text_angle, 
X	   X11_justify_text, X11_point, do_arrow}
X    ,{"X11", "X11 Window System (identical to x11)",
X	   X11_XMAX, X11_YMAX, X11_VCHAR, X11_HCHAR, 
X	   X11_VTIC, X11_HTIC, options_null, X11_init, X11_reset, 
X	   X11_text, null_scale, X11_graphics, X11_move, X11_vector, 
X	   X11_linetype, X11_put_text, null_text_angle, 
X	   X11_justify_text, X11_point, do_arrow}
X   ,{"xlib", "X11 Window System (gnulib_x11 dump)",
X	   Xlib_XMAX, Xlib_YMAX, Xlib_VCHAR, Xlib_HCHAR, 
X	   Xlib_VTIC, Xlib_HTIC, options_null, Xlib_init, Xlib_reset, 
X	   Xlib_text, null_scale, Xlib_graphics, Xlib_move, Xlib_vector, 
X	   Xlib_linetype, Xlib_put_text, null_text_angle, 
X	   Xlib_justify_text, line_and_point, do_arrow}
X#endif
X};
X
X#define TERMCOUNT (sizeof(term_tbl)/sizeof(struct termentry))
X
X
Xlist_terms()
X{
Xregister int i;
X
X	fprintf(stderr,"\nAvailable terminal types:\n");
X	for (i = 0; i < TERMCOUNT; i++)
X		fprintf(stderr,"  %15s  %s\n",
X			   term_tbl[i].name, term_tbl[i].description);
X	(void) putc('\n',stderr);
X}
X
X
X/* set_term: get terminal number from name on command line */
X/* will change 'term' variable if successful */
Xint						/* term number */
Xset_term(c_token)
Xint c_token;
X{
X    register int t;
X    char *input_name;
X
X    if (!token[c_token].is_token)
X	 int_error("terminal name expected",c_token);
X    t = -1;
X    input_name = input_line + token[c_token].start_index;
X    t = change_term(input_name, token[c_token].length);
X    if (t == -1)
X	 int_error("unknown terminal type; type just 'set terminal' for a list",
X			 c_token);
X    if (t == -2)
X	 int_error("ambiguous terminal name; type just 'set terminal' for a list",
X			 c_token);
X
X    /* otherwise the type was changed */
X
X    return(t);
X}
X
X/* change_term: get terminal number from name and set terminal type */
X/* returns -1 if unknown, -2 if ambiguous, >=0 is terminal number */
Xint
Xchange_term(name, length)
X	char *name;
X	int length;
X{
X    int i, t = -1;
X
X    for (i = 0; i < TERMCOUNT; i++) {
X	   if (!strncmp(name,term_tbl[i].name,length)) {
X		  if (t != -1)
X		    return(-2);	/* ambiguous */
X		  t = i;
X	   }
X    }
X
X    if (t == -1)			/* unknown */
X	 return(t);
X
X    /* Success: set terminal type now */
X
X    term = t;
X    term_init = FALSE;
X    name = term_tbl[term].name;
X
X    /* Special handling for unixplot term type */
X    if (!strncmp("unixplot",name,8)) {
X	   UP_redirect (2);  /* Redirect actual stdout for unixplots */
X    } else if (unixplot) {
X	   UP_redirect (3);  /* Put stdout back together again. */
X    }
X
X    if (interactive)
X	 fprintf(stderr, "Terminal type set to '%s'\n", name);
X
X    return(t);
X}
X
X/*
X   Routine to detect what terminal is being used (or do anything else
X   that would be nice).  One anticipated (or allowed for) side effect
X   is that the global ``term'' may be set. 
X   The environment variable GNUTERM is checked first; if that does
X   not exist, then the terminal hardware is checked, if possible, 
X   and finally, we can check $TERM for some kinds of terminals.
X   A default can be set with -DDEFAULTTERM=myterm in the Makefile
X   or #define DEFAULTTERM myterm in term.h
X*/
X/* thanks to osupyr!alden (Dave Alden) for the original GNUTERM code */
Xinit_terminal()
X{
X    int t;
X#ifdef DEFAULTTERM
X	char *term_name = DEFAULTTERM;
X#else
X    char *term_name = NULL;
X#endif /* DEFAULTTERM */
X#if (defined(__TURBOC__) && defined(MSDOS) && !defined(_Windows)) || defined(NEXT) || defined(SUN) || defined(X11)
X    char *term = NULL;		/* from TERM environment var */
X#endif
X#ifdef X11
X    char *display = NULL;
X#endif
X    char *gnuterm = NULL;
X
X    /* GNUTERM environment variable is primary */
X    gnuterm = getenv("GNUTERM");
X    if (gnuterm != (char *)NULL) {
X	 term_name = gnuterm;
X#ifndef _Windows
X#if defined(__TURBOC__) && defined(MSDOS)
X         get_path();   /* So *_init() can find the BGI driver */
X# endif
X#endif
X    }
X    else {
X#if defined(__TURBOC__) && defined(MSDOS) && !defined(_Windows)
X	   term_name = turboc_init();
X	   term = (char *)NULL; /* shut up turbo C */
X#endif
X	   
X#ifdef __ZTC__
X	  term_name = ztc_init();
X#endif
X
X#ifdef vms
X	   term_name = vms_init();
X#endif
X
X#ifdef NEXT
X	term = getenv("TERM");
X	if (term_name == (char *)NULL
X		&& term != (char *)NULL && strcmp(term,"next") == 0)
X	      term_name = "next";
X#endif /* NeXT */
X	   
X#ifdef SUN
X	   term = getenv("TERM");	/* try $TERM */
X	   if (term_name == (char *)NULL
X		  && term != (char *)NULL && strcmp(term, "sun") == 0)
X		term_name = "sun";
X#endif /* sun */
X
X#ifdef _Windows
X		term_name = "win";
X#endif /* _Windows */
X
X#ifdef GPR
X   if (gpr_isa_pad()) term_name = "gpr";       /* find out whether stdout is a DM pad. See term/gpr.trm */
X#else
X#ifdef APOLLO
X   if (apollo_isa_pad()) term_name = "apollo"; /* find out whether stdout is a DM pad. See term/apollo.trm */
X#endif /* APOLLO */
X#endif /* GPR    */
X
X#ifdef X11
X	   term = getenv("TERM");	/* try $TERM */
X	   if (term_name == (char *)NULL
X		  && term != (char *)NULL && strcmp(term, "xterm") == 0)
X		term_name = "x11";
X	   display = getenv("DISPLAY");
X	   if (term_name == (char *)NULL && display != (char *)NULL)
X		term_name = "x11";
X	   if (X11_Display)
X		term_name = "x11";
X#endif /* x11 */
X
X#ifdef AMIGASCREEN
X	   term_name = "amiga";
X#endif
X
X#ifdef ATARI
X	   term_name = "atari";
X#endif
X
X#ifdef UNIXPC
X           if (iswind() == 0) {
X              term_name = "unixpc";
X           }
X#endif /* unixpc */
X
X#ifdef CGI
X	   if (getenv("CGIDISP") || getenv("CGIPRNT"))
X	     term_name = "cgi";
X#endif /*CGI */
X
X#if defined(MSDOS) && defined(__EMX__)
X#ifdef EMXVESA
X	   term_name = "vesa";
X#else
X	   term_name = "vgal";
X#endif
X#endif
X
X#ifdef DJGPP
X		term_name = "svga";
X#endif
X
X#ifdef GRASS
X        term_name = "grass";
X#endif
X
X#ifdef OS2
X           term_name = "pm" ;
X            /* EMX compiler has getcwd that can return drive */
X           if( PM_path[0]=='\0' ) _getcwd2( PM_path, 256 ) ;
X#endif /*OS2 */           
X    }
X
X    /* We have a name, try to set term type */
X    if (term_name != NULL && *term_name != '\0') {
X	   t = change_term(term_name, (int)strlen(term_name));
X	   if (t == -1)
X		fprintf(stderr, "Unknown terminal name '%s'\n", term_name);
X	   else if (t == -2)
X		fprintf(stderr, "Ambiguous terminal name '%s'\n", term_name);
X	   else				/* successful */
X		;
X    }
X}
X
X
X#ifndef _Windows
X#if defined (__TURBOC__) && defined (MSDOS)
Xchar *
Xturboc_init()
X{
X  int g_driver,g_mode;
X  char far *c1,*c2;
X  char *term_name = NULL;
X  struct text_info tinfo;       /* So we can restore starting text mode. */
X
X/* Some of this code including BGI drivers is copyright Borland Intl. */
X	g_driver=DETECT;
X	      get_path();
X	gettextinfo(&tinfo);
X        initgraph(&g_driver,&g_mode,path);
X        c1=getdrivername();
X        c2=getmodename(g_mode);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X			case 1 : term_name = "cga";
X					 break;
X			case 2 : term_name = "mcga";
X					 break;
X			case 3 : 
X			case 4 : term_name = "egalib";
X					 break;
X			case 7 : term_name = "hercules";
X					 break;
X			case 8 : term_name = "att";
X					 break;
X			case 9 : term_name = "vgalib";
X					 break;
X            }
X        closegraph();
X        textmode(tinfo.currmode);
X	clrscr();
X	fprintf(stderr,"\tTC Graphics, driver %s  mode %s\n",c1,c2);
X  return(term_name);
X}
X# endif /* __TURBOC__ */
X#endif
X
X#if defined(__ZTC__)
Xchar *
Xztc_init()
X{
X  int g_mode;
X  char *term_name = NULL;
X
X	g_mode = fg_init();
X
X		  switch (g_mode){
X			case FG_NULL	  :  fprintf(stderr,"Graphics card not detected or not supported.\n");
X								 exit(1);
X			case FG_HERCFULL  :  term_name = "hercules";
X								 break;
X			case FG_EGAMONO   :  term_name = "egamono";
X								 break;
X			case FG_EGAECD	  :  term_name = "egalib";
X								 break;
X			case FG_VGA11	  :  term_name = "vgamono";
X								 break;
X			case FG_VGA12	  :  term_name = "vgalib";
X								 break;
X			case FG_VESA6A	  :  term_name = "svgalib";
X								 break;
X			case FG_VESA5	  :  term_name = "ssvgalib";
X								 break;
X			}
X		fg_term();
X  return(term_name);
X}
X#endif /* __ZTC__ */
X
X
X/*
X	This is always defined so we don't have to have command.c know if it
X	is there or not.
X*/
X#ifndef UNIXPLOT
XUP_redirect(caller) int caller; 
X{
X	caller = caller;	/* to stop Turbo C complaining 
X						 * about caller not being used */
X}
X#else
XUP_redirect (caller)
Xint caller;
X/*
X	Unixplot can't really write to outfile--it wants to write to stdout.
X	This is normally ok, but the original design of gnuplot gives us
X	little choice.  Originally users of unixplot had to anticipate
X	their needs and redirect all I/O to a file...  Not very gnuplot-like.
X
X	caller:  1 - called from SET OUTPUT "FOO.OUT"
X			 2 - called from SET TERM UNIXPLOT
X			 3 - called from SET TERM other
X			 4 - called from SET OUTPUT
X*/
X{
X	switch (caller) {
X	case 1:
X	/* Don't save, just replace stdout w/outfile (save was already done). */
X		if (unixplot)
X			*(stdout) = *(outfile);  /* Copy FILE structure */
X	break;
X	case 2:
X		if (!unixplot) {
X			fflush(stdout);
X			save_stdout = *(stdout);
X			*(stdout) = *(outfile);  /* Copy FILE structure */
X			unixplot = 1;
X		}
X	break;
X	case 3:
X	/* New terminal in use--put stdout back to original. */
X		/* closepl(); */  /* This is called by the term. */
X		fflush(stdout);
X		*(stdout) = save_stdout;  /* Copy FILE structure */
X		unixplot = 0;
X	break;
X	case 4:
X	/*  User really wants to go to normal output... */
X		if (unixplot) {
X			fflush(stdout);
X			*(stdout) = save_stdout;  /* Copy FILE structure */
X		}
X	break;
X	}
X}
X#endif
X
X
X/* test terminal by drawing border and text */
X/* called from command test */
Xtest_term()
X{
X	register struct termentry *t = &term_tbl[term];
X	char *str;
X	int x,y, xl,yl, i;
X	unsigned int xmax, ymax;
X	char label[MAX_ID_LEN];
X	int scaling;
X
X	if (!term_init) {
X	   (*t->init)();
X	   term_init = TRUE;
X	}
X	screen_ok = FALSE;
X	scaling = (*t->scale)(xsize, ysize);
X	xmax = (unsigned int)(t->xmax * (scaling ? 1 : xsize));
X	ymax = (unsigned int)(t->ymax * (scaling ? 1 : ysize));
X	(*t->graphics)();
X	/* border linetype */
X	(*t->linetype)(-2);
X	(*t->move)(0,0);
X	(*t->vector)(xmax-1,0);
X	(*t->vector)(xmax-1,ymax-1);
X	(*t->vector)(0,ymax-1);
X	(*t->vector)(0,0);
X	(void) (*t->justify_text)(LEFT);
X	(*t->put_text)(t->h_char*5,ymax-t->v_char*3,"Terminal Test");
X	/* axis linetype */
X	(*t->linetype)(-1);
X	(*t->move)(xmax/2,0);
X	(*t->vector)(xmax/2,ymax-1);
X	(*t->move)(0,ymax/2);
X	(*t->vector)(xmax-1,ymax/2);
X	/* test width and height of characters */
X	(*t->linetype)(-2);
X	(*t->move)(  xmax/2-t->h_char*10,ymax/2+t->v_char/2);
X	(*t->vector)(xmax/2+t->h_char*10,ymax/2+t->v_char/2);
X	(*t->vector)(xmax/2+t->h_char*10,ymax/2-t->v_char/2);
X	(*t->vector)(xmax/2-t->h_char*10,ymax/2-t->v_char/2);
X	(*t->vector)(xmax/2-t->h_char*10,ymax/2+t->v_char/2);
X	(*t->put_text)(xmax/2-t->h_char*10,ymax/2,
X		"12345678901234567890");
X	/* test justification */
X	(void) (*t->justify_text)(LEFT);
X	(*t->put_text)(xmax/2,ymax/2+t->v_char*6,"left justified");
X	str = "centre+d text";
X	if ((*t->justify_text)(CENTRE))
X		(*t->put_text)(xmax/2,
X				ymax/2+t->v_char*5,str);
X	else
X		(*t->put_text)(xmax/2-strlen(str)*t->h_char/2,
X				ymax/2+t->v_char*5,str);
X	str = "right justified";
X	if ((*t->justify_text)(RIGHT))
X		(*t->put_text)(xmax/2,
X				ymax/2+t->v_char*4,str);
X	else
X		(*t->put_text)(xmax/2-strlen(str)*t->h_char,
X				ymax/2+t->v_char*4,str);
X	/* test text angle */
X	str = "rotated ce+ntred text";
X	if ((*t->text_angle)(1)) {
X		if ((*t->justify_text)(CENTRE))
X			(*t->put_text)(t->v_char,
X				ymax/2,str);
X		else
X			(*t->put_text)(t->v_char,
X				ymax/2-strlen(str)*t->h_char/2,str);
X	}
X	else {
X	    (void) (*t->justify_text)(LEFT);
X	    (*t->put_text)(t->h_char*2,ymax/2-t->v_char*2,"Can't rotate text");
X	}
X	(void) (*t->justify_text)(LEFT);
X	(void) (*t->text_angle)(0);
X	/* test tic size */
X	(*t->move)(xmax/2+t->h_tic*2,0);
X	(*t->vector)(xmax/2+t->h_tic*2,t->v_tic);
X	(*t->move)(xmax/2,t->v_tic*2);
X	(*t->vector)(xmax/2+t->h_tic,t->v_tic*2);
X	(*t->put_text)(xmax/2+t->h_tic*2,t->v_tic*2+t->v_char/2,"test tics");
X	/* test line and point types */
X	x = xmax - t->h_char*4 - t->h_tic*4;
X	y = ymax - t->v_char;
X	for ( i = -2; y > t->v_char; i++ ) {
X		(*t->linetype)(i);
X		/*	(void) sprintf(label,"%d",i);  Jorgen Lippert
X		lippert@risoe.dk */
X		(void) sprintf(label,"%d",i+1);
X		if ((*t->justify_text)(RIGHT))
X			(*t->put_text)(x,y,label);
X		else
X			(*t->put_text)(x-strlen(label)*t->h_char,y,label);
X		(*t->move)(x+t->h_char,y);
X		(*t->vector)(x+t->h_char*4,y);
X		if ( i >= -1 )
X			(*t->point)(x+t->h_char*4+t->h_tic*2,y,i);
X		y -= t->v_char;
X	}
X	/* test some arrows */
X	(*t->linetype)(0);
X	x = xmax/4;
X	y = ymax/4;
X	xl = t->h_tic*5;
X	yl = t->v_tic*5;
X	(*t->arrow)(x,y,x+xl,y,TRUE);
X	(*t->arrow)(x,y,x+xl/2,y+yl,TRUE);
X	(*t->arrow)(x,y,x,y+yl,TRUE);
X	(*t->arrow)(x,y,x-xl/2,y+yl,FALSE);
X	(*t->arrow)(x,y,x-xl,y,TRUE);
X	(*t->arrow)(x,y,x-xl,y-yl,TRUE);
X	(*t->arrow)(x,y,x,y-yl,TRUE);
X	(*t->arrow)(x,y,x+xl,y-yl,TRUE);
X	/* and back into text mode */
X	(*t->text)();
X}
X
X
X#if defined(MSDOS)||defined(ATARI)||defined(OS2)||defined(_Windows)||defined(DOS386)
X/* output for some terminal types must be binary to stop non Unix computers
X   changing \n to \r\n. 
X   If the output is not STDOUT, the following code reopens outfile 
X   with binary mode. */
Xvoid
Xreopen_binary()
X{
Xchar filename[MAX_ID_LEN+1];
X
X	if (outfile!=stdout) {
X		(void) fclose(outfile);
X		(void) strcpy(filename,outstr+1);	/* remove quotes */
X		filename[strlen(filename)-1] = '\0';
X#ifdef _Windows
X		if ( !stricmp(outstr,"'PRN'") )
X			(void) strcpy(filename,win_prntmp);	/* use temp file for windows */
X#endif
X		if ( (outfile = fopen(filename,"wb")) == (FILE *)NULL ) {
X			if ( (outfile = fopen(filename,"w")) == (FILE *)NULL ) {
X				os_error("cannot reopen file with binary type; output unknown",
X					NO_CARET);
X			} 
X			else {
X	os_error("cannot reopen file with binary type; output reset to ascii", 
X					NO_CARET);
X			}
X		}
X#if defined(__TURBOC__) && defined(MSDOS)
X#ifndef _Windows
X		if ( !stricmp(outstr,"'PRN'") )
X		{
X		/* Put the printer into binary mode. */
X		union REGS regs;
X			regs.h.ah = 0x44;	/* ioctl */
X			regs.h.al = 0;		/* get device info */
X			regs.x.bx = fileno(outfile);
X			intdos(&regs, &regs);
X			regs.h.dl |= 0x20;	/* binary (no ^Z intervention) */
X			regs.h.dh = 0;
X			regs.h.ah = 0x44;	/* ioctl */
X			regs.h.al = 1;		/* set device info */
X			intdos(&regs, &regs);
X		}
X#endif
X#endif
X	}
X}
X#endif
X
X#ifdef vms
X/* these are needed to modify terminal characteristics */
X#include <descrip.h>
X#include <iodef.h>
X#include <ttdef.h>
X#include <tt2def.h>
X#include <dcdef.h>
X#include <ssdef.h>
X#include <stat.h>
X#include <fab.h>
Xstatic unsigned short   chan;
Xstatic int  old_char_buf[3], cur_char_buf[3];
X$DESCRIPTOR(sysoutput_desc,"SYS$OUTPUT");
X
Xchar *vms_init()
X/*
X * Determine if we have a regis terminal
X * and save terminal characteristics
X*/
X{
X   /* Save terminal characteristics in old_char_buf and
X   initialise cur_char_buf to current settings. */
X   int i;
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   sys$qiow(0,chan,IO$_SENSEMODE,0,0,0,old_char_buf,12,0,0,0,0);
X   for (i = 0 ; i < 3 ; ++i) cur_char_buf[i] = old_char_buf[i];
X   sys$dassgn(chan);
X
X   /* Test if terminal is regis */
X   if ((cur_char_buf[2] & TT2$M_REGIS) == TT2$M_REGIS) return("regis");
X   return(NULL);
X}
X
Xvoid
Xvms_reset()
X/* set terminal to original state */
X{
X   int i;
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   sys$qiow(0,chan,IO$_SETMODE,0,0,0,old_char_buf,12,0,0,0,0);
X   for (i = 0 ; i < 3 ; ++i) cur_char_buf[i] = old_char_buf[i];
X   sys$dassgn(chan);
X}
X
Xvoid
Xterm_mode_tek()
X/* set terminal mode to tektronix */
X{
X   long status;
X   if (outfile != stdout) return; /* don't modify if not stdout */
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   cur_char_buf[0] = 0x004A0000 | DC$_TERM | (TT$_TEK401X<<8);
X   cur_char_buf[1] = (cur_char_buf[1] & 0x00FFFFFF) | 0x18000000;
X
X   cur_char_buf[1] &= ~TT$M_CRFILL;
X   cur_char_buf[1] &= ~TT$M_ESCAPE;
X   cur_char_buf[1] &= ~TT$M_HALFDUP;
X   cur_char_buf[1] &= ~TT$M_LFFILL;
X   cur_char_buf[1] &= ~TT$M_MECHFORM;
X   cur_char_buf[1] &= ~TT$M_NOBRDCST;
X   cur_char_buf[1] &= ~TT$M_NOECHO;
X   cur_char_buf[1] &= ~TT$M_READSYNC;
X   cur_char_buf[1] &= ~TT$M_REMOTE;
X   cur_char_buf[1] |= TT$M_LOWER;
X   cur_char_buf[1] |= TT$M_TTSYNC;
X   cur_char_buf[1] |= TT$M_WRAP;
X   cur_char_buf[1] &= ~TT$M_EIGHTBIT;
X   cur_char_buf[1] &= ~TT$M_MECHTAB;
X   cur_char_buf[1] &= ~TT$M_SCOPE;
X   cur_char_buf[1] |= TT$M_HOSTSYNC;
X
X   cur_char_buf[2] &= ~TT2$M_APP_KEYPAD;
X   cur_char_buf[2] &= ~TT2$M_BLOCK;
X   cur_char_buf[2] &= ~TT2$M_DECCRT3;
X   cur_char_buf[2] &= ~TT2$M_LOCALECHO;
X   cur_char_buf[2] &= ~TT2$M_PASTHRU;
X   cur_char_buf[2] &= ~TT2$M_REGIS;
X   cur_char_buf[2] &= ~TT2$M_SIXEL;
X   cur_char_buf[2] |= TT2$M_BRDCSTMBX;
X   cur_char_buf[2] |= TT2$M_EDITING;
X   cur_char_buf[2] |= TT2$M_INSERT;
X   cur_char_buf[2] |= TT2$M_PRINTER;
X   cur_char_buf[2] &= ~TT2$M_ANSICRT;
X   cur_char_buf[2] &= ~TT2$M_AVO;
X   cur_char_buf[2] &= ~TT2$M_DECCRT;
X   cur_char_buf[2] &= ~TT2$M_DECCRT2;
X   cur_char_buf[2] &= ~TT2$M_DRCS;
X   cur_char_buf[2] &= ~TT2$M_EDIT;
X   cur_char_buf[2] |= TT2$M_FALLBACK;
X
X   status = sys$qiow(0,chan,IO$_SETMODE,0,0,0,cur_char_buf,12,0,0,0,0);
X   if (status == SS$_BADPARAM) {
X      /* terminal fallback utility not installed on system */
X      cur_char_buf[2] &= ~TT2$M_FALLBACK;
X      sys$qiow(0,chan,IO$_SETMODE,0,0,0,cur_char_buf,12,0,0,0,0);
X   }
X   else {
X      if (status != SS$_NORMAL)
X         lib$signal(status,0,0);
X   }
X   sys$dassgn(chan);
X}
X
Xvoid
Xterm_mode_native()
X/* set terminal mode back to native */
X{
X   int i;
X   if (outfile != stdout) return; /* don't modify if not stdout */
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   sys$qiow(0,chan,IO$_SETMODE,0,0,0,old_char_buf,12,0,0,0,0);
X   for (i = 0 ; i < 3 ; ++i) cur_char_buf[i] = old_char_buf[i];
X   sys$dassgn(chan);
X}
X
Xvoid
Xterm_pasthru()
X/* set terminal mode pasthru */
X{
X   if (outfile != stdout) return; /* don't modify if not stdout */
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   cur_char_buf[2] |= TT2$M_PASTHRU;
X   sys$qiow(0,chan,IO$_SETMODE,0,0,0,cur_char_buf,12,0,0,0,0);
X   sys$dassgn(chan);
X}
X
Xvoid
Xterm_nopasthru()
X/* set terminal mode nopasthru */
X{
X   if (outfile != stdout) return; /* don't modify if not stdout */
X   sys$assign(&sysoutput_desc,&chan,0,0);
X   cur_char_buf[2] &= ~TT2$M_PASTHRU;
X   sys$qiow(0,chan,IO$_SETMODE,0,0,0,cur_char_buf,12,0,0,0,0);
X   sys$dassgn(chan);
X}
X
Xvoid
Xreopen_binary()
X/* close the file outfile outfile and reopen it with binary type
X   if not already done or outfile == stdout */
X{
X   stat_t stat_buf;
X   char filename[MAX_ID_LEN+1];
X   if (outfile != stdout) { /* don't modify if not stdout */
X      if (!fstat(fileno(outfile),&stat_buf)) {
X         if (stat_buf.st_fab_rfm != FAB$C_FIX) {
X            /* modify only if not already done */
X            (void) fclose(outfile);
X            (void) strcpy(filename,outstr+1);   /* remove quotes */
X            filename[strlen(filename)-1] = '\0';
X            (void) delete(filename);
X            if ((outfile = fopen(filename,"wb","rfm=fix","bls=512","mrs=512"))
X                == (FILE *)NULL ) {
X               if ( (outfile = fopen(filename,"w")) == (FILE *)NULL ) {
X                 os_error("cannot reopen file with binary type; output unknown",
X                           NO_CARET);
X               }
X               else {
X          os_error("cannot reopen file with binary type; output reset to ascii",
X                           NO_CARET);
X               }
X            }
X         }
X      }
X      else{
X         os_error("cannot reopen file with binary type; output remains ascii",
X                  NO_CARET);
X      }
X   }
X}
X
Xvoid
Xfflush_binary()
X{
X   typedef short int INT16;     /* signed 16-bit integers */
X   register INT16 k;            /* loop index */
X   if (outfile != stdout) {
X       /* Stupid VMS fflush() raises error and loses last data block
X          unless it is full for a fixed-length record binary file.
X          Pad it here with NULL characters. */
X       for (k = (INT16)((*outfile)->_cnt); k > 0; --k)
X          putc('\0',outfile);
X       fflush(outfile);
X   }
X}
X#endif
END_OF_FILE
  if test 69784 -ne `wc -c <'gnuplot/term.c'`; then
    echo shar: \"'gnuplot/term.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term.c'
fi
if test ! -d 'gnuplot/win' ; then
    echo shar: Creating directory \"'gnuplot/win'\"
    mkdir 'gnuplot/win'
fi
echo shar: End of archive 1 \(of 33\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
