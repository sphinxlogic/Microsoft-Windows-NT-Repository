Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i037:  gnuplot - interactive function plotting utility, Part25/33
Message-ID: <1993Oct25.025905.1963@sparky.sterling.com>
X-Md4-Signature: bf8682448ab38cca5327eb2a8d561955
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 25 Oct 1993 02:59:05 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 37
Archive-name: gnuplot/part25
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/poldat.dem gnuplot/hrcgraph.asm
#   gnuplot/term/eepic.trm gnuplot/term/fig.trm
#   gnuplot/term/hpljii.trm gnuplot/term/object.h
#   gnuplot/term/pstricks.trm gnuplot/term/vws.trm
#   gnuplot/win/wgnuplib.h gnuplot/win/wpause.c
# Wrapped by kent@sparky on Wed Oct 20 17:14:58 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 25 (of 33)."'
if test -f 'gnuplot/demo/poldat.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/poldat.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/poldat.dem'\" \(1257 characters\)
  sed "s/^X//" >'gnuplot/demo/poldat.dem' <<'END_OF_FILE'
X#
X# $Id: poldat.dem%v 3.38.2.88 1993/03/04 01:47:16 woo Exp woo $
X#
X#
Xset size .8,1.0
Xset time
Xset clip
Xset grid
Xset noborder
Xset noparam
Xset title "Antenna Pattern"
Xset xlabel "Azimuth"
Xset ylabel "dBSM"
Xset data style line
Xset angles degrees
Xset polar
Xset yrange [-220:220]
Xset rrange [-200:60]
Xplot "polar.dat" using 1:5,"antenna.dat"
Xpause -1 "Hit return to continue"
Xset nogrid
Xset nopolar
Xset title "Primitive Smith Chart"
Xset nokey
Xset xlabel "Impedance or Admittance Coordinates"
Xset para
Xset nogrid
Xset rrange [-0 : 10]
Xset trange [-pi : pi]
Xset xrange [-1:1]
Xset yrange [-1:1]
Xtv(t,r) = sin(t)/(1+r)
Xtu(t,r) = (cos(t) +r)/(1+r)
Xcu(t,x) = 1 + cos(t)/x
Xcv(t,x) = (1+ sin(t))/x
Xplot cu(t,.1),cv(t,.1),cu(t,.1),-cv(t,.1),\
Xcu(t,1),cv(t,1),cu(t,1),-cv(t,1),\
Xcu(t,10),cv(t,10),cu(t,10),-cv(t,10),\
Xtu(t,.1),tv(t,.1),\
Xtu(t,.5),tv(t,.5),\
Xtu(t,1),tv(t,1),\
Xtu(t,5),tv(t,5),\
Xtu(t,10),tv(t,10),\
Xcu(t,.5),cv(t,.5),cu(t,.5),-cv(t,.5),\
Xtu(t,0),tv(t,0)
X#cu(t,5),cv(t,5),cu(t,5),-cv(t,5)
Xpause -1 "Hit return to continue"
Xset noparam
Xset key
Xset size 1.0,1.0
Xset notime
Xset title "" 0,0
Xset xlabel "" 0,0
Xset ylabel "" 0,0
Xset data style points
Xset angles radians
Xset nopolar
Xset yrange [-10:10]
Xset rrange [0:10]
Xset auto
Xset noparam
Xset border
Xset nogrid
END_OF_FILE
  if test 1257 -ne `wc -c <'gnuplot/demo/poldat.dem'`; then
    echo shar: \"'gnuplot/demo/poldat.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/poldat.dem'
fi
if test -f 'gnuplot/hrcgraph.asm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/hrcgraph.asm'\"
else
  echo shar: Extracting \"'gnuplot/hrcgraph.asm'\" \(8192 characters\)
  sed "s/^X//" >'gnuplot/hrcgraph.asm' <<'END_OF_FILE'
XTITLE	Hercules graphics module
X
X;	Michael Gordon - 8-Dec-86
X;
X; Certain routines were taken from the Hercules BIOS of	Dave Tutelman - 8/86
X; Others came from pcgraph.asm included in GNUPLOT by Colin Kelley
X;
X; modified slightly by Colin Kelley - 22-Dec-86
X;	added header.mac, parameterized declarations
X; added dgroup: in HVmodem to reach HCh_Parms and HGr_Parms - 30-Jan-87
X; modified by Russell Lang 3 Jun 1988
X;	added H_init
X
Xinclude header.mac
X
Xif1
Xinclude lineproc.mac
Xendif
X
X
XGPg1_Base equ 0B800h	; Graphics page 1 base address
X
X_text	segment
X
X	public _H_line, _H_color, _H_mask, _HVmode, _H_puts
X	public _H_init
X
XHCfg_Switch equ	03BFH	; Configuration Switch - software switch 
X			; to select graphics card memory map
X
Xbeginproc _H_init
X	mov al, 03H	; allow graphics in b8000:bffff
X	mov dx, HCfg_Switch
X	out dx, al
X	ret
X_H_init endp
X
Xhpixel	proc near
X	ror word ptr bmask,1
X	jc cont
X	ret
Xcont:
X	push ax
X	push bx
X	push cx
X	push dx
X	push si
X	mov cx,ax		; x
X	mov dx,bx		; y
X;
X; [couldn't this be done faster with a lookup table? -cdk]
X;
X	; first compute the address of byte to be modified
X	; = 90*[row/4] + [col/8] + 2^D*[row/4] + 2^F*page
X	mov	bh,cl		; col (low order) in BH
X	mov	bl,dl		; row (low order) in BL
X	and	bx,0703H	; mask the col & row remainders
XIFDEF iAPX286
X	shr	cx,3		; col / 8
X	shr	dx,2		; row / 4
X	mov	al,90
X	mul	dx		; AX = 90*[ row/4 ]
X	add	ax,cx		;  ... + col/8
X	shl	bl,5		; align row remainder
XELSE			; same as above, obscure but fast for 8086
X	shr	cx,1		; divide col by 8
X	shr	cx,1
X	shr	cx,1
X	shr	dx,1		; divide row by 4
X	shr	dx,1
X	shl	dx,1		; begin fast multiply by 90 (1011010 B)
X	mov	ax,dx
X	shl	dx,1
X	shl	dx,1
X	add	ax,dx
X	shl	dx,1
X	add	ax,dx
X	shl	dx,1
X	shl	dx,1
X	add	ax,dx		; end fast multiply by 90
X	add	ax,cx		; add on the col/8
X	shl	bl,1		; align row remainder
X	shl	bl,1
X	shl	bl,1
X	shl	bl,1
X	shl	bl,1
XENDIF
X	add	ah,bl		; use aligned row remainder
Xend_adr_calc:			; address of byte is now in AX
X	mov	dx,GPg1_Base	; base of pixel display to DX
X	mov	es,dx		; ...and thence to segment reg
X	mov	si,ax		; address of byte w/ pixel to index reg
X	mov	cl,bh		; bit addr in byte
X	mov	al,80H		; '1000 0000' in AL 
X	shr	al,cl		; shift mask to line up with bit to read/write
Xset_pix:			; set the pixel
X	or	es:[si],al	; or the mask with the right byte
X	pop si
X	pop dx
X	pop cx
X	pop bx
X	pop ax
X	ret
Xhpixel endp
X
Xlineproc _H_line, hpixel
X
X;
X; clear - clear page 1 of the screen buffer to zero (effectively, blank
X;	the screen)
X;
Xclear   proc near
X	push es
X	push ax
X	push cx
X	push di
X	mov ax, GPg1_Base
X	mov es, ax
X	xor di, di
X	mov cx, 4000h
X	xor ax, ax
X	cld
X	rep stosw			; zero out screen page
X	pop di
X	pop cx
X	pop ax
X	pop es
X	ret
Xclear	endp
X
Xbeginproc _H_color
X	push bp
X	mov bp,sp
X	mov al,[bp+X]			; color
X	mov byte ptr color,al
X	pop bp
X	ret
X_H_color endp
X
Xbeginproc _H_mask
X	push bp
X	mov bp,sp
X	mov ax,[bp+X]			; mask
X	mov word ptr bmask,ax
X	pop bp
X	ret
X_H_mask endp
X
XHCtrl_Port	equ	03B8H	; Hercules 6845 control port IO addr
XHIndx_Port	equ	03B4H	; Hercules 6845 index port IO addr
XHScrn_Enable	equ	008h	; Control port bit to enable video
XHCh_Mode	equ	020h	; Character output mode
XHGr_Mode	equ	082h	; Graphics output mode page 1
X
Xparm_count equ 12
X
Xbeginproc _HVmode
X	push bp
X	mov bp, sp
X	push si
X	mov ax, [bp+X]
X	or ah, al
X	mov al, HCh_Mode		; Assume character mode is wanted
X	mov si, offset dgroup:HCh_Parms
X	cmp ah, 0			; nonzero means switch to graphics
X	jz vmode_ok
X	call near ptr clear		; clear the graphics page
X	mov al, HGr_Mode
X	mov si, offset dgroup:HGr_Parms
Xvmode_ok:
X	mov dx, HCtrl_Port
X	out dx, al			; Set Hercules board to proper mode
X	call near ptr setParms		; Set the 6845 parameters
X	or al, HScrn_Enable		; Enable the video output
X	out dx, al
X	pop si
X	pop bp
X	ret
X_HVmode	endp
X
XsetParms proc near		; Send 6845 parms to Hercules board
X	push ax
X	push dx
X	push si			
X	mov dx, HIndx_Port	; Index port addr -> DX
X	mov ah, 0		; 0 -> parameter counter
Xsp_loop:
X	mov al, ah
X	out dx, al		; output to 6845 addr register
X	inc dx			; next output to data register
X	mov al, [si]		; next control byte -> al
X	inc si
X	out dx, al		; output control byte
X	dec dx			; 6845 index addr -> dx
X	inc ah			; bump addr
X	cmp ah, parm_count
X	jnz sp_loop
X	pop si
X	pop dx
X	pop ax
X	ret
XsetParms endp
X
X; H_puts - print text in graphics mode
X;
X;	cx = row
X;	bx = column
X;	si = address of string (null terminated) to print
X
Xbeginproc _H_puts
X	push bp
X	mov bp, sp
X	push si
X	push ds
X	mov si, [bp+X]			; string offset
X
Xifdef LARGE_DATA
X	mov ds, [bp+X+2]		; string segment
X	mov cx, [bp+X+4]		; row
X	mov bx, [bp+X+6]		; col
Xelse
X	mov cx, [bp+X+2]		; row
X	mov bx, [bp+X+4]		; col
Xendif
X
Xploop:	lodsb				; get next char
X	or	al, al			; end of display?
X	je	pdone
X	call near ptr display
X	inc	bx			; bump to next column
X	jmp	ploop
Xpdone:	pop ds
X	pop si
X	pop bp
X	ret
X_H_puts	endp
X
X;
X; display - output an 8x8 character from the IBM ROM to the Herc board
X;
X; AX = char, BX = column (0-89), CX = row(0-42)  ** all preserved **
X;
XCON8	db	8
XCON180	db	180
XIBMROM	equ	0F000h
XCHARTAB	equ	0FA6Eh
X
Xdisplay	proc near
X	push	ds			; save the lot
X	push	es
X	push	ax
X	push	bx
X	push	cx
X	push	dx
X	push	si
X	push	di
X
X; setup ds -> IBM ROM, and si -> index into IBM ROM character table located
X;	at 0fa6eh in the ROM
X
X	and	ax, 07fh
X	mul	cs:CON8			; mult by 8 bytes of table per char
X	mov	si, ax
X	mov	ax, IBMROM
X	mov	ds, ax
X	assume	ds:nothing
X	add	si, CHARTAB		; add offset of character table
X
X; compute index into Hercules screen memory for scan line 0.  The remaining
X;	seven scan lines are all at fixed offsets from the first.
X;
X;	Since graphics mode treats the screen as sets of 16x4 "characters",
X;	we need to map an 8x8 real character onto the front or back of
X;	a pair of graphics "characters".  The first four scan lines of our
X;	8x8 character will map to the top graphics "character", and the second
X;	four scan lines map to the graphics character on the "line" (4 scan
X;	lines high) below it.
X;
X;	For some exotic hardware reason (probably speed), all scan line 0
X;	bits (i.e. every fourth scan line) are stored in memory locations
X;	0-2000h in the screen buffer.  All scan line 1 bits are stored
X;	2000h-4000h.  Within these banks, they are stored by rows.  The first
X;	scan line on the screen (scan line 0 of graphics character row 0)
X;	is the first 45 words of memory in the screen buffer.  The next 45
X;	words are the first scan line graphics row 1, and since graphics
X;	"characters" are 4 bits high, this second scan line is physically
X;	the fifth scan line displayed on the screen.
X;
X;	SO, to display an 8x8 character, the 1st and 5th rows of dots are
X;	both scan line 0 of the graphics "character", the 2nd and 6th are
X;	scan line 1, and so on.
X;
X;	The column (0-89) tells which byte in a scan line we need to load.
X;	Since it takes two rows of graphics characters to hold one row of
X;	our characters, column+90 is a index to scan line 4 rows of pixels
X;	higher (n+4).  Thus 180 bytes of screen memory in any bank (0h, 2000h,
X;	4000h, 6000h) represent a row of 8x8 characters.
X;	
X;	The starting location in screen memory for the first scan line of
X;	a character to be displayed will be:  	(row*180)+column
X;	The 5th scan line will be at:		(row*180)+column+90
X;
X;	The second and 6th scan lines will be at the above offsets plus
X;	the bank offset of 2000h.  The third and 7th, add 4000h and finally
X;	the 4th and 8th, add 6000h.
X;
X	mov	ax, GPg1_Base
X	mov	es, ax			; es = hercules page 0
X	mov	ax, cx			; get row
X	mul	cs:CON180		; mult by 180(10)
X	mov	di, ax			; di = index reg
X	cld				; insure right direction
X
X;output 8 segments of character to video ram
X
X	lodsb				; line 0
X	mov	es:[di+bx], al
X	lodsb
X	mov	es:[di+bx+2000h], al	; line 1
X	lodsb
X	mov	es:[di+bx+4000h], al	; line 2
X	lodsb
X	mov	es:[di+bx+6000h], al	; line 3
X	lodsb
X	mov	es:[di+bx+90], al	; line 4
X	lodsb
X	mov	es:[di+bx+2000h+90], al	; line 5
X	lodsb
X	mov	es:[di+bx+4000h+90], al	; line 6
X	lodsb
X	mov	es:[di+bx+6000h+90], al	; line 7
X
X	pop	di
X	pop	si
X	pop	dx
X	pop	cx
X	pop	bx
X	pop	ax
X	pop	es
X	pop	ds
X	ret
Xdisplay	endp
X
X_text	ends
X
X_data	segment
Xbmask	dw -1
Xcolor	db 1
X_data	ends
X
Xconst	segment
XHCh_Parms db 	61H, 50H, 52H, 0FH, 19H, 06H, 19H, 19H, 02H, 0DH, 0BH, 0CH
XHGr_Parms db	35H, 2DH, 2EH, 07H, 5BH, 02H, 57H, 57H, 02H, 03H, 00H, 00H
Xconst	ends
X
X	end
X
X
END_OF_FILE
  if test 8192 -ne `wc -c <'gnuplot/hrcgraph.asm'`; then
    echo shar: \"'gnuplot/hrcgraph.asm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/hrcgraph.asm'
fi
if test -f 'gnuplot/term/eepic.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/eepic.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/eepic.trm'\" \(7741 characters\)
  sed "s/^X//" >'gnuplot/term/eepic.trm' <<'END_OF_FILE'
X/*
X * $Id: eepic.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - eepic.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   The EEPIC macros for LaTeX. 
X *
X * AUTHORS
X *   David Kotz
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X/*
X *  This file contains the eepic terminal driver, intended for use with the 
X *  eepic.sty macro package for LaTeX. This is an alternative to the 
X *  latex driver. You need eepic.sty, epic.sty, and a printer driver that
X *  supports the tpic \specials.
X *
X * Although dotted and dashed lines are possible with EEPIC, and are
X * tempting, they do not work well for high-sample-rate curves, mushing
X * the dashes all together into a solid line. For now anyway, the EEPIC
X * driver will have only solid lines. Anyone got a solution?
X *
X * LATEX must also be defined.
X */
X
X#define EEPIC_PTS_PER_INCH (72.27)
X#define DOTS_PER_INCH (300)	/* resolution of printer we expect to use */
X#define EEPIC_UNIT (EEPIC_PTS_PER_INCH/DOTS_PER_INCH) /* dot size in pt */
X
X/* 5 inches wide by 3 inches high (default) */
X#define EEPIC_XMAX (5*DOTS_PER_INCH)  /* (EEPIC_PTS_PER_INCH/EEPIC_UNIT*5.0) */
X#define EEPIC_YMAX (3*DOTS_PER_INCH)  /* (EEPIC_PTS_PER_INCH/EEPIC_UNIT*3.0) */
X
X#define EEPIC_HTIC (5*DOTS_PER_INCH/72)		/* (5./EEPIC_UNIT) */
X#define EEPIC_VTIC (5*DOTS_PER_INCH/72)		/* (5./EEPIC_UNIT) */
X#define EEPIC_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3/EEPIC_UNIT) */
X#define EEPIC_VCHAR (DOTS_PER_INCH*11/72)	/* (11./EEPIC_UNIT) */
X
Xstatic unsigned int EEPIC_posx;
Xstatic unsigned int EEPIC_posy;
Xenum JUSTIFY eepic_justify=LEFT;
Xstatic int eepic_angle=0;
X
X/* for DOTS point style */
X#define EEPIC_TINY_DOT "\\rule{.1pt}{.1pt}"
X
X/* POINTS */
X#define EEPIC_POINT_TYPES 12	/* we supply more point types */
Xstatic char GPFAR * GPFAR EEPIC_points[] = {
X    "\\raisebox{-1.2pt}{\\makebox(0,0){$\\Diamond$}}",
X    "\\makebox(0,0){$+$}",
X    "\\raisebox{-1.2pt}{\\makebox(0,0){$\\Box$}}",
X    "\\makebox(0,0){$\\times$}",
X    "\\makebox(0,0){$\\triangle$}",
X    "\\makebox(0,0){$\\star$}",
X    "\\circle{12}", "\\circle{18}", "\\circle{24}",
X    "\\circle*{12}", "\\circle*{18}", "\\circle*{24}"
X};
X
X/* LINES */
X#define EEPIC_NUMLINES 5		/* number of linetypes below */
Xstatic char GPFAR * GPFAR EEPIC_lines[] = {
X    "\\thicklines \\path",			/* -2 border */
X    "\\thinlines \\drawline[-50]",		/* -1 axes */
X    "\\thinlines \\path",			/*  0 solid thin  */
X    "\\thicklines \\path",			/*  1 solid thick */
X    "\\Thicklines \\path",			/*  2 solid Thick */
X};
X/* These are other possibilities
X    "\\thinlines \\dottedline{30}",
X    "\\thinlines \\drawline[-30]",	
X    "\\thinlines \\dottedline{60}",
X    "\\thinlines \\drawline[-60]",	
X    "\\thinlines \\dashline[-10]{20}[6]"
X*/
Xstatic int EEPIC_type;		/* current line type */
Xstatic TBOOLEAN EEPIC_inline = FALSE; /* are we in the middle of a line */
Xstatic void EEPIC_endline();	/* terminate any line in progress */
Xstatic int EEPIC_linecount = 0; /* number of points in line so far */
X#define EEPIC_LINEMAX 50		/* max value for linecount */
X
X/* ARROWS */
X/* we use the same code as for LATEX */
Xstatic void best_latex_arrow(); /* figure out the best arrow */
X
XEEPIC_init()
X{
X    EEPIC_posx = EEPIC_posy = 0;
X    EEPIC_linetype(-1);
X    fprintf(outfile, "%% GNUPLOT: LaTeX picture using EEPIC macros\n");
X    fprintf(outfile, "\\setlength{\\unitlength}{%fpt}\n", EEPIC_UNIT);
X}
X
X
XEEPIC_scale(xs, ys)
X	double xs, ys;			/* scaling factors */
X{
X    register struct termentry *t = &term_tbl[term];
X
X    /* we change the table for use in graphics.c and EEPIC_graphics */
X    t->xmax = (unsigned int)(EEPIC_XMAX * xs);
X    t->ymax = (unsigned int)(EEPIC_YMAX * ys);
X
X    return(TRUE);
X}
X
XEEPIC_graphics()
X{
X    register struct termentry *t = &term_tbl[term];
X
X    fprintf(outfile, "\\begin{picture}(%d,%d)(0,0)\n", t->xmax, t->ymax);
X    fprintf(outfile, "\\tenrm\n");
X}
X
X
XEEPIC_text()
X{
X    EEPIC_endline();
X    fprintf(outfile, "\\end{picture}\n");
X}
X
X
XEEPIC_linetype(linetype)
X	int linetype;
X{
X    EEPIC_endline();
X
X    if (linetype >= EEPIC_NUMLINES-2)
X	 linetype %= (EEPIC_NUMLINES-2);
X
X    EEPIC_type = linetype;
X}
X
X
X
XEEPIC_move(x,y)
X	unsigned int x,y;
X{
X    EEPIC_endline();
X
X    EEPIC_posx = x;
X    EEPIC_posy = y;
X}
X
X
XEEPIC_point(x,y, number)		/* version of line_and_point */
X	unsigned int x,y;
X	int number;				/* type of point */
X{
X    EEPIC_move(x,y);
X    
X    /* Print the character defined by 'number'; number < 0 means 
X	  to use a dot, otherwise one of the defined points. */
X    fprintf(outfile, "\\put(%d,%d){%s}\n", x, y, 
X		  (number < 0 ? EEPIC_TINY_DOT
X		   : EEPIC_points[number % EEPIC_POINT_TYPES]));
X}
X
X
XEEPIC_vector(ux,uy)
X	unsigned int ux,uy;
X{
X    if (!EEPIC_inline) {
X	   EEPIC_inline = TRUE;
X
X	   /* Start a new line. This depends on line type */
X	   fprintf(outfile, "%s(%u,%u)", 
X			 EEPIC_lines[EEPIC_type+2], 
X			 EEPIC_posx, EEPIC_posy);
X	   EEPIC_linecount = 1;
X    } else {
X	   /* Even though we are in middle of a path, 
X	    * we may want to start a new path command. 
X	    * If they are too long then latex will choke.
X	    */
X	   if (EEPIC_linecount++ >= EEPIC_LINEMAX) {
X		  fprintf(outfile, "\n");
X		  fprintf(outfile, "%s(%u,%u)", 
X				EEPIC_lines[EEPIC_type+2], 
X				EEPIC_posx, EEPIC_posy);
X		  EEPIC_linecount = 1;
X	   }
X    }
X    fprintf(outfile, "(%u,%u)", ux,uy);
X    EEPIC_posx = ux;
X    EEPIC_posy = uy;
X}
X
Xstatic void
XEEPIC_endline()
X{
X    if (EEPIC_inline) {
X	   fprintf(outfile, "\n");
X	   EEPIC_inline = FALSE;
X    }
X}
X
X
XEEPIC_arrow(sx,sy, ex,ey, head)
X	int sx,sy, ex,ey;
X	TBOOLEAN head;
X{
X    best_latex_arrow(sx,sy, ex,ey, 2, head); /* call latex routine */
X
X    EEPIC_posx = ex;
X    EEPIC_posy = ey;
X}
X
X
XEEPIC_put_text(x, y, str)
X	int x,y;				/* reference point of string */
X	char str[];			/* the text */
X{
X    EEPIC_endline();
X
X    fprintf(outfile, "\\put(%d,%d)",x,y);
X    switch(eepic_angle) {  
X 	   case 0: {
X		  switch(eepic_justify) {
X			 case LEFT: {
X				fprintf(outfile,
X					   "{\\makebox(0,0)[l]{%s}}\n", str);
X				break;
X			 }
X			 case CENTRE: {
X				fprintf(outfile,
X					   "{\\makebox(0,0){%s}}\n", str);
X				break;
X			 }
X			 case RIGHT: {
X				fprintf(outfile,
X					   "{\\makebox(0,0)[r]{%s}}\n", str);
X				break;
X			 }
X		  }
X		  break;
X	   }
X	   case 1: {			/* put text in a short stack */
X		  switch(eepic_justify) {
X			 case LEFT: {
X				fprintf(outfile,
X					   "{\\makebox(0,0)[lb]{\\shortstack{%s}}}\n", str);
X				break;
X			 }
X			 case CENTRE: {
X				fprintf(outfile,
X					   "{\\makebox(0,0)[l]{\\shortstack{%s}}}\n", str);
X				break;
X			 }
X			 case RIGHT: {
X				fprintf(outfile,
X					   "{\\makebox(0,0)[lt]{\\shortstack{%s}}}\n", str);
X				break;
X			 }
X		  }
X		  break;
X	   }	
X    }
X}
X
X
X
Xint EEPIC_justify_text(mode)
X	enum JUSTIFY mode;
X{
X    eepic_justify = mode;
X    return (TRUE);
X}
X
Xint EEPIC_text_angle(angle)
X	int angle;
X{
X    /* we can't really write text vertically, but this will 
X	  put the ylabel centred at the left of the plot, and
X	  then we'll make a \shortstack */
X    eepic_angle = angle;
X    return (TRUE);
X}
X
XEEPIC_reset()
X{
X    EEPIC_endline();
X    EEPIC_posx = EEPIC_posy = 0;
X}
X
END_OF_FILE
  if test 7741 -ne `wc -c <'gnuplot/term/eepic.trm'`; then
    echo shar: \"'gnuplot/term/eepic.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/eepic.trm'
fi
if test -f 'gnuplot/term/fig.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/fig.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/fig.trm'\" \(8468 characters\)
  sed "s/^X//" >'gnuplot/term/fig.trm' <<'END_OF_FILE'
X/*
X * $Id: fig.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - fig.trm */
X/*
X * Copyright (C) 1990, 1991, 1992
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  Fig graphics language
X *
X * AUTHORS
X *  Micah Beck, David Kotz
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X#ifdef MSDOS
X#define long int
X#endif /* MSDOS */
X
X/*
X * Original for Fig code output by Micah Beck, 1989
X * Department of Computer Science, Cornell University
X * Updated by David Kotz for gnuplot 2.0
X * More efficient output by Ian Dall
X * Updated to FIG 2.1 (with color) format by Vivek Khera
X */
X#include "object.h"                     /* from the XFig distribution */
X#define FIG_DEFAULT DEFAULT
X#define FIG_ROMAN_FONT (0)	/* actually, the default font */
X 
X#ifndef FIG_RES
X/* Must be 80 for the Fig editor, but may be increased if used
X * only by TransFig filters.
X * Represents pixels per inch.
X */
X#define FIG_RES         (80)
X#endif
X 
X#define FIG_COORD_SYS   2
X 
X#define FIG_MAGIC       "#FIG 2.1"
X#define FIG_HTIC        (5*FIG_RES/80)
X#define FIG_VTIC        (5*FIG_RES/80)
X#define FIG_FONT_S      (10)	/* size in points */
X#define FIG_VCHAR       (FIG_FONT_S*72/FIG_RES) /* height of font in pixels */
X#define FIG_HCHAR       (FIG_VCHAR*6/10) /* this is a guess at the width */
X#define FIG_ARROW_WIDTH (FIG_HTIC/2 + 1)
X#define FIG_ARROW_HEIGHT FIG_HTIC
X 
Xstatic long FIG_xbase = FIG_RES/2;
Xstatic long FIG_ybase = FIG_RES/2;
X 
Xstatic long FIG_posx;
Xstatic long FIG_posy;
Xstatic int FIG_poly_vec_cnt;
Xenum FIG_poly_stat {FIG_poly_new, FIG_poly_part};
Xstatic enum FIG_poly_stat FIG_polyvec_stat;
X/* 5 inches wide by 3 inches high */
X#define FIG_XMAX (5 * FIG_RES)
X#define FIG_YMAX (3 * FIG_RES)
X 
X#define FIG_XOFF (FIG_RES/4)
X#define FIG_YOFF (FIG_RES/4)
X 
Xstatic int FIG_type;            /* negative types use real lines */
Xstatic float FIG_spacing;       /* length of dash or dot spacing */
Xstatic int FIG_justify;         /* Fig justification T_*_JUSTIFIED */
Xstatic float FIG_angle;         /* Fig text angle 0=horiz, Pi/2=vert */
Xstatic int FIG_use_color = FALSE;	/* do we use color or not? */
Xstatic int FIG_color = DEFAULT;	/* which color to use */
X 
X#define FIG_POINT_TYPES POINT_TYPES /* we use the same points */
X 
Xstatic
X  FIG_poly_clean(stat)
Xenum FIG_poly_stat stat;
X{
X  if(stat == FIG_poly_part)
X        fprintf(outfile, " 9999 9999\n");
X  FIG_polyvec_stat = FIG_poly_new;
X}
X 
XFIG_options()
X{
X	FIG_use_color = FALSE;	/* assumption */
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"m$onochrome")) {
X			FIG_use_color=FALSE;
X			c_token++;
X		}
X		else if (almost_equals(c_token,"c$olor")) {
X			FIG_use_color=TRUE;
X			c_token++;
X		}
X	}
X
X	sprintf(term_options,"%s", FIG_use_color ? "color" : "monochrome");
X}
X
XFIG_init()
X{
X    FIG_posx = FIG_posy = 0;
X    FIG_polyvec_stat = FIG_poly_new;
X    FIG_linetype(-1);
X    FIG_justify_text(LEFT);
X    FIG_text_angle(0);
X 
X    fprintf(outfile, "%s\n", FIG_MAGIC);
X    fprintf(outfile, "%d %d\n", FIG_RES, FIG_COORD_SYS);
X}
X 
X 
XFIG_graphics()
X{
X    FIG_posx = FIG_posy = 0;
X    FIG_polyvec_stat = FIG_poly_new;
X    /* there is no way to have separate pictures in a FIG file */
X}
X 
X 
XFIG_text()
X{
X    /* there is no way to have separate pictures in a FIG file */
X    FIG_poly_clean(FIG_polyvec_stat);
X    FIG_posx = FIG_posy = 0;
X    fflush(outfile);
X}
X 
X 
X/* Line types for FIG work like this:
X *  for monochrome:
X *  -2 : solid (border)
X *  -1 : dotted 4 (axes)
X *   0 : solid (first curve)
X *   1 : dotted 3
X *   2 : dashed 3
X *   3 : dotted 6
X *   4 : dashed 6
X *   ... ...
X *  for color, cycle through colors. once colors are used up, repeat colors
X *   but start using dashed lines of different dash length. don't use white
X *   as a color.
X */
X 
XFIG_linetype(linetype)
X        int linetype;                   /* expect linetype >= -2 */
X{
X    int last_FIG_type = FIG_type;
X    int last_FIG_spacing = FIG_spacing;
X    switch (linetype) {
X           case 0:
X           case -2: {
X                  FIG_type = SOLID_LINE;
X                  FIG_spacing = 0.0;
X		  if (FIG_use_color) FIG_color = BLACK;
X                  break;
X           }
X           case -1: {
X                  FIG_type = DOTTED_LINE;
X                  FIG_spacing = 4.0; /* gap */
X		  if (FIG_use_color) FIG_color = BLACK;
X                  break;
X           }
X           default: {
X                linetype = abs(linetype); /* shouldn't be negative anyway */
X                /* now linetype >= 1 */
X		if (FIG_use_color) {
X		  FIG_type = (linetype >= WHITE);	/* dashed line */
X		  FIG_color = linetype % WHITE;
X		  FIG_spacing = (linetype / WHITE) * 3;
X		} else { /* monochrome */
X                  FIG_type = linetype % 2 + 1; /* dotted, dashed, ... */
X                  FIG_spacing = (linetype+1) / 2 * 3;
X		}
X                  break;
X           }
X    }
X    if (FIG_type != last_FIG_type || FIG_spacing != last_FIG_spacing)
X      FIG_poly_clean(FIG_polyvec_stat);
X}
X 
XFIG_move(x,y)
X        unsigned int x,y;
X{
X    int last_FIG_posx = FIG_posx;
X    int last_FIG_posy = FIG_posy;
X    FIG_posx = x;
X    FIG_posy = y;
X    if (FIG_posx != last_FIG_posx || FIG_posy != last_FIG_posy)
X          FIG_poly_clean(FIG_polyvec_stat);
X}
X 
X 
XFIG_vector(ux,uy)
X     unsigned int ux,uy;
X{
X  int x=ux, y=uy;
X 
X  if (FIG_polyvec_stat != FIG_poly_part)
X    {
X      fprintf(outfile, "%d %d %d %d %d %d %d %d %6.3f %d %d %d\n",
X              O_POLYLINE, T_POLYLINE,
X              FIG_type, 1, FIG_color, 0, FIG_DEFAULT, 0, FIG_spacing, 0,0,0);
X      fprintf(outfile, "%d %d",
X              FIG_XOFF + FIG_posx, FIG_YMAX + FIG_YOFF - FIG_posy);
X      FIG_poly_vec_cnt = 1;
X      FIG_polyvec_stat = FIG_poly_part;
X    }
X  fprintf(outfile, " %d %d",
X          FIG_XOFF +  x, FIG_YMAX + FIG_YOFF-y);
X  FIG_poly_vec_cnt++;
X  if (FIG_poly_vec_cnt > 50)
X    FIG_poly_clean(FIG_polyvec_stat);
X 
X  FIG_posx = x;
X  FIG_posy = y;
X}
X 
X 
XFIG_arrow(sx, sy, ex, ey, head)
X        int sx, sy;     /* start coord */
X        int ex, ey;     /* end coord */
X	TBOOLEAN head;
X{
X	FIG_poly_clean(FIG_polyvec_stat);
X        fprintf(outfile, "%d %d %d %d %d %d %d %d %6.3f %d  %d %d\n",
X                O_POLYLINE, T_POLYLINE,
X                FIG_type, 1, FIG_color, 0, FIG_DEFAULT, 0, FIG_spacing,
X		0, head ? 1 : 0, 0);
X        /* arrow line */
X	if ( head )
X	        fprintf(outfile, "%d %d %.3f %.3f %.3f\n",
X        	        0, 0, 1.0,
X			(double)FIG_ARROW_WIDTH, (double)FIG_ARROW_HEIGHT);
X        fprintf(outfile, "%d %d %d %d 9999 9999\n",
X                FIG_XOFF + sx, FIG_YOFF + FIG_YMAX - sy,
X		FIG_XOFF + ex, FIG_YOFF + FIG_YMAX - ey);
X 
X        FIG_posx = ex;
X        FIG_posy = ey;
X}
X 
X 
XFIG_put_text(x, y, str)
X        int x, y;
X        char *str;
X{
X  if (strlen(str) == 0) return;
X  FIG_poly_clean(FIG_polyvec_stat);
X  y -= FIG_VCHAR/2;	/* assuming vertical center justified */
X 
X    fprintf(outfile, "%d %d %d %d %d %d %d %6.3f %d %d %d %d %d %s\01\n",
X                  O_TEXT, FIG_justify,
X                  FIG_ROMAN_FONT, FIG_FONT_S, FIG_DEFAULT, FIG_DEFAULT, 0,
X		  FIG_angle, SPECIAL_TEXT, FIG_VCHAR, FIG_HCHAR*strlen(str),
X		  FIG_XOFF + x, FIG_YMAX + FIG_YOFF-y, str);
X}
X 
Xint FIG_justify_text(mode)
X        enum JUSTIFY mode;
X{
X    switch(mode) {
X           case LEFT: FIG_justify = T_LEFT_JUSTIFIED; break;
X           case CENTRE: FIG_justify = T_CENTER_JUSTIFIED; break;
X           case RIGHT: FIG_justify = T_RIGHT_JUSTIFIED; break;
X           /* shouldn't happen */
X           default: FIG_justify = T_LEFT_JUSTIFIED; return (FALSE); break;
X    }
X    return (TRUE);
X}
X 
Xint FIG_text_angle(angle)
X        int angle;
X{
X    if (angle)
X         FIG_angle = Pi / 2.0;  /* vertical is pi/2 radians */
X    else
X         FIG_angle = 0.0;               /* horizontal */
X    return (TRUE);
X}
X 
XFIG_reset()
X{
X    FIG_poly_clean(FIG_polyvec_stat);
X    FIG_posx = FIG_posy = 0;
X    fflush(outfile);
X}
X
X#ifdef MSDOS
X#undef long
X#endif /* MSDOS */
END_OF_FILE
  if test 8468 -ne `wc -c <'gnuplot/term/fig.trm'`; then
    echo shar: \"'gnuplot/term/fig.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/fig.trm'
fi
if test -f 'gnuplot/term/hpljii.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/hpljii.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/hpljii.trm'\" \(8299 characters\)
  sed "s/^X//" >'gnuplot/term/hpljii.trm' <<'END_OF_FILE'
X/*
X * $Id: hpljii.trm%v 3.50.1.11 1993/08/10 03:55:03 woo Exp $
X *
X */
X
X/* GNUPLOT - hpljii.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  hpljii, hpdj
X *
X * AUTHORS
X *  John Engels
X *  Russell Lang
X *  Maurice Castro
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/* The following HP laserjet series II driver uses generic bit mapped graphics
X   routines from bitmap.c to build up a bit map in memory.  The driver
X   interchanges colomns and lines in order to access entire lines
X   easily and returns the lines to get bits in the right order :
X   (x,y) -> (y,XMAX-1-x). */
X/* This interchange is done by calling b_makebitmap() with reversed 
X   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
X   will then perform the interchange before each pixel is plotted */
X/* by John Engels JENGELS@BNANDP51.BITNET, inspired by the hpljet driver
X   of Jyrki Yli-Nokari */
X
X#ifdef HPLJII
X
X/* We define 4 different print qualities : 300ppi, 150ppi, 100ppi and
X   75ppi.  (Pixel size = 1, 2, 3, 4 dots) */
X
X#define HPLJII_DPP (hplj_dpp)   /* dots per pixel */
X#define HPLJII_PPI (300/HPLJII_DPP) /* pixel per inch */
X/* make XMAX and YMAX a multiple of 8 */
X#define HPLJII_XMAX (8*(unsigned int)(xsize*1920/HPLJII_DPP/8.0+0.9))
X#define HPLJII_YMAX (8*(unsigned int)(ysize*1920/HPLJII_DPP/8.0+0.9))
X
X#define HPLJII_VCHAR (HPLJII_PPI/6) /* Courier font with 6 lines per inch */
X#define HPLJII_HCHAR (HPLJII_PPI/10) /* Courier font with 10 caracters
X                                        per inch */
X
X/* default values for term_tbl */
X#define HPLJII_75PPI_XMAX (1920/4)
X#define HPLJII_75PPI_YMAX (1920/4)
X#define HPLJII_75PPI_HCHAR (1920/4/6)
X#define HPLJII_75PPI_VCHAR (1920/4/10)
X#define HPLJII_75PPI_VTIC 5
X#define HPLJII_75PPI_HTIC 5
X
X
X#define HPLJII_PUSH_CURSOR fprintf(outfile,"\033&f0S") /* Save current
X                  cursor position */
X#define HPLJII_POP_CURSOR fprintf(outfile,"\033&f1S") /* Restore
X                  cursor position */
X#define HPLJII_COURIER fprintf(outfile,"\033(0N\033(s0p10.0h12.0v0s0b3T\033&l6D")
X         /* be sure to use courier font with 6lpi and 10cpi */
X
Xstatic int hplj_dpp=4;
X/* bm_pattern not appropriate for 300ppi graphics */
Xstatic unsigned int b_300ppi_pattern[] = {0xffff, 0x1111,
X        0xffff, 0x3333, 0x0f0f, 0x3f3f, 0x0fff, 0x00ff, 0x33ff};
X
XHPLJIIoptions()
X{
Xchar opt[4];
Xint parse_error=0;
X
X	if (END_OF_COMMAND) {
X		term_options[0]='\0';
X	} else {
X		if (token[c_token].length>3) {
X			parse_error=1; /* see below */
X		} else {
X		/* almost_equals() won't accept numbers - use strcmp() instead */
X		capture(opt,c_token,c_token);
X		if (!strcmp(opt,"75")) {
X   			hplj_dpp = 4;
X		}
X		else if (!strcmp(opt,"100")) {
X   			hplj_dpp = 3;
X		}
X		else if (!strcmp(opt,"150")) {
X   			hplj_dpp = 2;
X		}
X		else if (!strcmp(opt,"300")) {
X   			hplj_dpp = 1;
X		} else {
X		/* error, but set dpi anyway, since term it already set */
X				parse_error=1;
X		}
X		c_token++;
X	}
X	}
X
X	term_tbl[term].xmax = HPLJII_XMAX;
X	term_tbl[term].ymax = HPLJII_YMAX;
X	switch(hplj_dpp) {
X		case 1:
X			strcpy(term_options,"300");
X			term_tbl[term].v_tic = 15;
X			term_tbl[term].h_tic = 15;
X			break;
X		case 2:
X			strcpy(term_options,"150");
X			term_tbl[term].v_tic = 8;
X			term_tbl[term].h_tic = 8;
X			break;
X		case 3:
X			strcpy(term_options,"100");
X			term_tbl[term].v_tic = 6;
X			term_tbl[term].h_tic = 6;
X			break;
X		case 4:
X			strcpy(term_options,"75");
X			term_tbl[term].v_tic = 5;
X			term_tbl[term].h_tic = 5;
X			break;
X	}
X
X	if( parse_error ) 
X		int_error("expecting dots per inch size 75, 100, 150 or 300",
X				c_token);
X}
X
X
XHPLJIIinit()
X{
X#ifdef REOPEN_BINARY
X   reopen_binary();
X#endif /* REOPEN_BINARY */
X}
X
X
XHPLJIIgraphics()
X{
X   term_tbl[term].v_char = HPLJII_VCHAR;
X   term_tbl[term].h_char = HPLJII_HCHAR;
X   HPLJII_COURIER;
X   HPLJII_PUSH_CURSOR;
X   /* rotate plot -90 degrees by reversing XMAX and YMAX and by 
X      setting b_rastermode to TRUE */
X   b_makebitmap(HPLJII_YMAX,HPLJII_XMAX,1);
X   b_rastermode = TRUE;
X}
X
X
X/* HPLJIItext by rjl - no compression */
XHPLJIItext()
X{
X  register int x,j,row;
X
X   fprintf(outfile,"\033*t%dR", HPLJII_PPI);
X   HPLJII_POP_CURSOR;
X   fprintf(outfile, "\033*r1A");
X
X   /* dump bitmap in raster mode */
X   for (x = b_xsize-1; x >= 0; x--) {
X      row = (b_ysize/8)-1;
X      fprintf(outfile, "\033*b0m%dW", b_ysize/8);
X      for (j = row; j >= 0; j--) {
X         (void) fputc( (char)(*((*b_p)[j]+x)), outfile );
X      }
X   }
X   fprintf(outfile, "\033*rB");
X
X   b_freebitmap();
X
X#ifndef vms  /* most vms spoolers add a formfeed character */
X   fprintf(outfile,"\f");
X#endif /* not vms */
X}
X
X
X
XHPLJIIlinetype(linetype)
Xint linetype;
X{
X
X   if (hplj_dpp == 1) {
X      if (linetype>=7)
X          linetype %= 7;
X      /* b_pattern not appropriate for 300ppi graphics */
X      b_linemask = b_300ppi_pattern[linetype+2];
X      b_maskcount=0;
X   }
X   else {
X      b_setlinetype(linetype);
X   }
X}
X
X#define HPLJIImove b_move
X#define HPLJIIvector b_vector
X#define HPLJIItext_angle b_text_angle
X
XHPLJIIput_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X   switch (b_angle) {
X      case 0:
X         y -= HPLJII_VCHAR/5;
X         HPLJII_POP_CURSOR;
X         HPLJII_PUSH_CURSOR;
X         /* (0,0) is the upper left point of the paper */
X         fprintf(outfile, "\033*p%+dx%+dY", x*HPLJII_DPP
X                                         ,  (HPLJII_YMAX-y-1)*HPLJII_DPP );
X         fputs(str, outfile);
X/*       for (; *str; ++str, x += HPLJII_HCHAR)
X            HPLJIIputc (x, y, *str, b_angle);*/
X         break;
X      case 1:
X         y += (HPLJII_HCHAR-2*HPLJII_VCHAR)/2;
X         y += (HPLJII_VCHAR+HPLJII_HCHAR)*strlen(str)/2;
X         for (; *str; ++str, y -= HPLJII_VCHAR)
X            HPLJIIputc (x, y, *str, b_angle);
X         break;
X   }
X}
X
XHPLJIIputc(x,y,c,angle)
Xunsigned int x,y;
Xint angle;
Xchar c;
X{
X   HPLJII_POP_CURSOR;
X   HPLJII_PUSH_CURSOR;
X   /* (0,0) is the upper left point of the paper */
X   fprintf(outfile, "\033*p%+dx%+dY", x*HPLJII_DPP
X                                   ,  (HPLJII_YMAX-y-1)*HPLJII_DPP );
X   fputc(c, outfile);
X}
X
X
XHPLJIIreset()
X{
X#ifdef vms
X   fflush_binary();
X#endif /* vms */
X}
X
X
X/* HP DeskJet routines */
XHPDJgraphics()
X{
X	switch(hplj_dpp) {
X		case 1:
X			b_charsize(FNT13X25);
X			term_tbl[term].v_char = FNT13X25_VCHAR;
X			term_tbl[term].h_char = FNT13X25_HCHAR;
X			break;
X		case 2:
X			b_charsize(FNT13X25);
X			term_tbl[term].v_char = FNT13X25_VCHAR;
X			term_tbl[term].h_char = FNT13X25_HCHAR;
X			break;
X		case 3:
X			b_charsize(FNT9X17);
X			term_tbl[term].v_char = FNT9X17_VCHAR;
X			term_tbl[term].h_char = FNT9X17_HCHAR;
X			break;
X		case 4:
X			b_charsize(FNT5X9);
X			term_tbl[term].v_char = FNT5X9_VCHAR;
X			term_tbl[term].h_char = FNT5X9_HCHAR;
X			break;
X	}
X	/* rotate plot -90 degrees by reversing XMAX and YMAX and by 
X	setting b_rastermode to TRUE */
X	b_makebitmap(HPLJII_YMAX,HPLJII_XMAX,1);
X	b_rastermode = TRUE;
X}
X
X
X/* 0 compression raster bitmap dump. Compatible with HP DeskJet 500
X   hopefully compatible with other HP Deskjet printers */
XHPDJtext()
X{
X  register int x,j,row;
X
X   fprintf(outfile,"\033*b0M");
X   fprintf(outfile,"\033*t%dR", HPLJII_PPI);
X   fprintf(outfile, "\033*r1A");
X
X   /* dump bitmap in raster mode */
X   for (x = b_xsize-1; x >= 0; x--) {
X      row = (b_ysize/8)-1;
X      fprintf(outfile, "\033*b%dW", b_ysize/8);
X      for (j = row; j >= 0; j--) {
X         (void) fputc( (char)(*((*b_p)[j]+x)), outfile );
X      }
X   }
X   fprintf(outfile, "\033*rbC");
X
X   b_freebitmap();
X
X#ifndef vms  /* most vms spoolers add a formfeed character */
X   fprintf(outfile,"\f");
X#endif /* not vms */
X}
X
X#define HPDJtext_angle b_text_angle
X#define HPDJput_text b_put_text
X
X#endif /* HPLJII */
X
END_OF_FILE
  if test 8299 -ne `wc -c <'gnuplot/term/hpljii.trm'`; then
    echo shar: \"'gnuplot/term/hpljii.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/hpljii.trm'
fi
if test -f 'gnuplot/term/object.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/object.h'\"
else
  echo shar: Extracting \"'gnuplot/term/object.h'\" \(7748 characters\)
  sed "s/^X//" >'gnuplot/term/object.h' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X#define		DEFAULT		      (-1)
X#define		SOLID_LINE		0
X#define		DASH_LINE		1
X#define		DOTTED_LINE		2
X#define		RUBBER_LINE		3
X/* #define		PANEL_LINE		4  ** not needed for gnuplot */
X
X#define		Color			long
X
X#define		BLACK			0
X#define		WHITE			7
X
Xtypedef struct f_pattern {
X    int		    w, h;
X    int		   *p;
X}
X		F_pattern;
X
Xtypedef struct f_point {
X    int		    x, y;
X    struct f_point *next;
X}
X		F_point;
X
Xtypedef struct f_pos {
X    int		    x, y;
X}
X		F_pos;
X
Xtypedef struct f_arrow {
X    int		    type;
X    int		    style;
X    float	    thickness;
X    float	    wid;
X    float	    ht;
X}
X		F_arrow;
X
Xtypedef struct f_ellipse {
X    int		    tagged;
X    int		    type;
X#define					T_ELLIPSE_BY_RAD	1
X#define					T_ELLIPSE_BY_DIA	2
X#define					T_CIRCLE_BY_RAD		3
X#define					T_CIRCLE_BY_DIA		4
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    int		    direction;
X    float	    style_val;
X    float	    angle;
X    int		    pen;
X    int		    fill_style;
X#define					UNFILLED	0
X#define					WHITE_FILL	1
X#define					BLACK_FILL	21
X    struct f_pos    center;
X    struct f_pos    radiuses;
X    struct f_pos    start;
X    struct f_pos    end;
X    struct f_ellipse *next;
X}
X		F_ellipse;
X
Xtypedef struct f_arc {
X    int		    tagged;
X    int		    type;
X#define					T_3_POINTS_ARC		1
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    int		    pen;
X    int		    fill_style;
X    float	    style_val;
X    int		    direction;
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    struct {
X	float		x, y;
X    }		    center;
X    struct f_pos    point[3];
X    struct f_arc   *next;
X}
X		F_arc;
X
X#define		CLOSED_PATH		0
X#define		OPEN_PATH		1
X#define		DEF_BOXRADIUS		7
X#define		DEF_DASHLENGTH		4
X#define		DEF_DOTGAP		3
X
Xtypedef struct f_line {
X    int		    tagged;
X    int		    type;
X#define					T_POLYLINE	1
X#define					T_BOX		2
X#define					T_POLYGON	3
X#define					T_ARC_BOX	4
X#define					T_EPS_BOX	5
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    float	    style_val;
X    int		    pen;
X    int		    fill_style;
X    int		    radius;	/* corner radius for T_ARC_BOX */
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    struct f_point *points;
X    struct f_eps   *eps;
X    struct f_line  *next;
X}
X		F_line;
X
Xtypedef struct f_text {
X    int		    tagged;
X    int		    type;
X#define					T_LEFT_JUSTIFIED	0
X#define					T_CENTER_JUSTIFIED	1
X#define					T_RIGHT_JUSTIFIED	2
X    int		    font;
X    int		    size;	/* point size */
X    Color	    color;
X    int		    depth;
X    float	    angle;	/* in radian */
X
X    int		    flags;
X#define					RIGID_TEXT		1
X#define					SPECIAL_TEXT		2
X#define					PSFONT_TEXT		4
X#define					HIDDEN_TEXT		8
X
X    int		    height;	/* pixels */
X    int		    length;	/* pixels */
X    int		    base_x;
X    int		    base_y;
X    int		    pen;
X    char	   *cstring;
X    struct f_text  *next;
X}
X		F_text;
X
X#define MAXFONT(T) (psfont_text(T) ? NUM_PS_FONTS : NUM_LATEX_FONTS)
X
X#define		rigid_text(t) \
X			(t->flags == DEFAULT \
X				|| (t->flags & RIGID_TEXT))
X
X#define		special_text(t) \
X			((t->flags != DEFAULT \
X				&& (t->flags & SPECIAL_TEXT)))
X
X#define		psfont_text(t) \
X			(t->flags != DEFAULT \
X				&& (t->flags & PSFONT_TEXT))
X
X#define		hidden_text(t) \
X			(t->flags != DEFAULT \
X				&& (t->flags & HIDDEN_TEXT))
X
X#define		text_length(t) \
X			(hidden_text(t) ? hidden_text_length : t->length)
X
X#define		using_ps	(cur_textflags & PSFONT_TEXT)
X
Xtypedef struct f_control {
X    float	    lx, ly, rx, ry;
X    struct f_control *next;
X}
X		F_control;
X
X#define		int_spline(s)		(s->type & 0x2)
X#define		normal_spline(s)	(!(s->type & 0x2))
X#define		closed_spline(s)	(s->type & 0x1)
X#define		open_spline(s)		(!(s->type & 0x1))
X
Xtypedef struct f_spline {
X    int		    tagged;
X    int		    type;
X#define					T_OPEN_NORMAL	0
X#define					T_CLOSED_NORMAL 1
X#define					T_OPEN_INTERP	2
X#define					T_CLOSED_INTERP 3
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    float	    style_val;
X    int		    pen;
X    int		    fill_style;
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    /*
X     * For T_OPEN_NORMAL and T_CLOSED_NORMAL points are control points while
X     * they are knots for T_OPEN_INTERP and T_CLOSED_INTERP whose control
X     * points are stored in controls.
X     */
X    struct f_point *points;
X    struct f_control *controls;
X    struct f_spline *next;
X}
X		F_spline;
X
Xtypedef struct f_compound {
X    int		    tagged;
X    struct f_pos    nwcorner;
X    struct f_pos    secorner;
X    struct f_line  *lines;
X    struct f_ellipse *ellipses;
X    struct f_spline *splines;
X    struct f_text  *texts;
X    struct f_arc   *arcs;
X    struct f_compound *compounds;
X    struct f_compound *next;
X}
X		F_compound;
X
Xtypedef struct f_linkinfo {
X    struct f_line  *line;
X    struct f_point *endpt;
X    struct f_point *prevpt;
X    int		    two_pts;
X    struct f_linkinfo *next;
X}
X		F_linkinfo;
X
X#define		ARROW_SIZE		sizeof(struct f_arrow)
X#define		POINT_SIZE		sizeof(struct f_point)
X#define		CONTROL_SIZE		sizeof(struct f_control)
X#define		ELLOBJ_SIZE		sizeof(struct f_ellipse)
X#define		ARCOBJ_SIZE		sizeof(struct f_arc)
X#define		LINOBJ_SIZE		sizeof(struct f_line)
X#define		TEXOBJ_SIZE		sizeof(struct f_text)
X#define		SPLOBJ_SIZE		sizeof(struct f_spline)
X#define		COMOBJ_SIZE		sizeof(struct f_compound)
X#define		EPS_SIZE		sizeof(struct f_eps)
X#define		LINKINFO_SIZE		sizeof(struct f_linkinfo)
X
X/**********************	 object codes  **********************/
X
X#define		O_ELLIPSE		1
X#define		O_POLYLINE		2
X#define		O_SPLINE		3
X#define		O_TEXT			4
X#define		O_ARC			5
X#define		O_COMPOUND		6
X#define		O_END_COMPOUND		-O_COMPOUND
X#define		O_ALL_OBJECT		99
X
X/*********************	object masks  ************************/
X
X#define M_NONE			0x000
X#define M_POLYLINE_POLYGON	0x001
X#define M_POLYLINE_LINE		0x002
X#define M_POLYLINE_BOX		0x004	/* includes ARCBOX */
X#define M_SPLINE_O_NORMAL	0x008
X#define M_SPLINE_C_NORMAL	0x010
X#define M_SPLINE_O_INTERP	0x020
X#define M_SPLINE_C_INTERP	0x040
X#define M_TEXT_NORMAL		0x080
X#define M_TEXT_HIDDEN		0x100
X#define M_ARC			0x200
X#define M_ELLIPSE		0x400
X#define M_COMPOUND		0x800
X
X#define M_TEXT		(M_TEXT_HIDDEN | M_TEXT_NORMAL)
X#define M_SPLINE_O	(M_SPLINE_O_NORMAL | M_SPLINE_O_INTERP)
X#define M_SPLINE_C	(M_SPLINE_C_NORMAL | M_SPLINE_C_INTERP)
X#define M_SPLINE_NORMAL (M_SPLINE_O_NORMAL | M_SPLINE_C_NORMAL)
X#define M_SPLINE_INTERP (M_SPLINE_O_INTERP | M_SPLINE_C_INTERP)
X#define M_SPLINE	(M_SPLINE_NORMAL | M_SPLINE_INTERP)
X#define M_POLYLINE	(M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_POLYLINE_BOX)
X#define M_VARPTS_OBJECT (M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_SPLINE)
X#define M_OPEN_OBJECT	(M_POLYLINE_LINE | M_SPLINE_O | M_ARC)
X#define M_ROTATE_ANGLE	(M_VARPTS_OBJECT | M_ARC | M_TEXT | M_COMPOUND)
X#define M_OBJECT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_TEXT | M_ARC)
X#define M_NO_TEXT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_COMPOUND | M_ARC)
X#define M_ALL		(M_OBJECT | M_COMPOUND)
END_OF_FILE
  if test 7748 -ne `wc -c <'gnuplot/term/object.h'`; then
    echo shar: \"'gnuplot/term/object.h'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/object.h'
fi
if test -f 'gnuplot/term/pstricks.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/pstricks.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/pstricks.trm'\" \(7730 characters\)
  sed "s/^X//" >'gnuplot/term/pstricks.trm' <<'END_OF_FILE'
X/*
X * $Id: pstricks.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - pstricks.trm */
X/*
X * Copyright (C) 1990 - 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   The PSTricks macros for LaTeX.
X *
X * AUTHORS
X *   David Kotz
X *
X *   Raymond Toy	toy@soho.crd.ge.com
X *	Modified the eepic.trm file to use PSTricks macros instead.
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X/*
X *  This file contains the PSTricks terminal driver, intended for use with the
X *  pstricks.sty macro package for LaTeX. This is an alternative to the
X *  eepic and latex driver. You need pstricks.sty, and, of course, a printer
X *  that understands PostScript.  Ghostscript understands Postscript too.
X *
X *  PSTricks is available via anonymous ftp from the /pub directory
X *  at Princeton.EDU.  This driver comes definitely does not come close to
X *  using the full capability of the PSTricks package.
X */
X
X#define PSTRICKS_PTS_PER_INCH (72.27)
X#define DOTS_PER_INCH (300)		/* resolution of printer we expect to use */
X#define PSTRICKS_UNIT (PSTRICKS_PTS_PER_INCH/DOTS_PER_INCH)	/* dot size in pt */
X
X/* 5 inches wide by 3 inches high (default) */
X#define PSTRICKS_XMAX (5*DOTS_PER_INCH)	/* (PSTRICKS_PTS_PER_INCH/PSTRICKS_UNIT*5.0) */
X#define PSTRICKS_YMAX (3*DOTS_PER_INCH)	/* (PSTRICKS_PTS_PER_INCH/PSTRICKS_UNIT*3.0) */
X
X#define PSTRICKS_HTIC (5*DOTS_PER_INCH/72)	/* (5./PSTRICKS_UNIT) */
X#define PSTRICKS_VTIC (5*DOTS_PER_INCH/72)	/* (5./PSTRICKS_UNIT) */
X#define PSTRICKS_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3/PSTRICKS_UNIT) */
X#define PSTRICKS_VCHAR (DOTS_PER_INCH*11/72)	/* (11./PSTRICKS_UNIT) */
X
Xstatic unsigned int PSTRICKS_posx;
Xstatic unsigned int PSTRICKS_posy;
Xenum JUSTIFY    PSTRICKS_justify = LEFT;
Xstatic int      PSTRICKS_angle = 0;
X
X#define	PSTRICKS_TINY_DOT	0.25	/* A tiny dot, in points */
X
X/* POINTS */
X#define PSTRICKS_POINT_TYPES 12		/* we supply more point types */
Xstatic char  GPFAR * GPFAR PSTRICKS_points[] =
X{
X    "\\psset{dotstyle=square, dotangle=45}",
X    "\\psset{dotstyle=+}",
X    "\\psset{dotstyle=square}",
X    "\\psset{dotstyle=+, dotangle=45}",
X    "\\psset{dotstyle=triangle}",
X    "\\psset{dotstyle=pentagon}",
X    "\\psset{dotstyle=o}",
X    "\\psset{dotstyle=square*, dotangle=45}",
X    "\\psset{dotstyle=square*}",
X    "\\psset{dotstyle=triangle*}",
X    "\\psset{dotstyle=pentagon*}",
X    "\\psset{dotstyle=*}",
X};
X
X/* LINES */
X#define PSTRICKS_NUMLINES 6		/* number of linetypes below */
Xstatic char  GPFAR * GPFAR PSTRICKS_lines[] =
X{
X    "\\psset{linewidth=0.35pt,linestyle=solid}",		/* -2 border		*/
X    "\\psset{linewidth=0.3pt,linestyle=dotted,dotsep=1pt}",	/* -1 axes, grid	*/
X    "\\psset{linewidth=0.35pt,linestyle=solid}",		/*  0 solid thin	*/
X    "\\psset{linewidth=0.35pt,linestyle=dashed,dash=5pt 3pt}",	/*  1 dashed		*/
X    "\\psset{linewidth=0.35pt,linestyle=dotted,dotsep=3pt}",	/*  2 dotted		*/
X    "\\psset{linewidth=0.35pt,linestyle=dashed,dash=10pt 3pt}"	/*  3 long dash	*/
X};
X
Xstatic int      PSTRICKS_type;		/* current line type */
Xstatic TBOOLEAN  PSTRICKS_inline = FALSE;/* are we in the middle of a line */
Xstatic void     PSTRICKS_endline();	/* terminate any line in progress */
Xstatic int      PSTRICKS_linecount = 0;	/* number of points in line so far */
X
X#define PSTRICKS_LINEMAX 50		/* max value for linecount */
X
XPSTRICKS_init()
X{
X    PSTRICKS_posx = PSTRICKS_posy = 0;
X    PSTRICKS_linetype(-1);
X    fprintf(outfile, "%% GNUPLOT: LaTeX picture using PSTRICKS macros\n");
X    fprintf(outfile, "\\psset{unit=%fpt}\n", PSTRICKS_UNIT);
X    fprintf(outfile, "\\psset{arrowsize=3pt 3.2 1.4 .3}\n");
X}
X
X
XPSTRICKS_scale(xs, ys)
X    double          xs, ys;		/* scaling factors */
X{
X    register struct termentry *t = &term_tbl[term];
X
X    /* we change the table for use in graphics.c and PSTRICKS_graphics */
X    t->xmax = (unsigned int) (PSTRICKS_XMAX * xs);
X    t->ymax = (unsigned int) (PSTRICKS_YMAX * ys);
X
X    return (TRUE);
X}
X
XPSTRICKS_graphics()
X{
X    register struct termentry *t = &term_tbl[term];
X
X    fprintf(outfile, "\\begin{pspicture}(0,0)(%d,%d)\n", t->xmax, t->ymax);
X    fprintf(outfile, "\\tenrm\n");
X}
X
X
XPSTRICKS_text()
X{
X    PSTRICKS_endline();
X    fprintf(outfile, "\\end{pspicture}\n");
X}
X
X
XPSTRICKS_linetype(linetype)
X    int             linetype;
X{
X    PSTRICKS_endline();
X
X    if (linetype >= PSTRICKS_NUMLINES - 2)
X	linetype %= (PSTRICKS_NUMLINES - 2);
X
X    PSTRICKS_type = linetype;
X}
X
X
X
XPSTRICKS_move(x, y)
X    unsigned int    x, y;
X{
X    PSTRICKS_endline();
X
X    PSTRICKS_posx = x;
X    PSTRICKS_posy = y;
X}
X
X
XPSTRICKS_point(x, y, number)		/* version of line_and_point */
X    unsigned int    x, y;
X    int             number;		/* type of point */
X{
X    PSTRICKS_move(x, y);
X
X    /* Print the character defined by 'number'; number < 0 means
X	  to use a dot, otherwise one of the defined points. */
X
X    if (number < 0) {
X	fprintf(outfile, "\\qdisk(%d,%d){%fpt}\n",
X		x, y, PSTRICKS_TINY_DOT);
X    } else {
X	fprintf(outfile, "%s\\psdots(%d,%d)\n",
X		PSTRICKS_points[number % PSTRICKS_POINT_TYPES],
X		x, y);
X    }
X}
X
X
XPSTRICKS_vector(ux, uy)
X    unsigned int    ux, uy;
X{
X    if (!PSTRICKS_inline) {
X	PSTRICKS_inline = TRUE;
X
X	/* Start a new line. This depends on line type */
X	fprintf(outfile, "%s\\psline(%u,%u)",
X		PSTRICKS_lines[PSTRICKS_type + 2],
X		PSTRICKS_posx, PSTRICKS_posy);
X	PSTRICKS_linecount = 1;
X    } else {
X	/*
X	 * Even though we are in middle of a path,
X	 * we may want to start a new path command.
X	 * If they are too long then latex will choke.
X	 */
X	if (PSTRICKS_linecount++ >= PSTRICKS_LINEMAX) {
X	    fprintf(outfile, "\n");
X	    fprintf(outfile, "%s\\psline(%u,%u)",
X		    PSTRICKS_lines[PSTRICKS_type + 2],
X		    PSTRICKS_posx, PSTRICKS_posy);
X	    PSTRICKS_linecount = 1;
X	}
X    }
X    fprintf(outfile, "(%u,%u)", ux, uy);
X    PSTRICKS_posx = ux;
X    PSTRICKS_posy = uy;
X}
X
Xstatic void
XPSTRICKS_endline()
X{
X    if (PSTRICKS_inline) {
X	fprintf(outfile, "\n");
X	PSTRICKS_inline = FALSE;
X    }
X}
X
X
XPSTRICKS_arrow(sx, sy, ex, ey, head)
X    int             sx, sy, ex, ey;
X    TBOOLEAN         head;
X{
X    fprintf(outfile, "\\psline[linestyle=solid]%s(%d,%d)(%d,%d)\n",
X	    head ? "{->}" : "",
X	    sx, sy, ex, ey);
X
X    PSTRICKS_posx = ex;
X    PSTRICKS_posy = ey;
X}
X
X
XPSTRICKS_put_text(x, y, str)
X    int             x, y;		/* reference point of string */
X    char            str[];		/* the text */
X{
X    PSTRICKS_endline();
X
X    fprintf(outfile, "\\rput");
X
X    /* Set justification */
X
X    switch (PSTRICKS_justify) {
X    case LEFT:
X	fprintf(outfile, "[l]");
X	break;
X    case CENTRE:
X	break;
X    case RIGHT:
X	fprintf(outfile, "[r]");
X	break;
X    }
X
X    /* Set text angle */
X
X    switch (PSTRICKS_angle) {
X    case 0:
X	break;
X    case 1:
X	fprintf(outfile, "{L}");
X	break;
X    }
X
X    /* Set reference position and text */
X
X    fprintf(outfile, "(%d,%d){%s}\n", x, y, str);
X
X}
X
X
X
Xint 
XPSTRICKS_justify_text(mode)
X    enum JUSTIFY    mode;
X{
X    PSTRICKS_justify = mode;
X    return (TRUE);
X}
X
Xint 
XPSTRICKS_text_angle(angle)
X    int             angle;
X{
X    PSTRICKS_angle = angle;
X    return (TRUE);
X}
X
XPSTRICKS_reset()
X{
X    PSTRICKS_endline();
X    PSTRICKS_posx = PSTRICKS_posy = 0;
X}
X
END_OF_FILE
  if test 7730 -ne `wc -c <'gnuplot/term/pstricks.trm'`; then
    echo shar: \"'gnuplot/term/pstricks.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/pstricks.trm'
fi
if test -f 'gnuplot/term/vws.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/vws.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/vws.trm'\" \(8085 characters\)
  sed "s/^X//" >'gnuplot/term/vws.trm' <<'END_OF_FILE'
X/*
X * $Id: vws.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - vws.trm */
X/*
X * Copyright (C) 1990 - 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   IRIS terminals
X *
X * AUTHORS
X *   Walter Speth
X *           BITNET: SPETH@DBNPIB5
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X 
X#define VWS_XMAX   1024
X#define VWS_YMAX   780
X#define VWS_VCHAR  25
X#define VWS_HCHAR  15
X#define VWS_VTIC   10
X#define VWS_HTIC   10
X 
X#include stdio
X/*
X#include math
X#include ssdef
X*/
X#include descrip
X 
X#include <uisentry.h>
X#include <uisusrdef.h>
X 
X 
X#define DEFAULT_ATTR 0
X#define OVER_ATTR 1
X#define ERAS_ATTR 2
X#define BIS_ATTR 3
X#define COLOR_ATTR 4
X#define TEXT_ATTR 5
X#define LINE_ATTR 6
X#define BACK_ATTR 7
X 
X 
Xfloat current_x, current_y;
X 
X 
Xint vd_id, wd_id;
Xint vcm_id;
X 
Xstatic $DESCRIPTOR(ws_devname, "SYS$WORKSTATION");
Xstatic $DESCRIPTOR(vd_title, "gnuplot");
X 
Xstatic float x0, y0, xsiz, ysiz,
X             wc_xmin_new, wc_ymin_new, wc_xmax_new, wc_ymax_new,
X             wc_xmin, wc_ymin, wc_xmax, wc_ymax,
X             vd_width, vd_height;
X 
XVWS_resize_ast()
X{ uis$resize_window(&vd_id, &wd_id, &x0, &y0, &xsiz, &ysiz,
X                     &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax);
X  replotrequest();
X}
X/****************************************************************************/
XVWS_init()
X 
X 
X{
X  int i;
X  int cattr;
X  $DESCRIPTOR(a_font,"DTABER0003WK00PG0001UZZZZ02A000");
X 
X  vd_width  = 14;
X  vd_height = 10; /* aspect sqrt(2) as DIN A paper */
X 
X  wc_xmin = 0.0;
X  wc_ymin = 0.0;
X  wc_xmax = (float) VWS_XMAX;
X  wc_ymax = (float) VWS_YMAX;
X 
X  vcm_id = uis$create_color_map(&8);
X 
X  vd_id = uis$create_display(&wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax,
X                             &vd_width, &vd_height, &vcm_id);
X 
X  uis$set_color(&vd_id, &0, &.5, &.5, &.5);
X  uis$set_color(&vd_id, &1, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &2, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &3, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &4, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &5, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &6, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &7, &0.0, &0.0, &0.0);
X 
X/*
X  uis$set_color(&vd_id, &2, &.2, &.2, &.2);
X  uis$set_color(&vd_id, &3, &.3, &.3, &.3);
X  uis$set_color(&vd_id, &4, &.4, &.4, &.4);
X  uis$set_color(&vd_id, &5, &.5, &.5, &.5);
X  uis$set_color(&vd_id, &6, &.6, &.6, &.6);
X  uis$set_color(&vd_id, &7, &.7, &.7, &.7);
X 
X/* perhaps better for color terms (which I do not have)
X  uis$set_color(&vd_id, &0, &0.0, &0.0, &0.0);
X  uis$set_color(&vd_id, &1, &0.9, &0.0, &0.0);
X  uis$set_color(&vd_id, &2, &0.0, &0.9, &0.0);
X  uis$set_color(&vd_id, &3, &0.9, &0.9, &0.0);
X  uis$set_color(&vd_id, &4, &0.0, &0.0, &0.9);
X  uis$set_color(&vd_id, &5, &0.9, &0.0, &0.9);
X  uis$set_color(&vd_id, &6, &0.0, &0.9, &0.9);
X  uis$set_color(&vd_id, &7, &0.9, &0.9, &0.9);
X/*
X*/
X  uis$disable_display_list(&vd_id);
X 
X  wd_id = uis$create_window(&vd_id, &ws_devname, &vd_title,
X                            &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax,
X                            &vd_width, &vd_height);
X 
X  uis$set_resize_ast(&vd_id, &wd_id, &VWS_resize_ast, &0,
X                     &x0, &y0, &xsiz, &ysiz,
X                     &wc_xmin_new, &wc_ymin_new, &wc_xmax_new, &wc_ymax_new);
X 
X  uis$set_writing_mode(&vd_id, &DEFAULT_ATTR, &OVER_ATTR, &UIS$C_MODE_OVER);
X  uis$set_writing_mode(&vd_id, &DEFAULT_ATTR, &ERAS_ATTR, &UIS$C_MODE_ERAS);
X  uis$set_writing_mode(&vd_id, &DEFAULT_ATTR, &BIS_ATTR, &UIS$C_MODE_BIS);
X/*
X  for (i=0; i<8; i++) {
X    cattr = COLOR_ATTR+i;
X    uis$set_writing_index(&vd_id, &COPY_ATTR, &cattr, &i);
X    }
X*/
X  uis$set_background_index(&vd_id, &DEFAULT_ATTR, &BACK_ATTR, &0);
X  uis$set_writing_mode(&vd_id, &DEFAULT_ATTR, &TEXT_ATTR, &UIS$C_MODE_OVER);
X  uis$set_font(&vd_id,&TEXT_ATTR,&TEXT_ATTR,&a_font);
X  uis$set_char_size(&vd_id,&TEXT_ATTR,&TEXT_ATTR,&0,
X                    &(float)VWS_HCHAR,&(float)VWS_VCHAR);
X  uis$set_line_style(&vd_id,&LINE_ATTR,&LINE_ATTR,&0xFFFFFFFF);
X}
X 
X/****************************************************************************/
X 
XVWS_reset()
X{
X  uis$delete_display(&vd_id);
X}
X/****************************************************************************/
XVWS_scale(xs,ys)
Xint xs,ys;
X{
X        return FALSE;
X}
X/****************************************************************************/
XVWS_graphics()
X{
X    uis$erase(&vd_id, &wc_xmin, &wc_ymin, &wc_xmax, &wc_ymax);
X}
X/****************************************************************************/
XVWS_text()
X{
X}
X/****************************************************************************/
XVWS_move(x,y)
Xint x,y;
X{
X  current_x= (float)(x);
X  current_y= (float)(y);
X}
X/****************************************************************************/
XVWS_vector(x,y)
Xint x,y;
X{ int col;
X  float fx,fy;
X  fx=(float) x;
X  fy=(float) y;
X 
X      uis$line(&vd_id, &LINE_ATTR,
X               &current_x, &current_y, &fx, &fy);
X      VWS_move (x,y);
X}
X/****************************************************************************/
XVWS_linetype(lt)
Xint lt;
X{
Xlong int lstyle[9]={    0xffffffff,
X                        0Xff00ff00,
X                        0xffffff00,
X                        0xffff0000,
X                        0xf0f0f0f0,
X                        0Xfff0fff0,
X                        0xf000f000,
X                        0xa5a5a5af,
X                        0xf00f00f0 };
X 
X  switch(lt) {
Xcase -1: uis$set_line_style(&vd_id,&LINE_ATTR,&LINE_ATTR,&0xFFFFFFFF);
X         uis$set_line_width(&vd_id,&LINE_ATTR,&LINE_ATTR,&1.5);
X         break;
Xcase -2: uis$set_line_style(&vd_id,&LINE_ATTR,&LINE_ATTR,&0xFFFFFFFF);
X         uis$set_line_width(&vd_id,&LINE_ATTR,&LINE_ATTR,&2.0);
X         break;
X/*
Xdefault:  uis$set_line_style(&vd_id,&LINE_ATTR,&LINE_ATTR,&lstyle[lt % 8]);
X          makes part of curve disappear on my workstation
X*/
Xdefault:  uis$set_line_style(&vd_id,&LINE_ATTR,&LINE_ATTR,&0xFFFFFFFF);
X         uis$set_line_width(&vd_id,&LINE_ATTR,&LINE_ATTR,&1.0);
X}
X}
X 
X/****************************************************************************/
Xstatic int justify_mode =CENTRE,up;;
X 
XVWS_put_text(x,y,str)
Xint x,y; char* str;
X{
X  float fx,fy, thih, twid;
X 
X 
X/* uis$text parameter is descriptor string not character string */
X 
X  struct dsc$descriptor_s textline = {0,DSC$K_DTYPE_T,DSC$K_CLASS_S,""};
X 
X 
X  textline.dsc$a_pointer = str;
X  textline.dsc$w_length = strlen(textline.dsc$a_pointer);
X  uis$measure_text(&vd_id,&TEXT_ATTR,&textline,&twid,&thih);
X  fx=(float)x;
X  fy=(float)y;
X 
X  switch (justify_mode) {
X  case LEFT : fy+=thih/2.;
X              break;
X  case RIGHT : fy+=thih/2.;
X               fx-=twid;
X              break;
X 
X  case CENTRE : fy+=thih/2.;
X               fx-=twid/2;
X              break;
X  };
X 
X  uis$text(&vd_id,&TEXT_ATTR,&textline,&fx,&fy);
X     /* write to Example Viewport window */
X 
X 
X}
X/****************************************************************************/
XVWS_text_angle(ang)
Xint ang;
X{
X  float degrees;
X  degrees=90.*(up=ang);
X  uis$set_text_slope (&vd_id, &TEXT_ATTR, &TEXT_ATTR, &degrees);
Xreturn TRUE;
X}
X/****************************************************************************/
XVWS_justify_text(mode)
Xint mode;
X{ justify_mode=mode;
Xreturn TRUE;
X}
X/****************************************************************************/
XVWS_point(x,y,point)
Xint x,y,point;
X{
Xdo_point(x,y,point);
X}
X/****************************************************************************/
XVWS_arrow(sx,sy,ex,ey)
Xint sx,sy,ex,ey;
X{
Xdo_arrow(sx,sy,ex,ey);
X}
END_OF_FILE
  if test 8085 -ne `wc -c <'gnuplot/term/vws.trm'`; then
    echo shar: \"'gnuplot/term/vws.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/vws.trm'
fi
if test -f 'gnuplot/win/wgnuplib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wgnuplib.h'\"
else
  echo shar: Extracting \"'gnuplot/win/wgnuplib.h'\" \(8074 characters\)
  sed "s/^X//" >'gnuplot/win/wgnuplib.h' <<'END_OF_FILE'
X/*
X * $Id: wgnuplib.h%v 3.50.1.13 1993/08/19 03:21:26 woo Exp $
X */
X
X/* GNUPLOT - win/wgnuplib.h */
X/*
X * Copyright (C) 1992   Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Russell Lang
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X */
X
X/* this file contains items to be visible outside wgnuplot.dll */
X
X#ifdef _WINDOWS
X#define _Windows
X#endif
X
X#ifdef __DLL__
X#define WDPROC WINAPI _export
X#else
X#define WDPROC WINAPI
X#endif
X
X#define WGNUPLOTVERSION  "1.1   1993-08-14"
XBOOL WDPROC CheckWGNUPLOTVersion(LPSTR str);
X
X/* ================================== */
X/* For WIN32 API's 
X#ifdef WIN32
X#define DEFAULT_CHARSET ANSI_CHARSET
X#define OFFSETOF(x)  (x)
X#define SELECTOROF(x)  (x)
X#define MoveTo(hdc,x,y) MoveToEx(hdc,x,y,(LPPOINT)NULL);
X#endif
X 
X/* ================================== */
X/* wprinter.c - windows printer routines */
Xvoid WDPROC DumpPrinter(HWND hwnd, LPSTR szAppName, LPSTR szFileName);
X
Xtypedef struct tagPRINT {
X	HDC		hdcPrn;
X	HWND	hDlgPrint;
X	BOOL	bUserAbort;
X	POINT	pdef;
X	POINT	psize;
X	POINT	poff;
X	struct tagPRINT FAR *next;
X} PRINT;
Xtypedef PRINT FAR*  LPPRINT;
X
X/* ================================== */
X/* wpause.c - pause window structure */
Xtypedef struct tagPW
X{
X	HINSTANCE	hInstance;		/* required */
X	HINSTANCE	hPrevInstance;	/* required */
X	LPSTR	Title;			/* required */
X	LPSTR	Message;		/* required */
X	POINT	Origin;			/* optional */
X	HWND	hWndParent;		/* optional */
X	HWND	hWndPause;
X	HWND	hOK;
X	HWND	hCancel;
X	BOOL	bPause;
X	BOOL	bPauseCancel;
X	BOOL	bDefOK;
X	WNDPROC	lpfnOK;
X	WNDPROC	lpfnCancel;
X	WNDPROC	lpfnPauseButtonProc;
X} PW;
Xtypedef PW FAR*  LPPW;
X
Xint WDPROC PauseBox(LPPW lppw);
X
X/* ================================== */
X/* wmenu.c - menu structure */
X#define BUTTONMAX 10
Xtypedef struct tagMW
X{
X	LPSTR	szMenuName;		/* required */
X	HMENU	hMenu;
X	BYTE FAR * FAR *macro;
X	BYTE FAR *macrobuf;
X	int		nCountMenu;
X	DLGPROC	lpProcInput;
X	char	*szPrompt;
X	char	*szAnswer;
X	int		nChar;
X	int		nButton;
X	HWND	hButton[BUTTONMAX];
X	int		hButtonID[BUTTONMAX];
X	WNDPROC	lpfnMenuButtonProc;
X	WNDPROC	lpfnButtonProc[BUTTONMAX];
X} MW;
Xtypedef MW FAR * LPMW;
X
X/* ================================== */
X/* wtext.c text window structure */
X/* If an optional item is not specified it must be zero */
X#define MAXFONTNAME 80
Xtypedef struct tagTW
X{
X	LPPRINT	lpr;			/* must be first */
X	HINSTANCE hInstance;		/* required */
X	HINSTANCE hPrevInstance;	/* required */
X	LPSTR	Title;			/* required */
X	LPMW	lpmw;			/* optional */
X	POINT	ScreenSize;		/* optional */
X	unsigned int KeyBufSize;	/* optional */
X	LPSTR	IniFile;		/* optional */
X	LPSTR	IniSection;		/* optional */
X	LPSTR	DragPre;		/* optional */
X	LPSTR	DragPost;		/* optional */
X	int		nCmdShow;		/* optional */
X	FARPROC shutdown;		/* optional */
X	HICON	hIcon;			/* optional */
X	LPSTR   AboutText;		/* optional */
X	HMENU	hPopMenu;
X	HWND	hWndText;
X	HWND	hWndParent;
X	POINT	Origin;
X	POINT	Size;
X	BYTE FAR *ScreenBuffer;
X	BYTE FAR *AttrBuffer;
X	BYTE FAR *KeyBuf;
X	BYTE FAR *KeyBufIn;
X	BYTE FAR *KeyBufOut;
X	BYTE	Attr;
X	BOOL	bFocus;
X	BOOL	bGetCh;
X	BOOL	bSysColors;
X	HBRUSH	hbrBackground;
X	char	fontname[MAXFONTNAME];	/* font name */
X	int		fontsize;				/* font size in pts */
X	HFONT	hfont;
X	int		CharAscent;
X	int		ButtonHeight;
X	int		CaretHeight;
X	int		CursorFlag;
X	POINT	CursorPos;
X	POINT	ClientSize;
X	POINT	CharSize;
X	POINT	ScrollPos;
X	POINT	ScrollMax;
X	POINT	MarkBegin;
X	POINT	MarkEnd;
X	BOOL	Marking;
X} TW;
Xtypedef TW FAR*  LPTW;
X
X
X/* ================================== */
X/* wtext.c - Text Window */
Xvoid WDPROC TextMessage(void);
Xint WDPROC TextInit(LPTW lptw);
Xvoid WDPROC TextClose(LPTW lptw);
Xvoid WDPROC TextToCursor(LPTW lptw);
Xint WDPROC  TextKBHit(LPTW);
Xint WDPROC TextGetCh(LPTW);
Xint WDPROC TextGetChE(LPTW);
XLPSTR WDPROC TextGetS(LPTW lptw, LPSTR str, unsigned int size);
Xint WDPROC TextPutCh(LPTW, BYTE);
Xint WDPROC TextPutS(LPTW lptw, LPSTR str);
Xvoid WDPROC TextGotoXY(LPTW lptw, int x, int y);
Xint  WDPROC TextWhereX(LPTW lptw);
Xint  WDPROC TextWhereY(LPTW lptw);
Xvoid WDPROC TextCursorHeight(LPTW lptw, int height);
Xvoid WDPROC TextClearEOL(LPTW lptw);
Xvoid WDPROC TextClearEOS(LPTW lptw);
Xvoid WDPROC TextInsertLine(LPTW lptw);
Xvoid WDPROC TextDeleteLine(LPTW lptw);
Xvoid WDPROC TextScrollReverse(LPTW lptw);
Xvoid WDPROC TextAttr(LPTW lptw, BYTE attr);
Xvoid WDPROC AboutBox(HWND hwnd, LPSTR str);
X
X/* ================================== */
X/* wgraph.c - graphics window */
X
X/* windows data */
X#define WGNUMPENS 15
X
X#define GWOPMAX 4096
X/* GWOP is 8 bytes long. Array of GWOP kept in global block */
Xstruct GWOP {
X	WORD op;
X	WORD x, y; 
X	HLOCAL htext;
X};
X
X/* memory block for graph operations */
Xstruct GWOPBLK {			/* kept in local memory */
X	struct GWOPBLK *next;
X	HGLOBAL hblk;			/* handle to a global block */
X	struct GWOP FAR *gwop;	/* pointer to global block if locked */
X	UINT used;				/* number of GWOP's used */
X};
X
X/* ops */
X#define W_endoflist 0
X#define W_dot 10
X#define W_diamond 11
X#define W_plus 12
X#define W_box 13
X#define W_cross 14
X#define W_triangle 15
X#define W_star 16
X#define W_move 20
X#define W_vect 21
X#define W_line_type 22
X#define W_put_text 23
X#define W_justify 24
X#define W_text_angle 25
X
Xtypedef struct tagGW {
X	LPPRINT	lpr;			/* must be first */
X	HINSTANCE	hInstance;		/* required */
X	HINSTANCE	hPrevInstance;	/* required */
X	LPSTR	Title;			/* required */
X	int		xmax;			/* required */
X	int		ymax;			/* required */
X	LPTW	lptw;		/* optional */  /* associated text window */
X	POINT	Origin;		/* optional */	/* origin of graph window */
X	POINT	Size;		/* optional */	/* size of graph window */
X	LPSTR	IniFile;	/* optional */
X	LPSTR	IniSection;	/* optional */
X	HWND	hWndGraph;	/* window handle */
X	HMENU	hPopMenu;	/* popup menu */
X	int		numsolid;	/* number of solid pen styles */
X	int		pen;		/* current pen number */
X	int		htic;		/* horizontal size of point symbol (xmax units) */
X	int 	vtic;		/* vertical size of point symbol (ymax units)*/
X	int		hchar;		/* horizontal size of character (xmax units) */
X	int		vchar;		/* vertical size of character (ymax units)*/
X	int		angle;		/* text angle */
X	BOOL	rotate;		/* can text be rotated 90 degrees ? */
X	char	fontname[MAXFONTNAME];	/* font name */
X	int		fontsize;	/* font size in pts */
X	HFONT	hfonth;		/* horizonal font */
X	HFONT	hfontv;		/* vertical font */
X	BOOL	resized;	/* has graph window been resized? */
X	BOOL	graphtotop;	/* bring graph window to top after every plot? */
X	BOOL	color;					/* color pens? */
X	HPEN	hbpen;					/* border pen */
X	HPEN	hapen;					/* axis pen */
X	HPEN	hpen[WGNUMPENS];		/* pens */
X	LOGPEN	colorpen[WGNUMPENS+2];	/* logical color pens */
X	LOGPEN	monopen[WGNUMPENS+2];	/* logical mono pens */
X	COLORREF background;			/* background color */
X	HBRUSH   hbrush;				/* background brush */
X	struct GWOPBLK *gwopblk_head;
X	struct GWOPBLK *gwopblk_tail;
X	unsigned int nGWOP;
X	BOOL	locked;				/* locked if being written */
X} GW;
Xtypedef GW FAR*  LPGW;
X
X#define WINFONTSIZE 10
X#define WIN30FONT "Courier"
X#define WINFONT "Arial"
X
X#ifndef LEFT
X#define LEFT 0
X#endif
X#ifndef CENTRE
X#define CENTRE 1
X#endif
X#ifndef RIGHT
X#define RIGHT 2
X#endif
X
Xvoid WDPROC GraphInit(LPGW lpgw);
Xvoid WDPROC GraphClose(LPGW lpgw);
Xvoid WDPROC GraphStart(LPGW lpgw);
Xvoid WDPROC GraphEnd(LPGW lpgw);
Xvoid WDPROC GraphOp(LPGW lpgw, WORD op, WORD x, WORD y, LPSTR str);
Xvoid WDPROC GraphPrint(LPGW lpgw);
Xvoid WDPROC GraphRedraw(LPGW lpgw);
X
X/* ================================== */
END_OF_FILE
  if test 8074 -ne `wc -c <'gnuplot/win/wgnuplib.h'`; then
    echo shar: \"'gnuplot/win/wgnuplib.h'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wgnuplib.h'
fi
if test -f 'gnuplot/win/wpause.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wpause.c'\"
else
  echo shar: Extracting \"'gnuplot/win/wpause.c'\" \(7827 characters\)
  sed "s/^X//" >'gnuplot/win/wpause.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: wpause.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X/* GNUPLOT - win/wpause.c */
X/*
X * Copyright (C) 1992   Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Russell Lang
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X */
X/* PauseBox() */
X
X/* MessageBox ALWAYS appears in the middle of the screen so instead */
X/* we use this PauseBox so we can decide where it is to be placed */
X
X#define STRICT
X#include <windows.h>
X#include <windowsx.h>
X#include <string.h>
X#include "wgnuplib.h"
X#include "wresourc.h"
X#include "wcommon.h"
X
X/* Pause Window */
XLRESULT CALLBACK _export WndPauseProc(HWND, UINT, WPARAM, LPARAM);
XLRESULT CALLBACK _export PauseButtonProc(HWND, UINT, WPARAM, LPARAM);
X
X/* Create Pause Class */
X/* called from PauseBox the first time a pause window is created */
Xvoid
XCreatePauseClass(LPPW lppw)
X{
X	WNDCLASS wndclass;
X
X	wndclass.style = 0;
X	wndclass.lpfnWndProc = (WNDPROC)WndPauseProc;
X	wndclass.cbClsExtra = 0;
X	wndclass.cbWndExtra = sizeof(void FAR *);
X	wndclass.hInstance = lppw->hInstance;
X	wndclass.hIcon = NULL;
X	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
X	wndclass.hbrBackground = GetStockBrush(WHITE_BRUSH);
X	wndclass.lpszMenuName = NULL;
X	wndclass.lpszClassName = szPauseClass;
X	RegisterClass(&wndclass);
X}
X
X/* PauseBox */
Xint WDPROC
XPauseBox(LPPW lppw)
X{
X	MSG msg;
X	HDC hdc;
X	int width, height;
X	TEXTMETRIC tm;
X	RECT rect;
X
X	if (!lppw->hPrevInstance)
X		CreatePauseClass(lppw);
X	GetWindowRect(GetDesktopWindow(), &rect);
X	if ( (lppw->Origin.x == CW_USEDEFAULT) || (lppw->Origin.x == 0) )
X		lppw->Origin.x = (rect.right + rect.left) / 2;
X	if ( (lppw->Origin.y == CW_USEDEFAULT) || (lppw->Origin.y == 0) )
X		lppw->Origin.y = (rect.bottom + rect.top) / 2;
X
X	hdc = GetDC(NULL);
X	SelectFont(hdc, GetStockFont(SYSTEM_FIXED_FONT));
X	GetTextMetrics(hdc, &tm);
X	width  = max(24,4+_fstrlen(lppw->Message)) * tm.tmAveCharWidth;
X	width = min(width, rect.right-rect.left);
X	height = 28 * (tm.tmHeight + tm.tmExternalLeading) / 4;
X	ReleaseDC(NULL,hdc);
X
X	lppw->lpfnPauseButtonProc = 
X#ifdef __DLL__
X		(WNDPROC)GetProcAddress(hdllInstance, "PauseButtonProc");
X#else
X		(WNDPROC)MakeProcInstance((FARPROC)PauseButtonProc ,hdllInstance);
X#endif
X	lppw->hWndPause = CreateWindowEx(WS_EX_DLGMODALFRAME, 
X		szPauseClass, lppw->Title,
X		WS_POPUPWINDOW | WS_CAPTION,
X		lppw->Origin.x - width/2, lppw->Origin.y - height/2,
X		width, height,
X		lppw->hWndParent, NULL, lppw->hInstance, lppw);
X	ShowWindow(lppw->hWndPause, SW_SHOWNORMAL);
X	BringWindowToTop(lppw->hWndPause);
X	UpdateWindow(lppw->hWndPause);
X
X	lppw->bPause = TRUE;
X	lppw->bPauseCancel = IDCANCEL;
X	while (lppw->bPause)
X    		while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
X			/* wait until window closed */
X        		TranslateMessage(&msg);
X        		DispatchMessage(&msg);
X        	}
X	DestroyWindow(lppw->hWndPause);
X#ifndef __DLL__
X	FreeProcInstance((FARPROC)lppw->lpfnPauseButtonProc);
X#endif
X
X	return(lppw->bPauseCancel);
X}
X
XLRESULT CALLBACK _export
XWndPauseProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
X{
X	HDC hdc;
X	PAINTSTRUCT ps;
X	RECT rect;
X	TEXTMETRIC tm;
X	LPPW lppw;
X	int cxChar, cyChar, middle;
X
X	lppw = (LPPW)GetWindowLong(hwnd, 0);
X
X	switch(message) {
X		case WM_KEYDOWN:
X			if (wParam == VK_RETURN) {
X				if (lppw->bDefOK)
X					SendMessage(hwnd, WM_COMMAND, IDOK, 0L);
X				else
X					SendMessage(hwnd, WM_COMMAND, IDCANCEL, 0L);
X			}
X			return(0);
X		case WM_COMMAND:
X			switch(LOWORD(wParam)) {
X				case IDCANCEL:
X				case IDOK:
X					lppw->bPauseCancel = LOWORD(wParam);
X					lppw->bPause = FALSE;
X					break;
X			}
X			return(0);
X		case WM_SETFOCUS:
X			SetFocus(lppw->bDefOK ? lppw->hOK : lppw->hCancel);
X			return(0);
X		case WM_PAINT:
X			{
X			hdc = BeginPaint(hwnd, &ps);
X			SelectFont(hdc, GetStockFont(SYSTEM_FIXED_FONT));
X			SetTextAlign(hdc, TA_CENTER);
X			GetClientRect(hwnd, &rect);
X			TextOut(hdc,(rect.right+rect.left)/2, (rect.bottom+rect.top)/6,
X				lppw->Message,_fstrlen(lppw->Message));
X			EndPaint(hwnd, &ps);
X			return 0;
X			}
X		case WM_CREATE:
X			{
X			HMENU sysmenu = GetSystemMenu(hwnd, FALSE);
X			lppw = ((CREATESTRUCT FAR *)lParam)->lpCreateParams;
X			SetWindowLong(hwnd, 0, (LONG)lppw);
X			lppw->hWndPause = hwnd;
X			hdc = GetDC(hwnd);
X			SelectFont(hdc, GetStockFont(SYSTEM_FIXED_FONT));
X			GetTextMetrics(hdc, &tm);
X			cxChar = tm.tmAveCharWidth;
X			cyChar = tm.tmHeight + tm.tmExternalLeading;
X			ReleaseDC(hwnd,hdc);
X			middle = ((LPCREATESTRUCT) lParam)->cx / 2;
X			lppw->hOK = CreateWindow((LPSTR)"button", (LPSTR)"OK",
X				WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON,
X					middle - 10*cxChar, 3*cyChar,
X					8*cxChar, 7*cyChar/4,
X					hwnd, (HMENU)IDOK,
X					((LPCREATESTRUCT) lParam)->hInstance, NULL);
X			lppw->bDefOK = TRUE;
X			lppw->hCancel = CreateWindow((LPSTR)"button", (LPSTR)"Cancel",
X				WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
X					middle + 2*cxChar, 3*cyChar,
X					8*cxChar, 7*cyChar/4,
X					hwnd, (HMENU)IDCANCEL,
X					((LPCREATESTRUCT) lParam)->hInstance, NULL);
X			lppw->lpfnOK = (WNDPROC) GetWindowLong(lppw->hOK, GWL_WNDPROC);
X			SetWindowLong(lppw->hOK, GWL_WNDPROC, (LONG)lppw->lpfnPauseButtonProc);
X			lppw->lpfnCancel = (WNDPROC) GetWindowLong(lppw->hCancel, GWL_WNDPROC);
X			SetWindowLong(lppw->hCancel, GWL_WNDPROC, (LONG)lppw->lpfnPauseButtonProc);
X			if (GetParent(hwnd))
X				EnableWindow(GetParent(hwnd),FALSE);
X			DeleteMenu(sysmenu,SC_RESTORE,MF_BYCOMMAND);
X			DeleteMenu(sysmenu,SC_SIZE,MF_BYCOMMAND);
X			DeleteMenu(sysmenu,SC_MINIMIZE,MF_BYCOMMAND);
X			DeleteMenu(sysmenu,SC_MAXIMIZE,MF_BYCOMMAND);
X			DeleteMenu(sysmenu,SC_TASKLIST,MF_BYCOMMAND);
X			DeleteMenu(sysmenu,0,MF_BYCOMMAND); /* a separator */
X			DeleteMenu(sysmenu,0,MF_BYCOMMAND); /* a separator */
X			}
X			return 0;
X		case WM_DESTROY:
X			GetWindowRect(hwnd, &rect);
X			lppw->Origin.x = (rect.right+rect.left)/2;
X			lppw->Origin.y = (rect.bottom+rect.top)/2;
X			lppw->bPause = FALSE;
X			if (GetParent(hwnd))
X				EnableWindow(GetParent(hwnd),TRUE);
X			break;
X	}
X	return DefWindowProc(hwnd, message, wParam, lParam);
X}
X
X
XLRESULT CALLBACK _export
XPauseButtonProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
X{
X	LPPW lppw;
X#ifdef WIN32
X	LONG n = GetWindowLong(hwnd, GWL_ID);
X#else
X	WORD n = GetWindowWord(hwnd, GWW_ID);
X#endif
X	lppw = (LPPW)GetWindowLong(GetParent(hwnd), 0);
X	switch(message) {
X		case WM_KEYDOWN:
X			switch(wParam) {
X			  case VK_TAB:
X			  case VK_BACK:
X			  case VK_LEFT:
X			  case VK_RIGHT:
X			  case VK_UP:
X			  case VK_DOWN:
X				lppw->bDefOK = !(n == IDOK);
X				if (lppw->bDefOK) {
X					SendMessage(lppw->hOK,     BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, (LPARAM)TRUE);
X					SendMessage(lppw->hCancel, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, (LPARAM)TRUE);
X					SetFocus(lppw->hOK);
X				}
X				else {
X					SendMessage(lppw->hOK,     BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, (LPARAM)TRUE);
X					SendMessage(lppw->hCancel, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, (LPARAM)TRUE);
X					SetFocus(lppw->hCancel);
X				}
X				break;
X			  default:
X				SendMessage(GetParent(hwnd), message, wParam, lParam);
X			}
X			break;
X	}
X	return CallWindowProc(((n == IDOK) ? lppw->lpfnOK : lppw->lpfnCancel),
X		 hwnd, message, wParam, lParam);
X}
END_OF_FILE
  if test 7827 -ne `wc -c <'gnuplot/win/wpause.c'`; then
    echo shar: \"'gnuplot/win/wpause.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wpause.c'
fi
echo shar: End of archive 25 \(of 33\).
cp /dev/null ark25isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
