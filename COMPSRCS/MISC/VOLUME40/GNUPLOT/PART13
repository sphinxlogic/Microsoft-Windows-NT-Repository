Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i025:  gnuplot - interactive function plotting utility, Part13/33
Message-ID: <1993Oct22.163418.23803@sparky.sterling.com>
X-Md4-Signature: a74ba26ab2d1318ef1e21218d2aabb4c
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:34:18 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 25
Archive-name: gnuplot/part13
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/random.dem gnuplot/graph3d.c.A
#   gnuplot/makefile.unx
# Wrapped by kent@sparky on Wed Oct 20 17:14:47 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 13 (of 33)."'
if test -f 'gnuplot/demo/random.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/random.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/random.dem'\" \(913 characters\)
  sed "s/^X//" >'gnuplot/demo/random.dem' <<'END_OF_FILE'
X#
X# $Id: random.demo 3.38.2.32 1992/12/04 18:33:59 woo Exp $
X#
X# random.dem
X#
X# Lattice test for random numbers;
X# If you can see any patterns in this plot, the random number generator
X# is not very good.
X#
X# Permission granted to distribute freely for non-commercial purposes only
X#
X# Copyright (c) 1991, Jos van der Woude, jvdwoude@hut.nl
Xsave set "defaults.ini"
Xseed = 1317
Xseed = rand(seed)
Xset nokey
Xset xrange [0: 1]
Xset yrange [0: 1]
Xset zrange [0: 1]
Xset title "Lattice test for random numbers"
Xset xlabel "rand(n) ->"
Xset ylabel "rand(n + 1) ->"
Xset zlabel "rand(n + 2) ->"
Xset format x "%3.2f"
Xset format y "%3.2f"
Xset format z "%3.2f"
Xset tics
Xset sample 1000
Xset function style dots
Xset parametric
Xplot rand(1), rand(1)
Xpause -1 "Hit return to continue"
Xpause 0 "3D plot ahead, one moment please ..."
Xset sample 50
Xsplot rand(1), rand(1), rand(1)
Xpause -1 "Hit return to continue"
Xload "defaults.ini"
END_OF_FILE
  if test 913 -ne `wc -c <'gnuplot/demo/random.dem'`; then
    echo shar: \"'gnuplot/demo/random.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/random.dem'
fi
if test -f 'gnuplot/graph3d.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/graph3d.c.A'\"
else
  echo shar: Extracting \"'gnuplot/graph3d.c.A'\" \(42442 characters\)
  sed "s/^X//" >'gnuplot/graph3d.c.A' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: graph3d.c%v 3.50.1.9 1993/08/05 05:38:59 woo Exp $";
X#endif
X
X
X/* GNUPLOT - graph3d.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *
X * This software is provided "as is" without express or implied warranty.
X *
X *
X * AUTHORS
X *
X *   Original Software:
X *       Gershon Elber and many others.
X *
X * 19 September 1992  Lawrence Crowl  (crowl@cs.orst.edu)
X * Added user-specified bases for log scaling.
X *
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X#include <stdio.h>
X#include <math.h>
X#include <assert.h>
X#if !defined(u3b2)
X#include <time.h>
X#endif
X#if !defined(sequent) && !defined(apollo) && !defined(alliant)
X#include <limits.h>
X#endif
X#include "plot.h"
X#include "setshow.h"
X
X#if defined(DJGPP)||defined(sun386)
X#define time_t unsigned long
X#endif
X
X#if defined(apollo) || defined(sequent) || defined(u3b2) || defined(alliant) || defined(sun386)
X#include <sys/types.h> /* typedef long time_t; */
X#endif
X
Xint suppressMove = 0;  /* for preventing moveto while drawing contours */
X#ifndef AMIGA_SC_6_1
Xextern char *strcpy(),*strncpy(),*strcat(),*ctime(),*tdate;
X#else /* AMIGA_SC_6_1 */
Xextern char *tdate;
X#endif /* AMIGA_SC_6_1 */
X#ifdef AMIGA_AC_5
Xextern time_t dated;
X#else
Xextern time_t dated; /* ,time(); */
X#include <time.h>
X#endif
X
X#ifdef __TURBOC__
X#include <stdlib.h>		/* for qsort */
X#endif
X
X/*
X * hidden_line_type_above, hidden_line_type_below - controls type of lines
X *   for above and below parts of the surface.
X * hidden_no_update - if TRUE lines will be hidden line removed but they
X *   are not assumed to be part of the surface (i.e. grid) and therefore
X *   do not influence the hidings.
X * hidden_active - TRUE if hidden lines are to be removed.
X */
Xstatic int hidden_active = FALSE;
X
X/* LITE defines a restricted memory version for MS-DOS */
X
X#ifndef LITE
X
Xstatic int hidden_line_type_above, hidden_line_type_below, hidden_no_update;
X
X/* We divvy up the figure into the component boxes that make it up, and then
X   sort them by the z-value (which is really just an average value).  */
Xstruct pnts{
X  int x,y,z;
X  int flag;
X  long int style_used;	/* acw test */
X  int nplot;
X};
Xstatic int * boxlist;
Xstatic struct pnts * nodes;
X/* These variables are used to keep track of the range of x values used in the
Xline drawing routine.  */
Xstatic long int xmin_hl,xmax_hl;
X/* These arrays are used to keep track of the minimum and maximum y values used
X   for each X value.  These are only used for drawing the individual boxes that
X   make up the 3d figure.  After each box is drawn, the information is copied
X   to the bitmap. */
Xstatic short int *ymin_hl, *ymax_hl;
X/*
X * These numbers are chosen as dividers into the bitmap.
X */
Xstatic short int xfact, yfact;
X#define XREDUCE(X) ((X)/xfact)
X#define YREDUCE(Y) ((Y)/yfact)
X/* Bitmap of the screen.  The array for each x value is malloc-ed as needed */
Xstatic short int **pnt;
X#define IFSET(X,Y) (pnt[X] == 0 ? 0 : (((pnt[X])[(Y)>>4] >> ((Y) & 0xf)) & 0x01))
Xstatic plot3d_hidden();
X
X#endif /* LITE */
X
X
Xstatic plot3d_impulses();
Xstatic plot3d_lines();
Xstatic plot3d_points();
Xstatic plot3d_dots();
Xstatic cntr3d_impulses();
Xstatic cntr3d_lines();
Xstatic cntr3d_points();
Xstatic cntr3d_dots();
Xstatic update_extrema_pts();
Xstatic draw_parametric_grid();
Xstatic draw_non_param_grid();
Xstatic draw_bottom_grid();
Xstatic draw_3dxtics();
Xstatic draw_3dytics();
Xstatic draw_3dztics();
Xstatic draw_series_3dxtics();
Xstatic draw_series_3dytics();
Xstatic draw_series_3dztics();
Xstatic draw_set_3dxtics();
Xstatic draw_set_3dytics();
Xstatic draw_set_3dztics();
Xstatic xtick();
Xstatic ytick();
Xstatic ztick();
Xstatic setlinestyle();
X#ifdef __PUREC__
X/* a little problem with the 16bit int size of PureC. this completely broke
X   the hidded3d feature. doesn't really fix it, but I'm working at it.  (AL) */
Xstatic int clip_point(int x, int y);
Xstatic void clip_put_text(int x, int y, char *str);
X#endif
X
X#ifndef max		/* Lattice C has max() in math.h, but shouldn't! */
X#define max(a,b) ((a > b) ? a : b)
X#endif
X
X#ifndef min
X#define min(a,b) ((a < b) ? a : b)
X#endif
X
X#define inrange(z,min,max) ((min<max) ? ((z>=min)&&(z<=max)) : ((z>=max)&&(z<=min)) )
X
X#define apx_eq(x,y) (fabs(x-y) < 0.001)
X#ifndef abs
X#define abs(x) ((x) >= 0 ? (x) : -(x))
X#endif
X#define sqr(x) ((x) * (x))
X
X/* Define the boundary of the plot
X * These are computed at each call to do_plot, and are constant over
X * the period of one do_plot. They actually only change when the term
X * type changes and when the 'set size' factors change. 
X */
Xstatic int xleft, xright, ybot, ytop, xmiddle, ymiddle, xscaler, yscaler;
X
X/* Boundary and scale factors, in user coordinates */
X/* x_min3d, x_max3d, y_min3d, y_max3d, z_min3d, z_max3d are local to this
X * file and are not the same as variables of the same names in other files
X */
Xstatic double x_min3d, x_max3d, y_min3d, y_max3d, z_min3d, z_max3d;
Xstatic double xscale3d, yscale3d, zscale3d;
Xstatic double real_z_min3d, real_z_max3d;
Xstatic double min_sy_ox,min_sy_oy; /* obj. coords. for xy tics placement. */
Xstatic double min_sx_ox,min_sx_oy; /* obj. coords. for z tics placement. */
X
Xtypedef double transform_matrix[4][4];
Xstatic transform_matrix trans_mat;
X
X/* (DFK) Watch for cancellation error near zero on axes labels */
X#define SIGNIF (0.01)		/* less than one hundredth of a tic mark */
X#define CheckZero(x,tic) (fabs(x) < ((tic) * SIGNIF) ? 0.0 : (x))
X#define NearlyEqual(x,y,tic) (fabs((x)-(y)) < ((tic) * SIGNIF))
X
X/* And the functions to map from user to terminal coordinates */
X#define map_x(x) (int)(x+0.5) /* maps floating point x to screen */ 
X#define map_y(y) (int)(y+0.5)	/* same for y */
X
X/* And the functions to map from user 3D space into normalized -1..1 */
X#define map_x3d(x) ((x-x_min3d)*xscale3d-1.0)
X#define map_y3d(y) ((y-y_min3d)*yscale3d-1.0)
X#define map_z3d(z) ((z-z_min3d)*zscale3d-1.0)
X
Xstatic mat_unit(mat)
Xtransform_matrix mat;
X{
X    int i, j;
X
X    for (i = 0; i < 4; i++) for (j = 0; j < 4; j++)
X	if (i == j)
X	    mat[i][j] = 1.0;
X	else
X	    mat[i][j] = 0.0;
X}
X
Xstatic mat_trans(tx, ty, tz, mat)
Xdouble tx, ty, tz;
Xtransform_matrix mat;
X{
X     mat_unit(mat);                                 /* Make it unit matrix. */
X     mat[3][0] = tx;
X     mat[3][1] = ty;
X     mat[3][2] = tz;
X}
X
Xstatic mat_scale(sx, sy, sz, mat)
Xdouble sx, sy, sz;
Xtransform_matrix mat;
X{
X     mat_unit(mat);                                 /* Make it unit matrix. */
X     mat[0][0] = sx;
X     mat[1][1] = sy;
X     mat[2][2] = sz;
X}
X
Xstatic mat_rot_x(teta, mat)
Xdouble teta;
Xtransform_matrix mat;
X{
X    double cos_teta, sin_teta;
X
X    teta *= Pi / 180.0;
X    cos_teta = cos(teta);
X    sin_teta = sin(teta);
X
X    mat_unit(mat);                                  /* Make it unit matrix. */
X    mat[1][1] = cos_teta;
X    mat[1][2] = -sin_teta;
X    mat[2][1] = sin_teta;
X    mat[2][2] = cos_teta;
X}
X
Xstatic mat_rot_y(teta, mat)
Xdouble teta;
Xtransform_matrix mat;
X{
X    double cos_teta, sin_teta;
X
X    teta *= Pi / 180.0;
X    cos_teta = cos(teta);
X    sin_teta = sin(teta);
X
X    mat_unit(mat);                                  /* Make it unit matrix. */
X    mat[0][0] = cos_teta;
X    mat[0][2] = -sin_teta;
X    mat[2][0] = sin_teta;
X    mat[2][2] = cos_teta;
X}
X
Xstatic mat_rot_z(teta, mat)
Xdouble teta;
Xtransform_matrix mat;
X{
X    double cos_teta, sin_teta;
X
X    teta *= Pi / 180.0;
X    cos_teta = cos(teta);
X    sin_teta = sin(teta);
X
X    mat_unit(mat);                                  /* Make it unit matrix. */
X    mat[0][0] = cos_teta;
X    mat[0][1] = -sin_teta;
X    mat[1][0] = sin_teta;
X    mat[1][1] = cos_teta;
X}
X
X/* Multiply two transform_matrix. Result can be one of two operands. */
Xvoid mat_mult(mat_res, mat1, mat2)
Xtransform_matrix mat_res, mat1, mat2;
X{
X    int i, j, k;
X    transform_matrix mat_res_temp;
X
X    for (i = 0; i < 4; i++) for (j = 0; j < 4; j++) {
X        mat_res_temp[i][j] = 0;
X        for (k = 0; k < 4; k++) mat_res_temp[i][j] += mat1[i][k] * mat2[k][j];
X    }
X    for (i = 0; i < 4; i++) for (j = 0; j < 4; j++)
X	mat_res[i][j] = mat_res_temp[i][j];
X}
X
X/* And the functions to map from user 3D space to terminal coordinates */
Xstatic int map3d_xy(x, y, z, xt, yt)
Xdouble x, y, z;
Xint *xt, *yt;
X{
X    int i,j;
X    double v[4], res[4],		     /* Homogeneous coords. vectors. */
X	w = trans_mat[3][3];
X
X    v[0] = map_x3d(x); /* Normalize object space to -1..1 */
X    v[1] = map_y3d(y);
X    v[2] = map_z3d(z);
X    v[3] = 1.0;
X
X    for (i = 0; i < 2; i++) {	             /* Dont use the third axes (z). */
X        res[i] = trans_mat[3][i];     /* Initiate it with the weight factor. */
X        for (j = 0; j < 3; j++) res[i] += v[j] * trans_mat[j][i];
X    }
X
X    for (i = 0; i < 3; i++) w += v[i] * trans_mat[i][3];
X    if (w == 0) w = 1e-5;
X
X    *xt = ((int) (res[0] * xscaler / w)) + xmiddle;
X    *yt = ((int) (res[1] * yscaler / w)) + ymiddle;
X}
X
X/* And the functions to map from user 3D space to terminal z coordinate */
Xstatic int map3d_z(x, y, z)
Xdouble x, y, z;
X{
X    int i, zt;
X    double v[4], res,			     /* Homogeneous coords. vectors. */
X	w = trans_mat[3][3];
X
X    v[0] = map_x3d(x); /* Normalize object space to -1..1 */
X    v[1] = map_y3d(y);
X    v[2] = map_z3d(z);
X    v[3] = 1.0;
X
X    res = trans_mat[3][2];     	      /* Initiate it with the weight factor. */
X    for (i = 0; i < 3; i++) res += v[i] * trans_mat[i][2];
X    if(w==0) w= 1e-5;
X    for (i = 0; i < 3; i++) w += v[i] * trans_mat[i][3];
X    zt = ((int) (res * 16384 / w));
X    return  zt;
X}
X
X/* Initialize the line style using the current device and set hidden styles  */
X/* to it as well if hidden line removal is enabled.			     */
Xstatic setlinestyle(style)
Xint style;
X{
X    register struct termentry *t = &term_tbl[term];
X
X    (*t->linetype)(style);
X
X#ifndef LITE
X    if (hidden3d) {
X	hidden_line_type_above = style;
X	hidden_line_type_below = style;
X    }
X#endif  /* LITE */
X}
X
X#ifndef LITE
X/* Initialize the necessary steps for hidden line removal. */
Xstatic void init_hidden_line_removal()
X{
X  int i;
X  /*  We want to keep the bitmap size less than 2048x2048, so we choose
X   *  integer dividers for the x and y coordinates to keep the x and y
X   *  ranges less than 2048.  In practice, the x and y sizes for the bitmap
X   *  will be somewhere between 1024 and 2048, except in cases where the
X   *  coordinates ranges for the device are already less than 1024.
X   *  We do this mainly to control the size of the bitmap, but it also
X   *  speeds up the computation.  We maintain separate dividers for
X   *  x and y.
X   */
X  xfact = (xright-xleft)/1024;
X  yfact = (ytop-ybot)/1024;
X  if(xfact == 0) xfact=1;
X  if(yfact == 0) yfact=1;
X  if(pnt == 0){
X    i = sizeof(short int*)*(XREDUCE(xright) - XREDUCE(xleft) + 1);
X    pnt = (short int **) alloc((unsigned long)i, "hidden");
X    bzero(pnt,i);
X  };
X  ymin_hl = (short int *) alloc((unsigned long)sizeof(short int)*
X				(XREDUCE(xright) - XREDUCE(xleft) + 1), "hidden");
X  ymax_hl = (short int *) alloc((unsigned long)sizeof(short int)*
X				(XREDUCE(xright) - XREDUCE(xleft) + 1), "hidden");
X}
X
X/* Reset the hidden line data to a fresh start.				     */
Xstatic void reset_hidden_line_removal()
X{
X    int i;
X    if(pnt){
X      for(i=0;i<=XREDUCE(xright)-XREDUCE(xleft);i++) {
X	if(pnt[i])
X	  { free(pnt[i]); pnt[i] = 0;};
X      };
X    };
X}
X
X/* Terminates the hidden line removal process. Free any memory allocated by  */
X/* init_hidden_line_removal above.					     */
Xstatic void term_hidden_line_removal()
X{
X     if(pnt){
X       int j;
X       for(j=0;j<=XREDUCE(xright)-XREDUCE(xleft);j++) {
X 	if(pnt[j])
X 	  { free(pnt[j]); pnt[j] = 0;};
X       };
X       free(pnt);
X       pnt = 0;
X     };
X   free(ymin_hl);
X   free(ymax_hl);
X}
X#endif /* not LITE */
X
X/* Test a single point to be within the xleft,xright,ybot,ytop bbox.
X * Sets the returned integers 4 l.s.b. as follows:
X * bit 0 if to the left of xleft.
X * bit 1 if to the right of xright.
X * bit 2 if above of ytop.
X * bit 3 if below of ybot.
X * 0 is returned if inside.
X */
Xstatic int clip_point(x, y)
Xint x, y;
X{
X    int ret_val = 0;
X
X    if (x < xleft) ret_val |= 0x01;
X    if (x > xright) ret_val |= 0x02;
X    if (y < ybot) ret_val |= 0x04;
X    if (y > ytop) ret_val |= 0x08;
X
X    return ret_val;
X}
X
X
X/* Clip the given line to drawing coords defined as xleft,xright,ybot,ytop.
X *   This routine uses the cohen & sutherland bit mapping for fast clipping -
X * see "Principles of Interactive Computer Graphics" Newman & Sproull page 65.
X */
Xstatic void draw_clip_line(x1, y1, x2, y2)
Xint x1, y1, x2, y2;
X{
X    int x, y, dx, dy, x_intr[2], y_intr[2], count, pos1, pos2;
X    register struct termentry *t = &term_tbl[term];
X
X    pos1 = clip_point(x1, y1);
X    pos2 = clip_point(x2, y2);
X    if (pos1 || pos2) {
X	if (pos1 & pos2) return;		  /* segment is totally out. */
X
X	/* Here part of the segment MAY be inside. test the intersection
X	 * of this segment with the 4 boundaries for hopefully 2 intersections
X	 * in. If non found segment is totaly out.
X	 */
X	count = 0;
X	dx = x2 - x1;
X	dy = y2 - y1;
X
X	/* Find intersections with the x parallel bbox lines: */
X	if (dy != 0) {
X	    x = (ybot - y2) * dx / dy + x2;        /* Test for ybot boundary. */
X	    if (x >= xleft && x <= xright) {
X		x_intr[count] = x;
X		y_intr[count++] = ybot;
X	    }
X	    x = (ytop - y2) * dx / dy + x2;        /* Test for ytop boundary. */
X	    if (x >= xleft && x <= xright) {
X		x_intr[count] = x;
X		y_intr[count++] = ytop;
X	    }
X	}
X
X	/* Find intersections with the y parallel bbox lines: */
X	if (dx != 0) {
X	    y = (xleft - x2) * dy / dx + y2;      /* Test for xleft boundary. */
X	    if (y >= ybot && y <= ytop) {
X		x_intr[count] = xleft;
X		y_intr[count++] = y;
X	    }
X	    y = (xright - x2) * dy / dx + y2;    /* Test for xright boundary. */
X	    if (y >= ybot && y <= ytop) {
X		x_intr[count] = xright;
X		y_intr[count++] = y;
X	    }
X	}
X
X	if (count == 2) {
X	    int x_max, x_min, y_max, y_min;
X
X	    x_min = min(x1, x2);
X	    x_max = max(x1, x2);
X	    y_min = min(y1, y2);
X	    y_max = max(y1, y2);
X
X	    if (pos1 && pos2) {		       /* Both were out - update both */
X		x1 = x_intr[0];
X		y1 = y_intr[0];
X		x2 = x_intr[1];
X		y2 = y_intr[1];
X	    }
X	    else if (pos1) {	       /* Only x1/y1 was out - update only it */
X		if (dx * (x2 - x_intr[0]) + dy * (y2 - y_intr[0]) > 0) {
X		    x1 = x_intr[0];
X		    y1 = y_intr[0];
X		}
X		else {
X		    x1 = x_intr[1];
X		    y1 = y_intr[1];
X		}
X	    }
X	    else {	       	       /* Only x2/y2 was out - update only it */
X		if (dx * (x_intr[0] - x1) + dy * (y_intr[0] - x1) > 0) {
X		    x2 = x_intr[0];
X		    y2 = y_intr[0];
X		}
X		else {
X		    x2 = x_intr[1];
X		    y2 = y_intr[1];
X		}
X	    }
X
X	    if (x1 < x_min || x1 > x_max ||
X		x2 < x_min || x2 > x_max ||
X		y1 < y_min || y1 > y_max ||
X		y2 < y_min || y2 > y_max) return;
X	}
X	else
X	    return;
X    }
X
X#ifndef LITE
X    if(hidden3d && draw_surface)
X      {
X	char flag;
X	register int xv, yv, errx, erry, err;
X	register int xvr, yvr;
X	int xve, yve;
X	register int dy, nstep, dyr;
X	int i;
X	if (x1 > x2){
X	  xvr = x2;
X	  yvr = y2;
X	  xve = x1;
X	  yve = y1;
X	} else {
X	  xvr = x1;
X	  yvr = y1;
X	  xve = x2;
X	  yve = y2;
X	};
X	errx = XREDUCE(xve) - XREDUCE(xvr);
X	erry = YREDUCE(yve) - YREDUCE(yvr);
X	dy = (erry > 0 ? 1 : -1);
X	dyr = dy*yfact;
X	switch (dy){
X	case 1:
X	  nstep = errx + erry;
X	  errx = -errx;
X	  break;
X	case -1:
X	  nstep = errx - erry;
X	  errx = -errx;
X	  erry = -erry;
X	  break;
X	};
X	err = errx + erry;
X	errx <<= 1;
X	erry <<= 1;
X	xv = XREDUCE(xvr) - XREDUCE(xleft);
X	yv = YREDUCE(yvr) - YREDUCE(ybot);
X	(*t->move)(xvr,yvr);
X	if( !IFSET(xv,yv) ) flag = 0;
X	else flag = 1;
X	if(!hidden_no_update){ /* Check first point */
X	  if (xv < xmin_hl) xmin_hl = xv;
X	  if (xv > xmax_hl) xmax_hl = xv;
X	  if (yv > ymax_hl[xv]) ymax_hl[xv] = yv;
X	  if (yv < ymin_hl[xv]) ymin_hl[xv] = yv;
X	};
X	for (i=0;i<nstep;i++){
X	  if (err < 0){
X	    xv ++;
X	    xvr += xfact;
X	    err += erry;
X	  } else {
X	    yv += dy;
X	    yvr += dyr;
X	    err += errx;
X	  };
X	  if( !IFSET(xv,yv)){
X	    if(flag != 0) {(*t->move)(xvr,yvr); flag = 0;};
X	  } else {
X	    if(flag == 0) {(*t->vector)(xvr,yvr); flag = 1;};
X	  };
X	  if(!hidden_no_update){
X	    if (xv < xmin_hl) xmin_hl = xv;
X	    if (xv > xmax_hl) xmax_hl = xv;
X	    if (yv > ymax_hl[xv]) ymax_hl[xv] = yv;
X	    if (yv < ymin_hl[xv]) ymin_hl[xv] = yv;
X	  };
X	};
X	if (flag == 0) (*t->vector)(xve, yve);
X	return;
X      };
X#endif /* not LITE */
X    if(!suppressMove) (*t->move)(x1,y1);
X    (*t->vector)(x2,y2);
X}
X
X/* Two routine to emulate move/vector sequence using line drawing routine. */
Xstatic int move_pos_x, move_pos_y;
X
Xstatic void clip_move(x,y)
Xint x,y;
X{
X    move_pos_x = x;
X    move_pos_y = y;
X}
X
Xstatic void clip_vector(x,y)
Xint x,y;
X{
X    draw_clip_line(move_pos_x,move_pos_y, x, y);
X    move_pos_x = x;
X    move_pos_y = y;
X}
X
X/* And text clipping routine. */
Xstatic void clip_put_text(x, y, str)
Xint x,y;
Xchar *str;
X{
X    register struct termentry *t = &term_tbl[term];
X
X    if (clip_point(x, y)) return;
X
X    (*t->put_text)(x,y,str);
X}
X
X/* (DFK) For some reason, the Sun386i compiler screws up with the CheckLog 
X * macro, so I write it as a function on that machine.
X */
X#ifndef sun386
X/* (DFK) Use 10^x if logscale is in effect, else x */
X#define CheckLog(is_log, base_log, x) ((is_log) ? pow(base_log, (x)) : (x))
X#else
Xstatic double
XCheckLog(is_log, base_log, x)
X     TBOOLEAN is_log;
X     double base_log;
X     double x;
X{
X  if (is_log)
X    return(pow(base_log, x));
X  else
X    return(x);
X}
X#endif /* sun386 */
X
Xstatic double
XLogScale(coord, is_log, log_base_log, what, axis)
X	double coord;			/* the value */
X	TBOOLEAN is_log;			/* is this axis in logscale? */
X	double log_base_log;		/* if so, the log of its base */
X	char *what;			/* what is the coord for? */
X	char *axis;			/* which axis is this for ("x" or "y")? */
X{
X    if (is_log) {
X	   if (coord <= 0.0) {
X		  char errbuf[100];		/* place to write error message */
X		(void) sprintf(errbuf,"%s has %s coord of %g; must be above 0 for log scale!",
X				what, axis, coord);
X		  (*term_tbl[term].text)();
X		  (void) fflush(outfile);
X		  int_error(errbuf, NO_CARET);
X	   } else
X		return(log(coord)/log_base_log);
X    }
X    return(coord);
X}
X
X/* borders of plotting area */
X/* computed once on every call to do_plot */
Xstatic boundary3d(scaling)
X	TBOOLEAN scaling;		/* TRUE if terminal is doing the scaling */
X{
X    register struct termentry *t = &term_tbl[term];
X    /* luecken@udel.edu modifications
X       sizes the plot to take up more of available resolution */
X    xleft = (t->h_char)*2 + (t->h_tic);
X    xright = (scaling ? 1 : xsize) * (t->xmax) - (t->h_char)*2 - (t->h_tic);
X    ybot = (t->v_char)*5/2 + 1;
X    ytop = (scaling ? 1 : ysize) * (t->ymax) - (t->v_char)*5/2 - 1;
X    xmiddle = (xright + xleft) / 2;
X    ymiddle = (ytop + ybot) / 2;
X    xscaler = (xright - xleft) * 4 / 7;
X    yscaler = (ytop - ybot) * 4 / 7;
X}
X
Xstatic double dbl_raise(x,y)
Xdouble x;
Xint y;
X{
Xregister int i;
Xdouble val;
X
X	val = 1.0;
X	for (i=0; i < abs(y); i++)
X		val *= x;
X	if (y < 0 ) return (1.0/val);
X	return(val);
X}
X
X
Xstatic double make_3dtics(tmin,tmax,axis,logscale, base_log)
Xdouble tmin,tmax;
Xint axis;
XTBOOLEAN logscale;
Xdouble base_log;
X{
Xint x1,y1,x2,y2;
Xregister double xr,xnorm,tics,tic,l10;
X
X	xr = fabs(tmin-tmax);
X
X	/* Compute length of axis in screen space coords. */
X	switch (axis) {
X		case 'x':
X			map3d_xy(tmin,0.0,0.0,&x1,&y1);
X			map3d_xy(tmax,0.0,0.0,&x2,&y2);
X			break;
X		case 'y':
X			map3d_xy(0.0,tmin,0.0,&x1,&y1);
X			map3d_xy(0.0,tmax,0.0,&x2,&y2);
X			break;
X		case 'z':
X			map3d_xy(0.0,0.0,tmin,&x1,&y1);
X			map3d_xy(0.0,0.0,tmax,&x2,&y2);
X			break;
X	}
X
X	if (((long) (x1-x2))*(x1-x2) + ((long) (y1-y2))*(y1-y2) <
X	    sqr(3L * term_tbl[term].h_char))
X		return -1.0;                  			/* No tics! */
X
X	l10 = log10(xr);
X	if (logscale) {
X		tic = dbl_raise(base_log,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X		if (tic < 1.0)
X			tic = 1.0;
X	} else {
X		xnorm = pow(10.0,l10-(double)((l10 >= 0.0 ) ? (int)l10 : ((int)l10-1)));
X		if (xnorm <= 5)
X			tics = 0.5;
X		else tics = 1.0;
X		tic = tics * dbl_raise(10.0,(l10 >= 0.0 ) ? (int)l10 : ((int)l10-1));
X	}
X	return(tic);
X}
X
Xdo_3dplot(plots, pcount, min_x, max_x, min_y, max_y, min_z, max_z)
Xstruct surface_points *plots;
Xint pcount;			/* count of plots in linked list */
Xdouble min_x, max_x;
Xdouble min_y, max_y;
Xdouble min_z, max_z;
X{
Xregister struct termentry *t = &term_tbl[term];
Xregister int surface;
Xregister struct surface_points *this_plot;
Xint xl, yl, linetypeOffset = 0;
X			/* only a Pyramid would have this many registers! */
Xdouble xtemp, ytemp, ztemp, temp;
Xstruct text_label *this_label;
Xstruct arrow_def *this_arrow;
XTBOOLEAN scaling;
Xtransform_matrix mat;
X
X/* Initiate transformation matrix using the global view variables. */
X    mat_rot_z(surface_rot_z, trans_mat);
X    mat_rot_x(surface_rot_x, mat);
X    mat_mult(trans_mat, trans_mat, mat);
X    mat_scale(surface_scale / 2.0, surface_scale / 2.0, surface_scale / 2.0, mat);
X    mat_mult(trans_mat, trans_mat, mat);
X
X/* modify min_z/max_z so it will zscale properly. */
X    ztemp = (max_z - min_z) / (2.0 * surface_zscale);
X    temp = (max_z + min_z) / 2.0;
X    min_z = temp - ztemp;
X    max_z = temp + ztemp;
X
X/* store these in variables global to this file */
X/* otherwise, we have to pass them around a lot */
X    x_min3d = min_x;
X    x_max3d = max_x;
X    y_min3d = min_y;
X    y_max3d = max_y;
X    z_min3d = min_z;
X    z_max3d = max_z;
X
X	/* The extrema need to be set even when a surface is not being
X	 * drawn.   Without this, gnuplot used to assume that the X and
X	 * Y axis started at zero.   -RKC
X	 */
X
X	/* find (bottom) left corner of grid */
X	min_sx_ox = min_x;
X	min_sx_oy = min_y;
X	/* find bottom (right) corner of grid */
X	min_sy_ox = max_x;
X	min_sy_oy = min_y;
X
X
X    if (polar)
X	int_error("Cannot splot in polar coordinate system.", NO_CARET);
X
X    if (z_min3d == VERYLARGE || z_max3d == -VERYLARGE ||
X	x_min3d == VERYLARGE || x_max3d == -VERYLARGE ||
X	y_min3d == VERYLARGE || y_max3d == -VERYLARGE)
X        int_error("all points undefined!", NO_CARET);
X
X    /* If we are to draw the bottom grid make sure zmin is updated properly. */
X    if (xtics || ytics || grid)
X	z_min3d -= (max_z - min_z) * ticslevel;
X
X/*  This used be x_max3d == x_min3d, but that caused an infinite loop once. */
X    if (fabs(x_max3d - x_min3d) < zero)
X	int_error("x_min3d should not equal x_max3d!",NO_CARET);
X    if (fabs(y_max3d - y_min3d) < zero)
X	int_error("y_min3d should not equal y_max3d!",NO_CARET);
X    if (fabs(z_max3d - z_min3d) < zero)
X	int_error("z_min3d should not equal z_max3d!",NO_CARET);
X
X#ifndef LITE
X    if (hidden3d) {
X	struct surface_points *plot;
X  
X        /* Verify data is hidden line removable - grid based. */
X      	for (plot = plots; plot != NULL; plot = plot->next_sp) {
X 	    if (plot->plot_type == DATA3D && !plot->has_grid_topology){
X	      fprintf(stderr,"Notice: Cannot remove hidden lines from non grid data\n");
X              return(0);
X            }
X	
X        }
X    }
X#endif /* not LITE */
X
X/* INITIALIZE TERMINAL */
X    if (!term_init) {
X	(*t->init)();
X	term_init = TRUE;
X    }
X    screen_ok = FALSE;
X    scaling = (*t->scale)(xsize, ysize);
X    (*t->graphics)();
X
X    /* now compute boundary for plot (xleft, xright, ytop, ybot) */
X    boundary3d(scaling);
X
X/* SCALE FACTORS */
X	zscale3d = 2.0/(z_max3d - z_min3d);
X	yscale3d = 2.0/(y_max3d - y_min3d);
X	xscale3d = 2.0/(x_max3d - x_min3d);
X
X	(*t->linetype)(-2); /* border linetype */
X
X/* PLACE TITLE */
X	if (*title != 0) {
X		int x, y;
X
X		x = title_xoffset * t->h_char;
X		y = title_yoffset * t->v_char;
X
X		if ((*t->justify_text)(CENTRE)) 
X			(*t->put_text)(x+(xleft+xright)/2, 
X				       y+ytop+(t->v_char), title);
X		else
X			(*t->put_text)(x+(xleft+xright)/2 - strlen(title)*(t->h_char)/2,
X				       y+ytop+(t->v_char), title);
X	}
X
X/* PLACE TIMEDATE */
X	if (timedate) {
X		int x, y;
X
X		x = time_xoffset * t->h_char;
X		y = time_yoffset * t->v_char;
X		dated = time( (time_t *) 0);
X		tdate = ctime( &dated);
X		tdate[24]='\0';
X		if ((*t->text_angle)(1)) {
X			if ((*t->justify_text)(CENTRE)) {
X				(*t->put_text)(x+(t->v_char),
X						 y+ybot+4*(t->v_char), tdate);
X			}
X			else {
X				(*t->put_text)(x+(t->v_char),
X						 y+ybot+4*(t->v_char)-(t->h_char)*strlen(ylabel)/2, 
X						 tdate);
X			}
X		}
X		else {
X			(void)(*t->justify_text)(LEFT);
X			(*t->put_text)(x,
X						 y+ybot-1*(t->v_char), tdate);
X		}
X		(void)(*t->text_angle)(0);
X	}
X
X/* PLACE LABELS */
X    for (this_label = first_label; this_label!=NULL;
X			this_label=this_label->next ) {
X	    int x,y;
X
X	    xtemp = LogScale(this_label->x, is_log_x, log_base_log_x, "label", "x");
X	    ytemp = LogScale(this_label->y, is_log_y, log_base_log_y, "label", "y");
X	    ztemp = LogScale(this_label->z, is_log_z, log_base_log_z, "label", "z");
X    	    map3d_xy(xtemp,ytemp,ztemp, &x, &y);
X
X		if ((*t->justify_text)(this_label->pos)) {
X			(*t->put_text)(x,y,this_label->text);
X		}
X		else {
X			switch(this_label->pos) {
X				case  LEFT:
X					(*t->put_text)(x,y,this_label->text);
X					break;
X				case CENTRE:
X					(*t->put_text)(x -
X						(t->h_char)*strlen(this_label->text)/2,
X						y, this_label->text);
X					break;
X				case RIGHT:
X					(*t->put_text)(x -
X						(t->h_char)*strlen(this_label->text),
X						y, this_label->text);
X					break;
X			}
X		 }
X	 }
X
X/* PLACE ARROWS */
X    (*t->linetype)(0);	/* arrow line type */
X    for (this_arrow = first_arrow; this_arrow!=NULL;
X	    this_arrow = this_arrow->next ) {
X	int sx,sy,ex,ey;
X
X	xtemp = LogScale(this_arrow->sx, is_log_x, log_base_log_x, "arrow", "x");
X	ytemp = LogScale(this_arrow->sy, is_log_y, log_base_log_y, "arrow", "y");
X	ztemp = LogScale(this_arrow->sz, is_log_z, log_base_log_z, "arrow", "z");
X	map3d_xy(xtemp,ytemp,ztemp, &sx, &sy);
X
X	xtemp = LogScale(this_arrow->ex, is_log_x, log_base_log_x, "arrow", "x");
X	ytemp = LogScale(this_arrow->ey, is_log_y, log_base_log_y, "arrow", "y");
X	ztemp = LogScale(this_arrow->ez, is_log_z, log_base_log_z, "arrow", "z");
X	map3d_xy(xtemp,ytemp,ztemp, &ex, &ey);
X
X	(*t->arrow)(sx, sy, ex, ey, this_arrow->head);
X    }
X
X#ifndef LITE
X    if (hidden3d && draw_surface) {
X	init_hidden_line_removal();
X	reset_hidden_line_removal();
X	hidden_active = TRUE;
X    }
X#endif /* not LITE */
X
X/* DRAW SURFACES AND CONTOURS */
X	real_z_min3d = min_z;
X	real_z_max3d = max_z;
X	if (key == -1) {
X	    xl = xright  - (t->h_tic) - (t->h_char)*5;
X	    yl = ytop - (t->v_tic) - (t->v_char);
X	}
X	if (key == 1) {
X	    xtemp = LogScale(key_x, is_log_x, log_base_log_x, "key", "x");
X	    ytemp = LogScale(key_y, is_log_y, log_base_log_y, "key", "y");
X	    ztemp = LogScale(key_z, is_log_z, log_base_log_z, "key", "z");
X	    map3d_xy(xtemp,ytemp,ztemp, &xl, &yl);
X	}
X
X#ifndef LITE
X	if (hidden3d && draw_surface) plot3d_hidden(plots,pcount);
X#endif /* not LITE */
X	this_plot = plots;
X	for (surface = 0;
X	     surface < pcount;
X	     this_plot = this_plot->next_sp, surface++) {
X#ifndef LITE
X		if ( hidden3d )
X		    hidden_no_update = FALSE;
X#endif /* not LITE */
X
X		if (draw_surface) {
X		    (*t->linetype)(this_plot->line_type);
X#ifndef LITE
X		    if (hidden3d) {
X			hidden_line_type_above = this_plot->line_type;
X			hidden_line_type_below = this_plot->line_type + 1;
X		    }
X#endif /* not LITE */		    
X		    if (key != 0 && this_plot->title) {
X			if ((*t->justify_text)(RIGHT)) {
X			    clip_put_text(xl,
X					  yl,this_plot->title);
X			}
X			else {
X			    if (inrange(xl-(t->h_char)*strlen(this_plot->title), 
X					xleft, xright))
X				clip_put_text(xl-(t->h_char)*strlen(this_plot->title),
X					      yl,this_plot->title);
X			}
X		    }
X		    
X		    switch(this_plot->plot_style) {
X				case BOXES: /* can't do boxes in 3d yet so use impulses */
X		        case IMPULSES: {
X			    if (key != 0 && this_plot->title) {
X				clip_move(xl+(t->h_char),yl);
X				clip_vector(xl+4*(t->h_char),yl);
X			    }
X			    if (!(hidden3d && draw_surface))
X			      plot3d_impulses(this_plot);
X			    break;
X			}
X			case LINES: {
X			    if (key != 0 && this_plot->title) {
X				clip_move(xl+(int)(t->h_char),yl);
X				clip_vector(xl+(int)(4*(t->h_char)),yl);
X			    }
X			    if (!(hidden3d && draw_surface))
X			      plot3d_lines(this_plot);
X			    break;
X			}
X			case ERRORBARS:	/* ignored; treat like points */
X			case POINTSTYLE: {
X			    if (key != 0 && this_plot->title 
X				&& !clip_point(xl+2*(t->h_char),yl)) {
X				(*t->point)(xl+2*(t->h_char),yl,
X					    this_plot->point_type);
X			    }
X			    if (!(hidden3d && draw_surface))
X			      plot3d_points(this_plot);
X			    break;
X			}
X			case LINESPOINTS: {
X			    /* put lines */
X			    if (key != 0 && this_plot->title) {
X				clip_move(xl+(t->h_char),yl);
X				clip_vector(xl+4*(t->h_char),yl);
X			    }
X 			    if (!(hidden3d && draw_surface))
X 			      plot3d_lines(this_plot);
X			
X			    /* put points */
X			    if (key != 0 && this_plot->title 
X				&& !clip_point(xl+2*(t->h_char),yl)) {
X				(*t->point)(xl+2*(t->h_char),yl,
X					    this_plot->point_type);
X			    }
X			    if (!(hidden3d && draw_surface))
X			      plot3d_points(this_plot);
X			    break;
X			}
X			case DOTS: {
X			    if (key != 0 && this_plot->title
X				&& !clip_point(xl+2*(t->h_char),yl)) {
X				(*t->point)(xl+2*(t->h_char),yl, -1);
X			    }
X			    if (!(hidden3d && draw_surface))
X			      plot3d_dots(this_plot);
X			    break;
X			}
X		    }
X		    if (key != 0 && this_plot->title)
X		        yl = yl - (t->v_char);
X		}
X
X#ifndef LITE
X		if ( hidden3d ) {
X		    hidden_no_update = TRUE;
X		    hidden_line_type_above = this_plot->line_type + (hidden3d ? 2 : 1);
X		    hidden_line_type_below = this_plot->line_type + (hidden3d ? 2 : 1);
X		}
X#endif /* not LITE */
X
X		if (draw_contour && this_plot->contours != NULL) {
X			struct gnuplot_contours *cntrs = this_plot->contours;
X
X			(*t->linetype)(this_plot->line_type + (hidden3d ? 2 : 1));
X
X			if (key != 0 && this_plot->title 
X			          && !(draw_surface && label_contours) ) {
X				if ((*t->justify_text)(RIGHT)) {
X					clip_put_text(xl,
X						yl,this_plot->title);
X				}
X				else {
X				    if (inrange(xl-(t->h_char)*strlen(this_plot->title), 
X							 xleft, xright))
X					 clip_put_text(xl-(t->h_char)*strlen(this_plot->title),
X								 yl,this_plot->title);
X				}
X				switch(this_plot->plot_style) {
X					case IMPULSES:
X						clip_move(xl+(t->h_char),yl);
X						clip_vector(xl+4*(t->h_char),yl);
X						break;
X					case LINES:
X						clip_move(xl+(int)(t->h_char),yl);
X						clip_vector(xl+(int)(4*(t->h_char)),yl);
X						break;
X					case ERRORBARS: /* ignored; treat like points */
X					case POINTSTYLE:
X						if (!clip_point(xl+2*(t->h_char),yl)) {
X						     (*t->point)(xl+2*(t->h_char),yl,
X								    this_plot->point_type);
X						}
X						break;
X					case LINESPOINTS:
X						clip_move(xl+(int)(t->h_char),yl);
X						clip_vector(xl+(int)(4*(t->h_char)),yl);
X						break;
X					case DOTS:
X						if (!clip_point(xl+2*(t->h_char),yl)) {
X						     (*t->point)(xl+2*(t->h_char),yl, -1);
X						}
X						break;
X				}
X				yl = yl - (t->v_char);
X			}
X			yl = yl + (t->v_char);
X
X 			linetypeOffset = this_plot->line_type + (hidden3d ? 2 : 1);
X			while (cntrs) {
X 				if(label_contours && cntrs->isNewLevel) {
X 					(*t->linetype)(linetypeOffset++);
X#ifndef LITE
X 					if(hidden3d) hidden_line_type_below = hidden_line_type_above = linetypeOffset-1;
X#endif /* not LITE */
X 					yl -= (t->v_char);
X 					if ((*t->justify_text)(RIGHT)) {
X 					   clip_put_text(xl,
X 						   yl,cntrs->label);
X 				   }
X 				   else {
X 					   if (inrange(xl-(t->h_char)*strlen(cntrs->label),
X 								xleft, xright))
X 						clip_put_text(xl-(t->h_char)*strlen(cntrs->label),
X 									yl,cntrs->label);
X 				   }
X 				   switch(this_plot->plot_style) {
X 					   case IMPULSES:
X 						   clip_move(xl+(t->h_char),yl);
X 						   clip_vector(xl+4*(t->h_char),yl);
X 						   break;
X 					   case LINES:
X 						   clip_move(xl+(int)(t->h_char),yl);
X 						   clip_vector(xl+(int)(4*(t->h_char)),yl);
X 						   break;
X 					   case ERRORBARS: /* ignored; treat like points */
X 					   case POINTSTYLE:
X 						   if (!clip_point(xl+2*(t->h_char),yl)) {
X 								(*t->point)(xl+2*(t->h_char),yl,
X 									   this_plot->point_type);
X 						   }
X 						   break;
X 					   case LINESPOINTS:
X 						   clip_move(xl+(int)(t->h_char),yl);
X 						   clip_vector(xl+(int)(4*(t->h_char)),yl);
X 						   break;
X 					   case DOTS:
X 						   if (!clip_point(xl+2*(t->h_char),yl)) {
X 								(*t->point)(xl+2*(t->h_char),yl, -1);
X 						   }
X 						   break;
X 				   }
X 				}
X				switch(this_plot->plot_style) {
X					case IMPULSES:
X			   			cntr3d_impulses(cntrs, this_plot);
X						break;
X					case LINES:
X						cntr3d_lines(cntrs);
X						break;
X					case ERRORBARS: /* ignored; treat like points */
X					case POINTSTYLE:
X						cntr3d_points(cntrs, this_plot);
X						break;
X					case LINESPOINTS:
X						cntr3d_lines(cntrs);
X						cntr3d_points(cntrs, this_plot);
X						break;
X					case DOTS:
X						cntr3d_dots(cntrs);
X						break;
X				}
X				cntrs = cntrs->next;
X			}
X			if (key != 0 && this_plot->title)
X			  yl = yl - (t->v_char);
X		}
X
X		if (surface == 0)
X		    draw_bottom_grid(this_plot,real_z_min3d,real_z_max3d);
X	}
X	(*t->text)();
X	(void) fflush(outfile);
X
X#ifndef LITE
X	if (hidden3d) {
X	    term_hidden_line_removal();
X	    hidden_active = FALSE;
X	}
X#endif /* not LITE */
X}
X
X/* plot3d_impulses:
X * Plot the surfaces in IMPULSES style
X */
Xstatic plot3d_impulses(plot)
X	struct surface_points *plot;
X{
X    int i;				/* point index */
X    int x,y,x0,y0;			/* point in terminal coordinates */
X    struct iso_curve *icrvs = plot->iso_crvs;
X
X    while ( icrvs ) {
X	struct coordinate GPHUGE *points = icrvs->points;
X
X	for (i = 0; i < icrvs->p_count; i++) {
X	    if (real_z_max3d<points[i].z)
X		real_z_max3d=points[i].z;
X	    if (real_z_min3d>points[i].z)
X		real_z_min3d=points[i].z;
X
X	    map3d_xy(points[i].x, points[i].y, points[i].z, &x, &y);
X	    map3d_xy(points[i].x, points[i].y, z_min3d, &x0, &y0);
X
X	    clip_move(x0,y0);
X	    clip_vector(x,y);
X	}
X
X	icrvs = icrvs->next;
X    }
X}
X
X/* plot3d_lines:
X * Plot the surfaces in LINES style
X */
X/* We want to always draw the lines in the same direction, otherwise when
X   we draw an adjacent box we might get the line drawn a little differently
X   and we get splotches.  */
X
X#ifndef LITE
X
Xstatic int zsort( r1, r2)
Xint * r1;
Xint * r2;
X{
X  int z1, z2;
X  z1 = nodes[*r1].z;
X  z2 = nodes[*r2].z;
X  if (z1 < z2) return 1;
X  if (z1 == z2) return 0;
X  return -1;
X}
X#define TESTBOX(X,Y)					\
X  if(X<xmin_box) xmin_box = X;				\
X  if(X>xmax_box) xmax_box = X;				\
X  if(Y<ymin_box) ymin_box = Y;				\
X  if(Y>ymax_box) ymax_box = Y;
X/* Usefull macro to help us figure out which side of the surface we are on */
X#define XPRD(I,J,K) 					\
X  ((nodes[I].x-nodes[J].x)*(nodes[J].y-nodes[K].y) -	\
X  (nodes[I].y-nodes[J].y)*(nodes[J].x-nodes[K].x))
X#define MAYBE_LINEPOINT(J)				        \
X    if((nodes[J].flag & 0x20) != 0) {				\
X      x = nodes[J].x;						\
X      y = nodes[J].y;						\
X      nodes[J].flag -= 0x20;					\
X      if (!clip_point(x,y) && 					\
X	  !IFSET(XREDUCE(x)-XREDUCE(xleft),YREDUCE(y)-YREDUCE(ybot))) \
X	(*t->point)(x,y, plot_info[nplot].point_type);		\
X    };
X
Xstruct surface_plots{
X  int above_color;
X  int below_color;
X  int row_offset;
X  int point_type;
X};
X/* All of the plots coming into this routine are assumed to have grid
X   topology.  */
X
Xstatic plot3d_hidden(plots, pcount)
X     struct surface_points *plots;
X     int pcount;
X{
X  struct surface_points *this_plot;
X  long int i, j;
X  int nplot;
X  long int x,y,z ,nseg, ncrv, ncrv1;        /* point in terminal coordinates */
X#ifdef AMIGA_SC_6_1
X  unsigned short int * cpnt;
X#else /* !AMIGA_SC_6_1 */
X  short int * cpnt;
X#endif /* !AMIGA_SC_6_1 */
X  short int  mask1, mask2;
X  long int indx1, indx2, k, m;
X  short int xmin_box, xmax_box, ymin_box, ymax_box;
X  struct surface_plots * plot_info;
X  int row_offset, nnode;
X  short int y_malloc;  /* Amount of space we need for one vertical row of
X                          bitmap, and byte offset of first used element */
X  struct termentry *t = &term_tbl[term];
X  struct iso_curve *icrvs;
X  int current_style = 0x7fff;  /* Current line style */
X  int surface;
X  nnode = 0;
X  nseg = 0;
X  nplot = 0;
X  this_plot = plots;
X
X  for (surface = 0;
X       surface < pcount;
X       this_plot = this_plot->next_sp, surface++) {
X    nplot++;
X    icrvs = plots->iso_crvs;
X    icrvs = plots->iso_crvs;
X    if(this_plot->plot_type == FUNC3D) {
X        for(icrvs = this_plot->iso_crvs,ncrv=0;icrvs;icrvs=icrvs->next,ncrv++) { };
X /*      if(this_plot->has_grid_topology) ncrv >>= 1; */
X    };
X    if(this_plot->plot_type == DATA3D)
X       ncrv = this_plot->num_iso_read;
X    nnode += ncrv * (this_plot->iso_crvs->p_count);
X/*    for(icrvs = this_plot->iso_crvs,ncrv=0;icrvs;icrvs=icrvs->next,ncrv++) { };
X    nnode += ncrv * (this_plot->iso_crvs->p_count); */
X    switch(this_plot->plot_style) {
X    case ERRORBARS:
X    case DOTS:
X    case POINTSTYLE:
X    case LINESPOINTS:
X      nseg += (ncrv) * (this_plot->iso_crvs->p_count);
X      break;
X    case LINES:
X      nseg += (ncrv-1) * (this_plot->iso_crvs->p_count-1);
X      break;
X    case IMPULSES:
X      /* There will be two nodes for each segment */
X      nnode += ncrv * (this_plot->iso_crvs->p_count);
X      nseg += (ncrv) * (this_plot->iso_crvs->p_count);
X      break;
X    }
X  };
X  boxlist = (int *) alloc((unsigned long)sizeof(int)*nseg, "hidden");
X  nodes = (struct pnts *) alloc((unsigned long)sizeof(struct pnts)*nnode, "hidden");
X  plot_info = (struct surface_plots *) alloc((unsigned long)sizeof(struct surface_plots)*nplot,"hidden");
X  nnode = 0;
X  nseg = 0;
X  nplot = 0;
X  this_plot = plots;
X  hidden_no_update = FALSE;
X
X  if ( hidden3d && draw_surface)
X    for (surface = 0;
X	 surface < pcount;
X	 this_plot = this_plot->next_sp, surface++) {
X      (*t->linetype)(this_plot->line_type);
X      hidden_line_type_above = this_plot->line_type;
X		hidden_line_type_below = this_plot->line_type + 1;
X    if(this_plot->plot_type == FUNC3D) {
X      for(icrvs = this_plot->iso_crvs,ncrv=0;icrvs;icrvs=icrvs->next,ncrv++) { };
X/*      if(this_plot->has_grid_topology) ncrv >>= 1; */
X    };
X    if(this_plot->plot_type == DATA3D)
X      ncrv = this_plot->num_iso_read;
X      icrvs = this_plot->iso_crvs;
X      ncrv1 = ncrv;
X      ncrv = 0;
X      while ( icrvs) {
X	struct coordinate GPHUGE *points = icrvs->points;
X	for (i = 0; i < icrvs->p_count; i++) {
X	  map3d_xy(points[i].x, points[i].y, points[i].z,&nodes[nnode].x,&nodes[nnode].y);
X	  nodes[nnode].z = map3d_z(points[i].x, points[i].y, points[i].z);
X	  nodes[nnode].flag = (i==0 ? 1 : 0) + (ncrv == 0 ? 2 : 0) +
X	    (i == icrvs->p_count-1 ? 4 : 0) + (ncrv == ncrv1-1 ? 8 : 0);
X	  nodes[nnode].nplot = nplot;
X	  nodes[nnode].style_used = -1000; /* indicates no style */
X	  switch(this_plot->plot_style) {
X	  case LINESPOINTS:
X	    if(i < icrvs->p_count-1 && ncrv < ncrv1-1)
X	      nodes[nnode].flag |= 0x30;
X	    else
X	      nodes[nnode].flag |= 0x20;
X	    boxlist[nseg++] = nnode++;
X	    break;
X	  case LINES:
X	    if(i < icrvs->p_count-1 && ncrv < ncrv1-1)
X	      {
X		nodes[nnode].flag |= 0x10;
X		boxlist[nseg++] = nnode++;
X	      }
X	    else
X	      nnode++;
X	    break;
X	  case ERRORBARS:
X	  case POINTSTYLE:
X	  case DOTS:
X	    nodes[nnode].flag |= 0x40;
X	    boxlist[nseg++] = nnode++;
X	    break;
X	  case IMPULSES:
X	    nodes[nnode].flag |= 0x80;
X	    boxlist[nseg++] = nnode++;
X	    map3d_xy(points[i].x, points[i].y, z_min3d, &nodes[nnode].x,&nodes[nnode].y);
X	    nodes[nnode].z = map3d_z(points[i].x, points[i].y, z_min3d);
X	    nnode++;
X	    break;
X	    break;
X	  }
X	}
X	icrvs = icrvs->next;
X	ncrv++;
X	if(ncrv == ncrv1) break;
X      }
X      /* Next we go through all of the boxes, and substitute the average z value
X	 for the box for the z value of the corner node */
X      plot_info[nplot].above_color = this_plot->line_type;
X      plot_info[nplot].below_color = this_plot->line_type+1;
X      plot_info[nplot].point_type =
X	((this_plot->plot_style == DOTS) ? -1 : this_plot->point_type);
X      plot_info[nplot++].row_offset = this_plot->iso_crvs->p_count;
X    }
X      for(i=0; i<nseg; i++){
X	j = boxlist[i];
X	if ((nodes[j].flag & 0x80) != 0) {
X	  nodes[j].z = (nodes[j].z < nodes[j+1].z ? nodes[j].z : nodes[j+1].z);
X	  continue;
X	};
X	if ((nodes[j].flag & 0x10) == 0) continue;
X	row_offset = plot_info[nodes[j].nplot].row_offset;
X	z = nodes[j].z;
X	if (z < nodes[j+1].z) z = nodes[j+1].z;
X	if (z < nodes[j+row_offset].z) z = nodes[j+row_offset].z;
X	if (z < nodes[j+row_offset+1].z) z = nodes[j+row_offset+1].z;
X      };
X  qsort (boxlist, nseg, sizeof(int), zsort);
X  y_malloc = (2+ (YREDUCE(ytop)>>4) - (YREDUCE(ybot)>>4))*sizeof(short int);
X  for(i=0;i<=(XREDUCE(xright)-XREDUCE(xleft));i++) {
X    ymin_hl[i] = 0x7fff; 
X    ymax_hl[i] = 0;
X  };
X  for(i=0;i<nseg;i++) {
X    j = boxlist[i];
X    nplot = nodes[j].nplot;
X    row_offset = plot_info[nplot].row_offset;
X    if((nodes[j].flag & 0x40) != 0) {
X      x = nodes[j].x;
X      y = nodes[j].y;
X      if (!clip_point(x,y) &&
X	  !IFSET(XREDUCE(x)-XREDUCE(xleft),YREDUCE(y)-YREDUCE(ybot)))
X	(*t->point)(x,y, plot_info[nplot].point_type);
X    };
X    if((nodes[j].flag & 0x80) != 0) { /* impulses */
X      clip_move(nodes[j].x,nodes[j].y);
X      clip_vector(nodes[j+1].x,nodes[j+1].y);
X    };
X    if((nodes[j].flag & 0x10) != 0) {
X/* It is possible, and often profitable, to take a quick look and see
X   if the current box is entirely obscured.  If this is the case we will
X   not even bother testing this box any further.  */
END_OF_FILE
  if test 42442 -ne `wc -c <'gnuplot/graph3d.c.A'`; then
    echo shar: \"'gnuplot/graph3d.c.A'\" unpacked with wrong size!
  elif test -f 'gnuplot/graph3d.c.B' ; then
    echo shar: Combining  \"'gnuplot/graph3d.c'\" \(82372 characters\)
    cat 'gnuplot/graph3d.c.A' 'gnuplot/graph3d.c.B' > 'gnuplot/graph3d.c'
    if test 82372 -ne `wc -c <'gnuplot/graph3d.c'`; then
      echo shar: \"'gnuplot/graph3d.c'\" combined with wrong size!
    else 
      rm gnuplot/graph3d.c.A gnuplot/graph3d.c.B
    fi 
  fi
  # end of 'gnuplot/graph3d.c.A'
fi
if test -f 'gnuplot/makefile.unx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.unx'\"
else
  echo shar: Extracting \"'gnuplot/makefile.unx'\" \(33720 characters\)
  sed "s/^X//" >'gnuplot/makefile.unx' <<'END_OF_FILE'
X#
X# $Id: makefile.unx%v 3.50.1.16 1993/08/27 05:04:42 woo Exp $
X#
X#
X############################################################
X#
X# GNUPLOT 3.0 Makefile (Unix X11 support) for
X#  Apollo/Sun/Dec5000/IBM-RS6000/HP9000/SGI/3B1/386IX/Cray
X#
X# Original version by:
X#   oliveria@caen.engin.umich.edu (ROQUE DONIZETE DE OLIVEIRA)
X#   Wed, 3 Jul 91 14:31:37 -0400
X#
X#>>> Customizing: You must customize part of this makefile for your site.
X#>>> Then type 'make' for further instructions.
X#>>> Customization instructions look like these lines do (#>>>).
X#
X
X.NOEXPORT:
X
XTARGET = All# What to make by default
X
X############################################################
X#>>> Decide where the binaries and manuals will go.
X# directory where to install executables on 'make install'
XDEST=/usr/local/bin
X# directory for installing man page on 'make man_install'.
XMANDEST=/usr/local/man/manl
X# where to install help file gnuplot.gih
XHELPDEST=/usr/local/lib
X#HELPDEST=docs/gnuplot.gih
X# Where to send email about bugs and comments (locally)
XEMAIL=bug-gnuplot@dartmouth.edu
X
X############################################################
X#>>> Some machines may need MAKE to be defined explicitly
XMAKE   = make
X#>>> Choose your C compiler and basic compiler flags.
X# the C compiler
XCC     = cc
X# -O if you trust your compiler's optimizer
XCOPTS  =
X# default loading command
XLD     = $(CC) $(CFLAGS)
XNPROC  = 2
X#
X############################################################
X#>>> Choose some optional features.
X#>>> At this point there are only two optional features:
X# READLINE:
X#   If READLINE is defined, then command-line editing is supported.
X#   Otherwise, your normal terminal editing is all you get.
X#   Some machines will not support this, and they will turn this
X#   option off (for example, apollos running SR10.2 or SR10.3 and
X#   loaded with BSD4.3 instead of SYS5). Note: problems with
X#   gnuplot prompts have been noted when this feature is selected
X#   on IBM RS/6000 AIX, and compile errors are encountered on
X#   Sequent Dynix 3 and Convex OS 9.0.
X# NOCWDRC:
X#   If NOCWDRC is defined, then any .gnuplot in the current directory
X#   is not read on startup. This is a security consideration
X#   especially for root users ( we recommend you define -DNOCWDRC ).
XOPTIONS = -DREADLINE -DNOCWDRC
X
X#>>> Optionally install the lasergnu script.
X# Lasergnu is a handy shell script for creating a plot from the
X# command line and sending it directly to the printer. It currently
X# supports PostScript and imagen printers, and probably would need
X# tailoring to your site.
X# Use lasergnu_install to install lasergnu.
X# Use lasergnu_noinstall to not install lasergnu (default).
XLASERGNU = lasergnu_install
X
X############################################################
X# X11 support
X#
X
X#>>> List your X11 libraries
XX11LIBS = -lX11
X
X#>>> List where the X11 include directory is found (if other than /usr/include)
XX11INCLUDES =
X
X#>>> List additional CFLAGS for X11 compilation
X# -DOLD_SELECT if you have an old 4.2 BSD OS (e.g. Sun OS 3.5) and
X#   encounter compile error for missing include file <sys/select.h>
X# -DBSD_TYPES if your system defines FD_* macros for select in
X#   <sys/bsdtypes.h>
X# -ISC22 to circumvent missing plots past the first on ISC 2.2
XX11FLAGS =
X
X#>>> You shouldn't have to change these, since they are controlled by
X#>>> Machine dependent definitions below.
X#       Compile option for plot.c and TERMFLAGS, to include X11 support
XPLOTXFLAG = -DX11
X#       make gnuplot_x11 by default
XGNUPLOT_X11 = gnuplot_x11
X#       install gnuplot_x11 by default
XX11INSTALL = x11_install
X
X############################################################
X#>>> Okay, you've changed enough. Now type 'make'.
X
X############################################################
X# This is used to pass many of the above definitions to make
X# subprocesses. Don't change this.
XMY_FLAGS  = CC="$(CC)" COPTS="$(COPTS)" DEST="$(DEST)" \
X        MANDEST="$(MANDEST)" HELPDEST="$(HELPDEST)" \
X        EMAIL="$(EMAIL)" LASERGNU="$(LASERGNU)"
X
X############################################################
X# Explanations of CFLAGS definitions.
X#  These should not need to be changed by you.
X# They are set correctly for each machine below. If your machine
X# doesn't fit the one of the patterns, override on the make command
X# line or make a new target for it and a new _FLAGS definition.
X#  -DNOVFORK if you're unix and you have don't have vfork()
X#  -DMEMSET if you need to use memset() instead of bzero()
X#  -DMEMCPY if your bcopy() is called memcpy()
X#  -DNOCOPY if you don't have a memcpy() by any name
X#  -DGAMMA=foo if your gamma function is called foo(). Apollos have
X#    lgamma(3m). The default is -DGAMMA=gamma.
X#  -DGETCWD if your unix uses getcwd() instead of getcd()
X#    this is needed by HP-UX and Cray Unicos systems.
X#  -DULTRIX_KLUDGE if you run X windows on Ultrix and experience the
X#    "every other plot" problem.
X#  -DCRIPPLED_SELECT if "select errors" are encountered with X. This
X#    option is needed on SVR3 platforms with incomplete support for
X#    the BSD select() system call
X#  -DXPG3_LOCALE if your system uses the 'setlocale' function to
X#    support foreign charactersets (currently only ISO8859-1).
X#  -Dunix is required to explicitly define "unix" for SCO and IBM
X#          RS/6000 running AIX 3.2
X#  -fswitch if you are compiling on a Sun3 (or even -f68881)
X#    (but -fswitch is buggy on some systems, so watch out)
X
X# Defaults in case the user types 'make All' directly
X# Should match X11_FLAGS's CFLAGS definition
XCFLAGS = $(COPTS) $(OPTIONS)
X
X############################################################
X# Terminal (device) support
X#
X# All devices available to a given machine are compiled in by default.
X# This documents the flags available in TERMFLAGS, although TERMFLAGS
X# is usually controlled by the machine-dependent definitions below.
X# See other terminal defines in term.h.
X# Define ULTRIX_KLUDGE if you have the every-other plot problem in Ultrix X11.
X#
X# -DAPOLLO      Apollo Graphics Primitive Resource (window resize after replot)
X# -DGPR         Apollo Graphics Primitive Resource (fixed-size window)
X# -DCGI         SCO CGI
X# -DIRIS4D      IRIS4D series computer
X# -DSUN         Sun Microsystems Workstation
X# -DUNIXPC      unixpc (ATT 3b1 or ATT 7300)
X# -DUNIXPLOT    unixplot
X# -DGNUGRAPH    use GNU graphics version of UNIX plot library
X#               This can only be used in combination with -DUNIXPLOT
X# -DX11         X11 Window System (This is $(PLOTXFLAG))
XTERMFLAGS = -Iterm $(PLOTXFLAG)
X
X############################################################
X# Library explanations.
X#  You shouldn't need to adjust this; again, it is handled by the
X# machine-dependent definitions below.
X#
X#  -lplot if you have -DUNIXPLOT in TERMFLAGS
X#  -lsuntool -lsunwindow -lpixrect  if you have -DSUN in TERMFLAGS
X#  -lgl_s if -DIRIS4D in TERMFLAGS
X#  -lccgi if -DCGI in TERMFLAGS
X#  -lmgr -lpixrect if -DMGR in TERMFLAGS. (conflicts with SunView)
XLIBS = -lm # -lplot is no longer shipped on SUNs
X
X####################################################################
X# List of object files except version.o
XOBJS = bitmap.o command.o contour.o eval.o graphics.o graph3d.o help.o \
X       internal.o misc.o parse.o plot.o readline.o scanner.o \
X       setshow.o specfun.o standard.o term.o util.o gnubin.o binary.o
X
XNEXTOBJS = epsviewe.o
X############################################################
X# Machine-dependent settings.
X#
XX11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS)" \
X           LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS)"
X
XDEC_OSF_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -I/usr/sys/include -I/usr/sys/BINARY -DANSI -DNOVFORK -DGAMMA=lgamma -D_XOPEN_SOURCE " \
X           LIBS="$(LIBS) -ldnet_stub" \
X           X11FLAGS="$(X11FLAGS) -DMOTIF -D_NO_PROTO -D_OSF_SOURCE" \
X           X11INCLUDES="$(X11INCLUDES) -I/usr/include/Xm" \
X           X11LIBS="$(X11LIBS) -ldnet_stub" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) "
X
XDEC_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) " \
X           LIBS="-lplot $(LIBS)" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) -DULTRIX_KLUDGE"
X
XAPOLLO_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGAMMA=lgamma" \
X           LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="-L/usr/lib/X11 -lX11" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) -DAPOLLO -DGPR"
X
XHP_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DMEMSET -DMEMCPY -DGETCWD" \
X           LIBS="-lm" X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="/usr/include/X11R4" \
X           X11LIBS="-L/usr/lib/X11R4 -lX11" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="-Iterm -DX11"
X
XSOLARIS_X11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DMEMSET -DMEMCPY -DGETCWD -DSOLARIS" \
X           X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) -DSOLARIS"
X
XSUN_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DSUN" \
X           LIBS="-lsuntool -lsunwindow -lpixrect $(LIBS)" \
X           X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " \
X           PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm"
X
XSUN_X11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) " \
X           LIBS="-L/usr/openwin/lib $(LIBS)" \
X           X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="-I/usr/openwin/include $(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS)"
X
XSUN_X11_MGR_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS)" \
X           LIBS="-lmgr -lpixrect -L/usr/mgr/lib $(LIBS)" \
X           X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="-I/usr/mgr/include -Iterm -DMGR $(TERMFLAGS)"
X
XSGI_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
X           LIBS="-lgl_s -lm" X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " \
X           PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm -DIRIS4D -DANSI"
X
XSGIX11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
X           LIBS="-lgl_s -lm -lc_s" X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="-L/usr/lib/X11 -lX11" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="-Iterm -DX11 -DIRIS4D -DANSI"
X
XCGI_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -Dunix" \
X           LIBS="-lccgi $(LIBS)" X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm -DUNIXPLOT -DCGI"
X
X3B1_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK" \
X           LIBS="$(LIBS)" X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " \
X           PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           LD="ld /lib/crt0s.o /lib/shlib.ifile" \
X           TERMFLAGS="-Iterm -DUNIXPC"
X
X3B2_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK" \
X           X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " \
X           PLOTXFLAG=" " GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm -DUNIXPLOT" LIBS="$(LIBS) -lplot"
X
X386IX_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK -DTCSETSW -DTCGETS" \
X           LIBS="$(LIBS) -lcposix" X11FLAGS=" " X11INCLUDES=" " \
X           X11LIBS=" " PLOTXFLAG=" " GNUPLOT_X11=" " \
X           X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm -DUNIXPLOT"
X
X386IX_X11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK -DTCSETSW -DTCGETS" \
X           LIBS="$(LIBS) -lcposix" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
X           X11INSTALL= "$(X11INSTALL)" \
X           TERMFLAGS="-Iterm -DUNIXPLOT -DX11"
X
XISC22_X11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DNOVFORK -DISC22" \
X           LIBS="$(LIBS) -lplot -lcposix" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS) -linet -lpt -lcposix" PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
X           X11INSTALL= "$(X11INSTALL)" \
X           TERMFLAGS="-Iterm -DUNIXPLOT -DX11"
X
XAIX_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGAMMA=gamma -DXPG3_LOCALE -Dunix" \
X           LIBS="$(LIBS) -lbsd" X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) -qmaxmem=9000" \
X           COMFLAGS="-qmaxmem=3000" SSFLAGS="-qmaxmem=3000"
X
XAIXO_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DGAMMA=gamma -DXPG3_LOCALE -Dunix" \
X           LIBS="$(LIBS) -lbsd" X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS)"
X
XNEXT_FLAGS = \
X           CFLAGS="$(COPTS) -DGAMMA=lgamma -DNEXT -DREADLINE -DSGTTY" \
X           LIBS="-lNeXT_s -lsys_s -lm" \
X           X11FLAGS="$(X11FLAGS)" \
X           X11INCLUDES=" " X11LIBS=" " PLOTXFLAG=" " \
X           GNUPLOT_X11=" " X11INSTALL=x11_noinstall \
X           TERMFLAGS="-Iterm -ObjC -DANSI" OBJS=" $(OBJS) $(NEXTOBJS)"
X
XNEXT_X11_FLAGS = \
X           CFLAGS="$(COPTS) -DGAMMA=lgamma -DNEXT -DREADLINE -DSGTTY -DX_NOT_POSIX" \
X           LIBS="-lNeXT_s -lsys_s -lm" \
X           X11LIBS="-L/usr/lib/X11 -lX11" \
X           X11INCLUDES="$(X11INCLUDES)" X11FLAGS="$(X11FLAGS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="-Iterm -DX11 -ObjC -DANSI" OBJS=" $(OBJS) $(NEXTOBJS)"
X
XCRAY_FLAGS = \
X       CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
X       LIBS="-lm" X11FLAGS=" " \
X       X11INCLUDES=" " \
X       X11LIBS=" " \
X       PLOTXFLAG=" " GNUPLOT_X11=" " \
X       X11INSTALL=x11_noinstall \
X       TERMFLAGS="-Iterm"
X
XCRAY_X11_FLAGS = \
X       CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DNOVFORK" \
X       LIBS="-lm" X11FLAGS="$(X11FLAGS)" \
X       X11INCLUDES="$(X11INCLUDES)" \
X       X11LIBS="$(X11LIBS)" \
X       PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
X       X11INSTALL=$(X11INSTALL) \
X       TERMFLAGS="-Iterm -DX11"
X
XPTX_X11_FLAGS = \
X       CFLAGS="$(COPTS) $(OPTIONS) -DGETCWD -DMEMSET -DMEMCPY -DCRIPPLED_SELECT" \
X       LIBS="-lm -lplot" X11FLAGS="$(X11FLAGS)" \
X       X11INCLUDES="$(X11INCLUDES)" \
X       X11LIBS="-lX11 -lseq -lsocket -linet -lnsl" \
X       PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
X       X11INSTALL=$(X11INSTALL) \
X       TERMFLAGS="$(TERMFLAGS)"
X
XSEQUENT_X11_FLAGS = \
X       CFLAGS="$(COPTS) $(OPTIONS) -DSGTTY -DCRIPPLED_SELECT" \
X       LIBS="-lm -lplot" X11FLAGS="$(X11FLAGS) -DX_WCHAR" \
X       X11INCLUDES="$(X11INCLUDES)" \
X       X11LIBS="-lX11 -lseq " \
X       PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11="$(GNUPLOT_X11)" \
X       X11INSTALL=$(X11INSTALL) \
X       TERMFLAGS="$(TERMFLAGS)"
X
XCONVEX_X11_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -DHUGE=8.9e307" \
X           LIBS="$(LIBS)" X11FLAGS="$(X11FLAGS)" X11INCLUDES="$(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS)"
X
XKSR_FLAGS = \
X           CFLAGS="$(COPTS) $(OPTIONS) -I/usr/sys/include -I/usr/sys/BINARY -DANSI -DNOVFORK -DNOGAMMA -D_XOPEN_SOURCE -DKSR" \
X           LIBS="$(LIBS)" \
X           X11FLAGS="$(X11FLAGS) -DMOTIF -D_NO_PROTO -D_OSF_SOURCE" \
X           X11INCLUDES="$(X11INCLUDES) -I/usr/include/Xm" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS) "
X
XLINUX_FLAGS = \
X		   CFLAGS="$(COPTS) $(OPTIONS) -m486 -DGAMMA=lgamma" \
X		   LIBS="-L/usr/X386/lib -lX11 $(LIBS)" \
X           X11FLAGS="$(X11FLAGS)" X11INCLUDES="-I/usr/X386/include $(X11INCLUDES)" \
X           X11LIBS="$(X11LIBS)" \
X           PLOTXFLAG="$(PLOTXFLAG)" GNUPLOT_X11=$(GNUPLOT_X11) \
X           X11INSTALL="$(X11INSTALL)" \
X           TERMFLAGS="$(TERMFLAGS)"
X
X####################################################################
X# List of source files
X# Used for making shar files, lint, and some dependencies.
XDIRS = term demo docs docs/latextut
X
XCSOURCE1 = bf_test.c binary.c command.c setshow.c
XCSOURCE2 = help.c gnubin.c graphics.c graph3d.c internal.c
XCSOURCE3 = misc.c eval.c parse.c plot.c readline.c scanner.c standard.c
XCSOURCE4 = bitmap.c term.c util.c version.c
XCSOURCE5 = term/ai.trm term/amiga.trm term/aed.trm term/atari.trm \
X	term/bigfig.trm term/cgi.trm term/corel.trm \
X	term/djsvga.trm term/dumb.trm \
X	term/dxf.trm term/dxy.trm term/debug.trm \
X	term/emxvga.trm term/eepic.trm term/epson.trm term/excl.trm \
X	term/fig.trm term/grass.trm term/hp26.trm term/hp2648.trm term/hpgl.trm \
X	term/hp500c.trm term/hpljii.trm term/metafont.trm term/mgr.trm\
X	term/apollo.trm term/gpr.trm term/hppj.trm term/compact.c
XCSOURCE6 = term/impcodes.h term/imagen.trm term/next.trm term/object.h \
X	term/iris4d.trm term/kyo.trm term/latex.trm term/mif.trm \
X	term/pbm.trm term/pslatex.trm term/gpic.trm term/gnugraph.trm
XCSOURCE7 = term/post.trm term/pstricks.trm term/qms.trm term/regis.trm \
X	term/rgip.trm term/sun.trm \
X	term/t410x.trm term/tek.trm term/texdraw.trm term/tgif.h \
X	term/tgif.trm term/tpic.trm \
X	term/unixpc.trm term/unixplot.trm \
X	term/v384.trm term/vws.trm term/x11.trm term/xlib.trm
XCSOURCE8 = contour.c specfun.c gplt_x11.c
XCONFIGURE = configure configure.in Makefile.in docs/Makefile.in\
X	docs/latextut/Makefile.in 0CONFIG
XNEXTSRC  = epsviewe.m epsviewe.h
X# not C code, but still needed
X
XDEMOS = demo/1.dat demo/2.dat demo/3.dat demo/contours.dem \
X	demo/controls.dem demo/electron.dem demo/glass.dat demo/param.dem \
X	demo/polar.dem demo/simple.dem demo/surface1.dem \
X	demo/surface2.dem demo/using.dat demo/using.dem demo/world.cor \
X	demo/world.dat demo/world.dem \
X	demo/err.dat demo/poldat.dem demo/polar.dat demo/errorbar.dem \
X	demo/antenna.dat demo/all.dem demo/animate.dem demo/bivariat.dem \
X	demo/prob.dem demo/stat.inc demo/prob2.dem demo/random.dem \
X	demo/discrete.dem demo/hidden.dem demo/airfoil.dem demo/gnuplot.rot\
X	demo/binary.dem demo/spline.dem demo/steps.dem demo/steps.dat \
X	demo/multimsh.dem demo/whale.dat demo/hemisphr.dat \
X	demo/scatter.dem demo/scatter2.dat demo/singulr.dem demo/klein.dat
X
XETC = Copyright 0README README.gnu README.ami makefile.unx makefile.vms \
X	linkopt.amg makefile.amg makefile.ami linkopt.vms buildvms.com \
X	lasergnu makefile.r makefile.nt makefile.g 0FAQ 0BUGS\
X	term/README History gnuplot.el intergra.x11 0INSTALL README.3p1\
X	README.3p2 README.3p3 README.3p4 README.pro README.nex README.x11 \
X	README.3d README.mf README.win README.iso README.3p5 README.pic \
X	README.xli $(CONFIGURE)
X
X#BETA files (not standard distribution files)
XBETA = 
X# PC-specific files
XPC = corgraph.asm corplot.c header.mac hrcgraph.asm lineproc.mac \
X	linkopt.msc makefile.msc makefile.tc makefile.st makefile.djg \
X	pcgraph.asm gnuplot.def makefile.286 makefile.emx \
X	makefile.ztc linkopt.ztc term/fg.trm term/pc.trm 
XWINDOWS = makefile.win makefile.msw README.win win/wcommon.h \
X	win/wgnuplib.c win/wgnuplib.def win/wgnuplib.h win/wgnuplib.rc \
X	win/wgnuplot.def win/wgnuplot.hpj win/wgnuplot.mnu win/wgnuplot.rc \
X	win/wgraph.c win/winmain.c win/wmenu.c win/wpause.c \
X	win/wprinter.c win/wresourc.h win/wtext.c win/wtext.h \
X	win/geticon.c docs/doc2rtf.c term/win.trm
XOS2 = makefile.os2 os2/makefile os2/dialogs.c os2/dialogs.h os2/gclient.c \
X	os2/gnuicon.uue os2/gnupmdrv.c os2/gnupmdrv.def os2/gnupmdrv.h \
X	os2/gnupmdrv.itl os2/gnupmdrv.rc os2/print.c docs/doc2ipf.c \
X	README.os2 term/pm.trm
X
X# Documentation and help files
XDOCS1 = docs/makefile docs/README docs/checkdoc.c docs/doc2gih.c \
X	docs/doc2hlp.c docs/doc2hlp.com docs/doc2ms.c docs/doc2tex.c \
X	docs/gnuplot.1 docs/lasergnu.1 docs/toc_entr.sty docs/doc2info.pl \
X	docs/titlepag.ms docs/titlepag.tex docs/makefile.ami \
X	docs/doc2rtf.c
XDOCS2 = docs/gnuplot.doc docs/gpcard.tex
XDOCS3 = docs/latextut/makefile docs/latextut/eg1.plt \
X	docs/latextut/eg2.plt docs/latextut/eg3.dat docs/latextut/eg3.plt \
X	docs/latextut/eg4.plt docs/latextut/eg5.plt docs/latextut/eg6.plt \
X	docs/latextut/header.tex docs/latextut/tutorial.tex \
X	docs/latextut/linepoin.plt
X
X#########################################################################
X# Default target (informational)
Xinfo:
X	@echo "Please do a 'make <MACHINE>' where <MACHINE> is one of the following:"
X	@echo
X	@echo "apollo       for Apollo running SR10.3 with Apollo's X11"
X	@echo "dec_osf      for Dec3100/5000 running DEC OSF/1 v1.0"
X	@echo "dec          for Dec3100/5000 running Ultrix 3.1d with MIT's X11"
X	@echo "hp           for HP/9000 700 series running HP/UX 8.0 with MIT's X11R4"
X	@echo "sun          for Sun sparcstation running SunOS 4.1 with suntools (no X11) "
X	@echo "sun_x11      for Sun sparcstation running SunOS 4.1 with suntools and X11 "
X	@echo "sgi          for Silicon Graphics IRIS4D machines (no X11) "
X	@echo "sgix11       for Silicon Graphics IRIS4D machines (X11) "
X	@echo "next         for NeXT Cube and Slab running NeXTOS 2.0+ (no X11)"
X	@echo "next_x11     for NeXT Cube and Slab running NeXTOS 2.0+ with X11"
X	@echo "3b1          for ATT 3b1 machines (no X11) "
X	@echo "3b2          for ATT 3b2 machines (no X11) "
X	@echo "386ix        for 386 machines running 386/ix (no X11)"
X	@echo "386ix_x11    for 386 machines running 386/ix with T.Roell X386"
X	@echo "isc22_x11    for 386 machines running ISC 2.2 with T.Roell X386"
X	@echo "aix32        for IBM RS/6000 running AIX 3.2 with xlc 1.2"
X	@echo "aix32o       for IBM RS/6000 running AIX 3.2 with xlc 1.1"
X	@echo "x11          for a generic machine (like a sun or dec) with MIT's X11"
X	@echo "cray         for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 (no X11)"
X	@echo "cray_x11     for Cray Y-MP or Cray-2 running Unicos 6.0 or 6.1 with X11"
X	@echo "ptx_x11      for Sequent Dynix/PTX with MIT X11"
X	@echo "sequent_x11  for Sequent Symmetry (DYNIX 3) with X11"
X	@echo "convex_x11   for Convex 9.0 with MIT X11"
X	@echo "ksr          for KSR1 running DEC OSF/1 v1.0 (use make -j 16)"
X	@echo "linux        for LINUX with XFree86-1.2"
X	@echo
X	@echo "Examples:"
X	@echo
X	@echo "         make x11"
X	@echo "         make apollo"
X	@echo "         make apollo       OPTIONS='-DNOCWDRC' "
X	@echo "         make apollo       DEST='/usr/um/misc/bin' "
X	@echo "         make dec"
X	@echo "         make hp"
X	@echo "         make next"
X	@echo "         make solaris_x11"
X	@echo "         make sun          HELPDEST='/usr/um/misc/lib' "
X	@echo "         make sun          X11INCLUDES='-I/usr/local/include' "
X	@echo "         make sun_x11"
X	@echo "         make sgi"
X	@echo "         make 3b1"
X	@echo "         make 386ix"
X	@echo "         make 386ix_x11"
X	@echo "         make isc22_x11"
X	@echo "         make aix32        MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
X	@echo "         make cray"
X	@echo "         make cray_x11"
X	@echo
X	@echo "If you just type 'make All' , it will build gnuplot for Unix X11"
X	@echo "and the following variables will be used as default:"
X	@echo
X	@echo " DEST                     " $(DEST)
X	@echo " MANDEST                  " $(MANDEST)
X	@echo " HELPDEST                 " $(HELPDEST)
X	@echo " EMAIL                    " $(EMAIL)
X	@echo " CC                       " $(CC)
X	@echo " COPTS                    " $(COPTS)
X	@echo " OPTIONS                  " $(OPTIONS)
X	@echo " CFLAGS                   " $(CFLAGS)
X	@echo " LIBS                     " $(LIBS)
X	@echo " X11FLAGS                 " $(X11FLAGS)
X	@echo " X11LIBS                  " $(X11LIBS)
X	@echo " X11INCLUDES              " $(X11INCLUDES)
X	@echo " TERMFLAGS                " $(TERMFLAGS)
X	@echo " LASERGNU                 " $(LASERGNU)
X	@echo
X	@echo "If you are not familiar with makefiles or just want to know what"
X	@echo " 'make <MACHINE>' would do without actually doing anything, then type"
X	@echo " 'make <MACHINE> -n' "
X	@echo
X
X###############################################################
X# Targets for each machine
X
Xx11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(X11_FLAGS)      $(TARGET)
X
Xdec_osf:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(DEC_OSF_FLAGS)  $(TARGET)
X
Xdec:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(DEC_FLAGS)      $(TARGET)
X
Xapollo:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(APOLLO_FLAGS)   $(TARGET)
X
Xhp:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(HP_FLAGS)       $(TARGET)
X
Xnext:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(NEXT_FLAGS)     $(TARGET)
X
Xnext_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(NEXT_X11_FLAGS) $(TARGET)
X
Xsolaris_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SOLARIS_X11_FLAGS)  $(TARGET)
X
Xsun:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SUN_FLAGS)      $(TARGET)
X
Xsun_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SUN_X11_FLAGS)  $(TARGET)
X
Xsun_x11_mgr:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SUN_X11_MGR_FLAGS)  $(TARGET)
X
Xsgi:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SGI_FLAGS)      $(TARGET)
X
Xsgix11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(SGIX11_FLAGS)   $(TARGET)
X
Xcgi:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CGI_FLAGS)      $(TARGET)
X
X3b1:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(3B1_FLAGS)      $(TARGET)
X
X3b2:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(3B2_FLAGS)      $(TARGET)
X
X386ix:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(386IX_FLAGS)    $(TARGET)
X
X386ix_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(386IX_X11_FLAGS) $(TARGET)
X
Xisc22_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(ISC22_X11_FLAGS) $(TARGET)
X
Xaix32:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(AIX_FLAGS)      $(TARGET)
X
Xaix32o:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(AIXO_FLAGS)     $(TARGET)
X
Xcray:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CRAY_FLAGS)     $(TARGET)
X
Xcray_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CRAY_X11_FLAGS) $(TARGET)
X
Xptx_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(PTX_X11_FLAGS)  $(TARGET)
X
Xsequent_x11:
X	make $(MFLAGS) $(MY_FLAGS) $(SEQUENT_X11_FLAGS) $(TARGET)
X
Xconvex_x11:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(CONVEX_X11_FLAGS) $(TARGET)
X
Xksr:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(KSR_FLAGS)  $(TARGET)
X
Xlinux:
X	$(MAKE) $(MFLAGS) $(MY_FLAGS) $(LINUX_FLAGS)  $(TARGET)
X
X#############################################################
X# Targets that really do something
X
Xall:
X	@echo "Please just type  'make'  in order to get some information on "
X	@echo "how to build gnuplot under Unix and the X Window System."
X
XAll: gnuplot $(GNUPLOT_X11) doc demo/binary1
X
Xgnuplot: $(OBJS) version.o
X	$(LD) -o gnuplot $(OBJS) version.o $(LIBS)
X
Xdoc:
X	( cd docs; $(MAKE) $(MFLAGS) $(MY_FLAGS) gnuplot.gih )
X
Xgnuplot_x11: gplt_x11.c
X	$(CC) $(CFLAGS) $(X11FLAGS) $(X11INCLUDES) -o gnuplot_x11 \
X	gplt_x11.c $(X11LIBS)
X
Xdemo/binary1 demo/binary2 demo/binary3: bf_test
X	( cd demo; ../bf_test )
X
Xbf_test: bf_test.o binary.o
X	$(CC) $(CFLAGS) bf_test.o binary.o -lm -o bf_test
X################################################################
X# Installation instructions
X
Xinstall:
X	@echo
X	@echo "Please do a 'make <MACHINE> TARGET=Install' where <MACHINE> is one of the following:"
X	@echo
X	@echo "apollo, dec, hp, sun, sun_x11, sgi, sgix11, cgi,"
X	@echo "next, next_x11, 3b1, 386ix, 386ix_x11, aix32, aix32o,"
X	@echo "x11, cray, cray_x11, ptx_x11, sequent_x11, convex_x11"
X	@echo
X	@echo "Examples:"
X	@echo
X	@echo "         make x11          TARGET=Install "
X	@echo "         make apollo       TARGET=Install "
X	@echo "         make dec          TARGET=Install "
X	@echo "         make hp           TARGET=Install "
X	@echo "         make sun          TARGET=Install HELPDEST='/usr/um/misc/lib' "
X	@echo "         make aix32        TARGET=Install MANDEST='/usr/um/misc/man/man1' COPTS='-O' "
X	@echo
X################################################################
X# Installation targets
X
XInstall: All man_install $(X11INSTALL) $(LASERGNU)
X	cp gnuplot $(DEST)
X	strip $(DEST)/gnuplot
X	( cd docs; $(MAKE) $(MFLAGS) $(MY_FLAGS) install-unix HELPDEST=$(HELPDEST) )
X
Xx11_install: gnuplot_x11
X	cp gnuplot_x11 $(DEST)
X	strip $(DEST)/gnuplot_x11
X
Xx11_noinstall:
X	@echo "X11 not requested, so gnuplot_x11 program not installed"
X
Xman_install: docs/gnuplot.1
X	cp docs/gnuplot.1 $(MANDEST)
X
Xlasergnu_install: lasergnu docs/lasergnu.1
X	cp lasergnu $(DEST)
X	chmod 755 $(DEST)/lasergnu
X	cp docs/lasergnu.1 $(MANDEST)
X
Xlasergnu_noinstall:
X	@echo
X	@echo "Lasergnu will not be installed by default."
X	@echo "If you think you need the lasergnu script to print"
X	@echo " files on the imagen or PostScript printers, then"
X	@echo " type"
X	@echo "      'make <MACHINE> TARGET=Install LASERGNU='lasergnu_install' "
X	@echo
X	@echo "Lasergnu is really not needed since within gnuplot you can"
X	@echo " can create files (in impress or PostScript language) and"
X	@echo " print them through your favorite print command (lpr, lp, prf, ipr)."
X	@echo
X
X################################################################
X# Dependencies
X
Xplot.o: plot.c
X	$(CC) $(CFLAGS) $(PLOTXFLAG) -c plot.c
X
Xterm.o: term.h term.c $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	$(CC) $(CFLAGS) $(TERMFLAGS) -c term.c
X
Xversion.o:
X	$(CC) $(CFLAGS) -DCONTACT=\"$(EMAIL)\" -c version.c
X
Xepsviewe.o : epsviewe.h epsviewe.m
X	$(CC) -ObjC -c epsviewe.m
X
X$(OBJS): plot.h
X
Xcommand.o: command.c
X	$(CC) $(CFLAGS) -c command.c -DHELPFILE=\"$(HELPDEST)/gnuplot.gih\" $(COMFLAGS)
X
Xcommand.o help.o misc.o: help.h
X
Xcommand.o graphics.o graph3d.o misc.o plot.o setshow.o term.o: setshow.h
X
Xbitmap.o term.o: bitmap.h
X
Xsetshow.o: setshow.c
X	$(CC) $(CFLAGS) -c setshow.c $(SSFLAGS)
X
X################################################################
X# Miscellaneous targets
X
XSOURCES=plot.h help.h setshow.h bitmap.h term.h $(CSOURCE1) $(CSOURCE2) \
X	$(CSOURCE3) $(CSOURCE4) $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)\
X	$(CSOURCE8) $(NEXTSRC) $(WINDOWS) $(OS2)
X
XDOCS  = $(DOCS1) $(DOCS2) $(DOCS3)
X
Xlint:
X	lint -hx $(SOURCES)
X
Xclean:
X	rm -f *.o *.orig *.rej *~ *.bak term/*~ term/*.orig term/*.bak
X	( cd docs; $(MAKE) $(MFLAGS) clean )
X	( cd docs/latextut; $(MAKE) $(MFLAGS) clean )
X
Xspotless:
X	rm -f *.o *~ *.orig *.rej *.bak term/*~ term/*.orig term/*.bak \
X	TAGS gnuplot gnuplot_x11 \
X	bf_test demo/binary[1-3]
X	( cd docs; $(MAKE) $(MFLAGS) clean )
X	( cd docs/latextut; $(MAKE) $(MFLAGS) spotless )
X
X################################################################
X# Making shar files for mailing gnuplot
X
Xshar: gnuplot.sh00 gnuplot.sh01 gnuplot.sh02 gnuplot.sh03 gnuplot.sh04 \
X	gnuplot.sh05 gnuplot.sh06 gnuplot.sh07 gnuplot.sh08 \
X	gnuplot.sh09 gnuplot.sh10 gnuplot.sh11 gnuplot.sh12 \
X	gnuplot.sh13 gnuplot.sh14 gnuplot.sh15 gnuplot.sh16
X
Xgnuplot.sh00:
X	echo '#!/bin/sh' > gnuplot.sh00
X	echo '# This is a shell file to make directories' >> gnuplot.sh00
X	echo mkdir $(DIRS) >> gnuplot.sh00
X
Xgnuplot.sh01: $(ETC) 
X	shar $(ETC) > gnuplot.sh01
X
Xgnuplot.sh02: $(DOCS1)
X	shar $(DOCS1) > gnuplot.sh02
X
Xgnuplot.sh03: $(DOCS2)
X	shar $(DOCS2) > gnuplot.sh03
X
Xgnuplot.sh04: $(DOCS3)
X	shar $(DOCS3) > gnuplot.sh04
X
Xgnuplot.sh05: $(CSOURCE1)
X	shar $(CSOURCE1) > gnuplot.sh05
X
Xgnuplot.sh06: $(CSOURCE2)
X	shar $(CSOURCE2) > gnuplot.sh06
X
Xgnuplot.sh07: $(CSOURCE3)
X	shar $(CSOURCE3) > gnuplot.sh07
X
Xgnuplot.sh08: $(CSOURCE4)
X	shar $(CSOURCE4) > gnuplot.sh08
X
Xgnuplot.sh09: $(CSOURCE5)
X	shar $(CSOURCE5) > gnuplot.sh09
X
Xgnuplot.sh10: $(CSOURCE6)
X	shar $(CSOURCE6) > gnuplot.sh10
X
Xgnuplot.sh11: $(CSOURCE7)
X	shar $(CSOURCE7) > gnuplot.sh11
X
Xgnuplot.sh12: $(PC)
X	shar $(PC) > gnuplot.sh12
X
Xgnuplot.sh13: $(CSOURCE8)
X	shar $(CSOURCE8) > gnuplot.sh13
X
Xgnuplot.sh14: $(DEMOS)
X	shar $(DEMOS) > gnuplot.sh14
X
Xgnuplot.sh15: $(WINDOWS)
X	shar $(WINDOWS) > gnuplot.sh15
X
Xgnuplot.sh16: $(BETA)
X	shar $(BETA) > gnuplot.sh16
X
Xtar: $(ETC) $(SOURCES) $(PC) $(DEMOS) $(BETA) $(DOCS) 
X	$(TAR) cvf /tmp/gnuplot.tar $(ETC) $(SOURCES) $(PC)\
X	     $(DEMOS) $(BETA) $(DOCS) 
X#
X# the following uses Rick Saltz's makekit shar generation tools
X#
X
Xkit: $(ETC) $(SOURCES) $(PC) $(DEMOS) $(BETA) $(DOCS) 
X	makekit -s135k -k30 $(ETC) $(SOURCES) $(PC)\
X	     $(DEMOS) $(BETA) $(DOCS) 
X
Xbranch: rcs rcsdoc rcsdemo
X
Xrcs:
X	rcs -b$(RCSVER) $(ETC) $(SOURCES) $(PC) 
X
Xrcsdoc:
X	rcs -b$(RCSVER) $(DOCS)
X
Xrcsdemo:
X	rcs -b$(RCSVER) $(DEMOS)
X
Xciall: ci cidoc cidemo
X
Xci:
X	ci -l$(RCSVER) -m$(RCSCOM) -t-$(RCSCOM) $(SOURCES) $(PC) $(ETC) 
X
Xcidoc:
X	ci -l$(RCSVER) -m$(RCSCOM) -t-$(RCSCOM) $(DOCS)
X
Xcidemo:
X	ci -l$(RCSVER) -m$(RCSCOM) -t-$(RCSCOM) $(DEMOS)
X
Xciforce:
X	ci -f$(RCSVER) -m$(RCSCOM) -t-$(RCSCOM) $(SOURCES) $(ETC) $(DOCS) $(DEMOS) $(PC)
X
Xcoall: co codoc codemo
X
Xco:
X	co -l -r$(RCSVER) $(ETC) $(SOURCES) $(PC)
X
Xcodoc:
X	co -l -r$(RCSVER) $(DOCS)
X
Xcodemo:
X	co -l -r$(RCSVER) $(DEMOS)
END_OF_FILE
  if test 33720 -ne `wc -c <'gnuplot/makefile.unx'`; then
    echo shar: \"'gnuplot/makefile.unx'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.unx'
fi
echo shar: End of archive 13 \(of 33\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
