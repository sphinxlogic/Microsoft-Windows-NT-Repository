Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i031:  gnuplot - interactive function plotting utility, Part19/33
Message-ID: <1993Oct22.163708.24314@sparky.sterling.com>
X-Md4-Signature: c1f1089cc31d11f2f5b07d734214409a
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:37:08 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 31
Archive-name: gnuplot/part19
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/configure gnuplot/makefile.emx
#   gnuplot/term/apollo.trm gnuplot/term/mif.trm gnuplot/win/wmenu.c
# Wrapped by kent@sparky on Wed Oct 20 17:14:53 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 19 (of 33)."'
if test -f 'gnuplot/configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/configure'\"
else
  echo shar: Extracting \"'gnuplot/configure'\" \(16895 characters\)
  sed "s/^X//" >'gnuplot/configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
X# --with-PACKAGE unless this script has special code to handle it.
X
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
X       verbose=yes ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -fr conftest* core; exit 1' 1 3 15
X
X# NLS nuisances.
X# These must not be set unconditionally because not all systems understand
X# e.g. LANG=C (notably SCO).
Xif test "${LC_ALL+set}" = 'set' ; then LC_ALL=C; export LC_ALL; fi
Xif test "${LANG+set}"   = 'set' ; then LANG=C;   export LANG;   fi
X
Xrm -f conftest*
Xcompile='${CC-cc} $CFLAGS $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=graphics.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X# Save the original args to write them into config.status later.
Xconfigure_args="$*"
X
X
Xif test -z "$CC"; then
X  # Extract the first word of `gcc', so it can be a program name with args.
X  set dummy gcc; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
Xtest -n "$CC" -a -n "$verbose" && echo "	setting CC to $CC"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args, or
X# /usr/ucb/install on SVR4, which tries to use the nonexistent group
X# `staff'.  On most BSDish systems install is in /usr/bin, not /usr/ucb
X# anyway.  Sigh.
Xif test "z${INSTALL}" = "z" ; then
X  echo checking for install
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin|/usr/ucb) ;;
X    *)
X      if test -f $dir/installbsd; then
X	INSTALL="$dir/installbsd -c" # OSF1
X	INSTALL_PROGRAM='$(INSTALL)'
X	INSTALL_DATA='$(INSTALL) -m 644'
X	break
X      fi
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
X
X
X# check whether --with-no-readline was given
Xif test -n "$with_no_readline"; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining READLINE"
XDEFS="$DEFS -DREADLINE=1"
X}
X
Xfi
X
X# check whether --with-cwdrc was given
Xif test -n "$with_cwdrc"; then
X  :
Xelse
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NOCWDRC"
XDEFS="$DEFS -DNOCWDRC=1"
X}
X
Xfi
X
X
X# check whether --with-lasergnu was given
Xif test -n "$with_lasergnu"; then
X  LASERGNU=lasergnu_install
Xelse
X  LASERGNU=lasergnu_noinstall
Xfi
X
X
X
X
X
X# If we find X, set shell vars x_includes and x_libraries to the paths.
Xecho checking for X include and library files with xmkmf
Xrm -fr conftestdir
Xif mkdir conftestdir; then
X  cd conftestdir
X  cat > Imakefile <<\EOF
Xacfindx:
X	@echo "x_includes=$(INCROOT); x_libraries=$(USRLIBDIR)"
XEOF
X  if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
X    eval `make acfindx`
X  fi
X  cd ..
X  rm -fr conftestdir
Xfi
X
Xif test -z "$x_includes" || test -z "$x_libraries"; then
X  X_INCLUDES= X_LIBRARIES= PROGS=
Xelse
X  X_INCLUDES="-I$x_includes" X_LIBRARIES="-L$x_libraries -lX11"
X  PROGS=gnuplot_x11
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining X11"
XDEFS="$DEFS -DX11=1"
X}
X
Xfi
X
Xecho checking for NeXT
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  # This must be in double quotes, not single quotes, because CPP may get
X  # substituted into the Makefile and ``${CC-cc}'' will simply confuse
X  # make.  It must be expanded now.
X  CPP="${CC-cc} -E"
X  cat > conftest.c <<EOF
X#include <stdio.h>
XSyntax Error
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
Xtest ".${verbose}" != "." && echo "	setting CPP to $CPP"
X
Xcat > conftest.c <<EOF
X#ifdef __NeXT__
X  yes
X#endif
X
XEOF
Xeval "$CPP \$DEFS conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NEXT"
XDEFS="$DEFS -DNEXT=1"
X}
X 
X{
Xtest -n "$verbose" && \
Xecho "	defining NeXT"
XDEFS="$DEFS -DNeXT=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for OSF/1
Xecho checking for sys/bkmac.h
Xcat > conftest.c <<EOF
X#include <sys/bkmac.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining OSF1"
XDEFS="$DEFS -DOSF1=1"
X}
X 
X{
Xtest -n "$verbose" && \
Xecho "	defining _OSF_SOURCE"
XDEFS="$DEFS -D_OSF_SOURCE=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for Solaris
Xecho checking for libgenIO.h
Xcat > conftest.c <<EOF
X#include <libgenIO.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SOLARIS"
XDEFS="$DEFS -DSOLARIS=1"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for sys/bsdtypes.h
Xcat > conftest.c <<EOF
X#include <sys/bsdtypes.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining BSD_TYPES"
XDEFS="$DEFS -DBSD_TYPES=1"
X}
X
Xfi
Xrm -f conftest*
X
Xhave_hdr=
Xecho checking for termios.h
Xcat > conftest.c <<EOF
X#include <termios.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining TERMIOS"
XDEFS="$DEFS -DTERMIOS=1"
X}
X have_hdr=1
Xfi
Xrm -f conftest*
X
Xif test -z "$have_hdr"; then
X  echo checking for sgtty.h
Xcat > conftest.c <<EOF
X#include <sgtty.h>
XEOF
Xerr=`eval "($CPP \$DEFS conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining SGTTY"
XDEFS="$DEFS -DSGTTY=1"
X}
X
Xfi
Xrm -f conftest*
X
Xfi
X
Xecho checking for lgamma
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_lgamma) || defined (__stub___lgamma)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char lgamma(); lgamma();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining GAMMA to be lgamma"
XDEFS="$DEFS -DGAMMA=lgamma"
X}
X
Xelse
X  {
Xtest -n "$verbose" && \
Xecho "	defining GAMMA to be gamma"
XDEFS="$DEFS -DGAMMA=gamma"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for getcwd
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_getcwd) || defined (__stub___getcwd)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char getcwd(); getcwd();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining GETCWD"
XDEFS="$DEFS -DGETCWD=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for memcpy
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_memcpy) || defined (__stub___memcpy)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char memcpy(); memcpy();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining MEMCPY"
XDEFS="$DEFS -DMEMCPY=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for memset
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_memset) || defined (__stub___memset)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char memset(); memset();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining MEMSET"
XDEFS="$DEFS -DMEMSET=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for setlocale
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_setlocale) || defined (__stub___setlocale)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char setlocale(); setlocale();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining XPG3_LOCALE"
XDEFS="$DEFS -DXPG3_LOCALE=1"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for setlinebuf
Xcat > conftest.c <<EOF
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_setlinebuf) || defined (__stub___setlinebuf)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char setlinebuf(); setlinebuf();
X#endif
X }
XEOF
Xif eval $compile; then
X  {
Xtest -n "$verbose" && \
Xecho "	defining UNIX"
XDEFS="$DEFS -DUNIX=1"
X}
X
Xfi
Xrm -f conftest*
X
X
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lsocket"
Xhave_lib=""
Xecho checking for -lsocket
Xcat > conftest.c <<EOF
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  have_lib="1"
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lsocket"
Xelse
X   :; 
Xfi
X
X
X
X
X{
Xtest -n "$verbose" && \
Xecho "	defining NOVFORK"
XDEFS="$DEFS -DNOVFORK=1"
X}
X
X
X{
Xtest -n "$verbose" && \
Xecho "	defining unix"
XDEFS="$DEFS -Dunix=1"
X}
X
X
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%exec_prefix\\1=\\2$exec_prefix%"
Xfi
Xcat >conftest.def <<EOF
X$DEFS
XEOF
Xescape_ampersand_and_backslash='s%[&\\]%\\&%g'
XDEFS=`sed "$escape_ampersand_and_backslash" <conftest.def`
Xrm -f conftest.def
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
X#
X# $0 $configure_args
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $configure_args ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -f Makefile docs/Makefile docs/latextut/Makefile; exit 1' 1 3 15
XCC='$CC'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLASERGNU='$LASERGNU'
XX_INCLUDES='$X_INCLUDES'
XX_LIBRARIES='$X_LIBRARIES'
XPROGS='$PROGS'
XCPP='$CPP'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
XDEFS='$DEFS'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
X
X# Allow make-time overrides of the generated file list.
Xtest -n "$gen_files" || gen_files="Makefile docs/Makefile docs/latextut/Makefile"
X
Xfor file in .. $gen_files; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
Xs%@CC@%$CC%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LASERGNU@%$LASERGNU%g
Xs%@X_INCLUDES@%$X_INCLUDES%g
Xs%@X_LIBRARIES@%$X_LIBRARIES%g
Xs%@PROGS@%$PROGS%g
Xs%@CPP@%$CPP%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%$DEFS%
X" $top_srcdir/${file}.in >> $file
Xfi; done
X
Xexit 0
XEOF
Xchmod +x config.status
Xtest -n "$no_create" || ./config.status
X
END_OF_FILE
  if test 16895 -ne `wc -c <'gnuplot/configure'`; then
    echo shar: \"'gnuplot/configure'\" unpacked with wrong size!
  fi
  chmod +x 'gnuplot/configure'
  # end of 'gnuplot/configure'
fi
if test -f 'gnuplot/makefile.emx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.emx'\"
else
  echo shar: Extracting \"'gnuplot/makefile.emx'\" \(3535 characters\)
  sed "s/^X//" >'gnuplot/makefile.emx' <<'END_OF_FILE'
X#
X# Make file for use with emx-0.8f/gcc and ndmake 4.5
X# for compiling for MS-DOS
X# 
X# This version has had very little testing.
X
XEMXPATH = c:/emx
X
X# uncomment the following two lines if you have 
X# Johannes Martin's SVGA/VESA extensions
X# A VESA 1.2 compatible display, and the vesa_emx.com TSR are required.
X# "set term vgal" needs vesa_ibm.com with svgakit/vesa_emx version 1.2.
X# VESA = -DEMXVESA
X# VESALIB = -lvesa
X
X# where to place gnuplot.gih helpfile
XHELPFILE = gnuplot.gih
X
XCFLAGS = -c -O2 -DMSDOS -DREADLINE
X
X# see other terminal defines in term.h
XTERMFLAGS = -DEMXVGA $(VESA)
X
XOBJS = 	bitmap.o command.o contour.o eval.o graphics.o graph3d.o \
X	help.o internal.o misc.o parse.o plot.o readline.o specfun.o \
X	scanner.o setshow.o standard.o term.o util.o version.o \
X        binary.o gnubin.o
X
XCSOURCE5 = term\aed.trm term\cgi.trm term/dumb.trm term/dxf.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm 
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term/pbm.trm term\pm.trm 
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm term\emxvga.trm
XCSOURCE8 = contour.c
X
Xall: gnuplotx.exe $(HELPFILE)
X
X# default rules
XCCC = gcc $(CFLAGS) -o $*.o $*.c
X
Xgnuplotx.exe: $(OBJS) emxlink.rsp
X        gcc -o gnuplot @emxlink.rsp -lm -lgraph $(VESALIB)
X	emxbind $(EMXPATH)/bin/emx.exe gnuplot gnuplotx.exe -p -acmi
X
Xemxlink.rsp: makefile.emx
X	echo bitmap.o> emxlink.rsp
X	echo command.o>> emxlink.rsp
X	echo contour.o>> emxlink.rsp
X	echo eval.o>> emxlink.rsp
X	echo graphics.o>> emxlink.rsp
X	echo graph3d.o>> emxlink.rsp
X	echo help.o>> emxlink.rsp
X	echo internal.o>> emxlink.rsp
X	echo misc.o>> emxlink.rsp
X	echo parse.o>> emxlink.rsp
X	echo plot.o>> emxlink.rsp
X	echo readline.o>> emxlink.rsp
X	echo specfun.o>> emxlink.rsp
X	echo scanner.o>> emxlink.rsp
X	echo setshow.o>> emxlink.rsp
X	echo standard.o>> emxlink.rsp
X	echo term.o>> emxlink.rsp
X	echo util.o>> emxlink.rsp
X	echo version.o>> emxlink.rsp
X	echo binary.o>> emxlink.rsp
X	echo gnubin.o>> emxlink.rsp
X
Xbitmap.o: bitmap.c bitmap.h plot.h
X	$(CCC)
X
Xbinary.o: binary.c plot.h
X	$(CCC)
X
Xgnubin.o: gnubin.c plot.h
X	$(CCC)
X
Xcommand.o: command.c plot.h setshow.h help.h
X	$(CCC) -DHELPFILE=\"$(HELPFILE)\"
X
Xcontour.o: contour.c plot.h
X	$(CCC)
X
Xeval.o: eval.c plot.h
X	$(CCC)
X
Xgraphics.o: graphics.c plot.h setshow.h
X	$(CCC)
X
Xgraph3d.o: graph3d.c plot.h setshow.h
X	$(CCC)
X
Xhelp.o: help.c plot.h help.h
X	$(CCC)
X
Xinternal.o: internal.c plot.h
X	$(CCC)
X
Xmisc.o: misc.c plot.h setshow.h
X	$(CCC)
X
Xparse.o: parse.c plot.h
X	$(CCC)
X
Xplot.o: plot.c plot.h setshow.h
X	$(CCC)
X
Xreadline.o: readline.c
X	$(CCC)
X
Xscanner.o: scanner.c plot.h
X	$(CCC)
X
Xsetshow.o: setshow.c plot.h setshow.h
X	$(CCC)
X
Xspecfun.o: specfun.c plot.h
X	$(CCC)
X
Xstandard.o: standard.c plot.h
X	$(CCC)
X
Xterm.o: term.c term.h plot.h setshow.h bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	$(CCC) $(TERMFLAGS) -Iterm
X
Xutil.o: util.c plot.h
X	$(CCC)
X
Xversion.o: version.c
X	$(CCC)
X
X# convert gnuplot.doc to gnuplot.gih
Xdoc2gih.exe: docs\doc2gih.c
X	gcc -o doc2gih  docs/doc2gih.c
X	emxbind $(EMXPATH)/bin/emx.exe doc2gih doc2gih.exe
X
X$(HELPFILE): doc2gih.exe docs\gnuplot.doc
X	doc2gih docs\gnuplot.doc $(HELPFILE)
X
Xclean:
X	del *.o
X	del emxlink.rsp
X	del gnuplot
X	del doc2gih
X
X# veryclean target - remove all files created by the makefile
X
Xveryclean: clean
X	del gnuplot.exe
X	del doc2gih.exe
X	del gnuplot.gih
X
X
END_OF_FILE
  if test 3535 -ne `wc -c <'gnuplot/makefile.emx'`; then
    echo shar: \"'gnuplot/makefile.emx'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.emx'
fi
if test -f 'gnuplot/term/apollo.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/apollo.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/apollo.trm'\" \(17140 characters\)
  sed "s/^X//" >'gnuplot/term/apollo.trm' <<'END_OF_FILE'
X/*
X * $Id: apollo.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - apollo.trm */
X/*
X    Apollo terminal driver for GNUplot.
X
X    Open a pad for the graphics, and use GPR routines.  For additional
X    speed, we do the graphics to a separate bitmap, and the blt the
X    entire bitmap to the display.  When the user specifies an output
X    file name, however, we draw directly to the screen, so the graphics
X    are written to the file correctly.  Thus, the user can save the
X    graphics in a file, to be viewed later.  If we try the bitmap
X    trick, it looks funny.
X
X    Ray Lischner (uunet!mntgfx!lisch)
X    4 October 1989	file created for GNUplot 1.1
X    26 March 1990	updated for GNUplot 2.0
X    30 October 1991	fixed minor problem in apollo_tic_sizes
X*/
X
X#include <apollo/base.h>
X#include <apollo/error.h>
X#include <apollo/pad.h>
X#include <apollo/gpr.h>
X
X/* default tick sizes for small windows */
X#define APOLLO_VTIC	 6
X#define APOLLO_HTIC	 6	
X
X/* issue an error message, using additional text "s" */
X#define apollo_error(s)	error_$print_name(status, (s), strlen(s))
X
X/* if "status" indicates an error, then issue an error message */
X#define apollo_check(s)	if (status.all != status_$ok) apollo_error(s)
X
Xstatic ios_$id_t stream = -1;           /* the stream for the pad */
Xstatic gpr_$bitmap_desc_t screen_desc;  /* the screen's bitmap */
Xstatic gpr_$bitmap_desc_t bitmap_desc;  /* the graphics bitmap */
Xstatic gpr_$attribute_desc_t attr;      /* attribute block for saved bitmap */
Xstatic short draw_width;                /* default GPR draw width */
Xstatic name_$long_pname_t font_name;    /* font path name */
Xstatic int APOLLO_XMAX, APOLLO_YMAX;    /* window size */
Xstatic boolean use_bitmap;              /* use a separate bitmap? */
X
X/* return whether stdout is a DM pad */
Xapollo_isa_pad()
X{
X    status_$t status;
X    pad_$isa(1, &status);
X    return (status.all == status_$ok);
X}
X
X/*
X    Find out what the default font is for the pad, and save the
X    character height and width information.
X
X    Note that we must save the font file name because we need
X    to reload the font file everytime the window changes size.
X*/
Xstatic void apollo_font_info(struct termentry* tbl, char* fname)
X{
X    short fwidth, fheight, flen;
X    status_$t status;
X
X    /* get the font size & update the termentry table */
X    pad_$inq_font(stream, &fwidth, &fheight, fname, name_$long_pnamlen_max,
X		  &flen, &status);
X    apollo_check("inq_font");
X    fname[flen] = '\0';
X
X    tbl->v_char = fheight;
X    tbl->h_char = fwidth;
X}
X
X/*
X    Initialize all the GPR stuff.  To save time, we draw into a separate
X    bitmap, and then blt it onto the screen all at once.  This results
X    in 5-10 times speed-up in the graphics, with only a little
X    complication.  Most of the complication is right here, making sure
X    we allocate the right bitmaps, etc., in the right order.  The rest
X    is in APOLLO_text(), where we actually BLT the bitmap onto the screen.
X    Everything else is the same.
X
X    The bitmaps have the same size as the window.  If the window changes
X    size, then the bitmaps retain the same size, so the user sees part
X    of the plot or a lot of space around the plot.  Drawing a new plot,
X    or replotting the previous one causes APOLLO_graphics() to see if
X    the window has changed size, in which case the GPR is terminated,
X    and this routine is called again.  Thus, make sure any changes
X    preserve this ability.  Anything that should only be done once
X    to the pad should be handled by APOLLO_init().
X
X    By the way, we save the current draw width, to be used later
X    for drawing extra wide lines.  This way we don't need to know
X    anything about the current output device characteristics;
X    we can just draw the default width, or twice the default width, etc.
X*/
Xstatic void apollo_gpr_init(struct termentry* tbl, pad_$window_desc_t* window)
X{
X    gpr_$offset_t size;
X    short fontid;
X    status_$t status;
X
X    size.x_size = APOLLO_XMAX = tbl->xmax = window->width;
X    size.y_size = APOLLO_YMAX = tbl->ymax = window->height;
X
X    /* now initialize GPR */
X    gpr_$init(gpr_$frame, stream, size, 1, &screen_desc, &status);
X    apollo_check("gpr_$init");
X
X    if (use_bitmap)
X    {
X	/* allocate the bitmap and its attribute block */
X	gpr_$allocate_attribute_block(&attr, &status);
X	apollo_check("allocate_attribute_block");
X
X	gpr_$allocate_bitmap(size, 1, attr, &bitmap_desc, &status);
X	apollo_check("allocate_bitmap");
X
X	gpr_$set_bitmap(bitmap_desc, &status);
X	apollo_check("set_bitmap");
X    }
X
X    /* set the font file */
X    gpr_$load_font_file(font_name, strlen(font_name), &fontid, &status);
X    apollo_check(font_name);
X
X    gpr_$set_text_font(fontid, &status);
X    apollo_check("set_text_font");
X
X    gpr_$inq_draw_width(&draw_width, &status);
X    apollo_check("inq_draw_width");
X}
X
X/*
X    Determine the tick sizes to be used for labelling borders.
X    By default, we use 1/50 of the window size, which looks nice to me.
X    If this makes the ticks too small, however, we use a minimum
X    size, to make sure they are visible.  The minimum size was also
X    determined experimentally.
X
X    Feel free to changes the sizes to something you feel looks better.
X
X    This routine must be called after apollo_gpr_init(), because we
X    need to know the window size, as stored in the termentry table.
X*/
Xstatic void apollo_tic_sizes(struct termentry* tbl)
X{
X    /* base the tick size on the window size */
X    tbl->v_tic = tbl->ymax / 50;
X    if (tbl->v_tic < APOLLO_VTIC)
X	tbl->v_tic = APOLLO_VTIC;
X    tbl->h_tic = tbl->xmax / 50;
X    if (tbl->h_tic < APOLLO_HTIC)
X	tbl->h_tic = APOLLO_HTIC;
X}
X
X/*
X    Terminate the GPR.  This is called whenever the window size
X    changes, and we need to reinitialize the GPR.  I assume that
X    calling gpr_$terminate() also deallocates the bitmaps and
X    attribute blocks because deallocating the screen's bitmap
X    causes terminate() to think GPR has already been terminated.
X
X    Since this can be called many times, make sure nothing
X    drastic is done here, like closing the stream to the pad.
X    The only actions should be those that will be reinitialized
X    by apollo_gpr_init().
X*/
Xstatic void apollo_gpr_terminate()
X{
X    status_$t status;
X
X    gpr_$terminate(false, &status);
X    apollo_check("terminate");
X}
X
X/*
X    Initialize the graphics.  This is called once, so we do things
X    here that should be done exactly once, such as opening the window.
X    I like to give windows names, so it is obvious what the window's
X    contents are, but this causes a transcript to be kept in a file
X    whose name is the window's name.  This might be nice in some
X    circumstances, but to me it is a nuisance, so the file is
X    deleted immediately.  The name is unlikely to appear normally,
X    so there should be little interference with users' normal files.
X    If the user has explicitly set the output file, however, then
X    we use that name, and do not delete the file.  Thus, the
X    user can get a metafile of the plot.  We can tell if the
X    output file has been set because outstr is "STDOUT".  Otherwise,
X    outstr is the filename, in single quotes.  We need to strip
X    the quotes to make the file name.
X
X    The DM defaults are used for window sizes and positions.  If
X    the user doesn't like it, he or she can change is and issue
X    a replot command (assuming a plot has already been generated).
X
X    Note, also, that we must call pad_$set_scale() or else
X    pad_$inq_windows() returns scaled values, which is not what
X    we want.  Setting the scale to one (1) turns off the scaling,
X    so we get real pixel sizes.
X
X    Finally, we get the name and size of the default font.  The
X    name is kept, as explained earlier.  Then we can initialize
X    the GPR stuff.
X
X    Note that there is a way that APOLLO_init() gets called more
X    than once.  If the user issues the "set terminal apollo" command
X    more than once, then this is called, so we need to make sure
X    that we do not keep creating windows.
X
X    An alternative strategy would be to interpret multiple "set term
X    apollo"s to mean create multiple windows.  The user could only
X    access the most recent window because GNUplot has no concept of
X    multiple terminals.  The user would, in fact, have no way of
X    removing old windows because they are still active.  We could try
X    catching keyboard events to see if the user presses EXIT, but I do
X    not want to start getting into that mess.  If the user really
X    wants this kind of functionality, then he or she can run gnuplot
X    multiple times.  I think that is a lot cleaner, don't you?
X*/
XAPOLLO_init()
X{
X    /* only initialize once */
X    if (stream == -1)
X    {
X	extern char outstr[];
X	struct termentry* tbl;
X	pad_$window_desc_t window;
X	name_$long_name_t wname;
X	short wnum;			/* junk needed by pad_$inq_windows() */
X	boolean unlink_wname;
X	status_$t status;
X
X	tbl = &term_tbl[term];
X
X	/* make the window name unique, with "gnuplot" in the label */
X	if (strcmp(outstr, "STDOUT") == 0)
X	{
X	    sprintf(wname, "gnuplot-%d", getpid());
X	    unlink_wname = true;
X	}
X	else
X	{
X	    /* strip the single quotes around the file name */
X	    strcpy(wname, outstr + 1);
X	    wname[strlen(wname) - 1] = '\0';
X	    unlink_wname = false;
X	}
X
X	use_bitmap = unlink_wname;
X
X	/* use the default window position and size */
X	window.top = window.left = window.width = window.height = 0;
X	pad_$create_window(wname, strlen(wname), pad_$transcript, 1, window,
X			   &stream, &status);
X	apollo_check("create_window");
X
X	/* if this is not the user's name, then delete the file */
X	if (unlink_wname)
X	    unlink(wname);
X
X	/* remove all scaling, to revert to pixel units, not char. units */
X	pad_$set_scale(stream, 1, 1, &status);
X	apollo_check("set_scale");
X
X	/* get rid of the window when the program exits */
X	pad_$set_auto_close(stream, 1, true, &status);
X	apollo_check("set_auto_close");
X
X	/* now determine the window size & update the termentry table */
X	pad_$inq_windows(stream, &window, 1, &wnum, &status);
X	apollo_check("inq_windows");
X
X	/* the order of the next three calls is important */
X	apollo_font_info(tbl, font_name);
X	apollo_gpr_init(tbl, &window);
X	apollo_tic_sizes(tbl);
X    }
X}
X
X/*
X    Prepare for graphics output.  Since this is what the user wants to
X    do when preparing a new plot, this is a meaningful time to see if
X    the window has changed size.  Thus, we avoid mucking about with
X    asynchronous traps, and we avoid the bigger problem of dealing
X    with a half-finished plot when the window changes size.
X
X    Simply put, get the current window size, and if it has changed,
X    then get rid of the old bitmaps, etc., and allocate new ones at
X    the new size.  We also need to update the termentry table.
X    If the window stays the same size, then just clear it.
X*/
Xstatic void apollo_redo_window(pad_$window_desc_t* window)
X{
X    struct termentry* tbl = &term_tbl[term];
X    status_$t status;
X
X    /* the order of the following calls is important */
X    apollo_gpr_terminate();
X    apollo_gpr_init(tbl, window);
X    apollo_tic_sizes(tbl);
X}
X
XAPOLLO_graphics()
X{
X    pad_$window_desc_t window;
X    short wnum;
X    status_$t status;
X
X    pad_$inq_windows(stream, &window, 1, &wnum, &status);
X    apollo_check("inq_windows");
X
X    if (window.width != APOLLO_XMAX || window.height != APOLLO_YMAX)
X	apollo_redo_window(&window);
X    else
X    {
X	gpr_$clear(0, &status);
X	apollo_check("clear");
X    }
X}
X
X/* set a line type:
X   -2 heavy, solid	(border)
X   -1 heavy, dotted	(axis)
X   0  solid		(normal)
X   1  dots		(other curves)
X   2  short dash
X   3  long dash
X   4  dash dot
X
X   Apparently, GPUplot draws a lot of short line segments, and each
X   one starts a new pattern.  This makes the patterns somewhat useless,
X   but one can still tell the difference between solid, dotted, and
X   dashed lines.  The utility of fancier styles is limited, however.
X
X   On a color workstation, we should use different colors, but I
X   don't have one.
X*/
X
X/*
X    To draw different line styles on an Apollo, we use two different
X    parameters.  One is a line thickness, which is just an integral
X    multiple of the default line thickness.  The second is a 16-bit
X    pattern that is repeated.  We could use fancier patterns, since
X    GPR supports up to 64-bits, but, as I explained earlier, this
X    really does not buy us anything.
X
X    I used patterns that do not start with all bits on because
X    GNUplot seems to use lots of short line segments to draw
X    a curve, and this might make a very curvey plot seem like
X    a solid line, regardless of pattern.  I don't want to start
X    with too many zeros, however, or else the curve might not
X    appear at all!  All the patterns, therefore, start with one
X    bit on.  The rest of the bits determine the true pattern.
X
X    By examining graphics.c, we see that linetype -2 is used exclusively
X    for the border, -1 for the axes, and the non-negative integers for
X    the curves.  We use heavy lines for the border and axes, and normal
X    width lines for the curves.
X
X    Since C arrays start at zero, make sure all the offsets are correct,
X    so that it is easy to access the array with -2...n linetypes.
X*/
X
Xtypedef struct {
X    short width;
X    short pattern;
X} APOLLO_LINE;
X
Xstatic APOLLO_LINE apollo_lines[] = {
X    { 2, ~0 },		/* heavy, solid */
X    { 2, 0x6666 },	/* heavy, dotted */
X    { 1, ~0 },		/* normal */
X    { 1, 0xAAAA },	/* dotted */
X    { 1, 0xC3C3 },	/* short dash */
X    { 1, 0xE01F },	/* long dash */
X    { 1, 0x87F8 },	/* dash dot */
X    { 1, 0x6666 },	/* big dots */
X};
X
X#define BITS_PER_LINETYPE	16
X
X/* apollo_line(-2) is the border style, etc. */
X#define apollo_line(x)		apollo_lines[(x)+2]
X#define apollo_pattern(x)	&apollo_line(x).pattern
X#define apollo_width(x)		apollo_line(x).width
X
X#define APOLLO_MIN_LINE		(-2)
X#define APOLLO_MAX_LINE		(sizeof(apollo_lines)/sizeof(*apollo_lines)-2)
X
X/* set the line style */
XAPOLLO_linetype(ltype)
Xint ltype;
X{
X    status_$t status;
X
X    if (ltype < APOLLO_MIN_LINE)
X	ltype = APOLLO_MIN_LINE;
X    if (ltype >= APOLLO_MAX_LINE)
X	ltype %= APOLLO_MAX_LINE;
X
X    gpr_$set_line_pattern(1, apollo_pattern(ltype), BITS_PER_LINETYPE, &status);
X    apollo_check("set_line_pattern");
X
X    gpr_$set_draw_width(draw_width * apollo_width(ltype), &status);
X    apollo_check("set_draw_width");
X}
X
X/* issue an error message that includes an (x, y) coordinate */
Xstatic void apollo_xy_error(char* s, int x, int y, status_$t status)
X{
X    char buffer[128];
X
X    sprintf(buffer, "%s(%d, %d)", s, x, y);
X    apollo_error(buffer);
X}
X
X#define apollo_xy_check(s)	\
X    if (status.all != status_$ok) apollo_xy_error((s), x, y, status)
X
X/*
X    Note that GNUplot and GPR have reversed ideas of where the Y origin is.
X    This means subtracting the Y coordinate from Y max.
X*/
X#define plot_to_gpr(y)		(APOLLO_YMAX - (y))
X
X/* move to a new position */
XAPOLLO_move(unsigned int x, unsigned int y)
X{
X    status_$t status;
X
X    gpr_$move((gpr_$coordinate_t) x, plot_to_gpr(y), &status);
X    apollo_xy_check("move");
X}
X
X/* draw a line to a new position */
XAPOLLO_vector(unsigned int x, unsigned int y)
X{
X    status_$t status;
X
X    gpr_$line((gpr_$coordinate_t) x, plot_to_gpr(y), &status);
X    apollo_xy_check("line");
X}
X
X/*
X    On terminals, this switches to text mode.  The real meaning,
X    however, is that the graphics are finished.  This means we can
X    now display the saved bitmap.
X*/
XAPOLLO_text()
X{
X    if (use_bitmap)
X    {
X	static gpr_$position_t pos;		/* always zero */
X	gpr_$window_t window;
X	status_$t status;
X
X	/* bitblt the entire bitmap to the entire window */
X	window.window_base.x_coord = 0;
X	window.window_base.y_coord = 0;
X	window.window_size.x_size = APOLLO_XMAX;
X	window.window_size.y_size = APOLLO_YMAX;
X
X	gpr_$set_bitmap(screen_desc, &status);
X	apollo_check("set_bitmap(screen_desc)");
X
X	gpr_$pixel_blt(bitmap_desc, window, pos, &status);
X	apollo_check("bitblt");
X
X	gpr_$set_bitmap(bitmap_desc, &status);
X	apollo_check("set_bitmap(bitmap_desc)");
X    }
X}
X
XAPOLLO_text_angle(ang)
Xint ang;
X{
X    status_$t status;
X
X    gpr_$set_text_path(ang ? gpr_$up : gpr_$right, &status);
X    apollo_check("set_text_path");
X    return TRUE;
X}
X
Xstatic enum JUSTIFY apollo_text_mode;
X
XAPOLLO_justify_text(mode)
Xenum JUSTIFY mode;
X{
X    apollo_text_mode = mode;
X    return TRUE;
X}
X
X/*
X    Write "str" right justified on row "row".  A row is assumed to
X    have whatever height the current text has.  Make sure the
X    text does not cover the tick marks.
X*/
XAPOLLO_put_text(x, y, str)
Xunsigned int x, y;
Xchar str[];
X{
X    gpr_$offset_t size;
X    status_$t status;
X
X    gpr_$inq_text_extent(str, strlen(str), &size, &status);
X    apollo_check("inq_text_extent");
X
X    y -= size.y_size / 2;	/* center around "y" */
X    switch (apollo_text_mode)
X    {
X    case LEFT:
X	break;
X    case CENTRE:
X	x -= size.x_size / 2;
X	break;
X    case RIGHT:
X	x -= size.x_size;
X	break;
X    }
X    APOLLO_move(x, y);
X
X    gpr_$text(str, strlen(str), &status);
X    apollo_check("put_text");
X}
X
X/* reset the graphics state and terminate */
XAPOLLO_reset()
X{
X    if (stream != -1)
X    {
X	apollo_gpr_terminate();
X	stream = -1;
X    }
X}
END_OF_FILE
  if test 17140 -ne `wc -c <'gnuplot/term/apollo.trm'`; then
    echo shar: \"'gnuplot/term/apollo.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/apollo.trm'
fi
if test -f 'gnuplot/term/mif.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/mif.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/mif.trm'\" \(19730 characters\)
  sed "s/^X//" >'gnuplot/term/mif.trm' <<'END_OF_FILE'
X/* GNUPLOT -- mif.trm */
X/*
X * Copyright (C) 1992, 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver was developed for
X *      gnuplot for unix version 3.0 (patchlevel 1)
X *      gnuplot for unix version 3.2 (patchlevel 2)
X *
X * This terminal driver supports:
X *      Frame Maker MIF format version 3.00
X *
X * Options for this terminal driver (set terminal mif [options]):
X *      colour /        Draw primitives with line types >= 0 in colour (sep. 2-7)
X *      monochrome      Draw primitives in black (sep. 0)
X *
X *      polyline /      Draw lines as continous curves
X *      vectors         Draw lines as collections of vectors
X *
X *      help / ?        Print short usage description on stderr
X *
X * Properties for this terminal driver:
X *     -Gnuplot size of worksheet:              MIF_XMAX * MIF_YMAX
X *     -Unit in MIF output:                     cm
X *     -Plot primitives with the same pen will
X *      be grouped in the same MIF group.
X *     -Plot primitives with line types >= 0
X *      will as default be drawn in colour.
X *     -Lines are plotted as collections of
X *      vectors, or as continous lines (default)
X *     -Plot primitives in a plot will be in a
X *      Frame in MIF. Several plot Frames will
X *      be collected in one large Frame.
X *     -Point size of MIF output characters:    MIF_PSIZE
X *     -Used font for MIF output characters:    Times
X *     -Supports vertical text
X *
X * AUTHORS:
X *      Olof Franksson, Physics IV, KTH, S-100 44 Stockholm, Sweden
X * 
X * COMMENTS:
X *      Send comments and/or suggestions to olof@fysik4.kth.se
X * 
X * CHANGES:
X *      Changed order of routine declarations.          olof@fysik4.kth.se
X *      Changed mechanism for pen pattern selection.    kssingvo@immd4.informatik.uni-erlangen.de
X *      Support for vertical text.                      kssingvo@immd4.informatik.uni-erlangen.de
X *      Fixed plot bug for "set size XS,YS", XS/YS > 1. olof@fysik4.kth.se
X *
X */
X#if !defined(cfree)
X#define cfree free
X#endif
X
X/** Coordinates **/
X#define GNP_TO_MIF(P)   (((float) (P)) / 1000.0)        /* Converts gnuplot units to MIF units */
X#define MIF_XMAX 15000                  /* Basic unit: 0.01 mm (15cm -> 15*10*100=15000) */
X#define MIF_YMAX 10000                  /* Basic unit: 0.01 mm (10cm -> 10*10*100=10000) */
X
X#define MIF_XLAST (MIF_XMAX - 1)
X#define MIF_YLAST (MIF_YMAX - 1)
X
Xstatic struct mif_line { /* Line point structure specification */
X	float fpos_x;           /* Line point X coordinate */
X	float fpos_y;           /*            Y coordinate */
X	struct mif_line *next;  /* Pointer to next line point */
X	struct mif_line *prev;  /* Pointer to previous line point */
X} mif_line = { /* Current position structure. Adjust for orign. Local for this file. */
X	GNP_TO_MIF(0),
X	GNP_TO_MIF(MIF_YLAST),
X	&mif_line,
X	&mif_line
X};
X
X/** Characters **/
X#define MIF_PSIZE 9                     /* Point size of used characters */
X
X#define MIF_VCHAR (MIF_YMAX/31)         /* Distance between rows (a guess) */
X#define MIF_HCHAR (MIF_XMAX/95)         /* Distance between characters (a guess) */
X
X/** Scale marks **/
X#define MIF_VTIC  (MIF_YMAX/150)        /* Size of scale mark (vert) */
X#define MIF_HTIC  (MIF_XMAX/225)        /* Size of scale mark (hor) */
X
X/** Drawing properties **/
Xstatic char mif_justify[64];                    /* How to justify the used text */
Xstatic char mif_pen[64], mif_pen_width[64], mif_separation[64];         /* How to plot */
X
X#define MIF_TEXT_HOR  0
X#define MIF_TEXT_VER  1
Xstatic int mif_text_ang = MIF_TEXT_HOR;         /* Rotation angle of text */
X
X#define MIF_NPENS 16                    /* Number of MIF pen types */
Xstatic int mif_pentype = 0;             /* Pen type to use. Also used to create groups for graphics */
X#define MIF_PEN_TO_GROUP(P)     ( 1 + (P) )     /* Map pen type to group number. Must be >= 1 */
X
Xstatic int mif_pattern_table[MIF_NPENS] = {     /* Table, which pattern should be used for drawing */
X    0,                          /* border  */
X    1,                          /* not used */
X    2, 3, 4, 8, 12, 13,         /* other lines: functions, data, ... (5 is used for grid; 6,7 is (nearly) invisible) */
X    5,                          /* grid */
X    9, 10, 11, 12, 13, 14, 15   /* not used */
X};
X
X/** MIF groups administration **/
X#define MIF_NGROUP_ID           20
Xstatic struct mif_group_id {
X	int group_existance;
X#define MIF_GROUP_EXISTS        1       /* This group id should generate a MIF group */
X#define MIF_GROUP_NOT_EXISTS    0       /* This group id should not generate a MIF group */
X
X	int group_id;
X#define MIF_INVALID_GROUP_ID    0       /* An invalid MIF group ID */
X
X} mif_group_id[MIF_NGROUP_ID];            /* List of used group ID:s and corresponding MIF groups existance */
X
X/** Semaphores **/
Xstatic int mif_initialized = 0;		/* != 0 when output is active */
Xstatic int mif_in_frame = 0;            /* != 0 when inside a plot frame */
Xstatic int mif_frameno = -1;            /* Current frame number */
Xstatic int mif_colour = TRUE;           /* == TRUE when colour should be used */
Xstatic int mif_polyline = TRUE;         /* == TRUE when lines are drawn as continous curves */
X
X/** Declaration of routine/s for internal use **/
Xstatic int insert_mif_line(), proc_group_id();
X
X/** Routine/s **/
X
X/* Called when this terminal type is set in order to parse options */
XMIF_options()
X{
X	extern char term_options[];     /* Declared in ../setshow.c */
X
X	if (!END_OF_COMMAND) {
X		/* Colour options */
X		if (!END_OF_COMMAND && almost_equals(c_token, "m$onochrome")) {    /* Compare up to $ */
X			mif_colour = FALSE;
X			c_token++;
X		}
X		if (!END_OF_COMMAND && almost_equals(c_token, "c$olour")) {   /* Compare up to $ */
X			mif_colour = TRUE;
X			c_token++;
X		}
X
X		/* Curve options */
X		if (!END_OF_COMMAND && almost_equals(c_token, "v$ectors")) {   /* Compare up to $ */
X			mif_polyline = FALSE;
X			c_token++;
X		}
X		if (!END_OF_COMMAND && almost_equals(c_token, "p$olyline")) {   /* Compare up to $ */
X			mif_polyline = TRUE;
X			c_token++;
X		}
X
X		/* Short help */
X		if ( !END_OF_COMMAND &&
X		     (almost_equals(c_token, "h$elp") ||
X		      almost_equals(c_token, "?$")) ) { /* Compare up to $ */
X			fprintf(stderr, "Usage: set terminal mif [options]\n");
X			fprintf(stderr, "\toptions:\n");
X			fprintf(stderr, "\t\tcolour /        Draw primitives with line types >= 0 in colour (sep. 2-7)\n");
X			fprintf(stderr, "\t\tmonochrome      Draw primitives in black (sep. 0)                        \n");
X			fprintf(stderr, "\n");
X			fprintf(stderr, "\t\tpolyline /      Draw lines as continous curves                           \n");
X			fprintf(stderr, "\t\tvectors         Draw lines as collections of vectors                     \n");
X			fprintf(stderr, "\n");
X			fprintf(stderr, "\t\thelp / ?        Print short usage description on stderr                  \n");
X
X			c_token++;
X		}
X	}
X
X	sprintf(term_options, "%s %s", (mif_colour == TRUE)? "colour": "monochrome",
X				       (mif_polyline == TRUE)? "polyline": "vectors");
X}
X
X/* Deallocate the used line structure elements */
Xstatic int free_mif_line()
X{
X	struct mif_line *tline;
X
X	while (mif_line.prev != &mif_line) {
X		/* Unlink */
X		tline = mif_line.prev;
X		mif_line.prev = mif_line.prev->prev;
X		mif_line.prev->next = &mif_line;
X
X		/* Deallocate */
X		free(tline);
X	}
X
X	/* Make sure that the list will be empty */
X	mif_line.prev = &mif_line;
X	mif_line.next = &mif_line;
X}
X
X/* Draw the pending line. Change current position. */
Xstatic int put_mif_line()
X{
X	int np, i;
X	struct mif_line *tline;
X
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Count the number of available points */
X		for (tline = mif_line.next, np = 1; tline != &mif_line; tline = tline->next, np++)
X			;
X
X		/* Draw line (at least two points) */
X		if (np >= 2) {
X			/* Line preamble */
X			fprintf(outfile, "\t<PolyLine <GroupID %d> %s %s %s\n",
X					 MIF_PEN_TO_GROUP(mif_pentype), mif_pen, mif_pen_width, mif_separation);
X
X			/* Draw the line elements */
X			fprintf(outfile, "\t\t<NumPoints %d> ", np);
X			for (i = 0, tline = &mif_line; i < np; i++, tline = tline->next) {
X				if (i%4 == 0)
X					fprintf(outfile, "\n\t\t");
X				fprintf(outfile, "<Point  %.3f %.3f> ", tline->fpos_x, tline->fpos_y);
X			}
X
X			/* Line post amble */
X			fprintf(outfile, "\n\t>\n");
X
X			/* Register the used group ID */
X			proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
X
X			/* Avoid to redraw this. The MIF system should remember it. */
X			mif_pen[0] = '\0';
X			mif_pen_width[0] = '\0';
X			mif_separation[0] = '\0';
X
X			/* Move current position to end of line */
X			mif_line.fpos_x = mif_line.prev->fpos_x;
X			mif_line.fpos_y = mif_line.prev->fpos_y;
X
X			/* Restore the line */
X			free_mif_line();
X		}
X
X	} /* Line processed */
X}
X
X/* Set up a MIF output file */
XMIF_init()
X{
X	int i;
X
X	extern char version[];		/* Declared in ../version.c */
X	extern char patchlevel[];
X
X	/* Process if not inside a MIF file and Frame */
X	if (mif_initialized == 0 && mif_in_frame == 0) {
X		/* Tell this terminal driver that the output is initialized and no current frames are processed */
X		mif_initialized = 1;
X		mif_in_frame = 0;
X
X		/* Reset internal position */
X		free_mif_line();
X		mif_line.fpos_x = GNP_TO_MIF(0);
X		mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
X
X		/* Reset drawing properties strings */
X		mif_pen[0] = '\0';
X		mif_pen_width[0] = '\0';
X		mif_separation[0] = '\0';
X		sprintf(mif_justify, " <TLAlignment Left> ");
X
X		/* Reset group ID generator */
X		for (i = 0; i < MIF_NGROUP_ID; i++) {
X			mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
X			mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
X		}
X
X		/* Identify ourselves */
X		fprintf(outfile, "<MIFFile 3.00> # Generated by gnuplot version %s patchlevel %s; identifies this as a MIF file\n", version, patchlevel);
X		fprintf(outfile, "#\n");
X
X		/* Setup a default environment to use */
X		fprintf(outfile, "# Set a default pen pattern, pen width, unit and font for subsequent objects\n");
X		fprintf(outfile, "<Pen 0>\n");
X		fprintf(outfile, "<Fill 15>\n");
X		fprintf(outfile, "<PenWidth 0.5 pt>\n");
X		fprintf(outfile, "<Separation 0>\n");
X		fprintf(outfile, "<Units Ucm>\n");
X		fprintf(outfile, "<Font <FFamily `Times'> <FSize %d> <FPlain Yes>>\n", MIF_PSIZE);
X		fprintf(outfile, "#\n");
X	} /* MIF file created */
X}
X
X/* Finish of a MIF output file */
XMIF_reset()
X{
X	/* Process if inside a MIF file and not inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame == 0) {
X		/* Finish off the MIF file */
X		fprintf(outfile, "#\n");
X		fprintf(outfile, "# End of MIFFile\n");
X
X		/* Tell this terminal driver that the output is finished */
X		mif_initialized = 0;
X	} /* MIF file finished */
X}
X
X/* Start plotting a Frame (-> graphics mode) */
XMIF_graphics()
X{
X	int i;
X
X	/* Process if not inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame == 0) {
X		/* Tell that this terminal driver is working with a plot frame */
X		mif_in_frame = 1;
X
X		/* Update frame number */
X		mif_frameno++;
X
X		/* Set current position */
X		free_mif_line();
X		mif_line.fpos_x = GNP_TO_MIF(0);
X		mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST);
X
X		/* Set drawing properties */
X		mif_pen[0] = '\0';
X		mif_pen_width[0] = '\0';
X		mif_separation[0] = '\0';
X		sprintf(mif_justify, " <TLAlignment Left> ");
X
X		/* Reset group ID generator */
X		for (i = 0; i < MIF_NGROUP_ID; i++) {
X			mif_group_id[i].group_id = MIF_INVALID_GROUP_ID;
X			mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
X		}
X
X		/* Frame preamble */
X		fprintf(outfile, "#\n");
X		fprintf(outfile, "# Frame number %d with plot of graphics\n", mif_frameno);
X		fprintf(outfile, "<Frame\n");
X		fprintf(outfile, "\t<Pen 15>\n");
X		fprintf(outfile, "\t<Fill 15>\n");
X		fprintf(outfile, "\t<PenWidth  0.5 pt>\n");
X		fprintf(outfile, "\t<Separation 0>\n");
X		fprintf(outfile, "\t<BRect 0.000 %.3f %.3f %.3f>\n",
X				 ((float) mif_frameno)*GNP_TO_MIF(MIF_YMAX+100), GNP_TO_MIF(MIF_XMAX), GNP_TO_MIF(MIF_YMAX));
X		fprintf(outfile, "\t<NSOffset  0.000>\n");
X		fprintf(outfile, "\t<BLOffset  0.000>\n");
X	} /* Frame created */
X}
X
X/* Stop plotting a Frame (-> text mode) */
XMIF_text()
X{
X	int i;
X
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Draw pending line */
X		if (mif_polyline == TRUE)
X			put_mif_line();
X
X		/* Group the used plot primitives */
X		fprintf(outfile, "\t#\n");
X		fprintf(outfile, "\t# Group the the objects in groups to make the chart easier to manipulate\n");
X		fprintf(outfile, "\t# after it's imported into FrameMaker.\n");
X
X		for (i = 0; i < MIF_NGROUP_ID; i++) {
X			if (mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
X			    mif_group_id[i].group_existance == MIF_GROUP_EXISTS) {
X				fprintf(outfile, "\t<Group\n");
X				fprintf(outfile, "\t\t<ID %d>\n", mif_group_id[i].group_id);
X				fprintf(outfile, "\t>\n");
X			}
X		}
X
X		/* Frame post amble */
X		fprintf(outfile, ">\n");
X		fprintf(outfile, "# End of Frame number %d\n", mif_frameno);
X		fprintf(outfile, "#\n");
X
X		/* Tell that this terminal driver is not working with a plot frame */
X		mif_in_frame = 0;
X	} /* Frame finshed */
X}
X
X/* Select type of line in grapics */
X/* NOTE: actually written to output the first time a primitive is drawn AFTER this call */
XMIF_linetype(linetype)
Xint linetype;           /* -2=border, -1=X/Y-axis, 0-13=lines, and 14-=mapped back */
X{
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Draw pending line */
X		if (mif_polyline == TRUE)
X			put_mif_line();
X
X		/* Translate gnuplot pen types to MIF pen types */
X		if (linetype < 0) {     /* Special lines */
X			if (linetype == -1) {
X				mif_pentype = 8+MIF_NPENS;      /* -1 */
X				if (mif_colour == TRUE)
X					sprintf(mif_separation, " <Separation 0> ");
X			}
X			else {
X				mif_pentype = 0+MIF_NPENS;      /* -2 or less */
X				if (mif_colour == TRUE)
X					sprintf(mif_separation, " <Separation 0> ");
X			}
X			sprintf(mif_pen_width, " <PenWidth 1.0 pt> ");
X		}
X		else {                  /* Normal lines */
X			mif_pentype = (linetype)%MIF_NPENS;     /* 0-(MIF_NPENS-1) */
X			sprintf(mif_pen_width, " <PenWidth 0.5 pt> ");
X			if (mif_colour == TRUE)
X				sprintf(mif_separation, " <Separation %d> ", 2+(mif_pentype%6));        /* 2-7 */
X		}
X
X		/* Set pen type */
X		sprintf(mif_pen, " <Pen %d> ", mif_pattern_table[mif_pentype%MIF_NPENS]);
X
X	} /* Primitive processed */
X}
X
X/* Draw the text horisontally or vertically (90 degrees counterclockwise) */
Xint MIF_text_angle(ang)
Xint ang;
X{
X    if (ang != 0)
X	mif_text_ang = MIF_TEXT_VER;
X    else
X	mif_text_ang = MIF_TEXT_HOR;
X
X    return(TRUE);
X}
X
X/* Justify following text lines (MIF_put_text()) relative to the insertion point */
XMIF_justify_text(mode)
X/* NOTE: actually written to output in text primitives which are drawn AFTER this call */
Xenum JUSTIFY mode;
X{
X	int rval = TRUE;
X
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X		switch (mode) {
X		case LEFT:
X			sprintf(mif_justify, " <TLAlignment Left> ");
X			break;
X		case CENTRE:
X			sprintf(mif_justify, " <TLAlignment Center> ");
X			break;
X		case RIGHT:
X			sprintf(mif_justify, " <TLAlignment Right> ");
X			break;
X		default:
X			rval = FALSE;
X			break;
X		}
X
X	} /* Primitive processed */
X	else {
X		rval = FALSE;
X	}
X
X	return(rval);
X}
X
X/* Draw a vector from current position to (x, y) and change current position. */
X/* NOTE: actually written to output the first time another primitive is called AFTER this call */
XMIF_vector(x, y)
Xunsigned int x, y;
X{
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Setup the vector as a part of the line */
X		insert_mif_line(GNP_TO_MIF(x), GNP_TO_MIF(MIF_YLAST-(int)y));
X
X		/* Draw pending line -> vector */
X		if (mif_polyline == FALSE)
X			put_mif_line();
X
X	} /* Vector processed */
X}
X
X/* Move current position */
XMIF_move(x, y)
Xunsigned int x, y;
X{
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Draw pending line */
X		if (mif_polyline == TRUE)
X			put_mif_line();
X
X		mif_line.fpos_x = GNP_TO_MIF(x);
X		mif_line.fpos_y = GNP_TO_MIF(MIF_YLAST-(int)y);
X	}
X}
X
X/* Draw the text string str at (x, y). Adjust according to MIF_justify_text(). Change current position. */
XMIF_put_text(x, y, str)
Xunsigned int x, y;
Xchar str[];
X{
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Draw pending line */
X		if (mif_polyline == TRUE)
X			put_mif_line();
X
X		/* Adjust current position for text-graphics alignment */
X		MIF_move(x, y-MIF_VCHAR/5);
X
X		if (strlen(str) > 0) {
X
X			/* Draw the text */
X			fprintf(outfile, "\t<TextLine <GroupID %d> %s %s %s\n",
X					 MIF_PEN_TO_GROUP(mif_pentype), mif_pen, mif_pen_width, mif_separation);
X			fprintf(outfile, "\t\t<TLOrigin  %.3f %.3f> %s %s <String `%s'>\n",
X					 mif_line.fpos_x, mif_line.fpos_y, mif_justify,
X					 (mif_text_ang == MIF_TEXT_VER)? "<Angle 90>": "",
X					 str);
X			fprintf(outfile, "\t>\n");
X
X			/* Register the used group ID */
X			proc_group_id(MIF_PEN_TO_GROUP(mif_pentype));
X
X			/* Avoid to redraw this. The MIF system should remember it. */
X			mif_pen[0] = '\0';
X			mif_pen_width[0] = '\0';
X			mif_separation[0] = '\0';
X
X			mif_justify[0] = '\0';  /* Independent of linetype */
X		}
X	} /* Text processed */
X}
X
X
X/* Insert one point in the line */
Xstatic int insert_mif_line(fx, fy)
Xfloat fx, fy;
X{
X	int rval = TRUE;
X
X	if ((mif_line.prev->next = (struct mif_line *) alloc(sizeof(struct mif_line),"MIF driver")) != (struct mif_line *) NULL) {
X		/* Link */
X		mif_line.prev->next->next = &mif_line;
X		mif_line.prev->next->prev = mif_line.prev;
X		mif_line.prev = mif_line.prev->next;
X
X		/* Fill */
X		mif_line.prev->fpos_x = fx;
X		mif_line.prev->fpos_y = fy;
X
X		rval = TRUE;
X	}
X	else { /* Failed to allocate */
X		/* Relink */
X		mif_line.prev->next = &mif_line;
X
X		rval = FALSE;
X	}
X
X	return(rval);
X}
X
X
X/* Register group ID. Update group ID existance. */
X/* Returns:     1       group_id belongs to a MIF group
X		0       group_id does not belong to a MIF group
X	       -1       not inside a Frame
X	       -2       group ID list is full
X */
Xstatic int proc_group_id(group_id)
Xint group_id;
X{
X	int i, rval = 0;
X
X	/* Process if inside a Frame */
X	if (mif_initialized != 0 && mif_in_frame != 0) {
X
X		/* Find out the group ID, or a free group ID slot index. */
X		for (i = 0; i < MIF_NGROUP_ID &&
X			    mif_group_id[i].group_id != MIF_INVALID_GROUP_ID &&
X			    mif_group_id[i].group_id != group_id;
X										i++) {
X			/* Don't check the group_existance variable */
X		}
X
X		if (i < MIF_NGROUP_ID) {
X			if (mif_group_id[i].group_id == MIF_INVALID_GROUP_ID) {
X				/* Register as new group ID for eventual use as MIF group */
X				mif_group_id[i].group_id = group_id;
X				mif_group_id[i].group_existance = MIF_GROUP_NOT_EXISTS;
X			}
X			else {
X				/* If second use of this group ID -> create a new MIF group */
X				if (mif_group_id[i].group_id == group_id) {
X					mif_group_id[i].group_existance = MIF_GROUP_EXISTS;
X					/* NOTE: a group MUST have at least two members. */
X					rval = 1;
X				}
X			}
X		}
X		else {
X			rval = -2;      /* No place for this group ID in the list */
X		}
X
X	} /* Group ID processed */
X	else {
X		rval = -1;      /* Not inside a Frame */
X	}
X
X	/* Return MIF group status */
X	return(rval);
X}
X
END_OF_FILE
  if test 19730 -ne `wc -c <'gnuplot/term/mif.trm'`; then
    echo shar: \"'gnuplot/term/mif.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/mif.trm'
fi
if test -f 'gnuplot/win/wmenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wmenu.c'\"
else
  echo shar: Extracting \"'gnuplot/win/wmenu.c'\" \(18486 characters\)
  sed "s/^X//" >'gnuplot/win/wmenu.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: wmenu.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X/* GNUPLOT - win/wmenu.c */
X/*
X * Copyright (C) 1992   Maurice Castro, Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Maurice Castro
X *   Russell Lang
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X */
X
X#define STRICT
X#include <windows.h>
X#include <windowsx.h>
X#if WINVER >= 0x030a
X#include <commdlg.h>
X#endif
X#include <string.h>	/* only use far items */
X#include "wgnuplib.h"
X#include "wresource.h"
X#include "wcommon.h"
X
XBOOL CALLBACK _export InputBoxDlgProc(HWND, UINT, WPARAM, LPARAM);
XLRESULT CALLBACK _export MenuButtonProc(HWND, UINT, WPARAM, LPARAM);
X
X/* limits */
X#define MAXSTR 255
X#define MACROLEN 5000
X/* #define NUMMENU 256  defined in wresourc.h */
X#define MENUDEPTH 3
X
X/* menu tokens */
X#define CMDMIN 129
X#define INPUT 129
X#define EOS 130
X#define OPEN 131
X#define SAVE 132
X#define CMDMAX 132
Xchar * keyword[] = {
X	"[INPUT]", "[EOS]", "[OPEN]", "[SAVE]",
X        "{ENTER}", "{ESC}", "{TAB}",
X        "{^A}", "{^B}", "{^C}", "{^D}", "{^E}", "{^F}", "{^G}", "{^H}", 
X	"{^I}", "{^J}", "{^K}", "{^L}", "{^M}", "{^N}", "{^O}", "{^P}", 
X	"{^Q}", "{^R}", "{^S}", "{^T}", "{^U}", "{^V}", "{^W}", "{^X}", 
X	"{^Y}", "{^Z}", "{^[}", "{^\\}", "{^]}", "{^^}", "{^_}",
X	NULL};
XBYTE keyeq[] = {
X	INPUT, EOS, OPEN, SAVE,
X        13, 27, 9,
X        1, 2, 3, 4, 5, 6, 7, 8,
X	9, 10, 11, 12, 13, 14, 15, 16,
X	17, 18, 19, 20, 21, 22, 23, 24, 
X	25, 26, 28, 29, 30, 31,
X	NULL};
X
X
X/* Send a macro to the text window */
Xvoid
XSendMacro(LPTW lptw, UINT m)
X{
XBYTE FAR *s;
Xchar *d;
Xchar *buf;
XBOOL flag=TRUE;
Xint i;
XLPMW lpmw = lptw->lpmw;
X#if WINVER >= 0x030a
XOPENFILENAME ofn;
Xchar *szTitle;
Xchar *szFile;
Xchar *szFilter;
X#endif
X
X	if ( (buf = LocalAllocPtr(LHND, MAXSTR+1)) == (char *)NULL )
X		return;
X
X	if (m>=lpmw->nCountMenu)
X		return;
X	s = lpmw->macro[m];
X	d = buf;
X	*d = '\0';
X	while (s && *s && (d-buf < MAXSTR)) {
X	    if (*s>=CMDMIN  && *s<=CMDMAX) {
X		switch (*s) {
X			case SAVE: /* [SAVE] - get a save filename from a file list box */
X			case OPEN: /* [OPEN] - get a filename from a file list box */
X#if WINVER >= 0x030a
X				/* This uses COMMDLG.DLL from Windows 3.1 
X				   COMMDLG.DLL is redistributable */
X				{
X				BOOL save;
X				if ( (szTitle = LocalAllocPtr(LHND, MAXSTR+1)) == (char *)NULL )
X					return;
X				if ( (szFile = LocalAllocPtr(LHND, MAXSTR+1)) == (char *)NULL )
X					return;
X				if ( (szFilter = LocalAllocPtr(LHND, MAXSTR+1)) == (char *)NULL )
X					return;
X
X				save = (*s==SAVE);
X				s++;
X						for(i=0; (*s >= 32 && *s <= 126); i++)
X							szTitle[i] = *s++;	/* get dialog box title */
X				szTitle[i]='\0';
X				s++;
X						for(i=0; (*s >= 32 && *s <= 126); i++)
X							szFile[i] = *s++;	/* temporary copy of filter */
X				szFile[i++]='\0';
X				lstrcpy(szFilter,"Default (");
X				lstrcat(szFilter,szFile);
X				lstrcat(szFilter,")");
X				i=lstrlen(szFilter);
X				i++;	/* move past NULL */
X				lstrcpy(szFilter+i,szFile);
X				i+=lstrlen(szFilter+i);
X				i++;	/* move past NULL */
X				lstrcpy(szFilter+i,"All Files (*.*)");
X				i+=lstrlen(szFilter+i);
X				i++;	/* move past NULL */
X				lstrcpy(szFilter+i,"*.*");
X				i+=lstrlen(szFilter+i);
X				i++;	/* move past NULL */
X				szFilter[i++]='\0';	/* add a second NULL */
X				flag = 0;
X
X				/* the Windows 3.1 implentation - MC */
X				szFile[0] = '\0';
X				/* clear the structrure */
X				_fmemset(&ofn, 0, sizeof(OPENFILENAME));
X				ofn.lStructSize = sizeof(OPENFILENAME);
X				ofn.hwndOwner = lptw->hWndParent;
X				ofn.lpstrFilter = szFilter;
X				ofn.nFilterIndex = 1;
X				ofn.lpstrFile = szFile;
X				ofn.nMaxFile = MAXSTR;
X				ofn.lpstrFileTitle = szFile;
X				ofn.nMaxFileTitle = MAXSTR;
X				ofn.lpstrTitle = szTitle;
X				ofn.lpstrInitialDir = (LPSTR)NULL;
X				ofn.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
X				flag = (save ? GetSaveFileName(&ofn) : GetOpenFileName(&ofn));
X				if( flag ) {
X					lpmw->nChar = lstrlen(ofn.lpstrFile);
X					for (i=0; i<lpmw->nChar; i++)
X						*d++=ofn.lpstrFile[i];
X				}
X
X				LocalFreePtr((void NEAR *)OFFSETOF(szTitle));
X				LocalFreePtr((void NEAR *)OFFSETOF(szFilter));
X				LocalFreePtr((void NEAR *)OFFSETOF(szFile));
X
X				}
X				break;
X#else
X				/* Use InputBox if you don't have COMMDLG.DLL.
X				s++;	/* skip list box title */
X				for(i=0; (*s >= 32 && *s <= 126); i++)
X					s++;
X#endif
X			case INPUT: /* [INPUT] - input a string of characters */
X				s++;
X				for(i=0; (*s >= 32 && *s <= 126); i++)
X					lpmw->szPrompt[i] = *s++;
X				lpmw->szPrompt[i]='\0';
X#ifdef __DLL__
X				lpmw->lpProcInput = (DLGPROC)GetProcAddress(hdllInstance, "InputBoxDlgProc");
X#else
X				lpmw->lpProcInput = (DLGPROC)MakeProcInstance((FARPROC)InputBoxDlgProc, hdllInstance);
X#endif
X				flag = DialogBox( hdllInstance, "InputDlgBox", lptw->hWndParent, lpmw->lpProcInput);
X				if( flag ) {
X					for (i=0; i<lpmw->nChar; i++)
X						*d++=lpmw->szAnswer[i];
X				}
X#ifndef __DLL__
X				FreeProcInstance((FARPROC)lpmw->lpProcInput);
X#endif
X				break;
X		    case EOS: /* [EOS] - End Of String - do nothing */
X				default:
X				s++;
X				break;
X		}
X		if (!flag) { /* abort */
X			d = buf;
X			s = (BYTE FAR *)"";
X		}
X	    }
X	    else {
X		*d++ = *s++;
X	    }
X	}
X	*d = '\0';
X	if (buf[0]!='\0') {
X		d = buf;
X		while (*d) {
X			SendMessage(lptw->hWndText,WM_CHAR,*d,1L);
X			d++;
X		}
X	}
X}
X
X
X#define GBUFSIZE 512
Xtypedef struct tagGFILE {
X	HFILE	hfile;
X	char 	getbuf[GBUFSIZE];
X	int	getnext;
X	int	getleft;
X} GFILE;
X
XGFILE * Gfopen(LPSTR lpszFileName, int fnOpenMode)
X{
XGFILE *gfile;
X	
X	gfile = (GFILE *)LocalAllocPtr(LHND, sizeof(GFILE));
X	if (!gfile)
X		return NULL;
X
X	gfile->hfile = _lopen(lpszFileName, fnOpenMode);
X	if (gfile->hfile == HFILE_ERROR) {
X		LocalFreePtr((void NEAR *)OFFSETOF(gfile));
X		return NULL;
X	}
X	gfile->getleft = 0;
X	gfile->getnext = 0;
X	return gfile;
X}
X
Xvoid Gfclose(GFILE * gfile)
X{
X	
X	_lclose(gfile->hfile);
X	LocalFreePtr((void NEAR *)OFFSETOF(gfile));
X	return;
X}
X
X/* returns number of characters read */
Xint
XGfgets(LPSTR lp, int size, GFILE *gfile)
X{
Xint i;
Xint ch;
X	for (i=0; i<size; i++) {
X		if (gfile->getleft <= 0) {
X			if ( (gfile->getleft = _lread(gfile->hfile, gfile->getbuf, GBUFSIZE)) == 0)
X				break;
X			gfile->getnext = 0;
X		}
X		ch = *lp++ = gfile->getbuf[gfile->getnext++];
X		gfile->getleft --;
X		if (ch == '\r') {
X			i--;
X			lp--;
X		}
X		if (ch == '\n') {
X			i++;
X			break;
X		}
X	}
X	if (i<size)
X		*lp++ = '\0';
X	return i;
X}
X
X/* Get a line from the menu file */
X/* Return number of lines read from file including comment lines */
Xint GetLine(char * buffer, int len, GFILE *gfile)
X{
XBOOL  status;
Xint nLine = 0;
X    
X   status = (Gfgets(buffer,len,gfile) != 0);
X   nLine++;
X   while( status && ( buffer[0] == NULL || buffer[0] == '\n' || buffer[0] == ';' ) ) {
X      /* blank line or comment - ignore */ 
X   	  status = (Gfgets(buffer,len,gfile) != 0);
X      nLine++;
X   }
X   if (lstrlen(buffer)>0)
X      buffer[lstrlen(buffer)-1] = '\0';	/* remove trailing \n */
X
X   if (!status)
X      nLine = 0;	/* zero lines if file error */
X        
X    return nLine;
X}
X
X/* Left justify string */
Xvoid LeftJustify(char *d, char *s)
X{
X	while ( *s && (*s==' ' || *s=='\t') )
X		s++;	/* skip over space */
X	do {
X		*d++ = *s;
X	} while (*s++);
X}
X
X/* Translate string to tokenized macro */
Xvoid TranslateMacro(char *string)
X{
Xint i, len;
XLPSTR ptr;
X
X    for( i=0; keyword[i]!=(char *)NULL; i++ ) {
X        if( (ptr = _fstrstr( string, keyword[i] )) != NULL ) {
X            len = lstrlen( keyword[i] );
X            *ptr = keyeq[i];
X            lstrcpy( ptr+1, ptr+len );
X            i--;       /* allows for more than one occurrence of keyword */
X            }
X        }
X}
X
X/* Load Macros, and create Menu from Menu file */
Xvoid 
XLoadMacros(LPTW lptw)
X{
XGFILE *menufile;
XBYTE FAR *macroptr;
Xchar *buf;
Xint nMenuLevel;
XHMENU hMenu[MENUDEPTH+1];
XLPMW lpmw;
Xint nLine = 1;
Xint nInc;
XHGLOBAL hmacro, hmacrobuf;
X
Xint i;
XHDC hdc;
XTEXTMETRIC tm;
XRECT rect;
Xint ButtonX, ButtonY;
Xchar FAR *ButtonText[BUTTONMAX];
X
X	lpmw = lptw->lpmw;
X
X	/* mark all buffers and menu file as unused */
X	buf = (char *)NULL;
X	hmacro = 0;
X	hmacrobuf = 0;
X	lpmw->macro = (BYTE FAR * FAR *)NULL;
X	lpmw->macrobuf = (BYTE FAR *)NULL;
X	lpmw->szPrompt = (char *)NULL;
X	lpmw->szAnswer = (char *)NULL;
X	menufile = (GFILE *)NULL;
X
X	/* open menu file */
X	if ((menufile=Gfopen(lpmw->szMenuName,READ)) == (GFILE *)NULL)
X		goto errorcleanup;
X
X	/* allocate buffers */
X	if ((buf = LocalAllocPtr(LHND, MAXSTR)) == (char *)NULL)
X		goto nomemory;
X	hmacro = GlobalAlloc(GHND,(NUMMENU) * sizeof(BYTE FAR *));
X	if ((lpmw->macro = (BYTE FAR * FAR *)GlobalLock(hmacro))  == (BYTE FAR * FAR *)NULL)
X		goto nomemory;
X	hmacrobuf = GlobalAlloc(GHND, MACROLEN);
X	if ((lpmw->macrobuf = (BYTE FAR*)GlobalLock(hmacrobuf)) == (BYTE FAR *)NULL)
X		goto nomemory;
X	if ((lpmw->szPrompt = LocalAllocPtr(LHND, MAXSTR)) == (char *)NULL)
X		goto nomemory;
X	if ((lpmw->szAnswer = LocalAllocPtr(LHND, MAXSTR)) == (char *)NULL)
X		goto nomemory;
X
X	macroptr = lpmw->macrobuf;
X	lpmw->nButton = 0;
X	lpmw->nCountMenu = 0;
X	lpmw->hMenu = hMenu[0] = CreateMenu();
X	nMenuLevel = 0;
X
X	while ((nInc = GetLine(buf,MAXSTR,menufile)) != 0) {
X	  nLine += nInc;
X	  LeftJustify(buf,buf);
X	  if (buf[0]=='\0') {
X		/* ignore blank lines */
X	  }
X	  else if (!lstrcmpi(buf,"[Menu]")) {
X		/* new menu */
X		if (!(nInc = GetLine(buf,MAXSTR,menufile))) {
X			nLine += nInc;
X			wsprintf(buf,"Problem on line %d of %s\n",nLine,lpmw->szMenuName);
X            		MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		LeftJustify(buf,buf);
X		if (nMenuLevel<MENUDEPTH)
X			nMenuLevel++;
X		else {
X			wsprintf(buf,"Menu is too deep at line %d of %s\n",nLine,lpmw->szMenuName);
X            		MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		hMenu[nMenuLevel] = CreateMenu();
X		AppendMenu(hMenu[nMenuLevel > 0 ? nMenuLevel-1 : 0],
X			MF_STRING | MF_POPUP, (UINT)hMenu[nMenuLevel], (LPCSTR)buf);
X	  }
X	  else if (!lstrcmpi(buf,"[EndMenu]")) {
X		if (nMenuLevel > 0)
X			nMenuLevel--;	/* back up one menu */
X	  }
X	  else if (!lstrcmpi(buf,"[Button]")) {
X		/* button macro */
X		if (lpmw->nButton >= BUTTONMAX) {
X			wsprintf(buf,"Too many buttons at line %d of %s\n",nLine,lpmw->szMenuName);
X           			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		if (!(nInc = GetLine(buf,MAXSTR,menufile))) {
X			nLine += nInc;
X			wsprintf(buf,"Problem on line %d of %s\n",nLine,lpmw->szMenuName);
X            		MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		LeftJustify(buf,buf);
X		if (lstrlen(buf)+1 < MACROLEN - (macroptr-lpmw->macrobuf))
X			lstrcpy((char FAR *)macroptr,buf);
X		else {
X			wsprintf(buf,"Out of space for storing menu macros\n at line %d of \n",nLine,lpmw->szMenuName);
X           			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		ButtonText[lpmw->nButton] = (char FAR *)macroptr;
X		macroptr += lstrlen((char FAR *)macroptr)+1;
X		*macroptr = '\0';
X		if (!(nInc = GetLine(buf,MAXSTR,menufile))) {
X			nLine += nInc;
X			wsprintf(buf,"Problem on line %d of %s\n",nLine,lpmw->szMenuName);
X           			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		LeftJustify(buf,buf);
X		TranslateMacro(buf);
X		if (lstrlen(buf)+1 < MACROLEN - (macroptr-lpmw->macrobuf))
X			lstrcpy((char FAR *)macroptr,buf);
X		else {
X			wsprintf(buf,"Out of space for storing menu macros\n at line %d of \n",nLine,lpmw->szMenuName);
X           			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		lpmw->hButtonID[lpmw->nButton] = lpmw->nCountMenu;
X		lpmw->macro[lpmw->nCountMenu] = macroptr;
X		macroptr += lstrlen((char FAR *)macroptr)+1;
X		*macroptr = '\0';
X		lpmw->nCountMenu++;
X		lpmw->nButton++;
X	  }
X	  else {
X		/* menu item */
X		if (lpmw->nCountMenu>=NUMMENU) {
X			wsprintf(buf,"Too many menu items at line %d of %s\n",nLine,lpmw->szMenuName);
X           			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X			goto errorcleanup;
X		}
X		LeftJustify(buf,buf);
X		if (buf[0]=='-') {
X		    if (nMenuLevel == 0)
X			AppendMenu(hMenu[0], MF_MENUBREAK, 0, (LPSTR)NULL);
X		    else
X			AppendMenu(hMenu[nMenuLevel], MF_SEPARATOR, 0, (LPSTR)NULL);
X		}
X		else if (buf[0]=='|') {
X			AppendMenu(hMenu[nMenuLevel], MF_MENUBARBREAK, 0, (LPSTR)NULL);
X		}
X		else {
X			AppendMenu(hMenu[nMenuLevel],MF_STRING, lpmw->nCountMenu, (LPSTR)buf);
X			if (!(nInc = GetLine(buf,MAXSTR,menufile))) {
X				nLine += nInc;
X				wsprintf(buf,"Problem on line %d of %s\n",nLine,lpmw->szMenuName);
X            			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X				goto errorcleanup;
X			}
X			LeftJustify(buf,buf);
X			TranslateMacro(buf);
X			if (lstrlen(buf)+1 < MACROLEN - (macroptr-lpmw->macrobuf))
X				lstrcpy((char FAR *)macroptr,buf);
X			else {
X				wsprintf(buf,"Out of space for storing menu macros\n at line %d of %s\n",nLine,lpmw->szMenuName);
X            			MessageBox(lptw->hWndParent,(LPSTR) buf,lptw->Title, MB_ICONEXCLAMATION);
X				goto errorcleanup;
X			}
X			lpmw->macro[lpmw->nCountMenu] = macroptr;
X			macroptr += lstrlen((char FAR *)macroptr)+1;
X			*macroptr = '\0';
X			lpmw->nCountMenu++;
X		}
X	  }
X	}
X
X	if ( (lpmw->nCountMenu - lpmw->nButton) > 0 ) {
X		/* we have a menu bar so put it on the window */
X		SetMenu(lptw->hWndParent,lpmw->hMenu);
X		DrawMenuBar(lptw->hWndParent);
X	}
X
X	if (!lpmw->nButton)
X		goto cleanup;		/* no buttons */
X
X	/* calculate size of buttons */
X	hdc = GetDC(lptw->hWndParent);
X	SelectFont(hdc, GetStockFont(SYSTEM_FIXED_FONT));
X	GetTextMetrics(hdc, &tm);
X	ButtonX = 8 * tm.tmAveCharWidth;
X	ButtonY = 6 * (tm.tmHeight + tm.tmExternalLeading) / 4;
X	ReleaseDC(lptw->hWndParent,hdc);
X
X	/* move top of client text window down to allow space for buttons */
X	lptw->ButtonHeight = ButtonY+1;
X	GetClientRect(lptw->hWndParent, &rect);
X	SetWindowPos(lptw->hWndText, (HWND)NULL, 0, lptw->ButtonHeight,
X			rect.right, rect.bottom-lptw->ButtonHeight, 
X			SWP_NOZORDER | SWP_NOACTIVATE);
X
X	/* create the buttons */
X#ifdef __DLL__
X	lpmw->lpfnMenuButtonProc = (WNDPROC)GetProcAddress(hdllInstance, "MenuButtonProc");
X#else
X	lpmw->lpfnMenuButtonProc = (WNDPROC)MakeProcInstance((FARPROC)MenuButtonProc, hdllInstance);
X#endif
X	for (i=0; i<lpmw->nButton; i++) {
X		lpmw->hButton[i] = CreateWindow("button", ButtonText[i],
X			WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
X				i * ButtonX, 0,
X				ButtonX, ButtonY,
X				lptw->hWndParent, (HMENU)i,
X				lptw->hInstance, lptw);
X		lpmw->lpfnButtonProc[i] = (WNDPROC) GetWindowLong(lpmw->hButton[i], GWL_WNDPROC);
X		SetWindowLong(lpmw->hButton[i], GWL_WNDPROC, (LONG)lpmw->lpfnMenuButtonProc);
X	}
X
X	goto cleanup;
X
X
Xnomemory:
X	MessageBox(lptw->hWndParent,"Out of memory",lptw->Title, MB_ICONEXCLAMATION);
Xerrorcleanup:
X	if (hmacro) {
X		GlobalUnlock(hmacro);
X		GlobalFree(hmacro);
X	}
X	if (hmacrobuf) {
X		GlobalUnlock(hmacrobuf);
X		GlobalFree(hmacrobuf);
X	}
X	if (lpmw->szPrompt != (char *)NULL)
X		LocalFreePtr((void NEAR *)OFFSETOF(lpmw->szPrompt));
X	if (lpmw->szAnswer != (char *)NULL)
X		LocalFreePtr((void NEAR *)OFFSETOF(lpmw->szAnswer));
X
Xcleanup:
X	if (buf != (char *)NULL)
X		LocalFreePtr((void NEAR *)OFFSETOF(buf));
X	if (menufile != (GFILE *)NULL)
X		Gfclose(menufile);
X	return;
X
X}
X
Xvoid
XCloseMacros(LPTW lptw)
X{
XHGLOBAL hglobal;
XLPMW lpmw;
X	lpmw = lptw->lpmw;
X
X#ifndef __DLL__
X	if (lpmw->lpfnMenuButtonProc)
X		FreeProcInstance((FARPROC)lpmw->lpfnMenuButtonProc);
X#endif
X	hglobal = (HGLOBAL)GlobalHandle( SELECTOROF(lpmw->macro) );
X	if (hglobal) {
X		GlobalUnlock(hglobal);
X		GlobalFree(hglobal);
X	}
X	hglobal = (HGLOBAL)GlobalHandle( SELECTOROF(lpmw->macrobuf) );
X	if (hglobal) {
X		GlobalUnlock(hglobal);
X		GlobalFree(hglobal);
X	}
X	if (lpmw->szPrompt != (char *)NULL)
X		LocalFreePtr((void NEAR *)OFFSETOF(lpmw->szPrompt));
X	if (lpmw->szAnswer != (char *)NULL)
X		LocalFreePtr((void NEAR *)OFFSETOF(lpmw->szAnswer));
X}
X
X
X/***********************************************************************/
X/* InputBoxDlgProc() -  Message handling routine for Input dialog box         */
X/***********************************************************************/
X
XBOOL CALLBACK _export
XInputBoxDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
X{
XLPTW lptw;
XLPMW lpmw;
X    lptw = (LPTW)GetWindowLong(GetParent(hDlg), 0);
X    lpmw = lptw->lpmw;
X
X    switch( message) {
X        case WM_INITDIALOG:
X            SetDlgItemText( hDlg, ID_PROMPT, lpmw->szPrompt);
X            return( TRUE);
X
X        case WM_COMMAND:
X            switch(LOWORD(wParam)) {
X                case ID_ANSWER:
X                    return( TRUE);
X
X                case IDOK:
X                    lpmw->nChar = GetDlgItemText( hDlg, ID_ANSWER, lpmw->szAnswer, MAXSTR);
X                    EndDialog( hDlg, TRUE);
X                    return( TRUE);
X
X                case IDCANCEL:
X                    lpmw->szAnswer[0] = NULL;
X                    EndDialog( hDlg, FALSE);
X                    return( TRUE);
X
X                default:
X                    return( FALSE);
X                }
X        default:
X            return( FALSE);
X        }
X    }
X
X
XLRESULT CALLBACK _export
XMenuButtonProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
X{
XLPTW lptw;
XLPMW lpmw;
X#ifdef WIN32
XLONG n = GetWindowLong(hwnd, GWL_ID);
X#else
XWORD n = GetWindowWord(hwnd, GWW_ID);
X#endif
X	lptw = (LPTW)GetWindowLong(GetParent(hwnd), 0);
X	lpmw = lptw->lpmw;
X
X	switch(message) {
X		case WM_LBUTTONUP:
X			{
X			RECT rect;
X			POINT pt;
X			GetWindowRect(hwnd, &rect);
X			GetCursorPos(&pt);
X			if (PtInRect(&rect, pt))
X				SendMessage(lptw->hWndText, WM_COMMAND, lpmw->hButtonID[n], 0L);
X			SetFocus(lptw->hWndText);
X			}
X			break;
X	}
X	return CallWindowProc((lpmw->lpfnButtonProc[n]), hwnd, message, wParam, lParam);
X}
END_OF_FILE
  if test 18486 -ne `wc -c <'gnuplot/win/wmenu.c'`; then
    echo shar: \"'gnuplot/win/wmenu.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wmenu.c'
fi
echo shar: End of archive 19 \(of 33\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
