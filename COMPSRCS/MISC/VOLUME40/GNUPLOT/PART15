Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i027:  gnuplot - interactive function plotting utility, Part15/33
Message-ID: <1993Oct22.163506.23965@sparky.sterling.com>
X-Md4-Signature: 5db1ac65167533ce5763e82cb8f46637
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:35:06 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 27
Archive-name: gnuplot/part15
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/prob2.dem gnuplot/docs/gpcard.tex
#   gnuplot/term/pc.trm
# Wrapped by kent@sparky on Wed Oct 20 17:14:50 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 15 (of 33)."'
if test -f 'gnuplot/demo/prob2.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/prob2.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/prob2.dem'\" \(10444 characters\)
  sed "s/^X//" >'gnuplot/demo/prob2.dem' <<'END_OF_FILE'
X#
X# $Id: prob2.demo 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X# Demo Statistical Approximations version 1.1
X#
X# Permission granted to distribute freely for non-commercial purposes only
X#
X# Copyright (c) 1991, Jos van der Woude, jvdwoude@hut.nl
X
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 "                        Statistical Approximations, version 1.1"
Xpause  0 ""
Xpause  0 "        Copyright (c) 1991, 1992, Jos van de Woude, jvdwoude@hut.nl"
Xpause  0 ""
Xpause  0 ""
Xpause  0 " Permission granted to distribute freely for non-commercial purposes only"
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 ""
Xpause  0 "     NOTE: contains 10 plots and consequently takes some time to run"
Xpause  0 "                      Press Ctrl-C to exit right now"
Xpause  0 ""
Xpause -1 "                      Press Return to start demo ..."
Xsave set "defaults.ini"
X
Xload "stat.inc"
X
X# Binomial PDF using normal approximation
Xn = 25; p = 0.15
Xmu = n * p
Xsigma = sqrt(n * p * (1.0 - p))
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xymax = 1.1 * binom(mu) #mode of binomial PDF used
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil(sigma), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "binomial PDF using normal approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot binom(x), normal(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Binomial PDF using poisson approximation
Xn = 50; p = 0.1
Xmu = n * p
Xsigma = sqrt(mu)
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xymax = 1.1 * binom(mu) #mode of binomial PDF used
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil(sigma), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "binomial PDF using poisson approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot binom(x), poisson(x)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Geometric PDF using gamma approximation
Xp = 0.3
Xmu = (1.0 - p) / p
Xsigma = sqrt(mu / p)
Xlambda = p
Xrho = 1.0 - p
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * p
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil((xmax - xmin)/ 10.0), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "geometric PDF using gamma approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, g(mu) nohead
Xset arrow from mu + 0.5, g(mu + sigma) \
X          to mu + 0.5 + sigma, g(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, g(mu + sigma)
Xplot geometric(x), g(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Geometric PDF using normal approximation
Xp = 0.3
Xmu = (1.0 - p) / p
Xsigma = sqrt(mu / p)
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * p
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil((xmax - xmin)/ 10.0), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "geometric PDF using normal approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot geometric(x), normal(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Hypergeometric PDF using binomial approximation
Xnn = 75; mm = 25; n = 10
Xp = real(mm) / nn
Xmu = n * p
Xsigma = sqrt(real(nn - n) / (nn - 1.0) * n * p * (1.0 - p))
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * hypgeo(mu) #mode of binom PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k ->"
Xset ylabel "probability density ->"
Xset xtics xmin, xinc, xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "hypergeometric PDF using binomial approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, binom(mu) nohead
Xset arrow from mu + 0.5, binom(mu + sigma) \
X          to mu + 0.5 + sigma, binom(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, binom(mu + sigma)
Xplot hypgeo(x), binom(x)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Hypergeometric PDF using normal approximation
Xnn = 75; mm = 25; n = 10
Xp = real(mm) / nn
Xmu = n * p
Xsigma = sqrt(real(nn - n) / (nn - 1.0) * n * p * (1.0 - p))
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * hypgeo(mu) #mode of binom PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin, xinc, xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "hypergeometric PDF using normal approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot hypgeo(x), normal(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Negative binomial PDF using gamma approximation
Xr = 8; p = 0.6
Xmu = r * (1.0 - p) / p
Xsigma = sqrt(mu / p)
Xlambda = p
Xrho = r * (1.0 - p)
Xxmin = int(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = int(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * g((rho - 1) / lambda) #mode of gamma PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil((xmax - xmin)/ 10.0), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "negative binomial PDF using gamma approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, g(mu) nohead
Xset arrow from mu + 0.5, g(mu + sigma) \
X          to mu + 0.5 + sigma, g(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, g(mu + sigma)
Xplot negbin(x), g(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Negative binomial PDF using normal approximation
Xr = 8; p = 0.4
Xmu = r * (1.0 - p) / p
Xsigma = sqrt(mu / p)
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * negbin(mu - 1/p) #mode of gamma PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin + 0.499, ceil((xmax - xmin)/ 10.0), xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "negative binomial PDF using normal approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot negbin(x), normal(x - 0.5)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Normal PDF using logistic approximation
Xmu = 1.0; sigma = 1.5
Xa = mu
Xlambda = pi / (sqrt(3.0) * sigma)
Xxmin = mu - 4.0 * sigma
Xxmax = mu + 4.0 * sigma
Xymax = 1.1 * logistic(mu) #mode of logistic PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin: xmax]
Xset yrange [0 : ymax]
Xset xlabel "x ->"
Xset ylabel "probability density ->"
Xset xtics xmin, (xmax - xmin)/ 10.0, xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%.1f"
Xset format y "%.2f"
Xset sample 200
Xset title "normal PDF using logistic approximation"
Xset arrow from mu,0 to mu, normal(mu) nohead
Xset arrow from mu, normal(mu + sigma) \
X          to mu + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot logistic(x), normal(x)
Xpause -1 "Hit return to continue"
Xset noarrow
Xset nolabel
X
X# Poisson PDF using normal approximation
Xmu = 5.0
Xsigma = sqrt(mu)
Xxmin = floor(mu - 4.0 * sigma)
Xxmin = xmin < 0 ? 0 : xmin
Xxmax = ceil(mu + 4.0 * sigma)
Xxinc = ceil((xmax - xmin) / 10)
Xxinc = xinc > 1 ? xinc : 1
Xymax = 1.1 * poisson(mu) #mode of poisson PDF used
Xset key
Xset nozeroaxis
Xset xrange [xmin - 1 : xmax + 1]
Xset yrange [0 : ymax]
Xset xlabel "k, x ->"
Xset ylabel "probability density ->"
Xset xtics xmin, xinc, xmax
Xset ytics 0, ymax / 10.0, ymax
Xset format x "%2.0f"
Xset format y "%3.2f"
Xset sample 200
Xset title "poisson PDF using normal approximation"
Xset arrow from mu + 0.5, 0 to mu + 0.5, normal(mu) nohead
Xset arrow from mu + 0.5, normal(mu + sigma) \
X          to mu + 0.5 + sigma, normal(mu + sigma) nohead
Xset label "mu" at mu + 1, ymax / 10
Xset label "sigma" at mu + 1 + sigma, normal(mu + sigma)
Xplot poisson(x), normal(x - 0.5)
Xset noarrow
Xset nolabel
X
Xload "defaults.ini"
END_OF_FILE
  if test 10444 -ne `wc -c <'gnuplot/demo/prob2.dem'`; then
    echo shar: \"'gnuplot/demo/prob2.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/prob2.dem'
fi
if test -f 'gnuplot/docs/gpcard.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/gpcard.tex'\"
else
  echo shar: Extracting \"'gnuplot/docs/gpcard.tex'\" \(41221 characters\)
  sed "s/^X//" >'gnuplot/docs/gpcard.tex' <<'END_OF_FILE'
X% Quick Reference Card for GNUPLOT 1992
X% Format stolen shamelessly from the GNU Emacs reference card
X%**start of header
X\special{landscape}
X\newcount\columnsperpage
X
X% This file can be printed with 1, 2, or 3 columns per page (see below).
X% Specify how many you want here.  Nothing else needs to be changed.
X% For GNUPLOT refcard, entries are too wide for 3 columns.  Print
X% 2 columns landscape
X
X\columnsperpage=2
X
X% Copyright (c) 1987 Free Software Foundation, Inc.
X
X% This file is part of GNU Emacs, but was adapted for the GNUPLOT
X% reference card because it was so nicely set up.
X
X% This file is intended to be processed by plain TeX (TeX82).
X%
X% The final reference card has six columns, three on each side.
X% This file can be used to produce it in any of three ways:
X% 1 column per page
X%    produces six separate pages, each of which needs to be reduced to 80%.
X%    This gives the best resolution.
X% 2 columns per page
X%    produces three already-reduced pages.
X%    You will still need to cut and paste.
X% 3 columns per page
X%    produces two pages which must be printed sideways to make a
X%    ready-to-use 8.5 x 11 inch reference card.
X%    For this you need a dvi device driver that can print sideways.
X% Which mode to use is controlled by setting \columnsperpage above.
X%
X% Author of GNU Emacs Refcard:
X%  Stephen Gildea
X%  UUCP: mit-erl!gildea
X%  Internet: gildea@erl.mit.edu
X%
X% Thanks to Paul Rubin, Bob Chassell, Len Tower, and Richard Mlynarik
X% for their many good ideas.
X%
X% Person who ripped off the formatter:
X%  Alex Woo
X%  NASA Ames Research Center
X%  Internet: woo@ames.arc.nasa.gov
X%
X% Modified on 9 Dec 1992 by:
X%  Daniel S. Lewart
X%  University of Illinois
X%  Internet: d-lewart@uiuc.edu
X
X% make \bye not \outer so that the \def\bye in the \else clause below
X% can be scanned without complaint.
X\def\bye{\par\vfill\supereject\end}
X
X\def\copyrightnotice{
X\vskip 1ex plus 2 fill\begingroup\small
XLayout adapted from the \TeX\ source for Stephen Gildea's GNU Emacs
XReference Card (version 1.8).
X
XPostScript is a registered trademark of Adobe Systems Incorporated.
XGNU, Versatec, Imagen, Printronix, Canon, GraphOn, Visual, MicroVAX,
XUIS, Tektronix, Unix, VAX, VMS, NeWS, SunView, and em4010 are all
Xtrademarks of various companies.  We endorse none of them.
X
X\endgroup}
X
X\newdimen\intercolumnskip
X\newbox\columna
X\newbox\columnb
X
X\def\ncolumns{\the\columnsperpage}
X
X\message{[\ncolumns\space
X  column\if 1\ncolumns\else s\fi\space per page]}
X
X\def\scaledmag#1{ scaled \magstep #1}
X
X% This multi-way format was designed by Stephen Gildea
X% October 1986.
X% modified for GNUPLOT refcard by Alex Woo
X
X\if 1\ncolumns
X%  \hsize 4in
X  \hsize 6in
X  \vsize 10in
X  \voffset -.7in
X  \font\titlefont=\fontname\tenbf \scaledmag3
X  \font\headingfont=\fontname\tenbf \scaledmag2
X  \font\smallfont=\fontname\sevenrm
X  \font\smallsy=\fontname\sevensy
X
X  \footline{\hss\folio}
X  \def\makefootline{\baselineskip10pt\hsize6.5in\line{\the\footline}}
X\else
X%  \hsize 3.2in
X  \hsize 5in
X  \vsize 7.95in
X  \hoffset -.75in
X  \voffset -.745in
X  \font\titlefont=cmbx10 \scaledmag2
X  \font\headingfont=cmbx10 \scaledmag1
X  \font\smallfont=cmr6
X  \font\smallsy=cmsy6
X  \font\eightrm=cmr8
X  \font\eightbf=cmbx8
X  \font\eightit=cmti8
X  \font\eighttt=cmtt8
X  \font\eightsy=cmsy8
X  \textfont0=\eightrm
X  \textfont2=\eightsy
X  \def\rm{\eightrm}
X  \def\bf{\eightbf}
X  \def\it{\eightit}
X  \def\tt{\eighttt}
X  \normalbaselineskip=.8\normalbaselineskip
X  \normallineskip=.8\normallineskip
X  \normallineskiplimit=.8\normallineskiplimit
X  \normalbaselines\rm           %make definitions take effect
X
X  \if 2\ncolumns
X    \let\maxcolumn=b
X    \footline{\hss\rm\folio\hss}
X    \def\makefootline{\vskip 2in \hsize=6.86in\line{\the\footline}}
X  \else \if 3\ncolumns
X    \let\maxcolumn=c
X    \nopagenumbers
X  \else
X    \errhelp{You must set \columnsperpage equal to 1, 2, or 3.}
X    \errmessage{Illegal number of columns per page}
X  \fi\fi
X
X  \intercolumnskip=.46in
X  \def\abc{a}
X  \output={%
X      % This next line is useful when designing the layout.
X      %\immediate\write16{Column \folio\abc\space starts with \firstmark}
X      \if \maxcolumn\abc \multicolumnformat \global\def\abc{a}
X      \else\if a\abc
X        \global\setbox\columna\columnbox \global\def\abc{b}
X        %% in case we never use \columnb (two-column mode)
X        \global\setbox\columnb\hbox to -\intercolumnskip{}
X      \else
X        \global\setbox\columnb\columnbox \global\def\abc{c}\fi\fi}
X  \def\multicolumnformat{\shipout\vbox{\makeheadline
X      \hbox{\box\columna\hskip\intercolumnskip
X        \box\columnb\hskip\intercolumnskip\columnbox}
X      \makefootline}\advancepageno}
X  \def\columnbox{\leftline{\pagebody}}
X
X  \def\bye{\par\vfill\supereject
X    \if a\abc \else\null\vfill\eject\fi
X    \if a\abc \else\null\vfill\eject\fi
X    \end}
X\fi
X
X% we won't be using math mode much, so redefine some of the characters
X% we might want to talk about
X\catcode`\^=12
X\catcode`\_=12
X
X\chardef\\=`\\
X\chardef\{=`\{
X\chardef\}=`\}
X
X\hyphenation{mini-buf-fer}
X
X\parindent 0pt
X\parskip 1ex plus .5ex minus .5ex
X
X\def\small{\smallfont\textfont2=\smallsy\baselineskip=.8\baselineskip}
X
X\outer\def\newcolumn{\vfill\eject}
X
X\outer\def\title#1{{\titlefont\centerline{#1}}\vskip 1ex plus .5ex}
X
X\outer\def\section#1{\par\filbreak
X  \vskip 3ex plus 2ex minus 2ex {\headingfont #1}\mark{#1}%
X  \vskip 2ex plus 1ex minus 1.5ex}
X
X\newdimen\keyindent
X
X\def\beginindentedkeys{\keyindent=1em}
X\def\endindentedkeys{\keyindent=0em}
X\endindentedkeys
X
X\def\paralign{\vskip\parskip\halign}
X
X\def\<#1>{$\langle${\rm #1}$\rangle$}
X
X\def\kbd#1{{\tt#1}\null}        %\null so not an abbrev even if period follows
X
X\def\beginexample{\par\leavevmode\begingroup
X  \obeylines\obeyspaces\parskip0pt\tt}
X{\obeyspaces\global\let =\ }
X\def\endexample{\endgroup}
X
X
X\def\key#1#2{\leavevmode\hbox to \hsize{\vtop
X%  {\hsize=.75\hsize\rightskip=1em
X  {\hsize=.5\hsize\rightskip=1em
X  \hskip\keyindent\relax#1}\kbd{#2}\hfil}}
X
X\newbox\metaxbox
X\setbox\metaxbox\hbox{\kbd{M-x }}
X\newdimen\metaxwidth
X\metaxwidth=\wd\metaxbox
X
X\def\metax#1#2{\leavevmode\hbox to \hsize{\hbox to .75\hsize
X  {\hskip\keyindent\relax#1\hfil}%
X  \hskip -\metaxwidth minus 1fil
X  \kbd{#2}\hfil}}
X
X\def\threecol#1#2#3{\hskip\keyindent\relax#1\hfil&\kbd{#2}\quad
X  &\kbd{#3}\quad\cr}
X
X%**end of header
X
X
X\title{GNUPLOT Quick Reference}
X
X\centerline{(Copyright(c) Alex Woo 1992 June 1)}
X
X\section{Starting GNUPLOT}
X
X\key{to enter GNUPLOT}{gnuplot}
X\key{to enter batch GNUPLOT}{gnuplot macro_file}
X\key{to pipe commands to GNUPLOT}{application | gnuplot}
X
Xsee below for  environment variables you might want to change
Xbefore entering GNUPLOT.
X
X\section{Exiting GNUPLOT}
X
X\key{exit GNUPLOT}{quit}
X
XAll GNUPLOT commands can be abbreviated to the first few
Xunique letters, usually three characters.  This reference uses
Xthe complete name for clarity.
X
X\section{Getting Help}
X
X\key{introductory help} {help plot}
X\key{help on a topic}{help <topic>}
X\key{list of all help available}{help or ?}
X\key{show current environment}{show all}
X\section{Command-line Editing}
X
XThe UNIX, MS-DOS and VMS versions of GNUPLOT support command-line
Xediting and a command history.  EMACS style editing is supported.
X
X\beginindentedkeys
X
XLine Editing:
X
X\key{move back a single character}{^ B}
X\key{move forward a single character}{^ F}
X\key{moves to the beginning of the line}{^ A}
X\key{moves to the end of the line}{^ E}
X\key{delete the previous character} {^ H and DEL }
X\key{deletes the current character}  {^ D}
X\key{deletes to the end of line}{^ K}
X\key{redraws line in case it gets trashed}{ ^ L,^ R}
X\key{deletes the entire line}{ ^ U}
X\key{deletes the last word}{ ^ W}
X\endindentedkeys
X\beginindentedkeys
X
XHistory:
X
X\key{moves back through history}{ ^ P }
X\key{moves forward through history}{ ^ N }
X\endindentedkeys
X
XThe following arrow keys may be used on the MS-DOS version if READLINE is
Xused.
X
X\beginindentedkeys
XIBM PC Arrow Keys:
X
X\key{Left  Arrow}{same as ^ B}
X\key{Right Arrow}{same as ^ F}
X\key{Ctrl Left  Arrow}{same as ^ A}
X\key{Ctrl Right Arrow}{same as ^ E}
X\key{Up    Arrow}{same as ^ P}
X\key{Down  Arrow}{same as ^ N}
X\endindentedkeys
X
X
X
X\section{Graphics Devices}
X
XAll screen graphics devices are specified by names and options.
XThis information can be read from a startup file (.gnuplot in UNIX).
XIf  you change the graphics device, you must replot with the
X\kbd{replot} command.
X
X\key{get a list of valid devices }{set terminal [options]}
X
X\beginindentedkeys
X
XGraphics Terminals:
X
X\key{AED 512 Terminal}                          {set term aed512}
X\key{AED 767 Terminal}                          {set term aed767}
X\key{Amiga}                                     {set term amiga}
X\key{Adobe Illustrator 3.0 Format}              {set term aifm}
X\key{Apollo graphics primitive, rescalable}     {set term apollo}
X\key{Atari ST}                                  {set term atari}
X\key{BBN Bitgraph Terminal}                     {set term bitgraph}
X\key{SCO CGI Driver}                            {set term cgi}
X\key{Apollo graphics primitive, fixed window}   {set term gpr}
X\key{SGI GL windown}                            {set term iris4d [8 24]}
X\key{MS-DOS Kermit Tek4010 term - color}        {set term kc_tek40xx}
X\key{MS-DOS Kermit Tek4010 term - mono}         {set term km_tek40xx}
X\key{NeXTstep window system}                    {set term next}
X\key{REGIS graphics language}                   {set term regis}
X\key{Selanar Tek Terminal}                      {set term selanar}
X\key{SunView window system}                     {set term sun}
X\key{Tektronix 4106, 4107, 4109 \& 420X }       {set term tek4OD10x}
X\key{Tektronix 4010; most TEK emulators}        {set term tek40xx}
X\key{VAX UIS window system}                     {set term VMS}
X\key{VT-like tek40xx terminal emulator}         {set term vttek}
X\key{UNIX plotting (not always supplied)}       {set term unixplot}
X\key{AT\&T 3b1 or 7300 UNIXPC}                  {set term unixpc}
X\key{X11 default display device}                {set term x11}
X\key{X11 multicolor point default device}       {set term X11}
X
X\endindentedkeys
X
X\beginindentedkeys
X
XTurbo C PC Graphics Modes:
X
X\key{Hercules}{set term hercules}
X\key{Color Graphics Adaptor}{set term cga}
X\key{Monochrome CGA}{set term mcga}
X\key{Extended Graphics Adaptor}{set term ega}
X\key{VGA} {set term vga}
X\key{Monochrome VGA} {set term vgamono}
X\key{Super VGA - requires SVGA driver}{set term svga}
X\key{AT\&T 6300 Micro}{set term att}
X
X\endindentedkeys
X
XMS Windows 3.x and OS/2 Presentation Manager are also supported.
X
X\beginindentedkeys
X
XHardcopy Devices:
X
X\key{Unknown - not a plotting device} {set term unknown}
X\key{Dump ASCII table of X Y [Z] values}{set term table}
X\key{printer or glass dumb terminal}                    {set term dumb}
X\key{Roland DXY800A plotter}                            {set term dxy800a}
X
XDot Matrix Printers
X
X\key{Epson-style 60-dot per inch printers}              {set term epson_60dpi}
X\key{Epson LX-800, Star NL-10 }{set term epson_lx800}
X\key{NX-1000, PROPRINTER }{set term epson_lx800}
X\key{NEC printer CP6, Epson LQ-800 }
X                        {set term nec_cp6 [monochrome color draft]}
X\key{Star Color Printer}                                {set term starc}
X\key{Tandy DMP-130  60-dot per inch }   {set term tandy_60dpi}
X\key{Vectrix 384 \& Tandy color printer}                {set term vx384}
X
XLaser Printers
X
X\key{Talaris EXCL language}{set term excl}
X\key{Imagen laser printer}                              {set term imagen}
X\key{LN03-Plus in EGM mode}                     {set term ln03}
X\key{PostScript graphics language }
X                {set term post [mode color `font' size]}
X\key{CorelDraw EPS}
X                {set term corel [mode color `font' size]}
X\key{Prescribe - for the Kyocera Laser Printer} {set term prescribe}
X\key{Kyocera Laser Printer with Courier font}           {set term kyo}
X\key{QMS/QUIC Laser  (also Talaris 1200 )}{set term qms}
X
XMetafiles
X
X\key{AutoCAD DXF (120x80 default)}                      {set term dxf}
X\key{FIG graphics language: SunView or X }{set term fig}
X\key{FIG graphics language:  Large Graph}{set term bfig}
X\key{SCO hardcopy CGI}{set term hcgi}
X\key{Frame Maker MIF 3.0}
X                {set term mif [pentype curvetype help]}
X\key{Portable bitmap}                                   {set term pbm [fontsize color]}
X\key{Uniplex Redwood Graphics Interface Protocol}{set term rgip}
X\key{TGIF language}                             {set term tgif}
X
XHP Devices
X
X\key{HP2623A and maybe others}                  {set term hp2623A}
X\key{HP2648 and HP2647}                         {set term hp2648}
X\key{HP7580, \& probably other HPs (4 pens)}            {set term hp7580B}
X\key{HP7475 \&  lots of others (6 pens)}        {set term hpgl}
X\key{HP Laserjet series II \& clones}   {set term hpljii [75 100 150 300]}
X\key{HP DeskJet 500} {set term hpdj [75 100 150 300]}
X\key{HP PaintJet \& HP3630 }
X                                {set term hppj [FNT5X9 FNT9X17 FNT13x25]}
X\key{HP laserjet III ( HPGL plot vectors)}
X                {set term pcl5 [mode font fontsize ]}
X
XTeX picture environments
X
X\key{LaTeX picture environment}                 {set term latex}
X\key{EEPIC -- extended LaTeX picture }  {set term eepic}
X\key{LaTeX picture  with emTeX specials}        {set term emtex}
X\key{PSTricks macros for TeX or LaTeX}  {set term pstricks}
X\key{TPIC specials for TeX or LaTeX}    {set term tpic}
X\key{MetaFont font generation input}                    {set term mf}
X
X
X\endindentedkeys
X
X\section{Files}
X
X\key{{\bf plot} a data file}{plot `fspec'}
X\key{{\bf load} in a macro file}{load `fspec'}
X\key{{\bf save} command buffer to a macro file}{save `fspec'}
X\key{{\bf save settings} for later reuse}{save set `fpec'}
X
X\section{PLOT \& SPLOT commands}
X
X
X{\bf plot} and {\bf splot} are the primary commands
X{\bf plot} is used to plot 2-d
Xfunctions and data, while {\bf splot} plots 3-d surfaces and data.
X
XSyntax:
X
X        plot $\{$ranges$\}$ $<$function$> \{$title$\} \{$style$\}$
X                    $\{, <$function$> \{$title$\} \{$style$\}...\}$
X
X        splot $\{$ranges$\} <$function$> \{$title$\} \{$style$\}$
X                    $\{, <$function$> \{$title$\} \{$style$\}...\}$
X
Xwhere $<$function$>$ is either a mathematical expression, the name of a
Xdata file enclosed in quotes, or a pair ({\bf plot}) or triple ({\bf splot})
Xof mathematical expressions in the case of parametric functions.
XUser-defined functions and variables may also be defined here.
XExamples will be given below.
X
X\section{Plotting Data}
XDiscrete data contained in a file can displayed by specifying the
Xname of the data file (enclosed in quotes) on the {\bf plot} or {\bf splot}
Xcommand line. Data files should contain one data point per line.
XLines beginning with \# (or ! on VMS) will be treated as comments
Xand ignored. For {\bf plot}s, each data point represents an (x,y)
Xpair. For {\bf splot}s, each point is an (x,y,z) triple. For {\bf plot}s with
Xerror bars (see {\bf plot errorbars}), each data point is either
X(x,y,ydelta) or (x,y,ylow,yhigh). In all cases, the numbers on each
Xline of a data file must be separated by blank space. This blank
Xspace divides each line into columns.
X
XFor {\bf plot}s the x value may be omitted, and for {\bf splot}s the x
Xand y values may be omitted. In either case the omitted values are
Xassigned the current coordinate number. Coordinate numbers start at 0
Xand are incremented for each data point read.
X
X\section{Surface Plotting}
XImplicitly, there are two types of 3-d datafiles. If all the isolines
Xare of the same length, the data is assumed to be a grid data, i.e.,
Xthe data has a grid topology. Cross isolines in the other parametric
Xdirection (the ith cross isoline passes thru the ith point of all the
Xprovided isolines) will also be drawn for grid data. (Note contouring
Xis available for grid data only.) If all the isolines are not of the
Xsame length, no cross isolines will be drawn and contouring that data
Xis impossible.
X
XFor splot if 3-d datafile and using format (see {\bf splot datafile using})
Xspecify only z (height field), a non parametric mode must be specified.
XIf, on the other hand, x, y, and z are all specified, a parametric
Xmode should be selected (see {\bf set parametric}) since data is defining a
Xparametric surface.
X
X\key{example of plotting a 3-d data}{set parametric;splot 'glass.dat'}
X\key{example of plotting explicit}{set noparametric;splot 'datafile.dat'}
X
X\section{Using Pipes}
X
XOn some computer systems with a popen function (UNIX), the datafile
Xcan be piped through a shell command by starting the file name
Xwith a '$<$'.  For example:
X
X        pop(x) = 103*exp(x/10)
X        plot "$<$ awk '$\{$ print \$1-1965 \$2 $\}$' population.dat", pop(x)
X
Xwould plot the same information as the first population example
Xbut with years since 1965 as the x axis.
X
XSimilarly, output can be piped to another application, e.g.
X
X        set out "$|$lpr -Pmy\_laser\_printer"
X
X\section{Plot Data Using}
XThe format of data within a file can be selected with the {\bf using}
Xoption. An explicit scanf string can be used, or simpler column
Xchoices can be made.
X
X\key{plot "datafile"}{ $\{$ using $\{ <$ycol$> |$}
X\key{}{$<$xcol$>:<$ycol$> |$}
X\key{}{$<$xcol$>:<$ycol$>:<$ydelta$> |$}
X\key{}{$<$xcol$>:<$ycol$>:<$ylow$>:<$yhigh$> \}$}
X\key{}{$\{$"<scanf string>"$\} \} ...$}
X
X\key{splot "datafile"}
X{$\{$ using $\{ <$xcol$>:<$ycol$>:<$zcol$> \}$}
X\key{}{$\{"<$scanf string$>"\} \} ...$}
X
X$<$xcol$>$, $<$ycol$>$, and $<$zcol$>$ explicitly select the columns to plot from
Xa space or tab separated multicolumn data file. If only $<$ycol$>$ is
Xselected for {\bf plot}, $<$xcol$>$ defaults to 1. If only $<$zcol$>$ is selected
Xfor {\bf splot}, then only that column is read from the file. An $<$xcol$>$ of
X0 forces $<$ycol$>$ to be plotted versus its coordinate number. $<$xcol$>$,
X$<$ycol$>$, and $<$zcol$>$ can be entered as constants or expressions.
X
XIf errorbars (see also {\bf plot errorbars}) are used for {\bf plot}s,
Xydelta (for example, a +/- error) should be provided as the third
Xcolumn, or ylow and yhigh as third and fourth columns.  These columns
Xmust follow the x and y columns.
X
XScanf strings override any $<$xcol$>$:$<$ycol$>$(:$<$zcol$>$) choices, except for
Xordering of input, e.g.,
X
X\key{plot "datafile"}{ using 2:1 "\%f\%*f\%f"}
X
Xcauses the first column to be y and the third column to be x.
X
XIf the scanf string is omitted, the default is generated based on the
X$<$xcol$>$:$<$ycol$>$(:$<$zcol$>$) choices. If the {\bf using} option is omitted, ''\%f\%f''
Xis used for {\bf plot} (''\%f\%f\%f\%f'' for {\bf errorbar} {\bf plot}s) and ''\%f\%f\%f'' is
Xused for {\bf splot}.
X
X\key{plot "MyData"} {using "\%*f\%f\%*20[^$\backslash$n]\%f" w lines}
X
XData are read from the file ``MyData'' using the format
X''\%*f\%f\%*20[^$\backslash$n]\%f''. The meaning of this format is: ''\%*f'' ignore the
Xfirst number, ''\%f'' then read in the second and assign to x,
X''\%*20[^$\backslash$n]'' then ignore 20 non-newline characters, ''\%f'' then read in
Xthe y value.
X
X\section{Plot With Errorbars}
XError bars are supported for 2-d data file plots by reading one or
Xtwo additional columns specifying ydelta or ylow and yhigh
Xrespectively. No support exists for x error bars or any error bars
Xfor {\bf splot}s.
X
XIn the default situation, GNUPLOT expects to see three or four
Xnumbers on each line of the data file, either (x, y, ydelta) or
X(x, y, ylow, yhigh). The x coordinate must be specified. The order
Xof the numbers must be exactly as given above. Data files in this
Xformat can easily be plotted with error bars:
X
X        plot "data.dat" with errorbars
X
XThe error bar is a vertical line plotted from (x, ylow) to (x,
Xyhigh). If ydelta is specified instead of ylow and yhigh,
Xylow=y-ydelta and yhigh=y+ydelta are derived. If there
Xare only two numbers on the line, yhigh and ylow are both set to
Xy. To get lines plotted between the data points, {\bf plot} the
Xdata file twice, once with errorbars and once with lines.
X
XIf y autoscaling is on, the y range will be adjusted to fit the
Xerror bars.
X
X\key{x,y,ylow \& yhigh from columns 1,2,3,4}{plot "data.dat" us 1:2:3:4 w errorbars}
X\key{x from third, y from second, ydelta from 6}{plot "data.dat" using 3:2:6 with errorbars}
X
X\section{Plot Ranges}
XThe optional range specifies the region of the plot that will be
Xdisplayed.
X
XRanges may be provided on the {\bf plot} and {\bf splot} command line and
Xaffect only that plot, or in the {\bf set xrange}, {\bf set yrange}, etc.,
Xcommands, to change the default ranges for future plots.
X
X\key{[$\{<$dummy-var$> =\} \{<$xmin$> : <$xmax$>\}$]} { $\{$ [$\{<$ymin$> : <$ymax$>\}$] $\}$}
X
Xwhere $<$dummy-var$>$ is the independent variable (the defaults are x and
Xy, but this may be changed with {\bf set dummy}) and the min and max
Xterms can be constant expressions.
X
XBoth the min and max terms are optional. The ':' is also optional
Xif neither a min nor a max term is specified. This allows '[ ]' to
Xbe used as a null range specification.
X
XSpecifying a range in the {\bf plot} command line turns autoscaling for
Xthat axis off for that plot. Using one of the {\bf set} range commands
Xturns autoscaling off for that axis for future plots, unless changed
Xlater. (See {\bf set autoscale}).
X
X\key{This uses the current ranges}{plot cos(x)}
X\key{This sets the x range only}{plot [-10:30] sin(pi*x)/(pi*x)}
X\key{This sets both the x and y ranges}{plot [-pi:pi] [-3:3]  tan(x), 1/x}
X\key{sets only y range, \&} {plot [ ] [-2:sin(5)*-8] sin(x)**besj0(x)}
X\key{turns off autoscaling on both axes}{}
X\key{This sets xmax and ymin only}{plot [:200] [-pi:]  exp(sin(x))}
X\key{This sets the x, y, and z ranges}{splot [0:3] [1:4] [-1:1] x*y}
X
X\section{Plot With Style}
XPlots may be displayed in one of six styles: {\bf lines}, {\bf points},
X{\bf linespoints}, {\bf impulses}, {\bf dots}, {\bf steps},
Xor {\bf errorbars}. The {\bf lines} style
Xconnects adjacent points with lines. The {\bf points} style displays a
Xsmall symbol at each point. The {\bf linespoints} style does both
X{\bf lines} and {\bf points}. The {\bf impulses} style displays a vertical line
Xfrom the x axis (or from the grid base for {\bf splot}) to each point. The
X{\bf dots} style plots a tiny dot at each point; this is useful for
Xscatter plots with many points.
X
XThe {\bf errorbars} style is only relevant to 2-d data file plotting. It
Xis treated like {\bf points} for {\bf splot}s and function {\bf plot}s. For data
X{\bf plot}s, {\bf errorbars} is like {\bf points}, except that a vertical error
Xbar is also drawn: for each point (x,y), a line is drawn from
X(x,ylow) to (x,yhigh). A tic mark is placed at the ends of the error
Xbar. The ylow and yhigh values are read from the data file's columns,
Xas specified with the {\bf using} option to plot. See {\bf plot errorbars} for
Xmore information.
X
XDefault styles are chosen with the {\bf set function style} and
X{\bf set data style} commands.
X
XBy default, each function and data file will use a different
Xline type and point type, up to the maximum number of available
Xtypes. All terminal drivers support at least six different point
Xtypes, and re-use them, in order, if more than six are required.
XThe LaTeX driver supplies an additional six point types (all variants
Xof a circle), and thus will only repeat after twelve curves are
Xplotted with points.
X
XIf desired, the style and (optionally) the line type and point type
Xused for a curve can be specified.
X
X\key{with $<$style$>$}{$ \{<$linetype$> \{<$pointtype$>\}\}$}
X
Xwhere $<$style$>$ is either {\bf lines}, {\bf points}, {\bf linespoints}, {\bf impulses},
X{\bf dots}, {\bf steps}, or {\bf errorbars}.
XThe $<$linetype$>$ \& $<$pointtype$>$ are positive
Xinteger constants or expressions and specify the line type and point
Xtype to be used for the plot. Line type 1 is the first line type used
Xby default, line type 2 is the second line type used by default, etc.
X
X\key{plots sin(x) with impulses}{plot sin(x) with impulses}
X\key{plots x*y with points, x**2 + y**2 default}{splot x*y w points, x**2 + y**2}
X\key{plots tan(x) with default function style}
X        {plot [ ] [-2:5] tan(x)}
X\key{plots ``data.1'' with lines}{plot "data.1" with l}
X\key{plots ``leastsq.dat'' with impulses} {plot 'leastsq.dat' w i}
X\key{plots ``exper.dat'' with errorbars \& }
X{plot 'exper.dat' w l, 'exper.dat' w err}
X\key{ lines connecting points}{}
X
XHere 'exper.dat' should have three or four data columns.
X
X\key{plots x**2 + y**2 and x**2 - y**2 with the same line type}
X{splot x**2 + y**2 w l 1, x**2 - y**2 w l 1}
X\key{plots sin(x) and cos(x) with linespoints, using}
X    {plot sin(x) w linesp 1 3, \\}
X\key{ the same line type but different point types}{ cos(x) w linesp 1 4}
X\key{plots file ``data'' with points style 3}
X{plot "data" with points 1 3}
X
XNote that the line style must be specified when specifying the point
Xstyle, even when it is irrelevant. Here the line style is 1 and the
Xpoint style is 3, and the line style is irrelevant.
X
XSee {\bf set style} to change the default styles.
X
X\section{Plot Title}
X
XA title of each plot appears in the key. By default the title is
Xthe function or file name as it appears on the plot command line.
XThe title can be changed by using the {\bf title} option. This option
Xshould precede any {\bf with} option.
X
X\key{        title "$<$title$>$"}{}
X
Xwhere $<$title$>$ is the new title of the plot and must be enclosed in
Xquotes. The quotes will not be shown in the key.
X
X\key{plots y=x with the title 'x'} {plot x}
X\key{plots the ``glass.dat'' file}
X{splot "glass.dat" tit 'revolution surface'}
X\key{with the title 'revolution surface'}{}
X\key{plots x squared with title ``x^2'' and ``data.1''}
X    {plot x**2 t "x^2", \\}
X\key{ with title 'measured data'}{ "data.1" t 'measured data'}
X
X\section{Set-Show Commands}
X
X\beginindentedkeys
X\key{all commands below begin with set}{set}
X\key{set mapping of polar angles}{angles [degrees|radians]}
X\key{arrows from point to}{arrow [<tag>][from <sx>,<sy>,<sz>]}
X\key{}{ [to <ex>,<ey>,<ez>][nohead]}
X\key{force autoscaling of an axis}{autoscale [<axes>]}
X\key{enter/exit parametric mode} {[no]parametric}
X\key{display border}{[no]border}
X\key{clip points/line near boundaries}{[no]clip <clip-type>}
X\key{specify parameters for contour plots}{cntrparam
X[spline][points][order][levels]}
X\key{enable splot contour plots}{[no]contour [base|surface|both]}
X\key{default plotting style for data}{data style <style-choice>}
X\key{specify dummy variable}{dummy <dummy1>,<dummy2>...}
X\key{tic-mark label format specification}{format
X[<axes>]["format-string"]}
X\key{function plotting style}{function style <style-choice>}
X\key{draw a grid at tick marks}{[no]grid}
X\key{enables hiddenline removal}{[no]hidden3d}
X\key{specify number of isolines}{isosamples <expression>}
X\key{enables key of curves in plot}{key <x>,<y>,<z>}
X\key{logscaling of an axes (optionally giving base)}{logscale <axes> [<base>]}
X\key{mapping 3D coordinates}{mapping
X[cartesian|spherical|cylindrical]}
X\key{offsets from center of graph}{offsets
X<left>,<right>,<top>,<bottom>}
X\key{mapping 2D coordinates}{[no]polar}
X\key{set radial range}{rrange [<rmin>:<rmax>]}
X\key{set sampling rate of functions}{samples <expression>}
X\key{set scaling factors of plot}{size <xsize>,<ysize>}
X\key{control display of isolines of surface}{[no]surface}
X\key{control graphics device}{terminal <device>}
X\key{change direction of tics}{tics <direction>}
X\key{adjust relative height of vertical axis}{ticslevel <level>}
X\key{turn on time/date stamp}{[no]time}
X\key{set centered plot title}{title "title-text" <xoff>,<yoff>}
X\key{set parametric range}{trange [<tmin>:<tmax>]}
X\key{set surface parametric ranges}{urange or vrange}
X\key{sets the view point for {\bf splot}}{view
X<rot_x>,<rot_z>,<scale>,<scale_z>}
X\key{sets x-axis label}{xlabel "<label>" <xoff>,<yoff>}
X\key{set horizontal range}{xrange [<xmin>:<xmax>]}
X\key{change horizontal tics}{xtics <start>,<incr>,<end>,}
X\key{}{"<label>" <pos> }
X\key{draw x-axis}{[no]xzeroaxis}
X\key{sets y-axis label}{ylabel "<label>" <xoff>,<yoff>}
X\key{set vertical range}{yrange [<ymin>:<ymax>]}
X\key{change vertical tics}{ytics <start>,<incr>,<end>,}
X\key{}{"<label>" <pos> }
X\key{draw y-axis}{[no]yzeroaxis}
X\key{set default threshold for values near 0}{zero <expression>}
X\key{draw axes}{[no]zeroaxis}
X\key{sets z-axis label}{zlabel "<label>" <xoff>,<yoff>}
X\key{set vertical range}{zrange [<zmin>:<zmax>]}
X\key{change vertical tics}{ztics <start>,<incr>,<end>,}
X\key{}{"<label>" <pos> }
X\key{draw z-axis}{[no]zzeroaxis}
X\endindentedkeys
X
X\section{Contour Plots}
XEnable contour drawing for surfaces. This option is available for {\bf splot}
Xonly.
X
XSyntax:
X        set contour $\{$ base $|$ surface $|$ both $\}$
X        set nocontour
X
XIf no option is provided to {\bf set contour}, the default is {\bf base}.
XThe three options specify where to draw the contours: {\bf base} draws
Xthe contours on the grid base where the x/ytics are placed, {\bf surface}
Xdraws the contours on the surfaces themselves, and {\bf both} draws the
Xcontours on both the base and the surface.
X
XSee also {\bf set cntrparam} for the parameters that affect the drawing of
Xcontours.
X
X\section{Contour Parameters}
XSets the different parameters for the contouring plot (see also {\bf contour}).
X
X \key{set cntrparam}{ $\{ \{$ linear $|$ cubicspline $|$ bspline $\} |$}
X\key{}{points $<$n$>$ $|$ }
X\key{}{order $<$n$>$  $|$ }
X\key{}{levels \{ [ auto ] $<$n$>$ $|$ }
X\key{}{discrete $<$z1$>$ $<$z2$>$ ... $|$ }
X\key{}{incr $<$start$>$ $<$increment$>$ [ $<$n$>$ ] $\} \}$ }
X
X\key{5 automatic levels}{set cntrparam levels auto 5}
X\key{3 discrete levels at 10\%, 37\% and 90\%}
X        {set cntrp levels discrete .1 1/exp(1) .9}
X\key{5 incremental levels at 0, .1, .2, .3 and .4}
X        {set cntrparam levels incremental  0 .1 5 }
X\key{sets n = 10 retaining current setting of auto, incr., or discr.}
X        {set cntrparam levels 10 }
X\key{set start = 100 and increment = 50, retaining old n}
X        {set cntrparam levels incremental 100 50}
X
XThis command controls the way contours are plotted. $<$n$>$ should be an
Xintegral constant expression and $<$z1$>$, $<$z2$>$ any constant expressions.
XThe parameters are:
X
X{\bf linear}, {\bf cubicspline}, {\bf bspline} - Controls type of approximation or
Xinterpolation. If {\bf linear}, then the contours are drawn piecewise
Xlinear, as extracted from the surface directly. If {\bf cubicspline}, then
Xpiecewise linear contours are interpolated to form a somewhat smoother
Xcontours, but which may undulate. The third option is the uniform
X{\bf bspline}, which only approximates the piecewise linear data but is
Xguaranteed to be smoother.
X
X{\bf points} - Eventually all drawings are done with piecewise linear
Xstrokes.  This number controls the number of points used to
Xapproximate a curve.  Relevant for {\bf cubicspline} and {\bf bspline} modes
Xonly.
X
X{\bf order}  - Order of the bspline approximation to be used. The bigger this
Xorder is, the smoother the resulting contour.  (Of course, higher order
Xbspline curves will move further away from the original piecewise linear
Xdata.)  This option is relevant for {\bf bspline} mode only. Allowed values are
Xintegers in the range from 2 (linear) to 10.
X
X{\bf levels} - Number of contour levels, 'n'.  Selection of the levels is
Xcontrolled by 'auto' (default), 'discrete', and 'incremental'. For 'auto',
Xif the surface is bounded by zmin and zmax then contours will be
Xgenerated from zmin+dz to zmax-dz in steps of size dz, where
Xdz = (zmax - zmin) / (levels + 1).  For 'discrete', contours will be
Xgenerated at z = z1, z2 ... as specified.  The number of discrete levels
Xis limited to MAX\_DISCRETE\_LEVELS, defined in plot.h to be 30.  If
X'incremental', contours are generated at $<$n$>$ values of z beginning at
X$<$start$>$ and increasing by $<$increment$>$.
X
X\section{Specifying Labels}
XArbitrary labels can be placed on the plot using the {\bf set label}
Xcommand.  If the z coordinate is given on a {\bf plot} it is ignored; if
Xit is missing on a {\bf splot} it is assumed to be 0.
X
X\key{set label $\{<$tag$>\} \{"<$label_text$>"\}$}
X{$\{$at $<$x$>,<$y$>\{,<$z$>\}\}$}
X\key{}{$\{<$justification$>\}$}
X\key{set nolabel $\{<$tag$>\}$}{}
X\key{show label}{}
X
XThe text defaults to '''', and the position to 0,0,0.  The $<$x$>$, $<$y$>$, and
X$<$z$>$ values are in the graph's coordinate system.  The tag is an
Xinteger that is used to identify the label. If no $<$tag$>$ is given, the
Xlowest unused tag value is assigned automatically. The tag can be used
Xto delete or change a specific label. To change any attribute of an
Xexisting label, use the {\bf set label} command with the appropriate tag,
Xand specify the parts of the label to be changed.
X
XBy default, the text is placed flush left against the point x,y,z.
XTo adjust the way the label is positioned with respect to the point
Xx,y,z, add the parameter $<$justification$>$, which may be {\bf left}, {\bf right}
Xor {\bf center}, indicating that the point is to be at the left, right or
Xcenter of the text. Labels outside the plotted boundaries are
Xpermitted but may interfere with axes labels or other text.
X
X\key{label at (1,2) to ``y=x'' }{set label "y=x" at 1,2}
X\key{label ``y=x^2'' w right of the text at (2,3,4), }
X{set label 3 "y=x^2" at 2,3,4 right}
X\key{\& tag the label number 3 }{}
X\key{change preceding label to center justification}{set label 3 center}
X\key{delete label number 2 }{set nolabel 2}
X\key{delete all labels}{set nolabel}
X\key{show all labels (in tag order)}{show label}
X
X(The EEPIC, Imagen, LaTeX, and TPIC drivers allow $\backslash$$\backslash$
Xin a string to specify a newline.)
X
X\section{Miscellaneous Commands}
X
XFor further information on these commands, print out a copy
Xof the GNUPLOT manual.
X
X\key{change working directory}{cd}
X\key{erase current screen or device}{clear}
X\key{exit GNUPLOT}{exit or quit or EOF}
X\key{display text and wait}{pause <time> ["<string>"]}
X\key{print the value of $<$expression$>$}{print <expression>}
X\key{print working directory}{pwd}
X\key{repeat last {\bf plot} or {\bf splot}}{replot}
X\key{spawn an interactive shell}{! (UNIX) or \$ (VMS)}
X
X\section{Environment Variables}
X
XA number of shell environment variables are understood by GNUPLOT.
XNone of these are required, but may be useful.
X
XIf GNUTERM is defined, it is used as the name of the terminal type to
Xbe used. This overrides any terminal type sensed by GNUPLOT on start
Xup, but is itself overridden by the .gnuplot (or equivalent) start-up
Xfile (see {\bf start-up}), and of course by later explicit changes.
X
XOn Unix, AmigaDOS, and MS-DOS, GNUHELP may be defined to be the pathname
Xof the HELP file (gnuplot.gih).
X
XOn VMS, the symbol GNUPLOT\$HELP should be defined as the name of
Xthe help library for GNUPLOT.
X
XOn Unix, HOME is used as the name of a directory to search for
Xa .gnuplot file if none is found in the current directory.
XOn AmigaDOS and MS-DOS, GNUPLOT is used. On VMS, SYS\$LOGIN: is used.
XSee help start-up.
X
XOn Unix, PAGER is used as an output filter for help messages.
X
XOn Unix and AmigaDOS, SHELL is used for the {\bf shell} command. On MS-DOS,
XCOMSPEC is used for the {\bf shell} command.
X
XOn AmigaDOS, GNUFONT is used for the screen font.  For example:
X``setenv GNUFONT sapphire/14''.
X
XOn MS-DOS, if the BGI interface is used, the variable {\bf BGI} is used to point
Xto the full path to the BGI drivers directory. Furthermore SVGA is used to
Xname the Super VGA BGI driver in 800x600 res., and its mode of operation
Xas 'Name.Mode'.
XFor example, if the Super VGA driver is C:$\backslash$TC$\backslash$BGI$\backslash$SVGADRV.BGI and mode 3 is
Xused for 800x600 res., then: 'set BGI=C:$\backslash$TC$\backslash$BGI' and 'set SVGA=SVGADRV.3'.
X
X
X\section{Expressions}
XIn general, any mathematical expression accepted by C, FORTRAN,
XPascal, or BASIC is valid. The precedence of these operators is
Xdetermined by the specifications of the C programming language.
XWhite space (spaces and tabs) is ignored inside expressions.
X
XComplex constants may be expressed as $\{<$real$>,<$imag$>\}$, where
X$<$real$>$ and $<$imag$>$ must be numerical constants.  For example,
X$\{3,2\}$ represents 3 + 2{\bf i} and $\{0,1\}$ represents {\bf i}
Xitself.  The curly braces are explicitly required here.
X\section{Functions}
XThe functions in GNUPLOT are the same as the corresponding functions
Xin the Unix math library, except that all functions accept integer,
Xreal, and complex arguments, unless otherwise noted. The {\bf sgn}
Xfunction is also supported, as in BASIC.
X
X%\begin{center}
X%\begin{tabular}{|ccl|} \hline
X\settabs 5\columns
X\+Function & Arguments & Returns \cr
X\hrule%\hline
X\+ abs(x) & any  &  absolute value of {\tt x}, $|x|$; same type \cr
X\+ abs(x) & complex &  length of {\tt x}, $\sqrt{{\hbox{real}(x)^{2} +
X\hbox{imag}(x)^{2}}}$ \cr
X\+ acos(x) & any  & $\cos^{-1} x$ (inverse cosine) in radians \cr
X\+ arg(x) & complex & the phase of $x$ in radians\cr
X\+ asin(x) & any  & $\sin^{-1} x$ (inverse sin) in radians \cr
X\+ atan(x) & any  & $\tan^{-1} x$ (inverse tangent) in radians \cr
X\+ besj0(x) & radians &  $j_{0}$ Bessel function of $x$ \cr
X\+ besj1(x) & radians & $j_{1}$ Bessel function of $x$ \cr
X\+ besy0(x) & radians & $y_{0}$ Bessel function of $x$ \cr
X\+ besy1(x) & radians & $y_{1}$ Bessel function of $x$ \cr
X\+ ceil(x) & any & $\lceil x \rceil$, smallest integer not less than $x$
X(real part) \cr
X\+ cos(x) & radians & $\cos x$, cosine of $x$ \cr
X\+ cosh(x) & radians & $\cosh x$, hyperbolic cosine of $x$ \cr
X\+ erf(x) & any & $\hbox{Erf}(\hbox{real}(x))$,  error function of real($x$) \cr
X\+ erfc(x) & any & $\hbox{Erfc}(\hbox{real}(x))$,  1.0 - error function of real($x$) \cr
X\+ exp(x) & any & $e^{x}$,  exponential function of $x$ \cr
X\+ floor(x) & any & $\lfloor x \rfloor$,  largest integer not greater
Xthan $x$ (real part) \cr
X\+ gamma(x) & any & $\hbox{Gamma}(\hbox{real}(x))$,  gamma function of real($x$) \cr
X\+ ibeta(p,q,x) & any & $\hbox{Ibeta}(\hbox{real}(p,q,x))$,  ibeta function of real($p$,$q$,$x$) \cr
X\+ igamma(a,x) & any & $\hbox{Igamma}(\hbox{real}(a,x))$,  igamma function of real($a$,$x$) \cr
X\+ imag(x) & complex &  imaginary part of $x$ as a real number \cr
X\+ int(x) & real &  integer part of $x$, truncated toward zero \cr
X\+ lgamma(x) & any & $\hbox{Lgamma}(\hbox{real}(x))$,  lgamma function of real($x$) \cr
X\+ log(x) & any & $\log_{e} x$,  natural logarithm (base $e$) of $x$ \cr
X\+ log10(x) & any & $\log_{10} x$,  logarithm (base $10$) of $x$ \cr
X\+ rand(x) & any & $\hbox{Rand}(\hbox{real}(x))$,  pseudo random number generator \cr
X\+ real(x) & any &  real part of $x$ \cr
X\+ sgn(x) & any & 1 if $x>0$, -1 if $x<0$, 0 if $x=0$. imag($x$) ignored \cr
X\+ sin(x) & radians & $\sin x$, sine of $x$ \cr
X\+ sinh(x) & radians & $\sinh x$, hyperbolic sine $x$ \cr
X\+ sqrt(x) & any & $\sqrt{x}$,  square root of $x$ \cr
X\+ tan(x) & radians & $\tan x$,  tangent of $x$ \cr
X\+ tanh(x) & radians & $\tanh x$, hyperbolic tangent of $x$\cr
X\hrule % \hline
X%\end{tabular}
X%\end{center}
X\section{Operators}
XThe operators in GNUPLOT are the same as the corresponding operators
Xin the C programming language, except that all operators accept
Xinteger, real, and complex arguments, unless otherwise noted.
XThe ** operator (exponentiation) is supported, as in FORTRAN.
X
XParentheses may be used to change order of evaluation.
X
X
X
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X\bye
X\subsubsection{Binary}
XThe following is a list of all the binary operators and their
Xusages:
X
X
X\begin{center}
X\begin{tabular}{|ccl|} \hline
X\multicolumn{3}{|c|}{Binary Operators} \\
XSymbol & Example & Explanation \\ \hline
X\verb~**~ & \verb~a**b~ & exponentiation\\
X\verb~*~ & \verb~a*b~ & multiplication\\
X\verb~/~ & \verb~a/b~ & division\\
X\verb~%~ & \verb~a%b~ & * modulo\\
X\verb~+~ & \verb~a+b~ & addition\\
X\verb~-~ & \verb~a-b~ & subtraction\\
X\verb~==~ & \verb~a==b~ & equality\\
X\verb~!=~ & \verb~a!=b~ & inequality\\
X\verb~&~ & \verb~a&b~ & * bitwise AND\\
X\verb~^~ & \verb~a^b~ & * bitwise exclusive OR\\
X\verb~|~ & \verb~a|b~ & * bitwise inclusive OR\\
X\verb~&&~ & \verb~a&&b~ & * logical AND\\
X\verb~||~ & \verb~a||b~ & * logical OR\\
X\verb~?:~ & \verb~a?b:c~ & * ternary operation\\
X\hline
X\end{tabular}
X\end{center}
X(*) Starred explanations indicate that the operator requires
Xinteger arguments.
X
XLogical AND (\&\&) and OR ($|$$|$) short-circuit the way they do in C.
XThat is, the second \&\& operand is not evaluated if the first is
Xfalse; the second $|$$|$ operand is not evaluated if the first is true.
X
XThe ternary operator evaluates its first argument (a). If it is
Xtrue (non-zero) the second argument (b) is evaluated and returned,
Xotherwise the third argument (c) is evaluated and returned.
X\subsubsection{Unary}
XThe following is a list of all the unary operators and their
Xusages:
X
X
X\begin{center}
X\begin{tabular}{|ccl|} \hline
X\multicolumn{3}{|c|}{Unary Operators}\\
XSymbol & Example & Explanation \\ \hline
X\verb@-@ & \verb@-a@ & unary minus \\
X\verb@~@ & \verb@~a@ & * one's complement \\
X\verb@!@ & \verb@!a@ & * logical negation \\
X\verb@!@ & \verb@a!@ & * factorial \\
X\hline
X\end{tabular}
X\end{center}
X(*) Starred explanations indicate that the operator requires an
Xinteger argument.
X
XThe factorial operator returns a real number to allow a greater range.
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
END_OF_FILE
  if test 41221 -ne `wc -c <'gnuplot/docs/gpcard.tex'`; then
    echo shar: \"'gnuplot/docs/gpcard.tex'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/gpcard.tex'
fi
if test -f 'gnuplot/term/pc.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/pc.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/pc.trm'\" \(25354 characters\)
  sed "s/^X//" >'gnuplot/term/pc.trm' <<'END_OF_FILE'
X/*
X * $Id: pc.trm 3.38.2.42 1993/01/07 17:23:59 woo Exp woo $
X *
X */
X
X/* GNUPLOT - pc.trm */
X/*
X * Copyright (C) 1990 - 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  Under Microsoft C
X *      cga, egabios, egalib, vgabios, hercules, corona325, att
X *  Under Turboc C
X *      egalib, vgalib, vgamono, svga, mcga, cga, hercules, att
X *
X * AUTHORS
X *  Colin Kelley, Thomas Williams, William Wilson, Russell Lang
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X#ifdef __TURBOC__
X#include <graphics.h>
X#include <conio.h>
X#include <dos.h>
X  int g_driver, g_mode, g_error;
X  char far *path;
X  char *pathp, path_s[128];
X
X/* instead of string.h */
Xextern char *strrchr();
X
Xget_path()
X{
X   path=(char far *) getenv("BGI");
X   if (path==NULL) {
X      (void) strcpy(path_s,_argv[0]);
X      pathp=strrchr(path_s,'\\');
X      *pathp=0x00;
X      path=path_s;
X   }
X}
X
Xstatic struct text_info tinfo;       /* So we can restore starting text mode. */
X#endif
X
X
Xstatic char near buf[80];	/* kludge since EGA.LIB is compiled SMALL */
X
Xstatic int pattern[] = {0xffff, 0x0f0f, 0xffff, 0xaaaa, 0x3333, 0x3f3f, 0x0f0f};
X
Xstatic int graphics_on = FALSE;
Xint startx, starty;
X
Xint pc_angle;
X#define PC_VCHAR FNT5X9_VCHAR
X#define PC_HCHAR FNT5X9_HCHAR
X
Xpause()		/* press any key to continue... */
X{
X	(void) getch();
X}
X
X
XPC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X#ifdef __TURBOC__
X	restorecrtmode();
X        textmode(tinfo.currmode);
X	clrscr();
X#else
X	Vmode(3);
X#endif
X}
X
XPC_reset()
X{
X#ifdef __TURBOC__
X	closegraph();
X        textmode(tinfo.currmode);
X	clrscr();
X#endif
X}
X
X
X#ifndef __TURBOC__
X
XPC_putc(x,y,c,angle,line_func)
Xunsigned int x,y;
Xchar c;
Xint angle;
XFUNC_PTR line_func;
X{
Xint i,j,k;
Xunsigned int pixelon;
X	i = (int)(c) - 32;
X	for (j=0; j<FNT5X9_VBITS; j++) {
X		for (k=0; k<FNT5X9_HBITS; k++) {
X			pixelon = (((unsigned int)(fnt5x9[i][j])) >> k & 1);
X			if (pixelon) {
X				switch(angle) {
X					case 0 : (*line_func)(x+k+1,y-j,x+k+1,y-j);
X							break;
X					case 1 : (*line_func)(x-j,y-k-1,x-j,y-k-1);
X							break;
X				}
X			}
X		}
X	}
X}
X
X
Xint PC_text_angle(ang)
Xint ang;
X{
X	pc_angle=ang;
X	return TRUE;
X}
X
X
X#define CGA_XMAX 640
X#define CGA_YMAX 200
X
X#define CGA_XLAST (CGA_XMAX - 1)
X#define CGA_YLAST (CGA_YMAX - 1)
X
X#define CGA_VCHAR PC_VCHAR
X#define CGA_HCHAR PC_HCHAR
X#define CGA_VTIC 4
X#define CGA_HTIC 6
X
Xint line_cga;
X
XCGA_init()
X{
X	PC_color(1);		/* monochrome */
X}
X
XCGA_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(6);
X}
X
X#define CGA_text PC_text
X
XCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	line_cga=linetype;
X	PC_mask(pattern[linetype+2]);
X}
X
XCGA_move(x,y)
X{
X	startx = x;
X	starty = y;
X}
X
X
XCGA_vector(x,y)
X{
X	PC_line(startx,CGA_YLAST-starty,x,CGA_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XCGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
Xint line;
X	line= line_cga; 	/* disable the dotted lines temporarily */
X	PC_mask(pattern[0]);
X	switch(pc_angle) {
X		case 0 : y -= CGA_VCHAR/2;
X				break;
X		case 1 : x += CGA_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,CGA_YLAST-y,str[i],pc_angle,PC_line);
X		switch(pc_angle) {
X			case 0 : x+=CGA_HCHAR ;
X					break;
X			case 1 : y+=CGA_HCHAR ;
X					break;
X		}
X	}
X	PC_mask(pattern[line]);  /* enable dotted lines */
X}
X
X
X#define CGA_text_angle PC_text_angle
X
X#define CGA_reset PC_reset
X
X
X#define EGA_XMAX 640
X#define EGA_YMAX 350
X
X#define EGA_XLAST (EGA_XMAX - 1)
X#define EGA_YLAST (EGA_YMAX - 1)
X
X#define EGA_VCHAR PC_VCHAR
X#define EGA_HCHAR PC_HCHAR
X#define EGA_VTIC 4
X#define EGA_HTIC 5
X
Xstatic int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
Xstatic int ega256color[] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
X
Xstatic int *egacolor;
X
X
XEGA_init()
X{
X	PC_mask(0xffff);
X	egacolor = ega256color;		/* should be smarter */
X}
X
XEGA_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(16);
X}
X
X#define EGA_text PC_text
X
XEGA_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	PC_color(egacolor[linetype+2]);
X}
X
XEGA_move(x,y)
X{
X	startx = x;
X	starty = y;
X}
X
XEGA_vector(x,y)
X{
X	PC_line(startx,EGA_YLAST-starty,x,EGA_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XEGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
X	switch(pc_angle) {
X		case 0 : y -= EGA_VCHAR/2;
X				break;
X		case 1 : x += EGA_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,EGA_YLAST-y,str[i],pc_angle,PC_line);
X		switch(pc_angle) {
X			case 0 : x+=EGA_HCHAR ;
X					break;
X			case 1 : y+=EGA_HCHAR ;
X					break;
X		}
X	}
X}
X
X
X#define EGA_text_angle PC_text_angle
X
X#define EGA_reset PC_reset
X
X
X
X/* The following VGA routines are hacked from the above EGA routines
X   They worked on two VGA cards.
X   Russell Lang, eln272v@monu1.cc.monash.oz */
X#define VGA_XMAX 640
X#define VGA_YMAX 480
X
X#define VGA_XLAST (VGA_XMAX - 1)
X#define VGA_YLAST (VGA_YMAX - 1)
X
X#define VGA_VCHAR PC_VCHAR
X#define VGA_HCHAR PC_HCHAR
X#define VGA_VTIC 5
X#define VGA_HTIC 5
X
Xstatic int vga256color[] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
X
Xstatic int *vgacolor;
X
X
XVGA_init()
X{
X	PC_mask(0xffff);
X	vgacolor = vga256color;		/* should be smarter */
X}
X
XVGA_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(18);
X}
X
X#define VGA_text PC_text
X
XVGA_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	PC_color(vgacolor[linetype+2]);
X}
X
XVGA_move(x,y)
X{
X	startx = x;
X	starty = y;
X}
X
XVGA_vector(x,y)
X{
X	PC_line(startx,VGA_YLAST-starty,x,VGA_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XVGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
X	switch(pc_angle) {
X		case 0 : y -= VGA_VCHAR/2;
X				break;
X		case 1 : x += VGA_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,VGA_YLAST-y,str[i],pc_angle,PC_line);
X		switch(pc_angle) {
X			case 0 : x+=VGA_HCHAR ;
X					break;
X			case 1 : y+=VGA_HCHAR ;
X					break;
X		}
X	}
X}
X
X
X#define VGA_text_angle PC_text_angle
X
X#define VGA_reset PC_reset
X
X
X
X#ifdef EGALIB
X
X#define EGALIB_XMAX 640
X#define EGALIB_YMAX 350
X
X#define EGALIB_XLAST (EGA_XMAX - 1)
X#define EGALIB_YLAST (EGA_YMAX - 1)
X
X#define EGALIB_VCHAR 14
X#define EGALIB_HCHAR 8
X#define EGALIB_VTIC 4
X#define EGALIB_HTIC 5
X
X#include "mcega.h"
X
XEGALIB_init()
X{
X	GPPARMS();
X	if (GDTYPE != 5) {
X		term = 0;
X		int_error("color EGA board not found",NO_CARET);
X	}
X	egacolor = (GDMEMORY < 256) ? ega64color : ega256color;
X}
X
XEGALIB_graphics()
X{
X	graphics_on = TRUE;
X	GPINIT();
X}
X
XEGALIB_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	GPTERM();
X}
X
XEGALIB_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	GPCOLOR(egacolor[linetype+2]);
X}
X
XEGALIB_move(x,y)
X{
X	GPMOVE(x,GDMAXROW-y);
X}
X
X
XEGALIB_vector(x,y)
X{
X	GPLINE(x,GDMAXROW-y);
X}
X
X
XEGALIB_put_text(x,y,str)
Xint x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	GotoXY((int)(x/EGALIB_HCHAR),
X		   (int)((EGALIB_YMAX-y-(EGALIB_VCHAR/2))/EGALIB_VCHAR));
X	gprintf(buf);
X}
X
X
X#define EGALIB_reset PC_reset
X
X#endif /* EGALIB */
X
X
X#ifdef HERCULES
X
X#define HERC_XMAX 720
X#define HERC_YMAX 348
X
X#define HERC_XLAST (HERC_XMAX - 1)
X#define HERC_YLAST (HERC_YMAX - 1)
X
X#define HERC_VCHAR PC_VCHAR
X#define HERC_HCHAR PC_HCHAR
X#define HERC_VTIC 4
X#define HERC_HTIC 5
X
Xint line_herc;
X
XHERC_init()
X{
X	H_init();
X}
X
XHERC_graphics()
X{
X	HVmode(1);
X	graphics_on = TRUE;
X}
X
XHERC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	HVmode(0);
X}
X
XHERC_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	H_mask(pattern[linetype+2]);
X	line_herc = linetype;
X}
X
XHERC_move(x,y)
X{
X	if (x < 0)
X		startx = 0;
X	else if (x > HERC_XLAST)
X		startx = HERC_XLAST;
X	else
X		startx = x;
X
X	if (y < 0)
X		starty = 0;
X	else if (y > HERC_YLAST)
X		starty = HERC_YLAST;
X	else
X		starty = y;
X}
X
XHERC_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X
X	H_line(startx,HERC_YLAST-starty,x,HERC_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XHERC_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
Xint line;
X	line= line_herc; 	/* disable the dotted lines temporarily */
X	H_mask(pattern[0]);
X	switch(pc_angle) {
X		case 0 : y -= HERC_VCHAR/2;
X				break;
X		case 1 : x += HERC_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,HERC_YLAST-y,str[i],pc_angle,H_line);
X		switch(pc_angle) {
X			case 0 : x+=HERC_HCHAR ;
X					break;
X			case 1 : y+=HERC_HCHAR ;
X					break;
X		}
X	}
X	H_mask(pattern[line]);  /* enable dotted lines */
X}
X
X
X#define HERC_text_angle PC_text_angle
X
X#define HERC_reset PC_reset
X
X
X#endif /* HERCULES */
X
X
X/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
X   ATT 6300 driver */ 
X
X
X#ifdef ATT6300
X
X#define ATT_XMAX 640
X#define ATT_YMAX 400
X
X#define ATT_XLAST (ATT_XMAX - 1)
X#define ATT_YLAST (ATT_YMAX - 1)
X
X#define ATT_VCHAR PC_VCHAR
X#define ATT_HCHAR PC_HCHAR
X#define ATT_VTIC 4
X#define ATT_HTIC 5
X
X#define ATT_init CGA_init
X
XATT_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(0x40);        /* 40H is the magic number for the AT&T driver */
X}
X
X#define ATT_text CGA_text
X
X#define ATT_linetype CGA_linetype
X
X#define ATT_move CGA_move
X
XATT_vector(x,y)
X{
X	PC_line(startx,ATT_YLAST-starty,x,ATT_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XATT_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
Xint line;
X	line= line_cga; 	/* disable the dotted lines temporarily */
X	PC_mask(pattern[0]);
X	switch(pc_angle) {
X		case 0 : y -= ATT_VCHAR/2;
X				break;
X		case 1 : x += ATT_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,ATT_YLAST-y,str[i],pc_angle,PC_line);
X		switch(pc_angle) {
X			case 0 : x+=ATT_HCHAR ;
X					break;
X			case 1 : y+=ATT_HCHAR ;
X					break;
X		}
X	}
X	PC_mask(pattern[line]);  /* enable dotted lines */
X}
X
X
X#define ATT_text_angle PC_text_angle
X
X#define ATT_reset CGA_reset
X
X#endif  /* ATT6300 */
X
X
X#ifdef CORONA
X
X#define COR_XMAX 640
X#define COR_YMAX 325
X
X#define COR_XLAST (COR_XMAX - 1)
X#define COR_YLAST (COR_YMAX - 1)
X
X#define COR_VCHAR PC_VCHAR
X#define COR_HCHAR PC_HCHAR
X#define COR_VTIC 4
X#define COR_HTIC 5
X
Xint line_cor;
X
Xstatic int corscreen;		/* screen number, 0 - 7 */
X
XCOR_init()
X{
Xregister char *p;
X	if (!(p = getenv("CORSCREEN")))
X		int_error("must run CORPLOT for Corona graphics",NO_CARET);
X	corscreen = *p - '0';
X}
X
XCOR_graphics()
X{
X	graphics_on = TRUE;
X	Vmode(3);				/* clear text screen */
X	grinit(corscreen);
X	grandtx();
X}
X
XCOR_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	grreset();
X	txonly();
X	Vmode(3);
X}
X
XCOR_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	line_cor = linetype;
X	Cor_mask(pattern[linetype+2]);
X}
X
XCOR_move(x,y)
X{
X	if (x < 0)
X		startx = 0;
X	else if (x > COR_XLAST)
X		startx = COR_XLAST;
X	else
X		startx = x;
X
X	if (y < 0)
X		starty = 0;
X	else if (y > COR_YLAST)
X		starty = COR_YLAST;
X	else
X		starty = y;
X}
X
XCOR_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > COR_XLAST)
X		x = COR_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > COR_YLAST)
X		y = COR_YLAST;
X
X	Cor_line(startx,COR_YLAST-starty,x,COR_YLAST-y);
X	startx = x;
X	starty = y;
X}
X
X
XCOR_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
Xint line;
X	line= line_cor; 	/* disable the dotted lines temporarily */
X	Cor_mask(pattern[0]);
X	switch(pc_angle) {
X		case 0 : y -= COR_VCHAR/2;
X				break;
X		case 1 : x += COR_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		PC_putc(x,COR_YLAST-y,str[i],pc_angle,Cor_line);
X		switch(pc_angle) {
X			case 0 : x+=COR_HCHAR ;
X					break;
X			case 1 : y+=COR_HCHAR ;
X					break;
X		}
X	}
X	COR_mask(pattern[line]);  /* enable dotted lines */
X}
X
X
X#define COR_text_angle PC_text_angle
X
X#define COR_reset PC_reset
X
X#endif /* CORONA */
X
X
X#else /* ifndef __TURBOC__ */
X/* all of the Turbo C routines for the different graphics devices go here */
X
X#define VGA_XMAX 640
X#define VGA_YMAX 480
X
X#define VGA_XLAST (VGA_XMAX - 1)
X#define VGA_YLAST (VGA_YMAX - 1)
X
X#define VGA_VCHAR 10
X#define VGA_HCHAR 8
X#define VGA_VTIC 4
X#define VGA_HTIC 5
X
X#define SVGA_XMAX 640
X#define SVGA_YMAX 480
X
X#define SVGA_VCHAR 10
X#define SVGA_HCHAR 8
X#define SVGA_VTIC 4
X#define SVGA_HTIC 5
X
Xstatic int vga256color[] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
Xstatic int *vgacolor;
X
Xstatic int svga_xmax = SVGA_XMAX,
X	   svga_ymax = SVGA_YMAX,
X	   svga_xlast = 639,
X	   svga_ylast = 479;
X
X#define VGA_reset EGALIB_reset
X#define VGA_text EGALIB_text
X#define VGA_move EGALIB_move
X#define VGA_vector EGALIB_vector
X#define VGA_text_angle PC_text_angle
X#define VGA_justify_text PC_justify_text
X
X#define SVGA_reset EGALIB_reset
X#define SVGA_text EGALIB_text
X#define SVGA_move EGALIB_move
X#define SVGA_vector EGALIB_vector
X#define SVGA_text_angle PC_text_angle
X#define SVGA_justify_text PC_justify_text
X#define SVGA_linetype VGA_linetype
X
Xint PC_text_angle(ang)
Xint ang;
X{
X	int size = svga_ymax > 600 ? 2 : 1;
X
X	pc_angle = ang;
X
X	switch (ang) {
X		case 0 : settextstyle(DEFAULT_FONT,HORIZ_DIR,size);
X			break;
X		case 1 : settextstyle(DEFAULT_FONT,VERT_DIR,size);
X			break;
X	}
X	return TRUE;
X}
X
Xint PC_justify_text(mode)
Xenum JUSTIFY mode;
X{
X	switch(mode) {
X		case LEFT :
X			settextjustify(LEFT_TEXT,CENTER_TEXT);
X			break;
X		case CENTRE :
X			settextjustify(CENTER_TEXT,CENTER_TEXT);
X			break;
X		case RIGHT:
X			settextjustify(RIGHT_TEXT,CENTER_TEXT);
X			break;
X	}
X	return TRUE;
X}
X
XVGA_init()
X{
X	g_driver=VGA;
X	g_mode=2;
X	gettextinfo(&tinfo);
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver!=9){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X
X/*          int_error("color VGA board not found",NO_CARET);*/
X        }
X        if(g_driver==VGA) vgacolor=vga256color;
X}
X
XVGA_graphics()
X{       g_driver=VGA;
X	g_mode=2;
X	graphics_on = TRUE;
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	VGA_justify_text(LEFT);
X}
X
XVGA_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	setcolor(vgacolor[linetype+2]);
X}
X
XVGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,VGA_YLAST-y,buf);
X}
X
X
XVGAMONO_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
Xstatic int huge detect_svga(void)
X{
X    return g_mode;
X}
X
XSVGA_init()
X{
X	char *p, name[128], *SVGA = getenv( "SVGA" );
X
X	if (SVGA == NULL)
X		int_error("'SVGA' driver environment variable is not set",
X			  NO_CARET);
X
X	strcpy(name, SVGA);
X	if ((p = strrchr(name, '.')) == NULL ||
X	    sscanf(&p[1], "%d", &g_mode) != 1)
X		int_error("'SVGA' envvar should be of the form 'name.mode'",
X			  NO_CARET);
X
X	*p = 0;
X
X	installuserdriver(name, detect_svga);
X	gettextinfo(&tinfo);
X	g_driver = 0;
X	get_path();
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver<0){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X
X        }
X	else
X	    vgacolor=vga256color;
X
X	/* Get the screen size: */
X	svga_xmax = term_tbl[term].xmax = getmaxx() + 1;
X        svga_ymax = term_tbl[term].ymax = getmaxy() + 1;
X	svga_xlast = svga_xmax-1;
X	svga_ylast = svga_ymax-1;
X
X	if (svga_ymax > 600) {		       /* Double the tic/font sizes. */
X		term_tbl[term].h_char = SVGA_HCHAR * 2;
X		term_tbl[term].v_char = SVGA_VCHAR * 2;
X		term_tbl[term].h_tic = SVGA_HTIC * 2;
X		term_tbl[term].v_tic = SVGA_VTIC * 2;
X		settextstyle(DEFAULT_FONT,HORIZ_DIR,2);
X 	}
X	else
X		settextstyle(DEFAULT_FONT,HORIZ_DIR,1);
X}
X
XSVGA_graphics()
X{
X	graphics_on = TRUE;
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	VGA_justify_text(LEFT);
X
X        svga_ymax = getmaxy() + 1;
X	if (svga_ymax > 600)		       /* Double the tic/font sizes. */
X		settextstyle(DEFAULT_FONT,HORIZ_DIR,2);
X	else
X		settextstyle(DEFAULT_FONT,HORIZ_DIR,1);
X}
X
XSVGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,svga_ylast-y,buf);
X}
X
X#define MCGA_XMAX 640
X#define MCGA_YMAX 480
X
X#define MCGA_XLAST (MCGA_XMAX - 1)
X#define MCGA_YLAST (MCGA_YMAX - 1)
X
X#define MCGA_VCHAR 10
X#define MCGA_HCHAR 8
X#define MCGA_VTIC 4
X#define MCGA_HTIC 5
X
Xstatic int *MCGAcolor;
X
X#define MCGA_reset EGALIB_reset
X#define MCGA_text EGALIB_text
X#define MCGA_move EGALIB_move
X#define MCGA_vector EGALIB_vector
X#define MCGA_text_angle PC_text_angle
X#define MCGA_justify_text PC_justify_text
X
XMCGA_init()
X{
X	g_driver=MCGA;
X	g_mode=5;
X	gettextinfo(&tinfo);
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver!=2){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X        }
X}
X
XMCGA_graphics()
X{
X	graphics_on = TRUE;
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	MCGA_justify_text(LEFT);
X}
X
X
XMCGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,MCGA_YLAST-y,buf);
X}
X
X
XMCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
X
X#define EGALIB_XMAX 640
X#define EGALIB_YMAX 350
X
X#define EGALIB_XLAST (EGALIB_XMAX - 1)
X#define EGALIB_YLAST (EGALIB_YMAX - 1)
X
X#define EGALIB_VCHAR 10
X#define EGALIB_HCHAR 8
X#define EGALIB_VTIC 4
X#define EGALIB_HTIC 5
X
Xstatic int ega64color[] =  {1,1,5,4,3,5,4,3, 5, 4, 3, 5, 4, 3,5};
Xstatic int ega256color[] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
X
Xstatic int *egacolor;
X
X#define EGALIB_text_angle PC_text_angle
X#define EGALIB_justify_text PC_justify_text
X
XEGALIB_init()
X{
X	g_driver=EGA;
X	g_mode=1;
X	gettextinfo(&tinfo);
X        initgraph(&g_driver,&g_mode,path);
X        if(g_driver<3 || g_driver>4){
X          term=0;
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X
X/*          int_error("color EGA board not found",NO_CARET);*/
X        }
X        if(g_driver==EGA) egacolor=ega256color;
X        if(g_driver==EGA64) egacolor=ega64color;
X}
X
XEGALIB_graphics()
X{
X	graphics_on = TRUE;
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	EGALIB_justify_text(LEFT);
X}
X
XEGALIB_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	restorecrtmode();
X        textmode(tinfo.currmode);
X	clrscr();
X	svga_ymax = SVGA_YMAX; /* Since it may double font size if too high. */
X}
X
XEGALIB_linetype(linetype)
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	setcolor(egacolor[linetype+2]);
X}
X
XEGALIB_move(x,y)
X{
X        moveto(x,getmaxy()-y);
X}
X
X
XEGALIB_vector(x,y)
X{
X	lineto(x,getmaxy()-y);
X}
X
X
XEGALIB_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,EGALIB_YLAST-y,buf);
X}
X
X
XEGALIB_reset()
X{
X  	closegraph();
X        textmode(tinfo.currmode);
X	clrscr();
X	svga_ymax = SVGA_YMAX; /* Since it may double font size if too high. */
X}
X
X
X#define CGA_XMAX 640
X#define CGA_YMAX 200
X
X#define CGA_XLAST (CGA_XMAX - 1)
X#define CGA_YLAST (CGA_YMAX - 1)
X
X#define CGA_VCHAR 10
X#define CGA_HCHAR 8
X#define CGA_VTIC 4
X#define CGA_HTIC 6
X
X#define CGA_text_angle PC_text_angle
X#define CGA_justify_text PC_justify_text
X#define CGA_reset PC_reset
X
XCGA_init()
X{
X	g_driver=CGA;
X	g_mode=4;
X	gettextinfo(&tinfo);
X	initgraph(&g_driver,&g_mode,path);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X/*	PC_color(1);		 monochrome */
X
X}
X
XCGA_graphics()
X{
X	graphics_on = TRUE;
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	CGA_justify_text(LEFT);
X	/*	Vmode(6);*/
X}
X
X#define CGA_text PC_text
X
XCGA_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
XCGA_move(x,y)
X{
X	moveto(x,getmaxy()-y);
X}
X
X
XCGA_vector(x,y)
X{
X	lineto(x,getmaxy()-y);
X}
X
XCGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,CGA_YLAST-y,buf);
X}
X
X
X
X#define HERC_XMAX 720
X#define HERC_YMAX 348
X
X#define HERC_XLAST (HERC_XMAX - 1)
X#define HERC_YLAST (HERC_YMAX - 1)
X
X#define HERC_VCHAR 10
X#define HERC_HCHAR 8
X#define HERC_VTIC 4
X#define HERC_HTIC 5
X
X#define HERC_text_angle PC_text_angle
X#define HERC_justify_text PC_justify_text
X#define HERC_reset PC_reset
X
XHERC_init()
X{
X	g_driver=HERCMONO;
X	g_mode=0;
X	gettextinfo(&tinfo);
X  	initgraph(&g_driver,&g_mode,path);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X}
X
XHERC_graphics()
X{
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	HERC_justify_text(LEFT);
X	graphics_on = TRUE;
X}
X
XHERC_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	restorecrtmode();
X        textmode(tinfo.currmode);
X	clrscr();
X}
X
XHERC_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
XHERC_move(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X	moveto(x,getmaxy()-y);
X}
X
XHERC_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > HERC_XLAST)
X		x = HERC_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > HERC_YLAST)
X		y = HERC_YLAST;
X
X	lineto(x,getmaxy()-y);
X}
X
X
XHERC_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,HERC_YLAST-y,buf);
X}
X
X
X#ifdef ATT6300
X/* this driver added by rjl@monu1.cc.monash.edu.au */
X
X#define ATT_XMAX 640
X#define ATT_YMAX 400
X
X#define ATT_XLAST (ATT_XMAX - 1)
X#define ATT_YLAST (ATT_YMAX - 1)
X
X#define ATT_VCHAR PC_VCHAR
X#define ATT_HCHAR PC_HCHAR
X#define ATT_VTIC 4
X#define ATT_HTIC 5
X
X#define ATT_text_angle PC_text_angle
X#define ATT_justify_text PC_justify_text
X#define ATT_reset PC_reset
X
XATT_init()
X{
X	g_driver=ATT400;
X	g_mode=5;
X	gettextinfo(&tinfo);
X  	initgraph(&g_driver,&g_mode,path);
X          switch (g_driver){
X            case -2: fprintf(stderr,"Graphics card not detected.\n");
X                     break;
X            case -3: fprintf(stderr,"BGI driver file cannot be found.\n");
X                     break;
X            case -4: fprintf(stderr,"Invalid BGI driver file.\n");
X                     break;
X            case -5: fprintf(stderr,"Insufficient memory to load ",
X                             "graphics driver.");
X                     break;
X            }
X}
X
XATT_graphics()
X{
X	gettextinfo(&tinfo);
X	setgraphmode(getgraphmode());
X	ATT_justify_text(LEFT);
X	graphics_on = TRUE;
X}
X
XATT_text()
X{
X	if (graphics_on) {
X		graphics_on = FALSE;
X		pause();
X	}
X	restorecrtmode();
X        textmode(tinfo.currmode);
X	clrscr();
X}
X
XATT_linetype(linetype)
X{
X	if (linetype >= 5)
X		linetype %= 5;
X	setlinestyle(4,pattern[linetype+2],1);
X}
X
XATT_move(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > ATT_XLAST)
X		x = ATT_XLAST;
X
X	if (y < 0)
X		y = 0;
X	else if (y > ATT_YLAST)
X		y = ATT_YLAST;
X	moveto(x,getmaxy()-y);
X}
X
XATT_vector(x,y)
X{
X	if (x < 0)
X		x = 0;
X	else if (x > ATT_XLAST)
X		x = ATT_XLAST;
X	if (y < 0)
X		y = 0;
X	else if (y > ATT_YLAST)
X		y = ATT_YLAST;
X
X	lineto(x,getmaxy()-y);
X}
X
X
XATT_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X	strcpy((char far *)buf,str);
X	outtextxy(x,ATT_YLAST-y,buf);
X}
X#endif /* ifdef ATT6300 */
X
X#endif /* ifndef __TURBOC__ */
X
END_OF_FILE
  if test 25354 -ne `wc -c <'gnuplot/term/pc.trm'`; then
    echo shar: \"'gnuplot/term/pc.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/pc.trm'
fi
echo shar: End of archive 15 \(of 33\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
