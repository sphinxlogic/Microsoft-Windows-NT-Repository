Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i017:  gnuplot - interactive function plotting utility, Part05/33
Message-ID: <1993Oct21.144328.1622@sparky.sterling.com>
X-Md4-Signature: d581c782461add0aabde710458b84346
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 21 Oct 1993 14:43:28 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 17
Archive-name: gnuplot/part05
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/command.c.A gnuplot/demo/1.dat
#   gnuplot/term/imagen.trm
# Wrapped by kent@sparky on Wed Oct 20 17:14:39 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 33)."'
if test -f 'gnuplot/command.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/command.c.A'\"
else
  echo shar: Extracting \"'gnuplot/command.c.A'\" \(58930 characters\)
  sed "s/^X//" >'gnuplot/command.c.A' <<'END_OF_FILE'
X#ifndef lint
Xstatic char    *RCSid = "$Id: command.c%v 3.50.1.15 1993/08/21 15:23:42 woo Exp $";
X#endif
X
X
X/* GNUPLOT - command.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X * 
X * Permission to use, copy, and distribute this software and its documentation
X * for any purpose with or without fee is hereby granted, provided that the
X * above copyright notice appear in all copies and that both that copyright
X * notice and this permission notice appear in supporting documentation.
X * 
X * Permission to modify the software is granted, but not the right to distribute
X * the modified code.  Modifications are to be distributed as patches to
X * released version.
X * 
X * This software is provided "as is" without express or implied warranty.
X * 
X * 
X * AUTHORS
X * 
X * Original Software: Thomas Williams,  Colin Kelley.
X * 
X * Gnuplot 2.0 additions: Russell Lang, Dave Kotz, John Campbell.
X * 
X * Gnuplot 3.0 additions: Gershon Elber and many others.
X * 
X * Changes:
X * 
X * Feb 5, 1992	Jack Veenstra	(veenstra@cs.rochester.edu) Added support to
X * filter data values read from a file through a user-defined function before
X * plotting. The keyword "thru" was added to the "plot" command. Example
X * syntax: f(x) = x / 100 plot "test.data" thru f(x) This example divides all
X * the y values by 100 before plotting. The filter function processes the
X * data before any log-scaling occurs. This capability should be generalized
X * to filter x values as well and a similar feature should be added to the
X * "splot" command.
X * 
X * 19 September 1992  Lawrence Crowl  (crowl@cs.orst.edu)
X * Added user-specified bases for log scaling.
X * 
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X#include <stdio.h>
X#include <math.h>
X#include <ctype.h>
X
X#ifdef AMIGA_AC_5
X#include <time.h>
Xvoid            sleep();	/* defined later */
X#endif
X
X#ifdef OS2
X#include <setjmp.h>
Xextern jmp_buf env;       /* from plot.c */
X#endif
X
X#if defined(MSDOS) || defined(DOS386)
X#ifdef DJGPP
X#include <dos.h>
X#else
X#include <process.h>
X#endif
X
X#ifdef __ZTC__
X#define P_WAIT 0
X#include <time.h>		/* usleep() */
X#else
X
X#ifdef __TURBOC__
X#ifndef _Windows
X#include <dos.h>		/* sleep() */
X#include <conio.h>
X#include <dir.h>    /* setdisk() */
Xextern unsigned _stklen = 16394;/* increase stack size */
X#endif
X
X#else				/* must be MSC */
X#if !defined(__EMX__) && !defined(DJGPP)
X#ifdef __MSC__
X#include <direct.h>		/* for _chdrive() */
X#endif
X#include <time.h>		/* kludge to provide sleep() */
Xvoid            sleep();	/* defined later */
X#endif				/* !__EMX__ && !DJGPP */
X#endif				/* TURBOC */
X#endif				/* ZTC */
X
X#endif				/* MSDOS */
X
X#ifdef ATARI
X#ifdef __PUREC__
X#include <ext.h>
X#include <tos.h>
X#include <aes.h>
X#else
X#include <osbind.h>
X#include <aesbind.h>
X#endif /* __PUREC__ */
X#endif /* ATARI */
X
X#ifdef AMIGA_SC_6_1
X#include <proto/dos.h>
Xvoid            sleep();
X#endif				/* AMIGA_SC_6_1 */
X
X#include "plot.h"
X#include "setshow.h"
X#ifndef _Windows
X#include "help.h"
X#else
X#define MAXSTR 255
X#endif
X
X#ifndef STDOUT
X#define STDOUT 1
X#endif
X
X#ifndef HELPFILE
X#if defined( MSDOS ) || defined( OS2 ) || defined(DOS386)
X#define HELPFILE "gnuplot.gih"
X#else
X#ifdef AMIGA_SC_6_1
X#define HELPFILE "S:gnuplot.gih"
X#else
X#define HELPFILE "docs/gnuplot.gih"	/* changed by makefile */
X#endif				/* AMIGA_SC_6_1 */
X#endif
X#endif				/* HELPFILE */
X
X#ifdef _Windows
X#include <windows.h>
X#include <setjmp.h>
X#ifdef __MSC__
X#include <malloc.h>
X#else
X#include <alloc.h>
X#include <dir.h>    /* setdisk() */
X#endif
X#include "win/wgnuplib.h"
Xvoid sleep();
Xextern TW textwin;
Xextern jmp_buf FAR env;       /* from plot.c */
Xextern LPSTR winhelpname;
Xextern void screen_dump(void);	/* in term/win.trm */
Xextern int Pause(LPSTR mess); /* in winmain.c */
X#endif
X
X#define inrange(z,min,max) ((min<max) ? ((z>=min)&&(z<=max)) : ((z>=max)&&(z<=min)) )
X
X/*
X * instead of <strings.h>
X */
X
X#ifndef ATARI
X#ifdef _Windows
X#include <string.h>
X#include <stdlib.h>
X#else
X#ifndef AMIGA_SC_6_1
Xextern char    *gets(), *getenv();
X#ifdef sequent
Xextern char    *strcpy(), *strncpy(), *strcat(), *index();
X#else
Xextern char    *strcpy(), *strncpy(), *strcat(), *strchr();
X#endif
Xextern int      strlen();
Xextern int      strcmp();
Xextern double   atof();
X#endif /* !AMIGA_SC_6_1 */
X#endif
X#else
X#ifdef __PUREC__
X/*
X * a substitute for PureC's buggy sscanf.
X * this uses the normal sscanf and fixes the following bugs:
X * - whitespace in format matches whitespace in string, but doesn't
X *   require any. ( "%f , %f" scans "1,2" correctly )
X * - the ignore value feature works (*). this created an address error
X *   in PureC.
X */
X
X#include <stdarg.h>
X#include <string.h>
X
Xint purec_sscanf( const char *string, const char *format, ... )
X{
X  va_list args;
X  int cnt=0;
X  char onefmt[256];
X  char buffer[256];
X  const char *f=format;
X  const char *s=string;
X  char *f2;
X  char ch;
X  int ignore;
X  void *p;
X  int *ip;
X  int pos;
X
X  va_start(args,format);
X  while( *f && *s ) {
X    ch=*f++;
X    if( ch!='%' ) {
X      if(isspace(ch)) {
X        /* match any number of whitespace */
X        while(isspace(*s)) s++;
X      } else {
X        /* match exactly the character ch */
X        if( *s!=ch ) goto finish;
X        s++;
X      }
X    } else {
X      /* we have got a '%' */
X      ch=*f++;
X      if( ch=='%' ) {
X        /* match exactly % */
X        if( *s!=ch ) goto finish;
X        s++;
X      } else {
X        f2=onefmt;
X        *f2++='%';
X        *f2++=ch;
X        ignore=0;
X        if( ch=='*' ) {
X          ignore=1;
X          ch=f2[-1]=*f++;
X        }
X        while( isdigit(ch) ) {
X          ch=*f2++=*f++;
X        }
X        if( ch=='l' || ch=='L' || ch=='h' ) {
X          ch=*f2++=*f++;
X        }
X        switch(ch) {
X          case '[':
X            while( ch && ch!=']' ) {
X              ch=*f2++=*f++;
X            }
X            if( !ch ) goto error;
X            break;
X          case 'e':
X          case 'f':
X          case 'g':
X          case 'd':
X          case 'o':
X          case 'i':
X          case 'u':
X          case 'x':
X          case 'c':
X          case 's':
X          case 'p':
X          case 'n': /* special case handled below */
X            break;
X          default:
X            goto error;
X        }
X        if( ch!='n' ) {
X          strcpy(f2,"%n");
X          if( ignore ) {
X            p=buffer;
X          } else {
X            p=va_arg(args,void *);
X          }
X          switch( sscanf( s, onefmt, p, &pos ) ) {
X            case EOF: goto error;
X            case  0 : goto finish;
X          }
X          if( !ignore ) cnt++;
X          s+=pos;
X        } else {
X          if( !ignore ) {
X            ip=va_arg(args,int *);
X            *ip=(int)(s-string);
X          }
X        }
X      }
X    }
X  }
X
X  if( !*f ) goto finish;
X
Xerror:
X  cnt=EOF;
Xfinish:
X  va_end(args);
X  return cnt;
X}
X
X/* use the substitute now. I know this is dirty trick, but it works. */
X#define sscanf purec_sscanf
X
X#endif /* __PUREC__ */
X#endif /* ATARI */
X
X/*
X * Only reference to contours library.
X */
Xextern struct gnuplot_contours *contour();
X
X#ifdef OS2
X /* emx has getcwd, chdir that can handle drive names */
X#define getcwd _getcwd2
X#define chdir  _chdir2
X#endif /* OS2 */
X
X#if defined(unix) && !defined(hpux)
X#ifdef GETCWD
Xextern char    *getcwd();	/* some Unix's use getcwd */
X#else
Xextern char    *getwd();	/* most Unix's use getwd */
X#endif
X#else
X#ifdef DJGPP
Xextern char    *getwd();	/* DJGPP acts like Unix here */
X#else
Xextern char    *getcwd();	/* Turbo C, MSC, EMX, OS2 and VMS use getcwd */
X#endif
X#endif
X
X#ifdef vms
Xint             vms_vkid;	/* Virtual keyboard id */
X#endif
X	
Xstatic FILE *data_fp=NULL;	/* != means file still open */
Xstatic TBOOLEAN more_data_fp=FALSE;  /* And this explicitly says so. */
X
X#if defined(unix) || defined(PIPES)
Xextern FILE    *popen();
Xstatic TBOOLEAN  pipe_open = FALSE;
X#endif
X
Xextern int      chdir();
X
Xextern double   magnitude(), angle(), real(), imag();
Xextern struct value *const_express(), *pop(), *Gcomplex();
Xextern struct at_type *temp_at(), *perm_at();
Xextern struct udft_entry *add_udf();
Xextern struct udvt_entry *add_udv();
Xextern void     squash_spaces();
Xextern void     lower_case();
X
X/* local functions */
Xstatic enum coord_type adjustlog();
X
Xextern TBOOLEAN  interactive;	/* from plot.c */
X
X/* input data, parsing variables */
Xstruct lexical_unit token[MAX_TOKENS];
Xchar            input_line[MAX_LINE_LEN + 1] = "";
Xint             num_tokens, c_token;
Xint             inline_num = 0;	/* input line number */
X
Xchar            c_dummy_var[MAX_NUM_VAR][MAX_ID_LEN + 1];	/* current dummy vars */
X
X/* the curves/surfaces of the plot */
Xstruct curve_points *first_plot = NULL;
Xstruct surface_points *first_3dplot = NULL;
Xstatic struct udft_entry plot_func;
Xstruct udft_entry *dummy_func;
X
X/* jev -- for passing data thru user-defined function */
Xstatic struct udft_entry ydata_func;
X
X/* support for replot command */
Xchar            replot_line[MAX_LINE_LEN + 1] = "";
Xstatic int      plot_token;	/* start of 'plot' command */
X
X/* If last plot was a 3d one. */
XTBOOLEAN         is_3d_plot = FALSE;
X
Xcom_line()
X{
X   if (read_line(PROMPT))
X       return(1);
X
X    /* So we can flag any new output: if false at time of error, */
X    /* we reprint the command line before printing caret. */
X    /* TRUE for interactive terminals, since the command line is typed. */
X    /* FALSE for non-terminal stdin, so command line is printed anyway. */
X    /* (DFK 11/89) */
X    screen_ok = interactive;
X
X    if (do_line())
X        return(1);
X     else
X        return(0);
X}
X
X
Xdo_line()
X{				/* also used in load_file */
X    if (is_system(input_line[0])) {
X	do_system();
X	(void) fputs("!\n", stderr);
X	return(0);
X    }
X    num_tokens = scanner(input_line);
X    c_token = 0;
X    while (c_token < num_tokens) {
X	if (command())
X           return(1);
X	if (c_token < num_tokens)	/* something after command */
X	    if (equals(c_token, ";"))
X		c_token++;
X	    else
X		int_error("';' expected", c_token);
X    }
X    return(0);
X}
X
X
X
Xcommand()
X{
X    FILE *fp, *lf_top();
X    int             i;
X    char            sv_file[MAX_LINE_LEN + 1];
X#if defined(__ZTC__)
X	unsigned dummy; /* it's a parameter needed for dos_setdrive */
X#endif
X    /* string holding name of save or load file */
X
X    for (i = 0; i < MAX_NUM_VAR; i++)
X	c_dummy_var[i][0] = '\0';	/* no dummy variables */
X
X    if (is_definition(c_token))
X	define();
X    else if (almost_equals(c_token, "h$elp") || equals(c_token, "?")) {
X	c_token++;
X	do_help();
X    } else if (almost_equals(c_token, "test")) {
X	c_token++;
X	test_term();
X    } else if (almost_equals(c_token, "scr$eendump")) {
X	c_token++;
X#ifdef _Windows
X	screen_dump();
X#else
X	fputs("screendump not implemented\n",stderr);
X#endif
X    } else if (almost_equals(c_token, "pa$use")) {
X	struct value    a;
X	int             stime, text = 0;
X	char            buf[MAX_LINE_LEN + 1];
X
X	c_token++;
X	stime = (int) real(const_express(&a));
X	buf[0]='\0';
X	if (!(END_OF_COMMAND)) {
X	    if (!isstring(c_token))
X		int_error("expecting string", c_token);
X	    else {
X		quotel_str(buf, c_token);
X#ifdef _Windows
X		if (stime>=0)
X#endif
X#ifdef OS2
X                if( strcmp(term_tbl[term].name, "pm" )!=0 || stime >=0 )
X#endif
X		(void) fprintf(stderr, "%s", buf);
X		text = 1;
X	    }
X	}
X	if (stime < 0)
X#ifdef _Windows
X        {
X            if (!Pause(buf))
X                 longjmp(env, TRUE); /* bail out to command line */
X         }
X#else
X#ifdef OS2
X        if( strcmp(term_tbl[term].name, "pm" )==0 && stime < 0 )
X        {
X            int rc ;
X            if( (rc=PM_pause( buf ))==0 ) longjmp(env,TRUE) ;
X            else if( rc==2 ) { 
X		(void) fprintf(stderr, "%s", buf);
X		text = 1;
X                (void) fgets(buf, MAX_LINE_LEN, stdin);
X                }
X        }
X#else
X	    (void) fgets(buf, MAX_LINE_LEN, stdin);
X	/* Hold until CR hit. */
X#endif /*OS2*/
X#endif
X#ifdef __ZTC__
X	if (stime > 0)
X	    usleep((unsigned long) stime);
X#else
X	if (stime > 0)
X	    sleep((unsigned int) stime);
X#endif
X	if (text != 0 && stime >= 0)
X	    (void) fprintf(stderr, "\n");
X	c_token++;
X	screen_ok = FALSE;
X    } else if (almost_equals(c_token, "pr$int")) {
X	struct value    a;
X
X	c_token++;
X	(void) const_express(&a);
X	(void) putc('\t', stderr);
X	disp_value(stderr, &a);
X	(void) putc('\n', stderr);
X	screen_ok = FALSE;
X    } else if (almost_equals(c_token, "p$lot")) {
X	plot_token = c_token++;
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT));
X#endif
X	plotrequest();
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_ARROW));
X#endif
X    } else if (almost_equals(c_token, "sp$lot")) {
X	plot_token = c_token++;
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT));
X#endif
X	plot3drequest();
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_ARROW));
X#endif
X    } else if (almost_equals(c_token, "rep$lot")) {
X	if (replot_line[0] == '\0')
X	    int_error("no previous plot", c_token);
X	c_token++;
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT));
X#endif
X	replotrequest();
X#ifdef _Windows
X	SetCursor(LoadCursor((HINSTANCE)NULL, IDC_ARROW));
X#endif
X    } else if (almost_equals(c_token, "se$t"))
X	set_command();
X    else if (almost_equals(c_token, "sh$ow"))
X	show_command();
X    else if (almost_equals(c_token, "cl$ear")) {
X	if (!term_init) {
X	    (*term_tbl[term].init) ();
X	    term_init = TRUE;
X	}
X	(*term_tbl[term].graphics) ();
X	(*term_tbl[term].text) ();
X	(void) fflush(outfile);
X	screen_ok = FALSE;
X	c_token++;
X    } else if (almost_equals(c_token, "she$ll")) {
X	do_shell();
X	screen_ok = FALSE;
X	c_token++;
X    } else if (almost_equals(c_token, "sa$ve")) {
X	if (almost_equals(++c_token, "f$unctions")) {
X	    if (!isstring(++c_token))
X		int_error("expecting filename", c_token);
X	    else {
X		quote_str(sv_file, c_token);
X		save_functions(fopen(sv_file, "w"));
X	    }
X	} else if (almost_equals(c_token, "v$ariables")) {
X	    if (!isstring(++c_token))
X		int_error("expecting filename", c_token);
X	    else {
X		quote_str(sv_file, c_token);
X		save_variables(fopen(sv_file, "w"));
X	    }
X	} else if (almost_equals(c_token, "s$et")) {
X	    if (!isstring(++c_token))
X		int_error("expecting filename", c_token);
X	    else {
X		quote_str(sv_file, c_token);
X		save_set(fopen(sv_file, "w"));
X	    }
X	} else if (isstring(c_token)) {
X	    quote_str(sv_file, c_token);
X	    save_all(fopen(sv_file, "w"));
X	} else {
X	    int_error(
X			 "filename or keyword 'functions', 'variables', or 'set' expected",
X			 c_token);
X	}
X	c_token++;
X    } else if (almost_equals(c_token, "l$oad")) {
X	if (!isstring(++c_token))
X	    int_error("expecting filename", c_token);
X	else {
X	    quote_str(sv_file, c_token);
X	    load_file(fp=fopen(sv_file, "r"), sv_file);
X	    /* input_line[] and token[] now destroyed! */
X	    c_token = num_tokens = 0;
X	}
X    } else if (almost_equals(c_token,"rer$ead")) {
X            fp = lf_top();
X            if (fp != (FILE *)NULL) rewind(fp);
X            c_token++;
X    } else if (almost_equals(c_token, "cd")) {
X	if (!isstring(++c_token))
X	    int_error("expecting directory name", c_token);
X	else {
X	    quotel_str(sv_file, c_token);
X#if defined(MSDOS) || defined(_Windows) || defined(ATARI) || defined(DOS386)
X	    if (!((strlen(sv_file)==2) && isalpha(sv_file[0]) && (sv_file[1]==':')))
X#endif
X	    if (chdir(sv_file)) {
X		int_error("Can't change to this directory", c_token);
X	    }
X#if defined(MSDOS) || defined(_Windows) || defined(ATARI) || defined(DOS386)
X	    if (isalpha(sv_file[0]) && (sv_file[1]==':')) {
X#ifdef ATARI
X		(void)Dsetdrv(toupper(sv_file[0])-'A');
X#endif
X
X#if defined(__ZTC__)
X	  (void)dos_setdrive(toupper(sv_file[0]) - 'A' + 1, &dummy);
X#endif
X
X#if defined(MSDOS) && defined(__EMX__)
X		(void)_chdrive(toupper(sv_file[0]));
X#endif
X#if defined(__MSC__)
X		(void)_chdrive(toupper(sv_file[0])-'A');
X#endif
X#if (defined(MSDOS) || defined(_Windows)) && defined(__TURBOC__)
X		(void) setdisk(toupper(sv_file[0])-'A');
X#endif
X#ifdef DJGPP
X		{ union REGS r;
X			r.h.ah = 0x0e;
X			r.x.dx = toupper(sv_file[0])-'A';
X			intdos(&r, &r);
X		}
X#endif
X	    }
X#endif
X	    c_token++;
X	}
X    } else if (almost_equals(c_token, "pwd")) {
X#if defined(unix) && !defined(hpux)
X#ifdef GETCWD
X	(void) getcwd(sv_file, MAX_ID_LEN);	/* some Unix's use getcwd */
X#else
X	(void) getwd(sv_file);	/* most Unix's use getwd */
X#endif
X#else
X#ifdef __EMX__
X	(void) _getcwd2(sv_file, MAX_ID_LEN);
X#else
X	/* Turbo C and VMS have getcwd() */
X	(void) getcwd(sv_file, MAX_ID_LEN);
X#endif
X#endif
X#ifdef DJGPP
X	{ union REGS r;
X		r.h.ah = 0x19;
X		intdos(&r, &r);
X		fprintf(stderr, "%c:", r.h.al + 'a');
X	}
X#endif
X	fprintf(stderr, "%s\n", sv_file);
X	c_token++;
X    } else if (almost_equals(c_token, "ex$it") ||
X	       almost_equals(c_token, "q$uit")) {
X	return(1);
X    } else if (!equals(c_token, ";")) {	/* null statement */
X	int_error("invalid command", c_token);
X    }
X    return(0);
X}
X
Xreplotrequest()
X{
X    char            str[MAX_LINE_LEN + 1];
X    if (equals(c_token, "["))
X	int_error("cannot set range with replot", c_token);
X    if (!END_OF_COMMAND) {
X	capture(str, c_token, num_tokens - 1);
X	if ((strlen(str) + strlen(replot_line)) <= MAX_LINE_LEN - 1) {
X	    (void) strcat(replot_line, ",");
X	    (void) strcat(replot_line, str);
X	} else {
X	    int_error("plot line too long with replot arguments", c_token);
X	}
X    }
X    (void) strcpy(input_line, replot_line);
X    screen_ok = FALSE;
X    num_tokens = scanner(input_line);
X    c_token = 1;		/* skip the 'plot' part */
X    is_3d_plot ? plot3drequest() : plotrequest();
X}
X
X
Xplotrequest()
X/*
X * In the parametric case we can say plot [a= -4:4] [-2:2] [-1:1] sin(a),a**2
X * while in the non-parametric case we would say only plot [b= -2:2] [-1:1]
X * sin(b)
X */
X{
X    TBOOLEAN         changed;
X    int             dummy_token = -1;
X
X    is_3d_plot = FALSE;
X
X    if (parametric && strcmp(dummy_var[0], "u") == 0)
X	strcpy(dummy_var[0], "t");
X
X    autoscale_lt = autoscale_t;
X    autoscale_lx = autoscale_x;
X    autoscale_ly = autoscale_y;
X
X    if (!term)			/* unknown */
X	int_error("use 'set term' to set terminal type first", c_token);
X
X    if (equals(c_token, "[")) {
X	c_token++;
X	if (isletter(c_token)) {
X	    if (equals(c_token + 1, "=")) {
X		dummy_token = c_token;
X		c_token += 2;
X	    } else {
X		/* oops; probably an expression with a variable. */
X		/* Parse it as an xmin expression. */
X		/* used to be: int_error("'=' expected",c_token); */
X	    }
X	}
X	changed = parametric ? load_range(&tmin, &tmax) : load_range(&xmin, &xmax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed) {
X	    if (parametric)
X		autoscale_lt = FALSE;
X	    else
X		autoscale_lx = FALSE;
X	}
X    }
X    if (parametric && equals(c_token, "[")) {	/* set optional x ranges */
X	c_token++;
X	changed = load_range(&xmin, &xmax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X		if(parametric)
X			autoscale_lt = FALSE;
X		else
X	   	 	autoscale_lx = FALSE;
X    }
X    if (equals(c_token, "[")) {	/* set optional y ranges */
X	c_token++;
X	changed = load_range(&ymin, &ymax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X	    autoscale_ly = FALSE;
X    }
X    /* use the default dummy variable unless changed */
X    if (dummy_token >= 0)
X	copy_str(c_dummy_var[0], dummy_token);
X    else
X	(void) strcpy(c_dummy_var[0], dummy_var[0]);
X
X    eval_plots();
X}
X
Xplot3drequest()
X/*
X * in the parametric case we would say splot [u= -Pi:Pi] [v= 0:2*Pi] [-1:1]
X * [-1:1] [-1:1] sin(v)*cos(u),sin(v)*cos(u),sin(u) in the non-parametric
X * case we would say only splot [x= -2:2] [y= -5:5] sin(x)*cos(y)
X * 
X */
X{
X    TBOOLEAN         changed;
X    int             dummy_token0 = -1, dummy_token1 = -1;
X
X    is_3d_plot = TRUE;
X
X    if (parametric && strcmp(dummy_var[0], "t") == 0) {
X	strcpy(dummy_var[0], "u");
X	strcpy(dummy_var[1], "v");
X    }
X    autoscale_lx = autoscale_x;
X    autoscale_ly = autoscale_y;
X    autoscale_lz = autoscale_z;
X
X    if (!term)			/* unknown */
X	int_error("use 'set term' to set terminal type first", c_token);
X
X    if (equals(c_token, "[")) {
X	c_token++;
X	if (isletter(c_token)) {
X	    if (equals(c_token + 1, "=")) {
X		dummy_token0 = c_token;
X		c_token += 2;
X	    } else {
X		/* oops; probably an expression with a variable. */
X		/* Parse it as an xmin expression. */
X		/* used to be: int_error("'=' expected",c_token); */
X	    }
X	}
X	changed = parametric ? load_range(&umin, &umax) : load_range(&xmin, &xmax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X		if(parametric) 
X			autoscale_lu = FALSE;
X		else
X	    	autoscale_lx = FALSE;
X    }
X    if (equals(c_token, "[")) {
X	c_token++;
X	if (isletter(c_token)) {
X	    if (equals(c_token + 1, "=")) {
X		dummy_token1 = c_token;
X		c_token += 2;
X	    } else {
X		/* oops; probably an expression with a variable. */
X		/* Parse it as an xmin expression. */
X		/* used to be: int_error("'=' expected",c_token); */
X	    }
X	}
X	changed = parametric ? load_range(&vmin, &vmax) : load_range(&ymin, &ymax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X		if(parametric) 
X			autoscale_lv = FALSE;
X		else
X	    	autoscale_ly = FALSE;
X    }
X    if (equals(c_token, "[")) {	/* set optional x (parametric) or z ranges */
X	c_token++;
X	changed = parametric ? load_range(&xmin, &xmax) : load_range(&zmin, &zmax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X		if(parametric) 
X			autoscale_lx = FALSE;
X		else
X	    	autoscale_lz = FALSE;
X    }
X    if (equals(c_token, "[")) {	/* set optional y ranges */
X	c_token++;
X	changed = load_range(&ymin, &ymax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X	    autoscale_ly = FALSE;
X    }
X    if (equals(c_token, "[")) {	/* set optional z ranges */
X	c_token++;
X	changed = load_range(&zmin, &zmax);
X	if (!equals(c_token, "]"))
X	    int_error("']' expected", c_token);
X	c_token++;
X	if (changed)
X	    autoscale_lz = FALSE;
X    }
X    /* use the default dummy variable unless changed */
X    if (dummy_token0 >= 0)
X	copy_str(c_dummy_var[0], dummy_token0);
X    else
X	(void) strcpy(c_dummy_var[0], dummy_var[0]);
X
X    if (dummy_token1 >= 0)
X	copy_str(c_dummy_var[1], dummy_token1);
X    else
X	(void) strcpy(c_dummy_var[1], dummy_var[1]);
X
X    eval_3dplots();
X}
X
X
Xdefine()
X{
X    register int    start_token;/* the 1st token in the function definition */
X    register struct udvt_entry *udv;
X    register struct udft_entry *udf;
X
X    if (equals(c_token + 1, "(")) {
X	/* function ! */
X	int             dummy_num = 0;
X	start_token = c_token;
X	do {
X	    c_token += 2;	/* skip to the next dummy */
X	    copy_str(c_dummy_var[dummy_num++], c_token);
X	} while (equals(c_token + 1, ",") && (dummy_num < MAX_NUM_VAR));
X	if (equals(c_token + 1, ","))
X	    int_error("function contains too many parameters", c_token + 2);
X	c_token += 3;		/* skip (, dummy, ) and = */
X	if (END_OF_COMMAND)
X	    int_error("function definition expected", c_token);
X	udf = dummy_func = add_udf(start_token);
X	if (udf->at)		/* already a dynamic a.t. there */
X	    free((char *) udf->at);	/* so free it first */
X	if ((udf->at = perm_at()) == (struct at_type *) NULL)
X	    int_error("not enough memory for function", start_token);
X	m_capture(&(udf->definition), start_token, c_token - 1);
X    } else {
X	/* variable ! */
X	start_token = c_token;
X	c_token += 2;
X	udv = add_udv(start_token);
X	(void) const_express(&(udv->udv_value));
X	udv->udv_undef = FALSE;
X    }
X}
X
Xget_data(this_plot)
X    struct curve_points *this_plot;
X{
X	register int    i, j, l_num, datum;
X	int fcol[5], scol[5], ncol[5], prevmin, col;
X	char  format[MAX_LINE_LEN + 1], data_file[MAX_LINE_LEN + 1],
X	      line[MAX_LINE_LEN + 1];
X	/* conversion variables */
X	int n, m, linestat, using;
X	char *s;
X	double val[5], v[5];
X	float fval[5];	/* for use in sscanf */
X
X	/* close forgotten input file (in case of a syntax error) */
X	if( data_fp ) {
X#if defined(unix) || defined(PIPES)
X		if (pipe_open) {
X			(void) pclose(data_fp);
X			pipe_open = FALSE;
X		} else
X#endif /* unix || PIPES */
X		(void) fclose(data_fp);
X		data_fp=NULL;
X	}
X
X	quotel_str(data_file, c_token);
X	this_plot->plot_type = DATA;
X/*	if (parametric)
X		int_error("Parametric data files not yet implemented", NO_CARET);
X*/
X#if defined(unix) || defined(PIPES)
X	if (*data_file == '<') {
X		if ((data_fp = popen(data_file + 1, "r")) == (FILE *) NULL)
X			os_error("cannot create pipe for data", c_token);
X		else
X			pipe_open = TRUE;
X	} else
X#endif /* unix || PIPES */
X	if ((data_fp = fopen(data_file, "r")) == (FILE *) NULL)
X		os_error("can't open data file", c_token);
X
X	format[0] = '\0';
X	for (i=0; i<5; i++)
X		fcol[i] = i+1;
X
X	using = 0;
X	c_token++;			/* skip data file name */
X
X	/* jev -- support for passing data from file thru user function */
X	if (almost_equals(c_token, "thru$")) {
X		c_token++;
X		if (ydata_func.at)
X			free(ydata_func.at);
X		dummy_func = &ydata_func;
X		ydata_func.at = perm_at();
X	} else {
X		if (ydata_func.at)
X			free(ydata_func.at);
X		ydata_func.at = NULL;
X	}
X
X	if (almost_equals(c_token,"u$sing")) {
X		using = 1;
X		c_token++;  	/* skip "using" */
X			
X		if (!END_OF_COMMAND && !isstring(c_token)) {
X			struct value a;
X			for (i=0; i<5; i++)
X				fcol[i] = -1;
X			fcol[0] = (int)magnitude(const_express(&a));
X			for (i=1; equals(c_token,":") && i<5; i++) {
X				c_token++;      /* skip ":" */
X				fcol[i] = (int)magnitude(const_express(&a));
X			}
X		}
X
X		if (!END_OF_COMMAND && isstring(c_token)) {
X			quotel_str(format, c_token);
X			c_token++;	/* skip format */
X		}
X	}
X    
X	/* sort fcol[] into scol[] removing duplicates */
X	prevmin = 0;
X	for (i=0; i<5; i++) {
X	    col = 10000;
X		for (j=0; j<5; j++)
X			if ((fcol[j]>prevmin) && (fcol[j]<col))
X				col = fcol[j];
X		if (col <10000)
X   		    prevmin = scol[i] = col;
X		else
X			scol[i] = 0;
X	}
X	/* normalise fcol[] into ncol[] */
X	for (i=0; i<5; i++) {
X		if (fcol[i] > 0)
X			for (j=0; j<5; j++) {
X				if (fcol[i] == scol[j])
X					ncol[i] = j+1;
X			}
X		else if (fcol[i] == 0)
X			ncol[i] = 0;
X		else
X			ncol[i] = -1;
X	}
X	/* set col to highest column number */
X	col = 0;
X	for (i=0; i<5; i++) 
X		if (fcol[i]>col) col=fcol[i];
X
X	l_num = 0;
X	datum = 0;
X	i = 0;
X	while (fgets(line, MAX_LINE_LEN, data_fp) != (char *) NULL) {
X		l_num++;
X		if (is_comment(line[0]))
X	    	continue;		/* ignore comments */
X		if (i >= this_plot->p_max) {
X			/*
X			 * overflow about to occur. Extend size of points[] array. We
X			 * either double the size, or add 1000 points, whichever is a
X			 * smaller increment. Note i=p_max.
X			 */
X	    	cp_extend(this_plot, i + (i < 1000 ? i : 1000));
X		}
X		if (!line[1]) {		/* is it blank line ? */
X			/* break in data, make next point undefined */
X			this_plot->points[i].type = UNDEFINED;
X			i++;
X			continue;
X		}
X		if (strlen(format) != 0) {
X			/* use old sscanf if a format string was given */
X			m = sscanf(line, format, &fval[0], &fval[1], &fval[2], &fval[3], &fval[4]);
X			for (n=0; n<5; n++)		/* convert floats from sscanf to double */
X				val[n] = (double)fval[n];
X
X			for (j=0; j<5 && fcol[j]>=0 && fcol[j]-1<m ; j++)
X				if (fcol[j])
X					v[j] = val[fcol[j]-1];
X				else
X					v[j] = datum;	/* using 0:n */
X		}
X		else {
X			/* implement our own sscanf that skips lines with invalid data 
X			 * if a using statement was given */
X			/* convert the array to its constituents */
X			for(n=0; n<5; n++)			/* wipe the array */
X				val[n] = 0.0;
X			n=0;						/* n is column number */
X			m=0;						/* m is number of values read */
X			linestat = 1;				/* linestat: 1 OK 2 bad value 0 EOL */
X			s = line;
X			while ((linestat == 1) && (n<col)) {
X				while (isspace(*s)) s++;
X				if (*s == '\0') {
X					linestat = 0;
X					break;
X				}
X				n++;
X				if (n == scol[m]) {
X					if (isdigit(*s) || *s=='-' || *s=='+' || *s=='.') {
X						val[m] = atof(s);
X						m++;
X					}
X					else
X						linestat = 2;	/* abort the line non-digit in req loc */
X				}
X				while ((!isspace(*s)) && (*s != '\0')) s++;
X			}
X
X			if (using && (linestat == 2))
X				continue;	/* skip lines where a using pattern is present and not met */
X
X			for (j=0; j<5 && ncol[j]>=0 && ncol[j]-1<m ; j++)
X				if (ncol[j])
X					v[j] = val[ncol[j]-1];
X				else
X					v[j] = datum;	/* using 0:n */
X		}
X
X		switch (j) {
X		    case 1: {		/* only one number */
X		    	/* x is index, assign number to y */
X				v[1]=v[0];
X				v[0]=datum;
X				/* nobreak */
X		    }
X		    case 2: {		/* x, y */
X				/* ylow and yhigh are same as y */
X				datum++;
X				store2d_point(this_plot, i++, v[0], v[1], v[1], v[1], -1.0);
X				break;
X		    }
X		    case 3: {		/* x, y, ydelta */
X				/* ydelta is in the ylow variable */
X				datum++;
X				store2d_point(this_plot, i++, v[0], v[1], v[1]-v[2], v[1]+v[2], -1.0);
X				break;
X		    }
X		    case 4: {		/* x, y, ylow, yhigh */
X				datum++;
X				store2d_point(this_plot, i++, v[0], v[1], v[2], v[3], -1.0);
X				break;
X		    }
X		    case 5: {		/* x, y, ylow, yhigh, width */
X				datum++;
X				store2d_point(this_plot, i++, v[0], v[1], v[2], v[3], v[4]);
X				break;
X		    }
X		    default: {
X				(void) sprintf(line, "bad data on line %d", l_num);
X        		/* close file before exiting to command level */
X#if defined(unix) || defined(PIPES)
X				if (pipe_open) {
X					(void) pclose(data_fp);
X					pipe_open = FALSE;
X				} else
X#endif /* unix || PIPES */
X					(void) fclose(data_fp);
X				data_fp=NULL;
X				int_error(line, c_token);
X		    }
X		}
X	}
X	this_plot->p_count = i;
X	cp_extend(this_plot, i);	/* shrink to fit */
X
X#if defined(unix) || defined(PIPES)
X	if (pipe_open) {
X		(void) pclose(data_fp);
X		pipe_open = FALSE;
X	} else
X#endif /* unix || PIPES */
X	(void) fclose(data_fp);
X	data_fp=NULL;
X}
X
X
X/* called by get_data for each point */
Xstore2d_point(this_plot, i, x, y, ylow, yhigh, width)
X    struct curve_points *this_plot;
X    int             i;		/* point number */
X    double          x, y;
X    double          ylow, yhigh;
X    double          width;
X{
X    struct coordinate GPHUGE *cp = &(this_plot->points[i]);
X
X    /* the easy part: */
X    cp->type = INRANGE;
X    cp->x = x;
X    cp->y = y;
X    cp->ylow = ylow;
X    cp->yhigh = yhigh;
X    cp->z = width;
X
X    /* jev -- pass data values thru user-defined function */
X    if (ydata_func.at) {
X	struct value    val;
X
X	(void) Gcomplex(&ydata_func.dummy_values[0], y, 0.0);
X	evaluate_at(ydata_func.at, &val);
X	cp->y = real(&val);
X
X	(void) Gcomplex(&ydata_func.dummy_values[0], ylow, 0.0);
X	evaluate_at(ydata_func.at, &val);
X	cp->ylow = real(&val);
X
X	(void) Gcomplex(&ydata_func.dummy_values[0], yhigh, 0.0);
X	evaluate_at(ydata_func.at, &val);
X	cp->yhigh = real(&val);
X    }
X    /* Adjust for log scale. */
X    if (is_log_x) {
X	    cp->type = adjustlog(cp->type, &(cp->x), log_base_log_x);
X        (void) adjustlog(cp->type, &(cp->z), log_base_log_z);
X    }
X    if (is_log_y) {
X	cp->type = adjustlog(cp->type, &(cp->y), log_base_log_y);
X	/* Note ylow,yhigh can't affect cp->type. */
X	(void) adjustlog(cp->type, &(cp->ylow), log_base_log_y);
X	(void) adjustlog(cp->type, &(cp->yhigh), log_base_log_y);
X    }
X    /* Now adjust the xrange, or declare the point out of range */
X    /*
X     * The yrange is handled later, once we know whether to include ylow,
X     * yhigh in the calculation. See adjust_yrange()
X     */
X    if (cp->type == INRANGE)
X	if (autoscale_lx || inrange(x, xmin, xmax)) {
X	    if (autoscale_lx) {
X		if (x < xmin)
X		    xmin = x;
X		if (x > xmax)
X		    xmax = x;
X	    }
X	} else {
X	    cp->type = OUTRANGE;
X	}
X}
X
X
X/*
X * Adjust for log scale: take the log of the second parameter, in place, if
X * possible. If not possible, return new type for point; if possible, then
X * return old type for point.  The log is taken to the base implicit in the
X * third parameter.
X */
Xstatic enum coord_type
Xadjustlog(type, val, log_base_log)
X    enum coord_type type;
X    coordval       *val;
X    double          log_base_log;
X{
X    if (*val < 0.0) {
X	return (UNDEFINED);
X    } else if (*val == 0.0) {
X	*val = -VERYLARGE;
X	return (OUTRANGE);
X    } else {
X	*val = log(*val)/log_base_log;
X	return (type);
X    }
X}
X
X
X/* now adjust the yrange, or declare the point out of range */
X/* this does all points in a curve */
Xadjust_yrange(curve)
X    struct curve_points *curve;
X{
X    TBOOLEAN         ebars = (curve->plot_style == ERRORBARS);
X    int             npoints = curve->p_count;	/* number of points */
X    coordval        y, ylow, yhigh;	/* one point value */
X    struct coordinate GPHUGE *cp;	/* one coordinate */
X    int             i;		/* index into points */
X
X    for (i = 0; i < npoints; i++) {
X	cp = &(curve->points[i]);
X	if (cp->type == INRANGE) {
X	    y = is_log_y ? pow(base_log_y, cp->y) : cp->y;
X	    if ((autoscale_ly ||
X	    /*
X	     * inrange((is_log_y ? pow(base_log_y, y) : y), ymin, ymax) ||
X	     */
X		 inrange((y), ymin, ymax) ||
X		 polar)) {
X		if (autoscale_ly) {
X		    if (y < ymin)
X			ymin = y;
X		    if (y > ymax)
X			ymax = y;
X		    if (ebars) {
X			ylow = is_log_y ? pow(base_log_y, cp->ylow) : cp->ylow;
X			yhigh = is_log_y ? pow(base_log_y, cp->yhigh) : cp->yhigh;
X			if (ylow < ymin)
X			    ymin = ylow;
X			if (ylow > ymax)
X			    ymax = ylow;
X			if (yhigh < ymin)
X			    ymin = yhigh;
X			if (yhigh > ymax)
X			    ymax = yhigh;
X		    }
X		}
X	    } else {
X		cp->type = OUTRANGE;
X	    }
X	}
X    }
X}
X
Xgrid_nongrid_data(this_plot)
Xstruct surface_points *this_plot;
X{
X    int i, j, k;
X    double x, y, z, w, dx, dy, xmin, xmax, ymin, ymax;
X    struct iso_curve *old_iso_crvs = this_plot->iso_crvs;
X    struct iso_curve *icrv, *oicrv, *oicrvs;
X
X    /* Compute XY bounding box on the original data. */
X    xmin = xmax = old_iso_crvs->points[0].x;
X    ymin = ymax = old_iso_crvs->points[0].y;
X    for (icrv = old_iso_crvs; icrv != NULL; icrv = icrv->next) {
X	struct coordinate GPHUGE *points = icrv->points;
X
X	for (i = 0; i < icrv->p_count; i++, points++) {
X	    if (xmin > points->x)
X		xmin = points->x;
X	    if (xmax < points->x)
X		xmax = points->x;
X	    if (ymin > points->y)
X		ymin = points->y;
X	    if (ymax < points->y)
X		ymax = points->y;
X	}
X    }
X
X    dx = (xmax - xmin) / (dgrid3d_row_fineness - 1);
X    dy = (ymax - ymin) / (dgrid3d_row_fineness - 1);
X
X    /* Create the new grid structure, and compute the low pass filtering from
X     * non grid to grid structure.
X     */
X    this_plot->iso_crvs = NULL;
X    this_plot->num_iso_read = dgrid3d_col_fineness;
X    this_plot->has_grid_topology = TRUE;
X    for (i = 0, x = xmin; i < dgrid3d_col_fineness; i++, x += dx) {
X	struct coordinate GPHUGE *points;
X
X	icrv = iso_alloc(dgrid3d_row_fineness + 1);
X	icrv->p_count = dgrid3d_row_fineness;
X	icrv->next = this_plot->iso_crvs;
X	this_plot->iso_crvs = icrv;
X	points = icrv->points;
X
X	for (j = 0, y = ymin; j < dgrid3d_row_fineness; j++, y += dy, points++) {
X	    z = w = 0.0;
X
X	    for (oicrv = old_iso_crvs; oicrv != NULL; oicrv = oicrv->next) {
X		struct coordinate GPHUGE *opoints = oicrv->points;
X		for (k = 0; k < oicrv->p_count; k++, opoints++) {
X		    double dist,
X			   dist_x = fabs( opoints->x - x ),
X			   dist_y = fabs( opoints->y - y );
X
X		    switch (dgrid3d_norm_value) {
X			case 1:
X			    dist = dist_x + dist_y;
X			    break;
X			case 2:
X			    dist = dist_x * dist_x + dist_y * dist_y;
X			    break;
X			case 4:
X			    dist = dist_x * dist_x + dist_y * dist_y;
X			    dist *= dist;
X			    break;
X			case 8:
X			    dist = dist_x * dist_x + dist_y * dist_y;
X			    dist *= dist;
X			    dist *= dist;
X			    break;
X			case 16:
X			    dist = dist_x * dist_x + dist_y * dist_y;
X			    dist *= dist;
X			    dist *= dist;
X			    dist *= dist;
X			    break;
X			default:
X			    dist = pow( dist_x, dgrid3d_norm_value ) +
X				   pow( dist_y, dgrid3d_norm_value );
X			    break;
X		    }
X
X		    /* The weight of this point is inverse proportional
X		     * to the distance.
X		     */
X		    if ( dist == 0.0 )
X#ifndef AMIGA_SC_6_1
X			dist = VERYLARGE;
X#else /* AMIGA_SC_6_1 */
X			/* Multiplying VERYLARGE by opoints->z below
X			 * might yield Inf (i.e. a number that can't
X			 * be represented on the machine). This will
X			 * result in points->z being set to NaN. It's
X			 * better to have a pretty large number that is
X			 * also on the safe side... The numbers that are
X			 * read by gnuplot are float values anyway, so
X			 * they can't be bigger than FLT_MAX. So setting
X			 * dist to FLT_MAX^2 will make dist pretty large
X			 * with respect to any value that has been read. */
X			dist = ((double)FLT_MAX)*((double)FLT_MAX);
X#endif /* AMIGA_SC_6_1 */
X		    else
X			dist = 1.0 / dist;
X
X		    z += opoints->z * dist;
X		    w += dist;
X		}
X	    }
X
X	    points->x = x;
X	    points->y = y;
X	    points->z = z / w;
X	    points->type = INRANGE;
X	}
X    }
X	
X    /* Delete the old non grid data. */
X    for (oicrvs = old_iso_crvs; oicrvs != NULL;) {
X	oicrv = oicrvs;
X	oicrvs = oicrvs->next;
X	iso_free(oicrv);
X    }
X}
X
Xget_3ddata(this_plot)
X    struct surface_points *this_plot;
X{
X    register int    i, j, l_num, xdatum, ydatum;
X    float           x, y, z;
X    char            data_file[MAX_LINE_LEN + 1], line[MAX_LINE_LEN + 1];
X    char           *float_format = "%f", *float_skip = "%*f";
X    static TBOOLEAN  only_z = FALSE, using_format = FALSE;
X    static int      xcol = 1, ycol = 2, zcol = 3, index = -1;
X    static char     format[MAX_LINE_LEN + 1];
X    int		    pt_in_iso_crv = 0, maxcol, num_col;
X    enum XYZ_order_type {
X	XYZ, YXZ, ZXY, XZY, ZYX, YZX, XY, YX
X    }               xyz_order;
X    struct iso_curve *this_iso;
X
X    /* close forgotten file (in case of a syntax error) */
X    if (data_fp && !more_data_fp) {
X#if defined(unix) || defined(PIPES)
X	if (pipe_open) {
X	    (void) pclose(data_fp);
X	    pipe_open = FALSE;
X	} else
X#endif /* unix || PIPES */
X	    (void) fclose(data_fp);
X	    data_fp=NULL;
X        }
X
X    quotel_str(data_file, c_token);
X    this_plot->plot_type = DATA3D;
X    this_plot->has_grid_topology = TRUE;
X    if (!more_data_fp) {
X#if defined(unix) || defined(PIPES)
X	if (*data_file == '<') {
X	    if ((data_fp = popen(data_file + 1, "r")) == (FILE *) NULL)
X		os_error("cannot create pipe; output not changed", c_token);
X	    else
X		pipe_open = TRUE;
X	} else
X#endif /* unix || PIPES */
X	    if ((data_fp = fopen(data_file, "r")) == (FILE *) NULL)
X		os_error("can't open data file", c_token);
X
X	/* Initialize defualt values. */
X	only_z = FALSE;
X	using_format = FALSE;
X	xcol = 1;
X	ycol = 2;
X	zcol = 3;
X	index = -1;
X	format[0] = '\0';
X
X	c_token++;			/* skip data file name */
X	if (almost_equals(c_token, "i$ndex")) {
X	    struct value a;
X	    c_token++;		/* skip "index" */
X	    index = (int) magnitude(const_express(&a));
X	}
X	if (almost_equals(c_token, "u$sing")) {
X	    c_token++;		/* skip "using" */
X	    if (!END_OF_COMMAND && !isstring(c_token)) {
X		struct value a;
X		zcol = (int) magnitude(const_express(&a));
X		only_z = TRUE;
X		if (equals(c_token, ":")) {
X		    c_token++;	/* skip ":" */
X		    only_z = FALSE;
X		    ycol = zcol;
X		    zcol = (int) magnitude(const_express(&a));
X		    if (equals(c_token, ":")) {
X			c_token++;	/* skip ":" */
X			xcol = ycol;
X			ycol = zcol;
X			zcol = (int) magnitude(const_express(&a));
X		    } else {
X			if (mapping3d == MAP3D_CARTESIAN)
X			    int_error("Must specify 1 or 3 columns", c_token);
X			xcol = ycol;
X			ycol = zcol;
X		    }
X		}
X		if (!only_z)
X		    if ((xcol == ycol) || (ycol == zcol) || (xcol == zcol))
X			int_error("Columns must be distinct", c_token);
X	    }
X	    if (!END_OF_COMMAND && isstring(c_token)) {
X		quotel_str(format, c_token);
X		using_format = TRUE;
X		c_token++;		/* skip format */
X	    }
X	} else {
X	    if ( (only_z = !parametric) != FALSE)
X		zcol = 1;
X	}
X    }
X
X    switch (mapping3d) {
X    case MAP3D_CARTESIAN:
X	maxcol = (xcol > ycol) ? xcol : ycol;
X	maxcol = (maxcol > zcol) ? maxcol : zcol;
X	if (!only_z) {		/* Determine ordering of input columns */
X	    if (zcol == maxcol) {
X		if (xcol < ycol)
X		    xyz_order = XYZ;	/* scanf(x,y,z) */
X		else
X		    xyz_order = YXZ;	/* scanf(y,x,z) */
X	    } else if (ycol == maxcol) {
X		if (xcol < zcol)
X		    xyz_order = XZY;	/* scanf(x,z,y) */
X		else
X		    xyz_order = ZXY;	/* scanf(z,x,y) */
X	    } else {
X		if (ycol < zcol)
X		    xyz_order = YZX;	/* scanf(y,z,x) */
X		else
X		    xyz_order = ZYX;	/* scanf(z,y,x) */
X	    }
X	}
X	if (strlen(format) == 0) {
X	    if (only_z) {
X		for (i = 1; i <= zcol; i++)
X		    if (i == zcol)
X			(void) strcat(format, float_format);
X		    else
X			(void) strcat(format, float_skip);
X	    } else {
X		for (i = 1; i <= maxcol; i++)
X		    if ((i == xcol) || (i == ycol) || (i == zcol))
X			(void) strcat(format, float_format);
X		    else
X			(void) strcat(format, float_skip);
X	    }
X	}
X	break;
X    case MAP3D_SPHERICAL:
X    case MAP3D_CYLINDRICAL:
X	if (only_z)
X	    int_error("Two or three columns for spherical/cylindrical coords.", c_token);
X	maxcol = (xcol > ycol) ? xcol : ycol;
X	maxcol = (maxcol > zcol) ? maxcol : zcol;
X	xyz_order = (xcol < ycol) ? XY : YX;
X	for (i = 1; i <= maxcol; i++)
X	    if ((i == xcol) || (i == ycol))
X		(void) strcat(format, float_format);
X	    else
X		(void) strcat(format, float_skip);
X    }
X
X    l_num = 0;
X    xdatum = 0;
X    ydatum = 0;
X    this_plot->num_iso_read = 0;
X    this_plot->has_grid_topology = TRUE;
X    if (this_plot->iso_crvs != NULL) {
X	struct iso_curve *icrv, *icrvs = this_plot->iso_crvs;
X
X	while (icrvs) {
X	    icrv = icrvs;
X	    icrvs = icrvs->next;
X	    iso_free(icrv);
X	}
X	this_plot->iso_crvs = NULL;
X    }
X    if (!more_data_fp && is_binary_file(data_fp)) {	/* MOD--RKC */
X#if defined(MSDOS)||defined(ATARI)||defined(OS2)||defined(_Windows)||defined(DOS386)
X	/* file must be opened with binary flag. the old cr/lf problem again */
X#ifdef PIPES
X	if( pipe_open ) {
X	  pclose(data_fp);
X	  data_fp=NULL;
X	  pipe_open=FALSE;
X	  int_error("binary data from pipes is not implemented", NO_CARET);
X	}
X#endif
X	data_fp = freopen(data_file, "rb", data_fp);
X#endif
X	xdatum = get_binary_data(this_plot, data_fp, &this_iso);
X    } else {
X	int last_line_blank = FALSE;
X
X	more_data_fp = FALSE;
X
X	this_iso = iso_alloc(samples);
X
X	if (index > 0) { /* Skip data meshes until mesh index is reached. */
X	    int i = index;
X
X	    while (i--) {
X		while (fgets(line, MAX_LINE_LEN, data_fp) != (char *) NULL) {
X		    l_num++;
X
X		    if (!line[1]) {	/* is it blank line ? */
X			if (last_line_blank) /* Two consecutive blanks. */
X			    break;
X			last_line_blank = TRUE;
X		    }
X		    else
X			last_line_blank = FALSE;
X		}
X		if (feof(data_fp))
X		    int_error("mesh index overflow", NO_CARET);
X	    }
X	}   /* end of index skip */
X	
X	last_line_blank = FALSE;
X
X	while (fgets(line, MAX_LINE_LEN, data_fp) != (char *) NULL) {
X	    l_num++;
X	    if (is_comment(line[0]))
X		continue;	/* ignore comments */
X	    if (!line[1]) {	/* is it blank line ? */
X		if (last_line_blank) { /* Two consecutive blank lines. */
X		    more_data_fp = TRUE;
X		    break;
X		}
X		last_line_blank = TRUE;
X
X		if (pt_in_iso_crv == 0) {
X		    if (xdatum == 0)
X			continue;
X		    pt_in_iso_crv = xdatum;
X		}
X		if (xdatum > 0) {
X		    this_iso->p_count = xdatum;
X		    this_iso->next = this_plot->iso_crvs;
X		    this_plot->iso_crvs = this_iso;
X		    this_plot->num_iso_read++;
X
X		    if (xdatum != pt_in_iso_crv)
X			this_plot->has_grid_topology = FALSE;
X
X		    this_iso = iso_alloc(pt_in_iso_crv);
X		    xdatum = 0;
X		    ydatum++;
X		}
X		continue;
X	    }
X	    last_line_blank = FALSE;
X	    if (xdatum >= this_iso->p_max) {
X		/*
X		 * overflow about to occur. Extend size of points[] array. We
X		 * either double the size, or add 1000 points, whichever is a
X		 * smaller increment. Note i=p_max.
X		 */
X		iso_extend(this_iso,
X			   xdatum + (xdatum < 1000 ? xdatum : 1000));
X	    }
X	    switch (num_col = sscanf(line, format, &x, &y, &z)) {
X	    case 3:		/* All parameter are specified. */
X		if (!only_z || using_format) {
X		    switch (xyz_order) {
X		    case XYZ:	/* scanf(x,y,z) */
X			this_iso->points[xdatum].x = x;
X			this_iso->points[xdatum].y = y;
X			this_iso->points[xdatum].z = z;
X			break;
X		    case XZY:	/* scanf(x,z,y) */
X			this_iso->points[xdatum].x = x;
X			this_iso->points[xdatum].y = z;
X			this_iso->points[xdatum].z = y;
X			break;
X		    case YXZ:	/* scanf(y,x,z) */
X			this_iso->points[xdatum].x = y;
X			this_iso->points[xdatum].y = x;
X			this_iso->points[xdatum].z = z;
X			break;
X		    case ZXY:	/* scanf(z,x,y) */
X			this_iso->points[xdatum].x = y;
X			this_iso->points[xdatum].y = z;
X			this_iso->points[xdatum].z = x;
X			break;
X		    case YZX:	/* scanf(y,z,x) */
X			this_iso->points[xdatum].x = z;
X			this_iso->points[xdatum].y = x;
X			this_iso->points[xdatum].z = y;
X			break;
X		    case ZYX:	/* scanf(z,y,x) */
X			this_iso->points[xdatum].x = z;
X			this_iso->points[xdatum].y = y;
X			this_iso->points[xdatum].z = x;
X			break;
X		    }
X		    if (xyz_order != XYZ) {
X			x = this_iso->points[xdatum].x;
X			y = this_iso->points[xdatum].y;
X			z = this_iso->points[xdatum].z;
X		    }
X		    if (!parametric)
X			int_error("Must be in parametric mode.",
X				  NO_CARET);
X		    break;
X		}
X	    case 1:		/* only one number on the line */
X		if (!only_z && !using_format)
X		    int_error("3 columns expected, only 1 found", c_token);
X		/* assign that number to z */
X		this_iso->points[xdatum].z = x;
X		z = x;
X		this_iso->points[xdatum].x = xdatum;
X		x = this_iso->points[xdatum].x;
X		this_iso->points[xdatum].y = ydatum;
X		y = this_iso->points[xdatum].y;
X		if (parametric)
X		    int_error("Must be in non parametric mode.",
X			      NO_CARET);
X		break;
X	    case 2:
X		switch (xyz_order) {
X		case YX:
X		    z = x;	/* Use z as temp */
X		    x = y;
X		    y = z;
X		    break;
X		default:
X		    break;
X		}
X		switch (mapping3d) {
X		case MAP3D_CARTESIAN:
X		    int_error("2 columns found, 1 or 3 expected",
X			      c_token);
X		    break;
X		case MAP3D_SPHERICAL:
X		    if (angles_format == ANGLES_DEGREES) {
X			x *= DEG2RAD;	/* Convert to radians. */
X			y *= DEG2RAD;
X		    }
X		    if( num_col == 2) z = 1.0;
X		    this_iso->points[xdatum].x = z*cos(x) * cos(y);
X		    this_iso->points[xdatum].y = z*sin(x) * cos(y);
X		    this_iso->points[xdatum].z = z*sin(y);
X		    break;
X		case MAP3D_CYLINDRICAL:
X		    if (angles_format == ANGLES_DEGREES)
X			x *= DEG2RAD;	/* Convert to radians. */
X		    if( num_col == 2) z = 1.0;
X		    this_iso->points[xdatum].x = z*cos(x);
X		    this_iso->points[xdatum].y = z*sin(x);
X		    this_iso->points[xdatum].z = y;
X		    break;
X		}
X		x = this_iso->points[xdatum].x;
X		y = this_iso->points[xdatum].y;
X		z = this_iso->points[xdatum].z;
X		break;
X	    default:
X		(void) sprintf(line, "bad data on line %d", l_num);
X		int_error(line, c_token);
X	    }
X
X	    if (is_log_x) {
X		if (x <= 0.0)
X		    int_error("X value must be above 0 for log scale!",
X			      NO_CARET);
X		else
X		    this_iso->points[xdatum].x =
X			log(this_iso->points[xdatum].x)/log_base_log_x;
X	    }
X	    if (is_log_y) {
X		if (y <= 0.0)
X		    int_error("Y value must be above 0 for log scale!",
X			      NO_CARET);
X		else
X		    this_iso->points[xdatum].y =
X			log(this_iso->points[xdatum].y)/log_base_log_y;
X	    }
X	    if (is_log_z) {
X		if (z <= 0.0)
X		    int_error("Z value must be above 0 for log scale!",
X			      NO_CARET);
X		else
X		    this_iso->points[xdatum].z =
X			log(this_iso->points[xdatum].z)/log_base_log_z;
X	    }
X	    if (autoscale_lx) {
X		if (x < xmin)
X		    xmin = x;
X		if (x > xmax)
X		    xmax = x;
X	    }
X	    if (autoscale_ly) {
X		if (y < ymin)
X		    ymin = y;
X		if (y > ymax)
X		    ymax = y;
X	    }
X	    if (autoscale_lz) {
X		if (z < zmin)
X		    zmin = z;
X		if (z > zmax)
X		    zmax = z;
X	    }
X	    xdatum++;	
X	}  /* end of while loop */
X
X	if (xdatum > 0) {
X	    this_plot->num_iso_read++;	/* Update last iso. */
X	    this_iso->p_count = xdatum;
X
X	    this_iso->next = this_plot->iso_crvs;
X	    this_plot->iso_crvs = this_iso;
X
X	    if (xdatum != pt_in_iso_crv)
X		this_plot->has_grid_topology = FALSE;
X
X	} else {
X	    iso_free(this_iso);	/* Free last allocation. */
X	}
X    }				/* MOD-RKC else of binary */
X
X    if (index >= 0) more_data_fp = FALSE; /* Only one data set please. */
X
X    if (!more_data_fp) {
X      if (this_plot->num_iso_read <= 1)
X  	this_plot->has_grid_topology = FALSE;
X#if defined(unix) || defined(PIPES)
X      if (pipe_open) {
X	if (this_plot->has_grid_topology && !hidden3d) {
X	  (void) pclose(data_fp);
X	  pipe_open = FALSE;
X	}
X      } else 
X#endif /* unix || PIPES */
X      {
X	(void) fclose(data_fp);  
X	data_fp = NULL;
X      }
X    }
X
X    if (dgrid3d) grid_nongrid_data(this_plot);
X
X    if (this_plot->num_iso_read <= 1)
X	this_plot->has_grid_topology = FALSE;
X    if (this_plot->has_grid_topology && !hidden3d) {
X	struct iso_curve *new_icrvs = NULL;
X	int             num_new_iso = this_plot->iso_crvs->p_count, len_new_iso = this_plot->num_iso_read;
X
X	/* Now we need to set the other direction (pseudo) isolines. */
X	for (i = 0; i < num_new_iso; i++) {
X	    struct iso_curve *new_icrv = iso_alloc(len_new_iso);
X
X	    new_icrv->p_count = len_new_iso;
X
X	    for (j = 0, this_iso = this_plot->iso_crvs;
X		 this_iso != NULL;
X		 j++, this_iso = this_iso->next) {
X		new_icrv->points[j].x = this_iso->points[i].x;
X		new_icrv->points[j].y = this_iso->points[i].y;
X		new_icrv->points[j].z = this_iso->points[i].z;
X	    }
X
X	    new_icrv->next = new_icrvs;
X	    new_icrvs = new_icrv;
X	}
X
X	/* Append the new iso curves after the read ones. */
X	for (this_iso = this_plot->iso_crvs;
X	     this_iso->next != NULL;
X	     this_iso = this_iso->next);
X	    this_iso->next = new_icrvs;
X    }
X}
X
X/*
X * print_points: a debugging routine to print out the points of a curve, and
X * the curve structure. If curve<0, then we print the list of curves.
X */
X
Xstatic char    *plot_type_names[4] =
X{
X    "Function", "Data", "3D Function", "3d data"
X};
Xstatic char    *plot_style_names[6] =
X{
X    "Lines", "Points", "Impulses", "LinesPoints", "Dots", "Errorbars"
X};
X
Xprint_points(curve)
X    int             curve;	/* which curve to print */
X{
X    register struct curve_points *this_plot;
X    int             i;
X
X    if (curve < 0) {
X	for (this_plot = first_plot, i = 0;
X	     this_plot != NULL;
X	     i++, this_plot = this_plot->next_cp) {
X	    printf("Curve %d:\n", i);
X	    if ((int) this_plot->plot_type >= 0 && (int) (this_plot->plot_type) < 4)
X		printf("Plot type %d: %s\n", (int) (this_plot->plot_type),
X		       plot_type_names[(int) (this_plot->plot_type)]);
X	    else
X		printf("Plot type %d: BAD\n", (int) (this_plot->plot_type));
X	    if ((int) this_plot->plot_style >= 0 && (int) (this_plot->plot_style) < 6)
X		printf("Plot style %d: %s\n", (int) (this_plot->plot_style),
X		       plot_style_names[(int) (this_plot->plot_style)]);
X	    else
X		printf("Plot style %d: BAD\n", (int) (this_plot->plot_style));
X	    printf("Plot title: '%s'\n", this_plot->title);
X	    printf("Line type %d\n", this_plot->line_type);
X	    printf("Point type %d\n", this_plot->point_type);
X	    printf("max points %d\n", this_plot->p_max);
X	    printf("current points %d\n", this_plot->p_count);
X	    printf("\n");
X	}
X    } else {
X	for (this_plot = first_plot, i = 0;
X	     i < curve && this_plot != NULL;
X	     i++, this_plot = this_plot->next_cp);
X	if (this_plot == NULL)
X	    printf("Curve %d does not exist; list has %d curves\n", curve, i);
X	else {
X	    printf("Curve %d, %d points\n", curve, this_plot->p_count);
X	    for (i = 0; i < this_plot->p_count; i++) {
X		printf("%c x=%g y=%g z=%g ylow=%g yhigh=%g\n",
X		       this_plot->points[i].type == INRANGE ? 'i'
X		       : this_plot->points[i].type == OUTRANGE ? 'o'
X		       : 'u',
X		       this_plot->points[i].x,
X		       this_plot->points[i].y,
X		       this_plot->points[i].z,
X		       this_plot->points[i].ylow,
X		       this_plot->points[i].yhigh);
X	    }
X	    printf("\n");
X	}
X    }
X}
X
Xprint_table()
X{
X    register struct curve_points *this_plot;
X    int             i, curve;
X
X    for (this_plot = first_plot, curve = 0; this_plot != NULL;
X	 curve++, this_plot = this_plot->next_cp) {
X	fprintf(outfile, "Curve %d, %d points\n", curve, this_plot->p_count);
X	for (i = 0; i < this_plot->p_count; i++) {
X	    fprintf(outfile, "%c x=%g y=%g\n",
X		    this_plot->points[i].type == INRANGE ? 'i'
X		    : this_plot->points[i].type == OUTRANGE ? 'o'
X		    : 'u',
X		    this_plot->points[i].x,
X		    this_plot->points[i].y);
X	}
X	fprintf(outfile, "\n");
X    }
X    fflush(outfile);
X}
X
Xprint_3dtable(pcount)
Xint pcount;
X{
X    register struct surface_points *this_plot;
X    int             i, curve,surface;
X    struct iso_curve *icrvs;
X	struct coordinate GPHUGE *points;
X
X    for (surface=0, this_plot=first_3dplot ; surface < pcount; 
X		this_plot=this_plot->next_sp, surface++){
X		fprintf(outfile, "\nSurface %d of %d surfaces\n", surface, pcount);
X		icrvs = this_plot->iso_crvs;
X		curve = 0;
X
X		while(icrvs){
X			fprintf(outfile, "\nIsoCurve %d, %d points\n", curve, icrvs->p_count);
X			for(i=0, points = icrvs->points; i < icrvs->p_count; i++){
X	    		fprintf(outfile, "%c x=%g y=%g z=%g\n",
X		    	points[i].type == INRANGE ? 'i'
X		    	: points[i].type == OUTRANGE ? 'o'
X		    	: 'u',
X		    	points[i].x,
X		    	points[i].y,
X		    	points[i].z);
X			}
X			icrvs = icrvs->next;
X			curve++;
X		}
X	fprintf(outfile, "\n");
X	}
X    fflush(outfile);
X}
X
X/*
X * This parses the plot command after any range specifications. To support
X * autoscaling on the x axis, we want any data files to define the x range,
X * then to plot any functions using that range. We thus parse the input
X * twice, once to pick up the data files, and again to pick up the functions.
X * Definitions are processed twice, but that won't hurt.
X */
Xeval_plots()
X{
X    register int    i;
X    register struct curve_points *this_plot, **tp_ptr;
X    register int    start_token, end_token;
X    register int    begin_token;
X    double          x_min, x_max, y_min, y_max;
X    register double x, xdiff, temp;
X    static struct value a;
X    TBOOLEAN         ltmp, some_data_files = FALSE,is_log_func = FALSE;
X    int             plot_num, line_num, point_num, xparam = 0;
X    char           *xtitle;
X    void            parametric_fixup();
X
X    /* Reset first_plot. This is usually done at the end of this function.
X       If there is an error within this function, the memory is left allocated,
X       since we cannot call cp_free if the list is incomplete. Making sure that
X       the list structure is always vaild requires some rewriting */
X    first_plot=NULL;
X
X    if (autoscale_ly) {
X	ymin = VERYLARGE;
X	ymax = -VERYLARGE;
X    } else if (is_log_y && (ymin <= 0.0 || ymax <= 0.0))
X	int_error("y range must be above 0 for log scale!",
X		  NO_CARET);
X
X    tp_ptr = &(first_plot);
X    plot_num = 0;
X    line_num = 0;		/* default line type */
X    point_num = 0;		/* default point type */
X
X    xtitle = NULL;
X
X    begin_token = c_token;
X
X    /*** First Pass: Read through data files ***
X     * This pass serves to set the xrange and to parse the command, as well
X     * as filling in every thing except the function data. That is done after
X     * the xrange is defined.
X     */
X    while (TRUE) {
X	if (END_OF_COMMAND)
X	    int_error("function to plot expected", c_token);
X
X	start_token = c_token;
X
X	if (is_definition(c_token)) {
X	    define();
X	} else {
X	    plot_num++;
X
X	    if (isstring(c_token)) {	/* data file to plot */
X		if (parametric && xparam)
X		    int_error("previous parametric function not fully specified",
X			      c_token);
X
X		if (!some_data_files && autoscale_lx) {
X		    xmin = VERYLARGE;
X		    xmax = -VERYLARGE;
X		}
X		some_data_files = TRUE;
X
X		if (*tp_ptr)
X		    this_plot = *tp_ptr;
X		else {		/* no memory malloc()'d there yet */
X		    this_plot = cp_alloc(MIN_CRV_POINTS);
X		    *tp_ptr = this_plot;
X		}
X		this_plot->plot_type = DATA;
X		this_plot->plot_style = data_style;
X		end_token = c_token;
X		get_data(this_plot);	/* this also parses the using option */
X	    } else {		/* function to plot */
X		if (parametric)	/* working on x parametric function */
X		    xparam = 1 - xparam;
X		if (*tp_ptr) {
X		    this_plot = *tp_ptr;
X		    cp_extend(this_plot, samples + 1);
X		} else {	/* no memory malloc()'d there yet */
X		    this_plot = cp_alloc(samples + 1);
X		    *tp_ptr = this_plot;
X		}
X		this_plot->plot_type = FUNC;
X		this_plot->plot_style = func_style;
X		dummy_func = &plot_func;
X		plot_func.at = temp_at();
X		/* ignore it for now */
X		end_token = c_token - 1;
X	    }
X
X	    if (almost_equals(c_token, "t$itle")) {
X		if (parametric) {
X		    if (xparam)
X			int_error(
X				     "\"title\" allowed only after parametric function fully specified",
X				     c_token);
X		    else if (xtitle != NULL)
X			xtitle[0] = '\0';	/* Remove default title . */
X		}
X		c_token++;
X		if (isstring(c_token)) {
X		    m_quote_capture(&(this_plot->title), c_token, c_token);
X		} else {
X		    int_error("expecting \"title\" for plot", c_token);
X		}
X		c_token++;
X	    } else if (almost_equals(c_token, "not$itle")) {
X	        c_token++;
X	    } else {
X		m_capture(&(this_plot->title), start_token, end_token);
X		if (xparam)
X		    xtitle = this_plot->title;
X	    }
X
X	    this_plot->line_type = line_num;
X	    this_plot->point_type = point_num;
X
X	    if (almost_equals(c_token, "w$ith")) {
X		if (parametric && xparam)
X		    int_error("\"with\" allowed only after parametric function fully specified",
X			      c_token);
X		this_plot->plot_style = get_style();
X	    }
X	    if (!equals(c_token, ",") && !END_OF_COMMAND) {
X		struct value    t;
X		this_plot->line_type = (int) real(const_express(&t)) - 1;
X	    }
X	    if (!equals(c_token, ",") && !END_OF_COMMAND) {
X		struct value    t;
X		this_plot->point_type = (int) real(const_express(&t)) - 1;
X	    }
X	    if ((this_plot->plot_style == POINTSTYLE) ||
X		(this_plot->plot_style == LINESPOINTS) ||
X		(this_plot->plot_style == ERRORBARS))
X		if (!xparam)
X		    point_num++;
X	    if (!xparam)
X		line_num++;
X
X	    if (this_plot->plot_type == DATA)
X		/* now that we know the plot style, adjust the yrange */
X		adjust_yrange(this_plot);
X
X	    tp_ptr = &(this_plot->next_cp);
X	}
X
X	if (equals(c_token, ","))
X	    c_token++;
X	else
X	    break;
X    }
X
X    if (parametric && xparam)
X	int_error("parametric function not fully specified", NO_CARET);
X
X    if (parametric) {
X	/* Swap t and x ranges for duration of these eval_plot computations. */
X	ltmp = autoscale_lx;
X	autoscale_lx = autoscale_lt;
X	autoscale_lt = ltmp;
X	temp = xmin;
X	xmin = tmin;
X	tmin = temp;
X	temp = xmax;
X	xmax = tmax;
X	tmax = temp;
X    }
X    /*** Second Pass: Evaluate the functions ***/
X    /*
X     * Everything is defined now, except the function data. We expect no
X     * syntax errors, etc, since the above parsed it all. This makes the code
X     * below simpler. If autoscale_ly, the yrange may still change.
X     */
X    if (fabs(xmax - xmin) < zero)
END_OF_FILE
  if test 58930 -ne `wc -c <'gnuplot/command.c.A'`; then
    echo shar: \"'gnuplot/command.c.A'\" unpacked with wrong size!
  elif test -f 'gnuplot/command.c.B' ; then
    echo shar: Combining  \"'gnuplot/command.c'\" \(116680 characters\)
    cat 'gnuplot/command.c.A' 'gnuplot/command.c.B' > 'gnuplot/command.c'
    if test 116680 -ne `wc -c <'gnuplot/command.c'`; then
      echo shar: \"'gnuplot/command.c'\" combined with wrong size!
    else
      rm gnuplot/command.c.A gnuplot/command.c.B
    fi
  fi
  # end of 'gnuplot/command.c.A'
fi
if test -f 'gnuplot/demo/1.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/1.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/1.dat'\" \(839 characters\)
  sed "s/^X//" >'gnuplot/demo/1.dat' <<'END_OF_FILE'
X#
X# $Id: 1.dat 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X#
X-20.000000 -3.041676
X-19.000000 -3.036427
X-18.000000 -3.030596
X-17.000000 -3.024081
X-16.000000 -3.016755
X-15.000000 -3.008456
X-14.000000 -2.998978
X-13.000000 -2.988049
X-12.000000 -2.975310
X-11.000000 -2.960273
X-10.000000 -2.942255
X-9.000000 -2.920278
X-8.000000 -2.892883
X-7.000000 -2.857799
X-6.000000 -2.811295
X-5.000000 -2.746802
X-4.000000 -2.651635
X-3.000000 -2.498092
X-2.000000 -2.214297
X-1.000000 -1.570796
X0.000000 0.000000
X1.000000 1.570796
X2.000000 2.214297
X3.000000 2.498092
X4.000000 2.651635
X5.000000 2.746802
X6.000000 2.811295
X7.000000 2.857799
X8.000000 2.892883
X9.000000 2.920278
X10.000000 2.942255
X11.000000 2.960273
X12.000000 2.975310
X13.000000 2.988049
X14.000000 2.998978
X15.000000 3.008456
X16.000000 3.016755
X17.000000 3.024081
X18.000000 3.030596
X19.000000 3.036427
END_OF_FILE
  if test 839 -ne `wc -c <'gnuplot/demo/1.dat'`; then
    echo shar: \"'gnuplot/demo/1.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/1.dat'
fi
if test -f 'gnuplot/term/imagen.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/imagen.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/imagen.trm'\" \(17380 characters\)
  sed "s/^X//" >'gnuplot/term/imagen.trm' <<'END_OF_FILE'
X/*
X * $Id: imagen.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - imagen.trm */
X/*
X * Copyright (C) 1990   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   Imagen laser printers
X *
X * AUTHORS
X *   Paul E. McKenney, David Kotz
X *   Rewritten/extended by:
X *	Hans Olav Eggestad
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/*
X * Original for direct Imagen output (but retaining many of the
X * LaTeX extensions) by Paul E. McKenney, 1989.
X * Further modified by David Kotz to fit into gnuplot 2.0.
X * Information Science and Technology Division, SRI International,
X * 333 Ravenswood Ave, Menlo Park, CA 94025.
X * Mail to mckenney@sri.com.
X */
X
X#include "impcodes.h"
X
X#define IMAGEN_PTS_PER_INCH (300)
X#define IMAGEN_A4_H  (IMAGEN_PTS_PER_INCH * 83 / 10) /* default is landscape */
X#define IMAGEN_A4_W  (IMAGEN_PTS_PER_INCH * 116 / 10)
X
X#define IMAGEN_XMAX (IMAGEN_PTS_PER_INCH * 11) /* 10.0 inches */
X#define IMAGEN_YMAX (IMAGEN_PTS_PER_INCH * 78 / 10) /* 7.5 inches */
X
Xstatic int IMAGEN_Xmax = IMAGEN_XMAX;  /* width in current orientation */
Xstatic int IMAGEN_Ymax = IMAGEN_YMAX;
X
X#define IMAGEN_FONTSIZE 12
X#define IMAGEN_FONT "cour"
X
X#define IMAGEN_HTIC (20)
X#define IMAGEN_VTIC (20)
X#define IMAGEN_VCHAR (IMAGEN_FONTSIZE*5)
X#define IMAGEN_HCHAR (IMAGEN_VCHAR/2)
X
Xunsigned short IMP_gmap[128];
Xunsigned char IMP_chmap[256];
X
Xstatic int IMAGEN_page_h  = IMAGEN_A4_H;
Xstatic int IMAGEN_page_w = IMAGEN_A4_W;
Xstatic int IM_win_horiz = 1;
Xstatic int IM_win_verti = 1;
Xstatic int IM_plot_nr = 0;
X
Xstatic int IMAGEN_fontsize = IMAGEN_FONTSIZE;
Xstatic int IMAGEN_familytable[36];
Xstatic int IMAGEN_orgX;		/* absolute-pixel-ORIgin of graph page.	*/
Xstatic int IMAGEN_orgY;
Xstatic int IMAGEN_orgx;		/* absolute-pixel-ORIgin of current graph. */
Xstatic int IMAGEN_orgy;
Xstatic int IMAGEN_posx;		/* current drawing position (lines).	*/
Xstatic int IMAGEN_posy;
Xstatic int IMAGEN_inplot;
Xstatic int IMAGEN_xmax = IMAGEN_XMAX;	/* width of graph in pixels.	*/
Xstatic int IMAGEN_ymax = IMAGEN_YMAX;	/* height of graph in pixels.	*/
Xstatic int IMAGEN_winx = IMAGEN_XMAX;	/* width of window in pixels.	*/
Xstatic int IMAGEN_winy = IMAGEN_YMAX;	/* height of window in pixels.	*/
Xstatic int IMAGEN_hchar;	/* Height of CHAR in current font.	*/
Xstatic int IMAGEN_wchar;	/* Width of CHAR in current font.	*/
Xstatic int IMAGEN_blofs;	/* BaseLine OFfSet from bounding box.	*/
Xstatic int IMAGEN_angle = -1;	/* 0 for horizontal text, 1 for vertical */
Xstatic int IMAGEN_portrait;	/* 0 for landscape */
Xstatic enum JUSTIFY IMAGEN_justify = LEFT; /* left/center/right */
X
Xstatic IMAGEN_seq_pos;		/* position in sequence */
X
Xstatic void IMAGEN_putwd();
Xstatic void IMAGEN_createfamily();
Xstatic void IMAGEN_setfont();
Xstatic void IMAGEN_setpos();
Xvoid IMP_set_draw_pattern();
Xstatic unsigned char *IMAGEN_cvts();
X
X/* char IMPdrpattern[10][10] = { {0}, {30,10,0}, {0}, {10,30,0}, {2,20,0}, 
X	{20,10,0}, {30,20,10,20,0}, {30,20,4,10,10,10,4,20,0}, {40,20,0}, {30,15,4,15,0}
X};
X*/
X
Xchar IMPdrpattern[10][10] = { 
X/* -2 */ {0}, 
X/* -1 */ {1,8,0}, 
X/*  0 */ {0}, 
X/*  1 */ {16,4,0}, 
X/*  2 */ {3,8,0}, 
X/*  3 */ {8,8,0}, 
X/*  4 */ {16,6,3,6,0}, 
X/*  5 */ {16,6,8,6,0}, 
X/*  6 */ {16,4,1,4,8,4,1,4,0}, 
X/*  7 */ {16,4,1,8,1,4,0}
X};
X
XIMAGEN_init()
X{
X    register struct termentry *t = &term_tbl[term];
X
X    /* char font[10];	*/		/* font name */
X
X    IMAGEN_posx = IMAGEN_posy = 0;
X
X    IMAGEN_orgX = (IMAGEN_page_w - IMAGEN_Xmax) / 2;
X    IMAGEN_orgY = (IMAGEN_page_h - IMAGEN_Ymax) / 2;
X
X    IMAGEN_xmax = IMAGEN_winx = (int)(IMAGEN_Xmax / IM_win_horiz);
X    IMAGEN_ymax = IMAGEN_winy = (int)(IMAGEN_Ymax / IM_win_verti);
X
X    t->xmax = (unsigned int)(IMAGEN_xmax);
X    t->ymax = (unsigned int)(IMAGEN_ymax);
X
X    fputs("@document(language impress, paper a4)", outfile);
X
X    if (IMAGEN_portrait) {
X    	putc(imP_SET_ABS_V, outfile);
X    	IMAGEN_putwd(3520);
X    }
X    putc(imP_SET_HV_SYSTEM, outfile);
X    putc(((IMAGEN_portrait?3:0)<<5)|(3<<3)|(IMAGEN_portrait?0:5), outfile);
X
X    /* sprintf(font, "cour%02d", IMAGEN_FONTSIZE); */
X    IMAGEN_mapsinit();
X    IMAGEN_createmap(1,IMP_gmap);
X    /* IMAGEN_createfamily(font, IMAGEN_FONTSIZE); */
X    IMAGEN_setfont(IMAGEN_fontsize);
X
X    IMAGEN_text_angle(0);
X
X    putc(imP_SET_ABS_H, outfile);
X    IMAGEN_putwd(0);
X    putc(imP_SET_ABS_V, outfile);
X    IMAGEN_putwd(0);
X
X    IMAGEN_linetype(-1);
X}
X
XIM_page()
X{
X	putc(imP_ENDPAGE, outfile);
X	putc(imP_PAGE, outfile);
X}
X
XIMAGEN_graphics()
X{
X    int tmpx, tmpy;
X
X    if ( IM_plot_nr >= ( IM_win_horiz * IM_win_verti )) {
X	IM_page();
X	IM_plot_nr = 0;
X    }
X    IM_plot_nr++;
X    tmpx = IMAGEN_orgX + ((IM_plot_nr - 1) % IM_win_horiz) * IMAGEN_winx;
X    tmpy = IMAGEN_orgY + ((IM_win_verti - 1) - (int)((IM_plot_nr - 1) / IM_win_horiz)) * IMAGEN_winy;
X    IMAGEN_orgx = tmpx + (int)((IMAGEN_winx - IMAGEN_xmax)/2);
X    IMAGEN_orgy = tmpy + (int)((IMAGEN_winy - IMAGEN_ymax)/2);
X}
X
XIMAGEN_options()
X{
X	extern struct value *const_express();
X	extern double real();
X	struct value a;
X
X	while (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"p$ortrait")) {
X			IMAGEN_portrait=TRUE;
X			IMAGEN_page_h = IMAGEN_A4_W;
X			IMAGEN_page_w = IMAGEN_A4_H;
X			IMAGEN_Xmax = IMAGEN_YMAX;
X			IMAGEN_Ymax = IMAGEN_XMAX;
X			c_token++;
X		}
X		else if (almost_equals(c_token,"l$andscape")) {
X			IMAGEN_portrait=FALSE;
X			c_token++;
X		} else if (equals(c_token,"[")) { /* windows spesified */
X			c_token++;
X			if (IM_plot_nr>1)
X			if (equals(c_token,"]")) {
X				IM_page();
X				c_token++;
X				continue;
X			}
X			if (END_OF_COMMAND) {
X	    			int_error("no. windows: [horizontal,vertical] expected",c_token);
X			} else if (!equals(c_token,","))  {
X				IM_win_horiz = (int)real(const_express(&a));
X			}	
X			if (!equals(c_token,","))
X				int_error("',' expected",c_token);
X			c_token++;
X			if (!equals(c_token,"]")) {
X				IM_win_verti = (int)real(const_express(&a));
X	 		}
X			if (!equals(c_token,"]"))
X		  		int_error("expecting ']'",c_token);
X			c_token++;
X		} else {
X			/* We have font size specified */
X			IMAGEN_fontsize = (int)real(const_express(&a));
X			if ( IMAGEN_fontsize < 8 ) 
X				IMAGEN_fontsize = 8;
X			if ( IMAGEN_fontsize > 15 ) 
X				IMAGEN_fontsize = 15;
X		}
X	}
X	sprintf(term_options,"%d %s [%1d,%1d]",IMAGEN_fontsize,(IMAGEN_portrait)?"portrait":"landscape",IM_win_horiz,IM_win_verti);
X}
X
X
XIMAGEN_text()
X{
X}
X
XIMAGEN_scale(xs, ys)
X	double xs, ys;			/* scaling factors */
X{
X    register struct termentry *t = &term_tbl[term];
X
X    /* we change the table for use in graphics.c and IMAGEN_graphics */
X    t->xmax = (unsigned int)(xs * IMAGEN_winx);
X    IMAGEN_xmax = t->xmax ;
X    t->ymax = (unsigned int)(ys * IMAGEN_winy);
X    IMAGEN_ymax = t->ymax ;
X
X    return TRUE ;
X}
X
X#define DRAW_PATTERNS 6
X
X
XIMAGEN_linetype(lt)
Xint lt;
X{
X    static int lastlinetype = -10;
X    int pen;
X
X/* -2: axis
X   -1: border
X    0: arrow
X    1-7: graph
X*/
X	if (lt == -2) {
X		pen = 4;
X	} else {
X		pen = (int) (lt/8)*2;
X		if ( pen <= 0 ) pen = 1;
X	}
X	lt  = (lt % 8) +2;
X
X    if (lastlinetype == lt)
X	 return;
X
X    lastlinetype = lt;	
X
X    putc(imP_SET_PEN, outfile);
X    putc(pen, outfile);
X    IMP_set_draw_pattern(lt,pen);
X}
X
X
XIMAGEN_move(x,y)
X	unsigned int x,y;
X{
X    IMAGEN_posx = x;
X    IMAGEN_posy = y;
X}
X
XIMAGEN_vector(ux,uy)
X	unsigned int ux,uy;
X{
X    /* Create path. */
X
X    putc(imP_CREATE_PATH, outfile);
X    IMAGEN_putwd(2);
X    IMAGEN_putwd(IMAGEN_posx + IMAGEN_orgx);
X    IMAGEN_putwd(IMAGEN_posy + IMAGEN_orgy);
X    IMAGEN_putwd(ux + IMAGEN_orgx);
X    IMAGEN_putwd(uy + IMAGEN_orgy);
X
X    /* Draw path with black pen. */
X
X    putc(imP_DRAW_PATH, outfile);
X    putc(15, outfile);
X
X    /* Set current position to end of line. */
X
X    IMAGEN_move(ux, uy);
X}
X
Xstatic void
XIMAGEN_setpos(ux, uy)
X	int ux,uy;
X{
X    /* Set x and y position (for text), also set beginning-of-line. */
X
X    putc(imP_SET_ABS_H, outfile);
X    IMAGEN_putwd(ux + IMAGEN_orgx);
X    putc(imP_SET_ABS_V, outfile);
X    IMAGEN_putwd(uy + IMAGEN_orgy);
X    putc(imP_SET_BOL, outfile);
X    if (IMAGEN_angle == 1)
X	 IMAGEN_putwd(uy + IMAGEN_orgx); /* vertical */
X    else
X	 IMAGEN_putwd(ux + IMAGEN_orgx); /* horizontal */
X}
X
XIMAGEN_text_angle(angle)
X	int angle;
X{
X    if (IMAGEN_angle != angle) {
X	   IMAGEN_angle = angle;	/* record for later use */
X	   putc(imP_SET_ADV_DIRS, outfile);
X	   putc(angle == 0 ? 0 : 7, outfile); /* 0=>horiz : 7=>vert */
X    }
X
X    return(TRUE);
X}
X
XIMAGEN_justify_text(mode)
X	enum JUSTIFY mode;
X{
X    IMAGEN_justify = mode;
X    return(TRUE);
X}
X
Xstatic unsigned char *
XIMAGEN_cvts(str, width, height)
X	unsigned char		*str;
X	int		*width;
X	int		*height;
X{
X    unsigned char		*cp1;
X    unsigned char		*cp2;
X    static unsigned char	*buf = NULL;
X    int		h;
X    int		maxw;
X    int		w;
X
X    /* Free up old buffer, if there is one, get a new one.  Since	*/
X    /* all transformations shorten the string, get a buffer that is	*/
X    /* the same size as the input string.				*/
X
X    if (buf != NULL)
X	 (void) free(buf);
X    buf = (unsigned char *) alloc(strlen(str) + 1, "converted label string");
X
X    /* Do the transformations. */
X
X    cp1 = str;
X    cp2 = buf;
X    h = 1;
X    maxw = 0;
X    w = 0;
X    while (strlen(cp1) > 0) {
X	   switch (*cp1) {
X		  case ' ' :		/* Space character. */
X		    *cp2++ = imP_SP;
X		    w++;
X		    break;
X		    
X		    case  '\\' :	/* Escape sequence. */
X			 if (*++cp1 == '\\') {
X				/* Begin new line. */
X				h++;
X				if (w > maxw)
X				  maxw = w;
X				w = 0;
X				*cp2++ = '\n';
X				/* *cp2++ = imP_CRLF; */
X				break;
X			 }
X		    
X		    /* Fall through to just copy next char out.	*/
X		    
X		    default :
X			 /* *cp2++ = *cp1; */
X			 *cp2++ = IMP_chmap[*cp1];
X		    w++;
X		    break;
X		}
X	   cp1++;
X    }
X    
X    *cp2++ = '\n';
X    *cp2 = '\0';
X    if (w > maxw)
X	 maxw = w;
X    
X    if (height != NULL)
X	 *height = IMAGEN_angle ?
X	   IMAGEN_wchar * maxw :
X		IMAGEN_hchar * h;
X    if (width != NULL)
X	 *width = IMAGEN_angle ?
X	   IMAGEN_hchar * h :
X		IMAGEN_wchar * maxw;
X    return (buf);
X}
X
XIMAGEN_put_text(x, y, str)
X	int x,y;				/* reference point of string */
X	unsigned char str[];			/* the text */
X{
X    unsigned char *cvstr, *p; 
X    int height;
X    int width;
X    int sx, sy;
X    
X    cvstr = IMAGEN_cvts(str, &width, &height);
X
X    if (IMAGEN_angle) {		/* vertical */
X	/* x += IMAGEN_hchar; */
X	   x -= width/2 - IMAGEN_hchar;
X	  /* y -= height/2; */
X    } else				/* horizontal */
X	 y += height/2 - IMAGEN_hchar;
X
X#ifdef sequent
X    while ( p=(unsigned char *)index(cvstr,'\n' )) {
X#else
X    while ( p=(unsigned char *)strchr(cvstr,'\n' )) {
X#endif
X	*p = '\0';
X    	sx = x;
X    	sy = y;
X    	if ( IMAGEN_angle )
X		sx = x - IMAGEN_blofs;
X    	else
X		sy = y + IMAGEN_blofs;
X	
X    	width = strlen(cvstr)*IMAGEN_wchar;
X	
X    	switch (IMAGEN_justify) {
X	   	case LEFT: 
X			break;
X	   	case CENTRE: 
X			if ( IMAGEN_angle ) {
X				sy = y - width/2;
X			} else {
X				sx = x - width/2;
X			}
X			break;
X			/*x -= width/2; break; */
X	   	case RIGHT: 
X			if ( IMAGEN_angle ) {
X				sy = y - width;
X			} else {
X				sx = x - width;
X			}
X			break;
X			/* x -= width; break; */
X    	}
X
X    	IMAGEN_setpos(sx, sy);
X    	fputs((char*) cvstr, outfile);
X	cvstr = ++p;
X	if (IMAGEN_angle) { 	/* vertical */
X		x += IMAGEN_hchar;
X	} else {
X		y -= IMAGEN_hchar;
X	}
X
X    }
X}
X
XIMAGEN_reset()
X{
X    putc(imP_EOF, outfile);
X}
X
Xstatic void
XIMAGEN_putwd(w)
X{
X	putc(w>>8, outfile);
X	putc(w, outfile);
X}
X
Xstatic void
XIMAGEN_createfamily(c, sz)
X	char		*c;
X	int		sz;
X{
X
X    putc(imP_CREATE_FAMILY_TABLE, outfile);
X    putc(sz, outfile);
X    putc(1, outfile);
X    putc(1, outfile);
X    /* putc(0, outfile); */
X    fputs(c, outfile);
X    putc(0, outfile);
X}
X
Xstatic void
XIMAGEN_setfont(sz) 
X    int sz;
X{
X    char font[20];
X
X    if ( ! IMAGEN_familytable[sz] ) {
X	sprintf(font,"%s%02d",IMAGEN_FONT,sz);
X	IMAGEN_createfamily(font, sz);
X    	IMAGEN_familytable[sz] = sz;
X    }
X    IMAGEN_hchar = sz * 5;
X    IMAGEN_wchar = IMAGEN_hchar / 2;
X    IMAGEN_blofs = IMAGEN_hchar / 3;
X	term_tbl[term].v_char = IMAGEN_hchar;
X	term_tbl[term].h_char = IMAGEN_wchar;
X    putc(imP_SET_FAMILY, outfile);
X    putc(sz, outfile);
X    putc(imP_SET_SP, outfile);
X    IMAGEN_putwd(IMAGEN_wchar);
X    putc(imP_SET_IL, outfile);
X    IMAGEN_putwd(IMAGEN_hchar);
X}
X
Xvoid
XIMP_set_draw_pattern(pattern,sz)
Xint sz, pattern;
X{
X	int i;
X	putc(imP_SET_DRAW_PATTERN, outfile);
X	putc(0,outfile);
X	putc(imP_SET_DRAW_PATTERN, outfile);
X	/* if ( strlen(IMPdrpattern[pattern]) == 1 ) {
X		putc(type,outfile);
X		return;
X	} */ 
X	putc(strlen(IMPdrpattern[pattern]),outfile);
X	for ( i=0;i<strlen(IMPdrpattern[pattern]);i++) {
X		IMAGEN_putwd(IMPdrpattern[pattern][i]*sz);
X	}
X}
X
X
XIMAGEN_mapsinit()
X{
X
X    register int i;
X
X    for ( i=32;i<127;i++) {
X        IMP_gmap[i] = i;
X    }
X    IMP_gmap[1] = 225;
X    IMP_gmap[2]  = 233;
X    IMP_gmap[3] = 61736;
X    IMP_gmap[4] = 241;
X    IMP_gmap[5]  = 249;
X    IMP_gmap[6] = 61864;
X    IMP_gmap[7] = 162;
X    IMP_gmap[8] = 163;
X    IMP_gmap[9] = 164;
X    IMP_gmap[10] = 165;
X    IMP_gmap[11] = 167;
X    IMP_gmap[12] = 171;
X    IMP_gmap[13] = 182;
X    IMP_gmap[14] = 61346;
X    IMP_gmap[15] = 191;
X    IMP_gmap[16] = 187;
X    IMP_gmap[17] = 188;
X    IMP_gmap[18] = 189;
X    IMP_gmap[19] = 190;
X    IMP_gmap[20] = 210;
X    IMP_gmap[21] = 211;
X    IMP_gmap[22] = 251;
X    IMP_gmap[23] = 61232;
X    IMP_gmap[24] = 212;
X    IMP_gmap[25] = 137;
X    IMP_gmap[26] = 176;
X    IMP_gmap[27] = 161;
X    IMP_gmap[28] = 139;
X    IMP_gmap[29] = 133;
X    IMP_gmap[30] = 140;
X    IMP_gmap[31] = 61249;
X    IMP_gmap[32] = 8738;
X    IMP_gmap[34] = 186;
X    IMP_gmap[36] = 164;
X    IMP_gmap[39] = 185;
X    IMP_gmap[127] = 61286;
X
X    /* for (i=1;i<127;i++) fprintf(stderr,"%d -> %d\n",i,IMP_gmap[i]); */
X
X    for ( i=32;i<=127;i++) {
X        IMP_chmap [i] = i;
X    }
X    for ( i=128;i<=255;i++) {
X        IMP_chmap [i] = 128; /* first map all non printable chars to SPACE */
X    }
X
X    IMP_chmap [161] = 27;
X    IMP_chmap [162] = 7;
X    IMP_chmap [163] = 8;
X    IMP_chmap [164] = 120;
X    IMP_chmap [165] = 10;
X    IMP_chmap [166] = 124;
X    IMP_chmap [167] = 11;
X    IMP_chmap [168] = 25;
X    IMP_chmap [169] = 21;
X    IMP_chmap [170] = 45;
X    IMP_chmap [171] = 12;
X    IMP_chmap [172] = 83;
X    IMP_chmap [173] = 45;
X    IMP_chmap [174] = 20;
X    IMP_chmap [175] = 126;
X    IMP_chmap [176] = 26;
X    IMP_chmap [177] = 12;
X    IMP_chmap [178] = 1;
X    IMP_chmap [179] = 2;
X    IMP_chmap [180] = 29;
X    IMP_chmap [181] = 52;
X    IMP_chmap [182] = 13;
X    IMP_chmap [183] = 5;
X    IMP_chmap [184] = 28;
X    IMP_chmap [185] = 3;
X    IMP_chmap [186] = 45;
X    IMP_chmap [187] = 16;
X    IMP_chmap [188] = 17;
X    IMP_chmap [189] = 18;
X    IMP_chmap [190] = 19;
X    IMP_chmap [191] = 15;
X    IMP_chmap [192] = 65;
X    IMP_chmap [193] = 65;
X    IMP_chmap [194] = 65;
X    IMP_chmap [195] = 65;
X    IMP_chmap [196] = 65;
X    IMP_chmap [197] = 3;
X    IMP_chmap [198] = 1;
X    IMP_chmap [199] = 67;
X    IMP_chmap [200] = 69;
X    IMP_chmap [201] = 69;
X    IMP_chmap [202] = 69;
X    IMP_chmap [203] = 69;
X    IMP_chmap [204] = 73;
X    IMP_chmap [205] = 73;
X    IMP_chmap [206] = 73;
X    IMP_chmap [207] = 73;
X    IMP_chmap [208] = 68;
X    IMP_chmap [209] = 78;
X    IMP_chmap [210] = 79;
X    IMP_chmap [211] = 79;
X    IMP_chmap [212] = 79;
X    IMP_chmap [213] = 79;
X    IMP_chmap [214] = 79;
X    IMP_chmap [215] = 13;
X    IMP_chmap [216] = 2;
X    IMP_chmap [217] = 85;
X    IMP_chmap [218] = 85;
X    IMP_chmap [219] = 85;
X    IMP_chmap [220] = 85;
X    IMP_chmap [221] = 89;
X    IMP_chmap [222] = 32;
X    IMP_chmap [223] = 22;
X    IMP_chmap [224] = 97;
X    IMP_chmap [225] = 97;
X    IMP_chmap [226] = 97;
X    IMP_chmap [227] = 97;
X    IMP_chmap [228] = 97;
X    IMP_chmap [229] = 6;
X    IMP_chmap [230] = 4;
X    IMP_chmap [231] = 99;
X    IMP_chmap [232] = 101;
X    IMP_chmap [233] = 101;
X    IMP_chmap [234] = 101;
X    IMP_chmap [235] = 101;
X    IMP_chmap [236] = 105;
X    IMP_chmap [237] = 105;
X    IMP_chmap [238] = 105;
X    IMP_chmap [239] = 105;
X    IMP_chmap [240] = 100;
X    IMP_chmap [241] = 110;
X    IMP_chmap [242] = 111;
X    IMP_chmap [243] = 111;
X    IMP_chmap [244] = 111;
X    IMP_chmap [245] = 111;
X    IMP_chmap [246] = 111;
X    IMP_chmap [247] = 10;
X    IMP_chmap [248] = 5;
X    IMP_chmap [249] = 117;
X    IMP_chmap [250] = 117;
X    IMP_chmap [251] = 117;
X    IMP_chmap [252] = 117;
X    IMP_chmap [253] = 121;
X    IMP_chmap [254] = 32;
X    IMP_chmap [255] = 121;
X}
X 
XIMAGEN_createmap(name,map) 
Xunsigned short *map; 
Xint name; 
X{ 
X    register int i,j; 
X    unsigned char s[4], *p; 
X 
X    p = s; 
X    *p++ = imP_CREATE_MAP; 
X    *p++ = name; 
X    j = 0; 
X    for (i=0;i<127;i++) { 
X        if ( map[i] ) j++; 
X    } 
X    *p = j; 
X    for (i=0;i<3;i++) putc(s[i],outfile); 
X 
X    s[3] = 1;
X    for (j=0;j<127;j++) { 
X        if ( map[j] ) { 
X            p = s; 
X            *p++ = j; 
X            *p++ = map[j] >> 8; 
X            *p   = map[j] & 255;
X            for (i=0;i<4;i++) putc(s[i],outfile); 
X        } 
X    } 
X} 
X 
END_OF_FILE
  if test 17380 -ne `wc -c <'gnuplot/term/imagen.trm'`; then
    echo shar: \"'gnuplot/term/imagen.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/imagen.trm'
fi
echo shar: End of archive 5 \(of 33\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
