Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i039:  gnuplot - interactive function plotting utility, Part27/33
Message-ID: <1993Oct25.030201.2547@sparky.sterling.com>
X-Md4-Signature: f1c4bcc61f93d150dd3d938e9af164e9
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 25 Oct 1993 03:02:01 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 39
Archive-name: gnuplot/part27
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/0README gnuplot/README.3d
#   gnuplot/demo/contours.dem gnuplot/demo/stat.inc
#   gnuplot/makefile.msw gnuplot/os2/gnupmdrv.rc gnuplot/term.h
#   gnuplot/term/dumb.trm gnuplot/term/excl.trm gnuplot/term/hppj.trm
#   gnuplot/term/sun.trm gnuplot/term/win.trm
# Wrapped by kent@sparky on Wed Oct 20 17:14:59 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 27 (of 33)."'
if test -f 'gnuplot/0README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/0README'\"
else
  echo shar: Extracting \"'gnuplot/0README'\" \(6071 characters\)
  sed "s/^X//" >'gnuplot/0README' <<'END_OF_FILE'
XGnuplot is a command-line driven interactive function plotting utility
Xfor UNIX, MSDOS, and VMS platforms.  The software is copyrighted but
Xfreely distributed (i.e., you don't have to pay for it).  It was
Xoriginally intended as graphical program which would allow scientists
Xand students to visualize mathematical functions and data.  Gnuplot
Xsupports many different types of terminals, plotters, and printers
X(including many color devices, and pseudo-devices like LaTeX) and is
Xeasily extensible to include new devices.  [ The "GNU" in gnuplot is
XNOT related to the Free Software Foundation, the naming is just a
Xcoincidence (and a long story). Thus gnuplot is not covered by the Gnu
Xcopyleft, but rather by its own copyright statement, included in all
Xsource code files.]
X
XGnuplot handles both curves (2 dimensions) and surfaces (3
Xdimensions). Surfaces can be plotted as a mesh fitting the specified
Xfunction, floating in the 3-d coordinate space, or as a contour plot
Xon the x-y plane. For 2-d plots, there are also many plot styles,
Xincluding lines, points, lines with points, error bars, and impulses
X(crude bar graphs). Graphs may be labeled with arbitrary labels and
Xarrows, axes labels, a title, date and time, and a key.  The interface
Xincludes command-line editing and history on most platforms.
X
XThe new gnuplot user should begin by reading the general information
Xavailable by typing `help` after running gnuplot. Then read about the
X`plot` command (type `help plot`).  The manual for gnuplot (which is a
Xnicely formatted version of the on-line help information) can be
Xprinted either with TeX, troff or nroff.  Look at the docs/Makefile
Xfor the appropriate option.
X
X                      Help and Bug Reports
X
XAdditional help can be obtained from the USENET newsgroup
X        comp.graphics.gnuplot.
XThis newsgroup is the first place to ask for routine help.  It is is
Xgatewayed to a mailing list info-gnuplot@dartmouth.edu.  If you cannot
Xobtain a USENET feed and wish to join the above mailing list (or get
Xyourself off), mail to
X        info-gnuplot-request@dartmouth.edu.
XPlease do not ask to sign up if you can read comp.graphics.gnuplot.
X
XNote that since gnuplot has nothing to do with the GNU project, please
Xdon't ask them for help or information about gnuplot; also, please
Xdon't ask us about GNU stuff.
X
XThere is another list specifically for documented bug reports
Xand the submissions of fixes and modifications, bug-gnuplot@dartmouth.edu.
XTo join this list send mail to bug-gnuplot-request@dartmouth.edu.
X
X"bug-gnuplot" is NOT an appropriate place to ask questions on how to
Xsolve a gnuplot problem or even to report a bug that you haven't
Xinvestigated personally.  It is far more likely you'll get the help
Xyou need for this kind of problem from comp.graphics.gnuplot.
X
X"bug-gnuplot" is appropriate for turning in a formal bug report
Xthat does not require timely action.  In other words, if you spend
Xtime and investigate a bug, and especially if you fix a bug, then
Xsend it to bug-report and your fix will be considered for the next
Xrelease of gnuplot.  Fixes should be in ``diff -c'' format done
Xagainst the most current official version of gnuplot or the latest
Xalpha or beta release of the next version.  All major modifications
Xshould include documentation and a demo file.  Finally, it is
Xmuch easier to integrate smaller stepwise modifications rather
Xthan one gigantic diff file which represented months of changes.
XAll messages to bug-gnuplot should include the machine you are using, the
Xoperating system and it's version, plotting devices, and the version
Xof gnuplot that you are running.
X
X                   Where to get updates to GNUPLOT
X
XCongratulations on getting this version of GNUPLOT! Unfortunately, it
Xmay not be the most recent version ("you never know where this version
Xhas been!"). You can be sure that it IS the most recent version by
Xchecking one of the official distribution sites, guaranteed to be kept
Xup to date (of course, if you got this file from one of those sites,
Xyou don't need to check!).
X
XTo hear automatically about future releases (and other GNUPLOT news),
Xread the newsgroup; see above.
X
XAt the time of this writing, the following are the official
Xdistribution sites and transfer instructions. Note that
Xprep.ai.mit.edu is NOT an official site, and may not be up to date.
XAlso, comp.sources.misc is usually a month or so behind us.
X
XDate: Fri Aug 27 05:21:33 GMT 1993
X
X
XVersion: 3.5
X
XIn general, GNUPLOT 3.5 is available as the file gnuplot3.5.tar.Z.
XThere will patches to bring 3.4 to 3.5 as well called gp34to35.shar.Z.
X(Version 3.3 was skipped because of possible confusion
Xwith the numerous BETA releases.)  It will be made available to simtel20 
Xand its mirrors in ZIP format, along with a DOS, MS-Windows 3.1 and
XOS/2 2.0 executables.
X
XAlso, some sites will have gpdoc_ps.zip which contains
XPostScript versions of the manuals and tutorials.
X
XPlease obtain gnuplot from the site
Xnearest you.
X
XUSENET users:
X
X    GNUPLOT 3.5 will posted to comp.sources.misc.
X
X
XNORTH AMERICA:
X
X     Anonymous ftp to ftp.dartmouth.edu (129.170.16.4)
X     Fetch
X        pub/gnuplot/gnuplot3.5.tar.Z
X     in binary mode.
X
X     Users without ftp capability can obtain it through a mail ftp
X     server. Send a mail message saying 'help' to
X     BITFTP@pucc.princeton.edu for instructions. For a uuencoded
X     copy of the gnuplot sources (compressed tar file), send this
X     message to BITFTP@pucc.princeton.edu:
X         FTP DARTMOUTH.EDU UUENCODE
X         USER ANONYMOUS
X         CD pub/gnuplot
X         BINARY
X         GET gnuplot3.5.tar.Z
X         QUIT
X
X
XAUSTRALIA:
X
X     Anonymous ftp to monu1.cc.monash.edu.au (130.194.1.101).
X     Fetch pub/gnuplot3.5.tar.Z in binary mode.
X
X
XEUROPE:
X
X     Anonymous ftp to irisa.irisa.fr (131.254.2.3).
X     Fetch pub/gnuplot3.5.tar.Z in binary mode.
X
X----
X
X     DISCLAIMER - This product is not related in any way to
X     Pixar or any other commercial venture.
X
X----
X
X                                        -Thomas Williams-
X                                        -Alex Woo-
END_OF_FILE
  if test 6071 -ne `wc -c <'gnuplot/0README'`; then
    echo shar: \"'gnuplot/0README'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/0README'
fi
if test -f 'gnuplot/README.3d' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/README.3d'\"
else
  echo shar: Extracting \"'gnuplot/README.3d'\" \(6205 characters\)
  sed "s/^X//" >'gnuplot/README.3d' <<'END_OF_FILE'
X
X                   A tutorial on explicit/parametric
X                                   and
X                    everything you did not dare to ask
X                                  about
X                           curves and surfaces
X                                    in
X                                  gnuplot
X
XSeveral types of curves and surface are supported in gnuplot. Of those
Xnot every operation is supported for every curve or surface type and it
Xcan be therefore useful to understand the different types, their advantages
Xand limitations.
X
XCurves in gnuplot are almost always planar (with one exception which we
Xwill deal with in the end) and are assumed to be in the XY plane.
XTherefore only X and Y coordinates are needed for plotting curves.
XThe simplest curve is the `explicit function`. This curve is in fact a
Xfunction and for each given x, there is one and only one y value associated
Xwith it. A gnuplot example for such type is `plot sin(x)` or
X`plot "datafile" using 1". Note the later is using only a single column from
Xthe data file which is assumed to be the y values.
X
XAlternatively one can define a `parametric curve` form. In this case
Xx and y are both functions of a third free parameter t, while independent
Xof each other. A circle can be expressed parametrically as x = cos(t),
Xy = sin(t) and be plotted using gnuplot as
X'set parametric; plot cos(t),sin(t)'.
XThis form is not a function since there can be unlimited number of y values
Xassociated with same x. Furthermore the explicit form is a special case of
Xthe parametric representation by letting x equal to t. The curve y = sin(x)
Xcan be written in parametric form as y = sin(t), x = t.
X
XWe are used to think of the plane in cartesian coordinate system.
XIn practice, some coordinate systems may be easier to use then others
Xunder some circumstances. The polar form uses a different basis
Xto span the XY plane. In this representation the cartesian x coordinate
Xis equal to r cos(t) and the cartesian y coordinate is equal to r sin(t).
XTo draw a unit circle using the polar coordinate system in gnuplot use the
Xfollowing simple command: 'set polar; plot 1'. To better understand this
Xexplicit form lets backup a little.
XWhen we plot a regular explicit function like `y = sin(x)` we march in equal
Xsteps in x, evaluate the provided function and plot a piecewise linear curve
Xbetween the sampled points approximating the real function. In the polar
Xexplicit form we do exactly the same thing, but we march along the angular
Xdirection - we turn around the origin, computing the length of the radius
Xat that angle. Since for the unit circle, this radius is a constant 1,
X`plot 1` in polar form plots a circle (if t domain is from 0 or 2Pi).
XNote the polar form is explicit in that for each angle there is only a
Xsingle radius.
X
XSurprisingly (or maybe not so surprising) surfaces share the same
Xrepresentations. Since surfaces are two dimensional entities, they
Xrequire two free parameters (like t for curves).
X
XA surface explicit function uses x and y as the free parameters. For
Xeach such pair it provides a single z value. An example for this form
Xcan be `splot sin(sqrt(x**2+y**2))/sqrt(x**2+y**2)` for a three dimensional
Xsinc function or `splot 'datafile' using 1`. As for curves, the single column
Xused from the data file defines the function value or z in this case.
XThe order of the x and y function values is very strict in this form and
Xsimply defines a rectangular grid in the XY plane. Fortunately this
Xstrict form allows us to apply a very simplistic hidden line algorithm
Xcalled "the floating horizon". This hidden line algorithm exploits the
Xrectangular XY domain of the surface and therefore may be used for this
Xtype of surfaces only. Since in gnuplot this is the only form of hidden
Xlines removing algorithm provided, only explicit surfaces may have their
Xhidden lines removed.
X
XParametric surfaces are the exact extension for explicit surfaces as in
Xthe curves case. the x, y, and z are defined in terms of two new free
Xvariables and are totally independent of each other as x(u, v), y(u, v),
Xand z(u, v). Again the explicit surface is a special case of the parametric
Xrepresentation where x = u, and y = v. Examples for plotting parametric
Xsurfaces in gnuplot can be `splot cos(u)*cos(v),cos(u)*sin(v),sin(u)` which
Xdefines a sphere, or `splot "datafile" using 1:2:3`. Since these are
Xparametric surfaces, gnuplot must be informed to handle them by issuing
X`set parametric`.
X
XThe curve polar form takes the obvious extensions in the surface world.
XThe first possible extension is spherical coordinate system, while the
Xsecond is the cylindrical one. These modes currently work for data files
Xonly and both requires two parameters, theta and phi for mapping onto the
Xunit sphere, and theta and z form mapping on a unit radius cylinder as follow:
X
X        Spherical coord.                        Cylin. coord.
X        ----------------                        -------------
X        x = cos( theta ) * cos( phi )           x = cos( theta )
X        y = sin( theta ) * cos( phi )           y = sin( theta )
X        z = sin( phi )                          z = z
X
XThis subject brings us back to non planar curves. When surfaces are displayed
Xunder gnuplot, isocurves are actually getting plotted. An isocurve is a
Xcurve on the surface in which one of the two free parameters of the
Xsurface is fixed. For example the u isolines of a surface are drawn by
Xsetting u to be fixed and varying v along the entire v domain. The v isolines
Xare similarly drawn by fixing v. When data files are specified they are
Xclassified internally into two types. A surface is tagged to have grid
Xtopology if all its specified isolines are of the same length. A data mesh
Xof five isolines, seven points each is an example. In such a case the
Xsurface cross isolines are drawn as well. Seven isolines with five points
Xeach will be automatically created and drawn for grid type data. If
Xhowever, isolines of different length are found in the data, it is
Xtagged as nongrid surface and in fact is nothing more than a collection
Xof three dimensional curves. Only the provided data is plotted in that
Xcase (see world.dem for such an example).
END_OF_FILE
  if test 6205 -ne `wc -c <'gnuplot/README.3d'`; then
    echo shar: \"'gnuplot/README.3d'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/README.3d'
fi
if test -f 'gnuplot/demo/contours.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/contours.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/contours.dem'\" \(4657 characters\)
  sed "s/^X//" >'gnuplot/demo/contours.dem' <<'END_OF_FILE'
X#
X# $Id: contours.dem%v 3.38.2.146 1993/06/30 21:24:08 woo Exp woo $
X#
Xset samples 20
Xset isosamples 21
Xset xlabel "X axis" -5,-2
Xset ylabel "Y axis" 4,-1
Xset zlabel "Z axis"
Xset title "3D gnu plot demo - contour plot"
Xset contour
Xsplot x*y
Xpause -1 "Hit return to continue (1)"
Xset cntrparam levels 20
Xset title "3D gnu plot demo - contour plot (more contours)"
Xreplot
Xpause -1 "Hit return to continue (2)"
Xset cntrparam levels incr -100,10,100
Xset title "3D gnu plot demo - contour plot (every 10, starting at -100)"
Xreplot
Xpause -1 "Hit return to continue (3)"
Xset cntrparam levels disc -75,-50,0
Xset title "3D gnu plot demo - contour plot (at -75, -50, 0)"
Xreplot
Xpause -1 "Hit return to continue (4)"
Xset cntrparam levels auto 10
Xset title "3D gnu plot demo - contour plot on base grid"
Xset contour base
Xsplot x**2-y**2
Xpause -1 "Hit return to continue (5)"
Xset title "3D gnu plot demo - contour plot on surface"
Xset contour surface
Xreplot
Xpause -1 "Hit return to continue (6)"
Xset title "3D gnu plot demo - contour plot on both"
Xset contour both
Xreplot
Xpause -1 "Hit return to continue (7)"
Xset contour base
Xset title "3D gnu plot demo - 2 surfaces
Xsplot x**2*y**3, x**3*y**2
Xpause -1 "Hit return to continue (8)"
Xset title "3D gnu plot demo - some more interesting contours"
Xsplot x*y / (x**2 + y**2 + 0.1)
Xpause -1 "Hit return to continue (9)"
Xsplot [x=-3:3] [y=-3:3] sin(x) * cos(y)
Xpause -1 "Hit return to continue (10)"
Xset zrange [-0.5:0.5]
Xreplot
Xpause -1 "Hit return to continue (11)"
Xset samples 6
Xset isosamples 6
Xset cntrparam levels 5
Xset title "3D gnu plot demo - low resolution (6x6)"
Xreplot
Xpause -1 "Hit return to continue (12)"
Xset cntrparam bspline
Xset title "3D gnu plot demo - low resolution (6x6) using bspline approx."
Xreplot
Xpause -1 "Hit return to continue (13)"
Xset cntrparam order 8
Xset title "3D gnu plot demo - low resolution (6x6) raise bspline order."
Xreplot
Xpause -1 "Hit return to continue (14)"
Xset cntrparam linear
Xset auto
Xset title "3D gnu plot demo - low resolution (6x6) using linear contours."
Xsplot x*y
Xpause -1 "Hit return to continue (15)"
Xset cntrparam order 4
Xset cntrparam bspline
Xset title "3D gnu plot demo - low resolution (6x6) using bspline approx."
Xreplot
Xpause -1 "Hit return to continue (16)"
Xset samples 25
Xset isosamples 26
Xset title "3D gnu plot demo - contour of Sinc function"
Xsplot [-5:5.01] [-5:5.01] sin(sqrt(x**2+y**2)) / sqrt(x**2+y**2)
Xpause -1 "Hit return to continue (17)"
Xsplot [-12:12.01] [-12:12.01] sin(sqrt(x**2+y**2)) / sqrt(x**2+y**2)
Xpause -1 "Hit return to continue (18)"
Xset cntrparam levels 10
Xset xrange [0:15]
Xset yrange [0:15]
Xset auto
Xset zrange [-0.6:0.6]
Xset data style lines
Xset title "3D gnu plot demo - contour of data grid plotting"
Xset parametric
Xsplot "glass.dat"
Xpause -1 "Hit return to continue (19)"
Xset zrange [-1.2:1.2]
Xset noparametric
Xsplot "glass.dat" using 1
Xpause -1 "Hit return to continue (20)"
Xset view 0,0,1
Xset nosurface
Xset title "3D gnu plot demo - 2D contour projection of last plot"
Xreplot
Xpause -1 "Hit return to continue (21)"
X
X#From: shen@athena.cs.uga.edu (Mingzuo Shen)
X#Subject: Rosenbrock's function: some answers and thanks
X#Date: Wed, 23 Jun 1993 20:50:36 GMT
X#
X#    Last night I asked for help with a contour plot for the function:
X#
X#    (1-x)**2 + 100 * (y - x**2)**2
X#
X#which should have a minimum at (x=1,y=1). This is the 2D case of a more
X#general function named after Rosenbrock (the book I am reading does not
X#give a reference to any paper/book by this person):
X#
X#    for even integer n,
X#
X#    f(x) = \sum_{j=1,3,5,\ldots,n} [(1 - x_j)^2 + 100(x_{j+1} - x_j^2)^2]
X#
X#where x is a vector (x1, x2, ..., x_n). This function also have a minimum
X#at (1,1,...,1), which lies at the base of a "banana-shaped valley".
X#Here are the new commands I have tried.
X#
Xset auto
Xset surface
Xset nocontour
Xset cntrparam levels 5
Xset cntrparam linear
Xset samples 100
Xset logscale z
Xset hidden3d
Xset isosamples 20
Xset view 70,335,1
Xset xlabel "x"
Xset ylabel "y"
Xset title "Rosenbrock Function"
Xsplot [0.9:1.1] [0.9:1.1] (1-x)**2 + 100*(y - x**2)**2
Xpause -1 "Hit Return to Continue (22)"
X
Xset logscale z
Xset hidden3d
Xset isosamples 60
Xset view 20,340,1,2
Xset xlabel "x"
Xset ylabel "y"
Xsplot [-1.5:1.5] [-0.5:1.5] (1-x)**2 + 100*(y - x**2)**2
Xpause -1 "Hit Return to Continue (23)"
Xset contour
Xset nosurface
Xreplot
Xpause -1 "Hit Return to Continue (24)"
X#
X# Clean up:
X#
Xset nolog
Xset surface
Xset nocontour
Xset cntrparam levels 5
Xset cntrparam linear
Xset samples 100
Xset isosamples 10
Xset view 60,30,1,1
Xset xrange [-10:10]
Xset yrange [-10:10]
Xset zrange [-10:10]
Xset auto
Xset title "" 0,0
Xset xlabel "" 0,0
Xset ylabel "" 0,0
Xset zlabel "" 0,0
END_OF_FILE
  if test 4657 -ne `wc -c <'gnuplot/demo/contours.dem'`; then
    echo shar: \"'gnuplot/demo/contours.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/contours.dem'
fi
if test -f 'gnuplot/demo/stat.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/stat.inc'\"
else
  echo shar: Extracting \"'gnuplot/demo/stat.inc'\" \(6353 characters\)
  sed "s/^X//" >'gnuplot/demo/stat.inc' <<'END_OF_FILE'
X#
X# $Id: stat.inc 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X# Library of Statistical Functions version 3.0
X#
X# Permission granted to distribute freely for non-commercial purposes only
X#
X# Copyright (c) 1991, 1992 Jos van der Woude, jvdwoude@hut.nl
X
X# If you don't have the gamma() and/or lgamma() functions in your library,
X# you can use the following recursive definitions. They are correct for all
X# values i / 2 with i = 1, 2, 3, ... This is sufficient for most statistical
X# needs.
X#logsqrtpi = log(sqrt(pi))
X#lgamma(x) = (x<=0.5)?logsqrtpi:((x==1)?0:log(x-1)+lgamma(x-1))
X#gamma(x) = exp(lgamma(x))
X
X# If you have the lgamma() function compiled into gnuplot, you can use
X# alternate definitions for some PDFs. For larger arguments this will result
X# in more efficient evalution. Just uncomment the definitions containing the
X# string `lgamma', while at the same time commenting out the originals.
X# NOTE: In these cases the recursive definition for lgamma() is NOT sufficient!
X
X# Some PDFs have alternate definitions of a recursive nature. I suppose these
X# are not really very efficient, but I find them aesthetically pleasing to the
X# brain.
X
X# Define useful constants
Xfourinvsqrtpi=4.0/sqrt(pi)
Xinvpi=1.0/pi
Xinvsqrt2pi=1.0/sqrt(2.0*pi)
Xlog2=log(2.0)
Xsqrt2=sqrt(2.0)
Xsqrt2invpi=sqrt(2.0/pi)
Xtwopi=2.0*pi
X
X# define variables plus default values used as parameters in PDFs
X# some are integers, others MUST be reals
Xa=1.0
Xalpha=0.5
Xb=2.0
Xdf1=1
Xdf2=1
Xg=1.0
Xlambda=1.0
Xm=0.0
Xmm=1
Xmu=0.0
Xnn=2
Xn=2
Xp=0.5
Xq=0.5
Xr=1
Xrho=1.0
Xsigma=1.0
Xu=1.0
X
X#
X#define 1.0/Beta function
X#
XBinv(p,q)=exp(lgamma(p+q)-lgamma(p)-lgamma(q))
X
X#
X#define Probability Density Functions (PDFs)
X#
X
X# NOTE:
X# The discrete PDFs are calulated for all real values, using the int()
X# function to truncate to integers. This is a monumental waste of processing
X# power, but I see no other easy solution. If anyone has any smart ideas
X# about this, I would like to know. Setting the sample size to a larger value
X# makes the discrete PDFs look better, but takes even more time.
X
X# Arcsin PDF
Xarcsin(x)=invpi/sqrt(r*r-x*x)
X
X# Beta PDF
Xbeta(x)=Binv(p,q)*x**(p-1.0)*(1.0-x)**(q-1.0)
X
X# Binomial PDF
X#binom(x)=n!/(n-int(x))!/int(x)!*p**int(x)*(1.0-p)**(n-int(x))
X
Xbin_s(x)=n!/(n-int(x))!/int(x)!*p**int(x)*(1.0-p)**(n-int(x))
Xbin_l(x)=exp(lgamma(n+1)-lgamma(n-int(x)+1)-lgamma(int(x)+1)\
X+int(x)*log(p)+(n-int(x))*log(1.0-p))
Xbinom(x)=(n<50)?bin_s(x):bin_l(x)
X
X# Cauchy PDF
Xcauchy(x)=b/(pi*(b*b+(x-a)**2))
X
X# Chi-square PDF
X#chi(x)=x**(0.5*df1-1.0)*exp(-0.5*x)/gamma(0.5*df1)/2**(0.5*df1)
Xchi(x)=exp((0.5*df1-1.0)*log(x)-0.5*x-lgamma(0.5*df1)-df1*0.5*log2)
X
X# Erlang PDF
Xerlang(x)=lambda**n/(n-1)!*x**(n-1)*exp(-lambda*x)
X
X# Extreme (Gumbel extreme value) PDF
Xextreme(x)=alpha*(exp(-alpha*(x-u)-exp(-alpha*(x-u))))
X
X# F PDF
Xf(x)=Binv(0.5*df1,0.5*df2)*(df1/df2)**(0.5*df1)*x**(0.5*df1-1.0)/\
X(1.0+df1/df2*x)**(0.5*(df1+df2))
X
X# Gamma PDF
X#g(x)=lambda**rho*x**(rho-1.0)*exp(-lambda*x)/gamma(rho)
Xg(x)=exp(rho*log(lambda)+(rho-1.0)*log(x)-lgamma(rho)-lambda*x)
X
X# Geometric PDF
X#geometric(x)=p*(1.0-p)**int(x)
Xgeometric(x)=exp(log(p)+int(x)*log(1.0-p))
X
X# Half normal PDF
Xhalfnormal(x)=sqrt2invpi/sigma*exp(-0.5*(x/sigma)**2)
X
X# Hypergeometric PDF
Xhypgeo(x)=(int(x)>mm||int(x)<mm+n-nn)?0:\
Xmm!/(mm-int(x))!/int(x)!*(nn-mm)!/(n-int(x))!/(nn-mm-n+int(x))!*(nn-n)!*n!/nn!
X
X# Laplace PDF
Xlaplace(x)=0.5/b*exp(-abs(x-a)/b)
X
X# Logistic PDF
Xlogistic(x)=lambda*exp(-lambda*(x-a))/(1.0+exp(-lambda*(x-a)))**2
X
X# Lognormal PDF
Xlognormal(x)=invsqrt2pi/sigma/x*exp(-0.5*((log(x)-mu)/sigma)**2)
X
X# Maxwell PDF
Xmaxwell(x)=fourinvsqrtpi*a**3*x*x*exp(-a*a*x*x)
X
X# Negative binomial PDF
X#negbin(x)=(r+int(x)-1)!/int(x)!/(r-1)!*p**r*(1.0-p)**int(x)
Xnegbin(x)=exp(lgamma(r+int(x))-lgamma(r)-lgamma(int(x)+1)+\
Xr*log(p)+int(x)*log(1.0-p))
X
X# Negative exponential PDF
Xnexp(x)=lambda*exp(-lambda*x)
X
X# Normal PDF
Xnormal(x)=invsqrt2pi/sigma*exp(-0.5*((x-mu)/sigma)**2)
X
X# Pareto PDF
Xpareto(x)=x<a?0:b/x*(a/x)**b
X
X# Poisson PDF
Xpoisson(x)=mu**int(x)/int(x)!*exp(-mu)
X#poisson(x)=exp(int(x)*log(mu)-lgamma(int(x)+1)-mu)
X#poisson(x)=(x<1)?exp(-mu):mu/int(x)*poisson(x-1)
X#lpoisson(x)=(x<1)?-mu:log(mu)-log(int(x))+lpoisson(x-1)
X
X# Rayleigh PDF
Xrayleigh(x)=lambda*2.0*x*exp(-lambda*x*x)
X
X# Sine PDF
Xsine(x)=2.0/a*sin(n*pi*x/a)**2
X
X# t (Student's t) PDF
Xt(x)=Binv(0.5*df1,0.5)/sqrt(df1)*(1.0+(x*x)/df1)**(-0.5*(df1+1.0))
X
X# Triangular PDF
Xtriangular(x)=1.0/g-abs(x-m)/(g*g)
X
X# Uniform PDF
Xuniform(x)=1.0/(b-a)
X
X# Weibull PDF
Xweibull(x)=lambda*n*x**(n-1)*exp(-lambda*x**n)
X
X#
X#define Cumulative Distribution Functions (CDFs)
X#
X
X# Arcsin CDF
Xcarcsin(x)=0.5+invpi*asin(x/r)
X
X# incomplete Beta CDF
Xcbeta(x)=ibeta(p,q,x)
X
X# Binomial CDF
X#cbinom(x)=(x<1)?binom(0):binom(x)+cbinom(x-1)
Xcbinom(x)=ibeta(n-x,x+1.0,1.0-p)
X
X# Cauchy CDF
Xccauchy(x)=0.5+invpi*atan((x-a)/b)
X
X# Chi-square CDF
Xcchi(x)=igamma(0.5*df1,0.5*x)
X
X# Erlang CDF
X# approximation, using first three terms of expansion
Xcerlang(x)=1.0-exp(-lambda*x)*(1.0+lambda*x+0.5*(lambda*x)**2)
X
X# Extreme (Gumbel extreme value) CDF
Xcextreme(x)=exp(-exp(-alpha*(x-u)))
X
X# F CDF
Xcf(x)=1.0-ibeta(0.5*df2,0.5*df1,df2/(df2+df1*x))
X
X# incomplete Gamma CDF
Xcgamma(x)=igamma(rho,x)
X
X# Geometric CDF
Xcgeometric(x)=(x<1)?geometric(0):geometric(x)+cgeometric(x-1)
X
X# Half normal CDF
Xchalfnormal(x)=erf(x/sigma/sqrt2)
X
X# Hypergeometric CDF
Xchypgeo(x)=(x<1)?hypgeo(0):hypgeo(x)+chypgeo(x-1)
X
X# Laplace CDF
Xclaplace(x)=(x<a)?0.5*exp((x-a)/b):1.0-0.5*exp(-(x-a)/b)
X
X# Logistic CDF
Xclogistic(x)=1.0/(1.0+exp(-lambda*(x-a)))
X
X# Lognormal CDF
Xclognormal(x)=cnormal(log(x))
X
X# Maxwell CDF
Xcmaxwell(x)=igamma(1.5,a*a*x*x)
X
X# Negative binomial CDF
Xcnegbin(x)=(x<1)?negbin(0):negbin(x)+cnegbin(x-1)
X
X# Negative exponential CDF
Xcnexp(x)=1.0-exp(-lambda*x)
X
X# Normal CDF
Xcnormal(x)=0.5+0.5*erf((x-mu)/sigma/sqrt2)
X#cnormal(x)=0.5+((x>mu)?0.5:-0.5)*igamma(0.5,0.5*((x-mu)/sigma)**2)
X
X# Pareto CDF
Xcpareto(x)=x<a?0:1.0-(a/x)**b
X
X# Poisson CDF
X#cpoisson(x)=(x<1)?poisson(0):poisson(x)+cpoisson(x-1)
Xcpoisson(x)=1.0-igamma(x+1.0,mu)
X
X# Rayleigh CDF
Xcrayleigh(x)=1.0-exp(-lambda*x*x)
X
X# Sine CDF
Xcsine(x)=x/a-sin(n*twopi*x/a)/(n*twopi)
X
X# t (Student's t) CDF
Xct(x)=(x<0.0)?0.5*ibeta(0.5*df1,0.5,df1/(df1+x*x)):\
X1.0-0.5*ibeta(0.5*df1,0.5,df1/(df1+x*x))
X
X# Triangular PDF
Xctriangular(x)=0.5+(x-m)/g-(x-m)*abs(x-m)/(2.0*g*g)
X
X# Uniform CDF
Xcuniform(x)=(x-a)/(b-a)
X
X# Weibull CDF
Xcweibull(x)=1.0-exp(-lambda*x**n)
END_OF_FILE
  if test 6353 -ne `wc -c <'gnuplot/demo/stat.inc'`; then
    echo shar: \"'gnuplot/demo/stat.inc'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/stat.inc'
fi
if test -f 'gnuplot/makefile.msw' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.msw'\"
else
  echo shar: Extracting \"'gnuplot/makefile.msw'\" \(6444 characters\)
  sed "s/^X//" >'gnuplot/makefile.msw' <<'END_OF_FILE'
X#
X# $Id: makefile.msw%v 3.50 1993/07/09 05:35:24 woo Exp $
X#
X# Make file for Microsoft C  Version 7.0 Windows Version
X# and Microsoft Program Maintenance Utility  Version 1.20
X# 
X
X# where to place gnuplot.gih helpfile
XHELPFILE = wgnuplot.hlp
XTOP = .
X
X# /c  means don't link
X# /AL means large memory model (large code, large data)
X# /DLITE means remove hiddenline capability
X# /Gt128 means make data object > 128 FAR
X# /W1 means lower warning level
X# /I  means extra include directory
X# /GD means windows DLL
X# /GA means windows application
X# /Fm means produce link map
X# /Od means suppress optimizations (esp. for debug)
X# /Zi mean prepare for codeview
XCFLAGS = /c /ALw /FmGNUPLOT /GA /Gt128 /W1 /D__MSC__ /DREADLINE /I$(TOP) #/Zi #/Od
XDLLCC = cl /c /Asnw /FmGNUPLIB /GD /W1 /D__MSC__ /D__DLL__ /I$(TOP) #/Zi #/Od
X
X# see other terminal defines in term.h
XTERMFLAGS = 
X
X# /NOE means NO EXTernal Dictionary
X# /NOI means NO ignore case
X# /NOD means no default library (or :specified)
X# /CO prepare for codeview
XLINKFLAGS = /NOE /NOI /NOD:LLIBCE /ONERROR:NOEXE #/CO 
XDLLLINKFLAGS = /NOE /NOI /NOD /MAP #/CO
X
XOBJS =  bitmap.obj command.obj contour.obj eval.obj graphics.obj graph3d.obj \
X	internal.obj misc.obj parse.obj plot.obj readline.obj scanner.obj \
X	setshow.obj specfun.obj standard.obj term.obj util.obj version.obj \
X	gnubin.obj binary.obj winmain.obj
X
XCSOURCE5 = term\aed.trm term\cgi.trm term\dumb.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm 
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term/pbm.trm term\win.trm
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm
XCSOURCE8 = contour.c specfun.c gnubin.c binary.c
XWINDOWS = makefile.win makefile.msw README.win win\wcommon.h \
X	win\wgnuplib.c win\wgnuplib.def win\wgnuplib.h win\wgnuplib.rc\
X	win\wgnuplot.def win\wgnuplot.hpj win\wgnuplot.mnu win\wgnuplot.rc \
X	win\wgraph.c win\winmain.c win\wmenu.c win\wpause.c \
X	win\wprinter.c win\wresourc.h win\wtext.c win\wtext.h \
X	win\geticon.c docs\doc2rtf.c term\win.trm
X
Xdefault: wgnuplot.exe wgnuplot.dll $(HELPFILE) wgnuplot.mnu demo\bf_test.exe
X
X# default rules
X.c.obj:
X	cl $(CFLAGS) $*.c
X
X.asm.obj:
X	masm $*;
X
Xlinkopt2.msw: makefile.msw
X	echo winmain+bitmap+command+eval+graphics+ >linkopt2.msw
X	echo graph3d+internal+misc+parse+ >>linkopt2.msw
X	echo plot+scanner+setshow+specfun+ >>linkopt2.msw
X	echo standard+term+util+version+contour+ >>linkopt2.msw
X	echo gnubin+binary+readline >>linkopt2.msw
X	echo wgnuplot,wgnuplot, >>linkopt2.msw
X	echo wgnuplot+libw+llibcew, >>linkopt2.msw
X	echo win\wgnuplot.def >>linkopt2.msw
X	echo ; >>linkopt2.msw
X
Xwgnuplot.exe: $(OBJS) win\wgnuplot.def win\wgnuplot.rc winmain.obj wgnuplot.lib linkopt2.msw texticon.ico grpicon.ico
X	link $(LINKFLAGS) @linkopt2.msw
X	rc -30 -k -dMSRC win\wgnuplot.rc wgnuplot.exe
X
X# rules
X
Xpcgraph.obj: pcgraph.asm header.mac lineproc.mac
X
Xcorgraph.obj: corgraph.asm header.mac lineproc.mac
X
Xhrcgraph.obj: hrcgraph.asm header.mac lineproc.mac
X
Xbinary.obj: binary.c 
X
Xbitmap.obj: bitmap.c bitmap.h plot.h
X
Xcommand.obj: command.c plot.h setshow.h help.h
X	cl $(CFLAGS) /DHELPFILE=\"$(HELPFILE)\" command.c
X
Xcontour.obj: contour.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgnubin.obj: gnubin.c
X
Xgraphics.obj: graphics.c plot.h setshow.h
X
Xgraph3d.obj: graphics.c plot.h setshow.h
X
Xhelp.obj: help.c plot.h help.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h setshow.h
X
Xparse.obj: parse.c plot.h
X
Xplot.obj: plot.c plot.h setshow.h
X
Xreadline.obj: readline.c
X
Xscanner.obj: scanner.c plot.h
X
Xsetshow.obj: setshow.c plot.h setshow.h
X
Xstandard.obj: standard.c plot.h
X
Xspecfun.obj: specfun.c plot.h
X
Xterm.obj: term.c term.h plot.h setshow.h bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	cl $(CFLAGS) $(TERMFLAGS) /Iterm term.c
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
Xwinmain.obj: win\winmain.c win\wgnuplib.h win\wtext.h plot.h
X	cl $(CFLAGS) /DHELPFILE=\"$(HELPFILE)\"  win\winmain.c
X
Xwgnuplot.mnu: win\wgnuplot.mnu
X	copy win\wgnuplot.mnu wgnuplot.mnu
X
X# extract icons from wgnuplot.rc
Xtexticon.ico: grpicon.ico
X
Xgrpicon.ico: geticon.exe win\wgnuplot.rc
X	geticon win\wgnuplot.rc
X
Xgeticon.exe: win\geticon.c
X	cl /AS /W1 win\geticon.c
X
X# different compiler options for DLL's */
XDLLOBJS = wgnuplib.obj wtext.obj wmenu.obj wpause.obj wgraph.obj wprinter.obj
X
Xlinkopt1.msw: makefile.msw
X	echo wgnuplib+wtext+wmenu+wpause+wgraph+wprinter > linkopt1.msw
X	echo wgnuplot.dll  >> linkopt1.msw
X	echo wgnuplib.map >> linkopt1.msw
X	echo libw+commdlg+shell+sdllcew >> linkopt1.msw
X	echo win\wgnuplib.def >> linkopt1.msw
X	echo ; >> linkopt1.msw
X
Xwgnuplot.lib: wgnuplot.dll
X	implib wgnuplot.lib wgnuplot.dll
X
Xwgnuplot.dll: $(DLLOBJS) win/wgnuplib.def win/wgnuplib.rc linkopt1.msw
X	link $(DLLLINKFLAGS) @linkopt1.msw
X	rc -30 -t win\wgnuplib.rc wgnuplot.dll
X
Xwgnuplib.obj: win/wgnuplib.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wgnuplib.c
X	
Xwmenu.obj: win/wmenu.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wmenu.c
X
Xwtext.obj: win/wtext.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wtext.c
X	
Xwpause.obj: win/wpause.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wpause.c
X	
Xwprinter.obj: win/wprinter.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wprinter.c
X	
Xwgraph.obj: win/wgraph.c win/wgnuplib.h win/wcommon.h win/wresourc.h
X	$(DLLCC) win/wgraph.c
X	
X# convert gnuplot.doc to gnuplot.gih
X$(HELPFILE): doc2rtf.exe docs\gnuplot.doc win\wgnuplot.hpj
X	doc2rtf docs\gnuplot.doc win\gnuplot.rtf
X	hc31 win\wgnuplot.hpj 
X
Xdoc2rtf.exe: docs\doc2rtf.c
X	cl /AS /F 5000 /W1 docs\doc2rtf.c
X
X#make binary demo files
Xdemo\bf_test.exe: bf_test.c dbinary.obj
X        cl /AL /D__MSC__ /F 5000 /W1 /Fedemo\bf_test.exe bf_test.c dbinary.obj
X	cd demo
X	bf_test
X	cd ..
X
Xdbinary.obj: binary.c
X        cl /c /AL /DPC /D__MSC__ /F 5000 /W1 /Fodbinary.obj binary.c
X
X# clean up temporary files
Xclean:
X	del *.obj
X	del wgnuplot.map
X	del win\wgnuplot.res
X	del win\gnuplot.rtf
X	del doc2rtf.exe
X	del win\wgnuplib.res
X	del wgnuplib.map
X	del wgnuplot.lib
X	del demo\bf_test.exe
X	del linkopt1.msw
X	del linkopt2.msw
X        del *.ico
X        del geticon.exe
X	
Xveryclean: clean
X	del wgnuplot.exe
X	del wgnuplot.hlp
X	del wgnuplot.mnu
X	del wgnuplot.dll
X	del demo\binary1
X	del demo\binary2
X	del demo\binary3
END_OF_FILE
  if test 6444 -ne `wc -c <'gnuplot/makefile.msw'`; then
    echo shar: \"'gnuplot/makefile.msw'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.msw'
fi
if test -f 'gnuplot/os2/gnupmdrv.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/os2/gnupmdrv.rc'\"
else
  echo shar: Extracting \"'gnuplot/os2/gnupmdrv.rc'\" \(6139 characters\)
  sed "s/^X//" >'gnuplot/os2/gnupmdrv.rc' <<'END_OF_FILE'
X#include <os2.h>
X#include "dialogs.h"
X
XICON 1 "gnuplot.ico"
X
X
XMENU 1
XBEGIN
X    SUBMENU  "~Options" , IDM_FILE
X    BEGIN
X        MENUITEM    "Prin~ters...", IDM_PRINTSETUP
X        MENUITEM    "~Print..."   , IDM_PRINT
X        MENUITEM    "~Fonts...", IDM_FONTS
X        MENUITEM    "~Colours",  IDM_COLOURS,,MIA_CHECKED
X        SUBMENU     "~Lines", IDM_LINES
X        BEGIN
X            MENUITEM  "~Solid", IDM_LINES_SOLID,,MIA_CHECKED
X            MENUITEM  "~Thick", IDM_LINES_THICK
X        END
X        SUBMENU     "Pa~use mode", IDM_PAUSEOPT
X        BEGIN
X            MENUITEM  "~Dialog box", IDM_PAUSEDLG,,MIA_CHECKED
X            MENUITEM  "~Menu bar", IDM_PAUSEBTN
X            MENUITEM  "~Gnuplot", IDM_PAUSEGNU
X        END
X        MENUITEM  SEPARATOR
X        MENUITEM    "~Save settings", IDM_SAVE
X    END
X    MENUITEM "~Gnuplot" , IDM_COMMAND
X    MENUITEM "~Continue" , IDM_CONTINUE,,MIA_DISABLED
X    SUBMENU "~Help", 1
X    BEGIN
X        MENUITEM "~Help for Help...",    IDM_HELPFORHELP
X        MENUITEM "~Extended Help...",    IDM_EXTENDEDHELP
X        MENUITEM "~Keys Help...",        IDM_KEYSHELP
X        MENUITEM "Help ~index...",       IDM_HELPINDEX
X        MENUITEM SEPARATOR
X        MENUITEM "A~bout...",            IDM_ABOUT
X    END
XEND
X
XACCELTABLE 1
XBEGIN
X    VK_ESC, IDM_COMMAND, VIRTUALKEY 
XEND
X
XDLGTEMPLATE ID_ABOUT LOADONCALL MOVEABLE DISCARDABLE
XBEGIN
X    DIALOG  "", ID_ABOUT, 22, 17, 144, 75, 
X    BEGIN
X        CTEXT           "GnuplotPM", -1, 8, 65, 128, 8
X        CTEXT           "Gnuplot display for OS/2", -1, 8, 50, 128, 8
X        CTEXT           "$Revision: 3.50 $", -1, 8, 35, 128, 8
X        DEFPUSHBUTTON   "OK", DID_OK, 56, 10, 32, 14, WS_GROUP
X    END
XEND
X
XDLGTEMPLATE ID_QPRINT LOADONCALL MOVEABLE DISCARDABLE
XBEGIN
X    DIALOG  "GnuplotPM: printer setup", ID_QPRINT, 83, 7, 220, 175, 
X            FS_NOBYTEALIGN | WS_VISIBLE, FCF_TITLEBAR
X    BEGIN
X        DEFPUSHBUTTON   "OK", DID_OK, 6, 5, 38, 13
X        PUSHBUTTON      "Cancel", DID_CANCEL, 52, 5, 38, 13
X        PUSHBUTTON      "Help", 310, 176, 5, 38, 13, BS_HELP
X        GROUPBOX        "Set plot area", -1, 2, 41, 214, 116
X        PUSHBUTTON      "Adjust...", IDD_QPRTRACK, 7, 111, 56, 13
X        CONTROL         "Text", IDD_QPRBOX, 84, 96, 98, 49, WC_STATIC, 
X                        SS_FGNDRECT | WS_VISIBLE
X        CONTROL         "", IDD_QPRFRAME, 86, 98, 71, 34, WC_STATIC, 
X                        SS_HALFTONERECT | WS_VISIBLE
X        ENTRYFIELD      "Text", IDD_QPRXSIZE, 83, 47, 36, 12, ES_RIGHT | NOT 
X                        ES_AUTOSCROLL | ES_READONLY
X        ENTRYFIELD      "", IDD_QPRXFRAC, 168, 47, 39, 8, NOT ES_AUTOSCROLL | 
X                        ES_MARGIN
X        LTEXT           "Vertical size:", -1, 8, 63, 66, 8, NOT WS_GROUP
X        LTEXT           "Horizontal size:", -1, 8, 47, 70, 8, NOT WS_GROUP
X        ENTRYFIELD      "Text", IDD_QPRYSIZE, 83, 63, 36, 12, ES_RIGHT | NOT 
X                        ES_AUTOSCROLL | ES_READONLY
X        ENTRYFIELD      "", IDD_QPRYFRAC, 168, 63, 39, 8, NOT ES_AUTOSCROLL | 
X                        ES_MARGIN
X        LTEXT           "Or enter fraction of indicated size:", -1, 9, 79, 
X                        143, 8, NOT WS_GROUP
X        LTEXT           "cm", -1, 125, 63, 13, 8, NOT WS_GROUP
X        LTEXT           "cm", -1, 125, 47, 13, 8
X        PUSHBUTTON      "Job properties...", IDD_QPRSETPR, 98, 5, 72, 13
X        LTEXT           "Print to file named:", IDD_PRINTQNAME, 8, 28, 80, 8, 
X                        DT_HALFTONE
X        ENTRYFIELD      "", IDD_QPRNAME, 91, 28, 87, 8, NOT ES_AUTOSCROLL | 
X                        ES_MARGIN
X        LTEXT           "Adjust using", -1, 8, 136, 72, 8
X        LTEXT           "mouse...", -1, 8, 127, 37, 8
X        LTEXT           "Current printer:", -1, 8, 161, 64, 8
X        ENTRYFIELD      "", IDD_PRINTNAME, 74, 161, 139, 8, ES_MARGIN
X    END
XEND
X
XDLGTEMPLATE IDD_QUERYPRINT LOADONCALL MOVEABLE DISCARDABLE
XBEGIN
X    DIALOG  "GnuplotPM: printer selection", IDD_QUERYPRINT, 59, 44, 243, 99, 
X            FS_NOBYTEALIGN | WS_VISIBLE, FCF_SYSMENU | FCF_TITLEBAR
X    BEGIN
X        LTEXT           "Select printer:", IDD_QPTEXT, 4, 89, 65, 8
X        LISTBOX         IDD_QPRSLIST, 5, 29, 232, 60
X        DEFPUSHBUTTON   "OK", DID_OK, 5, 5, 38, 13, WS_GROUP
X        PUSHBUTTON      "Cancel", DID_CANCEL, 54, 5, 38, 13
X        PUSHBUTTON      "Help", 310, 102, 5, 38, 13, BS_HELP
X    END
XEND
X
XDLGTEMPLATE IDD_PAUSEBOX LOADONCALL MOVEABLE DISCARDABLE
XBEGIN
X    DIALOG  "Gnuplot: pause", IDD_PAUSEBOX, 69, 27, 148, 33, WS_VISIBLE, 
X            FCF_TITLEBAR | FCF_MINBUTTON
X    BEGIN
X        PUSHBUTTON      "Continue", DID_OK, 1, 0, 40, 14
X        PUSHBUTTON      "Cancel", DID_CANCEL, 54, 0, 40, 14
X        PUSHBUTTON      "Help", 310, 106, 0, 40, 14, BS_HELP
X        LTEXT           "Text", IDD_PAUSETEXT, 0, 20, 148, 8
X    END
XEND
X
XHELPSUBTABLE 1
XBEGIN
X    HELPSUBITEM  IDH_EXTENDED, IDH_EXTENDED
X    HELPSUBITEM  IDM_PRINTSETUP ,IDM_PRINTSETUP 
X    HELPSUBITEM  IDM_PRINT ,IDM_PRINT 
X    HELPSUBITEM  IDM_FONTS ,IDM_FONTS 
X    HELPSUBITEM  IDM_FILE ,IDM_FILE 
X    HELPSUBITEM  IDM_ABOUT ,IDM_ABOUT 
X    HELPSUBITEM  IDM_COLOURS ,IDM_COLOURS 
X    HELPSUBITEM  IDM_LINES ,IDM_LINES 
X    HELPSUBITEM  IDM_LINES_THICK ,IDM_LINES_THICK 
X    HELPSUBITEM  IDM_LINES_SOLID ,IDM_LINES_SOLID
X    HELPSUBITEM  IDM_SAVE ,IDM_SAVE 
X    HELPSUBITEM  IDM_COMMAND ,IDM_COMMAND  
X    HELPSUBITEM  IDM_CONTINUE,IDM_CONTINUE
X    HELPSUBITEM  IDM_PAUSEDLG,IDM_PAUSEDLG 
X    HELPSUBITEM  IDM_PAUSEOPT,IDM_PAUSEOPT 
X    HELPSUBITEM  IDM_PAUSEBTN,IDM_PAUSEBTN 
X    HELPSUBITEM  IDM_PAUSEGNU,IDM_PAUSEGNU 
XEND
XHELPSUBTABLE ID_PRINT
XBEGIN
X    HELPSUBITEM  ID_PRINT, ID_PRINT
XEND
XHELPSUBTABLE ID_QPRINT
XBEGIN
X    HELPSUBITEM  ID_QPRINT, ID_QPRINT
XEND
XHELPSUBTABLE IDD_QUERYPRINT
XBEGIN
X    HELPSUBITEM  IDD_QUERYPRINT, IDD_QUERYPRINT
XEND
XHELPSUBTABLE IDD_PAUSEBOX
XBEGIN
X    HELPSUBITEM  IDD_PAUSEBOX, IDD_PAUSEBOX
XEND
XHELPTABLE 1
XBEGIN
X    HELPITEM 1, 1, IDH_EXTENDED
X    HELPITEM ID_QPRINT, ID_QPRINT, ID_QPRINT
X    HELPITEM ID_PRINT, ID_PRINT, ID_PRINT
X    HELPITEM IDD_QUERYPRINT, IDD_QUERYPRINT, IDD_QUERYPRINT
X    HELPITEM IDD_PAUSEBOX, IDD_PAUSEBOX, IDD_PAUSEBOX
XEND
X
X
END_OF_FILE
  if test 6139 -ne `wc -c <'gnuplot/os2/gnupmdrv.rc'`; then
    echo shar: \"'gnuplot/os2/gnupmdrv.rc'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/os2/gnupmdrv.rc'
fi
if test -f 'gnuplot/term.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term.h'\"
else
  echo shar: Extracting \"'gnuplot/term.h'\" \(6048 characters\)
  sed "s/^X//" >'gnuplot/term.h' <<'END_OF_FILE'
X
X/*
X * $Id: term.h%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - term.h */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X * 
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X/*
X * term.h: terminal support definitions
X *   Edit this file depending on the set of terminals you wish to support.
X * Comment out the terminal types that you don't want or don't have, and
X * uncomment those that you want included. Be aware that some terminal 
X * types (eg, SUN, UNIXPLOT) will require changes in the makefile 
X * LIBS definition. 
X */
X
X/* These terminals are not relevant for MSDOS, OS2, MS-Windows, ATARI or Amiga */
X#if !defined(MSDOS) && !defined(OS2) && !defined(_Windows) && !defined(ATARI) && !defined(AMIGA_SC_6_1) && !defined(AMIGA_AC_5)
X
X#define AED		/* AED 512 and AED 767 */
X#define BITGRAPH	/* BBN BitGraph */
X#define COREL           /* CorelDRAW! eps format */
X/* #define CGI		/* SCO CGI */
X/* #define IRIS4D	/* IRIS4D series computer */
X#define KERMIT		/* MS-DOS Kermit Tektronix 4010 emulator */
X/* #define FIG 	  	/* Fig graphics language */
X/* #define NEXT		/* NeXT workstation console */
X/* #define SUN		/* Sun Microsystems Workstation */
X#define REGIS		/* ReGis graphics (vt125, vt220, vt240, Gigis...) */
X/* #define RGIP		/* WARNING: requires POSIX: Redwood Graphics Interface Protocol UNIPLEX */
X#define SELANAR		/* Selanar */
X#define T410X		/* Tektronix 4106, 4107, 4109 and 420x terminals */
X#define TEK		/* Tektronix 4010, and probably others */
X/* #define UNIXPC	/* unixpc (ATT 3b1 or ATT 7300) */
X/* #define UNIXPLOT	/* unixplot */
X#define VTTEK		/* VT-like tek40xx emulators */
X/* #define X11		/* X11R4 window system */
X
X#define DXY800A		/* Roland DXY800A plotter */
X#define EXCL		/* QMS/EXCL laserprinter (Talaris 1590 and others) */
X
X#define HP2648		/* HP2648, HP2647 */
X#define HP26		/* HP2623A and maybe others */
X/* #define DEBUG		/* debugging terminal */
X#define HP75		/* HP7580, and probably other HPs */
X#define IMAGEN  	/* Imagen laser printers (300dpi) (requires -Iterm also) */
X
X#define PRESCRIBE	/* Kyocera Laser printer */
X#define QMS		/* QMS/QUIC laserprinter (Talaris 1200 and others) */
X
X#define TANDY60		/* Tandy DMP-130 series 60-dot per inch graphics */
X#define V384		/* Vectrix 384 and tandy color printer */
X
X#define TGIF		/* TGIF X-Windows draw tool */
X
X#endif /* !MSDOS && !OS2 && !_Windows && !_ATARI && !AMIGA */
X
X/* These terminals can be used on any system */
X#define AIFM		/* Adobe Illustrator Format */
X#define DUMB
X
X
X#define DXF		/* DXF format for use with AutoCad (Release 10.x) */
X
X#define EEPIC		/* EEPIC-extended LaTeX driver, for EEPIC users */
X#define EMTEX		/* LATEX picture environment with EMTEX specials */
X#define EPS180		/* Epson-style 180-dot per inch (24 pin) printers */
X#define EPS60		/* Epson-style 60-dot per inch printers */
X#define EPSONP		/* Epson LX-800, Star NL-10, NX-1000 and lots of others */
X/* #define FIG 	  	/* Fig graphics language */
X#define GPIC		/* gpic for groff */
X/* #define GRASS	/* GRASS (geographic info system) monitor */
X#define HP500C		/* HP DeskJet 500 Color */
X#define HPGL		/* HP7475, HP7220 plotters, and (hopefully) lots of others */
X#define HPLJII		/* HP LaserJet II */
X#define HPPJ		/* HP PaintJet */
X#define LATEX		/* LATEX picture environment */
X#define MF			/* METAFONT driver */
X#define MIF			/* Frame Maker MIF 3.00 format driver */
X#define NEC			/* NEC CP6 pinwriter  and LQ-800 printer */
X#define OKIDATA		/* OKIDATA  320/321 standard 60-dpi printers */
X#define PBM			/* PBMPLUS portable bitmap */
X#define PCL			/* orignal HP LaserJet III */
X#define POSTSCRIPT	/* PostScript */
X#define PSLATEX		/* LaTeX picture environment with PostScript \specials */
X#define PSTRICKS	/* LaTeX picture environment with PSTricks macros */
X#define STARC		/* Star Color Printer */
X#define TEXDRAW         /* TeXDraw drawing package for LaTeX */
X#define TPIC		/* TPIC specials for TeX */
X
X/* These are for Amiga only */
X#if defined(AMIGA_SC_6_1) || defined(AMIGA_AC_5)
X#define AMIGASCREEN	/* Amiga custom screen */
X#undef  AIFM
X#undef  DXF
X#undef  FIG
X#undef  MIF
X#endif
X
X/* These are for MSDOS only */
X#ifdef MSDOS
X#ifdef __TURBOC__
X#define ATT6300		/* AT&T 6300 graphics */
X#else
X#define ATT6300		/* AT&T 6300 graphics */
X#define CORONA		/* Corona graphics 325 */
X#define HERCULES	/* IBM PC/Clone with Hercules graphics board */
X#endif /* __TURBOC__ */
X#endif /* MSDOS */
X
X#ifdef OS2
X#define OS2PM
X#endif /*OS2 */
X
X#ifdef GISBASE
X#define GRASS
X#endif
END_OF_FILE
  if test 6048 -ne `wc -c <'gnuplot/term.h'`; then
    echo shar: \"'gnuplot/term.h'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term.h'
fi
if test -f 'gnuplot/term/dumb.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/dumb.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/dumb.trm'\" \(6308 characters\)
  sed "s/^X//" >'gnuplot/term/dumb.trm' <<'END_OF_FILE'
X/*
X * $Id: dumb.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - dumb.trm */
X/*
X * Copyright (C) 1991, 1992
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   DUMB terminals
X *
X * AUTHORS
X *   Francois Pinard, 91-04-03
X *           INTERNET: pinard@iro.umontreal.ca
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X#define DUMB_AXIS_CONST '\1'
X#define DUMB_BORDER_CONST '\2'
X
X#define DUMB_XMAX 79
X#define DUMB_YMAX 24
X
Xstatic char *dumb_matrix = NULL;      /* matrix of characters */
Xstatic char *dumb_priority = NULL;    /* matrix of priority at each position */
Xstatic char dumb_pen;                 /* current character used to draw */
Xstatic int dumb_x;                    /* current X position */
Xstatic int dumb_y;                    /* current Y position */
Xstatic int dumb_xmax = DUMB_XMAX;
Xstatic int dumb_ymax = DUMB_YMAX;
X
X#define DUMB_PIXEL(x,y) dumb_matrix[dumb_xmax*(y)+(x)]
X
X
Xdumb_set_pixel(x,y,v,p)
Xint x,y,v,p;
X{
X  if (p > dumb_priority[dumb_xmax*y+x])
X    {
X      dumb_matrix[dumb_xmax*y+x] = v;
X      dumb_priority[dumb_xmax*y+x] = p;
X    }
X}
X
X
XDUMB_options()
X{
X  int x,y;
X  struct value a;
X  extern struct value *const_express();
X  extern double real();
X
X  if (!END_OF_COMMAND) {
X    x = (int) real(const_express(&a));
X    if (!END_OF_COMMAND) {
X      y = (int) real(const_express(&a));
X      dumb_xmax = term_tbl[term].xmax = x;
X      dumb_ymax = term_tbl[term].ymax = y;
X    }
X  }
X
X  sprintf(term_options, "%d %d",dumb_xmax,dumb_ymax);
X}
X
X
XDUMB_init()
X{
X  if (dumb_matrix)
X    free(dumb_matrix);
X
X  dumb_matrix = alloc ((unsigned long)dumb_xmax * dumb_ymax * 2, "dumb terminal");
X
X  dumb_priority = dumb_matrix + dumb_xmax * dumb_ymax;
X}
X
X
Xchar *
XDUMB_str_state()
X{
X   static char str[80];
X
X   sprintf( str, "%d %d", dumb_xmax, dumb_ymax );
X
X   return str;
X}
X
X
XDUMB_graphics ()
X{
X  int i;
X  char *pm = dumb_matrix, *pp = dumb_priority;
X
X  for ( i = dumb_xmax * dumb_ymax; i > 0; i-- ) {
X    *pm++ = ' ';
X    *pp++ = 0;
X  }
X}
X
X
XDUMB_text ()
X{
X  int x, y, l;
X
X  putc ('\f', outfile);
X  for (y = dumb_ymax - 1; y >= 0; y--)
X    {
X      for (l = dumb_xmax; l > 0 && DUMB_PIXEL (l - 1, y) == ' '; l--)
X       ;
X      for (x = 0; x < l; x++)
X       putc (DUMB_PIXEL (x, y), outfile);
X      if (y > 0)
X       putc ('\n', outfile);
X    }
X  fflush (outfile);
X}
X
X
XDUMB_reset()
X{
X  free (dumb_matrix);
X  dumb_matrix = NULL;
X}
X
X
XDUMB_linetype(linetype)
Xint linetype;
X{
X  static char pen_type[7] = {'*', '#', '$', '%', '@', '&', '='};
X
X  if (linetype == -2)
X    dumb_pen = DUMB_BORDER_CONST;
X  else if (linetype == -1)
X    dumb_pen = DUMB_AXIS_CONST;
X  else
X    {
X      linetype = linetype % 7;
X      dumb_pen = pen_type[linetype];
X    }
X}
X
X
XDUMB_move(x, y)
Xint x, y;
X{
X  dumb_x = x;
X  dumb_y = y;
X}
X
X
XDUMB_point(x,y,point)
Xint x,y,point;
X{
X  dumb_set_pixel (x, y, point == -1 ? '.' : point % 26 + 'A', 4);
X}
X
X
XDUMB_vector(x,y)
Xint x,y;
X{
X  char pen, pen1;
X  int priority;
X  int delta;
X
X  if (abs (y - dumb_y) > abs (x - dumb_x))
X    {
X      switch (dumb_pen)
X       {
X       case DUMB_AXIS_CONST:
X         pen = ':';
X         pen1 = '+';
X         priority = 1;
X         break;
X
X       case DUMB_BORDER_CONST:
X         pen = '|';
X         pen1 = '+';
X         priority = 2;
X         break;
X
X       default:
X         pen = dumb_pen;
X         pen1 = dumb_pen;
X         priority = 3;
X         break;
X       }
X      dumb_set_pixel (dumb_x, dumb_y, pen1, priority);
X      for (delta = 1; delta < abs (y - dumb_y); delta++)
X       dumb_set_pixel (dumb_x
X                       + (int) ((double) (x - dumb_x) * delta / abs(y - dumb_y)
X                                + 0.5),
X                       dumb_y + delta * sign (y - dumb_y),
X                       pen, priority);
X      dumb_set_pixel (x, y, pen1, priority);
X    }
X  else if (abs (x - dumb_x) > abs (y - dumb_y))
X    {
X      switch (dumb_pen)
X       {
X       case DUMB_AXIS_CONST:
X         pen = '.';
X         pen1 = '+';
X         priority = 1;
X         break;
X
X       case DUMB_BORDER_CONST:
X         pen = '-';
X         pen1 = '+';
X         priority = 2;
X         break;
X
X       default:
X         pen = dumb_pen;
X         pen1 = dumb_pen;
X         priority = 3;
X         break;
X       }
X      dumb_set_pixel (dumb_x, dumb_y, pen1, priority);
X      for (delta = 1; delta < abs (x - dumb_x); delta++)
X       dumb_set_pixel (dumb_x + delta * sign (x - dumb_x),
X                       dumb_y +
X                       (int) ((double) (y - dumb_y) * delta / abs(x - dumb_x)
X                              + 0.5),
X                       pen, priority);
X      dumb_set_pixel (x, y, pen1, priority);
X    }
X  else
X    {
X      switch (dumb_pen)
X       {
X       case DUMB_AXIS_CONST:	/* zero length axis */
X         pen = '+';
X         priority = 1;
X         break;
X
X       case DUMB_BORDER_CONST:	/* zero length border */
X         pen = '+';
X         priority = 2;
X         break;
X
X       default:
X         pen = dumb_pen;
X         priority = 3;
X         break;
X       }
X      for (delta = 0; delta <= abs (x - dumb_x); delta++)
X	dumb_set_pixel (dumb_x + delta * sign (x - dumb_x),
X			dumb_y + delta * sign (y - dumb_y),
X			pen, priority);
X    }
X  dumb_x = x;
X  dumb_y = y;
X}
X
X
XDUMB_put_text(x,y,str)
Xint x, y;
Xchar *str;
X{
X  int length;
X
X  length = strlen(str);
X  if (x + length > dumb_xmax)
X    x = max (0, dumb_xmax - length);
X
X  for (; x < dumb_xmax && *str; x++, str++)
X    dumb_set_pixel (x, y, *str, 5);
X}
X
X
XDUMB_arrow (sx,sy,ex,ey)
Xint sx,sy,ex,ey;
X{
X  char saved_pen;
X  char saved_x;
X  char saved_y;
X
X  saved_pen = dumb_pen;
X  saved_x = dumb_x;
X  saved_y = dumb_y;
X
X  dumb_pen = '>';
X  dumb_x = sx;
X  dumb_y = sy;
X  DUMB_vector (ex,ey);
X
X  dumb_pen = saved_pen;
X  dumb_x = saved_x;
X  dumb_y = saved_y;
X}
END_OF_FILE
  if test 6308 -ne `wc -c <'gnuplot/term/dumb.trm'`; then
    echo shar: \"'gnuplot/term/dumb.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/dumb.trm'
fi
if test -f 'gnuplot/term/excl.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/excl.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/excl.trm'\" \(6188 characters\)
  sed "s/^X//" >'gnuplot/term/excl.trm' <<'END_OF_FILE'
X/*
X * $Id: excl.trm 3.38.2.18 1992/11/23 21:54:22 woo Exp $
X *
X */
X
X/* Copyright (c) 1992 by P. Klosowski at NIST.  All Rights Reserved 
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X ***     $Id: excl.trm 3.38.2.18 1992/11/23 21:54:22 woo Exp $
X     
X  NAME
X     quic
X   PURPOSE
X     QUIC driver for GNUPLOT
X   NOTES
X     
X   HISTORY
X     przemek - Aug 16, 1992: Created.
X***/
X/*
Xc               *****************************************
Xc               *****************************************
Xc               ******                              *****
Xc               ******   EXCL command definitions   *****
Xc               ******                              *****
Xc               *****************************************
Xc               *****************************************
X*/
X
X/*  Define ansi command headers, NUL character */
X#define ESC "\033"
X#define GS  "\035"
X#define CSI "\033["
X#define DCS "\033P"
X#define ST  "\033\\"
X
X/*
Xpage numbers are given per "Talaris EXCL programmer's reference manual" M292 rev.2
XNOTE: EXCL coordinate system places (0,0) at upper left corner of the page
X
Xc EXCL commands for initialization
X
Xc     TALAMS: set ANSI                                        (p. 162)
Xc     TALMOD: set emulation *** EXCL                          (p. 164)
Xc     TALPGO: set page orient *** landscape                   (p.  81)
Xc     TALFCTL: set paper format *** 8.5x11                    (p.  85)
Xc     TALTBM: set top/bot margins  ** in land mode to full pg (p.  73)
Xc     TALLRM: set left/right margins                          (p.  75)
Xc     PUM:    set units ** units of measure set by TALPRM     (p.  67)
Xc     TALASF: Absorb cr/ff/lf/vt   ** ON                      (p. 182)
Xc     TALPOP: pop controller params                           (p. 168)
Xc     TALPSH: push controller params                          (p. 167)
Xc     TALPRM: set units of measure ** to 1/1000 inch          (p.  64)
Xc     TALGLT: set line type ** solid                          (p. 211)
Xc     TALORG: set page absolute origin ** (0,0) UL corner     (p.  78) 
Xc     TALPCW: set page clip window *** for landsc/full page   (p.  84)
Xc     TALGLP: line: **pen7x7mil*draw*smear*glyph112*font5279* (p. 208)
Xc     TALGLPE: ending for TALGLP command, forcing DRAW mode
Xc     TALGBB: bounding box; used only by qdrive               (p. 207)
Xc     TALFPO: Force page out  ** clear bitmap                 (p.  95)
Xc     TALGDW: graphical draw to hor,vert ** abs  coords       (p. 212)
Xc     TALGMV: graphical move to hor,vert ** abs  coords       (p. 213)
X*/
X#define TALAMS  "\033[0*s"
X#define TALMOD  "\033[1;0r"
X#define TALPGO  "\033[1;0p"
X#define TALFCTL "\033[0;3x"
X#define TALTBM  "\033[0;8500 v"
X#define TALLRM  "\033[0;11000v"
X#define PUM     "\033[11h"
X#define TALASF  "\033[1 z"
X#define TALPOP  "\033[*]"
X#define TALPSH  "\033[*["
X#define TALPRM  "\033[3y"
X#define TALGLT  "\033[%s*t"
X#define TALORG  "\033[0;0o"
X#define TALCCNT "\033[1;0u"
X#define TALPCW  "\033[0;8500;11000;0*c"
X#define TALGLP_init  "\033[7;7;8;1;112;5279*w"
X#define TALGLP  "\033[%d;%d;8*w"
X#define TALFPO  "\033[0*F"
X#define TALGDW "\033[0;%d;%d*d"
X#define TALGMV "\033[0;%d;%d*m"
X
X/*  TALPYL: polyline                                        (p. 222)
X**        5;0} list of 16-bit signed integers, encoded, mostly relative
X**        5,1} list of ASCII  absolute coords (if w/o +- signs)(e.g. 315:1222;)
X*/
X
X#define TALPYL  "\033P5;1}"
X
X#define EXCL_XMAX 9000
X#define EXCL_YMAX 6500
X
X#define EXCL_XLAST (EXCL_XMAX - 1)
X#define EXCL_YLAST (EXCL_YMAX - 1)
X
X#define EXCL_VCHAR		120
X#define EXCL_HCHAR		70
X#define EXCL_VTIC		70
X#define EXCL_HTIC		70
X
XEXCL_init()
X{
X  fprintf(outfile,"%s%s%s%s%s%s",
X  	          TALPSH,TALAMS,TALMOD,TALCCNT,TALFCTL,TALASF);
X/*                ^save state   ^setEXCL       ^PaperSize8.5x11       */
X/*                       ^setANSI      ^copyCount1     ^absorbCtlChar */
X  fprintf(outfile, "%s%s%s%s%s%s",
X		  PUM,TALPRM,TALPGO,TALPCW,TALORG,TALGLP_init);
X  fprintf(outfile,                                            TALGLT,"");
X/*                ^setUnits  ^landscape    ^OriginZero        ^SolidLine   */
X/*                    ^Units1/1000" ^pageClip     ^SetLine            */
X}
X
XEXCL_graphics()
X{
X}
X
XEXCL_text()
X{
X	fprintf(outfile,TALFPO );
X	/*              ^pageout  */
X}
X
X
XEXCL_linetype(linetype)
Xint linetype;
X{
X/* excl line widths in mils: 4 is mimimum, but too thin; then 
X   7,10,14,17,20,24,27...
X   exclpen=MOD(NPEN,8)*7
X   CSI  exclpen; exclpen; TALGLPE
X*/
X  static char *type[2+9]={ 
X    "", "40;40", "",  "42;42",  "14;21",
X    /*   ....   ----  -- -- --   . . .   */
X     "",  "49;30",  "14;21",         "",  "49;30",  "14;21"
X    /*  same pattern, but thicker..  and thicker       */
X    };
X  static int width[2+9] = {14, 7,    7, 7, 7, 10, 10, 10, 17, 17, 17};
X  if (linetype >= 9)
X    linetype %= 9;
X  fprintf(outfile,TALGLP,width[linetype+2],width[linetype+2]); 
X  /*	          ^width in dots */
X  fprintf(outfile,TALGLT,type[linetype+2]);
X  /*              ^line type     */
X}
X
X
XEXCL_move(x,y)
Xint x,y;
X{
X	fprintf(outfile,TALGMV, 1000 + x, EXCL_YLAST + 1000 - y);
X/*	                 ^pen up vector*/
X}
X
X
XEXCL_vector(x2,y2)
Xint x2,y2;
X{
X	fprintf(outfile,TALGDW, 1000 + x2, EXCL_YLAST + 1000 - y2);
X/*	                 ^pen down vector*/
X}
X
X
XEXCL_put_text(x,y,str)
Xunsigned int x,y;
Xchar str[];
X{
Xchar ch;
X	EXCL_move(x,y - EXCL_VCHAR/3);
X	ch = *str++;
X	while(ch!='\0') {
X		putc(ch,outfile);
X		ch = *str++;
X	}
X}
X
XEXCL_reset()
X{
X	fprintf(outfile,"%s%s", TALFPO, TALPOP);
X	/*                      ^pageout ^pop  */
X}
X
X
X
END_OF_FILE
  if test 6188 -ne `wc -c <'gnuplot/term/excl.trm'`; then
    echo shar: \"'gnuplot/term/excl.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/excl.trm'
fi
if test -f 'gnuplot/term/hppj.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/hppj.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/hppj.trm'\" \(6012 characters\)
  sed "s/^X//" >'gnuplot/term/hppj.trm' <<'END_OF_FILE'
X/*
X * $Id: hppj.trm%v 3.50.1.11 1993/08/10 03:55:03 woo Exp $
X *
X */
X
X/* GNUPLOT - hppj.trm */
X/*
X * Copyright (C) 1990   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  hppj
X *
X * AUTHORS
X *  Dan Merget (danm@sr.hp.com)
X *
X * This file was based on the hpljii file by:
X *  John Engels
X *  Russell Lang
X *  Maurice Castro
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/* The following HP laserjet series II driver uses generic bit mapped graphics
X * routines from bitmap.c to build up a bit map in memory.
X */
X
X#ifdef HPPJ
X
X/* We define 3 different font sizes: 5x9, 9x17, and 13x25 */
X
X#define HPPJ_DPI 180   /* dots per inch */
X#define HPPJ_PLANES 3  /* color planes */
X#define HPPJ_COLORS (1 << HPPJ_PLANES)
X/* make XMAX and YMAX a multiple of 8 */
X#define HPPJ_XMAX (8*(unsigned int)(9.5 * HPPJ_DPI / 8.0 + 0.9))
X#define HPPJ_YMAX (8 * HPPJ_DPI)
X
X/* default values for term_tbl */
X#define HPPJ_9x17_VCHAR FNT9X17_VCHAR
X#define HPPJ_9x17_HCHAR FNT9X17_HCHAR
X#define HPPJ_9x17_VTIC (FNT9X17_VCHAR / 2)
X#define HPPJ_9x17_HTIC (FNT9X17_HCHAR / 2)
X
Xstatic int hppj_font = FNT9X17;
X
XHPPJoptions()
X{
X    char opt[10];
X#define HPPJERROR "expecting font size FNT5X9, FNT9X17, or FNT13X25"
X
X    term_options[0]='\0'; /* default to empty string and 9x17 font */
X    hppj_font = FNT9X17;  /* in case of error or empty options     */
X
X    if ( !END_OF_COMMAND ) {
X        if ( token[c_token].length > 8 ) {
X            int_error(HPPJERROR, c_token);
X       }
X
X        capture(opt, c_token, c_token);
X        if ( !strcmp(opt, "FNT5X9") ) {
X            hppj_font = FNT5X9;
X            strcpy(term_options, "FNT5X9");
X	} else if ( !strcmp(opt, "FNT9X17") ) {
X   	    hppj_font = FNT9X17;
X            strcpy(term_options, "FNT9X17");
X	} else if ( !strcmp(opt, "FNT13X25") ) {
X   	    hppj_font = FNT13X25;
X            strcpy(term_options, "FNT13X25");
X	} else {
X	    int_error(HPPJERROR, c_token);
X	}
X	c_token++;
X    }
X}
X
X
XHPPJinit()
X{
X#ifdef REOPEN_BINARY
X    reopen_binary();
X#endif
X}
X
X
XHPPJreset()
X{
X#ifdef vms
X    fflush_binary();
X#endif /* vms */
X}
X
X
XHPPJgraphics()
X{
X    switch ( hppj_font ) {
X      case FNT5X9 :
X	term_tbl[term].v_char = FNT5X9_VCHAR;
X	term_tbl[term].h_char = FNT5X9_HCHAR;
X	term_tbl[term].v_tic = FNT5X9_VCHAR / 2;
X	term_tbl[term].h_tic = FNT5X9_HCHAR / 2;
X	break;
X      case FNT9X17 :
X	term_tbl[term].v_char = FNT9X17_VCHAR;
X	term_tbl[term].h_char = FNT9X17_HCHAR;
X	term_tbl[term].v_tic = FNT9X17_VCHAR / 2;
X	term_tbl[term].h_tic = FNT9X17_HCHAR / 2;
X	break;
X      case FNT13X25 :
X	term_tbl[term].v_char = FNT13X25_VCHAR;
X	term_tbl[term].h_char = FNT13X25_HCHAR;
X	term_tbl[term].v_tic = FNT13X25_VCHAR / 2;
X	term_tbl[term].h_tic = FNT13X25_HCHAR / 2;
X	break;
X    }
X    b_charsize(hppj_font);
X
X    b_makebitmap(HPPJ_XMAX, HPPJ_YMAX, HPPJ_PLANES);
X}
X
X
XHPPJtext()
X{
X    int x, plane, y;	/* loop indexes */
X    int minRow, maxRow;	/* loop bounds */
X    int numBytes;	/* Number of run-length coded bytes to output */
X    int numReps;	/* Number of times the current byte is repeated */
X
X    fprintf(outfile, "\033E\033*t%dR\033*r%dS", HPPJ_DPI, HPPJ_YMAX);
X    fprintf(outfile, "\033*b0X\033*b0Y\033*r%dU", HPPJ_PLANES);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI", 90, 88, 85, 0);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI", 53,  8, 14, 1);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI",  3, 26, 22, 2);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI",  4,  4, 29, 3);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI", 53,  5, 25, 4);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI",  2, 22, 64, 5);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI", 89, 83, 13, 6);
X    fprintf(outfile, "\033*v%dA\033*v%dB\033*v%dC\033*v%dI",  4,  4,  6, 7);
X    fprintf(outfile, "\033*b1M\033*r1A");
X
X    /* dump bitmap in raster mode using run-length encoding */
X    for ( x = HPPJ_XMAX - 1 ; x >= 0 ; --x ) {
X        for ( plane = 0 ; plane < HPPJ_PLANES ; plane++ ) {
X            minRow = b_psize * plane;
X            maxRow = b_psize * plane + b_psize - 1;
X
X            /* Print column header */
X            numBytes = 0;
X            for ( y = maxRow ; y >= minRow ; --y ) {
X                if ( y == minRow || *((*b_p)[y]+x) != *((*b_p)[y-1]+x) ) {
X                    numBytes += 2;
X                }
X            }
X            fprintf(outfile, "\033*b%d", numBytes);
X            (void) fputc((char)(plane < HPPJ_PLANES - 1 ? 'V' : 'W'), outfile);
X
X            /* Print remainder of column */
X            numReps = 0;
X            for ( y = maxRow ; y >= minRow ; --y ) {
X                if ( y == minRow || *((*b_p)[y]+x) != *((*b_p)[y-1]+x) ) {
X                    (void) fputc( (char)(numReps), outfile );
X                    (void) fputc( (char)(*((*b_p)[y]+x)), outfile );
X                    numReps = 0;
X                } else {
X                    numReps++;
X                }
X            }
X        }
X    }
X    fprintf(outfile, "\033*r1B\033E");
X
X    b_freebitmap();
X}
X
X
XHPPJlinetype(linetype)
X    int linetype;
X{
X    if ( linetype >= 0 ) {
X        b_setlinetype(0);
X        b_setvalue((linetype % (HPPJ_COLORS-1)) + 1);
X    } else {
X        b_setlinetype(linetype + 2);
X        b_setvalue(HPPJ_COLORS - 1);
X    }
X}
X
X
X#define HPPJmove       b_move
X#define HPPJvector     b_vector
X#define HPPJtext_angle b_text_angle
X#define HPPJput_text   b_put_text
X
X#endif /* HPPJ */
END_OF_FILE
  if test 6012 -ne `wc -c <'gnuplot/term/hppj.trm'`; then
    echo shar: \"'gnuplot/term/hppj.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/hppj.trm'
fi
if test -f 'gnuplot/term/sun.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/sun.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/sun.trm'\" \(6218 characters\)
  sed "s/^X//" >'gnuplot/term/sun.trm' <<'END_OF_FILE'
X/*
X * $Id: sun.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - sun.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   SUNview windowing system
X *
X * AUTHORS
X *  Maurice Castro
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X#include <suntool/sunview.h>
X#include <suntool/canvas.h>
X#include <suntool/scrollbar.h>
X#include <suntool/panel.h>
X#include <pixrect/pixrect_hs.h>
X
X#define SUN_XMAX 600
X#define SUN_YMAX 512
X
X#define SUN_VCHAR (12)		/* default, will be changed */
X#define SUN_HCHAR (8)		/* default, will be changed */
X#define SUN_VTIC (SUN_YMAX/80)
X#define SUN_HTIC (SUN_XMAX/80)
X#define MARGIN 5
X#define MINWIN 128
X
Xstatic Frame frame;
Xstatic Canvas canvas;
Xstatic Pixwin *pw;
Xstatic struct pixfont *sun_font = NULL;
X
Xstatic enum JUSTIFY sun_justify=LEFT;
X
Xstatic Notify_value local_notice_destroy();
X
Xextern Notify_error notify_dispatch();
X  
X/* dotted line generator */
Xunsigned int sun_value = 1;	/* this can be used for colour */
Xunsigned int sun_line_mask = 0xffff;	/* 16 bit mask for dotted lines */
Xstatic unsigned int sun_pattern[] = {0xffff, 0x1111,
X	0xffff, 0x5555, 0x3333, 0x7777, 0x3f3f, 0x0f0f, 0x5f5f};
Xint sun_mask_count = 0;
Xunsigned int sun_lastx, sun_lasty;	/* last pixel set - used by sun_line */
X
X
XSUN_init()
X{
X  struct termentry *t = &term_tbl[term];
X  struct pr_subregion bound;
X
X  frame = window_create(NULL, FRAME, 
X            FRAME_LABEL,               "Gnuplot",
X            0);
X  notify_interpose_destroy_func(frame,local_notice_destroy);
X  canvas = window_create(frame, CANVAS,
X            CANVAS_AUTO_EXPAND,        TRUE,
X            CANVAS_AUTO_SHRINK,        TRUE,
X            CANVAS_MARGIN,             MARGIN,
X            0);
X  notify_do_dispatch();
X  pw = canvas_pixwin(canvas);
X  window_set(frame, WIN_SHOW, TRUE, 0);
X
X  /* figure out font and rough size */
X  sun_font = pf_default();
X  pf_textbound(&bound, 1, sun_font, "M");
X  t->v_char = bound.size.y;
X  t->h_char = bound.size.x;
X
X  return;
X}
X
XSUN_graphics()
X{
X  term_tbl[term].xmax = (int) window_get(canvas,CANVAS_WIDTH);
X  term_tbl[term].ymax = (int) window_get(canvas,CANVAS_HEIGHT);
X  pw_writebackground(pw,0,0,term_tbl[term].xmax, term_tbl[term].ymax, PIX_SRC );
X  notify_dispatch();
X  /* do not let the user make the window too small */
X  if ((term_tbl[term].xmax)<MINWIN)
X  {
X      window_set(frame,
X            WIN_WIDTH,                MINWIN+2*MARGIN+24,
X            0);
X      notify_dispatch();
X      SUN_graphics();
X      }
X  if ((term_tbl[term].ymax) <MINWIN)
X  {
X      window_set(frame,
X            WIN_HEIGHT,               MINWIN+2*MARGIN+24,
X            0);
X      notify_dispatch();
X      SUN_graphics();
X      }
X  notify_dispatch();
X  return;
X}
X
XSUN_text()
X{
X  notify_dispatch();
X  return; /* enter text from another window!!! */
X}
X
XSUN_linetype(linetype)
Xint linetype;
X{
X	if (linetype>=7)
X		linetype %= 7;
X	sun_line_mask = sun_pattern[linetype+2];
X	sun_mask_count=0;
X}
X
X
XSUN_move(x, y)
Xunsigned int x, y;
X{
X  sun_lastx = x;
X  sun_lasty = y;
X  notify_dispatch();
X  return;
X}
X
XSUN_vector(x, y)
Xunsigned int x, y;
X{
X  if ( (x>=term_tbl[term].xmax) || (y>=term_tbl[term].ymax) )
X	return;
X  sun_line(sun_lastx,x,sun_lasty,y);
X  canvas_pixwin(canvas);
X  notify_dispatch();
X  return;
X}
X
X
XSUN_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
X  struct pr_subregion bound;
X
X  if ( (x>=term_tbl[term].xmax) || (y>=term_tbl[term].ymax) )
X	return;
X
X  pf_textbound(&bound, strlen(str), sun_font, str);
X  y = term_tbl[term].ymax-1-y + bound.size.y/3; /* vertical centering */
X
X  switch(sun_justify) {
X	 case LEFT:   break;
X	 case CENTRE: x -= bound.size.x/2; break;
X	 case RIGHT:  x -= bound.size.x; break;
X  }
X  pw_text(pw, x,y, PIX_SRC | PIX_DST, 0, str); 
X  canvas_pixwin(canvas);
X  notify_dispatch();
X  return;
X}
X 
X
Xint SUN_justify_text(mode)
X	enum JUSTIFY mode;
X{
X    sun_justify = mode;
X    return (TRUE);
X}
X  
X  
X
X
XSUN_reset()
X{
X  
X  term_tbl[term].xmax = SUN_XMAX;
X  term_tbl[term].ymax = SUN_YMAX;
X  window_set(frame, WIN_SHOW, FALSE, 0);
X  return;
X}
X
X
X
Xsun_setmaskpixel(x,y,value)
Xunsigned int x,y,value;
X{
X	/* dotted line generator */
X	if ((sun_line_mask>>sun_mask_count)&(unsigned int)(1)) {
X		pw_put(pw,x,term_tbl[term].ymax-1-y,sun_value);
X	}
X	sun_mask_count= (sun_mask_count+1) % 16;
X	sun_lastx= x;  /* last pixel set with mask */
X	sun_lasty= y;
X}
X
X
X
X
Xsun_line(x1,x2,y1,y2)
Xunsigned int x1,x2,y1,y2;
X{
Xint runcount;
Xint dx,dy;
Xint xinc,yinc;
Xunsigned int xplot,yplot;
X
X	runcount=0;
X	dx = abs((int)(x1)-(int)(x2));
X	if (x2>x1)  xinc=  1;
X	if (x2==x1) xinc=  0;
X	if (x2<x1)  xinc= -1;
X	dy = abs((int)(y1)-(int)(y2));
X	if (y2>y1)  yinc=  1;
X	if (y2==y1) yinc=  0;
X	if (y2<y1)  yinc= -1;
X	xplot=x1;
X	yplot=y1;
X	if (dx>dy) {
X		/* iterate x */
X		if ( (sun_line_mask==0xffff) ||
X			((xplot!=sun_lastx) && (yplot!=sun_lasty)) )
X			sun_setmaskpixel(xplot,yplot,sun_value);
X		while (xplot!=x2) { 
X			xplot+=xinc;
X			runcount+=dy;
X			if (runcount>=(dx-runcount)) {
X				yplot+=yinc;
X				runcount-=dx;
X			}
X			sun_setmaskpixel(xplot,yplot,sun_value);
X		} 
X	} else {
X		/* iterate y */
X		if ( (sun_line_mask==0xffff) ||
X			((xplot!=sun_lastx) && (yplot!=sun_lasty)) )
X			sun_setmaskpixel(xplot,yplot,sun_value);
X		while (yplot!=y2) {
X			yplot+=yinc;
X			runcount+=dx;
X			if (runcount>=(dy-runcount)) {
X				xplot+=xinc;
X				runcount-=dy;
X			}
X			sun_setmaskpixel(xplot,yplot,sun_value);
X		} 
X	}
X}
X
X
Xstatic Notify_value local_notice_destroy(frame, status)
X   Frame frame;
X   Destroy_status status;
X{
X   if (status != DESTROY_CHECKING)
X   {
X      SUN_reset();
X      term_init = FALSE;
X      }
X   return(NOTIFY_DONE);
X   }
X
END_OF_FILE
  if test 6218 -ne `wc -c <'gnuplot/term/sun.trm'`; then
    echo shar: \"'gnuplot/term/sun.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/sun.trm'
fi
if test -f 'gnuplot/term/win.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/win.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/win.trm'\" \(6130 characters\)
  sed "s/^X//" >'gnuplot/term/win.trm' <<'END_OF_FILE'
X/* GNUPLOT - term/win.trm */
X/*
X * Copyright (C) 1992   Maurice Castro, Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Gnuplot for Windows:
X *       Maurice Castro, Russell Lang
X * 
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X
X/* This file implements the terminal and printer display for gnuplot  */
X/* under Microsoft Windows. The code currently compiles only with the */
X/* Borland C++ 3.1 compiler.                                          */
X/*                                                                    */
X/* The modifications to allow Gnuplot to run under Windows were made  */
X/* by Maurice Castro (maurice@bruce.cs.monash.edu.au)                 */
X/* and Russell Lang (rjl@monu1.cc.monash.edu.au)         19 Nov 1992  */
X/*                                                                    */
X
X/* Edit this file with tabstop=4 (vi :se ts=4)                        */
X
X#include <windows.h>
X#include "../win/wgnuplib.h"
X
Xextern GW graphwin;
X
Xchar win_prntmp[256];	/* printer temporary file */
X
X/* Initialization values - Guess Now Scale later */
X#define WIN_XMAX (2400)
X#define WIN_YMAX (1800)
X#define WIN_HCHAR (WIN_XMAX/75) 
X#define WIN_VCHAR (WIN_YMAX/25)
X#define WIN_HTIC (WIN_XMAX/160)
X#define WIN_VTIC WIN_HTIC
X
X/* Interface routines - create list of actions for Windows */
X
XWIN_options()
X{
X	extern struct value *const_express();
X	extern double real();
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"d$efault")) {
X			graphwin.color=TRUE;
X			strcpy(graphwin.fontname,WINFONT);
X			graphwin.fontsize = WINFONTSIZE;
X			c_token++;
X		}
X	}
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"m$onochrome")) {
X			graphwin.color=FALSE;
X			c_token++;
X		}
X		else if (almost_equals(c_token,"c$olor")) {
X			graphwin.color=TRUE;
X			c_token++;
X		}
X	}
X
X	if (!END_OF_COMMAND && isstring(c_token)) {
X		quote_str(graphwin.fontname,c_token);
X		c_token++;
X	}
X
X	if (!END_OF_COMMAND) {
X		/* We have font size specified */
X		struct value a;
X		graphwin.fontsize = (int)real(const_express(&a));
X	}
X
X	if (graphwin.fontname[0] == '\0')
X	  sprintf(term_options,"%s", graphwin.color ? "color" :  "monochrome");
X	else
X	  sprintf(term_options,"%s \"%s\" %d", graphwin.color ? "color" :  "monochrome" ,
X		graphwin.fontname, graphwin.fontsize);
X	if (IsWindow(graphwin.hWndGraph) && IsIconic(graphwin.hWndGraph)) {
X		ShowWindow(graphwin.hWndGraph, SW_SHOWNORMAL);
X	}
X	GraphRedraw(&graphwin);
X}
X
X/* We don't actually do scaling, but we need to fix up the text size
X * if the user has resized the window */
Xint WIN_scale()
X{
X	term_tbl[term].h_char = graphwin.hchar;
X	term_tbl[term].v_char = graphwin.vchar;
X	sprintf(term_options,"%s \"%s\" %d", graphwin.color ? "color" :  "monochrome" ,
X		graphwin.fontname, graphwin.fontsize);
X	return FALSE ;	/* can't be done */
X}
X
XWIN_init()
X{
X	if (!graphwin.hWndGraph) {
X		graphwin.xmax = WIN_XMAX;
X		graphwin.ymax = WIN_YMAX;
X		graphwin.htic = WIN_HTIC;
X		graphwin.vtic = WIN_VTIC;
X		GraphInit(&graphwin);
X		SetClassWord(graphwin.hWndGraph, GCW_HICON, LoadIcon(graphwin.hInstance, "grpicon"));
X		graphwin.resized = FALSE;
X	}
X}
X
X
XWIN_reset()
X{
X}
X
XWIN_text()
X{
X	GraphEnd(&graphwin);
X}
X
XWIN_graphics()
X{
X	GraphStart(&graphwin);
X}
X
XWIN_move(x, y)
Xunsigned int x, y;
X{
X	GraphOp(&graphwin, W_move, x, y, NULL);
X}
X
XWIN_vector(x,y)
Xunsigned int x, y;
X{
X	GraphOp(&graphwin, W_vect, x, y, NULL);
X}
X
XWIN_linetype(lt)
Xint lt;
X{
X	GraphOp(&graphwin, W_line_type, lt, 0, NULL);
X}
X
XWIN_put_text(x,y,str)
Xint x, y;
Xchar *str;
X{
X	GraphOp(&graphwin, W_put_text, x, y, str);
X}
X
Xint WIN_justify_text(mode)
Xenum JUSTIFY mode;
X{
X	GraphOp(&graphwin, W_justify, mode, 0, NULL);
X    return(TRUE);
X}
X
Xint WIN_text_angle(ang)
Xint ang;
X{
X	if (graphwin.rotate)
X		GraphOp(&graphwin, W_text_angle, ang, 0, NULL);
X	return graphwin.rotate;
X}
X
XWIN_point(x,y,number)
Xint x,y;
Xint number;
X{
X	/* draw point shapes later to save memory */
X	graphwin.htic = term_tbl[term].h_tic / 2; 	/* size of point symbols */
X	graphwin.vtic = term_tbl[term].v_tic / 2;
X	if (number>=0)
X		number %= POINT_TYPES;
X	number += 1;
X	GraphOp(&graphwin, W_dot + number, x, y, NULL);
X}
X
X
X/* Windows PRN emulation */
XFILE *
Xopen_printer()
X{
Xchar *temp;
X	if ((temp = getenv("TEMP")) == (char *)NULL)
X		*win_prntmp='\0';
X	else  {
X		strncpy(win_prntmp,temp,MAX_ID_LEN-1);
X		/* stop X's in path being converted by mktemp */
X		for (temp=win_prntmp; *temp; temp++)
X			*temp = tolower(*temp);
X		if ( strlen(win_prntmp) && (win_prntmp[strlen(win_prntmp)-1]!='\\') )
X			strcat(win_prntmp,"\\");
X	}
X	strncat(win_prntmp, "_gptmp",MAX_ID_LEN-strlen(win_prntmp));
X	strncat(win_prntmp, "XXXXXX",MAX_ID_LEN-strlen(win_prntmp));
X	mktemp(win_prntmp);
X	return fopen(win_prntmp, "w");
X}
X
Xvoid
Xclose_printer()
X{
X	fclose(outfile);
X	DumpPrinter(graphwin.hWndGraph, graphwin.Title, win_prntmp);
X}
X
Xvoid
Xscreen_dump(void)
X{
X	GraphPrint(&graphwin);
X}
END_OF_FILE
  if test 6130 -ne `wc -c <'gnuplot/term/win.trm'`; then
    echo shar: \"'gnuplot/term/win.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/win.trm'
fi
echo shar: End of archive 27 \(of 33\).
cp /dev/null ark27isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
