Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i026:  gnuplot - interactive function plotting utility, Part14/33
Message-ID: <1993Oct22.163444.23882@sparky.sterling.com>
X-Md4-Signature: a62ecb7ae6c857261fb8b880e0d9709a
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 22 Oct 1993 16:34:44 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 26
Archive-name: gnuplot/part14
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/0FAQ gnuplot/0INSTALL gnuplot/win/wgraph.c
# Wrapped by kent@sparky on Wed Oct 20 17:14:48 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 33)."'
if test -f 'gnuplot/0FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/0FAQ'\"
else
  echo shar: Extracting \"'gnuplot/0FAQ'\" \(25601 characters\)
  sed "s/^X//" >'gnuplot/0FAQ' <<'END_OF_FILE'
XFrom ig25@fg70.rz.uni-karlsruhe.de Mon Sep 13 16:18:32 1993
XReturn-Path: <info-gnuplot-people-request@wildcat.dartmouth.edu>
XPath: uunet!noc.near.net!howland.reston.ans.net!xlink.net!rz.uni-karlsruhe.de!fg70.rz.uni-karlsruhe.de!ig25
XFrom: ig25@fg70.rz.uni-karlsruhe.de (Koenig)
XNewsgroups: comp.graphics.gnuplot,comp.answers,news.answers
XSubject: comp.graphics.gnuplot FAQ (Frequent Answered Questions)
XSupersedes: <comp-graphics-gnuplot-faq_746677383@fg70.rz.uni-karlsruhe.de>
XFollowup-To: comp.graphics.gnuplot
XDate: 13 Sep 1993 02:23:13 GMT
XOrganization: University of Karlsruhe, Germany
XLines: 613
XApproved: news-answers-request@MIT.Edu
XExpires: 11 Oct 1993 02:23:01 GMT
XReply-To: ig25@rz.uni-karlsruhe.de
XNntp-Posting-Host: fg70.rz.uni-karlsruhe.de
XMime-Version: 1.0
XContent-Type: text/plain; charset=iso-8859-1
XContent-Transfer-Encoding: 8bit
XSummary: This is the FAQ (Frequently Answered Questions) list of the
X         comp.graphics.gnuplot newsgroup, which discusses the
X         gnuplot program for plotting 2D - and 3D - graphs.
XKeywords: computer graphics, gnuplot
XXref: uunet comp.graphics.gnuplot:2095 comp.answers:1938 news.answers:12461
XSender: info-gnuplot-request@dartmouth.edu
XTo: info-gnuplot@dartmouth.edu
X
XArchive-name: graphics/gnuplot-faq
XVersion: $Header: comp-graphics-gnuplot,v 1.24 93/08/31 23:58:52 ig25 Exp $
X
XThis is the FAQ (Frequently Answered Questions) list of the
Xcomp.graphics.gnuplot newsgroup, which discusses the gnuplot program for
Xplotting 2D - and 3D - graphs.
X
XMost of the information in this document came from public discussion on
Xcomp.graphics.gnuplot; quotations are believed to be in the public
Xdomain.
X
XHere's a list of the questions.  If you are looking for the answer for a
Xspecific question, look for the string Qx.x:  at the beginning of a line,
Xwith x.x being the question number.
X
XQuestions:
X
XSection 0: Meta - Questions
XQ0.1: Where do I get this document?
XQ0.2: Where do I send comments about this document?
X
XSection 1: General Information
XQ1.1: What is gnuplot?
XQ1.2: How did it come about and why is it called gnuplot?
XQ1.3: Does gnuplot have anything to do with the FSF and the GNU project?
XQ1.4: What does gnuplot offer?
XQ1.5: Is gnuplot suitable for batch processing?
XQ1.6: Can I run gnuplot on my computer?
X
XSection 2: Setting it up
XQ2.1: What is the current version of gnuplot?
XQ2.2: Where can I get gnuplot?
XQ2.3: How do I get gnuplot to compile on my system?
XQ2.4: What documentation is there, and how do I get it?
X
XSection 3: Working with it
XQ3.1: How do I get help?
XQ3.2: How do I print out my graphs?
XQ3.3: How do I include my graphs in <word processor>?
X
XSection 4: Wanted features in gnuplot
XQ4.1: Does gnuplot have hidden line removal?
XQ4.2: Does gnuplot support bar-charts/histograms/boxes?
XQ4.3: Does gnuplot support multiple y-axes on a single plot?
XQ4.4: Can I put multiple plots on a single page?
XQ4.5: Can I put both data files and commands into a single file?
XQ4.6: Can I put Greek letters and super/subscripts into my labels?
XQ4.7: Can I do 1:1 scaling of axes?
XQ4.8: Can I put tic marks for x and y axes into 3d plots?
X
XSection 5: Miscellaneous
XQ5.1: I've found a bug, what do I do?
XQ5.2: Can I use gnuplot routines for my own programs?
XQ5.3: What extensions have people made to gnuplot?  Where can I get them?
XQ5.4: Can I do heavy - duty data processing with gnuplot?
XQ5.5: I have ported gnuplot to another system, or patched it.  What do I do?
X
XSection 6: Making life easier
XQ6.1: How do I plot two functions in non - overlapping regions?
XQ6.2: How do I run my data through a filter before plotting?
XQ6.3: How do I make it easier to use gnuplot with LaTeX?
XQ6.4: How do I save and restore my settings?
X
XSection 7: Known Problems
X
XQ7.1: Gnuplot is not plotting any points under X11!  How come?
XQ7.2: My isoline data generated by a Fortran program is not handled
X        correctly.  What can I do?
XQ7.3: Why does gnuplot ignore my very small numbers?
X
XSection 8: Credits
X
XQuestions and Answers:
X
XSection 0: Meta - Questions.
X
XQ0.1: Where do I get this document?
X
XThis document is posted about once every two weeks to the newsgroups
Xcomp.graphics.gnuplot, comp.answers and news.answers.  Like many other
XFAQ's, it is available via anonymous ftp from rtfm.mit.edu [18.70.0.224]
X>from the directory /pub/usenet/news.answers under the Archive-Name:  at
Xthe top of the article, graphics/gnuplot-faq, and from the directory
X/pub/usenet/comp.graphics.gnuplot, as well as via gopher from
Xgopher.univ-lyon1.fr [134.214.100.25].
X
XQ0.2: Where do I send comments about this document?
X
XSend comments, suggestions etc. via e-mail to Thomas Koenig,
Xig25@rz.uni-karlsruhe.de or ig25@dkauni2.bitnet.
X
XSection 1: General Information
X
XQ1.1: What is gnuplot?
X
XGnuplot is a command-driven interactive function plotting program.  It
Xcan be used to plot functions and data points in both two- and three-
Xdimensional plots in many different formats, and will accommodate many
Xof the needs of today's scientists for graphic data representation.
XGnuplot is copyrighted, but freely distributable; you don't have to pay
Xfor it.
X
XQ1.2: How did it come about and why is it called gnuplot?
X
XThe authors of gnuplot are:
X
XThomas Williams, Colin Kelley, Russell Lang, Dave Kotz, John Campbell,
XGershon Elber, Alexander Woo and many others.
X
XThe following quote comes from Thomas Williams:
X
XI was taking a differential equation class and Colin was taking
XElectromagnetics, we both thought it'd be helpful to visualize the
Xmathematics behind them.  We were both working as sys admin for an EE
XVLSI lab, so we had the graphics terminals and the time to do some
Xcoding.  The posting was better received than we expected, and prompted
Xus to add some, albeit lame, support for file data.
X
XAny reference to GNUplot is incorrect.  The real name of the program
Xis "gnuplot".  You see people use "Gnuplot" quite a bit because many
Xof us have an aversion to starting a sentence with a lower case
Xletter, even in the case of proper nouns and titles.  Gnuplot is not
Xrelated to the GNU project or the FSF in any but the most peripheral
Xsense.  Our software was designed completely independently and the
Xname "gnuplot" was actually a compromise.  I wanted to call it
X"llamaplot" and Colin wanted to call it "nplot."  We agreed that
X"newplot" was acceptable but, we then discovered that there was an
Xabsolutely ghastly pascal program of that name that the Computer
XScience Dept. occasionally used.  I decided that "gnuplot" would make
Xa nice pun and after a fashion Colin agreed.
X
XQ1.3: Does gnuplot have anything to do with the FSF and the GNU project?
X
XGnuplot is neither written nor maintained by the FSF.  It is not covered
Xby the General Public License, either.
X
XHowever, the FSF has decided to distribute gnuplot as part of the GNU
Xsystem, because it is useful, redistributable software.
X
XQ1.4: What does gnuplot offer?
X
X- Plotting of two - dimensional functions and data points in many different
X  styles (points, lines, error bars)
X- plotting of three - dimensional data points and surfaces in many
X  different styles (contour plot, mesh).
X- support for complex arithmetic
X- self - defined functions
X- support for a large number of operating systems, graphics file formats
X  and devices
X- extensive on-line help
X- labels for title, axes, data points
X- command line editing and history on most platforms
X
XQ1.5: Is gnuplot suitable for batch processing?
X
XYes.  You can read in files from the command line, or you can redirect
Xyour standard input to read from a file.  Both data and command files
Xcan be generated automatically, from data acquisition programs or
Xwhatever else you use.
X
XQ1.6: Can I run gnuplot on my computer?
X
XGnuplot is available for a number of platforms.  These are:  Unix (X11
Xand NeXTSTEP), VAX/VMS, OS/2, MS-DOS, Amiga, MS-Windows, OS-9/68k and
Xthe Macintosh.  Modifications for NEC PC-9801 are said to exist (where?).
XA version for the Atari ST exists at atari.archive.umich.edu, but is
Xunstable.
X
XSection 2: Setting it up
X
XQ2.1: What is the current version of gnuplot?
X
XThe current version of gnuplot is 3.4, patchlevel 4.
X
XQ2.2: Where can I get gnuplot?
X
X[This information may be dated, due to the release of gnuplot 3.4.
XPlease report any inaccuracies, if you find them.  Ed.]
X
XAll of the later addresses refer to ftp sites.  Please note that it is
Xpreferable for you to use the symbolic name, rather than the IP address
Xgiven in brackets, because that address is much more subject to change.
X
XThe official distribution site for the gnuplot source is dartmouth.edu
X[129.170.16.4], the file is called /pub/gnuplot/gnuplot.3.4.tar.Z.
XOfficial mirrors of that distribution are (for Australia)
Xmonu1.cc.monash.edu.au [130.194.1.101] and (for Europe) irisa.irisa.fr
X[131.254.254.2].  You can also get it from your friendly neighbourhood
Xcomp.sources.misc archive.
X
XMS-DOS and MS-Windows binaries are available from oak.oakland.edu (North
XAmerica) [141.210.10.117] as pub/msdos/plot/gpt34*.zip, garbo.uwasa.fi
X(Europe) [128.214.87.1] as /pc/plot/gpt34*.zip and archie.au (Australia)
X[139.130.4.6] as micros/pc/oak/plot/gpt34*.zip.  The files are:
Xgpt34doc.zip, gpt34exe.zip, gpt34src.zip and gpt34win.zip.
X
XOS/2 2.x binaries are at ftp-os2.nmsu.edu [128.123.35.151], in
X/os2/2.x/unix/gnu/gplt34.zip .
X
XAmiga sources and binaries are available from wuarchive.wustl.edu
X[128.252.135.4] as /pub/amiga/aminet/util/gnu/gnuplot-3.4*; there
Xare numerous mirrors of this distribution.
X
XThe NeXTSTEP front end can be found at sonata.cc.purdue.edu and
Xcs.orst.edu.
X
XA version for OS-9/68K can be found at cabrales.cs.wisc.edu
X[128.105.36.20] as /pub/OSK/GRAPHICS/gnuplot32x.tar.Z; it includes both
XX-Windows and non - X-windows versions.
X
XA version of gnuplot for the Macintosh is included in the gpcontrb
Xfile, or can be found at wuarchive.wustl.edu [128.252.135.4], in
Xedu/math/mac/graphingAids, as MacGnuPlot3.2.sea.hqx and
XMacGnuPlotPackage3.2.sea.hqx.
X
XPeople without ftp access can use an ftp-mail server; send mail to
Xbitftp@pucc.bitnet (for BITNET only) or ftpmail@decwrl.dec.com with the
Xword 'help' in the mail body for more information.
X
XIt is a good idea to look for a nearby ftp site when downloading things.
XYou can use archie for this.  See if an archie client is installed at
Xyour system (by simply typing archie at the command prompt), or send
Xmail to archie@sura.net with the word 'help' in both the subject line
Xand the body of the mail.  However, be aware that the version you find
Xat a near ftp site may well be out of date; check the last modification
Xdate and the number of bytes against the newest release at one of the
Xofficial servers.
X
XQ2.3: How do I get gnuplot to compile on my system?
X
XAs you would any other installation.  Read the files README and
XREADME.Install, edit the Makefile according to taste, and run make or
Xwhatever is suitable for your operating system.
X
XIf you get a complaint about a missing file libplot.a or something
Xsimilar when building gnuplot for x11, remove -DUNIXPLOT from the
XTERMFLAGS= line, remove -lplot from the LIBS= line and run again.  If
Xyou are making x11 on a sun, type 'make x11_sun'.
X
XQ2.4: What documentation is there, and how do I get it?
X
XThe documentation is included in the source distribution.  Look at the
Xdocs subdirectory, where you'll find
X
X - a Unix man page, which says how to start gnuplot
X - a help file, which also can be printed as a manual
X - a tutorial on using gnuplot with LaTeX
X - a quick reference summary sheet for TeX only
X
XPostScript copies of the documentation can be ftp'd from dartmouth.edu,
Xin pub/gnuplot, as manual.ps.Z and tutorial.ps.Z
X
X
XSection 3: Working with it
X
XQ3.1: How do I get help?
X
XGive the 'help' command at the initial prompt.  After that, keep
Xlooking through the keywords.  Good starting points are 'plot'
Xand 'set'.
X
XRead the manual, if you have it.
X
XAsk your colleagues, the system administrator or the person who set
Xup gnuplot.
X
XPost a question to comp.graphics.gnuplot or send mail to the gatewayed
Xmailing list info-gnuplot@dartmouth.edu.  If you want to subscribe to
Xthe mailing list, send mail to info-gnuplot-request@dartmouth.edu,
Xbut please don't do this if you can get comp.graphics.gnuplot directly.
XIf you pose a question there, it is considered good form to solicit
Xe-mail replies and post a summary.
X
XQ3.2: How do I print out my graphs?
X
XThe kind of output produced is determined by the 'set terminal' command;
Xfor example, 'set terminal postscript' will produce the graph in
XPostScript format.  Output can be redirected using the 'set output'
Xcommand.
X
XAs an example, the following prints out a graph of sin(x) on a Unix
Xmachine running X - Windows.
X
Xgnuplot> plot [-6:6] sin(x)
Xgnuplot> set terminal postscript
XTerminal type set to 'postscript'
XOptions are 'landscape monochrome "Courier" 14'
Xgnuplot> set output "sin.ps"
Xgnuplot> replot
Xgnuplot> set output                      # set output back to default
Xgnuplot> set terminal x11                # ditto for terminal type
Xgnuplot> ! lp -ops sin.ps                # print ps - File (site dependent)
Xrequest id is lprint-3433 (standard input)
Xlp: printed file sin.ps on fg20.rz.uni-karlsruhe.de (5068 Byte)
X!
Xgnuplot>
X
XQ3.3: How do I include my graphs in <word processor>?
X
XBasically, you save your plot to a file in a format your word processor
Xcan understand (using "set term" and "set output", see above), and then
Xyou read in the plot from your word processor.
X
XDetails depend on the kind of word processor you use; use "set term" to
Xget a list of available file formats.
X
XMany word processors can use Encapsulated PostScript for graphs.  This
Xcan be generated by the 'set terminal postscript eps' command.  Most
XMS-DOS word processors understand HPGL (terminal type hpgl).
X
XWith TeX, it depends on what you use to print your dvi files.  If you
Xuse dvips or dvi2ps, you can use Encapsulated PostScript.  For
XemTeX (popular for MS-DOS), you can use emTeX, otherwise use the
XLaTeX terminal type, which generates a picture environment.
X
XIf nothing else helps, try using the pgm or ppm format and converting it
Xto a bitmap format your favourite word processor can understand.  An
Xinvaluable tool for this is Jef Poskanzer's PBMPLUS package.
X
X
XSection 4:  Wanted features in gnuplot
X
XQ4.1: Does gnuplot have hidden line removal?
X
XVersion 3.4 supports hidden line removal on all platforms except MS-DOS;
Xuse the command
X
X	set hidden3d
X
XIf someone can solve the 64K DGROUP memory problem, gnuplot would
Xsupport hidden line removal on MS-DOS as well.  Version 3.2 supports
Xlimited hidden line removal.
X
XQ4.2: Does gnuplot support bar-charts/histograms/boxes?
X
XVersion 3.4 does.
X
XQ4.3: Does gnuplot support multiple y-axes on a single plot?
X
XNo.
X
XQ4.4: Can I put multiple plots on a single page?
X
XLook at the rosendorf subdirectory in the gpcontrb distribution;
Xif you are using PostScript output, check out mpage, which can
Xbe ftp'd from
X
Xftp.eng.umd.edu:pub/misc/mpage-2.tar.Z
X
XQ4.5: Can I put both data files and commands into a single file?
X
XAlex Woo has just put out an unofficial modification for beta test,
Xwhich does exactly this.  Otherwise, you might consider using Fudgit,
Xwhich can do it.
X
XQ4.6: Can I put Greek letters and super/subscripts into my labels?
X
XYou might try using the LaTeX terminal type and putting text like
X\alpha_{3} into it.
X
XIf you use PostScript output, you might find something in the Green
Xsubdirectory of the gpcontrb file (see Q5.3).
X
XQ4.7: Can I do 1:1 scaling of axes?
X
XNot easily.
X
XQ4.8: Can I put tic marks for x and y axes into 3d plots?
X
XThere are patches to do this on prep.ai.mit.edu.
X
X
XSection 5:  Miscellaneous
X
XQ5.1: I've found a bug, what do I do?
X
XFirst, try to see whether it actually is a bug, or whether it is a feature
Xwhich may be turned off by some obscure set - command.  If you have a
Xfairly general sort of bug report, posting to comp.graphics.gnuplot is
Xprobably the way to go.  If you have investigated a problem in detail,
Xespecially if you have a context diff that fixes the problem, please
Xe-email a report to bug-gnuplot@dartmouth.edu.  The bug-gnuplot list
Xis for reporting and collecting bug fixes, the comp.graphics.gnuplot
Xmailing list will be more help for finding work arounds or actually
Xsolving gnuplot related problems.  If you do send in a bug report, be
Xsure and include the version of gnuplot (including patchlevel), terminal
Xdriver, operating system, an exact description of the bug and input
Xwhich can reproduce the bug.  Also, any context diffs should be
Xreferenced against the latest official version of gnuplot if at all
Xpossible.
X
XQ5.2: Can I use gnuplot routines for my own programs?
X
XYes.  John Campbell <jdc@nauvax.ucc.nau.edu> has written gplotlib, a
Xversion of gnuplot as C subroutines callable from a C program.  This is
Xavailable as gplotlib.tar.Z on the machine ftp.nau.edu in the directory
X/pub/gplotlib.tar.Z.  It is also included in the gpcontrb distribution
Xin the campbell subdirectory.
X
XQ5.3: What extensions have people made to gnuplot?  Where can I get them?
X
X[This is still hazy; please check this out and see whether it is correct.
XEd.]
X
XExtensions have been put into the file gpcontrb.tar.z, which is
Xavailable with the 3.4 release, from the same places you can
Xdownload the main distribution from.
X
XNote that it is 3.5 megabytes and compressed using gzip.  The gzip
Xprogram is available from everywhere where you can find GNU software.
XThe main distribution site is prep.ai.mit.edu [18.71.0.38], in the
Xdirectory /pub/gnu.
X
XIt contains the following subdirectories:
X
Xbigler subdirectory:
X        From: bigler@cicg-calcul.grenet.fr
X        Subject: Multiple plots from a Fortran program
Xbudelsky subdirectory:
X        From: budelsky@haegar.ikp.uni-koeln.de
X        Subject: This is the information file for porting gnuplot 3.2
X                to OS-9/68000
Xbyrne subdirectory:
X        From: "Margaret R. Byrne" <mrb2j@kelvin.seas.virginia.edu>
X        Subject: congp3d3 preprocessor to draw contour plots on
X                irregular regions.
Xclark subdirectory:
X        From: Michael Clark <clarkmp@prony.Colorado.EDU>
X        Subject: data filtering: adds point_skip & point_offs
Xclift subdirectory:
X        From: ssclift@neumann.uwaterloo.ca (Simon Clift)
X        Subject: Re: Running gnuplot from Fortran, (and C)
Xgreen subdirectory:
X        From: Roque Donizete de Oliveira <oliveria@engin.umich.edu>
X        Subject: PostScript Greek symbols in gnuplot, new prologue
Xhanna subdirectory:
X        From: gregor@kafka.saic.com (gregg hanna)
X        Subject: x11-library mode, gnulib_x11.[c,h], xlibtest.c,makefile.xlib
Xklosowski subdirectory:
X        From:   Carsten Steger <stegerc@informatik.tu-muenchen.de>
X        Subject: New file "klein.dat"
X        From: przemek@rrdstrad.nist.gov (Przemek Klosowski)
X        Subject: calling gnuplot from Fortran
Xkocaturk subdirectory:
X        From: mustafa@seas.smu.edu (Mustafa Kocaturk)
X        Subject: Histograms in gnuplot
Xrichardson subdirectory:
X        From: amr@chiton.ucsd.edu (Tony Richardson)
X        Subject: Programmatic control of gnuplot from Unix
Xrosendorf subdirectory:
X        From:  prf@jprix.che.wisc.edu
X        Subject: Multiple plots on a page
Xvanzandt subdirectory:
X        From: James R. Van Zandt <jrv@mitre-bedford.ARPA>
X        Subject: Spline generating program
Xwhite subdirectory:
X        From: gwhite@bionet.bio.dfo.ca
X        Subject: gnuplot 3.2 for Titan 3000
Xwoo subdirectory:
X        From: "Alex Woo" <woo@ra-next.arc.nasa.gov>
X        Subject: two additional title lines and fixes to errorbar style
Xyamamoto subdirectory:
X        From: "NOBORU YAMAMOTO     " <sun!kekvax.kek.jp!YAMAMOTO@pixar.com>
X        Subject: Re: gnuplot on Apple Macintosh, "diff -c" of version 3.0
X                (now includes binaries)
Xcastro subdirectory:
X        From: maurice@bruce.cs.monash.edu.au (Maurice Castro)
X        Subject: Controlling gnuplot from another Windows program
Xgrammes subdirectory:
X        From: ph12hucg@rz.uni-sb.de (Carsten Grammes)
X        Subject: Nonlinear least squares fit mechanism
Xhenke subdirectory:
X        From: mgr@asgard.bo.open.de (Lars Hanke)
X        Subject: Re: Changes to gnuplot 3.3b9
Xwalton subdirectory:
X        From: dwalton@athena.mit.edu (Dave Walton)
X        Subject: Inter Process Communication stuff
X
XQ5.4: Can I do heavy - duty data processing with gnuplot?
X
XGnuplot alone is not suited very well for this.  One thing you might try
Xis fudgit, an interactive multi-purpose fitting program written by
XMartin-D. Lacasse (isaac@frodo.physics.mcgill.ca).  It can use gnuplot
Xas its graphics back end and is available from ftp.physics.mcgill.ca
Xin /pub/Fudgit/fudgit_2.33.tar.Z [132.206.9.13], and from the main Linux
Xserver, tsx-11.mit.edu [18.172.1.2] and its numerous mirrors around the
Xworld as /pub/linux/sources/usr.bin/fudgit-2.33.tar.z.  Versions are
Xavailable for AIX, Data General, HP-UX, IRIX 4, Linux, NeXT, Sun3, Sun4,
XUltrix, OS/2 and MS-DOS.  The MS-DOS version is available on simtel20
Xand mirrors in the "math" subdirectory as fudg_231.zip.
X
XCarsten Grammes has written a fitting program which goes together
Xwith gnuplot; it is called gnufit and is available from ftp.uni-kl.de
X[131.246.9.95] from the directory /pub/gnu/gnufit as gnufit10.tar.gz
Xor gft10dos.zip.
X
XYou might also want to look at the applications developed by the
XSoftware Tools Group (STG) at the National Center for Supercomputing
XApplications.  Ftp to ftp.ncsa.uiuc.edu [141.142.20.50] and get the
Xfile README.BROCHURE for more information.
X
XQ5.5: I have ported gnuplot to another system, or patched it.  What do I do?
X
XIf your patch is small, mail it to bug-gnuplot@dartmouth.edu, with
Xa thorough description of what the patch is supposed to do, which version
Xof gnuplot it is relative to, etc.  Please don't mail it to the FAQ
Xmaintainer.
X
XIf your modifications are extensive (such as a port to another system),
Xupload your modifications to dartmouth.edu:/pub/dropoff.  Please drop a
Xnote to David.Kotz@dartmouth.edu, the maintainer of the gnuplot
Xsubdirectory there, plus a note to bug-gnuplot@dartmouth.edu.
X
X
XSection 6: Making life easier
X
XQ6.1: How do I plot two functions in non - overlapping regions?
X
XUse a parametric plot.  An example:
X
Xset parametric
Xa=1
Xb=3
Xc=2
Xd=4
Xx1(t) = a+(b-a)*t
Xx2(t) = c+(d-c)*t
Xf1(x) = sin(x)
Xf2(x) = x**2/8
Xplot [t=0:1] x1(t),f1(x1(t)) title "f1", x2(t), f2(x2(t)) title "f2"
X
XQ6.2: How do I run my data through a filter before plotting?
X
XIf your system supports the popen() - function, as Unix does, you should
Xbe able to run the output through another process such as a short awk
Xprogram (use the "help plot datafile" command for an example).
XUnfortunately, in 3.2, there is a rather short limitation on the maximum
Xargument length, so your command line may be truncated (usually, this
Xwill mean that awk cannot find the filename).  Also, you may need to
Xescape the $ - characters in your awk programs.
X
XVersion 3.4 includes the thru - keyword for the plot command for running
Xdata files through a gnuplot - defined function.
X
XQ6.3: How do I make it easier to use gnuplot with LaTeX?
X
XThere is a set of LaTeX macros and shell scripts that are meant to
Xmake your life easier when using gnuplot with LaTeX.  This package can
Xbe found on dartmouth.edu [129.170.16.4] in pub/gnuplot/latex.shar, by
XDavid Kotz.  For example, the program "plotskel" can turn a
Xgnuplot-output file plot.tex into a skeleton file skel.tex, that has
Xthe same size as the original plot but contains no graph.  With the
Xright macros, the skeleton can be used for preliminary LaTeX passes,
Xreserving the full graph for later passes, saving tremendous amounts
Xof time.
X
XQ6.4: How do I save and restore my settings?
X
XUse the "save" and "load" commands for this; see "help save" and
X"help load" for details.
X
X
XSection 7: Known problems
X
XQ7.1: Gnuplot is not plotting any points under X11!  How come?
X
XVery probably, you still are using an old version of gnuplot_x11.
XRemove that, then do a full installation.
X
XQ7.2: My isoline data generated by a Fortran program is not handled
X        correctly.  What can I do?
X
XOne known cause for this is the use of list - directed output (as in
XWRITE (10,*) for generating blank lines.  Fortran uses ASA carriage
Xcontrol characters, and for list - directed output this results
Xin a space being output before the newline.  Gnuplot does not like
Xthis.
X
XThe solution is to generate blank lines using formatted output, as in
XWRITE (10,'()').
X
XQ7.3: Why does gnuplot ignore my very small numbers?
X
XGnuplot treats all numbers less than 1e-08 as zero, by default.  Thus,
Xif you are trying to plot a collection of very small numbers, they may
Xbe plotted as zero.  Worse, if you're plotting on a log scale, they will
Xbe off scale.  Or, if the whole set of numbers is "zero", your range may
Xbe considered empty:
X
Xgnuplot> plot 'test1'
XWarning: empty y range [4.047e-19:3e-11], adjusting to [-1:1]
Xgnuplot> set yrange [4e-19:3e-11]
Xgnuplot> plot 'test1'
X                     ^
X         y range is less than `zero`
X
XThe solution is to change gnuplot's idea of "zero":
X        set zero 1e-20
XFor more information,
X        help set zero
X
X
XSection 8: Credits
X
XThis list was initially compiled by John Fletcher with contributions
X>from Russell Lang, John Campbell, David Kotz, Rob Cunningham,
XDaniel Lewart and Alex Woo.  Reworked by Thomas Koenig from a draft by
XAlex Woo, with corrections and additions from Alex Woo, John Campbell,
XRussell Lang, David Kotz and many corrections from Daniel Lewart.
X-- 
XThomas Kvnig, ig25@rz.uni-karlsruhe.de, ig25@dkauni2.bitnet
XThe joy of engineering is to find a straight line on a double
Xlogarithmic diagram.
X
X
END_OF_FILE
  if test 25601 -ne `wc -c <'gnuplot/0FAQ'`; then
    echo shar: \"'gnuplot/0FAQ'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/0FAQ'
fi
if test -f 'gnuplot/0INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/0INSTALL'\"
else
  echo shar: Extracting \"'gnuplot/0INSTALL'\" \(9760 characters\)
  sed "s/^X//" >'gnuplot/0INSTALL' <<'END_OF_FILE'
XThe GNUPLOT source code and executables may be copied and/or modified
Xfreely as long as the copyright messages are left intact.
X
XSee the History file for changes to GNUPLOT.
X
XCompilation instructions are near the end of this file.
X
XGNUPLOT has been tested on Sun3's and Sun4's (SunOS 4.0.3 and 4.1.1),
Xa VAX 6410 (VMS 5.2), Commodore Amiga's (KS/WB 1.3 and 2.0, SAS/C 6.2
Xand Aztec C beta 5.2a), IBM PC XT's and AT's (MS-DOS 3.3/5.0 BC++
X3.1/TC++ 1.0 MSC 7.0), IRIS 4D/70G and 4D/25G with MIPS C, NeXT with
Xgnu C 1.34, DECStation 5000/200PXG (ULTRIX V4.1), AT&T 3B1 (version
X3.51m with cc and gcc 1.39), and Apollo's (DomainOS SR10.3 BSD4.3
Xwith C compiler 68K Rev 6.7(316)).  The code is written with
Xportability in mind.  GNUPLOT has not been tested on Pyramid 90x.
X
XThere is a mailing list for gnuplot users. Note, however, that the
Xnewsgroup 
X	comp.graphics.gnuplot 
Xis identical to the mailing list (they
Xboth carry the same set of messages). We prefer that you read the
Xmessages through that newsgroup, to subscribing to the mailing list.
X(If you can read that newsgroup, and are already on the mailing list,
Xplease send a message info-gnuplot-request@dartmouth.edu, asking to be
Xremoved from the mailing list.)
X
XThe address for mailing to list members is
X	   info-gnuplot@dartmouth.edu
Xand for mailing administrative requests is 
X	   info-gnuplot-request@dartmouth.edu
XThe mailing list for bug reports is 
X	   bug-gnuplot@dartmouth.edu
XThe list of those interested in beta-test versions is
X	   info-gnuplot-beta@dartmouth.edu
X
X[Please tell us the version and machine on which your bug occurred.]
X
X
X
X                       PREPROCESSOR #DEFINES
X
XThese #defines should be checked before compilation (see the makefiles):
Xdefine      file            note
X------      ----            --------
XNOVFORK     Makefile        define if you don't have the vfork() system call
XGAMMA       Makefile        define if you've got gamma(3)
XMEMCPY      Makefile        define if your bcopy() is called memcpy()
XMEMSET      Makefile        define if you have memset() but not bzero()
XNOCOPY      Makefile        define if you've don't have a memcpy() by any name
Xbcopy()     plot.h          define if you've got a memcpy() by some OTHER name
X                              (see example in plot.h)
XPC          Makefile        define if compiling on a PClone
XMSDOS       Makefile        define if compiling under MSDOS;
X                              automatically defined by Microsoft C 5.10
XHELPFILE    Makefile        name including path of gnuplot.gih file.
XVERYLARGE   plot.h          define to be largest coordinate number.
XSHELL       plot.h          default shell to spawn if SHELL environment
X                              variable not found at run-time
XNOCWDRC     Makefile        define to inhibit check of ./.gnuplot
XREADLINE    Makefile        define if you want command-line editing
X
XValid TERMFLAGS defines.  These defines are used to include the
Xvarious plotting terminals, printers, and protocols that a given version
Xof gnuplot can access:
X
Xdefine      file            note
X------      ----            --------
XTERMFLAGS   Makefile        the set of terminals you want, from below
X            or term.h
X
X   AED         AED 512 and AED 767
X   AIFM        Adobe Illustrator Format
X   AMIGASCREEN Amiga custom screen
X   APOLLO      Apollo Graphics Primitive Resource (resizable window)
X   ATT6300     PC with AT&T 6300 graphics
X   BITGRAPH    BBN BitGraph
X   CGI         SCO CGI
X   COREL       COREL! Draw Format
X   CORONA      PC with Corona graphics 325
X   DXY800A     Roland DXY800A plotter
X   DUMB        Printer or glass dumb terminal
X   DXF         AutoCad (Release 10.x) dxf file format
X   EEPIC       EEPIC-extended LaTeX driver, for EEPIC users
X   EGALIB      PC with EGA/VGA graphics.
X   EMTEX       LaTeX picture environment with emTeX specials
X   EPS180      Epson-LQ style 24-pin 180-dot per inch printers
X   EPS60       Epson-style 60-dot per inch printers
X   EPSONP      Epson LX-800, Star NL-10, NX-1000 and lots of others
X   EXCL        Talaris EXCL laser printer format
X   FIG         Fig graphics language (requires object.h from TransFig)
X   GPR         Apollo Graphics Primitive Resource (fixed-size window)
X   HERCULES    IBM PC/Clone with Hercules graphics board
X   HP2648      HP2648, HP2647
X   HP26        HP2623A and maybe others
X   HP500C      HP Deskjet 500 C and maybe other Color Deskjets
X   HP75        HP7580, and probably other HPs
X   HPGL        HP7475 and (hopefully) lots of others
X   HPLJII      HP Laserjet II
X   HPPJ        HP PaintJet
X   IMAGEN      Imagen laser printers (300dpi) (requires -Iterm also)
X   IRIS4D      IRIS4D series computer
X   KERMIT      MS-DOS Kermit Tektronix 4010 emulator
X   LATEX       LaTeX picture environment
X   MF          Metafont Format
X   MIF         FrameMaker MIF 3.00 Format
X   NEC         NEC CP6 pinwriter printer
X   NEXT        NeXTStep Window System (only grey scale)
X   OS2PM       OS/2 Presentation Manager
X   PBM         PBMPLUS pbm, pgm, ppm formats
X   PCL         HP PCL5 (actually  HPGL/2)
X   POSTSCRIPT  PostScript
X   PRESCRIBE   Kyocera Laser printer
X   PSLATEX     Postscript graphics, LaTeX labels and titles
X   PSTRICKS    PSTRICKS 0.91 format
X   QMS         QMS/QUIC laserprinter (Talaris 1200 and others)
X   REGIS       ReGis graphics (vt125, vt220, vt240, Gigis...)
X   RGIP        Redwood Graphics Interface Protocol
X   SELANAR     Selanar
X   STARC       Star Color Printer
X   SUN         Sun Microsystems Workstation
X   T410X       Tektronix 4106, 4107, 4109 and 420x terminals
X   TANDY60     Tandy DMP-130 series 60-dot per inch graphics
X   TEK         Tektronix 4010, and probably others
X   TEXDRAW     TeXDraw format (for LaTeX)
X   TGIF        TGIF X11 Drawing Tool
X   TPIC        Tpic specials for TeX
X   UNIXPC      unixpc (ATT 3b1 or ATT 7300)
X   UNIXPLOT    unixplot
X   V384        Vectrix 384 and tandy color printer
X   VTTEK       VT like Tektronix 4010 emulator
X   X11         X11R4 window system
X
X
XThese #defines are defined automatically by various compilers, some
Xgnuplot routines check these defines to implement features found in the
Xvarious environments:
X
Xdefine        note
X------        --------
XAMIGA_AC_5    defined for Manx Aztec C 5.2a on the Amiga
XAMIGA_SC_6_1  defined for SAS/C 6.1 or later versions on the Amiga
Xapollo        defined by Apollo's C compilers.
X_CRAY         defined by CRAY's C compiler.
X__TURBOC__    defined automatically by  Borland C++ 3.x
Xunix          defined by most unix C compilers.
Xvms           (and VMS) defined by VAX-11 C under VMS.
X__ZTC__       Zortech C compiler under MSDOS.
X_Windows      defined by Borland C++ 3.0 compiling for MS-Windows
X
X
X                             TO COMPILE
X
Xunder UNIX:
XTo compile do:
X  Copy makefile.unx to Makefile
X      cp makefile.unx Makefile
X  Look through the Makefile to see if you need to make any changes.
X  See especially the HELPDEST and TERMFLAGS variables.  Edit if needed.
X  Alternatively, all these variables may be set as command line arguments to
X  'make'. For example:
X
X        make <MACHINE> HELPDEST='/usr/um/misc/lib/gnuplot.gih' \
X                DEST='/usr/um/misc/bin' READLINE=
X
X  Edit term.h, to include/exclude terminals
X  Type
X      make
X  For further instructions.
X  If that works, try
X      make install
X  For further instructions.
X
Xunder VMS:
X  To compile:
X     copy makefile.vms makefile.
X     make
X  Or if you don't have a suitable make:
X     @buildvms
X  To tell gnuplot where to find the help library:
X      $ define gnuplot$help disk:[directory]gnuplot.hlb
X  Alternatively (and preferably) put the help in the main system help library.
X
Xunder AmigaDOS:
XUsing Aztec C 5.2a
X      make -f makefile.ami
XUsing SAS/C 6.1 or later versions
X      smake -f makefile.amg
X
XUsing Microsoft C 7.0 and compiling for MS-Windows
X      copy makefile.msw makefile
X      nmake
X  Put wgnuplot.exe, wgnuplot.dll, wgnuplot.hlp and wgnuplot.mnu
X  in the windows directory.
X
Xunder MSDOS:
XUsing Microsoft C 7.0.
X      copy makefile.msc makefile
X      nmake 
X
XUsing Borland C++ 3.1 and compiling for MS-Windows
X      copy makefile.win makefile
X  Edit makefile to change TC.
X      make
X  Put wgnuplot.exe, wgnuplot.dll, wgnuplot.hlp and wgnuplot.mnu
X  in the windows directory.
X
XUsing Borland C++ 3.0
X      copy makefile.tc makefile
X  Edit makefile to change TC, BIN, BGI, BGIOBJ. You may also want to turn
X  off overlays (See manual for more on overlays).
X      make
X
X
XThe file gnuplot.gih is needed for help on the PC.
XIf the file gnuplot.gih is not in the default directory, then use:
X    set GNUHELP={full path name of gnuplot.gih}
X
X
X                         ENVIRONMENT VARIABLES
X
XSee 'help environment'.
X
XIf the environment variable GNUTERM is found, it is used as the terminal
Xtype. Otherwise, in some cases the variable TERM will be used, or the
Xhardware may be automatically detected.
X
XThe PC version looks for the environment variable GNUPLOT to contain
Xthe name of the directory from which to load the initialization file
XGNUPLOT.INI.  See the help on 'start_up' for more information.
X
XHOME is examined as a directory where a .gnuplot startup file might be
Xfound. See help on "start-up".
X
XIf defined, the environment variable GNUHELP is used for the name
Xof the .gih help file, otherwise HELPFILE (defined in makefile or
Xplot.c) is used.
X
XThe VMS version looks for the logical name GNUPLOT$HELP to locate
Xthe help library.
X
XThe CGI drivers need the CGIPATH environment variable to set the path
Xto the CGI agents, and the CGIDISP and/or CGIPRNT environment
Xvariables to set the output devices.
X
XThe CGI drivers need the CGIPATH environment variable to set the path
Xto the CGI agents, and the CGIDISP and/or CGIPRNT environment
Xvariables to set the output devices.
END_OF_FILE
  if test 9760 -ne `wc -c <'gnuplot/0INSTALL'`; then
    echo shar: \"'gnuplot/0INSTALL'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/0INSTALL'
fi
if test -f 'gnuplot/win/wgraph.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/win/wgraph.c'\"
else
  echo shar: Extracting \"'gnuplot/win/wgraph.c'\" \(40601 characters\)
  sed "s/^X//" >'gnuplot/win/wgraph.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: wgraph.c%v 3.50.1.13 1993/08/19 03:21:26 woo Exp $";
X#endif
X
X/* GNUPLOT - win/wgraph.c */
X/*
X * Copyright (C) 1992   Maurice Castro, Russell Lang
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Maurice Castro
X *   Russell Lang
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X */
X
X#define STRICT
X#include <windows.h>
X#include <windowsx.h>
X#if WINVER >= 0x030a
X#include <commdlg.h>
X#endif
X#ifndef __MSC__
X#include <mem.h>
X#endif
X#include <string.h>
X#include "wgnuplib.h"
X#include "wresourc.h"
X#include "wcommon.h"
X
XLRESULT CALLBACK _export WndGraphProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
Xvoid ReadGraphIni(LPGW lpgw);
X
X/* ================================== */
X
X#define MAXSTR 255
X
X#define WGDEFCOLOR 15
XCOLORREF wginitcolor[WGDEFCOLOR] =  {
X	RGB(0,0,255),	/* blue */
X	RGB(0,255,0),	/* green */
X	RGB(255,0,0),	/* red */
X	RGB(255,0,255), /* magenta */
X	RGB(0,0,128),	/* dark blue */
X	RGB(128,0,0),	/* dark red */
X	RGB(0,128,128),	/* dark cyan */
X	RGB(0,0,0),	/* black */
X	RGB(128,128,128), /* grey */
X	RGB(0,128,64),	/* very dark cyan */
X	RGB(128,128,0), /* dark yellow */
X	RGB(128,0,128),	/* dark magenta */
X	RGB(192,192,192), /* light grey */
X	RGB(0,255,255),	/* cyan */
X	RGB(255,255,0),	/* yellow */
X};
X#define WGDEFSTYLE 5
Xint wginitstyle[WGDEFSTYLE] = {PS_SOLID, PS_DASH, PS_DOT, PS_DASHDOT, PS_DASHDOTDOT};
X
X/* ================================== */
X
X/* destroy memory blocks holding graph operations */
Xvoid
XDestroyBlocks(LPGW lpgw)
X{
X    struct GWOPBLK *this, *next;
X    struct GWOP FAR *gwop;
X    unsigned int i;
X
X	this = lpgw->gwopblk_head;
X	while (this != NULL) {
X		next = this->next;
X		if (!this->gwop) {
X			this->gwop = (struct GWOP FAR *)GlobalLock(this->hblk);
X		}
X		if (this->gwop) {
X			/* free all text strings within this block */
X			gwop = this->gwop;
X			for (i=0; i<GWOPMAX; i++) {
X				if (gwop->htext)
X					LocalFree(gwop->htext);
X				gwop++;
X			}
X		}
X		GlobalUnlock(this->hblk);
X		GlobalFree(this->hblk);
X		LocalFreePtr(this);
X		this = next;
X	}
X	lpgw->gwopblk_head = NULL;
X	lpgw->gwopblk_tail = NULL;
X	lpgw->nGWOP = 0;
X}
X		
X	
X/* add a new memory block for graph operations */
X/* returns TRUE if block allocated */
XBOOL 
XAddBlock(LPGW lpgw)
X{
XHGLOBAL hblk;
Xstruct GWOPBLK *next, *this;
X
X	/* create new block */
X	next = (struct GWOPBLK *)LocalAllocPtr(LHND, sizeof(struct GWOPBLK) );
X	if (next == NULL)
X		return FALSE;
X	hblk = GlobalAlloc(GHND, GWOPMAX*sizeof(struct GWOP));
X	if (hblk == NULL)
X		return FALSE;
X	next->hblk = hblk;
X	next->gwop = (struct GWOP FAR *)NULL;
X	next->next = (struct GWOPBLK *)NULL;
X	next->used = 0;
X	
X	/* attach it to list */
X	this = lpgw->gwopblk_tail;
X	if (this == NULL) {
X		lpgw->gwopblk_head = next;
X	}
X	else {
X		this->next = next;
X		this->gwop = (struct GWOP FAR *)NULL;
X		GlobalUnlock(this->hblk);
X	}
X	lpgw->gwopblk_tail = next;
X	next->gwop = (struct GWOP FAR *)GlobalLock(next->hblk);
X	if (next->gwop == (struct GWOP FAR *)NULL)
X		return FALSE;
X		
X	return TRUE;
X}
X
X
Xvoid WDPROC
XGraphOp(LPGW lpgw, WORD op, WORD x, WORD y, LPSTR str)
X{
X    struct GWOPBLK *this;
X    struct GWOP FAR *gwop;
X	char *npstr;
X	
X	this = lpgw->gwopblk_tail;
X	if ( (this==NULL) || (this->used >= GWOPMAX) ) {
X		/* not enough space so get new block */
X		if (!AddBlock(lpgw))
X			return;
X		this = lpgw->gwopblk_tail;
X	}
X	gwop = &this->gwop[this->used];
X	gwop->op = op;
X	gwop->x = x;
X	gwop->y = y;
X	gwop->htext = 0;
X	if (str) {
X		gwop->htext = LocalAlloc(LHND, _fstrlen(str)+1);
X		npstr = LocalLock(gwop->htext);
X		if (gwop->htext && (npstr != (char *)NULL))
X			lstrcpy(npstr, str);
X		LocalUnlock(gwop->htext);
X	}
X	this->used++;
X	lpgw->nGWOP++;
X	return;
X}
X
X/* ================================== */
X
Xvoid WDPROC
XGraphInit(LPGW lpgw)
X{
X	HMENU sysmenu;
X	WNDCLASS wndclass;
X	char buf[80];
X
X	if (!lpgw->hPrevInstance) {
X		wndclass.style = CS_HREDRAW | CS_VREDRAW;
X		wndclass.lpfnWndProc = WndGraphProc;
X		wndclass.cbClsExtra = 0;
X		wndclass.cbWndExtra = 2 * sizeof(void FAR *);
X		wndclass.hInstance = lpgw->hInstance;
X		wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
X		wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
X		wndclass.hbrBackground = GetStockBrush(WHITE_BRUSH);
X		wndclass.lpszMenuName = NULL;
X		wndclass.lpszClassName = szGraphClass;
X		RegisterClass(&wndclass);
X	}
X
X	ReadGraphIni(lpgw);
X
X	lpgw->hWndGraph = CreateWindow(szGraphClass, lpgw->Title,
X		WS_OVERLAPPEDWINDOW,
X		lpgw->Origin.x, lpgw->Origin.y,
X		lpgw->Size.x, lpgw->Size.y,
X		NULL, NULL, lpgw->hInstance, lpgw);
X
X	lpgw->hPopMenu = CreatePopupMenu();
X	AppendMenu(lpgw->hPopMenu, MF_STRING | (lpgw->graphtotop ? MF_CHECKED : MF_UNCHECKED), 
X		M_GRAPH_TO_TOP, "Bring to &Top");
X	AppendMenu(lpgw->hPopMenu, MF_STRING | (lpgw->color ? MF_CHECKED : MF_UNCHECKED), 
X		M_COLOR, "C&olor");
X	AppendMenu(lpgw->hPopMenu, MF_STRING, M_COPY_CLIP, "&Copy to Clipboard");
X#if WINVER >= 0x030a
X	AppendMenu(lpgw->hPopMenu, MF_STRING, M_BACKGROUND, "&Background...");
X	AppendMenu(lpgw->hPopMenu, MF_STRING, M_CHOOSE_FONT, "Choose &Font...");
X	AppendMenu(lpgw->hPopMenu, MF_STRING, M_LINESTYLE, "&Line Styles...");
X#endif
X	AppendMenu(lpgw->hPopMenu, MF_STRING, M_PRINT, "&Print...");
X	if (lpgw->IniFile != (LPSTR)NULL) {
X		wsprintf(buf,"&Update %s",lpgw->IniFile);
X		AppendMenu(lpgw->hPopMenu, MF_STRING, M_WRITEINI, (LPSTR)buf);
X	}
X
X	/* modify the system menu to have the new items we want */
X	sysmenu = GetSystemMenu(lpgw->hWndGraph,0);
X	AppendMenu(sysmenu, MF_SEPARATOR, 0, NULL);
X	AppendMenu(sysmenu, MF_POPUP, (UINT)lpgw->hPopMenu, "&Options");
X	AppendMenu(sysmenu, MF_STRING, M_ABOUT, "&About");
X
X	ShowWindow(lpgw->hWndGraph, SW_SHOWNORMAL);
X}
X
X/* close a graph window */
Xvoid WDPROC
XGraphClose(LPGW lpgw)
X{
X	/* close window */
X	if (lpgw->hWndGraph)
X		DestroyWindow(lpgw->hWndGraph);
X	TextMessage();
X	lpgw->hWndGraph = NULL;
X
X	lpgw->locked = TRUE;
X	DestroyBlocks(lpgw);
X	lpgw->locked = FALSE;
X
X}
X	
X
Xvoid WDPROC
XGraphStart(LPGW lpgw)
X{
X	lpgw->locked = TRUE;
X	DestroyBlocks(lpgw);
X	if ( !lpgw->hWndGraph || !IsWindow(lpgw->hWndGraph) )
X		GraphInit(lpgw);
X	if (IsIconic(lpgw->hWndGraph))
X		ShowWindow(lpgw->hWndGraph, SW_SHOWNORMAL);
X	if (lpgw->graphtotop)
X		BringWindowToTop(lpgw->hWndGraph);
X}
X		
Xvoid WDPROC
XGraphEnd(LPGW lpgw)
X{
XRECT rect;
X	GetClientRect(lpgw->hWndGraph, &rect);
X	InvalidateRect(lpgw->hWndGraph, (LPRECT) &rect, 1);
X	lpgw->locked = FALSE;
X	UpdateWindow(lpgw->hWndGraph);
X}
X
Xvoid WDPROC
XGraphPrint(LPGW lpgw)
X{
X	if (lpgw->hWndGraph && IsWindow(lpgw->hWndGraph))
X		SendMessage(lpgw->hWndGraph,WM_COMMAND,M_PRINT,0L);
X}
X
Xvoid WDPROC
XGraphRedraw(LPGW lpgw)
X{
X	if (lpgw->hWndGraph && IsWindow(lpgw->hWndGraph))
X		SendMessage(lpgw->hWndGraph,WM_COMMAND,M_REBUILDTOOLS,0L);
X}
X/* ================================== */
X
Xvoid
XStorePen(LPGW lpgw, int i, COLORREF ref, int colorstyle, int monostyle)
X{
X	LOGPEN FAR *plp;
X
X	plp = &lpgw->colorpen[i];
X	plp->lopnColor = ref;
X	if (colorstyle < 0) {
X		plp->lopnWidth.x = -colorstyle;
X		plp->lopnStyle = 0;
X	}
X	else {
X		plp->lopnWidth.x = 1;
X		plp->lopnStyle = colorstyle % 5;
X	}
X	plp->lopnWidth.y = 0;
X
X	plp = &lpgw->monopen[i];
X	plp->lopnColor = RGB(0,0,0);
X	if (monostyle < 0) {
X		plp->lopnWidth.x = -monostyle;
X			plp->lopnStyle = 0;
X	}
X	else {
X		plp->lopnWidth.x = 1;
X		plp->lopnStyle = monostyle % 5;
X	}
X	plp->lopnWidth.y = 0;
X}
X
Xvoid
XMakePens(LPGW lpgw, HDC hdc)
X{
X	int i;
X
X	if ((GetDeviceCaps(hdc,NUMCOLORS) == 2) || !lpgw->color) {
X		/* Monochrome Device */
X		/* create border pens */
X		lpgw->hbpen = CreatePenIndirect((LOGPEN FAR *)&lpgw->monopen[0]);	/* border */
X		lpgw->hapen = CreatePenIndirect((LOGPEN FAR *)&lpgw->monopen[1]); 	/* axis */
X		/* create drawing pens */
X		for (i=0; i<WGNUMPENS; i++)
X		{
X			lpgw->hpen[i] = CreatePenIndirect((LOGPEN FAR *)&lpgw->monopen[i+2]);
X			}
X		/* find number of solid, unit width line styles */
X		for (i=0; i<WGNUMPENS && lpgw->monopen[i+2].lopnStyle==PS_SOLID
X			&& lpgw->monopen[i+2].lopnWidth.x==1; i++) ;
X		lpgw->numsolid = i ? i : 1;	/* must be at least 1 */
X		lpgw->hbrush = CreateSolidBrush(RGB(255,255,255));
X	}
X	else {
X		/* Color Device */
X		/* create border pens */
X		lpgw->hbpen = CreatePenIndirect((LOGPEN FAR *)&lpgw->colorpen[0]);	/* border */
X		lpgw->hapen = CreatePenIndirect((LOGPEN FAR *)&lpgw->colorpen[1]); 	/* axis */
X		/* create drawing pens */
X		for (i=0; i<WGNUMPENS; i++)
X		{
X			lpgw->hpen[i] = CreatePenIndirect((LOGPEN FAR *)&lpgw->colorpen[i+2]);
X			}
X		/* find number of solid, unit width line styles */
X		for (i=0; i<WGNUMPENS && lpgw->colorpen[i+2].lopnStyle==PS_SOLID
X			&& lpgw->colorpen[i+2].lopnWidth.x==1; i++) ;
X		lpgw->numsolid = i ? i : 1;	/* must be at least 1 */
X		lpgw->hbrush = CreateSolidBrush(lpgw->background);
X	}
X}
X
Xvoid
XDestroyPens(LPGW lpgw)
X{
X	int i;
X
X	DeleteBrush(lpgw->hbrush);
X	DeletePen(lpgw->hbpen);
X	DeletePen(lpgw->hapen);
X	for (i=0; i<WGNUMPENS; i++)
X		DeletePen(lpgw->hpen[i]);
X}
X
X/* ================================== */
X
Xvoid
XMakeFonts(LPGW lpgw, LPRECT lprect, HDC hdc)
X{
X	LOGFONT lf;
X	HFONT hfontold;
X	TEXTMETRIC tm;
X	int result;
X	char FAR *p;
X	int cx, cy;
X
X	lpgw->rotate = FALSE;
X	_fmemset(&lf, 0, sizeof(LOGFONT));
X	_fstrncpy(lf.lfFaceName,lpgw->fontname,LF_FACESIZE);
X	lf.lfHeight = -MulDiv(lpgw->fontsize, GetDeviceCaps(hdc, LOGPIXELSY), 72);
X	lf.lfCharSet = DEFAULT_CHARSET;
X	if ( (p = _fstrstr(lpgw->fontname," Italic")) != (LPSTR)NULL ) {
X		lf.lfFaceName[ (unsigned int)(p-lpgw->fontname) ] = '\0';
X		lf.lfItalic = TRUE;
X	}
X	if ( (p = _fstrstr(lpgw->fontname," Bold")) != (LPSTR)NULL ) {
X		lf.lfFaceName[ (unsigned int)(p-lpgw->fontname) ] = '\0';
X		lf.lfWeight = FW_BOLD;
X	}
X
X	if (lpgw->hfonth == 0) {
X		lpgw->hfonth = CreateFontIndirect((LOGFONT FAR *)&lf);
X	}
X
X	if (lpgw->hfontv == 0) {
X		lf.lfEscapement = 900;
X		lf.lfOrientation = 900;
X		lpgw->hfontv = CreateFontIndirect((LOGFONT FAR *)&lf);
X	}
X
X	/* save text size */
X	hfontold = SelectFont(hdc, lpgw->hfonth);
X#ifdef WIN32
X	{
X	SIZE size;
X	GetTextExtentPoint(hdc,"0123456789",10, (LPSIZE)&size);
X	cx = size.cx;
X	cy = size.cy;
X	}
X#else
X	{
X	DWORD extent;
X	extent = GetTextExtent(hdc,"0123456789",10);
X	cx = LOWORD(extent);
X	cy = HIWORD(extent);
X	}
X#endif
X	lpgw->vchar = MulDiv(cy,lpgw->ymax,lprect->bottom - lprect->top);
X	lpgw->hchar = MulDiv(cx/10,lpgw->xmax,lprect->right - lprect->left);
X	/* find out if we can rotate text 90deg */
X	SelectFont(hdc, lpgw->hfontv);
X	result = GetDeviceCaps(hdc, TEXTCAPS);
X	if ((result & TC_CR_90) || (result & TC_CR_ANY))
X		lpgw->rotate = 1;
X	GetTextMetrics(hdc,(TEXTMETRIC FAR *)&tm);
X	if (tm.tmPitchAndFamily & TMPF_VECTOR)
X		lpgw->rotate = 1;	/* vector fonts can all be rotated */
X#if WINVER >=0x030a
X	if (tm.tmPitchAndFamily & TMPF_TRUETYPE)
X		lpgw->rotate = 1;	/* truetype fonts can all be rotated */
X#endif
X	SelectFont(hdc, hfontold);
X	return;
X}
X
Xvoid
XDestroyFonts(LPGW lpgw)
X{
X	if (lpgw->hfonth) {
X		DeleteFont(lpgw->hfonth);
X		lpgw->hfonth = 0;
X	}
X	if (lpgw->hfontv) {
X		DeleteFont(lpgw->hfontv);
X		lpgw->hfontv = 0;
X	}
X	return;
X}
X
Xvoid
XSetFont(LPGW lpgw, HDC hdc)
X{
X	if (lpgw->rotate && lpgw->angle) {
X		if (lpgw->hfontv)
X			SelectFont(hdc, lpgw->hfontv);
X	}
X	else {
X		if (lpgw->hfonth)
X			SelectFont(hdc, lpgw->hfonth);
X	}
X	return;
X}
X
Xvoid
XSelFont(LPGW lpgw) {
X#if WINVER >= 0x030a
X	LOGFONT lf;
X	CHOOSEFONT cf;
X	HDC hdc;
X	char lpszStyle[LF_FACESIZE]; 
X	char FAR *p;
X
X	/* Set all structure fields to zero. */
X	_fmemset(&cf, 0, sizeof(CHOOSEFONT));
X	_fmemset(&lf, 0, sizeof(LOGFONT));
X	cf.lStructSize = sizeof(CHOOSEFONT);
X	cf.hwndOwner = lpgw->hWndGraph;
X	_fstrncpy(lf.lfFaceName,lpgw->fontname,LF_FACESIZE);
X	if ( (p = _fstrstr(lpgw->fontname," Bold")) != (LPSTR)NULL ) {
X		_fstrncpy(lpszStyle,p+1,LF_FACESIZE);
X		lf.lfFaceName[ (unsigned int)(p-lpgw->fontname) ] = '\0';
X	}
X	else if ( (p = _fstrstr(lpgw->fontname," Italic")) != (LPSTR)NULL ) {
X		_fstrncpy(lpszStyle,p+1,LF_FACESIZE);
X		lf.lfFaceName[ (unsigned int)(p-lpgw->fontname) ] = '\0';
X	}
X	else
X		_fstrcpy(lpszStyle,"Regular");
X	cf.lpszStyle = lpszStyle;
X	hdc = GetDC(lpgw->hWndGraph);
X	lf.lfHeight = -MulDiv(lpgw->fontsize, GetDeviceCaps(hdc, LOGPIXELSY), 72);
X	ReleaseDC(lpgw->hWndGraph, hdc);
X	cf.lpLogFont = &lf;
X	cf.nFontType = SCREEN_FONTTYPE;
X	cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_USESTYLE;
X	if (ChooseFont(&cf)) {
X		_fstrcpy(lpgw->fontname,lf.lfFaceName);
X		lpgw->fontsize = cf.iPointSize / 10;
X		if (cf.nFontType & BOLD_FONTTYPE)
X			lstrcat(lpgw->fontname," Bold");
X		if (cf.nFontType & ITALIC_FONTTYPE)
X			lstrcat(lpgw->fontname," Italic");
X		SendMessage(lpgw->hWndGraph,WM_COMMAND,M_REBUILDTOOLS,0L);
X	}
X#endif
X}
X
X/* ================================== */
X
Xvoid
Xdrawgraph(LPGW lpgw, HDC hdc, LPRECT rect)
X{
X	int xdash, ydash;			/* the transformed coordinates */
X	int rr, rl, rt, rb;
X	struct GWOP FAR *curptr;
X	struct GWOPBLK *blkptr;
X	int htic, vtic, vshift;
X	unsigned int lastop=-1;		/* used for plotting last point on a line */
X	int pen, numsolid;
X	int polymax = 200;
X	int polyi = 0;
X	POINT *ppt;
X	unsigned int ngwop=0;
X	BOOL isColor;
X
X	if (lpgw->locked) 
X		return;
X
X 	isColor= GetDeviceCaps(hdc, NUMCOLORS) > 2;
X	if (lpgw->background != RGB(255,255,255) && lpgw->color && isColor) {
X		SetBkColor(hdc,lpgw->background);
X		FillRect(hdc, rect, lpgw->hbrush);
X	}
X
X	ppt = (POINT *)LocalAllocPtr(LHND, (polymax+1) * sizeof(POINT));
X
X	rr = rect->right;
X	rl = rect->left;
X	rt = rect->top;
X	rb = rect->bottom;
X
X	htic = MulDiv(lpgw->htic, rr-rl, lpgw->xmax) + 1;
X	vtic = MulDiv(lpgw->vtic, rb-rt, lpgw->ymax) + 1;
X
X	lpgw->angle = 0;
X	SetFont(lpgw, hdc);
X	SetTextAlign(hdc, TA_LEFT|TA_BOTTOM);
X	vshift = MulDiv(lpgw->vchar, rb-rt, lpgw->ymax)/2;
X
X	pen = 0;
X	SelectPen(hdc, lpgw->hpen[pen]);
X	numsolid = lpgw->numsolid;
X
X	/* do the drawing */
X	blkptr = lpgw->gwopblk_head;
X	curptr = NULL;
X	if (blkptr) {
X		if (!blkptr->gwop)
X			blkptr->gwop = (struct GWOP FAR *)GlobalLock(blkptr->hblk);
X		if (!blkptr->gwop)
X			return;
X		curptr = (struct GWOP FAR *)blkptr->gwop;
X	}
X	while(ngwop < lpgw->nGWOP)
X   	{
X		/* transform the coordinates */
X		xdash = MulDiv(curptr->x, rr-rl-1, lpgw->xmax) + rl;
X		ydash = MulDiv(curptr->y, rt-rb+1, lpgw->ymax) + rb - 1;
X		if ((lastop==W_vect) && (curptr->op!=W_vect)) {
X			if (polyi >= 2)
X				Polyline(hdc, ppt, polyi);
X			polyi = 0;
X		}
X		switch (curptr->op) {
X			case 0:	/* have run past last in this block */
X				break;
X			case W_move:
X				ppt[0].x = xdash;
X				ppt[0].y = ydash;
X				polyi = 1;;
X				break;
X			case W_vect:
X				ppt[polyi].x = xdash;
X				ppt[polyi].y = ydash;
X				polyi++;
X				if (polyi >= polymax) {
X					Polyline(hdc, ppt, polyi);
X					ppt[0].x = xdash;
X					ppt[0].y = ydash;
X					polyi = 1;;
X				}
X				break;
X			case W_line_type:
X				switch (curptr->x)
X				{
X				    case -2:		/* black 2 pixel wide */
X					    SelectPen(hdc, lpgw->hbpen);
X					    if (lpgw->color && isColor)
X					        SetTextColor(hdc, lpgw->colorpen[0].lopnColor);
X					    break;
X				    case -1:		/* black 1 pixel wide doted */
X					    SelectPen(hdc, lpgw->hapen);
X					    if (lpgw->color && isColor)
X					        SetTextColor(hdc, lpgw->colorpen[1].lopnColor);
X					    break;
X				    default:
X					    SelectPen(hdc, lpgw->hpen[(curptr->x)%WGNUMPENS]);
X					    if (lpgw->color && isColor)
X					        SetTextColor(hdc, lpgw->colorpen[(curptr->x)%WGNUMPENS + 2].lopnColor);
X				}
X				pen = curptr->x;
X				break;
X			case W_put_text:
X				{char *str;
X				str = LocalLock(curptr->htext);
X				if (str) {
X					ydash += vshift;
X					SetBkMode(hdc,TRANSPARENT);
X					TextOut(hdc,xdash,ydash,str,lstrlen(str));
X					SetBkMode(hdc,OPAQUE);
X				}
X				LocalUnlock(curptr->htext);
X				}
X				break;
X			case W_text_angle:
X				lpgw->angle = curptr->x;
X				SetFont(lpgw,hdc);
X				break;
X			case W_justify:
X				switch (curptr->x)
X				{
X					case LEFT:
X						SetTextAlign(hdc, TA_LEFT|TA_BOTTOM);
X						break;
X					case RIGHT:
X						SetTextAlign(hdc, TA_RIGHT|TA_BOTTOM);
X						break;
X					case CENTRE:
X						SetTextAlign(hdc, TA_CENTER|TA_BOTTOM);
X						break;
X					}
X				break;
X			case W_dot:
X				if (pen >= numsolid) {
X					pen %= numsolid;	/* select solid pen */
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash,ydash);
X				LineTo(hdc,xdash+1,ydash);
X				break;
X			case W_diamond: /* do diamond */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash-htic,ydash);
X				LineTo(hdc,xdash,ydash-vtic);
X				LineTo(hdc,xdash+htic,ydash);
X				LineTo(hdc,xdash,ydash+vtic);
X				LineTo(hdc,xdash-htic,ydash);
X				MoveTo(hdc,xdash,ydash);
X				LineTo(hdc,xdash+1,ydash);
X				break;
X			case W_plus: /* do plus */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash-htic,ydash);
X				LineTo(hdc,xdash+htic+1,ydash);
X				MoveTo(hdc,xdash,ydash-vtic);
X				LineTo(hdc,xdash,ydash+vtic+1);
X				break;
X			case W_box: /* do box */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash-htic,ydash-vtic);
X				LineTo(hdc,xdash+htic,ydash-vtic);
X				LineTo(hdc,xdash+htic,ydash+vtic);
X				LineTo(hdc,xdash-htic,ydash+vtic);
X				LineTo(hdc,xdash-htic,ydash-vtic);
X				MoveTo(hdc,xdash,ydash);
X				LineTo(hdc,xdash+1,ydash);
X				break;
X			case W_cross: /* do X */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash-htic,ydash-vtic);
X				LineTo(hdc,xdash+htic+1,ydash+vtic+1);
X				MoveTo(hdc,xdash-htic,ydash+vtic);
X				LineTo(hdc,xdash+htic+1,ydash-vtic-1);
X				break;
X			case W_triangle: /* do triangle */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash,ydash-(4*vtic/3));
X				LineTo(hdc,xdash-(4*htic/3),ydash+(2*vtic/3));
X				LineTo(hdc,xdash+(4*htic/3),ydash+(2*vtic/3));
X				LineTo(hdc,xdash,ydash-(4*vtic/3));
X				MoveTo(hdc,xdash,ydash);
X				LineTo(hdc,xdash+1,ydash);
X				break;
X			case W_star: /* do star */ 
X				if (pen >= numsolid) {
X					pen %= numsolid;
X					SelectPen(hdc, lpgw->hpen[pen]);
X				}
X				MoveTo(hdc,xdash-htic,ydash);
X				LineTo(hdc,xdash+htic+1,ydash);
X				MoveTo(hdc,xdash,ydash-vtic);
X				LineTo(hdc,xdash,ydash+vtic+1);
X				MoveTo(hdc,xdash-htic,ydash-vtic);
X				LineTo(hdc,xdash+htic+1,ydash+vtic+1);
X				MoveTo(hdc,xdash-htic,ydash+vtic);
X				LineTo(hdc,xdash+htic+1,ydash-vtic-1);
X				break;
X		}
X		lastop = curptr->op;
X		ngwop++;
X		curptr++;
X		if ((unsigned)(curptr - blkptr->gwop) >= GWOPMAX) {
X			GlobalUnlock(blkptr->hblk);
X			blkptr->gwop = (struct GWOP FAR *)NULL;
X			blkptr = blkptr->next;
X			if (!blkptr->gwop)
X				blkptr->gwop = (struct GWOP FAR *)GlobalLock(blkptr->hblk);
X			if (!blkptr->gwop)
X					return;
X				curptr = (struct GWOP FAR *)blkptr->gwop;
X		}
X	}
X	if (polyi >= 2)
X		Polyline(hdc, ppt, polyi);
X	LocalFreePtr(ppt);
X}
X
X/* ================================== */
X
X/* copy graph window to clipboard */
Xvoid
XCopyClip(LPGW lpgw)
X{
X	RECT rect;
X	HDC mem;
X	HBITMAP bitmap;
X	HANDLE hmf;
X	GLOBALHANDLE hGMem;
X	LPMETAFILEPICT lpMFP;
X	HWND hwnd;
X	HDC hdc;
X
X	hwnd = lpgw->hWndGraph;
X
X	/* view the window */
X	if (IsIconic(hwnd))
X		ShowWindow(hwnd, SW_SHOWNORMAL);
X	BringWindowToTop(hwnd);
X	UpdateWindow(hwnd);
X
X	/* get the context */
X	hdc = GetDC(hwnd);
X	GetClientRect(hwnd, &rect);
X	/* make a bitmap and copy it there */
X	mem = CreateCompatibleDC(hdc);
X	bitmap = CreateCompatibleBitmap(hdc, rect.right - rect.left,
X			rect.bottom - rect.top);
X	if (bitmap) {
X		/* there is enough memory and the bitmaps OK */
X		SelectBitmap(mem, bitmap);
X		BitBlt(mem,0,0,rect.right - rect.left, 
X			rect.bottom - rect.top, hdc, rect.left,
X			rect.top, SRCCOPY);
X	}
X	else {
X		MessageBeep(MB_ICONHAND);
X		MessageBox(hwnd, "Insufficient Memory to Copy Clipboard", 
X			lpgw->Title, MB_ICONHAND | MB_OK);
X	}
X	DeleteDC(mem);
X	ReleaseDC(hwnd, hdc);
X
X	hdc = CreateMetaFile((LPSTR)NULL);
X	SetMapMode(hdc, MM_ANISOTROPIC);
X#ifdef WIN32
X	SetWindowExtEx(hdc, rect.right, rect.bottom, (LPSIZE)NULL);
X#else
X	SetWindowExt(hdc, rect.right, rect.bottom);
X#endif
X	drawgraph(lpgw, hdc, (void *) &rect);
X	hmf = CloseMetaFile(hdc);
X
X	hGMem = GlobalAlloc(GMEM_MOVEABLE, (DWORD)sizeof(METAFILEPICT));
X	lpMFP = (LPMETAFILEPICT) GlobalLock(hGMem);
X	hdc = GetDC(hwnd);	/* get window size */
X	GetClientRect(hwnd, &rect);
X	/* in MM_ANISOTROPIC, xExt & yExt give suggested size in 0.01mm units */
X	lpMFP->mm = MM_ANISOTROPIC;
X	lpMFP->xExt = MulDiv(rect.right-rect.left, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
X	lpMFP->yExt = MulDiv(rect.bottom-rect.top, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
X	lpMFP->hMF = hmf;
X	ReleaseDC(hwnd, hdc);
X	GlobalUnlock(hGMem);
X
X	OpenClipboard(hwnd);
X	EmptyClipboard();
X	SetClipboardData(CF_METAFILEPICT,hGMem);
X	SetClipboardData(CF_BITMAP, bitmap);
X	CloseClipboard();
X	return;
X}
X
X/* copy graph window to printer */
Xvoid
XCopyPrint(LPGW lpgw)
X{
X#if WINVER >= 0x030a
X	HDC printer;
X	DLGPROC lpfnAbortProc;
X	DLGPROC lpfnPrintDlgProc;
X	PRINTDLG pd;
X	HWND hwnd;
X	RECT rect;
X	PRINT pr;
X	UINT widabort;
X
X	hwnd = lpgw->hWndGraph;
X
X	_fmemset(&pd, 0, sizeof(PRINTDLG));
X	pd.lStructSize = sizeof(PRINTDLG);
X	pd.hwndOwner = hwnd;
X	pd.Flags = PD_PRINTSETUP | PD_RETURNDC;
X
X	if (!PrintDlg(&pd))
X		return;
X	printer = pd.hDC;
X	if (NULL == printer)
X		return;	/* abort */
X
X	if (!PrintSize(printer, hwnd, &rect)) {
X		DeleteDC(printer);
X		return; /* abort */
X	}
X
X	pr.hdcPrn = printer;
X	SetWindowLong(hwnd, 4, (LONG)((LPPRINT)&pr));
X	PrintRegister((LPPRINT)&pr);
X
X	EnableWindow(hwnd,FALSE);
X	pr.bUserAbort = FALSE;
X#ifdef __DLL__
X	lpfnPrintDlgProc = (DLGPROC)GetProcAddress(hdllInstance, "PrintDlgProc");
X	lpfnAbortProc = (DLGPROC)GetProcAddress(hdllInstance, "PrintAbortProc");
X#else
X	lpfnPrintDlgProc = (DLGPROC)MakeProcInstance((FARPROC)PrintDlgProc, hdllInstance);
X	lpfnAbortProc = (DLGPROC)MakeProcInstance((FARPROC)PrintAbortProc, hdllInstance);
X#endif
X	pr.hDlgPrint = CreateDialogParam(hdllInstance,"PrintDlgBox",hwnd,lpfnPrintDlgProc,(LPARAM)lpgw->Title);
X	Escape(printer,SETABORTPROC,0,(LPSTR)lpfnAbortProc,NULL);  
X	if (Escape(printer, STARTDOC, lstrlen(lpgw->Title),lpgw->Title, NULL) > 0) {
X		SetMapMode(printer, MM_TEXT);
X		SetBkMode(printer,OPAQUE);
X		DestroyFonts(lpgw);
X		MakeFonts(lpgw, (RECT FAR *)&rect, printer);
X		DestroyPens(lpgw);	/* rebuild pens */
X		MakePens(lpgw, printer);
X		drawgraph(lpgw, printer, (void *) &rect);
X		if (Escape(printer,NEWFRAME,0,NULL,NULL) > 0)
X			Escape(printer,ENDDOC,0,NULL,NULL);
X	}
X	if (!pr.bUserAbort) {
X		EnableWindow(hwnd,TRUE);
X		DestroyWindow(pr.hDlgPrint);
X	}
X#ifndef __DLL__
X	FreeProcInstance((FARPROC)lpfnPrintDlgProc);
X	FreeProcInstance((FARPROC)lpfnAbortProc);
X#endif
X	DeleteDC(printer);
X	SetWindowLong(hwnd, 4, (LONG)(0L));
X	PrintUnregister((LPPRINT)&pr);
X	/* make certain that the screen pen set is restored */
X	SendMessage(lpgw->hWndGraph,WM_COMMAND,M_REBUILDTOOLS,0L);
X#endif
X	return;
X}
X
X/* ================================== */
X/*  INI file stuff */
Xvoid
XWriteGraphIni(LPGW lpgw)
X{
X	RECT rect;
X	int i;
X	char entry[32];
X	LPLOGPEN pc;
X	LPLOGPEN pm;
X	LPSTR file = lpgw->IniFile;
X	LPSTR section = lpgw->IniSection;
X	char profile[80];
X
X	if ((file == (LPSTR)NULL) || (section == (LPSTR)NULL))
X		return;
X	if (IsIconic(lpgw->hWndGraph))
X		ShowWindow(lpgw->hWndGraph, SW_SHOWNORMAL);
X	GetWindowRect(lpgw->hWndGraph,&rect);
X	wsprintf(profile, "%d %d", rect.left, rect.top);
X	WritePrivateProfileString(section, "GraphOrigin", profile, file);
X	wsprintf(profile, "%d %d", rect.right-rect.left, rect.bottom-rect.top);
X	WritePrivateProfileString(section, "GraphSize", profile, file);
X	wsprintf(profile, "%s,%d", lpgw->fontname, lpgw->fontsize);
X	WritePrivateProfileString(section, "GraphFont", profile, file);
X	wsprintf(profile, "%d", lpgw->color);
X	WritePrivateProfileString(section, "GraphColor", profile, file);
X	wsprintf(profile, "%d", lpgw->graphtotop);
X	WritePrivateProfileString(section, "GraphToTop", profile, file);
X	wsprintf(profile, "%d %d %d",GetRValue(lpgw->background),
X			GetGValue(lpgw->background), GetBValue(lpgw->background));
X	WritePrivateProfileString(section, "GraphBackground", profile, file);
X
X	/* now save pens */
X	for (i=0; i<WGNUMPENS+2; i++) {
X		if (i==0)
X			_fstrcpy(entry,"Border");
X		else if (i==1)
X			_fstrcpy(entry,"Axis");
X		else
X			 wsprintf(entry,"Line%d",i-1);
X		pc = &lpgw->colorpen[i];
X		pm = &lpgw->monopen[i];
X		wsprintf(profile, "%d %d %d %d %d",GetRValue(pc->lopnColor),
X			GetGValue(pc->lopnColor), GetBValue(pc->lopnColor),
X			(pc->lopnWidth.x != 1) ? -pc->lopnWidth.x : pc->lopnStyle, 
X			(pm->lopnWidth.x != 1) ? -pm->lopnWidth.x : pm->lopnStyle);
X		WritePrivateProfileString(section, entry, profile, file);
X	}
X	return;
X}
X
Xvoid
XReadGraphIni(LPGW lpgw)
X{
X	LPSTR file = lpgw->IniFile;
X	LPSTR section = lpgw->IniSection;
X	char profile[81];
X	char entry[32];
X	LPSTR p;
X	int i,r,g,b,colorstyle,monostyle;
X	COLORREF ref;
X	BOOL bOKINI;
X
X	bOKINI = (file != (LPSTR)NULL) && (section != (LPSTR)NULL);
X	if (!bOKINI)
X		profile[0] = '\0';
X
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphOrigin", "", profile, 80, file);
X	if ( (p = GetInt(profile, &lpgw->Origin.x)) == NULL)
X		lpgw->Origin.x = CW_USEDEFAULT;
X	if ( (p = GetInt(p, &lpgw->Origin.y)) == NULL)
X		lpgw->Origin.y = CW_USEDEFAULT;
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphSize", "", profile, 80, file);
X	if ( (p = GetInt(profile, &lpgw->Size.x)) == NULL)
X		lpgw->Size.x = CW_USEDEFAULT;
X	if ( (p = GetInt(p, &lpgw->Size.y)) == NULL)
X		lpgw->Size.y = CW_USEDEFAULT;
X
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphFont", "", profile, 80, file);
X	{
X		char FAR *size;
X		size = _fstrchr(profile,',');
X		if (size) {
X			*size++ = '\0';
X			if ( (p = GetInt(size, &lpgw->fontsize)) == NULL)
X				lpgw->fontsize = WINFONTSIZE;
X		}
X		_fstrcpy(lpgw->fontname, profile);
X		if (lpgw->fontsize == 0)
X			lpgw->fontsize = WINFONTSIZE;
X		if (!(*lpgw->fontname))
X			if (LOWORD(GetVersion()) == 3)
X				_fstrcpy(lpgw->fontname,WIN30FONT);
X			else
X				_fstrcpy(lpgw->fontname,WINFONT);
X	}
X
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphColor", "", profile, 80, file);
X		if ( (p = GetInt(profile, &lpgw->color)) == NULL)
X			lpgw->color = TRUE;
X
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphToTop", "", profile, 80, file);
X		if ( (p = GetInt(profile, &lpgw->graphtotop)) == NULL)
X			lpgw->graphtotop = TRUE;
X
X	lpgw->background = RGB(255,255,255);
X	if (bOKINI)
X	  GetPrivateProfileString(section, "GraphBackground", "", profile, 80, file);
X	if ( ((p = GetInt(profile, &r)) != NULL) &&
X	     ((p = GetInt(p, &g)) != NULL) &&
X	     ((p = GetInt(p, &b)) != NULL) )
X			lpgw->background = RGB(r,g,b);
X
X	StorePen(lpgw, 0,RGB(0,0,0),PS_SOLID,PS_SOLID);
X	if (bOKINI)
X	  GetPrivateProfileString(section, "Border", "", profile, 80, file);
X	if ( ((p = GetInt(profile, &r)) != NULL) &&
X	     ((p = GetInt(p, &g)) != NULL) &&
X	     ((p = GetInt(p, &b)) != NULL) &&
X	     ((p = GetInt(p, &colorstyle)) != NULL) &&
X	     ((p = GetInt(p, &monostyle)) != NULL) )
X			StorePen(lpgw,0,RGB(r,g,b),colorstyle,monostyle);
X
X	StorePen(lpgw, 1,RGB(192,192,192),PS_DOT,PS_DOT);
X	if (bOKINI)
X	  GetPrivateProfileString(section, "Axis", "", profile, 80, file);
X	if ( ((p = GetInt(profile, &r)) != NULL) &&
X	     ((p = GetInt(p, &g)) != NULL) &&
X	     ((p = GetInt(p, &b)) != NULL) &&
X	     ((p = GetInt(p, &colorstyle)) != NULL) &&
X	     ((p = GetInt(p, &monostyle)) != NULL) )
X			StorePen(lpgw,1,RGB(r,g,b),colorstyle,monostyle);
X
X	for (i=0; i<WGNUMPENS; i++)
X	{
X		ref = wginitcolor[ i%WGDEFCOLOR ];
X		colorstyle = wginitstyle[ (i/WGDEFCOLOR) % WGDEFSTYLE ];
X		monostyle  = wginitstyle[ i%WGDEFSTYLE ];
X		StorePen(lpgw, i+2,ref,colorstyle,monostyle);
X		wsprintf(entry,"Line%d",i+1);
X		if (bOKINI)
X		  GetPrivateProfileString(section, entry, "", profile, 80, file);
X		if ( ((p = GetInt(profile, &r)) != NULL) &&
X		     ((p = GetInt(p, &g)) != NULL) &&
X		     ((p = GetInt(p, &b)) != NULL) &&
X		     ((p = GetInt(p, &colorstyle)) != NULL) &&
X		     ((p = GetInt(p, &monostyle)) != NULL) )
X				StorePen(lpgw,i+2,RGB(r,g,b),colorstyle,monostyle);
X	}
X}
X
X
X/* ================================== */
X
X#define LS_DEFLINE 2
Xtypedef struct tagLS {
X	int	widtype;
X	int	wid;
X	HWND	hwnd;
X	int	pen;			/* current pen number */
X	LOGPEN	colorpen[WGNUMPENS+2];	/* logical color pens */
X	LOGPEN	monopen[WGNUMPENS+2];	/* logical mono pens */
X} LS;
Xtypedef LS FAR*  LPLS;
X	
X
XCOLORREF
XGetColor(HWND hwnd, COLORREF ref)
X{
XCHOOSECOLOR cc;
XCOLORREF aclrCust[16];
Xint i;
X
X	for (i=0; i<16; i++) {
X		aclrCust[i] = RGB(0,0,0);
X	}
X	_fmemset(&cc, 0, sizeof(CHOOSECOLOR));
X	cc.lStructSize = sizeof(CHOOSECOLOR);
X	cc.hwndOwner = hwnd;
X	cc.lpCustColors = aclrCust;
X	cc.rgbResult = ref;
X	cc.Flags = CC_RGBINIT;
X	if (ChooseColor(&cc))
X		return cc.rgbResult;
X	return ref;
X}
X
X
X/* force update of owner draw button */
Xvoid
XUpdateColorSample(HWND hdlg)
X{
X	RECT rect;
X	POINT ptul, ptlr;
X	GetWindowRect( GetDlgItem(hdlg, LS_COLORSAMPLE), &rect);
X	ptul.x = rect.left;
X	ptul.y = rect.top;
X	ptlr.x = rect.right;
X	ptlr.y = rect.bottom;
X	ScreenToClient(hdlg, &ptul);
X	ScreenToClient(hdlg, &ptlr);
X	rect.left   = ptul.x;
X	rect.top    = ptul.y;
X	rect.right  = ptlr.x;
X	rect.bottom = ptlr.y;
X	InvalidateRect(hdlg, &rect, TRUE);
X	UpdateWindow(hdlg);
X}
X
XBOOL CALLBACK _export
XLineStyleDlgProc(HWND hdlg, UINT wmsg, WPARAM wparam, LPARAM lparam)
X{
X	char buf[16];
X	LPLS lpls;
X	int i;
X	UINT pen;
X	LPLOGPEN plpm, plpc;
X	lpls = (LPLS)GetWindowLong(GetParent(hdlg), 4);
X
X	switch (wmsg) {
X		case WM_INITDIALOG:
X			pen = 2;
X			for (i=0; i<WGNUMPENS+2; i++) {
X				if (i==0)
X					_fstrcpy(buf,"Border");
X				else if (i==1)
X					_fstrcpy(buf,"Axis");
X				else
X			 		wsprintf(buf,"Line%d",i-1);
X				SendDlgItemMessage(hdlg, LS_LINENUM, LB_ADDSTRING, 0, 
X					(LPARAM)((LPSTR)buf));
X			}
X			SendDlgItemMessage(hdlg, LS_LINENUM, LB_SETCURSEL, pen, 0L);
X
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Solid"));
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Dash"));
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Dot"));
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"DashDot"));
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"DashDotDot"));
X
X			plpm = &lpls->monopen[pen];
X			SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_SETCURSEL, 
X				plpm->lopnStyle, 0L);
X			wsprintf(buf,"%d",plpm->lopnWidth.x);
X			SetDlgItemText(hdlg, LS_MONOWIDTH, buf);
X
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Solid"));
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Dash"));
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"Dot"));
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"DashDot"));
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_ADDSTRING, 0, 
X				(LPARAM)((LPSTR)"DashDotDot"));
X
X			plpc = &lpls->colorpen[pen];
X			SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_SETCURSEL, 
X				plpc->lopnStyle, 0L);
X			wsprintf(buf,"%d",plpc->lopnWidth.x);
X			SetDlgItemText(hdlg, LS_COLORWIDTH, buf);
X
X			return TRUE;
X		case WM_COMMAND:
X			pen = (UINT)SendDlgItemMessage(hdlg, LS_LINENUM, LB_GETCURSEL, 0, 0L);
X			plpm = &lpls->monopen[pen];
X			plpc = &lpls->colorpen[pen];
X			switch (LOWORD(wparam)) {
X				case LS_LINENUM:
X					wsprintf(buf,"%d",plpm->lopnWidth.x);
X					SetDlgItemText(hdlg, LS_MONOWIDTH, buf);
X					SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_SETCURSEL, 
X						plpm->lopnStyle, 0L);
X					wsprintf(buf,"%d",plpc->lopnWidth.x);
X					SetDlgItemText(hdlg, LS_COLORWIDTH, buf);
X					SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_SETCURSEL, 
X						plpc->lopnStyle, 0L);
X					UpdateColorSample(hdlg);
X					return FALSE;
X				case LS_MONOSTYLE:
X					plpm->lopnStyle = 
X						(UINT)SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_GETCURSEL, 0, 0L);
X					if (plpm->lopnStyle != 0) {
X						plpm->lopnWidth.x = 1;
X						wsprintf(buf,"%d",plpm->lopnWidth.x);
X						SetDlgItemText(hdlg, LS_MONOWIDTH, buf);
X					}
X					return FALSE;
X				case LS_MONOWIDTH:
X					GetDlgItemText(hdlg, LS_MONOWIDTH, buf, 15);
X					GetInt(buf, &plpm->lopnWidth.x);
X					if (plpm->lopnWidth.x != 1) {
X						plpm->lopnStyle = 0;
X						SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_SETCURSEL, 
X							plpm->lopnStyle, 0L);
X					}
X					return FALSE;
X				case LS_CHOOSECOLOR:
X					plpc->lopnColor = GetColor(hdlg, plpc->lopnColor);
X					UpdateColorSample(hdlg);
X					return FALSE;
X				case LS_COLORSTYLE:
X					plpc->lopnStyle = 
X						(UINT)SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_GETCURSEL, 0, 0L);
X					if (plpc->lopnStyle != 0) {
X						plpc->lopnWidth.x = 1;
X						wsprintf(buf,"%d",plpc->lopnWidth.x);
X						SetDlgItemText(hdlg, LS_COLORWIDTH, buf);
X					}
X					return FALSE;
X				case LS_COLORWIDTH:
X					GetDlgItemText(hdlg, LS_COLORWIDTH, buf, 15);
X					GetInt(buf, &plpc->lopnWidth.x);
X					if (plpc->lopnWidth.x != 1) {
X						plpc->lopnStyle = 0;
X						SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_SETCURSEL, 
X							plpc->lopnStyle, 0L);
X					}
X					return FALSE;
X				case LS_DEFAULT:
X					plpm = lpls->monopen;
X					plpc = lpls->colorpen;
X					/* border */
X					plpc->lopnColor   = RGB(0,0,0);
X					plpc->lopnStyle   = PS_SOLID;
X					plpc->lopnWidth.x = 1;
X					plpm->lopnStyle   = PS_SOLID;
X					plpm->lopnWidth.x = 1;
X					plpc++; plpm++;
X					/* axis */
X					plpc->lopnColor   = RGB(192,192,192);
X					plpc->lopnStyle   = PS_DOT;
X					plpc->lopnWidth.x = 1;
X					plpm->lopnStyle   = PS_DOT;
X					plpm->lopnWidth.x = 1;
X					/* LineX */
X					for (i=0; i<WGNUMPENS; i++) {
X						plpc++; plpm++;
X						plpc->lopnColor   = wginitcolor[ i%WGDEFCOLOR ];
X						plpc->lopnStyle   = wginitstyle[ (i/WGDEFCOLOR) % WGDEFSTYLE ];
X						plpc->lopnWidth.x = 1;
X						plpm->lopnStyle   = wginitstyle[ i%WGDEFSTYLE ];
X						plpm->lopnWidth.x = 1;
X					}
X					/* update window */
X					plpm = &lpls->monopen[pen];
X					plpc = &lpls->colorpen[pen];
X					SendDlgItemMessage(hdlg, LS_LINENUM, LB_SETCURSEL, pen, 0L);
X					wsprintf(buf,"%d",plpm->lopnWidth.x);
X					SetDlgItemText(hdlg, LS_MONOWIDTH, buf);
X					SendDlgItemMessage(hdlg, LS_MONOSTYLE, CB_SETCURSEL, 
X						plpm->lopnStyle, 0L);
X					wsprintf(buf,"%d",plpc->lopnWidth.x);
X					SetDlgItemText(hdlg, LS_COLORWIDTH, buf);
X					SendDlgItemMessage(hdlg, LS_COLORSTYLE, CB_SETCURSEL, 
X						plpc->lopnStyle, 0L);
X					UpdateColorSample(hdlg);
X					return FALSE;
X				case IDOK:
X					EndDialog(hdlg, IDOK);
X					return TRUE;
X				case IDCANCEL:
X					EndDialog(hdlg, IDCANCEL);
X					return TRUE;
X			}
X			break;
X		case WM_DRAWITEM:
X			{
X			HBRUSH hBrush;
X			LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lparam;
X			pen = (UINT)SendDlgItemMessage(hdlg, LS_LINENUM, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
X			plpc = &lpls->colorpen[pen];
X			hBrush = CreateSolidBrush(plpc->lopnColor);
X			FillRect(lpdis->hDC, &lpdis->rcItem, hBrush);
X			FrameRect(lpdis->hDC, &lpdis->rcItem, GetStockBrush(BLACK_BRUSH));
X			DeleteBrush(hBrush);
X			}
X			return FALSE;
X	}
X	return FALSE;
X}
X
X
X
X/* GetWindowLong(hwnd, 4) must be available for use */
XBOOL
XLineStyle(LPGW lpgw)
X{
XDLGPROC lpfnLineStyleDlgProc ;
XBOOL status = FALSE;
XLS ls;
X	
X	SetWindowLong(lpgw->hWndGraph, 4, (LONG)((LPLS)&ls));
X	_fmemcpy(&ls.colorpen, &lpgw->colorpen, (WGNUMPENS + 2) * sizeof(LOGPEN));
X	_fmemcpy(&ls.monopen, &lpgw->monopen, (WGNUMPENS + 2) * sizeof(LOGPEN));
X
X#ifdef __DLL__
X	lpfnLineStyleDlgProc = (DLGPROC)GetProcAddress(hdllInstance, "LineStyleDlgProc");
X#else
X	lpfnLineStyleDlgProc = (DLGPROC)MakeProcInstance((FARPROC)LineStyleDlgProc, hdllInstance);
X#endif
X	if (DialogBox (hdllInstance, "LineStyleDlgBox", lpgw->hWndGraph, lpfnLineStyleDlgProc)
X		== IDOK) {
X		_fmemcpy(&lpgw->colorpen, &ls.colorpen, (WGNUMPENS + 2) * sizeof(LOGPEN));
X		_fmemcpy(&lpgw->monopen, &ls.monopen, (WGNUMPENS + 2) * sizeof(LOGPEN));
X		status = TRUE;
X	}
X#ifndef __DLL__
X	FreeProcInstance((FARPROC)lpfnLineStyleDlgProc);
X#endif
X	SetWindowLong(lpgw->hWndGraph, 4, (LONG)(0L));
X	return status;
X}
X
X/* ================================== */
X
XLRESULT CALLBACK _export
XWndGraphProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
X{
X	HDC hdc;
X	PAINTSTRUCT ps;
X	RECT rect;
X	LPGW lpgw;
X
X	lpgw = (LPGW)GetWindowLong(hwnd, 0);
X
X	switch(message)
X	{
X		case WM_SYSCOMMAND:
X			switch(LOWORD(wParam))
X			{
X				case M_GRAPH_TO_TOP:
X				case M_COLOR:
X				case M_CHOOSE_FONT:
X				case M_COPY_CLIP:
X				case M_LINESTYLE:
X				case M_PRINT:
X				case M_WRITEINI:
X				case M_REBUILDTOOLS:
X					SendMessage(hwnd, WM_COMMAND, wParam, lParam);
X					break;
X				case M_ABOUT:
X					if (lpgw->lptw)
X						AboutBox(hwnd,lpgw->lptw->AboutText);
X					return 0;
X			}
X			break;
X		case WM_COMMAND:
X			switch(LOWORD(wParam))
X			{
X				case M_GRAPH_TO_TOP:
X					lpgw->graphtotop = !lpgw->graphtotop;
X					SendMessage(hwnd,WM_COMMAND,M_REBUILDTOOLS,0L);
X					return(0);
X				case M_COLOR:
X					lpgw->color = !lpgw->color;
X					SendMessage(hwnd,WM_COMMAND,M_REBUILDTOOLS,0L);
X					return(0);
X				case M_CHOOSE_FONT:
X					SelFont(lpgw);
X					return 0;
X				case M_COPY_CLIP:
X					CopyClip(lpgw);
X					return 0;
X				case M_LINESTYLE:
X					if (LineStyle(lpgw))
X						SendMessage(hwnd,WM_COMMAND,M_REBUILDTOOLS,0L);
X					return 0;
X				case M_BACKGROUND:
X					lpgw->background = GetColor(hwnd, lpgw->background);
X					SendMessage(hwnd,WM_COMMAND,M_REBUILDTOOLS,0L);
X					return 0;
X				case M_PRINT:
X					CopyPrint(lpgw);
X					return 0;
X				case M_WRITEINI:
X					WriteGraphIni(lpgw);
X					if (lpgw->lptw)
X						WriteTextIni(lpgw->lptw);
X					return 0;
X				case M_REBUILDTOOLS:
X					lpgw->resized = TRUE;
X					if (lpgw->color) 
X						CheckMenuItem(lpgw->hPopMenu, M_COLOR, MF_BYCOMMAND | MF_CHECKED);
X					else
X						CheckMenuItem(lpgw->hPopMenu, M_COLOR, MF_BYCOMMAND | MF_UNCHECKED);
X					if (lpgw->graphtotop) 
X						CheckMenuItem(lpgw->hPopMenu, M_GRAPH_TO_TOP, MF_BYCOMMAND | MF_CHECKED);
X					else
X						CheckMenuItem(lpgw->hPopMenu, M_GRAPH_TO_TOP, MF_BYCOMMAND | MF_UNCHECKED);
X					DestroyPens(lpgw);
X					DestroyFonts(lpgw);
X					hdc = GetDC(hwnd);
X					MakePens(lpgw, hdc);
X					GetClientRect(hwnd, &rect);
X					MakeFonts(lpgw, (LPRECT)&rect, hdc);
X					ReleaseDC(hwnd, hdc);
X					GetClientRect(hwnd, &rect);
X					InvalidateRect(hwnd, (LPRECT) &rect, 1);
X					UpdateWindow(hwnd);
X					return 0;
X			}
X			return 0;
X		case WM_RBUTTONDOWN:
X			{
X			POINT pt;
X			pt.x = LOWORD(lParam);
X			pt.y = HIWORD(lParam);
X			ClientToScreen(hwnd,&pt);
X			TrackPopupMenu(lpgw->hPopMenu, TPM_LEFTALIGN, 
X				pt.x, pt.y, 0, hwnd, NULL);
X			}
X			return(0);
X		case WM_CREATE:
X			lpgw = ((CREATESTRUCT FAR *)lParam)->lpCreateParams;
X			SetWindowLong(hwnd, 0, (LONG)lpgw);
X			lpgw->hWndGraph = hwnd;
X			hdc = GetDC(hwnd);
X			MakePens(lpgw, hdc);
X			GetClientRect(hwnd, &rect);
X			MakeFonts(lpgw, (LPRECT)&rect, hdc);
X			ReleaseDC(hwnd, hdc);
X#if WINVER >= 0x030a
X			{
X			WORD version = LOWORD(GetVersion());
X			if ((LOBYTE(version)*100 + HIBYTE(version)) >= 310)
X				if ( lpgw->lptw && (lpgw->lptw->DragPre!=(LPSTR)NULL) && (lpgw->lptw->DragPost!=(LPSTR)NULL) )
X					DragAcceptFiles(hwnd, TRUE);
X			}
X#endif
X			return(0);
X		case WM_PAINT:
X			hdc = BeginPaint(hwnd, &ps);
X			SetMapMode(hdc, MM_TEXT);
X			SetBkMode(hdc,OPAQUE);
X			GetClientRect(hwnd, &rect);
X			SetViewportExt(hdc, rect.right, rect.bottom);
X			drawgraph(lpgw, hdc, (void *) &rect);
X			EndPaint(hwnd, &ps);
X			return 0;
X		case WM_SIZE:
X			/* update font sizes if graph resized */
X			if ((wParam == SIZE_MAXIMIZED) || (wParam == SIZE_RESTORED)) {
X				RECT rect;
X				SendMessage(hwnd,WM_SYSCOMMAND,M_REBUILDTOOLS,0L);
X				GetWindowRect(hwnd,&rect);
X				lpgw->Size.x = rect.right-rect.left;
X				lpgw->Size.y = rect.bottom-rect.top;
X			}
X			break;
X#if WINVER >= 0x030a
X		case WM_DROPFILES:
X			{
X			WORD version = LOWORD(GetVersion());
X			if ((LOBYTE(version)*100 + HIBYTE(version)) >= 310)
X				if (lpgw->lptw)
X					DragFunc(lpgw->lptw, (HDROP)wParam);
X			}
X			break;
X#endif
X		case WM_DESTROY:
X			DestroyPens(lpgw);
X			DestroyFonts(lpgw);
X#if __TURBOC__ >= 0x410    /* Borland C++ 3.1 or later */
X			{
X			WORD version = LOWORD(GetVersion());
X			if ((LOBYTE(version)*100 + HIBYTE(version)) >= 310)
X				DragAcceptFiles(hwnd, FALSE);
X			}
X#endif
X			return 0;
X		case WM_CLOSE:
X			GraphClose(lpgw);
X			return 0;
X		}
X	return DefWindowProc(hwnd, message, wParam, lParam);
X}
X
END_OF_FILE
  if test 40601 -ne `wc -c <'gnuplot/win/wgraph.c'`; then
    echo shar: \"'gnuplot/win/wgraph.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/win/wgraph.c'
fi
echo shar: End of archive 14 \(of 33\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
