Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i038:  gnuplot - interactive function plotting utility, Part26/33
Message-ID: <1993Oct25.025925.2074@sparky.sterling.com>
X-Md4-Signature: 7441b8a628a8d3886f351b64b8c4f058
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 25 Oct 1993 02:59:25 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 38
Archive-name: gnuplot/part26
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/demo/hemisphr.dat gnuplot/demo/polar.dat
#   gnuplot/docs/gnuplot.1 gnuplot/os2/gnupmdrv.c gnuplot/term/README
#   gnuplot/term/ai.trm gnuplot/term/hp2648.trm gnuplot/term/pbm.trm
#   gnuplot/term/pm.trm gnuplot/term/tek.trm gnuplot/term/texdraw.trm
# Wrapped by kent@sparky on Wed Oct 20 17:14:59 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 26 (of 33)."'
if test -f 'gnuplot/demo/hemisphr.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/hemisphr.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/hemisphr.dat'\" \(6975 characters\)
  sed "s/^X//" >'gnuplot/demo/hemisphr.dat' <<'END_OF_FILE'
X0.687151 -0.636061 0.351070
X0.641845 -0.232436 0.730759
X0.273514 -0.848211 0.453572
X-0.550699 0.813122 0.188582
X-0.347821 0.841382 0.413639
X-0.829282 -0.509933 0.228604
X0.399696 0.466770 0.788903
X0.736650 0.020192 0.675973
X-0.274921 -0.182391 0.944008
X0.222153 -0.841996 0.491621
X-0.461820 -0.755197 0.465189
X0.294122 0.670369 0.681247
X0.261892 0.211723 0.941587
X-0.554902 0.477345 0.681341
X-0.316651 -0.647984 0.692711
X0.940858 -0.324848 0.096228
X0.455903 -0.594463 0.662394
X0.144714 -0.941617 0.304000
X-0.417407 0.068704 0.906119
X0.227478 -0.641231 0.732855
X-0.636961 -0.237343 0.733450
X0.302450 -0.701212 0.645620
X0.355187 0.625974 0.694261
X0.126868 0.938774 0.320325
X-0.198825 -0.825277 0.528571
X-0.605855 0.466076 0.644758
X-0.979983 0.196939 0.029143
X0.730081 -0.677485 0.089423
X-0.733658 -0.065519 0.676353
X0.593833 -0.583880 0.553576
X0.630038 -0.757773 0.169798
X0.214063 0.953829 0.210682
X-0.210639 0.045720 0.976494
X0.502269 -0.672584 0.543467
X-0.713914 -0.019685 0.699956
X-0.102652 0.225742 0.968764
X-0.575935 0.679368 0.454707
X-0.552680 0.325656 0.767133
X-0.105718 0.489948 0.865318
X-0.642008 0.237217 0.729077
X0.912208 -0.302322 0.276546
X0.685076 0.723350 0.086233
X-0.730777 -0.226034 0.644107
X-0.733895 -0.430285 0.525597
X0.643521 -0.710952 0.283598
X0.206564 0.497907 0.842271
X-0.388945 -0.813833 0.431738
X0.514538 -0.817664 0.258216
X0.658314 0.496308 0.565952
X0.588167 0.708096 0.390716
X0.552130 0.427566 0.715779
X-0.705121 0.320760 0.632390
X-0.689813 0.688923 0.222582
X0.553844 0.711779 0.432004
X-0.046413 0.212599 0.976037
X0.399406 -0.766162 0.503458
X-0.233463 -0.160645 0.959004
X0.529336 -0.621840 0.577163
X0.606825 0.629365 0.485451
X0.501835 0.612707 0.610534
X-0.683857 0.450334 0.574055
X-0.882283 0.443548 0.157614
X0.586683 0.464120 0.663623
X-0.595482 0.233864 0.768576
X0.237607 -0.846347 0.476696
X-0.409129 0.625441 0.664407
X0.664685 -0.741902 0.088182
X-0.588147 -0.803628 0.090915
X-0.682428 -0.728175 0.063668
X0.540892 0.542901 0.642413
X0.117736 -0.786009 0.606900
X0.846712 -0.474373 0.240934
X-0.739743 -0.661408 0.123773
X-0.674807 -0.295222 0.676373
X0.612938 0.564586 0.552766
X-0.200352 -0.584274 0.786437
X-0.583626 -0.608199 0.538028
X-0.842820 -0.537921 0.017206
X-0.914848 -0.365948 0.170690
X-0.722029 -0.691806 0.008805
X-0.749203 0.647075 0.141379
X0.542856 0.713704 0.442644
X0.708415 0.597082 0.376353
X-0.514737 -0.622752 0.589258
X0.517661 -0.651774 0.554273
X0.964970 -0.229158 0.127752
X-0.896947 -0.320221 0.304868
X-0.806679 0.191888 0.558970
X-0.449889 0.492534 0.744990
X-0.121829 0.701839 0.701840
X-0.136385 -0.726159 0.673864
X0.141310 0.776791 0.613700
X0.730240 0.567015 0.381108
X-0.096403 0.876852 0.470997
X-0.407930 0.721095 0.560014
X-0.617285 0.119734 0.777575
X-0.516675 0.784493 0.342954
X-0.409966 -0.414935 0.812254
X0.172975 0.141665 0.974685
X-0.421979 0.745663 0.515674
X-0.657963 -0.199035 0.726271
X0.579425 0.685534 0.440805
X-0.214461 0.856536 0.469418
X0.809815 -0.403364 0.426025
X-0.706903 0.588917 0.391745
X0.585611 0.463666 0.664886
X0.438727 0.698150 0.565779
X-0.464391 -0.446944 0.764580
X-0.657744 0.534413 0.530825
X0.537112 -0.749640 0.386718
X0.007187 -0.597134 0.802109
X-0.356817 -0.675864 0.644895
X0.682514 -0.090759 0.725216
X-0.759950 -0.640982 0.107787
X0.314462 0.320252 0.893618
X0.794300 -0.091894 0.600535
X0.231465 -0.737745 0.634159
X-0.493894 -0.137710 0.858548
X-0.636201 0.372391 0.675703
X0.851855 -0.078785 0.517819
X-0.252937 0.823486 0.507832
X-0.501036 -0.558527 0.661068
X-0.667380 -0.740968 0.074628
X0.826057 -0.356650 0.436383
X0.676558 0.736342 0.008355
X0.356317 0.717007 0.599115
X-0.702754 -0.252940 0.664950
X0.241305 0.873806 0.422179
X-0.444469 0.694911 0.565284
X0.285538 0.893811 0.345789
X-0.816376 -0.543964 0.193993
X0.411338 -0.215215 0.885711
X-0.685665 0.175779 0.706375
X-0.370169 -0.144937 0.917588
X0.415254 -0.282774 0.864640
X0.342285 -0.791855 0.505773
X-0.442990 -0.543366 0.713101
X0.737523 0.300789 0.604637
X-0.648119 0.560986 0.515012
X0.832393 -0.080222 0.548349
X-0.745494 -0.022420 0.666135
X-0.343740 -0.929656 0.132602
X0.632050 -0.340980 0.695878
X-0.670904 0.696398 0.254790
X-0.691893 -0.369253 0.620433
X-0.644716 -0.667477 0.372578
X0.511738 -0.534049 0.672990
X0.542618 -0.778095 0.316437
X-0.369727 -0.900054 0.230662
X-0.681421 -0.572227 0.456313
X0.200343 -0.968269 0.149389
X-0.897349 0.345346 0.274776
X-0.524090 -0.266174 0.809000
X-0.863974 0.483194 0.141680
X-0.549403 -0.740878 0.386336
X0.206515 -0.791156 0.575694
X-0.617364 0.470918 0.630157
X0.964888 0.246811 0.089862
X0.681090 0.695442 0.229080
X-0.635200 -0.708299 0.307949
X0.388299 0.158032 0.907882
X0.573002 0.727986 0.376438
X0.601183 -0.586111 0.543188
X-0.235470 -0.811948 0.534130
X0.155904 -0.681863 0.714672
X-0.672889 0.588006 0.448852
X0.306393 0.874114 0.376892
X0.032428 0.271616 0.961859
X0.107372 0.155924 0.981916
X0.592487 0.224923 0.773543
X-0.585302 -0.568462 0.578163
X0.663301 0.728159 0.172675
X-0.513634 0.781053 0.355157
X0.810010 -0.386643 0.440898
X-0.139469 0.655629 0.742091
X0.621210 0.615790 0.484666
X-0.051261 0.216594 0.974915
X0.658176 -0.726097 0.198966
X0.603351 0.247584 0.758070
X0.686614 -0.089142 0.721537
X0.226818 0.552577 0.802005
X-0.741481 0.327178 0.585799
X-0.366696 0.771805 0.519472
X0.238979 0.647361 0.723749
X-0.672754 -0.332136 0.661126
X0.696711 -0.471073 0.541004
X0.160743 0.905419 0.392909
X-0.912978 0.232968 0.334959
X-0.285567 -0.185395 0.940255
X-0.619693 -0.706342 0.342142
X0.382874 0.892396 0.238822
X-0.381917 0.512306 0.769209
X-0.652722 -0.575238 0.493006
X0.240731 0.522574 0.817902
X-0.047170 0.578270 0.814481
X-0.769256 0.592413 0.239359
X0.517803 -0.372629 0.770083
X0.879867 -0.153159 0.449862
X-0.408953 0.473917 0.779846
X-0.611694 0.790628 0.027172
X0.082968 0.088643 0.992602
X0.329262 0.745222 0.579854
X-0.093733 0.752980 0.651334
X-0.876795 -0.216424 0.429408
X0.659021 0.742999 0.116803
X0.471778 -0.608160 0.638410
X-0.771241 0.625579 0.117638
X0.666548 0.601906 0.439799
X-0.177481 -0.887762 0.424711
X-0.544219 -0.682418 0.487987
X-0.232865 0.617965 0.750929
X-0.761795 -0.037050 0.646758
X0.261925 0.847441 0.461778
X-0.447484 -0.545276 0.708824
X-0.005218 -0.773747 0.633474
X0.216045 0.575576 0.788693
X-0.018365 0.656245 0.754325
X0.305420 0.594325 0.743973
X-0.508168 -0.512279 0.692341
X0.478855 0.493185 0.726269
X0.451841 0.584772 0.673707
X0.253152 -0.875528 0.411540
X-0.653601 0.507497 0.561474
X0.486897 0.719655 0.495003
X0.497595 -0.353890 0.791935
X-0.044254 -0.938949 0.341197
X-0.781823 -0.038665 0.622300
X-0.486930 -0.527387 0.696249
X0.869944 -0.440150 0.222408
X0.279697 0.693758 0.663679
X0.593555 0.421221 0.685759
X0.519810 -0.396648 0.756616
X-0.862087 0.275232 0.425503
X0.237904 -0.755351 0.610612
X-0.614121 -0.664634 0.425579
X0.328900 0.035730 0.943689
X0.769607 0.633896 0.076682
X-0.575359 -0.794269 0.195191
X-0.608405 0.637947 0.472087
X-0.658203 0.089686 0.747479
X-0.913833 -0.389451 0.115050
X0.272020 -0.871201 0.408673
X-0.519856 -0.851058 0.073831
X0.411266 0.672267 0.615563
X0.686633 0.578928 0.439747
X-0.097612 -0.192980 0.976335
X-0.710703 -0.205920 0.672680
X-0.622197 0.068071 0.779896
X-0.296696 0.405710 0.864506
END_OF_FILE
  if test 6975 -ne `wc -c <'gnuplot/demo/hemisphr.dat'`; then
    echo shar: \"'gnuplot/demo/hemisphr.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/hemisphr.dat'
fi
if test -f 'gnuplot/demo/polar.dat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/polar.dat'\"
else
  echo shar: Extracting \"'gnuplot/demo/polar.dat'\" \(6598 characters\)
  sed "s/^X//" >'gnuplot/demo/polar.dat' <<'END_OF_FILE'
X#
X# $Id: polar.dat 3.38.2.6 1992/11/14 02:25:21 woo Exp $
X#
X# Input data ncmain.d4 generated by genpat2.f:Tx antenna pattern
X# x,y,z of center point B in coord 3
X#     -5.12000     0.00000    -1.50000  
X# euler matrix
X#      0.00000    -1.00000     0.00000  
X#      0.70710     0.00000     0.70710  
X#     -0.70710     0.00000     0.70710  
X#  theta(deg)    phi(deg)  E-theta(dB)  phase     E-phi(dB)    phase
X      0.000      0.000   -200.000      0.000     18.992      0.000 
X      2.000      0.000   -200.000      0.000     18.898      0.000 
X      4.000      0.000   -200.000      0.000     18.619      0.000 
X      6.000      0.000   -200.000      0.000     18.152      0.000 
X      8.000      0.000   -200.000      0.000     17.497      0.000 
X     10.000      0.000   -200.000      0.000     16.651      0.000 
X     12.000      0.000   -200.000      0.000     15.614      0.000 
X     14.000      0.000   -200.000      0.000     14.382      0.000 
X     16.000      0.000   -200.000      0.000     12.952      0.000 
X     18.000      0.000   -200.000      0.000     11.320      0.000 
X     20.000      0.000   -200.000      0.000      9.483      0.000 
X     22.000      0.000   -200.000      0.000      7.434      0.000 
X     24.000      0.000   -200.000      0.000      5.169      0.000 
X     26.000      0.000   -200.000      0.000      2.680      0.000 
X     28.000      0.000   -200.000      0.000     -0.039      0.000 
X     30.000      0.000   -200.000      0.000     -2.998      0.000 
X     32.000      0.000   -200.000      0.000     -6.204      0.000 
X     34.000      0.000   -200.000      0.000     -9.670      0.000 
X     36.000      0.000   -200.000      0.000    -13.407      0.000 
X     38.000      0.000   -200.000      0.000    -17.429      0.000 
X     40.000      0.000   -200.000      0.000    -21.751      0.000 
X     42.000      0.000   -200.000      0.000    -26.391      0.000 
X     44.000      0.000   -200.000      0.000    -31.368      0.000 
X     46.000      0.000   -200.000      0.000    -36.705      0.000 
X     48.000      0.000   -200.000      0.000    -42.429      0.000 
X     50.000      0.000   -200.000      0.000    -48.569      0.000 
X     52.000      0.000   -200.000      0.000    -55.160      0.000 
X     54.000      0.000   -200.000      0.000    -62.243      0.000 
X     56.000      0.000   -200.000      0.000    -69.867      0.000 
X     58.000      0.000   -200.000      0.000    -78.087      0.000 
X     60.000      0.000   -200.000      0.000    -86.971      0.000 
X     62.000      0.000   -200.000      0.000    -96.602      0.000 
X     64.000      0.000   -200.000      0.000   -107.080      0.000 
X     66.000      0.000   -200.000      0.000   -118.530      0.000 
X     68.000      0.000   -200.000      0.000   -131.110      0.000 
X     70.000      0.000   -200.000      0.000   -145.022      0.000 
X     72.000      0.000   -200.000      0.000   -160.534      0.000 
X     74.000      0.000   -200.000      0.000   -177.982      0.000 
X     76.000      0.000   -200.000      0.000   -195.848      0.000 
X     78.000      0.000   -200.000      0.000   -199.967      0.000 
X     80.000      0.000   -200.000      0.000   -200.000      0.000 
X     82.000      0.000   -200.000      0.000   -200.000      0.000 
X     84.000      0.000   -200.000      0.000   -200.000      0.000 
X     86.000      0.000   -200.000      0.000   -200.000      0.000 
X     88.000      0.000   -200.000      0.000   -200.000      0.000 
X     90.000      0.000   -200.000      0.000   -200.000      0.000 
X     92.000      0.000   -200.000      0.000   -200.000      0.000 
X     94.000      0.000   -200.000      0.000   -200.000      0.000 
X     96.000      0.000   -200.000      0.000   -200.000      0.000 
X     98.000      0.000   -200.000      0.000   -200.000      0.000 
X    100.000      0.000   -200.000      0.000   -200.000      0.000 
X    102.000      0.000   -200.000      0.000   -200.000      0.000 
X    104.000      0.000   -200.000      0.000   -200.000      0.000 
X    106.000      0.000   -200.000      0.000   -200.000      0.000 
X    108.000      0.000   -200.000      0.000   -200.000      0.000 
X    110.000      0.000   -200.000      0.000   -200.000      0.000 
X    112.000      0.000   -200.000      0.000   -200.000      0.000 
X    114.000      0.000   -200.000      0.000   -200.000      0.000 
X    116.000      0.000   -200.000      0.000   -200.000      0.000 
X    118.000      0.000   -200.000      0.000   -200.000      0.000 
X    120.000      0.000   -200.000      0.000   -200.000      0.000 
X    122.000      0.000   -200.000      0.000   -200.000      0.000 
X    124.000      0.000   -200.000      0.000   -200.000      0.000 
X    126.000      0.000   -200.000      0.000   -200.000      0.000 
X    128.000      0.000   -200.000      0.000   -200.000      0.000 
X    130.000      0.000   -200.000      0.000   -200.000      0.000 
X    132.000      0.000   -200.000      0.000   -200.000      0.000 
X    134.000      0.000   -200.000      0.000   -200.000      0.000 
X    136.000      0.000   -200.000      0.000   -200.000      0.000 
X    138.000      0.000   -200.000      0.000   -200.000      0.000 
X    140.000      0.000   -200.000      0.000   -200.000      0.000 
X    142.000      0.000   -200.000      0.000   -200.000      0.000 
X    144.000      0.000   -200.000      0.000   -200.000      0.000 
X    146.000      0.000   -200.000      0.000   -200.000      0.000 
X    148.000      0.000   -200.000      0.000   -200.000      0.000 
X    150.000      0.000   -200.000      0.000   -200.000      0.000 
X    152.000      0.000   -200.000      0.000   -200.000      0.000 
X    154.000      0.000   -200.000      0.000   -200.000      0.000 
X    156.000      0.000   -200.000      0.000   -200.000      0.000 
X    158.000      0.000   -200.000      0.000   -200.000      0.000 
X    160.000      0.000   -200.000      0.000   -200.000      0.000 
X    162.000      0.000   -200.000      0.000   -200.000      0.000 
X    164.000      0.000   -200.000      0.000   -200.000      0.000 
X    166.000      0.000   -200.000      0.000   -200.000      0.000 
X    168.000      0.000   -200.000      0.000   -200.000      0.000 
X    170.000      0.000   -200.000      0.000   -200.000      0.000 
X    172.000      0.000   -200.000      0.000   -200.000      0.000 
X    174.000      0.000   -200.000      0.000   -200.000      0.000 
X    176.000      0.000   -200.000      0.000   -200.000      0.000 
X    178.000      0.000   -200.000      0.000   -200.000      0.000 
X    180.000      0.000   -200.000      0.000   -200.000      0.000 
END_OF_FILE
  if test 6598 -ne `wc -c <'gnuplot/demo/polar.dat'`; then
    echo shar: \"'gnuplot/demo/polar.dat'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/polar.dat'
fi
if test -f 'gnuplot/docs/gnuplot.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/gnuplot.1'\"
else
  echo shar: Extracting \"'gnuplot/docs/gnuplot.1'\" \(7472 characters\)
  sed "s/^X//" >'gnuplot/docs/gnuplot.1' <<'END_OF_FILE'
X.\" dummy line
X.TH GNUPLOT 1 "31 August 1990"
X.UC 4
X.SH NAME
Xgnuplot \- an interactive plotting program
X.SH SYNOPSIS
X.B gnuplot
X[ X11 options ] [file ...]
X.br
X.SH DESCRIPTION
X.I Gnuplot
Xis a command-driven interactive function plotting program.
X.PP
XIf files are given,
X.I gnuplot
Xloads each file with the
X.I load
Xcommand, in the order specified.
X.I Gnuplot
Xexits after the last file is processed.
X.PP
XHere are some of its features:
X.PP
XPlots any number of functions, built up of C operators, C library
Xfunctions, and some things C doesn't have like **, sgn(), etc.  Also
Xsupport for plotting data files, to compare actual
Xdata to theoretical curves.
X.PP
XUser-defined X and Y ranges (optional auto-ranging), smart axes scaling,
Xsmart tic marks.
X.PP
XLabelling of X and Y axes.
X.PP
XUser-defined constants and functions.
X.PP
XSupport through a generalized graphics driver for
XAED 512,
XAED 767,
XBBN BitGraph,
XCommodore Amiga,
XRoland DXY800A,
XEEPIC,
XTeXDraw,
XEmTeX,
XEpson 60dpi printers,
XEpson LX-800,
XFig,
XHP2623,
XHP2648,
XHP75xx,
XHPGL,
XHP LaserJet II,
XImagen,
XIris 4D,
XMS-DOS Kermit,
XKyocera laser printer,
XLaTeX,
XNEC CP6 pinwriter,
XPostScript,
XQMS QUIC,
XReGis (VT125 and VT2xx),
XSCO Xenix CGI,
XSelanar,
XStar color printer,
XTandy DMP-130 printer,
XTek 401x,
XTek 410x,
XVectrix 384,
XVT like Tektronix emulator,
XUnix PC (ATT 3b1 or ATT 7300),
Xunixplot,
Xand X11.
XThe PC version compiled by Microsoft C
Xsupports IBM CGA, EGA, VGA, Hercules, ATT 6300,
Xand Corona 325 graphics.
XThe PC version compiled by Borland C++
Xsupports IBM CGA, EGA, MCGA, VGA, Hercules and ATT 6300 graphics.
XOther devices can be added simply, but will require recompiling.
X.PP
XShell escapes and command line substitution.
X.PP
XLoad and save capability.
X.PP
XOutput redirection.
X.PP
XAll computations performed in the complex domain.  Just the real part is
Xplotted by default, but functions like imag() and abs() and arg() are
Xavailable to override this.
X.SH X11 OPTIONS
X.I Gnuplot
Xprovides the \fIx11\fP terminal type for use
Xwith X servers. This terminal type is set automatically at startup if
Xthe \fBDISPLAY\fR environment variable is set, if the \fBTERM\fR environment
Xvariable is set to \fBxterm\fR, or if the \fB\-display\fR command line
Xoption is used.
XFor terminal type \fIx11\fR, \fIgnuplot\fP
Xaccepts the standard X Toolkit options and resources such as geometry, font,
Xand background. See the X(1) man page for a description of
Xthe options.
XIn addition to the X Toolkit options:
X.PP
X\fB\-mono\fP forces monochrome rendering on color displays.
X.PP
X\fB\-gray\fP requests grayscale rendering on grayscale or color displays.
X(Grayscale displays receive monochrome rendering by default.)
X.PP
X\fB\-clear\fP requests that the window be cleared momentarily before a
Xnew plot is displayed.
X.PP
X\fB\-tvtwm\fP requests that geometry specifications
Xfor position of the window be made relative to the currently displayed
Xportion of the virtual root.
X.PP
XThese options may also be controlled with resources in your \fB.Xdefaults\fR
Xfile.
XFor example: \fBgnuplot*gray: on\fP .
X.PP
X\fIGnuplot\fP provides a command line option (\fB\-pointsize \fIv\fR) and
Xa resource (\fBgnuplot*pointsize: \fIv\fR) to control the size of points
Xplotted with the "points" plotting style. The value \fIv\fR is a real
Xnumber (greater than 0 and less than or equal to ten) used as a
Xscaling factor for point sizes. For example, \fB\-pointsize 2\fR uses
Xpoints twice the default size, and \fB\-pointsize 0.5\fR uses points
Xhalf the normal size.
X.PP
XFor monochrome displays, \fIgnuplot\fR does not honor foreground or
Xbackground colors. The default is black-on-white. \fB\-rv\fP or
X\fBgnuplot*reverseVideo: on\fP requests white-on-black.
X.PP
XFor color displays \fIgnuplot\fP honors
Xthe following resources (shown here with default values). The values
Xmay be color names in the X11 rgb.txt file on your system, hexadecimal
XRGB color specifications (see X11 documentation), or a color name
Xfollowed by a comma and an \fIintensity\fR value from 0 to 1. For example,
X\fBblue,.5\fR means a half intensity blue.
X.sp
X.B  "gnuplot*background: white"
X.br
X.B  "gnuplot*textColor: black"
X.br
X.B  "gnuplot*borderColor: black"
X.br
X.B  "gnuplot*axisColor: black"
X.br
X.B  "gnuplot*line1Color: red"
X.br
X.B  "gnuplot*line2Color: green"
X.br
X.B  "gnuplot*line3Color: blue"
X.br
X.B  "gnuplot*line4Color: magenta"
X.br
X.B  "gnuplot*line5Color: cyan"
X.br
X.B  "gnuplot*line6Color: sienna"
X.br
X.B  "gnuplot*line7Color: orange"
X.br
X.B  "gnuplot*line8Color: coral"
X.br
X
XWhen \fB\-gray\fP is selected, \fIgnuplot\fP honors
Xthe following resources for grayscale or color displays (shown here with
Xdefault values). Note that the default background is black.
X.sp
X.B  "gnuplot*background: black"
X.br
X.B  "gnuplot*textGray: white"
X.br
X.B  "gnuplot*borderGray: gray50"
X.br
X.B  "gnuplot*axisGray: gray50"
X.br
X.B  "gnuplot*line1Gray: gray100"
X.br
X.B  "gnuplot*line2Gray: gray60"
X.br
X.B  "gnuplot*line3Gray: gray80"
X.br
X.B  "gnuplot*line4Gray: gray40"
X.br
X.B  "gnuplot*line5Gray: gray90"
X.br
X.B  "gnuplot*line6Gray: gray50"
X.br
X.B  "gnuplot*line7Gray: gray70"
X.br
X.B  "gnuplot*line8Gray: gray30"
X.br
X
X\fIGnuplot\fP honors the following resources for setting the width in
Xpixels of plot lines (shown here with default values.) 0 or 1 means
Xa minimal width line of 1 pixel width. A value of 2 or 3 may
Ximprove the  appearance of some plots.
X.sp
X.br
X.B  "gnuplot*borderWidth: 2"
X.br
X.B  "gnuplot*axisWidth: 0"
X.br
X.B  "gnuplot*line1Width: 0"
X.br
X.B  "gnuplot*line2Width: 0"
X.br
X.B  "gnuplot*line3Width: 0"
X.br
X.B  "gnuplot*line4Width: 0"
X.br
X.B  "gnuplot*line5Width: 0"
X.br
X.B  "gnuplot*line6Width: 0"
X.br
X.B  "gnuplot*line7Width: 0"
X.br
X.B  "gnuplot*line8Width: 0"
X.br
X
X\fIGnuplot\fP honors the following resources for setting the dash style
Xused for plotting lines.  0 means a solid line. A 2 digit number \fIjk\fR
X(\fIj\fP and \fIk\fP are >= 1  and <= 9) means a dashed line with a
Xrepeated pattern of \fIj\fR pixels on followed by \fIk\fR pixels off.
XFor example, '16' is a "dotted" line with 1 pixel on followed by 6 pixels
Xoff.  More elaborate on/off patterns can be specified with a 4 digit value.
XFor example, '4441' is 4 on, 4 off, 4 on, 1 off. The default values shown
Xbelow are for monochrome displays or monochrome rendering on color or
Xgrayscale displays. For color displays, the defaults for all are 0
X(solid line) except for \fBaxisDashes\fR which defaults to a '16' dotted
Xline.
X.sp
X.br
X.B  "gnuplot*borderDashes: 0"
X.br
X.B  "gnuplot*axisDashes: 16"
X.br
X.B  "gnuplot*line1Dashes: 0"
X.br
X.B  "gnuplot*line2Dashes: 42"
X.br
X.B  "gnuplot*line3Dashes: 13"
X.br
X.B  "gnuplot*line4Dashes: 44"
X.br
X.B  "gnuplot*line5Dashes: 15"
X.br
X.B  "gnuplot*line6Dashes: 4441"
X.br
X.B  "gnuplot*line7Dashes: 42"
X.br
X.B  "gnuplot*line8Dashes: 13"
X.br
X.PP
XThe size or aspect ratio of a plot may be changed by resizing the
X.I gnuplot
Xwindow.
X.SH AUTHORS
XThomas Williams, Pixar Corporation,
X.br
X(info-gnuplot@dartmouth.edu)
X.br
Xand Colin Kelley.
X.PP
XAdditions for labelling by Russell Lang, Monash University, Australia.
X.br
X(rjl@monu1.cc.monash.edu.au)
X.br
XFurther additions by David Kotz, Dartmouth College, New Hampshire, USA
X(formerly of Duke University, North Carolina, USA).
X.br
X(David.Kotz@Dartmouth.edu)
X.SH BUGS
XThe atan() function does not work correctly for complex arguments.
X.br
XThe bessel functions do not work for complex arguments.
X.br
XSee the
X.I help bugs
Xcommand in gnuplot.
X.SH SEE ALSO
XSee the printed manual or the on-line help for details on specific commands.
X.br
XX(1).
END_OF_FILE
  if test 7472 -ne `wc -c <'gnuplot/docs/gnuplot.1'`; then
    echo shar: \"'gnuplot/docs/gnuplot.1'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/gnuplot.1'
fi
if test -f 'gnuplot/os2/gnupmdrv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/os2/gnupmdrv.c'\"
else
  echo shar: Extracting \"'gnuplot/os2/gnupmdrv.c'\" \(6295 characters\)
  sed "s/^X//" >'gnuplot/os2/gnupmdrv.c' <<'END_OF_FILE'
X#ifdef INCRCSDATA
Xstatic char RCSid[]="$Id: gnupmdrv.c%v 3.50 1993/07/09 05:35:24 woo Exp $" ;
X#endif
X
X/****************************************************************************
X
X    PROGRAM: gnupmdrv
X    
X    Outboard PM driver for GNUPLOT 3.3
X
X    MODULE:  gnupmdrv.c
X        
X    This file contains the startup procedures for gnupmdrv
X       
X****************************************************************************/
X
X/*
X * PM driver for GNUPLOT
X * Copyright (C) 1992   Roger Fearick
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHOR
X * 
X *   Gnuplot driver for OS/2:  Roger Fearick
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X**/
X
X#define INCL_PM
X#define INCL_WIN
X#define INCL_SPL
X#define INCL_SPLDOSPRINT
X#define INCL_DOSMEMMGR
X#define INCL_DOSPROCESS
X#define INCL_DOSFILEMGR
X#include <os2.h>
X#include <string.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include "gnupmdrv.h"
X
X/*==== g l o b a l    d a t a ================================================*/
X
Xchar szIPCName[256] ;
X#define IPCDEFAULT "gnuplot"
X
X/*==== l o c a l    d a t a ==================================================*/
X
X            /* class names for window registration */
X
Xstatic char szChildName []     = "Gnuchild" ;
X
X/*==== f u n c t i o n s =====================================================*/
X
XBOOL             QueryIni( HAB ) ;
Xint              main( int, char** ) ;
Xstatic HWND      InitHelp( HAB, HWND ) ;
X
X/*==== c o d e ===============================================================*/
X
Xint main ( int argc, char **argv )
X/*
X** args:  argv[1] : name to be used for IPC (pipes/semaphores) with gnuplot 
X** 
X** Standard PM initialisation:
X** -- set up message processing loop
X** -- register all window classes
X** -- start up main window
X** -- subclass main window for help and dde message trapping to frame window
X** -- init help system
X** -- check command line and open any filename found there
X**
X*/
X    {
X    static ULONG flFrameFlags = (FCF_ACCELTABLE|FCF_STANDARD);//&(~FCF_TASKLIST) ;
X    static ULONG flClientFlags = WS_VISIBLE ;
X    HMQ          hmq ;
X    QMSG         qmsg ;
X    PFNWP        pfnOldFrameWndProc ;
X    HWND         hwndHelp ;        
X    BOOL         bPos ;
X
X    if( argc <= 1 ) strcpy( szIPCName, IPCDEFAULT ) ;
X    else            strcpy( szIPCName, argv[1] ) ; 
X
X    hab = WinInitialize( 0 ) ;    
X    hmq = WinCreateMsgQueue( hab, 50 ) ;
X
X                // get defaults from gnupmdrv.ini
X
X    bPos = QueryIni( hab ) ;
X                
X                // register window and child window classes
X
X    if( ! WinRegisterClass( hab,        /* Exit if can't register */
X                            APP_NAME,
X                            (PFNWP)DisplayClientWndProc,
X                            CS_SIZEREDRAW,
X                            0 ) 
X                            ) return 0L ;
X
X                // create main window
X
X    hwndFrame = WinCreateStdWindow (
X                    HWND_DESKTOP,
X                    0,//WS_VISIBLE,
X                    &flFrameFlags,
X                    APP_NAME,
X                    NULL,
X                    flClientFlags,
X                    0L,
X                    1,
X                    &hApp) ;
X
X    if ( ! hwndFrame ) return NULL ;
X
X                // subclass window for help & DDE trapping
X
X    pfnOldFrameWndProc = WinSubclassWindow( hwndFrame, (PFNWP)NewFrameWndProc ) ;
X    WinSetWindowULong( hwndFrame, QWL_USER, (ULONG) pfnOldFrameWndProc ) ;
X
X                // init the help manager
X
X    hwndHelp = InitHelp( hab, hwndFrame ) ;        
X
X                // set window title and make it active
X
X    WinSetWindowText( hwndFrame, APP_NAME ) ;
X        
X                // process window messages 
X      
X    while (WinGetMsg (hab, &qmsg, NULL, 0, 0))
X         WinDispatchMsg (hab, &qmsg) ;
X
X                // shut down
X
X    WinDestroyHelpInstance( hwndHelp ) ;
X    WinDestroyWindow (hwndFrame) ;
X    WinDestroyMsgQueue (hmq) ;
X    WinTerminate (hab) ;
X
X    return 0 ;
X    }
X
Xstatic HWND InitHelp( HAB hab, HWND hwnd )
X/*
X**  initialise the help system
X*/
X    {
X    static HELPINIT helpinit = { sizeof(HELPINIT),
X                                 0L,
X                                 NULL,
X                                 (PHELPTABLE)MAKELONG(1, 0xFFFF),
X                                 0L,
X                                 0L,
X                                 0,
X                                 0,
X                                 "GnuplotPM Help",
X                                 CMIC_HIDE_PANEL_ID,
X                                 "gnupmdrv.hlp" } ;
X    HWND hwndHelp ;
X    
X    hwndHelp = WinCreateHelpInstance( hab, &helpinit ) ;
X    WinAssociateHelpInstance( hwndHelp, hwnd ) ;
X    return hwndHelp ;
X    }
X
XMRESULT EXPENTRY NewFrameWndProc (HWND hwnd, ULONG msg, MPARAM mp1, MPARAM mp2)
X/*
X**  Subclasses top-level frame window to trap help & dde messages
X*/
X    {
X    PFNWP       pfnOldFrameWndProc ;
X    
X    pfnOldFrameWndProc = (PFNWP) WinQueryWindowULong( hwnd, QWL_USER ) ; 
X    switch( msg ) {
X        default: 
X            break ;
X
X        case HM_QUERY_KEYS_HELP:
X            return (MRESULT) IDH_KEYS ;            
X        }
X    return (*pfnOldFrameWndProc)(hwnd, msg, mp1, mp2) ;    
X    }
X
X
XMRESULT EXPENTRY About( HWND hDlg, ULONG message, MPARAM mp1, MPARAM mp2)
X/*
X** 'About' box dialog function
X*/
X    {
X  /*  switch (message) {
X
X        case WM_COMMAND:
X            if (SHORT1FROMMP(mp1) == DID_OK) {
X                WinDismissDlg( hDlg, DID_OK );
X                return 0L;
X                }
X            break;
X        }*/
X    return WinDefDlgProc( hDlg, message, mp1, mp2 ) ;
X    }
X
END_OF_FILE
  if test 6295 -ne `wc -c <'gnuplot/os2/gnupmdrv.c'`; then
    echo shar: \"'gnuplot/os2/gnupmdrv.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/os2/gnupmdrv.c'
fi
if test -f 'gnuplot/term/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/README'\"
else
  echo shar: Extracting \"'gnuplot/term/README'\" \(7115 characters\)
  sed "s/^X//" >'gnuplot/term/README' <<'END_OF_FILE'
XDOCUMENTATION FOR GNUPLOT TERMINAL DRIVER WRITERS
XBy Russell Lang 1/90
X
XInformation on each terminal device driver is contained in term.c and
Xthe term/*.trm files.  Each driver is contained in a .trm file and is 
X#include'd into term.c.  Each driver has a set of initialisers in 
Xterm.c for term_tbl[], an array of struct termentry.
X
XHere is the definition of the struct termentry from plot.h:
X
Xstruct termentry {
X	char *name;
X	char *description;
X	unsigned int xmax,ymax,v_char,h_char,v_tic,h_tic;
X	FUNC_PTR options,init,reset,text,scale,graphics,move,vector,linetype,
X		put_text,text_angle,justify_text,point,arrow;
X};
X
XHere's a brief description of each variable:
X
XThe char *name is a pointer to a string containing the name
Xof the terminal.  This name is used by the 'set terminal' and 
X'show terminal' commands.  
XThe name must be unique and must not be confused with an abbreviation 
Xof another name.  For example if the name "postscript" exists, it is not
Xpossible to have another name "postscript2".
XKeep the name under 15 characters.
X
XThe char *description is a pointer to a string containing a
Xdescription of the terminal, which is displayed in response
Xto the 'set terminal' command.  
XKeep the description under 60 characters.
X
Xxmax is the maximum number of points in the x direction.  
XThe range of points used by gnuplot is 0 to xmax-1.
X
Xymax is the maximum number of points in the y direction.  
XThe range of points used by gnuplot is 0 to ymax-1.
X
Xv_char is the height of characters, in the same units as xmax and ymax.
XThe border for labelling at the top and bottom of the plot is 
Xcalculated using v_char.  
Xv_char is used as the vertical line spacing for characters.
X
Xh_char is the width of characters, in the same units as xmax and ymax.
XThe border for labelling at the left and right of the plot is 
Xcalculated using h_char.  
XIf the _justify_text function returns FALSE, h_char is used to justify 
Xtext right or centre.  If characters are not fixed width, then the 
X_justify_text function must correctly justify the text.
X
Xv_tic is the vertical size of tics along the x axis, 
Xin the same units as ymax.
X
Xh_tic is the horizontal size of tics along the y axis, 
Xin the same units as xmax.
X
X
XHere's a brief description of what each term.c function does:
X
X_options()  Called when terminal type is selected.  
XThis procedure should parse options on the command line.  A list of the 
Xcurrently selected options should be stored in term_options[] in a form 
Xsuitable for use with the set term command.  term_options[] is used by 
Xthe save command.  Use options_null() if no options are available. 
X
X_init()  Called once, when the device is first selected.  This procedure
Xshould set up things that only need to be set once, like handshaking and
Xcharacter sets etc...
X
X_reset()  Called when gnuplot is exited, the output device changed or
Xthe terminal type changed.  This procedure should reset the device, 
Xpossibly flushing a buffer somewhere or generating a form feed.
X
X_scale(xs,ys) Called just before _graphics(). This takes the x and y
Xscaling factors as information. If the terminal would like to do its
Xown scaling, it returns TRUE. Otherwise, it can ignore the information
Xand return FALSE: do_plot will do the scaling for you. null_scale is
Xprovided to do just this, so most drivers can ignore this function
Xentirely. The Latex driver is currently the only one providing its own
Xscaling.
X
X_graphics()  Called just before a plot is going to be displayed.  This
Xprocedure should set the device into graphics mode.  Devices which can't
Xbe used as terminals (like plotters) will probably be in graphics mode 
Xalways and therefore won't need this.
X
X_text()  Called immediately after a plot is displayed.  This procedure 
Xshould set the device back into text mode if it is also a terminal, so
Xthat commands can be seen as they're typed.  Again, this will probably
Xdo nothing if the device can't be used as a terminal.
X
X_move(x,y)  Called at the start of a line.  The cursor should move to the
X(x,y) position without drawing.
X
X_vector(x,y)  Called when a line is to be drawn.  This should display a line
Xfrom the last (x,y) position given by _move() or _vector() to this new (x,y)
Xposition.
X
X_linetype(lt)  Called to set the line type before text is displayed or
Xline(s) plotted.  This procedure should select a pen color or line
Xstyle if the device has these capabilities.  
Xlt is an integer from -2 to 0 or greater.  
XAn lt of -2 is used for the border of the plot.
XAn lt of -1 is used for the X and Y axes.  
Xlt 0 and upwards are used for plots 0 and upwards.
XIf _linetype() is called with lt greater than the available line types, 
Xit should map it to one of the available line types.
XMost drivers provide 9 different linetypes (lt is 0 to 8).
X
X_put_text(x,y,str)  Called to display text at the (x,y) position, 
Xwhile in graphics mode.   The text should be vertically (with respect 
Xto the text) justified about (x,y).  The text is rotated according 
Xto _text_angle and then horizontally (with respect to the text)
Xjustified according to _justify_text.
X
X_text_angle(ang)  Called to rotate the text angle when placing the y label.
XIf ang = 0 then text is horizontal.  If ang = 1 then text is vertically
Xupwards.  Returns TRUE if text can be rotated, FALSE otherwise.
X
X_justify_text(mode)  Called to justify text left, right or centre.
XIf mode = LEFT then text placed by _put_text is flushed left against (x,y).
XIf mode = CENTRE then centre of text is at (x,y).  
XIf mode = RIGHT then text is placed flushed right against (x,y).
XReturns TRUE if text can be justified
XReturns FALSE otherwise and then _put_text assumes text is flushed left;
Xjustification of text is then performed by calculating the text width
Xusing strlen(text) * h_char.
X
X_point(x,y,point)  Called to place a point at position (x,y).
Xpoint is -1 or an integer from 0 upwards.  
X6 point types (numbered 0 to 5) are normally provided.  
XPoint type -1 is a dot.
XIf point is more than the available point types then it should 
Xbe mapped back to one of the available points.
XTwo _point() functions called do_point() and line_and_point() are 
Xprovided in term.c and should be suitable for most drivers.  
Xdo_point() draws the points in the current line type.
XIf your driver uses dotted line types (generally because it is
Xmonochrome), you should use line_and_point() which changes to 
Xline type 0 before drawing the point.  line type 0 should be solid.
X
X_arrow(sx,sy,ex,ey,head)  Called to draw an arrrow from (sx,sy) to (ex,ey).
XA head is drawn on the arrow if head = TRUE.
XAn _arrow() function called do_arrow() is provided in term.c which will
Xdraw arrows using the _move() and _vector() functions.  
XDrivers should use do_arrow unless it causes problems.
X
XThe following should illustrate the order in which calls to these
Xroutines are made:
X
X  _init()
X    _scale(xs,ys)
X    _graphics()
X      _linetype(lt)
X      _move(x,y)
X      _vector(x,y)
X	  _point(x,y,point)
X      _text_angle(angle)
X      _justify(mode)
X      _put_text(x,y,text)
X      _arrow(sx,sy,ex,ey)
X    _text()
X    _graphics()
X      .
X      .
X    _text()
X  _reset()
X
X
END_OF_FILE
  if test 7115 -ne `wc -c <'gnuplot/term/README'`; then
    echo shar: \"'gnuplot/term/README'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/README'
fi
if test -f 'gnuplot/term/ai.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/ai.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/ai.trm'\" \(7393 characters\)
  sed "s/^X//" >'gnuplot/term/ai.trm' <<'END_OF_FILE'
X/*
X * $Id: ai.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - ai.trm */
X/*
X * Copyright (C) 1991, 1992   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *     aifm
X *
X * AUTHORS
X *  Ray Ghanbari
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X * The 'aifm' driver produces files editable by Adobe Illustrator 3.0
X * To change font to Courier and font size to 20pts use 
X * 'set term aifm "Courier" 20'.
X * To switch to color output use
X * 'set term aifm color'.
X */
X
X
X/* AIFM driver by Ray Ghanbari, ray@mtl.mit.edu, 
X *	based on PostScript driver by Russell Lang, rjl@monu1.cc.monash.edu.au */
X
Xchar ai_font[MAX_ID_LEN+1] = "Times-Roman" ; /* name of font */
Xint ai_fontsize = 14;					 /* size of font in pts */
XTBOOLEAN ai_color = FALSE;
XTBOOLEAN ai_stroke = FALSE;
Xint ai_page=0;			/* page count */
Xint ai_path_count=0; 	/* count of lines in path */
Xint ai_ang=0;			/* text angle */
Xenum JUSTIFY ai_justify=LEFT;	/* text is flush left */
X
X
X#define AI_XOFF	50	/* page offset in pts */
X#define AI_YOFF	50
X
X#define AI_XMAX 5000
X#define AI_YMAX 3500
X
X#define AI_XLAST (AI_XMAX - 1)
X#define AI_YLAST (AI_YMAX - 1)
X
X#define AI_VTIC (AI_YMAX/80)
X#define AI_HTIC (AI_YMAX/80)
X
X#define AI_SC (10.0)				/* scale is 1pt = 10 units */
X#define AI_LW (0.5*AI_SC)		/* linewidth = 0.5 pts */
X
X#define AI_VCHAR (14*AI_SC)		/* default is 14 point characters */
X#define AI_HCHAR (14*AI_SC*6/10)
X
X
XAI_options()
X{
X	extern struct value *const_express();
X	extern double real();
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"d$efault")) {
X			ai_color=FALSE;
X			strcpy(ai_font,"Times-Roman");
X			ai_fontsize = 14;
X			c_token++;
X		}
X	}
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"m$onochrome")) {
X			ai_color=FALSE;
X			c_token++;
X		}
X		else if (almost_equals(c_token,"c$olor")) {
X			ai_color=TRUE;
X			c_token++;
X		}
X	}
X
X	if (!END_OF_COMMAND && isstring(c_token)) {
X		quote_str(ai_font,c_token);
X		c_token++;
X	}
X
X	if (!END_OF_COMMAND) {
X		/* We have font size specified */
X		struct value a;
X		ai_fontsize = (int)real(const_express(&a));
X		c_token++;
X		term_tbl[term].v_char = (unsigned int)(ai_fontsize*AI_SC);
X		term_tbl[term].h_char = (unsigned int)(ai_fontsize*AI_SC*6/10);
X	}
X
X	sprintf(term_options,"%s \"%s\" %d",
X		ai_color ? "color" : "monochrome",ai_font,ai_fontsize);
X}
X
X
XAI_init()
X{
X	ai_page = 0;
X	fprintf(outfile,"%%!PS-Adobe-2.0 EPSF-1.2\n");
X	fprintf(outfile,"%%%%BoundingBox: %d %d %d %d\n", AI_XOFF,AI_YOFF,
X		(int)((AI_XMAX)/AI_SC+0.5+AI_XOFF), 
X		(int)((AI_YMAX)/AI_SC+0.5+AI_YOFF) );
X	fprintf(outfile,"%%%%Template:\n");
X	fprintf(outfile,"%%%%EndComments\n");
X	fprintf(outfile,"%%%%EndProlog\n");
X}
X
X
XAI_graphics()
X{
X	ai_page++;
X/*	fprintf(outfile,"%%%%Page: %d %d\n",ai_page,ai_page);*/
X	fprintf(outfile,"0 G\n");
X	fprintf(outfile,"1 j\n");
X	fprintf(outfile,"1 J\n");
X	fprintf(outfile,"u\n");
X	ai_path_count = 0;
X	ai_stroke = FALSE;
X}
X
X
XAI_text()
X{
X	if (ai_stroke) {
X		fprintf(outfile,"S\n");
X		ai_stroke = FALSE;
X	}
X	fprintf(outfile,"U\n");
X	ai_path_count = 0;
X}
X
X
XAI_reset()
X{
X	fprintf(outfile,"%%%%Trailer\n");
X/*	fprintf(outfile,"%%%%Pages: %d\n",ai_page);*/
X}
X
X
XAI_linetype(linetype)
Xint linetype;
X{
X	if (ai_stroke) {
X		fprintf(outfile,"S\n");
X		ai_stroke = FALSE;
X	}
X	switch(linetype) {
X		case -2 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC*2.0);
X				if (ai_color) {
X					fprintf(outfile,"0 0 0 1 K\n");
X				}
X				else {				
X					fprintf(outfile,"[] 0 d\n");
X				}
X				break;
X				
X		case -1 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC/2.0);
X				if (ai_color) {
X					fprintf(outfile,"0 0 0 1 K\n");
X				}
X				else {				
X					fprintf(outfile,"[1 2] 0 d\n");
X				}
X				break;
X				
X		case 0 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"1 0 1 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[] 0 d\n");
X				}
X				break;
X				
X		case 1 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"1 1 0 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[4 2] 0 d\n");
X				}
X				break;
X				
X		case 2 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0 1 1 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[2 3] 0 d\n");
X				}
X				break;
X				
X		case 3 :  fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0 1 0 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[1 1.5] 0 d\n");
X				}
X				break;
X				
X		case 4 :  fprintf(outfile,"%f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"1 0 0 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[5 2 1 2] 0 d\n");
X				}
X				break;
X				
X		case 5 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0 0 1 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[4 3 1 3] 0 d\n");
X				}
X				break;
X				
X		case 6 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0 0 0 1 K\n");
X				}
X				else {				
X					fprintf(outfile,"[2 2 2 4] 0 d\n");
X				}
X				break;
X				
X		case 7 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0 0.7 1 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[2 2 2 2 2 4] 0 d\n");
X				}
X				break;
X				
X		case 8 : fprintf(outfile,"%.2f w\n",AI_LW/AI_SC);
X				if (ai_color) {
X					fprintf(outfile,"0.5 0.5 0.5 0 K\n");
X				}
X				else {				
X					fprintf(outfile,"[2 2 2 2 2 2 2 4] 0 d\n");
X				}
X				break;
X		}
X				
X	ai_path_count = 0;
X}
X
X
XAI_move(x,y)
Xunsigned int x,y;
X{
X	if (ai_stroke) fprintf(outfile,"S\n");
X	fprintf(outfile,"%.2f %.2f m\n", x/AI_SC, y/AI_SC);
X	ai_path_count += 1;
X	ai_stroke = TRUE;
X}
X
X
XAI_vector(x,y)
Xunsigned int x,y;
X{
X	fprintf(outfile,"%.2f %.2f l\n", x/AI_SC, y/AI_SC);
X	ai_path_count += 1;
X	ai_stroke = TRUE;
X	if (ai_path_count >= 400) {
X		fprintf(outfile,"S\n%.2f %.2f m\n",x/AI_SC,y/AI_SC);
X		ai_path_count = 0;
X	}
X}
X
X
XAI_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xchar ch;
X	if (ai_stroke) {
X		fprintf(outfile,"S\n");
X		ai_stroke = FALSE;
X	}
X	switch(ai_justify) {
X		case LEFT :   fprintf(outfile,"/_%s %d 0 0 0 z\n",ai_font,ai_fontsize);
X			break;
X		case CENTRE : fprintf(outfile,"/_%s %d 0 0 1 z\n",ai_font,ai_fontsize);
X			break;
X		case RIGHT :  fprintf(outfile,"/_%s %d 0 0 2 z\n",ai_font,ai_fontsize);
X			break;
X	}
X	if (ai_ang==0) {
X		fprintf(outfile,"[ 1 0 0 1 %.2f %.2f] e\n",
X			x/AI_SC,y/AI_SC - ai_fontsize/3.0);
X	}
X	else {
X		fprintf(outfile,"[ 0 1 -1 0 %.2f %.2f] e\n",
X			x/AI_SC - ai_fontsize/3.0,y/AI_SC);
X	}
X		
X	putc('(',outfile);
X	ch = *str++;
X	while(ch!='\0') {
X		if ( (ch=='(') || (ch==')') || (ch=='\\') )
X			putc('\\',outfile);
X		putc(ch,outfile);
X		ch = *str++;
X	}
X	fprintf(outfile,") t\nT\n");
X	ai_path_count = 0;
X}
X
Xint AI_text_angle(ang)
Xint ang;
X{
X	ai_ang=ang;
X	return TRUE;
X}
X
Xint AI_justify_text(mode)
Xenum JUSTIFY mode;
X{
X	ai_justify=mode;
X	return TRUE;
X}
X
END_OF_FILE
  if test 7393 -ne `wc -c <'gnuplot/term/ai.trm'`; then
    echo shar: \"'gnuplot/term/ai.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/ai.trm'
fi
if test -f 'gnuplot/term/hp2648.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/hp2648.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/hp2648.trm'\" \(2187 characters\)
  sed "s/^X//" >'gnuplot/term/hp2648.trm' <<'END_OF_FILE'
X/*
X * $Id: hp2648.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT -  hp2648.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  HP2648 and HP2647
X *
X * AUTHORS
X *  Russell Lang
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X#define HP2648XMAX 720             
X#define HP2648YMAX 360
X
X#define HP2648XLAST (HP2648XMAX - 1)
X#define HP2648YLAST (HP2648YMAX - 1)
X
X#define HP2648VCHAR		12  	
X#define HP2648HCHAR		7		
X#define HP2648VTIC		8
X#define HP2648HTIC		8
X
X
XHP2648init()
X{
X	fprintf(outfile,"\033*m1m1n136,1cZ");
X/*                   1     2 3     4
X	1. mode
X	2. textsize=1
X	3. textangle=1
X        4. define line type 2 to be *   *   *   * etc.
X*/
X}
X
X
XHP2648graphics()
X{
X	fprintf(outfile,"\033*dacZ");
X/*                   1     23
X	1. mode
X	2. clear grahics screen
X	3. graphics video on
X*/
X}
X
X
XHP2648text()
X{
X}
X
X
XHP2648linetype(linetype)
Xint linetype;
X{
X	static int hpline[] = {1,7,1,4,5,6,8,9,10,7,2};
X	fprintf(outfile,"\033*m%dbZ",hpline[(linetype+2)%11]);
X}
X
X
XHP2648move(x,y)
Xint x,y;
X{
X	fprintf(outfile,"\033*paf%d,%dZ",x,y);
X    /*               1     23     4
X	1	plot mode
X	2	"pen up"
X	3	goto absolute x,y
X	4	end command
X	*/
X}
X
X
XHP2648vector(x,y)
Xint x,y;
X{
X	fprintf(outfile,"\033*pbf%d,%dZ",x,y);
X    /*                     1 
X	1	"pen down"
X	*/
X}
X
X
XHP2648put_text(x,y,str)
Xint x, y;
Xchar *str;
X{
X	HP2648move(x,y-HP2648VCHAR/2 + 1);
X	fprintf(outfile,"\033*l%s\n",str);
X}
X
X
Xint HP2648_text_angle(ang)
Xint ang;
X{
X	fprintf(outfile,"\033*m%dnZ\n",ang+1);
X	return TRUE;
X}
X	
XHP2648reset()
X{
X}
X
END_OF_FILE
  if test 2187 -ne `wc -c <'gnuplot/term/hp2648.trm'`; then
    echo shar: \"'gnuplot/term/hp2648.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/hp2648.trm'
fi
if test -f 'gnuplot/term/pbm.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/pbm.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/pbm.trm'\" \(7401 characters\)
  sed "s/^X//" >'gnuplot/term/pbm.trm' <<'END_OF_FILE'
X/*
X * $Id: pbm.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - pbm.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  pbm
X *
X * AUTHORS
X *  Russell Lang
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/* The following pbmplus drivers use the generic bit mapped graphics
X   routines from bitmap.c to build up a bit map in memory.  The driver
X   interchanges colomns and lines in order to access entire lines
X   easily and returns the lines to get bits in the right order :
X   (x,y) -> (y,XMAX-1-x). */
X/* This interchange is done by calling b_makebitmap() with reversed 
X   xmax and ymax, and then setting b_rastermode to TRUE.  b_setpixel()
X   will then perform the interchange before each pixel is plotted */
X/* See Jef Poskanzer's excellent PBMplus package for more details of
X   the Portable BitMap format and for programs to convert PBM files  
X   to other bitmap formats. */
X
X#ifdef PBM
X
X/* make XMAX and YMAX a multiple of 8 */
X#define PBM_XMAX (640)
X#define PBM_YMAX (480)
X#define PBM_VCHAR (FNT5X9_VCHAR)
X#define PBM_HCHAR (FNT5X9_VCHAR)
X#define PBM_VTIC FNT5X9_HBITS
X#define PBM_HTIC FNT5X9_HBITS
X
Xstatic int pbm_font=1;	/* small font */
Xstatic int pbm_mode=0;  /* 0:monochrome 1:gray 2:color */
X
X/* 7=black, 0=white */
Xstatic int pgm_gray[]={7,1,6,5,4,3,2,1,7};  /* grays  */
X/* bit3=!intensify, bit2=!red, bit1=!green, bit0=!blue */
Xstatic int ppm_color[]={15,8,3,5,6,4,2,1,11,13,14}; /* colors */
X
XPBMoptions()
X{
X  pbm_font=1;
X  pbm_mode=0;
X
X  term_options[0]='\0';
X
X  while (!END_OF_COMMAND) {
X    if (almost_equals(c_token,"s$mall"))
X      pbm_font=1;
X    else if (almost_equals(c_token,"me$dium"))
X      pbm_font=2;
X    else if (almost_equals(c_token,"l$arge"))
X      pbm_font=3;
X    else if (almost_equals(c_token,"mo$nochrome"))
X      pbm_mode=0;
X    else if (almost_equals(c_token,"g$ray"))
X      pbm_mode=1;
X    else if (almost_equals(c_token,"c$olor"))
X      pbm_mode=2;
X    else {
X      pbm_font=1; /* reset to default, since term is already set */
X      pbm_mode=0;
X      int_error("expecting: {small, medium, large} and {monochrome, gray, color}",c_token);
X    }
X    c_token++;
X  }
X
X  /* setup options string */
X
X  switch(pbm_font) {
X    case 1: strcat(term_options,"small"); break;
X    case 2: strcat(term_options,"medium"); break;
X    case 3: strcat(term_options,"large"); break;
X  }
X
X  switch(pbm_mode) {
X    case 0: strcat(term_options," monochrome"); break;
X    case 1: strcat(term_options," gray"); break;
X    case 2: strcat(term_options," color"); break;
X  }
X}
X
X
XPBMinit()
X{
X#ifdef REOPEN_BINARY
X   reopen_binary();
X#endif /* REOPEN_BINARY */
X}
X
X
XPBMreset()
X{
X#ifdef vms
X   fflush_binary();
X#endif /* vms */
X}
X
X
XPBMsetfont()
X{
X	switch(pbm_font) {
X		case 1:
X			b_charsize(FNT5X9);
X			term_tbl[term].v_char = FNT5X9_VCHAR;
X			term_tbl[term].h_char = FNT5X9_HCHAR;
X			term_tbl[term].v_tic = FNT5X9_HBITS;
X			term_tbl[term].h_tic = FNT5X9_HBITS;
X			break;
X		case 2:
X			b_charsize(FNT9X17);
X			term_tbl[term].v_char = FNT9X17_VCHAR;
X			term_tbl[term].h_char = FNT9X17_HCHAR;
X			term_tbl[term].v_tic = FNT9X17_HBITS;
X			term_tbl[term].h_tic = FNT9X17_HBITS;
X			break;
X		case 3:
X			b_charsize(FNT13X25);
X			term_tbl[term].v_char = FNT13X25_VCHAR;
X			term_tbl[term].h_char = FNT13X25_HCHAR;
X			term_tbl[term].v_tic = FNT13X25_HBITS;
X			term_tbl[term].h_tic = FNT13X25_HBITS;
X			break;
X	}
X}
X
X
XPBMgraphics()
X{
X  int numplanes;
X
X  switch(pbm_mode) {
X    case 0: numplanes=1; break;
X    case 1: numplanes=3; break;
X    case 2: numplanes=4; break;
X  }
X
X  PBMsetfont();
X  /* rotate plot -90 degrees by reversing XMAX and YMAX and by 
X  setting b_rastermode to TRUE */
X  b_makebitmap((unsigned int)(PBM_YMAX*ysize),
X               (unsigned int)(PBM_XMAX*xsize),numplanes);
X  b_rastermode = TRUE;
X
X  if(pbm_mode!=0)
X    b_setlinetype(0); /* solid lines */
X}
X
X
XPBMmonotext()
X{
X  register int x,j,row;
X
X   fprintf(outfile,"P4\n");
X   fprintf(outfile,"%u %u\n", b_ysize, b_xsize);
X
X   /* dump bitmap in raster mode */
X   for (x = b_xsize-1; x >= 0; x--) {
X      row = (b_ysize/8)-1;
X      for (j = row; j >= 0; j--) {
X         (void) fputc( (char)(*((*b_p)[j]+x)), outfile );
X      }
X   }
X
X   b_freebitmap();
X}
X
XPBMgraytext()
X{
X  register int x,j,row;
X  register int i,value;
X  int mask, plane1, plane2, plane3;
X
X   fprintf(outfile,"P5\n");
X   fprintf(outfile,"%u %u\n", b_ysize, b_xsize);
X   fprintf(outfile,"%u\n",7);
X
X   /* dump bitmap in raster mode */
X   for (x = b_xsize-1; x >= 0; x--) {
X      row = (b_ysize/8)-1;
X      for (j = row; j >= 0; j--) {
X         mask = 0x80;
X         plane1=(*((*b_p)[j]+x));
X         plane2=(*((*b_p)[j+b_psize]+x));
X         plane3=(*((*b_p)[j+b_psize+b_psize]+x));
X         for (i=0; i<8; i++) {
X            value=7;
X            if (plane1 & mask)  value-=1;
X            if (plane2 & mask)  value-=2;
X            if (plane3 & mask)  value-=4;
X            (void) fputc( (char)(value), outfile );
X            mask>>=1;
X         }
X      }
X   }
X
X   b_freebitmap();
X}
X
XPBMcolortext()
X{
X  register int x,j,row;
X  register int i;
X  int mask, plane1, plane2, plane3, plane4;
X  int red, green, blue;
X
X   fprintf(outfile,"P6\n");
X   fprintf(outfile,"%u %u\n", b_ysize, b_xsize);
X   fprintf(outfile,"%u\n",3);
X
X   /* dump bitmap in raster mode */
X   for (x = b_xsize-1; x >= 0; x--) {
X      row = (b_ysize/8)-1;
X      for (j = row; j >= 0; j--) {
X         mask = 0x80;
X         plane1=(*((*b_p)[j]+x));
X         plane2=(*((*b_p)[j+b_psize]+x));
X         plane3=(*((*b_p)[j+b_psize+b_psize]+x));
X         plane4=(*((*b_p)[j+b_psize+b_psize+b_psize]+x));
X         for (i=0; i<8; i++) {
X            red = (plane3 & mask) ? 1 : 3;
X            green = (plane2 & mask) ? 1 : 3;
X            blue = (plane1 & mask) ? 1 : 3;
X            if (plane4 & mask) {
X               red--; green--; blue--;
X            }
X            (void) fputc( (char)(red), outfile );
X            (void) fputc( (char)(green), outfile );
X            (void) fputc( (char)(blue), outfile );
X            mask>>=1;
X         }
X      }
X   }
X
X   b_freebitmap();
X}
X
XPBMtext()
X{
X  switch(pbm_mode) {
X    case 0: PBMmonotext(); break;
X    case 1: PBMgraytext(); break;
X    case 2: PBMcolortext(); break;
X  }
X}
X
X
XPBMlinetype(linetype)
Xint linetype;
X{
X  switch(pbm_mode) {
X    case 0:
X      b_setlinetype(linetype);
X    break;
X    case 1:
X      if (linetype>=7)
X        linetype %= 7;
X      b_setvalue(pgm_gray[linetype+2]);
X    break;
X    case 2:
X      if (linetype>=9)
X        linetype %= 9;
X      b_setvalue(ppm_color[linetype+2]);
X    break;
X  }
X}
X
XPBMpoint(x,y,point)
Xint x,y,point;
X{
X  if(pbm_mode==0) line_and_point(x,y,point);
X  else            do_point(x,y,point);
X}
X
X#define PBMmove b_move
X#define PBMvector b_vector
X#define PBMtext_angle b_text_angle
X#define PBMput_text b_put_text
X
X#endif /* PBM */
END_OF_FILE
  if test 7401 -ne `wc -c <'gnuplot/term/pbm.trm'`; then
    echo shar: \"'gnuplot/term/pbm.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/pbm.trm'
fi
if test -f 'gnuplot/term/pm.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/pm.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/pm.trm'\" \(7141 characters\)
  sed "s/^X//" >'gnuplot/term/pm.trm' <<'END_OF_FILE'
X/*
X *    pm.trm  --- inboard terminal driver for Presentation Manager
X *            --- after X-11 driver, by R.W.Fearick 31/1/92.
X *    v1.1 11/8/92 -- speed things up        
X */
X
X#include <stdio.h>
X#include <process.h>
X
X/* 
X   include all stuff from os2.h as GNUPLOT uses INT as an enum and
X   this clashes with #defines in os2.h 
X*/
X
Xtypedef unsigned short USHORT;
Xtypedef USHORT *PUSHORT;
Xtypedef void *PVOID ;
Xtypedef char *PCHAR ;
X
Xtypedef long LONG;
Xtypedef LONG *PLONG;
X
Xtypedef unsigned long ULONG;
Xtypedef ULONG *PULONG;
Xtypedef struct
X{
X  ULONG  tib2_ultid;
X  ULONG  tib2_ulpri;
X  ULONG  tib2_version;
X  USHORT tib2_usMCCount;
X  USHORT tib2_fMCForceFlag;
X} TIB2;
Xtypedef TIB2 *PTIB2;
X
Xtypedef struct
X{
X  PVOID tib_pexchain;
X  PVOID tib_pstack;
X  PVOID tib_pstacklimit;
X  PTIB2 tib_ptib2;
X  ULONG tib_version;
X  ULONG tib_ordinal;
X} TIB;
Xtypedef TIB *PTIB;
X
Xtypedef struct
X{
X  ULONG pib_ulpid;
X  ULONG pib_ulppid;
X  ULONG pib_hmte;
X  PCHAR pib_pchcmd;
X  PCHAR pib_pchenv;
X  ULONG pib_flstatus;
X  ULONG pib_ultype;
X} PIB;
Xtypedef PIB *PPIB;
Xtypedef ULONG HEV;
Xtypedef HEV *PHEV;
X
XULONG DosCreateEventSem (const char *, PHEV, ULONG, ULONG);
XULONG DosWaitEventSem (HEV, ULONG);
XULONG DosGetInfoBlocks (PTIB *, PPIB *);
XULONG DosSearchPath( ULONG, char*, char*, char*, ULONG ) ;
X
X/* define PM world coordinate limits */
X#define PM_XMAX 4096
X#define PM_YMAX 4096
X
X/* approximations for typical font/screen sizes */
X
X#define PM_VCHAR (PM_YMAX/30) 
X#define PM_HCHAR (PM_XMAX/80) 
X#define PM_VTIC (PM_YMAX/100)
X#define PM_HTIC (PM_XMAX/150)
X
X/* graphics commands */
X#define SET_GRAPHICS    'G'
X#define SET_TEXT        'E'
X#define SET_LINE        'L'
X#define SET_ANGLE       'A'
X#define SET_JUSTIFY     'J'
X#define SET_POINTMODE   'D'
X#define GR_MOVE         'M'
X#define GR_DRAW         'V'
X#define GR_RESET        'R'
X#define GR_TEXT         'T'
X#define GR_PAUSE        'P'
X#define GR_HELP         'H'
X#define PM_nopts 1
X
Xstatic char PM_path[256] = "" ;  /* path for pm program */
Xstatic int  PM_mode      = 0 ;   /* track mode to avoid redraw after hitting break */
Xstatic     HEV hev ;
X
Xchar PM_opts[PM_nopts][20] = {
X   " "
X   };
Xint PM_optarg[PM_nopts] = { 
X   0
X   };
X
XFILE *PM_pipe=NULL, *fopen();
Xchar PM_command[1024]= "gnuplot_PM -name gnuplot";
X
X
X/*   PM_args - scan gnuplot command line for options */
X
XPM_args(argc, argv) int argc; char *argv[]; {
X   int nPM = 0, n;
X   if( PM_path[0]=='\0' ) getcwd( PM_path, 256 ) ;
X   return(nPM);
X   }
X
XPM_init() 
X    { 
X    static char buffer[1024] ;
X    int pid ;
X    int rc ;
X    PPIB pib ;
X    PTIB tib ;
X    char semname[32] ;
X    char pipename[32] ;
X    char tempname[32] ;
X    if( PM_pipe == NULL ) {
X        strcpy( tempname, "gpXXXXXX" ) ;
X        if( mktemp( tempname ) == NULL ) {
X            fprintf( stderr, "Temp name failure !\n" ) ;
X            abort() ;   
X            }
X        strcpy( semname, "\\sem32\\" ) ;
X        strcpy( pipename, "\\pipe\\" ) ;
X        strcat( semname, tempname ) ;
X        strcat( pipename, tempname ) ;
X        strcat( PM_path, "\\gnupmdrv.exe" ) ;
X        rc = access( PM_path, 0 ) ;
X            /* find exe file */ 
X  
X        if( rc != 0 ) 
X            rc = DosSearchPath( 0x0002, /* search GNUPLOT environment */
X                                "GNUPLOT",
X                                "gnupmdrv.exe",
X                                PM_path,
X                                256 ) ; 
X
X        if( rc != 0 ) 
X            rc = DosSearchPath( 0x0003,  /* then try current directory & path */
X                                "PATH",
X                                "gnupmdrv.exe",
X                                PM_path,
X                                256 ) ; 
X        if( rc != 0 ) {
X            fprintf( stderr, "Can't find gnupmdrv.exe !\n" ) ;
X            abort() ;   
X            }
X                            
X        rc = DosCreateEventSem( semname, &hev, 1, 0 ) ;
X        if( rc != 0 ) {
X            fprintf( stderr, "Can't create semaphore !\n" ) ;
X            abort() ;   
X            }
X        pid=spawnl( P_SESSION|P_DEFAULT, PM_path, "GnuplotPM", tempname, NULL ) ;
X        if( rc == -1 ) {
X            fprintf( stderr, "Can't spawn gnupmdrv.exe !\n" ) ;
X            abort() ;   
X            }
X
X        DosGetInfoBlocks( &tib, &pib ) ;
X        DosWaitEventSem( hev, 10000 ) ;        
X        PM_pipe = fopen( pipename, "r+b" ) ; 
X        if( PM_pipe == NULL ) {
X            fprintf( stderr, "Can't open pipe to gnupmdrv.exe !\n" ) ;
X            abort() ;   
X            }
X        setvbuf( PM_pipe, buffer, _IOFBF, 1024 ) ;
X        pid = pib->pib_ulpid ;
X        fwrite( &pid, 1, 4, PM_pipe ) ;
X        fflush( PM_pipe ) ;
X        }
X    }
X
XPM_reset() {
X        putc( GR_RESET, PM_pipe); 
X        fflush(PM_pipe);
X        }
X
XPM_text() 
X    {
X    if( PM_mode != SET_TEXT ) { 
X        putc( SET_TEXT, PM_pipe); 
X        fflush(PM_pipe);
X        }
X    PM_mode = SET_TEXT ;
X    }
X
XPM_graphics() 
X    { 
X    putc( SET_GRAPHICS, PM_pipe); 
X    PM_mode = SET_GRAPHICS ;
X    }
X
XPM_move(unsigned int x, unsigned int y) 
X    { 
X    putc( GR_MOVE, PM_pipe ) ;
X    fwrite( &x, sizeof(int), 1, PM_pipe ) ;
X    fwrite( &y, sizeof(int), 1, PM_pipe ) ;
X    }
X
XPM_vector(unsigned int x, unsigned int y)
X    { 
X    putc( GR_DRAW, PM_pipe ) ;
X    fwrite( &x, sizeof(int), 1, PM_pipe ) ;
X    fwrite( &y, sizeof(int), 1, PM_pipe ) ;
X    }
X
XPM_linetype(int lt)
X    { 
X    putc( SET_LINE, PM_pipe ) ;
X    fwrite( &lt, sizeof(int), 1, PM_pipe ) ;
X    }
X
XPM_text_angle( int ta)
X    { 
X    putc( SET_ANGLE, PM_pipe ) ;
X    fwrite( &ta, sizeof(int), 1, PM_pipe ) ;
X    return(TRUE) ; 
X    }
X
XPM_put_text(unsigned int x, unsigned int y, char *str) 
X    {
X    int len ;
X    putc( GR_TEXT, PM_pipe ) ;
X    fwrite( &x, sizeof(int), 1, PM_pipe ) ;
X    fwrite( &y, sizeof(int), 1, PM_pipe ) ;
X    len = strlen( str ) + 1 ;
X    fwrite( &len, sizeof(int), 1, PM_pipe ) ;
X    fwrite( str, 1, len, PM_pipe ) ;
X    for( len=sizeof(int)-len%sizeof(int); len > 0 ; len-- )  /* pad rest of int with zeros */
X        putc( '\0', PM_pipe ) ;
X    }
X
XPM_justify_text( enum JUSTIFY mode ) 
X    {
X    putc( SET_JUSTIFY, PM_pipe ) ;
X    fwrite( &mode, sizeof(int), 1, PM_pipe ) ;
X    return(TRUE);
X    }
X
XPM_point( int x, int y, int number )
X/*
X** tell the driver we are plotting a point so it can decide whether to
X** use colour or not
X*/
X    {
X    int mode ;
X    mode=1 ;
X    putc( SET_POINTMODE, PM_pipe ) ;
X    fwrite( &mode, sizeof(int), 1, PM_pipe ) ;
X    do_point( x, y, number ) ;
X    mode = 0 ;
X    putc( SET_POINTMODE, PM_pipe ) ;
X    fwrite( &mode, sizeof(int), 1, PM_pipe ) ;
X    }
X
XPM_pause( char *str )
X/*
X** pause - using message box on PM screen
X*/
X    {
X    int len, cbR, rc ;
X    unsigned long ul ;
X    char buf[256] ;
X    char *bp ;
X
X    if( PM_pipe == NULL ) return 2 ;
X    bp=buf ;
X    putc( GR_PAUSE, PM_pipe ) ;
X    len = strlen( str ) + 1 ;
X    fwrite( &len, sizeof(int), 1, PM_pipe ) ;
X    fwrite( str, 1, len, PM_pipe ) ;
X    for( rc=sizeof(int)-len%sizeof(int); rc > 0 ; rc-- )  /* pad rest of int with zeros */
X        putc( '\0', PM_pipe ) ;
X    fflush(PM_pipe ) ;
X    rc=DosRead( fileno(PM_pipe), &len, sizeof(int), &cbR ) ;
X    return len ;
X    }
END_OF_FILE
  if test 7141 -ne `wc -c <'gnuplot/term/pm.trm'`; then
    echo shar: \"'gnuplot/term/pm.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/pm.trm'
fi
if test -f 'gnuplot/term/tek.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/tek.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/tek.trm'\" \(6797 characters\)
  sed "s/^X//" >'gnuplot/term/tek.trm' <<'END_OF_FILE'
X/*
X * $Id: tek.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - tek.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  tek40xx, bitgraph, kermit_color_tek40xx, kermit_mono_tek40xx, selanar
X *  ln03plus
X *
X * AUTHORS
X *   Colin Kelley, Thomas Williams, Russell Lang
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X#ifdef TEK
X
X#define TEK40XMAX 1024
X#define TEK40YMAX 780
X
X#define TEK40XLAST (TEK40XMAX - 1)
X#define TEK40YLAST (TEK40YMAX - 1)
X
X#define TEK40VCHAR		25
X#define TEK40HCHAR		14
X#define TEK40VTIC		11
X#define TEK40HTIC		11	
X
X#define HX 0x20		/* bit pattern to OR over 5-bit data */
X#define HY 0x20
X#define LX 0x40
X#define LY 0x60
X
X#define LOWER5 31
X#define UPPER5 (31<<5)
X
X
XTEK40init()
X{
X}
X
X
XTEK40graphics()
X{
X#ifdef vms
X	term_pasthru();
X#endif /* vms */
X	fprintf(outfile,"\033\014");
X/*                   1
X	1. clear screen
X*/
X	(void) fflush(outfile);
X	sleep(1);  
X	/* sleep 1 second to allow screen time to clear on real 
X	   tektronix terminals */
X}
X
XTEK40text()
X{
X	TEK40move(0,12);
X	fprintf(outfile,"\037");
X/*                   1
X	1. into alphanumerics
X*/
X#ifdef vms
X	term_nopasthru();
X#endif /* vms */
X}
X
X
XTEK40linetype(linetype)
Xint linetype;
X{
X}
X
XTEK40move(x,y)
Xunsigned int x,y;
X{
X	(void) putc('\035', outfile);	/* into graphics */
X	TEK40vector(x,y);
X}
X
X
XTEK40vector(x,y)
Xunsigned int x,y;
X{
X	(void) putc((HY | (y & UPPER5)>>5), outfile);
X	(void) putc((LY | (y & LOWER5)), outfile);
X	(void) putc((HX | (x & UPPER5)>>5), outfile);
X	(void) putc((LX | (x & LOWER5)), outfile);
X}
X
X
XTEK40put_text(x,y,str)
Xunsigned int x,y;
Xchar str[];
X{
X	TEK40move(x,y-11);
X	fprintf(outfile,"\037%s\n",str);
X}
X
X
XTEK40reset()
X{
X}
X
X#endif /* TEK */
X
X
X
X/* thanks to dukecdu!evs (Ed Simpson) for the BBN BitGraph driver */
X
X#ifdef BITGRAPH
X
X#define BG_XMAX			 	768 /* width of plot area */
X#define BG_YMAX			 	768 /* height of plot area */
X#define BG_SCREEN_HEIGHT	1024 /* full screen height */
X
X#define BG_XLAST	 (BG_XMAX - 1)
X#define BG_YLAST	 (BG_YMAX - 1)
X
X#define BG_VCHAR	16
X#define BG_HCHAR	 9
X#define BG_VTIC		 8
X#define BG_HTIC		 8	
X
X
X#define BG_init TEK40init
X
X#define BG_graphics TEK40graphics
X
X
X#define BG_linetype TEK40linetype
X
X#define BG_move TEK40move
X
X#define BG_vector TEK40vector
X
X
XBG_text()
X{
X	BG_move(0, BG_SCREEN_HEIGHT - 2 * BG_VCHAR);
X	fprintf(outfile,"\037");
X/*                   1
X	1. into alphanumerics
X*/
X}
X
X
XBG_put_text(x,y,str)
Xunsigned int x,y;
Xchar str[];
X{
X	BG_move(x,y-11);
X	fprintf(outfile,"\037%s\n",str);
X}
X
X
X#define BG_reset TEK40reset
X
X#endif /* BITGRAPH */
X
X
X/* Color and Monochrome specials for the MS-DOS Kermit Tektronix Emulator
X   by Russell Lang,  eln272v@monu1.cc.monash.oz  */
X
X#ifdef KERMIT
X
X#define KTEK40HCHAR		13
X
XKTEK40graphics()
X{
X#ifdef vms
X        term_mode_tek();
X	term_pasthru();
X#endif /* vms */
X	fprintf(outfile,"\033\014");
X/*                   1
X	1. clear screen
X*/
X	/* kermit tektronix emulation doesn't need to wait */
X}
X
XKTEK40Ctext()
X{
X	TEK40text();
X	KTEK40Clinetype(0);  /* change to green */
X#ifdef vms
X	term_nopasthru();
X#endif /* vms */
X}
X
X/* special color linetypes for MS-DOS Kermit v2.31 tektronix emulator */
X/*	0 = normal, 1 = bright 
X	foreground color (30-37) = 30 + colors
X		where colors are   1=red, 2=green, 4=blue */
Xstatic char *kermit_color[15]= {"\033[0;37m","\033[1;30m",
X		"\033[0;32m","\033[0;36m","\033[0;31m","\033[0;35m",
X		"\033[1;34m","\033[1;33m","\033[1;31m","\033[1;37m",
X		"\033[1;35m","\033[1;32m","\033[1;36m","\033[0;34m",
X		"\033[0;33m"};
X
XKTEK40Clinetype(linetype)
Xint linetype;
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	fprintf(outfile,"%s",kermit_color[linetype+2]);
X}
X
X
X/* linetypes for MS-DOS Kermit v2.30 tektronix emulator */
X/* `=solid, a=fine dots, b=short dashes, c=dash dot, 
X   d=long dash dot, e=dash dot dot */
Xstatic char *kerm_linetype = "`a`abcde" ;
X
XKTEK40Mlinetype(linetype)
Xint linetype;
X{
X	if (linetype >= 6)
X		linetype %= 6;
X	fprintf(outfile,"\033%c",kerm_linetype[linetype+2]);
X}
X
XKTEK40reset()
X{
X	fprintf(outfile,"\030\n");  /* turn off Tek emulation */
X#ifdef vms
X	term_mode_native();
X#endif /* vms */
X}
X
X#endif /* KERMIT */
X
X
X/* thanks to sask!macphed (Geoff Coleman and Ian Macphedran) for the
X   Selanar driver */
X
X#ifdef SELANAR
X
XSEL_init()
X{
X	fprintf(outfile,"\033\062");
X/*					1
X	1. set to ansi mode
X*/
X}
X
X
XSEL_graphics()
X{
X	fprintf(outfile,"\033[H\033[J\033\061\033\014");
X/*                   1           2       3
X	1. clear ANSI screen
X	2. set to TEK mode
X	3. clear screen
X*/
X}
X
X
XSEL_text()
X{
X	TEK40move(0,12);
X	fprintf(outfile,"\033\062");
X/*                   1
X	1. into ANSI mode
X*/
X}
X
XSEL_reset()
X{
X	fprintf(outfile,"\033\061\033\012\033\062\033[H\033[J");
X/*                   1        2       3      4
X1       set tek mode
X2       clear screen
X3       set ansi mode
X4       clear screen
X*/
X}
X#endif /* SELANAR */
X
X#ifdef VTTEK
X
XVTTEK40init()
X{
X        fprintf(outfile,"\033[?38h");
X        fflush(outfile);
X        sleep(1);
X        /* sleep 1 second to allow screen time to clear on some terminals */
X#ifdef vms
X        term_mode_tek();
X#endif /* vms */
X}
X
XVTTEK40reset()
X{
X        fprintf(outfile,"\033[?38l");
X        fflush(outfile);
X        sleep(1);
X        /* sleep 1 second to allow screen time to clear on some terminals */
X#ifdef vms
X        term_mode_native();
X#endif /* vms */
X}
X
X/* linetypes for VT-type terminals in tektronix emulator mode */
X/* `=solid, a=fine dots, b=short dashes, c=dash dot,
X   d=long dash dot, h=bold solid, i=bold fine dots, j=bold short dashes,
X   k=bold dash dot, l=bold long dash dot */
Xstatic char *vt_linetype = "`a`abcdhijkl" ;
Xstatic int last_vt_linetype = 0;
XVTTEK40linetype(linetype)
Xint linetype;
X{
X        if (linetype >= 10)
X                linetype %= 10;
X        fprintf(outfile,"\033%c",vt_linetype[linetype+2]);
X        last_vt_linetype = linetype;
X}
X
XVTTEK40put_text(x,y,str)
Xunsigned int x,y;
Xchar str[];
X{
X        int linetype;
X        linetype = last_vt_linetype;
X        VTTEK40linetype(0);
X        TEK40put_text(x,y,str);
X        VTTEK40linetype(linetype);
X}
X
X#endif /* VTTEK */
X
X#ifdef LN03P
X
XLN03Pinit()
X{
X	fprintf(outfile,"\033[?38h");
X}
X
XLN03Preset()
X{
X	fprintf(outfile,"\033[?38l");
X}
X#endif /* LN03P */
END_OF_FILE
  if test 6797 -ne `wc -c <'gnuplot/term/tek.trm'`; then
    echo shar: \"'gnuplot/term/tek.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/tek.trm'
fi
if test -f 'gnuplot/term/texdraw.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/texdraw.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/texdraw.trm'\" \(7694 characters\)
  sed "s/^X//" >'gnuplot/term/texdraw.trm' <<'END_OF_FILE'
X/*
X * $Id: texdraw.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - texdraw.trm */
X/*
X * Copyright (C) 1990
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *   The TEXDRAW macros for LaTeX.
X *
X * AUTHORS
X *   Khun Yee Fung. Modified from eepic.trm.
X *   clipper@csd.uwo.ca
X *   January 20, 1992
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X/*
X *  This file contains the texdraw terminal driver, intended for use with the
X *  texdraw macro package for LaTeX. This is an alternative to the
X *  latex driver. You need texdraw.sty, and texdraw.tex in the texdraw package.
X *
X */
X
X#define TEXDRAW_PTS_PER_INCH (72.27)
X#define DOTS_PER_INCH (300)	/* resolution of printer we expect to use */
X#define TEXDRAW_UNIT (TEXDRAW_PTS_PER_INCH/DOTS_PER_INCH) /* dot size in pt */
X
X/* 5 inches wide by 3 inches high (default) */
X#define TEXDRAW_XMAX (5*DOTS_PER_INCH)
X#define TEXDRAW_YMAX (3*DOTS_PER_INCH)
X
X#define TEXDRAW_HTIC (5*DOTS_PER_INCH/72)	/* (5./TEXDRAW_UNIT) */
X#define TEXDRAW_VTIC (5*DOTS_PER_INCH/72)	/* (5./TEXDRAW_UNIT) */
X#define TEXDRAW_HCHAR (DOTS_PER_INCH*53/10/72)	/* (5.3/TEXDRAW_UNIT) */
X#define TEXDRAW_VCHAR (DOTS_PER_INCH*11/72)	/* (11./TEXDRAW_UNIT) */
X
Xstatic unsigned int TEXDRAW_posx;
Xstatic unsigned int TEXDRAW_posy;
Xenum JUSTIFY TEXDRAW_justify = LEFT;
Xenum JUSTIFY TEXDRAW_last_justify = LEFT;
Xstatic int TEXDRAW_angle = 0;
Xstatic float TEXDRAW_scalefactor = 0.2409;
Xstatic double TEXDRAW_xscale = 1.0, TEXDRAW_yscale = 1.0;
X
X/* for DOTS point style */
X#define TEXDRAW_TINY_DOT "\\htext{$\\cdot$}"
X
X/* POINTS */
X#define TEXDRAW_POINT_TYPES 12	/* we supply more point types */
Xstatic char GPFAR * GPFAR TEXDRAW_points[] =
X{
X  "\\rmove(0 4)\\htext{$\\Diamond$}",
X  "\\htext{$+$}",
X  "\\rmove(0 4)\\htext{$\\Box$}",
X  "\\htext{$\\times$}",
X  "\\htext{$\\triangle$}",
X  "\\htext{$\\star$}",
X  "\\lcir f:9",
X  "\\lcir f:12",
X  "\\lcir f:16",
X  "\\fcir f:0.9 r:9",
X  "\\fcir f:0.9 r:12",
X  "\\fcir f:0.9 r:16"
X};
X
X/* LINES */
X#define TEXDRAW_NUMLINES 5	/* number of linetypes below */
Xstatic int TEXDRAW_lines[] =
X{
X  4,		/* -2 border */
X  3,		/* -1 axes */
X  3,		/*  0 solid thin  */
X  4,		/*  1 solid thick */
X  6,		/*  2 solid Thick */
X};
X
Xstatic int TEXDRAW_last_type = 0; /* The line type selected most recently */
Xstatic int TEXDRAW_type;	/* current line type */
Xstatic TBOOLEAN TEXDRAW_inline = FALSE;	/* are we in the middle of a line */
Xstatic void TEXDRAW_endline();	/* terminate any line in progress */
Xstatic int TEXDRAW_linecount = 0;	/* number of points in line so far */
X#define TEXDRAW_LINEMAX 5	/* max value for linecount */
X
XTEXDRAW_init()
X{
X  TEXDRAW_posx = TEXDRAW_posy = 0;
X  TEXDRAW_linetype(-1);
X  fprintf(outfile, "%% GNUPLOT: LaTeX using TEXDRAW macros\n");
X}
X
X
XTEXDRAW_scale(xs, ys)
Xdouble xs, ys;			/* scaling factors */
X{
X  register struct termentry *t = &term_tbl[term];
X
X  /* we change the table for use in graphics.c */
X  t->xmax = (unsigned int) (TEXDRAW_XMAX * xs);
X  t->ymax = (unsigned int) (TEXDRAW_YMAX * ys);
X
X  TEXDRAW_xscale = xs;
X  TEXDRAW_yscale = ys;
X
X  return (TRUE);
X}
X
XTEXDRAW_graphics()
X{
Xstatic char GPFAR tdg1[] = "\
X\\begin{texdraw}\n\
X\\normalsize\n\
X\\ifx\\pathDEFINED\\relax\\else\\let\\pathDEFINED\\relax\n\
X \\def\\QtGfr{\\ifx (\\TGre \\let\\YhetT\\cpath\\else\\let\\YhetT\\relax\\fi\\YhetT}\n\
X \\def\\path (#1 #2){\\move (#1 #2)\\futurelet\\TGre\\QtGfr}\n\
X \\def\\cpath (#1 #2){\\lvec (#1 #2)\\futurelet\\TGre\\QtGfr}\n\
X\\fi\n\
X\\drawdim pt\n\
X\\setunitscale %2.2f\n\
X\\linewd %d\n\
X\\textref h:L v:C\n";
X  fprintf(outfile, tdg1, 
X	TEXDRAW_scalefactor,
X	TEXDRAW_lines[2]);
X  TEXDRAW_last_type = 0;
X  TEXDRAW_type = 0;
X}
X
X
XTEXDRAW_text()
X{
X  TEXDRAW_endline();
X  fprintf(outfile, "\\end{texdraw}\n");
X}
X
X
XTEXDRAW_linetype(linetype)
Xint linetype;
X{
X  TEXDRAW_endline();
X
X  if (linetype >= TEXDRAW_NUMLINES - 2)
X    linetype %= (TEXDRAW_NUMLINES - 2);
X
X  TEXDRAW_type = linetype;
X}
X
X
XTEXDRAW_move(x, y)
Xunsigned int x, y;
X{
X  TEXDRAW_endline();
X
X  TEXDRAW_posx = x;
X  TEXDRAW_posy = y;
X}
X
X
XTEXDRAW_point(x, y, number)
Xunsigned int x, y;
Xint number;
X{
X  TEXDRAW_move(x, y);
X
X  /* Print the character defined by 'number'; number < 0 means
X        to use a dot, otherwise one of the defined points. */
X  fprintf(outfile, "\\move (%d %d)\n",
X	  (int)((double) x * TEXDRAW_xscale),
X	  (int)((double) y * TEXDRAW_yscale));
X  if (TEXDRAW_last_justify != CENTRE) {
X    fprintf(outfile, "\\textref h:C v:C ");
X    TEXDRAW_last_justify = CENTRE;
X  }
X  fprintf(outfile, "%s\n",
X	  (number < 0 ?
X	   TEXDRAW_TINY_DOT :
X	   TEXDRAW_points[number % TEXDRAW_POINT_TYPES]));
X}
X
X
XTEXDRAW_vector(ux, uy)
Xunsigned int ux, uy;
X{
X  if (!TEXDRAW_inline) {
X    TEXDRAW_inline = TRUE;
X
X    /* Start a new line. This depends on line type */
X    if (TEXDRAW_type != TEXDRAW_last_type){
X      if (TEXDRAW_lines[TEXDRAW_type+2] != TEXDRAW_lines[TEXDRAW_last_type+2])
X	fprintf(outfile, "\\linewd %d\n", TEXDRAW_lines[TEXDRAW_type + 2]);
X      TEXDRAW_last_type = TEXDRAW_type;
X    }
X    fprintf(outfile, "\\path (%d %d)",
X	    (int)((double) TEXDRAW_posx * TEXDRAW_xscale),
X	    (int)((double) TEXDRAW_posy * TEXDRAW_yscale));
X    TEXDRAW_linecount = 1;
X  }
X  else {
X    /* Even though we are in middle of a path,
X     * we may want to start a new path command.
X     * If they are too long then latex will choke.
X     */
X    if (TEXDRAW_linecount++ >= TEXDRAW_LINEMAX) {
X      fprintf(outfile, "\n\\cpath ");
X      TEXDRAW_linecount = 1;
X    }
X  }
X  fprintf(outfile, "(%d %d)",
X	  (int)((double) ux * TEXDRAW_xscale),
X	  (int)((double) uy * TEXDRAW_yscale));
X  TEXDRAW_posx = ux;
X  TEXDRAW_posy = uy;
X}
X
Xstatic void TEXDRAW_endline()
X{
X  if (TEXDRAW_inline) {
X    fprintf(outfile, "\n");
X    TEXDRAW_inline = FALSE;
X  }
X}
X
X
XTEXDRAW_arrow(sx, sy, ex, ey, head)
Xint sx, sy, ex, ey;
XTBOOLEAN head;
X{
X  char text;
X
X  if (head)
X    text = 'a';
X  else
X    text = 'l';
X  fprintf(outfile, "\\move (%d %d)\\%cvec (%d %d)",
X	  (int)((double) sx * TEXDRAW_xscale),
X	  (int)((double) sy * TEXDRAW_yscale),
X	  text,
X	  (int)((double) ex * TEXDRAW_xscale),
X	  (int)((double) ey * TEXDRAW_yscale));
X  TEXDRAW_posx = ex;
X  TEXDRAW_posy = ey;
X}
X
X
XTEXDRAW_put_text(x, y, str)
Xint x, y;			/* reference point of string */
Xchar str[];			/* the text */
X{
X  char text;
X
X  TEXDRAW_endline();
X
X  fprintf(outfile, "\\move (%d %d)",
X	  (int)((double) x * TEXDRAW_xscale),
X	  (int)((double) y * TEXDRAW_yscale));
X
X  if (!TEXDRAW_angle)
X    text = 'h';
X  else
X    text = 'v';
X
X  if (TEXDRAW_last_justify != TEXDRAW_justify) {
X    TEXDRAW_last_justify = TEXDRAW_justify;
X    if (TEXDRAW_justify == LEFT)
X      fprintf(outfile, "\\textref h:L v:C ");
X    else if (TEXDRAW_justify == CENTRE)
X      fprintf(outfile, "\\textref h:C v:C ");
X    else if (TEXDRAW_justify == RIGHT)
X      fprintf(outfile, "\\textref h:R v:C ");
X  }
X  fprintf(outfile, "\\%ctext{%s}\n", text, str);
X}
X
X
Xint TEXDRAW_justify_text(mode)
Xenum JUSTIFY mode;
X{
X  TEXDRAW_justify = mode;
X  return (TRUE);
X}
X
Xint TEXDRAW_text_angle(angle)
Xint angle;
X{
X  TEXDRAW_angle = angle;
X  return (TRUE);
X}
X
XTEXDRAW_reset()
X{
X  TEXDRAW_endline();
X  TEXDRAW_posx = TEXDRAW_posy = 0;
X}
END_OF_FILE
  if test 7694 -ne `wc -c <'gnuplot/term/texdraw.trm'`; then
    echo shar: \"'gnuplot/term/texdraw.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/texdraw.trm'
fi
echo shar: End of archive 26 \(of 33\).
cp /dev/null ark26isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
