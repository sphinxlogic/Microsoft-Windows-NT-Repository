Newsgroups: comp.sources.misc
From: woo@playfair.stanford.edu ("Alexander Woo")
Subject: v40i041:  gnuplot - interactive function plotting utility, Part29/33
Message-ID: <1993Oct25.030433.2748@sparky.sterling.com>
X-Md4-Signature: c8c49411d30f19cf65d0bf96fa2aa418
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 25 Oct 1993 03:04:33 GMT
Approved: kent@sparky.sterling.com

Submitted-by: woo@playfair.stanford.edu ("Alexander Woo")
Posting-number: Volume 40, Issue 41
Archive-name: gnuplot/part29
Environment: UNIX, MS-DOS, VMS
Supersedes: gnuplot3: Volume 24, Issue 23-48

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  gnuplot/README.3p4 gnuplot/README.mf
#   gnuplot/demo/airfoil.dem gnuplot/demo/singulr.dem
#   gnuplot/docs/lasergnu.1 gnuplot/docs/makefile gnuplot/eval.c
#   gnuplot/gnubin.c gnuplot/lasergnu gnuplot/makefile.286
#   gnuplot/os2/gnupmdrv.h gnuplot/term/cgi.trm
#   gnuplot/term/emxvga.trm gnuplot/term/gnugraph.trm
#   gnuplot/term/gpic.trm gnuplot/term/t410x.trm
# Wrapped by kent@sparky on Wed Oct 20 17:15:04 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 29 (of 33)."'
if test -f 'gnuplot/README.3p4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/README.3p4'\"
else
  echo shar: Extracting \"'gnuplot/README.3p4'\" \(5153 characters\)
  sed "s/^X//" >'gnuplot/README.3p4' <<'END_OF_FILE'
XThis version of gnuplot represents the work of many people.  For a more
Xcomplete list read the RCS log on the top of makefile.unx.  This version
Xoriginally was centered on Jos Van Woude's probability functions,
XDon Tabor's discrete contour levels and Rob Cunningham's binary file
XIO capability.  It has grown tremendously.  Russell Lang and Maurice
XCastro added MS-Windows capability and much more.  Roger Fearick
Xadded OS/2 capabilility.  Alexander Lehmann and Hans-Edgar Koechling
Xgreatly improved Atari support. (There are also an OS-9 and PC-9801 versions
Xof 3.2 and a Mac version of 3.0 and a multiple plot on a page mod
Xwhich were not integrated into this release.)  Eric Youngdale replaced the
Xexplicit function hidden line removal routines with a more general
Ximplicit bitmap (which requires more memory).  Gershon Elber fixed
Xmany 3D bugs and added the "dgrid3d" option which takes allows
Xscattered data to be contoured.  Ed Kubaitis reworked the X11 support.
XIn addition, many more devices are now provided.  We have
Xalways added device drivers because we have no way to debug most of
Xthem and only by including them into the package we obtain feedback.
X
XIn addition, we have begun a contrib subdirectory which contains
Xexternal library, programs, and mods which help in the use of
XGnuplot.  Many of the diffs are now out of date and will take
Xsome work to implement.
X
XThese contributions are not in any particular order.
X
X* Subject: Special Functions for Probability Densities
X  Name: Jos van der Woude
X  Email: jvdwoude@hut.nl
X
X* Subject: Discrete Contour Levels
X  Name: Don Taber
X  Email: news@solitary.stanford.edu,dbt@victoria.risc.rockwell.com
X
X* Subject: LN03p (Graphic Enhance Mode) Driver and REGIS fixes
X  Name: Hung-chi Lihn
X  Email: lihn@ssrl01.slac.stanford.edu
X
X* Subject: LESS-like additions to READLINE capability
X  Name:    Michal Tomczak, Tom Tkacik
X  Email: ntomczak@vm.ucs.ualberta.ca,tkacik@hobbes.cs.gmr.com
X
X* Subject: doc2texinfo : Converts Gnuplot .doc files to Texinfo format.
X  Name: George Ferguson
X  Email: ferguson@cs.rochester.edu
X
X* Subject: Atari ST (gcc 1.40) version  and PureC version
X  Name: Alexander Lehmann, Hans-Edgar Koechling
X  Email: alexlehm@iti.informatik.th-darmstadt.de,
X        koechling@nvdv.e-technik.uni-stuttgart.dpe.de
X
X* Subject: ISO 8869/1 character sets
X  Name: Marius Olafsson
X  Email: marius@rhi.hi.is
X
X* Subject: HP PaintJet Driver
X  Name: Dan Merget
X  Email: danm@hpnmdlc0.sr.hp.com
X
X* Subject: Improvements to HP PCL driver
X  Name: Timothy Collins, Tom Swiler, Alex Woo
X  Email: kaph6@solx1.central.susx.ac.uk,tom@silica.mse.ufl.edu
X
X* Subject: plot "file" thru f(x) for transforming datafiles
X  Name: Jack Veenstra
X  Email: veenstra@cs.rochester.edu
X
X* Subject: improvement to HPGL driver
X  Name: Craig Johnston
X  Email: johnston@maxwell.ee.washington.edu
X
X* Subject: X11 mods
X  Name: Ed Kubaitis, Yehavi Bourvine
X  Email: ejk@ux2.ncsa.uiuc.edu, YEHAVI@vms.huji.ac.il
X
X* Subject: Binary File IO
X  Name: Rob Cunningham, Jos van der Woude
X  Email: rkc@xn.ll.mit.edu,jvdwoude@hut.nl
X
X* Subject: Improved Hidden Line Removal & LITE flag
X  Name: Eric Youngdale
X  Email: eric@tantalus.nrl.navy.mil
X
X* Subject: xlib driver & test programs in contrib
X  Name: Gregg Hanna
X  Email: gregor@kafka.saic.com
X
X* Subject: MS-Windows, boxes and boxerror styles, plot using accepts
X           columns in any order, plus many, many improvements
X  Name: Russell Lang, Maurice Castro
X  Email: rjl@monu1.cc.monash.edu.au, maurice@bruce.cs.monash.edu.au
X
X* Subject: OS/2 version
X  Name: Roger Fearick
X  Email: fearick@physci.uct.ac.za
X
X* Subject: scatter to grid mods "set dgrid3d", plus fixes
X  Name: Gershon Elber scatter to grid mods
X  Email: gershon@cs.utah.edu
X
X* Subject: Notitle option to remove entry in key
X  Name: R. Shouman
X  Email: rshouman@hermes.chpc.utexas.edu
X
X* Subject: Misc. Bug Fixes, new get_data, many improvements
X  Name: Daniel S. Lewart
X  Email: d-lewart@uiuc.edu
X
X
X* Subject: H Olav Eggestad RGIP Uniplex driver (POSIX) and Imagen driver
X  Name: Hans Olav Eggestad
X  Email: olav@jordforsk.nlh.no
X
X* Subject: New plotstyle "steps" for discrete functions
X  Name: John Grosh
X  Email: jgrosh@brl.mil
X
X
X* Subject: CorelDraw! driver (subset of EPS)
X  Name: Chris Parks
X  Email: parks@physics.purdue.edu
X
X* Subject: PSTRICKS  driver (for TeX)
X  Name: Ray Toy
X  Email: toy@soho.crd.ge.com
X
X* Subject: Framemaker MIF 3.0 driver
X  Name: Olof Franksson
X  Email: olof@ikaros.fysik4.kth.se
X
X* Subject: Apollo mods
X  Name:  Jim Richardson
X  Email: jimr@maths.su.oz.au
X
X* Subject: TGIF driver
X  Name: Neal Holtz
X  Email: nholtz@civeng.carleton.ca
X
X* Subject: TPIC specials driver (TeX)
X  Name: Honoo Suzuki
X  Email: honoo@nc.titech.ac.jp
X
X* Subject: Log to any base capability
X  Name: Lawrence Crowl
X  Email: crowl@cs.orst.edu
X
X* Subject: Talaris EXCL driver
X  Name: P. Klosowski
X  Email: przemek@rrdstrad.nist.gov
X
X* Subject: New LaTeX Driver
X  Name: Xiaoguang Zhang
X  Email: zhang@whbws.ms.ornl.gov
X
X* Subject: TeXdraw driver (eepic derivative)
X  Name: Khun Yee Fung
X  Email: clipper@csd.uwo.ca
X
X* Subject: debug and hp2623a driver, fixes
X  Name: Bruce Lueckenoff
X  Email: luecken@udel.edu
END_OF_FILE
  if test 5153 -ne `wc -c <'gnuplot/README.3p4'`; then
    echo shar: \"'gnuplot/README.3p4'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/README.3p4'
fi
if test -f 'gnuplot/README.mf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/README.mf'\"
else
  echo shar: Extracting \"'gnuplot/README.mf'\" \(4322 characters\)
  sed "s/^X//" >'gnuplot/README.mf' <<'END_OF_FILE'
XMetaFont Terminal Driver for GnuPlot (MF.TRM):
X----------------------------------------------
XThe new terminal driver creates a input file to the MetaFont program.
XThus a figure may be used in the TeX document in the same way as a
Xcharacter is.
X
XTo use the plot in a document the MetaFont program must be run
Xwith the output file from GnuPlot as input. Thus, the user needs a basic
Xknowledge of the font creating prosess and inclusion of a new font in a
Xdocument. However, if the Metafont program are set up properly at the
Xlocal site an unexperienced user could perform the operation without
Xmuch trouble.
X
XThe text support is based on a MetaFont character set.
XCurrently the Computer Modern Roman font set is input but the
Xuser are in principal free to chose whatever fonts he/she needs.
XThe MetaFont source files for the chosen font must be available.
XEach character is stored in a separate picture variable in MetaFont. These
Xvariables may be manipulated (rotated, scaled etc.) when characters are
Xneeded. The drawback is the interpretation time in the MetaFont
Xprogram. On some machines (i.e. PC) the limited amount of memory available
Xmay also cause problem if too many pictures are stored.
X
XThe MetaFont terminal driver MF.TRM is UENCODED and included in this mail.
XAlso the "diff" files between an orginal TERM.C and mine are
XUENCODED included. I am afraid there may be several
Xdifferences which are not due to the MetaFont terminal. However, the new
Xterminal driver should be included in exactly the same manner as the other.
X
XIn TERM.H the only necessary change is :
X
X               #define MF
X
XPlease inform me if something  goes wrong. I will then transfer the code
Xto an anonymous FTP cite where you can pick it up.
X
XTo use the MetaFont terminal driver:
X------------------------------------
X1) In GnuPlot use:   set terminal mf
X                     set output "myfile.mf"
X                          .
X                          .
X                          .
X                     plot ....
X                     exit
X
X
X2) Run MetaFont. Syntax is site dependant:
X
X   On my UNIX I use:   cmmf '\mode=localfont; \mag=1;' input myfile.mf
X   On my PC I use:     mf286 &cm \mode=localfont; \mag=1; input myfile.mf
X
X   Be aware that MetaFont can only handle number less than 4096. Thus if you
X
X   have very high resolution in your localfont and a large picture you will
X   probably get an error message when running metaFont. To solve the
Xproblem,
X   reduce the resolution or the plot size.
X
X3) Run GfToPk, syntax is
X
X   on my UNIX:   gftpk myfile.xxxgf myfile.pk
X   on my PC:     gftpk myfile.xxx myfile.pk
X
X   where xxx is the resolution (typically 300).
X
X   The version of GfToPk included with unix TeX3.14 probably needs to be
X   compiled with more memory than it is. Third line in GFTOPK.C declares
X   a variable "maxrow". Defining this to 32000 should be sufficient.
X
X4) Copy the files myfile.pk and myfile.tfm to a place where you are sure TeX
X   and the dvi processing programs you use  can find them. (They can
Xprobably
X   be located in your current working directory)
X
X5) Include in your TeX document the following statement:
X
X      \font\myfont=myfile  % Declares the new font you just have made
X      {\myfont\char0}      % Typeset character with code zero which
X                           % MF.TRM uses as default character
X
X
X
X
X
XHPGL to GnuPlot converter (HPG2GNU):
X-------------------------------------
XI have also written a program which interprets files written in
XHewlett Packard's plotter language, HPGL, and outputs the graphic
Xon an available GnuPlot terminal.
X
XPersonally, I have used the program as an link to the MetaFont terminal
X(the orginal version of the program only translated from HPGL to MF).
XThis way I am able to design pictures in my favorite graphic drawing
Xprogram,
Xexport the figures to HPGL files and translate to MetaFont. A lot of new
Xsymbols (fancy arrows, electronic components, process symbols etc. etc.)
Xcan thus be  made available to TeX as new font sets without the need to dig
Xinto the MetaFont manual.
X
XHowever, the program is now mainly based on code from the GnuPlot
Xprogram and according to the copyright notes should not be distributed.
X
X
XWith regard
X
XPaal Hedne
XSINTEF Multiphase Laboratory
XN-7034 Trondheim
XNorway
X
XTel.: -47-7-591060
XE.mail: Pal.Hedne@termo.unit.no
END_OF_FILE
  if test 4322 -ne `wc -c <'gnuplot/README.mf'`; then
    echo shar: \"'gnuplot/README.mf'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/README.mf'
fi
if test -f 'gnuplot/demo/airfoil.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/airfoil.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/airfoil.dem'\" \(4833 characters\)
  sed "s/^X//" >'gnuplot/demo/airfoil.dem' <<'END_OF_FILE'
X#
X# $Id: airfoil.dem%v 3.38.2.45 1993/01/11 04:09:41 woo Exp woo $
X#
X# This demo shows how to use bezier splines to define NACA four
X# series airfoils and complex variables to define Joukowski
X# Airfoils.  It will be expanded after overplotting in implemented
X# to plot Coefficient of Pressure as well.
X#		Alex Woo, Dec. 1992
X#
X# The definitions below follows: "Bezier presentation of airfoils",
X# by Wolfgang Boehm, Computer Aided Geometric Design 4 (1987) pp 17-22.
X#
X#				Gershon Elber, Nov. 1992
X#
X# m = percent camber
X# p = percent chord with maximum camber
Xpause 0  "NACA four series airfoils by bezier splines"
Xpause 0  "Will add pressure distribution later with Overplotting"
Xmm = 0.6
X# NACA6xxx
Xthick = 0.09  
X# nine percent  NACAxx09
Xpp = 0.4
X# NACAx4xx
X# Combined this implies NACA6409 airfoil
X#
X# Airfoil thickness function.
X#
Xset xlabel "NACA6409 -- 9% thick, 40% max camber, 6% camber"
Xx0 = 0.0
Xy0 = 0.0
Xx1 = 0.0
Xy1 = 0.18556
Xx2 = 0.03571
Xy2 = 0.34863
Xx3 = 0.10714
Xy3 = 0.48919
Xx4 = 0.21429 
Xy4 = 0.58214
Xx5 = 0.35714
Xy5 = 0.55724
Xx6 = 0.53571
Xy6 = 0.44992
Xx7 = 0.75000
Xy7 = 0.30281
Xx8 = 1.00000
Xy8 = 0.01050
X#
X# Directly defining the order 8 Bezier basis function for a faster evaluation.
X#
Xbez_d4_i0(x) =     (1 - x)**4
Xbez_d4_i1(x) = 4 * (1 - x)**3 * x
Xbez_d4_i2(x) = 6 * (1 - x)**2 * x**2
Xbez_d4_i3(x) = 4 * (1 - x)**1 * x**3
Xbez_d4_i4(x) =                  x**4
X
Xbez_d8_i0(x) =      (1 - x)**8
Xbez_d8_i1(x) =  8 * (1 - x)**7 * x
Xbez_d8_i2(x) = 28 * (1 - x)**6 * x**2
Xbez_d8_i3(x) = 56 * (1 - x)**5 * x**3
Xbez_d8_i4(x) = 70 * (1 - x)**4 * x**4
Xbez_d8_i5(x) = 56 * (1 - x)**3 * x**5
Xbez_d8_i6(x) = 28 * (1 - x)**2 * x**6
Xbez_d8_i7(x) =  8 * (1 - x)    * x**7
Xbez_d8_i8(x) =                   x**8
X
X
Xm0 = 0.0
Xm1 = 0.1
Xm2 = 0.1
Xm3 = 0.1
Xm4 = 0.0
Xmean_y(t) = m0 * mm * bez_d4_i0(t) + \
X	    m1 * mm * bez_d4_i1(t) + \
X	    m2 * mm * bez_d4_i2(t) + \
X	    m3 * mm * bez_d4_i3(t) + \
X	    m4 * mm * bez_d4_i4(t)
X
Xp0 = 0.0
Xp1 = pp / 2
Xp2 = pp
Xp3 = (pp + 1) / 2
Xp4 = 1.0
Xmean_x(t) = p0 * bez_d4_i0(t) + \
X	    p1 * bez_d4_i1(t) + \
X	    p2 * bez_d4_i2(t) + \
X	    p3 * bez_d4_i3(t) + \
X	    p4 * bez_d4_i4(t)
X
Xz_x(x) = x0 * bez_d8_i0(x) + x1 * bez_d8_i1(x) + x2 * bez_d8_i2(x) + \
X	 x3 * bez_d8_i3(x) + x4 * bez_d8_i4(x) + x5 * bez_d8_i5(x) + \
X	 x6 * bez_d8_i6(x) + x7 * bez_d8_i7(x) + x8 * bez_d8_i8(x)
X
Xz_y(x, tk) = \
X   y0 * tk * bez_d8_i0(x) + y1 * tk * bez_d8_i1(x) + y2 * tk * bez_d8_i2(x) + \
X   y3 * tk * bez_d8_i3(x) + y4 * tk * bez_d8_i4(x) + y5 * tk * bez_d8_i5(x) + \
X   y6 * tk * bez_d8_i6(x) + y7 * tk * bez_d8_i7(x) + y8 * tk * bez_d8_i8(x)
X
X#
X# Given t value between zero and one, the airfoild curve is defined as
X# 
X#			c(t) = mean(t1(t)) +/- z(t2(t)) n(t1(t)),
X#
X# where n is the unit normal to the mean line. See the above paper for more.
X#
X# Unfortunately, the parametrization of c(t) is not the same for mean(t1)
X# and z(t2). The mean line (and its normal) can assume linear function t1 = t,
X#                                                     -1
X# but the thickness z_y is, in fact, a function of z_x  (t). Since it is
X# not obvious how to compute this inverse function analytically, we instead
X# replace t in c(t) equation above by z_x(t) to get:
X# 
X#			c(z_x(t)) = mean(z_x(t)) +/- z(t) n(z_x(t)),
X#
X# and compute and display this instead. Note we also ignore n(t) and assumes
X# n(t) is constant in the y direction,
X#
X
Xairfoil_y1(t, thick) = mean_y(z_x(t)) + z_y(t, thick)
Xairfoil_y2(t, thick) = mean_y(z_x(t)) - z_y(t, thick)
Xairfoil_y(t) = mean_y(z_x(t))
Xairfoil_x(t) = mean_x(z_x(t))
Xset nogrid
Xset nozero
Xset parametric
Xset xrange [-0.1:1.1]
Xset yrange [-0.1:.7]
Xset trange [ 0.0:1.0]
Xset title "NACA6409 Airfoil"
Xplot airfoil_x(t), airfoil_y(t) title "mean line" w l 2, \
X     airfoil_x(t), airfoil_y1(t, thick) title "upper surface" w l 1, \
X     airfoil_x(t), airfoil_y2(t, thick) title "lower surface" w l 1
Xpause -1 "Press Return"
Xmm = 0.0
Xpp = .5
Xthick = .12
Xset title "NACA0012 Airfoil"
Xset xlabel "12% thick, no camber -- classical test case"
Xplot airfoil_x(t), airfoil_y(t) title "mean line" w l 2, \
X     airfoil_x(t), airfoil_y1(t, thick) title "upper surface" w l 1, \
X     airfoil_x(t), airfoil_y2(t, thick) title "lower surface" w l 1
Xpause -1 "Press Return"
Xset title ""
Xset xlab ""
Xset key
Xset parametric
Xset samples 100
Xset isosamples 10
Xset data style lines
Xset function style lines
Xpause 0  "Joukowski Airfoil using Complex Variables" 
Xset title "Joukowski Airfoil using Complex Variables" 0,0
Xset time
Xset yrange [-.2 : 1.8]
Xset trange [0: 2*pi]
Xset xrange [-.6:.6]
Xzeta(t) = -eps + (a+eps)*exp(t*{0,1})
Xeta(t) = zeta(t) + a*a/zeta(t)
Xeps = 0.06
Xa =.250
Xset xlabel "eps = 0.06 real"
Xplot real(eta(t)),imag(eta(t))
Xpause -1 "Press Return"
Xeps = 0.06*{1,-1}
Xset xlabel "eps = 0.06 + i0.06"
Xplot real(eta(t)),imag(eta(t))
Xpause -1 "Press Return"
Xset title ""
Xset xlabel ""
X
X
END_OF_FILE
  if test 4833 -ne `wc -c <'gnuplot/demo/airfoil.dem'`; then
    echo shar: \"'gnuplot/demo/airfoil.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/airfoil.dem'
fi
if test -f 'gnuplot/demo/singulr.dem' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/demo/singulr.dem'\"
else
  echo shar: Extracting \"'gnuplot/demo/singulr.dem'\" \(4183 characters\)
  sed "s/^X//" >'gnuplot/demo/singulr.dem' <<'END_OF_FILE'
X# $Id: singulr.dem%v 3.38.2.97 1993/03/16 15:07:24 woo Exp woo $
X#
X# Demo that plots some surfaces with singularities.
X# Author: Carsten Steger
X#
X# (x,y,x^2-y^2,2xy) is the graph of w=z^2 in 4-space.
X# Therefore (x^2-y^2,2xy,x,y) is the graph of w=sqrt(z) in 4-space.
X# Coordinates 1, 2, and 3 give the real part of either function,
X# whereas coordinates 1, 2, and 4 give the imaginary part.
X# The same holds for the cube function w=z^3. The graphs are given by
X# (x,y,x^3-3xy^2,3x^2y-y^3) and (x^3-3xy^2,3x^2y-y^3,x,y).
X# And so on...
X
X
Xset parametric
Xset hidden3d
Xset isosamples 21
Xset autoscale
X
X
Xset view 60,30
Xset urange [-3:3]
Xset vrange [-3:3]
Xset title "Real part of complex square root function"
Xsplot u**2-v**2,2*u*v,u
Xpause -1 "Hit return to continue (1)"
X
X
Xset view 60,210
Xset title "Real part of complex square root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (2)"
X
X
Xset view 60,120
Xset urange [-3:3]
Xset vrange [-3:3]
Xset title "Imaginary part of complex square root function"
Xsplot u**2-v**2,2*u*v,v
Xpause -1 "Hit return to continue (3)"
X
X
Xset view 60,300
Xset title "Imaginary part of complex square root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (4)"
X
X
Xset view 60,30
Xset urange [-3:3]
Xset vrange [-3:3]
Xset title "Real part of complex cube root function"
Xsplot u**3-3*u*v**2,3*u**2*v-v**3,u
Xpause -1 "Hit return to continue (5)"
X
X
Xset view 60,210
Xset title "Real part of complex cube root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (6)"
X
X
Xset view 60,30
Xset urange [-3:3]
Xset vrange [-3:3]
Xset title "Imaginary part of complex cube root function"
Xsplot u**3-3*u*v**2,3*u**2*v-v**3,v
Xpause -1 "Hit return to continue (7)"
X
X
Xset view 60,210
Xset title "Imaginary part of complex cube root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (8)" 
X
X
Xset view 60,30
Xset isosamples 31
Xset urange [-1:1]
Xset vrange [-1:1]
Xset title "Real part of complex 4th root function"
Xsplot u**4-6*u**2*v**2+v**4,4*u**3*v-4*u*v**3,u
Xpause -1 "Hit return to continue (9)"
X
X
Xset view 60,210
Xset title "Real part of complex 4th root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (10)"
X
X
Xset view 60,120
Xset urange [-1:1]
Xset vrange [-1:1]
Xset title "Imaginary part of complex 4th root function"
Xsplot u**4-6*u**2*v**2+v**4,4*u**3*v-4*u*v**3,v
Xpause -1 "Hit return to continue (11)"
X
X
Xset view 60,300
Xset title "Imaginary part of complex 4th root function (different view)"
Xreplot
Xpause -1 "Hit return to continue (12)"
X
X
Xset isosamples 21
Xset view 60,20
Xset urange [-3:3]
Xset vrange [-3:3]
Xset title "Enneper's surface"
Xsplot u-u**3/3+u*v**2,v-v**3/3+v*u**2,u**2-v**2
Xpause -1 "Hit return to continue (13)"
X
X
Xset view 60,110
Xset title "Enneper's surface (different view)"
Xreplot
Xpause -1 "Hit return to continue (14)"
X
X
Xset isosamples 31,11
Xset view 60,30
Xset title "Moebius strip"
Xset urange [0:2*pi]
Xset vrange [-0.25:0.25]
Xsplot (2-v*sin(u/2))*sin(u),(2-v*sin(u/2))*cos(u),v*cos(u/2)
Xpause -1 "Hit return to continue (15)"
X
X
Xset view 60,210
Xset title "Moebius strip (view from opposite side)"
Xreplot
Xpause -1 "Hit return to continue (16)"
X
Xset nokey
Xset xrange [-10:10]
Xset yrange [-10:10]
Xset zrange [-3:3]
Xset urange [0:2*pi]
Xset vrange [0:2*pi]
Xset isosamples 39,60
Xset view 60,120
Xset title "Klein bottle"
Xsplot  (2*sin(u)*cos(v/2)-sin(2*u)*sin(v/2)+8)*cos(v), \
X       (2*sin(u)*cos(v/2)-sin(2*u)*sin(v/2)+8)*sin(v), \
X        2*sin(u)*sin(v/2)+sin(2*u)*cos(v/2)
Xpause -1 "Hit return to continue (17)"
X
X
Xset urange [0:2*pi]
Xset vrange [0:4*pi/3]
Xset isosamples 39,40
Xset view 60,20
Xset title "Klein bottle with look at the 'inside'"
Xreplot
Xpause -1 "Hit return to continue (18)"
X
Xset data style lines
Xset xrange [-12:12]
Xset yrange [-12:12]
Xset zrange [-1:15]
Xset nohidden3d
Xset view 50,15
Xset title "Klein bottle, glassblowers' version (look-through)"
Xsplot "klein.dat"
Xpause -1 "Hit return to continue (19)"
X
X
Xset hidden3d
Xset view 70,305
Xset title "Klein bottle, glassblowers' version (solid)"
Xsplot "klein.dat"
Xpause -1 "Hit return to continue (20)"
X
X
Xset autoscale
Xset title ""
Xset key
Xset noparametric
Xset nohidden3d
Xset samples 100
Xset isosamples 10
Xset view 60,30
END_OF_FILE
  if test 4183 -ne `wc -c <'gnuplot/demo/singulr.dem'`; then
    echo shar: \"'gnuplot/demo/singulr.dem'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/demo/singulr.dem'
fi
if test -f 'gnuplot/docs/lasergnu.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/lasergnu.1'\"
else
  echo shar: Extracting \"'gnuplot/docs/lasergnu.1'\" \(1594 characters\)
  sed "s/^X//" >'gnuplot/docs/lasergnu.1' <<'END_OF_FILE'
X.TH LASERGNU l 
X.SH NAME
Xlasergnu \- send gnuplot output to a printer
X.SH SYNOPSIS
X.B lasergnu
X[ flags ] plot-command...
X.SH DESCRIPTION
X.I lasergnu
Xruns
X.IR gnuplot (1)
Xin an environment to produce typeset output on an IMAGEN  or
XPostscript printer.
X.PP
XThe 
X.B gnuplot
Xcommands
X.B plot-command
Xare performed and the output sent to the printer. 
XIf the 
X.B -f
Xoption specifies a file for input, the plot command is optional. 
XThe command-line plot commands are executed prior to any in the
Xfile(s).
X.PP
XFor example, to plot the function
X.I sin(x)
Xfrom -1 to +1, and to use printer im1, use the command
X.br
X.nf
X    lasergnu -Pim1 'plot [-1:1] sin(x) with lines'
X.fi
XTo execute the gnuplot command file
X.I myplot,
Xon the postscript printer lw0, use the command
X.br
X.nf
X    lasergnu -Plw0 -p -f myplot
X.fi
XThe following switches are recognized:
X.TP
X.BI \-p
XUse the postscript language to make the plot, instead of Impress.
XThis is for use on Postscript printers only. This uses a double-size
Xplot in landscape mode as the default.
X.TP
X.BI \-P\0 printer
XThe output of this program is intended for 
X.I printer.
X\ If the file is being spooled, this determines the printer it is spooled
Xto (default: $LASER).
XBe sure to use the -p flag if the printer is a postscript printer.
X.TP
X.BI \-f\0 file
XTake gnuplot commands from the named file.
XMultiple files  may be supplied with separate -f options.
X.TP
X.BI  \-t\0 title
XSpecify the title of the plot.
X.TP
X.BI \-b
XDo not print a banner page.
X.TP
X.BI \-J
XDo not print a banner page.
X.TP
X.B \-help
XPrints a list of options.
X.SH SEE ALSO
Xgnuplot(l), lpr(1)
END_OF_FILE
  if test 1594 -ne `wc -c <'gnuplot/docs/lasergnu.1'`; then
    echo shar: \"'gnuplot/docs/lasergnu.1'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/lasergnu.1'
fi
if test -f 'gnuplot/docs/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/docs/makefile'\"
else
  echo shar: Extracting \"'gnuplot/docs/makefile'\" \(4379 characters\)
  sed "s/^X//" >'gnuplot/docs/makefile' <<'END_OF_FILE'
X#
X# $Id: makefile%v 3.38.2.84 1993/03/01 01:36:45 woo Exp woo $
X#
X#
X# Makefile for GNUPLOT documentation
X#
X# Note that the top-level file for documentation is gnuplot.doc.
X# See README.
X#
X# To print manual:
X#    make gnuplot.dvi             (for latex)
X#    (print or view gnuplot.dvi)
X# OR
X#    make gnuplot.nroff           (for nroff)
X#    (print or view gnuplot.nroff)
X#   or
X#    make "TROFF=itroff" troff    (for troff; use your troff here)
X#
X# $Id: makefile%v 3.38.2.84 1993/03/01 01:36:45 woo Exp woo $
X
X# usually overridden by ../Makefile
XHELPDEST = /usr/local/lib
X
X# substitute your troff command (and any flags) for this one
XTROFF=troff
X
X# substitute cp if you do not have the install program
XINSTALL=install
X
X# substitute your DVI to PostScript conversion program here
XDVIPS=dvips
X
X# Compiler flags
X# -DSYSV if att sys V
X# -DMSDOS if MSDOS PS
X# -traditional -g -O if gcc (set 'CC = gcc')
X# no extra flags for BSD
XCFLAGS = -s
XCC = cc
X
X# Default information
Xhelp:
X	@echo "Please do a 'make <TARGET>' where <TARGET> is one of" \
X                "the following:"
X	@echo
X	@echo "check        check the gnuplot.doc file"
X	@echo "clean        remove all derived files"
X	@echo "dvi          DVI files (gnuplot.dvi gpcard.dvi)"
X	@echo "gih          Unix and MSDOS help file (gnuplot.gih)"
X	@echo "help         make help"
X	@echo "hlp          VMS help file (gnuplot.hlp)"
X	@echo "info         Info documentation (gnuplot.info)"
X	@echo "install-unix Unix and MSDOS install"
X	@echo "install-vms  VMS install"
X	@echo "nroff        nroff documentation (gnuplot.nroff)"
X	@echo "ps           PostScript files (gnuplot.ps gpcard.ps)"
X	@echo "tex          LaTeX documentation (gnuplot.tex)"
X	@echo "troff        troff documentation"
X	@echo "tutorial     LaTeX tutorial (latextut/tutorial.dvi)"
X	@echo
X	@echo "If you are not familiar with makefiles or just want" \
X                "to know what"
X	@echo "'make <TARGET>' would do without actually doing" \
X                "anything, then type"
X	@echo "        'make -n <TARGET>'"
X	@echo
X
X# default is what is needed for interactive gnuplot
Xdefault: gnuplot.hlp gnuplot.gih
X
X### [tn]roff documentation
Xtroff: gnuplot.ms titlepag.ms
X	tbl gnuplot.ms | eqn | $(TROFF) -ms
X
Xnroff: gnuplot.nroff
X
Xgnuplot.nroff: gnuplot.ms titlepag.ms
X	tbl gnuplot.ms | neqn | nroff -ms | col > gnuplot.nroff
X
Xms: gnuplot.ms
X
Xgnuplot.ms: doc2ms gnuplot.doc
X	./doc2ms gnuplot.doc gnuplot.ms
X
Xdoc2ms: doc2ms.c
X	$(CC) $(CFLAGS) -o doc2ms doc2ms.c
X
X### LaTeX documentation
Xtex: gnuplot.tex
X
Xgnuplot.tex: doc2tex gnuplot.doc
X	./doc2tex gnuplot.doc gnuplot.tex
X
X# this is how to make DVI files
Xdvi: gnuplot.dvi gpcard.dvi
X
Xgnuplot.dvi: gnuplot.tex titlepag.tex toc_entr.sty
X	latex gnuplot
X	latex gnuplot
X
Xgpcard.dvi: gpcard.tex
X	tex gpcard
X
X# this is how to make PostScript files
X# if pslatex has been installed, add "times" to titlepage.tex
Xps: gnuplot.ps gpcard.ps
X
Xgnuplot.ps: gnuplot.dvi
X	$(DVIPS) gnuplot
X
Xgpcard.ps: gpcard.dvi
X	$(DVIPS) gpcard
X
Xdoc2tex: doc2tex.c
X	$(CC) $(CFLAGS) -o doc2tex doc2tex.c
X
X# this is how to make gnuplot.hlp
Xhlp: gnuplot.hlp
X
Xgnuplot.hlp: doc2hlp gnuplot.doc
X	./doc2hlp gnuplot.doc gnuplot.hlp
X
Xdoc2hlp: doc2hlp.c
X	$(CC) $(CFLAGS) -o doc2hlp doc2hlp.c
X
X# this is how to make gnuplot.gih
Xgih: gnuplot.gih
X
Xgnuplot.gih: doc2gih gnuplot.doc
X	./doc2gih gnuplot.doc gnuplot.gih
X
Xdoc2gih: doc2gih.c
X	$(CC) $(CFLAGS) -o doc2gih doc2gih.c
X
X# this is how to make Info documentation
Xinfo: gnuplot.info
X
Xgnuplot.info: gnuplot.doc
X	perl doc2info.pl gnuplot.doc > gpltinfo.tex
X	makeinfo +fill-column 80 gpltinfo.tex
X	rm -f gpltinfo.tex
X
Xtutorial: latextut/tutorial.tex
X	( cd latextut; $(MAKE) )
X
X# this is how to check the gnuplot.doc file
Xcheck: checkdoc gnuplot.doc
X	./checkdoc < gnuplot.doc
X
Xcheckdoc: checkdoc.c
X	$(CC) $(CFLAGS) -o checkdoc checkdoc.c
X
X# For Unix and MSDOS only
Xinstall-unix: gnuplot.gih
X	$(INSTALL) gnuplot.gih $(HELPDEST)
X
X# for VMS only
Xinstall-vms: gnuplot.hlp
X	$(INSTALL) gnuplot.hlp $(HELPDEST)
X
X# remove all derived files
Xclean:
X	rm -f doc2ms gnuplot.nroff gnuplot.ms \
X              doc2tex gnuplot.tex gnuplot.dvi \
X              gnuplot.aux gnuplot.log gnuplot.toc \
X              gnuplot.ps gpcard.dvi gpcard.log gpcard.ps \
X              doc2hlp gnuplot.hlp \
X              doc2gih gnuplot.gih \
X              checkdoc *~ *.o core a.out \
X              gnuplot.info* gpltinfo.tex
X	( cd latextut; $(MAKE) clean )
END_OF_FILE
  if test 4379 -ne `wc -c <'gnuplot/docs/makefile'`; then
    echo shar: \"'gnuplot/docs/makefile'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/docs/makefile'
fi
if test -f 'gnuplot/eval.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/eval.c'\"
else
  echo shar: Extracting \"'gnuplot/eval.c'\" \(4465 characters\)
  sed "s/^X//" >'gnuplot/eval.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: eval.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X
X/* GNUPLOT - eval.c */
X/*
X * Copyright (C) 1986 - 1993   Thomas Williams, Colin Kelley
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHORS
X * 
X *   Original Software:
X *     Thomas Williams,  Colin Kelley.
X * 
X *   Gnuplot 2.0 additions:
X *       Russell Lang, Dave Kotz, John Campbell.
X *
X *   Gnuplot 3.0 additions:
X *       Gershon Elber and many others.
X * 
X * There is a mailing list for gnuplot users. Note, however, that the
X * newsgroup 
X *	comp.graphics.gnuplot 
X * is identical to the mailing list (they
X * both carry the same set of messages). We prefer that you read the
X * messages through that newsgroup, to subscribing to the mailing list.
X * (If you can read that newsgroup, and are already on the mailing list,
X * please send a message info-gnuplot-request@dartmouth.edu, asking to be
X * removed from the mailing list.)
X *
X * The address for mailing to list members is
X *	   info-gnuplot@dartmouth.edu
X * and for mailing administrative requests is 
X *	   info-gnuplot-request@dartmouth.edu
X * The mailing list for bug reports is 
X *	   bug-gnuplot@dartmouth.edu
X * The list of those interested in beta-test versions is
X *	   info-gnuplot-beta@dartmouth.edu
X */
X
X#include <stdio.h>
X#include "plot.h"
X
Xextern int c_token;
Xextern struct ft_entry ft[];
Xextern struct udvt_entry *first_udv;
Xextern struct udft_entry *first_udf;
Xextern struct at_type at;
Xextern struct lexical_unit token[];
X
Xstruct value *Ginteger();
X
X
X
Xstruct udvt_entry *
Xadd_udv(t_num)  /* find or add value and return pointer */
Xint t_num;
X{
Xregister struct udvt_entry **udv_ptr = &first_udv;
X
X	/* check if it's already in the table... */
X
X	while (*udv_ptr) {
X		if (equals(t_num,(*udv_ptr)->udv_name))
X			return(*udv_ptr);
X		udv_ptr = &((*udv_ptr)->next_udv);
X	}
X
X	*udv_ptr = (struct udvt_entry *)
X	  alloc((unsigned long)sizeof(struct udvt_entry), "value");
X	(*udv_ptr)->next_udv = NULL;
X	copy_str((*udv_ptr)->udv_name,t_num);
X	(*udv_ptr)->udv_value.type = INTGR;	/* not necessary, but safe! */
X	(*udv_ptr)->udv_undef = TRUE;
X	return(*udv_ptr);
X}
X
X
Xstruct udft_entry *
Xadd_udf(t_num)  /* find or add function and return pointer */
Xint t_num; /* index to token[] */
X{
Xregister struct udft_entry **udf_ptr = &first_udf;
X
X	int i;
X	while (*udf_ptr) {
X		if (equals(t_num,(*udf_ptr)->udf_name))
X			return(*udf_ptr);
X		udf_ptr = &((*udf_ptr)->next_udf);
X	}
X     *udf_ptr = (struct udft_entry *)
X	  alloc((unsigned long)sizeof(struct udft_entry), "function");
X	(*udf_ptr)->next_udf = (struct udft_entry *) NULL;
X	(*udf_ptr)->definition = NULL;
X	(*udf_ptr)->at = NULL;
X	copy_str((*udf_ptr)->udf_name,t_num);
X	for(i=0; i<MAX_NUM_VAR; i++)
X		(void) Ginteger(&((*udf_ptr)->dummy_values[i]), 0);
X	return(*udf_ptr);
X}
X
X
Xunion argument *
Xadd_action(sf_index)
Xenum operators sf_index;		/* index of p-code function */
X{
X	if (at.a_count >= MAX_AT_LEN)
X		int_error("action table overflow",NO_CARET);
X	at.actions[at.a_count].index = sf_index;
X	return(&(at.actions[at.a_count++].arg));
X}
X
X
Xint standard(t_num)  /* return standard function index or 0 */
X{
Xregister int i;
X	for (i = (int)SF_START; ft[i].f_name != NULL; i++) {
X		if (equals(t_num,ft[i].f_name))
X			return(i);
X	}
X	return(0);
X}
X
X 
X
Xexecute_at(at_ptr)
Xstruct at_type *at_ptr;
X{
Xregister int i,index,count,offset;
X
X	count = at_ptr->a_count;
X	for (i = 0; i < count;) {
X		index = (int)at_ptr->actions[i].index;
X		offset = (*ft[index].func)(&(at_ptr->actions[i].arg));
X		if (is_jump(index))
X			i += offset;
X		else
X			i++;
X	}
X}
X
X/*
X
X 'ft' is a table containing C functions within this program. 
X
X An 'action_table' contains pointers to these functions and arguments to be
X passed to them. 
X
X at_ptr is a pointer to the action table which must be executed (evaluated)
X
X so the iterated line exectues the function indexed by the at_ptr and 
X passes the address of the argument which is pointed to by the arg_ptr 
X
X*/
END_OF_FILE
  if test 4465 -ne `wc -c <'gnuplot/eval.c'`; then
    echo shar: \"'gnuplot/eval.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/eval.c'
fi
if test -f 'gnuplot/gnubin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/gnubin.c'\"
else
  echo shar: Extracting \"'gnuplot/gnubin.c'\" \(4608 characters\)
  sed "s/^X//" >'gnuplot/gnubin.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char *RCSid = "$Id: gnubin.c%v 3.50 1993/07/09 05:35:24 woo Exp $";
X#endif
X
X
X/*
X * The addition of gnu_binary_files and binary_files, along with a small patch
X * to command.c, will permit gnuplot to plot binary files.
X * gnu_binary_files  - contains the code that relies on gnuplot include files
X *                     and other definitions
X * binary_files      - contains those things that are independent of those 
X *                     definitions and files
X *
X * With these routines, hidden line removal of your binary data is possible!
X *
X * Last update: 3/3/92 for Gnuplot 3.24.
X * Created from code for written by RKC for gnuplot 2.0b.
X *
X * 19 September 1992  Lawrence Crowl  (crowl@cs.orst.edu)
X * Added user-specified bases for log scaling.
X *
X * Copyright (c) 1991,1992 Robert K. Cunningham, MIT Lincoln Laboratory
X *
X */
X#include <stdio.h>
X#include <math.h>
X#include "plot.h"
X#include "setshow.h"
X
X/******************* SHARED INCLUDE FILE--start ***********************
X *  I recommend that these be put into an include file that all
X *  will share -- but I leave it up to the powers that be to do this.
X */
X/* Copied from command.c -- this should be put in a shared macro file */
X#define inrange(z,min,max) ((min<max) ? ((z>=min)&&(z<=max)) : ((z>=max)&&(z<=min)) )
X
X/* Routines for interfacing with command.c */
Xfloat GPFAR *vector();
Xfloat GPFAR *extend_vector();
Xfloat GPFAR *retract_vector();
Xfloat GPFAR * GPFAR *matrix();
Xfloat GPFAR * GPFAR *extend_matrix();
Xfloat GPFAR * GPFAR *retract_matrix();
Xvoid free_matrix();
Xvoid free_vector();
X/******************* SHARED INCLUDE FILE--end *************************/
X/*
X  Here we keep putting new plots onto the end of the linked list
X
X  We assume the data's x,y values have x1<x2, x2<x3... and 
X                                       y1<y2, y2<y3... .
X  Actually, I think the assumption is less stron than that--it looks like
X  the direction just has to be the same.
X
X  This routine expects the following to be properly initialized:
X      is_log_x, is_log_y, and is_log_z 
X      base_log_x, base_log_y, and base_log_z 
X      log_base_log_x, log_base_log_y, and log_base_log_z 
X      xmin,ymin, and zmin
X      xmax,ymax, and zmax
X      autoscale_lx, autoscale_ly, and autoscale_lz
X
X*/
Xint
X  get_binary_data(this_plot,fp,p_ret_iso)
Xstruct surface_points *this_plot;
XFILE *fp;
Xstruct iso_curve **p_ret_iso;
X{
X  register int i,j;
X  float GPFAR * GPFAR *matrix, GPFAR *rt, GPFAR *ct;
X  int nr,nc;
X  int ndata;
X  struct iso_curve *this_iso;
X  float z;
X
X  this_plot->plot_type = DATA3D;
X  this_plot->has_grid_topology = TRUE;
X
X  if(!fread_matrix(fp,&matrix,&nr,&nc,&rt,&ct))
X    int_error("Binary file read error: format unknown!",NO_CARET);
X
X  /* Now we do some error checking on the x and y axis */
X  if(is_log_x)
X    for(i=0; i<nc; i++)
X      if(ct[i] < 0.0)
X	int_error("X value must be above 0 for log scale!",NO_CARET);
X      else
X	ct[i] = log(ct[i])/log_base_log_x;
X
X  if(is_log_y)
X    for(i=0; i<nr; i++)
X      if(rt[i] < 0.0)
X	int_error("Y value must be above 0 for log scale!",NO_CARET);
X      else
X	rt[i] = log(rt[i])/log_base_log_y;
X
X  /* Count up the number of used column entries */
X  if (autoscale_lx) {
X    ndata = nc;
X    for(j=0; j< nc; j++){
X      if (ct[j] < xmin) xmin = ct[j];
X      if (ct[j] > xmax) xmax = ct[j];
X    }
X  }
X  else {
X    for(ndata = 0, j = 0; j< nc; j++){
X      if (!((ct[j] < xmin) || (ct[j] > xmax)))/*Column is in bounds*/
X	ndata++;
X    }
X  }
X
X  for(i=0; i < nr; i++){
X      if (autoscale_ly) {
X	if (rt[i] < ymin) ymin = rt[i];
X	if (rt[i] > ymax) ymax = rt[i];
X      }
X      else if ((rt[i] < ymin) || (rt[i] > ymax))/* This row is out of bounds */
X	continue;
X
X      this_iso = iso_alloc( ndata );/*Allocate the correct number of entries*/
X      for(ndata = 0, j = 0; j< nc; j++){/* Cycle through data */
X
X	if ((ct[j] < xmin) || (ct[j] > xmax))/*Column is out of bounds*/
X	  continue;       /* Only affects non-autoscale_lx cases */
X
X	this_iso->points[ndata].x = ct[j];
X	this_iso->points[ndata].y = rt[i];
X	z = matrix[i][j];
X	if(is_log_z)
X	  if (z <= 0.0)
X	    int_error("Z value must be above 0 for log scale!",NO_CARET);
X	  else
X	    z = log(z)/log_base_log_z;
X	this_iso->points[ndata].z = z;
X      
X	if (autoscale_lz) {
X	  if (z < zmin) zmin = z;
X	  if (z > zmax) zmax = z;
X	}
X	ndata++;
X      }
X      this_iso->p_count = ndata;
X      this_iso->next = this_plot->iso_crvs;
X      this_plot->iso_crvs = this_iso;
X      this_plot->num_iso_read++;
X  }
X  
X  free_matrix(matrix,0,nr-1,0,nc-1);
X  free_vector(rt,0,nr-1);
X  free_vector(ct,0,nc-1);
X  *p_ret_iso = this_iso;
X  return(ndata+1);
X}
END_OF_FILE
  if test 4608 -ne `wc -c <'gnuplot/gnubin.c'`; then
    echo shar: \"'gnuplot/gnubin.c'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/gnubin.c'
fi
if test -f 'gnuplot/lasergnu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/lasergnu'\"
else
  echo shar: Extracting \"'gnuplot/lasergnu'\" \(4511 characters\)
  sed "s/^X//" >'gnuplot/lasergnu' <<'END_OF_FILE'
X#!/bin/csh -f
X#
X# $Id: lasergnu%v 3.50 1993/07/09 05:35:24 woo Exp $
X#
X# Print gnuplot output on an Imagen or Postscript laser printer.
X
Xset print_banner = on   # Print a banner page unless told otherwise.
Xset input_files = ()    # the plot input command files
Xset lpr_opts = ()       # options to lpr
X
X# Default printer set by shell variable PRINTER.
Xif (! $?PRINTER) then
X    if ($?LASER) then
X        set PRINTER=$LASER
X    else
X        set PRINTER="lw0"
X    endif
Xendif
Xset printer = (-P$PRINTER)
X
X# File for plot commands, and for plot output
Xset TMP=/tmp/plot$$
Xset outfile=$TMP.out    # the output file
Xonintr cleanup
X
X# default is Imagen mode for Imagen printer; see -p option
Xset setterm="set terminal imagen"
Xset LANG="-Limpress"
X
Xset usage="usage: lasergnu [-Pprinter] [-b] [-p] [-t title] [-f file] ['plot command']...."
X
X# Loop through the command-line arguments.
X
Xtop:
X    if ($#argv > 0) then
X
X        switch ("$argv[1]")
X
X        case -b*:   # Do not print a banner page.
X        case -J*:   # Compatible with imprint.
X            set print_banner = off
X                set lpr_opts=($lpr_opts -h)
X            shift argv
X            goto top
X
X        case -f?*:  # Specify file containing plot commands
X            set input_files = ($input_files `echo $argv[1] | sed 's/^-f//'`)
X            shift argv
X            goto top
X
X        case -f:    # Specify file containing plot commands
X            shift argv
X            if ($#argv > 0) then
X                set input_files = ($input_files $argv[1])
X                shift argv
X            else
X                echo "Usage: -f file ..."
X                echo "Type    lasergnu -help    for help."
X                exit (1)
X            endif
X            goto top
X
X        case -t?*:  # Specify title of plot
X            echo set title \""`echo $argv[1] | sed 's/^-t//'`"\" >> $TMP
X            shift argv
X            goto top
X
X        case -t:    # Specify title of plot
X            shift argv
X            if ($#argv > 0) then
X                echo set title \""$1"\" >> $TMP
X                shift argv
X            else
X                echo "Usage: -t title ..."
X                echo "Type    lasergnu -help    for help."
X                exit (1)
X            endif
X            goto top
X        case -help:
X            echo "$usage"
X            exit(1)
X
X        case -P?*:  # Set the printer, exactly as by itroff.
X            set printer = $argv[1]
X            shift argv
X            goto top
X
X        case -P:    # Set the printer, exactly as by itroff.
X            shift argv
X            if ($#argv > 0) then
X                set printer = (-P$argv[1])
X                shift argv
X            else
X                echo "Usage: -P printer ..."
X                echo "Type    lasergnu -help    for help."
X                exit (1)
X            endif
X            goto top
X
X                # use impress
X        case -I:
X             echo Imagen is the default mode now
X             shift argv
X             goto top
X
X                # use postscript instead of impress language
X        case -p:
X             set setterm="set term postscript"
X             set LANG="-Lpostscript"
X             shift argv
X             goto top
X
X        case -?*:
X            echo "I do not recognize option $argv[1]."
X            echo "$usage"
X            exit (1)
X
X        default:
X              echo "$argv[1]"   >> $TMP
X            shift argv
X            goto top
X
X        endsw
X    endif
X
X# try to devine the printer type
Xif ($printer =~ -Plw*) then
X    set setterm="set term postscript"
X    set LANG="-Lpostscript"
Xendif
X
Xif ($printer =~ -Pim*) then
X    set setterm="set term imagen"
X    set LANG="-Limpress"
Xendif
X
X# Set up input file
Xecho $setterm > $TMP.plt
Xecho set output \"$outfile\" >> $TMP.plt
Xif (-e $TMP) cat $TMP >> $TMP.plt
X
X# If input file is specified AND command line contains plot commands, then
X#   do command line args first, then plot commands in input file.
Xgnuplot $TMP.plt $input_files
X
Xif ($status == 0 && -e $outfile && ! -z $outfile) then
X    # The printer is whatever printer was last specified,
X    # or the default printer if none was specified.
X    if ($LANG == -Limpress) then
X        /usr/local/bin/ipr $LANG $printer \
X           -D"jobheader $print_banner" \
X           -D"pagereversal on" \
X           -D"program lasergnu" $outfile
X    else if ($LANG == -Lpostscript) then
X           lpr $lpr_opts $printer $outfile
X    endif
Xelse
X    echo "lasergnu: error in plotting or empty plot; nothing printed."
Xendif
X
Xcleanup:
Xrm -f $TMP* $outfile
END_OF_FILE
  if test 4511 -ne `wc -c <'gnuplot/lasergnu'`; then
    echo shar: \"'gnuplot/lasergnu'\" unpacked with wrong size!
  fi
  chmod +x 'gnuplot/lasergnu'
  # end of 'gnuplot/lasergnu'
fi
if test -f 'gnuplot/makefile.286' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/makefile.286'\"
else
  echo shar: Extracting \"'gnuplot/makefile.286'\" \(4238 characters\)
  sed "s/^X//" >'gnuplot/makefile.286' <<'END_OF_FILE'
X# make file for Borland C++ 3.x
X#   and Phar Lap LITE286 DOS extender
X# both LITE286 bin and BORLANDC bin directories must be on the path
X
X# where to place gnuplot.gih helpfile
XHELPFILE = gnuplot.gih
X# location of LITE286 Pharlap Extender
XLITE=c:\lite286
XLITECC=$(LITE)\bin\bcc286
X# location of Turbo C compiler
XTC = c:\borlandc
X# name of C compiler
XCC = bcc
X#CC = tcc
X# location of TLINK.EXE and TCC.EXE or BCC.EXE
XBIN = $(TC)\bin\\
X#BIN =
X# location of BGI files,
X# change this line if not in TC directory, i.e. $(TC)\bgi
XBGI = $(TC)\bgi
X
X# -c means don't link, -f means emulate 8087 if not present
X# -ml says large model 
X# -M means produce link map
X# -y means include line numbers for debugger
X# -v means include debug info
X# -w- means ignore warnings and do not report them
X# -DREADLINE to use the history/line editing capability. If you want this 
X#    capability add -DREADLINE to CFLAGS
XCFLAGS = -Ff=256 -c -f -ml -w- -I$(TC)\include -DMSDOS -DPC -DREADLINE
XTERMFLAGS =
X
XOBJ1 =  bitmap.obj command.obj contour.obj eval.obj graphics.obj graph3d.obj
XOBJ2 =	help.obj internal.obj misc.obj parse.obj plot.obj readline.obj
XOBJ3 =	scanner.obj setshow.obj specfun.obj standard.obj term.obj util.obj
XOBJ4 =	version.obj gnubin.obj binary.obj
XBGIFILES = cga.bgi egavga.bgi herc.bgi att.bgi
X
XOBJS =	$(OBJ1) $(OBJ2) $(OBJ3) $(OBJ4)
X
XCSOURCE5 = term\aed.trm term\cgi.trm term\dumb.trm term\dxy.trm \
X	term\eepic.trm term\epson.trm term\fig.trm term\hp26.trm \
X	term\hp2648.trm term\hpgl.trm term\hpljii.trm 
XCSOURCE6 = term\impcodes.h term\imagen.trm term\object.h \
X	term\iris4d.trm term\kyo.trm term\latex.trm term\pc.trm 
XCSOURCE7 = term\post.trm term\qms.trm term\regis.trm term\sun.trm \
X	term\t410x.trm term\tek.trm term\unixpc.trm term\unixplot.trm \
X	term\v384.trm term\x11.trm
XCSOURCE8 = contour.c specfun.c gnubin.c binary.c
X
Xall: gnuplot.exe $(HELPFILE) demo\bf_test.exe $(BGIFILES)
X
X# use response file to avoid command-line overflow
Xgnuplot.exe: $(OBJS)
X	$(BIN)tlink @&&!
X$(LITE)\bc3\lib\c0pl +
Xbitmap command eval graphics graph3d help internal misc parse +
Xplot scanner setshow specfun standard term util version contour +
Xgnubin binary +
Xreadline +
X$(LITE)\bc3\lib\emu286.lib +
X,gnuplot,gnuplot, +
X$(TC)\lib\emu +
X$(TC)\lib\mathl +
X$(LITE)\bc3\lib\graph286.lib +
X$(LITE)\bc3\lib\phapi +
X$(LITE)\bc3\lib\bcl286, +
Xgnuplot.def
X!
X
X
X# default rules
X
X.c.obj:
X	$(LITECC) $(CFLAGS) $<
X
Xbitmap.obj: bitmap.c bitmap.h plot.h
X
Xcommand.obj: command.c plot.h setshow.h help.h
X	$(LITECC) $(CFLAGS) command.c
X
Xcontour.obj: contour.c plot.h
X
Xeval.obj: eval.c plot.h
X
Xgraphics.obj: graphics.c plot.h setshow.h
X
Xgraph3d.obj: graphics.c plot.h setshow.h
X
Xhelp.obj: help.c plot.h help.h
X
Xinternal.obj: internal.c plot.h
X
Xmisc.obj: misc.c plot.h setshow.h help.h
X
Xparse.obj: parse.c plot.h
X	$(LITECC) $(CFLAGS) parse.c
X
Xplot.obj: plot.c plot.h setshow.h
X	$(LITECC) $(CFLAGS) plot.c
X
Xreadline.obj: readline.c
X
Xscanner.obj: scanner.c plot.h
X
Xsetshow.obj: setshow.c plot.h setshow.h
X
Xspecfun.obj: specfun.c
X
Xstandard.obj: standard.c plot.h
X
X# the CSOURCE? dependencies are not up to date (but who cares)
Xterm.obj: term.c term.h plot.h setshow.c bitmap.h $(CSOURCE5) $(CSOURCE6) $(CSOURCE7)
X	$(LITECC) $(CFLAGS) $(TERMFLAGS) -Iterm term.c
X
Xutil.obj: util.c plot.h
X
Xversion.obj: version.c
X
X# convert gnuplot.doc to gnuplot.gih
X$(HELPFILE): doc2gih.exe docs\gnuplot.doc
X	doc2gih docs\gnuplot.doc $(HELPFILE)
X
Xdoc2gih.exe: docs\doc2gih.c
X    $(BIN)$(CC) -w- -ml -I$(TC)\include -L$(TC)\lib docs\doc2gih.c
X
Xdemo\bf_test.exe: bf_test.c binary.obj
X    $(BIN)$(CC) -edemo\bf_test.exe -w- -ml -I$(TC)\include -L$(TC)\lib bf_test.c binary.obj
X
X# copy Borland Graphics Interface files to current directory
Xcga.bgi: $(BGI)\cga.bgi
X	copy $(BGI)\$< $<
X
Xegavga.bgi: $(BGI)\egavga.bgi
X	copy $(BGI)\$< $<
X
Xherc.bgi: $(BGI)\herc.bgi
X	copy $(BGI)\$< $<
X
Xatt.bgi: $(BGI)\att.bgi
X	copy $(BGI)\$< $<
X
X# clean target - remove all temp files, but leave executable intact
X# needed when changing configuration (model or overlaying)
X
Xclean:
X	del *.obj
X	del gnuplot.map
X	del doc2gih.exe
X
X# realclean target - remove all files created by the makefile
X
Xrealclean: clean
X	del gnuplot.exe
X	del gnuplot.gih
X	del demo\bf_test.exe
X	del demo\binary1
X	del demo\binary2
X	del demo\binary3
END_OF_FILE
  if test 4238 -ne `wc -c <'gnuplot/makefile.286'`; then
    echo shar: \"'gnuplot/makefile.286'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/makefile.286'
fi
if test -f 'gnuplot/os2/gnupmdrv.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/os2/gnupmdrv.h'\"
else
  echo shar: Extracting \"'gnuplot/os2/gnupmdrv.h'\" \(4603 characters\)
  sed "s/^X//" >'gnuplot/os2/gnupmdrv.h' <<'END_OF_FILE'
X/* gnushell header file */
X/*
X** static char RCSid[]="$Id: gnupmdrv.h%v 3.50 1993/07/09 05:35:24 woo Exp $" ;
X*/
X
X/*
X * PM driver for GNUPLOT
X * Copyright (C) 1992   Roger Fearick
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software is provided "as is" without express or implied warranty.
X * 
X *
X * AUTHOR
X * 
X *   Gnuplot driver for OS/2:  Roger Fearick
X * 
X * Send your comments or suggestions to 
X *  info-gnuplot@dartmouth.edu.
X * This is a mailing list; to join it send a note to 
X *  info-gnuplot-request@dartmouth.edu.  
X * Send bug reports to
X *  bug-gnuplot@dartmouth.edu.
X**/
X
X    /* include resource defines */
X    
X#ifndef DISPDEFS_H
X/*#include "dispdefs.h"*/
X#include "dialogs.h"
X#endif
X
X/*==== own window messages  =================================================*/
X
X#define WM_GNUPLOT          (WM_USER+20)
X#define WM_PAUSEPLOT        (WM_USER+21)
X#define WM_PAUSEEND         (WM_USER+22)
X#define WM_USER_SET_DATA    (WM_USER+90)
X#define WM_USER_GET_DATA    (WM_USER+91)
X#define WM_USER_CHGFONT     (WM_USER+10) 
X#define WM_USER_PRINT_BEGIN (WM_USER+200)
X#define WM_USER_PRINT_OK    (WM_USER+201)
X#define WM_USER_PRINT_ERROR (WM_USER+202)
X#define WM_USER_DEV_ERROR   (WM_USER+203)
X#define WM_USER_PRINT_QBUSY (WM_USER+204)
X
X/*==== various names ========================================================*/
X
X#define GNUPIPE     "\\pipe\\gnuplot"       /* named pipe to gnuplot */
X#define GNUQUEUE    "\\queues\\gnuplot"     /* queue for gnuplot termination */
X#define GNUSEM      "\\sem32\\gnuplot.sem"  /* synch gnuplot and gnupmdrv */
X#define GNUINI      "gnupmdrv.ini"          /* ini filename */
X#define ENVGNUHELP  "GNUHELP"               /* gnuplot help envionment name */
X#define ENVGNUPLOT  "GNUPLOT"               /* general gnuplot environment */
X#define GNUEXEFILE  "gnuplot.exe"           /* exe file name */
X#define GNUHELPFILE "gnuplot.gih"           /* help file name */
X#define GNUTERMINIT "GNUTERM=pm"            /* terminal setup string */
X#define INITIAL_FONT "12.Helvetica"         /* initial font for plots */
X#define APP_NAME     "GnuplotPM"             /* application name */
X
X        // profile (ini file) names 
X#define INISHELLPOS  "PosShell"
X#define INIPLOTPOS   "PosPlot"
X#define INIFONT      "DefFont" 
X#define INIOPTS      "DefOpts"      
X
X/*==== global data  ==========================================================*/
X
XHAB         hab ;                   // application anchor block handle 
XHWND   	    hApp ;                  // application window handle 
XHWND        hwndFrame ;             // frame window handle 
X#define   FONTBUF   256         /* buffer for dropped font namesize */
X
X/*==== stuff for querying printer capability =================================*/
X
Xtypedef struct {  //query data for printer setup
X    float xsize ;
X    float ysize ;
X    float xfrac ;
X    float yfrac ;
X    short caps ;
X    char  szFilename[CCHMAXPATHCOMP] ;
X    PPRQINFO3 piPrinter ;
X    } QPRINT, *PQPRINT ;
X
X#define QP_CAPS_NORMAL 0
X#define QP_CAPS_FILE   1   /* can print to file */
X
X/*==== function declarations =================================================*/
X
Xshort            ScalePS( HPS, PRECTL, USHORT ) ;
Xvoid             PlotThings( HPS, long ) ;
Xint              SetupPrinter( HWND, char*, PPRQINFO3 ) ;
XHDC              OpenPrinterDC( HAB, PPRQINFO3, LONG, char* ) ;
Xint              SetPrinterMode( HWND, PPRQINFO3 ) ;
XMPARAM           PrintCmdProc( HWND, ULONG, MPARAM, MPARAM ) ;
XMRESULT EXPENTRY PrintDlgProc( HWND, ULONG, MPARAM, MPARAM ) ;
XMRESULT EXPENTRY PauseMsgDlgProc( HWND, ULONG, MPARAM, MPARAM ) ;
XMRESULT EXPENTRY QFontDlgProc( HWND ,ULONG, MPARAM, MPARAM ) ;
XMRESULT EXPENTRY QPrintDlgProc (HWND, ULONG, MPARAM, MPARAM) ;
XMRESULT EXPENTRY QPrintersDlgProc ( HWND, ULONG, MPARAM, MPARAM ) ;
XMRESULT EXPENTRY DisplayClientWndProc(HWND, ULONG, MPARAM, MPARAM);
XMRESULT EXPENTRY NewFrameWndProc(HWND, ULONG, MPARAM, MPARAM) ;
XMRESULT EXPENTRY About(HWND, ULONG, MPARAM, MPARAM);
X
X        /* own window functions... */
Xvoid WinSetDlgItemFloat( HWND, USHORT, float ) ;
Xvoid WinSetDlgItemFloatF( HWND, USHORT, int, float ) ;
Xvoid WinQueryDlgItemFloat( HWND, USHORT, float* ) ;
X
X
END_OF_FILE
  if test 4603 -ne `wc -c <'gnuplot/os2/gnupmdrv.h'`; then
    echo shar: \"'gnuplot/os2/gnupmdrv.h'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/os2/gnupmdrv.h'
fi
if test -f 'gnuplot/term/cgi.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/cgi.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/cgi.trm'\" \(4478 characters\)
  sed "s/^X//" >'gnuplot/term/cgi.trm' <<'END_OF_FILE'
X/*
X * $Id: cgi.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X *
X */
X
X/* GNUPLOT - cgi.trm */
X/*
X * Copyright (C) 1990 - 1993 Ronald Florence
X *
X * Permission is hereby granted for unlimited non-commercial
X * use of this code, on condition that the copyright
X * notices are left intact and any modifications to the source
X * code are noted as such.  No warranty of any kind is implied
X * or granted for this material.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports SCO CGI drivers
X *
X * AUTHOR
X *   Ronald Florence <ron@mlfarm.com>
X */
X
X#ifdef VGA_MONO
Xstatic short rgb[16][3] = {
X  0,    0,      0,      /* Black        */
X  1000,	1000,	1000,	/* White	*/
X  800,	800,	0,	/* Red		*/
X  0,	600,	0,	/* Green	*/
X  0,	800,	800,	/* Blue		*/
X  1000,	1000,	400,	/* Yellow	*/
X  0,	600,	600,	/* Cyan		*/
X  600,	600,	600,	/* Magenta	*/
X  800,	800,	0,	/* Brown	*/
X  600,	600,	600,	/* Lt. Grey	*/
X  400,	600,	400,	/* Dark Grey	*/
X  400,	600,	1000,	/* Lt. Blue	*/
X  400,	1000,	400,	/* Lt Green	*/
X  400,	1000,	1000,	/* Lt Cyan	*/
X  1000,	600,	400,	/* Lt Red	*/
X  600,	600,	1000	/* Lt Magenta	*/
X};
X#endif
X
X#define CGI_XMAX	32767
X#define CGI_YMAX	32767
X#define CGI_VTIC	(CGI_YMAX / 75)
X#define CGI_HTIC	term_tbl[term].h_tic
X#define CGI_VCHAR	term_tbl[term].v_char
X#define CGI_HCHAR	term_tbl[term].h_char
X#define CRT		(gout[45] == 0)
X#define CGICOLORS	gout[13]
X#define CGILINES	gout[6]
X#define CGIROTATES	gout[36]
X#define CGITEXTALIGN	gout[48]
X
Xstatic short gout[66];
Xstatic short cgidev;
Xstatic short vect[4];
Xstatic short gin[19] = {
X 0,	/* default aspect ratio */
X 1,	/* solid line */
X 1,	/* line color */
X 1,	/* marker type . */
X 1,	/* marker color */
X 1,	/* graphics text font */
X 1,	/* graphics text color */
X 0,	/* fill interior style */
X 0,	/* fill style index */
X 1,	/* fill color index */
X 1 	/* prompt for paper changes */
X };
X
Xchar	*cgidriver, *getenv();
X
X
XCGI_init()
X{
X  if (getenv(cgidriver = "CGIDISP") == NULL)
X    HCGI_init();
X}
X
X
XHCGI_init()
X{
X  if (getenv(cgidriver = "CGIPRNT") == NULL)
X    int_error("no CGI driver", NO_CARET);
X}
X
X
XCGI_graphics()
X{
X  int	i, aspect;
X  char *s;
X  short font_cap[9];
X  char	err_str[80];
X
X  if ( (s=getenv("ASPECT")) != NULL && (aspect=atoi(s)) >= 0 && aspect <= 3 )
X    gin[0] = aspect;
X  for (i = 0; cgidriver[i]; i++) 
X    gin[11+i] = cgidriver[i];
X  gin[18] = ' ';
X
X  if (v_opnwk(gin, &cgidev, gout) < 0) 
X    {
X      sprintf(err_str, "CGI error %d opening %s", -vq_error(), cgidriver);
X      int_error(err_str, NO_CARET);
X    }
X  vqt_representation(cgidev, 9, font_cap);
X  CGI_VCHAR = font_cap[8] * 3 / 2;
X  CGI_HCHAR = font_cap[7];
X  CGI_HTIC = CGI_VTIC * ((double) gout[1] / (double) gout[4]) / 
X			((double) gout[0] / (double) gout[3]);
X#ifdef VGA_MONO
X  if (CGICOLORS > 2)
X    vsc_table(cgidev, 0, CGICOLORS, rgb);
X#endif
X}
X
X
XCGI_text()
X{
X  if (CRT)  
X    {
X      short ptin[2];
X      char  strin[2];
X      
X      ptin[0] = 0;
X      ptin[1] = 0;
X      vrq_string(cgidev, 1, 0, ptin, strin);
X    }
X  v_clswk(cgidev);
X}
X
X
XCGI_reset()
X{
X}
X
X
XCGI_move(x, y)
X     int x, y;
X{
X  vect[0] = x;
X  vect[1] = y;
X}
X
XCGI_vector(x, y)
X     int x, y;
X{
X  vect[2] = x;
X  vect[3] = y;
X  v_pline(cgidev, 2, vect);
X  vect[0] = x;
X  vect[1] = y;
X}
X
X
XCGI_linetype(linetype)
X     int linetype;
X{
X  short lcolor;
X
X  if (CGICOLORS > 2) 
X    {
X      lcolor = (linetype + 2) % CGICOLORS + 1;
X      vsl_color(cgidev, lcolor);
X      vsm_color(cgidev, lcolor);
X    }
X  vsl_type(cgidev, (linetype < 1) ? 1 : (linetype % CGILINES) + 1);
X}
X
X
XCGI_put_text(x, y, str)
Xint x, y;
Xchar *str;
X{
X  v_gtext(cgidev, (short) x, (short) y, str);
X}
X
X
XCGI_text_angle(ang)
Xint	ang;
X{
X  if (!CGIROTATES)
X    return FALSE;
X				/* angles are 1/10 degree ccw */
X  vst_rotation(cgidev, (ang) ? 900 : 0);
X  return TRUE;
X}
X
X
XCGI_justify_text(mode)
Xenum JUSTIFY mode;
X{
X  short hor_in, hor_out, vert_out;
X
X  if (!CGITEXTALIGN)
X    return FALSE;
X
X  switch (mode)
X    {
X    case LEFT:   hor_in = 0; break;
X    case CENTRE: hor_in = 1; break;
X    case RIGHT:  hor_in = 2; break;
X    }
X  vst_alignment(cgidev, hor_in, 1, &hor_out, &vert_out); 
X  return TRUE;
X}
X
X
X#define POINT_TYPES 6
X
XCGI_point(x,y,num)
X     int x, y, num;
X{
X  short  point[2];
X  static short cgimarker[POINT_TYPES] = {1, 2, 6, 4, 5, 3};
X			              /* .  +  <> [] X  * */
X  if (num < 0)
X    {
X      CGI_move(x, y);
X      CGI_vector(x, y);
X    }
X  else
X    {
X      vsm_type(cgidev, cgimarker[num % POINT_TYPES]);
X      point[0] = x;
X      point[1] = y;
X      v_pmarker(cgidev, 1, point);
X    }
X}
END_OF_FILE
  if test 4478 -ne `wc -c <'gnuplot/term/cgi.trm'`; then
    echo shar: \"'gnuplot/term/cgi.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/cgi.trm'
fi
if test -f 'gnuplot/term/emxvga.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/emxvga.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/emxvga.trm'\" \(4303 characters\)
  sed "s/^X//" >'gnuplot/term/emxvga.trm' <<'END_OF_FILE'
X/* GNUPLOT - emxvga.trm */
X/*
X * Copyright (C) 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *
X * This software  is provided "as is" without express or implied warranty.
X *
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  vgal
X *  vesa
X *
X * AUTHORS
X *  Russell Lang
X *
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X *
X */
X
X/* VGA driver using EMX/GCC for DOS */
X#include <graph.h>
X#include <conio.h>
X#include <dos.h>
X
Xint emx_startx, emx_starty;
Xint emx_xlast, emx_ylast;
Xint emx_color;
Xint emx_angle;
Xint emx_vmode = 0;
X#ifdef EMXVESA
Xint emx_vesamode = G640x480x256;
X#endif
X
X#define EMXVGA_XMAX 640
X#define EMXVGA_YMAX 480
X
X#define EMXVGA_XLAST (EMXVGA_XMAX - 1)
X#define EMXVGA_YLAST (EMXVGA_YMAX - 1)
X
X#define EMXVGA_VCHAR FNT5X9_VCHAR
X#define EMXVGA_HCHAR FNT5X9_HCHAR
X#define EMXVGA_VTIC 4
X#define EMXVGA_HTIC 4
X
X#define EMXNUMCOLOR 15
Xstatic int emx_colors[EMXNUMCOLOR] = {7,8,2,3,4,5,9,14,12,15,13,10,11,1,6};
X
X
XEMXVGA_init()
X{
Xunion REGS r;
X	r.h.ah = 0x0f;
X	_int86(0x10, &r, &r);
X	emx_vmode = r.h.al;	/* save old video mode */
X	/* Get the screen size: */
X	if (!g_mode(G_MODE_VGA_L))
X		int_error("Couldn't select graphics mode",NO_CARET);
X	emx_xlast = g_xsize - 1;
X    	term_tbl[term].xmax = emx_xlast + 1;
X	emx_ylast = g_ysize - 1;
X    	term_tbl[term].ymax = emx_ylast + 1;
X	g_mode(G_MODE_OFF);
X}
X
XEMXVGA_graphics()
X{
X/* don't use g_mode() here - gmode(G_MODE_OFF) doesn't clean up */
Xunion REGS r;
X	r.h.ah = 0x00;
X	r.h.al = 19;		/* VGA 320x200x256 mode */
X	_int86(0x10, &r, &r);
X}
X
XEMXVGA_text()
X{
X/* don't use g_mode() here - gmode(G_MODE_OFF) doesn't clean up */
Xunion REGS r;
Xint ch;
X	ch = getch();
X	r.h.ah = 0x00;
X	r.h.al = emx_vmode;	/* old video mode */
X	_int86(0x10, &r, &r);
X	if (ch == 3)
X		int_error("Interrupt",NO_CARET);
X}
X
XEMXVGA_reset()
X{
X}
X
X#ifdef EMXVESA
X/* untested */
XEMXVESA_options()
X{
X	extern struct value *const_express();
X	extern double real();
X
X	if (!END_OF_COMMAND) {
X		if (almost_equals(c_token,"d$efault")) {
X			emx_vesamode = G640x480x256;
X			c_token++;
X		}
X	}
X
X	if (!END_OF_COMMAND) {
X		/* We have a vesa mode specified */
X		struct value a;
X		emx_vesamode = (int)real(const_express(&a));
X	}
X
X	sprintf(term_options,"%d",emx_vesamode);
X}
X
XEMXVESA_init()
X{
X	if (!g_mode(emx_vesamode))
X		int_error("Couldn't select graphics mode",NO_CARET);
X	emx_xlast = g_xsize - 1;
X    	term_tbl[term].xmax = emx_xlast + 1;
X	emx_ylast = g_ysize - 1;
X    	term_tbl[term].ymax = emx_ylast + 1;
X	g_mode(GTEXT);
X}
X
XEMXVESA_graphics()
X{
X	g_mode(emx_vesamode);
X}
X
XEMXVESA_text()
X{
Xint ch;
X	ch = getch();
X	g_mode(GTEXT);
X	if (ch == 3)
X		int_error("Interrupt",NO_CARET);
X}
X
XEMXVESA_reset()
X{
X}
X#endif
X
X
XEMXVGA_linetype(linetype)
Xint linetype;
X{
X	if (linetype >= 13)
X		linetype %= 13;
X	emx_color = emx_colors[linetype+2];
X}
X
XEMXVGA_move(x,y)
Xunsigned int x,y;
X{
X	emx_startx = x;
X	emx_starty = y;
X}
X
X
XEMXVGA_vector(x,y)
Xunsigned int x,y;
X{
X	g_line(emx_startx,emx_ylast-emx_starty,x,emx_ylast-y,emx_color);
X	emx_startx = x;
X	emx_starty = y;
X}
X
X
Xint EMXVGA_text_angle(ang)
Xint ang;
X{
X	emx_angle=ang;
X	return TRUE;
X}
X
X
XEMXVGA_putc(x,y,c,angle)
Xunsigned int x,y;
Xchar c;
Xint angle;
X{
Xint i,j,k;
Xunsigned int pixelon;
X	i = (int)(c) - 32;
X	for (j=0; j<FNT5X9_VBITS; j++) {
X		for (k=0; k<FNT5X9_HBITS; k++) {
X			pixelon = (((unsigned int)(fnt5x9[i][j])) >> k & 1);
X			if (pixelon) {
X				switch(angle) {
X					case 0 : g_set(x+k,y-j,emx_color);
X							break;
X					case 1 : g_set(x-j,y-k,emx_color);
X							break;
X				}
X			}
X		}
X	}
X}
X
X
XEMXVGA_put_text(x,y,str)
Xunsigned int x, y;
Xchar *str;
X{
Xint i;
X	switch(emx_angle) {
X		case 0 : y -= EMXVGA_VCHAR/2;
X				break;
X		case 1 : x += EMXVGA_VCHAR/2;
X				break;
X	}
X	for (i=0;str[i];i++) {
X		EMXVGA_putc(x,emx_ylast-y,str[i],emx_angle);
X		switch(emx_angle) {
X			case 0 : x+=EMXVGA_HCHAR ;
X					break;
X			case 1 : y+=EMXVGA_HCHAR ;
X					break;
X		}
X	}
X}
X
END_OF_FILE
  if test 4303 -ne `wc -c <'gnuplot/term/emxvga.trm'`; then
    echo shar: \"'gnuplot/term/emxvga.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/emxvga.trm'
fi
if test -f 'gnuplot/term/gnugraph.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/gnugraph.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/gnugraph.trm'\" \(4989 characters\)
  sed "s/^X//" >'gnuplot/term/gnugraph.trm' <<'END_OF_FILE'
X/* GNUPLOT -- gnugraph.trm */
X/*
X * Copyright (C) 1993
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports:
X *  GNU plot(5) graphics language
X *
X * AUTHORS
X *  Tony Richardson from the unixplot.trm by Colin Kelley, Thomas Williams,
X *  and Russell Lang and from post.trm by Russell Lang.
X * 
X * send your comments or suggestions to (info-gnuplot@ames.arc.nasa.gov).
X * 
X * This version of the 'unixplot' driver produces device independent
X * output.  I've chosen parameter values so that the PostScript output
X * produced by plot2ps is 5" x 3".  You can use the 'set size' command
X * to get output up to 8.25" x 8.25", i.e. size values larger than
X * 1 are okay.
X */
X
X/*
XUnixplot library writes to stdout.  A fix was put in place by
X..!arizona!naucse!jdc to let set term and set output redirect
Xstdout.  All other terminals write to outfile.
X*/
X
X/* This is a device independent format, so the output should look
X * look "reasonable" on any output device.  I set things up there so
X * that the output of plot2ps is 5" x 3" (standard GNUPLOT size).
X * You can use GNUPLOT's size command to obtain plots to almost the
X * 8.25" x 8.25" limit.
X */
X
Xchar up_font[MAX_ID_LEN+1] = "Courier" ; /* name of font */
Xint up_fontsize = 10;
X
X/* plot2ps produces a 8.25" x 8.25" square. */
X#define UP_SCREENX 32768
X#define UP_SCREENY 32768
X#define UP_SCRXINC 8.25
X#define UP_SCRYINC 8.25
X
X/* We want a 5" x 3" graph by default. */
X#define UP_XINCHES 5
X#define UP_YINCHES 3
X/* UP_XMAX = (UP_SCREENX*UP_XINCHES)/UP_SCRXINC
X   UP_YMAX (UP_SCREENY*UP_YINCHES)/UP_SCRYINC */
X#define UP_XMAX 19859
X#define UP_YMAX 11565
X
X#define UP_XLAST (UP_XMAX - 1)
X#define UP_YLAST (UP_YMAX - 1)
X
X/* UP_VCHAR = ((UP_FONTSIZE*UP_YMAX)/(UP_YINCHES*72)) 
X            = UP_FONTSIZE*UP_VFONTSC
X   UP_HCHAR = ((UP_FONTSIZE/2)*UP_XMAX)/(UP_XINCHES*72))
X            = UP_FONTSIZE*UP_HFONTSC
X*/
X
X#define UP_VFONTSC  53.5
X#define UP_VCHAR    535   /* 10 * VFONTSC */
X#define UP_HFONTSC  27.6
X#define UP_HCHAR    276   /* 10 * HFONTSC */
X
X#define UP_VTIC (UP_YMAX/80)
X#define UP_HTIC (UP_XMAX/80)
X
X/* These offsets center plot2ps output in the middle of the page.  The
X * amount of resizing that can be done is limited. */
X/*
X * #define UP_XOFF 6454
X * #define UP_YOFF 10601
X */
X
X/* These offsets give a 1" offset from the lower left corner.  This
X * gives a greater range of permissible values in GNUPLOT's size
X * command. */
X#define UP_XOFF 3972
X#define UP_YOFF 3972
X
Xenum JUSTIFY up_justify=LEFT;
X
XUP_options()
X{
X        extern struct value *const_express();
X        extern double real();
X
X	if(!END_OF_COMMAND) {
X	  if(almost_equals(c_token,"d$efault")) {
X		strcpy(up_font,"Courier");
X		up_fontsize = 10;
X		term_tbl[term].v_char = (unsigned int)(up_fontsize*UP_VFONTSC);
X		term_tbl[term].h_char = (unsigned int)(up_fontsize*UP_HFONTSC);
X		c_token++;
X	  }
X	}
X
X        if (!END_OF_COMMAND && isstring(c_token)) {
X                quote_str(up_font,c_token);
X                c_token++;
X        }
X
X        if (!END_OF_COMMAND) {
X                /* We have font size specified */
X                struct value a;
X                up_fontsize = (int)real(const_express(&a));
X                term_tbl[term].v_char = (unsigned int)(up_fontsize*UP_VFONTSC);
X                term_tbl[term].h_char = (unsigned int)(up_fontsize*UP_HFONTSC);
X        }
X
X	sprintf(term_options,"\"%s\" %d",up_font,up_fontsize);
X}
X
XUP_init()
X{
X	openpl();
X	space(0,0,UP_SCREENX-1,UP_SCREENY-1);
X	fontname(up_font);
X	fontsize(up_fontsize);
X}
X
X
XUP_graphics()
X{
X	erase();
X}
X
X
XUP_text()
X{
X	/* Flush here so that output will be complete. */
X	fflush(stdout);
X}
X
X
XUP_linetype(linetype)
Xint linetype;
X{
Xstatic char *lt[2+5] = {"solid", "longdashed", "solid", "dotted","shortdashed",
X	"dotdashed", "longdashed"};
X
X	if (linetype >= 5)
X		linetype %= 5;
X	linemod(lt[linetype+2]);
X}
X
X
XUP_move(x,y)
Xunsigned int x,y;
X{
X	move(x+UP_XOFF,y+UP_YOFF);
X}
X
X
XUP_vector(x,y)
Xunsigned int x,y;
X{
X	cont(x+UP_XOFF,y+UP_YOFF);
X}
X
X
XUP_put_text(x,y,str)
Xunsigned int x,y;
Xchar str[];
X{
X	UP_move(x,y); /* Don't adjust x and y! It's done in UP_move. */
X	switch(up_justify) {
X	 case LEFT:
X	  alabel('l','c',str);
X	  break;
X	 case CENTRE:
X	  alabel('c','c',str);
X	  break;
X	 case RIGHT:
X	  alabel('r','c',str);
X	  break;
X	}
X
X}
X
XUP_text_angle(ang)
Xint ang;
X{
X	rotate(0,0,90*ang);
X	return TRUE;
X}
X
XUP_justify_text(mode)
Xenum JUSTIFY mode;
X{
X	up_justify=mode;
X	return TRUE;
X}
X
XUP_reset()
X{
X	closepl();
X}
X
END_OF_FILE
  if test 4989 -ne `wc -c <'gnuplot/term/gnugraph.trm'`; then
    echo shar: \"'gnuplot/term/gnugraph.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/gnugraph.trm'
fi
if test -f 'gnuplot/term/gpic.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/gpic.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/gpic.trm'\" \(4824 characters\)
  sed "s/^X//" >'gnuplot/term/gpic.trm' <<'END_OF_FILE'
X/*
X * $Id: gpic.trm%v 3.50 1993/07/09 05:35:24 woo Exp $
X */
X
X/* GNUPLOT - gpic.trm -*-C-*- */
X/*
X * Copyright (C) 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X */
X
X/*
X * This terminal driver supports:
X *   The GPIC graphics language for groff
X *
X * AUTHOR
X *  Sigfrid Lundberg
X *
X * send your comments or suggestions to (siglun@volterra.teorekol.lu.se).
X * 
X */
X
X
X#define GPIC_PTS_PER_INCH (72.27)
X#define GPIC_DOTS_PER_INCH (300)	
X#define GPIC_UNIT (GPIC_PTS_PER_INCH/GPIC_DOTS_PER_INCH) /* dot size in pt */
X
X/* 5 inches wide by 3 inches high (default) */
X#define GPIC_XMAX (5*GPIC_DOTS_PER_INCH)  
X#define GPIC_YMAX (3*GPIC_DOTS_PER_INCH)  
X
X#define GPIC_HTIC (5*GPIC_DOTS_PER_INCH/72)
X#define GPIC_VTIC (5*GPIC_DOTS_PER_INCH/72)
X#define GPIC_HCHAR (GPIC_DOTS_PER_INCH*53/10/72)
X#define GPIC_VCHAR (GPIC_DOTS_PER_INCH*11/72)	
X#define GPIC_coord(x) ((float)x)/((float)GPIC_DOTS_PER_INCH)
X
Xstatic float GPIC_x, GPIC_y;
Xstatic unsigned int GPIC_posx;
Xstatic unsigned int GPIC_posy;
Xstatic unsigned int GPIC_ltype;
Xenum JUSTIFY GPIC_justify=LEFT;
Xstatic int GPIC_angle=0;
X
X/* for DOTS point style */
X
X#define GPIC_NUMLINES 6		/* number of linetypes below */
Xstatic char *GPIC_lines[] = {
X    "thickness 1.0",			/* -2 border */
X    "", 		/* -1 axes */
X    "",			/*  0 solid thin  */
X    "dotted",
X    "dashed 0.05",			/*  1 solid thick */
X    "dashed 0.075",			/*  2 solid Thick */
X};
X
X
Xstatic int GPIC_type;		/* current line type */
Xstatic TBOOLEAN GPIC_inline = FALSE; /* are we in the middle of a line */
Xstatic int GPIC_linecount = 0; /* number of points in line so far */
X
X
XGPIC_options()
X{
X  float x,y;
X  struct value a;
X  extern struct value *const_express();
X  extern double real();
X
X  GPIC_x=0;
X  GPIC_y=0;
X
X  if (!END_OF_COMMAND) {
X    x = real(const_express(&a));
X    if (!END_OF_COMMAND) {
X      y = real(const_express(&a));
X      GPIC_x = x;
X      GPIC_y = y;
X    }
X  }
X
X  sprintf(term_options, "Origin is at (%f,%f)",GPIC_x,GPIC_y);
X
X}
X
XGPIC_init()
X{
X  GPIC_linetype(-1);
X  fprintf(outfile, ".\\\"GNUPLOT: GROFF picture using the gpic preprocessor\n");
X}
X
X
XGPIC_scale(xs, ys)
X     double xs, ys;			/* scaling factors */
X{
X  register struct termentry *t = &term_tbl[term];
X
X  /* we change the table for use in graphics.c and GPIC_graphics */
X  t->xmax = (unsigned int)(GPIC_XMAX * xs);
X  t->ymax = (unsigned int)(GPIC_YMAX * ys);
X
X  return(TRUE);
X}
X
X
XGPIC_graphics()
X{
X  register struct termentry *t = &term_tbl[term];
X
X  fprintf(outfile, ".PS %f %f\n",GPIC_coord(t->xmax),
X	  GPIC_coord(t->ymax));
X  fprintf(outfile,"x=%f; y=%f\n",GPIC_x, GPIC_y);
X}
X
X
XGPIC_text()
X{
X  GPIC_close_line();
X  fprintf(outfile, ".PE\n");
X}
X
XGPIC_linetype(linetype)
X     int linetype;
X{
X  if (linetype >= GPIC_NUMLINES-2)
X    linetype %= (GPIC_NUMLINES-2);
X  GPIC_ltype = linetype;
X}
X
XGPIC_close_line()
X{
X  if(GPIC_linecount>0) {
X    fprintf(outfile,"; reset linewid\n");
X    GPIC_linecount = 0;
X  }
X}
X
XGPIC_move(x,y)
X     unsigned int x,y;
X{
X  GPIC_close_line();
X  fprintf(outfile,"move to (x+%f,y+%f)\n",GPIC_coord(x),GPIC_coord(y));
X  GPIC_linecount = 1;
X}
X
X
XGPIC_vector(ux,uy)
X     unsigned int ux,uy;
X{
X  if(GPIC_linecount==1) {
X    fprintf(outfile,"line %s to (x+%f,y+%f)",
X	    GPIC_lines[GPIC_ltype+2],
X	    GPIC_coord(ux),GPIC_coord(uy));
X  } else {
X    fprintf(outfile," \\\n");
X    fprintf(outfile,"   then to (x+%f,y+%f)",GPIC_coord(ux),GPIC_coord(uy));
X  }
X  GPIC_linecount++;
X}
X
X
XGPIC_arrow(sx,sy, ex,ey, head)
X	int sx,sy, ex,ey;
X	TBOOLEAN head;
X{
X  GPIC_close_line();
X  if(head) {
X    fprintf(outfile,"arrowhead=7; arrow from x+%f,y+%f to x+%f,y+%f\n",
X	    GPIC_coord(sx),GPIC_coord(sy),GPIC_coord(ex),GPIC_coord(ey));
X  } else { 
X    fprintf(outfile,"line from x+%f,y+%f to x+%f,y+%f\n",
X	    GPIC_coord(sx),GPIC_coord(sy),GPIC_coord(ex),GPIC_coord(ey));
X  }
X}
X
X
XGPIC_put_text(x, y, str)
X	int x,y;				/* reference point of string */
X	char str[];			/* the text */
X{
X  GPIC_close_line();
X  fprintf(outfile, "\"%s\" ",str);
X  switch(GPIC_justify) {
X  case LEFT: {
X    fprintf(outfile,"ljust ");
X    break;
X  }
X  case CENTRE: {
X    fprintf(outfile," ");
X    break;
X  }
X  case RIGHT: {
X    fprintf(outfile,"rjust ");
X    break;
X  }
X  }
X  fprintf(outfile,"at x+%f,y+%f\n",GPIC_coord(x),GPIC_coord(y));
X}
X
X
X
Xint GPIC_justify_text(mode)
X	enum JUSTIFY mode;
X{
X  GPIC_justify = mode;
X  return (TRUE);
X}
X
Xint GPIC_text_angle(angle)
X	int angle;
X{
X  GPIC_close_line();
X  return (FALSE);
X}
X
XGPIC_reset()
X{
X  fflush(outfile);
X}
X
X
X
X
X
X
X
END_OF_FILE
  if test 4824 -ne `wc -c <'gnuplot/term/gpic.trm'`; then
    echo shar: \"'gnuplot/term/gpic.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/gpic.trm'
fi
if test -f 'gnuplot/term/t410x.trm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gnuplot/term/t410x.trm'\"
else
  echo shar: Extracting \"'gnuplot/term/t410x.trm'\" \(5083 characters\)
  sed "s/^X//" >'gnuplot/term/t410x.trm' <<'END_OF_FILE'
X/*
X * $Id: t410x.trm%v 3.50.1.9 1993/08/05 05:38:59 woo Exp $
X *
X */
X
X/* GNUPLOT - t410x.trm */
X/*
X * Copyright (C) 1990 - 1993   
X *
X * Permission to use, copy, and distribute this software and its
X * documentation for any purpose with or without fee is hereby granted, 
X * provided that the above copyright notice appear in all copies and 
X * that both that copyright notice and this permission notice appear 
X * in supporting documentation.
X *
X * Permission to modify the software is granted, but not the right to
X * distribute the modified code.  Modifications are to be distributed 
X * as patches to released version.
X *  
X * This software  is provided "as is" without express or implied warranty.
X * 
X * This file is included by ../term.c.
X *
X * This terminal driver supports: Tektronix 410x and 420x series terminals
X *
X * AUTHORS
X *   Colin Kelley, Thomas Williams
X * 
X * send your comments or suggestions to (info-gnuplot@dartmouth.edu).
X * 
X */
X
X/* Tektronix 410X and 420X driver written by Cary D. Renzema.
X * email address: caryr@vice.ico.tek.com
X *
X * I've tested this driver on the following terminals: 4106, 4107A, 4109
X * and 4207.  It should work, without editing, on other terminals in the
X * 410x and 420x families.  It will probably need to be changed to work
X * on a 4105 (screen size and character rotation are two guesses).  This
X * file can also be used as a start for a 411x driver.
X *
X * Cary R.
X * April 5, 1990
X */
X
X#ifdef T410X
X
X#define T410XXMAX 4095
X#define T410XYMAX 3131
X
X#define T410XVCHAR	71
X#define T410XHCHAR	51
X#define T410XVTIC	36
X#define T410XHTIC	36	
X
Xstatic int T410X_angle=0;
X
XT410X_init()
X{
X	(void) fprintf(outfile, "\033%%!0\033MN0\033MCB7C;\033MQ1\033MT1");
X	(void) fprintf(outfile, "\033MG1\033RK!\033SK!\033LZ\033%%!1");
X/*
X	 1. set tek mode
X	 2. set character path to 0 (characters placed equal to rotation)
X	 3. set character size to 59 height
X	 4. set character precision to string
X	 5. set character text index to 1
X	 6. set character write mode to overstrike
X	 7. clear the view
X	 8. clear the segments
X	 9. clear the dialog buffer
X	10. set ansi mode
X*/
X	(void) fflush(outfile);
X}
X
X
XT410X_reset()
X{
X	(void) fprintf(outfile, "\033%%!0\033LZ\033%%!1");
X/*
X	1. set tek mode
X	2. clear the dialog buffer
X	3. set ansi mode
X*/
X	(void) fflush(outfile);
X}
X
X
XT410X_graphics()
X{
X	(void) fprintf(outfile, "\033%%!0\033\014\033LV0");
X/*
X	1. set tek mode
X	2. clear the screen
X	3. set dialog area invisible
X*/
X	(void) fflush(outfile);
X}
X
XT410X_text()
X{
X	(void) fprintf(outfile, "\033LV1\033%%!1");
X/*
X	1. set dialog area visible
X	2. set ansi mode
X*/
X	(void) fflush(outfile);
X}
X
X
XT410X_move(x, y)
Xunsigned int x, y;
X{
X	(void) fprintf(outfile, "\033LF");
X	(void) T410X_encode_x_y(x, y);
X	(void) fflush(outfile);
X}
X
X
XT410X_vector(x, y)
Xunsigned int x, y;
X{
X	(void) fprintf(outfile, "\033LG");
X	(void) T410X_encode_x_y(x, y);
X	(void) fflush(outfile);
X}
X
X
XT410X_point(x, y, number)
Xunsigned int x, y;
Xint number;
X{
X	(void) fprintf(outfile, "\033MM");
X	(void) T410X_encode_int(max(number, 0)%11);
X	(void) fprintf(outfile, "\033LH");
X	(void) T410X_encode_x_y(x, y);
X	(void) fflush(outfile);
X}
X
X
XT410X_linetype(linetype)
Xint linetype;
X{
X	switch (linetype) {
X		case -1:
X			(void) fprintf(outfile, "\033ML5");
X			break;
X		case -2:
X			(void) fprintf(outfile, "\033ML?");
X			break;
X		default:
X			(void) fprintf(outfile, "\033ML");
X			(void) T410X_encode_int(linetype%14+2);
X			break;
X	}
X	(void) fprintf(outfile, "\033MV");
X	(void) T410X_encode_int(max(linetype, 0)%8);
X	(void) fflush(outfile);
X}
X
X
XT410X_put_text(x, y, str)
Xunsigned int x, y;
Xchar str[];
X{
X
X	if (T410X_angle == 0) {
X		(void) T410X_move(x, y-T410XVCHAR/2+6);
X		(void) fprintf(outfile, "\033MR00");
X	} else {
X		(void) T410X_move(x+T410XHCHAR/2-6, y);
X		(void) fprintf(outfile, "\033MRE:0");
X	}
X	(void) fprintf(outfile, "\033LT");
X	(void) T410X_encode_int(strlen(str));
X	(void) fputs(str, outfile);
X	(void) fflush(outfile);
X}
X
XT410X_text_angle(ang)
Xint ang;
X{
X
X	T410X_angle = ang;
X	return(TRUE);
X}
X
X/* These last two routines are based on fortran code found in the
X * 4106/4107/4109/CX PROGRAMMERS manual.
X */
X
XT410X_encode_x_y(x, y)
Xunsigned int x, y;
X{
X	static char chix=0, chiy=0, cloy=0, ceb=0;
X
X	register unsigned int hix, lox, hiy, loy, eb, lx, ly;
X
X	lx = (x <= T410XXMAX) ? x : T410XXMAX;
X	ly = (y <= T410XYMAX) ? y : T410XYMAX;
X
X	hix = lx/128 + 32;
X	lox = (lx/4)%32 + 64;
X	hiy = ly/128 + 32;
X	loy = (ly/4)%32 + 96;
X	eb = (ly%4)*4 + lx%4 + 96;
X
X	if (chiy != hiy) (void) putc(hiy, outfile);
X	if (ceb != eb) (void) putc(eb, outfile);
X	if ((cloy!=loy) || (ceb!=eb) || (chix!=hix)) (void) putc(loy, outfile);
X	if (chix != hix) (void) putc(hix, outfile);
X	(void) putc(lox, outfile);
X
X	chix = hix;
X	chiy = hiy;
X	cloy = loy;
X	ceb = eb;
X}
X
X
XT410X_encode_int(number)
Xint number;
X{
X	register unsigned int mag, hi1, hi2, lo;
X
X	mag = abs(number);
X
X	hi1 = mag/1024 + 64;
X	hi2 = (mag/16)%64 + 64;
X	lo = mag%16 + 32;
X
X	if (number >= 0) lo += 16;
X
X	if (hi1 != 64) (void) putc(hi1, outfile);
X	if ((hi2 != 64) || (hi1 != 64)) (void) putc(hi2, outfile);
X	(void) putc(lo, outfile);
X
X}
X
X
X#endif /* T410X */
END_OF_FILE
  if test 5083 -ne `wc -c <'gnuplot/term/t410x.trm'`; then
    echo shar: \"'gnuplot/term/t410x.trm'\" unpacked with wrong size!
  fi
  # end of 'gnuplot/term/t410x.trm'
fi
echo shar: End of archive 29 \(of 33\).
cp /dev/null ark29isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 33 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
