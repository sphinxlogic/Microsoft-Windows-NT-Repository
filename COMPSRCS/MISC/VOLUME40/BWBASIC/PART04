Newsgroups: comp.sources.misc
From: tcamp@delphi.com (Ted A. Campbell)
Subject: v40i055:  bwbasic - Bywater BASIC interpreter version 2.10, Part04/15
Message-ID: <1993Oct29.162506.3537@sparky.sterling.com>
X-Md4-Signature: ef4bc5de3fd9dac027682183ba78e8f0
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 29 Oct 1993 16:25:06 GMT
Approved: kent@sparky.sterling.com

Submitted-by: tcamp@delphi.com (Ted A. Campbell)
Posting-number: Volume 40, Issue 55
Archive-name: bwbasic/part04
Environment: UNIX, DOS
Supersedes: bwbasic: Volume 33, Issue 37-47

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  bwbasic-2.10/README bwbasic-2.10/bwb_stc.c
#   bwbasic-2.10/configure
# Wrapped by kent@sparky on Thu Oct 21 10:47:49 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 15)."'
if test -f 'bwbasic-2.10/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bwbasic-2.10/README'\"
else
  echo shar: Extracting \"'bwbasic-2.10/README'\" \(5592 characters\)
  sed "s/^X//" >'bwbasic-2.10/README' <<'END_OF_FILE'
X
X
X                        Bywater Software Announces
X
X
X               Bywater BASIC Interpreter/Shell, version 2.10
X               ---------------------------------------------
X
X                    Copyright (c) 1993, Ted A. Campbell
X                  for bwBASIC version 2.10, 11 October 1993
X
X
X
XDESCRIPTION:
X
X   The Bywater BASIC Interpreter (bwBASIC) implements a large
X   superset of the ANSI Standard for Minimal BASIC (X3.60-1978)
X   and a significant subset of the ANSI Standard for Full BASIC
X   (X3.113-1987) in C. It also offers shell programming facilities
X   as an extension of BASIC. bwBASIC seeks to be as portable
X   as possible.
X
X   This version of Bywater BASIC is released under the terms of the 
X   GNU General Public License (GPL), which is distributed with this 
X   software in the file "COPYING".  The GPL specifies the terms 
X   under which users may copy and use the software in this distribution.
X
X   A separate license is available for commercial distribution,
X   for information on which you should contact the author.
X
X
XIMPROVEMENTS OVER PREVIOUS VERSION (1.11):
X
X   * now compilable on "stock" (older K&R specification) C compilers; 
X
X   * implements ANSI-BASIC-style structured programming, with
X     called subroutines, multi-line functions, multi-line IF-THEN
X     ELSE statements, SELECT CASE statements, etc.;
X
X   * new enhancements to the interactive environment, such as DO NUM
X     and DO UNNUM to number or unnumber all program lines;
X
X   * addition of some hardware-specific commands such as CLS, LOCATE,
X     and INKEY$ (at present for IBM PC and compatibles, using the
X     Microsoft QuickC compiler), opening the way for more hardware-
X     specific commands and functions in the future; 
X
X   * general improvements to reliability and portability, including
X     more extensive testing than previous versions; 
X
X
XOBTAINING THE SOURCE CODE:
X
X   The source code for bwBASIC 2.10 will be posted to network news
X   groups and is available immediately by anonymous ftp. To obtain
X   the source code, ftp to site ftp.eng.umd.edu, cd to pub/basic and
X   get the file bwbasic-2.10.tar.gz.
X
X
XCOMMUNICATIONS:
X
X   email:  tcamp@delphi.com
X
X
XA LIST OF BASIC COMMANDS AND FUNCTIONS IMPLEMENTED in bwBASIC 2.10:
X
X   Be aware that many of these commands and functions will not be
X   available unless you have set certain flags in the header files.
X
X   ABS( number )
X   ASC( string$ )
X   ATN( number )
X   CALL subroutine-name
X   CASE constant | IF partial-expression | ELSE
X   CHAIN file-name
X   CHDIR pathname
X   CHR$( number )
X   CINT( number )
X   CLEAR
X   CLOSE [[#]file-number]...
X   CLS
X   COMMON variable [, variable...]
X   COS( number )
X   CSNG( number )
X   CVD( string$ )
X   CVI( string$ )
X   CVS( string$ )
X   DATA constant[,constant]...
X   DATE$
X   DEF FNname(arg...)] = expression
X   DEFDBL letter[-letter](, letter[-letter])...
X   DEFINT letter[-letter](, letter[-letter])...
X   DEFSNG letter[-letter](, letter[-letter])...
X   DEFSTR letter[-letter](, letter[-letter])...
X   DELETE line[-line]
X   DIM variable(elements...)[variable(elements...)]...
X   DO NUM|UNNUM
X   DO [WHILE expression]
X   EDIT		(* depends on variable BWB.EDITOR$)
X   ELSE
X   ELSEIF
X   END FUNCTION | IF | SELECT | SUB
X   ENVIRON variable-string$ = string$
X   ENVIRON$( variable-string )
X   EOF( device-number )
X   ERASE variable[, variable]...
X   ERL
X   ERR
X   ERROR number
X   EXIT FOR|DO
X   EXP( number )
X   FIELD [#] device-number, number AS string-variable [, number AS string-variable...]
X   FILES filespec$	(* depends on variable BWB.FILES$)
X   FOR counter = start TO finish [STEP increment]
X   FUNCTION function-definition
X   GET [#] device-number [, record-number]
X   GOSUB line | label
X   GOTO line | label
X   HEX$( number )
X   IF expression THEN [statement [ELSE statement]]
X   INKEY$
X   INPUT [# device-number]|[;]["prompt string";]list of variables
X   INSTR( [start-position,] string-searched$, string-pattern$ )
X   INT( number )
X   KILL file-name
X   LEFT$( string$, number-of-spaces )
X   LEN( string$ )
X   LET variable = expression
X   LINE INPUT [[#] device-number,]["prompt string";] string-variable$
X   LIST line[-line]
X   LOAD file-name
X   LOC( device-number )
X   LOCATE
X   LOF( device-number )
X   LOG( number )
X   LOOP [UNTIL expression]
X   LSET string-variable$ = expression
X   MERGE file-name
X   MID$( string$, start-position-in-string[, number-of-spaces ] )
X   MKD$( number )
X   MKDIR pathname
X   MKI$( number )
X   MKS$( number )
X   NAME old-file-name AS new-file-name
X   NEW
X   NEXT counter
X   OCT$( number )
X   ON variable GOTO|GOSUB line[,line,line,...]
X   ON ERROR GOSUB line | label
X   OPEN O|I|R, [#]device-number, file-name [,record length]
X        file-name FOR INPUT|OUTPUT|APPEND AS [#]device-number [LEN = record-length]
X   OPTION BASE number
X   POS
X   PRINT [# device-number,][USING format-string$;] expressions...
X   PUT [#] device-number [, record-number]
X   RANDOMIZE number
X   READ variable[, variable]...
X   REM string
X   RESTORE line
X   RETURN
X   RIGHT$( string$, number-of-spaces )
X   RMDIR pathname
X   RND( number )
X   RSET string-variable$ = expression
X   RUN [line]|[file-name]
X   SAVE file-name
X   SELECT CASE expression
X   SGN( number )
X   SIN( number )
X   SPACE$( number )
X   SPC( number )
X   SQR( number )
X   STOP
X   STR$( number )
X   STRING$( number, ascii-value|string$ )
X   SUB subroutine-name
X   SWAP variable, variable
X   SYSTEM
X   TAB( number )
X   TAN( number )
X   TIME$
X   TIMER
X   TROFF
X   TRON
X   VAL( string$ )
X   WEND
X   WHILE expression
X   WIDTH [# device-number,] number
X   WRITE [# device-number,] element [, element ]....
X
END_OF_FILE
  if test 5592 -ne `wc -c <'bwbasic-2.10/README'`; then
    echo shar: \"'bwbasic-2.10/README'\" unpacked with wrong size!
  fi
  # end of 'bwbasic-2.10/README'
fi
if test -f 'bwbasic-2.10/bwb_stc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bwbasic-2.10/bwb_stc.c'\"
else
  echo shar: Extracting \"'bwbasic-2.10/bwb_stc.c'\" \(52211 characters\)
  sed "s/^X//" >'bwbasic-2.10/bwb_stc.c' <<'END_OF_FILE'
X/***************************************************************
X
X        bwb_stc.c       Commands Related to Structured Programming
X                        for Bywater BASIC Interpreter
X
X                        Commands:	CALL
X					SUB
X					FUNCTION
X					END SUB
X					END FUNCTION
X
X                        Copyright (c) 1993, Ted A. Campbell
X                        Bywater Software
X
X                        email: tcamp@delphi.com
X
X        Copyright and Permissions Information:
X
X        All U.S. and international rights are claimed by the author,
X        Ted A. Campbell.
X
X	This software is released under the terms of the GNU General
X	Public License (GPL), which is distributed with this software
X	in the file "COPYING".  The GPL specifies the terms under
X	which users may copy and use the software in this distribution.
X
X	A separate license is available for commercial distribution,
X	for information on which you should contact the author.
X
X***************************************************************/
X
X#include <stdio.h>
X#include <ctype.h>
X
X#include "bwbasic.h"
X#include "bwb_mes.h"
X
X/* prototypes */
X
X#if ANSI_C
Xstatic int fslt_clear( void );
Xstatic int fslt_add( struct bwb_line *line, int *position, int code );
Xstatic struct bwb_line *fslt_findl( char *buffer );
Xstatic struct fslte    *fslt_findf( char *buffer );
Xstatic int scan_getcmd( struct bwb_line *line, int *position );
Xstatic int scan_readargs( struct fslte *f,
X   struct bwb_line *line, int *position );
Xstatic int call_readargs( struct fslte *f,
X   char *expression, int *position );
Xstatic int is_endsub( struct bwb_line *l );
Xstatic struct bwb_line *find_endsub( struct bwb_line *l );
Xstatic struct bwb_line *bwb_loopuntil( struct bwb_line *l );
Xstruct bwb_variable *bwb_vtov( struct bwb_variable *dst, struct bwb_variable *src );
Xstruct bwb_variable *bwb_etov( struct bwb_variable *dst, struct exp_ese *src );
Xstruct bwb_variable *var_pos( struct bwb_variable *firstvar, int p );
Xint fslt_addcallvar( struct bwb_variable *v );
Xint fslt_addlocalvar( struct fslte *f, struct bwb_variable *v );
X#else
Xstatic int fslt_clear();
Xstatic int fslt_add();
Xstatic struct bwb_line *fslt_findl();
Xstatic struct fslte    *fslt_findf();
Xstatic int scan_getcmd();
Xstatic int scan_readargs();
Xstatic int call_readargs();
Xstatic int is_endsub();
Xstatic struct bwb_line *find_endsub();
Xstatic struct bwb_line *bwb_loopuntil();
Xstruct bwb_variable *bwb_vtov();
Xstruct bwb_variable *bwb_etov();
Xstruct bwb_variable *var_pos();
Xint fslt_addcallvar();
Xint fslt_addlocalvar();
X#endif				/* ANSI_C for prototypes */
X
X/***************************************************************
X
X        FUNCTION:       bwb_scan()
X
X        DESCRIPTION:	This function scans all lines of the
X        		program in memory and creates a FUNCTION-
X        		SUB lookup table (fslt) for the program.
X
X***************************************************************/
X
X#if ANSI_C
Xint
Xbwb_scan( void )
X#else
Xint
Xbwb_scan()
X#endif
X   {
X   struct bwb_line *current;
X   int position;
X   int c;
X
X#if PROG_ERRORS
X   if ( CURTASK rescan != TRUE )
X      {
X      bwb_error( "in bwb_scan(): call to scan while CURTASK rescan != TRUE" );
X      return FALSE;
X      }
X#endif
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_scan(): beginning scan..." );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* first run through the FUNCTION - SUB loopkup table
X      and free any existing memory */
X
X   fslt_clear();
X
X   /* run through the list of lines and identify SUB and FUNCTION statements */
X
X   for ( current = CURTASK bwb_start.next; current != &CURTASK bwb_end; current = current->next )
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_scan(): scanning line <%d>", current->number );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      c = scan_getcmd( current, &position );
X      if ( c == getcmdnum( CMD_SUB ))
X         {
X         fslt_add( current, &position, EXEC_CALLSUB );
X         }
X      else if ( c == getcmdnum( CMD_FUNCTION ))
X         {
X         fslt_add( current, &position, EXEC_FUNCTION );
X         }
X      else if ( c == getcmdnum( CMD_DEF ))
X         {
X         fslt_add( current, &position, EXEC_FUNCTION );
X         }
X#if STRUCT_CMDS
X      else if ( c == getcmdnum( CMD_LABEL ))
X         {
X         fslt_add( current, &position, EXEC_LABEL );
X         }
X#endif
X      }
X
X   /* return */
X
X   CURTASK rescan = FALSE;
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       fslt_clear()
X
X        DESCRIPTION:	This C function clears all existing memory
X        		in the FUNCTION-SUB lookup table.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xfslt_clear( void )
X#else
Xstatic int
Xfslt_clear()
X#endif
X   {
X   struct fslte *current, *next;
X   struct bwb_variable *c, *n;
X
X   /* run through table and clear memory */
X
X   next = CURTASK fslt_start.next;
X   for ( current = CURTASK fslt_start.next; current != &CURTASK fslt_end;
X      current = next )
X      {
X
X      /* check for local variables and free them */
X
X      c = current->local_variable;
X      while ( c != NULL )
X         {
X         n = c->next;
X         free( c );
X         c = n;
X         }
X
X      next = current->next;
X      free( current );
X      }
X
X   /* reset linkage */
X
X   CURTASK fslt_start.next = &CURTASK fslt_end;
X
X   return TRUE;
X   }
X
X/***************************************************************
X
X        FUNCTION:       scan_getcmd()
X
X        DESCRIPTION:	This command returns the command number
X        		for the first BASIC command word encountered
X        		in a line.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xscan_getcmd( struct bwb_line *line, int *position )
X#else
Xstatic int
Xscan_getcmd( line, position )
X   struct bwb_line *line;
X   int *position;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X
X   *position = 0;
X   adv_ws( line->buffer, position );
X
X   /* check for NULL line */
X
X   if ( line->buffer[ *position ] == '\0' )
X      {
X      return -1;
X      }
X
X   /* check for line number and advance beyond it */
X
X   if ( isdigit( line->buffer[ *position ] ))
X      {
X      scan_element( line->buffer, position, tbuf );
X      }
X
X   /* get the command element in the buffer */
X
X   scan_element( line->buffer, position, tbuf );
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in scan_getcmd(): scanning element <%s>", tbuf );
X   bwb_debug( bwb_ebuf );
X#endif
X
X#if STRUCT_CMDS
X
X   if ( is_label( tbuf ) == TRUE )
X      {
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in scan_getcmd(): found label <%s>", tbuf );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      return getcmdnum( CMD_LABEL );
X      }
X
X#endif
X
X   bwb_strtoupper( tbuf );
X
X   /* return command number */
X
X   return getcmdnum( tbuf );
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       scan_element()
X
X        DESCRIPTION:    This function reads characters in <buffer>
X                        beginning at <pos> and advances past a
X                        line element, incrementing <pos> appropri-
X                        ately and returning the line element in
X			<element>.
X
X			This function is almost identical to adv_element(),
X			but it will not stop at a full colon.  This is
X			necessary to detect a label in the first element
X			position.  If MULTISEG_LINES is defined as TRUE,
X			adv_element() will stop at the colon, interpreting
X			it as the end-of-segment marker.
X
X***************************************************************/
X
X#if ANSI_C
Xextern int
Xscan_element( char *buffer, int *pos, char *element )
X#else
Xint
Xscan_element( buffer, pos, element )
X   char *buffer;
X   int *pos;
X   char *element;
X#endif
X   {
X   int loop;                                    /* control loop */
X   int e_pos;                                   /* position in element buffer */
X   int str_const;                               /* boolean: building a string constant */
X
X   /* advance beyond any initial whitespace */
X
X   adv_ws( buffer, pos );
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in adv_element(): receieved <%s>.", &( buffer[ *pos ] ));
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* now loop while building an element and looking for an
X      element terminator */
X
X   loop = TRUE;
X   e_pos = 0;
X   element[ e_pos ] = '\0';
X   str_const = FALSE;
X
X   while ( loop == TRUE )
X      {
X      switch( buffer[ *pos ] )
X         {
X         case ',':                      /* element terminators */
X         case ';':
X	 case '=':
X	 case ' ':
X         case '\t':
X         case '\0':
X         case '\n':
X         case '\r':
X            if ( str_const == TRUE )
X               {
X               element[ e_pos ] = buffer[ *pos ];
X               ++e_pos;
X               ++( *pos );
X               element[ e_pos ] = '\0';
X               }
X            else
X               {
X               return TRUE;
X               }
X            break;
X
X         case '\"':                     /* string constant */
X            element[ e_pos ] = buffer[ *pos ];
X            ++e_pos;
X            ++( *pos );
X            element[ e_pos ] = '\0';
X            if ( str_const == TRUE )    /* termination of string constant */
X               {
X               return TRUE;
X               }
X            else                        /* beginning of string constant */
X               {
X               str_const = TRUE;
X               }
X            break;
X
X         default:
X            element[ e_pos ] = buffer[ *pos ];
X            ++e_pos;
X            ++( *pos );
X            element[ e_pos ] = '\0';
X            break;
X         }
X      }
X
X   /* This should not happen */
X
X   return FALSE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       fslt_add()
X
X        DESCRIPTION:	This C function adds an entry to the
X        		FUNCTION-SUB lookup table.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xfslt_add( struct bwb_line *line, int *position, int code )
X#else
Xstatic int
Xfslt_add( line, position, code )
X   struct bwb_line *line;
X   int *position;
X   int code;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X   char *name;
X   struct bwb_variable *v;
X   struct fslte *f, *n;
X   int p;
X
X   /* get the element for name */
X
X   if ( code == EXEC_LABEL )
X      {
X      p = 0;
X      scan_element( line->buffer, &p, tbuf );
X      if ( isdigit( tbuf[ 0 ] ))
X         {
X	 scan_element( line->buffer, &p, tbuf );
X         }
X      tbuf[ strlen( tbuf ) - 1 ] = '\0';
X      }
X   else
X      {
X      adv_ws( line->buffer, position );
X      exp_getvfname( &( line->buffer[ *position ] ), tbuf );
X      *position += strlen( tbuf );
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in fslt_add(): adding SUB/FUNCTION/LABEL code <%d> name <%s>",
X      code, tbuf );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* get memory for name buffer */
X
X   if ( ( name = calloc( 1, strlen( tbuf ) + 1 ) ) == NULL )
X      {
X#if PROG_ERRORS
X      bwb_error( "in fslt_add(): failed to get memory for name buffer" );
X#else
X      bwb_error( err_getmem );
X#endif
X      return FALSE;
X      }
X
X   strcpy( name, tbuf );
X
X   /* get memory for fslt structure */
X
X   if ( ( f = calloc( 1, sizeof( struct fslte ) ) ) == NULL )
X      {
X#if PROG_ERRORS
X      bwb_error( "in fslt_add(): failed to get memory for fslt structure" );
X#else
X      bwb_error( err_getmem );
X#endif
X      return FALSE;
X      }
X
X   /* fill in structure */
X
X   f->line = line;
X   f->name = name;
X   f->code = code;
X   f->local_variable = NULL;
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in fslt_add(): current buffer <%s>",
X      &( line->buffer[ *position ] ) );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* read arguments */
X
X   adv_ws( line->buffer, position );
X   if ( line->buffer[ *position ] == '(' )
X      {
X      scan_readargs( f, line, position );
X      }
X
X   /* if function, add one more local variable expressing the name
X      of the function */
X
X   if ( code == EXEC_FUNCTION )
X      {
X
X      v = var_new( tbuf );
X      fslt_addlocalvar( f, v );
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in fslt_add(): added function-name variable <%s>",
X         v->name );
X      bwb_debug( bwb_ebuf );
X      getchar();
X#endif
X
X      }
X
X   /* establish linkages */
X
X   n = CURTASK fslt_start.next;
X   CURTASK fslt_start.next = f;
X   f->next = n;
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       scan_readargs()
X
X        DESCRIPTION:	This C function reads arguments (variable
X        		names for an entry added to the FUNCTION-
X			SUB lookup table.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xscan_readargs( struct fslte *f, struct bwb_line *line, int *position )
X#else
Xstatic int
Xscan_readargs( f, line, position )
X   struct fslte *f;
X   struct bwb_line *line;
X   int *position;
X#endif
X   {
X   int control_loop;
X   struct bwb_variable *v;
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in scan_readargs(): reading arguments, buffer <%s>",
X      &( line->buffer[ *position ] ) );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* if we are at begin paren, advance */
X
X   if ( line->buffer[ *position ] == '(' )
X      {
X      ++( *position );
X      }
X
X   /* loop through looking for arguments */
X
X   control_loop = TRUE;
X   adv_ws( line->buffer, position );
X   while ( control_loop == TRUE )
X      {
X
X      switch( line->buffer[ *position ] )
X         {
X         case '\n':		/* premature end of line */
X         case '\r':
X         case '\0':
X            control_loop = FALSE;
X            f->startpos = *position;
X            bwb_error( err_syntax );
X            return FALSE;
X         case ')':		/* end of argument list */
X            ++( *position );
X            control_loop = FALSE;
X            f->startpos = *position;
X            return TRUE;
X
X         default:		/* presume beginning of argument == variable name */
X
X            exp_getvfname( &( line->buffer[ *position ] ), tbuf );
X            *position += strlen( tbuf );
X
X#if INTENSIVE_DEBUG
X            sprintf( bwb_ebuf, "in scan_readargs(): read argument <%s>",
X               tbuf );
X            bwb_debug( bwb_ebuf );
X#endif
X
X            /* initialize the variable and add it to local chain */
X
X            v = var_new( tbuf );
X            fslt_addlocalvar( f, v );
X
X            /* advance past the comma */
X
X            if ( line->buffer[ *position ] == ',' )
X               {
X               ++( *position );
X               }
X
X            break;
X         }
X
X      adv_ws( line->buffer, position );
X      }
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       call_readargs()
X
X        DESCRIPTION:	This C function reads arguments (variable
X        		names for a subroutine CALL or function
X			call.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xcall_readargs( struct fslte *f, char *expression, int *position )
X#else
Xstatic int
Xcall_readargs( f, expression, position )
X   struct fslte *f;
X   char *expression;
X   int *position;
X#endif
X   {
X   int control_loop;
X   struct bwb_variable *v, *c;
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X   int argument_counter;
X   int local_pos, single_var;
X   struct exp_ese *e;
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in call_readargs(): reading arguments, buffer <%s>",
X      &( expression[ *position ] ) );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* if we are at begin paren, advance */
X
X   if ( expression[ *position ] == '(' )
X      {
X      ++( *position );
X      }
X
X   /* loop through looking for arguments */
X
X   control_loop = TRUE;
X   argument_counter = 0;
X
X   while ( control_loop == TRUE )
X      {
X
X      adv_ws( expression, position );
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in call_readargs(): in loop, buffer <%s>",
X         &( expression[ *position ] ) );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      switch( expression[ *position ] )
X         {
X         case '\n':		/* end of line */
X         case '\r':
X	 case '\0':
X#if MULTISEG_LINES
X	 case ':':              /* end of segment */
X#endif
X            control_loop = FALSE;
X            return FALSE;
X
X         case ')':		/* end of argument list */
X            ++( *position );
X            control_loop = FALSE;
X            return TRUE;
X
X         default:		/* presume beginning of argument */
X
X            /* read the first word to see if it is a single variable name */
X
X            single_var = FALSE;
X            exp_getvfname( &( expression[ *position ] ), tbuf );
X            local_pos = *position + strlen( tbuf );
X
X            adv_ws( expression, &local_pos );
X
X#if INTENSIVE_DEBUG
X            sprintf( bwb_ebuf, "in call_readargs(): in loop, tbuf <%s>",
X               tbuf );
X            bwb_debug( bwb_ebuf );
X#endif
X
X            /* check now for the single variable name */
X
X            if ( strlen( tbuf ) == 0 )
X               {
X               single_var = FALSE;
X               }
X
X            else
X               {
X               switch ( expression[ local_pos ] )
X                  {
X                  case ')':		/* end of argument list */
X
X#if INTENSIVE_DEBUG
X		     sprintf( bwb_ebuf, "in call_readargs(): detected end of argument list" );
X		     bwb_debug( bwb_ebuf );
X#endif
X
X		     ++local_pos;       /* and fall through */
X                  case '\n':		/* end of line */
X                  case '\r':
X		  case '\0':
X#if MULTISEG_LINES
X		  case ':':             /* end of segment */
X#endif
X		     control_loop = FALSE;      /* and fall through */
X						/* added 1993-06-16 */
X		  case ',':             /* end of argument */
X
X		     single_var = TRUE;
X
X		     /* look for variable from previous (calling) level */
X
X		     -- CURTASK exsc;
X		     v = var_find( tbuf );      /* find variable there */
X		     ++ CURTASK exsc;
X
X		     c = var_pos( CURTASK excs[ CURTASK exsc ].local_variable,
X                        argument_counter );	/* find local equivalent */
X                     bwb_vtov( c, v );		/* assign calling value to local variable */
X
X#if INTENSIVE_DEBUG
X		     sprintf( bwb_ebuf, "in call_readargs(): variable name is <%s>, local name <%s>",
X			v->name, c->name );
X		     bwb_debug( bwb_ebuf );
X#endif
X
X		     *position = local_pos;
X                     break;
X                  default:
X                     single_var = FALSE;
X                     break;
X                  }
X               }
X
X            if ( single_var == FALSE )
X               {
X#if INTENSIVE_DEBUG
X               sprintf( bwb_ebuf, "in call_readargs(): in loop, parse expression <%s>",
X                  &( expression[ *position ] ) );
X               bwb_debug( bwb_ebuf );
X#endif
X
X               e = bwb_exp( expression, FALSE, position );	/* parse */
X
X#if INTENSIVE_DEBUG
X	       sprintf( bwb_ebuf, "in call_readargs(): in loop, parsed expression, buffer <%s>",
X		  &( expression[ *position ] ) );
X               bwb_debug( bwb_ebuf );
X#endif
X
X               v = var_pos( CURTASK excs[ CURTASK exsc ].local_variable,
X                  argument_counter );		/* assign to variable */
X               bwb_etov( v, e );		/* assign value */
X               }
X
X            /* add the variable to the calling variable chain */
X
X            fslt_addcallvar( v );
X
X#if INTENSIVE_DEBUG
X            str_btoc( tbuf, var_getsval( v ));
X            if ( single_var == TRUE )
X               {
X               sprintf( bwb_ebuf, "in call_readargs(): added arg <%d> (single) name <%s> value <%s>",
X                  argument_counter, v->name, tbuf );
X               }
X            else
X               {
X               sprintf( bwb_ebuf, "in call_readargs(): added arg <%d> (expression) name <%s> value <%s>",
X                  argument_counter, v->name, tbuf );
X               }
X            bwb_debug( bwb_ebuf );
X            getchar();
X#endif
X
X            /* advance past comma if present */
X
X            adv_ws( expression, position );
X            if ( expression[ *position ] == ',' )
X               {
X               ++( *position );
X               }
X
X            break;
X         }
X
X      ++argument_counter;
X
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in call_readargs(): exiting function" );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       fslt_findl()
X
X        DESCRIPTION:	This C function finds a line corresponding
X        		to a name in the FUNCTION-SUB lookup
X			table.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic struct bwb_line *
Xfslt_findl( char *buffer )
X#else
Xstatic struct bwb_line *
Xfslt_findl( buffer )
X   char *buffer;
X#endif
X   {
X   struct fslte *r;
X
X   r = fslt_findf( buffer );
X
X   return r->line;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       fslt_findf()
X
X        DESCRIPTION:	This C function finds an fslte structure
X			corresponding to a name in the FUNCTION-
X			SUB lookup table.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic struct fslte *
Xfslt_findf( char *buffer )
X#else
Xstatic struct fslte *
Xfslt_findf( buffer )
X   char *buffer;
X#endif
X   {
X   struct fslte *f;
X   register int c;
X
X   /* remove open-paren from string */
X
X   for ( c = 0; buffer[ c ] != '\0'; ++c )
X      {
X      if ( buffer[ c ] == '(' )
X         {
X         buffer[ c ] = '\0';
X         }
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in fslt_findf(): search for name <%s>", buffer );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* run through the table */
X
X   for ( f = CURTASK fslt_start.next; f != &CURTASK fslt_end; f = f->next )
X      {
X      if ( strcmp( f->name, buffer ) == 0 )
X         {
X         return f;
X         }
X      }
X
X   /* search has failed */
X
X#if PROG_ERRORS
X   sprintf( bwb_ebuf, "in fslt_findf(): failed to find Function/Subroutine <%s>",
X      buffer );
X   bwb_error( bwb_ebuf );
X#else
X   bwb_error( err_lnnotfound );
X#endif
X
X   return NULL;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_def()
X
X        DESCRIPTION:    This C function implements the BASIC
X                        DEF statement. Since DEF and FUNCTION
X			are equivalent, it simply passes execution
X			to bwb_function().
X
X	SYNTAX:		DEF FNname(arg...)] = expression
X
X	NOTE:		It is not a strict requirement that the
X			function name should begin with "FN".
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_def( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_def( l )
X   struct bwb_line *l;
X#endif
X   {
X
X#if MULTISEG_LINES
X   adv_eos( l->buffer, &( l->position ));
X#endif
X
X   return bwb_zline( l );
X   }
X
X#if STRUCT_CMDS
X
X/***************************************************************
X
X        FUNCTION:       bwb_function()
X
X        DESCRIPTION:	This C function implements the BASIC
X			FUNCTION and DEF commands.
X
X	SYNTAX:		FUNCTION function-definition
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_function( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_function( l )
X   struct bwb_line *l;
X#endif
X   {
X
X   return bwb_def( l );
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_endfnc()
X
X        DESCRIPTION:	This C function implements the BASIC
X			END FUNCTION command, ending a subroutine
X			definition.  Because the command END
X			can have multiple meanings, this function
X			should be called from the bwb_xend()
X			function, which should be able to identify
X			an END FUNCTION command.
X
X	SYNTAX:		END FUNCTION
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_endfnc( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_endfnc( l )
X   struct bwb_line *l;
X#endif
X   {
X   struct bwb_variable *local;
X   register int c;
X
X   /* assign local variable values to calling variables */
X
X   local = CURTASK excs[ CURTASK exsc ].local_variable;
X   for ( c = 0; c < CURTASK excs[ CURTASK exsc ].n_cvs; ++c )
X      {
X      bwb_vtov( CURTASK excs[ CURTASK exsc ].calling_variable[ c ], local );
X      local = local->next;
X      }
X
X   /* decrement the EXEC stack counter */
X
X   bwb_decexec();
X
X   /* and return next from old line */
X
X   CURTASK excs[ CURTASK exsc ].line->next->position = 0;
X   return CURTASK excs[ CURTASK exsc ].line->next;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_call()
X
X        DESCRIPTION:	This C function implements the BASIC
X        		CALL subroutine command.
X
X	SYNTAX:		CALL subroutine-name
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_call( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_call( l )
X   struct bwb_line *l;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X   struct bwb_line *call_line;
X   struct fslte *f;
X
X   adv_element( l->buffer, &( l->position ), tbuf );
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_call(): call to subroutine <%s>", tbuf );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* find the line to call */
X
X   call_line = fslt_findl( tbuf );
X   f = fslt_findf( tbuf );
X
X   if ( call_line == NULL )
X      {
X      return bwb_zline( l );
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_call(): found line <%s>",
X      call_line->buffer );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* save the old position on the EXEC stack */
X
X   bwb_setexec( l, l->position, CURTASK excs[ CURTASK exsc ].code );
X
X   /* increment and set new EXEC stack */
X
X   bwb_incexec();
X   call_line->position = 0;
X   bwb_setexec( call_line, 0, EXEC_CALLSUB );
X
X   /* attach local variables */
X
X   CURTASK excs[ CURTASK exsc ].local_variable = f->local_variable;
X
X   /* read calling variables for this call */
X
X   call_readargs( f, l->buffer, &( l->position ) );
X
X   return call_line;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_sub()
X
X	DESCRIPTION:    This function implements the BASIC
X			SUB command, introducing a named
X			subroutine.
X
X	SYNTAX:		SUB subroutine-name
X			(followed by subroutine definition ending
X			with END SUB).
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_sub( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_sub( l )
X   struct bwb_line *l;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X   struct bwb_line *rline;
X#if MULTISEG_LINES
X   struct fslte *f;
X#endif
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_sub(): entered function at exec level <%d>",
X      CURTASK exsc );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* check current exec level: if 1 then only MAIN should be executed */
X
X   if ( CURTASK exsc == 0 )
X      {
X      adv_element( l->buffer, &( l->position ), tbuf );
X      bwb_strtoupper( tbuf );
X      if ( strcmp( tbuf, "MAIN" ) == 0 )
X         {
X#if INTENSIVE_DEBUG
X         sprintf( bwb_ebuf, "in bwb_sub(): found MAIN function at level 0" );
X         bwb_debug( bwb_ebuf );
X#endif
X
X         bwb_incexec();
X
X         bwb_setexec( l->next, 0, EXEC_MAIN );
X
X         return bwb_zline( l );
X
X         }
X
X      /* if a MAIN function was not found at level 0, then skip the subroutine */
X
X      else
X         {
X
X#if INTENSIVE_DEBUG
X         sprintf( bwb_ebuf, "in bwb_sub(): found non-MAIN function at level 0" );
X         bwb_debug( bwb_ebuf );
X#endif
X
X         rline = find_endsub( l );
X         bwb_setexec( rline->next, 0, EXEC_CALLSUB );
X         rline->next->position = 0;
X         return rline->next;
X         }
X      }
X
X   /* check for integrity of CALL-SUB sequence if above level 0 */
X
X   else if ( CURTASK excs[ CURTASK exsc ].code != EXEC_CALLSUB )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_sub(): SUB without CALL" );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_retnogosub );
X#endif
X      }
X
X   /* advance position */
X
X#if MULTISEG_LINES
X   adv_ws( l->buffer, &( l->position ));
X   adv_element( l->buffer, &( l->position ), tbuf );
X   f = fslt_findf( tbuf );
X
X   l->position = f->startpos;
X
X   return bwb_zline( l );
X#else
X   return bwb_zline( l );
X#endif
X   }
X
X/***************************************************************
X
X        FUNCTION:       find_endsub()
X
X        DESCRIPTION:    This function searches for a line containing
X                        an END SUB statement corresponding to a previous
X                        SUB statement.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic struct bwb_line *
Xfind_endsub( struct bwb_line *l )
X#else
Xstatic struct bwb_line *
Xfind_endsub( l )
X   struct bwb_line *l;
X#endif
X   {
X   struct bwb_line *current;
X   register int s_level;
X   int position;
X
X   s_level = 1;
X   for ( current = l->next; current != &CURTASK bwb_end; current = current->next )
X      {
X      position = 0;
X      if ( current->marked != TRUE )
X         {
X         line_start( current->buffer, &position, &( current->lnpos ),
X            &( current->lnum ),
X            &( current->cmdpos ),
X            &( current->cmdnum ),
X            &( current->startpos ) );
X         }
X      current->position = current->startpos;
X
X      if ( current->cmdnum > -1 )
X         {
X
X         if ( bwb_cmdtable[ current->cmdnum ].vector == bwb_sub )
X            {
X            ++s_level;
X
X#if INTENSIVE_DEBUG
X            sprintf( bwb_ebuf, "in find_endsub(): found SUB at line %d, level %d",
X               current->number, s_level );
X            bwb_debug( bwb_ebuf );
X#endif
X
X            }
X         else if ( is_endsub( current ) == TRUE )
X            {
X            --s_level;
X
X#if INTENSIVE_DEBUG
X            sprintf( bwb_ebuf, "in find_endsub(): found END SUB at line %d, level %d",
X               current->number, s_level );
X            bwb_debug( bwb_ebuf );
X#endif
X
X            if ( s_level == 0 )
X               {
X               return current;
X               }
X            }
X
X         }
X      }
X
X#if PROG_ERRORS
X   sprintf( bwb_ebuf, "SUB without END SUB" );
X   bwb_error( bwb_ebuf );
X#else
X   bwb_error( err_syntax  );
X#endif
X
X   return NULL;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       is_endsub()
X
X	DESCRIPTION:    This function determines whether the
X			line buffer for line 'l' is positioned
X			at an END SUB statement.
X
X***************************************************************/
X
X#if ANSI_C
Xstatic int
Xis_endsub( struct bwb_line *l )
X#else
Xstatic int
Xis_endsub( l )
X   struct bwb_line *l;
X#endif
X   {
X   int position;
X   char tbuf[ MAXVARNAMESIZE + 1];
X
X   if ( bwb_cmdtable[ l->cmdnum ].vector != bwb_xend )
X      {
X      return FALSE;
X      }
X
X   position = l->startpos;
X   adv_ws( l->buffer, &position );
X   adv_element( l->buffer, &position, tbuf );
X   bwb_strtoupper( tbuf );
X
X   if ( strcmp( tbuf, "SUB" ) == 0 )
X      {
X      return TRUE;
X      }
X
X   return FALSE;
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_endsub()
X
X        DESCRIPTION:	This C function implements the BASIC
X			END SUB command, ending a subroutine
X			definition.  Because the command END
X			can have multiple meanings, this function
X			should be called from the bwb_xend()
X			function, which should be able to identify
X			an END SUB command.
X
X	SYNTAX:		END SUB
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_endsub( struct bwb_line *line )
X#else
Xstruct bwb_line *
Xbwb_endsub( line )
X   struct bwb_line *line;
X#endif
X   {
X   struct bwb_variable *l;
X   register int c;
X
X   /* assign local variable values to calling variables */
X
X   l = CURTASK excs[ CURTASK exsc ].local_variable;
X   for ( c = 0; c < CURTASK excs[ CURTASK exsc ].n_cvs; ++c )
X      {
X      bwb_vtov( CURTASK excs[ CURTASK exsc ].calling_variable[ c ], l );
X      l = l->next;
X      }
X
X   /* decrement the EXEC stack counter */
X
X   bwb_decexec();
X
X   /* if the previous level was EXEC_MAIN,
X      then execution continues from this point */
X
X   if ( CURTASK excs[ CURTASK exsc + 1 ].code == EXEC_MAIN )
X      {
X      return bwb_zline( line );
X      }
X
X   /* else return next from old line */
X
X   CURTASK excs[ CURTASK exsc ].line->next->position = 0;
X   return CURTASK excs[ CURTASK exsc ].line->next;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:	find_label()
X
X	DESCRIPTION:	This C function finds a program line that
X			begins with the label included in <buffer>.
X
X***************************************************************/
X
X#if ANSI_C
Xextern struct bwb_line *
Xfind_label( char *buffer )
X#else
Xextern struct bwb_line *
Xfind_label( buffer )
X   char *buffer;
X#endif
X   {
X   struct fslte *f;
X
X   for ( f = CURTASK fslt_start.next; f != & ( CURTASK fslt_end ); f = f->next )
X      {
X      if ( strcmp( buffer, f->name ) == 0 )
X         {
X#if INTENSIVE_DEBUG
X         sprintf( bwb_ebuf, "in find_label(): found label <%s>", buffer );
X         bwb_debug( bwb_ebuf );
X#endif
X         return f->line;
X         }
X      }
X
X#if PROG_ERRORS
X   sprintf( bwb_ebuf, "in find_label(): failed to find label <%s>", buffer );
X   bwb_error( bwb_ebuf );
X#else
X   bwb_error( err_lnnotfound );
X#endif
X
X   return NULL;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       bwb_doloop()
X
X	DESCRIPTION:    This C function implements the ANSI BASIC
X			DO statement, when DO is not followed by
X			an argument.  It is called by bwb_do() in
X			bwb_cmd.c.
X
X	SYNTAX:		DO
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_doloop( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_doloop( l )
X   struct bwb_line *l;
X#endif
X   {
X
X   /* if this is the first time at this DO statement, note it */
X
X   if ( CURTASK excs[ CURTASK exsc ].while_line != l )
X      {
X
X      bwb_incexec();
X      CURTASK excs[ CURTASK exsc ].while_line = l;
X
X      /* find the LOOP statement */
X
X      CURTASK excs[ CURTASK exsc ].wend_line = find_loop( l );
X
X      if ( CURTASK excs[ CURTASK exsc ].wend_line == NULL )
X	 {
X	 return bwb_zline( l );
X	 }
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_doloop(): initialize DO loop, line <%d>",
X	 l->number );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      }
X#if INTENSIVE_DEBUG
X   else
X      {
X      sprintf( bwb_ebuf, "in bwb_doloop(): return to DO loop, line <%d>",
X	 l->number );
X      bwb_debug( bwb_ebuf );
X      }
X#endif
X
X   bwb_setexec( l, l->position, EXEC_DO );
X   return bwb_zline( l );
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_loop()
X
X	DESCRIPTION:    This C function implements the ANSI BASIC
X			LOOP statement.
X
X	SYNTAX:		LOOP [UNTIL expression]
X			
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_loop( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_loop( l )
X   struct bwb_line *l;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_loop(): entered subroutine" );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* If the current exec stack is set for EXEC_WHILE, then we
X      presume that this is a LOOP statement ending a DO WHILE
X      loop */
X
X   if ( CURTASK excs[ CURTASK exsc ].code == EXEC_WHILE )
X      {
X      return bwb_wend( l );
X      }
X
X   /* check integrity of DO loop */
X
X   if ( CURTASK excs[ CURTASK exsc ].code != EXEC_DO )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_loop(): exec stack code != EXEC_DO" );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_syntax );
X#endif
X      }
X
X   if ( CURTASK excs[ CURTASK exsc ].while_line == NULL )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_loop(): exec stack while_line == NULL" );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_syntax );
X#endif
X      }
X
X   /* advance to find the first argument */
X
X   adv_element( l->buffer, &( l->position ), tbuf );
X   bwb_strtoupper( tbuf );
X
X   /* detect a LOOP UNTIL structure */
X
X   if ( strcmp( tbuf, CMD_XUNTIL ) == 0 )
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_loop(): detected LOOP UNTIL" );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      return bwb_loopuntil( l );
X
X      }
X
X   /* LOOP does not have UNTIL */
X
X   else
X      {
X
X      /* reset to the top of the current DO loop */
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_loop() return to line <%d>",
X	 CURTASK excs[ CURTASK exsc ].while_line->number );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      CURTASK excs[ CURTASK exsc ].while_line->position = 0;
X      bwb_setexec( CURTASK excs[ CURTASK exsc ].while_line, 0, EXEC_DO );
X
X      return CURTASK excs[ CURTASK exsc ].while_line;
X
X      }
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       bwb_loopuntil()
X
X	DESCRIPTION:    This C function implements the ANSI BASIC
X			LOOP UNTIL statement and is called by
X			bwb_loop().
X
X***************************************************************/
X
X#if ANSI_C
Xstatic struct bwb_line *
Xbwb_loopuntil( struct bwb_line *l )
X#else
Xstatic struct bwb_line *
Xbwb_loopuntil( l )
X   struct bwb_line *l;
X#endif
X   {
X   struct exp_ese *e;
X   struct bwb_line *r;
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_loopuntil(): entered subroutine" );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* call bwb_exp() to interpret the expression */
X
X   e = bwb_exp( l->buffer, FALSE, &( l->position ) );
X
X   if ( (int) exp_getnval( e ) == TRUE )
X      {
X      CURTASK excs[ CURTASK exsc ].while_line = NULL;
X      r = CURTASK excs[ CURTASK exsc ].wend_line;
X      bwb_setexec( r, 0, CURTASK excs[ CURTASK exsc - 1 ].code );
X      r->position = 0;
X      bwb_decexec();
X      return r;
X      }
X
X   /* condition is false: loop around to DO again */
X
X   else
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_loopuntil() return to line <%d>",
X	 CURTASK excs[ CURTASK exsc ].while_line->number );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      CURTASK excs[ CURTASK exsc ].while_line->position = 0;
X      bwb_setexec( CURTASK excs[ CURTASK exsc ].while_line, 0, EXEC_DO );
X
X      return CURTASK excs[ CURTASK exsc ].while_line;
X
X      }
X
X   }
X
X/***************************************************************
X
X        FUNCTION:       bwb_exit()
X
X	DESCRIPTION:    This C function implements the BASIC EXIT
X			statement, calling subroutines for either
X			EXIT FOR or EXIT DO.
X
X	SYNTAX:		EXIT FOR|DO
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_exit( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_exit( l )
X   struct bwb_line *l;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_exit(): entered subroutine" );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   adv_element( l->buffer, &( l->position ), tbuf );
X   bwb_strtoupper( tbuf );
X
X   if ( strcmp( tbuf, CMD_XFOR ) == 0 )
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_exit(): detected EXIT FOR" );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      return bwb_exitfor( l );
X      }
X
X   if ( strcmp( tbuf, CMD_XDO ) == 0 )
X      {
X      return bwb_exitdo( l );
X      }
X
X#if PROG_ERRORS
X   sprintf( bwb_ebuf, "in bwb_exit(): Nonsense or nothing following EXIT" );
X   bwb_error( bwb_ebuf );
X#else
X   bwb_error( err_syntax );
X#endif
X
X   return bwb_zline( l );
X   }
X
X/***************************************************************
X
X	FUNCTION:       bwb_exitdo()
X
X	DESCRIPTION:    This function handles the BASIC EXIT
X			DO statement.  This is a structured
X			programming command compatible with ANSI
X			BASIC. It is called from the bwb_exit()
X			subroutine.
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_line *
Xbwb_exitdo( struct bwb_line *l )
X#else
Xstruct bwb_line *
Xbwb_exitdo( l )
X   struct bwb_line *l;
X#endif
X   {
X   struct bwb_line *next_line;
X   int found;
X   register int level;
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_exitdo(): entered subroutine" );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* Check the integrity of the DO statement */
X
X   found = FALSE;
X   level = CURTASK exsc;
X   do
X      {
X      if ( CURTASK excs[ level ].code == EXEC_DO )
X	 {
X	 next_line = CURTASK excs[ CURTASK level ].wend_line;
X	 found = TRUE;
X	 }
X      else
X	 {
X	 --level;
X	 }
X      }
X   while ( ( level >= 0 ) && ( found == FALSE ) );
X
X   if ( found != TRUE )
X      {
X
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_exitfor(): EXIT DO without DO" );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_syntax );
X#endif
X
X      return bwb_zline( l );
X
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in bwb_exitdo(): level found is <%d>, current <%d>",
X      level, CURTASK exsc );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* decrement below the level of the NEXT statement */
X
X   while( CURTASK exsc >= level )
X      {
X      bwb_decexec();
X      }
X
X   /* set the next line in the exec stack */
X
X   next_line->position = 0;
X   bwb_setexec( next_line, 0, EXEC_NORM );
X
X   return next_line;
X
X   }
X
X#endif					/* STRUCT_CMDS */
X
X/***************************************************************
X
X	FUNCTION:       bwb_vtov()
X
X	DESCRIPTION:    This function assigns the value of one
X			bwBASIC variable (src) to the value of another
X			bwBASIC variable (dst).
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_variable *
Xbwb_vtov( struct bwb_variable *dst,
X   struct bwb_variable *src )
X#else
Xstruct bwb_variable *
Xbwb_vtov( dst, src )
X   struct bwb_variable *dst;
X   struct bwb_variable *src;
X#endif
X   {
X
X   if ( dst == src )
X      {
X      return dst;
X      }
X
X   if ( src->type != dst->type )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_vtov(): mismatch src <%s> type <%d> dst <%s> type <%d>",
X	 src->name, src->type, dst->name, dst->type );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_mismatch );
X#endif
X      return NULL;
X      }
X
X   if ( dst->type == NUMBER )
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in bwb_vtov(): assigning var <%s> val <%lf> to var <%s>",
X	 src->name, var_getnval( src ), dst->name );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      * var_findnval( dst, dst->array_pos ) = var_getnval( src );
X      }
X   else
X      {
X      str_btob( var_getsval( dst ), var_getsval( src ) );
X      }
X
X   return dst;
X   }
X
X/***************************************************************
X
X	FUNCTION:       bwb_etov()
X
X	DESCRIPTION:    This function assigns the value of a
X			bwBASIC expression stack element (src)
X			to the value of a bwBASIC variable (dst).
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_variable *
Xbwb_etov( struct bwb_variable *dst, struct exp_ese *src )
X#else
Xstruct bwb_variable *
Xbwb_etov( dst, src )
X   struct bwb_variable *dst;
X   struct exp_ese *src;
X#endif
X   {
X
X   if ( (int) src->type != dst->type )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in bwb_etov(): mismatch src <%d> dst <%d>",
X         src->type, dst->type );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_mismatch );
X#endif
X      return NULL;
X      }
X
X   if ( dst->type == NUMBER )
X      {
X      * var_findnval( dst, dst->array_pos ) = exp_getnval( src );
X      }
X   else
X      {
X      str_btob( var_getsval( dst ), exp_getsval( src ) );
X      }
X
X   return dst;
X   }
X
X/***************************************************************
X
X	FUNCTION:       var_pos()
X
X	DESCRIPTION:    This function returns the name of a
X			local variable at a specified position
X			in the local variable list.
X
X***************************************************************/
X
X#if ANSI_C
Xstruct bwb_variable *
Xvar_pos( struct bwb_variable *firstvar, int p )
X#else
Xstruct bwb_variable *
Xvar_pos( firstvar, p )
X   struct bwb_variable *firstvar;
X   int p;
X#endif
X   {
X   register int c;
X   struct bwb_variable *v;
X
X   v = firstvar;
X   for ( c = 0; c != p; ++c )
X      {
X      v = v->next;
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in var_pos(): returning pos <%d> variable <%s>",
X      p, v->name );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   return v;
X   }
X
X/***************************************************************
X
X	FUNCTION:       fslt_addcallvar()
X
X	DESCRIPTION:    This function adds a calling variable
X			to the FUNCTION-SUB lookuop table at
X			a specific level.
X
X***************************************************************/
X
X#if ANSI_C
Xint
Xfslt_addcallvar( struct bwb_variable *v )
X#else
Xint
Xfslt_addcallvar( v )
X   struct bwb_variable *v;
X#endif
X   {
X
X   if ( CURTASK excs[ CURTASK exsc ].n_cvs >= MAX_FARGS )
X      {
X#if PROG_ERRORS
X      sprintf( bwb_ebuf, "in fslt_addcallvar(): Maximum number of Function Args Exceeded" );
X      bwb_error( bwb_ebuf );
X#else
X      bwb_error( err_overflow );
X#endif
X      }
X
X   CURTASK excs[ CURTASK exsc ].calling_variable[ CURTASK excs[ CURTASK exsc ].n_cvs ] = v;
X   ++CURTASK excs[ CURTASK exsc ].n_cvs;
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       expufnc()
X
X        DESCRIPTION:	This C function interprets a user-defined
X			function, returning its value at the current
X			level of the expression stack.
X
X***************************************************************/
X
X#if ANSI_C
Xint
Xexp_ufnc( char *expression )
X#else
Xint
Xexp_ufnc( expression )
X   char *expression;
X#endif
X   {
X   char tbuf[ MAXSTRINGSIZE + 1 ];
X   struct bwb_line *call_line;
X   struct fslte *f, *c;
X   struct bwb_variable *v, *r;
X   struct exp_ese *e;
X   int save_elevel;
X   int position, epos;
X#if INTENSIVE_DEBUG
X   register int i;
X#endif
X
X   position = 0;
X
X   /* get the function name in tbuf */
X
X   exp_getvfname( expression, tbuf );
X
X   /* find the function name in the function-subroutine lookup table */
X
X   for ( f = CURTASK fslt_start.next; f != &CURTASK fslt_end; f = f->next )
X      {
X      if ( strcmp( f->name, tbuf ) == 0 )
X	 {
X#if INTENSIVE_DEBUG
X	 sprintf( bwb_ebuf, "in exp_ufnc(): found user function <%s>",
X	    tbuf );
X	 bwb_debug( bwb_ebuf );
X#endif
X	 c = f; 		/* current function-subroutine lookup table element */
X	 call_line = f->line;	/* line to call for function */
X	 }
X      }
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in exp_ufnc(): call to function <%s>", tbuf );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   position += strlen( tbuf );
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in exp_ufnc(): found line <%s>",
X      call_line->buffer );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* save the old position on the EXEC stack */
X
X   bwb_setexec( CURTASK excs[ CURTASK exsc ].line,
X      position, CURTASK excs[ CURTASK exsc ].code );
X   save_elevel = CURTASK exsc;
X
X   /* increment and set new EXEC stack */
X
X   bwb_incexec();
X   call_line->position = 0;
X   bwb_setexec( call_line, 0, EXEC_FUNCTION );
X
X   /* attach local variables */
X
X   CURTASK excs[ CURTASK exsc ].local_variable = c->local_variable;
X
X#if INTENSIVE_DEBUG
X   i = 0;
X   sprintf( bwb_ebuf, "in exp_ufnc(): <%s> attached local variables EXEC level <%d>",
X      tbuf, CURTASK exsc );
X   bwb_debug( bwb_ebuf );
X   for ( v = CURTASK excs[ CURTASK exsc ].local_variable; v != NULL; v = v->next )
X      {
X      sprintf( bwb_ebuf, "in exp_ufnc():   <%s> level <%d> variable <%d> name <%s>",
X	 tbuf, CURTASK exsc, i, v->name );
X      bwb_debug( bwb_ebuf );
X      ++i;
X      }
X   getchar();
X#endif
X
X   /* read calling variables for this call */
X
X   call_readargs( c, expression, &position );
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in exp_ufnc(): current buffer <%s>",
X      &( call_line->buffer[ c->startpos ] ) );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   /* determine if single-line function */
X
X   epos = c->startpos;
X   adv_ws( call_line->buffer, &epos );
X   if ( call_line->buffer[ epos ] == '=' )
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in exp_ufnc(): found SINGLE-LINE function" );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      ++epos;
X      call_line->position = epos;
X      bwb_setexec( call_line, epos, EXEC_FUNCTION );
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in exp_ufnc(): single line: parse <%s>",
X	 &( call_line->buffer[ epos ] ) );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      e = bwb_exp( call_line->buffer, FALSE, &epos );
X      v = var_find( tbuf );
X
X#if INTENSIVE_DEBUG
X      if ( e->type == STRING )
X	 {
X	 sprintf( bwb_ebuf, "in exp_ufnc(): expression returns <%d>-byte string",
X	    exp_getsval( e )->length );
X	 bwb_debug( bwb_ebuf );
X	 }
X      else
X	 {
X	 sprintf( bwb_ebuf, "in exp_ufnc(): expression returns number <%lf>",
X	    (double) exp_getnval( e ) );
X	 bwb_debug( bwb_ebuf );
X	 }
X#endif
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in exp_ufnc(): single line after parsing, <%s>",
X	 &( call_line->buffer[ epos ] ) );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      bwb_etov( v, e );
X      bwb_decexec();
X      }
X
X   /* multi-line function must be executed now */
X
X   else
X      {
X
X#if INTENSIVE_DEBUG
X      sprintf( bwb_ebuf, "in exp_ufnc(): found MULTI-LINE function" );
X      bwb_debug( bwb_ebuf );
X#endif
X
X      /* now execute until function is resolved */
X
X      bwb_execline();
X      while( CURTASK exsc > save_elevel )
X	 {
X	 bwb_execline();
X	 }
X
X      /* find the return value */
X
X      for ( r = c->local_variable; r != NULL; r = r->next )
X	 {
X	 if ( strcmp( r->name, c->name ) == 0 )
X	    {
X	    v = r;
X	    }
X	 }
X
X      }
X
X   /* now place value in expression stack */
X
X   CURTASK exps[ CURTASK expsc ].type = (char) v->type;
X   CURTASK exps[ CURTASK expsc ].pos_adv = position;
X
X   switch( v->type )
X      {
X      case STRING:
X	 CURTASK exps[ CURTASK expsc ].operation = CONST_STRING;
X
X#if INTENSIVE_DEBUG
X	 sprintf( bwb_ebuf, "in exp_ufnc(): ready to assign <%d>-byte STRING",
X	    var_getsval( v )->length );
X	 bwb_debug( bwb_ebuf );
X#endif
X
X	 str_btob( exp_getsval( &( CURTASK exps[ CURTASK expsc ] )),
X	    var_getsval( v ) );
X
X#if INTENSIVE_DEBUG
X	 str_btoc( tbuf, var_getsval( v ) );
X	 sprintf( bwb_ebuf, "in exp_ufnc(): string assigned <%s>", tbuf );
X	 bwb_debug( bwb_ebuf );
X#endif
X
X	 break;
X
X      default:
X	 CURTASK exps[ CURTASK expsc ].operation = NUMBER;
X	 CURTASK exps[ CURTASK expsc ].nval = var_getnval( v );
X	 break;
X      }
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       fslt_addlocalvar()
X
X	DESCRIPTION:    This function adds a local variable
X			to the FUNCTION-SUB lookuop table at
X			a specific level.
X
X***************************************************************/
X
X#if ANSI_C
Xint
Xfslt_addlocalvar( struct fslte *f, struct bwb_variable *v )
X#else
Xint
Xfslt_addlocalvar( f, v )
X   struct fslte *f;
X   struct bwb_variable *v;
X#endif
X   {
X   struct bwb_variable *c, *p;
X#if INTENSIVE_DEBUG
X   register int i;
X#endif
X
X   /* find end of local chain */
X
X   if ( f->local_variable == NULL )
X      {
X#if INTENSIVE_DEBUG
X      i = 0;
X#endif
X      f->local_variable = v;
X      }
X   else
X      {
X#if INTENSIVE_DEBUG
X      i = 1;
X#endif
X      p = f->local_variable;
X      for ( c = f->local_variable->next; c != NULL; c = c->next )
X         {
X         p = c;
X#if INTENSIVE_DEBUG
X         ++i;
X#endif
X         }
X      p->next = v;
X      }
X
X   v->next = NULL;
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in fslt_addlocalvar(): added local variable variable <%s> arg number <%d>",
X      v->name, i );
X   bwb_debug( bwb_ebuf );
X   getchar();
X#endif
X
X   return TRUE;
X
X   }
X
X/***************************************************************
X
X	FUNCTION:       fslt_init()
X
X	DESCRIPTION:    This function initializes the FUNCTION-SUB
X			lookup table.
X
X***************************************************************/
X
X#if ANSI_C
Xint
Xfslt_init( int task )
X#else
Xint
Xfslt_init( task )
X   int task;
X#endif
X   {
X   LOCALTASK fslt_start.next = &(LOCALTASK fslt_end);
X   return TRUE;
X   }
X
X/***************************************************************
X
X	FUNCTION:       is_label()
X
X	DESCRIPTION:    This function determines whether the string
X			pointed to by 'buffer' is a label (i.e.,
X			ends with colon).
X
X***************************************************************/
X
X#if ANSI_C
Xextern int
Xis_label( char *buffer )
X#else
Xint
Xis_label( buffer )
X   char *buffer;
X#endif
X   {
X
X#if INTENSIVE_DEBUG
X   sprintf( bwb_ebuf, "in is_label(): check element <%s>", buffer );
X   bwb_debug( bwb_ebuf );
X#endif
X
X   if ( buffer[ strlen( buffer ) - 1 ] == ':' )
X      {
X      return TRUE;
X      }
X   else
X      {
X      return FALSE;
X      }
X
X   }
X
X
END_OF_FILE
  if test 52211 -ne `wc -c <'bwbasic-2.10/bwb_stc.c'`; then
    echo shar: \"'bwbasic-2.10/bwb_stc.c'\" unpacked with wrong size!
  fi
  # end of 'bwbasic-2.10/bwb_stc.c'
fi
if test -f 'bwbasic-2.10/configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bwbasic-2.10/configure'\"
else
  echo shar: Extracting \"'bwbasic-2.10/configure'\" \(8681 characters\)
  sed "s/^X//" >'bwbasic-2.10/configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
X# --with-PACKAGE unless this script has special code to handle it.
X
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -f conftest* core; exit 1' 1 3 15
X
Xrm -f conftest*
Xcompile='${CC-cc} $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=bwb_cmd.c
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
Xif test -z "$CC"; then
X  echo checking for gcc
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/gcc; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  CPP='${CC-cc} -E'
X  cat > conftest.c <<EOF
X#include <stdio.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  :
Xelse
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args.  (Sigh.)
Xif test -z "$INSTALL"; then
X  echo checking for install
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin) ;;
X    *)
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
X
Xecho checking for size_t in sys/types.h
Xecho '#include <sys/types.h>' > conftest.c
Xeval "$CPP $DEFS conftest.c > conftest.out 2>&1"
Xif egrep "size_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse 
X  DEFS="$DEFS -Dsize_t=unsigned"
Xfi
Xrm -f conftest*
X
Xecho checking for string.h
Xcat > conftest.c <<EOF
X#include <string.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DHAVE_STRING=1"
Xfi
Xrm -f conftest*
X
Xecho checking for stdlib.h
Xcat > conftest.c <<EOF
X#include <stdlib.h>
XEOF
Xerr=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
Xif test -z "$err"; then
X  DEFS="$DEFS -DHAVE_STDLIB=1"
Xfi
Xrm -f conftest*
X
Xecho checking for raise
Xcat > conftest.c <<EOF
X#include <sys/types.h>
X#include <signal.h>
Xmain() { exit(0); } 
Xt() { raise(1); }
XEOF
Xif eval $compile; then
X  DEFS="$DEFS -DHAVE_RAISE=1"
Xfi
Xrm -f conftest*
X
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%\
Xexec_prefix\\1=\\2$exec_prefix%"
Xfi
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null`:
X#
X# $0 $*
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $* ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -f Makefile; exit 1' 1 3 15
XCC='$CC'
XCPP='$CPP'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
XDEFS='$DEFS'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
Xfor file in .. Makefile; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
Xs%@CC@%$CC%g
Xs%@CPP@%$CPP%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%$DEFS%
X" $top_srcdir/${file}.in >> $file
Xfi; done
X
XEOF
Xchmod +x config.status
Xtest -n "$no_create" || ./config.status
X
END_OF_FILE
  if test 8681 -ne `wc -c <'bwbasic-2.10/configure'`; then
    echo shar: \"'bwbasic-2.10/configure'\" unpacked with wrong size!
  fi
  chmod +x 'bwbasic-2.10/configure'
  # end of 'bwbasic-2.10/configure'
fi
echo shar: End of archive 4 \(of 15\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
