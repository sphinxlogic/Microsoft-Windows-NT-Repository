Newsgroups: comp.sources.misc
From: casey@gauss.llnl.gov (Casey Leedom)
Subject: v40i121:  lic - LLNL Line Integral Convolution, v1.3, Part07/09
Message-ID: <1993Nov9.171028.26930@sparky.sterling.com>
X-Md4-Signature: da2fe49ec0f1f7f6292bb72f1da313fe
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 9 Nov 1993 17:10:28 GMT
Approved: kent@sparky.sterling.com

Submitted-by: casey@gauss.llnl.gov (Casey Leedom)
Posting-number: Volume 40, Issue 121
Archive-name: lic/part07
Environment: UNIX
Supersedes: lic: Volume 38, Issue 104

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lic.1.3/config/Makefile.config lic.1.3/doc/cover.me
#   lic.1.3/liblic/Filters.c lic.1.3/liblic/LIC_Filters.3
#   lic.1.3/liblic/liblic.h lic.1.3/lic/Makefile.tmpl
#   lic.1.3/test/ElectroStatic.c lic.1.3/test/SpiralField.c
#   lic.1.3/test/SpotNoise.c
# Wrapped by kent@sparky on Tue Nov  9 10:09:41 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 9)."'
if test -f 'lic.1.3/config/Makefile.config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/config/Makefile.config'\"
else
  echo shar: Extracting \"'lic.1.3/config/Makefile.config'\" \(7263 characters\)
  sed "s/^X//" >'lic.1.3/config/Makefile.config' <<'END_OF_FILE'
X#
X# $Header: /usr/local/src/lic/config/RCS/Makefile.config,v 1.13 1993/11/05 16:06:10 casey Exp $
X#
X
X# Installation targetting.  Any user commands will be installed in BINDIR,
X# libraries in LIBDIR, include files in INCDIR, manual pages in MAN1DIR
X# and MAN3DIR, etc.
X#
X      DESTDIR = 
X       BINDIR = $(DESTDIR)/usr/local/bin
X       LIBDIR = $(DESTDIR)/usr/local/lib
X       INCDIR = $(DESTDIR)/usr/local/include
X
X      MANROOT = $(DESTDIR)/usr/local/man
X      MAN1DIR = $(MANROOT)/man1
X      MAN1EXT = 1
X      MAN3DIR = $(MANROOT)/man3
X      MAN3EXT = 3
X      MANDIRS = $(MAN1DIR) $(MAN3DIR)
X
X# Specify "man" for MANINSTALL if you want unformatted troff source manual
X# pages installed in the above locations.  Specify "cat" if you want nroff
X# formatted manual pages installed.  Specify "none" if you don't want
X# manual pages installed.
X#
X   MANINSTALL = man
X
X# Protection modes to be set on various installation targets.
X#
X  INSTBINPROT = 555
X  INSTLIBPROT = 444
X  INSTINCPROT = 444
X  INSTMANPROT = 444
X  INSTDOCPROT = 444
X
X
X# Specify "avs" for AVS below if you have AVS and you want to build an AVS
X# LIC module.
X#
X# AVS modules will be installed in AVSMODDIR, AVS module document in AVSDOCDIR,
X# etc.
X#
X# AVSLIBDIR is where AVS support libraries can be found.  AVS_INCLUDES are
X# -I include definitions that point to the AVS include directories.
X# AVS_DEFINES should include any special defines needed to compile AVS
X# coroutine modules on your system.  AVS_EXTRALIBS should contain any extra
X# library definitions needed to link AVS coroutine modules on your system.
X#
X# Using AVS 4.0 (under IBM AIX 3.2), we didn't need any special AVS_DEFINES
X# or AVS_EXTRALIBS.
X#
X# Using AVS 5.0 (under SGI IRIX 4.0.5), AVS_DEFINES should contain
X# -DNeedFunctionPrototypes=1 and AVS_EXTRALIBS needs to contain -lsun.
X#
X# Note that the AVS module currently *only* understands 4-byte ARGB images.
X# Thus, you'll want to select -DARGB for IMAGE_DEFINES below if you want to
X# use the AVS module.
X#
X          AVS = 
X
X       AVSDIR = $(DESTDIR)/usr/avs
X    AVSMODDIR = $(AVSDIR)/unsupp_mods
X    AVSDOCDIR = $(AVSDIR)/unsupp_doc
X
X    AVSLIBDIR = $(AVSDIR)/lib
X AVS_INCLUDES = -I$(AVSDIR)/include
X  AVS_DEFINES = 
XAVS_EXTRALIBS = 
X
X
X# IMAGE_DEFINES should define one of the following (yes, this should all be
X# handled dynamically at run-time, but we ran out of time):
X#
X#    ARGB, ABGR, RGBA, BGRA -- four byte pixels:  alpha, red, green and blue
X#    RGB, BGR               -- three byte pixels: red, green and blue
X#    MONOCHROME             -- one byte pixels:   grey scale
X#
XIMAGE_DEFINES = -DMONOCHROME
X
X
X# Standard compilation environment definitions:
X#
X# NOTES:
X#   Neither DEFINES nor INCLUDES should be used below.  They are present for
X#   the benefit of various Makefile.tmpl files to add includes and defines to
X#   the standard CFLAGS macro.
X#
X#   Setting MMAP_DEFINES to -DHAS_MMAP will cause the lic(1) command to use
X#   mmap calls to map its input and output files directly into its address
X#   space.  If HAS_MMAP is not defined lic(1) will malloc memory for the input
X#   and output files.  Using mmap has the advantage that it won't require space
X#   on swap for the potentially very large images and also saves on pointless
X#   I/O to swap.
X#
X#   There is support for parallel processing on a limited number of platforms.
X#   It shouldn't be too difficult to do the work for any other platform that
X#   supports shared memory multiprocessing.  Only liblic/ComputeImage.c should
X#   need to be changed.  See that file to see what was done for other
X#   platforms.
X#
X# DEC OSF1(alpha)
X#   1.	STD_DEFINES should contain -std1.
X#   2.	CDEBUGFLAGS should contain -g or -O (or -O2) depending on your
X#	debugging/performance needs.
X#   3.	Set RANLIB to ranlib.
X#
X# HP-UX 9.01(snake)
X#   1.	STD_DEFINES should contain -Aa, -D_INCLUDE_XOPEN_SOURCE,
X#	-D_INCLUDE_POSIX_SOURCE and -DHAS_HP_GETOPT.  Unfortunately getopt(3)
X#	wasn't part of either the ANSI C X3.159-1989 or POSIX 1003.1-1990
X#	standards.  HP has chosen a prototype for getopt that is in conflict
X#	with everyone else's.
X#   2.	Wasn't able to use mmap under HP-UX 8.07 even though it linked
X#	successfully.  Didn't try again with HP-UX 9.01.  If I remember right,
X#	it wrote out the output image as all zeros.  When I ran it with the
X#	debugger, every page of the output image that I touched in an effort
X#	to find those zeros turned out to have the correct values *and* got
X#	written out with the correct values.  Some weird VM problem ...
X#   3.	Set RANLIB to /bin/true.
X#
X# IBM AIX 3.2(rs/6000):
X#   1.	STD_DEFINES should contain -qlanglvl=ansi and -D_ALL_SOURCE.
X#   2.	CDEBUGFLAGS should contain -qsrcmsg. It should probably also contain
X#	-qextchk, but that causes the loader to complain about not being able
X#	to resolve references to LIC_Convolve_2D and LIC_Convolve_3D.
X#	CDEBUGFLAGS should also probably contain -g or -O depending on your
X#	debugging/performance needs.
X#   3.	Set MMAP_DEFINES to -DHAS_MMAP.
X#   4.	Set RANLIB to /bin/true.
X#
X# SGI IRIX 4.0.5(mips):
X#   1.	CDEBUGFLAGS should contain -prototypes in order to get C function
X#	prototype checking.  CDEBUGFLAGS should also probably contain -g
X#	or -O depending on your debugging/performance needs.
X#   2.	Set MMAP_DEFINES to -DHAS_MMAP.
X#   3.	Set MCP_DEFINES to -DPARALLEL and -DHAS_M_FORK.
X#   4.	Set MPC_EXTRALIBS to -lmpc.
X#   5.	Set RANLIB to /bin/true.
X#
X# SUN OS 4.1.1(sparc):
X#   1.	CC should be an ANSI C compiler like gcc or Sun's unbundled compiler.
X#	Sun's bundled compiler won't work.
X#   2.	If gcc is used, you'll probably have to add -I/usr/include to
X#	STD_INCLUDES because gcc seems to search its own local include
X#	directory before /usr/include which leads to all sorts of problems.
X#   3.	STD_DEFINES needs -DNEED_STRERROR, -DHAS_OLD_TIMES, -DEXIT_SUCCESS=0,
X#	-DEXIT_FAILURE=1 and -DRAND_MAX=32767.  Sun OS 4.1.1 fails to supply
X#	the ANSI C X3.159-1989 strerror routine, its version of the times(2)
X#	call also doesn't conform to the POSIX definition (it returns 0 on
X#	success instead of a monotonically increasing wall clock time) and the
X#	EXIT_SUCCESS, EXIT_FAILURE and RAND_MAX defines are missing from
X#	<stdlib.h>.  Note also that Sun OS's version of rand is so mind-
X#	bogglingly bad that you'll want to use random() instead.  We didn't
X#	make this change to the source because it would have required
X#	diverging from the ANSI C standard too much.  You'll need to edit
X#	test/WhiteNoise.c and test/SpotNoise.c.
X#   4.	CDEBUGFLAGS should also probably contain -g or -O depending on your
X#	debugging/performance needs.
X#   5.	Set MMAP_DEFINES to -DHAS_MMAP.
X#   6.	Set RANLIB to ranlib.
X#
X  BUILDINCTOP = $(TOP)/include
X    LIBLICDIR = $(TOP)/liblic
X       LIBLIC = $(LIBLICDIR)/liblic.a
X
X           CC = cc
X STD_INCLUDES = -I.
X TOP_INCLUDES = -I$(BUILDINCTOP)
X     INCLUDES = 
X  ALLINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X  STD_DEFINES = 
X      DEFINES = 
X   ALLDEFINES = $(STD_DEFINES) $(DEFINES)
X  CDEBUGFLAGS = -O
X       CFLAGS = $(CDEBUGFLAGS) $(ALLDEFINES) $(ALLINCLUDES)
X
X MMAP_DEFINES = 
X
X  MPC_DEFINES = 
XMPC_EXTRALIBS = 
X
X# Various programs we use ...
X#
X           AR = ar cq
X        NROFF = nroff
X       RANLIB = /bin/true
X        SHELL = /bin/sh
X        STRIP = strip
END_OF_FILE
  if test 7263 -ne `wc -c <'lic.1.3/config/Makefile.config'`; then
    echo shar: \"'lic.1.3/config/Makefile.config'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/config/Makefile.config'
fi
if test -f 'lic.1.3/doc/cover.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/doc/cover.me'\"
else
  echo shar: Extracting \"'lic.1.3/doc/cover.me'\" \(6377 characters\)
  sed "s/^X//" >'lic.1.3/doc/cover.me' <<'END_OF_FILE'
X.\" Copyright (c) 1993 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Lawrence Livermore National Laboratory and its
X.\"	contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.po 1.0in
X.ll 6.5in
X.nr pi 0n
X.de Hd
X.ds Vr 1.3
X.ds Dt \\$4
X..
X.Hd $Header: /usr/local/src/lic/doc/RCS/cover.me,v 1.6 1993/10/22 23:59:35 casey Exp $
X.(b C
X.sz +10
X.rs
X.sp 2.25in
XLLNL
X.sp .25in
XLine Integral Convolution
X.sp .5in
XDistribution
X.sp 2in
XVersion \*(Vr
X\*(Dt
X.sz -10
X.)b
X.\" We delay defining the footer so it won't show up on the first page ...
X.of '\*(Dt''LLNL LIC version \*(Vr'
X.ef '\*(Dt''LLNL LIC version \*(Vr'
X.pa
X.rs
X.sp 3.75in
XCopyright (c) 1993 The Regents of the University of California.
XAll rights reserved.
X.pp
XRedistribution and use in source and binary forms, with or without
Xmodification, are permitted provided that the following conditions
Xare met:
X.ip 1.
XRedistributions of source code must retain the above copyright
Xnotice, this list of conditions and the following disclaimer.
X.ip 2.
XRedistributions in binary form must reproduce the above copyright
Xnotice, this list of conditions and the following disclaimer in the
Xdocumentation and/or other materials provided with the distribution.
X.ip 3.
XAll advertising materials mentioning features or use of this software
Xmust display the following acknowledgement:
X.(q
XThis product includes software developed by the University of
XCalifornia, Lawrence Livermore National Laboratory and its contributors.
X.)q
X.ip 4.
XNeither the name of the University nor the names of its contributors
Xmay be used to endorse or promote products derived from this software
Xwithout specific prior written permission.
X.pp
XTHIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
XANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
XIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
XARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
XFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
XDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
XOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
XHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
XLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
XOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
XSUCH DAMAGE.
X.pa
X.(b C
X.sz +2
XContents
X.sz -2
X.)b
X.sp 3v
X.(x i
XIntroduction
X.)x 1
X.(x i
XREADME
X.)x 2
X.(x i
XABSTRACT
X.)x 3
X.(x i
XMEMO
X.)x 4
X.(x i
XTODO
X.)x 5
X.(x i
XImaging Vector Fields Using Line Integral Convolution
X.)x 6
X.(x i
XManual pages
X.)x 7
X.(x i
XInclude file sources
X.)x 8
X.(x i
Xlic command source
X.)x 9
X.(x i
XLIC AVS coroutine module source
X.)x 10
X.(x i
XLIC library sources
X.)x 11
X.xp i
X.pa
X.(b C
X.sz +2
X1
X.sp 1v
XIntroduction
X.sz -2
X.)b
X.sp 3v
X.pp
XThis document contains the documentation and source code to the LLNL
XLine Integral Convolution (LIC) software distribution version \*(Vr.
X.pp
XThe LLNL LIC software is an experimental implementation of a new
Xvector visualization algorithm.  It allows researchers to experiment
Xwith this algorithm and duplicate results presented in the paper
X.i "Imaging Vector Fields Using Line Integral Convolution"
Xby Brian Cabral and Casey Leedom in the 1993 SIGGRAPH conference.
X.pp
XThe software consists of an object-oriented library that implements
Xthe algorithm, a command line interface and an AVS interface and
Xdocumentation for all of the above.
X.pa
X.(b C
X.sz +2
X2
X.sp 1v
XREADME
X.sz -2
X.)b
X.pa
X.(b C
X.sz +2
X3
X.sp 1v
XABSTRACT
X.sz -2
X.)b
X.pa
X.(b C
X.sz +2
X4
X.sp 1v
XMEMO
X.sz -2
X.)b
X.pa
X.(b C
X.sz +2
X5
X.sp 1v
XTODO
X.sz -2
X.)b
X.pa
X.(b C
X.sz +2
X6
X.sp 1v
XImaging Vector Fields Using Line Integral Convolution
X.sz -2
X.)b
X.pa
X.(b C
X.sz +2
X7
X.sp 1v
XManual pages
X.sz -2
X.)b
X.sp 3v
X.pp
X.(x i
Xlic.1
X.)x 1
X.(x i
XLIC.txt (AVS coroutine on-line documentation)
X.)x 2
X.(x i
XLIC.3
X.)x 3
X.(x i
XLIC_ComputeImage.3
X.)x 4
X.(x i
XLIC_Convolve.3
X.)x 5
X.(x i
XLIC_Create.3
X.)x 6
X.(x i
XLIC_Destroy.3
X.)x 7
X.(x i
XLIC_Filters.3
X.)x 8
X.(x i
XLIC_Modify.3
X.)x 9
X.(x i
XLIC_Query.3
X.)x 10
X.xp i
X.pa
X.(b C
X.sz +2
X8
X.sp 1v
XInclude file sources
X.sz -2
X.)b
X.sp 3v
X.pp
X.(x i
Xinclude/lic.h
X.)x 1
X.xp i
X.pa
X.(b C
X.sz +2
X9
X.sp 1v
Xlic command source
X.sz -2
X.)b
X.sp 3v
X.(x i
Xlic/lic.c
X.)x 1
X.xp i
X.pa
X.(b C
X.sz +2
X10
X.sp 1v
XLIC AVS coroutine module source
X.sz -2
X.)b
X.sp 3v
X.pp
X.(x i
Xavs/LIC.c
X.)x 1
X.xp i
X.pa
X.(b C
X.sz +2
X11
X.sp 1v
XLIC library sources
X.sz -2
X.)b
X.sp 3v
X.pp
X.(x i
Xliblic.h
X.)x 1
X.(x i
XComputeImage.c
X.)x 2
X.(x i
XConvolve2D.c
X.)x 3
X.(x i
XConvolve3D.c
X.)x 4
X.(x i
XCreate.c
X.)x 5
X.(x i
XDestroy.c
X.)x 6
X.(x i
XFilters.c
X.)x 7
X.(x i
XModify.c
X.)x 8
X.(x i
XQuery.c
X.)x 9
X.xp i
END_OF_FILE
  if test 6377 -ne `wc -c <'lic.1.3/doc/cover.me'`; then
    echo shar: \"'lic.1.3/doc/cover.me'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/doc/cover.me'
fi
if test -f 'lic.1.3/liblic/Filters.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/liblic/Filters.c'\"
else
  echo shar: Extracting \"'lic.1.3/liblic/Filters.c'\" \(6091 characters\)
  sed "s/^X//" >'lic.1.3/liblic/Filters.c' <<'END_OF_FILE'
X/*
X * $Header: /usr/local/src/lic/liblic/RCS/Filters.c,v 1.12 1993/08/10 23:35:32 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /usr/local/src/lic/liblic/RCS/Filters.c,v 1.12 1993/08/10 23:35:32 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include "liblic.h"
X
X
X/*
X *	Build integral tables from filter integrator.
X *	=============================================
X */
X
Xvoid
XLIC_BuildIntegralTables(LIC *This)
X    /*
X     * Build integral tables for LIC instance if needed.
X     */
X{
X    int speed, length;
X
X    if (!This->NeedIntegration)
X	return;
X    This->NeedIntegration = FALSE;
X
X    /*
X     * Build the convolution integral tables.  Build LIC_INTEGRAL_SPEEDS
X     * different versions of them with speed varying between 0 and
X     * LIC_INTEGRAL_SPEEDS.
X     */
X    for (speed = 0; speed < LIC_INTEGRAL_SPEEDS; speed++)
X    {
X	double s;
X
X	for (length = 0; length < LIC_INTEGRAL_LEN; length++)
X	{
X	    s = LIC_Length(This) * length / (double)LIC_INTEGRAL_LEN;
X	    This->NegIntegralTable[speed][length] = This->Filter(This,  -s, 0.0, speed);
X	    This->PosIntegralTable[speed][length] = This->Filter(This, 0.0,   s, speed);
X	}
X    }
X}
X
X
Xdouble
XLIC_Box(LIC *This, double a, double b, int speed)
X    /*
X     * Compute the integral bewteen points a and b, a <= b, of a box
X     * filter:
X     *
X     *    k(s) = 1
X     */
X{
X    return(b - a);
X}
X
X
Xdouble
XLIC_Ripple(LIC *This, double a, double b, int speed)
X    /*
X     * Compute the integral bewteen points a and b, a <= b, of a phase shifted
X     * Hanning low pass filter multiplied by a Hanning window function:
X     *
X     *    k(s) = (cos(d*s + phase) + 1)/2 * (cos(c*s) + 1)/2
X     *
X     * We need to scale the filter to the length of the filter support.  This
X     * requires scaling each occurance of s by Pi/L.  Things fall out in the
X     * integral which allow us to slip the scaling factors into c and d.
X     */
X{
X    REGISTER double m;		/* speed multiple */
X    REGISTER double p;		/* phase of the Hanning ripple function */
X    REGISTER double f;		/* frequency of the Hanning ripple function */
X    REGISTER double c;		/* Hanning window function dilation constant */
X    REGISTER double d;		/* Hanning ripple filter dilation constant */
X    REGISTER double w;		/* integral value */
X    
X    if (LIC_Length(This) == 0 || a == b)
X	return(0.0);
X    
X    /*
X     * Implement ``speed'' variations by scaling the frequency inversely
X     * to speed.  This causes low magnitude vectors to be convolved using
X     * a higher frequency filter which will yield less distinct output
X     * features.  As the frequency increases the filter begins to approximate
X     * the Hanning window filter.
X     */
X
X    p = LIC_Phase(This);
X    f = LIC_Frequency(This) * (6.0 - 5.0*(double)speed/(LIC_INTEGRAL_SPEEDS - 1));
X    c = 1.0/LIC_Length(This) * M_PI;
X    d = 1.0/LIC_Length(This) * M_PI * f;
X    
X    w =   b                          - a
X	+ sin(b*c)/c                 - sin(a*c)/c
X	+ sin(b*d + p)/d             - sin(a*d + p)/d
X	+ sin(b*(c+d) + p)/(2*(c+d)) - sin(a*(c+d) + p)/(2*(c+d));
X    if (c != d)
X	w +=  sin(b*(c-d) - p)/(2*(c-d))
X	    - sin(a*(c-d) - p)/(2*(c-d));
X    w /= 4;
X    return(w);
X}
X
X
Xdouble
XLIC_Ramp(LIC *This, double a, double b, int speed)
X    /*
X     * Compute the integral bewteen points a and b, a <= b, of a biased
X     * triangle filter:
X     *
X     *    k(s) = (s + L) / (2 * L)
X     */
X{
X    if (LIC_Length(This) == 0)
X	return(0.0);
X    else
X	return((a*a - b*b)/(4*LIC_Length(This)) + (a - b)/2);
X}
X
X
Xdouble
XLIC_Select(LIC *This, double a, double b, int speed)
X    /*
X     * Compute the integral bewteen points a and b, a <= b, of a 
X     * narrow Gaussian filter which sits at L-2 along the local
X     * streamline.  This filter's delta function like shape and
X     * it's location near the end of the local streamline means that
X     * the filter acts as a pixel selection filter. Hence it's name.
X     *
X     *    k(s) = 1/2*pi * e^(x - L + 2)^2 
X     */
X{
X    if (LIC_Length(This) == 0)
X	return(0.0);
X    else 
X	return(  erf((b - LIC_Length(This) + 2) / sqrt(2.0))
X	       - erf((a - LIC_Length(This) + 2) / sqrt(2.0)));
X}
END_OF_FILE
  if test 6091 -ne `wc -c <'lic.1.3/liblic/Filters.c'`; then
    echo shar: \"'lic.1.3/liblic/Filters.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/liblic/Filters.c'
fi
if test -f 'lic.1.3/liblic/LIC_Filters.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/liblic/LIC_Filters.3'\"
else
  echo shar: Extracting \"'lic.1.3/liblic/LIC_Filters.3'\" \(7604 characters\)
  sed "s/^X//" >'lic.1.3/liblic/LIC_Filters.3' <<'END_OF_FILE'
X.\" Copyright (c) 1993 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Lawrence Livermore National Laboratory and its
X.\"	contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.de Hd
X.ds Dt \\$4
X..
X.Hd $Header: /usr/local/src/lic/liblic/RCS/LIC_Filters.3,v 1.7 1993/08/10 23:35:32 casey Exp $
X.TH LIC_FILTERS 3 \*(Dt
X.SH NAME
XLIC_BuildIntegralTables, LIC_Box, LIC_Ripple, LIC_Ramp, LIC_Select \- Line Integral Convolution filter support
X.SH SYNOPSIS
X.nf
X#include <lic.h>
X
Xvoid \fBLIC_BuildIntegralTables\fP(LIC *\fIThis\fP)
Xdouble \fBLIC_Box\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ripple\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ramp\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Select\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X.fi
X.SH DESCRIPTION
X.if t .ds pi \(*p
X.if n .ds pi Pi
X.B LIC_BuildIntegralTables
Xbuilds tables of filter integral values for use in the LIC convolution
Xmethods.
X.B LIC_BuildIntegralTables
Xis automatically called by the convolution methods whenever any parameters
Xhave changed that will affect the filter integrals.
X.PP
XThe tables are discrete samples of the filter function integral for a
Xvariety of points along the filter kernel and for a variety of
X.IR speeds .
X.PP
XThe
X.I speed
Xvariations are used to implement the variable speed option of
X.BR LIC_Create .
XWith the variable speed option, high magnitude regions of the field will
Xuse higher
X.I speed
Xversions of the filter kernel.  These higher speeds variations are typically
Xfrequency scaled versions of the base frequency and are used in periodic
Xmotion animations to give the appearance of higher speed in higher magnitude
Xregions of the vector field.
XHowever, it is up to each filter integral function to implement its own
Xinterpretation of
X.I speed
X(see
X.B LIC_Ripple
Xbelow).
X.PP
XThe tables are broken up into integral values for the
Xpositive and negative halves of the filter integral as follows:
X.PP
X.RS
X.nf
Xpos[\fIspeed\fP][\fIsi\fP] = \fIFilter\fP(\fIThis\fP, 0.0, \fIs\fP, \fIspeed\fP)
Xneg[\fIspeed\fP][\fIsi\fP] = \fIFilter\fP(\fIThis\fP, -\fIs\fP, 0.0, \fIspeed\fP)
X
Xwhere
X
X0 <= \fIsi\fP < \fBLIC_INTEGRAL_LEN\fP
X0 <= \fIspeed\fP < \fBLIC_INTEGRAL_SPEEDS\fP
X
X\fIs\fP = \fILength\fP * ((double)\fIsi\fP / \fBLIC_INTEGRAL_LEN\fP)
X.fi
X.RE
X.PP
XCurrently
X.B LIC_INTEGRAL_LEN
Xis 2048 and
X.B LIC_INTEGRAL_SPEEDS
Xis 20.
X.PP
XThe tables are built up by calling a user specified filter integration
Xfunction for each of the above discrete sample points.  A simple example
Xis a ramp filter:
X.PP
X.RS
X.nf
X\fIk\fP(\fIs\fP) = (\fIs\fP + \fIL\fP) / 2\fIL\fP
X
Xintegral { \fIk\fP(\fIs\fP) \fIds\fP } = \c
X.if t (\fIs\fP\u\s-22\s+2\d + 2\fIL\fP\|\fIs\fP)/4\fIL\fP
X.if n (\fIs\fP^2 + 2\fIL\fP*\fIs\fP)/4\fIL\fP
X.fi
X.RE
X.PP
XWhich yields the following LIC filter integral function (with some algebraic
Xsimplifications):
X.PP
X.RS
X.nf
Xdouble
XLIC_Ramp(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X{
X.RS
Xif (\fBLIC_Length\fP(\fIThis\fP) == 0)
X.RS
Xreturn(0.0);
X.RE
Xelse
X.RS
Xreturn((\fIa\fP*\fIa\fP - \fIb\fP*\fIb\fP)/(4*\fBLIC_Length\fP(\fIThis\fP)) + (\fIa\fP - \fIb\fP)/2);
X.RE
X.RE
X}
X.fi
X.RE
X.PP
XFilters supplied with
Xthe LIC library include:
X.PP
X.RS
X.nf
Xdouble \fBLIC_Box\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ripple\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ramp\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Select\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X.fi
X.RE
X.PP
X.B LIC_Box
Ximplements a constant box shape filter: \fIk\fP(\fIs\fP) =  1.
X.PP
X.B LIC_Ripple
Ximplements a phase shifted Hanning ripple function, windowed by a Hanning
Xfunction: \fIk\fP(\fIs\fP) = (cos(\fId\fP*\fIs\fP + \fIphase\fP) + 1)/2
X* (cos(\fIc\fP*\fIs\fP) + 1)/2.
XWhere
X.I d
Xand
X.I c
Xare the dilation constants for the ripple and window functions,
Xrespectively, and
X.I phase
Xis the phase shift of the ripple function.
X.I d
Xand
X.I c
Xcontrol the number of cycles of the Hanning functions over the filter kernel
Xfrom
X.RI - Length
Xto
X.RI + Length .
X.I d
Xis equal to \fIfrequency\fP * \*(pi / \fILength\fP and
X.I c
Xis always equal to \*(pi / \fILength\fP.
X.I frequency
Xis computed as follows:
X.PP
X.RS
X.nf
X/*
X * Implement ``speed'' variations by scaling the frequency inversely
X * to speed.  This causes low magnitude vectors to be convolved using
X * a higher frequency filter which will yield less distinct output
X * features.  As the frequency increases the filter begins to approximate
X * the Hanning window filter.
X */
X\fIm\fP = 6.0 - 5.0*(double)\fIspeed\fP/(\fBLIC_INTEGRAL_SPEEDS\fP - 1);
X
X\fIfrequency\fP = \fBLIC_Frequency\fP(\fIThis\fP) * \fIm\fP;
X.fi
X.RE
X.PP
XThis causes high magnitude regions to have fast moving, long
Xblurred looking features and low magnitude regions to have
Xslow moving, small sharp features over a blurred base.
X.PP
X.B LIC_Ramp
Ximplements  a ramp shape filter whose value is
X.B 0
Xat
X.RI - Length
Xand
X.B 1
Xat
X.RI + Length :
X\fIk\fP(\fIs\fP) = (\fIs\fP + \fIL\fP) / 2\fIL\fP.
X.PP
X.B LIC_Select
Ximplements a pixel selection filter which uses a narrow Gaussian
Xfilter positioned
X.IR L -2
Xdistance along the local streamline. It is called a selection filter
Xbecause its effect is to select an approximately one pixel wide
Xsection of the input image near the end of the local streamline
Xunderneath the Gaussian and place it at the origin of the local
Xstreamline.  A narrow Gaussian was chosen for its low-pass filter
Xqualities and simple analytical form, and is given by:
X\fIk\fP(\fIs\fP) = 1 / 2 * exp(-(\fIs\fP + \fIL\fP - 2)^2).
X.SH "SEE ALSO"
X.BR LIC (3),
X.BR LIC_Convolve (3),
X.BR LIC_Create (3)
X.SH STANDARDS
XThis is unsupported, non-standard software.  It is not the subject of any
Xstandards effort.
END_OF_FILE
  if test 7604 -ne `wc -c <'lic.1.3/liblic/LIC_Filters.3'`; then
    echo shar: \"'lic.1.3/liblic/LIC_Filters.3'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/liblic/LIC_Filters.3'
fi
if test -f 'lic.1.3/liblic/liblic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/liblic/liblic.h'\"
else
  echo shar: Extracting \"'lic.1.3/liblic/liblic.h'\" \(6075 characters\)
  sed "s/^X//" >'lic.1.3/liblic/liblic.h' <<'END_OF_FILE'
X/*
X * $Header: /usr/local/src/lic/liblic/RCS/liblic.h,v 1.3 1993/05/28 04:27:31 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef _LIBLIC_H_
X#define _LIBLIC_H_
X
X
X/*
X * ANSI C and POSIX includes.
X */
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <string.h>
X#include <stdio.h>
X#include <sys/types.h>
X
X#include <math.h>
X
X#include <lic.h>
X
X
X/*
X * Input and output image configuration.  Should really be handled
X * dynamically at run-time ...
X */
X#if !defined(RGBA) && !defined(ABGR) && !defined(ARGB) && !defined(BGRA) \
X	&& !defined(RGB) && !defined(BGR) && !defined(MONOCHROME)
X#   define ARGB
X#endif
X
X#ifdef RGBA
X#   define PixelSize	4
X#   define PixelType	"RGBA"
X#   define ALPHA(i)	(i)[3]
X#   define RED(i)	(i)[0]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[2]
X#endif
X
X#ifdef BGRA
X#   define PixelSize	4
X#   define PixelType	"BGRA"
X#   define ALPHA(i)	(i)[3]
X#   define RED(i)	(i)[2]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[0]
X#endif
X
X#ifdef ARGB
X#   define PixelSize	4
X#   define PixelType	"ARGB"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[1]
X#   define GREEN(i)	(i)[2]
X#   define BLUE(i)	(i)[3]
X#endif
X
X#ifdef ABGR
X#   define PixelSize	4
X#   define PixelType	"ABGR"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[3]
X#   define GREEN(i)	(i)[2]
X#   define BLUE(i)	(i)[1]
X#endif
X
X#ifdef RGB
X#   define PixelSize	3
X#   define PixelType	"RGB"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[0]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[2]
X#endif
X
X#ifdef BGR
X#   define PixelSize	3
X#   define PixelType	"BGR"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[2]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[0]
X#endif
X
X#ifdef MONOCHROME
X#   define PixelSize	1
X#   define PixelType	"MONOCHROME"
X#   define ALPHA(i)	(i)[0]
X#endif
X
X
X/*
X * Access macros for row major rectilinear images and other array data.
X */
X#define INDEX_2D(f, x, y) \
X	((f).data + (f).Rank * ((y)*(f).Xres + (x)))
X
X#define INDEX_3D(f, x, y, z) \
X	((f).data + (f).Rank * (((z)*(f).Yres + (y))*(f).Xres + (x)))
X
X
X/*
X * Amount of bias used to insure that we step over pixel/cell boundaries
X * when performing vector field stream line advection.
X */
X#define ROUND_OFF	0.00001
X
X
X/*
X * Default parallel edge/vector tolerance.  If an advected stream line and
X * an edge meet at an angle less than or equal to PARALLEL_EDGE, treat it
X * as an intersection of parallel lines (sic) and extend the advected stream
X * line out till it meets the next edge.
X */
X#define SIN_PARALLEL	0.523359562429	/* sin(three degrees) */
X#ifndef M_PI
X#   define M_PI		3.141592653589793116
X#endif
X
X
X/*
X * Define DEBUG to dump out PostScript to draw the streamline for the
X * vector field cell where the condition ThisPixel is TRUE.  Use the
X * PostScript prologue DebugPrologue.ps in this directory to get nice
X * output.  Note that this only works for two-dimensional fields.
X */
X#ifdef DEBUG
X#   define ThisPixel  (i == 42 && j == 64)
X#endif
X
X
X/*
X * define REGISTER to register on some machines for speed ...
X */
X#define REGISTER  register
X
X
X/*
X * Handy macros.
X */
X#define SQUARE(x)	((x)*(x))
X#define SIGN(x)		(((x) > 0) ? 1 : (((x) < 0) ? -1 : 0))
X#define CLAMP(x)	(((x) > 255) ? 255 : (((x) < 0) ?  0 : (x)))
X
X
X/*
X * Macro to wrap pixel coordinates in a torus like topology: 0 .. width-1.
X */
X#define WRAP(i, width) \
X{ \
X    if ((i) < 0) \
X    { \
X	/* we'll never be off more than one width negatively */ \
X	(i) += (width); \
X    } \
X    else if ((i) >= (width)) \
X    { \
X	/* we may be very far off positively ... */ \
X	(i) %= (width); \
X    } \
X}
X
X
X/*
X * Macros to take the floor and ceil of real numbers representing coordinates
X * within a vector lattice.  Since we're dealing with lattice coordinates,
X * we know that we're dealing with positive numbers, so we get to use
X * trucation to get floor.  Moreover, since we definitely won't be working
X * with vector fields with indexes larger than an int, we get to do the
X * truncation by simply casting into an int.  Finally, since we're dealing
X * with lattice coordinates, we get to use truncation + 1 to get ceil.
X */
X#define FLOOR(x)  ((double)(int)(x))
X#define CEIL(x)   ((double)((int)(x) + 1))
X#define IFLOOR(x) ((int)(x))
X#define ICEIL(x)  ((int)(x) + 1)
X
X
X#endif /* _LIBLIC_H_ */
END_OF_FILE
  if test 6075 -ne `wc -c <'lic.1.3/liblic/liblic.h'`; then
    echo shar: \"'lic.1.3/liblic/liblic.h'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/liblic/liblic.h'
fi
if test -f 'lic.1.3/lic/Makefile.tmpl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/lic/Makefile.tmpl'\"
else
  echo shar: Extracting \"'lic.1.3/lic/Makefile.tmpl'\" \(1219 characters\)
  sed "s/^X//" >'lic.1.3/lic/Makefile.tmpl' <<'END_OF_FILE'
X#
X# $Header: /usr/local/src/lic/lic/RCS/Makefile.tmpl,v 1.4 1993/11/03 20:22:18 casey Exp $
X#
X      DEFINES = $(MMAP_DEFINES)
X
X        SRCS1 = lic.c
X        OBJS1 = lic.o
X     DEPLIBS1 = $(LIBLIC)
X     SYSLIBS1 = $(MPC_EXTRALIBS) -lm
X     PROGRAM1 = lic
X        MANS1 = lic.1
X
X         SRCS = $(SRCS1)
X          ALL = $(PROGRAM1)
X
Xall: $(ALL)
X
Xincludes:
X
X$(PROGRAM1): $(OBJS1) $(DEPLIBS1)
X	$(CC) $(CFLAGS) -o $(PROGRAM1) $(OBJS1) $(DEPLIBS1) $(SYSLIBS1)
X
Xinstall: $(ALL) $(BINDIR) install_$(MANINSTALL)
X	rm -f $(BINDIR)/$(PROGRAM1)
X	cp $(PROGRAM1) $(BINDIR)/$(PROGRAM1)
X	$(STRIP) $(BINDIR)/$(PROGRAM1)
X	chmod $(INSTBINPROT) $(BINDIR)/$(PROGRAM1)
X
Xinstall_man: $(MANROOT) $(MAN1DIR) lic.1
X	rm -f $(MAN1DIR)/$(PROGRAM1).$(MAN1EXT)
X	cp lic.1 $(MAN1DIR)/$(PROGRAM1).$(MAN1EXT)
X	chmod $(INSTMANPROT) $(MAN1DIR)/lic.$(MAN1EXT)
X
Xinstall_cat: $(MANROOT) $(MAN1DIR) lic.1
X	rm -f $(MAN1DIR)/lic.$(MAN1EXT)
X	$(NROFF) -man lic.1 > $(MAN1DIR)/$(PROGRAM1).$(MAN1EXT)
X	chmod $(INSTMANPROT) $(MAN1DIR)/$(PROGRAM1).$(MAN1EXT)
X
Xinstall_none:
X
X$(BINDIR) $(MANROOT) $(MAN1DIR):
X	mkdir $@
X
Xclean:
X	rm -f $(PROGRAM1) $(OBJS1)
X	rm -f *~ *.o core a.out MAKELOG
X
Xlint:
X	lint -x $(ALLDEFINES) $(SRCS)
X
Xdepend:
X
Xlic.o: lic.c $(BUILDINCTOP)/lic.h
END_OF_FILE
  if test 1219 -ne `wc -c <'lic.1.3/lic/Makefile.tmpl'`; then
    echo shar: \"'lic.1.3/lic/Makefile.tmpl'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/lic/Makefile.tmpl'
fi
if test -f 'lic.1.3/test/ElectroStatic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/test/ElectroStatic.c'\"
else
  echo shar: Extracting \"'lic.1.3/test/ElectroStatic.c'\" \(7826 characters\)
  sed "s/^X//" >'lic.1.3/test/ElectroStatic.c' <<'END_OF_FILE'
X/*
X * $Header: /usr/local/src/lic/test/RCS/ElectroStatic.c,v 1.7 1993/11/04 02:24:20 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /usr/local/src/lic/test/RCS/ElectroStatic.c,v 1.7 1993/11/04 02:24:20 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdio.h>
X
X#include <math.h>
X#include <sys/types.h>
X
X#if defined(HAS_MMAP)
X#   include <sys/mman.h>
X#endif
X
X
X#ifdef NEED_STRERROR
X    /*
X     * strerror is supposed to be defined in <string.h> and supplied in the
X     * standard C library according to the ANSI C X3.159-1989 specification,
X     * but Sun OS 4.1.1 fails to define or supply it ...  Unfortunately the
X     * only way we can control this is with an externally supplied define.
X     */
X    extern int      errno;		/* system error number */
X    extern char     *sys_errlist[];	/* system error messages */
X    extern int      sys_nerr;		/* number of entries in sys_errlist */
X
X    char *
X    strerror(int err)
X    {
X	if (err < 0 || err >= sys_nerr) {
X	    static char msg[100];
X
X	    sprintf(msg, "system error number %d", err);
X	    return(msg);
X	}
X	return(sys_errlist[err]);
X    }
X#endif
X
X
X/*
X * Create a three-dimensional electrostatic charge floating point vector
X * field.
X */
X
X
X#define SQUARE(x) ((x)*(x))
X
X#define N_CHARGES 2
Xdouble charge[N_CHARGES]   = { 1000.0, -1000.0 };
Xdouble charge_x[N_CHARGES] = { 1, -1 };
Xdouble charge_y[N_CHARGES] = { 1, -1 };
Xdouble charge_z[N_CHARGES] = { 1, -1 };
X
X
X/*
X * Internal routines to calculate electrostatic field values.
X */
Xdouble Fx(double x, double y, double z);
Xdouble Fy(double x, double y, double z);
Xdouble Fz(double x, double y, double z);
X
X
Xmain(int argc, char **argv)
X{
X    char          *myname;
X    char          *file;
X    int            Xres, Yres, Zres;
X    float         *VectorField;
X    size_t         FieldSize;
X    register int   i,  j, k;
X    register float x,  y,  z;
X    register float fx, fy, fz;
X    int            fd;
X    
X    myname = argv[0];
X    if (argc != 5)
X    {
X	fprintf(stderr, "\nUsage: %s file_name x_res y_res z_res\n", myname);
X	exit(1);
X    }
X    
X    /* grab arguments */
X    file = argv[1];
X    Xres = atoi(argv[2]);
X    Yres = atoi(argv[3]);
X    Zres = atoi(argv[4]);
X    FieldSize = Xres*Yres*Zres*(3*sizeof(float));
X    
X    /*
X     * Open the file here even for the non-mmap version just to make sure
X     * we can create it.  Have to use O_RDWR rather than O_WRONLY because
X     * the mmap version will end up ``paging in pages from the file'' (sic).
X     * In reality they'll just be zero fill on demand pages ...
X     */
X    fd = open(file, O_CREAT|O_TRUNC|O_RDWR, 0666);
X    if (fd < 0)
X    {
X	(void)fprintf(stderr, "%s: unable to open %s: %s\n",
X		      myname, file, strerror(errno));
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X
X#if defined(HAS_MMAP)
X
X    /*
X     * Pre-extend file to it's final size and map it into memory.
X     */
X    (void)lseek(fd, (off_t)(FieldSize - sizeof(fd)), SEEK_SET);
X    if (write(fd, (void *)&fd, sizeof(fd)) != sizeof(fd))
X    {
X	(void)fprintf(stderr, "%s: unable to preextend %s to %ld bytes: %s\n",
X		      myname, file, (int)FieldSize, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    VectorField = (float *)mmap((void *)0, (int)FieldSize, PROT_WRITE,
X			        MAP_SHARED, fd, (off_t)0);
X    if ((int)VectorField == -1)
X    {
X	(void)fprintf(stderr, "%s: unable to map %s: %s\n",
X		      myname, file, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    (void)close(fd);
X
X#else /* HAS_MMAP */
X
X    VectorField = (float *)malloc(FieldSize);
X    if (VectorField == NULL)
X    {
X	(void)fprintf(stderr, "%s: unable to allocate %d bytes of memory\n",
X		      myname, (int)FieldSize);
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    /*
X     * Should probably try to write the field now just to make sure there's
X     * enough disk space ...
X     */
X
X#endif /* HAS_MMAP */
X    
X    /*
X     * Create the electrostatic vector field ...
X     */
X    for (k = 0; k < Zres; k++)
X    {
X	z = (float)k/(float)Zres * 10.0 - 5.0;
X
X	for (j = 0; j < Yres; j++)
X	{
X	    y = (float)j/(float)Yres * 10.0 - 5.0;
X
X	    for (i = 0; i < Xres; i++)
X	    {
X		x = (float)i/(float)Xres * 10.0 - 5.0;
X		
X		fx = sqrt(fabs(Fx(x,y,z)));
X		fy = sqrt(fabs(Fy(x,y,z)));
X		fz = sqrt(fabs(Fz(x,y,z)));
X		
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 0] =  fx;
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 1] = -fy;
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 2] =  fz;
X	    }
X	}
X    }
X
X#if !defined(HAS_MMAP)
X    if (write(fd, (void *)VectorField, FieldSize) != FieldSize)
X    {
X	(void)fprintf(stderr, "%s: unable to write %ld bytes to %s: %s\n",
X		      myname, (int)FieldSize, file, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    (void)close(fd);
X#endif
X}
X
X
Xdouble
XFx(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((x - charge_x[i]) / sqrt(d2));
X    }
X    return(sum);
X}
X
X
Xdouble
XFy(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((y - charge_y[i]) / sqrt(d2));
X    }
X    return(sum);
X}
X
X
Xdouble
XFz(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((z - charge_z[i]) / sqrt(d2));
X    }
X    return(sum);
X}
END_OF_FILE
  if test 7826 -ne `wc -c <'lic.1.3/test/ElectroStatic.c'`; then
    echo shar: \"'lic.1.3/test/ElectroStatic.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/test/ElectroStatic.c'
fi
if test -f 'lic.1.3/test/SpiralField.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/test/SpiralField.c'\"
else
  echo shar: Extracting \"'lic.1.3/test/SpiralField.c'\" \(5068 characters\)
  sed "s/^X//" >'lic.1.3/test/SpiralField.c' <<'END_OF_FILE'
X/*
X * $Header: /usr/local/src/lic/test/RCS/SpiralField.c,v 1.7 1993/11/05 01:46:08 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /usr/local/src/lic/test/RCS/SpiralField.c,v 1.7 1993/11/05 01:46:08 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdio.h>
X
X
X/*
X * Create a three-dimensional floating point spiral vector field.  Each
X * vector will point 90 degrees, clockwise, away from the vertical (Z)
X * center of the field and slightly up: v(x, y, z) = (x, -y, 0.1).  Note
X * that the vector magnitudes are *not* equal to 1.0.
X */
X
X
X#ifdef NEED_STRERROR
X    /*
X     * strerror is supposed to be defined in <string.h> and supplied in the
X     * standard C library according to the ANSI C X3.159-1989 specification,
X     * but Sun OS 4.1.1 fails to define or supply it ...  Unfortunately the
X     * only way we can control this is with an externally supplied define.
X     */
X    extern int      errno;		/* system error number */
X    extern char     *sys_errlist[];	/* system error messages */
X    extern int      sys_nerr;		/* number of entries in sys_errlist */
X
X    char *
X    strerror(int err)
X    {
X	if (err < 0 || err >= sys_nerr) {
X	    static char msg[100];
X
X	    sprintf(msg, "system error number %d", err);
X	    return(msg);
X	}
X	return(sys_errlist[err]);
X    }
X#endif
X
X
Xmain(int argc, char *argv[])
X{
X    char          *myname;
X    char          *file;
X    int            Xres, Yres, Zres;
X    float         *VectorField;
X    register float fx, fy;
X    register int   i, j, k;
X    int            fd, cc;
X
X    myname = argv[0];
X    if (argc != 5)
X    {
X	(void)fprintf(stderr, "usage: %s file-name x-res y-res z-res\n",
X		      myname);
X	exit(EXIT_FAILURE);
X    }
X
X    /* grab arguments */
X    file    = argv[1];
X    Xres    = atoi(argv[2]);
X    Yres    = atoi(argv[3]);
X    Zres    = atoi(argv[4]);
X
X    VectorField = (float *)malloc(sizeof(float)*Yres*Xres*Zres*3);
X    if (VectorField == NULL)
X    {
X	(void)fprintf(stderr, "%s: insufficient memory for creating the spiral"
X		      " field\n", myname);
X	exit(EXIT_FAILURE);
X    }
X
X    for ( k = 0; k < Yres; k++ )
X    {
X       for ( j = 0; j < Yres; j++ )
X       {
X	  fy = (float)j/(float)(Yres-1) - 0.5;
X	  for ( i = 0; i < Xres; i++ )
X	  {
X	     fx = (float)i/(float)(Xres-1) - 0.5;
X	     VectorField[3*(k*Xres*Yres + (Yres-1 - j)*Xres + i) + 0] =  fy;
X	     VectorField[3*(k*Xres*Yres + (Yres-1 - j)*Xres + i) + 1] = -fx;
X	     VectorField[3*(k*Xres*Yres + (Yres-1 - j)*Xres + i) + 2] = 0.1;
X	  }
X       }
X    }
X
X    fd = open(file, O_CREAT|O_TRUNC|O_WRONLY, 0666);
X    if (fd < 0)
X    {
X	(void)fprintf(stderr, "%s: unable to open %s: %s\n", myname, file,
X		      strerror(errno));
X	exit(EXIT_FAILURE);
X    }
X
X    cc = write(fd, VectorField, 3*sizeof(float)*Xres*Yres*Zres);
X    if (cc != 3*sizeof(float)*Xres*Yres*Zres)
X    {
X	(void)fprintf(stderr, "%s: write returned short (%d): %s\n",
X		      myname, cc, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X    }
X    (void)close(fd);
X    exit(EXIT_SUCCESS);
X}
END_OF_FILE
  if test 5068 -ne `wc -c <'lic.1.3/test/SpiralField.c'`; then
    echo shar: \"'lic.1.3/test/SpiralField.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/test/SpiralField.c'
fi
if test -f 'lic.1.3/test/SpotNoise.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.3/test/SpotNoise.c'\"
else
  echo shar: Extracting \"'lic.1.3/test/SpotNoise.c'\" \(6438 characters\)
  sed "s/^X//" >'lic.1.3/test/SpotNoise.c' <<'END_OF_FILE'
X/*
X * $Header: /usr/local/src/lic/test/RCS/SpotNoise.c,v 1.3 1993/11/04 02:24:20 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /usr/local/src/lic/test/RCS/SpotNoise.c,v 1.3 1993/11/04 02:24:20 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X/*
X * Create a spot noise image.  Place Gaussian blobs down in a pseudo-poisson
X * distribution using a jittered sampling technique ala Cook and Dippe.
X */
X
X
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <math.h>
X
X#include <lic.h>
X
X
X#if (defined(NEED_STRERROR))
X    /*
X     * strerror is supposed to be defined in <string.h> and supplied in the
X     * standard C library according to the ANSI C X3.159-1989 specification,
X     * but Sun OS 4.1.1 fails to define or supply it ...  Unfortunately the
X     * only way we can control this is with an externally supplied define.
X     */
X    extern int      errno;		/* system error number */
X    extern char     *sys_errlist[];	/* system error messages */
X    extern int      sys_nerr;		/* number of entries in sys_errlist */
X
X    char *
X    strerror(int err)
X    {
X	if (err < 0 || err >= sys_nerr) {
X	    static char msg[100];
X
X	    sprintf(msg, "system error number %d", err);
X	    return(msg);
X	}
X	return(sys_errlist[err]);
X    }
X#endif
X
X
X/*
X * Generate X_N_SPOTS by Y_N_SPOTS in image.  Each spot will be a soft Gaussian
X * blob 2*X_HALF_WIDTH by 2*Y_HALF_WIDTH.
X */
X#define X_N_SPOTS	20
X#define Y_N_SPOTS	20
X
X#define X_HALF_WIDTH	20
X#define Y_HALF_WIDTH	20
X
X
Xvoid RenderSpot(unsigned char *Image, int Xres, int Yres, int psize,
X		int u, int v);
Xdouble normal(double x, double s, double m);
X
X
Xmain(int argc, char *argv[])
X{
X    char          *myname;
X    char          *file;
X    int            Xres, Yres;
X    unsigned char *Image;
X    size_t         psize, ImageSize;
X    register int   i, j;
X    int            fd, cc;
X
X    myname = argv[0];
X    if (argc != 4)
X    {
X	(void)fprintf(stderr, "usage: %s file_name x_res y_res\n", myname);
X	exit(EXIT_FAILURE);
X    }
X
X    /* grab arguments */
X    file = argv[1];
X    Xres = atoi(argv[2]);
X    Yres = atoi(argv[3]);
X    
X    psize     = LIC_ConfiguredPixelSize();
X    ImageSize = sizeof(unsigned char) * Xres * Yres;
X    Image     = (unsigned char *) malloc(ImageSize*psize);
X
X    if (Image == NULL)
X    {
X	(void)fprintf(stderr, "%s: insufficient memory for creating the image"
X		      " field\n", myname);
X	exit(EXIT_FAILURE);
X    }
X
X    fd = open(file, O_CREAT|O_TRUNC|O_WRONLY, 0666);
X    if (fd < 0)
X    {
X	(void)fprintf(stderr, "%s: unable to open %s: %s\n", myname, file,
X		      strerror(errno));
X	exit(EXIT_FAILURE);
X    }
X
X    srand(98639);	/* Seed with a prime number */
X    for (i = 1; i < X_N_SPOTS; i++)
X    {
X	for (j = 1; j < Y_N_SPOTS; j++)
X	{
X	    register int x, y;
X
X	    x = ((rand()/(double)RAND_MAX - 0.5) * 0.70 + i)/X_N_SPOTS
X		* (double)Xres;
X	    y = ((rand()/(double)RAND_MAX - 0.5) * 0.70 + j)/Y_N_SPOTS
X		* (double)Yres;
X
X#	    if (defined(DEBUG))
X		fprintf(stderr, "Spot %d %d placed at %d %d\n", i, j, x, y);
X		fflush(stderr);
X#	    endif
X
X	    RenderSpot(Image, Xres, Yres, psize, x, y);
X	}
X    }
X
X    cc = write(fd, Image, ImageSize*psize);
X    if (cc != ImageSize*psize)
X    {
X       (void)fprintf(stderr, "%s: write returned short: %s\n", myname,
X		     strerror(errno));
X       (void)close(fd);
X       exit(EXIT_FAILURE);
X    }
X    (void)close(fd);
X
X    exit(EXIT_SUCCESS);
X}
X
X
Xvoid
XRenderSpot(unsigned char *Image, int Xres, int Yres, int psize, int u, int v)
X{
X    register int            i, j, k;
X    register float          x, y, dx, dy, d, sigma;
X    register int            pixel_value;
X    register unsigned char *image;
X
X    image = &Image[(v*Xres + u)*psize];
X
X    sigma = 2.0;
X    dx = 8.0*sigma / (float)X_HALF_WIDTH;
X    dy = 8.0*sigma / (float)Y_HALF_WIDTH;
X
X    for (i = -X_HALF_WIDTH; i <= X_HALF_WIDTH; i++)
X	if (0 <= v + i  &&  v + i < Xres)
X	{
X	    x = i*dx;
X
X	    for (j = -Y_HALF_WIDTH; j <= Y_HALF_WIDTH; j++)
X		if (0 <= u + j  &&  u + j < Yres)
X		{
X		    y = j*dy;
X		    d = sqrt(x*x + y*y);
X		    pixel_value = 650.0 * normal(d, sigma, 0.0);
X		    if (pixel_value > 255)
X			pixel_value = 255;
X
X		    if (image[(j*Xres + i)*psize] < pixel_value)
X			for (k = 0; k < psize; k++)
X			    image[(j*Xres + i)*psize + k] = pixel_value;
X		}
X	}
X}
X
X
Xdouble
Xnormal(double x, double s, double m)
X{
X    return(1.0/sqrt(M_PI*2*(s)) * exp(-(((x)-(m))*((x)-(m)))/(2*(s)*(s))));
X}
END_OF_FILE
  if test 6438 -ne `wc -c <'lic.1.3/test/SpotNoise.c'`; then
    echo shar: \"'lic.1.3/test/SpotNoise.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.3/test/SpotNoise.c'
fi
echo shar: End of archive 7 \(of 9\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
