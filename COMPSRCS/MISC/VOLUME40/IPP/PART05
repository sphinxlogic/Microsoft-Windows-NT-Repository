Newsgroups: comp.sources.misc
From: db15@ukc.ac.uk (Damiano Bolla)
Subject: v40i163:  ipp - IPP Routing Architecture Toolkit, Part05/06
Message-ID: <1993Nov24.193907.7780@sparky.sterling.com>
X-Md4-Signature: f70a9464e656ee9ee424f9568c63f71e
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Computing Lab, University of Kent at Canterbury, UK.
Date: Wed, 24 Nov 1993 19:39:07 GMT
Approved: kent@sparky.sterling.com

Submitted-by: db15@ukc.ac.uk (Damiano Bolla)
Posting-number: Volume 40, Issue 163
Archive-name: ipp/part05
Environment: INET

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  IPP/README IPP/config/ex1/1.1config
#   IPP/config/ex1/1.20config IPP/config/ex1/1.30config
#   IPP/config/ex1/15config IPP/config/ex1/2config IPP/config/ex1/run
#   IPP/config/ex2/4config IPP/ethernet/EthParseCall.c
#   IPP/ethernet/NewAddress.c IPP/ethernet/ProcessPacket.c
#   IPP/host/ReceivePacket.c IPP/host/host.c IPP/include/defs.h
#   IPP/include/ethernet.h IPP/include/func_defs.h IPP/include/host.h
#   IPP/lib/route/AddressMatch.c IPP/lib/route/FindHostRoute.c
#   IPP/lib/route/ShowInterface.c IPP/lib/route/WhatIsIt.c
#   IPP/lib/utils/Accept.c IPP/lib/utils/GetAddress.c
#   IPP/lib/utils/Listen.c IPP/lib/utils/ReadConfig.c
#   IPP/lib/utils/SafeRead.c IPP/lib/utils/WatchDog.c
#   IPP/monitor/Send.c
# Wrapped by kent@sparky on Wed Nov 24 11:51:05 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 6)."'
if test -f 'IPP/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/README'\"
else
  echo shar: Extracting \"'IPP/README'\" \(1561 characters\)
  sed "s/^X//" >'IPP/README' <<'END_OF_FILE'
XAuthor Damiano Bolla, 1993
XAll parts of this Toolkit are under the GNU Copyright.
X
XThis is a toolkit that allow you to play with IPP addresses and
Xnetwork topology. 
X
XTo compile the programs you should just type make at this level.
XThe resulting programs will then be in the various subdirectory. What 
Xfollows is a description of what each subdirectory contains.
XFor further reading just have a look at the README in the subdirs.
X
Xconfig
X	Contains the config files to set up the two topology examples
X	described in the postscript notes.
X
Xdocs
X
Xethernet
X	A program that simulates the ethernet behaviour. It is 
X	working but not used at the moment. 
X
Xhost
X	This simulate a host. It requires a config file in stdin
X	and will operate accordingly.
X
Xlogd
X	This is the daemon that display error messages from the 
X	various daemons. Always start this first in a separate window
X
Xmonitor
X	This is a simple console type host. It allows you to connect
X	to one router and then be part of the network. I.e. you can 
X	ask routers for information or set up things.
X
Xrouter
X	An example of IPP router using SOCKETS as medium for packets.
X	It requires a config file given in stdin and will route packets
X	according to the routing table.
X	It also understant data packets directed to him and act
X	accordingly.
X
XThis software is ready to be compiled with Solaris 2.2, just define
XSOCKLIB="-lsocket -lnsl";	export SOCKLIB
X
XIf you compile it on Linux do not define the above. 
XIf you compile it on SunOS do not define the above and look at the 
XREADME in the lib directory.
X
XDamiano
END_OF_FILE
  if test 1561 -ne `wc -c <'IPP/README'`; then
    echo shar: \"'IPP/README'\" unpacked with wrong size!
  fi
  # end of 'IPP/README'
fi
if test -f 'IPP/config/ex1/1.1config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/1.1config'\"
else
  echo shar: Extracting \"'IPP/config/ex1/1.1config'\" \(2038 characters\)
  sed "s/^X//" >'IPP/config/ex1/1.1config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 1.1
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
XInterface 1 sock no localhost 1039
X
X#Interface 1 sock yes
XInterface 2 sock yes
XInterface 3 sock yes
XInterface 4 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) below/here/above	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
XRoute Host 4 30 2 1
XRoute Host 5 30 2 1
XRoute Host 20 30 2 1
X
X# this syas that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
X#Route Net 1 1 1 2
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X#Route Parent dummy 12 1 2 
XRoute Parent dummy 2 1 1 
XRoute Parent dummy 20 0 2 
END_OF_FILE
  if test 2038 -ne `wc -c <'IPP/config/ex1/1.1config'`; then
    echo shar: \"'IPP/config/ex1/1.1config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex1/1.1config'
fi
if test -f 'IPP/config/ex1/1.20config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/1.20config'\"
else
  echo shar: Extracting \"'IPP/config/ex1/1.20config'\" \(2152 characters\)
  sed "s/^X//" >'IPP/config/ex1/1.20config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 1.20
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
XInterface 1 sock no localhost 1036
XInterface 2 sock no localhost 1043
X
X#Interface 1 sock yes
X#Interface 2 sock yes
XInterface 3 sock yes
XInterface 4 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) host/net/parent	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
XRoute Host 1 30 2 1
XRoute Host 3 30 2 1
XRoute Host 4 30 2 1
X#Route Host 5 5 4 1
XRoute Host 30 30 2 1
X
X# this syas that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X# The fields are as follows, routing host, interface, cost
X#Route Parent dummy 1 2 1
XRoute Parent dummy 16 1 1 
XRoute Parent dummy 1 0 2 
END_OF_FILE
  if test 2152 -ne `wc -c <'IPP/config/ex1/1.20config'`; then
    echo shar: \"'IPP/config/ex1/1.20config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex1/1.20config'
fi
if test -f 'IPP/config/ex1/1.30config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/1.30config'\"
else
  echo shar: Extracting \"'IPP/config/ex1/1.30config'\" \(2079 characters\)
  sed "s/^X//" >'IPP/config/ex1/1.30config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 1.30
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
XInterface 1 sock no localhost 1039
X
X#Interface 1 sock yes
XInterface 2 sock yes
XInterface 3 sock yes
XInterface 4 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) below/here/above	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
XRoute Host 1 1 1 1
XRoute Host 3 1 1 1
X#Route Host 4 4 4 1
XRoute Host 5 20 2 1
X#Route Host 20 20 2 1
X
X# this syas that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
X#Route Net 1 1 1 2
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X#Route Parent dummy 12 1 2 
XRoute Parent dummy 1 0 1 
XRoute Parent dummy 20 0	1 
X
END_OF_FILE
  if test 2079 -ne `wc -c <'IPP/config/ex1/1.30config'`; then
    echo shar: \"'IPP/config/ex1/1.30config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex1/1.30config'
fi
if test -f 'IPP/config/ex1/15config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/15config'\"
else
  echo shar: Extracting \"'IPP/config/ex1/15config'\" \(2088 characters\)
  sed "s/^X//" >'IPP/config/ex1/15config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 15
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
XInterface 1 sock no localhost 1026
X
X#Interface 1 sock yes
XInterface 2 sock yes
XInterface 3 sock yes
XInterface 4 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) below/here/above	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
X# NOTE: Next hop MUST be directly connected
XRoute Host 2 2 1 1
X#Route Host 5 5 4 1
XRoute Host 10 2 1 1
XRoute Host 11 16 2 1
X#Route Host 16 16 2 1
X
X# this syas that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
XRoute Net 1 2 0 1
XRoute Net 1 16 0 1
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X#Route Parent dummy 12 1 2 
X
END_OF_FILE
  if test 2088 -ne `wc -c <'IPP/config/ex1/15config'`; then
    echo shar: \"'IPP/config/ex1/15config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex1/15config'
fi
if test -f 'IPP/config/ex1/2config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/2config'\"
else
  echo shar: Extracting \"'IPP/config/ex1/2config'\" \(2181 characters\)
  sed "s/^X//" >'IPP/config/ex1/2config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 2
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
X#Interface 1 sock no localhost 4326
X#Interface 2 sock no localhost 4366
X
XInterface 1 sock yes
XInterface 2 sock yes
XInterface 3 sock yes
XInterface 4 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) below/here/above	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
X# NOTE: ALL next hop of a host must be directly connected
X# NOTE: You should NOT setup a route for a calling host.
XRoute Host 5 15 1 1
X# Route Host 10 10 2 1
XRoute Host 11 15 1 1
X#Route Host 15 15 1 1
XRoute Host 16 15 1 1
X
X# this says that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
XRoute Net 1 16 0 2
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X#Route Parent dummy 12 1 2 
X
END_OF_FILE
  if test 2181 -ne `wc -c <'IPP/config/ex1/2config'`; then
    echo shar: \"'IPP/config/ex1/2config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex1/2config'
fi
if test -f 'IPP/config/ex1/run' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex1/run'\"
else
  echo shar: Extracting \"'IPP/config/ex1/run'\" \(1858 characters\)
  sed "s/^X//" >'IPP/config/ex1/run' <<'END_OF_FILE'
X#!/bin/sh
X
XPATH=.:$PATH; export PATH
X
X# ------------------------------------------------------------------------
Xrouter <2config >2links &
Xecho "Router 2 started"
Xsleep 2
X
X# ---------------------------------------------------------------------------
X>script
Xdoscript 2 1 1
Xsed -f script <15config | router >15links &
Xecho "Router 15 started"
Xsleep 2
X
X# ---------------------------------------------------------------------------
X>script
Xdoscript 15 2 1
Xsed -f script <16config	| router >16links &
Xecho "Router 16 started"
Xsleep 2
X
X
X# ---------------------------------------------------------------------------
X>script 
Xdoscript 2 4 1
Xsed -f script <1.1config | router >1.1links &
Xecho "Router 1.1 started"
Xsleep 2
X
X# ---------------------------------------------------------------------------
X>script 
Xdoscript 1.1 2 1
Xsed -f script <1.30config | router >1.30links &
Xecho "Router 1.30 started"
Xsleep 2
X
X# ---------------------------------------------------------------------------
X>script 
Xdoscript 1.30 2 2
Xdoscript 16 3 1
Xsed -f script <1.20config | router >1.20links &
Xecho "Router 1.20 started"
Xsleep 2
X
X# ---------------------------------------------------------------------------
X# The runhost requires three parameters
X# 1) The router to be connected to , just the IPP number, ex: 1.1
X# 2) The interface to use of thet router, ex: 2
X# 3) The address of this host , just the IPP nbumber, ex: 1.3
X
Xxterm -geometry 26x55+1378+0 -e runhost 2 2 10 &
Xecho "Host 10 started"
X
Xxterm -geometry 27x55+1833+0 -e runhost 15 4 5 &
Xecho "Host 5 started"
X
Xxterm -geometry 26x55+1605+0 -e runhost 16 4 11 &
Xecho "Host 11 started"
X
Xxterm -geometry 28x55+2066+0 -e runhost 1.1 3 1.3  &
Xecho "Host 1.3 started"
X
Xxterm -geometry 28x55+2066+0 -e runhost 1.30 4 1.4  &
Xecho "Host 1.4 started"
X
Xxterm -geometry 28x55+2066+0 -e runhost 1.20 4 1.5  &
Xecho "Host 1.5 started"
X
END_OF_FILE
  if test 1858 -ne `wc -c <'IPP/config/ex1/run'`; then
    echo shar: \"'IPP/config/ex1/run'\" unpacked with wrong size!
  fi
  chmod +x 'IPP/config/ex1/run'
  # end of 'IPP/config/ex1/run'
fi
if test -f 'IPP/config/ex2/4config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/config/ex2/4config'\"
else
  echo shar: Extracting \"'IPP/config/ex2/4config'\" \(2201 characters\)
  sed "s/^X//" >'IPP/config/ex2/4config' <<'END_OF_FILE'
X# The config file is quite strict in terms of layout, Comments MUST start with a #
X# You cannot place comments anywhere you want...
X# You are allowed blank lines...
X# ONLY spaces are allowed as separators...
X# The FIRST thing you have to write is the address of the router.,
X
XAddress 4
X
X# The n you have to write the interface specification.. the thing begins with
X# a special keyword... otherwise it is too complicated.
X# The other thing is tha all parameters fit in one line... in the following order
X# Number LinkType Listen Parameters
X
X#Interface 1 sock no localhost 4326
X
XInterface 1 sock yes
XInterface 2 sock yes
XInterface 3 sock no localhost 4366
XInterface 4 sock no localhost 4366
XInterface 5 sock yes
X
X# Routing gets more complicated....
X# If a routing entry overwrite another one a WARNING message will follow !
X# Note how a routing entry does not know about interface technology
X#
X# The routing entry is more complicated... follows a list of explanation
X# 1) below/here/above	This indicate if the route is for this level. down up 
X# 2) number		Indicate the hash table entry this route is for
X# 4) number		Indicate the IPP address of next hop 1-254
X# 5) number		Indicate the interface 0==none	1-n
X# 6) number 		Indicate the cost of a route 1-254
X
X# Ex: the following entry says that the route for host 11 in this level
X# is trought the host 11 itself and uses interface 1 with cost 1
X# NOTE: ALL next hop of a host must be directly connected
X# NOTE: You should NOT setup a route for a calling host.
XRoute Host 1 2 3 1
XRoute Host 2 2 3 1
XRoute Host 3 3 4 1
XRoute Host 6 2 3 1
XRoute Host 7 3 4 1
XRoute Host 9 5 2 1
X
X# this syas that route to subnet 10 can be done trough router 11 that is not
X# directly connected with a cost of 1
X# The fact that router 11 is not directly connected means that it is on 
X# this same network.
X#Route Net 10 11 0 1
X
X# this says that a route to subnet 10 can be done via host 12 that is directly 
X# connected but with a cost of 2
X# Being directly connected means that the next hop is subnet.router
X#Route Net 10 12 1 2
X#Route Net 1 1 1 2
X
X# A route to the parent network, the dummy entry is used to somplify
X# the parsing algorithms.
X#Route Parent dummy 12 1 2 
X
END_OF_FILE
  if test 2201 -ne `wc -c <'IPP/config/ex2/4config'`; then
    echo shar: \"'IPP/config/ex2/4config'\" unpacked with wrong size!
  fi
  # end of 'IPP/config/ex2/4config'
fi
if test -f 'IPP/ethernet/EthParseCall.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/ethernet/EthParseCall.c'\"
else
  echo shar: Extracting \"'IPP/ethernet/EthParseCall.c'\" \(2207 characters\)
  sed "s/^X//" >'IPP/ethernet/EthParseCall.c' <<'END_OF_FILE'
X/* --------------------------------------------------------------------------
X * Ident: EthParseCall.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "commands.h"
X#include "debug.h"
X#include "ethernet.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This function is in charge of deciding what to do of a new connection
X * It has all the data it needs and will do whatewer is needed to do it.
X * It will close the new socket if needed...
X */	 
Xint EthParseCall ( struct Ethernet *eth, int newsocket, char *buff )
X   {
X   char *Command;
X   char *Argument;
X   char Null[2]={0};
X
X   /* Note the strtok breaking string, it is quite complex in a way		*/
X   if ((Command=strtok(buff, CMD_SEP)) ==NULL) Command=Null;
X   if ((Argument=strtok(NULL, CMD_SEP))==NULL) Argument=Null;
X
X   sprintf (dbg.msg,"EthParseCall: Command='%s' Argument='%s'",Command,Argument);
X   DebugCall ( ERR_MSG, DEBUG_TEXT );
X
X   if ( strcasecmp (Command,CMD_STAT) == 0 )
X      {
X      /* Good we should be sending back some statistics...			*/
X      EthStats ( eth, newsocket );
X      close (newsocket);
X      return (DONE);
X      }
X
X   if ( strcasecmp (Command,CMD_ADDR) == 0 )
X      {
X      /* Good we have a new host on the ethernet, let's add it to the array	*/
X      /* If it fails I close the socket ....					*/
X      if ( NewAddress ( eth, newsocket, Argument ) ) close (newsocket);
X      /* Mhhh, maybe this should be different... ???	Damiano			*/
X      return (DONE);
X      }
X
X   if ( strcasecmp (Command,CMD_DEBUG) == 0 )
X      {
X      dbg.current_level = ipp_atoi (Argument);
X      close (newsocket);
X      return (DONE);
X      }
X
X   /* mhhh, it does not look like that we have a command he ?			*/
X   /* Better signal it then,,..							*/
X   sprintf (dbg.msg,"EthParseCall: A command was expected, got '%s'",Command);
X   DebugCall ( ERR_NOCOMM, DEBUG_NOTICE );
X
X   /* we need to close the socket in any case.					*/
X   close (newsocket);
X   return (DONE);	/* No need to make a fuss out of it			*/
X   }
END_OF_FILE
  if test 2207 -ne `wc -c <'IPP/ethernet/EthParseCall.c'`; then
    echo shar: \"'IPP/ethernet/EthParseCall.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/ethernet/EthParseCall.c'
fi
if test -f 'IPP/ethernet/NewAddress.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/ethernet/NewAddress.c'\"
else
  echo shar: Extracting \"'IPP/ethernet/NewAddress.c'\" \(1703 characters\)
  sed "s/^X//" >'IPP/ethernet/NewAddress.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: NewAddress.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "commands.h"
X#include "debug.h"
X#include "ethernet.h"
X#include "packet.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
Xint NewAddress ( struct Ethernet *eth, int newsocket, char *Argument)
X   {
X   struct IPPaddr *NetAddr;
X   int    addr;
X   NetAddr = ipp_aton(Argument);
X   if ( NetAddr == NULL )
X      {
X      sprintf (dbg.msg,"NewAddress: Cannot convert %s ",Argument);
X      DebugCall ( ERR_BADADDR, DEBUG_ALERT );
X      return (NOT_DONE);
X      }
X
X   if ( NetAddr->Al > 0 ) addr = NetAddr->Addr[NetAddr->Al-1];
X   else addr = 0;
X
X   if ( (addr <=0) || (addr>(ADDR_NUM-2)) )
X      {
X      /* I got a problem here... this address is out of range !			*/
X      sprintf (dbg.msg,"NewAddress: Out of range address %d ",addr);
X      DebugCall ( ERR_BADADDR, DEBUG_ALERT );
X      return (NOT_DONE);
X      }
X
X   /* Ok, the address is ok, let's ad it to the host table			*/
X   if ( eth->IoFd[addr] && ExistFd ( eth->IoFd[addr], SOCK_TECH) )	
X      {
X      sprintf (dbg.msg,"NewAddress: requested port already in use %d ",addr);
X      DebugCall ( ERR_BADADDR, DEBUG_ALERT );
X      return (NOT_DONE);
X      }
X
X   /* Ok, nobody is using the entry, I can add it...				*/
X   /* WARNING: Closing channel ZERO is REALLY BAD !!!!				*/
X   if ( eth->IoFd[addr] ) close (eth->IoFd[addr] );
X   eth->IoFd[addr]=newsocket;
X   return (DONE);
X   }
X
X
END_OF_FILE
  if test 1703 -ne `wc -c <'IPP/ethernet/NewAddress.c'`; then
    echo shar: \"'IPP/ethernet/NewAddress.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/ethernet/NewAddress.c'
fi
if test -f 'IPP/ethernet/ProcessPacket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/ethernet/ProcessPacket.c'\"
else
  echo shar: Extracting \"'IPP/ethernet/ProcessPacket.c'\" \(1958 characters\)
  sed "s/^X//" >'IPP/ethernet/ProcessPacket.c' <<'END_OF_FILE'
X/* -------------------------------------------------------------------------
X * Ident: ProcessPacket.c
X * Author Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "debug.h"
X#include "ethernet.h"
X#include "packet.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X	 
Xint ProcessPacket ( struct Ethernet *eth, int  chan)	
X   {
X   struct IPP ipp;
X   int    Eof;		/* A flag to know if I have an EOF			*/
X   int    Dest;		/* The destination for this packet			*/
X
X   Eof = FALSE;
X
X   if ( RcvPack ( &ipp, eth->IoFd[chan], &Eof ) )
X      {
X      /* I had an error, reported by the error system..				*/
X      /* I may have gad just and EOF... let's seee....				*/
X      if ( Eof ) { close (eth->IoFd[chan]); eth->IoFd[chan]=0; }
X      /* I can't be bothered with reporting it..				*/
X      eth->BadPack++;
X      return (NOT_DONE);
X      }
X
X   /* Good we have a nice clean packet here.. 					*/
X   /* I have to look what is the destination of this				*/
X   Dest = ipp.NextHop;
X
X   /* now.. let me see, do I have a host on that address ???			*/
X   if ( eth->IoFd[Dest] == 0 )
X      {
X      /* Too bad... nobody is listning there !					*/
X      eth->LostPack++;
X      sprintf (dbg.msg,"ProcessPacket: Given address is %d ",Dest);
X      DebugCall ( ERR_BADADDR, DEBUG_ALERT );
X      return (NOT_DONE);
X      }
X
X   /* Good somebody is listning there, let's send the packet as it is		*/
X   Eof = FALSE;
X   if ( SndPack ( &ipp, eth->IoFd[Dest], &Eof ) )
X      {
X      /* Well, nothing very good tiday... this thing is a bit brokenn...	*/
X      /* Let me see... Did I have an EOF there ????				*/
X      if ( Eof ) { close (eth->IoFd[Dest]); eth->IoFd[Dest]=0; }
X      /* Can't be bthered to report it..					*/
X      return (NOT_DONE);
X      }
X
X   return (DONE);
X   }
END_OF_FILE
  if test 1958 -ne `wc -c <'IPP/ethernet/ProcessPacket.c'`; then
    echo shar: \"'IPP/ethernet/ProcessPacket.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/ethernet/ProcessPacket.c'
fi
if test -f 'IPP/host/ReceivePacket.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/host/ReceivePacket.c'\"
else
  echo shar: Extracting \"'IPP/host/ReceivePacket.c'\" \(1469 characters\)
  sed "s/^X//" >'IPP/host/ReceivePacket.c' <<'END_OF_FILE'
X/* ------------------------------------------------------------------------------
X * Ident: ReceivePacket.d
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "host.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
Xint ReceivePacket ( struct Host *hostdata )
X   {
X   int Eof;
X   struct IPP     ippR;
X   struct IPPaddr addr;
X
X   Eof = FALSE;
X   RcvPack( &ippR, hostdata->NetFd, &Eof);
X   if ( Eof ) return (NOT_DONE);
X
X   ipp_StoA (&ippR,&addr);
X
X   if ( ippR.Type == PTYPE_DATA )
X      {
X      printf ("Data from %s ===== ",ipp_ntoa (&addr));
X      printf ("I am  %s \n",ipp_ntoa (&hostdata->Myaddr));
X      ippR.Data[ippR.DataLen] = 0;
X      printf ("%s \n",ippR.Data);
X      return (DONE);
X      }
X   
X   if ( ippR.Type == PTYPE_RR )
X      {
X      printf ("RR from %s ===== ",ipp_ntoa (&addr));
X      printf ("I am  %s \n",ipp_ntoa (&hostdata->Myaddr));
X      ippR.Data[ippR.DataLen] = 0;
X      printf ("%s \n",ippR.Data);
X      return (DONE);
X      }
X
X   if ( ippR.Type == PTYPE_PING )
X      {
X      printf ("Received PING packet from %s \n",ipp_ntoa(&addr));
X      return (DONE);
X      }
X
X   printf ("Unknown packet type %d from %s \n",ippR.Type, ipp_ntoa(&addr));
X   return (DONE);
X   }
END_OF_FILE
  if test 1469 -ne `wc -c <'IPP/host/ReceivePacket.c'`; then
    echo shar: \"'IPP/host/ReceivePacket.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/host/ReceivePacket.c'
fi
if test -f 'IPP/host/host.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/host/host.c'\"
else
  echo shar: Extracting \"'IPP/host/host.c'\" \(1833 characters\)
  sed "s/^X//" >'IPP/host/host.c' <<'END_OF_FILE'
X/* ------------------------------------------------------------------------------
X * Ident: host.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "host.h"
X#include "func_defs.h"
X
Xstruct Debug dbg;
X
X/* This is a host. It can only have one link 
X * The link is setup at startup time by command line.
X */
X
Xint main ( int argc, char *argv[] )
X   {
X   struct Host hostdata;
X   fd_set  readfds;
X   struct timeval timeout;
X   int error;
X
X   /* First thing to do is to setup the debugging unit...			*/
X   if ( DebugInit ( "localhost", "1234", "Host") ) return (1);
X
X   if ( HostInit ( &hostdata ) ) return (1);
X
X   strcpy (dbg.ident, ipp_ntoa(&hostdata.Myaddr));
X
X   sleep (5);
X
X   for (;;)
X      {
X      FD_ZERO (&readfds);  
X
X      /* We have to set the mask each time we come here...                      */
X      FD_SET (hostdata.NetFd, &readfds);
X
X      timeout.tv_sec = 1;       /* Timeout in  seconds                  */
X      timeout.tv_usec = 0;      /* and no microseconds         		*/
X
X      error = select  (MAX_FILES, &readfds, NULL, NULL, &timeout);
X
X      if ( error < 0 ) 
X         {
X         sprintf (dbg.msg,"Host: Select failed badly");
X         DebugCall ( ERR_MSG, DEBUG_ALERT );
X         }
X
X      if ( error == 0 ) 
X         {
X         sprintf (dbg.msg,"Host: Host is idle, let's send a packet");
X         DebugCall ( ERR_MSG, DEBUG_TEXT );
X         if ( SendPacket ( &hostdata ) ) return (0);
X         }
X
X      if ( (error > 0) && FD_ISSET (hostdata.NetFd, &readfds) ) 
X         if ( ReceivePacket ( &hostdata ) ) return (0);
X
X      }
X   }
END_OF_FILE
  if test 1833 -ne `wc -c <'IPP/host/host.c'`; then
    echo shar: \"'IPP/host/host.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/host/host.c'
fi
if test -f 'IPP/include/defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/include/defs.h'\"
else
  echo shar: Extracting \"'IPP/include/defs.h'\" \(1609 characters\)
  sed "s/^X//" >'IPP/include/defs.h' <<'END_OF_FILE'
X/* ----------------------------------------------------------------------
X * AUthor: Damiano Bolla, 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#ifndef DEFS_H
X#define DEFS_H
X
X/* This file include the definitions of what MUST be common.
X * Things MUST be defined ONCE !!!
X * NOTE: The following small set of constants MUST NOT be changed
X */
X
X#define DONE		0	/* Sam as below.. :-)				*/
X#define FALSE		0	/* So you can do if ( .. )		 	*/
X#define NOT_USED	0	/* Do not change this !!!!		 	*/
X
X#define NOT_DONE	-1	/* Do not change this			 	*/
X#define TRUE		-1	/* Anything different tan Zero		 	*/
X
X/* -------------------------------------------------------------------
X * General constants here
X */
X
X#define LISTEN_QUEUE	4	/* Length of thexlistening queue		*/
X#define SREAD_TOUT	5	/* Timeout for a SafeRead Function	 	*/
X#define IDLE_TOUT	30	/* Timeout to decide a select is idle (sec)	*/
X
X#define MAX_FILES	60	/* Max number of open files		 	*/
X#define ADDR_NUM	256	/* From 0 to 255			 	*/
X#define ADDR_DEPTH	16	/* The depthe of the tree can go 0->15	 	*/
X#define IPP_DATA	1024	/* Max data into an IPP packet		 	*/
X#define CONF_LLEN	1024	/* Maximum length of one config line	 	*/
X#define INIT_TTL	255	/* Initial TTL value			 	*/
X#define MAX_COST	254	/* A route cannot cost more than this	 	*/
X#define IP_NAMLEN	254	/* An ip name cannot be longer,,	 	*/
X
X#define SOCK_TECH	1	/* Link type uses this tecnology	 	*/
X#define SOCK_TECH_NAM	"sock"	/* The same as above but in ascii	 	*/
X
X#define CMD_SEP		" \t\n\r"	/* A command can be divided by	 	*/
X
X#define min(a,b) ((a) <= (b) ? (a) : (b))
X
X#endif
END_OF_FILE
  if test 1609 -ne `wc -c <'IPP/include/defs.h'`; then
    echo shar: \"'IPP/include/defs.h'\" unpacked with wrong size!
  fi
  # end of 'IPP/include/defs.h'
fi
if test -f 'IPP/include/ethernet.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/include/ethernet.h'\"
else
  echo shar: Extracting \"'IPP/include/ethernet.h'\" \(1035 characters\)
  sed "s/^X//" >'IPP/include/ethernet.h' <<'END_OF_FILE'
X/* ----------------------------------------------------------------------
X * AUthor: Damiano Bolla, 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#ifndef ETHERNET_H
X#define ETHERNET_H
X
X/* This file defines all things that are used by the ethernet system
X * In particular it defines a structure that holds all data useful
X * to describe the status of the ethernet driver.
X * In this way a singlepointer is passed around to the system.
X */
X
X
Xstruct Ethernet
X   {
X   char Host[IP_NAMLEN+2];	/* To store teh adress of this host		*/
X   int ListenPort;	/* The port used to accept incoming connections		*/
X   int ListenFd;	/* The file descriptor accepting incoming calls		*/
X   int IoFd[ADDR_NUM];	/* The array that holds the descriptors of connections	*/
X   fd_set readfds;	/* Used by select to know who is ready to read		*/
X   u_long Idle;		/* Counts how many seconds it has been idle		*/
X   u_long BadPack;	/* Counts the packets received that are bad		*/
X   u_long LostPack;	/* Counts the lost packets				*/
X   };
X
X#endif
END_OF_FILE
  if test 1035 -ne `wc -c <'IPP/include/ethernet.h'`; then
    echo shar: \"'IPP/include/ethernet.h'\" unpacked with wrong size!
  fi
  # end of 'IPP/include/ethernet.h'
fi
if test -f 'IPP/include/func_defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/include/func_defs.h'\"
else
  echo shar: Extracting \"'IPP/include/func_defs.h'\" \(1658 characters\)
  sed "s/^X//" >'IPP/include/func_defs.h' <<'END_OF_FILE'
X/* ----------------------------------------------------------------------
X * AUthor: Damiano Bolla, 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#ifndef FUNCDEFS_H
X#define FUNCDEFS_H
X
Xint   atoi  ( char *str );
Xint   ipp_atoi ( char *str );
X
Xchar *ReadConfig();
Xint Accept ( int Ring, int *Newsock, char *Msg, int MsgLen );
Xint Listen ( int *socket_id, char *host, int *port );
X
X#ifdef PACKET_H
Xstruct IPPaddr *ipp_aton( char *str );
Xchar   *ipp_ntoa ( struct IPPaddr *addr );
Xint Connect ( char *host, u_short port, int *sock, struct IPPaddr *Myaddr );
Xint SndPack ( struct IPP *ipp, int fd, int *Eof );
Xint RcvPack ( struct IPP *ipp, int fd, int *Eof );
Xint ipp_AtoS ( struct IPPaddr *src, struct IPP *dest );
Xint ipp_AtoR ( struct IPPaddr *src, struct IPP *dest );
Xint ipp_StoA ( struct IPP *src, struct IPPaddr *dest );
Xint ipp_RtoA ( struct IPP *src, struct IPPaddr *dest );
Xint ipp_AtoA ( struct IPPaddr *dest, struct IPPaddr *src );
Xint SetPackAddr ( struct IPP *ipp, struct IPPaddr *Snd, struct IPPaddr *Rcv );
Xint WhatIsIt ( struct IPPaddr *Myaddr, struct IPPaddr *dest );
X#endif
X
X#ifdef DEBUG_H
Xvoid DebugCall ( int ErrType, int ErrLevel );
Xint  DebugInit ( char *logd_host, char *logd_port, char *prog );
X#endif
X
X#ifdef ROUTER_H
Xint RouteHostMgr ( struct HostEntry *rdata );
Xint RouteNetMgr ( struct NetEntry *rdata );
Xint RouteAdd ( struct Routing *rinfo, char *Arg );
Xint FindHostRoute ( struct Routing *rinfo, u_char From, u_char Dest, u_char *NextHop, int *Interf );
Xint SeenAlready ( SeenData seendata, u_char Sender, u_char PackId );
Xint FindRoute ( struct Routing *rinfo, struct IPP *ipp, int    *Interf );
X#endif
X
X#endif
END_OF_FILE
  if test 1658 -ne `wc -c <'IPP/include/func_defs.h'`; then
    echo shar: \"'IPP/include/func_defs.h'\" unpacked with wrong size!
  fi
  # end of 'IPP/include/func_defs.h'
fi
if test -f 'IPP/include/host.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/include/host.h'\"
else
  echo shar: Extracting \"'IPP/include/host.h'\" \(1501 characters\)
  sed "s/^X//" >'IPP/include/host.h' <<'END_OF_FILE'
X/* ----------------------------------------------------------------------
X * AUthor: Damiano Bolla, 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#ifndef HOST_H
X#define HOST_H
X
X/* This file defines the structure that is used to hold the status 
X * information for the host program. 
X * A host program will just talk with anybody that it is told to.
X * The talk will be a pseudoramndom talk and the values will be given
X * by the network.
X * Statistics collection is also a duty of the host program.
X * On demand thi will report statistics..
X */
X
X#define PEER_MSG        256     /* Max size of a message between peers  	*/
X#define PEER_MAX	16	/* Max number of pers that a host can have	*/
X
Xstruct PeerStruct
X   {
X   struct IPPaddr Peer;		/* The address to where to send data		*/
X   int  Freq;			/* The proposed frequency of the talking X min	*/
X   u_long SndCount;	/* Number of packets sent to the remote side		*/
X   u_long RcvCount;	/* Number of packets received from the remote side	*/
X   };
X
Xstruct Host
X   {
X   struct IPPaddr Myaddr;	/* Ny address					*/
X   u_char Router;		/* The single byte address of the router	*/
X   u_char PackId;		/* Used to generate "unique" packet Id		*/
X   int    CurPeer; 		/* The perr I am sending messages		*/
X   struct PeerStruct Peer[PEER_MAX+2];	/* A number of peers to talk with	*/
X   u_long BadPack;		/* Number of bad packets received		*/
X   fd_set readfds;		/* For select...				*/
X   int    NetFd;		/* The network Fd to use...			*/
X   };
X
X#endif
END_OF_FILE
  if test 1501 -ne `wc -c <'IPP/include/host.h'`; then
    echo shar: \"'IPP/include/host.h'\" unpacked with wrong size!
  fi
  # end of 'IPP/include/host.h'
fi
if test -f 'IPP/lib/route/AddressMatch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/route/AddressMatch.c'\"
else
  echo shar: Extracting \"'IPP/lib/route/AddressMatch.c'\" \(1650 characters\)
  sed "s/^X//" >'IPP/lib/route/AddressMatch.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: AddressMatch.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <memory.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This function will see if the FULL Myaddr match the DestAddr
X * This should try to avoid memory fault :-)
X * It will return TRUE if they match, FALSE othervise
X */
Xint AddressMatch ( struct IPPaddr *MyAddr, struct IPPaddr *DestAddr, int Depth )
X   {
X   u_char *Taddr;
X
X   if ( (MyAddr==NULL) || (DestAddr==NULL) ) 
X      {
X      sprintf (dbg.msg,"AddressMatch: You gave me NULL pointers ! ");
X      DebugCall ( ERR_NULL, DEBUG_CRITICAL );
X      return (FALSE);
X      }
X
X   /* If the address depth is longer than the full length of my address
X    * what can I check ??? There is something very wrong here
X    */
X   if ( Depth >= MyAddr->Al ) return (FALSE);
X
X   /* This is really an error... what should I do ?? Debug ??			*/
X   if ( Depth+DestAddr->Al >= ADDR_DEPTH ) 
X      {
X      sprintf (dbg.msg,"AddressMatch: Depth is %d DestLeng is %d ",Depth,DestAddr->Al);
X      DebugCall ( ERR_BADDEPTH, DEBUG_ALERT );
X      return (FALSE);
X      }
X
X   /* I will the start checkng from here...					*/
X   Taddr = &MyAddr->Addr[Depth];
X
X   /* Ok, almost done, I just have to compare the two things			*/
X   if ( (memcmp(Taddr, DestAddr->Addr, DestAddr->Al)==0) && 
X        (DestAddr->Al == MyAddr->Al-Depth) ) return (TRUE);
X   else return (FALSE);
X   }
END_OF_FILE
  if test 1650 -ne `wc -c <'IPP/lib/route/AddressMatch.c'`; then
    echo shar: \"'IPP/lib/route/AddressMatch.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/route/AddressMatch.c'
fi
if test -f 'IPP/lib/route/FindHostRoute.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/route/FindHostRoute.c'\"
else
  echo shar: Extracting \"'IPP/lib/route/FindHostRoute.c'\" \(1844 characters\)
  sed "s/^X//" >'IPP/lib/route/FindHostRoute.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: FindHostRoute.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This tryes to find a route to the desired destination...
X * It wants the routing table, the destination, depth, and returns
X * what is the right next with the given depth and the interface.
X * NOTE: The interface returned is NOT a file descriptor it is anumber
X * indicating what interface to use !!!
X * NOTE: This ONLY find a route to a HOST in this net !
X */
Xint FindHostRoute ( struct Routing *rinfo, 
X	u_char From,
X	u_char Dest, 
X	u_char *NextHop, 
X	int *Interf )
X   {
X   struct HostEntry *Entry;
X   int    UseThis;
X
X   /* If this host has any route I can use it...				*/
X   /* Othervise I have to say there is no route available...			*/
X   Entry = &rinfo->hostdata[Dest];
X   UseThis = Entry->Direct;
X   if ( !UseThis )
X      {
X      sprintf (dbg.msg,"FindHostRoute: Cannot find any route to Host %d",Dest);
X      DebugCall ( ERR_BADROUTE, DEBUG_NOTICE );
X      return (NOT_DONE);
X      }
X
X   /* Let me see.. is the proposed route the one I got the packet from ?	*/
X   if ( Entry->Link[UseThis].Next == From ) 
X      UseThis = Entry->Another;
X
X   if ( !UseThis )
X      {
X      sprintf (dbg.msg,"FindHostRoute: No way to avoid a loop %d",Dest);
X      DebugCall ( ERR_BADROUTE, DEBUG_NOTICE );
X      rinfo->LoopCount++;
X      return (NOT_DONE);
X      }
X
X   *Interf  = Entry->Link[UseThis].Interface;
X   *NextHop = Entry->Link[UseThis].Next;
X   Entry->Link[UseThis].Cumulated += Entry->Link[UseThis].Cost;
X   RouteHostMgr ( Entry );
X   return (DONE);
X   }
END_OF_FILE
  if test 1844 -ne `wc -c <'IPP/lib/route/FindHostRoute.c'`; then
    echo shar: \"'IPP/lib/route/FindHostRoute.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/route/FindHostRoute.c'
fi
if test -f 'IPP/lib/route/ShowInterface.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/route/ShowInterface.c'\"
else
  echo shar: Extracting \"'IPP/lib/route/ShowInterface.c'\" \(1518 characters\)
  sed "s/^X//" >'IPP/lib/route/ShowInterface.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: ShowInterface.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "commands.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This one looks at the tree tables of routing and try to print them
X * in a nice way. The difficult thing is NOT to ooverflow th buffer.
X */
Xint ShowInterface ( struct Routing *rinfo, char *Buff, int Bufflen )
X   {
X   int c;
X   char *ptr;
X
X   ptr = Buff;
X
X   sprintf (ptr,"If \t Line \t Tech \t Ring \t Host \t Port \t Sent \t Received \n");
X   ptr += strlen (ptr);
X
X   for (c=1; c<=IF_MAX; c++)
X      {
X      /* If there is no data to show why bother ???				*/
X      if ( rinfo->ifdata[c].Line==0 && rinfo->ifdata[c].Ring==0 ) continue;
X
X      sprintf (ptr,"%d \t %d \t %d \t %d \t %s \t %d \t %d \t %d\n",c,
X        rinfo->ifdata[c].Line, rinfo->ifdata[c].Technology, 
X        rinfo->ifdata[c].Ring, rinfo->ifdata[c].RingHost, 
X        rinfo->ifdata[c].RingPort, rinfo->ifdata[c].Sent,
X        rinfo->ifdata[c].Received );
X      ptr += strlen (ptr);
X      if ( strlen (Buff) > Bufflen )
X         {
X         sprintf (dbg.msg,"ShowInterface: Not enough space in the buffer ");
X         DebugCall ( ERR_MEMFAULT, DEBUG_CRASH );
X         exit (1); 
X         }
X      }
X   return (DONE);
X   }
X
END_OF_FILE
  if test 1518 -ne `wc -c <'IPP/lib/route/ShowInterface.c'`; then
    echo shar: \"'IPP/lib/route/ShowInterface.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/route/ShowInterface.c'
fi
if test -f 'IPP/lib/route/WhatIsIt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/route/WhatIsIt.c'\"
else
  echo shar: Extracting \"'IPP/lib/route/WhatIsIt.c'\" \(2123 characters\)
  sed "s/^X//" >'IPP/lib/route/WhatIsIt.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------------
X * Ident: WhatIsIt.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <string.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
X/* This function will check if the dest address is a subnet of the 
X * given local address. It should be robust... and use the depth information
X * NOTE: The myaddr is in COMPLETE form, I.e. not relative to depth
X * It will return what the dest address is relative to the current address.
X * It will return it in the return paramenter.
X */
X
Xint WhatIsIt ( struct IPPaddr *Myaddr, struct IPPaddr *Dest )
X   {
X   int  BytesToCheck;
X   int  Remain;
X   int  More;
X   char *Myptr;
X   char *Deptr;
X   int  c;
X   u_char Depth;
X
X   Depth = Dest->Depth;
X
X   BytesToCheck = Myaddr->Al - Depth;
X   if ( BytesToCheck <= 0 ) return (NOT_DONE);
X
X   /* More counts the number of bytes up and down the above Remain		*/
X   More = Dest->Al-BytesToCheck;
X   /* If the dest address is shorter then where I am ... It is a parent		*/
X   if (More<0) return (IS_PARENTNET);
X
X   Myptr = &Myaddr->Addr[Depth];
X   Deptr = Dest->Addr;
X
X   /* Note that I go from 1 to ... since I count the bytes checked		*/
X   /* Weelll, circa, the following is correct :-)				*/
X   c=0;
X   while ( (c<BytesToCheck) && (*Myptr++ == *Deptr++) ) c++;
X
X   /* Remain counte the numebr of bytes difference that thre are between the
X    * address of the router and the destination address
X    */
X   Remain = BytesToCheck - c;
X
X   if ( Remain == 0 ) 
X      {
X      /* This can be my same host OR a subnet of my host			*/
X      if (More>0) return (IS_SUBNET);
X      else return (IS_THISHOST);
X      }
X
X   if ( Remain == 1 ) 
X      {
X      /* This can be a host of this net OR a subnet,,,..			*/
X      if (More> 0) return (IS_SUBNET);
X      else return (IS_SAMENET);
X      }
X   if ( Remain > 1 ) return (IS_PARENTNET);
X
X   /* The above series of if should cover all cases.. if it doesnt..		*/
X   return (NOT_DONE);
X   }
END_OF_FILE
  if test 2123 -ne `wc -c <'IPP/lib/route/WhatIsIt.c'`; then
    echo shar: \"'IPP/lib/route/WhatIsIt.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/route/WhatIsIt.c'
fi
if test -f 'IPP/lib/utils/Accept.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/Accept.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/Accept.c'\" \(1619 characters\)
  sed "s/^X//" >'IPP/lib/utils/Accept.c' <<'END_OF_FILE'
X/* -----------------------------------------------------------------------------
X * Ident: Accept.c
X * Author: Damiano Bolla
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "commands.h"
X#include "debug.h"
X#include "ethernet.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;	 
X
X/* This one accept a connection. It knows that there is omeone calling.
X * Once the connection is accepted it gets what the other side wants
X * The dialog MUST be non blocking !!!!!!
X */
X
Xint Accept ( int Ring, int *Newsock, char *Msg, int MsgLen )
X   {
X   struct sockaddr_in from_where;
X   int socksize;
X   int newsocket;
X   int Letti;
X
X   socksize = sizeof ( from_where );
X   newsocket = accept ( Ring, (struct sockaddr *)&from_where, &socksize );
X   if ( newsocket < 0 )
X      {
X      sprintf (dbg.msg,"Accept: accept Syscall failed ");
X      DebugCall ( ERR_NOACCEPT, DEBUG_ALERT );
X      return (NOT_DONE);
X      }
X
X   /* Ok, adesso il nuovo descriptor newsocket dovrebbe avere dei dati		*/
X   Letti = SafeRead ( SREAD_TOUT, newsocket, Msg, MsgLen);
X   if ( Letti == NOT_DONE )
X      {
X      sprintf (dbg.msg,"Accept: Nothing read from channel");
X      DebugCall ( ERR_SREAD, DEBUG_NOTICE );
X      close (newsocket);
X      return (NOT_DONE);
X      }
X
X   /* Ok, we have something here... we have to process it and do wht request	*/
X   *Newsock = newsocket;
X   Msg[Letti]=0;	/* Must be shure that there is a 0 at the end		*/
X   return (DONE);
X   }
END_OF_FILE
  if test 1619 -ne `wc -c <'IPP/lib/utils/Accept.c'`; then
    echo shar: \"'IPP/lib/utils/Accept.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/Accept.c'
fi
if test -f 'IPP/lib/utils/GetAddress.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/GetAddress.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/GetAddress.c'\" \(1924 characters\)
  sed "s/^X//" >'IPP/lib/utils/GetAddress.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: GetAddress.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "commands.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This function will try to read the network address of a machine from stdin
X * It returns NOT_DONE if it fails, DOEN otherwise...
X * Debugging is done via the logd daemon.
X */
X
Xint GetAddress ( struct IPPaddr* addr )
X   {
X   struct IPPaddr *tmp;
X   char *Line;	/* The command line I am parsing...				*/
X   char *Cmd;	/* The given command						*/
X   char *Arg;	/* The given argument						*/
X   char Null[2]={0};
X
X   if ( (Line=ReadConfig(stdin)) == NULL )
X      {
X      /* Hey almeno il mio indirizzo me lo devi dare !!!			*/
X      sprintf (dbg.msg,"GetAddress: You MUST give me my address !");
X      DebugCall ( ERR_CONFIG, DEBUG_CRITICAL );
X      return (NOT_DONE);
X      }
X
X   /* Ok, now... in general each config option is in key-value format		*/
X   /* So... what I need to do is to break the two and use the appropriate func	*/
X   if ((Cmd=strtok(Line,CMD_SEP))==NULL) Cmd=Null;
X
X   if ( strcasecmp (Cmd, CMD_ADDR) != 0 )
X      {
X      sprintf (dbg.msg,"GetAddress: You forgot the command ?? %s !",CMD_ADDR);
X      DebugCall ( ERR_CONFIG, DEBUG_CRITICAL );
X      return (NOT_DONE);
X      }
X
X   /* Ok , the remaining part is the wanted address...				*/
X   if ((Arg=strtok(NULL,CMD_SEP))==NULL) Arg=Null;
X   
X   if ( (tmp=ipp_aton(Arg)) == NULL )
X      {
X      sprintf (dbg.msg,"GetAddress: Cannot convert '%s'",Cmd );
X      DebugCall ( ERR_CONFIG, DEBUG_CRITICAL );
X      return (NOT_DONE);
X      }
X
X   /* good good... almost all done...						*/
X   ipp_AtoA ( addr, tmp );
X   return (DONE);
X   }
END_OF_FILE
  if test 1924 -ne `wc -c <'IPP/lib/utils/GetAddress.c'`; then
    echo shar: \"'IPP/lib/utils/GetAddress.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/GetAddress.c'
fi
if test -f 'IPP/lib/utils/Listen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/Listen.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/Listen.c'\" \(1813 characters\)
  sed "s/^X//" >'IPP/lib/utils/Listen.c' <<'END_OF_FILE'
X/* -------------------------------------------------------------------------
X * Ident: Listen.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <sys/types.h>
X#include <sys/socket.h>	
X#include <sys/utsname.h>
X#include <netinet/in.h>	
X#include <sys/utsname.h>
X#include <netdb.h>	
X#include <signal.h>	
X#include "defs.h"
X#include "debug.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This Function creates a socket and set it in Listen mode.
X * It requires the structure to handle errors and it will return
X * appropriate values on return.
X */
X
Xint Listen ( int *socket_id, char *host, int *port )
X   {
X   int listen_socket;
X   int address_len;
X   struct sockaddr_in address;	
X
X   listen_socket = socket ( AF_INET, SOCK_STREAM, 0);
X   if ( listen_socket < 0 ) 
X      {
X      sprintf (dbg.msg,"Listen: non poso creare il socket");
X      DebugCall ( ERR_NOLISTEN, DEBUG_CRITICAL );
X      return (NOT_DONE);
X      }
X
X   if ( listen ( listen_socket, LISTEN_QUEUE ) )
X      {
X      sprintf (dbg.msg,"Listen: Can't set socket to listen");
X      DebugCall ( ERR_NOLISTEN, DEBUG_CRITICAL );
X      close ( listen_socket );
X      return (NOT_DONE);
X      }
X
X   address_len = sizeof (struct sockaddr_in);
X   if ( getsockname (listen_socket, (struct sockaddr *)&address, &address_len ) )
X      {
X      sprintf (dbg.msg,"Listen: Can't get socket data with getsockname ");
X      DebugCall ( ERR_NOLISTEN, DEBUG_CRITICAL );
X      close ( listen_socket );
X      return (NOT_DONE);
X      }
X
X   /* I have to return/store the name of this host..			*/
X   gethostname (host, IP_NAMLEN);
X
X   /* Ok at this point all is fine I can return safely :-)		*/
X   *socket_id = listen_socket;
X   *port = ntohs(address.sin_port);
X   return (DONE);
X   }
END_OF_FILE
  if test 1813 -ne `wc -c <'IPP/lib/utils/Listen.c'`; then
    echo shar: \"'IPP/lib/utils/Listen.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/Listen.c'
fi
if test -f 'IPP/lib/utils/ReadConfig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/ReadConfig.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/ReadConfig.c'\" \(1543 characters\)
  sed "s/^X//" >'IPP/lib/utils/ReadConfig.c' <<'END_OF_FILE'
X/* ---------------------------------------------------------------------------
X * Ident: ReadConfig.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
X#define MAX_LINES	1000
X
Xextern struct Debug dbg;
X
X/* This function read from the config file and return only good entryes.
X * I.e. the returned pointer point s to a valid config option.
X * What it does is skip comments and blonk lines. Not much...
X * NOTE that it wants the file from where to read Ex: stdin...
X */
X
Xchar *ReadConfig ( FILE *input )
X   {
X   static char Risul[CONF_LLEN+2];	/* This will be the returned string	*/
X   char   *NlPtr;
X   int c;
X
X   /* I have to cycle around until either the string is NULL or found valid	*/
X   for (c=0; c<MAX_LINES; c++)
X      {
X      /* While reading I test for EOF in the direct caser.			*/
X      if ( fgets(Risul, CONF_LLEN, input) == NULL ) return (NULL);
X      if ( strlen(Risul) == 0 ) return (NULL);	/* Found an EOF ??		*/
X
X      /* The next two lines get rid of the possible newline at the end		*/
X      NlPtr = strchr (Risul, '\n');
X      if ( NlPtr ) *NlPtr=0;
X
X      if ( isalpha (Risul[0]) ) return (Risul);	/* Got a config string		*/
X      }
X
X   sprintf (dbg.msg,"ReadConfig: A config file longer than %d ???",MAX_LINES);
X   DebugCall ( ERR_CONFIG, DEBUG_CRITICAL );
X   return (NULL);
X   }
END_OF_FILE
  if test 1543 -ne `wc -c <'IPP/lib/utils/ReadConfig.c'`; then
    echo shar: \"'IPP/lib/utils/ReadConfig.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/ReadConfig.c'
fi
if test -f 'IPP/lib/utils/SafeRead.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/SafeRead.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/SafeRead.c'\" \(1729 characters\)
  sed "s/^X//" >'IPP/lib/utils/SafeRead.c' <<'END_OF_FILE'
X/* -------------------------------------------------------------------------
X * Ident: SafeRead.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <unistd.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#include "defs.h"
X#include "debug.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* this function will read from a socket in a safe way.
X * That is without blokiing if there is no data.
X * This returns the nuber of bytes read if all is fine.
X * It it fails... it returns NOT_DONE (-1) BUT it does NOT close the socket
X */
X
Xint SafeRead ( int tout, int fd, char *buff, int BuffSize )
X   {
X   fd_set readfds;
X   struct timeval timeout;
X   int    Letti;
X   int    error;
X
X   FD_ZERO ( &readfds );
X   FD_SET  ( fd, &readfds );
X   timeout.tv_sec  = tout;	/* Timeout in  seconds				*/
X   timeout.tv_usec = 0;		/* and no microseconds				*/
X
X   error = select  (MAX_FILES, &readfds, NULL, NULL, &timeout);
X   if ( error == 0 )
X      {
X      sprintf (dbg.msg,"SafeRead: Select timeout ");
X      DebugCall ( ERR_NOLISTEN, DEBUG_NOTICE );
X      /* NOTE: I am not closing the socket Damiano				*/
X      return (NOT_DONE);
X      }
X
X   if ( error < 0 )
X      {
X      sprintf (dbg.msg,"SafeRead: Select FAILED ");
X      DebugCall ( ERR_NOLISTEN, DEBUG_CRITICAL );
X      /* NOTE: I am not closing the socket Damiano				*/
X      return (NOT_DONE);
X      }
X
X   if ( error > 0 )
X      {
X      Letti = read (fd, buff, BuffSize);
X      sprintf (dbg.msg,"SafeRead: Read succeded ");
X      DebugCall ( ERR_MSG, DEBUG_TEXT );
X      return ( Letti );	/* Return the number of chars read			*/
X      }
X
X   /* Not that I can be here... anyway..					*/
X   return (NOT_DONE);   
X   }
END_OF_FILE
  if test 1729 -ne `wc -c <'IPP/lib/utils/SafeRead.c'`; then
    echo shar: \"'IPP/lib/utils/SafeRead.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/SafeRead.c'
fi
if test -f 'IPP/lib/utils/WatchDog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/lib/utils/WatchDog.c'\"
else
  echo shar: Extracting \"'IPP/lib/utils/WatchDog.c'\" \(2051 characters\)
  sed "s/^X//" >'IPP/lib/utils/WatchDog.c' <<'END_OF_FILE'
X/* --------------------------------------------------------------------------------
X * Ident: WatchDog.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X
X#include <stdio.h>
X#include <unistd.h>
X#include <sys/types.h>
X#include <signal.h>
X#include "defs.h"
X#include "debug.h"
X#include "watchdog.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
X/* This is a set of functions that deal with errors in a program.
X * In this case what I need to avoid at all cost is a program stopping in a syscall
X * It is too difficult to try to make all syscall non bloking with a recovery
X * system.. therefore I need a sort of hartbeat that when it stops kill teh program.
X * This is therefore the purpose of this bit. 
X * Of course not all programs will need this but ethernet, router and host.. yes !
X */
X
Xvoid Handler ( int Sig )
X   {
X   if ( Sig == SIGALRM )
X      {
X      /* I really got a signalarm... too bad !					*/
X      sprintf (dbg.msg,"Signal Handler: Got a Sigalarm from the WatchDog ! ");
X      DebugCall ( ERR_ALARM, DEBUG_PANIC );
X      chdir ("/tmp");	/* I want the core to be here... possibly		*/
X      abort ();		/* End the program AND generate a core			*/
X      exit (1);		/* Just in case...					*/
X      }
X
X   /* mhhh, why am I here ??? better tell and then die..			*/
X   sprintf (dbg.msg,"Signal Handler: Got Signal %d I core and then die! ",Sig);
X   DebugCall ( ERR_SIGNAL, DEBUG_PANIC );
X   chdir ("/tmp");	/* I want the core to be here... possibly		*/
X   abort ();		/* End the program AND generate a core			*/
X   exit (1);		/* Just in case...					*/
X   }
X
X
X
X/* This is in charge to prepare the Watchdog Handler
X * It will NOT start the watchdog !!!!
X */
Xvoid WatchDogInit ( void (*Handler)() )
X   {
X   /* This cannot fail.. can it ??? :-)						*/
X   signal ( SIGALRM, Handler );
X   signal ( SIGSEGV, Handler );
X   signal ( SIGTERM, Handler );
X   }
X
X/* This function will activate the timer (in seconds)
X * If the value is Zero it deactivate it.
X */
Xint WatchDog ( int Sec ) { return (alarm (Sec)); }
END_OF_FILE
  if test 2051 -ne `wc -c <'IPP/lib/utils/WatchDog.c'`; then
    echo shar: \"'IPP/lib/utils/WatchDog.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/lib/utils/WatchDog.c'
fi
if test -f 'IPP/monitor/Send.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IPP/monitor/Send.c'\"
else
  echo shar: Extracting \"'IPP/monitor/Send.c'\" \(1895 characters\)
  sed "s/^X//" >'IPP/monitor/Send.c' <<'END_OF_FILE'
X/* ------------------------------------------------------------------------------
X * Ident: Send.c
X * Author: Damiano Bolla 1993
X * All this project is covered by the GNU Copyright.
X */
X
X#include <stdio.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netdb.h>
X#include <sys/time.h>
X#include <netinet/in.h>
X#include "defs.h"
X#include "debug.h"
X#include "packet.h"
X#include "router.h"
X#include "func_defs.h"
X
Xextern struct Debug dbg;
X
Xint Send ( struct IPPaddr *myaddr, int talksock, u_char NextHop , u_char *PackId)
X   {
X   struct IPPaddr *dest;
X   struct IPP	  ippS;
X   char   Tbuff[CONF_LLEN+2];
X   char   TmpBuff[CONF_LLEN+2];
X   int    Eof;
X   u_char Mylastbyte;
X
X   TmpBuff[0]=0;	/* I must be shure it is empty		*/
X   Mylastbyte = myaddr->Addr[myaddr->Al -1];
X
X   fflush (stdin); fflush (stdout);
X   printf ("%s Destination  > ",ipp_ntoa(myaddr));fflush (stdout);
X   while ( TtyGets(Tbuff,CONF_LLEN), strlen(Tbuff) == 0);
X   dest = ipp_aton (Tbuff);
X   if ( dest == NULL ) return (DONE); 
X
X   fflush (stdin); fflush (stdout);
X   printf ("Packet Type (Ping, Record-route, Data)  > ");fflush (stdout);
X   TtyGets(Tbuff,CONF_LLEN);
X   if ( Tbuff[0] == 'p' ) ippS.Type = PTYPE_PING;
X   if ( Tbuff[0] == 'r' ) ippS.Type = PTYPE_RR;
X   if ( Tbuff[0] == 'd' ) 
X      {
X      ippS.Type = PTYPE_DATA;
X      fflush (stdin);
X      printf ("Message  > ");fflush (stdout);
X      TtyGets (TmpBuff,CONF_LLEN);
X      } 
X
X   ipp_AtoS ( myaddr, &ippS );	
X   ipp_AtoR ( dest, &ippS );
X   ippS.NextRouter = NOT_USED;
X   ippS.NextHop = NextHop;
X   ippS.From = Mylastbyte;
X   ippS.Sender = Mylastbyte;
X   ippS.PackId = ++(*PackId);
X
X   ippS.Depth=0;
X   ippS.TTL=INIT_TTL;
X
X   ippS.DataLen = strlen(TmpBuff);
X   strcpy (ippS.Data,TmpBuff);
X
X   Eof = FALSE;
X   if ( SndPack( &ippS, talksock, &Eof) ) printf ("Send failed \n");
X   if ( Eof ) return (NOT_DONE);
X   return (DONE);
X   }
END_OF_FILE
  if test 1895 -ne `wc -c <'IPP/monitor/Send.c'`; then
    echo shar: \"'IPP/monitor/Send.c'\" unpacked with wrong size!
  fi
  # end of 'IPP/monitor/Send.c'
fi
echo shar: End of archive 5 \(of 6\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 6 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
