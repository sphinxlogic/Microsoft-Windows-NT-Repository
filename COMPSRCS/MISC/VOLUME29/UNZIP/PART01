Newsgroups: comp.sources.misc
From: info-zip@cs.ucla.edu
Subject:  v29i031:  unzip - Info-ZIP's portable UnZip v4.2, Part01/12
Message-ID: <csm-v29i031=unzip.224424@sparky.IMD.Sterling.COM>
X-Md4-Signature: 053cf105e87df231018565806bef5456
Date: Fri, 3 Apr 1992 04:47:44 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: info-zip@cs.ucla.edu (Info-Zip)
Posting-number: Volume 29, Issue 31
Archive-name: unzip/part01
Environment: Unix, VMS, OS/2, MS-DOS, Amiga, Macintosh
Supersedes: unzip, Volume 19, Issues 96-101

This is unzip v4.2, a public distribution version of the Info-ZIP project's
portable generic Unix unzip utility.  This version of unzip has been ported 
to a wide array of Unix and other mainframes, minis, and micros (to include 
MSDOS, Atari ST (kinda), and Macintosh).  Although highly compatible with 
Phil Katz's PKZIP and PKUNZIP utilities of MSDOS fame, our objective has been 
one of portability and other-than-MSDOS functionality.

BEFORE YOU ASK:  UnZip and its companion Zip utility can be found on many
archive sites around the world.  The "archie" ftp database utility can be
used to find a site near you (if you don't know how to use it, DON'T ASK
US--check the Usenet groups news.newusers.questions or news.answers or some
such).  The "official" Info-ZIP ftp site is valeria.cs.ucla.edu in /pub.
The most heavily used US site is wuarchive.wustl.edu; Zip 1.0 can be found
in /packages/compression/zip-1.0-export.tar.Z, and UnZip will probably be
found in the same place.  Zip 1.0 is also at any comp.sources.misc archive
site (volume 23) and, due to an oversight, in comp.sources.unix archives,
too (most recent volume--24?).  Machine-specific archives and executables
for both Zip and UnZip may be stored at wuarchive in /mirrors/misc/unix,
/mirrors/misc/vaxvms, /mirrors/msdos/zip, etc.  See the bottom of Contents
for locations of the decryption routines for Zip and UnZip.  The interna-
tional sites listed there (and US mirrors thereof) will most likely have
the rest of the Zip and UnZip packages, as well.

See unzip.1 or unzip.man for usage.  (No, there isn't a manual, per se.
Dave Heiland is working on one, but it's a big job and he isn't done
yet.)  See the Makefile (or the system-specific archives) for details 
on how to compile for your system.  

If any changes are made to source, we'd appreciate them (context diff
files only, please), with explanation as appropriate.

All bug reports and patches should go to zip-bugs@cs.ucla.edu, and sug-
gestions for new features can be sent to info-zip@cs.ucla.edu (although
we don't promise to use all suggestions).  If it's something which is
manifestly useful, sending the required patches to zip-bugs directly is 
likely to produce a quicker response than asking us to do it.  Those 
directly responsible for updating the code are somewhat short on time 
these days.  If you're considering a port, however, please check in with 
Info-ZIP FIRST, since the code is constantly being updated behind the 
scenes.  We'll arrange to send you the latest source.  The alternative 
is the possibility that your hard work will be tucked away in a sub-
archive and pretty much ignored.

If you'd like to keep up to date with our UnZip (and companion Zip
utility) development, join the ranks of BETA testers, add your own
thoughts and contributions, etc., send your request to

	Info-ZIP-Request@cs.ucla.edu

and Rich Wales'll add you to the Info-ZIP newsletter mailing list.
--------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README AMIGA ATARI ATARI/README.src MAC MSDOS MSDOS/bcc
#   MSDOS/tcc OS2 VMS VMS/bilf VMS/crypt ship.c
# Wrapped by kent@sparky on Mon Mar 30 01:45:50 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 12)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(6487 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XFile README for:
X
Xunzip42.zip	generic Unix/VMS/OS2/MSDOS/Mac/Amiga/Atari UnZip v4.2
Xunzip42.zoo	same as above, but ZOO format
Xunzip42.arc	same as above, but ARC format
Xunzip42.tar.Z	same as above, but compressed tar format
X
XA public distribution version of the Info-ZIP project's generic UnZip
Xutility; 20 March 1992.
X__________________________________________________________________________
X
XBEFORE YOU ASK:  UnZip and its companion Zip utility can be found on many
Xarchive sites around the world.  The "archie" ftp database utility can be
Xused to find a site near you (if you don't know how to use it, DON'T ASK
XUS--check the Usenet groups news.newusers.questions or news.answers or some
Xsuch).  The "official" Info-ZIP ftp site is valeria.cs.ucla.edu in /pub.
XThe most heavily used US site is wuarchive.wustl.edu; Zip 1.0 can be found
Xin /packages/compression/zip-1.0-export.tar.Z, and UnZip will probably be
Xfound in the same place.  Zip 1.0 is also at any comp.sources.misc archive
Xsite (volume 23) and, due to an oversight, in comp.sources.unix archives,
Xtoo (most recent volume--24?).  Machine-specific archives and executables
Xfor both Zip and UnZip may be stored at wuarchive in /mirrors/misc/unix,
X/mirrors/misc/vaxvms, /mirrors/msdos/zip, etc.  See the bottom of Contents
Xfor locations of the decryption routines for Zip and UnZip.  The interna-
Xtional sites listed there (and US mirrors thereof) will most likely have
Xthe rest of the Zip and UnZip packages, as well.
X__________________________________________________________________________
X
X
XThis version of UnZip has been ported to a wide array of Unix and other
Xmainframes, minis, and micros (including VMS, OS/2, Minix, MSDOS, Amiga,
XAtari ST (kinda), and Macintosh).  Although highly compatible with Phil
XKatz's PKZIP and PKUNZIP utilities of MSDOS fame, our objective has been
Xone of portability and other-than-MSDOS functionality.  Features not found
Xin the PKWare version include default extraction of directory trees (with
Xa switch to defeat this, rather than the other way around); HPFS awareness
Xfor the OS/2 version; and, of course, the ability to run on most of your
Xfavorite operating systems.
X
XNew features in this version are detailed in the History file, but a
Xcouple of them are worth comment.  Decryption (to accompany Zip 1.0's 
Xencryption) is now supported (you still have to ftp the crypt.c source
Xseparately, but that's explained in the Contents file).  It is a recent
Xaddition, however, and there may be some rough edges in the compilation.
XIf it fails, try adding (or removing) -DTERMIO to the compiler command.
X(This is especially likely on System V machines--the error messages will
Xsay things about sgtty being undefined in file_io.c.)  Once you get it
Xto compile, everything should work well; it's only the compilation itself
Xwhich may be a problem.  (The one known exception is for Crays; there is
Xa bug in crypt.c 1.0.  A small patch [cray.dif] is included with UnZip
X4.2.  The patch is unnecessary for later versions of crypt.c.)  Decryption
Xis optional, of course, and there should be virtually no problems compil-
Xing the export (non-decryption) version of UnZip.
X
XShip is also now included with the UnZip distribution.  It first appeared
Xwith Zip 1.0 and is the preferred method for mailing binaries to and from
XInfo-ZIP.  As it was added at the last minute, however, there are only
Xmakefile targets in the main Makefile (for regular Unix, SysV, OS/2 and
XMS-DOS).  Most people will already have Ship compiled with the Zip dis-
Xtribution, so this shouldn't be a big problem.  Ship is likely to disap-
Xpear again in the next release (it should be separately distributed by
Xthen).
X
XThe new compression method in PKZIP 1.93a (deflation) is NOT supported
Xyet and won't be until PKZIP 2.0 (or whatever) is officially released.
XPKZ193A.EXE is a beta version of the software, and its compression format
Xmay change before the official release.  We'll be ready when it does come 
Xout, however.... :-)
X
XSee unzip.1 or unzip.man for usage.  (No, there isn't a manual, per se.
XDave Heiland is working on one, but it's a big job and he isn't done
Xyet.)  See Contents for an explanation of everything in the distribution,
Xand BUGS for a list of what still doesn't work.  The History file lists
Xwhat *did* get fixed and added this time; CONTRIBS lists who did it (not
Xcomplete, but we're trying); and COPYING contains information on commer-
Xcial usage, licensing, etc.  Basically such usage is prohibited at present,
Xbut we're working on lifting that restriction.  So don't bug us unless you
Xhave (legally) rewritten some or all of the code in question (check with
Xus first, however, since we're also working on that as time permits).
X
XSee the Makefile (or the system-specific archives) for details on how to
Xcompile for your system.  If you confirm a clean compile and execution
Xon a unique system (i.e., one different from those in the makefiles), 
Xplease provide Info-ZIP via e-mail with details as to your system type, 
Xany changes required, what Makefile system was used, etc.
X
XIf any changes are made to source, we'd appreciate them (context diff
Xfiles only, please), with explanation as appropriate.
X
XAll bug reports and patches should go to zip-bugs@cs.ucla.edu, and sug-
Xgestions for new features can be sent to info-zip@cs.ucla.edu (although
Xwe don't promise to use all suggestions).  If it's something which is
Xmanifestly useful, sending the required patches to zip-bugs directly is 
Xlikely to produce a quicker response than asking us to do it.  Those 
Xdirectly responsible for updating the code are somewhat short on time 
Xthese days.  If you're considering a port, however, please check in with 
XInfo-ZIP FIRST, since the code is constantly being updated behind the 
Xscenes.  We'll arrange to send you the latest source.  The alternative 
Xis the possibility that your hard work will be tucked away in a sub-
Xarchive and pretty much ignored.
X
XPlease don't send e-mail to me (I'm only the Coordinator), unless
Xyou're requesting something special (e.g., a copy of the "No Feelthy ..."
Xrules for source and change submission).
X
XIf you'd like to keep up to date with our UnZip (and companion Zip
Xutility) development, join the ranks of BETA testers, add your own
Xthoughts and contributions, etc., send your request to
X
X	Info-ZIP-Request@cs.ucla.edu
X
Xand Rich Wales'll add you to the Info-ZIP newsletter mailing list.
X
XDavid Kirschbaum
XInfo-ZIP Coordinator
X
X(with some additions by Cavum Newtus)
END_OF_FILE
  if test 6487 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test ! -d 'AMIGA' ; then
    echo shar: Creating directory \"'AMIGA'\"
    mkdir 'AMIGA'
fi
if test ! -d 'ATARI' ; then
    echo shar: Creating directory \"'ATARI'\"
    mkdir 'ATARI'
fi
if test -f 'ATARI/README.src' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ATARI/README.src'\"
else
  echo shar: Extracting \"'ATARI/README.src'\" \(2944 characters\)
  sed "s/^X//" >'ATARI/README.src' <<'END_OF_FILE'
XUNZIP 4.1 source code for the Atari ST
X======================================
X
XThe source code for UNZIP 4.1 (or later) is available through
Xanonymous ftp from:
X
X	simtel20.army.mil	misc/unix/unzip41.*
Xor	wuarchive.wustl.edu	mirrors/misc/unix/unzip41.*
X
XI have compiled unzip.prg with TURBO C 2.0 for the ATARI ST, probably
Xthe best C compiler available for the Atari ST.
X
XMy modifications to unzip:
X
X1) ATARIST.PAT
X	- an alignment problem in the data (unzip.c)
X
X	- set '\' as the path character for the Atari ST (mapname.c)
X
X	- additions to unzip.h so that Turbo C for the Atari ST is  happy.
X	  I think I didn't break anythig else, at least the Sun's version
X	  compiles just as before.
X	  I commented massively in unzip.h because the configuration
X          is not well thought out.  The last time I generated the ST
X          version I threw out all the mess, the result of which was that
X          my version wasn't distributed.  I hope that will fit in better
X          this time.  If anybody cares about the comments, just clean up
X          the code (together with comments).
X
X2) OPTIMIZE.PAT
X	This patch is general and not related to the Atari ST.
X	It speeds up the processing by as much as 30% by
X	eliminating many function calls, optimizing some
X	macros and using a ULONG bitbuffer.  The claimed
X	performance gain is on a Sun, using unzip -t some-file.
X	I didn't measure the speed on the Atari ST.
X
X3) SYMLINK.PAT
X	This applies to unix systems only.  Unzip does extract
X	symbolic links correctly now.
X
X4) UNIXBLAN.PAT
X	On Unix systems, file names may contain blanks.
X	If they do, why not allow them to be restored exactly?
X	For all other systems still change the blanks to '_'.
X
XDue to historic reasons the order these patches were applied is
X 3 - 4 - 1 - 2.  However they do not overlap and can therefore be
Xapplied independently.
X
XI am providing UNZIP.PRG for the Atari ST as UNZIP41.ARC
Xfor those who don't have any unzipper yet.
X
XSpecial features:
X=================
X
X Unzip.prg uses a special version of the startup file which is capable
X of recognizing extended parameters a la Beckemeyer/Mark Williams shell,
X using the "ARGV=" Environment variable.
X
X Although the Turbo C compiler is quite good, the libs are buggy!
X Therefore I cannot garantee that any unzip.prg compiled with Turbo C
X will ever run successfully. Mine seems to be ok., but I have fixed
X various problems for my lib. Especially the stat() was making trouble.
X
XHowever, if someone wants to compile it the same way I did,
Xthere are essentially 3 ways:
X- using a shell, and the command line compiler TCC,
X  as indicated by the script 'MAKEIT',
X
X- using some sort of make and 'MAKEFILE.ST'
X  This and the previous case both require also 'TLINK.OPT'
X
X- using the interactive version 'TC' of Turbo C and
X  the supplied 'UNZIP.PRJ'.
X
XPlease read the note above about problems which might arise
Xwhen you recompile unzip on your Atari.
X
X					martin@atlantic.cs.unb.ca
X
END_OF_FILE
  if test 2944 -ne `wc -c <'ATARI/README.src'`; then
    echo shar: \"'ATARI/README.src'\" unpacked with wrong size!
  fi
  # end of 'ATARI/README.src'
fi
if test ! -d 'MAC' ; then
    echo shar: Creating directory \"'MAC'\"
    mkdir 'MAC'
fi
if test ! -d 'MSDOS' ; then
    echo shar: Creating directory \"'MSDOS'\"
    mkdir 'MSDOS'
fi
if test ! -d 'MSDOS/bcc' ; then
    echo shar: Creating directory \"'MSDOS/bcc'\"
    mkdir 'MSDOS/bcc'
fi
if test ! -d 'MSDOS/tcc' ; then
    echo shar: Creating directory \"'MSDOS/tcc'\"
    mkdir 'MSDOS/tcc'
fi
if test ! -d 'OS2' ; then
    echo shar: Creating directory \"'OS2'\"
    mkdir 'OS2'
fi
if test ! -d 'VMS' ; then
    echo shar: Creating directory \"'VMS'\"
    mkdir 'VMS'
fi
if test ! -d 'VMS/bilf' ; then
    echo shar: Creating directory \"'VMS/bilf'\"
    mkdir 'VMS/bilf'
fi
if test ! -d 'VMS/crypt' ; then
    echo shar: Creating directory \"'VMS/crypt'\"
    mkdir 'VMS/crypt'
fi
if test -f 'ship.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ship.c'\"
else
  echo shar: Extracting \"'ship.c'\" \(38513 characters\)
  sed "s/^X//" >'ship.c' <<'END_OF_FILE'
X/* ship.c -- Not copyrighted 1991 Mark Adler */
X
X#define SHIPVER "ship version 1.1  November 4, 1991  Mark Adler"
X
X/* Command for mailing (-m): the %s's are, in order, the subject prefix,
X   the part number (always of the form "partnnnn"), the subject suffix
X   (empty or " (last)" if the last part), the mailing address, and the
X   name of the temporary file begin mailed.  The command "Mail" is for BSD
X   systems.  You may need to change it to "mailx" for System V Unix, using
X   the compile option "-DMAILX".  Also, on Sperry (Unisys?) SysV.3 systems,
X   you might try the command name "v6mail". */
X
X#ifdef DIRENT           /* If compiled with zip, DIRENT implies System V */
X#  define MAILX
X#endif /* DIRENT */
X
X#ifdef sun              /* Except Sun's use DIRENT, but have Mail */
X#  ifdef MAILX
X#    undef MAILX
X#  endif /* MAILX */
X#endif /* sun */
X
X#ifdef sgi              /* Silicon Graphics that way too */
X#  ifdef MAILX
X#    undef MAILX
X#  endif /* MAILX */
X#endif /* sgi */
X
X#ifdef VMS
X#  define TMPNAME "_SXXXXXX."
X#  define MAILCMD "mail %s /subj=\"%s %s%s\" \"%s\""
X#  define PATHCUT ']'
X#else /* !VMS */
X#  define TMPNAME "_SXXXXXX"
X#  ifdef MAILX
X#    define MAILCMD "mailx -s \"%s %s%s\" \"%s\" < %s"
X#  else /* !MAILX */
X#    ifdef M_XENIX
X#      define MAILCMD "mail -s \"%s %s%s\" \"%s\" < %s"
X#    else /* !M_XENIX */
X#      define MAILCMD "Mail -s \"%s %s%s\" \"%s\" < %s"
X#    endif /* ?M_XENIX */
X#  endif /* ?MAILX */
X#  ifdef MSDOS
X#    define PATHCUT '\\'
X#  else /* !MSDOS */
X#    define PATHCUT '/'
X#  endif /* ?MSDOS */
X#endif /* ?VMS */
X
X/*
X
XSHIP -
X
X  Ship is a program for sending binary files through email.  It is designed
X  to supplant uuencode and uudecode.  Ship encodes approximately 6.32 bits
X  per character mailed, compared to uuencode's 5.81 bits per character.
X
X  Ship also has these features: a 32-bit CRC check on each file; automatic
X  splitting of the ship output into multiple, smaller files for speedier
X  mailing; automatic mailing of ship's output, with subject lines for
X  multiple parts; and a check on the sequence of parts when unshipping.
X
X  Usage:
X
X       ship [-nnn] [-m address] [-s subject] file ...
X
X  where nnn is the maximum number of K bytes for each output file, address
X  is the address to send mail to, subject is a Subject" line prefix, and
X  file ... is a list of files to ship.  If no options are given, ship
X  outputs to stdout.  The simplest use is:
X
X       ship foo > x
X
X  where foo is converted into the mailable file, x.
X
X  When -nnn is specified, but -m is not, ship writes to the files
X  part0001, part0002, etc., where each file has nnn or less K bytes.  For
X  example:
X
X       ship -25 bigfoo
X
X  will write however many 25K byte or less ship files is needed to contain
X  bigfoo.  If, say, six files are needed, then the files part0001 to part0006
X  will be written.
X
X  When using -m, nothing is written, either to files or to stdout; rather,
X  the output is mailed to the specified address.  If -nnn is also specified,
X  then the parts are mailed separately with the subject lines part0001, etc.
X  If -nnn is not specified, then only one part (the whole thing) is mailed
X  with the subject line "part0001".  For example:
X
X       ship -25 -m fred bigfoo
X
X  will mail the six parts of bigfoo to fred.
X
X  Any number of files can be shipped at once.  They become part of one long
X  ship stream, so if, for example -25 is specified, all but the last part
X  will have about 25K bytes.  For example:
X
X       ship -25 -m fred fee fi fo fum
X
X  will send the files fee, fi, fo, and fum to fred.
X
X  Fred will get several mail messages with the subject lines part0001, etc.
X  He can then save those messages as the files, say, p1, p2, p3, ...
X  Then he can use the command:
X
X       ship -u p?
X
X  to recreate bigfoo, or fee fi fo and fum, depending on what he was sent.
X  If Fred saved the wrong numbers, ship will detect this and report a
X  sequence error.
X
X  Note: there is enough information in the shipped parts to determine the
X  correct sequence.  A future version of ship will prescan the files to
X  determine the sequence, and then process them in the correct order.
X
X  If a file being received already exists, ship -u will report an error
X  and exit.  The -o option avoids this and allows ship to overwrite existing
X  files.  The -o option must follow the -u option:
X
X       ship -u -o p?
X
X  In addition to the -u option, ship will unship if it sees that its name is
X  unship.  On Unix systems, this can be done simply by linking the executable
X  to unship:
X
X       ln ship unship 
X
X  Ship can also be used as a filter.  The special file name "-" means stdin.
X  For example:
X
X       tar covf - foodir | compress | ship -25 -m fred -
X
X  will tar the directory foodir, compress it, and ship it to fred in 25K byte
X  pieces.  Then, after Fred saves the files as p01, etc. at the other, end,
X  he can:
X
X       ship -u p? | zcat | tar xovf -
X
X  which will recreate the directory foobar and its contents.  ship -u knows
X  to write to stdout, since the original ship put the special file name "-"
X  in the first part.
X
X  Ship uses a base 85 coding that needs 32-bit multiplication and division.
X  This can be slow on 16-bit machines, so ship provides a fast encoding
X  method by specifying the -f option.  This method is somewhat faster even
X  on 32-bit machines, and has approximately a 1% penalty in the size of the
X  encoded result (-f gives 6.26 bits per character, on the average).  The -f
X  option need only be used when shipping--unshipping (ship -u) automatically
X  detects the encoding used.  For example:
X
X       ship -f -25 -m fred foo
X
X  will send foo to fred in 25K byte pieces using the fast encoding method.
X  You don't need to tell Fred, since ship -u will figure that out for him.
X
X  The fast encoding method is probabilistic, so it's possible for the size
X  penalty to be worse than 1%, and it's also possible for the fast encoding
X  to produce a smaller result than base 85 encoding would, all depending on
X  the data.
X
X  The -q option can be used with either ship or unship (ship -u) for quiet
X  operation--informational messages are inhibited.
X
X  You can find out the version of ship and get the command usage by using
X  "ship -h" or "ship -?".  The version number and date and help will be
X  printed, and ship will exit (the rest of the command line is ignored).
X
X  Acknowledgements:
X
X  The hard-arithmetic coding algorithm was blatantly stolen from Peter
X  Gutmann's pgencode/pgdecode programs posted on comp.compression, with
X  modifications to use 86 instead of 94 characters, and to make zeros encode
X  better than, rather than worse than other bytes.  (As Stravinsky once said:
X  "Mediocre composers plagiarize.  Great composers steal.")
X
X*/
X
X/* tailor.h -- Not copyrighted 1991 Mark Adler */
X
X/* const's are inconsistently used across ANSI libraries--kill for all
X   header files. */
X#define const
X
X
X/* Use prototypes and ANSI libraries if __STDC__ */
X#ifdef __STDC__
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* __STDC__ */
X
X
X/* Use prototypes and ANSI libraries if Silicon Graphics */
X#ifdef sgi
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* sgi */
X
X
X/* Define MSDOS for Turbo C as well as Microsoft C */
X#ifdef __POWERC                 /* For Power C too */
X#  define __TURBOC__
X#endif /* __POWERC */
X#ifdef __TURBOC__
X#  ifndef MSDOS
X#    define MSDOS
X#  endif /* !MSDOS */
X#endif /* __TURBOC__ */
X
X
X/* Use prototypes and ANSI libraries if Microsoft or Borland C */
X#ifdef MSDOS
X#  ifndef PROTO
X#    define PROTO
X#  endif /* !PROTO */
X#  define MODERN
X#endif /* MSDOS */
X
X
X/* Turn off prototypes if requested */
X#ifdef NOPROTO
X#  ifdef PROTO
X#    undef PROTO
X#  endif /* PROTO */
X#endif /* NOPROT */
X
X
X/* Used to remove arguments in function prototypes for non-ANSI C */
X#ifdef PROTO
X#  define OF(a) a
X#else /* !PROTO */
X#  define OF(a) ()
X#endif /* ?PROTO */
X
X
X/* Allow far and huge allocation for small model (Microsoft C or Turbo C) */
X#ifdef MSDOS
X#  ifdef __TURBOC__
X#    include <alloc.h>
X#  else /* !__TURBOC__ */
X#    include <malloc.h>
X#    define farmalloc _fmalloc
X#    define farfree   _ffree
X#  endif /* ?__TURBOC__ */
X#else /* !MSDOS */
X#  define huge
X#  define far
X#  define near
X#  define farmalloc malloc
X#  define farfree   free
X#endif /* ?MSDOS */
X
X
X/* Define MSVMS if either MSDOS or VMS defined */
X#ifdef MSDOS
X#  define MSVMS
X#else /* !MSDOS */
X#  ifdef VMS
X#    define MSVMS
X#  endif /* VMS */
X#endif /* ?MSDOS */
X
X
X/* Define void, voidp, and extent (size_t) */
X#include <stdio.h>
X#ifdef MODERN
X#  if !defined(M_XENIX) && !(defined(__GNUC__) && defined(sun))
X#    include <stddef.h>
X#  endif
X#  include <stdlib.h>
X   typedef size_t extent;
X   typedef void voidp;
X#else /* !MODERN */
X   typedef unsigned int extent;
X#  define void int
X   typedef char voidp;
X#endif /* ?MODERN */
X
X/* Get types and stat */
X#ifdef VMS
X#  include <types.h>
X#  include <stat.h>
X#else /* !VMS */
X#  include <sys/types.h>
X#  include <sys/stat.h>
X#endif /* ?VMS */
X
X
X/* Cheap fix for unlink on VMS */
X#ifdef VMS
X#  define unlink delete
X#endif /* VMS */
X
X
X/* For Pyramid */
X#ifdef pyr
X#  define strrchr rindex
X#  define ZMEM
X#endif /* pyr */
X
X
X/* File operations--use "b" for binary if allowed */
X#ifdef MODERN
X#  define FOPR "rb"
X#  define FOPM "r+b"
X#  define FOPW "w+b"
X#else /* !MODERN */
X#  define FOPR "r"
X#  define FOPM "r+"
X#  define FOPW "w+"
X#endif /* ?MODERN */
X
X
X/* Fine tuning */
X#ifndef MSDOS
X#   define BSZ 8192   /* Buffer size for files */
X#else /* !MSDOS */
X#   define BSZ 4096   /* Keep precious NEAR space */
X    /* BSZ can't be 8192 even for compact model because of 64K limitation
X     * in im_lmat.c. If you run out of memory when processing a large number
X     * files, use the compact model and reduce BSZ to 2048 here and in
X     * im_lm.asm.
X     */
X#endif /* ?MSDOS */
X
X/* end of tailor.h */
X
X#ifdef MODERN
X#  include <string.h>
X#else /* !MODERN */
X   voidp *malloc();
X   long atol();
X   char *strcpy();
X   char *strrchr();
X#endif /* ?MODERN */
X
X/* Library functions not in (most) header files */
Xchar *mktemp OF((char *));
Xint unlink OF((char *));
X
X#ifdef MSDOS            /* Use binary mode for binary files */
X#  include <io.h>
X#  include <fcntl.h>
X#endif /* MSDOS */
X
X
X#define LNSZ 1025       /* size of line buffer */
X
Xtypedef unsigned long ulg;      /* 32-bit unsigned integer */
X
Xtypedef struct {        /* associates a CRC with a file */
X  FILE *f;              /* pointer to associated file stream */
X  ulg c;                /* CRC register */
X  ulg b;                /* four byte buffer */
X  int n;                /* buffer count */
X} cfile;
X
X
X/* Function prototypes */
X#ifdef MODERN
X   void err(int, char *);
X   cfile *chook(FILE *);
X   char *nopath(char *);
X   void newship(void);
X   void endship(int);
X   void newline(char *);
X   void ship(char *, FILE *);
X   void mkinv(void);
X   void decode(unsigned char *, cfile *);
X   void unship(char **, int, int);
X   void help(void);
X   void main(int, char **);
X#endif /* MODERN */
X
X
X
X/* Globals for ship() */
Xchar sname[9];          /* current ship file name */
XFILE *sfile;            /* current ship file */
Xulg slns;               /* number of lines written to ship file */
Xulg slmax;              /* maximum number of lines per ship file */
Xint fast;               /* true for arithmetic coding, else base 85 */
Xint mail;               /* true if mailing */
Xchar mpspc[9];          /* prealloced space for prefix */
Xchar *mprefix = mpspc;  /* identification for this mailing */
Xchar *mdest;            /* mail destination */
Xchar mname[10];         /* temporary file name if mailing */
Xulg ccnt;               /* count of bytes read or written */
Xint noisy = 1;          /* false to inhibit informational messages */
X
X
X
X/* Errors */
X#define SE_ARG 1
X#define SE_FIND 2
X#define SE_NONE 3
X#define SE_PART 4
X#define SE_FORM 5
X#define SE_CONT 6
X#define SE_CRC 7
X#define SE_MAIL 8
X#define SE_OVER 9
X#define SE_FULL 10
X#define SE_MANY 11
X#define SE_MEM 12
Xchar *errors[] = {
X  /* 1 */ "invalid argument ",
X  /* 2 */ "could not find ",
X  /* 3 */ "no files received",
X  /* 4 */ "unfinished file ",
X  /* 5 */ "invalid ship format in ",
X  /* 6 */ "wrong sequence for ",
X  /* 7 */ "CRC check failed on ",
X  /* 8 */ "mail command failed: ",
X  /* 9 */ "attempted to overwrite ",
X  /* 10 */ "could not write to ",
X  /* 11 */ "too many output files!",
X  /* 12 */ "out of memory"
X};
X
X
X/* Set of 86 characters used for the base 85 digits (last one not used), and
X   the 86 character arithmetic coding.  Selected to be part of both the ASCII
X   printable characters, and the common EBCDIC printable characters whose
X   ASCII translations are universal. */
Xunsigned char safe[] = {
X        '{','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',
X        '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?','@',
X        'A','B','C','D','E','F','G','H','I','J','K','L','M',
X        'N','O','P','Q','R','S','T','U','V','W','X','Y','Z','_',
X        'a','b','c','d','e','f','g','h','i','j','k','l','m',
X        'n','o','p','q','r','s','t','u','v','w','x','y','z','}'};
X
X#define LOWSZ (sizeof(safe)-64)         /* low set size for fast coding */
X
X/* Special replacement pairs--if first of each pair is received, it is
X   treated like the second member of the pair.  You're probably
X   wondering why.  The first pair is for compatibility with an
X   earlier version of ship that used ! for the base 85 zero digit.
X   However, there exist ASCII-EBCDIC translation tables that don't
X   know about exclamation marks.  The second set has mysterious
X   historical origins that are best left unspoken ... */
Xunsigned char aliases[] = {'!','{','|','+',0};
X
X/* Inverse of safe[], filled in by mkinv() */
Xunsigned char invsafe[256];
X
X/* Table of CRC-32's of all single byte values (made by makecrc.c) */
Xulg crctab[] = {
X  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
X  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
X  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
X  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
X  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
X  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
X  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
X  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
X  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
X  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
X  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
X  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
X  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
X  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
X  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
X  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
X  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
X  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
X  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
X  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
X  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
X  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
X  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
X  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
X  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
X  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
X  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
X  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
X  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
X  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
X  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
X  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
X  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
X  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
X  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
X  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
X  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
X  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
X  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
X  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
X  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
X  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
X  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
X  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
X  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
X  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
X  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
X  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
X  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
X  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
X  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
X  0x2d02ef8dL
X};
X
X/* Macro to update the CRC shift register one byte at a time */
X#define CRC(c,b) (crctab[((int)(c)^(int)(b))&0xff]^((c)>>8))
X
X
Xchar *errname = "ship error";
Xchar *warname = "ship warning";
X
Xvoid err(n, m)
Xint n;                  /* error number */
Xchar *m;                /* additional error information */
X{
X  if (n == SE_FIND || n == SE_FULL)
X    perror(errname);
X  fputs(errname, stderr);
X  fputs(": ", stderr);
X  fputs(errors[n - 1], stderr);
X  fputs(m, stderr);
X  putc('\n', stderr);
X  if (*mname)
X    unlink(mname);
X#ifdef VMS
X  exit(0);
X#else /* !VMS */
X  exit(n);
X#endif /* ?VMS */
X}
X
X
Xcfile *chook(f)
XFILE *f;                /* file stream */
X/* Inherit the file stream structure and add a CRC and buffer for appending
X   a CRC on reads and checking the CRC on writes.  Return a pointer to the
X   cfile structure, or NULL if the malloc() failed.  Also, if MSDOS, set the
X   file mode to binary to avoid LF<->CRLF conversions. */
X{
X  cfile *c;             /* allocated cfile structure */
X
X#ifdef MSDOS
X  /* Set file mode to binary for MSDOS systems */
X  setmode(fileno(f), O_BINARY);
X#endif /* MSDOS */
X
X  /* Allocate and fill structure */
X  if ((c = (cfile *)malloc(sizeof(cfile))) != NULL)
X  {
X    c->f = f;                           /* file stream */
X    c->b = 0;                           /* empty fifo (for output) */
X    c->c = 0xffffffffL;                 /* preload CRC register */
X    c->n = 0;                           /* fifo is empty (output) or */
X  }                                     /*  no CRC bytes given (input) */
X  return c;
X}
X
X
X
X/* cgetc(x)--like getc(f), but appends a 32-bit CRC to the end of the stream.
X   Return the byte read (the last four of which will be the CRC) or EOF. */
X#define cgete(x) (x->n==4?EOF:(x->c=x->n++?x->c>>8:~x->c,(int)x->c&0xff))
X#define cgetc(x) (x->n==0&&(b=getc(x->f))!=EOF?(ccnt++,x->c=CRC(x->c,b),b):cgete(c))
X
X
X/* cputc(d,x)--like putc(d,f), but delays four bytes and computes a CRC.
X   x is a cfile *, and d is expected to be an ulg. */
X#define cputf(x) (int)(x->c=CRC(x->c,x->b),putc((int)x->b&0xff,x->f),ccnt++)
X#define cputc(d,x) (x->n!=4?x->n++:cputf(x),x->b=(x->b>>8)+((ulg)(d)<<24))
X
X
Xchar *nopath(p)
Xchar *p;                /* full file name */
X/* Extract just the name of file--remove and subdirectories or devices */
X{
X#ifdef MSDOS
X  char *q = "/\\:";     /* MSDOS delimiters */
X#else /* !MSDOS */
X#ifdef VMS
X  char *q = "]:";       /* VMS delimiters */
X#else /* !VMS */
X  char *q = "/";        /* Unix delimiter */
X#endif /* ?VMS */
X#endif /* ?MSDOS */
X  char *r;              /* result of strrchr() */
X
X  while (*q)
X    if ((r = strrchr(p, *q++)) != NULL)
X      p = r + 1;
X  return p;
X}
X
X
Xvoid newship()
X/* Open up a new ship file to write to */
X{
X  int i;                /* scans down name to increment */
X
X  for (i = 7; i > 3; i--)
X    if (++sname[i] > '9')
X      sname[i] = '0';
X    else
X      break;
X  if (i == 3)
X    err(SE_MANY, "");
X  if ((sfile = fopen(mail ? mktemp(strcpy(mname, TMPNAME)) : sname,
X                     "w")) == NULL)
X    err(SE_FULL, mail ? mname : sname);
X  slns = 0;
X}
X
X
Xvoid endship(e)
Xint e;          /* true if ending the last ship file */
X/* Finish off current ship file */
X{
X  char *s;              /* malloc'd space for mail command */
X
X  if (ferror(sfile) || fclose(sfile))
X    err(SE_FULL, mail ? mname : sname);
X  if (mail)
X  {
X    if ((s = malloc(strlen(MAILCMD)- 5*2 + strlen(mprefix) + strlen(sname) +
X                    (e ? 7 : 0) + strlen(mdest) + strlen(mname) + 1)) == NULL)
X      err(SE_MEM, "");
X#ifdef VMS
X    sprintf(s, MAILCMD, mname, mprefix, sname, e ? " (last)" : "", mdest);
X    if (!system(s))             /* this string fits on one line */
X      err(SE_MAIL, "system() call is not supported on this machine");
X#else /* !VMS */
X    sprintf(s, MAILCMD, mprefix, sname, e ? " (last)" : "", mdest, mname);
X    if (system(s))
X      err(SE_MAIL, s);
X#endif /* ?VMS */
X    free((voidp *)s);
X    unlink(mname);
X    *mname = 0;
X  }
X}
X
X
Xvoid newline(p)
Xchar *p;                /* name of the input file */
X/* Add a new line inside a ship file, possibly cut the file */
X{
X  putc('\n', sfile);
X  slns++;
X  if (slmax && slns >= slmax - 2)
X  {
X    putc('$', sfile);
X    if (fast)
X      fputs(" f", sfile);
X    fputs("\nmore\n", sfile);
X    endship(0);
X    newship();
X    fprintf(sfile, "$%s\ncont %lu %s\n", fast ? " f" : "", ccnt, nopath(p));
X    slns += 2;
X  }
X}
X
X
X/* Macro to avoid leading dots.  It assumes i==0 at the beginning of a line
X   and that b is an available int.  c is only evaluated once. */
X#define sputc(c,f) (i==0?((b=(c))=='.'?putc(' ',f):0,putc(b,f)):putc(c,f))
X
X
Xvoid ship(p, f)
Xchar *p;                /* name of the input file */
XFILE *f;                /* input file */
X/* Encode the binary file f. */
X{
X  int b;                /* character just read */
X  cfile *c;             /* checked file stream */
X  int i;                /* how much is written on line so far */
X  int j;                /* how much is in bit buffer */
X
X  /* Set up output file if needed */
X  if ((mail || slmax) && sfile == stdout)
X  {
X    strcpy(sname, "part0000");
X    newship();
X  }
X
X  /* Write header */
X  if ((c = chook(f)) == NULL)
X    err(SE_MEM, "");
X  ccnt = 0;
X  if (slmax && slns >= slmax - 5) 
X  {
X    endship(0);
X    newship();
X  }
X  fprintf(sfile, "$%s\nship %s\n", fast ? " f" : "", nopath(p));
X  slns += 2;
X
X  /* Encode the file, writing to sfile */
X  if (fast)
X  {
X    int d;              /* accumulates bits (never more than 14) */
X
X    d = j = i = 0;
X    while ((b = cgetc(c)) != EOF)
X    {
X      d |= b << j;
X      j += 8;
X      if ((d & 0x3f) >= LOWSZ)
X      {
X        sputc((int)(safe[(d & 0x3f) + LOWSZ]), sfile);
X        d >>= 6;
X        j -= 6;
X      }
X      else
X      {
X        sputc((int)(safe[(d & 0x3f) + (d & 0x40 ? LOWSZ : 0)]), sfile);
X        d >>= 7;
X        j -= 7;
X      }
X      if (++i == 79)
X      {
X        newline(p);
X        i = 0;
X      }
X      if (j >= 6 && (d & 0x3f) >= LOWSZ)
X      {
X        sputc((int)(safe[(d & 0x3f) + LOWSZ]), sfile);
X        d >>= 6;
X        j -= 6;
X        if (++i == 79)
X        {
X          newline(p);
X          i = 0;
X        }
X      }
X      else if (j >= 7)
X      {
X        sputc((int)(safe[(d & 0x3f) + (d & 0x40 ? LOWSZ : 0)]), sfile);
X        d >>= 7;
X        j -= 7;
X        if (++i == 79)
X        {
X          newline(p);
X          i = 0;
X        }
X      }
X    }
X    free((voidp *)c);
X
X    /* Write leftover bits */
X    if (j)
X    {
X      sputc((int)(safe[d + (d < LOWSZ ? 0 : LOWSZ)]), sfile);
X      putc('\n', sfile);
X      slns++;
X    }
X    else if (i)
X    {
X      putc('\n', sfile);
X      slns++;
X    }
X  }
X  else
X  {
X    ulg d;              /* accumulates bytes */
X
X    d = j = i = 0;
X    while ((b = cgetc(c)) != EOF)
X    {
X      d += ((ulg)b) << j;
X      if ((j += 8) == 32)
X      {
X        sputc((int)(safe[(int)(d % 85)]), sfile);  d /= 85;
X        putc((int)(safe[(int)(d % 85)]), sfile);  d /= 85;
X        putc((int)(safe[(int)(d % 85)]), sfile);  d /= 85;
X        putc((int)(safe[(int)(d % 85)]), sfile);  d /= 85;
X        putc((int)(safe[(int)d]), sfile);
X        if (++i == 15)                  /* each line is <= 75 characters */
X        {
X          newline(p);
X          i = 0;
X        }
X        d = j = 0;
X      }
X    }
X    free((voidp *)c);
X  
X    /* Write leftover data */
X    if (j)
X    {
X      j >>= 3;
X      sputc((int)(safe[(int)(d % 85)]), sfile);
X      while (j--)
X      {
X        d /= 85;
X        putc((int)(safe[(int)(d % 85)]), sfile);
X      }
X      putc('\n', sfile);
X      slns++;
X    }
X    else if (i)
X    {
X      putc('\n', sfile);
X      slns++;
X    }
X  }
X  putc('$', sfile);
X  if (fast)
X    fputs(" f", sfile);
X  fputs("\nend\n", sfile);
X  slns += 2;
X  if (ferror(sfile) || fflush(sfile))
X    err(SE_FULL, mail ? mname : sname);
X  if (noisy)
X    fprintf(stderr, "%s shipped\n", p);
X}
X
X
Xvoid mkinv()
X/* Build invsafe[], the inverse of safe[]. */
X{
X  int i;
X
X  for (i = 0; i < 256; i++)
X    invsafe[i] = 127;
X  for (i = 0; i < sizeof(safe); i++)
X    invsafe[safe[i]] = (char)i;
X  for (i = 0; aliases[i]; i += 2)
X    invsafe[aliases[i]] = invsafe[aliases[i + 1]];
X}
X
X
Xunsigned int decb;      /* bit buffer for decode */
Xunsigned int decn;      /* number of bits in decb */
X
Xvoid decode(s, c)
Xunsigned char *s;       /* data to decode */
Xcfile *c;               /* binary output file */
X/* Decode s, a string of base 85 digits or, if fast is true, a string of safe
X   characters generated arithmetically, into its binary equivalent, writing
X   the result to c, using cputc(). */
X{
X  int b;                /* state of line loop, next character */
X  int k;                /* counts bits or digits read */
X  /* powers of 85 table for decoding */
X  static ulg m[] = {1L,85L,85L*85L,85L*85L*85L,85L*85L*85L*85L};
X
X  if (fast)
X  {
X    unsigned int d;     /* disperses bits */
X
X    d = decb;
X    k = decn;
X    while ((b = *s++) != 0)
X      if ((b = invsafe[b]) < sizeof(safe))
X      {
X        if (b < LOWSZ)
X        {
X          d |= b << k;
X          k += 7;
X        }
X        else if ((b -= LOWSZ) < LOWSZ)
X        {
X          d |= (b + 0x40) << k;
X          k += 7;
X        }
X        else
X        {
X          d |= b << k;
X          k += 6;
X        }
X        if (k >= 8)
X        {
X          cputc(d, c);
X          d >>= 8;
X          k -= 8;
X        }
X      }
X    decb = d;
X    decn = k;
X  }
X  else
X  {
X    ulg d;              /* disperses bytes */
X
X    d = k = 0;
X    while ((b = *s++) != 0)
X      if ((b = invsafe[b]) < 85)
X      {
X        d += m[k] * b;
X        if (++k == 5)
X        {
X          cputc(d, c);  d >>= 8;
X          cputc(d, c);  d >>= 8;
X          cputc(d, c);  d >>= 8;
X          cputc(d, c);
X          d = k = 0;
X        }
X      }
X    if (--k > 0)
X    {
X      while (--k)
X      {
X        cputc(d, c);
X        d >>= 8;
X      }
X      cputc(d, c);
X    }
X  }
X}
X
X
Xvoid unship(v, g, o)
Xchar **v;               /* arguments */
Xint g;                  /* number of arguments */
Xint o;                  /* overwrite flag */
X/* Extract from the files named in the arguments the files that were
X   encoded by ship.  If an argument is "-", then stdin is read. */
X{
X  int b;                /* state of line loop */
X  cfile *c;             /* output binary file */
X  FILE *f;              /* output file */
X  char *h;              /* name of current ship file */
X  char l[LNSZ];         /* line buffer on input */
X  int n;                /* next argument to use for input */
X  char *p;              /* modifies line buffer */
X  char *q;              /* scans continuation line */
X  char *r;              /* name of output binary file */
X  FILE *s;              /* current ship file */
X  int z;                /* true if zero files received */
X
X  /* Build inverse table */
X  mkinv();
X
X  /* No input or output files initially */
X  s = NULL;
X  c = NULL;
X  h = r = NULL;
X
X  /* Loop on input files' lines */
X  z = 1;                                /* none received yet */
X  n = 0;                                /* start with file zero */
X  b = 2;                                /* not in body yet */
X  while (1)                             /* return on end of last file */
X  {
X    /* Get next line from list of files */
X    while (s == NULL || fgets(l, LNSZ, s) == NULL)
X    {
X      if (s != NULL)
X        fclose(s);
X      if (n >= g)
X      {
X        if (c != NULL)
X          err(SE_PART, r);
X        else if (z)
X          err(SE_NONE, "");
X        return;
X      }
X      if (v[n][0] == '-')
X        if (v[n][1])
X          err(SE_ARG, v[n]);
X        else
X        {
X          h = "stream stdin";
X          s = stdin;
X        }
X      else
X      {
X        h = v[n];
X        if ((s = fopen(h, "r")) == NULL)
X          err(SE_FIND, h);
X      }
X      n++;
X      b &= ~1;                          /* not in middle of line */
X    }
X
X    /* Strip control characters and leading blank space, if any */
X    for (q = l; *q && *q <= ' ' && *q != '\n'; q++)
X      ;
X    for (p = l; *q; q++)
X      if (*q >= ' ' || *q == '\n')
X        *p++ = *q;
X    *p = 0;
X
X    /* Based on current state, end or start on terminator.  States are:
X         b == 0:  at start of body or body terminator line
X         b == 1:  in middle of body line
X         b == 2:  at start of non-body line
X         b == 3:  in middle of non-body line
X         b == 4:  at information line
X    */
X    switch (b)
X    {
X    case 0:
X      if ((!fast && strcmp(l, "$\n") == 0) ||
X          (fast && strcmp(l, "$ f\n") == 0))
X      {
X        b = 4;
X        break;
X      }
X      /* fall through to case 1 */
X    case 1:
X      decode((unsigned char *)l, c);
X      b = l[strlen(l) - 1] != '\n';
X      break;
X    case 2:
X      if (strcmp(l, "$\n") == 0 || strcmp(l, "$ f\n") == 0)
X      {
X        fast = l[1] == ' ';
X        b = 4;
X        break;
X      }
X      /* fall through to case 3 */
X    case 3:
X      b = l[strlen(l)-1] == '\n' ? 2 : 3;
X      break;
X    case 4:
X      /* Possible information lines are ship, more, cont, and end */
X      if (l[b = strlen(l) - 1] != '\n')
X        err(SE_FORM, h);
X      l[b] = 0;
X      if (strncmp(l, "ship ", 5) == 0)
X      {
X        /* get name, open new output file */
X        if (c != NULL)
X          err(SE_FORM, h);
X        if ((r = malloc(b - 4)) == NULL)
X          err(SE_MEM, "");
X        strcpy(r, l + 5);
X        if (strcmp(r, "-") == 0)
X          f = stdout;
X#ifndef VMS     /* shouldn't have explicit version #, so VMS won't overwrite */
X        else if (!o && (f = fopen(r, "r")) != NULL)
X        {
X          fclose(f);
X          err(SE_OVER, r);
X        }
X#endif /* !VMS */
X        else if ((f = fopen(r, "w")) == NULL)
X          err(SE_FULL, r);
X        if ((c = chook(f)) == NULL)
X          err(SE_MEM, "");
X        b = decb = decn = 0;
X        ccnt = 0;
X      }
X      else if (strcmp(l, "more") == 0)
X      {
X        /* check if currently writing */
X        if (c == NULL)
X          err(SE_FORM, h);
X        b = 2;
X      }
X      else if (strncmp(l, "cont ", 5) == 0)
X      {
X        /* check name and file offset */
X        if (c == NULL)
X          err(SE_FORM, h);
X        for (q = l + 5; *q && *q != ' '; q++)
X          ;
X        if (*q == 0 || atol(l + 5) != ccnt + 4 + (decn != 0) ||
X            strcmp(q + 1, r))
X          err(SE_CONT, r);
X        b = 0;
X      }
X      else if (strcmp(l, "end") == 0)
X      {
X        /* check crc, close output file */
X        if (c == NULL)
X          err(SE_FORM, h);
X        if (c->n != 4 || c->b != ~c->c)
X          err(SE_CRC, r);
X        if (ferror(c->f) || fclose(c->f))
X          err(SE_FULL, r);
X        if (noisy)
X          fprintf(stderr, "%s received\n", r);
X        z = 0;
X        free((voidp *)c);
X        c = NULL;
X        b = 2;
X      }
X      else
X      {
X        for (q = l; *q && *q != ' '; q++)
X          ;
X        *q = 0;
X        fprintf(stderr, "%s: unsupported keyword '%s' ignored\n", warname, l);
X        b = 4;
X      }
X      break;
X    }
X  }
X}
X
X
Xvoid help()
X{
X  int i;
X  static char *text[] = {
X"Usage:",
X"   ship [-f] [-q] [-nnn] [-m address] [-s subject] files...",
X"",
X"   ships the files to stdout.  -m sends the output via the mailer to",
X"   address.  -nnn splits the output into pieces of nnnK bytes or less.",
X"   if -nnn is used without -m, the output goes to the files partxxxx,",
X"   where xxxx is 0001, 0002, etc.  If -0 is specified, the output goes",
X"   entirely to the file part0001.  -f uses a fast method with slightly",
X"   less performance.  If no files are given, stdin is used.  The special",
X"   filename '-' also takes input from stdin.  Files shipped from stdin",
X"   are unshipped to stdout.  This can be used to document a shipment.",
X"   When mailing, -s gives a subject line prefix.  -q inhibits messages.",
X"",
X"   ship -u [-o] [-q] files...",
X"   unship  [-o] [-q] files...",
X"",
X"   extracts the contents of the mail messages in files...  -o allows",
X"   existing files to be overwritten.  -u is implied if the name of the",
X"   executable is unship.  If no files are given, the input is from",
X"   stdin.  If any of the files were shipped from stdin, then they are",
X"   extracted to stdout."
X  };
X
X  puts(SHIPVER);
X  for (i = 0; i < sizeof(text)/sizeof(char *); i++)
X  {
X    printf(text[i]);
X    putchar('\n');
X  }
X  exit(0);
X}
X
X
Xvoid main(argc, argv)
Xint argc;               /* number of arguments */
Xchar **argv;            /* table of argument strings */
X{
X  FILE *f;              /* input file */
X  ulg k;                /* number of k requested per part */
X  char *p;              /* temporary variable */
X  int o;                /* overwrite flag */
X  int r;                /* temporary variable */
X  int s;                /* true if no names given */
X
X  /* No temporary file yet (for err()) */
X  *mname = 0;
X
X  /* No subject prefix yet */
X  *mprefix = 0;
X
X  /* See if help requested */
X  if (argc > 1 && (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "-?") == 0))
X    help();
X
X  /* Unship */
X  if ((p = strrchr(argv[0], PATHCUT)) == NULL)
X    p = argv[0];
X  else
X    p++;
X  r = 0;                                /* (make some compilers happier) */
X  if ((r = strncmp(p, "unship", 6)) == 0 ||
X      (r = strncmp(p, "UNSHIP", 6)) == 0 ||
X      (argc > 1 && strcmp(argv[1], "-u") == 0))
X  {
X    errname = "unship error";
X    warname = "unship warning";
X    r = r ? 2 : 1;                      /* next arg */
X    o = 0;                              /* disallow overwriting */
X    if (r < argc && strcmp(argv[r], "-o") == 0)
X    {
X      r++;
X      o = 1;                            /* allow overwriting */
X    }
X    if (r < argc && strcmp(argv[r], "-q") == 0)
X    {
X      r++;
X      noisy = 0;                        /* inhibit messages */
X    }
X    if (r < argc)
X      unship(argv + r, argc - r, o);    /* unship files in args */
X    else
X    {
X      char *a[1];       /* short list of names (one) */
X
X      a[0] = "-";
X      unship(a, 1, o);                  /* no args--do stdin */
X    }
X  }
X
X  /* Ship */
X  else
X  {
X    mail = 0;                           /* not mailing */
X    fast = 0;                           /* use base 85 encoding */
X    s = 1;                              /* no names given yet */
X    strcpy(sname, "-");                 /* output to stdout */
X    sfile = stdout;
X    slns = slmax = k = 0;
X    for (r = 1; r < argc; r++)          /* go through args */
X      if (argv[r][0] == '-')            /* option or stdin */
X        if (argv[r][1])                 /* option */
X        {
X          if (argv[r][1] == 'm')        /* mail output */
X          {
X            mail = 1;
X            mdest = NULL;               /* next arg is mail address */
X          }
X          else if (argv[r][1] == 's')   /* next arg is subject prefix */
X            mprefix = NULL;
X          else if (argv[r][1] == 'f')   /* fast arithmetic encoding */
X          {
X            fast = 1;
X            if (k)                      /* recompute slmax if needed */
X              slmax = 4 + (k * 1024L) / 81;
X          }
X          else if (argv[r][1] == 'q')   /* quiet operation */
X            noisy = 0;
X          else                          /* option is number of lines */
X          {
X            /* Check numeric option */
X            for (p = argv[r] + 1; *p; p++)
X              if (*p < '0' || *p > '9')
X                break;
X            if (*p || slmax)
X              err(SE_ARG, argv[r]);
X  
X            /* Zero means infinity, else convert */
X            if ((k = atol(argv[r] + 1)) == 0)
X              slmax = -1L;
X            else
X              slmax = 4 + (k * 1024L) / (fast ? 81 : 77);
X          }
X        }
X        else                            /* input file is stdin */
X        {
X          if (mail && mdest == NULL)
X            err(SE_ARG, "- (no mail destination given)");
X          s = 0;
X          if (mail && !*mprefix)
X            strcpy(mprefix, "(stdin)");
X          ship("-", stdin);
X        }
X      else                              /* not option or stdin */
X        if (mail && mdest == NULL)      /* arg is mail address */
X          mdest = argv[r];
X        else if (mprefix == NULL)       /* arg is subject prefix */
X          mprefix = argv[r];
X        else                            /* arg is file to ship */
X        {
X          s = 0;
X          if ((f = fopen(argv[r], "r")) == NULL)
X            err(SE_FIND, argv[r]);
X          if (mail && !*mprefix)
X          {
X            int i;
X
X            for (i = 0, p = nopath(argv[r]); i < 8 && *p; p++)
X              if ((*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'Z') ||
X                  (*p >= 'a' && *p <= 'z') || *p == '.' || *p == '_')
X                mprefix[i++] = *p;
X            mprefix[i] = 0;
X          }
X          ship(argv[r], f);
X          fclose(f);
X        }
X    if (s)                              /* no names--act as filter */
X      if (mail && mdest == NULL)
X        err(SE_ARG, "-m (no mail destination given)");
X      else if (mprefix == NULL)
X        err(SE_ARG, "-s (no subject prefix given)");
X      else
X      {
X        if (mail && !*mprefix)
X          strcpy(mprefix, "(stdin)");
X        ship("-", stdin);
X      }
X    endship(1);                         /* clean up */
X    if (noisy && (mail || slmax))
X      fprintf(stderr, "file%s%s %s\n",
X              strcmp("part0001", sname) ? "s part0001.." : " ", sname,
X              mail ? "mailed" : "written");
X  }
X
X  /* Done */
X  exit(0);
X}
END_OF_FILE
  if test 38513 -ne `wc -c <'ship.c'`; then
    echo shar: \"'ship.c'\" unpacked with wrong size!
  fi
  # end of 'ship.c'
fi
echo shar: End of archive 1 \(of 12\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0


exit 0 # Just in case...
