Newsgroups: comp.sources.misc
From: cthuang@zerosan.UUCP (Chin Huang)
Subject:  v29i079:  cproto - generate C function prototypes v3, Patch03
Message-ID: <1992Apr17.021530.17139@sparky.imd.sterling.com>
X-Md4-Signature: bd96eb683edc08ae9f04346fd4bc5624
Date: Fri, 17 Apr 1992 02:15:30 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cthuang@zerosan.UUCP (Chin Huang)
Posting-number: Volume 29, Issue 79
Archive-name: cproto/patch03
Environment: UNIX, MS-DOS, getopt, lex, yacc
Patch-To: cproto: Volume 29, Issue 61-62

This patch brings cproto to version 3 patchlevel 3.  This release fixes
several bugs and adds some new options.  Read the CHANGES file for
details.  Thanks to the following people for their suggestions and bug
reports:

witr@rwwa.com (Robert Withrow)
Si Hanh Nguyen <shn@bby.oz.au>
pelf!dj@harvard.harvard.edu (Diab Jerius)
------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  patch3
# Wrapped by cthuang@zerosan.UUCP on Sat Apr 11 19:45:01 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f patch3 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"patch3\"
else
echo shar: Extracting \"patch3\" \(23755 characters\)
sed "s/^X//" >patch3 <<'END_OF_patch3'
Xdiff -c old/CHANGES new/CHANGES
X*** old/CHANGES	Sat Apr 11 19:11:26 1992
X--- new/CHANGES	Sat Apr 11 19:23:02 1992
X***************
X*** 1,5 ****
X--- 1,17 ----
X  Version 3
X  
X+ Patchlevel 3
X+ 
X+ - Fix: The program didn't generate prototypes for functions defined with
X+   the extern specifier.
X+ - Fix: The -c option didn't output a space before parameter names in
X+   generated prototypes.
X+ - Added the -E option to specify a particular C preprocessor to run or
X+   to stop the program from running the C preprocessor.
X+ - Added the -q option to stop the program from outputting error messages
X+   when it cannot read the file specified in an #include directive.
X+ - Made the yacc specification compatible with UNIX SYSVR4 yacc.
X+   
X  Patchlevel 2
X  
X  - Fix: The function definition conversion may produce a mangled function
Xdiff -c old/cproto.1 new/cproto.1
X*** old/cproto.1	Sat Apr 11 19:11:26 1992
X--- new/cproto.1	Sat Apr 11 19:27:16 1992
X***************
X*** 1,4 ****
X! .\" $Id: cproto.1 3.4 92/04/04 14:01:52 cthuang Exp $
X  .\"
X  .de EX		\"Begin example
X  .ne 5
X--- 1,4 ----
X! .\" $Id: cproto.1 3.5 92/04/11 19:27:07 cthuang Exp $
X  .\"
X  .de EX		\"Begin example
X  .ne 5
X***************
X*** 13,19 ****
X  .if n .sp 1
X  .if t .sp .5
X  ..
X! .TH CPROTO 1 "April 3, 1992"
X  .SH NAME
X  cproto \- generate C function prototypes and convert function definitions
X  .SH SYNOPSIS
X--- 13,19 ----
X  .if n .sp 1
X  .if t .sp .5
X  ..
X! .TH CPROTO 1 "April 7, 1992"
X  .SH NAME
X  cproto \- generate C function prototypes and convert function definitions
X  .SH SYNOPSIS
X***************
X*** 55,62 ****
X  such as in the example,
X  .EX
X  main (argc, argv)
X! int argc;	/* number of arguments */
X! char *argv[];	/* arguments */
X  {
X   ...
X  }
X--- 55,62 ----
X  such as in the example,
X  .EX
X  main (argc, argv)
X! int argc;       /* number of arguments */
X! char *argv[];   /* arguments */
X  {
X   ...
X  }
X***************
X*** 65,71 ****
X  .EX
X  int
X  main (
X!     int argc;	    /* number of arguments */
X      char *argv[];   /* arguments */
X  )
X  {
X--- 65,71 ----
X  .EX
X  int
X  main (
X!     int argc;       /* number of arguments */
X      char *argv[];   /* arguments */
X  )
X  {
X***************
X*** 132,147 ****
X  .TP
X  .B \-c
X  Omit the parameter comments in the prototypes generated by
X! the -f1 and -f2 options.
X  This option also omits the comments naming the source files from which
X  the prototypes were generated.
X  .TP
X  .BI \-m name
X! Set the name of the macro used to guard prototypes when option -f4 is selected.
X  The default is "P_".
X  .TP
X  .B \-d
X! Omit the definition of the prototype macro named by the -m option.
X  .TP
X  .B \-p
X  Disable promotion of formal parameters in old style function definitions.
X--- 132,147 ----
X  .TP
X  .B \-c
X  Omit the parameter comments in the prototypes generated by
X! the \-f1 and \-f2 options.
X  This option also omits the comments naming the source files from which
X  the prototypes were generated.
X  .TP
X  .BI \-m name
X! Set the name of the macro used to guard prototypes when option \-f4 is selected.
X  The default is "P_".
X  .TP
X  .B \-d
X! Omit the definition of the prototype macro named by the \-m option.
X  .TP
X  .B \-p
X  Disable promotion of formal parameters in old style function definitions.
X***************
X*** 158,163 ****
X--- 158,169 ----
X  .B double
X  as well.
X  .TP
X+ .B \-q
X+ Do not output any error messages when the program cannot read the
X+ file specified in an
X+ .I #include
X+ directive.
X+ .TP
X  .B \-s
X  By default,
X  .B cproto
X***************
X*** 212,217 ****
X--- 218,231 ----
X  a directory to search for files that are referenced with 
X  .I #include.
X  .TP
X+ .BI \-E cpp
X+ Pipe the input files through the specified C preprocessor command
X+ when generating prototypes.
X+ By default, the program uses /lib/cpp.
X+ .TP
X+ .BI \-E 0
X+ Do not run the C preprocessor.
X+ .TP
X  .B \-V
X  Print version information.
X  .SH ENVIRONMENT
X***************
X*** 229,235 ****
X  The conversion also discards some comments in the function definition
X  head.
X  .LP
X! The -v option does not generate declarations for variables defined with the
X  .B extern
X  specifier.
X  This doesn't strictly conform to the C language standard but this rule
X--- 243,249 ----
X  The conversion also discards some comments in the function definition
X  head.
X  .LP
X! The \-v option does not generate declarations for variables defined with the
X  .B extern
X  specifier.
X  This doesn't strictly conform to the C language standard but this rule
Xdiff -c old/cproto.c new/cproto.c
X*** old/cproto.c	Sat Apr 11 19:11:38 1992
X--- new/cproto.c	Sat Apr 11 19:28:06 1992
X***************
X*** 1,9 ****
X! /* $Id: cproto.c 3.4 92/04/04 13:59:22 cthuang Exp $
X   *
X   * C function prototype generator and function definition converter
X   */
X  #ifndef lint
X! static char rcsid[] = "$Id: cproto.c 3.4 92/04/04 13:59:22 cthuang Exp $";
X  #endif
X  #include <stdio.h>
X  #include <ctype.h>
X--- 1,9 ----
X! /* $Id: cproto.c 3.5 92/04/11 19:28:01 cthuang Exp $
X   *
X   * C function prototype generator and function definition converter
X   */
X  #ifndef lint
X! static char rcsid[] = "$Id: cproto.c 3.5 92/04/11 19:28:01 cthuang Exp $";
X  #endif
X  #include <stdio.h>
X  #include <ctype.h>
X***************
X*** 59,64 ****
X--- 59,67 ----
X      { "", "\n", " ", "\n    ", "\n    ", "\n" },
X  };
X  
X+ /* If TRUE, don't output message if unable to read an include file */
X+ boolean quiet = FALSE;
X+ 
X  /* Include file directories */
X  #ifdef MSDOS
X  int num_inc_dir = 1;
X***************
X*** 72,78 ****
X  #ifdef CPP
X  extern FILE *popen();
X  extern int pclose();
X! static char *cpp_cmd, *cmd;
X  #endif
X  
X  
X--- 75,81 ----
X  #ifdef CPP
X  extern FILE *popen();
X  extern int pclose();
X! static char *cpp = CPP, *cpp_opt, *cpp_cmd;
X  #endif
X  
X  
X***************
X*** 228,233 ****
X--- 231,237 ----
X  	stderr);
X      fputs("  -f n     Set function prototype style (0 to 4)\n", stderr);
X      fputs("  -p       Disable formal parameter promotion\n", stderr);
X+     fputs("  -q       Disable include file read failure messages\n", stderr);
X      fputs("  -s       Output static declarations\n", stderr);
X      fputs("  -t       Convert function definitions to traditional style\n",
X  	stderr);
X***************
X*** 240,250 ****
X  	stderr);
X      fputs("  -C fmt   Set format for function definition with parameter comments\n",
X  	stderr);
X-     fputs("  -V       Print version information\n", stderr);
X      fputs("  -D name[=value]\n", stderr);
X      fputs("  -U name\n", stderr);
X      fputs("  -I directory\n", stderr);
X      fputs("           Set C preprocessor options\n", stderr);
X      exit(1);
X  }
X  
X--- 244,256 ----
X  	stderr);
X      fputs("  -C fmt   Set format for function definition with parameter comments\n",
X  	stderr);
X      fputs("  -D name[=value]\n", stderr);
X      fputs("  -U name\n", stderr);
X      fputs("  -I directory\n", stderr);
X      fputs("           Set C preprocessor options\n", stderr);
X+     fputs("  -E cpp   Run specified C preprocessor command\n", stderr);
X+     fputs("  -E 0     Do not run any C preprocessor\n", stderr);
X+     fputs("  -V       Print version information\n", stderr);
X      exit(1);
X  }
X  
X***************
X*** 288,299 ****
X      for (i = 0; i < argc; ++i) {
X  	n += strlen(argv[i]) + 1;
X      }
X      cpp_cmd = xmalloc(n);
X-     strcpy(cpp_cmd, CPP);
X-     cmd = xmalloc(n);
X  #endif
X  
X!     while ((c = getopt(argc, argv, "aC:cD:deF:f:I:m:P:pstU:Vv")) != EOF) {
X  	switch (c) {
X  	case 'I':
X  	    if (num_inc_dir < MAX_INC_DIR) {
X--- 294,305 ----
X      for (i = 0; i < argc; ++i) {
X  	n += strlen(argv[i]) + 1;
X      }
X+     cpp_opt = xmalloc(n);
X+     *cpp_opt = '\0';
X      cpp_cmd = xmalloc(n);
X  #endif
X  
X!     while ((c = getopt(argc, argv, "aC:cD:dE:eF:f:I:m:P:pqstU:Vv")) != EOF) {
X  	switch (c) {
X  	case 'I':
X  	    if (num_inc_dir < MAX_INC_DIR) {
X***************
X*** 306,312 ****
X  	case 'U':
X  #ifdef CPP
X  	    sprintf(tmp, " -%c%s", c, optarg);
X! 	    strcat(cpp_cmd, tmp);
X  #endif
X  	    break;
X  	case 'a':
X--- 312,318 ----
X  	case 'U':
X  #ifdef CPP
X  	    sprintf(tmp, " -%c%s", c, optarg);
X! 	    strcat(cpp_opt, tmp);
X  #endif
X  	    break;
X  	case 'a':
X***************
X*** 318,323 ****
X--- 324,338 ----
X  	case 'd':
X  	    define_macro = FALSE;
X  	    break;
X+ 	case 'E':
X+ #ifdef CPP
X+ 	    if (strcmp(optarg, "0") == 0) {
X+ 		cpp = NULL;
X+ 	    } else {
X+ 		cpp = optarg;
X+ 	    }
X+ #endif
X+ 	    break;
X  	case 'e':
X  	    extern_out = TRUE;
X  	    break;
X***************
X*** 377,382 ****
X--- 392,400 ----
X  	case 'p':
X  	    promote_param = FALSE;
X  	    break;
X+ 	case 'q':
X+ 	    quiet = TRUE;
X+ 	    break;
X  	case 's':
X  	    static_out = TRUE;
X  	    break;
X***************
X*** 385,390 ****
X--- 403,409 ----
X  	    break;
X  	case 'V':
X  	    fprintf(stderr, "%s patchlevel %d\n", rcsid, PATCHLEVEL);
X+ 	    exit(1);
X  	    break;
X  	case 'v':
X  	    variables_out = TRUE;
X***************
X*** 428,443 ****
X      } else {
X  	for (i = optind; i < argc; ++i) {
X  #ifdef CPP
X! 	    if (func_style == FUNC_NONE) {
X! 		sprintf(cmd, "%s %s", cpp_cmd, argv[i]);
X! 		if ((inf = popen(cmd, "r")) == NULL) {
X! 		    fprintf(stderr, "%s: error running cpp\n", progname);
X  		    continue;
X  		}
X  	    } else {
X  		if ((inf = fopen(argv[i], "r")) == NULL) {
X  		    fprintf(stderr, "%s: cannot read file %s\n", progname,
X! 			argv[i]);
X  		    continue;
X  		}
X  	    }
X--- 447,463 ----
X      } else {
X  	for (i = optind; i < argc; ++i) {
X  #ifdef CPP
X! 	    if (func_style == FUNC_NONE && cpp != NULL) {
X! 		sprintf(cpp_cmd, "%s%s %s", cpp, cpp_opt, argv[i]);
X! 		if ((inf = popen(cpp_cmd, "r")) == NULL) {
X! 		    fprintf(stderr, "%s: error running %s\n", progname,
X! 		     cpp_cmd);
X  		    continue;
X  		}
X  	    } else {
X  		if ((inf = fopen(argv[i], "r")) == NULL) {
X  		    fprintf(stderr, "%s: cannot read file %s\n", progname,
X! 		     argv[i]);
X  		    continue;
X  		}
X  	    }
Xdiff -c old/cproto.h new/cproto.h
X*** old/cproto.h	Sat Apr 11 19:11:36 1992
X--- new/cproto.h	Sat Apr 11 19:27:48 1992
X***************
X*** 1,4 ****
X! /* $Id: cproto.h 3.4 92/04/04 13:59:08 cthuang Exp $
X   *
X   * Declarations for C function prototype generator
X   */
X--- 1,4 ----
X! /* $Id: cproto.h 3.5 92/04/11 19:27:44 cthuang Exp $
X   *
X   * Declarations for C function prototype generator
X   */
X***************
X*** 25,36 ****
X  } ParameterList;
X  
X  /* Declaration specifier flags */
X! #define DS_EXTERN	0	/* default: external declaration */
X! #define DS_STATIC	1	/* visible only in current file */
X! #define DS_CHAR 	2	/* "char" type specifier in declaration */
X! #define DS_SHORT	4	/* "short" type specifier in declaration */
X! #define DS_FLOAT	8	/* "float" type specifier in declaration */
X! #define DS_JUNK 	16	/* we're not interested in this declaration */
X  
X  /* This structure stores information about a declaration specifier. */
X  typedef struct decl_spec {
X--- 25,37 ----
X  } ParameterList;
X  
X  /* Declaration specifier flags */
X! #define DS_NONE 	0	/* default */
X! #define DS_EXTERN	1	/* contains "extern" specifier */
X! #define DS_STATIC	2	/* contains "static" specifier */
X! #define DS_CHAR 	4	/* contains "char" type specifier */
X! #define DS_SHORT	8	/* contains "short" type specifier */
X! #define DS_FLOAT	16	/* contains "float" type specifier */
X! #define DS_JUNK 	32	/* we're not interested in this declaration */
X  
X  /* This structure stores information about a declaration specifier. */
X  typedef struct decl_spec {
X***************
X*** 105,111 ****
X  typedef int FuncFormatType;
X  
X  /* Prototype/function definition output format */
X! typedef struct {
X      char *decl_spec_prefix;	/* output before declaration specifier */
X      char *declarator_prefix;	/* output before declarator name */
X      char *declarator_suffix;	/* output before '(' of parameter list */
X--- 106,112 ----
X  typedef int FuncFormatType;
X  
X  /* Prototype/function definition output format */
X! typedef struct func_format {
X      char *decl_spec_prefix;	/* output before declaration specifier */
X      char *declarator_prefix;	/* output before declarator name */
X      char *declarator_suffix;	/* output before '(' of parameter list */
X***************
X*** 124,129 ****
X--- 125,131 ----
X  extern boolean define_macro;
X  extern char *macro_name;
X  extern boolean proto_comments;
X+ extern boolean quiet;
X  extern int num_inc_dir;
X  extern char *inc_dir[];
X  extern FuncFormat fmt[4];
Xdiff -c old/grammar.y new/grammar.y
X*** old/grammar.y	Sat Apr 11 19:11:28 1992
X--- new/grammar.y	Sat Apr 11 19:27:38 1992
X***************
X*** 1,4 ****
X! /* $Id: grammar.y 3.4 92/04/04 13:58:58 cthuang Exp $
X   *
X   * yacc grammar for C function prototype generator
X   * This was derived from the grammar in Appendix A of
X--- 1,4 ----
X! /* $Id: grammar.y 3.5 92/04/11 19:27:34 cthuang Exp $
X   *
X   * yacc grammar for C function prototype generator
X   * This was derived from the grammar in Appendix A of
X***************
X*** 5,10 ****
X--- 5,12 ----
X   * "The C Programming Language" by Kernighan and Ritchie.
X   */
X  
X+ %token <text> '(' '*'
X+ 
X  %token
X  	/* identifiers that are not reserved words */
X  	T_IDENTIFIER T_TYPEDEF_NAME
X***************
X*** 203,209 ****
X  
X  	    func_params = NULL;
X  
X! 	    new_decl_spec(&decl_spec, "int", $1->begin, DS_EXTERN);
X  	    if (cur_file->convert)
X  		gen_func_definition(&decl_spec, $1);
X  	    gen_prototype(&decl_spec, $1);
X--- 205,211 ----
X  
X  	    func_params = NULL;
X  
X! 	    new_decl_spec(&decl_spec, "int", $1->begin, DS_NONE);
X  	    if (cur_file->convert)
X  		gen_func_definition(&decl_spec, $1);
X  	    gen_prototype(&decl_spec, $1);
X***************
X*** 242,256 ****
X  storage_class
X  	: T_AUTO
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_EXTERN
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_JUNK);
X  	}
X  	| T_REGISTER
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_STATIC
X  	{
X--- 244,258 ----
X  storage_class
X  	: T_AUTO
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_EXTERN
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_REGISTER
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_STATIC
X  	{
X***************
X*** 265,303 ****
X  type_specifier
X  	: T_CHAR
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN | DS_CHAR);
X  	}
X  	| T_DOUBLE
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_FLOAT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN | DS_FLOAT);
X  	}
X  	| T_INT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_LONG
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_SHORT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN | DS_SHORT);
X  	}
X  	| T_SIGNED
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_UNSIGNED
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_VOID
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| struct_or_union_specifier
X  	| enum_specifier
X--- 267,305 ----
X  type_specifier
X  	: T_CHAR
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_CHAR);
X  	}
X  	| T_DOUBLE
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_FLOAT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_FLOAT);
X  	}
X  	| T_INT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_LONG
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_SHORT
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_SHORT);
X  	}
X  	| T_SIGNED
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_UNSIGNED
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_VOID
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| struct_or_union_specifier
X  	| enum_specifier
X***************
X*** 306,312 ****
X  type_qualifier
X  	: T_TYPE_QUALIFIER
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_EXTERN);
X  	}
X  	| T_TYPEDEF_NAME
X  	{
X--- 308,314 ----
X  type_qualifier
X  	: T_TYPE_QUALIFIER
X  	{
X! 	    new_decl_spec(&$$, $1.text, $1.begin, DS_NONE);
X  	}
X  	| T_TYPEDEF_NAME
X  	{
X***************
X*** 324,340 ****
X  	: struct_or_union any_id braces
X  	{
X  	    sprintf(buf, "%s %s", $1.text, $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_EXTERN);
X  	}
X  	| struct_or_union braces
X  	{
X  	    sprintf(buf, "%s {}", $1.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_EXTERN);
X  	}
X  	| struct_or_union any_id
X  	{
X  	    sprintf(buf, "%s %s", $1.text, $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_EXTERN);
X  	}
X  	;
X  
X--- 326,342 ----
X  	: struct_or_union any_id braces
X  	{
X  	    sprintf(buf, "%s %s", $1.text, $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_NONE);
X  	}
X  	| struct_or_union braces
X  	{
X  	    sprintf(buf, "%s {}", $1.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_NONE);
X  	}
X  	| struct_or_union any_id
X  	{
X  	    sprintf(buf, "%s %s", $1.text, $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_NONE);
X  	}
X  	;
X  
X***************
X*** 379,394 ****
X  	: T_ENUM any_id braces
X  	{
X  	    sprintf(buf, "enum %s", $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_EXTERN);
X  	}
X  	| T_ENUM braces
X  	{
X! 	    new_decl_spec(&$$, "enum {}", $1.begin, DS_EXTERN);
X  	}
X  	| T_ENUM any_id
X  	{
X  	    sprintf(buf, "enum %s", $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_EXTERN);
X  	}
X  	;
X  
X--- 381,396 ----
X  	: T_ENUM any_id braces
X  	{
X  	    sprintf(buf, "enum %s", $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_NONE);
X  	}
X  	| T_ENUM braces
X  	{
X! 	    new_decl_spec(&$$, "enum {}", $1.begin, DS_NONE);
X  	}
X  	| T_ENUM any_id
X  	{
X  	    sprintf(buf, "enum %s", $2.text);
X! 	    new_decl_spec(&$$, buf, $1.begin, DS_NONE);
X  	}
X  	;
X  
X***************
X*** 651,657 ****
X      /* Initialize type qualifier table. */
X      type_qualifiers = new_symbol_table();
X      for (i = 0; i < sizeof(keywords)/sizeof(keywords[0]); ++i) {
X! 	new_symbol(type_qualifiers, keywords[i], DS_EXTERN);
X      }
X  }
X  
X--- 653,659 ----
X      /* Initialize type qualifier table. */
X      type_qualifiers = new_symbol_table();
X      for (i = 0; i < sizeof(keywords)/sizeof(keywords[0]); ++i) {
X! 	new_symbol(type_qualifiers, keywords[i], DS_NONE);
X      }
X  }
X  
Xdiff -c old/lex.l new/lex.l
X*** old/lex.l	Sat Apr 11 19:11:28 1992
X--- new/lex.l	Sat Apr 11 19:27:34 1992
X***************
X*** 1,5 ****
X  %{
X! /* $Id: lex.l 3.5 92/04/04 13:58:53 cthuang Exp $
X   *
X   * Lexical analyzer for C function prototype generator
X   */
X--- 1,5 ----
X  %{
X! /* $Id: lex.l 3.6 92/04/11 19:27:25 cthuang Exp $
X   *
X   * Lexical analyzer for C function prototype generator
X   */
X***************
X*** 9,15 ****
X  
X  /* information about the current input file */
X  typedef struct {
X!     char *file_name;		/* input file name */
X      FILE *file; 		/* input file */
X      unsigned line_num;		/* current line number in input file */
X      FILE *tmp_file;		/* temporary file */
X--- 9,16 ----
X  
X  /* information about the current input file */
X  typedef struct {
X!     char *base_name;		/* base input file name */
X!     char *file_name;		/* current file name */
X      FILE *file; 		/* input file */
X      unsigned line_num;		/* current line number in input file */
X      FILE *tmp_file;		/* temporary file */
X***************
X*** 344,349 ****
X--- 345,351 ----
X      ++inc_depth;
X      cur_file = inc_stack + inc_depth;
X      cur_file->file = yyin;
X+     cur_file->base_name = xstrdup(name);
X      cur_file->file_name = strcpy(xmalloc(MAX_TEXT_SIZE), name);
X      cur_file->line_num = 1;
X      cur_file->convert = convert;
X***************
X*** 402,418 ****
X  	if (cur_file->changed) {
X  	    if (yyin == stdin) {
X  		put_file(stdout);
X! 	    } else if ((outf = fopen(cur_file->file_name, "w")) != NULL) {
X  		put_file(outf);
X  		fclose(outf);
X  	    } else {
X  		fprintf(stderr, "%s: cannot create file %s\n", progname,
X! 		    cur_file->file_name);
X  	    }
X  	}
X  
X  	fclose(cur_file->tmp_file);
X      }
X      free(cur_file->file_name);
X  
X  #ifdef FLEX_SCANNER
X--- 404,421 ----
X  	if (cur_file->changed) {
X  	    if (yyin == stdin) {
X  		put_file(stdout);
X! 	    } else if ((outf = fopen(cur_file->base_name, "w")) != NULL) {
X  		put_file(outf);
X  		fclose(outf);
X  	    } else {
X  		fprintf(stderr, "%s: cannot create file %s\n", progname,
X! 		    cur_file->base_name);
X  	    }
X  	}
X  
X  	fclose(cur_file->tmp_file);
X      }
X+     free(cur_file->base_name);
X      free(cur_file->file_name);
X  
X  #ifdef FLEX_SCANNER
X***************
X*** 464,471 ****
X  	}
X      }
X  
X!     put_error();
X!     fprintf(stderr, "cannot read file %s\n", filename);
X  }
X  
X  /* When the end of the current input file is reached, pop a
X--- 467,476 ----
X  	}
X      }
X  
X!     if (!quiet) {
X! 	put_error();
X! 	fprintf(stderr, "cannot read file %s\n", filename);
X!     }
X  }
X  
X  /* When the end of the current input file is reached, pop a
XOnly in new: makefile
Xdiff -c old/Makefile.uni new/Makefile.uni
X*** old/Makefile.uni	Sat Apr 11 19:11:26 1992
X--- new/Makefile.uni	Sat Apr 11 19:27:24 1992
X***************
X*** 1,4 ****
X! # $Id: makefile.uni 3.3 92/04/04 13:58:48 cthuang Exp $
X  #
X  # UNIX makefile for C prototype generator
X  
X--- 1,4 ----
X! # $Id: makefile.uni 3.4 92/04/11 19:27:21 cthuang Exp $
X  #
X  # UNIX makefile for C prototype generator
X  
X***************
X*** 31,37 ****
X  	nroff -man cproto.1 >$@
X  
X  clean:
X! 	rm *.o *.bak *.log cproto
X  
X  ci:
X  	ci -u3 $(DIST2) $(DIST3) $(DIST4)
X--- 31,37 ----
X  	nroff -man cproto.1 >$@
X  
X  clean:
X! 	rm -f *.o *.bak *.log cproto lex.yy.c y.tab.c
X  
X  ci:
X  	ci -u3 $(DIST2) $(DIST3) $(DIST4)
Xdiff -c old/patchlev.h new/patchlev.h
X*** old/patchlev.h	Sat Apr 11 19:11:36 1992
X--- new/patchlev.h	Sat Apr 11 19:28:34 1992
X***************
X*** 1,1 ****
X! #define PATCHLEVEL 2
X--- 1,1 ----
X! #define PATCHLEVEL 3
Xdiff -c old/semantic.c new/semantic.c
X*** old/semantic.c	Sat Apr 11 19:11:38 1992
X--- new/semantic.c	Sat Apr 11 19:28:14 1992
X***************
X*** 1,4 ****
X! /* $Id: semantic.c 3.4 92/04/04 13:59:28 cthuang Exp $
X   *
X   * Semantic actions executed by the parser of the
X   * C function prototype generator.
X--- 1,4 ----
X! /* $Id: semantic.c 3.5 92/04/11 19:28:08 cthuang Exp $
X   *
X   * Semantic actions executed by the parser of the
X   * C function prototype generator.
X***************
X*** 365,373 ****
X  {
X      fputs(p->decl_spec.text, outf);
X      if (strlen(p->declarator->text) > 0) {
X! 	if (strcmp(p->declarator->text, "...") != 0)
X! 	    if (where != FUNC_PROTO || proto_comments)
X  		fputc(' ', outf);
X  	put_declarator(outf, p->declarator);
X      }
X  }
X--- 365,376 ----
X  {
X      fputs(p->decl_spec.text, outf);
X      if (strlen(p->declarator->text) > 0) {
X! 	if (strcmp(p->declarator->text, "...") != 0) {
X! 	    if (proto_style != PROTO_ABSTRACT || proto_comments ||
X! 	     where != FUNC_PROTO ||
X! 	     strcmp(p->declarator->text, p->declarator->name) != 0)
X  		fputc(' ', outf);
X+ 	}
X  	put_declarator(outf, p->declarator);
X      }
X  }
X***************
X*** 593,599 ****
X  {
X      Declarator *d;
X  
X!     if (!variables_out || (decl_spec->flags & DS_JUNK))
X  	return;
X      if (!static_out && (decl_spec->flags & DS_STATIC))
X  	return;
X--- 596,602 ----
X  {
X      Declarator *d;
X  
X!     if (!variables_out || (decl_spec->flags & (DS_EXTERN|DS_JUNK)))
X  	return;
X      if (!static_out && (decl_spec->flags & DS_STATIC))
X  	return;
X***************
X*** 637,645 ****
X  DeclSpec *decl_spec;
X  Declarator *declarator;
X  {
X!     if (proto_style == PROTO_NONE)
X! 	return;
X!     if (decl_spec->flags & DS_JUNK)
X  	return;
X      if (!static_out && (decl_spec->flags & DS_STATIC))
X  	return;
X--- 640,646 ----
X  DeclSpec *decl_spec;
X  Declarator *declarator;
X  {
X!     if (proto_style == PROTO_NONE || (decl_spec->flags & DS_JUNK))
X  	return;
X      if (!static_out && (decl_spec->flags & DS_STATIC))
X  	return;
END_OF_patch3
if test 23755 -ne `wc -c <patch3`; then
    echo shar: \"patch3\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of shell archive.
exit 0

-- 
Chin Huang  cthuang@zerosan.UUCP  chin.huang@canrem.com

exit 0 # Just in case...
