Newsgroups: comp.sources.misc
From: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Subject:  v29i116:  parseargs - functions to parse command line arguments, Part01/10
Message-ID: <1992May17.182221.28490@sparky.imd.sterling.com>
X-Md4-Signature: d30d5f3b7ec44dc723b06665f9923280
Date: Sun, 17 May 1992 18:22:21 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Posting-number: Volume 29, Issue 116
Archive-name: parseargs/part01
Environment: UNIX, VMS, MS-DOS, OS/2, Amiga
Supersedes: parseargs: Volume 17, Issue 46-57

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 10)."
# Contents:  MANIFEST README doc doc/argvalopt.inc doc/caveats.inc
#   doc/cmd_macros.inc doc/defargs.inc doc/effects.inc
#   doc/fparseargs3.inc doc/lib_bugs.inc doc/lparseargs3.inc
#   doc/parseargs1.inc doc/parseargs3.inc doc/parsecntl.man3
#   doc/parsecntl3.inc doc/parsemodes.inc doc/sparseargs3.inc
#   doc/usage3.inc doc/vparseargs3.inc exit_codes.h pgopen.h test.pl
#   test.rc test.sh test.tcl
# Wrapped by brad@hcx1 on Thu May  7 12:12:13 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(4410 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Intro                      2	Introduction to parseargs
X MANIFEST                   1	This file
X Makefile                   2	makefile for parseargs library
X README                     1	release information
X VMSbuild.com               2	VMS makefile for the parseargs library
X amiga_args.c               5	parse AmigaDOS command-lines
X arglist.c                  3	implement the listXxxx functions for arglists
X argtype.c                  5	implement the argXxxx argument type functions
X doc                        1	directory containing documentation
X doc/Makefile               2	makefile for the documentation
X doc/arg_macros.inc         2	describe arg-xxx and ARG_XXX macros
X doc/argdesc.inc            2	describe an ARGDESC structure
X doc/argflags.inc           2	describe argument flags
X doc/argtype.man3           3	{n,t}roff source for argtype(3)
X doc/argvalopt.inc          1	describe options with optional arguments
X doc/bugs.inc               2	BUGS section for parseargs(1)
X doc/caveats.inc            1	CAVEATS section for parseargs(1) and (3)
X doc/cmd_macros.inc         1	describe CMD_XXX macros
X doc/defargs.inc            1	describe the default argdesc-array
X doc/effects.inc            1	describe the side-effects of parseargs(3)
X doc/env_args.inc           2	describe use of $CMD_ARGS
X doc/env_parse.inc          2	describe use of $PARSECNTL
X doc/env_usage.inc          2	describe use of $USAGECNTL
X doc/fparseargs3.inc        1	describe fparseargs(3)
X doc/lib_bugs.inc           1	BUGS section for parseargs(3)
X doc/lparseargs3.inc        1	describe lparseargs(3)
X doc/multivals.inc          2	describe multivals(3)
X doc/parseargs.man1         4	{n,t}roff source for parseargs(1)
X doc/parseargs.man3         4	{n,t}roff source for parseargs(3)
X doc/parseargs1.inc         1	describe parseargs(1)
X doc/parseargs3.inc         1	describe parseargs(3)
X doc/parsecntl.man3         1	{n,t}roff source for parsecntl(3)
X doc/parsecntl3.inc         1	describe parsecntl(3)
X doc/parsecntls.inc         2	describe function-codes for parsecntl(3)
X doc/parseflags.inc         3	describe parse flags
X doc/parsemodes.inc         1	describe modes for parsecntl(3)
X doc/returns.inc            2	describe function return values
X doc/sh_arrays.inc          3	describe handling of shell arrays
X doc/shells.inc             2	describe handling of different shells
X doc/sparseargs3.inc        1	describe sparseargs(3)
X doc/usage3.inc             1	describe usage(3)
X doc/vparseargs3.inc        1	describe vparseargs(3)
X exit_codes.h               1	#defines for arguments to exit(3C)
X ibm_args.c                 6	parse MS-DOS and OS/2 command-lines
X parseargs.awk              3	parseargs for awk
X parseargs.c               10	C source for parseargs(1)
X parseargs.h                8	include file for parseargs library
X parseargs.pl               2	parseargs for perl
X parseargs.tcl              2	parseargs for tcl
X patchlevel.h               3	list of patches (most recent first)
X pgopen.c                   4	pipe output to a pager
X pgopen.h                   1	include file for pgopen.c
X stest.c                    4	test program for parseargs(3)
X strfuncs.c                 7	string library
X strfuncs.h                 2	include file for strfuncs.c
X syserr.c                   3	diagnostic message printing routines
X test.awk                   3	awk test program for parseargs(1)
X test.csh                   2	C-shell test program for parseargs(1)
X test.ksh                   2	Korn shell test program for parseargs(1)
X test.pl                    1	perl test program for parseargs(1)
X test.rc                    1	Plan 9 shell test program for parseargs(1)
X test.sh                    1	Bourne shell test program for parseargs(1)
X test.tcl                   1	tcl test program for parseargs(1)
X test.zsh                   2	Z shell test program for parseargs(1)
X unix_args.c                5	parse Unix command-lines
X unix_man.c                 4	print Unix manual-page templates
X useful.h                   4	common include file for the library
X vms_args.c                 6	parse VAX/VMS DCL command-lines
X vprintf.c                  3	portable vfprintf, vprintf, and vsprintf
X winsize.c                  3	determine # rows and # columns of window
X xparse.c                   9	implement the parseargs library
END_OF_FILE
if test 4410 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(41528 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X
X
X                                   PARSEARGS
X
X                          extracted from Eric Allman's
X
X                             NIFTY UTILITY LIBRARY
X
X                                 Eric P. Allman
X                            University of California
X                              Berkeley, California
X                               eric@Berkeley.EDU
X
X                                modifications by
X
X                                 Peter da Silva
X                  Ferranti International Controls Corporation
X                               Sugar Land, Texas
X                               peter@ferranti.com
X
X                          modified and rewritten by
X
X                                 Brad Appleton
X                 Harris Corporation, Computer Systems Division
X                         Fort Lauderdale, Florida USA
X                            brad@ssd.csd.harris.com
X
X
X
X SUMMARY
X =======
X This directory contains a subset of a utility library that I have used
X (in various forms) for several years now. This particular version is
X rather sparse, being a relatively recent reimplementation.
X
X [ The rest of the utility library has been left out, to reduce the
X size of Parseargs. The complete set of utilities was pubbed in the
X first comp.sources.misc distribution. -- PDS ]
X
X I am making this available as a  result of the rather surprising
X response to my C  Advisor column in UNIX Review Vol. 7 No. 11 on
X argument parsing, in which I  described an alternative to getopt.
X Several dozen people have asked for the source code -- an amazing
X number, considering that in the four years prior to this column, I
X have gotten perhaps six letters in total.
X
X
X COPY/REUSE POLICY
X =================
X Permission is hereby granted to freely copy and redistribute this
X software, provided that the author is clearly credited in all copies
X and derivations. Neither the name of the author nor that of the
X University may be used to endorse or promote products derived from
X this software without specific written permission. This software is
X provided ``As Is'' and without any express or implied warranties.
X
X
X CONTENTS
X ========
X See the file "MANIFEST" in the distribution for a complete list and
X description of all the files included in this release.
X
X TO DO
X =====
X The parseargs routines really ought to have a way of matching a  list
X (e.g., return the rest of argv). This isn't especially hard to do, but
X I haven't gotten around to it yet. [ Added, with ARGLIST flag -- PDS ]
X
X [ Added argUsage and argDummy pseudo-argument types -- BDA ]
X [ Added arg{S,T,U}Bool boolean argument types -- BDA ]
X [ Added ARGNOVAL argument flag to implement trigger types -- BDA ]
X [ Added ARGVALOPT, ARGVALREQ, and ARGVALGIVEN argument flags to
X   implement options with optional arguments -- BDA ]
X [ Added ARGPOS argument flag to implement arguments that may be
X    matched both positonally and by keyword -- BDA ]
X [ Added ARGVEC for argc/argv structures and implemented them for
X   string, character, floating point, and integer types -- BDA ]
X [ Added fparseargs(3), sparseargs(3), vparseargs(3), lparseargs(3),
X   and parsecntl(3) functions for flexibility and robustness -- BDA ]
X
X
X DISCLAIMERS
X ===========
X I hacked this code up to (hopefully) work on ANSI C  compilers, since
X several readers seem to be interested in this sort of thing. I can't
X claim to have really tested this.
X [ Now compiles under both BSD & AT&T Unix Systems using both ANSI and
X   non-ANSI C compilers -- BDA ]
X [ non-ANSI C compilers that have <stdlib.h> need to explicitly #include
X   <stdlib.h> in useful.h -- BDA ]
X
X The original version was tested under SunOS 4.0 on SPARC
X architectures. The version you see has been loosely tested on a Mips
X M/2000 running RISC/os 4.01; I  have only tried it in the BSD
X environment, and that only loosely.
X
X ACKNOWLEDGEMENTS
X ================
X I wrote the first version of this code while working at the
X International Computer Science Institute in Berkeley, CA.
X
X ______________________________________________________________________________
X
X      Update to parseargs by Peter da Silva (peter@ferranti.com):
X
X (2nd update: more improvements to arg parsing, argChar type)
X (3rd update: return to original calling sequence, argList type)
X (4th update: removed routines not relevant to parseargs,
X              removed tracing/interactive stuff.)
X
X
X Parseargs is a really nifty set of routines, but it doesn't fit too
X well with standard UNIX semantics. In particular, you can get into a
X lot of trouble using it in a script if it drops into interactive mode
X on you. Also, it's not as useful as it could be for non-UNIX systems.
X To make it work better, I've made a couple of changes.
X
X It compiled straight out of the box on System III once I'd provided
X bcopy, bcmp, and strtol. The strtol I've provided is almost totally
X untested, but hopefully you won't need to use it. It's only for folks
X with old UNIX systems.
X
X First change was to disable the interactive prompting for arguments. I
X think that's inconsistent with usual UNIX semantics.
X
X The second change was to allow for a trailing list of arguments. I
X originally implemented this by changing the calling sequence to
X parseargs. On reflection this would just produce incompatibilities, so
X I added a  new flag, ARGLIST, and a new type, listStr. Later, other
X kinds of lists can presumably be added. A list handles a pointer to a
X list of objects:
X
X     struct arglist *fred;
X
X Operations are defined on arglists, L_NEXT(fred) produces the next
X element in fred. L_STRING(fred) produces the value of fred cast to
X "char *".
X
X During evaluation the list is kept in LIFO order, and it's reversed
X just before returning to parseargs. This simplifies the coding of the
X list routines, but still lets you step through the list in a
X reasonable order. [ lists are now maintained in FIFO order --BDA ]
X
X The final change is the addition of a  'argChar' type. This parses
X character arguments (such as the '-T' option to 'awk'), accepting
X single characters,
X
X Parseargs itself no longer uses ckalloc, traceset, funclist, and so
X on. these routines are pretty cool, but when you're grafting parseargs
X onto an existing program they just get in the way. Also, it's possible
X to make parseargs fail in a cleaner fashion by handling out-of-memory
X cases myself. Certainly there's not going to be any loose memory lying
X around to be collected when parseargs starts up!
X
X Also, the error messages have been made a  bit more descriptive.
X Instead of saying "stest: value required for -c flag", it prints
X "stest: RepCount required for -c flag". The ad_prompt element should
X really be a descriptive word that can be used in a sentence... or for
X non_UNIX systems a multi-character or keyword based flag. I have an
X Amiga version included, for example, that uses keyword syntax. In that
X version, the usage message reads:
X
X     Usage: amiga_test <name> [GROUP <newsgroup>]... [REP <repcount>] +
X             [DIR <dirname>] [X] [Y] [Z] [TAB <tabchar>] [<file>]...
X
X Instead of:
X
X     Usage: unix_test <Name> [-n <newsGROUP>]... [-c <REPcount>] [-d <DIRname>] [-x] [-y] [-z] [-t <TABchar>] [<File>]...
X
X
X This would solve the old problem of UNIX programs sticking out like a
X sore thumb in other operating systems.
X
X The Amiga version still needs to prompt for options if called with a
X single types and finally integrate CLI and Workbench environments.
X
X Latest update: the prompt string may include a more extensive comment
X (in parentheses, after the one-word initial comment), that will be
X used in error messages and listed in the usage message.
X
X [ comment may appear in square brackets, curly braces, angle brackets,
X   or parentheses (so one can use the other 3 in the comment) -- BDA ]
X
X The environment variable USAGE controls the printing of the usage
X message:
X
X     USAGE == -1 No usage message.
X     USAGE == 0 Short message (default).
X     USAGE == 1 Names of flags given in parentheses.
X     USAGE == 2 Long description of options given.
X     USAGE == 3 Both flag names and long description given.
X
X Examples:
X
X     $ USAGE=3; export USAGE
X     $ unix_test -c
X     unix_test: REPcount (number of times to repeat each group) required for -c flag
X     unix_test: Name required
X     Usage: unix_test <Name> [-n <newsGROUP>]... [-c <REPcount>] [-d <DIRname>] [-x] (Xflag) [-y] (Yflag) [-z] (Zflag) [-t <TABchar>] [<File>]...
X     Options:
X             -n newsGROUP newsgroups to test
X             -c REPcount number of times to repeat each group
X             -x (Xflag) expand in X direction
X             -y (Yflag) expand in Y direction
X             -z (Zflag) expand in Z direction
X     $ USAGE=0; export USAGE
X     $ unix_test
X     unix_test: Name required
X     Usage: unix_test <Name> [-n <newsGROUP>]... [-c <REPcount>] [-d <DIRname>] [-x] [-y] [-z] [-t <TABchar>] [<File>]...
X     $ USAGE=-1; export USAGE
X     $ unix_test
X     unix_test: Name required
X
X
X [ changed to use the environment variable USAGECNTL instead of USAGE.
X   "USAGE" is a variable name commonly used in shell scripts. --BDA ]
X
X [ when keywords are desired (via USAGECNTL) their actual command-line
X   syntax is now displayed (instead of just appearing in parentheses)
X   -- BDA ]
X
X ______________________________________________________________________________
X
X
X             Update to parseargs (and major re-write) by Brad Appleton
X                        (brad@ssd.csd.harris.com)
X                              Last Update: 08/15/91
X 
X
X THIS RELEASE
X ============
X Read the file patchlevel.h in the distribution to find out what version
X and patchlevel of parseargs you have received.
X
X
X DISCLAIMER
X ==========
X Neither Brad Appleton, nor Harris Corporation (including any of its
X subsidiaries and subdivisions and Harris Computer Systems Division in
X particular) are responsible for maintaining and supporting this
X software or for any consequences resulting from the use of this
X software, no matter how awful, even if they arise from flaws in the
X software.
X
X
X NEW FILES: parseargs.c, xparse.c, pgopen.[ch], vprintf.c
X ========================================================
X I thought parseargs was so cool that I wanted to be able to use it for
X shell-scripts too! To do that I would need a command-line interface.
X I decided to make the command-line interface look as close as possible
X to the C-interface so I  basically implemented a  very small
X interpreter; Hence, parseargs.c was resurrected but this time as an
X interface to the parseargs library instead of being the guts of it.
X
X Xparse.c implements routines to parse arguments from a   file
X (fparseargs), from an arglist (lparseargs), from a  string
X (sparseargs), from a variable argument-list (vparseargs), and from a
X string-vector (parseargs). It also contains the routine parsecntl()
X which controls the parsing behavior of a  commands, and the routine
X usage() which prints a usage message. Each of the <os>_args.c files
X used to implement its own parseargs() and usage() functions, this has
X been changed so that parseargs() and usage() are implemented in
X xparse.c and the guts of the os-specific parsing and formatting is
X implemented in the routines <os>_parse() and <os>_usage() in the file
X <os>_args.c!
X
X On Unix systems, if the user desires, usage messages are paged using
X popen(3S). The pager used is ${USAGE_PAGER:-${PAGER:-/usr/ucb/more}}.
X If for some reason this fails then no paging is performed. The pager
X library is implemented in the file pgopen.c and only used if the macro
X USE_PAGER is #defined. Pgopen.h is an include file which will include
X the external declarations for pgopen.c if USE_PAGER is #defined and
X defines some functionally equivalent (but non-paging) macros instead.
X
X The file vprintf.c is a  portable implementation of vprintf(),
X vfprintf(), and vsprintf() for systems (such as BSD Unix) that don't
X already have them.
X
X
X NEW ARGUMENT TYPES: argUsage, arg[UTS]Bool, & argDummy
X ======================================================
X I added the following argument types to parseargs:
X
X    argUsage -- print a usage message
X    argDummy -- dummy argument, not parsed but used for messages
X    argSBool -- set a boolean flag
X    argTBool -- toggle a boolean flag
X    argUBool -- unset a boolean flag
X
X Consult the manual page for argtype(3) for more information.
X I also added the capability to handle ARGVEC arguments into the
X remaining argument type functions.
X
X
X NEW ARGUMENT FLAGS:
X ===================
X I added the following argument flags to parseargs:
X
X     ARGPOS -- arg is positionally matched and keyword matched
X     ARGNOVAL -- arg takes no value
X     ARGVALOPT -- arg takes an optional value
X     ARGVALREQ -- arg requires a value
X     ARGGIVEN -- arg was supplied on command-line
X     ARGVALGIVEN -- arg-value was supplied on command-line
X     ARGDESCRIBED -- argument was given a description
X     ARGKEYWORD -- argument was matched as a keyword
X     ARGVALSEP -- arg-value was in a separate token from the argument
X
X Consult the manual page for parseargs(1) & parseargs(3) for more information.
X
X
X NEW INTERFACE
X =============
X I added a set of Macros to allow a more "self documenting" approach to
X declaring argument-descriptor arrays. The "old-style" is still
X accepted (but if used it is recommended that the STARTOFARGS macro is
X used in conjunction with ENDOFARGS). The new style is documented in the
X parseargs(3) manual under the heading "CMD MACROS"
X
X
X MODIFICATIONS TO USAGE MESSAGES
X ===============================
X After Peter modified usage() to look at the USAGE environment
X variable, I decided that, even if the user had turned USAGE off, that
X (s)he really did want the usage if an argUsage option was specified so
X I added a  static global Usage_Requested to xparse.c to over-ride
X the USAGE variable (if necessary) so that a verbose message is always
X given when an argUsage option is specified (regardless of the value in
X the environment variable).
X
X I also changed the name of the environment variable that gets "looked"
X up to be USAGECNTL instead of USAGE since USAGE is a common variable
X name for shell scripts. Furthermore, I changed the contents of USAGECNTL
X from a number to a sequence of mnemonic strings (for better readability).
X I also made USAGECNTL control whether or not a command-description is
X printed and whether or not the message is piped to a pager on Unix.
X
X Under VMS, the global symbol USAGECNTL is used in lieu of an environment
X variable.  See the parseargs(3) and parseargs(1) manual pages for more
X information regarding USAGECNTL.
X
X
X SPECIFYING ALTERNATE PARSING BEHAVIOR
X =====================================
X Parseargs provides 3 methods for controlling "how" the command-line is
X parsed. There is a parsecntl() function which may be used to specify
X flags other than the default parse-behavior. The user may define the
X environment variable (or global symbol) PARSECNTL to contain the option-
X string that corresponds to the desired combination of pa_XXXX flags
X #defined in parseargs.h. The parseargs command, also allows for options
X to specify certain parsing behavior. The parsecntl() function provides
X finer control than either of the other two methods. The user's PARSECNTL
X variable will always over-ride any conflicting flags that were set by
X parsecntl() or by the parseargs command via command-line options.
X See the manual pages for parseargs(1), parseargs(3), and parsecntl(3)
X for more information.
X
X
X GIVING DEFAULT ARGUMENTS
X ========================
X Programs that use parseargs may be given default arguments under UNIX
X and PCs through the use of environment variables (symbols are used for
X VMS systems). If a C-program or a shell-script uses parseargs to imple-
X -ment a command named "foo" then the environment variable (or global
X symbol) FOO_ARGS will be parsed for any "default" arguments before argv
X is parsed.  Argv will over-ride any options that are specified in
X FOO_ARGS (except that ARGLISTs and ARGVECs set in FOO_ARGS will be
X appended from argv[]).
X
X
X SPECIFYING DEFAULT ARGDESCs TO SEARCH
X =====================================
X If a given option/qualifier does not appear to match any items in the
X argdesc-array, a  default argdesc-array is then searched to match the
X option. If it is STILL unmatched then it is flagged as such. The
X default-argdesc array is automatically used by all programmer-defined
X argdesc-array but may be unset or reset using the pc_DEFARGS function
X of parsecntl(3).
X
X
X ADDING NEW SHELLS TO parseargs(1)
X =================================
X I did my best to implement parseargs.c in a manner that would make it
X relatively easy to add new shell-types. At this point in time, parseargs
X will generate output for the following command-interpreters:
X
X     sh               (Bourne Shell)
X     csh/tcsh/itcsh   (C-Shell)
X     bash             (Bourne-Again Shell)
X     ksh              (Korn Shell)
X     rc               (Plan 9 Shell)
X     zsh              (Z shell)
X     perl
X     tcl
X     ash
X     awk
X
X Parseargs.c thinks the Free Software Foundation's Bourne-Again Shell
X (bash) is equivalent to the Bourne shell (sh). Bash is a superset of
X sh (so I am told) but I do not know enough about it to treat it
X differently. I  hope someone who is familiar with bash syntax will
X correct this deficiency (particularly with shell arrays).
X
X If someone wants to try to add more shell-types to parseargs.c, here
X are the main things that need to be done:
X
X 1. add an entry for the shell type into the type definition for the
X    "shell_t" enumerated type.
X
X 2. add a shell_info entry for the shell into the array Shell[].
X
X 3. print_args doesnt really do any shell specific stuff outside of
X    indexing into the table. The print_arglist() function does some
X    shell specific stuff and MAY need a case added to the switch statement(s)
X    for the newly added shell.
X
X 4. If the information in the shell-info structure is not sufficient
X    for the new shell then you should either:
X       a) redefine the structure for all shells including your shell.
X       b) add some special code into print_args() for your shell!
X
X For a more thorough discussion of parseargs(1), consult the manual pages!
X
X
X MODIFICATIONS TO KEYWORD MATCHING
X =================================
X I changed keyword matching in strfuncs.c just a tad by allowing only a
X partial match on the keyword (instead of a full match), this way the
X user only needs to give enough of the keyword on the command line so
X that it will uniquely match a  suffix of a  keyword in the arg-
X descriptor table. A drawback to this is that if the user does NOT
X specify enough of the keyword to uniquely match ONE arg-desc entry,
X then the first such entry encountered will be considered to match the
X partial keyword on the command-line.
X
X This "shortest-prefix" matching is performed 1st on only the uppercase
X characters in the ad_prompt, and then (if no match) on the whole
X prompt. This is "nice" in that the user only needs to specify the
X shortest prefix but it also means that a typo can very easily be
X interpreted as an option when it shouldnt be (both "+new" and "+gr"
X would match "newsGROUPS") or the wrong option may be matched if too
X small a portion of the keyword is provided.
X
X To help prevent this type of thing... Unless the keyword to be matched
X has length < 2, I force the user to specify at least 2 characters for
X the keyword (for VAX/VMS this minimum length becomes 4 iff the keyword
X starts with "NO").
X
X amiga_args.c still uses the old keyword matching function. Since
X AmigaDOS keywords have no '/' or '-' prefix -- I thought it would be
X too dangerous to allow such "partial matching" because it would be too
X easy for bona-fide arguments to partially match a keyword!
X
X
X MODIFICATIONS TO CHARACTER ARGTYPES
X ===================================
X Under UNIX, an argChar option argument may now be provided on the
X command-line immediately following the option-letter and the
X characters following the character argument are still processed as
X options. Hence, if '-c' is an argChar option and '-x', '-y', and '-z'
X are boolean options, then we may specify the character '_' as an
X argument to '-c' as well as specifying the '-x', '-y' and '-z' flags
X in the following manner:
X
X     -c_xyz
X
X Of course, the following will have the same effect:
X
X     -c_ -xyz
X
X as will this:
X
X     -c _ -xyz
X
X but the following is incorrect:
X
X     -c _xyz
X
X In other words, only the character that immediately follows an argChar
X option is considered to be an argument to the option and other option
X characters may immediately precede the single-character argument.
X
X
X MODIFICATIONS TO BOOLEAN ARGTYPES
X =================================
X Boolean types may now take an argument if so desired. under VAX/VMS:
X
X     "/FLAG" (1)
X
X will turn ON an an argBool or argSBool flag, will turn OFF an argUBool
X flag, and will toggle an argTBool flag. However, the following:
X
X     "/FLAG=ON" (2)
X
X will turn ON the flag regardless of whether it is argBool, argSBool,
X argUBool, or argTBool (so long as it is one of them). Similarly,
X
X     "/FLAG=OFF" (3)
X
X will always turn a boolean flag OFF!
X
X Similar syntax is used for AmigaDOS, the corresponding Amiga
X specification for examples (1)-(3) above would be:
X
X     FLAG (1)
X     FLAG=ON (2)
X     FLAG=OFF (3)
X
X For the Amiga, the boolean argument MUST be part of the same argv[]
X element as the keyword itself ("FLAG ON" or "FLAG OFF" is not
X acceptable).
X
X For Unix (and IBM-PCs), long option examples of (1)-(3) would be the
X following:
X
X     +flag (1)
X     +flag=on (2)
X     +flag=off (3)
X
X As with the Amiga, the boolean argument ("on" or "off") MUST be part
X of the same argv[] element as the long-option itself.
X
X For single character options under Unix, the corresponding examples
X for (1)-(3) are as follows:
X
X     -f (1)
X     -f+ (2)
X     -f- (3)
X
X As with Unix, the boolean argument ("on" or "off") MUST be part of the
X same argv[] element as the long-option itself.
X
X For single character options under MS-DOS and OS/2, the corresponding
X examples for (1)-(3) are as follows:
X
X     /f (1)
X     /f+ (2)
X     /f- (3)
X
X With single character options, any boolean argument must be a  single
X character and must be in the character immediately following the the
X option character. If the character following the option character is
X NOT one of '-', '+', '0', ment) then the default action will be taken
X (set, clear or toggle depending upon the type of boolean flag) and the
X character immediately following the boolean option is assumed to be
X another option-specification (e.g. -fc4 and -f+c4 are both allowed
X where 'f' is a boolean flag and 'c' is an integer (argInt) flag).
X
X With all supported operating systems, the following arguments may be
X used as Boolean arguments (differences between uppercase/lowercase are
X ignored):
X
X      Arg        Effect
X     =====  ====================
X       ^    Toggles flag (single character options only)
X       ~    Toggles flag (single character options only)
X       1    Sets flag
X       0    Unsets flag
X       +    Sets flag
X       -    Unsets flag
X       T    Sets flag
X       F    Unsets flag
X      YES   Sets flag
X       NO   Unsets flag
X       ON   Sets flag
X      OFF   Unsets flag
X     TRUE   Sets flag
X    FALSE   Unsets flag
X
X With single character options under Unix and IBM-PCs, only '+', '-',
X '0', '1', '^' and '~' may be used.
X
X
X CHANGES TO ARGTYPE RETURN VALUES
X ================================
X In order to allow only a single character to be consumed for arguments
X to boolean and character options, I  had to change the way return
X values from an argtype function were handled. Previously, the argtype
X function merely returned TRUE (1) upon success and FALSE (0) upon
X failure. I changed this slightly. Now, an argument type function
X returns:
X
X     FALSE (0) if the argument was NOT successfully interpreted
X
X     TRUE (1) if the argument was successfully interpreted and ALL
X             characters of the argument were used.
X
X     -N (<0) if the argument was successfully interpreted AND only
X             the first N characters of the argument were used.
X
X At this time, only the Boolean and argChar argument type functions
X return any value other than TRUE or FALSE.
X
X
X NEW ARGUMENT LISTS
X ==================
X Arglists have been enhanced with a new type called arg-vectors (and
X use the ARGVEC flag instead of the ARGLIST flag). Arg-vectors are a
X structure containing an argv/argc pair. There are two macros in
X parseargs.h which are used for arg-vectors. ARGVEC_T may be used to
X declare a vector structure or a vector type; ARGVEC_EMPTY may be used
X to initialize the structure. It is strongly recommended that ARGVEC_T
X be used to declare vector types in a typedef statement (particularly
X if one is using function prototypes) but for those who insist, it may
X be used to directly declare a  structure. An example of both uses (as
X well as an example use of ArgLists) may be found in the documentation.
X
X
X MISCELLANEOUS FIXES/ENHANCEMENTS
X ================================
X unix_args.c did not consider '-' or '+' to be valid arguments unless
X '--' had already been specified. This has been fixed.
X
X The compile-time interactive option seemed to have been removed from
X parseargs so I put it back in and made it a run-time option (that is
X selected using the pa_PROMPT function-code to parsecntl()). I  also
X made it prompt repeatedly for arglists (a blank line ends the list).
X No characters are escaped or trimmed (such as whitespace, quotes, or
X special characters) when a prompted argument is read from the user!
X
X amiga_args.c will now check to see if an argument matches a  keyword
X before assigning it as a keyword argument. If 'STRING' is an argStr
X and 'REP' is an argInt then: "cmd STRING REP=4" will leave string
X without a  value and assign REP to be 4. Previously, this would have
X resulted in assigning the value of optional keyword arguments.
X
X Arglists are no longer stored in LIFO order and then reversed at the
X last minute, they are now always stored in FIFO order (the order given
X on the command-line).
X
X I also provided extensive updating to the manual pages so that they
X now reflect the current capabilities of parseargs!
X
X Since the FSF has decided to change the use of '+' as a long-option prefix
X to '--' (in order to be POSIX conformant), I added some #ifdef POSIX_SOURCE
X code to unix_args.c to use '--' instead of '+' as the long option prefix.
X
X MODIFICATIONS TO parseargs.h
X ============================
X I hacked parseargs.h up a bit so that certain items may be excluded or
X included by #defining certain names before including the file.
X
X If PARSEARGS_PRIVATE is #defined, then various type and macro
X definitions which are specific to the implementation of parseargs (but
X not to its use) are included. This is my hack at C++ friend functions;
X A file declares itself to be a  "friend" by #defining PARSEARGS_PRIVATE
X before #including the file parseargs.h
X
X If PARSEARGS_NEXTERNS is #defined, then the external function declarations
X for the various parseargs functions (parseargs, parsecntl, fparseargs,
X etc ...) are NOT included. This is really only useful to the files that
X actually implement the various parseargs functions.
X
X If PARSEARGS_NARGTYPES is #defined, then the external function
X declarations for the various argtype functions (argInt, argStr,
X listStr, etc ..) are NOT included. This is really only useful to the
X files that actually implement the various argtype functions.
X
X Also, ARGDESC is now a typedef instead of a #define. On the same note,
X arglists may be declared by using the "ArgList" typedef or by using
X the "struct arglist" structure declaration.
X
X
X MODIFICATIONS TO THE ARGDESC ARRAY
X ==================================
X Before I got my hands on it - parseargs had no parsecntl() or means of
X parsing arguments from a file or a string. Any and all arguments to be
X parsed would be handled in a single invocation of parseargs. In order
X to allow arguments to be parsed using multiple passes (which would be
X required if we were to parse arguments in a file for example) I  added
X the notion of parse-flags to modify parsing behavior. Because of this,
X I also required certain local variables to now be static. In order to
X allow parsing for multiple commands - I put the parse-flags and the
X static variables into the argument descriptor array itself. This way -
X each arg-descriptor has its own set of flags and state variables to
X record its own context.
X
X To implement this without changing the existing syntax, I put all this
X stuff into the FIRST & LAST argument descriptors in the array. If an
X argdesc-array is declared using the CMD_XXXXX macros, then this is
X already taken care of. If an argdesc array is used using the old-style
X syntax, ENDOFARGS will now define two arg-descs at the end of the
X array. Parseargs needs to recognize the old syntax and shift each
X element in the array down by one position (creating room for a new one
X at the top). I would have preferred to just swap the first and last
X entries in this case but I have to preserve the original order of any
X positionally-matched parameters! This means that extra pre-processing
X (to shift the array) needs to be performed for argdesc-arrays that are
X declared using the old syntax! To avoid this overhead - users of the
X old syntax could use the pre#defined macro STARTOFARGS and make it the
X first entry in the argdesc-array.
X
X Also, each arg-descriptor is now precompiled so that the argument
X prompt and the argument description are stored in two separate strings
X (the first of which is pointed to by the "ad_prompt" field). This
X avoids the need to constantly write code to "locate" the description
X every time it is desired by the programmer.
X
X In order to ease the use of the various attributes of arg-descriptors,
X (including the argument-prompt and the argument description) a set of
X macros is available for extracting the corresponding attributes of a
X command, or one of its argument entries.  Public macros are documented
X in the manual pages, private ones are listed here:
X
X     cmd_name(Args) -- the given command-name
X     cmd_flags(Args) -- the command parse flags
X     cmd_context(Args) -- pointer to the command-context
X                          (which is stored in the last argument-descriptor)
X     cmd_state(Args) -- the command-state flags
X     cmd_list(Args) -- pointer to currently active arg-list
X     cmd_prev(Args) -- pointer to previously matched arg (Amiga only)
X     cmd_defargs(Args) -- pointer to default argdesc for this command
X     cmd_argv0(Args) -- pointer to argv[0] from command-line
X     cmd_purpose(Args) -- one-line description of command
X     cmd_description(Args) -- multi-line description of command
X
X The cmd_xxx macros are included only if PARSEARGS_PRIVATE is #defined.
X
X Similarly, there are also some macros (some public, some private) to
X query certain attributes of an argument descriptor (or assist in its
X manipulation). The public macros are documented in the manual pages,
X private ones are listed here:
X
X     ARG_isBOOLEAN(ad) -- is this arg an argBool, or an arg[STU]Bool type?
X     ARG_isPSEUDOARG(ad) -- is this arg an argDummy or an argUsage type?
X     ARG_FIRST(argd) -- return the first argument-entry
X     ARG_LAST(argd) -- return the first last-entry
X     ARG_isEND(ad) -- are we at the end of the argument list?
X     ARG_ADVANCE(ad) -- return the next argument entry.
X     ARG_RETREAT(ad) -- return the previous argument entry.
X
X
X These last five macros are for traversing all the entries in the
X argument descriptor array that correspond to actual command-line
X arguments (i.e. the 2nd thru 2nd-to-last entries in the array):
X
X     for ( ad = ARG_FIRST(argd) ; !ARG_isEND(ad) ; ARG_ADVANCE(ad) )  ...
X or
X     for ( ad = ARG_LAST(argd) ; !ARG_isEND(ad) ; ARG_RETREAT(ad) )  ...
X
X
X OPERATING SYSTEM DEPENDENCIES
X =============================
X I also added "-D${os}_style" to the CFLAGS macro used in the Makefile.
X It is used to conditionally include OS dependent code in the parseargs
X files. I tried to keep "#ifdef <os>_style" sections of code to a
X minimum.
X
X I tried to make a distinction between portions of the code that depend
X upon the underlying OS and portions of the code that depend on the
X desired argument parsing style so that - in theory - one could compile
X for any of the existing styles on any of the supported systems. Thus,
X just because "unix_style" is #defined does not necessarily imply that
X the underlying OS is unix. This would only be implied if "unix" was
X #defined.
X
X It is assumed that the following constants are #defined for the
X following operating systems:
X
X        NAME                        OS
X    ------------------   ------------------------
X     unix                Unix (BSD or AT&T)
X     BSD, SYSV           BSD Unix or AT&T Unix (only one should be present)
X     MANX, AZTEC         AmigaDOS
X     MSDOS               MS-DOS for IBM PCs
X     OS2                 OS/2 for IBM PCs
X     vms                 VAX/VMS
X
X As of this writing, as long as the above constants are defined for the
X corresponding OS, parseargs compiles without errors on both BSD and
X AT&T Unix Systems using both ANSI and non-ANSI C Compilers.
X
X NOTE: If you are using the curses library with parseargs and your system's
X       <curses.h> #defined VOID (as it does for the Sun), then you will
X       need to #undef VOID after including <parseargs.h> but before
X       including <curses.h> (or vice-versa).
X
X       Also - if your compiler is NOT an ANSI compiler but does have the
X       #include file named <stdlib.h> then you will need to modify the 
X       file useful.h to explicitly include <stdlib.h>.
X
X
X COMPILE-TIME CONSTANTS
X ======================
X If any of the following macros are #defined at compile time then they will
X have the following effect:
X
X    USE_PAGER    --  For Unix systems only. Parseargs will include the code
X                     which pipes usage messages to a paging program
X
X    NOFLOAT      --  Parseargs will NOT include the code for the predefined
X                     floating point arg-types argFloat() and argDouble().
X
X    SVR4         --  Parseargs(1) with the -M option will generate the new
X                     Style Unix manual template.
X
X    USE_CURSES
X    USE_TERMINFO
X    USE_TERMCAP  --  Parseargs will use curses/terminfo/termcap when trying
X                     to figure out the size of the screen.
X
X    POSIX_SOURCE --  For unix_style only. Parseargs will use '--' instead of
X                     '+' as the long-option prefix.
X
X IBM-PC VERSION OF parseargs(3)
X ==============================
X I also added ibm_args.c for MS-DOS and OS/2.
X
X IBM_ARGS.C HAS NOT BEEN TESTED ON AN IBM-PC! I did not have one to
X test it on.
X
X The ibm-pc version is VERY similar to the unix version. The difference
X is that ibm_args.c will look in $SWITCHAR for the option character(s)
X to use. If the option character is '-', it behaves just like
X unix_args.c, if the option character is something else or $SWITCHAR is
X undefined then it behaves more like normal MS-DOS stuff. The main
X difference is that if the ibm-pc version is NOT emulating unix, than
X all option arguments MUST be in the same argument as the option itself
X and they must be separated by an '=' character (so "/S=str" is fine
X but "/Sstr" and "/S str" are not).
X
X By default, if SWITCHAR is undefined then both the long and short
X option prefix character are '/'. One is able to distinguish an option
X from a long-option in this case because the third character of an
X option-arg will always be '=' or '\0'. Hence, using the test program
X with the defaults, both "ibm_test foo /D=directory" and "ibm_test
X /DIR=directory" are equivalent.
X
X
X VAX/VMS VERSION OF parseargs(3)
X ===============================
X I also added vms_args.c for VAX/VMS.
X
X vms_args.c has been tested by people (other than myself) on a VAX/VMS
X system and seems to work okay. It does not use the CLI$XXXXX routines
X for parsing. It should accept command-line arguments as described in
X the "Grammar Rules" section of the VAX manual with one slight exception
X which is noted below.
X
X ARGLIST and ARGVEC are comma-separated lists in the VMS version of
X parseargs (not whitespace separated lists). In order to preserve a
X one-to-one mapping between UNIX & AmigaDOS whitespace separated lists
X with VMS comma-separated lists, a  VMS ARGLIST or ARGVEC that
X corresponds to a positional parameter may use both commas and white-
X space to separate its arguments. This avoids having VMS command lines
X like the following:
X
X     cmdname file1,file2,file3 directory1,directory2
X
X for which there exists no corresponding command-line for UNIX or or
X AmigaDOS programs without changing the standard command-line syntax
X for these systems.
X
X In addition to a help option in the default argument descriptor, The
X VMS version of parseargs(3) also has /OUTPUT, /INPUT, and /ERROR
X qualifiers in the standard default argument-descriptor array. These
X all serve to redirect stdin, stdout, or stderr to or from a file (many
X thanks to posters from comp.os.vms for giving me a clue on how to do
X this). As a result of this, under VAX/VMS, there are two new argtype
X functions "argInput" and "argOutput": each requires that ad->ad_valp
X be a pointer to a file pointer (not a FILE * variable as in "__ stdin"
X but an actual FILE ** variable as in "__ &stdin"). ArgInput & argOutput
X close the stream associated with the given file-pointer and reconnect
X the stream to the named file for input or output (so the effect is to
X redirect input (output) from (to) the stream to the named file. If
X redirection fails, the original stream remains closed (sorry -- its a
X side-effect of freopen()).
X
X One can implement a "negatable" vms qualifier by using two entries in
X the argument descriptor table as follows:
X
X     'F', ARGOPT, argSBool, __ &myflag, "FLAG {set flag}",
X     'f', ARGOPT, argUBool, __ &myflag, "NOFLAG {unset flag}",
X
X so that /FLAG will turn the flag on (via argBool or argSBool) and
X /NOFLAG will turn it off (via argUBool).
X
X I did not know what to do (if anything) to add the VAX/VMS shell (DCL)
X into the parseargs command-line interface (parseargs(1)) so it is not
X currently implemented. I  will leave the task of configuring
X parseargs(1) for DCL programmers to some other brave soul who knows
X more than I about DCL! I was thinking that for DCL, the parseargs
X command could directly set the value of a symbol (with the proper
X scope of course) at execution time instead of printing something on
X stdout that would be evaluated later (as the UNIX version does).
X
X Anyone who uses VAX/VMS is strongly encouraged to test vms_args.c on
X their system (and make changes if need be) and to modify the usage and
X parsing functions accordingly!!! It would probably be a good idea to
X use some builtin VMS system call to replace the method used for
X finding the basename of a file (basename() in strfuncs.c) when "#ifdef
X vms" is true. There are also some command-line parsing routines
X available through DCL that could replace a  lot of the guts of
X vms_args.c as well.
X
X
X TO DO
X =====
X - get parseargs(1) to work for DCL under VMS using symbols
X - add ash to the list of shells supported by parseargs(1)
X - add clam to the list of shells supported by parseargs(1)
X - get parseargs(1) to support arrays for bash
X - verify that parseargs(1) works for rc, the Plan 9 shell
X - verify that parseargs(1) works for zsh
X - verify that parseargs(3) works on MS-DOS and OS/2 systems.
X
X
X LITERATE PROGRAMMING
X ====================
X If you look at the source code you will notice that it contains lots
X of funny looking comments with sections that have titles enclosed
X between '^' and ':' characters. This is my own feeble attempt at
X literate programming. I have a Korn shell script (xdoc) which will
X extract certain portions of these "structured" comments so that I may
X dump them directly into the documentation (and thus attempt to keep
X the documentation up-to-date at the same rate as the source). If anyone
X is interested in my script(s) please let me know and I will gladly
X e-mail them to the interested parties.
X
X
X ACKNOWLEDGEMENTS
X ================
X I was in constant contact with Peter Da Silva during the entire period
X that I  implemented all of the above modifications and would like to
X thank him for his time and his sage advice. Many of the ideas which I 
X implemented are a direct result of our discussions.
X
X Thanx also to Jim Barbour for helping me with some VMS specific things
X (like getting the original, unparsed command-line from DCL and
X retrieving the value of a symbol), and to Tom Christiansen and Raymond
X Chen for their help in getting parseargs(1) to work for perl scripts.
X
X Thanx also to Gillmer J. Derge, Marco Nijdam, Chris Johnston, Earl Chew
X and Mike Levin for sending me their bug reports and fixes so that I could
X incorporate them into the latest patch of parseargs.
X
X Lastly, thanks to all those who use and will continue to improve
X Parseargs.  Unfortunately - with the release of Patchlevel 11, I
X will no longer have the time (or inclination) to continue to support
X Parseargs.  If anyone out there wishes to take over the job for me,
X please let me know and I will give you some extra "goodies" that I
X use for maintenance that are not part of the regular Parseargs 
X distribution.
X
X PS - C++ user's be on the lookout for "CmdLine", a C++ re-write of
X      Parseargs (written by your's truly).
END_OF_FILE
if test 41528 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/argvalopt.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/argvalopt.inc'\"
else
echo shar: Extracting \"'doc/argvalopt.inc'\" \(1216 characters\)
sed "s/^X//" >'doc/argvalopt.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -p '[ \t]*' -s ARGVALOPT ../parseargs.c
X.\"----------------------------------------------------------------------------
X.SH OPTIONS WITH OPTIONAL ARGUMENTS
X.PP
XOptions that may take an optional argument need special consideration.
XThe shell programmer needs to know whether or not the option was given, and
X(if given) if it was accompanied by an argument. In order to accommodate this
Xneed, \fBparseargs\fP will set an additional shell variable for each argument
Xthat is given the \s-1ARGVALOPT\s+1 flag if it is supplied on the command line
X\fIregardless of whether or not it was accompanied by its optional argument\fP.
XIf the user has defined an option which may optionally
Xtake an argument and the option appears on the command line
X\fIwith or without\fP its associated argument, then the shell variable
X\fI<name>\fP\f4_flag\fP will be assigned the value ``\f4TRUE\fP''
X(or the value supplied with the \fB\-T\fP option to \fBparseargs\fP) where
X\fI<name>\fP is the name of the shell variable associated with the option
Xin the argument description string.
END_OF_FILE
if test 1216 -ne `wc -c <'doc/argvalopt.inc'`; then
    echo shar: \"'doc/argvalopt.inc'\" unpacked with wrong size!
fi
# end of 'doc/argvalopt.inc'
fi
if test -f 'doc/caveats.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/caveats.inc'\"
else
echo shar: Extracting \"'doc/caveats.inc'\" \(1768 characters\)
sed "s/^X//" >'doc/caveats.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I CAVEATS ../xparse.c
X.\"----------------------------------------------------------------------------
X.SH CAVEATS
X.PP
XBecause of the way argument parsing is implemented under \s-1UNIX\s+1,
X\s-1MS-DOS\s+1, and \s-1OS/2\s+1,
Xoption arguments which contain a leading dash (`\-') (or whatever the
Xoption prefix character is defined to be) may \fInot\fP be specified
Xas a separate argument on the command line, it must be part of the
Xsame argument. That is to say that if a program has a \fB\-f\fP option
Xthat requires a string argument, then the following:
X.sp 4p
X.RS
X.ft 4
X\-f\-arg
X.ft R
X.RE
X.sp 4p
Xwill properly assign the string ``\fB\-arg\fP'' to the option whereas
Xthe following:
X.sp 4p
X.RS
X.ft 4
X\-f\0\-arg
X.RE
X.sp 4p
Xwill be interpreted by \fIparseargs\fP as two option strings: the first
Xof which (``\fB\-f\fP'') is missing a required argument and the second of
Xwhich (``\fB\-arg\fP'') will most likely be flagged as an invalid option.
X.PP
XSimilarly, if the user requires an \s-1\fIARGLIST\fP\s+1 option
Xto take multiple arguments with leading dashes then the following
Xmethod must be used: It is a ``feature'' of \fIparseargs\fP that
X\s-1\fIARGLIST\fP\s+1 arguments are always appended to the current
Xlist of arguments for the given option. Thus, if ``\fB\-f\fP'' is
Xan option taking a list of arguments, then the following are all
Xequivalent:
X.sp 8p
X.RS
X.ft 4
X\-farg1 arg2
X.sp 4p
X\-f arg1 arg2
X.sp 4p
X\-farg1 \-farg2
X.sp 4p
X\-f arg1 \-f arg2
X.ft R
X.RE
X.sp 8p
XHence multiple ``leading dash'' arguments may specified as follows:
X.sp 4p
X.RS
X.ft 4
X\-f\-dash_arg1 \-f\-dash_arg2  ...
X.ft R
X.RE
END_OF_FILE
if test 1768 -ne `wc -c <'doc/caveats.inc'`; then
    echo shar: \"'doc/caveats.inc'\" unpacked with wrong size!
fi
# end of 'doc/caveats.inc'
fi
if test -f 'doc/cmd_macros.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/cmd_macros.inc'\"
else
echo shar: Extracting \"'doc/cmd_macros.inc'\" \(1635 characters\)
sed "s/^X//" >'doc/cmd_macros.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -p '[ \t]*' -s CMD-MACROS ../parseargs.h
X.\"----------------------------------------------------------------------------
X.SH "CMD MACROS"
X\f4<parseargs.h>\fP defines a set of macros to allow a more "self documenting"
Xapproach to declaring argument-descriptor arrays. The "old-style" is
Xstill accepted (but if used it is recommended that the \s-1STARTOFARGS\s+1
Xmacro is used in conjunction with \s-1ENDOFARGS\s+1).
XAn example use of these macros (which, with one exception, all begin with
X``\s-1CMD\s+1'') follows:
X.RS
X.nf
X.ft 4
X#include <parseargs.h>
X
Xstatic BOOL bflag = FALSE;
Xstatic char *arg1 = CHARNULL;
Xstatic char *arg2 = CHARNULL;
X
Xstatic
X   CMD_OBJECT
X      MyCmd
X
X   CMD_NAME
X      "mycmd -- one line statement of purpose"
X
X   CMD_DESCRIPTION
X      "Mycmd will try really really hard to run without errors \\
Xand do whatever the heck it is supposed to do. If (God forbid) \\
Xsomething should actually go wrong it will say so."
X
X   CMD_ARGUMENTS
X      'H', ARGOPT, argUsage, __ NULL,
X      "Help -- display usage and quit",
X
X      'b', ARGOPT, argSBool, __ &bflag,
X      "bflag -- turn on `b'-mode (whatever that is)",
X
X      ' ', ARGREQ, argStr, __ &arg1,
X      "arg1 -- first argument to this spiffy program",
X
X      ' ', ARGOPT, argStr, __ &arg2,
X      "arg2 -- optional second argument to this spiffy program",
X
X      END_ARGUMENTS
X   CMD_END
X
Xmain( int argc, char *argv[] )
X{
X   (void) parseargs( argv, MyCmd );
X   (void) dostuff();
X   exit( 0 );
X}
X.ft R
X.fi
X.RE
END_OF_FILE
if test 1635 -ne `wc -c <'doc/cmd_macros.inc'`; then
    echo shar: \"'doc/cmd_macros.inc'\" unpacked with wrong size!
fi
# end of 'doc/cmd_macros.inc'
fi
if test -f 'doc/defargs.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/defargs.inc'\"
else
echo shar: Extracting \"'doc/defargs.inc'\" \(1117 characters\)
sed "s/^X//" >'doc/defargs.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -p '[ \t]*' -s DEFAULT-ARGUMENT ../xparse.c
X.\"----------------------------------------------------------------------------
X.SH "DEFAULT ARGUMENT DESCRIPTOR"
X.PP
XEach argdesc-array has an initial default argument list (which may be reset
Xusing the pc_DEFARGS function code with \fIparsecntl\fP). This initial
Xdefault argument-list contains `?' and `H' which may be used as single
Xcharacter keywords to display command-usage for all command-line styles.
XSimilarly, ``?'', ``H'', and ``Help'' may be used as long-keywords to display
Xcommand-usage for all command-line styles.  In Addition, for \s-1VMS\s+1
Xstyle commands, the qualifiers \fB\s-1/INPUT\s+1=\fIfile\fR,
X\fB\s-1/OUTPUT\s+1=\fIfile\fR, and \fB\s-1/ERROR\s+1=\fIfile\fR, may be used
Xto redirect \f4stdin\fP, \f4stdout\fP, and \f4stderr\fP (respectively) to a
Xfile.  For Amiga\s-1DOS\s+1 style commands, the keyword ``ENDKWDS'' may be
Xused to disable parsing for any more keywords on the command-line.
END_OF_FILE
if test 1117 -ne `wc -c <'doc/defargs.inc'`; then
    echo shar: \"'doc/defargs.inc'\" unpacked with wrong size!
fi
# end of 'doc/defargs.inc'
fi
if test -f 'doc/effects.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/effects.inc'\"
else
echo shar: Extracting \"'doc/effects.inc'\" \(1060 characters\)
sed "s/^X//" >'doc/effects.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I SIDE-EFFECTS  ../xparse.c
X.\"----------------------------------------------------------------------------
X.SH "SIDE EFFECTS"
X.PP
XEach of the functions in the \fIparseargs\fP library will set the external
Xcharacter string \fIProgName\fP to be the name of the last command that
Xwas operated upon by any of the library routines.
X.PP
XWhen an argument-descriptor array is first encountered by any of the
Xparseargs library routines, it is initially compiled into an intermediate
Xform that is more convenient to manipulate. As a direct result, it is not
Xadvisable to attempt to index directly into the array to manipulate one
Xof the argument descriptors (because the argdesc that you thought was there
Xmay actually be somewhere else). After the array has been given its initial
Xvalue(s), only \fIparsecntl\fP(3) should be used to manipulate or query the
Xattributes of an argument descriptor.
END_OF_FILE
if test 1060 -ne `wc -c <'doc/effects.inc'`; then
    echo shar: \"'doc/effects.inc'\" unpacked with wrong size!
fi
# end of 'doc/effects.inc'
fi
if test -f 'doc/fparseargs3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/fparseargs3.inc'\"
else
echo shar: Extracting \"'doc/fparseargs3.inc'\" \(932 characters\)
sed "s/^X//" >'doc/fparseargs3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f fparseargs ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
XGiven a readable input stream and an argdesc array, \fIfparseargs\fP
Xwill parse arguments in a file in the same manner as \fIparseargs\fP.
XA maximum-line length of 255 characters is imposed.  NO ``escaping'' of any
Xkind is performed. Comments of a limited form are permitted: if the first
Xnon-whitespace character on a line is a '#' (or '!' for \s-1VMS\s+1) then
Xthat entire line is considered a comment and is ignored.  If a value is
Xprovided for an argument that is NOT a list or a vector, then the value MUST
Xbe on the same line as the argument (in other words, ``\fB\-v\fI val\fR'' is
Xfine but ``\fB\-v\f4\\n\fIval\fR'' is a not).
END_OF_FILE
if test 932 -ne `wc -c <'doc/fparseargs3.inc'`; then
    echo shar: \"'doc/fparseargs3.inc'\" unpacked with wrong size!
fi
# end of 'doc/fparseargs3.inc'
fi
if test -f 'doc/lib_bugs.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/lib_bugs.inc'\"
else
echo shar: Extracting \"'doc/lib_bugs.inc'\" \(1102 characters\)
sed "s/^X//" >'doc/lib_bugs.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I BUGS  ../xparse.c
X.\"----------------------------------------------------------------------------
X.SH BUGS
X.PP
XWhen a non-multivalued argument appears more than once on the command-line
Xthen only the last value supplied is used. A problem occurs however in the
Xfollowing scenario: suppose `\fB\-s\fP' is an option that takes an optional
Xstring argument (and suppose `\fB\-x\fP' is some boolean flag). Then if the
Xfollowing command-line is issued:
X
X.RS
X.nf
X.ft 4
Xcommand  \-s string  \-x  \-s
X.ft R
X.fi
X.RE
X
Xthen, the argument flags will properly correspond to the second instance
Xof the `\fB\-s\fP' option (namely \s-1ARGGIVEN\s+1 will be set but 
X\s-1ARGVALGIVEN\s+1 will be unset) but the value associated with the
Xoption will be ``\fIstring\fP'' (because the first instance overwrote
Xthe default).  Because of this, it may be safest to reassign the default
Xvalue if \s-1ARGGIVEN\s+1 is set but \s-1ARGVALGIVEN\s+1 is unset.
END_OF_FILE
if test 1102 -ne `wc -c <'doc/lib_bugs.inc'`; then
    echo shar: \"'doc/lib_bugs.inc'\" unpacked with wrong size!
fi
# end of 'doc/lib_bugs.inc'
fi
if test -f 'doc/lparseargs3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/lparseargs3.inc'\"
else
echo shar: Extracting \"'doc/lparseargs3.inc'\" \(427 characters\)
sed "s/^X//" >'doc/lparseargs3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f lparseargs ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
XGiven an ArgList and an argdesc array, \fIlparseargs\fP
Xwill parse arguments in an ArgList in the same manner as \fIparseargs\fP.
END_OF_FILE
if test 427 -ne `wc -c <'doc/lparseargs3.inc'`; then
    echo shar: \"'doc/lparseargs3.inc'\" unpacked with wrong size!
fi
# end of 'doc/lparseargs3.inc'
fi
if test -f 'doc/parseargs1.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/parseargs1.inc'\"
else
echo shar: Extracting \"'doc/parseargs1.inc'\" \(1622 characters\)
sed "s/^X//" >'doc/parseargs1.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION ../parseargs.c
X.\"----------------------------------------------------------------------------
X.SH DESCRIPTION
XGiven a command name, a vector of string-valued arguments
Xsuch as that passed to a shell script,
Xand a specification string describing the possible arguments,
X.B parseargs
Xmatches actual arguments to possible arguments,
Xconverts values to the desired type,
Xand diagnoses problems such as
Xmissing arguments,
Xextra arguments,
Xand argument values that are syntactically incorrect.
XOther behavior such as prompting the user for missing arguments and
Xignoring bad command-line syntax may be specified on the command-line
Xthrough the use of various options, or through the use of the
X``\s-1PARSECNTL\s+1'' environment variable.
X.PP
XGiven the command name and the argument specification string,
X.B parseargs \-U
Xprints a reasonably friendly version of the usage of the
Xcalling program on standard diagnostic output. The ``verbosity''
Xof the usage message may be controlled through the use of the
X``\s-1USAGECNTL\s+1'' environment variable.
X.PP
XGiven the command name and the argument specification string,
X.B parseargs \-M
Xprints a template of the command-syntax on standard output that is
Xsuitable for input to \fInroff\fP or \fItroff\fP using the \fI\-man\fP
Xmacro package.
X.PP
XGiven no other arguments
X\fBparseargs \-#\fP prints on standard output, the current version and
Xpatchlevel of the running version of \fBparseargs\fP.
X
END_OF_FILE
if test 1622 -ne `wc -c <'doc/parseargs1.inc'`; then
    echo shar: \"'doc/parseargs1.inc'\" unpacked with wrong size!
fi
# end of 'doc/parseargs1.inc'
fi
if test -f 'doc/parseargs3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/parseargs3.inc'\"
else
echo shar: Extracting \"'doc/parseargs3.inc'\" \(642 characters\)
sed "s/^X//" >'doc/parseargs3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f parseargs ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
XGiven a vector of string-valued arguments such as that passed to \fImain\fP
Xand a vector describing the possible arguments, \fIparseargs\fP matches
Xactual arguments to possible arguments, converts values to the desired type,
Xand diagnoses problems such as missing arguments, extra arguments,
Xand argument values that are syntactically incorrect.
END_OF_FILE
if test 642 -ne `wc -c <'doc/parseargs3.inc'`; then
    echo shar: \"'doc/parseargs3.inc'\" unpacked with wrong size!
fi
# end of 'doc/parseargs3.inc'
fi
if test -f 'doc/parsecntl.man3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/parsecntl.man3'\"
else
echo shar: Extracting \"'doc/parsecntl.man3'\" \(1022 characters\)
sed "s/^X//" >'doc/parsecntl.man3' <<'END_OF_FILE'
X.\"---------- TO PRINT, USE: {n,t}roff -man file ----------
X.TH PARSECNTL 3
X.\"-----------------------------------
X.SH NAME
Xparsecntl \- get and set attributes of an argument descriptor array
X.\"-----------------------------------
X.SH SYNOPSIS
X#include <parseargs.h>
X.PP
X.nf
Xint  parsecntl( ARGDESC argd[\|],  parsecntl_t func,  parsemode_t mode,  ... );
X.fi
X
X.\"-----------------------------------
X.so parsecntl3.inc
X.\"-----------------------------------
X.so parsecntls.inc
X.\"-----------------------------------
X.so parsemodes.inc
X.\"-----------------------------------
X.so parseflags.inc
X.\"-----------------------------------
X.so argflags.inc
X.\"-----------------------------------
X.so returns.inc
X.\"-----------------------------------
X.so effects.inc
X.\"-----------------------------------
X.SH SEE ALSO
X.IR argtype (3),
X.IR parseargs (3),
X.IR parseargs (1)
X.\"-----------------------------------
X.SH AUTHOR
X.PP
X.nf
XBrad Appleton  (\fIbrad@ssd.csd.harris.com\fP)
XHarris Computer Systems, Fort Lauderdale, FL USA
X.fi
END_OF_FILE
if test 1022 -ne `wc -c <'doc/parsecntl.man3'`; then
    echo shar: \"'doc/parsecntl.man3'\" unpacked with wrong size!
fi
# end of 'doc/parsecntl.man3'
fi
if test -f 'doc/parsecntl3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/parsecntl3.inc'\"
else
echo shar: Extracting \"'doc/parsecntl3.inc'\" \(1720 characters\)
sed "s/^X//" >'doc/parsecntl3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f parsecntl ../xparse.c
X.\"----------------------------------------------------------------------------
X.SH "DESCRIPTION"
X.PP
X.I Parsecntl
Xwill read and/or write the desired attributes of the given
Xcommand-object. The attributes to be operated upon are specified by
Xthe second parameter to
X.I parsecntl.
XThe desired mode (read, write, or both) are specified by the third parameter to
X.I parsecntl.
XIf the operation to be performed is
X.I pc_\s-1ARGFLAGS\s+1,
Xthen the fourth argument to
X.I parsecntl
Xshould be the keyword name of the argument whose flags
Xare to be retrieved.  The last parameter to
X.I parsecntl
Xis always the object to contain the attribute(s) to be read/written.
XIf the attribute(s) are to be read (regardless of whether or not they are 
Xalso being changed) then the last argument should be a pointer to
Xan object, otherwise the last argument should be the object itself.
X.PP
XIf mode is
X.I pc_\s-1READ\s+1,
Xthen the desired attributes are copied into
Xthe object pointed to by the last parameter. If the mode is
X.I pc_\s-1WRITE\s+1,
Xthen the attributes from the last parameter are copied to the
Xcommand-object. If mode is
X.I pc_\s-1RDWR\s+1,
Xthen the attributes pointed to by the last
Xparameter are copied to the command-object, and then the previous value
Xof these attributes (before they were overwritten) is copied into the
Xobject pointed to by the last parameter.
X.PP
XIf cntl is
X.I pc_\s-1ARGFLAGS\s+1,
Xthen the only valid mode is
X.I pc_\s-1READ\s+1.
XAll other attributes may be written or read by
X.I parsecntl.
END_OF_FILE
if test 1720 -ne `wc -c <'doc/parsecntl3.inc'`; then
    echo shar: \"'doc/parsecntl3.inc'\" unpacked with wrong size!
fi
# end of 'doc/parsecntl3.inc'
fi
if test -f 'doc/parsemodes.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/parsemodes.inc'\"
else
echo shar: Extracting \"'doc/parsemodes.inc'\" \(1435 characters\)
sed "s/^X//" >'doc/parsemodes.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -p '[ \t]*' -s PARSE-MODES ../parseargs.h
X.\"----------------------------------------------------------------------------
X.SH "PARSE MODES"
X.PP
X\fIParsecntl\fP may be used to read current command attributes, write
X(assign) new command attributes, or both. The mode argument to
Xparsecntl determines which of these three alternatives are
Xdesired. If the programmer merely wishes to assign new attributes,
Xthen invoking \fIparsecntl\fP in \fIpc_\s-1WRITE\s+1\fP mode and passing
Xthe new attributes will do the job. If the programmer wishes simply to query
Xattributes, then invoking \fIparsecntl\fP in \fIpc_\s-1READ\s+1\fP mode and
Xpassing a pointer to the desired object in which to write the attribute
Xsettings will suffice.
X
XIf the programmer wishes to assign new attributes and at the same time
Xfind out what the attributes were before making the assignment, then
Xprogrammer must invoke \fIparsecntl\fP for \fIpc_\s-1RDWR\s+1\fP mode
Xand pass a pointer to the object containing the new attribute settings;
XWhen \fIparsecntl\fP returns, then (assuming it returns 0) the desired
Xattributes will have been assigned and the object that contained the
Xnew attribute settings will now contain the attribute settings that
Xwere in effect immediately before \fIparsecntl\fP was invoked.
END_OF_FILE
if test 1435 -ne `wc -c <'doc/parsemodes.inc'`; then
    echo shar: \"'doc/parsemodes.inc'\" unpacked with wrong size!
fi
# end of 'doc/parsemodes.inc'
fi
if test -f 'doc/sparseargs3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/sparseargs3.inc'\"
else
echo shar: Extracting \"'doc/sparseargs3.inc'\" \(830 characters\)
sed "s/^X//" >'doc/sparseargs3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f sparseargs ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
XGiven a single string and an argdesc array, \fIsparseargs\fP
Xwill parse arguments from a string in much the manner as \fIparseargs\fP.
X.I Sparseargs
Xwill split the given string up into a vector of whitespace
Xseparated tokens and then attempt to parse the resultant vector as
Xif it were given as \f4argv[]\fP on the command-line.
XNO special treatment is given to characters such as single-quotes,
Xdouble-quotes, or anything else. \fISparseargs\fP will always assume that
Xany whitespace characters are intended as argument separators.
END_OF_FILE
if test 830 -ne `wc -c <'doc/sparseargs3.inc'`; then
    echo shar: \"'doc/sparseargs3.inc'\" unpacked with wrong size!
fi
# end of 'doc/sparseargs3.inc'
fi
if test -f 'doc/usage3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/usage3.inc'\"
else
echo shar: Extracting \"'doc/usage3.inc'\" \(449 characters\)
sed "s/^X//" >'doc/usage3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f usage ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
XGiven an argdesc array, \fIusage\fP will print the usage for the given
Xcommand in the format specified by the user's \s-1USAGECNTL\s+1 environment
Xvariable.
END_OF_FILE
if test 449 -ne `wc -c <'doc/usage3.inc'`; then
    echo shar: \"'doc/usage3.inc'\" unpacked with wrong size!
fi
# end of 'doc/usage3.inc'
fi
if test -f 'doc/vparseargs3.inc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/vparseargs3.inc'\"
else
echo shar: Extracting \"'doc/vparseargs3.inc'\" \(731 characters\)
sed "s/^X//" >'doc/vparseargs3.inc' <<'END_OF_FILE'
X.\"----------------------------------------------------------------------------
X.\"-- This text was extracted using the following command:
X.\"--   xdoc -man -n -p '[ \t]*' -I DESCRIPTION -f vparseargs ../xparse.c
X.\"----------------------------------------------------------------------------
X.PP
X.I Vparseargs
Xtakes an argdesc array, the number of arguments to parse, and a
X(possibly NULL terminated) list of argument-strings
Xand parses them in the same manner as \fIparseargs\fP.
XUnlike
X.I sparseargs,
X.I vparseargs
Xassumes that all parameters are already split up into tokens, hence any
Xwhitespace characters contained in any of the string-parameters are used as
Xis (and will be considered a part of an argument name or value).
END_OF_FILE
if test 731 -ne `wc -c <'doc/vparseargs3.inc'`; then
    echo shar: \"'doc/vparseargs3.inc'\" unpacked with wrong size!
fi
# end of 'doc/vparseargs3.inc'
fi
if test -f 'exit_codes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'exit_codes.h'\"
else
echo shar: Extracting \"'exit_codes.h'\" \(1098 characters\)
sed "s/^X//" >'exit_codes.h' <<'END_OF_FILE'
X/*************************************************************************
X** ^FILE: exit_codes.h - define exit codes used by the parseargs library
X**
X** ^DESCRIPTION:
X**    When we call exit(3C), we want to use a value that is appropriate
X**    for the operating system that we are on.  Here are the values
X**    that we need to define:
X**
X**       exit_NORMAL  -- no errors everything is fine
X**       exit_USAGE   -- no errors but we didnt parse the command-line
X**                       because we say an argUsage argument
X**       exit_SYNTAX  -- a syntax error occurred
X**       exit_SYSTEM  -- a system error occurred
X**
X** ^HISTORY:
X**    04/13/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X***^^********************************************************************/
X
X#ifndef exit_NORMAL
X
X#ifdef vms
X# include <ssdef.h>
X# define  exit_NORMAL  SS$_NORMAL
X# define  exit_USAGE   SS$_NOTMODIFIED
X# define  exit_SYNTAX  SS$_BADPARAM
X# define  exit_SYSTEM  SS$_CANCEL
X#else
X# define  exit_NORMAL  0
X# define  exit_USAGE   1
X# define  exit_SYNTAX  2
X# define  exit_SYSTEM  127
X#endif
X
X#endif
END_OF_FILE
if test 1098 -ne `wc -c <'exit_codes.h'`; then
    echo shar: \"'exit_codes.h'\" unpacked with wrong size!
fi
# end of 'exit_codes.h'
fi
if test -f 'pgopen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pgopen.h'\"
else
echo shar: Extracting \"'pgopen.h'\" \(977 characters\)
sed "s/^X//" >'pgopen.h' <<'END_OF_FILE'
X/*************************************************************************
X** ^FILE: pgopen.h - include file for pgopen.c
X**
X** ^DESCRIPTION:
X**    If USE_PAGER is #define'd then this file will define the function
X**    prototypes needed to use the paging library implemented in pgopen.c;
X**    Otherwise it will #define macros with the same name as the paging
X**    library routines which do NOT perform any paging.
X**
X** ^HISTORY:
X**    01/02/91 	Brad Appleton 	<brad@ssd.csd.harris.com> 	Created
X***^^**********************************************************************/
X
X#ifndef NULL
X#  include <stdio.h>
X#endif
X#include <useful.h>
X
X#ifdef  USE_PAGER
X   EXTERN   FILE *pgopen    ARGS(( FILE *, const char * ));
X   EXTERN   int   pgclose   ARGS(( FILE * ));
X   EXTERN   int   pgactive  ARGS(( const FILE * ));
X#else
X#  define  pgopen(fp,s)  (( !fp ) ? fp : (fflush(fp), fp))
X#  define  pgclose(fp)   (( !fp ) ?  0 : (fflush(fp), 0))
X#  define  pgactive(fp)  ( fp )
X#endif
END_OF_FILE
if test 977 -ne `wc -c <'pgopen.h'`; then
    echo shar: \"'pgopen.h'\" unpacked with wrong size!
fi
# end of 'pgopen.h'
fi
if test -f 'test.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.pl'\"
else
echo shar: Extracting \"'test.pl'\" \(1718 characters\)
sed "s/^X//" >'test.pl' <<'END_OF_FILE'
X#!/usr/bin/perl
X
Xrequire  'parseargs.pl';
X
X$ARGD = '
X  { "?", ARGHIDDEN, argUsage, NULL,    "Help : print usage and exit" },
X  { "S", ARGVALOPT, argStr,   string,  "STRing : optional string arg" },
X  { "g", ARGLIST,   argStr,   groups,  "newsGROUPS : groups to test" },
X  { "r", ARGOPT,    argInt,   count,   "REPcount : group repeat count" },
X  { "d", ARGOPT,    argStr,   dirname, "DIRectory : working directory" },
X  { "x", ARGOPT,    argBool,  xflag,   "Xflag : turn on X-mode" },
X  { "y", ARGOPT,    argUBool, yflag,   "Yflag : turn off Y-mode" },
X  { "s", ARGOPT,    argChar,  sepch,   "SEPchar : field separator" },
X  { "f", ARGLIST,   argStr,   files,   "files : files to process" },
X  { "n", ARGREQ|ARGPOS, argStr, name,  "name : name to use" },
X  { " ", ARGLIST,   argStr,   ARGV,    "ARGV : any remaining arguments" },
X  "ENDOFARGS" ';
X
X$count = 1;
X$dirname = '.';
X$sepch = ',';
X$yflag = 'TRUE';
X
X&parseargs( @ARGV, $ARGD );
X
X## print  the parsed arguments (use defaults if not defined)
Xprint "ARGUMENTS:\n";
Xprint "==========\n";
Xfor ( $i = $[ ; $i <= $#groups ; $i++ ) {
X  printf( "Groups[%d] = '%s'\n", $i, $groups[$i] );
X}
Xprintf( "Count = %d\n", $count );
Xprintf( "Directory = '%s'\n", $dirname );
Xprintf( "XFlag = '%s'\n", $xflag );
Xprintf( "YFlag = '%s'\n", $yflag );
Xprintf( "SepChar = '%s'\n", $sepch );
Xprintf( "Name = '%s'\n", $name );
Xfor ( $i = $[ ; $i <= $#files ; $i++ ) {
X  printf( "Files[%d] = '%s'\n", $i, $files[$i] );
X}
Xif ( $string_flag ) {
X  if ( ! $string ) {
X    $string = '!string arg ommitted on cmd-line!';
X  }
X}
Xelse {
X  $string = 'default string';
X}
Xprintf( "String = '%s'\n", $string );
Xfor ( $i = $[ ; $i <= $#ARGV ; $i++ ) {
X  printf( "ARGV[%d] = '%s'\n", $i, $ARGV[$i] );
X}
END_OF_FILE
if test 1718 -ne `wc -c <'test.pl'`; then
    echo shar: \"'test.pl'\" unpacked with wrong size!
fi
chmod +x 'test.pl'
# end of 'test.pl'
fi
if test -f 'test.rc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.rc'\"
else
echo shar: Extracting \"'test.rc'\" \(1873 characters\)
sed "s/^X//" >'test.rc' <<'END_OF_FILE'
X#!/bin/rc
X#	test.rc - rc shell script to test out the parseargs command!
X#
X#   NOTE: This script tests Byron Rakitzis' version of rc. NOT the
X#         Plan 9 version (there are a few differences such as the use
X#         of "else" instead of "if not" and the use of "$^variable").
X#
XNAME=`{basename $0}
X
XARGUMENTS='
X  "?", ARGHIDDEN, argUsage, NULL,    "Help : print usage and exit",
X  "S", ARGVALOPT, argStr,   string,  "STRing : optional string arg",
X  "g", ARGLIST,   argStr,   groups,  "newsGROUPS : groups to test",
X  "r", ARGOPT,    argInt,   count,   "REPcount <# to repeat each group>",
X  "d", ARGOPT,    argStr,   dirname, "DIRectory : working directory",
X  "x", ARGOPT,    argBool,  xflag,   "Xflag : turn on X-mode",
X  "y", ARGOPT,    argUBool, yflag,   "Yflag : turn off Y-mode",
X  "s", ARGOPT,    argChar,  sepch,   "SEPchar : field separator",
X  "f", ARGLIST,   argStr,   files,   "files : files to process",
X  "n", ARGREQ|ARGPOS, argStr, name,  "name : name to use",
X  " ", ARGLIST,   argStr,   argv,      "argv : any remaining arguments",
X  ENDOFARGS
X'
X
Xyflag='TRUE'     ## set defaults (dir="."; count=1; sepch=',') ##
Xcount=1
Xsepch=','
X
X## parse command-line and save assignments in a temporary file ##
Xif ( parseargs -s rc -e ARGUMENTS -u -- $^NAME $* >/tmp/tmp$pid ) {
X   ## evaluate results from parseargs and remove temporary file
X   . /tmp/tmp$pid;  rm -f /tmp/tmp$pid
X} else {
X  rm -f /tmp/tmp$pid;
X  exit 2  ## non-zero status (usage given)
X}
X
X
X## echo  the parsed arguments (use defaults if not defined)
Xecho 'ARGUMENTS:'
Xecho '=========='
Xecho 'Name='"$name", 'Count='$count
Xecho 'XFlag='"$xflag", 'YFlag='"$yflag"
Xecho 'Directory='"$dirname", 'SepChar='"$sepch"
Xecho 'Groups='"$groups"
Xecho 'Files='"$files"
Xecho 'string_flag='$^string_flag
Xecho 'String='"$string"
Xecho 'argv=' "$argv"
X
Xparseargs -a $^ARGUMENTS -U $^NAME     ## print usage ##
END_OF_FILE
if test 1873 -ne `wc -c <'test.rc'`; then
    echo shar: \"'test.rc'\" unpacked with wrong size!
fi
chmod +x 'test.rc'
# end of 'test.rc'
fi
if test -f 'test.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.sh'\"
else
echo shar: Extracting \"'test.sh'\" \(1790 characters\)
sed "s/^X//" >'test.sh' <<'END_OF_FILE'
X#!/bin/sh
X#	test.sh - Bourne shell script to test out the parseargs command!
X#
XNAME="`basename $0`";  DOT=".";
X
XARGUMENTS="
X  '?', ARGHIDDEN, argUsage, NULL,    'Help : print usage and exit',
X  'S', ARGVALOPT, argStr,   string,  'STRing : optional string arg',
X  'g', ARGLIST,   argStr,   groups,  'newsGROUPS : groups to test',
X  'r', ARGOPT,    argInt,   count,   'REPcount <# to repeat each group>',
X  'd', ARGOPT,    argStr,   dirname, 'DIRectory : working directory',
X  'x', ARGOPT,    argBool,  xflag,   'Xflag : turn on X-mode',
X  'y', ARGOPT,    argUBool, yflag,   'Yflag : turn off Y-mode',
X  's', ARGOPT,    argChar,  sepch,   'SEPchar : field separator',
X  'f', ARGLIST,   argStr,   files,   'files : files to process',
X  'n', ARGREQ|ARGPOS, argStr, name,  'name : name to use',
X  ' ', ARGLIST,   argStr,   -- ,     'argv : any remaining arguments',
X  ENDOFARGS
X"
Xexport ARGUMENTS
X
Xyflag='TRUE'     ## set defaults (dir="."; count=1; sepch=',') ##
X
X## parse command-line and save assignments in a temporary file ##
Xparseargs -s sh -e ARGUMENTS -u -- "$NAME" "$@" > /tmp/tmp$$
Xif [ $? -ne 0 ]
X  then rm -f /tmp/tmp$$; exit 2  ## non-zero status (usage given)
Xfi
X
X## evaluate results from parseargs and remove temporary file
X$DOT /tmp/tmp$$;  rm -f /tmp/tmp$$
X
X## echo  the parsed arguments (use defaults if not defined)
Xecho "ARGUMENTS:"
Xecho "=========="
Xecho "Name='$name', Count='${count:-1}'"
Xecho "XFlag='$xflag', YFlag='$yflag'"
Xecho "Directory='${dirname:-"."}', SepChar='${sepch:-","}'"
Xecho "Groups='$groups'"
Xecho "Files='$files'"
Xif [ "$string_flag" ]
X  then string=${string:-"!string arg ommitted on cmd-line!"}
X  else string="default string"
Xfi
Xecho "String='$string'"
Xecho "New Positional Parameters='$*'"
X
Xparseargs -a "$ARGUMENTS" -U "$NAME"     ## print usage ##
END_OF_FILE
if test 1790 -ne `wc -c <'test.sh'`; then
    echo shar: \"'test.sh'\" unpacked with wrong size!
fi
chmod +x 'test.sh'
# end of 'test.sh'
fi
if test -f 'test.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.tcl'\"
else
echo shar: Extracting \"'test.tcl'\" \(1616 characters\)
sed "s/^X//" >'test.tcl' <<'END_OF_FILE'
X#!/usr/bin/tcl -q
X
Xsource parseargs.tcl
X
Xset arguments {
X  { '?', ARGHIDDEN, argUsage, NULL,    "Help : print usage and exit" },
X  { 'S', ARGVALOPT, argStr,   string,  "STRing : optional string arg" },
X  { 'g', ARGLIST,   argStr,   groups,  "newsGROUPS : groups to test" },
X  { 'r', ARGOPT,    argInt,   count,   "REPcount : group repeat count" },
X  { 'd', ARGOPT,    argStr,   dirname, "DIRectory : working directory" },
X  { 'x', ARGOPT,    argBool,  xflag,   "Xflag : turn on X-mode" },
X  { 'y', ARGOPT,    argUBool, yflag,   "Yflag : turn off Y-mode" },
X  { 's', ARGOPT,    argChar,  sepch,   "SEPchar : field separator" },
X  { 'f', ARGLIST,   argStr,   files,   "files : files to process" },
X  { 'n', ARGREQ|ARGPOS, argStr, name,  "name : name to use" },
X  { ' ', ARGLIST,   argStr,   argv,    "argv : any remaining arguments" },
X  ENDOFARGS
X}
X
Xset count 1
Xset dirname "."
Xset sepch ","
Xset xflag ""
Xset yflag "TRUE"
Xset files {}
Xset groups {}
Xset name ""
Xset string ""
Xset string_flag ""
X
Xeval [ parseargs -u -a $arguments $scriptName $argv ]
X
X## print  the parsed arguments (use defaults if not defined)
Xputs stdout "ARGUMENTS:"
Xputs stdout "=========="
Xputs stdout "Groups = $groups"
Xputs stdout "Count = $count"
Xputs stdout "Directory = $dirname"
Xputs stdout "XFlag = $xflag"
Xputs stdout "YFlag = $yflag"
Xputs stdout "SepChar = $sepch"
Xputs stdout "Name = $name"
Xputs stdout "Files = $files"
Xif {( "$string_flag" != "") } {
X  if {( "$string" == "" )} {
X    set string "!string arg ommitted on cmd-line!"
X  }
X} else {
X  set string "default string"
X}
Xputs stdout "String = $string"
Xputs stdout "argv = $argv"
X
END_OF_FILE
if test 1616 -ne `wc -c <'test.tcl'`; then
    echo shar: \"'test.tcl'\" unpacked with wrong size!
fi
chmod +x 'test.tcl'
# end of 'test.tcl'
fi
echo shar: End of archive 1 \(of 10\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
