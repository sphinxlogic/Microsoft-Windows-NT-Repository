Newsgroups: comp.sources.misc
From: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Subject:  v29i090:  procmail - mail processing program v2.70, Part01/05
Message-ID: <csm-v29i090=procmail.101301@sparky.IMD.Sterling.COM>
X-Md4-Signature: 8396d7abbb6283263df334082ede2af1
Date: Mon, 11 May 1992 15:13:47 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Posting-number: Volume 29, Issue 90
Archive-name: procmail/part01
Environment: UNIX, sendmail, smail, MMDF
Supersedes: procmail: Volume 28, Issue 01-05

The procmail mail processing program. (v2.70 1992/04/30)

Can be used to create mail-servers, mailing lists, sort your incoming mail
into separate folders/files (real convenient when subscribing to one or more
mailing lists or for prioritising your mail), preprocess your mail, start
any programs upon mail arrival (e.g. to generate different chimes on your
workstation for different types of mail) or selectively forward certain
incoming mail automatically to someone.

The accompanying formail program enables you to generate autoreplies, split up
digests/mailboxes into the original messages, do some very simple
header-munging/extraction, or force mail into mail-format (with leading From
line).

Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de
 ----------------------
A recent version can be picked up at various comp.sources.misc archives.
The latest version can be obtained directly from the ftp-archive at:

	ftp.informatik.rwth-aachen.de (137.226.112.31)

	as compressed tar file:		pub/unix/procmail.tar.Z		<128KB
	or in compressed shar format:	pub/unix/procmail.0?.Z
 ----------------------
Feature summary for procmail:
	+ It's small
	+ Very easy to install (rated PG6 :-)
	+ Simple to maintain and configure because
	  all you need is actually only ONE executable (procmail)
	  and ONE configuration file (.procmailrc)
	+ Is event driven (i.e. gets invoked automagically when mail arrives)
	+ Does not use *any* temporary files
	+ Uses standard egrep regular expressions
	+ Allows for very-easy-to-use yes-no decisions on where the mail
	  should go (can take the size of the mail into consideration)
	+ Filters, delivers and forwards mail *reliably*
	+ Provides a reliable hook (you might even say anchor :-) for any
	  programs or shell scripts you may wish to start upon mail arrival
	+ Performs heroically under even the worst conditions
	  (file system full, out of swap space, process table full,
	  file table full, missing support files, unavailable executables,
	  denied permissions) and tries to deliver the mail somehow anyway
	+ Absolutely undeliverable mail (after trying every trick in the book)
	  will bounce back to the sender (or not, your choice)
	+ Is one of the few mailers to perform reliable mailbox locking across
	  NFS as well (DON'T use NFS mounted mailboxes WITHOUT installing
	  procmail, you may use valuable mail one day)
	+ Supports four mailfolder standards: single file folders (standard
	  and nonstandard VNIX format), directory folders that contain one file
	  per message, or the similar MH directory folders (numbered files)
	+ Variable assignment and substitution is an extremely complete subset
	  of the standard /bin/sh syntax
	+ Provides a mail log file, which logs all mail arrival, shows
	  in summary whence it came from, what it was about, where it went
	  (what folder) and how long (in bytes) it was
	+ Uses this log file to display a wide range of diagnostic and error
	  messages (if something went wrong)
	+ Processed mail can contain arbitrary 8-bit characters (including
	  '\0'); i.e. binary mailings can be processed if the rest of the
	  mailing system knew how to handle them too
	+ It has a man page (boy, does *it* have a man page)
	+ Procmail can be used as a local delivery agent (a completely
	  integrated substitute for /bin/mail), in which case it can heal
	  your system mailbox, if something messes up the permissions
	+ It runs on virtually all (old and future) operating systems which
	  names start with a 'U' or end in an 'X' :-) (i.e. extremely portable
	  code; POSIX, ANSI C and K&R conforming)
	+ Is clock skew immune (e.g. in the case of NFS mounted mailboxes)
	+ Works with (among others?) sendmail, smail and MMDF

Feature summary for formail:
	+ Can generate auto-reply headers
	+ Can convert mail into standard mailbox format (so that you can
	  process it with standard mail programs)
	+ Can split up mailboxes into the individual messages
	+ Can split up digests into the individual messages
	+ Can split up saved articles into the individual articles
	+ Can do simple header munging/extraction

Feature summary for lockfile:
	+ Provides NFS-secure lockfiles to shell script programmers
	+ Gives normal users the ability to lock their system mailbox,
	  regardless of permissions on the mail-spool directory
----------------------cut here-----------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  procmail procmail/FEATURES procmail/HISTORY
#   procmail/README procmail/common.c procmail/examples
#   procmail/examples/1procmailrc procmail/examples/2procmailrc
#   procmail/examples/2rmail procmail/examples/3procmailrc
#   procmail/examples/3rmail procmail/examples/forward
#   procmail/examples/listrc procmail/exopen.c procmail/exopen.h
#   procmail/lockfile.c procmail/man procmail/patchlevel.h
#   procmail/procmail.h procmail/recommend.c procmail/strpbrk.c
# Wrapped by berg@drunol on Thu Apr 30 13:42:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'procmail' ; then
    echo shar: Creating directory \"'procmail'\"
    mkdir 'procmail'
fi
if test -f 'procmail/FEATURES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/FEATURES'\"
else
echo shar: Extracting \"'procmail/FEATURES'\" \(3204 characters\)
sed "s/^X//" >'procmail/FEATURES' <<'END_OF_FILE'
XFeature summary for procmail:
X	+ It's small
X	+ Very easy to install (rated PG6 :-)
X	+ Simple to maintain and configure because
X	  all you need is actually only ONE executable (procmail)
X	  and ONE configuration file (.procmailrc)
X	+ Is event driven (i.e. gets invoked automagically when mail arrives)
X	+ Does not use *any* temporary files
X	+ Uses standard egrep regular expressions
X	+ Allows for very-easy-to-use yes-no decisions on where the mail
X	  should go (can take the size of the mail into consideration)
X	+ Filters, delivers and forwards mail *reliably*
X	+ Provides a reliable hook (you might even say anchor :-) for any
X	  programs or shell scripts you may wish to start upon mail arrival
X	+ Performs heroically under even the worst conditions
X	  (file system full, out of swap space, process table full,
X	  file table full, missing support files, unavailable executables,
X	  denied permissions) and tries to deliver the mail somehow anyway
X	+ Absolutely undeliverable mail (after trying every trick in the book)
X	  will bounce back to the sender (or not, your choice)
X	+ Is one of the few mailers to perform reliable mailbox locking across
X	  NFS as well (DON'T use NFS mounted mailboxes WITHOUT installing
X	  procmail, you may use valuable mail one day)
X	+ Supports four mailfolder standards: single file folders (standard
X	  and nonstandard VNIX format), directory folders that contain one file
X	  per message, or the similar MH directory folders (numbered files)
X	+ Variable assignment and substitution is an extremely complete subset
X	  of the standard /bin/sh syntax
X	+ Provides a mail log file, which logs all mail arrival, shows
X	  in summary whence it came from, what it was about, where it went
X	  (what folder) and how long (in bytes) it was
X	+ Uses this log file to display a wide range of diagnostic and error
X	  messages (if something went wrong)
X	+ Processed mail can contain arbitrary 8-bit characters (including
X	  '\0'); i.e. binary mailings can be processed if the rest of the
X	  mailing system knew how to handle them too
X	+ It has a man page (boy, does *it* have a man page)
X	+ Procmail can be used as a local delivery agent (a completely
X	  integrated substitute for /bin/mail), in which case it can heal
X	  your system mailbox, if something messes up the permissions
X	+ It runs on virtually all (old and future) operating systems which
X	  names start with a 'U' or end in an 'X' :-) (i.e. extremely portable
X	  code; POSIX, ANSI C and K&R conforming)
X	+ Is clock skew immune (e.g. in the case of NFS mounted mailboxes)
X	+ Works with (among others?) sendmail, smail and MMDF
X
XFeature summary for formail:
X	+ Can generate auto-reply headers
X	+ Can convert mail into standard mailbox format (so that you can
X	  process it with standard mail programs)
X	+ Can split up mailboxes into the individual messages
X	+ Can split up digests into the individual messages
X	+ Can split up saved articles into the individual articles
X	+ Can do simple header munging/extraction
X
XFeature summary for lockfile:
X	+ Provides NFS-secure lockfiles to shell script programmers
X	+ Gives normal users the ability to lock their system mailbox,
X	  regardless of permissions on the mail-spool directory
END_OF_FILE
if test 3204 -ne `wc -c <'procmail/FEATURES'`; then
    echo shar: \"'procmail/FEATURES'\" unpacked with wrong size!
fi
# end of 'procmail/FEATURES'
fi
if test -f 'procmail/HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/HISTORY'\"
else
echo shar: Extracting \"'procmail/HISTORY'\" \(5045 characters\)
sed "s/^X//" >'procmail/HISTORY' <<'END_OF_FILE'
X	Only the last entry is complete, the others might have been condensed.
X
X1990/12/07: v1.00
X1990/12/12: v1.01
X1991/02/04: v1.02
X1991/02/13: v1.10
X1991/02/21: v1.20
X1991/02/22: v1.21
X1991/03/01: v1.30
X1991/03/15: v1.35
X	    Started using RCS to manage the source
X1991/06/04: v1.99
X1991/06/10: v2.00
X1991/06/11: v2.01
X1991/06/12: v2.02
X1991/06/20: v2.03
X1991/07/04: v2.10
X1991/07/12: v2.11
X1991/10/02: v2.20 (never released)
X1991/10/18: v2.30
X	    Implemented a custom regular expression library (fully egrep
X	       compatible), should eliminate the annoyances with incompatible
X	       egreps
X	    Accomplished the doubtful milestone of having a source file
X	       (regexp.c) which provokes a compiler error on an old compiler
X	       (if using the optimiser)
X	    Ignoring leading spaces on condition lines now (means that
X	       everything can be indented in the rcfile)
X1991/10/22: v2.31
X1991/12/05: v2.40
X	    Made a clear debugging-aid entry in the INSTALL file
X	    Made procmail capable of healing the recipient's mail spool file
X	    Tricked NFS into supplying an access_time<modification_time for the
X	       folders written
X1991/12/13: v2.50
X1992/01/22: v2.60
X	    Enhanced the response to signals (SIGTERM and SIGQUIT now have
X	       different meanings)
X1992/01/31: v2.61
X	    Updated the directions for .forward file contents
X	    Fixed the EDQUOT define (some machines didn't define it)
X	    Eliminated a rare (no report of it occuring yet) inconvenience,
X	       a temporary file could be left lying around if procmail would
X	       be killed in a very small window after an open()
X	    Kludge the username into lowercase after the -d option
X	    Added specific directions for sites running smail (see
X	       examples/advanced)
X	    Added a search for sendmail in autoconf
X	    Fixed a problem in the implicit-lockfile-searching code
X	    Added the ARCHITECTURE variable to the Makefile (for convenience)
X1992/04/30: v2.70
X	    Added NO_USER_TO_LOWERCASE_HACK and NO_NFS_ATIME_HACK defines to
X	       config.h
X	    Added LD_LIBRARY_PATH protection (would have been a security hole
X	       on some machines)
X	    Fixed mistakenly default usage of KERNEL_LOCKS (was enabled
X	       regardless of the definition of KERNEL_LOCKS in config.h), if
X	       your system is running buggy lockd's, problems could have
X	       occurred
X	    Inserted some casts to shut up systems with ANSI compilers and
X	       prototyped include files
X	    Made sure logfile is flushed before forking
X	    Made sure no library calls are made in signal handlers
X	    Added a `vacation'-autoreply sample in examples/advanced
X	    Worked around a `PATH' bug in some Bourne shells
X	    Sped up sputenv, the smart environment handler routine
X	    Made sure procmail checks the return value from close()
X	    Made the man pages yet more portable (.LP->.PP)
X	    Made it possible for lockfile to be setuid or setgid, so that
X	       it is able to create and unlink lockfiles in the mail
X	       spool directory, even if normal users cannot
X	    Created the targets 'recommend' and 'suid' in Makefile, in
X	       order to make suid/sgid recommendations even more obvious,
X	       not easily overlooked and automatic
X	    Worked around bugs in some compilers not accepting:
X	       - struct eps const*const something;
X	       - char a[2]; &a;
X	    Worked around a bug in the SINIX include files (wrong protype for
X	       uname)
X	    Made procmail & lockfile clock skew independent (during LOCKTIMEOUT)
X	    By popular demand: added possibility to select mails on size
X	    Made procmail accept multiple recipients (this was not as trivial
X	       as it sounds!), in order for complete compatibility with mailers
X	       like smail 2.x
X	    Expanded the mail-delivery-agent instructions in examples/advanced,
X	       this includes specific intstructions for smail 2.x
X	    Made special entries in config.h for semi-permanent environment-
X	       variable overrides
X	    Made formail more intelligent, it can now parse full-fledged
X	       RFC822 addresses (quoting et al)
X	    Let formail look at the Date: field when reconstructing the date
X	    Changed stdin handling in forks in formail, to circumvent a bug in
X	       HP/UX
X	    A complete rewrite of formail, the code got bigger, the runtime
X	       requirement got bigger, it got slower, but, it's more structured
X	       (so much for structured programming :-)
X	    Provide a separate strpbrk.c file, since I use it in several
X	       programs now
X	    Made procmail check the permissions of its invoker, generate
X	       an overriding From_ line if necessary, and consequently made it
X	       accept the -f option (fromwhom), and also the alternate obsolete
X	       -r option of course
X	    Wiped out the ./include tree, made autoconf check it instead (the
X	       compile line looks so terribly clean now :-)
X	    Procmail makes an additional security check on the rcfiles before
X	       accepting them (owner and permissions, see man page)
X	    Fixed the `spurious' 0660 permissions on system-mailboxes
END_OF_FILE
if test 5045 -ne `wc -c <'procmail/HISTORY'`; then
    echo shar: \"'procmail/HISTORY'\" unpacked with wrong size!
fi
# end of 'procmail/HISTORY'
fi
if test -f 'procmail/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/README'\"
else
echo shar: Extracting \"'procmail/README'\" \(4205 characters\)
sed "s/^X//" >'procmail/README' <<'END_OF_FILE'
XFor installation instructions see the INSTALL file.
X----------------------
XProcmail & formail mail processing package.
XCopyright (c) 1990-1992, S.R. van den Berg, The Netherlands.
X
XSome legal stuff:
X
XUse this software package at your own risk.  The programmer cannot
Xbe held liable for any incurred damages, directly or indirectly due to
Xthe use or inability to use this software.
X
XYou are encouraged to distribute this package freely.  This package is
Xhowever not to be sold (minor transfer costs excepted) or included in
Xany commercially sold software package (if you want to do this anyway,
Xcontact me (address below), and we'll work something out).
X
XIf you distribute it, please leave the package intact.	You are allowed to
Xtake parts from this distribution and distribute these separately as long
Xas you retain the copyright messages.  If you redistribute any part of this
Xpackage in a modified form, be sure to mark the parts you changed.
XIf you have some important changes that might be useful to the rest of the
Xworld, contact me instead.
X
X-------------------------- SYSTEM REQUIREMENTS -------------------------------
X
XAny *NIX-alike system.
X
XSendmail, smail, MMDF or compatible mailers (in effect any mailer that can
Xprocess RFC-822 compliant mails).
X
XThe most important system calls that need to be supported (among others):
Xdup(),wait(),getpwnam(),fork(),pipe()
X
XFor a more complete list of all library references see "includes.h"
X
X------------------------------ DESCRIPTION -----------------------------------
X
XThe procmail mail processing program. (v2.70 1992/04/30)
X
XCan be used to create mail-servers, mailing lists, sort your incoming mail
Xinto separate folders/files (real convenient when subscribing to one or more
Xmailing lists or for prioritising your mail), preprocess your mail, start
Xany programs upon mail arrival (e.g. to generate different chimes on your
Xworkstation for different types of mail) or selectively forward certain
Xincoming mail automatically to someone.
X
XThe accompanying formail program enables you to generate autoreplies, split up
Xdigests/mailboxes into the original messages, do some very simple
Xheader-munging/extraction, or force mail into mail-format (with leading From
Xline).
X
X----------------------
X
XI made the utmost effort to make procmail as robust as any program can be
X(every conceivable system error is caught *and* handled).
X
XProcmail was designed to deliver the mail under the worst conditions
X(file system full, out of swap space, process table full, file table full,
Xmissing support files, unavailable executables; it all doesn't matter).
XShould (in the unlikely event) procmail be unable to deliver your mail
Xsomewhere, the mail will bounce back to the sender or reenter the mailqueue
X(your choice).
X
XFor a more extensive list of features see the FEATURES file.
X
X----------------------
X
XHowever, as with any program, bugs cannot be completely ruled out.
XI tested the program extensively, and believe it should be relatively
Xbug free (no known bug at the time).  Should, however, anyone find any
Xbugs (highly unlikely :-), I would be pleased (well, sort of :-) to hear
Xabout it.  Please send me the patches or bug report.
XI'll look at them and will try to fix it in a future release.
X(BTW, if you should find any spelling or grammar errors in these files,
Xdon't hesitate to point them out to me; I like correct English just as much
Xas you do).
X
XPlease note that this program essentially is supposed to be static, that
Xmeans no extra features (honouring the VNIX spirit) are supposed to be
Xadded (though any useful suggestions will be appreciated and evaluated if
Xtime permits).
X
XCheers,
X       Stephen R. van den Berg	at RWTH-Aachen, Germany.
X
XInternet E-mail:		berg@pool.informatik.rwth-aachen.de
X				berg@physik.tu-muenchen.de
X
XSnail-Mail:	P.O.Box 21074
X		6369 ZG Simpelveld
X		The Netherlands
X
X----------------------
XA recent version can be picked up at various comp.sources.misc archives.
XThe latest version can be obtained directly from the ftp-archive at:
X
X	ftp.informatik.rwth-aachen.de (137.226.112.31)
X
X	as compressed tar file:		pub/unix/procmail.tar.Z		<128KB
X	or in compressed shar format:	pub/unix/procmail.0?.Z
X----------------------
END_OF_FILE
if test 4205 -ne `wc -c <'procmail/README'`; then
    echo shar: \"'procmail/README'\" unpacked with wrong size!
fi
# end of 'procmail/README'
fi
if test -f 'procmail/common.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/common.c'\"
else
echo shar: Extracting \"'procmail/common.c'\" \(2031 characters\)
sed "s/^X//" >'procmail/common.c' <<'END_OF_FILE'
X/************************************************************************
X *	A some common routines for procmail and formail			*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	The sources can be freely copied for non-commercial use.	*
X *	#include "README"						*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: common.c,v 2.11 1992/03/19 14:00:28 berg Rel $";
X#endif
X#include "includes.h"
X
Xvoid*tmalloc();
Xextern const char binsh[];
X
X#ifdef NOmemmove
Xvoid*smemmove(To,From,count)void*To,*From;register size_t count;
X#ifdef NObcopy
X{ register char*to=To,*from=From;/*void*old;*/	  /* silly compromise, throw */
X  /*old=to;*/count++;--to;--from;  /* away space to be syntactically correct */
X  if(to<=from)
X   { goto jiasc;
X     do
X      { *++to= *++from;					  /* copy from above */
Xjiasc:;
X      }
X     while(--count);
X   }
X  else
X   { to+=count;from+=count;goto jidesc;
X     do
X      { *--to= *--from;					  /* copy from below */
Xjidesc:;
X      }
X     while(--count);
X   }
X  return To/*old*/;
X#else
X{ bcopy(From,To,count);return To;
X#endif /* NObcopy */
X}
X#endif /* NOmemmove */
X
X#include "shell.h"
X
Xshexec(argv)char*const*argv;
X{ int i;char**newargv;const char**p;
X#ifdef SIGXCPU
X  signal(SIGXCPU,SIG_DFL);signal(SIGXFSZ,SIG_DFL);
X#endif
X  signal(SIGPIPE,SIG_DFL);execvp(*argv,argv);	/* or is it a shell script ? */
X  for(p=(const char**)argv,i=1;i++,*p++;);	      /* count the arguments */
X  newargv=malloc(i*sizeof*p);
X  for(*(p=(const char**)newargv)=binsh;*++p= *argv++;);
X  execve(*newargv,newargv,environ);	      /* no shell script? -> trouble */
X  log("Failed to execute");logqnl(*argv);exit(EX_UNAVAILABLE);
X}
X
Xchar*pstrspn(whole,sub)const char*whole,*const sub;
X{ while(*whole&&strchr(sub,*whole))
X     whole++;
X  return(char*)whole;
X}
X
X#ifdef NOstrcspn
Xstrcspn(whole,sub)const char*const whole,*const sub;
X{ const register char*p;
X  p=whole;
X  while(*p&&!strchr(sub,*p))
X     p++;
X  return p-whole;
X}
X#endif
END_OF_FILE
if test 2031 -ne `wc -c <'procmail/common.c'`; then
    echo shar: \"'procmail/common.c'\" unpacked with wrong size!
fi
# end of 'procmail/common.c'
fi
if test ! -d 'procmail/examples' ; then
    echo shar: Creating directory \"'procmail/examples'\"
    mkdir 'procmail/examples'
fi
if test -f 'procmail/examples/1procmailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/1procmailrc'\"
else
echo shar: Extracting \"'procmail/examples/1procmailrc'\" \(634 characters\)
sed "s/^X//" >'procmail/examples/1procmailrc' <<'END_OF_FILE'
X# Please check if all the paths in PATH are reachable, remove the ones that
X# are not.
X
XPATH=$HOME/bin:/usr/bin:/usr/ucb:/bin:/usr/local/bin:
XMAILDIR=$HOME/Mail	# You'd better make sure it exists
XDEFAULT=$MAILDIR/mbox
XLOGFILE=$MAILDIR/from
XLOCKFILE=$HOME/.lockmail
X
X:				# Anything from thf
X^From.*thf@somewhere.someplace
Xtodd				# will go to $MAILDIR/todd
X
X:				# Anything from people at uunet
X^From.*@uunet
Xuunetbox			# will go to $MAILDIR/uunetbox
X
X:				# Anything from Henry
X^From.*henry
Xhenries				# will go to $MAILDIR/henries
X
X# Anything that has not been delivered by now will go to $DEFAULT
X# using LOCKFILE=$DEFAULT$LOCKEXT
END_OF_FILE
if test 634 -ne `wc -c <'procmail/examples/1procmailrc'`; then
    echo shar: \"'procmail/examples/1procmailrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/1procmailrc'
fi
if test -f 'procmail/examples/2procmailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/2procmailrc'\"
else
echo shar: Extracting \"'procmail/examples/2procmailrc'\" \(1970 characters\)
sed "s/^X//" >'procmail/examples/2procmailrc' <<'END_OF_FILE'
X# Please check if all the paths in PATH are reachable, remove the ones that
X# are not.
X
XPATH=$HOME/bin:/usr/bin:/usr/ucb:/bin:/usr/local/bin:
XMAILDIR=$HOME/Mail	# You'd better make sure it exists
XDEFAULT=$MAILDIR/mbox
X			# We don't use a global lockfile here now.
X			# Instead we use local lockfiles everywhere.
X			# This allows mail to arrive in all mailboxes
X			# concurrently, or allows you to read one mailbox
X			# while mail arrives in another.
X
X# The next recipe will split up Digests into their individual messages.
X# Don't do this if you use a global lockfile before this recipe (deadlock)
X
X:
X^Subject:.*Digest
X|formail +1 -d -s procmail
X
XLOGFILE=$MAILDIR/from		# Put it here, in order to avoid logging
X				# the arrival of the digest.
X
X# An alternative and probably more efficient solution to splitting up a digest
X# would be (only works for standard format mailbox files though):
X
X::
X^Subject:.*Other Digest
X|formail +1 -ds cat >>this_lists_mailbox
X
X# Notice the double : in the next recipe, this will cause a lockfile
X# named "$MAILDIR/todd.lock" to be used if and only if this mail is going
X# into the file "todd".
X
X::				# Anything from thf
X^From.*thf@somewhere.someplace
Xtodd				# will go to $MAILDIR/todd
X
X
X# The next recipe will likewise use $MAILDIR/uunetbox.lock as a lock file.
X
X::				# Anything from people at uunet
X^From.*@uunet
Xuunetbox			# will go to $MAILDIR/uunetbox
X
X
X# And here the lockfile will be $MAILDIR/henries.lock of course.
X
X::				# Anything from Henry
X^From.*henry
Xhenries				# will go to $MAILDIR/henries
X
X
X# But you can specify any lockfile you want, like "myfile".  The following
X# recipe will use "$MAILDIR/myfile" as the lock file.
X
X::myfile			# All 'questions' will go to
X^Subject:.*questions
Xtoread				# $MAILDIR/toread
X
X# Anything that has not been delivered by now will go to $DEFAULT
X
X# After procmail sees the end of the rcfile, it pretends that it sees a
X# LOCKFILE=$DEFAULT$LOCKEXT
X# Therefore $DEFAULT is always locked.
END_OF_FILE
if test 1970 -ne `wc -c <'procmail/examples/2procmailrc'`; then
    echo shar: \"'procmail/examples/2procmailrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/2procmailrc'
fi
if test -f 'procmail/examples/2rmail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/2rmail'\"
else
echo shar: Extracting \"'procmail/examples/2rmail'\" \(392 characters\)
sed "s/^X//" >'procmail/examples/2rmail' <<'END_OF_FILE'
X#!/bin/sh
X#
X# specify the mailbox file you want to read on the command line
X#
XMAILDIR=$HOME/Mail
Xcd $MAILDIR
XLOCKFILE=$1.lock
Xif lockfile -! -r1 $LOCKFILE
Xthen
X echo Mail is currently arriving, please wait...
X while
X   lockfile -! -4 -r2 $LOCKFILE
X do
X echo Mail is still arriving...
X done
Xfi
Xtrap "rm -f $LOCKFILE;exit 0" 0 1 2 3 15
X#
X# Call you favourite mailer here.
X#
X/usr/ucb/mail -f $*
END_OF_FILE
if test 392 -ne `wc -c <'procmail/examples/2rmail'`; then
    echo shar: \"'procmail/examples/2rmail'\" unpacked with wrong size!
fi
# end of 'procmail/examples/2rmail'
fi
if test -f 'procmail/examples/3procmailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/3procmailrc'\"
else
echo shar: Extracting \"'procmail/examples/3procmailrc'\" \(1517 characters\)
sed "s/^X//" >'procmail/examples/3procmailrc' <<'END_OF_FILE'
X# Please check if all the paths in PATH are reachable, remove the ones that
X# are not.
X
XPATH=$HOME/bin:/usr/bin:/global/bin:/usr/ucb:/bin:/usr/local/bin:
XMAILDIR =	$HOME/Mail	# You'd better make sure it exists
XDEFAULT =	$MAILDIR/mbox
XLOGFILE =	$MAILDIR/from
XLOCKFILE=	$HOME/.lockmail
X
X			# This will create a local lockfile named todd.lock
X::			# *if* the condition matches
X^From.*thf
Xtodd
X
XLOCKFILE=$MAILDIR/whatever	# This will remove the global lockfile
X				# $HOME/.lockmail and the new lockfile
X				# will be $MAILDIR/whatever
X
X
X				# The next recipe will
X				# filter out all messages from "at"
X				# jobs and will put them in a terse format
X				# (only the date and the body) in
X				# a file called $MAILDIR/atjunk
X: 2 fh
X^From root
X^Subject: Output from "at" job
X|egrep "^Date:"
X				# The next recipe will only be used if
X				# the previous one matched
X:A
Xatjunk
X
X
X
XMAILDIR=$HOME/News	# This will change the current directory
X
X
X			# The next recipe will create a local lockfile
X			# named $HOME/News/dustbin.lock (*if* the condition
X			# matches), and will feed the body of the message
X			# through `sort` (sorry, couldn't come up with anything
X			# better :-), after which the result will be
X			# appended to $HOME/News/dustbin
X:b:
X^Subject:.*rubbish
X|sort >>dustbin
X
X			# The next recipe will use the play directory as a MH
X			# folder (of course you need MH to read the mail then)
X:
X^Subject:.*games
Xgames/.
X
X# Anything not delivered by now will go to $HOME/Mail/mbox
X# Using LOCKFILE=$HOME/Mail/mbox.lock
END_OF_FILE
if test 1517 -ne `wc -c <'procmail/examples/3procmailrc'`; then
    echo shar: \"'procmail/examples/3procmailrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/3procmailrc'
fi
if test -f 'procmail/examples/3rmail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/3rmail'\"
else
echo shar: Extracting \"'procmail/examples/3rmail'\" \(757 characters\)
sed "s/^X//" >'procmail/examples/3rmail' <<'END_OF_FILE'
X#!/bin/sh
X#
X# specify the mailbox file you want to read on the command line
X# Use a relative path from your $HOME directory
X#
X# For this kind of chaotic procmailrc there is no uniform neat solution
X# to determine which lockfiles to use.	I'll give just one (suboptimal)
X# solution here.  Use your imagination to extend it :-).
X#
XMAILDIR=$HOME/Mail
Xcd $HOME			# this means all paths are relative to $HOME
XLOCKFILE=$HOME/.lockmail
XLOCKFILE2=$HOME/Mail/whatever
Xif lockfile -! -r1 $LOCKFILE $LOCKFILE2
Xthen
X echo Mail is currently arriving, please wait...
X while
X   lockfile -! -4 -r2 $LOCKFILE $LOCKFILE2
X do
X echo Mail is still arriving...
X done
Xfi
Xtrap "rm -f $LOCKFILE $LOCKFILE2;exit 0" 0 1 2 3 15
X#
X# Call you favourite mailer here.
X#
X/usr/ucb/mail -f $*
END_OF_FILE
if test 757 -ne `wc -c <'procmail/examples/3rmail'`; then
    echo shar: \"'procmail/examples/3rmail'\" unpacked with wrong size!
fi
# end of 'procmail/examples/3rmail'
fi
if test -f 'procmail/examples/forward' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/forward'\"
else
echo shar: Extracting \"'procmail/examples/forward'\" \(57 characters\)
sed "s/^X//" >'procmail/examples/forward' <<'END_OF_FILE'
X"|IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME"
END_OF_FILE
if test 57 -ne `wc -c <'procmail/examples/forward'`; then
    echo shar: \"'procmail/examples/forward'\" unpacked with wrong size!
fi
# end of 'procmail/examples/forward'
fi
if test -f 'procmail/examples/listrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/listrc'\"
else
echo shar: Extracting \"'procmail/examples/listrc'\" \(1856 characters\)
sed "s/^X//" >'procmail/examples/listrc' <<'END_OF_FILE'
XPATH=/bin:/usr/bin:/usr/local/bin	# add more if appropriate
XSHELL=/bin/sh
X
X# list		should contain the submitting address of the list
X# listreq	should contain the request address of the list
X# subscribers	should name the file which contains the list of subscribers
X#		separated by whitespace
X
X:3wfh
X!^Subject:.*((add|remove).*list|subscribe)
X!^From +(postmaster|Mailer)
X!^X-Loop: loop
X| formail -b -IReturn-Receipt-To: -I"Errors-To: $listreq" \
X  -I "Sender: $listreq" -I"Precedence: bulk" -IReceived: -I"X-Loop: loop"\
X# -i "Reply-To: $list"			# uncomment if you want, many people
X					# consider this a bad idea.
X
X# If memberlist is longer than 2048 bytes, you will have to insert a
X# LINEBUF=some_big_number here because procmail uses a buffer of size
X# $LINEBUF to expand the inline 'cat'
X
X:Aw
X! -f$listreq `cat $subscribers`		# the -f and -oi are sendmail options
X					# omit if not applicable
X	# the -f flag will only take effect if the sender is not local
X
X# Alternatively you could have put the burden on the shell for expanding the
X# 'cat' by providing the following action line instead:
X# | $SENDMAIL -oi `cat $subscribers`;	# the ; forces the procmail to pass
X					# on the line to the shell unparsed
X
X# Anything not delivered yet (either because it was from the postmaster
X# or mailer-daemon, or because it might be a request-message) will be forwarded
X# to the list maintainer:
X:0w
X! -oi $listreq
X
X# In case not even this works, the mail will be appended to the
X# following last-resort files
X
XUMASK=666	# this is probably inevitable since procmail (in this case)
X		# could be running under the local-sender's uid or the
X		# daemon or mailer-uid (in the remote-sender's case)
X
XDEFAULT=/usr/tmp/${listreq}s		# first-choice
XORGMAIL=/tmp/${listreq}s		# a last-last-resort-file in case the
X			# filesystem for /usr/tmp/mylist-request should be full
END_OF_FILE
if test 1856 -ne `wc -c <'procmail/examples/listrc'`; then
    echo shar: \"'procmail/examples/listrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/listrc'
fi
if test -f 'procmail/exopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/exopen.c'\"
else
echo shar: Extracting \"'procmail/exopen.c'\" \(2227 characters\)
sed "s/^X//" >'procmail/exopen.c' <<'END_OF_FILE'
X/************************************************************************
X *	Collection of NFS secure exclusive open routines		*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	The sources can be freely copied for non-commercial use.	*
X *	#include "README"						*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: exopen.c,v 2.11 1992/04/21 15:27:50 berg Rel $";
X#endif
X#include "config.h"
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
Xconst char*hostname();
Xextern pid_t thepid;
Xextern const char dirsep[];
X
Xconst char*hostname()
X{ static char name[HOSTNAMElen+1];
X#ifdef	NOuname
X  gethostname(name,HOSTNAMElen+1);
X#else
X  struct utsname names;
X  uname_(&names);strncpy(name,names.nodename,HOSTNAMElen);
X#endif
X  name[HOSTNAMElen]='\0';return name;
X}
X
Xultoan(val,dest)unsigned long val;char*dest;	      /* convert to a number */
X{ register i;				     /* within the set [0-9A-Za-z-_] */
X  do
X   { i=val&0x3f;
X     *dest++=i+(i<10?'0':i<10+26?'A'-10:i<10+26+26?'a'-10-26:
X      i==10+26+26?'-'-10-26-26:'_'-10-26-27);
X   }
X  while(val>>=6);
X  *dest='\0';
X}
X
Xunique(full,p,mode)const char*const full;char*const p;const mode_t mode;
X{ unsigned long retry=mrotbSERIAL;int i;	  /* create unique file name */
X  do
X   { ultoan(maskSERIAL&(retry<<bitsSERIAL-mrotbSERIAL)+
X      (unsigned long)thepid,p+1);
X     *p=UNIQ_PREFIX;strcat(p,hostname());
X   }
X#ifndef O_CREAT
X#define ropen(path,type,mode)	creat(path,mode)
X#endif
X  while(0>(i=ropen(full,O_WRONLY|O_CREAT|O_EXCL|O_SYNC,mode))&&errno==EEXIST&&
X   retry--);	    /* casually check if it already exists (highly unlikely) */
X  if(i<0)
X   { writeerr(full);return 0;
X   }
X  rclose(i);return 1;
X}
X				     /* rename MUST fail if already existent */
Xmyrename(old,newn)const char*const old,*const newn;
X{ int i,serrno;struct stat stbuf;
X  link(old,newn);serrno=errno;i=stat(old,&stbuf);unlink(old);errno=serrno;
X  return stbuf.st_nlink==2?i:-1;
X}
X
Xchar*lastdirsep(filename)const char*filename;	 /* finds the next character */
X{ const char*p;					/* following the last DIRSEP */
X  while(p=strpbrk(filename,dirsep))
X     filename=p+1;
X  return(char*)filename;
X}
END_OF_FILE
if test 2227 -ne `wc -c <'procmail/exopen.c'`; then
    echo shar: \"'procmail/exopen.c'\" unpacked with wrong size!
fi
# end of 'procmail/exopen.c'
fi
if test -f 'procmail/exopen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/exopen.h'\"
else
echo shar: Extracting \"'procmail/exopen.h'\" \(284 characters\)
sed "s/^X//" >'procmail/exopen.h' <<'END_OF_FILE'
X/*$Id: exopen.h,v 2.4 1992/04/21 15:27:50 berg Rel $*/
X#define charsSERIAL	4
X#define UNIQnamelen	(1+charsSERIAL+HOSTNAMElen+1)
X#define bitsSERIAL	(6*charsSERIAL)
X#define maskSERIAL	((1L<<bitsSERIAL)-1)
X#define rotbSERIAL	2
X#define mrotbSERIAL	((1L<<rotbSERIAL)-1)
X
Xchar*lastdirsep();
END_OF_FILE
if test 284 -ne `wc -c <'procmail/exopen.h'`; then
    echo shar: \"'procmail/exopen.h'\" unpacked with wrong size!
fi
# end of 'procmail/exopen.h'
fi
if test -f 'procmail/lockfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/lockfile.c'\"
else
echo shar: Extracting \"'procmail/lockfile.c'\" \(3742 characters\)
sed "s/^X//" >'procmail/lockfile.c' <<'END_OF_FILE'
X/************************************************************************
X *	lockfile.c	a conditional semaphore-file creator		*
X *									*
X *	It has been designed to be able to be run suid/sgid root or	*
X *	any id you see fit (in case your mail spool area is *not*	*
X *	world writeable), without creating security holes.		*
X *									*
X *	Seems to be perfect.						*
X *									*
X *	Created by S.R. van den Berg, The Netherlands			*
X *	This file can be freely copied for any use.			*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: lockfile.c,v 2.13 1992/04/21 15:27:50 berg Rel $";
X#endif
Xstatic char rcsdate[]="$Date: 1992/04/21 15:27:50 $";
X#include "config.h"
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
Xvolatile int exitflag;
Xpid_t thepid;
Xchar system_mbox[]=SYSTEM_MBOX;
Xconst char dirsep[]=DIRSEP,lockext[]=DEFlockext;
X
Xvoid failure()
X{ exitflag=1;
X}
X
Xmain(argc,argv)const char*const argv[];
X{ const char*const*p,*cp;uid_t uid;
X  int sleepsec,retries,invert,force,suspend,retval=0,virgin=0;
X  static char usage[]=
X  "Usage: lockfile -nnn | -rnnn | -! | -lnnn | -snnn | -ml | -mu | file ...\n";
X  sleepsec=8;force=retries=invert=0;suspend=16;thepid=getpid();uid=getuid();
X  *lastdirsep(system_mbox)='\0';
X  if(--argc<=0)
X   { putse(usage);return EX_USAGE;
X   }
Xagain:
X  p=argv;signal(SIGHUP,(void(*)())failure);signal(SIGINT,(void(*)())failure);
X  signal(SIGQUIT,(void(*)())failure);signal(SIGTERM,(void(*)())failure);
X  while(argc--)
X     if(*(cp= *++p)=='-')
X	switch(cp[1])
X	 { case '!':invert=1;break;
X	   case 'r':retries=strtol(cp+2,(char**)0,10);break;
X	   case 'l':force=strtol(cp+2,(char**)0,10);break;
X	   case 's':suspend=strtol(cp+2,(char**)0,10);break;
X	   case 'm':
X	    { struct passwd*pass;char*ma;
X	      if(virgin||!(pass=getpwuid(uid))||
X	       !(ma=malloc(strlen(system_mbox)+strlen(pass->pw_name)+
X	       STRLEN(lockext)+1)))
X		 goto eusg;
X	      strcpy(ma,system_mbox);strcat(ma,pass->pw_name);
X	      strcat(ma,lockext);
X	      if(cp[2]=='u')
X	       { unlink(ma);break;
X	       }
X	      if(cp[2]=='l')
X	       { cp=ma;goto stilv;
X	       }
X	      goto eusg;
X	    }
X	   default:
X	      if(cp[1]-'0'>(unsigned)9)
Xeusg:	       { putse(usage);retval=EX_USAGE;goto lfailure;
X	       }
X	      if(sleepsec>=0)
X		 sleepsec=strtol(cp+1,(char**)0,10);
X	 }
X     else if(sleepsec<0)
X	unlink(cp);
X     else
X      { time_t t;
X	setgid(getgid());setuid(uid);
Xstilv:	virgin=1;
X	while(0>NFSxopen(cp,&t))
X	 { struct stat buf;
X	   if(exitflag||retries==1)
Xlfailure:   { sleepsec= -1;argc=p-argv-1;goto again;
X	    }
X	   if(force&&!stat(cp,&buf)&&force<t-buf.st_mtime)
X	    { unlink(cp);putse("lockfile: Forcing lock on \"");putse(cp);
X	      putse("\"\n");sleep(suspend);
X	    }
X	   else
X	      sleep(sleepsec);
X	   if(retries)
X	      retries--;
X	 }
X      }
X  return retval?retval:invert^(sleepsec<0)?EX_CANTCREAT:EX_OK;
X}
X
Xputse(a)char*a;
X{ char*b;
X  b=a-1;
X  while(*++b);
X  write(STDERR,a,(size_t)(b-a));
X}
X
XNFSxopen(name,tim)char*name;time_t*const tim;
X{ char*p,*q;int j= -1,i;struct stat stbuf;
X  for(q=name;p=strpbrk(q,dirsep);q=p+1);
X  i=q-name;
X  if(!(p=malloc(i+UNIQnamelen)))
X     return exitflag=1;
X  strncpy(p,name,i);
X  if(unique(p,p+i,0))
X     stat(p,&stbuf),*tim=stbuf.st_mtime,j=myrename(p,name);
X  free(p);return j;
X}
X
Xvoid*tmalloc(len)const size_t len;				     /* stub */
X{ return malloc(len);
X}
X
Xropen(name,mode,mask)const char*const name;const int mode;const mode_t mask;
X{ return open(name,mode,mask);					     /* stub */
X}
X
Xrclose(fd)const int fd;						     /* stub */
X{ return close(fd);
X}
X
Xwriteerr(a)const char*const a;					     /* stub */
X{
X}
END_OF_FILE
if test 3742 -ne `wc -c <'procmail/lockfile.c'`; then
    echo shar: \"'procmail/lockfile.c'\" unpacked with wrong size!
fi
# end of 'procmail/lockfile.c'
fi
if test ! -d 'procmail/man' ; then
    echo shar: Creating directory \"'procmail/man'\"
    mkdir 'procmail/man'
fi
if test -f 'procmail/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/patchlevel.h'\"
else
echo shar: Extracting \"'procmail/patchlevel.h'\" \(168 characters\)
sed "s/^X//" >'procmail/patchlevel.h' <<'END_OF_FILE'
X#define VERSION \
X"procmail v2.70 1992/04/30 written by Stephen R. van den Berg\n\
X\t\t\t\tberg@pool.informatik.rwth-aachen.de\n\
X\t\t\t\tberg@physik.tu-muenchen.de\n"
END_OF_FILE
if test 168 -ne `wc -c <'procmail/patchlevel.h'`; then
    echo shar: \"'procmail/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'procmail/patchlevel.h'
fi
if test -f 'procmail/procmail.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/procmail.h'\"
else
echo shar: Extracting \"'procmail/procmail.h'\" \(2987 characters\)
sed "s/^X//" >'procmail/procmail.h' <<'END_OF_FILE'
X/*$Id: procmail.h,v 2.19 1992/04/23 16:46:41 berg Rel $*/
X
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
Xtypedef unsigned char uschar;	     /* sometimes uchar is already typedef'd */
X#ifdef uchar
X#undef uchar
X#endif
X#define uchar uschar
X
X#ifdef console
X#define vconsole (verbose=1,console)
X#else
X#define vconsole devnull
X#endif
X
X#ifndef DEFsendmail
X#define DEFsendmail SENDMAIL
X#endif
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
X#ifdef sMAILBOX_SEPARATOR
X#define smboxseparator(fd)	\
X (tofolder?rwrite(fd,sMAILBOX_SEPARATOR,STRLEN(sMAILBOX_SEPARATOR)):0)
X#define emboxseparator(fd)	\
X (tofolder?rwrite(fd,eMAILBOX_SEPARATOR,STRLEN(eMAILBOX_SEPARATOR)):0)
X#else
X#define smboxseparator(fd)
X#define emboxseparator(fd)
X#endif
X
X#ifndef KERNEL_LOCKS
X#define fdlock(fd)	0
X#define fdunlock()	0
X#else
X#ifndef SYS_FILE_H_MISSING
X#include <sys/file.h>
X#endif
X#endif
X
X#define XTRAlinebuf	2	     /* surplus of LINEBUF (see readparse()) */
X#define TMNATE		'\377'		     /* terminator (see readoarse()) */
X
X#define PRDO	poutfd[0]
X#define PWRO	poutfd[1]
X#define PRDI	pinfd[0]
X#define PWRI	pinfd[1]
X#define PRDB	pbackfd[0]
X#define PWRB	pbackfd[1]
X#define LENoffset	(TABWIDTH*LENtSTOP)
X#define MAXfoldlen	(LENoffset-STRLEN(sfolder)-1)
X#define MCDIRSEP	(dirsep+STRLEN(dirsep)-1)      /* most common DIRSEP */
X
X#define lck_LOCKFILE	1	  /* crosscheck the order of this with msg[] */
X#define lck_ALLOCLIB	2		      /* in sterminate() in retint.c */
X#define lck_MEMORY	4
X#define lck_FORK	8
X#define lck_FILDES	16
X#define lck_KERNELL	32
X
Xstruct varval{const char*const name;long val;};
X#define locksleep	(strenvvar[0].val)
X#define locktimeout	(strenvvar[1].val)
X#define suspendv	(strenvvar[2].val)
X#define noresretry	(strenvvar[3].val)
X#define timeoutv	(strenvvar[4].val)
X#define MAXvarvals	maxindex(strenvvar)
X
X#ifndef MAIN
Xextern char*buf,*buf2,*globlock,*loclock,*tolock,*lastfolder;
Xextern const char shellflags[],shell[],lockext[],newline[],binsh[],
X unexpeof[],shellmetas[],*const*gargv,*sgetcp,*rcfile,dirsep[],msgprefix[],
X devnull[],executing[],oquote[],cquote[],whilstwfor[],procmailn[],Mail[];
Xextern struct varval strenvvar[];
Xextern long lastdump;
Xextern sh,pwait,retval,retvl2,lcking,locknext,verbose,linebuf,rc,tofolder,
X tofile,ignwerr,fakedelivery;
Xextern volatile nextexit;
Xextern volatile time_t alrmtime;
Xextern pid_t thepid,pidchild;
X#endif
X
X#ifdef NOmemmove
Xvoid*smemmove();
X#endif
X#ifdef strtol
X#undef strtol
X#define NOstrtol
Xlong strtol();
X#endif
X
Xvoid*tmalloc(),*trealloc(),*bregcomp(),srequeue(),slose(),sbounce(),
X stermchild(),ftimeout();
Xpid_t sfork();
Xlong dump(),pipin(),renvint();
Xchar*readdyn(),*fromprog(),*cat(),*tstrdup(),*cstr(),*pstrspn(),
X *bregexec(),*egrepin();
Xconst char*tgetenv(),*hostname();
Xint sgetc(),getb();
X
X/*
X *	External variables that are checked/changed by the signal handlers:
X *	volatile time_t alrmtime;
X *	pid_t pidfilt,pidchild;
X *	volatile int nextexit;
X *	int lcking;
X *	static volatile mailread;	in procmail.c
X */
END_OF_FILE
if test 2987 -ne `wc -c <'procmail/procmail.h'`; then
    echo shar: \"'procmail/procmail.h'\" unpacked with wrong size!
fi
# end of 'procmail/procmail.h'
fi
if test -f 'procmail/recommend.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/recommend.c'\"
else
echo shar: Extracting \"'procmail/recommend.c'\" \(2226 characters\)
sed "s/^X//" >'procmail/recommend.c' <<'END_OF_FILE'
X/************************************************************************
X *	recommend.c	analyses the installation, and makes		*
X *			recommendations about suid/sgid modes		*
X ************************************************************************/
X/*$Id: recommend.c,v 2.3 1992/04/29 15:54:33 berg Rel $*/
X#include "config.h"
X#include "includes.h"				       /* also for fprintf() */
X#include "strpbrk.h"
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
X#define PERMIS	(S_IRWXU|S_IRWXG&~S_IWGRP|S_IRWXO&~S_IWOTH)
X
Xchar system_mbox[]=SYSTEM_MBOX;
Xconst char dirsep[]=DIRSEP,
X *const checkf[]={"/bin/mail","/bin/lmail","/usr/lib/sendmail",
X "/usr/lib/smail",0};
X			     /* lastdirsep() has been lifted out of exopen.c */
Xchar*lastdirsep(filename)const char*filename;	 /* finds the next character */
X{ const char*p;					/* following the last DIRSEP */
X  while(p=strpbrk(filename,dirsep))
X     filename=p+1;
X  return(char*)filename;
X}
X
Xmain(argc,argv)const int argc;const char*const argv[];
X{ struct passwd*pass;struct group*grp;struct stat stbuf;
X  uid_t uid=ROOT_uid;gid_t gid=NOBODY_gid;const char*const*p;
X  mode_t suid=0,sgid=0;
X  if(argc!=3)
X   { fprintf(stderr,"Please run this program via 'make recommend'\n");
X     return EX_USAGE;
X   }
X  *lastdirsep(system_mbox)='\0';
X  for(p=checkf;*p;++p)
X     if(!stat(*p,&stbuf)&&stbuf.st_mode&(S_ISUID|S_ISGID))
X      { if(stbuf.st_mode&S_ISUID&&stbuf.st_uid!=ROOT_uid)
X	   suid=S_ISUID,uid=stbuf.st_uid;
X	if(stbuf.st_mode&S_ISGID)
X	   sgid=S_ISGID,gid=stbuf.st_gid;
X	break;
X      }
X  if(!stat(system_mbox,&stbuf)&&!(stbuf.st_mode&S_IWOTH))
X     if(stbuf.st_mode&S_IWGRP)
X	sgid=S_ISGID,gid=stbuf.st_gid;
X     else
X	suid=S_ISUID,uid=stbuf.st_uid;
X  if(gid!=stbuf.st_gid)
X     sgid=0;
X  printf("chown root %s\n",argv[1]);
X  if(suid)
X     if(pass=getpwuid(uid))
X	printf("chown %s %s\n",pass->pw_name,argv[2]);
X     else
X	printf("chown %u %s\n",(int)uid,argv[2]);
X  if(sgid)
X     if(grp=getgrgid(gid))
X	printf("chgrp %s %s %s\n",grp->gr_name,argv[1],argv[2]);
X     else
X	printf("chgrp %u %s %s\n",(int)gid,argv[1],argv[2]);
X  printf("chmod %o %s\n",sgid|S_ISUID|PERMIS,argv[1]);
X  if(suid||sgid)
X     printf("chmod %o %s\n",suid|sgid|PERMIS,argv[2]);
X  return EX_OK;
X}
END_OF_FILE
if test 2226 -ne `wc -c <'procmail/recommend.c'`; then
    echo shar: \"'procmail/recommend.c'\" unpacked with wrong size!
fi
# end of 'procmail/recommend.c'
fi
if test -f 'procmail/strpbrk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/strpbrk.c'\"
else
echo shar: Extracting \"'procmail/strpbrk.c'\" \(344 characters\)
sed "s/^X//" >'procmail/strpbrk.c' <<'END_OF_FILE'
X/*$Id: strpbrk.c,v 1.3 1992/04/23 16:46:41 berg Rel $*/
X#include "includes.h"
X#include "strpbrk.h"
X
X#ifdef NOstrpbrk
Xchar*strpbrk(st,del)const char*const st,*del;
X{ const char*f=0,*t;
X  for(f=0;*del;)
X     if((t=strchr(st,*del++))&&(!f||t<f))
X	f=t;
X  return(char*)f;
X}
X#else
Xchar dummy_strpbrk;			/* to keep some linkers from choking */
X#endif
END_OF_FILE
if test 344 -ne `wc -c <'procmail/strpbrk.c'`; then
    echo shar: \"'procmail/strpbrk.c'\" unpacked with wrong size!
fi
# end of 'procmail/strpbrk.c'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de

"I have a *cunning* plan!"

exit 0 # Just in case...
