Newsgroups: comp.sources.misc
From: stein.wbst129@xerox.com (Adam Stein)
Subject:  v29i054:  persim - Single-Layer Perceptron Simulator, Part01/03
Message-ID: <csm-v29i054=persim.204901@sparky.IMD.Sterling.COM>
X-Md4-Signature: e53a6e63eaa1f62270d48c2478f1c261
Date: Sun, 5 Apr 1992 02:50:16 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: stein.wbst129@xerox.com (Adam Stein)
Posting-number: Volume 29, Issue 54
Archive-name: persim/part01
Environment: BSD

Persim is a single-layer perceptron simulator that I had to write for a
neural networks class.  Included are 2 examples to show that it works (and to
show how to use it).

I hope it can be of some use.

        Adam Stein
        stein.wbst129@xerox.com

---- Cut Here and feed the following to sh ----
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  README example1 example1/output4 example2 is.c persim.1
#   persim.h read.c run.c set.c show.c write.c
# Wrapped by kent@sparky on Sat Apr  4 20:29:30 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1555 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the README file for persim.
X
XAuthor:
X
X  Adam Stein (stein.wbst129@xerox.com)
X
XCopyright:
X
X  Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
XDescription:
X
X  This program will simulate a single-layer perceptron.  This
X  includes training as well as testing.  The convergence
X  procedure used for training was developed by R. Rosenblatt.
X
X  See the man page for more details.
X
XInstallation:
X
X  This program has only been compiled and tested on BSD or BSD/SYS5
X  mixed systems.  I have no idea what would have to be changed for
X  a SYS5 only system (probably only index to strchr and that sort of
X  stuff).  To compile use:
X
X		make
X
X  and to install the program and man page use
X
X		make install
X
XBugs/Additions:
X
X  While I don't plan on supporting this, I would appreciate
X  knowing about any bug fixes or any enhancements made.
X  I would like to keep a centralized version with the
X  upgrades so that there aren't 50 million versions posted
X  to the net.
X
X  I hope this program is of use to you, either in it's capacity or as simple
X  example in single-layer perceptrons.
X
END_OF_FILE
  if test 1555 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test ! -d 'example1' ; then
    echo shar: Creating directory \"'example1'\"
    mkdir 'example1'
fi
if test -f 'example1/output4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'example1/output4'\"
else
  echo shar: Extracting \"'example1/output4'\" \(5140 characters\)
  sed "s/^X//" >'example1/output4' <<'END_OF_FILE'
Xpersim> inodes=3
Xpersim> onodes=1
Xpersim> alpha=0.01
Xpersim> node function step
Xpersim> load input "input4.asc",asc
Xpersim> load desired "desired4.asc",asc
Xpersim> load weights "weights.asc",asc
Xpersim> run verbose
XEpoch #1:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.376465
X  [New] From #2, To #1, Weight = 0.812299
X  [New] From #3, To #1, Weight = 0.352806
X
XEpoch #2:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.356465
X  [New] From #2, To #1, Weight = 0.784112
X  [New] From #3, To #1, Weight = 0.352275
X
XEpoch #3:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.336465
X  [New] From #2, To #1, Weight = 0.755926
X  [New] From #3, To #1, Weight = 0.351745
X
XEpoch #4:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.316465
X  [New] From #2, To #1, Weight = 0.727739
X  [New] From #3, To #1, Weight = 0.351215
X
XEpoch #5:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.296465
X  [New] From #2, To #1, Weight = 0.699553
X  [New] From #3, To #1, Weight = 0.350684
X
XEpoch #6:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.276465
X  [New] From #2, To #1, Weight = 0.671366
X  [New] From #3, To #1, Weight = 0.350154
X
XEpoch #7:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.256465
X  [New] From #2, To #1, Weight = 0.643180
X  [New] From #3, To #1, Weight = 0.349624
X
XEpoch #8:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.236465
X  [New] From #2, To #1, Weight = 0.614993
X  [New] From #3, To #1, Weight = 0.349093
X
XEpoch #9:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.216465
X  [New] From #2, To #1, Weight = 0.586807
X  [New] From #3, To #1, Weight = 0.348563
X
XEpoch #10:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.196465
X  [New] From #2, To #1, Weight = 0.558620
X  [New] From #3, To #1, Weight = 0.348033
X
XEpoch #11:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.176465
X  [New] From #2, To #1, Weight = 0.530434
X  [New] From #3, To #1, Weight = 0.347502
X
XEpoch #12:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.156465
X  [New] From #2, To #1, Weight = 0.502247
X  [New] From #3, To #1, Weight = 0.346972
X
XEpoch #13:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.136465
X  [New] From #2, To #1, Weight = 0.474061
X  [New] From #3, To #1, Weight = 0.346442
X
XEpoch #14:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.116465
X  [New] From #2, To #1, Weight = 0.445874
X  [New] From #3, To #1, Weight = 0.345912
X
XEpoch #15:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.096465
X  [New] From #2, To #1, Weight = 0.417688
X  [New] From #3, To #1, Weight = 0.345381
X
XEpoch #16:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.076465
X  [New] From #2, To #1, Weight = 0.389501
X  [New] From #3, To #1, Weight = 0.344851
X
XEpoch #17:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.056465
X  [New] From #2, To #1, Weight = 0.361315
X  [New] From #3, To #1, Weight = 0.344321
X
XEpoch #18:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.036465
X  [New] From #2, To #1, Weight = 0.333128
X  [New] From #3, To #1, Weight = 0.343790
X
XEpoch #19:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = 0.016465
X  [New] From #2, To #1, Weight = 0.304942
X  [New] From #3, To #1, Weight = 0.343260
X
XEpoch #20:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.003535
X  [New] From #2, To #1, Weight = 0.276755
X  [New] From #3, To #1, Weight = 0.342730
X
XEpoch #21:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.023535
X  [New] From #2, To #1, Weight = 0.248569
X  [New] From #3, To #1, Weight = 0.342199
X
XEpoch #22:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.043535
X  [New] From #2, To #1, Weight = 0.220382
X  [New] From #3, To #1, Weight = 0.341669
X
XEpoch #23:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.063535
X  [New] From #2, To #1, Weight = 0.192196
X  [New] From #3, To #1, Weight = 0.341139
X
XEpoch #24:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.083535
X  [New] From #2, To #1, Weight = 0.164009
X  [New] From #3, To #1, Weight = 0.340608
X
XEpoch #25:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.103535
X  [New] From #2, To #1, Weight = 0.135823
X  [New] From #3, To #1, Weight = 0.340078
X
XEpoch #26:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.123535
X  [New] From #2, To #1, Weight = 0.107637
X  [New] From #3, To #1, Weight = 0.339548
X
XEpoch #27:
X  Actual Output Node #1 = 1.000000
X
X  [New] From #1, To #1, Weight = -0.143535
X  [New] From #2, To #1, Weight = 0.079450
X  [New] From #3, To #1, Weight = 0.339017
X
XEpoch #28:
X  Actual Output Node #1 = -1.000000
X
X  [New] From #1, To #1, Weight = -0.143535
X  [New] From #2, To #1, Weight = 0.079450
X  [New] From #3, To #1, Weight = 0.339017
X
Xpersim> save weights "weights.asc",asc
Xpersim> exit
END_OF_FILE
  if test 5140 -ne `wc -c <'example1/output4'`; then
    echo shar: \"'example1/output4'\" unpacked with wrong size!
  fi
  # end of 'example1/output4'
fi
if test ! -d 'example2' ; then
    echo shar: Creating directory \"'example2'\"
    mkdir 'example2'
fi
if test -f 'is.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'is.c'\"
else
  echo shar: Extracting \"'is.c'\" \(4473 characters\)
  sed "s/^X//" >'is.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include "persim.h"
X#include "commands.h"
X#include "grammar.h"
X
X/*This routine will determine if a string of characters is a keyword.
X
X  Inputs:  numargs   - (return value)
X	   string    - string of characters to identify as a keyword or not
X  Outputs: numargs   - number of arguments this keyword takes
X  Locals:  loop      - loop through list of keywords
X	   pointer   - pointer to each keyword in list to compare
X  Globals: cmd       - name of keyword
X	   AMBIGUOUS - not enough of a keyword was given to distiguish it
X	   NUM_CMDS  - total number of commands available
X	   UNKNOWN   - string is not a keyword
X*/
Xiskeyword(string,numargs)
Xregister int *numargs;
Xregister char *string;
X{
X	register int loop;
X	register char *pointer;
X	char *strstr();
X
X	/*Look for a match*/
X	for(loop = 0;loop < NUM_CMDS;++loop)
X	  if((pointer = strstr(cmd[loop].name,string)) == cmd[loop].name)
X	    break;
X
X	/*If didn't find a match, string is unknown*/
X	if(loop == NUM_CMDS) loop = UNKNOWN;
X	else {
X	       /*Find out if the 'match' matched more than 1 item (ambiguous)*/
X	       if((loop == (NUM_CMDS - 1)) ||
X		  (strstr(cmd[loop + 1].name,string) != cmd[loop + 1].name))
X	         *numargs = cmd[loop].numargs;
X	       else loop = AMBIGUOUS;
X	     }
X
X	return(loop);
X}
X
X/*This routine will check to see if a string of characters is a qualifier.
X
X  Inputs:  type           - (return value)
X	   string         - string of characters to identify as a keyword or not
X  Outputs: type           - type of qualifier (used in grammar.y)
X  Locals:  loop           - loop through list of keywords
X	   pointer        - pointer to each keyword in list to compare
X  Globals: AMBIGUOUS	  - not enough of a qualifier was given to distiguish it
X	   ASCII	  - qualifier relates to an ascii filetype
X	   BINARY	  - qualifier relates to a binary filetype
X	   DATA   	  - data attribute (used in grammar.y)
X	   DESIRED	  - qualifier relates to desired output values
X	   FILETYPE   	  - filetype attribute (used in grammar.y)
X	   FUNC_ATTR	  - function attribute (used in grammar.y)
X	   FUNCTION	  - qualifier relates to a node's function
X	   INPUT	  - qualifier relates to input values
X	   NOTFILE	  - loading values is not coming from a file (grammar.y)
X	   NUM_QUALIFIERS - total number of qualifiers
X	   OUTPUT	  - qualifier relates to output values
X	   SYS_VARS       - qualifier relates to system variables
X	   RANDOM         - qualifier relates to using random values
X	   STDIN          - qualifier relates to loading values from keyboard
X	   THRESHOLD      - qualifier relates to threshold value
X	   THRESHOLD_ATTR - threshold attribute (used in grammar.y)
X	   WEIGHTS	  - qualifier relates to weights
X	   UNKNOWN        - string is not a qualifier
X	   VERBOSE	  - qualifier relates to verbosity of a command
X	   VERBOSE_ATTR   - verbose attribute (used in grammar.y)
X*/
Xisqualifier(string,type)
Xregister int *type;
Xregister char *string;
X{
X	register int loop;
X	register char *pointer;
X	char *strstr();
X
X	/*Look for a match*/
X	for(loop = 0;loop < NUM_QUALIFIERS;++loop)
X	  if((pointer = strstr(qual[loop],string)) == qual[loop])
X	    break;
X
X	/*If didn't find a match, string is unknown*/
X	if(loop == NUM_QUALIFIERS) loop = UNKNOWN;
X	else if((loop != (NUM_QUALIFIERS - 1)) &&
X		(strstr(qual[loop + 1],string) == qual[loop + 1]))
X	       loop = AMBIGUOUS;
X	     else loop += 50;
X
X	/*Find out which part of the grammar this qualifier belongs to*/
X	switch(loop) {
X	  case ASCII:
X	  case BINARY:
X			*type = FILETYPE;
X			break;
X	  case DESIRED:
X	  case INPUT:
X	  case OUTPUT:
X	  case SYS_VARS:
X	  case WEIGHTS:
X			*type = DATA;
X			break;
X	  case RANDOM:
X	  case STDIN:
X			*type = NOTFILE;
X			break;
X	  case FUNCTION:
X			*type = FUNC_ATTR;
X			break;
X	  case THRESHOLD:
X			*type = THRESHOLD_ATTR;
X			break;
X	  case VERBOSE:
X			*type = VERBOSE_ATTR;
X			break;
X	}
X
X	return(loop);
X}
X
END_OF_FILE
  if test 4473 -ne `wc -c <'is.c'`; then
    echo shar: \"'is.c'\" unpacked with wrong size!
  fi
  # end of 'is.c'
fi
if test -f 'persim.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'persim.1'\"
else
  echo shar: Extracting \"'persim.1'\" \(6994 characters\)
  sed "s/^X//" >'persim.1' <<'END_OF_FILE'
X.ll 6.5i
X.TH PERSIM 1 "16-Feb-92"
X.SH NAME
Xpersim - simple single layer perceptron simulator
X.SH SYNOPSIS
Xpersim [file]
X.SH DESCRIPTION
XPersim is a simple single layer perceptron simulator.  Simulation includes
Xthe running of a perceptron as well as training one.  The
Xconvergence procedure used for the training mode was developed by R. Rosenblatt
X(see CONVERGENCE PROCEDURE below).
X
XThe optional filename argument (if given) is the name of a file containing
X\f2persim\f1 commands.  If no arguement is given, \f2persim\f1 will run
Xinteractively.
X
XTo terminate weight values coming from the keyboard, answer any of the
Xquestions with just a carriage return.
X
XDuring 'run' mode, there are two special control chraracters, ^C and ^Z.
XDuring a simulator, hitting ^C will quit the simulation and return to the
X'persim' prompt.  ^Z is only used if the 'run' command isn't used verbosely.
XIf run isn't used verbosely, ^Z will print out a snapshot of the simulation.
XThis inclues the epoch number, the actual output value(s) and the weight
Xvalue(s).
X.SH COMMANDS
XCommands may be abbreviated.  Just enough of a command to make it unique is
Xneeded.
X
XSystem variables (mentioned in the commands below) are alpha, number of
Xinput nodes, number of output nodes, and training mode (either on or off).
X
X.IP "? [command]"
XThis is a synonym for the help command and can be used in place of 'help'.
X.IP "alpha = #"
XSet alpha equal to #.  # can be a number between 0.0 and 1.0 (inclusive).
XDefault is 0.1.
X.IP exit
XExit the program.
X.IP "help [command]"
XDisplay information about the command specified.  If no command is specified,
Xa list of all legal commands is given.
X.IP "inodes = #"
XSet the number of input nodes equal to #.  # can be 1 or greater.
X.TP
Xload <var> "filename"[, type]
X.TP
Xload <var> stdin
X.IP "load <var> random"
XLoad values of a variable (denoted by <var>).  Legal values for <var> are:
X
X.nf
X.ta 5 15
X	desired	(desired output)
X	input	(input data)
X	state	(system variables)
X	weights	(weight data).
X	
X.fi
XThe first form loads data from a filename (given by 'filename').  'Type' (if
Xgiven) can be 'ascii' for ASCII files or 'binary' for binary files.  The
Xsecond form uses the keyword 'stdin' to denote data coming from standard
Xinput.  This second from will allow the user to input all of the data for
X<var> directly from the keyboard.  The third form will load the variable
Xwith random values between 0.0 and 1.0, inclusive.  This is only valid for
Xthe weights variable.
X.IP "node[#] attr value"
XSet output node attributes.  Attributes (attr) can be set for just one node or
Xfor all nodes.  To set an attribute for a particular node, use 'node#', where #
Xis the number of the output node to set.  To set all output nodes, use 'node'
Xwith no number.  'Attr' can be either 'function', to set a node's function,
Xor 'threshold', to set a node's threshold.  'Value' is a floating point
Xnumber if setting a threshold.  Legal values for 'value' is setting a
Xfunction are 'step', for the step function, and 'arctan', for the
Xarctangent function.
X.IP "onodes = #"
XSet the number of output nodes equal to #.  # can be 1 or greater.
X.IP "range <obj> min max"
XSet a range for an object.  The only value <obj> can be right now is 'step' for
Xthe step function.  'Min' is the mininum and 'max' is the maximum range to
Xset.  The default range for the step function is (-1.0,1.0).
X.IP "run [verbose]"
XRun the simulator.  If training mode is on, this command will train the
Xperceptron.  If training mode is off, this will run input data through the
Xperceptron.  If 'verbose' is given and the training mode is on, intermediate
Xoutput values and weights will be displayed as the simulator goes through the
Xepochs.
X.TP
Xsave <var> "filename"[, type]
XSave variables to a file.  Legal values for <var> are:
X
X.nf
X.ta 5 15
X	desired	(desired output values)
X	input	(input values)
X	output	(output values)
X	state	(system variables)
X	weights	(weight values).
X	
X.fi
X\'Filename\' is the name of the file to save to.  'Type' (if
Xgiven) is the type of format to save to.  'Type' can be 'ascii' or 'binary'.
X.IP "show <var>"
XShow the value(s) of a variable.  Legal values for <var> are:
X
X.nf
X.ta 5 15
X	alpha	(the value of alpha)
X	desired	(desired output values)
X	inodes	(the number of input nodes)
X	input	(input values),
X	node[#]	(node information for all nodes or a particular
X		 node, as indicated by #),
X	onodes	(the number of output nodes)
X	output	(output values)
X	range	(ranges)
X	state	(system variables)
X	training	(the state of the training mode)
X	weights	(weight values).
X.fi
X.IP training
XToggle training mode on and off.  Default value is on.
X.IP version
XDisplay current version and compile date.
X.SH CONVERGENCE PROCEDURE
XThe following steps are taken to train the perceptron.  This is taken from
X"An Introduction to Computing with Neural Nets" by Richard P. Lippmann
X.IP "Step 1.	Initialize Weights"
XSet Wi(0) (0 <= i <= N - 1) to small random values if the weights don't
Xalready have a value.  Here Wi(t) is the weight from input i at time t.
X.IP "Step 2.	Present New Input and Desired Output"
XPresent new continuous valued input X0,X1,...,Xn-1 along with the desired output
Xd(t).
X.IP "Step 3.	Calculate Actual Output"
Xy(t) = fn(SUM Wi(t)Xi(t) - theta), where SUM is the mathematical summation
Xsymbol and theta is the output node threshold.
X.IP "Step 4.	Adapt Weights"
XWi(t + 1) = Wi(t) + alpha[d(t) - y(t)]Xi(t), 0 <= i <= N - 1
X
X.nf
X         _
X        /  +1 if input from class A
Xd(t) = -
X        \\_ -1 if input from class B
X.fi
X
XIn these equations, alpha is a positive gain fraction less than 1 and d(t) is
Xthe desired correct output for the current input.  Note that weights are
Xunchanged if the correct decision is made by the net.
X.IP "Step 5.	Repeat by Going to Step 2"
XRepeat procedure until the weights have stabilized.
X.SH FILE FORMATS
XThe ASCII format for input, output, and desired output values is simply one
Xvalue per line.  The BINARY format is a stream of bytes, 1 byte per value.
X
XThe ASCII format for the weights is three values per line; which input node
Xthe connection is coming from, which output node the connection is going to,
Xand the weight value for that connection.  The BINARY format is a stream of
Xbytes (in double floating point format) where the numbers are in the same
Xorder as described for ASCII (from, to, weight, from, to, weight, ...).
XInternal processing for input, output, and desired IS in double floating
Xpoint.
X
XASCII format uses floating point numbers.  Binary is used for values (0,255)
Xusing a single byte per value.
X.SH SEE ALSO
XR. Rosenblatt, \f2Principles of Neurodynamics\f1, New York, Spartan Books
X(1959); Richard P. Lippmann, \f2An Introduction to Computing with Neural Nets\f1
X.SH LIMITATIONS
XOnly two functions (step & arctan) are supported.
X
XOnly training method is R. Rosenblatt's.
X
XProbably more I haven't thought of.
X.SH BUGS
XCould be.  This hasn't been stress-tested due to the fact that it's only a
Xlab and I don't have the time :-(
X.SH AUTHOR
XAdam Stein
X
END_OF_FILE
  if test 6994 -ne `wc -c <'persim.1'`; then
    echo shar: \"'persim.1'\" unpacked with wrong size!
  fi
  # end of 'persim.1'
fi
if test -f 'persim.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'persim.h'\"
else
  echo shar: Extracting \"'persim.h'\" \(2784 characters\)
  sed "s/^X//" >'persim.h' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#define AMBIGUOUS -2				/*Ambiguous syntax*/
X#define UNKNOWN -1				/*Value is unknown*/
X#define VERSION_STR "v1.0 by Adam Stein"	/*Version string*/
X
X/*Commands*/
X#define ALPHA		0		/*Alpha*/
X#define EXIT		1		/*Exit program*/
X#define HELP		2		/*Help*/
X#define INODES		3		/*Number of input nodes*/
X#define LOAD		4		/*Load variables from a file or stdin*/
X#define NODE		5		/*Node command*/
X#define ONODES		6		/*Number of output nodes*/
X#define RANGE		7		/*Range of something*/
X#define RUN		8		/*Run the simulator*/
X#define SAVE		9		/*Save variables to a file*/
X#define SHOW		10		/*Show the value of a variable*/
X#define TRAINING	11		/*Training mode toggle*/
X#define VERSION 	12		/*Show version*/
X
X#define NUM_CMDS	13		/*Number of commands available*/
X
X/*Qualifiers*/
X#define ASCII		50		/*File is of type ASCII*/
X#define BINARY		51		/*File is of type binary (byte size)*/
X#define DESIRED		52		/*Operation involves desired output*/
X#define FUNCTION	53		/*Non-linearity function to use*/
X#define INPUT		54		/*Operation involves input data*/
X#define OUTPUT		55		/*Operation involves output data*/
X#define RANDOM		56		/*Load weights randomly*/
X#define STDIN		57		/*Read values from stdin*/
X#define SYS_VARS	58		/*Operation involves system variables*/
X#define THRESHOLD	59		/*Set node's threshold*/
X#define VERBOSE		60		/*Run in verbose mode*/
X#define WEIGHTS		61		/*Operation involves weight data*/
X
X#define NUM_QUALIFIERS	12		/*Number of qualifiers*/
X
X/*Command structure*/
Xtypedef struct _cmd {
X	int numargs;			/*Number of arguments for cmd*/
X	char *name;			/*Name of command*/
X} CMD;
X
X/*Node information structure*/
Xtypedef struct _node_attr {
X	double threshold;		/*Node threshold*/
X	double (*func)();		/*Non-linear function*/
X} NODE_ATTR;
X
X/*System variables structure*/
Xtypedef struct _state {
X	double alpha;			/*Alpha*/
X	int inodes;			/*Number of input nodes*/
X	int onodes;			/*Number of output nodes*/
X	int training;			/*Training mode status (on/off)*/
X} STATE;
X
X/*Structure of file containing weight information*/
Xtypedef struct _weight {
X	int from;			/*From input node number*/
X	int to;				/*To output node number*/
X	double value;			/*Weight value*/
X} WEIGHT;
X
END_OF_FILE
  if test 2784 -ne `wc -c <'persim.h'`; then
    echo shar: \"'persim.h'\" unpacked with wrong size!
  fi
  # end of 'persim.h'
fi
if test -f 'read.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'read.c'\"
else
  echo shar: Extracting \"'read.c'\" \(6036 characters\)
  sed "s/^X//" >'read.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include <stdio.h>
X#include <fcntl.h>
X#include "persim.h"
X
Xdouble atof();
X
X/*This routine will read in values for 1D arrays from a file or keyboard.
X
X  Inputs:  filename - name of the file containing the values
X	   filetype - what type this file it is
X	   numnodes - number of values to read in
X	   var      - which variable these values are for
X  Outputs: 1 if successful, 0 if an error occurred
X  Locals:  data     - used to read in data from binary files
X	   dummy    - used to check if there are too many values in the file
X	   fp       - file pointer
X	   loop     - loop through reading in values
X  Globals: ASCII    - file is in ascii format
X	   EOF      - user terminated input
X	   NULL     - 0
X*/
Xreaddata(var,numnodes,filename,filetype)
Xregister int numnodes,filetype;
Xregister double var[];
Xregister char *filename;
X{
X	register int loop;
X	register unsigned char *data,dummy[21];
X	register FILE *fp;
X	char *malloc();
X
X	/*If filename isn't NULL, read in values from a file*/
X	if(filename) {
X	  if((fp = fopen(filename,"r")) == NULL) {
X	    printf("can't open {%s}\n",filename);
X	    return(0);
X	  }
X
X	  /*If binary, read in a line of values at a time*/
X	  if(filetype != ASCII) {
X	    if((data = (unsigned char *) malloc(numnodes)) == NULL)
X	      error();
X
X	    if(fread(data,1,numnodes,fp) != numnodes) error();
X
X	    if(fread(&dummy[0],1,1,fp) || !feof(fp))
X	      puts("warning: too many data points in file");
X	  }
X
X	  /*Read values from ascii file or convert from binary array*/
X	  for(loop = 0;loop < numnodes;++loop)
X	    if(filetype == ASCII) {
X	      if(fgets(dummy,21,fp) == NULL) {
X		puts("not enough data points in file");
X		break;
X	      } else var[loop] = atof(dummy);
X	    } else var[loop] = (double) data[loop];
X
X	  fclose(fp);
X	} else for(loop = 0;loop < numnodes;++loop) { /*Get data from keyboard*/
X		 printf("Data Point #%d? ");
X
X		 if(fgets(dummy,21,stdin) == (char *) EOF) {
X		   puts("input ended early at request of the user");
X		   break;
X		 } else var[loop] = atof(dummy);
X	       }
X
X	return(1);
X}
X
X/*This routine will read in the system variables.
X
X  Inputs:  filename - name of the file containing the values
X  Outputs: none
X  Locals:  fd       - file descriptor
X	   tmp      - temporary holding place for read in values
X  Globals: state    - system variables
X	   O_RDONLY - open file for reading
X*/
Xreadstate(filename)
Xregister char *filename;
X{
X	register int fd;
X	STATE tmp;
X	extern STATE state;
X
X	if((fd = open(filename,O_RDONLY)) == -1) {
X	  printf("can't open {%s}\n",filename);
X	  return;
X	}
X
X	if(read(fd,(char *) &tmp,sizeof(tmp)) != sizeof(tmp))
X	  puts("reading system variables failed");
X	else bcopy((char *) &tmp,(char *) &state,sizeof(state));
X
X	close(fd);
X}
X
X/*This routine will read in values for 2D arrays from a file or keyboard.
X
X  Inputs:  filename - name of the file containing the values
X	   filetype - what type this file it is
X	   innodes  - number of input nodes
X	   outnodes - number of output nodes
X	   var      - which variable these values are for
X  Outputs: 1 if successful, 0 if an error occurred
X  Locals:  fp       - file pointer
X	   from     - from which input node value
X	   dummy    - line of input from keyboard
X	   to       - to which output node value
X	   value    - weight value
X	   weight   - read in values (from, to, value)
X  Globals: ASCII    - file is in ascii format
X	   NULL     - 0
X*/
Xreadwts(var,innodes,outnodes,filename,filetype)
Xregister int innodes,outnodes,filetype;
Xregister double *var[];
Xregister char *filename;
X{
X	int from,to;
X	double value;
X	register char dummy[21];
X	register FILE *fp;
X	WEIGHT weight;
X
X	/*If filename isn't NULL, read values from a file*/
X	if(filename) {
X	  if((fp = fopen(filename,"r")) == NULL) {
X	    printf("can't open {%s}\n",filename);
X	    return(0);
X	  }
X
X	  if(filetype != ASCII)
X	    while(fread((char *) &weight,sizeof(weight),1,fp) == 1) {
X	      if((weight.from < 1) || (weight.from > innodes))
X		printf("\nthe specified input node #%d is out of bounds\n\n",
X		       weight.from);
X	      else if((weight.to < 1) || (weight.to > outnodes))
X		     printf("\nthe specified output node #%d is out of bounds\n\n",
X		            weight.to);
X	           else var[weight.from-1][weight.to-1] = weight.value;
X	    }
X	  else while(fscanf(fp,"%d %d %lf",&from,&to,&value) == 3) {
X	         if((from < 1) || (from > innodes))
X		   printf("\nthe specified input node #%d is out of bounds\n\n",
X		          from);
X	         else if((to < 1) || (to > outnodes))
X		        printf("\nthe specified output node #%d is out of bounds\n\n",
X		               to);
X		      else var[from-1][to-1] = value;
X	       }
X
X	  fclose(fp);
X	} else {
X		 /*Read from keyboard until user quits*/
X		 while(1) {
X		   printf("From Input Node? ");
X		   fgets(dummy,21,stdin);
X		   if(dummy[0] == '\n') break;
X		   from = atoi(dummy);
X
X		   printf("To Output Node? ");
X		   fgets(dummy,21,stdin);
X		   if(dummy[0] == '\n') break;
X		   to = atoi(dummy);
X
X		   printf("Weight Value? ");
X		   fgets(dummy,21,stdin);
X		   if(dummy[0] == '\n') break;
X		   puts("");
X
X	           if((from < 1) || (from > innodes))
X		     printf("\nthe specified input node #%d is out of bounds\n\n",
X		            from);
X	           else if((to < 1) || (to > outnodes))
X		          printf("\nthe specified output node #%d is out of bounds\n\n",
X		                 to);
X		        else var[from-1][to-1] = atof(dummy);
X		 }
X	       }
X
X	return(1);
X}
X
END_OF_FILE
  if test 6036 -ne `wc -c <'read.c'`; then
    echo shar: \"'read.c'\" unpacked with wrong size!
  fi
  # end of 'read.c'
fi
if test -f 'run.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'run.c'\"
else
  echo shar: Extracting \"'run.c'\" \(5878 characters\)
  sed "s/^X//" >'run.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include <stdio.h>
X#include <signal.h>
X#include <math.h>
X#include "persim.h"
X
Xint quit,numepoch;
Xdouble *actual;
Xchar *calloc();
Xextern double *input,*output,*desired,**weights;
Xextern NODE_ATTR *node_attr;
Xextern STATE state;
X
X/*This routine will simulate a single layer perceptron.
X
X  Inputs:  verbose     - flag to indicate to run in verbose mode
X  Outputs: none        - 0
X  Locals:  convergence - flag indicating if weights have converged
X	   loop        - loop through weights arrays
X	   loop2       - loop through weights array elements
X	   old_wts     - previous values of the weights
X  Globals: actual      - actual output values
X	   desired     - desired output values
X	   input       - input values
X	   node_attr   - node attributes (function, threshold)
X	   numepoch    - number of the epoch
X	   quit        - flag indicating to quit simulation
X	   state       - system variables
X	   weights     - perceptron weights
X	   NULL        - 0
X	   UNKNOWN     - variable isn't set
X*/
Xvoid run(verbose)
Xregister int verbose;
X{
X	register int loop,loop2,convergence;
X	double **old_wts;
X	void quitit(),snapshot();
X
X	/*Make sure all variables needed are set*/
X	if(state.inodes == UNKNOWN) {
X	  puts("the number of input nodes has not been set");
X	  return;
X	}
X	if(state.onodes == UNKNOWN) {
X	  puts("the number of output nodes has not been set");
X	  return;
X	}
X	if(input == (double *) NULL) {
X	  puts("no input data points have been loaded");
X	  return;
X	}
X	if(state.training && (desired == (double *) NULL)) {
X	  puts("no desired output data points have been loaded");
X	  return;
X	}
X	if(node_attr == (NODE_ATTR *) NULL) {
X	puts("node thresholds and functions haven't been set");
X	return;
X	}
X
X	/*If the weights haven't been set, initialize to random values*/
X	if(weights == (double **) NULL) {
X	  puts("warning: weights not set, initializing to random values");
X	  randomize();
X	}
X
X	if(state.training) {
X	  old_wts = (double **) NULL;
X	  alloc_wts(&old_wts,state.inodes,state.onodes);
X	}
X
X	if((actual = (double *) calloc(state.onodes,sizeof(double))) == NULL)
X	  error();
X
X	/*Set up signals*/
X	signal(SIGINT,quitit);
X	if(!verbose) signal(SIGTSTP,snapshot);
X
X	/*Begin simulation*/
X	convergence = quit = 0;
X	numepoch = 1;
X	while(!convergence) {
X	  do_epoch();
X
X	  /*If training, adjust weights until convergence*/
X	  if(state.training) {
X	    convergence = 1;
X	    for(loop = 0;loop < state.onodes;++loop)
X	      for(loop2 = 0;loop2 < state.inodes;++loop2) {
X		old_wts[loop2][loop] = weights[loop2][loop];
X	        weights[loop2][loop] += (state.alpha * 
X					 (desired[loop] - actual[loop]) *
X				         input[loop2]);
X
X		if((fabs(weights[loop2][loop] - old_wts[loop2][loop]) >
X		    0.000025) && !quit)
X		  convergence = 0;
X	      }
X
X	    /*Print information if user requested verbosity*/
X	    if(verbose) snapshot();
X	  } else convergence = 1;
X
X	  ++numepoch;
X	}
X
X	alloc_data(state.onodes,&output);
X	bcopy((char *) actual,(char *) output,state.onodes*sizeof(double));
X
X	free((char *) actual);
X	if(state.training) {
X	  for(loop = 0;loop < state.inodes;++loop)
X	    free((char *) old_wts[loop]);
X	  free((char *) old_wts);
X	}
X
X	/*Restore signals*/
X	signal(SIGINT,SIG_DFL);
X	signal(SIGTSTP,SIG_DFL);
X}
X
X/*This routine does the calculations that make up an epoch.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  loop      - loop through output nodes
X	   loop2     - loop though inputs
X	   sum       - sum of an output node
X  Globals: actual    - actual output values
X	   input     - input values
X	   node_attr - node attributes (function, threshold)
X	   quit      - flag indicating to quit simulation
X	   state     - system variables
X	   weights   - perceptron weights
X	   NULL      - 0
X*/
Xdo_epoch()
X{
X	register int loop,loop2;
X	register double sum;
X
X	for(loop = 0;loop < state.onodes;++loop) {
X	  for(loop2 = 0,sum = 0.0;loop2 < state.inodes;++loop2)
X	    sum += (weights[loop2][loop] * input[loop2]);
X
X	  if(node_attr[loop].func == NULL) {
X	    printf("the function for output node #%d hasn't been set ... quitting run\n",loop);
X	    quit = 1;
X	    return;
X	  }
X
X	  actual[loop] = node_attr[loop].func(sum - node_attr[loop].threshold);
X	}
X}
X
X/*This routine will set the weights to random numbers between 0.0 and 1.0.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  from    - from which input node
X	   to      - to which output node
X  Globals: state   - system variables
X	   weights - perceptron weights
X*/
Xrandomize()
X{
X	register int from,to;
X	double drand48();
X
X	alloc_wts(&weights,state.inodes,state.onodes);
X
X	for(from = 0;from < state.inodes;++from)
X	  for(to = 0;to < state.onodes;++to)
X	    weights[from][to] = drand48();
X}
X
X/*This routine is called if ^C is pressed.  It sets up the flag to exit
X  the simulator.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  none
X  Globals: quit - flag indicating to quit simulation
X*/
Xvoid quitit()
X{
X	quit = 1;
X}
X
Xvoid snapshot()
X{
X	register int loop,loop2;
X
X	printf("Epoch #%d:\n",numepoch);
X
X	for(loop = 0;loop < state.onodes;++loop)
X	  printf("  Actual Output Node #%d = %lf\n",loop+1,actual[loop]);
X
X	puts("");
X
X	for(loop = 0;loop < state.inodes;++loop)
X	  for(loop2 = 0;loop2 < state.onodes;++loop2)
X	    printf("  [New] From #%d, To #%d, Weight = %lf\n",loop+1,loop2+1,weights[loop][loop2]);
X	      
X	puts("");
X}
X
END_OF_FILE
  if test 5878 -ne `wc -c <'run.c'`; then
    echo shar: \"'run.c'\" unpacked with wrong size!
  fi
  # end of 'run.c'
fi
if test -f 'set.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'set.c'\"
else
  echo shar: Extracting \"'set.c'\" \(4432 characters\)
  sed "s/^X//" >'set.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include <stdio.h>
X#include <math.h>
X#include "persim.h"
X
Xextern NODE_ATTR *node_attr;
Xextern STATE state;
X
X/*This routine will set a variable to an integer number.
X
X  Inputs:  number    - number to set variable to
X	   var       - variable to set
X  Outputs: none
X  Locals:  loop      - loop through output nodes
X  Globals: input     - input values array
X	   node_attr - node attributes (function, threshold)
X	   output    - output values array
X	   state     - system variables
X	   INODES    - set number of input nodes variable
X	   ONODES    - set number of output nodes variable
X	   NULL      - 0
X*/
Xvoid iset(var,number)
Xregister int var,number;
X{
X	register int loop;
X	char *calloc();
X	extern double *input,*output;
X
X	switch(var) {
X	  case INODES:
X		if(number < 1) puts("illegal value for number of input nodes");
X		else {
X		       if(input != (double *) NULL)
X			 resize_io(&input,number);
X
X		       state.inodes = number;
X		     }
X		break;
X	  case ONODES:
X		if(number < 1) puts("illegal value for number of output nodes");
X		else {
X		       if(output != (double *) NULL) resize_io(&output,number);
X		       if(node_attr != (NODE_ATTR *) NULL)
X			 resize_attr(&node_attr,number);
X		       else if((node_attr = (NODE_ATTR *) calloc(number,
X							  sizeof(NODE_ATTR)))
X							  == NULL)
X			      error();
X
X		       for(loop = 0;loop < state.onodes;++loop)
X			 node_attr[loop].func = NULL;
X
X		       state.onodes = number;
X		     }
X		break;
X	}
X}
X
X/*This routine will set a variable to a floating point number.
X
X  Inputs:  number - number to set variable to
X	   var	  - variable to set
X  Outputs: none
X  Locals:  none
X  Globals: state  - system variables
X	   ALPHA  - set alpha
X*/
Xvoid fpset(var,number)
Xregister int var;
Xregister double number;
X{
X	switch(var) {
X	  case ALPHA:
X		if((number < 0.0) || (number > 1.0))
X		  puts("illegal value for alpha");
X		else state.alpha = number;
X		break;
X	}
X}
X
X/*This routine will set the threshold level of an output node.
X
X  Inputs:  value      - threshold level
X	   whichnnode - which node to set (-1 means ALL nodes)
X  Outputs: none
X  Locals:  loop	      - loop through output nodes
X  Globals: node_attr  - node attributes (function, threshold)
X	   state      - system variables
X	   NULL       - 0
X*/
Xvoid set_threshold(whichnode,value)
Xregister int whichnode;
Xregister double value;
X{
X	register int loop;
X
X	if(node_attr == (NODE_ATTR *) NULL) {
X	  puts("the number of output nodes has not been set yet");
X	  return;
X	}
X
X	if(whichnode == -1)
X	  for(loop = 0;loop < state.onodes;++loop)
X	    node_attr[loop].threshold = value;
X	else node_attr[whichnode-1].threshold = value;
X}
X
X/*This routine will set the function of an output node.
X
X  Inputs:  string     - function to set
X	   whichnnode - which node to set (-1 means ALL nodes)
X  Outputs: none
X  Locals:  loop	      - loop through output nodes
X  Globals: node_attr  - node attributes (function, threshold)
X	   state      - system variables
X	   NULL       - 0
X*/
Xvoid set_func(whichnode,string)
Xregister int whichnode;
Xregister char *string;
X{
X	register int loop;
X
X	if(node_attr == (NODE_ATTR *) NULL) {
X	  puts("the number of output nodes has not been set yet");
X	  return;
X	}
X
X	if(whichnode == -1) {
X	  for(loop = 0;loop < state.onodes;++loop)
X	    if(!_set_func(string,&node_attr[loop]))
X	      puts("illegal function");
X	} else if(!_set_func(string,&node_attr[whichnode-1]))
X		 puts("illegal function");
X}
X
X/*This routine will set the correct function pointer based on function name.
X  
X  Inputs:  node   - which output node to set
X	   string - function to set it to
X  Outputs: none
X  Locals:  none
X  Globals: none
X*/
X_set_func(string,node)
Xregister char *string;
Xregister NODE_ATTR *node;
X{
X	double step();
X
X	if(!strcmp(string,"step")) node->func = step;
X	else if(!strcmp(string,"arctan")) node->func = atan;
X}
X
END_OF_FILE
  if test 4432 -ne `wc -c <'set.c'`; then
    echo shar: \"'set.c'\" unpacked with wrong size!
  fi
  # end of 'set.c'
fi
if test -f 'show.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'show.c'\"
else
  echo shar: Extracting \"'show.c'\" \(5153 characters\)
  sed "s/^X//" >'show.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include <stdio.h>
X#include <math.h>
X#include "persim.h"
X
X/*This routine will show the values of different variables.
X
X  Inputs:  var        - which variable to display
X	   whichnode  - in the case of output node attributes, which node
X  Outputs: none
X  Locals:  loop       - loop through variable elements
X	   loop2      - loop through variable elements (for 2D arrays)
X  Globals: desired    - desired output values
X	   input      - intput values
X	   output     - output values
X	   node_attr  - node attributes (function, threshold)
X	   print_line - flag indicating if commands are from a batch file
X	   ranges     - max and min values (only for step function right now)
X	   state      - system variables
X	   weights    - perceptron weights
X	   ALPHA      - show alpha
X	   AMBIGUOUS  - ambiguous variable specified
X	   DESIRED    - show desired output values
X	   NULL       - 0
X	   INODES     - show number of input nodes
X	   INPUT      - show input values
X	   NODE       - show node attributes
X	   ONODES     - show number of output nodes
X	   OUTPUT     - show output values
X	   RANGE      - show ranges
X	   SYS_VARS   - show system variables
X	   UNKNOWN    - variable isn't set
X	   TRAINING   - show status of training mode
X	   WEIGHTS    - show perceptron weights
X*/
Xshow(var,whichnode)
Xregister int var,whichnode;
X{
X	register int loop,loop2;
X	extern int print_line;
X	extern double *input,*output,*desired,**weights,ranges[1][2];
X	extern NODE_ATTR *node_attr;
X	extern STATE state;
X
X	switch(var) {
X	  case ALPHA:
X		printf("Alpha is currently set to %lf\n",state.alpha);
X		break;
X	  case AMBIGUOUS:
X		puts("*** ambiguous variable to show ***");
X		break;
X	  case DESIRED:
X		if(desired == (double *) NULL)
X		  puts("no desired output data points have been loaded");
X		else
X		  for(loop = 0;loop < state.onodes;++loop)
X		    printf("Desired Output Data Point #%d = %lf\n",loop+1,desired[loop]);
X		break;
X	  case INODES:
X		if(state.inodes == UNKNOWN)
X		  puts("The number of input nodes has not been set");
X		else
X		  printf("The number of input nodes is currently set to %d\n",
X			 state.inodes);
X		break;
X	  case INPUT:
X		if(input == (double *) NULL)
X		  puts("no input data points have been loaded");
X		else
X		  for(loop = 0;loop < state.inodes;++loop)
X		    printf("Input Data Point #%d = %lf\n",loop+1,input[loop]);
X		break;
X	  case NODE:
X		if(node_attr == (NODE_ATTR *) NULL)
X		  puts("no node attributes have been set");
X		else if(whichnode == -1)
X		       for(loop = 0;loop < state.onodes;++loop)
X			 show_node(loop+1,node_attr[loop]);
X		     else show_node(whichnode,node_attr[whichnode-1]);
X		break;
X	  case ONODES:
X		if(state.onodes == UNKNOWN)
X		  puts("The number of output nodes has not been set");
X		else
X		  printf("The number of output nodes is currently set to %d\n",
X			 state.onodes);
X		break;
X	  case OUTPUT:
X		if(output == (double *) NULL)
X		  puts("no output data points have generated");
X		else
X		  for(loop = 0;loop < state.onodes;++loop)
X		    printf("Output Data Point #%d = %lf\n",loop+1,output[loop]);
X		break;
X	  case RANGE:
X		puts("Step Function:");
X		printf("  min: %lf, max: %lf\n",ranges[0][0],ranges[0][1]);
X		break;
X	  case SYS_VARS:
X		puts("System Variables:");
X		printf("  alpha = %lf\n",state.alpha);
X
X		printf("  inodes = ");
X		if(state.inodes == UNKNOWN) puts("NOT SET");
X		else printf("%d\n",state.inodes);
X
X		printf("  onodes = ");
X		if(state.onodes == UNKNOWN) puts("NOT SET");
X		else printf("%d\n",state.onodes);
X
X		printf("  training mode is ");
X		if(state.training) puts("ON");
X		else puts("OFF");
X		break;
X	  case TRAINING:
X		printf("training mode is ");
X		if(state.training) puts("ON");
X		else puts("OFF");
X		break;
X	  case WEIGHTS:
X		if(weights == (double **) NULL)
X		  puts("no weights have been loaded");
X		else
X		  for(loop = 0;loop < state.inodes;++loop)
X		    for(loop2 = 0;loop2 < state.onodes;++loop2)
X		      if(weights[loop][loop2] != 0.0)
X			printf("From Input Node #%d, To Output Node #%d, Weight = %lf\n",
X			       loop+1,loop2+1,weights[loop][loop2]);
X		break;
X	}
X}
X
X/*This routine will show the attributes of an output node.
X
X  Inputs:  node      - node attributes
X	   whichnode - which node to display information about
X  Outputs: none
X  Locals:  none
X  Globals: none
X*/
Xshow_node(whichnode,node)
Xregister int whichnode;
XNODE_ATTR node;
X{
X	double step();
X
X	printf("Output Node #%d: threshold = %lf, function = ",whichnode,
X							       node.threshold);
X	
X	if(node.func == atan) puts("arctan");
X	else if(node.func == step) puts("step");
X	     else  puts("NULL");
X}
X
END_OF_FILE
  if test 5153 -ne `wc -c <'show.c'`; then
    echo shar: \"'show.c'\" unpacked with wrong size!
  fi
  # end of 'show.c'
fi
if test -f 'write.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'write.c'\"
else
  echo shar: Extracting \"'write.c'\" \(3632 characters\)
  sed "s/^X//" >'write.c' <<'END_OF_FILE'
X/*Copyright  (c)   1992  Adam  Stein.   All  Rights Reserved.   
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is  
X  retained.   
X  
X  A fee may be charged for this program ONLY to recover costs   
X  for distribution (i.e. media costs).  No profit can be made            
X  on this program.   
X   
X  The author assumes no responsibility for disasters (natural   
X  or otherwise) as a consequence of use of this software.      
X   
X  Adam Stein (stein.wbst129@xerox.com)         
X*/ 
X
X#include <stdio.h>
X#include <fcntl.h>
X#include "persim.h"
X
X/*This routine will write values for 1D arrays to a file.
X
X  Inputs:  filename - name of the file to write to
X	   filetype - what type this file it is
X	   numnodes - number of values to write out
X	   var      - which variable to write out
X  Outputs: none
X  Locals:  data	    - line of data to write out
X	   fp       - file pointer
X	   loop     - loop through writing out values
X  Globals: ASCII    - write out in ascii format
X	   NULL     - 0
X*/
Xwritedata(var,numnodes,filename,filetype)
Xregister int numnodes,filetype;
Xregister double var[];
Xregister char *filename;
X{
X	register int loop;
X	register unsigned char *data;
X	register FILE *fp;
X	char *malloc();
X
X	if((fp = fopen(filename,"w")) == NULL) {
X          printf("can't open {%s}\n",filename);
X	  return;
X        }
X
X	if((data = (unsigned char *) malloc(numnodes)) == NULL)
X	  error();
X
X	for(loop = 0;loop < numnodes;++loop)
X	  if(filetype == ASCII) fprintf(fp,"%d\n",(int) var[loop]);
X	  else data[loop] = (unsigned char) var[loop];
X
X	if(filetype != ASCII)
X	  if(fwrite(data,1,numnodes,fp) != numnodes) error();
X
X	fclose(fp);
X}
X
X/*This routine will write out the system variables.
X
X  Inputs:  filename - name of the file to write to
X  Outputs: none
X  Locals:  fd	    - file descriptor
X  Globals: state    - system variables
X	   O_CREAT  - create file if necessary
X	   O_RDONLY - open file for reading
X	   O_WRONLY - open file for writing
X*/
Xwritestate(filename)
Xregister char *filename;
X{
X	register int fd;
X	extern STATE state;
X
X	if((fd = open(filename,O_RDONLY)) != -1) {
X	  close(fd);
X	  printf("{%s} already exists\n",filename);
X	  return;
X	}
X
X	if((fd = open(filename,O_WRONLY|O_CREAT,0644)) == -1) {
X	  printf("can't open {%s}\n",filename);
X	  return;
X	}
X
X	if(write(fd,(char *) &state,sizeof(state)) != sizeof(state))
X	  puts("writing system variables failed");
X
X	close(fd);
X}
X
X/*This function will write the values from a 2D array to a file.
X
X  Inputs:  filename - name of the file to write to
X	   filetype - what type this file it is
X	   innodes  - number of input nodes
X	   outnodes - number of output nodes
X	   var      - which variable to write out
X  Outputs: none
X  Locals:  fd       - file descriptor
X  Globals: ASCII    - write out in ascii format
X	   NULL     - 0
X
X*/
Xwritewts(var,innodes,outnodes,filename,filetype)
Xregister int innodes,outnodes,filetype;
Xregister double *var[];
Xregister char *filename;
X{
X	register int loop,loop2;
X	register FILE *fp;
X	WEIGHT weight;
X
X	if((fp = fopen(filename,"w")) == NULL) {
X          printf("can't open {%s}\n",filename);
X          return;
X        }
X
X	for(loop = 0;loop < innodes;++loop)
X	  for(loop2 = 0;loop2 < outnodes;++loop2)
X	    if(var[loop][loop2] != 0.0)
X	      if(filetype != ASCII) {
X		weight.from = loop+1;
X		weight.to = loop2+1;
X		weight.value = var[loop][loop2];
X	        if(fwrite((char *) &weight,sizeof(weight),1,fp) != 1)
X		  error();
X	      } else fprintf(fp,"%d %d %lf\n",loop+1,loop2+1,var[loop][loop2]);
X
X	fclose(fp);
X}
X
END_OF_FILE
  if test 3632 -ne `wc -c <'write.c'`; then
    echo shar: \"'write.c'\" unpacked with wrong size!
  fi
  # end of 'write.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
