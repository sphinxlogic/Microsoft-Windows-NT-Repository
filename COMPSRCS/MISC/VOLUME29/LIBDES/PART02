From: eay@psych.psy.uq.oz.au (Eric Young)
Newsgroups: comp.sources.misc
Subject: v29i044: libdes - DES encryption library, Part02/04
Message-ID: <1992Apr3.224108.29579@aber.ac.uk>
Date: 3 Apr 92 22:41:08 GMT
Approved: aem@aber.ac.uk
X-Md4-Signature: e275604d77dcfb04f30ce3736e9acb73

Submitted-by: eay@psych.psy.uq.oz.au (Eric Young)
Posting-number: Volume 29, Issue 44
Archive-name: libdes/part02
Environment: UNIX

#! /bin/sh
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  des.c des_crypt.man destest.c set_key.c sk.h sp.h
#   testdes.pl
# Wrapped by aem@aberfa on Wed Apr  1 15:53:23 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'des.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des.c'\"
else
echo shar: Extracting \"'des.c'\" \(4336 characters\)
sed "s/^X//" >'des.c' <<'END_OF_FILE'
X/* des.c */
X/* Copyright (C) 1992 Eric Young - see COPYING for more details */
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include "des.h"
X
X#define VERIFY  1
X#define KEYSIZ	8
Xchar key[KEYSIZ+1];
Xint encrypt;
Xchar *in=NULL,*out=NULL;
XFILE *IN,*OUT;
X
Xint eflag,dflag,kflag,bflag,fflag,sflag,error;
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X	{
X	int i;
X	struct stat ins,outs;
X
X	eflag=dflag=kflag=bflag=fflag=sflag=0,error=0;
X	memset(key,0,sizeof(key));
X
X	for (i=1; i<argc; i++)
X		{
X		if ((argv[i][0] == '-') && (argv[i][1] != '\0') &&
X			(argv[i][2] == '\0'))
X			{
X			switch (argv[i][1])
X				{
X			case 'e':
X				eflag=1;
X				break;
X			case 'd':
X				dflag=1;
X				break;
X			case 'b':
X				bflag=1;
X				break;
X			case 'f':
X				fflag=1;
X				break;
X			case 's':
X				sflag=1;
X				break;
X			case 'k':
X				kflag=1;
X				if ((i+1) == argc)
X					{
X					fputs("must have a key with the -k option\n",stderr);
X					error=1;
X					}
X				else
X					{
X					int j;
X
X					i++;
X					strncpy(key,argv[i],KEYSIZ);
X					for (j=strlen(argv[i])-1; j>=0; j--)
X						argv[i][j]='\0';
X					}
X				break;
X			default:
X				fprintf(stderr,"'%s' unknown flag\n",argv[i]);
X				error=1;
X				break;
X				}
X			}
X		else
X			{
X			if (in == NULL)
X				in=argv[i];
X			else if (out == NULL)
X				out=argv[i];
X			else
X				error=1;
X			}
X		}
X	if (error) usage();
X	if ((eflag+dflag) == 1)
X		{
X		if (eflag) encrypt=DES_ENCRYPT;
X		if (dflag) encrypt=DES_DECRYPT;
X		}
X	else
X		usage();
X
X	if (	(in != NULL) &&
X		(out != NULL) &&
X		(stat(in,&ins) != -1) &&
X		(stat(out,&outs) != -1) &&
X		(ins.st_dev == outs.st_dev) &&
X		(ins.st_ino == outs.st_ino))
X			{
X			fputs("input and output file are the same\n",stderr);
X			exit(3);
X			}
X
X	if (!kflag)
X		if (des_read_pw_string(key,KEYSIZ+1,"Enter key:",eflag?VERIFY:0))
X			{
X			fputs("password error\n",stderr);
X			exit(2);
X			}
X
X	if (in == NULL)
X		IN=stdin;
X	else if ((IN=fopen(in,"r")) == NULL)
X		{
X		perror("opening input file");
X		exit(4);
X		}
X
X	if (out == NULL)
X		OUT=stdout;
X	else if ((OUT=fopen(out,"w")) == NULL)
X		{
X		perror("opening output file");
X		exit(5);
X		}
X
X	doencryption();
X	fclose(IN);
X	fclose(OUT);
X	exit(0);
X	}
X
Xusage()
X	{
X	fputs("des -e | -d [ -bfs ] [ -k key ] [ input-file [ output-file]\n",
X		stderr);
X	exit(1);
X	}
X
Xdoencryption()
X	{
X	char buf[1024*8+8];
X	char obuf[1024*8+8];
X	des_key_schedule ks;
X	char iv[8];
X	int i,j,k,l,ll,last,ex=0;
X
X	for (i=0; i<KEYSIZ; i++)
X		{
X		l=0;
X		k=key[i];
X		for (j=0; j<8; j++)
X			{
X			if (k&1) l++;
X			k>>=1;
X			}
X		if (l & 1)
X			key[i]=key[i]&0x7f;
X		else
X			key[i]=key[i]|0x80;
X		}
X
X	des_set_key(key,ks);
X	memset(key,0,sizeof(key));
X
X	l=1;
X	/* first read */
X	if (encrypt == DES_ENCRYPT)
X		{
X		for (;;)
X			{
X			l=fread(buf,1,1024*8,IN);
X			if (l < 0)
X				{
X				perror("read error");
X				exit(6);
X				}
X
X			if (feof(IN))
X				{
X				last=l%8;
X				srand(time(NULL));
X				for (i=7-last; i>0; i--)
X					buf[l++]=rand()&0xff;
X				buf[l++]=last;
X				ex=1;
X				}
X
X			if (bflag)
X				for (i=0; i<l; i+=8)
X					des_ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,encrypt);
X			else
X				{
X				des_cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X					l,ks,(des_cblock *)iv,encrypt);
X				if (l >= 8) bcopy(&(obuf[l-8]),iv,8);
X				}
X
X			i=0;
X			while (i != l)
X				{
X				j=fwrite(obuf,1,l-i,OUT);
X				if (j == -1)
X					{
X					perror("Write error");
X					exit(7);
X					}
X				i+=j;
X				}
X			if (feof(IN)) break;
X			}
X		}
X	else /* decrypt */
X		{
X		ex=1;
X		for (;;)
X			{
X			if (ex) {
X				l=fread(buf,1,1024*8,IN);
X				ex=0;
X				}
X			if (l < 0)
X				{
X				perror("read error");
X				exit(6);
X				}
X
X			if (bflag)
X				for (i=0; i<l; i+=8)
X					des_ecb_encrypt(
X						(des_cblock *)&(buf[i]),
X						(des_cblock *)&(obuf[i]),
X						ks,encrypt);
X			else
X				{
X				des_cbc_encrypt(
X					(des_cblock *)buf,(des_cblock *)obuf,
X					l,ks,(des_cblock *)iv,encrypt);
X				if (l >= 8) bcopy(&(buf[l-8]),iv,8);
X				}
X
X			if (!ex) ll=fread(buf,1,1024*8,IN);
X			if (feof(IN) && (ll == 0))
X				{
X				last=obuf[l-1];
X				if ((last > 7) || (last < 0))
X					{
X					fputs("The file was not decrypted correctly.\n",
X						stderr);
X					exit(8);
X					}
X				l=l-8+last;
X				}
X			i=0;
X			while (i != l)
X				{
X				j=fwrite(obuf,1,l-i,OUT);
X				if (j == -1)
X					{
X					perror("Write error");
X					exit(7);
X					}
X				i+=j;
X				}
X			l=ll;
X			if ((l == 0) && feof(IN)) break;
X			}
X		}
X	}
END_OF_FILE
if test 4336 -ne `wc -c <'des.c'`; then
    echo shar: \"'des.c'\" unpacked with wrong size!
fi
# end of 'des.c'
fi
if test -f 'des_crypt.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'des_crypt.man'\"
else
echo shar: Extracting \"'des_crypt.man'\" \(8756 characters\)
sed "s/^X//" >'des_crypt.man' <<'END_OF_FILE'
X.TH DES_CRYPT 3 
X.SH NAME
Xdes_read_password, des_string_to_key, des_read_pw_string,
Xdes_random_key, des_set_key,
Xdes_key_sched, des_ecb_encrypt, des_cbc_encrypt,
Xdes_pcbc_encrypt, des_cbc_cksum, des_quad_cksum,
Xdes_enc_read, des_enc_write, des_set_odd_parity,
Xdes_is_weak_key, crypt \- (non USA) DES encryption
X.SH SYNOPSIS
X.nf
X.nj
X.ft B
X#include <des.h>
X.PP
X.B int des_read_password(key,prompt,verify)
Xdes_cblock *key;
Xchar *prompt;
Xint verify;
X.PP
X.B int des_string_to_key(str,key)
Xchar *str;
Xdes_cblock *key;
X.PP
X.B int des_read_pw_string(buf,length,prompt,verify)
Xchar *buf;
Xint length;
Xchar *prompt;
Xint verify;
X.PP
X.B int des_random_key(key)
Xdes_cblock *key;
X.PP
X.B int des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X.PP
X.B int des_key_sched(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X.PP
X.B int des_ecb_encrypt(input,output,schedule,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xdes_key_schedule schedule;
Xint encrypt;
X.PP
X.B int des_cbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X.PP
X.B int des_pcbc_encrypt(input,output,length,schedule,ivec,encrypt)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
Xint encrypt;
X.PP
X.B unsigned long des_cbc_cksum(input,output,length,schedule,ivec)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xdes_key_schedule schedule;
Xdes_cblock *ivec;
X.PP
X.B unsigned long des_quad_cksum(input,output,length,out_count,seed)
Xdes_cblock *input;
Xdes_cblock *output;
Xlong length;
Xint out_count;
Xdes_cblock *seed;
X.PP
X.B int des_check_key;
X.PP
X.B int des_enc_read(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X.PP
X.B int des_enc_write(fd,buf,len,sched,iv)
Xint fd;
Xchar *buf;
Xint len;
Xdes_key_schedule sched;
Xdes_cblock *iv;
X.PP
X.B extern int des_rw_mode;
X.PP
X.B void des_set_odd_parity(key)
Xdes_cblock *key;
X.PP
X.B int des_is_weak_key(key)
Xdes_cblock *key;
X.PP
X.B char *crypt(passwd,salt)
Xchar *passwd;
Xchar *salt;
X.PP
X.fi
X.SH DESCRIPTION
XThis library contains a fast implementation of the DES encryption
Xalgorithm.
X.PP
XThere are two phases to the use of DES encryption.
XThe first is the generation of a
X.I des_key_schedule
Xfrom a key,
Xthe second is the actual encryption.
XA des key is of type
X.I des_cblock.
XThis type is made from 8 characters with odd parity.
XThe least significant bit in the character is the parity bit.
XThe key schedule is an expanded form of the key; it is used to speed the
Xencryption process.
X.PP
X.I des_read_password
Xwrites the string specified by prompt to the standard output,
Xturns off echo and reads an input string from standard input
Xuntil terminated with a newline.
XIf verify is non-zero, it prompts and reads input again and verifies
Xthat both entered passwords are the same.
XThe entered string is converted into a des key by using the
X.I des_string_to_key
Xroutine.
XThe new key is placed in the
X.I des_cblock
Xthat was passed (by reference) to the routine.
XIf there were no errors,
X.I des_read_password
Xreturns 0,
X-1 is returned if there was a terminal error and 1 is returned
Xany other error.
X.PP
X.I des_read_pw_string
Xis called by
X.I des_read_password
Xto read and verify a string from stdin.
XThe string is returned in
X.I buf.
XThe size of but is passed to the routine via the
X.I length
Xparameter.
X.PP
X.I des_string_to_key
Xconverts a string into a valid des key.
X.PP
X.I des_random_key
Xreturns a random key that is made of a combination of process id,
Xtime and an increasing counter.
X.PP
XBefore a des key can be used it is converted into a
X.I des_key_schedule
Xvia the
X.I des_set_key
Xroutine.
XIf the
X.I des_check_key
Xflag is non-zero,
X.I des_set_key
Xwill check that the key passed is of odd parity and is not a week or
Xsemi-weak key.
XIf the parity is wrong,
Xthen -1 is returned.
XIf the key is a weak key,
Xthen -2 is returned.
XIf an error is returned,
Xthe key schedule is not generated.
X.PP
X.I des_key_sched
Xis another name for the
X.I des_set_key
Xfunction.
X.PP
XThe following routines all operate on an input and output stream of
X.I des_cblock's.
X.PP
X.I des_ecb_encrypt
Xis the basic DES encryption routine that encrypts or decrypts a single 8-byte
X.I des_cblock
Xin
X.I electronic code book
Xmode.
XIt always transforms the input data, pointed to by
X.I input,
Xinto the output data,
Xpointed to by the
X.I output
Xargument.
XIf the
X.I encrypt
Xargument is non-zero (DES_ENCRYPT),
Xthe
X.I input
X(cleartext) is encrypted in to the
X.I output
X(ciphertext) using the key_schedule specified by the
X.I schedule
Xargument,
Xpreviously set via
X.I des_set_key.
XIf
X.I encrypt
Xis zero (DES_DECRYPT),
Xthe
X.I input
X(now ciphertext)
Xis decrypted into the
X.I output
X(now cleartext).
XInput and output may overlap.
XNo meaningful value is returned.
X.PP
X.I des_cbc_encrypt
Xencrypts/decrypts using the
X.I cipher-block-chaining
Xmode of DES.
XIf the
X.I encrypt
Xargument is non-zero,
Xthe routine cipher-block-chain encrypts the cleartext data pointed to by the
X.I input
Xargument into the ciphertext pointed to by the
X.I output
Xargument,
Xusing the key schedule provided by the
X.I schedule
Xargument,
Xand initialization vector provided by the
X.I ivec
Xargument.
XIf the
X.I length
Xargument is not an integral multiple of eight bytes, 
Xthe last block is copied to a temporary area and zero filled.
XThe output is always
Xan integral multiple of eight bytes.
X.PP
X.I des_pcbc_encrypt
Xencrypt/decrypts using a modified block chaining mode.
XIt provides better error propagation characteristics than cbc
Xencryption.
X.PP
X.I des_cbc_cksum
Xproduces an 8 byte checksum based on the input stream (via cbc encryption).
XThe last 4 bytes of the checksum is returned and the complete 8 bytes is
Xplaced in
X.I output.
X.PP
X.I des_quad_cksum
Xreturns a 4 byte checksum from the input bytes.
XThe algorithm can be iterated over the input,
Xdepending on
X.I out_count,
X1, 2, 3 or 4 times.
XIf
X.I output
Xis non-NULL,
Xthe 4 bytes generated by each pass are written into
X.I output.
X.PP
X.I des_enc_write
Xis used to write
X.I len
Xbytes
Xto file descriptor
X.I fd
Xfrom buffer
X.I buf.
XThe data is encrypted via
X.I pcbc_encrypt
X(default) using
X.I sched
Xfor the key and
X.I iv
Xas a starting vector.
XThe actual data send down
X.I fd
Xconsists of 4 bytes (in network byte order) containing the length of the
Xfollowing encrypted data.  The encrypted data then follows, padded with random
Xdata out to a multiple of 8 bytes.
X.PP
X.I des_enc_read
Xis used to read
X.I len
Xbytes
Xfrom file descriptor
X.I fd
Xinto buffer
X.I buf.
XThe data being read from
X.I fd
Xis assumed to have come from
X.I des_enc_write
Xand is decrypted using
X.I sched
Xfor the key schedule and
X.I iv
Xfor the initial vector.
XThe
X.I des_enc_read/des_enc_write
Xpair can be used to read/write to files, pipes and sockets.
XI have used them in implementing a version of rlogin in which all
Xdata is encrypted.
X.PP
X.I des_rw_mode
Xis used to specify the encryption mode to use with 
X.I des_enc_read
Xand 
X.I des_end_write.
XIf set to
X.I DES_PCBC_MODE
X(the defualt), des_pcbc_encrypt is used.
XIf set to
X.I DES_CBC_MODE
Xdes_cbc_encrypt is used.
XThese two routines and the variable are not part of the normal MIT library.
X.PP
X.I des_set_odd_parity
Xsets the parity of the passed
X.I key
Xto odd.  This routine is not part of the standard MIT library.
X.PP
X.I des_is_weak_key
Xreturns 1 is the passed key is a weak key (pick again :-),
X0 if it is ok.
XThis routine is not part of the standard MIT library.
X.PP
X.I crypt
Xis a replacement for the normal system crypt.
XIt is much faster than the system crypt.
X.PP
X.SH FILES
X/usr/include/des.h
X.br
X/usr/lib/libdes.a
X.PP
XThe encryption routines have been tested on VAX,
Xsun 3 (68020), sun 4 (Sparc), DECstation 3100 (MIPS R2000).
X.PP
X.SH BUGS
X.PP
XIf you think this manual is sparse,
Xread the des_crypt(3) manual from the MIT kerberos (or bones outside
Xof the USA) distribution.
X.PP
X.I des_read_pw_string
Xonly really works under bsd based systems.
X.PP
X.I des_string_to_key
Xis almost definitely different from the MIT version since there are lots
Xof fun ways to implement one-way encryption of a text string.
X.PP
X.I des_quad_cksum
Xis almost definitely different from the MIT version since the algorithm
Xcalls for 64-bit multiplication.
XMy fudge is probably different from MIT's
X.PP
XThe routines are optimized for 32 bit machines and so are not efficient
Xon IBM PCs.
X.SH AUTHOR
XEric Young (eay@psych.psy.uq.oz.au),
XPsychology Department,
XUniversity of Queensland, Australia.
X.SH RESTRICTIONS
XThere are none.
XSince I am not a US citizen,
Xthis software can
Xbe freely exported outside of the US without a special license
Xfrom the US Dept of Commerce :-).
XThis has been implemented from FIPS publication 46 which I has
Xbeen in my local library for several years.
END_OF_FILE
if test 8756 -ne `wc -c <'des_crypt.man'`; then
    echo shar: \"'des_crypt.man'\" unpacked with wrong size!
fi
# end of 'des_crypt.man'
fi
if test -f 'destest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'destest.c'\"
else
echo shar: Extracting \"'destest.c'\" \(8656 characters\)
sed "s/^X//" >'destest.c' <<'END_OF_FILE'
X/* destest.c */
X/* Copyright (C) 1992 Eric Young - see COPYING for more details */
X#include <stdio.h>
X#include "des_local.h"
X/* tisk tisk - the test keys don't all have odd parity :-( */
X
X/* test data */
X#define NUM_TESTS 34
Xstatic unsigned char key_data[NUM_TESTS][8]={
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	0x7C,0xA1,0x10,0x45,0x4A,0x1A,0x6E,0x57,
X	0x01,0x31,0xD9,0x61,0x9D,0xC1,0x37,0x6E,
X	0x07,0xA1,0x13,0x3E,0x4A,0x0B,0x26,0x86,
X	0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
X	0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
X	0x01,0x13,0xB9,0x70,0xFD,0x34,0xF2,0xCE,
X	0x01,0x70,0xF1,0x75,0x46,0x8F,0xB5,0xE6,
X	0x43,0x29,0x7F,0xAD,0x38,0xE3,0x73,0xFE,
X	0x07,0xA7,0x13,0x70,0x45,0xDA,0x2A,0x16,
X	0x04,0x68,0x91,0x04,0xC2,0xFD,0x3B,0x2F,
X	0x37,0xD0,0x6B,0xB5,0x16,0xCB,0x75,0x46,
X	0x1F,0x08,0x26,0x0D,0x1A,0xC2,0x46,0x5E,
X	0x58,0x40,0x23,0x64,0x1A,0xBA,0x61,0x76,
X	0x02,0x58,0x16,0x16,0x46,0x29,0xB0,0x07,
X	0x49,0x79,0x3E,0xBC,0x79,0xB3,0x25,0x8F,
X	0x4F,0xB0,0x5E,0x15,0x15,0xAB,0x73,0xA7,
X	0x49,0xE9,0x5D,0x6D,0x4C,0xA2,0x29,0xBF,
X	0x01,0x83,0x10,0xDC,0x40,0x9B,0x26,0xD6,
X	0x1C,0x58,0x7F,0x1C,0x13,0x92,0x4F,0xEF,
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10};
X
Xstatic unsigned char plain_data[NUM_TESTS][8]={
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0xA1,0xD6,0xD0,0x39,0x77,0x67,0x42,
X	0x5C,0xD5,0x4C,0xA8,0x3D,0xEF,0x57,0xDA,
X	0x02,0x48,0xD4,0x38,0x06,0xF6,0x71,0x72,
X	0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A,
X	0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2,
X	0x05,0x9B,0x5E,0x08,0x51,0xCF,0x14,0x3A,
X	0x07,0x56,0xD8,0xE0,0x77,0x47,0x61,0xD2,
X	0x76,0x25,0x14,0xB8,0x29,0xBF,0x48,0x6A,
X	0x3B,0xDD,0x11,0x90,0x49,0x37,0x28,0x02,
X	0x26,0x95,0x5F,0x68,0x35,0xAF,0x60,0x9A,
X	0x16,0x4D,0x5E,0x40,0x4F,0x27,0x52,0x32,
X	0x6B,0x05,0x6E,0x18,0x75,0x9F,0x5C,0xCA,
X	0x00,0x4B,0xD6,0xEF,0x09,0x17,0x60,0x62,
X	0x48,0x0D,0x39,0x00,0x6E,0xE7,0x62,0xF2,
X	0x43,0x75,0x40,0xC8,0x69,0x8F,0x3C,0xFA,
X	0x07,0x2D,0x43,0xA0,0x77,0x07,0x52,0x92,
X	0x02,0xFE,0x55,0x77,0x81,0x17,0xF1,0x2A,
X	0x1D,0x9D,0x5C,0x50,0x18,0xF7,0x28,0xC2,
X	0x30,0x55,0x32,0x28,0x6D,0x6F,0x29,0x5A,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
X
Xstatic unsigned char cipher_data[NUM_TESTS][8]={
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0x73,0x59,0xB2,0x16,0x3E,0x4E,0xDC,0x58,
X	0x95,0x8E,0x6E,0x62,0x7A,0x05,0x55,0x7B,
X	0xF4,0x03,0x79,0xAB,0x9E,0x0E,0xC5,0x33,
X	0x17,0x66,0x8D,0xFC,0x72,0x92,0x53,0x2D,
X	0x8A,0x5A,0xE1,0xF8,0x1A,0xB8,0xF2,0xDD,
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0xED,0x39,0xD9,0x50,0xFA,0x74,0xBC,0xC4,
X	0x69,0x0F,0x5B,0x0D,0x9A,0x26,0x93,0x9B,
X	0x7A,0x38,0x9D,0x10,0x35,0x4B,0xD2,0x71,
X	0x86,0x8E,0xBB,0x51,0xCA,0xB4,0x59,0x9A,
X	0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A,
X	0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95,
X	0x86,0xA5,0x60,0xF1,0x0E,0xC6,0xD8,0x5B,
X	0x0C,0xD3,0xDA,0x02,0x00,0x21,0xDC,0x09,
X	0xEA,0x67,0x6B,0x2C,0xB7,0xDB,0x2B,0x7A,
X	0xDF,0xD6,0x4A,0x81,0x5C,0xAF,0x1A,0x0F,
X	0x5C,0x51,0x3C,0x9C,0x48,0x86,0xC0,0x88,
X	0x0A,0x2A,0xEE,0xAE,0x3F,0xF4,0xAB,0x77,
X	0xEF,0x1B,0xF0,0x3E,0x5D,0xFA,0x57,0x5A,
X	0x88,0xBF,0x0D,0xB6,0xD7,0x0D,0xEE,0x56,
X	0xA1,0xF9,0x91,0x55,0x41,0x02,0x0B,0x56,
X	0x6F,0xBF,0x1C,0xAF,0xCF,0xFD,0x05,0x56,
X	0x2F,0x22,0xE4,0x9B,0xAB,0x7C,0xA1,0xAC,
X	0x5A,0x6B,0x61,0x2C,0xC2,0x6C,0xCE,0x4A,
X	0x5F,0x4C,0x03,0x8E,0xD1,0x2B,0x2E,0x41,
X	0x63,0xFA,0xC0,0xD0,0x34,0xD9,0xF7,0x93,
X	0x61,0x7B,0x3A,0x0C,0xE8,0xF0,0x71,0x00,
X	0xDB,0x95,0x86,0x05,0xF8,0xC8,0xC6,0x06,
X	0xED,0xBF,0xD1,0xC6,0x6C,0x29,0xCC,0xC7,
X	0x35,0x55,0x50,0xB2,0x15,0x0E,0x24,0x51,
X	0xCA,0xAA,0xAF,0x4D,0xEA,0xF1,0xDB,0xAE,
X	0xD5,0xD4,0x4F,0xF7,0x20,0x68,0x3D,0x0D,
X	0x2A,0x2B,0xB0,0x08,0xDF,0x97,0xC2,0xF2};
X
Xstatic unsigned char cbc_key[8]={0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
Xstatic unsigned char cbc_iv[8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};
Xstatic unsigned char cbc_data[40]="7654321 Now is the time for ";
X
Xstatic unsigned char cbc_ok[32]={
X	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
X	0xac,0xd8,0xae,0xfd,0xdf,0xd8,0xa1,0xeb,
X	0x46,0x8e,0x91,0x15,0x78,0x88,0xba,0x68,
X	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
X
Xstatic unsigned char pcbc_ok[32]={
X	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
X	0x6d,0xec,0xb4,0x70,0xa0,0xe5,0x6b,0x15,
X	0xae,0xa6,0xbf,0x61,0xed,0x7d,0x9c,0x9f,
X	0xf7,0x17,0x46,0x3b,0x8a,0xb3,0xcc,0x88};
X
Xstatic unsigned char cksum_ok[8]={
X	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};
X
Xchar *pt();
X
Xmain()
X	{
X	int i,j;
X	des_cblock in,out,outin;
X	des_key_schedule ks;
X	unsigned char cbc_in[40],cbc_out[40];
X	ulong cs;
X	char *str;
X
X	printf("Doing ecb\n");
X	for (i=0; i<NUM_TESTS; i++)
X		{
X		if ((j=key_sched((C_Block *)(key_data[i]),ks)) != 0)
X			printf("Key error %2d:%d\n",i+1,j);
X		bcopy(plain_data[i],in,8);
X		bzero(out,8);
X		bzero(outin,8);
X		des_ecb_encrypt((C_Block *)in,(C_Block *)out,ks,DES_ENCRYPT);
X		des_ecb_encrypt((C_Block *)out,(C_Block *)outin,ks,DES_DECRYPT);
X
X		if (bcmp(out,cipher_data[i],8) != 0)
X			{
X			printf("Encryption error %2d\nk=%s p=%s o=%s act=%s\n",
X				i+1,pt(key_data[i]),pt(in),pt(cipher_data[i]),
X				pt(out));
X			}
X		if (bcmp(in,outin,8) != 0)
X			{
X			printf("Decryption error %2d\nk=%s p=%s o=%s act=%s\n",
X				i+1,pt(key_data[i]),pt(out),pt(in),pt(outin));
X			}
X		}
X
X	printf("Doing cbc\n");
X	if ((j=key_sched((C_Block *)cbc_key,ks)) != 0)
X		printf("Key error %2d:%d\n",i+1,j);
X	bzero(cbc_out,40);
X	bzero(cbc_in,40);
X	des_cbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_ENCRYPT);
X	if (bcmp(cbc_out,cbc_ok,32) != 0)
X		printf("cbc_encrypt encrypt error\n");
X	des_cbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_DECRYPT);
X	if (bcmp(cbc_in,cbc_data,32) != 0)
X		printf("cbc_encrypt decrypt error\n");
X
X	printf("Doing pcbc\n");
X	if ((j=key_sched((C_Block *)cbc_key,ks)) != 0)
X		printf("Key error %2d:%d\n",i+1,j);
X	bzero(cbc_out,40);
X	bzero(cbc_in,40);
X	des_pcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_ENCRYPT);
X	if (bcmp(cbc_out,pcbc_ok,32) != 0)
X		printf("pcbc_encrypt encrypt error\n");
X	des_pcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,DES_DECRYPT);
X	if (bcmp(cbc_in,cbc_data,32) != 0)
X		printf("pcbc_encrypt decrypt error\n");
X
X	printf("Doing cbc_cksum\n");
X	des_cbc_cksum((C_Block *)cbc_data,(C_Block *)cbc_out,
X		(long)strlen(cbc_data),ks,(C_Block *)cbc_iv);
X	if (bcmp(cbc_out,cksum_ok,8) != 0)
X		printf("cbc_cksum error\n");
X	printf("Doing quad_cksum\n");
X	cs=quad_cksum((C_Block *)cbc_data,NULL,(long)strlen(cbc_data),1,
X		(C_Block *)cbc_iv);
X	if (cs != 0x327eba8d)
X		printf("quad_cksum error, %08x should be 327eba8d\n",cs);
X
X	printf("input word alignment test");
X	for (i=0; i<4; i++)
X		{
X		printf(" %d",i);
X		des_cbc_encrypt((C_Block *)&(cbc_out[i]),(C_Block *)cbc_in,
X			(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,
X			DES_ENCRYPT);
X		}
X	printf("\noutput word alignment test");
X	for (i=0; i<4; i++)
X		{
X		printf(" %d",i);
X		des_cbc_encrypt((C_Block *)cbc_out,(C_Block *)&(cbc_in[i]),
X			(long)strlen(cbc_data),ks,(C_Block *)cbc_iv,
X			DES_ENCRYPT);
X		}
X	printf("\n");
X	printf("fast crypt test ");
X	str=crypt("testing","ef");
X	if (strcmp("efGnQx2725bI2",str) != 0)
X		printf("fast crypt error, %x should be efGnQx2725bI2\n",str);
X	str=crypt("bca76;23","yA");
X	if (strcmp("yA1Rp/1hZXIJk",str) != 0)
X		printf("fast crypt error, %x should be yA1Rp/1hZXIJk\n",str);
X	printf("\n");
X	exit(0);
X	}
X
Xchar *pt(p)
Xunsigned char *p;
X	{
X	char *ret;
X	int i;
X	static char *f="0123456789ABCDEF";
X
X	ret=(char *)malloc(17);
X	for (i=0; i<8; i++)
X		{
X		ret[i*2]=f[(p[i]>>4)&0xf];
X		ret[i*2+1]=f[p[i]&0xf];
X		}
X	ret[16]='\0';
X	return(ret);
X	}
X	
END_OF_FILE
if test 8656 -ne `wc -c <'destest.c'`; then
    echo shar: \"'destest.c'\" unpacked with wrong size!
fi
# end of 'destest.c'
fi
if test -f 'set_key.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'set_key.c'\"
else
echo shar: Extracting \"'set_key.c'\" \(4144 characters\)
sed "s/^X//" >'set_key.c' <<'END_OF_FILE'
X/* set_key.c */
X/* Copyright (C) 1992 Eric Young - see COPYING for more details */
X/* set_key.c v 1.4 eay 24/9/91
X * 1.4 Speed up by 400% :-)
X * 1.3 added register declarations.
X * 1.2 unrolled make_key_sched a bit more
X * 1.1 added norm_expand_bits
X * 1.0 First working version
X */
X#include "des_local.h"
X#include "podd.h"
X#include "sk.h"
X
Xstatic int check_parity();
X
Xint des_check_key=0;
X
Xvoid des_set_odd_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		(*key)[i]=odd_parity[(*key)[i]];
X	}
X
Xstatic int check_parity(key)
Xdes_cblock *key;
X	{
X	int i;
X
X	for (i=0; i<DES_KEY_SZ; i++)
X		{
X		if ((*key)[i] != odd_parity[(*key)[i]])
X			return(0);
X		}
X	return(1);
X	}
X
X/* Weak and semi week keys as take from
X * %A D.W. Davies
X * %A W.L. Price
X * %T Security for Computer Networks
X * %I John Wiley & Sons
X * %D 1984
X * Many thanks to smb@ulysses.att.com (Steven Bellovin) for the reference
X * (and actual cblock values).
X */
X#define NUM_WEAK_KEY	16
Xstatic des_cblock weak_keys[NUM_WEAK_KEY]={
X	/* weak keys */
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,
X	0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
X	0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,
X	/* semi-weak keys */
X	0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,
X	0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,
X	0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1,
X	0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E,
X	0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,
X	0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01,
X	0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE,
X	0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,
X	0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,
X	0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1};
X
Xint des_is_weak_key(key)
Xdes_cblock *key;
X	{
X	ulong *lp;
X	register ulong l,r;
X	int i;
X
X	c2l(key,l);
X	c2l(key,r);
X	/* the weak_keys bytes should be aligned */
X	lp=(ulong *)weak_keys;
X	for (i=0; i<NUM_WEAK_KEY; i++)
X		{
X		if ((l == lp[0]) && (r == lp[1]))
X			return(1);
X		lp+=2;
X		}
X	return(0);
X	}
X
X/* See ecb_encrypt.c for a pseudo description of these macros. */
X#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
X	(b)^=(t),\
X	(a)^=((t)<<(n)))
X
X#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
X	(a)=(a)^(t)^(t>>(16-(n))))\
X
Xstatic char shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
X
X/* return 0 if key parity is odd (correct),
X * return -1 if key parity error,
X * return -2 if illegal weak key.
X */
Xint des_set_key(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	register ulong c,d,t,s;
X	register uchar *in;
X	register ulong *k;
X	register int i;
X
X	if (des_check_key)
X		{
X		if (!check_parity(key))
X			return(-1);
X
X		if (des_is_weak_key(key))
X			return(-2);
X		}
X
X	k=(ulong *)schedule;
X	in=(uchar *)key;
X
X	c2l(in,c);
X	c2l(in,d);
X
X	/* do PC1 in 60 simple operations */ 
X	PERM_OP(d,c,t,4,0x0f0f0f0f);
X	HPERM_OP(c,t,-2, 0xcccc0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(c,t, 8, 0x00ff0000);
X	HPERM_OP(c,t,-1, 0xaaaa0000);
X	HPERM_OP(d,t,-8, 0xff000000);
X	HPERM_OP(d,t, 8, 0x00ff0000);
X	HPERM_OP(d,t, 2, 0x33330000);
X	d=((d&0x00aa00aa)<<7)|((d&0x55005500)>>7)|(d&0xaa55aa55);
X	d=(d>>8)|((c&0xf0000000)>>4);
X	c&=0x0fffffff;
X
X	for (i=0; i<ITERATIONS; i++)
X		{
X		if (shifts2[i])
X			{ c=((c>>2)|(c<<26)); d=((d>>2)|(d<<26)); }
X		else
X			{ c=((c>>1)|(c<<27)); d=((d>>1)|(d<<27)); }
X		c&=0x0fffffff;
X		d&=0x0fffffff;
X		/* could be a few less shifts but I am to lazy at this
X		 * point in time to investigate */
X		s=	des_skb[0][ (c    )&0x3f                ]|
X			des_skb[1][((c>> 6)&0x03)|((c>> 7)&0x3c)]|
X			des_skb[2][((c>>13)&0x0f)|((c>>14)&0x30)]|
X			des_skb[3][((c>>20)&0x01)|((c>>21)&0x06) |
X			                      ((c>>22)&0x38)];
X		t=	des_skb[4][ (d    )&0x3f                ]|
X			des_skb[5][((d>> 7)&0x03)|((d>> 8)&0x3c)]|
X			des_skb[6][ (d>>15)&0x3f                ]|
X			des_skb[7][((d>>21)&0x0f)|((d>>22)&0x30)];
X
X		/* table contained 0213 4657 */
X		*(k++)=((t<<16)|(s&0x0000ffff));
X		s=     ((s>>16)|(t&0xffff0000));
X		
X		s=(s<<4)|(s>>28);
X		*(k++)=s;
X		}
X	return(0);
X	}
X
Xint key_sched(key,schedule)
Xdes_cblock *key;
Xdes_key_schedule schedule;
X	{
X	return(des_set_key(key,schedule));
X	}
END_OF_FILE
if test 4144 -ne `wc -c <'set_key.c'`; then
    echo shar: \"'set_key.c'\" unpacked with wrong size!
fi
# end of 'set_key.c'
fi
if test -f 'sk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sk.h'\"
else
echo shar: Extracting \"'sk.h'\" \(6343 characters\)
sed "s/^X//" >'sk.h' <<'END_OF_FILE'
X/* sk.h */
X/* Copyright (C) 1992 Eric Young - see COPYING for more details */
Xstatic ulong des_skb[8][64]={
X/* for C bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x00000010,0x20000000,0x20000010,
X0x00010000,0x00010010,0x20010000,0x20010010,
X0x00000800,0x00000810,0x20000800,0x20000810,
X0x00010800,0x00010810,0x20010800,0x20010810,
X0x00000020,0x00000030,0x20000020,0x20000030,
X0x00010020,0x00010030,0x20010020,0x20010030,
X0x00000820,0x00000830,0x20000820,0x20000830,
X0x00010820,0x00010830,0x20010820,0x20010830,
X0x00080000,0x00080010,0x20080000,0x20080010,
X0x00090000,0x00090010,0x20090000,0x20090010,
X0x00080800,0x00080810,0x20080800,0x20080810,
X0x00090800,0x00090810,0x20090800,0x20090810,
X0x00080020,0x00080030,0x20080020,0x20080030,
X0x00090020,0x00090030,0x20090020,0x20090030,
X0x00080820,0x00080830,0x20080820,0x20080830,
X0x00090820,0x00090830,0x20090820,0x20090830,
X/* for C bits (numbered as per FIPS 46) 7 8 10 11 12 13 */
X0x00000000,0x02000000,0x00002000,0x02002000,
X0x00200000,0x02200000,0x00202000,0x02202000,
X0x00000004,0x02000004,0x00002004,0x02002004,
X0x00200004,0x02200004,0x00202004,0x02202004,
X0x00000400,0x02000400,0x00002400,0x02002400,
X0x00200400,0x02200400,0x00202400,0x02202400,
X0x00000404,0x02000404,0x00002404,0x02002404,
X0x00200404,0x02200404,0x00202404,0x02202404,
X0x10000000,0x12000000,0x10002000,0x12002000,
X0x10200000,0x12200000,0x10202000,0x12202000,
X0x10000004,0x12000004,0x10002004,0x12002004,
X0x10200004,0x12200004,0x10202004,0x12202004,
X0x10000400,0x12000400,0x10002400,0x12002400,
X0x10200400,0x12200400,0x10202400,0x12202400,
X0x10000404,0x12000404,0x10002404,0x12002404,
X0x10200404,0x12200404,0x10202404,0x12202404,
X/* for C bits (numbered as per FIPS 46) 14 15 16 17 19 20 */
X0x00000000,0x00000001,0x00040000,0x00040001,
X0x01000000,0x01000001,0x01040000,0x01040001,
X0x00000002,0x00000003,0x00040002,0x00040003,
X0x01000002,0x01000003,0x01040002,0x01040003,
X0x00000200,0x00000201,0x00040200,0x00040201,
X0x01000200,0x01000201,0x01040200,0x01040201,
X0x00000202,0x00000203,0x00040202,0x00040203,
X0x01000202,0x01000203,0x01040202,0x01040203,
X0x08000000,0x08000001,0x08040000,0x08040001,
X0x09000000,0x09000001,0x09040000,0x09040001,
X0x08000002,0x08000003,0x08040002,0x08040003,
X0x09000002,0x09000003,0x09040002,0x09040003,
X0x08000200,0x08000201,0x08040200,0x08040201,
X0x09000200,0x09000201,0x09040200,0x09040201,
X0x08000202,0x08000203,0x08040202,0x08040203,
X0x09000202,0x09000203,0x09040202,0x09040203,
X/* for C bits (numbered as per FIPS 46) 21 23 24 26 27 28 */
X0x00000000,0x00100000,0x00000100,0x00100100,
X0x00000008,0x00100008,0x00000108,0x00100108,
X0x00001000,0x00101000,0x00001100,0x00101100,
X0x00001008,0x00101008,0x00001108,0x00101108,
X0x04000000,0x04100000,0x04000100,0x04100100,
X0x04000008,0x04100008,0x04000108,0x04100108,
X0x04001000,0x04101000,0x04001100,0x04101100,
X0x04001008,0x04101008,0x04001108,0x04101108,
X0x00020000,0x00120000,0x00020100,0x00120100,
X0x00020008,0x00120008,0x00020108,0x00120108,
X0x00021000,0x00121000,0x00021100,0x00121100,
X0x00021008,0x00121008,0x00021108,0x00121108,
X0x04020000,0x04120000,0x04020100,0x04120100,
X0x04020008,0x04120008,0x04020108,0x04120108,
X0x04021000,0x04121000,0x04021100,0x04121100,
X0x04021008,0x04121008,0x04021108,0x04121108,
X/* for D bits (numbered as per FIPS 46) 1 2 3 4 5 6 */
X0x00000000,0x10000000,0x00010000,0x10010000,
X0x00000004,0x10000004,0x00010004,0x10010004,
X0x20000000,0x30000000,0x20010000,0x30010000,
X0x20000004,0x30000004,0x20010004,0x30010004,
X0x00100000,0x10100000,0x00110000,0x10110000,
X0x00100004,0x10100004,0x00110004,0x10110004,
X0x20100000,0x30100000,0x20110000,0x30110000,
X0x20100004,0x30100004,0x20110004,0x30110004,
X0x00001000,0x10001000,0x00011000,0x10011000,
X0x00001004,0x10001004,0x00011004,0x10011004,
X0x20001000,0x30001000,0x20011000,0x30011000,
X0x20001004,0x30001004,0x20011004,0x30011004,
X0x00101000,0x10101000,0x00111000,0x10111000,
X0x00101004,0x10101004,0x00111004,0x10111004,
X0x20101000,0x30101000,0x20111000,0x30111000,
X0x20101004,0x30101004,0x20111004,0x30111004,
X/* for D bits (numbered as per FIPS 46) 8 9 11 12 13 14 */
X0x00000000,0x08000000,0x00000008,0x08000008,
X0x00000400,0x08000400,0x00000408,0x08000408,
X0x00020000,0x08020000,0x00020008,0x08020008,
X0x00020400,0x08020400,0x00020408,0x08020408,
X0x00000001,0x08000001,0x00000009,0x08000009,
X0x00000401,0x08000401,0x00000409,0x08000409,
X0x00020001,0x08020001,0x00020009,0x08020009,
X0x00020401,0x08020401,0x00020409,0x08020409,
X0x02000000,0x0A000000,0x02000008,0x0A000008,
X0x02000400,0x0A000400,0x02000408,0x0A000408,
X0x02020000,0x0A020000,0x02020008,0x0A020008,
X0x02020400,0x0A020400,0x02020408,0x0A020408,
X0x02000001,0x0A000001,0x02000009,0x0A000009,
X0x02000401,0x0A000401,0x02000409,0x0A000409,
X0x02020001,0x0A020001,0x02020009,0x0A020009,
X0x02020401,0x0A020401,0x02020409,0x0A020409,
X/* for D bits (numbered as per FIPS 46) 16 17 18 19 20 21 */
X0x00000000,0x00000100,0x00080000,0x00080100,
X0x01000000,0x01000100,0x01080000,0x01080100,
X0x00000010,0x00000110,0x00080010,0x00080110,
X0x01000010,0x01000110,0x01080010,0x01080110,
X0x00200000,0x00200100,0x00280000,0x00280100,
X0x01200000,0x01200100,0x01280000,0x01280100,
X0x00200010,0x00200110,0x00280010,0x00280110,
X0x01200010,0x01200110,0x01280010,0x01280110,
X0x00000200,0x00000300,0x00080200,0x00080300,
X0x01000200,0x01000300,0x01080200,0x01080300,
X0x00000210,0x00000310,0x00080210,0x00080310,
X0x01000210,0x01000310,0x01080210,0x01080310,
X0x00200200,0x00200300,0x00280200,0x00280300,
X0x01200200,0x01200300,0x01280200,0x01280300,
X0x00200210,0x00200310,0x00280210,0x00280310,
X0x01200210,0x01200310,0x01280210,0x01280310,
X/* for D bits (numbered as per FIPS 46) 22 23 24 25 27 28 */
X0x00000000,0x04000000,0x00040000,0x04040000,
X0x00000002,0x04000002,0x00040002,0x04040002,
X0x00002000,0x04002000,0x00042000,0x04042000,
X0x00002002,0x04002002,0x00042002,0x04042002,
X0x00000020,0x04000020,0x00040020,0x04040020,
X0x00000022,0x04000022,0x00040022,0x04040022,
X0x00002020,0x04002020,0x00042020,0x04042020,
X0x00002022,0x04002022,0x00042022,0x04042022,
X0x00000800,0x04000800,0x00040800,0x04040800,
X0x00000802,0x04000802,0x00040802,0x04040802,
X0x00002800,0x04002800,0x00042800,0x04042800,
X0x00002802,0x04002802,0x00042802,0x04042802,
X0x00000820,0x04000820,0x00040820,0x04040820,
X0x00000822,0x04000822,0x00040822,0x04040822,
X0x00002820,0x04002820,0x00042820,0x04042820,
X0x00002822,0x04002822,0x00042822,0x04042822,
X};
END_OF_FILE
if test 6343 -ne `wc -c <'sk.h'`; then
    echo shar: \"'sk.h'\" unpacked with wrong size!
fi
# end of 'sk.h'
fi
if test -f 'sp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sp.h'\"
else
echo shar: Extracting \"'sp.h'\" \(6392 characters\)
sed "s/^X//" >'sp.h' <<'END_OF_FILE'
X/* sp.h */
X/* Copyright (C) 1992 Eric Young - see COPYING for more details */
Xstatic unsigned long des_SPtrans[8][64]={
X/* nibble 0 */
X0x00410100, 0x00010000, 0x40400000, 0x40410100,
X0x00400000, 0x40010100, 0x40010000, 0x40400000,
X0x40010100, 0x00410100, 0x00410000, 0x40000100,
X0x40400100, 0x00400000, 0x00000000, 0x40010000,
X0x00010000, 0x40000000, 0x00400100, 0x00010100,
X0x40410100, 0x00410000, 0x40000100, 0x00400100,
X0x40000000, 0x00000100, 0x00010100, 0x40410000,
X0x00000100, 0x40400100, 0x40410000, 0x00000000,
X0x00000000, 0x40410100, 0x00400100, 0x40010000,
X0x00410100, 0x00010000, 0x40000100, 0x00400100,
X0x40410000, 0x00000100, 0x00010100, 0x40400000,
X0x40010100, 0x40000000, 0x40400000, 0x00410000,
X0x40410100, 0x00010100, 0x00410000, 0x40400100,
X0x00400000, 0x40000100, 0x40010000, 0x00000000,
X0x00010000, 0x00400000, 0x40400100, 0x00410100,
X0x40000000, 0x40410000, 0x00000100, 0x40010100,
X
X/* nibble 1 */
X0x08021002, 0x00000000, 0x00021000, 0x08020000,
X0x08000002, 0x00001002, 0x08001000, 0x00021000,
X0x00001000, 0x08020002, 0x00000002, 0x08001000,
X0x00020002, 0x08021000, 0x08020000, 0x00000002,
X0x00020000, 0x08001002, 0x08020002, 0x00001000,
X0x00021002, 0x08000000, 0x00000000, 0x00020002,
X0x08001002, 0x00021002, 0x08021000, 0x08000002,
X0x08000000, 0x00020000, 0x00001002, 0x08021002,
X0x00020002, 0x08021000, 0x08001000, 0x00021002,
X0x08021002, 0x00020002, 0x08000002, 0x00000000,
X0x08000000, 0x00001002, 0x00020000, 0x08020002,
X0x00001000, 0x08000000, 0x00021002, 0x08001002,
X0x08021000, 0x00001000, 0x00000000, 0x08000002,
X0x00000002, 0x08021002, 0x00021000, 0x08020000,
X0x08020002, 0x00020000, 0x00001002, 0x08001000,
X0x08001002, 0x00000002, 0x08020000, 0x00021000,
X
X/* nibble 2 */
X0x20800000, 0x00808020, 0x00000020, 0x20800020,
X0x20008000, 0x00800000, 0x20800020, 0x00008020,
X0x00800020, 0x00008000, 0x00808000, 0x20000000,
X0x20808020, 0x20000020, 0x20000000, 0x20808000,
X0x00000000, 0x20008000, 0x00808020, 0x00000020,
X0x20000020, 0x20808020, 0x00008000, 0x20800000,
X0x20808000, 0x00800020, 0x20008020, 0x00808000,
X0x00008020, 0x00000000, 0x00800000, 0x20008020,
X0x00808020, 0x00000020, 0x20000000, 0x00008000,
X0x20000020, 0x20008000, 0x00808000, 0x20800020,
X0x00000000, 0x00808020, 0x00008020, 0x20808000,
X0x20008000, 0x00800000, 0x20808020, 0x20000000,
X0x20008020, 0x20800000, 0x00800000, 0x20808020,
X0x00008000, 0x00800020, 0x20800020, 0x00008020,
X0x00800020, 0x00000000, 0x20808000, 0x20000020,
X0x20800000, 0x20008020, 0x00000020, 0x00808000,
X
X/* nibble 3 */
X0x00080201, 0x02000200, 0x00000001, 0x02080201,
X0x00000000, 0x02080000, 0x02000201, 0x00080001,
X0x02080200, 0x02000001, 0x02000000, 0x00000201,
X0x02000001, 0x00080201, 0x00080000, 0x02000000,
X0x02080001, 0x00080200, 0x00000200, 0x00000001,
X0x00080200, 0x02000201, 0x02080000, 0x00000200,
X0x00000201, 0x00000000, 0x00080001, 0x02080200,
X0x02000200, 0x02080001, 0x02080201, 0x00080000,
X0x02080001, 0x00000201, 0x00080000, 0x02000001,
X0x00080200, 0x02000200, 0x00000001, 0x02080000,
X0x02000201, 0x00000000, 0x00000200, 0x00080001,
X0x00000000, 0x02080001, 0x02080200, 0x00000200,
X0x02000000, 0x02080201, 0x00080201, 0x00080000,
X0x02080201, 0x00000001, 0x02000200, 0x00080201,
X0x00080001, 0x00080200, 0x02080000, 0x02000201,
X0x00000201, 0x02000000, 0x02000001, 0x02080200,
X
X/* nibble 4 */
X0x01000000, 0x00002000, 0x00000080, 0x01002084,
X0x01002004, 0x01000080, 0x00002084, 0x01002000,
X0x00002000, 0x00000004, 0x01000004, 0x00002080,
X0x01000084, 0x01002004, 0x01002080, 0x00000000,
X0x00002080, 0x01000000, 0x00002004, 0x00000084,
X0x01000080, 0x00002084, 0x00000000, 0x01000004,
X0x00000004, 0x01000084, 0x01002084, 0x00002004,
X0x01002000, 0x00000080, 0x00000084, 0x01002080,
X0x01002080, 0x01000084, 0x00002004, 0x01002000,
X0x00002000, 0x00000004, 0x01000004, 0x01000080,
X0x01000000, 0x00002080, 0x01002084, 0x00000000,
X0x00002084, 0x01000000, 0x00000080, 0x00002004,
X0x01000084, 0x00000080, 0x00000000, 0x01002084,
X0x01002004, 0x01002080, 0x00000084, 0x00002000,
X0x00002080, 0x01002004, 0x01000080, 0x00000084,
X0x00000004, 0x00002084, 0x01002000, 0x01000004,
X
X/* nibble 5 */
X0x10000008, 0x00040008, 0x00000000, 0x10040400,
X0x00040008, 0x00000400, 0x10000408, 0x00040000,
X0x00000408, 0x10040408, 0x00040400, 0x10000000,
X0x10000400, 0x10000008, 0x10040000, 0x00040408,
X0x00040000, 0x10000408, 0x10040008, 0x00000000,
X0x00000400, 0x00000008, 0x10040400, 0x10040008,
X0x10040408, 0x10040000, 0x10000000, 0x00000408,
X0x00000008, 0x00040400, 0x00040408, 0x10000400,
X0x00000408, 0x10000000, 0x10000400, 0x00040408,
X0x10040400, 0x00040008, 0x00000000, 0x10000400,
X0x10000000, 0x00000400, 0x10040008, 0x00040000,
X0x00040008, 0x10040408, 0x00040400, 0x00000008,
X0x10040408, 0x00040400, 0x00040000, 0x10000408,
X0x10000008, 0x10040000, 0x00040408, 0x00000000,
X0x00000400, 0x10000008, 0x10000408, 0x10040400,
X0x10040000, 0x00000408, 0x00000008, 0x10040008,
X
X/* nibble 6 */
X0x00000800, 0x00000040, 0x00200040, 0x80200000,
X0x80200840, 0x80000800, 0x00000840, 0x00000000,
X0x00200000, 0x80200040, 0x80000040, 0x00200800,
X0x80000000, 0x00200840, 0x00200800, 0x80000040,
X0x80200040, 0x00000800, 0x80000800, 0x80200840,
X0x00000000, 0x00200040, 0x80200000, 0x00000840,
X0x80200800, 0x80000840, 0x00200840, 0x80000000,
X0x80000840, 0x80200800, 0x00000040, 0x00200000,
X0x80000840, 0x00200800, 0x80200800, 0x80000040,
X0x00000800, 0x00000040, 0x00200000, 0x80200800,
X0x80200040, 0x80000840, 0x00000840, 0x00000000,
X0x00000040, 0x80200000, 0x80000000, 0x00200040,
X0x00000000, 0x80200040, 0x00200040, 0x00000840,
X0x80000040, 0x00000800, 0x80200840, 0x00200000,
X0x00200840, 0x80000000, 0x80000800, 0x80200840,
X0x80200000, 0x00200840, 0x00200800, 0x80000800,
X
X/* nibble 7 */
X0x04100010, 0x04104000, 0x00004010, 0x00000000,
X0x04004000, 0x00100010, 0x04100000, 0x04104010,
X0x00000010, 0x04000000, 0x00104000, 0x00004010,
X0x00104010, 0x04004010, 0x04000010, 0x04100000,
X0x00004000, 0x00104010, 0x00100010, 0x04004000,
X0x04104010, 0x04000010, 0x00000000, 0x00104000,
X0x04000000, 0x00100000, 0x04004010, 0x04100010,
X0x00100000, 0x00004000, 0x04104000, 0x00000010,
X0x00100000, 0x00004000, 0x04000010, 0x04104010,
X0x00004010, 0x04000000, 0x00000000, 0x00104000,
X0x04100010, 0x04004010, 0x04004000, 0x00100010,
X0x04104000, 0x00000010, 0x00100010, 0x04004000,
X0x04104010, 0x00100000, 0x04100000, 0x04000010,
X0x00104000, 0x00004010, 0x04004010, 0x04100000,
X0x00000010, 0x04104000, 0x00104010, 0x00000000,
X0x04000000, 0x04100010, 0x00004000, 0x00104010};
END_OF_FILE
if test 6392 -ne `wc -c <'sp.h'`; then
    echo shar: \"'sp.h'\" unpacked with wrong size!
fi
# end of 'sp.h'
fi
if test -f 'testdes.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'testdes.pl'\"
else
echo shar: Extracting \"'testdes.pl'\" \(5644 characters\)
sed "s/^X//" >'testdes.pl' <<'END_OF_FILE'
X#!/usr/local/bin/perl
X
X# des.pl tesing code
X
Xrequire 'des.pl';
X
X$num_tests=34;
X@key_data=(
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	0x7C,0xA1,0x10,0x45,0x4A,0x1A,0x6E,0x57,
X	0x01,0x31,0xD9,0x61,0x9D,0xC1,0x37,0x6E,
X	0x07,0xA1,0x13,0x3E,0x4A,0x0B,0x26,0x86,
X	0x38,0x49,0x67,0x4C,0x26,0x02,0x31,0x9E,
X	0x04,0xB9,0x15,0xBA,0x43,0xFE,0xB5,0xB6,
X	0x01,0x13,0xB9,0x70,0xFD,0x34,0xF2,0xCE,
X	0x01,0x70,0xF1,0x75,0x46,0x8F,0xB5,0xE6,
X	0x43,0x29,0x7F,0xAD,0x38,0xE3,0x73,0xFE,
X	0x07,0xA7,0x13,0x70,0x45,0xDA,0x2A,0x16,
X	0x04,0x68,0x91,0x04,0xC2,0xFD,0x3B,0x2F,
X	0x37,0xD0,0x6B,0xB5,0x16,0xCB,0x75,0x46,
X	0x1F,0x08,0x26,0x0D,0x1A,0xC2,0x46,0x5E,
X	0x58,0x40,0x23,0x64,0x1A,0xBA,0x61,0x76,
X	0x02,0x58,0x16,0x16,0x46,0x29,0xB0,0x07,
X	0x49,0x79,0x3E,0xBC,0x79,0xB3,0x25,0x8F,
X	0x4F,0xB0,0x5E,0x15,0x15,0xAB,0x73,0xA7,
X	0x49,0xE9,0x5D,0x6D,0x4C,0xA2,0x29,0xBF,
X	0x01,0x83,0x10,0xDC,0x40,0x9B,0x26,0xD6,
X	0x1C,0x58,0x7F,0x1C,0x13,0x92,0x4F,0xEF,
X	0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
X	0x1F,0x1F,0x1F,0x1F,0x0E,0x0E,0x0E,0x0E,
X	0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
X	);
X
X@plain_data=(
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0xA1,0xD6,0xD0,0x39,0x77,0x67,0x42,
X	0x5C,0xD5,0x4C,0xA8,0x3D,0xEF,0x57,0xDA,
X	0x02,0x48,0xD4,0x38,0x06,0xF6,0x71,0x72,
X	0x51,0x45,0x4B,0x58,0x2D,0xDF,0x44,0x0A,
X	0x42,0xFD,0x44,0x30,0x59,0x57,0x7F,0xA2,
X	0x05,0x9B,0x5E,0x08,0x51,0xCF,0x14,0x3A,
X	0x07,0x56,0xD8,0xE0,0x77,0x47,0x61,0xD2,
X	0x76,0x25,0x14,0xB8,0x29,0xBF,0x48,0x6A,
X	0x3B,0xDD,0x11,0x90,0x49,0x37,0x28,0x02,
X	0x26,0x95,0x5F,0x68,0x35,0xAF,0x60,0x9A,
X	0x16,0x4D,0x5E,0x40,0x4F,0x27,0x52,0x32,
X	0x6B,0x05,0x6E,0x18,0x75,0x9F,0x5C,0xCA,
X	0x00,0x4B,0xD6,0xEF,0x09,0x17,0x60,0x62,
X	0x48,0x0D,0x39,0x00,0x6E,0xE7,0x62,0xF2,
X	0x43,0x75,0x40,0xC8,0x69,0x8F,0x3C,0xFA,
X	0x07,0x2D,0x43,0xA0,0x77,0x07,0x52,0x92,
X	0x02,0xFE,0x55,0x77,0x81,0x17,0xF1,0x2A,
X	0x1D,0x9D,0x5C,0x50,0x18,0xF7,0x28,0xC2,
X	0x30,0x55,0x32,0x28,0x6D,0x6F,0x29,0x5A,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X	0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF);
X
X@cipher_data=(
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0x73,0x59,0xB2,0x16,0x3E,0x4E,0xDC,0x58,
X	0x95,0x8E,0x6E,0x62,0x7A,0x05,0x55,0x7B,
X	0xF4,0x03,0x79,0xAB,0x9E,0x0E,0xC5,0x33,
X	0x17,0x66,0x8D,0xFC,0x72,0x92,0x53,0x2D,
X	0x8A,0x5A,0xE1,0xF8,0x1A,0xB8,0xF2,0xDD,
X	0x8C,0xA6,0x4D,0xE9,0xC1,0xB1,0x23,0xA7,
X	0xED,0x39,0xD9,0x50,0xFA,0x74,0xBC,0xC4,
X	0x69,0x0F,0x5B,0x0D,0x9A,0x26,0x93,0x9B,
X	0x7A,0x38,0x9D,0x10,0x35,0x4B,0xD2,0x71,
X	0x86,0x8E,0xBB,0x51,0xCA,0xB4,0x59,0x9A,
X	0x71,0x78,0x87,0x6E,0x01,0xF1,0x9B,0x2A,
X	0xAF,0x37,0xFB,0x42,0x1F,0x8C,0x40,0x95,
X	0x86,0xA5,0x60,0xF1,0x0E,0xC6,0xD8,0x5B,
X	0x0C,0xD3,0xDA,0x02,0x00,0x21,0xDC,0x09,
X	0xEA,0x67,0x6B,0x2C,0xB7,0xDB,0x2B,0x7A,
X	0xDF,0xD6,0x4A,0x81,0x5C,0xAF,0x1A,0x0F,
X	0x5C,0x51,0x3C,0x9C,0x48,0x86,0xC0,0x88,
X	0x0A,0x2A,0xEE,0xAE,0x3F,0xF4,0xAB,0x77,
X	0xEF,0x1B,0xF0,0x3E,0x5D,0xFA,0x57,0x5A,
X	0x88,0xBF,0x0D,0xB6,0xD7,0x0D,0xEE,0x56,
X	0xA1,0xF9,0x91,0x55,0x41,0x02,0x0B,0x56,
X	0x6F,0xBF,0x1C,0xAF,0xCF,0xFD,0x05,0x56,
X	0x2F,0x22,0xE4,0x9B,0xAB,0x7C,0xA1,0xAC,
X	0x5A,0x6B,0x61,0x2C,0xC2,0x6C,0xCE,0x4A,
X	0x5F,0x4C,0x03,0x8E,0xD1,0x2B,0x2E,0x41,
X	0x63,0xFA,0xC0,0xD0,0x34,0xD9,0xF7,0x93,
X	0x61,0x7B,0x3A,0x0C,0xE8,0xF0,0x71,0x00,
X	0xDB,0x95,0x86,0x05,0xF8,0xC8,0xC6,0x06,
X	0xED,0xBF,0xD1,0xC6,0x6C,0x29,0xCC,0xC7,
X	0x35,0x55,0x50,0xB2,0x15,0x0E,0x24,0x51,
X	0xCA,0xAA,0xAF,0x4D,0xEA,0xF1,0xDB,0xAE,
X	0xD5,0xD4,0x4F,0xF7,0x20,0x68,0x3D,0x0D,
X	0x2A,0x2B,0xB0,0x08,0xDF,0x97,0xC2,0xF2);
X
Xprint "Doing ecb tests\n";
Xfor ($i=0; $i<$num_tests; $i++)
X	{
X	printf "Doing test $i\n";
X	$key =pack("C8",splice(@key_data   ,0,8));
X	$data=pack("C8",splice(@plain_data ,0,8));
X	$res =pack("C8",splice(@cipher_data,0,8));
X
X	@ks=  &des_set_key($key);
X	$out1= &des_ecb_encrypt(*ks,1,$data);
X	$out2= &des_ecb_encrypt(*ks,0,$out1);
X	$out3= &des_ecb_encrypt(*ks,0,$res);
X	&eprint("encryption failure",$res,$out1)
X		if ($out1 ne $res);
X	&eprint("encryption/decryption failure",$data,$out2)
X		if ($out2 ne $data);
X	&eprint("decryption failure",$data,$out3)
X		if ($data ne $out3);
X	}
Xprint "Done\n";
X
Xprint "doing speed test over 30 seconds\n";
X$SIG{'ALRM'}='done';
Xsub done {$done=1;}
X$done=0;
X
X$count=0;
X$d=pack("C8",0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef);
X@ks=  &des_set_key($d);
Xalarm(30);
X$start=(times)[0];
Xwhile (!$done)
X	{
X	$count++;
X	$d=&des_ecb_encrypt(*ks,1,$d);
X	}
X$end=(times)[0];
X$t=$end-$start;
Xprintf "$count DESs in %.2f seconds is %.2f DESs/sec or %.2f bytes/sec\n",
X	1.0*$t,1.0*$count/$t,$count*8.0/$t;
X
Xsub eprint
X	{
X	local($s,$c,$e)=@_;
X	local(@k);
X
X	@k=unpack("C8",$c);
X	printf "%02x%02x%02x%02x %02x%02x%02x%02x - ",unpack("C8",$c);
X	printf "%02x%02x%02x%02x %02x%02x%02x%02x :",unpack("C8",$e);
X	print " $s\n";
X	}
END_OF_FILE
if test 5644 -ne `wc -c <'testdes.pl'`; then
    echo shar: \"'testdes.pl'\" unpacked with wrong size!
fi
# end of 'testdes.pl'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
exit 0 # Just in case...
