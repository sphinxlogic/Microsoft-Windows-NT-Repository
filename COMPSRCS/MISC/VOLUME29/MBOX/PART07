Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i069:  mbox - A Bulletin Board System for UNIX and MINIX, Part07/10
Message-ID: <1992Apr5.183617.29887@sparky.imd.sterling.com>
X-Md4-Signature: 70340675a0150e9c13ee73aa72e3d766
Date: Sun, 5 Apr 1992 18:36:17 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 69
Archive-name: mbox/part07
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Changelog TUTORIAL etc/english.hilfe src/bled.c
#   src/lesen2.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:45 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 10)."'
if test -f 'Changelog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Changelog'\"
else
  echo shar: Extracting \"'Changelog'\" \(8260 characters\)
  sed "s/^X//" >'Changelog' <<'END_OF_FILE'
X
XHeute, nach einem Telefonat mit Volker haben wir beschlossen die Versionen
Xder ix/MBox mal auf einen Gleichstand zu bringen.
X
XDa inzwischen mehrere Leute an der Box programmieren, verliert man leicht
Xden Ueberblick, wenn nicht von einem definierten Stand der Version ausge-
Xgangen wird.
X
XDie Version 1.6.0 soll deshalb die Version sein, auf die sich alle nach-
Xfolgenden Aenderungen beziehen!
X
XAlso wenn Aenderungen gemacht werden, diff's erzeugen und Volker schicken.
XDabei sollte man die Angabe der Version (ab Version 1.6.0) und Patchlevel
Xnicht vergessen, auf die sich das Diff bezieht!
X
XUm Aenderungen nachvollziehen zu koennen, waehre meine Bitte, an dieses
XFile kurze Erlaeuterungen zu den Aenderungen anzuhaengen!
X
X---------------------------------------------------------------------------
X
XSat Nov 16 02:21:20 MEZ 1991, Hergo Pape <hergo@ivcmd.Boerde.DE>
X
Xix/MBox 1.6 PL1::
X
X-  File patchlevel.h eingefuert, hier sind die Version, der Autor und
X   die aktuelle Patchlevel definiert. Das File wird in mbox.h eingelesen.
X
X-  Makefile geaendert, "bled" braucht nicht mehr extra uebersetzt werden.
X   Die Variable MBOXHOME eingefuehrt, daher man kann jetzt die Sourcen
X   irgendwo uebersetzen und installiert wird in MBOXHOME. Ist meiner Meinung
X   nach guenstiger fuer die Versionskontrolle.
X
X-  In nerror() den Aufruf der Funktion loop() gegen longjmp() ausgetauscht.
X   Zumindest unter ISC gibt es jetzt kein core mehr beim verlassen der Box.
X
X-  In mb-daemon.c gibt die Finktion scan() nur char zurueck! Geaendert auf
X   char *scan(), da ein String zurueckgegeben wird.
X
X-  In bled.c, HILFE wird jetzt im Makefile definiert.
X
X-  File portinfo.c, bei ps musz leider anstatt "ps a", "ps -a" angegeben
X   werden. Kann jetzt per #define in mbox.h definiert werden.
X   Wenn ich <defunkt> Prozesse habe, geht das aber auch noch nicht richtig.
X
X-  If's auf File-Zeiger von 0 nach NULL geaendert. Ich hoffe ich habe alle
X   gefunden.
X
X---------------------------------------------------------------------------
X
XSun Nov 17 09:02:12 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL1::
X
X-  Fataler Fehler im File xmd.c gefunden und behoben. 
X   (Das Uebliche: "=" oder "==", dass ist hier die Frage ...)
X
X-  Ausgabe im Modus "Seitenweise ausgeben, Seitende markieren" komplett
X   ueberarbeitet. Diese Aenderung bezieht sich auf show.c, portinfo.c,
X   tools.c, misc2.c, misc.c und lesen2.c.
X
X-  Hergo's Makefile fast komplett uebernommen - leider ist MINIXens
X   MAKE etwas umstaendlicher, desshalb musste 'ne kleinere Aenderung
X   gemacht werden.
X
X-  Die Geschichte mit "ps -a" wird generell so gefahren, denn auch
X   MINIX kennt diese Flagge. 
X
X---------------------------------------------------------------------------
X
XWed Nov 20 17:02:12 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL2::
X
X-  Im Makefile gab's noch ein paar Unstimmigkeiten .... jetzt gibt's
X   ein paar weniger :-)
X
X-  Fuer den Fall das die Datei UDBASE (siehe mbox.h) nicht existiert,
X   richtet die MBox automagisch eine Userdatenbank ein, die den 
X   Definitionen in mbox.h angepasst wird.
X
X-  In admin.c war eine Forward Deklaration nicht zulaessig.
X
X-  Die SYSV-Version hatte den "nnpost" nicht im Griff. Dieses Problem
X   ist jetzt behoben - allerdings werden Subject, Keywords und Summary
X   mit "No xxxx." gefuellt wenn sie nicht definiert vom User definiert
X   wurden.
X
X---------------------------------------------------------------------------
X
XSat Nov 23 16:22:24 MEZ 1991, Hergo Pape <hergo@ivcmd.Boerde.DE>
X
Xix/MBox 1.6 PL3::
X
X -  In coreleft.c noch ein "#include <malloc.h> eingefuegt, sonst kommt
X    bei malloc() ein Warning.
X -  Im Makefile ist weiterl.c angegeben! habe das File weiterleiten.c
X    entsprechend umbenannt.
X -  Unter ISC gibt es keine Funktion "chgrp()", das wird wie bei SYS7
X    mit chown() gemacht. 
X -  In bled.c wurde HILFE nochmal definiert! Habe #ifndef Klammer drum
X    gesetzt.
X -  In xmd.c fehlt in der Funktion main(), ganz hinten eine Klammer '}'!.
X
X---------------------------------------------------------------------------
X
XSun Nov 24 11:15:43 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL3::
X
X -  Die Flagge -D_ISC sorgt dafuer, dass auch unter Interactive UNIX
X    der System Call "chown" statt "chown"&"chgrp" eingesetzt wird.
X
X -  Die Flagge -D_DATESTAMP gibt auf der Console (oder auf was immer
X    gerade per REDIRECT umgeleitet wird) zusaetlich zu den alten MBox-
X    Informatione auch Datum und Uhrzeit aus.
X
X---------------------------------------------------------------------------
X
XWed Dec 4 19:41:02 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL4::
X
X -  Die Flagge -D_SCO entspricht fast komplett -D_ISC. Allerdings wird
X    die Definition der ENTER Taste bei -D_SCO zusaetzlich beeinflusst
X    (ENTER = 13).
X
X -  Im Makefile fehlte bei PROGS die Angabe "xmd" ("mb-daemon" war doppelt
X    aufgefuehrt.
X
X -  Die Umbenennung von "weiterleiten.c" auf "weiterl.c" bleibt auch
X    weiterhin den Installateuren ueberlassen :-)
X
X
X---------------------------------------------------------------------------
X
XSun Dec 8 19:41:02 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL4::
X
X -  Da die MBox ab sofort komplett auf RMAIL und INEWS aufsetzt, gibt's
X    ein paar GROESSERE Aenderungen:
X
X    Die Modi SYS_ACCOUNT und HDB_UUCP wurden komplett deaktiviert.
X
X    Die Kommunikation mit RMAIL, INEWS und SMAIL (?) laeuft ueber drei
X    Shell-Scripts: $MBOXHOME/etc/rmail.sh, ~/etc/inews.sh und ~/etc/alias.sh
X
X -  Bisher habe ich es nicht fertig gebracht auf SETUID "root" zu verzichten.    
X    Auch nach der Umstellung auf RMAIL/INEWS laufen MB-DAEMON und MBOX
X    nur mit "root"-Permissions fehlerfrei.
X
X---------------------------------------------------------------------------
X
XSat Dec 28 18:11:41 CET 1991, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6e PL5::
X    
X -  Alle Text-Zeilen im Source-Code der ix/MBox wurden entfernt und durch
X    #DEFINES ersetzt. Diese Defines koennen ueber das "Language-File"
X    [mbox.msg] belegt werde.
X
X -  Die Dateien [help.befehle], [help.hilfe] und [help.shorthelp] liegen
X    in englischen Versionen vor. Das gilt auch fuer die Dokumentation.
X
X -  Verschiedene Fehler in "lesen2.c" und "admin.c" wurden behoben. Ausserdem
X    wird neue Post auch direkt beim Anmelden angekuendigt. 
X
X
X---------------------------------------------------------------------------
X
XWed Jan 1 11:11:11 CET 1992, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL6::
X
X -  Probleme mit "ifdef XXX || XXX" in [defs.h] und [getline.c] geloest.
X
X -  Der XMD wertet nur noch das erste Auftreten von "From:" und "Subject:"
X    aus. Bei "From" (aus dem Envelope) gibt's 'ne Sonderregelung. 
X
X---------------------------------------------------------------------------
X
XWed Jan 4 22:31:51 CET 1992, Volker Schuermann <volkers@unnet.w.open.de>
X
Xix/MBox 1.6 PL6::
X
X -  Befehl "Suchen" testweise implementiert. Er setzt auf GREP auf.
X
X -  Die Header von MAIL und NEWS koennen editiert werden. "Followup" und
X    "Poster" werden erkannt und ausgewertet.
X
X---------------------------------------------------------------------------
X
XTue Feb 17 21:02:32 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL8.7::
X
X -  Befehl "User" erweitert: Informationen ueber lokale User aus der
X    Userdatenbank, oder per "uux" von anderen Sites.
X
X -  Sicherheitslecks in "postfach.c" und "admin.c" gefunden und entschaerft.
X
X -  Header werden generell <intensive> ausgegeben.
X
X -  Funktion "Download" bietet die Option mehrer Dateien mit einem
X    Kommando zu uebertragen.
X
X -  Funktion "Statistik #" zeigt zusaetlich die Ausnutzung der Baudrate
X    in Prozent an.
X
X -  Befehl "Statistik %" errechnet eine HITLISTE aus der Liste der
X    Downloads.
X
X -  Erfassung in "postfach.c" und "admin.c" erlaubt keine Sonderzeichen
X    in Name, Nick/Alias und Shell-Name.
X
X -  XMD verfuegt ueber eine XMD.ALIAS-Datei, in der Empfaenger-Adressen
X    lokal umgeleitet werden koennen.
X
X -  Das Makefile wurde ERHEBLICH verbessert!
X
X -  Die INDEX-Files muessen nicht mehr global fuer alle Gruppen im
X    voraus gebildet werden, sondern koennen auch online von der MBox
X    gruppenweise erstellt werden.
END_OF_FILE
  if test 8260 -ne `wc -c <'Changelog'`; then
    echo shar: \"'Changelog'\" unpacked with wrong size!
  fi
  # end of 'Changelog'
fi
if test -f 'TUTORIAL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TUTORIAL'\"
else
  echo shar: Extracting \"'TUTORIAL'\" \(10956 characters\)
  sed "s/^X//" >'TUTORIAL' <<'END_OF_FILE'
X
X
X
X
X
X
X
X
X
X			ix/MBox BETA-Test Version
X		  Mailbox-Programm fuer UNIX(-Derivate)
X			
X			   Volker Schuermann
X		      Wuppertal, FRG, 08.12.1991
X
X
X
X
X
X
X
X
X
X
X
X
X          INHALT (Tutorial Beta-Entwurf (internal use only !))
X=============================================================================
X
X    1.  ALLGEMEINES
X
X	1.1.  Public Domain ?!
X	1.2.  Struktur der Programme
X
X    2.  UMGEBUNG (Voraussetzungen)
X
X	2.1.  Fuer alle
X	2.2.  Speziell fuer Minix
X
X    3.  INSTALLATION
X
X	3.1.  Anpassungen "mbox.h"
X	3.2.  Anpassungen "mb-daemon.c"
X	3.3.  Anpassungen "/usr/lib/crontab"
X	3.4.  Anpassungen "/etc/passwd"
X	3.5.  Die Verteilung der Rechte
X	3.6.  Kommunikation mit RMAIL & INEWS
X
X    4.  VERWALTUNG
X	
X	4.1.  der Teilnehmer (Bitte VOR dem ersten Aufruf der MBox lesen !)
X	4.2.  der Dateien
X
X    5.  WEITERE INFOS
X	
X	5.1.  Mail genuegt
X	5.2.  Updates
X
X
X
X
X
X
X1. ALLGEMEIN
X=============================================================================
X
X1.1.  Public Domain ?!
X======================
X
XDas gesammte Programmpaket darf beliebig oft weitergegeben und eingesetzt
Xwerden. 
X
XEs duerfen keine veraenderten Versionen verbreitet werden. Jede Veraenderung
Xmuss dem Autor als ASCII-Textfile uebermittelt werden. Er entscheidet, ob
Xdie Veraenderung in die naechste Version aufgenommen wird.
X
XDie Routine "getch.c" stammt nicht vom Autor, sondern von "attron!chris" !
X
X
X
X1.2. Struktur der Programme
X===========================
X
XMir ist voellig klar, 
X
X... dass jeder die Routinen der "ix/MBox" effizienter, 
Xstrukturierter und "besser" schreiben koennte. 
X
X... dass GOTOs und globale Varibalen nicht unbedingt zum
XHandwerkszeug eine C-Programmierers gehoehren sollten.
X
X... dass viele Routinen aussehen, als waeren sie schnell
X"ins Unreine" geschrieben worden - bei etlichen trifft das zu.
X
X... dass keine der Routinen einem LINT standhalten koennte.
X
X... dass jeder, der diese Punkte bemaengelt, selbst zu faul 
Xwar, eine MBox auf die Beine zu stellen ...
X
X
X
X
X2. UMGEBUNG
X=============================================================================
X
X2.1. Fuer alle
X==============
XFolgende Programme MUESSEN bereits auf dem Host-Rechner installiert und
Xeinsatzfaehig sein:
X
X- UUCP (UUCICO, UUX, UUXQT, ...)  
X
X- NEWS (RNEWS, PNEWS, EXPIRE, NNPOST, ...)
X
X- MAIL (LMAIL)
X
X- UMAIL (SENDMAIL, SMAIL etc.)
X
XDie MBox setzt auf dieser Programm-Konstellation auf. Sie ist nicht ein-
Xsatzfaehig, wenn eines der Programm nicht verfuegbar ist.
X
X
X
X2.2. Speziell fuer Minix
X========================
XDie MBox wurde entwickelt unter MINIX 1.5.10 ... folgenden Patches muessen
Xbei dieser Version angewendet werden:
X
X- Bruce Evans MX386-Patches
X
XVorteilhaft aber nicht zwingend erforderlich:
X
X- Gordon Irlams VC (virtuelle Consolen)
X
X- Shoelace (zum Booten von Harddisk)
X
XDie "ix/MBox" laeuft NICHT im 64+64 Modus, sondern nur unter 386er MINIX !
XWie's bei 68000er MINIX aussieht, ist bisher nicht geprueft worden.
X
X
X
X3. INSTALLATION
X=============================================================================
X
X3.1. Anpassungen ("mbox.h")
X===========================
XDie Datei "mbox.h" enthaelt die wichtigsten system-spezifischen Parameter.
XDiese Parameter MUESSEN (zum Teil) unbedingt angepasst werden. 
X
XDie einzelnen Eintraege sind in der Datei dokumentiert - Fehler bei der
XAnpassung ziehen WEITE Kreise ... VORSICHT ist die Mutter der Porzellankiste.
X
XPfade, deren Definition mit "./" beginnen, beziehen sich auf die MBox und 
Xderen HOME-Verzeichnis. Diese Pfade muessen/sollten NICHT geandert werden.
X
XDas gilt praktisch fuer alle Definitionen, die nicht durch ein vorangestelltes
X">" kenntlich gemacht wurden.
X
XZusaetzlich enthalten die verschiedenen Programme jeweils eigene Parameter-
XDefinitionen. Deren Bedeutung wird im Folgenden erklaert.
X
X
X3.2. Anpassungen "mb-daemon.c"
X==============================
XDer MB-Daemon kann u.A. auch als Reflektor fuer eine NewsGroup (NG) fungieren.
XDa er sich nicht an die Konventionen fuer Reflektoren haelt, sollte sein
XEinsatz auf lokal NGs beschraenkt bleiben.
X
XREFLECT_NG        Diese NG wird vom Reflektor untersucht und beantwortet
XREFLECT_LOG       Hier protokolliert der Reflector seine Aktionen
XDIRLIST           Mit dieser Datei wird ein DIRLIST-Request beantwortet
XREFLECTUID        UID des Users "reflector" ... siehe "/etc/passwd"
X
XSoll der Reflektor inaktiv bleiben, genuegt es die REFLECT_NG auf eine NG
Xzu setzen, die nicht existiert (NICHT "", sondern z.B. "dummy.dummy".
X
X
X
X
X3.3. Anpassungen "/usr/lib/crontab"
X===================================
XDie CRONTAB muss um 2 Eintraege erweitert werden. Entscheidend ist dabei
Xdie chronologische Reihenfolge:
X
X  0   4         *   *   *   /usr/lib/news/sendbatch -c NEWSFEED
X 30   5         *   *   *   /usr/lib/uucp/uucico -r1 -x2 -sNEWSFEED
X  0   6         *   *   *   /usr/lib/news/rnews -U
X 20   6         *   *   *   /usr/bin/mb-daemon
X 40   6         *   *   *   /usr/bin/xmd
X
XMB-Daemon und XMD duerfen erst aktiv werden, nachdem die NEWS einsortiert
Xsind. Wird als Mailer SMAIL verwendet, entfaellt der Aufruf des XMD.
X
X
X3.4. Anpassung der "/etc/passwd"
X================================
XDie PASSWD-Datei sollte um den Eintrag "gast" erweitert werden. Meldet
Xsich dieser User an, wird direkt die "ix/MBox" gestartet.
XEin Verlassen den MBox ist damit gleichbedeutend mit einem Verlassen des
XSystems !
X
Xgast::12:1:Mailbox-User:/usr/gast:/usr/bin/mbox
Xvolkers:X:14:3:Volker Schuermann:/usr/volkers/bin/shh
Xreflector:*:22:3:UnNet Reflector::
Xnews:*:30:6:W-NEWS System:/usr/lib/news:
Xusenet:*:31:6:W-NEWS Administrator:/usr/lib/news: 
Xuucp::40:40:UUCP-Account on Un.Net:/usr/spool/uucp:
Xpostmaster:*:41:40:UUCP-Erroruser:/usr/spool/uucp:/bin/sh
Xnuucp::42:40:Anonymous-UUCP:/usr/spool/uucppublic:/usr/lib/uucp/uucico
X
XDie Gruppe des Users "gast" und die Gruppe der uebrigen User (z.B. "volkers")
Xmuss unterschiedlich sein (GID !)
X
X
X
X3.5. Die Verteilung der Rechte
X==============================
XHier nun eine Uebersicht der versch. Pfade und Programme (wobei das HOME-
XVerzeichnis der "ix/MBox" jetzt "/usr/mbox" genannt wird):
X
Xdrwxrwxrwx  root.root /usr/mbox
X-r-xr-xr-x  root.root /usr/mbox/mbrsh
X
Xdrwxrwx---  root.root  /usr/mbox/etc
X-rw-rw----  root.root  /usr/mbox/etc/*
X-rwxrwx---  root.root  /usr/mbox/etc/tset
X
Xdrwxrwx---  root.root  /usr/mbox/lib
X-rw-rw-rw-  root.root  /usr/mbox/lib/*
X
Xdrwx------  root.root  /usr/mbox/src
X-rw-r--r--  root.root  /usr/mbox/src/*
X
Xdrwxrwx---  root.root  /usr/mbox/usr
Xdrwxrwx---  root.root  /usr/mbox/usr/*
X-rw-rw----  root.root  /usr/mbox/usr/*/*
X
X-rwsrwsr-x  root.root  /usr/bin/mbox
X-rwxrwxr-x  bin.sys    /usr/bin/bled
X-rwxrwxr-x  root.root  /usr/bin/xmd
X-rwsrwsr-x  root.root  /usr/bin/mb-daemon
X
X
X3.6. Kommunikation mit RMAIL & INEWS
X====================================
XMit der Version 1.6 PL4 wird eine voellig neue Struktur der Kommunikation
Xzwischen ix/MBox und UNIX/MINIX eingefuehrt. Sowohl Mails als auch Artikel
Xfuer NEWS werden von der MBox mit einem Header ausgestattet und an die
XProgramme RMAIL bzw. INEWS uebergeben, die den Header komplettieren und
Xdie MSG verschicken.
X
XDurchgefuehrt werden diese Aktion mit Hilfe von 2 (3) Shell-Scripts. Sie
Xbefinden sich in "/usr/mbox/etc/rmail.sh", "/usr/mbox/etc/inews.sh" und
X"/usr/mbox/etc/alias.sh". Das letzte Script wird immer dann aufgerufen,
Xwenn ein neues Postfach angelegt wird. Es sollte dann eine Zeile an die Datei
X"/usr/lib/smail/aliases" (Alias-Datei von SMAIL) angehaengt werden, die
XSMAIL anweist den Usernamen "Vorname.Name" als Alias zu verstehen und das
Xentsprechende Kommando ("xmd Vorname.Name") auszufuehren ...
X
X
X
X
X4. VERWALTUNG
X=============================================================================
X
X4.1. Teilnehmer
X===============
XDie "ix/MBox" benutzt den Befehl "admin" zur Pflege der Teilnehmerdaten-
Xbank. Der Sysop/Postmaster/Administrator kann hier auf alle Eintraege
Xzugreifen. 
X
XUm die Sysop-Berechtigung zu bekommen, muss der Postmaster sich als "root"
Xins System einloggen, und dann per "mbox" die MBox aufrufen. Er erhaelt
Xdann Userlevel 10 und ist damit berechtigt, das Kommando "admin" auszu-
Xfuehren. Sollte das mal nicht funktionieren, kann man einfach das Level
Xfuer "admin" in der Datei "/usr/mbox/etc/help.befehle" auf 0 setzen ...
X
XACHTUNG: damit hat JEDER Zugriff auf alle Teilnehmerdaten - also nach
XErhoehung des eigenen Levels (auf 10) unbedingt das "admin"-Level wieder
Xauf 9 zuruecksetzen !!!
X
X
XNochmal ACHTUNG: Zwei User muessen unbedingt ins System eingetragen werden:
X
XUsername:   GAST (identisch mit der GUEST-Definition in "mbox.h")
XSH-Account: gast (siehe "/etc/passwd");
XUser-Level: 0
X
XUsername:   Jacke wie Hose (naja...)
XSH-Account: root (siehe POSTMASTER-Definition in "mbox.h");
XUser-Level: 10
X
XSolange diese beiden User nicht ordnungsgemaess eingetragen sind, laeuft
Xdas System nicht !!!
X
X
XWird die MBox gestartet, und die Datei UDBASE (siehe "mbox.h") existiert
Xnoch nicht, erzeugt die MBox eine Userdatenbank aus den Definitionen in
X"mbox.h" - diese Datenbank kann mit dem Befehl "admin" ueberarbeitet werden.
X
XScheint das zu aufwendig, muessen die Definitionen in "mbox.h" geaendert und
Xdie Datei UDBASE geloescht werden. Beim naechsten Start der MBox wird
Xerneute eine Datenbank angelegt.
X
X
X
XWICHTIG: Fuer Gaeste und User muss es verschiedene GIDs (GroupIDs) auf
XShell-Ebene geben !!! MBox-User OHNE Shell-Account werden daran erkannt,
Xdass ihre GID die der SH-Gaeste (z.b. "other") ist ... MBox-User MIT Shell-
XAccount haben die GID der SH-User (z.B. "sys"). 
X
X
X
X4.2. Dateien
X============
XDa es sich bei allen Protokoll- und Steuerdateien um ASCII-Textfiles handelt,
Xkoennen Aenderungen problemlos mit einem "normalen" Editor vorgenommen werden.
X
XDie einzige Ausnahme bildet die Teilnehmer-Datenbank - also HAENDE WEG !!!
X
XSoll sich die MBox mit einem "LOGO"-Text/Bild melden, muss die Datei 
X"./etc/logo" (s. LOGO-Definition in "mbox.h") exisitieren. Diese Datei 
Xenthaelt einen ASCII-Text. ANSI-Bilder sollten vermieden werden, denn sie
Xumgehen die TERMCAP-Steuerung der MBox.
X
X
X5. WEITERE INFOS
X=============================================================================
X
X5.1. Mail genuegt
X=================
XDiese BETA-Version des TUTORIALS beantwortet natuerlich nicht alle Fragen,
Xdie bei der Installation der "ix/MBox" auftreten werden, aber bei zusaetz-
Xlichem Studium der einzelnen Routinen (siehe auch CROSSREF), sollte sich
Xzu fast jedem Problem auch eine Loesung finden lassen.
X
XWenn alles fehlschlaegt, genuegt eine MAIL an "volkers@unnet.w.open.de",
Xum Infos und evtl. neue Routinen zu bekommen. Ausserdem wird immer dann,
Xwenn's neue Erkenntnisse gibt, ein INFO-Rundschreiben verschickt, um 
Xalle MBox-Betrieber mit dem aktuellen Stand der Entwicklung vertraut
Xzu machen.
X
X
X5.2. Updates
X============
XUpdates werden als CDIFFs fuer die Version 1.6.0 der ix/MBox verschickt,
Xoder auf Wunsch als komplette Source-Files. Ausserdem werden von Zeit zu
XZeit INFO-Runschreiben verschickt, die auf Aenderungen aufmerksam machen.
X
X
XDer Rest ist Glueckssache ... mfG Volker Schuermann
END_OF_FILE
  if test 10956 -ne `wc -c <'TUTORIAL'`; then
    echo shar: \"'TUTORIAL'\" unpacked with wrong size!
  fi
  # end of 'TUTORIAL'
fi
if test -f 'etc/english.hilfe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.hilfe'\"
else
  echo shar: Extracting \"'etc/english.hilfe'\" \(9576 characters\)
  sed "s/^X//" >'etc/english.hilfe' <<'END_OF_FILE'
X#?
XCommand: "?"
X
XYou'll get a list of all commands, which you may use. The contents of this
Xlist depends on your user-level. Type "? *", if you like to see ALL commands
Xof this BBS.
X
X#0
XCommand: "0" ("1-9")
X
XThere is a "dynamic command buffer", who captures every input you type at
Xthe command-prompt. Type "0" to see which commands are in buffer, or any
Xnumber between 1 and 9 to execute one of those commands. Of course, you may
Xuse the cursor-keys to select any command, too.
X
X#+
XCommand: "+"
X
XJump to the next board with new articles.
X
X#-
XCommand: "-"
XJump to the previous board with new articles.
X
X#ACCOUNT
XCommand: "Account"
X
XYou need to registered to send and receive mails to/from all over the
Xworld. The registration makes you a fully accepted user of this BBS.
XYou're now reachable by mail from users on this host or on any host, this
Xhost is connected to.
X
XPLEASE use your full name as username !
X
X#BOARD
XCommand: "Board"
X
XThere is a board for every single subject/theme with it's own index. So you
Xhadn't to search long for special information on any item. To move from one
Xboard to another, you use the command "board" with some options:
X
XBOARD                      list boards with new articles
XBOARD *                    list ALL boards
XBOARD +                    go to the next board
XBOARD -                    go to the previous board
XBOARD !                    display the name of the current board
XBOARD #                    list areas in board
XBOARD ..		   step from one area to the previous one
XBOARD boardname            jump to board "boardname"
X
X#CHAT
XCommand: "Chat"
X
X- systemdepending stuff -
X
X#DATE
XCommand: "Date"
X
XShows the current date. (Not quite right ... it's shows the systems date :-)
X
X#DELETE
XCommand: "Delete"
X
XDelete mails or articles. NOTE: Be careful! If you type "delete" in your
XPM, every (!) mail will be scratched!
X
XDELETE			   delete all your mail
XDELETE article		   delete article no. "article"
XDELETE article-article	   delete from "article" to "article"
X
X#DIR
XCommand: "Dir"
X
XThis will give you a survey of what subjects are collect in the current
Xboard. If you hadn't add a '*', you'll ony see the entries which are
Xnew for you.
X
XDIR                        index new articles
XDIR *                      index ALL articles (of a board)
X
X#DIRECTION
XCommand: "Direction"
X
XIt's sounds pretty funny, but this commands decides whether you see
Xanswers before questions or not :-)
X
X#FORWARD
XCommand: "Forward"
X
XIf you like to send copies of mails/articles to other users, you may use
Xthis command. The variable "user" (see below) stand for every kind of
Xaddress (i.e. "Prename.Name", "host!name", "name@host.domain" etc.). So
Xit is possible to forward articles to your own shell-account on this host,
Xor to your account on any other host ... this may be useful sometimes.
X
XFORWARD                    list stored mails
XFORWARD user               forward a stored mail to "user"
XFORWARD mail user          forward "mail" to "user"
XFORWARD article user       forward "article" to "user"
X
X#GAMES
XCommand: "Games"
X
XThe list, that will be shown if you enter this command, includes some
Xgames you may play. They all have own accounting procedures and different
Xinstruction sets ... so don't blame the sysop for anything that will
Xhappen to you :-)
X
X#GOODBYE
XCommand: "Goodbye"
X
XNEVER use this command! (Exception: If you REALLY want to leave :-)
X
X#HELP
XCommand: "Help"
X
XYou managed to get this information ... so why do you ask ???
X
XHELP                       this shorthelp
XHELP *                     display some pages of helpful descriptions
XHELP command               show information on "command"
X
X#MAIL
XCommand: "Mail"
X
XOne of the most powerful commands on this BBS. If you are fitted out with
Xthe right user-level, you're able to send mails to receivers all over the
Xworld ... or just to another BBS-user.
X
XMAIL Prename.Name          (Prename.Name i.e. "Volker.Schuermann")
XMAIL Alias                 (Alias i.e. "Sysop")
XMAIL Shell-Account         (Shell-Account i.e. "volkers")
X
XThese three commands will deliver a mail to a user on this host. If this user
Xhas his own BBS-account, the mail will be sent to his BBS-maildrop. 
XOtherwise his/her shell-account-maildrop will be filled ... 
X
XMAIL Host!User             (Host!User i.e. "unnet!Volker.Schuermann")
XMAIL User@Host.Domain      (User@Host.Domain i.e. "volker@unnet.w.open.de")
X
XBoth commands will send the mail to a user on another host (if "host" or
X"host@domain" are the address of this host, the mail won't leave this host).
X
X#MACRO
XCommand: "Macro"
X
XFor all lazy/intelligent users, here is a way to simplify work! Just create
Xa new command to collect a group of commands:
X
Xnew = b comp.os.minix, d, key, b sub.os.minix, b
X
XThe new command "new" will jump to board "comp.os.minix" and show the index
Xof new articels. If you hit (the) any key, it moves to "sub.os.minix" and 
Xdoes the same.
X
XMacro = Command Sequence
X===========================================================================
Xandi  = mail andreas@xenox.ruhr.de
Xwalt  = mail Walter, forward weller!walterb
Xgrp   = mail volkers, forw xenox, forw stefans, forw joergg
Xsts   = mail Stefan S, forw stefans@coduck.ruhr.sub.org, forw unnet!stefans
Xin    = +, dir, KEY, in
Xpp    = PORTINFO, SLEEP 5, pp
X
XThe entries "in" and "pp" are demonstrating how to build recursive commands.
XUse CTRL-X to break the run of such a command sequence!
X
X#MESSAGE
XCommand: "Message"
X
XYou may use this text to inform other users that you're offline for a
Xfew days or that you never answers mail or what ever ...
X
XThis text is shown to everybody who wants to send a mail to you on this
Xhost.
X
X#MINIX
XCommand: "Minix"
X
XIf you'd have to leave the BBS everytime you like to do something on
Xshell-level, it would be a nice swapping around on this system. But with
Xthe command "minix", you can do everything (even start the BBS :-) without
Xleaving ... 
X
X#PORTINFO
XCommand: "Portinfo"
X
XHave a look on what the other users are doing. This includes BBS-users
Xas well as shell-only-users (poor guys :-)
X
X#PROTOCOL
XCommand: "Protocol"
X
XSee WHO called in WHEN from WHERE on WHICH line ... puhh, but that's exactly
Xwhat this command is doing.
X
XIf you use the option "#" (means "protocol #"), the informations are shown
Xas a diagram (for statistics purposes). 
X
X#PM
XCommand: "PM"
X
XMove to the board with your BBS-maildrop. There you may check your incomming
Xmails and answer (reply) them.
X
X#READ
XCommand: "Read"
X
XThat's how to get the information hidden behind the subjects ... the options
Xto this command a described in the following:
X
XREAD                       read NEW articles
XREAD *                     real ALL articles (of a board)
XREAD article               show article no. "article"
XREAD article-article       display from "article" to "article"
X
XThe line "READ article" builds an exceptions ... if the listing of the
Xspecified article is complete, the BBS shows a little menu to you. Type
Xa "?" at the prompt to see what actions are available there!
X
XUsing this form of the command "read" is the most convenient way to consume
Xarticles!!! 
X
X#SETUP
XCommand: "Setup"
X
XTo make life easier (especially YOUR life), you may change lot's of the
XBBS depending paramaters. The SETUP is fully controlled by menu, so you
Xonly have to hit keys (more or less astonished because of the features 
Xyou never noticed before) ...
X
X#SIGNATURE
XCommand: "Signature"
X
XUse this command to create a text, that will be sent as a footnote of every
Xmail/article you'll write on this BBS. Have a look on the ".signatures"
Xof other ppl. to see which facts belong to such a text ...  
X
X#STATE
XCommand: "State"
X
XGives a summary of all data, this BBS has stored in it's accouting database.
XOf course,only that part of data is shown, that belongs to you!
X
X#STATISTICS
XCommand: "Statistics"
X
XThe BBS collects some information for statistics purpose. If you are inter-
Xested in those statistics, use one of the following options:
X
XSTATISTICS                 table containing NEWS-statistics
XSTATISTICS *               table containing more NEWS-statistics
XSTATISTICS $               UUCP-rates (only if UUCP supports this)
XSTATISTICS #               download-statistics 
X
XThe option "$" depends on the systems UUCP-Support. Ask your Sysop whether
Xthis system accounts UUCP-Rates or not.
X
X#TIME
XCommand: "Time"
X
XShows the system time and the time you're online in seconds ... my goodness,
Xfive hours, and still online ...
X
X#USERS
XCommand: "Users"
X
XYep, you're not alone on this host. To see who's on too, type one of the
Xfollowing commands:
X
XUSERS                      show users list
XUSERS *                    show users list (more detailed)
XUSERS #                    users up-/download ratio
X
XIf your level is to low, you won't be able to use the "#" option - don't
Xbe angry, it's not as much interesting, as it seems to be (use "stati #"
Xinstead :-)
X
X#VERSION
XCommand: "Version"
X
XThis option was built in for other Sysops only - they may use it to spy out
Xwhich BBS is the older one - nothing else.
X
XVERSION                    print version
XVERSION *                  display compiling definitions
XVERSION #                  the "Hall of Fame"
X
XThe option "#" gives a list of ppl., who were members of the "BBS gold crew"
Xduring it's development :-)
X
X#WRITE
XCommand: "Write"
X
XUse this command to create a new article for any board or newsgroup on this
XBBS. Depending on your user-level this article will be sent with distribution
X"world", "*group*" or "local". 
X
XDon't use this command to send mails to other users ... try it, if you don't
Xtrust in documentations. 
END_OF_FILE
  if test 9576 -ne `wc -c <'etc/english.hilfe'`; then
    echo shar: \"'etc/english.hilfe'\" unpacked with wrong size!
  fi
  # end of 'etc/english.hilfe'
fi
if test -f 'src/bled.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bled.c'\"
else
  echo shar: Extracting \"'src/bled.c'\" \(11258 characters\)
  sed "s/^X//" >'src/bled.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <setjmp.h>
X#include <signal.h>
X
X#define VERSION "LED 3.4 (Unix)"
X#define AUTOR   "Volker.Schuermann@unnet.w.open.de"
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X#include "mbox.msg"
X
X
X#define CR     13
X#define LF     10
X#define BS      8
X#define CTRL_X 24
X#define CTRL_D  4
X
X
X#define TMP "/tmp"
X
X#define APPEND 1
X#define INSERT 2
X#define FINISH 3
X#define QUIT   4
X#define UPLOAD 5
X
X#ifdef _MBOX
X#undef _MBOX
X#endif
X
Xstatic int melted;
X
Xstatic char tmp1[STRING];
Xstatic char tmp2[STRING];
X
Xstatic int von, bis;
Xstatic int max_line;
X
Xstatic char imode;
X
Xstatic char THE_FILE[STRING];
Xstatic int  THE_LINE;
X
X
Xint melt(startlin)
Xint startlin;
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *fg;
X  char s[255];
X  char tmp3[STRING];
X  int i;
X
X
X  if (melted == 0) return 0;
X
X  sprintf(tmp3, "%s/bled3.%d", TMP, getpid());
X
X  fg = fopen(tmp3, "w");
X  if (fg == NULL) {
X	printf("\n%s\n", tmp3);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 0;
X  while ((i < startlin) && (fgets(s, 250, fp) != NULL)) {
X	fputs(s, fg);
X	i++;
X  }
X  ff = fopen(tmp2, "r");
X  if (ff != NULL) {
X	while (fgets(s, 250, ff) != NULL) {
X		fputs(s, fg);
X		i++;
X	}
X	fclose(ff);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, fg);
X  }
X  fclose(fg);
X  fclose(fp);
X
X  unlink(tmp1);
X  rename(tmp3, tmp1);
X  unlink(tmp3);
X
X  return 0;
X}
X
X
X
Xbledmove(from, to)
Xchar from[], to[];
X{
X  FILE *fp;
X  FILE *ff;
X  char s[255];
X
X
X  fp = fopen(from, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  ff = fopen(to, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, ff);
X  }
X  fclose(fp);
X  fclose(ff);
X}
X
X
X
X
X
Xzeigen(mode)
Xchar mode;
X{
X  FILE *fp;
X  char t[STRING];
X  char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != NULL) {
X	if ((i >= von) && (i <= bis)) {
X		if (mode == 'l')
X			printf("L%04.4d %s", i, s);
X		else
X			printf("%s", s);
X	}
X	i++;
X  }
X  fclose(fp);
X}
X
X
X
Xloeschen()
X{
X  FILE *fp;
X  FILE *ff;
X  char t[STRING];
X  char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != 0) {
X	if ((i < von) || (i > bis)) {
X		fputs(s, ff);
X	}
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
Xupload()
X{
X  FILE *fp;
X  char c;
X  char lf;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  /*
X  printf("\n\nLED: Uebertragung beginnt. (Beenden mit CTRL-X !)\n\n");
X  */
X  printf("\n\nLED: %s\n\n", BLD02_MSG);
X
X  c = 0;
X  lf = CR;
X
X
X  while ((c != CTRL_X) && (c != CTRL_D)) {
X
X        c = getint();
X
X	if ((c == CR) && (lf == CR)) fputc(LF, fp);
X	if (c == CR) lf = CR;
X	if (c == LF) lf = LF;
X	if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X		fputc(c, fp);
X	}
X  }
X  fclose(fp);
X}
X
X
X
Xkorrigieren()
X{
X  FILE *fp;
X  FILE *ff;
X  char s[255];
X  char t[255];
X  int i;
X
X  if (von == 0) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  while (fgets(s, 250, fp) != NULL) {
X	if (i == von) {
X		t[0] = '\0';
X		strcat(t, stripped(s));
X		s[0] = '\0';
X		if (length(t) < 74)
X			printf("\n\nK%04.4d ", i);
X		else
X			printf("\n\n");
X		strcat(s, getline(74, 1001, ' ', t));
X		strcat(s, "\n");
X		printf("\n");
X	}
X	fputs(s, ff);
X	i++;
X  }
X  fclose(ff);
X  fclose(fp);
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
X
Xcrunch(s)
Xchar s[];
X{
X  char t[STRING];
X  int i = 0, a = 0;
X
X  von = 0;
X  bis = 0;
X
X  while (s[i] != '\0') {
X	if ((s[i] == ',') || (s[i] == '-')) a = i;
X	i++;
X  }
X  if (a == 0) a = i;
X  t[0] = '\0';
X  strcat(t, strcopy(s, 3, (a - 1)));
X  von = atoi(t);
X  t[0] = '\0';
X  strcat(t, strcopy(s, (a + 1), i));
X  bis = atoi(t);
X  if ((a != i) && (bis == 0)) bis = 32000;
X}
X
X
X
X
X
Xint befehl(s)
Xchar s[];
X{
X  char c = s[1];
X
X  if ((s[2] != ' ') && (s[2] != '\0') && (s[1] != '\0')) {
X	/*
X	printf("\n\nLED: Syntax-Fehler.\n");
X	*/
X	printf("\n\nLED: %s\n", BLD03_MSG);
X	return 0;
X  }
X  crunch(s);
X
X  switch (c) {
X      case '\0':
X			return FINISH;
X			break;
X      case '?':
X			printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Befehlsuebersicht ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD04_MSG);
X			ansi("me");
X			printf("\n\n");
X			/*
X			printf(".l [ZEILE]|[VON,BIS]   lesen\n");
X			printf(".L [ZEILE]|[VON,BIS]   lesen (keine Zeilennummern)\n");
X			printf(".i AB                  einfuegen\n");
X			printf(".a                     anhaengen (beendet einfuegen)\n");
X			printf(".k ZEILE               korrigieren\n");
X			printf(".d [ZEILE]|[VON,BIS]   loeschen\n");
X			printf(".u                     uebertragen (ASCII-Upload)\n");
X			printf(".q                     abbrechen\n");
X			printf(".h                     ausfuehrliche Hilfe\n");
X			printf(".                      sichern & beenden\n\n");
X			printf("ZEILE, VON, BIS, AB sind gueltige Zeilennummern.\n");
X			printf("Angaben in [KLAMMERN] sind optional. Werden\n");
X			printf("keine Angaben gemacht gilt AB=1, VON=1, BIS=32000.\n");
X			*/
X			printf("%s\n", BLD05_MSG);
X			printf("%s\n", BLD06_MSG);
X			printf("%s\n", BLD07_MSG);
X			printf("%s\n", BLD08_MSG);
X			printf("%s\n", BLD09_MSG);
X			printf("%s\n", BLD10_MSG);			
X			printf("%s\n", BLD11_MSG);
X			printf("%s\n", BLD12_MSG);
X			printf("%s\n", BLD13_MSG);
X			printf("%s\n", BLD14_MSG);
X			printf("\n");
X			printf("%s\n", BLD15_MSG);
X			printf("%s\n", BLD16_MSG);
X			printf("%s\n", BLD17_MSG);
X			break;
X      case 'h':	        printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Hilfe ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD18_MSG);
X			ansi("me");
X			printf("\n\n");
X			system( HILFE );
X			break;
X      case 'a':	
X			return APPEND;	
X			break;
X      case 'i':
X			return INSERT;	
X			break;
X      case 'l':
X      case 'L':
X			zeigen(c);
X			return APPEND;
X			break;
X      case 'd':
X			loeschen();
X			return APPEND;
X			break;
X      case 'k':
X      case 'c':
X			korrigieren();
X			return APPEND;
X      case 'u':
X			upload();
X			return UPLOAD;
X      case 'q':
X			unlink(tmp1);
X			unlink(tmp2);
X			/*
X			printf("\n\nLED: Abgebrochen. Datei NICHT gesichert.\n\n");
X			*/
X			printf("\n\nLED: %s\n\n", BLD19_MSG);
X			exit(0);
X			break;
X      default:		/*
X			printf("\n\nLED: Befehl unbekannt.\n");
X			*/
X			printf("\n\nLED: %s\n", BLD20_MSG);
X}
X  return 0;
X}
X
X
X
X
X
Xint erfassen(line, mode)
Xint line, mode;
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  char def[STRING];
X  int ok = 0;
X  int elin = line;
X  int startlin = line - 1;
X  int a, b;
X
X  melted = 1;			/* Sicher ist sicher ... */
X  THE_LINE = startlin;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) return -1;
X
X  def[0] = '\0';
X
X  do {
X	if (elin > max_line) max_line = elin;
X	printf("\n%c%04.4d ", imode, elin);
X	s[0] = '\0';
X	if (def[0] == '\0')
X		strcat(s, getline(73, 1, ' ', " "));
X	else
X		strcat(s, getline(73, 1001, ' ', def));
X
X	if (strcomp("<BREAK>", s) == 0) {
X		sprintf(s, ".?");
X	}
X	if (s[0] == '.') {
X		fclose(fp);
X		melted = melt(startlin);
X
X		ok = befehl(s);
X
X		if (ok == UPLOAD) {
X			melted = 1;
X			melted = melt(startlin);
X			ok = APPEND;
X		}
X		if (ok == INSERT) {
X			imode = 'I';
X			if (von < 1) von = 1;
X			if (von > max_line) {
X				ok = APPEND;
X			}
X			 else {
X				startlin = von - 1;
X				THE_LINE = startlin;
X				elin = von;
X			}
X		}
X		if (ok == APPEND) {
X			imode = 'A';
X			unlink(tmp2);
X			rename(tmp1, tmp2);
X			startlin = getfile(tmp2);
X			if (startlin < 1) startlin = 0;
X			elin = startlin + 1;
X			THE_LINE = startlin;
X		}
X		fp = fopen(tmp2, "w");
X		if (fp == NULL) return -1;
X
X	} else {
X		def[0] = '\0';
X		a = length(s);
X		if (a == 73) {
X			while ((s[a] != ' ') && (a > 40)) a--;
X			if (s[a] == ' ') {
X				strcat(def, strcopy(s, (a + 1), 73));
X				s[a] = '\0';
X				for (b = a; b < 73; b++) printf("%c", BS);
X				for (b = a; b < 73; b++) printf(" ");
X			}
X		}
X		fprintf(fp, "%s\n", s);
X		elin++;
X		melted++;
X	}
X  } while (ok != FINISH);
X  return elin;
X}
X
X
X
Xsigcatch(sig)
Xint sig;
X{
X
X  switch (sig) {
X      case SIGINT:
X      case SIGQUIT:
X      case SIGHUP:
X      case SIGABRT:
X      case SIGTERM:
X	melted++;
X	melt(THE_LINE);
X	bledmove(tmp1, THE_FILE);
X	unlink(tmp1);
X	unlink(tmp2);
X	/*
X	printf("\n\nLED: Prozess terminiert. Datei gesichert.\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD21_MSG);
X	exit(-1);
X	break;
X  }
X}
X
X
X
Xint getfile(path)
Xchar path[];
X{
X  FILE *fp;
X  FILE *ff;
X  int i = 0;
X  char s[STRING];
X
X  ff = fopen(tmp1, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X  }
X  fp = fopen(path, "r");
X  if (fp == NULL) {
X	fclose(ff);
X	return -1;
X  }
X  if (fgets(s, STRING, fp) != 0) i++;
X  if ((s[0] == 1) && (s[1] == 3)) {	/* MAGIC NUMBER */
X	return -2;
X  }
X  fputs(s, ff);
X
X  while (fgets(s, STRING, fp) != NULL) {
X	fputs(s, ff);
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  return i;
X}
X
X
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  char s[STRING];
X
X  int eof = 0;
X
X
X  if (argc < 2) {
X	/*
X	printf("\nLED: Keine Datei angegeben.\n\n");
X	*/
X	printf("\nLED: %s\n\n", BLD22_MSG);
X	return;
X  }
X  /*
X  signal(SIGINT, sigcatch);
X  signal(SIGQUIT, sigcatch);
X  signal(SIGHUP, sigcatch);
X  signal(SIGABRT, sigcatch);
X  signal(SIGTERM, sigcatch);
X  */
X  signal(SIGINT,  SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGHUP,  SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X#ifndef _SYS7
X
X  setbuf(stdout, NULL);
X
X#endif
X
X  ansi( "INIT" );
X
X  sprintf(s, " %s ", VERSION);
X  headline(s);
X 
X  /*
X  printf("\nMomentchen ...");
X  */
X  printf("\n%s", BLD23_MSG);
X
X  sprintf(tmp1, "%s/bled1.%d", TMP, getpid());
X  sprintf(tmp2, "%s/bled2.%d", TMP, getpid());
X
X  sprintf(THE_FILE, "%s", argv[1]);
X  THE_LINE = 0;
X
X  eof = getfile(THE_FILE);
X  printf("%c", CR);
X  if (eof == -2) {
X	/*
X	printf("Datei \"%s\" enthaelt ein ausfuehrbares Programm.\n\n", THE_FILE);
X	*/
X	printf("%s \"%s\" %s\n\n", BLD24_MSG, THE_FILE, BLD25_MSG);
X	return;
X  }
X  if (eof == -1)
X	/*
X	printf("Datei wird angelegt.");
X	*/
X	printf("%s", BLD26_MSG);
X  else
X	/*
X	printf("Datei enthaelt %d Zeilen.", eof);
X	*/
X	printf("%s %d %s", BLD27_MSG, eof, BLD28_MSG);
X  
X  /*
X  printf(" Befehlsuebersicht: \".?\"\n");
X  */
X  printf(" %s: \".?\"\n", BLD04_MSG);
X
X  if (eof < 1) eof = 0;
X  melted = 0;
X  max_line = eof;
X  eof++;
X
X  imode = 'A';
X
X  if (erfassen(eof, APPEND) < 1) {
X	/*
X	printf("\n\nLED: Probleme ...\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD29_MSG);
X  }
X  bledmove(tmp1, THE_FILE);
X  unlink(tmp1);
X  unlink(tmp2);
X
X  /*
X  printf("\n\nUnd 'tschuess ...\n\n");
X  */
X  printf("\n\n%s\n\n", BLD30_MSG);
X}
END_OF_FILE
  if test 11258 -ne `wc -c <'src/bled.c'`; then
    echo shar: \"'src/bled.c'\" unpacked with wrong size!
  fi
  # end of 'src/bled.c'
fi
if test -f 'src/lesen2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lesen2.c'\"
else
  echo shar: Extracting \"'src/lesen2.c'\" \(10222 characters\)
  sed "s/^X//" >'src/lesen2.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  lesen2.c						   */
X/*        FUNKTIONEN  anzeigen(), lesen2(), inhalt2(), loeschen2()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  20.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
Xextern char headinfo[STRING];
X
X/***************************************************************************/
X/*      FUNKTION  anzeigen()						   */
X/*  BESCHREIBUNG  Artikel selektieren und anzeigen.			   */
X/*     PARAMETER  art  =  Artikel(-Nummer)                                 */
X/*		  von  =  Artikel-Nummer (Minimum)                         */
X/*		  bis  =  Artikel-Nummer (Maximum)                         */
X/*     RUECKGABE  siehe "show()"					   */
X/***************************************************************************/
X
Xint anzeigen(art, von, bis)
Xint art, von, bis;
X{
X  char entry[STRING];
X  char s[STRING];
X  int mr;
X  int ok;
X
X  if (strcomp(BRETT, "PM") != 0) {
X	sprintf(entry, "%s/%d", BRETT, art);
X  }
X  else {
X	sprintf(entry, "%s/usr/%d/%d", HOME, USER.id, art);
X  }
X
X  mr = 0;
X  if ((USER.more == 1) || (USER.more == 3)) mr = 2;
X
X  sprintf(s, "%d", art);
X
X  if (((art >= von) && (art <= bis)) ||
X      ((art >= bis) && (art <= von))) {
X
X	ok = pruefe(s);	
X
X	if(ok == 0){
X		if(USER.more != 0){
X			sprintf(headinfo, " %s %d (%s) ", LE201_MSG, art, NG);
X			headline( headinfo );
X		}
X		else{
X			ansi("md");
X			printf("%s %d\n", LE202_MSG, art);
X			ansi("me");
X		}
X		show( "?", 99, 99 );
X		ok = show(entry, 9999, mr);
X		if(ok != -1){
X			if(USER.more != 0) more();
X		}
X		else return ok;
X	}
X  }
X  return ok;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  lesen2() 						   */
X/*  BESCHREIBUNG  Artikel selektieren (je nach Parameter) und anzeigen.    */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid lesen2(arg, mode)
Xchar arg[];
Xchar mode;
X{
X  FILE *fp;
X  char ex[255];
X  char s[STRING];
X  char entry[STRING];
X  int a = 56, b = 63;
X  int i, d, e;
X  int von, bis;
X  int ALLE;
X  int PM = 0;
X  int art[MAX_PER_NG];
X  int artp;
X  int k, l;
X  int LR = 0;
X
X
X  i = 0;
X  k = -1;
X  l = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	if (arg[i] == '*') l = i;
X	i++;
X  }
X
X  if ((arg[0] != '\0') && (k == -1) && (l == -1)) {
X	ansi("md");
X	printf(" %s\n", LE203_MSG);
X	ansi("me");
X	return;
X  }
X
X  von = 1;
X  bis = 32000;
X
X  if (l != -1) {
X	ALLE = 1;
X  }
X  if (k != -1) {
X	strcpy(s, (char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X	ALLE = 1;
X  }
X  if ((k == -1) && (l == -1)) {
X	ALLE = 0;
X  }
X  if ((von == 1) && (bis == 32000)) LR++;
X
X  if ((USER.leserichtung != 1) && (LR != 0)) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X  if (strcomp(BRETT, "PM") != 0) {
X	PM = 0;
X  }
X  else {
X	PM = 1;
X  }
X
X  d = a + 10;
X  e = a + 14;
X
X  maybe_locked(INHALT, "r");
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	nerror("lesen2.c", 104, "lesen2", "Datei-Lesefehler", INHALT);
X  }
X  artp = -1;
X  while (fgets(ex, 250, fp) != NULL) {
X	if (ALLE == 1) {
X		artp++;
X		art[artp] = atoi(ex);
X	}
X	else {
X		strcpy(s, (char *) strcopy(ex, a, b));
X		if (LASTLOG < dateconv(s)) {
X			artp++;
X			art[artp] = atoi(ex);
X		}
X		if (LASTLOG == dateconv(s)) {
X			strcpy(s, (char *) strcopy(ex, d, e));
X			if (LASTTIME <= timeconv(s)) {
X				artp++;
X				art[artp] = atoi(ex);
X			}
X		}
X	}
X	if(artp >= MAX_PER_NG){
X		nerror("lesen2.c", 188, "lesen2", "Zuviele", "Artikel");
X	}
X  }
X  fclose(fp);
X
X
X
X  if (artp == -1) {
X	ansi("md");
X	printf(" %s", LE204_MSG);
X	ansi("me");
X	printf("\n");
X	return;
X  }
X  ansi("cl");
X
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X
X  show("?", 0, 99);
X
X  if (von > bis) {
X	for (i = artp; i >= 0; i--) {
X		if (anzeigen(art[i], von, bis) == -1) return;
X	}
X  }
X  else {
X	for (i = 0; i <= artp; i++) {
X		if (anzeigen(art[i], von, bis) == -1) return;
X	}
X  }
X
X  return;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  inhalt2() 						   */
X/*  BESCHREIBUNG  Inhalt selektieren (je nach Parameter) und anzeigen. 	   */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid inhalt2(arg, mode)
Xchar arg[];
Xchar mode;
X{
X  FILE *fp;
X  FILE *ff;
X  char ex[255];
X  char s[STRING];
X  char tmp[STRING];
X  int a = 56, b = 63;
X  int e, d, i;
X  int von, bis;
X  int k, l;
X  int plus, minus;
X  int PM;
X  int ALLE;
X  int LR = 0;
X
X
X  i = 0;
X  k = -1;
X  l = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	if (arg[i] == '*') l = i;
X	i++;
X  }
X
X  von = 1;
X  bis = 32000;
X
X  if ((arg[0] != '\0') && (k == -1) && (l == -1)) {
X	strcpy(s, (char *) strcopy(arg, 0, length(arg)));
X	von = atoi(s);	
X	bis = von;
X	ALLE = 1;
X  }
X
X  if (l != -1) {
X	ALLE = 1;
X  }
X  if (k != -1) {
X	strcpy(s, (char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X	ALLE = 1;
X  }
X
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	brett( "~" );
X	return;
X  }
X  sprintf(tmp, "%s/I.%d", TMP, getpid());
X  ff = fopen(tmp, "w");
X
X  sprintf(ex, " %s (%s) ", LE205_MSG, NG);
X  ex[80] = '\0';
X  headline(ex);
X
X  fgets(ex, 250, fp);	/* alte Ueberschrift ausblenden */
X  fgets(ex, 250, fp);   /* dito */
X
X  if(strcomp(PDNG, NG) == 0){
X	printf("%s\n", GBL08_MSG); 
X  }
X  else{
X	printf("%s\n", GBL05_MSG);
X  }
X  printf("===============================================================================\n", ff);
X  
X
X  PM = 1;
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X	PM = 0;
X  }
X  plus = 0;
X  minus = 0;
X
X  d = a + 10;
X  e = a + 14;
X
X  if (((von == 1) && (bis == 32000)) || ((von == 32000) && (bis == 1))) LR++;
X
X  if ((USER.leserichtung != 1) && (LR != 0)) {
X	i = von;
X	von = bis;
X	bis = i;
X  }
X  if (von > bis) {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if(i != 0) minus++;
X		if (ALLE == 1) {
X			if ((i >= bis) && (i <= von)) {
X				fputs(ex, ff);
X				plus++;
X			}
X	} else {
X			strcpy(s, (char *) strcopy(ex, a, b));
X			if (LASTLOG < dateconv(s)) {
X				fputs(ex, ff);
X				plus++;
X			}
X			if (LASTLOG == dateconv(s)) {
X				strcpy(s, (char *) strcopy(ex, d, e));
X				if (LASTTIME <= timeconv(s)) {
X					fputs(ex, ff);
X					plus++;
X				}
X			}
X		}
X	}
X	fclose(ff);
X
X	if (PM == 1)
X		sprintf(s, "sort -nr -o %s %s", tmp, tmp);
X	else
X		sprintf(s, "sort -n -o %s %s", tmp, tmp);
X	system(s);
X  }
X  else {
X	while (fgets(ex, 250, fp) != 0) {
X		i = atoi(ex);
X		if(i != 0) minus++;
X		if (ALLE == 1) {
X			if ((i >= von) && (i <= bis)) {
X				fputs(ex, ff);
X				plus++;
X			}
X		} 
X		else {
X			strcpy(s, (char *) strcopy(ex, a, b));
X			if (LASTLOG < dateconv(s)) {
X				fputs(ex, ff);
X				plus++;
X			}
X			if (LASTLOG == dateconv(s)) {
X				strcpy(s, (char *) strcopy(ex, d, e));
X				if (LASTTIME <= timeconv(s)) {
X					fputs(ex, ff);
X					plus++;
X				}
X			}
X		}
X	}
X	fclose(ff);
X  }
X  fclose(fp);
X
X  if (plus != 0) show(tmp, 9999, USER.more + 100);
X
X  unlink(tmp);
X
X  if (plus == 0) {
X	ansi("md");
X	printf("%s", LE206_MSG);
X	ansi("me");
X	if ((minus - plus) > 0)
X		printf("\n%s %d %s", LE207_MSG, minus, LE208_MSG);
X	else
X		printf("\n%s", LE209_MSG);
X  }
X  else if ((plus < 19) || (plus > 21)) {
X	if ((minus - plus) > 0)
X		printf("\n%s %d %s", LE210_MSG, (minus - plus), LE211_MSG);
X	else
X		printf("\n%s", LE212_MSG);
X  }
X  printf("\n");
X
X  return;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  loeschen2() 						   */
X/*  BESCHREIBUNG  Persoenliche Post selektieren (je nach Parameter) und    */
X/*                loeschen.						   */
X/*     PARAMETER  arg  =  Selektions-Schluessel                            */
X/*		  mode =  DUMMY (!)                                        */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid loeschen2(arg, mode)
Xchar arg[];
Xchar mode;
X{
X  FILE *fp;
X  FILE *ff;
X  char ex[255];
X  char s[STRING];
X  char tmp[STRING];
X  int a, b, i;
X  int von, bis;
X  int k;
X  int plus;
X  int PM;
X
X
X  if(USER.level == GUEST_LEV){
X	return;
X  }
X
X  i = 0;
X  k = -1;
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	i++;
X  }
X
X  if ((arg[0] != '\0') && (k == -1)) {
X	ansi("md");
X	printf(" %s\n", LE213_MSG);
X	ansi("me");
X	return;
X  }
X  von = 1;
X  bis = 32000;
X
X  if (k != -1) {
X	strcpy(s, (char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X  }
X  if (strcomp(BRETT, "PM") != 0) {
X	a = 60;
X	b = 69;
X  } else {
X	a = 58;
X	b = 65;
X  }
X
X  maybe_locked(INHALT, "r");
X
X  sprintf(tmp, "%s/%d.l2", TMP, getpid());
X  sprintf(s, "cp %s %s > /dev/null", INHALT, tmp);
X  system(s);
X
X  fp = fopen(tmp, "r");
X  if (fp == NULL) {
X	nerror("lesen2.c", 217, "loeschen2", "Datei-Lesefehler", tmp);
X  }
X  fgets(ex, 250, fp);
X  fgets(ex, 250, fp);
X
X  PM = 1;
X  if (strcomp(BRETT, "PM") != 0) {
X	i = von;
X	von = bis;
X	bis = i;
X	PM = 0;
X  }
X  plus = 0;
X
X  if (von > bis) {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if ((i >= bis) && (i <= von)) {
X			sprintf(s, "%d", i);
X			loeschen(s);
X			plus++;
X		}
X	}
X  }
X  else {
X	while (fgets(ex, 250, fp) != NULL) {
X		i = atoi(ex);
X		if ((i >= von) && (i <= bis)) {
X			sprintf(s, "%d", i);
X			loeschen(s);
X			plus++;
X		}
X	}
X  }
X  fclose(fp);
X
X  if (plus == 0) {
X	ansi("md");
X	printf("%s\n", LE214_MSG);
X	ansi("me");
X	return;
X  }
X 
X  unlink(tmp);
X
X  return;
X}
END_OF_FILE
  if test 10222 -ne `wc -c <'src/lesen2.c'`; then
    echo shar: \"'src/lesen2.c'\" unpacked with wrong size!
  fi
  # end of 'src/lesen2.c'
fi
echo shar: End of archive 7 \(of 10\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
