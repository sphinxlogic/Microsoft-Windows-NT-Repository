Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i067:  mbox - A Bulletin Board System for UNIX and MINIX, Part05/10
Message-ID: <1992Apr5.183510.29739@sparky.imd.sterling.com>
X-Md4-Signature: a03efcf75524fc438a4c31a62cd716ea
Date: Sun, 5 Apr 1992 18:35:10 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 67
Archive-name: mbox/part05
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  etc/help.hilfe etc/logo~ src/intro.c src/loop.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:42 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 10)."'
if test -f 'etc/help.hilfe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.hilfe'\"
else
  echo shar: Extracting \"'etc/help.hilfe'\" \(17291 characters\)
  sed "s/^X//" >'etc/help.hilfe' <<'END_OF_FILE'
X#?
XBefehl "?"
X
XDie beim aktuellen Level verfuegbaren Befehle werden angezeigt. Um auch die
Xuebrigen Befehle anzeigen zu lassen, muss als Argument ein "*" angegeben
Xwerden.
X
X#0
XBefehl "0" ("1 - 9")
X
XUeber die Ziffern 0-9 wird der dynamische Befehlspuffer aufgerufen. Die Ziffer
X0 zeigt die aktuelle Belegung dieser "Hot-Keys" an, 1-9 rufen denn gespreicherten
XBefehl ab. Ausserdem kann man diese Befehle auch mit Hilfe der Cursortasten
XUP und DOWN durchblaettern.
X
X#+
XBefehl "+"
X
XDas naechste Brett mit neuen Nachrichten wird aufgerufen. Innerhalb des Brettes
Xkann mit den ueblichen Befehlen (Inhalt, Lesen) gearbeitet werden.
X
X#-
XBefehl "-"
X
XDas vorherige Brett mit neuen Nachrichten wird aufgerufen. Innerhalb des
XBrettes kann mit den ueblichen Befehlen (Inhalt, Lesen) gearbeitet werden.
X
X#ANRUFER
XBefehl "Anrufer" ("Protokoll")
X
XEine Liste der Anrufer wird angezeigt. Wird "*" als Parameter angegeben,
Xzeigt das System ALLE Eintaege des Protokolls an, sonst nur die letzten 21.
X
XDie Option "#" (also "Anrufer #") erstellt eine Statistik aus den Daten
Xder Anrufer-Liste.
X
X#ANSAGE
XBefehl "Ansage"
X
XWenn ein anderer Teilnehmer Ihnen eine persoenliche Nachricht senden will,
Xwird ihm der "Ansage"-Text angezeigt. Sollten sie z.B. fuer laenger Zeit
Xverreisen und desshalb nicht sofort antworten koennen, teilen sie das im
X"Ansage"-Text mit.
X
X#BRETT
XBefehl "Brett" ("cd")
X
XDie Nachrichten dieser MBox sind nach Themen geordnet in verschiedenen
XBrettern zusammengefasst. Der Ausdruck "Brett" ist in diesem Zusammenhang
Xgleichbedeutend mit dem Begriff "Newsgroup" der UUCP-Terminologie.
X
X
XDie verschiedenen Einsatzmoeglichkeiten des Befehls:
X
X"Brett"             Alle Bretter mit neuen Artikeln werden angezeigt.
X 
X"Brett *"           Alle Bretter des Systems werden angezeigt.
X
X"Brett +"           Es wird in's naechst hoehere Brett gewechselt.
X
X"Brett -"           Es wird in's naechst niedrigere Brett gewechselt. 
X
X"Brett !"           Der Name des aktuellen Brettes wird ausgegeben.
X
X"Brett BRETT"       Es wird in Brett "BRETT" gewechselt. Alle INHALT- und LESE-
X                    Befehle beziehen sich jetzt auf "BRETT". 
X
X
XDa verschienden Bretter allerdings nach dem Schema "Oberbrett.Unterbrett" auf-
Xgebaut sind, gibt es noch einige spezielle Parameter:
X
X"Brett #"           Die sogenannten Oberbretter werden angezeigt. 
X
X"Brett OBERBRETT"   Wechselt ins Oberbrett OBERBRETT. Der Befehl INHALT
X                    zeigt nun die Unterbretter dieses Oberbrettes an !!!
X
X"Brett UNTERBRETT"  Es wird ins Brett OBERBRETT.UNTERBRETT gewechselt.
X
X"Brett .."          Von OBERBRETT.UNTERBRETT gelangt man so wieder auf die
X                    Ebene OBERBRETT.
X
X#BRIEF
XBefehl "Brief" ("Mail");
X
XPersoenliche Post wird an Teilnehmer dieser MBox oder aber auch an User auf
Xeinem fremden Rechner verschickt. 
X
XUm einen "internen" Teilnehmer anzuschreiben wird Folgendes eingegeben:
X
X"Brief USERNAME", "Brief ALIAS" oder "Brief SH-ACCOUNT"
X
XZ.B.: "Brief Volker Schuermann", "Brief volkers"
X
XDie MBox erkennt anhand dieser Angaben den Empfaenger und ruft zur Eingabe
Xden Editor auf. Nun kann eine Nachricht geschrieben werden. Die persoenliche
XUNTERSCHRIFT (siehe dort) wird der Nachricht angehaengt und mit verschickt.
X
X
XBei einem Brief an "externe" Teilnehmer sieht die Anschrift etwas anderes
Xaus:
X
X"Brief HOST!USER", "Brief USER@HOST.DOMAIN"
X
XZ.B.: "Brief unnet!volkers", "brief volkers@unnet.ruhr.sub.org"
X
XAnsonsten verhaelt sich der Vorgang genauso wie bei einer "internen" Nachricht.
X
XACHTUNG: Als eingetragener Teilnehmer duerfen Sie auch Post von "externen"
XUsern empfangen. Folgende Adressierungs-Methode ist dabei verbindlich:
X
X"mail unnet!VORNAME.NAME"
X
XDie Adresse "unnet!VORNAME.NAME" entspricht "VORNAME.NAME@unnet.ruhr.sub.org"
Xoder auch "..!unido!uka!smurf!horga!xenox!unnet!VORNAME.NAME" ... je nach 
XDomain des Brief-Autoren.
X
X"VORNAME.NAME" steht in diesem Fall fuer Ihren (User-) Namen, kann aber auch
Xkomplett durch Ihr Alias ersetzt werden (AUSNAHME !) ...
X
XZ.B.: "mail Volker.Schuermann@unnet.ruhr.sub.org"
X
X
X#CHAT
XBefehl "Chat" ("Dialog")
X
XSie betreten den Konferenzbereich. Dort koennen Sie sich mit anderen Teil-
Xnehmern unterhalten. Dabei spielt es keine Rolle, ob Ihre Gespraechspartner
Xebenfalls die MBox benutzen, oder auf Betriebssystem-Ebene arbeiten.
X
X#DOWNLOAD
XBefehl "Download"
X
XDieser Befehl uebertraegt Artikel mit Hilfe eines Protokolls. Angeboten
Xwerden ASCII (einfaches Auflisten der Textdatei) und SX/SZ/SB. Moegliche
XParameter sind:
X
X"Download NUMMER"       Uebertraegt den Artikel No. "NUMMER".
X
X"Download NUM1-NUM2"    Uebertraegt die Artikel von No. "NUM1" bis "NUM2".
X
X"Download NUM-"         Alle Artikel von "NUM" bis 32000 werden uebertragen.
X
X"Download -NUM"         Alle Artikel von 1 bis "NUM" werden uebertragen.
X
XACHTUNG: "Download ??-??" uebertraegt alle angeforderten Artikel OHNE
XUnterbrechung. Die UNIX-Befehle "RX/RZ/RB" unterstuetzen diesen Modus.
X
X#ENDE
XBefehl "Ende" ("Quit")
X
XDas Programm wird beendet. Teilnehmer ohne SH-Account loesen mit diesem
XBefehl auch die Verbindung ... also VORSICHT !
X
XNormalerweise wird nach der Eingabe des Befehls "Ende" das Scanner-Datum und
Xdie Scanner-Zeit aktualisiert. Gibt man als Parameter ein "*" an, wird
Xdiese Aktion unterbunden.
X
X#HILFE
XBefehl "Hilfe"
X
XZu allen Befehlen dieses Systems gibt es mit "HILFE" eine kurze Information.
X
X"Hilfe"           eine Zusammenfassung der Befehle wird angezeigt.
X"Hilfe *"         die gesamte Hilfsdatei wird ausgegeben.
X"Hilfe BEFEHL"    zeigt nur den Eintrag zum Befehl "BEFEHL".
X
X#INHALT
XBefehl "Inhalt" ("dir")
X
XWird als Parameter ein "*" angegeben, zeigt die MBox ein Inhaltsverzeichnis
Xmit allen Eintraegen im aktuellen Brett an, sonst nur Neuzugaenge.
X
XIst das aktuelle Brett ein OBERBRETT, wird statt des Inhaltsverzeichnisses
Xdie Liste der UNTERBRETTER ausgegeben.
X
X#LESEN
XBefehl "Lesen" 
X
XDie per Parameter angeforderten Nachrichten werden angezeigt. Die Reihenfolge
Xinnerhalb der einzelnen Artikel haengt von der Positionierung der Artikel-
XNummern ab.
X
X"Lesen NUMMER"       Zeigt den Artikel No. "NUMMER" an.
X
X"Lesen NUM1-NUM2"    Zeigt die Artikel von No. "NUM1" bis "NUM2" an
X                     Ist "NUM2" groesser als "NUM1" wird die Reihenfolge
X                     bei der Ausgabe umgekehrt.
X
X"Lesen NUM-"         Alle Artikel von "NUM" bis 32000 werden angezeigt
X
X"Lesen -NUM"         Alle Artikel von 1 bis "NUM" werden angezeigt
X
X"Lesen"              Es werden alle neuen Artikel gezeigt (siehe INHALT)
X
X"Lesen *"            Saemtliche Eintraege eines Brettes werden ausgegeben
X
X
XBei seitenweiser Ausgabe (siehe SETUP) kann mit der LEERTASTE weiterge-
Xblaettert werden. Die Tasten "q" o. "Q" beenden die Anzeige.
X
XDie Ausgabe laesst sich mit "x", "X", "DEL", "CTRL-X" und "CTRL-D" komplett
Xabbrechen (z.B. bei "Lesen *").
X
XIst der Artikel beendet, erscheint eine Eingabeaufforderung. Dort kann man
Xentscheiden zwischen ABBRECHEN, BEANTWORTEN, NAECHSTE, VORHERIGE und
XWIEDERHOLEN ... mit Hilfe dieser Auswahl kann man durch die einzelnen
XNachrichten eines Brettes blaettern.
X
X#LOESCHEN
XBefehl "Loeschen"
X
XDie per Parameter benannten Nachrichten werden geloescht. Wird keinerlei
XAngabe gemacht, loescht das System ALLE Eintraege !
X
X"Loeschen NUMMER"     Loescht den Artikel No. "NUMMER"
X
X"Loeschen NUM1-NUM2"  Loescht die Artikel von No. "NUM1" bis "NUM2"
X
X"Loeschen NUM-"       Alle Artikel von "NUM" bis 32000 werden geloescht
X
X"Loeschen -NUM"       Alle Artikel von 1 bis "NUM" werden entfernt
X
X"Loeschen"            Es werden alle (!) persoenlichen Mails geloescht
X
XACHTUNG: Der Befehl ist NICHT rueckgaengig zu machen ! Da wir hier unter
X         UNIX arbeiten, halten wird uns an die Devise: "Der User weiss was
X         er tut, also KEINE Rueckfragen - wenn er loeschen will, will er
X         loeschen ..."	 
X
X#MAKRO
XBefehl "Makro"
X
XUm haeufig wiederkehrende Befehlsfolgen nicht jedesmal komplett eingeben
Xzu muessen, kann man Makros mit diesen Kommandos vereinbaren. Nach der
XVereinbarung genuegt die Angabe des Makro-Names, um die Befehle aufzurufen.
X
XMakro = Befehlsfolge
X===========================================================================
Xandi  = BRIEF andreas@xenox.ruhr.de
Xwalt  = BRIEF Walter, WEITERLEITEN weller!walterb
Xgrp   = BRIEF volkers, WEITER xenox, WEITER stefans, WEITER joergg
Xsts   = BRI Stefan S, WEI stefans@coduck.ruhr.sub.org, WEI unnet!stefans
Xin    = +, INHALT, KEY, in
Xpp    = PORTINFO, SLEEP 5, pp
X
XDie letzen beiden Beispiele demonstrieren "rekursive" Makros. Dabei werden
Xdie Befehle "KEYPRESSED" (wartet auf einen Tastendruck - "CTRL-X", "x" und
X"q" beenden den Vorgang) und "SLEEP nnn" (wartet "nnn" Sekunden) verwendet.
X
XMakros lassen sich auch in der Kommandozeile definieren. Es genuegt eine
Xgueltige Vereinbarung inzugeben (siehe oben) - sie wird automagisch in
Xdie Makro-Sammlung aufgenommen.
X
X#MINIX
XBefehl "Minix" ("execute")
X
XMit entsprechendem LEVEL kann man mit dem Befehl "Minix OS-BEFEHL" ein
XKommando auf Betriebssystem-Ebene ausfuehren.
X
XZ.B. "Minix date", "Minix whodo", "Minix ps -lax"
X
X#PM
XBefehl "PM"
X
XDie oeffentlichen Bretter werden verlassen und das persoenliche Postfach
Xgeoeffnet. Die Befehle INHALT, LESEN, LOESCHEN beziehen sich nun auf das
XPostfach.
X
X#PORTINFO
XBefehl "Portinfo" ("Wer")
X
XDas System holt sich Informationen ueber die Taetigkeit aller Teilnehmer und
Xzeigt sie zusammen mit Name, Terminal-Port und Login-Zeit an. Ist der 
XTeilnehmer in der MBox aktiv, wird ausserdem sein letzter Befehl angezeigt,
Xbei SH-Usern wird der aktuellste Prozess angezeigt.
X
X#POSTFACH
XBefehl "Postfach"
X
XUm persoenliche Post erhalten zu koennen, und um an die externen Bretter
Xsenden zu duerfen, muss das System einen "Account" einrichten. Sie werden
Xgebeten Ihren Namen und einige pers. Daten anzugeben. Wenn Sie nur inner-
Xhalb der Box Post u. Nachrichten versenden wollen, genuegt der Name. Falls
XSie aber auch an die extrenen Bretter senden wollen, und PMs an User auf
Xanderen Rechnern verschicken wollen, MUSS auch die Anschrift stimmig ange-
Xgeben werden ...
X
X#RICHTUNG
XBefehl "Richtung"
X
XMit diesem Befehl kann die Leserichtung beeinflusst werden. D.h. ob zuerst
Xdie aeltern, oder die neuer Artikel angezeigt werden sollen. Diese Einstellung
Xgilt sowohl fuer den Befehl "Lesen" als auch fuer den Befehl "Inhalt".
XMit dem Befehl "Setup" kann (im Untermenue "Textausgabe") die Leserichtung
Xgespeichert werden. 
X
XACHTUNG: der Befehl "Richtung" setzt die im SETUP gespeicherte Vorgabe zwar
X         fuer die Dauer der Session ausser Kraft, beim naechsten Login aber,
X         wird der Vorgabewerte wieder aktiviert.
X
X#SCHREIBEN
XBefehl "Schreiben"
X
XEin neuer Artikel kann mit diesem Befehl an eines der Bretter gesendet werden.
XVor der eigentlichen Eingabe werden noch "Subject" (das Thema des Artikels)
Xund "Keywords" (falls mal nach bestimmten Schluesselworten gesucht werden
Xsollte) abgefragt. Anschliessend wird der Editor zur Erfassung gestartet.
X
XJe nach Brett und Userlevel wird der Artikel nach Beendigung der Eingabe
Xentweder nur lokal verbreitet, oder aber an eines der UUCP-Netze verschickt.
X
X#SETUP
XBefehl "Setup" ("Anschrift", "Ansi", "Bell", "More", "Terminal", "Passwort")
X
XIhre persoenlichen Daten und System-Parameter koennen mit diesem Befehl
Xbearbeitet werden. 
X
XTerminal:  Sie haben die Wahl zwischen drei Terminal-Emulation und einer
X           reinen Dump-Ausgabe. Vorzuziehen ist die "ANSI"-Einstellung, weil
X           sie von allen gaengigen Terminal-Programmen unterstuetzt wird.
X
XEditor:    Es werden einige Editoren angeboten, deren Einsatz vom gewaehlten
X           Terminaltyp abhaengig ist. GAESTE und User ohne SH-Account arbeiten
X           generell mit einen zeilenorientierten Editor (LED).
X
XPrompt:    Der Prompt (die Eingabeaufforderung) kann verschiedene Informationen		
X           ausgeben. Entweder das aktuelle Brett, die Uhrzeit oder die ver-
X           brauchten Telefongebuehren (ACHTUNG: Feiertage werden NICHT berueck-
X           sichtigt, Wechseln zwischen Norm- und Billigtarif waehrend der
X           Verbindung wird NICHT registriert ... es gilt immer der Tarif zur
X           Anzeigezeit).
X
XAusgabe:   Texte koennen entweder bildschirmweise, oder kontinuierlich ausge-
X           geben werden. Bei der ersten Methode wird mit der LEERTASTE weiter-
X           geblaettert, die Tasten "q" o. "Q"  beenden die Ausgabe. Die konti-
X           nuierliche Ausgabe wird mit CTRL-S gestoppt und mit CTRL-Q  
X           wieder aufgenommen. Mit CTRL-X (oder DEL) kann die Ausgabe abge-
X           brochen werden.
X	
X           Ausserdem kann an dieser Stelle die Leserichtung vorgegegben werden.	   
X	   D.h. es wird entschieden, ob zuerst die aelteren, oder zuerst die
X           neueren Artikel angezeigt werden sollen.
X
XAnschrift: Persoenliche Daten wie (User-)Name, Anschrift etc. koennen mit
X           dieser Option geandert werden. Je detailierter die Angaben, desto
X           ehr wird eine Schreibberechtigung fuer extrene Bretter vergeben.
X
XPasswort:  Das Passwort sollte regelmaessig geandert werden, um die persoenl.
X           Daten und die Post zu schuetzten.
X
XIntro:     Nach dem Anmelden im System kann man sich eine Statusmeldung und
X           eine aktuelle Information anzeigen lassen. Beide Anzeigen koennen
X           getrennt unterbunden werden.
X
XScanner:   Hier kann das Datum geaendert werden, das bei der Bestimmung
X           aktueller Eintraege zugrunde gelegt wird. Je weiter zurueckdatiert
X           wird, desto mehr Eintraege werden angezeigt. Ausserdem kann man
X           zusaetzlich die Uhrzeit als Vergleichswert einsetzen.
X
X#SPIELE
XBefehl "Spiele"
X
XEine Liste der ONLINE-Spiele wird angezeigt. Die Spiele verwenden z.T. 
XTerminal-Emulationen - also ACHTUNG! Fast alle Spiele lassen sich mit
X"Q" oder "q" beenden.
X
X#STATUS
XBefehl "Status"
X
XIhre persoenlichen Daten und Einstellungen werden angezeigt. Dazu zaehlen
Xauch Angaben ueber Up- und Downloads, Onlinezeit und die UUCP-Adressen.
X
X#STATISTIK
XBefehl "Statistik"
X
XEin Statistik der versch. Bretter (NGs) und deren aktueller Inhalt wird
Xangezeigt. Mit der Option "*" wird die komplette Ausgabe der Statistik
Xbefohlen, und mit "$" kann eine Uebersicht der (Transfer-)Telefongebuehren
Xabgefragt werden. Ausserdem laesst sich mit "#" ein Protokoll der Down-
Xloads aus den versch. PD-Brettern abrufen. Wird stattdessen ein "%" angegeben,
Xerfolgt eine Auswertung der Downloads. Das Ergebnis wird als "Hitliste"
Xausgegeben.
X
X#SUCHEN
XBefehl "Suchen"
X
XAlle (!) Artikel eine Brettes werden nach dem optional anzugebenden Such-
Xmuster durchsucht. Die Artikel, die das Suchmuster enthalten, werden 
Xangezeigt.
X
X#UPLOAD
XBefehl "Upload"
XDiesen Befehl gibt es NICHT. Der Befehl "Schreiben" bietet als Option
Xden Upload an. Programm-Daten werden automatisch erkannt und entsprechend
Xverarbeitet.
X
X#UNTERSCHRIFT
XBefehl "Unterschrift"
X
XAlle Texte, die sie in dieser MBox schreiben, werden mit der "Unterschrift"
Xbeendet. Sie koennen hier z.B. Ihre Anschrift, Ihre E-Mail Adresse oder
Xeinen Spruch (Disclaimer) eingeben. Fuer UNIX-Kenner: der Befehl entspricht
Xder ".signature". Ein Beispiel:
X
X-----------------------------------------------------------------------------
XDAS MENSCHLICHE AN COMPUTERN   Volker Schuermann,D-5600 Wpt.21,Monhofsfeld 70
XIST IHRE GEWISSENLOSIGKEIT !   DATA   +49 202 4660234    DATA  +49 202 462114
X-----------------------------------------------------------------------------
X
X#USER
XBefehl: "User" ("Teilnehmer")
X
XSie erhalten eine Liste der Teilnehmer in diesem MBox-System. Der Wert, der
Xdem Namen folgt (z.B. "J. Random Looser (24)"), zeigt die UserID. Je niedriger
Xdie Nummer, desto laenger ist der User eingtragen - jede Nummer wird nur
Xeinmal vergeben.
X
XWird als Argument ein "*" angehaengt, gibt die MBox eine detailierte Liste aus,
Xdie z.B. den letzen Anruf der jeweiligen User, das Userlevel etc. enthaelt.
X
XDetailierte Informationen ueber einzelnen User erhaelt man, wenn man als 
XOption den Namen ("Vorname Name", "Alias", "Shell-Account") angibt.
X
X#VERSION
XBefehl: "Version"
X
XDie aktulle Versionnummer wird angezeigt. Sollten Sie einmal einen Fehler
Xim Programm finden, geben Sie diese Nummer bei Ihrer Fehlerbeschreibung 
Xbitte an.
X
Xix/Mbox 0.8.2 by <volkers@unnet.ruhr.sub.org>	
X        =====
X
XDie Fehlerberschreibung sende Sie per E-Mail an die Anschrift "<volkers@...>".
X
XMit der "Version #"-Option wird die MBox angwiesen eine Liste begabter Leute
Xauszugeben, die massgeblich an der Entwicklung dieses Programms beteiligt
Xwaren.
X
X#WEITERLEITEN
XBefehl: "Weiterleiten"
X
XBriefe und Artikel koennen an andere Teilnehmer weitergeleitet werden. Dabei
Xgilt folgende Schreibweise:
X
X"Weiterleiten"            Der Betreff der zuletzt geschriebenen PM (!) wird
X                          angezeigt. Diese PM kann weitergeleitet werden.
X
X"Weiterleiten USER"       Die zuletztgeschrieben PM wird an den Teilnehmer
X                          USER geschickt. 
X
X"Weiterleiten NNN USER"   Der Artikel/Brief NNN wird an den Teilnehmer USER
X                          gesendet. 
X
XDie Briefe/Artikel koennen vor dem Versand ueberarbeitet werden. Die Syntax
Xist VERBINDLICH, es darf immer nur EIN Empfaenger angegeben werden.
X
XUSER kann ein lokaler Teilnehmer, ein User auf einem anderen Rechner, oder
Xaber der eigene SH-Account sein:
X
X"Weiterleiten Volker"            
X"Weiterleiten volkers@xenox.ruhr.de", 
X"Weiterleiten unnet!volkers"
X
X
END_OF_FILE
  if test 17291 -ne `wc -c <'etc/help.hilfe'`; then
    echo shar: \"'etc/help.hilfe'\" unpacked with wrong size!
  fi
  # end of 'etc/help.hilfe'
fi
if test -f 'etc/logo~' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/logo~'\"
else
  echo shar: Extracting \"'etc/logo~'\" \(243 characters\)
  sed "s/^X//" >'etc/logo~' <<'END_OF_FILE'
X
X
X
Xooo o o ooo   ooo o ooo ooo   ooo oo   o  o o ooo o      o  oo  ooo ooo ooo o o
X o  ooo oo     o  o ooo oo     o  ooo ooo o o oo  o     ooo o o oo  ooo o    o
X o  o o ooo    o  o o o ooo    o  o o o o  o  ooo ooo   o o ooo ooo ooo ooo  o
X
X
END_OF_FILE
  if test 243 -ne `wc -c <'etc/logo~'`; then
    echo shar: \"'etc/logo~'\" unpacked with wrong size!
  fi
  # end of 'etc/logo~'
fi
if test -f 'src/intro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/intro.c'\"
else
  echo shar: Extracting \"'src/intro.c'\" \(13541 characters\)
  sed "s/^X//" >'src/intro.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  intro.c						   */
X/*        FUNKTIONEN  intro(), init_user()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  18.03.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <time.h>
X
X#include "mbox.h"
X
Xtime_t time_start, time_now;
X
X
Xvoid init_user();
X
X/***************************************************************************/
X/*      FUNKTION  intro()						   */
X/*  BESCHREIBUNG  Teilnehmer melden sich an. Beim Aufruf von SHELL, wird   */
X/*		  die Prozedur automagisch abgewickelt. Gaeste koennen     */
X/*		  ausserdem in dieser Funktion ein Terminal auswaehlen.    */
X/*     PARAMETER  keine                                                    */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid intro()
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  char s[LSTRING];
X  char t[STRING];
X  char f[STRING];
X  char tmp[STRING];
X  char crypt_pw[STRING];
X  char ex[255];
X  char tmpuser[STRING];
X  char moreLASTLOG[STRING];
X  int i, calls;
X  char c;
X  int ok;
X  int a, b;
X  long lalo;
X  struct userdaten LOOSER;
X
X  struct tm *timeptr;
X  time_t timer;
X 
X  struct stat fst;
X
X  umask(0007);
X
X  sprintf(TERMINAL, "ansi");
X  ansi("INIT");
X
X  time(&time_start);
X
X  fp = fopen( LOGO, "r" );
X  if(fp != NULL){
X	fclose(fp);
X	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
X	ansi("cl");
X	ansi("md");
X        show( LOGO, 24, 0 );
X	ansi("me");
X	c = getint();	
X  }
X
X  printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
X  ansi("cl");
X
X  ansi("md");
X  printf("\n%s ", INT01_MSG);
X  ansi("me");
X  printf("%s", ORGANIZATION);
X	
X  ansi("md");
X  printf("\n%s ", INT02_MSG);
X  ansi("me");
X  printf("%s %s %s", VERSION, PATCHLEVEL, AUTOR);
X
X  ansi("md");
X  printf("\n%s ", INT03_MSG);
X  ansi("me");
X  printf("%s", SYSTEM);
X
X  BAUDRATE = (int) 0;
X
X  if (OLDGID == GUEST_GID) {	/* GAESTE */
X
X        TRY_AGAIN:
X
X	printf("\n\n%s ", GBL04_MSG);
X	strcpy(LOOSER.name, (char *) getline(30, 11, '.', ""));
X	if (LOOSER.name[0] == '\0') goto TRY_AGAIN;
X
X	strcpy(s, (char *) upcased(LOOSER.name));
X
X	if (strcomp(GUEST, s) != 0) {
X
X		printf("\n%s ", GBL09_MSG);
X		strcpy(LOOSER.passwort, (char *) getline(10, 12, '.', ""));
X		strcpy(crypt_pw, (char *) crypted(LOOSER.passwort));
X
X		maybe_locked(UDBASE, "r"); lockf(UDBASE);
X		fd = open(UDBASE, O_RDONLY);
X		if (fd == -1) {
X			nerror("intro.c", 78, "intro", "Datei-Lesefehler", UDBASE);
X		}
X		ok = 0;
X		while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X			if (((strcomp(LOOSER.name, USER.name) == 0) ||
X			  (strcomp(LOOSER.name, USER.nick) == 0)) &&
X			 ((strcomp(USER.passwort, (char *) crypt_pw) == 0) ||
X			  (strcomp(USER.passwort, LOOSER.passwort) == 0)))
X				ok = 1;
X		}
X		close(fd);
X		unlockf(UDBASE);
X
X		if (ok == 1) goto WELL_DONE;
X		goto TRY_AGAIN;
X	}
X	strcpy(LOOSER.name, (char *) upcased(s));
X
X	maybe_locked(UDBASE, "r"); lockf(UDBASE);
X	fd = open(UDBASE, O_RDONLY);
X	if (fd == -1) {
X		nerror("intro.c", 98, "intro", "Datei-Lesefehler", UDBASE);
X	}
X	ok = 0;
X	while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X		if (strcomp(LOOSER.name, USER.name) == 0) ok = 1;
X	}
X	close(fd);
X	unlockf(UDBASE);
X
X	ansi("md");
X	printf("\n\n%s\n\n", INT04_MSG);
X	ansi("me");
X	printf("%s\n", INT05_MSG);
X	ansi("md");
X	printf("\n%s > ", INT06_MSG);
X	ansi("me");
X
X	do {
X		c = getint();
X	} while ((c < '1') || (c > '4'));
X	printf("%c", c);
X	USER.terminal = c - 48;
X
X	strcpy(USER.name, (char *) GUEST);
X	sprintf(USER.passwort, "%s", "*****");
X
X	USER.level	   =  0;
X	USER.prompt        =  2;
X	USER.bell          =  0;
X	USER.intro         =  1;
X	USER.more          =  1;
X	USER.editor        =  1;
X	USER.lastmode      =  2;
X	USER.leserichtung  =  2;
X	USER.tlines        = 23;
X	USER.schluessel[0] =  1;
X
X	sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X
X	LASTLOG = (long) 19700101;
X	LASTTIME = 0;
X	sprintf(moreLASTLOG, "%s", "01.01.1970");
X  }
X  else {			/* USER */
X
X	printf("\n\n%s ....................", GBL04_MSG);
X	for (i = 0; i < 20; i++) printf("%c", BS);
X
X	strcpy(tmpuser, (char *) whoami());
X	printf("%s", tmpuser);
X
X	printf("\n%s ..........", GBL09_MSG);
X
X	for (i = 0; i < 10; i++) printf("%c", BS);
X	for (i = 0; i < 10; i++) printf("*");
X
X	if (strcomp(tmpuser, "root") == 0) {
X		strcpy(tmpuser, (char *) POSTMASTER);
X
X		s[0] = '\0'; strcat(s, (char *) ttyname(0));
X		if(strcomp(PMS_TTY, s) != 0){
X			printf("\n\n");
X			ansi("mr");
X			printf("%s", INT07_MSG);
X			ansi("me");
X			printf("\n\n");
X			exit(-1);
X		}
X		else {
X			USER.level = 10;
X		}
X	}
X	maybe_locked(UDBASE, "r"); lockf(UDBASE);
X	fd = open(UDBASE, O_RDONLY);
X	if (fd == -1) {
X		nerror("intro.c", 156, "intro", "Datei-Lesefehler", UDBASE);
X	}
X	ok = 0;
X	while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X		if ((strcomp(tmpuser, USER.sh_name) == 0)) ok = 1;
X	}
X	close(fd);
X	unlockf(UDBASE);
X
X	if (ok == 0) postfach(tmpuser);
X
X  }
X
X  WELL_DONE:
X
X  setuid( ROOT_UID );
X  setgid( ROOT_GID ); 
X
X  if (strcomp(GUEST, USER.name) != 0) {
X	LASTLOG = (long) dateconv(USER.lastlog);
X	LASTTIME = USER.lasttime;
X	sprintf(moreLASTLOG, "%s", USER.lastlog);
X  }
X  if (USER.lastmode == 2) LASTTIME = 0;
X
X  sprintf(UGROUPS, "%s/usr/%d/.active", HOME, USER.id);
X
X  maybe_locked( AGROUPS, "r" );
X  fp = fopen(AGROUPS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 182, "intro", "Datei-Lesefehler", AGROUPS);
X  }
X  ff = fopen(UGROUPS, "w");
X  if (ff == NULL) {
X	nerror("intro.c", 195, "intro", "Datei-Schreibfehler", UGROUPS);
X  }
X  while (fscanf(fp, "%s %ld", s, &lalo) > 0) {
X	if (LASTLOG < lalo) {
X		sprintf(t, "%s 00000 00000 y\n", s);
X		fputs(t, ff);
X	}
X	if (LASTLOG == lalo) {
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  sprintf(s, "%s \"%s\" (%d) %s", INT08_MSG, USER.name, USER.id, INT09_MSG);
X  control(s, 3);
X  whodo( INT10_MSG );
X
X  printf("\n\n");
X
X  if ((USER.level < 10) && (strcomp(MYNAME, USER.name) != 0)) {
X
X	maybe_locked(SEQ, "r"); lockf(SEQ);
X	fp = fopen(SEQ, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 223, "intro", "Datei-Lesefehler", SEQ);
X	}
X	fscanf(fp, "%d", &calls);
X	fclose(fp);
X	calls++;
X
X	fp = fopen(SEQ, "w");
X	if (fp == NULL) {
X		nerror("intro.c", 227, "intro", "Datei-Schreibfehler", SEQ);
X	}
X	fprintf(fp, "%d\n", calls);
X	fclose(fp);
X	unlockf(SEQ);
X
X	sprintf(tmp, "%s/%dT", TMP, getpid());
X
X	fp = fopen(tmp, "w");
X	if (fp == NULL) {
X		nerror("intro.c", 236, "intro", "Datei-Schreibfehler", tmp);
X	}
X	maybe_locked(CALLS, "r"); lockf(CALLS);
X	ff = fopen(CALLS, "r");
X	if (ff == NULL) {
X		nerror("intro.c", 239, "intro", "Datei-Lesefehler", CALLS);
X	}
X	sprintf(s, "%s (%s)", USER.name, USER.nick);
X	sprintf(t, "%s", numstripped(USER.wohnort));
X	if (t[0] == '\0') sprintf(t, "%s", "   ");
X
X	sprintf(f, "%s", (char *) ttyna());
X
X	if (OLDGID == GUEST_GID){
X		fprintf(fp, "%5.d  %-28.28s  %-17.17s %6.6s   %s  %s\n",
X			calls, s, stripped(t), f, (char *) mydate(1), (char *) mytime(1));
X	}
X	else{
X		fprintf(fp, "%5.d  %-28.28s  %-17.17s %6.6s   %s  %s\n",
X			calls, s, stripped(t), f, (char *) mydate(1), (char *) mytime(1));
X	}
X
X	if(PRO_ENTRIES < 10){
X		nerror("intro.c", 291, "intro", "PRO_ENTRIES zu klein dimensioniert", "mbox.h");			
X	}
X
X	i = 1;
X	while ((fgets(s, 84, ff) != NULL) && (i <= PRO_ENTRIES)) {
X		fputs(s, fp);
X		i++;
X	}
X
X	fclose(ff);
X	fclose(fp);
X
X	sprintf(s, "cp %s %s > /dev/null", tmp, CALLS);
X	system(s);
X
X	unlink(tmp);
X	unlockf(CALLS);
X  }
X
X  sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);  
X  if(atol(USER.abused) == 0L){
X	  stat(s, &fst);
X	  IDX_SIZE = (long) fst.st_size;
X  }
X  else IDX_SIZE = atol(USER.abused);
X
X  init_user( INT11_MSG );
X
X  if (USER.intro < 3) {
X
X	a = 0;
X	fp = fopen(UGROUPS, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 283, "intro", "Datei-Lesefehler", AGROUPS);
X	}
X	while (fgets(ex, 200, fp) != NULL) a++;
X	fclose(fp);
X
X	b = 0;
X	sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);  
X	
X	fp = fopen(s, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 291, "intro", "Datei-Lesefehler", s);
X	}
X	while (fgets(ex, 200, fp) != NULL){
X		if(ex[0] < 65) b++;
X	}
X	fclose(fp);
X	b -= 1;
X
X	ansi("md");
X	printf("%s %d. %s %s %s.\n", 
X		INT12_MSG, USER.seq, INT13_MSG, moreLASTLOG, INT14_MSG);
X	printf("%s %d %s %d %s.\n", 
X		INT15_MSG, a, INT16_MSG, b, INT17_MSG);
X	ansi("me");
X	printf("\n");
X  }
X  if ((USER.intro != 2) && (USER.intro != 4)) show(INTRO, 9999, 1);
X
X
X
X  
X  fp = fopen(WHO, "a");
X  if (fp == NULL) {
X	nerror("intro.c", 309, "intro", "Datei-Lesefehler", WHO);
X  }
X  strcpy(s, (char *) USER.sh_name);
X  if (s[0] == '\0') strcat(s, GBL10_MSG);
X  sprintf(ex, "%-5.5s %s (%s)                                               ",
X	(char *) ttyna(), USER.name, s);
X
X  ex[38] = '\0';
X  fputs(ex, fp);
X
X  sprintf(ex, "  %s              ", (char *) ttyna());
X  ex[11] = '\0';
X  fputs(ex, fp);
X
X  strcpy(s, (char *) mytime(1));
X  if (USER.level < 10)
X	sprintf(ex, " %s   [%d] MBox: %s\n", s, USER.level, INT10_MSG);
X  else
X	sprintf(ex, " %s   [%d] MBox: %s\n", s, ADMIN_LEV, INT10_MSG);
X
X  fputs(ex, fp);
X  fclose(fp);
X  
X
X
X  sprintf(MYNAME, "%s", USER.name);
X
X  sprintf(s, "%s", (char *) mydate(0));
X  s[5] = '\0';
X  if (strcomp(s, USER.geburtsdatum) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT18_MSG);
X	printf("%s\n\n", INT19_MSG);
X	ansi("me");
X  }
X  if (strcomp("24.12.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT20_MSG);
X	printf("%s\n\n", INT21_MSG);
X	ansi("me");
X  }
X  if (strcomp("06.12.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT22_MSG);
X	printf("\n%s\n\n", INT23_MSG);
X	ansi("me");
X  }
X  if (strcomp("01.01.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT24_MSG);
X	printf("%s\n\n", INT25_MSG);
X	ansi("me");
X  }
X  if ((calls == 1000) || (calls == 10000) || (calls == 100000)) {
X	ansi("md");
X	printf("\n\n%s %d%s\n\n", INT26_MSG, calls, INT27_MSG);
X	ansi("me");
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  init_user()						   */
X/*  BESCHREIBUNG  Teilnehmer-Parameter werden zugewiesen, Rechte verteilt  */
X/*		  und die Daten aktualisiert.                              */
X/*     PARAMETER  info  =  Ansage-Text                                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid init_user(info)
Xchar info[];
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  char s[STRING];
X  char t[STRING];
X  int i;
X  struct userdaten DUMMY;
X  int dummy = sizeof(DUMMY);
X  long ll, lalo;
X  int lati;
X  int ok;
X
X  printf("%s ..", info);
X
X  switch (USER.terminal) {
X      case 1:
X		sprintf(s, "eval '%s ansi' ", TSET);
X		sprintf(TERMINAL, "ansi");
X		break;
X      case 2:
X		sprintf(s, "eval '%s vt100' ", TSET);
X		sprintf(TERMINAL, "vt100");
X		break;
X      case 3:
X		sprintf(s, "eval '%s vt52' ", TSET);
X		sprintf(TERMINAL, "vt52");
X		break;
X      case 4:
X		sprintf(s, "eval '%s vt52' ", TSET);
X		sprintf(TERMINAL, "vt52");
X		break;
X  }
X  printf(".");
X
X  ansi("INIT");
X
X  fp = fopen(EDITORS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 487, "intro", "Datei-Lesefehler", EDITORS);
X  }
X  i = 0;
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  while ((i != USER.editor) && (fscanf(fp, "%s %s", s, EDDY) > 0)) i++;
X  fclose(fp);
X
X  printf(".");
X
X  if (USER.leserichtung == 0) USER.leserichtung = 2;
X
X  USER.seq++;
X
X  maybe_locked(UDBASE, "r"); lockf(UDBASE);
X  fd = open(UDBASE, O_RDWR);
X  if (fd == -1) {
X	nerror("intro.c", 395, "init_user", "Datei-Schreib/-Lesefehler", UDBASE);
X  }
X  while (read(fd, &DUMMY, dummy) == dummy) {
X	if (USER.id == DUMMY.id) {
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  write(fd, &USER, sizeof(USER));
X  close(fd);
X  unlockf(UDBASE);
X
X  printf(".");
X
X  sprintf(UGROUPS, "%s/usr/%d/.active", HOME, USER.id);
X  sprintf(MAKRO, "%s/usr/%d/.makro", HOME, USER.id);
X
X  maybe_locked( AGROUPS, "r" );
X  fp = fopen(AGROUPS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 412, "intro", "Datei-Lesefehler", AGROUPS);
X  }
X  ff = fopen(UGROUPS, "w");
X  if (ff == NULL) {
X	nerror("intro.c", 442, "intro", "Datei-Schreibfehler", UGROUPS);
X  }
X  while (fscanf(fp, "%s %ld %d", s, &lalo, &lati) > 0) {
X	if (LASTLOG < lalo) {
X		sprintf(t, "%s 00000 00000 y\n", s);
X		fputs(t, ff);
X	}
X	if (LASTLOG == lalo) {
X		if (LASTTIME <= lati) {
X			sprintf(t, "%s 00000 00000 y\n", s);
X			fputs(t, ff);
X		}
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  printf(".");
X
X  strcpy(BRETT, "PM");
X  sprintf(NG, "%s.PM", USER.name);
X  sprintf(INHALT, "%s/usr/%d/INDEX", HOME, USER.id);
X
X  printf(".");
X
X  if (USER.newsgrps[0] == '\0') sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X
X  sscanf(USER.newsgrps, "%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
X	newsgrp[1], newsgrp[2], newsgrp[3], newsgrp[4], newsgrp[5],
X	newsgrp[6], newsgrp[7], newsgrp[8], newsgrp[9], newsgrp[10],
X	newsgrp[11], newsgrp[12], newsgrp[13], newsgrp[14], newsgrp[15]);
X 
X
X  if((USER.tlines < 22) || (USER.tlines > 23)){
X	MAX_SCR_LINES = DEF_MAX_SCR_LINES;
X	USER.tlines = DEF_MAX_SCR_LINES;
X  }
X  else 
X	MAX_SCR_LINES = USER.tlines;
X
X
X  if(USER.schluessel[0] == 32)
X	SHORT_HEADER = 1;
X  else
X	SHORT_HEADER = 0;
X
X  if(USER.schluessel[1] == 0)
X	USER.schluessel[1] = 4;
X
X  if(USER.level >= WRITE_INTERNAT){
X	strcpy(UUCPID, UUCPID2);
X  }
X  else{
X	strcpy(UUCPID, UUCPID1);
X  }
X
X  if(USER.account[0] == '\0') strcpy(USER.account, "01.01.2001 000.00");
X
X  printf("%c", CR);
X}
END_OF_FILE
  if test 13541 -ne `wc -c <'src/intro.c'`; then
    echo shar: \"'src/intro.c'\" unpacked with wrong size!
  fi
  # end of 'src/intro.c'
fi
if test -f 'src/loop.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/loop.c'\"
else
  echo shar: Extracting \"'src/loop.c'\" \(19593 characters\)
  sed "s/^X//" >'src/loop.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  loop.c						   */
X/*        FUNKTIONEN  sigcatch(), cut_bef(), cut_arg(), rates(), loop()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  29.02.1992					   */
X/***************************************************************************/
X   
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/wait.h>
X#include <time.h>
X#include <setjmp.h>
X#include <signal.h>
X#include <sys/stat.h>
X
X#include "mbox.h"
X
X
X
Xextern time_t time_start, time_now;
X
Xjmp_buf jmpenv;
X
X
X
X/***************************************************************************/
X/*      FUNKTION  sigcatch()						   */
X/*  BESCHREIBUNG  Wird aufgerufen, wenn eines der abgefangen Signale	   */
X/*		  eintrifft. Je nach Signal wird entweder ein CTRL-X       */
X/*		  simuliert, oder das Programm ordnungsgemaesst beendet.   */
X/*     PARAMETER  sig  =  Nummer des ausloesenden Signals                  */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid sigcatch(sig)
Xint sig;
X{
X  char tmp[80];  
X
X  signal(SIGINT,   SIG_IGN);
X  signal(SIGQUIT,  SIG_IGN);
X  signal(SIGHUP,   SIG_IGN);
X  signal(SIGABRT,  SIG_IGN);
X  signal(SIGTERM,  SIG_IGN);
X
X  chdir( HOME );
X 
X  switch (sig) {
X	case SIGINT:
X	case SIGQUIT:
X		sprintf(tmp, "%s/I.%d", TMP, getpid());
X		unlink(tmp);
X		sprintf(tmp, "%s/show%d", TMP, getpid());
X		unlink(tmp);
X		unlockf( UDBASE );
X		printf("\n");
X		ansi("mr");
X		printf("%s", LOP01_MSG);
X		ansi("me");
X		printf("\n\n");
X		longjmp(jmpenv, 1);
X		break;
X      case SIGHUP:
X      case SIGABRT:
X      case SIGTERM:
X		printf("\n\n");
X		ansi("mr");
X		printf("%s", LOP02_MSG);
X		ansi("me");
X		printf("");
X		logout();
X		exit(-1);
X		break;
X  }
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  cut_bef()						   */
X/*  BESCHREIBUNG  Filtert den Befehl aus der Eingabe eines Users.          */
X/*     PARAMETER  Eingabezeile                                             */
X/*     RUECKGABE  Der isolierte Befehl                                     */
X/***************************************************************************/
X
Xchar *cut_bef(s)
Xchar s[];
X{
X  static char bef[STRING];
X  int i = 0;
X
X  while (s[i] > 32) {
X	bef[i] = s[i];
X	i++;
X  }
X  bef[i] = '\0';
X  return (char *) bef;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  cut_arg()						   */
X/*  BESCHREIBUNG  Filtert das Argument aus der Eingabe des Users.          */
X/*     PARAMETER  Eingabezeile 	                                           */
X/*     RUECKGABE  Das isolierte Argument                                   */
X/***************************************************************************/
X
Xchar *cut_arg(s)
Xchar s[];
X{
X  static char arg[STRING];
X  int i = 0, a = 0;
X
X  while (s[i] > 32) i++;
X  if (s[i] == '\0') return (char *) "";
X
X  while (s[i] == 32) i++;
X
X  while (s[i] != '\0') {
X	arg[a] = s[i];
X	i++;
X	a++;
X  }
X  arg[a] = '\0';
X
X  while((arg[(a-1)] < 33) && (a > 1)){
X	a--;
X	arg[a] = '\0';
X  }
X
X  return (char *) arg;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  rates()						   */
X/*  BESCHREIBUNG  Ermittelt die Telefongebuehren des laufenden Anrufs und  */
X/*		  bereitet sie als PROMPT auf.                             */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  PROMPT-Zeile fuer Gebuehren                              */
X/***************************************************************************/
X
Xchar *rates()
X{
X  static char s[STRING];
X  char t[STRING];
X  int nz, rz, wz;
X  int dif;
X  int n1, n2, r1, r2, w1, w2;
X  struct tm *timeptr;
X
X  time(&time_now);
X  dif = time_now - time_start;
X
X  n1 = dif / NZNT;
X  n1++;
X  n1 *= TARIF;
X  n2 = dif / NZBT;
X  n2++;
X  n2 *= TARIF;
X  r1 = dif / RZNT;
X  r1++;
X  r1 *= TARIF;
X  r2 = dif / RZBT;
X  r2++;
X  r2 *= TARIF;
X  w1 = dif / WZNT;
X  w1++;
X  w1 *= TARIF;
X  w2 = dif / WZBT;
X  w2++;
X  w2 *= TARIF;
X
X  timeptr = localtime(&time_now);
X  sprintf(t, "%s", asctime(timeptr));
X
X  if ((t[0] == 'S') || (timeptr->tm_hour > 18) || (timeptr->tm_hour < 8)) {
X	sprintf(s, "(%ds) NZ %d.%02.2d, RZ %d.%02.2d, WZ %d.%02.2d",
X	 dif, fix(n2), flt(n2), fix(r2), flt(r2), fix(w2), flt(w2));
X  }
X  else {
X	sprintf(s, "(%ds) NZ %d.%02.2d, RZ %d.%02.2d, WZ %d.%02.2d",
X	 dif, fix(n1), flt(n1), fix(r1), flt(r1), fix(w1), flt(w1));
X  }
X
X  return (char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  loop.c						   */
X/*  BESCHREIBUNG  Die Eingaben des Users werden entgegengenommen und die   */
X/*		  entsprechenden Routinen aufgerufen und ausgefuehrt.      */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid loop()
X{
X  char s[STRING];
X  char t[STRING];
X  char l[LONGSTRING];
X  char befehl[STRING];
X  char argument[STRING];
X  char prompt[STRING];
X
X  char prev_befehl[10][STRING];
X  int wasok;
X
X  char c;
X
X  char bef_buff[(STRING * 2)];
X  int bef_rec;
X
X  int ende = 0, ok, dummy, i;
X  int pp;
X  int to_del;
X  int fpid;
X
X  struct stat fst;
X
X
X  sprintf(prev_befehl[1], "%s ", BEF[BB1].befehl);
X  sprintf(prev_befehl[2], "%s ", BEF[BB2].befehl); 
X  sprintf(prev_befehl[3], "%s ", BEF[BB3].befehl);
X  sprintf(prev_befehl[4], "%s ", BEF[BB4].befehl);
X  sprintf(prev_befehl[5], "%s ", BEF[BB5].befehl);
X  sprintf(prev_befehl[6], "%s ", BEF[BB6].befehl);
X  sprintf(prev_befehl[7], "%s ", BEF[BB7].befehl);
X  sprintf(prev_befehl[8], "%s ", BEF[BB8].befehl);
X  sprintf(prev_befehl[9], "%s ", BEF[BB9].befehl);
X
X  wasok = 1;
X
X  bef_buff[0] = '\0';
X
X  do {
X
X	if(setjmp(jmpenv) == 1){
X		bef_buff[0] = '\0';
X	}
X
X	FASTER:
X	
X	signal(SIGINT,  sigcatch);
X	signal(SIGQUIT, sigcatch);
X
X	signal(SIGHUP,  sigcatch);
X	signal(SIGABRT, sigcatch);
X	signal(SIGTERM, sigcatch);
X
X
X	sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X	stat(s, &fst);
X	if(fst.st_size > IDX_SIZE){
X		printf("%c\n\n%s\n", BELL, LOP03_MSG); 
X	}
X        IDX_SIZE = (long) fst.st_size;
X
X	if(bef_buff[0] != '\0'){
X		sprintf(s, "%s", bef_buff);		
X		IS_BUFFERED = 1;
X		bef_rec++;
X		goto BUFFERING;
X	}
X        else 
X		IS_BUFFERED = 0;
X
X
X	bef_rec = 0;
X
X	ansi("md");
X	prompt[0] = '\0';
X
X	switch (USER.prompt) {
X	    case 1:
X			strcat(prompt, (char *) mytime(0));
X			break;
X	    case 2:	
X			strcat(prompt, NG);
X			break;
X	    case 3:	
X			strcat(prompt, (char *) rates());
X			break;
X	}
X	printf("\n[%s] %s > ", prompt, LOP06_MSG);
X	ansi("me");
X	if (USER.bell == 1) printf("%c", BELL);
X
X	befehl[0] = '\0';
X
X#ifdef _CORELEFT
X	if(coreleft() < _CORELEFT){
X		sprintf(s, "%d", _CORELEFT);
X		nerror( "loop.c", 288, "loop", "Speicherplatz kleiner ", s );
X	}
X#endif
X
X
X	do {
X		strcpy(s, (char *) getline(60, 11001, 32, befehl));
X		to_del = length(befehl);
X
X		if (s[0] == 48) {
X			headline( LOP05_MSG );
X			printf("\n");
X			for (i = 9; i > 0; i--) {
X				printf(" %d: %s\n", i, prev_befehl[i]);
X			}
X			goto FASTER;
X		}
X		if ((s[0] > 48) && (s[0] < 58)) {
X			sprintf(befehl, "%s", prev_befehl[(s[0] - 48)]);
X			printf("%c", CR);
X			if (ansi("ce") == 1) {
X				printf("                                                               ");
X			}
X			ansi("md");
X			printf("%c[%s] %s > ", CR, prompt, LOP06_MSG);
X			ansi("me");
X		}
X	} while ((s[0] > 47) && (s[0] < 58));
X
X	
X        if(makro_definition(s) != 0) goto FASTER;
X
X
X	BUFFERING:
X
X	if((bef_rec > MAKRO_MAX_REK) && (USER.level < (ADMIN_LEV+1))){
X		bef_buff[0] = '\0';
X		goto FASTER;
X	}
X
X        
X	strcpy(t, (char *) makro(s));
X	strcpy(s, t); 
X        
X	while ((s[0] == 32) || (s[0] == '.')) {
X		sprintf(befehl, "%s", (char *) strcopy(s, 1, length(s)));
X		sprintf(s, "%s", befehl);
X	}
X
X	i = 0; ok = 0;
X	while((ok == 0) && (s[i] != '\0')){
X		if(s[i] == ','){ 
X			strcpy(bef_buff, (char *) strcopy(s, (i+1), length(s)));
X			s[i] = '\0';
X			ok++;
X		}			
X		i++;
X	}
X	if(ok == 0) bef_buff[0] = '\0';
X	
X	strcpy(befehl, (char *) cut_bef(s));
X	strcpy(argument, (char *) cut_arg(s));
X	strcpy(s, (char *) upcased(befehl));
X	strcpy(befehl, s);
X
X	sprintf(s, "%s %s", befehl, argument);
X
X	if (wasok == 1) {
X		ok = 0;
X		for (i = 9; i > 0; i--) {
X			if ((strcomp(s, prev_befehl[i]) == 0) && (strcomp(prev_befehl[i], s) == 0))
X				ok++;
X		}
X		if ((ok == 0) && (befehl[0] > 32)) {
X			for (i = 9; i > 1; i--) {
X				sprintf(prev_befehl[i], "%s", prev_befehl[(i - 1)]);
X			}
X			sprintf(prev_befehl[1], "%s %s", befehl, argument);
X		}
X	}
X	else {
X		sprintf(prev_befehl[1], "%s %s", befehl, argument);
X	}
X
X	sprintf(s, "[%s] %s %s", LOP04_MSG, befehl, argument);
X	control(s, 3);
X
X	sprintf(s, "%s %s", befehl, argument);
X	whodo(s);
X
X
X	wasok = 0;
X
X	if (befehl[0] == '"') {
X		ansi("md");
X		/*
X		printf(" <- Nein, so daemlich kann kein User sein !\n");
X		*/
X		printf(" %s\n", LOP07_MSG);
X		ansi("me");
X		goto FASTER;
X	}
X	if (befehl[0] == '\0') goto FASTER;
X
X
X	if(argument[0] == '?') {
X		strcpy(argument, befehl);
X		strcpy(befehl, BEF[BB7].befehl);
X 	}
X
X/*  ?  */
X
X	if (befehl[0] == '?') {
X		if (argument[0] != '*') {
X			sprintf(s, " %s %d) ", LOP08_MSG, USER.level);
X		} else {
X			sprintf(s, " %s ", LOP09_MSG, USER.level);
X		}
X		headline(s);
X		printf("\n");
X		bef("?", argument);
X		goto FASTER;
X	}
X
X/* <BREAK> */
X
X	if (strcomp(befehl, "<BREAK>") == 0) {
X		printf("!@#?");
X		ansi("md");
X		printf(" %s", LOP10_MSG);
X		ansi("me");
X		printf("\n");
X		goto FASTER;
X	}
X	wasok = 1;
X
X
X	switch (bef(befehl, argument)) {
X
X	    case 275:		/* RELOGIN */
X
X		logout();
X		intro();
X		break;
X
X
X	    case 240:		/* MINIX */
X
X		if (argument[0] == '\0') {
X			ansi("md");
X			printf(" %s\n", LOP11_MSG);
X			ansi("me");
X		}
X		else {
X			printf("\n\n");
X			sprintf(s, "exec %s %s %d %d", RSH, argument, OLDUID, OLDGID);
X			system(s);
X		}
X		break;
X
X
X	    case 110:
X	    case 120:		/* + -  */
X
X		scanner(befehl[0]);
X		break;
X
X
X	    case 190:		/* HILFE */
X
X		printf("\n\n");
X		if (argument[0] < 33)
X			help("=");
X		else {
X			if(argument[0] == '*'){	
X				help("*");
X			}
X			else{
X				strcpy(s, "#");
X				strcat(s, upcased(argument));
X				if (help(s) < 1) {
X					ansi("md");
X					printf("%s \"%s\" %s\n", LOP12_MSG, argument, LOP13_MSG);
X					ansi("me");
X				}
X			}
X		}
X		break;
X
X
X	    case 150:		/* BRETT */
X
X		brett(argument);
X		break;
X
X
X	    case 130:		/* ANRUFER */
X
X		if(argument[0] == '#'){
X			statistik();
X			break;
X		}
X
X		if(argument[0] == '%'){
X			headline( LOP34_MSG );
X			printf("%s\n", LOP35_MSG);
X			printf("===============================================================================\n");
X			printf("%s ..", LOP29_MSG);
X	
X			switch( (fpid = fork()) ){
X				case -1 :
X					break;
X				case  0 : 
X					while(1){
X						printf(".");
X						sleep(2);
X					}	
X					break;
X			}
X			sprintf(t, "%s/%d.srt", TMP, getpid());
X			sprintf(l, SECONDCUT, CALLS, t);
X			system(l); 			
X			kill( fpid, 9 );
X			(void) wait( fpid );
X			printf("%c", CR);
X			show(t, 9999, USER.more + 100);
X			unlink(t);
X			break;
X		}
X
X		headline( LOP14_MSG );
X		printf("%s\n", LOP15_MSG);
X		printf("===============================================================================\n");
X
X		if (argument[0] != '*') {
X			show(CALLS, 19, USER.more);
X		}
X		else {
X			show(CALLS, 9999, USER.more + 100);
X		}
X		break;
X
X
X	    case 200:		/* INHALT */
X
X		inhalt2(argument, 'I');
X		break;
X
X
X	    case 210:		/* LESEN */
X
X		dummy = (pruefe(argument));
X		if (dummy == 0) lesen(argument);
X		if (dummy == -1) lesen2(argument, 'L');
X		break;
X
X
X
X	    case 230:		/* SCHREIBEN */
X
X		if (USER.level < WRITE_IN_LEV) {
X			ansi("md");
X			printf(" %s\n", LOP16_MSG);
X			ansi("me");
X		}
X		else
X			schreiben(argument);
X		break;
X
X
X	    case 220:		/* LOESCHEN */
X
X		dummy = (pruefe(argument));
X		if (dummy == 0) loeschen(argument);
X		if (dummy == -1) loeschen2(argument, 'D');
X		break;
X
X
X	    case 160:		/* BRIEF */
X
X		if (USER.level < WRITE_IN_LEV) {
X			ansi("md");
X			printf(" %s\n", LOP16_MSG);
X			ansi("me");
X		}
X		else
X			if((brief(argument) == 0) && (strcomp(GUEST, USER.name) != 0)){
X				sprintf(s, "%s?", USER.name);
X				brief(s);
X				sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X				stat(s, &fst);
X			        IDX_SIZE = (int) fst.st_size;
X			}
X			else bef_buff[0] = '\0';
X		break;
X
X
X	    case 170:		/* CHAT */
X
X		sprintf(s, "exec %s %s \"%s\" %d %d", RSH, CHAT, USER.nick, OLDUID, OLDGID);
X		system(s);
X		break;
X
X
X	    case 250:		/* PM */
X
X		strcpy(BRETT, "PM");
X		printf("\n");
X		sprintf(NG, "%s.PM", USER.name);
X		sprintf(INHALT, "%s/usr/%d/INDEX", HOME, USER.id);
X		break;
X
X
X	    case 260:		/* POSTFACH */
X
X		postfach("*");
X		break;
X
X
X	    case 300:		/* USER */
X
X		userliste(argument);
X		break;
X
X
X	    case 140:		/* ANSAGE */
X
X		ansage();
X		break;
X
X
X	    case 310:		/* UNTERSCHRIFT */
X
X		unterschrift();
X		break;
X
X
X	    case 320:		/* VERSION */
X
X		printf("\n\n");
X		ansi("md");
X		printf("Version: ");
X		ansi("me");
X		printf("%s %s %s\n", VERSION, PATCHLEVEL, AUTOR);
X
X		if(argument[0] == '#'){
X			ansi("md");
X			printf("\nMein spezieller Dank gilt folgenden Mitarbeitern, Beta-Testern und Ratgebern: \n\n");
X			ansi("me");
X			
X			printf("andreas@xenox.ruhr.de       - fuer den \"NewsFeed\" und seine Geduld\n");
X			printf("                              bei unseren \"Sonderwuenschen\"\n\n");
X
X			printf("az@unnet.w.open.de          - fuer seinen Einsatz beim \"Einrichten\"\n");
X			printf("                              der Mailbox und der PD-Portierung\n\n");
X
X			printf("joergg@unnet.ruhr.sub.org   - fuer seine Ideen, Tips, konstruktive\n");
X			printf("                              Kritik und gruendliche Tests\n\n");		
X
X			printf("klausr@skylink.ruhr.sub.org - fuer viele Vorschlaege, und vor allem\n");			
X			printf("                              fuer seine praesizen Fehlerbeschreibungen\n\n");			
X
X			printf("stefans@coduck.ruhr.sub.org - fuer seine Hilfe bei der Installation\n");
X			printf("                              der 386er Patches und der PD-Beschaffung\n\n");
X
X			printf("walterb@weller.ruhr.sub.org - fuer seine Unterstuetzung bei der Portierung auf\n");
X			printf("                              UNIX SVR3 und bei der Installation\n\n");
X
X			printf("hergo@ivcmd.boerde.de       - fuer seine Hilfe bei der Bildung einer Referenz-\n");
X			printf("                              Version zur Verwendung von CDIFFs\n\n");
X			
X		}
X		
X		if(argument[0] == '*'){
X			ansi("md");
X			printf("\n%s ", LOP17_MSG);
X			ansi("me");
X#ifdef _SYS7
X			printf("-D_SYS7 ");
X#endif
X#ifdef _MBOX
X			printf("-D_MBOX ");
X#endif
X#ifdef _MINIX
X			printf("-D_MINIX ");
X#endif
X#ifdef _ESTDIO
X			printf("-D_ESTDIO ");
X#endif
X#ifdef _CORELEFT
X			printf("-D_CORELEFT ");
X#endif
X#ifdef _DATESTAMP
X			printf("-D_DATESTAMP ");
X#endif
X#ifdef _BAUDRATE
X			printf("-D_BAUDRATE ");
X#endif
X
X			printf("\n");
X		}
X
X		break;
X
X
X	    case 270:		/* PORTINFO */
X
X		port( argument );
X		break;
X
X
X	    case 280:		/* SETUP */
X
X		sprintf(s, "%s", NG);
X		sprintf(t, "%s", BRETT);
X		setup();
X		if (strcomp("PM", t) != 0) brett(s);
X		break;
X
X
X	    case 125:		/* ADMIN */
X
X		sprintf(s, "%s", NG);
X		sprintf(t, "%s", BRETT);
X		admin();
X		if (strcomp("PM", t) != 0) brett(s);
X		break;
X
X
X	    case 205:		/* ID */
X
X		if(strcomp("-c", argument) == 0){ /* Memory fault - core dumped */
X			printf("\n\nDebug-Modus: ");
X			fclose(0);   
X			break;
X		}
X
X		if(strcomp("*", argument) == 0){
X			BAUDRATE = baudrate( MAX_BPS );
X			printf("\n\n>>> Baudrate %d\n", BAUDRATE);
X			break;
X		}
X
X		if(strcomp("#", argument) == 0){
X			printf("\n\n>>> Coreleft %d\n", coreleft());
X			break;
X		}
X
X		printf("\n\n>>> %s (UID %d|%d|%d) (GID %d|%d|%d)\n", MYNAME,
X		       getuid(), geteuid(), OLDUID,
X		       getgid(), getegid(), OLDGID);
X		break;
X
X
X	    case 215:		/* LEVEL */
X
X		show_level();
X		break;
X
X
X	    case 290:		/* STATUS */
X
X		status();
X		break;
X
X
X	    case 330: 		/* MAKRO */
X
X		set_makros();
X		break;
X
X
X	    case 340:		/* WEITERLEITEN */
X
X		weiterleiten( argument );
X		break;
X
X
X	    case 350:           /* SLEEP */
X
X		dummy = atoi( argument );
X		if(dummy < 1) dummy = 1;
X		printf("\n");
X		ansi( "mr" );
X		printf(" %s ... ", LOP29_MSG);
X		ansi( "me" );	
X		sleep( dummy );
X		break;		
X
X
X	    case 360:		/* KEYPRESSED */
X
X		printf("\n");
X		ansi("mr");
X		printf(" Taste ! ");
X		ansi("me");
X		dummy = getint();
X		if((dummy == CTRL_X) || (dummy == 'x') || (dummy == 'q')){
X			bef_buff[0] = '\0';
X			printf("\n");
X		}
X		break;
X
X
X	    case 370:		/* DATUM */
X		
X		ansi("md");
X		printf("\n\n%s ", LOP18_MSG);
X		ansi("me"); 
X		printf("%s, ", (char *) mydate( 2 ));
X		printf("%s\n",  (char *) mydate( 0 ));
X		break;
X	
X
X	    case 380:		/* ZEIT */
X
X		ansi("md");
X		printf("\n\n%s ", LOP19_MSG);
X		ansi("me");
X		printf("%s\n", (char *) mytime( 0 ));
X		ansi("md");
X		printf("Online: ");
X		ansi("me");
X		time(&time_now);
X		printf("%d %s\n",  (int) time_now - time_start, LOP20_MSG);
X		break;
X
X
X	   case 390:		/* SPIELE */
X
X		games();
X		break;
X	
X
X	    case 400:		/* RICHTUNG */
X
X		ansi("md");
X		printf("\n\n%s ", LOP21_MSG);
X		ansi("me");
X
X		if (USER.leserichtung == 1) {
X			USER.leserichtung = 2;
X			printf("%s\n", LOP22_MSG);
X		}
X		else {
X			USER.leserichtung = 1;
X			printf("%s\n", LOP22aMSG);
X		}
X		break;
X
X
X	    case 410:           /* STATISTIK */
X
X		if ((argument[0] != '#') && (argument[0] != '$') && (argument[0] != '%')) {
X			headline( LOP23_MSG );
X			printf("%s\n", LOP24_MSG);
X			printf("===============================================================================\n");
X
X			if (argument[0] != '*') {
X				show(MB_DLOG, 19, USER.more);
X			}
X			else {
X				show(MB_DLOG, 9999, USER.more + 100);
X			}
X		}
X		if(argument[0] == '$') {
X			headline( LOP25_MSG );
X			show(UUCPCOSTS, 9999, USER.more);
X		}
X   		if(argument[0] == '#') {
X			headline( LOP26_MSG );
X			printf("%s\n", LOP27_MSG);
X			printf("===============================================================================\n");
X
X			show(PDLOG, 9999, USER.more + 100);
X		}
X		if(argument[0] == '%') {
X			headline( LOP32_MSG );
X			printf("%s\n", LOP33_MSG);
X			printf("===============================================================================\n");
X			printf("%s ..", LOP29_MSG);
X	
X			switch( (fpid = fork()) ){
X				case -1 :
X					break;
X				case  0 : 
X					while(1){
X						printf(".");
X						sleep(2);
X					}	
X					break;
X			}
X			sprintf(t, "%s/%d.srt", TMP, getpid());
X			sprintf(l, SORTEDCUT, PDLOG, t);
X			system(l); 			
X			kill( fpid, 9 );
X			(void) wait( fpid );
X			printf("%c", CR);
X			show(t, 9999, USER.more + 100);
X			unlink(t);
X		}
X
X		break;
X 
X
X	    case 430:		/* SUCHEN */
X
X		suchen( argument );
X		break;	
X
X	    			
X	    case 420:		/* RING */
X
X		ende = 1;
X		break;
X
X
X	  case 440:		/* DOWNLOAD */
X
X		download( argument );
X		break;
X	       	
X
X	    case 180:		/* ENDE */
X
X#ifdef _MINIX
X		if (tty() >= FIRST_EX_TTY) {
X			printf("\n\n");
X			ansi("mr");
X			printf("%c%s [%c, %c] > ", CR, LOP28_MSG, GBL06_MSG, GBL07_MSG);
X			ansi("me");
X			
X			c = yesno();
X		} else
X#endif
X			c = GBL06_MSG;
X
X
X		if (c == GBL06_MSG)
X			ende = 1;
X		else
X			printf("\n");
X
X		if(argument[0] == '*'){
X			USER.lasttime = LASTTIME;
X			strcpy(USER.lastlog, (char *) datereconv( LASTLOG ));
X		}
X		else{
X			strcpy(s, (char *) mydate(0));
X			s[10] = '\0';
X			strcpy(USER.lastlog, s);
X			strcpy(s, (char *) mytime(1));
X			USER.lasttime = timeconv(s);
X		}
X
X		break;
X
X	    case -1:		/* LEVEL ??? */
X
X		wasok = 0;
X		ansi("md");
X		printf(" %s %d ...\n", LOP30_MSG, USER.level);
X		ansi("me");
X		break;
X
X	    default:
X
X		wasok = 0;
X		ansi("md");
X		printf(" %s\n", LOP31_MSG);
X		ansi("me");
X	}
X
X  } while (ende == 0);
X}
END_OF_FILE
  if test 19593 -ne `wc -c <'src/loop.c'`; then
    echo shar: \"'src/loop.c'\" unpacked with wrong size!
  fi
  # end of 'src/loop.c'
fi
echo shar: End of archive 5 \(of 10\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
