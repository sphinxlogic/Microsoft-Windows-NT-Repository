Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i068:  mbox - A Bulletin Board System for UNIX and MINIX, Part06/10
Message-ID: <1992Apr5.183536.29812@sparky.imd.sterling.com>
X-Md4-Signature: ddf5005c58f3cb830bf57ca26d6c91a2
Date: Sun, 5 Apr 1992 18:35:36 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 68
Archive-name: mbox/part06
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  src/mbox.h src/misc2.c src/pd.c src/portinfo.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:43 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 10)."'
if test -f 'src/mbox.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mbox.h'\"
else
  echo shar: Extracting \"'src/mbox.h'\" \(12398 characters\)
  sed "s/^X//" >'src/mbox.h' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/MBox						   */
X/*             DATEI  mbox.h						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  28.02.1992					   */
X/***************************************************************************/
X 
X#include "mbox.msg"
X#include "defs.h"
X#include "patchlevel.h"
X
X
X 
X/***************************************************************************/
X/* >ORGANIZATION  -  frei waehlbar (moeglichst identisch mit dem ent-      */
X/*		     sprechenden Eintrag fuer NEWS)			   */
X/* >SYSTEM        -  frei waehlbar (Name der Mailbox)     	  	   */
X/***************************************************************************/
X
X#define ORGANIZATION 	"THE UNDERGROUND NETWORK"
X#define SYSTEM       	"The Time Traveling Agency"  
X
X
X
X/***************************************************************************/
X/*  VERSION       -  wird vom Autor (und nur vom dem) geandert		   */
X/*                   Co-Autoren, Portierer etc. koennen sich gefaelligst   */
X/*		     ihren eigenen Eintrag basteln.		           */
X/*  AUTOR         -  das bin ich - Hallo auch !				   */
X/***************************************************************************/
X
X#define VERSION	     	"ix/MBox 1.6"
X#define AUTOR        	"by <volkers@unnet.w.open.DE>"
X
X
X
X
X/***************************************************************************/
X/* >UUCPSITE       - Systemname innerhalb der UUCP-Netze		   */
X/* >UUCPID2        - Adresse (Domain-) im Internet			   */
X/* >UUCPID1        - Adresse (Domain-) im lokalen UUCP-Netz 		   */
X/* >UUCPBANG       - Adresse als BANG-Pfad				   */
X/*  UUCPCOSTS      - Gebuehrenaufstellung				   */
X/* >SMARTHOST	   - 							   */
X/***************************************************************************/
X
X#define UUCPSITE     	"unnet"
X#define UUCPID2      	"unnet.w.open.DE"        
X#define UUCPID1	     	"unnet.ruhr.SUB.ORG"
X#define UUCPBANG     	"~!unido!horga!xenox!unnet!"
X#define UUCPCOSTS    	"/usr/spool/uucp/.costs"
X#define SMARTHOST	"xenox"
X
X
X
X/***************************************************************************/
X/*  X_MAIL_DEMON    - Name des X-Mail-Daemons (HAENDE WEG !!!) 		   */
X/***************************************************************************/
X
X#define X_MAIL_DEMON 	"X-Mail-Daemon"
X
X
X
X
X/***************************************************************************/
X/* >HOME             - HOME-Directory der ix/MBox	   	  	   */
X/*  LIB		     - Pfad zum MBox-Directory LIB			   */
X/*  TMP              - Directory fuer temporaere Dateien		   */
X/* >NEWS	     - Pfad zum SPOOL-Directory fuer NEWS		   */
X/*  ERRMBOX          - Mailbox des Error-Users (POSTMASTER)		   */
X/*  MAILDROP         - Pfad zu den Maildrops der SH-User		   */
X/* >NGROUPS          - Pfad zur "active"-Datei von NEWS			   */
X/*  AGROUPS	     - Pfad zur MBox-"active"-Datei			   */
X/***************************************************************************/
X     
X#define HOME         	"/mbox"
X#define LIB	     	"./lib"
X#define TMP	     	"/tmp"
X#define NEWS         	"/usr/spool/news"
X#define ERRMBOX      	"/usr/spool/mail/postmaster"
X#define MAILDROP     	"/usr/spool/mail"
X#define NGROUPS      	"/usr/lib/news/active"
X#define AGROUPS      	"./etc/active"
X
X
X
X
X
X/***************************************************************************/
X/* >CONSOLE	      - Geraet/Datei fuer die Logbuch-Ausgaben		   */
X/*			Ist CONSOLE als "REDIRECT" definiert, wird aus der */
X/*                      Datei CDIRECTFL der Name der Ausgabedatei gelesen  */
X/*			gelesen					           */
X/*  CDIRECTFL         - Geraet/Datei wohin CONSOLE-Info ausgeben wird	   */
X/*		        Die Datei ENTHAELT DEN NAMEN der Ausgabedatei !!!  */
X/* >CPRN              - Geraet/Datei fuer Fehler-Ausgaben		   */
X/* >POSTMASTER        - Name des SYSOPs (identisch mit dessen SH-Account)  */
X/*  MAX_BPS           - Maximale Modem-Ubertragungsrate in BPS             */
X/* >PMS_TTY           - Nummer des einzigen Terminals, auf dem sich "root" */
X/*			anmelden darf					   */
X/*  GUEST             - MBox-Account fuer Besucher			   */
X/*  UDBASE            - Pfad zur Teilnehmer-Datenbank			   */
X/*  UDSEQ             - Pfad zur Teilnehmer-SEQ-Datei			   */
X/***************************************************************************/
X
X#define CONSOLE	     	"REDIRECT"
X#define CDIRECTFL    	"/etc/mbox.out"
X#define CPRN	     	"/tmp/errlog"
X#define POSTMASTER   	"volkers"
X#define PMS_TTY      	"/dev/tty4"
X#define MAX_BPS      	19200
X#define GUEST        	"GAST"
X#define UDBASE       	"./etc/users.data"
X#define UDSEQ        	"./etc/users.seq"
X
X
X
X
X/***************************************************************************/
X/*  BEFEHLE 	   - Pfad zur Befehls-Tabelle				   */
X/*  HILFE          - Pfad zu den HELP-Texten				   */
X/*  KURZHILFE	   - Kurzuebersicht					   */
X/*  INTRO          - Pfad zur INTRO-Meldung				   */
X/*  LOGO           - Optionaler Text als Mailbox-LOGO 			   */
X/***************************************************************************/
X
X#define BEFEHLE	     	"./etc/help.befehle"  
X#define HILFE	     	"./etc/help.hilfe"
X#define KURZHILFE    	"./etc/help.shorthelp"
X#define INTRO        	"./etc/intro"
X#define LOGO         	"./etc/logo"
X
X
X
X
X/***************************************************************************/
X/*  SEQ             - Pfad zur MBox-SEQ-Datei (Anzahl der Anrufe)	   */
X/*  CALLS           - Pfad zur MBox-CALLS-Datei (Logfile)		   */
X/*  WHO             - Pfad zur MBox-WHO-Datei (gerade aktive User)	   */
X/***************************************************************************/
X
X#define SEQ          	"./etc/mbox.seq"
X#define CALLS        	"./etc/mbox.calls"
X#define WHO          	"./etc/mbox.who"
X
X
X
X
X/***************************************************************************/
X/*  EDITORS          - Pfad zur Liste der verfuegbaren Eddies		   */
X/*  GAMES            - Pfad zur Liste der Online-Spiele			   */
X/*  MAX_GAMES 	     - Anzahl der max. angebotenen Spiele		   */
X/* >CHAT             - Pfad zum CHAT-Programm				   */
X/*  RSH              - MBox-RSH; NICHT identisch mit RemoteSH/RestrictedSH */
X/***************************************************************************/
X
X#define EDITORS      	"./etc/mbox.editors"
X#define GAMES	     	"./etc/mbox.games"
X#define MAX_GAMES	10
X#define CHAT         	"/usr/bin/chat"
X#define RSH          	"./mbrsh"
X
X
X
X
X
X/***************************************************************************/
X/*  ROOT_UID          - siehe "/etc/passwd"				   */
X/*  ROOT_GID          - dito						   */
X/*  GUEST_GID 	      - dito (unbedingt != GID fuer "normale" User)        */
X/***************************************************************************/
X
X#define ROOT_UID      	0
X#define ROOT_GID      	0
X#define GUEST_GID     	1
X
X
X
X
X
X/***************************************************************************/
X/* >FIRST_EX_TTY       - Nummer des ersten seriellen Terminals		   */
X/*  MAX_TERMINALS      - Max. Anzahl der aktiven Terminals 		   */
X/***************************************************************************/
X
X#define FIRST_EX_TTY	64
X#define MAX_TERMINALS	20
X
X
X
X
X/***************************************************************************/
X/* >SIGNATURE          - Name des '.signature'-File im $HOME eins SH-Users */
X/* >TSET               - Pfad zum TSET-Programm				   */
X/* >EXPIRE             - Pfad zum EXPIRE-Programm			   */
X/*  MB-DAEMON          - Pfad zum MB-DAEMON-Programm			   */
X/*  MB_DLOG            - Pfad zum MB-DAEMON-Statistik-File		   */
X/*  XMDLOG	       - Pfad zum XMD-Protokoll-File		           */
X/*  XMD_ALIAS	       - Pfad zur Alias-Datei des XMD			   */
X/***************************************************************************/
X
X#define SIGNATURE    	".wmailsign"
X#define TSET         	"./etc/tset"
X#define EXPIRE       	"/usr/lib/news/expire"
X#define MB_DAEMON    	"/usr/bin/mb-daemon"
X#define MB_DLOG      	"./etc/mbd.log"
X#define XMDLOG	     	"/usr/adm/xmd.log"
X#define XMD_ALIAS	"./etc/xmd.alias"
X
X
X
X
X/***************************************************************************/
X/* >COMPRESS		- Pfad zum Standard-COMPRESS			   */
X/* >GREP 		- Pfad zum SUCH-Programm (GREP -L: Filename only !)*/
X/* >SORTEDCUT           - Zaehlt die Downloads pro File			   */
X/* >SECONDCUT           - Zaehlt die Anrufe pro User			   */
X/* >UUX                 - Fuehrt Kommandos auf fremden Sites aus	   */
X/***************************************************************************/
X
X#define COMPRESS     	"/usr/bin/compress"
X#define GREP         	"/usr/bin/grep -l"
X#define SORTEDCUT       "cut -d' ' -i2 -f3 %s | sort - | uniq -c | sort -r - | sed '/ \\//s//   \\//g' > %s"
X#define SECONDCUT	"cut -c6-35 %s | sed '/  /s//    /g' | sort - | uniq -c | sort -r - > %s"
X#define UUX		"uux -r"
X
X
X
X
X/***************************************************************************/
X/*  PDNG		 - Name der Freeware/Shareware/PD-NG		   */
X/*  PDLOG                - PD-Download-Protokoll			   */
X/*  PDSCRIPT		 - Pfad zum Protokoll der UPLOADs		   */
X/* >NEWS_MINIMUM         - Mindestens verfuegbare NGs			   */
X/*  MAX_PER_NG           - Maximale Anzahl der Eintraege pro NG		   */
X/*  EXPIRE_DAYS          - Ab wann loeschen, wenn MAX_PER_NG erreicht ist  */
X/*  MAX_XMD_ALIAS	 - Wieviele Namen kann XMD "umleiten"              */
X/*  NAT_DOMAIN1          - Nationale Domains (gebuehrenfrei)		   */
X/*  NAT_DOMAIN2          - (dito)					   */
X/*  NAT_DOMAIN3          - (dito)					   */
X/***************************************************************************/
X
X#define PDNG	     	"local.pd"
X#define PDLOG	     	"./etc/pd.log"
X#define PDSCRIPT     	"./etc/pd.script"
X#define NEWS_MINIMUM 	"junk local xenox de"
X#define MAX_PER_NG   	700
X#define EXPIRED_DAYS 	32
X#define MAX_XMD_ALIAS   20
X#define NAT_DOMAIN1  	".de"
X#define NAT_DOMAIN2  	".sub.org"
X#define NAT_DOMAIN3  	".de" 
X
X
X
X
X
X/***************************************************************************/
X/*  SZ  		  - ZModem Download				   */
X/*  SX			  - X-Modem					   */
X/*  SB		          - Y-Modem					   */
X/*  RZ			  - ZModem Upload				   */
X/*  RX                    - X-Modem 					   */
X/*  RB                    - Y-Modem					   */
X/***************************************************************************/
X
X#define SZ           	"/usr/bin/sz"
X#define SX           	"/usr/bin/sx"
X#define SB 	     	"/usr/bin/sb"
X
X#define RZ           	"/usr/bin/rz"
X#define RX	     	"/usr/bin/rx"
X#define RB	     	"/usr/bin/rb"
X
X
X
X
X
X/***************************************************************************/
X/*  TARIF           	  - Pfennige pro Einheit (Telefongebuehren)	   */
X/*  NZNT                  - Sekunden pro Einheit Nahzone/Normal-Tarif	   */
X/*  NZBT                  -                      Nahzone/Billig-Tarif	   */
X/*  RZNT                  - 		         Regionalzone/Normal-Tarif */
X/*  RZBT		  -			 Regionalzone/Billig-Tarif */
X/*  WZNT		  -			 Weitzone/Normal-Tarif     */
X/*  WZBT		  -			 Weitzone/Billig-Tarif     */
X/***************************************************************************/
X
X#define TARIF        	23
X#define NZNT         	360
X#define NZBT         	720
X#define RZNT 	     	60
X#define RZBT	    	120
X#define WZNT	     	21
X#define WZBT	     	42
X
X
X
X
X/***************************************************************************/
X/*  PRO_ENTRIES    	  - Maximal Eintraege in MBOX.CALLS      	   */
X/*  MAX_TAGE		  - Max. Eintraege im PRO-Diagramm		   */
X/***************************************************************************/
X
X#define PRO_ENTRIES  	999
X#define MAX_TAGE	16
X
X
X
X/***************************************************************************/
X/*  MVERSION		  - Version des MB-DAEMON			   */
X/*  REFLECT_NG		  - Auf diese Gruppe wird "reflektiert"		   */
X/*  REFLECT_LOG		  - LOG-File des Reflektors			   */
X/*  DIRLIST		  - Wird gesendet bei DIRLIST-Request 		   */
X/*  REFLECTUID		  - UID des Reflektors (siehe /etc/passwd)         */
X/*  TZS			  - ?? Fehler in der Zeitberechnung ??		   */
X/***************************************************************************/
X
X#define MVERSION    	"+++ Un.Net Reflecting Device - Version 1.6 / MB-DAEMON +++"
X#define REFLECT_NG  	"xenox.test"
X#define REFLECT_LOG 	"/mbox/etc/reflector.log"
X#define DIRLIST     	"/public/pd/DIRLIST"
X#define REFLECTUID  	22
X#define TZS		1
X
X
X
X
X
X
END_OF_FILE
  if test 12398 -ne `wc -c <'src/mbox.h'`; then
    echo shar: \"'src/mbox.h'\" unpacked with wrong size!
  fi
  # end of 'src/mbox.h'
fi
if test -f 'src/misc2.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/misc2.c'\"
else
  echo shar: Extracting \"'src/misc2.c'\" \(8307 characters\)
  sed "s/^X//" >'src/misc2.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  misc2.c						   */
X/*        FUNKTIONEN  chk_newsgrp(), subb(), loeschen(), brett() 	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  23.01.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  chk_newsgrp()						   */
X/*  BESCHREIBUNG  Stellt fest, ob ein Benutzer die angefragt NG betreten   */
X/*		  darf.	                                                   */
X/*     PARAMETER  s  =  Name der fraglichen NG				   */
X/*     RUECKGABE  -1 =  Kein Zugang/Zugriff :-(                            */
X/*                 1 =  Zugang erlaubt :-) 				   */
X/***************************************************************************/
X
Xint chk_newsgrp( s )
Xchar s[];
X{
X  int i = 1, ok = -1;
X
X  while ((i < MAX_NEWSGRPS) && (newsgrp[i][0] != '\0') && (ok == -1)) {
X	if (strcomp(newsgrp[i], s) == 0) ok = 0;
X	if (strcomp(newsgrp[i], "all") == 0) ok = 0;
X	i++;
X  }
X
X  return ok;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  subb()						   */
X/*  BESCHREIBUNG  Ist die angefragte NG eine Unter-NG, oder ein kompletter */
X/*		  Pfad ??                                                  */
X/*     PARAMETER  s  =  Name der NG                         |              */
X/*     RUECKGABE  0  =  Unter-NG (z.B. minix)               v              */
X/*		  n  =  Erste Obergruppe endet bei 'n' (comp.os.minix)     */
X/***************************************************************************/
X
Xint subb(s)
Xchar s[];
X{
X  int a = 0, i = 0;
X
X  while (s[i] != '\0') {
X	if ((s[i] == '.') && (a == 0)) a = i;
X	i++;
X  }
X  return a;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  loeschen()						   */
X/*  BESCHREIBUNG  Gezielt einen persoenliche Mail loeschen.		   */
X/*     PARAMETER  arg  =  Nummer der Mail                                  */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid loeschen(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  char s[STRING];
X  char entry[STRING];
X  char index[STRING];
X  char t[STRING];
X  char ex[255];
X  char c;
X  int i, a = atoi(arg);
X  int ok;
X
X
X  if ((arg[0] < '1') || (arg[0] > '9')) {
X	ansi("md");
X	printf(" %s\n", MI201_MSG);
X	ansi("me");
X	return;
X  }
X  if (strcomp(BRETT, "PM") != 0) {
X	if(arg[0] < 33) return;
X	if(USER.level < ADMIN_LEV){
X		ansi("md");
X		printf(" %s %d ...\n", MI202_MSG, USER.level);
X		ansi("me");
X	}
X	else{
X		sprintf(entry, "%s/%s", BRETT, arg);
X		unlink(entry);
X		printf("\n\n%s\n", MI203_MSG);		
X		sprintf(entry, "mb-daemon %s -X", NG);
X		system(entry);
X	}
X	return;
X  }
X
X  if(USER.level == GUEST_LEV){
X	return;
X  }
X
X  sprintf(entry, "%s/usr/%d/%s", HOME, USER.id, arg);
X  sprintf(index, "%s/usr/%d/INDEX", HOME, USER.id);
X
X  sprintf(s, "%s/loe%d", TMP, getpid());
X  ff = fopen(s, "w");
X
X  fp = fopen(index, "r");
X  if (fp == NULL) {
X	nerror("misc2.c", 109, "loeschen", "Datei-Lesefehler", index);
X  }
X  ok = 0;
X
X  while (fgets(ex, 250, fp) != NULL) {
X	if (atoi(ex) != a)
X		fputs(ex, ff);
X	else
X		ok = 1;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  sprintf(t, "cp %s %s", s, index);
X  system(t);
X  unlink(s);
X  unlink(entry);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  brett()						   */
X/*  BESCHREIBUNG  Wechselt das Brett, zeigt Bretter an etc. pp. 	   */
X/*     PARAMETER  arg  =  '?'     =  Brettername ausgeben		   */
X/*		  arg  =  ''      =  aktuelle Bretter ausgeben		   */
X/*		  arg  =  '*'     =  alle Bretter ausgeben	           */
X/*		  arg  =  '#'     =  Gruppen ausgeben                      */
X/*		  arg  =  '..'    =  eine Gruppe zurueck		   */
X/*		  arg  = 'Brett'  =  ins Brett 'Brett' wechseln		   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
X/*
Xvoid brett(arg)  Compiler Bug ???? 
X*/
Xbrett(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  char s[STRING];
X  char o[STRING];
X  int a, b, h;
X  char t[STRING];
X  char org[STRING];
X  char maybe[STRING];
X  int this;
X  int i, j;
X  int subboard = 0;
X  char c;
X  int plus = 0;
X  int zeile = 0;
X  int swing = 1;  
X  int fpid;
X
X  if (arg[0] == '!') {
X	printf("\n\n");
X	ansi( "md" );
X	printf("%s ", MI204_MSG);
X	ansi( "me" );
X	printf("%s\n", NG);
X	return;
X  }
X  if ((arg[0] == '+') || (arg[0] == '-')) {
X	scanner(arg[0] + 255);
X	return;
X  }
X  if (arg[0] == '\0') {
X	maybe_locked(UGROUPS, "r");
X	fp = fopen(UGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 908, "brett", "Datei-Lesefehler", UGROUPS);
X	}
X	arg[0] = '*';
X  }
X  else {
X	maybe_locked(NGROUPS, "r");
X	fp = fopen(NGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 916, "brett", "Datei-Lesefehler", NGROUPS);
X	}
X  }
X
X
X  org[0] = '\0';
X  strcat(org, arg);
X
X  if (arg[0] == '.') {
X	i = 0;
X	j = 0;
X	strcpy(org, NG);
X	while (org[i] != '\0') {
X		if (org[i] == '.') j = i;
X		i++;
X	}
X	if (j == 0) return;
X	org[j] = '\0';
X  }
X  if (arg[0] == '#') subboard++;
X
X  zeile = 0;
X
X  show(NGROUPS, 99, 99); /* RESET */
X
X  if ((arg[0] == '*') || (arg[0] == '+') || (arg[0] == '#') || (arg[0] == '~')) {
X	sprintf(s, "%s %d) ", MI205_MSG, USER.level);
X	headline(s);
X	i = 0;
X	strcpy(o, (char *) "OOPS");
X
X	while (fscanf(fp, "%s %d %d %s", s, &a, &h, t) > 0) {
X		if (arg[0] == '~') {
X			if (strcomp(NG, s) != 0) continue;
X		}
X		if ((strcomp(o, s) != 0) || (subboard == 0)) {
X			if (subboard != 0) {
X				j = subb(s);
X				if (j != 0) s[j] = '\0';
X				o[0] = '\0'; strcat(o, s);
X			}
X			if (chk_newsgrp(s) == 0) {
X				/*
X				s[18] = '\0';
X				*/
X				s[((80/USER.schluessel[1]) -2)] = '\0';
X				strcat(s, "                                   ");
X				/*
X				s[19] = '\0';
X				*/
X				s[((80/USER.schluessel[1]) -1)] = '\0';
X				printf("%s", s);
X				i++;
X				plus++;
X				if (i == USER.schluessel[1]) {
X					printf("\n");
X					i = 0;				
X					zeile++;
X					if (zeile >= MAX_SCR_LINES) {
X						zeile = 0;
X						if(USER.more != 0){
X							if (more() != 0) return (int) 1;
X						}
X					}
X				}
X			}
X		}
X	}
X	if (plus == 0) {
X		printf("%s", MI206_MSG);
X	}
X	printf("\n");
X  }
X  else {
X	if (org[0] != '\0') {
X
X		SO_WHAT:
X
X		strcpy(o, (char *) org);
X
X		i = 0;
X		while (org[i] != '\0') {
X			t[i] = org[i];
X			if (t[i] == '.') t[i] = '/';
X			i++;
X		}
X		t[i] = '\0';
X
X		sprintf(s, "%s/%s", NEWS, t);
X
X		if (chdir(s) != 0) {
X			sprintf(o, "%s.%s", NG, org);
X			i = 0;
X			while (o[i] != '\0') {
X				t[i] = o[i];
X				if (t[i] == '.') t[i] = '/';
X				i++;
X			}
X			t[i] = '\0';
X			sprintf(s, "%s/%s", NEWS, t);
X		}
X		if (chdir(s) != 0) {
X			this = 9999;
X			maybe_locked(NGROUPS, "r");
X			ff = fopen(NGROUPS, "r");
X			if (ff == NULL) {
X				nerror("misc.c", 1001, "brett", "Datei-Lesefehler", NGROUPS);
X			}
X			while (fscanf(ff, "%s %d %d %s", s, &i, &i, t) > 0) {
X				i = strcomp(org, s);
X				if (i < this) {
X					this = i;
X					strcpy(maybe, s);
X				}
X			}
X			fclose(ff);
X			
X			strcpy(org, maybe);
X			printf("\n\n");
X			ansi("mr");
X			printf("%s \"%s\" [%c, %c] >", MI207_MSG, maybe, GBL06_MSG, GBL07_MSG);
X			ansi("me");
X
X			c = yesno();
X			
X			if (c != GBL07_MSG) goto SO_WHAT;
X
X			printf("\n");
X		}
X		else {
X
X			if (chk_newsgrp(o) == 0) {
X				strcpy(BRETT, s);
X				printf("\n");
X				sprintf(NG, "%s", o);
X				if(length(o) > 14){
X					strcpy(s, o);
X					strcpy(o, shortname(s));
X				}
X#ifdef _NOINDEX
X				printf("\n%s ..", MI211_MSG);
X				switch( (fpid = fork()) ){
X					case -1 :
X						break;
X					case  0 :	while(1){
X								printf(".");
X								sleep(1);
X							}	
X						break;
X				}
X				sprintf(s, "%s %s -x", MB_DAEMON, NG);
X				system( s );
X				sprintf(s, "mv %s/%s/%s %s/inhalt.%d", HOME, LIB, o, TMP, getpid());
X				system( s );
X				sprintf(INHALT, "%s/inhalt.%d", TMP, getpid());
X				kill( fpid, 9 );
X				wait( fpid );
X				printf("\n");				
X#else				
X				sprintf(INHALT, "%s/%s", LIB, o);
X#endif
X			} else {
X				ansi("md");
X				printf(" %s\n", MI210_MSG);
X				ansi("me");
X			}
X		}
X		chdir(HOME);
X	}
X  }
X  fclose(fp);
X  return;
X}
X
END_OF_FILE
  if test 8307 -ne `wc -c <'src/misc2.c'`; then
    echo shar: \"'src/misc2.c'\" unpacked with wrong size!
  fi
  # end of 'src/misc2.c'
fi
if test -f 'src/pd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pd.c'\"
else
  echo shar: Extracting \"'src/pd.c'\" \(15299 characters\)
  sed "s/^X//" >'src/pd.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  pd.c						   */
X/*        FUNKTIONEN  pd(), download(), status(), mkix(), statistik()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  18.03.1992					   */
X/***************************************************************************/
X  
X#include <stdio.h>
X#include <sys/types.h>
X#include <signal.h>
X#include <sys/stat.h>
X#include <time.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  pd()							   */
X/*  BESCHREIBUNG  Eine Datei wird mit o. ohne Protokoll uebertragen.       */
X/*		  Diese Funktion wird von "lesen()" oder "pruefe()"        */
X/*		  aufgerufen, wenn die zu bearbeitende Datei den Kenn-     */
X/*		  zeichner "BINFILE" enthaelt.                             */
X/*     PARAMETER  arg = Dateiname                                          */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid pd(arg, keywds)
Xchar arg[], keywds[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  char s[STRING];
X  char tmp[STRING];
X  char c;
X  char protokoll;
X  char cd[STRING];
X  struct stat fst;
X  long ts, tn;
X
X  int cps, bps, eff;
X  int ok, i;
X
X  strcpy(cd, stripped(arg));
X
X  printf("\n\n");
X  ansi("md");
X  printf("%s\n\n", PD01_MSG);
X  
X  if(keywds[0] != '\0'){
X	printf("%s ", PD02_MSG); 
X	ansi("me");
X	printf("%s\n\n", keywds);
X  }
X  else{
X	 ansi("me");
X  }
X
X  ansi("mr");
X  printf("%c%s [%c, %c, (%c)] >  ", CR, PD03_MSG, GBL06_MSG, GBL07_MSG, PD06_MSG);
X  ansi("me");
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if ((c != GBL06_MSG) && (c != GBL07_MSG) && (c != PD06_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  if (c == PD06_MSG) {	/*  X  */
X	printf("\n");
X	sigcatch(SIGINT);	
X  }
X
X  if (c != GBL06_MSG) {	/*  J  */
X	printf("\n");
X	return;
X  }
X  ansi("mr");
X  printf("%c[%s] %c, %c, %c, %c ? > ", CR, PD07_MSG, PD08_MSG, PD09_MSG, PD10_MSG, PD11_MSG);
X  ansi("me");
X
X
X  do {
X	protokoll = getint();
X	if (protokoll >= 97) protokoll -= 32;
X	if (protokoll == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, PD12_MSG);
X		ansi("me");
X	}
X	if ((protokoll != PD08_MSG) && (protokoll != PD09_MSG) &&
X	    (protokoll != PD10_MSG) && (protokoll != PD11_MSG))
X		protokoll = 0;
X  } while (protokoll == 0);
X
X
X  printf("%c", protokoll);
X
X  signal(SIGINT,  SIG_IGN);
X  signal(SIGHUP,  SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X  printf("\n\n");
X  ansi("md");
X  printf("%s\n\n", PD13_MSG);
X  ansi("me");
X
X  time(&ts);
X
X  switch (protokoll) {
X      case PD08_MSG:
X		sprintf(s, "exec cat %s", cd);
X		break;
X      case PD09_MSG:
X		sprintf(s, "exec %s -b %s 2> /dev/null", SX, cd);
X		break;
X      case PD10_MSG:
X		sprintf(s, "exec %s %s 2> /dev/null", SB, cd);
X		break;
X      case PD11_MSG:
X		sprintf(s, "exec %s %s 2> /dev/null", SZ, cd);
X		break;
X  }
X  system( s );
X
X  time(&tn); tn = tn - ts; 
X
X  stat(cd, &fst);
X  USER.downratio += ((long) fst.st_size / 1024);
X
X  ansi( "md" );
X 
X  if(tn < 1) tn = 1;
X  cps = fst.st_size / tn;
X  bps = cps * 11;
X
X  BAUDRATE = baudrate( bps );
X
X  eff = ((100000 / BAUDRATE) * bps) / 1000;  
X
X  if(bps > BAUDRATE){
X	printf("\n\n%s\n", PD14_MSG);
X	ok = -1;
X  }
X  else{	
X	printf("\n\n%ld %s.\n", fst.st_size, PD15_MSG);
X	ok = 0;
X  }
X
X  ansi( "me" );
X  printf("%s %d cps (ca. %d bps).", PD16_MSG, cps, bps);
X  sprintf(tmp, "%s/%d.pd", TMP, getpid());
X  ff = fopen( tmp, "w" );
X
X
X  if(ok == 0){
X	fprintf(ff, "%s  %c  %-40.40s", mydate( 1 ), protokoll, cd); 
X	if(bps < BAUDRATE){
X		fprintf(ff, "  %6.d  %6.d  %2.d%% OK\n", cps, bps, eff);
X	}
X	else{
X		fprintf(ff, "  %6.d  %6.d  %2.d%% BRK\n", cps, bps, eff);
X	}
X  }
X  else{
X	/*
X	fprintf(ff, "%s  %c  %-40.40s", mydate( 1 ), protokoll, cd); 
X	fprintf(ff, "  %6.6d  %6.6d  %s\n", cps, bps, PD17_MSG);
X	*/
X  }
X
X  i = 0;
X
X  fp = fopen( PDLOG, "r" );
X  if(fp != NULL){
X	while((fgets(s, 80, fp) != NULL) && (i < PRO_ENTRIES)){
X		fputs(s, ff);
X		i++;
X	}
X	fclose(fp);
X  }
X
X  fclose(ff);
X
X  sprintf(cd, "mv %s %s", tmp, PDLOG);
X  system( cd );
X
X  printf("\n");
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  status						   */
X/*  BESCHREIBUNG  Verschiedene (eigentlich fast alle) Eintraege aus den    */
X/*		  Teilnehmerdaten werden angezeigt.                        */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine  					           */
X/***************************************************************************/
X
Xvoid status()
X{
X  char s[STRING];
X  char t[STRING];
X  char ex[255];
X  int a, b;
X  int i;
X
X
X  sprintf(s, " %s %d ) %s ", PD18_MSG, USER.id, USER.name);
X  headline(s);
X  printf("\n");
X
X  ansi("md");
X  printf("%s", PD19_MSG);
X  ansi("me");
X
X  printf("\n");
X
X  sprintf(ex, "%s                                        ", USER.name);
X  ex[27] = '\0';
X  strcat(ex, USER.nick);
X  strcat(ex, "                            ");
X  ex[45] = '\0';
X  strcat(ex, USER.geburtsdatum);
X  strcat(ex, "                            ");
X  ex[62] = '\0';
X  strcat(ex, USER.telefon1);
X  printf("%s\n", ex);
X
X  sprintf(ex, "%s                                        ", USER.strasse);
X  ex[27] = '\0';
X  strcat(ex, USER.sh_name);
X  strcat(ex, "                            ");
X  ex[45] = '\0';
X  strcat(ex, "                            ");
X  ex[62] = '\0';
X  strcat(ex, USER.telefon2);
X  printf("%s\n", ex);
X
X  printf("%s\n\n", USER.wohnort);
X  ansi("md");
X  printf("%s", PD20_MSG);  
X  ansi("me");
X  printf("\n");
X
X  s[0] = '\0'; strcat(s, datereconv( LASTLOG ));
X  strcat(s, "-"); strcat(s, timereconv( LASTTIME ));
X  s[16] = '\0';
X
X  sprintf(ex, "       %1d       %1d  %5d     %1d       %1d     %1d      %1d  %6d  %s",
X	USER.terminal, USER.editor, USER.level, USER.bell, USER.prompt, USER.more, USER.intro, USER.seq, s);
X  printf("%s\n\n", ex);
X
X  ansi("md");
X  printf("%s", PD21_MSG);  
X  ansi("me");
X  sprintf(ex, "\n%06.6d                      %06.6d                    %06.6d",
X	(USER.elapsed / 60), USER.upratio, USER.downratio);
X  printf("%s\n\n", ex);
X
X  ansi("md");
X  printf("%s", PD22_MSG);
X  ansi("me");
X
X  i = 0;
X  strcpy(s, (char *) USER.name);
X  while (s[i] != '\0') {
X	if (s[i] == ' ') s[i] = '.';
X	i++;
X  }
X
X  sprintf(t,  "%s: %s@%s", PD23_MSG, s, UUCPID);
X  strcpy(s, USER.account); s[10] = '\0';
X  sprintf(ex, "%-54.54s%s\n%s: %s%s", t, s, PD24_MSG, UUCPBANG, USER.nick);
X  printf("\n%s\n", ex);
X  if (USER.sh_name[0] != '\0')
X	printf("%s: %s!%s\n", PD25_MSG, UUCPSITE, USER.sh_name);
X
X  printf("\n");
X
X  ansi("md");
X  printf("%s\n", PD26_MSG);
X
X  ansi("me");
X
X  i = 1;
X  while(newsgrp[i][0] != '\0'){
X	if(i != 1) printf(", ");
X	printf("%s", newsgrp[i]);
X	i++;
X  }
X
X  printf("\n\n");  
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mkix()						   */
X/*  BESCHREIBUNG  Wandelt eine Datei ins UNIX-Format (CRs werden entfernt) */
X/*     PARAMETER  s  =  Dateiname                                          */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid mkix( pfad )
Xchar pfad[];
X{
X  FILE *fp; 
X  FILE *ff;
X
X  char s[255];
X  char p[255];
X
X  int i, ok = 0;
X
X  
X  sprintf(p, "%sabc", pfad);
X
X  fp = fopen( pfad, "r" );
X  if(fp == NULL){
X	return;
X  }  	
X
X  ff = fopen( p, "w" );
X  if(ff == NULL){
X	nerror("pd.c", 243, "mkix", "Datei-Erstellungsfehler", p);	
X  }
X
X  while((ok == 0) && (fgets(s, 254, fp) != NULL)){
X	i = 0;
X	while(s[i] != '\0'){
X		if(s[i] == CTRL_Z){
X			ok++;
X			break;
X		}
X		i++;
X	}
X	if(ok == 0){
X		i = strlen(s) -2;
X		if(s[i] == CR){
X			s[i]    = LF;
X			s[i +1] = '\0';
X		}
X		fputs(s, ff);
X	}
X  }
X  fclose(fp);
X  fclose(ff);
X
X  unlink(pfad);
X  rename(p, pfad);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  statitik()						   */
X/*  BESCHREIBUNG  Anrufer-Protokoll auswerten 				   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid statistik()
X{
X  FILE *fp;
X
X  struct tm *tp;
X  time_t tt;
X
X  char s[STRING];
X  char od[MAX_TAGE][STRING];
X  char t[STRING];
X  char r[STRING];
X
X  int v18u[MAX_TAGE];
X  int n18u[MAX_TAGE];
X  int v18g = 0;
X  int n18g = 0;
X
X  int zeit = 0;
X  int tage = 0;
X  int max  = 0;
X
X  int i, a;
X  int toggle = 0;
X  int sun;
X
X  fp = fopen( CALLS, "r" );
X  if(fp == NULL){
X	nerror("pd.c", 288, "statistik", "Datei-Lesefehler", CALLS);		
X  }
X
X  od[0][0] = '\0';
X
X  headline( PD27_MSG );
X  printf("%s\n", PD28_MSG);
X  printf("===============================================================================\n");
X
X  while((fgets(s, (STRING *2), fp) != NULL) && (tage < (MAX_SCR_LINES -7))){
X	strcpy(t, (char *) strcopy(s, 64, 71));
X
X	if(strcomp(t, od[tage]) != 0){
X		if(tage != 0){
X			if((v18u[tage] + n18u[tage]) > max){
X				max = v18u[tage] + n18u[tage];
X			}
X			v18g += v18u[tage];
X			n18g += n18u[tage];
X		}
X		tage++;
X		od[tage][0] = '\0'; strcat(od[tage], t);
X		v18u[tage] = 0;
X		n18u[tage] = 0;
X        }
X	zeit = atoi(strcopy(s, 74, 75));
X	if((zeit >   6) && (zeit < 18)) v18u[tage]++;
X	if((zeit >= 18) || (zeit <= 6)) n18u[tage]++;
X  }
X
X  sprintf(s, "%s", "ooooooooooooooooooooooooooooooooooooooooooooooooooooo");
X
X  time(&tt);
X  tp = localtime(&tt);
X  sun = tp->tm_wday;
X
X  for(i = 1; i < tage; i++){
X	sprintf(t, "%s", s);
X	a = (290 / max * (v18u[i] + n18u[i])) / 10;
X	t[a] = '\0';	
X	strcpy(r, "    ");	
X	if(sun == 0){
X		strcpy(r, PD29_MSG);
X		toggle++;	
X		ansi( "md" );
X	}
X	if(sun == 6) 
X		strcpy(r, PD30_MSG);
X	sun--;
X	if(sun == -1) sun = 6;
X
X	printf("%s %s %4.d        %5.d         %5.d      %s\n",
X                od[i], r, v18u[i], n18u[i], v18u[i]+n18u[i], t);
X	if(toggle != 0) ansi( "me" );
X	toggle = 0;
X  }
X
X  printf("-------------------------------------------------------------------------------\n");
X  printf("%s %5.d        %5.d         %5.d      %s\n",
X	  PD31_MSG, v18g, n18g, v18g+n18g, PD32_MSG);
X  printf("===============================================================================\n");
X
X  printf("\n%s %d %s.\n", PD33_MSG, (tage -1), PD34_MSG);   
X
X  fclose(fp);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  download()						   */
X/*  BESCHREIBUNG  Text- und Binaerartikel uebertragen			   */
X/*     PARAMETER  arg = artikel[-artikel]                                  */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
X#define MAX_DL_FILES 20
X
Xvoid download( arg )
Xchar arg[];
X{
X  int i, k, l, m;
X  int von, bis;
X  int ALLE;
X  int protokoll, ok;
X  int cps, bps, eff;
X
X  long ts, tn;
X  long bytes_total = 0L;
X
X  struct stat fst;
X
X  char s[STRING];
X  char cd[LONGSTRING];
X  char t[(LONGSTRING+STRING)];
X  char tmp[STRING];
X
X  char files[MAX_DL_FILES][STRING];
X  int mdlp = 1;
X
X  int art[MAX_PER_NG];
X  int artp = 0;
X
X
X  FILE *fp, *ff;
X
X  
X  tmp[0] = '\0';
X
X  i = 0;
X  k = -1;
X  l = -1;
X  m = -1;
X
X  while (arg[i] != '\0') {
X	if (arg[i] == '-') k = i;
X	if (arg[i] == '*') l = i;
X	if ((arg[i] > 48) && (arg[i] < 58) && (m == -1)) m = i;
X	i++;
X  }
X
X  von = 1;
X  bis = 32000;
X
X  if ((m == -1) && (l == -1) && (k == -1)) {
X	return;
X  }
X
X  if ((m != -1) && (l == -1) && (k == -1)) {
X	strcpy(s, (char *) strcopy(arg, m, length(arg)));
X	von = atoi(s);
X	bis = von;
X  }
X  if (k != -1) {
X	strcpy(s, (char *) strcopy(arg, 0, (k - 1)));
X	von = atoi(s);
X	strcpy(s, (char *) strcopy(arg, (k + 1), length(arg)));
X	bis = atoi(s);
X
X	if (von == 0) von = 1;
X	if (bis == 0) bis = 32000;
X  }
X  
X  if(von > bis){
X	i = bis;
X	bis = von;
X	von = i;
X  }
X
X  maybe_locked(INHALT, "r");
X  fp = fopen(INHALT, "r");
X  if (fp == NULL) {
X	nerror("pd.c", 504, "download", "Datei-Lesefehler", INHALT);
X  }
X  while (fgets(cd, 250, fp) != NULL){
X	i = atoi(cd);
X	if((i >= von) && (i <= bis)){
X		art[artp] = i;
X		artp++;
X		if(artp > MAX_PER_NG){
X			printf("SHIT!!!");
X			exit(0);
X		}		
X	}
X  }
X  fclose(fp);
X
X
X  printf("\n\n");
X
X  ansi("mr");
X  printf("%c[%s] %c, %c, %c, %c ? > ", CR, PD07_MSG, PD08_MSG, PD09_MSG, PD10_MSG, PD11_MSG);
X  ansi("me");
X
X
X  do {
X	protokoll = getint();
X	if (protokoll >= 97) protokoll -= 32;
X	if (protokoll == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, PD12_MSG);
X		ansi("me");
X	}
X	if ((protokoll != PD08_MSG) && (protokoll != PD09_MSG) &&
X	    (protokoll != PD10_MSG) && (protokoll != PD11_MSG))
X		protokoll = 0;
X  } while (protokoll == 0);
X
X
X  printf("%c", protokoll);
X
X  if (strcomp(BRETT, "PM") != 0) {
X	       sprintf(s, "%s", BRETT); 
X  }
X  else {
X	sprintf(s, "%s/usr/%d", HOME, USER.id);
X  }
X  chdir( s );
X
X  cd[0] = '\0';
X  printf("\n\n%s .", PD36_MSG);
X  
X  for( i = 0; i < artp; i++){  
X
X	sprintf(s, "%d", art[i]); 
X	
X	fp = fopen(s, "r");
X	if(fp != 0){
X		printf(".");
X
X		while ((fgets(t, 250, fp) != NULL) && (t[0] > 32));
X		while ((fgets(t, 250, fp) != NULL) && (t[0] < 32));
X
X		ok = 0;
X
X		if (strcomp("BINFILE", t) == 0) {
X			fgets(t, 80, fp);
X			strcpy(s, (char *) stripped(t));
X			ok++;
X		}
X		if(((strlen(s) + strlen(cd)) < LONGSTRING) && (mdlp < MAX_DL_FILES)){
X			stat(s, &fst);
X			bytes_total += (long) fst.st_size;
X
X			if(ok != 0){
X				strcpy(files[mdlp], s);
X				mdlp++;				
X				USER.downratio += ((long) fst.st_size / 1024);
X			}
X
X			strcat(cd, s); 
X			strcat(cd, " ");
X			fclose(fp);
X		}
X	}
X  }
X
X  if(cd[0] == '\0'){
X	ansi("md");
X	printf("%c%s\n", CR, PD35_MSG);
X	ansi("me");
X	chdir( HOME );
X	return;
X  }
X
X  signal(SIGINT, SIG_IGN);
X  signal(SIGHUP, SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X  printf("\n\n");
X  ansi("md");
X  printf("%s\n\n", PD13_MSG);
X  ansi("me");
X
X  time(&ts);
X 
X  switch (protokoll) {
X      case PD08_MSG:
X		sprintf(t, "exec cat %s", cd);
X		break;
X      case PD09_MSG:
X		sprintf(t, "exec %s -b %s 2> /dev/null", SX, cd);
X		break;
X      case PD10_MSG:
X		sprintf(t, "exec %s %s 2> /dev/null", SB, cd);
X		break;
X      case PD11_MSG:
X		sprintf(t, "exec %s %s 2> /dev/null", SZ, cd);
X		break;
X  }	
X  system( t );
X
X  time(&tn); tn = tn - ts; 
X
X  chdir( HOME );
X
X  ansi( "md" );
X 
X  if(tn < 1) tn = 1;
X  cps = bytes_total / tn;
X  bps = cps * 11;
X
X  BAUDRATE = baudrate( bps );
X
X  eff = ((100000 / BAUDRATE) * bps) / 1000;
X
X  if(bps > BAUDRATE){
X	printf("\n\n%s\n", PD14_MSG);
X	ok = -1;
X  }
X  else{	
X	printf("\n\n%ld %s.\n", fst.st_size, PD15_MSG);
X	ok = 0;
X  }
X
X  ansi( "me" );
X  printf("%s %d cps (ca. %d bps).", PD16_MSG, cps, bps);  
X
X  
X  if(ok != -1){
X	  
X	sprintf(tmp, "%s/%d.pd", TMP, getpid());
X	ff = fopen( tmp, "w" );
X
X	for(i = 1; i < mdlp; i++){
X		fprintf(ff, "%s  %c  %-40.40s", mydate( 1 ), protokoll, files[i]); 
X		fprintf(ff, "  %6.d  %6.d  %2.d%% DNL\n", cps, bps, eff);		
X	}  
X
X	i = 0;
X
X	fp = fopen( PDLOG, "r" );
X	if(fp != NULL){
X		while((fgets(s, 80, fp) != NULL) && (i < PRO_ENTRIES)){
X			fputs(s, ff);
X			i++;
X		}
X		fclose(fp);
X	}
X
X	fclose(ff);
X
X	sprintf(cd, "mv %s %s", tmp, PDLOG);
X	system( cd );
X  }
X  else{
X	if(ff != 0) fclose(ff);
X	if(tmp[0] != '\0') unlink(tmp);
X  }
X
X  printf("\n\n");
X}
X
X
END_OF_FILE
  if test 15299 -ne `wc -c <'src/pd.c'`; then
    echo shar: \"'src/pd.c'\" unpacked with wrong size!
  fi
  # end of 'src/pd.c'
fi
if test -f 'src/portinfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/portinfo.c'\"
else
  echo shar: Extracting \"'src/portinfo.c'\" \(14509 characters\)
  sed "s/^X//" >'src/portinfo.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  portinfo.c					   */
X/*        FUNKTIONEN  port(), show_level(), userliste(), finger()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  28.03.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <fcntl.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <utmp.h>
X#include <time.h>
X
X#include <string.h>
X
X#include "mbox.h"
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  port()						   */
X/*  BESCHREIBUNG  Anzeigen was die Mbox- und die SH-User z. Zt. anstellen. */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid port(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *pp;
X  int fd;
X  char s[STRING];
X  char t[STRING];
X  char ks[STRING];
X  char ls[STRING];
X  char tmp[STRING];
X  char ex[255];
X  char terms[MAX_TERMINALS][STRING];
X  int termc = 0;
X  int a, b, k, l;
X  struct utmp US;
X  struct tm *tmt;
X  long ltime;
X  
X
X  if(arg[0] != '-'){
X	headline( POR01_MSG );
X  }
X  else printf("\n\n");
X
X  printf("%s\n", POR02_MSG);
X  printf("===============================================================================\n");
X
X  printf("%s ", POR03_MSG);
X
X  maybe_locked(WHO, "r");
X  fp = fopen(WHO, "r");
X  if (fp == NULL) {
X	nerror("portinfo.c", 56, "port", "Datei-Lesefehler", WHO);
X  }
X  while (fgets(s, 80, fp) != NULL) {
X	printf(".");
X	if(s[0] > 32){
X		strcpy(t, (char *) strcopy(s, 6, 80));
X		sprintf(terms[termc], "%s", t);
X		strcat(terms[termc], "          ");
X		terms[termc][56] = '\0';
X		sprintf(t, "%s", (char *) strcopy(s, 40, 49));
X		sprintf(s, "%s/etc/%s.", HOME, (char *) stripped(t));
X		ff = fopen(s, "r");
X		if (ff == NULL) {
X			continue;
X		}
X		fgets(s, 80, ff);
X		s[23] = '\0';
X		fclose(ff);
X		strcat(terms[termc], s);
X		strcat(terms[termc], "\n");
X		termc++;
X	}
X  }
X  fclose(fp);
X
X  sprintf(tmp, "%s/%dps", TMP, getpid());
X  sprintf(s, "ps -a > %s", tmp);
X  system( s );
X
X#ifdef _SYS7
X  maybe_locked(UTMP, "r");
X  fd = open(UTMP, O_RDONLY);
X#else
X  maybe_locked(UTMP_FILE, "r");
X  fd = open(UTMP_FILE, O_RDONLY);
X#endif
X
X  if (fd == -1) {
X
X#ifdef _SYS7
X	nerror("portinfo.c", 83, "port", "Datei-Lesefehler", UTMP);
X#else
X	nerror("portinfo.c", 83, "port", "Datei-Lesefehler", UTMP_FILE);
X#endif
X
X  }
X  while (read(fd, &US, sizeof(US)) == sizeof(US)) {
X
X	printf(".");
X	t[0] = '\0';
X	strcat(t, "[$] -\n");
X
X	if (US.ut_type == USER_PROCESS) {
X		terms[termc][0] = '\0';
X		sprintf(ex, "%.8s [SH-Account]                                                  ",
X			US.ut_user);
X		ex[33] = '\0';
X		strcat(terms[termc], ex);
X
X		sprintf(ex, " %s                ",
X			US.ut_line);
X		ex[11] = '\0';
X		strcat(terms[termc], ex);
X
X		ltime = US.ut_time;
X		tmt = localtime(&ltime);
X		sprintf(ex, "%02.2d:%02.2d   ",
X			tmt->tm_hour, tmt->tm_min);
X		strcat(terms[termc], ex);
X
X		l = atoi(strcopy(US.ut_line, 3, 6));
X
X		pp = fopen(tmp, "r");
X		if (pp == NULL) {
X			nerror("portinfo.c", 113, "port", tmp, "???");
X		}
X		while (fgets(s, 80, pp) != NULL) {
X			k = atoi((char *) strcopy(s, 8, 10));
X			if ((k == l) && (s[17] != '-')) {
X				t[0] = '\0';
X				strcat(t, "[$] ");
X				strcat(t, (char *) strcopy(s, 17, 40));
X				s[0] = '\0';
X				strcat(s, t);
X				t[0] = '\0';
X				strcat(t, (char *) stripped(s));
X				t[27] = '\0';
X				strcat(t, "\n");
X			}
X		}
X		fclose(pp);
X
X		strcat(terms[termc], t);
X		termc++;
X	}
X  }
X  close(fd);
X
X  unlink(tmp);
X
X  printf("%c", CR);
X
X  for (a = 0; a < termc; a++) {
X	for (b = 0; b < termc; b++) {
X		sprintf(ks, "%s", (char *) strcopy(terms[a], 34, 40));
X		sprintf(ls, "%s", (char *) strcopy(terms[b], 34, 40));
X		if((strcomp(ks, ls) == 0) && (a != b)){
X			if (terms[a][53] == '$') terms[a][0] = '*';
X			if (terms[b][53] == '$') terms[b][0] = '*';
X		}
X		sprintf(s, "%d", ks); k = atoi(s);
X		sprintf(s, "%d", ls); l = atoi(s);
X		if (k < l) {
X			s[0] = '\0';
X			strcat(s, terms[a]);
X			terms[a][0] = '\0';
X			strcat(terms[a], terms[b]);
X			terms[b][0] = '\0';
X			strcat(terms[b], s);
X		}
X	}
X  }
X
X
X  for (a = 0; a < termc; a++) {
X	if (terms[a][0] != '*'){
X		if(terms[a][53] != '$') ansi( "md" );
X		printf("%s", terms[a]);
X		if(terms[a][53] != '$') ansi( "me" );
X	}
X  }
X
X  printf("\n");
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  show_level()						   */
X/*  BESCHREIBUNG  Zuweisung der Userlevel anzeigen.			   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid show_level()
X{
X  headline( POR04_MSG );
X  printf("\n");
X
X  printf("%s\n", POR05_MSG);
X  printf("-----------------------------------------\n");
X  printf("%s (%d)\n", POR06_MSG, GUEST_LEV);
X  printf("%s (%d)\n", POR07_MSG, WRITE_IN_LEV);
X  printf("%s (%d)\n", POR08_MSG, MAILOUT_LEV);
X  printf("%s (%d)\n", POR09_MSG, WRITE_EX_LEV);
X  printf("%s (%d)\n", POR10_MSG, WRITE_INTERNAT);
X  printf("%s (%d)\n", POR11_MSG, PD_D_LEV);
X  printf("%s (%d)\n", POR12_MSG, PD_U_LEV);
X  printf("%s (%d)\n", POR13_MSG, EXE_LEV);
X  printf("%s (%d)\n", POR14_MSG, ADMIN_LEV);
X
X  printf("\n%s (%d), %s !\n\n", POR15_MSG, USER.level, USER.name);
X
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  userliste()						   */
X/*  BESCHREIBUNG  Verschieden Formen der Userliste ausgeben.		   */
X/*     PARAMETER  arg  =  ''   =  nur Username und ID                      */
X/*			  '*'  =  Name, letzter Anruf etc.                 */
X/*			  '#'  =  Name, Up- / Downloads			   */
X/*			  '%'  =  Gebuehren-Stand			   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid userliste(arg)
Xchar arg[];
X{
X  FILE *fp;
X  int fd;
X  struct userdaten LOOSER;
X  char s[STRING];
X  char u[(STRING*2)];
X  char tmp[STRING];
X  int i = 0, l;
X  int mode = 0;
X  int totalusr = 0;
X  int totalact = 0;
X  int totalgas = 0;
X
X  char c;
X
X  if (arg[0] == '*') mode = 1;
X  if ((arg[0] == '#') && (USER.level >= ADMIN_LEV)) mode = 2;
X  if ((arg[0] == '%') && (USER.level >= ADMIN_LEV)) mode = 3;
X  if ((arg[0] > 47) && (mode == 0)){
X	finger(arg);
X	return;
X  }
X 
X  headline( POR15aMSG );
X
X  show(UDBASE, 99, 99); /* RESET */
X
X  if (mode == 1) {
X	printf("%s\n", POR16_MSG);	
X	printf("===============================================================================\n");
X	printf("%s", POR17_MSG);
X  }
X  if (mode == 2) {
X	printf("%s\n", POR18_MSG);	
X	printf("===============================================================================\n");
X	printf("%s", POR17_MSG);
X  }
X  if (mode == 3) {
X        printf("%s\n", POR18aMSG);	
X	printf("===============================================================================\n");
X	printf("%s", POR17_MSG);
X  }
X
X  sprintf(tmp, "%s/%d", TMP, getpid());
X  fp = fopen(tmp, "w");
X  if (fp == NULL) {
X	nerror("portinfo.c", 231, "userliste", "Datei-Schreibfehler", tmp);
X  }
X  maybe_locked(UDBASE, "r");
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("admin.c", 254, "userliste", "Datei-Lesefehler", UDBASE);
X  }
X  while (read(fd, &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) {
X	if (mode == 0) {
X		sprintf(u, "%s", LOOSER.name);
X		sprintf(s, " (%d) ", LOOSER.id);		
X		u[26 - strlen(s)] = '\0';
X		strcat(u, s); strcat(u, "                                ");	
X 		u[26] = '\0';
X		fprintf(fp, "%s", u);
X		i++;
X		if (i == 3) {
X			i = 0;
X			fprintf(fp, "\n");
X		}
X	}
X	if (mode == 1) {
X		sprintf(s, "%s", "   ");
X		if ((LOOSER.elapsed / 60) > 2) {
X			if (LOOSER.wohnort[0] < 48) {
X				if (strcomp(GUEST, LOOSER.name) != 0)
X					sprintf(s, "%s", "<?>");
X			}
X		}
X		else {
X			sprintf(s, "%s", "{-}");
X		}
X		fprintf(fp, "%-30.30s  %10s %s%6.6d   %6.6ld\"  %5.5d%10.10s\n",
X			LOOSER.name, LOOSER.lastlog, s, LOOSER.seq, (LOOSER.elapsed / 60), LOOSER.level, LOOSER.sh_name);
X
X	}
X	if (mode == 2) {
X		fprintf(fp, "%-30.30s  %8.8d kB  %10.10d kB %8.8d\"\n",
X			LOOSER.name, LOOSER.upratio, LOOSER.downratio, (LOOSER.elapsed / 60));
X	}
X        if (mode == 3) {
X		if(LOOSER.level >= WRITE_INTERNAT){
X			if(LOOSER.account[0] == '\0') strcpy(LOOSER.account, "00.00.0000");
X			strcpy(s, LOOSER.account);
X			s[10] = '\0';
X			c = ' ';
X			fprintf(fp, "%-30.30s  %5.5d   %c %s\n", 
X				LOOSER.name, LOOSER.id, c, s);
X		}
X        }
X	totalusr++;
X	sprintf(s, "%s", (char *) mydate( 0 )); 
X	if((strcomp(s, LOOSER.lastlog) < 3) && (LOOSER.seq > 10)) totalact++;
X	if(strcomp(GUEST, LOOSER.name) == 0) totalgas = LOOSER.seq;
X  }
X  close(fd);
X
X  fclose(fp);
X
X  if (mode != 0) {
X	printf("%c", CR);
X	sprintf(s, "sort -d -o %s %s", tmp, tmp);
X	system(s);
X	show(tmp, 9999, USER.more + 100);
X	if (mode == 1) {
X		printf("\n%s\n%s", POR19_MSG, POR20_MSG);
X	}
X  }
X  else{
X	show(tmp, 9999, USER.more);
X  }
X  if(mode == 0){
X	printf("\n\n%s %d %s %d %s", POR21_MSG, totalusr, POR22_MSG, totalact, POR23_MSG); 
X	printf("\n%s %d %s", POR24_MSG, totalgas, POR25_MSG);
X  }
X  printf("\n");
X  unlink(tmp);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  finger()						   */
X/*  BESCHREIBUNG  Informationen ueber einen Teilnehmer anzeigen.	   */
X/*     PARAMETER  arg  =  User-Name/User-Id des Teilnehmers                */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid finger(arg)
Xchar arg[];
X{
X  int fd;
X  struct userdaten DUMMY, LOOSER;
X  char s[STRING];
X  char t[STRING];
X  long ll = -1L;
X  size_t dummy = sizeof(DUMMY);
X  char c;
X  char ex[LONGSTRING];
X  int i, ok, a, b;
X  int uid = -1;
X  char name[STRING];
X  char domain[STRING];	  
X
X
X  FILE *fp;
X
X  
X  if ((arg[0] > 47) && (arg[0] < 58)) {
X	uid = atoi(arg);
X  }
X  else{
X	a = 0; b = 0;
X	i = 0;
X	while(arg[i] != '\0'){	
X		if(arg[i] == '!') a = i;
X		if(arg[i] == '@') b = i;
X		i++;
X	}
X	if((a != 0) && (b == 0)){
X		if(a != 0){
X			strcpy(name, (char *) strcopy(arg, (a+1), length(arg)));
X			strcpy(domain, (char *) strcopy(arg, 0, (a-1)));
X		}
X		else{
X			strcpy(name, (char *) strcopy(arg, 0, (b-1)));
X			strcpy(domain, (char *) strcopy(arg, (b+1), length(arg)));
X		}
X		strcpy(t, USER.name);
X		i = 0;
X		while(t[i] != '\0'){
X			if(t[i] == ' ') t[i] = '.';
X			i++;
X		}
X		chdir( "/" );
X		sprintf(s, "%s %s!%s!\"finger %s\" \\| mail %s@%s", UUX, SMARTHOST, domain, name, t, UUCPID);
X		/*
X		printf("\n\n%s\n\n", s);
X		*/
X		system( s );
X		chdir( HOME );
X		printf("\n\n%s \"%s\",\n%s \"%s\" %s.", POR25aMSG, name, POR25bMSG, domain, POR25cMSG);
X		ansi( "md" );
X		printf("\n%s\n", POR26_MSG);
X		ansi( "me" );
X		return;
X	}
X	else{
X		if(b != 0){
X			ansi( "md" );
X			printf(" <- Unzulaessige DOMAIN-Adresse!\n\n");
X			ansi( "me" );
X			return;
X		}
X	}
X  }
X
X  maybe_locked(UDBASE, "r"); lockf(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("admin.c", 324, "aendern", "Datei-Lesefehler", UDBASE);
X  }
X  while (read(fd, &DUMMY, dummy) == dummy) {
X	if (uid == DUMMY.id) {
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	} 
X	else{
X		if ((strcomp(arg, DUMMY.name) == 0) ||
X		    (strcomp(arg, DUMMY.nick) == 0) ||
X		    (strcomp(arg, DUMMY.sh_name) == 0)) {
X			ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X		}
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  read(fd, &LOOSER, sizeof(LOOSER));
X  close(fd);
X  unlockf(UDBASE);
X
X  if (ll == -1L) {
X	ansi( "md" );
X	printf(" <- %s\n\n", POR27_MSG);
X	ansi( "me" );
X	return;
X  }
X
X  sprintf(s, " %s: %s ", POR28_MSG, arg);
X  headline( s );
X
X  ansi( "md" );
X  printf("\n%s ", POR29_MSG);
X  ansi( "me" );
X  printf("%d\n", LOOSER.id);
X
X  ansi( "md" );
X  printf("%s ", POR30_MSG);
X  ansi( "me");
X  printf("%s\n", LOOSER.name);
X
X  if(LOOSER.sh_name[0] != '\0'){
X	ansi( "md" );
X	printf("%s ", POR31_MSG);
X	ansi( "me" );
X	printf("%s\n", LOOSER.sh_name);
X  }
X
X  if(LOOSER.nick[0] != '\0'){
X	ansi( "md" );
X  	printf("%s ", POR32_MSG);
X	ansi( "me" );
X	printf("%s\n", LOOSER.nick);
X  }
X
X  ansi( "md" );
X  printf("%s ", POR33_MSG);
X  ansi( "me" );
X  strcpy(s, LOOSER.name);
X  i = 0;
X  while(s[i] != '\0'){
X	if(s[i] == ' ') s[i] = '.';
X	i++;
X  }
X  if(LOOSER.level >= WRITE_INTERNAT)
X	printf("%s@%s\n", s, UUCPID2);
X  else
X	printf("%s@%s\n", s, UUCPID1);
X
X  printf("\n"); ok = 0;
X
X  if(USER.level >= WRITE_EX_LEV){
X	if(LOOSER.wohnort[0] != '\0'){
X		ok++;
X		ansi( "md" );
X		printf("%s ", POR34_MSG);
X		ansi( "me" );
X		printf("%s\n", LOOSER.wohnort);
X	}
X  }
X
X  if(USER.level >= ADMIN_LEV){
X	if(LOOSER.strasse[0] != '\0'){
X		ok++;
X		ansi( "md" );
X		printf("%s ", POR35_MSG);
X		ansi( "me" );
X		printf("%s\n", LOOSER.strasse);
X	}
X	if(LOOSER.telefon1[0] != '\0'){
X		ok++;
X		ansi( "md" ); 
X		printf("%s ", POR36_MSG);
X		ansi( "me" );
X		printf("%s", LOOSER.telefon1);
X
X		if(LOOSER.telefon2[0] != '\0'){
X			printf(" // %s\n", LOOSER.telefon2);
X		}
X		else{
X			printf("\n");
X		}
X	}
X
X	if(ok != 0) printf("\n"); 
X	ok = 0;
X
X	if(LOOSER.geburtsdatum[0] != '\0'){
X		ok++;
X		ansi( "md" );
X		printf("%s ", POR37_MSG);
X		ansi( "me" );
X		printf("%s\n", LOOSER.geburtsdatum);
X	}
X  }
X
X  if(ok != 0) printf("\n");
X
X  if(USER.level >= WRITE_EX_LEV){
X	ansi( "md" );
X	printf("%s ", POR38_MSG);
X	ansi( "me" );
X	printf("%d\n", LOOSER.seq);
X  	ansi( "md" );
X	printf("%s ", POR39_MSG);
X	ansi( "me" );
X	printf("%s // %s\n", LOOSER.lastlog, (char *) timereconv(LOOSER.lasttime));
X  }
X
X  ansi( "md" );
X  printf("%s ", POR45_MSG);
X  ansi( "me" );
X 
X  b = 0;
X  sprintf(s, "%s/usr/%d/INDEX", HOME, LOOSER.id);  
X	
X  fp = fopen(s, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 291, "intro", "Datei-Lesefehler", s);
X  }
X  while (fgets(ex, 200, fp) != NULL){
X	if(ex[0] < 65) b++;
X  }
X  fclose(fp);
X  printf("%d\n", b-1);
X
X  if(USER.level >= ADMIN_LEV){
X	ansi( "md" );
X	printf("%s ", POR40_MSG);
X	ansi( "me" );
X	printf("%d:%02.2d", (LOOSER.elapsed/3600), (LOOSER.elapsed - (LOOSER.elapsed/3600 * 3600))/360);
X	printf(" %s\n", POR41_MSG);
X        ansi( "md" );
X        printf("%s ", POR41aMSG);
X        ansi( "me" );
X        printf("%s\n", LOOSER.account);
X	ansi( "md" );
X	printf("%s ", POR42_MSG);
X	ansi( "me" );
X	printf("%ld %s\n", LOOSER.upratio, POR43_MSG);
X	ansi( "md" );
X	printf("%s ", POR44_MSG);
X	ansi( "me" );
X	printf("%ld %s\n", LOOSER.downratio, POR43_MSG);
X  }
X
X  printf("\n");
X}
X
END_OF_FILE
  if test 14509 -ne `wc -c <'src/portinfo.c'`; then
    echo shar: \"'src/portinfo.c'\" unpacked with wrong size!
  fi
  # end of 'src/portinfo.c'
fi
echo shar: End of archive 6 \(of 10\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
