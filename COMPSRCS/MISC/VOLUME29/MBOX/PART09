Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i071:  mbox - A Bulletin Board System for UNIX and MINIX, Part09/10
Message-ID: <1992Apr5.183726.150@sparky.imd.sterling.com>
X-Md4-Signature: c2b851dfcccf8a015734298fef61e3a6
Date: Sun, 5 Apr 1992 18:37:26 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 71
Archive-name: mbox/part09
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Installation etc/alias.sh etc/english.befehl
#   etc/english.shorth etc/help.befehle etc/help.shorthelp
#   src/CROSSREF src/SysV.getch.c src/befehl.c src/control.c
#   src/ctrlx.c src/defs.h src/derror.c src/help.c src/makro.c
#   src/nerror.c src/suchen.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:47 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 10)."'
if test -f 'Installation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Installation'\"
else
  echo shar: Extracting \"'Installation'\" \(4213 characters\)
  sed "s/^X//" >'Installation' <<'END_OF_FILE'
X
X
X
X
X
X
X
X			
X
X		         ix/MBox  R E A D M E
X		  Mailbox-Programm fuer UNIX(-Derivate)
X			
X			   Volker Schuermann
X		      Wuppertal, FRG, 07.12.1991
X
X
X
X
X
X
X
X
X
X
XFolgendes wird jetzt als bereits geschehen (!) vorausgesetzt:
X
X1. Wir befinden uns im zukuenftigen "Mailbox-HOME"-Verzeichnis (~HOME)
X
X2. Wir haben "root.root"-Permissions (sprich sind als "root" aktiv)
X
X3. Wir haben das Archiv "mbox.tar.Z" komplett ausgepackt und in etwa
X   diese Verzeichnisse/Dateien erhalten:
X
X   ./TUTORIAL
X   ./README
X
X   ./src/*.c
X   ./src/*.h
X   ./src/Makefile
X   ./src/CROSSREF
X
X   ./etc/active
X   .  
X   .  
X   .
X   ./etc/users.data
X
X
X   Das heisst "src" und "etc" sind Unterverzeichnisse von (~HOME) und
X   "TUTORIAL" etc. befinden sich in (~HOME). Sollte das nicht der Fall
X   sein, muessen wir diese Stuktur im (~HOME) entweder von Hand
X   herstellen, oder das Archiv "mbox.tar.Z" nochmal an entsprechender
X   Stelle auspacken!
X
X
X
XWir wechseln jetzt ins "./src"-Verzeichnis, um die MBox an ihre neue
XUmgebung anzupassen. Zwei Dateien muessen bearbeitet werden:
X
X1. Das "Makefile", das einige Informationen zum verwendeten Betriebs-
X   system erhalten muss. Es sollte genuegen die entsprechenden 
X   Eintraege durch Entfernen des "#" in der ersten Spalte zu aktivieren
X   bzw. durch Voranstellen eines "#" auszukommentieren.
X
X   Die Variablen OWNER und GROUP muessen auf Werte gesetzt werden, die
X   z.B. denen von "/bin/su" entsprechen - OWNER.GROUP muss Zugriff auf
X   alle NEWS-, MAIL- und UUCP-Dateien/Verzeichnisse haben ... maximale
X   Prioritaet ist also Voraussetzung!
X
X   Wenn SETUID "root" fuer die MBox NICHT gewuenscht wird, haben wir
X   viel, viel Arbeit vor uns. Offiziell MUSS die MBox mit SETUID
X   "root" gefahren werden !
X
X
X
X2. Das Definitions-File "mbox.h", in dem alle system-spezifischen
X   Informationen gespeichert werden. Alle Eintraege, deren Kommentar
X   mit einem ">" beginnt, muessen geprueft bzw. geaendert werden -
X   bei allen anderen ist Vorsicht angebracht!
X
X   Es empfielt sich von "mbox.h" eine Kopie anzufertigen, um bei evtl.
X   Fehlschlaegen das Original zu Rate ziehen zu koennen!
X   
X
X
XJetzt kommen wir zum spannenden Teil der Aktion. Wir starten "make"
Xund hoffen (den ueblichen Zauber lassen wir mal weg, denn Aberglaube
Xist ganz, ganz schlecht - bringt Unglueck :-)
X
XWenn wir nicht allzuviel falsch gemacht haben bei der Anpassung der
Xbeiden Dateien, sollte sich das "Makefile" irgendwann kommentarlos
Xverabschieden und uns mit einem Schwung neuer Programme in $(BIN) 
Xzuruecklassen:
X
X$(BIN)/mbox		die Mailbox 
X$(BIN)/mb-daemon        ein Daemon der INDEX-Dateien aus NEWS bildet
X$(BIN)/xmd              ein Programm das Post an Mailbox-User zustellt
X$(BIN)/bled             ein "anstaendiger" Zeileneditor
X
Xmbrsh                   eine neue SHELL, die von der Mailbox genutzt wird
X
XSollten diese Programme nicht vorhanden sein, geht's zurueck an den Start.
XEntweder haben wir uns einen "Make error" eingefangen (dann muessen wir
Xuns "Makefile" nochmal vornehmen), oder wir haben in "mbox.h" einen dieser
Xklassischen Syntax-Fehler fabriziert ... viel Spass beim Suchen!
X
X
XSo, wenn wir hier angekommen sind, sollten wir uns ein paar Stunden Pause
Xgoennen, denn jetzt kommt Arbeit auf uns zu. Herumexperimentieren wuerde
Xuns nicht weit bringen, wir sollten in aller Ruhe das "TUTORIAL" lesen
Xund versuchen die dort beschrieben Dateien anzupassen ...
X
XTrotzdem duerfen wir uns schonmal auf die Schulter klopfen, die erste
XHuerde ist genommen!
X
XMfG Volker
X
X
X
XNachschlag: Die MINIX-Mailbox kommt mit der Version "rz 2.30" von Chuck
XForsbergs RZ/SZ nicht klar. Auch wenn's uns nicht gefaellt, in diesem
Xspeziellen Fall kommen wir um einen kleinen Patch nicht herum:
X
X1. Wir kopieren "rz.cdiff" nach "/usr/src/commands/zmodem"
X
X2. Wir wechseln ins "/usr/src/commands/zmodem"-Verzeichnis
X
X3. Mit dem Befehl "patch -cf rz.c rz.cdiff" bringen wir den Patch an
X
X4. Um sicher zu gehen kopieren wir wie folgt: "mv rz.c rz.c.old" und
X   "mv rz.c~ rc.c"
X
X5. Ein "make" sorgt dafuer, dass die neue RZ/SZ-Version erstellt wird.
X   Da RB/SB und RX/RX Links auf RZ/SZ sind, muessen diese Protokolle
X   nicht gesondert behandelt werden.
X
XVORSICHT: Das gilt ausschliesslich fuer die Version "rz 2.30" !
END_OF_FILE
  if test 4213 -ne `wc -c <'Installation'`; then
    echo shar: \"'Installation'\" unpacked with wrong size!
  fi
  # end of 'Installation'
fi
if test -f 'etc/alias.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/alias.sh'\"
else
  echo shar: Extracting \"'etc/alias.sh'\" \(829 characters\)
  sed "s/^X//" >'etc/alias.sh' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  A L I A S . S H
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 08.12.1991
X#
X#---------------------------------------------------------------------------
X# Dieses Script fuegt einen Eintrag fuer jeden neuen User der ix/MBox an die
X# Alias-Datei von SMAIL (etc.) an. 
X#
X# Wird UMAIL statt SMAIL verwendet, sollten alle Zeilen dieses Scripts' aus-
X# kommentiert werden.
X#---------------------------------------------------------------------------
X# Parameter:
X#
X# $1  ->  Name des neuen Users im Format "Vorname.Nachname"
X# 
X# Beispiel:
X#
X# echo $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X
Xecho $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X
END_OF_FILE
  if test 829 -ne `wc -c <'etc/alias.sh'`; then
    echo shar: \"'etc/alias.sh'\" unpacked with wrong size!
  fi
  # end of 'etc/alias.sh'
fi
if test -f 'etc/english.befehl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.befehl'\"
else
  echo shar: Extracting \"'etc/english.befehl'\" \(2565 characters\)
  sed "s/^X//" >'etc/english.befehl' <<'END_OF_FILE'
X/***************************************************************************/
X/* Wer diese Datei aendert sollte GENAU wissen was er tut. Die Reihen-     */
X/* folge der Befehle ist NICHT willkuerlich festgelegt worden, sondern     */
X/* entspricht der Vorgabe fuer GEOnet-Befehle und deren Abkuerzungen.      */
X/*									   */
X/* S(schreiben) kommt vor SE(tup) und L(esen) vor LOE(schen) etc. ... wer  */
X/* sich nicht voellig sicher ist, sollte die Datei einfach im Urzustand    */
X/* belassen.								   */
X/*								           */
X/*                 Die Bedeutung der versch. Spalten 			   */
X/* ======================================================================= */
X/* ID            - Nummer des Befehls (siehe "loop()")			   */
X/* Intern        - Benoetigtes Userlevel				   */
X/* Extern        - Bei einigen Befehle wird unterscheiden zwischen intern  */
X/*		   und extern. Z.B. beim Befehl "schreiben" wird diese     */
X/*		   Regelung angewendet, damit User zwar an die lokalen     */
X/*		   Bretter senden duerfen, nicht aber an die externen.     */
X/* Prototyp      - Enthaelt diese Spalte eine '1', wird der Befehl bei der */
X/*		   Befehlsuebersicht angezeigt.				   */
X/* Befehl        - Unter diesem Namen wird der Befehl aufgerufen           */
X/*									   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Ueberschrift EINE Leerzeile einfuegen ! */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X260	0	0	1	Account
X125	9	9	0	Admin
X150	0	0	1	Board
X170	0	0	1	Chat
X200	0	0	1	Dir
X370	0	0	1	Date
X220	1	1	1	Delete
X440	0	0	1	Download
X150	0	0	0	Cd
X400     0       0       1       Direction
X340	1	1	1	Forward
X390 	0	0	1	Games
X180	0	0	1	Goodbye
X180	0	0	0	Quit
X180	0	0	0	Bye
X180	0	0	0	End
X190	0	0	1	Help
X160	0	2	1	Mail
X330     0       0       1       Macro
X140	0	0	1	Message
X240	6	6	1	Minix
X240	6	6	0	Execute
X270	0	0	1	Portinfo
X130	0	0	1	Protocol
X250	0	0	1	PM
X210	0	0	1	Read
X280	0	0	1	Setup
X280	0	0	0	Password
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Address
X310	1	0	1	Signature
X290	0	0	1	State
X410     0       0       1       Statistics
X430     1       1       1       Search
X380	0	0	1	Time
X300	0	0	1	Users
X320	0	0	1	Version        
X230	0	5	1	Write
X270	0	0	0	Who
X420	0	0	0	RING
X195	0	1	0	~PD
X215	0	0	0	Level
X275	9	9	0	Relogin
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X230     0       5       1       Upload
X180     0       0       0       RING
X998	2	2	0	~MAIL_DUMMY
END_OF_FILE
  if test 2565 -ne `wc -c <'etc/english.befehl'`; then
    echo shar: \"'etc/english.befehl'\" unpacked with wrong size!
  fi
  # end of 'etc/english.befehl'
fi
if test -f 'etc/english.shorth' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.shorth'\"
else
  echo shar: Extracting \"'etc/english.shorth'\" \(3470 characters\)
  sed "s/^X//" >'etc/english.shorth' <<'END_OF_FILE'
X?                          reachable commands are shown 
X? *                        all commands are shown
Xcommand ?                  help on "command"
X
X0                          list command-buffers contents
X1-9                        execute one of nine buffered commands 
X
X+                          go to the next board/group with NEW articles
X
X-                          go to the previous board/group with NEW articles
X
XACCOUNT			   establish an account & a maildrop for a new user
X
XBOARD                      list boards with new articles
XBOARD *                    list ALL boards
XBOARD +                    go to the next board
XBOARD -                    go to the previous board
XBOARD !                    display the name of the current board
XBOARD #                    list areas in board
XBOARD ..		   step from one area to the previous one
XBOARD boardname            jump to board "boardname"
X
XCHAT                       multiport chatsystem
X
XDATE			   display current date
X
XDELETE			   delete all your mail
XDELETE article		   delete article no. "article"
XDELETE article-article	   delete from "article" to "article"
X
XDIR                        index new articles
XDIR *                      index ALL articles (of a board)
X
XDIRECTION                  reading direction OLD <> NEW ?
X
XFORWARD                    list stored mails
XFORWARD user               forward a stored mail to "user"
XFORWARD article user       forward "article" to "user"
X
XGAMES			   offer a (list of) game(s)
X
XGOODBYE			   leave the BBS 
X
XHELP                       this shorthelp
XHELP *                     display some pages of helpful descriptions
XHELP command               show information on "command"
X
XMAIL user                  send mail to "user" 
XMAIL host!user             send mail to "user" on system "host"
XMAIL user@host.domain      send mail to "user" on system "host.domain"
X
XMACRO			   display/declare macros
X
XMESSAGE                    show/change "hello" message
X
XMINIX OS-command           execute "OS-command" on MINIX-shell
X
XPORTINFO                   list all terminals, users, activities
X
XPROTOCOL                   protocol of all call(s/ers)
XPROTOCOL *                 protocol (complete)
XPROTOCOL #                 statistics of these calls
XPROTOCOL %                 callers statistics (hitlist)
X
XPM                         move to your maildrop
X
XREAD                       read NEW articles
XREAD *                     real ALL articles (of a board)
XREAD article               show article no. "article"
XREAD article-article       display from "article" to "article"
X
XSETUP                      configure the BBS to your favor
X
XSIGNATURE		   show/change your signature
X
XSTATE                      list your BBS-configuration
X
XSTATISTICS                 table containing NEWS-statistics
XSTATISTICS *               table containing more NEWS-statistics
XSTATISTICS $               UUCP-rates (only if UUCP supports this)
XSTATISTICS #               download-statistics 
XSTATISTICS %               download-statistics (hitlist)
X
XTIME                       local time and your online-time in seconds
X
XUSERS                      show users list
XUSERS *                    show users list (more detailed)
XUSERS #                    users up-/download ratio
X
XVERSION                    print version
XVERSION *                  display compiling definitions
XVERSION #                  the "Hall of Fame"
X
XWRITE                      create a new article and post it 
END_OF_FILE
  if test 3470 -ne `wc -c <'etc/english.shorth'`; then
    echo shar: \"'etc/english.shorth'\" unpacked with wrong size!
  fi
  # end of 'etc/english.shorth'
fi
if test -f 'etc/help.befehle' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.befehle'\"
else
  echo shar: Extracting \"'etc/help.befehle'\" \(2752 characters\)
  sed "s/^X//" >'etc/help.befehle' <<'END_OF_FILE'
X/***************************************************************************/
X/* Wer diese Datei aendert sollte GENAU wissen was er tut. Die Reihen-     */
X/* folge der Befehle ist NICHT willkuerlich festgelegt worden, sondern     */
X/* entspricht der Vorgabe fuer GEOnet-Befehle und deren Abkuerzungen.      */
X/*									   */
X/* S(chreiben) kommt vor SE(tup) und L(esen) vor LOE(schen) etc. ... wer   */
X/* sich nicht voellig sicher ist, sollte die Datei einfach im Urzustand    */
X/* belassen.								   */
X/*								           */
X/*                 Die Bedeutung der versch. Spalten 			   */
X/* ======================================================================= */
X/* ID            - Nummer des Befehls (siehe "loop()")			   */
X/* Intern        - Benoetigtes Userlevel				   */
X/* Extern        - Bei einigen Befehle wird unterscheiden zwischen intern  */
X/*		   und extern. Z.B. beim Befehl "schreiben" wird diese     */
X/*		   Regelung angewendet, damit User zwar an die lokalen     */
X/*		   Bretter senden duerfen, nicht aber an die externen.     */
X/* Prototyp      - Enthaelt diese Spalte eine '1', wird der Befehl bei der */
X/*		   Befehlsuebersicht angezeigt.				   */
X/* Befehl        - Unter diesem Namen wird der Befehl aufgerufen           */
X/*									   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Ueberschrift EINE Leerzeile einfuegen ! */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X130	0	0	1	Anrufer
X140	1	0	1	Ansage
X150	0	0	1	Brett
X160	0	2	1	Brief
X170	0	0	1	Chat
X170	0	0	0	Dialog
X370	0	0	0	Datum
X170	0	0	0	Co
X999	0	0	1	Demo
X440     0       0       1       Download
X210	0	0	1	Lesen
X180	0	0	1	Ende
X180	0	0	0	Quit
X180	0	0	0	Log
X180	0	0	0	Goodbye
X190	0	0	1	Hilfe
X195	0	1	0	~PD
X200	0	0	1	Inhalt
X200	0	0	0	Dir
X205	0	0	0	Id
X215	0	0	0	Level
X220	1	1	1	Loeschen
X230	0	5	1	Schreiben
X330     0       0       1       Makro
X240	6	6	1	Minix
X240	6	6	0	Execute
X270	0	0	1	Portinfo
X270	0	0	0	Who
X270	0	0	0	Wer
X260	0	0	1	Postfach
X260	0	0	0	Antrag
X275	9	9	0	Relogin
X400     0       0       1       Richtung
X280	0	0	1	Setup
X390 	0	0	1	Spiele
X430	1	1	1	Suchen
X280	0	0	0	Passwort
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Anschrift
X290	0	0	1	Status
X410     0       0       1       Statistik
X300	0	0	1	User
X310	1	0	1	Unterschrift
X230     0       5       1       Upload
X320	0	0	1	Version        
X340	1	1	1	Weiterleiten
X380	0	0	0	Zeit
X125	9	9	0	Admin
X130	0	0	0	Protokoll
X250	0	0	1	PM
X150	0	0	0	Cd
X300	0	0	0	Finger
X160	0	2	0	Mail
X180	0	0	0	Quit
X180	0	0	0	Exit
X180	0	0	0	Logout
X420	0	0	0	RING
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X998	7	7	0	~MAIL_DUMMY
END_OF_FILE
  if test 2752 -ne `wc -c <'etc/help.befehle'`; then
    echo shar: \"'etc/help.befehle'\" unpacked with wrong size!
  fi
  # end of 'etc/help.befehle'
fi
if test -f 'etc/help.shorthelp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.shorthelp'\"
else
  echo shar: Extracting \"'etc/help.shorthelp'\" \(4032 characters\)
  sed "s/^X//" >'etc/help.shorthelp' <<'END_OF_FILE'
X?                          Befehlsuebersicht (levelabhaengig)
X? *                        Befehlsuebersicht (alle Befehle)
XBefehl ?                   Informationen zu "Befehl"
X
X0                          Inhalt des Befehlspuffers
X1-9                        Befehl aus dem Puffer abrufen
X
X+                          Wechseln ins naechste Brett mit neuen Artikeln
X
X-                          Wechseln ins vorherige Brett mit neuen Artikeln
X
XANRUFER                    Anruferprotokoll
XANRUFER *                  Anruferprotokoll (komplett)
XANRUFER #                  Statistik der Anrufe
X
XANSAGE                     Mitteilungstext anzeigen/aendern
X
XBRETT                      Bretter mit aktuellen Artikeln anzeigen
XBRETT *                    Alle Bretter anzeigen
XBRETT +                    Wechseln ins naechste Brett
XBRETT -                    Wechseln ins vorherige Brett
XBRETT !                    Aktuellen Brettnamen ausgeben
XBRETT #                    Gruppen (Areas) ausgeben
XBRETT ..		   Innerhalb einer Gruppe ins vorherige Brett wechseln
XBRETT Brettname            Ins Brett "Brettname" wechseln
X
XBRIEF User                 Persoenliche Nachricht an "User" senden
XBRIEF Host!User            Persoenliche Nachricht an "User" auf "Host"
X
XCHAT                       Multiport Chatsystem
X
XDOWNLOAD                   Diese Funktion erlaubt es, Artikel und Programme
X                           unter Protokoll-Kontrollen zu empfangen
X
XENDE			   Mailbox verlassen
XENDE *                     Mailbox verlassen (Scanner nicht aktuallisieren)
X
XHILFE                      Diese Kurzhilfe anzeigen
XHILFE *                    Hilfstexte komplett ausgeben
XHILFE Befehl               Hilfstext zum Befehl "Befehl" zeigen
X
XINHALT                     Index der aktuellen Artikel ausgeben
XINHALT *                   Alle Artikel eines Brettes anzeigen
X
XLESEN                      Neue Artikel listen
XLESEN *                    Alle Artikel listen
XLESEN Artikel              Artikel mit der Nummer "Artikel" ausgeben
XLESEN Artikel-Artikel      Artikel von Nummer "Artikel" bis "Artikel" zeigen
X
XLOESCHEN Artikel           Artikel Nummer "Artikel" loeschen
XLOESCHEN Artikel-Artikel   Loeschen von "Artikel" bis "Artikel"
X
XMAKRO                      Makrovereinbarungen zeigen/aendern
X
XMINIX Shell-Befehl         Externes Kommando "Shell-Befehl" ausfuehren
X
XPM                         Ins persoenliche Verzeichnis wechseln
X
XPORTINFO                   Aktivitaeten der verschiedenen Terminals zeigen
X
XPOSTFACH                   Postfach einrichten
X
XRICHTUNG                   Leserichtung (alt <-> neu) aendern
X
XSCHREIBEN                  Artikel erfassen und speichern
X
XSETUP                      Persoenliche Anpassungen
X
XSPIELE			   Verschiedene Spiele werden aufgelistet/aufgerufen
X
XSTATUS                     Ausgabe der eigenen Anpassungen
X
XSTATISTIK                  Datei-Statistik der versch. Bretter anzeigen
XSTATISTIK *                Statistik komplett ausgeben
XSTATISTIK $                Uebersicht der UUCP-Gebuehren 
XSTATISTIK #                Protokoll der Downloads (PD-Bretter)
XSTATISTIK %                Protokoll der Downloads (HITLISTE)
X
XSUCHEN Muster              Artikel eines Brettes nach "Muster" durchsuchen	
X
XUNTERSCHRIFT               Unterschrift anzeigen/aendern
X
XUPLOAD                     Diese Funktion wird ueber den Befehl SCHREIBEN
X                           automatisch aufgerufen
X
XUSER                       Userliste ausgeben
XUSER *                     Userliste mit erweiteren Informationen
XUSER #                     Userliste mit Up-/Download Verhaeltnis
XUSER Name                  Informationen ueber den Teilnehmern "Name"
X
XVERSION                    Versionsnummer ausgeben
XVERSION *                  Versionsnummer und Definitionen ausgeben
XVERSION #                  Versionsnummer und "Hall of Fame" ausgeben
X
XWEITERLEITEN               Weiterleitbare PMs anzeigen
XWEITERLEITEN User          Weiterleitbare PM an "User" senden
XWEITERLEITEN Artikel User  Artikel Nummer "Artikel" an "User" senden
END_OF_FILE
  if test 4032 -ne `wc -c <'etc/help.shorthelp'`; then
    echo shar: \"'etc/help.shorthelp'\" unpacked with wrong size!
  fi
  # end of 'etc/help.shorthelp'
fi
if test -f 'src/CROSSREF' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/CROSSREF'\"
else
  echo shar: Extracting \"'src/CROSSREF'\" \(2297 characters\)
  sed "s/^X//" >'src/CROSSREF' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  CROSSREF						   */
X/*        FUNKTIONEN  Cross-Referenz-Liste der Funktionen		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.02.1992					   */
X/***************************************************************************/
X
Xadmin()				admin.c
Xansage()			lesen.c
Xansi()		 		tools.c
Xanzeigen()			lesen2.c
Xbaudrate()			baudrate.c
Xbef()				befehl.c
Xbrett()				misc2.c
Xbrief()				mail.c
Xbigcopy()			tools.c
Xcarboncopy()			weiterl.c
Xcheckdomaintype()		lesen.c
Xchk_newsgrp()			misc2.c
Xclearline()			tools.c
Xcontrol()			control.c
Xcrypted()			tools.c
Xctrlx()				ctrlx.c
Xcut_arg()			loop.c
Xcut_bef()			loop.c
Xdateconv()			tools.c
Xdatereconv()			tools.c
Xdownload()			pd.c
Xfetch_receipy()			mail.c
Xfinger()			portinfo.c
Xfixoutput()			main.c
Xgames()				games.c
Xgetch()				getch.c
Xgetint()			getline.c
Xgetline()			getline.c
Xgetsite()			lesen.c
Xheadline()			tools.c
Xhelp()				help.c
Xinhalt2()			lesen2.c
Xinit()				main.c
Xinit_user()			intro.c
Xintro()				intro.c
Xisin()				tools.c
Xlength()			tools.c
Xlesen()				lesen.c
Xlesen2()			lesen2.c
Xloeschen()			misc2.c
Xloeschen2()			lesen2.c
Xlogout()			main.c
Xloop()				loop.c
Xlockf()				tools.c
Xmain()				main.c
Xmaybe_locked()			tools.c
Xmore()				more.c
Xmkix()				pd.c
Xmydate()			tools.c
Xmytime()			tools.c
Xnerror()			nerror.c & derror.c
Xnoctrlx()			ctrlx.c
Xnum_stripped()			tools.c
Xpd()				pd.c
Xperms()				tools.c
Xport()				portinfo.c
Xpostfach()			postfach.c
Xprf()				misc.c
Xpruefe()			misc.c
Xrates()				loop.c
Xrename()			tools.c
Xscanner()			misc.c
Xschreiben()			misc.c
Xsetup()		  		admin.c
Xsetup_get()			admin.c
Xshortname()			shortname.c
Xshow()				show.c
Xshow_level()			portinfo.c
Xsigcatch()			loop.c
Xstatus()			pd.c
Xstatistik()			pd.c
Xstrcomp()			tools.c
Xstrcopy()			tools.c
Xstripped()			tools.c
Xsubb()				misc2.c
Xtimeconv()			tools.c
Xtimereconv()			tools.c
Xtty()		 		tools.c
Xttyna()				tools.c
Xunterschrift()			lesen.c
Xunlockf()			tools.c
Xupcased()			tools.c
Xuser_aendern()			admin.c
Xuser_anzeigen()			admin.c
Xuser_loeschen()			admin.c
Xuserliste()			portinfo.c
Xwait_until_keypressed()		admin.c
Xweiterleiten()			weiterl.c
Xwhoami()			tools.c
Xwhodo()				control.c
Xyesno()				getline.c
END_OF_FILE
  if test 2297 -ne `wc -c <'src/CROSSREF'`; then
    echo shar: \"'src/CROSSREF'\" unpacked with wrong size!
  fi
  # end of 'src/CROSSREF'
fi
if test -f 'src/SysV.getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/SysV.getch.c'\"
else
  echo shar: Extracting \"'src/SysV.getch.c'\" \(1811 characters\)
  sed "s/^X//" >'src/SysV.getch.c' <<'END_OF_FILE'
X/*
X *	%Z% %M%	%I% %D% %Q%
X *
X *	Copyright (C) 1990 by Christian Schlichtherle
X *			      (chriss@attron.ruhr.sub.org)
X *
X *	%M% - C module for getch(S).
X *
X *	"getch" is a DOS and curses(S) like function which reads
X *	a character and returns immediately without waiting for
X *	newline.
X */
X
X#if	!defined(lint) && !defined(library)
Xstatic char	sccsid[] = "%Z% %M% %I% %D% %Q%";
X#endif /* not lint and not library */
X
X#include <stdio.h>    
X#include <sys/ioctl.h>
X#include <termio.h>
X#include <errno.h>
X
X/*
X * getch - Gets a character.
X * This function gets one character and immediately returns
X * without waiting for newline. The character is not echoed.
X * This function can be used best when you want to input only one
X * character within canonical input or if you need this function
X * only very rarely.
X * EOF is returned on errors or if an ignored signal occured.
X */
Xint	getch()
X{
X	static struct termio	told, tnew;
X	static int	set = 0;
X	int	rstat;
X	char	c;
X
X	if (!set) {
X			/* Get old terminal mode. */
X		if (ioctl(0, TCGETA, &told) == -1)
X			return (EOF);
X
X		/*
X		 * Set new terminal mode. Switch off
X		 * canonical input and echoing.
X		 */
X		tnew = told;
X		tnew.c_cc[VMIN] = 1;
X		tnew.c_cc[VTIME] = 0;
X		tnew.c_lflag &= ~(ICANON | ECHO);
X
X			/* Don't execute this part anymore. */
X		set = 1;
X	}
X
X		/* Set new terminal mode. */
X	if (ioctl(0, TCSETA, &tnew) == -1)
X		return (EOF);
X
X		/* Read one character. */
X	rstat = read(0, &c, 1);
X
X		/* Reset old terminal mode.
X		   Don't get disturbed by ignored signals.
X		   unnet!volker: Quite right, but you'll get
X		   Timing-Problems using this Function on
X	           ESIX-Systems.	
X		
X	while (ioctl(0, TCSETA, &told) == -1)
X		if (errno != EINTR)
X			return (EOF);  */
X
X        ioctl(0, TCSETA, &told);
X
X	if (rstat != 1)
X		return (EOF);
X
X	return ((int)c);
X}
X
END_OF_FILE
  if test 1811 -ne `wc -c <'src/SysV.getch.c'`; then
    echo shar: \"'src/SysV.getch.c'\" unpacked with wrong size!
  fi
  # end of 'src/SysV.getch.c'
fi
if test -f 'src/befehl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/befehl.c'\"
else
  echo shar: Extracting \"'src/befehl.c'\" \(1767 characters\)
  sed "s/^X//" >'src/befehl.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  befehl.c						   */
X/*        FUNKTIONEN  bef()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  bef()							   */
X/*  BESCHREIBUNG  Sucht entweder die Befehlsnummer zu einem bekannten      */
X/*		  Befehl, oder zeigt die Befehle als Uebersicht an.        */
X/*		  Dabei wird das Userlevel beruecksichtigt.                */
X/*     PARAMETER  befehl  =  Befehl  =  Befehl, der gesucht werden soll    */
X/*			     '?'     =  Befehle anzeigen (levelabhaengig)  */
X/*		  arg     =  '*'     =  ALLE Befehle anzeigen 	           */
X/*     RUECKGABE  -1  =  Userlevel reicht nicht aus			   */
X/*     		  -9  =  Befehl nicht gefunden				   */
X/*		   n  =  Befehlsnummer (siehe Datei BEFEHLE und loop.c)	   */
X/***************************************************************************/
X
Xint bef(befehl, arg)
Xchar befehl[];
Xchar arg[];
X{
X  int b = 0, i = 0, l;
X
X  l = USER.level;
X
X  if (befehl[0] == '?') {
X
X	if (arg[0] == '*') l = 9999;
X
X	while (BEF[b].id != -1) {
X		if ((BEF[b].prototyp == 1) && (BEF[b].in <= l)) {
X			printf("%-14.14s ", BEF[b].befehl);
X			i++;
X			if (i == 5) {
X				printf("\n");
X				i = 0;
X			}
X		}
X		b++;
X	}
X	printf("\n\n");
X	return 0;
X  }
X  else {
X	while (BEF[b].id != -1) {
X		if (strcomp(befehl, BEF[b].befehl) == 0) {
X			if (BEF[b].in <= USER.level)
X				return BEF[b].id;
X			else
X				return -1;
X		}
X		b++;
X	}
X	return -9;
X  }
X}
END_OF_FILE
  if test 1767 -ne `wc -c <'src/befehl.c'`; then
    echo shar: \"'src/befehl.c'\" unpacked with wrong size!
  fi
  # end of 'src/befehl.c'
fi
if test -f 'src/control.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/control.c'\"
else
  echo shar: Extracting \"'src/control.c'\" \(2590 characters\)
  sed "s/^X//" >'src/control.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  control.c						   */
X/*        FUNKTIONEN  control(), whodo()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  24.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X
X/***************************************************************************/
X/*      FUNKTION  control()						   */
X/*  BESCHREIBUNG  Fuehrt ein "Logbuch" in zwei versch. Dateien/auf zwei    */
X/*		  versch. Geraeten (CONSOLE & CPRN).                       */
X/*     PARAMETER  text  =  Ansage-Text                                     */
X/*		  mode  =  '< 99'  =  Ausgabe auf CONSOLE                  */
X/*		  mode  =  '= 99'  =  Ausgabe auf CPRN                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
XFILE *contfp = NULL;
X
Xvoid control(text, mode)
Xchar text[];
Xint mode;
X{
X  if (mode < 99) {
X
X#ifdef _MINIX
X	if(tty() >= FIRST_EX_TTY){
X#endif
X		contfp = fopen(CONSOLE_REDIRECT, "a");
X		if (contfp == NULL) {
X			printf("\n\n%s [%s]\n\n", CTL01_MSG, CONSOLE_REDIRECT);
X			exit(-1);
X		}
X#ifdef _DATESTAMP
X		fprintf(contfp, "%s %s <%s>  %s\n", mydate(1), mytime(1), ttyna(), text);
X#else
X		fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X#endif
X		fflush(contfp);
X		fclose(contfp);
X#ifdef _MINIX
X	}
X#endif
X
X  }
X  if (mode == 99) {
X	contfp = fopen(CPRN, "a");
X	if (contfp == NULL) {
X		printf("\n\n%s [%s]\n\n", CTL01_MSG, CPRN);
X		exit(-1);
X	}
X	fprintf(contfp, "\n%s  -  %s\n", mydate(1), mytime(1));
X	fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X	fflush(contfp);
X	fclose(contfp);
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  whodo()						   */
X/*  BESCHREIBUNG  Erstellt eine Datei fuer die "portinfo()"-Routine.       */
X/*     PARAMETER  text = Ansage-Text (aktiver Befehl etc.)                 */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid whodo(text)
Xchar text[];
X{
X  FILE *fp;
X  char s[STRING];
X
X  s[0] = '\0'; strcat(s, HOME); strcat(s, "/etc/");
X  strcat(s, (char *) ttyna()); strcat(s, ".");
X
X  fp = fopen(s, "w");
X  if (fp == NULL) {
X	nerror("control.c", 44, "whodo", "Datei-Schreibfehler", s);
X  }
X  fputs(text, fp);
X  fclose(fp);
X}
END_OF_FILE
  if test 2590 -ne `wc -c <'src/control.c'`; then
    echo shar: \"'src/control.c'\" unpacked with wrong size!
  fi
  # end of 'src/control.c'
fi
if test -f 'src/ctrlx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ctrlx.c'\"
else
  echo shar: Extracting \"'src/ctrlx.c'\" \(2077 characters\)
  sed "s/^X//" >'src/ctrlx.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  ctrlx.c						   */
X/*        FUNKTIONEN  ctrlx(), noctrlx()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#ifdef _SYS7	/* UNIX System 7  (MINIX, COHERENT, ...) */
X
X#include  <sgtty.h>
Xstatic struct tchars newtc, oldtc;
X
X#else		/* UNIX System V  (UNIX, XENIX, ESIX, ...) */
X
X#include  <sys/termio.h> 
Xstatic struct termio newtc, oldtc;
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  ctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird auf (int) 24 gesetzt - das ent-	   */
X/*		  spricht einem CTRL-X. Wird nun CTRL-X gedrueckt, loest   */
X/*		  UNIX das Signal SIGABRT aus ...                          */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid ctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCGETC, (struct sgttyb *) &oldtc);
X  newtc = oldtc;
X  newtc.t_quitc = 24;
X  ioctl(0, TIOCSETC, (struct sgttyb *) &newtc);
X
X#else
X
X  ioctl(0, TCGETA, (struct termio *) &oldtc);
X  newtc = oldtc;
X  newtc.c_cc[VQUIT] = 24;
X  ioctl(0, TCSETA, (struct termio *) &newtc);
X
X#endif
X
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  noctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird "restauriert" ...		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid noctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCSETC, (struct sgttyb *) &oldtc);
X
X#else
X
X  ioctl(0, TCSETA, (struct termio *) &oldtc);
X
X#endif
X
X}
END_OF_FILE
  if test 2077 -ne `wc -c <'src/ctrlx.c'`; then
    echo shar: \"'src/ctrlx.c'\" unpacked with wrong size!
  fi
  # end of 'src/ctrlx.c'
fi
if test -f 'src/defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/defs.h'\"
else
  echo shar: Extracting \"'src/defs.h'\" \(3215 characters\)
  sed "s/^X//" >'src/defs.h' <<'END_OF_FILE'
X/***************************************************************************/
X/* Was jetzt folgt, ist fuer Experimente voellig ungeeignet. Jegliche Aen- */
X/* derung bringt ueber kurz oder lang ernste Probleme fuer die Konsistenz  */
X/* der ix/MBox.						 	           */
X/*									   */
X/* Auch wenn Aenderungen (zufaellig) erfolgreich sein sollten, duerfen sie */
X/* nicht an dritte weitergeleitet werden.				   */
X/*									   */
X/* Wer globale Variablen/Strukturen nicht akzeptiert, sollte jetzt auf der */
X/* Stelle diese Datei verlassen !					   */
X/***************************************************************************/
X
X  
X#ifndef EXTERN
X#define EXTERN extern
X#endif
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X#include "proto.h"
X
X#define STRING	     81
X#define LSTRING	     STRING + 4
X#define LONGSTRING  256
X#define BS            8
X#define CR           13
X#define LF           10
X#define TAB           9
X#define BELL          7
X#define DEL         127
X#define CTRL_X	     24
X#define CTRL_Z       26
X#define CTRL_D        4
X#define ESC          27
X
X#if defined( _SYS7) || defined(_SCO)
X#define ENTER        13
X#else
X#define ENTER        10
X#endif
X
X
X#define fix( II )  ( II / 100 )
X#define flt( II )  ( II - (fix( II ) * 100 ))
X
X#define MAKRO_MAX_REK 30
X
X#define DEF_MAX_SCR_LINES 23
X
XEXTERN int MAX_SCR_LINES;
X
XEXTERN int OLDUID;
XEXTERN int OLDGID;
X
XEXTERN char PROMPT[STRING];
XEXTERN char TERMINAL[STRING];
X
XEXTERN char EDDY[STRING];
X
XEXTERN char BRETT[STRING];
XEXTERN char INHALT[STRING];
XEXTERN char NG[STRING];
X
XEXTERN char UGROUPS[STRING];
XEXTERN char MAKRO[STRING];
X
XEXTERN char MYNAME[STRING];
X
XEXTERN long LASTLOG;
XEXTERN int LASTTIME;
X
XEXTERN int IS_BUFFERED;
X
XEXTERN int SHORT_HEADER;
X
XEXTERN long IDX_SIZE;
X
XEXTERN struct userdaten {
X	int id;
X	char name[31];
X	char passwort[11];
X	char sh_name[15];
X	char nick[31];
X	char wohnort[31];
X	char strasse[31];
X	char telefon1[31];
X	char telefon2[31];
X	char geburtsdatum[31];
X        int terminal;
X	int editor;
X	int level;
X        int bell;
X	int prompt;
X	int more;
X	char lastlog[11]; 
X	int seq;
X        int intro;
X	int lasttime;
X 	int lastmode;
X	int leserichtung;
X	int tlines;
X	long upratio;
X	long downratio;
X	long elapsed;
X	char newsgrps[STRING];
X	char schluessel[STRING];
X	char abused[STRING];
X	char account[STRING]; 		
X} USER;
X
X
X
X#define MAX_BEF 70
X
XEXTERN struct bef_struct {
X	int id;
X	int in;
X 	int ex;
X	int prototyp;
X	char befehl[(STRING/2)];
X} BEF[MAX_BEF];
X
X
X#define MAX_MAK 30
X
XEXTERN struct mak_struct {
X	char makname[STRING];
X	char makwert[(STRING * 2)];
X} MAK[MAX_MAK];
X
X
X
X#define MAX_NEWSGRPS 20
X
XEXTERN char newsgrp[MAX_NEWSGRPS][(STRING/3)];
XEXTERN int newsgrpptr;
X
XEXTERN int MAILOUT_LEV;
XEXTERN int ADMIN_LEV;
XEXTERN int WRITE_EX_LEV;
XEXTERN int WRITE_IN_LEV;
XEXTERN int WRITE_INTERNAT;
XEXTERN int PD_D_LEV;
XEXTERN int PD_U_LEV;
XEXTERN int EXE_LEV; 
XEXTERN int GUEST_LEV;
X
XEXTERN char CONSOLE_REDIRECT[STRING];
X
XEXTERN int BB1;
XEXTERN int BB2;
XEXTERN int BB3;
XEXTERN int BB4;
XEXTERN int BB5;
XEXTERN int BB6;
XEXTERN int BB7;
XEXTERN int BB8;
XEXTERN int BB9;
X
XEXTERN char UUCPID[STRING];
X
XEXTERN int BAUDRATE;
X
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X
X
X
X
X
X
X
END_OF_FILE
  if test 3215 -ne `wc -c <'src/defs.h'`; then
    echo shar: \"'src/defs.h'\" unpacked with wrong size!
  fi
  # end of 'src/defs.h'
fi
if test -f 'src/derror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/derror.c'\"
else
  echo shar: Extracting \"'src/derror.c'\" \(1740 characters\)
  sed "s/^X//" >'src/derror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  dummy_nerror.c					   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "defs.h"
X#include "mbox.msg"
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wie die        */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xchar file[];
Xint line;
Xchar function[], descr[], er[];
X{
X  char s[80];
X
X  printf("%c%s %s (%s) - %s \"%s\"\n", CR, DER01_MSG, function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	DER02_MSG, file, line, function, descr, er, DER03_MSG);
X  
X}
X
X
END_OF_FILE
  if test 1740 -ne `wc -c <'src/derror.c'`; then
    echo shar: \"'src/derror.c'\" unpacked with wrong size!
  fi
  # end of 'src/derror.c'
fi
if test -f 'src/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/help.c'\"
else
  echo shar: Extracting \"'src/help.c'\" \(2401 characters\)
  sed "s/^X//" >'src/help.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  help.c						   */
X/*        FUNKTIONEN  help()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  help() 						   */
X/*  BESCHREIBUNG  Der Inhalt der Datei HILFE wird entweder komplett ange-  */
X/*		  zeigt, oder aber in Abhaengigkeit von 'cmd' in Auszuegen */
X/*		  ausgegeben.                                              */
X/*     PARAMETER  cmd  =  '*'      =  HILFE wird komplett ausgegeben       */
X/*                        '='      =  SHORTHELP                            */
X/*		  #Befehl  	   =  HILFE zu "Befehl" wird ausgegeben    */
X/*     RUECKGABE  0  =  Keinen Eintrag gefunden                            */
X/*                n  =  Anzahl der Eintraege				   */
X/***************************************************************************/
X
Xint help(cmd)
Xchar cmd[];
X{
X  FILE *fp;
X  char s[255];
X  int ende = 0, ok = 0, found = 0, toggle = 0, lines = 0;
X
X  show(KURZHILFE, 99, 99); /* RESET */
X  
X  if(cmd[0] == '='){
X	headline( HLP01_MSG );
X	show(KURZHILFE, 9999, USER.more);	
X	return 9999;
X  }
X
X  maybe_locked(HILFE, "r");
X  fp = fopen(HILFE, "r");
X  if (fp == NULL) {
X	nerror("help.c", 14, "help", "Datei-Lesefehler", HILFE);
X  }
X  if (cmd[0] != '#') {
X	ok = 2;
X	found++;
X  }
X  headline( HLP01_MSG );
X  lines = 0;
X
X  while ((fgets(s, 85, fp) != NULL) && !ende) {
X
X	if (USER.more > 0) {
X		if (lines >= MAX_SCR_LINES) {
X			lines = 0;
X			if (more() != 0) return 1;
X		}
X	}
X	if (ok == 2) {
X		if (s[0] != '#') {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle = 0;
X			}
X		}
X		else {
X			printf("\n");
X			lines++;
X			ansi("md");
X			toggle++;
X		}
X	}
X	else {
X		if ((ok == 1) && (s[0] == '#')) {
X			ok = 0;
X			printf("\n");
X			lines++;
X		}
X		if ((ok == 1) && (s[0] != '#')) {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle == 0;
X			}
X		}
X		if ((ok == 0) && (s[0] == '#')) {
X			if (strcomp(cmd, s) == 0) {
X				ok = 1;
X				found++;
X				ansi("md");
X				toggle++;
X			}
X		}
X	}
X  }
X  fclose(fp);
X
X  return found;
X}
END_OF_FILE
  if test 2401 -ne `wc -c <'src/help.c'`; then
    echo shar: \"'src/help.c'\" unpacked with wrong size!
  fi
  # end of 'src/help.c'
fi
if test -f 'src/makro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/makro.c'\"
else
  echo shar: Extracting \"'src/makro.c'\" \(5459 characters\)
  sed "s/^X//" >'src/makro.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  makro.c						   */
X/*        FUNKTIONEN  makro()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
Xvoid get_makros();
X
X/***************************************************************************/
X/*      FUNKTION  makro()						   */
X/*  BESCHREIBUNG  Makros auswerten					   */
X/*     PARAMETER  s  =  Eingabezeile                                       */
X/*     RUECKGABE  Eingabezeile mit Gegenwerten der Makros	           */
X/***************************************************************************/
X
Xchar *makro( s )
Xchar s[];
X{
X  static char t[STRING];
X  char f[STRING];
X  int a = 0, b = 0, i = 0;
X  int m = 0, ok = 0;
X  int subcom = 0;
X
X  t[0] = '\0';
X
X  strcat(s, " ");
X
X  while(s[0] == ' ') *s++;
X
X  while(s[i] != '\0'){
X
X	if(s[i] == ' '){
X		b = i -1;
X		f[0] = '\0';
X		strcat(f, strcopy(s, a, b));
X		a = i +1;
X		ok = 0; 
X		m = 0;
X
X		while(MAK[m].makname[0] != '\0'){
X			if((strcomp(f, MAK[m].makname) == 0) && (strcomp(MAK[m].makname, f) == 0) && (subcom == 0)){
X				ok = 1; 
X				strcat(t, MAK[m].makwert);
X			}
X			m++;
X		}
X		if(ok == 0) strcat(t, stripped(f));
X		strcat(t, " ");
X	
X		subcom++;
X	}
X	i++;
X  }
X  return (char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  set_makros						   */
X/*  BESCHREIBUNG  Die Makro-Datei wird angezeigt und kann geandert werden. */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid set_makros()
X{
X  FILE *ff;
X  char s[STRING];
X  char t[STRING];
X  char tmp[STRING];
X  char c;
X  int b;
X
X
X  printf("\n\n%s\n\n", MAK01_MSG);
X
X  ansi("md");
X  b = 4;
X  while(MAK[b].makname[0] != '\0'){
X	printf("%s%c=%c%s\n", MAK[b].makname, TAB, TAB, MAK[b].makwert);
X	b++;
X  }  
X  printf("\n");  
X  ansi("mr");
X  printf("%c%s [%c, %c] > ", CR, MAK02_MSG, GBL06_MSG, GBL07_MSG);
X  ansi("me");
X
X  c = yesno();
X
X  if (c == GBL06_MSG) {
X	sprintf(t, "%s %s", EDDY, MAKRO);
X	system(t);
X  }
X
X  get_makros();
X
X  printf("\n");
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  get_makros()						   */
X/*  BESCHREIBUNG  Liest die userabhaengigen Makro-Vereinbarungen in die    */
X/*		  Stuktur ein				                   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid get_makros()
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  int b = 0, i = 0;
X
X
X  sprintf(MAK[0].makname, "demo");
X  sprintf(MAK[0].makwert, "?, sl 3, PM, sl 3, i, sl 3, anr, sl 3, dem1");
X  sprintf(MAK[1].makname, "dem1");
X  sprintf(MAK[1].makwert, "b, sl 3, +, +, +, +, +, +, i, sl 3, +, dem2");
X  sprintf(MAK[2].makname, "dem2");
X  sprintf(MAK[2].makwert, "i, sl 3, +, i, sl 3, b, +, i, sl 3, ?, dem3");
X  sprintf(MAK[3].makname, "dem3");
X  sprintf(MAK[3].makwert, "sl 3, v, sl 3, h hilf, sl 3, st, sl 3, pm, i");
X 
X
X  fp = fopen(MAKRO, "r");
X  if (fp == NULL) {
X	MAK[4].makname[0] = '\0';
X	return;
X  }
X
X
X  b = 4;
X
X  while(fgets(s, 80, fp) != NULL){
X
X	MAK[b].makname[0] = '\0';
X	MAK[b].makwert[0] = '\0';
X	
X	i = 0;
X
X	while((s[i] != '=') && (s[i] != '\0')) i++;
X
X	t[0] = '\0'; strcat(t, strcopy(s, 0, (i-1)));
X	strcat(MAK[b].makname, stripped(t));
X
X	t[0] = '\0'; strcat(t, strcopy(s, (i+1), length(s)));
X 	strcat(MAK[b].makwert, stripped(t));
X
X	b++;
X	if (b >= (MAX_MAK -1)) {
X		nerror("makro.c", 108, "get_makro", "MAX_MAK ueberschritten !!", "???");
X	}
X  }
X  MAK[b].makname[0] = '\0';
X
X  fclose(fp);
X
X}
X
X/***************************************************************************/
X/*      FUNKTION  add_makros()						   */
X/*  BESCHREIBUNG  Haengt Makro-Definition aus einer Prompt-Eingabe an die  */
X/*		  Makro-Datei an			                   */
X/*     PARAMETER  s  =  Makro-Definition                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid add_makro( s )
Xchar s[];
X{
X  FILE *fp;
X
X  fp = fopen( MAKRO, "a" );
X  if(fp == NULL){
X	nerror("makro.c", 189, "add_makro", "Datei-Erweiterungsfehler", MAKRO);
X  }
X  fputs((char *) stripped(s), fp);
X  fputs("\n", fp);
X  fclose(fp);
X
X  get_makros();
X
X  printf("\n\n%s\n", MAK03_MSG);
X  
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  makro_definition()					   */
X/*  BESCHREIBUNG  Prueft ob die Prompt-Eingabe eine Makro-Definition ent-  */
X/*		  haelt.    				                   */
X/*     PARAMETER  s  =  Prompt-Eingabe                                     */
X/*     RUECKGABE  0  =  Keine Definition				   */
X/*                1  =  Makro-Definition				   */
X/***************************************************************************/
X
Xint makro_definition( s )
Xchar s[];
X{
X  int i = 0;
X  int ok = 0;
X
X  while(s[i] != '\0'){
X	if(s[i] == '=') ok++;
X	i++;
X  }
X
X  if(ok == 1){
X	add_makro( s );
X  }
X  if(ok > 1){
X	ansi("md");
X	printf(" %s\n", MAK04_MSG);
X	ansi("me");
X  }
X  return ok;
X}
X
END_OF_FILE
  if test 5459 -ne `wc -c <'src/makro.c'`; then
    echo shar: \"'src/makro.c'\" unpacked with wrong size!
  fi
  # end of 'src/makro.c'
fi
if test -f 'src/nerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/nerror.c'\"
else
  echo shar: Extracting \"'src/nerror.c'\" \(1859 characters\)
  sed "s/^X//" >'src/nerror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  nerror.c						   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <setjmp.h>
X
X#include "mbox.h"
X
X
Xextern jmp_buf jmpenv;
X
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wird die       */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xchar file[];
Xint line;
Xchar function[], descr[], er[];
X{
X  char s[80];
X
X  ansi("md");
X  printf("%c%s ", CR, NER01_MSG);
X  ansi("me");
X
X  printf("%s (%s) - %s \"%s\"\n", function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	NER02_MSG, file, line, function, descr, er, NER03_MSG);
X
X  control(s, 99);
X  control(s, 3);
X
X  longjmp(jmpenv, 1);
X}
X
END_OF_FILE
  if test 1859 -ne `wc -c <'src/nerror.c'`; then
    echo shar: \"'src/nerror.c'\" unpacked with wrong size!
  fi
  # end of 'src/nerror.c'
fi
if test -f 'src/suchen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/suchen.c'\"
else
  echo shar: Extracting \"'src/suchen.c'\" \(2335 characters\)
  sed "s/^X//" >'src/suchen.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  suchen.c						   */
X/*        FUNKTIONEN  weiterleiten()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  10.01.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  suchen()						   */
X/*  BESCHREIBUNG  Artikel im aktuellen Brett mit GREP nach muster durch-   */
X/* 		  suchen und entsprechende Artikel anzeigen.		   */
X/*     PARAMETER  muster = Suchbegriff				           */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid suchen( muster )
Xchar muster[];
X{
X  FILE *fp;
X
X  char s[STRING];
X  char t[STRING];
X  char tmp[STRING];
X  char ex[LONGSTRING];
X
X  int fpid;
X  int found = 0;
X  int ok = 0;
X  int i;
X  
X
X  if(muster[0] == '\0'){
X	ansi( "md" );
X	printf("\n\n%s ", SUC01_MSG);
X	ansi( "me" );
X	strcpy(muster, (char *) getline(60, 1, 32, ""));
X	if(muster[0] == '\0'){
X		printf(" <- %s\n", SUC02_MSG);
X		return;
X	}
X  }
X
X  i = 0;
X  while(muster[i] != '\0'){
X	if(muster[i] == '"') muster[i] = ' ';
X	i++;
X  }
X
X  sprintf(s, " %s \"%s\" %s [%s] ", SUC03_MSG, (char *) stripped(muster), SUC04_MSG, NG);
X  headline( s );
X
X  printf("%s .", SUC05_MSG);
X
X  sprintf(tmp, "%s/such.%d", TMP, getpid());
X
X  if(strcomp("PM", BRETT) == 0){
X	sprintf(t, "%s/usr/%d", HOME, USER.id);
X	chdir( t );
X  }
X  else{
X	chdir( BRETT );
X  }
X
X  switch( (fpid = fork()) ){
X		case -1 :
X				break;
X		case  0 :	while(1){
X					printf(".");
X					sleep(3);
X				}	
X				break;
X  }
X
X  sprintf(s, "%s \"%s\" * > %s 2> %s", GREP, (char *) stripped(muster), tmp, CPRN);
X  system( s );
X
X  kill( fpid, 9 );
X  wait( fpid );
X
X  printf("%c", CR);
X
X
X  fp = fopen( tmp, "r" );
X  if(fp == 0){
X	
X  }
X  while((fgets(ex, LONGSTRING, fp) != NULL) && (ok == 0)){
X	if(atoi(ex) != 0){	
X		if(show( (char *) stripped(ex), 9999, USER.more ) == -1) ok++;
X		found++;
X	}
X  }
X  fclose(fp);
X
X  chdir( HOME );
X
X  if(found == 0){
X	printf("%s \"%s\" %s\n", SUC06_MSG, (char *) stripped(muster), SUC07_MSG);
X  }
X
X  unlink( tmp );
X}
END_OF_FILE
  if test 2335 -ne `wc -c <'src/suchen.c'`; then
    echo shar: \"'src/suchen.c'\" unpacked with wrong size!
  fi
  # end of 'src/suchen.c'
fi
echo shar: End of archive 9 \(of 10\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
