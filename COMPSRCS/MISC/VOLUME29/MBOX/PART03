Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i065:  mbox - A Bulletin Board System for UNIX and MINIX, Part03/10
Message-ID: <1992Apr5.183346.29579@sparky.imd.sterling.com>
X-Md4-Signature: 85572a99c2493168ef10d957db9dfeff
Date: Sun, 5 Apr 1992 18:33:46 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 65
Archive-name: mbox/part03
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  etc/mbox.games src/mbox.english src/proto.h src/tools.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:40 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 10)."'
if test -f 'etc/mbox.games' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/mbox.games'\"
else
  echo shar: Extracting \"'etc/mbox.games'\" \(734 characters\)
  sed "s/^X//" >'etc/mbox.games' <<'END_OF_FILE'
X/***************************************************************************/
X/* Diese Datei enthaelt die Liste der verfuegbaren Spiele. Die Struktur    */
X/* ist folgende:							   */
X/*									   */
X/* Name		Pfad zum Spiel						   */
X/* ======================================================================= */
X/* animals   	/usr/bin/animals					   */
X/* ttt		/usr/bin/ttt						   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Liste EINE Leerzeile einfuegen !	   */
X/***************************************************************************/
X
XAnimals	/usr/bin/animals
XDiepbom /usr/games/diepbom
XEmpire	/usr/games/empire
XKiller	/usr/games/killer
XSokoban	/usr/games/sokoban
XRogue	/usr/bin/rogue
XRobots  /usr/games/robots
END_OF_FILE
  if test 734 -ne `wc -c <'etc/mbox.games'`; then
    echo shar: \"'etc/mbox.games'\" unpacked with wrong size!
  fi
  # end of 'etc/mbox.games'
fi
if test -f 'src/mbox.english' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mbox.english'\"
else
  echo shar: Extracting \"'src/mbox.english'\" \(23558 characters\)
  sed "s/^X//" >'src/mbox.english' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  MBOX.MSG "english"				   */
X/*        FUNKTIONEN  Landessprachen-abhaengige Text-Zeilen		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  28.03.1992					   */
X/***************************************************************************/
X
X
X/* ?? SysV.getch.c */
X
X/* admin.c */
X
X#define ADM01_MSG	" Administration (Change User) "
X#define ADM01aMSG	" Administration (Show User) "
X#define ADM02_MSG	"UserID/Username:"
X#define ADM03_MSG	"            User-ID:"
X#define ADM04_MSG	"           Username:"
X#define ADM05_MSG	"           Password:"
X#define ADM06_MSG	"         SH-Account:"
X#define ADM07_MSG	"              Alias:"
X#define ADM08_MSG	"           Hometown:"
X#define ADM09_MSG	"             Street:"
X#define ADM10_MSG	"  Telephone (voice):"
X#define ADM11_MSG	"   Telephone (data):"
X#define ADM12_MSG	"      Date of Birth:"
X#define ADM13_MSG	"           Terminal:"
X#define ADM14_MSG	"             Editor:"
X#define ADM15_MSG	"              Level:"
X#define ADM16_MSG	"               More:"
X#define ADM17_MSG	"               Bell:"
X#define ADM18_MSG	"             Prompt:"
X#define ADM19_MSG	"              Lines:"
X#define ADM20_MSG	"          LastLogin:"
X#define ADM21_MSG	"           LastTime:"
X#define ADM21aMSG	"            Account:"
X#define ADM22_MSG	"             Boards:"
X#define ADM23_MSG	"                SEQ:"
X#define ADM24_MSG	" Administration (Change User) "	
X#define ADM25_MSG	" Administration (Delete User) "
X#define ADM26_MSG	"User-ID"
X#define ADM27_MSG	"Username"
X#define ADM28_MSG	"[DELETE] Really?"
X#define ADM29_MSG	"Which?"
X#define ADM30_MSG	"[ADM] More?"
X#define ADM31_MSG	" Administration (The Revenge of the Sysop) "
X#define ADM32_MSG	"Register User"
X#define ADM33_MSG	"Change User"
X#define ADM34_MSG	"Delete User"
X#define ADM35_MSG	"Show User"
X#define ADM36_MSG	"Show List of Users"
X#define ADM37_MSG	"Back to MBox"
X#define ADM38_MSG	" Administration (Setup) "
X#define ADM39_MSG	"Terminal (ANSI, VT100 etc.)"
X#define ADM40_MSG	"Editor (Textprocessor)"
X#define ADM41_MSG	"Prompt (Id, Board, Rates)"
X#define ADM42_MSG	"Output (Textoutput)"
X#define ADM43_MSG	"Address (Personal Data)"
X#define ADM44_MSG	"Password (To be changed regularly!)"
X#define ADM45_MSG	"Intro (Show State and/or Intro MSG?)"
X#define ADM46_MSG	"Scanner (Date of last login)"
X#define ADM47_MSG	"END (Leave Setup)"
X#define ADM48_MSG	" Administration (Terminal) "
X#define ADM49_MSG	"List-Device"
X#define ADM50_MSG	" Administration (Editor) "
X#define ADM51_MSG	" Administration (Prompt) "
X#define ADM52_MSG	"Time & Signal (BELL)         "
X#define ADM53_MSG	"Time                         "
X#define ADM54_MSG	"Board & Signal (BELL)        "
X#define ADM55_MSG	"Board                        "
X#define ADM56_MSG	"Rates & Signal (BELL)        "
X#define ADM57_MSG	"Rates                        "
X#define ADM58_MSG	" Administration (Textoutput) "
X#define ADM59_MSG	"List continuously (TYPE, CAT)"
X#define ADM60_MSG	"Page (Mark end of page)"
X#define ADM61_MSG	"Page (Don't mark end of page)"
X#define ADM62_MSG	"Reading-Direction (OLD <> NEW)"
X#define ADM63_MSG	"Number of Screen-Lines (State-Line?)"
X#define ADM64_MSG	"Format of Article-\"Header\""
X#define ADM64aMSG	"Boards Survey (Number of Columns)
X#define ADM65_MSG	"Reading-Direction OLD -> NEW"
X#define ADM66_MSG	"Reading-Direction NEW -> OLD"
X#define ADM67_MSG	"Number of Screen-Lines: 24 (State-Line; ProComm etc.)"
X#define ADM68_MSG	"Number of Screen-Lines: 25 (no State-Line)"
X#define ADM69_MSG	"Original Article-\"Header\" (Total)"	
X#define ADM70_MSG	"Short Output (Author, Subject, Date)"
X#define ADM70aMSG	"Output in two-column Format"
X#define ADM70bMSG	"Output in three Columns"
X#define ADM70cMSG	"Output in four Columns"
X#define ADM71_MSG	" Administration (Address) "
X#define ADM72_MSG	"At this point, you are able to change ALL personal data (including your"
X#define ADM73_MSG	"Username). To get permission to send NEWS-Articles and external mails,"
X#define ADM74_MSG	"your name and address have to be specified." 
X#define ADM75_MSG	"If the old entries are still correct, you have to use the <ENTER>-key to"
X#define ADM76_MSG	"leave them uncorrected. Otherwise you may enter the new data."
X#define ADM77_MSG	" Administration (Password) "
X#define ADM78_MSG	"New Password:"
X#define ADM79_MSG	"You have to enter more than four characters!" 
X#define ADM80_MSG	"Again, please:"
X#define ADM81_MSG	"<- not identical!!!"
X#define ADM82_MSG	" Administration (Intro) "
X#define ADM83_MSG	"State & intro message"
X#define ADM84_MSG	"State message"
X#define ADM85_MSG	"Intro message"
X#define ADM86_MSG	"No message"
X#define ADM87_MSG	" Administration (Scanner) "
X#define ADM88_MSG	"Date & time of last login are checked"
X#define ADM89_MSG	"Only date is checked"
X#define ADM90_MSG	"Change date & time"
X#define ADM91_MSG	"Everytime the system was assigned to show \"new\" information, "
X#define ADM92_MSG	"it checks the \"date of your last login\" to find out what is new. This date"
X#define ADM93_MSG	"you may change now. The number of \"new\" articles grows more, if you"
X#define ADM94_MSG	"count back further ..."
X#define ADM95_MSG	"New date:"
X#define ADM96_MSG	"New time:"
X#define ADM97_MSG	"Reorganizing"
X
X
X/* ?? befehl.c */
X
X/* bled.c */
X
X#define BLD01_MSG	"Wrong line."
X#define BLD02_MSG	"Transfer starts. (Cancel with CTRL-X !)"
X#define BLD03_MSG	"Syntax error."
X#define BLD04_MSG	"Commands"
X#define BLD05_MSG	".l [LINE]|[FROM,TO]    list"
X#define BLD06_MSG	".L [LINE]|[FROM,TO]    list (don't show line numbers)"
X#define BLD07_MSG	".i AT                  insert"
X#define BLD08_MSG	".a                     append (stops insert mode)"
X#define BLD09_MSG	".c LINE                correct"
X#define BLD10_MSG	".d [LINE]|[FROM,TO]    delete"	
X#define BLD11_MSG	".u                     upload (ASCII text)"
X#define BLD12_MSG	".q                     quit (don't save)"
X#define BLD13_MSG	".h                     help (long text)"
X#define BLD14_MSG	".                      save & quit"
X#define BLD15_MSG	"LINE, FROM, TO, AT are legal line numbers."
X#define BLD16_MSG	"Statements in [brackets] are optional. If there"
X#define BLD17_MSG	"are no values specified: AT=1, FROM=1, TO=32000."
X#define BLD18_MSG	"Help"
X#define BLD19_MSG	"Break. File NOT saved."
X#define BLD20_MSG	"Command not known."
X#define BLD21_MSG	"Process terminated. File saved."
X#define BLD22_MSG	"No file specified."	
X#define BLD23_MSG	"Wait a while ..."
X#define BLD24_MSG	"File"
X#define BLD25_MSG	"contains non-ASCII characters."
X#define BLD26_MSG	"New file."
X#define BLD27_MSG	"File contains"
X#define BLD28_MSG	"lines"	
X#define BLD29_MSG	"Problems ..."
X#define BLD30_MSG	"That's all ..."
X
X
X/* control.c */
X
X#define CTL01_MSG	"Error in errorhandler!!!"
X
X
X/* ?? coreleft.c */
X
X/* ?? ctrlx.c */
X
X/* derror.c */
X
X#define DER01_MSG	"ERROR:"
X#define DER02_MSG	"Error:"
X#define DER03_MSG	"break"
X
X
X/* games.c */
X
X#define GA01_MSG	" Onlinegames (Some using ANSI Codes) "
X#define GA02_MSG	"[Games] Which?"
X#define GA03_MSG	"<- Ok, don't play!"
X
X
X/* ?? getch.c */
X
X/* ?? getline.c */
X
X/* help.c */
X
X#define HLP01_MSG	" Helpfunctions (For ix/MBox only) "
X
X
X/* intro.c */
X
X#define INT01_MSG	"Organisation:"
X#define INT02_MSG	"BBS-Software:"
X#define INT03_MSG	"Mailbox-Name:"
X#define INT04_MSG	"Choose a terminal:"
X#define INT05_MSG	"1 - ANSI         2 - VT100         3 - VT52         4 - DUMP"
X#define INT06_MSG	"Terminal?"
X#define INT07_MSG	"---  Your process was terminated  ---"
X#define INT08_MSG	"User"
X#define INT09_MSG	"logged in"
X#define INT10_MSG	"Login"
X#define INT11_MSG	"Initializing"
X#define INT12_MSG	"That's your"
X#define INT13_MSG	"call to this BBS, on"
X#define INT14_MSG	"you were in last"
X#define INT15_MSG	"There are"
X#define INT16_MSG	"boards with new articles and your mailbox contains"
X#define INT17_MSG	"mails"
X#define INT18_MSG	"Hey, todays your birthday ... yet noticed?"
X#define INT19_MSG	"So I wish you a \"Happy Birthday\" !!!"
X#define INT20_MSG	"MERRY XMAS, and best of holidays to you!"
X#define INT21_MSG	"May Santa Claus bring the \"right\" presents ..."
X#define INT22_MSG	""
X#define INT23_MSG	""
X#define INT24_MSG	"Puhh ... the year is gone at least ..."
X#define INT25_MSG	"So have a nice new one !!!"
X#define INT26_MSG	"There he is, the"
X#define INT27_MSG	"st caller !!!"
X
X
X/* lesen2.c */
X
X#define LE201_MSG	"Article"
X#define LE202_MSG	"Article:"
X#define LE203_MSG	"<- Can't find that article!"
X#define LE204_MSG	"<- No new articles in here!"
X#define LE205_MSG	"Directory"
X#define LE206_MSG	"Sorry, no new articles ..."
X#define LE207_MSG	"But there are still"
X#define LE208_MSG	"older entries."
X#define LE209_MSG	"And there ain't no older entries, either."
X#define LE210_MSG 	"In this board, there are"
X#define LE211_MSG	"older articles."
X#define LE212_MSG	"In this board, there are no older articles."
X#define LE213_MSG	"<- Can't find that article!"
X#define LE214_MSG	"No corresponding article found ..."
X
X
X/* loop.c */
X
X#define LOP01_MSG	"---  Break  ---"
X#define LOP02_MSG	"---  Your process was terminated  ---"	
X#define LOP03_MSG	"New mail arrived for you ..."
X#define LOP04_MSG	"Cmd:"
X#define LOP05_MSG	" Commandbuffer (1-9) "
X#define LOP06_MSG	"So what?"
X#define LOP07_MSG	"<- No, there couldn't be such stupid users!"
X#define LOP08_MSG	"Commands (At Level"
X#define LOP09_MSG	"Commands (Survey)"
X#define LOP10_MSG	"<- Ridiculous!"
X#define LOP11_MSG	"<- You have to add a command!"
X#define LOP12_MSG	"No help for command"
X#define LOP13_MSG	"available ..."
X#define LOP14_MSG	" Protocol (Calls) "
X#define LOP15_MSG	" Call  User                          Hometown         Terminal  Date      Time"
X#define LOP16_MSG	"No write authorization!"
X#define LOP17_MSG	"Definitions:"
X#define LOP18_MSG	"Date:"
X#define LOP19_MSG	"Time:"	
X#define LOP20_MSG	"Seconds"
X#define LOP21_MSG	"Reading-Directions:"
X#define LOP22_MSG	"New -> Old"
X#define LOP22aMSG	"Old -> New"
X#define LOP23_MSG	" Statistics (NewsSystem) "	
X#define LOP24_MSG	"Date      Time       Boards  Bytes (Bb)     total: Boards  Articles  Bytes (kB)"
X#define LOP25_MSG	" Statistics (UUCP-Rates) "
X#define LOP26_MSG	" Statistics (Download) "
X#define LOP27_MSG	"Date         File                                         CPS     BPS  State"
X#define LOP28_MSG	"[END] Really?"
X#define LOP29_MSG	"Wait"
X#define LOP30_MSG	"<- Remember, you only have level"
X#define LOP31_MSG	"<- Command not known!"
X#define LOP32_MSG	" Statistics (Download/HITLIST) "
X#define LOP33_MSG	"DNLs   Files"
X#define LOP34_MSG	" Statistics (Calls per User) "
X#define LOP35_MSG	"Calls    User"
X
X
X/* mail.c */
X
X#define MAL01_MSG	"You need level"
X#define MAL02_MSG	"to send international mails ..."
X#define MAL03_MSG	"<- No receiver specified!"
X#define MAL04_MSG	"You need level"
X#define MAL05_MSG	"for mailing to external users ..."
X#define MAL06_MSG	"Transmission:"
X#define MAL07_MSG	"<No subject found>"
X#define MAL08_MSG	"Can't find external users address!"
X#define MAL09_MSG	"The user"
X#define MAL10_MSG	"doesn't \"live\" on this host!"
X#define MAL11_MSG	"Mail to"
X#define MAL12_MSG	"W, U, A"
X#define MAL13_MSG	'W'
X#define MAL14_MSG	'U'
X#define MAL15_MSG	'A'
X#define MAL16_MSG	"Write, Upload, reject & Abort"
X#define MAL17_MSG	"[Transfer-Protocol] A, X, Y, Z"
X#define MAL17aMSG	"ASCII (Text), [X-Modem], Y-Modem (Batch), Z-Modem"
X#define MAL18_MSG	'A'
X#define MAL19_MSG	'X'
X#define MAL20_MSG	'Y'
X#define MAL21_MSG	'Z'
X#define MAL22_MSG	"   From:"
X#define MAL23_MSG	"     To:"
X#define MAL23aMSG	"Copy to:"
X#define MAL24_MSG	"Subject:"
X#define MAL25_MSG	"It's not allowed to mail binaries! They will be rejected!"
X#define MAL26_MSG	"Please start transfer now ... cancel with CTRL-X!"
X#define MAL27_MSG	"No mail recieved. Job canceld ..."
X#define MAL28_MSG	"Nothing received!"
X#define MAL28aMSG	"W, A, C"
X#define MAL29_MSG	'W'
X#define MAL30_MSG	'A'
X#define MAL31_MSG	'C'
X#define MAL31aMSG	'E'
X#define MAL32_MSG	"Write & send, Abort, Continue, Edit header"
X#define MAL32aMSG	" Edit Header "
X#define MAL32bMSG	"Receiver"
X#define MAL32cMSG	"unknown!"
X#define MAL33_MSG	"Ok, no mail ..."
X#define MAL34_MSG	"Mail canled!"
X#define MAL35_MSG	"Wait a while ..."
X#define MAL36_MSG	"that's all!"
X#define MAL37_MSG	"sent"
X#define MAL38_MSG	"The current \"hello\" message:"
X#define MAL39_MSG	"[MESSAGE] change?"
X#define MAL40_MSG	"The current signature:"
X#define MAL41_MSG	"[SIGNATURE] change?"
X
X
X/* main.c */
X
X#define MAI01_MSG	"Updating account"
X#define MAI02_MSG	"Connection closed ..."
X#define MAI03_MSG	" Administration (Setup UDBASE) "
X#define MAI04_MSG	"Can't find users DATABASE. Therefore a DATABASE will be established auto-"
X#define MAI05_MSG	"matically. The necessary stuff will be found in 'mbox.h' (have a look there)."
X#define MAI06_MSG	""
X#define MAI07_MSG	"These new DATABASE has to be checked with the command 'admin', or may be" 
X#define MAI08_MSG	"rebuild by deleting the DATABASE - don't forget to change the entries in" 
X#define MAI09_MSG	"'mbox.h' (read the TUTORIAL)."
X#define MAI10_MSG       "The DATABASE is usable now. Please restart \"ix/Mbox\" ..."
X#define MAI11_MSG	"Bye, bye, ..."
X
X
X/* makro.c */
X
X#define MAK01_MSG	"The following macros are declared:"
X#define MAK02_MSG	"[MACROS] Change?"
X#define MAK03_MSG	"Macro declared."
X#define MAK04_MSG	"<- Error in macro declaration!"
X
X
X/* mb-daemon.c */
X
X#define MBD01_MSG	"New articles"
X#define MBD02_MSG	"Yet scanned articles"
X#define MBD03_MSG	"Today there are"
X#define MBD04_MSG	"new borads with"
X#define MBD05_MSG	"kbytes"
X#define MBD06_MSG	"In total"
X#define MBD07_MSG	"groups there are"
X#define MBD08_MSG	"articles with"
X#define MBD09_MSG	"kbytes"
X
X/* ?? mbrsh.c */
X
X/* misc.c */
X
X#define MIS01_MSG	"<- No new boards available."
X#define MIS02_MSG	"is not a NEWSGROUP!"
X#define MIS02aMSG	"Not allowed! (See: \"Followup-To:\")"
X#define MIS03_MSG	"     From:"
X#define MIS04_MSG	"       To:"	
X#define MIS05_MSG	"  Subject:"
X#define MIS06_MSG	" Keywords:"
X#define MIS07_MSG	"  Summary:"
X#define MIS08_MSG	"W, U, A"
X#define MIS09_MSG	'W'
X#define MIS10_MSG	'U'
X#define MIS11_MSG	'A'
X#define MIS12_MSG	"Write, Upload, reject & Abort"
X#define MIS13_MSG	"[Transfer-Protocol] A, [X], Y, Z"
X#define MIS14_MSG	"ASCII (Text), [X-Modem], Y-Modem (Batch), Z-Modem"
X#define MIS15_MSG	'A'
X#define MIS16_MSG 	'X'
X#define MIS17_MSG	'Y'
X#define MIS18_MSG	'Z'
X#define MIS19_MSG	"Please start transfer now ... cancel with CTRL-X!"
X#define MIS20_MSG	"Nothing received, no new article ..."
X#define MIS21_MSG	"Upload hasn't received data!"
X#define MIS22_MSG	"binaryfile"
X#define MIS23_MSG	"textfile"
X#define MIS24_MSG	"bytes of a"
X#define MIS25_MSG	"received"
X#define MIS26_MSG	"The effective transfer-rate was"
X#define MIS27_MSG	"W, A, C"
X#define MIS28_MSG	"W, A"
X#define MIS29_MSG	'W'
X#define MIS30_MSG	'A'
X#define MIS31_MSG	'C'
X#define MIS31aMSG	"E"
X#define MIS32_MSG	"Write & send, Abort, Continue, Edit header"	
X#define MIS33_MSG	"Write & send, Abort, Edit header"
X#define MIS34_MSG	"Writing ..."
X#define MIS35_MSG	"Ok, no new article ..."
X#define MIS36_MSG	"Article rejected!"
X#define MIS37_MSG	"Message to"
X#define MIS38_MSG	"sent"
X#define MIS38aMSG	" Edit Header "
X#define MIS39_MSG	"The new article will be available in 30 seconds."
X#define MIS40_MSG	"<- Options are not allowed ..."
X#define MIS41_MSG	"<- Wrong option  ..."
X#define MIS42_MSG	"Message:"
X#define MIS43_MSG	"Article"
X#define MIS44_MSG	"Message:"
X#define MIS45_MSG	"Personal message"
X#define MIS46_MSG	"A, R, S, D, N, P"
X#define MIS47_MSG	'A'
X#define MIS48_MSG  	'R'
X#define MIS49_MSG	'S'
X#define MIS50_MSG	'D'
X#define MIS51_MSG	'N'
X#define MIS52_MSG	'P'
X#define MIS53_MSG	"Abort, Reply, Show again, Delete, Next one, Previous one"
X#define MIS54_MSG	"[DELETE] really?"
X#define MIS55_MSG	"No more new articles in this board!"
X#define MIS56_MSG	"There are no older articles!"
X#define MIS57_MSG	" Reply in progress (Searching path etc. ...) "
X#define MIS58_MSG	"Wait a while ..."
X#define MIS59_MSG	"[REPLY] A, B"
X#define MIS60_MSG	"Send to Author or Board?"
X#define MIS61_MSG	'A'
X#define MIS62_MSG	'B'
X
X
X
X/* misc2.c */
X
X#define MI201_MSG	"<- Wrong option ..."
X#define MI202_MSG	"<- Not with level"
X#define MI203_MSG	"The index will be available in 30 seconds."
X#define MI204_MSG	"Board (Newsgroup):"
X#define MI205_MSG	" Boards (Level"
X#define MI206_MSG	"No boards with new articles found ..."
X#define MI207_MSG	"Board"	
X#define MI208_MSG	
X#define MI209_MSG	
X#define MI210_MSG	"<- No access "
X#define MI211_MSG	"Building index"
X
X
X/* nerror.c */
X
X#define NER01_MSG	"ERROR:"
X#define NER02_MSG	"Error:"
X#define NER03_MSG	"break"
X
X
X/* pd.c */
X
X#define PD01_MSG	"Can't list this article. It contains an executable program."
X#define PD02_MSG	"Contents:"
X#define PD03_MSG	"[PROGRAM] Transmit?"
X#define PD04_MSG	
X#define PD05_MSG	
X#define PD06_MSG	'Q'
X#define PD07_MSG	"Transfer-Protocol"
X#define PD08_MSG	'A'
X#define PD09_MSG	'X'
X#define PD10_MSG	'Y'
X#define PD11_MSG	'Z'
X#define PD12_MSG	"ASCII (UUE), X-Modem, Y-Modem, Z-Modem"
X#define PD13_MSG	"Please start transfer now ... cancel with CTRL-X !"
X#define PD14_MSG	"Transfer probably (!) interrupted ..."
X#define PD15_MSG	"bytes transmitted"
X#define PD16_MSG	"The effective transfer-rate was"
X#define PD17_MSG	"BREAK"
X#define PD18_MSG	"State (UserID"
X#define PD19_MSG	"Address                    Alias(es)         Date of Birth    Telephone"
X#define PD20_MSG	"Terminal  Editor  Level  Bell  Prompt  More  Intro   Calls  Last Call"
X#define PD21_MSG	"Onlinetime (min. total)     Bytes (kB Upload)         Bytes (kB Download)"
X#define PD22_MSG	"UUCP-Adresse(es)                                      Accounted until"
X#define PD22aMSG	"Accounted until"
X#define PD23_MSG	"Subnet"
X#define PD24_MSG	"Bang"
X#define PD25_MSG	"Local"
X#define PD26_MSG	"Newsgroup(s)"
X#define PD27_MSG	" Statistics (Login) "
X#define PD28_MSG   	"Date         \"Daytime\"  \"Nightshift\"       Total    Diagram"
X#define PD29_MSG	"<Su>"
X#define PD30_MSG	"<Sa>"
X#define PD31_MSG	"Total       "
X#define PD32_MSG	"Diagram"
X#define PD33_MSG	"The line \"Total\" refers to the calls of the last"
X#define PD34_MSG	"days"
X#define PD35_MSG	"Transaktion failed! No such articles located."
X#define PD36_MSG	"Assembling articles. Wait"
X
X
X/* portinfo.c */
X
X#define POR01_MSG	" Portinfo (external/internal) "
X#define POR02_MSG	"User                             Terminal   Login   Process"
X#define POR03_MSG	"Wait a moment"
X#define POR04_MSG	" Level (Survey) "
X#define POR05_MSG	"Option/Description         required level"
X#define POR06_MSG	"Visitor (Guest) ....................."
X#define POR07_MSG	"Write (internal Mail) ..............."
X#define POR08_MSG	"Write (external Mail) ..............."
X#define POR09_MSG	"Write (NEWS Articles) ..............."
X#define POR10_MSG	"Write (international Mail) .........."
X#define POR11_MSG	"Freeware (Download) ................."
X#define POR12_MSG	"Freeware (Upload) ..................."
X#define POR13_MSG	"OS-Shell ............................"
X#define POR14_MSG	"Administration (Postmaster) ........."
X#define POR15_MSG	"And we are on level"
X#define POR15aMSG	" List of Users "
X#define POR16_MSG	"User                            Last Call      Calls   Online   Level   Account"
X#define POR17_MSG	"Wait a while ..."
X#define POR18_MSG	"User                              Upload       Download      Online"
X#define POR19_MSG	"Users with <?> mark should check their accounting-data (something is missing)."
X#define POR20_MSG	"All {-} entries will be deleted at next update."  
X#define POR21_MSG	"Momentary"
X#define POR22_MSG	"users are on this BBS. Thereof"
X#define POR23_MSG	"are regularly active."
X#define POR24_MSG	"And besides"
X#define POR25_MSG	"guests have looked around here."
X#define POR25aMSG	"Informations about the external user"
X#define POR25bMSG	"will be ordered on"
X#define POR25cMSG	"via UUCP
X#define POR26_MSG	"Look for an answers in your mailbox the next days!"
X#define POR27_MSG	"User not known."
X#define POR28_MSG	"Userinformation"
X#define POR29_MSG	"       User-ID:"
X#define POR30_MSG	"      Username:"
X#define POR31_MSG	" Shell-Account:"
X#define POR32_MSG	"         Alias:"
X#define POR33_MSG	"      Internet:"
X#define POR34_MSG	"      Hometown:"
X#define POR35_MSG	"        Street:"
X#define POR36_MSG	"     Telephone:"
X#define POR37_MSG	" Date of Birth:"
X#define POR38_MSG	" Calls (total):"
X#define POR39_MSG	"     Last Call:"
X#define POR40_MSG	"   Time Online:"
X#define POR41_MSG	"hours"
X#define POR41aMSG	" Account until:"
X#define POR42_MSG       "        Upload:"
X#define POR43_MSG	"kByte(s)"
X#define POR44_MSG	"      Download:"
X#define POR45_MSG	"         Mails:"
X
X
X
X/* postfach.c */
X
X#define POS01_MSG	"<- Don't you think that one account is enough ?"
X#define POS02_MSG	
X#define POS03_MSG	"Guest"
X#define POS04_MSG	"User No.1"
X#define POS05_MSG	"User No.2"
X#define POS06_MSG	" Administration (Registration) "
X#define POS07_MSG	"Your personal data will be stored for administrative purpose!"
X#define POS08_MSG	"The sysop can't give any guarantees for the security of your data, because"
X#define POS09_MSG	"this hosts allows shell-accounting, too." 
X#define POS10_MSG	"First name and name (Username=Realname):"
X#define POS11_MSG	"Ok, ok, no account ..."
X#define POS12_MSG	"Checking ... wait a while, please ..."
X#define POS13_MSG	"yet accounted!!!"
X#define POS14_MSG	"                               Password:"
X#define POS15_MSG	"More than four characters!!!"
X#define POS16_MSG	"                  Alias (for UUCP etc.):"
X#define POS17_MSG	"                               Hometown:"
X#define POS18_MSG	"                                 Street:"
X#define POS19_MSG	"                      Telephone (VOICE):"
X#define POS20_MSG	"                       Telephone (DATA):"
X#define POS21_MSG	"                          Date of Birth:"
X#define POS22_MSG	"You now have an account and a maildrop on this host. As soon as your data"
X#define POS23_MSG	"is checked, your \"LEVEL\" will be raised."
X#define POS24_MSG	"New account for"
X#define POS25_MSG	"Reorganizing"	
X
X
X/* show.c */
X
X#define SHO01_MSG
X#define SHO02_MSG
X#define SHO03_MSG
X#define SHO04_MSG	"MORE"
X#define SHO05_MSG	"Show again, Abort, Leave or use \"SPACE\"-bar to continue"
X#define SHO06_MSG	'L'
X#define SHO07_MSG	'X'
X#define SHO08_MSG	'Q'
X#define SHO09_MSG	'A'
X#define SHO10_MSG	'S'
X#define SHO11_MSG	"Repetition ..."
X#define SHO12_MSG	"Page"
X
X
X/* suchen.c */
X
X#define SUC01_MSG	"Searchpattern:"
X#define SUC02_MSG	"Ok, don't search!"
X#define SUC03_MSG	"Searching for"
X#define SUC04_MSG	"in"
X#define SUC05_MSG	"Wait a moment"
X#define SUC06_MSG	"No articles including pattern"	
X#define SUC07_MSG	"found."	
X
X
X/* tools.c */
X
X#define TOL01_MSG	"Sunday"
X#define TOL02_MSG	"Monday"
X#define TOL03_MSG	"Tuesday"
X#define TOL04_MSG	"Wednesday"
X#define TOL05_MSG	"Thursday"
X#define TOL06_MSG	"Friday"
X#define TOL07_MSG	"Saturday"
X#define TOL08_MSG	"Wait a moment"
X
X
X/* weiterl.c */
X
X#define WEI01_MSG	"<- No messages stored."
X#define WEI02_MSG	"Stored message(s):"
X#define WEI03_MSG	"Subject:"
X#define WEI04_MSG	"<- Article not found!"
X
X
X/* xmd.c */
X
X#define XMD01_MSG	"Mail from an \"external\" user"
X#define XMD02_MSG	"---------  Message follows  ---------"
X
X
X/*  G L O B A L  */
X
X#define GBL01_MSG	"Author:"
X
X#define GBL02_MSG	"Date:"
X#define GBL03_MSG	"Subject:"
X
X#define GBL04_MSG	"Username:"
X#define GBL05_MSG	"No.   Subject                     Author                Date      Time   Lines"
X
X#define GBL06_MSG	'Y' 	/* YES !!!!! */
X#define GBL07_MSG	'N'	/* NO !!!!!! */
X
X#define GBL08_MSG	"No.   Subject                     Author                Date      Time   kBytes"
X#define GBL09_MSG	"Password:"
X
X#define GBL10_MSG	"guest"
END_OF_FILE
  if test 23558 -ne `wc -c <'src/mbox.english'`; then
    echo shar: \"'src/mbox.english'\" unpacked with wrong size!
  fi
  # end of 'src/mbox.english'
fi
if test -f 'src/proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/proto.h'\"
else
  echo shar: Extracting \"'src/proto.h'\" \(4294 characters\)
  sed "s/^X//" >'src/proto.h' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  proto.h						   */
X/*        FUNKTIONEN  Prototypen der Funktionen				   */
X/*             AUTOR  Olaf's CPROTO					   */
X/*  LETZTE AENDERUNG  20.02.1992					   */
X/***************************************************************************/
X
X#if defined(__STDC__) || defined(__cplusplus)
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
X/* admin.c */
Xvoid user_aendern P_((void));
Xvoid user_anzeigen P_((void));
Xvoid user_loeschen P_((void));
Xint setup_get P_((int max));
Xvoid wait_until_keypressed P_((void));
Xvoid admin P_((void));
Xvoid setup P_((void));
X
X/* befehl.c */
Xint bef P_((char befehl[], char arg[]));
X
X/* baudrate.c */
Xint baudrate P_((int try));
X
X/* control.c */
Xvoid control P_((char text[], int mode));
Xvoid whodo P_((char text[]));
X
X/* coreleft.c */
Xint coreleft P_((void));
X
X/* ctrlx.c */
Xvoid ctrlx P_((void));
Xvoid noctrlx P_((void));
X
X/* derror.c */
Xvoid nerror P_((char file[], int line, char function[], char descr[], char er[]));
X
X/* games.c */
Xint games P_((void));
X
X/* getch.c */
Xint getch P_((void));
X
X/* getline.c */
Xchar *getline P_((int len, int mode, int bsc, char deftext[]));
Xint getint P_((void));
Xint yesno P_((void));
X
X/* help.c */
Xint help P_((char cmd[]));
X
X/* intro.c */
Xvoid intro P_((void));
Xvoid init_user P_((char info[]));
X
X/* lesen2.c */
Xint anzeigen P_((int art, int von, int bis));
Xvoid lesen2 P_((char arg[], int mode));
Xvoid inhalt2 P_((char arg[], int mode));
Xvoid loeschen2 P_((char arg[], int mode));
X
X/* loop.c */
Xvoid sigcatch P_((int sig));
Xchar *cut_bef P_((char s[]));
Xchar *cut_arg P_((char s[]));
Xchar *rates P_((void));
Xvoid loop P_((void));
X
X/* mail.c */
Xchar *fetch_reciepy P_((char REP[]));
Xchar *getsite P_((char arg[]));
Xint checkdomaintype P_((char arg[]));
Xint brief P_((char arg[]));
Xvoid ansage P_((void));
Xvoid unterschrift P_((void));
X
X/* main.c */
Xvoid logout P_((void));
Xvoid init P_((void));
Xvoid fixoutput P_((void));
X/* int main P_((void)); */
X
X/* makro.c */
Xchar *makro P_((char s[]));
Xvoid set_makros P_((void));
Xvoid get_makros P_((void));
Xvoid add_makro P_((char s[]));
Xint makro_definition P_((char s[]));
X
X/* mb-daemon.c */
Xint reflector P_((char arg[], char msg[]));
Xint pdsize P_((char arg[]));
Xchar *scan P_((char arg[]));
Xvoid mix P_((char s[], char t[]));
Xint main P_((int argc, char *argv[]));
X
X/* mbrsh.c */
Xint main P_((int argc, char *argv[]));
X
X/* misc.c */
Xvoid scanner P_((int mode));
Xvoid schreiben P_((char arg[]));
Xint prf P_((char arg[]));
Xint pruefe P_((char arg[]));
Xvoid lesen P_((char arg[]));
X
X/* misc2.c */
Xint chk_newsgrp P_((char s[]));
Xint subb P_((char s[]));
Xvoid loeschen P_((char arg[]));
Xint brett P_((char arg[]));
X
X/* nerror.c */
Xvoid nerror P_((char file[], int line, char function[], char descr[], char er[]));
X
X/* pd.c */
Xvoid pd P_((char arg[], char keywds[]));
Xvoid status P_((void));
Xvoid mkix P_((char pfad[]));
Xvoid statistik P_((void));
Xvoid download P_((char arg[]));
X
X/* portinfo.c */
Xvoid port P_((char arg[]));
Xvoid show_level P_((void));
Xvoid userliste P_((char arg[]));
Xvoid finger P_((char arg[]));
X
X/* postfach.c */
Xvoid postfach P_((char arg[]));
X
X/* show.c */
Xint show P_((char fname[], int maxlines, int mode));
Xint more P_((void));
X
X/* tools.c */
Xchar *whoami P_((void));
Xchar *stripped P_((char st[]));
Xchar *upcased P_((char st[]));
Xint length P_((char st[]));
Xchar *strcopy P_((char st[], int v, int b));
Xchar *bigcopy P_((char st[], int v, int b));
Xint strcomp P_((char s[], char t[]));
Xint ansi P_((char code[]));
Xchar *mydate P_((int mode));
Xchar *mytime P_((int mode));
Xchar *crypted P_((char s[]));
Xlong dateconv P_((char d[]));
Xchar *datereconv P_((long l));
Xint timeconv P_((char t[]));
Xchar *timereconv P_((int i));
Xchar *shortname P_((char longname[]));
Xint maybe_locked P_((char name[], char mode[]));
Xchar *numstripped P_((char s[]));
Xvoid headline P_((char line[]));
Xvoid lockf P_((char path[]));
Xvoid unlockf P_((char path[]));
Xint tty P_((void));
Xchar *ttyna P_((void));
Xvoid clearline P_((void));
Xint isin P_((char patter[], int c)); 
X
X/* weiterl.c */
Xvoid weiterleiten P_((char arg[]));
X
X/* xmd.c */
Xint brief P_((char arg[]));
Xint mailing P_((void));
Xint main P_((int argc, char *argv[]));
X
X#undef P_
END_OF_FILE
  if test 4294 -ne `wc -c <'src/proto.h'`; then
    echo shar: \"'src/proto.h'\" unpacked with wrong size!
  fi
  # end of 'src/proto.h'
fi
if test -f 'src/tools.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/tools.c'\"
else
  echo shar: Extracting \"'src/tools.c'\" \(22291 characters\)
  sed "s/^X//" >'src/tools.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  tools.c						   */
X/*        FUNKTIONEN  whoami(), tty(), stripped(), upcased(), length(),    */
X/*		      strcopy(), strcomp(), ansi(), mydate(), mytime(),    */
X/*	              crypted(), dateconv(), datereconv(), timeconv(),     */
X/*		      timereconv(), maybe_locked(), num_stripped(),        */
X/*		      rename(), headline(), ttyna(), bigcopy(), lockf(),   */
X/*		      unlockf(), shortname(), clearline(), isin()	   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.03.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X#include <unistd.h>
X#include <time.h>
X#include <pwd.h>
X
X#ifdef _SYS7
X#include <termcap.h>
X#endif
X
X
X#ifdef _MBOX
X#define EXTERN
X#include "mbox.h"
X#else
X#define VERSION "TOOLS.C"
X#define CR 13
X#define TOL01_MSG	"Sonntag"
X#define TOL02_MSG	"Montag"
X#define TOL03_MSG	"Dienstag"
X#define TOL04_MSG	"Mittwoch"
X#define TOL05_MSG	"Donnerstag"
X#define TOL06_MSG	"Freitag"
X#define TOL07_MSG	"Samstag"
X#define TOL08_MSG	"Momentchen"
X#endif
X#ifdef STRING
X#undef STRING
X#endif
X
X#ifdef LONGSTRING
X#undef LONGSTRING
X#endif
X
X#define STRING 81
X#define LONGSTRING 256
X
X
Xvoid unlockf();
Xvoid clearline();
X
Xchar headinfo[STRING];
X
X
X/***************************************************************************/
X/*      FUNKTION  whoami()						   */
X/*  BESCHREIBUNG  Name des eigenen SH-Accounts.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xchar *whoami()
X{
X  struct passwd *pw_entry;
X
X  pw_entry = getpwuid(getuid());
X
X  if (pw_entry->pw_uid < 0) return (char *) "OOPS";
X
X  return (char *) (pw_entry->pw_name);
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  stripped()						   */
X/*  BESCHREIBUNG  STRING von fuehrenden und folgenden Leerzeichen be-      */
X/*		  freien.                                                  */
X/*     PARAMETER  st  =  STRING inclusive Leerzeichen                      */
X/*     RUECKGABE  STRING exclusive Leerzeichen                             */
X/***************************************************************************/
X
Xchar *stripped(st)
Xchar st[];
X{
X  static char s[STRING];
X
X  int i = 0, a = 0, b = 0, c = 0;
X
X  if (st[0] == '\0') return (char *) '\0';
X  if ((st[0] == 10) || (st[0] == 13)) return (char *) " ";
X
X  strcpy(s, st);
X
X  while ((s[i] < 33) && (s[i] != '\0')) i++;
X  a = i;
X  while (s[a] != '\0') a++;
X  a--;
X  while (s[a] < 33) a--;
X
X  for (c = i; c <= a; c++) {
X	s[b] = s[c];
X	b++;
X  }
X  s[b] = '\0';
X
X  return (char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  upcased()						   */
X/*  BESCHREIBUNG  Zeichen eines STRING auf Grossbuchstaben umstellen.	   */
X/*     PARAMETER  st  =  STRING mit Gross-/Kleinbuchstaben		   */
X/*     RUECKGABE  STRING in Grossbuchstaben                                */
X/***************************************************************************/
X
Xchar *upcased(st)
Xchar st[];
X{
X  static char s[STRING];
X
X  int i = 0;
X
X
X  strcpy(s, st);
X
X  while (s[i] != '\0') {
X	if (s[i] > 96) s[i] -= 32;
X	i++;
X  }
X
X  return (char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  length()						   */
X/*  BESCHREIBUNG  Laenge eines STRING ermitteln (ja, ja, "strlen" ...)	   */
X/*     PARAMETER  st  =  STRING                                            */
X/*     RUECKGABE  Laenge des STRING                                        */
X/***************************************************************************/
X
Xint length(st)
Xchar st[];
X{
X  int i = 0;
X
X  while (st[i] != '\0') i++;
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcopy()						   */
X/*  BESCHREIBUNG  Einen TeilSTRING aus einem STRING herausschneiden.       */
X/*     PARAMETER  st  =  STRING                                            */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilSTRING                                               */
X/***************************************************************************/
X
Xchar *strcopy(st, v, b)
Xchar st[];
Xint v, b;
X{
X  static char s[STRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (char *) s;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  bigcopy()						   */
X/*  BESCHREIBUNG  Einen TeilLONGSTRING aus LONGSTRING herausschneiden.     */
X/*     PARAMETER  st  =  LONGSTRING                                        */
X/*		  v   =  von Zeichen (1. Zeichen = 0 !!!)		   */
X/*		  b   =  bis Zeichen				           */
X/*     RUECKGABE  TeilLONGSTRING                                           */
X/***************************************************************************/
X
Xchar *bigcopy(st, v, b)
Xchar st[];
Xint v, b;
X{
X  static char s[LONGSTRING];
X
X  int i = 0, j;
X
X
X  strcpy(s, st);
X
X  if (length(s) < b) b = length(s);
X
X  for (j = v; j <= b; j++) {
X	s[i] = s[j];
X	i++;
X  }
X  s[i] = '\0';
X
X  return (char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  strcomp()						   */
X/*  BESCHREIBUNG  Zwei STRINGs vergleichen. Und zwar genau solange, bis    */
X/*		  bei STRING1 das Ende ('\0') erreicht ist !!!             */
X/*                Gross-/Kleinschreibung wird dabei IGNORIERT !!!          */
X/*     PARAMETER  st  =  STRING1                                           */
X/*	          tt  =  STRING2                                           */
X/*     RUECKGABE  Anzahl der UNGLEICHEN Zeichen                            */
X/***************************************************************************/
X
Xint strcomp(s, t)
Xchar s[], t[];
X{
X  int i = 0, a = 0;
X  int s1, t1;
X
X  while (s[i] != '\0') {
X	s1 = s[i];
X	t1 = t[i];
X	if ((t1 > 96) && (t1 < 123)) t1 -= 32;
X	if ((s1 > 96) && (s1 < 123)) s1 -= 32;
X	if (t1 != s1) a++;
X	i++;
X  }
X  return a;
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ansi()						   */
X/*  BESCHREIBUNG  TERMCAP-Eintrag fuer ein Terminal in "buf" einlesen,     */
X/*		  und angeforderte Sequenzen finden & ausgeben.            */
X/*     PARAMETER  code  =  'INIT'  =  Eintrag holen und speichern	   */
X/*		  	           =  Sequenz finden & ausgeben            */
X/*     RUECKGABE  -1  =  Terminal nicht gefunden                           */
X/*		   1  =  Sequenz nicht gefunden				   */
X/***************************************************************************/
X
Xstatic char buf[1024];
X
Xint ansi(code)
Xchar code[];
X{
X  char *getenv();
X  static char s[STRING];
X  char *p = s;
X  char *term;
X
X#ifdef _MBOX
X  term = TERMINAL;
X#else
X  term = getenv("TERM");
X#endif
X
X  if (strcomp("INIT", code) == 0) {
X	if (tgetent(buf, term) != 1) return -1;
X  }
X  if (tgetstr(code, &p) == 0) return 1;
X
X  printf("%s", s);
X
X  return 0;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mydate()						   */
X/*  BESCHREIBUNG  Tagesdatum liefern.  					   */
X/*     PARAMETER  mode  =  0  =  tt.mm.yyyy				   */
X/*			   1  =  tt.mm.yy				   */
X/*			   2  =  ttt					   */	
X/*     RUECKGABE  Datum                                                    */
X/***************************************************************************/
X
X#define TZS      1
X
Xchar *mydate(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X  char wt[8][11];
X
X  static char s[STRING];
X
X#ifndef _MBOX
X  strcpy(wt[0], "Sonntag");
X  strcpy(wt[1], "Montag");
X  strcpy(wt[2], "Dienstag");
X  strcpy(wt[3], "Mittwoch");
X  strcpy(wt[4], "Donnerstag");
X  strcpy(wt[5], "Freitag");
X  strcpy(wt[6], "Samstag");
X#else
X  strcpy(wt[0], TOL01_MSG);
X  strcpy(wt[1], TOL02_MSG);
X  strcpy(wt[2], TOL03_MSG);
X  strcpy(wt[3], TOL04_MSG);
X  strcpy(wt[4], TOL05_MSG);
X  strcpy(wt[5], TOL06_MSG);
X  strcpy(wt[6], TOL07_MSG);
X#endif
X
X  time(&tt);
X  tp = localtime(&tt);
X  if (mode == 0) {
X	sprintf(s, "%02.2d.%02.2d.%04.4d", tp->tm_mday, tp->tm_mon + TZS, 1900 + tp->tm_year);
X  }
X  if (mode == 1) {
X	sprintf(s, "%02.2d.%02.2d.%02.2d", tp->tm_mday, tp->tm_mon + TZS, tp->tm_year);
X  }
X  if (mode == 2) {
X	sprintf(s, "%s", wt[tp->tm_wday]);
X  }
X  return (char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mytime()						   */
X/*  BESCHREIBUNG  Tageszeit liefern.  					   */
X/*     PARAMETER  mode  =  0  =  hh:mm:ss				   */
X/*			   1  =  hh:mm	 				   */
X/*     RUECKGABE  Zeit                                                     */
X/***************************************************************************/
X
Xchar *mytime(mode)
Xint mode;
X{
X  struct tm *tp;
X  time_t tt;
X
X  static char s[STRING];
X
X  time(&tt);
X  tp = localtime(&tt);
X  sprintf(s, "%02.2d:%02.2d:%02.2d", tp->tm_hour, tp->tm_min, tp->tm_sec);
X
X  if (mode == 1) s[5] = '\0';
X
X  return (char *) s;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  crypted()						   */
X/*  BESCHREIBUNG  STRING verschluesseln und zurueckgeben.		   */
X/*     PARAMETER  s  =  STRING                                             */
X/*     RUECKGABE  Verschluesselter STRING                                  */
X/***************************************************************************/
X
Xchar *crypted(s)
Xchar s[];
X{
X  static char t[STRING];
X  int i, a;
X
X
X  strcpy(t, s);
X  i = 0;
X  a = 2;
X  while (t[i] != '\0') {
X	t[i] = (t[i] / a) + 32;
X	i++;
X	a++;
X	if (a > 5) a = 2;
X  }
X
X  return (char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  dateconv() 						   */
X/*  BESCHREIBUNG  Datum (STRING) in Datum (LONG) wandeln.		   */
X/*     PARAMETER  d  =  Datum (STRING)                                     */
X/*     RUECKGABE  Datum (LONG)                                             */
X/***************************************************************************/
X
Xlong dateconv(d)
Xchar d[];
X{
X  char s[STRING];
X  int a, b, i;
X
X
X  strcpy(s, (char *) strcopy(d, 0, 1));
X  a = atoi(s);
X  strcpy(s, (char *) strcopy(d, 3, 4));
X  b = atoi(s);
X  strcpy(s, (char *) strcopy(d, 6, 9));
X  i = atoi(s);
X  if (i < 1900) i += 1900;
X
X  sprintf(s, "%4.4d%02.2d%02.2d", i, b, a);
X
X  return atol(s);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  datereconv() 						   */
X/*  BESCHREIBUNG  Datum (LONG) in Datum (STRING) wandeln.		   */
X/*     PARAMETER  l  =  Datum (LONG)                                       */
X/*     RUECKGABE  Datum (STRING)                                           */
X/***************************************************************************/
X
Xchar *datereconv(l)
Xlong l;
X{
X  static char s[STRING];
X  static char t[STRING];
X
X
X  if (l < 19000000)
X	sprintf(s, "%ld", 1900000L + l);
X  else
X	sprintf(s, "%ld", l);
X
X  strcpy(t, (char *) strcopy(s, 6, 7));
X  strcat(t, ".");
X  strcat(t, (char *) strcopy(s, 4, 5));
X  strcat(t, ".");
X  strcat(t, (char *) strcopy(s, 0, 3));
X
X  return (char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timeconv() 						   */
X/*  BESCHREIBUNG  Zeit (STRING) in Zeit (LONG) wandeln.			   */
X/*     PARAMETER  t  =  Zeit (STRING)                                      */
X/*     RUECKGABE  Zeit (LONG)                                              */
X/***************************************************************************/
X
Xint timeconv(t)
Xchar t[];
X{
X  char s[STRING];
X  int i = 0;
X
X
X  strcpy(s, (char *) strcopy(t, 0, 1));
X  i = 100 * atoi(s);
X  strcpy(s, (char *) strcopy(t, 3, 4));
X  i += atoi(s);
X
X  return i;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  timereconv() 						   */
X/*  BESCHREIBUNG  Zeit (LONG) in Zeit (STRING) wandeln.			   */
X/*     PARAMETER  i  =  Zeit (LONG)                                        */
X/*     RUECKGABE  Zeit (STRING)                                            */
X/***************************************************************************/
X
Xchar *timereconv(i)
Xint i;
X{
X  static char s[STRING];
X  static char t[STRING];
X
X
X  if (i < 10000)
X	sprintf(s, "%04.4d00", i);
X  else
X	sprintf(s, "%06.6d", i);
X
X  strcpy(t, (char *) strcopy(s, 0, 1));
X  strcat(t, ":");
X  strcat(t, (char *) strcopy(s, 2, 3));
X  strcat(t, ":");
X  strcat(t, (char *) strcopy(s, 4, 5));
X
X  return (char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  shortname() 						   */
X/*  BESCHREIBUNG  Wandelt lange Namen (NGs) ins 14-Zeichenformat, um Ver-  */
X/*                Wechslungen zu vermeiden:				   */
X/*									   */
X/*		      comp.protocols.tcp-ip.sources.wanted		   */
X/*                =>  com0ces.wanted					   */
X/*							                   */
X/*     PARAMETER  longname : langer Name                                   */
X/*									   */
X/*   									   */
X/*     RUECKGABE  s : kurzer Name                                          */
X/***************************************************************************/
X
Xchar *shortname( longname )
Xchar longname[];
X{
X  char s[STRING];
X  char t[STRING];
X
X  int i = 0, j = 0;
X
X  strcpy(s, longname);
X  strcpy(t, longname);
X
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X
X  i = strlen(t);
X
X  if((i - j) < 15) return (char *) s;
X
X  s[j + 3] = '0'; s[j + 4] = '\0';
X  strcat(s, (char *) strcopy(t, (i-10), i));
X
X  return (char *) s;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  maybe_locked()					   */
X/*  BESCHREIBUNG  Um sicherzustellen das eine Datei, die eigentlich vor-   */
X/*		  handen sein MUSS, wirklich nicht da ist (und nicht nur   */
X/*		  gerade von einem anderen Task benutzt wird), verzoegert  */
X/*		  diese Funktion die Fehlermeldung um eine festgelegte     */
X/*		  Zeitspanne.                                              */
X/*     PARAMETER  name  =  Dateiname				           */
X/*		  mode  =  Zugriffsmodus (sollte NICHT verwendet werden !) */
X/*     RUECKGABE   0    =  Datei erreichbar				   */
X/*		  -1    =  Datei nicht verfuegbar			   */
X/***************************************************************************/
X
Xint maybe_locked(name, mode)
Xchar name[], mode[];
X{
X  FILE *fp;
X  int i = 0, LCK = 0;
X  char s[STRING];
X  char t[STRING];
X
X  sprintf(s, "%s.LCK", name); t[0] = '\0'; strcat(t, (char *) shortname(s));
X
X  TRY_TWICE:
X
X  fp = NULL;
X
X  do {
X	if(fp != NULL) fclose(fp);
X	fp = fopen(t, "r");
X	i++;
X	if (fp != NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);
X		printf(".");
X		sleep(3);
X	}
X  } while ((i < 8) && (fp != 0));
X
X  if(fp != 0){
X	fclose(fp);
X#ifdef _MBOX
X	unlockf(name);   /* <--- DAS IST NATUERLICH NICHT KORREKT !!! */
X	goto TRY_TWICE;  /* <--- DAS AUCH NICHT !!! */
X	nerror("tools.c", 566, "maybe_locked", "Datei gesperrt", name);	
X#else
X	printf("\n\nDatei >>%s<< gesperrt !!!\n\n", name);
X#endif
X	exit( -1 );
X  }
X
X  i = 0;
X
X  do {
X	fp = fopen(name, "r");	/* "r" => "mode", aber VORSICHT ! */
X	i++;
X	if (fp == NULL) {
X		if(i == 1) printf("%c%s ", CR, TOL08_MSG);	
X		printf(".");
X		sync();
X		sleep(3);
X	}
X  } while ((i < 5) && (fp == NULL));
X
X  if (fp == NULL) return -1;
X
X  fclose(fp);
X  return 0;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  num_stripped()					   */
X/*  BESCHREIBUNG  Entfernt alle Ziffern aus STRING.			   */
X/*     PARAMETER  s  =  STRING (incl. Ziffern)				   */
X/*     RUECKGABE  STRING (excl. Ziffern)				   */
X/***************************************************************************/
X
Xchar *numstripped(s)
Xchar s[];
X{
X  static char t[STRING];
X  int i = 0, a = 0;
X
X  while (s[i] != '\0') {
X	if (((s[i] > 64) && (s[i] < 127)) || (s[i] == ' ') || (s[i] == '-')) {
X		t[a] = s[i];
X		a++;
X	}
X	i++;
X  }
X  t[a] = '\0';
X
X  return (char *) t;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  rename()						   */
X/*  BESCHREIBUNG  Benennt Datei1 in Datei2 um (ok, gelogen ... Datei1 wird */
X/*		  in Datei2 kopiert).                                      */
X/*     PARAMETER  alt  =  Datei1                                           */
X/*		  neu  =  Datei2                                           */
X/*     RUECKGABE   0   =  ok                                               */
X/*		  -1   =  Datei1 nicht gefunden				   */
X/***************************************************************************/
X
X#ifndef _ANSI
X
Xint rename(alt, neu)
Xchar *alt[], *neu[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  char s[250];
X
X  fp = fopen(neu, "w");
X  if (fp == NULL) {
X	return -1;
X  }
X  ff = fopen(alt, "r");
X  if (ff == NULL) {
X	return -2;
X  }
X  while (fgets(s, 250, ff) != NULL) {
X	fputs(s, fp);
X  }
X
X  fclose(fp);
X  fclose(ff);
X
X  unlink(alt);
X
X  return 0;
X}
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  headline()						   */
X/*  BESCHREIBUNG  Ueberschrift mit Ansage-Text ausgeben. Vorher wird der   */
X/*		  der Bildschirm geloescht (falls moegliche) und auf	   */
X/*		  negative Darstellung umgeschaltet.                       */
X/*     PARAMETER  line  =  Ansage-Text					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid headline(line)
Xchar line[];
X{
X  char ex[255];
X  int i;
X
X
X  strcpy(ex, line);
X  i = 0;
X  while(line[i] != '\0'){
X	if(line[i] == '\''){
X		/*
X		line[i] = ' ';
X		*/
X		ex[0] = '\0';
X		strcat(ex, strcopy(line, 0, (i-1)));
X	}
X	i++;
X  }
X   
X  sprintf(headinfo, "%s", ex);
X
X  sprintf(ex, "%s                                                                          ", line);
X  ex[79] = '\0';
X  if (ansi("cl") != -1) {
X	if (ansi("mr") == 1) {
X		if (ansi("so") == 1) { 
X			printf("\n\n------  %s  ------\n\n", line);
X			return;
X		}
X	}
X	printf("%s\n", ex);
X	if (ansi("me") == 1) {
X		ansi("se");
X	}
X  }
X  else {
X	printf("\n\n\n\n\n------  %s  ------\n\n", line);
X  }
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  lockf()						   */
X/*  BESCHREIBUNG  Schuetzt eine Datei vor ALLEN Zugriffen		   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid lockf( path )
Xchar path[];
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];  
X
X  sprintf(s, "%s.LCK", path); t[0] = '\0'; strcat(t, (char *) shortname(s));
X
X  fp = fopen( t, "w" );
X  fputs(VERSION, fp);
X  fclose(fp);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  unlockf()						   */
X/*  BESCHREIBUNG  Erlaubt Zugriffe auf eine Datei			   */
X/*     PARAMETER  path  =  Datei					   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid unlockf( path )
Xchar path[];
X{
X  char s[STRING];
X  char t[STRING];
X  
X  sprintf(s, "%s.LCK", path); t[0] = '\0'; strcat(t, (char *) shortname(s));
X
X  unlink(t);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  tty()							   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xint tty()
X{
X  char s[STRING];
X  char t[STRING];
X  int i, l, a, b;
X
X
X  strcpy(s, (char *) ttyname(0));
X  l = length(s);
X  i = l;
X
X  while ((s[l] != 'y') && (l > 0)) l--;
X
X  l++;
X  a = 0;
X
X  for (b = l; b < i; b++) {
X	t[a] = s[b];
X	a++;
X  }
X  t[a] = '\0';
X
X  return atoi(t);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  ttyna()						   */
X/*  BESCHREIBUNG  Name des eigenen Terminal-Anschlusses. 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  siehe BESCHREIBUNG                                       */
X/***************************************************************************/
X
Xchar *ttyna()
X{
X  static char s[STRING];
X  static char t[STRING];
X  int i, j, l;
X
X
X  strcpy(s, (char *) ttyname(0));
X
X  l = length(s) + 1;
X
X  i = 0; 
X  while(s[i] != '\0'){
X	if(s[i] == '/') j = i + 1;
X	i++;
X  }
X  (void) strcpy(t, (char *) strcopy(s, j, l));
X  
X  return (char *) t;
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  clearline()						   */
X/*  BESCHREIBUNG  Bildschirmzeile loeschen.		 		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine			                                   */
X/***************************************************************************/
X
Xvoid clearline()
X{
X  printf("%c", CR);
X  if (ansi("ce") == 1) {
X	printf("                                                               ");
X  }
X  printf("%c", CR);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  isin()						   */
X/*  BESCHREIBUNG  Prueft ob ein Zeichen in einer Zeichenkette vorkommt.	   */
X/*     PARAMETER  pattern = Zeichenkette mit den moegl. Uebereinstimmungen */
X/*		  c       = Zeichen					   */
X/*     RUECKGABE  0       = Zeichen ist NICHT in Zeichenkette enthalten	   */
X/***************************************************************************/
X
Xint isin( pattern, c )
Xchar pattern[];
Xint c;
X{
X  int i = 0;
X  int ok = 0;
X
X  while((pattern[i] != '\0') && (ok == 0)){
X	if(pattern[i] == c) ok++;	
X	i++;
X  }
X  
X  return (int) ok;  
X}
X
END_OF_FILE
  if test 22291 -ne `wc -c <'src/tools.c'`; then
    echo shar: \"'src/tools.c'\" unpacked with wrong size!
  fi
  # end of 'src/tools.c'
fi
echo shar: End of archive 3 \(of 10\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
