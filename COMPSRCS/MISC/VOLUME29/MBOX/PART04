Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v29i066:  mbox - A Bulletin Board System for UNIX and MINIX, Part04/10
Message-ID: <1992Apr5.183425.29664@sparky.imd.sterling.com>
X-Md4-Signature: fd1b8fce3ef98690d1c4044e80c65bdb
Date: Sun, 5 Apr 1992 18:34:25 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 29, Issue 66
Archive-name: mbox/part04
Environment: MINIX, ISC, ESIX, SVR3

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  src/Makefile src/mail.c src/misc.c
# Wrapped by kent@sparky on Sun Apr  5 11:57:41 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 10)."'
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
  echo shar: Extracting \"'src/Makefile'\" \(9174 characters\)
  sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  M A K E F I L E
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 26.10.1991
X#
X#
X#	  	         Modifiziert fuer SVR3    
X#		
X#	      Walter Buerger <walterb@weller.ruhr.sub.org>
X#              Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#		  Solingen/Wuppertal, FRG, 08.11.1991
X#
X#
X#                      Modifiziert fuer ISC 2.21
X#
X#	   	   Hergo Pape <hergo@ivcmd.BOERDE.DE>
X#		       Magdeburg, FRG, 16.11.1991
X#
X#		
X#			     DIFF-Support
X#
X#		Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#			Wuppertal, FRG, 07.01.1992
X#
X#
X#		       Modifiziert fuer ST Minix/c86
X#      
X#		        Olaf <olaf@oski.toppoint.de>
X#      			   Kiel, FRG, 14.01.1992
X#
X#
X#---------------------------------------------------------------------------
X# CFLAGS: 
X# 
X# -D_SYS7         UNIX System 7 (z.B. MINIX, COHERENT, ...)
X# -D_MBOX         IMMER!!!
X# -D_MINIX        Fuer alles, was nur unter MINIX funxt
X# -D_ISC          Fuer alles, was auch unter Interactive UNIX funxt
X# -D_SCO          Fuer alles, was sogar unter SCO UNIX (!) funxt
X# -D_ESTDIO       Earl Chew's "estdio.h" und GNU C 1.37
X# -D_CORELEFT     Speicherplatzreserven ueberwachen (-D_CORELEFT=10000)
X#		  NUR ZU TESTZWECKEN (siehe "chmem +200000")!!! 
X# -D_DATESTAMP    Zeit&Datum ins Console-Logfile aufnehmen
X# -D_NOINDEX      Index-Dateien werden ONLINE gebildet 
X#                 MB-DAEMON wird nicht per [crontab] sondern nur explizit
X#                 fuer die gerade aktive Gruppe gestartet
X# -D_BAUDRATE     Baudrate austesten (nur bei HST-Modems/Fixed BPS)
X#
X# MINIX 386 (BCC)
X CC= bcc
X LN= ln
X CHMEM= chmem
X CFLAGS= -D_MINIX -D_SYS7 -D_MBOX -D_BAUDRATE
X LIB=
X CONVERT= mv a.out $@
X CHOWN= chown $(OWNER).$(GROUP) 
X CHGRP= :
X STRIP= strip $@
X GETCH= getch.o
X#
X#
X# MINIX 386 & ESTDIO.H
X# CC= cc
X# LN= ln
X# CHMEM= chmem
X# CFLAGS= -D_MINIX -D_SYS7 -D_ESTDIO -D_MBOX
X# LIB= -lestdio
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X# GETCH= getch.o
X#
X#
X# MINIX 386 (GCC 1.37)
X# CC= gcc
X# LN= ln
X# CHMEM= : 
X# CFLAGS= -O -D_MINIX -D_SYS7 -D_MBOX -D_ESTDIO 
X# LIB=
X# CONVERT= /usr/local/bin/gcc2minix < a.out > $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X# GETCH= getch.o
X#
X#
X# ESIX SVR3 
X# CC= cc
X# LN= ln
X# CHMEM= chmem
X# CFLAGS= -O -D_MBOX 
X# LIB= -ltermcap -lcurses -lc_s -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X# GETCH= SysV.getch.o
X#
X#
X# ISC 2.21 & "Shared Libs" 
X# CC= gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -D_ISC -traditional
X# LIB= -ltermcap -lcurses -lc_s -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X# GETCH= SysV.getch.o
X
X
X# Hier ist das $HOME-Verzeichnis der ix/MBox
XMBOXHOME=/mbox
X
X
X# Hier befinden sich alle BINARIES/EXECUTABLES
XBIN=/usr/bin
X
X
X# Damit zeigt BLED sein HELP-File an
XBLPAGER=cat
X
X
X# Hier findet man HELP-Files und Dokumentationen
XHELPDIR=/usr/doc
X
X
X# Es waere zwar wuenschenswert die MBox ohne "root.root"
X# zu fahren, aber leider klappt's nicht :-(
XOWNER=root
XGROUP=root
X
X
X
X# Fuer den automagischen Update per "make diff"
XDIFF=/usr/bin/cdiff
X
X# Enthaelt die geaenderten Quellen bzw. die original 1.6er Referencen
XSRC      = /mbox/src
XSRC_ORIG = /mbox/1.6
X
X# Und wer hat die aktuellen Aenderungen ausgefuehrt ?
XADRESSE = "volkers@unnet.w.open.DE"
X
X
X
X
XMBOX.OBJ=main.o $(GETCH) tools.o getline.o \
X	intro.o nerror.o show.o	loop.o help.o admin.o mail.o control.o \
X	misc.o lesen.o lesen2.o pd.o portinfo.o befehl.o misc2.o \
X	postfach.o ctrlx.o makro.o weiterl.o coreleft.o games.o suchen.o \
X	baudrate.o
X
XBLED.OBJ=bled.o $(GETCH) bltools.o blgetline.o derror.o
X
XXMD.OBJ=xmd.o tools.o derror.o
X
XMBRSH.OBJ=mbrsh.o
X
XMBD.OBJ=tools.o mb-daemon.o derror.o
X
XDIFF_FILES=SysV.getch.c admin.c befehl.c bled.c control.c coreleft.c \
X	ctrlx.c defs.h derror.c games.c getch.c getline.c help.c intro.c \
X	lesen.c lesen2.c loop.c mail.c main.c makro.c mb-daemon.c mbox.h \
X	mbrsh.c misc.c misc2.c nerror.c patchlevel.h pd.c portinfo.c \
X	postfach.c show.c suchen.c tools.c weiterl.c xmd.c baudrate.c
X
XPROGS=mbox bled mb-daemon mbrsh xmd
X
Xdefault:; @echo ''
X	  @echo 'Sie muessen eines der folgenden Kommandos verwenden:'
X	  @echo ''
X	  @echo 'make all       <-   Erstellt alle Dateien '
X	  @echo 'make world     <-   Richtet Verzeichnisse ein und verteilt die Rechte'
X	  @echo 'make inst      <-   Kopiert die Binaer-Dateien nach "$(BIN)"'
X	  @echo 'make clean     <-   Entfernt Objekt-Dateien'
X	  @echo 'make mbox      <-   Erstellt "mbox" (ix/MBox BBS)'
X	  @echo 'make mb-daemon <-   Erstellt "mb-daemon" (NEWS Scanner)'
X	  @echo 'make xmd       <-   Erstellt "xmd" (Mailing Agent)'
X	  @echo 'make mbrsh     <-   Erstellt "mbrsh" (Externe Shell)'
X	  @echo 'make bled      <-   Erstellt "bled" (B[etter] L[ine] ED[itor])'
X	  @echo ''
X	  @echo 'Aktive Definitionen:'
X	  @echo ''
X	  @echo 'Compiler [$(CC)]'
X	  @echo 'CFLAGS   [$(CFLAGS)]'
X	  @echo 'Lib(s)   [$(LIB)]'
X	  @echo 'Getch    [$(GETCH)]'
X	  @echo 'Root-ID  [$(OWNER).$(GROUP)]'
X	  @echo ''
X
Xall: $(PROGS)
X	@echo ''
X	@echo '- Alle Dateien wurden erstellt' 
X	@echo ''
X
Xmbox:	$(MBOX.OBJ)
X	@echo ''
X	@echo '- Das Mailboxprogramm wird uebersetzt'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBOX.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHOWN) $@
X	@$(CHGRP) $@
X	@chmod +x mbox
X	@chmod ug+s mbox
X	@$(CHMEM) +200000 mbox
X	@$(STRIP)
X
Xbled:	$(BLED.OBJ) 
X	@echo ''
X	@echo '- Der Editor (BLED) wird uebersetzt'
X	@echo ''
X	$(CC) $(CFLAGS) $(BLED.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHMEM) +10000 bled	
X	@$(STRIP)
X	@chmod +x bled
X
Xxmd:    $(XMD.OBJ) 
X	@echo ''
X	@echo '- Der Mailing Agent (xmd) wird uebersetzt'
X	@echo ''
X	$(CC) $(CFLAGS) $(XMD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x xmd
X
Xmbrsh:  $(MBRSH.OBJ) 
X	@echo ''
X	@echo '- Die interne SHELL (mbrsh) wird uebersetzt'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBRSH.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x mbrsh
X
Xmb-daemon:    $(MBD.OBJ) 
X	@echo ''
X	@echo '- Der NEWS Scanner (mb-daemon) wird uebersetzt'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@chmod +x mb-daemon
X	@chmod ug+s mb-daemon
X	@$(CHMEM) +64000 mb-daemon		
X	@$(STRIP)
X
Xinst:	world all
X	@echo
X	@echo -n '- Die Mailbox wird installiert...'
X	@cp mbox $(BIN)
X	@cp bled $(BIN)
X	@cp mbrsh $(MBOXHOME)
X	@cp mb-daemon $(BIN)
X	@cp xmd $(BIN)
X	@cp bled.doc $(HELPDIR)
X	@$(CHOWN) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@$(CHGRP) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@chmod +s $(BIN)/mbox
X	@chmod +s $(BIN)/mb-daemon
X	@echo  'fertig.'
X	@echo
X
Xcopy:
X	cp mbox bled mb-daemon xmd $(BIN)
X	cp mbrsh $(MBOXHOME)
X
Xworld:;	@echo
X	@echo -n '- Die Verzeichnisse werden eingerichtet ... '
X	@if test -d $(MBOXHOME) ; then echo -n ''; else mkdir $(MBOXHOME) ; fi
X	@if test -d $(BIN) ; then echo -n ''; else mkdir $(BIN) ; fi
X	@if test -d $(MBOXHOME)/etc ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/etc ; fi
X	@if test -d $(MBOXHOME)/lib ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/lib ; fi
X	@if test -d $(MBOXHOME)/src ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/src ; fi
X	@if test -d $(MBOXHOME)/usr ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/usr ; fi
X	@$(CHOWN) $(MBOXHOME) $(MBOXHOME)/*
X	@$(CHGRP) $(MBOXHOME) $(MBOXHOME)/*
X	@chmod ug+rwx $(MBOXHOME)/lib
X	@chmod o-rwx $(MBOXHOME)/lib
X	@chmod ug+rwx $(MBOXHOME)/src
X	@chmod o-rwx $(MBOXHOME)/src
X	@chmod ug+rwx $(MBOXHOME)/etc
X	@chmod o-rwx $(MBOXHOME)/etc
X	@chmod ug+rwx $(MBOXHOME)/usr
X	@chmod o-rwx $(MBOXHOME)/usr
X	@echo 'fertig.'
X	@echo ''
X
X
Xclean:;	
X	@echo ''
X	@echo -n '- Alte Programme etc. werden entfernt ... ' 
X	@rm -f *.o mbox mbrsh bled xmd mb-daemon bltools.c blgetline.c
X	@echo 'fertig.'
X	@echo ''
X
Xblgetline.o:	mbox.h patchlevel.h
X	@if test -f blgetline.c ; then echo -n '' ; \
X		else $(LN) getline.c blgetline.c ; fi
X	$(CC) -c $(CFLAGS) blgetline.c
X
Xbltools.o:	mbox.h patchlevel.h
X	@rm -f bltools.c
X	@cat undef.c > bltools.c
X	@cat tools.c >> bltools.c
X	$(CC) -c $(CFLAGS) bltools.c
X
Xbled.o:	mbox.h patchlevel.h
X	$(CC) -c $(CFLAGS) -D'HILFE "$(BLPAGER) $(HELPDIR)/bled.doc"' bled.c
X
Xdiff: $(DIFF_FILES)
X	@echo DiffMailer by ralf@heibox.ruhr.sub.org >$@
X	@echo Project: ix/MBox 1.6 >>$@
X	@echo Adresse: $(ADRESSE)
X	@echo Folgende Aenderungen sind in $? vorzunehmen >>$@
X	@date >>$@
X	@echo >>$@
X	@for f in $? ; do \
X	echo ----- $$f -----; \
X	echo ----- $$f ----- >>$@; \
X	$(DIFF) $(SRC)/$$f $(SRC_ORIG) | cat >>$@; \
X	done
X	@cat diff | mail -s "ix/MBox PATCHES" volkers@unnet.w.open.de
X
X
Xadmin.o:		mbox.h defs.h
Xbefehl.o:		mbox.h defs.h
Xbled.o:			mbox.h defs.h
Xbaudrate.o:		mbox.h defs.h
Xcontrol.o:		mbox.h defs.h
Xderror.o:		mbox.h defs.h
Xgames.o:		mbox.h defs.h
Xgetline.o:		mbox.h defs.h
Xhelp.o:			mbox.h defs.h
Xintro.o:		mbox.h defs.h
Xlesen:			mbox.h defs.h
Xlesen2.o:		mbox.h defs.h
Xloop.o:			mbox.h defs.h
Xmail.o:			mbox.h defs.h
Xmain.o:			mbox.h defs.h
Xmakro.o:		mbox.h defs.h
Xmbd.o:			mbox.h defs.h
Xmbrsh.o:		mbox.h defs.h
Xmisc.o:			mbox.h defs.h
Xmisc2.o:		mbox.h defs.h
Xnerror.o:		mbox.h defs.h
Xpd.o:			mbox.h defs.h
Xportinfo.o:		mbox.h defs.h
Xpostfach.o:		mbox.h defs.h
Xshow.o:			mbox.h defs.h
Xsuchen.o:		mbox.h defs.h
Xtools.o:		mbox.h defs.h
Xweiterl.o:		mbox.h defs.h
Xxmd.o:			mbox.h defs.h
X
X
X
END_OF_FILE
  if test 9174 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
  fi
  # end of 'src/Makefile'
fi
if test -f 'src/mail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mail.c'\"
else
  echo shar: Extracting \"'src/mail.c'\" \(21793 characters\)
  sed "s/^X//" >'src/mail.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  mail.c						   */
X/*        FUNKTIONEN  fetch_receipy(), brief()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  17.02.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <time.h>
X
X#include "mbox.h"
X
Xstatic int fetch_local;
Xstatic char fetch_subj[STRING];
X
X
X/***************************************************************************/
X/*      FUNKTION  fetch_receipy()					   */
X/*  BESCHREIBUNG  Im REPLY-Modus wird die Adresse des Empfaengers aus      */
X/*	          dessen Mail gefiltert.                                   */
X/*     PARAMETER  REP  =  Datei mit der Mail des zukuenftigen Empfaengers  */
X/*     RUECKGABE  Adresse des Empfaengers                                  */
X/***************************************************************************/
X
Xchar *fetch_reciepy(REP)
Xchar REP[];
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  char f[STRING];
X  int ok = 0, i;
X  int beg = 0;
X  int bang = 0, at = 0, strange = 0, stranger = 0;
X
X  fetch_local = 0;
X  fetch_subj[0] = '\0';
X
X  fp = fopen(REP, "r");
X  if (fp == NULL) {
X	nerror("mail.c", 31, "fetch_reciepy", "Datei_Lesefehler", REP);
X  }
X  while (fgets(f, 80, fp) != NULL) {
X	if (strcomp("From: ", f) == 0) {
X		beg = 6;
X		ok = 1;
X		strcpy(s, f);
X	}
X	if (strcomp("From ", f) == 0) { /* local mail */
X		beg = 5; 
X		ok = 1;
X		strcpy(s, f);
X	}
X	if (strcomp("Reply-To: ", f) == 0) {
X		beg = 10;
X		ok = 1;
X		strcpy(s, f);
X	}
X	if (strcomp("Subject: ", s) == 0) {
X		strcpy(fetch_subj, (char *) strcopy(s, 9, 79));
X	}
X  }
X  fclose(fp);
X
X  if (ok == 0) {
X	return (char *) "OOPS";
X  }
X  i = beg;
X  ok = 0;
X
X  while (s[i] != '\0') {
X	if (s[i] == '(') ok = i - 2;
X	if (s[i] == '<') strange = i + 1;
X	if (s[i] == '>') stranger = i - 1;
X	i++;
X  }
X  if (ok == 0) ok = i;
X  strcpy(t, (char *) strcopy(s, beg, ok));
X
X  if ((strange != 0) && (stranger != 0)) {
X	strcpy(t, (char *) strcopy(s, strange, stranger));
X	return (char *) t;
X  }
X  i = 0;
X  while (t[i] != '\0') {
X	if (t[i] == '@') at = i;
X	if (t[i] == '!') bang = i;
X	i++;
X  }
X
X  if (at != 0) {
X	strcpy(s, (char *) strcopy(t, (at + 1), length(t)));
X	if (strcomp(UUCPSITE, s) == 0) {	/* local user */
X		fetch_local = 1;
X		strcpy(s, (char *) strcopy(t, 0, (at - 1)));
X		i = 0;
X		while (s[i] != '\0') {
X			if (s[i] == '.') s[i] = ' ';
X			i++;
X		}
X		return (char *) s;
X	}
X  }
X
X  if (beg == 5) {  /* local mail */
X	i = 0;
X	while((t[i] != '\0') && (t[i] != ' ')) i++;
X	t[i] = '\0';
X  }
X
X  return (char *) t;
X}
X
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  brief()						   */
X/*  BESCHREIBUNG  Eine persoenliche Nachricht wird verschickt. Je nach     */
X/*		  Empfaenger-Adresse und Parameter wird die Post ins       */
X/*		  MBox-interne Mailsystem geschickt, oder an MAIL          */
X/*		  weitergleitet. Die Adresse des Empfaengers wird ent-     */
X/*		  weder als Parameter uebergeben, oder aus einer Datei     */
X/*		  gefiltert, auf die geantwortet werden soll (REPLY-Mode). */
X/*     PARAMETER  arg  =  "~REPLY~"    =  REPLY-Modus aktivieren           */
X/*			  Es wird nicht unterschieden zwischen REPLY auf   */
X/*			  pers. Mail oder REPLY auf einen NEWS-Artikel.    */
X/*			  Die Datei mit der zu beantwortenden MSG liefert  */
X/*			  die Routine "lesen()".                           */
X/*		  arg  =  "Empfaenger" =  verwertbare Adresse fuer das     */
X/*			  interen Mail-System oder MAIL.                   */
X/*     RUECKGABE   -1  =  Abbruch                                          */
X/***************************************************************************/
X
Xint brief(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  int i, j;
X  int ok;
X  struct userdaten LOOSER;
X
X  struct tm *timeptr;
X  time_t timer;
X
X  int receiver;
X  int mail_id;
X  int EX_PM = 0;
X  int REPLY = 0;
X  int lines = 0;
X  int WEITERLEITEN = 0;
X  int HOLD = 0;
X  int UMLEITUNG = 0;
X
X  char s[STRING];
X  char t[STRING];
X  char TEP[STRING];
X  char REP[STRING];
X  char f[STRING];
X  char subject[STRING];
X  char from[STRING];
X  char rec_char[STRING];
X  char ex[255];
X  char user[STRING];
X  char mesg_id[STRING];
X  char refs[STRING];
X  char date[STRING];
X  char c;
X  char protokoll;
X  char lf;
X  char pubdir[STRING];
X  char dummy[STRING];
X  char username[STRING];
X  char reply[STRING];
X  char priority[STRING];
X  char action[STRING];
X  char cc[STRING];
X  char bcc[STRING];
X  char encrypted[STRING];
X  char comments[STRING];
X  char keywords[STRING];
X  char fortune[STRING];
X
X  char YOUR_SITE[STRING];
X
X  int BINFILE;
X  int news_reply = 0;
X
X  struct stat fst;
X
X
X  i = 0;
X  ok = 0;
X
X  mesg_id[0] = '\0';
X
X  if (arg[0] == '\0') {
X	ansi("md");
X	printf(" %s\n", MAL03_MSG);
X	ansi("me");
X	return -1;
X  }
X  EX_PM = 0;
X
X
X  i = 0;
X  strcpy(t, USER.name);
X  while (t[i] != '\0') {
X	if (t[i] == ' ') t[i] = '.';
X	i++;
X  }
X  strcpy(username, t);
X  action[0] = '\0';
X  priority[0] = '\0';
X  encrypted[0] = '\0';
X  keywords[0] = '\0';
X  comments[0] = '\0';
X  cc[0] = '\0';
X  bcc[0] = '\0';
X  fortune[0] = '\0';
X
X  i = 0;
X  while (arg[i] != '\0') {
X	if ((arg[i] == '!') || (arg[i] == '@') || (arg[i] == '%')) EX_PM++;
X	i++;
X  }
X
X  if ((EX_PM > 0) && (USER.level < MAILOUT_LEV)) {
X	ansi("md");
X	printf("\n\n%s (%d) %s\n", MAL04_MSG, MAILOUT_LEV, MAL05_MSG);
X	ansi("me");
X	return -1;
X  }
X
X  if(arg[length(arg) -1] == '?'){
X	arg[length(arg) -1] = '$';
X	HOLD++;
X  }
X
X  if(arg[length(arg) -1] == '$'){
X	WEITERLEITEN++;
X	arg[length(arg) -1] = '\0';
X	sprintf(TEP, "%s/usr/%d/.lastletter", HOME, USER.id);
X	sprintf(t, "%s/usr/%d/.lastsubject", HOME, USER.id);
X	fp = fopen( t, "r" );
X	if(fp == NULL) {
X		return -1; 
X	}
X	fgets(s, 80, fp);
X	fclose(fp);
X	if(HOLD == 0){
X		sprintf(subject, "%s %s", MAL06_MSG, s);
X		UMLEITUNG++;
X	}else
X		sprintf(subject, "%s", s);
X  }
X
X  user[0] = '\0';
X  strcat(user, arg);
X
X  if(WEITERLEITEN != 0) goto TRY_AGAIN;
X
X  if (strcomp("~REPLY~", arg) == 0) {
X	REPLY++;
X	sprintf(REP, "%s/%dRep", TMP, getpid());
X	sprintf(TEP, "%s/%dTep", TMP, getpid());
X	fp = fopen(REP, "r");
X	if (fp == NULL) {
X		nerror("mail.c", 278, "brief", "Datei-Lesefehler", REP);
X	}
X	fgets(s, 80, fp	);			/* HEADER: Autor */
X
X	sprintf(dummy, "%s %s", GBL01_MSG, X_MAIL_DEMON);
X
X	if ((strcomp(GBL01_MSG, s) == 0) && (strcomp(dummy, s) != 0)) {
X		strcpy(user, (char *) strcopy(s, (1+strlen(GBL01_MSG)), 80));
X
X		fgets(s, 80, fp);		/* HEADER: Datum */
X		fgets(s, 80, fp);		/* HEADER: Betreff */
X
X		strcpy(t, (char *) strcopy(s, (1+strlen(GBL03_MSG)), 80));
X		subject[0]= '\0';
X		if (strcomp("Re: ", t) != 0) {
X			strcpy(subject, "Re: ");
X		}
X		strcat(subject, (char *) stripped(t));
X
X		fgets(s, 80, fp);	/* HEADER: Leer */
X		fgets(s, 80, fp);	/* HEADER: Leer */
X	}
X	else {		/* UUCP-Header (!MBox) */
X
X		sprintf(subject, MAL07_MSG);
X		refs[0] = '\0';
X		mesg_id[0] = '\0';
X
X		ok = -1;
X
X		while ((ok < 1) && (fgets(s, 80, fp) != NULL)) {
X			if (strcomp("Lines: ", s)      == 0) ok = 1;
X			if (strcomp("Date: ",  s)      == 0) {
X				strcpy(date, (char *) strcopy(s, 6, 80));
X			}
X			if (strcomp("Newsgroups: ", s) == 0) news_reply++;
X			if (strcomp("Subject: ", s)    == 0) {
X				subject[0] = '\0';
X				strcpy(t, (char *) strcopy(s, 9, 80));
X				if (strcomp("Re: ", t) != 0) {
X					sprintf(subject, "%s", "Re: ");
X				}
X				strcat(subject, (char *) stripped(t));
X			}
X			if (strcomp("Message-Id: ", s) == 0) {
X				strcpy(mesg_id, (char *) strcopy(s, 12, 80));
X			}
X			if (strcomp("From: ", s) == 0) {
X				strcpy(from, (char *) strcopy(s, 6, 80));
X				ok = 0;
X			}
X			if (strcomp("From ", s) == 0) {
X				strcpy(from, (char *) strcopy(s, 5, 80));
X				ok = 0;
X			}
X			if (strcomp("References: ", s) == 0) {
X				strcpy(refs, (char *) strcopy(s, 12, 80));
X			}
X			if (strcomp("Comments: ", s) == 0) {
X				strcpy(comments, (char *) strcopy(s, 10, 80));
X				strcpy(comments, (char *) stripped(comments));	
X			}
X			if (strcomp("Keywords: ", s) == 0) {
X				strcpy(keywords, (char *) strcopy(s, 10, 80));
X				strcpy(keywords, (char *) stripped(keywords));
X			}
X
X			if ((strlen(s) < 5) && (ok == 0)) ok = 1;
X		}
X		/*
X		fgets(s, 80, fp);
X		*/
X	}
X
X	ff = fopen(TEP, "w");
X	while (fgets(s, 80, fp) != NULL) {
X		if(s[0] != '\n') fputs("> ", ff);
X		fputs(s, ff);
X	}
X	fputs("", ff);
X	fclose(ff);
X	fclose(fp);
X  }
X
X  TRY_AGAIN:
X
X  if((WEITERLEITEN != 0) && (EX_PM != 0)){
X	sprintf(rec_char, "%s", user);
X	if(checkdomaintype( rec_char ) != 0) return -1;
X	goto ONCE_MORE;
X  }
X
X  receiver = 0;
X
X  maybe_locked(UDBASE, "r"); lockf(UDBASE);
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("mail.c", 216, "brief", "Datei-Lesefehler", UDBASE);
X  }
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (receiver == 0)) {
X	if ((strcomp(user, LOOSER.name) == 0) ||
X	    (strcomp(LOOSER.name, user) == 0) ||
X	    (strcomp(user, LOOSER.nick) == 0) ||
X	    (strcomp(user, LOOSER.sh_name) == 0)) {
X		receiver = LOOSER.id;
X		strcpy(rec_char, LOOSER.name);
X	}
X  }
X  close(fd);
X  unlockf(UDBASE);
X
X
X  if ((receiver == 0) && (EX_PM == 0)) {
X
X	if (REPLY != 0) {
X		strcpy(user, fetch_reciepy(REP));
X		if (fetch_local == 1) goto TRY_AGAIN;
X		strcpy(rec_char, (char *) stripped(user));
X		if (strcomp(user, "OOPS") == 0) {
X			ansi("md");
X			printf("\n\n%s\n", MAL08_MSG);
X			ansi("me ");
X			unlink(TEP);
X			unlink(REP); /* ??? */
X			return -1;
X		}
X		EX_PM = 1;
X		c = MAL13_MSG;
X		goto REPLY_MARK;
X	}
X	else {
X		ansi("md");
X		strcpy(rec_char, (char *) stripped(user));
X		printf("\n\n%s \"%s\" %s\n", MAL09_MSG, user, MAL10_MSG);
X		ansi("me");
X		if(WEITERLEITEN == 0) unlink(TEP);
X		unlink(REP);
X		return -1;
X	}
X  }
X
X  if(WEITERLEITEN != 0) goto ONCE_MORE;
X
X  unlink(REP);
X
X  if (EX_PM == 0) {
X	ansi("md");
X	sprintf(s, "%s/usr/%d/.hello", HOME, receiver);
X	printf("\n\n");
X	show(s, 22, 0);
X	ansi("me");
X  }
X  else {
X	strcpy(rec_char, arg);
X  }
X
X  if(checkdomaintype( rec_char ) != 0) return -1;
X
X  if (REPLY != 0) {
X	c = MAL13_MSG;
X	goto REPLY_MARK;
X  }
X  printf("\n\n");
X  ansi("mr");
X  printf("[%s \"%s\"] %s, ? > ", MAL11_MSG, rec_char, MAL12_MSG);
X  ansi("me");
X  printf("%c%c", MAL13_MSG, BS);
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if (c == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, MAL16_MSG);
X		ansi("me");
X	}
X	if (c == ENTER) c = MAL13_MSG;
X	if ((c != MAL13_MSG) && (c != MAL14_MSG) && (c != MAL15_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  if (c == MAL15_MSG) {		/* VERWERFEN */
X	unlink(REP);
X	unlink(TEP);
X	printf("\n");
X	return -1;
X  }
X  sprintf(TEP, "%s/M%d", TMP, getpid());
X  sprintf(pubdir, "%s/dir%d", TMP, getpid());
X
X  if (c == MAL14_MSG) {		/* UPLOAD */
X	clearline();
X	ansi("mr");
X	printf("%c%s, ? > ", CR, MAL17_MSG);
X	ansi("me");
X
X	do {
X		protokoll = getint();
X		if (protokoll >= 97) protokoll -= 32;
X		if (protokoll == '?') {
X			clearline();
X			ansi("mr");
X			printf("%c%s > ", CR, MAL17aMSG);
X			ansi("me");
X		}
X		if ((protokoll != MAL18_MSG) && (protokoll != MAL18_MSG) &&
X		    (protokoll != MAL20_MSG) && (protokoll != MAL21_MSG))
X			protokoll = 0;
X	} while (protokoll == 0);
X
X	printf("%c", protokoll);
X
X  }
X  printf("\n\n%c", CR);
X  ansi("mr");
X  printf("%s ", MAL22_MSG);
X  ansi("me");
X  printf(" %s (%s)\n%c", USER.name, USER.nick, CR);
X  ansi("mr");
X  printf("%s ", MAL23_MSG);
X  ansi("me");
X  printf(" %s\n%c", rec_char, CR);
X  ansi("mr");
X  printf("%s ", MAL24_MSG);
X  ansi("me");
X  printf(" ");
X  strcpy(subject, (char *) getline(50, 11, '.', ""));
X  printf("\n");
X  ansi("mr");
X  printf("%s ", MAL23aMSG);
X  ansi("me");
X  printf(" ");
X  strcpy(cc, (char *) getline(50, 11, '.', ""));
X
X
X  REPLY_MARK:
X
X  if(checkdomaintype( rec_char ) != 0) return -1;
X
X  if (c == MAL13_MSG) {
X	sprintf(s, "%s %s", EDDY, TEP);
X	noctrlx();
X	system(s);
X	ctrlx();
X	protokoll = '*';
X  }
X  else {			/* UPLOAD */
X
X	printf("\n\n");
X	printf("%s\n\n", MAL25_MSG); 
X	ansi("md");
X	printf("%s", MAL26_MSG);
X	ansi("me");
X          
X	unlink( TEP );
X	
X	switch (protokoll) {
X	    case MAL18_MSG:
X			fp = fopen(TEP, "w");
X			if (fp == NULL) {
X				nerror("mail.c", 268, "brief", "DSF", TEP);
X			}
X			c = 0;
X			lf = CR;
X
X			fputc(LF, fp);
X
X			while ((c != CTRL_X) && (c != CTRL_D)) {
X				c = getint();
X				if ((c == CR) && (lf == CR)) fputc(LF, fp);
X				if (c == CR) lf = CR;
X				if (c == LF) lf = LF;
X				if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X					fputc(c, fp);
X				}
X			}
X			fclose(fp);
X			break;
X
X	    case MAL19_MSG:
X			printf("\n");
X			sprintf(s, "exec %s -bc TimeTravelAgency", RX);
X			break;
X	    case MAL20_MSG:
X			printf("\n");
X			sprintf(s, "exec %s -b", RB);
X			break;
X	    case MAL21_MSG:
X			printf("\n");
X			sprintf(s, "exec %s -b", RZ);
X			break;
X	}
X	if (protokoll != MAL18_MSG){
X		mkdir( pubdir, 0777 );
X		chdir( pubdir );
X
X		system( s );
X
X		chdir( HOME );
X		sprintf(s, "mv %s/* %s", pubdir, TEP);
X		system( s );
X		sprintf(s, "rm -r %s", pubdir);
X		system( s );
X	}
X	sync();
X	stat(TEP, &fst);
X	if (fst.st_size < 3L) {
X		printf("\n\n%s\n", MAL27_MSG);
X		control(MAL28_MSG, 3);
X		unlink(REP);	/* ??? */
X		unlink(TEP);
X		return -1;
X	}	
X	if (prf(TEP) == 1) {
X		printf("\n\n");
X		ansi( "md" );
X		printf("%s", MAL25_MSG);		
X		ansi( "me" );
X		unlink(REP); 	/* ??? */
X		unlink(TEP);
X		return -1;
X		BINFILE++;
X	}
X	else{
X		mkix(TEP);
X	}
X  }
X
X  sprintf(reply, "%s <%s@%s>", USER.name, username, UUCPID);
X
X
X  ONCE_MORE:
X
X  if((HOLD != 0) || ((WEITERLEITEN != 0) && (IS_BUFFERED != 0))) goto HOLD_MARK;
X
X  printf("\n\n");
X  ansi("mr");
X  printf("[%s \"%s\"] %s, ? > ", MAL11_MSG, rec_char, MAL28aMSG);
X  ansi("me");
X  printf("%c%c", MAL29_MSG, BS);
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if (c == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, MAL32_MSG);
X		ansi("me");
X	}
X	if (c == ENTER) c = MAL29_MSG;
X	if ((c != MAL29_MSG) && (c != MAL30_MSG) && (c != MAL31_MSG) && (c != MAL31aMSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  if (c == MAL31_MSG) {		/* WEITERSCHREIBEN */
X	sprintf(s, "%s %s", EDDY, TEP);
X	noctrlx();
X	system(s);
X	ctrlx();
X	goto ONCE_MORE;
X  }
X  if (c == MAL30_MSG) {		/* VERWERFEN */
X	printf("\n");
X	unlink(TEP);
X	unlink(REP);
X	return -1;
X  }
X  if (c == MAL31aMSG) {		/* HEADER */
X	headline( MAL32aMSG );
X	printf("\n");
X
X	time(&timer);
X
X	ansi( "md" );
X	printf("From: ");
X	ansi( "me" );
X	printf("%s <%s@%s>\n", USER.name, username, UUCPID);
X
X	ansi( "md" );
X	printf("Reply-To: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(reply, (char *) getline(80, 1001, 32, reply));
X		printf("\n");
X	}
X	else printf("%s\n", reply);
X
X
X	i = 0; j = 0;			/* Empfaenger: Realname */
X	while(from[i] != '\0'){
X		if(from[i] == '<'){
X			strcpy(s, (char *) strcopy(from, 0, (i-1)));
X			j = i;
X		}
X		if(from[i] == '(') j = i+1;
X		if(from[i] == ')') strcpy(s, (char *) strcopy(from, j, (i-1)));
X		i++;
X	}
X	if(j == 0) strcpy(s, from);
X		
X	if(mesg_id[0] != '\0'){
X		ansi( "md" );
X		printf("In-Reply-To: ");
X		ansi( "me" );
X		printf("%s; ", (char *) stripped(mesg_id)); 
X		printf("from \"%s\" at %s", (char *) stripped(s), date);
X
X		if(refs[0] != '\0') 
X			sprintf(s, "%s ", stripped(refs));
X		else
X			s[0] = '\0';
X		strcat(s, mesg_id);
X		ansi( "md" );
X		printf("References: ");
X		ansi( "me" );
X		printf("%s", s);
X	}
X
X	ansi( "md" );
X	printf("To: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(rec_char, (char *) getline(80, 1001, 32, rec_char));
X		printf("\n");
X	}
X	else printf("%s\n", rec_char);
X
X	ansi( "md" );
X	printf("Cc: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(cc, (char *) getline(80, 1001, 32, cc));
X		printf("\n");
X	}
X	else printf("%s\n", cc);
X
X	ansi( "md" );
X	printf("Bcc: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(bcc, (char *) getline(80, 1001, 32, bcc));
X		printf("\n");
X	}
X	else printf("%s\n", bcc);
X
X
X	ansi( "md" );
X	printf("Subject: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(subject, (char *) getline(80, 1001, 32, subject));
X		printf("\n");
X	}
X	else printf("%s\n", subject);
X
X	ansi( "md" );
X	printf("Keywords: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(keywords, (char *) getline(80, 1001, 32, keywords));
X		printf("\n");
X	}
X	else printf("%s\n", keywords);
X
X	ansi( "md" );
X	printf("Comments: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(comments, (char *) getline(80, 1001, 32, comments));
X		printf("\n");
X	}
X	else printf("%s\n", comments);
X	
X	ansi( "md" );
X	printf("Encrypted: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(encrypted, (char *) getline(80, 1001, 32, encrypted));
X		printf("\n");
X	}
X	else printf("%s\n", encrypted);
X
X	ansi( "md" );
X	printf("X-Mailer: ");
X	ansi( "me" );
X	printf("%s %s %s\n", VERSION, PATCHLEVEL, AUTOR);	
X
X	ansi( "md" );
X	printf("Priority: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(priority, (char *) getline(80, 1001, 32, priority));
X		printf("\n");
X	}
X	else printf("%s\n", priority);
X
X	ansi( "md" );
X	printf("Action: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(action, (char *) getline(80, 1001, 32, action));
X		printf("\n");
X	}
X	else printf("%s\n", action);
X
X	ansi( "md" );
X	printf("X-Fortune: ");
X	ansi( "me" );
X	if(USER.level > GUEST_LEV){
X		strcpy(fortune, (char *) getline(80, 1001, 32, fortune));
X		printf("\n");
X	}
X	else printf("%s\n", fortune);
X
X
X	ansi( "md" );
X	printf("Message-Id: ");
X	ansi( "me" );
X   	printf("<%x.%d@%s>\n", timer, USER.id, UUCPID);
X
X	goto ONCE_MORE;
X  }
X
X
X  HOLD_MARK:
X 
X
X  if(UMLEITUNG == 0){
X	if(WEITERLEITEN == 0){
X		sprintf(s, "cp %s %s/usr/%d/.lastletter > /dev/null", TEP, HOME, USER.id);
X		system( s );     
X	}
X	sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X	fp = fopen( s, "w" );
X	if(fp == NULL){
X		nerror("mail.c", 500, "brief", "Datei-Schreibfehler", s);
X	}
X	fprintf(fp, "%s", subject);
X	fclose(fp);
X  }
X
X
X  if (EX_PM == 0) {
X	sprintf(s, "%s/usr/%d/seq", HOME, receiver);
X	maybe_locked(s, "r");
X	fp = fopen(s, "r");
X	if (fp == NULL) {
X		nerror("mail.c", 431, "brief", "Datei-Lesefehler", s);
X	}
X	fscanf(fp, "%d", &mail_id);
X	fclose(fp);
X	fp = fopen(s, "w");
X	fprintf(fp, "%d\n", (mail_id + 1));
X	fclose(fp);
X
X	sprintf(s, "%s/usr/%d/%d", HOME, receiver, mail_id);
X  }
X  else {
X	umask(0000);
X	sprintf(s, "%s/%d.expm", TMP, getpid());
X  }
X
X
X  fp = fopen(s, "w");
X
X  if (EX_PM == 0) {
X	sprintf(s, "%s %s (%s)\n", GBL01_MSG, USER.name, USER.nick);
X	fputs(s, fp);
X
X	time(&timer);
X	timeptr = localtime(&timer);
X	strcpy(t, asctime(timeptr));
X
X	sprintf(s, "%s %s", GBL02_MSG, t);
X	fputs(s, fp);
X
X	sprintf(s, "%s %s\n\n\n", GBL03_MSG, subject);
X	fputs(s, fp);
X
X	lines = 5;
X  }
X   else {
X	lines = 4;
X  }
X
X
X  ff = fopen(TEP, "r");
X  if (ff == 0) {
X	printf("\n\n");
X	ansi("md");
X	printf("%s\n", MAL33_MSG);
X	ansi("me");
X	control(MAL34_MSG, 3);
X	return;
X  }
X  if(EX_PM != 0){
X
X	time(&timer);
X
X	i = 0; j = 0;			/* Empfaenger: Realname */
X	while(from[i] != '\0'){
X		if(from[i] == '<'){
X			strcpy(s, (char *) strcopy(from, 0, (i-1)));
X			j = i;
X		}
X		if(from[i] == '(') j = i+1;
X		if(from[i] == ')') strcpy(s, (char *) strcopy(from, j, (i-1)));
X		i++;
X	}
X	if(j == 0) strcpy(s, from);
X
X	fprintf(fp, "From: %s@%s (%s)\n", username, UUCPID, USER.name); 
X	if(reply[0] != '\0')
X		fprintf(fp, "Reply-To: %s\n", reply);
X	fprintf(fp, "Organization: %s\n", ORGANIZATION);
X	if(mesg_id[0] != '\0'){
X		fprintf(fp, "In-Reply-To: %s; ", (char *) stripped(mesg_id)); 
X		fprintf(fp, "from \"%s\" at %s", (char *) stripped(s), date);
X		if(refs[0] != '\0') 
X			sprintf(s, "%s ", stripped(refs));
X		else
X			s[0] = '\0';
X		strcat(s, mesg_id);
X		fprintf(fp, "References: %s", s);
X	}
X        fprintf(fp, "To: %s\n", rec_char);
X	if(cc[0] != '\0')
X		fprintf(fp, "Cc: %s\n", cc);
X	if(subject[0] != '\0')
X		fprintf(fp, "Subject: %s\n", subject);
X	if(keywords[0] != '\0')
X		fprintf(fp, "Keywords: %s\n", keywords);
X	if(comments[0] != '\0')
X		fprintf(fp, "Comments: %s\n", comments);
X	if(encrypted[0] != '\0')
X		fprintf(fp, "Encrypted: %s\n", encrypted);
X	fprintf(fp, "X-Mailer: %s %s %s\n", VERSION, PATCHLEVEL, AUTOR);	
X	if(priority[0] != '\0')
X		fprintf(fp, "Priority: %s\n", priority);
X	if(action[0] != '\0')
X		fprintf(fp, "Action: %s\n", action);
X	if(fortune[0] != '\0')
X		fprintf(fp, "X-Fortune: %s\n", fortune);
X   	fprintf(fp, "Message-Id: <%x.%d@%s>\n", timer, USER.id, UUCPID);
X 	fputs("\n", fp);
X  }
X  while (fgets(s, 80, ff) != 0) {
X	fputs(s, fp);
X	lines++;
X  }
X  fclose(ff);
X
X  if(UMLEITUNG == 0){
X	  sprintf(s, "%s/usr/%d/.signature", HOME, USER.id);
X	  ff = fopen(s, "r");
X	  if (ff != NULL) {
X		while (fgets(s, 80, ff) != 0) {
X			fputs(s, fp);
X			lines++;
X		}
X		fclose(ff);
X	  }
X  }
X
X  if(WEITERLEITEN == 0) unlink(TEP);
X  fclose(fp);
X
X  if (EX_PM == 0) {
X	sprintf(s, "%s/usr/%d/INDEX", HOME, receiver);
X	maybe_locked(s, "r"); 
X	fp = fopen(s, "a");
X	if (fp == NULL) {
X		nerror("mail.c", 527, "brief", "Datei-Ergaenzungsfehler", s);
X	}
X	sprintf(s, "%d              ", mail_id);
X	s[6] = '\0';
X	if(HOLD != 0){
X		s[5] = '>';
X	}
X	fputs(s, fp);
X
X	sprintf(ex, "%s                                ", subject);
X	ex[26] = '\0';
X	fputs(ex, fp);
X
X	sprintf(ex, "  %s                                        ", USER.name);
X	ex[22] = '\0';
X	fputs(ex, fp);
X
X	strcpy(s, (char *) mydate(1));
X	strcpy(t, (char *) mytime(1));
X	sprintf(ex, "  %s  %s         ", s, t);
X	ex[19] = '\0';
X	fputs(ex, fp);
X
X	sprintf(s, "%-6.d\n", lines);
X	fputs(s, fp);
X
X	fclose(fp);
X
X  }
X  else {
X	sprintf(s, " X-Mail via UUCP (%s) ", rec_char);
X	headline(s);
X	printf("\n%s", MAL35_MSG);
X	sprintf(s, "%s/%d.expm", TMP, getpid());
X	sprintf(t, "/bin/sh ./etc/rmail.sh %s %s", s, rec_char);
X	system(t);
X	unlink(s);
X	unlink(f);
X	umask(0007);
X	printf(" %s\n", MAL36_MSG);
X  }
X
X  unlink(REP);
X  if(UMLEITUNG == 0) unlink(TEP);
X
X  sprintf(s, "%s \"%s\" %s", MAL11_MSG, rec_char, MAL37_MSG);
X  control(s, 3);
X
X  printf("\n");
X
X  if((cc[0] != '\0') || (bcc[0] != '\0')){
X	carboncopy(cc, bcc);
X  }
X
X  return 0;
X}
X
X
X
X
END_OF_FILE
  if test 21793 -ne `wc -c <'src/mail.c'`; then
    echo shar: \"'src/mail.c'\" unpacked with wrong size!
  fi
  # end of 'src/mail.c'
fi
if test -f 'src/misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/misc.c'\"
else
  echo shar: Extracting \"'src/misc.c'\" \(19838 characters\)
  sed "s/^X//" >'src/misc.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  misc.c						   */
X/*        FUNKTIONEN  scanner(), schreiben(), prf(), pruefe()		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  17.02.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <utmp.h>
X#include <time.h>
X
X
X#include "mbox.h"
X
X
Xextern char headinfo[STRING];
X
X/***************************************************************************/
X/*      FUNKTION  scanner()   						   */
X/*  BESCHREIBUNG  Wechselt BRETTER. Bei "B +" bzw. "B -" wird die Aktual-  */
X/*		  litaet nicht beruecksichtigt. In den anderen Modi 	   */
X/*		  werden nur aktuelle Bretter angesprungen.                */
X/*     PARAMETER  mode  =  '> 255'  =  nicht nur aktuelle Bretter	   */
X/*			   '+'      =  aufwaerts springen		   */
X/*			   '-'      =  abwaerts springen		   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid scanner(mode)
Xint mode;
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  char f[STRING];
X  int ok = 0, a, b;
X  int line = 0, l = 0;
X  int locmod = 0;
X  int max = 0;
X
X  if (mode >= 255) {
X	locmod = 255;
X	mode -= 255;
X  }
X  KEIN_ZUGRIFF:
X
X  if (locmod == 255) {
X	maybe_locked(NGROUPS, "r");
X	fp = fopen(NGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 26, "scanner", "Datei-Lesefehler", NGROUPS);
X	}
X }
X  else {
X	maybe_locked(UGROUPS, "r");
X	fp = fopen(UGROUPS, "r");
X	if (fp == NULL) {
X		nerror("misc.c", 34, "scanner", "Datei-Lesefehler", UGROUPS);
X	}
X  }
X
X  f[0] = '\0';
X  ok = 0;
X
X  while ((ok == 0) && (fscanf(fp, "%s %d %d %s", s, &a, &a, t) > 0)) {
X	l++;
X	if (strcomp(NG, s) == 0) {
X		ok = 1;
X	}
X	else {
X		strcpy(f, (char *) s);
X	}
X  }
X
X
X  if (mode == '+') {
X	if (fscanf(fp, "%s %d %d %s", f, &a, &a, t) < 1) {
X		if (ok == 0) {
X			rewind(fp);
X			fscanf(fp, "%s %d %d %s", f, &a, &a, t);
X		}
X	  	else {
X			line = -1;
X		}
X	}
X  }
X  if (mode == '-') {
X	if (f[0] == '\0') {
X		rewind(fp);
X		while (fscanf(fp, "%s %d %d %s", f, &a, &a, t) > 0);
X
X	}
X  }
X  fclose(fp);
X
X  if (max > 20) line = -1;
X
X  if (line == -1) {
X	strcpy(BRETT, (char *) "PM");
X	printf("\n");
X	sprintf(NG, "%s.PM", USER.name);
X	sprintf(INHALT, "%s/usr/%d/INDEX", HOME, USER.id);
X	return;
X  }
X  if (l == 0) {
X	ansi("md");
X	printf(" %s\n", MIS01_MSG);
X	ansi("me");
X	return;
X  }
X  if (chk_newsgrp(f) != 0) {
X	sprintf(NG, "%s", f);
X	max++;
X	goto KEIN_ZUGRIFF;
X  }
X  brett(f);
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  schreiben()						   */
X/*  BESCHREIBUNG  Artikel fuer NEWS einlesen und verteilen. Die Distri-    */
X/*		  bution ist abhaengig von der NG und vom Userlevel.	   */
X/*     PARAMETER  arg = DUMMY (!)                                          */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid schreiben(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *fl;
X  char s[STRING];
X  char t[STRING];
X  char f[STRING];
X  char g[LSTRING];
X  char ex[255];
X  char cmdl[STRING];
X  char rep[STRING];
X  char subj[STRING];
X  char keyw[STRING];
X  char summ[STRING];
X  char from[STRING];
X  char msid[STRING];
X  char refs[STRING];
X  char tmp[STRING];
X  char ng[STRING];
X  char reply[STRING];
X  char group[STRING];
X  char newsgroups[STRING];
X  char distribution[STRING];
X  char followup[STRING];
X  char expires[STRING];
X  char ctrl[STRING];
X  char sender[STRING];
X  char approved[STRING];
X  char iam[STRING];
X  char username[STRING];
X
X  int i, a, b, ok;
X  int app;
X
X  char protokoll = 0;
X  char c;
X  char lf;
X
X  int BINFILE;
X
X  struct stat fst;
X
X  char pubdir[STRING];
X  long tdummy;
X  long tn, ts;
X
X  if (strcomp(BRETT, "PM") == 0) {
X	ansi("md");
X	printf(" <- \"%s.PM\" %s\n\n", USER.name, MIS02_MSG);
X	ansi("me");
X	return;
X  }
X  BINFILE = 0;
X
X
X  i = 0;				/* Vorname.Name */
X  strcpy(ng, USER.name);
X  while (ng[i] != '\0') {
X	if (ng[i] == ' ') ng[i] = '.';
X	i++;
X  }
X  strcpy(username, ng);
X
X  strcpy(group, NG);
X
X
X  umask(0000);
X
X  if (arg[0] == '\0') {
X
X	subj[0] = '\0';
X	keyw[0] = '\0';
X	from[0] = '\0';
X	msid[0] = '\0';
X	summ[0] = '\0';
X	refs[0] = '\0';
X
X	sprintf(rep, "%s/%dRep", TMP, getpid());
X
X	fp = fopen(rep, "r");
X	if (fp != NULL) {		/* REPLY */
X		while ((fgets(s, 80, fp) != NULL) && (s[0] > 32)) {
X			if (strcomp("Subject:", s)   == 0) {
X				strcat(subj, strcopy(s, 8, 79));
X				strcpy(subj,  (char *) stripped(subj));				
X			}
X			if (strcomp("From:", s)      == 0) {
X				from[0] = '\0';
X				strcat(from, strcopy(s, 6, 79));
X				strcpy(from,  (char *) stripped(from));
X			}
X			if (strcomp("Reply-To:", s)  == 0) {
X				from[0] = '\0';
X				strcat(from, strcopy(s, 10, 79));
X				strcpy(from,  (char *) stripped(from));
X			}
X			if (strcomp("Keywords:", s)  == 0) {
X				strcat(keyw, strcopy(s, 10, 79));
X				strcpy(keyw,  (char *) stripped(keyw));
X			}
X			if (strcomp("Summary:", s)   == 0) {
X				strcat(summ, strcopy(s, 9, 79));
X				strcpy(summ,  (char *) stripped(summ));
X			}
X			if (strcomp("Message-ID:", s) == 0) {
X				strcat(msid, strcopy(s, 11, 79));
X				strcpy(msid,  (char *) stripped(msid));
X			}
X			if (strcomp("Article-I.D.:", s) == 0) {
X				strcat(msid, strcopy(s, 13, 79));
X				strcpy(msid,  (char *) stripped(msid));
X			}
X			if (strcomp("References:", s) == 0) {
X				strcat(refs, strcopy(s, 12, 79));
X				strcpy(refs,  (char *) stripped(refs));
X			} 
X			if (strcomp("Followup-To:", s) == 0) {
X				strcpy(group, strcopy(s, 13, 79));
X				strcpy(group, (char *) stripped(group));
X			}
X		}
X		
X		if(strcomp("Poster", group) == 0){
X			printf(" <- %s\n", MIS02aMSG);
X			return;
X		}
X
X
X		sprintf(t, "%s/A%d", TMP, getpid());
X		ff = fopen(t, "w");
X
X		a = 0;
X		b = 0;
X		i = 0;
X		while (from[i] != '\0') {
X			if (from[i] == '(') a = i + 1;
X			if (from[i] == ')') b = i - 1;
X			i++;
X		}
X		if (a < b) {
X			strcpy(s, (char *) strcopy(from, a, b));
X			strcpy(from, (char *) s);
X		}
X		sprintf(ex, "In article %s,\n            %s writes:\n\n", msid, from);
X		fputs(ex, ff);
X		while (fgets(s, 80, fp) != NULL) {
X			if(s[0] != '\n') fputs("> ", ff);
X			fputs(s, ff);
X		}
X		fclose(fp);
X		fclose(ff);
X
X		sprintf(cmdl, "%s %s", EDDY, t);
X		printf("\n\n");
X		system(cmdl);
X		if (strcomp("Re:", subj) != 0) {
X			sprintf(f, "Re: %s", stripped(subj));
X			strcpy(subj, (char *) f);
X		}
X		unlink(rep);
X	}
X	else {		/* Interactive MAIL */
X
X		printf("\n\n%c", CR);
X		ansi("mr");
X		printf("%s", MIS03_MSG);
X		ansi("me");
X		printf(" %s (%s)\n%c", USER.name, USER.nick, CR);
X		ansi("mr");
X		printf("%s", MIS04_MSG);
X		ansi("me");
X		printf(" %s\n%c", NG, CR);
X		ansi("mr");
X		printf("%s", MIS05_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(subj, (char *) getline(57, 11, '.', ""));
X		printf("\n");
X		ansi("mr");
X		printf("%s", MIS06_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(keyw, (char *) getline(57, 11, '.', ""));
X		printf("\n");
X		ansi("mr");
X		printf("%s", MIS07_MSG);
X		ansi("me");
X		printf(" ");
X		strcpy(summ, (char *) getline(57, 11, '.', ""));
X
X		printf("\n\n");
X		ansi("mr");
X		printf("[%s] %s ? > ", NG, MIS08_MSG);
X		ansi("me");
X		printf("%c%c", MIS09_MSG, BS);
X
X		do {
X			c = getint();
X			if (c >= 97) c -= 32;
X			if (c == '?') {
X				clearline();
X				ansi("mr");
X				printf("%c%s > ", CR, MIS12_MSG);
X				ansi("me");
X			}
X			if (c == ENTER) c = MIS09_MSG;
X			if ((c != MIS09_MSG) && (c != MIS10_MSG) && (c != MIS11_MSG)) c = 0;
X		} while (c == 0);
X
X		printf("%c", c);
X
X		if (c == MIS11_MSG) {
X			printf("\n");
X			unlink(t);
X			return;
X		}
X		if (c == MIS10_MSG) {
X			printf("%c                                                                       ", CR);
X			ansi("mr");
X			printf("%c%s, ? > ", CR, MIS13_MSG);
X			ansi("me");
X
X			do {
X				protokoll = getint();
X				if (protokoll >= 97) protokoll -= 32;
X				if (protokoll == '?') {
X					clearline();
X					ansi("mr");
X					printf("%c%s > ", CR, MIS14_MSG);
X					ansi("me"); 
X				}
X				if ((protokoll != MIS15_MSG) && (protokoll != MIS15_MSG) &&
X				    (protokoll != MIS18_MSG) && (protokoll != MIS17_MSG ))
X					protokoll = 0;
X			} while (protokoll == 0);
X
X			printf("%c", protokoll);
X
X		}
X		sprintf(tmp, "%s/A%d", TMP, getpid());
X		sprintf(cmdl, "%s %s", EDDY, tmp);
X		sprintf(pubdir, "%s/dir%d", TMP, getpid());
X
X		if (c == MIS09_MSG) {
X			noctrlx();
X			system(cmdl);
X			ctrlx();
X			protokoll = '*';
X		}
X		else {	/* UPLOAD */
X
X			printf("\n\n");
X			ansi("md");
X			printf("%s", MIS19_MSG);
X			ansi("me");
X
X			switch (protokoll) {
X			    case MIS15_MSG:
X					fp = fopen(tmp, "w");
X					if (fp == NULL) {
X						nerror("misc.c", 310, "schreiben", "DSF", tmp);
X					}
X					c = 0;
X					lf = CR;
X					fputc(LF, fp);
X
X					while ((c != CTRL_X) && (c != CTRL_D)) {
X						c = getint();
X						if ((c == CR) && (lf == CR))
X							fputc(LF, fp);
X						if (c == CR) lf = CR;
X						if (c == LF) lf = LF;
X						if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X							fputc(c, fp);
X						}
X					}
X					fclose(fp);
X					break;
X			    case MIS16_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -bc TimeTravelAgency 2> /dev/null", RX);
X					break;
X			    case MIS17_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -b 2> /dev/null", RB);
X					break;
X			    case MIS18_MSG:
X					printf("\n");
X					sprintf(s, "exec %s -b 2> /dev/null", RZ);
X					break;
X			}
X			if (protokoll != MIS15_MSG){
X				mkdir( pubdir, 0777 );
X				chdir( pubdir );
X
X				time(&ts);
X				system( s );
X				time(&tn); tn = tn - ts;
X				tn -= 10;  /* 10 = "Toleranz" */
X	
X				chdir( HOME );
X				sprintf(s, "mv %s/* %s", pubdir, tmp);
X				system( s );
X				sprintf(s, "rm -r %s", pubdir);
X				system( s );
X			}
X			sync();
X			stat(tmp, &fst);
X			if (fst.st_size < 3L) {
X				printf("\n\n%s\n", MIS20_MSG);
X				control(MIS21_MSG, 3);
X				unlink(tmp);
X				return;
X			}
X			if (prf(tmp) == 1) {
X				if (strcomp(PDNG, NG) == 0) {
X					USER.upratio += ((long) fst.st_size / 1024);
X				}
X				BINFILE++;
X				sprintf(s, MIS22_MSG);
X			}
X			else{
X				mkix(tmp);
X				sprintf(s, MIS23_MSG);
X			}
X			ansi( "md" );
X			printf("\n\n%ld %s %s %s.\n", fst.st_size, MIS24_MSG, s, MIS25_MSG);
X			ansi( "me" );
X			if(tn < 1) tn = 1L;
X			printf("%s %d cps (ca. %d bps).", MIS26_MSG,
X				(fst.st_size / tn), ((fst.st_size / tn) * 11));				
X		}
X	}
X
X	sprintf(iam, "%s <%s@%s>", USER.name, username, UUCPID);
X	sprintf(reply, "%s@%s (%s)", username, UUCPID, USER.name);
X	strcpy(newsgroups, group);
X	if (USER.level < WRITE_EX_LEV) {
X		strcpy(distribution, "local");
X	}
X	else {
X		/*
X		strcpy(ng, NG);
X		i = 0;
X		while ((ng[i] != '.') && (ng[i] != '\0')) i++;
X		ng[i] = '\0';
X		strcpy(distribution, ng);
X		*/
X		strcpy(distribution, "world");
X	}
X	if(refs[0] != '\0') strcat(refs, " ");
X	strcat(refs, msid);	
X	followup[0] = '\0';
X	sender[0] = '\0';
X	ctrl[0] = '\0';
X	expires[0] = '\0';
X	approved[0] = '\0';
X	app = 0;
X	
X
X	ONCE_MORE:
X
X	printf("\n\n");
X	ansi("mr");
X	if(BINFILE == 0){
X		printf("[%s] %s, ? > ", NG, MIS27_MSG);
X	}
X	else{
X		printf("[%s] %s, ? > ", NG, MIS28_MSG);
X	}
X	ansi("me");
X	printf("%c%c", MIS29_MSG, BS);
X
X	do {
X		c = getint();
X		if (c >= 97) c -= 32;
X		if (c == '?') {
X			clearline();
X			ansi("mr");
X			if(BINFILE == 0){
X				printf("%c%s > ", CR, MIS32_MSG);
X			}
X			else{
X				printf("%c%s > ", CR, MIS33_MSG);
X			}
X			ansi("me");
X		}
X		if (c == ENTER) c = MIS29_MSG;
X		if ((c != MIS29_MSG) && (c != MIS30_MSG) && (c != MIS31_MSG) && (c != MIS31aMSG)) c = 0;
X	} while (c == 0);
X
X	printf("%c", c);
X	if (c == MIS30_MSG) {
X		unlink(f);
X		unlink(s);
X		unlink(t);
X		unlink(tmp); /* ??? */
X		unlink(rep);
X		printf("\n");
X		return;
X	}
X	if ((c == MIS31_MSG) && (BINFILE == 0)) {
X		noctrlx();
X		system(cmdl);
X		ctrlx();
X		goto ONCE_MORE;
X	}
X	if (c == MIS31aMSG) { /* HEADER */
X		headline( MIS38aMSG );
X		printf("\n");
X		time(&tdummy);
X
X		ansi( "md" );
X		printf("From: ");
X		ansi( "me" );
X		if(USER.level > ADMIN_LEV){
X			strcpy(s, (char *) getline(80, 1001, 32, iam));
X			if(strcomp(s, iam) != 0) app++;			
X			if(s[0] != '\0') strcpy(iam, s);
X			printf("\n");
X		}
X		else printf("%s\n", iam);
X
X		ansi( "md" );
X		printf("Reply-To: ");
X		ansi( "me" );
X		if(USER.level > GUEST_LEV){
X			strcpy(reply, (char *) getline(80, 1001, 32, reply));
X			printf("\n");
X		}
X		else printf("%s\n", reply);
X
X		ansi( "md" );
X		printf("Sender: ");
X		ansi( "me" );
X		if(USER.level >= ADMIN_LEV){
X			strcpy(sender, (char *) getline(80, 1001, 32, sender));
X			printf("\n");
X		}
X		else printf("%s\n", sender);	
X		
X		ansi( "md" );
X		printf("Control: ");
X		ansi( "me" );
X		if(USER.level >= ADMIN_LEV){
X			strcpy(ctrl, (char *) getline(80, 1001, 32, ctrl));
X			printf("\n");
X		}
X		else printf("%s\n", ctrl);	
X		
X		ansi( "md" );
X		printf("Approved: ");
X		ansi( "me" );
X		if(app != 0) sprintf(approved, "%s <%s@%s>", USER.name, username, UUCPID);
X		if(USER.level >= EXE_LEV){
X			strcpy(approved, (char *) getline(80, 1001, 32, approved));
X			printf("\n");
X		}
X		else printf("%s\n", approved);	
X	
X		ansi( "md" );
X		printf("Newsgroups: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_EX_LEV){
X			strcpy(newsgroups, (char *) getline(80, 1001, 32, newsgroups));
X			printf("\n");
X		}
X		else printf("%s\n", newsgroups);	
X		
X		ansi( "md" );
X		printf("Distribution: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_INTERNAT){
X			strcpy(distribution, (char *) getline(80, 1001, 32, distribution));
X			printf("\n");
X		}
X		else printf("%s\n", distribution);	
X		
X		ansi( "md" );
X		printf("Followup-To: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_EX_LEV){
X			strcpy(followup, (char *) getline(80, 1001, 32, followup));
X			printf("\n");
X		}
X		else printf("%s\n", followup);	
X		
X		ansi( "md" );
X		printf("Subject: ");
X		ansi( "me" );
X		strcpy(subj, (char *) getline(80, 1001, 32, subj));
X
X		ansi( "md" );
X		printf("\nKeywords: ");
X		ansi( "me" );
X		strcpy(keyw, (char *) getline(80, 1001, 32, keyw));
X			
X		ansi( "md" );
X		printf("\nSummary: ");
X		ansi( "me" );
X		strcpy(summ, (char *) getline(80, 1001, 32, summ));
X	
X		ansi( "md" );
X		printf("\nX-News-Reader: ");
X		ansi( "me" );
X	        printf("%s %s %s\n", VERSION, PATCHLEVEL, AUTOR);
X
X		ansi( "md" );
X		printf("References: ");
X		ansi( "me" );
X		printf("%s\n", refs);
X		
X		ansi( "md" );
X		printf("Message-ID: ");
X		ansi( "me" );
X		printf("<%x.%d@%s>\n", tdummy, USER.id, UUCPID);
X		
X		ansi( "md" );
X		printf("Expires: ");
X		ansi( "me" );
X		if(USER.level >= WRITE_INTERNAT){
X			strcpy(expires, (char *) getline(80, 1001, 32, expires));
X			printf("\n");
X		}
X		else printf("%s\n", expires);	
X
X		goto ONCE_MORE;		
X	}
X
X	ansi( "md" );
X	printf("\n\n%s\n", MIS34_MSG);
X	ansi( "me" );
X
X	sprintf(f, "%s/A%d", TMP, getpid());
X	sprintf(t, "%s/B%d", TMP, getpid());
X
X	fp = fopen(f, "r");
X	if (fp == NULL) {
X		printf("\n");
X		ansi("md");
X		printf("%s ...\n", MIS35_MSG);
X		ansi("me");
X		control(MIS36_MSG, 3);
X		unlink(rep);
X		return;
X	}
X
X	ff = fopen(t, "w");
X
X	time(&tdummy);
X
X	fprintf(ff, "From: %s\n", iam);
X	if(reply[0] != '\0')
X		fprintf(ff, "Reply-To: %s\n", reply);
X	if(sender[0] != '\0')
X		fprintf(ff, "Sender: %s\n", sender);
X	if(approved[0] != '\0')
X		fprintf(ff, "Approved: %s\n", approved);
X	if(newsgroups[0] != '\0')
X		fprintf(ff, "Newsgroups: %s\n", newsgroups);
X	if(distribution[0] != '\0')
X		fprintf(ff, "Distribution: %s\n", distribution);
X	if(ctrl[0] != '\0')
X		fprintf(ff, "Control: %s\n", ctrl);
X	if(followup[0] != '\0')
X		fprintf(ff, "Followup-To: %s\n", followup);
X	if(subj[0] != '\0')
X		fprintf(ff, "Subject: %s\n", subj);
X	if(keyw[0] != '\0')
X		fprintf(ff, "Keywords: %s\n", keyw);
X	if(summ[0] != '\0')
X		fprintf(ff, "Summary: %s\n", summ);
X	fprintf(ff, "X-News-Reader: %s %s %s\n", VERSION, PATCHLEVEL, AUTOR);
X	fprintf(ff, "Message-ID: <%x.%d@%s>\n", tdummy, USER.id, UUCPID);
X	if(expires[0] != '\0')
X		fprintf(ff, "Expires: %s\n", expires);
X	if(refs[0] != '\0')
X		fprintf(ff, "References: %s\n", refs);	
X	fputs("\n", ff);	
X	
X	if (BINFILE == 0) {
X		while (fgets(s, 80, fp) != 0) {
X			fputs(s, ff);
X		}
X	}
X	else {
X		time(&tdummy);
X		fputs("BINFILE\n", ff);
X		sprintf(s, "%s/PD.%d", BRETT, tdummy);
X		fputs(s, ff);
X		sprintf(f, "cp %s %s &", tmp, s);
X		system(f);
X		sprintf(s, "\n/public/pd/%s\n", subj);
X		fputs(s, ff);
X		fl = fopen( PDSCRIPT, "a" );
X		fprintf(fl, "mv %s/PD.%d /public/pd/%s\n", BRETT, tdummy, subj);
X		fclose(fl);
X	}
X	fclose(fp);
X	unlink(f);
X
X	unlink(rep);
X
X	if ((USER.level > WRITE_IN_LEV) && (BINFILE == 0)) {
X		sprintf(s, "%s/usr/%d/.signature", HOME, USER.id);
X		fp = fopen(s, "r");
X		if (fp != NULL) {
X			while (fgets(s, 80, fp) != 0) {
X				fputs(s, ff);
X			}
X			fclose(fp);
X		}
X	}
X	fclose(ff);
X
X	sprintf(ex, "/bin/sh ./etc/inews.sh %s %s", NG, t);
X	system(ex);
X
X	unlink(t);
X
X	sprintf(s, "%s \"%s\" %s", MIS37_MSG, NG, MIS38_MSG);
X	control(s, 3);
X
X	
X	if(BINFILE != 0){
X		maybe_locked(NGROUPS, "r");
X		fp = fopen(NGROUPS, "r");
X		if (fp == NULL) {
X			nerror("misc.c", 895, "schreiben", "Datei-Lesefehler", NGROUPS);
X		}
X
X		ok = 0;
X
X	        while ((ok == 0) && (fscanf(fp, "%s %d %d %s", s, &a, &b, f) > 0)) {
X			if(strcomp(NG, s) == 0){
X				i = a;
X				ok = 1;
X			}
X	 	}
X		fclose(fp);
X
X		fl = fopen( PDSCRIPT, "a" );
X		fprintf(fl, "mined %s/%d\n", BRETT, i); 
X		fprintf(fl, "#%s   %s\n\n", NG, USER.name);
X		fclose(fl);
X	}
X
X	printf("%s", MIS39_MSG);
X
X#ifndef _SYS7
X	sleep(30);	/* Scheinbar laeuft INEWS bei SYSV im Hintergrund */
X#endif
X
X	sprintf(s, "%s %s", MB_DAEMON, group);
X	system(s);
X	unlink(tmp);
X	printf("\n");
X  }
X  else {
X	ansi("md");
X	printf(" %s\n\n", MIS40_MSG);
X	ansi("me");
X  }
X  umask(0007);
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  prf()							   */
X/*  BESCHREIBUNG  Stellt fest, ob eine Datei (die per UPLOAD empfangen     */
X/*		  wurde) einen Text oder ein ausfuehrbares Programm ent-   */
X/*		  haelt.                                                   */
X/*     PARAMETER  arg  =  Dateiname                                        */
X/*     RUECKGABE  0    =  Text-Datei                                       */
X/*		  1    =  Ausfuehrbares Programm			   */
X/***************************************************************************/
X
Xint prf(arg)
Xchar arg[];
X{
X  FILE *fp;
X  char ex[255];
X  int i, a;
X
X  fp = fopen(arg, "r");
X  if (fp == NULL) return -1;
X  while ((fgets(ex, 250, fp) != NULL) && (strlen(ex) < 30));
X  fclose(fp);
X
X  i = 0;
X  a = 0;
X  while (ex[i] != '\0') {
X	if ((ex[i] < 32) || (ex[i] > 127)) a++;
X	i++;
X  }
X  if (a > 3) return 1;		/* BINFILE */
X
X  return 0;			/* TEXTFILE */
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  pruefe()	 					   */
X/*  BESCHREIBUNG  Stellt fest, ob eine Datei aus den News-Artikeln die     */
X/*		  Kennung "BINFILE" enthaelt. Faellt die Antwort positiv   */
X/*		  aus, wird die Routine "pd()" aufgerufen.		   */
X/*     PARAMETER  arg  =  Nummer des Artikels                              */
X/*     RUECKGABE  0    =  Text-Datei                                       */
X/*                1    =  BINFILE					   */
X/***************************************************************************/
X
Xint pruefe(arg)
Xchar arg[];
X{
X  FILE *fp;
X  char ex[255];
X  char s[STRING];
X  char entry[STRING];
X  char keywds[STRING];
X
X  if ((arg[0] == '\0') || (arg[0] == '*')) return -1;
X
X  if (strcomp(BRETT, "PM") != 0) {
X	sprintf(entry, "%s/%s", BRETT, arg);
X  }
X  else {
X	sprintf(entry, "%s/usr/%d/%s", HOME, USER.id, arg);
X  }
X
X  keywds[0] = '\0';
X
X  fp = fopen(entry, "r");
X  if (fp == NULL) return -1;
X
X  while ((fgets(ex, 250, fp) != NULL) && (ex[0] > 32)){
X	if(strcomp("Keywords: ", ex) == 0){
X		ex[80] = '\0';
X		strcpy(keywds, strcopy(ex, 10, 80));
X	}
X  }
X
X  while ((fgets(ex, 250, fp) != NULL) && (ex[0] < 32));
X
X  if (strcomp("BINFILE", ex) == 0) {
X	fgets(s, 80, fp);
X	fclose(fp);
X	pd(s, keywds);
X	return 1;
X  }
X  fclose(fp);
X
X  return 0;
X}
X
X
X
X
X
X
END_OF_FILE
  if test 19838 -ne `wc -c <'src/misc.c'`; then
    echo shar: \"'src/misc.c'\" unpacked with wrong size!
  fi
  # end of 'src/misc.c'
fi
echo shar: End of archive 4 \(of 10\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
