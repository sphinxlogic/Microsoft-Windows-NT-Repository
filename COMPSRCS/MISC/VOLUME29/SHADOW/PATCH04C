Newsgroups: comp.sources.misc
From: jfh@rpp386.cactus.org (John F Haugh II)
Subject:  v29i049:  shadow - Shadow Login Suite, Patch04c/3
Message-ID: <1992Apr3.202853.20042@sparky.imd.sterling.com>
X-Md4-Signature: adc402ff173d60c747f1e21e15663dcb
Date: Fri, 3 Apr 1992 20:28:53 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jfh@rpp386.cactus.org (John F Haugh II)
Posting-number: Volume 29, Issue 49
Archive-name: shadow/patch04c
Environment: UNIX
Patch-To: shadow: Volume 26, Issue 54-64

This is the third part of the patch for 3.1.4.
--
Index: Makefile.sun4
*** rel3/Makefile.sun4	Fri Mar 27 10:25:50 1992
--- Makefile.sun4	Fri Mar 27 10:27:12 1992
***************
*** 1,5 ****
  #
! # Copyright 1988,1989,1990,1991, John F. Haugh II
  # All rights reserved.
  #
  # Permission is granted to copy and create derivative works for any
--- 1,5 ----
  #
! # Copyright 1988,1989,1990,1991,1992 John F. Haugh II
  # All rights reserved.
  #
  # Permission is granted to copy and create derivative works for any
***************
*** 8,16 ****
  # and conspicuously displayed on all copies of object code or
  # distribution media.
  #
! #	@(#)Makefile.sun4	3.1	19:49:25  - Shadow password system (SunOS 4.1.1 version)
  #
! #	@(#)Makefile.sun4	3.1	19:49:25	12/28/91
  #
  SHELL = /bin/sh
  
--- 8,16 ----
  # and conspicuously displayed on all copies of object code or
  # distribution media.
  #
! #	@(#)Makefile.sun4	3.5	11:27:30  - Shadow password system (SunOS 4.1.1 version)
  #
! #	@(#)Makefile.sun4	3.5	11:27:30	3/19/92
  #
  SHELL = /bin/sh
  
***************
*** 40,45 ****
--- 40,46 ----
  
  # Configuration Flags
  #
+ #	DEST_INCLUDE_DIR - local include files
  #	LIBS - system libraries
  #		-lsocket - needed for TCP/IP and possibly SYSLOG
  #		-ldbm or -lndbm - needed for DBM support
***************
*** 47,64 ****
  #	CFLAGS - C compiler flags
  #		-DLAI_TCP - needed for SCO Xenix Lachman TCP/IP
  
  # Flags for SunOS 4.1.1
! CFLAGS = -O2 $(OS)
  LIBS =
  LDFLAGS = 
  
  # Names for root user and group, and bin user and group.  See your
! # /etc/passwd and /etc/group files.
  RUID = root
  RGID = wheel
  BUID = bin
  BGID = bin
  
  # Rules for .L (lint) files.
  .SUFFIXES: .L
  LINT = lint
--- 48,73 ----
  #	CFLAGS - C compiler flags
  #		-DLAI_TCP - needed for SCO Xenix Lachman TCP/IP
  
+ DEST_INCLUDE_DIR = /usr/include
+ 
  # Flags for SunOS 4.1.1
! CFLAGS = -O2 $(OS) $(DEST_INCLUDE_DIR)
  LIBS =
  LDFLAGS = 
  
+ # Library for SunOS 4.1.1
+ LIBSEC = libsec.a
+ 
  # Names for root user and group, and bin user and group.  See your
! # /etc/passwd and /etc/group files.  This is for SunOS 4.1.1
  RUID = root
  RGID = wheel
  BUID = bin
  BGID = bin
  
+ # Where the login.defs file will be copied.  Must agree with config.h
+ DEST_LOGIN_DEFS = /etc/login.defs
+ 
  # Rules for .L (lint) files.
  .SUFFIXES: .L
  LINT = lint
***************
*** 157,162 ****
--- 166,174 ----
  FILES9 = groupadd.c groupdel.c groupmod.c tz.c console.c hushed.c getdef.c \
  	scologin.c logoutd.c sulog.c getpass.c userdel.c
  
+ FILES_SUN4 = Makefile.sun4 README.sun4 config.h.sun4
+ FILES_SVR4 = Makefile.svr4 config.h.svr4
+ 
  MAN_1 = chage.1 chfn.1 chsh.1 id.1 login.1 newgrp.1 passwd.1 su.1 \
  	useradd.1 userdel.1 usermod.1 groupadd.1 groupdel.1 groupmod.1 \
  	groups.1
***************
*** 233,239 ****
  	cp chsh /bin
  	cp chage /bin
  	cp id /bin
! 	cp dialup.h shadow.h pwd.h /usr/include
  	chown $(RUID) $(LOGINDIR)/login /etc/pwconv /etc/pwunconv /etc/sulogin \
  		/bin/su /bin/passwd /bin/gpasswd /bin/newgrp /etc/mkpasswd \
  		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
--- 245,251 ----
  	cp chsh /bin
  	cp chage /bin
  	cp id /bin
! 	cp dialup.h shadow.h pwd.h $(DEST_INCLUDE_DIR)
  	chown $(RUID) $(LOGINDIR)/login /etc/pwconv /etc/pwunconv /etc/sulogin \
  		/bin/su /bin/passwd /bin/gpasswd /bin/newgrp /etc/mkpasswd \
  		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
***************
*** 244,253 ****
  		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
  		/etc/userdel /etc/usermod /etc/groupadd /etc/groupdel \
  		/etc/groupmod /etc/logoutd
! 	chown $(BUID) /bin/faillog /bin/id /usr/include/shadow.h \
! 		/usr/include/dialup.h /usr/include/pwd.h
! 	chgrp $(BGID) /bin/faillog /bin/id /usr/include/shadow.h \
! 		/usr/include/dialup.h /usr/include/pwd.h
  	chmod 700 /etc/pwconv /etc/pwunconv /etc/sulogin /etc/mkpasswd \
  		/etc/chpasswd /etc/newusers /bin/dpasswd /bin/chage \
  		/etc/useradd /etc/userdel /etc/usermod /etc/groupadd \
--- 256,265 ----
  		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
  		/etc/userdel /etc/usermod /etc/groupadd /etc/groupdel \
  		/etc/groupmod /etc/logoutd
! 	chown $(BUID) /bin/faillog /bin/id $(DEST_INCLUDE_DIR)/shadow.h \
! 		$(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/pwd.h
! 	chgrp $(BGID) /bin/faillog /bin/id $(DEST_INCLUDE_DIR)/shadow.h \
! 		$(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/pwd.h
  	chmod 700 /etc/pwconv /etc/pwunconv /etc/sulogin /etc/mkpasswd \
  		/etc/chpasswd /etc/newusers /bin/dpasswd /bin/chage \
  		/etc/useradd /etc/userdel /etc/usermod /etc/groupadd \
***************
*** 255,272 ****
  	chmod 4711 $(LOGINDIR)/login /bin/su /bin/passwd /bin/gpasswd \
  		/bin/newgrp /bin/chfn /bin/chsh
  	chmod 711 /bin/faillog /bin/id
! 	chmod 444 /usr/include/shadow.h /usr/include/dialup.h \
! 		/usr/include/pwd.h
! 	[ -f /etc/login.defs ] || (cp login.defs /etc ; \
! 		chown $(RUID) /etc/login.defs ; \
! 		chgrp $(RGID) /etc/login.defs ; \
! 		chmod 600 /etc/login.defs )
  
  lint:	su.lint login.lint pwconv.lint pwunconv.lint passwd.lint sulogin.lint \
  	faillog.lint newgrp.lint gpasswd.lint mkpasswd.lint chfn.lint \
  	chsh.lint chage.lint dpasswd.lint id.lint useradd.lint userdel.lint \
! 	usermod.lint groupadd.lint groupdel.lint groupmod.lint $(ALLSRCS:.c=.L)
! 	logoutd.lint
  
  tags:	$(ALLSRCS)
  	$(TAGS) $(ALLSRCS)
--- 267,284 ----
  	chmod 4711 $(LOGINDIR)/login /bin/su /bin/passwd /bin/gpasswd \
  		/bin/newgrp /bin/chfn /bin/chsh
  	chmod 711 /bin/faillog /bin/id
! 	chmod 444 $(DEST_INCLUDE_DIR)/shadow.h $(DEST_INCLUDE_DIR)/dialup.h \
! 		$(DEST_INCLUDE_DIR)/pwd.h
! 	[ -f $(DEST_LOGIN_DEFS) ] || (cp login.defs $(DEST_LOGIN_DEFS) ; \
! 		chown $(RUID) $(DEST_LOGIN_DEFS) ; \
! 		chgrp $(RGID) $(DEST_LOGIN_DEFS) ; \
! 		chmod 600 $(DEST_LOGIN_DEFS) )
  
  lint:	su.lint login.lint pwconv.lint pwunconv.lint passwd.lint sulogin.lint \
  	faillog.lint newgrp.lint gpasswd.lint mkpasswd.lint chfn.lint \
  	chsh.lint chage.lint dpasswd.lint id.lint useradd.lint userdel.lint \
! 	usermod.lint groupadd.lint groupdel.lint groupmod.lint logoutd.lint \
! 	$(ALLSRCS:.c=.L)
  
  tags:	$(ALLSRCS)
  	$(TAGS) $(ALLSRCS)
***************
*** 277,282 ****
--- 289,306 ----
  $(DOCS):
  	[ -f s.$@ ] && get -t -r$(RELEASE) s.$@
  
+ login.defs:
+ 	[ -f s.login.defs ] && get -t -r$(RELEASE) s.login.defs
+ 
+ Makefile.sun4:
+ 	[ -f s.Makefile.sun4 ] && get -t -r$(RELEASE) s.Makefile.sun4
+ 
+ README.sun4:
+ 	[ -f s.README.sun4 ] && get -t -r$(RELEASE) s.README.sun4
+ 
+ config.h.sun4:
+ 	[ -f s.config.h.sun4 ] && get -t -r$(RELEASE) s.config.h.sun4
+ 
  login:	$(LOBJS) libshadow.a
  	$(CC) -o login $(LDFLAGS) $(LOBJS) libshadow.a $(LIBS)
  
***************
*** 380,386 ****
  	$(LINT) $(LINTFLAGS) id.c > id.lint
  
  groups: groups.o libshadow.a
- 	$(CC) -c $(CFLAGS) groups.o libshadow.a $(LIBS)
  	$(CC) -o groups $(LDFLAGS) groups.o libshadow.a $(LIBS)
  
  groups.lint: groups.c
--- 404,409 ----
***************
*** 429,435 ****
  	[ -f s.pwd.h.m4 ] && get -t -r$(RELEASE) s.pwd.h.m4
  
  pwd.h: pwd.h.m4
! 	m4 $(OS) pwd.h.m4 >pwd.h
  
  logoutd: logoutd.o libshadow.a
  	$(CC) -o logoutd $(LDFLAGS) logoutd.o libshadow.a
--- 452,458 ----
  	[ -f s.pwd.h.m4 ] && get -t -r$(RELEASE) s.pwd.h.m4
  
  pwd.h: pwd.h.m4
! 	/usr/5bin/m4 $(OS) < pwd.h.m4 > pwd.h
  
  logoutd: logoutd.o libshadow.a
  	$(CC) -o logoutd $(LDFLAGS) logoutd.o libshadow.a
***************
*** 442,448 ****
  susetup.c: setup.c
  	cp setup.c susetup.c
  
! susetup.o: config.h setup.c pwd.h
  	$(CC) -c $(CFLAGS) -DSU susetup.c
  
  scologin: scologin.o
--- 465,471 ----
  susetup.c: setup.c
  	cp setup.c susetup.c
  
! susetup.o: config.h susetup.c pwd.h
  	$(CC) -c $(CFLAGS) -DSU susetup.c
  
  scologin: scologin.o
***************
*** 483,489 ****
  groupadd.o: config.h shadow.h
  groupdel.o: config.h shadow.h
  groupmod.o: config.h shadow.h
! logoutd.o:
  
  libshadow.a(shadow.o): shadow.h config.h
  libshadow.a(shadowio.o): shadow.h
--- 506,513 ----
  groupadd.o: config.h shadow.h
  groupdel.o: config.h shadow.h
  groupmod.o: config.h shadow.h
! logoutd.o: config.h
! sulogin.o: config.h
  
  libshadow.a(shadow.o): shadow.h config.h
  libshadow.a(shadowio.o): shadow.h
***************
*** 493,498 ****
--- 517,525 ----
  libshadow.a(dialchk.o): dialup.h config.h
  libshadow.a(getdef.o): config.h
  libshadow.a(pwdbm.o): config.h pwd.h
+ libshadow.a(spdbm.o): config.h shadow.h
+ libshadow.a(grdbm.o): config.h
+ libshadow.a(gsdbm.o): config.h shadow.h
  libshadow.a(pwpack.o): config.h pwd.h
  libshadow.a(pwent.o): config.h pwd.h
  libshadow.a(pwio.o): pwd.h
***************
*** 499,507 ****
  libshadow.a(getpass.o): config.h
  libshadow.a(encrypt.o): config.h
  libshadow.a(port.o): port.h
  
  clean:
! 	-rm -f susetup.c *.o a.out core npasswd nshadow *.pag *.dir
  
  clobber: clean
  	-rm -f $(BINS) *.lint *.L libshadow.a
--- 526,535 ----
  libshadow.a(getpass.o): config.h
  libshadow.a(encrypt.o): config.h
  libshadow.a(port.o): port.h
+ libshadow.a(rad64.o): config.h
  
  clean:
! 	-rm -f susetup.c *.o a.out core npasswd nshadow *.pag *.dir pwd.h
  
  clobber: clean
  	-rm -f $(BINS) *.lint *.L libshadow.a
***************
*** 515,521 ****
  
  shar:	login.sh.01 login.sh.02 login.sh.03 login.sh.04 login.sh.05 \
  	login.sh.06 login.sh.07 login.sh.08 login.sh.09 login.sh.10 \
! 	login.sh.11
  
  login.sh.01: $(FILES1) Makefile
  	shar -a $(FILES1) > login.sh.01
--- 543,549 ----
  
  shar:	login.sh.01 login.sh.02 login.sh.03 login.sh.04 login.sh.05 \
  	login.sh.06 login.sh.07 login.sh.08 login.sh.09 login.sh.10 \
! 	login.sh.11 login.sh.12
  
  login.sh.01: $(FILES1) Makefile
  	shar -a $(FILES1) > login.sh.01
***************
*** 549,551 ****
--- 577,582 ----
  
  login.sh.11: $(DOCS2) Makefile
  	shar -a $(DOCS2) > login.sh.11
+ 
+ login.sh.12: $(FILES_SUN4) $(FILES_SVR4) Makefile
+ 	shar -a $(FILES_SUN4) $(FILES_SVR4) > login.sh.12
Index: config.h.sun4
*** rel3/config.h.sun4	Fri Mar 27 10:25:50 1992
--- config.h.sun4	Fri Mar 27 10:27:14 1992
***************
*** 12,18 ****
  /*
   * Configuration file for login.
   *
!  *	@(#)config.h.sun4	3.1	19:49:35	12/28/91 (SunOS 4.1.1)
   */
  
  
--- 12,18 ----
  /*
   * Configuration file for login.
   *
!  *	@(#)config.h.sun4	3.2	13:22:32	3/9/92 (SunOS 4.1.1)
   */
  
  
***************
*** 79,84 ****
--- 79,92 ----
  
  #define RLOGIN
  #define UT_HOST
+ 
+ /*
+  * Define the "success" code from ruserok().  Most modern systems use 0
+  * for success and -1 for failure, while certain older versions use 1
+  * for success and 0 for failure.  Please check your manpage to be sure.
+  */
+ 
+ #define       RUSEROK 0
  
  /*
   * Select one of the following
Index: logoutd.c
*** rel3/logoutd.c	Fri Mar 27 10:25:38 1992
--- logoutd.c	Fri Mar 27 10:27:16 1992
***************
*** 10,16 ****
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)logoutd.c	3.2	11:50:28	12/28/91";
  #endif
  
  #include <sys/types.h>
--- 10,16 ----
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)logoutd.c	3.3	13:22:33	3/9/92";
  #endif
  
  #include <sys/types.h>
***************
*** 19,24 ****
--- 19,28 ----
  #include <utmp.h>
  #include "config.h"
  
+ #ifdef SUN4
+ #include <fcntl.h>
+ #endif
+ 
  main ()
  {
  	int	i;
***************
*** 55,67 ****
  #ifdef	USG_UTMP
  			if (utmp.ut_type != USER_PROCESS)
  				continue;
  #endif
  #ifdef BSD_UTMP
! 			if (utmp.ut_user[0] == '\0')
  				continue;
! #endif
! 			if (isttytime (utmp.ut_user, utmp.ut_line, time (0)))
  				continue;
  #ifdef	USG_UTMP
  			kill (- utmp.ut_pid, SIGHUP);
  			sleep (10);
--- 59,73 ----
  #ifdef	USG_UTMP
  			if (utmp.ut_type != USER_PROCESS)
  				continue;
+ 			if (isttytime (utmp.ut_user, utmp.ut_line, time (0)))
+ 				continue;
  #endif
  #ifdef BSD_UTMP
! 			if (utmp.ut_name[0] == '\0')
  				continue;
! 			if (isttytime (utmp.ut_name, utmp.ut_line, time (0)))
  				continue;
+ #endif
  #ifdef	USG_UTMP
  			kill (- utmp.ut_pid, SIGHUP);
  			sleep (10);
Index: usermod.c
*** rel3/usermod.c	Fri Mar 27 10:25:31 1992
--- usermod.c	Fri Mar 27 10:27:21 1992
***************
*** 1,5 ****
  /*
!  * Copyright 1991, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
--- 1,5 ----
  /*
!  * Copyright 1991, 1992, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
***************
*** 10,16 ****
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)usermod.c	3.8	19:40:17	12/28/91";
  #endif
  
  #include <sys/types.h>
--- 10,16 ----
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)usermod.c	3.11	09:26:21	3/27/92";
  #endif
  
  #include <sys/types.h>
***************
*** 31,38 ****
  
  #include "config.h"
  #include "shadow.h"
! #include <faillog.h>
! #include <lastlog.h>
  
  #ifdef	USE_SYSLOG
  #include <syslog.h>
--- 31,38 ----
  
  #include "config.h"
  #include "shadow.h"
! #include "faillog.h"
! #include "lastlog.h"
  
  #ifdef	USE_SYSLOG
  #include <syslog.h>
***************
*** 46,51 ****
--- 46,59 ----
  #define	NGROUPS_MAX	64
  #endif
  
+ #if !defined(MDY_DATE) && !defined(DMY_DATE) && !defined(YMD_DATE)
+ #define	MDY_DATE	1
+ #endif
+ #if (defined (MDY_DATE) && (defined (DMY_DATE) || defined (YMD_DATE))) || \
+     (defined (DMY_DATE) && (defined (MDY_DATE) || defined (YMD_DATE)))
+ Error: You must only define one of MDY_DATE, DMY_DATE, or YMD_DATE
+ #endif
+ 
  #define	VALID(s)	(strcspn (s, ":\n") == strlen (s))
  
  char	user_name[BUFSIZ];
***************
*** 221,233 ****
  	long	total;
  
  	/*
! 	 * start by separating the month, day and year.  this is
! 	 * a chauvanistic program - it only takes date input in
! 	 * the standard USA format.
  	 */
  
  	if (sscanf (str, "%d/%d/%d%c", &month, &day, &year, slop) != 3)
  		return -1;
  
  	/*
  	 * the month, day of the month, and year are checked for
--- 229,250 ----
  	long	total;
  
  	/*
! 	 * start by separating the month, day and year.  the order
! 	 * is compiled in ...
  	 */
  
+ #ifdef	MDY_DATE
  	if (sscanf (str, "%d/%d/%d%c", &month, &day, &year, slop) != 3)
  		return -1;
+ #endif
+ #ifdef	DMY_DATE
+ 	if (sscanf (str, "%d/%d/%d%c", &day, &month, &year, slop) != 3)
+ 		return -1;
+ #endif
+ #ifdef	YMD_DATE
+ 	if (sscanf (str, "%d/%d/%d%c", &year, &month, &day, slop) != 3)
+ 		return -1;
+ #endif
  
  	/*
  	 * the month, day of the month, and year are checked for
***************
*** 458,466 ****
  		"usage: %s [-u uid [-o]] [-g group] [-G group,...] \n", Prog);
  	fprintf (stderr,
  		"\t\t[-d home [-m]] [-s shell] [-c comment] [-l new_name]\n");
  	fprintf (stderr,
! 		"\t\t[-f inactive] [-e expire] name\n");
! 
  	exit (2);
  }
  
--- 475,492 ----
  		"usage: %s [-u uid [-o]] [-g group] [-G group,...] \n", Prog);
  	fprintf (stderr,
  		"\t\t[-d home [-m]] [-s shell] [-c comment] [-l new_name]\n");
+ #ifdef	MDY_DATE
  	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire mm/dd/yy ] name\n");
! #endif
! #ifdef	DMY_DATE
! 	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire dd/mm/yy ] name\n");
! #endif
! #ifdef	YMD_DATE
! 	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire yy/mm/dd ] name\n");
! #endif
  	exit (2);
  }
  
***************
*** 575,590 ****
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: error opening group file\n", Prog);
! 		exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: error locking shadow group file\n", Prog);
! 		exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: error opening shadow group file\n", Prog);
! 		exit (1);
  	}
  #endif
  
--- 601,616 ----
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: error opening group file\n", Prog);
! 		fail_exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: error locking shadow group file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: error opening shadow group file\n", Prog);
! 		fail_exit (1);
  	}
  #endif
  
***************
*** 646,652 ****
  		if (! gr_update (grp)) {
  			fprintf (stderr, "%s: error adding new group entry\n",
  				Prog);
! 			exit (1);
  		}
  #ifdef	NDBM
  		/*
--- 672,678 ----
  		if (! gr_update (grp)) {
  			fprintf (stderr, "%s: error adding new group entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  #ifdef	NDBM
  		/*
***************
*** 656,666 ****
  		if (! gr_dbm_update (grp)) {
  			fprintf (stderr, "%s: cannot add new dbm group entry\n",
  				Prog);
! 			exit (1);
  		}
- 		endgrent ();
  #endif
  	}
  
  #ifdef	SHADOWGRP
  	/*
--- 682,694 ----
  		if (! gr_dbm_update (grp)) {
  			fprintf (stderr, "%s: cannot add new dbm group entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  #endif
  	}
+ #ifdef NDBM
+ 	endgrent ();
+ #endif
  
  #ifdef	SHADOWGRP
  	/*
***************
*** 749,755 ****
  		if (! sgr_update (sgrp)) {
  			fprintf (stderr, "%s: error adding new group entry\n",
  				Prog);
! 			exit (1);
  		}
  #ifdef	NDBM
  		/*
--- 777,783 ----
  		if (! sgr_update (sgrp)) {
  			fprintf (stderr, "%s: error adding new group entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  #ifdef	NDBM
  		/*
***************
*** 759,770 ****
  		if (! sgr_dbm_update (sgrp)) {
  			fprintf (stderr, "%s: cannot add new dbm group entry\n",
  				Prog);
! 			exit (1);
  		}
- 		endsgent ();
  #endif
  	}
  #endif
  }
  
  /*
--- 787,800 ----
  		if (! sgr_dbm_update (sgrp)) {
  			fprintf (stderr, "%s: cannot add new dbm group entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  #endif
  	}
+ #ifdef NDBM
+ 	endsgent ();
  #endif
+ #endif
  }
  
  /*
***************
*** 976,993 ****
  {
  	if (! pw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite password file\n", Prog);
! 		exit (1);
  	}
  	if (! spw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow password file\n",	
  			Prog);
! 		exit (1);
  	}
  	if (user_ngroups >= 0) {
  		if (! gr_close ()) {
  			fprintf (stderr, "%s: cannot rewrite group file\n",
  				Prog);
! 			exit (1);
  		}
  		(void) gr_unlock ();
  #ifdef	SHADOWGRP
--- 1006,1023 ----
  {
  	if (! pw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite password file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! spw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow password file\n",	
  			Prog);
! 		fail_exit (1);
  	}
  	if (user_ngroups >= 0) {
  		if (! gr_close ()) {
  			fprintf (stderr, "%s: cannot rewrite group file\n",
  				Prog);
! 			fail_exit (1);
  		}
  		(void) gr_unlock ();
  #ifdef	SHADOWGRP
***************
*** 994,1000 ****
  		if (! sgr_close ()) {
  			fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  				Prog);
! 			exit (1);
  		}
  		(void) sgr_unlock ();
  #endif
--- 1024,1030 ----
  		if (! sgr_close ()) {
  			fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  				Prog);
! 			fail_exit (1);
  		}
  		(void) sgr_unlock ();
  #endif
***************
*** 1017,1031 ****
  	}
  	if (! pw_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open password file\n", Prog);
! 		exit (1);
  	}
  	if (! spw_lock ()) {
! 		fprintf (stderr, "%s: cannot lock shadow password file\n", Prog);
! 		exit (1);
  	}
  	if (! spw_open (O_RDWR)) {
! 		fprintf (stderr, "%s: cannot open shadow password file\n", Prog);
! 		exit (1);
  	}
  }
  
--- 1047,1063 ----
  	}
  	if (! pw_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open password file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! spw_lock ()) {
! 		fprintf (stderr, "%s: cannot lock shadow password file\n",
! 			Prog);
! 		fail_exit (1);
  	}
  	if (! spw_open (O_RDWR)) {
! 		fprintf (stderr, "%s: cannot open shadow password file\n",
! 			Prog);
! 		fail_exit (1);
  	}
  }
  
***************
*** 1056,1079 ****
  		if (! pw_update (&pwent)) {
  			fprintf (stderr, "%s: error changing password entry\n",
  				Prog);
! 			exit (1);
  		}
  		if (lflg && ! pw_remove (user_name)) {
  			fprintf (stderr, "%s: error removing password entry\n",
  				Prog);
! 			exit (1);
  		}
  #if defined(DBM) || defined(NDBM)
  		if (access ("/etc/passwd.pag", 0) == 0) {
  			if (! pw_dbm_update (&pwent)) {
! 				fprintf (stderr, "%s: error adding password dbm entry\n",
  					Prog);
! 				exit (1);
  			}
! 			if (lflg && (pwd = getpwnam (user_name)) && ! pw_dbm_remove (pwd)) {
! 				fprintf (stderr, "%s: error removing passwd dbm entry\n",
  					Prog);
! 				exit (1);
  			}
  			endpwent ();
  		}
--- 1088,1114 ----
  		if (! pw_update (&pwent)) {
  			fprintf (stderr, "%s: error changing password entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  		if (lflg && ! pw_remove (user_name)) {
  			fprintf (stderr, "%s: error removing password entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  #if defined(DBM) || defined(NDBM)
  		if (access ("/etc/passwd.pag", 0) == 0) {
  			if (! pw_dbm_update (&pwent)) {
! 				fprintf (stderr,
! 					"%s: error adding password dbm entry\n",
  					Prog);
! 				fail_exit (1);
  			}
! 			if (lflg && (pwd = getpwnam (user_name)) &&
! 					! pw_dbm_remove (pwd)) {
! 				fprintf (stderr,
! 					"%s: error removing passwd dbm entry\n",
  					Prog);
! 				fail_exit (1);
  			}
  			endpwent ();
  		}
***************
*** 1081,1107 ****
  	}
  	if (lflg || eflg || fflg) {
  		if (! spw_update (&spent)) {
! 			fprintf (stderr, "%s: error adding new shadow password entry\n",
  				Prog);
! 			exit (1);
  		}
  		if (lflg && ! spw_remove (user_name)) {
! 			fprintf (stderr, "%s: error removing shadow password entry\n",
  				Prog);
! 			exit (1);
  		}
  	}
  #ifdef	NDBM
  	if (access ("/etc/shadow.pag", 0) == 0) {
  		if (! sp_dbm_update (&spent)) {
! 			fprintf (stderr, "%s: error updating shadow passwd dbm entry\n",
  				Prog);
! 			exit (1);
  		}
  		if (lflg && ! sp_dbm_remove (user_name)) {
! 			fprintf (stderr, "%s: error removing shadow passwd db entry\n",
  				Prog);
! 			exit (1);
  		}
  		endspent ();
  	}
--- 1116,1146 ----
  	}
  	if (lflg || eflg || fflg) {
  		if (! spw_update (&spent)) {
! 			fprintf (stderr,
! 				"%s: error adding new shadow password entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  		if (lflg && ! spw_remove (user_name)) {
! 			fprintf (stderr,
! 				"%s: error removing shadow password entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  	}
  #ifdef	NDBM
  	if (access ("/etc/shadow.pag", 0) == 0) {
  		if (! sp_dbm_update (&spent)) {
! 			fprintf (stderr,
! 				"%s: error updating shadow passwd dbm entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  		if (lflg && ! sp_dbm_remove (user_name)) {
! 			fprintf (stderr,
! 				"%s: error removing shadow passwd db entry\n",
  				Prog);
! 			fail_exit (1);
  		}
  		endspent ();
  	}
***************
*** 1126,1132 ****
  		if (access (user_newhome, 0) == 0) {
  			fprintf (stderr, "%s: directory %s exists\n",
  				Prog, user_newhome);
! 			exit (12);
  		} else if (rename (user_home, user_newhome)) {
  			if (errno == EXDEV) {
  				if (mkdir (user_newhome, sb.st_mode & 0777)) {
--- 1165,1171 ----
  		if (access (user_newhome, 0) == 0) {
  			fprintf (stderr, "%s: directory %s exists\n",
  				Prog, user_newhome);
! 			fail_exit (12);
  		} else if (rename (user_home, user_newhome)) {
  			if (errno == EXDEV) {
  				if (mkdir (user_newhome, sb.st_mode & 0777)) {
***************
*** 1147,1153 ****
  			fprintf (stderr,
  				"%s: cannot rename directory %s to %s\n",
  				Prog, user_home, user_newhome);
! 			exit (12);
  		}
  	}
  	if (uflg || gflg)
--- 1186,1192 ----
  			fprintf (stderr,
  				"%s: cannot rename directory %s to %s\n",
  				Prog, user_home, user_newhome);
! 			fail_exit (12);
  		}
  	}
  	if (uflg || gflg)
***************
*** 1191,1196 ****
--- 1230,1251 ----
  		}
  		close (fd);
  	}
+ }
+ 
+ /*
+  * fail_exit - exit with an error code after unlocking files
+  */
+ 
+ fail_exit (code)
+ int	code;
+ {
+ 	(void) gr_unlock ();
+ #ifdef	SHADOWGRP
+ 	(void) sgr_unlock ();
+ #endif
+ 	(void) spw_unlock ();
+ 	(void) pw_unlock ();
+ 	exit (code);
  }
  
  /*
Index: useradd.c
*** rel3/useradd.c	Fri Mar 27 10:25:30 1992
--- useradd.c	Fri Mar 27 10:27:24 1992
***************
*** 1,5 ****
  /*
!  * Copyright 1991, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
--- 1,5 ----
  /*
!  * Copyright 1991, 1992, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
***************
*** 10,16 ****
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)useradd.c	3.8	19:40:07	12/28/91";
  #endif
  
  #include "config.h"
--- 10,16 ----
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)useradd.c	3.9	09:41:30	3/19/92";
  #endif
  
  #include "config.h"
***************
*** 52,57 ****
--- 52,65 ----
  #define	NGROUPS_MAX	64
  #endif
  
+ #if !defined(MDY_DATE) && !defined(DMY_DATE) && !defined(YMD_DATE)
+ #define	MDY_DATE	1
+ #endif
+ #if (defined (MDY_DATE) && (defined (DMY_DATE) || defined (YMD_DATE))) || \
+     (defined (DMY_DATE) && (defined (MDY_DATE) || defined (YMD_DATE)))
+ Error: You must only define one of MDY_DATE, DMY_DATE, or YMD_DATE
+ #endif
+ 
  #define	VALID(s)	(strcspn (s, ":\n") == strlen (s))
  
  char	user_name[BUFSIZ];
***************
*** 221,233 ****
  	long	total;
  
  	/*
! 	 * start by separating the month, day and year.  this is
! 	 * a chauvanistic program - it only takes date input in
! 	 * the standard USA format.
  	 */
  
  	if (sscanf (str, "%d/%d/%d%c", &month, &day, &year, slop) != 3)
  		return -1;
  
  	/*
  	 * the month, day of the month, and year are checked for
--- 229,250 ----
  	long	total;
  
  	/*
! 	 * start by separating the month, day and year.  the order
! 	 * is compiled in ...
  	 */
  
+ #ifdef	MDY_DATE
  	if (sscanf (str, "%d/%d/%d%c", &month, &day, &year, slop) != 3)
  		return -1;
+ #endif
+ #ifdef	DMY_DATE
+ 	if (sscanf (str, "%d/%d/%d%c", &day, &month, &year, slop) != 3)
+ 		return -1;
+ #endif
+ #ifdef	YMD_DATE
+ 	if (sscanf (str, "%d/%d/%d%c", &year, &month, &day, slop) != 3)
+ 		return -1;
+ #endif
  
  	/*
  	 * the month, day of the month, and year are checked for
***************
*** 643,651 ****
  		"usage:\t%s [-u uid [-o]] [-g group] [-G group,...] \n", Prog);
  	fprintf (stderr,
  		"\t\t[-d home] [-s shell] [-c comment] [-m [-k template]]\n");
  	fprintf (stderr,
! 		"\t\t[-f inactive] [-e expire] name\n");
! 
  	fprintf (stderr,
  		"\t%s -D [-g group] [-b base] [-f inactive] [-e expire]\n",
  			Prog);
--- 660,677 ----
  		"usage:\t%s [-u uid [-o]] [-g group] [-G group,...] \n", Prog);
  	fprintf (stderr,
  		"\t\t[-d home] [-s shell] [-c comment] [-m [-k template]]\n");
+ #ifdef	MDY_DATE
  	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire mm/dd/yy ] name\n");
! #endif
! #ifdef	DMY_DATE
! 	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire dd/mm/yy ] name\n");
! #endif
! #ifdef	YMD_DATE
! 	fprintf (stderr,
! 		"\t\t[-f inactive ] [-e expire yy/mm/dd ] name\n");
! #endif
  	fprintf (stderr,
  		"\t%s -D [-g group] [-b base] [-f inactive] [-e expire]\n",
  			Prog);
***************
*** 778,784 ****
  				Prog);
  			exit (1);
  		}
- 		endgrent ();
  #endif
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "add `%s' to group `%s'\n",
--- 804,809 ----
***************
*** 785,790 ****
--- 810,818 ----
  			user_name, grp->gr_name);
  #endif
  	}
+ #ifdef NDBM
+ 	endgrent ();
+ #endif
  
  #ifdef	SHADOWGRP
  	/*
***************
*** 831,837 ****
  				Prog);
  			exit (1);
  		}
- 		endsgent ();
  #endif
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "add `%s' to shadow group `%s'\n",
--- 859,864 ----
***************
*** 838,843 ****
--- 865,873 ----
  			user_name, sgrp->sg_name);
  #endif
  	}
+ #ifdef NDBM
+ 	endsgent ();
+ #endif
  #endif
  }
  
Index: userdel.c
*** rel3/userdel.c	Fri Mar 27 10:24:23 1992
--- userdel.c	Fri Mar 27 10:27:27 1992
***************
*** 1,5 ****
  /*
!  * Copyright 1991, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
--- 1,5 ----
  /*
!  * Copyright 1991, 1992, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
***************
*** 10,16 ****
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)userdel.c	3.9	14:38:36	10/27/91";
  #endif
  
  #include <sys/types.h>
--- 10,16 ----
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)userdel.c	3.10	09:41:48	3/19/92";
  #endif
  
  #include <sys/types.h>
***************
*** 163,169 ****
  	struct	group	*grp;
  #ifdef	SHADOWGRP
  	struct	sgrp	*sgrp;
! #endif
  
  	/*
  	 * Scan through the entire group file looking for the groups that
--- 163,169 ----
  	struct	group	*grp;
  #ifdef	SHADOWGRP
  	struct	sgrp	*sgrp;
! #endif	/* SHADOWGRP */
  
  	/*
  	 * Scan through the entire group file looking for the groups that
***************
*** 190,218 ****
  		 */
  
  		grp->gr_mem = del_list (grp->gr_mem, user_name);
! 		if (! gr_update (grp)) {
  			fprintf (stderr, "%s: error updating group entry\n",
  				Prog);
! 			exit (1);
! 		}
  		/*
  		 * Update the DBM group file with the new entry as well.
  		 */
  
  #ifdef	NDBM
! 		if (! gr_dbm_update (grp)) {
  			fprintf (stderr, "%s: cannot update dbm group entry\n",
  				Prog);
- 			exit (1);
- 		}
- 		endgrent ();
  #endif	/* NDBM */
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "delete `%s' from group `%s'\n",
  			user_name, grp->gr_name);
! #endif
  	}
! 
  #ifdef	SHADOWGRP
  	/*
  	 * Scan through the entire shadow group file looking for the groups
--- 190,216 ----
  		 */
  
  		grp->gr_mem = del_list (grp->gr_mem, user_name);
! 		if (! gr_update (grp))
  			fprintf (stderr, "%s: error updating group entry\n",
  				Prog);
! 
  		/*
  		 * Update the DBM group file with the new entry as well.
  		 */
  
  #ifdef	NDBM
! 		if (! gr_dbm_update (grp))
  			fprintf (stderr, "%s: cannot update dbm group entry\n",
  				Prog);
  #endif	/* NDBM */
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "delete `%s' from group `%s'\n",
  			user_name, grp->gr_name);
! #endif	/* USE_SYSLOG */
  	}
! #ifdef	NDBM
! 	endgrent ();
! #endif	/* NDBM */
  #ifdef	SHADOWGRP
  	/*
  	 * Scan through the entire shadow group file looking for the groups
***************
*** 247,275 ****
  		if (! group_changed)
  			continue;
  
! 		if (! sgr_update (sgrp)) {
  			fprintf (stderr, "%s: error updating group entry\n",
  				Prog);
- 			exit (1);
- 		}
  #ifdef	NDBM
  		/*
  		 * Update the DBM group file with the new entry as well.
  		 */
  
! 		if (! sgr_dbm_update (sgrp)) {
  			fprintf (stderr, "%s: cannot update dbm group entry\n",
  				Prog);
! 			exit (1);
! 		}
! 		endsgent ();
! #endif
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "delete `%s' from shadow group `%s'\n",
  			user_name, sgrp->sg_name);
! #endif
  	}
! #endif
  }
  
  /*
--- 245,271 ----
  		if (! group_changed)
  			continue;
  
! 		if (! sgr_update (sgrp))
  			fprintf (stderr, "%s: error updating group entry\n",
  				Prog);
  #ifdef	NDBM
  		/*
  		 * Update the DBM group file with the new entry as well.
  		 */
  
! 		if (! sgr_dbm_update (sgrp))
  			fprintf (stderr, "%s: cannot update dbm group entry\n",
  				Prog);
! #endif	/* NDBM */
  #ifdef	USE_SYSLOG
  		syslog (LOG_INFO, "delete `%s' from shadow group `%s'\n",
  			user_name, sgrp->sg_name);
! #endif	/* USE_SYSLOG */
  	}
! #ifdef	NDBM
! 	endsgent ();
! #endif	/* NDBM */
! #endif	/* SHADOWGRP */
  }
  
  /*
***************
*** 281,307 ****
  
  close_files ()
  {
! 	if (! pw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite password file\n", Prog);
! 		exit (1);
! 	}
! 	if (! spw_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow password file\n",	
  			Prog);
! 		exit (1);
! 	}
! 	if (! gr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite group file\n",
  			Prog);
! 		exit (10);
! 	}
  	(void) gr_unlock ();
  #ifdef	SHADOWGRP
! 	if (! sgr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  			Prog);
! 		exit (10);
! 	}
  	(void) sgr_unlock ();
  #endif
  	(void) spw_unlock ();
--- 277,299 ----
  
  close_files ()
  {
! 	if (! pw_close ())
  		fprintf (stderr, "%s: cannot rewrite password file\n", Prog);
! 
! 	if (! spw_close ())
  		fprintf (stderr, "%s: cannot rewrite shadow password file\n",	
  			Prog);
! 
! 	if (! gr_close ())
  		fprintf (stderr, "%s: cannot rewrite group file\n",
  			Prog);
! 
  	(void) gr_unlock ();
  #ifdef	SHADOWGRP
! 	if (! sgr_close ())
  		fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  			Prog);
! 
  	(void) sgr_unlock ();
  #endif
  	(void) spw_unlock ();
***************
*** 322,353 ****
  	}
  	if (! pw_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open password file\n", Prog);
! 		exit (1);
  	}
  	if (! spw_lock ()) {
  		fprintf (stderr, "%s: cannot lock shadow password file\n", Prog);
! 		exit (1);
  	}
  	if (! spw_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open shadow password file\n", Prog);
! 		exit (1);
  	}
  	if (! gr_lock ()) {
  		fprintf (stderr, "%s: unable to lock group file\n", Prog);
! 		exit (1);
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open group file\n", Prog);
! 		exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: unable to lock shadow group file\n", Prog);
! 		exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open shadow group file\n", Prog);
! 		exit (1);
  	}
  #endif
  }
--- 314,345 ----
  	}
  	if (! pw_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open password file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! spw_lock ()) {
  		fprintf (stderr, "%s: cannot lock shadow password file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! spw_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open shadow password file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! gr_lock ()) {
  		fprintf (stderr, "%s: unable to lock group file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open group file\n", Prog);
! 		fail_exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: unable to lock shadow group file\n", Prog);
! 		fail_exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: cannot open shadow group file\n", Prog);
! 		fail_exit (1);
  	}
  #endif
  }
***************
*** 376,383 ****
  			fprintf (stderr,
  				"%s: error deleting password dbm entry\n",
  				Prog);
- 
- 		endpwent ();
  	}
  
  	/*
--- 368,373 ----
***************
*** 389,395 ****
  	for (pw_rewind (), pwd = pw_next ();pwd;pwd = pw_next ()) {
  		if (pwd->pw_uid == user_id) {
  			pw_dbm_update (pwd);
- 			endpwent ();
  			break;
  		}
  	}
--- 379,384 ----
***************
*** 401,409 ****
--- 390,417 ----
  
  	endspent ();
  #endif
+ #if defined(DBM) || defined(NDBM)
+ 	endpwent ();
+ #endif
  #ifdef	USE_SYSLOG
  	syslog (LOG_INFO, "delete user `%s'\n", user_name);
  #endif
+ }
+ 
+ /*
+  * fail_exit - exit with a failure code after unlocking the files
+  */
+ 
+ fail_exit (code)
+ int	code;
+ {
+ 	(void) pw_unlock ();
+ 	(void) gr_unlock ();
+ 	(void) spw_unlock ();
+ #ifdef	SHADOWGRP
+ 	(void) sgr_unlock ();
+ #endif
+ 	exit (code);
  }
  
  /*
Index: groupadd.c
*** rel3/groupadd.c	Fri Mar 27 10:24:11 1992
--- groupadd.c	Fri Mar 27 10:27:29 1992
***************
*** 1,5 ****
  /*
!  * Copyright 1991, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
--- 1,5 ----
  /*
!  * Copyright 1991, 1992, John F. Haugh II
   * All rights reserved.
   *
   * Permission is granted to copy and create derivative works for any
***************
*** 10,16 ****
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)groupadd.c	3.3	08:43:44	9/12/91";
  #endif
  
  #include <sys/types.h>
--- 10,16 ----
   */
  
  #ifndef lint
! static	char	sccsid[] = "@(#)groupadd.c	3.4	09:41:21	3/19/92";
  #endif
  
  #include <sys/types.h>
***************
*** 140,146 ****
  
  	if (! gr_update (&grp)) {
  		fprintf (stderr, "%s: error adding new group entry\n", Prog);
! 		exit (1);
  	}
  #ifdef	NDBM
  
--- 140,146 ----
  
  	if (! gr_update (&grp)) {
  		fprintf (stderr, "%s: error adding new group entry\n", Prog);
! 		fail_exit (1);
  	}
  #ifdef	NDBM
  
***************
*** 150,156 ****
  
  	if (! gr_dbm_update (&grp)) {
  		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
! 		exit (1);
  	}
  	endgrent ();
  #endif	/* NDBM */
--- 150,156 ----
  
  	if (! gr_dbm_update (&grp)) {
  		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
! 		fail_exit (1);
  	}
  	endgrent ();
  #endif	/* NDBM */
***************
*** 163,169 ****
  
  	if (! sgr_update (&sgrp)) {
  		fprintf (stderr, "%s: error adding new group entry\n", Prog);
! 		exit (1);
  	}
  #ifdef	NDBM
  
--- 163,169 ----
  
  	if (! sgr_update (&sgrp)) {
  		fprintf (stderr, "%s: error adding new group entry\n", Prog);
! 		fail_exit (1);
  	}
  #ifdef	NDBM
  
***************
*** 173,179 ****
  
  	if (! sgr_dbm_update (&sgrp)) {
  		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
! 		exit (1);
  	}
  	endsgent ();
  #endif	/* NDBM */
--- 173,179 ----
  
  	if (! sgr_dbm_update (&sgrp)) {
  		fprintf (stderr, "%s: cannot add new dbm group entry\n", Prog);
! 		fail_exit (1);
  	}
  	endsgent ();
  #endif	/* NDBM */
***************
*** 215,226 ****
  		if (strcmp (group_name, grp->gr_name) == 0) {
  			fprintf (stderr, "%s: name %s is not unique\n",
  				Prog, group_name);
! 			exit (1);
  		}
  		if (gflg && group_id == grp->gr_gid) {
  			fprintf (stderr, "%s: gid %d is not unique\n",
  				Prog, group_id);
! 			exit (1);
  		}
  		if (! gflg && grp->gr_gid >= group_id)
  			group_id = grp->gr_gid + 1;
--- 215,226 ----
  		if (strcmp (group_name, grp->gr_name) == 0) {
  			fprintf (stderr, "%s: name %s is not unique\n",
  				Prog, group_name);
! 			fail_exit (1);
  		}
  		if (gflg && group_id == grp->gr_gid) {
  			fprintf (stderr, "%s: gid %d is not unique\n",
  				Prog, group_id);
! 			fail_exit (1);
  		}
  		if (! gflg && grp->gr_gid >= group_id)
  			group_id = grp->gr_gid + 1;
***************
*** 256,262 ****
  				if (*end != '\0') {
  					fprintf (stderr, "%s: invalid group %s\n",
  						Prog, optarg);
! 					exit (3);
  				}
  				break;
  			case 'o':
--- 256,262 ----
  				if (*end != '\0') {
  					fprintf (stderr, "%s: invalid group %s\n",
  						Prog, optarg);
! 					fail_exit (3);
  				}
  				break;
  			case 'o':
***************
*** 269,277 ****
  				usage ();
  		}
  	}
- 	if (! gflg)
- 		find_new_gid ();
- 
  	if (optind == argc - 1)
  		strcpy (group_name, argv[argc - 1]);
  	else
--- 269,274 ----
***************
*** 289,295 ****
  {
  	if (! gr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite group file\n", Prog);
! 		exit (1);
  	}
  	(void) gr_unlock ();
  #ifdef	SHADOWGRP
--- 286,292 ----
  {
  	if (! gr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite group file\n", Prog);
! 		fail_exit (1);
  	}
  	(void) gr_unlock ();
  #ifdef	SHADOWGRP
***************
*** 296,302 ****
  	if (! sgr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  			Prog);
! 		exit (1);
  	}
  	(void) sgr_unlock ();
  #endif	/* SHADOWGRP */
--- 293,299 ----
  	if (! sgr_close ()) {
  		fprintf (stderr, "%s: cannot rewrite shadow group file\n",
  			Prog);
! 		fail_exit (1);
  	}
  	(void) sgr_unlock ();
  #endif	/* SHADOWGRP */
***************
*** 316,338 ****
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open group file\n", Prog);
! 		exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: unable to lock shadow group file\n",
  			Prog);
! 		exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open shadow group file\n",
  			Prog);
! 		exit (1);
  	}
  #endif	/* SHADOWGRP */
  }
  
  /*
   * main - useradd command
   */
  
--- 313,349 ----
  	}
  	if (! gr_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open group file\n", Prog);
! 		fail_exit (1);
  	}
  #ifdef	SHADOWGRP
  	if (! sgr_lock ()) {
  		fprintf (stderr, "%s: unable to lock shadow group file\n",
  			Prog);
! 		fail_exit (1);
  	}
  	if (! sgr_open (O_RDWR)) {
  		fprintf (stderr, "%s: unable to open shadow group file\n",
  			Prog);
! 		fail_exit (1);
  	}
  #endif	/* SHADOWGRP */
  }
  
  /*
+  * fail_exit - exit with an error code after unlocking files
+  */
+ 
+ fail_exit (code)
+ int	code;
+ {
+ 	(void) gr_unlock ();
+ #ifdef	SHADOWGRP
+ 	(void) sgr_unlock ();
+ #endif
+ 	exit (code);
+ }
+ 
+ /*
   * main - useradd command
   */
  
***************
*** 382,387 ****
--- 393,400 ----
  	 */
  
  	open_files ();
+ 	if (! gflg)
+ 		find_new_gid ();
  
  	grp_update ();
  
Index: chage.1
*** rel3/chage.1	Fri Mar 27 10:24:28 1992
--- chage.1	Fri Mar 27 10:27:34 1992
***************
*** 4,36 ****
  .\" Use, duplication, and disclosure prohibited without
  .\" the express written permission of the author.
  .\"
! .\"	@(#)chage.1	3.1	09:34:14	11/21/90
  .\"
  .TH CHAGE 1
  .SH NAME
  chage \- change user password expirate information
  .SH SYNOPSIS
! \fBchage\fR [ \fB-m \fImindays\fR ] [ \fB-M \fImaxdays\fR ] [ \fB-d \fIlastday\fR ] \fIuser\fR
  .SH DESCRIPTION
  \fIchage\f changes the number of days between password changes and the
  date of the last password change.
  This information is used by the system to determine when a user must
! change their password.
! The \fIchage\f command is restricted to the root user.
  .PP
! The value of \fImindays\f is the minimum number of days between
! password changes.
  A value of zero for this field indicates that the user may change
  her password at any time.
  .PP
! The value of \fImaxdays\f is the maximum number of days during
! which a password is valid.
! When \fImaxdays\f plus \fIlastday\f is less than the current day,
  the user will be required to change her password before being
  able to use her account.
  .PP
! The value of \fIlastday\f is the number of days since January 1st,
! 1970 when the password was last changed.
  .PP
  All of the above values are stored exactly as days when the shadow
  password file is used, but are converted to and from weeks when the
--- 4,67 ----
  .\" Use, duplication, and disclosure prohibited without
  .\" the express written permission of the author.
  .\"
! .\"	@(#)chage.1	3.2	10:04:46	3/27/92
  .\"
  .TH CHAGE 1
  .SH NAME
  chage \- change user password expirate information
  .SH SYNOPSIS
! \fBchage\fR [ \fB-m \fImindays\fR ] [ \fB-M \fImaxdays\fR ]
! [ \fB-d \fIlastday\fR ] [ \fB-I \fIinactive\fR ]
! [ \fB-E \fIexpiredate\fR ] [ \fB-W \fIwarndays\fR ] \fIuser\fR
! .sp 1
! \fBchage\fR -l \fIuser\fR
  .SH DESCRIPTION
  \fIchage\f changes the number of days between password changes and the
  date of the last password change.
  This information is used by the system to determine when a user must
! change her password.
! The \fIchage\f command is restricted to the root user, except for the
! \fB-l\fR option, which may be used by an unprivileged user to determine
! when her password or account is due to expire.
  .PP
! With the \fB-m\fR option, the value of \fImindays\f is the minimum number
! of days between password changes.
  A value of zero for this field indicates that the user may change
  her password at any time.
  .PP
! With the \fB-M\fR option, the value of \fImaxdays\f is the maximum number
! of days during which a password is valid.
! When \fImaxdays\fR plus \fIlastday\fR is less than the current day,
  the user will be required to change her password before being
  able to use her account.
+ This occurance can be planned for in advance by use of the \fB-W\fR option,
+ which provides the user with advance warning.
  .PP
! With the \fB-d\fR option, the value of \fIlastday\f is the number of days
! since January 1st, 1970 when the password was last changed.
! The date may also be expressed in the format MM/DD/YY (or the format more
! commonly used in your area).
! .PP
! The \fB-E\fR option is used to set a date on which the user's account will
! no longer be accessible.
! The \fIexpiredate\fR option is the number of days since January 1, 1970 on
! which the accounted is locked.
! The date may also be expressed in the format MM/DD/YY (or the format more
! commonly used in your area).
! A user whose account is locked must contact the system administrator before
! being able to use the system again.
! .PP
! The \fB-I\fR option is used to set the number of days of inactivity after
! a password has expired before the account is locked.
! A user whose account is locked must contact the system administrator before
! being able to use the system again.
! The \fIinactive\fR option is the number of days of inactivity. A value of
! 0 disables this feature.
! .PP
! The \fB-W\fR option is used to set the number of days of warning before a
! password change is required.
! The \fIwarndays\fR option is the number of days prior to the password
! expiring that a user will be warned her password is about to expire.
  .PP
  All of the above values are stored exactly as days when the shadow
  password file is used, but are converted to and from weeks when the
-- 
John F. Haugh II        | Every 56 days.   | UUCP: ...!cs.utexas.edu!rpp386!jfh
Ma Bell: (512) 251-2151 | Give Blood, often.    | Domain: jfh@rpp386.cactus.org
"A countryman between two lawyers is like a fish between two cats."
		-- Benjamin Franklin

exit 0 # Just in case...
