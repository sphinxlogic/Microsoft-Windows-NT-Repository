Newsgroups: comp.sources.misc
From: jpeg-info@uunet.uu.net (Independent JPEG Group)
Subject:  v29i004:  jpeg - JPEG image compression, Part04/18
Message-ID: <1992Mar24.144329.18084@sparky.imd.sterling.com>
X-Md4-Signature: ceaf659f06ce5914d57baf5307e882bd
Date: Tue, 24 Mar 1992 14:43:29 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jpeg-info@uunet.uu.net (Independent JPEG Group)
Posting-number: Volume 29, Issue 4
Archive-name: jpeg/part04
Environment: UNIX, VMS, MS-DOS, Mac, Amiga, Cray

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  jpegdata.h jwrgif.c makcjpeg.lnk
# Wrapped by kent@sparky on Mon Mar 23 16:02:42 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 18)."'
if test -f 'jpegdata.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jpegdata.h'\"
else
  echo shar: Extracting \"'jpegdata.h'\" \(37381 characters\)
  sed "s/^X//" >'jpegdata.h' <<'END_OF_FILE'
X/*
X * jpegdata.h
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file defines shared data structures for the various JPEG modules.
X */
X
X
X/*
X * You might need to change some of the following declarations if you are
X * using the JPEG software within a surrounding application program
X * or porting it to an unusual system.
X */
X
X
X/* If the source or destination of image data is not to be stdio streams,
X * these types may need work.  You can replace them with some kind of
X * pointer or indicator that is useful to you, or just ignore 'em.
X * Note that the user interface and the various jrdxxx/jwrxxx modules
X * will also need work for non-stdio input/output.
X */
X
Xtypedef FILE * JFILEREF;	/* source or dest of JPEG-compressed data */
X
Xtypedef FILE * IFILEREF;	/* source or dest of non-JPEG image data */
X
X
X/* These defines are used in all function definitions and extern declarations.
X * You could modify them if you need to change function linkage conventions,
X * as is shown below for use with C++.  Another application would be to make
X * all functions global for use with code profilers that require it.
X * NOTE: the C++ test does the right thing if you are reading this include
X * file in a C++ application to link to JPEG code that's been compiled with a
X * regular C compiler.  I'm not sure it works if you try to compile the JPEG
X * code with C++.
X */
X
X#define METHODDEF static	/* a function called through method pointers */
X#define LOCAL	  static	/* a function used only in its module */
X#define GLOBAL			/* a function referenced thru EXTERNs */
X#ifdef __cplusplus
X#define EXTERN	  extern "C"	/* a reference to a GLOBAL function */
X#else
X#define EXTERN	  extern	/* a reference to a GLOBAL function */
X#endif
X
X
X/* Here is the pseudo-keyword for declaring pointers that must be "far"
X * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
X * by just saying "FAR *" where such a pointer is needed.  In a few places
X * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
X */
X
X#ifdef NEED_FAR_POINTERS
X#define FAR  far
X#else
X#define FAR
X#endif
X
X
X
X/* The remaining declarations are not system-dependent, we hope. */
X
X
X/*
X * NOTE: if you have an ancient, strict-K&R C compiler, it may choke on the
X * similarly-named fields in compress_info_struct and decompress_info_struct.
X * If this happens, you can get around it by rearranging the two structs so
X * that the similarly-named fields appear first and in the same order in
X * each struct.  Since such compilers are now pretty rare, we haven't done
X * this in the portable code, preferring to maintain a logical ordering.
X */
X
X
X
X/* This macro is used to declare a "method", that is, a function pointer. */
X/* We want to supply prototype parameters if the compiler can cope. */
X/* Note that the arglist parameter must be parenthesized! */
X
X#ifdef PROTO
X#define METHOD(type,methodname,arglist)  type (*methodname) arglist
X#else
X#define METHOD(type,methodname,arglist)  type (*methodname) ()
X#endif
X
X/* Forward references to lists of method pointers */
Xtypedef struct external_methods_struct * external_methods_ptr;
Xtypedef struct compress_methods_struct * compress_methods_ptr;
Xtypedef struct decompress_methods_struct * decompress_methods_ptr;
X
X
X/* Data structures for images containing either samples or coefficients. */
X/* Note that the topmost (leftmost) index is always color component. */
X/* On 80x86 machines, the image arrays are too big for near pointers, */
X/* but the pointer arrays can fit in near memory. */
X
Xtypedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
Xtypedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
Xtypedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
X
X
X#define DCTSIZE		8	/* The basic DCT block is 8x8 samples */
X#define DCTSIZE2	64	/* DCTSIZE squared; # of elements in a block */
X
Xtypedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
Xtypedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
Xtypedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
Xtypedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
X
Xtypedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
X
X
X/* The input and output data of the DCT transform subroutines are of
X * the following type, which need not be the same as JCOEF.
X * For example, on a machine with fast floating point, it might make sense
X * to recode the DCT routines to use floating point; then DCTELEM would be
X * 'float' or 'double'.
X */
X
Xtypedef JCOEF DCTELEM;
Xtypedef DCTELEM DCTBLOCK[DCTSIZE2];
X
X
X/* Types for JPEG compression parameters and working tables. */
X
X
Xtypedef enum {			/* defines known color spaces */
X	CS_UNKNOWN,		/* error/unspecified */
X	CS_GRAYSCALE,		/* monochrome (only 1 component) */
X	CS_RGB,			/* red/green/blue */
X	CS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
X	CS_YIQ,			/* Y/I/Q */
X	CS_CMYK			/* C/M/Y/K */
X} COLOR_SPACE;
X
X
Xtypedef struct {		/* Basic info about one component */
X  /* These values are fixed over the whole image */
X  /* For compression, they must be supplied by the user interface; */
X  /* for decompression, they are read from the SOF marker. */
X	short component_id;	/* identifier for this component (0..255) */
X	short component_index;	/* its index in SOF or cinfo->comp_info[] */
X	short h_samp_factor;	/* horizontal sampling factor (1..4) */
X	short v_samp_factor;	/* vertical sampling factor (1..4) */
X	short quant_tbl_no;	/* quantization table selector (0..3) */
X  /* These values may vary between scans */
X  /* For compression, they must be supplied by the user interface; */
X  /* for decompression, they are read from the SOS marker. */
X	short dc_tbl_no;	/* DC entropy table selector (0..3) */
X	short ac_tbl_no;	/* AC entropy table selector (0..3) */
X  /* These values are computed during compression or decompression startup */
X	long true_comp_width;	/* component's image width in samples */
X	long true_comp_height;	/* component's image height in samples */
X	/* the above are the logical dimensions of the subsampled image */
X  /* These values are computed before starting a scan of the component */
X	short MCU_width;	/* number of blocks per MCU, horizontally */
X	short MCU_height;	/* number of blocks per MCU, vertically */
X	short MCU_blocks;	/* MCU_width * MCU_height */
X	long subsampled_width;	/* image width in samples, after expansion */
X	long subsampled_height;	/* image height in samples, after expansion */
X	/* the above are the true_comp_xxx values rounded up to multiples of */
X	/* the MCU dimensions; these are the working dimensions of the array */
X	/* as it is passed through the DCT or IDCT step.  NOTE: these values */
X	/* differ depending on whether the component is interleaved or not!! */
X} jpeg_component_info;
X
X
X/* DCT coefficient quantization tables.
X * For 8-bit precision, 'INT16' should be good enough for quantization values;
X * for more precision, we go for the full 16 bits.  'INT16' provides a useful
X * speedup on many machines (multiplication & division of JCOEFs by
X * quantization values is a significant chunk of the runtime).
X * Note: the values in a QUANT_TBL are always given in zigzag order.
X */
X#ifdef EIGHT_BIT_SAMPLES
Xtypedef INT16 QUANT_VAL;	/* element of a quantization table */
X#else
Xtypedef UINT16 QUANT_VAL;	/* element of a quantization table */
X#endif
Xtypedef QUANT_VAL QUANT_TBL[DCTSIZE2];	/* A quantization table */
Xtypedef QUANT_VAL * QUANT_TBL_PTR;	/* pointer to same */
X
X
Xtypedef struct {		/* A Huffman coding table */
X  /* These two fields directly represent the contents of a JPEG DHT marker */
X	UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
X				/* length k bits; bits[0] is unused */
X	UINT8 huffval[256];	/* The symbols, in order of incr code length */
X  /* This field is used only during compression.  It's initialized FALSE when
X   * the table is created, and set TRUE when it's been output to the file.
X   */
X	boolean sent_table;	/* TRUE when table has been output */
X  /* The remaining fields are computed from the above to allow more efficient
X   * coding and decoding.  These fields should be considered private to the
X   * Huffman compression & decompression modules.
X   */
X	/* encoding tables: */
X	UINT16 ehufco[256];	/* code for each symbol */
X	char ehufsi[256];	/* length of code for each symbol */
X	/* decoding tables: (element [0] of each array is unused) */
X	UINT16 mincode[17];	/* smallest code of length k */
X	INT32 maxcode[18];	/* largest code of length k (-1 if none) */
X	/* (maxcode[17] is a sentinel to ensure huff_DECODE terminates) */
X	short valptr[17];	/* huffval[] index of 1st symbol of length k */
X} HUFF_TBL;
X
X
X#define NUM_QUANT_TBLS      4	/* quantization tables are numbered 0..3 */
X#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
X#define NUM_ARITH_TBLS      16	/* arith-coding tables are numbered 0..15 */
X#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
X#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
X#define MAX_BLOCKS_IN_MCU   10	/* JPEG limit on # of blocks in an MCU */
X
X
X/* Working data for compression */
X
Xstruct compress_info_struct {
X/*
X * All of these fields shall be established by the user interface before
X * calling jpeg_compress, or by the input_init or c_ui_method_selection
X * methods.
X * Most parameters can be set to reasonable defaults by j_c_defaults.
X * Note that the UI must supply the storage for the main methods struct,
X * though it sets only a few of the methods there.
X */
X	compress_methods_ptr methods; /* Points to list of methods to use */
X
X	external_methods_ptr emethods; /* Points to list of methods to use */
X
X	IFILEREF input_file;	/* tells input routines where to read image */
X	JFILEREF output_file;	/* tells output routines where to write JPEG */
X
X	long image_width;	/* input image width */
X	long image_height;	/* input image height */
X	short input_components;	/* # of color components in input image */
X
X	short data_precision;	/* bits of precision in image data */
X
X	COLOR_SPACE in_color_space; /* colorspace of input file */
X	COLOR_SPACE jpeg_color_space; /* colorspace of JPEG file */
X
X	double input_gamma;	/* image gamma of input file */
X
X	boolean write_JFIF_header; /* should a JFIF marker be written? */
X	/* These three values are not used by the JPEG code, only copied */
X	/* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
X	/* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
X	/* ratio is defined by X_density/Y_density even when density_unit=0. */
X	UINT8 density_unit;	/* JFIF code for pixel size units */
X	UINT16 X_density;	/* Horizontal pixel density */
X	UINT16 Y_density;	/* Vertical pixel density */
X
X	short num_components;	/* # of color components in JPEG image */
X	jpeg_component_info * comp_info;
X	/* comp_info[i] describes component that appears i'th in SOF */
X
X	QUANT_TBL_PTR quant_tbl_ptrs[NUM_QUANT_TBLS];
X	/* ptrs to coefficient quantization tables, or NULL if not defined */
X
X	HUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
X	HUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
X	/* ptrs to Huffman coding tables, or NULL if not defined */
X
X	UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arithmetic-coding tables */
X	UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arithmetic-coding tables */
X	UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arithmetic-coding tables */
X
X	boolean arith_code;	/* TRUE=arithmetic coding, FALSE=Huffman */
X	boolean interleave;	/* TRUE=interleaved output, FALSE=not */
X	boolean optimize_coding; /* TRUE=optimize entropy encoding parms */
X	boolean CCIR601_sampling; /* TRUE=first samples are cosited */
X
X	UINT16 restart_interval;/* MDUs per restart interval, or 0 for no restart */
X
X/*
X * These fields are computed during jpeg_compress startup
X */
X	short max_h_samp_factor; /* largest h_samp_factor */
X	short max_v_samp_factor; /* largest v_samp_factor */
X
X/*
X * These fields may be useful for progress monitoring
X */
X
X	int total_passes;	/* number of passes expected */
X	int completed_passes;	/* number of passes completed so far */
X
X/*
X * These fields are valid during any one scan
X */
X	short comps_in_scan;	/* # of JPEG components output this time */
X	jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
X	/* *cur_comp_info[i] describes component that appears i'th in SOS */
X
X	long MCUs_per_row;	/* # of MCUs across the image */
X	long MCU_rows_in_scan;	/* # of MCU rows in the image */
X
X	short blocks_in_MCU;	/* # of DCT blocks per MCU */
X	short MCU_membership[MAX_BLOCKS_IN_MCU];
X	/* MCU_membership[i] is index in cur_comp_info of component owning */
X	/* i'th block in an MCU */
X
X	/* these fields are private data for the entropy encoder */
X	JCOEF last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each comp */
X	JCOEF last_dc_diff[MAX_COMPS_IN_SCAN]; /* last DC diff for each comp */
X	UINT16 restarts_to_go;	/* MDUs left in this restart interval */
X	short next_restart_num;	/* # of next RSTn marker (0..7) */
X};
X
Xtypedef struct compress_info_struct * compress_info_ptr;
X
X
X/* Working data for decompression */
X
Xstruct decompress_info_struct {
X/*
X * These fields shall be established by the user interface before
X * calling jpeg_decompress.
X * Most parameters can be set to reasonable defaults by j_d_defaults.
X * Note that the UI must supply the storage for the main methods struct,
X * though it sets only a few of the methods there.
X */
X	decompress_methods_ptr methods; /* Points to list of methods to use */
X
X	external_methods_ptr emethods; /* Points to list of methods to use */
X
X	JFILEREF input_file;	/* tells input routines where to read JPEG */
X	IFILEREF output_file;	/* tells output routines where to write image */
X
X	/* these can be set at d_ui_method_selection time: */
X
X	COLOR_SPACE out_color_space; /* colorspace of output */
X
X	double output_gamma;	/* image gamma wanted in output */
X
X	boolean quantize_colors; /* T if output is a colormapped format */
X	/* the following are ignored if not quantize_colors: */
X	boolean two_pass_quantize;	/* use two-pass color quantization? */
X	boolean use_dithering;		/* want color dithering? */
X	int desired_number_of_colors;	/* max number of colors to use */
X
X	boolean do_block_smoothing; /* T = apply cross-block smoothing */
X	boolean do_pixel_smoothing; /* T = apply post-subsampling smoothing */
X
X/*
X * These fields are used for efficient buffering of data between read_jpeg_data
X * and the entropy decoding object.  By using a shared buffer, we avoid copying
X * data and eliminate the need for an "unget" operation at the end of a scan.
X * The actual source of the data is known only to read_jpeg_data; see the
X * JGETC macro, below.
X * Note: the user interface is expected to allocate the input_buffer and
X * initialize bytes_in_buffer to 0.  Also, for JFIF/raw-JPEG input, the UI
X * actually supplies the read_jpeg_data method.  This is all handled by
X * j_d_defaults in a typical implementation.
X */
X	char * input_buffer;	/* start of buffer (private to input code) */
X	char * next_input_byte;	/* => next byte to read from buffer */
X	int bytes_in_buffer;	/* # of bytes remaining in buffer */
X
X/*
X * These fields are set by read_file_header or read_scan_header
X */
X	long image_width;	/* overall image width */
X	long image_height;	/* overall image height */
X
X	short data_precision;	/* bits of precision in image data */
X
X	COLOR_SPACE jpeg_color_space; /* colorspace of JPEG file */
X
X        /* These three values are not used by the JPEG code, merely copied */
X	/* from the JFIF APP0 marker (if any). */
X	UINT8 density_unit;	/* JFIF code for pixel size units */
X	UINT16 X_density;	/* Horizontal pixel density */
X	UINT16 Y_density;	/* Vertical pixel density */
X
X	short num_components;	/* # of color components in JPEG image */
X	jpeg_component_info * comp_info;
X	/* comp_info[i] describes component that appears i'th in SOF */
X
X	QUANT_TBL_PTR quant_tbl_ptrs[NUM_QUANT_TBLS];
X	/* ptrs to coefficient quantization tables, or NULL if not defined */
X
X	HUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
X	HUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
X	/* ptrs to Huffman coding tables, or NULL if not defined */
X
X	UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
X	UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
X	UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
X
X	boolean arith_code;	/* TRUE=arithmetic coding, FALSE=Huffman */
X	boolean CCIR601_sampling; /* TRUE=first samples are cosited */
X
X	UINT16 restart_interval;/* MDUs per restart interval, or 0 for no restart */
X
X/*
X * These fields are computed during jpeg_decompress startup
X */
X	short max_h_samp_factor; /* largest h_samp_factor */
X	short max_v_samp_factor; /* largest v_samp_factor */
X
X	short color_out_comps;	/* # of color components output by color_convert */
X				/* (need not match num_components) */
X	short final_out_comps;	/* # of color components sent to put_pixel_rows */
X	/* (1 when quantizing colors, else same as color_out_comps) */
X
X/*
X * When quantizing colors, the color quantizer leaves a pointer to the output
X * colormap in these fields.  The colormap is valid from the time put_color_map
X * is called (must be before any put_pixel_rows calls) until shutdown (more
X * specifically, until free_all is called to release memory).
X */
X	int actual_number_of_colors; /* actual number of entries */
X	JSAMPARRAY colormap;	/* NULL if not valid */
X	/* map has color_out_comps rows * actual_number_of_colors columns */
X
X/*
X * These fields may be useful for progress monitoring
X */
X
X	int total_passes;	/* number of passes expected */
X	int completed_passes;	/* number of passes completed so far */
X
X/*
X * These fields are valid during any one scan
X */
X	short comps_in_scan;	/* # of JPEG components input this time */
X	jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
X	/* *cur_comp_info[i] describes component that appears i'th in SOS */
X
X	long MCUs_per_row;	/* # of MCUs across the image */
X	long MCU_rows_in_scan;	/* # of MCU rows in the image */
X
X	short blocks_in_MCU;	/* # of DCT blocks per MCU */
X	short MCU_membership[MAX_BLOCKS_IN_MCU];
X	/* MCU_membership[i] is index in cur_comp_info of component owning */
X	/* i'th block in an MCU */
X
X	/* these fields are private data for the entropy encoder */
X	JCOEF last_dc_val[MAX_COMPS_IN_SCAN]; /* last DC coef for each comp */
X	JCOEF last_dc_diff[MAX_COMPS_IN_SCAN]; /* last DC diff for each comp */
X	UINT16 restarts_to_go;	/* MDUs left in this restart interval */
X	short next_restart_num;	/* # of next RSTn marker (0..7) */
X};
X
Xtypedef struct decompress_info_struct * decompress_info_ptr;
X
X
X/* Macros for reading data from the decompression input buffer */
X
X#ifdef CHAR_IS_UNSIGNED
X#define JGETC(cinfo)	( --(cinfo)->bytes_in_buffer < 0 ? \
X			 (*(cinfo)->methods->read_jpeg_data) (cinfo) : \
X			 (int) (*(cinfo)->next_input_byte++) )
X#else
X#define JGETC(cinfo)	( --(cinfo)->bytes_in_buffer < 0 ? \
X			 (*(cinfo)->methods->read_jpeg_data) (cinfo) : \
X			 (int) (*(cinfo)->next_input_byte++) & 0xFF )
X#endif
X
X#define JUNGETC(ch,cinfo)  ((cinfo)->bytes_in_buffer++, \
X			    *(--((cinfo)->next_input_byte)) = (ch))
X
X#define MIN_UNGET	4	/* may always do at least 4 JUNGETCs */
X
X
X/* A virtual image has a control block whose contents are private to the
X * memory manager module (and may differ between managers).  The rest of the
X * code only refers to virtual images by these pointer types, and never
X * dereferences the pointer.
X */
X
Xtypedef struct big_sarray_control * big_sarray_ptr;
Xtypedef struct big_barray_control * big_barray_ptr;
X
X/* Although a real ANSI C compiler can deal perfectly well with pointers to
X * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
X * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
X * add -DINCOMPLETE_TYPES_BROKEN to CFLAGS in your Makefile.  Then we will
X * pseudo-define the structs as containing a single "dummy" field.
X * The memory managers #define AM_MEMORY_MANAGER before including this file,
X * so that they can make their own definitions of the structs.
X */
X
X#ifdef INCOMPLETE_TYPES_BROKEN
X#ifndef AM_MEMORY_MANAGER
Xstruct big_sarray_control { long dummy; };
Xstruct big_barray_control { long dummy; };
X#endif
X#endif
X
X
X/* Method types that need typedefs */
X
Xtypedef METHOD(void, MCU_output_method_ptr, (compress_info_ptr cinfo,
X					     JBLOCK *MCU_data));
Xtypedef METHOD(void, MCU_output_caller_ptr, (compress_info_ptr cinfo,
X					     MCU_output_method_ptr output_method));
Xtypedef METHOD(void, subsample_ptr, (compress_info_ptr cinfo,
X				     int which_component,
X				     long input_cols, int input_rows,
X				     long output_cols, int output_rows,
X				     JSAMPARRAY above,
X				     JSAMPARRAY input_data,
X				     JSAMPARRAY below,
X				     JSAMPARRAY output_data));
Xtypedef METHOD(void, unsubsample_ptr, (decompress_info_ptr cinfo,
X				       int which_component,
X				       long input_cols, int input_rows,
X				       long output_cols, int output_rows,
X				       JSAMPARRAY above,
X				       JSAMPARRAY input_data,
X				       JSAMPARRAY below,
X				       JSAMPARRAY output_data));
Xtypedef METHOD(void, quantize_method_ptr, (decompress_info_ptr cinfo,
X					   int num_rows,
X					   JSAMPIMAGE input_data,
X					   JSAMPARRAY output_workspace));
Xtypedef METHOD(void, quantize_caller_ptr, (decompress_info_ptr cinfo,
X					   quantize_method_ptr quantize_method));
X
X
X/* These structs contain function pointers for the various JPEG methods. */
X
X/* Routines to be provided by the surrounding application, rather than the
X * portable JPEG code proper.  These are the same for compression and
X * decompression.
X */
X
Xstruct external_methods_struct {
X	/* User interface: error exit and trace message routines */
X	/* NOTE: the string msgtext parameters will eventually be replaced */
X	/* by an enumerated-type code so that non-English error messages */
X	/* can be substituted easily.  This will not be done until all the */
X	/* code is in place, so that we know what messages are needed. */
X	METHOD(void, error_exit, (const char *msgtext));
X	METHOD(void, trace_message, (const char *msgtext));
X
X	/* Working data for error/trace facility */
X	/* See macros below for the usage of these variables */
X	int trace_level;	/* level of detail of tracing messages */
X	/* Use level 0 for unsuppressable messages (nonfatal errors) */
X	/* Use levels 1, 2, 3 for successively more detailed trace options */
X
X	int message_parm[8];	/* store numeric parms for messages here */
X
X	/* Memory management */
X	/* NB: alloc routines never return NULL. They exit to */
X	/* error_exit if not successful. */
X	METHOD(void *, alloc_small, (size_t sizeofobject));
X	METHOD(void, free_small, (void *ptr));
X	METHOD(void FAR *, alloc_medium, (size_t sizeofobject));
X	METHOD(void, free_medium, (void FAR *ptr));
X	METHOD(JSAMPARRAY, alloc_small_sarray, (long samplesperrow,
X						long numrows));
X	METHOD(void, free_small_sarray, (JSAMPARRAY ptr));
X	METHOD(JBLOCKARRAY, alloc_small_barray, (long blocksperrow,
X						 long numrows));
X	METHOD(void, free_small_barray, (JBLOCKARRAY ptr));
X	METHOD(big_sarray_ptr, request_big_sarray, (long samplesperrow,
X						    long numrows,
X						    long unitheight));
X	METHOD(big_barray_ptr, request_big_barray, (long blocksperrow,
X						    long numrows,
X						    long unitheight));
X	METHOD(void, alloc_big_arrays, (long extra_small_samples,
X					long extra_small_blocks,
X					long extra_medium_space));
X	METHOD(JSAMPARRAY, access_big_sarray, (big_sarray_ptr ptr,
X					       long start_row,
X					       boolean writable));
X	METHOD(JBLOCKARRAY, access_big_barray, (big_barray_ptr ptr,
X						long start_row,
X						boolean writable));
X	METHOD(void, free_big_sarray, (big_sarray_ptr ptr));
X	METHOD(void, free_big_barray, (big_barray_ptr ptr));
X	METHOD(void, free_all, (void));
X
X	long max_memory_to_use;	/* maximum amount of memory to use */
X};
X
X/* Macros to simplify using the error and trace message stuff */
X/* The first parameter is generally cinfo->emethods */
X
X#define ERREXIT(emeth,msg)		((*(emeth)->error_exit) (msg))
X#define ERREXIT1(emeth,msg,p1)		((emeth)->message_parm[0] = (p1), \
X					 (*(emeth)->error_exit) (msg))
X#define ERREXIT2(emeth,msg,p1,p2)	((emeth)->message_parm[0] = (p1), \
X					 (emeth)->message_parm[1] = (p2), \
X					 (*(emeth)->error_exit) (msg))
X#define ERREXIT3(emeth,msg,p1,p2,p3)	((emeth)->message_parm[0] = (p1), \
X					 (emeth)->message_parm[1] = (p2), \
X					 (emeth)->message_parm[2] = (p3), \
X					 (*(emeth)->error_exit) (msg))
X#define ERREXIT4(emeth,msg,p1,p2,p3,p4) ((emeth)->message_parm[0] = (p1), \
X					 (emeth)->message_parm[1] = (p2), \
X					 (emeth)->message_parm[2] = (p3), \
X					 (emeth)->message_parm[3] = (p4), \
X					 (*(emeth)->error_exit) (msg))
X
X#define MAKESTMT(stuff)		do { stuff } while (0)
X
X#define TRACEMS(emeth,lvl,msg)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		(*(emeth)->trace_message) (msg); } )
X#define TRACEMS1(emeth,lvl,msg,p1)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		(emeth)->message_parm[0] = (p1); \
X		(*(emeth)->trace_message) (msg); } )
X#define TRACEMS2(emeth,lvl,msg,p1,p2)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		(emeth)->message_parm[0] = (p1); \
X		(emeth)->message_parm[1] = (p2); \
X		(*(emeth)->trace_message) (msg); } )
X#define TRACEMS3(emeth,lvl,msg,p1,p2,p3)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		int * _mp = (emeth)->message_parm; \
X		*_mp++ = (p1); *_mp++ = (p2); *_mp = (p3); \
X		(*(emeth)->trace_message) (msg); } )
X#define TRACEMS4(emeth,lvl,msg,p1,p2,p3,p4)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		int * _mp = (emeth)->message_parm; \
X		*_mp++ = (p1); *_mp++ = (p2); *_mp++ = (p3); *_mp = (p4); \
X		(*(emeth)->trace_message) (msg); } )
X#define TRACEMS8(emeth,lvl,msg,p1,p2,p3,p4,p5,p6,p7,p8)    \
X  MAKESTMT( if ((emeth)->trace_level >= (lvl)) { \
X		int * _mp = (emeth)->message_parm; \
X		*_mp++ = (p1); *_mp++ = (p2); *_mp++ = (p3); *_mp++ = (p4); \
X		*_mp++ = (p5); *_mp++ = (p6); *_mp++ = (p7); *_mp = (p8); \
X		(*(emeth)->trace_message) (msg); } )
X
X
X/* Methods used during JPEG compression. */
X
Xstruct compress_methods_struct {
X	/* Hook for user interface to get control after input_init */
X	METHOD(void, c_ui_method_selection, (compress_info_ptr cinfo));
X	/* Hook for user interface to do progress monitoring */
X	METHOD(void, progress_monitor, (compress_info_ptr cinfo,
X					long loopcounter, long looplimit));
X	/* Input image reading & conversion to standard form */
X	METHOD(void, input_init, (compress_info_ptr cinfo));
X	METHOD(void, get_input_row, (compress_info_ptr cinfo,
X				     JSAMPARRAY pixel_row));
X	METHOD(void, input_term, (compress_info_ptr cinfo));
X	/* Color space and gamma conversion */
X	METHOD(void, colorin_init, (compress_info_ptr cinfo));
X	METHOD(void, get_sample_rows, (compress_info_ptr cinfo,
X				       int rows_to_read,
X				       JSAMPIMAGE image_data));
X	METHOD(void, colorin_term, (compress_info_ptr cinfo));
X	/* Expand picture data at edges */
X	METHOD(void, edge_expand, (compress_info_ptr cinfo,
X				   long input_cols, int input_rows,
X				   long output_cols, int output_rows,
X				   JSAMPIMAGE image_data));
X	/* Subsample pixel values of a single component */
X	/* There can be a different subsample method for each component */
X	METHOD(void, subsample_init, (compress_info_ptr cinfo));
X	subsample_ptr subsample[MAX_COMPS_IN_SCAN];
X	METHOD(void, subsample_term, (compress_info_ptr cinfo));
X	/* Extract samples in MCU order, process & hand off to output_method */
X	/* The input is always exactly N MCU rows worth of data */
X	METHOD(void, extract_init, (compress_info_ptr cinfo));
X	METHOD(void, extract_MCUs, (compress_info_ptr cinfo,
X				    JSAMPIMAGE image_data,
X				    int num_mcu_rows,
X				    MCU_output_method_ptr output_method));
X	METHOD(void, extract_term, (compress_info_ptr cinfo));
X	/* Entropy encoding parameter optimization */
X	METHOD(void, entropy_optimize, (compress_info_ptr cinfo,
X					MCU_output_caller_ptr source_method));
X	/* Entropy encoding */
X	METHOD(void, entropy_encoder_init, (compress_info_ptr cinfo));
X	METHOD(void, entropy_encode, (compress_info_ptr cinfo,
X				      JBLOCK *MCU_data));
X	METHOD(void, entropy_encoder_term, (compress_info_ptr cinfo));
X	/* JPEG file header construction */
X	METHOD(void, write_file_header, (compress_info_ptr cinfo));
X	METHOD(void, write_scan_header, (compress_info_ptr cinfo));
X	METHOD(void, write_jpeg_data, (compress_info_ptr cinfo,
X				       char *dataptr,
X				       int datacount));
X	METHOD(void, write_scan_trailer, (compress_info_ptr cinfo));
X	METHOD(void, write_file_trailer, (compress_info_ptr cinfo));
X	/* Pipeline control */
X	METHOD(void, c_pipeline_controller, (compress_info_ptr cinfo));
X	METHOD(void, entropy_output, (compress_info_ptr cinfo,
X				      char *dataptr,
X				      int datacount));
X	/* Overall control */
X	METHOD(void, c_per_scan_method_selection, (compress_info_ptr cinfo));
X};
X
X/* Methods used during JPEG decompression. */
X
Xstruct decompress_methods_struct {
X	/* Hook for user interface to get control after reading file header */
X	METHOD(void, d_ui_method_selection, (decompress_info_ptr cinfo));
X	/* Hook for user interface to do progress monitoring */
X	METHOD(void, progress_monitor, (decompress_info_ptr cinfo,
X					long loopcounter, long looplimit));
X	/* JPEG file scanning */
X	METHOD(void, read_file_header, (decompress_info_ptr cinfo));
X	METHOD(boolean, read_scan_header, (decompress_info_ptr cinfo));
X	METHOD(int, read_jpeg_data, (decompress_info_ptr cinfo));
X	METHOD(void, read_scan_trailer, (decompress_info_ptr cinfo));
X	METHOD(void, read_file_trailer, (decompress_info_ptr cinfo));
X	/* Entropy decoding */
X	METHOD(void, entropy_decoder_init, (decompress_info_ptr cinfo));
X	METHOD(void, entropy_decode, (decompress_info_ptr cinfo,
X				      JBLOCK *MCU_data));
X	METHOD(void, entropy_decoder_term, (decompress_info_ptr cinfo));
X	/* MCU disassembly: fetch MCUs from entropy_decode, build coef array */
X	/* The reverse_DCT step is in the same module for symmetry reasons */
X	METHOD(void, disassemble_init, (decompress_info_ptr cinfo));
X	METHOD(void, disassemble_MCU, (decompress_info_ptr cinfo,
X				       JBLOCKIMAGE image_data));
X	METHOD(void, reverse_DCT, (decompress_info_ptr cinfo,
X				   JBLOCKIMAGE coeff_data,
X				   JSAMPIMAGE output_data, int start_row));
X	METHOD(void, disassemble_term, (decompress_info_ptr cinfo));
X	/* Cross-block smoothing */
X	METHOD(void, smooth_coefficients, (decompress_info_ptr cinfo,
X					   jpeg_component_info *compptr,
X					   JBLOCKROW above,
X					   JBLOCKROW currow,
X					   JBLOCKROW below,
X					   JBLOCKROW output));
X	/* Un-subsample pixel values of a single component */
X	/* There can be a different unsubsample method for each component */
X	METHOD(void, unsubsample_init, (decompress_info_ptr cinfo));
X	unsubsample_ptr unsubsample[MAX_COMPS_IN_SCAN];
X	METHOD(void, unsubsample_term, (decompress_info_ptr cinfo));
X	/* Color space and gamma conversion */
X	METHOD(void, colorout_init, (decompress_info_ptr cinfo));
X	METHOD(void, color_convert, (decompress_info_ptr cinfo,
X				     int num_rows, long num_cols,
X				     JSAMPIMAGE input_data,
X				     JSAMPIMAGE output_data));
X	METHOD(void, colorout_term, (decompress_info_ptr cinfo));
X	/* Color quantization */
X	METHOD(void, color_quant_init, (decompress_info_ptr cinfo));
X	METHOD(void, color_quantize, (decompress_info_ptr cinfo,
X				      int num_rows,
X				      JSAMPIMAGE input_data,
X				      JSAMPARRAY output_data));
X	METHOD(void, color_quant_prescan, (decompress_info_ptr cinfo,
X					   int num_rows,
X					   JSAMPIMAGE image_data,
X					   JSAMPARRAY workspace));
X	METHOD(void, color_quant_doit, (decompress_info_ptr cinfo,
X					quantize_caller_ptr source_method));
X	METHOD(void, color_quant_term, (decompress_info_ptr cinfo));
X	/* Output image writing */
X	METHOD(void, output_init, (decompress_info_ptr cinfo));
X	METHOD(void, put_color_map, (decompress_info_ptr cinfo,
X				     int num_colors, JSAMPARRAY colormap));
X	METHOD(void, put_pixel_rows, (decompress_info_ptr cinfo,
X				      int num_rows,
X				      JSAMPIMAGE pixel_data));
X	METHOD(void, output_term, (decompress_info_ptr cinfo));
X	/* Pipeline control */
X	METHOD(void, d_pipeline_controller, (decompress_info_ptr cinfo));
X	/* Overall control */
X	METHOD(void, d_per_scan_method_selection, (decompress_info_ptr cinfo));
X};
X
X
X/* External declarations for routines that aren't called via method ptrs. */
X/* Note: use "j" as first char of names to minimize namespace pollution. */
X/* The PP macro hides prototype parameters from compilers that can't cope. */
X
X#ifdef PROTO
X#define PP(arglist)	arglist
X#else
X#define PP(arglist)	()
X#endif
X
X
X/* main entry for compression */
XEXTERN void jpeg_compress PP((compress_info_ptr cinfo));
X
X/* default parameter setup for compression */
XEXTERN void j_c_defaults PP((compress_info_ptr cinfo, int quality,
X			     boolean force_baseline));
XEXTERN void j_monochrome_default PP((compress_info_ptr cinfo));
XEXTERN void j_set_quality PP((compress_info_ptr cinfo, int quality,
X			      boolean force_baseline));
X
X/* main entry for decompression */
XEXTERN void jpeg_decompress PP((decompress_info_ptr cinfo));
X
X/* default parameter setup for decompression */
XEXTERN void j_d_defaults PP((decompress_info_ptr cinfo,
X			     boolean standard_buffering));
X
X/* forward DCT */
XEXTERN void j_fwd_dct PP((DCTBLOCK data));
X/* inverse DCT */
XEXTERN void j_rev_dct PP((DCTBLOCK data));
X
X/* utility routines in jutils.c */
XEXTERN long jround_up PP((long a, long b));
XEXTERN void jcopy_sample_rows PP((JSAMPARRAY input_array, int source_row,
X				  JSAMPARRAY output_array, int dest_row,
X				  int num_rows, long num_cols));
XEXTERN void jcopy_block_row PP((JBLOCKROW input_row, JBLOCKROW output_row,
X				long num_blocks));
XEXTERN void jzero_far PP((void FAR * target, size_t bytestozero));
X
X/* method selection routines for compression modules */
XEXTERN void jselcpipeline PP((compress_info_ptr cinfo)); /* jcpipe.c */
XEXTERN void jselchuffman PP((compress_info_ptr cinfo)); /* jchuff.c */
XEXTERN void jselcarithmetic PP((compress_info_ptr cinfo)); /* jcarith.c */
XEXTERN void jselexpand PP((compress_info_ptr cinfo)); /* jcexpand.c */
XEXTERN void jselsubsample PP((compress_info_ptr cinfo)); /* jcsample.c */
XEXTERN void jselcmcu PP((compress_info_ptr cinfo)); /* jcmcu.c */
XEXTERN void jselccolor PP((compress_info_ptr cinfo));	/* jccolor.c */
X/* The user interface should call one of these to select input format: */
XEXTERN void jselrgif PP((compress_info_ptr cinfo)); /* jrdgif.c */
XEXTERN void jselrppm PP((compress_info_ptr cinfo)); /* jrdppm.c */
XEXTERN void jselrrle PP((compress_info_ptr cinfo)); /* jrdrle.c */
XEXTERN void jselrtarga PP((compress_info_ptr cinfo)); /* jrdtarga.c */
X/* and one of these to select output header format: */
XEXTERN void jselwjfif PP((compress_info_ptr cinfo)); /* jwrjfif.c */
X
X/* method selection routines for decompression modules */
XEXTERN void jseldpipeline PP((decompress_info_ptr cinfo)); /* jdpipe.c */
XEXTERN void jseldhuffman PP((decompress_info_ptr cinfo)); /* jdhuff.c */
XEXTERN void jseldarithmetic PP((decompress_info_ptr cinfo)); /* jdarith.c */
XEXTERN void jseldmcu PP((decompress_info_ptr cinfo)); /* jdmcu.c */
XEXTERN void jselbsmooth PP((decompress_info_ptr cinfo)); /* jbsmooth.c */
XEXTERN void jselunsubsample PP((decompress_info_ptr cinfo)); /* jdsample.c */
XEXTERN void jseldcolor PP((decompress_info_ptr cinfo));	/* jdcolor.c */
XEXTERN void jsel1quantize PP((decompress_info_ptr cinfo)); /* jquant1.c */
XEXTERN void jsel2quantize PP((decompress_info_ptr cinfo)); /* jquant2.c */
X/* The user interface should call one of these to select input format: */
XEXTERN void jselrjfif PP((decompress_info_ptr cinfo)); /* jrdjfif.c */
X/* and one of these to select output image format: */
XEXTERN void jselwgif PP((decompress_info_ptr cinfo)); /* jwrgif.c */
XEXTERN void jselwppm PP((decompress_info_ptr cinfo)); /* jwrppm.c */
XEXTERN void jselwrle PP((decompress_info_ptr cinfo)); /* jwrrle.c */
XEXTERN void jselwtarga PP((decompress_info_ptr cinfo)); /* jwrtarga.c */
X
X/* method selection routines for system-dependent modules */
XEXTERN void jselerror PP((external_methods_ptr emethods)); /* jerror.c */
XEXTERN void jselmemmgr PP((external_methods_ptr emethods)); /* jmemmgr.c */
X
X
X/* We assume that right shift corresponds to signed division by 2 with
X * rounding towards minus infinity.  This is correct for typical "arithmetic
X * shift" instructions that shift in copies of the sign bit.  But some
X * C compilers implement >> with an unsigned shift.  For these machines you
X * must define RIGHT_SHIFT_IS_UNSIGNED.
X * RIGHT_SHIFT provides a proper signed right shift of an INT32 quantity.
X * It is only applied with constant shift counts.  SHIFT_TEMPS must be
X * included in the variables of any routine using RIGHT_SHIFT.
X */
X
X#ifdef RIGHT_SHIFT_IS_UNSIGNED
X#define SHIFT_TEMPS	INT32 shift_temp;
X#define RIGHT_SHIFT(x,shft)  \
X	((shift_temp = (x)) < 0 ? \
X	 (shift_temp >> (shft)) | ((~((INT32) 0)) << (32-(shft))) : \
X	 (shift_temp >> (shft)))
X#else
X#define SHIFT_TEMPS
X#define RIGHT_SHIFT(x,shft)	((x) >> (shft))
X#endif
X
X
X/* Miscellaneous useful macros */
X
X#undef MAX
X#define MAX(a,b)	((a) > (b) ? (a) : (b))
X#undef MIN
X#define MIN(a,b)	((a) < (b) ? (a) : (b))
X
X
X#define RST0	0xD0		/* RST0 marker code */
END_OF_FILE
  if test 37381 -ne `wc -c <'jpegdata.h'`; then
    echo shar: \"'jpegdata.h'\" unpacked with wrong size!
  fi
  # end of 'jpegdata.h'
fi
if test -f 'jwrgif.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jwrgif.c'\"
else
  echo shar: Extracting \"'jwrgif.c'\" \(13893 characters\)
  sed "s/^X//" >'jwrgif.c' <<'END_OF_FILE'
X/*
X * jwrgif.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains routines to write output images in GIF format.
X *
X * These routines may need modification for non-Unix environments or
X * specialized applications.  As they stand, they assume output to
X * an ordinary stdio stream.
X *
X * These routines are invoked via the methods put_pixel_rows, put_color_map,
X * and output_init/term.
X */
X
X/*
X * This code is loosely based on ppmtogif from the PBMPLUS distribution
X * of Feb. 1991.  That file contains the following copyright notice:
X *    Based on GIFENCODE by David Rowley <mgardi@watdscu.waterloo.edu>.
X *    Lempel-Ziv compression based on "compress" by Spencer W. Thomas et al.
X *    Copyright (C) 1989 by Jef Poskanzer.
X *    Permission to use, copy, modify, and distribute this software and its
X *    documentation for any purpose and without fee is hereby granted, provided
X *    that the above copyright notice appear in all copies and that both that
X *    copyright notice and this permission notice appear in supporting
X *    documentation.  This software is provided "as is" without express or
X *    implied warranty.
X *
X * We are also required to state that
X *    "The Graphics Interchange Format(c) is the Copyright property of
X *    CompuServe Incorporated. GIF(sm) is a Service Mark property of
X *    CompuServe Incorporated."
X */
X
X#include "jinclude.h"
X
X#ifdef GIF_SUPPORTED
X
X
Xstatic decompress_info_ptr dcinfo; /* to avoid passing to all functions */
X
X#define	MAX_LZW_BITS	12	/* maximum LZW code size (4096 symbols) */
X
Xtypedef INT16 code_int;		/* must hold -1 .. 2**MAX_LZW_BITS */
X
X#define LZW_TABLE_SIZE	((code_int) 1 << MAX_LZW_BITS)
X
X#define HSIZE		5003	/* hash table size for 80% occupancy */
X
Xtypedef int hash_int;		/* must hold -2*HSIZE..2*HSIZE */
X
Xstatic int n_bits;		/* current number of bits/code */
Xstatic code_int maxcode;	/* maximum code, given n_bits */
X#define MAXCODE(n_bits)	(((code_int) 1 << (n_bits)) - 1)
X
Xstatic int init_bits;		/* initial n_bits ... restored after clear */
X
Xstatic code_int ClearCode;	/* clear code (doesn't change) */
Xstatic code_int EOFCode;	/* EOF code (ditto) */
X
Xstatic code_int free_code;	/* first not-yet-used symbol code */
X
X/*
X * The LZW hash table consists of three parallel arrays:
X *   hash_code[i]	code of symbol in slot i, or 0 if empty slot
X *   hash_prefix[i]	symbol's prefix code; undefined if empty slot
X *   hash_suffix[i]	symbol's suffix character; undefined if empty slot
X * where slot values (i) range from 0 to HSIZE-1.
X *
X * Algorithm:  use open addressing double hashing (no chaining) on the
X * prefix code / suffix character combination.  We do a variant of Knuth's
X * algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime
X * secondary probe.
X *
X * The hash tables are allocated from FAR heap space since they would use up
X * rather a lot of the near data space in a PC.
X */
X
Xstatic code_int FAR *hash_code;	/* => hash table of symbol codes */
Xstatic code_int FAR *hash_prefix; /* => hash table of prefix symbols */
Xstatic UINT8 FAR *hash_suffix;	/* => hash table of suffix bytes */
X
X
X/*
X * Routines to package compressed data bytes into GIF data blocks.
X * A data block consists of a count byte (1..255) and that many data bytes.
X */
X
Xstatic int bytesinpkt;		/* # of bytes in current packet */
Xstatic char packetbuf[256];	/* workspace for accumulating packet */
X
X
XLOCAL void
Xflush_packet (void)
X/* flush any accumulated data */
X{
X  if (bytesinpkt > 0) {		/* never write zero-length packet */
X    packetbuf[0] = (char) bytesinpkt++;
X    if (JFWRITE(dcinfo->output_file, packetbuf, bytesinpkt)
X	!= (size_t) bytesinpkt)
X      ERREXIT(dcinfo->emethods, "Output file write error");
X    bytesinpkt = 0;
X  }
X}
X
X
X/* Add a character to current packet; flush to disk if necessary */
X#define CHAR_OUT(c)  \
X	{ packetbuf[++bytesinpkt] = (char) (c);  \
X	    if (bytesinpkt >= 255)  \
X	      flush_packet();  \
X	}
X
X
X/* Routine to convert variable-width codes into a byte stream */
X
Xstatic INT32 cur_accum;		/* holds bits not yet output */
Xstatic int cur_bits;		/* # of bits in cur_accum */
X
X
XLOCAL void
Xoutput (code_int code)
X/* Emit a code of n_bits bits */
X/* Uses cur_accum and cur_bits to reblock into 8-bit bytes */
X{
X  cur_accum |= ((INT32) code) << cur_bits;
X  cur_bits += n_bits;
X
X  while (cur_bits >= 8) {
X    CHAR_OUT(cur_accum & 0xFF);
X    cur_accum >>= 8;
X    cur_bits -= 8;
X  }
X
X  /*
X   * If the next entry is going to be too big for the code size,
X   * then increase it, if possible.  We do this here to ensure
X   * that it's done in sync with the decoder's codesize increases.
X   */
X  if (free_code > maxcode) {
X    n_bits++;
X    if (n_bits == MAX_LZW_BITS)
X      maxcode = LZW_TABLE_SIZE;	/* free_code will never exceed this */
X    else
X      maxcode = MAXCODE(n_bits);
X  }
X}
X
X
X/* The LZW algorithm proper */
X
Xstatic code_int waiting_code;	/* symbol not yet output; may be extendable */
Xstatic boolean first_byte;	/* if TRUE, waiting_code is not valid */
X
X
XLOCAL void
Xclear_hash (void)
X/* Fill the hash table with empty entries */
X{
X  /* It's sufficient to zero hash_code[] */
X  jzero_far((void FAR *) hash_code, HSIZE * SIZEOF(code_int));
X}
X
X
XLOCAL void
Xclear_block (void)
X/* Reset compressor and issue a Clear code */
X{
X  clear_hash();			/* delete all the symbols */
X  free_code = ClearCode + 2;
X  output(ClearCode);		/* inform decoder */
X  n_bits = init_bits;		/* reset code size */
X  maxcode = MAXCODE(n_bits);
X}
X
X
XLOCAL void
Xcompress_init (int i_bits)
X/* Initialize LZW compressor */
X{
X  /* init all the static variables */
X  n_bits = init_bits = i_bits;
X  maxcode = MAXCODE(n_bits);
X  ClearCode = ((code_int) 1 << (init_bits - 1));
X  EOFCode = ClearCode + 1;
X  free_code = ClearCode + 2;
X  first_byte = TRUE;		/* no waiting symbol yet */
X  /* init output buffering vars */
X  bytesinpkt = 0;
X  cur_accum = 0;
X  cur_bits = 0;
X  /* clear hash table */
X  clear_hash();
X  /* GIF specifies an initial Clear code */
X  output(ClearCode);
X}
X
X
XLOCAL void
Xcompress_byte (int c)
X/* Accept and compress one 8-bit byte */
X{
X  register hash_int i;
X  register hash_int disp;
X
X  if (first_byte) {		/* need to initialize waiting_code */
X    waiting_code = c;
X    first_byte = FALSE;
X    return;
X  }
X
X  /* Probe hash table to see if a symbol exists for
X   * waiting_code followed by c.
X   * If so, replace waiting_code by that symbol and return.
X   */
X  i = ((hash_int) c << (MAX_LZW_BITS-8)) + waiting_code;
X  /* i is less than twice 2**MAX_LZW_BITS, therefore less than twice HSIZE */
X  if (i >= HSIZE)
X    i -= HSIZE;
X  
X  if (hash_code[i] != 0) {	/* is first probed slot empty? */
X    if (hash_prefix[i] == waiting_code && hash_suffix[i] == (UINT8) c) {
X      waiting_code = hash_code[i];
X      return;
X    }
X    if (i == 0)			/* secondary hash (after G. Knott) */
X      disp = 1;
X    else
X      disp = HSIZE - i;
X    while (1) {
X      i -= disp;
X      if (i < 0)
X	i += HSIZE;
X      if (hash_code[i] == 0)
X	break;			/* hit empty slot */
X      if (hash_prefix[i] == waiting_code && hash_suffix[i] == (UINT8) c) {
X	waiting_code = hash_code[i];
X	return;
X      }
X    }
X  }
X
X  /* here when hashtable[i] is an empty slot; desired symbol not in table */
X  output(waiting_code);
X  if (free_code < LZW_TABLE_SIZE) {
X    hash_code[i] = free_code++;	/* add symbol to hashtable */
X    hash_prefix[i] = waiting_code;
X    hash_suffix[i] = (UINT8) c;
X  } else
X    clear_block();
X  waiting_code = c;
X}
X
X
XLOCAL void
Xcompress_term (void)
X/* Clean up at end */
X{
X  /* Flush out the buffered code */
X  if (! first_byte)
X    output(waiting_code);
X  /* Send an EOF code */
X  output(EOFCode);
X  /* Flush the bit-packing buffer */
X  if (cur_bits > 0) {
X    CHAR_OUT(cur_accum & 0xFF);
X  }
X  /* Flush the packet buffer */
X  flush_packet();
X}
X
X
X/* GIF header construction */
X
X
XLOCAL void
Xput_word (UINT16 w)
X/* Emit a 16-bit word, LSB first */
X{
X  putc(w & 0xFF, dcinfo->output_file);
X  putc((w >> 8) & 0xFF, dcinfo->output_file);
X}
X
X
XLOCAL void
Xput_3bytes (int val)
X/* Emit 3 copies of same byte value --- handy subr for colormap construction */
X{
X  putc(val, dcinfo->output_file);
X  putc(val, dcinfo->output_file);
X  putc(val, dcinfo->output_file);
X}
X
X
XLOCAL void
Xemit_header (int num_colors, JSAMPARRAY colormap)
X/* Output the GIF file header, including color map */
X/* If colormap==NULL, synthesize a gray-scale colormap */
X{
X  int BitsPerPixel, ColorMapSize, InitCodeSize, FlagByte;
X  int cshift = dcinfo->data_precision - 8;
X  int i;
X
X  if (num_colors > 256)
X    ERREXIT(dcinfo->emethods, "GIF can only handle 256 colors");
X  /* Compute bits/pixel and related values */
X  BitsPerPixel = 1;
X  while (num_colors > (1 << BitsPerPixel))
X    BitsPerPixel++;
X  ColorMapSize = 1 << BitsPerPixel;
X  if (BitsPerPixel <= 1)
X    InitCodeSize = 2;
X  else
X    InitCodeSize = BitsPerPixel;
X  /*
X   * Write the GIF header.
X   * Note that we generate a plain GIF87 header for maximum compatibility.
X   */
X  (void) JFWRITE(dcinfo->output_file, "GIF87a", 6);
X  /* Write the Logical Screen Descriptor */
X  put_word((UINT16) dcinfo->image_width);
X  put_word((UINT16) dcinfo->image_height);
X  FlagByte = 0x80;		/* Yes, there is a global color table */
X  FlagByte |= (BitsPerPixel-1) << 4; /* color resolution */
X  FlagByte |= (BitsPerPixel-1);	/* size of global color table */
X  putc(FlagByte, dcinfo->output_file);
X  putc(0, dcinfo->output_file);	/* Background color index */
X  putc(0, dcinfo->output_file);	/* Reserved in GIF87 (aspect ratio in GIF89) */
X  /* Write the Global Color Map */
X  /* If the color map is more than 8 bits precision, */
X  /* we reduce it to 8 bits by shifting */
X  for (i=0; i < ColorMapSize; i++) {
X    if (i < num_colors) {
X      if (colormap != NULL) {
X	if (dcinfo->out_color_space == CS_RGB) {
X	  /* Normal case: RGB color map */
X	  putc(GETJSAMPLE(colormap[0][i]) >> cshift, dcinfo->output_file);
X	  putc(GETJSAMPLE(colormap[1][i]) >> cshift, dcinfo->output_file);
X	  putc(GETJSAMPLE(colormap[2][i]) >> cshift, dcinfo->output_file);
X	} else {
X	  /* Grayscale "color map": possible if quantizing grayscale image */
X	  put_3bytes(GETJSAMPLE(colormap[0][i]) >> cshift);
X	}
X      } else {
X	/* Create a gray-scale map of num_colors values, range 0..255 */
X	put_3bytes((i * 255 + (num_colors-1)/2) / (num_colors-1));
X      }
X    } else {
X      /* fill out the map to a power of 2 */
X      put_3bytes(0);
X    }
X  }
X  /* Write image separator and Image Descriptor */
X  putc(',', dcinfo->output_file); /* separator */
X  put_word((UINT16) 0);		/* left/top offset */
X  put_word((UINT16) 0);
X  put_word((UINT16) dcinfo->image_width); /* image size */
X  put_word((UINT16) dcinfo->image_height);
X  /* flag byte: not interlaced, no local color map */
X  putc(0x00, dcinfo->output_file);
X  /* Write Initial Code Size byte */
X  putc(InitCodeSize, dcinfo->output_file);
X
X  /* Initialize for LZW compression of image data */
X  compress_init(InitCodeSize+1);
X}
X
X
X
X/*
X * Initialize for GIF output.
X */
X
XMETHODDEF void
Xoutput_init (decompress_info_ptr cinfo)
X{
X  dcinfo = cinfo;		/* save for use by local routines */
X  if (cinfo->final_out_comps != 1) /* safety check */
X    ERREXIT(cinfo->emethods, "GIF output got confused");
X  /* Allocate space for hash table */
X  hash_code = (code_int FAR *) (*cinfo->emethods->alloc_medium)
X				(HSIZE * SIZEOF(code_int));
X  hash_prefix = (code_int FAR *) (*cinfo->emethods->alloc_medium)
X				(HSIZE * SIZEOF(code_int));
X  hash_suffix = (UINT8 FAR *) (*cinfo->emethods->alloc_medium)
X				(HSIZE * SIZEOF(UINT8));
X  /*
X   * If we aren't quantizing, put_color_map won't be called,
X   * so emit the header now.  This only happens with gray scale output.
X   * (If we are quantizing, wait for the color map to be provided.)
X   */
X  if (! cinfo->quantize_colors)
X    emit_header(256, (JSAMPARRAY) NULL);
X}
X
X
X/*
X * Write the color map.
X */
X
XMETHODDEF void
Xput_color_map (decompress_info_ptr cinfo, int num_colors, JSAMPARRAY colormap)
X{
X  emit_header(num_colors, colormap);
X}
X
X
X/*
X * Write some pixel data.
X */
X
XMETHODDEF void
Xput_pixel_rows (decompress_info_ptr cinfo, int num_rows,
X		JSAMPIMAGE pixel_data)
X{
X  register JSAMPROW ptr;
X  register long col;
X  register long width = cinfo->image_width;
X  register int row;
X  
X  for (row = 0; row < num_rows; row++) {
X    ptr = pixel_data[0][row];
X    for (col = width; col > 0; col--) {
X      compress_byte(GETJSAMPLE(*ptr));
X      ptr++;
X    }
X  }
X}
X
X
X/*
X * Finish up at the end of the file.
X */
X
XMETHODDEF void
Xoutput_term (decompress_info_ptr cinfo)
X{
X  /* Flush LZW mechanism */
X  compress_term();
X  /* Write a zero-length data block to end the series */
X  putc(0, cinfo->output_file);
X  /* Write the GIF terminator mark */
X  putc(';', cinfo->output_file);
X  /* Make sure we wrote the output file OK */
X  fflush(cinfo->output_file);
X  if (ferror(cinfo->output_file))
X    ERREXIT(cinfo->emethods, "Output file write error");
X  /* Free space */
X  /* no work (we let free_all release the workspace) */
X}
X
X
X/*
X * The method selection routine for GIF format output.
X * This should be called from d_ui_method_selection if GIF output is wanted.
X */
X
XGLOBAL void
Xjselwgif (decompress_info_ptr cinfo)
X{
X  cinfo->methods->output_init = output_init;
X  cinfo->methods->put_color_map = put_color_map;
X  cinfo->methods->put_pixel_rows = put_pixel_rows;
X  cinfo->methods->output_term = output_term;
X
X  if (cinfo->out_color_space != CS_GRAYSCALE &&
X      cinfo->out_color_space != CS_RGB)
X    ERREXIT(cinfo->emethods, "GIF output must be grayscale or RGB");
X
X  /* Force quantization if color or if > 8 bits input */
X  if (cinfo->out_color_space == CS_RGB || cinfo->data_precision > 8) {
X    /* Force quantization to at most 256 colors */
X    cinfo->quantize_colors = TRUE;
X    if (cinfo->desired_number_of_colors > 256)
X      cinfo->desired_number_of_colors = 256;
X  }
X}
X
X#endif /* GIF_SUPPORTED */
END_OF_FILE
  if test 13893 -ne `wc -c <'jwrgif.c'`; then
    echo shar: \"'jwrgif.c'\" unpacked with wrong size!
  fi
  # end of 'jwrgif.c'
fi
if test -f 'makcjpeg.lnk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makcjpeg.lnk'\"
else
  echo shar: Extracting \"'makcjpeg.lnk'\" \(320 characters\)
  sed "s/^X//" >'makcjpeg.lnk' <<'END_OF_FILE'
Xjcmain.obj +
Xjcmaster.obj +
Xjcdeflts.obj +
Xjcarith.obj +
Xjccolor.obj +
Xjcexpand.obj +
Xjchuff.obj +
Xjcmcu.obj +
Xjcpipe.obj +
Xjcsample.obj +
Xjfwddct.obj +
Xjwrjfif.obj +
Xjrdgif.obj +
Xjrdppm.obj +
Xjrdrle.obj +
Xjrdtarga.obj +
Xjutils.obj +
Xjerror.obj +
Xjmemmgr.obj +
Xjmemsys.obj +
Xjmemdosa.obj
Xcjpeg.exe /NOI
Xnul.map
X
Xnul.def
END_OF_FILE
  if test 320 -ne `wc -c <'makcjpeg.lnk'`; then
    echo shar: \"'makcjpeg.lnk'\" unpacked with wrong size!
  fi
  # end of 'makcjpeg.lnk'
fi
echo shar: End of archive 4 \(of 18\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
