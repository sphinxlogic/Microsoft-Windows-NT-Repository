Newsgroups: comp.sources.misc
From: jpeg-info@uunet.uu.net (Independent JPEG Group)
Subject:  v29i015:  jpeg - JPEG image compression, Part15/18
Message-ID: <1992Mar25.145404.733@sparky.imd.sterling.com>
X-Md4-Signature: eccbed3270240dac781b2a4d7b461de4
Date: Wed, 25 Mar 1992 14:54:04 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jpeg-info@uunet.uu.net (Independent JPEG Group)
Posting-number: Volume 29, Issue 15
Archive-name: jpeg/part15
Environment: UNIX, VMS, MS-DOS, Mac, Amiga, Cray

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  djpeg.1 jccolor.c jdsample.c jwrrle.c makefile.ansi
#   makefile.mms makefile.sas makefile.unix
# Wrapped by kent@sparky on Mon Mar 23 16:02:55 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 15 (of 18)."'
if test -f 'djpeg.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'djpeg.1'\"
else
  echo shar: Extracting \"'djpeg.1'\" \(3099 characters\)
  sed "s/^X//" >'djpeg.1' <<'END_OF_FILE'
X.TH DJPEG 1 "28 February 1992"
X.SH NAME
Xdjpeg \- decompress a JPEG file to an image file
X.SH SYNOPSIS
X.B djpeg
X[
X.B \-GPRTgD1bd
X]
X[
X.BI \-q " colors"
X]
X[
X.BI \-m " memory"
X]
X[
X.I filename
X]
X.LP
X.SH DESCRIPTION
X.LP
X.B djpeg
Xdecompresses the named JPEG file, or the standard input if no file is named,
Xand produces an image file on the standard output.  PPM, GIF, Targa, or RLE
Xoutput format can be selected.  (RLE is supported only if the URT library is
Xavailable.)
X.SH OPTIONS
X.TP
X.B \-G
XSelect GIF output format (implies
X.BR \-q ,
Xwith default of 256 colors).
X.TP
X.B \-P
XSelect PPM or PGM output format (this is the default).  PGM is emitted if the
XJPEG file is gray-scale or if
X.B \-g
Xis specified.
X.TP
X.B \-R
XSelect RLE output format.  Requires URT library.
X.TP
X.B \-T
XSelect Targa output format.  Gray-scale format is emitted if the JPEG file is
Xgray-scale or if
X.B \-g
Xis specified; otherwise, colormapped format is emitted if
X.B \-q
Xis specified; otherwise, 24-bit full-color format is emitted.
X.TP
X.B \-g
XForce gray-scale output even if input is color.
X.TP
X.BI \-q " N"
XQuantize to N colors.  This reduces the number of colors in the output image
Xso that it can be displayed on a colormapped display or stored in a
Xcolormapped file format.  For example, if you have an 8-bit display, you'd
Xneed to quantize to 256 or fewer colors.
X.TP
X.B \-D
XDo not use dithering in color quantization.  By default, Floyd-Steinberg
Xdithering is applied when quantizing colors, but on some images dithering may
Xresult in objectionable "graininess".  If that happens, you can turn off
Xdithering with
X.BR \-D .
X.B \-D
Xis ignored unless you also say
X.B \-q
Xor
X.BR \-G .
X.TP
X.B \-1
XUse one-pass instead of two-pass color quantization.  The one-pass method is
Xfaster and needs less memory, but it produces a lower-quality image.
X.B \-1
Xis ignored unless you also say
X.B \-q
Xor
X.BR \-G .
XAlso, the one-pass method is always used for gray-scale output (the two-pass
Xmethod is no improvement then).
X.TP
X.B \-b
XPerform cross-block smoothing.  This is quite memory-intensive and only seems
Xto improve the image at low quality settings (\fB\-Q\fR 10 to 20 or so).
XAt normal
X.B \-Q
Xsettings it may make the image worse.
X.TP
X.B \-d
XEnable debug printout.  More
X.BR \-d 's
Xgive more output.  Also, version information is printed at startup.
X.TP
X.BI \-m " memory"
XSet limit for amount of memory to use in processing large images.  Value is
Xin thousands of bytes, or millions of bytes if "M" is attached to the
Xnumber.  For example,
X.B \-m 4m
Xselects 4000000 bytes.  If more space is needed, temporary files will be used.
X.SH EXAMPLES
X.LP
XThis example decompresses the JPEG file foo.jpg, quantizes to 256 colors,
Xand saves the output in GIF format in foo.gif:
X.IP
X.B djpeg \-G
X.I foo.jpg
X.B >
X.I foo.gif
X.SH SEE ALSO
X.BR cjpeg (1)
X.br
X.BR ppm (5),
X.BR pgm (5)
X.br
XWallace, Gregory K.  "The JPEG Still Picture Compression Standard",
XCommunications of the ACM, April 1991 (vol. 34, no. 4), pp. 30-44.
X.SH AUTHOR
XIndependent JPEG Group
X.SH BUGS
XArithmetic coding is not supported for legal reasons.
X.PP
XNot as fast as we'd like.
END_OF_FILE
  if test 3099 -ne `wc -c <'djpeg.1'`; then
    echo shar: \"'djpeg.1'\" unpacked with wrong size!
  fi
  # end of 'djpeg.1'
fi
if test -f 'jccolor.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jccolor.c'\"
else
  echo shar: Extracting \"'jccolor.c'\" \(6864 characters\)
  sed "s/^X//" >'jccolor.c' <<'END_OF_FILE'
X/*
X * jccolor.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains input colorspace conversion routines.
X * These routines are invoked via the methods get_sample_rows
X * and colorin_init/term.
X */
X
X#include "jinclude.h"
X
X
Xstatic JSAMPARRAY pixel_row;	/* Workspace for a pixel row in input format */
X
X
X/*
X * Initialize for colorspace conversion.
X */
X
XMETHODDEF void
Xcolorin_init (compress_info_ptr cinfo)
X{
X  /* Allocate a workspace for the result of get_input_row. */
X  pixel_row = (*cinfo->emethods->alloc_small_sarray)
X		(cinfo->image_width, (long) cinfo->input_components);
X}
X
X
X/*
X * Fetch some rows of pixels from get_input_row and convert to the
X * JPEG colorspace.
X */
X
X
X/*
X * This version handles RGB -> YCbCr conversion.
X * YCbCr is defined per CCIR 601-1, except that Cb and Cr are
X * normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
X * The conversion equations to be implemented are therefore
X *	Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
X *	Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B
X *	Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B
X * where Cb and Cr must be incremented by MAXJSAMPLE/2 to create a
X * nonnegative output value.
X * (These numbers are derived from TIFF Appendix O, draft of 4/10/91.)
X *
X * To avoid floating-point arithmetic, we represent the fractional constants
X * as integers scaled up by 2^14 (about 4 digits precision); we have to divide
X * the products by 2^14, with appropriate rounding, to get the correct answer.
X *
X * For even more speed, we could avoid any multiplications in the inner loop
X * by precalculating the constants times R,G,B for all possible values.
X * This is not currently implemented.
X */
X
X#define SCALEBITS	14
X#define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
X#define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
X
X
XMETHODDEF void
Xget_rgb_ycc_rows (compress_info_ptr cinfo,
X		  int rows_to_read, JSAMPIMAGE image_data)
X{
X  register INT32 r, g, b;
X  register JSAMPROW inptr0, inptr1, inptr2;
X  register JSAMPROW outptr0, outptr1, outptr2;
X  register long col;
X  long width = cinfo->image_width;
X  int row;
X
X  for (row = 0; row < rows_to_read; row++) {
X    /* Read one row from the source file */
X    (*cinfo->methods->get_input_row) (cinfo, pixel_row);
X    /* Convert colorspace */
X    inptr0 = pixel_row[0];
X    inptr1 = pixel_row[1];
X    inptr2 = pixel_row[2];
X    outptr0 = image_data[0][row];
X    outptr1 = image_data[1][row];
X    outptr2 = image_data[2][row];
X    for (col = width; col > 0; col--) {
X      r = GETJSAMPLE(*inptr0++);
X      g = GETJSAMPLE(*inptr1++);
X      b = GETJSAMPLE(*inptr2++);
X      /* If the inputs are 0..MAXJSAMPLE, the outputs of these equations
X       * must be too; we do not need an explicit range-limiting operation.
X       * Hence the value being shifted is never negative, and we don't
X       * need the general RIGHT_SHIFT macro.
X       */
X      /* Y */
X      *outptr0++ = (JSAMPLE)
X	((  FIX(0.29900)*r  + FIX(0.58700)*g + FIX(0.11400)*b
X	  + ONE_HALF) >> SCALEBITS);
X      /* Cb */
X      *outptr1++ = (JSAMPLE)
X	(((-FIX(0.16874))*r - FIX(0.33126)*g + FIX(0.50000)*b
X	  + ONE_HALF*(MAXJSAMPLE+1)) >> SCALEBITS);
X      /* Cr */
X      *outptr2++ = (JSAMPLE)
X	((  FIX(0.50000)*r  - FIX(0.41869)*g - FIX(0.08131)*b
X	  + ONE_HALF*(MAXJSAMPLE+1)) >> SCALEBITS);
X    }
X  }
X}
X
X
X/*
X * Fetch some rows of pixels from get_input_row and convert to the
X * JPEG colorspace.
X * This version handles grayscale (no conversion).
X */
X
XMETHODDEF void
Xget_grayscale_rows (compress_info_ptr cinfo,
X		    int rows_to_read, JSAMPIMAGE image_data)
X{
X  int row;
X
X  for (row = 0; row < rows_to_read; row++) {
X    /* Read one row from the source file */
X    (*cinfo->methods->get_input_row) (cinfo, pixel_row);
X    /* Convert colorspace (gamma mapping needed here) */
X    jcopy_sample_rows(pixel_row, 0, image_data[0], row,
X		      1, cinfo->image_width);
X  }
X}
X
X
X/*
X * Fetch some rows of pixels from get_input_row and convert to the
X * JPEG colorspace.
X * This version handles multi-component colorspaces without conversion.
X */
X
XMETHODDEF void
Xget_noconvert_rows (compress_info_ptr cinfo,
X		    int rows_to_read, JSAMPIMAGE image_data)
X{
X  int row, ci;
X
X  for (row = 0; row < rows_to_read; row++) {
X    /* Read one row from the source file */
X    (*cinfo->methods->get_input_row) (cinfo, pixel_row);
X    /* Convert colorspace (gamma mapping needed here) */
X    for (ci = 0; ci < cinfo->input_components; ci++) {
X      jcopy_sample_rows(pixel_row, ci, image_data[ci], row,
X			1, cinfo->image_width);
X    }
X  }
X}
X
X
X/*
X * Finish up at the end of the file.
X */
X
XMETHODDEF void
Xcolorin_term (compress_info_ptr cinfo)
X{
X  /* no work (we let free_all release the workspace) */
X}
X
X
X/*
X * The method selection routine for input colorspace conversion.
X */
X
XGLOBAL void
Xjselccolor (compress_info_ptr cinfo)
X{
X  /* Make sure input_components agrees with in_color_space */
X  switch (cinfo->in_color_space) {
X  case CS_GRAYSCALE:
X    if (cinfo->input_components != 1)
X      ERREXIT(cinfo->emethods, "Bogus input colorspace");
X    break;
X
X  case CS_RGB:
X  case CS_YCbCr:
X  case CS_YIQ:
X    if (cinfo->input_components != 3)
X      ERREXIT(cinfo->emethods, "Bogus input colorspace");
X    break;
X
X  case CS_CMYK:
X    if (cinfo->input_components != 4)
X      ERREXIT(cinfo->emethods, "Bogus input colorspace");
X    break;
X
X  default:
X    ERREXIT(cinfo->emethods, "Unsupported input colorspace");
X    break;
X  }
X
X  /* Check num_components, set conversion method based on requested space */
X  switch (cinfo->jpeg_color_space) {
X  case CS_GRAYSCALE:
X    if (cinfo->num_components != 1)
X      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
X    if (cinfo->in_color_space == CS_GRAYSCALE)
X      cinfo->methods->get_sample_rows = get_grayscale_rows;
X    else
X      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
X    break;
X
X  case CS_YCbCr:
X    if (cinfo->num_components != 3)
X      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
X    if (cinfo->in_color_space == CS_RGB)
X      cinfo->methods->get_sample_rows = get_rgb_ycc_rows;
X    else if (cinfo->in_color_space == CS_YCbCr)
X      cinfo->methods->get_sample_rows = get_noconvert_rows;
X    else
X      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
X    break;
X
X  case CS_CMYK:
X    if (cinfo->num_components != 4)
X      ERREXIT(cinfo->emethods, "Bogus JPEG colorspace");
X    if (cinfo->in_color_space == CS_CMYK)
X      cinfo->methods->get_sample_rows = get_noconvert_rows;
X    else
X      ERREXIT(cinfo->emethods, "Unsupported color conversion request");
X    break;
X
X  default:
X    ERREXIT(cinfo->emethods, "Unsupported JPEG colorspace");
X    break;
X  }
X
X  cinfo->methods->colorin_init = colorin_init;
X  cinfo->methods->colorin_term = colorin_term;
X}
END_OF_FILE
  if test 6864 -ne `wc -c <'jccolor.c'`; then
    echo shar: \"'jccolor.c'\" unpacked with wrong size!
  fi
  # end of 'jccolor.c'
fi
if test -f 'jdsample.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jdsample.c'\"
else
  echo shar: Extracting \"'jdsample.c'\" \(6290 characters\)
  sed "s/^X//" >'jdsample.c' <<'END_OF_FILE'
X/*
X * jdsample.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains un-subsampling routines.
X * These routines are invoked via the unsubsample and
X * unsubsample_init/term methods.
X */
X
X#include "jinclude.h"
X
X
X/*
X * Initialize for un-subsampling a scan.
X */
X
XMETHODDEF void
Xunsubsample_init (decompress_info_ptr cinfo)
X{
X  /* no work for now */
X}
X
X
X/*
X * Un-subsample pixel values of a single component.
X * This version handles any integral sampling ratios.
X * This is not used for typical JPEG files, so it need not be fast.
X */
X
XMETHODDEF void
Xint_unsubsample (decompress_info_ptr cinfo, int which_component,
X		 long input_cols, int input_rows,
X		 long output_cols, int output_rows,
X		 JSAMPARRAY above, JSAMPARRAY input_data, JSAMPARRAY below,
X		 JSAMPARRAY output_data)
X{
X  jpeg_component_info * compptr = cinfo->cur_comp_info[which_component];
X  register JSAMPROW inptr, outptr;
X  register JSAMPLE invalue;
X  register short h_expand, h;
X  short v_expand, v;
X  int inrow, outrow;
X  register long incol;
X
X#ifdef DEBUG			/* for debugging pipeline controller */
X  if (input_rows != compptr->v_samp_factor ||
X      output_rows != cinfo->max_v_samp_factor ||
X      (input_cols % compptr->h_samp_factor) != 0 ||
X      (output_cols % cinfo->max_h_samp_factor) != 0 ||
X      output_cols*compptr->h_samp_factor != input_cols*cinfo->max_h_samp_factor)
X    ERREXIT(cinfo->emethods, "Bogus unsubsample parameters");
X#endif
X
X  h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
X  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
X
X  outrow = 0;
X  for (inrow = 0; inrow < input_rows; inrow++) {
X    for (v = 0; v < v_expand; v++) {
X      inptr = input_data[inrow];
X      outptr = output_data[outrow++];
X      for (incol = 0; incol < input_cols; incol++) {
X	invalue = GETJSAMPLE(*inptr++);
X	for (h = 0; h < h_expand; h++) {
X	  *outptr++ = invalue;
X	}
X      }
X    }
X  }
X}
X
X
X/*
X * Un-subsample pixel values of a single component.
X * This version handles the extremely common case of
X * horizontal expansion by 2 and any integral vertical expansion.
X */
X
XMETHODDEF void
Xh2_unsubsample (decompress_info_ptr cinfo, int which_component,
X		long input_cols, int input_rows,
X		long output_cols, int output_rows,
X		JSAMPARRAY above, JSAMPARRAY input_data, JSAMPARRAY below,
X		JSAMPARRAY output_data)
X{
X  jpeg_component_info * compptr = cinfo->cur_comp_info[which_component];
X  register JSAMPROW inptr, outptr;
X  register JSAMPLE invalue;
X  short v_expand, v;
X  int inrow, outrow;
X  register long incol;
X
X#ifdef DEBUG			/* for debugging pipeline controller */
X  if (input_rows != compptr->v_samp_factor ||
X      output_rows != cinfo->max_v_samp_factor ||
X      (input_cols % compptr->h_samp_factor) != 0 ||
X      (output_cols % cinfo->max_h_samp_factor) != 0 ||
X      output_cols*compptr->h_samp_factor != input_cols*cinfo->max_h_samp_factor)
X    ERREXIT(cinfo->emethods, "Bogus unsubsample parameters");
X#endif
X
X  v_expand = cinfo->max_v_samp_factor / compptr->v_samp_factor;
X
X/* The subsampled image width will always be a multiple of DCTSIZE,
X * so we can unroll the inner loop.
X */
X
X  outrow = 0;
X  for (inrow = 0; inrow < input_rows; inrow++) {
X    for (v = 0; v < v_expand; v++) {
X      inptr = input_data[inrow];
X      outptr = output_data[outrow++];
X#if DCTSIZE == 8
X      for (incol = 0; incol < input_cols; incol += DCTSIZE) {
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X      }
X#else /* nonstandard DCTSIZE */
X      for (incol = 0; incol < input_cols; incol++) {
X	invalue = GETJSAMPLE(*inptr++);
X	*outptr++ = invalue;
X	*outptr++ = invalue;
X      }
X#endif
X    }
X  }
X}
X
X
X/*
X * Un-subsample pixel values of a single component.
X * This version handles the special case of a full-size component.
X */
X
XMETHODDEF void
Xfullsize_unsubsample (decompress_info_ptr cinfo, int which_component,
X		      long input_cols, int input_rows,
X		      long output_cols, int output_rows,
X		      JSAMPARRAY above, JSAMPARRAY input_data, JSAMPARRAY below,
X		      JSAMPARRAY output_data)
X{
X#ifdef DEBUG			/* for debugging pipeline controller */
X  if (input_cols != output_cols || input_rows != output_rows)
X    ERREXIT(cinfo->emethods, "Pipeline controller messed up");
X#endif
X
X  jcopy_sample_rows(input_data, 0, output_data, 0, output_rows, output_cols);
X}
X
X
X
X/*
X * Clean up after a scan.
X */
X
XMETHODDEF void
Xunsubsample_term (decompress_info_ptr cinfo)
X{
X  /* no work for now */
X}
X
X
X
X/*
X * The method selection routine for unsubsampling.
X * Note that we must select a routine for each component.
X */
X
XGLOBAL void
Xjselunsubsample (decompress_info_ptr cinfo)
X{
X  short ci;
X  jpeg_component_info * compptr;
X
X  if (cinfo->CCIR601_sampling)
X    ERREXIT(cinfo->emethods, "CCIR601 subsampling not implemented yet");
X
X  for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
X    compptr = cinfo->cur_comp_info[ci];
X    if (compptr->h_samp_factor == cinfo->max_h_samp_factor &&
X	compptr->v_samp_factor == cinfo->max_v_samp_factor)
X      cinfo->methods->unsubsample[ci] = fullsize_unsubsample;
X    else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
X	     (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0)
X      cinfo->methods->unsubsample[ci] = h2_unsubsample;
X    else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
X	     (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0)
X      cinfo->methods->unsubsample[ci] = int_unsubsample;
X    else
X      ERREXIT(cinfo->emethods, "Fractional subsampling not implemented yet");
X  }
X
X  cinfo->methods->unsubsample_init = unsubsample_init;
X  cinfo->methods->unsubsample_term = unsubsample_term;
X}
END_OF_FILE
  if test 6290 -ne `wc -c <'jdsample.c'`; then
    echo shar: \"'jdsample.c'\" unpacked with wrong size!
  fi
  # end of 'jdsample.c'
fi
if test -f 'jwrrle.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jwrrle.c'\"
else
  echo shar: Extracting \"'jwrrle.c'\" \(6758 characters\)
  sed "s/^X//" >'jwrrle.c' <<'END_OF_FILE'
X/*
X * jwrrle.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains routines to write output images in RLE format.
X * The Utah Raster Toolkit library is required (version 3.0).
X *
X * These routines may need modification for non-Unix environments or
X * specialized applications.  As they stand, they assume output to
X * an ordinary stdio stream.
X *
X * These routines are invoked via the methods put_pixel_rows, put_color_map,
X * and output_init/term.
X *
X * Based on code contributed by Mike Lijewski.
X */
X
X#include "jinclude.h"
X
X#ifdef RLE_SUPPORTED
X
X/* rle.h is provided by the Utah Raster Toolkit. */
X
X#include <rle.h>
X
X
X/*
X * output_term assumes that JSAMPLE has the same representation as rle_pixel,
X * to wit, "unsigned char".  Hence we can't cope with 12- or 16-bit samples.
X */
X
X#ifndef EIGHT_BIT_SAMPLES
X  Sorry, this code only copes with 8-bit JSAMPLEs. /* deliberate syntax err */
X#endif
X
X
X/*
X * Since RLE stores scanlines bottom-to-top, we have to invert the image
X * from JPEG's top-to-bottom order.  To do this, we save the outgoing data
X * in virtual array(s) during put_pixel_row calls, then actually emit the
X * RLE file during output_term.  We use one virtual array if the output is
X * grayscale or colormapped, more if it is full color.
X */
X
X#define MAX_CHANS	4	/* allow up to four color components */
Xstatic big_sarray_ptr channels[MAX_CHANS]; /* Virtual arrays for saved data */
X
Xstatic long cur_output_row;	/* next row# to write to virtual array(s) */
X
X
X/*
X * For now, if we emit an RLE color map then it is always 256 entries long,
X * though not all of the entries need be used.
X */
X
X#define CMAPBITS	8
X#define CMAPLENGTH	(1<<(CMAPBITS))
X
Xstatic rle_map *output_colormap; /* RLE-style color map, or NULL if none */
Xstatic int number_colors;	/* Number of colors actually used */
X
X
X/*
X * Write the file header.
X *
X * In this module it's easier to wait till output_term to actually write
X * anything; here we just request the big arrays we'll need.
X */
X
XMETHODDEF void
Xoutput_init (decompress_info_ptr cinfo)
X{
X  short ci;
X  
X  if (cinfo->final_out_comps > MAX_CHANS)
X    ERREXIT1(cinfo->emethods, "Cannot handle %d output channels for RLE",
X	     cinfo->final_out_comps);
X  
X  for (ci = 0; ci < cinfo->final_out_comps; ci++) {
X    channels[ci] = (*cinfo->emethods->request_big_sarray)
X			(cinfo->image_width, cinfo->image_height, 1L);
X  }
X  
X  output_colormap = NULL;	/* No output colormap as yet */
X  number_colors = 0;
X  cur_output_row = 0;		/* Start filling virtual arrays at row 0 */
X
X  cinfo->total_passes++;	/* count file writing as separate pass */
X}
X
X
X/*
X * Write some pixel data.
X *
X * This routine just saves the data away in virtual arrays.
X */
X
XMETHODDEF void
Xput_pixel_rows (decompress_info_ptr cinfo, int num_rows,
X		JSAMPIMAGE pixel_data)
X{
X  JSAMPROW outputrow[1];	/* a pseudo JSAMPARRAY structure */
X  int row;
X  short ci;
X  
X  for (row = 0; row < num_rows; row++) {
X    for (ci = 0; ci < cinfo->final_out_comps; ci++) {
X      outputrow[0] = *((*cinfo->emethods->access_big_sarray)
X			(channels[ci], cur_output_row, TRUE));
X      jcopy_sample_rows(pixel_data[ci], row, outputrow, 0,
X			1, cinfo->image_width);
X    }
X    cur_output_row++;
X  }
X}
X
X
X/*
X * Write the color map.
X *
X *  For RLE output we just save the colormap for the output stage.
X */
X
XMETHODDEF void
Xput_color_map (decompress_info_ptr cinfo, int num_colors, JSAMPARRAY colormap)
X{
X  size_t cmapsize;
X  short ci;
X  int i;
X
X  if (num_colors > CMAPLENGTH)
X    ERREXIT1(cinfo->emethods, "Cannot handle %d colormap entries for RLE",
X	     num_colors);
X
X  /* Allocate storage for RLE-style cmap, zero any extra entries */
X  cmapsize = cinfo->color_out_comps * CMAPLENGTH * SIZEOF(rle_map);
X  output_colormap = (rle_map *) (*cinfo->emethods->alloc_small) (cmapsize);
X  MEMZERO((void *) output_colormap, cmapsize);
X
X  /* Save away data in RLE format --- note 8-bit left shift! */
X  /* Shifting would need adjustment for JSAMPLEs wider than 8 bits. */
X  for (ci = 0; ci < cinfo->color_out_comps; ci++) {
X    for (i = 0; i < num_colors; i++) {
X      output_colormap[ci * CMAPLENGTH + i] = GETJSAMPLE(colormap[ci][i]) << 8;
X    }
X  }
X  number_colors = num_colors;
X}
X
X
X/*
X * Finish up at the end of the file.
X *
X * Here is where we really output the RLE file.
X */
X
XMETHODDEF void
Xoutput_term (decompress_info_ptr cinfo)
X{
X  rle_hdr header;		/* Output file information */
X  rle_pixel *output_rows[MAX_CHANS];
X  char cmapcomment[80];
X  short ci;
X  long row;
X
X  /* Initialize the header info */
X  MEMZERO((void *) &header, SIZEOF(rle_hdr)); /* make sure all bits are 0 */
X  header.rle_file = cinfo->output_file;
X  header.xmin     = 0;
X  header.xmax     = cinfo->image_width  - 1;
X  header.ymin     = 0;
X  header.ymax     = cinfo->image_height - 1;
X  header.alpha    = 0;
X  header.ncolors  = cinfo->final_out_comps;
X  for (ci = 0; ci < cinfo->final_out_comps; ci++) {
X    RLE_SET_BIT(header, ci);
X  }
X  if (number_colors > 0) {
X    header.ncmap   = cinfo->color_out_comps;
X    header.cmaplen = CMAPBITS;
X    header.cmap    = output_colormap;
X    /* Add a comment to the output image with the true colormap length. */
X    sprintf(cmapcomment, "color_map_length=%d", number_colors);
X    rle_putcom(cmapcomment, &header);
X  }
X  /* Emit the RLE header and color map (if any) */
X  rle_put_setup(&header);
X
X  /* Now output the RLE data from our virtual array(s).
X   * We assume here that (a) rle_pixel is represented the same as JSAMPLE,
X   * and (b) we are not on a machine where FAR pointers differ from regular.
X   */
X  for (row = cinfo->image_height-1; row >= 0; row--) {
X    (*cinfo->methods->progress_monitor) (cinfo, cinfo->image_height-row-1,
X					 cinfo->image_height);
X    for (ci = 0; ci < cinfo->final_out_comps; ci++) {
X      output_rows[ci] = (rle_pixel *) *((*cinfo->emethods->access_big_sarray)
X					(channels[ci], row, FALSE));
X    }
X    rle_putrow(output_rows, (int) cinfo->image_width, &header);
X  }
X  cinfo->completed_passes++;
X
X  /* Emit file trailer */
X  rle_puteof(&header);
X  fflush(cinfo->output_file);
X  if (ferror(cinfo->output_file))
X    ERREXIT(cinfo->emethods, "Output file write error");
X
X  /* Release memory */
X  /* no work (we let free_all release the workspace) */
X}
X
X
X/*
X * The method selection routine for RLE format output.
X * This should be called from d_ui_method_selection if RLE output is wanted.
X */
X
XGLOBAL void
Xjselwrle (decompress_info_ptr cinfo)
X{
X  cinfo->methods->output_init    = output_init;
X  cinfo->methods->put_color_map  = put_color_map;
X  cinfo->methods->put_pixel_rows = put_pixel_rows;
X  cinfo->methods->output_term    = output_term;
X}
X
X#endif /* RLE_SUPPORTED */
END_OF_FILE
  if test 6758 -ne `wc -c <'jwrrle.c'`; then
    echo shar: \"'jwrrle.c'\" unpacked with wrong size!
  fi
  # end of 'jwrrle.c'
fi
if test -f 'makefile.ansi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.ansi'\"
else
  echo shar: Extracting \"'makefile.ansi'\" \(6360 characters\)
  sed "s/^X//" >'makefile.ansi' <<'END_OF_FILE'
X# Makefile for Independent JPEG Group's software
X
X# This makefile is suitable for Unix-like systems with ANSI-capable compilers.
X# If you have a non-ANSI compiler, makefile.unix is a better starting point.
X
X# Read SETUP instructions before saying "make" !!
X
X# The name of your C compiler:
XCC= cc
X
X# You may need to adjust these cc options:
XCFLAGS= -O
X# In particular:
X#   Add -DBSD if on a pure BSD system (see jinclude.h).
X#   Add -DMEM_STATS to enable gathering of memory usage statistics.
X#   You may also want to add -DTWO_FILE_COMMANDLINE or -D switches for other
X#   symbols listed in jconfig.h, if you prefer not to change jconfig.h.
X
X# Link-time cc options:
XLDFLAGS= 
X
X# To link any special libraries, add the necessary -l commands here.
X# In particular, on some versions of HP-UX (and probably other SysV-derived
X# systems) there is a faster alternate malloc(3) library that you can use
X# by adding "-lmalloc" to this line.
XLDLIBS= 
X
X# miscellaneous OS-dependent stuff
X# linker
XLN= $(CC)
X# file deletion command
XRM= rm -f
X# library (.a) file creation command
XAR= ar rc
X# second step in .a creation (use "touch" if not needed)
XAR2= ranlib
X
X
X# source files (independently compilable files)
XSOURCES= jbsmooth.c jcarith.c jccolor.c jcdeflts.c jcexpand.c jchuff.c \
X        jcmain.c jcmaster.c jcmcu.c jcpipe.c jcsample.c jdarith.c jdcolor.c \
X        jddeflts.c jdhuff.c jdmain.c jdmaster.c jdmcu.c jdpipe.c jdsample.c \
X        jerror.c jquant1.c jquant2.c jfwddct.c jrevdct.c jutils.c jmemmgr.c \
X        jrdjfif.c jrdgif.c jrdppm.c jrdrle.c jrdtarga.c jwrjfif.c jwrgif.c \
X        jwrppm.c jwrrle.c jwrtarga.c
X# virtual source files (not present in distribution file)
XVIRTSOURCES= jmemsys.c
X# system-dependent implementations of source files
XSYSDEPFILES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemdos.h \
X        jmemdosa.asm
X# files included by source files
XINCLUDES= jinclude.h jconfig.h jpegdata.h jversion.h jmemsys.h egetopt.c
X# documentation, test, and support files
XDOCS= README SETUP USAGE CHANGELOG cjpeg.1 djpeg.1 architecture codingrules
XMAKEFILES= makefile.ansi makefile.unix makefile.manx makefile.sas \
X        makefile.mc5 makefile.mc6 makcjpeg.lnk makdjpeg.lnk makefile.bcc \
X        makcjpeg.lst makdjpeg.lst makefile.pwc makcjpeg.cf makdjpeg.cf \
X        makljpeg.cf makefile.mms makefile.vms makvms.opt
XOTHERFILES= ansi2knr.c ckconfig.c example.c
XTESTFILES= testorig.jpg testimg.ppm testimg.gif testimg.jpg
XDISTFILES= $(DOCS) $(MAKEFILES) $(SOURCES) $(SYSDEPFILES) $(INCLUDES) \
X        $(OTHERFILES) $(TESTFILES)
X# objectfiles common to cjpeg and djpeg
XCOMOBJECTS= jutils.o jerror.o jmemmgr.o jmemsys.o
X# compression objectfiles
XCLIBOBJECTS= jcmaster.o jcdeflts.o jcarith.o jccolor.o jcexpand.o jchuff.o \
X        jcmcu.o jcpipe.o jcsample.o jfwddct.o jwrjfif.o jrdgif.o jrdppm.o \
X        jrdrle.o jrdtarga.o
XCOBJECTS= jcmain.o $(CLIBOBJECTS) $(COMOBJECTS)
X# decompression objectfiles
XDLIBOBJECTS= jdmaster.o jddeflts.o jbsmooth.o jdarith.o jdcolor.o jdhuff.o \
X        jdmcu.o jdpipe.o jdsample.o jquant1.o jquant2.o jrevdct.o jrdjfif.o \
X        jwrgif.o jwrppm.o jwrrle.o jwrtarga.o
XDOBJECTS= jdmain.o $(DLIBOBJECTS) $(COMOBJECTS)
X# These objectfiles are included in libjpeg.a
XLIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
X
X
Xall: cjpeg djpeg
X# By default, libjpeg.a is not built unless you explicitly request it.
X# You can add libjpeg.a to the line above if you want it built by default.
X
X
Xcjpeg: $(COBJECTS)
X	$(LN) $(LDFLAGS) -o cjpeg $(COBJECTS) $(LDLIBS)
X
Xdjpeg: $(DOBJECTS)
X	$(LN) $(LDFLAGS) -o djpeg $(DOBJECTS) $(LDLIBS)
X
X# libjpeg.a is useful if you are including the JPEG software in a larger
X# program; you'd include it in your link, rather than the individual modules.
Xlibjpeg.a: $(LIBOBJECTS)
X	$(RM) libjpeg.a
X	$(AR) libjpeg.a  $(LIBOBJECTS)
X	$(AR2) libjpeg.a
X
Xclean:
X	$(RM) *.o cjpeg djpeg libjpeg.a core testout.*
X
Xdistribute:
X	$(RM) jpegsrc.tar*
X	tar cvf jpegsrc.tar $(DISTFILES)
X	compress -v jpegsrc.tar
X
Xtest: cjpeg djpeg
X	$(RM) testout.ppm testout.gif testout.jpg
X	./djpeg testorig.jpg >testout.ppm
X	./djpeg -G testorig.jpg >testout.gif
X	./cjpeg testimg.ppm >testout.jpg
X	cmp testimg.ppm testout.ppm
X	cmp testimg.gif testout.gif
X	cmp testimg.jpg testout.jpg
X
X
Xjbsmooth.o : jbsmooth.c jinclude.h jconfig.h jpegdata.h 
Xjcarith.o : jcarith.c jinclude.h jconfig.h jpegdata.h 
Xjccolor.o : jccolor.c jinclude.h jconfig.h jpegdata.h 
Xjcdeflts.o : jcdeflts.c jinclude.h jconfig.h jpegdata.h 
Xjcexpand.o : jcexpand.c jinclude.h jconfig.h jpegdata.h 
Xjchuff.o : jchuff.c jinclude.h jconfig.h jpegdata.h 
Xjcmain.o : jcmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjcmaster.o : jcmaster.c jinclude.h jconfig.h jpegdata.h 
Xjcmcu.o : jcmcu.c jinclude.h jconfig.h jpegdata.h 
Xjcpipe.o : jcpipe.c jinclude.h jconfig.h jpegdata.h 
Xjcsample.o : jcsample.c jinclude.h jconfig.h jpegdata.h 
Xjdarith.o : jdarith.c jinclude.h jconfig.h jpegdata.h 
Xjdcolor.o : jdcolor.c jinclude.h jconfig.h jpegdata.h 
Xjddeflts.o : jddeflts.c jinclude.h jconfig.h jpegdata.h 
Xjdhuff.o : jdhuff.c jinclude.h jconfig.h jpegdata.h 
Xjdmain.o : jdmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjdmaster.o : jdmaster.c jinclude.h jconfig.h jpegdata.h 
Xjdmcu.o : jdmcu.c jinclude.h jconfig.h jpegdata.h 
Xjdpipe.o : jdpipe.c jinclude.h jconfig.h jpegdata.h 
Xjdsample.o : jdsample.c jinclude.h jconfig.h jpegdata.h 
Xjerror.o : jerror.c jinclude.h jconfig.h jpegdata.h 
Xjquant1.o : jquant1.c jinclude.h jconfig.h jpegdata.h 
Xjquant2.o : jquant2.c jinclude.h jconfig.h jpegdata.h 
Xjfwddct.o : jfwddct.c jinclude.h jconfig.h jpegdata.h 
Xjrevdct.o : jrevdct.c jinclude.h jconfig.h jpegdata.h 
Xjutils.o : jutils.c jinclude.h jconfig.h jpegdata.h 
Xjmemmgr.o : jmemmgr.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
Xjrdjfif.o : jrdjfif.c jinclude.h jconfig.h jpegdata.h 
Xjrdgif.o : jrdgif.c jinclude.h jconfig.h jpegdata.h 
Xjrdppm.o : jrdppm.c jinclude.h jconfig.h jpegdata.h 
Xjrdrle.o : jrdrle.c jinclude.h jconfig.h jpegdata.h 
Xjrdtarga.o : jrdtarga.c jinclude.h jconfig.h jpegdata.h 
Xjwrjfif.o : jwrjfif.c jinclude.h jconfig.h jpegdata.h 
Xjwrgif.o : jwrgif.c jinclude.h jconfig.h jpegdata.h 
Xjwrppm.o : jwrppm.c jinclude.h jconfig.h jpegdata.h 
Xjwrrle.o : jwrrle.c jinclude.h jconfig.h jpegdata.h 
Xjwrtarga.o : jwrtarga.c jinclude.h jconfig.h jpegdata.h 
Xjmemsys.o : jmemsys.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
END_OF_FILE
  if test 6360 -ne `wc -c <'makefile.ansi'`; then
    echo shar: \"'makefile.ansi'\" unpacked with wrong size!
  fi
  # end of 'makefile.ansi'
fi
if test -f 'makefile.mms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.mms'\"
else
  echo shar: Extracting \"'makefile.mms'\" \(6695 characters\)
  sed "s/^X//" >'makefile.mms' <<'END_OF_FILE'
X# Makefile for Independent JPEG Group's software
X
X# This makefile is for use with MMS on VAX/VMS systems.
X# Thanks to Rick Dyson (dyson@iowasp.physics.uiowa.edu) for his help.
X
X# Read SETUP instructions before saying "MMS" !!
X
XCFLAGS= $(CFLAGS) /NoDebug /Optimize /Define = (TWO_FILE_COMMANDLINE,HAVE_STDC,INCLUDES_ARE_ANSI)
XOPT= Sys$Disk:[]MAKVMS.OPT
X
X
X# source files (independently compilable files)
XSOURCES= jbsmooth.c jcarith.c jccolor.c jcdeflts.c jcexpand.c jchuff.c \
X        jcmain.c jcmaster.c jcmcu.c jcpipe.c jcsample.c jdarith.c jdcolor.c \
X        jddeflts.c jdhuff.c jdmain.c jdmaster.c jdmcu.c jdpipe.c jdsample.c \
X        jerror.c jquant1.c jquant2.c jfwddct.c jrevdct.c jutils.c jmemmgr.c \
X        jrdjfif.c jrdgif.c jrdppm.c jrdrle.c jrdtarga.c jwrjfif.c jwrgif.c \
X        jwrppm.c jwrrle.c jwrtarga.c
X# virtual source files (not present in distribution file)
XVIRTSOURCES= jmemsys.c
X# system-dependent implementations of source files
XSYSDEPFILES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemdos.h \
X        jmemdosa.asm
X# files included by source files
XINCLUDES= jinclude.h jconfig.h jpegdata.h jversion.h jmemsys.h egetopt.c
X# documentation, test, and support files
XDOCS= README SETUP USAGE CHANGELOG cjpeg.1 djpeg.1 architecture codingrules
XMAKEFILES= makefile.ansi makefile.unix makefile.manx makefile.sas \
X        makefile.mc5 makefile.mc6 makcjpeg.lnk makdjpeg.lnk makefile.bcc \
X        makcjpeg.lst makdjpeg.lst makefile.pwc makcjpeg.cf makdjpeg.cf \
X        makljpeg.cf makefile.mms makefile.vms makvms.opt
XOTHERFILES= ansi2knr.c ckconfig.c example.c
XTESTFILES= testorig.jpg testimg.ppm testimg.gif testimg.jpg
XDISTFILES= $(DOCS) $(MAKEFILES) $(SOURCES) $(SYSDEPFILES) $(INCLUDES) \
X        $(OTHERFILES) $(TESTFILES)
X# objectfiles common to cjpeg and djpeg
XCOMOBJECTS= jutils.obj jerror.obj jmemmgr.obj jmemsys.obj
X# compression objectfiles
XCLIBOBJECTS= jcmaster.obj jcdeflts.obj jcarith.obj jccolor.obj jcexpand.obj \
X        jchuff.obj jcmcu.obj jcpipe.obj jcsample.obj jfwddct.obj \
X        jwrjfif.obj jrdgif.obj jrdppm.obj jrdrle.obj jrdtarga.obj
XCOBJECTS= jcmain.obj $(CLIBOBJECTS) $(COMOBJECTS)
X# decompression objectfiles
XDLIBOBJECTS= jdmaster.obj jddeflts.obj jbsmooth.obj jdarith.obj jdcolor.obj \
X        jdhuff.obj jdmcu.obj jdpipe.obj jdsample.obj jquant1.obj \
X        jquant2.obj jrevdct.obj jrdjfif.obj jwrgif.obj jwrppm.obj \
X        jwrrle.obj jwrtarga.obj
XDOBJECTS= jdmain.obj $(DLIBOBJECTS) $(COMOBJECTS)
X# These objectfiles are included in libjpeg.olb
XLIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
X# objectfile lists with commas --- what a crock
XCOBJLIST= jcmain.obj,jcmaster.obj,jcdeflts.obj,jcarith.obj,jccolor.obj,\
X          jcexpand.obj,jchuff.obj,jcmcu.obj,jcpipe.obj,jcsample.obj,\
X          jfwddct.obj,jwrjfif.obj,jrdgif.obj,jrdppm.obj,jrdrle.obj,\
X          jrdtarga.obj,jutils.obj,jerror.obj,jmemmgr.obj,jmemsys.obj
XDOBJLIST= jdmain.obj,jdmaster.obj,jddeflts.obj,jbsmooth.obj,jdarith.obj,\
X          jdcolor.obj,jdhuff.obj,jdmcu.obj,jdpipe.obj,jdsample.obj,\
X          jquant1.obj,jquant2.obj,jrevdct.obj,jrdjfif.obj,jwrgif.obj,\
X          jwrppm.obj,jwrrle.obj,jwrtarga.obj,jutils.obj,jerror.obj,\
X          jmemmgr.obj,jmemsys.obj
XLIBOBJLIST= jcmaster.obj,jcdeflts.obj,jcarith.obj,jccolor.obj,jcexpand.obj,\
X          jchuff.obj,jcmcu.obj,jcpipe.obj,jcsample.obj,jfwddct.obj,\
X          jwrjfif.obj,jrdgif.obj,jrdppm.obj,jrdrle.obj,jrdtarga.obj,\
X          jdmaster.obj,jddeflts.obj,jbsmooth.obj,jdarith.obj,jdcolor.obj,\
X          jdhuff.obj,jdmcu.obj,jdpipe.obj,jdsample.obj,jquant1.obj,\
X          jquant2.obj,jrevdct.obj,jrdjfif.obj,jwrgif.obj,jwrppm.obj,\
X          jwrrle.obj,jwrtarga.obj,jutils.obj,jerror.obj,jmemmgr.obj,\
X          jmemsys.obj
X
X
X.first
X	@ Define Sys Sys$Library
X
X# By default, libjpeg.olb is not built unless you explicitly request it.
X# You can add libjpeg.olb to the next line if you want it built by default.
XALL : cjpeg.exe djpeg.exe
X	@ Continue
X
Xcjpeg.exe : $(COBJECTS)
X	$(LINK) $(LFLAGS) /Executable = cjpeg.exe $(COBJLIST),$(OPT)/Option
X
Xdjpeg.exe : $(DOBJECTS)
X	$(LINK) $(LFLAGS) /Executable = djpeg.exe $(DOBJLIST),$(OPT)/Option
X
X# libjpeg.olb is useful if you are including the JPEG software in a larger
X# program; you'd include it in your link, rather than the individual modules.
Xlibjpeg.olb : $(LIBOBJECTS)
X	Library /Create libjpeg.olb $(LIBOBJLIST)
X
Xclean :
X	@- Set Protection = Owner:RWED *.*;-1
X	@- Set Protection = Owner:RWED *.OBJ
X	- Purge /NoLog /NoConfirm *.*
X	- Delete /NoLog /NoConfirm *.OBJ;
X
X
Xjbsmooth.obj : jbsmooth.c jinclude.h jconfig.h jpegdata.h
Xjcarith.obj : jcarith.c jinclude.h jconfig.h jpegdata.h
Xjccolor.obj : jccolor.c jinclude.h jconfig.h jpegdata.h
Xjcdeflts.obj : jcdeflts.c jinclude.h jconfig.h jpegdata.h
Xjcexpand.obj : jcexpand.c jinclude.h jconfig.h jpegdata.h
Xjchuff.obj : jchuff.c jinclude.h jconfig.h jpegdata.h
Xjcmain.obj : jcmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c
Xjcmaster.obj : jcmaster.c jinclude.h jconfig.h jpegdata.h
Xjcmcu.obj : jcmcu.c jinclude.h jconfig.h jpegdata.h
Xjcpipe.obj : jcpipe.c jinclude.h jconfig.h jpegdata.h
Xjcsample.obj : jcsample.c jinclude.h jconfig.h jpegdata.h
Xjdarith.obj : jdarith.c jinclude.h jconfig.h jpegdata.h
Xjdcolor.obj : jdcolor.c jinclude.h jconfig.h jpegdata.h
Xjddeflts.obj : jddeflts.c jinclude.h jconfig.h jpegdata.h
Xjdhuff.obj : jdhuff.c jinclude.h jconfig.h jpegdata.h
Xjdmain.obj : jdmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c
Xjdmaster.obj : jdmaster.c jinclude.h jconfig.h jpegdata.h
Xjdmcu.obj : jdmcu.c jinclude.h jconfig.h jpegdata.h
Xjdpipe.obj : jdpipe.c jinclude.h jconfig.h jpegdata.h
Xjdsample.obj : jdsample.c jinclude.h jconfig.h jpegdata.h
Xjerror.obj : jerror.c jinclude.h jconfig.h jpegdata.h
Xjquant1.obj : jquant1.c jinclude.h jconfig.h jpegdata.h
Xjquant2.obj : jquant2.c jinclude.h jconfig.h jpegdata.h
Xjfwddct.obj : jfwddct.c jinclude.h jconfig.h jpegdata.h
Xjrevdct.obj : jrevdct.c jinclude.h jconfig.h jpegdata.h
Xjutils.obj : jutils.c jinclude.h jconfig.h jpegdata.h
Xjmemmgr.obj : jmemmgr.c jinclude.h jconfig.h jpegdata.h jmemsys.h
Xjrdjfif.obj : jrdjfif.c jinclude.h jconfig.h jpegdata.h
Xjrdgif.obj : jrdgif.c jinclude.h jconfig.h jpegdata.h
Xjrdppm.obj : jrdppm.c jinclude.h jconfig.h jpegdata.h
Xjrdrle.obj : jrdrle.c jinclude.h jconfig.h jpegdata.h
Xjrdtarga.obj : jrdtarga.c jinclude.h jconfig.h jpegdata.h
Xjwrjfif.obj : jwrjfif.c jinclude.h jconfig.h jpegdata.h
Xjwrgif.obj : jwrgif.c jinclude.h jconfig.h jpegdata.h
Xjwrppm.obj : jwrppm.c jinclude.h jconfig.h jpegdata.h
Xjwrrle.obj : jwrrle.c jinclude.h jconfig.h jpegdata.h
Xjwrtarga.obj : jwrtarga.c jinclude.h jconfig.h jpegdata.h
Xjmemsys.obj : jmemsys.c jinclude.h jconfig.h jpegdata.h jmemsys.h
END_OF_FILE
  if test 6695 -ne `wc -c <'makefile.mms'`; then
    echo shar: \"'makefile.mms'\" unpacked with wrong size!
  fi
  # end of 'makefile.mms'
fi
if test -f 'makefile.sas' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.sas'\"
else
  echo shar: Extracting \"'makefile.sas'\" \(6349 characters\)
  sed "s/^X//" >'makefile.sas' <<'END_OF_FILE'
X# Makefile for Independent JPEG Group's software
X
X# This makefile is for Amiga systems using SAS C 5.10b.
X# Use jmemname.c as the system-dependent memory manager.
X# Contributed by Ed Hanway (sisd!jeh@uunet.uu.net).
X
X# Read SETUP instructions before saying "make" !!
X
X# The name of your C compiler:
XCC= lc
X
X# Uncomment the following lines for generic 680x0 version
XARCHFLAGS=
XSUFFIX=
X
X# Uncomment the following lines for 68030-only version
X#ARCHFLAGS= -m3
X#SUFFIX=.030
X
X# You may need to adjust these cc options:
XCFLAGS= -v -b -rr -O -j104 $(ARCHFLAGS) -DHAVE_STDC -DINCLUDES_ARE_ANSI \
X	-DAMIGA -DTWO_FILE_COMMANDLINE -DINCOMPLETE_TYPES_BROKEN \
X	-DNO_MKTEMP -DNEED_SIGNAL_CATCHER
X# -j104 disables warnings for mismatched const qualifiers
X
X# Link-time cc options:
XLDFLAGS= SC SD ND BATCH
X
X# To link any special libraries, add the necessary commands here.
XLDLIBS= LIB LIB:lcr.lib
X
X# miscellaneous OS-dependent stuff
X# linker
XLN= blink
X# file deletion command
XRM= delete quiet
X# library (.lib) file creation command
XAR= oml
X
X
X# source files (independently compilable files)
XSOURCES= jbsmooth.c jcarith.c jccolor.c jcdeflts.c jcexpand.c jchuff.c \
X        jcmain.c jcmaster.c jcmcu.c jcpipe.c jcsample.c jdarith.c jdcolor.c \
X        jddeflts.c jdhuff.c jdmain.c jdmaster.c jdmcu.c jdpipe.c jdsample.c \
X        jerror.c jquant1.c jquant2.c jfwddct.c jrevdct.c jutils.c jmemmgr.c \
X        jrdjfif.c jrdgif.c jrdppm.c jrdrle.c jrdtarga.c jwrjfif.c jwrgif.c \
X        jwrppm.c jwrrle.c jwrtarga.c
X# virtual source files (not present in distribution file)
XVIRTSOURCES= jmemsys.c
X# system-dependent implementations of source files
XSYSDEPFILES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemdos.h \
X        jmemdosa.asm
X# files included by source files
XINCLUDES= jinclude.h jconfig.h jpegdata.h jversion.h jmemsys.h egetopt.c
X# documentation, test, and support files
XDOCS= README SETUP USAGE CHANGELOG cjpeg.1 djpeg.1 architecture codingrules
XMAKEFILES= makefile.ansi makefile.unix makefile.manx makefile.sas \
X        makefile.mc5 makefile.mc6 makcjpeg.lnk makdjpeg.lnk makefile.bcc \
X        makcjpeg.lst makdjpeg.lst makefile.pwc makcjpeg.cf makdjpeg.cf \
X        makljpeg.cf makefile.mms makefile.vms makvms.opt
XOTHERFILES= ansi2knr.c ckconfig.c example.c
XTESTFILES= testorig.jpg testimg.ppm testimg.gif testimg.jpg
XDISTFILES= $(DOCS) $(MAKEFILES) $(SOURCES) $(SYSDEPFILES) $(INCLUDES) \
X        $(OTHERFILES) $(TESTFILES)
X# objectfiles common to cjpeg and djpeg
XCOMOBJECTS= jutils.o jerror.o jmemmgr.o jmemsys.o
X# compression objectfiles
XCLIBOBJECTS= jcmaster.o jcdeflts.o jcarith.o jccolor.o jcexpand.o jchuff.o \
X        jcmcu.o jcpipe.o jcsample.o jfwddct.o jwrjfif.o jrdgif.o jrdppm.o \
X        jrdrle.o jrdtarga.o
XCOBJECTS= jcmain.o $(CLIBOBJECTS) $(COMOBJECTS)
X# decompression objectfiles
XDLIBOBJECTS= jdmaster.o jddeflts.o jbsmooth.o jdarith.o jdcolor.o jdhuff.o \
X        jdmcu.o jdpipe.o jdsample.o jquant1.o jquant2.o jrevdct.o jrdjfif.o \
X        jwrgif.o jwrppm.o jwrrle.o jwrtarga.o
XDOBJECTS= jdmain.o $(DLIBOBJECTS) $(COMOBJECTS)
X# These objectfiles are included in libjpeg.lib
XLIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
X
X
Xall: cjpeg$(SUFFIX) djpeg$(SUFFIX)
X# By default, libjpeg.lib is not built unless you explicitly request it.
X# You can add libjpeg.lib to the line above if you want it built by default.
X
X
Xcjpeg$(SUFFIX): $(COBJECTS)
X	$(LN) <WITH <
X$(LDFLAGS)
XTO cjpeg$(SUFFIX)
XFROM LIB:c.o $(COBJECTS)
X$(LDLIBS)
X<
X
Xdjpeg$(SUFFIX): $(DOBJECTS)
X	$(LN) <WITH <
X$(LDFLAGS)
XTO djpeg$(SUFFIX)
XFROM LIB:c.o $(DOBJECTS)
X$(LDLIBS)
X<
X
X# libjpeg.lib is useful if you are including the JPEG software in a larger
X# program; you'd include it in your link, rather than the individual modules.
Xlibjpeg.lib: $(LIBOBJECTS)
X	-$(RM) libjpeg.lib
X	$(AR) libjpeg.lib r $(LIBOBJECTS)
X
Xclean:
X	-$(RM) *.o cjpeg djpeg cjpeg.030 djpeg.030 libjpeg.lib core testout.*
X
Xdistribute:
X	-$(RM) jpegsrc.tar*
X	tar cvf jpegsrc.tar $(DISTFILES)
X	compress -v jpegsrc.tar
X
Xtest: cjpeg djpeg
X	-$(RM) testout.ppm testout.gif testout.jpg
X	djpeg testorig.jpg testout.ppm
X	djpeg -G testorig.jpg testout.gif
X	cjpeg testimg.ppm testout.jpg
X	cmp testimg.ppm testout.ppm
X	cmp testimg.gif testout.gif
X	cmp testimg.jpg testout.jpg
X
X
Xjbsmooth.o : jbsmooth.c jinclude.h jconfig.h jpegdata.h 
Xjcarith.o : jcarith.c jinclude.h jconfig.h jpegdata.h 
Xjccolor.o : jccolor.c jinclude.h jconfig.h jpegdata.h 
Xjcdeflts.o : jcdeflts.c jinclude.h jconfig.h jpegdata.h 
Xjcexpand.o : jcexpand.c jinclude.h jconfig.h jpegdata.h 
Xjchuff.o : jchuff.c jinclude.h jconfig.h jpegdata.h 
Xjcmain.o : jcmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjcmaster.o : jcmaster.c jinclude.h jconfig.h jpegdata.h 
Xjcmcu.o : jcmcu.c jinclude.h jconfig.h jpegdata.h 
Xjcpipe.o : jcpipe.c jinclude.h jconfig.h jpegdata.h 
Xjcsample.o : jcsample.c jinclude.h jconfig.h jpegdata.h 
Xjdarith.o : jdarith.c jinclude.h jconfig.h jpegdata.h 
Xjdcolor.o : jdcolor.c jinclude.h jconfig.h jpegdata.h 
Xjddeflts.o : jddeflts.c jinclude.h jconfig.h jpegdata.h 
Xjdhuff.o : jdhuff.c jinclude.h jconfig.h jpegdata.h 
Xjdmain.o : jdmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjdmaster.o : jdmaster.c jinclude.h jconfig.h jpegdata.h 
Xjdmcu.o : jdmcu.c jinclude.h jconfig.h jpegdata.h 
Xjdpipe.o : jdpipe.c jinclude.h jconfig.h jpegdata.h 
Xjdsample.o : jdsample.c jinclude.h jconfig.h jpegdata.h 
Xjerror.o : jerror.c jinclude.h jconfig.h jpegdata.h 
Xjquant1.o : jquant1.c jinclude.h jconfig.h jpegdata.h 
Xjquant2.o : jquant2.c jinclude.h jconfig.h jpegdata.h 
Xjfwddct.o : jfwddct.c jinclude.h jconfig.h jpegdata.h 
Xjrevdct.o : jrevdct.c jinclude.h jconfig.h jpegdata.h 
Xjutils.o : jutils.c jinclude.h jconfig.h jpegdata.h 
Xjmemmgr.o : jmemmgr.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
Xjrdjfif.o : jrdjfif.c jinclude.h jconfig.h jpegdata.h 
Xjrdgif.o : jrdgif.c jinclude.h jconfig.h jpegdata.h 
Xjrdppm.o : jrdppm.c jinclude.h jconfig.h jpegdata.h 
Xjrdrle.o : jrdrle.c jinclude.h jconfig.h jpegdata.h 
Xjrdtarga.o : jrdtarga.c jinclude.h jconfig.h jpegdata.h 
Xjwrjfif.o : jwrjfif.c jinclude.h jconfig.h jpegdata.h 
Xjwrgif.o : jwrgif.c jinclude.h jconfig.h jpegdata.h 
Xjwrppm.o : jwrppm.c jinclude.h jconfig.h jpegdata.h 
Xjwrrle.o : jwrrle.c jinclude.h jconfig.h jpegdata.h 
Xjwrtarga.o : jwrtarga.c jinclude.h jconfig.h jpegdata.h 
Xjmemsys.o : jmemsys.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
END_OF_FILE
  if test 6349 -ne `wc -c <'makefile.sas'`; then
    echo shar: \"'makefile.sas'\" unpacked with wrong size!
  fi
  # end of 'makefile.sas'
fi
if test -f 'makefile.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.unix'\"
else
  echo shar: Extracting \"'makefile.unix'\" \(6796 characters\)
  sed "s/^X//" >'makefile.unix' <<'END_OF_FILE'
X# Makefile for Independent JPEG Group's software
X
X# This makefile is suitable for Unix-like systems with non-ANSI compilers.
X# If you have an ANSI compiler, makefile.ansi is a better starting point.
X
X# Read SETUP instructions before saying "make" !!
X
X# The name of your C compiler:
XCC= cc
X
X# You may need to adjust these cc options:
XCFLAGS= -O
X# In particular:
X#   Add -DBSD if on a pure BSD system (see jinclude.h).
X#   Add -DVMS if on a VMS system (see ansi2knr.c).
X#   Add -DMSDOS if on an MSDOS system (see ansi2knr.c).
X#   Add -DMEM_STATS to enable gathering of memory usage statistics.
X#   You may also want to add -DTWO_FILE_COMMANDLINE or -D switches for other
X#   symbols listed in jconfig.h, if you prefer not to change jconfig.h.
X
X# Link-time cc options:
XLDFLAGS= 
X
X# To link any special libraries, add the necessary -l commands here.
X# In particular, on some versions of HP-UX (and probably other SysV-derived
X# systems) there is a faster alternate malloc(3) library that you can use
X# by adding "-lmalloc" to this line.
XLDLIBS= 
X
X# miscellaneous OS-dependent stuff
X# linker
XLN= $(CC)
X# file deletion command
XRM= rm -f
X# library (.a) file creation command
XAR= ar rc
X# second step in .a creation (use "touch" if not needed)
XAR2= ranlib
X
X
X# source files (independently compilable files)
XSOURCES= jbsmooth.c jcarith.c jccolor.c jcdeflts.c jcexpand.c jchuff.c \
X        jcmain.c jcmaster.c jcmcu.c jcpipe.c jcsample.c jdarith.c jdcolor.c \
X        jddeflts.c jdhuff.c jdmain.c jdmaster.c jdmcu.c jdpipe.c jdsample.c \
X        jerror.c jquant1.c jquant2.c jfwddct.c jrevdct.c jutils.c jmemmgr.c \
X        jrdjfif.c jrdgif.c jrdppm.c jrdrle.c jrdtarga.c jwrjfif.c jwrgif.c \
X        jwrppm.c jwrrle.c jwrtarga.c
X# virtual source files (not present in distribution file)
XVIRTSOURCES= jmemsys.c
X# system-dependent implementations of source files
XSYSDEPFILES= jmemansi.c jmemname.c jmemnobs.c jmemdos.c jmemdos.h \
X        jmemdosa.asm
X# files included by source files
XINCLUDES= jinclude.h jconfig.h jpegdata.h jversion.h jmemsys.h egetopt.c
X# documentation, test, and support files
XDOCS= README SETUP USAGE CHANGELOG cjpeg.1 djpeg.1 architecture codingrules
XMAKEFILES= makefile.ansi makefile.unix makefile.manx makefile.sas \
X        makefile.mc5 makefile.mc6 makcjpeg.lnk makdjpeg.lnk makefile.bcc \
X        makcjpeg.lst makdjpeg.lst makefile.pwc makcjpeg.cf makdjpeg.cf \
X        makljpeg.cf makefile.mms makefile.vms makvms.opt
XOTHERFILES= ansi2knr.c ckconfig.c example.c
XTESTFILES= testorig.jpg testimg.ppm testimg.gif testimg.jpg
XDISTFILES= $(DOCS) $(MAKEFILES) $(SOURCES) $(SYSDEPFILES) $(INCLUDES) \
X        $(OTHERFILES) $(TESTFILES)
X# objectfiles common to cjpeg and djpeg
XCOMOBJECTS= jutils.o jerror.o jmemmgr.o jmemsys.o
X# compression objectfiles
XCLIBOBJECTS= jcmaster.o jcdeflts.o jcarith.o jccolor.o jcexpand.o jchuff.o \
X        jcmcu.o jcpipe.o jcsample.o jfwddct.o jwrjfif.o jrdgif.o jrdppm.o \
X        jrdrle.o jrdtarga.o
XCOBJECTS= jcmain.o $(CLIBOBJECTS) $(COMOBJECTS)
X# decompression objectfiles
XDLIBOBJECTS= jdmaster.o jddeflts.o jbsmooth.o jdarith.o jdcolor.o jdhuff.o \
X        jdmcu.o jdpipe.o jdsample.o jquant1.o jquant2.o jrevdct.o jrdjfif.o \
X        jwrgif.o jwrppm.o jwrrle.o jwrtarga.o
XDOBJECTS= jdmain.o $(DLIBOBJECTS) $(COMOBJECTS)
X# These objectfiles are included in libjpeg.a
XLIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
X
X
Xall: ansi2knr cjpeg djpeg
X# By default, libjpeg.a is not built unless you explicitly request it.
X# You can add libjpeg.a to the line above if you want it built by default.
X
X
X# This rule causes ansi2knr to be invoked.  If you use this makefile,
X# make sure PROTO is not defined by jconfig.h.
X
X.c.o:
X	./ansi2knr $*.c tmpansi.c
X	$(CC) $(CFLAGS) -c tmpansi.c
X	mv tmpansi.o $*.o
X	$(RM) tmpansi.c
X
Xansi2knr: ansi2knr.c
X	$(CC) $(CFLAGS) -o ansi2knr ansi2knr.c
X
X
Xcjpeg: ansi2knr $(COBJECTS)
X	$(LN) $(LDFLAGS) -o cjpeg $(COBJECTS) $(LDLIBS)
X
Xdjpeg: ansi2knr $(DOBJECTS)
X	$(LN) $(LDFLAGS) -o djpeg $(DOBJECTS) $(LDLIBS)
X
X# libjpeg.a is useful if you are including the JPEG software in a larger
X# program; you'd include it in your link, rather than the individual modules.
Xlibjpeg.a: ansi2knr $(LIBOBJECTS)
X	$(RM) libjpeg.a
X	$(AR) libjpeg.a  $(LIBOBJECTS)
X	$(AR2) libjpeg.a
X
Xclean:
X	$(RM) *.o cjpeg djpeg libjpeg.a ansi2knr core tmpansi.* testout.*
X
Xdistribute:
X	$(RM) jpegsrc.tar*
X	tar cvf jpegsrc.tar $(DISTFILES)
X	compress -v jpegsrc.tar
X
Xtest: cjpeg djpeg
X	$(RM) testout.ppm testout.gif testout.jpg
X	./djpeg testorig.jpg >testout.ppm
X	./djpeg -G testorig.jpg >testout.gif
X	./cjpeg testimg.ppm >testout.jpg
X	cmp testimg.ppm testout.ppm
X	cmp testimg.gif testout.gif
X	cmp testimg.jpg testout.jpg
X
X
Xjbsmooth.o : jbsmooth.c jinclude.h jconfig.h jpegdata.h 
Xjcarith.o : jcarith.c jinclude.h jconfig.h jpegdata.h 
Xjccolor.o : jccolor.c jinclude.h jconfig.h jpegdata.h 
Xjcdeflts.o : jcdeflts.c jinclude.h jconfig.h jpegdata.h 
Xjcexpand.o : jcexpand.c jinclude.h jconfig.h jpegdata.h 
Xjchuff.o : jchuff.c jinclude.h jconfig.h jpegdata.h 
Xjcmain.o : jcmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjcmaster.o : jcmaster.c jinclude.h jconfig.h jpegdata.h 
Xjcmcu.o : jcmcu.c jinclude.h jconfig.h jpegdata.h 
Xjcpipe.o : jcpipe.c jinclude.h jconfig.h jpegdata.h 
Xjcsample.o : jcsample.c jinclude.h jconfig.h jpegdata.h 
Xjdarith.o : jdarith.c jinclude.h jconfig.h jpegdata.h 
Xjdcolor.o : jdcolor.c jinclude.h jconfig.h jpegdata.h 
Xjddeflts.o : jddeflts.c jinclude.h jconfig.h jpegdata.h 
Xjdhuff.o : jdhuff.c jinclude.h jconfig.h jpegdata.h 
Xjdmain.o : jdmain.c jinclude.h jconfig.h jpegdata.h jversion.h egetopt.c 
Xjdmaster.o : jdmaster.c jinclude.h jconfig.h jpegdata.h 
Xjdmcu.o : jdmcu.c jinclude.h jconfig.h jpegdata.h 
Xjdpipe.o : jdpipe.c jinclude.h jconfig.h jpegdata.h 
Xjdsample.o : jdsample.c jinclude.h jconfig.h jpegdata.h 
Xjerror.o : jerror.c jinclude.h jconfig.h jpegdata.h 
Xjquant1.o : jquant1.c jinclude.h jconfig.h jpegdata.h 
Xjquant2.o : jquant2.c jinclude.h jconfig.h jpegdata.h 
Xjfwddct.o : jfwddct.c jinclude.h jconfig.h jpegdata.h 
Xjrevdct.o : jrevdct.c jinclude.h jconfig.h jpegdata.h 
Xjutils.o : jutils.c jinclude.h jconfig.h jpegdata.h 
Xjmemmgr.o : jmemmgr.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
Xjrdjfif.o : jrdjfif.c jinclude.h jconfig.h jpegdata.h 
Xjrdgif.o : jrdgif.c jinclude.h jconfig.h jpegdata.h 
Xjrdppm.o : jrdppm.c jinclude.h jconfig.h jpegdata.h 
Xjrdrle.o : jrdrle.c jinclude.h jconfig.h jpegdata.h 
Xjrdtarga.o : jrdtarga.c jinclude.h jconfig.h jpegdata.h 
Xjwrjfif.o : jwrjfif.c jinclude.h jconfig.h jpegdata.h 
Xjwrgif.o : jwrgif.c jinclude.h jconfig.h jpegdata.h 
Xjwrppm.o : jwrppm.c jinclude.h jconfig.h jpegdata.h 
Xjwrrle.o : jwrrle.c jinclude.h jconfig.h jpegdata.h 
Xjwrtarga.o : jwrtarga.c jinclude.h jconfig.h jpegdata.h 
Xjmemsys.o : jmemsys.c jinclude.h jconfig.h jpegdata.h jmemsys.h 
END_OF_FILE
  if test 6796 -ne `wc -c <'makefile.unix'`; then
    echo shar: \"'makefile.unix'\" unpacked with wrong size!
  fi
  # end of 'makefile.unix'
fi
echo shar: End of archive 15 \(of 18\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
