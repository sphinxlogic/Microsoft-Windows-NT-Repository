Newsgroups: comp.sources.misc
From: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Subject:  v29i029:  tin - threaded full screen newsreader v1.1P1, Part11/12
Message-ID: <1992Mar27.033945.3696@sparky.imd.sterling.com>
X-Md4-Signature: abeabf93559a7d39e1d5cb0b999eba2f
Date: Fri, 27 Mar 1992 03:39:45 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@germany.eu.net (Iain J. Lea)
Posting-number: Volume 29, Issue 29
Archive-name: tin/part11
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 28, Issue 45-55

#!/bin/sh
# this is tin.shar.11 (part 11 of tin1.1)
# do not concatenate these parts, unpack them in order with /bin/sh
# file thread.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 11; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping thread.c'
else
echo 'x - continuing file thread.c'
sed 's/^X//' << 'SHAR_EOF' >> 'thread.c' &&
static int thread_respnum = 0;
static int first_thread_on_screen = 0;
static int last_thread_on_screen = 0;
X
X
/*
X * show current thread. If threaded on Subject: show
X *   <respnum> <name>    <respnum> <name>
X * If threaded on Archive-name: show
X *   <respnum> <subject> <name>
X */
X 
int show_thread (respnum, group, group_path)
X	int respnum;
X	char *group;
X	char *group_path;
{
#ifndef INDEX_DAEMON
X
X	int ch;
X	int i, index, n;
X	int scroll_lines;
X
X	thread_respnum = respnum;
X	thread_basenote = which_thread (thread_respnum);
X	top_thread = num_of_responses (thread_basenote) + 1;
X
X	if (debug == 2) {
X		sprintf (msg, "THREAD respnum=[%d]  basenote=[%d]  num=[%d]",
X			thread_respnum, thread_basenote, top_thread);
X		info_message (msg);
X		sleep (2);
X	}
X
X	if (top_thread <= 0) {
X		info_message (txt_no_resps_in_thread);
X		return FALSE;
X	}
X
X	if (arts[thread_respnum].archive != (char *) 0) {
X		threaded_on_subject = FALSE;
X	} else {
X		threaded_on_subject = TRUE;
X	}
X
X	thread_index_point = top_thread;
X	if (space_mode) {
X		if (i = new_responses (thread_basenote)) {
X			for (n=0, i = base[thread_basenote]; i >= 0 ;
X				 i = arts[i].thread, n++) {
X				if (arts[i].unread == ART_UNREAD) {
X					thread_index_point = n;
X					break;
X				}
X			}
X		}
X	}
X
X	if (thread_index_point < 0) {
X		thread_index_point = 0;
X	}
X
X	show_thread_page ();
X
X	while (TRUE) {
X		ch = (char) ReadCh();
X
X		if (ch >= '0' && ch <= '9') {	/* 0 goes to basenote */
X			prompt_thread_num (ch);
X		} else switch (ch) {
X			case ESC:	/* common arrow keys */
X				switch (get_arrow_key ()) {
X					case KEYMAP_UP:
X						goto thread_up;
X
X					case KEYMAP_DOWN:
X						goto thread_down;
X
X					case KEYMAP_PAGE_UP:
X						goto thread_page_up;
X
X					case KEYMAP_PAGE_DOWN:
X						goto thread_page_down;
X
X					case KEYMAP_HOME:
X						if (thread_index_point != 0) {
X							thread_index_point = 0;
X							show_thread_page ();
X						}
X						break;
X					
X					case KEYMAP_END:
X						goto end_of_thread;
X				}
X				break;
X
X			case '$':	/* show last page of threads */
end_of_thread:			
X				if (thread_index_point != top_thread) {
X					thread_index_point = top_thread;
X					show_thread_page ();
X				}
X				break;
X				
X			case '\r':
X			case '\n':	/* read current article within thread */
X				n = choose_response (thread_basenote, thread_index_point);
X				n = show_page (n, group, group_path);
X				if (n == thread_basenote) {
X					show_thread_page ();
X				} else {
X					index_point = n;	
X					goto thread_done;
X				}
X				break;
X
X			case '\t':
X 				space_mode = TRUE;
X				if (thread_index_point == 0) {
X					n = thread_respnum;
X				} else {
X					n = choose_response (thread_basenote, thread_index_point);
X				}
X				index = thread_index_point;
X				for (i = n ; i != -1 ; i = arts[i].thread) {
X					if (arts[i].unread == ART_UNREAD) {
X						n = show_page (i, group, group_path);
X						break;
X					}
X					index++;
X				}
X				if (n == thread_basenote) {
X					thread_index_point = index;
X					show_thread_page ();
X				} else {
X					index_point = which_thread (n);	
X					goto thread_done;
X				}
X				break;
X	
X			case ' ':			/* page down */
X			case ctrl('D'):		/* vi style */
X			case ctrl('V'):		/* emacs style */
thread_page_down:
X				if (thread_index_point + 1 == top_thread)
X					break;
X
X				erase_thread_arrow ();
X				scroll_lines = (full_page_scroll ? NOTESLINES : NOTESLINES / 2);
X				thread_index_point = ((thread_index_point + scroll_lines) /
X							scroll_lines) * scroll_lines;
X				if (thread_index_point >= top_thread) {
X					thread_index_point = (top_thread / scroll_lines) * scroll_lines;
X					if (thread_index_point < top_thread - 1) {
X						thread_index_point = top_thread - 1;
X					}
X				}
X				if (thread_index_point < first_thread_on_screen ||
X					thread_index_point >= last_thread_on_screen) {
X					show_thread_page ();
X				} else {
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('L'):		/* redraw screen */
X			case ctrl('R'):
X			case ctrl('W'):
#ifndef USE_CLEARSCREEN
X				ClearScreen ();
#endif
X				show_thread_page ();
X				break;
X
X			case ctrl('N'):
X			case 'j':		/* line down */
thread_down:
X				if (thread_index_point + 1 >= top_thread)
X					break;
X
X				if (thread_index_point + 1 >= last_thread_on_screen) {
#ifndef USE_CLEARSCREEN
X					erase_thread_arrow ();
#endif					
X					thread_index_point++;
X					show_thread_page ();
X				} else {
X					erase_thread_arrow ();
X					thread_index_point++;
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('P'):
X			case 'k':		/* line up */
thread_up:
X				if (! thread_index_point)
X					break;
X
X				if (thread_index_point <= first_thread_on_screen) {
X					thread_index_point--;
X					show_thread_page ();
X				} else {
X					erase_thread_arrow ();
X					thread_index_point--;
X					draw_thread_arrow ();
X				}
X				break;
X
X			case ctrl('U'):		/* page up */
X			case 'b':
thread_page_up:
#ifndef USE_CLEARSCREEN
X				clear_message ();
#endif
X				erase_thread_arrow ();
X				scroll_lines = (full_page_scroll ? NOTESLINES : NOTESLINES / 2);
X				if ((n = thread_index_point % scroll_lines) > 0) {
X					thread_index_point = thread_index_point - n;
X				} else {
X					thread_index_point = ((thread_index_point - scroll_lines) / scroll_lines) * scroll_lines;
X				}
X				if (thread_index_point < 0) {
X					thread_index_point = 0;
X				}
X				if (thread_index_point < first_thread_on_screen
X				|| thread_index_point >= last_thread_on_screen)
X					show_thread_page ();
X				else
X					draw_thread_arrow ();
X				break;
X
X			case 'h':	/* help */
X				show_info_page (HELP_INFO, help_thread, txt_thread_com);
X				show_thread_page ();
X				break;
X
X			case 'I':	/* toggle inverse video */
X				toggle_inverse_video ();
X				show_thread_page ();
X				break;
X
X			case 'i':	/* return */
X			case 'q':
X			case 't':
X				goto thread_done;
X
X			case 'K':	/* mark thread as read */
X				for (i = (int) base[thread_basenote] ; i != -1 ; i = arts[i].thread) {
X					arts[i].unread = ART_READ;
X				}
X				goto thread_done;
X				break;
X
X 			case 'T':	/* tag/untag art for mailing/piping/printing/saving */
X 				if (thread_index_point == 0) {
X 					n = thread_respnum;
X 				} else {
X 					n = choose_response (thread_basenote, thread_index_point);
X 				}
X 				if (n < 0)
X 					break;
X 
X 				if (arts[n].tagged) {
X 					arts[n].tagged = 0;
X 					info_message (txt_untagged_art);
X 				} else {
X 					arts[n].tagged = ++num_of_tagged_files;
X					info_message (txt_tagged_art);
X 				}
X 				show_thread_page ();
X 				break;
X
X			case 'v':	/* version */
X				info_message (cvers);
X				break;
X
X			case 'z':	/* mark article as unread */
X				if (thread_index_point == 0) {
X					n = thread_respnum;
X				} else {
X					n = choose_response (thread_basenote, thread_index_point);
X				}
X				if (n >= 0) {
X					arts[n].unread = ART_UNREAD;
X					show_thread_page ();
X					info_message (txt_art_marked_as_unread);
X				}
X				break;
X
X			case 'Z':	/* mark thread as unread */
X				for (i = (int) base[thread_basenote] ; i != -1 ; i = arts[i].thread) {
X					arts[i].unread = ART_UNREAD;
X				}
X				show_thread_page ();
X				info_message (txt_thread_marked_as_unread);
X				break;
X				
X			default:
X			    info_message (txt_bad_command);
X		}
X	}
X
thread_done:
X	clear_note_area ();
X
#endif /* INDEX_DAEMON */
X
X	return TRUE;
}
X
X
void show_thread_page ()
{
#ifndef INDEX_DAEMON
X
X	extern int index_point;
X	char new_resps[8];
X	char from[LEN];
X	char subject[LEN];
X	int i, j;
X	static int index = 0;
X
X	set_signals_thread ();
X	
X	ClearScreen ();
X
X	if (threaded_on_subject) {
X		sprintf (msg, "Thread (%s)", arts[thread_respnum].subject);
X	} else {
X		sprintf (msg, "List Thread (%d of %d)", index_point+1, top_base);
X	}
X	show_title (msg);
X
X	MoveCursor (INDEX_TOP, 0);
X	if (thread_index_point > top_thread - 1) {
X		thread_index_point = top_thread - 1;
X	}
X
X	if (NOTESLINES <= 0) {
X		first_thread_on_screen = 0;
X	} else {
X		first_thread_on_screen = (thread_index_point / NOTESLINES) * NOTESLINES;
X		if (first_thread_on_screen < 0) {
X			first_thread_on_screen = 0;
X		}
X	}
X
X	last_thread_on_screen = first_thread_on_screen + NOTESLINES;
X
X	if (last_thread_on_screen >= top_thread) {
X		last_thread_on_screen = top_thread;
X		first_thread_on_screen = (top_thread / NOTESLINES) * NOTESLINES;
X
X		if (first_thread_on_screen == last_thread_on_screen ||
X			first_thread_on_screen < 0) {
X			if (first_thread_on_screen < 0) {
X				first_thread_on_screen = 0;
X			} else {
X				first_thread_on_screen = last_thread_on_screen - NOTESLINES;
X			}
X		}
X	}
X
X	if (top_thread == 0) {
X		first_thread_on_screen = 0;
X		last_thread_on_screen = 0;
X	}
X
X	index = choose_response (thread_basenote, first_thread_on_screen);
X	assert(first_thread_on_screen != 0 || index == thread_respnum);
X
X	for (j=0, i = first_thread_on_screen; j < NOTESLINES && i < last_thread_on_screen; i++, j++) {
X		if (arts[index].tagged) {
X			sprintf (new_resps, "%3d", arts[index].tagged);
X		} else if (arts[index].unread == ART_UNREAD) {
X			sprintf (new_resps, "  %c", UNREAD_ART_MARK);
X		} else if (arts[index].unread == ART_WILL_RETURN) {
X			sprintf (new_resps, "  %c", RETURN_ART_MARK);
X		} else {
X			strcpy (new_resps, "   ");
X		}
X
X		get_author (TRUE, index, from);
X
X		if (draw_arrow_mark) {
X			if (threaded_on_subject) {
X				printf ("  %4d%3s  %s\r\n", i, new_resps, from);
X			} else {
X				my_strncpy (subject, arts[index].subject, max_subj);
X				printf ("  %4d%3s  %-*s   %-*s\r\n",
X					i, new_resps, max_subj, subject, max_from, from);
X			}
X		} else {
X			if (threaded_on_subject) {
X				sprintf (screen[j].col, "  %4d%3s  %-*s\r\n", i, new_resps, max_subj+max_from+5, from);
X			} else {
X				my_strncpy (subject, arts[index].subject, max_subj+2);
X				sprintf (screen[j].col, "  %4d%3s  %-*s   %-*s\r\n",
X					i, new_resps, max_subj+2, subject, max_from, from);
X			}
X			printf ("%s", screen[j].col);
X		}
X		
X		if ((index = next_response (index)) == -1) {
X			break;
X		}	
X	}
X
#ifndef USE_CLEARSCREEN
X	CleartoEOS ();
#endif
X
X	if (last_thread_on_screen == top_thread) {
X		info_message (txt_end_of_thread);
X	}
X
X	draw_thread_arrow ();
X
#endif /* INDEX_DAEMON */
}
X
X
void draw_thread_arrow ()
{
X	draw_arrow (INDEX_TOP + (thread_index_point-first_thread_on_screen));
}
X
X
void erase_thread_arrow ()
{
X	erase_arrow (INDEX_TOP + (thread_index_point-first_thread_on_screen));
}
X
X
int prompt_thread_num (ch)
X	char ch;
{
X	int num;
X
X	clear_message ();
X
X	if ((num = prompt_num (ch, txt_read_art)) == -1) {
X		clear_message ();
X		return FALSE;
X	}
X
X	if (num >= top_thread)
X		num = top_thread - 1;
X
X	if (num >= first_thread_on_screen
X	&&  num < last_thread_on_screen) {
X		erase_thread_arrow ();
X		thread_index_point = num;
X		draw_thread_arrow ();
X	} else {
#ifndef USE_CLEARSCREEN
X		erase_thread_arrow ();
#endif		
X		thread_index_point = num;
X		show_thread_page ();
X	}
X	return TRUE;
}
X
/*
X *  Return the number of unread articles there are within a thread
X */
X
int new_responses (thread)
X	int thread;
{
X	int i;
X	int sum = 0;
X
X	for (i = (int) base[thread]; i >= 0; i = arts[i].thread) {
X		if (arts[i].unread) {
X			sum++;
X		}
X	}
X	
X	return sum;
}
X
/*
X *  Which base note (an index into base[]) does a respnum
X *  (an index into arts[]) corresponsd to?
X *
X *  In other words, base[] points to an entry in arts[] which is
X *  the head of a thread, linked with arts[].thread.  For any q: arts[q],
X *  find i such that base[i]->arts[n]->arts[o]->...->arts[q]
X *
X *  Note that which_thread() can return -1 if in show_read_only mode and
X *  the article of interest has been read as well as all other articles in
X *  the thread,  thus resulting in no base[] entry for it.
X */
X
int which_thread (n)
X	int n;
{
X	register int i, j;
X
X	for (i = 0; i < top_base; i++) {
X		for (j = (int) base[i] ; j >= 0 ; j = arts[j].thread) {
X			if (j == n) {
X				return i;
X			}
X		}
X	}
X
X	sprintf (msg, "%d", n);
X	error_message (txt_cannot_find_base_art, msg);
X	return -1;
}
X
/*
X *  Find how deep in a thread a response is.  Start counting at zero
X */
X
int which_response (n)
X	int n;
{
X	int i, j;
X	int num = 0;
X
X	i = which_thread (n);
X	assert(i >= 0);
X
X	for (j = (int) base[i]; j != -1; j = arts[j].thread)
X		if (j == n)
X			break;
X		else
X			num++;
X
X	return num;
}
X
/*
X *  Given an index into base[], find the number of responses for
X *  that basenote
X */
X
int num_of_responses (n)
X	int n;
{
X	int i;
X	int oldi = -3;
X	int sum = 0;
X
X	assert (n < top_base);
X
X	for (i = (int) base[n]; i != -1; i = arts[i].thread) {
X		assert (i != -2);
X		assert (i != oldi);
X		oldi = i;
X		sum++;
X	}
X
X	return sum - 1;
}
X
/*
X *  Find the next response.  Go to the next basenote if there
X *  are no more responses in this thread
X */
X
int next_response (n)
X	int n;
{
X	int i;
X
X	if (arts[n].thread >= 0)
X		return arts[n].thread;
X
X	i = which_thread (n) + 1;
X
X	if (i >= top_base)
X		return -1;
X
X	return (int) base[i];
}
X
/*
X *  Given a respnum (index into arts[]), find the respnum of the
X *  next basenote
X */
X
int next_thread (n)
X	int n;
{
X	int i;
X
X	i = which_thread (n) + 1;
X	if (i >= top_base)
X		return -1;
X
X	return (int) base[i];
}
X
/*
X *  Find the previous response.  Go to the last response in the previous
X *  thread if we go past the beginning of this thread.
X */
X
int prev_response (n)
X	int n;
{
X	int resp;
X	int i;
X
X	resp = which_response (n);
X
X	if (resp > 0)
X		return choose_response (which_thread (n), resp-1);
X
X	i = which_thread (n) - 1;
X
X	if (i < 0)
X		return -1;
X
X	return choose_response (i, num_of_responses (i));
}
X
/*
X *  return response number n from thread i
X */
X
int choose_response (i, n)
X	int i;
X	int n;
{
X	int j;
X
X	j = (int) base[i];
X
X	while (n-- && arts[j].thread >= 0) {
X		j = arts[j].thread;
X	}
X
X	return j;
}
X
/*
X *  Find the next unread response in this group 
X */
X
int next_unread (n)
X	int n;
{
X	while (n >= 0) {
X		if (arts[n].unread == ART_UNREAD) {
X			return n;
X		}
X		n = next_response (n);
X	}
X
X	return -1;
}
X
X
/*
X *  Find the previous unread response in this thread
X */
X
int prev_unread (n)
X	int n;
{
X	while (n >= 0) {
X		if (arts[n].unread == ART_UNREAD) {
X			return n;
X		}
X		n = prev_response (n);
X	}
X
X	return -1;
}
SHAR_EOF
echo 'File thread.c is complete' &&
chmod 0600 thread.c ||
echo 'restore of thread.c failed'
Wc_c="`wc -c < 'thread.c'`"
test 14471 -eq "$Wc_c" ||
	echo 'thread.c: original size 14471, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= wildmat.c ==============
if test -f 'wildmat.c' -a X"$1" != X"-c"; then
	echo 'x - skipping wildmat.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting wildmat.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'wildmat.c' &&
/*  $Revision: 1.5 $
**
**  Do shell-style pattern matching for ?, \, [], and * characters.
**  Might not be robust in face of malformed patterns; e.g., "foo[a-"
**  could cause a segmentation violation.  It is 8bit clean.
**
**  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
**  Rich $alz is now <rsalz@bbn.com>.
**  April, 1991:  Replaced mutually-recursive calls with in-line code
**  for the star character.
**
**  Special thanks to Lars Mathiesen <thorinn@diku.dk> for the ABORT code.
**  This can greatly speed up failing wildcard patterns.  For example:
**	pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-*
**	text 1:	 -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1
**	text 2:	 -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1
**  Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without
**  the ABORT, then it takes 22310 calls to fail.  Ugh.  The following
**  explanation is from Lars:
**  The precondition that must be fulfilled is that DoMatch will consume
**  at least one character in text.  This is true if *p is neither '*' nor
**  '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic
**  behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With
**  FALSE, each star-loop has to run to the end of the text; with ABORT
**  only the last one does.
**
**  Once the control of one instance of DoMatch enters the star-loop, that
**  instance will return either TRUE or ABORT, and any calling instance
**  will therefore return immediately after (without calling recursively
**  again).  In effect, only one star-loop is ever active.  It would be
**  possible to modify the code to maintain this context explicitly,
**  eliminating all recursive calls at the cost of some complication and
**  loss of clarity (and the ABORT stuff seems to be unclear enough by
**  itself).  I think it would be unwise to try to get this into a
**  released version unless you have a good test data base to try it out
**  on.
*/
X
#define TRUE			1
#define FALSE			0
#define ABORT			-1
X
X
X    /* What character marks an inverted character class? */
#define NEGATE_CLASS		'^'
X    /* Is "*" a common pattern? */
#define OPTIMIZE_JUST_STAR
X    /* Do tar(1) matching rules, which ignore a trailing slash? */
#undef MATCH_TAR_PATTERN
X
X
/*
**  Match text and p, return TRUE, FALSE, or ABORT.
*/
static int
DoMatch(text, p)
X    register char	*text;
X    register char	*p;
{
X    register int	last;
X    register int	matched;
X    register int	reverse;
X
X    for ( ; *p; text++, p++) {
X	if (*text == '\0' && *p != '*')
X	    return ABORT;
X	switch (*p) {
X	case '\\':
X	    /* Literal match with following character. */
X	    p++;
X	    /* FALLTHROUGH */
X	default:
X	    if (*text != *p)
X		return FALSE;
X	    continue;
X	case '?':
X	    /* Match anything. */
X	    continue;
X	case '*':
X	    while (*++p == '*')
X		/* Consecutive stars act just like one. */
X		continue;
X	    if (*p == '\0')
X		/* Trailing star matches everything. */
X		return TRUE;
X	    while (*text)
X		if ((matched = DoMatch(text++, p)) != FALSE)
X		    return matched;
X	    return ABORT;
X	case '[':
X	    reverse = p[1] == NEGATE_CLASS ? TRUE : FALSE;
X	    if (reverse)
X		/* Inverted character class. */
X		p++;
X	    matched = FALSE;
X	    if (p[1] == ']' || p[1] == '-')
X		if (*++p == *text)
X		    matched = TRUE;
X	    for (last = *p; *++p && *p != ']'; last = *p)
X		/* This next line requires a good C compiler. */
X		if (*p == '-' && p[1] != ']'
X		    ? *text <= *++p && *text >= last : *text == *p)
X		    matched = TRUE;
X	    if (matched == reverse)
X		return FALSE;
X	    continue;
X	}
X    }
X
#ifdef	MATCH_TAR_PATTERN
X    if (*text == '/')
X	return TRUE;
#endif	/* MATCH_TAR_ATTERN */
X    return *text == '\0';
}
X
X
/*
**  User-level routine.  Returns TRUE or FALSE.
*/
int
wildmat(text, p)
X    char	*text;
X    char	*p;
{
#ifdef	OPTIMIZE_JUST_STAR
X    if (p[0] == '*' && p[1] == '\0')
X	return TRUE;
#endif	/* OPTIMIZE_JUST_STAR */
X    return DoMatch(text, p) == TRUE;
}
X
X
X
#ifdef	TEST
#include <stdio.h>
X
/* Yes, we use gets not fgets.  Sue me. */
extern char	*gets();
X
X
main()
{
X    char	 p[80];
X    char	 text[80];
X
X    printf("Wildmat tester.  Enter pattern, then strings to test.\n");
X    printf("A blank line gets prompts for a new pattern; a blank pattern\n");
X    printf("exits the program.\n");
X
X    for ( ; ; ) {
X	printf("\nEnter pattern:  ");
X	(void)fflush(stdout);
X	if (gets(p) == NULL || p[0] == '\0')
X	    break;
X	for ( ; ; ) {
X	    printf("Enter text:  ");
X	    (void)fflush(stdout);
X	    if (gets(text) == NULL)
X		exit(0);
X	    if (text[0] == '\0')
X		/* Blank line; go back and get a new pattern. */
X		break;
X	    printf("      %s\n", wildmat(text, p) ? "YES" : "NO");
X	}
X    }
X
X    exit(0);
X    /* NOTREACHED */
}
#endif	/* TEST */
SHAR_EOF
chmod 0600 wildmat.c ||
echo 'restore of wildmat.c failed'
Wc_c="`wc -c < 'wildmat.c'`"
test 4749 -eq "$Wc_c" ||
	echo 'wildmat.c: original size 4749, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= tin.h ==============
if test -f 'tin.h' -a X"$1" != X"-c"; then
	echo 'x - skipping tin.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting tin.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tin.h' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : tin.h
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 21-03-92
X *  Notes     : #include files, #defines & struct's
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#include	<stdio.h>
#include	<signal.h>
#include	<sys/types.h>
#include	<pwd.h>
#if !defined(MINIX) && !defined(__convexc__)
#	include	<memory.h>
#endif
#include	<ctype.h>
#include	<time.h>
#include	<sys/stat.h>
X
#ifdef BSD
#	include	<strings.h>
#	include	<fcntl.h>
#else
#	include	<string.h>
#	ifndef MINIX
#		include	<malloc.h>
#	else
#		include	<stdlib.h>
#	endif
#endif
X
#ifdef M_XENIX
#	include	<prototypes.h>
#endif
X
/*
X * Needed for resizing under an xterm
X */
X
#if defined(SIGWINCH)
#	include	<sys/ioctl.h>
#	ifndef TIOCGWINSZ
#		if !defined(sinix) && !defined(nsc)
#			ifdef SCO_UNIX
#				include	<sys/streams.h>
#			else
#				include <sys/stream.h>
#			endif
#			include <sys/ptem.h>
#			include <sys/tty.h>
#			ifndef SVR4
#				include <sys/pty.h>
#			endif
#		endif
#	endif
#endif
X
#if defined(NNTP_ABLE) || defined(NNTP_ONLY)
#	ifndef NNTP_ABLE
#		define	NNTP_ABLE
#	endif
#	ifdef NNTP_EXTS
#		ifndef NNTP_XUSER
#			define	NNTP_XUSER
#		endif
#		ifndef NNTP_XINDEX
#			define	NNTP_XINDEX
#		endif
#	endif
#	ifdef NNTP_XUSER
#		ifndef LOG_USER
#			define	LOG_USER
#		endif
#	endif
#endif
X
/*
X * Index file daemon version of tin. Will create/update index files from cron
X * on NNTP server machine so clients can retreive index file with NNTP XINDEX
X * command from server. Also can be used on machines that just want one copy
X * of all the index files in one place. In this case the normal tin must have
X * access to the index directory or be setuid news.
X */
X 
#ifdef INDEX_DAEMON
#	undef NNTP_ABLE
#	undef NNTP_ONLY
#	undef NNTP_XUSER
#	undef NNTP_XINDEX
#endif
X
#ifndef SIGTYPE
#	if defined(sony)
#		define	SIGTYPE	int
#	else
#		if defined(__STDC__) || defined(__GNUC__) || \
X		   defined(sinix)    || defined(sun) || defined(ultrix)
#			define	SIGTYPE	void
#		else
#			define	SIGTYPE	int
#		endif
#	endif
#endif
X
#ifndef SPOOLDIR
#	define		SPOOLDIR	"/usr/spool/news"
#endif
#ifndef LIBDIR
#	define		LIBDIR		"/usr/lib/news"
#endif
#ifndef INEWSDIR
#	define		INEWSDIR	LIBDIR
#endif
X
#define		DEFAULT_SHELL	"/bin/sh"
X
#ifdef BSD
#	define		strchr(str, ch)	index(str, ch)
#	define		DEFAULT_MAILER	"/bin/mail"
#	define		DEFAULT_EDITOR	"/usr/ucb/vi"
#	define		DEFAULT_MAILBOX	"/usr/spool/mail"
#	define		DEFAULT_PRINTER	"/usr/ucb/lpr"
#	define		DEFAULT_SUM		"sum"
#	ifndef USE_LONG_FILENAMES
#		define USE_LONG_FILENAMES
#	endif
#else
#	ifdef SVR4
#		define		USE_LONG_FILENAMES
#	endif
#	ifdef M_XENIX
#		define		DEFAULT_EDITOR	"/bin/vi"
#		define		DEFAULT_MAILBOX	"/usr/spool/mail"
#	else
#		define		DEFAULT_EDITOR	"/usr/bin/vi"
#		define		DEFAULT_MAILBOX	"/usr/mail"
#	endif
#	ifdef NCR
#		define		DEFAULT_MAILER	"/usr/bin/mailx"
#	endif
#	ifdef RS6000
#		define		DEFAULT_PRINTER	"/bin/lp"
#	endif
#	ifdef UNIXPC
#		define		DEFAULT_MAILER	"/bin/rmail"
#	endif
#	ifdef sinix
#		define		DEFAULT_MAILER	"/bin/rmail"
#		define		DEFAULT_PRINTER	"/bin/lpr"
#		ifndef USE_LONG_FILENAMES
#			define USE_LONG_FILENAMES
#		endif
#	endif
#	ifndef DEFAULT_MAILER
#		define		DEFAULT_MAILER	"/bin/mail"
#	endif
#	ifndef DEFAULT_PRINTER
#		define		DEFAULT_PRINTER	"/usr/bin/lp"
#	endif
#	define		DEFAULT_SUM		"sum -r"
#endif
X
#ifdef USE_LONG_FILENAMES
#	define		LONG_PATH_PART	"part"
#	define		LONG_PATH_PATCH	"patch"
#else
#	define		LONG_PATH_PART	""
#	define		LONG_PATH_PATCH	"p"
#endif
X
#ifdef LOG_USER
#	define		LOG_USER_FILE	"/tmp/.tin_log" 
#endif
X
#ifndef NO_RESYNC_ACTIVE_FILE
#	ifndef RESYNC_ACTIVE_SECS
#		define	RESYNC_ACTIVE_SECS	300	/* reread active every n secs */
#	endif
#endif
X
#define		DEFAULT_ACTIVE_NUM	1800	/* initial size of active array */
#define		DEFAULT_ARTICLE_NUM	400		/* initial size of art array */ 
#define		DEFAULT_KILL_NUM	10		/* initial size of kill array */ 
#define		DEFAULT_SAVE_NUM	10		/* initial size of save array */ 
X
#define		RCDIR			".tin"
#define		RCFILE			"tinrc"
#define		INDEXDIR		".index"
#define		KILLFILE		"kill"
#define		POSTFILE		"posted"
#define		UNTHREADFILE	"unthread"
#define		DEFAULT_MAILDIR	"Mail"
X
#define BUG_REPORT_ADDRESS	"iain%anl433.uucp@germany.eu.net"
X
#ifdef TRUE
#	undef TRUE
#endif
#define		TRUE		1
X
#ifdef FALSE
#	undef FALSE
#endif
#define		FALSE		0
X
#define		LEN					1024
#define		MODULO_COUNT_NUM	5
#define		HEADER_LEN			1024
#define		TABLE_SIZE			1409
#define		MAX_PAGES			1000
#define		ctrl(c)				((c) & 0x1F)
X
X
#ifndef DEFAULT_COMMENT
#	define		DEFAULT_COMMENT	": "	/* used when by follow-ups & replys */
#endif
#ifndef UNREAD_ART_MARK
#	define		UNREAD_ART_MARK	'+'	/* used to show that an art is unread */
#endif
#ifndef RETURN_ART_MARK
#	define		RETURN_ART_MARK	'-'	/* used to show that an art will return */
#endif
X
#ifdef USE_INVERSE_HACK
#	define		BLANK_SELECT_COLS	30
#	define		BLANK_GROUP_COLS	2
#	define		BLANK_PAGE_COLS		2
#else
#	define		BLANK_SELECT_COLS	58
#	define		BLANK_GROUP_COLS	0
#	define		BLANK_PAGE_COLS		0
#endif
X
#define		SCREEN_READ_UNREAD		6		/* position for "  +" / "   " */
#define		DEFAULT_COLS			132		/* used when updating indexes */
#define		INDEX_TOP				2
X
/*
X *  used by get_arrow_key()
X */
X
#define		KEYMAP_UNKNOWN			0
#define		KEYMAP_UP				1
#define		KEYMAP_DOWN				2
#define		KEYMAP_PAGE_UP			3
#define		KEYMAP_PAGE_DOWN		4
#define		KEYMAP_HOME				5
#define		KEYMAP_END				6
X
/*
X *  used by feed.c - feed_articles()
X */
X 
#define		SELECT_LEVEL			1
#define		GROUP_LEVEL				2
#define		PAGE_LEVEL				3
X
#define		FEED_MAIL				1
#define		FEED_PIPE				2
#define		FEED_PRINT				3
#define		FEED_SAVE				4
X
/*
X *  used in art.c & rcfile.c
X */
X 
#define		SORT_BY_NOTHING			0		/* sort types on arts[] array */
#define		SORT_BY_SUBJ_DESCEND	1
#define		SORT_BY_SUBJ_ASCEND		2
#define		SORT_BY_FROM_DESCEND	3
#define		SORT_BY_FROM_ASCEND		4
#define		SORT_BY_DATE_DESCEND	5
#define		SORT_BY_DATE_ASCEND		6
X
#define		SHOW_FROM_NONE			0
#define		SHOW_FROM_ADDR			1
#define		SHOW_FROM_NAME			2
#define		SHOW_FROM_BOTH			3
X
/*
X *  used in help.c
X */
X
#define		HELP_INFO				0
#define		POST_INFO				1
X
/*
X *  used in save.c
X */
X
#define		CHECK_ANY_NEWS			0
#define		START_ANY_NEWS			1
#define		MAIL_ANY_NEWS			2
#define		SAVE_ANY_NEWS			3
X
/*
X *  used in help.c
X */
X
#define		HEADER_TO				0
#define		HEADER_SUBJECT			1
X
/*
X *  used in page.c & post.c
X */
X
#define		POSTED_NONE				0
#define		POSTED_REDRAW			1
#define		POSTED_OK				2
X
/*
X *  Assertion verifier
X */
X
#if __STDC__
#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, #p); else
#else
#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, "p"); else
#endif
X
#define		ESC		27
#if defined(BSD) || defined(MINIX)
#	define		CR		'\r'
#else
#	define		CR		10
#endif
X
/*
X * return codes for change_rcfile ()
X */
X
#define		NO_KILLING		0
#define		KILLING			1
X
/*
X *  art.thread
X */
X
#define		ART_NORMAL		-1
#define		ART_EXPIRED		-2
X
/*
X *  art.unread
X */
X
#define		ART_READ		0
#define		ART_UNREAD		1
#define		ART_WILL_RETURN	2
X
/*
X * used by group_t & my_group[]
X */
X 
#define		UNSUBSCRIBED	0x01	/* haven't put in my_group[] yet */
#define		SUBSCRIBED		0x02	/* subscribed to */
X
/*
X * kill_type used in struct kill_t
X */
X 
#define KILL_SUBJ	1
#define KILL_FROM	2
#define KILL_BOTH	3
X
/*
X * used in feed.c & save.c
X */
X 
#define POST_PROC_NONE			0
#define POST_PROC_SHAR			1
#define POST_PROC_UUDECODE		2
#define POST_PROC_UUD_LST_ZOO	3
#define POST_PROC_UUD_EXT_ZOO	4
X
/*
X *  struct article_t - article header
X *
X *  article.artnum:
X *	article number in spool directory for group
X *
X *  article.thread:
X *	initially -1
X *	points to another arts[] (struct article_t): zero and up
X *	-2 means article has expired (wasn't found in file search
X *	of spool directory for the group)
X *
X *  article.inthread:
X *	FALSE for the first article in a thread, TRUE for all
X *	following articles in thread
X *
X *  article.unread:
X *	boolean, has this article been read or not
X *
X *  article.date
X *  date: line used for sorting articles by date order
X *
X *  article.archive:
X *	archive name used in *source* groups
X *
X *  article.part:
X *	part no. of archive
X *
X *  article.patch:
X *	patch no. of archive
X *
X *  article.killed:
X *	boolean, has this article been killed
X *
X *  article.tagged:
X *	boolean, has this article been tagged for saving or not
X */
X
struct article_t {
X	long artnum;
X	char *subject;	/* Subject: line from mail header */
X	char *from;		/* From: line from mail header (address) */
X	char *name;		/* From: line from mail header (full name) */
X	int thread;
X	int inthread;
X	int unread;		/* 0 = read, 1 = unread, 2 = will return */
X	char date[16];	/* Date: line from mail header */
X	char *archive;	/* Archive-name: line from mail header */
X	char *part;		/* part no. of archive */
X	char *patch;	/* patch no. of archive */
X	int killed;		/* 0 = not killed, 1 = killed */
X	int tagged;		/* 0 = not tagged, 1 = tagged */
};
X
/*
X *  struct group_t - newsgroup info from active file
X */
X
struct group_t {
X	char *name;
X	long max;
X	long min;
X	char moderated;
X	int next;		/* next active entry in hash chain */
X	int flag;
X	int read;		/* marked TRUE if group was entered during session */
X	int thread;		/* marked FALSE if group is not to be threaded */
};
X
/*
X *  used in hashstr.c
X */
X 
struct hashnode {
X	char *s;						/* the string we're saving */
X	struct hashnode *next;			/* chain for spillover */
};
X
/*
X *  used in kill.c
X */
X 
struct kill_t {
X	int kill_type;
X	long kill_group;
X	char *kill_subj;
X	char *kill_from;
};
X
struct save_t {
X	char *subject;
X	char *dir;
X	char *file;
X	char *archive;
X	char *part;
X	char *patch;
X	int index;	
X	int saved;	
X	int is_mailbox;	
};
X
struct screen_t {
X	char *col;
};
X
struct posted_t {
X	char date[10];
X	char group[80];
X	char subj[120];
};
X
/*
X *  function prototypes	& extern definitions	
X */ 
X
#include	"patchlev.h"
#include	"extern.h"
#include	"proto.h"
SHAR_EOF
chmod 0600 tin.h ||
echo 'restore of tin.h failed'
Wc_c="`wc -c < 'tin.h'`"
test 10183 -eq "$Wc_c" ||
	echo 'tin.h: original size 10183, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= extern.h ==============
if test -f 'extern.h' -a X"$1" != X"-c"; then
	echo 'x - skipping extern.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting extern.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'extern.h' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : lang.h
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 21-03-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
/*
X * Library functions
X */
X
#if !defined(__STDC__)
extern char *getenv();
#endif
X
extern int optind;
extern char *optarg;
X
/*
X * Local variables
X */
X 
extern char *help_group[];
extern char *help_page[];
extern char *help_select[];
extern char *help_thread[];
extern char active_file[LEN];
extern char add_addr[LEN];
extern char art_search_string[LEN];
extern char article[LEN];
extern char author_search_string[LEN];
extern char bug_addr[LEN];
extern char cvers[LEN];
extern char dead_article[LEN];
extern char default_mail_address[LEN];
extern char default_pipe_command[LEN];
extern char default_post_subject[LEN];
extern char default_regex_pattern[LEN];
extern char default_save_file[LEN];
extern char default_shell_command[LEN];
extern char delgroups[LEN];
extern char group_search_string[LEN];
extern char homedir[LEN];
extern char indexdir[LEN];
extern char killfile[LEN];
extern char killfrom[LEN];
extern char killsubj[LEN];
extern char mail_news_user[LEN];
extern char mailbox[LEN];
extern char maildir[LEN];
extern char mailer[LEN];
extern char msg[LEN];
extern char my_org[LEN];
extern char newnewsrc[LEN];
extern char newsrc[LEN];
extern char nntp_server[LEN];
extern char page_header[LEN];
extern char postfile[LEN];
extern char printer[LEN];
extern char cmd_line_printer[LEN];
extern char proc_ch_default;				/* set in change_rcfile () */
extern char progname[LEN];
extern char rcdir[LEN];
extern char rcfile[LEN];
extern char redirect_output[LEN];
extern char reply_to[LEN];
extern char savedir[LEN];
extern char sig[LEN];
extern char signature[LEN];
extern char spooldir[LEN];
extern char subject_search_string[LEN];
extern char subscriptions_file[LEN];
extern char txt_help_bug_report[LEN];
extern char unthreadfile[LEN];
extern char userid[LEN];
X
extern char txt_group[];
extern char txt_cannot_open_art[];
extern char txt_indexing[];
extern char txt_indexing_num[];
extern char txt_corrupt_index[];
extern char txt_checking_for_news[];
extern char txt_there_is_no_news[];
extern char txt_killing_arts[];
extern char txt_unkilling_arts[];
extern char txt_art_thread_regex_tag[];
extern char txt_post_process_type[];
extern char txt_feed_pattern[];
extern char txt_no_command[];
extern char txt_piping[];
extern char txt_cannot_post[];
extern char txt_tagged_art[];
extern char txt_untagged_art[];
extern char txt_inverse_on[];
extern char txt_inverse_off[];
extern char txt_subscribed_to[];
extern char txt_unsubscribed_to[];
extern char txt_mark_all_read[];
extern char txt_no_more_groups[];
extern char txt_no_prev_group[];
extern char txt_no_arts[];
extern char txt_no_groups[];
extern char txt_end_of_thread[];
extern char txt_end_of_arts[];
extern char txt_end_of_groups[];
extern char txt_no_next_unread_art[];
extern char txt_no_prev_unread_art[];
extern char txt_no_last_message[];
extern char txt_bad_command[];
extern char txt_you_have_mail[];
extern char txt_type_h_for_help[];
extern char txt_read_art[];
extern char txt_author_search_forwards[];
extern char txt_author_search_backwards[];
extern char txt_search_forwards[];
extern char txt_search_backwards[];
extern char txt_no_search_string[];
extern char txt_no_match[];
extern char txt_post_subject[];
extern char txt_no_subject[];
extern char txt_cannot_open[];
extern char txt_posting[];
extern char txt_art_posted[];
extern char txt_art_rejected[];
extern char txt_abort_edit_post[];
extern char txt_index_page_com[];
extern char txt_thread_com[];
extern char txt_help_i_4[];
extern char txt_help_ctrl_k[];
extern char txt_help_ctrl_l[];
extern char txt_help_ctrl_d[];
extern char txt_help_i_cr[];
extern char txt_help_i_tab[];
extern char txt_help_d[];
extern char txt_help_l[];
extern char txt_help_m[];
extern char txt_help_M[];
extern char txt_help_a[];
extern char txt_help_sel_c[];
extern char txt_help_c[];
extern char txt_help_g[];
extern char txt_help_I[];
extern char txt_help_K[];
extern char txt_help_t_K[];
extern char txt_help_j[];
extern char txt_help_i_n[];
extern char txt_help_i_p[];
extern char txt_help_q[];
extern char txt_help_r[];
extern char txt_help_s[];
extern char txt_help_S[];
extern char txt_help_t[];
extern char txt_help_T[];
extern char txt_help_u[];
extern char txt_help_U[];
extern char txt_help_v[];
extern char txt_help_w[];
extern char txt_help_i_search[];
extern char txt_help_thread[];
#ifndef NO_SHELL_ESCAPE
extern char txt_help_shell[];
#endif
extern char txt_help_dash[];
extern char txt_save_pattern[];
extern char txt_saved_pattern_to[];
extern char txt_saved_to_mailbox[];
extern char txt_switch_on_kill_art_menu[];
extern char txt_post_history_menu[];
extern char txt_hit_space_for_more[];
extern char txt_kill_menu[];
extern char txt_kill_subject[];
extern char txt_kill_from[];
extern char txt_kill_text[];
extern char txt_kill_text_type[];
extern char txt_kill_group[];
extern char txt_help_kill_subject[];
extern char txt_help_kill_from[];
extern char txt_help_kill_text[];
extern char txt_help_kill_text_type[];
extern char txt_help_kill_group[];
extern char txt_abort_edit_save_killfile[];
extern char txt_quit[];
extern char txt_art_unavailable[];
extern char txt_art_marked_as_unread[];
extern char txt_thread_marked_as_unread[];
extern char txt_begin_of_art[];
extern char txt_next_resp[];
extern char txt_last_resp[];
extern char txt_more_percent[];
extern char txt_more[];
extern char txt_thread_x_of_n[];
extern char txt_art[];
extern char txt_resp_x_of_n[];
extern char txt_no_resp[];
extern char txt_1_resp[];
extern char txt_x_resp[];
extern char txt_s_at_s[];
extern char txt_thread_resp_page[];
extern char txt_thread_page[];
extern char txt_read_resp[];
extern char txt_art_pager_com[];
extern char txt_help_p_0[];
extern char txt_help_p_4[];
extern char txt_help_p_cr[];
extern char txt_help_p_tab[];
extern char txt_help_b[];
extern char txt_help_C[];
extern char txt_help_bug[];
extern char txt_help_p_f[];
extern char txt_help_ctrl_h[];
extern char txt_help_h[];
extern char txt_help_p_i[];
extern char txt_help_p_k[];
extern char txt_help_p_m[];
extern char txt_help_p_n[];
extern char txt_help_o[];
extern char txt_help_p_p[];
extern char txt_help_p_r[];
extern char txt_help_p_s[];
extern char txt_help_p_z[];
extern char txt_help_p_ctrl_r[];
extern char txt_help_p_g[];
extern char txt_help_p_d[];
extern char txt_help_pipe[];
extern char txt_help_p_search[];
extern char txt_mail_art_to[];
extern char txt_no_mail_address[];
extern char txt_abort_edit_send[];
extern char txt_abort_edit_cancel[];
extern char txt_cancelling[];
extern char txt_art_cancelled[];
extern char txt_mailing_to[];
extern char txt_message_sent[];
extern char txt_command_failed_s[];
extern char txt_in_art_you_write[];
extern char txt_resp_to_poster[];
extern char txt_resp_redirect[];
extern char txt_continue[];
extern char txt_writes[];
extern char txt_writes_name[];
extern char txt_save_filename[];
extern char txt_art_not_saved[];
extern char txt_no_filename[];
extern char txt_saving[];
extern char txt_art_saved_to[];
extern char txt_thread_not_saved[];
extern char txt_thread_saved_to_many[];
extern char txt_thread_saved_to[];
extern char txt_pipe_to_command[];
extern char txt_command_failed[];
extern char txt_printing[];
extern char txt_printed[];
extern char txt_append_to_file[];
extern char txt_hit_any_key[];
extern char txt_option_not_enabled[];
extern char txt_not_in_active_file[];
extern char txt_screen_init_failed[];
extern char txt_bad_active_file[];
extern char txt_creating_newsrc[];
extern char txt_deleting_from_newsrc[];
extern char txt_cannot_open_active_file[];
extern char txt_reading_active_file[];
extern char txt_active_file_is_empty[];
extern char txt_subscribe_to_new_group[];
extern char txt_checking_active_file[];
extern char txt_checking[];
extern char txt_cannot_find_base_art[];
extern char txt_out_of_memory[];
extern char txt_rename_error[];
extern char txt_shell_escape[];
extern char txt_connecting[];
extern char txt_cannot_get_nntp_server_name[];
extern char txt_server_name_in_file_env_var[];
extern char txt_failed_to_connect_to_server[];
extern char txt_rejected_by_nntpserver[];
extern char txt_connection_to_server_broken[];
extern char txt_stuff_nntp_cannot_open[];
extern char txt_nntp_to_fp_cannot_reopen[];
extern char txt_nntp_to_fd_cannot_reopen[];
extern char txt_toggled_rot13[];
extern char txt_no_arts_posted[];
extern char txt_post_an_article[];
extern char txt_post_a_followup[];
extern char txt_mail_bug_report[];
extern char txt_mail_bug_report_confirm[];
extern char txt_reply_to_author[];
extern char txt_opt_autosave[];
extern char txt_opt_save_separate[];
extern char txt_opt_mark_saved_read[];
extern char txt_opt_kill_articles[];
extern char txt_opt_show_author[];
extern char txt_opt_draw_arrow[];
extern char txt_opt_post_process[];
extern char txt_opt_print_header[];
extern char txt_opt_pos_first_unread[];
extern char txt_opt_page_scroll[];
extern char txt_opt_catchup_groups[];
extern char txt_opt_thread_arts[];
extern char txt_opt_show_only_unread[];
extern char txt_opt_process_type[];
extern char txt_opt_sort_type[];
extern char txt_show_from_none[];
extern char txt_show_from_addr[];
extern char txt_show_from_name[];
extern char txt_show_from_both[];
extern char txt_post_process_none[];
extern char txt_post_process_sh[];
extern char txt_post_process_uudecode[];
extern char txt_post_process_uud_lst_zoo[];
extern char txt_post_process_uud_ext_zoo[];
extern char txt_sort_by_nothing[];
extern char txt_sort_by_subj_descend[];
extern char txt_sort_by_subj_ascend[];
extern char txt_sort_by_from_descend[];
extern char txt_sort_by_from_ascend[];
extern char txt_sort_by_date_descend[];
extern char txt_sort_by_date_ascend[];
extern char txt_opt_savedir[];
extern char txt_opt_maildir[];
extern char txt_opt_printer[];
extern char txt_options_menu[];
extern char txt_help_autosave[];
extern char txt_help_save_separate[];
extern char txt_help_print_header[];
extern char txt_help_pos_first_unread[];
extern char txt_help_show_author[];
extern char txt_help_draw_arrow[];
extern char txt_help_kill_articles[];
extern char txt_help_mark_saved_read[];
extern char txt_help_page_scroll[];
extern char txt_help_catchup_groups[];
extern char txt_help_thread_arts[];
extern char txt_help_show_only_unread[];
extern char txt_help_post_proc_type[];
extern char txt_help_sort_type[];
extern char txt_help_savedir[];
extern char txt_help_maildir[];
extern char txt_help_printer[];
extern char txt_select_rcfile_option[];
extern char txt_post_processing[];
extern char txt_post_processing_finished[];
extern char txt_deleting[];
extern char txt_uudecoding[];
extern char txt_searching[];
extern char txt_moving[];
extern char txt_subscribe_pattern[];
extern char txt_unsubscribe_pattern[];
extern char txt_subscribing[];
extern char txt_subscribing_to[];
extern char txt_unsubscribing[];
extern char txt_unsubscribing_from[];
extern char txt_subscribed_num_groups[];
extern char txt_unsubscribed_num_groups[];
extern char txt_del_group_in_newsrc[];
extern char txt_group_deleted[];
extern char txt_group_undeleted[];
extern char txt_mark_group_read[];
extern char txt_no_groups_to_delete[];
extern char txt_reset_newsrc[];
extern char txt_post_newsgroup[];
extern char txt_yanking_all_groups[];
extern char txt_yanking_sub_groups[];
extern char txt_no_groups_to_read[];
extern char txt_added_groups[];
extern char txt_plural[];
extern char txt_no_groups_to_yank_in[];
extern char txt_group_selection[];
extern char txt_select_group[];
extern char txt_group_select_com[];
extern char txt_help_g_4[];
extern char txt_help_g_ctrl_r[];
extern char txt_help_g_ctrl_k[];
extern char txt_help_g_cr[];
extern char txt_help_g_tab[];
extern char txt_help_g_c[];
extern char txt_help_n[];
extern char txt_help_W[];
extern char txt_help_g_y[];
extern char txt_help_g_z[];
extern char txt_help_g_dollar[];
extern char txt_help_g_search[];
extern char txt_newsgroup[];
extern char txt_newsgroup_position[];
extern char txt_resizing_window[];
extern char txt_no_resps_in_thread[];
extern char txt_help_t_0[];
extern char txt_help_t_4[];
extern char txt_help_t_cr[];
extern char txt_help_t_tab[];
X
extern int LINES, COLS;
extern int MORE_POS;
extern int NOTESLINES;
extern int RIGHT_POS;
extern int *my_group;
extern int *unread;
extern int can_post;
extern int catchup;
extern int catchup_read_groups;
extern int cmd_line;
extern int compiled_with_nntp;
extern int created_rcdir;
extern int debug;
extern int default_printer;
extern int default_show_author;
#ifdef SIGTSTP
extern int do_sigtstp;
#endif
extern int draw_arrow_mark;
extern int full_page_scroll;
extern int group_hash[TABLE_SIZE];
extern int group_top;
extern int index_file_killed;
extern int inverse_okay;
extern int kill_articles;
extern int kill_num;
extern int local_index;
extern int mail_news;
extern int mark_saved_read;
extern int max_active;
extern int max_art;
extern int max_from;
extern int max_subj;
extern int max_kill;
extern int max_save;
extern int nntp_codeno;
extern int num_active;
extern int num_of_killed_files;
extern int num_of_tagged_files;
extern int pos_first_unread;
extern int post_proc_type;
extern int print_header;
extern int process_id;
extern int read_news_via_nntp;
extern int real_gid;
extern int real_uid;
extern int save_archive_name;
extern int save_news;
extern int save_num;
extern int save_separate;
extern int show_author;
extern int show_only_unread;
extern int sort_art_type;
extern int space_mode;
extern int start_line_offset;
extern int thread_arts;
extern int tin_gid;
extern int tin_uid;
extern int top;
extern int top_base;
extern int unlink_article;
extern int update;
extern int verbose;
extern int update_fork;
extern int check_any_unread;
extern int start_any_unread;
extern int notify_new_groups;
X
extern long *base;
X
extern struct passwd *myentry;
extern struct article_t *arts;
extern struct group_t *active;
extern struct kill_t *killf;
extern struct posted_t *posted;
extern struct save_t *save;
extern struct screen_t *screen;
X
#ifdef POSIX_JOB_CONTROL
extern struct sigaction art_act;
extern struct sigaction group_act;
extern struct sigaction kill_act;
extern struct sigaction main_act;
extern struct sigaction old_act;
extern struct sigaction page_act;
extern struct sigaction rcfile_act;
extern struct sigaction select_act;
extern struct sigaction thread_act;
#endif
SHAR_EOF
chmod 0600 extern.h ||
echo 'restore of extern.h failed'
Wc_c="`wc -c < 'extern.h'`"
test 14795 -eq "$Wc_c" ||
	echo 'extern.h: original size 14795, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= nntp.h ==============
if test -f 'nntp.h' -a X"$1" != X"-c"; then
	echo 'x - skipping nntp.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting nntp.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'nntp.h' &&
/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : nntp.h
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 10-03-92
X *  Notes     : Changed a bit so nntp knows about Tin
X *              This file is originally from the nntp 1.5 source.
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
#ifndef	NNTP_SERVER_FILE
#	define	NNTP_SERVER_FILE	"/etc/nntpserver"
#endif
X
/*
X *  External routine declarations
X */
X
extern char *getserverbyfile();
extern int server_init();
extern int get_tcp_socket();
extern int handle_server_response();
extern void put_server();
extern int get_server();
extern void close_server();
X
/*
X *  External file descriptors for the server connection
X */
X
extern FILE *ser_wr_fp;
X
/*
X * Response codes for NNTP server
X *
X * @(#)nntp.h	1.7	(Berkeley) 1/11/88
X *
X * First digit:
X *
X *	1xx	Informative message
X *	2xx	Command ok
X *	3xx	Command ok so far, continue
X *	4xx	Command was correct, but couldn't be performed
X *		for some specified reason.
X *	5xx	Command unimplemented, incorrect, or a
X *		program error has occured.
X *
X * Second digit:
X *
X *	x0x	Connection, setup, miscellaneous
X *	x1x	Newsgroup selection
X *	x2x	Article selection
X *	x3x	Distribution
X *	x4x	Posting
X */
X
#define	CHAR_INF	'1'
#define	CHAR_OK		'2'
#define	CHAR_CONT	'3'
#define	CHAR_ERR	'4'
#define	CHAR_FATAL	'5'
X
#define	INF_HELP		100	/* Help text on way */
#define	INF_DEBUG		199	/* Debug output */
X
#define	OK_CANPOST		200	/* Hello; you can post */
#define	OK_NOPOST		201	/* Hello; you can't post */
#define	OK_SLAVE		202	/* Slave status noted */
#define	OK_GOODBYE		205	/* Closing connection */
#define	OK_GROUP		211	/* Group selected */
#define	OK_GROUPS		215	/* Newsgroups follow */
X
#define OK_XINDEX		218	/* Tin index follows */
X
#define	OK_ARTICLE		220	/* Article (head & body) follows */
#define	OK_HEAD			221	/* Head follows */
#define	OK_BODY			222	/* Body follows */
#define	OK_NOTEXT		223	/* No text sent -- stat, next, last */
#define	OK_NEWNEWS		230	/* New articles by message-id follow */
#define	OK_NEWGROUPS		231	/* New newsgroups follow */
#define	OK_XFERED		235	/* Article transferred successfully */
#define	OK_POSTED		240	/* Article posted successfully */
X
#define CONT_XFER		335	/* Continue to send article */
#define	CONT_POST		340	/* Continue to post article */
X
#define	ERR_GOODBYE		400	/* Have to hang up for some reason */
#define	ERR_NOGROUP		411	/* No such newsgroup */
#define	ERR_NCING		412	/* Not currently in newsgroup */
X
#define ERR_XINDEX		418	/* No tin index for this group */
X
#define	ERR_NOCRNT		420	/* No current article selected */
#define	ERR_NONEXT		421	/* No next article in this group */
#define	ERR_NOPREV		422	/* No previous article in this group */
#define	ERR_NOARTIG		423	/* No such article in this group */
#define ERR_NOART		430	/* No such article at all */
#define ERR_GOTIT		435	/* Already got that article, don't send */
#define ERR_XFERFAIL		436	/* Transfer failed */
#define	ERR_XFERRJCT		437	/* Article rejected, don't resend */
#define	ERR_NOPOST		440	/* Posting not allowed */
#define	ERR_POSTFAIL		441	/* Posting failed */
X
#define	ERR_COMMAND		500	/* Command not recognized */
SHAR_EOF
true || echo 'restore of nntp.h failed'
fi
echo 'End of tin1.1 part 11'
echo 'File nntp.h is continued in part 12'
echo 12 > _shar_seq_.tmp
exit 0

--
NAME   Iain Lea 
EMAIL  iain%anl433.uucp@germany.eu.net
SNAIL  Siemens AG, ANL A433SZ, Gruendlacher Str. 248, 8510 Fuerth, Germany.
PHONE  +49-911-3089-407 (work) +49-911-331963 (home) +49-911-3089-290 (FAX)  
-- 
 Dr. med. dipl.-math Dieter Becker           Tel.: (0 / +49) 6841 - 16 3046
 Medizinische Universitaets- und Poliklinik  Fax.: (0 / +49) 6841 - 16 3369
 Innere Medizin III                         
 D - 6650 Homburg / Saar                     Email: becker@med-in.uni-sb.de
exit 0 # Just in case...
