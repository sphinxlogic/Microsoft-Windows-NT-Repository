Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i101:  zsh2.2 - The Z shell, Part05/17
Message-ID: <1992May13.155855.8883@sparky.imd.sterling.com>
X-Md4-Signature: 30e617310b385a8a79d232cff6bf0558
Date: Wed, 13 May 1992 15:58:55 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 101
Archive-name: zsh2.2/part05
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.05 (part 5 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/man/man1/zsh.1 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/man/man1/zsh.1'
else
echo 'x - continuing file zsh2.2/man/man1/zsh.1'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/man/man1/zsh.1' &&
Xon the commands.
XIf the \-\fBl\fP flag is given, the resulting commands are listed on
Xstandard output.
XOtherwise the editor program \fIename\fP is invoked on a file containing
Xthese history events.  If \fIename\fP is not given, the value
Xof the parameter \fBFCEDIT\fP is used.  If \fIename\fP is "\-",
Xno editor is invoked.  When editing is complete, the edited
Xcommand(s) is executed.  
XIf \fIfirst\fP is not specified, it will be set to \-1 (the most recent
Xevent), or to -16 if the \-\fBl\fP flag is given.
XIf \fIlast\fP is not specified, it will be set to \fIfirst\fP,
Xor to \-1 if the \-\fBl\fP flag is given.
XThe flag \-\fBr\fP reverses the order of the commands and the
Xflag \-\fBn\fP suppresses command numbers when listing.
XAlso when listing, \-\fBd\fP prints datestamps for each command,
Xand \-\fBD\fP prints real execution times.
X.RS
X.PP
X\fBfc\fP \-\fBR\fP reads the history from the given file,
X\fBfc\fP \-\fBW\fP writes the history out to the given file,
Xand \fBfc\fP \-\fBA\fP appends the history out to the given file.
X.RE
X.TP
X.PD 0
X\fBfg\fP [ \fIjob\fP ... ]
X.TP
X\fIjob\fP ...
X.PD
XBring the specified \fIjob\fPs to the foreground.
XIf no \fIjob\fP is specified, use the current job.
X.TP
X\fBfunctions\fP [ \(+-\fBtu\fP ] [ \fIname\fP ... ]
XEquivalent to \fBtypeset\fP \-\fBf\fP.
X.TP
X\fBgetln\fP \fIname\fP ...
XRead the top value from the buffer stack and put it in
Xthe shell parameter \fIname\fP.  Equivalent to
X\fBread\fP \-\fBzr\fP.
X.TP
X\fBgetopts\fP \fIoptstring\fP \fIname\fP [ \fIarg\fP ... ]
XChecks \fBarg\fP for legal options.  If \fIarg\fP is omitted,
Xuse the positional parameters.  A valid option argument
Xbegins with a + or a \-.  An argument not beginning with
Xa + or a \-, or the argument \-\-, ends the options.
X\fIoptstring\fP contains the letters that \fBgetopts\fP
Xrecognizes.  If a letter is followed by a `:', that option
Xis expected to have an argument.  The options can be
Xseparated from the argument by blanks.
X.RS
X.PP
XEach time it is invoked, \fBgetopts\fP places the option letter it finds
Xin the shell parameter \fIname\fP, prepended with a + when
X\fIarg\fP begins with a +.  The index of the next \fIarg\fP
Xis stored in \fBOPTIND\fP.  The option argument, if any,
Xis stored in \fBOPTARG\fP.
X.PP
XA leading : in \fIoptstring\fP causes \fBgetopts\fP to store the
Xletter of the invalid option in \fBOPTARG\fP, and to set \fIname\fP
Xto `?' for an unknown option and to `:' when a required option
Xis missing.  Otherwise, \fBgetopts\fP prints an error
Xmessage.  The exit status is nonzero when there are no more options.
X.RE
X.TP
X\fBhash\fP \fIname\fP \fIpath\fP
XPuts \fIname\fP in the command hash table, associating it with
Xthe pathname \fIpath\fP.  Whenever \fIname\fP is used as a command
Xargument, the shell will try to execute the file given by \fIpath\fP.
X.TP
X\fBhistory\fP [ \-\fBnr\fP ] [ \fIfirst\fP [ \fIlast\fP ] ]
XSame as \fBfc\fP \-\fBl\fP.
X.TP
X\fBinteger\fP
XSame as \fBtypeset\fP \-\fBi\fP.
X.TP
X\fBjobs\fP [ \-\fBlp\fP ] [ \fIjob\fP ... ]
XLists information about each given job, or all jobs
Xif \fIjob\fP is omitted.  The \-\fBl\fP flag lists process
Xids, and the \-\fBp\fP flag lists process groups.
X.TP
X.PD 0
X\fBkill\fP [ \-\fIsig\fP ] \fIjob\fP ...
X.TP
X\fBkill\fP \-\fBl\fP
X.PD
XSends either SIGTERM or the specified signal to the given
Xjobs or processes.
XSignals are given by number or by names
X(with the prefix "SIG" removed).
XIf the signal being sent is not KILL or CONT, then the job
Xwill be sent a CONT signal if it is stopped.
XThe argument \fIjob\fP can be the process id of a job
Xnot in the job list.
XIn the second form, \fBkill\fP \-\fBl\fP, the signal names
Xare listed.
X.TP
X\fBlet\fP \fIarg\fP ...
XEvaluate each \fIarg\fP as an arithmetic expression.
XSee \fBARITHMETIC EVALUATION\fP above for a description
Xof arithmetic expressions.  The exit status is 0 if the
Xvalue of the last expression is nonzero, and 1 otherwise.
X.TP
X.PD 0
X\fBlimit\fP [ \-\fBh\fP ] [ \fIresource\fP [ \fIlimit\fP ] ] ...
X.TP
X\fBlimit\fP \-\fBs\fP
X.PD
XLimit the resource consumption of children of the current shell.
XIf \fIlimit\fP is not specified, print the current limit placed
Xon \fIresource\fP; otherwise
Xset the limit to the specified value.  If the \-\fBh\fP flag
Xis given, use hard limits instead of soft limits.
XIf no \fIresource\fP is given, print all limits.
X.RS
X.PP
X\fIresource\fP is one of:
X.PP
X.PD 0
X.TP
X.B cputime
XMaximum CPU seconds per process.
X.TP
X.B filesize
XLargest single file allowed.
X.TP
X.B datasize
XMaximum data size (including stack) for each process.
X.TP
X.B stacksize
XMaximum stack size for each process.
X.TP
X.B coredumpsize
XMaximum size of a core dump.
X.TP
X.B resident
XMaximum resident set size.
X.TP
X.B descriptors
XMaximum value for a file descriptor.
X.PD
X.PP
X\fIlimit\fP is a number, with an optional scaling factor, as follows:
X.PP
X.PD 0
X.TP
X\fIn\fPh
Xhours.
X.TP
X\fIn\fPk
Xkilobytes. 
XThis is the default for all but cputime.
X.TP
X\fIn\fPm
Xmegabytes or minutes.
X.TP
X\fImm\fP:\fBss\fP
Xminutes and seconds.
X.PD
X.RE
X.TP
X\fBlocal\fP
XSame as \fBtypeset\fP.
X.TP
X\fBlog\fP
XList all users currently logged in who are affected by
Xthe current setting of the \fBwatch\fP parameter.
X.TP
X\fBlogout\fP
XExit the shell, if this is a login shell.
X.TP
X\fBpopd\fP [ \(+-\fIn\fP ]
XRemoves entries from the directory stack.  With no arguments,
Xremoves the top directory from the stack, and performs a \fBcd\fP
Xto the new top directory.  With an argument of the form +\fIn\fP,
Xremove the \fIn\fPth entry counting from the left of the list
Xshown by the \fBdirs\fP command, starting with zero, and change
Xto that directory.  With an argument of the form \-\fIn\fP,
Xremove the \fIn\fPth entry counting from the right.
XIf the \fBPUSHD_MINUS\fP option is set, the meanings of +
Xand \- in this context are swapped.
X.TP
X\fBprint\fP [ \-\fBRnrslzpNDP\fP ] [ \-\fBu\fP\fIn\fP ] [ \fIarg\fP ... ]
XWith no flags or with flag \-, the arguments are printed on
Xthe standard output as described by \fBecho\fP.
X.RS
X.PD 0
X.TP
X\-\fBR\fP, \-\fBr\fP
Xignore the escape conventions of \fBecho\fP.
XThe \-\fBR\fP option will print all subsequent
Xarguments and options.
X.TP
X\-\fBs\fP
Xplace the results in the history list instead of on the standard output.
X.TP
X\-\fBn\fP
Xdo not add a newline to the output.
X.TP
X\-\fBl\fP
Xprint the arguments separated by newlines instead of spaces.
X.TP
X\-\fBN\fP
Xprint the arguments separated and terminated by nulls.
X.TP
X\-\fBu\fP\fIn\fP
Xprint the arguments to file descriptor \fIn\fP.
X.TP
X\-\fBp\fP
Xprint the arguments to the input of the coprocess.
X.TP
X\-\fBz\fP
Xpush the arguments onto the editing buffer stack, separated by spaces;
Xno escape sequences are recognized.
X.TP
X\-\fBD\fP
Xtreat the arguments as directory names, replacing prefixes with ~
Xexpressions, as appropriate.
X.TP
X\-\fBP\fP
Xrecognize the same escape sequences as in the \fBPROMPT\fP parameter.
X.PD
X.RE
X.TP
X.PD 0
X\fBpushd\fP [ \fIarg\fP ]
X.TP
X\fBpushd\fP \fIold\fP \fInew\fP
X.TP
X\fBpushd\fP \(+-\fBn\fP
X.PD
XChange the current directory, and push the old current directory
Xonto the directory stack.  In the first form, change the
Xcurrent directory to \fIarg\fP.
XIf \fIarg\fP is not specified, change to the second directory
Xon the stack (that is, exchange the top two entries), or
Xchange to the value of \fBHOME\fP if the \fBPUSHD_TO_HOME\fP
Xoption is set or if there is only one entry on the stack.
XIf \fIarg\fP is \-, change to the
Xvalue of \fBOLDPWD\fP, the previous directory.
XIf a directory named \fIarg\fP is not found in the current directory
Xand \fIarg\fP does not contain a slash,
Xsearch each component of the shell parameter \fBcdpath\fP.
XIf the option \fBCDABLEVARS\fP is set, and a parameter named \fIarg\fP
Xexists whose value begins with a slash, treat its value as
Xthe directory.
XIf the option \fBPUSHD_SILENT\fP is not set, the directory
Xstack will be printed after a \fBpushd\fP is performed.
X.RS
X.PP
XThe second form of \fBpushd\fP substitutes the string \fInew\fP
Xfor the string \fIold\fP in the name of the current directory,
Xand tries to change to this new directory.
X.PP
XThe third form of \fBpushd\fP is equivalent to \fBpopd\fP.
X.RE
X.TP
X\fBpwd\fP
XEquivalent to \fBprint \-R $PWD\fP.
X.TP
X\fBr\fP
XEquivalent to \fBfc \-e \-\fP.
X.TP
X\fBread\fP [ \-\fBrzp\fP ] [ \-\fBu\fIn\fR ] [ \fIname\fP?\fIprompt\fP ] [ \fIname\fP ...  ]
XRead one line and break it into fields using the characters
Xin \fBIFS\fP as separators.  In raw mode, \-\fBr\fP, a \e
Xat the end of a line does not signify line continuation.
XIf the \-\fBz\fP flag is set, read from the editor buffer stack.
XThe first field is assigned to the first \fIname\fP, the second field
Xto the second \fIname\fP, etc., with leftover
Xfields assigned to the last \fIname\fP.
XIf \fIname\fP is omitted then \fBREPLY\fP is used.
XIf \-\fBu\fIn\fR is specified, then input is read from file
Xdescriptor \fIn\fP; if \-\fBp\fP is specified, then input is
Xread from the coprocess.
XThe exit status is 0 unless end-of-file is encountered.
XIf the first argument contains a \fB?\fP, the remainder of this
Xword is used as a \fIprompt\fP on standard error when the shell
Xis interactive.  The exit status is 0 unless an end-of-file
Xis encountered.
X.TP
X\fBreadonly\fP [ \fIname\fP[=\fIvalue\fP] ] ...
XThe given \fInames\fP are marked readonly; these names
Xcannot be changed by subsequent assignment.
X.TP
X\fBrehash\fP [ \-\fBf\fP ]
XThrow out the command hash table and start over.
XIf the \-\fBf\fP option is set, rescan the command path
Ximmediately, instead of rebuilding the hash table incrementally.
X.TP
X\fBreturn\fP [ \fIn\fP ]
XCauses a shell function or \fB\&.\fP script to return to
Xthe invoking script
Xwith the return status specified by \fIn\fP.  If \fIn\fP
Xis omitted then the return status is that of the last command
Xexecuted.
X.TP
X.PD 0
X\fBsched\fP [+]\fIhh\fP:\fImm\fP \fIcommand\fP ...
X.TP
X\fBsched\fP [ \-\fIitem\fP ]
X.PD
XMake an entry in the scheduled list of commands to execute.
XThe time may be specified in either absolute or relative time.
XWith no arguments, prints the list of scheduled commands.
XWith the argument \-\fIitem\fP, removes the given item
Xfrom the list.
X.TP
X\fBset\fP [ \(+-\fIoptions\fP ] [ \(+-\fBo\fP \fIoption name\fP ] ... [ \-\fBA\fP \fIname\fP ] [ \fIarg\fP ] ...
XSet the options for the shell and/or set the positional parameters, or
Xdeclare an array.  For the meaning of the flags, see
X\fBOPTIONS\fP above.
XFlags may be specified by name using the \-\fBo\fP option.
XIf the \-\fBA\fP flag is specified, \fIname\fP is set to an
Xarray containing the given \fIarg\fPs.
XOtherwise the positional parameters are set.
XIf no arguments are given, then the names and values
Xof all parameters are printed on the standard output.
XIf the only argument is +, the names of all parameters are printed.
X.TP
X\fBsetopt\fP [ \(+-\fIoptions\fP ] [ \fIname\fP ... ]
XSet the options for the shell.  All options specified either
Xwith flags or by name are set.  If no arguments are supplied,
Xthe names of all options currently set are printed.
XIn option names, case is insignificant, and all underscore
Xcharacters are ignored.
X.TP
X\fBshift\fP [ \fIn\fP ]
XThe positional parameters from $\fIn\fP+\fB1\fP ... are renamed
X$\fB1\fP, where \fIn\fP is an arithmetic expression that
Xdefaults to 1.
X.TP
X\fBsource\fP
XSame as \fB.\fP.
X.TP
X\fBsuspend\fP [ \-\fBf\fP ]
XSuspend the execution of the shell (send it a \fBSIGTSTP\fP)
Xuntil it receives a \fBSIGCONT\fP.
XIf the \-\fBf\fP option is not given, complain if this is a login shell.
X.TP
X.PD 0
X\fBtest\fP \fIarg\fP ...
X.TP
X\fB[\fP \fIarg\fP ... \fB]\fP
X.PD
XLike the system version of \fBtest\fP.  Added for compatibility;
Xuse conditional expressions instead.
X.TP
X\fBtimes\fP
XPrint the accumulated user and system times for the shell
Xand for processes run from the shell.
X.TP
X\fBtrap\fP [ \fIarg\fP ] [ \fIsig\fP ] ...
X\fIarg\fP is a command to be read and executed when the shell
Xreceives \fIsig\fP.  Each \fIsig\fP can be given as a number
Xor as the name of a signal.
XIf \fIarg\fP is \-, then all traps \fIsig\fP are reset to their
Xdefault values.  If \fIarg\fP is the null string, then this signal
Xis ignored by the shell and by the commands it invokes.
XIf \fIsig\fP is \fBERR\fP then \fIarg\fP will be executed
Xafter each command.
XIf \fIsig\fP is \fB0\fP or \fBEXIT\fP
Xand the \fBtrap\fP statement is executed inside the body of a function,
Xthen the command \fIarg\fP is executed after the function completes.
XIf \fIsig\fP is \fB0\fP or \fBEXIT\fP
Xand the \fBtrap\fP statement is not executed inside the body of a function,
Xthen the command \fIarg\fP is executed when the shell terminates.
XThe \fBtrap\fP command with no arguments prints a list of commands
Xassociated with each signal.
X.TP
X\fBtrue\fP
XDo nothing and return an exit code of 0.
X.TP
X\fBttyctl\fP \-\fBfu\fP
XThe \-\fBf\fP option freezes the tty, and \-\fBu\fP unfreezes it.
XWhen the tty is frozen, no changes made to the tty settings by
Xexternal programs will be honored by the shell; the shell will
Xsimply reset the settings to their previous values as soon as each
Xcommand exits.  Thus, \fBstty\fP and similar programs have no
Xeffect when the tty is frozen.
X.TP
X\fBtype\fP
XSame as \fBwhence\fP \-\fBv\fP.
X.TP
X\fBtypeset\fP [ \(+-\fBLRZfilrtux [\fIn\fP]] [ \fIname\fP[=\fIvalue\fP] ] ...
XSet attributes and values for shell parameters.
XWhen invoked inside a function, if \fIname\fP is not already
Xdefined, a new parameter is created which will be unset when the
Xfunction completes.
XThe following attributes are valid:
X.RS
X.PD 0
X.TP
X\-\fBL\fP
XLeft justify and remove leading blanks from \fIvalue\fP.
XIf \fIn\fP is nonzero, it defines the width of the field;
Xotherwise it is determined by the width of the value of the first
Xassignment.
XWhen the parameter is printed, it is filled on the right with
Xblanks or truncated if necessary to fit the field.
XLeading zeros are removed if the \-\fBZ\fP flag is also set.
X.TP
X\-\fBR\fP
XRight justify and fill with leading blanks.  If \fIn\fP is nonzero
Xif defines the width of the field;
Xotherwise it is determined by the width of the value of the first
Xassignment.
XWhen the parameter is printed, the field is left filled with
Xblanks or truncated from the end.
X.TP
X\-\fBZ\fP
XRight justify and fill with leading zeros if the first non-blank
Xcharacter is a digit and the \-\fBL\fP flag has not been set.
XIf \fIn\fP is nonzero it defines the width of the field;
Xotherwise it is determined by the width of the value of the
Xfirst assignment.
X.TP
X\-\fBf\fP
XThe names refer to functions rather than parameters.  No assignments
Xcan be made, and the only other valid flags are \-\fBt\fP
Xand \-\fBu\fP.  The flag \-\fBt\fP turns on execution tracing for this
Xfunction.  The flag \-\fBu\fP causes this function to be marked
Xfor autoloading.  The \fBfpath\fP parameter will be searched to find the
Xfunction definition when the function is first referenced.
X.TP
X\-\fBi\fP
XUse an internal integer representation.  If \fBi\fP is nonzero
Xit defines the output arithmetic base, otherwise it is determined by the first
Xassignment.
X.TP
X\-\fBl\fP
XConvert to lower case.
X.TP
X\-\fBr\fP
XThe given \fIname\fPs are marked readonly.
X.TP
X\-\fBt\fP
XTags the named parameters.  Tags have no special meaning to the shell.
X.TP
X\-\fBu\fP
XConvert to upper case.
X.TP
X\-\fBx\fP
XMark for automatic export to the environment of subsequently
Xexecuted commands.
X.RE
X.PD
X.PP
XUsing + rather than \- causes these flags to be turned off.
XIf no arguments are given but flags are specified,
Xa list of named parameters which have these flags set is printed.
XUsing + instead of \- keeps their values from being printed.
XIf no arguments or options are given, the names and attributes
Xof all parameters are printed.
X.TP
X\fBulimit\fP [ \-\fBHSacdfmnt\fP ] [ \fIlimit\fP ]
XSet or display a resource limit.  The value of limit can be a number
Xin the unit specified below or the value \fBunlimited\fP.
XThe \fBH\fP and \fBS\fP flags specify whether the hard limit
Xor the soft limit for the given resource is set.
X.RS
X.PD 0
X.TP
X\-\fBa\fP
XLists all of the current resource limits.
X.TP
X\-\fBc\fP
XThe number of 512-byte blocks on the size of core dumps.
X.TP
X\-\fBd\fP
XThe number of K-bytes on the size of the data segment.
X.TP
X\-\fBf\fP
XThe number of 512-byte blocks on the size of files written.
X.TP
X\-\fBm\fP
XThe number of K-bytes on the size of physical memory.
X.TP
X\-\fBn\fP
XThe number of file descriptors.
X.TP
X\-\fBs\fP
XThe number of K-bytes on the size of the stack.
X.TP
X\-\fBt\fP
XThe number of CPU seconds to be used.
X.RE
X.PD
X.TP
X\fBumask\fP [ \fImask\fP ]
XThe umask is set to \fImask\fP.  \fImask\fP can be either
Xan octal number or a symbolic value as described in \fBchmod\fP(1).
XIf \fImask\fP is omitted, the current value is printed.
X.TP
X\fBunalias\fP \fIname\fP ...
XThe alias definition, if any, for each \fIname\fP is removed.
X.TP
X\fBunfunction\fP \fIname\fP ...
XThe function definition, if any, for each \fIname\fP is removed.
X.TP
X\fBunhash\fP \fIname\fP ...
XThe entry in the command hash table, if any, for each \fIname\fP
Xis removed.
X.TP
X\fBunlimit\fP [ \-\fBh\fP ] \fIresource\fP ...
XThe resource limit for each \fIresource\fP is set to the hard limit.
XIf the \-\fBh\fP flag is given and the shell is running as root,
Xthe hard resource limit for each \fIresource\fP is removed.
X.TP
X\fBunset\fP \fIname\fP ...
XEach named parameter is unset.
X.TP
X\fBunsetopt\fP [ \(+-\fIoptions\fP ] [ \fIname\fP ... ]
XUnset the options for the shell.  All options specified either
Xwith flags or by name are unset.
X.TP
X\fBvared\fP \fIname\fP
XThe value of the parameter \fIname\fP is loaded into the edit
Xbuffer, and the line editor is invoked.  When the editor exits,
X\fIname\fP is set to the string value returned by the editor.
X.TP
X\fBwait\fP [ \fIjob\fP ... ]
XWait for the specified jobs or processes.  If \fIjob\fP is not given
Xthen all currently active child processes are waited for.
XEach \fIjob\fP can be either a job specification or the process-id
Xof a job in the job table.
XThe exit status from this command is that of the job waited for.
X.TP
X\fBwhence\fP [ \-\fBacpv\fP ] \fIname\fP ...
XFor each name, indicate how it would be interpreted if used
Xas a command name.  The \-\fBv\fP flag produces a more verbose
Xreport.  The \-\fBp\fP flag does a path search for \fIname\fP
Xeven if it is a shell function, alias, or reserved word.
XThe \-\fBc\fP flag prints the results in a csh-like format.
XThe \-\fBa\fP flag does a search for all occurences of \fIname\fP
Xthroughout the command path.
X.TP
X\fBwhich\fP
XSame as \fBwhence \-c\fP.
X.RE
X.SH INVOCATION
XCommands are first read from /etc/zshenv.
XThen, if the \fBNO_RCS\fP option is unset, commands are read
Xfrom $ZDOTDIR/.zshenv.
X(If \fBZDOTDIR\fP is unset, \fBHOME\fP is used instead).
XThen, if the shell is interactive and
Xthe \fBNO_RCS\fP option is unset, commands are read
Xfrom /etc/zshrc and $ZDOTDIR/.zshrc, in that order, if either file
Xexists.
XIf the first character of argument zero passed to the shell
Xis \-, then the shell is assumed to be a login shell, and commands
Xare read from /etc/zprofile and $ZDOTDIR/.zprofile before .zshrc is read,
Xthen /etc/zlogin and $ZDOTDIR/.zlogin after .zshrc is read.
XIf the \fBNO_RCS\fP option is set, only /etc/zshrc
X/etc/zlogin, and /etc/zprofile may be read.
XIf the \-\fBs\fP flag is not present and an argument is given,
Xthe first argument is taken to be the pathname of a script to
Xexecute.  The remaining arguments are assigned to the positional
Xparameters.  The following flags are interpreted by the shell
Xwhen invoked:
X.TP
X.PD 0
X\-\fBc\fP \fIstring\fP
XRead commands from \fIstring\fP.
X.TP
X\-\fBs\fP
XRead command from the standard input.
X.TP
X\-\fBi\fP
XIf this flag is present or the shell input and output
Xare attached to a terminal, this shell is interactive.
X.PD
X.SH "SEE ALSO"
Xsh(1),
Xcsh(1),
Xtcsh(1),
Xitcsh(1),
Xrc(1),
Xbash(1),
Xash(1),
Xksh(1),
Xclam(1),
Xstrftime(3).
X.SH FILES
X$ZDOTDIR/.zshenv
X.br
X$ZDOTDIR/.zshrc
X.br
X$ZDOTDIR/.zlogin
X.br
X$ZDOTDIR/.zlogout
X.br
X$ZDOTDIR/.zprofile
X.br
X/tmp/zsh*
X.br
X/etc/zshenv
X.br
X/etc/zprofile
X.br
X/etc/zshrc
X.br
X/etc/zlogin
X.SH AUTHOR
XPaul Falstad (pfalstad@phoenix.princeton.edu)
X.SH "UNDOCUMENTED FEATURES"
XNone known, but many suspected.
XPlease mail the author if you find any.
SHAR_EOF
echo 'File zsh2.2/man/man1/zsh.1 is complete' &&
chmod 0644 zsh2.2/man/man1/zsh.1 ||
echo 'restore of zsh2.2/man/man1/zsh.1 failed'
Wc_c="`wc -c < 'zsh2.2/man/man1/zsh.1'`"
test 112852 -eq "$Wc_c" ||
	echo 'zsh2.2/man/man1/zsh.1: original size 112852, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/aproto ==============
if test ! -d 'zsh2.2/scripts'; then
    echo 'x - creating directory zsh2.2/scripts'
    mkdir 'zsh2.2/scripts'
fi
if test -f 'zsh2.2/scripts/aproto' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/aproto (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/aproto (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/aproto' &&
X#! /bin/sh
Xfproto builtin.c >builtin.pro
Xfproto cond.c >cond.pro
Xfproto exec.c >exec.pro
Xfproto glob.c >glob.pro
Xfproto hist.c >hist.pro
Xfproto init.c >init.pro
Xfproto jobs.c >jobs.pro
Xfproto lex.c >lex.pro
Xfproto loop.c >loop.pro
Xfproto math.c >math.pro
Xfproto mem.c >mem.pro
Xfproto params.c >params.pro
Xfproto subst.c >subst.pro
Xfproto table.c >table.pro
Xfproto text.c >text.pro
Xfproto utils.c >utils.pro
Xfproto watch.c >watch.pro
Xfproto parse.c >parse.pro
Xfproto zle_hist.c >zle_hist.pro
Xfproto zle_main.c >zle_main.pro
Xfproto zle_misc.c >zle_misc.pro
Xfproto zle_move.c >zle_move.pro
Xfproto zle_refresh.c >zle_refresh.pro
Xfproto zle_tricky.c >zle_tricky.pro
Xfproto zle_utils.c >zle_utils.pro
Xfproto zle_vi.c >zle_vi.pro
Xfproto zle_word.c >zle_word.pro
SHAR_EOF
chmod 0755 zsh2.2/scripts/aproto ||
echo 'restore of zsh2.2/scripts/aproto failed'
Wc_c="`wc -c < 'zsh2.2/scripts/aproto'`"
test 755 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/aproto: original size 755, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/fproto ==============
if test -f 'zsh2.2/scripts/fproto' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/fproto (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/fproto (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/fproto' &&
X#! /bin/sh
X# prototype generator
Xsed -n '/\/\*\*\/$/{N;s/^\([^(]*\).*\/\*\*\/.\(.*\)/\1 DCLPROTO((\2))/p;}' $1 | sed -e 's/;/,/g' -e 's/,))$/));/' -e 's/(({))$/((void));/'
X
SHAR_EOF
chmod 0755 zsh2.2/scripts/fproto ||
echo 'restore of zsh2.2/scripts/fproto failed'
Wc_c="`wc -c < 'zsh2.2/scripts/fproto'`"
test 173 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/fproto: original size 173, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/ctoz ==============
if test -f 'zsh2.2/scripts/ctoz' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/ctoz (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/ctoz (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/ctoz' &&
X#! /bin/sh
X#
X# ctoz - alias conversion tool
X# This file is part of zsh, the Z shell.
X# (c) 1991 Paul Falstad
X#
X# This is a quick script to convert csh aliases to zsh aliases/functions.
X# Pipe the output of csh's alias command through this; it will generate
X# a series of alias/function definitions on stdout, suitable for
X# processing by zsh (probably also ksh or bash).
X#
X# This is not perfect, but it gets most common aliases; it should manage to
X# cut down a lot of the busy work.
X#
Xsed -e 's/	(\(.*\))/	\1/' >/tmp/cz$$.1
Xgrep ! /tmp/cz$$.1 >/tmp/cz$$.2
Xgrep -v ! /tmp/cz$$.1 >/tmp/cz$$.3
Xsed -e "s/'/'"\\\\"''"/g -e 's/^\([^	]*\)	\(.*\)$/alias \1='"'\2'/" \
X	/tmp/cz$$.3
Xsed -e 's/![:#]*/$/g' -e 's/^\([^	]*\)	\(.*\)$/\1 () { \2 }/' /tmp/cz$$.2
Xrm /tmp/cz$$.?
X#
X# in case your mailer eats tabs, here it is again, with the tabs
X# marked with a T:
X#
X#sed -e 's/T(\(.*\))/T\1/' >/tmp/cz$$.1
X#grep ! /tmp/cz$$.1 >/tmp/cz$$.2
X#grep -v ! /tmp/cz$$.1 >/tmp/cz$$.3
X#sed -e "s/'/'"\\\\"''"/g -e 's/^\([^T]*\)T\(.*\)$/alias \1='"'\2'/" \
X#	/tmp/cz$$.3
X#sed -e 's/![:#]*/$/g' -e 's/^\([^T]*\)T\(.*\)$/\1 () { \2 }/' /tmp/cz$$.2
X#rm /tmp/cz$$.?
SHAR_EOF
chmod 0644 zsh2.2/scripts/ctoz ||
echo 'restore of zsh2.2/scripts/ctoz failed'
Wc_c="`wc -c < 'zsh2.2/scripts/ctoz'`"
test 1137 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/ctoz: original size 1137, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/fooz ==============
if test -f 'zsh2.2/scripts/fooz' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/fooz (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/fooz (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/fooz' &&
Xalias -- 0='vi'
Xalias -- a='alias'
Xalias -- a.out='./a.out'
Xalias -- c='cp'
Xalias -- gnu='telnet gnu.ai.mit.edu'
Xalias -- grep='egrep'
Xalias -- gz='gdb zsh'
Xalias -- j='jobs -l'
Xalias -- k='kill'
Xalias -- l='ls -AF'
Xalias -- lock='lock -p -600'
Xalias -- lsd='ls -d */'
Xalias -- m='make'
Xalias -- main='./main'
Xalias -- man='woman'
Xalias -- mm='less'
Xalias -- more='less'
Xalias -- nw='l -ltr | tail'
Xalias -- pd='pushd'
Xalias -- pop='popd'
Xalias -- ps='sps'
Xalias -- pwrite='talk'
Xalias -- rn='h /usr/princeton/bin/rn.4.1'
Xalias -- rtfm='man'
Xalias -- strings='strings -'
Xalias -- t='cat'
Xalias -- talk='h talk'
Xalias -- v='mv'
Xalias -- where='hostname; echo >/dev/null'
Xalias -- whm='who | mm'
Xalias -- wm='w | mm'
X320 () { $* | fgrep -f /u/pfalstad/src/cs320/cs320list }
Xacx () { chmod 755 $* }
Xcx () { chmod +x $* }
Xf () { $* | fgrep -f /u/pfalstad/.friends }
Xk9 () { kill -9 $* }
Xmere () { nroff <$1 -man -Tman | less -s }
Xnrable () { ls -AFltr $* | grep -v r..r..  }
Xrable () { ls -AFltr $* | grep r..r..  }
Xexport ATTRIBUTION='%f wrote:'
Xexport CAD_HOME='/u/cad/magic'
Xexport COSMOS='/u/cad/cosmos'
Xexport HOME='/u/pfalstad'
Xexport LESS='-ainx3'
Xexport LM_LICENSE_FILE='/u/cs475/Mentor/etc/license_file'
Xexport LOGNAME='pfalstad'
Xexport MAIL='/usr/spool/mail/pfalstad'
Xexport MAILCALL='NEW MAIL! '
Xexport MANPATH='/usr/man:/usr/princeton/man:/u/cad/man'
Xexport NAME='Paul Falstad'
Xexport OCTTOOLS='/u/cad/octtools'
Xexport ORGANIZATION='The E. Henry Thripshaw Fan Club'
Xexport PATH='/u/pfalstad/scr:/u/pfalstad/bin/sun4:/usr/princeton/bin:/usr/ucb:/usr/bin:/bin:/u/maruchck/scr:/u/cs320/bin:/u/subbarao/bin:/u/maruchck/bin:/usr/hosts:/usr/princeton/bin/X11:/usr/etc:/etc'
Xexport PRINTER='dod'
Xexport PWD='/n/homeserver/c/pfalstad/zsh2.1/scripts'
Xexport RNINIT='/u/pfalstad/.rninit'
Xexport SCS='/u/cs475/Mentor'
Xexport SCS_LICENSE_CLASS='2'
Xexport SHELL='/u/pfalstad/bin/sun4/zsh'
Xexport TERM='vt100'
Xexport TERMCAP='d0|vt100|vt100-am|vt100am|dec-vt100:do=^J:co#80:li#24:cl=50\E[;H\E[2J:sf=5\ED:le=^H:bs:am:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E>\E[?1l\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:rf=/usr/share/lib/tabset/vt100:rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:ke=\E[?1l\E>:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:pt:sr=5\EM:vt#3:xn:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:'
Xexport USER='pfalstad'
Xexport YOUSAID='In %C you wrote:'
Xexport _='/u/pfalstad/zsh2.1/scripts/c2z'
XDISPLAY='phoenix:0.0'
XHOSTTYPE='sun4'
Xcdpath=(/u/pfalstad /u/pfalstad/src/cs320 /u/pfalstad/src)
Xedit=
XHISTSIZE='200'
XHOME='/u/pfalstad'
Xmail=(30 /usr/spool/mail/pfalstad)
Xpath=(/u/pfalstad/scr /u/pfalstad/bin/sun4 /usr/princeton/bin /usr/ucb /usr/bin /bin /u/maruchck/scr /u/cs320/bin /u/subbarao/bin /u/maruchck/bin /usr/hosts /usr/princeton/bin/X11 /usr/etc /etc)
Xprompt='c phoenix% '
Xshell='/bin/csh'
Xsetopt globdots
Xterm='vt100'
Xuser='pfalstad'
Xvi=
SHAR_EOF
chmod 0644 zsh2.2/scripts/fooz ||
echo 'restore of zsh2.2/scripts/fooz failed'
Wc_c="`wc -c < 'zsh2.2/scripts/fooz'`"
test 2958 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/fooz: original size 2958, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/c2z ==============
if test -f 'zsh2.2/scripts/c2z' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/c2z (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/c2z (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/c2z' &&
X#! /bin/sh
X#
X# c2z - environment conversion tool
X# Contributed by Bart Schaefer
X# (Tweaked a bit by Paul Falstad)
X#
X# This is a quick script to convert csh aliases to zsh aliases/functions.
X# It also converts the csh environment and local variables to zsh.  c2z
X# uses the csh to parse its own dot-files, then processes csh output to
X# convert the csh settings to zsh.
X#
X# When run as a zsh fuction, c2z runs csh as if it were an interactive
X# shell whenever the parent zsh is interactive.  When run as a shell
X# script, the -i switch can be used to force this behavior.
X#
X# The -l (login) switch causes csh to run as if it were a login shell.
X# This is done "properly" if c2z is used as a zsh function, otherwise
X# it's faked by explicitly sourcing .login.  Use with caution if your
X# .login initializes an X server or does other one-time-only startup
X# procedures.
X#
X# usage:
X#	c2z [-i] [-l]
X#
X# You can use this script in your .zshrc or .zlogin files to load your
X# regular csh environment into zsh; for example, in .zlogin:
X#
X#	. =(c2z -l)
X#
X# This is not perfect, but it gets most common aliases and variables.
X# It's also rather time-consuming to do this every time you log in.
X# However, if you're moving from csh to zsh for the first time, this
X# can get you started with a familiar environment right away.
X#
X# In case your mailer eats tabs, $T is set to expand to a tab.
X#
XT="`echo x | tr x '\011'`"
X
X# If we're zsh, we can run "- csh" to get the complete environment.
X#
XMINUS=""
XLOGIN=""
XINTERACT=""
Xcase "$VERSION" in
Xzsh*)
X    case $1 in
X    -l*) MINUS="-" ;;
X    -i*) INTERACT="-i" ;;
X    esac
X    if [[ -o INTERACTIVE ]]; then INTERACT="-i"; fi
X    setopt nobanghist
X    ;;
X*)
X    case $1 in
X    -l*) LOGIN="source ~/.login" ;;
X    -i*) INTERACT="-i" ;;
X    esac
X    ;;
Xesac
X
X( eval $MINUS csh $INTERACT ) <<EOF 2>&1 >/dev/null
X$LOGIN
Xalias >! /tmp/cz$$.a
Xsetenv >! /tmp/cz$$.e
Xset >! /tmp/cz$$.v
XEOF
X
X# save stdin
Xexec 9<&0
X
X# First convert aliases
Xexec < /tmp/cz$$.a
X
X# Taken straight from ctoz except for $T and "alias --"
Xsed -e 's/'"$T"'(\(.*\))/'"$T"'\1/' >/tmp/cz$$.1
Xgrep ! /tmp/cz$$.1 >/tmp/cz$$.2
Xgrep -v ! /tmp/cz$$.1 >/tmp/cz$$.3
Xsed -e "s/'/'"\\\\"''"/g \
X    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/alias -- \1='"'\2'/" \
X    /tmp/cz$$.3
Xsed -e 's/![:#]*/$/g' \
X    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/\1 () { \2 }/' \
X    /tmp/cz$$.2
X
X# Next, convert environment variables
Xexec < /tmp/cz$$.e
X
X# Would be nice to deal with embedded newlines, e.g. in TERMCAP, but ...
Xsed -e '/^SHLVL/d' \
X    -e "s/'/'"\\\\"''"/g \
X    -e "s/^\([A-Za-z0-9_]*=\)/export \1'/" \
X    -e "s/$/'/"
X
X# Finally, convert local variables
Xexec < /tmp/cz$$.v
X
Xsed -e 's/'"$T"'/=/' \
X    -e "s/'/'"\\\\"''"/g \
X    -e '/^[A-Za-z0-9_]*=[^(]/{
X	s/=/='"'/"'
X	s/$/'"'/"'
X	}' |
Xsed -e '/^argv=/d' -e '/^cwd=/d' -e '/^filec=/d' -e '/^status=/d' \
X	 -e '/^histchars=/s//HISTCHARS=/' \
X	 -e '/^history=/s//HISTSIZE=/' \
X	 -e '/^home=/s//HOME=/' \
X	 -e '/^ignoreeof=/s/.*/setopt ignoreeof/' \
X	 -e '/^noclobber=/s/.*/setopt noclobber/' \
X	 -e '/^notify=/d' \
X	 -e '/^showdots=/s/.*/setopt globdots/' \
X    -e '/^savehist=/s//HISTFILE=\~\/.zhistory SAVEHIST=/' \
X	 -e '/^autolist=/s/.*/setopt autolist/' \
X	 -e '/^correct=[cmd]*/s//setopt autocorrect/' \
X	 -e '/^who=/s//WATCHFMT=/'
X
X
Xexec 0<&9
X
Xrm /tmp/cz$$.?
Xexit
SHAR_EOF
chmod 0755 zsh2.2/scripts/c2z ||
echo 'restore of zsh2.2/scripts/c2z failed'
Wc_c="`wc -c < 'zsh2.2/scripts/c2z'`"
test 3299 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/c2z: original size 3299, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/scripts/c2z.orig ==============
if test -f 'zsh2.2/scripts/c2z.orig' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/scripts/c2z.orig (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/scripts/c2z.orig (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/scripts/c2z.orig' &&
X#! /bin/sh
X#
X# c2z - environment conversion tool
X# Contributed by Bart Schaefer
X#
X# This is a quick script to convert csh aliases to zsh aliases/functions.
X# It also converts the csh environment and local variables to zsh.  c2z
X# uses the csh to parse its own dot-files, then processes csh output to
X# convert the csh settings to zsh.
X#
X# When run as a zsh fuction, c2z runs csh as if it were an interactive
X# shell whenever the parent zsh is interactive.  When run as a shell
X# script, the -i switch can be used to force this behavior.
X#
X# The -l (login) switch causes csh to run as if it were a login shell.
X# This is done "properly" if c2z is used as a zsh function, otherwise
X# it's faked by explicitly sourcing .login.  Use with caution if your
X# .login initializes an X server or does other one-time-only startup
X# procedures.
X#
X# usage:
X#	c2z [-i] [-l]
X#
X# You can use this script in your .zshrc or .zlogin files to load your
X# regular csh environment into zsh; for example, in .zlogin:
X#
X#	. =(c2z -l)
X#
X# This is not perfect, but it gets most common aliases and variables.
X# It's also rather time-consuming to do this every time you log in.
X# However, if you're moving from csh to zsh for the first time, this
X# can get you started with a familiar environment right away.
X#
X# In case your mailer eats tabs, $T is set to expand to a tab.
X#
XT="`echo x | tr x '\011'`"
X
X# If we're zsh, we can run "- csh" to get the complete environment.
X#
XMINUS=""
XLOGIN=""
XINTERACT=""
Xcase "$VERSION" in
Xzsh*)
X    case $1 in
X    -l*) MINUS="-" ;;
X    -i*) INTERACT="-i" ;;
X    esac
X    if [[ -o INTERACTIVE ]]; then INTERACT="-i"; fi
X    setopt nobanghist
X    ;;
X*)
X    case $1 in
X    -l*) LOGIN="source ~/.login" ;;
X    -i*) INTERACT="-i" ;;
X    esac
X    ;;
Xesac
X
X( eval $MINUS csh $INTERACT ) <<EOF 2>&1 >/dev/null
X$LOGIN
Xalias >! /tmp/cz$$.a
Xsetenv >! /tmp/cz$$.e
Xset >! /tmp/cz$$.v
XEOF
X
X# First convert aliases
Xexec < /tmp/cz$$.a
X
X# Taken straight from ctoz except for $T and "alias --"
Xsed -e 's/'"$T"'(\(.*\))/'"$T"'\1/' >/tmp/cz$$.1
Xgrep ! /tmp/cz$$.1 >/tmp/cz$$.2
Xgrep -v ! /tmp/cz$$.1 >/tmp/cz$$.3
Xsed -e "s/'/'"\\\\"''"/g \
X    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/alias -- \1='"'\2'/" \
X    /tmp/cz$$.3
Xsed -e 's/![:#]*/$/g' \
X    -e 's/^\([^'"$T"']*\)'"$T"'\(.*\)$/\1 () { \2 }/' \
X    /tmp/cz$$.2
X
X# Next, convert environment variables
Xexec < /tmp/cz$$.e
X
X# Would be nice to deal with embedded newlines, e.g. in TERMCAP, but ...
Xsed -e '/^SHLVL/d' \
X    -e "s/'/'"\\\\"''"/g \
X    -e "s/^\([A-Za-z0-9_]*=\)/export \1'/" \
X    -e "s/$/'/"
X
X# Finally, convert local variables
Xsed -e '
Xexec < /tmp/cz$$.v
X
Xsed -e 's/'"$T"'/=/' \
X    -e "s/'/'"\\\\"''"/g \
X    -e '/^[A-Za-z0-9_]*=[^(]/{
X	s/=/='"'/"'
X	s/$/'"'/"'
X	}'
X
Xrm /tmp/cz$$.?
Xexit
SHAR_EOF
chmod 0755 zsh2.2/scripts/c2z.orig ||
echo 'restore of zsh2.2/scripts/c2z.orig failed'
Wc_c="`wc -c < 'zsh2.2/scripts/c2z.orig'`"
test 2736 -eq "$Wc_c" ||
	echo 'zsh2.2/scripts/c2z.orig: original size 2736, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/buildzsh ==============
if test ! -d 'zsh2.2/src'; then
    echo 'x - creating directory zsh2.2/src'
    mkdir 'zsh2.2/src'
fi
if test -f 'zsh2.2/src/buildzsh' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/buildzsh (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/buildzsh (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/buildzsh' &&
X#! /bin/sh
Xecho
Xecho 'Building config.h...
X'
Xexec >config.h
Xcat <<'foo'
X/* this file is created automatically by buildzsh */
X
X/* define this if you are sysvish */
Xfoo
Xif test -f /usr/include/sys/resource.h
Xthen echo '/* #define SYSV */'; echo 'looks like a BSDish system...' >&2
Xelse echo '#define SYSV'; echo 'looks like a SYSVish system...' >&2
Xfi
Xecho
Xif grep ULTRIX /usr/include/stdio.h >/dev/null 2>&1
Xthen echo '/* ULTRIX termios is weird... */
X/* #define TERMIOS */'; echo 'using sgttyb...' >&2
Xelse
Xif test -f /usr/include/termios.h && test ! -f /hp-ux
Xthen echo '#define TERMIOS
X/* #define TTY_NEEDS_DRAINING */
X/* #define CLOBBERS_TYPEAHEAD */'
Xecho 'using termios...' >&2
Xelse
Xif grep sgttyb /usr/include/sys/ioctl.h >/dev/null 2>&1
Xthen echo '/* #define TERMIO */'
Xelse echo '#define TERMIO'
Xecho 'using termio...' >&2
Xfi
Xecho '#define TTY_NEEDS_DRAINING
X#define CLOBBERS_TYPEAHEAD'
Xecho 'using sgttyb...' >&2
Xfi
Xfi
Xecho
Xif test -f /usr/include/stdlib.h
Xthen echo '#define HAS_STDLIB'; echo 'using <stdlib.h>...' >&2
Xelse echo '/*#define HAS_STDLIB*/'; echo 'not using <stdlib.h>...' >&2
Xfi
Xecho
Xif test -f /usr/include/string.h
Xthen echo '#define HAS_STRING'; echo 'using <string.h>...' >&2
Xelse echo '/*#define HAS_STRING*/'; echo 'using <strings.h>...' >&2
Xecho '#define strchr	index
X#define strrchr	rindex
X#define memcpy(dst, src, n)	bcopy(src, dst, n)
X#define memset(dst, ch, n)	bfill(dst, n, ch)
X#define memcmp(s1, s2, n)	bcopy(s1, s2, n)'
Xfi
Xecho
Xif test -f /usr/include/locale.h
Xthen echo '#define HAS_LOCALE'; echo 'using <locale.h>...' >&2
Xelse echo '/*#define HAS_LOCALE*/'; echo 'not using <locale.h>...' >&2
Xfi
Xecho
Xecho '/* define this if you have a host field in utmp */'
Xif grep ut_host /usr/include/utmp.h >/dev/null
Xthen echo '#define UTMP_HOST'; echo 'host field in utmp...' >&2
Xelse echo '/* #define UTMP_HOST */'; echo 'no host field in utmp...' >&2
Xfi
Xecho
Xecho '/* define this if you have WAITPID */'
Xif man 2 wait 2>/dev/null | sed 's/_.//g' | grep waitpid >/dev/null
Xthen echo '#define WAITPID'; echo 'using waitpid()...' >&2
Xelse echo '/* #define WAITPID */'; echo 'not using waitpid()...' >&2
Xfi
Xecho
Xecho '/* define this if you have SELECT */'
Xif grep FD_SET /usr/include/sys/types.h >/dev/null ||
X	test -f /usr/include/sys/select.h
Xthen echo '#define HAS_SELECT'; echo 'using select()...' >&2
Xelse echo '/* #define HAS_SELECT */'; echo 'not using select()...' >&2
Xfi
Xecho
Xecho '/* define this if you have <sys/select.h> */'
Xif test -f /usr/include/sys/select.h
Xthen echo '#define HAS_SYS_SELECT'
Xelse echo '/* #define HAS_SYS_SELECT */'
Xfi
Xecho "
X/* we can't just test for S_IFIFO or check to see if the mknod worked,
X   because the NeXTs sold by a vendor which will remain nameless will
X   happily create the FIFO for you, and then panic when you try to do
X	something weird with them, because they aren't supported by the OS. */
X"
Xif test -f /mach
Xthen echo '#define NO_FIFOS'; echo 'no FIFOs...' >&2
Xelse echo '/* #define NO_FIFOS */'; echo 'using FIFOs...' >&2
Xfi
Xecho
Xecho '/* define this if you have strftime() */'
Xif man 3 strftime 2>/dev/null | grep return >/dev/null
Xthen echo '#define HAS_STRFTIME'; echo 'using strftime()...' >&2
Xelse echo '/* #define HAS_STRFTIME */'; echo 'not using strftime()...' >&2
Xfi
Xecho
Xif man tcsetpgrp 2>/dev/null | grep process >/dev/null
Xthen echo '#define HAS_TCSETPGRP'; echo 'using tcsetpgrp()...' >&2
Xelse echo '/* #define HAS_TCSETPGRP */'; echo 'not using tcsetpgrp()...' >&2
Xfi
Xecho
Xif grep tcgetattr /usr/include/termios.h >/dev/null 2>/dev/null ||
X	grep tcgetattr /usr/include/sys/termios.h >/dev/null 2>/dev/null ||
X	grep tcgetattr /usr/include/sys/termio.h >/dev/null 2>/dev/null
Xthen echo '#define HAS_TCCRAP'; echo 'using tcgetattr() and friends...' >&2
Xelse echo '/* #define HAS_TCCRAP */'; echo 'not using tcgetattr()...' >&2
Xfi
Xecho
Xif test -f /bin/hinv
Xthen echo '/* SGI setpgid() is weird...  setpgrp() is better anyway */
X/* #define HAS_SETPGID */'; echo 'using setpgrp()...' >&2
Xelif man setpgid 2>/dev/null | grep process >/dev/null
Xthen echo '#define HAS_SETPGID'; echo 'using setpgid()...' >&2
Xelse echo '/* #define HAS_SETPGID */'; echo 'using setpgrp()...' >&2
Xfi
Xecho
Xif test ! -f /hp-ux && man sigrelse 2>/dev/null | grep signal >/dev/null
Xthen echo '#define HAS_SIGRELSE'; echo 'using sigrelse()...' >&2
Xelse echo '/* #define HAS_SIGRELSE */'; echo 'using sigblock()...' >&2
Xfi
Xecho
Xecho '/* define this if you have RFS */'
Xif test -d /../.CONTROL
Xthen echo '#define HAS_RFS'; echo 'you seem to have RFS...' >&2
Xelse echo '/* #define HAS_RFS */'; echo 'no RFS, it seems...' >&2
Xfi
Xecho
Xecho '/* define this if you have a working getrusage and wait3 */'
Xif test -f /hp-ux
Xthen echo '/* #define HAS_RUSAGE */'; echo 'no getrusage...' >&2
Xelif test -f /usr/include/sys/resource.h
Xthen echo '#define HAS_RUSAGE'; echo 'has getrusage...' >&2
Xelse echo '/* #define HAS_RUSAGE */'; echo 'no getrusage...' >&2
Xfi
Xecho '
X/* define this if your signal handlers return void */'
Xif grep SIG_DFL /usr/include/signal.h /usr/include/sys/signal.h |
X	grep void >/dev/null
Xthen echo '#define SIGVOID'; echo 'signal handlers return void...' >&2
Xelse echo '/* #define SIGVOID */'; echo 'signal handlers return int...' >&2
Xfi
Xcat <<'foo'
X#ifdef sgi
X#undef SIGVOID
X#endif
Xfoo
Xecho
Xecho '/* define this if signal handlers need to be reset each time */'
Xif grep SIGTSTP /usr/include/signal.h /usr/include/sys/signal.h >/dev/null
Xthen echo '/* #define RESETHANDNEEDED */'
Xecho 'signal handlers need no resetting...' >&2
Xelse echo '#define RESETHANDNEEDED'
Xecho 'signal handlers need to be reset...' >&2
Xfi
Xecho
Xcat <<'foo'
X#ifdef SIGVOID
X#define HANDTYPE void
X#else
X#define HANDTYPE int
X#define INTHANDTYPE
X#endif
X
X/* a string corresponding to the host type */
Xfoo
Xecho '#define HOSTTYPE "' | tr -d '\012'
Xhost=`(tcsh -fc 'echo $HOSTTYPE' || arch) 2>/dev/null`
Xcase $host in
X'') if grep ULTRIX /usr/include/stdio.h >/dev/null 2>&1
X    then host=ultrix
X	 elif test -f /bin/hinv
X	 then host=iris
X	 elif test -d /NextApps
X	 then host=next
X	 elif test $machine
X	 then host=$machine
X	 else
X	 echo 1>&2 '
X
XI cannot figure out what sort of host this is.  Please enter one
Xshort alphanumeric string describing this host.  (This will be used
Xto set the $HOSTTYPE variable, so '"you don't have to be very
Xaccurate if you're not in a multivendor environment.)
X"
X	 echo "? " | tr -d '\012' 1>&2
X	 read host
X	 echo ' ' 1>&2
X	 fi
X  ;;
Xesac
Xecho $host'"'
Xecho "using host type $host..." >&2
Xecho
Xecho '/* the default editor for the fc builtin */'
Xecho '#define DEFFCEDIT "vi"'
Xecho
Xif grep UTMP_FILE /usr/include/utmp.h >/dev/null
Xthen :
Xelse 
Xecho '/* the path of wtmp */'
Xecho '#define WTMP_FILE "' | tr -d '\012'
Xif test -f /etc/wtmp
Xthen echo /etc/wtmp
Xelif test -f /usr/etc/wtmp
Xthen echo /usr/etc/wtmp
Xelif test -f /var/adm/wtmp
Xthen echo /var/adm/wtmp
Xelif test -f /usr/adm/wtmp
Xthen echo /usr/adm/wtmp
Xelse echo /dev/null
Xfi | tr -d '\012'
Xecho '"
X
X/* the path of utmp */
X#define UTMP_FILE "/etc/utmp"
X'
Xfi
Xcat <<'foo'
X/* default prefix for temporary files */
X#define DEFTMPPREFIX "/tmp/zsh"
X
X/* define if you prefer "suspended" to "stopped" */
X#define USE_SUSPENDED
X
X/* the file to source whenever zsh is run; if undefined, don't source
X	anything */
X#define GLOBALZSHRC "/etc/zshrc"
X
X/* the file to source whenever zsh is run as a login shell; if
X	undefined, don't source anything */
X#define GLOBALZLOGIN "/etc/zlogin"
X
X/* the file to source whenever zsh is run as a login shell, before
X	zshrc is read; if undefined, don't source anything */
X#define GLOBALZPROFILE "/etc/zprofile"
X
X/* the default HISTSIZE */
X#define DEFAULT_HISTSIZE 30
X
X#define _BSD_SIGNALS   /* this could be an iris, you never know */
X#define _BSD           /* this could be HP-UX, you never know */
X#define _BSD_INCLUDES  /* this could be AIX, you never know */
X
X/* if your compiler doesn't like void *, change this to char *
X	and ignore all the warnings.
X*/
X
Xtypedef void *vptr;
X
X#define JOB_CONTROL
Xfoo
Xexec 1>&2
Xecho
Xecho 'Building signals.h...' | tr -d '\012'
Xecho `csh -fc 'kill -l'` | tr ' ' '\012' >signals.h
Xlct=`wc -l < signals.h`
Xcp signals.h signams.h
X(
Xecho '/* this file is created automatically by buildzsh */
X/* if all this is wrong, blame csh ;-) */
X
X#define SIGCOUNT '"$lct"'
X
X#ifdef GLOBALS
X
Xchar *sigmsg[SIGCOUNT+2] = {
X	"done",'
Xsed -e 's/^/SIG/' -e '/SIGHUP/s//hangup/
X/SIGINT/s//interrupt/
X/SIGQUIT/s//quit/
X/SIGILL/s//illegal instruction/
X/SIGTRAP/s//trace trap/
X/SIGIOT/s//IOT instruction/
X/SIGABRT/s//abort/
X/SIGEMT/s//EMT instruction/
X/SIGFPE/s//floating point exception/
X/SIGKILL/s//killed/
X/SIGBUS/s//bus error/
X/SIGSEGV/s//segmentation fault/
X/SIGSYS/s//bad system call/
X/SIGPIPE/s//broken pipe/
X/SIGTERM/s//terminated/
X/SIGPWR/s//power fail/
X/SIGVTALRM/s//virtual time alarm/
X/SIGCONT/s//continued/
X/SIGXCPU/s//cpu limit exceeded/
X/SIGXFSZ/s//filesize limit exceeded/' -e 's/.*/	"&",/' signals.h
Xecho '	NULL
X};
X
Xchar *sigs[SIGCOUNT+4] = {
X	"EXIT",' ) >sigtmp.h
Xmv sigtmp.h signals.h
Xif grep SIGSTOP signals.h >/dev/null
Xthen ed signals.h <<'foo' >/dev/null 2>&1
X/SIGSTOP/c
X#ifdef USE_SUSPENDED
X	"suspended (signal)",
X#else
X	"stopped (signal)",
X#endif
X.
X/SIGTSTP/c
X#ifdef USE_SUSPENDED
X	"suspended",
X#else
X	"stopped",
X#endif
X.
X/SIGTTIN/c
X#ifdef USE_SUSPENDED
X	"suspended (tty input)",
X#else
X	"stopped (tty input)",
X#endif
X.
X/SIGTTOU/c
X#ifdef USE_SUSPENDED
X	"suspended (tty output)",
X#else
X	"stopped (tty output)",
X#endif
X.
Xw
Xq
Xfoo
Xfi
X(sed 's/.*/	"&",/' signams.h
Xecho '	"ERR",
X	"DEBUG",
X	NULL
X};
X
X#else
X
Xextern char *sigs[SIGCOUNT+4],*sigmsg[SIGCOUNT+2];
X
X#endif') >>signals.h
Xrm signams.h
Xecho done
Xecho 'Building Makefile...' | tr -d '\012'
Xexec >Makefile
Xcat <<'foo'
X#! /bin/make -f
X# Makefile for zsh
X# generated by buildzsh
X
XOBJS=builtin.o cond.o exec.o glob.o hist.o init.o jobs.o lex.o loop.o \
Xmath.o mem.o params.o parse.o subst.o table.o text.o utils.o watch.o \
Xzle_bindings.o zle_hist.o zle_main.o zle_misc.o zle_move.o zle_refresh.o \
Xzle_tricky.o zle_utils.o zle_vi.o zle_word.o
X
XBINDIR=/usr/local/bin
XMANDIR=/usr/local/man/man1
X
X# debugging flags
X#CFLAGS=-g -Wreturn-type -Wunused -Wpointer-arith -DQDEBUG
X#CC=gcc -traditional
X
XCC=cc
Xfoo
Xif test -f /usr/include/ndir.h -a ! -f /usr/lib/libBSD.a
Xthen echo 'CFLAGS= -O -Aa'
Xelif strings /usr/bin/cc 2>/dev/null | grep cckr >/dev/null 2>&1
Xthen echo 'CFLAGS= -O -cckr'
Xelse echo 'CFLAGS= -O'
Xfi
Xif test -f /bin/hinv
Xthen
Xif grep '^\+' /etc/passwd >/dev/null
Xthen echo 'LIBS= -lcurses -lmalloc -lbsd -lsun'
Xelse echo 'LIBS= -lcurses -lmalloc -lbsd'
Xfi
Xelif test -f /usr/lib/libcposix.a
Xthen echo 'LIBS= -lcposix -ltermcap'
Xelif test -f /usr/lib/libBSD.a
Xthen echo 'LIBS= -ltermcap -lBSD'
Xelif test -f /usr/lib/libtermcap.a || test -f /usr/ucblib/libtermcap.a
Xthen
X	if grep 'Property of IBM' /usr/include/stdio.h >/dev/null 2>&1
X	then echo 'LIBS= -lcurses'
X	else echo 'LIBS= -ltermcap'
X	fi
Xelse echo 'LIBS= -lcurses'
Xfi
Xcat <<'foo'
X
XZSHPATH=zsh
X
X.c.o:
X	$(CC) $(CFLAGS) -c $<
X
Xall: $(ZSHPATH)
X
X$(ZSHPATH): $(OBJS)
X	$(CC) -o $(ZSHPATH) $(OBJS) $(LIBS) $(LFLAGS)
X	
Xtags: /tmp
X	ctags *.[cy]
X
X# I hate this next line
X$(OBJS): config.h zsh.h zle.h signals.h ztype.h funcs.h
X
Xclean:
X	rm -f *.o zsh core 
X
Xcleanall:
X	rm -f *.o zsh core Makefile signals.h config.h
X
Xinstall: zsh
X	install -s -m 755 zsh $(BINDIR)
X	install -m 444 ../man/man1/zsh.1 $(MANDIR)
Xfoo
Xexec 1>&2
Xcat <<'foo'
Xdone
X
XYou may want to look at the files I just created (config.h, Makefile,
Xand signals.h) to make sure they are correct.  Or you may just want
Xto go ahead and try running make now to see what happens.
X
Xfoo
Xecho 'Shall I execute make now?' | tr -d '\012' 
Xread reply
Xecho
Xcase "$reply" in
X[yY]*) exec make ;;
Xesac
X
SHAR_EOF
chmod 0755 zsh2.2/src/buildzsh ||
echo 'restore of zsh2.2/src/buildzsh failed'
Wc_c="`wc -c < 'zsh2.2/src/buildzsh'`"
test 11626 -eq "$Wc_c" ||
	echo 'zsh2.2/src/buildzsh: original size 11626, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/builtin.c ==============
if test -f 'zsh2.2/src/builtin.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/builtin.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/builtin.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/builtin.c' &&
X/*
SHAR_EOF
true || echo 'restore of zsh2.2/src/builtin.c failed'
fi
echo 'End of zsh2.2 part 5'
echo 'File zsh2.2/src/builtin.c is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
