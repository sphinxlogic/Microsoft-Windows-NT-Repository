Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i106:  zsh2.2 - The Z shell, Part10/17
Message-ID: <1992May13.160505.9956@sparky.imd.sterling.com>
X-Md4-Signature: f7a695d26e7d4697f97e21aee6cf1c8e
Date: Wed, 13 May 1992 16:05:05 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 106
Archive-name: zsh2.2/part10
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.10 (part 10 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/src/lex.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 10; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/src/lex.c'
else
echo 'x - continuing file zsh2.2/src/lex.c'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/src/lex.c' &&
X#define LX1_INPAR 7
X#define LX1_OUTPAR 8
X#define LX1_INBRACE 9
X#define LX1_OUTBRACE 10
X#define LX1_INBRACK 11
X#define LX1_OUTBRACK 12
X#define LX1_INANG 13
X#define LX1_OUTANG 14
X#define LX1_OTHER 15
X
X#define LX2_BREAK 0
X#define LX2_OUTPAR 1
X#define LX2_BAR 2
X#define LX2_STRING 3
X#define LX2_INBRACK 4
X#define LX2_OUTBRACK 5
X#define LX2_TILDE 6
X#define LX2_INPAR 7
X#define LX2_INBRACE 8
X#define LX2_OUTBRACE 9
X#define LX2_OUTANG 10
X#define LX2_INANG 11
X#define LX2_EQUALS 12
X#define LX2_BKSLASH 13
X#define LX2_QUOTE 14
X#define LX2_DQUOTE 15
X#define LX2_BQUOTE 16
X#define LX2_OTHER 17
X
Xunsigned char lexact1[256],lexact2[256],lextok2[256];
X
Xvoid initlextabs() /**/
X{
Xint t0;
Xstatic char *lx1 = "\\q\n;!&|(){}[]<>xx";
Xstatic char *lx2 = "x)|$[]~({}><=\\\'\"`x";
X
X	for (t0 = 0; t0 != 256; t0++) {
X		lexact1[t0] = LX1_OTHER;
X		lexact2[t0] = LX2_OTHER;
X		lextok2[t0] = t0;
X	}
X	for (t0 = 0; lx1[t0]; t0++)
X		if (lx1[t0] != 'x')
X			lexact1[lx1[t0]] = t0;
X	for (t0 = 0; lx2[t0]; t0++)
X		if (lx2[t0] != 'x')
X			lexact2[lx2[t0]] = t0;
X	lexact2[';'] = LX2_BREAK;
X	lexact2['&'] = LX2_BREAK;
X	lextok2[','] = Comma;
X	lextok2['*'] = Star;
X	lextok2['?'] = Quest;
X	lextok2['{'] = Inbrace;
X	lextok2['['] = Inbrack;
X	lextok2['$'] = String;
X}
X
X/* initialize lexical state */
X
Xvoid lexinit() /**/
X{
X	incond = incasepat = nocorrect =
X		dbparens = alstat = lexstop = 0;
X	incmdpos = 1;
X	tok = ENDINPUT;
X	if (isset(EXTENDEDGLOB))
X		{
X		lextok2['#'] = Pound;
X		lextok2['^'] = Hat;
X		}
X	else
X		{
X		lextok2['#'] = '#'; 
X		lextok2['^'] = '^';
X		}
X}
X
Xint len = 0,bsiz = 256;
Xchar *bptr;
X
X/* add a char to the string buffer */
X
Xvoid add(c) /**/
Xint c;
X{
X	*bptr++ = c;
X	if (bsiz == ++len)
X		{
X		int newbsiz;
X
X		newbsiz = bsiz * 8;
X		while (newbsiz < inbufct)
X			newbsiz *= 2;
X		bptr = len+(tokstr = hrealloc(tokstr,bsiz,newbsiz));
X		bsiz = newbsiz;
X		}
X}
X
Xstatic void unadd()
X{
X	bptr--; len--;
X}
X
Xint gettok() /**/
X{
Xint bct = 0,pct = 0,brct = 0;
Xint c,d,intpos = 1;
Xint peekfd = -1,peek,ninbracks;
X
Xbeginning:
X	hlastw = NULL;
X	tokstr = NULL;
X	parbegin = -1;
X	while (iblank(c = hgetc()) && !lexstop);
X	isfirstln = 0;
X	wordbeg = inbufct;
X	hwbegin();
X	hwaddc(c);
X	if (dbparens)	/* handle ((...)) */
X		{
X		pct = 2;
X		peek = STRING;
X		len = dbparens = 0;
X		bptr = tokstr = ncalloc(bsiz = 256);
X		for (;;)
X			{
X			if (c == '(')
X				pct++;
X			else if (c == ')')
X				pct--;
X			else if (c == '\n')
X				{
X				zerr("parse error: )) expected",NULL,0);
X				peek = LEXERR;
X				return peek;
X				}
X			else if (c == '$')
X				c = Qstring;
X			if (pct >= 2)
X				add(c);
X			if (pct)
X				c = hgetc();
X			else
X				break;
X			}
X		*bptr = '\0';
X		return peek;
X		}
X	if (idigit(c))	/* handle 1< foo */
X		{
X		d = hgetc();
X		hungetc(d);
X		lexstop = 0;
X		if (d == '>' || d == '<')
X			{
X			peekfd = c-'0';
X			c = hgetc();
X			}
X		}
X
X	/* chars in initial position in word */
X
X	if (c == hashchar &&
X			(isset(INTERACTIVECOMMENTS) ||
X			(!zleparse && (!interact || unset(SHINSTDIN) || strin))))
X		{
X		/* changed hgetch to hgetc so comments appear in history */
X		stophist = 1;
X		while ((c = hgetc()) != '\n' && !lexstop);
X		if (c == '\n') {
X			hwaddc('\n');
X			peek = NEWLIN;
X		} else {
X			peek = (errflag) ? LEXERR : ENDINPUT;
X			errflag = 1;
X		}
X		return peek;
X		}
X	if (lexstop)
X		return (errflag) ? LEXERR : ENDINPUT;
X	switch (lexact1[(unsigned char) c])
X		{
X		case LX1_BKSLASH:
X			d = hgetc();
X			if (d == '\n')
X				goto beginning;
X			hungetc(d);
X			break;
X		case LX1_NEWLIN: return NEWLIN;
X		case LX1_SEMI:
X			d = hgetc();
X			if (d != ';')
X				{
X				hungetc(d);
X				return SEMI;
X				}
X			return DSEMI;
X		case LX1_BANG:
X			d = hgetc();
X			hungetc(d);
X			if (!inblank(d))
X				break;
X			if (incmdpos || incond)
X				return BANG;
X			break;
X		case LX1_AMPER:
X			d = hgetc();
X			if (d != '&')
X				{
X				hungetc(d);
X				return AMPER;
X				}
X			return DAMPER;
X		case LX1_BAR:
X			d = hgetc();
X			if (d == '|')
X				return DBAR;
X			else if (d == '&')
X				return BARAMP;
X			hungetc(d);
X			return BAR;
X		case LX1_INPAR:
X			d = hgetc();
X			if (d == '(' && incmdpos)
X				{
X				tokstr = strdup("let");
X				dbparens = 1;
X				return STRING;
X				}
X			else if (d == ')')
X				return INOUTPAR;
X			hungetc(d);
X			if (!(incond || incmdpos))
X				break;
X			return INPAR;
X		case LX1_OUTPAR: return OUTPAR;
X		case LX1_INBRACE: if (!incmdpos) break; return INBRACE;
X		case LX1_OUTBRACE: return OUTBRACE;
X		case LX1_INBRACK:
X			if (!incmdpos)
X				break;
X			d = hgetc();
X			if (d == '[')
X				return DINBRACK;
X			hungetc(d);
X			break;
X		case LX1_OUTBRACK:
X			if (!incond)
X				break;
X			d = hgetc();
X			if (d == ']')
X				return DOUTBRACK;
X			hungetc(d);
X			break;
X		case LX1_INANG:
X			d = hgetc();
X			if ((!incmdpos && d == '(') || incasepat) {
X				hungetc(d);
X				break;
X			} else if (d == '<') {
X				int e = hgetc();
X
X				if (e == '(') {
X					hungetc(e);
X					hungetc(d);
X					peek = INANG;
X				} else if (e == '<')
X					peek = TRINANG;
X				else if (e == '-')
X					peek = DINANGDASH;
X				else {
X					hungetc(e);
X					peek = DINANG;
X				}
X			} else if (d == '&')
X				peek = INANGAMP;
X			else {
X				peek = INANG;
X				hungetc(d);
X			}
X			tokfd = peekfd;
X			return peek;
X		case LX1_OUTANG:
X			d = hgetc();
X			if (d == '(')
X				{
X				hungetc(d);
X				break;
X				}
X			else if (d == '&')
X				{
X				d = hgetc();
X				if (d == '!')
X					peek = OUTANGAMPBANG;
X				else
X					{
X					hungetc(d);
X					peek = OUTANGAMP;
X					}
X				}
X			else if (d == '!')
X				peek = OUTANGBANG;
X			else if (d == '>')
X				{
X				d = hgetc();
X				if (d == '&')
X					{
X					d = hgetc();
X					if (d == '!')
X						peek = DOUTANGAMPBANG;
X					else
X						{
X						hungetc(d);
X						peek = DOUTANGAMP;
X						}
X					}
X				else if (d == '!')
X					peek = DOUTANGBANG;
X				else if (d == '(')
X					{
X					hungetc(d);
X					hungetc('>');
X					peek = OUTANG;
X					}
X				else
X					{
X					hungetc(d);
X					peek = DOUTANG;
X					if (isset(NOCLOBBER)) hwaddc('!');
X					}
X				}
X			else
X				{
X				hungetc(d);
X				peek = OUTANG;
X				if (isset(NOCLOBBER)) hwaddc('!');
X				}
X			tokfd = peekfd;
X			return peek;
X		}
X
X	/* we've started a string, now get the rest of it, performing
X		tokenization */
X
X	peek = STRING;
X	len = 0;
X	bptr = tokstr = ncalloc(bsiz = 256);
X	for(;;)
X		{
X		int act;
X		int d;
X		
X		if (inblank(c))
X			act = LX2_BREAK;
X		else
X			{
X			act = lexact2[(unsigned char) c];
X			c = lextok2[(unsigned char) c];
X			}
X		switch (act)
X			{
X			case LX2_BREAK: goto brk;
X			case LX2_OUTPAR:
X				if (!pct)
X					goto brk;
X				c = Outpar;
X				pct--;
X				break;
X			case LX2_BAR:
X				if (!pct && !incasepat)
X					goto brk;
X				c = Bar;
X				break;
X			case LX2_STRING:
X				d = hgetc();
X				if (d == '[')
X					{
X					add(String);
X					add(Inbrack);
X					ninbracks = 1;
X					while (ninbracks && (c = hgetc()) && !lexstop) {
X						if (c == '[') ninbracks++;
X						else if (c == ']') ninbracks--;
X						if (ninbracks) add(c);
X					}
X					c = Outbrack;
X					}
X				else if (d == '(')
X					{
X					add(String);
X					if (skipcomm()) { peek = LEXERR; goto brk; }
X					c = Outpar;
X					}
X				else
X					hungetc(d);
X				break;
X			case LX2_INBRACK: brct++; break;
X			case LX2_OUTBRACK:
X				if (incond && !brct)
X					goto brk;
X				brct--;
X				c = Outbrack;
X				break;
X			case LX2_TILDE: /* if (intpos) */ c = Tilde; break;
X			case LX2_INPAR:
X				d = hgetc();
X				hungetc(d);
X				if (d == ')' || (incmdpos && peek != ENVSTRING))
X					goto brk;
X				pct++;
X				c = Inpar;
X				break;
X			case LX2_INBRACE: bct++; break;
X			case LX2_OUTBRACE:
X				if (!bct)
X					goto brk;
X				bct--;
X				c = Outbrace;
X				break;
X			case LX2_OUTANG:
X				d = hgetc();
X				if (d != '(')
X					{
X					hungetc(d);
X					goto brk;
X					}
X				add(Outang);
X				if (skipcomm()) { peek = LEXERR; goto brk; }
X				c = Outpar;
X				break;
X			case LX2_INANG:
X				d = hgetc();
X				if (!(idigit(d) || d == '-' || d == '>' || d == '(' || d == ')'))
X					{
X					hungetc(d);
X					goto brk;
X					}
X				c = Inang;
X				if (d == '(')
X					{
X					add(c);
X					if (skipcomm()) { peek = LEXERR; goto brk; }
X					c = Outpar;
X					}
X				else if (d == ')')
X					hungetc(d);
X				else
X					{
X					add(c);
X					c = d;
X					while (c != '>' && !lexstop)
X						add(c),c = hgetc();
X					c = Outang;
X					}
X				break;
X			case LX2_EQUALS:
X				if (intpos)
X					{
X					d = hgetc();
X					if (d != '(')
X						{
X						hungetc(d);
X						c = Equals;
X						}
X					else
X						{
X						add(Equals);
X						if (skipcomm()) { peek = LEXERR; goto brk; }
X						c = Outpar;
X						}
X					}
X				else if (peek != ENVSTRING && incmdpos)
X					{
X					d = hgetc();
X					if (d == '(' && incmdpos)
X						{
X						*bptr = '\0';
X						return ENVARRAY;
X						}
X					hungetc(d);
X					peek = ENVSTRING;
X					intpos = 2;
X					}
X				break;
X			case LX2_BKSLASH:
X				c = hgetc();
X				if (c == '\n')
X					{
X					c = hgetc();
X					continue;
X					}
X				add(c);
X				c = hgetc();
X				continue;
X			case LX2_QUOTE:
X				add(Nularg);
X
X				/* we add the Nularg to prevent this:
X
X				echo $PA'TH'
X
X				from printing the path. */
X
X				for (;;) {
X					while ((c = hgetc()) != '\'' && !lexstop) {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						add(c);
X					}
X					if (c != '\'') {
X						zerr("unmatched \'",NULL,0);
X						peek = LEXERR;
X						goto brk;
X					}
X					d = hgetc();
X					if (d != '\'' || unset(RCQUOTES)) break;
X					add(c);
X				}
X				hungetc(d);
X				c = Nularg;
X				break;
X			case LX2_DQUOTE:
X				add(Nularg);
X				while ((c = hgetc()) != '\"' && !lexstop)
X					if (c == '\\')
X						{
X						c = hgetc();
X						if (c != '\n')
X							{
X							if (c != '$' && c != '\\' && c != '\"' && c != '`')
X								add('\\');
X							add(c);
X							}
X						}
X					else {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						if (c == '$') {
X							d = hgetc();
X							if (d == '(') {
X								add(Qstring);
X								if (skipcomm()) { peek = LEXERR; goto brk; }
X								c = Outpar;
X							} else if (d == '[') {
X								add(String);
X								add(Inbrack);
X								while ((c = hgetc()) != ']' && !lexstop)
X									add(c);
X								c = Outbrack;
X							} else {
X								c = Qstring;
X								hungetc(d);
X							}
X						} else if (c == '`')
X							c = Qtick;
X						add(c);
X					}
X				if (c != '\"') {
X					zerr("unmatched \"",NULL,0);
X					peek = LEXERR;
X					goto brk;
X				}
X				c = Nularg;
X				break;
X			case LX2_BQUOTE:
X				add(Tick);
X				parbegin = inbufct;
X				while ((c = hgetc()) != '`' && !lexstop)
X					if (c == '\\')
X						{
X						c = hgetc();
X						if (c != '\n')
X							{
X							if (c != '`' && c != '\\' && c != '$')
X								add('\\');
X							add(c);
X							}
X						}
X					else {
X						if (isset(CSHJUNKIEQUOTES) && c == '\n') {
X							if (bptr[-1] == '\\') unadd(); else break;
X						}
X						add(c);
X					}
X				if (c != '`') {
X					if (!zleparse) zerr("unmatched `",NULL,0);
X					peek = LEXERR;
X					goto brk;
X				}
X				c = Tick;
X				parbegin = -1;
X				break;
X			}
X		add(c);
X		c = hgetc();
X		if (intpos)
X			intpos--;
X		if (lexstop)
X			break;
X		}
Xbrk:
X	hungetc(c);
X	*bptr = '\0';
X	return peek;
X}
X
X/* expand aliases, perhaps */
X
Xint exalias() /**/
X{
Xstruct alias *an;
Xchar *s,*t;
X
X	s = yytext = hwadd();
X	for (t = s; *t && *t != HISTSPACE; t++);
X	if (!*t)
X		t = NULL;
X	else
X		*t = '\0';
X	if (interact && isset(SHINSTDIN) && !strin && !incasepat && tok == STRING &&
X		(isset(CORRECTALL) || (isset(CORRECT) && incmdpos)) && !nocorrect)
X			spckword(&tokstr,&s,&t,!incmdpos,1);
X	if (zleparse && !alstackind) {
X		int zp = zleparse;
X		gotword(s);
X		if (zp && !zleparse) {
X			if (t) *t = HISTSPACE;
X			return 0;
X		}
X	}
X	an = gethnode(s,aliastab);
X	if (t) *t = HISTSPACE;
X	if (alstackind != MAXAL && an && !an->inuse)
X		if (!(an->cmd && !incmdpos && alstat != ALSTAT_MORE)) {
X			if (an->cmd < 0) {
X				tok = DO-an->cmd-1;
X				return 0;
X			} else {
X				an->inuse = 1;
X				hungets(ALPOPS);
X				hungets((alstack[alstackind++] = an)->text);
X				alstat = 0;
X				/* remove from history if it begins with space */
X				if (isset(HISTIGNORESPACE) && an->text[0] == ' ') remhist();
X				lexstop = 0;
X				return 1;
X			}
X		}
X	return 0;
X}
X
X/* skip (...) */
X
Xint skipcomm() /**/
X{
Xint pct = 1,c;
X
X	parbegin = inbufct;
X	c = Inpar;
X	do
X		{
X		add(c);
X		c = hgetc();
X		if (itok(c) || lexstop)
X			break;
X		else if (c == '(') pct++;
X		else if (c == ')') pct--;
X		else if (c == '\\')
X			{
X			add(c);
X			c = hgetc();
X			}
X		else if (c == '\'')
X			{
X			add(c);
X			while ((c = hgetc()) != '\'' && !lexstop)
X				add(c);
X			}
X		else if (c == '\"')
X			{
X			add(c);
X			while ((c = hgetc()) != '\"' && !lexstop)
X				if (c == '\\')
X					{
X					add(c);
X					add(hgetc());
X					}
X				else add(c);
X			}
X		else if (c == '`')
X			{
X			add(c);
X			while ((c = hgetc()) != '`' && !lexstop)
X				if (c == '\\') add(c), add(hgetc());
X				else add(c);
X			}
X		}
X	while(pct);
X	if (!lexstop) parbegin = -1;
X	return lexstop;
X}
X
SHAR_EOF
echo 'File zsh2.2/src/lex.c is complete' &&
chmod 0644 zsh2.2/src/lex.c ||
echo 'restore of zsh2.2/src/lex.c failed'
Wc_c="`wc -c < 'zsh2.2/src/lex.c'`"
test 15554 -eq "$Wc_c" ||
	echo 'zsh2.2/src/lex.c: original size 15554, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/loop.c ==============
if test -f 'zsh2.2/src/loop.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/loop.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/loop.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/loop.c' &&
X/*
X *
X * loop.c - loop execution
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
Xint execfor(cmd) /**/
XCmd cmd;
X{
XList list;
Xstruct forcmd *node;
Xchar *str;
XLklist args;
Xint cj = thisjob;
X
X	loops++;
X	exiting = 0;
X	node = cmd->u.forcmd;
X	args = cmd->args;
X	if (!node->inflag)
X		{
X		char **x;
X
X		args = newlist();
X		for (x = pparams; *x; x++)
X			addnode(args,ztrdup(*x));
X		}
X	pushheap();
X	while (str = ugetnode(args))
X		{
X		setsparam(node->name,ztrdup(str));
X		list = dupstruct(node->list);
X		execlist(list);
X		if (breaks)
X			{
X			breaks--;
X			if (breaks || !contflag)
X				break;
X			contflag = 0;
X			}
X		if (errflag)
X			{
X			lastval = 1;
X			break;
X			}
X		freeheap();
X		}
X	popheap();
X	thisjob = cj;
X	loops--;
X	return lastval;
X}
X
Xint execselect(cmd) /**/
XCmd cmd;
X{
XList list;
Xstruct forcmd *node;
Xchar *str,*s;
XLklist args;
XLknode n;
Xint cj = thisjob,t0;
XFILE *inp;
X
X	node = cmd->u.forcmd;
X	args = cmd->args;
X	if (!node->inflag) {
X		char **x;
X
X		args = newlist();
X		for (x = pparams; *x; x++)
X			addnode(args,ztrdup(*x));
X	}
X	if (!full(args))
X		return 1;
X	loops++;
X	exiting = 0;
X	pushheap();
X	inp = fdopen(dup((SHTTY==-1)?0:SHTTY),"r");
X	for (;;)
X		{
X		do
X			{
X			int pl;
X			selectlist(args);
X			str = putprompt(prompt3,&pl);
X			if (full(bufstack)) str = (char *) getnode(bufstack);
X			else if (interact && SHTTY != -1 && isset(USEZLE)) {
X				str = (char *)zleread(str,NULL,pl);
X			} else {
X				fprintf(stderr,"%s",str);
X				fflush(stderr);
X				str = fgets(zalloc(256),256,inp);
X			}
X			if (!str || errflag)
X				{
X				fprintf(stderr,"\n");
X				fflush(stderr);
X				goto done;
X				}
X			if (s = strchr(str,'\n'))
X				*s = '\0';
X			}
X		while (!*str);
X		setsparam("REPLY",ztrdup(str));
X		t0 = atoi(str);
X		if (!t0)
X			str = "";
X		else
X			{
X			for (t0--,n = firstnode(args); n && t0; incnode(n),t0--);
X			if (n)
X				str = getdata(n);
X			else
X				str = "";
X			}
X		setsparam(node->name,ztrdup(str));
X		list = dupstruct(node->list);
X		execlist(list);
X		freeheap();
X		if (breaks)
X			{
X			breaks--;
X			if (breaks || !contflag)
X				break;
X			contflag = 0;
X			}
X		if (errflag)
X			break;
X		}
Xdone:
X	popheap();
X	fclose(inp);
X	thisjob = cj;
X	loops--;
X	return lastval;
X}
X 
Xint execwhile(cmd) /**/
XCmd cmd;
X{
XList list;
Xstruct whilecmd *node;
Xint cj = thisjob; 
X
X	node = cmd->u.whilecmd;
X	exiting = 0;
X	pushheap();
X	loops++;
X	for(;;)
X		{
X		list = dupstruct(node->cont);
X		execlist(list);
X		if (!((lastval == 0) ^ node->cond))
X			break;
X		list = dupstruct(node->loop);
X		execlist(list);
X		if (breaks)
X			{
X			breaks--;
X			if (breaks || !contflag)
X				break;
X			contflag = 0;
X			}
X		freeheap();
X		if (errflag)
X			{
X			lastval = 1;
X			break;
X			}
X		}
X	popheap();
X	thisjob = cj;
X	loops--;
X	return lastval;
X}
X 
Xint execrepeat(cmd) /**/
XCmd cmd;
X{
XList list;
Xint cj = thisjob,count;
X
X	exiting = 0;
X	if (!full(cmd->args) || nextnode(firstnode(cmd->args)))
X		{
X		zerr("bad argument for repeat",NULL,0);
X		return 1;
X		}
X	count = atoi(peekfirst(cmd->args));
X	pushheap();
X	loops++;
X	while (count--)
X		{
X		list = dupstruct(cmd->u.list);
X		execlist(list);
X		freeheap();
X		if (breaks)
X			{
X			breaks--;
X			if (breaks || !contflag)
X				break;
X			contflag = 0;
X			}
X		if (lastval)
X			break;
X		if (errflag)
X			{
X			lastval = 1;
X			break;
X			}
X		}
X	popheap();
X	thisjob = cj;
X	loops--;
X	return lastval;
X}
X 
Xint execif(cmd) /**/
XCmd cmd;
X{
Xstruct ifcmd *node;
Xint cj = thisjob;
X
X	node = cmd->u.ifcmd;
X	exiting = 0;
X	while (node)
X		{
X		if (node->ifl)
X			{
X			execlist(node->ifl);
X			if (lastval)
X				{
X				node = node->next;
X				continue;
X				}
X			}
X		execlist(node->thenl);
X		break;
X		}
X	thisjob = cj;
X	return lastval;
X}
X 
Xint execcase(cmd) /**/
XCmd cmd;
X{
Xstruct casecmd *node;
Xchar *word;
XLklist args;
Xint cj = thisjob;
X
X	node = cmd->u.casecmd;
X	args = cmd->args;
X	exiting = 0;
X	if (firstnode(args) && nextnode(firstnode(args)))
X		{
X		zerr("too many arguments to case",NULL,0);
X		errflag = 1;
X		return 1;
X		}
X	if (!full(args))
X		word = strdup("");
X	else
X		word = peekfirst(args);
X	while (node)
X		{
X		singsub(&(node->pat));
X		if (matchpat(word,node->pat))
X			break;
X		else
X			node = node->next;
X		}
X	if (node && node->list)
X		execlist(node->list);
X	thisjob = cj;
X	return lastval;
X}
SHAR_EOF
chmod 0644 zsh2.2/src/loop.c ||
echo 'restore of zsh2.2/src/loop.c failed'
Wc_c="`wc -c < 'zsh2.2/src/loop.c'`"
test 4752 -eq "$Wc_c" ||
	echo 'zsh2.2/src/loop.c: original size 4752, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/math.c ==============
if test -f 'zsh2.2/src/math.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/math.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/math.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/math.c' &&
X/*
X *
X * math.c - mathematical expression evaluation
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X
Xstatic char *ptr;
X
Xtypedef int LV;
X
Xstatic long yyval;
Xstatic LV yylval;
X
X/* nonzero means we are not evaluating, just parsing */
X
Xstatic int noeval = 0;
X
X/* != 0 means recognize unary plus, minus, etc. */
X
Xstatic int unary = 1;
X
Xvoid mathparse DCLPROTO((int));
X
X/* LR = left-to-right associativity
X	RL = right-to-left associativity
X	BOO = short-circuiting boolean */
X
X#define LR 0
X#define RL 1
X#define BOOL 2
X
X#define M_INPAR 0
X#define M_OUTPAR 1
X#define NOT 2
X#define COMP 3
X#define POSTPLUS 4
X#define POSTMINUS 5
X#define UPLUS 6
X#define UMINUS 7
X#define AND 8
X#define XOR 9
X#define OR 10
X#define MUL 11
X#define DIV 12
X#define MOD 13
X#define PLUS 14
X#define MINUS 15
X#define SHLEFT 16
X#define SHRIGHT 17
X#define LES 18
X#define LEQ 19
X#define GRE 20
X#define GEQ 21
X#define DEQ 22
X#define NEQ 23
X#define DAND 24
X#define DOR 25
X#define DXOR 26
X#define QUEST 27
X#define COLON 28
X#define EQ 29
X#define PLUSEQ 30
X#define MINUSEQ 31
X#define MULEQ 32
X#define DIVEQ 33
X#define MODEQ 34
X#define ANDEQ 35
X#define XOREQ 36
X#define OREQ 37
X#define SHLEFTEQ 38
X#define SHRIGHTEQ 39
X#define DANDEQ 40
X#define DOREQ 41
X#define DXOREQ 42
X#define COMMA 43
X#define EOI 44
X#define PREPLUS 45
X#define PREMINUS 46
X#define NUM 47
X#define ID 48
X#define TOKCOUNT 49
X
X/* precedences */
X
Xstatic int prec[TOKCOUNT] = {
X	1,137,2,2,2,
X	2,2,2,4,5,
X	6,7,7,7,8,
X	8,3,3,9,9,
X	9,9,10,10,11,
X	12,12,13,13,14,
X	14,14,14,14,14,
X	14,14,14,14,14,
X	14,14,14,15,200,
X	2,2,0,0,
X};
X
X#define TOPPREC 15
X#define ARGPREC (15-1)
X
Xstatic int type[TOKCOUNT] = {
X	LR,LR,RL,RL,RL,
X	RL,RL,RL,LR,LR,
X	LR,LR,LR,LR,LR,
X	LR,LR,LR,LR,LR,
X	LR,LR,LR,LR,BOOL,
X	BOOL,LR,RL,RL,RL,
X	RL,RL,RL,RL,RL,
X	RL,RL,RL,RL,RL,
X	BOOL,BOOL,RL,RL,RL,
X	RL,RL,LR,LR,
X};
X
X#define LVCOUNT 32
X
X/* list of lvalues (variables) */
X
Xstatic int lvc;
Xstatic char *lvals[LVCOUNT];
X
Xint zzlex() /**/
X{
X	for(;;)
X		switch (*ptr++)
X			{
X			case '+':
X				if (*ptr == '+' && (unary || !ialnum(*ptr)))
X					{
X					ptr++;
X					return (unary) ? PREPLUS : POSTPLUS;
X					}
X				if (*ptr == '=') { unary = 1; ptr++; return PLUSEQ; }
X				return (unary) ? UPLUS : PLUS;
X			case '-':
X				if (*ptr == '-' && (unary || !ialnum(*ptr)))
X					{
X					ptr++;
X					return (unary) ? PREMINUS : POSTMINUS;
X					}
X				if (*ptr == '=') { unary = 1; ptr++; return MINUSEQ; }
X				return (unary) ? UMINUS : MINUS;
X			case '(': unary = 1; return M_INPAR;
X			case ')': return M_OUTPAR;
X			case '!': if (*ptr == '=')
X						{ unary = 1; ptr++; return NEQ; }
X						return NOT;
X			case '~': return COMP;
X			case '&': unary = 1;
X				if (*ptr == '&') { if (*++ptr == '=')
X				{ ptr++; return DANDEQ; } return DAND; }
X				else if (*ptr == '=') { ptr++; return ANDEQ; } return AND;
X			case '|': unary = 1;
X				if (*ptr == '|') { if (*++ptr == '=')
X				{ ptr++; return DOREQ; } return DOR; }
X				else if (*ptr == '=') { ptr++; return OREQ; } return OR;
X			case '^': unary = 1;
X				if (*ptr == '^') { if (*++ptr == '=')
X				{ ptr++; return DXOREQ; } return DXOR; }
X				else if (*ptr == '=') { ptr++; return XOREQ; } return XOR;
X			case '*': unary = 1;
X				if (*ptr == '=') { ptr++; return MULEQ; } return MUL;
X			case '/': unary = 1;
X				if (*ptr == '=') { ptr++; return DIVEQ; } return DIV;
X			case '%': unary = 1;
X				if (*ptr == '=') { ptr++; return MODEQ; } return MOD;
X			case '<': unary = 1; if (*ptr == '<')
X				{ if (*++ptr == '=') { ptr++; return SHLEFTEQ; } return SHLEFT; }
X				else if (*ptr == '=') { ptr++; return LEQ; } return LES;
X			case '>': unary = 1; if (*ptr == '>')
X				{ if (*++ptr == '=') { ptr++; return SHRIGHTEQ; } return SHRIGHT; }
X				else if (*ptr == '=') { ptr++; return GEQ; } return GRE;
X			case '=': unary = 1; if (*ptr == '=') { ptr++; return DEQ; }
X				return EQ;
X			case '?': unary = 1; return QUEST;
X			case ':': unary = 1; return COLON;
X			case ',': unary = 1; return COMMA;
X			case '\0': unary = 1; ptr--; return EOI;
X			case '[': unary = 0;
X				{ int base = zstrtol(ptr,&ptr,10);
X					if (*ptr == ']') ptr++;
X					yyval = zstrtol(ptr,&ptr,lastbase = base);
X					return NUM; }
X			case ' ': case '\t':
X				break;
X			default:
X				if (idigit(*--ptr))
X					{ unary = 0; yyval = zstrtol(ptr,&ptr,10); return NUM; }
X				if (iident(*ptr) || *ptr == '$')
X					{
X					char *p,q;
X
X					if (*ptr == '$')
X						ptr++;
X					p = ptr;
X					if (lvc == LVCOUNT)
X						{
X						zerr("too many identifiers (complain to author)",NULL,0);
X						return EOI;
X						}
X					unary = 0;
X					while(iident(*++ptr));
X					q = *ptr;
X					*ptr = '\0';
X					lvals[yylval = lvc++] = ztrdup(p);
X					*ptr = q;
X					return ID;
X					}
X				return EOI;
X			}
X}
X
X/* the value stack */
X
X#define STACKSZ 100
Xint mtok;			/* last token */
Xint sp = -1;	/* stack pointer */
Xstruct mathvalue {
X	LV lval;
X	long val;
X	} stack[STACKSZ];
X
Xvoid push(val,lval)
Xlong val;LV lval;
X{
X	if (sp == STACKSZ-1)
X		zerr("stack overflow",NULL,0);
X	else
X		sp++;
X	stack[sp].val = val;
X	stack[sp].lval = lval;
X}
X
Xlong getvar(s)
XLV s;
X{
Xlong t;
X
X	if (!(t = getiparam(lvals[s])))
X		return 0;
X	return t;
X}
X
Xlong setvar(s,v)
XLV s;long v;
X{
X	if (s == -1 || s >= lvc)
X		{
X		zerr("lvalue required",NULL,0);
X		return 0;
X		}
X	if (noeval)
X		return v;
X	setiparam(lvals[s],v);
X	return v;
X}
X
Xint notzero(a) /**/
Xint a;
X{
X	if (a == 0)
X		{
X		zerr("division by zero",NULL,0);
X		return 0;
X		}
X	return 1;
X}
X
X#define pop2() { b = stack[sp--].val; a = stack[sp--].val; }
X#define pop3() {c=stack[sp--].val;b=stack[sp--].val;a=stack[sp--].val;}
X#define nolval() {stack[sp].lval= -1;}
X#define pushv(X) { push(X,-1); }
X#define pop2lv() { pop2() lv = stack[sp+1].lval; }
X#define set(X) { push(setvar(lv,X),lv); }
X
Xvoid op(what) /**/
Xint what;
X{
Xlong a,b,c;
XLV lv;
X
X	if (sp < 0)
X		{
X		zerr("bad math expression: stack empty",NULL,0);
X		return;
X		}
X	switch(what) {
X		case NOT: stack[sp].val = !stack[sp].val; nolval(); break;
X		case COMP: stack[sp].val = ~stack[sp].val; nolval(); break;
X		case POSTPLUS: ( void ) setvar(stack[sp].lval,stack[sp].val+1); break;
X		case POSTMINUS: ( void ) setvar(stack[sp].lval,stack[sp].val-1); break;
X		case UPLUS: nolval(); break;
X		case UMINUS: stack[sp].val = -stack[sp].val; nolval(); break;
X		case AND: pop2(); pushv(a&b); break;
X		case XOR: pop2(); pushv(a^b); break;
X		case OR: pop2(); pushv(a|b); break;
X		case MUL: pop2(); pushv(a*b); break;
X		case DIV: pop2(); if (notzero(b)) pushv(a/b); break;
X		case MOD: pop2(); if (notzero(b)) pushv(a%b); break;
X		case PLUS: pop2(); pushv(a+b); break;
X		case MINUS: pop2(); pushv(a-b); break;
X		case SHLEFT: pop2(); pushv(a<<b); break;
X		case SHRIGHT: pop2(); pushv(a>>b); break;
X		case LES: pop2(); pushv(a<b); break;
X		case LEQ: pop2(); pushv(a<=b); break;
X		case GRE: pop2(); pushv(a>b); break;
X		case GEQ: pop2(); pushv(a>=b); break;
X		case DEQ: pop2(); pushv(a==b); break;
X		case NEQ: pop2(); pushv(a!=b); break;
X		case DAND: pop2(); pushv(a&&b); break;
X		case DOR: pop2(); pushv(a||b); break;
X		case DXOR: pop2(); pushv(a&&!b||!a&&b); break;
X		case QUEST: pop3(); pushv((a)?b:c); break;
X		case COLON: break;
X		case EQ: pop2lv(); set(b); break;
X		case PLUSEQ: pop2lv(); set(a+b); break;
X		case MINUSEQ: pop2lv(); set(a-b); break;
X		case MULEQ: pop2lv(); set(a*b); break;
X		case DIVEQ: pop2lv(); if (notzero(b)) set(a/b); break;
X		case MODEQ: pop2lv(); if (notzero(b)) set(a%b); break;
X		case ANDEQ: pop2lv(); set(a&b); break;
X		case XOREQ: pop2lv(); set(a^b); break;
X		case OREQ: pop2lv(); set(a|b); break;
X		case SHLEFTEQ: pop2lv(); set(a<<b); break;
X		case SHRIGHTEQ: pop2lv(); set(a>>b); break;
X		case DANDEQ: pop2lv(); set(a&&b); break;
X		case DOREQ: pop2lv(); set(a||b); break;
X		case DXOREQ: pop2lv(); set(a&&!b||!a&&b); break;
X		case COMMA: pop2(); pushv(b); break;
X		case PREPLUS: stack[sp].val = setvar(stack[sp].lval,
X			stack[sp].val+1); break;
X		case PREMINUS: stack[sp].val = setvar(stack[sp].lval,
X			stack[sp].val-1); break;
X		default: zerr("out of integers",NULL,0); exit(1);
X	}
X}
X
Xvoid bop(tk) /**/
Xint tk;
X{
X	switch (tk) {
X		case DAND: case DANDEQ: if (!stack[sp].val) noeval++; break;
X		case DOR: case DOREQ: if (stack[sp].val) noeval++; break;
X		};
X}
X
Xlong mathevall(s,prek,ep) /**/
Xchar *s;int prek;char **ep;
X{
Xint t0;
X
X	lastbase = -1;
X	for (t0 = 0; t0 != LVCOUNT; t0++)
X		lvals[t0] = NULL;
X	lvc = 0;
X	ptr = s;
X	sp = -1;
X	unary = 1;
X	mathparse(prek);
X	*ep = ptr;
X	if (sp)
X		zerr("bad math expression: unbalanced stack",NULL,0);
X	for (t0 = 0; t0 != lvc; t0++)
X		free(lvals[t0]);
X	return stack[0].val;
X}
X
Xlong matheval(s) /**/
Xchar *s;
X{
Xchar *junk;
Xlong x;
X
X	if (!*s)
X		return 0;
X	x = mathevall(s,TOPPREC,&junk);
X	if (*junk)
X		zerr("bad math expression: illegal character: %c",NULL,*junk);
X	return x;
X}
X
Xlong mathevalarg(s,ss) /**/
Xchar *s;char **ss;
X{
Xlong x;
X
X	x = mathevall(s,ARGPREC,ss);
X	if (mtok == COMMA)
X		(*ss)--;
X	return x;
X}
X
X/* operator-precedence parse the string and execute */
X
Xvoid mathparse(pc) /**/
Xint pc;
X{
X	if (errflag)
X		return;
X	mtok = zzlex();
X	while (prec[mtok] <= pc)
X		{
X		if (errflag)
X			return;
X		if (mtok == NUM)
X			push(yyval,-1);
X		else if (mtok == ID)
X			push(getvar(yylval),yylval);
X		else if (mtok == M_INPAR)
X			{
X			mathparse(TOPPREC);
X			if (mtok != M_OUTPAR)
X				exit(1);
X			}
X		else if (mtok == QUEST)
X			{
X			int q = stack[sp].val;
X			if (!q) noeval++;
X			mathparse(prec[QUEST]-1);
X			if (!q) noeval--; else noeval++;
X			mathparse(prec[QUEST]);
X			if (q) noeval--;
X			op(QUEST);
X			continue;
X			}
X		else
X			{
X			int otok = mtok,onoeval = noeval;
X
X			if (type[otok] == BOOL)
X				bop(otok);
X			mathparse(prec[otok]-(type[otok] != RL));
X			noeval = onoeval;
X			op(otok);
X			continue;
X			}
X		mtok = zzlex();
X		}
X}
X
SHAR_EOF
chmod 0644 zsh2.2/src/math.c ||
echo 'restore of zsh2.2/src/math.c failed'
Wc_c="`wc -c < 'zsh2.2/src/math.c'`"
test 10185 -eq "$Wc_c" ||
	echo 'zsh2.2/src/math.c: original size 10185, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/mem.c ==============
if test -f 'zsh2.2/src/mem.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/mem.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/mem.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/mem.c' &&
X/*
X *
X * mem.c - memory management
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X/*
X
X	mem.c - memory management
X
X	This file is part of zsh, the Z shell.
X
X	zsh is free software; no one can prevent you from reading the source
X   code, or giving it to someone else.
X
X   This file is copyrighted under the GNU General Public License, which
X   can be found in the file called COPYING.
X
X   Copyright (C) 1990, 1991 Paul Falstad
X
X*/
X
X#include "zsh.h"
X#define HEAPSIZE 8192
X
X/*
X
X	There are two ways to allocate memory in zsh.  The first way is
X	to call zalloc/zcalloc, which call malloc/calloc directly.  It
X	is legal to call realloc() or free() on memory allocated this way.
X	The second way is to call halloc/hcalloc, which allocates memory
X	from one of the memory pools on the heap stack.  A pool can be
X	created by calling pushheap(), and destroyed by calling popheap().
X	To free the memory in the pool without destroying it, call
X	freeheap(); this is equivalent to { popheap(); pushheap(); }
X	Memory allocated in this way does not have to be freed explicitly;
X	it will all be freed when the pool is destroyed.  In fact,
X	attempting to free this memory may result in a core dump.
X	The pair of pointers ncalloc and alloc may point to either
X	zalloc & zcalloc or halloc & hcalloc; permalloc() sets them to the
X	former, and heapalloc() sets them to the latter. This can be useful.
X	For example, the dupstruct() routine duplicates a syntax tree,
X	allocating the new memory for the tree using alloc().  If you want
X	to duplicate a structure for a one-time use (i.e. to execute the list
X	in a for loop), call heapalloc(), then dupstruct().  If you want
X	to duplicate a structure in order to preserve it (i.e. a function
X	definition), call permalloc(), then dupstruct().
X
X*/
X
X/* initialize heap stack */
X
Xvoid meminit() /**/
X{
X	permalloc();
X	heaplist = newlist();
X	pushheap();
X}
X
X/* set default allocation to heap stack */
X
Xvoid heapalloc() /**/
X{
X	alloc = hcalloc;
X	ncalloc = halloc;
X	useheap = 1;
X}
X
Xstatic vptr (*lastcalloc) DCLPROTO((int));
Xstatic vptr (*lastncalloc) DCLPROTO((int));
X
X/* set default allocation to malloc() */
X
Xvoid permalloc() /**/
X{
X	lastcalloc = alloc;
X	lastncalloc = ncalloc;
X	alloc = zcalloc;
X	ncalloc = zalloc;
X	useheap = 0;
X}
X
X/* reset previous default allocation */
X
Xvoid lastalloc() /**/
X{
X	alloc = lastcalloc;
X	ncalloc = lastncalloc;
X}
X
Xstruct heap {
X	char *pool,*ptr;
X	int free;
X	struct heap *next;
X	};
X
X/* create a memory pool */
X
Xvoid pushheap() /**/
X{
XHeap h;
X
X	h = (Heap) zalloc(sizeof *h);
X	h->pool = h->ptr = zalloc(HEAPSIZE);
X	h->free = HEAPSIZE;
X	h->next = NULL;
X	permalloc();
X	pushnode(heaplist,h);
X	lastalloc();
X}
X
X/* reset a memory pool */
X
Xvoid freeheap() /**/
X{
XHeap h = (Heap) peekfirst(heaplist);
X
X	freeh(h->next);
X	h->next = NULL;
X	h->free += (h->ptr-h->pool);
X	h->ptr = h->pool;
X}
X
X/* destroy a memory pool */
X
Xvoid popheap() /**/
X{
XHeap h = (Heap) getnode(heaplist);
X
X	freeh(h);
X}
X
Xvoid freeh(h) /**/
XHeap h;
X{
X	if (h)
X		{
X		freeh(h->next);
X		free(h->pool);
X		free(h);
X		}
X}
X
X/* allocate memory from the current memory pool */
X
Xvptr halloc(size) /**/
Xint size;
X{
XHeap h = (Heap) peekfirst(heaplist),h2;
Xchar *ret;
X
X	size = (size|7)+1;
X	while (h && h->free-size < 0)
X		h = h->next;
X	if (!h) {
X		h2 = (Heap) zalloc(sizeof *h2);
X		h2->pool = h2->ptr = zalloc(h2->free = 
X			(size < HEAPSIZE) ? HEAPSIZE : (size|(HEAPSIZE-1))+1);
X		h2->next = (Heap) peekfirst(heaplist);
X		setdata(firstnode(heaplist),(vptr) h2);
X		h = h2;
X	}
X	h->free -= size;
X	ret = h->ptr;
X	h->ptr += size;
X	return ret;
X}
X
X/* allocate memory from the current memory pool and clear it */
X
Xvptr hcalloc(size) /**/
Xint size;
X{
Xvptr ptr;
X
X	ptr = halloc(size);
X	memset(ptr,0,size);
X	return ptr;
X}
X
Xvptr hrealloc(p,old,new) /**/
Xchar *p;int old;int new;
X{
Xchar *ptr;
X
X	ptr = halloc(new);
X	memcpy(ptr,p,old);
X	return ptr;
X}
X
X/* allocate permanent memory */
X
Xvptr zalloc(l) /**/
Xint l;
X{
Xvptr z;
X 
X	if (!l) l = 1;
X	if (!(z = malloc(l)))
X		{
X		zerr("fatal error: out of memory",NULL,0);
X		exit(1);
X		}
X	return z;
X}
X
Xvptr zcalloc(size) /**/
Xint size;
X{
Xvptr ptr;
X
X	ptr = zalloc(size);
X	memset(ptr,0,size);
X	return ptr;
X}
X
Xchar *strdup(s) /**/
Xchar *s;
X{
Xchar *t;
X
X	if (!s)
X		return NULL;
X	t = ncalloc(strlen(s)+1);
X	strcpy(t,s);
X	return t;
X}
X
Xchar *ztrdup(s) /**/
Xchar *s;
X{
Xchar *t;
X
X	if (!s)
X		return NULL;
X	t = zalloc(strlen(s)+1);
X	strcpy(t,s);
X	return t;
X}
X
SHAR_EOF
chmod 0644 zsh2.2/src/mem.c ||
echo 'restore of zsh2.2/src/mem.c failed'
Wc_c="`wc -c < 'zsh2.2/src/mem.c'`"
test 4948 -eq "$Wc_c" ||
	echo 'zsh2.2/src/mem.c: original size 4948, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/params.c ==============
if test -f 'zsh2.2/src/params.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/params.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/params.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/params.c' &&
X/*
X *
X * params.c - parameters
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X#include <pwd.h>
X
X#define new(X) (X=(vptr)alloc(sizeof(*(X))))
X
Xstatic Param argvparam;
X
Xstruct iparam {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	void *value;
X	int (*func1)(); /* set func */
X	int (*func2)(); /* get func */
X	int ct;				/* output base or field width */
X	int flags;
X	vptr data;			/* used by getfns */
X	char *env;			/* location in environment, if exported */
X	char *ename;		/* name of corresponding environment var */
X	};
X
X#define IFN(X) ((int (*)())(X))
X
X/* put predefined params in hash table */
X
Xvoid setupparams() /**/
X{
Xstatic struct iparam pinit[] = {
X#define IPDEF1(A,B,C,D) {NULL,0,A,NULL,IFN(C),IFN(B),10,\
X		PMFLAG_i|PMFLAG_SPECIAL|D,NULL,NULL,NULL}
X	IPDEF1("#",poundgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("ARGC",poundgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("ERRNO",errnogetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("GID",gidgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF1("HISTSIZE",histsizegetfn,histsizesetfn,0),
X	IPDEF1("LITHISTSIZE",lithistsizegetfn,lithistsizesetfn,0),
X	IPDEF1("RANDOM",randomgetfn,randomsetfn,0),
X	IPDEF1("SECONDS",secondsgetfn,secondssetfn,0),
X	IPDEF1("UID",uidgetfn,IFN(nullsetfn),PMFLAG_r),
X
X#define IPDEF2(A,B,C,D) {NULL,0,A,NULL,IFN(C),IFN(B),0,\
X		PMFLAG_SPECIAL|D,NULL,NULL,NULL}
X	IPDEF2("-",dashgetfn,IFN(nullsetfn),PMFLAG_r),
X	IPDEF2("HISTCHARS",histcharsgetfn,histcharssetfn,0),
X	IPDEF2("HOME",homegetfn,homesetfn,0),
X	IPDEF2("TERM",termgetfn,termsetfn,0),
X	IPDEF2("WORDCHARS",wordcharsgetfn,wordcharssetfn,0),
X	IPDEF2("IFS",ifsgetfn,ifssetfn,0),
X	IPDEF2("_",underscoregetfn,IFN(nullsetfn),PMFLAG_r),
X
X#define IPDEF3(A,B) {NULL,0,A,NULL,IFN(nullsetfn),IFN(strconstgetfn),0,PMFLAG_r|\
X		PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF3("HOSTTYPE",HOSTTYPE),
X	IPDEF3("VERSION",VERSIONSTR),
X
X#define IPDEF4(A,B) {NULL,0,A,NULL,IFN(nullsetfn),IFN(intvargetfn),10,\
X		PMFLAG_r|PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF4("!",&lastpid),
X	IPDEF4("$",&mypid),
X	IPDEF4("?",&lastval),
X	IPDEF4("status",&lastval),
X	IPDEF4("LINENO",&lineno),
X	IPDEF4("PPID",&ppid),
X
X#define IPDEF5(A,B) {NULL,0,A,NULL,IFN(intvarsetfn),IFN(intvargetfn),10,\
X		PMFLAG_i|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF5("BAUD",&baud),
X	IPDEF5("COLUMNS",&columns),
X	IPDEF5("DIRSTACKSIZE",&dirstacksize),
X	IPDEF5("LINES",&lines),
X	IPDEF5("LISTMAX",&listmax),
X	IPDEF5("LOGCHECK",&logcheck),
X	IPDEF5("MAILCHECK",&mailcheck),
X	IPDEF5("OPTIND",&zoptind),
X	IPDEF5("PERIOD",&period),
X	IPDEF5("REPORTTIME",&reporttime),
X	IPDEF5("SAVEHIST",&savehist),
X	IPDEF5("SHLVL",&shlvl),
X	IPDEF5("TMOUT",&tmout),
X
X#define IPDEF6(A,B) {NULL,0,A,NULL,IFN(nullsetfn),IFN(strvargetfn),0,\
X		PMFLAG_r|PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF6("LOGNAME",&logname),
X	IPDEF6("PWD",&pwd),
X	IPDEF6("TTY",&ttystrname),
X	IPDEF6("USERNAME",&username),
X
X#define IPDEF7(A,B) {NULL,0,A,NULL,IFN(strvarsetfn),IFN(strvargetfn),0,\
X		PMFLAG_SPECIAL,(vptr)B,NULL,NULL}
X	IPDEF7("FCEDIT",&fceditparam),
X	IPDEF7("HOST",&hostnam),
X	IPDEF7("OLDPWD",&oldpwd),
X	IPDEF7("OPTARG",&optarg),
X	IPDEF7("MAIL",&mailfile),
X	IPDEF7("NULLCMD",&nullcmd),
X	IPDEF7("POSTEDIT",&postedit),
X	IPDEF7("prompt",&prompt),
X	IPDEF7("PROMPT",&prompt),
X	IPDEF7("PROMPT2",&prompt2),
X	IPDEF7("PROMPT3",&prompt3),
X	IPDEF7("PROMPT4",&prompt4),
X	IPDEF7("READNULLCMD",&readnullcmd),
X	IPDEF7("RPROMPT",&rprompt),
X	IPDEF7("PS1",&prompt),
X	IPDEF7("PS2",&prompt2),
X	IPDEF7("PS3",&prompt3),
X	IPDEF7("PS4",&prompt4),
X	IPDEF7("RPS1",&rprompt),
X	IPDEF7("SPROMPT",&sprompt),
X	IPDEF7("TIMEFMT",&timefmt),
X	IPDEF7("TMPPREFIX",&tmpprefix),
X	IPDEF7("WATCHFMT",&watchfmt),
X	IPDEF7("0",&argzero),
X
X#define IPDEF8(A,B,C) {NULL,0,A,NULL,IFN(colonarrsetfn),IFN(colonarrgetfn),0,\
X		PMFLAG_SPECIAL,(vptr)C,NULL,B}
X	IPDEF8("CDPATH","cdpath",&cdpath),
X	IPDEF8("FIGNORE","fignore",&fignore),
X	IPDEF8("FPATH","fpath",&fpath),
X	IPDEF8("MAILPATH","mailpath",&mailpath),
X	IPDEF8("MANPATH","manpath",&manpath),
X	IPDEF8("WATCH","watch",&watch),
X	IPDEF8("HOSTS","hosts",&hosts),
X	IPDEF8("PATH",NULL,NULL),
X
X#define IPDEF9(A,B,C) {NULL,0,A,NULL,IFN(arrvarsetfn),IFN(arrvargetfn),0,\
X		PMFLAG_A|PMFLAG_SPECIAL|C,(vptr)B,NULL,NULL}
X	IPDEF9("cdpath",&cdpath,0),
X	IPDEF9("fignore",&fignore,0),
X	IPDEF9("fpath",&fpath,0),
X	IPDEF9("mailpath",&mailpath,0),
X	IPDEF9("manpath",&manpath,0),
X	IPDEF9("watch",&watch,0),
X	IPDEF9("hosts",&hosts,0),
X	IPDEF9("signals",&sigptr,PMFLAG_r),
X	IPDEF9("argv",&pparams,0),
X	IPDEF9("*",&pparams,0),
X	IPDEF9("@",&pparams,0),
X
X#define IPDEF10(A,C,D) {NULL,0,A,NULL,IFN(D),IFN(C),0,\
X		PMFLAG_A|PMFLAG_SPECIAL,NULL,NULL,NULL}
X	IPDEF10("path",pathgetfn,pathsetfn),
X	IPDEF10("hostcmds",nullgetfn,hostcmdssetfn),
X	IPDEF10("optcmds",nullgetfn,optcmdssetfn),
X	IPDEF10("bindcmds",nullgetfn,bindcmdssetfn),
X	IPDEF10("varcmds",nullgetfn,varcmdssetfn),
X	{NULL,}
X	};
Xstruct iparam *ip;
X
X	for (ip = pinit; ip->nam; ip++) addhperm(ip->nam,ip,paramtab,NULL);
X	argvparam = gethnode("argv",paramtab);
X}
X
Xstatic int unsetflag;
X
Xstruct param *createparam(name,value,flags) /**/
Xchar *name;vptr value;int flags;
X{
Xstruct param *pm;
Xchar buf[20];
X
X	pm = zcalloc(sizeof *pm);
X	if (isset(ALLEXPORT))
X		flags |= PMFLAG_x;
X	pm->flags = flags;
X	if ((flags & PMTYPE) == PMFLAG_s) {
X		pm->u.str = value;
X		pm->sets.cfn = strsetfn;
X		pm->gets.cfn = strgetfn;
X	} else if ((flags & PMTYPE) == PMFLAG_A) {
X		pm->u.arr = value;
X		pm->sets.afn = arrsetfn;
X		pm->gets.afn = arrgetfn;
X	} else {
X		pm->u.val = (value) ? matheval(value) : 0;
X		pm->sets.ifn = intsetfn;
X		pm->gets.ifn = intgetfn;
X		sprintf(buf,"%ld",pm->u.val);
X		value = buf;
X	}
X	if (flags & PMFLAG_x)
X		pm->env = addenv(name,value);
X	addhnode(ztrdup(name),pm,paramtab,freepm);
X	return pm;
X}
X
Xint isident(s) /**/
Xchar *s;
X{
Xchar *ss;
X
X	for (ss = s; *ss; ss++) if (!iident(*ss)) break;
X	if (!*ss || *ss == '[') return 1;
X	if (*s == Quest)
X		*s = '?';
X	else if (*s == Pound)
X		*s = '#';
X	else if (*s == String || *s == Qstring)
X		*s = '$';
X	else if (*s == Star)
X		*s = '*';
X	if (*s == '#' || *s == '-' || *s == '?' || *s == '$' || *s == '_' ||
X		 *s == '!' || *s == '@' || *s == '*')
X		return 1;
X	return 0;
X}
X
XValue getvalue(pptr,bracks) /**/
Xchar **pptr;int bracks;
X{
Xchar *s = *pptr,*t = *pptr;
Xchar sav;
XValue v;
X
X	if (idigit(*s)) while (idigit(*s)) s++;
X	else if (iident(*s)) while (iident(*s)) s++;
X	else if (*s == Quest) *s++ = '?';
X	else if (*s == Pound) *s++ = '#';
X	else if (*s == String) *s++ = '$';
X	else if (*s == Qstring) *s++ = '$';
X	else if (*s == Star) *s++ = '*';
X	else if (*s == '#' || *s == '-' || *s == '?' || *s == '$' ||
X				*s == '_' || *s == '!' || *s == '@' || *s == '*') s++;
X	else return NULL;
X	if (sav = *s) *s = '\0';
X	if (idigit(*t) && *t != '0') {
X		v = (Value) hcalloc(sizeof *v);
X		v->pm = argvparam;
X		v->a = v->b = atoi(t)-1;
X		if (sav)
X			*s = sav;
X	} else {
X		struct param *pm;
X		int isvarat = !strcmp(t, "@");
X
X		pm = gethnode(t,paramtab);
X		if (sav)
X			*s = sav;
X		*pptr = s;
X		if (!pm)
X			return NULL;
X		v = hcalloc(sizeof *v);
X		if (pmtype(pm) == PMFLAG_A)
X			v->isarr = isvarat ? -1 : 1;
X		v->pm = pm;
X		v->a = 0; v->b = -1;
X		if (bracks && (*s == '[' || *s == Inbrack)) {
X			int a,b;
X			char *olds = s,*t;
X
X			*s++ = '[';
X			for (t = s; *t && *t != ']' && *t != Outbrack; t++)
X				if (itok(*t))
X					*t = ztokens[*t-Pound];
X			if (*t == Outbrack)
X				*t = ']';
X			if ((s[0] == '*' || s[0] == '@')  && s[1] == ']') {
X				if (v->isarr) v->isarr = (s[0] == '*') ? 1 : -1;
X				v->a = 0;
X				v->b = -1;
X				s += 2;
X			} else {
X				a = mathevalarg(s,&s);
X				if (a > 0) a--;
X				if (*s == ',' || *s == Comma) {
X					s++;
X					b = mathevalarg(s,&s);
X					if (b > 0) b--;
X				} else
X					b = a;
X				if (*s == ']') {
X					s++;
X					if (v->isarr && a == b)
X						v->isarr = 0;
X					v->a = a;
X					v->b = b;
X				} else
X					s = olds;
X			}
X		}
X	}
X	if (!bracks && *s)
X		return NULL;
X	*pptr = s;
X	return v;
X}
X
Xchar *getstrvalue(v) /**/
XValue v;
X{
Xchar *s,**ss;
Xstatic char buf[20];
X
X	if (!v)
X		return "";
X	if (pmtype(v->pm) != PMFLAG_A) {
X		if ((pmtype(v->pm) == PMFLAG_i))
X			convbase(s = buf,v->pm->gets.ifn(v->pm),v->pm->ct);
X		else
X			s = v->pm->gets.cfn(v->pm);
X		if (v->a == 0 && v->b == -1) return s;
X		if (v->a < 0) v->a += strlen(s);
X		if (v->b < 0) v->b += strlen(s);
X		s = (v->a > strlen(s)) ? strdup("") : strdup(s+v->a);
X		if (v->b < v->a) s[0] = '\0';
X		else if (v->b-v->a < strlen(s)) s[v->b-v->a+1] = '\0';
X		return s;
X	}
X	if (v->isarr) return spacejoin(v->pm->gets.afn(v->pm));
X
X	ss = v->pm->gets.afn(v->pm);
X	if (v->a < 0) v->a += arrlen(ss);
X	s = (v->a >= arrlen(ss) || v->a < 0) ? "" : ss[v->a];
X	return s;
X}
X
Xchar **getarrvalue(v) /**/
XValue v;
X{
Xchar **s;
Xstatic char *nular[] = { "", NULL };
X
X	if (!v)
X		return arrdup(nular);
X	s = v->pm->gets.afn(v->pm);
X	if (v->a == 0 && v->b == -1) return s;
X	if (v->a < 0) v->a += arrlen(s);
X	if (v->b < 0) v->b += arrlen(s);
X	if (v->a > arrlen(s) || v->a < 0)
X		s = arrdup(nular);
X	else
X		s = arrdup(s)+v->a;
X	if (v->b < v->a) s[0] = NULL;
X	else if (v->b-v->a < arrlen(s)) s[v->b-v->a+1] = NULL;
X	return s;
X}
X
Xlong getintvalue(v) /**/
XValue v;
X{
Xchar **ss;
X
X	if (!v || v->isarr)
X		return 0;
X	if (pmtype(v->pm) != PMFLAG_A) {
X		if (pmtype(v->pm) == PMFLAG_i)
X			return v->pm->gets.ifn(v->pm);
X		return atol(v->pm->gets.cfn(v->pm));
X	}
X	ss = v->pm->gets.afn(v->pm);
X	if (v->a < 0) v->a += arrlen(ss);
X	if (v->a < 0 || v->a > arrlen(ss)) return 0;
X	return atol(ss[v->a]);
X}
X
Xvoid setstrvalue(v,val) /**/
XValue v;char *val;
X{
Xchar *s;
X
X	if (v->pm->flags & PMFLAG_r) {
X		free(val);
X		return;
X	}
X	if ((s = v->pm->env) && val)
X		v->pm->env = replenv(v->pm->env,val);
X	switch (pmtype(v->pm)) {
X		case PMFLAG_s:
X			if (v->a == 0 && v->b == -1)
X				(v->pm->sets.cfn)(v->pm,val);
X			else {
X				char *z,*y,*x;
X
X				z = strdup((v->pm->gets.cfn)(v->pm));
X				if (v->a < 0) {
X					v->a += strlen(z);
X					if (v->a < 0) v->a = 0;
X				}
X				if (v->a > strlen(z)) v->a = strlen(z);
X				if (v->b < 0) v->b += strlen(z);
X				if (v->b < v->a) v->b = v->a;
X				z[v->a] = '\0';
X				y = z+v->b+1;
X				x = zalloc(strlen(z)+strlen(y)+strlen(val)+1);
X				strcpy(x,z);
X				strcat(x,val);
X				strcat(x,y);
X				(v->pm->sets.cfn)(v->pm,x);
X			}
X			if (v->pm->flags & (PMFLAG_L|PMFLAG_R|PMFLAG_Z) && !v->pm->ct)
X				v->pm->ct = strlen(val);
X			break;
X		case PMFLAG_i:
X			(v->pm->sets.ifn)(v->pm,matheval(val));
X			if (!v->pm->ct && lastbase != 1)
X				v->pm->ct = lastbase;
X			free(val);
X			break;
X		case PMFLAG_A:
X			if (v->a != v->b)
X				zerr("illegal array assignment",NULL,0);
X			else {
X				char **ss = (v->pm->gets.afn)(v->pm);
X				int ac,ad,t0;
X
X				ac = arrlen(ss);
X				if (v->a < 0) {
X					v->a += ac;
X					if (v->a < 0) v->a = 0;
X				}
X				if (v->a >= ac) {
X					char **st = ss;
X
X					ad = v->a+1;
X					ss = zalloc((ad+1)*sizeof *ss);
X					memcpy(ss,st,(ad+1)*sizeof *ss);
X					for (t0 = 0; t0 != ac; t0++)
X						ss[t0] = ztrdup(ss[t0]);
X					while (ac < ad)
X						ss[ac++] = ztrdup("");
X					ss[ac] = NULL;
X				}
X				if (ss[v->a]) free(ss[v->a]);
X				ss[v->a] = val;
X				(v->pm->sets.afn)(v->pm,ss);
X			}
X			break;
X	}
X}
X
Xvoid setintvalue(v,val) /**/
XValue v;long val;
X{
Xchar buf[20];
X
X	if (v->pm->flags & PMFLAG_r)
X		return;
X	if (v->pm->env) {
X		sprintf(buf,"%ld",val);
X		v->pm->env = replenv(v->pm->env,buf);
X	}
X	switch (pmtype(v->pm))
X		{
X		case PMFLAG_s:
X			sprintf(buf,"%ld",val);
X			(v->pm->sets.cfn)(v->pm,ztrdup(buf));
X			break;
X		case PMFLAG_i:
SHAR_EOF
true || echo 'restore of zsh2.2/src/params.c failed'
fi
echo 'End of zsh2.2 part 10'
echo 'File zsh2.2/src/params.c is continued in part 11'
echo 11 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
