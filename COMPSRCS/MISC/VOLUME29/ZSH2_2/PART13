Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i109:  zsh2.2 - The Z shell, Part13/17
Message-ID: <1992May13.160654.10358@sparky.imd.sterling.com>
X-Md4-Signature: 2c035840861e8b42f58582935f9913e1
Date: Wed, 13 May 1992 16:06:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 109
Archive-name: zsh2.2/part13
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.13 (part 13 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/src/zle.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 13; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/src/zle.h'
else
echo 'x - continuing file zsh2.2/src/zle.h'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/src/zle.h' &&
X#define z_viforwardwordend 104
X#define z_vigotocolumn 105
X#define z_vigotomark 106
X#define z_vigotomarkline 107
X#define z_vihistorysearchbackward 108
X#define z_vihistorysearchforward 109
X#define z_viindent 110
X#define z_viinsert 111
X#define z_viinsertbol 112
X#define z_vijoin 113
X#define z_vimatchbracket 114
X#define z_viopenlineabove 115
X#define z_viopenlinebelow 116
X#define z_vioperswapcases 117
X#define z_viputafter 118
X#define z_virepeatchange 119
X#define z_virepeatfind 120
X#define z_virepeatsearch 121
X#define z_vireplace 122
X#define z_vireplacechars 123
X#define z_virevrepeatfind 124
X#define z_virevrepeatsearch 125
X#define z_visetbuffer 126
X#define z_visetmark 127
X#define z_visubstitute 128
X#define z_viswapcase 129
X#define z_viundochange 130
X#define z_viunindent 131
X#define z_viyank 132
X#define z_viyankeol 133
X#define z_whichcommand 134
X#define z_yank 135
X#define z_yankpop 136
X#define z_emacsbackwardword 137
X#define z_emacsforwardword 138
X#define z_killword 139
X#define z_vikillline 140
X#define z_vibackwardkillword 141
X#define z_expandcmdpath 142
X#define z_negargument 143
X#define z_poundinsert 144
X#define z_viforwardword 145
X#define z_vibackwardword 146
X#define ZLECMDCOUNT 147
X
Xextern struct zlecmd zlecmds[];
X
SHAR_EOF
echo 'File zsh2.2/src/zle.h is complete' &&
chmod 0644 zsh2.2/src/zle.h ||
echo 'restore of zsh2.2/src/zle.h failed'
Wc_c="`wc -c < 'zsh2.2/src/zle.h'`"
test 8371 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle.h: original size 8371, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_bindings.c ==============
if test -f 'zsh2.2/src/zle_bindings.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_bindings.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_bindings.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_bindings.c' &&
X/*
X *
X * zle_bindings.c - commands and keymaps
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X
Xstruct zlecmd zlecmds[] = {
X"accept-and-hold",acceptandhold,0,
X"accept-and-infer-next-history",acceptandinfernexthistory,0,
X"accept-and-menu-complete", acceptandmenucomplete, ZLE_MENUCMP,
X"accept-line",acceptline,0,
X"accept-line-and-down-history",acceptlineanddownhistory,0,
X"backward-char",backwardchar,ZLE_MOVEMENT,
X"backward-delete-char",backwarddeletechar,0,
X"backward-delete-word",backwarddeleteword,0,
X"backward-kill-line",backwardkillline,ZLE_KILL,
X"backward-kill-word",backwardkillword,ZLE_KILL,
X"backward-word",backwardword,ZLE_MOVEMENT,
X"beginning-of-buffer-or-history",beginningofbufferorhistory,ZLE_MOVEMENT,
X"beginning-of-history",beginningofhistory,0,
X"beginning-of-line",beginningofline,ZLE_MOVEMENT,
X"beginning-of-line-hist",beginningoflinehist,ZLE_MOVEMENT,
X"capitalize-word",capitalizeword,0,
X"clear-screen",clearscreen,0,
X"complete-word",completeword,ZLE_MENUCMP,
X"copy-prev-word",copyprevword,0,
X"copy-region-as-kill",copyregionaskill,ZLE_KILL,
X"delete-char",deletechar,0,
X"delete-char-or-list",deletecharorlist,ZLE_MENUCMP,
X"delete-word",deleteword,0,
X"digit-argument",digitargument,ZLE_ARG,
X"down-case-word",downcaseword,0,
X"down-history",downhistory,0,
X"down-line-or-history",downlineorhistory,ZLE_MOVEMENT|ZLE_LINEMOVE,
X"end-of-buffer-or-history",endofbufferorhistory,ZLE_MOVEMENT,
X"end-of-history",endofhistory,0,
X"end-of-line",endofline,ZLE_MOVEMENT,
X"end-of-line-hist",endoflinehist,ZLE_MOVEMENT,
X"exchange-point-and-mark",exchangepointandmark,ZLE_MOVEMENT,
X"execute-last-named-cmd",NULL,0,
X"execute-named-cmd",NULL,0,
X"expand-history",expandhistory,0,
X"expand-or-complete",expandorcomplete,ZLE_MENUCMP,
X"expand-word",expandword,0,
X"forward-char",forwardchar,ZLE_MOVEMENT,
X"forward-word",forwardword,ZLE_MOVEMENT,
X"get-line",getline,0,
X"gosmacs-transpose-chars",gosmacstransposechars,0,
X"history-incremental-search-backward",historyincrementalsearchbackward,0,
X"history-incremental-search-forward",historyincrementalsearchforward,0,
X"history-search-backward",historysearchbackward,ZLE_HISTSEARCH,
X"history-search-forward",historysearchforward,ZLE_HISTSEARCH,
X"infer-next-history",infernexthistory,0,
X"insert-last-word",insertlastword,ZLE_INSERT,
X"kill-buffer",killbuffer,ZLE_KILL,
X"kill-line",killline,ZLE_KILL,
X"kill-region",killregion,ZLE_KILL,
X"kill-whole-line",killwholeline,ZLE_KILL,
X"list-choices",listchoices,0,
X"list-expand",listexpand,ZLE_MENUCMP,
X"magic-space",magicspace,0,
X"menu-complete",menucompleteword,ZLE_MENUCMP,
X"menu-expand-or-complete",menuexpandorcomplete,ZLE_MENUCMP,
X"overwrite-mode",overwritemode,0,
X"push-line",pushline,0,
X"quoted-insert",quotedinsert,ZLE_INSERT,
X"quote-line",quoteline,0,
X"quote-region",quoteregion,0,
X"redisplay",redisplay,0,
X"reverse-menu-complete",reversemenucomplete,ZLE_MENUCMP,
X"run-help",processcmd,0,
X"self-insert",selfinsert,ZLE_INSERT,
X"self-insert-unmeta",selfinsertunmeta,ZLE_INSERT,
X"send-break",sendbreak,0,
X"send-string",sendstring,0,
X"",NULL,0,
X"set-mark-command",setmarkcommand,0,
X"spell-word",spellword,0,
X"toggle-literal-history",toggleliteralhistory,0,
X"transpose-chars",transposechars,0,
X"transpose-words",transposewords,0,
X"undefined-key",undefinedkey,0,
X"undo",undo,ZLE_UNDO,
X"universal-argument",universalargument,ZLE_ARG,
X"up-case-word",upcaseword,0,
X"up-history",uphistory,0,
X"up-line-or-history",uplineorhistory,ZLE_LINEMOVE|ZLE_MOVEMENT,
X"vi-add-eol",viaddeol,0,
X"vi-add-next",viaddnext,0,
X"vi-backward-blank-word",vibackwardblankword,ZLE_MOVEMENT,
X"vi-backward-char",vibackwardchar,ZLE_MOVEMENT,
X"vi-backward-delete-char",vibackwarddeletechar,ZLE_KILL,
X"vi-beginning-of-line",vibeginningofline,ZLE_MOVEMENT,
X"vi-caps-lock-panic",vicapslockpanic,0,
X"vi-change",vichange,0,
X"vi-change-eol",vichangeeol,0,
X"vi-change-whole-line",vichangewholeline,0,
X"vi-cmd-mode",vicmdmode,0,
X"vi-delete",videlete,ZLE_KILL,
X"vi-delete-char",videletechar,ZLE_KILL,
X"vi-digit-or-beginning-of-line",NULL,0,
X"vi-end-of-line",viendofline,ZLE_MOVEMENT,
X"vi-fetch-history",vifetchhistory,0,
X"vi-find-next-char",vifindnextchar,ZLE_MOVEMENT,
X"vi-find-next-char-skip",vifindnextcharskip,ZLE_MOVEMENT,
X"vi-find-prev-char",vifindprevchar,ZLE_MOVEMENT,
X"vi-find-prev-char-skip",vifindprevcharskip,ZLE_MOVEMENT,
X"vi-first-non-blank",vifirstnonblank,ZLE_MOVEMENT,
X"vi-forward-blank-word",viforwardblankword,ZLE_MOVEMENT,
X"vi-forward-blank-word-end",viforwardblankwordend,ZLE_MOVEMENT,
X"vi-forward-char",viforwardchar,ZLE_MOVEMENT,
X"vi-forward-word-end",viforwardwordend,ZLE_MOVEMENT,
X"vi-goto-column",vigotocolumn,ZLE_MOVEMENT,
X"vi-goto-mark",vigotomark,ZLE_MOVEMENT,
X"vi-goto-mark-line",vigotomarkline,ZLE_MOVEMENT,
X"vi-history-search-backward",vihistorysearchbackward,0,
X"vi-history-search-forward",vihistorysearchforward,0,
X"vi-indent",viindent,0,
X"vi-insert",viinsert,0,
X"vi-insert-bol",viinsertbol,0,
X"vi-join",vijoin,0,
X"vi-match-bracket",vimatchbracket,ZLE_MOVEMENT,
X"vi-open-line-above",viopenlineabove,0,
X"vi-open-line-below",viopenlinebelow,0,
X"vi-oper-swap-case",vioperswapcase,0,
X"vi-put-after",viputafter,ZLE_YANK,
X"vi-repeat-change",virepeatchange,0,
X"vi-repeat-find",virepeatfind,ZLE_MOVEMENT,
X"vi-repeat-search",virepeatsearch,ZLE_MOVEMENT,
X"vi-replace",vireplace,0,
X"vi-replace-chars",vireplacechars,0,
X"vi-rev-repeat-find",virevrepeatfind,ZLE_MOVEMENT,
X"vi-rev-repeat-search",virevrepeatsearch,ZLE_MOVEMENT,
X"vi-set-buffer",visetbuffer,0,
X"vi-set-mark",visetmark,0,
X"vi-substitute",visubstitute,0,
X"vi-swap-case",viswapcase,0,
X"vi-undo-change",undo,0,
X"vi-unindent",viunindent,0,
X"vi-yank",viyank,0,
X"vi-yank-eol",viyankeol,0,
X"which-command",processcmd,0,
X"yank",yank,ZLE_YANK|ZLE_NAMEDBUFFER,
X"yank-pop",yankpop,ZLE_YANK,
X"emacs-forward-word",emacsforwardword,ZLE_MOVEMENT,
X"emacs-backward-word",emacsbackwardword,ZLE_MOVEMENT,
X"kill-word",killword,ZLE_KILL,
X"vi-kill-line",vikillline,0,
X"vi-backward-kill-word",vibackwardkillword,0,
X"expand-cmd-path",expandcmdpath,0,
X"neg-argument",negargument,ZLE_NEGARG,
X"pound-insert",poundinsert,0,
X"vi-forward-word",viforwardword,ZLE_MOVEMENT,
X"vi-backward-word",vibackwardword,ZLE_MOVEMENT,
X"",NULL,0
X};
X
Xint emacsbind[256] = {
X/* ^@ */ z_setmarkcommand,
X/* ^A */ z_beginningofline,
X/* ^B */ z_backwardchar,
X/* ^C */ z_sendbreak,
X/* ^D */ z_deletecharorlist,
X/* ^E */ z_endofline,
X/* ^F */ z_forwardchar,
X/* ^G */ z_undefinedkey,
X/* ^H */ z_backwarddeletechar,
X/* ^I */ z_expandorcomplete,
X/* ^J */ z_acceptline,
X/* ^K */ z_killline,
X/* ^L */ z_clearscreen,
X/* ^M */ z_acceptline,
X/* ^N */ z_downlineorhistory,
X/* ^O */ z_acceptlineanddownhistory,
X/* ^P */ z_uplineorhistory,
X/* ^Q */ z_pushline,
X/* ^R */ z_historyincrementalsearchbackward,
X/* ^S */ z_historyincrementalsearchforward,
X/* ^T */ z_transposechars,
X/* ^U */ z_killwholeline,
X/* ^V */ z_quotedinsert,
X/* ^W */ z_backwardkillword,
X/* ^X */ z_sequenceleadin,
X/* ^Y */ z_yank,
X/* ^Z */ z_undefinedkey,
X/* ^[ */ z_sequenceleadin,
X/* ^\ */ z_undefinedkey,
X/* ^] */ z_undefinedkey,
X/* ^^ */ z_undefinedkey,
X/* ^_ */ z_undo,
X/*   */ z_selfinsert,
X/* ! */ z_selfinsert,
X/* " */ z_selfinsert,
X/* # */ z_selfinsert,
X/* $ */ z_selfinsert,
X/* % */ z_selfinsert,
X/* & */ z_selfinsert,
X/* ' */ z_selfinsert,
X/* ( */ z_selfinsert,
X/* ) */ z_selfinsert,
X/* * */ z_selfinsert,
X/* + */ z_selfinsert,
X/* , */ z_selfinsert,
X/* - */ z_selfinsert,
X/* . */ z_selfinsert,
X/* / */ z_selfinsert,
X/* 0 */ z_selfinsert,
X/* 1 */ z_selfinsert,
X/* 2 */ z_selfinsert,
X/* 3 */ z_selfinsert,
X/* 4 */ z_selfinsert,
X/* 5 */ z_selfinsert,
X/* 6 */ z_selfinsert,
X/* 7 */ z_selfinsert,
X/* 8 */ z_selfinsert,
X/* 9 */ z_selfinsert,
X/* : */ z_selfinsert,
X/* ; */ z_selfinsert,
X/* < */ z_selfinsert,
X/* = */ z_selfinsert,
X/* > */ z_selfinsert,
X/* ? */ z_selfinsert,
X/* @ */ z_selfinsert,
X/* A */ z_selfinsert,
X/* B */ z_selfinsert,
X/* C */ z_selfinsert,
X/* D */ z_selfinsert,
X/* E */ z_selfinsert,
X/* F */ z_selfinsert,
X/* G */ z_selfinsert,
X/* H */ z_selfinsert,
X/* I */ z_selfinsert,
X/* J */ z_selfinsert,
X/* K */ z_selfinsert,
X/* L */ z_selfinsert,
X/* M */ z_selfinsert,
X/* N */ z_selfinsert,
X/* O */ z_selfinsert,
X/* P */ z_selfinsert,
X/* Q */ z_selfinsert,
X/* R */ z_selfinsert,
X/* S */ z_selfinsert,
X/* T */ z_selfinsert,
X/* U */ z_selfinsert,
X/* V */ z_selfinsert,
X/* W */ z_selfinsert,
X/* X */ z_selfinsert,
X/* Y */ z_selfinsert,
X/* Z */ z_selfinsert,
X/* [ */ z_selfinsert,
X/* \ */ z_selfinsert,
X/* ] */ z_selfinsert,
X/* ^ */ z_selfinsert,
X/* _ */ z_selfinsert,
X/* ` */ z_selfinsert,
X/* a */ z_selfinsert,
X/* b */ z_selfinsert,
X/* c */ z_selfinsert,
X/* d */ z_selfinsert,
X/* e */ z_selfinsert,
X/* f */ z_selfinsert,
X/* g */ z_selfinsert,
X/* h */ z_selfinsert,
X/* i */ z_selfinsert,
X/* j */ z_selfinsert,
X/* k */ z_selfinsert,
X/* l */ z_selfinsert,
X/* m */ z_selfinsert,
X/* n */ z_selfinsert,
X/* o */ z_selfinsert,
X/* p */ z_selfinsert,
X/* q */ z_selfinsert,
X/* r */ z_selfinsert,
X/* s */ z_selfinsert,
X/* t */ z_selfinsert,
X/* u */ z_selfinsert,
X/* v */ z_selfinsert,
X/* w */ z_selfinsert,
X/* x */ z_selfinsert,
X/* y */ z_selfinsert,
X/* z */ z_selfinsert,
X/* { */ z_selfinsert,
X/* | */ z_selfinsert,
X/* } */ z_selfinsert,
X/* ~ */ z_selfinsert,
X/* ^? */ z_backwarddeletechar,
X/* M-^@ */ z_undefinedkey,
X/* M-^A */ z_undefinedkey,
X/* M-^B */ z_undefinedkey,
X/* M-^C */ z_undefinedkey,
X/* M-^D */ z_listchoices,
X/* M-^E */ z_undefinedkey,
X/* M-^F */ z_undefinedkey,
X/* M-^G */ z_undefinedkey,
X/* M-^H */ z_backwardkillword,
X/* M-^I */ z_selfinsertunmeta,
X/* M-^J */ z_selfinsertunmeta,
X/* M-^K */ z_undefinedkey,
X/* M-^L */ z_clearscreen,
X/* M-^M */ z_selfinsertunmeta,
X/* M-^N */ z_undefinedkey,
X/* M-^O */ z_undefinedkey,
X/* M-^P */ z_undefinedkey,
X/* M-^Q */ z_undefinedkey,
X/* M-^R */ z_undefinedkey,
X/* M-^S */ z_undefinedkey,
X/* M-^T */ z_undefinedkey,
X/* M-^U */ z_undefinedkey,
X/* M-^V */ z_undefinedkey,
X/* M-^W */ z_undefinedkey,
X/* M-^X */ z_undefinedkey,
X/* M-^Y */ z_undefinedkey,
X/* M-^Z */ z_undefinedkey,
X/* M-^[ */ z_undefinedkey,
X/* M-^\ */ z_undefinedkey,
X/* M-^] */ z_undefinedkey,
X/* M-^^ */ z_undefinedkey,
X/* M-^_ */ z_copyprevword,
X/* M-  */ z_expandhistory,
X/* M-! */ z_expandhistory,
X/* M-" */ z_quoteregion,
X/* M-# */ z_undefinedkey,
X/* M-$ */ z_spellword,
X/* M-% */ z_undefinedkey,
X/* M-& */ z_undefinedkey,
X/* M-' */ z_quoteline,
X/* M-( */ z_undefinedkey,
X/* M-) */ z_undefinedkey,
X/* M-* */ z_undefinedkey,
X/* M-+ */ z_undefinedkey,
X/* M-, */ z_undefinedkey,
X/* M-- */ z_negargument,
X/* M-. */ z_insertlastword,
X/* M-/ */ z_undefinedkey,
X/* M-0 */ z_digitargument,
X/* M-1 */ z_digitargument,
X/* M-2 */ z_digitargument,
X/* M-3 */ z_digitargument,
X/* M-4 */ z_digitargument,
X/* M-5 */ z_digitargument,
X/* M-6 */ z_digitargument,
X/* M-7 */ z_digitargument,
X/* M-8 */ z_digitargument,
X/* M-9 */ z_digitargument,
X/* M-: */ z_undefinedkey,
X/* M-; */ z_undefinedkey,
X/* M-< */ z_beginningofbufferorhistory,
X/* M-= */ z_undefinedkey,
X/* M-> */ z_endofbufferorhistory,
X/* M-? */ z_whichcommand,
X/* M-@ */ z_undefinedkey,
X/* M-A */ z_acceptandhold,
X/* M-B */ z_backwardword,
X/* M-C */ z_capitalizeword,
X/* M-D */ z_deleteword,
X/* M-E */ z_undefinedkey,
X/* M-F */ z_forwardword,
X/* M-G */ z_getline,
X/* M-H */ z_runhelp,
X/* M-I */ z_undefinedkey,
X/* M-J */ z_undefinedkey,
X/* M-K */ z_undefinedkey,
X/* M-L */ z_downcaseword,
X/* M-M */ z_undefinedkey,
X/* M-N */ z_historysearchforward,
X/* M-O */ z_undefinedkey,
X/* M-P */ z_historysearchbackward,
X/* M-Q */ z_pushline,
X/* M-R */ z_toggleliteralhistory,
X/* M-S */ z_spellword,
X/* M-T */ z_transposewords,
X/* M-U */ z_upcaseword,
X/* M-V */ z_undefinedkey,
X/* M-W */ z_copyregionaskill,
X/* M-X */ z_undefinedkey,
X/* M-Y */ z_undefinedkey,
X/* M-Z */ z_undefinedkey,
X/* M-[ */ z_sequenceleadin,
X/* M-\ */ z_undefinedkey,
X/* M-] */ z_undefinedkey,
X/* M-^ */ z_undefinedkey,
X/* M-_ */ z_insertlastword,
X/* M-` */ z_undefinedkey,
X/* M-a */ z_acceptandhold,
X/* M-b */ z_backwardword,
X/* M-c */ z_capitalizeword,
X/* M-d */ z_deleteword,
X/* M-e */ z_undefinedkey,
X/* M-f */ z_forwardword,
X/* M-g */ z_getline,
X/* M-h */ z_runhelp,
X/* M-i */ z_undefinedkey,
X/* M-j */ z_undefinedkey,
X/* M-k */ z_undefinedkey,
X/* M-l */ z_downcaseword,
X/* M-m */ z_undefinedkey,
X/* M-n */ z_historysearchforward,
X/* M-o */ z_undefinedkey,
X/* M-p */ z_historysearchbackward,
X/* M-q */ z_pushline,
X/* M-r */ z_toggleliteralhistory,
X/* M-s */ z_spellword,
X/* M-t */ z_transposewords,
X/* M-u */ z_upcaseword,
X/* M-v */ z_undefinedkey,
X/* M-w */ z_copyregionaskill,
X/* M-x */ z_executenamedcmd,
X/* M-y */ z_yankpop,
X/* M-z */ z_executelastnamedcmd,
X/* M-{ */ z_undefinedkey,
X/* M-| */ z_vigotocolumn,
X/* M-} */ z_undefinedkey,
X/* M-~ */ z_undefinedkey,
X/* M-^? */ z_backwardkillword,
X};
X
Xint viinsbind[32] = {
X/* ^@ */ z_undefinedkey,
X/* ^A */ z_selfinsert,
X/* ^B */ z_selfinsert,
X/* ^C */ z_sendbreak,
X/* ^D */ z_listchoices,
X/* ^E */ z_selfinsert,
X/* ^F */ z_selfinsert,
X/* ^G */ z_selfinsert,
X/* ^H */ z_vibackwarddeletechar,
X/* ^I */ z_expandorcomplete,
X/* ^J */ z_acceptline,
X/* ^K */ z_killline,
X/* ^L */ z_clearscreen,
X/* ^M */ z_acceptline,
X/* ^N */ z_selfinsert,
X/* ^O */ z_selfinsert,
X/* ^P */ z_selfinsert,
X/* ^Q */ z_selfinsert,
X/* ^R */ z_redisplay,
X/* ^S */ z_selfinsert,
X/* ^T */ z_selfinsert,
X/* ^U */ z_vikillline,
X/* ^V */ z_quotedinsert,
X/* ^W */ z_vibackwardkillword,
X/* ^X */ z_selfinsert,
X/* ^Y */ z_selfinsert,
X/* ^Z */ z_selfinsert,
X/* ^[ */ z_vicmdmode,
X/* ^\ */ z_selfinsert,
X/* ^] */ z_selfinsert,
X/* ^^ */ z_selfinsert,
X/* ^_ */ z_selfinsert,
X};
X
Xint vicmdbind[128] = {
X/* ^@ */ z_undefinedkey,
X/* ^A */ z_beginningofline,
X/* ^B */ z_undefinedkey,
X/* ^C */ z_sendbreak,
X/* ^D */ z_listchoices,
X/* ^E */ z_endofline,
X/* ^F */ z_undefinedkey,
X/* ^G */ z_listexpand,
X/* ^H */ z_backwarddeletechar,
X/* ^I */ z_completeword,
X/* ^J */ z_acceptline,
X/* ^K */ z_killline,
X/* ^L */ z_clearscreen,
X/* ^M */ z_acceptline,
X/* ^N */ z_downhistory,
X/* ^O */ z_undefinedkey,
X/* ^P */ z_uphistory,
X/* ^Q */ z_undefinedkey,
X/* ^R */ z_redisplay,
X/* ^S */ z_undefinedkey,
X/* ^T */ z_undefinedkey,
X/* ^U */ z_killbuffer,
X/* ^V */ z_undefinedkey,
X/* ^W */ z_backwardkillword,
X/* ^X */ z_expandorcomplete,
X/* ^Y */ z_undefinedkey,
X/* ^Z */ z_undefinedkey,
X/* ^[ */ z_sequenceleadin,
X/* ^\ */ z_undefinedkey,
X/* ^] */ z_undefinedkey,
X/* ^^ */ z_undefinedkey,
X/* ^_ */ z_undefinedkey,
X/*   */ z_viforwardchar,
X/* ! */ z_undefinedkey,
X/* " */ z_visetbuffer,
X/* # */ z_poundinsert,
X/* $ */ z_viendofline,
X/* % */ z_vimatchbracket,
X/* & */ z_undefinedkey,
X/* ' */ z_vigotomarkline,
X/* ( */ z_undefinedkey,
X/* ) */ z_undefinedkey,
X/* * */ z_undefinedkey,
X/* + */ z_downlineorhistory,
X/* , */ z_virevrepeatfind,
X/* - */ z_uplineorhistory,
X/* . */ z_virepeatchange,
X/* / */ z_vihistorysearchbackward,
X/* 0 */ z_vidigitorbeginningofline,
X/* 1 */ z_digitargument,
X/* 2 */ z_digitargument,
X/* 3 */ z_digitargument,
X/* 4 */ z_digitargument,
X/* 5 */ z_digitargument,
X/* 6 */ z_digitargument,
X/* 7 */ z_digitargument,
X/* 8 */ z_digitargument,
X/* 9 */ z_digitargument,
X/* : */ z_undefinedkey,
X/* ; */ z_virepeatfind,
X/* < */ z_viunindent,
X/* = */ z_listchoices,
X/* > */ z_viindent,
X/* ? */ z_vihistorysearchforward,
X/* @ */ z_undefinedkey,
X/* A */ z_viaddeol,
X/* B */ z_vibackwardblankword,
X/* C */ z_vichangeeol,
X/* D */ z_killline,
X/* E */ z_viforwardblankwordend,
X/* F */ z_vifindprevchar,
X/* G */ z_vifetchhistory,
X/* H */ z_vicapslockpanic,
X/* I */ z_viinsertbol,
X/* J */ z_historysearchforward,
X/* K */ z_historysearchbackward,
X/* L */ z_undefinedkey,
X/* M */ z_undefinedkey,
X/* N */ z_virevrepeatsearch,
X/* O */ z_viopenlineabove,
X/* P */ z_yank,
X/* Q */ z_undefinedkey,
X/* R */ z_vireplace,
X/* S */ z_vichangewholeline,
X/* T */ z_vifindprevcharskip,
X/* U */ z_undefinedkey,
X/* V */ z_undefinedkey,
X/* W */ z_viforwardblankword,
X/* X */ z_vibackwarddeletechar,
X/* Y */ z_viyankeol,
X/* Z */ z_undefinedkey,
X/* [ */ z_undefinedkey,
X/* \ */ z_completeword,
X/* ] */ z_undefinedkey,
X/* ^ */ z_vifirstnonblank,
X/* _ */ z_undefinedkey,
X/* ` */ z_vigotomark,
X/* a */ z_viaddnext,
X/* b */ z_vibackwardword,
X/* c */ z_vichange,
X/* d */ z_videlete,
X/* e */ z_viforwardwordend,
X/* f */ z_vifindnextchar,
X/* g */ z_undefinedkey,
X/* h */ z_vibackwardchar,
X/* i */ z_viinsert,
X/* j */ z_downlineorhistory,
X/* k */ z_uplineorhistory,
X/* l */ z_viforwardchar,
X/* m */ z_visetmark,
X/* n */ z_virepeatsearch,
X/* o */ z_viopenlinebelow,
X/* p */ z_viputafter,
X/* q */ z_undefinedkey,
X/* r */ z_vireplacechars,
X/* s */ z_visubstitute,
X/* t */ z_vifindnextcharskip,
X/* u */ z_viundochange,
X/* v */ z_undefinedkey,
X/* w */ z_viforwardword,
X/* x */ z_videletechar,
X/* y */ z_viyank,
X/* z */ z_undefinedkey,
X/* { */ z_undefinedkey,
X/* | */ z_vigotocolumn,
X/* } */ z_undefinedkey,
X/* ~ */ z_viswapcase,
X/* ^? */ z_backwarddeletechar,
X};
X
SHAR_EOF
chmod 0644 zsh2.2/src/zle_bindings.c ||
echo 'restore of zsh2.2/src/zle_bindings.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_bindings.c'`"
test 17212 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_bindings.c: original size 17212, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_main.c ==============
if test -f 'zsh2.2/src/zle_main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_main.c' &&
X/*
X *
X * zle_main.c - main routines for line editor
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLEGLOBALS
X#define ZLE
X#include "zsh.h"
X#include <sys/types.h>
X#include <sys/errno.h>
X#ifdef HAS_SYS_SELECT
X#include <sys/select.h>
X#endif
X
Xstatic Key cky;
X
X/* set up terminal */
X
Xvoid setterm() /**/
X{
Xstruct ttyinfo ti;
X#ifdef FIONREAD
Xlong val;
X#endif
X
X#ifdef CLOBBERS_TYPEAHEAD
X#ifdef FIONREAD
X	ioctl(SHTTY, FIONREAD, &val);
X	if (val) return;
X#endif
X#endif
X	inittty();
X	ti = shttyinfo;
X#ifdef TIO
X	ti.tio.c_lflag &= ~(ICANON|ECHO
X#ifdef FLUSHO
X		|FLUSHO
X#endif
X		);
X	ti.tio.c_cc[VQUIT] =
X#ifdef VDISCARD
X		ti.tio.c_cc[VDISCARD] = 
X#endif
X#ifdef VSUSP
X		ti.tio.c_cc[VSUSP] =
X#endif
X#ifdef VDSUSP
X		ti.tio.c_cc[VDSUSP] =
X#endif
X#ifdef VSWTCH
X		ti.tio.c_cc[VSWTCH] =
X#endif
X		VDISABLEVAL;
X	ti.tio.c_cc[VMIN] = 1;
X	ti.tio.c_cc[VTIME] = 0;
X	ti.tio.c_iflag &= ~(INLCR|ICRNL);
X#else
X	ti.sgttyb.sg_flags = (ti.sgttyb.sg_flags | CBREAK) & ~ECHO;
X	ti.lmodes &= ~LFLUSHO;
X	ti.tchars.t_quitc =
X		ti.ltchars.t_suspc =
X		ti.ltchars.t_flushc =
X		ti.ltchars.t_dsuspc = ti.ltchars.t_lnextc = -1;
X#endif
X#ifdef TTY_NEEDS_DRAINING
X	drainoutput();
X#endif
X	settyinfo(&ti);
X}
X
Xvoid unsetterm() /**/
X{
X	settyinfo(&shttyinfo);
X}
X
Xstatic char *kungetbuf;
Xstatic int kungetct,kungetsz;
X
Xvoid ungetkey(ch) /**/
Xint ch;
X{
X	if (kungetct == kungetsz)
X		kungetbuf = realloc(kungetbuf,kungetsz *= 2);
X	kungetbuf[kungetct++] = ch;
X}
X
Xvoid ungetkeys(s,len) /**/
Xchar *s;int len;
X{
X	s += len;
X	while (len--)
X		ungetkey(*--s);
X}
X
Xunsigned int getkey(tmok) /**/
Xint tmok;
X{
Xchar cc;
Xunsigned int ret = 0;
Xint die = 0;
X#ifdef HAS_SELECT
Xfd_set foofd;
X#endif
X
X	if (kungetct)
X		ret = (unsigned int) (unsigned char) kungetbuf[--kungetct];
X	else {
X		while (
X#ifdef HAS_SELECT
X		FD_SET(0,&foofd), select(1,&foofd,NULL,NULL,NULL) != 1 ||
X#endif
X		read(0,&cc,1) != 1)
X			if (errno == EINTR) {
X				if (!errflag)
X					continue;
X				errflag = 0;
X				if (tmok)
X					return -1;
X				return 3;
X			} else if (errno == EWOULDBLOCK) {
X				fcntl(0,F_SETFL,0);
X			} else if (errno == EIO && !die) {
X				ret = jobbing;
X				jobbing = 1;
X				attachtty(mypgrp);
X				refresh(); /* kludge! */
X				jobbing = ret;
X				die = 1;
X			} else {
X				zerr("error on TTY read: %e",NULL,errno);
X				exit(1);
X			}
X		ret = (unsigned int) (unsigned char) cc;
X	}
X	if (vichgflag) {
X		if (vichgbufptr == vichgbufsz)
X			vichgbuf = realloc(vichgbuf,vichgbufsz *= 2);
X		vichgbuf[vichgbufptr++] = ret;
X	}
X	return ret;
X}
X
X/* read a line */
X
Xunsigned char *zleread(ppt,ppt2,plen) /**/
Xunsigned char *ppt;unsigned char *ppt2;int plen;
X{
Xint z;
Xlong costmult;
Xunsigned char *s;
X#ifdef HAS_SELECT
Xstruct timeval tv;
Xfd_set foofd;
X
X	tv.tv_sec = 0;
X#endif
X	fflush(stdout);
X	fflush(stderr);
X	intr();
X	costmult = 3840000L/((baud) ? baud : 2400);
X	insmode = unset(OVERSTRIKE); eofsent = 0; resetneeded =0 ;
X	pmpt = (char *)ppt;
X	pmpt2 = (char *)ppt2;
X	permalloc();
X	histline = curhist;
X	pptlen = plen;
X	resetneeded = 1;
X#ifdef HAS_SELECT
X	FD_ZERO(&foofd);
X#endif
X	undoing = 1;
X	line = zalloc(linesz = 256);
X	*line = '\0';
X	virangeflag = lastcmd = done = cs = ll = mark = 0;
X	curhistline = NULL;
X	mult = 1;
X	vibufspec = 0;
X	bindtab = mainbindtab;
X	addedslash = vichgflag = 0;
X	viinsbegin = 0;
X	statusline = NULL;
X	if (s = getnode(bufstack))
X		{
X		setline((char *) s);
X		free(s);
X		if (stackcs != -1)
X			{
X			cs = stackcs;
X			stackcs = -1;
X			if (cs > ll)
X				cs = ll;
X			}
X		if (stackhist != -1)
X			{
X			histline = stackhist;
X			stackhist = -1;
X			}
X		}
X	initundo();
X	if (unset(NOPROMPTCR))
X		putchar('\r');
X	if (tmout)
X		alarm(tmout);
X	refresh();
X	errflag = 0;
X	while (!done && !errflag)
X		{
X		struct zlecmd *zc;
X		
X		statusline = NULL;
X		bindk = getkeycmd();
X		if (c == 4 && !ll)
X			{
X			eofsent = 1;
X			break;
X			}
X		if (bindk != -1)
X			{
X			zc = zlecmds+bindk;
X			if (!(lastcmd & ZLE_ARG))
X				mult = 1;
X			if ((lastcmd & ZLE_UNDO) != (zc->flags & ZLE_UNDO) && undoing)
X				addundo();
X			if (!(zc->flags & ZLE_MENUCMP)) {
X				if (menucmp) freemenu();
X				if (addedslash &&
X						!((zc->flags & ZLE_INSERT) && c != ' ')) {
X					backdel(1);
X				}
X				addedslash = 0;
X			}
X			if (zc->func)
X				(*zc->func)();
X			lastcmd = zc->flags;
X			if (!(lastcmd & ZLE_UNDO) && undoing) addundo();
X			}
X		else
X			{
X			errflag = 1;
X			break;
X			}
X#ifdef HAS_SELECT
X		FD_SET(0,&foofd);
X		if ((tv.tv_usec = cost*costmult) > 500000)
X			tv.tv_usec = 500000;
X#endif
X		if (!kungetct
X#ifdef HAS_SELECT
X			&& select(1,&foofd,NULL,NULL,&tv) <= 0
X#endif
X			)
X			refresh();
X		}
X	if (menucmp)
X		freemenu();
X	statusline = NULL;
X	trashzle();
X	alarm(0);
X	z = strlen((char *)line);
X	line[z] = '\n';
X	line[z+1] = 0;
X	heapalloc();
X	if (curhistline)
X		free(curhistline);
X	if (eofsent)
X		{
X		free(line);
X		line = NULL;
X		}
X	zleactive = 0;
X	freeundo();
X	return line;
X}
X
Xint getkeycmd() /**/
X{
Xchar buf[10];
Xint t0,ret;
XKey ky;
X
X	t0 = 1;
X	cky = NULL;
X	if ((c = getkey(1)) == -1)
X		return -1;
X	if ((ret = bindtab[c]) == z_sequenceleadin)
X		{
X		buf[0] = (c) ? c : 0x80;
X		for (;;)
X			{
X			c = getkey(0);
X			buf[t0++] = (c) ? c : 0x80;
X			buf[t0] = '\0';
X			if (!(ky = (Key) gethnode(buf,xbindtab)))
X				return z_undefinedkey;
X			if (ky->func != z_sequenceleadin)
X				{
X				cky = ky;
X				ret = ky->func;
X				break;
X				}
X			}
X		}
X	if (ret == z_vidigitorbeginningofline)
X		ret = (lastcmd & ZLE_ARG) ? z_digitargument : z_beginningofline;
X	else if (ret == z_executenamedcmd)
X		ret = executenamedcommand();
X	else if (ret == z_executelastnamedcmd)
X		ret = lastnamed;
X	return ret;
X}
X
Xvoid sendstring() /**/
X{
Xchar buf[2];
X
X	buf[0] = c;
X	buf[1] = '\0';
X	if (!cky)
X		cky = (Key) gethnode(buf,xbindtab);
X	ungetkeys(cky->str,cky->len);
X}
X
XKey makefunckey(fun) /**/
Xint fun;
X{
XKey ky = zcalloc(sizeof *ky);
X
X	ky->func = fun;
X	return ky;
X}
X
X/* initialize the bindings */
X
Xvoid initxbindtab() /**/
X{
Xint t0,vi = 0;
Xchar buf[3],*s;
X
X	lastnamed = z_undefinedkey;
X	if (s = zgetenv("VISUAL")) {
X		if (ztrstr(s,"vi"))
X			vi = 1;
X	}
X	else if ((s = zgetenv("EDITOR")) && ztrstr(s,"vi"))
X		vi = 1;
X	if (vi) {
X		for (t0 = 0; t0 != 32; t0++)
X			mainbindtab[t0] = viinsbind[t0];
X		for (t0 = 32; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X		mainbindtab[127] = z_backwarddeletechar;
X	} else {
X		for (t0 = 0; t0 != 128; t0++)
X			mainbindtab[t0] = emacsbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			mainbindtab[t0] = z_selfinsert;
X	}
X	for (t0 = 0200; t0 != 0240; t0++)
X		mainbindtab[t0] = z_undefinedkey;
X	for (t0 = 0; t0 != 128; t0++)
X		altbindtab[t0] = vicmdbind[t0];
X	for (t0 = 128; t0 != 256; t0++)
X		altbindtab[t0] = emacsbind[t0];
X	bindtab = mainbindtab;
X	kungetbuf = zalloc(kungetsz = 32);
X	kungetct = 0;
X	xbindtab = newhtable(67);
X	addhperm("\33\133C",makefunckey(z_forwardchar),xbindtab,NULL);
X	addhperm("\33\133D",makefunckey(z_backwardchar),xbindtab,NULL);
X	addhperm("\33\133A",makefunckey(z_uplineorhistory),xbindtab,NULL);
X	addhperm("\33\133B",makefunckey(z_downlineorhistory),xbindtab,NULL);
X	addhperm("\30*",makefunckey(z_expandword),xbindtab,NULL);
X	addhperm("\30g",makefunckey(z_listexpand),xbindtab,NULL);
X	addhperm("\30G",makefunckey(z_listexpand),xbindtab,NULL);
X	addhperm("\30\16",makefunckey(z_infernexthistory),xbindtab,NULL);
X	addhperm("\30\13",makefunckey(z_killbuffer),xbindtab,NULL);
X	addhperm("\30\6",makefunckey(z_vifindnextchar),xbindtab,NULL);
X	addhperm("\30\17",makefunckey(z_overwritemode),xbindtab,NULL);
X	addhperm("\30\25",makefunckey(z_undo),xbindtab,NULL);
X	addhperm("\30\26",makefunckey(z_vicmdmode),xbindtab,NULL);
X	addhperm("\30\12",makefunckey(z_vijoin),xbindtab,NULL);
X	addhperm("\30\2",makefunckey(z_vimatchbracket),xbindtab,NULL);
X	addhperm("\30s",makefunckey(z_historyincrementalsearchforward),
X		xbindtab,NULL);
X	addhperm("\30r",makefunckey(z_historyincrementalsearchbackward),
X		xbindtab,NULL);
X	addhperm("\30u",makefunckey(z_undo),xbindtab,NULL);
X	addhperm("\30\30",makefunckey(z_exchangepointandmark),
X		xbindtab,NULL);
X	addhperm("run-help",mkanode(ztrdup("man"),1),aliastab,NULL);
X	addhperm("which-command",mkanode(ztrdup("whence"),1),aliastab,NULL);
X	strcpy(buf,"\33q");
X	for (t0 = 128; t0 != 256; t0++)
X		if (emacsbind[t0] != z_undefinedkey) {
X			buf[1] = t0 & 0x7f;
X			addhnode(ztrdup(buf),makefunckey(emacsbind[t0]),xbindtab,NULL);
X		}
X	for (t0 = 0; t0 != 36; t0++) vibuf[t0] = NULL;
X	for (t0 = 0; t0 != 26; t0++) vimarkline[t0] = 0;
X	stackhist = stackcs = -1;
X	vichgbufsz = 0;
X	vichgbuf = NULL;
X}
X
Xchar *getkeystring(s,len) /**/
Xchar *s;int *len;
X{
Xstatic char buf[512];
Xchar *t = buf;
Xint x,first = 1,metanext = 0;
X
X	for (;*s;s++)
X		{
X		if (*s == '\\' && s[1])
X			switch(*++s)
X				{
X				case 'a': *t++ = '\07'; break;
X				case 'n': *t++ = '\n'; break;
X				case 'b': *t++ = '\010'; break;
X				case 't': *t++ = '\t'; break;
X				case 'v': *t++ = '\v'; break;
X				case 'f': *t++ = '\f'; break;
X				case 'r': *t++ = '\r'; break;
X				case 'e': *t++ = '\033'; break;
X				case 'M':
X					if (s[1] == '-')
X						s++;
X					metanext = 2;
X					break;
X				default:
X					if (idigit(*s))
X						{
X						for (x = 0; idigit(*s); s++)
X							x = x*8+(*s-'0');
X						s--;
X						*t++ = x;
X						}
X					else
X						*t++ = *s;
X					break;
X				}
X		else if (*s == '^')
X			if (*++s == '?')
X				*t++ = 0x7f;
X			else
X				*t++ = *s & 0x9f;
X		else
X			*t++ = *s;
X		if (metanext && !(--metanext))
X			{
X			t[-1] |= 0x80;
X			metanext = 0;
X			}
X		if (t > buf+500)
X			break;
X		first = 0;
X		}
X	*t = '\0';
X	*len = t-buf;
X	return buf;
X}
X
Xvoid printbind(s,len) /**/
Xchar *s;int len;
X{
Xint ch;
X
X	while (len--)
X		{
X		ch = (unsigned char) *s++;
X		if (ch & 0x80)
X			{
X			printf("\\M-");
X			ch &= 0x7f;
X			}
X		if (icntrl(ch))
X			switch(ch)
X				{
X				case 0x7f: printf("^?"); break;
X				default: printf("^%c",(ch|0x40)); break;
X				}
X		else
X			putchar(ch);
X		}
X}
X
Xvoid printbinding(str,k) /**/
Xchar *str;Key k;
X{
X	if (k->func == z_sequenceleadin)
X		return;
X	putchar('\"');
X	printbind(str,strlen(str));
X	printf("\"\t");
X	if (k->func == z_sendstring)
X		{
X		putchar('\"');
X		printbind(k->str,k->len);
X		printf("\"\n");
X		}
X	else
X		printf("%s\n",zlecmds[k->func].name);
X}
X
Xint bin_bindkey(name,argv,ops,junc) /**/
Xchar *name;char **argv;char *ops;int junc;
X{
Xint t0,len;
Xchar *s;
Xint func,*tab;
X
X	tab = (ops['a']) ? altbindtab : mainbindtab;
X	if (ops['v'] || ops['e'] || ops['d'])
X		{
X		if (*argv)
X			{
X			zerrnam(name,"too many arguments",NULL,0);
X			return 1;
X			}
X		if (ops['d'] || ops['e'])
X			if (ops['m'])
X				for (t0 = 0; t0 != 256; t0++)
X					tab[t0] = emacsbind[t0];
X			else
X				{
X				for (t0 = 0; t0 != 128; t0++)
X					tab[t0] = emacsbind[t0];
X				for (t0 = 128; t0 != 256; t0++)
X					tab[t0] = z_selfinsert;
X				}
X		else
X			{
X			for (t0 = 0; t0 != 32; t0++)
X				mainbindtab[t0] = viinsbind[t0];
X			for (t0 = 32; t0 != 256; t0++)
X				mainbindtab[t0] = z_selfinsert;
X			mainbindtab[127] = z_backwarddeletechar;
X			}
X		for (t0 = 0; t0 != 128; t0++)
X			altbindtab[t0] = vicmdbind[t0];
X		for (t0 = 128; t0 != 256; t0++)
X			altbindtab[t0] = emacsbind[t0];
X		for (t0 = 0200; t0 != 0240; t0++)
X			tab[t0] = z_undefinedkey;
X		return 0;
X		}
X	if (!*argv)
X		{
X		char buf[2];
X		
X		buf[0] = 'x'; buf[1] = '\0';
X		for (t0 = 0; t0 != 256; t0++)
X			{
X			buf[0] = t0;
X			putchar('\"');
X			printbind(buf,1);
X			if (t0 < 254 && tab[t0] == tab[t0+1] && tab[t0] == tab[t0+2])
X				{
X				printf("\" to \"");
X				while (tab[t0] == tab[t0+1]) t0++;
X				buf[0] = t0;
X				printbind(buf,1);
X				}
X			printf("\"\t%s\n",zlecmds[tab[t0]].name);
X			}
X		listhtable(xbindtab,(HFunc) printbinding);
X		return 0;
X		}
X	while (*argv)
X		{
X		s = getkeystring(*argv++,&len);
X		if (len > 8)
X			{
X			zerrnam(name,"in-string too long",NULL,0);
X			return 1;
X			}
X		if (!*argv || ops['r'])
X			{
X			Key ky;
X
X			ky = gethnode(s,xbindtab);
X			if (len == 1)
X				func = tab[(unsigned char) *s];
X			else
X				func = (ky) ? ky->func : z_undefinedkey;
X			if (func == z_undefinedkey)
X				{
X				zerrnam(name,"in-string is not bound",NULL,0);
X				return 1;
X				}
X			if (ops['r'])
X				{
X				if (len == 1)
X					tab[(unsigned char) *s] = z_undefinedkey;
X				else
X					{
X					while (strlen(s) > 1)
X						{
X						free(remhnode(s,xbindtab));
X						s[strlen(s)-1] = '\0';
X						}
X					}
X				continue;
X				}
X			if (func == z_sendstring)
X				{
X				printbind(ky->str,ky->len);
X				putchar('\n');
X				return 0;
X				}
X			printf("%s\n",zlecmds[func].name);
X			return 0;
X			}
X		if (!ops['s'])
X			{
X			for (t0 = 0; t0 != ZLECMDCOUNT; t0++)
X				if (!strcmp(*argv,zlecmds[t0].name))
X					break;
X			if (t0 == ZLECMDCOUNT)
X				{
X				zerr("undefined function: %s",*argv,0);
X				return 1;
X				}
X			func = t0;
X			}
X		else
X			func = z_sendstring;
X		if (len == 1)
X			{
X			Key ky;
X
X			tab[(unsigned char) *s] = (ops['s']) ? z_sendstring : t0;
X			if (ops['s'])
X				{
X				addhnode(ztrdup(s),ky = makefunckey(z_sendstring),xbindtab,freekey);
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X				}
X			}
X		else
X			{
X			int t1;
X			Key ky;
X
X			if (tab[(unsigned char) *s] != z_undefinedkey &&
X					tab[(unsigned char) *s] != z_sequenceleadin)
X				{
X				zerrnam(name,"in-string has already bound prefix",NULL,0);
X				return 1;
X				}
X			tab[(unsigned char) *s] = z_sequenceleadin;
X			if (!s[1])
X				s[1] = 0x80;
X			for (t1 = 1; t1 != len-1; t1++)
X				{
X				char sav;
X
X				sav = s[t1+1];
X				s[t1+1] = '\0';
X				ky = gethnode(s,xbindtab);
X				if (ky && ky->func != z_sequenceleadin)
X					{
X					zerrnam(name,"in-string has already bound prefix",NULL,0);
X					return 1;
X					}
X				if (!ky)
X					addhnode(ztrdup(s),makefunckey(z_sequenceleadin),xbindtab,
X						freekey);
X				if (!sav)
X					sav = 0x80;
X				s[t1+1] = sav;
X				}
X			addhnode(ztrdup(s),ky = makefunckey(func),xbindtab,freekey);
X			if (ops['s'])
X				ky->str = ztrdup(getkeystring(*argv,&ky->len));
X			}
X		argv++;
X		}
X	return 0;
X}
X
Xvoid freekey(x) /**/
Xvptr x;
X{
XKey k = x;
X
X	if (k->str)
X		free(k->str);
X	free(k);
X}
X
X/* this is mostly stolen from bash's draino() */
X
Xvoid drainoutput() /**/
X{
Xint n = 0;
X
X	if (!baud) return;
X#ifdef TIOCOUTQ
X#ifdef HAS_SELECT
X	while ((ioctl(SHTTY,TIOCOUTQ,&n) >= 0) && n) {
X		struct timeval tv;
X		tv.tv_sec = n/baud;
X		tv.tv_usec = ((n%baud)*1000000)/baud;
X		select (0,(fd_set *)0,(fd_set *)0,(fd_set *)0,&tv);
X	}
X#endif
X#endif
X}
X
SHAR_EOF
chmod 0644 zsh2.2/src/zle_main.c ||
echo 'restore of zsh2.2/src/zle_main.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_main.c'`"
test 14597 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_main.c: original size 14597, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_refresh.c ==============
if test -f 'zsh2.2/src/zle_refresh.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_refresh.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_refresh.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_refresh.c' &&
X/*
X *
X * zle_refresh.c - screen update
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
Xchar **obuf = NULL,**nbuf = NULL;
Xint olnct,nlnct;
Xint winw,winh,winpos;
X
Xint vcs,vln,vmaxln;
X
Xvoid resetvideo() /**/
X{
Xint ln;
Xstatic int lwinw = -1,lwinh = -1;
X
X	setterm();
X	winw = columns-1;
X	if (isset(SINGLELINEZLE) || !termok)
X		winh = 1;
X	else
X		winh = (lines < 2) ? 24 : lines;
X	winpos = vln = vmaxln = 0;
X	if (lwinw != winw || lwinh != winh)
X		{
X		if (nbuf)
X			{
X			for (ln = 0; ln != lwinh; ln++)
X				{
X				free(nbuf[ln]);
X				free(obuf[ln]);
X				}
X			free(nbuf);
X			free(obuf);
X			}
X		nbuf = (char **) zalloc((winh+1)*sizeof(char *));
X		obuf = (char **) zalloc((winh+1)*sizeof(char *));
X		for (ln = 0; ln != winh+1; ln++)
X			{
X			nbuf[ln] = zalloc(winw+1);
X			obuf[ln] = zalloc(winw+1);
X			}
X		lwinw = winw;
X		lwinh = winh;
X		}
X	for (ln = 0; ln != winh+1; ln++)
X		{
X		*nbuf[ln] = '\0';
X		*obuf[ln] = '\0';
X		}
X	if (!pptlen)
X		nbuf[0][0] = obuf[0][0] = '\0';
X	else
X		{
X		for (ln = 0; ln != pptlen-1; ln++)
X			nbuf[0][ln] = obuf[0][ln] = ' ';
X		nbuf[0][ln] = obuf[0][ln] = '>';
X		nbuf[0][pptlen] = obuf[0][pptlen] = '\0';
X		}
X	vcs = pptlen;
X	olnct = nlnct = 1;
X}
X
Xint scrollwindow() /**/
X{
Xint t0,hwinh = winh/2;
X
X	for (t0 = 0; t0 != winh-hwinh; t0++)
X		{
X		char *s;
X
X		s = nbuf[t0];
X		nbuf[t0] = nbuf[t0+hwinh];
X		nbuf[t0+hwinh] = s;
X		}
X	for (t0 = 0; t0 != pptlen-1; t0++)
X		nbuf[0][t0] = ' ';
X	strcpy(nbuf[0]+t0,"> ...");
X	return winh-hwinh;
X}
X
X/* this is the messy part. */
X/* this define belongs where it's used!!! */
X
X#define nextline { *s = (unsigned char)'\0'; \
X	if (winh == ln+1) if (nvln != -1) break; else ln = scrollwindow()-1; \
X	s = (unsigned char *)nbuf[++ln]; sen = s+winw; \
X	}
X
Xvoid refresh() /**/
X{
Xunsigned char *s,*t,*sen,*scs = line+cs; char **qbuf;
Xint ln = 0,nvcs,nvln = -1,t0;
X
X	cost = 0;
X	if (resetneeded)
X		{
X		resetvideo();
X		resetneeded = 0;
X		if (isset(SINGLELINEZLE) || !termok)
X			vcs = 0;
X		else
X			printf("%s",pmpt);
X		}
X	zleactive = 1;
X	if (isset(SINGLELINEZLE) || !termok)
X		{
X		singlerefresh();
X		return;
X		}
X
X/* first, we generate the video line buffers so we know what to
X	put on the screen. 
X
X	s = ptr into the video buffer.
X	t = ptr into the real buffer.
X	sen = end of the video buffer (eol)
X*/
X
X	s = (unsigned char *)(nbuf[ln = 0]+pptlen);
X	t = line;
X	sen = (unsigned char *)(*nbuf+winw);
X	for (; *t; t++)
X		{
X		if (icntrl((char)*t))
X			if (*t == '\n')
X				{
X				if (t == scs)
X					{
X					nvcs = (char *)s-nbuf[nvln = ln];
X					scs = (unsigned char *)NULL;
X					}
X				nextline
X				}
X			else if ((char)*t == '\t')
X				{
X				int t1 = (char *)s-nbuf[ln];
X
X				if ((t1|7)+1 >= winw) nextline
X				else
X					do
X						*s++ = ' ';
X					while ((++t1) & 7);
X				}
X			else
X				{
X				if (s == sen) nextline
X				*s++ = '^';
X				if (s == sen) nextline
X				*s++ = (*t == 127) ? '?' : (*t | '@');
X				}
X		else
X			{
X			if (s == sen) nextline
X			*s++ = *t;
X			}
X/* if the cursor is here, remember it */
X
X		if (t == scs)
X			nvcs = s-(unsigned char *)nbuf[nvln = ln]-1;
X		}
X	if (scs == t)
X		nvcs = s-(unsigned char *)nbuf[nvln = ln];
X	*s = '\0';
X	nlnct = ln+1;
X	if (statusline)
X		strcpy(nbuf[(nlnct == winh) ? winh-1 : nlnct++],statusline);
X
X/* do RPROMPT */
X
X	if (pmpt2 && ln == 0 && strlen(nbuf[0])+strlen(pmpt2) < winw)
X		{
X		for (t0 = strlen(nbuf[0]); t0 != winw; t0++)
X			nbuf[0][t0] = ' ';
X		strcpy(nbuf[0]+winw-strlen(pmpt2),pmpt2);
X		}
X	for (ln = 0; ln < nlnct; ln++)
X		{
X
X/* if old line and new line are different,
X	see if we can insert/delete a line */
X
X		if (ln < olnct && strncmp(nbuf[ln],obuf[ln],16))
X			{
X			if (tccan(TCDELLINE) && !strncmp(nbuf[ln],obuf[ln+1],16)
X					&& obuf[ln+1][0] && ln != olnct)
X				{
X				int t0;
X
X				moveto(ln,0);
X				tcout(TCDELLINE);
X				for (t0 = ln; t0 != olnct; t0++)
X					strcpy(obuf[t0],obuf[t0+1]);
X				olnct--;
X				}
X
X/* don't try to insert a line if olnct < vmaxln (vmaxln is the number
X	of lines that have been displayed by this routine) so that we don't
X	go off the end of the screen. */
X
X			else if (tccan(TCINSLINE) && !strncmp(nbuf[ln+1],obuf[ln],16) &&
X					olnct < vmaxln && nbuf[ln+1][0] && ln != olnct)
X				{
X				int t0;
X
X				moveto(ln,0);
X				tcout(TCINSLINE);
X				for (t0 = olnct; t0 != ln; t0--)
X					strcpy(obuf[t0],obuf[t0-1]);
X				*obuf[ln] = '\0';
X				olnct++;
X				}
X			}
X		refreshline(ln);
X		}
X
X/* if old buffer had extra lines, do a clear-end-of-display if we can,
X	otherwise, just fill new buffer with blank lines and refresh them */
X
X	if (olnct > nlnct)
X		{
X		for (ln = nlnct; ln < olnct; ln++)
X			nbuf[ln][0] = '\0';
X		if (tccan(TCCLEAREOD))
X			{
X			moveto(nlnct,0);
X			tcout(TCCLEAREOD);
X			}
X		else
X			for (ln = nlnct; ln < olnct; ln++)
X				refreshline(ln);
X		}
X
X/* move to the new cursor position */
X
X	moveto(nvln,nvcs);
X	qbuf = nbuf;
X	nbuf = obuf;
X	obuf = qbuf;
X	olnct = nlnct;
X	if (nlnct > vmaxln)
X		vmaxln = nlnct;
X	fflush(stdout);
X}
X
X#define tcinscost(X) (tccan(TCMULTINS) ? tclen[TCMULTINS] : (X)*tclen[TCINS])
X#define tcdelcost(X) (tccan(TCMULTDEL) ? tclen[TCMULTDEL] : (X)*tclen[TCDEL])
X#define tc_delchars(X) tcmultout(TCDEL,TCMULTDEL,(X))
X#define tc_inschars(X) tcmultout(TCINS,TCMULTINS,(X))
X#define tc_upcurs(X) tcmultout(TCUP,TCMULTUP,(X))
X#define tc_leftcurs(X) tcmultout(TCLEFT,TCMULTLEFT,(X))
X
Xvoid refreshline(ln) /**/
Xint ln;
X{
Xchar *nl = nbuf[ln],*ol = obuf[ln];
Xchar *p1;
Xchar junk,*truncptr = &junk;
Xint ccs = 0;
X
X	if (ln >= olnct)
X		*ol = '\0';
X	for (;;)
X		{
X		while (*nl && *nl == *ol)
X			{
X			nl++,ol++,ccs++;
X			}
X		if (!*nl && !*ol)
X			{ *truncptr = '\0'; return; }
X
X/* if this is the end of the new buffer but the old buffer has stuff
X	here, clear to end of line if we can, otherwise fill the new buffer
X	with blanks and continue. */
X
X		if (!*nl)
X			{
X			if (tccan(TCCLEAREOL) && strlen(ol) > tclen[TCCLEAREOL])
X				{
X				moveto(ln,ccs);
X				tcout(TCCLEAREOL);
X				*ol = '\0';
X				*truncptr = '\0';
X				return;
X				}
X			else
X				{
X				int x = strlen(ol);
X				char *p = nl;
X
X				truncptr = p;
X				while (x--)
X					*p++ = ' ';
X				*p = '\0';
X				continue;
X				}
X			}
X
X/* if this is the end of the old buffer, just dump the rest of the
X	new buffer. */
X
X		if (!*ol)
X			{
X			while (*nl == ' ')
X				nl++,ccs++;
X			if (*nl)
X				{
X				moveto(ln,ccs);
X				fwrite(nl,strlen(nl),1,stdout);
X				cost += strlen(nl);
X				ccs = (vcs += strlen(nl));
X				}
X			*truncptr = 0;
X			return;
X			}
X		moveto(ln,ccs);
X
X/* try to insert/delete characters */
X
X		if (ol[1] != nl[1] && tccan(TCDEL))
X			{
X			int ct = 0;
X
X			for (p1 = ol; *p1; p1++,ct++)
X				if (tcdelcost(ct) < streqct(p1,nl))
X					{
X					tc_delchars(ct);
X					ol = p1;
X					break;
X					}
X			if (*p1)
X				continue;
X			}
X
X		if (ol[1] != nl[1] && tccan(TCINS))
X			{
X			int ct = 0;
X
X			for (p1 = nl; *p1; p1++,ct++)
X				if (tcinscost(ct) < streqct(p1,ol)+ct)
X					{
X#if 0
X/* make sure we aren't inserting characters off the end of the screen;
X	if we are, jump to the end and truncate the line, if we can do
X	it quickly (gee, clever idea, Paul!) */
X					if (ct+ccs+strlen(ol) >= winw-1)
X						{
X						if (!tccan(TCMULTRIGHT) || ccs > winw-tclen[TCMULTRIGHT])
X							continue;
X						moveto(ln,winw-1-ct);
X						if (!tccan(TCCLEAREOL) || ct < tclen[TCCLEAREOL])
X							{
X							int x = ct;
X
X							while (vcs++,x--)
X								putchar(' ');
X							}
X						else
X							tcout(TCCLEAREOL);
X						moveto(ln,ccs);
X						}
X#endif
X					if (ct+ccs+strlen(ol) < winw-1)
X						{
X						tc_inschars(ct = p1-nl);
X						ccs = (vcs += p1-nl);
X						cost += ct;
X						fwrite(nl,ct,1,stdout);
X						nl += ct;
X						break;
X						}
X					}
X			if (*p1)
X				continue;
X			}
X
X/* if we can't do anything fancy, just write the new character and
X	keep going. */
X
X		putchar(*nl);
X		cost++;
X		nl++,ol++,ccs = ++vcs;
X		}
X}
X
Xvoid moveto(ln,cl) /**/
Xint ln;int cl;
X{
X
X/* move up */
X
X	if (ln < vln)
X		{
X		tc_upcurs(vln-ln);
X		vln = ln;
X		}
X
X/* move down; if we might go off the end of the screen, use newlines
X	instead of TCDOWN */
X
X	while (ln > vln)
X		if (cl < (vcs/2) || ln >= vmaxln || !tccan(TCLEFT))
X			{
X			putchar('\r');
X			putchar('\n');
X			cost+=2;
X			vln++;
X			vcs = 0;
X			}
X		else
X			{
X			tc_downcurs(ln-vln);
X			vln = ln;
X			}
X	if (cl < (vcs/2) || !tccan(TCLEFT))
X		{
X		putchar('\r');
X		cost++;
X		vcs = 0;
X		}
X	if (vcs < cl)
X		tc_rightcurs(cl-vcs);
X	else if (vcs > cl)
X		tc_leftcurs(vcs-cl);
X	vcs = cl;
X}
X
Xvoid tcmultout(cap,multcap,ct) /**/
Xint cap;int multcap;int ct;
X{
X	if (tccan(multcap) && (!tccan(cap) || tclen[multcap] < tclen[cap]*ct))
X		tcoutarg(multcap,ct);
X	else while (ct--)
X		tcout(cap);
X}
X
Xvoid tc_rightcurs(ct) /**/
Xint ct;
X{
X
X/* do a multright if it's cheaper or if we're walking over the prompt.  */
X
X	if (tccan(TCMULTRIGHT) &&
X			(ct > tclen[TCMULTRIGHT] || vln == 0 && vcs < pptlen))
X		tcoutarg(TCMULTRIGHT,ct);
X
X/* if we're walking over the prompt and we can do a bunch of cursor rights,
X	do them, even though they're more expensive.  (We can't redraw the
X	prompt very easily in general.)  */
X
X	else if (vln == 0 && vcs < pptlen && tccan(TCRIGHT))
X		while (ct--)
X			tcout(TCRIGHT);
X
X/* otherwise write the contents of the video buffer. */
X
X	else
X		fwrite(nbuf[vln]+vcs,ct,1,stdout);
X}
X
Xvoid tc_downcurs(ct) /**/
Xint ct;
X{
X	if (tccan(TCMULTDOWN) &&
X			(!tccan(TCDOWN) || tclen[TCMULTDOWN] < tclen[TCDOWN]*ct))
X		tcoutarg(TCMULTDOWN,ct);
X	else if (tccan(TCDOWN))
X		while (ct--)
X			tcout(TCDOWN);
X	else
X		{
X		while (ct--)
X			putchar('\n');
X		vcs = 0;
X		}
X}
X
X/* I'm NOT going to worry about padding unless anyone complains. */
X
Xvoid tcout(cap) /**/
Xint cap;
X{
X	tputs(tcstr[cap],1,putraw);
X}
X
Xvoid tcoutarg(cap,arg) /**/
Xint cap;int arg;
X{
X	tputs(tgoto(tcstr[cap],arg,arg),1,putraw);
X}
X
Xvoid clearscreen() /**/
X{
X	tcout(TCCLEARSCREEN);
X	resetneeded = 1;
X}
X
Xvoid redisplay() /**/
X{
X	trashzle();
X}
X
Xvoid trashzle() /**/
X{
X	if (zleactive)
X		{
X		refresh();
X		moveto(nlnct,0);
X		printf("%s",postedit);
X		fflush(stdout);
X		unsetterm();
X		resetneeded = 1;
X		}
X}
X
Xvoid singlerefresh() /**/
X{
Xchar *vbuf,*vp,**qbuf,*op;
Xint t0,vsiz,nvcs;
X
X	for (vsiz = 1+pptlen, t0 = 0; t0 != ll; t0++,vsiz++)
X		if (line[t0] == '\t')
X			vsiz += 7;
X		else if (icntrl(line[t0]))
X			vsiz++;
X	vbuf = zalloc(vsiz);
X	strcpy(vbuf,pmpt);
X	vp = vbuf+pptlen;
X	for (t0 = 0; t0 != ll; t0++)
X		{
X		if (line[t0] == '\t')
X			do
X				*vp++ = ' ';
X			while ((vp-vbuf) & 7);
X		else if (line[t0] == '\n')
X			{
X			*vp++ = '\\';
X			*vp++ = 'n';
X			}
X		else if (line[t0] == 0x7f)
X			{
X			*vp++ = '^';
X			*vp++ = '?';
X			}
X		else if (icntrl(line[t0]))
X			{
X			*vp++ = '^';
X			*vp++ = line[t0] | '@';
X			}
X		else
X			*vp++ = line[t0];
X		if (t0 == cs)
X			nvcs = vp-vbuf-1;
X		}
X	if (t0 == cs)
X		nvcs = vp-vbuf;
X	*vp = '\0';
X	if ((winpos && nvcs < winpos+1) || (nvcs > winpos+winw-1))
X		{
X		if ((winpos = nvcs-(winw/2)) < 0)
X			winpos = 0;
X		}
X	if (winpos)
X		vbuf[winpos] = '<';
X	if (strlen(vbuf+winpos) > winw)
X		{
X		vbuf[winpos+winw-1] = '>';
X		vbuf[winpos+winw] = '\0';
X		}
X	strcpy(nbuf[0],vbuf+winpos);
X	free(vbuf);
X	nvcs -= winpos;
X	for (t0 = 0,vp = *nbuf,op = *obuf; *vp; t0++,vp++)
X		{
X		if (*vp != *op && !(*vp == ' ' && !*op))
X			{
X			singmoveto(t0);
X			putchar(*vp);
X			vcs++;
X			}
X		if (*op)
X			op++;
X		}
X	if (*op)
X		{
X		singmoveto(t0);
X		for (; *op; op++)
X			{
X			putchar(' ');
X			vcs++;
X			}
X		}
X	singmoveto(nvcs);
X	qbuf = nbuf;
X	nbuf = obuf;
X	obuf = qbuf;
X	fflush(stdout);
X}
X
Xvoid singmoveto(pos) /**/
Xint pos;
X{
X	while (pos < vcs)
X		{
X		vcs--;
X		putchar('\b');
X		}
X	while (pos > vcs)
X		{
X		putchar(nbuf[0][vcs]);
X		vcs++;
X		}
X}
X
Xint streqct(s,t) /**/
Xchar *s;char *t;
X{
Xint ct = 0;
X
X	while (*s && *s == *t) s++,t++,ct++;
SHAR_EOF
true || echo 'restore of zsh2.2/src/zle_refresh.c failed'
fi
echo 'End of zsh2.2 part 13'
echo 'File zsh2.2/src/zle_refresh.c is continued in part 14'
echo 14 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
