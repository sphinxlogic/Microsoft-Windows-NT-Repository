Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i110:  zsh2.2 - The Z shell, Part14/17
Message-ID: <1992May13.160936.11005@sparky.imd.sterling.com>
X-Md4-Signature: d9e717f9307ae05be74057c71501ab4c
Date: Wed, 13 May 1992 16:09:36 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 110
Archive-name: zsh2.2/part14
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.14 (part 14 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/src/zle_refresh.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 14; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/src/zle_refresh.c'
else
echo 'x - continuing file zsh2.2/src/zle_refresh.c'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/src/zle_refresh.c' &&
X	return ct;
X}
X
SHAR_EOF
echo 'File zsh2.2/src/zle_refresh.c is complete' &&
chmod 0644 zsh2.2/src/zle_refresh.c ||
echo 'restore of zsh2.2/src/zle_refresh.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_refresh.c'`"
test 12058 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_refresh.c: original size 12058, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_utils.c ==============
if test -f 'zsh2.2/src/zle_utils.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_utils.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_utils.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_utils.c' &&
X/*
X *
X * zle_utils.c - miscellaneous line editor utilities
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X/* make sure that the line buffer has at least sz chars */
X
Xvoid sizeline(sz) /**/
Xint sz;
X{
X	while (sz > linesz)
X		line = (unsigned char *)realloc(line,(linesz *= 4)+1);
X}
X
X/* insert space for ct chars at cursor position */
X
Xvoid spaceinline(ct) /**/
Xint ct;
X{
Xint i;
X
X	while (ct+ll > linesz)
X		line = (unsigned char *)realloc(line,(linesz *= 4)+1);
X	for (i = ll; i >= cs; i--)
X		line[i+ct] = line[i];
X	ll += ct;
X	line[ll] = '\0';
X}
X
Xvoid backkill(ct,dir) /**/
Xint ct;int dir;
X{
Xint i = (cs -= ct);
X
X	cut(i,ct,dir);
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid forekill(ct,dir) /**/
Xint ct;int dir;
X{
Xint i = cs;
X
X	cut(i,ct,dir);
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid cut(i,ct,dir) /**/
Xint i;int ct;int dir;
X{
X	if (vibufspec) {
X		int owrite = 1;
X		if (vibufspec >= 'A' && vibufspec <= 'Z') {
X			owrite = 0; vibufspec = tolower(vibufspec);
X		}
X		vibufspec += (idigit(vibufspec)) ? - '1' +26 : - 'a';
X		if (owrite || !vibuf[vibufspec]) {
X			if (vibuf[vibufspec]) free(vibuf[vibufspec]);
X			vibuf[vibufspec] = zalloc(ct+1);
X			ztrncpy(vibuf[vibufspec],line+i,ct);
X		} else {
X			int len = strlen(vibuf[vibufspec]);
X			vibuf[vibufspec] = realloc(vibuf[vibufspec],ct+len);
X			ztrncpy(vibuf[vibufspec]+len,line+i,ct);
X		}
X		vibufspec = 0;
X		return;
X	}
X	if (!cutbuf)
X		cutbuf = ztrdup("");
X	else if (!(lastcmd & ZLE_KILL)) {
X		kringnum = (kringnum+1)&(KRINGCT-1);
X		if (kring[kringnum])
X			free(kring[kringnum]);
X		kring[kringnum] = cutbuf;
X		cutbuf = ztrdup("");
X	}
X	if (dir) {
X		char *s = zalloc(strlen(cutbuf)+ct+1);
X		strncpy(s,(char *) line+i,ct);
X		strcpy(s+ct,cutbuf);
X		free(cutbuf);
X		cutbuf = s;
X	} else {
X		int x;
X
X		cutbuf = realloc(cutbuf,(x = strlen(cutbuf))+ct+1);
X		ztrncpy(cutbuf+x,line+i,ct);
X	}
X}
X
Xvoid backdel(ct) /**/
Xint ct;
X{
Xint i = (cs -= ct);
X
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid foredel(ct) /**/
Xint ct;
X{
Xint i = cs;
X
X	while (line[i] = line[i+ct])
X		i++;
X	ll -= ct;
X}
X
Xvoid setline(s) /**/
Xchar *s;
X{
X	sizeline(strlen(s));
X	strcpy((char *) line,s);
X	cs = ll = strlen(s);
X	if (cs && bindtab == altbindtab) cs--;
X}
X
Xvoid sethistline(s) /**/
Xunsigned char *s;
X{
X	setline(s);
X	for (s = line; *s; s++)
X		if (*s == (unsigned char)HISTSPACE)
X			*s = ' ';
X}
X
Xint findbol() /**/
X{
Xint x = cs;
X
X	while (x > 0 && line[x-1] != '\n') x--;
X	return x;
X}
X
Xint findeol() /**/
X{
Xint x = cs;
X
X	while (x != ll && line[x] != '\n') x++;
X	return x;
X}
X
Xvoid findline(a,b) /**/
Xint *a;int *b;
X{
X	*a = findbol();
X	*b = findeol();
X}
X
Xstatic int lastlinelen;
X
Xvoid initundo() /**/
X{
Xint t0;
X
X	for (t0 = 0; t0 != UNDOCT; t0++)
X		undos[t0].change = NULL;
X	undoct = 0;
X	lastline = zalloc(lastlinelen = (ll+1 < 32) ? 32 : ll+1);
X	strcpy((char *) lastline,(char *) line);
X	lastcs = cs;
X}
X
Xvoid addundo() /**/
X{
Xint pf,sf;
Xunsigned char *s,*s2,*t,*t2;
Xstruct undoent *ue;
X
X	for (s = line, t = lastline; *s && *s==*t; s++,t++);
X	if (!*s && !*t)
X		return;
X	pf = s-line;
X	for (s2 = (unsigned char *)line+strlen((char *) line),
X			t2 = lastline+strlen((char *) lastline);
X		s2 > s && t > t2 && s2[-1] == t2[-1]; s2--,t2--);
X	sf = strlen((char *) s2);
X	ue = undos+(undoct = (UNDOCT-1) & (undoct+1));
X	ue->pref = pf;
X	ue->suff = sf;
X	ue->len = t2-t;
X	ue->cs = lastcs;
X	strncpy(ue->change = halloc(ue->len),(char *) t,ue->len);
X	while (ll+1 > lastlinelen)
X		{
X		free(lastline);
X		lastline = zalloc(lastlinelen *= 2);
X		}
X	strcpy((char *) lastline,(char *) line);
X	lastcs = cs;
X}
X
Xvoid freeundo() /**/
X{
X	free(lastline);
X}
X
Xint hstrncmp(s,t,len) /**/
Xchar *s;char *t;int len;
X{
X	while (len && *s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
X			(*s == HISTSPACE && *t == ' ')))
X		s++,t++,len--;
X	return len;
X}
X
Xint hstrcmp(s,t) /**/
Xchar *s;char *t;
X{
X	while (*s && (*s == *t || (*s == ' ' && *t == HISTSPACE) ||
X			(*s == HISTSPACE && *t == ' ')))
X		s++,t++;
X	return !(*s == '\0' && *t == '\0');
X}
X
Xchar *hstrnstr(s,t,len) /**/
Xchar *s;char *t;int len;
X{
X	for (; *s; s++)
X		if (!hstrncmp(t,s,len))
X			return s;
X	return NULL;
X}
X
SHAR_EOF
chmod 0644 zsh2.2/src/zle_utils.c ||
echo 'restore of zsh2.2/src/zle_utils.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_utils.c'`"
test 4690 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_utils.c: original size 4690, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zsh.h ==============
if test -f 'zsh2.2/src/zsh.h' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zsh.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zsh.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zsh.h' &&
X/*
X *
X * zsh.h - standard header file
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "config.h"
X
X#include <stdio.h>
X#include <ctype.h>
X
X#ifdef HAS_STRING
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X#ifdef HAS_LOCALE
X#include <locale.h>
X#endif
X
X#ifdef HAS_STDLIB
X#include <stdlib.h>
X#endif
X
X#ifdef SYSV
X#include <sys/bsdtypes.h>
X#define _POSIX_SOURCE
X#include <sys/limits.h>
X#include <sys/sioctl.h>
X#define MAXPATHLEN PATH_MAX
X#define lstat stat
Xextern int gethostname();
X#define sigmask(m) m
X#include <sys/dirent.h>
X#else
X#include <sys/types.h>		/* this is the key to the whole thing */
X#endif
X
X#ifdef _IBMR2
X#undef _BSD   /* union wait SUCKS! */
X#include <sys/wait.h>
X#define _BSD
X#else
X#include <sys/wait.h>
X#endif
X
X#include <sys/time.h>
X
X#ifndef SYSV
X#include <sys/resource.h>
X#endif
X
X#include <sys/file.h>
X#include <signal.h>
X
X#ifdef TERMIO
X#define VDISABLEVAL -1
X#define TIO 1
X#include <sys/termio.h>
X#else
X#ifdef TERMIOS
X#define VDISABLEVAL 0
X#define TIO 1
X#include <termios.h>
X#else
X#include <sgtty.h>
X#endif
X#endif
X
X#ifdef SYSV
X#undef TIOCGWINSZ
X#endif
X
X#include <sys/param.h>
X#include <sys/times.h>
X
X#ifdef SYSV
X#undef _POSIX_SOURCE
X#endif
X
X#ifdef __hp9000s800
X#include <sys/bsdtty.h>
X#endif
X
X#ifndef sun
X#include <sys/ioctl.h>
X#else
X#include <sys/filio.h>
X#endif
X
X#define VERSIONSTR "zsh v2.2.0"
X
X#if 0 /* __STDC__ */
X#include <unistd.h>
X#include <fcntl.h>
X#include <stat.h>
X#define DCLPROTO(X) X
X#undef NULL
X#define NULL ((void *)0)
X#else /* not __STDC__ */
X#include <sys/stat.h>
X#define DCLPROTO(X) ()
X#ifndef NULL
X#define NULL 0
X#endif
X#endif /* __STDC__ */
X
X#ifdef QDEBUG
X#define DCLPROTO(X) X
X#endif
X
X#define DEFWORDCHARS "*?_-.[]~=/&;!#$%^(){}<>"
X#define DEFTIMEFMT "%E real  %U user  %S system  %P %J"
X#ifdef UTMP_HOST
X#define DEFWATCHFMT "%n has %a %l from %m."
X#else
X#define DEFWATCHFMT "%n has %a %l."
X#endif
X
X#ifdef GLOBALS
X#define EXTERN
X#else
X#define EXTERN extern
X#endif
X
X#ifdef HAS_STRING
X#define killpg(pgrp,sig) kill(-(pgrp),sig)
X#endif
X
X#ifndef F_OK
X#define F_OK 00
X#define R_OK 04
X#define W_OK 02
X#define X_OK 01
X#endif
X
X#include "zle.h"
X
X/* size of job list */
X
X#define MAXJOB 80
X
X/* memory allocation routines - changed with permalloc()/heapalloc() */
X
Xvptr (*alloc)DCLPROTO((int));
Xvptr (*ncalloc)DCLPROTO((int));
X
X#define addhnode(A,B,C,D) Addhnode(A,B,C,D,1)
X#define addhperm(A,B,C,D) Addhnode(A,B,C,D,0)
X
X/* character tokens */
X
X#define ALPOP			((char) 0x81)
X#define HISTSPACE		((char) 0x83)
X#define Pound			((char) 0x84)
X#define String			((char) 0x85)
X#define Hat				((char) 0x86)
X#define Star			((char) 0x87)
X#define Inpar			((char) 0x88)
X#define Outpar			((char) 0x89)
X#define Qstring		((char) 0x8a)
X#define Equals			((char) 0x8b)
X#define Bar				((char) 0x8c)
X#define Inbrace		((char) 0x8d)
X#define Outbrace		((char) 0x8e)
X#define Inbrack		((char) 0x8f)
X#define Outbrack		((char) 0x90)
X#define Tick			((char) 0x91)
X#define Inang			((char) 0x92)
X#define Outang			((char) 0x93)
X#define Quest			((char) 0x94)
X#define Tilde			((char) 0x95)
X#define Qtick			((char) 0x96)
X#define Comma			((char) 0x97)
X#define Nularg			((char) 0x98)
X
X/* chars that need to be quoted if meant literally */
X
X#define SPECCHARS "#$^*()$=|{}[]`<>?~;&!\n\t \\\'\""
X
X/* ALPOP in the form of a string */
X
X#define ALPOPS " \201"
X#define HISTMARK "\201"
X
X#define SEPER 1
X#define NEWLIN 2
X#define LEXERR 3
X#define SEMI 4
X#define DSEMI 5
X#define AMPER 6
X#define INPAR 7
X#define INBRACE 8
X#define OUTPAR 9
X#define DBAR 10
X#define DAMPER 11
X#define BANG 12
X#define OUTBRACE 13
X#define OUTANG 14
X#define OUTANGBANG 15
X#define DOUTANG 16
X#define DOUTANGBANG 17
X#define INANG 18
X#define DINANG 19
X#define DINANGDASH 20
X#define INANGAMP 21
X#define OUTANGAMP 22
X#define OUTANGAMPBANG 23
X#define DOUTANGAMP 24
X#define DOUTANGAMPBANG 25
X#define TRINANG 26
X#define BAR 27
X#define BARAMP 28
X#define DINBRACK 29
X#define DOUTBRACK 30
X#define STRING 31
X#define ENVSTRING 32
X#define ENVARRAY 33
X#define ENDINPUT 34
X#define INOUTPAR 35
X#define DO 36
X#define DONE 37
X#define ESAC 38
X#define THEN 39
X#define ELIF 40
X#define ELSE 41
X#define FI 42
X#define FOR 43
X#define CASE 44
X#define IF 45
X#define WHILE 46
X#define FUNC 47
X#define REPEAT 48
X#define TIME 49
X#define UNTIL 50
X#define EXEC 51
X#define COMMAND 52
X#define SELECT 53
X#define COPROC 54
X#define NOGLOB 55
X#define DASH 56
X#define NOCORRECT 57
X#define FOREACH 58
X#define ZEND 59
X
X#define WRITE 0
X#define WRITENOW 1
X#define APP 2
X#define APPNOW 3
X#define MERGEOUT 4
X#define MERGEOUTNOW 5
X#define ERRAPP 6
X#define ERRAPPNOW 7
X#define READ 8
X#define HEREDOC 9
X#define HEREDOCDASH 10
X#define HERESTR 11
X#define MERGE 12
X#define CLOSE 13
X#define INPIPE 14
X#define OUTPIPE 15
X#define NONE 16
X
X#ifdef GLOBALS
Xint redirtab[TRINANG-OUTANG+1] = {
X	WRITE,
X	WRITENOW,
X	APP,
X	APPNOW,
X	READ,
X	HEREDOC,
X	HEREDOCDASH,
X	MERGE,
X	MERGEOUT,
X	MERGEOUTNOW,
X	ERRAPP,
X	ERRAPPNOW,
X	HERESTR,
X};
X#else
Xint redirtab[TRINANG-OUTANG+1];
X#endif
X
X#define IS_READFD(X) ((X)>=READ && (X)<=MERGE)
X#define IS_REDIROP(X) ((X)>=OUTANG && (X)<=TRINANG)
X#define IS_ERROR_REDIR(X) ((X)>=MERGEOUT && (X)<=ERRAPPNOW)
X#define UN_ERROR_REDIR(X) ((X)-MERGEOUT+WRITE)
X
X#define FD_WORD   -1
X#define FD_COPROC -2
X#define FD_CLOSE  -3
X
XEXTERN char **environ;
X
Xtypedef struct hashtab *Hashtab;
Xtypedef struct hashnode *Hashnode;
Xtypedef struct schedcmd *Schedcmd;
Xtypedef struct alias *Alias;
Xtypedef struct process *Process;
Xtypedef struct job *Job;
Xtypedef struct value *Value;
Xtypedef struct arrind *Arrind;
Xtypedef struct varasg *Varasg;
Xtypedef struct param *Param;
Xtypedef struct cmdnam *Cmdnam;
Xtypedef struct cond *Cond;
Xtypedef struct cmd *Cmd;
Xtypedef struct pline *Pline;
Xtypedef struct sublist *Sublist;
Xtypedef struct list *List;
Xtypedef struct lklist *Lklist;
Xtypedef struct lknode *Lknode;
Xtypedef struct comp *Comp;
Xtypedef struct redir *Redir;
Xtypedef struct complist *Complist;
Xtypedef struct heap *Heap;
Xtypedef struct histent *Histent;
Xtypedef struct hp *Hp;
Xtypedef struct compctl *Compctl;
Xtypedef void (*FFunc)DCLPROTO((vptr));
Xtypedef vptr (*VFunc)DCLPROTO((vptr));
Xtypedef void (*HFunc)DCLPROTO((char *,char *));
X
X/* linked list abstract data type */
X
Xstruct lknode;
Xstruct lklist;
X
Xstruct lknode {
X   Lknode next,last;
X   vptr dat;
X   };
Xstruct lklist {
X   Lknode first,last;
X   };
X
X#define addnode(X,Y) insnode(X,(X)->last,Y)
X#define full(X) ((X)->first != NULL)
X#define firstnode(X) ((X)->first)
X#define getaddrdata(X) (&((X)->dat))
X#define getdata(X) ((X)->dat)
X#define setdata(X,Y) ((X)->dat = (Y))
X#define lastnode(X) ((X)->last)
X#define nextnode(X) ((X)->next)
X#define prevnode(X) ((X)->last)
X#define peekfirst(X) ((X)->first->dat)
X#define pushnode(X,Y) insnode(X,(Lknode) X,Y)
X#define incnode(X) (X = nextnode(X))
X#define gethistent(X) (histentarr+((X)%histentct))
X
X/* node structure for syntax trees */
X
X/* struct list, struct sublist, struct pline, etc.  all fit the form
X	of this structure and are used interchangably
X*/
X
Xstruct node {
X	int data[4];			/* arbitrary integer data */
X	vptr ptrs[4];			/* arbitrary pointer data */
X	int types[4];			/* what ptrs[] are pointing to */
X	int type;				/* node type */
X	};
X
X#define N_LIST 0
X#define N_SUBLIST 1
X#define N_PLINE 2
X#define N_CMD 3
X#define N_REDIR 4
X#define N_COND 5
X#define N_FOR 6
X#define N_CASE 7
X#define N_IF 8
X#define N_WHILE 9
X#define N_VARASG 10
X#define N_COUNT 11
X
X/* values for types[4] */
X
X#define NT_EMPTY 0
X#define NT_NODE  1
X#define NT_STR   2
X#define NT_LIST  4
X#define NT_MALLOC 8
X
X/* tree element for lists */
X
Xstruct list {
X	int type;
X	int ifil[3];		/* to fit struct node */
X   Sublist left;
X   List right;
X   };
X
X#define SYNC 0		/* ; */
X#define ASYNC 1	/* & */
X#define TIMED 2
X
X/* tree element for sublists */
X
Xstruct sublist {
X	int type;
X	int flags;			/* see PFLAGs below */
X	int ifil[2];
X	Pline left;
X	Sublist right;
X	};
X
X#define ORNEXT 10		/* || */
X#define ANDNEXT 11	/* && */
X
X#define PFLAG_NOT 1			/* ! ... */
X#define PFLAG_COPROC 32		/* coproc ... */
X
X/* tree element for pipes */
X
Xstruct pline {
X	int type;
X	int ifil[3];
X   Cmd left;
X   Pline right;
X   };
X
X#define END		0	/* pnode *right is null */
X#define PIPE	1	/* pnode *right is the rest of the pipeline */
X
X/* tree element for commands */
X
Xstruct cmd {
X	int type;
X	int flags;				/* see CFLAGs below */
X	int ifil[2];
X   Lklist args;			/* command & argmument List (char *'s) */
X	union {
X   	List list;			/* for SUBSH/CURSH/SHFUNC */
X		struct forcmd *forcmd;
X		struct casecmd *casecmd;
X		struct ifcmd *ifcmd;
X		struct whilecmd *whilecmd;
X		Sublist pline;
X		Cond cond;
X		} u;
X   Lklist redir;			/* i/o redirections (struct redir *'s) */
X	Lklist vars;			/* param assignments (struct varasg *'s) */
X   };
X
X#define SIMPLE 0
X#define SUBSH 1
X#define CURSH 2
X#define ZCTIME 3
X#define FUNCDEF 4
X#define CFOR 5
X#define CWHILE 6
X#define CREPEAT 7
X#define CIF 8
X#define CCASE 9
X#define CSELECT 10
X#define COND 11
X
X#define CFLAG_EXEC 1			/* exec ... */
X#define CFLAG_COMMAND 2		/* command ... */
X#define CFLAG_NOGLOB 4     /* noglob ... */
X#define CFLAG_DASH 8			/* - ... */
X
X/* tree element for redirection lists */
X
Xstruct redir {
X	int type,fd1,fd2,ifil;
X	char *name;
X   };
X
X/* tree element for conditionals */
X
Xstruct cond {
X	int type;		/* can be cond_type, or a single letter (-a, -b, ...) */
X	int ifil[3];
X	vptr left,right,vfil[2];
X	int types[4],typ;	/* from struct node.  DO NOT REMOVE */
X	};
X
X#define COND_NOT 0
X#define COND_AND 1
X#define COND_OR 2
X#define COND_STREQ 3
X#define COND_STRNEQ 4
X#define COND_STRLT 5
X#define COND_STRGTR 6
X#define COND_NT 7
X#define COND_OT 8
X#define COND_EF 9
X#define COND_EQ 10
X#define COND_NE 11
X#define COND_LT 12
X#define COND_GT 13
X#define COND_LE 14
X#define COND_GE 15
X
Xstruct forcmd {		/* for/select */
X							/* Cmd->args contains list of words to loop thru */
X	int inflag;			/* if there is an in ... clause */
X	int ifil[3];
X	char *name;			/* parameter to assign values to */
X	List list;			/* list to look through for each name */
X	};
Xstruct casecmd {
X							/* Cmd->args contains word to test */
X	int ifil[4];
X	struct casecmd *next;
X	char *pat;
X	List list;					/* list to execute */
X	};
X
X/*
X
X	a command like "if foo then bar elif baz then fubar else fooble"
X	generates a tree like:
X
X	struct ifcmd a = { next =  &b,  ifl = "foo", thenl = "bar" }
X	struct ifcmd b = { next =  &c,  ifl = "baz", thenl = "fubar" }
X	struct ifcmd c = { next = NULL, ifl = NULL, thenl = "fooble" }
X
X*/
X
Xstruct ifcmd {
X	int ifil[4];
X	struct ifcmd *next;
X	List ifl;
X	List thenl;
X	};
X
Xstruct whilecmd {
X	int cond;		/* 0 for while, 1 for until */
X	int ifil[3];
X	List cont;		/* condition */
X	List loop;		/* list to execute until condition met */
X	};
X
X/* structure used for multiple i/o redirection */
X/* one for each fd open */
X
Xstruct multio {
X	int ct;				/* # of redirections on this fd */
X	int rflag;			/* 0 if open for reading, 1 if open for writing */
X	int pipe;			/* fd of pipe if ct > 1 */
X	int fds[NOFILE];	/* list of src/dests redirected to/from this fd */
X   }; 
X
X/* node used in command path hash table (cmdnamtab) */
X
Xstruct cmdnam 
X{
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	int type,flags;
X	union {
X		char *nam;		/* full pathname if type != BUILTIN */
X		int binnum;		/* func to exec if type == BUILTIN */
X		List list;		/* list to exec if type == SHFUNC */
X		} u;
X	char **pcomp;		/* location in path for EXCMD's */
X	};
X
X#define EXCMD 0
X#define BUILTIN 2
X#define SHFUNC 3
X#define DISABLED 4
X#define ISEXCMD(X) ((X)==EXCMD)
X
X/* node used in parameter hash table (paramtab) */
X
Xstruct param {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	union {
X		char **arr;		/* value if declared array */
X		char *str;		/* value if declared string (scalar) */
X		long val;		/* value if declared integer */
X		} u;
X	union {				/* functions to call to set value */
X		void (*cfn)DCLPROTO((Param,char *));
X		void (*ifn)DCLPROTO((Param,long));
X		void (*afn)DCLPROTO((Param,char **));
X		} sets;
X	union {				/* functions to call to get value */
X		char *(*cfn)DCLPROTO((Param));
X		long (*ifn)DCLPROTO((Param));
X		char **(*afn)DCLPROTO((Param));
X		} gets;
X	int ct;				/* output base or field width */
X	int flags;
X	vptr data;			/* used by getfns */
X	char *env;			/* location in environment, if exported */
X	char *ename;		/* name of corresponding environment var */
X	};
X
X#define PMFLAG_s 0		/* scalar */
X#define PMFLAG_L 1		/* left justify and remove leading blanks */
X#define PMFLAG_R 2		/* right justify and fill with leading blanks */
X#define PMFLAG_Z 4		/* right justify and fill with leading zeros */
X#define PMFLAG_i 8		/* integer */
X#define PMFLAG_l 16		/* all lower case */
X#define PMFLAG_u 32		/* all upper case */
X#define PMFLAG_r 64		/* readonly */
X#define PMFLAG_t 128		/* tagged */
X#define PMFLAG_x 256		/* exported */
X#define PMFLAG_A 512		/* array */
X#define PMFLAG_SPECIAL	1024
X#define PMTYPE (PMFLAG_i|PMFLAG_A)
X#define pmtype(X) ((X)->flags & PMTYPE)
X
X/* variable assignment tree element */
X
Xstruct varasg {
X	int type;			/* nonzero means array */
X	int ifil[3];
X	char *name;
X	char *str;			/* should've been a union here.  oh well */
X	Lklist arr;
X	};
X
X/* lvalue for variable assignment/expansion */
X
Xstruct value {
X	int isarr;
X	struct param *pm;		/* parameter node */
X	int a;					/* first element of array slice, or -1 */
X	int b;					/* last element of array slice, or -1 */
X	};
X
Xstruct fdpair {
X	int fd1,fd2;
X	};
X
X/* tty state structure */
X
Xstruct ttyinfo {
X#ifdef TERMIOS
X	struct termios tio;
X#else
X#ifdef TERMIO
X	struct termio tio;
X#else
X	struct sgttyb sgttyb;
X	int lmodes;
X	struct tchars tchars;
X	struct ltchars ltchars;
X#endif
X#endif
X#ifdef TIOCGWINSZ
X	struct winsize winsize;
X#endif
X	};
X
XEXTERN struct ttyinfo savedttyinfo;
X
X/* entry in job table */
X
Xstruct job {
X	long gleader;					/* process group leader of this job */
X	int stat;
X	char *pwd;						/* current working dir of shell when
X											this job was spawned */
X	struct process *procs;		/* list of processes */
X	Lklist filelist;				/* list of files to delete when done */
X	};
X
X#define STAT_CHANGED 1		/* status changed and not reported */
X#define STAT_STOPPED 2		/* all procs stopped or exited */
X#define STAT_TIMED 4			/* job is being timed */
X#define STAT_DONE 8
X#define STAT_LOCKED 16		/* shell is finished creating this job,
X										may be deleted from job table */
X#define STAT_INUSE 64		/* this job entry is in use */
X
X#define SP_RUNNING -1		/* fake statusp for running jobs */
X
X#ifndef RUSAGE_CHILDREN
X#undef HAS_RUSAGE
X#endif
X
Xstruct timeinfo {
X#ifdef HAS_RUSAGE
X	struct rusage ru;
X#else
X	long ut, st;
X#endif
X};
X
X/* node in job process lists */
X
X#define JOBTEXTSIZE 80
X
Xstruct process {
X	struct process *next;
X	long pid;
X	char text[JOBTEXTSIZE];		/* text to print when 'jobs' is run */
X	int statusp;					/* return code from wait3() */
X	struct timeinfo ti;
X	time_t bgtime;					/* time job was spawned */
X	time_t endtime;				/* time job exited */
X	};
X
X/* node in alias hash table */
X
Xstruct alias {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	char *text;			/* expansion of alias */
X	int cmd;				/* one for regular aliases,
X								zero for global aliases,
X								negative for reserved words */
X	int inuse;			/* alias is being expanded */
X	};
X
X/* node in sched list */
X
Xstruct schedcmd {
X	struct schedcmd *next;
X	char *cmd;		/* command to run */
X	time_t time;	/* when to run it */
X	};
X
X#define MAXAL 20	/* maximum number of aliases expanded at once */
X
X/* hash table node */
X
Xstruct hashnode {
X	struct hashnode *next;
X	int canfree;		/* nam is free()able */
X	char *nam;
X	};
X
X/* hash table */
X
Xstruct hashtab {
X	int hsize;							/* size of nodes[] */
X	int ct;								/* # of elements */
X	struct hashnode **nodes;		/* array of size hsize */
X	};
X
X/* history entry */
X
Xstruct histent {
X	char *lex;			/* lexical history line */
X	char *lit;			/* literal history line */
X	time_t stim;		/* command started time (datestamp) */
X	time_t ftim;		/* command finished time */
X	};
X
X/* completion control */
X
Xstruct compctl {
X	struct hashnode *next; int canfree; char *nam; /* hash data */
X	int mask;
X	char *keyvar;
X	};
X
X#define CC_FILES		1
X#define CC_COMMPATH	2
X#define CC_HOSTS		4
X#define CC_OPTIONS	8
X#define CC_VARS		16
X#define CC_BINDINGS	32
X#define CC_USRKEYS   64
X
Xextern char *sys_errlist[];
Xextern int errno;
X
X/* values in opts[] array */
X
X#define OPT_INVALID 1	/* opt is invalid, like -$ */
X#define OPT_UNSET 0
X#define OPT_SET 2
X
X/* the options */
X
Xstruct option {
X	char *name;
X	char id;			/* corresponding letter */
X	};
X
X#define CORRECT '0'
X#define NOCLOBBER '1'
X#define NOBADPATTERN '2'
X#define NONOMATCH '3'
X#define GLOBDOTS '4'
X#define NOTIFY '5'
X#define BGNICE '6'
X#define IGNOREEOF '7'
X#define MARKDIRS '8'
X#define AUTOLIST '9'
X#define NOBEEP 'B'
X#define PRINTEXITVALUE 'C'
X#define PUSHDTOHOME 'D'
X#define PUSHDSILENT 'E'
X#define NOGLOBOPT 'F'
X#define NULLGLOB 'G'
X#define RMSTARSILENT 'H'
X#define IGNOREBRACES 'I'
X#define AUTOCD 'J'
X#define NOBANGHIST 'K'
X#define SUNKEYBOARDHACK 'L'
X#define SINGLELINEZLE 'M'
X#define AUTOPUSHD 'N'
X#define CORRECTALL 'O'
X#define RCEXPANDPARAM 'P'
X#define PATHDIRS 'Q'
X#define LONGLISTJOBS 'R'
X#define RECEXACT 'S'
X#define CDABLEVARS 'T'
X#define MAILWARNING 'U'
X#define NOPROMPTCR 'V'
X#define AUTORESUME 'W'
X#define LISTTYPES 'X'
X#define MENUCOMPLETE 'Y'
X#define USEZLE 'Z'
X#define ALLEXPORT 'a'
X#define ERREXIT 'e'
X#define NORCS 'f'
X#define HISTIGNORESPACE 'g'
X#define HISTIGNOREDUPS 'h'
X#define INTERACTIVE 'i'
X#define HISTLIT 'j'
X#define INTERACTIVECOMMENTS 'k'
X#define LOGINSHELL 'l'
X#define MONITOR 'm'
X#define NOEXEC 'n'
X#define SHINSTDIN 's'
X#define NOUNSET 'u'
X#define VERBOSE 'v'
X#define CHASELINKS 'w'
X#define XTRACE 'x'
X#define SHWORDSPLIT 'y'
X#define MENUCOMPLETEBEEP '\2'
X#define HISTNOSTORE '\3'
X#define EXTENDEDGLOB '\5'
X#define GLOBCOMPLETE '\6'
X#define CSHJUNKIEQUOTES '\7'
X#define PUSHDMINUS '\10'
X#define CSHJUNKIELOOPS '\11'
X#define RCQUOTES '\12'
X#define KSHOPTIONPRINT '\13'
X#define NOSHORTLOOPS '\14'
X#define LASTMENU '\15'
X#define AUTOMENU '\16'
X#define HISTVERIFY '\17'
X#define NOLISTBEEP '\20'
X#define NOHUP '\21'
X#define NOEQUALS '\22'
X#define CSHNULLGLOB '\23'
X#define HASHCMDS '\24'
X#define HASHDIRS '\25'
X#define NUMERICGLOBSORT '\26'
X#define BRACECCL '\27'
X#define HASHLISTALL '\30'
X#define OVERSTRIKE '\31'
X#define NOHISTBEEP '\32'
X#define PUSHDIGNOREDUPS '\33'
X#define AUTOREMOVESLASH '\34'
X
X#ifndef GLOBALS
Xextern struct option optns[];
X#else
Xstruct option optns[] = {
X	"correct",CORRECT,
X	"noclobber",NOCLOBBER,
X	"nobadpattern",NOBADPATTERN,
X	"nonomatch",NONOMATCH,
X	"globdots",GLOBDOTS,
X	"notify",NOTIFY,
X	"bgnice",BGNICE,
X	"ignoreeof",IGNOREEOF,
X	"markdirs",MARKDIRS,
X	"autolist",AUTOLIST,
X	"nobeep",NOBEEP,
X	"printexitvalue",PRINTEXITVALUE,
X	"pushdtohome",PUSHDTOHOME,
X	"pushdsilent",PUSHDSILENT,
X	"noglob",NOGLOBOPT,
X	"nullglob",NULLGLOB,
X	"rmstarsilent",RMSTARSILENT,
X	"ignorebraces",IGNOREBRACES,
X	"braceccl",BRACECCL,
X	"autocd",AUTOCD,
X	"nobanghist",NOBANGHIST,
X	"sunkeyboardhack",SUNKEYBOARDHACK,
X	"singlelinezle",SINGLELINEZLE,
X	"autopushd",AUTOPUSHD,
X	"correctall",CORRECTALL,
X	"rcexpandparam",RCEXPANDPARAM,
X	"pathdirs",PATHDIRS,
X	"longlistjobs",LONGLISTJOBS,
X	"recexact",RECEXACT,
X	"cdablevars",CDABLEVARS,
X	"mailwarning",MAILWARNING,
X	"nopromptcr",NOPROMPTCR,
X	"autoresume",AUTORESUME,
X	"listtypes",LISTTYPES,
X	"menucomplete",MENUCOMPLETE,
X	"zle",USEZLE,
X	"allexport",ALLEXPORT,
X	"errexit",ERREXIT,
X	"norcs",NORCS,
X	"histignorespace",HISTIGNORESPACE,
X	"histignoredups",HISTIGNOREDUPS,
X	"interactive",INTERACTIVE,
X	"histlit",HISTLIT,
X	"interactivecomments",INTERACTIVECOMMENTS,
X	"login",LOGINSHELL,
X	"monitor",MONITOR,
X	"noexec",NOEXEC,
X	"shinstdin",SHINSTDIN,
X	"nounset",NOUNSET,
X	"verbose",VERBOSE,
X	"chaselinks",CHASELINKS,
X	"xtrace",XTRACE,
X	"shwordsplit",SHWORDSPLIT,
X	"menucompletebeep",MENUCOMPLETEBEEP,
X	"histnostore",HISTNOSTORE,
X	"extendedglob",EXTENDEDGLOB,
X	"globcomplete",GLOBCOMPLETE,
X	"cshjunkiequotes",CSHJUNKIEQUOTES,
X	"pushdminus",PUSHDMINUS,
X	"cshjunkieloops",CSHJUNKIELOOPS,
X	"rcquotes",RCQUOTES,
X	"noshortloops",NOSHORTLOOPS,
X	"lastmenu",LASTMENU,
X	"automenu",AUTOMENU,
X	"histverify",HISTVERIFY,
X	"nolistbeep",NOLISTBEEP,
X	"nohup",NOHUP,
X	"noequals",NOEQUALS,
X	"kshoptionprint",KSHOPTIONPRINT,
X	"cshnullglob",CSHNULLGLOB,
X	"hashcmds",HASHCMDS,
X	"hashdirs",HASHDIRS,
X	"numericglobsort",NUMERICGLOBSORT,
X	"hashlistall",HASHLISTALL,
X	"overstrike",OVERSTRIKE,
X	"nohistbeep",NOHISTBEEP,
X	"pushdignoredups",PUSHDIGNOREDUPS,
X	"autoremoveslash",AUTOREMOVESLASH,
X	NULL,0
X};
X#endif
X
X#define ALSTAT_MORE 1	/* last alias ended with ' ' */
X#define ALSTAT_JUNK 2	/* don't put word in history List */
X
X#undef isset
X#define isset(X) (opts[X])
X#define unset(X) (!opts[X])
X#define interact (isset(INTERACTIVE))
X#define jobbing (isset(MONITOR))
X#define nointr() signal(SIGINT,SIG_IGN)
X#define islogin (isset(LOGINSHELL))
X
X#ifndef _IBMR2
X#undef WIFSTOPPED
X#undef WIFSIGNALED
X#undef WIFEXITED
X#undef WEXITSTATUS
X#undef WTERMSIG
X#undef WSTOPSIG
X#undef WCOREDUMPED
X
X#define WIFSTOPPED(X) (((X)&0377)==0177)
X#define WIFSIGNALED(X) (((X)&0377)!=0&&((X)&0377)!=0177)
X#define WIFEXITED(X) (((X)&0377)==0)
X#define WEXITSTATUS(X) (((X)>>8)&0377)
X#define WTERMSIG(X) ((X)&0177)
X#define WSTOPSIG(X) (((X)>>8)&0377)
X#endif
X#define WCOREDUMPED(X) ((X)&0200)
X
X#ifndef S_ISBLK
X#define	_IFMT		0170000
X#define	_IFDIR	0040000
X#define	_IFCHR	0020000
X#define	_IFBLK	0060000
X#define	_IFREG	0100000
X#define	_IFIFO	0010000
X#define	S_ISBLK(m)	(((m)&_IFMT) == _IFBLK)
X#define	S_ISCHR(m)	(((m)&_IFMT) == _IFCHR)
X#define	S_ISDIR(m)	(((m)&_IFMT) == _IFDIR)
X#define	S_ISFIFO(m)	(((m)&_IFMT) == _IFIFO)
X#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)
X#endif
X
X#ifndef S_ISSOCK
X#ifndef _IFMT
X#define _IFMT 0170000
X#endif
X#define	_IFLNK	0120000
X#define	_IFSOCK	0140000
X#define	S_ISLNK(m)	(((m)&_IFMT) == _IFLNK)
X#define	S_ISSOCK(m)	(((m)&_IFMT) == _IFSOCK)
X#endif
X
X#if S_IFIFO == S_IFSOCK
X#undef S_IFIFO
X#endif
X
X#ifndef S_IFIFO
X#define NO_FIFOS
X#endif
X
X/* buffered shell input for non-interactive shells */
X
XEXTERN FILE *bshin;
X
X/* NULL-terminated arrays containing path, cdpath, etc. */
X
XEXTERN char **path,**cdpath,**fpath,**watch,**mailpath;
XEXTERN char **manpath,**tildedirs,**fignore;
XEXTERN char **hosts;
X
X/* named directories */
X
XEXTERN char **userdirs,**usernames;
X
X/* size of userdirs[], # of userdirs */
X
XEXTERN int userdirsz,userdirct;
X
XEXTERN char *mailfile;
X
XEXTERN char *yytext;
X
X/* error/break flag */
X
XEXTERN int errflag;
X
XEXTERN char *tokstr;
XEXTERN int tok, tokfd;
X
X/* lexical analyzer error flag */
X
XEXTERN int lexstop;
X
X/* suppress error messages */
X
XEXTERN int noerrs;
X
X/* current history event number */
X
XEXTERN int curhist;
X
X/* if != 0, this is the first line of the command */
X
XEXTERN int isfirstln;
X
X/* if != 0, this is the first char of the command (not including
X	white space */
X
XEXTERN int isfirstch;
X
X/* number of history entries */
X
XEXTERN int histentct;
X
X/* array of history entries */
X
XEXTERN Histent histentarr;
X
X/* capacity of history lists */
X
XEXTERN int histsiz,lithistsiz;
X
X/* if = 1, we have performed history substitution on the current line
X 	if = 2, we have used the 'p' modifier */
X
XEXTERN int histdone;
X
X/* default event (usually curhist-1, that is, "!!") */
X
XEXTERN int defev;
X
X/* != 0 if we are about to read a command word */
X
XEXTERN int incmdpos;
X
X/* != 0 if we are in the middle of a [[ ... ]] */
X
XEXTERN int incond;
X
X/* != 0 if we are after a redirection (for ctxtlex only) */
X
XEXTERN int inredir;
X
X/* != 0 if we are about to read a case pattern */
X
XEXTERN int incasepat;
X
X/* != 0 if we just read FUNCTION */
X
XEXTERN int infunc;
X
X/* != 0 if we just read a newline */
X
XEXTERN int isnewlin;
X
X/* the lists of history events */
X
XEXTERN Lklist histlist,lithistlist;
X
X/* the directory stack */
X
XEXTERN Lklist dirstack;
X
X/* the zle buffer stack */
X
XEXTERN Lklist bufstack;
X
X/* the input queue (stack?)
X
X	inbuf    = start of buffer
X	inbufptr = location in buffer (= inbuf for a FULL buffer)
X											(= inbuf+inbufsz for an EMPTY buffer)
X	inbufct  = # of chars in buffer (inbufptr+inbufct == inbuf+inbufsz)
X	inbufsz  = max size of buffer
X*/
X
XEXTERN char *inbuf,*inbufptr;
XEXTERN int inbufct,inbufsz;
X
XEXTERN char *ifs;		/* $IFS */
X
XEXTERN char *oldpwd;	/* $OLDPWD */
X
XEXTERN char *underscore; /* $_ */
X
X/* != 0 if this is a subshell */
X
XEXTERN int subsh;
X
X/* # of break levels */
X
XEXTERN int breaks;
X
X/* != 0 if we have a return pending */
X
XEXTERN int retflag;
X
X/* how far we've hashed the PATH so far */
X
XEXTERN char **pathchecked;
X
X/* # of nested loops we are in */
X
XEXTERN int loops;
X
X/* # of continue levels */
X
XEXTERN int contflag;
X
X/* the job we are working on */
X
XEXTERN int thisjob;
X
X/* the current job (+) */
X
XEXTERN int curjob;
X
X/* the previous job (-) */
X
XEXTERN int prevjob;
X
X/* hash table containing the aliases and reserved words */
X
XEXTERN Hashtab aliastab;
X
X/* hash table containing the parameters */
X
XEXTERN Hashtab paramtab;
X
X/* hash table containing the builtins/shfuncs/hashed commands */
X
XEXTERN Hashtab cmdnamtab;
X
X/* hash table containing the zle multi-character bindings */
X
XEXTERN Hashtab xbindtab;
X
X/* hash table for completion info for commands */
X
XEXTERN Hashtab compctltab;
X
X/* default completion infos */
X
XEXTERN struct compctl cc_compos, cc_default;
X
X/* the job table */
X
XEXTERN struct job jobtab[MAXJOB];
X
X/* shell timings */
X
X#ifndef HAS_RUSAGE
XEXTERN struct tms shtms;
X#endif
X
X/* the list of sched jobs pending */
X
XEXTERN struct schedcmd *schedcmds;
X
X/* the last l for s/l/r/ history substitution */
X
XEXTERN char *hsubl;
X
X/* the last r for s/l/r/ history substitution */
X
XEXTERN char *hsubr;
X
XEXTERN char *username;	/* $USERNAME */
XEXTERN char *logname;	/* $LOGNAME */
XEXTERN long lastval;		/* $? */
XEXTERN long baud;			/* $BAUD */
XEXTERN long columns;		/* $COLUMNS */
XEXTERN long lines;		/* $LINES */
XEXTERN long reporttime; /* $REPORTTIME */
X
X/* input fd from the coprocess */
X
XEXTERN int coprocin;
X
X/* output fd from the coprocess */
X
XEXTERN int coprocout;
X
XEXTERN long mailcheck;	/* $MAILCHECK */
XEXTERN long logcheck;	/* $LOGCHECK */
X
X/* the last time we checked mail */
X
XEXTERN time_t lastmailcheck;
X
X/* the last time we checked the people in the WATCH variable */
X
XEXTERN time_t lastwatch;
X
X/* the last time we did the periodic() shell function */
X
XEXTERN time_t lastperiod;
X
X/* $SECONDS = time(NULL) - shtimer */
X
XEXTERN time_t shtimer;
X
XEXTERN long mypid;		/* $$ */
XEXTERN long lastpid;		/* $! */
XEXTERN long ppid;			/* $PPID */
X
X/* the process group of the shell */
X
XEXTERN long mypgrp;
X
XEXTERN char *pwd;			/* $PWD */
XEXTERN char *optarg;		/* $OPTARG */
XEXTERN long zoptind;		/* $OPTIND */
XEXTERN char *prompt;		/* $PROMPT */
XEXTERN char *rprompt;	/* $RPROMPT */
XEXTERN char *prompt2;	/* etc. */
XEXTERN char *prompt3;
XEXTERN char *prompt4;
XEXTERN char *sprompt;
XEXTERN char *timefmt;
XEXTERN char *watchfmt;
XEXTERN char *wordchars;
XEXTERN char *fceditparam;
XEXTERN char *tmpprefix;
XEXTERN char *rstring, *Rstring;
XEXTERN char *postedit;
X
XEXTERN char *argzero;	/* $0 */
X
XEXTERN char *hackzero;
X
X/* the hostname */
X
XEXTERN char *hostnam;
X
XEXTERN char *home;		/* $HOME */
XEXTERN char **pparams;	/* $argv */
X
X/* the default command for null commands */
X
XEXTERN char *nullcmd;
XEXTERN char *readnullcmd;
X
X/* the List of local variables we have to destroy */
X
XEXTERN Lklist locallist;
X
X/* the shell input fd */
X
XEXTERN int SHIN;
X
X/* the shell tty fd */
X
XEXTERN int SHTTY;
X
X/* the stack of aliases we are expanding */
X
XEXTERN struct alias *alstack[MAXAL];
X
X/* the alias stack pointer; also, the number of aliases currently
X 	being expanded */
X
XEXTERN int alstackind;
X
X/* != 0 means we are reading input from a string */
X
XEXTERN int strin;
X
X/* period between periodic() commands, in seconds */
X
XEXTERN long period;
X
X/* != 0 means history substitution is turned off */
X
XEXTERN int stophist;
X
XEXTERN int lithist;
X
X/* this line began with a space, so junk it if HISTIGNORESPACE is on */
X
XEXTERN int spaceflag;
X
X/* don't do spelling correction */
X
XEXTERN int nocorrect;
X
X/* != 0 means we have removed the current event from the history List */
X
XEXTERN int histremmed;
X
X/* the options; e.g. if opts['a'] == OPT_SET, -a is turned on */
X
XEXTERN int opts[128];
X
XEXTERN long lineno;		/* LINENO */
XEXTERN long listmax;		/* LISTMAX */
XEXTERN long savehist;	/* SAVEHIST */
XEXTERN long shlvl;		/* SHLVL */
XEXTERN long tmout;		/* TMOUT */
XEXTERN long dirstacksize;	/* DIRSTACKSIZE */
X
X/* != 0 means we have called execlist() and then intend to exit(),
X 	so don't fork if not necessary */
X
XEXTERN int exiting;
X
XEXTERN int lastbase;		/* last input base we used */
X
X/* the limits for child processes */
X
X#ifdef RLIM_INFINITY
XEXTERN struct rlimit limits[RLIM_NLIMITS];
X#endif
X
X/* the current word in the history List */
X
XEXTERN char *hlastw;
X
X/* pointer into the history line */
X
XEXTERN char *hptr;
X
X/* the current history line */
X
XEXTERN char *hline;
X
X/* the termcap buffer */
X
XEXTERN char termbuf[1024];
X
X/* $TERM */
X
XEXTERN char *term;
X
X/* != 0 if this $TERM setup is usable */
X
XEXTERN int termok;
X
X/* flag for CSHNULLGLOB */
X
XEXTERN int badcshglob;
X
X/* max size of hline */
X
XEXTERN int hlinesz;
X
X/* the alias expansion status - if == ALSTAT_MORE, we just finished
X	expanding an alias ending with a space */
X
XEXTERN int alstat;
X
X/* we have printed a 'you have stopped (running) jobs.' message */
X
XEXTERN int stopmsg;
X
X/* the default tty state */
X
XEXTERN struct ttyinfo shttyinfo;
X
X/* $TTY */
X
XEXTERN char *ttystrname;
X
X/* 1 if ttyctl -f has been executed */
X
XEXTERN int ttyfrozen;
X
X/* list of memory heaps */
X
XEXTERN Lklist heaplist;
X
X/* != 0 if we are allocating in the heaplist */
X
XEXTERN int useheap;
X
X#include "signals.h"
X
X#ifdef GLOBALS
X
X/* signal names */
Xchar **sigptr = sigs;
X
X/* tokens */
Xchar *ztokens = "#$^*()$=|{}[]`<>?~`,";
X
X#else
Xextern char *ztokens,**sigptr;
X#endif
X
X#define SIGERR (SIGCOUNT+1)
X#define SIGDEBUG (SIGCOUNT+2)
X#define VSIGCOUNT (SIGCOUNT+3)
X#define SIGEXIT 0
X
X/* signals that are trapped = 1, signals ignored =2 */
X
XEXTERN int sigtrapped[VSIGCOUNT];
X
X/* trap functions for each signal */
X
XEXTERN List sigfuncs[VSIGCOUNT];
X
X/* $HISTCHARS */
X
XEXTERN char bangchar,hatchar,hashchar;
X
XEXTERN int eofseen;
X
X/* we are parsing a line sent to use by the editor */
X
XEXTERN int zleparse;
X
XEXTERN int wordbeg;
X
XEXTERN int parbegin;
X
X/* interesting termcap strings */
X
X#define TCCLEARSCREEN 0
X#define TCLEFT 1
X#define TCMULTLEFT 2
X#define TCRIGHT 3
X#define TCMULTRIGHT 4
X#define TCUP 5
X#define TCMULTUP 6
X#define TCDOWN 7
X#define TCMULTDOWN 8
X#define TCDEL 9
X#define TCMULTDEL 10
X#define TCINS 11
X#define TCMULTINS 12
X#define TCCLEAREOD 13
X#define TCCLEAREOL 14
X#define TCINSLINE 15
X#define TCDELLINE 16
X#define TC_COUNT 17
X
X/* lengths of each string */
X
XEXTERN int tclen[TC_COUNT];
X
XEXTERN char *tcstr[TC_COUNT];
X
X#ifdef GLOBALS
X
X/* names of the strings we want */
X
Xchar *tccapnams[TC_COUNT] = {
X	"cl","le","LE","nd","RI","up","UP","do",
X	"DO","dc","DC","ic","IC","cd","ce","al","dl"
X	};
X
X#else
Xextern char *tccapnams[TC_COUNT];
X#endif
X
X#define tccan(X) (!!tclen[X])
X
X#define HISTFLAG_DONE   1
X#define HISTFLAG_NOEXEC 2
X#define HISTFLAG_RECALL 4
X
X#include "ztype.h"
X#include "funcs.h"
X
X#ifdef HAS_SETPGID
X#define setpgrp setpgid
X#endif
X
X#define _INCLUDE_POSIX_SOURCE
X#define _INCLUDE_XOPEN_SOURCE
X#define _INCLUDE_HPUX_SOURCE
X
X#ifdef SV_BSDSIG
X#define SV_INTERRUPT SV_BSDSIG
X#endif
X
X#ifdef HAS_SIGRELSE
X#define blockchld() sighold(SIGCHLD)
X#define unblockchld() sigrelse(SIGCHLD)
X#define chldsuspend() sigpause(SIGCHLD)
X#else
X#define blockchld() sigblock(sigmask(SIGCHLD))
X#define unblockchld() sigsetmask(0)
X#define chldsuspend() sigpause(0)
X#endif
SHAR_EOF
chmod 0644 zsh2.2/src/zsh.h ||
echo 'restore of zsh2.2/src/zsh.h failed'
Wc_c="`wc -c < 'zsh2.2/src/zsh.h'`"
test 31883 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zsh.h: original size 31883, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_vi.c ==============
if test -f 'zsh2.2/src/zle_vi.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_vi.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_vi.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_vi.c' &&
X/*
X *
X * zle_vi.c - vi-specific functions
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
X
Xstatic void startvichange(im)
Xint im;
X{
X	insmode = im;
X	if (vichgbuf) free(vichgbuf);
X	vichgbuf = zalloc(vichgbufsz = 16);
X	vichgbuf[0] = c;
X	vichgbufptr = 1;
X	vichgflag = 1;
X	viinsbegin = cs;
X}
X
Xstatic void startvitext(im)
X{
X	startvichange(im);
X	bindtab = mainbindtab;
X	undoing = 0;
X}
X
Xint vigetkey() /**/
X{
Xint ch;
X
X	if ((ch = getkey(0)) == -1)
X		return 0;
X	if (ch == 22)
X		{
X		if ((ch = getkey(0)) == -1)
X			return 0;
X		return ch;
X		}
X	else if (ch == 27)
X		return 0;
X	return ch;
X}
X
Xint getvirange(wf) /**/
Xint wf;
X{
Xint k2,t0,startline,endline;
X
X	startline = findbol();
X	endline = findeol();
X	for (;;) {
X		k2 = getkeycmd();
X		if (k2 == -1) {
X			feep();
X			return -1;
X		}
X		if (zlecmds[k2].flags & ZLE_ARG)
X			(*zlecmds[k2].func)();
X		else
X			break;
X	}
X	if (k2 == bindk) {
X		findline(&cs,&t0);
X		return (t0 == ll) ? t0 : t0+1;
X	}
X	if (!(zlecmds[k2].flags & ZLE_MOVEMENT)) {
X		feep();
X		return -1;
X	}
X	t0 = cs;
X
X	virangeflag = 1;
X	wordflag = wf;
X	(*zlecmds[k2].func)();
X	wordflag = virangeflag = 0;
X	if (cs == t0) {
X		feep();
X		return -1;
X	}
X	if (startline != findbol()) {
X		if (zlecmds[k2].flags & ZLE_LINEMOVE) {
X			if (cs < t0) {
X				cs = startline;
X				t0 = findeol()+1;
X			} else {
X				t0 = startline;
X				cs = findeol()+1;
X			}
X		} else {
X			if (cs < startline) cs = startline;
X			else if (cs >= endline) cs = endline-1;
X		}
X	}
X	if (cs > t0) {
X		k2 = cs;
X		cs = t0;
X		t0 = k2;
X	}
X	return t0;
X}
X
Xvoid viaddnext() /**/
X{
X	if (cs != ll)
X		cs++;
X	startvitext(1);
X}
X
Xvoid viaddeol() /**/
X{
X	cs = findeol();
X	startvitext(1);
X}
X
Xvoid viinsert() /**/
X{
X	startvitext(1);
X}
X
Xvoid viinsertbol() /**/
X{
X	cs = findbol();
X	startvitext(1);
X}
X
Xvoid videlete() /**/
X{
Xint c2;
X
X	startvichange(1);
X	if ((c2 = getvirange(0)) == -1)
X		{ vichgflag = 0; return; }
X	forekill(c2-cs,0);
X	vichgflag = 0;
X}
X
Xvoid vichange() /**/
X{
Xint c2;
X
X	startvichange(1);
X	if ((c2 = getvirange(1)) == -1)
X		{ vichgflag = 0; return; }
X	forekill(c2-cs,0);
X	bindtab = mainbindtab;
X	undoing = 0;
X}
X
Xvoid visubstitute() /**/
X{
X	if (mult < 0) return;
X	if (findeol()-cs < mult) mult = findeol()-cs;
X	if (mult) {
X		foredel(mult);
X		startvitext(1);
X	}
X}
X
Xvoid vichangeeol() /**/
X{
X	killline();
X	startvitext(1);
X}
X
Xvoid vichangewholeline() /**/
X{
Xint cq;
X
X	findline(&cs,&cq);
X	foredel(cq-cs);
X	startvitext(1);
X}
X
Xvoid viyank() /**/
X{
Xint c2;
X
X	if ((c2 = getvirange(0)) == -1) return;
X	cut(cs,c2-cs,0);
X}
X
Xvoid viyankeol() /**/
X{
Xint x = findeol();
X
X	if (x == cs)
X		feep();
X	else
X		cut(cs,x-cs,0);
X}
X
Xvoid vireplace() /**/
X{
X	startvitext(0);
X}
X
Xvoid vireplacechars() /**/
X{
Xint ch;
X
X	if (mult < 0) return;
X	if (mult+cs > ll) {
X		feep();
X		return;
X	}
X	startvichange(1);
X	if (ch = vigetkey()) while (mult--) line[cs++] = ch;
X	vichgflag = 0;
X	cs--;
X}
X
Xvoid vicmdmode() /**/
X{
X	bindtab = altbindtab;
X	if (cs) cs--;
X	undoing = 1;
X	if (vichgflag) vichgflag = 0;
X}
X
Xvoid viopenlinebelow() /**/
X{
X	cs = findeol();
X	spaceinline(1);
X	line[cs++] = '\n';
X	startvitext(1);
X}
X
Xvoid viopenlineabove() /**/
X{
X	cs = findbol();
X	spaceinline(1);
X	line[cs] = '\n';
X	startvitext(1);
X}
X
Xvoid vioperswapcase() /**/
X{
Xint c2;
X
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	while (cs < c2)
X		{
X		int ch = line[cs];
X
X		if (islower(ch))
X			ch = tuupper(ch);
X		else if (isupper(ch))
X			ch = tulower(ch);
X		line[cs++] = ch;
X		}
X}
X
Xvoid virepeatchange() /**/
X{
X	if (!vichgbuf || bindtab == mainbindtab || vichgflag) feep();
X	else ungetkeys(vichgbuf,vichgbufptr);
X}
X
Xvoid viindent() /**/
X{
Xint c2,endcs,t0,rmult;
X
X	if (mult < 0) { mult = -mult; viunindent(); return; }
X	rmult = mult;
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	if (cs != findbol()) { feep(); return; }
X	endcs = cs+rmult;
X	while (cs < c2) {
X		spaceinline(rmult);
X		for (t0 = 0; t0 != rmult; t0++) line[cs++] = '\t';
X		cs = findeol()+1;
X	}
X	cs = endcs;
X}
X
Xvoid viunindent() /**/
X{
Xint c2,endcs,t0,rmult;
X
X	rmult = mult;
X	if (mult < 0) { mult = -mult; viindent(); return; }
X	if ((c2 = getvirange(0)) == -1)
X		return;
X	if (cs != findbol()) { feep(); return; }
X	endcs = cs;
X	while (cs < c2) {
X		for (t0 = 0; t0 != rmult && line[cs] == '\t'; t0++) foredel(1);
X		cs = findeol()+1;
X	}
X	cs = endcs;
X}
SHAR_EOF
chmod 0644 zsh2.2/src/zle_vi.c ||
echo 'restore of zsh2.2/src/zle_vi.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_vi.c'`"
test 4793 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_vi.c: original size 4793, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/ztype.h ==============
if test -f 'zsh2.2/src/ztype.h' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/ztype.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/ztype.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/ztype.h' &&
X/*
X *
X * ztype.h - character classification macros
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define IDIGIT  1
X#define IALNUM  2
X#define IBLANK  4
X#define INBLANK 8
X#define ITOK    16
X#define ISEP    32
X#define IALPHA  64
X#define IIDENT  128
X#define IUSER   256
X#define ICNTRL  512
X#define IWORD	 1024
X#define ISPECIAL 2048
X#define _icom(X,Y) (typtab[(int) (unsigned char) (X)] & Y)
X#define idigit(X) _icom(X,IDIGIT)
X#define ialnum(X) _icom(X,IALNUM)
X#define iblank(X) _icom(X,IBLANK)		/* blank, not including \n */
X#define inblank(X) _icom(X,INBLANK)		/* blank or \n */
X#define itok(X) _icom(X,ITOK)
X#define isep(X) _icom(X,ISEP)
X#define ialpha(X) _icom(X,IALPHA)
X#define iident(X) _icom(X,IIDENT)
X#define iuser(X) _icom(X,IUSER)			/* username char */
X#define icntrl(X) _icom(X,ICNTRL)
X#define iword(X) _icom(X,IWORD)
X#define ispecial(X) _icom(X,ISPECIAL)
X
XEXTERN short int typtab[256];
X
SHAR_EOF
chmod 0644 zsh2.2/src/ztype.h ||
echo 'restore of zsh2.2/src/ztype.h failed'
Wc_c="`wc -c < 'zsh2.2/src/ztype.h'`"
test 1486 -eq "$Wc_c" ||
	echo 'zsh2.2/src/ztype.h: original size 1486, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_tricky.c ==============
if test -f 'zsh2.2/src/zle_tricky.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_tricky.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_tricky.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_tricky.c' &&
X/*
X *
X * zle_tricky.c - expansion and completion
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X#ifdef __hpux
X#include <ndir.h>
X#else
X#ifdef SYSV
X#define direct dirent
X#else
X#include <sys/dir.h>
X#endif
X#endif
X#include	<pwd.h>
X
Xstatic int we,wb,usemenu,useglob;
X
Xstatic int menub,menue,menuw;
SHAR_EOF
true || echo 'restore of zsh2.2/src/zle_tricky.c failed'
fi
echo 'End of zsh2.2 part 14'
echo 'File zsh2.2/src/zle_tricky.c is continued in part 15'
echo 15 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
