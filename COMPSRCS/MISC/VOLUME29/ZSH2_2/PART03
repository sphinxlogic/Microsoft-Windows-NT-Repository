Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i099:  zsh2.2 - The Z shell, Part03/17
Message-ID: <1992May13.155507.8157@sparky.imd.sterling.com>
X-Md4-Signature: 65c71c4552876273adb5ceffe88a0ed0
Date: Wed, 13 May 1992 15:55:07 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 99
Archive-name: zsh2.2/part03
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.03 (part 3 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/func/randline continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/func/randline'
else
echo 'x - continuing file zsh2.2/func/randline'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/func/randline' &&
Xinteger z=$(wc -l <$1)
Xsed -n $[RANDOM%z+1]p $1
SHAR_EOF
echo 'File zsh2.2/func/randline is complete' &&
chmod 0755 zsh2.2/func/randline ||
echo 'restore of zsh2.2/func/randline failed'
Wc_c="`wc -c < 'zsh2.2/func/randline'`"
test 80 -eq "$Wc_c" ||
	echo 'zsh2.2/func/randline: original size 80, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/func/yp ==============
if test -f 'zsh2.2/func/yp' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/func/yp (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/func/yp (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/func/yp' &&
X#! /bin/sh
Xypmatch $1 passwd
SHAR_EOF
chmod 0755 zsh2.2/func/yp ||
echo 'restore of zsh2.2/func/yp failed'
Wc_c="`wc -c < 'zsh2.2/func/yp'`"
test 29 -eq "$Wc_c" ||
	echo 'zsh2.2/func/yp: original size 29, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/func/yu ==============
if test -f 'zsh2.2/func/yu' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/func/yu (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/func/yu (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/func/yu' &&
X#! /bin/sh
Xypmatch $1 passwd.byuid
SHAR_EOF
chmod 0755 zsh2.2/func/yu ||
echo 'restore of zsh2.2/func/yu failed'
Wc_c="`wc -c < 'zsh2.2/func/yu'`"
test 35 -eq "$Wc_c" ||
	echo 'zsh2.2/func/yu: original size 35, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/man/man1/zsh.1 ==============
if test ! -d 'zsh2.2/man'; then
    echo 'x - creating directory zsh2.2/man'
    mkdir 'zsh2.2/man'
fi
if test ! -d 'zsh2.2/man/man1'; then
    echo 'x - creating directory zsh2.2/man/man1'
    mkdir 'zsh2.2/man/man1'
fi
if test -f 'zsh2.2/man/man1/zsh.1' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/man/man1/zsh.1 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/man/man1/zsh.1 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/man/man1/zsh.1' &&
X.\"
X.TH ZSH 1 "1992 May 2"
X.SH NAME
Xzsh \- the Z shell
X.SH SYNOPSIS
X\fBzsh\fP [ \(+-\fIoptions\fP ] [ \(+-\fBo\fP \fIoption\fP ] ...  [ \-\fBc\fP \fIstring\fP ] [ \fIarg\fP ... ]
X.SH "SHELL GRAMMAR"
XA \fIsimple command\fP is a sequence of optional parameter
Xassignments followed by blank-separated words,
Xwith optional redirections interspersed.
XThe first word is the command to be executed, and the remaining
Xwords, if any, are arguments to the command.
XIf a command name is given, the parameter assignments modify
Xthe environment of the command when it is executed.
XThe value of a simple command is its exit status,
Xor 128 plus the signal number if terminated by a signal.
X.PP
XIf a simple command is preceded by the word \fBexec\fP,
Xit is executed in the parent shell without forking.
XIf preceded by \fBcommand\fP, the command word is taken
Xto be the name of an external command, rather than a
Xshell function or builtin.
XIf preceded by \fBnoglob\fP, filename generation is not performed
Xon any of the words.  If preceded by a \-, the command
Xis executed with a \- prepended to its \fBargv[0]\fP string.
XIf preceded by \fBnocorrect\fP, spelling correction is not
Xdone on any of the words.
X.PP
XA \fIpipeline\fP is a sequence of one or more commands
Xseparated by \fB|\fP or \fB|&\fP.  \fB|&\fP is shorthand
Xfor \fB2>&1 |\fP.  The standard output of each command is
Xconnected to the standard input of the next command in the
Xpipeline.
X.PP
XThe value of a pipeline is the value of the last command.
XIf a pipeline is preceded by a \fB!\fP, the value
Xof that pipeline is the logical NOT of the value of the last
Xcommand.
X.PP
XIf a pipeline is preceded by \fBcoproc\fP, it is
Xexecuted as a coprocess; a two-way pipe is established
Xbetween it and the parent shell.  The shell can read from or write to
Xthe coprocess by means of the \fB>&p\fP and \fB<&p\fP
Xredirection operators.
X.PP
XA \fIsublist\fP is a sequence of one or more pipelines
Xseparated by \fB&&\fP or \fB|\||\fP.  If two pipelines
Xare separated by \fB&&\fP, the second pipeline is executed
Xonly if the first is successful (returns a zero value).
XIf two pipelines are separated by \fB|\||\fP, the second is executed
Xonly if the first is unsuccessful (returns a nonzero value).
X.PP
XA \fIlist\fP is a sequence of one or more sublists
Xseparated by, and optionally terminated by, \fB;\fP, \fB&\fP,
Xor a newline.
XNormally the shell waits for each list to finish before executing
Xthe next one.
XIf a list is terminated by a \fB&\fP, the shell executes
Xit in the background, and does not wait for it to finish.
X.PP
XA \fIcomplex command\fP is one of the following:
X.PP
X.RS
X.PD 0
X.TP
X\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExpand the list of \fIword\fPs, and set the parameter
X\fIname\fP to each of them in turn, executing
X\fIlist\fP each time.  If the \fBin\fP \fIword\fP is omitted,
Xuse the positional parameters instead of the \fIword\fPs.
X.TP
X\fBfor\fP \fIname\fP [ \fBin\fP \fIword\fP ... ] ; \fIsublist\fP
XThis is a shorthand for \fBfor\fP.
XThough it may cause confusion, it is included for convenience;
Xits use in scripts is discouraged,
Xunless \fIsublist\fP is a command of the form { \fIlist\fP }.
X.PP
X.PD 0
X.TP
X\fBforeach\fP \fIname\fP \fB(\fP \fIword\fP ... \fB)\fP
X.TP
X\fIlist\fP
X.TP
X\fBend\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fBin\fP \fIword\fP ...
X.TP
X\fB{\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBfor\fP \fIname\fP \fB(\fP \fIword\fP ... \fB) \fIsublist\fP
X.PD
XAnother form of \fBfor\fP.
X.PP
X.PD 0
X.TP
X\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ... ]
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XPrint the set of \fIword\fPs, each preceded by a number.
XIf the \fBin\fP \fIword\fP is omitted, use the positional parameters.
XThe \fBPROMPT3\fP prompt is printed and a line is read from standard
Xinput.  If this line consists of the number of one of the listed
X\fIword\fPs, then the parameter \fIname\fP
Xis set to the \fIword\fP corresponding to this number.
XIf this line is empty, the selection list is printed again.
XOtherwise, the value of the parameter \fIname\fP is set to null.
XThe contents of the line read from standard input is saved
Xin the parameter \fBREPLY\fP.  \fIlist\fP is executed
Xfor each selection until a break or end-of-file is encountered.
X.TP
X\fBselect\fP \fIname\fP [ \fBin\fP \fIword\fP ] ; \fIsublist\fP
XA short form of \fBselect\fP.
X.TP
X\fBcase\fP \fIword\fP \fBin\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fBesac\fP
XExecute the \fIlist\fP associated with the first \fIpattern\fP
Xthat matches \fIword\fP, if any.  The form of the patterns
Xis the same as that used for filename generation.  See
X\fIFilename Generation\fP below.
X.TP
X\fBcase\fP \fIword\fP \fB{\fP [ \fIpattern\fP ) \fIlist\fP ;; ] ...  \fB}\fP
XAnother form of \fBcase\fP.
X.TP
X.PD 0
X\fBif\fP \fIlist\fP
X.TP
X\fBthen\fP \fIlist\fP
X.TP
X[ \fBelif\fP \fIlist\fP ; \fBthen\fP \fIlist\fP ] ...
X.TP
X[ \fBelse\fP \fIlist\fP ]
X.TP
X\fBfi\fP
X.PD
XThe \fBif\fP \fIlist\fP is executed, and,
Xif it returns a zero exit status,
Xthe \fBthen\fP \fIlist\fP is executed.
XOtherwise, the \fBelif\fP \fIlist\fP is
Xexecuted and, if its value is zero,
Xthe \fBthen\fP \fIlist\fP is executed.
XIf each \fBelif\fP \fIlist\fP returns
Xnonzero, the \fBelse\fP \fIlist\fP is executed.
X.TP
X\fBif (\fP \fIlist\fP \fB)\fP \fIsublist\fP
XA short form of \fBif\fP.
X.PP
X.PD 0
X.TP
X\fBif\fP \fB(\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB} elif (\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB} ... else {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAn alternate form of \fBif\fP.
X.TP
X.PD 0
X\fBwhile\fP \fIlist\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExecute the \fBdo\fP \fIlist\fP as long as the \fBwhile\fP \fIlist\fP
Xreturns a zero exit status.
X.PP
X.PD 0
X.TP
X\fBwhile (\fP \fIlist\fP \fB) {\fP
X.TP
X\fIlist\fP
X.TP
X\fB}\fP
X.PD
XAn alternate form of \fBwhile\fP.
X.TP
X.PD 0
X\fBuntil\fP \fIlist\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
XExecute the \fBdo\fP \fIlist\fP as long as \fBuntil\fP \fIlist\fP
Xreturns a nonzero exit status.
X.TP
X.PD 0
X\fBrepeat\fP \fIword\fP
X.TP
X\fBdo\fP \fIlist\fP
X.TP
X\fBdone\fP
X.PD
X\fIword\fP is expanded and treated as an arithmetic expression,
Xwhich must evaluate to a number \fIn\fP.
X\fIlist\fP is then executed \fBn\fP times.
X.TP
X\fBrepeat\fP \fIword\fP \fIsublist\fP
XThis is a short form of \fBrepeat\fP.
X.TP
X( \fIlist\fP )
XExecute \fIlist\fP in a subshell.
X.TP
X{ \fIlist\fP }
XExecute \fIlist\fP.
X.TP
X.PD 0
X\fBfunction\fP \fIword\fP [ (\|) ] ... { \fIlist\fP }
X.TP
X\fIword\fP ... (\|) { \fIlist\fP }
X.TP
X\fIword\fP ... (\|) \fIsublist\fP
X.PD
XDefine a function which is referenced by any one of \fIword\fP.
XNormally, only one \fIword\fP is provided; multiple \fIword\fPs
Xare usually only useful for setting traps.
XThe body of the function is the \fIlist\fP between
Xthe { and }.
XSee \fBFUNCTIONS\fP below.
X.TP
X\fBtime\fP [ \fIpipeline\fP ]
XThe \fIpipeline\fP is executed, and timing statistics are
Xreported on the standard error in the form specified
Xby the \fBTIMEFMT\fP parameter.
XIf \fIpipeline\fP is omitted, print statistics about the
Xshell process and its children.
X.TP
X[[ \fIexp\fP ]]
XEvaluates the conditional expression \fIexp\fP
Xand return a zero exit status if it is true.
XSee \fBConditional Expressions\fP below for a description
Xof \fIexp\fP.
X.SH "RESERVED WORDS"
XThe following words are recognized as reserved words when used 
Xas the first word of a command
Xunless quoted or removed using the \fBunalias\fP builtin:
X.RS
X.PP
X\fBdo done esac then elif else fi for case
Xif while function repeat time until exec command
Xselect coproc noglob \- nocorrect foreach end\fP
X.RE
X.SH COMMENTS
XIn noninteractive shells, or in interactive shells with the
X\fBINTERACTIVE_COMMENTS\fP option set, a word beginning
Xwith the third character of the \fBHISTCHARS\fP parameter
X(`#' by default) causes that word and all the following
Xcharacters up to a newline to be ignored.
X.SH ALIASING
XEvery token in the shell input is checked to see if there
Xis an alias defined for it.
XIf so, it is replaced by the text of the alias if it is in command
Xposition (if it could be the first word of a simple command),
Xor if the alias is global.
XIf the text ends with a space, the next word in the shell input
Xis treated as though it were in command position for purposes of alias
Xexpansion.
XAn alias is defined using the \fBalias\fP builtin; global aliases
Xmay be defined using the \-\fBg\fP option to that bulitin.
X.PP
XAlias substitution is done on the shell input before any
Xother substitution except history substitution.  Therefore,
Xif an alias is defined for the word \fBfoo\fP, alias substitution
Xmay be avoided by quoting part of the word, e.g. \fB\efoo\fP.
XBut there is nothing to prevent an alias being defined
Xfor \fB\efoo\fP as well.
X.SH QUOTING
XA character may be \fIquoted\fP (that is, made
Xto stand for itself) by preceding it with a \e\|.
X\e followed by a newline is ignored.
XAll characters enclosed between a pair of single quotes ('')
Xare quoted.
XA single quote cannot appear within single quotes.
XInside double quotes (""), parameter and command substitution
Xoccurs, and \e quotes the characters \e\|, `, ", and $.
X.SH EXPANSION
XExpansion is performed on the command line after it has been
Xparsed.  The types of expansions performed are
X\fIfilename expansion\fP, 
X\fIprocess substitution\fP,
X\fIparameter expansion\fP,
X\fIcommand substitution\fP,
X\fIarithmetic expansion\fP,
X\fIbrace expansion\fP,
Xand \fIfilename generation\fP.
X.SS Filename Expansion
XEach word is checked to see if it begins with an unquoted ~.
XIf it does, then the word up to a / is checked to see if it matches
Xthe name of a named directory.  If so, then the ~ and the matched portion
Xare replaced with the value of the named directory.
XA ~ by itself or followed by a / is replaced by the value of the
X\fBHOME\fP parameter.
XA ~ followed by a + or a \- is replaced by the value of 
X\fBPWD\fP or \fBOLDPWD\fP, respectively.
X.PP
XNamed directories are typically login directories for users on the system.
XThey may also be defined if the text after the ~ is the name
Xof a shell parameter whose value begins with a /.
XIn certain circumstances (in prompts, for instance), when the shell
Xprints a path, the path is checked to see if it has a named
Xdirectory as its prefix.  If so, then the prefix portion
Xis replaced with a ~ followed by the name of the directory.
XThe longest match is preferred.
X.PP
XIf a word begins with an unquoted \fB=\fP and the
X\fBNO_EQUALS\fP option is not set,
Xthe remainder of the word is taken as the
Xname of a command or alias.  If a command
Xexists by that name, the word is replaced
Xby the full pathname of the command.
XIf an alias exists by that name, the word
Xis replaced with the text of the alias.
XOtherwise the word is checked up to a /
Xto see if it is a number or a \-.  If so,
Xthe matched portion is replaced with
Xthe \fIn\fPth directory in the directory stack,
Xwhere \fIn\fP is the number matched, or
Xthe last directory in the directory stack
Xif a \- is matched.
X.SS Process Substitution
XEach command argument of the form
X\fB<(\fIlist\^\fB)\fR
Xor
X\fB>(\fIlist\^\fB)\fR
Xor
X\fB=(\fIlist\^\fB)\fR
Xis subject to process substitution.
XIn the case of the
X.B <
Xor
X.B >
Xforms, the shell will run process
X.I list
Xasynchronously connected to a named pipe (FIFO).
XThe name of this pipe will become the argument to the command.
XIf the form with
X.B >
Xis selected then writing on this file will provide input for
X.IR list .
XIf
X.B <
Xis used,
Xthen the file passed as an argument will
Xbe a named pipe connected to the output of the
X.I list
Xprocess.
XFor example,
X.RS
X.PP
X\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) | tee >(\fIprocess1\fB) >(\fIprocess2\fB)\fR >/dev/null
X.RE
X.PP
X.BR cut s
Xfields 1 and 3 from
Xthe files
X.I file1
Xand
X.I file2
Xrespectively,
X.BR paste s
Xthe results together, and sends it to the processes
X.I process1
Xand
X.IR process2 .
XNote that the file, which is passed as an argument to the command,
Xis a system
Xpipe 
Xso programs that expect to
X.BR lseek (2)
Xon the file will not work.
XAlso note that the previous example can be more compactly and
Xefficiently written as:
X.RS
X.PP
X\fBpaste <(cut \-f1\fP \fIfile1\fB) <(cut \-f3\fP \fIfile2\fB) > >(\fIprocess1\fB) > >(\fIprocess2\fB)\fR
X.RE
X.PP
Xthe shell uses pipes instead of a FIFOs to implement the latter
Xtwo process substitutions in the above example.
X.PP
XIf
X.B =
Xis used,
Xthen the file passed as an argument will be the name
Xof a temporary file containing
Xthe output of the
X.I list
Xprocess.  This may be used instead of the
X.B <
Xform for a program that expects to \fBlseek\fP(2) on the input file.
X.SS Parameter Expansion
XThe character \fB$\fP is used to introduce parameter expansions.
XSee \fBPARAMETERS\fP below for a description of parameters.
X.PD
X.RS
X.TP
X\fB${\fIname\fB}\fR
XThe value, if any, of the parameter \fIname\fP is substituted.
XThe braces are required with \fIname\fP is followed by
Xa letter, digit, or underscore that is not to be interpreted
Xas part of its name.
XIf \fIname\fP is an array parameter, then the values of each
Xelement of \fIname\fP is substituted, one element per word.
XOtherwise, the expansion results in one word only; no
Xword splitting is done on the result.
X.TP
X\fB${\fIname\fB:\-\fIword\fB}\fR
XIf \fIname\fP is set and is non-null then substitute its
Xvalue; otherwise substitute \fIword\fP.
X.TP
X\fB${\fIname\fB:=\fIword\fB}\fR
XIf \fIname\fP is unset and is null then
Xset it to \fIword\fP; the value of the parameter is then
Xsubstituted.
X.TP
X\fB${\fIname\fB:?\fIword\fB}\fR
XIf \fIname\fP is set and is non-null, then substitute
Xits value; otherwise, print \fIword\fP and exit from the shell.
XIf \fIword\fP is omitted, then a standard message is printed.
X.TP
X\fB${\fIname\fB:+\fIword\fB}\fR
XIf \fIname\fP is set and is non-null then substitute
X\fIword\fP; otherwise substitute nothing.
X.PD 0
X.TP
X\fB${\fIname\fB#\fIpattern\fB}\fR
X.TP
X\fB${\fIname\fB##\fIpattern\fB}\fR
X.PD
XIf the \fIpattern\fP matches the beginning of the value of
X\fIname\fP, then substitute the value of \fIname\fP with
Xthe matched portion deleted; otherwise, just
Xsubstitute the value of \fIname\fP.  In the first
Xform, the smallest matching pattern is preferred;
Xin the second form, the largest matching pattern is preferred.
X.PD 0
X.TP
X${\fIname\fB%\fIpattern\fR}
X.TP
X${\fIname\fB%%\fIpattern\fR}
X.PD
XIf the \fIpattern\fP matches the end of the value of
X\fIname\fP, then substitute the value of \fIname\fP with
Xthe matched portion deleted; otherwise, just
Xsubstitute the value of \fIname\fP.  In the first
Xform, the smallest matching pattern is preferred;
Xin the second form, the largest matching pattern is preferred.
X.TP
X${\fB#\fIspec\fR}
XIf \fIspec\fP is one of the above substitutions, substitute
Xthe length in characters of the result instead of
Xthe result itself.  If \fIspec\fP is an array expression,
Xsubstitute the number of elements of the result.
X.TP
X${\fB^\fIspec\fR}
XToggle the value of the \fBRC_EXPAND_PARAM\fP option for the
Xevaluation of \fIspec\fP.
XWhen this option is set, array expansions of the form
X\fIfoo\fB${\fIxx\fB}\fIbar\fR, where the parameter
X\fIxx\fP is set to (\fIa b c\fP), are substituted with
X\fIfooabar foobbar foocbar\fP instead of the default
X\fIfooa b cbar\fP.
X.TP
X${\fB=\fIspec\fR}
XToggle the value of the \fBSH_WORD_SPLIT\fP option for the
Xevaluation of \fIspec\fP.
XWhen this option is set, parameter values are split into
Xseparate words using \fBIFS\fP as a delimiter
Xbefore substitution.
XThis is done by default in most other shells.
X.PD
X.RE
X.PP
XIf the colon is omitted from one of the above expressions
Xcontaining a colon, then the shell only checks whether
X\fIname\fP is set or not, not whether it is null.
X.SS Command Substitution
XA command enclosed in parentheses
Xpreceded by a dollar sign, like so: $(...) or quoted with grave
Xaccents: `...` is replaced with its standard output.
XIf the substitution is not enclosed in double quotes, the
Xoutput is broken into words using the \fBIFS\fP parameter.
XThe substitution \fB$(cat foo)\fP may be replaced
Xby the equivalent but faster \fB$(<foo)\fP.
X.SS Arithmetic Expansion
XA string of the form \fB$[\fIexp\fB]\fR is substituted
Xwith the value of the arithmetic expression \fIexp\fP.
X\fIexp\fP is treated as if it were within single quotes.
XSee \fBARITHMETIC EVALUATION\fP below.
X.SS Brace Expansion
XA string of the form
X\fIfoo\fB{\fIxx\fB,\fIyy\fB,\fIzz\fB}\fIbar\fR
Xis expanded to the individual words
X\fIfooxxbar\fP, \fIfooyybar\fP, and \fIfoozzbar\fP.
XLeft-to-right order is preserved.  This construct
Xmay be nested.  Malformed brace expansion expressions,
Xincluding expressions without a comma, are left unchanged
Xby the shell.
X.PP
XAn expression of the form
X\fB{\fIx\fB\-\fIy\fB}\fR,
Xwhere \fIx\fP and \fIy\fP are single characters,
Xis expanded to every character between
X\fIx\fP and \fIy\fP, inclusive.
X.SS Filename Generation
XIf a word contains an unquoted instance of one of the characters
X*, |, <, [, or ?, it is regarded
Xas a pattern for filename generation, unless the \fBNOGLOB\fP option is set.
XIf the \fBEXTENDED_GLOB\fP option is set, the
X^ and # characters also denote a pattern; otherwise
Xthey are not treated specially by the shell.
XThe word is replaced with a list of sorted filenames that match
Xthe pattern.  If no matching pattern is found, the shell gives
Xan error message, unless the \fBNULLGLOB\fP option is set,
Xin which case the word is deleted; or unless the \fBNO_NOMATCH\fP
Xoption is set, in which case the word is left unchanged.
XIn filename generation,
Xthe character / must be matched explicitly; also, a . must be matched
Xexplicitly at the beginning of a pattern or after a /, unless the
X\fBGLOBDOTS\fP option is set.  No filename generation pattern
Xmatches the files "." or "..".  In other instances of pattern
Xmatching, the / and . are not treated specially.
X.PP
X.RS
X.PD 0
X.TP
X.B *
Xmatches any string, including the null string.
X.TP
X.B ?
Xmatches any character.
X.TP
X\fB[ ... ]\fP
Xmatches any of the enclosed characters.
X.TP
X\fB[^ ... ]\fP
Xmatches any character except the enclosed characters.
X.TP
X\fB<x\-y>\fP
Xmatches any number in the range x to y, inclusive.
XIf x is omitted, the number must be less than or equal to y.
XIf y is omitted, the number must be greater than or equal to x.
XA pattern of the form \fB<\->\fP or
Xsimply \fB<>\fP matches any number.
X.TP
X\fB^x\fP
Xmatches anything except the pattern x.
X.TP
X\fBx|y\fP
Xmatches either x or y.
X.TP
X\fBx#\fP
Xmatches zero or more occurrences of the pattern x.
X.TP
X\fBx##\fP
Xmatches one or more occurrences of the pattern x.
X.RE
X.PD
X.PP
XParentheses may be used for grouping.  Note that the \fB|\fP character
Xmust be within parentheses, so that the lexical analyzer does
Xnot think it is a pipe character.  Also note that "/" has a
Xhigher precedence than "^"; that is:
X.RS
X.PP
Xls
X.BI ^ foo / bar
X.RE
X.PP
Xwill search directories in "." except "./foo" for a file named bar.
X.PP
XA pathname component of the form
X.BI ( foo /)#
Xmatches a path consisting of zero or more directories
Xmatching the pattern foo.
XAs a shorthand,
X.B **/
Xis equivalent to
X.BR (*/)# .
XThus:
X.RS
X.PP
Xls
X.BI (*/)# bar
X.RE
X.PP
Xor
X.RS
X.PP
Xls
X.BI **/ bar
X.RE
X.PP
Xdoes a recursive directory search for files named bar.
X.PP
XIf used for filename generation, a pattern may contain an exclusion
Xspecifier.  Such patterns are of the form \fIpat1\fB~\fIpat2\fR.
XThis pattern will generate all files matching \fIpat1\fP, but which
Xdo not match \fIpat2\fP.  For example, \fB*.c~lex.c\fP will match
Xall files ending in .c, except the file \fBlex.c\fP.
X.PP
XPatterns used for filename generation may also end in a
Xlist of qualifiers enclosed in parentheses.
XThe qualifiers
Xspecify which filenames that otherwise match the given pattern
Xwill be inserted in the argument list.
XA qualifier may be any one of the following:
X.PD 0
X.RS
X.TP
X.B /
Xdirectories
X.TP
X.B .
Xplain files
X.TP
X.B @
Xsymbolic links
X.TP
X.B =
Xsockets
X.TP
X.B p
Xnamed pipes (FIFOs)
X.TP
X.B *
Xexecutable plain files (0100)
X.TP
X.B %
Xdevice files (character or block special)
X.TP
X.B r
Xreadable files (0400)
X.TP
X.B w
Xwritable files (0200)
X.TP
X.B x
Xexecutable files (0100)
X.TP
X.B R
Xworld-readable files (0004)
X.TP
X.B W
Xworld-writable files (0002)
X.TP
X.B X
Xworld-executable files (0001)
X.TP
X.B s
Xsetuid files (04000)
X.TP
X.B S
Xsetgid files (02000)
X.TP
X\fBd\fIdev\fR
Xfiles on the device \fIdev\fP
X.TP
X\fBl\fIct\fR
Xfiles having a link count of \fIct\fP
X.TP
X\fBU\fP
Xfiles owned by the effective user id
X.TP
X\fBG\fP
Xfiles owned by the effective group id
X.TP
X\fBu\fInum\fR
Xfiles owned by user id \fInum\fP
X.TP
X\fBg\fInum\fR
Xfiles owned by group id \fInum\fP
X.TP
X\fB^\fP
Xnegates all qualifiers following it
X.TP
X\fBM\fP
Xsets the \fBMARKDIRS\fP option for the current pattern
X.TP
X\fBN\fP
Xsets the \fBNULLGLOB\fP option for the current pattern
X.TP
X\fBD\fP
Xsets the \fBGLOBDOTS\fP option for the current pattern
X.PD
X.RE
X.PP
XThus:
X.RS
X.PP
Xls
X.B
X*(%W)
X.RE
X.PP
Xlists all world-writable device files in the current directory,
Xand
X.RS
X.PP
Xls
X.B /tmp/foo*(u0^@)
X.RE
X.PP
Xlists all root-owned files beginning with the string
X"foo" in /tmp, ignoring symlinks, and
X.RS
X.PP
Xls
X.B *.*~(lex|parse).[ch](^D^l1)
X.RE
X.PP
Xlists all files having a link count of one whose names contain a dot
X(but not those starting with a dot, since \fBGLOBDOTS\fP is explicitly
Xswitched off) except for lex.c, lex.h, parse.c, and parse.h.
XA "/" at the end of a pattern
Xis equivalent to "(\|/\|)".
X.SH REDIRECTION
XBefore a command is executed, its input and output
Xmay be redirected.
XThe following may appear anywhere in a simple-command
Xor may precede or follow a complex command.
XSubstitution occurs before
X.I word
Xis used except as noted below.
XIf the result of substitution on
X.I word
Xproduces more than one filename,
Xredirection occurs for each
Xseparate filename in turn.
X.TP
X.BI < word
XOpen file
X.I word
Xas standard input.
X.TP
X.BI > word
XOpen file
X.I word
Xas standard output.
XIf the file does not exist then it is created.
XIf the file exists, and the
X.B NOCLOBBER
Xoption is set,
Xthis causes an error;
Xotherwise, it is truncated to zero length.
X.TP
X.BI >! " word"
XSame as
X.BR > ,
Xexcept that the file is truncated to zero length
Xif it exists, even if
X.B NOCLOBBER
Xis set.
X.TP
X.BI >> word
XOpen file
X.I word
Xas standard output.
XIf the file exists then output is appended to it.
XIf the file does not exist, and the
X.B NOCLOBBER
Xoption is set,
Xthis causes an error;
Xotherwise, the file is created.
X.TP
X.BI >>! " word"
XSame as
X.BR >> ,
Xexcept that the file is created if it does not
Xexist, even if
X.B NOCLOBBER
Xis set.
X.TP
X\fB<<\fP[\-] \fIword\fP
XThe shell input is read up to a line that is the same as
X.IR word ,
Xor to an end-of-file.
XNo parameter substitution, command substitution or
Xfilename generation is performed on
X.IR word .
XThe resulting document,
Xcalled a
X.IR here-document ,
Xbecomes
Xthe standard input.
XIf any character of \fIword\fP is quoted with
Xsingle or double quotes (a \e alone is \fInot\fP sufficient),
Xno interpretation
Xis placed upon the characters of the document.
XOtherwise, parameter and command substitution
Xoccurs, \e followed by a newline is removed,
Xand \e must be used to quote the characters
X\e, $, `, and the first character of \fIword\fP.
XIf <<\- is used, then all leading
Xtabs are stripped from \fIword\fP and from the document.
X.TP
X.BI <<< word
XOpen a file containing \fIword\fP, after expansion,
Xas standard input.
X.TP
X.BI <& digit
XThe standard input
Xis duplicated from file descriptor
X.I digit
X(see
X.IR dup (2)).
XSimilarly for standard output using
X\fB>&\fIdigit\fP.
X.TP
X.BI >& word
XSame as
X.BI > word
X\fB2>&\fP1.
X.TP
X.BI >>& word
XSame as
X.BI >> word
X\fB2>&\fP1.
X.TP
X.BI <&\-
XClose the standard input.
X.TP
X.BI >&\-
XClose the standard output.
X.TP
X.BI <&p
XThe input from the coprocess is moved to the standard input.
X.TP
X.BI >&p
XThe output to the coprocess is moved to the standard output.
X.PP
XIf one of the above is preceded by a digit, then the file
Xdescriptor referred to is that specified by the digit
X(instead of the default 0 or 1).
XThe order in which redirections are specified is significant.
Xthe shell evaluates each redirection in terms of the
X.RI ( "file descriptor" ", " file )
Xassociation at the time of evaluation.
XFor example:
X.RS
X.PP
X\&.\|.\|. \|1>\fIfname\^\fP 2>&1
X.RE
X.PP
Xfirst associates file descriptor 1 with file
X.IR fname .
XIt then associates file descriptor 2 with the file associated with file
Xdescriptor 1 (that is,
X.IR fname ).
XIf the order of redirections were reversed, file descriptor 2 would be associated
Xwith the terminal (assuming file descriptor 1 had been) and then file descriptor
X1 would be associated with file
X.IR fname .
X.PP
XIf the user tries to open a file descriptor for writing more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xits input to all the specified outputs, similar to tee(1).  Thus:
X.RS
X.PP
X.B date >foo >bar
X.RE
X.PP
Xwrites the date to two files, named "foo" and "bar".
XNote that a pipe is an implicit indirection; thus
X.RS
X.PP
X.B date >foo | cat
X.RE
X.PP
Xwrites the date to the file "foo", and also pipes it to cat.
X.PP
XIf the user tries to open a file descriptor for reading more than once,
Xthe shell opens the file descriptor as a pipe to a process that copies
Xall the specified inputs to its output in the order
Xspecified, similar to cat(1).  Thus
X.RS
X.PP
X.B sort <foo <fubar
X.RE
X.PP
Xor even
X.RS
X.PP
X.B sort <f{oo,ubar}
X.RE
X.PP
Xis equivalent to "cat foo bar | sort".  Note that
Xa pipe is in implicit indirection; thus
X.RS
X.PP
X.B cat bar | sort <foo
X.RE
X.PP
Xis equivalent to "cat bar foo | sort" (note the order of the inputs).
X.PP
XIf a simple command consists of one or more redirection operators
Xand zero or more parameter assignments, but no command name,
Xthe command \fBcat\fP is assumed.  Thus
X.RS
X.PP
X.B < file
X.RE
X.PP
Xprints the contents of \fBfile\fP.
X.PP
XIf a command is followed by
X.B &
Xand job control is not active,
Xthen the default standard input
Xfor the command
Xis the empty file
X.BR /dev/null .
XOtherwise, the environment for the execution of a command contains the
Xfile descriptors of the invoking shell as modified by
Xinput/output specifications.
X.SH "COMMAND EXECUTION"
XIf a command name contains no slashes, the shell attempts to locate
Xit.  If there exists a shell function by that name, the function
Xis invoked as described below in \fBFUNCTIONS\fP.  If there exists
Xa shell builtin by that name, the builtin is invoked.
X.PP
XOtherwise, the shell searches each element of \fBpath\fP for a
Xdirectory containing an executable file by that name.  If the
Xsearch is unsuccessful, the shell prints an error message and returns
Xa nonzero exit status.
X.PP
XIf execution fails because the file is not in executable format,
Xand the file is not a directory, it is assumed to be a shell
Xscript.  /bin/sh is spawned to execute it.  If the program
Xis a file beginning with \fB#!\fP, the remainder of the first line
Xspecifies an interpreter for the program.  The shell will
Xexecute the specified interpreter on operating systems that do
Xnot handle this executable format in the kernel.
X.SH FUNCTIONS
X.PP
XThe
X.B function
Xreserved word is used to define shell functions.
XShell functions are read in and stored internally.
XAlias names are resolved when the function is read.
XFunctions are executed like commands with the arguments
Xpassed as positional parameters.
X(See
X.I Execution
Xbelow).
X.PP
XFunctions execute in the same process as the caller and
Xshare all files
Xand present working directory with the
Xcaller.
XA trap on
X.B EXIT
Xset inside a function
Xis executed after the function completes in the environment
Xof the caller.
X.PP
XThe
X.B return
Xbuiltin is used to return
Xfrom function calls.
X.PP
XFunction identifiers
Xcan be listed with the
X.B functions
Xbuiltin.
XFunctions can be undefined with the
X.B unfunction
Xbuiltin.
X.PP
XThe following functions, if defined, have special meaning to
Xthe shell:
X.PP
X.PD 0
X.TP
X\fBchpwd\fP
XExecuted whenever the current working directory is changed.
X.TP
X\fBprecmd\fP
XExecuted before each prompt.
X.TP
X\fBperiodic\fP
XIf the parameter
X.B PERIOD
Xis set, this function is executed every
X.B PERIOD
Xseconds, just before a prompt.
X.TP
X\fBTRAPxxx\fP
XIf defined and non-null,
Xthis function will be executed whenever the shell
Xcatches a signal \fBSIGxxx\fP, where \fBxxx\fP is a signal
Xname as specified for the \fBkill\fP builtin (see below).
XIn addition, \fBTRAPERR\fP is executed whenever a command has a non-zero
Xexit status, \fBTRAPDEBUG\fP is executed after each command, and
X\fBTRAPEXIT\fP
Xis executed when the shell exits,
Xor when the current function exits if defined
Xinside a function.
XIf a function of this form is defined and null,
Xthe shell and processes spawned by it will ignore \fBSIGxxx\fP.
X.PD
X.SH JOBS
X.PP
XIf the
X.B MONITOR
Xoption is set,
Xan interactive shell associates a \fIjob\fR with each pipeline.
XIt keeps
Xa table of current jobs, printed by the
X.B jobs
Xcommand, and assigns them small integer numbers.
XWhen a job is started asynchronously with
X.BR & ,
Xthe shell prints a line which looks
Xlike:
X.PP
X.DT
X	[1] 1234
X.PP
Xindicating that the job which was started asynchronously was job number
X1 and had one (top-level) process, whose process id was 1234.
X.PP
XIf you are running a job and wish to do something else you may hit the key
X\fB^Z\fR (control-Z) which sends a STOP signal to the current job.
Xthe shell will then normally indicate that the job has been `suspended',
Xand print another prompt.
XYou can then manipulate the state of this job,
Xputting it in the background with the
X.B bg
Xcommand, or run some other
Xcommands and then eventually bring the job back into the foreground with
Xthe foreground command
X.BR fg .
XA \fB^Z\fR takes effect immediately and
Xis like an interrupt in that pending output and unread input are discarded
Xwhen it is typed.
X.PP
XA job being run in the background will suspend if it tries to read
Xfrom the terminal.
XBackground jobs are normally allowed to produce output,
Xbut this can be disabled by giving the command ``stty tostop''.
XIf you set this
Xtty option, then background jobs will suspend when they try to produce
Xoutput like they do when they try to read input.
X.PP
XThere are several ways to refer to jobs in the shell.
XA job can be referred to by the process id of any process of the job
Xor by one of the following:
X.PD 0
X.TP
X.BI % number
XThe job with the given number.
X.TP
X.BI % string
XAny job whose command line begins with
X.IR string .
X.TP
X.BI %? string
XAny job whose command line contains
X.IR string .
X.TP
X.BI %%
XCurrent job.
X.TP
X.BI %+
XEquivalent to
X.BR %% .
X.TP
X.BI %\-
XPrevious job.
X.PD
X.PP
XThe shell learns immediately whenever a process changes state.
XIt normally informs you whenever a job becomes blocked so that
Xno further progress is possible.  If
X.B notify
Xis not set, it waits until
Xjust before it prints
Xa prompt before it informs you.
X.PP
XWhen the monitor mode is on, each background job that completes
Xtriggers any trap set for
X.BR CHLD .
X.PP
XWhen you try to leave the shell while jobs are running or suspended, you will
Xbe warned that `You have suspended (running) jobs.'
XYou may use the
X.B jobs
Xcommand to see what they are.
XIf you do this or immediately try to
Xexit again, the shell will not warn you a second time; the suspended
Xjobs will be terminated, and the running jobs will be sent
Xa \fBSIGHUP\fP signal.
XTo avoid having the shell terminate the running jobs, either
Xuse the \fBnohup\fP(1) command or the \fBdisown\fP builtin (see below).
X.SH SIGNALS
XThe INT and QUIT signals for an invoked
Xcommand are ignored if the command is followed by
X.B &
Xand job
X.B monitor
Xoption is not active.
XOtherwise, signals have the values
Xinherited by the shell from its parent
X(but see the \fBTRAPxxx\fP special function above).
X.SH HISTORY
XHistory substitution allows you to use words from previous command
Xlines in the command line you are typing.  This simplifies spelling
Xcorrections and the repetition of complicated commands or arguments.
XCommand lines are saved in the history list, the size of which
Xis controlled by the
X.B HISTSIZE
Xvariable.  The most recent command is retained in any case.
XA history substitution begins with a
X.B !
Xand may occur anywhere on the command line; history
Xsubstitutions do not nest.  The
X.B !
Xcan be escaped with
X.B \e
Xto suppress its special meaning.
XSingle or double quotes will \fInot\fP work for this.
X.PP
XInput lines containing history substitutions are echoed on the
Xterminal after being expanded, but before any other
Xsubstitutions take place or the command gets executed.
X.SS Event Designators
X.PP
XAn event designator is a reference to a command-line entry in
Xthe history list.
X.RS
X.PD 0
X.TP
X.B !
XStart a history substitution, except when followed by a blank, newline,
X.BR = ,
Xor
X.BR ( .
X.TP
X.B !!
XRefer to the previous command. 
XBy itself, this substitution
Xrepeats the previous command.
X.TP
X.BI ! n
XRefer to command-line
X.IR n .
X.TP
X.BI ! \-n
XRefer to the current command-line minus
X.IR n .
X.TP
X.BI  ! str
XRefer to the most recent command starting with
X.IR str .
X.TP
X.BI  !? str\fR[\fP ? \fR]\fP
XRefer to the most recent command containing
X.IR str .
X.TP
X.B !#
XRefer to the current command line typed in so far.
X.TP
X.BR !{ .\|.\|. }
XInsulate a history reference from adjacent characters (if necessary).
X.PD
X.RE
X.SS Word Designators
X.PP
XA
X.RB ` : '
Xseparates the event specification from the word designator. 
XIt can be omitted if the word designator begins with a
X.BR \*^ ,
X.BR $ ,
X.BR * ,
X.B \-
Xor
X.BR % .
XIf the word is to be selected from the previous command, the second
X.B !
Xcharacter can be omitted from the event specification.  For instance,
X.B !!:1
Xand
X.B !:1
Xboth refer to the first word of the previous command, while
X.B !!$
Xand
X.B !$
Xboth refer to the last word in the previous command. 
XWord designators include:
X.RS
X.PD 0
X.TP
X.B 0
XThe first input word (command).
X.TP
X.I n
XThe
X.IR n 'th
Xargument.
X.TP
X.B ^
XThe first argument, that is,
X.BR 1 .
X.TP
X.B $
XThe last argument.
X.TP
X.B %
XThe word matched by (the most recent)
X.BI ? s
Xsearch.
X.TP
X.IB x \- y
XA range of words;
X.BI \- y
Xabbreviates
X.BI 0\- y\fR.
X.TP
X.B *
XAll the arguments, or a null value if there is just
Xone word in the event.
X.TP
X.IB x *
XAbbreviates
X.IB x \-$ .
X.TP
X.IB x \-
XLike
X.I x*
Xbut omitting word
X.BR $ .
X.PD
X.RE
X.SS Modifiers
X.PP
XAfter the optional word designator, you can add
Xa sequence of one or more of the following modifiers,
Xeach preceded by a
X.BR : .
XThese modifiers also work on the result
Xof filename and parameter expansion.
X.RS
X.TP
X.B h
XRemove a trailing pathname component, leaving the head.
X.PD 0
X.TP
X.B r
XRemove a trailing suffix of the form
X.RB ` "\&.\fIxxx" ',
Xleaving the basename.
X.TP
X.B e
XRemove all but the suffix.
X.TP
X.B t
XRemove all leading pathname components, leaving the tail.
X.TP
X.B &
XRepeat the previous substitution.
X.TP
X.B g
XApply the change to the first occurrence of a match in each word,
Xby prefixing the above (for example,
X.BR g& ).
X.TP
X.B p
XPrint the new command but do not execute it.
X.TP
X.B q
XQuote the substituted words, escaping further substitutions.
X.TP
X.B x
XLike
X.BR q ,
Xbut break into words at each blank.
X.TP
X.B l
XConvert the words to all lowercase.
X.TP
X.B u
XConvert the words to all uppercase.
X.TP
X.BI s/ l / r\fR[\fP / \fR]\fP
XSubstitute
X.I r
Xfor
X.IR l .
X.PD
X.RE
X.PP
XUnless preceded by a
X.BR g ,
Xthe substitution is done only for the
Xfirst string that matches
X.IR l .
X.PP
XThe left-hand side of substitutions are not regular expressions,
Xbut character strings.
XAny character can be used as the delimiter in place of
X.BR / .
XA backslash quotes the delimiter character.
XThe character
X.BR & ,
Xin the right hand side, is replaced by the text
Xfrom the left-hand-side. 
XThe
X.B &
Xcan be quoted with a backslash. 
XA null
X.I l
Xuses the previous string either from a
X.I l
Xor from a contextual scan string
X.I s
Xfrom
X.BI !? s\fR.
XYou can omit the rightmost delimiter if a newline
Ximmediately follows
X.IR r ;
Xthe rightmost
X.B ?
Xin a context scan can similarly be omitted.
X.PP
XWithout an event specification, a history reference refers either to the
Xprevious command, or to a previous history reference on the command line
X(if any).
X.PP
XThe character sequence
X.BI ^ foo ^ bar
Xrepeats the last command, replacing the string "foo" with the
Xstring "bar".
X.PP
XIf the shell encounters the character sequence
X\fB!"\fP
Xin the input, the history mechanism is temporarily disabled until
Xthe current list is fully parsed.  The
X\fB!"\fP
Xis removed from the input, and any subsequent
X.B !
Xcharacters have no special significance.
X.PP
XA less convenient but more comprehensible
Xform of command history support
Xis provided by the
X.B fc
Xbuiltin (see below).
X.SH "ARITHMETIC EVALUATION"
XAn ability to perform integer arithmetic
Xis provided with the builtin
X.BR let .
XEvaluations are performed using
X.I long
Xarithmetic.
XConstants are of the form
X[\fIbase\fB#\^\fR]\fIn\^\fP
Xwhere
X.I base
Xis a decimal number between two and thirty-six
Xrepresenting the arithmetic base
Xand
X.I n
Xis a number in that base.
XIf
X.I base
Xis omitted
Xthen base 10 is used.
X.PP
XAn arithmetic expression uses nearly the same syntax, precedence, and
Xassociativity of
Xexpressions in C.
XThe following operators are supported (listed in decreasing order
Xof precedence):
X.PP
X.PD 0
X.RS
X.TP
X.B + \- ! \(ap ++ \-\|\-
Xunary plus/minus, logical NOT, complement, {pre,post}{in,de}crement
X.TP
X.B &
Xlogical AND
X.TP
X.B ^
Xlogical XOR
X.TP
X.B |
Xlogical OR
X.TP
X.B * / %
Xmultiplication, division, remainder
X.TP
X.B + \-
Xaddition, subtraction
X.TP
X.B << >>
Xlogical shift left, shift right
X.TP
X.B < > <= >=
Xcomparison
X.TP
X.B == !=
Xequality and inequality
X.TP
X.B &&
Xboolean AND
X.TP
X.B |\|| ^^
Xboolean OR, XOR
X.TP
X.B ? :
Xternary operator
X.TP
X.B
X= += \-= *= /= %= &= ^= |= <<= >>= &&= |\||= ^^=
Xassignment
X.TP
X.B ,
Xcomma operator
X.PD
X.RE
X.PP
XThe operators &&, |\||, &&=, and |\||= are short-circuiting,
Xand only one of the latter two expressions in a ternary operator
Xis evaluated.  Note the precedence of the logical AND, OR,
Xand XOR operators.
X.PP
XNamed parameters can be referenced by name within an arithmetic expression
Xwithout using the parameter substitution syntax.
X.PP
XAn internal integer representation of a named parameter
Xcan be specified with the
X.B integer
Xbuiltin.
XArithmetic evaluation is performed on the value of each
Xassignment to a named parameter declared integer
Xin this manner.
X.PP
XSince many of the arithmetic operators require
Xquoting, an alternative form of the
X.B let
Xcommand is provided.
XFor any command which begins with a
X.BR (( ,
Xall the characters until a matching
X.B ))
Xare treated as a quoted expression.
XMore precisely,
X.BR (( ... ))
Xis equivalent to
X.B let
X\fB"\fP...\fB"\fP.
X.SH "CONDITIONAL EXPRESSIONS"
XA \fIconditional expression\fP is used with the
X.B [[
Xcompound command to test attributes of files and to compare strings.
XEach expression can be constructed from one or more
Xof the following unary or binary expressions:
X.PD 0
X.TP
X\fB\-a\fP \fIfile\fP
Xtrue if
X.I file
Xexists.
X.TP
X\fB\-b\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a block special file.
X.TP
X\fB\-c\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a character special file.
X.TP
X\fB\-d\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a directory.
X.TP
X\fB\-e\fP \fIfile\fP
Xtrue if
X.I file
Xexists.
X.TP
X\fB\-f\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is an ordinary file.
X.TP
X\fB\-g\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is has its setgid bit set.
X.TP
X\fB\-h\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a symbolic link.
X.TP
X\fB\-k\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is has its sticky bit set.
X.TP
X\fB\-n\fP \fIstring\fP
Xtrue if length of
X.I string
Xis non-zero.
X.TP
X\fB\-o\fP \fIoption\fP
Xtrue if option named
X.I option
Xis on.
X.TP
X\fB\-p\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a fifo special file or a pipe.
X.TP
X\fB\-r\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is readable by current process.
X.TP
X\fB\-s\fP \fIfile\fP
Xtrue if
X.I file
Xexists and has size greater than zero.
X.TP
X\fB\-t\fP \fIfd\fP
Xtrue if file descriptor number
X.I fd
Xis open and associated with a terminal device.
X(note: \fIfd\fP is not optional)
X.TP
X\fB\-u\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is has its setuid bit set.
X.TP
X\fB\-w\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is writable by current process.
X.TP
X\fB\-x\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is executable by current process.
XIf
X.I file
Xexists and is a directory, then the current process
Xhas permission to search in the directory.
X.TP
X\fB\-z\fP \fIstring\fP
Xtrue if length of
X.I string
Xis zero.
X.TP
X\fB\-L\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a symbolic link.
X.TP
X\fB\-O\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is owned by the effective user id of this process.
X.TP
X\fB\-G\fP \fIfile\fP
Xtrue if
X.I file
Xexists and its group matches the effective group id of this process.
X.TP
X\fB\-S\fP \fIfile\fP
Xtrue if
X.I file
Xexists and is a socket.
X.TP
X\fIfile1\fP \fB\-nt\fP \fIfile2\fP
Xtrue if
X.I file1
Xexists and is newer than
X.IR file2 .
X.TP
X\fIfile1\fP \fB\-ot\fP \fIfile2\fP
Xtrue if
X.I file1
Xexists and is older than
X.IR file2 .
X.TP
X\fIfile1\fP \fB\-ef\fP \fIfile2\fP
Xtrue if
X.I file1
Xand 
X.I file2
Xexist and refer to the same file.
X.TP
X\fIstring\fP \fB=\fP \fIpattern\fP
Xtrue if
X.I string
Xmatches
X.IR pattern .
X.TP
X\fIstring\fP \fB!=\fP \fIpattern\fP
Xtrue if
X.I string
Xdoes not match
X.IR pattern .
X.TP
X\fIstring1\fP \fB<\fP \fIstring2\fP
Xtrue if
X.I string1
Xcomes before
X.I string2
Xbased on ASCII value of their characters.
X.TP
X\fIstring1\fP \fB>\fP \fIstring2\fP
Xtrue if
X.I string1
Xcomes after
X.I string2
Xbased on ASCII value of their characters.
X.TP
X\fIexp1\fP \fB\-eq\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-ne\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis not equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-lt\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis less than
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-gt\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis greater than
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-le\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis less than or equal to
X.IR exp2.
X.TP
X\fIexp1\fP \fB\-ge\fP \fIexp2\fP
Xtrue if
X.I exp1
Xis greater than or equal to
X.IR exp2.
X.TP
X\fB(\fP \fIexp\fP \fB)\fP
Xtrue if \fIexp\fP is true.
X.TP
X\fB!\fP \fIexp\fP
Xtrue if \fIexp\fP is false.
X.TP
X\fIexp1\fP \fB&&\fP \fIexp2\fP
Xtrue if \fIexp1\fP and \fIexp2\fP are both true.
X.TP
X\fIexp1\fP \fB|\||\fP \fIexp2\fP
Xtrue if either \fIexp1\fP or \fIexp2\fP is true.
X.PD
X.PP
XIn each of the above expressions, if
X.I file
Xis of the form
X\fB/dev/fd/\fP\fIn\fR,
Xwhere
X.I n
Xis an integer,
Xthen the test applied to the open file whose
Xdescriptor number is
X.IR n ,
Xeven if the underlying system does not support
Xthe \fB/dev/fd\fP directory.
X.PD
X.SH "ZSH LINE EDITOR"
XIf the \fBZLE\fP option is set (it is by default)
Xand the shell input is attached to the terminal, the user
Xis allowed to edit command lines.
X.PP
XThere are two display modes.  The first, multiline mode, is the default.
XIt only works if the \fBTERM\fP parameter is set to a valid
Xterminal type that can move the cursor up.  The second,
Xsingle line mode, is used if \fBTERM\fP is invalid or incapable
Xof moving the cursor up, or if the \fBSINGLE_LINE_ZLE\fP
Xoption is set.  This mode is similar to ksh, and uses no
Xtermcap sequences.
X.SS Bindings
XCommand bindings may be set using the \fBbindkey\fP builtin.
XThere are two keymaps\-the main keymap and the alternate keymap.
XThe alternate keymap is bound to vi command mode.
XThe main keymap is bound to emacs mode by default.
XTo bind the main keymap to vi insert mode, use 
X\fBbindkey \-v\fP, or set one of the \fBVISUAL\fP or \fBEDITOR\fP
Xenvironment variables to a string containing \fBvi\fP.
X.PP
XThe following is a list of all the key commands
Xand their default bindings in emacs and vi command mode.
X.SS Movement
X.TP
X\fBvi-backward-blank-word\fP (unbound) (B)
XMove backward one word, where a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBbackward-char\fP (^B ESC-[D) (\|)
XMove backward one character.
X.TP
X\fBvi-backward-char\fP (\|) (h)
XMove backward one character, without changing lines.
X.TP
X\fBbackward-word\fP (ESC-B ESC-b) (unbound)
XMove to the beginning of the previous word.
X.TP
X\fBemacs-backward-word\fP
XMove to the beginning of the previous word.
X.TP
X\fBvi-backward-word\fP (unbound) (b)
XMove to the beginning of the previous word, vi-style.
X.TP
X\fBbeginning-of-line\fP (^A) (0)
XMove to the beginning of the line.  If already at the beginning
Xof the line, move to the beginning of the previous line, if any.
X.TP
X\fBvi-beginning-of-line\fP
XMove to the beginning of the line, without changing lines.
X.TP
X\fBend-of-line\fP (^E)
XMove to the end of the line.  If already at the end 
Xof the line, move to the end of the next line, if any.
X.TP
X\fBvi-end-of-line\fP (unbound) ($)
XMove to the end of the line.
X.TP
X\fBvi-forward-blank-word\fP (unbound) (W)
XMove forward one word, where a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBvi-forward-blank-word-end\fP (unbound) (E)
XMove to the end of the current word,
Xor, if at the end of the current word,
Xto the end of the next word,
Xwhere a word is defined as a series of
Xnon-blank characters.
X.TP
X\fBforward-char\fP (^F ESC-[C)
XMove forward one character.
X.TP
X\fBvi-forward-char\fP (unbound) (space l)
XMove forward one character.
X.TP
X\fBvi-find-next-char\fP (^X^F) (f)
XRead a character from the keyboard, and move to
Xthe next occurrence of it in the line.
X.TP
X\fBvi-find-next-char-skip\fP (unbound) (t)
SHAR_EOF
true || echo 'restore of zsh2.2/man/man1/zsh.1 failed'
fi
echo 'End of zsh2.2 part 3'
echo 'File zsh2.2/man/man1/zsh.1 is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
