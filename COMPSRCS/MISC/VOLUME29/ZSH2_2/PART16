Newsgroups: comp.sources.misc
From: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Subject:  v29i112:  zsh2.2 - The Z shell, Part16/17
Message-ID: <1992May13.161048.11193@sparky.imd.sterling.com>
X-Md4-Signature: 0c3b87c59885f3fa25b6297a6522572c
Date: Wed, 13 May 1992 16:10:48 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: pfalstad@phoenix.Princeton.EDU (Paul Falstad)
Posting-number: Volume 29, Issue 112
Archive-name: zsh2.2/part16
Environment: BSD
Supersedes: zsh2.1: Volume 24, Issue 1-19

#!/bin/sh
# this is aa.16 (part 16 of zsh2.2)
# do not concatenate these parts, unpack them in order with /bin/sh
# file zsh2.2/src/params.pro continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 16; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping zsh2.2/src/params.pro'
else
echo 'x - continuing file zsh2.2/src/params.pro'
sed 's/^X//' << 'SHAR_EOF' >> 'zsh2.2/src/params.pro' &&
Xvoid lithistsizesetfn DCLPROTO((Param pm,long v));
Xlong lithistsizegetfn DCLPROTO((Param pm));
Xvoid mailchecksetfn DCLPROTO((Param pm,long x));
Xvoid pathasetfn DCLPROTO((Param pm,char **x));
Xchar **pathagetfn DCLPROTO((Param pm));
Xlong errnogetfn DCLPROTO((Param pm));
Xchar *dashgetfn DCLPROTO((Param pm));
Xvoid histcharssetfn DCLPROTO((Param pm,char *x));
Xchar *histcharsgetfn DCLPROTO((Param pm));
Xchar *homegetfn DCLPROTO((Param pm));
Xvoid homesetfn DCLPROTO((Param pm,char *x));
Xchar *wordcharsgetfn DCLPROTO((Param pm));
Xvoid wordcharssetfn DCLPROTO((Param pm,char *x));
Xchar *underscoregetfn DCLPROTO((Param pm));
Xchar *termgetfn DCLPROTO((Param pm));
Xvoid termsetfn DCLPROTO((Param pm,char *x));
Xvoid setparams DCLPROTO((void));
Xchar *mkenvstr DCLPROTO((char *x,char *y));
Xvoid arrfixenv DCLPROTO((char *s,char **t));
Xchar *replenv DCLPROTO((char *e,char *value));
Xchar *addenv DCLPROTO((char *name,char *value));
Xvoid delenv DCLPROTO((char *x));
Xvoid convbase DCLPROTO((char *s,long v,int base));
SHAR_EOF
echo 'File zsh2.2/src/params.pro is complete' &&
chmod 0644 zsh2.2/src/params.pro ||
echo 'restore of zsh2.2/src/params.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/params.pro'`"
test 3478 -eq "$Wc_c" ||
	echo 'zsh2.2/src/params.pro: original size 3478, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/subst.pro ==============
if test -f 'zsh2.2/src/subst.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/subst.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/subst.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/subst.pro' &&
Xvoid prefork DCLPROTO((Lklist list));
Xvoid postfork DCLPROTO((Lklist list,int doglob));
Xvoid singsub DCLPROTO((char **s));
Xvptr nstrdup DCLPROTO((vptr s));
Xchar *dynread DCLPROTO((int stop));
Xint filesub DCLPROTO((char **namptr));
Xchar *gethome DCLPROTO((char *user,int len));
Xvoid commsubst DCLPROTO((Lklist l,Lknode n,char *str3,char *str,int qt));
Xvoid paramsubst DCLPROTO((Lklist l,Lknode n,char *aptr,char *bptr,int qt));
Xvoid arithsubst DCLPROTO((vptr *aptr,char **bptr));
Xvoid modify DCLPROTO((char **str,char **ptr));
Xchar *dstackent DCLPROTO((int val));
Xstruct alias *mkanode DCLPROTO((char *txt,int cmflag));
SHAR_EOF
chmod 0644 zsh2.2/src/subst.pro ||
echo 'restore of zsh2.2/src/subst.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/subst.pro'`"
test 619 -eq "$Wc_c" ||
	echo 'zsh2.2/src/subst.pro: original size 619, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/table.pro ==============
if test -f 'zsh2.2/src/table.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/table.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/table.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/table.pro' &&
XLklist newlist DCLPROTO((void));
XHashtab newhtable DCLPROTO((int size));
Xint hasher DCLPROTO((char *s));
Xvoid Addhnode DCLPROTO((char *nam,vptr dat,Hashtab ht,FFunc freefunc,int canfree));
Xvoid addhcmdnode DCLPROTO((char *nam,char **pnam));
Xvoid expandhtab DCLPROTO((Hashtab ht));
Xvptr gethnode DCLPROTO((char *nam,Hashtab ht));
Xvoid freehtab DCLPROTO((Hashtab ht,FFunc freefunc));
Xvptr remhnode DCLPROTO((char *nam,Hashtab ht));
Xvoid insnode DCLPROTO((Lklist list,Lknode llast,vptr dat));
Xvoid addnodeinorder DCLPROTO((Lklist x, char *dat));
Xvptr remnode DCLPROTO((Lklist list,Lknode nd));
Xvptr uremnode DCLPROTO((Lklist list,Lknode nd));
Xvoid chuck DCLPROTO((char *str));
Xvptr getnode DCLPROTO((Lklist list));
Xvptr ugetnode DCLPROTO((Lklist list));
Xvoid freetable DCLPROTO((Lklist tab,FFunc freefunc));
Xchar *ztrstr DCLPROTO((char *s,char *t));
Xvoid inslist DCLPROTO((Lklist l,Lknode where,Lklist x));
Xint countnodes DCLPROTO((Lklist x));
SHAR_EOF
chmod 0644 zsh2.2/src/table.pro ||
echo 'restore of zsh2.2/src/table.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/table.pro'`"
test 941 -eq "$Wc_c" ||
	echo 'zsh2.2/src/table.pro: original size 941, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/text.pro ==============
if test -f 'zsh2.2/src/text.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/text.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/text.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/text.pro' &&
Xvoid taddchr DCLPROTO((int c));
Xvoid taddstr DCLPROTO((char *s));
Xvoid taddint DCLPROTO((int x));
Xvoid taddnl DCLPROTO((void));
Xchar *getpermtext DCLPROTO((struct node *n));
Xchar *getjobtext DCLPROTO((struct node *n));
Xvoid gettext2 DCLPROTO((struct node *n));
Xvoid getsimptext DCLPROTO((Cmd cmd));
Xvoid getredirs DCLPROTO((Cmd cmd));
Xvoid taddlist DCLPROTO((Lklist l));
SHAR_EOF
chmod 0644 zsh2.2/src/text.pro ||
echo 'restore of zsh2.2/src/text.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/text.pro'`"
test 371 -eq "$Wc_c" ||
	echo 'zsh2.2/src/text.pro: original size 371, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/utils.pro ==============
if test -f 'zsh2.2/src/utils.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/utils.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/utils.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/utils.pro' &&
Xint source DCLPROTO((char *s));
Xvoid sourcehome DCLPROTO((char *s));
Xvoid zerrnam DCLPROTO((char *cmd, char *fmt, char *str,int num));
Xvoid zerr DCLPROTO((char *fmt, char *str,int num));
Xvoid niceputc DCLPROTO((int c,FILE *f));
Xvoid intr DCLPROTO((void));
Xvoid noholdintr DCLPROTO((void));
Xvoid holdintr DCLPROTO((void));
Xchar *fgetline DCLPROTO((char *buf,int len,FILE *in));
Xchar *findpwd DCLPROTO((char *s));
Xchar *fixpwd DCLPROTO((char *s));
Xint ispwd DCLPROTO((char *s));
Xchar *xsymlink DCLPROTO((char *s));
Xchar **slashsplit DCLPROTO((char *s));
Xint islink DCLPROTO((char *s));
Xint xsymlinks DCLPROTO((char *s,int flag));
Xvoid fprintdir DCLPROTO((char *s, FILE *f));
Xvoid printdir DCLPROTO((char *s));
Xvoid printdircr DCLPROTO((char *s));
Xint finddir DCLPROTO((char *s));
Xvoid adduserdir DCLPROTO((char *s,char *t));
Xint dircmp DCLPROTO((char *s,char *t));
Xint ddifftime DCLPROTO((time_t t1,time_t t2));
Xvoid scanjobs DCLPROTO((void));
Xvoid preprompt DCLPROTO((void));
Xint arrlen DCLPROTO((char **s));
Xvoid checkmailpath DCLPROTO((char **s));
Xvoid saveoldfuncs DCLPROTO((char *x,Cmdnam y));
Xvoid newcmdnamtab DCLPROTO((void));
Xvoid freecmdnam DCLPROTO((vptr a));
Xvoid freecompctl DCLPROTO((vptr a));
Xvoid freestr DCLPROTO((vptr a));
Xvoid freeanode DCLPROTO((vptr a));
Xvoid freepm DCLPROTO((vptr a));
Xvoid restoretty DCLPROTO((void));
Xvoid gettyinfo DCLPROTO((struct ttyinfo *ti));
Xvoid settyinfo DCLPROTO((struct ttyinfo *ti));
Xvoid sanetty DCLPROTO((struct ttyinfo *ti));
Xvoid adjustwinsize DCLPROTO((void));
Xint zyztem DCLPROTO((char *s,char *t));
Xint waitfork DCLPROTO((void));
Xint movefd DCLPROTO((int fd));
Xvoid redup DCLPROTO((int x,int y));
Xvoid settrap DCLPROTO((int t0,List l));
Xvoid unsettrap DCLPROTO((int t0));
Xvoid dotrap DCLPROTO((int sig));
Xvoid ztrncpy DCLPROTO((char *s,char *t,int len));
Xvoid strucpy DCLPROTO((char **s,char *t));
Xvoid struncpy DCLPROTO((char **s,char *t,int n));
Xvoid checkrmall DCLPROTO((char *s));
Xint getquery DCLPROTO((void));
Xvoid spscannodis DCLPROTO((char *s,char *cn));
Xvoid spscan DCLPROTO((char *s,char *junk));
Xvoid spckword DCLPROTO((char **s,char **s2,char **tptr,int cmd,int ask));
Xint ztrftime DCLPROTO((char *buf,int bufsize,char *fmt,struct tm *tm));
Xchar *join DCLPROTO((char **arr,int delim));
Xchar *spacejoin DCLPROTO((char **s));
Xchar *colonjoin DCLPROTO((char **s));
Xchar **colonsplit DCLPROTO((char *s));
Xchar **spacesplit DCLPROTO((char *s));
XList getshfunc DCLPROTO((char *nam));
Xvptr allocnode DCLPROTO((int type));
Xvptr dupstruct DCLPROTO((vptr a));
Xvoid freestruct DCLPROTO((vptr a));
XLklist duplist DCLPROTO((Lklist l,VFunc func));
Xchar **mkarray DCLPROTO((char *s));
Xvoid feep DCLPROTO((void));
Xvoid freearray DCLPROTO((char **s));
Xint equalsplit DCLPROTO((char *s,char **t));
Xvoid simplifyright DCLPROTO((List l));
Xvoid inittyptab DCLPROTO((void));
Xchar **arrdup DCLPROTO((char **s));
Xchar *spname  DCLPROTO((char *oldname));
Xint mindist DCLPROTO((char *dir,char *guess,char *best));
Xint spdist DCLPROTO((char *s,char *t,int thresh));
Xchar *zgetenv DCLPROTO((char *s));
Xint tulower DCLPROTO((int c));
Xint tuupper DCLPROTO((int c));
Xvoid setcbreak DCLPROTO((void));
Xint getlineleng DCLPROTO((void));
Xvoid unsetcbreak DCLPROTO((void));
Xvoid attachtty DCLPROTO((long pgrp));
Xlong gettygrp DCLPROTO((void));
SHAR_EOF
chmod 0644 zsh2.2/src/utils.pro ||
echo 'restore of zsh2.2/src/utils.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/utils.pro'`"
test 3277 -eq "$Wc_c" ||
	echo 'zsh2.2/src/utils.pro: original size 3277, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/watch.pro ==============
if test -f 'zsh2.2/src/watch.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/watch.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/watch.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/watch.pro' &&
Xtime_t getlogtime DCLPROTO((struct utmp *u,int inout));
Xvoid watchlog2 DCLPROTO((int inout,struct utmp *u,char *fmt));
Xvoid watchlog DCLPROTO((int inout,struct utmp *u,char **w,char *fmt));
Xint ucmp DCLPROTO((struct utmp *u,struct utmp *v));
Xvoid readwtab DCLPROTO((void));
Xvoid dowatch DCLPROTO((void));
Xint bin_log DCLPROTO((char *nam,char **argv,char *ops,int func));
SHAR_EOF
chmod 0644 zsh2.2/src/watch.pro ||
echo 'restore of zsh2.2/src/watch.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/watch.pro'`"
test 371 -eq "$Wc_c" ||
	echo 'zsh2.2/src/watch.pro: original size 371, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_bindings.pro ==============
if test -f 'zsh2.2/src/zle_bindings.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_bindings.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_bindings.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_bindings.pro' &&
SHAR_EOF
chmod 0644 zsh2.2/src/zle_bindings.pro ||
echo 'restore of zsh2.2/src/zle_bindings.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_bindings.pro'`"
test 0 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_bindings.pro: original size 0, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_main.pro ==============
if test -f 'zsh2.2/src/zle_main.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_main.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_main.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_main.pro' &&
Xvoid setterm DCLPROTO((void));
Xvoid unsetterm DCLPROTO((void));
Xvoid ungetkey DCLPROTO((int ch));
Xvoid ungetkeys DCLPROTO((char *s,int len));
Xunsigned int getkey DCLPROTO((int tmok));
Xunsigned char *zleread DCLPROTO((unsigned char *ppt,unsigned char *ppt2,int plen));
Xint getkeycmd DCLPROTO((void));
Xvoid sendstring DCLPROTO((void));
XKey makefunckey DCLPROTO((int fun));
Xvoid initxbindtab DCLPROTO((void));
Xchar *getkeystring DCLPROTO((char *s,int *len));
Xvoid printbind DCLPROTO((char *s,int len));
Xvoid printbinding DCLPROTO((char *str,Key k));
Xint bin_bindkey DCLPROTO((char *name,char **argv,char *ops,int junc));
Xvoid freekey DCLPROTO((vptr x));
Xvoid drainoutput DCLPROTO((void));
SHAR_EOF
chmod 0644 zsh2.2/src/zle_main.pro ||
echo 'restore of zsh2.2/src/zle_main.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_main.pro'`"
test 686 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_main.pro: original size 686, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_refresh.pro ==============
if test -f 'zsh2.2/src/zle_refresh.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_refresh.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_refresh.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_refresh.pro' &&
Xvoid resetvideo DCLPROTO((void));
Xint scrollwindow DCLPROTO((void));
Xvoid refresh DCLPROTO((void));
Xvoid refreshline DCLPROTO((int ln));
Xvoid moveto DCLPROTO((int ln,int cl));
Xvoid tcmultout DCLPROTO((int cap,int multcap,int ct));
Xvoid tc_rightcurs DCLPROTO((int ct));
Xvoid tc_downcurs DCLPROTO((int ct));
Xvoid tcout DCLPROTO((int cap));
Xvoid tcoutarg DCLPROTO((int cap,int arg));
Xvoid clearscreen DCLPROTO((void));
Xvoid redisplay DCLPROTO((void));
Xvoid trashzle DCLPROTO((void));
Xvoid singlerefresh DCLPROTO((void));
Xvoid singmoveto DCLPROTO((int pos));
Xint streqct DCLPROTO((char *s,char *t));
SHAR_EOF
chmod 0644 zsh2.2/src/zle_refresh.pro ||
echo 'restore of zsh2.2/src/zle_refresh.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_refresh.pro'`"
test 596 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_refresh.pro: original size 596, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_vi.pro ==============
if test -f 'zsh2.2/src/zle_vi.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_vi.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_vi.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_vi.pro' &&
Xint vigetkey DCLPROTO((void));
Xint getvirange DCLPROTO((int wf));
Xvoid viaddnext DCLPROTO((void));
Xvoid viaddeol DCLPROTO((void));
Xvoid viinsert DCLPROTO((void));
Xvoid viinsertbol DCLPROTO((void));
Xvoid videlete DCLPROTO((void));
Xvoid vichange DCLPROTO((void));
Xvoid visubstitute DCLPROTO((void));
Xvoid vichangeeol DCLPROTO((void));
Xvoid vichangewholeline DCLPROTO((void));
Xvoid viyank DCLPROTO((void));
Xvoid viyankeol DCLPROTO((void));
Xvoid vireplace DCLPROTO((void));
Xvoid vireplacechars DCLPROTO((void));
Xvoid vicmdmode DCLPROTO((void));
Xvoid viopenlinebelow DCLPROTO((void));
Xvoid viopenlineabove DCLPROTO((void));
Xvoid vioperswapcase DCLPROTO((void));
Xvoid virepeatchange DCLPROTO((void));
Xvoid viindent DCLPROTO((void));
Xvoid viunindent DCLPROTO((void));
SHAR_EOF
chmod 0644 zsh2.2/src/zle_vi.pro ||
echo 'restore of zsh2.2/src/zle_vi.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_vi.pro'`"
test 761 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_vi.pro: original size 761, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/parse.pro ==============
if test -f 'zsh2.2/src/parse.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/parse.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/parse.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/parse.pro' &&
XList parse_event DCLPROTO((void));
XList par_event DCLPROTO((void));
XList parse_list DCLPROTO((void));
XList par_list DCLPROTO((void));
XList par_list1 DCLPROTO((void));
XSublist par_sublist DCLPROTO((void));
XSublist par_sublist2 DCLPROTO((void));
XPline par_pline DCLPROTO((void));
XCmd par_cmd DCLPROTO((void));
Xvoid par_for DCLPROTO((Cmd c));
Xvoid par_case DCLPROTO((Cmd c));
Xvoid par_if DCLPROTO((Cmd c));
Xvoid par_while DCLPROTO((Cmd c));
Xvoid par_repeat DCLPROTO((Cmd c));
Xvoid par_subsh DCLPROTO((Cmd c));
Xvoid par_funcdef DCLPROTO((Cmd c));
Xvoid par_time DCLPROTO((Cmd c));
Xvoid par_dinbrack DCLPROTO((Cmd c));
XCmd par_simple DCLPROTO((Cmd c));
XCond par_cond DCLPROTO((void));
XCond par_cond_1 DCLPROTO((void));
XCond par_cond_2 DCLPROTO((void));
Xvoid par_redir DCLPROTO((Lklist l));
XLklist par_wordlist DCLPROTO((void));
XLklist par_nl_wordlist DCLPROTO((void));
Xint getfdstr DCLPROTO((char *s));
XCond par_cond_double DCLPROTO((char *a,char *b));
XCond par_cond_triple DCLPROTO((char *a,char *b,char *c));
Xvoid yyerror DCLPROTO((void));
SHAR_EOF
chmod 0644 zsh2.2/src/parse.pro ||
echo 'restore of zsh2.2/src/parse.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/parse.pro'`"
test 1036 -eq "$Wc_c" ||
	echo 'zsh2.2/src/parse.pro: original size 1036, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_tricky.pro ==============
if test -f 'zsh2.2/src/zle_tricky.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_tricky.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_tricky.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_tricky.pro' &&
Xint usetab DCLPROTO((void));
Xvoid completeword DCLPROTO((void));
Xvoid menucompleteword DCLPROTO((void));
Xvoid listchoices DCLPROTO((void));
Xvoid spellword DCLPROTO((void));
Xvoid deletecharorlist DCLPROTO((void));
Xvoid expandword DCLPROTO((void));
Xvoid expandorcomplete DCLPROTO((void));
Xvoid menuexpandorcomplete DCLPROTO((void));
Xvoid listexpand DCLPROTO((void));
Xvoid reversemenucomplete DCLPROTO((void));
Xvoid acceptandmenucomplete DCLPROTO((void));
Xvoid docomplete DCLPROTO((int lst));
Xvoid do_menucmp DCLPROTO((int lst));
Xchar *get_comp_string DCLPROTO((void));
Xvoid doexpansion DCLPROTO((char *s,int lst,int lincmd));
Xvoid gotword DCLPROTO((char *s));
Xvoid inststrlen DCLPROTO((char *s,int l));
Xvoid addmatch DCLPROTO((char *s));
Xvoid addcmdmatch DCLPROTO((char *s,char *t));
Xvoid addcmddirparam DCLPROTO((char *s,char *t));
Xvoid addcmdnodis DCLPROTO((char *s,char *t));
Xvoid maketildelist DCLPROTO((char	*s));
Xint Isdir DCLPROTO((char *s));
Xint isdir DCLPROTO((char *t,char *s));
Xvoid docompletion DCLPROTO((char *s,int lst,int incmd));
Xchar **get_user_var DCLPROTO((char *nam));
Xvoid gen_matches_glob DCLPROTO((char *s,int incmd));
Xvoid gen_matches_reg DCLPROTO((char *s,int incmd,int regfiles));
Xvoid do_fignore DCLPROTO((char *origstr));
Xvoid do_ambiguous DCLPROTO((char *s));
Xvoid do_single DCLPROTO((char *s));
Xvoid do_ambig_menu DCLPROTO((char *s));
Xint strpfx DCLPROTO((char *s,char *t));
Xint pfxlen DCLPROTO((char *s,char *t));
Xvoid listmatches DCLPROTO((Lklist l,char *apps));
Xvoid selectlist DCLPROTO((Lklist l));
Xint doexpandhist DCLPROTO((void));
Xvoid magicspace DCLPROTO((void));
Xvoid expandhistory DCLPROTO((void));
Xchar *getcurcmd DCLPROTO((void));
Xvoid processcmd DCLPROTO((void));
Xvoid expandcmdpath DCLPROTO((void));
Xvoid freemenu DCLPROTO((void));
Xint inarray DCLPROTO((char *s, char **a));
SHAR_EOF
chmod 0644 zsh2.2/src/zle_tricky.pro ||
echo 'restore of zsh2.2/src/zle_tricky.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_tricky.pro'`"
test 1817 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_tricky.pro: original size 1817, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/parse.c ==============
if test -f 'zsh2.2/src/parse.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/parse.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/parse.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/parse.c' &&
X/*
X *
X * parse.c - parser
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#include "zsh.h"
X#include "funcs.h"
X
X#define YYERROR { tok = LEXERR; return NULL; }
X#define YYERRORV { tok = LEXERR; return; }
X
X#define make_list() allocnode(N_LIST)
X#define make_sublist() allocnode(N_SUBLIST)
X#define make_pline() allocnode(N_PLINE)
X#define make_cmd() allocnode(N_CMD)
X#define make_forcmd() allocnode(N_FOR)
X#define make_casecmd() allocnode(N_CASE)
X#define make_ifcmd() allocnode(N_IF)
X#define make_whilecmd() allocnode(N_WHILE)
X#define make_varnode() allocnode(N_VARASG)
X#define make_cond() allocnode(N_COND)
X
X/*
X * event	: ENDINPUT
X *			| SEPER
X *			| sublist [ SEPER | AMPER ]
X */
XList parse_event() /**/
X{
X	tok = ENDINPUT;
X	incmdpos = 1;
X	yylex();
X	return par_event();
X}
X
XList par_event() /**/
X{
XSublist sl;
XList l = NULL;
X
X	while (tok == SEPER) {
X		if (isnewlin > 0) return NULL;
X		yylex();
X	}
X	if (tok == ENDINPUT) return NULL;
X	if (sl = par_sublist())
X		if (tok == ENDINPUT) {
X			l = make_list();
X			l->type = SYNC; l->left = sl;
X		} else if (tok == SEPER) {
X			l = make_list();
X			l->type = SYNC; l->left = sl;
X			if (isnewlin <= 0) yylex();
X		} else if (tok == AMPER) {
X			l = make_list();
X			l->type = ASYNC; l->left = sl;
X			yylex();
X		} else
X			l = NULL;
X	if (!l) {
X		if (errflag) { yyerror(); return NULL; }
X		yyerror();
X		errflag = 0;
X		if (isnewlin <= 0) {
X			int c;
X
X			hwbegin();
X			while ((c = hgetc()) != '\n' && !lexstop);
X			if (c == '\n') hungetc('\n');
X			hwaddc(HISTSPACE);
X			hwadd();
X		}
X		errflag = 1;
X		return NULL;
X	} else {
X		l->right = par_event();
X	}
X	return l;
X}
X
XList parse_list() /**/
X{
X	tok = ENDINPUT;
X	incmdpos = 1;
X	yylex();
X	return par_list();
X}
X
X/*
X * list	: { SEPER } [ sublist [ { SEPER | AMPER } list ] ]
X */
XList par_list() /**/
X{
XSublist sl;
XList l = NULL;
X
X	while (tok == SEPER) yylex();
X	if (sl = par_sublist())
X		if (tok == SEPER || tok == AMPER) {
X			l = make_list();
X			l->left = sl;
X			l->type = (tok == SEPER) ? SYNC : ASYNC;
X			incmdpos = 1;
X			while (tok == SEPER || tok == AMPER) yylex();
X			l->right = par_list();
X		} else {
X			l = make_list();
X			l->left = sl;
X			l->type = SYNC;
X		}
X	return l;
X}
X
XList par_list1() /**/
X{
XSublist sl;
XList l = NULL;
X
X	if (sl = par_sublist()) {
X		l = make_list();
X		l->type = SYNC;
X		l->left = sl;
X	}
X	return l;
X}
X
X/*
X * sublist	: sublist2 [ ( DBAR | DAMPER ) { SEPER } sublist ]
X */
XSublist par_sublist() /**/
X{
XSublist sl;
X
X	if (sl = par_sublist2())
X		if (tok == DBAR || tok == DAMPER) {
X			int qtok = tok;
X			yylex();
X			while (tok == SEPER) yylex();
X			sl->right = par_sublist();
X			sl->type = (qtok == DBAR) ? ORNEXT : ANDNEXT;
X		}
X	return sl;
X}
X
X/*
X * sublist2	: [ COPROC | BANG ] pline
X */
XSublist par_sublist2() /**/
X{
XSublist sl;
XPline p;
X
X	sl = make_sublist();
X	if (tok == COPROC) { sl->flags |= PFLAG_COPROC; yylex(); }
X	else if (tok == BANG) { sl->flags |= PFLAG_NOT; yylex(); }
X	if (!(p = par_pline()) && !sl->flags)
X		return NULL;
X	sl->left = p;
X	return sl;
X}
X
X/*
X * pline	: cmd [ ( BAR | BARAMP ) { SEPER } pline ]
X */
XPline par_pline() /**/
X{
XCmd c;
XPline p,p2;
X
X	if (!(c = par_cmd()))
X		return NULL;
X	if (tok == BAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		p2 = par_pline();
X		p = make_pline();
X		p->left = c; p->right = p2; p->type = PIPE;
X		return p;
X	} else if (tok == BARAMP) {
X		struct redir *rdr = alloc(sizeof *rdr);
X		rdr->type = MERGE; rdr->fd1 = 2; rdr->fd2 = 1;
X		addnode(c->redir,rdr);
X
X		yylex();
X		p2 = par_pline();
X		p = make_pline();
X		p->left = c; p->right = p2; p->type = PIPE;
X		return p;
X	} else {
X		p = make_pline();
X		p->left = c; p->type = END;
X		return p;
X	}
X}
X
X/*
X * cmd	: { redir } ( for | case | if | while | repeat |
X *				subsh | funcdef | time | dinbrack | simple ) { redir }
X */
XCmd par_cmd() /**/
X{
XCmd c;
X
X	c = make_cmd();
X	c->args = newlist();
X	c->redir = newlist();
X	c->vars = newlist();
X	while (IS_REDIROP(tok))
X		par_redir(c->redir);
X	switch (tok) {
X	case FOR: case FOREACH: case SELECT: par_for(c); break;
X	case CASE: par_case(c); break;
X	case IF: par_if(c); break;
X	case WHILE: case UNTIL: par_while(c); break;
X	case REPEAT: par_repeat(c); break;
X	case INPAR: case INBRACE: par_subsh(c); break;
X	case FUNC: par_funcdef(c); break;
X	case TIME: par_time(c); break;
X	case DINBRACK: par_dinbrack(c); break;
X	default: if (!par_simple(c)) return NULL; break;
X	}
X	while (IS_REDIROP(tok))
X		par_redir(c->redir);
X	incmdpos = 1;
X	incasepat = 0;
X	incond = 0;
X	return c;
X}
X
X/*
X * for	: ( FOR[EACH] | SELECT ) name ( "in" wordlist | INPAR wordlist OUTPAR )
X				{ SEPER } ( DO list DONE | INBRACE list OUTBRACE |
X				list ZEND | list1 )
X */
Xvoid par_for(c) /**/
XCmd c;
X{
Xstruct forcmd *f;
Xint csh = (tok == FOREACH || isset(CSHJUNKIELOOPS));
X
X	f = make_forcmd();
X	c->type = (tok == SELECT) ? CSELECT : CFOR;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	f->name = tokstr;
X	incmdpos = 1;
X	yylex();
X	if (tok == STRING && !strcmp(tokstr,"in")) {
X		f->inflag = 1;
X		incmdpos = 0;
X		yylex();
X		c->args = par_wordlist();
X		if (tok != SEPER) YYERRORV;
X	} else if (tok == INPAR) {
X		f->inflag = 1;
X		incmdpos = 0;
X		yylex();
X		c->args = par_nl_wordlist();
X		if (tok != OUTPAR) YYERRORV;
X		incmdpos = 1;
X		yylex();
X	}
X	incmdpos = 1;
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		f->list = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else if (tok == INBRACE) {
X		yylex();
X		f->list = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (csh) {
X		f->list = par_list();
X		if (tok != ZEND) YYERRORV;
X		yylex();
X	} else if (isset(NOSHORTLOOPS)) {
X		YYERRORV;
X	} else
X		f->list = par_list1();
X	c->u.forcmd = f;
X}
X
X/*
X * case	: CASE STRING { SEPER } ( "in" | INBRACE )
X				{ { SEPER } STRING { BAR STRING } OUTPAR list [ DSEMI ] }
X				{ SEPER } ( "esac" | OUTBRACE )
X */
Xvoid par_case(c) /**/
XCmd c;
X{
Xstruct casecmd **ccp;
Xint brflag;
X
X	c->type = CCASE;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	addnode(c->args,tokstr);
X	incmdpos = 1;
X	yylex();
X	while (tok == SEPER) yylex();
X	if (!(tok == STRING && !strcmp(tokstr,"in")) && tok != INBRACE) YYERRORV;
X	brflag = (tok == INBRACE);
X	incasepat = 1;
X	incmdpos = 0;
X	yylex();
X	ccp = &c->u.casecmd;
X	for (;;) {
X		char *str;
X		struct casecmd *cc;
X
X		*ccp = cc = make_casecmd();
X		while (tok == SEPER) yylex();
X		if (tok == OUTBRACE) {
X			yylex();
X			break;
X		}
X		if (tok != STRING) YYERRORV;
X		if (!strcmp(tokstr,"esac")) {
X			yylex();
X			break;
X		}
X		str = tokstr;
X		yylex();
X		while (tok == BAR) {
X			char *str2;
X			int sl = strlen(str);
X
X			yylex();
X			if (tok != STRING) YYERRORV;
X			str2 = alloc(sl+strlen(tokstr)+1);
X			strcpy(str2,str);
X			str2[sl] = Bar;
X			strcpy(str2+sl+1,tokstr);
X			str = str2;
X			yylex();
X		}
X		if (tok != OUTPAR) YYERRORV;
X		incasepat = 0;
X		incmdpos = 1;
X		yylex();
X		cc->pat = str;
X		cc->list = par_list();
X		ccp = &cc->next;
X		if ((tok == ESAC && !brflag) || (tok == OUTBRACE && brflag)) {
X			yylex();
X			break;
X		}
X		if (tok != DSEMI) YYERRORV;
X		incasepat = 1;
X		incmdpos = 0;
X		yylex();
X	}
X	*ccp = NULL;
X}
X
X/*
X * if	: { ( IF | ELIF ) { SEPER } ( INPAR list OUTPAR | list )
X			{ SEPER } ( THEN list | INBRACE list OUTBRACE | list1 ) }
X			[ FI | ELSE list FI | ELSE { SEPER } INBRACE list OUTBRACE ]
X			(you get the idea...?)
X */
Xvoid par_if(c) /**/
XCmd c;
X{
Xstruct ifcmd *i,**ip;
Xint xtok;
X
X	c->type = CIF;
X	ip = &c->u.ifcmd;
X	for (;;) {
X		xtok = tok;
X		yylex();
X		if (xtok == FI)
X			break;
X		while (tok == SEPER) yylex();
X		if (xtok == ELSE)
X			break;
X		if (!(xtok == IF || xtok == ELIF)) YYERRORV;
X		*ip = i = make_ifcmd();
X		ip = &i->next;
X		if (tok == INPAR) {
X			yylex();
X			i->ifl = par_list();
X			if (tok != OUTPAR) YYERRORV;
X			incmdpos = 1;
X			yylex();
X		} else {
X			i->ifl = par_list();
X			incmdpos = 1;
X		}
X		while (tok == SEPER) yylex();
X		xtok = FI;
X		if (tok == THEN) {
X			yylex();
X			i->thenl = par_list();
X			incmdpos = 1;
X		} else if (tok == INBRACE) {
X			yylex();
X			i->thenl = par_list();
X			if (tok != OUTBRACE) YYERRORV;
X			yylex();
X			incmdpos = 1;
X			if (tok == SEPER) break;
X		} else if (isset(NOSHORTLOOPS)) {
X			YYERRORV;
X		} else {
X			i->thenl = par_list1();
X			incmdpos = 1;
X			break;
X		}
X	}
X	if (xtok == ELSE) {
X		*ip = i = make_ifcmd();
X		if (tok == INBRACE) {
X			yylex();
X			i->thenl = par_list();
X			if (tok != OUTBRACE) YYERRORV;
X			yylex();
X		} else {
X			i->thenl = par_list();
X			if (tok != FI) YYERRORV;
X			yylex();
X		}
X	}
X}
X
X/*
X * while	: ( WHILE | UNTIL ) ( INPAR list OUTPAR | list ) { SEPER }
X				( DO list DONE | INBRACE list OUTBRACE | list ZEND )
X */
Xvoid par_while(c) /**/
XCmd c;
X{
Xstruct whilecmd *w;
X
X	c->type = CWHILE;
X	w = c->u.whilecmd = make_whilecmd();
X	w->cond = (tok == UNTIL);
X	yylex();
X	if (tok == INPAR) {
X		yylex();
X		w->cont = par_list();
X		if (tok != OUTPAR) YYERRORV;
X		yylex();
X	} else {
X		w->cont = par_list();
X	}
X	incmdpos = 1;
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		w->loop = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else if (tok == INBRACE) {
X		yylex();
X		w->loop = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (isset(CSHJUNKIELOOPS)) {
X		w->loop = par_list();
X		if (tok != ZEND) YYERRORV;
X		yylex();
X	} else
X		YYERRORV;
X}
X
X/*
X * repeat	: REPEAT STRING { SEPER } ( DO list DONE | list1 )
X */
Xvoid par_repeat(c) /**/
XCmd c;
X{
X	c->type = CREPEAT;
X	incmdpos = 0;
X	yylex();
X	if (tok != STRING) YYERRORV;
X	addnode(c->args,tokstr);
X	incmdpos = 1;
X	yylex();
X	while (tok == SEPER) yylex();
X	if (tok == DO) {
X		yylex();
X		c->u.list = par_list();
X		if (tok != DONE) YYERRORV;
X		yylex();
X	} else {
X		c->u.list = par_list1();
X	}
X}
X
X/*
X * subsh	: ( INPAR | INBRACE ) list ( OUTPAR | OUTBRACE )
X */
Xvoid par_subsh(c) /**/
XCmd c;
X{
X	c->type = (tok == INPAR) ? SUBSH : CURSH;
X	yylex();
X	c->u.list = par_list();
X	if (tok != ((c->type == SUBSH) ? OUTPAR : OUTBRACE)) YYERRORV;
X	yylex();
X}
X
X/*
X * funcdef	: FUNCTION wordlist [ INOUTPAR ] { SEPER }
X *					( list1 | INBRACE list OUTBRACE )
X */
Xvoid par_funcdef(c) /**/
XCmd c;
X{
X	nocorrect = 1;
X	incmdpos = 0;
X	yylex();
X	c->type = FUNCDEF;
X	c->args = newlist();
X	while (tok == STRING) {
X		if (*tokstr == Inbrace && !tokstr[1]) { tok = INBRACE; break; }
X		addnode(c->args,tokstr);
X		yylex();
X	}
X	nocorrect = 0;
X	incmdpos = 1;
X	if (tok == INOUTPAR) yylex();
X	while (tok == SEPER) yylex();
X	if (tok == INBRACE) {
X		yylex();
X		c->u.list = par_list();
X		if (tok != OUTBRACE) YYERRORV;
X		yylex();
X	} else if (isset(NOSHORTLOOPS)) {
X		YYERRORV;
X	} else
X		c->u.list = par_list1();
X}
X
X/*
X * time	: TIME sublist2
X */
Xvoid par_time(c) /**/
XCmd c;
X{
X	yylex();
X	c->type = ZCTIME;
X	c->u.pline = par_sublist2();
X}
X
X/*
X * dinbrack	: DINBRACK cond DOUTBRACK
X */
Xvoid par_dinbrack(c) /**/
XCmd c;
X{
X	c->type = COND;
X	incond = 1;
X	incmdpos = 0;
X	yylex();
X	c->u.cond = par_cond();
X	if (tok != DOUTBRACK) YYERRORV;
X	incond = 0;
X	incmdpos = 1;
X	yylex();
X}
X
X/*
X * simple	: { COMMAND | EXEC | NOGLOB | NOCORRECT | DASH }
X					{ STRING | ENVSTRING | ENVARRAY wordlist OUTPAR | redir }
X					[ INOUTPAR { SEPER } ( list1 | INBRACE list OUTBRACE ) ]
X */
XCmd par_simple(c) /**/
XCmd c;
X{
Xint isnull = 1;
X
X	c->type = SIMPLE;
X	for (;;) {
X		if (tok == COMMAND) c->flags |= CFLAG_COMMAND;
X		else if (tok == EXEC) c->flags |= CFLAG_EXEC;
X		else if (tok == NOGLOB) c->flags |= CFLAG_NOGLOB;
X		else if (tok == NOCORRECT) nocorrect = 1;
X		else if (tok == DASH) c->flags = CFLAG_DASH;
X		else break;
X		yylex();
X	}
X	if (tok == AMPER) YYERROR;
X	for (;;) {
X		if (tok == STRING) {
X			incmdpos = 0;
X			addnode(c->args,tokstr);
X			yylex();
X		} else if (tok == ENVSTRING) {
X			struct varasg *v = make_varnode();
X			v->type = PMFLAG_s;
X			equalsplit(v->name = tokstr,&v->str);
X			addnode(c->vars,v);
X			yylex();
X		} else if (tok == ENVARRAY) {
X			struct varasg *v = make_varnode();
X			int oldcmdpos = incmdpos;
X			v->type = PMFLAG_A;
X			incmdpos = 0;
X			v->name = tokstr;
X			yylex();
X			v->arr = par_nl_wordlist();
X			if (tok != OUTPAR) YYERROR;
X			incmdpos = oldcmdpos;
X			yylex();
X			addnode(c->vars,v);
X		} else if (IS_REDIROP(tok)) {
X			par_redir(c->redir);
X		} else if (tok == INOUTPAR) {
X			incmdpos = 1;
X			yylex();
X			while (tok == SEPER) yylex();
X			if (tok == INBRACE) {
X				yylex();
X				c->u.list = par_list();
X				if (tok != OUTBRACE) YYERROR;
X				yylex();
X			} else if (isset(NOSHORTLOOPS)) {
X				YYERROR;
X			} else
X				c->u.list = par_list1();
X			c->type = FUNCDEF;
X		} else break;
X		isnull = 0;
X	}
X	if (isnull && !full(c->redir)) return NULL;
X	if (full(c->args)) {
X		if (underscore)
X			free(underscore);
X		underscore = ztrdup(getdata(lastnode(c->args)));
X		untokenize(underscore);
X	}
X	incmdpos = 1;
X	return c;
X}
X
X/*
X * cond	: cond_1 { SEPER } [ DBAR { SEPER } cond ]
X */
XCond par_cond() /**/
X{
XCond c,c2;
X
X	c = par_cond_1();
X	while (tok == SEPER) yylex();
X	if (tok == DBAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c2 = make_cond();
X		c2->left = c;
X		c2->right = par_cond();
X		c2->type = COND_OR;
X		return c2;
X	}
X	return c;
X}
X
X/*
X * cond_1 : cond_2 { SEPER } [ DAMPER { SEPER } cond_1 ]
X */
XCond par_cond_1() /**/
X{
XCond c,c2;
X
X	c = par_cond_2();
X	while (tok == SEPER) yylex();
X	if (tok == DAMPER) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c2 = make_cond();
X		c2->left = c;
X		c2->right = par_cond_1();
X		c2->type = COND_AND;
X		return c2;
X	}
X	return c;
X}
X
X/*
X * cond_2	: BANG cond_2
X				| INPAR { SEPER } cond_2 { SEPER } OUTPAR
X				| STRING STRING STRING
X				| STRING STRING
X				| STRING ( INANG | OUTANG ) STRING
X */
XCond par_cond_2() /**/
X{
XCond c,c2;
Xchar *s1,*s2,*s3;
Xint xtok;
X
X	if (tok == BANG) {
X		yylex();
X		c = par_cond_2();
X		c2 = make_cond();
X		c2->left = c;
X		c2->type = COND_NOT;
X		return c2;
X	}
X	if (tok == INPAR) {
X		yylex();
X		while (tok == SEPER) yylex();
X		c = par_cond();
X		while (tok == SEPER) yylex();
X		if (tok != OUTPAR) YYERROR;
X		yylex();
X		return c;
X	}
X	if (tok != STRING) YYERROR;
X	s1 = tokstr;
X	yylex();
X	xtok = tok;
X	if (tok == INANG || tok == OUTANG) {
X		yylex();
X		if (tok != STRING) YYERROR;
X		s3 = tokstr;
X		yylex();
X		c = make_cond();
X		c->left = s1;
X		c->right = s3;
X		c->type = (xtok == INANG) ? COND_STRLT : COND_STRGTR;
X		c->types[0] = c->types[1] = NT_STR;
X		return c;
X	}
X	if (tok != STRING) YYERROR;
X	s2 = tokstr;
X	yylex();
X	if (tok == STRING) {
X		s3 = tokstr;
X		yylex();
X		return par_cond_triple(s1,s2,s3);
X	} else
X		return par_cond_double(s1,s2);
X}
X
X/*
X * redir	: ( OUTANG | ... | TRINANG ) STRING
X */
Xvoid par_redir(l) /**/
XLklist l;
X{
Xchar *toks;
Xstruct redir *fn = allocnode(N_REDIR);
Xint mergerror = 0;
Xint oldcmdpos,oldnc;
X
X	oldcmdpos = incmdpos;
X	incmdpos = 0;
X	oldnc = nocorrect;
X	if (tok != INANG) nocorrect = 1;
X	fn->type = redirtab[tok-OUTANG];
X	fn->fd1 = tokfd;
X	yylex();
X	if (tok != STRING && tok != ENVSTRING) YYERRORV;
X	toks = tokstr;
X	incmdpos = oldcmdpos;
X	nocorrect = oldnc;
X	yylex();
X
X/* assign default fd */
X
X	if (fn->fd1 == -1)
X		fn->fd1 = IS_READFD(fn->type) ? 0 : 1;
X
X/* > >(...) or < <(...) */
X
X	if ((*toks == Inang || *toks == Outang) && toks[1] == Inpar) {
X		if ((fn->type & ~1) == WRITE) fn->type = OUTPIPE;
X		else if (fn->type == READ) fn->type = INPIPE;
X		else YYERRORV;
X		fn->name = toks;
X
X/* <<[-] name */
X
X	} else if (fn->type == HEREDOC || fn->type == HEREDOCDASH) {
X		char tbuf[256], *tlin;
X		int tsiz = 0, l;
X		/* Save the rest of the current line for later tokenization */
X		if (!isnewlin) {
X			while (hgets(tbuf, 256) != NULL) {
X				l = strlen(tbuf);
X				if (tsiz == 0) {
X					tlin = ztrdup(tbuf); /* Test for failure? */
X					tsiz = l;
X				} else {
X					tlin = realloc(tlin,tsiz+l+1); /* Test for failure? */
X					strcpy(&tlin[tsiz], tbuf);
X					tsiz += l;
X				}
X				if (tbuf[l-1] == '\n') break;
X			}
X		}
X		/* Now grab the document */
X		fn->name = gethere(toks,fn->type);
X		fn->type = HERESTR;
X		/* Put back the saved line to resume tokenizing */
X		if (tsiz > 0) {
X			hungets(tlin);
X			free(tlin);
X		}
X
X/* >& name or >>& name */
X
X	} else if (IS_ERROR_REDIR(fn->type) && getfdstr(toks) == FD_WORD) {
X		mergerror = 1;
X		fn->name = toks;
X		fn->type = UN_ERROR_REDIR(fn->type);
X
X/* >>& and >>&! are only valid with a name after them */
X
X	} else if (fn->type == ERRAPP || fn->type == ERRAPPNOW) {
X		YYERRORV;
X
X/* >& # */
X
X	} else if (fn->type == MERGE || fn->type == MERGEOUT) {
X		fn->fd2 = getfdstr(toks);
X		if (fn->fd2 == FD_CLOSE) fn->type = CLOSE;
X		else if (fn->fd2 == FD_WORD) fn->fd2 = (fn->type==MERGEOUT) ? 1 : 0;
X	} else
X		fn->name = toks;
X	addnode(l,fn);
X	if (mergerror)
X		{
X		struct redir *fe = allocnode(N_REDIR);
X
X		fe->fd1 = 2;
X		fe->fd2 = fn->fd1;
X		fe->type = MERGEOUT;
X		addnode(l,fe);
X		}
X}
X
X/*
X * wordlist	: { STRING }
X */
XLklist par_wordlist() /**/
X{
XLklist l;
X
X	l = newlist();
X	while (tok == STRING) {
X		addnode(l,tokstr);
X		yylex();
X	}
X	return l;
X}
X
X/*
X * nl_wordlist	: { STRING | SEPER }
X */
XLklist par_nl_wordlist() /**/
X{
XLklist l;
X
X	l = newlist();
X	while (tok == STRING || tok == SEPER) {
X		if (tok != SEPER)
X			addnode(l,tokstr);
X		yylex();
X	}
X	return l;
X}
X
X/* get fd associated with str */
X
Xint getfdstr(s) /**/
Xchar *s;
X{
X	if (s[1]) return FD_WORD;
X	if (idigit(*s)) return *s-'0';
X	if (*s == 'p') return FD_COPROC;
X	if (*s == '-') return FD_CLOSE;
X	return FD_WORD;
X}
X
XCond par_cond_double(a,b) /**/
Xchar *a;char *b;
X{
XCond n = make_cond();
X
X	if (a[0] != '-' || !a[1] || a[2])
X		{
X		zerr("parse error: condition expected: %s",a,0);
X		return NULL;
X		}
X	n->left = b;
X	n->type = a[1];
X	n->types[0] = n->types[1] = NT_STR;
X	return n;
X}
X
XCond par_cond_triple(a,b,c) /**/
Xchar *a;char *b;char *c;
X{
XCond n = make_cond();
Xstatic char *condstrs[] = {
X	"nt","ot","ef","eq","ne","lt","gt","le","ge",NULL
X	};
Xint t0;
X
X	if ((b[0] == Equals || b[0] == '=') && !b[1])
X		n->type = COND_STREQ;
X	else if (b[0] == '!' && b[1] == '=' && !b[2])
X		n->type = COND_STRNEQ;
X	else if (b[0] == '-')
X		{
X		for (t0 = 0; condstrs[t0]; t0++)
X			if (!strcmp(condstrs[t0],b+1))
X				break;
X		if (condstrs[t0])
X			n->type = t0+COND_NT;
X		else
X			zerr("unrecognized condition: %s",b,0);
X		}
X	else
X		zerr("condition expected: %s",b,0);
X	n->left = a;
X	n->right = c;
X	n->types[0] = n->types[1] = NT_STR;
X	return n;
X}
X
Xvoid yyerror() /**/
X{
Xint t0;
X
X	for (t0 = 0; t0 != 20; t0++)
X		if (!yytext[t0] || yytext[t0] == '\n' || yytext[t0] == HISTSPACE)
X			break;
X	if (t0 == 20)
X		zerr("parse error near `%l...'",yytext,20);
X	else if (t0)
X		zerr("parse error near `%l'",yytext,t0);
X	else
X		zerr("parse error",NULL,0);
X}
X
SHAR_EOF
chmod 0644 zsh2.2/src/parse.c ||
echo 'restore of zsh2.2/src/parse.c failed'
Wc_c="`wc -c < 'zsh2.2/src/parse.c'`"
test 18760 -eq "$Wc_c" ||
	echo 'zsh2.2/src/parse.c: original size 18760, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_utils.pro ==============
if test -f 'zsh2.2/src/zle_utils.pro' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_utils.pro (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_utils.pro (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_utils.pro' &&
Xvoid sizeline DCLPROTO((int sz));
Xvoid spaceinline DCLPROTO((int ct));
Xvoid backkill DCLPROTO((int ct,int dir));
Xvoid forekill DCLPROTO((int ct,int dir));
Xvoid cut DCLPROTO((int i,int ct,int dir));
Xvoid backdel DCLPROTO((int ct));
Xvoid foredel DCLPROTO((int ct));
Xvoid setline DCLPROTO((char *s));
Xvoid sethistline DCLPROTO((unsigned char *s));
Xint findbol DCLPROTO((void));
Xint findeol DCLPROTO((void));
Xvoid findline DCLPROTO((int *a,int *b));
Xvoid initundo DCLPROTO((void));
Xvoid addundo DCLPROTO((void));
Xvoid freeundo DCLPROTO((void));
Xint hstrncmp DCLPROTO((char *s,char *t,int len));
Xint hstrcmp DCLPROTO((char *s,char *t));
Xchar *hstrnstr DCLPROTO((char *s,char *t,int len));
SHAR_EOF
chmod 0644 zsh2.2/src/zle_utils.pro ||
echo 'restore of zsh2.2/src/zle_utils.pro failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_utils.pro'`"
test 684 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_utils.pro: original size 684, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/signals.h.sample ==============
if test -f 'zsh2.2/src/signals.h.sample' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/signals.h.sample (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/signals.h.sample (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/signals.h.sample' &&
XYour signals.h file should look something like this.  If it doesn't,
Xperhaps your csh or ed is different.
X
X/* this file is created automatically by buildzsh */
X/* if all this is wrong, blame csh ;-) */
X
X#define SIGCOUNT       31
X
X#ifdef GLOBALS
X
Xchar *sigmsg[SIGCOUNT+2] = {
X	"done",
X	"hangup",
X	"interrupt",
X	"quit",
X	"illegal instruction",
X	"trace trap",
X	"abort",
X	"EMT instruction",
X	"floating point exception",
X	"killed",
X	"bus error",
X	"segmentation fault",
X	"bad system call",
X	"broken pipe",
X	"SIGALRM",
X	"terminated",
X	"SIGURG",
X#ifdef USE_SUSPENDED
X	"suspended (signal)",
X#else
X	"stopped (signal)",
X#endif
X#ifdef USE_SUSPENDED
X	"suspended",
X#else
X	"stopped",
X#endif
X	"continued",
X	"SIGCHLD",
X#ifdef USE_SUSPENDED
X	"suspended (tty input)",
X#else
X	"stopped (tty input)",
X#endif
X#ifdef USE_SUSPENDED
X	"suspended (tty output)",
X#else
X	"stopped (tty output)",
X#endif
X	"SIGIO",
X	"cpu limit exceeded",
X	"filesize limit exceeded",
X	"virtual time alarm",
X	"SIGPROF",
X	"SIGWINCH",
X	"SIGLOST",
X	"SIGUSR1",
X	"SIGUSR2",
X	NULL
X};
X
Xchar *sigs[SIGCOUNT+4] = {
X	"EXIT",
X	"HUP",
X	"INT",
X	"QUIT",
X	"ILL",
X	"TRAP",
X	"ABRT",
X	"EMT",
X	"FPE",
X	"KILL",
X	"BUS",
X	"SEGV",
X	"SYS",
X	"PIPE",
X	"ALRM",
X	"TERM",
X	"URG",
X	"STOP",
X	"TSTP",
X	"CONT",
X	"CHLD",
X	"TTIN",
X	"TTOU",
X	"IO",
X	"XCPU",
X	"XFSZ",
X	"VTALRM",
X	"PROF",
X	"WINCH",
X	"LOST",
X	"USR1",
X	"USR2",
X	"ERR",
X	"DEBUG",
X	NULL
X};
X
X#else
X
Xextern char *sigs[SIGCOUNT+4],*sigmsg[SIGCOUNT+2];
X
X#endif
SHAR_EOF
chmod 0644 zsh2.2/src/signals.h.sample ||
echo 'restore of zsh2.2/src/signals.h.sample failed'
Wc_c="`wc -c < 'zsh2.2/src/signals.h.sample'`"
test 1429 -eq "$Wc_c" ||
	echo 'zsh2.2/src/signals.h.sample: original size 1429, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_move.c ==============
if test -f 'zsh2.2/src/zle_move.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_move.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_move.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_move.c' &&
X/*
X *
X * zle_move.c - editor movement
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
X *
X * Permission is hereby granted to copy, reproduce, redistribute or otherwise
X * use this software as long as: there is no monetary profit gained
X * specifically from the use or reproduction of this software, it is not
X * sold, rented, traded or otherwise marketed, and this copyright notice is
X * included prominently in any copy made. 
X *
X * The author make no claims as to the fitness or correctness of this software
X * for any use whatsoever, and it is provided as is. Any use of this software
X * is at the user's own risk. 
X *
X */
X
X#define ZLE
X#include "zsh.h"
X
Xvoid beginningofline() /**/
X{
X	if (mult < 0) { mult = -mult; endofline(); return; }
X	while (mult--) {
X		if (cs == 0)
X			return;
X		if (line[cs-1] == '\n')
X			if (!--cs)
X				return;
X		while (cs && line[cs-1] != '\n') cs--;
X	}
X}
X
Xvoid endofline() /**/
X{
X	if (mult < 0) { mult = -mult; beginningofline(); return; }
X	while (mult--) {
X		if (cs >= ll) {
X			cs = ll;
X			return;
X		}
X		if (line[cs] == '\n')
X			if (++cs == ll)
X				return;
X		while (cs != ll && line[cs] != '\n') cs++;
X	}
X}
X
Xvoid beginningoflinehist() /**/
X{
X	if (mult < 0) { mult = -mult; endoflinehist(); return; }
X	while (mult) {
X		if (cs == 0)
X			break;
X		if (line[cs-1] == '\n')
X			if (!--cs)
X				break;
X		while (cs && line[cs-1] != '\n') cs--;
X		mult--;
X	}
X	if (mult) {
X		uphistory();
X		cs = 0;
X	}
X}
X
Xvoid endoflinehist() /**/
X{
X	if (mult < 0) { mult = -mult; beginningoflinehist(); return; }
X	while (mult) {
X		if (cs >= ll) {
X			cs = ll;
X			break;
X		}
X		if (line[cs] == '\n')
X			if (++cs == ll)
X				break;
X		while (cs != ll && line[cs] != '\n') cs++;
X		mult--;
X	}
X	if (mult)
X		downhistory();
X}
X
Xvoid forwardchar() /**/
X{
X	cs += mult;
X	if (cs > ll) cs = ll;
X	if (cs <  0) cs = 0;
X}
X
Xvoid backwardchar() /**/
X{
X	cs -= mult;
X	if (cs > ll) cs = ll;
X	if (cs <  0) cs = 0;
X}
X
Xvoid setmarkcommand() /**/
X{
X	mark = cs;
X}
X
Xvoid exchangepointandmark() /**/
X{
Xint x;
X
X	x = mark;
X	mark = cs;
X	cs = x;
X	if (cs > ll)
X		cs = ll;
X}
X
Xvoid vigotocolumn() /**/
X{
Xint x,y,ocs = cs;
X
X	if (mult > 0) mult--;
X	findline(&x,&y);
X	if (mult >= 0) cs = x+mult; else cs = y+mult;
X	if (cs < x || cs > y) {
X		feep();
X		cs = ocs;
X	}
X}
X
Xvoid vimatchbracket() /**/
X{
Xint ocs = cs,dir,ct;
Xchar oth,me;
X
Xotog:
X	if (cs == ll)
X		{
X		feep();
X		cs = ocs;
X		return;
X		}
X	switch(me = line[cs])
X		{
X		case '{': dir = 1; oth = '}'; break;
X		case '}': dir = -1; oth = '{'; break;
X		case '(': dir = 1; oth = ')'; break;
X		case ')': dir = -1; oth = '('; break;
X		case '[': dir = 1; oth = ']'; break;
X		case ']': dir = -1; oth = '['; break;
X		default: cs++; goto otog;
X		}
X	ct = 1;
X	while (cs >= 0 && cs < ll && ct)
X		{
X		cs += dir;
X		if (line[cs] == oth)
X			ct--;
X		else if (line[cs] == me)
X			ct++;
X		}
X	if (cs < 0 || cs >= ll)
X		{
X		feep();
X		cs = ocs;
X		}
X}
X
Xvoid viforwardchar() /**/
X{
X	if (mult < 0) { mult = -mult; vibackwardchar(); return; }
X	while (mult--) {
X		cs++;
X		if (cs >= ll || line[cs] == '\n') {
X			cs--;
X			break;
X		}
X	}
X}
X
Xvoid vibackwardchar() /**/
X{
X	if (mult < 0) { mult = -mult; viforwardchar(); return; }
X	while (mult--) {
X		cs--;
X		if (cs < 0 || line[cs] == '\n') {
X			cs++;
X			break;
X		}
X	}
X}
X
Xvoid viendofline() /**/
X{
X	cs = findeol();
X	if (!virangeflag && cs != 0 && line[cs-1] != '\n') cs--;
X}
X
Xvoid vibeginningofline() /**/
X{
X	cs = findbol();
X}
X
X
Xstatic int vfindchar,vfinddir,tailadd;
X
Xvoid vifindnextchar() /**/
X{
X	if (vfindchar = vigetkey())
X		{
X		vfinddir = 1;
X		tailadd = 0;
X		virepeatfind();
X		}
X}
X
Xvoid vifindprevchar() /**/
X{
X	if (vfindchar = vigetkey())
X		{
X		vfinddir = -1;
X		tailadd = 0;
X		virepeatfind();
X		}
X}
X
Xvoid vifindnextcharskip() /**/
X{
X	if (vfindchar = vigetkey())
X		{
X		vfinddir = 1;
X		tailadd = -1;
X		virepeatfind();
X		}
X}
X
Xvoid vifindprevcharskip() /**/
X{
X	if (vfindchar = vigetkey())
X		{
X		vfinddir = -1;
X		tailadd = 1;
X		virepeatfind();
X		}
X}
X
Xvoid virepeatfind() /**/
X{
Xint ocs = cs;
X
X	if (!vfinddir) { feep(); return; }
X	if (mult < 0) { mult = -mult; virevrepeatfind(); return; }
X	while (mult--)
X		{
X		do
X			cs += vfinddir;
X		while (cs >= 0 && cs < ll && line[cs] != vfindchar && line[cs] != '\n');
X		if (cs < 0 || cs >= ll || line[cs] == '\n')
X			{
X			feep();
X			cs = ocs;
X			return;
X			}
X		}
X	cs += tailadd;
X	if (vfinddir == 1 && virangeflag) cs++;
X}
X
Xvoid virevrepeatfind() /**/
X{
X	if (mult < 0) { mult = -mult; virepeatfind(); return; }
X	vfinddir = -vfinddir;
X	virepeatfind();
X	vfinddir = -vfinddir;
X}
X
Xvoid vifirstnonblank() /**/
X{
X	cs = findbol();
X	while (cs != ll && iblank(line[cs]))
X		cs++;
X}
X
Xvoid visetmark() /**/
X{
Xint ch;
X
X	ch = getkey(1);
X	if (ch < 'a' || ch > 'z') {
X		feep();
X		return;
X	}
X	ch -= 'a';
X	vimarkcs[ch] = cs;
X	vimarkline[ch] = histline;
X}
X
Xvoid vigotomark() /**/
X{
Xint ch;
X
X	ch = getkey(1);
X	if (ch == c) ch = 26;
X	else {
X		if (ch < 'a' || ch > 'z') {
X			feep();
X			return;
X		}
X		ch -= 'a';
X	}
X	if (!vimarkline[ch]) {
X		feep();
X		return;
X	}
X	if (curhist != vimarkline[ch]) {
X		mult = vimarkline[ch];
X		vifetchhistory();
X		if (curhist != vimarkline[ch]) return;
X	}
X	cs = vimarkcs[ch];
X	if (cs > ll) ch = ll;
X}
X
Xvoid vigotomarkline() /**/
X{
X	vigotomark();
X	cs = findbol();
X}
SHAR_EOF
chmod 0644 zsh2.2/src/zle_move.c ||
echo 'restore of zsh2.2/src/zle_move.c failed'
Wc_c="`wc -c < 'zsh2.2/src/zle_move.c'`"
test 5181 -eq "$Wc_c" ||
	echo 'zsh2.2/src/zle_move.c: original size 5181, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= zsh2.2/src/zle_misc.c ==============
if test -f 'zsh2.2/src/zle_misc.c' -a X"$1" != X"-c"; then
	echo 'x - skipping zsh2.2/src/zle_misc.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting zsh2.2/src/zle_misc.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'zsh2.2/src/zle_misc.c' &&
X/*
X *
X * zle_misc.c - miscellaneous editor routines
X *
X * This file is part of zsh, the Z shell.
X *
X * This software is Copyright 1992 by Paul Falstad
SHAR_EOF
true || echo 'restore of zsh2.2/src/zle_misc.c failed'
fi
echo 'End of zsh2.2 part 16'
echo 'File zsh2.2/src/zle_misc.c is continued in part 17'
echo 17 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
