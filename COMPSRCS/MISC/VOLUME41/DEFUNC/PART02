Newsgroups: comp.sources.misc
From: jinke@sparky.Phy.QueensU.CA (Ke Jin)
Subject: v41i033:  defunc - C library package for runtime function constructing, Part02/02
Message-ID: <1993Dec14.045908.9569@sparky.sterling.com>
X-Md4-Signature: 5a7b0b657b83447e3cccd34fa6c1d26a
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 14 Dec 1993 04:59:08 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jinke@sparky.Phy.QueensU.CA (Ke Jin)
Posting-number: Volume 41, Issue 33
Archive-name: defunc/part02
Environment: UNIX, yacc

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile defunc.3.UU defunc.h demo.c dfcscan.h
#   dfcsymtable.h dfctree.h dfopen.3.UU y.tab.c
# Wrapped by kent@sparky on Mon Dec 13 22:36:50 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(382 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# for library file 
XLIBDIR = /usr/lib 
X
X# for include file
XINCDIR = /usr/include
X
XCFLAGS = -O
XOBJS = defunc.o dfctree.o dfcsymtable.o y.tab.o
X
Xy.tab.c: dfcparse.y
X	$(YACC.y) dfcparse.y
X
Xinstall: libdfc.a
X	install libdfc.a $(LIBDIR)
X	install defunc.h $(INCDIR)
X	ranlib -t $(LIBDIR)/libdfc.a 
X
Xlibdfc.a: $(OBJS)
X	$(AR) $(ARFLAGS) $@ $(OBJS)
X	ranlib $@
X
Xclean:
X	$(RM) $(OBJS) y.tab.c 
END_OF_FILE
  if test 382 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'defunc.3.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defunc.3.UU'\"
else
  echo shar: Extracting \"'defunc.3.UU'\" \(7305 characters\)
  sed "s/^X//" >'defunc.3.UU' <<'END_OF_FILE'
Xbegin 644 defunc.3
XM"@H*1$5&54Y#*#,I(" @(" @(" @(" @("!#($Q)0E)!4ED@1E5.0U1)3TY3
XM(" @(" @(" @(" @("!$14953D,H,RD*"@H*3D%-10H@(" @(%\(9%\(95\(
XM9E\(=5\(;E\(8R M+2!A('!O<G1A8FQE($,@;&EB<F%R>2!P86-K86=E(&9O
XM<B!R=6YT:6UE("!F=6YC=&EO;@H@(" @(&-O;G-T<G5C=&EN9RX*"D1%4T-2
XM25!424]."B @(" @7PAD7PAE7PAF7PAU7PAN7PAC("A$>6YA;6EC("!%>'!R
XM97-S:6)L92 @1G5N8W1I;VX@($-O;G-T<G5C=&EN9RD@(&ES("!A"B @(" @
XM<&]R=&%B;&4@($,@(&QI8G)A<GD@<&%C:V%G92!F;W(@8V]N<W1R=6-T:6YG
XM(&9U;F-T:6]N<R!F<F]M"B @(" @<G5N=&EM92!I;G!U='1E9"!E>'!R97-S
XM:6]N<RX*"B @(" @7PAD7PAE7PAF7PAU7PAN7PAC("!L:6)R87)Y("!F=6YC
XM=&EO;B @7PAD7PAF7PAO7PAP7PAE7PAN*"D@(&%C8V5P=',@(&%N("!E>'!R
XM97-S:6]N"B @(" @<W1R:6YG(&%N9"P@;VX@<W5C8V5S<RP@<F5T=7)N<R!A
XM(&9U;F-T:6]N('!O:6YT97(N(&4N9RX*"B @(" @(" @(" C:6YC;'5D92 \
XM9&5F=6YC+F@^"@H@(" @(" @(" @9F]O*"D*(" @(" @(" @('L*(" @(" @
XM(" @(" @("!D;W5B;&4@*"IF;F-T<'1R*2@I.PH@(" @(" @(" @(" @(" @
XM+BXN+@H@(" @(" @(" @(" @(&9N8W1P='(@/2!D9F]P96XH(BAX*G@K>2IY
XM*5XP+C4B*3L*(" @(" @(" @(" @(" @("XN+BX*(" @(" @(" @('T["@H@
XM(" @(%1H92!F=6YC=&EO;B!D9F]P96XH*2 @:7,@(')E96YT97)A8FQE+B @
XM5&AA=" @:7,L("!Y;W4@(&-A;@H@(" @(')E<&5A=&5D;'D@(&-A;&P@9&9O
XM<&5N*"D@=VET:&]U="!W;W)R>2!A8F]U="!T:&4@;F5W(')E<W5L= H@(" @
XM(&UA>2!O=F5R;&%P(&]R(&1A;6%G92!T:&4@;VQD(&]N92P@87,@(&QO;F<@
XM(&%S("!Y;W4@(&%S<VEG;@H@(" @('1H96T@=&\@9&EF9F5R96YT(&QV86QU
XM97,N(&4N9RX*"B @(" @(" @("!D;W5B;&4@*"IF;F-T<'1R,2DH*3L*(" @
XM(" @(" @(&1O=6)L92 H*F9N8W1P='(R*2@I.PH@(" @(" @(" @("XN+@H@
XM(" @(" @(" @9FYC='!T<C$@/2!D9F]P96XH(F5X<"@M>"IX*2(I.PH@(" @
XM(" @(" @9FYC='!T<C(@/2!D9F]P96XH(F5X<"@M>"DJ<VEN*'@I(BD["B @
XM(" @(" @(" @+BXN"@H@(" @(%1H96XL(&9N8W1P='(Q(&%N9"!F;F-T<'1R
XM,B @=VEL;" @<&]I;G0@('1O("!T=V\@(&1I9F9E<F5N= H@(" @(&9U;F-T
XM:6]N<RX*"B @(" @1G5N8W1I;VX@9&9O<&5N*"D@<&%R<V5S('1H92!E>'!R
XM97-S:6]N(&)E('!A<W-E9" @8F%S960@(&]N"B @(" @=&]K96YS("!I=" @
XM<F5C;V=N:7IE9"X@17AC97!T(&9O<B!N=6UE<FEC86P@<W1R:6YG(&-O;G-T
XM86YT"B @(" @=&]K96YS*&DN92X@86YO;GEM;W5S(&-O;G-T86YT('1O:V5N
XM<RD@86YD(#@@8G5I;&0@:6X@=&]K96YS"B @(" @(BLB+" @(BTB+" @(BHB
XM+" B+R(L(")>(BP@(B@B+" B*2(L("(L(B!P;'5S(&$@<'-E=61O('1O:V5N
XM"B @(" @(CTB+"!A;&P@;W1H97(@=&]K96YS(&%R92!E>'1E<FYA;"!T;VME
XM;G,N("!%>'1E<FYA;" @=&]K96YS"B @(" @:6YC;'5D92 @87)G=6UE;G0@
XM=&]K96YS+"!F=6YC=&EO;B!T;VME;G,@86YD(&YA;65D(&-O;G-T86YT"B @
XM(" @=&]K96YS+B!4:&5Y(&%R92!S=&]R960@:6X@82!G;&]B86P@=&]K96X@
XM=&%B;&4N(%1H97D@8V%N(&)E"B @(" @<V5T+W)E<V5T("!O<B @061D960O
XM9&5L971E9" @<W1A=&EC86QL>2 @87,@=V5L;"!A<R!D>6YA;6DM"B @(" @
XM8V%L;'DN(&4N9RX*"B @(" @(" @("!N86UE87)G=2@B<F4B+" B:6TB*3L*
XM"B @(" @5&AI<R!W:6QL(')E<V5T(&%R9W5M96YT('1O:V5N<R!T;R B<F4B
XM(&%N9" B:6TB*'1H92!D969A=6QT"B @(" @87)E(")X(B!A;F0@(GDB*2X*
XM"@H*"F1E9G5N8R Q+C(@(" @(" @(" @($QA<W0@8VAA;F=E.B!$96,N(#$Y
XM.3,@(" @(" @(" @(" @(" @(" @(" Q"@H*"@H*"D1%1E5.0R@S*2 @(" @
XM(" @(" @(" @0R!,24)205)9($953D-424].4R @(" @(" @(" @(" @1$5&
XM54Y#*#,I"@H*"B @(" @(" @("!N86UE9FYC="@B;&]G(BP@;&]G*3L*(" @
XM(" @(" @(&YA;65F;F-T*")L;B(@+"!L;V<I.PH*(" @("!(97)E+"!T:&4@
XM97AT97)N86P@9G5N8W1I;VX@;&]G*"D@(&AA<R @8F5E;B @861D960@('1O
XM("!T:&4*(" @("!T;VME;B!L:7-T('=I=&@@,B!A;&EA<R!N86UE<R B;&]G
XM(B!A;F0@(FQN(BX*"B @(" @(" @("!N86UE8VYS="@B<&DB+" R+C J87-I
XM;B@Q+C I*3L*(" @(" @(" @(&YA;65C;G-T*")022(L(#(N,"IA<VEN*#$N
XM,"DI.PH*(" @("!4:&ES('=I;&P@861D(&$@;F%M960@8V]N<W1A;G0@=&]K
XM96X@=&\@=&AE(&QI<W0@=VET:" @86QI87,*(" @("!N86UE<R B<&DB(&%N
XM9" B4$DB(&%N9"!V86QU92 S+C$T,34Y,C8N+BX@+@H*(" @(" @(" @(&-L
XM<F-N<W0H(E!)(BD["@H@(" @(%1H:7,@=VEL;"!D96QE=&4@=&AE(&-O;G-T
XM86YT('1O:V5N(" B4$DB("!F<F]M("!T:&4@(&=L;V)A; H@(" @('1O:V5N
XM("!T86)L92X@($%F=&5R(&%N(&5X=&5R;F%L('1O:V5N(&AA<R!B965N('!U
XM="!I;G1O('1H90H@(" @(&=L;V)A;"!T;VME;B!L:7-T+"!I="!C86X@8F4@
XM=7-E9"!I;B!E>'!R97-S:6]N<R @<&%S<V5D("!T;PH@(" @(%\(9%\(9E\(
XM;U\(<%\(95\(;B@I+B @92YG+B!!9G1E<B!Y;W4@<'5T('1H92!E>'!O;F5N
XM=&EA;"!F=6YC=&EO;B!E>' H*0H@(" @(&EN=&\@=&]K96X@=&%B;&4@=VET
XM: H*(" @(" @(" @(&YA;65F;F-T*")E>' B+"!E>' I.PH@(" @(" @(" @
XM(" O*B!A9&0@97AP*"D@=&\@=&]K96X@=&%B;&4@<W1A=&EC86QL>2 J+PH*
XM(" @("!4:&%N('EO=2!C86X@=7-E(&ET('1O(&-O;G-T<G5C="!A(&=A=7-S
XM:6%N(&9U;F-T:6]N(&1Y;F%M:2T*(" @("!C86QL>2!A<PH*(" @(" @(" @
XM(&1O=6)L92 H*F=A=7-S*2@I.PH@(" @(" @(" @("XN+@H@(" @(" @(" @
XM9V%U<W,@/2!D9F]P96XH(F5X<"@M>"IX*2(I.PH*(" @("!!<F=U;65N="!T
XM;VME;G,L(&YA;65D(&-O;G-T86YT('1O:V5N<R!A;F0@9'EN86UI8V%L;'D@
XM(&-O;BT*(" @("!S=')U8W1E9" @9G5N8W1I;VYS("!C86X@8F4@<F5S970@
XM;W(@861D960@=&\@=&AE('1O:V5N(&QI<W0*(" @("!D>6YA;6EC86QL>2X@
XM5&AI<R!C86X@8F4@9&]N92!D:7)E8W1L>2!F<F]M("!T:&4@(&5X<')E<W-I
XM;VX*(" @("!P87-S960@=&\@7PAD7PAF7PAO7PAP7PAE7PAN*"D@9G5N8W1I
XM;VXN(&4N9RX*"B @(" @(" @("!F;F-T<'1R(#T@9&9O<&5N*")2:&\H<F4L
XM(&EM*3TH<F4J<F4K:6TJ:6TI7C N-2(I.PH*(" @("!4:&ES('=I;&P@<F5S
XM970@=&AE(&%R9W5M96YT('1O:V5N<R!T;R B<F4B(&%N9" B:6TB+"!R971U
XM<FX*(" @("!A("!D=7!L97@@(&9U;F-T:6]N('!O:6YT97(@86YD(&%D9"!T
XM:&ES(&9U;F-T:6]N('!O:6YT97(@=&\*(" @("!T:&4@9VQO8F%L('1O:V5N
XM(&QI<W0@=VET:"!N86UE(")2:&\B+@H*(" @(" @(" @(&1F;W!E;B@B9V%U
XM<W,H>"D]97AP*"UX*G@I(BD["@H@(" @(%1H:7,@<V5T<R!T:&4@9FER<W0@
XM87)G=6UE;G0@=&]K96YS('1O(")X(B!A;F0@(#)N9" @;VYE("!T;PH@(" @
XM(&YO;F4@86YD('!U="!T:&4@<F5T=7)N(&9U;F-T:6]N('!O:6YT97(@=&\@
XM=&AE(&=L;V)A;"!T;VME;@H@(" @('1A8FQE('=I=&@@;F%M92 B9V%U<W,B
XM('=H:6QE('1H92!R971U<FX@9G5N8W1I;VX@<&]I;G1E<B!I<PH@(" @(&YO
XM="!A<W-I9VYE9"!T;R!A;GD@;'9A;'5E+B!.;W<L('1H92!T;VME;B B9V%U
XM<W,B(&ES(')E8V]G+0H@(" @(&YI>F%B;&4@8GD@7PAD7PAE7PAF7PAU7PAN
XM7PAC(&%N9"!Y;W4@8V%N(&EN('1U<FX@=7-E("!I=" @=&\@(&-O;G-T<G5C
XM= H@(" @(&YE=R!F=6YC=&EO;BX@4W5C:"!A<PH*(" @(" @(" @(&1F;W!E
XM;B@B9V%U<W,R9"AX+'DI/6=A=7-S*'@I*F=A=7-S*'DI(BD["@H*"@ID969U
XM;F,@,2XR(" @(" @(" @("!,87-T(&-H86YG93H@1&5C+B Q.3DS(" @(" @
XM(" @(" @(" @(" @(" @,@H*"@H*"@I$14953D,H,RD@(" @(" @(" @(" @
XM($,@3$E"4D%262!&54Y#5$E/3E,@(" @(" @(" @(" @($1%1E5.0R@S*0H*
XM"@H@(" @('=I;&P@<F5T=7)N(&$@,B!D:6UE;G-I;VX@9V%U<W-I86X@9G5N
XM8W1I;VX@86YD("!P=70@(&ET("!T;PH@(" @('1O:V5N("!T86)L92 @=VET
XM:" @;F%M92 B9V%U<W,R9"(N($EF('EO=2!D;VXG="!W86YT('1H:7,@,@H@
XM(" @(&1I;65N<VEO;B!G875S<VEA;B!F=6YC=&EO;B!B92!P=71T960@:6YT
XM;R!T:&4@('1O:V5N("!T86)L90H@(" @(&)U="!Y;W4@<W1I;&P@=V%N="!R
XM97-E="!T:&4@87)G=6UE;G0@=&]K96YS+"!F;W(@97AA;7!L92!T;PH@(" @
XM(")A(BP@(F(B+"!Y;W4@8V%N('5S90H*(" @(" @(" @(&9N8W1P='(@/2!D
XM9F]P96XH(BAA+"!B*2 ](&=A=7-S*&$I*F=A=7-S*&(I(BD["@H@(" @(&]R
XM"@H@(" @(" @(" @9FYC='!R=" ](&1F;W!E;B@B9V%U<W,H82P@8BD@/2!G
XM875S<RAA*2IG875S<RAB*2(I.PH*(" @("!(97)E+"!F;F-T<'1R(&ES(&$@
XM9G5N8W1I;VX@<&]I;G1E<B!T;R!A8V-E<'0@('1H92 @<F5T=7)N960*(" @
XM("!V86QU92!F<F]M(%\(9%\(9E\(;U\(<%\(95\(;B@I+@H*(" @("!.86UE
XM9"!C;VYS=&%N="!T;VME;G,@8V%N(&%L<V\@8F4@861D960@=&\@('1H92 @
XM=&]K96X@(&QI<W0*(" @("!F<F]M(&5X<')E<W-I;VX@<&%S<V5D('1O(%\(
XM9%\(9E\(;U\(<%\(95\(;B@I+B!E+F<N"@H@(" @(" @(" @9FYC='!T<B ]
XM(&1F;W!E;B@B<&D@/2 T*F%T86XR*#$L,2DB*3L*"B @(" @5&AI<R!W:6QL
XM(')E='5R;B!A(&-O;G-T86YT(&9U;F-T:6]N(&%N9"!A9&0@(&$@(&YA;65D
XM("!C;VXM"B @(" @<W1A;G0@('1O:V5N("!T;R @=&AE('1O:V5N(&QI<W0@
XM=VET:"!V86QU92 S+C$T,34Y,C8N+BX@86YD"B @(" @;F%M92 B<&DB+@H*
XM4T5%($%,4T\*(" @("!D9F]P96XH,RD*"D%55$A/4@H@(" @($ME($II;@H@
XM(" @(%!H>7-I8W,@1&5P87)T;65N= H@(" @(%%U965N)W,@56YI=F5R<VET
XM>0H@(" @($MI;F=S=&]N+"!/;G1A<FEO"B @(" @0V%N861A($LW3" S3C8*
XM(" @("!J:6YK94!S<&%R:WDN<&AY+G%U965N<W4N8V$*"D)51U,*(" @("!2
XM97!O<G0@8G5G<R!O9B!?"&1?"&5?"&9?"'5?"&Y?"&,@;&EB<F%R>2!T;R!T
XM:&4@875T:&]R(&)Y(&5M86EL+@H*"@H*"@H*"@H*"@H*"@H*"@ID969U;F,@
XM,2XR(" @(" @(" @("!,87-T(&-H86YG93H@1&5C+B Q.3DS(" @(" @(" @
X1(" @(" @(" @(" @,PH*"@IT
X 
Xend
END_OF_FILE
  if test 7305 -ne `wc -c <'defunc.3.UU'`; then
    echo shar: \"'defunc.3.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'defunc.3'\" \(5282 characters\)
    cat defunc.3.UU | uudecode
    if test 5282 -ne `wc -c <'defunc.3'`; then
      echo shar: \"'defunc.3'\" uudecoded with wrong size!
    else
      rm defunc.3.UU
    fi
  fi
  # end of 'defunc.3.UU'
fi
if test -f 'defunc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defunc.h'\"
else
  echo shar: Extracting \"'defunc.h'\" \(3065 characters\)
  sed "s/^X//" >'defunc.h' <<'END_OF_FILE'
X/***************************************************************
X *
X *    Copyright (c) 1993  Ke Jin
X *
X *    Permission to use, copy, modify, and distribute
X *    this software and its documentation without fee
X *    is granted, provided that the author's name and
X *    this copyright notice are retained.
X *
X * -------------------------------------------------------------
X *
X *     defunc.h -- public interface of defunc high level module
X *
X *
X *     external function : namefnct();
X *                         namecnst();
X *                         nameargu();
X *                         getarguname();
X *                       
X *                         clrfnct();
X *                         clrfnctall();
X *                         clrcnst();
X *                         clrcnstall();
X *
X *                         matha2z();
X *
X *                         dfopen();
X *                         dfclose();
X *                         dfcloseall();
X *
X *     external variable : exparserror;
X *
X ***************************************************************/
X
X#ifndef _DEFUNC_H
X#define _DEFUNC_H
X
X#ifndef NeedFunctionPrototypes
X#if defined(__STDC__)||defined(__cplusplus)
X#define NeedFunctionPrototypes 1 /* for ANSI */ 
X#else
X#define NeedFunctionPrototypes 0 /* for K&R  */
X#endif  /* __STDC__ */
X#endif  /* NeedFunctionPrototypes */
X
X#ifdef __cplusplus
X  extern "C" {    /* for c++ */
X#endif
X
X#if NeedFunctionPrototypes
X  extern int    namefnct(char* name, double (*fnctptr)());
X  extern int    namecnst(char* name, double const_expression);
X  extern int    nameargu(char* name4arg1, char* name4arg2);
X  extern char*  getarguname(int argidx);
X  extern int    clrfnct(char* name);
X  extern int    clrfnctall(void);
X  extern int    clrcnst(char* name);
X  extern int    clrcnstall(void);
X
X  extern double (*dfopen(char* exprbody))(double x, double y);
X  extern int    dfclose(double (*fnctptr)());
X  extern int    dfcloseall(void);  
X
X  extern int    matha2z(void);
X
X  extern char*  exparserror;
X
X#else  /* for K&R */
X  extern int    namefnct();    /* set/delete alias name for function */
X  extern int    namecnst();    /* set/delete alias name for constant */
X  extern int    nameargu();    /* set symbol for function arguments  */
X  extern char*  getarguname(); /* retrive argument names             */
X  extern int    clrfnct();     /* clear a function token             */
X  extern int    clrfnctall();  /* clear all function tokens          */
X  extern int    clrcnst();     /* clear a constant token             */
X  extern int    clrcnstall();  /* clear all constant tokens          */
X
X  extern double (*dfopen())();   /* open function of an expression */
X  extern int    dfclose();       /* close a opened function        */
X  extern int    dfcloseall();    /* close all opened functions     */ 
X
X  extern int    matha2z();       /* install math symtable          */
X
X  extern char*  exparserror;     /* point to a error message string */
X#endif /* NeedFunctionPrototypes */
X
X#ifdef __cplusplus
X  }    /* end for c++ */
X#endif
X
X#endif /* _DEFUNC_H */
END_OF_FILE
  if test 3065 -ne `wc -c <'defunc.h'`; then
    echo shar: \"'defunc.h'\" unpacked with wrong size!
  fi
  # end of 'defunc.h'
fi
if test -f 'demo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo.c'\"
else
  echo shar: Extracting \"'demo.c'\" \(1324 characters\)
  sed "s/^X//" >'demo.c' <<'END_OF_FILE'
X/*********************************************************
X *
X *    example program of useing defunc (Ke Jin 1993)
X *
X *********************************************************/
X#include <stdio.h>
X#include <math.h>
X#include <defunc.h>
X
Xint main()
X{
X    double (*fp)();
X    char expr[128];
X    double x;
X
X    matha2z(); /* portable functions in  math lib into token table */
X
X    printf("\n\tEnter a expression please.\n");
X
X    for(;;)
X    {
X       printf("\n\tinput > ");
X       fgets(expr, 127, stdin);
X       expr[strlen(expr)-1]='\0';   /* strip off the '\n' on end */
X
X       if(strncmp(expr, "quit", 4)==0||
X	  strncmp(expr, "exit", 4)==0)
X       {
X           printf("\n\t\t--------- Bye! ---------\n\n");
X	   return 0;
X       }
X
X       fp = dfopen(expr);
X       if(fp==0) {
X	   if(exparserror!=0) 
X	      printf("\t\t%s\n", exparserror);
X           else
X	      printf("\t\tempty expression body\n");
X	   exparserror = 0;
X
X           printf("\n\t\tcurrent arguments are %s, %s\n",
X		       getarguname(1), getarguname(2));
X
X	   continue;
X       }
X
X       printf("\t\t%s\t\t%s\n", getarguname(1), expr);
X       for(x=0.0;x<1.0;x=x+0.1)
X       {
X	   printf("\t\t%f\t%f\n", x, fp(x,0));
X       }
X       printf("\n\t\tcurrent arguments are %s, %s\n", 
X	       getarguname(1), getarguname(2));
X
X       dfclose(fp);
X    }
X}
END_OF_FILE
  if test 1324 -ne `wc -c <'demo.c'`; then
    echo shar: \"'demo.c'\" unpacked with wrong size!
  fi
  # end of 'demo.c'
fi
if test -f 'dfcscan.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dfcscan.h'\"
else
  echo shar: Extracting \"'dfcscan.h'\" \(2758 characters\)
  sed "s/^X//" >'dfcscan.h' <<'END_OF_FILE'
X/****************************************************************
X *
X *    Copyright (c) 1993  Ke Jin
X *
X *    Permission to use, copy, modify, and distribute
X *    this software and its documentation without fee
X *    is granted, provided that the author's name and
X *    this copyright notice are retained.
X *
X * -------------------------------------------------------------
X *  
X *   dfcscan.h --- the lexical scaner of defunc
X *
X *   private variable : yyexpr;
X *                      yyexprlen;
X *                      yytext;
X *                      yypos;
X *
X *   private function : yylex();
X *
X ****************************************************************/
X
X#ifndef _DFCSCAN_H
X#define _DFCSCAN_H
X
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#include "dfcsymtable.h"
X
X#ifdef __cplusplus
X  extern "C" {    /* for c++ */
X#endif
X
Xstatic char* yyexpr;
Xstatic int   yyexprlen;
Xstatic char* yytext; 
Xstatic int   yypos;
X
X#if NeedFunctionPrototypes
X  static int yylex(void)
X#else
X  static int yylex()
X#endif
X{
X   char c;    
X   int  i;
X
X   Symbol_record* ptr;
X
X   /* --- [ \t] do nothing --------------------------------- */
X   for(;yypos<yyexprlen;yypos++)
X   {
X      c=yyexpr[yypos];
X      if(c==' '||c=='\t') continue;
X      break; 
X   }
X
X   /* --- {number} return token CONST with value ----------- */ 
X   if(c=='.'||isdigit(c))
X   {
X       sscanf(yyexpr+yypos, "%lf", &(yylval.value));
X       for(;yypos<=yyexprlen;yypos++)
X       {
X	   c=yyexpr[yypos];
X	   if(c=='.'||isdigit(c)) continue;
X	   break;
X       }
X       return CONST;
X   }
X
X   /* --- {symbol} return token VAR or FNCT with fnctptr --- */
X   if(isalpha(c))
X   {
X       yytext = (char*)malloc(sizeof(char)*(yyexprlen-yypos+1));
X       if(yytext==0) 
X       {
X	   perror("malloc for token text in module scaner");
X	   exit(1);
X       }
X
X       for(i=0;yypos<=yyexprlen;yypos++, i++)
X       {
X	   c=yyexpr[yypos];
X	   if(isalnum(c))
X	   {
X	       yytext[i]=c;
X	       continue;
X           }
X	   yytext[i]='\0';
X	   break;
X       }
X
X       ptr = (Symbol_record*)getsym(yytext);
X       if(ptr==0) /* symbol not in table */
X       {
X	   strncpy(yylval.name, yytext, 32);
X	   return SYM;
X       }
X
X       switch (ptr->type)
X       {
X	   case arg_symbol:
X		yylval.argidx = ptr->content.argidx;
X		return ARG;
X           
X	   case fnct_symbol:
X	        yylval.fnctptr = ptr->content.fnctptr; 
X	        return FNCT;
X
X           case const_symbol:
X	        yylval.value = ptr->content.value; 
X	        return CONST;
X       }
X   }
X
X   /* ------ append a '\n' on end ----------------- */
X   if(yypos==yyexprlen) return '\n';
X
X   yypos++;
X   /* ------ return other characters -------------- */
X   return c;
X};
X
X#ifdef __cplusplus
X  }    /* end for c++ */
X#endif
X
X#endif /* _DFCSCAN_H */
END_OF_FILE
  if test 2758 -ne `wc -c <'dfcscan.h'`; then
    echo shar: \"'dfcscan.h'\" unpacked with wrong size!
  fi
  # end of 'dfcscan.h'
fi
if test -f 'dfcsymtable.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dfcsymtable.h'\"
else
  echo shar: Extracting \"'dfcsymtable.h'\" \(2790 characters\)
  sed "s/^X//" >'dfcsymtable.h' <<'END_OF_FILE'
X/*********************************************************
X *
X *    Copyright (c) 1993  Ke Jin
X *
X *    Permission to use, copy, modify, and distribute
X *    this software and its documentation without fee
X *    is granted, provided that the author's name and
X *    this copyright notice are retained.
X *
X * -----------------------------------------------------
X *
X *    dfcsymtable.h -- interface of defunc symbol table
X *    
X *    struct definition : Symbol_record;
X *
X *    external function : getsym(); 
X *                        getfnctname();
X *                        getarguname();
X *                        initargu();
X *
X *                        nameargu();
X *                        namefnct();
X *                        namecnst();
X *                        clrfnct();
X *                        clrfnctall();
X *                        clrcnst();
X *                        clrcnstall();
X *                        
X *                        matha2z();
X *
X *********************************************************/
X
X#ifndef _DFCSYMTABLE_H
X#define _DFCSYMTABLE_H
X
X#ifndef NeedFunctionPrototypes
X#if defined(__STDC__)||defined(__cplusplus)
X#define NeedFunctionPrototypes 1
X#else
X#define NeedFunctionPrototypes 0
X#endif  /* __STDC__ */
X#endif  /* NeedFunctionPrototypes */
X
X#ifdef __cplusplus
X  extern "C" {    /* for c++ */
X#endif
X
Xtypedef enum {
X    arg_symbol, const_symbol, fnct_symbol
X} Symbol_type;
X
Xtypedef struct symbol_record
X/* association between symbol and its content */ 
X{
X    char*        name;
X    Symbol_type  type;
X    union {
X       int    argidx;
X       double value;
X       double (*fnctptr)();
X    } content;
X    struct symbol_record* next;
X} Symbol_record;
X
X#if NeedFunctionPrototypes
X   extern Symbol_record* getsym(char* name);
X   extern char* getfnctname(double (*fnctptr)()); 
X   extern char* getarguname(int argidx);
X   extern int initargu(void);
X
X   extern int nameargu(char* name4arg1, char* name4arg2);
X   extern int namefnct(char* name, double (*fnctptr)());
X   extern int namecnst(char* name, double constexpress);
X   extern int clrfnct(char* name);
X   extern int clrfnctall(void);
X   extern int clrcnst(char* name);
X   extern int clrcnstall(void);
X
X   extern int matha2z(void);
X#else
X   extern Symbol_record* getsym();   /* searching symbol in sym_table */
X   extern char* getfnctname();
X   extern char* getarguname();
X   extern int initargu();
X
X   extern int nameargu();
X   extern int namefnct();            /* function alias name */
X   extern int namecnst();            /* constant alias name */
X   extern int clrfnct();
X   extern int clrfnctall();
X   extern int clrcnst();
X   extern int clrcnstall();
X
X   extern int matha2z();
X#endif /* NeedFunctionPrototypes */
X
X#ifdef __cplusplus
X  }    /* end for c++ */
X#endif
X
X#endif /* _DFCSYMTABLE_H */
END_OF_FILE
  if test 2790 -ne `wc -c <'dfcsymtable.h'`; then
    echo shar: \"'dfcsymtable.h'\" unpacked with wrong size!
  fi
  # end of 'dfcsymtable.h'
fi
if test -f 'dfctree.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dfctree.h'\"
else
  echo shar: Extracting \"'dfctree.h'\" \(1988 characters\)
  sed "s/^X//" >'dfctree.h' <<'END_OF_FILE'
X/*********************************************************
X *
X *    Copyright (c) 1993  Ke Jin
X *
X *    Permission to use, copy, modify, and distribute
X *    this software and its documentation without fee
X *    is granted, provided that the author's name and
X *    this copyright notice are retained.
X *
X * -----------------------------------------------------
X *
X *    dfctree.h -- interface of defunc low level module
X *
X *    struct definition : Node
X *
X *    external function : exparse(); 
X *			  evaluate();
X *                        getparsetree(); 
X *                        reduce();
X *
X *********************************************************/
X
X#ifndef _DFCTREE_H
X#define _DFCTREE_H
X
X#ifndef NeedFunctionPrototypes
X#if defined(__STDC__)||defined(__cplusplus)
X#define NeedFunctionPrototypes 1
X#else 
X#define NeedFunctionPrototypes 0
X#endif  /* __STDC__ */
X#endif  /* NeedFunctionPrototypes */
X
X#ifdef __cplusplus
X  extern "C" {    /* for c++ */
X#endif
X
Xtypedef enum { 
X    const_node, 
X    arg_node, 
X
X    unary_op_node,
X    binary_op_node, 
X
X    simplex_fnct_node, 
X    duplex_fnct_node,
X    triplex_fnct_node,  /* not used in current version */
X
X    arg_fnct_node       /* not used in current version */
X} Node_type;
X
Xtypedef enum {
X    op_sum,
X    op_sub,
X    op_mul,
X    op_div,
X    op_neg
X} op_idx;
X
Xtypedef struct {
X    Node_type type;
X    union {
X       int    argidx;
X       op_idx op;
X       double value;
X       double (*fnctptr)();
X    } content;
X    int left;
X    int right;
X} Node;
X
X#if NeedFunctionPrototypes /* ANSI */
X   extern int    exparse(char* expression);
X   extern double evaluate(Node* tree, int i, double x, double y);
X   extern int    getparsetree(Node* buff);
X   extern Node*  reduce(Node* tree, int i);
X#else /* K&R */
X   extern int    exparse();
X   extern double evaluate();
X   extern int    getparsetree();
X   extern Node*  reduce();
X#endif /* NeedFunctionPrototype */
X
X#ifdef __cplusplus
X  }    /* end for c++ */
X#endif
X
X#endif /* _DFCTREE_H */
END_OF_FILE
  if test 1988 -ne `wc -c <'dfctree.h'`; then
    echo shar: \"'dfctree.h'\" unpacked with wrong size!
  fi
  # end of 'dfctree.h'
fi
if test -f 'dfopen.3.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dfopen.3.UU'\"
else
  echo shar: Extracting \"'dfopen.3.UU'\" \(6313 characters\)
  sed "s/^X//" >'dfopen.3.UU' <<'END_OF_FILE'
Xbegin 644 dfopen.3
XM"@H*1$5&54Y#*#,I(" @(" @(" @(" @("!#($Q)0E)!4ED@1E5.0U1)3TY3
XM(" @(" @(" @(" @("!$14953D,H,RD*"@H*3D%-10H@(" @(&1F;W!E;BP@
XM9&9C;&]S92P@9&9C;&]S96%L;" M+2!D>6YA;6EC(&9U;F-T:6]N(&-O;G-T
XM<G5C=&EN9PH@(" @(&%N9"!D96-O;G-T<G5C=&EN9RX*"E-93D]04TE3"B @
XM(" @(VEN8VQU9&4@/&1E9G5N8RYH/@H*(" @("!D;W5B;&4@*"ID9F]P96XH
XM8VAA<BH@97AP<F5S<VEO;BDI*&1O=6)L92!X+"!D;W5B;&4@>2D["@H@(" @
XM(&EN=" @("!D9F-L;W-E*&1O=6)L92 H*F1C9FYC="DH*2D["B @(" @:6YT
XM(" @(&1F8VQO<V5A;&PH=F]I9"D["@I$15-#4DE05$E/3@H@(" @(%\(9%\(
XM9E\(;U\(<%\(95\(;B@I(&1Y;F%M:6-A;&QY(&-O;G-T<G5C=',@82!F=6YC
XM=&EO;B!F<F]M("!A;B @97AP<F5S+0H@(" @('-I;VX@('-T<FEN9R!P87-S
XM960@=&\@:70N(&5X<')E<W-I;VX@<W1R:6YG(&ES('5S=6%L;'D@8V]N+0H@
XM(" @('-I<W1S(&]F(&YA;64@86YD(&%R9W5M96YT<R!S971T:6YG(&EN9F]R
XM;6%T:6]N(&EN(&9R;VYT("!O9@H@(" @('1H92 @97AP<F5S<VEO;B @8F]D
XM>2 @86YD("!S97!A<F%T92!W:71H(&ET(&)Y('!S975D;R!T;VME;@H@(" @
XM("<])SH*"B @(" @(" @(" B;F%M92@@87)G,7-T+"!A<F<R;F0@*2 ](&)O
XM9'DB"@H@(" @($]N('-U8V-E<W,L(%\(9%\(9E\(;U\(<%\(95\(;B@I('=I
XM;&P@<F5T=7)N(&$@<&]I;G1E<B!A9&1R97-S:6YG("!T;R @80H@(" @(&=L
XM;V)A;" @:&%N9&QE("!F=6YC=&EO;BX@("!4:&4@9VQO8F%L(&AA;F1L92!F
XM=6YC=&EO;G,@:&%V90H@(" @('1H92!P<F]T;W1Y<&4@;V8*"B @(" @(" @
XM("!D;W5B;&4@:&1L*&1O=6)L92!X+"!D;W5B;&4@>2D["@H@(" @($EF('1H
XM92!N86UE('-T<FEN9R @:7,@(&$@(&QE9V%L("!T;VME;B @;F%M92AS=&%R
XM=&EN9R @=VET: H@(" @(&%L<&AA8F5T:6,@8VAA<F%C=&5R(&%N9"!F;VQL
XM;W=E9"!B>2!A;'!H86)E=&EC(&]R(&YU;65R:6-A; H@(" @(&-H87)A8W1E
XM<G,I+"!T:&5N('1H92!C;VYS=')U8W1E9"!F=6YC=&EO;B!W:6QL(&)E('!U
XM=" @:6YT;PH@(" @('1H92 @=&]K96X@=&%B;&4@875T;VUA=&EC86QL>2X@
XM($EF('1H92 Q<W0@87)G=6UE;G0@;F%M92!I<PH@(" @(&$@;&5G86P@=&]K
XM96X@;F%M92P@=&AE;B!T:&4@87)G=6UE;G0@('1O:V5N("!N86UE("!W:6QL
XM("!B90H@(" @(')E<V5T("!T;R!I="@@=&AE(&1E9F%U;'0@87)E(")X(B!A
XM;F0@(GDB*2X@3W1H97(@;W!T:6]N<R!O9@H@(" @(&5X<')E<W-I;VX@87)E
XM.@H*(" @(" @(")B;V1Y(B @(" @(" @(" @(" @($]N;'D@<F5T=7)N('1H
XM92!C;VYS=')U8W1E9"!F=6YC=&EO;BX*"B @(" @(" B*&%R9S%S="P@87)G
XM,G-T*3TB("!297-E="!T:&4@87)G=6UE;G0@=&]K96X@;F%M97,@;VYL>2X*
XM"B @(" @(" B;F%M92@I/6)O9'DB(" @(" @("!0=70@9G5N8W1I;VX@=&]K
XM96X@:6YT;R!T86)L92X*"B @(" @(" B;F%M92 ](&)O9'DB(" @(" @("!0
XM=70@8V]N<W1A;G0@=&]K96X@:6YT;R!T86)L92X*"B @(" @(" B7&YA;64H
XM87)G,7-T+"!A<F<R;F0I/2(@($IU<W0@<F5S970@=&AE(&%R9W5M96YT('1O
XM:V5N"B @(" @(" @(" @(" @(" @(" @(" @(" @("!N86UE<RX@5&AE(&YA
XM;64@:7,@:6=N;W)E9"X*"B @(" @(" B7&YA;64H87)G,7-T+"!A<F<R;F0I
XM/6)O9'DB("!297-E="!T:&4@87)G=6UE;G0@=&]K96X*(" @(" @(" @(" @
XM(" @(" @(" @(" @(" @(&YA;65S(&%N9"!R971U<FX@=&AE(&-O;G-T<G5C
XM=&5D"B @(" @(" @(" @(" @(" @(" @(" @(" @("!F=6YC=&EO;B!W:71H
XM;W5T('!U="!I="!T;R!T:&4@=&]K96X*(" @(" @(" @(" @(" @(" @(" @
XM(" @(" @('1A8FQE+@H*(" @("!/;B!E<G)O<B!O<B @=&AE("!E>'!R97-S
XM:6]N("!S=')I;F<@(&1O97-N)W0@(&=E;F5R871I;F<@(&$*"@H*9&5F=6YC
XM(#$N,B @(" @(" @(" @(" @3&%S="!C:&%N9V4Z(#$Y.3,@(" @(" @(" @
XM(" @(" @(" @(" @(#$*"@H*"@H*1$5&54Y#*#,I(" @(" @(" @(" @("!#
XM($Q)0E)!4ED@1E5.0U1)3TY3(" @(" @(" @(" @("!$14953D,H,RD*"@H*
XM(" @("!F=6YC=&EO;BAE+F<N("!A;B @97AP<F5S<VEO;B @=VET:" @96UP
XM='D@(&)O9'DI+" @7PAD7PAF7PAO7PAP7PAE7PAN*"D*(" @("!R971U<FYS
XM(&$@;G5L;"!P;VEN=&5R+B!4:&5R92!A<F4@,S(@9VQO8F%L(&AA;F1L92!F
XM=6YC=&EO;G,*(" @("!A=F%I;&%B;&4N(" @5&AU<RP@=VET:&EN(&]N92!P
XM<F]C97-S+"!A<R!M86YY(&%S(#,R(&1Y;F%M:2T*(" @("!C86QL>2!C;VYS
XM=')U8W1E9"!F=6YC=&EO;G,@87)E(&%L;&]W960@=&\@8V]E>&ES="X@5&AE
XM(&AA;BT*(" @("!D;&4@(&9U;F-T:6]N<R @8V%N("!O;FQY("!B92 @9G)E
XM960@('=I=&@@(%\(9%\(95\(9E\(=5\(;E\(8R @9G5N8VEO;G,*(" @("!?
XM"&1?"&9?"&-?"&Q?"&]?"'-?"&4H*2!A;F0@7PAD7PAF7PAC7PAL7PAO7PAS
XM7PAE7PAA7PAL7PAL*"D@;W(@96YD(&]F('1H92!P<F]C97-S+@H*(" @("!?
XM"&1?"&9?"&-?"&Q?"&]?"'-?"&4H*2!W:6QL(&-L;W-E('1H92 @9'EN86UI
XM8V%L;'D@(&-O;G-T<G5C=&5D("!F=6YC=&EO;@H@(" @('!A<W-E9" @=&\@
XM(&ET+B @5&AI<R!W:6QL(&9R964@=&AE(&%S<V]C:6%T960@9VQO8F%L(&AA
XM;F1L90H@(" @(&9U;F-T:6]N(&9O<B!R975S92X@3VX@<W5C8V5S<RP@7PAD
XM7PAF7PAC7PAL7PAO7PAS7PAE*"D@<F5T=7)N("AI;G0I,"X@($EF"B @(" @
XM=&AI<R @9G5N8W1I;VX@(&ES("!S=&EL;" @:6X@=&AE(&=L;V)A;"!T;VME
XM;B!T86)L92!O<B!T:&ES"B @(" @9G5N8W1I;VX@(&ES("!N;W0@(')E='5R
XM;F5D("!F<F]M("!A("!?"&1?"&9?"&]?"'!?"&5?"&XH*2 @8V%L;"P@("!T
XM:&5N"B @(" @7PAD7PAF7PAC7PAL7PAO7PAS7PAE*"D@=VEL;"!N;W0@8VQO
XM<V4@:70@86YD(')E='5R;B M,2X*"B @(" @7PAD7PAF7PAC7PAL7PAO7PAS
XM7PAE7PAA7PAL7PAL*"D@9G)E92!A;&P@:&%N9&QE(&9U;F-T:6]N<R!W:&EC
XM:"!A<F4@;F]T(&]N("!T:&4*(" @("!G;&]B86P@=&]K96X@=&%B;&4N($]N
XM('-U8V-E<W,@8V%L;"P@7PAD7PAF7PAC7PAL7PAO7PAS7PAE7PAA7PAL7PAL
XM*"D@<F5T=7)N('1H90H@(" @('1O=&%L(&YU;6)E<B!O9B!H86YD;&5S(&9R
XM965D(&)Y(&ET+@H*4T5%($%,4T\*(" @("!?"&1?"&5?"&9?"'5?"&Y?"&,@
XM("!A;F0@("!G971A<F=U;F%M92@S*2P@("!N86UE87)G=2@S*2P@("!N86UE
XM9FYC="@S*2P*(" @("!N86UE8VYS="@S*2P@(" @8VQR9FYC="@S*2P@(" @
XM8VQR9FYC=&%L;"@S*2P@(" @8VQR8VYS="@S*2P*(" @("!C;')C;G-T86QL
XM*#,I"@I%6$%-4$Q%4PH@(" @(" @(" @9&]U8FQE("@J9FYC='!T<BDH*3L*
XM(" @(" @(" @(&9N8W1P='(@/2!D9F]P96XH(E)H;RAR92P@:6TI(#T@*')E
XM*G)E*VEM*FEM*5XP+C4B*3L*"B @(" @5&AI<R!W:6QL("!R971U<FX@(&$@
XM(&AY<&]T96YU<R @9G5N8W1I;VXL("!C:&%N9V4@(&%R9W5M96YT"B @(" @
XM=&]K96YS("!T;R @(G)E(B @86YD(" B:6TB("!A;F0@('!U=" @=&AE(')E
XM='5R;F5D(&9U;F-T:6]N"B @(" @<&]I;G1E<B!I;G1O('1O:V5N('1A8FQE
XM('=I=&@@;F%M92 B4FAO(BX*"B @(" @(" @("!D;W5B;&4@*"IF;F-T<'1R
XM*2@I.PH@(" @(" @(" @9FYC='!T<B ](&1F;W!E;B@B<&D@/2 R*F%S:6XH
XM,2DB*3L*"B @(" @5&AI<R!W:6QL(')E='5R;B!A(&-O;G-T86YT(&9U;F-T
XM:6]N*')E='5R;B!V86QU<V4@:7,@82!C;VXM"B @(" @<W1A;G0@("TM(" S
XM+C$T,34Y+BXN*2!A;F0@861D(&$@8V]N<W1A;G0@=&]K96X@=&\@=&AE('1O
XM:V5N"B @(" @=&%B;&4@=VET:"!V86QU92 S+C$T,34Y+BXN(&%N9"!N86UE
XM(")P:2(N("!!<R @=&AE(" G/2<@(&ES"B @(" @;VYL>2!A('!S975D;R!T
XM;VME;BP@=&AU<R!T:&4@97AP<F5S<VEO;@H*(" @(" @(" @(")P:2 ](%!)
XM(#T@,BIA<VEN*#$I(@H*(" @("!I<R!S=&EL;"!U;G)E8V]G;FEZ86)L92!B
XM>2!T:&4@7PAD7PAE7PAF7PAU7PAN7PAC"@I!551(3U(*(" @("!+92!*:6X*
XM(" @("!0:'ES:6-S($1E<&%R=&UE;G0*(" @("!1=65E;B=S(%5N:79E<G-I
XM='D*(" @("!+:6YG<W1O;BP@3VYT87)I;PH@(" @($-A;F%D82!+-TP@,TXV
XM"B @(" @:FEN:V5 <W!A<FMY+G!H>2YQ=65E;G-U+F-A"@H*"@H*9&5F=6YC
XM(#$N,B @(" @(" @(" @(" @3&%S="!C:&%N9V4Z(#$Y.3,@(" @(" @(" @
XM(" @(" @(" @(" @(#(*"@H*"@H*1$5&54Y#*#,I(" @(" @(" @(" @("!#
XM($Q)0E)!4ED@1E5.0U1)3TY3(" @(" @(" @(" @("!$14953D,H,RD*"@H*
XM0E5'4PH@(" @(%)E<&]R="!B=6=S(&]F(%\(9%\(95\(9E\(=5\(;E\(8R!L
XM:6)R87)Y('1O('1H92!A=71H;W(@8GD@96UA:6PN"@H*"@H*"@H*"@H*"@H*
XM"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*9&5F=6YC
XM(#$N,B @(" @(" @(" @(" @3&%S="!C:&%N9V4Z(#$Y.3,@(" @(" @(" @
X2(" @(" @(" @(" @(#,*"@H*
X 
Xend
END_OF_FILE
  if test 6313 -ne `wc -c <'dfopen.3.UU'`; then
    echo shar: \"'dfopen.3.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'dfopen.3'\" \(4563 characters\)
    cat dfopen.3.UU | uudecode
    if test 4563 -ne `wc -c <'dfopen.3'`; then
      echo shar: \"'dfopen.3'\" uudecoded with wrong size!
    else
      rm dfopen.3.UU
    fi
  fi
  # end of 'dfopen.3.UU'
fi
if test -f 'y.tab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'y.tab.c'\"
else
  echo shar: Extracting \"'y.tab.c'\" \(14183 characters\)
  sed "s/^X//" >'y.tab.c' <<'END_OF_FILE'
X
X# line 32 "dfcparse.y"
X#include <stdio.h>
X#include <malloc.h>
X#include <math.h>
X#include <string.h>
X#include "dfctree.h"
X#include "dfcsymtable.h"
X
Xchar*         exparserror;
Xstatic char   ermsgbuff[128];
Xstatic Node*  yyparsetree; 
Xstatic int    yytreesize;
Xstatic Node   newnode;
X
X#if NeedFunctionPrototypes
X  int yyparse(void);
X  static int yyreverse(void);
X#else
X  extern int yyparse();
X  extern int yyreverse();
X#endif
X
X#if NeedFunctionPrototypes
X  static int addnode(Node *ptr)
X#else
X  static int addnode(ptr)
X  Node *ptr;
X#endif
X{
X    yytreesize++;
X
X    if(yytreesize==1)
X    {
X        yyparsetree = (Node*)malloc(sizeof(Node));
X    }
X    else
X    {
X        yyparsetree = (Node*)realloc((Node*)yyparsetree, 
X                                 yytreesize*sizeof(Node));
X    }
X    if(yyparsetree==0)
X    {
X	perror("malloc/realloc in addnode()");
X	exit(1);
X    }
X
X    if(yyparsetree == 0) 
X    {
X        fprintf(stderr, "fail to allocate memory in add node\n");
X        exit(1);
X    }
X
X    /* yyparsetree[yytreesize-1] = *ptr; */
X    memcpy(yyparsetree+yytreesize-1, ptr, sizeof(Node)); 
X
X    return yytreesize-1;
X};
X
X
X# line 91 "dfcparse.y"
Xtypedef union  {
X    int    nodeidx;
X    int    argidx;
X    double value;
X    double (*fnctptr)();
X    char   name[32];
X} YYSTYPE;
X# define CONST 257
X# define ARG 258
X# define FNCT 259
X# define SYM 260
X# define SIG 261
X#define yyclearin yychar = -1
X#define yyerrok yyerrflag = 0
Xextern int yychar;
Xextern short yyerrflag;
X#ifndef YYMAXDEPTH
X#define YYMAXDEPTH 150
X#endif
XYYSTYPE yylval, yyval;
X# define YYERRCODE 256
X
X# line 231 "dfcparse.y"
X /* --------------------------------------------------------- */
X#include "dfcscan.h"
X
X#if NeedFunctionPrototype
X  int yyinit(char* expr)
X#else
X  int yyinit(expr)
X  char *expr; 
X#endif
X{
X    initargu();
X
X    yyexpr = expr;
X    yyexprlen = strlen(yyexpr);
X    yypos = 0;
X    yytreesize = 0;
X
X    return 0;
X};
X
X#if NeedFunctionPrototypes
X  static int yyreverse(void)
X#else
X  static int yyreverse()  
X#endif
X/* yyparse() use a LALR(1) bottom-up algorithem to construct the
X   parse tree. Thus the result tree is upsetdown, i.e. the root
X   is place on the end of the yyparsetree[]. yyreverse make it
X   in right order, i.e. yyparsetree[0] be the root */
X{
X    int   i;
X    Node* buff;
X
X    if(yytreesize==0) return 0;
X
X    buff = (Node*)malloc(sizeof(Node)*yytreesize);
X    if(buff==0) 
X    {
X	perror("malloc in reverse()");
X	exit(1);
X    }
X
X    for(i=0; i<yytreesize; i++) /* reverse */
X    {
X	
X 	/* buff[i] = yyparsetree[yytreesize-1-i]; */
X	memcpy(buff+i, yyparsetree+yytreesize-1-i, sizeof(Node));
X	buff[i].left = yytreesize - 1 - buff[i].left;
X	buff[i].right= yytreesize - 1 - buff[i].right;
X
X    }
X
X    for(i=0; i<yytreesize; i++) /* put it back */ 
X    {
X	yyparsetree[i] = buff[i];
X    }
X
X    free(buff);
X
X    return yytreesize;
X};
X
X#if NeedFunctionPrototypes
X  int getparsetree(Node* buff)
X#else
X  int getparsetree(buff)
X  Node* buff;
X#endif
X/* copy the parse into buff */
X{
X    int i;
X
X    for(i=0; i<yytreesize; i++)
X    {
X	buff[i] = yyparsetree[i];
X    }
X
X    return yytreesize;
X};
X
X#if NeedFunctionPrototypes
X  static void yyerror(char* s)
X#else
X  static yyerror(s)
X  char *s;
X#endif
X{
X    exparserror=s;
X};
X
X#if NeedFunctionPrototypes
X  static int yywrap(void)
X#else
X  static int yywrap()
X#endif
X{
X   return 1;
X};
Xshort yyexca[] ={
X-1, 1,
X	0, -1,
X	-2, 0,
X	};
X# define YYNPROD 22
X# define YYLAST 251
Xshort yyact[]={
X
X   2,  12,  31,  19,  11,  12,  10,  13,  11,  22,
X  10,  39,  17,  15,  40,  16,  21,  18,  36,  17,
X  15,  37,  16,  17,  18,  42,  17,  15,  18,  16,
X  12,  18,  20,  11,   1,  10,   0,   0,   0,  17,
X  15,   0,  16,   0,  18,   0,  35,  17,  15,   3,
X  16,   0,  18,  34,  17,  15,  14,  16,   0,  18,
X   0,   0,   0,   0,  19,   0,   0,   0,   0,   0,
X   4,  19,   0,   0,   0,  19,   0,   0,  19,   0,
X   0,  23,  24,  25,   0,   0,  26,  27,  28,  29,
X  30,  19,  32,  33,   0,   0,   0,   0,   0,  19,
X   0,   0,   0,   0,   0,   0,  19,   0,  38,   0,
X   0,  41,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   6,   8,
X   9,   7,   6,   8,   9,   7,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
X   0,   0,   0,   0,   0,   0,   5,   6,   8,   9,
X   7 };
Xshort yypact[]={
X
X -10,-1000,-1000,-1000,  -3,  22, -24,-1000,-1000, -31,
X -35, -35, -35,-1000,-1000, -35, -35, -35, -35, -35,
X-1000, -39, -35, -91, -91,  12, -19, -19, -91, -91,
X -91,-1000,   5, -23,-1000,-1000,-1000, -35, -30,-1000,
X -35, -16,-1000 };
Xshort yypgo[]={
X
X   0,  70,  34 };
Xshort yyr1[]={
X
X   0,   2,   2,   2,   2,   2,   1,   1,   1,   1,
X   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
X   1,   1 };
Xshort yyr2[]={
X
X   0,   1,   1,   2,   2,   2,   1,   1,   3,   4,
X   1,   4,   6,   8,   3,   3,   3,   3,   2,   2,
X   3,   3 };
Xshort yychk[]={
X
X-1000,  -2,  10,  59,  -1, 256, 257, 260, 258, 259,
X  45,  43,  40,  10,  59,  43,  45,  42,  47,  94,
X  10,  40,  40,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
X  -1,  41,  -1,  -1,  41,  41,  41,  44,  -1,  41,
X  44,  -1,  41 };
Xshort yydef[]={
X
X   0,  -2,   1,   2,   0,   0,   6,   7,  10,   0,
X   0,   0,   0,   3,   4,   0,   0,   0,   0,   0,
X   5,   0,   0,  18,  19,   0,  14,  15,  16,  17,
X  20,   8,   0,   0,  21,   9,  11,   0,   0,  12,
X   0,   0,  13 };
X#ifndef lint
Xstatic	char yaccpar_sccsid[] = "@(#)yaccpar 1.6 88/02/08 SMI"; /* from UCB 4.1 83/02/11 */
X#endif
X
X#
X# define YYFLAG -1000
X# define YYERROR goto yyerrlab
X# define YYACCEPT return(0)
X# define YYABORT return(1)
X
X/*	parser for yacc output	*/
X
X#ifdef YYDEBUG
Xint yydebug = 0; /* 1 for debugging */
X#endif
XYYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
Xint yychar = -1; /* current input token number */
Xint yynerrs = 0;  /* number of errors */
Xshort yyerrflag = 0;  /* error recovery flag */
X
Xyyparse() {
X
X	short yys[YYMAXDEPTH];
X	short yyj, yym;
X	register YYSTYPE *yypvt;
X	register short yystate, *yyps, yyn;
X	register YYSTYPE *yypv;
X	register short *yyxi;
X
X	yystate = 0;
X	yychar = -1;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yyps= &yys[-1];
X	yypv= &yyv[-1];
X
X yystack:    /* put a state and value onto the stack */
X
X#ifdef YYDEBUG
X	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
X#endif
X		if( ++yyps>= &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
X		*yyps = yystate;
X		++yypv;
X		*yypv = yyval;
X
X yynewstate:
X
X	yyn = yypact[yystate];
X
X	if( yyn<= YYFLAG ) goto yydefault; /* simple state */
X
X	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
X	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;
X
X	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
X		yychar = -1;
X		yyval = yylval;
X		yystate = yyn;
X		if( yyerrflag > 0 ) --yyerrflag;
X		goto yystack;
X		}
X
X yydefault:
X	/* default state action */
X
X	if( (yyn=yydef[yystate]) == -2 ) {
X		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
X		/* look through exception table */
X
X		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */
X
X		while( *(yyxi+=2) >= 0 ){
X			if( *yyxi == yychar ) break;
X			}
X		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
X		}
X
X	if( yyn == 0 ){ /* error */
X		/* error ... attempt to resume parsing */
X
X		switch( yyerrflag ){
X
X		case 0:   /* brand new error */
X
X			yyerror( "syntax error" );
X		yyerrlab:
X			++yynerrs;
X
X		case 1:
X		case 2: /* incompletely recovered error ... try again */
X
X			yyerrflag = 3;
X
X			/* find a state where "error" is a legal shift action */
X
X			while ( yyps >= yys ) {
X			   yyn = yypact[*yyps] + YYERRCODE;
X			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
X			      yystate = yyact[yyn];  /* simulate a shift of "error" */
X			      goto yystack;
X			      }
X			   yyn = yypact[*yyps];
X
X			   /* the current yyps has no shift onn "error", pop stack */
X
X#ifdef YYDEBUG
X			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
X#endif
X			   --yyps;
X			   --yypv;
X			   }
X
X			/* there is no state on the stack with an error shift ... abort */
X
X	yyabort:
X			return(1);
X
X
X		case 3:  /* no shift yet; clobber input char */
X
X#ifdef YYDEBUG
X			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
X#endif
X
X			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
X			yychar = -1;
X			goto yynewstate;   /* try again in the same state */
X
X			}
X
X		}
X
X	/* reduction by production yyn */
X
X#ifdef YYDEBUG
X		if( yydebug ) printf("reduce %d\n",yyn);
X#endif
X		yyps -= yyr2[yyn];
X		yypvt = yypv;
X		yypv -= yyr2[yyn];
X		yyval = yypv[1];
X		yym=yyn;
X			/* consult goto table to find next state */
X		yyn = yyr1[yyn];
X		yyj = yypgo[yyn] + *yyps + 1;
X		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
X		switch(yym){
X			
Xcase 1:
X# line 111 "dfcparse.y"
X{  
X			      return 0;
X 			   } break;
Xcase 2:
X# line 114 "dfcparse.y"
X{
X			      return 0;
X                           } break;
Xcase 3:
X# line 117 "dfcparse.y"
X{  
X                              return yyreverse(); 
X                           } break;
Xcase 4:
X# line 120 "dfcparse.y"
X{
X			      return yyreverse();
X                           } break;
Xcase 5:
X# line 123 "dfcparse.y"
X{  
X                              return -1;
X                           } break;
Xcase 6:
X# line 128 "dfcparse.y"
X{  
X                              newnode.type = const_node;
X                              newnode.content.value = yypvt[-0].value;
X
X                              yyval.nodeidx = addnode(&newnode); 
X                           } break;
Xcase 7:
X# line 134 "dfcparse.y"
X{
X			      sprintf(ermsgbuff, 
X				  "unknow token \"%s\"", yypvt[-0].name);
X			      exparserror = ermsgbuff;
X			      return -1;
X                           } break;
Xcase 8:
X# line 140 "dfcparse.y"
X{
X			      newnode.type = const_node;
X			      newnode.content.value = yypvt[-2].value;
X
X			      yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 9:
X# line 146 "dfcparse.y"
X{
X			      newnode.type = const_node;
X			      newnode.content.value = yypvt[-3].value;
X
X			      yyval.nodeidx = addnode(&newnode);
X			   } break;
Xcase 10:
X# line 152 "dfcparse.y"
X{
X                              newnode.type = arg_node;
X			      newnode.content.argidx = yypvt[-0].argidx;
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 11:
X# line 157 "dfcparse.y"
X{ 
X                              newnode.type = simplex_fnct_node;
X                              newnode.content.fnctptr = yypvt[-3].fnctptr;
X                              newnode.right = yypvt[-1].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 12:
X# line 164 "dfcparse.y"
X{
X                              newnode.type = duplex_fnct_node;
X                              newnode.content.fnctptr = yypvt[-5].fnctptr;
X                              newnode.left = yypvt[-3].nodeidx;
X                              newnode.right= yypvt[-1].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 13:
X# line 172 "dfcparse.y"
X{
X			      exparserror 
X				= "not support triplex function yet";
X		              return -1;	
X	                   } break;
Xcase 14:
X# line 177 "dfcparse.y"
X{
X                              newnode.type = binary_op_node;
X                              newnode.content.op = op_sum;
X                              newnode.left = yypvt[-2].nodeidx;
X                              newnode.right= yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 15:
X# line 185 "dfcparse.y"
X{
X                              newnode.type = binary_op_node;
X                              newnode.content.op = op_sub;
X                              newnode.left = yypvt[-2].nodeidx;
X                              newnode.right= yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 16:
X# line 193 "dfcparse.y"
X{
X                              newnode.type = binary_op_node;
X                              newnode.content.op = op_mul;
X                              newnode.left = yypvt[-2].nodeidx;
X                              newnode.right= yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 17:
X# line 201 "dfcparse.y"
X{
X                              newnode.type = binary_op_node;
X                              newnode.content.op = op_div;
X                              newnode.left =yypvt[-2].nodeidx;
X                              newnode.right=yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode); 
X                           } break;
Xcase 18:
X# line 209 "dfcparse.y"
X{
X                              newnode.type = unary_op_node; 
X			      newnode.content.op = op_neg;
X                              newnode.right = yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 19:
X# line 216 "dfcparse.y"
X{ 
X                              yyval.nodeidx = yypvt[-0].nodeidx;
X                           } break;
Xcase 20:
X# line 219 "dfcparse.y"
X{
X                              newnode.type = duplex_fnct_node;
X                              newnode.content.fnctptr = pow;
X                              newnode.left = yypvt[-2].nodeidx;
X                              newnode.right= yypvt[-0].nodeidx;
X
X                              yyval.nodeidx = addnode(&newnode);
X                           } break;
Xcase 21:
X# line 227 "dfcparse.y"
X{ 
X                              yyval.nodeidx = yypvt[-1].nodeidx; 
X                           } break;
X		}
X		goto yystack;  /* stack new state and value */
X
X	}
END_OF_FILE
  if test 14183 -ne `wc -c <'y.tab.c'`; then
    echo shar: \"'y.tab.c'\" unpacked with wrong size!
  fi
  # end of 'y.tab.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
