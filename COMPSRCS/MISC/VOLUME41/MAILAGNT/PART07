Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v41i007:  mailagent - Flexible mail filtering and processing package, v3.0, Part07/26
Message-ID: <1993Dec2.133715.18266@sparky.sterling.com>
X-Md4-Signature: 778dd4e20ef5807b0bb8d0c7c8c15a03
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 2 Dec 1993 13:37:15 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 41, Issue 7
Archive-name: mailagent/part07
Environment: UNIX, Perl
Supersedes: mailagent: Volume 33, Issue 93-109

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Configure.02 agent/pl/add_log.pl
# Wrapped by ram@soft208 on Mon Nov 29 16:49:55 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 26)."'
if test -f 'Configure.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure.02'\"
else
  echo shar: Extracting \"'Configure.02'\" \(46962 characters\)
  sed "s/^X//" >'Configure.02' <<'END_OF_FILE'
X	'')
X		$hostcat >hosts
X		dflt=.`$awk "/[0-9].*$myhostname/ {for(i=2; i<=NF;i++) print \\\$i}" \
X			hosts | $sort | $uniq | \
X			$sed -n -e "s/$myhostname\.\([a-zA-Z_.]\)/\1/p"`
X		case "$dflt" in
X		.) echo "(You do not have fully-qualified names in /etc/hosts)"
X			dflt='.uucp';;
X		esac
X		$rm -f hosts
X		;;
X	*) dflt="$mydomain";;
X	esac;;
Xesac
Xecho " "
Xrp="What is your domain name?"
X. ./myread
Xtans="$ans"
Xcase "$ans" in
X'') ;;
X.*) ;;
X*) tans=".$tans";;
Xesac
Xmydomain="$tans"
X
X: a little sanity check here
Xcase "$phostname" in
X'') ;;
X*)
X	case `$phostname` in
X	$myhostname$mydomain|$myhostname) ;;
X	*)
X		case "$phostname" in
X		sed*)
X			echo "(That doesn't agree with your whoami.h file, by the way.)"
X			;;
X		*)
X			echo "(That doesn't agree with your $phostname command, by the way.)"
X			;;
X		esac
X	;;
X	esac
X	;;
Xesac
X
X: see how we will look up host name
Xecho " "
Xif false; then
X	: dummy stub to allow use of elif
Xelif set gethostname val -f d_gethname; eval $csym; $val; then
X	echo 'gethostname() found.' >&4
X	d_gethname="$define"
X	call=gethostname
Xelif set uname val -f d_uname; eval $csym; $val; then
X	if xenix; then
X		$cat <<'EOM'
Xuname() was found, but you're running xenix, and older versions of xenix
Xhave a broken uname(). If you don't really know whether your xenix is old
Xenough to have a broken system call, use the default answer.
X
XEOM
X		dflt=y
X		case "$d_uname" in
X		"$define") dflt=n;;
X		esac
X		rp='Is your uname() broken?'
X		. ./myread
X		case "$ans" in
X		n*) d_uname="$define"; call=uname;;
X		esac
X	else
X		echo 'uname() found.' >&4
X		d_uname="$define"
X		call=uname
X	fi
Xfi
Xcase "$d_gethname" in
X'') d_gethname="$undef";;
Xesac
Xcase "$d_uname" in
X'') d_uname="$undef";;
Xesac
Xcase "$d_uname$d_gethname" in
X*define*)
X	dflt=n
X	cat <<EOM
X 
XEvery now and then someone has a $call() that lies about the hostname
Xbut can't be fixed for political or economic reasons.  If you wish, I can
Xpretend $call() isn't there and maybe compile in the hostname or
Xcompute it from the '$phostname' command at run-time.
X
XEOM
X	rp="Shall I ignore $call() from now on?"
X	. ./myread
X	case "$ans" in
X	y*) d_uname="$undef" d_gethname="$undef"; $echo $n "Okay...$c";;
X	esac;;
Xesac
Xcase "$phostname" in
X'') aphostname='';;
X*) case "$aphostname" in
X	/*) ;;
X	*) set X $phostname
X		shift
X		file=$1
X		shift
X		file=`./loc $file $file $pth`
X		aphostname=`echo $file $*`
X		;;
X	esac
X	;;
Xesac
Xcase "$d_uname$d_gethname" in
X*define*) ;;
X*)
X	case "$phostname" in
X	'') ;;
X	*)
X		$cat <<EOT
X
XThere is no gethostname() or uname() on this system.  You have two
Xpossibilities at this point:
X
X1)  You can have your host name ($myhostname) compiled into $package, which
X    lets $package start up faster, but makes your binaries non-portable, or
X2)  you can have $package use a
X	
X	popen("$aphostname","r")
X
X    which will start slower but be more portable.
X
XIf you want option 2 but with a different command, you can edit config.sh at
Xthe end of this shell script.
X
XEOT
X		case "$d_phostname" in
X		"$define") dflt=n;;
X		"$undef")  dflt=y;;
X		'')
X			case "$d_portable" in
X			"$define") dflt=n ;;
X			*) dflt=y ;;
X			esac;;
X		esac
X		rp="Do you want your host name compiled in?"
X		. ./myread
X		case "$ans" in
X		n*) d_phostname="$define" ;;
X		*) aphostname=''; d_phostname="$undef";;
X		esac;;
X	esac
X	case "$aphostname" in
X	'')
X		echo 'No hostname function -- hardwiring "'$myhostname'".' >&4;;
X	esac;;
Xesac
Xcase "$d_phostname" in
X'') d_phostname="$undef";;
Xesac
X
X: function used to set $1 to $val
Xsetvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
Xcase "$val$was" in
X$define$undef) . whoa; eval "$var=\$td";;
X$undef$define) . whoa; eval "$var=\$tu";;
X*) eval "$var=$val";;
Xesac'
X
X: see how we invoke the C preprocessor
Xecho " "
Xecho "Now, how can we feed standard input to your C preprocessor..." >&4
Xcat <<'EOT' >testcpp.c
X#define ABC abc
X#define XYZ xyz
XABC.XYZ
XEOT
Xcd ..
Xecho 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
Xchmod 755 cppstdin
Xwrapper=`pwd`/cppstdin
Xcd UU
Xif $test "X$cppstdin" != "X" && \
X	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "You used to use $cppstdin $cppminus so we'll use that again."
Xelif $test "$cc" = gcc && \
X	(echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
X	$wrapper <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
X	echo "Yup, we can."
X	cppstdin="$wrapper"
X	cppminus='';
Xelif echo 'Maybe "'"$cc"' -E" will work...'; \
X	$cc -E <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yup, it does."
X	cppstdin="$cc -E"
X	cppminus='';
Xelif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
X	$cc -E - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yup, it does."
X	cppstdin="$cc -E"
X	cppminus='-';
Xelif echo 'No such luck, maybe "'$cpp'" will work...'; \
X	$cpp <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "It works!"
X	cppstdin="$cpp"
X	cppminus='';
Xelif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
X	$cpp - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Hooray, it works!  I was beginning to wonder."
X	cppstdin="$cpp"
X	cppminus='-';
Xelif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
X	$cc -P <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yipee, that works!"
X	cppstdin="$cc -P"
X	cppminus='';
Xelif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
X	$cc -P - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "At long last!"
X	cppstdin="$cc -P"
X	cppminus='-';
Xelif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
X	$wrapper <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	cppstdin="$wrapper"
X	cppminus=''
X	echo "Eureka!"
Xelse
X	dflt=''
X	rp="No dice.  I can't find a C preprocessor.  Name one:"
X	. ./myread
X	cppstdin="$ans"
X	$cppstdin <testcpp.c >testcpp.out 2>&1
X	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X		echo "OK, that will do." >&4
X	else
Xecho "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
X		exit 1
X	fi
Xfi
Xcase "$cppstdin" in
X"$wrapper") ;;
X*) $rm -f $wrapper;;
Xesac
X$rm -f testcpp.c testcpp.out
X
X: determine filename position in cpp output
Xecho " "
Xecho "Computing filename position in cpp output for #include directives..." >&4
Xecho '#include <stdio.h>' > foo.c
X$cat >fieldn <<EOF
X$startsh
X$cppstdin $cppminus $cppflags <foo.c 2>/dev/null | \
X$grep '^[ 	]*#.*stdio\.h' | \
Xwhile read cline; do
X	pos=1
X	set \$cline
X	while $test \$# -gt 0; do
X		if $test -r \`echo \$1 | $tr -d '"'\`; then
X			echo "\$pos"
X			exit 0
X		fi
X		shift
X		pos=\`expr \$pos + 1\`
X	done
Xdone
XEOF
Xchmod +x fieldn
Xfieldn=`./fieldn`
X$rm -f foo.c fieldn
Xcase $fieldn in
X'') pos='???';;
X1) pos=first;;
X2) pos=second;;
X3) pos=third;;
X*) pos="${fieldn}th";;
Xesac
Xecho "Your cpp writes the filename in the $pos field of the line."
X
X: locate header file
X$cat >findhdr <<EOF
X$startsh
Xwanted=\$1
Xname=''
Xif test -f $usrinc/\$wanted; then
X	echo "$usrinc/\$wanted"
X	exit 0
Xfi
Xawkprg='{ print \$$fieldn }'
Xecho "#include <\$wanted>" > foo\$\$.c
X$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
X$grep "^[ 	]*#.*\$wanted" | \
Xwhile read cline; do
X	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
X	case "\$name" in
X	*/\$wanted) echo "\$name"; exit 0;;
X	*) name='';;
X	esac;
Xdone;
X$rm -f foo\$\$.c;
Xcase "\$name" in
X'') exit 1;;
Xesac
XEOF
Xchmod +x findhdr
X
X: see which of string.h or strings.h is needed
Xecho " "
Xstrings=`./findhdr string.h`
Xif $test "$strings" && $test -r "$strings"; then
X	echo "Using <string.h> instead of <strings.h>." >&4
X	val="$define"
Xelse
X	val="$undef"
X	strings=`./findhdr strings.h`
X	if $test "$strings" && $test -r "$strings"; then
X		echo "Using <strings.h> instead of <string.h>." >&4
X	else
X		echo "No string header found -- You'll surely have problems." >&4
X	fi
Xfi
Xset i_string
Xeval $setvar
Xcase "$i_string" in
X"$undef") strings=`./findhdr strings.h`;;
X*)	  strings=`./findhdr string.h`;;
Xesac
X
X: index or strchr
Xecho " "
Xif set index val -f; eval $csym; $val; then
X	if set strchr val -f d_strchr; eval $csym; $val; then
X		if $contains strchr "$strings" >/dev/null 2>&1 ; then
X			val="$define"
X			vali="$undef"
X			echo "strchr() found." >&4
X		else
X			val="$undef"
X			vali="$define"
X			echo "index() found." >&4
X		fi
X	else
X		val="$undef"
X		vali="$define"
X		echo "index() found." >&4
X	fi
Xelse
X	if set strchr val -f d_strchr; eval $csym; $val; then
X		val="$define"
X		vali="$undef"
X		echo "strchr() found." >&4
X	else
X		echo "No index() or strchr() found!" >&4
X		val="$undef"
X		vali="$undef"
X	fi
Xfi
Xset d_strchr; eval $setvar
Xval="$vali"
Xset d_index; eval $setvar
X
X: Initialize h_fcntl
Xh_fcntl=false
X
X: Initialize h_sysfile
Xh_sysfile=false
X
X: Locate the flags for 'open()'
Xecho " "
X$cat >open3.c <<'EOCP'
X#include <sys/types.h>
X#ifdef I_FCNTL
X#include <fcntl.h>
X#endif
X#ifdef I_SYS_FILE
X#include <sys/file.h>
X#endif
Xmain() {
X	if(O_RDONLY);
X#ifdef O_TRUNC
X	exit(0);
X#else
X	exit(1);
X#endif
X}
XEOCP
X: check sys/file.h first to get FREAD on Sun
Xif $test `./findhdr sys/file.h` && \
X		$cc $cppflags "-DI_SYS_FILE" open3.c -o open3 >/dev/null 2>&1 ; then
X	h_sysfile=true;
X	echo "<sys/file.h> defines the O_* constants..." >&4
X	if ./open3; then
X		echo "and you have the 3 argument form of open()." >&4
X		val="$define"
X	else
X		echo "but not the 3 argument form of open().  Oh, well." >&4
X		val="$undef"
X	fi
Xelif $test `./findhdr fcntl.h` && \
X		$cc "-DI_FCNTL" open3.c -o open3 >/dev/null 2>&1 ; then
X	h_fcntl=true;
X	echo "<fcntl.h> defines the O_* constants..." >&4
X	if ./open3; then
X		echo "and you have the 3 argument form of open()." >&4
X		val="$define"
X	else
X		echo "but not the 3 argument form of open().  Oh, well." >&4
X		val="$undef"
X	fi
Xelse
X	val="$undef"
X	echo "I can't find the O_* constant definitions!  You got problems." >&4
Xfi
Xset d_open3
Xeval $setvar
X$rm -f open3*
X
X: see if rename exists
Xset rename d_rename
Xeval $inlibc
X
X: see if strerror and/or sys_errlist[] exist
Xecho " "
Xif set strerror val -f d_strerror; eval $csym; $val; then
X	echo 'strerror() found.' >&4
X	d_strerror="$define"
X	d_strerrm="$undef"
X	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
X		echo "(You also have sys_errlist[], so we could roll our own strerror.)" 
X		d_syserrlst="$define"
X	else
X	echo "(Since you don't have sys_errlist[], sterror() is welcome.)"
X		d_syserrlst="$undef"
X	fi
Xelif xxx=`./findhdr string.h`; test "$xxx" || xxx=`./findhdr strings.h`; \
X	$contains '#[ 	]*define.*strerror' "$xxx" >/dev/null 2>&1; then
X	echo 'strerror() found in string header.' >&4
X	d_strerror="$define"
X	d_strerrm="$undef"
X	if set sys_errlist val -a d_syserrlst; eval $csym; $val; then	
X		echo "(Most probably, strerror() uses sys_errlist[] for descriptions.)"
X		d_syserrlst="$define"
X	else
X		echo "(You don't appear to have any sys_errlist[], how can this be?)"
X		d_syserrlst="$undef"
X	fi
Xelif set sys_errlist val -a d_syserrlst; eval $csym; $val; then
Xecho "strerror() not found, but you have sys_errlist[] so we'll use that." >&4
X	d_strerror="$undef"
X	d_syserrlst="$define"
X	d_strerrm="$define"
Xelse
X	echo 'strerror() and sys_errlist[] NOT found.' >&4
X	d_strerror="$undef"
X	d_syserrlst="$undef"
X	d_strerrm="$undef"
Xfi
Xif set sys_errnolist val -a d_sysernlst; eval $csym; $val; then
X	echo "(Symbolic error codes can be fetched via the sys_errnolist[] array.)"
X	d_sysernlst="$define"
Xelse
X	echo "(However, I can't extract the symbolic error code out of errno.)"
X	d_sysernlst="$undef"
Xfi
X
X: see if union wait is available
Xecho " "
Xif $contains 'union.*wait.*{' `./findhdr sys/wait.h` >/dev/null 2>&1 ; then
X	echo "Looks like we have to use 'union wait' pointer for wait()." >&4
X	val="$define"
Xelse
X	echo "Your wait() should be happy with a plain 'int' pointer." >&4
X	val="$undef"
Xfi
Xset d_uwait
Xeval $setvar
X
X: backward compatibility for d_hvfork
Xif test X$d_hvfork != X; then
X	d_vfork="$d_hvfork"
X	d_hvfork=''
Xfi
X: see if there is a vfork
Xset vfork d_vfork
Xeval $inlibc
X
X: preserve RCS keywords in files with variable substitution, grrr
XHeader='$Header'
XId='$Id'
XLog='$Log'
X
X: see if flock exists
Xset flock d_flock
Xeval $inlibc
X
X: see which mailbox locking should be used
Xecho " "
Xlock_by_flock=''
Xflock_only=''
Xcase "$d_flock" in
X"$define")
X	if $contains EWOULDBLOCK $usrinc/errno.h > /dev/null 2>&1; then
X		echo 'EWOULDBLOCK found, will use flock type mailbox locking.'
X		val="$define"
X	elif $contains EWOULDBLOCK $usrinc/sys/errno.h > /dev/null 2>&1; then
X		echo 'EWOULDBLOCK found, will use flock type mailbox locking.'
X		val="$define"
X	else
X		echo 'Will use .lock type mailbox locking.'
X		val="$undef"
X	fi
X	;;
X*)
X	echo 'Will use .lock type mailbox locking.'
X	val="$undef"
X	;;
Xesac
Xset d_lockflock; eval $setvar
X
Xcase "$d_lockflock" in
X"$define")
X	lock_by_flock='true'
X	case "$d_flockonly" in
X	"$define") dflt=y;;
X	*) dflt=n;;
X	esac
X	$cat <<EOM
X 
XSome sites wish to use flock style locking only. This allows $package to be
Xinstalled without the setgid bit being set on some systems that would otherwise
Xrequire it.
X
XNote: Be sure no other mail utility that needs to lock the mail spool file
Xuses .lock type locking before using only flock style locking.
X
XEOM
X	rp="Would you like to use flock style mail spool locking only?"
X	. myread
X	case "$ans" in
X	y*|Y*) val="$define";;
X	*) val="$undef";;
X	esac
X	;;
X*) val="$undef";;
Xesac
Xset d_flockonly; eval $setvar
X
Xcase "$d_flockonly" in
X"$define") flock_only='true';;
Xesac
X
X: now get the host name to advertise as our mailing address
Xcase "$hiddennet" in
X'') dflt=n;;
X*) dflt=y;;
Xesac
X$cat <<EOM
X 
XSome sites are on "hidden" networks, in the sense that the network appears
Xto the outside world as a single machine.  The advertised name of any host
Xon this hidden network is the name of one machine on the local network which
Xknows how to forward mail to any other host on the hidden network.
X
XDo you wish to advertise a different hostname to the world than the one your
Xown host ($myhostname$mydomain) has?
X
XEOM
Xrp='Use "hidden" network?'
X. ./myread
Xcase "$ans" in
Xn*) d_hidnet="$undef" hiddennet='';;
X*)
X	d_hidnet="$define"
X	echo " "
X	case "$hiddennet" in
X	'') dflt=`echo $mydomain | $sed -e 's/^\.//'`;;
X	*) dflt="$hiddennet";;
X	esac
X	rp='What hostname do you wish to advertise?'
X	. ./myread
X	hiddennet="$ans"
X	;;
Xesac
X
X: is AFS running?
Xecho " "
Xif test -d /afs; then
X	echo "AFS may be running... I'll be extra cautious then..." >&4
X	afs=true
Xelse
X	echo "AFS does not seem to be running..." >&4
X	afs=false
Xfi
X
X: determine where public executables go
Xecho " "
Xcase "$bin" in
X'')
X	dflt=`./loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
X	;;
X*)
X	dflt="$bin"
X	;;
Xesac
Xfn=d~
Xrp='Pathname where the public executables will reside?'
X. ./getfile
Xbin="$ans"
Xbinexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xexecutables reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installbin" in
X	'') dflt=`echo $binexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installbin";;
X	esac
X	fn=de~
X	rp='Where will public executables be installed?'
X	. ./getfile
X	installbin="$ans"
Xelse
X	installbin="$binexp"
Xfi
X
X: determine where manual pages go
X$cat <<EOM
X
X$package has manual pages available in source form.
XEOM
Xcase "$nroff" in
Xnroff)
X	echo "However, you don't have nroff, so they're probably useless to you."
X	case "$mansrc" in
X	'') mansrc="none";;
X	esac;;
Xesac
Xecho "If you don't want the manual sources installed, answer 'none'."
Xcase "$mansrc" in
X'')
X	lookpath='/usr/local/man/man1 /usr/local/man/man1 /usr/man/manl'
X	lookpath="$lookpath /usr/man/local/man1 /usr/man/l_man/man1"
X	lookpath="$lookpath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
X	lookpath="$lookpath /usr/man/man.L"
X	mansrc=`./loc . $lookpath`
X	if $test -d "$mansrc"; then
X		dflt="$mansrc"
X	else
X		dflt="$sysman"
X	fi
X	;;
X*)  dflt="$mansrc"
X	;;
Xesac
Xecho " "
Xfn=dn~
Xrp='Where do the manual pages (source) go?'
X. ./getfile
Xmansrc="$ans"
Xmansrcexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xmanual pages reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installmansrc" in
X	'') dflt=`echo $mansrcexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installmansrc";;
X	esac
X	fn=de~
X	rp='Where will man pages be installed?'
X	. ./getfile
X	installmansrc="$ans"
Xelse
X	installmansrc="$mansrcexp"
Xfi
X
X
Xcase "$mansrc" in
X'') manext='0';;
X*l) manext=l;;
X*n) manext=n;;
X*o) manext=l;;
X*p) manext=n;;
X*C) manext=C;;
X*L) manext=L;;
X*L1) manext=L1;;
X*) manext=1;;
Xesac
X
X: determine where private executables go
Xcase "$privlib" in
X'')
X	dflt=/usr/lib/$package
X	$test -d /usr/local/lib && dflt=/usr/local/lib/$package
X	$test -d /local/lib && dflt=/local/lib/$package
X	;;
X*)  dflt="$privlib"
X	;;
Xesac
X$cat <<EOM
X
XThere are some auxiliary files for $package that need to be put into a
Xprivate library directory that is accessible by everyone.
X
XEOM
Xfn=d~+
Xrp='Pathname where private library files will reside?'
X. ./getfile
Xprivlib="$ans"
Xprivlibexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xprivate files reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installprivlib" in
X	'') dflt=`echo $privlibexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installprivlib";;
X	esac
X	fn=de~
X	rp='Where will private files be installed?'
X	. ./getfile
X	installprivlib="$ans"
Xelse
X	installprivlib="$privlibexp"
Xfi
X
X: determine where public executables go
Xcase "$scriptdir" in
X'')
X	dflt="$bin"
X	: guess some guesses
X	$test -d /usr/share/scripts && dflt=/usr/share/scripts
X	$test -d /usr/share/bin && dflt=/usr/share/bin
X	$test -d /usr/local/script && dflt=/usr/local/script
X	;;
X*)  dflt="$scriptdir"
X	;;
Xesac
X$cat <<EOM
X 
XSome installations have a separate directory just for executable scripts so
Xthat they can mount it across multiple architectures but keep the scripts in
Xone spot.  You might, for example, have a subdirectory of /usr/share for this.
XOr you might just lump your scripts in with all your other executables.
X 
XEOM
Xfn=d~
Xrp='Where do you keep publicly executable scripts?'
X. ./getfile
Xscriptdir="$ans"
Xscriptdirexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xscripts reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installscript" in
X	'') dflt=`echo $scriptdirexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installscript";;
X	esac
X	fn=de~
X	rp='Where will public scripts be installed?'
X	. ./getfile
X	installscript="$ans"
Xelse
X	installscript="$scriptdirexp"
Xfi
X
X: check for length of integer
Xecho " "
Xcase "$intsize" in
X'')
X	echo "Checking to see how big your integers are..." >&4
X	$cat >try.c <<'EOCP'
X#include <stdio.h>
Xmain()
X{
X	printf("%d\n", sizeof(int));
X}
XEOCP
X	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
X		dflt=`./try`
X	else
X		dflt='4'
X		echo "(I can't seem to compile the test program.  Guessing...)"
X	fi
X	;;
X*)
X	dflt="$intsize"
X	;;
Xesac
Xrp="What is the size of an integer (in bytes)?"
X. ./myread
Xintsize="$ans"
X$rm -f try.c try
X
X: determine where mail is spooled
Xcase "$maildir" in
X'') dflt=`./loc . /usr/spool/mail /usr/spool/mail /usr/mail`;;
X*) dflt="$maildir";;
Xesac
Xecho " "
Xfn=d~
Xrp='Where is yet-to-be-read mail spooled?'
X. ./getfile
Xmaildir="$ans"
Xmaildirexp="$ansexp"
X
X: determine the name of a reasonable mailer
Xcase "$mailer" in
X'')
X	if $test -f "$sendmail"; then
X		dflt="$sendmail"
X	elif $test -f "$smail"; then
X		dflt="$smail"
X	elif $test -f "$rmail"; then
X		dflt="$rmail"
X	elif $test -f /bin/mail; then
X		dflt=/bin/mail
X	else
X		dflt=$mail
X	fi
X	;;
X*)  dflt="$mailer";;
Xesac
X$cat <<EOM
X
XI need the full pathname of the program used to deliver mail on your system.
XA typical answer would be /usr/lib/sendmail or /bin/rmail, but you may choose
Xany other program, as long as it can be fed from standard input and will
Xhonour any user-supplied headers.
X
XEOM
Xfn=f
Xrp='Mail transport agent to be used?'
X. ./getfile
Xmailer="$ans"
X
X: determine where mail is spooled
Xcase "$mailfile" in
X'')
X	dflt=`./loc . XXX /usr/spool/mail /usr/mail`
X	case "$dflt" in
X	XXX) dflt='%~/mailbox';;
X	*) dflt="$dflt/%L";;
X	esac
X	;;
X*)  dflt="$mailfile"
X	;;
Xesac
Xcat <<'EOM'
X
XIn the following question, you may use %~ to represent the user's home
Xdirectory, and %L to represent a users name.
X
XEOM
Xrp='In which file is yet-to-be-read mail spooled? (~name ok)'
X. ./myread
Xmailfile=`./filexp "$ans"`
X
X: find out how to generate dependencies
Xecho " "
Xecho "Checking how to generate makefile dependencies on your machine..." >&4
Xtoplev=`cd ..;pwd`
X$cat >dep.c <<'EOCP'
X#include "dep.h"
XEOCP
X$cat >dep.h <<'EOCP'
X
XEOCP
Xtakeflags='flags=""
Xcase "$@" in
X*--*)
X	for arg
X	do
X		shift
X		case "$arg" in
X		--) break;;
X		*) flags="$flags $arg";;
X		esac
X	done;;
Xesac'
Xcase "$mkdep" in
X'')
X	;;
X*)
X	if test -x "$mkdep" &&
X		$mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "$mkdep works."
X	else
X		mkdep=
X	fi
Xesac
X
Xcase "$mkdep" in
X'')
X	$spitshell > ../mkdep <<EOM
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	$cpp -M -I. $cppflags \$flags \$srcfile 2>/dev/null
Xdone
XEOM
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "Looks like we can use $cpp -M."
X	else
X		mkdep=
X	fi
X	;;
Xesac
X
Xcase "$mkdep" in
X'')
X	$spitshell > ../mkdep <<EOM
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	$cc -MM -I. $cppflags \$flags \$srcfile 2>/dev/null
Xdone
XEOM
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep.o: dep.h' dep.out >/dev/null 2>&1
X	then
X		echo "Looks like we can use $cc -MM."
X	else
X		mkdep=
X	fi
X	;;
Xesac
X
Xcase "$mkdep" in
X'')
X	$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	<\$srcfile $cpp $cppminus $cppflags -I. \$flags 2>/dev/null | \\
X	$sed -e '/^# *[0-9]/!d' \\
X		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X		-e 's|: \./|: |' \\
X		-e 's|: *$|: '\$srcfile'|' | \\
X	$grep -v '^#' | $sort | $uniq
Xdone
XEOS
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "A shell script using $cpp does the trick."
X	else
X		echo "$cpp doesn't seem to be any use at all."
X		$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfiles="\$@"
Xset X \$flags
Xshift
Xinc='.'
Xwhile test \$# -gt 0
Xdo
X	case "\$1" in
X	-I) 
X		shift
X		inc="\$inc:\$1"
X		;;
X	-I*)
X		dir=\`echo \$1 | sed -e 's/^-I//'\`
X		inc="\$inc:\$dir"
X		;;
X	esac
X	shift
Xdone
Xset X \$files
Xshift
Xtrap "$rm -f /tmp/mkdep\$\$; exit 1" 1 2 3 15
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	echo \$filebase.o: \$srcfile
X	$grep '^#[  ]*include' \$srcfile /dev/null | \
X	$sed -n -e 's/#[   ]*include[  ]*//' \\
X		-e '/<\(.*\)>/ d' \\
X		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
X		-e 's/\.c:/\.o:/p' > /tmp/mkdep\$\$
X	IFS=': '
X	while read file dep; do
X		for dir in \$inc; do
X			if $test -f "\$dir/\$dep"; then
X				dep="\$dir/\$dep"
X				break
X			fi
X		done
X		echo "\$file: \$dep" | $sed -e 's,: \./,: ,'
X	done </tmp/mkdep\$\$
X	IFS=' '
X	$rm -f /tmp/mkdep\$\$
Xdone
XEOS
X		mkdep=$toplev/mkdep
X		chmod +x $mkdep
X		$eunicefix $mkdep
X		if $mkdep dep.c >dep.out 2>/dev/null &&
X			$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X		then
X			cat << EOM
X
XI can use a script with grep instead, but it will make some incorrect
Xdependencies, since it doesn't understand about conditional compilation.
XMoreover, some dependencies may be missing, because scanning won't be
Xa recursive process.
XIf you have a program which generates makefile dependencies, you may want
Xto use it.  If not, you can use the script and edit the Makefile by hand
Xif you need to.
XEOM
X		else
X			mkdep=
X			cat << EOM
X
XI can't seem to generate makefile dependencies at all!  Perhaps you have a
Xprogram that does?  If you don't, you might look at the mkdep script to
Xsee if you can create one which works.
XEOM
X		fi
X	fi
Xesac
Xdflt="$mkdep"
Xfn=f~/
Xrp="Name of program to make makefile dependencies?"
X. ./getfile
Xmkdep="$ans"
X$rm -f dep.c dep.h dep.o dep.out
X
X: get organization name
Xlongshots='/local/src /usr/src/new /usr/src/local /usr/local/src'
Xcase "$orgname" in
X'') if xxx=`./loc news/src/defs.h x $longshots`; then
X		dflt=`$sed -n 's/^.*MYORG[ 	]*"\(.*\)".*$/\1/p' $xxx`
X	else
X		dflt=''
X	fi
X	;;
X*)  dflt="$orgname";;
Xesac
X$cat << 'EOH'
X 
XPlease type the name of your organization as you want it to appear on the
XOrganization line of outgoing articles.  (It's nice if this also specifies
Xyour location.  Your city name is probably sufficient if well known.)
XFor example:
X
X    University of Southern North Dakota, Hoople
X
XYou may also put the name of a file, as long as it begins with a slash.
XFor example:
X
X    /etc/organization
X
XEOH
Xorgname=""
Xwhile test "X$orgname" = "X"; do
X	rp='Organization:'
X	. ./myread
X	orgname="$ans"
Xdone
X
X: set the base revision
Xbaserev=3.0
X
X: get the patchlevel
Xecho " "
Xecho "Getting the current patchlevel..." >&4
Xif $test -r ../patchlevel.h;then
X	patchlevel=`awk '/PATCHLEVEL/ {print $3}' < ../patchlevel.h`
Xelse
X	patchlevel=0
Xfi
Xecho "(You have $package $baserev PL$patchlevel.)"
X
X: determine perl absolute location
Xcase "$perlpath" in
X'')
X	if test -f /usr/bin/perl; then
X		dflt=/usr/bin/perl
X	else
X		case "$_perl" in
X		*/*) dflt="$_perl";;
X		*) dflt=/usr/bin/perl;;
X		esac
X	fi
X	;;
X*)  dflt="$perlpath"
X	;;
Xesac
Xecho " "
Xfn=f~/
Xrp="Where is perl located on your system?"
X. ./getfile
Xperlpath="$ans"
X
X: see what type pids are declared as in the kernel
Xcase "$pidtype" in
X'')
X	if $contains 'pid_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
X		dflt='pid_t';
X	else
X		dflt="int"
X	fi
X	;;
X*)  dflt="$pidtype";;
Xesac
Xecho " "
Xrp="What type are process ids on this system declared as?"
X. ./myread
Xpidtype="$ans"
X
X: Cruising for prototypes
Xecho " "
Xecho "Checking out function prototypes..." >&4
X$cat >prototype.c <<'EOCP'
Xmain(int argc, char *argv[]) {
X	exit(0);}
XEOCP
Xif $cc -c prototype.c >prototype.out 2>&1 ; then
X	echo "Your C compiler appears to support function prototypes."
X	val="$define"
Xelse
X	echo "Your C compiler doesn't seem to understand function prototypes."
X	val="$undef"
Xfi
Xset prototype
Xeval $setvar
X$rm -f prototype*
X
X: get C preprocessor symbols handy
Xecho " "
Xecho $attrlist | $tr ' ' '\012' >Cppsym.know
X$cat <<EOSS >Cppsym
X$startsh
Xcase "\$1" in
X-l) list=true
X	shift
X	;;
Xesac
Xunknown=''
Xcase "\$list\$#" in
X1|2)
X	for sym do
X		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
X			exit 0
X		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
X			:
X		else
X			unknown="\$unknown \$sym"
X		fi
X	done
X	set X \$unknown
X	shift
X	;;
Xesac
Xcase \$# in
X0) exit 1;;
Xesac
Xecho \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
X#ifdef \1\\
Xexit 0; _ _ _ _\1\\	 \1\\
X#endif\\
X/' >Cppsym\$\$
Xecho "exit 1; _ _ _" >>Cppsym\$\$
X$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
Xcase "\$list" in
Xtrue) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
X*)
X	sh Cppsym2\$\$
X	status=\$?
X	;;
Xesac
X$rm -f Cppsym\$\$ Cppsym2\$\$
Xexit \$status
XEOSS
Xchmod +x Cppsym
X$eunicefix Cppsym
Xecho "Your C preprocessor defines the following symbols:"
XCppsym -l $attrlist >Cppsym.true
X$cat Cppsym.true
X
X: see how many register declarations we want to use
Xcase "$registers" in
X'')
X	if Cppsym vax; then
X		dflt=6
X	elif Cppsym sun mc68000 mips; then
X		dflt=10
X	elif Cppsym pyr; then
X		dflt=14
X	elif Cppsym ns32000 ns16000; then
X		dflt=5
X	elif Cppsym $smallmach; then
X		dflt=3
X	else
X		: if you have any other numbers for me, please send them in
X		dflt=6
X	fi;;
X*) dflt=$registers ;;
Xesac
Xcat <<EOM
X 
XDifferent C compilers on different machines pay attention to different numbers
Xof register declarations.  About how many register declarations in each routine
Xdoes your C compiler pay attention to?  (OK to guess)
X
XEOM
Xrp="Maximum register declarations?"
X. ./myread
Xregisters=$ans
Xreg1=''
X$awk "BEGIN { for (i=1; i<=16; i++) printf \"reg%d=''\n\", i}" \
X	</dev/null >.foo
X. ./.foo
X$awk "BEGIN { for (i=1; i<=$registers; i++) printf \"reg%d=register\n\", i}" \
X	</dev/null >.foo
X. ./.foo
X$rm -f .foo
X
X: see if signal is declared as pointer to function returning int or void
Xecho " "
Xxxx=`./findhdr signal.h`
X$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
Xif $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have int (*signal())() instead of void." >&4
X	val="$undef"
X	signal_t="int"
Xelif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have void (*signal())() instead of int." >&4
X	val="$define"
X	signal_t="void"
Xelif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have int (*signal())() instead of void." >&4
X	val="$undef"
X	signal_t="int"
Xelse
X	case "$d_voidsig" in
X	'')
X	echo "I can't determine whether signal handler returns void or int..." >&4
X		dflt=void
X		rp="What type does your signal handler returns?"
X		. ./myread
X		case "$ans" in
X		void) val="$define"; signal_t="void";;
X		*) val="$undef"; signal_t="int";;
X		esac;;
X	*) echo "As you already told me, signal handler returns $signal_t." >&4;;
X	esac
Xfi
Xset d_voidsig
Xeval $setvar
X$rm -f $$.tmp
X
X: figure out how to guarantee perl startup
Xcase "$sharpbang" in
X*!)
X	$cat <<EOH
X
XI can use the #! construct to start perl on your system. This will make
Xstartup of perl scripts faster, but may cause problems if you want to share
Xthose scripts and perl is not in a standard place (/usr/bin/perl) on all your
Xplatforms. The alternative is to force a shell by starting the script with a
Xsingle ':' character.
X
XEOH
X	dflt=n
X	case "$startperl" in
X	*!*) dflt=y;;
X	'') case "$d_portable" in
X		"$define") ;;
X		*) dflt=y;;
X		esac;;
X	esac
X	rp='Shall I use #! to start up perl?'
X	. ./myread
X	case "$ans" in
X	y*|Y*) startperl="#!$perlpath";;
X	*) startperl=": # use perl";;
X	esac;;
X*) startperl=": # use perl";;
Xesac
X
X: see if time exists
Xecho " "
Xif set time val -f d_time; eval $csym; $val; then
X	echo 'time() found.' >&4
X	val="$define"
X	case "$timetype" in
X	'')
X		if $contains 'time_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
X			dflt='time_t';
X		else
X			dflt='long';
X		fi
X		;;
X	*)  dflt="$timetype"
X		;;
X	esac
X	echo " "
X	rp="What type is returned by time() on this sytem?"
X	. ./myread
X	timetype="$ans"
Xelse
X	echo 'time() not found, hope that will do.' >&4
X	val="$undef"
X	timetype='int';
Xfi
Xset d_time
Xeval $setvar
X
X: see what type uids are declared as in the kernel
Xcase "$uidtype" in
X'')
X	if $contains 'uid_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
X		dflt='uid_t';
X	else
X		xxx=`./findhdr sys/user.h`
X		set `grep '_ruid;' "$xxx" 2>/dev/null` unsigned short
X		case $1 in
X		unsigned) dflt="$1 $2" ;;
X		*) dflt="$1" ;;
X		esac
X	fi
X	;;
X*)  dflt="$uidtype";;
Xesac
Xecho " "
Xrp="What type are user ids on this system declared as?"
X. ./myread
Xuidtype="$ans"
X
X: check for void type
Xecho " "
X$cat >&4 <<EOM
XChecking to see how well your C compiler groks the void type...
X
X  Support flag bits are:
X    1: basic void declarations.
X    2: arrays of pointers to functions returning void.
X    4: operations between pointers to and addresses of void functions.
X    8: generic void pointers.
X
XEOM
Xcase "$voidflags" in
X'')
X	$cat >try.c <<'EOCP'
X#if TRY & 1
Xvoid main() {
X#else
Xmain() {
X#endif
X	extern void moo();	/* function returning void */
X	void (*goo)();		/* ptr to func returning void */
X#if TRY & 8
X	void *hue;		/* generic ptr */
X#endif
X#if TRY & 2
X	void (*foo[10])();
X#endif
X
X#if TRY & 4
X	if(goo == moo) {
X		exit(0);
X	}
X#endif
X	exit(0);
X}
XEOCP
X	if $cc -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
X		voidflags=$defvoidused
X	echo "It appears to support void to the level $package wants ($defvoidused)."
X		if $contains warning .out >/dev/null 2>&1; then
X			echo "However, you might get some warnings that look like this:"
X			$cat .out
X		fi
X	else
Xecho "Hmm, your compiler has some difficulty with void. Checking further..." >&4
X		if $cc -c -DTRY=1 try.c >/dev/null 2>&1 ; then
X			echo "It supports 1..."
X			if $cc -c -DTRY=3 try.c >/dev/null 2>&1 ; then
X				echo "It also supports 2..."
X				if $cc -c -DTRY=7 try.c >/dev/null 2>&1 ; then
X					voidflags=7
X					echo "And it supports 4 but not 8 definitely."
X				else
X					echo "It doesn't support 4..."
X					if $cc -c -DTRY=11 try.c >/dev/null 2>&1 ; then
X						voidflags=11
X						echo "But it supports 8."
X					else
X						voidflags=3
X						echo "Neither does it support 8."
X					fi
X				fi
X			else
X				echo "It does not support 2..."
X				if $cc -c -DTRY=13 try.c >/dev/null 2>&1 ; then
X					voidflags=13
X					echo "But it supports 4 and 8."
X				else
X					if $cc -c -DTRY=5 try.c >/dev/null 2>&1 ; then
X						voidflags=5
X						echo "And it supports 4 but has not heard about 8."
X					else
X						echo "However it supports 8 but not 4."
X					fi
X				fi
X			fi
X		else
X			echo "There is no support at all for void."
X			voidflags=0
X		fi
X	fi
Xesac
Xdflt="$voidflags";
Xrp="Your void support flags add up to what?"
X. ./myread
Xvoidflags="$ans"
X$rm -f try.* .out
X
X: define an alternate in-header-list? function
Xinhdr='echo " "; td=$define; tu=$undef; yyy=$@;
Xcont=true; xxf="echo \"<\$1> found.\" >&4";
Xcase $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
X*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
Xesac;
Xcase $# in 4) instead=instead;; *) instead="at last";; esac;
Xwhile $test "$cont"; do
X	xxx=`./findhdr $1`
X	var=$2; eval "was=\$$2";
X	if $test "$xxx" && $test -r "$xxx";
X	then eval $xxf;
X		eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
X		cont="";
X	else eval $xxnf;
X		eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi;
X	set $yyy; shift; shift; yyy=$@;
X	case $# in 0) cont="";;
X	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
X		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
X	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
X		xxnf="echo \"there is no <\$1>, ...\" >&4";;
X	esac;
Xdone;
Xwhile $test "$yyy";
Xdo set $yyy; var=$2; eval "was=\$$2";
X	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu";
X	set $yyy; shift; shift; yyy=$@;
Xdone'
X
X: see if this is a sys/file.h system
Xval=''
Xset sys/file.h val
Xeval $inhdr
X
X: do we need to #include <sys/file.h> ?
Xcase "$val" in
X"$define")
X	echo " "
X	if $h_sysfile; then
X		val="$define"
X		echo "We'll be including <sys/file.h>." >&4
X	else
X		val="$undef"
X		echo "We won't be including <sys/file.h>." >&4
X	fi
X	;;
X*)
X	h_sysfile=false
X	;;
Xesac
Xset i_sysfile
Xeval $setvar
X
X: see if fcntl.h is there
Xval=''
Xset fcntl.h val
Xeval $inhdr
X
X: see if we can include fcntl.h
Xcase "$val" in
X"$define")
X	echo " "
X	if $h_fcntl; then
X		val="$define"
X		echo "We'll be including <fcntl.h>." >&4
X	else
X		val="$undef"
X		if $h_sysfile; then
X	echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
X		else
X			echo "We won't be including <fcntl.h>." >&4
X		fi
X	fi
X	;;
X*)
X	h_fcntl=false
X	val="$undef"
X	;;
Xesac
Xset i_fcntl
Xeval $setvar
X
X: see if we should include time.h, sys/time.h, or both
Xecho " "
Xecho "Testing to see if we should include <time.h>, <sys/time.h> or both." >&4
X$echo $n "I'm now running the test program...$c"
X$cat >try.c <<'EOCP'
X#include <sys/types.h>
X#ifdef I_TIME
X#include <time.h>
X#endif
X#ifdef I_SYSTIME
X#ifdef SYSTIMEKERNEL
X#define KERNEL
X#endif
X#include <sys/time.h>
X#endif
X#ifdef I_SYSSELECT
X#include <sys/select.h>
X#endif
Xmain()
X{
X	struct tm foo;
X#ifdef S_TIMEVAL
X	struct timeval bar;
X#endif
X#ifdef S_TIMEZONE
X	struct timezone tzp;
X#endif
X	if (foo.tm_sec == foo.tm_sec)
X		exit(0);
X#ifdef S_TIMEVAL
X	if (bar.tv_sec == bar.tv_sec)
X		exit(0);
X#endif
X	exit(1);
X}
XEOCP
Xflags=''
Xfor s_timezone in '-DS_TIMEZONE' ''; do
Xsysselect=''
Xfor s_timeval in '-DS_TIMEVAL' ''; do
Xfor i_systimek in '' '-DSYSTIMEKERNEL'; do
Xfor i_time in '' '-DI_TIME'; do
Xfor i_systime in '-DI_SYSTIME' ''; do
X	case "$flags" in
X	'') $echo $n ".$c"
X		if $cc $ccflags \
X		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
X		try.c -o try >/dev/null 2>&1 ; then
X			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
X			shift
X			flags="$*"
X			echo " "
X			$echo $n "Succeeded with $flags$c"
X		fi
X		;;
X	esac
Xdone
Xdone
Xdone
Xdone
Xdone
Xtimeincl=''
Xecho " "
Xcase "$flags" in
X*SYSTIMEKERNEL*) i_systimek="$define"
X	timeincl=`./findhdr sys/time.h`
X	echo "We'll include <sys/time.h> with KERNEL defined." >&4;;
X*) i_systimek="$undef";;
Xesac
Xcase "$flags" in
X*I_TIME*) i_time="$define"
X	timeincl=`./findhdr time.h`" $timeincl"
X	echo "We'll include <time.h>." >&4;;
X*) i_time="$undef";;
Xesac
Xcase "$flags" in
X*I_SYSTIME*) i_systime="$define"
X	timeincl=`./findhdr sys/time.h`" $timeincl"
X	echo "We'll include <sys/time.h>." >&4;;
X*) i_systime="$undef";;
Xesac
X$rm -f try.c try
X
X: see if this is a syswait system
Xset sys/wait.h i_syswait
Xeval $inhdr
X
X: notify author that his package is used
Xif $test -f ../.config/mailauthor &&
X	cmp ../patchlevel.h ../.config/mailauthor >/dev/null 2>&1
Xthen
X	status="say that you're using $package";
X	case "$mailpatches" in
X	true) status='have patches mailed to you as they are issued';;
X	esac
X	case "$notifypatches" in
X	true) status='be notified when new patches are issued';;
X	esac
X	$cat <<EOM
X
XYou have already sent the author of $package (ram@acri.fr) mail to
X$status. If you wish, you may modify
Xyour previous request by sending a new mail with different options.
X
XEOM
X	rp='Should I send a status update to ram@acri.fr?'
X	dflt=n
Xelse
X	$cat <<EOM
X
XIf you are able to send mail to the Internet, the author of $package would
Xreally appreciate you letting me send off a quick note, just to say that you've
Xtried it. The author is more likely to spend time maintaining $package if it's
Xknown that many people are using it, and you can even ask to get sent new
Xpatches automagically this way if you wish. To protect your privacy, all I'll
Xsay in the mail is the version of $package that you're using.
X
XEOM
X	rp='Should I send mail to ram@acri.fr?'
X	dflt=y
Xfi
X. ./myread
Xcase "$ans" in
X[yY]*)
X	echo " "
X	echo "Great!. You cooperation is really appreciated."
X	$cat <<EOM
X
XSome braindead sites do not set a proper return address in the From: header of
Xtheir outgoing mail, making it impossible to reply to mail they generate.
XIf your site is broken in this way, write to your system administrator and get
Xit fixed!!! In the mean time, you can manually specify the Internet e-mail
Xaddress by which the author can get back to you, should there be a need to do
Xso. If manually specified, it should be something like "user@domain.top".
XIf your mail system generates addresses correctly, specify "none".
X
XEOM
X	case "$usermail" in
X	'-'|'') dflt=none;;
X	*) dflt="$usermail";;
X	esac
X	rp='Manually specify a return address to use:'
X	. ./myread
X	case "$ans" in
X	none|*@*.*)
X		case "$ans" in
X		none) usermail='-';;
X		*) usermail="$ans";;
X		esac
X		;;
X	*)
X		echo "(Address does not look like an Internet one -- ignoring it.)"
X		usermail='-'
X		mailpatches=false
X		notifypatches=false
X		;;
X	esac
X	echo " "
X	opt=''
X	rp='Would you like to have new patches automatically mailed to you?'
X	case "$mailpatches" in
X	true) dflt=y;;
X	*) dflt=n;;
X	esac
X	. ./myread
X	case "$ans" in
X	[yY]*) opt=' mailpatches'; mailpatches=true;;
X	*)
X		mailpatches=false
X		echo " "
X		rp='Ok, would you like to simply be notified of new patches?'
X		case "$notifypatches" in
X		false) dflt=n;;
X		*) dflt=y;;
X		esac
X		. ./myread
X		echo " "
X		case "$ans" in
X		[yY]*) opt=' notifypatches'; notifypatches=true;;
X		*)
X			echo "Fine, I'll simply say that you've tried it then."
X			notifypatches=false
X			;;
X		esac
X		;;
X	esac
X	echo "Sending mail to ram@acri.fr..." >&4
X	atsh='@SH'
X	$mailer ram@acri.fr <<EOM >/dev/null 2>&1
XSubject: Command
XPrecedence: junk
XTo: ram@acri.fr
X
X$atsh package $usermail $package $baserev $patchlevel$opt
XEOM
X	$rm -f ../.config/mailauthor
X	cp ../patchlevel.h ../.config/mailauthor
X	;;
X*)
X	case "$dflt" in
X	"y") echo "Oh well, maybe next time.";;
X	esac
X	;;
Xesac
X
X: end of configuration questions
Xecho " "
Xecho "End of configuration questions."
Xecho " "
X
X: back to where it started
Xif test -d ../UU; then
X	cd ..
Xfi
X
X: configuration may be patched via a 'config.over' file
Xif $test -f config.over; then
X	echo " "
X	dflt=y
X	rp='I see a config.over file.  Do you wish to load it?'
X	. UU/myread
X	case "$ans" in
X	n*) echo "OK, I'll ignore it.";;
X	*)	. ./config.over
X		echo "Configuration override changes have been loaded."
X		;;
X	esac
Xfi
X
X: create config.sh file
Xecho " "
Xecho "Creating config.sh..." >&4
X$spitshell <<EOT >config.sh
X$startsh
X#
X# This file was produced by running the Configure script. It holds all the
X# definitions figured out by Configure. Should you modify one of these values,
X# do not forget to propagate your changes by running "Configure -der". You may
X# instead choose to run each of the .SH files by yourself, or "Configure -S".
X#
X
X# Configuration time: $cf_time
X# Configured by: $cf_by
X# Target system: $myuname
X
Xd_bsd='$d_bsd'
Xd_eunice='$d_eunice'
Xd_xenix='$d_xenix'
Xeunicefix='$eunicefix'
XMcc='$Mcc'
Xawk='$awk'
Xbash='$bash'
Xbison='$bison'
Xcat='$cat'
Xchgrp='$chgrp'
Xchmod='$chmod'
Xchown='$chown'
Xcompress='$compress'
Xcp='$cp'
Xcpio='$cpio'
Xcpp='$cpp'
Xcsh='$csh'
Xdate='$date'
Xecho='$echo'
Xegrep='$egrep'
Xemacs='$emacs'
Xexpr='$expr'
Xflex='$flex'
Xgcc='$gcc'
Xgrep='$grep'
Xinews='$inews'
Xksh='$ksh'
Xless='$less'
Xline='$line'
Xlint='$lint'
Xln='$ln'
Xlp='$lp'
Xlpr='$lpr'
Xls='$ls'
Xmail='$mail'
Xmailx='$mailx'
Xmake='$make'
Xmkdir='$mkdir'
Xmore='$more'
Xmv='$mv'
Xnroff='$nroff'
Xperl='$perl'
Xpg='$pg'
Xpmake='$pmake'
Xpr='$pr'
Xrm='$rm'
Xrmail='$rmail'
Xsed='$sed'
Xsendmail='$sendmail'
Xsh='$sh'
Xshar='$shar'
Xsleep='$sleep'
Xsmail='$smail'
Xsort='$sort'
Xsubmit='$submit'
Xtail='$tail'
Xtar='$tar'
Xtbl='$tbl'
Xtest='$test'
Xtouch='$touch'
Xtr='$tr'
Xtroff='$troff'
Xuname='$uname'
Xuniq='$uniq'
Xuuname='$uuname'
Xvi='$vi'
Xzcat='$zcat'
Xmailpatches='$mailpatches'
Xnotifypatches='$notifypatches'
Xusermail='$usermail'
Xhint='$hint'
Xmyuname='$myuname'
XAuthor='$Author'
XDate='$Date'
XHeader='$Header'
XId='$Id'
XLocker='$Locker'
XLog='$Log'
XRCSfile='$RCSfile'
XRevision='$Revision'
XSource='$Source'
XState='$State'
Xafs='$afs'
Xbaserev='$baserev'
Xbin='$bin'
Xbinexp='$binexp'
Xinstallbin='$installbin'
Xcc='$cc'
Xccflags='$ccflags'
Xcppflags='$cppflags'
Xldflags='$ldflags'
Xlkflags='$lkflags'
Xoptimize='$optimize'
Xcf_by='$cf_by'
Xcf_time='$cf_time'
Xcontains='$contains'
Xcppminus='$cppminus'
Xcppstdin='$cppstdin'
Xd_bcopy='$d_bcopy'
Xd_flock='$d_flock'
Xaphostname='$aphostname'
Xd_gethname='$d_gethname'
Xd_phostname='$d_phostname'
Xd_uname='$d_uname'
Xd_hidnet='$d_hidnet'
Xhiddennet='$hiddennet'
Xd_open3='$d_open3'
Xd_portable='$d_portable'
Xd_rename='$d_rename'
Xd_index='$d_index'
Xd_strchr='$d_strchr'
Xd_strerrm='$d_strerrm'
Xd_strerror='$d_strerror'
Xd_sysernlst='$d_sysernlst'
Xd_syserrlst='$d_syserrlst'
Xd_time='$d_time'
Xtimetype='$timetype'
Xd_uwait='$d_uwait'
Xd_vfork='$d_vfork'
Xd_voidsig='$d_voidsig'
Xsignal_t='$signal_t'
Xh_fcntl='$h_fcntl'
Xh_sysfile='$h_sysfile'
Xi_fcntl='$i_fcntl'
Xi_string='$i_string'
Xstrings='$strings'
Xi_sysfile='$i_sysfile'
Xi_syswait='$i_syswait'
Xi_systime='$i_systime'
Xi_systimek='$i_systimek'
Xi_time='$i_time'
Xtimeincl='$timeincl'
Xintsize='$intsize'
Xlibc='$libc'
Xlibpth='$libpth'
Xplibpth='$plibpth'
Xxlibpth='$xlibpth'
Xlibs='$libs'
Xmaildir='$maildir'
Xmaildirexp='$maildirexp'
Xmailer='$mailer'
Xmailfile='$mailfile'
Xinstallmansrc='$installmansrc'
Xmanext='$manext'
Xmansrc='$mansrc'
Xmansrcexp='$mansrcexp'
Xd_flockonly='$d_flockonly'
Xd_lockflock='$d_lockflock'
Xflock_only='$flock_only'
Xlock_by_flock='$lock_by_flock'
Xmkdep='$mkdep'
Xhuge='$huge'
Xlarge='$large'
Xmedium='$medium'
Xmodels='$models'
Xsmall='$small'
Xsplit='$split'
Xmydomain='$mydomain'
Xmyhostname='$myhostname'
Xphostname='$phostname'
Xc='$c'
Xn='$n'
Xgroupcat='$groupcat'
Xhostcat='$hostcat'
Xpasscat='$passcat'
Xorgname='$orgname'
Xpackage='$package'
Xspackage='$spackage'
Xpatchlevel='$patchlevel'
Xperlpath='$perlpath'
Xpidtype='$pidtype'
Xinstallprivlib='$installprivlib'
Xprivlib='$privlib'
Xprivlibexp='$privlibexp'
Xprototype='$prototype'
Xreg10='$reg10'
Xreg11='$reg11'
Xreg12='$reg12'
Xreg13='$reg13'
Xreg14='$reg14'
Xreg15='$reg15'
Xreg16='$reg16'
Xreg1='$reg1'
Xreg2='$reg2'
Xreg3='$reg3'
Xreg4='$reg4'
Xreg5='$reg5'
Xreg6='$reg6'
Xreg7='$reg7'
Xreg8='$reg8'
Xreg9='$reg9'
Xregisters='$registers'
Xinstallscript='$installscript'
Xscriptdir='$scriptdir'
Xscriptdirexp='$scriptdirexp'
Xsharpbang='$sharpbang'
Xshsharp='$shsharp'
Xspitshell='$spitshell'
Xstartperl='$startperl'
Xstartsh='$startsh'
Xsysman='$sysman'
Xuidtype='$uidtype'
Xnm_opt='$nm_opt'
Xrunnm='$runnm'
Xusenm='$usenm'
Xincpath='$incpath'
Xmips='$mips'
Xmips_type='$mips_type'
Xusrinc='$usrinc'
Xdefvoidused='$defvoidused'
Xvoidflags='$voidflags'
XEOT
X
X: add special variables
X$test -f patchlevel.h && \
Xawk '/^#define/ {printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
Xecho "CONFIG=true" >>config.sh
X
X: propagate old symbols
Xif $test -f UU/config.sh; then
X	<UU/config.sh sort | uniq >UU/oldconfig.sh
X	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
X	sort | uniq -u >UU/oldsyms
X	set X `cat UU/oldsyms`
X	shift
X	case $# in
X	0) ;;
X	*)
X		cat <<EOM
XHmm...You had some extra variables I don't know about...I'll try to keep 'em...
XEOM
X		echo "# Variables propagated from previous config.sh file." >>config.sh
X		for sym in `cat UU/oldsyms`; do
X			echo "    Propagating $hint variable "'$'"$sym..."
X			eval 'tmp="$'"${sym}"'"'
X			echo "$tmp" | \
X				sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
X		done
X		;;
X	esac
Xfi
X
X: Finish up by extracting the .SH files
Xcase "$alldone" in
Xexit)
X	$rm -rf UU
X	echo "Done."
X	exit 0
X	;;
Xcont)
X	;;
X'')
X	echo " "
X	dflt=''
X	nostick=true
Xecho "If you didn't make any mistakes, then just type a carriage return here."
X	rp="If you need to edit config.sh, do it as a shell escape here:"
X	. UU/myread
X	nostick=''
X	case "$ans" in
X	'') ;;
X	*) : in case they cannot read
X		sh 1>&4 -c "$ans";;
X	esac
X	;;
Xesac
X
X: if this fails, just run all the .SH files by hand
X. ./config.sh
X
Xecho " "
Xexec 1>&4
X. ./UU/extract
X
Xif $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
X	dflt=y
X	case "$silent" in
X	true) ;;
X	*)
X		$cat <<EOM
X
XNow you need to generate make dependencies by running "make depend".
XYou might prefer to run it in background: "make depend > makedepend.out &"
XIt can take a while, so you might not want to run it right now.
X
XEOM
X		;;
X	esac
X	rp="Run make depend now?"
X	. UU/myread
X	case "$ans" in
X	y*)
X		make depend && echo "Now you must run a make."
X		;;
X	*)
X		echo "You must run 'make depend' then 'make'."
X		;;
X	esac
Xelif test -f [Mm]akefile; then
X	echo " "
X	echo "Now you must run a make."
Xelse
X	echo "Done."
Xfi
X
X$rm -f kit*isdone ark*isdone
X$rm -rf UU
X: End of Configure
END_OF_FILE
  if test 46962 -ne `wc -c <'Configure.02'`; then
    echo shar: \"'Configure.02'\" unpacked with wrong size!
  fi
  # end of 'Configure.02'
fi
if test -f 'agent/pl/add_log.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/pl/add_log.pl'\"
else
  echo shar: Extracting \"'agent/pl/add_log.pl'\" \(5120 characters\)
  sed "s/^X//" >'agent/pl/add_log.pl' <<'END_OF_FILE'
X;# $Id: add_log.pl,v 3.0 1993/11/29 13:48:34 ram Exp ram $
X;#
X;#  Copyright (c) 1990-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic License,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic License; a copy of which may be found at the root
X;#  of the source tree for mailagent 3.0.
X;#
X;# $Log: add_log.pl,v $
X;# Revision 3.0  1993/11/29  13:48:34  ram
X;# Baseline for mailagent 3.0 netwide release.
X;#
X;# Logging facilities. Normally, logs are appended into the agentlog file by
X;# a call to &add_log. For plain mailagent actions, this is fine. However,
X;# when user-defined commands are run or when the generic server is used, it
X;# could be desirable to write the logs to some other file.
X;#
X;# Therefore, this package provides a generic logging interface (usr_log) while
X;# keeping the previous add_log routine for backward compatibility. The user
X;# may record alternative log files, with or without a copy to the global log.
X;#
X;# The following interface functions in the usrlog package are available:
X;#
X;#   . new(name, file, flag)
X;#       records a log file. If flag is true, a copy to the main log
X;#       is also written. The name parameter refers to the global name
X;#       under which the log is known from now on. If an existing log file
X;#       has already been defined under this name, nothing is done.
X;#   . delete(name)
X;#       deletes a log file by name.
X;#
X;# All files given as a relative path name (i.e. not starting with /) are
X;# rooted in the 'logdir' directory as defined in the ~/.mailagent file.
X;#
X;# To log something, the user calls:
X;#
X;#   . usr_log(name, string)
X;#
X;# The logfile name 'default' is reserved to refer to the default system-wide
X;# logfile. Trying to log something to a non-existent logfile will log to the
X;# default logfile instead.
X;#
X# Add an entry to logfile
X# There is no need to lock logfile as print is sandwiched betweeen
X# an open and a close (kernel will flush at the end of the file).
Xsub add_log {
X	# Indirection needed, so that we may remap add_log on stderr_log via a
X	# type glob assignment.
X	&usrlog'write_log($cf'logfile, $_[0], undef);
X}
X
X# When mailagent is used interactively, log messages are also printed on
X# the standard error.
X# NB: this function is not called directly, but via a type glob *add_log.
Xsub stderr_log {
X	print STDERR "$prog_name: $_[0]\n";
X	&usrlog'write_log($cf'logfile, $_[0], undef);
X}
X
X#
X# User-defined log files
X#
X
Xpackage usrlog;
X
X# Record a new logfile by storing its pathname in the %Logpath hash table
X# indexed by names and the carbon-copy flag in the %Cc table.
Xsub new {
X	local($name, $path, $cc) = @_;
X	return if defined $Logpath{$name};	# Logfile already recorded
X	return if $name eq 'default';		# Cannot redefined defaul log
X	$path = "$cf'logdir/$path" unless $path =~ m|^/|;
X	$Logpath{$name} = $path;			# Where logfile should be stored
X	$Cc{$name} = $cc ? 1 : 0;			# Should we cc the default logfile?
X	$Map{$path} = $name;				# Two-way hash table
X}
X
X# Delete user-defined logfile.
Xsub delete {
X	local($name) = @_;
X	return unless defined $Logpath{$name};
X	local($path) = $Logpath{$name};
X	delete $Logpath{$name};
X	delete $Cc{$name};
X	delete $Map{$path};
X}
X
X# User-level logging main entry point
Xsub main'usr_log {
X	local($name, $message) = @_;	# Logfile name and message to be logged
X	local($file);
X	$file = ($name eq 'default' || !defined $Logpath{$name}) ?
X		$cf'logfile : $Logpath{$name};
X	&write_log($file, $message, $Cc{$name});
X}
X
X# Log message into logfile, using jobnum to identify process.
Xsub write_log {
X	local($file, $msg, $cc) = @_;	# Logfile, message to be logged, cc flag
X	local($date);
X	local($log);
X
X	local ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
X		localtime(time);
X	$date = sprintf("%.2d/%.2d/%.2d %.2d:%.2d:%.2d",
X		$year,++$mon,$mday,$hour,$min,$sec);
X	$log = $date . " $'prog_name[$'jobnum]: $msg\n";
X
X	# If we cannot append to the logfile, first check whether it is the default
X	# logfile or not. If it is not, then add a log entry to state the error in
X	# the default log and then delete that user logname entry, assuming the
X	# fault we get is of a permanent nature and not an NFS failure for instance.
X
X	unless (open(LOGFILE, ">>$file")) {
X		if ($file ne $cf'logfile) {
X			local($name) = $Map{$file};	# Name under which it was registered
X			&'add_log("ERROR cannot append to $name logfile $file: $!")
X				if $'loglvl > 1;
X			&'add_log("NOTICE removing logging to $file") if $'loglvl > 6;
X			&delete($Map{$file});
X			$cc = 1;				# Force logging to default file
X		} else {					# We were already writing to default log
X			return;					# Cannot log message at all
X		}
X	}
X
X	print LOGFILE $log;
X	close LOGFILE;
X
X	# If $cc is set, a copy of the same log message (same time stamp guaranteed)
X	# is made to the default logfile. If called with $file set to that default
X	# logfile, $cc will be undef by construction.
X
X	if ($cc) {
X		open(LOGFILE, ">>$cf'logfile");
X		print LOGFILE $log;
X		close LOGFILE;
X	}
X}
X
Xpackage main;
X
END_OF_FILE
  if test 5120 -ne `wc -c <'agent/pl/add_log.pl'`; then
    echo shar: \"'agent/pl/add_log.pl'\" unpacked with wrong size!
  fi
  # end of 'agent/pl/add_log.pl'
fi
echo shar: End of archive 7 \(of 26\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    echo "Now run 'sh PACKNOTES', then read README and type Configure.'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
