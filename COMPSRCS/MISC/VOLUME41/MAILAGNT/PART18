Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v41i018:  mailagent - Flexible mail filtering and processing package, v3.0, Part18/26
Message-ID: <1993Dec3.213347.22582@sparky.sterling.com>
X-Md4-Signature: 981913fae13c29c88a6bd99d8a8e420e
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Fri, 3 Dec 1993 21:33:47 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 41, Issue 18
Archive-name: mailagent/part18
Environment: UNIX, Perl
Supersedes: mailagent: Volume 33, Issue 93-109

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Artistic Makefile.SH agent/files/Makefile.SH
#   agent/filter/Makefile.SH agent/filter/lock.c
#   agent/filter/logfile.c agent/man/mailhelp.SH agent/pl/emergency.pl
#   agent/pl/eval.pl
# Wrapped by ram@soft208 on Mon Nov 29 16:49:57 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 26)."'
if test -f 'Artistic' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Artistic'\"
else
  echo shar: Extracting \"'Artistic'\" \(6205 characters\)
  sed "s/^X//" >'Artistic' <<'END_OF_FILE'
X                      The "Artistic License"
X
X                             Preamble
X
XThe intent of this document is to state the conditions under which a
XPackage may be copied, such that the Copyright Holder maintains some
Xsemblance of artistic control over the development of the Package,
Xwhile giving the users of the package the right to use and distribute
Xthe Package in a more-or-less customary fashion, plus the right to make
Xreasonable modifications.
X
XIt also grants you the rights to reuse parts of a Package in your own
Xprograms without transferring this License to those programs, provided
Xthat you meet some reasonable requirements.
X
XDefinitions:
X
X        "Package" refers to the collection of files distributed by the
X        Copyright Holder, and derivatives of that collection of files
X        created through textual modification.
X
X        "Standard Version" refers to such a Package if it has not been
X        modified, or has been modified in accordance with the wishes
X        of the Copyright Holder as specified below.
X
X        "Copyright Holder" is whoever is named in the copyright or
X        copyrights for the package.
X
X        "You" is you, if you're thinking about copying or distributing
X        this Package.
X
X        "Reasonable copying fee" is whatever you can justify on the
X        basis of media cost, duplication charges, time of people involved,
X        and so on.  (You will not be required to justify it to the
X        Copyright Holder, but only to the computing community at large
X        as a market that must bear the fee.)
X
X        "Freely Available" means that no fee is charged for the item
X        itself, though there may be fees involved in handling the item.
X        It also means that recipients of the item may redistribute it
X        under the same conditions they received it.
X
X1. You may make and give away verbatim copies of the source form of the
XStandard Version of this Package without restriction, provided that you
Xduplicate all of the original copyright notices and associated disclaimers.
X
X2. You may apply bug fixes, portability fixes and other modifications
Xderived from the Public Domain or from the Copyright Holder.  A Package
Xmodified in such a way shall still be considered the Standard Version.
X
X3. You may otherwise modify your copy of this Package in any way, provided
Xthat you insert a prominent notice in each changed file stating how and
Xwhen you changed that file, and provided that you do at least ONE of the
Xfollowing:
X
X    a) place your modifications in the Public Domain or otherwise make them
X    Freely Available, such as by posting said modifications to Usenet or
X    an equivalent medium, or placing the modifications on a major archive
X    site such as uunet.uu.net, or by allowing the Copyright Holder to include
X    your modifications in the Standard Version of the Package.
X
X    b) use the modified Package only within your corporation or organization.
X
X    c) rename any non-standard executables so the names do not conflict
X    with standard executables, which must also be provided, and provide
X    a separate manual page for each non-standard executable that clearly
X    documents how it differs from the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X4. You may distribute the programs of this Package in object code or
Xexecutable form, provided that you do at least ONE of the following:
X
X    a) distribute a Standard Version of the executables and library files,
X    together with instructions (in the manual page or equivalent) on where
X    to get the Standard Version.
X
X    b) accompany the distribution with the machine-readable source of
X    the Package with your modifications.
X
X    c) give non-standard executables non-standard names, and clearly
X    document the differences in manual pages (or equivalent), together
X    with instructions on where to get the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X5. You may charge a reasonable copying fee for any distribution of this
XPackage.  You may charge any fee you choose for support of this
XPackage.  You may not charge a fee for this Package itself.  However,
Xyou may distribute this Package in aggregate with other (possibly
Xcommercial) programs as part of a larger (possibly commercial) software
Xdistribution provided that you do not advertise this Package as a
Xproduct of your own.
X
X6. The scripts and library files supplied as input to or produced as
Xoutput from the programs of this Package do not automatically fall
Xunder the copyright of this Package, but belong to whomever generated
Xthem, and may be sold commercially, and may be aggregated with this
XPackage.  If such scripts or library files are aggregated with this
XPackage via the so-called "undump" or "unexec" methods of producing a
Xbinary executable image, then distribution of such an image shall
Xneither be construed as a distribution of this Package nor shall it
Xfall under the restrictions of Paragraphs 3 and 4, provided that you do
Xnot represent such an executable image as a Standard Version of this
XPackage.
X
X7. You may reuse parts of this Package in your own programs, provided that
Xyou explicitly state where you got them from, in the source code (and, left
Xto your courtesy, in the documentation), duplicating all the associated
Xcopyright notices and disclaimers. Besides your changes, if any, must be
Xclearly marked as such. Parts reused that way will no longer fall under this
Xlicense if, and only if, the name of your program(s) have no immediate
Xconnection with the name of the Package itself or its associated programs.
XYou may then apply whatever restrictions you wish on the reused parts or
Xchoose to place them in the Public Domain--this will apply only within the
Xcontext of your package.
X
X8. The name of the Copyright Holder may not be used to endorse or promote
Xproducts derived from this software without specific prior written permission.
X
X9. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
XIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
XWARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
X                                The End
END_OF_FILE
  if test 6205 -ne `wc -c <'Artistic'`; then
    echo shar: \"'Artistic'\" unpacked with wrong size!
  fi
  # end of 'Artistic'
fi
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
  echo shar: Extracting \"'Makefile.SH'\" \(5126 characters\)
  sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL14]
X: $X-Id: Jmake.tmpl,v 3.0.1.1 1993/08/20 07:36:36 ram Exp ram $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		echo "Can't find config.sh."; exit 1
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=.
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = .
XCURRENT = $CURRENT
XDIR = $DIR
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XMAKE = make
XMV = $mv
XRM = $rm -f
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSUBDIRS = agent
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 3.0 1993/08/18 12:04:14 ram Exp ram $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.9 92/07/14 16:46:57 ram Exp $
X#
X#  Copyright (c) 1990-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic License,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic License; a copy of which may be found at the root
X#  of the source tree for mailagent 3.0.
X#
X# $X-Log$
X
Xall::
X
Xlocal_clobber::
X	$(RM) install mkdep cppstdin
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo "Depending" "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS)  depend); \
X	done
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: sub_clean local_clean
Xrealclean: sub_realclean local_realclean
Xclobber: sub_clobber local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X	$(RM) -r UU
X
Xlocal_clobber:: local_realclean
X	$(RM) config.sh config.h
X	$(RM) Makefile
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Rules for building in sub-directories -- do not edit
X
Xsubdirs:
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo $(VERB) "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS) $(FLAGS) $(TARGET)); \
X	done
X
Xinstall::
X	@$(MAKE) subdirs TARGET=install VERB="Installing" FLAGS=
X
Xdeinstall::
X	@$(MAKE) subdirs TARGET=deinstall VERB="Deinstalling" FLAGS=
X
Xinstall.man::
X	@$(MAKE) subdirs TARGET=install.man VERB="Installing man pages" FLAGS=
X
Xdeinstall.man::
X	@$(MAKE) subdirs TARGET=deinstall.man VERB="Deinstalling man pages" FLAGS=
X
Xsub_clean::
X	@$(MAKE) subdirs TARGET=clean VERB="Cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "clean...
X
Xsub_realclean::
X	@$(MAKE) subdirs TARGET=realclean VERB="Real cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "realclean...
X
Xsub_clobber::
X	@$(MAKE) subdirs TARGET=clobber VERB="Clobbering" FLAGS=
X	@echo "Back to $(CURRENT) for "clobber...
X
Xtag::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo "Tagging" "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS)  tag); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		echo "Making "Makefiles" in $(DIR)$$i..."; \
X		(cd $$i || exit 1; \
X		if test ! -f Makefile; then /bin/sh Makefile.SH; fi; \
X		$(MAKE) $(MFLAGS) Makefiles) \
X	done
X
XMakefiles.SH:: Makefile.SH
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		case "$(DIR)$$i/" in \
X		*/*/*/*/) newtop=../../../..;; \
X		*/*/*/) newtop=../../..;; \
X		*/*/) newtop=../..;; \
X		*/) newtop=..;; \
X		esac; \
X		case "$(TOP)" in \
X		/*) newtop="$(TOP)" ;; \
X		esac; \
X		echo "Making Makefiles.SH in $(DIR)$$i..."; \
X		(cd $$i || exit 1; $(MAKE) $(MFLAGS) -f ../Makefile \
X		Makefile TOP=$$newtop CURRENT=$(DIR)$$i;\
X		$(MAKE) $(MFLAGS) Makefiles.SH) \
X	done
X
Xall::
X	@$(MAKE) subdirs TARGET=all VERB="Making all" FLAGS=
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5126 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'Makefile.SH'
fi
if test -f 'agent/files/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/files/Makefile.SH'\"
else
  echo shar: Extracting \"'agent/files/Makefile.SH'\" \(5457 characters\)
  sed "s/^X//" >'agent/files/Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL14]
X: $X-Id: Jmake.tmpl,v 3.0.1.1 1993/08/20 07:36:36 ram Exp ram $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		echo "Can't find config.sh."; exit 1
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=agent/files
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = ../..
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ../../install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XMAKE = make
XMV = $mv
XPRIVLIB = $installprivlib
XRM = $rm -f
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSUBDIRS = help
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 3.0 1993/08/18 12:04:14 ram Exp ram $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.9 92/07/14 16:47:32 ram Exp $
X#
X#  Copyright (c) 1990-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic License,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic License; a copy of which may be found at the root
X#  of the source tree for mailagent 3.0.
X#
X# $X-Log$
X
XFILES = agenthelp commands distribs filter.sh mailagent.cf proglist \
X	chkagent.sh
X
Xall::
X
Xinstall::
X	@for dir in $(PRIVLIB); do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(INSTALL) -d $$dir); \
X	done
X
Xdeinstall::
X	$(RM) -r $(PRIVLIB)
X
Xinstall:: $(FILES)
X	@case '${MFLAGS}' in *[i]*) set +e;; esac; \
X	for i in $(FILES); do \
X		(set -x; $(INSTALL) -c -m 444 $$i $(PRIVLIB)); \
X	done
X
Xdeinstall::
X	@case '${MFLAGS}' in *[i]*) set +e;; esac; \
X	for i in $(FILES); do \
X		(set -x; $(RM) $(PRIVLIB)/$$i); \
X	done
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: sub_clean local_clean
Xrealclean: sub_realclean local_realclean
Xclobber: sub_clobber local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X
Xlocal_clobber:: local_realclean
X	$(RM) Makefile config.sh
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Rules for building in sub-directories -- do not edit
X
Xsubdirs:
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo $(VERB) "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS) $(FLAGS) $(TARGET)); \
X	done
X
Xinstall::
X	@$(MAKE) subdirs TARGET=install VERB="Installing" FLAGS=
X
Xdeinstall::
X	@$(MAKE) subdirs TARGET=deinstall VERB="Deinstalling" FLAGS=
X
Xinstall.man::
X	@$(MAKE) subdirs TARGET=install.man VERB="Installing man pages" FLAGS=
X
Xdeinstall.man::
X	@$(MAKE) subdirs TARGET=deinstall.man VERB="Deinstalling man pages" FLAGS=
X
Xsub_clean::
X	@$(MAKE) subdirs TARGET=clean VERB="Cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "clean...
X
Xsub_realclean::
X	@$(MAKE) subdirs TARGET=realclean VERB="Real cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "realclean...
X
Xsub_clobber::
X	@$(MAKE) subdirs TARGET=clobber VERB="Clobbering" FLAGS=
X	@echo "Back to $(CURRENT) for "clobber...
X
Xtag::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo "Tagging" "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS)  tag); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		echo "Making "Makefiles" in $(DIR)$$i..."; \
X		(cd $$i || exit 1; \
X		if test ! -f Makefile; then /bin/sh Makefile.SH; fi; \
X		$(MAKE) $(MFLAGS) Makefiles) \
X	done
X
XMakefiles.SH:: Makefile.SH
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		case "$(DIR)$$i/" in \
X		*/*/*/*/) newtop=../../../..;; \
X		*/*/*/) newtop=../../..;; \
X		*/*/) newtop=../..;; \
X		*/) newtop=..;; \
X		esac; \
X		case "$(TOP)" in \
X		/*) newtop="$(TOP)" ;; \
X		esac; \
X		echo "Making Makefiles.SH in $(DIR)$$i..."; \
X		(cd $$i || exit 1; $(MAKE) $(MFLAGS) -f ../Makefile \
X		Makefile TOP=$$newtop CURRENT=$(DIR)$$i;\
X		$(MAKE) $(MFLAGS) Makefiles.SH) \
X	done
X
Xall::
X	@$(MAKE) subdirs TARGET=all VERB="Making all" FLAGS=
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5457 -ne `wc -c <'agent/files/Makefile.SH'`; then
    echo shar: \"'agent/files/Makefile.SH'\" unpacked with wrong size!
  fi
  chmod +x 'agent/files/Makefile.SH'
  # end of 'agent/files/Makefile.SH'
fi
if test -f 'agent/filter/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/filter/Makefile.SH'\"
else
  echo shar: Extracting \"'agent/filter/Makefile.SH'\" \(5055 characters\)
  sed "s/^X//" >'agent/filter/Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL14]
X: $X-Id: Jmake.tmpl,v 3.0.1.1 1993/08/20 07:36:36 ram Exp ram $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		echo "Can't find config.sh."; exit 1
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=agent/filter
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = ../..
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ../../install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCC = $cc
XCTAGS = ctags
XJCFLAGS = \$(CFLAGS) $optimize $ccflags $large
XJLDFLAGS = \$(LDFLAGS) $optimize $ldflags
XLIBS = $libs
XMAKE = make
XMKDEP = $mkdep \$(DPFLAGS) --
XMV = $mv
XPRIVLIB = $installprivlib
XRM = $rm -f
XSED = $sed
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSOURCES =  \$(SRC)
XOBJECTS =  \$(OBJ)
X
X########################################################################
X# New suffixes and associated building rules -- edit with care
X
X.c.o:
X	\$(CC) -c \$(JCFLAGS) \$<
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 3.0 1993/08/18 12:04:14 ram Exp ram $
X
X########################################################################
X# Force 'make depend' to be performed first -- do not edit
X
X.FORCE_DEPEND::
X
Xall:: .FORCE_DEPEND
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.9 92/07/14 18:41:10 ram Exp $
X#
X#  Copyright (c) 1990-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic License,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic License; a copy of which may be found at the root
X#  of the source tree for mailagent 3.0.
X#
X# $X-Log$
X
X# Files used to build the application
XSRC = environ.c hash.c io.c lock.c logfile.c main.c misc.c msg.c parser.c \
X	user.c
X
X# Derived object file names
XOBJ = \
X	environ.o \
X	hash.o \
X	io.o \
X	lock.o \
X	logfile.o \
X	main.o \
X	misc.o \
X	msg.o \
X	parser.o \
X	user.o 
X
X# File config.h is in the top-level directory
XCFLAGS = -I$(TOP)
XDPFLAGS = -I$(TOP)
X
Xdepend:: ../../mkdep
X
X../../mkdep:
X	@echo "You have to run Configure in $(TOP) first."; exit 1
X
Xdepend::
X	($(SED) '/^# DO NOT DELETE/q' Makefile && \
X	$(MKDEP) $(SOURCES) | \
X	$(SED) 's/: \.\//: /; /\/usr\/include/d' \
X	) > Makefile.new
X	cp Makefile Makefile.bak
X	cp Makefile.new Makefile
X	$(RM) Makefile.new
X
Xall:: filter
X
Xlocal_realclean::
X	$(RM) filter
X
Xfilter: $(OBJ)
X	$(RM) $@
X	if test -f $@; then $(MV) $@ $@~; else exit 0; fi
X	$(CC) -o $@ $(OBJ) $(JLDFLAGS) $(LIBS)
X
Xinstall:: filter
X	$(INSTALL) -c -s -m 555  filter  $(PRIVLIB)
X
Xdeinstall::
X	$(RM)  $(PRIVLIB)/filter
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: local_clean
Xrealclean: local_realclean
Xclobber: local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X
Xlocal_clobber:: local_realclean
X	$(RM) Makefile config.sh
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Empty rules for directories with no sub-directories -- do not edit
X
Xinstall::
X	@echo "install in $(CURRENT) done."
X
Xdeinstall::
X	@echo "deinstall in $(CURRENT) done."
X
Xinstall.man::
X	@echo "install.man in $(CURRENT) done."
X
Xdeinstall.man::
X	@echo "deinstall.man in $(CURRENT) done."
X
XMakefiles::
X
XMakefiles.SH::
X
X########################################################################
X# Dependencies generated by make depend
X# DO NOT DELETE THIS LINE -- make depend relies on it
X
X# Put nothing here or make depend will gobble it up
X.FORCE_DEPEND::
X	@echo "You must run 'make depend' in $(TOP) first."; exit 1
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5055 -ne `wc -c <'agent/filter/Makefile.SH'`; then
    echo shar: \"'agent/filter/Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'agent/filter/Makefile.SH'
fi
if test -f 'agent/filter/lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/filter/lock.c'\"
else
  echo shar: Extracting \"'agent/filter/lock.c'\" \(3106 characters\)
  sed "s/^X//" >'agent/filter/lock.c' <<'END_OF_FILE'
X/*
X
X #        ####    ####   #    #           ####
X #       #    #  #    #  #   #           #    #
X #       #    #  #       ####            #
X #       #    #  #       #  #     ###    #
X #       #    #  #    #  #   #    ###    #    #
X ######   ####    ####   #    #   ###     ####
X
X	Lock file handling.
X*/
X
X/*
X * $Id: lock.c,v 3.0 1993/11/29 13:48:12 ram Exp ram $
X *
X *  Copyright (c) 1990-1993, Raphael Manfredi
X *  
X *  You may redistribute only under the terms of the Artistic License,
X *  as specified in the README file that comes with the distribution.
X *  You may reuse parts of this distribution only within the terms of
X *  that same Artistic License; a copy of which may be found at the root
X *  of the source tree for mailagent 3.0.
X *
X * $Log: lock.c,v $
X * Revision 3.0  1993/11/29  13:48:12  ram
X * Baseline for mailagent 3.0 netwide release.
X *
X */
X
X#include "config.h"
X#include "portable.h"
X#include <errno.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#ifdef I_FCNTL
X#include <fcntl.h>
X#else
X#include <sys/fcntl.h>
X#endif
X#ifdef I_SYS_FILE
X#include <sys/file.h>
X#endif
X#include "confmagic.h"
X
X#define MAX_STRING	2048		/* Max string length */
X#define MAX_TIME	3600		/* One hour */
X
Xprivate char lockfile[MAX_STRING];		/* Location of lock file */
Xprivate int locked = 0;					/* Did we lock successfully? */
X
Xprivate void check_lock();				/* Make sure lockfile is not too old */
X
Xextern int errno;						/* System error status */
Xextern Time_t time();					/* Current time */
X
Xpublic int filter_lock(dir)
Xchar *dir;						/* Where lockfile should be written */
X{
X	/* Note: this locking is not completly safe w.r.t. race conditions, but the
X	 * mailagent will do its own locking checks in a rather safe way.
X	 * Return 0 if locking succeeds, -1 otherwise.
X	 */
X
X	int fd;
X
X	sprintf(lockfile, "%s/filter.lock", dir);
X	check_lock(lockfile);
X	if (-1 == (fd = open(lockfile, O_CREAT | O_EXCL, 0))) {
X		if (errno != EEXIST)
X			add_log(1, "SYSERR open: %m (%e)");
X		return -1;
X	}
X	locked = 1;					/* We did lock successfully */
X	close(fd);					/* Close dummy file descriptor */
X
X	return 0;
X}
X
Xpublic void release_lock()
X{
X	if (locked && -1 == unlink(lockfile)) {
X		add_log(1, "SYSERR unlink: %m (%e)");
X		add_log(4, "WARNING could not remove lockfile %s", lockfile);
X	}
X	locked = 0;
X}
X
Xpublic int is_locked()
X{
X	return locked;			/* Do we have a lock file active or not? */
X}
X
Xprivate void check_lock(file)
Xchar *file;
X{
X	/* Make sure the lock file is not older than MAX_TIME seconds, otherwise
X	 * unlink it (something must have gone wrong).
X	 */
X
X	struct stat buf;
X
X	if (-1 == stat(file, &buf)) {		/* Stat failed */
X		if (errno == ENOENT)			/* File does not exist */
X			return;
X		add_log(1, "SYSERR stat: %m (%e)");
X		add_log(2, "could not check lockfile %s", file);
X		return;
X	}
X
X	if (time((Time_t *) 0) - buf.st_mtime > MAX_TIME) {
X		if (-1 == unlink(lockfile)) {
X			add_log(1, "SYSERR unlink: %m (%e)");
X			add_log(4, "WARNING could not remove old lock %s", lockfile);
X		} else
X			add_log(6, "UNLOCKED filter (lock older than 1 hour)");
X	} else
X		add_log(16, "lockfile for filter is recent");
X}
X
END_OF_FILE
  if test 3106 -ne `wc -c <'agent/filter/lock.c'`; then
    echo shar: \"'agent/filter/lock.c'\" unpacked with wrong size!
  fi
  # end of 'agent/filter/lock.c'
fi
if test -f 'agent/filter/logfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/filter/logfile.c'\"
else
  echo shar: Extracting \"'agent/filter/logfile.c'\" \(5979 characters\)
  sed "s/^X//" >'agent/filter/logfile.c' <<'END_OF_FILE'
X/*
X
X #        ####    ####   ######     #    #       ######           ####
X #       #    #  #    #  #          #    #       #               #    #
X #       #    #  #       #####      #    #       #####           #
X #       #    #  #  ###  #          #    #       #        ###    #
X #       #    #  #    #  #          #    #       #        ###    #    #
X ######   ####    ####   #          #    ######  ######   ###     ####
X
X	Handles logging facilities.
X*/
X
X/*
X * $Id: logfile.c,v 3.0 1993/11/29 13:48:14 ram Exp ram $
X *
X *  Copyright (c) 1990-1993, Raphael Manfredi
X *  
X *  You may redistribute only under the terms of the Artistic License,
X *  as specified in the README file that comes with the distribution.
X *  You may reuse parts of this distribution only within the terms of
X *  that same Artistic License; a copy of which may be found at the root
X *  of the source tree for mailagent 3.0.
X *
X * $Log: logfile.c,v $
X * Revision 3.0  1993/11/29  13:48:14  ram
X * Baseline for mailagent 3.0 netwide release.
X *
X */
X
X#include "config.h"
X#include "portable.h"
X#include <stdio.h>
X#include <sys/types.h>
X
X#ifdef I_TIME
X# include <time.h>
X#endif
X#ifdef I_SYS_TIME
X# include <sys/time.h>
X#endif
X#ifdef I_SYS_TIME_KERNEL
X# define KERNEL
X# include <sys/time.h>
X# undef KERNEL
X#endif
X#include "confmagic.h"
X
X#define MAX_STRING	1024			/* Maximum length for logging string */
X
Xprivate FILE *logfile = (FILE *) 0;	/* File pointer used for logging */
Xshared int loglvl = 20;				/* Logging level */
Xprivate char *logname;				/* Name of the logfile in use */
Xprivate void expand();				/* Run the %m %e expansion on the string */
Xprivate int add_error();			/* Prints description of error in errno */
Xprivate int add_errcode();			/* Print the symbolic error name */
X
Xpublic char *progname = "ram";	/* Program name */
Xpublic Pid_t progpid = 0;		/* Program PID */
X
Xextern Time_t time();			/* Time in seconds since the Epoch */
Xextern char *malloc();			/* Memory allocation */
Xextern char *strsave();			/* Save string in memory */
Xextern int errno;				/* System error report variable */
X
X/* VARARGS2 */
Xpublic void add_log(level, format, arg1, arg2, arg3, arg4, arg5)
Xint level;
Xchar *format;
Xlong arg1, arg2, arg3, arg4, arg5;	/* Use long instead of int for 64 bits */
X{
X	/* Add logging informations at specified level. Note that the arguments are
X	 * declared as 'int', but it should work fine, even when we give doubles,
X	 * because they will be pased "as is" to fprintf. Maybe I should use
X	 * vfprintf when it is available--RAM.
X	 * The only magic string substitution which occurs is the '%m', which is
X	 * replaced by the error message, as given by errno and '%e' which gives
X	 * the symbolic name of the error (if available, otherwise the number).
X	 * The log file must have been opened with open_log() before add_log calls.
X	 */
X
X	struct tm *ct;				/* Current time (pointer to static data) */
X	Time_t clock;				/* Number of seconds since the Epoch */
X	char buffer[MAX_STRING];	/* Buffer which holds the expanded %m string */
X
X	if (loglvl < level)			/* Logging level is not high enough */
X		return;
X
X	if (logfile == (FILE *) 0)	/* Logfile not opened for whatever reason */
X		return;
X
X	clock = time((Time_t *) 0);	/* Number of seconds */
X	ct = localtime(&clock);		/* Get local time from amount of seconds */
X	expand(format, buffer);		/* Expansion of %m and %e into buffer */
X
X	fprintf(logfile, "%d/%.2d/%.2d %.2d:%.2d:%.2d %s[%d]: ",
X		ct->tm_year, ct->tm_mon + 1, ct->tm_mday,
X		ct->tm_hour, ct->tm_min, ct->tm_sec,
X		progname, progpid);
X
X	fprintf(logfile, buffer, arg1, arg2, arg3, arg4, arg5);
X	putc('\n', logfile);
X	fflush(logfile);
X}
X
Xpublic int open_log(name)
Xchar *name;
X{
X	/* Open log file 'name' for logging. If a previous log file was opened,
X	 * it is closed before. The routine returns -1 in case of error.
X	 */
X	
X	if (logfile != (FILE *) 0)
X		fclose(logfile);
X	
X	logfile = fopen(name, "a");		/* Append to existing file */
X	logname = strsave(name);		/* Save file name */
X
X	if (logfile == (FILE *) 0)
X		return -1;
X	
X	return 0;
X}
X
Xpublic void close_log()
X{
X	/* Close log file */
X
X	if (logfile != (FILE *) 0)
X		fclose(logfile);
X
X	logfile = (FILE *) 0;
X}
X
Xpublic void set_loglvl(level)
Xint level;
X{
X	/* Set logging level to 'level' */
X
X	loglvl = level;
X}
X
Xprivate void expand(from, to)
Xchar *from;
Xchar *to;
X{
X	/* The string held in 'from' is copied into 'to' and every '%m' is expanded
X	 * into the error message deduced from the value of errno.
X	 */
X
X	int len;							/* Length of substituted text */
X
X	while (*to++ = *from)
X		if (*from++ == '%')
X			switch (*from) {
X			case 'm':					/* %m is the English description */
X				len = add_error(to - 1);
X				to += len - 1;
X				from++;
X				break;
X			case 'e':					/* %e is the symbolic error code */
X				len = add_errcode(to - 1);
X				to += len - 1;
X				from++;
X				break;
X			}
X}
X
Xprivate int add_error(where)
Xchar *where;
X{
X	/* Prints a description of the error code held in 'errno' into 'where' if
X	 * it is available, otherwise simply print the error code number.
X	 */
X
X#ifdef HAS_SYS_ERRLIST
X	extern int sys_nerr;					/* Size of sys_errlist[] */
X	extern char *sys_errlist[];				/* Maps error code to string */
X#endif
X
X#ifdef HAS_STRERROR
X	sprintf(where, "%s", strerror(errno));
X#else
X#ifdef HAS_SYS_ERRLIST
X	sprintf(where, "%s", strerror(errno));	/* Macro defined by Configure */
X#else
X	sprintf(where, "error #%d", errno);
X#endif
X#endif
X
X	return strlen(where);
X}
X
Xprivate int add_errcode(where)
Xchar *where;
X{
X	/* Prints the symbolic description of the error code heldin in 'errno' into
X	 * 'where' if possible. Otherwise, prints the error number.
X	 */
X	
X#ifdef HAS_SYS_ERRNOLIST
X	extern int sys_nerrno;					/* Size of sys_errnolist[] */
X	extern char *sys_errnolist[];			/* Error code to symbolic name */
X#endif
X
X#ifdef HAS_SYS_ERRNOLIST
X	if (errno < 0 || errno >= sys_nerrno)
X		sprintf(where, "UNKNOWN");
X	else
X		sprintf(where, "%s", sys_errnolist[errno]);
X#else
X		sprintf(where, "%d", errno);
X#endif
X
X	return strlen(where);
X}
X
END_OF_FILE
  if test 5979 -ne `wc -c <'agent/filter/logfile.c'`; then
    echo shar: \"'agent/filter/logfile.c'\" unpacked with wrong size!
  fi
  # end of 'agent/filter/logfile.c'
fi
if test -f 'agent/man/mailhelp.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/man/mailhelp.SH'\"
else
  echo shar: Extracting \"'agent/man/mailhelp.SH'\" \(5834 characters\)
  sed "s/^X//" >'agent/man/mailhelp.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		echo "Can't find config.sh."; exit 1
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting agent/man/mailhelp.$manext (with variable substitutions)"
X$rm -f mailhelp.$manext
X$spitshell >mailhelp.$manext <<!GROK!THIS!
X.TH MAILHELP $manext ram
X''' @(#) Manual page for mailagent's commands -- (c) ram February 1991
X'''
X''' $Id: mailhelp.SH,v 3.0 1993/11/29 13:48:29 ram Exp ram $
X'''
X'''  Copyright (c) 1990-1993, Raphael Manfredi
X'''  
X'''  You may redistribute only under the terms of the Artistic License,
X'''  as specified in the README file that comes with the distribution.
X'''  You may reuse parts of this distribution only within the terms of
X'''  that same Artistic License; a copy of which may be found at the root
X'''  of the source tree for mailagent 3.0.
X'''
X''' $Log: mailhelp.SH,v $
X''' Revision 3.0  1993/11/29  13:48:29  ram
X''' Baseline for mailagent 3.0 netwide release.
X'''
X.SH NAME
Xmaildist, mailhelp, maillist, mailpatch \- mailagent's commands
X.SH SYNOPSIS
X\fBmaildist\fR \fIaddress\fR \fIsystem\fR [ \fIversion\fR ]
X.br
X\fBmailhelp\fR [ \fIaddress\fR ]
X.br
X\fBmaillist\fR [ \fIaddress\fR ]
X.br
X\fBmailpatch\fR \fIaddress\fR \fIsystem\fR \fIversion\fR \fIpatchlist\fR
X.SH DESCRIPTION
XThese commands are not intended to be run directly by a user. They may
Xappear in any mail whose subject is set to \fICommand\fR. Such a mail
Xwill be processed by the \fImailagent\fR(1), which will extract all lines
Xbeginning with \fI@SH\fR, followed by one of the above commands. The
Xmailagent first sets environment variables that will be used by every
Xcommands.
X.PP
X.I Maildist
Xis used to mail a whole distribution to the given address. The version
Xnumber may be ommitted if the system has no version specified !!
X.I Maildist
Xlooks for the \fISpool/distribs\fR file to find where the distribution
Xis located. If it has been archived, the file name extension is used
Xto guess how the archive will be restored:
X.sp
X.PD 0
X.TP 10
X.B .cpio
Xarchive is a \fIcpio\fR archive
X.TP
X.B .tar
Xarchive is in \fItar\fR format
X.TP
X.B .cpio.Z
Xcompressed \fIcpio\fR archive
X.TP
X.B .tar.Z
Xcompressed \fItar\fR archive
X.PD
X.PP
XNote that on file systems with short file names, the final \fB.Z\fR
Xextension could be dropped. Therefore, compressed archives must be
Xexplicitely stated in the \fISpool/distribs\fR file.
X.PP
XOnce the directory is found (or extracted), \fImaildist\fR looks
Xfor a \fI.package\fR file. If one is found, then it is assumed this
Xdistribution is under control of the dist 3.0 package, and the \fImakedist\fR
Xcommmand is called to actually mirror the source tree (makedist being part of
Xdist 3.0).
X.PP
XOtherwise, it looks
Xfor a \fIMANIFEST\fR file. If it finds one,
Xonly the files listed therein will be sent. Otherwise,
Xall the files will be sent, excepted the binary executables and object
Xfiles, the RCS sub-directories or RCS files, the private \fIU\fR
Xsubdirectory and the \fI.package\fR file, any \fIcore\fR file or files
Xin a \fIbugs\fR subdirectory.
X.PP
XThen, the following algorithm is used: if no RCS file is found, the
Xfile is sent as-is. Otherwise, we look for a defined 'lastpat' symbol.
XIf it is found, the corresponding revision is checked-out and sent.
XOtherwise, the last-revision on the default branch is exctracted,
Xprovided that the corresponding working file is not found.
X.PP
XThe \fImaildist\fR command will not work if the system is tagged as
Xan old one (with an \fIo\fR in the patches column of the \fIdistribs\fR
Xfile). A message will be sent back to the user, explaining that only
Xpatches are available.
X.PP
X.I Mailhelp
Xsends help to the address (if ommitted, the return path of the mail
Xis used). The help text is found in \fISpool/agenthelp\fR. It should
Xhave been correctly set in the installation procedure, as explained
Xin the \fImailagent\fR($manext) manual page.
X.PP
X.I Maillist
Xsends the list of available distributions, with current patchlevels
Xif necessary. The \fISpool/distribs\fR and \fISpool/proglist\fR files
Xare both used to build the list.
X.PP
X.I Mailpatch
Xsends one or more patches for a maintained distribution. The directory
Xor the archive is found by scanning \fISpool/distribs\fR. The \fIbugs\fR
Xsub-directory must then hold the available patches. The patches may
Xbe stored in compressed form (with the ending \fI.Z\fR), as
X.I mailpatch
Xknows about them and will uncompress the patch before sending.
X.PP
XPatches for old systems are kept in a separate directory, either in normal
Xor in compressed form. If the version number of the old system is \fIx.y\fR,
Xthen the directory must be named \fIbugs-x.y\fR and placed in the root
Xdirectory of the system, just like \fIbugs\fR is.
X.PP
XWhenever the user asks for an old system, \fImailpatch\fR inserts a little
Xnote giving the latest version number for that system.
X.SH NOTE
XFor a more accurate description of these commands (user's point of vue),
Xyou may want to have a look at the help file or send help to yourself
Xusing the \fImailhelp\fR command.
X.SH FILES
X.PD 0
X.TP 20
X~/.mailagent
Xconfiguration file for mailagent.
X.TP
X$privlib
Xdirectory holding templates and samples.
X.TP
XSpool/agenthelp
Xhelp file
X.TP
XSpool/distribs
Xdistribution list
X.TP
XSpool/proglist
Xcomments for available distributions
X.TP
XSpool/plsave
Xrecords patchlevel of archived distributions
X.TP
XLog/agentlog
Xmailagent's log file
X.PD
X.SH BUGS
XThe \fIproglist\fR file ought to make a distinction between different
Xversions of a same system.
X.SH AUTHOR
XRaphael Manfredi <ram@acri.fr>
X.SH "SEE ALSO"
Xmailagent($manext).
X!GROK!THIS!
Xchmod 444 mailhelp.$manext
END_OF_FILE
  if test 5834 -ne `wc -c <'agent/man/mailhelp.SH'`; then
    echo shar: \"'agent/man/mailhelp.SH'\" unpacked with wrong size!
  fi
  # end of 'agent/man/mailhelp.SH'
fi
if test -f 'agent/pl/emergency.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/pl/emergency.pl'\"
else
  echo shar: Extracting \"'agent/pl/emergency.pl'\" \(5547 characters\)
  sed "s/^X//" >'agent/pl/emergency.pl' <<'END_OF_FILE'
X;# $Id: emergency.pl,v 3.0 1993/11/29 13:48:41 ram Exp ram $
X;#
X;#  Copyright (c) 1990-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic License,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic License; a copy of which may be found at the root
X;#  of the source tree for mailagent 3.0.
X;#
X;# $Log: emergency.pl,v $
X;# Revision 3.0  1993/11/29  13:48:41  ram
X;# Baseline for mailagent 3.0 netwide release.
X;#
X;# 
X#
X# Emergency situation routines
X#
X
X# Emergency signal was caught
Xsub emergency {
X	local($sig) = @_;			# First argument is signal name
X	if ($has_option) {			# Mailagent was invoked "manually"
X		&resync;				# Resynchronize waiting file if necessary
X		exit 1;
X	}
X	&fatal("trapped SIG$sig");
X}
X
X# In case something got wrong
Xsub fatal {
X	local($reason) = shift;		# Why did we get here ?
X	# Make sure the lock file does not last. We don't need any lock now, as
X	# we are going to die real soon anyway.
X	unlink $lockfile if $locked;
X	# Assume the whole message has not been read yet
X	$fd = STDIN;				# Default input
X	if ($file_name ne '') {
X		$Header{'All'} = '';	# We're about to re-read the whole message
X		open(MSG, $file_name);	# Ignore errors
X		$fd = MSG;
X	}
X	unless (-t $fd) {			# Do not get mail if connected to a tty
X		while (<$fd>) {
X			$Header{'All'} .= $_;
X		}
X	}
X	# It can happen that we get here before configuration file was read
X	if (defined $loglvl) {
X		&add_log("FATAL $reason") if $loglvl;
X		-t STDIN && print STDERR "$prog_name: $reason\n";
X	}
X	# Try an emergency save, if mail is not empty
X	if ($Header{'All'} ne '' && 0 == &emergency_save) {
X		# The stderr should be redirected to some file
X		$file_name =~ s|.*/(.*)|$1|;	# Keep only basename
X		$file_name = "<stdin>" if $file_name eq '';
X		print STDERR "**** $file_name not processed ($reason) ****\n";
X		print STDERR $Header{'All'};
X		($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
X			localtime(time);
X		$date = sprintf("%.2d/%.2d/%.2d %.2d:%.2d:%.2d",
X			$year,++$mon,$mday,$hour,$min,$sec);
X		print STDERR "---- $date ----\n";
X	}
X	&resync;			# Resynchronize waiting file if necessary
X	# Give an error exit status to filter
X	exit 1;
X}
X
X# Emergency saving of message held in $Header{'All'}. If the 'emergdir'
X# configuration parameter in ~/.mailagent is set to an existing directory, the
X# first saving attempt is made there (each mail in a separate file).
Xsub emergency_save {
X	return 0 unless (defined $cf'home);	# ~/.mailagent not processed
X	return 1 if -d "$cf'emergdir" && &dump_mbox("$cf'emergdir/ma$$");
X	return 1 if &dump_mbox(&mailbox_name);
X	return 1 if &dump_mbox("$cf'home/mbox.urgent");
X	return 1 if &dump_mbox("$cf'home/mbox.urg$$");
X	return 1 if &dump_mbox("/usr/spool/uucppublic/mbox.$cf'user");
X	return 1 if &dump_mbox("/var/spool/uucppublic/mbox.$cf'user");
X	return 1 if &dump_mbox("/usr/tmp/mbox.$cf'user");
X	return 1 if &dump_mbox("/var/tmp/mbox.$cf'user");
X	return 1 if &dump_mbox("/tmp/mbox.$cf'user");
X	&add_log("ERROR unable to save mail in any emergency mailbox") if $loglvl;
X	0;
X}
X
X# Dump $Header{'All'} in emergency mailbox
Xsub dump_mbox {
X	local($mbox) = shift(@_);
X	local($ok) = 0;						# printing status
X	local($existed) = 0;				# did the mailbox exist already ?
X	local($old_size);					# Size the old mailbox had
X	local($new_size);					# Size of the mailbox after saving
X	local($should);						# Size it should have if saved properly
X	$existed = 1 if -f $mbox;
X	$old_size = $existed ? -s $mbox : 0;
X	if (open(MBOX, ">>$mbox")) {
X		(print MBOX $Header{'All'}) && ($ok = 1);
X		print MBOX "\n";				# allow parsing by other mail tools
X		close(MBOX) || ($ok = 0);
X		$new_size = -s $mbox;			# Stat new mbox file, grab its size
X		$should = $old_size +			# New ideal size is old size plus...
X			length($Header{'All'}) +	# ... the length of the message saved
X			1;							# ... the trailing new-line
X		if ($should != $new_size) {
X			&add_log("ERROR $mbox has $new_size bytes (should have $should)")
X				if $loglvl;
X			$ok = 0;					# Saving failed, sorry...
X		}
X		if ($ok) {
X			&add_log("DUMPED in $mbox") if $loglvl > 5;
X			return 1;
X		} else {
X			if ($existed) {
X				&add_log("WARNING imcomplete mail appended to $mbox")
X					if $loglvl > 5;
X			} else {
X				unlink "$mbox";			# remove incomplete file
X			}
X		}
X	}
X	0;
X}
X
X# Resynchronizes the waiting file if necessary (i.e if it exists and %waiting
X# is not an empty array).
Xsub resync {
X	local(@key) = keys %waiting;	# Keys of H table are file names
X	local($ok) = 1;					# Assume resync is ok
X	local($printed) = 0;			# Nothing printed yet
X	return if $#key < 0 || "$cf'queue" eq '' || ! -f "$cf'queue/$agent_wait";
X	&add_log("resynchronizing the waiting file") if $loglvl > 11;
X	if (open(WAITING, ">$cf'queue/$agent_wait~")) {
X		foreach (@key) {
X			if ($waiting{$_}) {
X				print WAITING "$_\n" || ($ok = 0);
X				$printed = 1;
X			}
X		}
X		close(WAITING) || ($ok = 0);
X		if ($printed) {
X			if (!$ok) {
X				&add_log("ERROR could not update waiting file") if $loglvl;
X				unlink "$cf'queue/$agent_wait~";
X			} elsif (rename("$cf'queue/$agent_wait~","$cf'queue/$agent_wait")) {
X				&add_log("waiting file has been updated") if $loglvl > 18;
X			} else {
X				&add_log("ERROR cannot rename waiting file") if $loglvl;
X			}
X		} else {
X			unlink "$cf'queue/$agent_wait";
X			unlink "$cf'queue/$agent_wait~";
X			&add_log ("removed waiting file") if $loglvl > 18;
X		}
X	} else {
X		&add_log("ERROR unable to write new waiting file") if $loglvl;
X	}
X}
X
END_OF_FILE
  if test 5547 -ne `wc -c <'agent/pl/emergency.pl'`; then
    echo shar: \"'agent/pl/emergency.pl'\" unpacked with wrong size!
  fi
  # end of 'agent/pl/emergency.pl'
fi
if test -f 'agent/pl/eval.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/pl/eval.pl'\"
else
  echo shar: Extracting \"'agent/pl/eval.pl'\" \(6419 characters\)
  sed "s/^X//" >'agent/pl/eval.pl' <<'END_OF_FILE'
X;# $Id: eval.pl,v 3.0 1993/11/29 13:48:42 ram Exp ram $
X;#
X;#  Copyright (c) 1990-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic License,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic License; a copy of which may be found at the root
X;#  of the source tree for mailagent 3.0.
X;#
X;# $Log: eval.pl,v $
X;# Revision 3.0  1993/11/29  13:48:42  ram
X;# Baseline for mailagent 3.0 netwide release.
X;#
X;# 
X#
X# The built-in expression interpreter
X#
X
X# Initialize the interpreter
Xsub init_interpreter {
X	do set_priorities();	# Fill in %Priority
X	do set_functions();		# Fill in %Function
X	$macro_T = "the Epoch";	# Default value for %T macro substitution
X}
X
X# Priorities for operators -- magic numbers :-)
X# An operator with higher priority will evaluate before another with a lower
X# one. For instance, given the priorities listed hereinafter, a && b == c
X# would evaluate as a && (b == c).
Xsub set_priorities {
X	$Priority{'&&'} = 4;
X	$Priority{'||'} = 3;
X	$Priority{'>='} = 6;
X	$Priority{'<='} = 6;
X	$Priority{'<'}  = 6;
X	$Priority{'>'}  = 6;
X	$Priority{'=='} = 6;
X	$Priority{'!='} = 6;
X	$Priority{'='}  = 6;
X	$Priority{'/='} = 6;
X}
X
X# Perl functions handling operators
Xsub set_functions {
X	$Function{'&&'} = 'f_and';			# Boolean AND
X	$Function{'||'} = 'f_or';			# Boolean OR
X	$Function{'>='} = 'f_ge';			# Greater or equal
X	$Function{'<='} = 'f_le';			# Lesser or equal
X	$Function{'<'}  = 'f_lt';			# Lesser than
X	$Function{'>'}  = 'f_gt';			# Greader than
X	$Function{'=='} = 'f_eq';			# Equality
X	$Function{'!='} = 'f_ne';			# Difference (not equality)
X	$Function{'='}  = 'f_match';		# Pattern matching
X	$Function{'/='} = 'f_nomatch';		# Pattern matching (no match)
X}
X
X# Print error messages -- asssumes $unit and $. correctly set.
Xsub error {
X	do add_log("ERROR @_") if $loglvl > 1;
X}
X
X# Add a value on the stack, modified by all the monadic operators.
X# We use the locals @val and @mono from eval_expr.
Xsub push_val {
X	local($val) = shift(@_);
X	while ($#mono >= 0) {
X		# Cheat... the only monadic operator is '!'.
X		pop(@mono);
X		$val = !$val;
X	}
X	push(@val, $val);
X}
X
X# Execute a stacked operation, leave result in stack.
X# We use the locals @val and @op from eval_expr.
X# If the value stack holds only one operand, do nothing.
Xsub execute {
X	return unless $#val > 0;
X	local($op) = pop(@op);			# The operator
X	local($val2) = pop(@val);		# Right value in algebraic notation
X	local($val1) = pop(@val);		# Left value in algebraic notation
X	local($func) = $Function{$op};	# Function to be called
X	do macros_subst(*val1);			# Expand macros
X	do macros_subst(*val2);
X	push(@val, eval("do $func($val1, $val2)") ? 1: 0);
X}
X
X# Given an operator, either we add it in the stack @op, because its
X# priority is lower than the one on top of the stack, or we first execute
X# the stacked operations until we reach the end of stack or an operand
X# whose priority is lower than ours.
X# We use the locals @val and @op from eval_expr.
Xsub update_stack {
X	local($op) = shift(@_);		# Operator
X	if (!$Priority{$op}) {
X		do error("illegal operator $op");
X		return;
X	} else {
X		if ($#val < 0) {
X			do error("missing first operand for '$op' (diadic operator)");
X			return;
X		}
X		# Because of a bug in perl 4.0 PL19, I'm using a loop construct
X		# instead of a while() modifier.
X		while (
X			$Priority{$op[$#op]} > $Priority{$op}	# Higher priority op
X			&& $#val > 0							# At least 2 values
X		) {
X			do execute();	# Execute an higer priority stacked operation
X		}
X		push(@op, $op);		# Everything at higher priority has been executed
X	}
X}
X
X# This is the heart of our little interpreter. Here, we evaluate
X# a logical expression and return its value.
Xsub eval_expr {
X	local(*expr) = shift(@_);	# Expression to parse
X	local(@val) = ();			# Stack of values
X	local(@op) = ();			# Stack of diadic operators
X	local(@mono) =();			# Stack of monadic operators
X	local($tmp);
X	$_ = $expr;
X	while (1) {
X		s/^\s+//;				# Remove spaces between words
X		# A perl statement <<command>>
X		if (s/^<<//) {
X			if (s/^(.*)>>//) {
X				do push_val((system
X					('perl','-e', "if ($1) {exit 0;} else {exit 1;}"
X					))? 0 : 1);
X			} else {
X				do error("incomplete perl statement");
X			}
X		}
X		# A shell statement <command>
X		elsif (s/^<//) {
X			if (s/^(.*)>//) {
X				do push_val((system
X					("if $1 >/dev/null 2>&1; then exit 0; else exit 1; fi"
X					))? 0 : 1);
X			} else {
X				do error("incomplete shell statement");
X			}
X		}
X		# The '(' construct
X		elsif (s/^\(//) {
X			do push_val(do eval_expr(*_));
X			# A final '\' indicates an end of line
X			do error("missing final parenthesis") if !s/^\\//;
X		}
X		# Found a ')' or end of line
X		elsif (/^\)/ || /^$/) {
X			s/^\)/\\/;						# Signals: left parenthesis found
X			$expr = $_;						# Remove interpreted stuff
X			do execute() while $#val > 0;	# Executed stacked operations
X			while ($#op >= 0) {
X				$_ = pop(@op);
X				do error("missing second operand for '$_' (diadic operator)");
X			}
X			return $val[0];
X		}
X		# Diadic operators
X		elsif (s/^(\|\||&&|>=|<=|>|<|==|!=|=|\/=)//) {
X			do update_stack($1);
X		}
X		# Unary operator '!'
X		elsif (s/^!//) {
X			push(@mono,'!');
X		}
X		# Everything else is a value which stands for itself (atom)
X		elsif (s/^([\w'"%]+)//) {
X			do push_val($1);
X		}
X		# Syntax error
X		else {
X			print "Syntax error: remaining is >>>$_<<<\n";
X			$_ = "";
X		}
X	}
X}
X
X# Call eval_expr and check that everything is ok (e.g. the stack must be empty)
Xsub evaluate {
X	local($val);					# Value returned
X	local(*expr) = shift(@_);		# Expression to be parsed
X	while ($expr) {
X		$val = do eval_expr(*expr);		# Expression will be modified
X		print "extra closing parenthesis ignored.\n" if $expr =~ s/^\\\)*//;
X		$expr = $val . $expr if $expr ne '';
X	}
X	$val;
X}
X
X#
X# Boolean functions used by the interpreter. They all take two arguments
X# and return 0 if false and 1 if true.
X#
X
Xsub f_and { $_[0] && $_[1]; }		# Boolean AND
Xsub f_or { $_[0] || $_[1]; }		# Boolean OR
Xsub f_ge { $_[0] >= $_[1]; }		# Greater or equal
Xsub f_le { $_[0] <= $_[1]; }		# Lesser or equal
Xsub f_lt { $_[0] < $_[1]; }			# Lesser than
Xsub f_gt { $_[0] > $_[1]; }			# Greater than
Xsub f_eq { "$_[0]" eq "$_[1]"; }	# Equal
Xsub f_ne { "$_[0]" ne "$_[1]"; }	# Not equal
Xsub f_match { $_[0] =~ /$_[1]/; }	# Pattern matches
Xsub f_nomatch { $_[0] !~ /$_[1]/; }	# Pattern does not match
X
END_OF_FILE
  if test 6419 -ne `wc -c <'agent/pl/eval.pl'`; then
    echo shar: \"'agent/pl/eval.pl'\" unpacked with wrong size!
  fi
  # end of 'agent/pl/eval.pl'
fi
echo shar: End of archive 18 \(of 26\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    echo "Now run 'sh PACKNOTES', then read README and type Configure.'"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
