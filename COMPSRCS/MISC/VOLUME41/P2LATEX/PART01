Newsgroups: comp.sources.misc
From: torsten@diku.dk (Torsten Poulin Nielsen)
Subject: v41i083:  p2latex - Pascal to LaTeX v1.0, Part01/03
Message-ID: <csm-v41i083=p2latex.215324@sparky.Sterling.COM>
X-Md4-Signature: d2bc8437b8abca170c98b84e7bf02658
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 10 Jan 1994 03:54:58 GMT
Approved: kent@sparky.sterling.com

Submitted-by: torsten@diku.dk (Torsten Poulin Nielsen)
Posting-number: Volume 41, Issue 83
Archive-name: p2latex/part01
Environment: UNIX, AmigaDOS

P2LATEX is a tool for generating LaTeX sources from ISO Pascal
programs.  It recognizes all keywords, strings, and comments. These
recognized parts can be typeset in different fonts.

It is built on the work of others and makes liberal use of code
copyrighted by the Free Software Foundation and others. Thus, it is by
default subject to the GPL. Please refer to the file LICENSE for
details.

Even though p2latex was written on a machine running AmigaDOS, it is
fundamentally a Unix (or GNU :-) command. Its quite portable, though.

I have supplied Makefiles for Unix and AmigaDOS. The one for AmigaDOS
is for SAS/C v5.10b. Yes, I now that compiler is a bit outdated, but
it happens to be the one I have.

If you don't have flex, touch p2latex.c before you invoke make.

If you use Amiga gcc, you can build p2latex with the supplied Unix
Makefile if you have versions of Unix rm, mv, and BSD make installed.
They are shipped with newer versions of gcc; they are also available
on Aminet. While you're at it, make or get Amiga ports of all the Unix
commands you can lay your hands on. I did a port of the f2c Fortran to
C translator without changing the Makefile that way.

If you have any comments or suggestions, you can write to me at

Torsten Poulin
Banebrinken 99,2,-77
DK-2400 Copenhagen
Denmark

or use email: torsten@diku.dk

Have fun,
Torsten

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README p2latex.1 p2latex.c
# Wrapped by kent@sparky on Sun Jan  9 21:45:39 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1169 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XP2LATEX is built on the work of others and makes liberal use of code
Xcopyrighted by the Free Software Foundation and others. Thus, it is by
Xdefault subject to the GPL. Please refer to the file LICENSE for
Xdetails.
X
XEven though p2latex was written on a machine running AmigaDOS, it is
Xfundamentally a Unix (or GNU :-) command. Its quite portable, though.
X
XI have supplied Makefiles for Unix and AmigaDOS. The one for AmigaDOS
Xis for SAS/C v5.10b. Yes, I now that compiler is a bit outdated, but
Xit happens to be the one I have.
X
XIf you don't have flex, touch p2latex.c before you invoke make.
X
XIf you use Amiga gcc, you can build p2latex with the supplied Unix
XMakefile if you have versions of Unix rm, mv, and BSD make installed.
XThey are shipped with newer versions of gcc; they are also available
Xon Aminet. While you're at it, make or get Amiga ports of all the Unix
Xcommands you can lay your hands on. I did a port of the f2c Fortran to
XC translator without changing the Makefile that way.
X
XIf you have any comments or suggestions, you write to me at
X
XTorsten Poulin
XBanebrinken 99,2,-77
XDK-2400 Copenhagen
XDenmark
X
Xor use email: torsten@diku.dk
X
XHave fun,
XTorsten
END_OF_FILE
  if test 1169 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'p2latex.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'p2latex.1'\"
else
  echo shar: Extracting \"'p2latex.1'\" \(6241 characters\)
  sed "s/^X//" >'p2latex.1' <<'END_OF_FILE'
X.\"
X.\" p2latex.1 - the *roff document processor source for the p2latex manual
X.\"
X.\" This file is part of p2latex
X.\" Copyright (C) 1993 Torsten Poulin
X.\"
X.\" This program is free software; you can redistribute it and/or modify
X.\" it under the terms of the GNU General Public License as published by
X.\" the Free Software Foundation; either version 2 of the License , or
X.\" (at your option) any later version.
X.\"
X.\" This program is distributed in the hope that it will be useful,
X.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
X.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X.\" GNU General Public License for more details.
X.\"
X.\" You should have received a copy of the GNU General Public License
X.\" along with this program; see the file COPYING.  If not, write to
X.\" the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X.\"
X.\" You can contact the author by:
X.\" e-mail: torsten@diku.dk
X.\" snail-mail:
X.\"   Torsten Poulin
X.\"   Banebrinken 99, 2, 77
X.\"   DK-2400 Copenhagen NV
X.\"   Denmark
X.\" phone: +45 39663111
X.\"
X.\" $Id: p2latex.1,v 1.1 93/12/20 14:43:20 Torsten Exp $
X.\" $Log:	p2latex.1,v $
X.\" Revision 1.1  93/12/20  14:43:20  Torsten
X.\" Initial revision
X.\" 
X.\"
X.TH P2LATEX 1
X.SH NAME
Xp2latex \- a Pascal to LaTeX converter
X.SH SYNOPSIS
X.B p2latex
X[
X.I options
X] [
X.I file
X]
X.SH DESCRIPTION
X.B p2latex
Xis a tool for generating
X.I LaTeX
Xsources from
X.I ISO Pascal
Xprograms.  It recognizes all keywords, strings, and comments. These
Xrecognized parts can be typeset in different fonts.
X.B p2latex
Xcan generate complete
X.I LaTeX
Xfiles which can be passed directly through
X.BR latex (1)
Xor parts of
X.I LaTeX
Xfiles which can be included in other
X.I LaTeX
Xfiles (either manually or with the
X.B \\\\input
Xor
X.B \\\\include
Xcommands).
X.PP
XIf the
X.B {\-o,\-\-output}
Xoption is given, the output is written to the specified file. If the
X.B {\-p,\-\-pipe}
Xoption is given, the output is written to
X.I stdout
X(it is an error to use both options together). If none of these
Xoptions are used, the output is written to a file. If the input comes
Xfrom a file, the last component of that name with `.tex' appended is
Xused as the output filename.
X.SH OPTIONS
X.B p2latex
Xrecognizes the options described below. The long forms can, unless
Xdisabled by the person who installed
X.BR p2latex ,
Xalso be introduced by a `+' or `-' instead of the
X.B POSIX.2
Xcompliant `--'.
X.TP
X.B "\-c, \-\-complete\-file"
XThe output is enveloped in commands that produce a complete
X.I LaTeX
Xdocument.
X.TP
X.BI "\-e, \-\-end\-comment" " distance"
XThis changes the distance between the
X.I Pascal
Xkeyword
X.B end
X(optionally followed by `;' or `.') and a following comment.  Default
Xis four times the indentation step size (see the
X.B {\-i,\-\-indentation}
Xoption).
X.TP
X.B "\-f, \-\-fancy"
XThe output approximates the style used in Niklaus Wirth:
X.IR "Programs+Data Structures=Programs" .
X.TP
X.B "\-h, \-\-header"
XEach page of output has a header giving the input filename.
XThis option implies the
X.B {\-c,\-\-complete\-file}
Xoption.
X.TP
X.BI "\-i, \-\-indentation" " length"
XGives the amount of indentation for each leading blank (tabs are
Xconverted to blanks). Default is `0.5em'.
X.TP
X.B "\-n, \-\-no\-alignment"
XComments belonging to statements are aligned to the right margin by
Xdefault. You can turn off this behaviour with this option.
X.TP
X.BI "\-o, \-\-output" " file"
XThe output is written on
X.IR file .
X.TP
X.B "\-p, \-\-pipe"
XThe output goes to
X.IR stdout .
X.TP
X.BI "\-s, \-\-font\-size" " fontsize"
XThe
X.I LaTeX
Xsource is set in
X.IR fontsize pt.
XDefault is `10'. This option is meaningless if not used in combination
Xwith
X.BR {\-c,\-\-complete\-file} .
X.TP
X.BI "\-C, \-\-comment\-font" " font"
XThe comments are set in the given
X.IR font .
XDefault is `it'.
X.TP
X.BI "\-H, \-\-header\-font" " font"
XThe headers are set in the given
X.IR font .
XDefault is `sl'.
X.TP
X.BI "\-I, \-\-identifier\-font" " font"
XThe identifiers are set in the given
X.IR font .
XDefault is `it'.
X.TP
X.BI "\-K, \-\-keyword\-font" " font"
XThe keywords are set in the given
X.IR font .
XDefault is `bf'.
X.TP
X.BI "\-S, \-\-string\-font" " font"
XThe string and character constants are set in the given
X.IR font .
XDefault is `tt'.
X.TP
X.BI "\-T, \-\-tabstop" " width"
XThe width of tabs is
X.IR width .
XDefault is `8'.
X.TP
X.B "\-V, \-\-version"
XPrints the version number on
X.IR stderr .
X.PP
XTo give no options at all is the same as giving the options
X.nf
X.RS
X\-i 0.5em \-s 10 \-C it \-H sl \-I it \-K bf \-S tt \-T 8
X.RE
X.fi
X.SH DIAGNOSTICS
X.TP
X.I Can't use {\-p,\-\-pipe} and {\-o,\-\-output} together
XAt most one of this options may be given.
X.PP
X.TP
X.I Can't open `<file>' for reading
XThe program failed to open <file> for reading.
X.PP
X.TP
X.I Can't open `<file>' for writing
XThe program failed to open <file> for writing. All output is written
Xin the current directory if not explicitly changed by
X.BR {\-o,\-\-output} .
X.PP
X.TP
X.I Virtual memory exhausted
XThe program failed to allocate storage. As this is only done for the
Xconstruction of the output filename, this error will normally indicate
Xa program error.
X.SH FILES
X.TP
X.I fancyheadings.sty
XUsed by the output when
X.B \-h
Xor
X.B \-\-header
Xis specified.
X.SH UNRESTRICTIONS
X.B p2latex
Xis free; anyone may redistribute copies of
X.B p2latex
Xto anyone under the
Xterms stated in the GNU General Public Licence, a copy of which
Xaccompanies each copy of
X.BR p2latex .
X.PP
XTorsten Poulin encourages you to improve and extend
X.BR p2latex ,
Xand urges that you contribute your extensions to the world.
X.SH "SEE ALSO"
X.BR c++2latex (1),
X.BR latex (1)
X.SH AUTHOR
XTorsten Poulin (torsten@diku.dk)
X.PP
X.B p2latex
Xis derived from version 2.0 of
X.B c++2latex
Xwritten by Joerg Heitkoetter
X.PP
XThe original
X.B c++2latex
Xwas written by Norbert Kiesel.
X.PP
XThis manual page is an adapted version of the one for
X.B c++2latex.
X.SH BUGS
XOnly knows about Unix pathnames. Thus, some AmigaDOS and all MS\-DOS
Xinput filenames will yield unexpected results. This problem can be
Xcircumvented by using the
X.B {\-o,\-\-output}
Xoption.
X.PP
XBeware of filenames that are too long for the appended `.tex' to fit.
XIt would be a shame if the
X.I Pascal
Xsource file was inadvertently overwritten by the
X.I LaTeX
Xfile.
END_OF_FILE
  if test 6241 -ne `wc -c <'p2latex.1'`; then
    echo shar: \"'p2latex.1'\" unpacked with wrong size!
  fi
  # end of 'p2latex.1'
fi
if test -f 'p2latex.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'p2latex.c'\"
else
  echo shar: Extracting \"'p2latex.c'\" \(41206 characters\)
  sed "s/^X//" >'p2latex.c' <<'END_OF_FILE'
X/* A lexical scanner generated by flex */
X
X/* scanner skeleton version:
X * $Header: WPL:Generators/flex-2.3/RCS/flex.skel,v 1.2 90/07/15 01:17:26 loftus Exp $
X */
X
X#define FLEX_SCANNER
X
X#include <stdio.h>
X
X#ifdef __STDC__
X
X#ifndef DONT_HAVE_STDLIB_H
X#include <stdlib.h>
X#else
Xvoid *malloc( unsigned );
Xvoid free( void* );
X#endif
X
X#define YY_USE_PROTOS
X#define YY_USE_CONST
X#endif
X
X
X/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
X#ifdef c_plusplus
X#ifndef __cplusplus
X#define __cplusplus
X#endif
X#endif
X
X
X#ifdef __cplusplus
X
X#ifndef __STDC__
X#include <stdlib.h>
X#endif
X
X#include <osfcn.h>
X
X/* use prototypes in function declarations */
X#define YY_USE_PROTOS
X
X/* the "const" storage-class-modifier is valid */
X#define YY_USE_CONST
X
X#endif
X
X
X#ifdef __TURBOC__
X#define YY_USE_CONST
X#endif
X
X
X#ifndef YY_USE_CONST
X#define const
X#endif
X
X
X#ifdef YY_USE_PROTOS
X#define YY_PROTO(proto) proto
X#else
X#define YY_PROTO(proto) ()
X/* there's no standard place to get these definitions */
Xchar *malloc();
Xint free();
Xint read();
X#endif
X
X
X/* amount of stuff to slurp up with each read */
X#ifndef YY_READ_BUF_SIZE
X#define YY_READ_BUF_SIZE 8192
X#endif
X
X/* returned upon end-of-file */
X#define YY_END_TOK 0
X
X/* copy whatever the last rule matched to the standard output */
X
X/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
X/* this used to be an fputs(), but since the string might contain NUL's,
X * we now use fwrite()
X */
X#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )
X
X/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
X#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
X#define YY_NULL 0
X
X/* no semi-colon after return; correct usage is to write "yyterminate();" -
X * we don't want an extra ';' after the "return" because that will cause
X * some compilers to complain about unreachable statements.
X */
X#define yyterminate() return ( YY_NULL )
X
X/* report a fatal error */
X
X/* The funky do-while is used to turn this macro definition into
X * a single C statement (which needs a semi-colon terminator).
X * This avoids problems with code like:
X *
X * 	if ( something_happens )
X *		YY_FATAL_ERROR( "oops, the something happened" );
X *	else
X *		everything_okay();
X *
X * Prior to using the do-while the compiler would get upset at the
X * "else" because it interpreted the "if" statement as being all
X * done when it reached the ';' after the YY_FATAL_ERROR() call.
X */
X
X#define YY_FATAL_ERROR(msg) \
X	do \
X		{ \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X		} \
X	while ( 0 )
X
X/* default yywrap function - always treat EOF as an EOF */
X#define yywrap() 1
X
X/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
X#define BEGIN yy_start = 1 + 2 *
X
X/* action number for EOF rule of a given start state */
X#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
X/* special action meaning "start processing a new file" */
X#define YY_NEW_FILE \
X	do \
X		{ \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X		} \
X	while ( 0 )
X
X/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
X#define YY_DECL int yylex YY_PROTO(( void )) 
X
X/* code executed at the end of each rule */
X#define YY_BREAK break;
X
X#define YY_END_OF_BUFFER_CHAR 0
X
X#ifndef YY_BUF_SIZE
X#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
X#endif
X
Xtypedef struct yy_buffer_state *YY_BUFFER_STATE;
X
X#define YY_CHAR unsigned char
X# line 1 "p2latex.l"
X#define INITIAL 0
X/*
X *  p2LaTeX: Produce prettyprinted LaTeX files from Pascal sources.
X *  Copyright (C) 1993 Torsten Poulin
X *    Note: This program is derived from work done by others (see below).
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2, or (at your option)
X *  any later version.
X *
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *  Torsten Poulin 
X *  Banebrinken 99, 2, 77
X *  DK-2400 Copenhagen NV
X *  DENMARK
X *
X *  e-mail: torsten@diku.dk
X *  --------------------------------------------------------------------
X *  p2latex is derived from the code for the program C++2LaTeX 2.0 which
X *  produces prettyprinted LaTeX files from C++ or C sources.
X *
X *  C++2LaTeX 2.0 is copyright (C) 1991 Joerg Heitkoetter
X *
X *     Systems Analysis Research Group
X *     University of Dortmund
X *     (heitkoet@gorbi.informatik.uni-dortmund.de).
X *
X *  The original C++2LaTeX is copyright (C) 1990 Norbert Kiesel
X *
X *      Norbert Kiesel
X *      RWTH Aachen / Institut f. Informatik III
X *      Ahornstr. 55
X *      D-5100 Aachen
X *      West Germany
X *
X *      Phone:  +49 241 80-7266
X *      EUNET:  norbert@rwthi3.uucp
X *      USENET: ...!mcvax!unido!rwthi3!norbert
X *      X.400:  norbert@rwthi3.informatik.rwth-aachen.de
X *  --------------------------------------------------------------------
X * p2latex p2main.l revision history.
X * $Log:	p2latex.l,v $
X * Revision 1.3  93/12/09  01:20:12  Torsten
X * Now sets the insidestring flag when inside a string.
X * Corrected the indentation of comments preceded only by white-space.
X * The copyleft comment now refers to version 2 of the GPL.
X * 
X * Revision 1.2  93/11/06  14:43:51  Torsten
X * Added a few lines to the comment at the top of the program
X * giving credit to the authors of C++2LaTeX.
X * Minus now emits -- (a TeX number-range dash) when not in
X * a comment or a string.
X * Strings are now printed using \frenchspacing to suppress
X * extra space after punctuation. 
X * 
X * Revision 1.1  93/10/15  23:41:49  Torsten
X * Initial revision
X *
X */
X#define STRING 1
X#define BCOMMENT 2
X# line 72 "p2latex.l"
X#define KEY		printf ("{\\%s %s}", keyword_font, yytext)
X#define FANCYKEY(x)	fancysymbols ? printf(x) : KEY
X#define SYM(x)		printf ("$\\%s$", x)
X#define FANCY(x,y)	printf ("%s", fancysymbols ? x : y)
X#define OUT(x)		printf ("%s", x)
X#define ETAB		printf ("\\hspace*{%d\\indentation}", tabtoend)
X#define CTAB		printf ("\\hspace*{%d\\indentation}", tabtocomment)
X#define FONT(x)		printf ("{\\%s ",x)
X#define SUB(x)		substitute(x)
X#define IDENTIFIER	printf ("{\\%s %s\\/}", ident_font, yytext)
X#define IND		indent(yytext)
X#define INIT		BEGIN (INITIAL);
X
X#include <stdio.h>
X
Xstatic char RCSid[] = "$Id: p2latex.l,v 1.3 93/12/09 01:20:12 Torsten Rel $";
X
Xstatic void nindent(char *, int);
Xint insidestring	= 0;
X
Xint complete_file	= 0;
Xint header		= 0;
Xint tabtotab		= 8;
Xint piped		= 0;
Xint fancysymbols	= 0;
X
Xint aligntoright	= 1;		/* align comments to the right */
Xint tabtoend		= 2;		/* distance between end and comment */
Xint tabtocomment	= 4;		/* distance between statement and comment*/
X
Xchar *font_size		= "10";
Xchar *indentation	= "0.5em";
Xchar *comment_font	= "it";
Xchar *ident_font	= "it";
Xchar *keyword_font	= "bf";
Xchar *header_font	= "sl";
Xchar *string_font	= "tt";
X
X#ifdef __STDC__
Xvoid substitute(const char *);
Xvoid indent(const char *);
Xvoid newpage(int);
Xvoid usage(const char *);
X#else
Xvoid substitute();
Xvoid indent();
Xvoid newpage();
Xvoid usage();
X#endif
X# line 123 "p2latex.l"
X
X/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
X#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
X#define EOB_ACT_CONTINUE_SCAN 0
X#define EOB_ACT_END_OF_FILE 1
X#define EOB_ACT_LAST_MATCH 2
X
X/* return all but the first 'n' matched characters back to the input stream */
X#define yyless(n) \
X	do \
X		{ \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X		} \
X	while ( 0 )
X
X#define unput(c) yyunput( c, yytext )
X
X
Xstruct yy_buffer_state
X    {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters*/
X    int yy_buf_size;	
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
X#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
X#define EOF_PENDING 1
X#define EOF_DONE 2
X    };
X
Xstatic YY_BUFFER_STATE yy_current_buffer;
X
X/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
X#define YY_CURRENT_BUFFER yy_current_buffer
X
X
X/* yy_hold_char holds the character lost when yytext is formed */
Xstatic YY_CHAR yy_hold_char;
X
Xstatic int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X
X#ifndef YY_USER_ACTION
X#define YY_USER_ACTION
X#endif
X
X#ifndef YY_USER_INIT
X#define YY_USER_INIT
X#endif
X
Xextern YY_CHAR *yytext;
Xextern int yyleng;
Xextern FILE *yyin, *yyout;
X
XYY_CHAR *yytext;
Xint yyleng;
X
XFILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
X#define YY_END_OF_BUFFER 82
Xtypedef int yy_state_type;
Xstatic const short int yy_accept[204] =
X    {   0,
X        0,    0,    0,    0,    0,    0,   82,   81,   78,   80,
X       79,   67,   45,   46,   39,   52,   49,   44,   50,   41,
X       76,   47,   51,   42,   48,   43,   53,   54,   40,   55,
X       55,   55,   55,   55,   55,   55,   55,   55,   55,   55,
X       55,   55,   55,   55,   55,   55,   55,   55,   55,   61,
X       77,   45,   59,   71,   69,   68,   70,   66,   65,   64,
X       66,   63,   78,   79,   60,   72,   73,   76,    0,   36,
X       38,   37,   55,   55,   55,   55,   55,   55,   55,    6,
X       55,   55,   55,   55,   55,   55,   14,   15,   67,   55,
X       55,   55,   55,   19,   35,   55,   55,   55,   55,   55,
X
X       27,   55,   55,   55,   55,   55,   77,    0,   59,   58,
X       70,   65,   62,    0,   72,    0,    0,   74,   33,   55,
X       55,   55,   55,    5,   55,   55,    9,   55,   11,   55,
X       55,   55,   17,   18,   34,   55,   55,   55,   55,   25,
X       55,   55,   55,   30,   55,   55,   58,    0,   74,    0,
X       75,   55,   55,    3,   55,   55,    8,    0,    0,    0,
X       57,   10,   55,   13,   55,   55,   55,   55,   55,   55,
X       26,   28,   55,   55,   32,    1,    2,    4,   55,   56,
X       55,   16,   55,   55,   55,   55,   55,   29,   31,    7,
X       55,   20,   55,   55,   23,   24,   55,   55,   22,   12,
X
X       55,   21,    0
X    } ;
X
Xstatic const YY_CHAR yy_ec[256] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    4,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    1,    1,    1,    1,    1,    1,    5,    6,
X        7,    8,    9,   10,   11,   12,   13,   14,   14,   14,
X       14,   14,   14,   14,   14,   14,   14,   15,   16,   17,
X       18,   19,    1,    1,   24,   25,   26,   27,   28,   29,
X       30,   31,   32,   23,   33,   34,   35,   36,   37,   38,
X       23,   39,   40,   41,   42,   43,   44,   23,   45,   23,
X       20,    1,   21,   22,   23,    1,   24,   25,   26,   27,
X
X       28,   29,   30,   31,   32,   23,   33,   34,   35,   36,
X       37,   38,   23,   39,   40,   41,   42,   43,   44,   23,
X       45,   23,   46,    1,   47,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1
X    } ;
X
Xstatic const YY_CHAR yy_meta[48] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    2,    1,    1,    1,    1,    1,    1,
X        1,    1,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
X        2,    2,    2,    2,    2,    1,    1
X    } ;
X
Xstatic const short int yy_base[207] =
X    {   0,
X        0,   46,   46,   51,   55,   57,  236,  237,  233,  237,
X      231,  237,  225,  237,  237,  237,  237,  237,  218,  237,
X       50,  237,  237,   48,  237,  213,  237,  237,  237,    0,
X       32,  202,   37,   18,   36,   43,  192,   40,   72,  191,
X       47,   44,   58,  199,  198,   50,  189,  200,   57,  237,
X       84,  215,  237,  237,  237,  237,  220,  237,  219,  237,
X      213,  237,  217,  237,  237,   77,   79,   86,   92,  237,
X      237,  237,    0,  191,  178,  186,  175,  178,  170,  168,
X      171,  183,  175,  169,  171,  165,    0,    0,  237,  180,
X      177,  169,  161,    0,    0,  175,  163,   73,  158,  170,
X
X        0,  159,  155,  156,  162,  152,  106,  184,  237,  237,
X      189,  188,  237,  104,   95,  108,  175,  174,    0,  163,
X      154,  157,  144,    0,  147,  154,  119,  153,    0,  154,
X      142,  150,    0,    0,    0,  139,   90,  134,  142,    0,
X      133,  139,  134,    0,  130,  132,  237,  148,  147,  146,
X      145,  113,  121,    0,  115,  114,    0,  122,  146,  127,
X      237,    0,  112,    0,  117,  122,  121,  109,  108,  122,
X        0,    0,  111,  116,    0,    0,    0,    0,  106,  237,
X      110,    0,  114,  113,  115,  111,   96,    0,    0,    0,
X       99,    0,   92,   97,    0,    0,   91,   87,    0,    0,
X
X       82,    0,  237,  173,  175,   92
X    } ;
X
Xstatic const short int yy_def[207] =
X    {   0,
X      203,    1,  204,  204,  205,  205,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  203,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X
X      206,  206,  206,  206,  206,  206,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  203,  203,  203,  203,
X      203,  206,  206,  206,  206,  206,  206,  203,  203,  203,
X      203,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  203,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
X
X      206,  206,    0,  203,  203,  203
X    } ;
X
Xstatic const short int yy_nxt[285] =
X    {   0,
X        8,    9,   10,   11,   12,   13,   14,   15,   16,   17,
X       18,   19,   20,   21,   22,   23,   24,   25,   26,   27,
X       28,   29,   30,   31,   32,   33,   34,   35,   36,   37,
X       30,   38,   30,   39,   40,   41,   42,   43,   44,   45,
X       46,   47,   48,   49,   30,   50,    8,   51,   55,   79,
X       56,   52,   57,   55,   80,   56,   59,   60,   59,   60,
X       77,   67,   61,   68,   61,   70,   71,   74,   87,   81,
X       75,   82,   94,   78,   83,   88,   89,   69,   92,   84,
X      100,   96,   95,   93,   85,  107,  101,  105,  106,  108,
X       66,   53,  115,   73,  102,   90,   97,   67,  138,   68,
X
X      117,   62,  117,   62,  114,  118,  116,  107,  115,  202,
X      139,  108,  148,   69,  148,  167,  150,  149,  150,  168,
X      158,  151,   69,  158,  159,  201,  200,  159,  158,  109,
X      160,  199,  159,  198,  160,  197,  196,  195,  194,  193,
X      192,  191,  190,  189,  188,  187,  186,  185,  184,  183,
X      182,  109,  181,  180,  179,  178,  177,  176,  151,  151,
X      149,  149,  175,  174,  161,  173,  172,  161,  171,  170,
X      169,  166,  161,   54,   54,   58,   58,  165,  164,  163,
X      162,  157,  156,  155,  154,  153,  152,  118,  118,  112,
X      111,  147,  146,  145,  144,  143,  142,  141,  140,  137,
X
X      136,  135,  134,  133,  132,  131,  130,  129,  128,  127,
X      126,  125,  124,  123,  122,  121,  120,  119,   63,  113,
X      112,  111,  110,  104,  103,   99,   98,   91,   86,   76,
X       72,   66,   65,   64,   63,  203,    7,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203
X    } ;
X
Xstatic const short int yy_chk[285] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    2,    3,   34,
X        3,    2,    4,    4,   34,    4,    5,    5,    6,    6,
X       33,   21,    5,   21,    6,   24,   24,   31,   38,   35,
X       31,   35,   42,   33,   36,   38,   39,   21,   41,   36,
X       46,   43,   42,   41,   36,   51,   46,   49,   49,   51,
X       66,    2,   67,  206,   46,   39,   43,   68,   98,   68,
X
X       69,    5,   69,    6,   66,   69,   67,  107,  115,  201,
X       98,  107,  114,   68,  114,  137,  116,  114,  116,  137,
X      127,  116,  115,  158,  127,  198,  197,  158,  160,   51,
X      127,  194,  160,  193,  127,  191,  187,  186,  185,  184,
X      183,  181,  179,  174,  173,  170,  169,  168,  167,  166,
X      165,  107,  163,  159,  156,  155,  153,  152,  151,  150,
X      149,  148,  146,  145,  127,  143,  142,  158,  141,  139,
X      138,  136,  160,  204,  204,  205,  205,  132,  131,  130,
X      128,  126,  125,  123,  122,  121,  120,  118,  117,  112,
X      111,  108,  106,  105,  104,  103,  102,  100,   99,   97,
X
X       96,   93,   92,   91,   90,   86,   85,   84,   83,   82,
X       81,   80,   79,   78,   77,   76,   75,   74,   63,   61,
X       59,   57,   52,   48,   47,   45,   44,   40,   37,   32,
X       26,   19,   13,   11,    9,    7,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203,  203,  203,  203,  203,  203,  203,
X      203,  203,  203,  203
X    } ;
X
Xstatic yy_state_type yy_last_accepting_state;
Xstatic YY_CHAR *yy_last_accepting_cpos;
X
X/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
X#define REJECT reject_used_but_not_detected
X#define yymore() yymore_used_but_not_detected
X#define YY_MORE_ADJ 0
X
X/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
X/* points to current character in buffer */
Xstatic YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
Xstatic int yy_init = 1;		/* whether we need to initialize */
Xstatic int yy_start = 0;	/* start state number */
X
X/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
Xstatic int yy_did_buffer_switch_on_eof;
X
Xstatic yy_state_type yy_get_previous_state YY_PROTO(( void ));
Xstatic yy_state_type yy_try_NUL_trans YY_PROTO(( register yy_state_type current_state ));
Xstatic int yy_get_next_buffer YY_PROTO(( void ));
Xstatic void yyunput YY_PROTO(( YY_CHAR c, register YY_CHAR *buf_ptr ));
Xvoid yyrestart YY_PROTO(( FILE *input_file ));
Xvoid yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
Xvoid yy_load_buffer_state YY_PROTO(( void ));
XYY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
Xvoid yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
Xvoid yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
X
X#define yy_new_buffer yy_create_buffer
X
X#ifdef __cplusplus
Xstatic int yyinput YY_PROTO(( void ));
X#else
Xstatic int input YY_PROTO(( void ));
X#endif
X
XYY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X			INIT;
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
X	if ( yy_bp[-1] == '\n' )
X	    ++yy_current_state;
Xyy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 204 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 203 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
Xyy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
Xdo_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
Xcase 1:
X# line 128 "p2latex.l"
Xcase 2:
X# line 129 "p2latex.l"
Xcase 3:
X# line 130 "p2latex.l"
Xcase 4:
X# line 131 "p2latex.l"
Xcase 5:
X# line 132 "p2latex.l"
Xcase 6:
X# line 133 "p2latex.l"
Xcase 7:
X# line 134 "p2latex.l"
Xcase 8:
X# line 135 "p2latex.l"
Xcase 9:
X# line 136 "p2latex.l"
Xcase 10:
X# line 137 "p2latex.l"
Xcase 11:
X# line 138 "p2latex.l"
Xcase 12:
X# line 139 "p2latex.l"
Xcase 13:
X# line 140 "p2latex.l"
Xcase 14:
X# line 141 "p2latex.l"
Xcase 15:
X# line 142 "p2latex.l"
Xcase 16:
X# line 143 "p2latex.l"
Xcase 17:
X# line 144 "p2latex.l"
Xcase 18:
X# line 145 "p2latex.l"
Xcase 19:
X# line 146 "p2latex.l"
Xcase 20:
X# line 147 "p2latex.l"
Xcase 21:
X# line 148 "p2latex.l"
Xcase 22:
X# line 149 "p2latex.l"
Xcase 23:
X# line 150 "p2latex.l"
Xcase 24:
X# line 151 "p2latex.l"
Xcase 25:
X# line 152 "p2latex.l"
Xcase 26:
X# line 153 "p2latex.l"
Xcase 27:
X# line 154 "p2latex.l"
Xcase 28:
X# line 155 "p2latex.l"
Xcase 29:
X# line 156 "p2latex.l"
Xcase 30:
X# line 157 "p2latex.l"
Xcase 31:
X# line 158 "p2latex.l"
Xcase 32:
X# line 158 "p2latex.l"
XKEY;
X	YY_BREAK
Xcase 33:
X# line 159 "p2latex.l"
XFANCYKEY("$\\wedge$");
X	YY_BREAK
Xcase 34:
X# line 160 "p2latex.l"
XFANCYKEY("$\\neg$");
X	YY_BREAK
Xcase 35:
X# line 161 "p2latex.l"
XFANCYKEY("$\\vee");
X	YY_BREAK
Xcase 36:
X# line 162 "p2latex.l"
XFANCY ("$\\leq$", "$<$=");
X	YY_BREAK
Xcase 37:
X# line 163 "p2latex.l"
XFANCY ("$\\geq$", "$>$=");
X	YY_BREAK
Xcase 38:
X# line 164 "p2latex.l"
XFANCY ("$\\neq$", "$<>$");
X	YY_BREAK
Xcase 39:
X# line 165 "p2latex.l"
XSYM ("ast");
X	YY_BREAK
Xcase 40:
X# line 166 "p2latex.l"
XSYM ("uparrow");
X	YY_BREAK
Xcase 41:
X# line 167 "p2latex.l"
XOUT ("$/$");
X	YY_BREAK
Xcase 42:
X# line 168 "p2latex.l"
XOUT ("$<$");
X	YY_BREAK
Xcase 43:
X# line 169 "p2latex.l"
XOUT ("$>$");
X	YY_BREAK
Xcase 44:
X# line 170 "p2latex.l"
XOUT ("--");
X	YY_BREAK
Xcase 45:
X# line 172 "p2latex.l"
Xcase 46:
X# line 173 "p2latex.l"
Xcase 47:
X# line 174 "p2latex.l"
Xcase 48:
X# line 175 "p2latex.l"
Xcase 49:
X# line 176 "p2latex.l"
Xcase 50:
X# line 177 "p2latex.l"
Xcase 51:
X# line 178 "p2latex.l"
Xcase 52:
X# line 179 "p2latex.l"
Xcase 53:
X# line 180 "p2latex.l"
Xcase 54:
X# line 180 "p2latex.l"
XECHO;
X	YY_BREAK
Xcase 55:
X# line 182 "p2latex.l"
XIDENTIFIER;
X	YY_BREAK
X /* Comments mini scanner */
X /* 1. Comment after 'end;', 'end.', or 'end'  */
Xcase 56:
X# line 186 "p2latex.l"
X{ BEGIN (BCOMMENT);
X				{ int i;
X				  printf("{\\%s ", keyword_font);
X				  for (i = 0; i < 3; i++)
X				    printf("%c", yytext[i]);
X				  printf("}");
X				  if (yytext[i] == ';' || yytext[i] == '.')
X				    printf("%c", yytext[i]); }
X                                ETAB;
X                                OUT ("($\\ast$");
X                                FONT (comment_font); }
X	YY_BREAK
Xcase 57:
X# line 197 "p2latex.l"
X{ BEGIN (BCOMMENT);
X				{ int i;
X				  printf("{\\%s ", keyword_font);
X				  for (i = 0; i < 3; i++)
X				    printf("%c", yytext[i]);
X				  printf("}");
X				  if (yytext[i] == ';' || yytext[i] == '.')
X				    printf("%c", yytext[i]); }
X                                ETAB;
X                                OUT ("\\{");
X                                FONT (comment_font); }
X	YY_BREAK
X /* 2. Comments at the beginning of a line */
Xcase 58:
X# line 210 "p2latex.l"
X{ BEGIN (BCOMMENT);
X				nindent(yytext, yyleng - 2);
X                                OUT ("($\\ast$");
X				FONT (comment_font); }
X	YY_BREAK
Xcase 59:
X# line 214 "p2latex.l"
X{ BEGIN (BCOMMENT);
X				nindent(yytext, yyleng - 1);
X				OUT ("\\{");
X				FONT (comment_font); }
X	YY_BREAK
X /* 3. Other comments, aligned to right side of paper */
Xcase 60:
X# line 220 "p2latex.l"
X{ BEGIN (BCOMMENT);
X                                if (aligntoright) {
X					OUT ("\\hfill");
X				} else {
X					CTAB;
X				}
X                                OUT ("($\\ast$");
X				FONT (comment_font); }
X	YY_BREAK
Xcase 61:
X# line 228 "p2latex.l"
X{ BEGIN (BCOMMENT);
X                                if (aligntoright) {
X					OUT ("\\hfill");
X				} else {
X					CTAB;
X				}
X                                OUT ("\\{");
X				FONT (comment_font); }
X	YY_BREAK
Xcase 62:
X# line 238 "p2latex.l"
X{ INIT; OUT ("}$\\ast$)"); }
X	YY_BREAK
Xcase 63:
X# line 239 "p2latex.l"
X{ INIT; OUT ("}\\}"); }
X	YY_BREAK
Xcase 64:
X# line 240 "p2latex.l"
XOUT ("\\mbox{}\\\\\n");
X	YY_BREAK
Xcase 65:
X# line 241 "p2latex.l"
XIND;
X	YY_BREAK
Xcase 66:
X# line 242 "p2latex.l"
XSUB (yytext);
X	YY_BREAK
Xcase 67:
X# line 244 "p2latex.l"
X{ BEGIN (STRING);
X				FONT (string_font);
X				OUT ("\\frenchspacing{");
X				OUT ("\'");
X				insidestring = 1; }
X	YY_BREAK
Xcase 68:
X# line 249 "p2latex.l"
X{ INIT;
X				OUT ("\'}}");
X				insidestring = 0; }
X	YY_BREAK
Xcase 69:
X# line 252 "p2latex.l"
XOUT ("\\mbox{}\\\\\n");
X	YY_BREAK
Xcase 70:
X# line 253 "p2latex.l"
XIND;
X	YY_BREAK
Xcase 71:
X# line 254 "p2latex.l"
XSUB (yytext);
X	YY_BREAK
Xcase 72:
X# line 257 "p2latex.l"
Xcase 73:
X# line 258 "p2latex.l"
Xcase 74:
X# line 259 "p2latex.l"
Xcase 75:
X# line 259 "p2latex.l"
XECHO;
X	YY_BREAK
Xcase 76:
X# line 261 "p2latex.l"
XECHO;
X	YY_BREAK
Xcase 77:
X# line 263 "p2latex.l"
XIND;
X	YY_BREAK
Xcase 78:
X# line 264 "p2latex.l"
XECHO;
X	YY_BREAK
Xcase 79:
X# line 265 "p2latex.l"
XOUT ("\\newpage\n");
X	YY_BREAK
Xcase 80:
X# line 266 "p2latex.l"
XOUT ("\\mbox{}\\\\\n");
X	YY_BREAK
Xcase 81:
X# line 268 "p2latex.l"
XECHO;
X	YY_BREAK
Xcase YY_STATE_EOF(INITIAL):
Xcase YY_STATE_EOF(STRING):
Xcase YY_STATE_EOF(BCOMMENT):
X    yyterminate();
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
X#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
X#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X    }
X
X
X/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
Xstatic int yy_get_next_buffer()
X
X    {
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
X/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
Xstatic yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    register YY_CHAR *yy_bp = yytext;
X
X    yy_current_state = yy_start;
X    if ( yy_bp[-1] == '\n' )
X	++yy_current_state;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 204 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
X/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
X#ifdef YY_USE_PROTOS
Xstatic yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
X#else
Xstatic yy_state_type yy_try_NUL_trans( yy_current_state )
Xregister yy_state_type yy_current_state;
X#endif
X
X    {
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 204 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 203);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xstatic void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
X#else
Xstatic void yyunput( c, yy_bp )
XYY_CHAR c;
Xregister YY_CHAR *yy_bp;
X#endif
X
X    {
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
X#ifdef __cplusplus
Xstatic int yyinput()
X#else
Xstatic int input()
X#endif
X
X    {
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
X#ifdef __cplusplus
X		    return ( yyinput() );
X#else
X		    return ( input() );
X#endif
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
X#ifdef __cplusplus
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
X#else
X		    YY_FATAL_ERROR( "unexpected last match in input()" );
X#endif
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yyrestart( FILE *input_file )
X#else
Xvoid yyrestart( input_file )
XFILE *input_file;
X#endif
X
X    {
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
X#else
Xvoid yy_switch_to_buffer( new_buffer )
XYY_BUFFER_STATE new_buffer;
X#endif
X
X    {
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_load_buffer_state( void )
X#else
Xvoid yy_load_buffer_state()
X#endif
X
X    {
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X    }
X
X
X#ifdef YY_USE_PROTOS
XYY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
X#else
XYY_BUFFER_STATE yy_create_buffer( file, size )
XFILE *file;
Xint size;
X#endif
X
X    {
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
X
X    if ( ! b )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );
X
X    if ( ! b->yy_ch_buf )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    yy_init_buffer( b, file );
X
X    return ( b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_delete_buffer( YY_BUFFER_STATE b )
X#else
Xvoid yy_delete_buffer( b )
XYY_BUFFER_STATE b;
X#endif
X
X    {
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free( (char *) b->yy_ch_buf );
X    free( (char *) b );
X    }
X
X
X#ifdef YY_USE_PROTOS
Xvoid yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
X#else
Xvoid yy_init_buffer( b, file )
XYY_BUFFER_STATE b;
XFILE *file;
X#endif
X
X    {
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X    }
X# line 268 "p2latex.l"
X
X
Xstatic void nindent(char *blanks, int n)
X{
X  int i, bl;
X
X  for (i = bl = 0; i < n; i++) {
X    if (*blanks == ' ') {
X      bl++;
X    }
X    else {			/* *blanks == '\t' */
X      while (++bl % tabtotab) ;
X    }
X    blanks++;
X  }
X  printf("\\hspace*{%d\\indentation}", bl);
X}
END_OF_FILE
  if test 41206 -ne `wc -c <'p2latex.c'`; then
    echo shar: \"'p2latex.c'\" unpacked with wrong size!
  fi
  # end of 'p2latex.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
