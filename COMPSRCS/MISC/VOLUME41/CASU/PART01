Newsgroups: comp.sources.misc
From: lm@rmit.edu.au (Luke Mewburn)
Subject: v41i076:  casu - comms. & status utils, v3.3, Part01/04
Message-ID: <csm-v41i076=casu.205241@sparky.Sterling.COM>
X-Md4-Signature: 12cdd896e2596a898054f943de9a358f
Sender: kent@sparky.sterling.com (Kent Landfield)
Reply-To: Luke Mewburn <lm@rmit.edu.au>
Organization: Sterling Software
Date: Mon, 10 Jan 1994 02:52:58 GMT
Approved: kent@sparky.sterling.com

Submitted-by: lm@rmit.edu.au (Luke Mewburn)
Posting-number: Volume 41, Issue 76
Archive-name: casu/part01
Environment: UNIX, ANSI-C

CaSU -- communications & status utilities.

CaSU is a collection of programs for communicating with, and showing
the status of, other users (especially your friends). The package
currently consists of:
    flon --	lists your friends who are logged on
    to --	sends a short message to another user

 _flon_ uses the `$HOME/.friends' file to instruct it on which users to
selectively display.  The file eg.friends contains sample information.
The $FLON environment variable is also used by _flon_.  Refer to the
manual (source form is `FLON.rof') for more details.

 _to_ uses the `$HOME/.torc' file to store various parameters.  The
various settings in this text file can either be directly edited,
or set via command line options.  The eg.torc file contains a sample. 
Refer to the manual (source form is `TO.rof') for more details.

CaSU 3.3 has successfully been ported (in that the author has personally
tested the auto-configured scripts) to the following architectures:
    A/UX 3.0, NetBSD 0.8, Solaris 2, SunOS 4.1.3, Umax 2.4
Flon and To (at various stages of their development) have also been
ported to the following architectures: (and theoretically should still
work without problems)
    386BSD 0.1, AIX, Dynix, Irix 4, Linux, SCO Unix, SVR4 (non-Solaris)

 _to_ may need to be installed by the system administrator if your system
limits who can access a user's tty. During configuration, if a message
such as:
    checking mesg y permissions
    - `to' is setgid to group 5
appears, then this is the case.

Some people may wish to install the manual pages unformatted. If this
is the case, clear the `ROFF =' variable in the Makefile, and the
Makefile will determine that you wish to install them unformatted.
In this case, you may wish to change the manual destination directory
and extensions to man1 and 1 respectively (from cat1 and 0 respectively.)

By default, _flon_ will install a hardlink to itself with the name of
`who' (to use _flon_ as who). If you don't want this behaviour, modify
the Makefile and clear the `who_prog =' variable.

Future enhancements currently being considered include:
 - addition of a calendar program
 - enhance package to become the rcaid (remote communications and
  interactive diary) currently being designed by myself and
  Andrew Vanderstock, which contains the following subsystems:
    - remote to (``rto'')
    - remote flon (``rlon'')
    - remote calendar (``rcal'')
    - remote pin-board (``rpin'')

Bug reports, fixes, suggestions, and enhancements would be gratefully
accepted by the author, who may be contacted via email at:
    <lm@rmit.edu.au>

Luke Mewburn
----
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  casu-3.3 casu-3.3/configure casu-3.3/to.c
# Wrapped by kent@sparky on Sun Jan  9 20:46:38 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 4)."'
if test ! -d 'casu-3.3' ; then
    echo shar: Creating directory \"'casu-3.3'\"
    mkdir 'casu-3.3'
fi
if test -f 'casu-3.3/configure' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/configure'\"
else
  echo shar: Extracting \"'casu-3.3/configure'\" \(27563 characters\)
  sed "s/^X//" >'casu-3.3/configure' <<'END_OF_FILE'
X#!/bin/sh
X# Guess values for system-dependent variables and create Makefiles.
X# Generated automatically using autoconf.
X# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
X# This program is free software; you can redistribute it and/or modify
X# it under the terms of the GNU General Public License as published by
X# the Free Software Foundation; either version 2, or (at your option)
X# any later version.
X
X# This program is distributed in the hope that it will be useful,
X# but WITHOUT ANY WARRANTY; without even the implied warranty of
X# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X# GNU General Public License for more details.
X
X# You should have received a copy of the GNU General Public License
X# along with this program; if not, write to the Free Software
X# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp]
X#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE[=VALUE]]
X# Ignores all args except --srcdir, --prefix, --exec-prefix, and
X# --with-PACKAGE[=VALUE] unless this script has special code to handle it.
X
Xfor arg
Xdo
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, recognize -exec-prefix and --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed -e 's/-*with-//' -e 's/=.*//'`
X       # Reject names that aren't valid shell variable names.
X       if test -n "`echo $package| sed 's/[-a-zA-Z0-9_]//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       package=`echo $package| sed 's/-/_/g'`
X       case "$arg" in
X         *=*) val="`echo $arg|sed 's/[^=]*=//'`" ;;
X         *) val=1 ;;
X       esac
X       eval "with_$package='$val'" ;;
X
X     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
X       verbose=yes ;;
X
X     *) ;;
X    esac
X  fi
Xdone
X
Xtrap 'rm -fr conftest* confdefs* core; exit 1' 1 3 15
Xtrap 'rm -f confdefs*' 0
X
X# NLS nuisances.
X# These must not be set unconditionally because not all systems understand
X# e.g. LANG=C (notably SCO).
Xif test "${LC_ALL+set}" = 'set' ; then LC_ALL=C; export LC_ALL; fi
Xif test "${LANG+set}"   = 'set' ; then LANG=C;   export LANG;   fi
X
Xrm -f conftest* confdefs.h
X# AIX cpp loses on an empty file, so make sure it contains at least a newline.
Xecho > confdefs.h
Xcompile='${CC-cc} $CFLAGS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
X# A filename unique to this package, relative to the directory that
X# configure is in, which we can look for to find out if srcdir is correct.
Xunique_file=casu.h
X
X# Find the source files, if location was not specified.
Xif test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
Xfi
Xif test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
Xfi
X# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
X# But we can't avoid them for `..', to make subdirectories work.
Xcase $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
Xesac
X
X
X# Save the original args to write them into config.status later.
Xconfigure_args="$*"
X
XPROGS="flon to"
Xif test -z "$CC"; then
X  # Extract the first word of `gcc', so it can be a program name with args.
X  set dummy gcc; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$CC" && CC="cc"
Xtest -n "$CC" && test -n "$verbose" && echo "	setting CC to $CC"
X
X# Find out if we are using GNU C, under whatever name.
Xcat > conftest.c <<EOF
X#ifdef __GNUC__
X  yes
X#endif
XEOF
X${CC-cc} -E conftest.c > conftest.out 2>&1
Xif egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
Xfi
Xrm -f conftest*
X
Xecho checking how to run the C preprocessor
Xif test -z "$CPP"; then
X  # This must be in double quotes, not single quotes, because CPP may get
X  # substituted into the Makefile and ``${CC-cc}'' will simply confuse
X  # make.  It must be expanded now.
X  CPP="${CC-cc} -E"
X  cat > conftest.c <<EOF
X#include "confdefs.h"
X#include <stdio.h>
XSyntax Error
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  :
Xelse
X  rm -rf conftest*
X  CPP=/lib/cpp
Xfi
Xrm -f conftest*
Xfi
Xtest ".${verbose}" != "." && echo "	setting CPP to $CPP"
X
X# Make sure to not get the incompatible SysV /etc/install and
X# /usr/sbin/install, which might be in PATH before a BSD-like install,
X# or the SunOS /usr/etc/install directory, or the AIX /bin/install,
X# or the AFS install, which mishandles nonexistent args, or
X# /usr/ucb/install on SVR4, which tries to use the nonexistent group
X# `staff'.  On most BSDish systems install is in /usr/bin, not /usr/ucb
X# anyway.  Sigh.
Xif test "z${INSTALL}" = "z" ; then
X  echo checking for install
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    case $dir in
X    /etc|/usr/sbin|/usr/etc|/usr/afsws/bin|/usr/ucb) ;;
X    *)
X      if test -f $dir/installbsd; then
X	INSTALL="$dir/installbsd -c" # OSF1
X	INSTALL_PROGRAM='$(INSTALL)'
X	INSTALL_DATA='$(INSTALL) -m 644'
X	break
X      fi
X      if test -f $dir/install; then
X	if grep dspmsg $dir/install >/dev/null 2>&1; then
X	  : # AIX
X	else
X	  INSTALL="$dir/install -c"
X	  INSTALL_PROGRAM='$(INSTALL)'
X	  INSTALL_DATA='$(INSTALL) -m 644'
X	  break
X	fi
X      fi
X      ;;
X    esac
X  done
X  IFS="$saveifs"
Xfi
XINSTALL=${INSTALL-cp}
Xtest -n "$verbose" && echo "	setting INSTALL to $INSTALL"
XINSTALL_PROGRAM=${INSTALL_PROGRAM-'$(INSTALL)'}
Xtest -n "$verbose" && echo "	setting INSTALL_PROGRAM to $INSTALL_PROGRAM"
XINSTALL_DATA=${INSTALL_DATA-'$(INSTALL)'}
Xtest -n "$verbose" && echo "	setting INSTALL_DATA to $INSTALL_DATA"
X
Xecho checking for ln -s
Xrm -f conftestdata
Xif ln -s X conftestdata 2>/dev/null
Xthen
X  rm -f conftestdata
X  LN_S="ln -s"
Xelse
X  LN_S=ln
Xfi
X
X
Xif test -z "$ROFF"; then
X  # Extract the first word of `nroff', so it can be a program name with args.
X  set dummy nroff; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      ROFF="nroff -man"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$ROFF" && ROFF="cat"
Xtest -n "$ROFF" && test -n "$verbose" && echo "	setting ROFF to $ROFF"
X
Xif test -z "$TBL"; then
X  # Extract the first word of `tbl', so it can be a program name with args.
X  set dummy tbl; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      TBL="tbl"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$TBL" && TBL="cat"
Xtest -n "$TBL" && test -n "$verbose" && echo "	setting TBL to $TBL"
X
Xif test -z "$YPWHICH"; then
X  # Extract the first word of `ypwhich', so it can be a program name with args.
X  set dummy ypwhich; word=$2
X  echo checking for $word
X  IFS="${IFS= 	}"; saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/$word; then
X      YPWHICH="ypwhich"
X      break
X    fi
X  done
X  IFS="$saveifs"
Xfi
Xtest -z "$YPWHICH" && YPWHICH="false"
Xtest -n "$YPWHICH" && test -n "$verbose" && echo "	setting YPWHICH to $YPWHICH"
X
X
Xecho checking for AIX
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#ifdef _AIX
X  yes
X#endif
X
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "yes" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _ALL_SOURCE"
Xecho "#define" _ALL_SOURCE 1 >> confdefs.h
XDEFS="$DEFS -D_ALL_SOURCE=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lseq"
Xhave_lib=""
Xecho checking for -lseq
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lseq"
Xelse
X   :; 
Xfi
X
X
Xecho checking for minix/config.h
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <minix/config.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  MINIX=1
X
Xfi
Xrm -f conftest*
X
X# The Minix shell can't assign to the same variable on the same line!
Xif test -n "$MINIX"; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _POSIX_SOURCE"
Xecho "#define" _POSIX_SOURCE 1 >> confdefs.h
XDEFS="$DEFS -D_POSIX_SOURCE=1"
X}
X
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" _POSIX_1_SOURCE to be 2
Xecho "#define" _POSIX_1_SOURCE 2 >> confdefs.h
XDEFS="$DEFS -D_POSIX_1_SOURCE=2"
X}
X
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _MINIX"
Xecho "#define" _MINIX 1 >> confdefs.h
XDEFS="$DEFS -D_MINIX=1"
X}
X
Xfi
X
Xecho checking for POSIXized ISC
Xif test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
Xthen
X  ISC=1 # If later tests want to check for ISC.
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining _POSIX_SOURCE"
Xecho "#define" _POSIX_SOURCE 1 >> confdefs.h
XDEFS="$DEFS -D_POSIX_SOURCE=1"
X}
X
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
Xfi
X
X
Xecho checking for ANSI C header files
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <stdlib.h>
X#include <stdarg.h>
X#include <string.h>
X#include <float.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
Xecho '#include "confdefs.h"
X#include <string.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "memchr" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  # SGI's /bin/cc from Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
X#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
X#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
X#define XOR(e,f) (((e) && !(f)) || (!(e) && (f)))
Xint main () { int i; for (i = 0; i < 256; i++)
Xif (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
Xexit (0); }
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining STDC_HEADERS"
Xecho "#define" STDC_HEADERS 1 >> confdefs.h
XDEFS="$DEFS -DSTDC_HEADERS=1"
X}
X
X
Xfi
Xrm -fr conftest*
X
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
Xfor hdr in stdlib.h
Xdo
Xtrhdr=HAVE_`echo $hdr | tr '[a-z]./' '[A-Z]__'`
Xecho checking for ${hdr}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <${hdr}>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining ${trhdr}"
Xecho "#define" ${trhdr} 1 >> confdefs.h
XDEFS="$DEFS -D${trhdr}=1"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
Xecho checking for uid_t in sys/types.h
Xecho '#include "confdefs.h"
X#include <sys/types.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "uid_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" uid_t to be int
Xecho "#define" uid_t int >> confdefs.h
XDEFS="$DEFS -Duid_t=int"
X}
X 
X{
Xtest -n "$verbose" && \
Xecho "	defining" gid_t to be int
Xecho "#define" gid_t int >> confdefs.h
XDEFS="$DEFS -Dgid_t=int"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for mode_t in sys/types.h
Xecho '#include "confdefs.h"
X#include <sys/types.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "mode_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" mode_t to be int
Xecho "#define" mode_t int >> confdefs.h
XDEFS="$DEFS -Dmode_t=int"
X}
X
Xfi
Xrm -f conftest*
X
Xecho checking for size_t in sys/types.h
Xecho '#include "confdefs.h"
X#include <sys/types.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "size_t" conftest.out >/dev/null 2>&1; then
X  :
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" size_t to be unsigned
Xecho "#define" size_t unsigned >> confdefs.h
XDEFS="$DEFS -Dsize_t=unsigned"
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking whether cross-compiling
X# If we cannot run a trivial program, we must be cross compiling.
Xcat > conftest.c <<EOF
X#include "confdefs.h"
Xmain(){exit(0);}
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
Xelse
X  cross_compiling=1
Xfi
Xrm -fr conftest*
X
Xprog='/* Ultrix mips cc rejects this.  */
Xtypedef int charset[2]; const charset x;
X/* SunOS 4.1.1 cc rejects this.  */
Xchar const *const *ccp;
Xchar **p;
X/* AIX XL C 1.02.0.0 rejects this.
X   It does not let you subtract one const X* pointer from another in an arm
X   of an if-expression whose if-part is not a constant expression */
Xconst char *g = "string";
Xccp = &g + (g ? g-g : 0);
X/* HPUX 7.0 cc rejects these. */
X++ccp;
Xp = (char**) ccp;
Xccp = (char const *const *) p;
X{ /* SCO 3.2v4 cc rejects this.  */
X  char *t;
X  char const *s = 0 ? (char *) 0 : (char const *) 0;
X
X  *t++ = 0;
X}
X{ /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
X  int x[] = {25,17};
X  const int *foo = &x[0];
X  ++foo;
X}
X{ /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
X  typedef const int *iptr;
X  iptr p = 0;
X  ++p;
X}
X{ /* AIX XL C 1.02.0.0 rejects this saying
X     "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
X  struct s { int j; const int *ap[3]; };
X  struct s *b; b->j = 5;
X}
X{ /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
X  const int foo = 10;
X}'
Xecho checking for lack of working const
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { $prog }
XEOF
Xif eval $compile; then
X  :
Xelse
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining" const to be empty
Xecho "#define" const  >> confdefs.h
XDEFS="$DEFS -Dconst="
X}
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for netdb.h
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <netdb.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  echo '#include "confdefs.h"
X#include <netdb.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "MAXHOSTNAMELEN" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining NEED_NETDB_H"
Xecho "#define" NEED_NETDB_H 1 >> confdefs.h
XDEFS="$DEFS -DNEED_NETDB_H=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
X
Xecho "checking mesg y permissions"
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
X    #include <sys/types.h>
X    #include <sys/stat.h>
X    #include <stdio.h>
X    main() {
X	struct stat sb; char *x; int om, m; FILE *fp;
X	if (!(x = ttyname(0))) exit(1);
X	if (stat(x, &sb)) exit(1);
X	om = sb.st_mode;
X	if (chmod(x, om & ~077)) exit(1);
X	m = system("mesg y");
X	if (m == -1 || m == 127) exit(1);
X	if (stat(x, &sb)) exit(1);
X	m = sb.st_mode;
X	if (chmod(x, om)) exit(1);
X	if (!(m & 002)) {
X	    if (!(fp=fopen("conftest_grp", "w")))
X		exit(1);
X	    fprintf(fp, "%d\n", sb.st_gid);
X	    fclose(fp);
X	}
X	exit(0);
X    }
X
XEOF
Xeval $compile
Xif test -s conftest && (./conftest; exit) 2>/dev/null; then
X  
X    if test -f conftest_grp; then
X	echo "- 'to' is setgid to group `cat conftest_grp`"
X	
X{
Xtest -n "$verbose" && \
Xecho "	defining TTY_RESTRICTED"
Xecho "#define" TTY_RESTRICTED 1 >> confdefs.h
XDEFS="$DEFS -DTTY_RESTRICTED=1"
X}
X
X	TO_GRP=`cat conftest_grp`
X    else
X	echo "- anyone can write to tty"
X    fi
X
X
Xelse
X  echo "- can't determine - assume anyone can write to tty"
X
Xfi
Xrm -fr conftest*
X    
Xecho "checking for YP/NIS"
Xif $YPWHICH >/dev/null 2>&1; then
X    echo "- running YP, using system getpwent"
X    usegetpw=1
Xelse
X    echo "checking for getpwent db caches"
X    if test -f /etc/passwd.dir || test -f /etc/pwd.db; then
X	echo "- they're there, using system getpwent"
X	usegetpw=1
X    else
X	echo "- unavailable, using own getpwent"
X    fi
Xfi
Xif test -n "$usegetpw"; then
X    
X{
Xtest -n "$verbose" && \
Xecho "	defining USE_GETPWENT"
Xecho "#define" USE_GETPWENT 1 >> confdefs.h
XDEFS="$DEFS -DUSE_GETPWENT=1"
X}
X
Xfi
X
Xecho checking for utmpx.h
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <utmpx.h>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UTMPX_H"
Xecho "#define" HAVE_UTMPX_H 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UTMPX_H=1"
X}
X
X    
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UT_TYPE"
Xecho "#define" HAVE_UT_TYPE 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UT_TYPE=1"
X}
X
X    
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UT_HOST"
Xecho "#define" HAVE_UT_HOST 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UT_HOST=1"
X}
X
X
X
Xelse
X  rm -rf conftest*
X  echo "checking for struct utmp.ut_type"
X    echo '#include "confdefs.h"
X#include <utmp.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "ut_type" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UT_TYPE"
Xecho "#define" HAVE_UT_TYPE 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UT_TYPE=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X    echo "checking for struct umtp.ut_host"
X    echo '#include "confdefs.h"
X#include <utmp.h>' > conftest.c
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "ut_host" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_UT_HOST"
Xecho "#define" HAVE_UT_HOST 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_UT_HOST=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
Xfi
Xrm -f conftest*
X
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lnsl"
Xhave_lib=""
Xecho checking for -lnsl
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lnsl"
Xelse
X   :; 
Xfi
X
XLIBS_save="${LIBS}"
XLIBS="${LIBS} -lsocket"
Xhave_lib=""
Xecho checking for -lsocket
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
Xint main() { exit(0); }
Xint t() { main(); }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  have_lib="1"
X
Xfi
Xrm -f conftest*
XLIBS="${LIBS_save}"
Xif test -n "${have_lib}"; then
X   :; LIBS="$LIBS -lsocket"
Xelse
X   :; 
Xfi
X
Xfor func in strerror
Xdo
Xtrfunc=HAVE_`echo $func | tr '[a-z]' '[A-Z]'`
Xecho checking for ${func}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_${func}) || defined (__stub___${func})
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char ${func}(); ${func}();
X#endif
X }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  {
Xtest -n "$verbose" && \
Xecho "	defining ${trfunc}"
Xecho "#define" ${trfunc} 1 >> confdefs.h
XDEFS="$DEFS -D${trfunc}=1"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
Xfor func in getutent
Xdo
Xecho checking for ${func}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_${func}) || defined (__stub___${func})
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char ${func}(); ${func}();
X#endif
X }
XEOF
Xif eval $compile; then
X  :
Xelse
X  rm -rf conftest*
X  LIBOBJS="$LIBOBJS ${func}.o"
Xtest -n "$verbose" && echo "	using ${func}.o instead"
Xfi
Xrm -f conftest*
X
Xdone
X
X
Xecho "checking malloc declaration"
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
X#if HAVE_STDLIB_H
X#   include <stdlib.h>
X#endif
X
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "malloc( |	|\()" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining MALLOC_DECL"
Xecho "#define" MALLOC_DECL 1 >> confdefs.h
XDEFS="$DEFS -DMALLOC_DECL=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
Xecho "checking open declaration"
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
X#include <fcntl.h>
X
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "open( |	|\()" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining OPEN_DECL"
Xecho "#define" OPEN_DECL 1 >> confdefs.h
XDEFS="$DEFS -DOPEN_DECL=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
Xecho "checking read declaration"
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X
X#if HAVE_UNISTD_H
X#   include <unistd.h>
X#endif
X
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "read( |	|\()" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining READ_DECL"
Xecho "#define" READ_DECL 1 >> confdefs.h
XDEFS="$DEFS -DREAD_DECL=1"
X}
X
X
Xfi
Xrm -f conftest*
X
X
Xecho checking for gethostname
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_gethostname) || defined (__stub___gethostname)
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char gethostname(); gethostname();
X#endif
X }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining HAVE_GETHOSTNAME"
Xecho "#define" HAVE_GETHOSTNAME 1 >> confdefs.h
XDEFS="$DEFS -DHAVE_GETHOSTNAME=1"
X}
X
X    have_ghn=1
X
X
Xelse
X  rm -rf conftest*
X  for hdr in sys/utsname.h
Xdo
Xtrhdr=HAVE_`echo $hdr | tr 'a-z./' 'A-Z__'`
Xecho checking for ${hdr}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <${hdr}>
XEOF
Xerr=`eval "($CPP conftest.c >/dev/null) 2>&1"`
Xif test -z "$err"; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining ${trhdr}"
Xecho "#define" ${trhdr} 1 >> confdefs.h
XDEFS="$DEFS -D${trhdr}=1"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
X    for func in uname
Xdo
Xtrfunc=HAVE_`echo $func | tr 'a-z' 'A-Z'`
Xecho checking for ${func}
Xcat > conftest.c <<EOF
X#include "confdefs.h"
X#include <ctype.h>
Xint main() { exit(0); }
Xint t() { 
X/* The GNU C library defines this for functions which it implements
X    to always fail with ENOSYS.  Some functions are actually named
X    something starting with __ and the normal name is an alias.  */
X#if defined (__stub_${func}) || defined (__stub___${func})
Xchoke me
X#else
X/* Override any gcc2 internal prototype to avoid an error.  */
Xextern char ${func}(); ${func}();
X#endif
X }
XEOF
Xif eval $compile; then
X  rm -rf conftest*
X  {
Xtest -n "$verbose" && \
Xecho "	defining ${trfunc}"
Xecho "#define" ${trfunc} 1 >> confdefs.h
XDEFS="$DEFS -D${trfunc}=1"
X}
X
X
Xfi
Xrm -f conftest*
Xdone
X
X
Xfi
Xrm -f conftest*
X
Xif test -n "$have_ghn"; then
X    echo "checking gethostname declaration"
X    cat > conftest.c <<EOF
X#include "confdefs.h"
X
X    #include <sys/types.h>
X    #if HAVE_UNISTD_H
X    #   include <unistd.h>
X    #endif
X    
XEOF
Xeval "$CPP conftest.c > conftest.out 2>&1"
Xif egrep "gethostname( |	|\()" conftest.out >/dev/null 2>&1; then
X  rm -rf conftest*
X  
X{
Xtest -n "$verbose" && \
Xecho "	defining GETHOSTNAME_DECL"
Xecho "#define" GETHOSTNAME_DECL 1 >> confdefs.h
XDEFS="$DEFS -DGETHOSTNAME_DECL=1"
X}
X
X
Xfi
Xrm -f conftest*
X
Xfi
X
X# Set default prefixes.
Xif test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
Xfi
Xif test -n "$exec_prefix"; then
X  prsub="$prsub
Xs%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%exec_prefix\\1=\\2$exec_prefix%"
Xfi
X# Quote sed substitution magic chars in DEFS.
Xcat >conftest.def <<EOF
X$DEFS
XEOF
Xescape_ampersand_and_backslash='s%[&\\]%\\&%g'
XDEFS=`sed "$escape_ampersand_and_backslash" <conftest.def`
Xrm -f conftest.def
X# Substitute for predefined variables.
X
Xtrap 'rm -f config.status; exit 1' 1 3 15
Xecho creating config.status
Xrm -f config.status
Xcat > config.status <<EOF
X#!/bin/sh
X# Generated automatically by configure.
X# Run this file to recreate the current configuration.
X# This directory was configured as follows,
X# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
X#
X# $0 $configure_args
X
Xfor arg
Xdo
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    echo running \${CONFIG_SHELL-/bin/sh} $0 $configure_args
X    exec \${CONFIG_SHELL-/bin/sh} $0 $configure_args ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
Xdone
X
Xtrap 'rm -f Makefile; exit 1' 1 3 15
XPROGS='$PROGS'
XCC='$CC'
XCPP='$CPP'
XINSTALL='$INSTALL'
XINSTALL_PROGRAM='$INSTALL_PROGRAM'
XINSTALL_DATA='$INSTALL_DATA'
XLN_S='$LN_S'
XROFF='$ROFF'
XTBL='$TBL'
XYPWHICH='$YPWHICH'
XTO_GRP='$TO_GRP'
XLIBOBJS='$LIBOBJS'
XLIBS='$LIBS'
Xsrcdir='$srcdir'
XDEFS='$DEFS'
Xprefix='$prefix'
Xexec_prefix='$exec_prefix'
Xprsub='$prsub'
Xextrasub='$extrasub'
XEOF
Xcat >> config.status <<\EOF
X
Xtop_srcdir=$srcdir
X
XCONFIG_FILES=${CONFIG_FILES-"Makefile"}
Xfor file in .. ${CONFIG_FILES}; do if test "x$file" != x..; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
X$prsub
X$extrasub
Xs%@PROGS@%$PROGS%g
Xs%@CC@%$CC%g
Xs%@CPP@%$CPP%g
Xs%@INSTALL@%$INSTALL%g
Xs%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
Xs%@INSTALL_DATA@%$INSTALL_DATA%g
Xs%@LN_S@%$LN_S%g
Xs%@ROFF@%$ROFF%g
Xs%@TBL@%$TBL%g
Xs%@YPWHICH@%$YPWHICH%g
Xs%@TO_GRP@%$TO_GRP%g
Xs%@LIBOBJS@%$LIBOBJS%g
Xs%@LIBS@%$LIBS%g
Xs%@srcdir@%$srcdir%g
Xs%@DEFS@%$DEFS%
X" $top_srcdir/${file}.in >> $file
Xfi; done
X
X
Xexit 0
XEOF
Xchmod +x config.status
X${CONFIG_SHELL-/bin/sh} config.status
X
END_OF_FILE
  if test 27563 -ne `wc -c <'casu-3.3/configure'`; then
    echo shar: \"'casu-3.3/configure'\" unpacked with wrong size!
  fi
  chmod +x 'casu-3.3/configure'
  # end of 'casu-3.3/configure'
fi
if test -f 'casu-3.3/to.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/to.c'\"
else
  echo shar: Extracting \"'casu-3.3/to.c'\" \(21895 characters\)
  sed "s/^X//" >'casu-3.3/to.c' <<'END_OF_FILE'
X/*
X *  CaSU - communications & status utilities.
X *  Copyright (C) 1992, 1993 Luke Mewburn <lm@rmit.edu.au>
X *	incorporating:
X *	   flon - lists your friends who are logged on.
X *	   to - send a short message to a friend
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *  
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *  
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X
X#define _MAIN_
X#include "casu.h"
X
X#ifdef M_SYSV
X    utmp_s	Kludge;
X#endif /* for SCO */
X
X
Xstatic	int 	argc;
Xstatic	char	**argv;
X
X/*
X * add_alist_ent -	add an alias/userid pair to the global linked list;
X *			if alias is empty, just add - as it's an exclude entry,
X *			not an alias.
X */
Xstatic void
Xadd_alist_ent(alias, userid, them)
X    char	*alias, *userid;
X    user_t	*them;
X{
X    alist *p = them->aliases;
X
X    if (alias[0])		/* find matching alias */
X    {
X	while (p != NULL)
X	{
X	    if (strcmp(p->alias, alias) == 0)
X		break;
X	    p = p->next;
X	}
X    }
X    else			/* find matching exclude entry */
X    {
X	while (p != NULL)
X	{
X	    if ((!p->alias[0]) && (strcmp(p->userid, userid) == 0))
X		break;
X	    p = p->next;
X	}
X    }
X    if (p == NULL)		/* not found - add new element */
X    {
X	p = (alist *) malloc (sizeof(alist));
X	if (p == NULL)
X	    errexit(strerror(errno), NULL);
X	p->next = them->aliases;
X	them->aliases = p;
X    }
X    strnc0py(p->alias, alias, sizeof(p->alias) - 1);
X    strnc0py(p->userid, userid, sizeof(p->userid) - 1);
X} /* add_alist_ent */
X
X
X/*
X * remove_alist_ent - remove an alias/userid pair from the global linked list;
X */
Xstatic void
Xremove_alist_ent(user, them, rm_type)
X    char	*user;
X    user_t	*them;
X#define REMOVE_EXCLUDE	0
X#define REMOVE_ALIAS	1
X    int		rm_type;	/* 1 == remove alias, 0 === remove exclude */
X{
X    alist *p = them->aliases, *last;
X
X    last = NULL;
X    while (p != NULL)			/* find relevant entry */
X    {
X	if (rm_type == REMOVE_ALIAS)
X	{
X	    if (strcmp(p->alias, user) == 0)
X		break;
X	}
X	else	/* REMOVE_EXCLUDE */
X	    if ((! p->alias[0]) && (strcmp(p->userid, user) == 0))
X		break;
X	last = p;
X	p = p->next;
X    }
X    if (p == NULL)			/* not there - complain */
X    {
X	if (rm_type == REMOVE_ALIAS)
X	    errmesg("alias not found", user);
X	else
X	    errmesg("exclude entry not found", user);
X	return;
X    }
X    if (last != NULL)			/* de-link it from the list */
X	last->next = p->next;
X    else
X	them->aliases = p->next;	/* don't bother free()ing it... */
X} /* remove_alist_ent */
X
X
X/*
X * get_pwent -	get an appropriate entry from the password file.
X *		if given NULL, assume it's for this user
X */
Xstatic struct passwd *
Xget_pwent(nam)
X    char *nam;
X{
X    struct passwd *pwent;
X    if (nam == NULL)
X	pwent = getpwuid(getuid());
X    else
X	pwent = getpwnam(nam);
X    return pwent;
X} /* get_pwent */
X
X
X/*
X * load_rcfile - read in the rcfile for the respective user
X *		into the data struct. if nam == NULL, also add
X *		aliases to the global list;
X */
Xstatic void
Xload_rcfile(them, nam)
X     user_t	*them;
X     char 	*nam;
X{
X    FILE		*fp;
X    char		buf[LINESIZ + 1], rcfile[MAXPATHLEN + 1];
X    char		user[UT_NAMESIZE + 1], alias[ALIASLEN + 1];
X    struct stat		sbuf;
X    int			ch;
X    struct passwd	*pwent;
X    static char		aliasfmt[16];	/* see below */
X
X    if (!aliasfmt[0])
X	sprintf(aliasfmt, "%%%ds %%%ds", ALIASLEN, UT_NAMESIZE);
X
X    them->yes[0] = '\0';		/* clear everything */
X    them->no[0] = '\0';
X    them->gone[0] = '\0';
X    them->idle[0] = '\0';
X    them->dotuser[0] = '\0';
X    them->dottty[0] = '\0';
X    them->exclude[0] = '\0';
X    them->aliases = NULL;
X
X    pwent = get_pwent(nam);		/* get info from /etc/passwd */
X    if (!pwent)
X	if (!nam)
X	    errexit("you don't exist", NULL);
X	else
X	    errexit("doesn't exist", nam);
X    strnc0py(them->name,
X	    convert_realname(pwent->pw_gecos, pwent->pw_name, pwent->pw_uid),
X	    sizeof(them->name) - 1);
X    strnc0py(them->userid, pwent->pw_name, sizeof(them->userid) - 1);
X    strnc0py(them->homedir, pwent->pw_dir, sizeof(them->homedir) - 1);
X
X    strnc0py(rcfile, pwent->pw_dir, sizeof(rcfile) - 1);
X    if (strlen(rcfile) + strlen(STRtorc) >= sizeof(rcfile) - 1)
X	errexit("filename is too long", STRtorc);
X    strcat(rcfile, STRtorc);
X    if (stat(rcfile, &sbuf) == -1)	/* open their .torc */
X	return;
X    fp = fopen(rcfile, "r");
X    if (fp == NULL)
X	return;
X    while (fgets(buf, sizeof(buf), fp) != NULL)
X    {					/* read it in */
X	if (strlen(buf) == sizeof(buf) - 1 )
X	    while ((ch = fgetc(fp)) != EOF)
X		if (ch == '\n')
X		    break;		/* gobble extra chars */
X	buf[strlen(buf) - 1] = '\0';
X	ch = isupper(buf[0]) ? tolower(buf[0]) : buf[0];
X	switch (ch)
X	{
X	case '.':			/* . user */
X	    strnc0py(them->dotuser, buf + (buf[1] == ' ' ? 2 : 1),
X			sizeof(them->dotuser) - 1);
X	    break;
X	case ':':			/* . tty */
X	    strnc0py(them->dottty, buf + 2, sizeof(them->dottty) - 1);
X	    break;
X	case 'y':			/* yes AR */
X	    strnc0py(them->yes, buf + 2, sizeof(them->yes) - 1);
X	    break;
X	case 'n':			/* no AR */
X	    strnc0py(them->no, buf + 2, sizeof(them->no) - 1);
X	    break;
X	case 'g':			/* gone AR */
X	    strnc0py(them->gone, buf + 2, sizeof(them->gone) - 1);
X	    break;
X	case 'i':			/* idle AR */
X	    strnc0py(them->idle, buf + 2, sizeof(them->idle) - 1);
X	    break;
X	case 'x':			/* exclude AR */
X	    strnc0py(them->exclude, buf + 2, sizeof(them->exclude) - 1);
X	    break;
X	case 'p':			/* pseudonym/name/whatever */
X	    strnc0py(them->name, buf + 2, sizeof(them->name) - 1);
X	    flags |= PSEUDO_MOD;
X	    break;
X	case 'a':			/* add an alias */
X	    if (nam == NULL)	/* only add aliases to sender's struct */
X	    {
X		sscanf(buf + 1, aliasfmt, alias, user);
X		add_alist_ent(alias, user, them);
X	    }
X	    break;
X	case 'e':		/* add an exclude entry */
X	    add_alist_ent("", buf + 2, them);
X	    break;
X	default:
X	    if (flags & DEBUG)
X	    {
X		buf[1] = '\0';	/* so errmesg doesn't die */
X		errmesg("illegal specifier (DEBUG)", buf);
X	    }
X	    break;
X	}
X    } /* while */
X} /* load_rcfile */
X
X
X/*
X * dump_status - 	dump status of user rec.
X */
Xstatic void
Xdump_status(me)
X    user_t	*me;
X{
X    struct stat sbuf;
X
X    if (!me->tty)
X	printf("Not attached to a tty.\n");
X    else
X    {
X	if (stat(me->tty, &sbuf) == -1)
X	    errmesg(strerror(errno), me->tty);
X	else
X	    printf("Incoming messages are %sabled.\n",
X		    (sbuf.st_mode & MESGS_ON) ? "en" : "dis");
X    }
X    printf("Name:      %s\n", me->name);
X    if (me->tty)
X	printf("Terminal:  %s\n", me->tty);
X    if (me->dotuser[0] != '\0')
X    {
X	if (me->dottty[0] != '\0')
X	    printf("Last user: %s (%s)\n", me->dotuser, me->dottty);
X	else
X	    printf("Last user: %s\n", me->dotuser);
X    }
X    if (me->yes[0] != '\0')
X	printf("Mesg ON autoreply:  %s\n", me->yes);
X    if (me->no[0] != '\0')
X	printf("Mesg OFF autoreply: %s\n", me->no);
X    if (me->gone[0] != '\0')
X	printf("Gone autoreply:     %s\n", me->gone);
X    if (me->idle[0] != '\0')
X	printf("Idle autoreply:     %s\n", me->idle);
X    if (me->exclude[0] != '\0')
X	printf("Exclude autoreply:  %s\n", me->exclude);
X} /* dump_status */
X
X
X/*
X * process_options -	parse the options available
X */
Xstatic void
Xprocess_options(me, you)
X    user_t	*me, *you;
X{
X    int		ch;
X
X    opterr=1;
X    while ((ch = getopt(argc, argv, "a:bde:E:hlnrt:u:yvP:I:Y:N:G:X:V")) != -1)
X    {
X	switch (ch)
X	{
X	case 'a':
X	    if (argc == optind)
X	    {
X		fprintf(stderr, "Usage: %s -a alias userid\n", progname);
X		flags |= ERROR;
X		break;
X	    }
X	    add_alist_ent(optarg, argv[optind++], me);
X	    flags |= DB_MOD;
X	    break;
X	case 'b':
X	    flags |= BEEP;
X	    break;
X	case 'd':
X	    flags |= DEBUG;
X	    break;
X	case 'e':
X	    add_alist_ent("", optarg, me);
X	    flags |= DB_MOD;
X	    break;
X	case 'E':
X	    remove_alist_ent(optarg, me, REMOVE_EXCLUDE);
X	    flags |= DB_MOD;
X	    break;
X	case 'l':
X	    flags |= LISTALIAS;
X	    break;
X	case 'h':
X	    flags |= HELP;
X	    break;
X	case 'n':
X	    flags &= ~MESG_Y;
X	    flags |= MESG_N;
X	    break;
X	case 'y':
X	    flags |= MESG_Y;
X	    flags &= ~MESG_N;
X	    break;
X	case 'r':
X	    flags |= STATUS;
X	    break;
X	case 't':
X	    you->tty = optarg;
X	    flags |= DB_MOD;
X	    break;
X	case 'u':
X	    remove_alist_ent(optarg, me, REMOVE_ALIAS);
X	    flags |= DB_MOD;
X	    break;
X	case 'v':
X	case 'V':
X	    flags |= LISTVERSION;
X	    break;
X	case 'Y':
X	    strnc0py(me->yes, optarg, sizeof(me->yes) - 1);
X	    flags |= DB_MOD;
X	    break;
X	case 'P':
X	    strnc0py(me->name, optarg, sizeof(me->name) - 1);
X	    flags |= (PSEUDO_MOD + DB_MOD);
X	    break;
X	case 'N':
X	    strnc0py(me->no, optarg, sizeof(me->no) - 1);
X	    flags |= DB_MOD;
X	    break;
X	case 'G':
X	    strnc0py(me->gone, optarg, sizeof(me->gone) - 1);
X	    flags |= DB_MOD;
X	    break;
X	case 'I':
X	    strnc0py(me->idle, optarg, sizeof(me->idle) - 1);
X	    flags |= DB_MOD;
X	    break;
X	case 'X':
X	    strnc0py(me->exclude, optarg, sizeof(me->exclude) - 1);
X	    flags |= DB_MOD;
X	    break;
X	case '?':
X	    flags |= ERROR;
X	    break;
X	}
X    }
X
X    if (flags & DEBUG)
X	printf("DEBUG: argc %d  optind %d  flags %d \n", argc, optind, flags);
X
X		/* barf if just -b, -t ttyxx, or no args */
X    if (   (argc == optind)		/* non-productive usage */
X	&& ((flags & BEEP) || (you->tty) || (argc == 1)))
X	flags |= ERROR;
X
X    if (flags & (MESG_Y + MESG_N))	/* change tty mode */
X    {
X	struct stat sbuf;
X	if (!me->tty)
X	    errmesg("unable to change status of tty - no such tty", NULL);
X	else
X	    if (stat(me->tty, &sbuf) == -1)
X		errmesg(strerror(errno), me->tty);
X	    else
X	    {
X		if (flags & MESG_N)
X		    sbuf.st_mode &= ~MESGS_ON;
X		else
X		    sbuf.st_mode |= MESGS_ON;
X		chmod(me->tty, sbuf.st_mode);
X	    }
X    }
X
X    if (flags & STATUS)			/* show status */
X	dump_status(me);
X
X    if (flags & LISTALIAS)		/* list aliases */
X    {
X	alist *p = me->aliases;
X	if (p)
X	    printf("UserID\t  Alias\n------\t  -----\n");
X	else
X	    printf("No aliases defined.\n");
X	while (p)
X	{
X	    printf("%s\t  %s\n", p->userid, p->alias[0] ? p->alias
X							: "** EXCLUDED **");
X	    p = p->next;
X	}
X    }
X
X    if (flags & (ERROR + LISTVERSION + HELP))
X    {
X	fprintf(stderr, "\
XUsage: %s [-a alias user] [-u alias] [-bdlnyr] [-G gone] [-Y yes] [-N no]\n\
X\t[-I idle] [-X exclude] [-P pseudo] [-e user] [-E user] [-t term]\n\
X\t[-h] -[vV]  [user [message]]\n\
X", progname);
X	if (flags & (HELP))
X	{
X	    fprintf(stderr, "\
X\n\
XTo - send a short message to another user\n\
X\n\
XUsage:  %s [options] user [message] \tsends message to user (*)\n\
X\n\
Xoptions can be:\n\
X	-a alias user	add an alias to your .torc\n\
X	-u alias	unalias an alias\n\
X	-b		beep other user with message\n\
X	-e user		add `user' to the exclude list\n\
X	-E user		remove `user' from the exclude list\n\
X	-h		this help page\n\
X	-n		turn messages off\n\
X	-y		turn messages on\n\
X	-l		list aliases\n\
X	-r		list status\n\
X	-t term		send to tty `term'\n\
X	-P name		set pseudonym to name\n\
X	-I mesg		set `idle' autoreply to mesg\n\
X	-G mesg		set `gone' autoreply to mesg\n\
X	-N mesg		set `mesg n' autoreply to mesg\n\
X	-Y mesg		set `mesg y' autoreply to mesg\n\
X	-X mesg		set `exclude' autoreply to mesg\n\
X	-V		version infomation\n\
X\n\
XThe options can be used in conjunction with each other.\n\
X\n\
X(*) Reads message from terminal if you don't specify one.\n\
X", progname);
X	}
X	if (flags & (HELP + LISTVERSION))
X	{
X	    fprintf(stderr, "\
X\n\
X%s version %s, %s.\n\
XCopyright (C) 1993 Luke Mewburn\n\
XEmail: <lm@rmit.edu.au>\n\
XThis is free software, and you are welcome to redistribute it under certain\n\
Xconditions. See version 2 of the GNU Public License for more details.\n\
X", progname, VERSION, RELDATE);
X	}
X	exit((flags & ERROR ) != 0);
X    }
X} /* process_options */
X
X
X/*
X * lookup_user -	find a user and put info in user_t struct
X */
Xstatic int
Xlookup_user(me, them)
X    user_t *me, *them;
X{
X    alist		*p = me->aliases;
X    struct passwd	*pwent;
X    char		*target;
X    
X    if (argc > optind)
X	target = argv[optind++];
X    else
X	return 0;
X    if (strcmp(target, ".") == 0)	/* is a .user */
X    {
X	if (me->dotuser[0] == '\0')
X	{
X	    errmesg("no `.' user defined", NULL);
X	    return 0;
X	}
X	target = me->dotuser;
X	if ((!them->tty) && (me->dottty[0] != '\0'))
X	    them->tty = me->dottty;	/* use last tty */
X    }
X    else				/* is it an alias? */
X    {
X	while (p)
X	{
X	    if (strcmp(target, p->alias) == 0)
X	    {
X		target = p->userid;
X		break;
X	    }
X	    p = p->next;
X	}
X    }
X    pwent = get_pwent(target);		/* check if user */
X    if (! pwent)
X    {
X	errmesg("doesn't exist", target);
X	return 0;
X    }
X    strnc0py(them->name,
X	    convert_realname(pwent->pw_gecos, pwent->pw_name, pwent->pw_uid),
X	    sizeof(them->name) - 1);
X    strnc0py(them->userid, pwent->pw_name, sizeof(them->userid) - 1);
X    strnc0py(them->homedir, pwent->pw_dir, sizeof(them->homedir) - 1);
X    if (target != me->dotuser)
X    {
X	strnc0py(me->dotuser, target, sizeof(me->dotuser) - 1);
X	flags |= DB_MOD;
X    }
X    return 1;
X} /* lookup_user */
X
X
X/*
X * update_torc -	write out change .torc file
X */
Xstatic void
Xupdate_torc(me)
X    user_t *me;
X{
X    FILE	*fp;
X    alist	*p = me->aliases;
X    char	rcfile[MAXPATHLEN + 1];
X    struct stat	sbuf;
X
X    if (!(flags & DB_MOD))	/* only write if info was modified */
X	return;
X
X    strnc0py(rcfile, me->homedir, sizeof(rcfile) - 1);
X    if (strlen(rcfile) + strlen(STRtorc) >= sizeof(rcfile) - 1)
X	errexit("filename is too long", STRtorc);
X    strcat(rcfile, STRtorc);
X
X#if TTY_RESTRICTED
X    setgid(getgid());		/* so a new .torc has user's group, not `tty' */
X#endif /* TTY_RESTRICTED */
X    fp = fopen(rcfile, "w");
X    if (fp == NULL)
X	errexit(strerror(errno), NULL);
X    if (me->dotuser[0] != '\0')
X	fprintf(fp, ". %s\n", me->dotuser);
X    if (me->dottty[0] != '\0')
X	fprintf(fp, ": %s\n", me->dottty);
X    if (flags & PSEUDO_MOD)
X	if (me->name[0] != '\0')
X	    fprintf(fp, "P %s\n", me->name);
X    if (me->yes[0] != '\0')
X	fprintf(fp, "Y %s\n", me->yes);
X    if (me->idle[0] != '\0')
X	fprintf(fp, "I %s\n", me->idle);
X    if (me->no[0] != '\0')
X	fprintf(fp, "N %s\n", me->no);
X    if (me->gone[0] != '\0')
X	fprintf(fp, "G %s\n", me->gone);
X    if (me->exclude[0] != '\0')
X	fprintf(fp, "X %s\n", me->exclude);
X    while (p)
X    {
X	if (p->alias[0])	/* exclude entries have this field empty */
X	    fprintf(fp, "a %s %s\n", p->alias, p->userid);
X	else
X	    fprintf(fp, "e %s\n", p->userid);
X	p = p->next;
X    }
X    if (stat(rcfile, &sbuf) != -1)	/* set the file to be world readable */
X    {
X	sbuf.st_mode |= 0444;
X	chmod(rcfile, sbuf.st_mode);
X    }
X    fclose(fp);
X} /* update_torc */
X
X
X/*
X * filter_buf - remove control characters from a NUL terminated char buffer
X */
X
Xstatic void
Xfilter_buf(buf)
X    char *buf;
X{
X#if 1			/* set to 0 to disable this function */
X    int i;
X    for (i = 0; i < strlen(buf); i++)
X	if (! (isprint(buf[i]) || buf[i] == '\t'))
X	    buf[i] = '?';
X#endif
X} /* filter_buf */
X
X
X/*
X * construct_message -	build message from argv[], or read it from stdin
X */
Xstatic void
Xconstruct_message(me)
X    user_t *me;
X{
X    int		i, pos, len;
X
X    me->message[0] = '\0';
X    if (argc != optind)		/* build up message from argv[] */
X    {
X	pos = len = 0;
X	for (i = optind; i < argc; i++)
X	{
X	    len = strlen(argv[i]);
X	    if (len + pos > sizeof(me->message) - 1)
X		break;
X	    strnc0py(me->message + pos, argv[i], len);
X	    pos += len;
X	    me->message[pos++] = ' ';
X	}
X	me->message[pos] = '\0';
X    }
X    else			/* interactively grab message */
X    {
X	if (!me->tty)		/* don't read message from non-terminal */
X	{
X	    strnc0py(me->message, "I would like to talk to you",
X				sizeof(me->message) - 1);
X	    return;
X	}
X	printf("Message: ");
X	if (fgets(me->message, sizeof(me->message), stdin) == NULL)
X	{
X	    strnc0py(me->message, "I would like to talk to you",
X				sizeof(me->message) - 1);
X	    return;
X	}
X	len = strlen(me->message);
X	if (me->message[len - 1] == '\n')
X	    me->message[--len] = '\0';
X    }
X} /* construct_message */
X
X
X/*
X * send_message -	send the message...
X */
Xstatic void
Xsend_message(me, you)
X    user_t *me, *you;
X{
X    utmp_s *		utent;
X    char		host[MAXHOSTNAMELEN + 2];
X    static char		tty[sizeof(_PATH_DEV)+UT_LINESIZE]=_PATH_DEV;
X    char		*p, *timestr;
X    int			i;
X    FILE *		fp;
X    time_t		now;
X    alist		*pers;
X    struct stat		stbuf;
X#if HAVE_UNAME
X    struct utsname	unamebuf;
X#endif /* HAVE_UNAME */
X    static struct {
X	char		tty[sizeof(tty)];
X	time_t		idle;
X	int		res;
X    } cur;
X#define R_SENT		(1<<0)
X#define R_ISON		(1<<1)
X#define R_VALID		(1<<2)
X#define R_EXCLUDE	(1<<3)
X
X    host[sizeof(host) - 1] = '\0';	/* get hostname _somehow_ */
X    host[0] ='@';
X#if HAVE_GETHOSTNAME
X    if (gethostname(host + 1, sizeof(host) - 2) == -1)
X	host[0] = '\0';
X#else /* !HAVE_GETHOSTNAME */
X#   if HAVE_UNAME
X    if (uname(&unamebuf) == 0)
X	strnc0py(host + 1, unamebuf.nodename, sizeof(host) - 2);
X    else	/* fallthru #endif */
X#   endif /* HAVE_UNAME */
X    host[0] = '\0';
X#endif  /* !HAVE_GETHOSTNAME */
X
X    now = time(NULL);
X    timestr = ctime(&now) + 11;
X    timestr[5] = '\0';
X
X    cur.res = 0;
X    if (flags & DEBUG)
X	printf("DEBUG: me->message is :%s:\n", me->message);
X    load_rcfile(you, you->userid);
X    construct_message(me);
X    pers = you->aliases;
X    while (pers)		/* see if they're excluding you */
X    {
X	if ((strcmp(me->userid, pers->userid) == 0) && (! pers->alias[0]))
X	{
X	    cur.res |= R_EXCLUDE;
X	    break;
X	}
X	pers = pers->next;
X    }
X    if (! (cur.res & R_EXCLUDE))	/* if !excluded, find tty */
X	while ((utent = getutent()) != NULL)
X	{
X	    if (NULL_UTMP_ENTRY(utent))
X		continue;
X	    if (strncmp(utent->ut_name, you->userid, sizeof(utent->ut_name) -1))
X		continue;		/* not them */
X	    cur.res |= R_ISON;
X	    strcpy(tty + sizeof(_PATH_DEV) - 1, utent->ut_line);
X	    if (you->tty)		/* want specific tty */
X	    {
X		if (strcmp(utent->ut_line, you->tty) != 0)
X		    continue;
X		strcpy(cur.tty, tty);
X		cur.res |= R_VALID;
X		break;
X	    }
X	    else
X	    {
X		if (me->tty && strcmp(me->tty, tty) == 0)
X		    continue;		/* don't do my current terminal */
X	    }
X	    i = stat(tty, &stbuf);
X	    if (!cur.idle || ((i != -1) && stbuf.st_atime > cur.idle))
X	    {
X		strcpy(cur.tty, tty);	/* remember idle info */
X		cur.res |= R_VALID;
X		if (i != -1)
X		    cur.idle = stbuf.st_atime;
X	    }
X	} /* while */
X
X					/* if valid tty, attempt to send */
X    if ((cur.res & R_VALID) && ((fp = fopen(cur.tty, "a")) != NULL))
X    {
X	cur.res |= R_SENT;
X	if (flags & BEEP)
X	    fprintf(fp, "%c", BELL);	/* Beep! */
X
X	if (!me->tty)
X	    me->tty = "/dev/tty??";	/* hmm... stdin wasn't stdin */
X	filter_buf(me->name);		/* Clean up your name & message */
X	filter_buf(me->message);	/*   and send it */
X	fprintf(fp, "\r-=> From %s (%s%s) on %s at %s :- \n\r",
X		me->name, me->userid, host,
X		me->tty + sizeof(_PATH_DEV) - 1, timestr);
X	fprintf(fp, "%s  \n\r", me->message);
X	fclose(fp);
X    }
X    p = NULL;
X    filter_buf(you->name);
X    if (cur.res & R_EXCLUDE)		/* They don't like you */
X    {
X	printf("%s: %s (%s) has excluded you as a sender.\n",
X			progname, you->name, you->userid);
X	p = you->exclude;
X    } else if (! (cur.res & R_ISON))	/* They're not on */
X    {
X	printf("%s: %s (%s) isn't logged on.\n",
X			progname, you->name, you->userid);
X	p = you->gone;
X    }
X    else if (! (cur.res & R_SENT))	/* Didn't work for other reason */
X    {
X	if (!(cur.res & R_VALID))
X	{
X	    if ((strncmp(me->userid, you->userid, sizeof(me->userid) - 1) == 0)
X		|| !you->tty)		/* only if >1 usernames on same uid */
X		printf("%s: You are only logged on once.\n", progname);
X	    else			/* Not on specific tty */
X		printf("%s: %s (%s) isn't logged onto the tty '%s'.\n",
X			progname, you->name, you->userid, you->tty);
X	}
X	else				/* No write perms to tty */
X	{
X	    printf("%s: Access to %s's (%s) terminal denied.\n",
X			progname, you->name, you->userid);
X	    p = you->no;
X	}
X
X    }
X    else
X    {
X	if (cur.idle)			/* Have an idle message */
X	{
X	    if (now - cur.idle > min_idle)
X		if (strlen(you->idle))
X		    p = you->idle;
X	}
X	if (p == NULL)
X	    p = you->yes;
X	if (stat(me->tty, &stbuf) != -1)
X	{
X	    if (! (stbuf.st_mode & MESGS_ON))	/* Just to let you know... */
X		printf("Warning: you have your messages disabled. %s can't reply\n", you->name);
X	}
X	printf("Message sent to %s (%s%s) on %s.\n",	/* Print results */
X			you->name, you->userid, host, 
X			cur.tty + sizeof(_PATH_DEV) - 1);
X		/* record where the message really went */
X	strnc0py(me->dottty, cur.tty + sizeof(_PATH_DEV) - 1,
X				sizeof(me->dottty) - 1);
X    }
X    if (p && strlen(p))			/* An autoreply exists */
X    {
X	filter_buf(p);			/* Remove illegal chars */
X	printf("-=> Auto-reply from %s :-\n%s\n", you->name, p);
X    }
X    endutent();
X} /* send_message */
X
X
X/*
X *	main function
X */
Xint
Xmain(margc, margv)
X    int margc;
X    char *margv[];
X{
X    user_t	me_s, *me = &me_s;
X    user_t	you_s, *you = &you_s;
X    char 	*p;
X
X    min_idle = MINIDLE;
X    argc = margc;
X    argv = margv;
X    me->tty = ttyname(0);
X    you->tty = NULL;
X    progname = argv[0];				/* Basename invocation name */
X    if ((p = strrchr(progname, '/')) != NULL)
X	progname = ++p;
X    flags = 0;
X
X    load_rcfile(me, NULL);
X    if (  ((p = getenv("PSEUDONYM")) != NULL)	/* Get default name for you */
X	|| ((p = getenv("NAME")) != NULL))
X    {
X	if (  (strcmp(me->name, p) != 0)
X	    && (!(flags & PSEUDO_MOD)))
X	{
X	    strnc0py(me->name, p, sizeof(me->name) - 1);
X	    flags |= (PSEUDO_MOD + DB_MOD);
X	}
X    }
X    process_options(me, you);
X    if (lookup_user(me, you))
X	send_message(me, you);
X    update_torc(me);
X    return 0;
X} /* main */
END_OF_FILE
  if test 21895 -ne `wc -c <'casu-3.3/to.c'`; then
    echo shar: \"'casu-3.3/to.c'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/to.c'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
