Newsgroups: comp.sources.misc
From: lm@rmit.edu.au (Luke Mewburn)
Subject: v41i078:  casu - comms. & status utils, v3.3, Part03/04
Message-ID: <1994Jan10.025649.4047@sparky.sterling.com>
X-Md4-Signature: 3bf92249c483c0d79f2794f14a265997
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Mon, 10 Jan 1994 02:56:49 GMT
Approved: kent@sparky.sterling.com

Submitted-by: lm@rmit.edu.au (Luke Mewburn)
Posting-number: Volume 41, Issue 78
Archive-name: casu/part03
Environment: UNIX, ANSI-C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  casu-3.3/FLON.rof casu-3.3/TO.rof casu-3.3/casu.h
#   casu-3.3/fileio.c casu-3.3/print.c
# Wrapped by kent@sparky on Sun Jan  9 20:46:38 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 4)."'
if test -f 'casu-3.3/FLON.rof' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/FLON.rof'\"
else
  echo shar: Extracting \"'casu-3.3/FLON.rof'\" \(10759 characters\)
  sed "s/^X//" >'casu-3.3/FLON.rof' <<'END_OF_FILE'
X'\" t
X.\" (the above line is to tell sun's man to run through tbl first)
X.\"
X.\"	flon - lists your friends who are logged on
X.\"
X.\" Part of the CaSU package written by Luke Mewburn <lm@rmit.edu.au>
X.\"
X.\" To format this manual page, format it through a `tbl' compatible
X.\" filter, then through an nroff or troff compatible formatter.
X.\"
X.TH FLON 1 "December 23 1993"
X.SH NAME
Xflon \- show which of your friends are logged on
X.SH SYNOPSIS
X.B flon
X.RB [ \-a ]
X.RB [ \-A ]
X.RB [ \-b ]
X.RB [ \-B ]
X.RB [ \-d ]
X.RB [ \-D ]
X.RB [ \-e ]
X.RB [ \-E ]
X.RB [ \-h ]
X.RB [ \-H ]
X.RB [ \-i ]
X.RB [ \-I ]
X.RB [ \-p\c
X.IR "\ max_idle" ]
X.RB [ \-P\c
X.IR "\ min_idle" ]
X.RB [ \-t ]
X.RB [ \-T ]
X.RB [ \-f\c
X.IR "\ file" ]
X.RB [ \-o\c
X.IR "\ format" ]
X.RB [ \-O ]
X.RB [ \-y\c
X.IR "\ mesgy" ]
X.RB [ \-Y ]
X.RB [ \-n\c
X.IR "\ mesgn" ]
X.RB [ \-N ]
X.RB [ \-U\c
X.IR "\ file" ]
X.RB [ \-v ]
X.RB [ \-V ]
X.RB [ \-w ]
X.SH DESCRIPTION
X.I flon
Xshows which of your friends are currently logged on
Xby matching entries in
X.B /etc/utmp
Xwith entries in
X.BR "$HOME/.friends" ,
Xand displaying the matches.
X.PP
XThe output that can displayed by
X.I flon
Xis extremely configurable, and a variety of information
Xabout your friends can be discovered.
XEven the output of
X.I who
Xcan be emulated, (but
X.I flon
Xis often much faster.)
X.PP
XThe actual
X.B friends file
Xthat
X.I flon
Xuses is user definable.
X.PP
XThe friends file has the following format:
X.TS
Xcenter;
Xl l.
Xuserid	pseudonym
Xuserid	pseudonym
Xuserid	pseudonym
X.TE
X.PP
XAny number of blank lines can occur between userid and pseudonym
Xpairs, and field separators are any white space,
X.B except
Xfor one case: A pseudonym is only terminated
Xby an end of line or EOF, because tabs and spaces can exist in
Xpseudonyms.
X.PP
XInformation such as
X.BR "user name" ,
X.BR "pseudonym" ,
X.BR "real name" ,
X.BR "login time" ,
X.BR "idle time" ,
X.BR "tty" ,
X.BR "remote host"
X(if supported on your system), and
X.B "mesg status"
Xcan all be displayed by
X.IR "flon" .
X.PP
XThe
X.B pseudonym
Xrefers to the entry in the friends file corresponding to a particular
X.BR "user name" .
X.PP
XIf
X.I who
Xis linked to
X.IR "flon" ,
Xthen flon will act much the same as the BSD version of who.
X.SH OPTIONS
X.I flon
Xaccepts the following options:
X.TP
X.B \-a
XShow all entries, irrespective of whether or not they appear in the
Xcurrent friends file.
XIf
X.B "%p"
Xis present in the format string, and the current entry is in the
Xfriends file, the appropriate pseudonym is listed, otherwise a blank
Xentry is displayed.
X.TP
X.B \-A
XThe opposite of
X.BR "\-a" ,
Xthis only lists users in the friends file.
X.TP
X.B \-b
XWhen used in conjunction with the format string specifier
X.BR "%p" ,
Xthen whenever a pseudonym cannot be found for the current entry, the
Xappropriate real name for that user (obtained from the GCOS field of the
X.B /etc/passwd
Xfile) will be used (if there is one.)
XThis option is only useful if
X.B \-a
Xis used.
X.TP
X.B \-B
XThe opposite of
X.BR "\-b" ,
Xwhich only prints pseudonyms with the
X.B "%p"
Xformat specifier.
X.TP
X.B \-d
XDon't print duplicates (where the user name is the same.)
XFor the
X.BR "%l" ,
X.BR "%i" ,
X.BR "%m" ,
Xand
X.B %t
Xoptions,
X.I flon
Xprints the information of the session with the least
Xidle time.
X.TP
X.B \-D
XDo print duplicates.
X(Opposite of
X.BR "\-d" .)
X.TP
X.B \-e
XExclude the listing of your friends.
XThis option implies
X.BR "\-a" .
X.TP
X.B \-E
XInclude the listing of your friends.
X(Opposite of
X.BR "\-e" .)
X.TP
X.B \-h
XDon\'t display the header at the top of the output of
X.IR "flon" .
X.TP
X.B \-H
XDisplay the header at the top of the output.
X.TP
X.B \-i
XDon't display people that have been idle for longer than
Xfive minutes (This cutout time can be changed with
X.BR "\-p" .)
X.TP
X.B \-I
XDisplay people that have been idle for longer than five minutes.
X(Opposite of
X.BR "\-i" .)
X.TP
X.BI \-p " limit"
XSets the idle cutout limit for
X.B \-i
Xand
X.B \-I
Xto
X.IR "limit" .
XThe default unit for this limit is minutes, but a suffix of
X.I "s"
Xor
X.I "S"
Xindicates that the figure is in seconds.
X(A suffix of
X.I "m"
Xor
X.I "M"
Xexplicitly specificies that the units are minutes.)
X.TP
X.BI \-P " limit"
XSet the minimum period at which the idle message switches from
X.RB \` ... \'
Xto the actual value.
XRefer to
X.B \-p
Xfor information on valid suffixes to this figure.
X.TP
X.B \-t
XDon't display the trailer \(em the count of how many times
Xyou are logged on, and the total of how many people are logged on.
X.TP
X.B \-T
XDisplay the trailer.
X.TP
X.BI \-f " file"
XUse
X.I file
Xas the friends file (instead of
X.B $HOME/.friends .)
X.TP
X.BI \-o " format"
XUse
X.I format
Xas the template for
X.IR "flon" 's
Xoutput.
X(See below for the specification of
X.IR "format" .)
X.TP
X.B \-O
XUse the default compiled-in format, which is usually:
X.br
X.BI "%-u | %p | %12l | %i | %t | %2mTalk"
X.TP
X.BI \-y " string"
XUse
X.I string
Xas the string to print in
X.B "%p"
Xwhen messages are on.
X.TP
X.B \-Y
XUse the compiled in default for ontalk, usually
X.RB \` On \'\&.
X.TP
X.BI \-n " string"
XUse
X.I string
Xas the string to print in
X.B "%p"
Xwhen messages are off.
X.TP
X.B \-N
XUse the compiled in default for notalk, usually
X.RB \` No \'\&.
X.TP
X.BI \-U " file"
XUse
X.I file
Xas the utmp file (instead of
X.BR "/etc/utmp" .)
X.TP
X.BI "\-v, \-V"
XDisplay the version, usage and copyright information.
X.TP
X.B \-w
XInvoke
X.I flon
Xas if it was invoked as
X.IR "who" .
X(I.e., simulate that it's name is
X.IR "who" ,
Xto the point where
X.RI \` "flon -w am I" \'
Xacts as
X.RI \` "who am I" \',
Xetc.)
X.SH FORMAT SPECIFIERS
X.I flon
Xhas a highly configurable output, which consists of a format
Xstring with static and variable fields.
XMuch like
X.IR "printf" (3),
Xthe format string of
X.I flon
Xuses the
X.B %
Xcharacter as a specifier for the variable fields.
XThis is the format of the specifier:
X.B %\c
X.RI [ flags ]\c
X.RI [ width ]\c
X.IR "command" .
X.PP
X.I flags
Xare optional.
XThere are two flags currently available:
X.TP
X.B \-
Xuse right justification for formatting that field.
X.TP
X.B \&.
Xuse a variant width record (i.e, extra space won't be added
Xas padding to fill out the field to the required width.)
X.PP
X.I width
Xcan be anything from 0 to 255.
XIf a width of
X.BR "0" ,
Xor no width at all is specified,
Xthe default width for that field is assumed.
X.PP
X.I specifiers
Xcan be any of:
X.TP
X.B %
XA single % sign.
X.TP
X.B u
XUser name of the current entry.
X.TP
X.B r
XReal name of the current entry.
X(From the
X.B /etc/passwd
Xfile.)
X.TP
X.B p
XPseudonym of this person.
XWhen
X.I flon
Xis started with
X.BR "\-a" ,
Xa pseudonym will be shown only for those people who have one in your
Xfriends file.
XThe only exception is when
X.B \-b
Xis used - then the real name will be printed instead (
X.B "%p"
Xacts the same as the
X.B "%r"
Xin this case)
X.TP
X.B l
XLogin time on that particular session.
X.TP
X.B i
XIdle time of that session.
XThe value is in
X.BR "minutes : seconds" .
XIf the string
X.RB \` >>> \'
Xis displayed, the session has been idle longer than 99 minutes, 59
Xseconds.
XIf
X.RB \` ... \'
Xis displayed, the terminal has not been idle for at least 5 minutes.
X(The latter time is changable with
X.BR "\-P" .)
X.TP
X.B t
XThe tty of that particular session.
X.TP
X.B m
X.I mesg
Xstatus of that session.
XIf
X.IR "y" ,
X.RB \` On \'
Xis displayed (unless
X.B \-y
X.I mesgy
Xis defined, then
X.I mesgy
Xwill be displayed.)
XIf it is
X.IR "n" ,
X.RB \` No \'
Xis displayed (or
X.I mesgn
Xif
X.B \-n
X.I mesgn
Xis used.)
X.TP
X.B c
XNumber of times that person is logged on.
X.TP
X.B x
XPrints an
X.RB \` x \'
Xif the number of times logged on is greater than 1.
X.TP
X.B a
XPrints the 
X.I mesgy
Xstring if any of the sessions for that person have messages on.
X(The `availability' field.)
XIf all sessions have messages off, the
X.I mesgn
Xstring is printed.
X.TP
X.B h
XPrint the host that the user logged in from, but only if your system
Xsupports it (via the existance of the
X.I ut_host
Xfield in the 
X.BR "/etc/utmp" .)
XOtherwise, an empty string will be printed.
X.TP
X.B b
XPrint the host (see
X.BR "%h" )
Xin parenthesis if the field is non-empty.
X.SH ENVIRONMENT
X.TP
X.B FLON
XContains default arguments that the user wants
X.I flon
Xto use.
XCommand line options override any settings in
X.IR "FLON" .
X.TP
X\&
XThe
X.I FLON
Xvariable can contain any of the command line arguments.
XIf a string is to have a space in it, it should be quoted with
Xsingle quotes, as:
X.RB \' word1 ... wordn \'
XNote that some options (like
X.BR "\-V" )
Xwont make sense in the environment variable.
X.TP
X\&
XFor example (in
X.IR "csh" (1))
X.IP
Xsetenv FLON "-ip30 -o'%-u %32p'"
X.TP
X\&
Xwill mean that by default,
X.I flon
Xwon't print sessions idle longer than 30 minutes, and for each friend,
Xonly the username (right justified), and the pseudonym (field width of
X32 characters) will be printed.
X.SH FILES
X.PD 0
X.TP 20
X.B $\s-1HOME\s0/.friends
X.TP 20
X.B /etc/utmp
X.TP 20
X.B /etc/passwd
X.PD
X.SH EXAMPLE FRIENDS FILE
X.TS
Xl l.
Xs902113	Zak
Xroot	Deus ex Machina
Xzrmitcs	Rmit Computer Society
Xnroot	Root with a _REAL_ shell
X.TE
X.SH SEE ALSO
X.IR "who" (1),
X.IR "utmp" (5).
X.SH LIMITATIONS
XThe maximum width of any specified field is 255 characters.
X.PP
X.SH WARNINGS
XIf a tty in /dev cannot be statted, flon will print an entry
Xfor that user, but without the mesg or idle status.
X.PP
XIf the friends file is unavailable (due to permissions or non-existance),
Xthen flon will operate as if run with the
X.I \-a
X(list all) option, with no pseudonyms.
X.SH HISTORY
X.I flon
Xhas a long line of ancestors.
XMany years ago at RMIT, on the
X.I Cyber 760
Xrunning
X.IR "NOS" ,
XMarc Boschma [Tau] wrote lon.
XPrimitive as it was, it did the job, looking up your friends logged on.
XWhen UNIX arrived at RMIT, it was soon ported, with a version by Simon
XBurge [Snark] also appearing.
XOther versions were written, including a derivative
X.IR "bcoh" .
XThe problem was that
X.IR "lon" ,
X.IR "bcoh" ,
Xand all the derivatives were slow, and lacked
X.IR "rampant featuritus"
X(although some may consider this lack a
X.BR "good thing" .)
XThese factors prompted me to write
X.IR "flon" .
X.PP
XFor their suggestions, bug fixes, and hints, thanks go to:
X.TS
Xcenter;
Xl l.
XAlbert Zvara	<s902117@minyos.xx.rmit.oz.au>
XAndrew Vanderstock	<rxkajv@minyos.xx.rmit.oz.au>
XCedric	<rcv@ukc.ac.uk>
XCraig Humphrey	<Craig.Humphrey@comp.vuw.ac.nz>
XDavid W. Sanderson	<dws@ssec.wisc.edu>
XHoward Picaizen	<doctor@binkley.cs.mcgill.ca>
XKeith	<basil@cs.odu.edu>
XKen Weaverling	<weave@pima.dtcc.edu>
XMarc Boschma	<s861298@minyos.xx.rmit.oz.au>
XMatthew Korth	<sparhawk@camelot.bradley.edu>
XJohn DuBois	<spcecdt@armory.com>
XStuart Bishop	<zen@rmit.edu.au>
XWes W. Price II	<ww2@bullwinkle.ssc.gov>
XWillem Kasdorp	<wkasdo@nikhefk.nikhef.nl>
X.TE
X.PP
X.SH AUTHOR
XLuke Mewburn, <lm@rmit.edu.au>.
X.PP
XPortions of the environment variable code are derived from code from
X.IR "gzip" ,
Xby Jean-loup Gailey, which in turn was derived from code I donated
Xto that package.
X.SH VERSION
XThis manual documents
X.I flon
Xversion 3.3.1, 931223.
END_OF_FILE
  if test 10759 -ne `wc -c <'casu-3.3/FLON.rof'`; then
    echo shar: \"'casu-3.3/FLON.rof'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/FLON.rof'
fi
if test -f 'casu-3.3/TO.rof' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/TO.rof'\"
else
  echo shar: Extracting \"'casu-3.3/TO.rof'\" \(8063 characters\)
  sed "s/^X//" >'casu-3.3/TO.rof' <<'END_OF_FILE'
X'\" t
X.\" (the above line is to tell sun's man to run through tbl first)
X.\"
X.\"	To - send a one line message to another user
X.\"
X.\" Part of the CaSU package written by Luke Mewburn <lm@rmit.edu.au>
X.\"
X.\" To format this manual page, format it through a `tbl' compatible
X.\" filter, then through an nroff or troff compatible formatter.
X.\"
X.TH TO 1 "December 23 1993"
X.SH NAME
Xto \- send a one line message to another user.
X.SH SYNOPSIS
X.B to
X.RB [ \-a\c
X.IR "\ alias\ user" ]
X.RB [ \-b ]
X.RB [ \-e\c
X.IR "\ user" ]
X.RB [ \-h ]
X.RB [ \-l ]
X.RB [ \-r ]
X.RB [ \-t\c
X.IR "\ term" ]
X.RB [ \-u\c
X.IR "\ alias" ]
X.RB [ \-n ]
X.RB [ \-y ]
X.RB [ \-P\c
X.IR "\ pseudonym" ]
X.RB [ \-G\c
X.IR "\ gonereply" ]
X.RB [ \-N\c
X.IR "\ noreply" ]
X.RB [ \-Y\c
X.IR "\ yesreply" ]
X.RB [ \-I\c
X.IR "\ idlereply" ]
X.RB [ \-X\c
X.IR "\ excludereply" ]
X[
X.I user
X[ 
X.IR message
X] ]
X.SH DESCRIPTION
X.I to
Xsends a short message to another user.
XThe default format for the message that the destination user receives is:
X.IP
X-=> From user ( userid@host ) on ttyxx at 12:00 :-
X.br
X.I message
X.PP
XThe recipient of the message can, at this point, choose to reply
Xusing the same method.
XIf the recipient has defined an
X.B auto-reply
Xmessage, you will receive a message back of the form:
X.IP
X-=> Auto-reply from username :-
X.br
X.I message
X.PP
XAll of the arguments to
X.I to
Xafter the username are treated as part of the message.
XIf a message isn't specified, then you are prompted to enter a
Xmessage interactively.
XThis is useful if you wish to enter a message that has characters
Xwhich would need to be escaped from the shell, and you're too
Xlazy to do that.
XIf no message is entered, then
X.RI \` "I would like to talk to you" \'
Xis sent.
X.PP
XYou can specify a user by a username, an alias, or with
X.RB \` \&. \'
X(a period.)
XThe use of a period indicates that you wish to send the message to
Xthe last person that you sent a message to (if you've sent one.)
XThe message will be sent to the same tty as last time unless you
Xspecify a new tty via the
X.B \-t
Xoption.
X.PP
XIf an alias is defined for the user string you entered, it will be
Xused, otherwise 
X.I to
Xwill attempt to send the message to the user on the system with
Xthat name.
X.PP
XIf the recipient is logged on in more that one place, the message will
Xbe sent to the terminal with the least idle time (unless a specific
Xterminal is requested via
X.BR \-t .)
XIf you are sending a message to yourself, the current terminal will
Xonly receive a message if you explicitly state it as the destination
Xterminal (This is useful if a friend is logged under your userid and
Xyou wish to send them a message.)
X.PP
XYou can exclude a user from transmitting a message to you by adding
Xthem to your exclude list (by using the
X.B \-e
Xcommand line option.)
X.PP
XAuto-reply messages are returned to you depending upon the conditions
Xin which the message was received.
XThey are:
X.TP
X.B gone
XThe auto-reply for when the recipient isn't logged on.
X.TP
X.B idle
XThe auto-reply for when you are idle more than 5 minutes (overrides the
X.B yes
Xmessage.)
X.TP
X.B no
XThe auto-reply for when the message didn't get through.
X.TP
X.B yes
XThe auto-reply for when the message was successfully sent.
X(Useful for when you are working or you're temporarily busy, and want
Xto let the message to still get through.)
X.TP
X.B exclude
XThe auto-reply message to people you've excluded.
X.PP
XBy default,
X.I to
Xuses your name from the
X.B /etc/passwd
Xfile.
XThis is overridden (in ascending order) by the environment variable
X.BR NAME ,
Xthe environment variable
X.BR PSEUDONYM ,
Xand finally, the
X.B \-p
Xcommand line option.
X.PP
XIf you have your messages disabled, and you are sending a message to a user
Xother than yourself, you will receive a warning telling you that the the
Xrecipient can't respond.
X.SH OPTIONS
X.I to
Xaccepts the following options (in any combination):
X.TP
X.BI \-a " alias userid"
XDefine an alias,
X.I alias
Xfor the user
X.IR "userid" .
X.TP
X.B \-b
XBeep the recipient (with an ASCII BELL character.)
X.TP
X.BI \-e " userid"
XAdd
X.I userid
Xto the list of people you've excluded from sending you messages.
X.TP
X.B \-h
XDisplay a usage and help page.
X.TP
X.B \-l
XList all the aliases that you have defined.
X.TP
X.B \-r
XDisplay some status about
X.IR to ,
Xincluding: mesg status, current name, current terminal, yes auto-reply,
Xno auto-reply, gone auto-reply, and last user.
X.TP
X.BI \-t " term"
XForce the message to be sent to the terminal
X.IR "term" .
XIt will only be sent if the recipient is currently using that terminal.
X.TP
X.BI \-u " alias"
XRemove 
X.I alias
Xfrom your alias list.
X.TP
X.BI "\-n, \-y"
XSet the
X.B mesg
Xstatus to off or on respectivly.
XThis performs the same purpose as
X.IR "mesg" (1).
X.TP
X.BI \-P " pseudonym"
XSets your pseudonym.
X.TP
X.BI \-Y " yesmess"
XSets your auto-reply message for when a message gets through successfully.
X.TP
X.BI \-I " idlemess"
XSets your auto-reply message for when a message gets through
Xsuccessfully and the recipient (you) has been idle for more than
Xfive minutes.
X.TP
X.BI \-N " nomess"
XSets your auto-reply message for when a transmission is unsuccessful.
X.TP
X.BI \-G " gonemess"
XSets your auto-reply message for when you aren't logged on.
X.TP
X.BI \-X " excludemess"
XSets your auto-reply message to send to a person who you've excluded.
X.TP
X.B \-V
XDisplay the usage and copyright information.
X.SH ENVIRONMENT
X.TP 12
X.B PSEUDONYM
XName to display when sending messages and auto-replies.
X.TP
X.B NAME
XUsed if
X.B PSEUDONYM
Xisn't defined.
X.SH FILES
X.PD 0
X.TP 20
X.B $\s-1HOME\s0/.torc
X.TP 20
X.B /etc/utmp
X.TP 20
X.B /etc/passwd
X.PD
X.PP
XThe
X.B .torc
Xfile is an ASCII file, which may be directly edited rather than using
Xthe command line options (although the author doesn't recommend this
Xtechnique.)
XEach line has the following format:
X.br
X\- A single character type specifier (case insensitive, but shown
Xwith case here for mnemonic reference with the command line options.)
X.br
X\- A single space
X.br
X\- The arguments to the command.
X.PP
XThe following characters are valid as type specifiers:
X.TP 3
X.B \&.
XThe last person to whom you sent a message.
X.TP
X.B :
XThe tty of the last person to whom you sent a message.
X.TP
X.B Y
XThe
X.I yes
Xauto-reply.
X.TP
X.B N
XThe
X.I no
Xauto-reply.
X.TP
X.B G
XThe
X.I gone
Xauto-reply.
X.TP
X.B I
XThe
X.I idle
Xauto-reply.
X.TP
X.B X
XThe
X.I exclude
Xauto-reply.
X.TP
X.B P
XThe pseudonym which is printed in the auto-reply.
X.TP
X.B a
XAn alias. This takes the format of
X.IR "alias userid" ,
Xwith whitespace separating the two elements
X.TP
X.B e
XAn excluded user.
X.PP
XAn unknown specifier or illegal line will be silently ignored by
X.IR "to" .
X.SH SEE ALSO
X.IR "mesg" (1),
X.IR "utmp" (5),
X.IR "talk" (1),
X.IR "write" (1).
X.SH LIMITATIONS
XThe maximum length of a userid is 8 characters.
XThe maximum length of an alias is 16 characters.
XThe maximum length of an auto-reply, pseudonym, or message is 256 characters.
XAny non-ASCII, or control characters in the message will be replaced with
Xa
X.RB \` ? \'\&.
X.PP
X.I to
Xcan only send an auto-reply message to another user if that user has
Xworld read access (\fI\-rw\-r\-\-r\-\-\fP) to your
X.I .torc
Xfile, and at least search access (\fIdrwx\-\-x\-\-x\fP)
Xto your home directory.
X.PP
XThe message that you send appears on the command line, and thus, can
Xbe read (for a short time), by the use of commands such as
X.IR "ps" (1).
XIf you want to send top secret or personal messages, you shouldn't
Xbe using electronic media!
X.SH HISTORY
X.I to
Xwas inspired by (and is upwardly compatible with) a program written
Xby Steve Riehm [Romulis].
XSteve's version was based on one by Simon Burge [Snark].
X.PP
XFor their inspiration, ideas and bug reports, thanks must go to:
X.TS
Xcenter;
Xl l.
XAndrew Vanderstock	<rxkajv@minyos.xx.rmit.oz.au>
XCraig Humphrey	<Craig.Humphrey@comp.vuw.ac.nz>
XJohn DuBois	<spcecdt@armory.com>
XKeith	<basil@cs.odu.edu>
XKen Weaverling	<weave@pima.dtcc.edu>
XMarc Boschma	<s861298@minyos.xx.rmit.oz.au>
XSteve Riehm	<ln-smr@pki-nbg.philips.de>
XWillem Kasdorp	<wkasdo@nikhefk.nikhef.nl>
X.TE
X.SH AUTHOR
XLuke Mewburn, <lm@rmit.edu.au>.
X.SH VERSION
XThis manual documents
X.I to
Xversion 3.3.1, 931223.
END_OF_FILE
  if test 8063 -ne `wc -c <'casu-3.3/TO.rof'`; then
    echo shar: \"'casu-3.3/TO.rof'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/TO.rof'
fi
if test -f 'casu-3.3/casu.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/casu.h'\"
else
  echo shar: Extracting \"'casu-3.3/casu.h'\" \(11418 characters\)
  sed "s/^X//" >'casu-3.3/casu.h' <<'END_OF_FILE'
X/*
X *  CaSU - communications & status utilities.
X *  Copyright (C) 1992, 1993 Luke Mewburn <lm@rmit.edu.au>
X *	incorporating:
X *	   flon - lists your friends who are logged on.
X *	   to - send a short message to a friend
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *  
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *  
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X
X
X#include "patchlevel.h"		/* for VERSION */
X
X
X#if STDC_HEADERS
X#   define __PROT(prototype)	prototype
X    typedef void *		voidptr;
X#else
X#   define __PROT(prototype)	()
X    typedef char *		voidptr;
X#endif /* STDC_HEADERS */
X
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/stat.h>
X#include <sys/time.h>
X#if HAVE_UNISTD_H
X#   include <unistd.h>
X#endif /* HAVE_UNISTD_H */
X#if HAVE_STDLIB_H || STDC_HEADERS
X#   include <stdlib.h>
X#else  /* !HAVE_STDLIB_H && !STDC_HEADERS */
X#   if !MALLOC_DECL
X	extern void 	free	__PROT((voidptr));
X	extern voidptr 	malloc	__PROT((size_t));
X	extern voidptr 	calloc	__PROT((size_t, size_t));
X#   endif /* !MALLOC_DECL */
X#endif  /* !HAVE_STDLIB_H && !STDC_HEADERS */
X#include <string.h>
X#include <ctype.h>
X#include <fcntl.h>
X#include <errno.h>
X#include <pwd.h>
X#include <limits.h>
X#if HAVE_PATHS_H
X#   include <paths.h>		/* for _PATH_DEV */
X#endif /* HAVE_PATHS_H */
X#if NEED_NETDB_H
X#   include <netdb.h>
X#endif /* NEED_NETDB_H */
X#if HAVE_UNAME && HAVE_SYS_UTSNAME_H
X#   include <sys/utsname.h>
X    extern int		uname		__PROT((struct utsname *));
X#endif
X#if HAVE_GETHOSTNAME && !GETHOSTNAME_DECL
X    extern int		gethostname	__PROT((char *, size_t));
X#endif /* HAVE_GETHOSTNAME && !GETHOSTNAME_DECL */
X
X#ifndef MAXPATHLEN
X#   ifdef PATH_MAX
X#	define MAXPATHLEN	PATH_MAX
X#   else
X#	define MAXPATHLEN	256
X#   endif
X#endif
X
X#ifndef MAXHOSTNAMELEN
X#   define MAXHOSTNAMELEN	256
X#endif
X
X#if HAVE_UTMPX_H
X#   include <utmpx.h>			/* assume includes <utmp.h> */
X#   define PATH_UTMP		UTMPX_FILE
X#   define getutent		getutxent
X#   define endutent		endutxent
X    typedef struct utmpx	utmp_s;
X#   define UT_TIME		ut_tv.tv_sec
X#else /* !HAVE_UTMPX_H */
X#   include <utmp.h>
X#   define UT_TIME		ut_time
X    typedef struct utmp		utmp_s;
X#endif /* !HAVE_UTMPX_H */
X#ifndef PATH_UTMP			/* don'cha love standards? */
X#   ifdef _PATH_UTMP
X#       define PATH_UTMP _PATH_UTMP
X#   else
X#	ifdef UTMP_FILE
X#	    define PATH_UTMP UTMP_FILE
X#	else
X#	    define PATH_UTMP "/etc/utmp"
X#	endif
X#   endif
X#endif
X
X#ifndef _PATH_PASSWD
X#   define _PATH_PASSWD	"/etc/passwd"
X#endif
X
X
Xextern utmp_s Kludge;
X#ifndef UT_NAMESIZE
X#   define UT_NAMESIZE	sizeof(Kludge.ut_name)
X#endif
X
X#ifndef UT_HOSTSIZE
X#   if HAVE_UT_HOST
X#	define UT_HOSTSIZE	sizeof(Kludge.ut_host)
X#   else
X#	define UT_HOSTSIZE	UT_NAMESIZE
X#   endif
X#endif /* not UT_HOSTSIZE */
X
X#ifndef UT_LINESIZE
X#   define UT_LINESIZE	sizeof(Kludge.ut_line)
X#endif
X
X		/* SYS V utmp format */
X#if HAVE_UT_TYPE
X#   define NULL_UTMP_ENTRY(x)	((x)->ut_type != USER_PROCESS \
X				|| (x)->ut_name[0] == '\0')
X#else
X		/* BSD utmp format */
X#   define NULL_UTMP_ENTRY(x)	((x)->ut_name[0] == '\0')
X#endif
X
X
Xextern	char	*optarg;
Xextern	int	optind,	opterr, errno;
X
Xextern char *sys_errlist[];
X
X#if !HAVE_STRERROR
X#   define strerror(x)	sys_errlist[x]
X#endif
X
X
X#ifndef _PATH_DEV
X#    define _PATH_DEV	"/dev/"
X#endif /* _PATH_DEV */
X
X#define	MINIDLE		300	/* 5 mins; flon: for `...', to: for idlereply */
X#define	MAXIDLE		6000	/* 100 mins */
X#define ONEDAY		60*60*24
X#define IDLE_MULTIPLY	60	/* default unit for -p & -P is minutes */
X#define NUM_SPECIFIERS	12	/* number of specifier types (%args) in -o */
X#define ALIASLEN	16	/* len of `to' alias */
X#define LINESIZ		256	/* nice figure */
X#define BELL		7
X
X#define STRuser		"USER"
X#define	STRhome		"HOME"
X#define	STRflon		"FLON"
X#define STRsep		"\014\n\r\t "
X#define STReoln		"\014\n\r"
X#define STRtorc		"/.torc"
X#define	STRdotfriends	".friends"
X#define STRformat	"%-u | %p | %12l | %i | %t | %2mTalk"
X#define STRyes		"On"
X#define STRno		"No"
X
X#define PWsep		":"
X#define PWGCOSsep	":,"
X#define PWeoln		STReoln
X
X#define	WHO_PROG	"who"
X#define WHO_NULLTTY	"tty??"
X#define WHO_AM_I_FMT	"%.*s  %.7s  %.12s\n"
X#if HAVE_UT_HOST
X#   define WHO_FORMAT	"%u %7t %12l %.34b"
X#else
X#   define WHO_FORMAT	"%u %7t %12l"
X#endif
X
X#if TTY_RESTRICTED
X#   define MESGS_ON	020
X#else
X#   define MESGS_ON	022		/* mask if messages are on */
X#endif
X
X
Xenum			/* flon flags */
X{
X    NO_HEADER=	(1<<0),	/* don't want header */
X    NO_TAILER=	(1<<1),	/* don't want tailer */
X    ONE_ONLY=	(1<<2),	/* remove duplicates */
X    ALL_ON=	(1<<3),	/* list all on */
X    NO_IDLE=	(1<<4),	/* remove idle entries */
X    BEST_NAME=	(1<<5),	/* print real name if no pseudonym */
X    NEED_STAT=	(1<<6),	/* need to stat() the ttys */
X    NEED_FFILE=	(1<<7),	/* need to load ~/.friends */
X    NEED_PASSWD=(1<<8),	/* need to load /etc/passwd */
X    BLANKF=	(1<<9),	/* field is to be blanked */
X    NO_MATES=	(1<<10),/* exclude friends */
X	/* expansion room */
X    ERROR_OPT=	(1<<14),/* error somewhere */
X    COPYLEFT=	(1<<15)	/* display copyleft: always must be after ERROR_OPT */
X};
X
Xenum			/* to flags */
X{
X    DEBUG=		(1<<0),
X    BEEP=		(1<<1),
X    LISTALIAS=		(1<<2),
X    STATUS=		(1<<3),
X    MESG_N=		(1<<4),
X    MESG_Y=		(1<<5),
X    HELP=		(1<<6),
X    LISTVERSION=	(1<<7),
X    ERROR=		(1<<8),
X    DB_MOD=		(1<<9),
X    PSEUDO_MOD=		(1<<10)
X};
X
Xenum			/* contains printdat cmd info */
X{
X    MAX_WIDTH =	0x00FF,	/* max val of an 8 bit unsigned entity */
X    C_WIDMASK =	0x00FF,	/* mask for widths */
X    C_NULL =	0x0100,	/* empty space */
X    C_USER =	0x0200,	/* username */
X    C_PSEUDO =	0x0300,	/* pseudonym */
X    C_REAL =	0x0400,	/* real name */
X    C_COUNT =	0x0500,	/* # times on */
X    C_X =	0x0600,	/* an 'x' */
X    C_LOGIN =	0x0700,	/* login time */
X    C_IDLE =	0x0800,	/* idle time */
X    C_TTY =	0x0900,	/* terminal */
X    C_MESG =	0x0A00,	/* mesg status */
X    C_AVAIL =	0x0B00,	/* availability */
X    C_HOST =	0x0C00,	/* remote host */
X    C_HOSTBRK =	0x0D00, /* remote host (in parenthesis) */
X    C_CMDMASK =	0x3F00,	/* mask for cmds */
X    C_VARIENT =	0x4000,	/* varient width */
X    C_RIGHT =	0x8000	/* right align */
X};
X
X
Xtypedef struct		/* flon: name/pseudonym pair struct */
X{
X	char name[UT_NAMESIZE+1];
X	char *pseudo;
X} frend;
X
Xtypedef struct		/* relevant info from passwd db */
X{
X    char *	username;	/* user name */
X    uid_t	uid;		/* uid */
X    char *	gcos;		/* real name */
X} upwd;
X
Xtypedef struct alist_S	/* to: linked list of alias/username for */
X{
X    char		userid[ UT_NAMESIZE + 1 ];
X    char		alias[ ALIASLEN + 1 ];	/* [0] == 0 if exclude entry */
X						/* otherwise, it's an alias */
X    struct alist_S	*next;
X} alist;
X
Xtypedef struct		/* to: stores all info from ~/.torc for src & dest */
X{			/*	an entry is unused if [0] == 0 */
X    char	userid[ UT_NAMESIZE + 1];	/* username */
X    char	name[ LINESIZ + 1 ];		/* realname or pseudo */
X    char	homedir[ MAXPATHLEN + 1 ];	/* $HOME */
X    char	dotuser[ UT_NAMESIZE + 1 ];	/* last user `.user' */
X    char	dottty[ UT_LINESIZE + 1 ];	/* last user's tty  */
X    char	yes[ LINESIZ + 1 ];		/* `yes' autoreply */
X    char	no[ LINESIZ + 1 ];		/* `no' autoreply */
X    char	gone[ LINESIZ + 1 ];		/* `gone' autoreply */
X    char	idle[ LINESIZ + 1 ];		/* `idle' autoreply */
X    char	exclude[ LINESIZ + 1 ];		/* `exclude' autoreply */
X    char 	message[ LINESIZ + 1 ];		/* actual message to send */
X    alist *	aliases;			/* linked list of aliases */
X    char *	tty;				/* pointer to tty name */
X} user_t;
X
X
X
X#ifdef _MAIN_			/* only declare storage once for globals */
X#   define GLOBAL
X#else
X#   define GLOBAL	extern
X#endif
X
XGLOBAL int	flags;			/* various flags */
XGLOBAL char *	progname;		/* basename of this invocation */
XGLOBAL int	min_idle, max_idle;	/* minimum & maximum idle cutouts */
XGLOBAL struct				/* print buffer for flon */
X    {
X	int	*cmds;			/* 	command array */
X	char	*form;			/* 	format/template array */
X	char	*buf;			/* 	temp buffer */
X    } printdat;
X
XGLOBAL frend *	friends_list;		/* dynamic array of friends */
XGLOBAL int	friends_count;		/* size of friends_list */
X
XGLOBAL char *	utmp_file;		/* name of UTMP file to use */
XGLOBAL utmp_s *	utmp_list;		/* dynamic array of UTMP entries */
XGLOBAL int	utmp_count;		/* size of utmp_list */
X
XGLOBAL upwd *	pw_list;		/* dynamic array of upwd entries */
XGLOBAL int	pw_count;		/* size of pw_list */
X
X
X
X/*
X *	library & system call prototypes
X */
X
Xextern int	atoi		__PROT((const char *));
Xextern int	chmod		__PROT((const char *, mode_t));
Xextern int	close		__PROT((int));
Xextern char	*ctime		__PROT((const time_t *));
Xextern void	exit		__PROT((int));
Xextern int	fstat		__PROT((int, struct stat *));
Xextern char	*getenv		__PROT((const char *));
Xextern void	nqsort		__PROT((void *, size_t, size_t, int (*)()));
Xextern void	*nbsearch	__PROT((const void *, const void *,
X				    size_t, size_t, int (*)()));
X#if !OPEN_DECL
X    extern int	open		__PROT((const char *, int, ...));
X#endif /* !OPEN_DECL */
X#if !READ_DECL
X    extern int	read		__PROT((int, void *, unsigned));
X#endif /* !READ_DECL */
Xextern int	stat		__PROT((const char *, struct stat *));
Xextern char	*strcat		__PROT((char *, const char *));
Xextern int	strcmp		__PROT((const char *, const char *));
Xextern int	strncmp		__PROT((const char *, const char *, size_t));
Xextern size_t	strlen		__PROT((const char *));
Xextern time_t	time		__PROT((time_t *));
Xextern char	*getlogin	__PROT((void));
Xextern char	*strncpy	__PROT((char *, const char *, size_t));
Xextern char	*ttyname	__PROT((int));
Xextern uid_t	getuid		__PROT((void));
Xextern gid_t	getgid		__PROT((void));
Xextern int	setgid		__PROT((gid_t));
Xextern int	getopt		__PROT((int, char * const *, const char *));
Xextern utmp_s	*getutent	__PROT((void));
Xextern void	endutent	__PROT((void));
Xextern struct passwd  *getpwuid	__PROT((uid_t));
Xextern struct passwd  *getpwnam	__PROT((const char *));
X#ifndef toupper			/* damn #defines in non __STDC__ ... */
X    extern int	toupper		__PROT((int));
X    extern int	tolower		__PROT((int));
X#endif
X
X
X/*
X *	local prototypes
X */
X
X    /* main.c */
Xvoid	who_main		__PROT((int, char *[]));
X    /* init.c */
Xvoid	add_envopt		__PROT((int *, char **[], char *));
Xvoid	parse_options		__PROT((int, int, char *[], char **,
X					char **, char **, char **));
Xvoid	parse_format		__PROT((char *));
X    /* getfile.c */
Xint	compare_utmp		__PROT((const void *, const void *));
Xint	compare_friends		__PROT((const void *, const void *));
Xint	compare_users		__PROT((const void *, const void *));
Xvoid	get_utmp		__PROT((int));
Xvoid	get_friends		__PROT((char *));
Xvoid	get_passwd		__PROT((char *));
X    /* print.c */
Xvoid	print_output		__PROT((char *, char *));
Xvoid	who_am_I		__PROT((void));
X    /* various.c */
Xvoid	errmesg			__PROT((char *, char *));
Xvoid	errexit			__PROT((char *, char *));
Xchar	*get_username		__PROT((void));
Xchar	*convert_realname	__PROT((char *, char *, int));
Xchar	*strnc0py		__PROT((char *, char *, size_t));
END_OF_FILE
  if test 11418 -ne `wc -c <'casu-3.3/casu.h'`; then
    echo shar: \"'casu-3.3/casu.h'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/casu.h'
fi
if test -f 'casu-3.3/fileio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/fileio.c'\"
else
  echo shar: Extracting \"'casu-3.3/fileio.c'\" \(9762 characters\)
  sed "s/^X//" >'casu-3.3/fileio.c' <<'END_OF_FILE'
X/*
X *  CaSU - communications & status utilities.
X *  Copyright (C) 1992, 1993 Luke Mewburn <lm@rmit.edu.au>
X *	incorporating:
X *	   flon - lists your friends who are logged on.
X *	   to - send a short message to a friend
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *  
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *  
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X
X#include "casu.h"
X
X/*
X *	compare_utmp
X */
X
Xint
Xcompare_utmp(entry1, entry2)
X    const void *entry1, *entry2;
X{
X    /*
X     * first, weight the null umtp entries so that they get
X     * moved to the higher end of the list.
X     */
X
X    if (   NULL_UTMP_ENTRY((utmp_s *) entry1)
X	&& NULL_UTMP_ENTRY((utmp_s *) entry2))
X    	return 0;
X    if (NULL_UTMP_ENTRY((utmp_s *) entry1))
X    	return 1;
X    if (NULL_UTMP_ENTRY((utmp_s *) entry2))
X    	return -1;
X	/* otherwise, just return with normal comparison values. */
X    return(strncmp(( (utmp_s *) entry1)->ut_name,
X		    ((utmp_s *) entry2)->ut_name, UT_NAMESIZE));
X} /* compare_utmp */
X
X
X/*
X *	compare_friends
X */
X
Xint
Xcompare_friends(entry1, entry2)
X    const void *entry1, *entry2;
X{
X	/* just compare the name fields of the friends entry. */
X    return (strcmp(((frend *) entry1)->name, ((frend *) entry2)->name));
X} /* compare_friends */
X
X
X/*
X *	compare_users
X */
X
Xint
Xcompare_users(entry1, entry2)
X    const void *entry1, *entry2;
X{
X	/* just compare the username fields */
X    return (strcmp(((upwd *) entry1)->username, ((upwd *) entry2)->username));
X} /* compare_users */
X
X
X/*
X *	get_utmp
X */
X
Xvoid
Xget_utmp(sort_required)
X    int sort_required;
X{
X    struct stat	statbuf;
X    int		utmp_fd;
X    long	filesiz;
X
X	/* prepare to read file into large chunk of memory */
X    if ((utmp_fd = open(utmp_file, O_RDONLY, 0)) == -1)
X	errexit(strerror(errno), utmp_file);
X    if (fstat(utmp_fd, &statbuf)== -1)
X	errexit(strerror(errno), utmp_file);
X    filesiz=(long) statbuf.st_size;
X    if ((utmp_list = (utmp_s *) malloc(filesiz+1)) == NULL)
X	errexit(strerror(errno), NULL);
X
X	/* read in the utmp file in one chunk */
X    if ((filesiz=read(utmp_fd, (char *) utmp_list, statbuf.st_size))==-1)
X	errexit(strerror(errno), utmp_file);
X
X	/* terminate the list, and close the file. */
X    ((char *) utmp_list)[filesiz]='\0';
X    if (close(utmp_fd) == -1)
X	errexit(strerror(errno), utmp_file);
X
X	/* sort the file, and set utmp_count to the # of valid entries */
X    filesiz /= sizeof(utmp_s); 	/* num entries in list */
X    if (sort_required)
X    {
X	nqsort(utmp_list, filesiz, sizeof(utmp_s), compare_utmp);
X	for (utmp_count=0;
X	     !(NULL_UTMP_ENTRY(&utmp_list[utmp_count]));
X	     utmp_count++)
X	    if (utmp_count >= filesiz)
X	    	break;
X    }
X    else
X	utmp_count = filesiz;
X} /* get_utmp */
X
X
X
X/*
X *	get_friends
X */
X
Xvoid
Xget_friends(frfile)
X    char *frfile;
X{
X    char	*tfb, *ffbufr, f_path[MAXPATHLEN], *envhome;
X    struct stat	stbufr;
X    int		loop, ffd;
X    long	filesiz;
X
X    f_path[0]='\0';
X    /*
X     * If frfile is not null, assume this is a user specified
X     * friends file, otherwise, get $HOME/.friends
X     */
X    if (frfile == NULL)
X    {
X		/* XXX: maybe this could use pwent->pw_dir, not $HOME */
X	if ((envhome=getenv(STRhome)) == NULL)
X	    errexit("Undefined variable", "HOME");
X	strcat(f_path, envhome);
X	strcat(f_path, "/");
X	frfile = STRdotfriends;
X    }
X
X	/* dump out if the resultant path will be too long. */
X    if ((int)strlen(f_path) + (int)strlen(frfile) >= MAXPATHLEN)
X    	errexit("Path too long", frfile);
X    strcat(f_path, frfile);
X
X    /*
X     * open and fstat the file, and malloc ram for the entire
X     * thing. Note, I use the open()/fstat() combination instead of
X     * the stat()/open() one, because once I have a file descriptor
X     * to the file, it can't be unlinked on me
X     */
X    if ((ffd = open(f_path, O_RDONLY, 0)) == -1)
X    	if (errno == ENOENT)
X	{
X    	    friends_list=NULL;
X	    flags |= ALL_ON;
X    	    return;
X    	}
X	else
X	    errexit(strerror(errno), f_path);
X    if (fstat(ffd, &stbufr)== -1)
X	errexit(strerror(errno), f_path);
X    filesiz=(long) stbufr.st_size;
X    ffbufr = (char *) malloc(sizeof(char) * (filesiz+1));
X    if (ffbufr == NULL)
X	errexit(strerror(errno), NULL);
X    if ((filesiz=read(ffd, ffbufr, stbufr.st_size))==-1)
X	errexit(strerror(errno), f_path);
X
X	/* nul terminate and close the file. */
X    (ffbufr)[filesiz]='\0';
X    if (close(ffd) == -1)
X	errexit(strerror(errno), f_path);
X
X    friends_count = 0;
X    tfb=ffbufr;
X
X    /*
X     * break up the friends file into alternating
X     * nul terminated names and pseudonyms.
X     */
X    while (1)
X    {
X    	/* find the start of the name (skipping CR and spaces) */
X    	tfb += strspn(tfb, STRsep);
X	if ( tfb >= &ffbufr[filesiz] )
X	    break;		/* exit if off end of buffer */
X    /*  for now, ignore NULs in friends file
X    	if (!(*tfb))
X    	    break;
X    */
X    	tfb += strcspn(tfb, STRsep);
X    	/* got end of name. If no trailing pseudo, error occurs */
X    	if ( !( *tfb ) || ( tfb >= &ffbufr[filesiz] ) )
X    	    errexit("Invalid format of friends file", NULL);
X    	*tfb++ = '\0';		/* ok, got name.... */
X
X    	/* find start of pseudonym, skipping all white space */
X    	tfb += strspn(tfb, STRsep);
X    	if ( !( *tfb ) || ( tfb > &ffbufr[filesiz] ) )
X    	    errexit("Invalid format of friends file", NULL);
X    	/*
X    	 * get \n terminated pseudonym (spaces are allowed in
X    	 * pseudonyms...), and nul terminate it. increment
X    	 * friends counter.
X    	 */
X    	tfb += strcspn(tfb, STReoln);
X    	if (!(*tfb))
X	    break;
X    	*tfb++ = '\0';			/* got pseudo */
X    	friends_count++;
X    }
X
X    /*
X     * return memory if the friends file has no friends in it.
X     * (they could have a 5K file of whitespaces ... :-)
X     */
X    if (!friends_count)
X    {
X    	free(ffbufr);
X    	return;
X    }
X
X	/* create the list of frend entries, and assign all the pointers */
X    friends_list = (frend *) malloc (friends_count * sizeof(frend));
X    if (friends_list == NULL)
X	errexit(strerror(errno), NULL);
X
X    tfb=ffbufr;
X    for (loop=0; loop <friends_count; loop++)
X    {
X    	tfb += strspn(tfb, STRsep);
X    	if (!(*tfb))
X    	    break;
X    	strnc0py(friends_list[loop].name, tfb, UT_NAMESIZE);
X	while ( *tfb )
X	    tfb++;
X    	tfb++;
X
X    	tfb += strspn(tfb, STRsep);
X    	friends_list[loop].pseudo = tfb;
X	while ( *tfb )
X	    tfb++;
X    	tfb++;
X    }
X	/* sort the friends list, and return. */
X    nqsort(friends_list, friends_count, sizeof(frend), compare_friends);
X} /* get_friends() */
X
X
X#if !USE_GETPWENT
X/*
X *	get_passwd
X */
X
Xvoid
Xget_passwd(pwfile)
X    char *pwfile;
X{
X    char	*pwbufr, *tfb;
X    int		pwfd, loop;
X    long	filesiz;
X    struct stat stbufr;
X
X    /*
X     * open and fstat the file, and malloc ram for the entire
X     * thing. Note, I use the open()/fstat() combination instead of
X     * the stat()/open() one, because once I have a file descriptor
X     * to the file, it can't be unlinked on me
X     */
X    if ((pwfd = open(pwfile, O_RDONLY, 0)) == -1)
X	errexit(strerror(errno), pwfile);
X    if (fstat(pwfd, &stbufr)== -1)
X	errexit(strerror(errno), pwfile);
X    filesiz=(long) stbufr.st_size;
X    if ((pwbufr = (char *) malloc(filesiz+1)) == NULL)
X	errexit(strerror(errno), pwfile);
X    if ((filesiz=read(pwfd, pwbufr, stbufr.st_size))==-1)
X	errexit(strerror(errno), pwfile);
X
X    (pwbufr)[filesiz]='\0';
X    if (close(pwfd) == -1)
X	errexit(strerror(errno), pwfile);
X
X    tfb=pwbufr;
X    pw_count = 0;
X
X    /*
X     * break up the passwd file into alternating
X     * nul terminated usernames, uid's, and realnames
X     */
X
X    while (1)
X    {
X		/* find end of username */
X	tfb += strcspn(tfb, PWsep);
X    	*tfb = '\0';	/* ok, got name.... */
X	if ( ++tfb > &pwbufr[filesiz])
X	    break;
X
X		/* skip password */
X	tfb += strcspn(tfb, PWsep) + 1;
X
X		/* find end of uid */
X	tfb += strcspn(tfb, PWsep);
X    	*tfb = '\0';	/* ok, got uid.... */
X	if ( ++tfb > &pwbufr[filesiz])
X	    break;
X
X		/* skip gid */
X	tfb += strcspn(tfb, PWsep) + 1;
X
X		/* find end of 1st part of GCOS (i.e, real name) */
X	tfb += strcspn(tfb, PWGCOSsep);
X    	*tfb = '\0';	/* ok, got name.... */
X	if ( ++tfb > &pwbufr[filesiz])
X	    break;
X
X    	tfb += strcspn(tfb, PWeoln);
X    	*tfb = '\0';	/* ok, got end of line */
X	if ( ++tfb > &pwbufr[filesiz] )
X	    break;
X    	pw_count++;
X    }
X
X	/* create the list of upwd entries, and assign all the pointers */
X    pw_list = (upwd *) malloc (pw_count * sizeof(upwd));
X    if (pw_list == NULL)
X	errexit(strerror(errno), NULL);
X
X    tfb=pwbufr;
X    for (loop=0; loop <pw_count; loop++)
X    {
X	pw_list[loop].username=tfb;	/* get start of username */
X    	while ( *tfb )
X    	    tfb++;
X    	tfb++;				/* at password */
X
X    	tfb += strcspn(tfb, PWsep) + 1;	/* at uid */
X
X    	pw_list[loop].uid = (uid_t) atoi(tfb);	/* get uid */
X    	while ( *tfb )
X    	    tfb++;
X    	tfb++;				/* at gid */
X
X	tfb += strcspn(tfb, PWsep) + 1;	/* at gcos */
X
X					/* get real name */
X	pw_list[loop].gcos = tfb;
X    	while ( *tfb )
X    	    tfb++;
X    	tfb++;				/* at end of realname */
X
X    	while ( *tfb )
X    	    tfb++;
X    	tfb++;				/* at end of line */
X    }
X
X	/* sort the password file on username */
X    nqsort(pw_list, pw_count, sizeof(upwd), compare_users);
X} /* get_passwd() */
X
X#endif /* USE_GETPWENT */
END_OF_FILE
  if test 9762 -ne `wc -c <'casu-3.3/fileio.c'`; then
    echo shar: \"'casu-3.3/fileio.c'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/fileio.c'
fi
if test -f 'casu-3.3/print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'casu-3.3/print.c'\"
else
  echo shar: Extracting \"'casu-3.3/print.c'\" \(10086 characters\)
  sed "s/^X//" >'casu-3.3/print.c' <<'END_OF_FILE'
X/*
X *  CaSU - communications & status utilities.
X *  Copyright (C) 1992, 1993 Luke Mewburn <lm@rmit.edu.au>
X *	incorporating:
X *	   flon - lists your friends who are logged on.
X *	   to - send a short message to a friend
X *
X *  This program is free software; you can redistribute it and/or modify
X *  it under the terms of the GNU General Public License as published by
X *  the Free Software Foundation; either version 2 of the License, or
X *  (at your option) any later version.
X *  
X *  This program is distributed in the hope that it will be useful,
X *  but WITHOUT ANY WARRANTY; without even the implied warranty of
X *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *  GNU General Public License for more details.
X *  
X *  You should have received a copy of the GNU General Public License
X *  along with this program; if not, write to the Free Software
X *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X
X#include "casu.h"
X
X/*
X *	print_output
X *
X * print the output according to the command and template buffer.
X */
X
Xvoid
Xprint_output(yes_str, no_str)
X    char *yes_str, *no_str;
X{
X    static char	term[sizeof(_PATH_DEV) + UT_LINESIZE] = _PATH_DEV;
X    char	*myname;
X    time_t	today;
X    int		entlp;
X    int		me_on;
X    int		offset, width;
X
X    static struct one_ent
X    {
X	int	on;		/* times this person on */
X	int	avail;		/* if any term has mesg y */
X	int	stres;		/* result of stat for this tty */
X	int	mesg;		/* mesg of cur ent */
X	time_t	idle, login; 	/* idle & login of cur ent */
X	char	*tty;		/* tty of cur ent */
X	char	*host;		/* remote host */
X	char	*name;		/* name of user */
X	int	valid;		/* is this entry valid */
X    } cur_ent, null_ent;
X
X
X    me_on = 0;
X    today=time(NULL);
X    if (!(flags & NO_HEADER))
X    {
X    	printf("\
X                Fast Lon v%-5.5s  %s\
X             -----------------------------------------------\n\
X", VERSION, ctime(&today) );
X    }
X    myname = NULL;
X    if (!(flags & NO_TAILER))
X	myname=get_username();
X
X    for (entlp=0; entlp <utmp_count; entlp++)
X    {
X	int		comlp, fpos;
X	frend		*curfrend, tmpfrend;
X	struct stat	stbufr;
X
X	if (NULL_UTMP_ENTRY(&utmp_list[entlp]))
X	    continue;		/* for who emulation - skip null entries */
X
X    	if (!(flags & NO_TAILER) && (myname != NULL))
X	{
X	    if (strncmp(utmp_list[entlp].ut_name, myname, UT_NAMESIZE) == 0)
X		me_on++;
X	}
X
X    	if (friends_list != NULL)
X    	{
X	    strnc0py(tmpfrend.name, utmp_list[entlp].ut_name, UT_NAMESIZE);
X	    curfrend = nbsearch(&tmpfrend, friends_list, friends_count,
X				sizeof(frend), compare_friends);
X	    if (   ((!(flags & ALL_ON)) && (curfrend == NULL))
X		|| (curfrend && (flags & NO_MATES)))
X	    {
X		cur_ent = null_ent;	/* previous info isn't valid anymore */
X		continue;
X	    }
X    	}
X    	else
X	    curfrend = NULL;
X
X    	if (flags & NEED_STAT)
X    	{
X	    strcpy(term + sizeof(_PATH_DEV) - 1, utmp_list[entlp].ut_line);
X	    cur_ent.stres=stat(term, &stbufr);
X    	}
X	else
X	    cur_ent.stres= -1;	/* fool the code to skip the stat stuff */
X
X    	if (entlp < utmp_count-1)		/* at least 1 to go */
X	{
X	    if (strncmp(utmp_list[entlp].ut_name,
X			utmp_list[entlp+1].ut_name, UT_NAMESIZE) == 0)
X	    {
X		if (cur_ent.stres != -1)
X		{
X		    time_t idle = today - stbufr.st_atime;
X			/* if not valid, or idle < least_idle */
X		    if ((! cur_ent.valid) || (idle < cur_ent.idle))
X		    {
X			cur_ent.idle=	idle;
X			cur_ent.tty=	utmp_list[entlp].ut_line;
X			cur_ent.login=	utmp_list[entlp].UT_TIME;
X			cur_ent.name=	utmp_list[entlp].ut_name;
X#ifdef HAVE_UT_HOST
X			cur_ent.host=	utmp_list[entlp].ut_host;
X#endif
X			cur_ent.mesg=	(stbufr.st_mode & MESGS_ON);
X			cur_ent.valid++;
X		    }
X		}
X		cur_ent.on++;
X		if (stbufr.st_mode & MESGS_ON)
X		    cur_ent.avail++;
X		if (flags & ONE_ONLY)		/* skip multiple entries */
X		    continue;
X	    }
X	}
X	if (cur_ent.stres != -1)
X	{
X		/* get valid info for last entry of a user */
X	    time_t idle = today - stbufr.st_atime;
X
X	    if ((! cur_ent.valid) || (idle < cur_ent.idle))
X	    {
X		cur_ent.idle= idle;
X		cur_ent.tty=  utmp_list[entlp].ut_line;
X		cur_ent.login=utmp_list[entlp].UT_TIME;
X		cur_ent.name= utmp_list[entlp].ut_name;
X#ifdef HAVE_UT_HOST
X		cur_ent.host= utmp_list[entlp].ut_host;
X#endif
X		cur_ent.mesg= (stbufr.st_mode & MESGS_ON);
X		cur_ent.valid++;
X	    }
X	    if (stbufr.st_mode & MESGS_ON)
X		cur_ent.avail++;
X	    if (flags & NO_IDLE)
X		if (cur_ent.idle >= max_idle)
X		{
X		    cur_ent = null_ent;
X		    continue;	/* don't print entry if idle limit exceeded */
X		}
X	}
X	else
X	{
X	    cur_ent.tty=  utmp_list[entlp].ut_line;
X	    cur_ent.login=utmp_list[entlp].UT_TIME;
X	    cur_ent.name= utmp_list[entlp].ut_name;
X#ifdef HAVE_UT_HOST
X	    cur_ent.host= utmp_list[entlp].ut_host;
X#endif
X	}
X
X    	offset=fpos=0;
X    	for (comlp=0; printdat.cmds[comlp]; comlp++)
X    	{
X	    char tmpbuf[UT_HOSTSIZE + 2 + 1], *outs;
X	    int	len, tmpwid;
X
X
X	    outs = NULL;
X	    width=printdat.cmds[comlp];
X	    tmpwid=width & C_WIDMASK;
X	    switch (printdat.cmds[comlp] & C_CMDMASK)
X	    {
X	    case C_NULL:
X		    outs = &printdat.form[fpos];
X		    break;
X	    case C_USER:
X		    strnc0py(tmpbuf, cur_ent.name, UT_NAMESIZE);
X		    outs = tmpbuf;
X		    break;
X	    case C_PSEUDO:
X		    if (curfrend != NULL)
X		    {
X			outs = curfrend->pseudo;
X			break;
X		    }
X		    if ((flags & BEST_NAME) == 0)
X			break;	/* don't fall thru if 'best' mode off */
X	    case C_REAL:
X		    { 
X#if USE_GETPWENT
X			struct passwd *curupwd;
X			strnc0py(tmpfrend.name, cur_ent.name, UT_NAMESIZE);
X			curupwd = getpwnam(tmpfrend.name);
X			if (curupwd != NULL)
X			    outs = convert_realname(curupwd->pw_gecos,
X						    curupwd->pw_name,
X						    curupwd->pw_uid);
X#else /* !USE_GETPWENT */
X#   if 0	/* lsearch */
X			int  i;
X			for (i=0; i<pw_count; i++)
X			    if (strncmp(pw_list[i].username, cur_ent.name,
X				    UT_NAMESIZE) ==0)
X				break;
X			if (i != pw_count)
X			    outs = convert_realname(pw_list[i].gcos,
X						    pw_list[i].username,
X						    pw_list[i].uid);
X#   else	/* nbsearch */
X			upwd *curp, tmpp;
X			strnc0py(tmpfrend.name, cur_ent.name, UT_NAMESIZE);
X			tmpp.username = tmpfrend.name;
X			curp = nbsearch(&tmpp, pw_list, pw_count, sizeof(upwd),
X					compare_users);
X			if (curp)
X			    outs = convert_realname(curp->gcos,
X						    curp->username,
X						    curp->uid);
X#   endif
X#endif /* !USE_GETPWENT */
X		    }
X		    break;
X	    case C_COUNT:
X		    if (!cur_ent.on)
X			break;
X		    sprintf(tmpbuf, "%-d", ++cur_ent.on);
X		    outs = tmpbuf;
X		    break;
X	    case C_X:
X		    tmpbuf[0] = cur_ent.on ? 'x' : ' ';
X		    tmpbuf[1] = '\0';
X		    outs = tmpbuf;
X		    break;
X	    case C_LOGIN:
X		    outs = 4 + ctime(&cur_ent.login);
X		    break;
X	    case C_IDLE:
X		    if (cur_ent.stres == -1)	/* print nothing if stat died */
X			break;
X		    if (cur_ent.idle >= MAXIDLE)
X			outs = " >>> ";
X		    else
X			if (cur_ent.idle < min_idle)
X			    outs = " ... ";
X			else
X			{
X			    sprintf(tmpbuf, "%02d:%02d",
X					(int) (cur_ent.idle / 60),
X					(int) (cur_ent.idle % 60));
X			    outs = tmpbuf;
X			}
X		    break;
X	    case C_TTY:
X		    outs = cur_ent.tty;
X		    break;
X	    case C_MESG:
X		    if (cur_ent.stres == -1) 	/* print nothing if stat died */
X			break;
X		    outs = cur_ent.mesg ? yes_str : no_str;
X		    break;
X	    case C_AVAIL:
X		    if (cur_ent.stres == -1) 	/* print nothing if stat died */
X			break;
X		    outs = cur_ent.avail ? yes_str : no_str;
X		    break;
X#ifdef HAVE_UT_HOST
X	    case C_HOST:
X		    strnc0py(tmpbuf, cur_ent.host, UT_HOSTSIZE);
X		    outs = tmpbuf;
X		    break;
X	    case C_HOSTBRK:
X		    if (cur_ent.host[0] == '\0')
X			break;
X		    tmpbuf[0] = '(';
X		    strnc0py(tmpbuf + 1, cur_ent.host, UT_HOSTSIZE);
X		    if (strlen(tmpbuf) >= tmpwid)
X			tmpbuf[tmpwid - 1] = '\0';
X		    strcat(tmpbuf, ")");
X		    outs=tmpbuf;
X		    break;
X#endif /* HAVE_UT_HOST */
X	    default:
X		    break;
X	    } /* switch */
X	    if (outs == NULL)
X		len = 0;
X	    else
X	    {
X		len=strlen(outs);
X		if (len>=tmpwid)			/* need to truncate */
X		{
X		    strncpy(&printdat.buf[offset], outs, tmpwid);
X		    len = tmpwid;
X		}
X		else if (width & C_RIGHT)		/* right align */
X		{
X		    tmpwid-= len;
X		    strncpy(&printdat.buf[offset+tmpwid], outs, len);
X		    len = 0;
X		}
X		else					/* left align */
X		    strncpy(&printdat.buf[offset], outs, len);
X	    }
X	    if (width & C_VARIENT)			/* varient width */
X	    {
X		width &= ~C_WIDMASK;
X		width += len & C_WIDMASK;
X	    }
X	    else
X	    {
X		int lp;
X		for (lp = len; lp < tmpwid; lp++)	/* clear unused areas */
X		    printdat.buf[offset+lp] = ' ';
X	    }
X	    offset += width & C_WIDMASK;
X	    fpos += printdat.cmds[comlp] & C_WIDMASK;
X    	}
X	printdat.buf[offset] = '\0';
X    	puts(printdat.buf);
X	cur_ent = null_ent;	/* previous info isn't valid anymore */
X    }
X    if (!(flags & NO_TAILER))
X    {
X    	switch (me_on)
X    	{
X    	case 0:
X#if 0
X    		puts("\nYou technically aren't logged on.");
X#else
X		puts("\nYou're not logged on.");
X#endif
X    		break;
X    	case 1:
X    		puts("\nYou are logged on once.");
X    		break;
X    	case 2:
X    		puts("\nYou are logged on twice.");
X    		break;
X    	default:
X    		printf("\nYou are logged on %d times.\n", me_on);
X    		break;
X    	}
X    	if (utmp_count == 1)
X	    puts("You are the only person logged on.");
X    	else
X	    printf("There are %d users logged on.\n", utmp_count);
X    }
X} /* print_output */
X
X
X/*
X *	who_am_I
X *
X * Emulates 'who am I'.
X */
X
Xvoid
Xwho_am_I()
X{
X    char    *tty, *tmptty;
X    int	    slp;
X    time_t  ttytime;
X
X    if ((tty = ttyname(0)) == NULL)	/* who am I < somefile */
X    {
X	ttytime=time(NULL);
X	tty=WHO_NULLTTY;
X    }
X    else				/* just who am I */
X    {
X	tmptty=strrchr(tty, '/');
X	if (tmptty != NULL)
X	    tty = tmptty + 1;
X	
X		/* search for user on tty */
X	for (slp=0; slp <utmp_count; slp++)
X	{
X	    if (NULL_UTMP_ENTRY(&utmp_list[slp]))
X		continue;
X	    if (strncmp(utmp_list[slp].ut_line, tty, UT_LINESIZE) == 0)
X		break;
X	}
X
X	if (slp == utmp_count)
X	    errexit("not found in utmp file", tty);
X	ttytime=utmp_list[slp].UT_TIME;
X    }
X	
X    printf(WHO_AM_I_FMT, (int) UT_NAMESIZE, get_username(),
X	    tty, 4 + ctime(&ttytime));
X} /* who_am_I */
END_OF_FILE
  if test 10086 -ne `wc -c <'casu-3.3/print.c'`; then
    echo shar: \"'casu-3.3/print.c'\" unpacked with wrong size!
  fi
  # end of 'casu-3.3/print.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
