Newsgroups: comp.sources.misc
From: youki-k@is.aist-nara.ac.jp (Youki Kadobayashi)
Subject: v41i097:  wwfs - WorldWide File System, Part12/22
Message-ID: <1994Jan17.202330.20046@sparky.sterling.com>
X-Md4-Signature: a654c58f4c3b8bab2a2d112b813fb5fe
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Nara Institute of Science and Technology, Japan
Date: Mon, 17 Jan 1994 20:23:30 GMT
Approved: kent@sparky.sterling.com

Submitted-by: youki-k@is.aist-nara.ac.jp (Youki Kadobayashi)
Posting-number: Volume 41, Issue 97
Archive-name: wwfs/part12
Environment: UNIX, inet

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  csd/auto.h csd/wfs.h doc/manual.tex libww/wwconfigure.sh
# Wrapped by kent@sparky on Sun Jan 16 17:48:34 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 22)."'
if test -f 'csd/auto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'csd/auto.h'\"
else
  echo shar: Extracting \"'csd/auto.h'\" \(27718 characters\)
  sed "s/^X//" >'csd/auto.h' <<'END_OF_FILE'
X/*
X *   This file was automatically generated by version 1.7 of cextract.
X *   Manual editing not recommended.
X *
X *   Created: Sat Dec 11 00:32:27 1993
X */
X#ifndef __CEXTRACT__
X#if __STDC__
X
Xextern int acc_bind ( char *name, char *value );
Xextern wf_acc * acc_load ( char *dir );
Xextern wf_acc * acc_findname ( char *dir );
Xextern int acc_check ( wf_acc *accp, unsigned long ip, long mask );
Xextern void bfs_start ( void );
Xextern int cwd_fake ( wf_thrd *c, wf_fh *fhp );
Xextern void fh_fake ( wf_thrd *c );
Xextern void fh_getattr ( wf_thrd *c );
Xextern void fh_read ( wf_thrd *c );
Xextern void * timeout_set ( time_t t, void (*fn)(), void *closure );
Xextern void timeout_reset ( time_t t, callout *cp );
Xextern void timeout_clear ( callout *cp );
Xextern void timeout_reschedule ( time_t now, time_t then );
Xextern int softclock ( void );
Xextern void cmfs_getattr ( wf_thrd *c );
Xextern void cmfs_lookup ( wf_thrd *c );
Xextern void cmfs_readdir ( wf_thrd *c );
Xextern void cmfs_readlink ( wf_thrd *c );
Xextern void cmfs_read ( wf_thrd *c );
Xextern void conn_start ( void );
Xextern void conn_stop ( void );
Xextern int conn_count ( void );
Xextern wf_conn * conn_alloc ( void );
Xextern void conn_free ( wf_conn *cp );
Xextern void conn_shutdown ( wf_conn *cp, int howto );
Xextern void conn_dropped ( int so );
Xextern void conn_inspect ( wf_req *reqp );
Xextern unsigned long updcrc ( unsigned long icrc, unsigned char *icp, int icnt );
Xextern int cs_namei ( char *pname, wf_fh *fhp );
Xextern long cs_error ( char *msg );
Xextern void cs_mount ( wf_thrd *c );
Xextern void cs_mount_done ( wf_thrd *c, int status );
Xextern int cs_umount ( char *vol );
Xextern void cs_lookup ( svc_req *rqstp, wf_vol *volp, wf_fh *fhp, char *fname );
Xextern void cs_readdir ( svc_req *rqstp, wf_vol *volp, wf_fh *fhp, long cookie, u_int count );
Xextern void cs_read ( svc_req *rqstp, wf_vol *volp, wf_fh *fhp, u_int offset, u_int count, u_int totalcount );
Xextern void cs_getuda ( svc_req *rqstp, wf_fh *fhp, char *attrname );
Xextern void cs_geterr ( svc_req *rqstp, long err_context );
Xextern void * cs_proc_null_1 ( void *argp, svc_req *rqstp );
Xextern int * cs_proc_getport_1 ( void *argp, svc_req *rqstp );
Xextern cs_fhres * cs_proc_register_1 ( void *argp, svc_req *rqstp );
Xextern cs_res * cs_proc_unregister_1 ( void *argp, svc_req *rqstp );
Xextern cs_res * cs_proc_mount_1 ( cs_volargs *argp, svc_req *rqstp );
Xextern cs_res * cs_proc_umount_1 ( cs_volargs *argp, svc_req *rqstp );
Xextern cs_diropres * cs_proc_lookup_1 ( cs_diropargs *argp, svc_req *rqstp );
Xextern cs_readdirres * cs_proc_readdir_1 ( cs_readdirargs *argp, svc_req *rqstp );
Xextern cs_readres * cs_proc_read_1 ( cs_readargs *argp, svc_req *rqstp );
Xextern cs_volres * cs_proc_getvol_1 ( cs_volargs *argp, svc_req *rqstp );
Xextern cs_xferres * cs_proc_getxfer_1 ( wf_fh *fhp, svc_req *rqstp );
Xextern cs_udares * cs_proc_getuda_1 ( cs_udaargs *argp, svc_req *rqstp );
Xextern cs_geterrres * cs_proc_geterr_1 ( cs_geterrargs *argp, svc_req *rqstp );
Xextern void dir_start ( void );
Xextern void dir_addfile ( wf_dir *dirp, wf_file *filep );
Xextern void dir_deletefile ( wf_file *filep );
Xextern wf_file * dir_adddir ( wf_dir *dirp, char *name, long volid, long dirid );
Xextern wf_dir * dir_new ( wf_vol *volp, long id, char *dir, char *subdir );
Xextern wf_dir * dir_findcache ( wf_vol *volp, long dirid );
Xextern wf_dir * dir_load ( wf_vol *volp, long dirid );
Xextern void dir_save ( wf_vol *volp, wf_dir *dirp, wf_dir *olddirp );
Xextern void dir_realdir ( char *path, wf_vol *volp, wf_dir *dirp );
Xextern void dir_dispose ( wf_vol *volp, long dirid );
Xextern void dir_inspect ( wf_req *reqp, char *name );
Xextern int dump_srv ( char *tag, wf_srv *srvp );
Xextern int dump_fh ( char *tag, wf_fh *fhp );
Xextern int dump_vol ( char *tag, wf_vol *volp );
Xextern int dump_dir ( char *tag, wf_dir *dirp );
Xextern int dump_fdset ( char *tag, fd_set *fdsetp );
Xextern void err_getattr ( wf_thrd *c );
Xextern void err_getattr_miss ( wf_thrd *c );
Xextern void err_lookup ( wf_thrd *c );
Xextern void err_lookup_miss ( wf_thrd *c );
Xextern void err_readlink ( wf_thrd *c );
Xextern void err_read ( wf_thrd *c );
Xextern void err_read_miss ( wf_thrd *c );
Xextern void err_readdir ( wf_thrd *c );
Xextern void err_readdir_miss ( wf_thrd *c );
Xextern void err_getuda ( wf_thrd *c );
Xextern void err_keepalive ( wf_thrd *c );
Xextern void err_close ( wf_conn *cp );
Xextern void err_shutdown ( wf_conn *cp, int howto );
Xextern wf_file * file_alloc ( void );
Xextern void file_free ( wf_file *filep );
Xextern void file_uncache ( wf_dir *dirp );
Xextern wf_file * file_new ( char *name, char *link, ftype filetype, u_int nlink, u_int mode, u_int uid, u_int gid, long size, long time, long fileid, u_int fsid );
Xextern void attr_initdir ( fattr *attrp );
Xextern void attr_initfile ( fattr *attrp, long size );
Xextern unsigned int attr_touch ( fattr *attrp );
Xextern wf_file * file_newvol ( char *name );
Xextern wf_file * file_findid ( wf_dir *dirp, long fsid, long fileid );
Xextern wf_file * file_findname ( wf_dir *dirp, char *name );
Xextern int file_recv_init ( wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern void file_recv_finish ( wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern void file_recv_abort ( wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern void file_getpath ( char *buf, wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern int file_findcache ( wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern void file_dispose ( wf_vol *volp, wf_dir *dirp, wf_file *filep );
Xextern void file_inspect ( wf_req *reqp, char *name );
Xextern void ftp_getuda ( void );
Xextern void ftp_keepalive ( void );
Xextern void ftp_close ( wf_conn *cp );
Xextern void ftp_shutdown ( wf_conn *cp, int howto );
Xextern int ftp_conn_open ( wf_thrd *c );
Xextern int ftp_recv_status ( wf_conn *cp );
Xextern void ftp_recv_junk ( int so );
Xextern void ftp_reply_diag ( int ret );
Xextern void ftp_readdir_miss ( wf_thrd *c );
Xextern void ftp_recv_list ( wf_thrd *c );
Xextern int ftp_parse_list ( char *buftop, wf_vol *volp, wf_dir *dirp, wf_dir *olddirp );
Xextern void ftp_read_miss ( wf_thrd *c );
Xextern void icmp_start ( void );
Xextern void icmp_send ( sockaddr_in *to );
Xextern void icmp_recv ( int so );
Xextern void dlog ( char *fmt, ... );
Xextern void dlog_start ( void );
Xextern void dlog_stop ( void );
Xextern void errno_log ( char *file, int line );
Xextern void talk_start ( void );
Xextern void talk ( long ip_addr, char *fmt, ... );
Xextern int main ( int argc, char **argv );
Xextern void csd_start_1 ( void );
Xextern void csd_start_2 ( void );
Xextern void csd_stop ( void );
Xextern int csd_tailor ( char *name, char *value );
Xextern void nfs_getattr_reply ( wf_thrd *c, int status );
Xextern void nfs_lookup_reply ( wf_thrd *c, int status );
Xextern void nfs_readlink_reply ( wf_thrd *c, int status );
Xextern void nfs_read_reply ( wf_thrd *c, nfsstat status, fattr *attrp, int data_len, char *data_val );
Xextern void nfs_read_done ( wf_thrd *c, int status );
Xextern unsigned long cookie_bake ( wf_file *filep, wf_file *head );
Xextern wf_file * cookie_taste ( unsigned long cookie, wf_file *head );
Xextern void nfs_readdir_done ( wf_thrd *c, int status );
Xextern void so_register ( int so, int flag );
Xextern void so_unregister ( int so, int flag );
Xextern void fd_union ( fd_set *destfdp, fd_set *srcfdp );
Xextern void so_callback ( int so, func funcp, void *p );
Xextern void so_clear ( int so );
Xextern char * so_getbuf ( int so );
Xextern serv_state csd_run ( void );
Xextern int csd_rpc ( void );
Xextern void * nfsproc_null_2 ( void *argp, svc_req *rqstp );
Xextern attrstat * nfsproc_getattr_2 ( nfs_fh *argp, svc_req *rqstp );
Xextern attrstat * nfsproc_setattr_2 ( sattrargs *argp, svc_req *rqstp );
Xextern void * nfsproc_root_2 ( void *argp, svc_req *rqstp );
Xextern diropres * nfsproc_lookup_2 ( diropargs *argp, svc_req *rqstp );
Xextern readlinkres * nfsproc_readlink_2 ( nfs_fh *argp, svc_req *rqstp );
Xextern readres * nfsproc_read_2 ( readargs *argp, svc_req *rqstp );
Xextern void * nfsproc_writecache_2 ( void *argp, svc_req *rqstp );
Xextern attrstat * nfsproc_write_2 ( writeargs *argp, svc_req *rqstp );
Xextern diropres * nfsproc_create_2 ( createargs *argp, svc_req *rqstp );
Xextern nfsstat * nfsproc_remove_2 ( diropargs *argp, svc_req *rqstp );
Xextern nfsstat * nfsproc_rename_2 ( renameargs *argp, svc_req *rqstp );
Xextern nfsstat * nfsproc_link_2 ( linkargs *argp, svc_req *rqstp );
Xextern nfsstat * nfsproc_symlink_2 ( symlinkargs *argp, svc_req *rqstp );
Xextern diropres * nfsproc_mkdir_2 ( createargs *argp, svc_req *rqstp );
Xextern nfsstat * nfsproc_rmdir_2 ( diropargs *argp, svc_req *rqstp );
Xextern readdirres * nfsproc_readdir_2 ( readdirargs *argp, svc_req *rqstp );
Xextern statfsres * nfsproc_statfs_2 ( nfs_fh *argp, svc_req *rqstp );
Xextern int parse_conf ( char *conf, int (*bind_func)() );
Xextern int parse_tailor ( wf_tailor *tailor, char *name, char *value );
Xextern long parse_cap ( wf_cap *cap, char *str );
Xextern wf_proto * pol_select_proto ( wf_vol *volp );
Xextern wf_srvq * pol_select_srv ( wf_vol *volp );
Xextern void proto_getattr ( wf_thrd *c );
Xextern void proto_lookup ( wf_thrd *c );
Xextern void proto_readlink ( wf_thrd *c );
Xextern void proto_read ( wf_thrd *c );
Xextern void proto_readdir ( wf_thrd *c );
Xextern void proto_getuda ( wf_thrd *c );
Xextern void proto_keepalive ( wf_thrd *c );
Xextern void proto_close ( wf_conn *cp );
Xextern void proto_shutdown ( wf_conn *cp, int howto );
Xextern void proto_getattr_miss ( wf_thrd *c );
Xextern void proto_lookup_miss ( wf_thrd *c );
Xextern void proto_readdir_miss ( wf_thrd *c );
Xextern void proto_read_miss ( wf_thrd *c );
Xextern void root_start ( void );
Xextern wf_file * root_attach ( wf_dir *dirp, char *name );
Xextern int root_deletevol ( char *name );
Xextern int root_fhn2ih ( char *pname, wf_ih *ihp );
Xextern int root_name2ih ( char *pname, wf_ih *ihp );
Xextern void ih2fh ( wf_ih *ihp, wf_fh *fhp );
Xextern int root_name2fh ( char *pname, wf_fh *fhp );
Xextern void root_inspect ( wf_req *reqp, char *arg );
Xextern void root_getattr_miss ( wf_thrd *c );
Xextern void root_read_miss ( wf_thrd *c );
Xextern void root_lookup_miss ( wf_thrd *c );
Xextern void root_getuda ( void );
Xextern void run_task ( int (*tf)(), void *ta, func cf, void *ca );
Xextern void sched_task ( func cf, void *ca, void *wchan );
Xextern void sched_task_atop ( func cf, void *ca, void *wchan );
Xextern void wakeup ( void *wchan );
Xextern void sigchld ( int sig );
Xextern void do_task_notify ( void );
Xextern struct hostent * parse_hostorip ( char *str );
Xextern void srv_resolv ( wf_srv *srvp );
Xextern wf_srv * srv_findname ( char *name );
Xextern wf_srv * srv_findip ( long ipaddr );
Xextern wf_conn * srv_getconn ( wf_srvq *srvq );
Xextern wf_conn * srv_newconn ( wf_srvq *srvq );
Xextern void srv_releaseconn ( wf_srv *srvp, wf_conn *cp );
Xextern void srv_flag ( wf_srv *srvp, int flag );
Xextern wf_thrd * thrd_alloc ( void );
Xextern void thrd_watch ( wf_thrd *thrdp );
Xextern void thrd_ignore ( wf_thrd *thrdp );
Xextern void thrd_free ( wf_thrd *thrdp );
Xextern void thrd_srvfailure ( wf_srv *srvp );
Xextern void thrd_start ( void );
Xextern void thrd_stop ( void );
Xextern void thrd_inspect ( wf_req *reqp );
Xextern void trace_event ( void *handle, wf_trace *tracep );
Xextern void trace_report ( void );
Xextern void trace_start ( void );
Xextern void ufs_read_miss ( wf_thrd *c );
Xextern void ufs_readdir_miss ( wf_thrd *c );
Xextern int uip_id ( void );
Xextern void uip_start ( void );
Xextern qelem * q_alloc ( void );
Xextern void q_insert ( qelem *elem, qelem *pred );
Xextern void q_remove ( qelem *elem );
Xextern int q_len ( qelem *elem );
Xextern void q_allfree ( qelem *head );
Xextern void * alloc_and_copy ( void *v, int vlen );
Xextern void * alloc_and_clear ( int vlen );
Xextern void alloc_start ( void );
Xextern int mkdirs ( char *path );
Xextern int validate_dir ( char *dir );
Xextern void csd_abort ( int ret );
Xextern int background ( void );
Xextern int bind_resv_port ( int so, unsigned short *portp );
Xextern int tcp_send ( int so, char *fmt, ... );
Xextern int req_send ( wf_req *reqp, char *fmt, ... );
Xextern void getdate ( void );
Xextern void unix_command ( char *cmd );
Xextern long compute_blocks ( long size );
Xextern time_t tm2time ( struct tm *tm );
Xextern char * strdup ( Const char *str );
Xextern wf_vol * vol_alloc ( void );
Xextern void vol_free ( wf_vol *volp );
Xextern wf_vol * vol_findid ( long id );
Xextern wf_vol * vol_findname ( char *dir, char *name );
Xextern int vol_set_name ( char *name );
Xextern int vol_set_ftp_server ( char *hostname );
Xextern int vol_set_ftp_directory ( char *subdir );
Xextern int vol_set_ftp_options ( char *flagstr );
Xextern int vol_set_ufs_directory ( char *topdir );
Xextern int vol_set_description ( char *desc );
Xextern int vol_bind ( char *name, char *value );
Xextern wf_vol * vol_load ( char *dir, char *name );
Xextern void vol_save ( wf_vol *volp );
Xextern wf_conn * vol_getconn ( wf_vol *volp );
Xextern wf_conn * vol_newconn ( wf_vol *volp );
Xextern void vol_releaseconn ( wf_vol *volp );
Xextern void vol_addsrv ( wf_vol *volp, wf_srv *srvp, char *subdir );
Xextern void vol_deletesrv ( wf_vol *volp, wf_srv *srvp );
Xextern long vol_allocid ( wf_vol *volp );
Xextern void vol_destroyid ( wf_vol *volp );
Xextern wf_dir * vol_newroot ( wf_vol *volp );
Xextern wf_dir * vol_findroot ( wf_vol *volp );
Xextern void vol_inspect ( wf_req *reqp, char *name );
X
X#else /* __STDC__ */
X
Xextern int acc_bind (/* char *name, char *value */);
Xextern wf_acc * acc_load (/* char *dir */);
Xextern wf_acc * acc_findname (/* char *dir */);
Xextern int acc_check (/* wf_acc *accp, unsigned long ip, long mask */);
Xextern void bfs_start (/* void */);
Xextern int cwd_fake (/* wf_thrd *c, wf_fh *fhp */);
Xextern void fh_fake (/* wf_thrd *c */);
Xextern void fh_getattr (/* wf_thrd *c */);
Xextern void fh_read (/* wf_thrd *c */);
Xextern void * timeout_set (/* time_t t, void (*fn)(), void *closure */);
Xextern void timeout_reset (/* time_t t, callout *cp */);
Xextern void timeout_clear (/* callout *cp */);
Xextern void timeout_reschedule (/* time_t now, time_t then */);
Xextern int softclock (/* void */);
Xextern void cmfs_getattr (/* wf_thrd *c */);
Xextern void cmfs_lookup (/* wf_thrd *c */);
Xextern void cmfs_readdir (/* wf_thrd *c */);
Xextern void cmfs_readlink (/* wf_thrd *c */);
Xextern void cmfs_read (/* wf_thrd *c */);
Xextern void conn_start (/* void */);
Xextern void conn_stop (/* void */);
Xextern int conn_count (/* void */);
Xextern wf_conn * conn_alloc (/* void */);
Xextern void conn_free (/* wf_conn *cp */);
Xextern void conn_shutdown (/* wf_conn *cp, int howto */);
Xextern void conn_dropped (/* int so */);
Xextern void conn_inspect (/* wf_req *reqp */);
Xextern unsigned long updcrc (/* unsigned long icrc, unsigned char *icp, int icnt */);
Xextern int cs_namei (/* char *pname, wf_fh *fhp */);
Xextern long cs_error (/* char *msg */);
Xextern void cs_mount (/* wf_thrd *c */);
Xextern void cs_mount_done (/* wf_thrd *c, int status */);
Xextern int cs_umount (/* char *vol */);
Xextern void cs_lookup (/* svc_req *rqstp, wf_vol *volp, wf_fh *fhp, char *fname */);
Xextern void cs_readdir (/* svc_req *rqstp, wf_vol *volp, wf_fh *fhp, long cookie, u_int count */);
Xextern void cs_read (/* svc_req *rqstp, wf_vol *volp, wf_fh *fhp, u_int offset, u_int count, u_int totalcount */);
Xextern void cs_getuda (/* svc_req *rqstp, wf_fh *fhp, char *attrname */);
Xextern void cs_geterr (/* svc_req *rqstp, long err_context */);
Xextern void * cs_proc_null_1 (/* void *argp, svc_req *rqstp */);
Xextern int * cs_proc_getport_1 (/* void *argp, svc_req *rqstp */);
Xextern cs_fhres * cs_proc_register_1 (/* void *argp, svc_req *rqstp */);
Xextern cs_res * cs_proc_unregister_1 (/* void *argp, svc_req *rqstp */);
Xextern cs_res * cs_proc_mount_1 (/* cs_volargs *argp, svc_req *rqstp */);
Xextern cs_res * cs_proc_umount_1 (/* cs_volargs *argp, svc_req *rqstp */);
Xextern cs_diropres * cs_proc_lookup_1 (/* cs_diropargs *argp, svc_req *rqstp */);
Xextern cs_readdirres * cs_proc_readdir_1 (/* cs_readdirargs *argp, svc_req *rqstp */);
Xextern cs_readres * cs_proc_read_1 (/* cs_readargs *argp, svc_req *rqstp */);
Xextern cs_volres * cs_proc_getvol_1 (/* cs_volargs *argp, svc_req *rqstp */);
Xextern cs_xferres * cs_proc_getxfer_1 (/* wf_fh *fhp, svc_req *rqstp */);
Xextern cs_udares * cs_proc_getuda_1 (/* cs_udaargs *argp, svc_req *rqstp */);
Xextern cs_geterrres * cs_proc_geterr_1 (/* cs_geterrargs *argp, svc_req *rqstp */);
Xextern void dir_start (/* void */);
Xextern void dir_addfile (/* wf_dir *dirp, wf_file *filep */);
Xextern void dir_deletefile (/* wf_file *filep */);
Xextern wf_file * dir_adddir (/* wf_dir *dirp, char *name, long volid, long dirid */);
Xextern wf_dir * dir_new (/* wf_vol *volp, long id, char *dir, char *subdir */);
Xextern wf_dir * dir_findcache (/* wf_vol *volp, long dirid */);
Xextern wf_dir * dir_load (/* wf_vol *volp, long dirid */);
Xextern void dir_save (/* wf_vol *volp, wf_dir *dirp, wf_dir *olddirp */);
Xextern void dir_realdir (/* char *path, wf_vol *volp, wf_dir *dirp */);
Xextern void dir_dispose (/* wf_vol *volp, long dirid */);
Xextern void dir_inspect (/* wf_req *reqp, char *name */);
Xextern int dump_srv (/* char *tag, wf_srv *srvp */);
Xextern int dump_fh (/* char *tag, wf_fh *fhp */);
Xextern int dump_vol (/* char *tag, wf_vol *volp */);
Xextern int dump_dir (/* char *tag, wf_dir *dirp */);
Xextern int dump_fdset (/* char *tag, fd_set *fdsetp */);
Xextern void err_getattr (/* wf_thrd *c */);
Xextern void err_getattr_miss (/* wf_thrd *c */);
Xextern void err_lookup (/* wf_thrd *c */);
Xextern void err_lookup_miss (/* wf_thrd *c */);
Xextern void err_readlink (/* wf_thrd *c */);
Xextern void err_read (/* wf_thrd *c */);
Xextern void err_read_miss (/* wf_thrd *c */);
Xextern void err_readdir (/* wf_thrd *c */);
Xextern void err_readdir_miss (/* wf_thrd *c */);
Xextern void err_getuda (/* wf_thrd *c */);
Xextern void err_keepalive (/* wf_thrd *c */);
Xextern void err_close (/* wf_conn *cp */);
Xextern void err_shutdown (/* wf_conn *cp, int howto */);
Xextern wf_file * file_alloc (/* void */);
Xextern void file_free (/* wf_file *filep */);
Xextern void file_uncache (/* wf_dir *dirp */);
Xextern wf_file * file_new (/* char *name, char *link, ftype filetype, u_int nlink, u_int mode, u_int uid, u_int gid, long size, long time, long fileid, u_int fsid */);
Xextern void attr_initdir (/* fattr *attrp */);
Xextern void attr_initfile (/* fattr *attrp, long size */);
Xextern unsigned int attr_touch (/* fattr *attrp */);
Xextern wf_file * file_newvol (/* char *name */);
Xextern wf_file * file_findid (/* wf_dir *dirp, long fsid, long fileid */);
Xextern wf_file * file_findname (/* wf_dir *dirp, char *name */);
Xextern int file_recv_init (/* wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern void file_recv_finish (/* wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern void file_recv_abort (/* wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern void file_getpath (/* char *buf, wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern int file_findcache (/* wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern void file_dispose (/* wf_vol *volp, wf_dir *dirp, wf_file *filep */);
Xextern void file_inspect (/* wf_req *reqp, char *name */);
Xextern void ftp_getuda (/* void */);
Xextern void ftp_keepalive (/* void */);
Xextern void ftp_close (/* wf_conn *cp */);
Xextern void ftp_shutdown (/* wf_conn *cp, int howto */);
Xextern int ftp_conn_open (/* wf_thrd *c */);
Xextern int ftp_recv_status (/* wf_conn *cp */);
Xextern void ftp_recv_junk (/* int so */);
Xextern void ftp_reply_diag (/* int ret */);
Xextern void ftp_readdir_miss (/* wf_thrd *c */);
Xextern void ftp_recv_list (/* wf_thrd *c */);
Xextern int ftp_parse_list (/* char *buftop, wf_vol *volp, wf_dir *dirp, wf_dir *olddirp */);
Xextern void ftp_read_miss (/* wf_thrd *c */);
Xextern void icmp_start (/* void */);
Xextern void icmp_send (/* sockaddr_in *to */);
Xextern void icmp_recv (/* int so */);
Xextern void dlog (/* char *fmt, ... */);
Xextern void dlog_start (/* void */);
Xextern void dlog_stop (/* void */);
Xextern void errno_log (/* char *file, int line */);
Xextern void talk_start (/* void */);
Xextern void talk (/* long ip_addr, char *fmt, ... */);
Xextern int main (/* int argc, char **argv */);
Xextern void csd_start_1 (/* void */);
Xextern void csd_start_2 (/* void */);
Xextern void csd_stop (/* void */);
Xextern int csd_tailor (/* char *name, char *value */);
Xextern void nfs_getattr_reply (/* wf_thrd *c, int status */);
Xextern void nfs_lookup_reply (/* wf_thrd *c, int status */);
Xextern void nfs_readlink_reply (/* wf_thrd *c, int status */);
Xextern void nfs_read_reply (/* wf_thrd *c, nfsstat status, fattr *attrp, int data_len, char *data_val */);
Xextern void nfs_read_done (/* wf_thrd *c, int status */);
Xextern unsigned long cookie_bake (/* wf_file *filep, wf_file *head */);
Xextern wf_file * cookie_taste (/* unsigned long cookie, wf_file *head */);
Xextern void nfs_readdir_done (/* wf_thrd *c, int status */);
Xextern void so_register (/* int so, int flag */);
Xextern void so_unregister (/* int so, int flag */);
Xextern void fd_union (/* fd_set *destfdp, fd_set *srcfdp */);
Xextern void so_callback (/* int so, func funcp, void *p */);
Xextern void so_clear (/* int so */);
Xextern char * so_getbuf (/* int so */);
Xextern serv_state csd_run (/* void */);
Xextern int csd_rpc (/* void */);
Xextern void * nfsproc_null_2 (/* void *argp, svc_req *rqstp */);
Xextern attrstat * nfsproc_getattr_2 (/* nfs_fh *argp, svc_req *rqstp */);
Xextern attrstat * nfsproc_setattr_2 (/* sattrargs *argp, svc_req *rqstp */);
Xextern void * nfsproc_root_2 (/* void *argp, svc_req *rqstp */);
Xextern diropres * nfsproc_lookup_2 (/* diropargs *argp, svc_req *rqstp */);
Xextern readlinkres * nfsproc_readlink_2 (/* nfs_fh *argp, svc_req *rqstp */);
Xextern readres * nfsproc_read_2 (/* readargs *argp, svc_req *rqstp */);
Xextern void * nfsproc_writecache_2 (/* void *argp, svc_req *rqstp */);
Xextern attrstat * nfsproc_write_2 (/* writeargs *argp, svc_req *rqstp */);
Xextern diropres * nfsproc_create_2 (/* createargs *argp, svc_req *rqstp */);
Xextern nfsstat * nfsproc_remove_2 (/* diropargs *argp, svc_req *rqstp */);
Xextern nfsstat * nfsproc_rename_2 (/* renameargs *argp, svc_req *rqstp */);
Xextern nfsstat * nfsproc_link_2 (/* linkargs *argp, svc_req *rqstp */);
Xextern nfsstat * nfsproc_symlink_2 (/* symlinkargs *argp, svc_req *rqstp */);
Xextern diropres * nfsproc_mkdir_2 (/* createargs *argp, svc_req *rqstp */);
Xextern nfsstat * nfsproc_rmdir_2 (/* diropargs *argp, svc_req *rqstp */);
Xextern readdirres * nfsproc_readdir_2 (/* readdirargs *argp, svc_req *rqstp */);
Xextern statfsres * nfsproc_statfs_2 (/* nfs_fh *argp, svc_req *rqstp */);
Xextern int parse_conf (/* char *conf, int (*bind_func)() */);
Xextern int parse_tailor (/* wf_tailor *tailor, char *name, char *value */);
Xextern long parse_cap (/* wf_cap *cap, char *str */);
Xextern wf_proto * pol_select_proto (/* wf_vol *volp */);
Xextern wf_srvq * pol_select_srv (/* wf_vol *volp */);
Xextern void proto_getattr (/* wf_thrd *c */);
Xextern void proto_lookup (/* wf_thrd *c */);
Xextern void proto_readlink (/* wf_thrd *c */);
Xextern void proto_read (/* wf_thrd *c */);
Xextern void proto_readdir (/* wf_thrd *c */);
Xextern void proto_getuda (/* wf_thrd *c */);
Xextern void proto_keepalive (/* wf_thrd *c */);
Xextern void proto_close (/* wf_conn *cp */);
Xextern void proto_shutdown (/* wf_conn *cp, int howto */);
Xextern void proto_getattr_miss (/* wf_thrd *c */);
Xextern void proto_lookup_miss (/* wf_thrd *c */);
Xextern void proto_readdir_miss (/* wf_thrd *c */);
Xextern void proto_read_miss (/* wf_thrd *c */);
Xextern void root_start (/* void */);
Xextern wf_file * root_attach (/* wf_dir *dirp, char *name */);
Xextern int root_deletevol (/* char *name */);
Xextern int root_fhn2ih (/* char *pname, wf_ih *ihp */);
Xextern int root_name2ih (/* char *pname, wf_ih *ihp */);
Xextern void ih2fh (/* wf_ih *ihp, wf_fh *fhp */);
Xextern int root_name2fh (/* char *pname, wf_fh *fhp */);
Xextern void root_inspect (/* wf_req *reqp, char *arg */);
Xextern void root_getattr_miss (/* wf_thrd *c */);
Xextern void root_read_miss (/* wf_thrd *c */);
Xextern void root_lookup_miss (/* wf_thrd *c */);
Xextern void root_getuda (/* void */);
Xextern void run_task (/* int (*tf)(), void *ta, func cf, void *ca */);
Xextern void sched_task (/* func cf, void *ca, void *wchan */);
Xextern void sched_task_atop (/* func cf, void *ca, void *wchan */);
Xextern void wakeup (/* void *wchan */);
Xextern void sigchld (/* int sig */);
Xextern void do_task_notify (/* void */);
Xextern struct hostent * parse_hostorip (/* char *str */);
Xextern void srv_resolv (/* wf_srv *srvp */);
Xextern wf_srv * srv_findname (/* char *name */);
Xextern wf_srv * srv_findip (/* long ipaddr */);
Xextern wf_conn * srv_getconn (/* wf_srvq *srvq */);
Xextern wf_conn * srv_newconn (/* wf_srvq *srvq */);
Xextern void srv_releaseconn (/* wf_srv *srvp, wf_conn *cp */);
Xextern void srv_flag (/* wf_srv *srvp, int flag */);
Xextern wf_thrd * thrd_alloc (/* void */);
Xextern void thrd_watch (/* wf_thrd *thrdp */);
Xextern void thrd_ignore (/* wf_thrd *thrdp */);
Xextern void thrd_free (/* wf_thrd *thrdp */);
Xextern void thrd_srvfailure (/* wf_srv *srvp */);
Xextern void thrd_start (/* void */);
Xextern void thrd_stop (/* void */);
Xextern void thrd_inspect (/* wf_req *reqp */);
Xextern void trace_event (/* void *handle, wf_trace *tracep */);
Xextern void trace_report (/* void */);
Xextern void trace_start (/* void */);
Xextern void ufs_read_miss (/* wf_thrd *c */);
Xextern void ufs_readdir_miss (/* wf_thrd *c */);
Xextern int uip_id (/* void */);
Xextern void uip_start (/* void */);
Xextern qelem * q_alloc (/* void */);
Xextern void q_insert (/* qelem *elem, qelem *pred */);
Xextern void q_remove (/* qelem *elem */);
Xextern int q_len (/* qelem *elem */);
Xextern void q_allfree (/* qelem *head */);
Xextern void * alloc_and_copy (/* void *v, int vlen */);
Xextern void * alloc_and_clear (/* int vlen */);
Xextern void alloc_start (/* void */);
Xextern int mkdirs (/* char *path */);
Xextern int validate_dir (/* char *dir */);
Xextern void csd_abort (/* int ret */);
Xextern int background (/* void */);
Xextern int bind_resv_port (/* int so, unsigned short *portp */);
Xextern int tcp_send (/* int so, char *fmt, ... */);
Xextern int req_send (/* wf_req *reqp, char *fmt, ... */);
Xextern void getdate (/* void */);
Xextern void unix_command (/* char *cmd */);
Xextern long compute_blocks (/* long size */);
Xextern time_t tm2time (/* struct tm *tm */);
Xextern char * strdup (/* Const char *str */);
Xextern wf_vol * vol_alloc (/* void */);
Xextern void vol_free (/* wf_vol *volp */);
Xextern wf_vol * vol_findid (/* long id */);
Xextern wf_vol * vol_findname (/* char *dir, char *name */);
Xextern int vol_set_name (/* char *name */);
Xextern int vol_set_ftp_server (/* char *hostname */);
Xextern int vol_set_ftp_directory (/* char *subdir */);
Xextern int vol_set_ftp_options (/* char *flagstr */);
Xextern int vol_set_ufs_directory (/* char *topdir */);
Xextern int vol_set_description (/* char *desc */);
Xextern int vol_bind (/* char *name, char *value */);
Xextern wf_vol * vol_load (/* char *dir, char *name */);
Xextern void vol_save (/* wf_vol *volp */);
Xextern wf_conn * vol_getconn (/* wf_vol *volp */);
Xextern wf_conn * vol_newconn (/* wf_vol *volp */);
Xextern void vol_releaseconn (/* wf_vol *volp */);
Xextern void vol_addsrv (/* wf_vol *volp, wf_srv *srvp, char *subdir */);
Xextern void vol_deletesrv (/* wf_vol *volp, wf_srv *srvp */);
Xextern long vol_allocid (/* wf_vol *volp */);
Xextern void vol_destroyid (/* wf_vol *volp */);
Xextern wf_dir * vol_newroot (/* wf_vol *volp */);
Xextern wf_dir * vol_findroot (/* wf_vol *volp */);
Xextern void vol_inspect (/* wf_req *reqp, char *name */);
X
X#endif /* __STDC__ */
X#endif /* __CEXTRACT__ */
END_OF_FILE
  if test 27718 -ne `wc -c <'csd/auto.h'`; then
    echo shar: \"'csd/auto.h'\" unpacked with wrong size!
  fi
  # end of 'csd/auto.h'
fi
if test -f 'csd/wfs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'csd/wfs.h'\"
else
  echo shar: Extracting \"'csd/wfs.h'\" \(13997 characters\)
  sed "s/^X//" >'csd/wfs.h' <<'END_OF_FILE'
X/* 
X * WorldWide File System
X * Copyright (c) 1992,1993 Youki Kadobayashi
X * Copyright (c) 1992,1993 Osaka University
X * All rights reserved.
X *
X * Permission to use, copy, modify and distribute this software and its
X * documentation is hereby granted, provided that the following conditions
X * are met:
X * 1. Both the copyright notice and this permission notice appear in
X *    all copies of the software, derivative works or modified versions,
X *    and any portions thereof, and that both notices appear in
X *    supporting documentation.
X * 2. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *      This product includes software developed by the Osaka University
X *      and its contributors.
X * 3. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE DEVELOPER ``AS IS'' AND OSAKA
X * UNIVERSITY DISCLAIMS ANY LIABILITY OF ANY KIND FOR ANY DAMAGES
X * WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
X *
X * Osaka University requests users of this software to return to
X *
X *  Youki Kadobayashi
X *  Department of Information and Computer Sciences
X *  Osaka University, Toyonaka 560, Osaka, Japan
X *
X * any improvements or extensions that they make and grant Osaka
X * University the rights to redistribute these changes.
X */
X/* $Header: wfs.h[109.0] Wed Nov 24 03:47:20 1993 youki-k@is.aist-nara.ac.jp saved $ */
X
X#include <sys/types.h>
X#include <sys/param.h>
X#include <sys/socket.h>
X#include <rpc/rpc.h>
X#ifndef IPPROTO_UDP
X#include <netinet/in.h>
X#endif
X#include <arpa/inet.h>
X#include "nfs_prot.h"
X#include "cs_prot.h"
X#define WFS_H
X#include "parse.h"
X
Xtypedef enum {
X	Start,
X	Run,
X	Finishing,
X	Quit,
X	Done
X} serv_state;
X
Xtypedef struct sockaddr_in sockaddr_in;
Xtypedef void (*func)();
Xtypedef struct svc_req svc_req;
X
X/*
X * Linked list
X */
Xtypedef struct qelem qelem;
Xstruct qelem {
X	qelem *q_forw;
X	qelem *q_back;
X};
X#define FIRST(ty, q)	((ty *) ((q)->q_forw))
X#define LAST(ty, q)	((ty *) ((q)->q_back))
X#define NEXT(ty, q)	((ty *) (((qelem *) q)->q_forw))
X#define PREV(ty, q)	((ty *) (((qelem *) q)->q_back))
X#define HEAD(ty, q)	((ty *) q)
X#define MORE(q)		((q)->q_forw != q)
X#define ITER(v, ty, q) \
X	for ((v) = FIRST(ty,(q)); (v) != HEAD(ty,(q)); (v) = NEXT(ty,(v)))
X#define REVITER(v, ty, q) \
X	for ((v) = LAST(ty,(q)); (v) != HEAD(ty,(q)); (v) = PREV(ty,(v)))
X#define ITER2(v, w, ty, q) \
X	for ((v) = FIRST(ty, (q)); (w) = NEXT(ty, (v)), (v) != HEAD(ty, (q)); \
X	     (v) = (w))
X
X/* protocol switch & protocol spec */
Xtypedef struct wf_proto {
X	char		*name;		/* protocol name */
X	func		wf_getattr;
X	func		wf_getattr_miss;
X	func		wf_lookup;
X	func		wf_lookup_miss;
X	func		wf_readlink;
X	func		wf_read;
X	func		wf_read_miss;
X	func		wf_readdir;
X	func		wf_readdir_miss;
X	func		wf_getuda;	/* user defined attributes */
X	func		wf_keepalive;
X	func		wf_close;
X	func		wf_shutdown;
X	int		class;		/* protocol class, WF_CLASS */
X} wf_proto;
X
X/* wf_proto->class bitmap */
X#define WF_CLASS_AUTH	0x1	/* authentication */
X#define WF_CLASS_ALIVE	0x2	/* keepalive */
X#define WF_CLASS_RD	0x4	/* reliable delivery */
X
X/* to compute padding */
Xstruct wf_fhsize {
X	long	a;
X	long	b;
X	long	c;
X	long	d;
X	long	e;
X};
X
X/* file handle */
Xtypedef struct wf_fh {
X	long	world_id;	/* filehandle type and version */
X	long	parent_vol;	/* unique in the world */
X	long	child_vol;	/* unique in the world */
X	union {
X		struct {
X			long	u_dir_id;	/* inode */
X			long	u_file_id;	/* crc */
X		} u_file;
X		struct {
X			long	u_parent_dir;	/* inode# of parent dir */
X			long	u_child_dir;	/* inode# of child dir */
X		} u_dir;
X	} u;
X	char	padding[NFS_FHSIZE - sizeof(struct wf_fhsize)];
X} wf_fh;
X
X#define	dir_id		u.u_file.u_dir_id
X#define	file_id		u.u_file.u_file_id
X#define	parent_dir	u.u_dir.u_parent_dir
X#define	child_dir	u.u_dir.u_child_dir
X
Xtypedef struct wf_srvstat {
X	long	bytes_to_server;	/* # of bytes sent to servers */
X	long	bytes_from_server;	/* # of bytes received from servers */
X	long	rtt;			/* round trip time with decay */
X	long	icmp_reply;		/* # of successful echo-reply */ 
X	long	icmp_unreach;		/* # of dest unreach */
X} wf_srvstat;
X
Xtypedef struct wf_connq wf_connq;
X/* per-server information */
Xtypedef struct wf_srv {
X	qelem		q;
X	char		*name;		/* server name */
X	sockaddr_in	sin;		/* network address */
X	int		flag;		/* server status, WF_SRV */
X	long		touch;		/* time of last status change */
X	int		protos;		/* supported protocols, WF_PROTO */
X	long		variant;	/* extension flags, WF_XYZFS */
X	wf_connq	*connq;		/* connections for this server */
X	int		nconn;		/* number of connections */
X	wf_srvstat	stats;		/* per-server statistics */
X} wf_srv;
X
X/* per-volume-server information */
Xtypedef struct wf_srvq {
X	qelem	q;
X	wf_srv	*srv;
X	void	*info;		/* protocol specific */
X} wf_srvq;
X
X/* wf_srv->flag */
X#define	WF_SRV_HUNREACH	0x1	/* server unreachable */
X#define	WF_SRV_NUNREACH	0x2	/* network unreachable */
X#define	WF_SRV_REFUSED	0x4	/* connection refused */
X#define	WF_SRV_XABORT	0x8	/* transfer aborted */
X#define	WF_SRV_TIMEOUT	0x10	/* transfer timeout */
X#define	WF_SRV_BADNS	0x20	/* name-server problem */
X
X/* wf_srv->protos bitmap */
X#define WF_PROTO_FTP	0x1	/* file transfer protocol */
X#define WF_PROTO_NFSUDP	0x2	/* sun NFS over UDP */
X#define WF_PROTO_NFSTCP	0x4	/* sun NFS over TCP */
X#define WF_PROTO_YFS	0x8	/* youki file system */
X
X/* wf_srv->variant bitmap */
X#define WF_FTP_FOLLOW	0x1	/* follow symbolic links */
X#define WF_FTP_NOSTAT	0x2	/* FTP does not support STAT */
X#define WF_NFS_SPONGY	0x4	/* NFS spongy mount */
X#define WF_NFS_COMPRESS	0x8	/* NFS compress */
X
X#define	WF_SRV_MAXCONN	16		/* max # of connection for a server */
X
Xtypedef struct wf_connstat {
X	long	bytes_to_server;	/* # of bytes sent to servers */
X	long	bytes_from_server;	/* # of bytes received from servers */
X} wf_connstat;
X
Xtypedef struct wf_thrd wf_thrd;
X/* per-connection information (server side) */
Xtypedef struct wf_conn {
X	qelem		q;
X	wf_proto	*proto;		/* protocol used */
X	int		id;		/* connection id */
X	wf_thrd		*thrdp;		/* transfer */
X	int		idle;		/* idle time */
X	wf_srv		*srv;		/* peer entity */
X	wf_connstat	stats;		/* per-connection statistics */
X	void		*info;		/* protocol specific */
X} wf_conn;
X
X/* list of per-connection information */
Xstruct wf_connq {
X	qelem	q;
X	wf_conn	*conn;
X};
X
X/* per-session information (client side); primarily for non-RPC protocols */
Xtypedef struct wf_req {
X	long		id;		/* session ID */
X	int		so;		/* socket */
X	sockaddr_in	sin;		/* client address */
X	int		flag;		/* flags */
X} wf_req;
X
X#define	WF_REQ_PRIV	0x01		/* privileged connection */
X
X/* access control information */
Xtypedef struct wf_acc {
X	qelem		q;
X	unsigned long	from;		/* lower bound (host byte order) */
X	unsigned long	to;		/* upper bound (host byte order) */
X	long		flag;		/* WF_ACC_ */
X} wf_acc;
X
X#define	WF_ACC_NFS	0x1
X#define	WF_ACC_UIP	0x2
X#define	WF_ACC_FDP	0x4
X#define	WF_ACC_RAW	0x8
X
Xtypedef struct wf_volstat {
X	long	bytes_to_server;	/* # of bytes sent to servers */
X	long	bytes_from_server;	/* # of bytes received from servers */
X	long	bytes_to_client;	/* # of bytes sent to clients */
X	long	bytes_from_client;	/* # of bytes received from clients */
X	long	n_request_readdir;	/* # of readdir requests */
X	long	n_request_lookup;	/* # of lookup requests */
X	long	n_request_read;		/* # of read requests */
X	long	n_request_readdir_miss;	/* # of readdir actually done */
X	long	n_request_lookup_miss;	/* # of lookup actually done */
X	long	n_request_read_miss;	/* # of read actually done */
X} wf_volstat;
X
Xtypedef struct wf_dir wf_dir;
X/* list of per-volume information */
Xtypedef struct wf_vol {
X	qelem		q;
X	char		*name;		/* volume name */
X	long		id;		/* volume id */
X	char		*dir;		/* directory this volume resides */
X	wf_acc		*accp;		/*   and its access control info */
X	int		flag:16;	/* status */
X	int		nconn:16;	/* number of connections */
X	long		mtime;		/* timestamp of volume update */
X	wf_srvq		*srvq;		/* servers of this volume */
X	wf_dir		*dirp;		/* cached directory chain */
X	wf_thrd		*thrdp;		/* transfer */
X	char		*topdir;	/* for WF_VOL_DIRECTFILE */
X	wf_volstat	stats;		/* per-volume statistics */
X} wf_vol;
X
X/* wf_vol->flag */
X#define	WF_VOL_XCONN		0x1	/* exceeded connection limit */
X#define	WF_VOL_DIRECTFILE	0x2	/* bypass file caching mechanism */
X
X/* constants */
X#define	WF_VOL_MAXCONN	4	/* max # of connection for a volume */
X#define	WF_VOL_BASE	0x10000	/* large enough so that volume IDs can be
X				 * discriminated from directory ID */
X#define	WF_GLUE_BASE	0x8000	/* large enough so that glue IDs can be
X				 * discriminated from directory ID */
X#define	WF_ROOT_VOL_ID	0	/* root file system */
X#if 0
X#define	WF_HOST_VOL_ID	(-1)	/* ".wwfs_host" */
X#define	WF_CWD_VOL_ID	(-2)	/* ".wwfs_cwd" */
X#endif
X#define	WF_FH_VOL_ID	(-3)	/* ".wwfs_fh" */
X
X/* list of per-file information */
Xtypedef struct wf_file {
X	qelem	q;
X	char	*name;		/* filename */
X	char	*link;		/* symbolic link */
X	long	id;		/* file id (crc32 or inode #) */
X	long	crc;		/* crc32 */
X	int	flag;		/* WF_FILE */
X	struct fattr fattr;	/* see nfs_prot.h */
X	wf_thrd	*thrdp;		/* transfer */
X} wf_file;
X
X/* wf_file->flag */
X#define WF_FILE_MARKED		0x1
X#define	WF_FILE_MUTABLE		0x2
X
X/* wrapper macros for this complex data structure */
X#define	FSID(p)		((p)->fattr.fsid)
X#define	FID(p)		((p)->id)
X
X/* list of per-directory information */
Xstruct wf_dir {
X	qelem	q;
X	char	*name;		/* entire directory name */
X	long	id;		/* directory id (inode #) */
X	int	flag;		/* WF_DIR */
X	int	idle;		/* idle time */
X	long	ctime;		/* when this id was allocated */
X	wf_file	*file;		/* files in this directory */
X	int	n_xfer;		/* # of ongoing transfer */
X};
X
X#define	WF_ROOT_DIR_ID	0xffff
X
X/* wf_dir->flag */
X#define	WF_DIR_OBSOLETE		0x1
X#define	WF_DIR_WIREDDOWN	0x2
X
Xtypedef struct wf_ih {		/* internal handle */
X	wf_vol	*parent_volp;
X	wf_dir	*dirp;
X	wf_vol	*child_volp;
X	wf_file	*filep;
X} wf_ih;
X
X/* for filesystem trace */
Xtypedef struct wf_trace {
X	qelem	q;
X	long	cookie;		/* unique id */
X	long	time;		/* timestamp */
X	int	uid;		/* user id */
X	long	client;		/* client ip address */
X	long	volume;		/* volume id */
X	long	dir;		/* directory id */
X	long	file;		/* file id */
X	int	op:16;		/* operation. read(0) or readdir(1) */
X	int	hit:16;		/* cache hit(1) or miss(0) */
X	long	arg;		/* file size etc. */
X} wf_trace;
X
X/* wf_trace->op */
X#define	WF_OP_READ		0
X#define	WF_OP_READDIR		1
X/* wf_trace->hit */
X#define	WF_CACHE_MISS		0
X#define	WF_CACHE_HIT		1
X#define	WF_CACHE_READY		2
X
Xtypedef struct callout callout;
X/* Unified closure.
X * Represents all information about currently processing request.
X */
Xstruct wf_thrd {
X	qelem		q;
X	int		step:16;	/* state of this thread */
X	int		flag:16;	/* WF_THREAD */
X	/* nfs args */
X	svc_req		*rqstp;
X	wf_vol		*parent_volp;
X	wf_vol		*child_volp;
X	wf_fh		*fhp;
X	char		*fname;
X	nfscookie	cookie;		/* nfs_readdir */
X	u_int		offset;		/* nfs_read */
X	u_int		count;		/* nfs_readdir, nfs_read */
X	u_int		totalcount;	/* nfs_read */
X	/* state */
X	wf_fh		*resfhp;
X	wf_dir		*dirp;
X	wf_dir		*olddirp;
X	wf_dir		*dotdotp;
X	wf_file		*filep;
X	/* for user-interface protocols */
X	wf_req		req;		/* deepcopy here */
X	char		*pathname;	/* deepcopy full pathname */
X	int		uid;		/* user id, for trace */
X	unsigned long	client;		/* ip address, for trace */
X	/* transfer state */
X	wf_proto	*proto;
X	wf_conn		*cp;		/* connection for this request */
X	int		so;		/* data connection socket */
X	int		port;		/* port for data connection */
X	int		fd;		/* received data */
X	char		*buf;		/* received data */
X	int		bytes;		/* done so far */
X	int		idle;		/* risky but no response */
X	func		reply;		/* reply to client */
X	func		give_up;	/* encountered difficulty */
X	void		*closure;	/* for give_up */
X	callout		*callout;	/* timeout handle (opaque) */
X};
X
X/* wf_thrd->flag bitmap */
X#define WF_THREAD_BUSY		0x1
X#define WF_THREAD_TIMEOUT	0x2	/* 2: timeout, ~2: in time */
X#define WF_THREAD_RISKY		0x4	/* 4: risky, ~4: safe */
X#define WF_THREAD_ERROR		0x8	/* 8: error, ~8: no error */
X
X/* wf_thrd->step FSM  */
X#define	FTPS_PROMPT		0
X#define	FTPS_STAT_RECV		1
X#define	FTPS_STAT_RECVINIT	2
X#define	FTPS_STAT_RECVLOOP	3
X#define	FTPS_RETR_SEND		4
X#define	FTPS_PORT_ACCEPT	5
X#define	FTPS_RETR_RECVINIT	6
X#define	FTPS_RETR_RECVLOOP	7
X#define	FTPS_RETR_FIN		8
X#define	FTPS_CONN_INIT		10
X#define	FTPS_CONN_USER		11
X#define	FTPS_CONN_PASS		12
X#define	FTPS_CONN_TYPE		13
X#define	FTPS_CONN_FIN		14
X#define	FTPS_CONN_FAIL		15
X
X/* unified error code. limited to internal use. */
X#define	WF_REP_OK	0		/* no error */
X#define	WF_ERR_PERM	1		/* Not owner */
X#define	WF_ERR_NOENT	2		/* No such entity */
X#define	WF_ERR_IO	3		/* I/O error */
X#define	WF_ERR_NXIO	4		/* No such device or address */
X#define	WF_ERR_ACCES	5		/* Permission denied */
X#define	WF_ERR_EXIST	6		/* Given resource exists */
X#define	WF_ERR_NODEV	7		/* No such device */
X#define	WF_ERR_NOTDIR	8		/* Not a directory*/
X#define	WF_ERR_ISDIR	9		/* Is a directory */
X#define	WF_ERR_FBIG	10		/* Resource too large */
X#define	WF_ERR_NOSPC	11		/* No space left on device */
X#define	WF_ERR_ROFS	12		/* Read-only file system */
X#define	WF_ERR_NAMETOOLONG	13	/* Resource name too long */
X#define	WF_ERR_NOTEMPTY	14		/* Directory not empty */
X#define	WF_ERR_DQUOT	15		/* Disc quota exceeded */
X#define	WF_ERR_STALE	16		/* Stale file handle */
X#define	WF_ERR_WFLUSH	17		/* Write cache flushed */
X#define	WF_REP_WAIT	18		/* Operation would block */
X#define	WF_ERR_ALREADY	19		/* Operation already in progress */
X#define	WF_ERR_PROTO	20		/* Protocol not available */
X#define	WF_ERR_NDOWN	21		/* Network is down */
X#define	WF_ERR_NUNREACH	22		/* Network is unreachable */
X#define	WF_ERR_XABORT	23		/* Transfer aborted */
X#define	WF_ERR_TIMEOUT	24		/* Connection timed out */
X#define	WF_ERR_REFUSED	25		/* Connection refused */
X#define	WF_ERR_HDOWN	26		/* Host is down */
X#define	WF_ERR_HUNREACH	27		/* No route to host */
X#define	WF_ERR_NQUOT	28		/* Network quota exceeded */
END_OF_FILE
  if test 13997 -ne `wc -c <'csd/wfs.h'`; then
    echo shar: \"'csd/wfs.h'\" unpacked with wrong size!
  fi
  # end of 'csd/wfs.h'
fi
if test -f 'doc/manual.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/manual.tex'\"
else
  echo shar: Extracting \"'doc/manual.tex'\" \(43575 characters\)
  sed "s/^X//" >'doc/manual.tex' <<'END_OF_FILE'
X\documentstyle[11pt,ascmac,a4wide,epsf]{book}
X\input{version.tex}
X\title{{\bf WWFS Reference Manual} \\
X        version \wwfsversion}
X\author{        Youki Kadobayashi \\
X                {\tt youki@wide.ad.jp} \\
X                Department of Information and Computer Sciences \\
X                Osaka University, Japan}
X
X\newcommand{\ID}{{\sc id}}
X\font\tentt = cmtt9
X\font\elvtt = cmtt10
X
X\begin{document}
X\maketitle
X\tableofcontents
X
X\chapter{Introduction}
X
X% \begin{quote}
X% {\it Although I have tried to describe every aspects of WWFS in this
X% document, there may be syntactically incorrect sentences and strange
X% wording.  If you have any comments or suggestions on this document,
X% please send e-mail to the alpha-testers mailing list. Instructions for
X% feedback are given in Section \ref{contrib_send}.}
X% \end{quote}
X
X\section{Description}
X
X% What is WWFS?
XWWFS (WorldWide File System, or Waku-Waku File System) is a filesystem
Xwhich extends NFS over the Internet, while achieving simplicity,
Xscalability, and compatibility.
X% What can I do with it?
XWWFS users can access existing FTP archives without expert knowledge
Xof the Internet and other network applications.
X
X% Who can use it?
X% Why shall I use it?
XWWFS is not wizard's vehicle.  It eliminates burden of users and
Xnetwork administrators. There is no need to worry about hostname,
Xpathname, or geographical location of the host. Once network
Xadministrator arranged ``volumes'' for you, it's no longer necessary
Xto remember the details of FTP archives. Also, WWFS supports network
Xadministrators by letting them estimate, optimize or regulate file
Xtransfer.
X
X% How to use it?
XWWFS is not technology with another dozen buzzword.  Every existing
XUNIX command works fine, just as ordinary UNIX file systems, apart
Xfrom some strange behaviors resulting from large delays in the
XInternet.  Because it is built on top of a filesystem, many existing
Xcommand works fine with little or no modification; MULE does great job
Xwith dozen Emacs lisp jewels, and NCSA {\sc Mosaic} now saves your
Xtime and network bandwidth with
Xdirect WWFS support.
X% Where can I use it?
XYou can use it ``off-the-shelf'', without any modification to the UNIX
Xkernel. Server and client runs on a number of BSD-derivatives, since I
Xused widely available features only. Client workstations require
Xminimal addition: {\tt wwmount} and {\tt wwumount}, which is modified
Xversions of mount/unmount commands. With the cluster server ({\tt
X  csd}) running on a well-endowed, well-managed machine, everyone can
Xshare those cached information with little performance overhead.
X
X% When can I use it?
XSo just try it.  It's technology of today --- enabling future
Xapplications to come out now.
X
X\begin{figure}
X\begin{center}
X\epsfile{file=overview.eps,scale=0.7}
X\end{center}
X\caption{Cluster Server: An NFS server, an NFS-FTP gateway software,
Xor the Internet file cache.}
X\label{fig_overview}
X\end{figure}
X
X\section{Organization of this distribution}
X
XThis release contains source code and documentation for our
Xintermediary file-server software named Cluster Server ({\tt csd}),
Xclient software, direct WWFS support in NCSA {\sc Mosaic} for X, API
X(application programming interface), API examples,
X% sample graphical user interface written in Tk,
Xsome perl scripts for administration, and volume files for variety of
Xinformation resources in the Internet.
X
XDirectories are organized as follows:
X
X\begin{itemize}
X\item   {\tt caps/} \\
X  {\tt perl} scripts and shell scripts.
X  CAPS stands for Client Administration Perl Scripts.
X\item   {\tt config/} \\
X  Machine-, architecture- and operating-system dependent files.
X\item {\tt csd/} \\
X  An NFS server, an NFS-FTP gateway software, the Internet file cache,
X  or the substrate for scalable information systems, that runs as a
X  daemon in the user mode.  Modification to the UNIX kernel is not
X  necessary at all.  It can be accessed as an ordinary NFS server from
X  virtually any client workstations with NFS capability. It talks with
X  anonymous ftp servers using FTP protocol (see Figure
X  \ref{fig_overview}).
X\item   {\tt doc/} \\
X  Documentation, both finished and unfinished, including
X  memorandum and preliminary ideas.
X  Some may be only useful to interested developers.
X\item   {\tt gtr/} \\
X  A package to rearrange servers by geographical / topological region.
X\item   {\tt include/} \\
X  Header files for C programs.
X\item   {\tt libww/} \\
X  Application programming interface, for bypassing NFS when necessary.
X\item {\tt mosaic/} \\
X  Patches to add direct WWFS support to NCSA {\sc Mosaic} for X,
X  the multi-protocol information browser.  Also included here are
X  migration tools from Internet Gopher Protocol and HyperText
X  Transfer Protocol.
X\item   {\tt mule/} \\
X  Emacs lisp package to access WWFS within multi-lingual EMACS.
X\item   {\tt rpc/} \\
X  Subroutines for remote procedure call.
X\item   {\tt saps/} \\
X  SAPS stands for Server Administration Perl Scripts;
X  some of which has been used for day-to-day server administration.
X\item {\tt vol/} \\
X  Volume files, that describe server-to-location mappings
X  and alternative servers.
X\item {\tt wwalk/} \\
X  Point-and-click style graphical user interface,
X  which is actually a rework of my good-old-days Tk script. You need
X  Tk2.3, TclX6.4c, and tclRawTCP-1.0 to run this script. {\em It's not
X    updated in this release.} If you don't know what Tcl and Tk is,
X  just get the {\tt comp.lang.tcl} FAQ from USENET newsgroups (or just
X  go to {\tt /news.answers/tcl-faq} on WWFS).
X\item {\tt wwmount/} \\
X  A modified version of {\tt mount} and {\tt umount} command, based on
X  BSD Net2.
X\end{itemize}
X
X\begin{figure}[h]
X\begin{center}
X\epsfile{file=architecture.eps,scale=0.6}
X\end{center}
X\caption{WWFS: shared namespace, replicated services, binding mechanism,
Xand right protocol for the right place.}
X\label{fig_architecture}
X\end{figure}
X
X\chapter{Installation}
X
XThis chapter describes installation procedure of this software suite.
XBefore beginning installation, you must make sure that you have
Xnecessary tools handy, then decide where you install this software.
X
X\section{Bootstrapping environments}
X
XThe following tools are necessary to generate executables
Xand to perform administrative tasks:
X
X\medskip
X\begin{tabular}{|l|l|} \hline
Xname            & requirements \\ \hline
Xmake            & bundled {\tt make}, or GNU {\tt make}. \\
Xcc              & bundled {\tt cc}, or GNU {\tt cc}. \\
Xperl            & version 4.0 or later. \\ \hline
X\end{tabular}
X\medskip
X
XBasically any brain-damaged {\tt make} should work.  If it doesn't work,
Xplease let me know.
X
XIf you are planning to make {\sc Mosaic/WWFS}, you will need Motif/X11
Xlibraries.  You can grab binaries from {\tt WWFS/binaries} on WWFS and
Xoriginal Mosaic source from {\tt NCSA/Web/Mosaic-source} on WWFS.
X
XIf you are planning to hack {\tt wwalk}, a point-and-click style
Xdirectory browser for the X Window System, you need Tcl and Tk.  Note
Xthat this stuff is no longer maintained up to date.  Bunch of Tcl
Xstuff is available from {\tt tcl-tk} on WWFS.
X
XIf you are willing to adapt, improve or port this software by
Xyourself, I strongly recommend the use of GNU software suite to
Xfacilitate development. If you are planning to modify the source code,
XI recommend the use of additional tools which I have been using for
Xday-to-day programming tasks:
X
X\medskip
X\begin{tabular}{|l|l|} \hline
Xname            & description \\ \hline
Xcextract        & C prototype extractor \\
Xgdb             & GNU debugger \\
Xlsof            & process file-table inspector \\
Xmalloclib       & malloc debugging library \\
Xmkid            & source code indexing tool \\
Xrpcsrc-4.0      & Sun RPC source \\ \hline
X\end{tabular}
X\medskip
X
XOther brand-new tools or commercial programming environments might be
Xof great help. I am very much interested to share any programming tips
Xwith other developers (preferably via mailing list).
X
X\section{Planning server installation}
X\label{install_plan}
X
X% Determine the size of the cache -- other extras isn't significant
XNow you must determine where to put related material. You need
Xsufficient amount of storage because our daemon cache accessed files.
XNecessary storage space varies depending on the number of users, user
Xactivity, and granularity of cached files, but you can start with
Xrelatively small space (e.g., 40Mbytes) and change the partition
Xlater, when demands exceed supply.  Other extras, such as logs and
Xmaintenance scripts, do not occupy much space as compared with cache
Xdirectories.
X
X% Make the cache partition and mount it if you want -- optional
XIf you have a relatively large empty partition available and you are
Xplanning to use WWFS regularly, it would be better to allocate the
Xentire partition to WWFS, since cache occasionally grows quickly when
Xusers access WWFS in a sudden burst\footnote{Also, WWFS has had a
X  strange bug which filled up entire partition, although it was known
X  to be harmless and is now exterminated.}. If you are planning to
Xadopt this option, simply {\tt newfs} it, create mountpoint and {\tt
X  mount} it as usual. No special operation is necessary since the
Xcaching mechanism is built on top of UNIX file system.
X
X% Make appropriately named directory for WWFS
XWWFS requires a directory tree to store various information. Name the
Xtop directory appropriately (e.g., {\tt /var/wwfs}) and make sure it
Xis writable by root. It can reside either on a local disk or on an
XNFS-mounted disk, but I recommend the use of local disk for better
Xreliability and performance.
X
X\section{Installing the Cluster Server}
X\label{install_server}
X
XThe {\tt csd} included in this release is known to work on the
Xfollowing platforms:
X
X\medskip
X\begin{tabular}{|l|l|} \hline
X        hardware        & operating system \\ \hline
X        Sun [34]        & Sun OS 4.1.[123] \\
X        DECstation      & Ultrix 4.3 \\
X        Gateway 2000    & BSD/386 \\
X        OMRON Luna 2    & BSD / Mach 2.5 \\
X        SUMI STATION    & RISC/os 4.x \\
X        Sony NEWS       & NEWS-OS 4.[012] \\ \hline
X\end{tabular}
X\medskip
X
XBasically any 4.3BSD, 4.4BSD or OSF/1 machines is OK (well, supposed to be).
X
XThis software is not tested on other platforms. Port to other
Xplatforms will be easy however, if the target platform implements Sun
XNFS, the Berkeley family of filesystems (FFS or FFFS) and 4.[34]BSD
Xsystem calls.  I haven't made further attempt to port this software to
Xmore esotelic platforms (largely due to lack of motivation for it and
Xfamiliarity with unseen beasts), but I hope we can support many more
Xplatforms without pain.
X
X\subsection{Edit {\tt csd.conf} and {\tt Makefile.config}}
X
XIf you are using one of these supported platforms, skip to the next
Xparagraph.  If you are not, then read comments in the {\tt
X  config/Makefile.config} and edit flags accordingly.  There are lots
Xof configuration files in the {\tt config/} directory, which has been
Xmostly stolen from the {\tt amd}, the 4.4 BSD automounter.  If your
Xplatform has been supported by the {\tt amd}, you can avoid
Xre-inventing the wheel by starting there.
X
XNext, modify {\tt config/csd.conf} to reflect your decision in Section
X\ref{install_plan}.  Let us call it {\tt WWFSDIR}.  {\tt csd.conf} is
Xreferenced by various utilities including make, shell scripts, perl
Xscripts and tcl scripts.
X
X\subsection{Just type {\tt make}}
X
XAt the top directory of the distribution, just type {\tt make}.  It
Xautomagically guesses your architecture and operating system.
X
X{\tt make} will start compilation, and eventually generate the server
Xprogram ({\tt csd}) and client commands ({\tt wwmount} and {\tt
X  wwumount}), among other things. You can ignore a lot of warnings
Xduring compilation procedure, especially if your compiler conform to
Xthe ANSI standard.
X
XNOTE: It's not desirable to hand-edit C files generated by {\tt
X  rpcgen}.  If you have encountered any difficulty with compiling
X\verb+*_prot_*.c+ files, you must regenerate these files using {\tt
X  rpcgen}.  To do this, step down to {\tt rpc/} then just type {\tt
X  make}.
X
X\subsection{Edit {\tt /etc/passwd}}
X
XIf this is the first time for your server installation, you must
Xcreate a local account with user \ID\ {\tt wwfs} and group \ID\ {\tt
X  operator} (or its counterpart in your system), at the machine
Xdesignated as your cluster server, since {\tt csd} operates under this
Xaccount, and since all files and directories beneath {\tt WWFSDIR}
Xwill be owned by the account.  Choice of user \ID\ and group \ID\ is
Xarbitrary, but you must choose \ID s carefully so that other
Xfilesystems can be protected from unexpected behaviour of {\tt csd}
X(which is very unlikely though, but serious admins wants firewall).
XAn excerpt from our password database follows.
X\begin{verbatim}
Xwwfs:*:40:5:WWFS manager:/var/wwfs:/bin/csh
X\end{verbatim}
X
XSince {\tt csd} uses {\tt wwfs@name.of.this.machine} for e-mail
Xaddress, this account should be reachable by e-mail and every received
Xmessage should be forwarded to the administrator. The e-mail address
Xhas been used for statistics reports and password (contact address,
Xthat is) for anonymous ftp login.
X
X\subsection{\tt make install-server}
X
XAs root, go to the top directory of the distribution, then type:
X\begin{verbatim}
Xmake install-server
X\end{verbatim}
XThis will install the {\tt csd} and shell/perl scripts appropriately,
Xcreating the following directories beneath {\tt WWFSDIR}:
X
X\begin{itemize}
X\item   {\tt bin/}      --- executables are installed here.
X\item   {\tt cache/}    --- cached information is stored here.
X\item   {\tt etc/}      --- configuration files for perl scripts.
X\item   {\tt lib/}      --- for library files used by perl scripts.
X\item   {\tt log/}      --- logs and event traces go here.
X\item   {\tt stale/}    --- stale files and directories are moved here.
X\item   {\tt ongoing/}  --- all interim data, including files, are stored here.
X\item   {\tt vol/}      --- volume files are stored here.
X\end{itemize}
X
XNow you finished server installation procedure. Please read Sections
X\ref{admin_server} and \ref{admin_volumes} for starting up the Cluster
XServer.
X
X\section{Installing mount commands}
X\label{install_client}
X
XNow you compile {\tt wwmount} and {\tt wwumount} for use on your
Xworkstation clusters.  Or you can grab binaries from {\tt
X  WWFS/binaries} on WWFS.
X
XThe mount commands is known to work on BSD/386 1, SunOS 4, Ultrix 4,
XOSF/1 1.3, IRIX 4, HP-UX 8, NEWS-OS 4, RISC/os 4, NeXT OS, and Luna
Xfamily of operating systems.  Bascially any 4.3BSD, 4.4BSD or OSF/1
Xmachines should be OK (say VAX or Tahoe which I don't have access to).
XAlso, it is relatively easy to port the client software to non-BSD
Xplatforms.  I would like to know if it runs on Solaris 2 and NEWS-OS
X6; please let me know if it runs on one of these (and other exotic
Xoperating systems :-).
X
XNOTE: BSD/386 and possibly other operating systems with 'Guelph NFS'
Xmay suffer from the symptom that previously uncached directories
Xremain empty even when FTP transfer completes and directories get
Xfilled.  I don't have any smart idea on how to fix it except modifying
Xthe BSD kernel.  I hope 4.4BSD have fixed this bug.
X
XNOTE: Luna2/Mach users must steal {\tt mount.o} from Luna/UniOS-B
X{\tt libc.a}.
X
XYou must modify {\tt config/wwfs.conf} accordingly.  It is referenced
Xby various utilities including shell scripts, perl scripts and tcl
Xscripts.
X
XYou may need to edit {\tt config/Makefile.config} and correctly set
Xthe following flags.
X
X\medskip
X\begin{tabular}{|l|l|} \hline
Xname    & description \\ \hline
X{\tt ETCDIR}    & {\tt wwmount} and {\tt wwumount} goes here \\
X{\tt LIBDIR}    & {\tt libww.a} goes here \\
X{\tt INCDIR}    & {\tt libww.h} goes here \\ \hline
X\end{tabular}
X\medskip
X
XJust type {\tt make install-client} then it will install {\tt
X  /etc/wwfs.conf}, mount commands, libraries and header files.
X
X\chapter{Administration}
X
XThis chapter is written for the administrator of the Cluster Server
X({\tt csd}).  Please read Sections \ref{admin_server} and
X\ref{admin_volumes} for starting up {\tt csd}.
X
X\section{Server administration}
X\label{admin_server}
X
XThe Cluster Server, {\tt csd}, can be restarted anytime. Basically,
Xthere is no loss of information due to termination, since cached
Xinformation is kept on the disk. You should be careful however, since
Xthere might be ongoing file transfer, and there might be some users
Xaccessing WWFS.
X
X\subsection*{Starting server process}
X
XTo start the server process, become superuser and just type {\tt
X  csd-nanny} to start {\tt csd}.  (presumably installed at
X\verb+WWFSDIR/bin+).
X
XNOTE: WWFS provides non-stop operation with {\tt csd-nanny}, an
Xiterative and automatic debugger front-end specifically written for
Xnon-stop programs such as {\tt csd}.  {\tt csd-nanny} is included in
X{\tt saps/} directory of this distribution.  For more information on
X{\tt csd-nanny}, read the source, which is actually a small perl
Xscript and is well-documented.
X
X\subsection*{Terminating server process}
X
X{\tt csd} can be killed just as other daemon processes. You can use
Xeither {\tt SIGINT}, {\tt SIGTERM} or {\tt SIGKILL}. Termination is
Xlogged as such, using {\tt syslog} facility.  {\tt csd-nanny} detects
Xtermination and automatically restarts {\tt csd}.
X
XIf you really want to stop {\tt csd}, first kill {\tt csd-nanny} then
X{\tt csd}.  But beware: if someone was accessing WWFS when you stopped
Xthe daemon, his shell (or other accessing processes, say Emacs) will
Xbecome frozen.  This is normal NFS behaviour and not a bug in WWFS.
X
X% His
X% ongoing file transfer, if any, will be aborted (the vestige remains
X% though).  Although I will try to address these problems in forthcoming
X% versions, you are advised to monitor filesystem activities so that
X% termination of the daemon will not lead to any loss of data or client
X% blockage.  Use of {\tt wall} might be a good idea on a big cluster
X% like NAIST, where {\tt csd} has been serving hundreds of machines.
X
X\subsection*{Managing cache}
X
X% expire
XCurrently, {\tt csd} does not reclaim secondary storage by itself.
XThe shell script {\tt expire.sh}, which has been included in this
Xdistribution, should be invoked regularly via {\tt crontab} (typically
Xonce a week). It expires ``inactive'' files that haven't been accessed
Xfor more than two weeks, so that cache partition will not be filled up
Xwith ``no longer referenced'' files.  Directories do not expire, but
Xobsolete directory listings are automatically discarded and superseded
Xby newer ones.
X
XNOTE: It's okay to delete cached files selectively, but it's not
Xrecommended to delete cached directory files (i.e., files within {\tt
X  dir/} directory) unless you want to remove cached information for
Xthe whole volume.  Even if all cached directory files were lost, {\tt
X  csd} continues to function but {\tt csd} will occasionally forget
Xwhich file is cached and which is not.
X
X% consistency check?
XOther management tools, such as file system consistency checker, will
Xbe available in future versions.
X
X% accident?
XIf {\tt csd} was accidentally killed by someone, even with
X{\tt SIGKILL}, the chances are that user's ongoing file transfers
Xweren't lost; just take a look at the {\tt ongoing} subdirectory of
X{\tt WWFSDIR}, where interim files are kept.
XSignificant amount of effort have been paid so that daemon can survive
Xvirtually eternally, and can be restarted anytime without loss of
Xdata.
X
X\subsection*{Snooping cache with perl}
X
XI have written {\tt libmm.pl}, the Maru-Maru library (counterpart of
XWaku-Waku in Japanese) in the hope that perl scripts built upon this
Xpackage complements features not implemented in {\tt csd}, thereby
Xenabling much more advanced features such as cache strategy selection,
Xcache statistics and cache consistency management.  I have also added
XUIP commands that enables close collaboration of {\tt csd} and these perl
Xprograms.
X
XNOTE: This package works only on localhost (that is, the machine
Xrunning csd) for security reasons.
X% Current implementation of UIP server restricts
X% CTOR/RTOC access to localhost.
X
XSeveral sample perl scripts are provided in the {\tt libww/}
Xsubdirectory of this distribution; I hope these examples facilitate
Xwriting perl scripts for {\tt csd} administration.
X
X\section{Client administration}
X
X% install wwclient
X{\tt wwclient}, a perl script, is included in this distribution to
Xfacilitate the administration of clients. It should be already present
Xin {\tt /etc} if you have done {\tt install-client}.
X
X% invoke wwclient in rc.local
XIf you want a client machine to automatically mount WWFS, you can do
Xit with {\tt wwclient}.  To do this, add the following lines to
X{\tt /etc/rc.local}:
X
X\begin{screen}
X\small
X\begin{verbatim}
X# WWFS
Xif [ -f /etc/wwclient -a -f /etc/wwfs.conf ]; then
X        /etc/wwclient
Xfi
X\end{verbatim}
X\end{screen}
XThis does not work if {\tt csd} does not respond to client's request
Xfor some reason (e.g., temporarily terminated for reboot).
X
X% acct users beware
XSites using {\tt acct} should beware so that it does not traverse
Xbeneath WWFS mount point. Some sites report that {\tt diskusg}, the
Xdisk accounting command of System V, makes {\tt csd} crash.
X
X% daily crash
XAlso, {\tt /usr/adm/daily}, {\tt /usr/spool/cron/crontabs/root} and
Xother periodically kicked maintenance scripts should be checked so
Xthat {\tt find} do not traverse beneath WWFS mount point. Traversal
Xshould be limited to local disks with appropriate {\tt find} options
Xsuch as {\tt -xdev} and/or {\tt -fstype nfs -prune}.
X
X\section{Troubleshooting {\tt csd}}
X\label{admin_troubleshooting}
X
X% inspecting logs
X
X\subsection*{Reporting bugs}
X% Use {\tt csd-nanny} if your {\tt csd} dumps core
X
XAlthough it is very unlikely, if your daemon runs out of CPU or
Xmemory, please be prepared to send bug reports to me.  I would
Xlike to particularly know:
X
X\begin{itemize}
X\item   if it is reproducible.
X\item   peculiarities of your network configuration.
X\item   peculiarities of your administrative tools.
X\item   debug logs produced by {\tt csd-nanny}.
X\end{itemize}
X
XIf you could get snapshots of debug session, then please e-mail them
Xto me. I am very grateful to receive your bug report.
X
X\subsection*{Other troubles: send e-mail}
X
XIf you have faced any other problem concerning the server software,
Xplease send e-mail to me (or the WWFS mailing list). If you have any
Xproblem with the client software, please make sure to read chapter
X\ref{using_wwfs} before asking any question to me, since it might be
Xthe inevitable oddities of global filesystems.
X
X\section{Volume administration}
X\label{admin_volumes}
X
X% what is volume
XI have introduced the notion of {\em volume} that is a group of files
Xwith a specific purpose and organized within a subtree, since every
Xanonymous ftp server contains tons of files with different purpose
Xand since it is difficult to locate where those files have been
Xcategorized, while it is relatively easy to find desired files
Xwithin the directory subtree.
X
X% what is volume for
XVolume makes it easy to find necessary information, since volumes have
Xbeen indexed with keywords and no extra information is necessary to
Xaccess them.
X
X% benefits
XThe separation of {\tt hostname:directory} and archived files yields
Xseveral benefits. An archive administrator can provide alternative access
Xpoint for the same files, so that alternative server is available when
Xthe original server become unavailable for some reason, such as network
Xtroubles and disk crashes. In other words, the task of locating file
Xserver, exploring directory trees, and switching between file servers
Xbecome automatic, once the administrator creates volumes.
X
X% who does administration
XTraditionally, these tasks have been done by the people called ``ftp
Xhacker''. Now that we have WWFS, their efforts can be publicized in
Xthe form of {\em volume file}, that will benefit every users of the
Xfilesystem. If you are not ftp type and you are not willing to
Xadminister volumes, ask your friendly ftp hackers to do the task
Xinstead.
X
X% how to share it
X% how to organize it
XThe beautiful point of volume files is that they can be shared among
XInternet sites. However, their uncontrolled distribution will lead to
Xtotally chaotic situation, which is no better than current ftp
Xarchives. Thus coordination by authoritative organization should be
Xnecessary in near future.
X
X\subsection*{Installing volumes}
X
XVolume files must be installed properly to enable access to volumes.
XYou must hold write permission on the volume directory, which is
Xnormally {\tt WWFSDIR/vol}.
X
X\subsection*{Creating new volumes}
X
XIf you or your clients want to access other ftp directories not listed
Xin existing volumes, you can create a new volume for that.
X% writing volume file
XYou can write a volume file with your favorite text editor. The syntax
Xof volume file can be described as follows:
X
X\begin{tabbing}
Xxxxxxxx \= foo \kill
Xfile    \> ::= line $|$ line file \\
Xline    \> ::= key: value \\
Xkey     \> ::= \{ ``volume-id'', ``ftp-server'', ``ftp-directory'' \}
X\end{tabbing}
X
X% volume id must be unique
XAlthough {\tt map.pl} tries to assign unique volume \ID\ for each
Xvolume file, it cannot make sure that given volume \ID\ is unique.
X{\tt map.pl} maintains the next free volume id in the {\tt seq} file,
Xwhich is located at {\tt WWFSDIR/vol}.  However, if the volume id
Xconflicts for some reason, {\tt csd} may behave incorrectly.  You must
Xguarantee the uniqueness of volume \ID s.  The most viable solution is
Xprobably that you learn {\tt perl} and troubleshoot your problem
Xyourself.
X
X% listing alternative servers
XIt is desirable to list all alternative servers that provide the same
Xvolume. If there are alternative servers, {\tt csd} will switch to
Xsecondary server if the primary server became unavailable due to
Xnetwork problems or hardware problems. An example, {\tt
X  X-contrib.vol}, is shown below, which enumerates alternative
Xservers.
X
X\begin{screen}
X\small
X\begin{verbatim}
Xvolume-id:      34
Xftp-server:     ftp.center.osaka-u.ac.jp
Xftp-directory:  X-contrib
Xftp-server:     ftp.iij.ad.jp
Xftp-directory:  pub/X/contrib
X
Xftp-server:     ftp.x.org
Xftp-directory:  contrib
Xftp-server:     ftp.germany.eu.net
Xftp-directory:  pub/X11/contrib
Xftp-server:     nic.switch.ch
Xftp-directory:  mirror/X-contrib
X
Xdescription:    Contributed software for X Window System
X#category-youki:        free/gui
X\end{verbatim}
X\end{screen}
X
XThe priority of access is determined by the order of listing; the topmost
Xone becomes primary server.
X
XNOTE: ``ftp-server:'' can be either hostname or IP address, so that
X{\tt csd} can run on corporate networks without DNS.
X
X\subsection*{Modifying volumes: {\tt make reload}}
X
X% why modify -- for speed, to save bandwidth, to balance the load
X% see ``working with archive servers''
XYou can accommodate volume files to your network configuration by
Xsorting server information in volumes files so that file transfer can
Xbe optimized; response time can be improved, load can be reduced, and
Xbandwidth can be saved.
X
XThis release comes with GTR, which automates selection of nearest
Xserver by GTR configuration file ({\tt WWFSDIR/etc/gtr.conf}) and GTR
Xresource records stored in DNS.  As this server selection scheme is
Xnot standardized, GTR resource records can be stored in a flat file
X({\tt WWFSDIR/etc/gtr.txt}).  Please look at {\tt gtr/} directory for
Xmore detailed information on GTR.
X
XTo install modified volumes, reload them using {\tt WWFSDIR/Makefile}.
XVolumes can be reloaded while {\tt csd} is running.
X
X\subsection*{Deleting volumes: {\tt make unload}}
X
X% why delete -- basically there is no need to delete
X% what to delete -- obsolete, or reorganized volumes
X% how to delete -- geez, delete and restart
XVolumes can be deleted, either because they are reorganized into other
Xvolumes or because they became obsolete and no longer necessary.  You
Xcan delete the volume files in {\tt WWFSDIR/vol}. Use {\tt
X  WWFSDIR/Makefile} to reflect the removal.
X
X\subsection*{Organizing volumes}
X
XYou can organize volumes by creating subdirectories under WWFSDIR/vol
Xand moving appropriate\footnote{The real question is that what's
X  appropriate.} volumes into that directory.  You must think twice
Xbefore doing this, since we do not provide any smart scheme to pick up
Xdesired volumes from hundreds of volumes that are organized in
Xsubdirectories.  The number of volumes does not change no matter how
Xyou organize it, and after all, how good is subdirectories that have
Xhundreds of volumes in each?
X
XWe are merely escaping from the namespace explosion problem; but at
Xleast we learned one thing: flat namespace with carefully annotated
XINDEX does help.
X
XIf you have {\sc Mosaic/WWFS} running, try looking at {\tt
X  wwfs:/WWFS/web/WWFShome.html}.
X
X\subsection*{Generating INDEX: {\tt make index}}
X
XSince volumes are initially invisible, users must be informed of their
Xavailability. The list of available volumes can be generated from
Xvolume files using {\tt makelist.pl}. To do this, simply type {\tt
X  make index} in {\tt WWFSDIR}.
X
X\subsection*{Automating administration with Makefile}
X
XSome of procedural tasks tend to be commonly performed by
Xadministrators. Such tasks can be facilitated by preparing a {\tt
XMakefile}.  Sample {\tt Makefile} have been provided for these
Xpurpose; they are copied to {\tt WWFSDIR} upon correct
Xinstallation. You are encouraged to tweak it and create {\tt perl}
Xscripts for smarter administration.
X
X\section{Access control and security}
X\label{access_control}
X
XFor some reason, you may want to make the filesystem visible to
Xcertain subnets but keep it inaccessible from the rest of the world.
XYou can do this with access control file named {\tt access}.  Access
Xcontrol files can be placed in arbitrary subdirectory of WWFSDIR/vol;
Xin other words, if you want to make some sensitive information
Xaccessible as volumes, make a subdirectory under WWFSDIR/vol, move
Xsensitive volumes there, and put {\tt access} there.  I do not go into
Xdetail about its grammer; here is an example {\tt access} file.
X
X\begin{screen}
X\small
X\begin{verbatim}
X163.221.32-163.221.68       nfs,uip    # address range
X163.221.80.*-163.221.96.*   nfs,uip    # same effect
X163.221.74.25               nfs,uip    # specific host
X163.221.78.*                nfs,uip    # 0 to 255
X\end{verbatim}
X\end{screen}
X
XBasically it's combination of {\em address range} and {\em
X  capability}.  Host names and domain names are not allowed here,
Xsince there are only tricky and non-standard way to retrieve subnet
Xmasks and subnet addresses via DNS.
X
XNOTE: You may want to ensure security at your firewall gateways (i.e.,
XInternet routers at the outermost segment) by letting them drop
Xpackets of UDP port 8000 (csd NFS), UDP and TCP port 8002 (csd UIP).
X
X
X\chapter{Using WWFS}
X\label{using_wwfs}
X
X% this chapter is for general public
XThis chapter is intended for casual UNIX users who can understand what
Xshell is and what {\tt ls} is. Even if you are wizard, you are
Xrecommended to glance through this chapter at least once.  Also, you
Xmay want to ask your local WWFS administrator for local configuration
Xinformation and/or local guide.
X
X\section{{\tt wwclient}: starting to be a WWFS client}
X
X% wwmount
XIf you or your system administrator has already mounted WWFS, you can
Xskip this section. You can see if WWFS have been mounted with the
X{\tt mount} command:
X\begin{screen}
X\small
X\begin{verbatim}
Xyouki-k@dec416$ /etc/mount | grep wwfs
Xfsa2:wwfs on /ww/fs type nfs (ro,soft)
X\end{verbatim}
X\end{screen}
X
XIf it's not mounted, then {\tt grep} will display nothing. In that
Xcase, you can mount WWFS by yourself (if you don't have superuser
Xprivilege, ask your system administrator to do so). There should be a
Xperl script named {\tt wwclient} somewhere in your filesystem
X(presumably {\tt /etc}, {\tt /usr/local/etc} or {\tt
X  /usr/local/ww/etc}).  You can mount WWFS by invoking {\tt wwclient}
Xas root without any arguments. If you can't find it, ask your local
XWWFS administrator for help.
X
X\section{Stopping to be a WWFS client}
X
X% wwumount
XIf you decided to stop using WWFS for some reason, you don't have to
Xunmount the filesystem. However, if your WWFS administrator asked you
Xto unmount the filesystem, you would better do that.  To unmount the
Xfilesystem, simply give the mount point as its argument. An example
Xfollows.
X\begin{screen}
X\small
X\begin{verbatim}
Xdec416# wwumount /ww/fs
X\end{verbatim}
X\end{screen}
X
X\section{Accessing volumes}
X
X% ls, ls snapshot...
XVolumes are represented as ordinary directories, but it is invisible
Xat first time. A volume is made visible only after it has been
Xaccessed explicitly, since users will get bewildered if thousands of
Xvolumes have been visible at once.
X\begin{screen}
X\small
X\begin{verbatim}
Xyouki-k@dec416$ ls /ww/fs
XCERN-web/  CTAN/      GNU/       INDEX      WWFS/      www/
X\end{verbatim}
X\end{screen}
X
X% Although they are currently organized directly beneath the mount point
X% in a flat manner, it should be improved somehow. Organization of
X% namespace is a touchy subject however, and it forms different research
X% gender. Your comments and opinions are welcomed.
X
X\section{Accessing directories}
X
XDirectories in WWFS can be accessed just like other filesystems using
Xyour favorite tools, with one noticeable difference: you must
Xsometimes retry. It will take longer when {\tt csd} establish FTP
Xconnection with anonymous ftp server.  You must be patient for this,
Xsince delays are inevitable in the Internet and delays increase as the
Xlogical distance between client and ftp server increase.
X
XNOTE: If you feel it really irritating to type {\tt ls} repeatedly,
Xyou should plan to re-compile {\tt ls} with {\tt libww}.  See
XChapter \ref{useful_hacks} for more detail.
X
X\section{Accessing files}
X
X% more, more snapshot...
XFiles suffer the same problem with directories. Generally, you cannot
Xexpect a file transfer to complete real soon now unless you have
Xenough bandwidth available for you. Therefore, the initial access to
Xthe designated file is likely to fail especially under poorly
Xconnected networks. After certain amount of time, access to the same
Xfile will succeed since the file has been cached on the local filesystem.
X
XFailure to instantly deliver the requested file will result in an
Xerror ``no such file or directory'' ({\tt NFSERR\_NOENT}), so that
X{\tt csd} deliberately avoids your shell being blocked (i.e., become
Xirresponsible) almost eternally by filesystem request.  This was a
Xdesign choice because of poor semantics provided by NFS.
X
XNOTE: You can virtually forget the problem by re-compiling your
Xfavorite programs with {\tt libww}.  See Chapter \ref{useful_hacks}
Xfor more detail.
X
X\section{Other operations}
X
XWrite operation is not supported for now, since WWFS is designed for
Xwidely shared information, which is rarely modified, according to
Xstatistical studies.
X
X\chapter{Useful hacks}
X\label{useful_hacks}
X
XDue to strong demand from the user community, I devised several ways
Xto bypass limitations of NFS with minimal effort. This chapter is
Xintended for aggressive WWFS users who want to accommodate existing
Xtools to WWFS.  The basic idea is that you have WWFS-ready command
Xsets, say {\tt emacs}, {\tt ls}, {\tt tar}, {\tt cat}, and so on.
X
X\section{MULE: {\tt wwfs-access-hook.el}}
X
XThere is {\tt mule/} subdirectory in this distribution.  For more
Xinformation on WWFS-ready {\tt mule}, follow the README in that
Xdirectory which I have written for {\tt mule} addicts.
X
XSo what is MULE?  MULE stands for Multilingual enhancement to GNU
XEmacs.  For those who cares, I do not support the US-centric version
Xof Emacs (because it's mostly useless to me).  But I think it's easy
Xto add {\tt access-hook} to Emacs 19 as well.
X
X\section{Recompiling other utilities}
X
XMost of GNU software can be compiled WWFS-ready and installed without
Xmodifying Makefiles; use {\tt libww/wwconfigure} in this distribution
Xinstead of the bundled {\tt configure}.
X
XBasically, it should be fairly easy to make existing commands
XWWFS-ready, as long as you have source code of them. Just redefine
X{\tt open} to {\tt ww\_open}, {\tt opendir} to {\tt ww\_opendir},
X{\tt fopen} to {\tt ww\_fopen} by adding C flags like this:
X\begin{screen}
X\small
X\begin{verbatim}
XCFLAGS= -Dopen=ww_open -Dopendir=ww_opendir -Dfopen=ww_fopen
X\end{verbatim}
X\end{screen}
X
XNext, make them link with {\tt libww.a} by adding flags for {\tt ld}
Xlike this:
X\begin{screen}
X\small
X\begin{verbatim}
XLIBS= -L/usr/local/ww/lib -lww
X\end{verbatim}
X\end{screen}
X
X\section{Splicing the C library}
X
XYou can rename arbitrary symbols in {\tt libc.a} with {\tt
X  renamesym.pl}, my brute-force perl script, which may be useful when
Xyou have object files but not source files (e.g., binary licensed
Xsoftware).  You can generate WWFS-ready C library, {\tt libc\_wwfs.a},
Xwith this perl script; to do this, just step down to {\tt libww/}
Xsubdirectory and type {\tt make libc}.  Note that this perl script
Xassumes BSD-style nm output format (that is, it does not work on IRIX,
XHP-UX and other SysV variants for now).
X
X\begin{figure}
X\begin{center}
X\epsfile{file=switch.eps,scale=0.4}
X\end{center}
X\caption{For those who cares: yes, {\tt csd} is a 1) protocol conversion
Xengine for information access, 2) shared file cache for the Internet, and
X3) an information delivery mechanism.}
X\label{fig_switch}
X\end{figure}
X
X\section{Monitoring server status}
X
X% lsof, netstat, ps, pstat
X
XThere are several ways to monitor the server status. You can use
Xtraditional tools such as {\tt netstat}, {\tt ps} and {\tt pstat}.
XBoth {\tt ps} and {\tt pstat} are useful to see if {\tt csd} is
Xoccupying too much memory or too much CPU time.
X
X% {\tt tcpdump} or {\tt etherfind} are useful to see how actively WWFS
X% has been accessed. These tools are particularly useful if you want to
X% replace {\tt csd} with new one but you can't determine when.  If you
X% plan to use {\tt tcpdump} for monitoring purpose, you must specify
X% {\tt udp port 8000} so that NFS requests to {\tt csd} can be
X% monitored. Other options, such as {\tt -N} and {\tt -s 192}, might be
X% helpful.
X
X{\tt netstat} may be useful to see how many file transfer have been
Xtaking place. But there is much smarter tool for this purpose, called
X{\tt lsof}, developed at Purdue University. Snapshot of a sample {\tt
X  lsof} session follows:
X
X\begin{screen}
X\small
X\begin{verbatim}
Xyouki@raicho$ /usr/local/etc/lsof -u wwfs -s
XCOMMAND     PID     USER   FD  TYPE     DEVICE   INODE/NAME
Xcsd        1887     wwfs  cwd  VDIR     7,   6   53658 /usr (/dev/sd0g)
Xcsd        1887     wwfs    0  VCHR    20,   0    2864 /dev/ttyp0
Xcsd        1887     wwfs    1  VCHR    20,   0    2864 /dev/ttyp0
Xcsd        1887     wwfs    2  VCHR    20,   0    2864 /dev/ttyp0
Xcsd        1887     wwfs    4  inet 0xff66090c     UDP *:791
Xcsd        1887     wwfs    6  inet 0xff651a8c     TCP *:8002
Xcsd        1887     wwfs    7  inet 0xff65158c     UDP *:2272
Xcsd        1887     wwfs    8  inet 0xff660e0c     UDP *:8000
Xcsd        1887     wwfs   10  VREG     7,  11   20542 /space (/dev/sd1d)
Xcsd        1887     wwfs   11  VREG     7,  11   20485 /space (/dev/sd1d)
Xcsd        1887     wwfs   12  inet 0xff66450c     TCP 133.1.84.1:3681
X                                                       ->192.41.197.14:21
X\end{verbatim}
X\end{screen}
X
X% telnet debug connection
X
XThere is an experimental feature called ``debug connection'' in {\tt
X  csd}. You can talk to csd directly with {\tt telnet} using TCP port
X8002. A new protocol, UIP (WWFS User Interface Protocol) has been
Xintroduced for the administrative purpose, among others. A sample
Xsession is shown below.
X
X\begin{screen}
X\small
X\begin{verbatim}
Xyouki@nozomi$ telnet raicho 8002
XTrying 133.1.84.1...
XConnected to raicho.rd.ecip.osaka-u.ac.jp.
XEscape character is '^]'.
XDIAG file /tahoe/bin/cat/cat.1
X220-009 fil /tahoe/bin/cat/cat.1
X213-009 name = cat.1
X213-009 link = (null)
X213-009 id = 1e5a2ca7
X213-009 crc = 1e5a2ca7
X213-009 flag = 0
X213-009 type = 1
X213-009 fsid = d
X213.009 fileid = 1e5a2ca7
XQUIT
XConnection closed by foreign host.
X\end{verbatim}
X\end{screen}
X
XThe draft document for UIP protocol specification has been included
Xin this distribution. It doesn't document all available features
Xhowever, and may not reflect latest changes to the protocol.  The
Xcorresponding source code, {\tt csd/uip.c}, might be more informative.
X
XThe {\tt telnet} debug connection can never be a security hole, but if
Xthe connection peer used privileged port (i.e., {\tt sin\_port} of the
Xconnection peer is smaller than 1024), {\tt csd} logs the event for
Xlater perusal.
X
X\begin{screen}
X\small
X\begin{verbatim}
Xraicho csd[1887]: privileged connection established: 133.1.84.13
Xraicho csd[1887]: privileged connection closed: 133.1.84.13
X\end{verbatim}
X\end{screen}
X
X\section{Mounting WWFS using {\tt amd}}
X
XIt's possible to mount WWFS using {\tt amd}'s program file system.
XOne possible pitfall is that {\tt amd} will fall into deadlock if you
Xmisconfigured it.  The rule of thumb is that {\em do not put wwmount
Xand wwumount under filesystems managed by amd}.  The deadlock occurs
Xas follows:
X\begin{enumerate}
X\item {\tt amd} executes {\tt wwmount} and block until it completes.
X\item exec routine in the kernel attempts to read {\tt wwmount}
X  binary from its directory, say {\tt /usr/local}, which in turn is
X  served by {\tt amd}.
X\item {\tt amd} deadlocks.
X\end{enumerate}
X
XNow you know how to avoid {\tt amd} deadlock, so write your own map file.
XHere is our working example:
X
X\begin{screen}
X\small
X\begin{verbatim}
Xworld   type:=program;\
X        mount:="/etc/wwmount wwmount raicho ${fs}";\
X        unmount:="/etc/wwumount wwumount ${fs}";
X\end{verbatim}
X\end{screen}
X
X
X\chapter{Contribution}
X
X\section{Sending comments, bug reports and improvements}
X\label{contrib_send}
X
X% send comments
X% send bug reports
X% send ideas for improvement
XWWFS is a still-ongoing research project. I think this software suite can
Xbecome a building block for large scale networked environments in near
Xfuture.  You can contribute to our research and development by sending
Xcomments, bug reports, and ideas for improvements; I am very grateful
Xto receive your feedback.
X
XPlease feel free to send your feedbacks to me, or to the following
Xe-mail address:
X\begin{verbatim}
Xwwfs@is.aist-nara.ac.jp
X\end{verbatim}
X
XIf you want to join the WWFS bandwagon, just send an e-mail to the
Xfollowing address, so that you will be added to the WWFS mailing list:
X\begin{verbatim}
Xwwfs-request@is.aist-nara.ac.jp
X\end{verbatim}
X
XAlthough we adopt English as our primary communication language, we
Xaccept Japanese as well, since this research project and this mailing
Xlist has been wheeled by Japanese folks, including me.
X
X\section{Acknowledgements}
X\label{acknowledgements}
XI would especially like to thank Noritoshi Demizu for his useful perl
Xhacks, impressive jokes and his serious attitude toward layer
Xviolation.  Also, I would like to thank Akira Kato, Hiroyuki Ohno,
XKazumasa Utashiro, Kouichirou Eto, Motonori Nakamura, Shuji Ishii,
XToshihiko Shimokawa, Yoshitaka Tokugawa and other alpha testers for
Xtheir helpful comments, bug reports and discussions on the WWFS
Xmailing list and private talks.  I would like to thank folks at Osaka
XUniversity, Nara Institute of Science and Technology, and WIDE
XProject, especially Dr.\ Suguru Yamaguchi, Prof.\ Hideo Miyahara and
XProf.\ Jun Murai for their fundamental support --- including
Xenvironmental, financial, and spiritual support --- for my research
Xactivities.  I would also like to thank the administrators of ftp
Xarchives in the Internet.
X
X\end{document}
END_OF_FILE
  if test 43575 -ne `wc -c <'doc/manual.tex'`; then
    echo shar: \"'doc/manual.tex'\" unpacked with wrong size!
  fi
  # end of 'doc/manual.tex'
fi
if test -f 'libww/wwconfigure.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'libww/wwconfigure.sh'\"
else
  echo shar: Extracting \"'libww/wwconfigure.sh'\" \(654 characters\)
  sed "s/^X//" >'libww/wwconfigure.sh' <<'END_OF_FILE'
X#!/bin/sh
X#
X# GNU configure for WWFS clients.
X# Do you want to recompile ls, cp, cat, gzip etc. for WWFS?
X# Then this shell script is for you.  You don't have to modify
X# source code or Makefiles.
X#
X# Just type
X#	wwconfigure
X# instead of
X#	./configure
X#
X# Author: DEMIZU Noritoshi <nori-d@is.aist-nara.ac.jp>
X# Modified: Youki Kadobayashi <youki@wide.ad.jp>
X#
X
X# This doesn't work anymore...
X#DEFS="-Dopen=ww_open -Dopendir=ww_opendir -Dfopen=ww_fopen" LIBS="-lww" \
X
X# Another try, which does work on newer versions of fileutils & textutils.
XCC="gcc -Dopen=ww_open -Dopendir=ww_opendir -Dfopen=ww_fopen" LIBS="-L/usr/local/ww/lib -lww" \
X./configure $*
END_OF_FILE
  if test 654 -ne `wc -c <'libww/wwconfigure.sh'`; then
    echo shar: \"'libww/wwconfigure.sh'\" unpacked with wrong size!
  fi
  chmod +x 'libww/wwconfigure.sh'
  # end of 'libww/wwconfigure.sh'
fi
echo shar: End of archive 12 \(of 22\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 22 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
