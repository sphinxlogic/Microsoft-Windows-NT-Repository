Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i054:  vim - Vi IMitation editor, v2.0, Part04/25
Message-ID: <1993Dec21.034400.27149@sparky.sterling.com>
X-Md4-Signature: f25c4b36c5c6debf267a08a9becebd55
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:44:00 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 54
Archive-name: vim/part04
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 25)."
# Contents:  vim/doc/vim_man.uue vim/src/globals.h
#   vim/src/makefile.manx vim/src/makefile.sas vim/src/tag.c
#   vim/src/vim.h
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/vim_man.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/vim_man.uue'\"
else
echo shar: Extracting \"'vim/doc/vim_man.uue'\" \(9655 characters\)
sed "s/^X//" >'vim/doc/vim_man.uue' <<'END_OF_FILE'
X
Xbegin 644 vim.man
XM"@I624TH,2D@("`@("`@("`@("`@("`@("`@("`@("`@(%5315(@0T]-34%.<
XM1%,@("`@("`@("`@("`@("`@("`@("`@("`@("!624TH,2D*"@I."$X(3D$(&
XM00A!30A-"$U%"$4(10H@("`@('9I;2`M(%9I($E-<')O=F5D+"!A('!R;V=R_
XM86UM97)S('1E>'0@961I=&]R"@I3"%,(4UD(60A93@A."$Y/"$\(3U`(4`A0`
XM4PA3"%-)"$D(25,(4PA3"B`@("`@=@AV"'9I"&D(:6T(;0AM(%MO<'1I;VYS"
XM72!;9FEL92`N+ET*("`@("!V"'8(=FD(:0AI;0AM"&T@6V]P=&EO;G-=("UTT
XM('1A9PH@("`@('8(=@AV:0AI"&EM"&T(;2!;;W!T:6]N<UT@*UMC;VUM86YD#
XM72!F:6QE("XN"B`@("`@=@AV"'9I"&D(:6T(;0AM(%MO<'1I;VYS72`M8R![&
XM8V]M;6%N9'T@9FEL92`N+@H@("`@('8(=@AV:0AI"&EM"&T(;2!;;W!T:6]NJ
XM<UT@+64@6V5R<F]R9FEL95T*"D0(1`A$10A%"$53"%,(4T,(0PA#4@A2"%))D
XM"$D(25`(4`A05`A4"%1)"$D(24\(3PA/3@A."$X*("`@("!6"%8(5FD(:0AI7
XM;0AM"&T@:7,@82!T97AT(&5D:71O<B!T:&%T(&ES('5P=V%R9',@8V]M<&%TW
XM:6)L92!T;R!V:2X@270@8V%N(&)E('5S960@('1O"B`@("`@961I="!A;GD@N
XM05-#24D@=&5X="X@270@:7,@97-P96-I86QL>2!U<V5F=6P@9F]R(&5D:71IJ
XM;F<@<')O9W)A;7,N"@H@("`@(%1H97)E(&%R92!A(&QO="!O9B!E;FAA;F-EI
XM;65N=',@86)O=F4@=FDZ(&UU;'1I(&QE=F5L('5N9&\L(&-O;6UA;F0@(&QIF
XM;F4*("`@("!E9&ET:6YG+"`@(&9I;&5N86UE("`@8V]M<&QE=&EO;BP@(&]N1
XM("!L:6YE("!H96QP+"`@<75O=&EN9RP@(&5T8RXN("!296%D"B`@("`@9&EFA
XM9F5R96YC92YD;V,@9F]R(&$@<W5M;6%R>2!O9B!T:&4@9&EF9F5R96YC97,@F
XM8F5T=V5E;B!V:2!A;F0@5FEM+@H*("`@("!-;W-T(&]F=&5N(%8(5@A6:0AI5
XM"&EM"&T(;2!I<R!S=&%R=&5D('1O(&5D:70@82!S:6YG;&4@9FEL92!W:71HC
XM('1H92!C;VUM86YD"@H@("`@("`@("`@=FEM(&9I;&4*"B`@("`@36]R92!G.
XM96YE<F%L;'D@5DE-(&ES('-T87)T960@=VET:#H*"B`@("`@("`@("!V:6T@1
XM6V]P=&EO;G-=(%MF:6QE;&ES=%T*"B`@("`@268@=&AE(&9I;&5L:7-T(&EST
XM(&UI<W-I;F<L('1H92!E9&ET;W(@=VEL;"!S=&%R="!W:71H(&%N("!E;7!TU
XM>2`@8G5F9F5R+@H@("`@($]T:&5R=VES92!E>&%C=&QY(&]N92!O=70@;V8@.
XM=&AE(&9O;&QO=VEN9R!F;W5R(&UA>2!B92!U<V5D('1O(&-H;V]S92!O;F4*]
XM("`@("!O<B!M;W)E(&9I;&5S('1O(&)E(&5D:71E9"X*"B`@("`@9FEL92`N0
XM+B`@("`@02!L:7-T(&]F(&9I;&4@;F%M97,N(%1H92!F:7)S="!O;F4@*&%L"
XM<&AA8F5T:6-A;&QY*2!W:6QL("!B90H@("`@("`@("`@("`@("`@('1H92!CH
XM=7)R96YT(&9I;&4@86YD(')E860@:6YT;R!T:&4@8G5F9F5R+B!4:&4@8W5R=
XM<V]R('=I;&P@8F4*("`@("`@("`@("`@("`@("!P;W-I=&EO;F5D(&]N('1HT
XM92!F:7)S="!L:6YE(&]F('1H92!B=69F97(N(%EO=2`@8V%N("!G970@('1O%
XM"B`@("`@("`@("`@("`@("`@=&AE(&]T:&5R(&9I;&5S('=I=&@@=&AE("(Z9
XM;F5X="(@8V]M;6%N9"X*"B`@("`@*UMN=6U=(&9I;&4@+BX*("`@("`@("`@;
XM("`@("`@("!386UE(&%S('1H92!A8F]V92P@8G5T('1H92!C=7)S;W(@=VELJ
XM;"!B92!P;W-I=&EO;F5D(&]N("!L:6YE"B`@("`@("`@("`@("`@("`@(FYU%
XM;2(N("!)9B`B;G5M(B!I<R!M:7-S:6YG+"!T:&4@8W5R<V]R('=I;&P@8F4@@
XM<&]S:71I;VYE9"!O;@H@("`@("`@("`@("`@("`@('1H92!L87-T(&QI;F4NP
XM"@H@("`@("LO<&%T(&9I;&4@+BX*("`@("`@("`@("`@("`@("!386UE(&%SS
XM('1H92!A8F]V92P@8G5T('1H92!C=7)S;W(@=VEL;"!B92!P;W-I=&EO;F5DA
XM("!O;B`@=&AE"B`@("`@("`@("`@("`@("`@9FER<W0@("!O8V-U<G)E;F-EY
XM("`@;V8@("`B<&%T(B`@:6X@('1H92`@8W5R<F5N="`@9FEL92`@*'-E90H@H
XM("`@("`@("`@("`@("`@(')E9F5R96YC92YD;V,L('-E8W1I;VX@(G!A='1ET
XM<FX@<V5A<F-H97,B(&9O<B`@=&AE("!A=F%I;&%B;&4*("`@("`@("`@("`@#
XM("`@("!S96%R8V@@<&%T=&5R;G,I+@H*("`@("`K>V-O;6UA;F1](&9I;&4@4
XM+BX*"B`@("`@+6,@>V-O;6UA;F1](&9I;&4@+BX*("`@("`@("`@("`@("`@]
XM("!386UE(&%S('1H92!A8F]V92P@8G5T('MC;VUM86YD?2!W:6QL(&)E(&5X2
XM96-U=&5D("!A9G1E<B`@=&AE"B`@("`@("`@("`@("`@("`@9FEL92`@:&%S3
XM("!B965N("!R96%D+B`@>V-O;6UA;F1]("!I<R`@:6YT97)P<F5T960@(&%S1
XM("!A;B!%>`H@("`@("`@("`@("`@("`@(&-O;6UA;F0N($EF('1H92![8V]MM
XM;6%N9'T@8V]N=&%I;G,@<W!A8V5S(&ET(&UU<W0@8F4@96YC;&]S960*("`@?
XM("`@("`@("`@("`@("!I;B`@9&]U8FQE("!Q=6]T97,@("AT:&ES(&1E<&5N_
XM9',@;VX@=&AE('-H96QL('1H870@:7,@=7-E9"DN"B`@("`@("`@("`@("`@L
XM("`@17AA;7!L93H@5FEM("(K<V5T('-I(B!M86EN+F,*"@H*"B`@("`@("`@1
XM("`@("`@("`@("`@("`@("`@("`@("`@,C@@36%R8V@@,3DY,B`@("`@("`@J
XM("`@("`@("`@("`@("`@("`@("`@("`@,0H*#`H*5DE-*#$I("`@("`@("`@S
XM("`@("`@("`@("`@("`@("!54T52($-/34U!3D13("`@("`@("`@("`@("`@Q
XM("`@("`@("`@("`@5DE-*#$I"@H*("`@("`M="![=&%G?2`@("!4:&4@9FEL=
XM92!T;R!E9&ET(&%N9"!T:&4@:6YI=&EA;"!C=7)S;W(@<&]S:71I;VX@9&5P8
XM96YD<R!O;B!A"B`@("`@("`@("`@("`@("`@(G1A9R(L("!A("!S;W)T(&]F<
XM(&=O=&\@;&%B96PN('MT86=](&ES(&QO;VME9"!U<"!I;B!T:&4@=&%G<PH@K
XM("`@("`@("`@("`@("`@(&9I;&4L('1H92!A<W-O8VEA=&5D(&9I;&4@8F5CW
XM;VUE<R!T:&4@8W5R<F5N="`@9FEL92`@86YD("!T:&4*("`@("`@("`@("`@6
XM("`@("!A<W-O8VEA=&5D("!C;VUM86YD("!I<R`@97AE8W5T960N("!-;W-TC
XM;'D@=&AI<R!I<R!U<V5D(&9O<B!#"B`@("`@("`@("`@("`@("`@<')O9W)A)
XM;7,N('MT86=]('1H96X@<VAO=6QD(&)E(&$@9G5N8W1I;VX@;F%M92X@5&AE^
XM(&5F9F5C="!I<PH@("`@("`@("`@("`@("`@('1H870@('1H92`@9FEL92`@%
XM8V]N=&%I;FEN9R!T:&%T(&9U;F-T:6]N(&)E8V]M97,@=&AE(&-U<G)E;G0*-
XM("`@("`@("`@("`@("`@("!F:6QE(&%N9"!T:&4@(&-U<G-O<B`@:7,@('!O-
XM<VET:6]N960@(&]N("!T:&4@('-T87)T("!O9B`@=&AE"B`@("`@("`@("`@K
XM("`@("`@9G5N8W1I;VX@*'-E92!R969E<F5N8V4N9&]C+"!S96-T:6]N(")T5
XM86<@<V5A<F-H97,B*2X*"B`@("`@+64@6V5R<F]R9FEL95T*("`@("`@("`@!
XM("`@("`@("!3=&%R="!I;B!Q=6EC:T9I>"!M;V1E+B!4:&4@9FEL92!;97)RA
XM;W)F:6QE72!I<R!R96%D(&%N9"`@=&AE"B`@("`@("`@("`@("`@("`@9FER5
XM<W0@(&5R<F]R(&ES(&1I<W!L87EE9"X@268@6V5R<F]R9FEL95T@:7,@;VUIL
XM='1E9"!T:&4@9FEL90H@("`@("`@("`@("`@("`@(&YA;64@:7,@;V)T86ENV
XM960@9G)O;2!T:&4@("=E<G)O<F9I;&4G("!O<'1I;VX@("AD969A=6QT<R`@O
XM=&\*("`@("`@("`@("`@("`@("`B07IT96-#+D5R<B(@(&9O<B`@=&AE("!!K
XM;6EG82P@(")E<G)O<G,B("!O;B`@;W1H97(@<WES=&5M<RDN"B`@("`@("`@#
XM("`@("`@("`@1G5R=&AE<B!E<G)O<G,@8V%N(&)E(&IU;7!E9"!T;R!W:71HZ
XM('1H92`B.F-N(B`@8V]M;6%N9"X@(%-E90H@("`@("`@("`@("`@("`@(')E[
XM9F5R96YC92YD;V,@<V5C=&EO;B`U+C4N"@I/"$\(3U`(4`A05`A4"%1)"$D(V
XM24\(3PA/3@A."$Y3"%,(4PH@("`@(%1H92!O<'1I;VYS+"!I9B!P<F5S96YT\
XM+"!M=7-T('!R96-E9&4@=&AE(&9I;&5L:7-T+B!4:&4@(&]P=&EO;G,@(&UAS
XM>2`@8F4*("`@("!G:79E;B!I;B!A;GD@;W)D97(N"@H@("`@("UR("`@("`@?
XM("`@(%)E8V]V97)Y(&UO9&4N(%1H92!A=71O<V-R:7!T("!F:6QE("!I<R`@M
XM<F5A9"`@=&\@(')E8V]V97(@(&$*("`@("`@("`@("`@("`@("!C<F%S:&5D:
XM(&5D:71I;F<@<V5S<VEO;BX@270@:&%S(&%L;6]S="!T:&4@<V%M92!E9F9E<
XM8W0@87,@(BUS"B`@("`@("`@("`@("`@("`@9FEL92YV:6TB+B`@4V5E("!R0
XM969E<F5N8V4N9&]C+"`@8VAA<'1E<B`@(E)E8V]V97)Y("!A9G1E<B`@80H@"
XM("`@("`@("`@("`@("`@(&-R87-H(BX*"B`@("`@+78@("`@("`@("`@5FEE<
XM=R!M;V1E+B!4:&4@)W)E861O;FQY)R!O<'1I;VX@=VEL;"!B92!S970N(%EOQ
XM=2`@8V%N("!S=&EL;`H@("`@("`@("`@("`@("`@(&5D:70@('1H92`@8G5F=
XM9F5R+"`@8G5T("!W:6QL("!B92`@<')E=F5N=&5D("!F<F]M(&%C8VED96YT/
XM86P*("`@("`@("`@("`@("`@("!O=F5R=W)I=&EN9R!A(&9I;&4N($EF('EO]
XM=2!D;R!W86YT('1O(&]V97)W<FET92!A("!F:6QE+"`@861D"B`@("`@("`@,
XM("`@("`@("`@86X@(&5X8VQA;6%T:6]N("!M87)K("!T;R`@=&AE("!%>"`@0
XM8V]M;6%N9"P@87,@:6X@(CIW(2(N(%1H90H@("`@("`@("`@("`@("`@("=R>
XM96%D;VYL>2<@(&]P=&EO;B`@8V%N("!B92`@<F5S970@('=I=&@@("(Z<V5TL
XM("!N;W)O(B`@("AS964*("`@("`@("`@("`@("`@("!R969E<F5N8V4N9&]CB
XM+"!O<'1I;VYS(&-H87!T97(I+@H*("`@("`M8B`@("`@("`@("!":6YA<GDN,
XM($$@9F5W(&]P=&EO;G,@=VEL;"!B92!S970@=&AA="!M86ME<R!I="`@<&]SK
XM<VEB;&4@('1O"B`@("`@("`@("`@("`@("`@961I="!A(&)I;F%R>2!O<B!EN
XM>&5C=71A8FQE(&9I;&4N"@H@("`@("UX("`@("`@("`@("A!;6EG82!O;FQYM
XM*2!6:6T@:7,@;F]T(')E<W1A<G1E9"!T;R!O<&5N(&$@;F5W('=I;F1O=RX@6
XM(%1H:7,*("`@("`@("`@("`@("`@("!O<'1I;VX@('-H;W5L9"!B92!U<V5D"
XM('=H96X@5FEM(&ES(&5X96-U=&5D(&)Y(&$@<')O9W)A;2!T:&%T"B`@("`@@
XM("`@("`@("`@("`@=VEL;"!W86ET(&9O<B!T:&4@961I="!S97-S:6]N('1O"
XM("!F:6YI<V@@("AE+F<N("!M86EL*2X@(%1H90H@("`@("`@("`@("`@("`@V
XM("(Z<V@B(&%N9"`B.B$B(&-O;6UA;F1S('=I;&P@;F]T('=O<FLN"@H@("`@K
XM("UN("`@("`@("`@($YO(&%U=&]S8W)I<'0@9FEL92!W:6QL(&)E('=R:71T_
XM96XN(%)E8V]V97)Y("!A9G1E<B`@82`@8W)A<V@*("`@("`@("`@("`@("`@>
XM("!W:6QL("!B92`@:6UP;W-S:6)L92X@($AA;F1Y("!I9B!Y;W4@=V%N="!T2
XM;R!E9&ET(&$@9FEL92!O;B!A"B`@("`@("`@("`@("`@("`@=F5R>2!S;&]W)
XM(&UE9&EU;2`H92YG+B!F;&]P<'DI+B!#86X@86QS;R!B92!D;VYE("!W:71H,
XM("`B.G-E=`H@("`@("`@("`@("`@("`@('5C/3`B+@H*("`@("`M<R![<V-R>
XM:7!T:6Y]"B`@("`@("`@("`@("`@("`@5&AE('-C<FEP="!F:6QE('MS8W)IM
XM<'1I;GT@:7,@<F5A9"X@(%1H92`@8VAA<F%C=&5R<R`@:6X@('1H90H@("`@!
XM("`@("`@("`@("`@(&9I;&4@(&%R92`@:6YT97)P<F5T960@87,@:68@>6]U^
XM(&AA9"!T>7!E9"!T:&5M+B!4:&4@<V%M92!C86X*("`@("`@("`@("`@("`@2
XM("!B92!D;VYE('=I=&@@=&AE(&-O;6UA;F0@(CIS;W5R8V4A('MS8W)I<'1I0
XM;GTB+B!)9B!T:&4@96YD(&]F"B`@("`@("`@("`@("`@("`@=&AE("`@9FEL]
XM92`@:7,@(')E86-H960@(&)E9F]R92`@=&AE("!E9&ET;W(@(&5X:71S+"`@A
XM9G5R=&AE<@H@("`@("`@("`@("`@("`@(&-H87)A8W1E<G,@87)E(')E860@^
XM9G)O;2!T:&4@:V5Y8F]A<F0N"@H@("`@("UW('MS8W)I<'1O=71]"B`@("`@[
XM("`@("`@("`@("`@06QL('1H92!C:&%R86-T97)S('1H870@>6]U('1Y<&4@*
XM87)E("!R96-O<F1E9"`@:6X@('1H92`@9FEL90H@("`@("`@("`@("`@("`@"
XM('MS8W)I<'1O=71]+"`@=6YT:6P@('EO=2!E>&ET(%9)32X@5&AI<R!I<R!U7
XM<V5F=6P@:68@>6]U('=A;G0*"@H@("`@("`@("`@("`@("`@("`@("`@("`@C
XM("`@("`@(#(X($UA<F-H(#$Y.3(@("`@("`@("`@("`@("`@("`@("`@("`@J
XM("`@("`@(#(*"@P*"E9)32@Q*2`@("`@("`@("`@("`@("`@("`@("`@("`@T
XM55-%4B!#3TU-04Y$4R`@("`@("`@("`@("`@("`@("`@("`@("`@(%9)32@Q6
XM*0H*"B`@("`@("`@("`@("`@("`@=&\@8W)E871E("!A("!S8W)I<'0@(&9IC
XM;&4@('1O("!B92`@=7-E9"`@=VET:"`@(G9I;2`@+7,B("!O<@H@("`@("`@C
XM("`@("`@("`@("(Z<V]U<F-E(2(N"@H@("`@("U4('1E<FUI;F%L(%1E;&QSS
XM(%9I;2!T:&4@;F%M92!O9B!T:&4@=&5R;6EN86P@>6]U(&%R92!U<VEN9RX@I
XM4VAO=6QD(&)E(&$*("`@("`@("`@("`@("`@("!T97)M:6YA;"`@:VYO=VX@J
XM('1O("!6:6T@("AB=6EL=&EN*2!O<B!D969I;F5D(&EN('1H92!T97)M8V%P+
XM"B`@("`@("`@("`@("`@("`@9FEL92X*"B`@("`@+60@9&5V:6-E("`@3W!E1
XM;B`B9&5V:6-E(B!F;W(@=7-E(&%S("!A("!T97)M:6YA;"X@($]N;'D@(&]NT
XM("!T:&4@($%M:6=A+@H@("`@("`@("`@("`@("`@($5X86UP;&4Z("`B+60@1
XM8V]N.C(P+S,P+S8P,"\Q-3`B+@H*4PA3"%-%"$4(144(10A%($$(00A!3`A,V
XM"$Q3"%,(4T\(3PA/"B`@("`@5FEM("!D;V-U;65N=&%T:6]N.B`@4F5F97)E]
XM;F-E+F1O8RP@(&EN9&5X+"`@(&1I9F9E<F5N8V4N9&]C+"`@('5N:7@N9&]C-
XM+`H@("`@('9I;2YH;'`N"@I!"$$(054(50A55`A4"%1("$@(2$\(3PA/4@A25
XM"%(*("`@("!-;W-T(&]F(%9)32!W87,@;6%D92!B>2!"<F%M($UO;VQE;F%AS
XM<BX*("`@("!624T@:7,@8F%S960@;VX@4W1E=FEE+"!W;W)K960@;VX@8GDZH
XM(%1I;2!4:&]M<'-O;BP@5&]N>2!!;F1R97=S(&%N9"!'+E(N"B`@("`@*$9R>
XM960I(%=A;'1E<@H*0@A""$)5"%4(54<(1PA'4PA3"%,*("`@("!0<F]B86)L4
XM>2X*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"@H*"B`@("`@#
XM("`@("`@("`@("`@("`@("`@("`@("`@("`@,C@@36%R8V@@,3DY,B`@("`@J
X>("`@("`@("`@("`@("`@("`@("`@("`@("`@,PH*G
X``
Xend
Xsize 6870
END_OF_FILE
if test 9655 -ne `wc -c <'vim/doc/vim_man.uue'`; then
    echo shar: \"'vim/doc/vim_man.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/vim_man.uue'
# end of 'vim/doc/vim_man.uue'
fi
if test -f 'vim/src/globals.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/globals.h'\"
else
echo shar: Extracting \"'vim/src/globals.h'\" \(9305 characters\)
sed "s/^X//" >'vim/src/globals.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * definition of global variables
X *
X * EXTERN is only defined in main.c (and in param.h)
X */
X
X#ifndef EXTERN
X# define EXTERN extern
X# define INIT(x)
X#else
X# ifndef INIT
X#  define INIT(x) x
X# endif
X#endif
X
X/*
X * Number of Rows and Columns in the current window.
X * Must be long to be able to use them as options in param.c.
X */
XEXTERN long		Rows;			/* currently used nr. of rows */
XEXTERN long		Columns;
XEXTERN long		Rows_max;		/* maximal physical nr. of rows */
X
XEXTERN char 	*Filename INIT(= NULL);		/* Current file name */
XEXTERN char 	*sFilename INIT(= NULL);	/* Filename without path */
XEXTERN char 	*xFilename INIT(= NULL);	/* Filename maybe without path */
X
XEXTERN linenr_t Topline;		/* number of the line at the top of the screen */
XEXTERN linenr_t Botline;		/* number of the line below the bottom of the
X								 * screen */
XEXTERN int		redraw_msg INIT(= TRUE);
X								/* TRUE when "insert mode" needs updating */
XEXTERN int		emptyrows INIT(= 0);	/* number of '~' rows on screen */
XEXTERN linenr_t line_count; 	/* current number of lines in the file */
X
XEXTERN FPOS 	Curpos; 		/* current position of the cursor */
X
XEXTERN int		Curscol;		/* Current position of cursor (column) */
XEXTERN int		Cursrow;		/* Current position of cursor (row) */
X
XEXTERN int		Cursvcol;		/* Current virtual column, the column number
X								 * of the file's actual line, as opposed to
X								 * the column number we're at on the screen.
X								 * This makes a difference on lines that span
X								 * more than one screen line. */
X
XEXTERN colnr_t	Curswant INIT(= 0); 	/* The column we'd like to be at. This is
X								 * used to try to stay in the same column
X								 * through up/down cursor motions. */
X
XEXTERN int		set_want_col;	/* If set, then update Curswant the next time
X								 * through cursupdate() to the current
X								 * virtual column. */
X
XEXTERN int		cmdoffset INIT(= 0); 	/* offset for command line position */
XEXTERN int		ru_col;			/* column for ruler */
XEXTERN int		sc_col;			/* column for shown command */
X
XEXTERN int		char_count;		/* number of characters sent to screen */
X
XEXTERN int		starting INIT(= TRUE);
X								/* set to FALSE when starting up finished */
XEXTERN int		exiting INIT(= FALSE);
X								/* set to TRUE when abandoning Vim */
X
XEXTERN int		secure INIT(= FALSE);
X								/* set to TRUE when only "safe" commands are 
X								 * allowed, e.g. when sourcing .exrc or .vimrc
X								 * in current directory */
X
XEXTERN FPOS 	Visual; 		/* start position of Visual
X								 * (Visual.lnum == 0 when not active) */
XEXTERN int		Visual_block INIT(= FALSE);
X								/* Visual is blockwise */
X
XEXTERN FPOS 	Insstart;		/* This is where the latest insert/append
X								 * mode started. */
X
X/*
X * This flag is used to make auto-indent work right on lines where only a
X * <RETURN> or <ESC> is typed. It is set when an auto-indent is done, and
X * reset when any other editting is done on the line. If an <ESC> or <RETURN>
X * is received, and did_ai is TRUE, the line is truncated.
X */
XEXTERN int			   did_ai INIT(= FALSE);
X
X/*
X * This flag is set when a smart indent has been performed. When the next typed
X * character is a '{' the inserted tab will be deleted again.
X */
XEXTERN int				did_si INIT(= FALSE);
X
X/*
X * This flag is set after an auto indent. If the next typed character is a '}'
X * one indent character will be removed.
X */
XEXTERN int				can_si INIT(= FALSE);
X
XEXTERN int				old_indent INIT(= 0); /* for ^^D command in insert mode */
X
X/*
X * This flag is set after doing a reverse replace in column 0.
X * An extra space has been inserted in column 0.
X */
XEXTERN int				extraspace INIT(= FALSE);
X
XEXTERN int		State INIT(= NORMAL);	/* This is the current state of the command
X										 * interpreter. */
X
XEXTERN int		Recording INIT(= FALSE);/* TRUE when recording into a register */
XEXTERN int		Exec_reg INIT(= FALSE);	/* TRUE when executing a register */
X
XEXTERN int		Changed INIT(= FALSE);	/* Set to TRUE if something in the file has
X								 		 * been changed and not written out. */
X
XEXTERN int		NotEdited INIT(= FALSE);/* Set to TRUE with ":file xxx" command,
X								 		 * reset when file is written out. */
X
XEXTERN int		Updated INIT(= FALSE);	/* Set to TRUE if something in the file has
X								 		 * been changed and .vim not flushed yet */
X
XEXTERN int		did_cd INIT(= FALSE);	/* TRUE when :cd dir used */
XEXTERN int		no_abbr INIT(= TRUE);	/* TRUE when no abbreviations loaded */
X
X
XEXTERN char 	*IObuff;				/* sprintf's are done into this buffer */
X
XEXTERN int		RedrawingDisabled INIT(= FALSE);
X										/* Set to TRUE if doing :g */
X#ifndef MSDOS
XEXTERN int		thisfile_sn INIT(= FALSE);	/* this file uses shortname */
X#endif
X
XEXTERN int		readonlymode INIT(= FALSE); /* Set to TRUE for "view" */
XEXTERN int		recoverymode INIT(= FALSE); /* Set to TRUE for "-r" option */
X
XEXTERN int		KeyTyped;				/* TRUE if user typed the character */
XEXTERN int		must_redraw INIT(= 0);	/* type of redraw necessary */
X
XEXTERN char 	**files INIT(= NULL);	/* list of input files */
XEXTERN int		numfiles INIT(= 0); 	/* number of input files */
XEXTERN int		curfile INIT(= 0);		/* number of the current file */
XEXTERN int		files_exp INIT(= FALSE);	/* *files must be freed */
X#define NSCRIPT 15
XEXTERN FILE 	*scriptin[NSCRIPT];		/* streams to read script from */
XEXTERN int		curscript INIT(= 0);	/* index in scriptin[] */
XEXTERN FILE 	*scriptout	INIT(= NULL); /* stream to write script to */
X
XEXTERN int		got_int INIT(= FALSE);	/* set to TRUE when interrupt
X										   signal occurred */
XEXTERN int		term_console INIT(= FALSE);	/* set to TRUE when Amiga window used */
XEXTERN int		termcap_active INIT(= FALSE);	/* set to TRUE by starttermcap() */
XEXTERN int		bangredo INIT(= FALSE);	/* set to TRUE whith ! command */
XEXTERN int		searchcmdlen;			/* length of previous search command */
XEXTERN int		did_outofmem_msg INIT(= FALSE);	/* set after out of memory msg */
X
X#ifdef DEBUG
XEXTERN FILE *debugfp INIT(=NULL);
X#endif
X
Xextern char *Version;			/* this is in version.c */
Xextern char *longVersion;		/* this is in version.c */
X
X/*
X * The error messages that can be shared are included here.
X * Excluded are very specific errors and debugging messages.
X */
XEXTERN char e_abbr[]		INIT(="No such abbreviation");
XEXTERN char e_abort[]		INIT(="Command aborted");
XEXTERN char e_ambmap[]		INIT(="Ambiguous mapping");
XEXTERN char e_argreq[]		INIT(="Argument required");
XEXTERN char e_curdir[]		INIT(="Command not allowed from from .exrc/.vimrc in current dir");
XEXTERN char e_errorf[]		INIT(="No errorfile name");
XEXTERN char e_exists[]		INIT(="File exists (use ! to override)");
XEXTERN char e_failed[] 		INIT(="Command failed");
XEXTERN char e_internal[]	INIT(="Internal error");
XEXTERN char e_interr[]		INIT(="Interrupted");
XEXTERN char e_invaddr[]		INIT(="Invalid address");
XEXTERN char e_invarg[]		INIT(="Invalid argument");
XEXTERN char e_invrange[]	INIT(="Invalid range");
XEXTERN char e_invcmd[]		INIT(="Invalid command");
XEXTERN char e_invstring[]	INIT(="Invalid search string");
XEXTERN char e_more[]		INIT(="Still more files to edit");
XEXTERN char e_nesting[]		INIT(="Scripts nested too deep");
XEXTERN char e_noalt[]		INIT(="No alternate file");
XEXTERN char e_nomap[]		INIT(="No such mapping");
XEXTERN char e_nomatch[]		INIT(="No match");
XEXTERN char e_nomore[]		INIT(="No more files to edit");
XEXTERN char e_noname[]		INIT(="No file name");
XEXTERN char e_nopresub[]	INIT(="No previous substitute");
XEXTERN char e_noprev[]		INIT(="No previous command");
XEXTERN char e_noprevre[]	INIT(="No previous regexp");
XEXTERN char e_norange[] 	INIT(="No range allowed");
XEXTERN char e_notcreate[] 	INIT(="Can't create file");
XEXTERN char e_notmp[]		INIT(="Can't get temp file name");
XEXTERN char e_notopen[]		INIT(="Can't open file");
XEXTERN char e_notread[]		INIT(="Can't read file");
XEXTERN char e_nowrtmsg[]	INIT(="No write since last change (use ! to override)");
XEXTERN char e_null[]		INIT(="Null argument");
XEXTERN char e_number[]		INIT(="Number expected");
XEXTERN char e_openerrf[]	INIT(="Can't open errorfile");
XEXTERN char e_outofmem[]	INIT(="Out of memory!");
XEXTERN char e_patnotf[]		INIT(="Pattern not found");
XEXTERN char e_positive[]	INIT(="Argument must be positive");
XEXTERN char e_quickfix[]	INIT(="No errorfile; use :cf");
XEXTERN char e_re_damg[]		INIT(="Damaged match string");
XEXTERN char e_re_corr[]		INIT(="Corrupted regexp program");
XEXTERN char e_readonly[]	INIT(="File is readonly");
XEXTERN char e_readerrf[]	INIT(="Error while reading errorfile");
XEXTERN char e_scroll[]		INIT(="Invalid scroll size");
XEXTERN char e_toocompl[]	INIT(="Command too complex");
XEXTERN char e_toombra[]		INIT(="Too many (");
XEXTERN char e_toomket[]		INIT(="Too many )");
XEXTERN char e_toomsbra[]	INIT(="Too many [");
XEXTERN char e_toolong[]		INIT(="Command too long");
XEXTERN char e_toomany[]		INIT(="Too many file names");
XEXTERN char e_trailing[]	INIT(="Trailing characters");
XEXTERN char e_umark[]		INIT(="Unknown mark");
XEXTERN char e_unknown[]		INIT(="Unknown");
XEXTERN char e_write[]		INIT(="Error while writing");
XEXTERN char e_zerocount[] 	INIT(="Zero count");
END_OF_FILE
if test 9305 -ne `wc -c <'vim/src/globals.h'`; then
    echo shar: \"'vim/src/globals.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/globals.h'
# end of 'vim/src/globals.h'
fi
if test -f 'vim/src/makefile.manx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.manx'\"
else
echo shar: Extracting \"'vim/src/makefile.manx'\" \(8112 characters\)
sed "s/^X//" >'vim/src/makefile.manx' <<'END_OF_FILE'
X#
X# Makefile for VIM on the Amiga, using Aztec/Manx C 5.0 or later
X#
X# Note: not all dependencies are included. This was done to avoid having
X#       to compile everything when a global variable or function is added
X#	
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DNO_ARP		do not use arp.library, DOS 2.0 required
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -Dconst		for compilers that don't have type const
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
XDEFINES = -DDIGRAPHS -DSOME_BUILTIN_TCAPS -DVIM_ISSPACE
X
X#>>>>> if TERMCAP is defined termlib.o has to be used
X#TERMLIB = termlib.o
XTERMLIB = 
X
X#>>>>> choose between debugging (-bs) or optimizing (-so)
XOPTIONS = -so
X#OPTIONS = -bs
X
X#>>>>> end of choices
X###########################################################################
X
XCFLAGS = $(OPTIONS) -wapruq -ps -qf $(DEFINES) -DAMIGA
X
XLIBS = -lc16
XSYMS = vim.syms
X
XOBJ =	alloc.o amiga.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o term.o undo.o $(TERMLIB)
X
XPRO =	proto/alloc.pro proto/buffers.pro proto/charset.pro proto/cmdline.pro \
X	proto/csearch.pro proto/digraph.pro proto/edit.pro proto/fileio.pro \
X	proto/help.pro proto/linefunc.pro proto/main.pro proto/mark.pro \
X	proto/message.pro proto/misccmds.pro proto/normal.pro proto/ops.pro \
X	proto/param.pro proto/quickfix.pro proto/regexp.pro proto/regsub.pro \
X	proto/screen.pro proto/script.pro proto/search.pro proto/storage.pro \
X	proto/tag.pro proto/term.pro proto/termlib.pro \
X	proto/undo.pro proto/amiga.pro
X
X/Vim: $(OBJ) version.c
X	cc $(CFLAGS) version.c
X	ln +q -m -o /Vim $(OBJ) version.o $(LIBS)
X
Xdebug: $(OBJ) version.c
X	cc $(CFLAGS) version.c
X	ln +q -m -g -o /Vim $(OBJ) version.o $(LIBS)
X
Xproto: $(SYMS) $(PRO)
X
Xctags:
X	csh -c ctags *.c *.h
X
X# can't use delete here, too many file names
Xclean:
X	csh -c rm -f $(OBJ) version.o mkcmdtab.o /Vim $(SYMS) mkcmdtab
X
X$(SYMS)  : vim.h keymap.h macros.h ascii.h term.h
X	cc $(CFLAGS) -ho$(SYMS) vim.h
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) alloc.c
X
Xproto/alloc.pro:	alloc.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) alloc.c
X	csh -c mv -f alloc.pro proto
X
Xamiga.o:	amiga.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) amiga.c
X
Xproto/amiga.pro:	amiga.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) amiga.c
X	csh -c mv -f amiga.pro proto
X
Xbuffers.o:	buffers.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) buffers.c
X
Xproto/buffers.pro:	buffers.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) buffers.c
X	csh -c mv -f buffers.pro proto
X
Xcharset.o:	charset.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) charset.c
X
Xproto/charset.pro:	charset.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) charset.c
X	csh -c mv -f charset.pro proto
X
Xcmdline.o:	cmdline.c  $(SYMS) cmdtab.h
X	cc $(CFLAGS) -hi$(SYMS) cmdline.c
X
Xproto/cmdline.pro:	cmdline.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) cmdline.c
X	csh -c mv -f cmdline.pro proto
X
Xcsearch.o:	csearch.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) csearch.c
X
Xproto/csearch.pro:	csearch.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) csearch.c
X	csh -c mv -f csearch.pro proto
X
Xdigraph.o:	digraph.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) digraph.c
X
Xproto/digraph.pro:	digraph.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) digraph.c
X	csh -c mv -f digraph.pro proto
X
Xedit.o:	edit.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) edit.c
X
Xproto/edit.pro:	edit.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) edit.c
X	csh -c mv -f edit.pro proto
X
Xfileio.o:	fileio.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) fileio.c
X
Xproto/fileio.pro:	fileio.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) fileio.c
X	csh -c mv -f fileio.pro proto
X
Xhelp.o:	help.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) help.c
X
Xproto/help.pro:	help.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) help.c
X	csh -c mv -f help.pro proto
X
Xlinefunc.o:	linefunc.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) linefunc.c
X
Xproto/linefunc.pro:	linefunc.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) linefunc.c
X	csh -c mv -f linefunc.pro proto
X
Xmain.o:	main.c $(SYMS) param.h globals.h
X	cc $(CFLAGS) -hi$(SYMS) main.c
X
Xproto/main.pro:	main.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) main.c
X	csh -c mv -f main.pro proto
X
Xmark.o:	mark.c  $(SYMS) mark.h
X	cc $(CFLAGS) -hi$(SYMS) mark.c
X
Xproto/mark.pro:	mark.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) mark.c
X	csh -c mv -f mark.pro proto
X
Xmessage.o:	message.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) message.c
X
Xproto/message.pro:	message.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) message.c
X	csh -c mv -f message.pro proto
X
Xmisccmds.o:	misccmds.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) misccmds.c
X
Xproto/misccmds.pro:	misccmds.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) misccmds.c
X	csh -c mv -f misccmds.pro proto
X
Xnormal.o:	normal.c  $(SYMS) ops.h
X	cc $(CFLAGS) -hi$(SYMS) normal.c
X
Xproto/normal.pro:	normal.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) normal.c
X	csh -c mv -f normal.pro proto
X
Xops.o:	ops.c  $(SYMS) ops.h
X	cc $(CFLAGS) -hi$(SYMS) ops.c
X
Xproto/ops.pro:	ops.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) ops.c
X	csh -c mv -f ops.pro proto
X
Xparam.o:	param.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) param.c
X
Xproto/param.pro:	param.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) param.c
X	csh -c mv -f param.pro proto
X
Xquickfix.o:	quickfix.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) quickfix.c
X
Xproto/quickfix.pro:	quickfix.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) quickfix.c
X	csh -c mv -f quickfix.pro proto
X
Xregexp.o:	regexp.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) regexp.c
X
Xproto/regexp.pro:	regexp.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) regexp.c
X	csh -c mv -f regexp.pro proto
X
Xregsub.o:	regsub.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) regsub.c
X
Xproto/regsub.pro:	regsub.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) regsub.c
X	csh -c mv -f regsub.pro proto
X
Xscreen.o:	screen.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) screen.c
X
Xproto/screen.pro:	screen.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) screen.c
X	csh -c mv -f screen.pro proto
X
Xscript.o:	script.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) script.c
X
Xproto/script.pro:	script.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) script.c
X	csh -c mv -f script.pro proto
X
Xsearch.o:	search.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) search.c
X
Xproto/search.pro:	search.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) search.c
X	csh -c mv -f search.pro proto
X
Xstorage.o:	storage.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) storage.c
X
Xproto/storage.pro:	storage.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) storage.c
X	csh -c mv -f storage.pro proto
X
Xtag.o:	tag.c  $(SYMS) mark.h
X	cc $(CFLAGS) -hi$(SYMS) tag.c
X
Xproto/tag.pro:	tag.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) tag.c
X	csh -c mv -f tag.pro proto
X
Xterm.o:	term.c  $(SYMS) term.h
X	cc $(CFLAGS) -hi$(SYMS) term.c
X
Xproto/term.pro:	term.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) term.c
X	csh -c mv -f term.pro proto
X
Xtermlib.o:	termlib.c  $(SYMS)
X	cc $(CFLAGS) termlib.c
X
Xproto/termlib.pro:	termlib.c
X	cc -qa -qp $(CFLAGS) -DPROTO termlib.c
X#the manx compiler generates a wrong prototype for tputs
X	vim -s termlib.fix termlib.pro
X	csh -c mv -f termlib.pro proto
X
Xundo.o:	undo.c  $(SYMS)
X	cc $(CFLAGS) -hi$(SYMS) undo.c
X
Xproto/undo.pro:	undo.c
X	cc -qa -qp $(CFLAGS) -DPROTO -hi$(SYMS) undo.c
X	csh -c mv -f undo.pro proto
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab: mkcmdtab.o
X	ln +q -o mkcmdtab mkcmdtab.o -lc16
END_OF_FILE
if test 8112 -ne `wc -c <'vim/src/makefile.manx'`; then
    echo shar: \"'vim/src/makefile.manx'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.manx'
# end of 'vim/src/makefile.manx'
fi
if test -f 'vim/src/makefile.sas' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.sas'\"
else
echo shar: Extracting \"'vim/src/makefile.sas'\" \(7825 characters\)
sed "s/^X//" >'vim/src/makefile.sas' <<'END_OF_FILE'
X#
X# Makefile for VIM on the Amiga, using SAS/Lattice C 6.0 to 6.3
X#
X# Do NOT use the peephole optimizer! It messes up all kinds of things.
X# For 6.0 and 6.1, expand_env() will not work correctly.
X# For 6.2 and 6.3 the call to free_line in u_freeentry is wrong.
X# You should use Manx Aztec C whenever possible.
X#
X# The prototypes from Manx and SAS are incompatible. If the prototypes
X# were generated by Manx, first do "touch *.c; make proto" before "make".
X#
X# Note: not all dependencies are included. This was done to avoid having
X#       to compile everything when a global variable or function is added
X#	
X
X#>>>>> choose options:
X### DEF=DIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### DEF=NO_ARP			do not use arp.library, DOS 2.0 required
X### DEF=COMPATIBLE		start in vi-compatible mode
X### DEF=NOBACKUP		default is no backup file
X### DEF=DEBUG			output a lot of debugging garbage
X### DEF=TERMCAP			include termcap file support
X### DEF=NO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### DEF=SOME_BUILTIN_TCAPS 	include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### DEF=ALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
XDEFINES = DEF=DIGRAPHS DEF=SOME_BUILTIN_TCAPS
X
X#>>>>> if TERMCAP is defined termlib.o has to be used
X#TERMLIB = termlib.o
XTERMLIB = 
X
X#>>>>> choose NODEBUG for normal compiling, the other for debugging and profiling
X# don't switch on debugging when generating proto files, it crashes the compiler.
XDBG = NODEBUG
X#DBG = DBG=SF
X
X#>>>>> choose NOOPTPEEP for 6.0 to 6.3, NOOPT for debugging
X# when all the optimizer bugs are finally solved you can use OPT
X#OPTIMIZE=OPT
XOPTIMIZE=NOOPTPEEP
X#OPTIMIZE=NOOPT
X
X#>>>>> end of choices
X###########################################################################
X
XCC = sc
XGST = vim.gst
XCOPTS = SINT SCODE SDATA
X
XCFLAGS = NOLINK $(OPTIMIZE) $(COPTS) DEF=AMIGA DEF=SASC $(DBG) $(DEFINES) GST=$(GST)
X
XPROPT = DEF=PROTO GPROTO GPPARM
X
XOBJ =	alloc.o amiga.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o term.o undo.o $(TERMLIB)
X
XPRO =	proto/alloc.pro proto/buffers.pro proto/charset.pro proto/cmdline.pro \
X	proto/csearch.pro proto/digraph.pro proto/edit.pro proto/fileio.pro \
X	proto/help.pro proto/linefunc.pro proto/main.pro proto/mark.pro \
X	proto/message.pro proto/misccmds.pro proto/normal.pro proto/ops.pro \
X	proto/param.pro proto/quickfix.pro proto/regexp.pro proto/regsub.pro \
X	proto/screen.pro proto/script.pro proto/search.pro proto/storage.pro \
X	proto/tag.pro proto/term.pro proto/termlib.pro \
X	proto/undo.pro proto/amiga.pro
X
X/Vim: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) LINK $(COPTS) $(OBJ) version.o $(DBG) PNAME=/Vim
X
Xdebug: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) LINK $(COPTS) $(OBJ) version.o $(DBG) PNAME=/Vim
X
Xproto: $(GST) $(PRO)
X
Xctags:
X	csh -c ctags *.c *.h
X
X# can't use delete here, too many file names
Xclean:
X	csh -c rm -f $(OBJ) version.o mkcmdtab.o /Vim $(GST) mkcmdtab
X
X$(GST)  : vim.h keymap.h macros.h ascii.h term.h
X	$(CC) $(CFLAGS) MGST=$(GST) vim.h
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(GST)
X	$(CC) $(CFLAGS) alloc.c
X
Xproto/alloc.pro:	alloc.c  $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/alloc.pro $(PROPT) alloc.c
X
Xamiga.o:	amiga.c  $(GST)
X	$(CC) $(CFLAGS) amiga.c
X
Xproto/amiga.pro:	amiga.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/amiga.pro $(PROPT) amiga.c
X
Xbuffers.o:	buffers.c  $(GST)
X	$(CC) $(CFLAGS) buffers.c
X
Xproto/buffers.pro:	buffers.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/buffers.pro $(PROPT) buffers.c
X
Xcharset.o:	charset.c  $(GST)
X	$(CC) $(CFLAGS) charset.c
X
Xproto/charset.pro:	charset.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/charset.pro $(PROPT) charset.c
X
Xcmdline.o:	cmdline.c  $(GST) cmdtab.h
X	$(CC) $(CFLAGS) cmdline.c
X
Xproto/cmdline.pro:	cmdline.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/cmdline.pro $(PROPT) cmdline.c
X
Xcsearch.o:	csearch.c  $(GST)
X	$(CC) $(CFLAGS) csearch.c
X
Xproto/csearch.pro:	csearch.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/csearch.pro $(PROPT) csearch.c
X
Xdigraph.o:	digraph.c  $(GST)
X	$(CC) $(CFLAGS) digraph.c
X
Xproto/digraph.pro:	digraph.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/digraph.pro $(PROPT) digraph.c
X
Xedit.o:	edit.c  $(GST)
X	$(CC) $(CFLAGS) edit.c
X
Xproto/edit.pro:	edit.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/edit.pro $(PROPT) edit.c
X
Xfileio.o:	fileio.c  $(GST)
X	$(CC) $(CFLAGS) fileio.c
X
Xproto/fileio.pro:	fileio.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/fileio.pro $(PROPT) fileio.c
X
Xhelp.o:	help.c  $(GST)
X	$(CC) $(CFLAGS) help.c
X
Xproto/help.pro:	help.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/help.pro $(PROPT) help.c
X
Xlinefunc.o:	linefunc.c  $(GST)
X	$(CC) $(CFLAGS) linefunc.c
X
Xproto/linefunc.pro:	linefunc.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/linefunc.pro $(PROPT) linefunc.c
X
Xmain.o:	main.c  $(GST)
X	$(CC) $(CFLAGS) main.c
X
Xproto/main.pro:	main.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/main.pro $(PROPT) main.c
X
Xmark.o:	mark.c  $(GST) mark.h
X	$(CC) $(CFLAGS) mark.c
X
Xproto/mark.pro:	mark.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/mark.pro $(PROPT) mark.c
X
Xmessage.o:	message.c  $(GST)
X	$(CC) $(CFLAGS) message.c
X
Xproto/message.pro:	message.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/message.pro $(PROPT) message.c
X
Xmisccmds.o:	misccmds.c  $(GST)
X	$(CC) $(CFLAGS) misccmds.c
X
Xproto/misccmds.pro:	misccmds.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/misccmds.pro $(PROPT) misccmds.c
X
Xnormal.o:	normal.c  $(GST) ops.h
X	$(CC) $(CFLAGS) normal.c
X
Xproto/normal.pro:	normal.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/normal.pro $(PROPT) normal.c
X
Xops.o:	ops.c  $(GST) ops.h
X	$(CC) $(CFLAGS) ops.c
X
Xproto/ops.pro:	ops.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/ops.pro $(PROPT) ops.c
X
Xparam.o:	param.c  $(GST)
X	$(CC) $(CFLAGS) param.c
X
Xproto/param.pro:	param.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/param.pro $(PROPT) param.c
X
Xquickfix.o:	quickfix.c  $(GST)
X	$(CC) $(CFLAGS) quickfix.c
X
Xproto/quickfix.pro:	quickfix.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/quickfix.pro $(PROPT) quickfix.c
X
Xregexp.o:	regexp.c  $(GST)
X	$(CC) $(CFLAGS) regexp.c
X
Xproto/regexp.pro:	regexp.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/regexp.pro $(PROPT) regexp.c
X
Xregsub.o:	regsub.c  $(GST)
X	$(CC) $(CFLAGS) regsub.c
X
Xproto/regsub.pro:	regsub.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/regsub.pro $(PROPT) regsub.c
X
Xscreen.o:	screen.c  $(GST)
X	$(CC) $(CFLAGS) screen.c
X
Xproto/screen.pro:	screen.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/screen.pro $(PROPT) screen.c
X
Xscript.o:	script.c  $(GST)
X	$(CC) $(CFLAGS) script.c
X
Xproto/script.pro:	script.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/script.pro $(PROPT) script.c
X
Xsearch.o:	search.c  $(GST)
X	$(CC) $(CFLAGS) search.c
X
Xproto/search.pro:	search.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/search.pro $(PROPT) search.c
X
Xstorage.o:	storage.c  $(GST)
X	$(CC) $(CFLAGS) storage.c
X
Xproto/storage.pro:	storage.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/storage.pro $(PROPT) storage.c
X
Xtag.o:	tag.c  $(GST) mark.h
X	$(CC) $(CFLAGS) tag.c
X
Xproto/tag.pro:	tag.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/tag.pro $(PROPT) tag.c
X
Xterm.o:	term.c  $(GST)
X	$(CC) $(CFLAGS) term.c
X
Xproto/term.pro:	term.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/term.pro $(PROPT) term.c
X
Xtermlib.o:	termlib.c  $(GST)
X	$(CC) $(CFLAGS) termlib.c
X
Xproto/termlib.pro:	termlib.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/termlib.pro $(PROPT) termlib.c
X
Xundo.o:	undo.c  $(GST)
X	$(CC) $(CFLAGS) undo.c
X
Xproto/undo.pro:	undo.c $(GST)
X	$(CC) $(CFLAGS) GPFILE=proto/undo.pro $(PROPT) undo.c
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab.o:	mkcmdtab.c
X	$(CC) $(CFLAGS) mkcmdtab.c
X
Xmkcmdtab: mkcmdtab.o
X	$(CC) LINK $(COPTS) mkcmdtab.o PNAME=mkcmdtab
END_OF_FILE
if test 7825 -ne `wc -c <'vim/src/makefile.sas'`; then
    echo shar: \"'vim/src/makefile.sas'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.sas'
# end of 'vim/src/makefile.sas'
fi
if test -f 'vim/src/tag.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/tag.c'\"
else
echo shar: Extracting \"'vim/src/tag.c'\" \(9080 characters\)
sed "s/^X//" >'vim/src/tag.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Code to handle tags and the tag stack
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X#include "mark.h"
X
X#define TAGSTACKSIZE 20
X
X/*
X * the taggy struct is used to store the information about a :tag command:
X *	the tag name and the cursor position BEFORE the :tag command
X */
Xstruct taggy
X{
X	char			*tagname;			/* tag name */
X	struct filemark fmark;				/* cursor position */
X};
X
X/*
X * the tagstack grows from 0 upwards:
X * entry 0: older
X * entry 1: newer
X * entry 2: newest
X */
Xstatic struct taggy tagstack[TAGSTACKSIZE];	/* the tag stack */
Xstatic int tagstackidx = 0;				/* index just below active entry */
Xstatic int tagstacklen = 0;				/* number of tags on the stack */
X
Xstatic int findtag __ARGS((char *));
X
Xstatic char bottommsg[] = "at bottom of tag stack";
Xstatic char topmsg[] = "at top of tag stack";
X
X/*
X * Jump to tag; handling of tag stack
X *
X * *tag != NUL (:tag): jump to new tag, add to tag stack
X * type == 1 (:pop) || type == 2 (CTRL-T): jump to old position
X * type == 0 (:tag): jump to old tag
X */
X	void
Xdotag(tag, type, count)
X	char	*tag;
X	int		type;
X	int		count;
X{
X	int 			i;
X	struct taggy	temptag;
X
X	if (*tag != NUL)						/* new pattern, add to the stack */
X	{
X		/*
X		 * if last used entry is not at the top, put it at the top by rotating
X		 * the stack until it is (the newer entries will be at the bottom)
X		 */
X		while (tagstackidx < tagstacklen)
X		{
X			temptag = tagstack[tagstacklen - 1];
X			for (i = tagstacklen - 1; i > 0; --i)
X				tagstack[i] = tagstack[i - 1];
X			tagstack[0] = temptag;
X			++tagstackidx;
X		}
X				/* if tagstack is full: remove oldest entry */
X		if (++tagstacklen > TAGSTACKSIZE)
X		{
X			tagstacklen = TAGSTACKSIZE;
X			free(tagstack[0].tagname);
X			for (i = 1; i < tagstacklen; ++i)
X				tagstack[i - 1] = tagstack[i];
X			--tagstackidx;
X		}
X	/*
X	 * remember the tag and the position before the jump
X	 */
X		tagstack[tagstackidx].tagname = strsave(tag);
X		tagstack[tagstackidx].fmark.lnum = Curpos.lnum;
X		tagstack[tagstackidx].fmark.mark.col = Curpos.col;
X		tagstack[tagstackidx].fmark.mark.ptr = nr2ptr(Curpos.lnum);
X		tagstack[tagstackidx].fmark.fnum = 0;
X	}
X	else if (tagstacklen == 0)					/* empty stack */
X	{
X		emsg("tag stack empty");
X		return;
X	}
X	else if (type)								/* go to older position */
X	{
X		if ((tagstackidx -= count) < 0)
X		{
X			tagstackidx = 0;
X			emsg(bottommsg);
X		}
X		else if (tagstackidx >= tagstacklen)	/* must have been count == 0 */
X		{
X			emsg(topmsg);
X			return;
X		}
X		if (tagstack[tagstackidx].fmark.mark.ptr == NULL)	/* jump to other file */
X		{
X			if (getaltfile(tagstack[tagstackidx].fmark.fnum - 1, tagstack[tagstackidx].fmark.lnum, TRUE))
X			{
X				/* emsg(e_notopen); */
X				return;
X			}
X			/* "refresh" this position, so we will not fall off the altfile array */
X			tagstack[tagstackidx].fmark.fnum = 0;
X			tagstack[tagstackidx].fmark.mark.ptr = nr2ptr(Curpos.lnum);
X		}
X		else
X			Curpos.lnum = ptr2nr(tagstack[tagstackidx].fmark.mark.ptr, (linenr_t)1);
X		Curpos.col = tagstack[tagstackidx].fmark.mark.col;
X		return;
X	}
X	else									/* go to newer pattern */
X	{
X		if ((tagstackidx += count - 1) >= tagstacklen)
X		{
X			tagstackidx = tagstacklen - 1;
X			emsg(topmsg);
X		}
X		else if (tagstackidx < 0)			/* must have been count == 0 */
X		{
X			emsg(bottommsg);
X			tagstackidx = 0;
X			return;
X		}
X	}
X	if (findtag(tagstack[tagstackidx].tagname) > 0)
X		++tagstackidx;
X	else if (bufempty())		/* "vim -t tag" failed, start script now */
X		startscript();
X}
X
X/*
X * invalidate the line pointer for all tags
X * called when abandoning the current file
X */
X	void
Xclrtags()
X{
X	int			i;
X
X	for (i = 0; i < tagstacklen; ++i)
X		tagstack[i].fmark.mark.ptr = NULL;
X}
X
X/*
X * increment the file number for all tags
X * called when adding a file to the file stack
X */
X	void
Xincrtags()
X{
X	int			i;
X
X	for (i = 0; i < tagstacklen; ++i)
X	{
X#if 0		/* this would take too much time */
X		if (tagstack[i].fmark.fnum == 0)	/* current file */
X			tagstack[i].fmark.lnum = ptr2nr(tagstack[i].fmark.mark.ptr, 1);
X#endif
X		++tagstack[i].fmark.fnum;
X	}
X}
X
X/*
X * decrement the file number for the tags of the current file
X * called when not adding the current file name to the file stack
X */
X	void
Xdecrtags()
X{
X	int			i;
X
X	for (i = 0; i < tagstacklen; ++i)
X		if (tagstack[i].fmark.fnum == 1)
X			tagstack[i].fmark.fnum = 0;
X}
X
X/*
X * Print the tag stack (use the occasion to update the line numbers)
X */
X	void
Xdotags()
X{
X	int			i;
X	char		*name;
X
X#ifdef AMIGA
X	settmode(0);		/* set cooked mode so output can be halted */
X#endif
X	outstrn("\n  # TO tag      FROM line in file\n");
X	for (i = 0; i < tagstacklen; ++i)
X	{
X		if (tagstack[i].tagname != NULL)
X		{
X			name = fm_getname(&(tagstack[i].fmark));
X			if (name == NULL)		/* file name not available */
X				continue;
X
X			sprintf(IObuff, "%c%2d %-15s %4ld  %s\n",
X				i == tagstackidx ? '>' : ' ',
X				i + 1,
X				tagstack[i].tagname,
X				tagstack[i].fmark.lnum,
X				name);
X			outstrn(IObuff);
X		}
X		flushbuf();
X	}
X	if (tagstackidx == tagstacklen)		/* idx at top of stack */
X		outstrn(">\n");
X#ifdef AMIGA
X	settmode(1);
X#endif
X	wait_return(TRUE);
X}
X
X/*
X * findtag(tag) - goto tag
X *   return 0 for failure, 1 for success
X */
X	static int
Xfindtag(tag)
X	char		   *tag;
X{
X	FILE	   *tp, *fopen();
X	char		lbuf[LSIZE];
X	char		pbuf[LSIZE];			/* search pattern buffer */
X	char	   *fname, *str;
X	int			cmplen;
X	char		*m = "No tags file";
X	register char	*p;
X	char		*np;					/* pointer into file name string */
X	char		sbuf[CMDBUFFSIZE + 1];	/* tag file name */
X	int			i;
X	int			save_secure;
X
X	if (tag == NULL)		/* out of memory condition */
X		return 0;
X
X	if ((cmplen = p_tl) == 0)
X		cmplen = 999;
X
X	/* get stack of tag file names from tags option */
X	for (np = p_tags; *np; )
X	{
X		for (i = 0; i < CMDBUFFSIZE && *np; ++i)	/* copy next file name into lbuf */
X		{
X			if (*np == ' ')
X			{
X				++np;
X				break;
X			}
X			sbuf[i] = *np++;
X		}
X		sbuf[i] = 0;
X		if ((tp = fopen(sbuf, "r")) == NULL)
X			continue;
X		while (fgets(lbuf, LSIZE, tp) != NULL)
X		{
X			m = "Format error in tags file %s";	/* default error message */
X
X		/* find start of file name, after first white space */
X			fname = lbuf;
X			skiptospace(&fname);	/* skip tag */
X			if (*fname == NUL)
X				goto erret;
X			*fname++ = '\0';
X
X			if (strncmp(lbuf, tag, (size_t)cmplen) == 0)	/* Tag found */
X			{
X				fclose(tp);
X				skipspace(&fname);
X
X			/* find start of search command, after second white space */
X				str = fname;
X				skiptospace(&str);
X				if (*str == NUL)
X					goto erret;
X				*str++ = '\0';
X				skipspace(&str);
X
X				/*
X				 * If the command is a string like "/^function fname"
X				 * scan through the search string. If we see a magic
X				 * char, we have to quote it. This lets us use "real"
X				 * implementations of ctags.
X				 */
X				if (*str == '/' || *str == '?')
X				{
X					p = pbuf;
X					*p++ = *str++;			/* copy the '/' or '?' */
X					if (*str == '^')
X						*p++ = *str++;			/* copy the '^' */
X
X					while (*str)
X					{
X						switch (*str)
X						{
X						case '\\':	if (str[1] == '(')	/* remove '\' before '(' */
X										++str;
X									else
X										*p++ = *str++;
X									break;
X
X						case '\r':
X						case '\n':	*p++ = pbuf[0];	/* copy '/' or '?' */
X									*str = 'n';		/* no setpcmark() for search */
X									str[1] = NUL;	/* delete NL after CR */
X									break;
X
X									/*
X									 * if string ends in search character: skip it
X									 * else escape it with '\'
X									 */
X						case '/':
X						case '?':	if (*str != pbuf[0])	/* not the search char */
X										break;
X															/* last char */
X									if (str[1] == '\n' || str[1] == '\r')
X									{
X										++str;
X										continue;
X									}
X						case '[':
X									if (!p_magic)
X										break;
X						case '^':
X						case '*':
X						case '.':	*p++ = '\\';
X									break;
X						}
X						*p++ = *str++;
X					}
X				}
X				else		/* not a search command, just copy it */
X					for (p = pbuf; *str && *str != '\n'; )
X						*p++ = *str++;
X				*p = NUL;
X
X				RedrawingDisabled = TRUE;
X				/* expand filename (for environment variables) */
X				if ((p = ExpandOne((u_char *)fname, 1, -1)) != NULL)
X					fname = p;
X				i = getfile(fname, NULL, TRUE);
X				if (p)
X					free(p);
X				if (i <= 0)
X				{
X					set_want_col = TRUE;
X
X					RedrawingDisabled = FALSE;
X					save_secure = secure;
X					secure = 1;
X					docmdline((u_char *)pbuf);
X					if (secure == 2)		/* done something that is not allowed */
X						wait_return(TRUE);
X					secure = save_secure;
X
X						/* print the file message after redraw */
X					if (p_im && i == -1)
X						stuffReadbuff("\033\007i");	/* ESC CTRL-G i */
X					else
X						stuffcharReadbuff('\007');		/* CTRL-G */
X					return 1;
X				}
X				RedrawingDisabled = FALSE;
X				return 0;
X			}
X		}
X		m = NULL;
X
Xerret:
X		fclose(tp);
X		if (m)
X		{
X			emsg2(m, sbuf);
X			sleep(1);
X		}
X	}
X	if (m == NULL)
X		emsg("tag not found");
X	else if (*np == NUL)
X		emsg(m);
X	return 0;
X}
END_OF_FILE
if test 9080 -ne `wc -c <'vim/src/tag.c'`; then
    echo shar: \"'vim/src/tag.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/tag.c'
# end of 'vim/src/tag.c'
fi
if test -f 'vim/src/vim.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vim.h'\"
else
echo shar: Extracting \"'vim/src/vim.h'\" \(8136 characters\)
sed "s/^X//" >'vim/src/vim.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X#if defined(SYSV_UNIX) || defined(BSD_UNIX)
X# ifndef UNIX
X#  define UNIX
X# endif
X#endif
X
X#include "debug.h"
X
X#include <stdio.h>
X
X#include <ctype.h>
X#ifndef DOMAIN
X#include <limits.h>		/* For MAX_INT, remove this if it does not exist */
X#endif
X
X#ifdef BSD_UNIX
X# include <strings.h>
X# ifdef __STDC__
X#  include <string.h>
X# endif
X#else
X# include <string.h>
X#endif
X
X#include "ascii.h"
X#include "keymap.h"
X#include "term.h"
X#include "macros.h"
X#ifdef LATTICE
X# include <sys/types.h>
X# include <sys/stat.h>
X#else
X# ifdef _DCC
X#  include <sys/stat.h>
X# else
X#  ifdef MSDOS 
X#   include <sys\stat.h>
X#  else
X#   ifdef UNIX
X#	 ifndef linux
X#	  define volatile		/* needed for gcc */
X#	  define signed			/* needed for gcc */
X#    endif
X#    include <sys/types.h>
X#    include <sys/stat.h>
X#   else
X#     include <stat.h>
X#   endif
X#  endif
X# endif
X#endif
X
X#ifndef DOMAIN
X# include <stdlib.h>
X#endif
X
X#ifdef AMIGA
X/*
X * arpbase.h must be included before functions.h
X */
X# include <libraries/arpbase.h>
X
X/*
X * This won't be needed if you have a version of Lattice 4.01 without broken
X * break signal handling.
X */
X#include <signal.h>
X#endif
X
X#ifndef AMIGA
X/*
X * For the Amiga we use a version of getenv that does local variables under 2.0
X */
X#define vimgetenv(x) getenv(x)
X#endif
X
X#ifdef AZTEC_C
X# include <functions.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef SASC
X# include <clib/exec_protos.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef _DCC
X# include <functions.h>
X# define __ARGS(x)	x
X# define __PARMS(x)	x
X#endif
X
X#ifdef __TURBOC__
X# define __ARGS(x) x
X#endif
X
X#ifdef MSDOS
X# include <dos.h>
X# include <dir.h>
X#endif
X
X#ifdef SOLARIS
X# include <stdlib.h>
X# include <unistd.h>
X#endif
X
X#ifdef UNIX
X# ifdef SCO
X#  undef M_XENIX
X#  include <sys/ndir.h>		/* for MAXNAMLEN */
X# else
X#  if defined(SOLARIS) || defined(AIX)
X#   include <dirent.h>		/* for MAXNAMLEN */
X#  else
X#   include <sys/dir.h>		/* for MAXNAMLEN */
X#  endif
X# endif
X# ifdef USL
X#  define MAXNAMLEN DIRSIZ
X# endif
X# if defined(UFS_MAXNAMLEN) && !defined(MAXNAMLEN)
X#  define MAXNAMLEN UFS_MAXNAMLEN		/* for dynix/ptx */
X# endif
X# if defined(NAME_MAX) && !defined(MAXNAMLEN)
X#  define MAXNAMLEN NAME_MAX			/* for Linux before .99p3 */
X# endif
X# if !defined(MAXNAMLEN)
X#  define MAXNAMLEN 512                 /* for all other Unix */
X# endif
X#endif
X
X#ifdef UNICOS		/* would make sense for other systems too */
X# include <errno.h>
X#endif
X
X#if defined(__STDC__) || defined(__GNUC__)
X# ifndef __ARGS
X#  define __ARGS(x) x
X# endif /* __ARGS */
X# if defined(_SEQUENT_)
X#  include "ptx_stdlib.h"
X# endif
X# if defined(sun) && !defined(SOLARIS)
X#  include "sun_stdlib.h"
X# endif
X# if defined(linux) || defined(SCO) || defined(M_UNIX)
X#  include <unistd.h>  /* may make sense for others too. jw. */
X# endif
X#else /*__STDC__*/
X# if defined(_SEQUENT_) && !defined(_STDLIB_H_)
X  extern char *getenv();
X  extern void *malloc();
X# endif
X#endif /* __STDC__ */
X
X#ifndef __ARGS
X#define __ARGS(x)	()
X#endif
X#ifndef __PARMS
X#define __PARMS(x)	()
X#endif
X
X/*
X * for systems that do not allow free(NULL)
X */
X#ifdef NO_FREE_NULL
X# define free(x)	nofreeNULL(x)
X  extern void nofreeNULL __ARGS((void *));
X#endif
X
X/*
X * fnamecmp() is used to compare filenames.
X * On some systems case in a filename does not matter, on others it does.
X * (this does not account for maximum name lengths, thus it is not 100% accurate!)
X */
X#if defined(AMIGA) || defined(MSDOS)
X# define fnamecmp(x, y) stricmp((x), (y))
X#else
X# define fnamecmp(x, y) strcmp((x), (y))
X#endif
X
X/* flags for updateScreen() */
X#define VALID					90	/* buffer not changed */
X#define NOT_VALID				91	/* buffer changed */
X#define VALID_TO_CURSCHAR		92	/* buffer before cursor not changed */
X#define INVERTED				93	/* redisplay inverted part */
X#define CLEAR					94	/* first clear screen */
X#define CURSUPD					95	/* update cursor first */
X
X/* values for State */
X/*
X * The lowest three bits are used to distinguish normal/cmdline/insert+replace
X * mode. This is used for mapping.
X */
X#define NORMAL					0x01
X#define NORMAL_BUSY				0x11	/* busy interpreting a command */
X#define CMDLINE 				0x02
X#define INSERT					0x04
X#define REPLACE 				0x24	/* replace mode */
X#define HELP					0x30	/* displaying help */
X#define NOMAPPING 				0x40	/* no :mapping mode for vgetc() */
X#define HITRETURN				0x51	/* waiting for a return */
X#define SETWSIZE				0x60	/* window size has changed */
X#define ABBREV					0x80	/* abbreviation instead of mapping */
X
X/* directions */
X#define FORWARD 				 1
X#define BACKWARD				 -1
X
X/* for GetChars */
X#define T_PEEK					1	/* do not wait at all */
X#define T_WAIT					2	/* wait for a short time */
X#define T_BLOCK					3	/* wait forever */
X
X#define VISUALLINE			MAXCOL	/* Visual is linewise */
X
X/*
X * Names for the EXRC, HELP and temporary files.
X * Some of these may have been defined in the makefile.
X */
X#ifndef SYSVIMRC_FILE
X# define SYSVIMRC_FILE	"s:.vimrc"
X#endif
X#ifndef SYSEXRC_FILE
X# define SYSEXRC_FILE	"s:.exrc"
X#endif
X#ifndef VIMRC_FILE
X# define VIMRC_FILE		".vimrc"
X#endif
X#ifndef EXRC_FILE
X# define EXRC_FILE		".exrc"
X#endif
X#ifndef VIM_HLP
X# define VIM_HLP		"vim:vim.hlp"
X#endif
X#define TMPNAME1		"t:viXXXXXX"
X#define TMPNAME2		"t:voXXXXXX"
X#define TMPNAMELEN		12
X
X/*
X * Boolean constants
X */
X#ifndef TRUE
X#define FALSE	(0)			/* note: this is an int, not a long! */
X#define TRUE	(1)
X#endif
X
X/*
X * Maximum screen width
X */
X#define MAX_COLUMNS 255L
X
X/*
X * Buffer sizes
X */
X#ifdef UNIX		/* Unix has plenty of memory */
X# define CMDBUFFSIZE	1024	/* size of the command processing buffer */
X#else
X# define CMDBUFFSIZE	256		/* size of the command processing buffer */
X#endif
X
X#define LSIZE		512			/* max. size of a line in the tags file */
X
X#define IOSIZE	   (1024+1) 	/* file i/o and sprintf buffer size */
X
X#define	TERMBUFSIZE	1024
X
X#ifdef linux
X# define TBUFSZ 2048			/* buffer size for termcap entry */
X#else
X# define TBUFSZ 1024			/* buffer size for termcap entry */
X#endif
X
X/*
X * maximum length of a file name path
X */
X#ifdef UNIX
X# define MAXPATHL	1024		/* Unix has long paths and plenty of memory */
X#else
X# define MAXPATHL	128			/* not too long to put name on stack */
X#endif
X
X#ifdef MSDOS
X# define BASENAMELEN	8		/* length of base of file name */
X#else
X# ifdef UNIX
X#  define BASENAMELEN	(MAXNAMLEN - 5)
X# else
X#  define BASENAMELEN	26		/* Amiga */
X# endif
X#endif
X
X#ifdef MSDOS
X# define WRITEBIN	"wb"		/* no CR-LF translation */
X# define READBIN	"rb"
X#else
X# define WRITEBIN	"w"
X# define READBIN	"r"
X#endif
X
X#define CHANGED   set_Changed()
X#define UNCHANGED Changed = 0
X
X#if !defined(BSD_UNIX) && !defined(linux) && !defined(SASC) && !defined(__sgi) && !defined(SCO) && !defined(hpux) && !defined(SOLARIS) && !defined(M_UNIX) && !defined(AIX) && !defined(_UTS) && !defined(USL)
Xtypedef unsigned char	u_char;		/* shorthand */
Xtypedef unsigned short	u_short;	/* shorthand */
Xtypedef unsigned int	u_int;		/* shorthand */
Xtypedef unsigned long	u_long;		/* shorthand */
X#endif
X
X#if defined(BSD_UNIX) && !defined(__STDC__)
X# define strchr(ptr, c)			index((ptr), (c))
X# define strrchr(ptr, c)		rindex((ptr), (c))
X#endif
X
X#ifdef BSD_UNIX
X# define memset(ptr, c, size)	bsdmemset((ptr), (c), (size))
Xchar *bsdmemset __ARGS((char *, int, long));
X#endif
X
Xtypedef long			linenr_t;	/* line number type */
Xtypedef unsigned		colnr_t;	/* column number type */
Xtypedef struct fpos		FPOS;		/* file position type */
X
X#define INVLNUM (0x7fffffff)		/* invalid line number */
X#ifdef MAX_INT
X# define MAXCOL	MAX_INT				/* maximum column number */
X#else
X# define MAXCOL	32767				/* maximum column number */
X#endif
X
Xstruct fpos
X{
X		linenr_t		lnum;	/* line number */
X		colnr_t 		col;	/* column number */
X};
X
X/*
X * Some versions of isspace() handle Meta character like a space!
X * This define fixes that.
X */
X#ifdef VIM_ISSPACE
X# ifdef isspace
X#  undef isspace
X# endif /* isspace */
X# define isspace(x)  (((x) >= 9 && (x) <= 13) || ((x) == 32))
X#endif /* VIM_ISSPACE */
END_OF_FILE
if test 8136 -ne `wc -c <'vim/src/vim.h'`; then
    echo shar: \"'vim/src/vim.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/vim.h'
# end of 'vim/src/vim.h'
fi
echo shar: End of archive 4 \(of 25\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
