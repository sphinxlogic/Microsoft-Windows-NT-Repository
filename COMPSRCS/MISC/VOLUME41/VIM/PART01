Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i051:  vim - Vi IMitation editor, v2.0, Part01/25
Message-ID: <1993Dec21.034211.26684@sparky.sterling.com>
X-Md4-Signature: fccca5ad6f071108922773f5bf8fa28e
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:42:11 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 51
Archive-name: vim/part01
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 25)."
# Contents:  vim vim/.exrc vim/README vim/doc vim/doc/unix.doc
#   vim/doc/vim132.uue vim/execute.me vim/macros vim/macros/center.uue
#   vim/macros/hanoi vim/macros/hanoi/click.me
#   vim/macros/hanoi/hanoi_ma.uue vim/macros/hanoi/poster
#   vim/macros/keyword.uue vim/macros/maze vim/macros/maze/README
#   vim/macros/maze/makefile vim/macros/maze/maze.c
#   vim/macros/maze/maze_5.78 vim/macros/maze/maze_ansi.c
#   vim/macros/maze/poster vim/macros/readme vim/poster vim/src
#   vim/src/addcr.c vim/src/ascii.h vim/src/debug.h vim/src/macros.h
#   vim/src/mark.h vim/src/mkcmdtab.c vim/src/ops.h vim/src/proto
#   vim/src/proto.h vim/src/proto/alloc.pro vim/src/proto/amiga.pro
#   vim/src/proto/buffers.pro vim/src/proto/charset.pro
#   vim/src/proto/cmdline.pro vim/src/proto/csearch.pro
#   vim/src/proto/digraph.pro vim/src/proto/edit.pro
#   vim/src/proto/fileio.pro vim/src/proto/help.pro
#   vim/src/proto/linefunc.pro vim/src/proto/main.pro
#   vim/src/proto/mark.pro vim/src/proto/message.pro
#   vim/src/proto/misccmds.pro vim/src/proto/normal.pro
#   vim/src/proto/ops.pro vim/src/proto/param.pro
#   vim/src/proto/quickfix.pro vim/src/proto/regexp.pro
#   vim/src/proto/regsub.pro vim/src/proto/screen.pro
#   vim/src/proto/script.pro vim/src/proto/search.pro
#   vim/src/proto/storage.pro vim/src/proto/tag.pro
#   vim/src/proto/term.pro vim/src/proto/termlib.pro
#   vim/src/proto/undo.pro vim/src/ptx_stdlib.h vim/src/regexp.h
#   vim/src/regmagic.h vim/src/sun_stdlib.h vim/src/term_fix.uue
#   vim/src/vim.prj vim/src/vimresp vim/tutor vim/tutor/Readme
#   vim/tutor/poster
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'vim' ; then
    echo shar: Creating directory \"'vim'\"
    mkdir 'vim'
fi
if test -f 'vim/.exrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/.exrc'\"
else
echo shar: Extracting \"'vim/.exrc'\" \(30 characters\)
sed "s/^X//" >'vim/.exrc' <<'END_OF_FILE'
Xset ai bs=2 shell=csh nojs ru
END_OF_FILE
if test 30 -ne `wc -c <'vim/.exrc'`; then
    echo shar: \"'vim/.exrc'\" unpacked with wrong size!
fi
chmod +x 'vim/.exrc'
# end of 'vim/.exrc'
fi
if test -f 'vim/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/README'\"
else
echo shar: Extracting \"'vim/README'\" \(1629 characters\)
sed "s/^X//" >'vim/README' <<'END_OF_FILE'
XREADME for version 2.0 of Vim: Vi IMproved.
X
XVim is an almost compatible version of the UNIX editor vi. Only the 'Q'
Xcommand is missing (you don't need it). Many new features have been added:
Xmulti level undo, command line history, filename completion, block operations,
Xetc. See difference.doc.
X
XThis editor is very useful for editing programs and other plain ASCII files. 
XAll commands are given with normal keyboard characters, so those who can type 
Xwith ten fingers can work very fast. Additionally function keys can be defined
Xby the user.
X
XVim currently runs under Amiga DOS, MSDOS and many UNIX versions. Porting to
Xother systems should not be very difficult.
X
XDocumentation:
X	  tutor/readme - one hour training course for beginners
X	 reference.doc - complete reference of all Vim commands
X	difference.doc - summarizes the differences with UNIX vi
X		 index - alfabetical list of commands
X	     amiga.doc - remarks for Amiga
X	      unix.doc - remarks for unix
X	     msdos.doc - remarks for MSDOS
X
XVim is Charityware. You can copy it as much as you like. Please read
Xuganda.txt for details.
X
X
XThe makefile offers some compilation options. If you do not use digraphs, you
Xcan save some memory by recompiling without the DIGRAPHS option. The Amiga
Xand MS-DOS versions are compiled for a limited number of supported terminals.
XIf you want to use Vim with other terminals you can recompile with the
XTERMCAP option. See the makefiles for further options.
X
XPlease send comments, bug reports and suggestions to:
X
X	Bram Moolenaar		UUCP E-mail:	mool@oce.nl
X	Clematisstraat 30		FAX:    +31-77-595473
X	5925 BE  Venlo
X	The Netherlands
END_OF_FILE
if test 1629 -ne `wc -c <'vim/README'`; then
    echo shar: \"'vim/README'\" unpacked with wrong size!
fi
chmod +x 'vim/README'
# end of 'vim/README'
fi
if test ! -d 'vim/doc' ; then
    echo shar: Creating directory \"'vim/doc'\"
    mkdir 'vim/doc'
fi
if test -f 'vim/doc/unix.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/unix.doc'\"
else
echo shar: Extracting \"'vim/doc/unix.doc'\" \(1226 characters\)
sed "s/^X//" >'vim/doc/unix.doc' <<'END_OF_FILE'
XThis file contains the particularities for the UNIX version of Vim.
X
XThe default help filename is "/usr/local/lib/vim.hlp"
XThe files "$HOME/.vimrc" and "$HOME/.exrc" are used instead of "s:.vimrc" and 
X"s:.exrc". Additionally "/usr/etc/.vimrc" is used first.
X
XTemporary files (for filtering) are put in "/tmp".
X
XIn some cases the terminal may have a problem with CTRL-S (subtract
Xcommand). To get around this you can map another key to CTRL-S, and remap
XCTRL-S to nothing. You could use CTRL-W:
X	:noremap! ^W ^V019
X	:noremap! ^V019 ^V^V
X	:noremap ^W ^V019
X	:noremap ^V019 ^V^V
X(^V is the single character CTRL-V. Do not use the '^' character. You have to 
Xtype CTRL-V twice to get one. What is shown above is what you have to type, 
Xit will look different on the screen or in the .exrc file.)
X
XWith wildcard expansion you can use <~> (home directory) and <$> 
X(environment variable).
X
XBecause terminal updating under UNIX is often slow (e.g. serial line 
Xterminal, shell window in suntools), the 'showcommand' and 'ruler' options 
Xare default off.
X
XThe file Vim132 is a shell script that can be used to put Vim in 132 column 
Xmode on a vt100 and lookalikes.
X
XThe *.info files are for the Amiga. You don't need them with unix.
END_OF_FILE
if test 1226 -ne `wc -c <'vim/doc/unix.doc'`; then
    echo shar: \"'vim/doc/unix.doc'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/unix.doc'
# end of 'vim/doc/unix.doc'
fi
if test -f 'vim/doc/vim132.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/vim132.uue'\"
else
echo shar: Extracting \"'vim/doc/vim132.uue'\" \(372 characters\)
sed "s/^X//" >'vim/doc/vim132.uue' <<'END_OF_FILE'
X
Xbegin 644 vim132
XM(R$@+V)I;B]C<V@*(R!3:&5L;"!S8W)I<'0@9F]R('5S92!W:71H(%5.25@*1
XM(R!3=&%R=',@=7`@5FEM('=I=&@@=&AE('1E<FUI;F%L(&EN(#$S,B!C;VQU.
XM;6X@;6]D90HC($]N;'D@=V]R:W,@;VX@5E0M,3`P('1E<FUI;F%L<R!A;F0@,
XM;&]O:V%L:6ME<PHC"G-E="!O;&1T97)M/21T97)M"F5C:&\@(AM;/S-H(@IS[
XM971E;G8@5$5232!V=#$P,"UW(`IV:6T@)"H*<V5T('1E<FT])&]L9'1E<FT*M
X-96-H;R`B&UL_,VPB"C$P"
X``
Xend
Xsize 238
END_OF_FILE
if test 372 -ne `wc -c <'vim/doc/vim132.uue'`; then
    echo shar: \"'vim/doc/vim132.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/vim132.uue'
# end of 'vim/doc/vim132.uue'
fi
if test -f 'vim/execute.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/execute.me'\"
else
echo shar: Extracting \"'vim/execute.me'\" \(840 characters\)
sed "s/^X//" >'vim/execute.me' <<'END_OF_FILE'
X#  Script to unpack the source distribution of Vim
X#
X#  Execute this script in the 'vim' directory.
X#  It is not very smart, no error checking at all.
X#
X#  What it does:
X#  - a few files with special characters in them will be uudecoded
X#  - the three parts of reference.doc are concatenated
X#
Xcd macros
Xuudecode center.uue
Xrm center.uue
Xcd maze
Xuudecode maze_mac.uue
Xrm maze_mac.uue
Xcd ../hanoi
Xuudecode hanoi_ma.uue
Xrm hanoi_ma.uue
Xcd ../../src
Xuudecode digrap_c.uue
Xuudecode tccon_tc.uue
Xuudecode term_fix.uue
Xrm digrap_c.uue tccon_tc.uue term_fix.uue
Xcd ../doc
Xuudecode vim_hlp.uue
Xuudecode digr_doc.uue
Xuudecode vim_man.uue
Xuudecode vim132.uue
Xrm vim_hlp.uue digr_doc.uue vim_man.uue vim132.uue
Xcat reference.do1 reference.do2 reference.do3 reference.do4 >reference.doc
Xrm reference.do1 reference.do2 reference.do3 reference.do4
Xcd ..
END_OF_FILE
if test 840 -ne `wc -c <'vim/execute.me'`; then
    echo shar: \"'vim/execute.me'\" unpacked with wrong size!
fi
chmod +x 'vim/execute.me'
# end of 'vim/execute.me'
fi
if test ! -d 'vim/macros' ; then
    echo shar: Creating directory \"'vim/macros'\"
    mkdir 'vim/macros'
fi
if test -f 'vim/macros/center.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/center.uue'\"
else
echo shar: Extracting \"'vim/macros/center.uue'\" \(274 characters\)
sed "s/^X//" >'vim/macros/center.uue' <<'END_OF_FILE'
X
Xbegin 644 center
XM(E1H:7,@;6%C<F\@8V5N=&5R<R!A(&QI;F4@:6X@86X@.#`@8VAA<F%C=&5R$
XM('-P86-E+@HB0V%R969U;#H@;&EN97,@;&]N9V5R('1H86X@.#`@8VAA<F%CY
XM=&5R<R!W:6QL(&)E('1R=6YC871E9`IM87`@.V-E(#IS+UY;(`E=*B\O#21MS
XB83@Q82`;.#$6?$1@86QL9#`Z<R\@("\@+V<-)'`-:R1X"EY;+
X``
Xend
Xsize 169
END_OF_FILE
if test 274 -ne `wc -c <'vim/macros/center.uue'`; then
    echo shar: \"'vim/macros/center.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/center.uue'
# end of 'vim/macros/center.uue'
fi
if test ! -d 'vim/macros/hanoi' ; then
    echo shar: Creating directory \"'vim/macros/hanoi'\"
    mkdir 'vim/macros/hanoi'
fi
if test -f 'vim/macros/hanoi/click.me' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/click.me'\"
else
echo shar: Extracting \"'vim/macros/hanoi/click.me'\" \(255 characters\)
sed "s/^X//" >'vim/macros/hanoi/click.me' <<'END_OF_FILE'
X
X
XSee Vim solve the towers of Hanoi!
X
XInstructions:
X   type ":so hanoi.mac<RETURN>" to load the macros
X   type "g" to start it
X
Xand watch it go.
X
X     to quit type ":q!<RETURN>"
Xto interrupt type CTRL-C
X
X(This text will disappear as soon as you type "g")
END_OF_FILE
if test 255 -ne `wc -c <'vim/macros/hanoi/click.me'`; then
    echo shar: \"'vim/macros/hanoi/click.me'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/hanoi/click.me'
# end of 'vim/macros/hanoi/click.me'
fi
if test -f 'vim/macros/hanoi/hanoi_ma.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/hanoi_ma.uue'\"
else
echo shar: Extracting \"'vim/macros/hanoi/hanoi_ma.uue'\" \(1577 characters\)
sed "s/^X//" >'vim/macros/hanoi/hanoi_ma.uue' <<'END_OF_FILE'
X
Xbegin 644 hanoi.mac
XM<V5T(')E;6%P"G-E="!N;W1E<G-E"G-E="!W<F%P<V-A;@HB('1O('-E="!T[
XM:&4@:&5I9VAT(&]F('1H92!T;W=E<BP@8VAA;F=E('1H92!D:6=I="!I;B!T<
XM:&4@9F]L;&]W:6YG"B(@='=O(&QI;F5S('1O('1H92!H96EG:'0@>6]U('=A1
XM;G0@*'-E;&5C="!F<F]M(#$@=&\@.2D*;6%P('0@-PIM87`A('0@-PIM87`@#
XM3"`Q1R]T#5@O7C`-)%`Q1THD06XD0D=#,&4D6#!%,$8D6"]4#4!F#4!H#21!$
XM,4=*0&8P;"18;B1050IM87`@9R!)3`H*;6%P($H@+UXP6UYT72HD#0IM87`@A
XM6"!X"FUA<"!0('`*;6%P(%4@3`IM87`@02`B9GEL"FUA<"!"(")H>6P*;6%P8
XM($,@(F9P"FUA<"!E(")F>3)L"FUA<"!%(")H<`IM87`@1B`B:'DR;`H*(B!I\
XM;FET:6%L:7-A=&EO;G,Z"B(@2TT)8VQE86YU<"!B=69F97(*(B!9"6-R96%T1
XM92!T;W=E<B!O9B!D97-I<F5D(&AE:6=H=`HB($Y/40EC;W!Y(&ET(&%N9"!I;
XM;G-T97(@82!4"B(@3D\)8V]P>2!T:&ES(&]N90HB(%,)8VAA;F=E(&QA<W0@*
XM8VAA<B!I;G1O(&$@)`HB(%()8VAA;F=E(&QA<W0@8VAA<B!I;B!P<F5V:6]U]
XM<R!L:6YE(&EN=&\@82!N"B(@5`EI;G-E<G0@='=O(&QI;F5S(&-O;G1A:6YI,
XM;F<@82!Z97)O"B(@5@EA9&0@82!L87-T(&QI;F4@8V]N=&%I;FEN9R!A(&)A5
XM8VMS;&%S:`IM87`@22!+35E.3U%.3U-K4E16"@HB8W)E871E(&5M<'1Y(&QI>
XM;F4*;6%P($L@,4=O&PH*(F1E;&5T92!T;R!E;F0@;V8@9FEL90IM87`@32!D9
XM1PH*(GEA;FL@;VYE(&QI;F4*;6%P($X@>7D*"B)P=70*;6%P($\@<`H*(F1EW
XM;&5T92!M;W)E('1H86X@:&5I9VAT+6]F+71O=V5R(&-H87)A8W1E<G,*;6%P)
XM('$@=&QL1`H*(F-R96%T92!A('1O=V5R(&]F(&1E<VER960@:&5I9VAT"FUAC
XM<"!9(&\P,3(S-#4V-S@Y6ALP<0H*(FEN<V5R="!A(%0@:6X@8V]L=6UN(#$*;
XM;6%P(%$@,&E4&PH*(G-U8G-T:71U=&4@;&%S="!C:&%R86-T97(@=VET:"!AG
XM(&X*;6%P(%(@)')N"@HB<W5B<W1I='5T92!L87-T(&-H87)A8W1E<B!W:71H[
XM(&$@)`IM87`@4R`D<B0*"B)I;G-E<G0@='=O(&QI;F5S(&-O;G1A:6YI;F<@$
XM82!Z97)O"FUA<"!4(&MO,`TP#0T;"@HB861D(&$@8F%C:W-L87-H(&%T('1HV
X192!E;F0*;6%P(%8@1V\O&PHP4
X``
Xend
Xsize 1097
END_OF_FILE
if test 1577 -ne `wc -c <'vim/macros/hanoi/hanoi_ma.uue'`; then
    echo shar: \"'vim/macros/hanoi/hanoi_ma.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/hanoi/hanoi_ma.uue'
# end of 'vim/macros/hanoi/hanoi_ma.uue'
fi
if test -f 'vim/macros/hanoi/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/hanoi/poster'\"
else
echo shar: Extracting \"'vim/macros/hanoi/poster'\" \(1259 characters\)
sed "s/^X//" >'vim/macros/hanoi/poster' <<'END_OF_FILE'
XArticle 2913 of alt.sources:
XPath: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!cluster!swift!softway!otc!gregm
XFrom: gregm@otc.otca.oz.au (Greg McFarlane)
XNewsgroups: comp.sources.d,alt.sources,comp.editors
XSubject: VI SOLVES HANOI
XMessage-ID: <2323@otc.otca.oz>
XDate: 19 Feb 91 01:32:14 GMT
XSender: news@otc.otca.oz
XReply-To: gregm@otc.otca.oz.au (Greg McFarlane)
XOrganization: OTC Development Unit, Australia
XLines: 80
XXref: oce-rd1 comp.sources.d:5702 alt.sources:2913 comp.editors:2313
X
XSubmitted-by: gregm@otc.otca.oz.au
XArchive-name: hanoi.vi.macros/part01
X
XEveryone seems to be writing stupid Tower of Hanoi programs.
XWell, here is the stupidest of them all: the hanoi solving vi macros.
X
XSave this article, unshar it, and run uudecode on hanoi.vi.macros.uu.
XThis will give you the macro file hanoi.vi.macros.
XThen run vi (with no file: just type "vi") and type:
X	:so hanoi.vi.macros
X	g
Xand watch it go.
X
XThe default height of the tower is 7 but can be easily changed by editing
Xthe macro file.
X
XThe disks aren't actually shown in this version, only numbers representing
Xeach disk, but I believe it is possible to write some macros to show the
Xdisks moving about as well. Any takers?
X
X(For maze solving macros, see alt.sources or comp.editors)
X
XGreg
END_OF_FILE
if test 1259 -ne `wc -c <'vim/macros/hanoi/poster'`; then
    echo shar: \"'vim/macros/hanoi/poster'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/hanoi/poster'
# end of 'vim/macros/hanoi/poster'
fi
if test -f 'vim/macros/keyword.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/keyword.uue'\"
else
echo shar: Extracting \"'vim/macros/keyword.uue'\" \(767 characters\)
sed "s/^X//" >'vim/macros/keyword.uue' <<'END_OF_FILE'
X
Xbegin 644 keyword
XM(B!3;VUE(&AA;F1Y(&ME>7=O<F0M8V]M<&QE=&EO;B!M86-R;W,N"B(@5&AE6
XM('=O<F0@:6X@9G)O;G0@;V8@=&AE(&-U<G-O<B!I<R!T86ME;B!A<R!A('-E,
XM87)C:"!S=')I;F<L('1H92!P<F5V:6]U<PHB('!A<G1I86QL>2!M871C:&ENA
XM9R!W;W)D(&ES(&9O=6YD('=H:6-H('1H96X@<F5P;&%C97,@=&AE('=O<F0@)
XM:6X@9G)O;G0*(B!O9B!T:&4@8W5R<V]R+B!4:&4@;6%C<F]S('=O<FL@:6X@N
XM:6YS97)T(&UO9&4N"B(*(B!>2R!S96%R8VAE<R!B86-K=V%R9"!F;W(@=&AE^
XM(&9I<G-T(&UA=&-H"B(@7DX@<V5A<F-H97,@8F%C:W=A<F0@9F]R('1H92!N0
XM97AT(&UA=&-H("AA9G1E<B!>2RD*(B!>4"!S96%R8VAE<R!F;W)W87)D(&9O\
XM<B!T:&4@<')E=FEO=7,@;6%T8V@@*&%F=&5R(%Y+*0HB"B(@5&AA;FMS('1O-
XM($1A=F4@0V%U9VAE>2X*(@HZ;6%P(2`+(!86%@T;8FUM:3]</!M@;2)N>68-8
XM0&YM;B)N>7=@;6-F#0)N"CIM87`A(`X@+AM@;FYM;B)N>7=@;6-F+@)N"CIM2
X987`A(!`@+AM@;DYM;B)N>7=@;6-F+@)N"AM@[
X``
Xend
Xsize 520
END_OF_FILE
if test 767 -ne `wc -c <'vim/macros/keyword.uue'`; then
    echo shar: \"'vim/macros/keyword.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/keyword.uue'
# end of 'vim/macros/keyword.uue'
fi
if test ! -d 'vim/macros/maze' ; then
    echo shar: Creating directory \"'vim/macros/maze'\"
    mkdir 'vim/macros/maze'
fi
if test -f 'vim/macros/maze/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/README'\"
else
echo shar: Extracting \"'vim/macros/maze/README'\" \(1666 characters\)
sed "s/^X//" >'vim/macros/maze/README' <<'END_OF_FILE'
XTo prove that you can do anything in vi, I wrote a couple of macros that
Xallows vi to solve mazes. It will solve any maze produced by maze.c
Xthat was posted to the net recently.
X
XJust follow this recipe and SEE FOR YOURSELF.
X	1. run uudecode on the file "maze.vi.macros.uu" to
X		produce the file "maze.vi.macros"
X	(If you can't wait to see the action, jump to step 4)
X	2. compile maze.c with "cc -o maze maze.c"
X	3. run maze > maze.out and input a small number (for example 10 if
X		you are on a fast machine, 3-5 if slow) which
X		is the size of the maze to produce
X	4. edit the maze (vi maze.out)
X	5. include the macros with the vi command:
X		:so maze.vi.macros
X	6. type the letter "g" (for "go") and watch vi solve the maze
X	7. when vi solves the maze, you will see why it lies
X	8. now look at maze.vi.macros and all will be revealed
X
XTested on a sparc, a sun and a pyramid (although maze.c will not compile
Xon the pyramid).
X
XAnyone who can't get the maze.c file to compile, get a new compiler,
Xtry maze.ansi.c which was also posted to the net.
XIf you can get it to compile but the maze comes out looking like a fence
Xand not a maze and you are using SysV or DOS replace the "27" on the
Xlast line of maze.c by "11"
XThanks to John Tromp (tromp@piring.cwi.nl) for maze.c.
XThanks to antonyc@nntp-server.caltech.edu (Bill T. Cat) for maze.ansi.c.
X
XAny donations should be in unmarked small denomination bills :^)=.
X
X                   ACSnet:  gregm@otc.otca.oz.au
XGreg McFarlane       UUCP:  {uunet,mcvax}!otc.otca.oz.au!gregm
X|||| OTC ||         Snail:  OTC R&D GPO Box 7000, Sydney 2001, Australia
X                    Phone:  +61 2 287 3139    Fax: +61 2 287 3299
X
X
END_OF_FILE
if test 1666 -ne `wc -c <'vim/macros/maze/README'`; then
    echo shar: \"'vim/macros/maze/README'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/README'
# end of 'vim/macros/maze/README'
fi
if test -f 'vim/macros/maze/makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/makefile'\"
else
echo shar: Extracting \"'vim/macros/maze/makefile'\" \(104 characters\)
sed "s/^X//" >'vim/macros/maze/makefile' <<'END_OF_FILE'
X#On the amiga with manx C 5.0 we have to use maze.ansi.c
X
Xmaze: maze.ansi.o
X	ln maze.ansi.o -o maze -lc
END_OF_FILE
if test 104 -ne `wc -c <'vim/macros/maze/makefile'`; then
    echo shar: \"'vim/macros/maze/makefile'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/makefile'
# end of 'vim/macros/maze/makefile'
fi
if test -f 'vim/macros/maze/maze.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze.c'\"
else
echo shar: Extracting \"'vim/macros/maze/maze.c'\" \(441 characters\)
sed "s/^X//" >'vim/macros/maze/maze.c' <<'END_OF_FILE'
Xchar*M,A,Z,E=40,J[40],T[40];main(C){for(*J=A=scanf(M="%d",&C);
X--            E;             J[              E]             =T
X[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
X)    ,   A    =              39              ,C             --
X)    ;   Z    ||    printf   (M   ))M[Z]=Z[A-(E   =A[J-Z])&&!C
X&    A   ==             T[                                  A]
X|6<<27<rand()||!C&!Z?J[T[E]=T[A]]=E,J[T[A]=A-Z]=A,"_.":" |"];}
END_OF_FILE
if test 441 -ne `wc -c <'vim/macros/maze/maze.c'`; then
    echo shar: \"'vim/macros/maze/maze.c'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/maze.c'
# end of 'vim/macros/maze/maze.c'
fi
if test -f 'vim/macros/maze/maze_5.78' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze_5.78'\"
else
echo shar: Extracting \"'vim/macros/maze/maze_5.78'\" \(626 characters\)
sed "s/^X//" >'vim/macros/maze/maze_5.78' <<'END_OF_FILE'
X._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._._
X| ._| . . ._| | |_._._. . ._|_._._._._. ._|_. ._|_._. ._| . ._|_. | . ._._. |
X| ._|_| |_. | | | | ._._|_._|_._. . |_. | | | ._._| |_._._| | ._. ._| . . |_|
X|_._._._. | ._|_. ._._._. | | ._. |_._. . | ._._| |_. | ._._._. |_. | |_|_| |
X| | . |_._| . ._._._| ._._. ._._| | | |_| . | |_. . ._|_| ._._. |_._|_| . | |
X|_._|_._._._|_._._._|_|_._._._|_._|_._._._|_._._._|_._._._|_._._._._._._|_._|
X
XSee Vim solve a maze!
X
X   type ":so maze_mac<RETURN>" to load the macros
X
X   type "g" to start
X
Xto interrupt type "<CTRL-C>"
X     to quit type ":q!<RETURN>"
X
END_OF_FILE
if test 626 -ne `wc -c <'vim/macros/maze/maze_5.78'`; then
    echo shar: \"'vim/macros/maze/maze_5.78'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/maze_5.78'
# end of 'vim/macros/maze/maze_5.78'
fi
if test -f 'vim/macros/maze/maze_ansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze_ansi.c'\"
else
echo shar: Extracting \"'vim/macros/maze/maze_ansi.c'\" \(441 characters\)
sed "s/^X//" >'vim/macros/maze/maze_ansi.c' <<'END_OF_FILE'
Xchar*M,A,Z,E=40,J[80],T[3];main(C){for(M=J+E,*J=A=scanf("%d",&
XC)            ;--            E;J             [E            ]=M
X[E   ]=  E)   printf("._");  for(;(A-=Z=!Z)  ||  (printf("\n|"
X)    ,   A    =              39              ,C             --
X)    ;   Z    ||    printf   (T   ))T[Z]=Z[A-(E   =A[J-Z])&&!C
X&    A   ==             M[                                  A]
X|6<<11<rand()||!C&!Z?J[M[E]=M[A]]=E,J[M[A]=A-Z]=A,"_.":" |"];}
END_OF_FILE
if test 441 -ne `wc -c <'vim/macros/maze/maze_ansi.c'`; then
    echo shar: \"'vim/macros/maze/maze_ansi.c'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/maze_ansi.c'
# end of 'vim/macros/maze/maze_ansi.c'
fi
if test -f 'vim/macros/maze/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/poster'\"
else
echo shar: Extracting \"'vim/macros/maze/poster'\" \(1562 characters\)
sed "s/^X//" >'vim/macros/maze/poster' <<'END_OF_FILE'
XArticle 2846 of alt.sources:
XPath: oce-rd1!hp4nl!mcsun!uunet!munnari.oz.au!metro!otc!gregm
XFrom: gregm@otc.otca.oz.au (Greg McFarlane)
XNewsgroups: alt.sources
XSubject: VI SOLVES MAZE (commented macros)
XMessage-ID: <2289@otc.otca.oz>
XDate: 10 Feb 91 23:31:02 GMT
XSender: news@otc.otca.oz
XReply-To: gregm@otc.otca.oz.au (Greg McFarlane)
XOrganization: OTC Development Unit, Australia
XLines: 464
X
XSubmitted-by: gregm@otc.otca.oz.au
XArchive-name: maze_solving_vi_macros
X
XA real working model. See it walk the maze in front of your very own eyes.
X
XTo prove that you can do anything in vi, I wrote a couple of macros that
Xallows vi to solve mazes. It will solve any maze produced by maze.c
Xthat was posted to the alt.sources last month. (Maze.c is also included
Xin this posting as well as an example of its output.)
X
XThe uncommented version of the macros was sent to alt.sources last month.
XHowever, so many people mailed me requesting the commented version of the
Xmacros that I decided to post it. I have made some modifications to the
Xoriginal macros to make them easier to follow and also after I learnt
Xthat you can escape the special meaning of '|' in macros by using '^V|'.
X
XSave this article and unshar it. Then read maze.README.
X
XAfter studying these macros, anyone who cannot write an emacs emulator
Xin vi macros should just curl up and :q!.
X
XComing soon to a newsgroup near you: "Vi macros solve Tower of Hanoi",
Xand a repost of the original "Turing Machine implemented in Vi macros"
X
XAnyone who has a version of these macros for edlin or nroff, please post.
END_OF_FILE
if test 1562 -ne `wc -c <'vim/macros/maze/poster'`; then
    echo shar: \"'vim/macros/maze/poster'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/poster'
# end of 'vim/macros/maze/poster'
fi
if test -f 'vim/macros/readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/readme'\"
else
echo shar: Extracting \"'vim/macros/readme'\" \(407 characters\)
sed "s/^X//" >'vim/macros/readme' <<'END_OF_FILE'
XThe macros in the maze and hanoi directories can be used to test Vim for
Xvi compatibility. They have been written for vi to show its unlimited
Xpossibilities.
X
XHANOI are macros that solve the tower of hanoi problem.
XMAZE  are macros that solve a maze (amazing!).
X
XThey are unmodified.
X
X
XThe other files contain some handy macros:
X
Xcenter: center current line in 80-character line
Xkeyword: keyword completion
END_OF_FILE
if test 407 -ne `wc -c <'vim/macros/readme'`; then
    echo shar: \"'vim/macros/readme'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/readme'
# end of 'vim/macros/readme'
fi
if test -f 'vim/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/poster'\"
else
echo shar: Extracting \"'vim/poster'\" \(1584 characters\)
sed "s/^X//" >'vim/poster' <<'END_OF_FILE'
XVim - Vi IMproved. A clone of the UNIX text editor Vi. Very useful for 
Xediting programs and other plain ASCII text. Full Vi compatibility (except Q 
Xcommand, you don't need it). Includes most Ex commands.
X
XExtra features above Vi: Multilevel undo, command line history, improved 
Xcommand line editing, command typeahead display, command to display yank 
Xbuffers, possibility to edit binary files, line wrapping can be switched off,
Xfile name stack, can be adjusted to understand error messages from any
Xcompiler, shows current file name in window title, on-line help, etc. 
X
XVersion 2.0, update to 1.27. Most important changes:
X- 'wrap' option to switch line wrapping on/off
X- filename completion is more like other programs and adjustable
X- automatic detection of CR/LF line separator
X- '-b' command line option to make editing binary files more easy
X- added abbreviation
X- :make command for quickly jumping to errors
X- MSDOS version uses bios calls for screen output, ansi.sys not needed
X- many small changes to make Vim more vi-compatible
X
XPortability: Runs on MSDOS, Amiga and several UNIX versions.
X
XDistribution:
Xcomp.binaries.ibm.pc:	vim_dos.zip:	MSDOS binary and documentation
X
Xcomp.binaries.amiga:	vim_bin.lha:	Amiga binary and documentation
X
Xcomp.sources.misc:	shell archive with sources and documentation
X
XThe documentation is almost the same for all systems. For MSDOS CR-LF is used
Xfor line separator. For Amiga .info files are included. For the shell archive
Xsome files are uuencoded because of unprintable characters.
X
XVim is charityware. Read uganda.txt for details.
END_OF_FILE
if test 1584 -ne `wc -c <'vim/poster'`; then
    echo shar: \"'vim/poster'\" unpacked with wrong size!
fi
chmod +x 'vim/poster'
# end of 'vim/poster'
fi
if test ! -d 'vim/src' ; then
    echo shar: Creating directory \"'vim/src'\"
    mkdir 'vim/src'
fi
if test -f 'vim/src/addcr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/addcr.c'\"
else
echo shar: Extracting \"'vim/src/addcr.c'\" \(413 characters\)
sed "s/^X//" >'vim/src/addcr.c' <<'END_OF_FILE'
X/*
X * This program, when compiled with Turbo-C, will make <LF> into <CR><LF>
X */
X
X#include <stdio.h>
X
Xmain(argc, argv)
X	int argc;
X	char **argv;
X{
X	char buffer[1024];
X	int	len;
X
X	while ((len = fread(buffer, 1, 1024, stdin)) > 0)
X		fwrite(buffer, 1, len, stdout);
X	if (ferror(stdin))
X		fprintf(stderr, "Error while reading\n");
X	if (ferror(stdout))
X		fprintf(stderr, "Error while writing\n");
X}
END_OF_FILE
if test 413 -ne `wc -c <'vim/src/addcr.c'`; then
    echo shar: \"'vim/src/addcr.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/addcr.c'
# end of 'vim/src/addcr.c'
fi
if test -f 'vim/src/ascii.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ascii.h'\"
else
echo shar: Extracting \"'vim/src/ascii.h'\" \(794 characters\)
sed "s/^X//" >'vim/src/ascii.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Definitions of various common control characters
X */
X
X#define NUL 					'\000'
X#define BS						'\010'
X#define BS_STR					"\010"
X#define TAB 					'\011'
X#define NL						'\012'
X#define NL_STR					"\012"
X#define CR						'\015'
X#define ESC 					'\033'
X#define ESC_STR 				"\033"
X#define DEL 					0x7f
X#define CSI 					0x9b
X
X#define Ctrl(x) ((x) & 0x1f)
X#define Meta(x) ((x) | 0x80)
X
X/*
X * character that separates dir names in a path
X */
X#ifdef MSDOS
X# define PATHSEP '\\'
X# define PATHSEPSTR "\\"
X#else
X# define PATHSEP '/'
X# define PATHSEPSTR "/"
X#endif
END_OF_FILE
if test 794 -ne `wc -c <'vim/src/ascii.h'`; then
    echo shar: \"'vim/src/ascii.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/ascii.h'
# end of 'vim/src/ascii.h'
fi
if test -f 'vim/src/debug.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/debug.h'\"
else
echo shar: Extracting \"'vim/src/debug.h'\" \(865 characters\)
sed "s/^X//" >'vim/src/debug.h' <<'END_OF_FILE'
X/*
X * debug.h -- my debug header for just any program.
X * use:
X * place the statement OPENDEBUG("/tmp/programdebug"); inside main.
X * Nothing will happen, unless you compile the source with -DDEBUG.
X * 
X * jw. 13.4.91.
X */
X#ifndef FILE
X# include <stdio.h>
X#endif
X
X#ifdef DEBUG
X#	define debug(x) {fprintf(debugfp,x);fflush(debugfp);}
X#	define debug1(x,a) {fprintf(debugfp,x,a);fflush(debugfp);}
X#	define debug2(x,a,b) {fprintf(debugfp,x,a,b);fflush(debugfp);}
X#	define debug3(x,a,b,c) {fprintf(debugfp,x,a,b,c);fflush(debugfp);}
X#	define OPENDEBUG(file)\
X	if ((debugfp = fopen(file,"w")) == NULL)\
X	{	debugfp = stderr;\
X		debug1("OPENDEBUG: sorry, cannot open '%s'\n", file);\
X		debug("           beware, using stderr!\n");\
X		sleep(3);\
X	}
X#else
X#	define debug(x)
X#	define debug1(x,a)
X#	define debug2(x,a,b)
X#	define debug3(x,a,b,c)
X#	define OPENDEBUG(file)
X#endif
END_OF_FILE
if test 865 -ne `wc -c <'vim/src/debug.h'`; then
    echo shar: \"'vim/src/debug.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/debug.h'
# end of 'vim/src/debug.h'
fi
if test -f 'vim/src/macros.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/macros.h'\"
else
echo shar: Extracting \"'vim/src/macros.h'\" \(1376 characters\)
sed "s/^X//" >'vim/src/macros.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * macros.h: macro definitions for often used code
X */
X
X/*
X * pchar(lp, c) - put character 'c' at position 'lp'
X */
X#define pchar(lp, c) (*(nr2ptr((lp).lnum) + (lp).col) = (c))
X
X/*
X * Position comparisons
X */
X#define lt(a, b) (((a).lnum != (b).lnum) \
X				   ? ((a).lnum < (b).lnum) : ((a).col < (b).col))
X
X#define ltoreq(a, b) (((a).lnum != (b).lnum) \
X				   ? ((a).lnum < (b).lnum) : ((a).col <= (b).col))
X
X#define equal(a, b) (((a).lnum == (b).lnum) && ((a).col == (b).col))
X
X/*
X * buf1line() - return TRUE if there is only one line in file buffer
X */
X#define buf1line() (line_count == 1)
X
X/*
X * lineempty() - return TRUE if the line is empty
X */
X#define lineempty(p) (*nr2ptr(p) == NUL)
X
X/*
X * bufempty() - return TRUE if the file buffer is empty
X */
X#define bufempty() (buf1line() && lineempty((linenr_t)1))
X
X/*
X * On some systems toupper()/tolower() only work on lower/uppercase characters
X */
X#if defined(sequent) || defined(DOMAIN) || !defined(__STDC__)
X# define TO_UPPER(c)	(islower(c) ? toupper(c) : (c))
X# define TO_LOWER(c)	(isupper(c) ? tolower(c) : (c))
X#else
X# define TO_UPPER		toupper
X# define TO_LOWER		tolower
X#endif
END_OF_FILE
if test 1376 -ne `wc -c <'vim/src/macros.h'`; then
    echo shar: \"'vim/src/macros.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/macros.h'
# end of 'vim/src/macros.h'
fi
if test -f 'vim/src/mark.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/mark.h'\"
else
echo shar: Extracting \"'vim/src/mark.h'\" \(545 characters\)
sed "s/^X//" >'vim/src/mark.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * mark.h: definitions shared between tag.c and mark.c 
X */
X
Xstruct mark
X{
X	char		   *ptr;
X	colnr_t 		col;
X};
X
Xstruct filemark
X{
X	struct mark		mark;			/* cursor position */
X	linenr_t		lnum;			/* last known line number */
X	int				fnum;			/* file number */
X};
X
Xchar *fm_getname __ARGS((struct filemark *));
END_OF_FILE
if test 545 -ne `wc -c <'vim/src/mark.h'`; then
    echo shar: \"'vim/src/mark.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/mark.h'
# end of 'vim/src/mark.h'
fi
if test -f 'vim/src/mkcmdtab.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/mkcmdtab.c'\"
else
echo shar: Extracting \"'vim/src/mkcmdtab.c'\" \(2065 characters\)
sed "s/^X//" >'vim/src/mkcmdtab.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * mkcmdtab.c: separate program that reads cmdtab.tab and produces cmdtab.h
X *
X *	call with: mkcmdtab cmdtab.tab cmdtab.h
X */
X
X#include "vim.h"
X
X#if defined(UTS4)
X    int
X#else
X	void
X#endif
Xmain(argc, argv)
X	int		argc;
X	char	**argv;
X{
X	register int	c;
X	char			buffer[100];
X	int				count;
X	int				i;
X	FILE			*ifp, *ofp;
X
X	if (argc != 3)
X	{
X		fprintf(stderr, "Usage: mkcmdtab cmdtab.tab cmdtab.h\n");
X		exit(10);
X	}
X	ifp = fopen(argv[1], "r");
X	if (ifp == NULL)
X	{
X		perror(argv[1]);
X		exit(10);
X	}
X	ofp = fopen(argv[2], "w");
X	if (ofp == NULL)
X	{
X		perror(argv[2]);
X		exit(10);
X	}
X
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X	fprintf(ofp, "THIS FILE IS AUTOMATICALLY PRODUCED - DO NOT EDIT");
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		;
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X
X	count = 0;
X	while ((c = getc(ifp)) != '|' && c != EOF)
X	{
X		putc(c, ofp);
X		while ((c = getc(ifp)) != '"' && c != EOF)
X			putc(c, ofp);
X		putc(c, ofp);
X
X		i = 0;
X		while ((c = getc(ifp)) != '"' && c != EOF)
X		{
X			putc(c, ofp);
X			buffer[i++] = c;
X		}
X		putc(c, ofp);
X		buffer[i] = 0;
X
X		while ((c = getc(ifp)) != '\n' && c != EOF)
X			putc(c, ofp);
X		putc(c, ofp);
X
X		switch (buffer[0])
X		{
X			case '@':	strcpy(buffer, "at");
X						break;
X			case '!':	strcpy(buffer, "bang");
X						break;
X			case '<':	strcpy(buffer, "lshift");
X						break;
X			case '>':	strcpy(buffer, "rshift");
X						break;
X			case '=':	strcpy(buffer, "equal");
X						break;
X			case '&':	strcpy(buffer, "and");
X						break;
X			case '~':	strcpy(buffer, "tilde");
X						break;
X		}
X					
X		fprintf(ofp, "#define CMD_%s %d\n", buffer, count++);
X	}
X
X	fprintf(ofp, "#define CMD_SIZE %d\n", count);
X
X	while ((c = getc(ifp)) != '|' && c != EOF)
X		putc(c, ofp);
X
X	if (c != '|')
X	{
X		fprintf(stderr, "not enough |'s\n");
X		exit(1);
X	}
X	exit(0);
X}
END_OF_FILE
if test 2065 -ne `wc -c <'vim/src/mkcmdtab.c'`; then
    echo shar: \"'vim/src/mkcmdtab.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/mkcmdtab.c'
# end of 'vim/src/mkcmdtab.c'
fi
if test -f 'vim/src/ops.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ops.h'\"
else
echo shar: Extracting \"'vim/src/ops.h'\" \(1955 characters\)
sed "s/^X//" >'vim/src/ops.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * ops.h: things shared between normal.c, cmdline.c and ops.c
X */
X
X/*
X * Operators
X */
X#define NOP 	0				/* no pending operation */
X#define DELETE	1
X#define YANK	2
X#define CHANGE	3
X#define LSHIFT	4
X#define RSHIFT	5
X#define FILTER	6
X#define TILDE	7
X#define INDENT	8
X#define FORMAT	9
X#define COLON	10
X#define UPPER	11
X#define LOWER	12
X
X/*
X * operator characters; the order must correspond to the defines above
X */
XEXTERN char *opchars INIT(= "dyc<>!~=Q:Uu");
X
X/*
X * When a cursor motion command is made, it is marked as being a character or
X * line oriented motion. Then, if an operator is in effect, the operation
X * becomes character or line oriented accordingly.
X *
X * Character motions are marked as being inclusive or not. Most char. motions
X * are inclusive, but some (e.g. 'w') are not.
X *
X * Generally speaking, every command in normal() should either clear any pending
X * operator (with CLEAROP), or set the motion type variable.
X */
X
X/*
X * Motion types
X */
X#define MBAD	(-1)			/* 'bad' motion type marks unusable yank buf */
X#define MCHAR	0
X#define MLINE	1
X#define MBLOCK	2
X
XEXTERN int		operator INIT(= NOP);	/* current pending operator */
XEXTERN int		mtype;					/* type of the current cursor motion */
XEXTERN int		mincl;					/* true if char motion is inclusive */
XEXTERN FPOS 	startop;				/* cursor pos. at start of operator */
XEXTERN FPOS		endop;					/* cursor pos. at end of operator */
XEXTERN colnr_t	startvcol;				/* start col for block mode operator */
XEXTERN colnr_t	endvcol;				/* end col for block mode operator */
XEXTERN long		nlines;					/* lines between startop and endop + 1 */
XEXTERN int		yankbuffer INIT(= 0);	/* current yank buffer */
XEXTERN int		no_op;					/* startop and endop the same */
END_OF_FILE
if test 1955 -ne `wc -c <'vim/src/ops.h'`; then
    echo shar: \"'vim/src/ops.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/ops.h'
# end of 'vim/src/ops.h'
fi
if test ! -d 'vim/src/proto' ; then
    echo shar: Creating directory \"'vim/src/proto'\"
    mkdir 'vim/src/proto'
fi
if test -f 'vim/src/proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto.h'\"
else
echo shar: Extracting \"'vim/src/proto.h'\" \(1269 characters\)
sed "s/^X//" >'vim/src/proto.h' <<'END_OF_FILE'
X/*
X * proto.h: include the (automatically generated) function prototypes
X *
X * the proto/xxx.pro files are automatically generated when using Manx/Aztec C.
X * For other compilers you will have to edit them.
X */
X
X#include "regexp.h"		/* for struct regexp */
X
X/*
X * Machine-dependent routines.
X */
X#ifdef AMIGA
X# include "proto/amiga.pro"
X#endif
X#ifdef UNIX
X# include "unix.h"
X#endif
X#ifdef MSDOS
X# include "msdos.h"
X#endif
X
X#include "proto/alloc.pro"
X#include "proto/buffers.pro"
X#include "proto/charset.pro"
X#include "proto/cmdline.pro"
X#include "proto/csearch.pro"
X#include "proto/digraph.pro"
X#include "proto/edit.pro"
X#include "proto/fileio.pro"
X#include "proto/help.pro"
X#include "proto/linefunc.pro"
X#include "proto/main.pro"
X#include "proto/mark.pro"
X
X#ifndef MESSAGE
Xvoid smsg __PARMS((char *, ...));	/* cannot be produced automatically */
X#endif
X#include "proto/message.pro"
X#include "proto/misccmds.pro"
X#include "proto/normal.pro"
X#include "proto/ops.pro"
X#include "proto/param.pro"
X#include "proto/quickfix.pro"
X#include "proto/regexp.pro"
X#include "proto/regsub.pro"
X#include "proto/screen.pro"
X#include "proto/script.pro"
X#include "proto/search.pro"
X#include "proto/storage.pro"
X#include "proto/tag.pro"
X#include "proto/term.pro"
X#include "proto/undo.pro"
END_OF_FILE
if test 1269 -ne `wc -c <'vim/src/proto.h'`; then
    echo shar: \"'vim/src/proto.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto.h'
# end of 'vim/src/proto.h'
fi
if test -f 'vim/src/proto/alloc.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/alloc.pro'\"
else
echo shar: Extracting \"'vim/src/proto/alloc.pro'\" \(261 characters\)
sed "s/^X//" >'vim/src/proto/alloc.pro' <<'END_OF_FILE'
X/* alloc.c */
Xchar *alloc __PARMS((unsigned int size));
Xchar *lalloc __PARMS((unsigned long size, int message));
Xchar *strsave __PARMS((char *string));
Xchar *strnsave __PARMS((char *string, int len));
Xvoid copy_spaces __PARMS((char *ptr, unsigned long count));
END_OF_FILE
if test 261 -ne `wc -c <'vim/src/proto/alloc.pro'`; then
    echo shar: \"'vim/src/proto/alloc.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/alloc.pro'
# end of 'vim/src/proto/alloc.pro'
fi
if test -f 'vim/src/proto/amiga.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/amiga.pro'\"
else
echo shar: Extracting \"'vim/src/proto/amiga.pro'\" \(1207 characters\)
sed "s/^X//" >'vim/src/proto/amiga.pro' <<'END_OF_FILE'
X/* amiga.c */
Xvoid win_resize_on __PARMS((void));
Xvoid win_resize_off __PARMS((void));
Xvoid mch_write __PARMS((char *p, int len));
Xint GetChars __PARMS((char *buf, int maxlen, int time));
Xvoid sleep __PARMS((int n));
Xvoid vim_delay __PARMS((void));
Xvoid mch_suspend __PARMS((void));
Xvoid mch_windinit __PARMS((void));
Xvoid check_win __PARMS((int argc, char **argv));
Xvoid fname_case __PARMS((char *name));
Xvoid settitle __PARMS((char *str));
Xvoid resettitle __PARMS((void));
Xint dirname __PARMS((char *buf, int len));
Xint FullName __PARMS((char *fname, char *buf, int len));
Xlong getperm __PARMS((char *name));
Xint setperm __PARMS((char *name, long perm));
Xint isdir __PARMS((char *name));
Xvoid mch_windexit __PARMS((int r));
Xvoid mch_settmode __PARMS((int raw));
Xint mch_get_winsize __PARMS((void));
Xvoid mch_set_winsize __PARMS((void));
Xint call_shell __PARMS((char *cmd, int filter, int cooked));
Xvoid breakcheck __PARMS((void));
Xlong Chk_Abort __PARMS((void));
Xint ExpandWildCards __PARMS((int num_pat, char **pat, int *num_file, char ***file, int files_only, int list_notfound));
Xvoid FreeWild __PARMS((int num, char **file));
Xint has_wildcard __PARMS((char *p));
Xchar *vimgetenv __PARMS((char *var));
END_OF_FILE
if test 1207 -ne `wc -c <'vim/src/proto/amiga.pro'`; then
    echo shar: \"'vim/src/proto/amiga.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/amiga.pro'
# end of 'vim/src/proto/amiga.pro'
fi
if test -f 'vim/src/proto/buffers.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/buffers.pro'\"
else
echo shar: Extracting \"'vim/src/proto/buffers.pro'\" \(1043 characters\)
sed "s/^X//" >'vim/src/proto/buffers.pro' <<'END_OF_FILE'
X/* buffers.c */
Xunsigned char *get_recorded __PARMS((void));
Xunsigned char *get_inserted __PARMS((void));
Xint stuff_empty __PARMS((void));
Xvoid flush_buffers __PARMS((int typeahead));
Xvoid ResetRedobuff __PARMS((void));
Xvoid AppendToRedobuff __PARMS((char *s));
Xvoid AppendCharToRedobuff __PARMS((int c));
Xvoid AppendNumberToRedobuff __PARMS((long n));
Xvoid stuffReadbuff __PARMS((char *s));
Xvoid stuffcharReadbuff __PARMS((int c));
Xvoid stuffnumReadbuff __PARMS((long n));
Xvoid copy_redo __PARMS((void));
Xint start_redo __PARMS((long count));
Xint start_redo_ins __PARMS((void));
Xvoid set_redo_ins __PARMS((void));
Xvoid stop_redo_ins __PARMS((void));
Xint ins_typestr __PARMS((char *str, int noremap));
Xvoid del_typestr __PARMS((int len));
Xunsigned char vgetc __PARMS((void));
Xunsigned char vpeekc __PARMS((void));
Xint domap __PARMS((int maptype, char *keys, int mode));
Xint check_abbr __PARMS((int c, char *ptr, int col, int mincol));
Xint makemap __PARMS((struct __stdio *fd));
Xint putescstr __PARMS((struct __stdio *fd, char *str, int set));
END_OF_FILE
if test 1043 -ne `wc -c <'vim/src/proto/buffers.pro'`; then
    echo shar: \"'vim/src/proto/buffers.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/buffers.pro'
# end of 'vim/src/proto/buffers.pro'
fi
if test -f 'vim/src/proto/charset.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/charset.pro'\"
else
echo shar: Extracting \"'vim/src/proto/charset.pro'\" \(240 characters\)
sed "s/^X//" >'vim/src/proto/charset.pro' <<'END_OF_FILE'
X/* charset.c */
Xchar *transchar __PARMS((unsigned int c));
Xint outtrans __PARMS((char *str, int len));
Xint charsize __PARMS((int c));
Xint strsize __PARMS((char *s));
Xint chartabsize __PARMS((int c, int col));
Xint isidchar __PARMS((int c));
END_OF_FILE
if test 240 -ne `wc -c <'vim/src/proto/charset.pro'`; then
    echo shar: \"'vim/src/proto/charset.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/charset.pro'
# end of 'vim/src/proto/charset.pro'
fi
if test -f 'vim/src/proto/cmdline.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/cmdline.pro'\"
else
echo shar: Extracting \"'vim/src/proto/cmdline.pro'\" \(607 characters\)
sed "s/^X//" >'vim/src/proto/cmdline.pro' <<'END_OF_FILE'
X/* cmdline.c */
Xint getcmdline __PARMS((int firstc, unsigned char *buff));
Xvoid redrawcmdline __PARMS((void));
Xvoid redrawcmd __PARMS((void));
Xvoid docmdline __PARMS((unsigned char *cmdline));
Xvoid gotocmdline __PARMS((int clr, int firstc));
Xvoid gotocmdend __PARMS((void));
Xint check_fname __PARMS((void));
Xint getfile __PARMS((char *fname, char *sfname, int setpm));
Xint samealtfile __PARMS((int n));
Xint getaltfile __PARMS((int n, long lnum, int setpm));
Xchar *getaltfname __PARMS((int n));
Xchar *ExpandOne __PARMS((unsigned char *str, int list_notfound, int mode));
Xint dosource __PARMS((char *fname));
END_OF_FILE
if test 607 -ne `wc -c <'vim/src/proto/cmdline.pro'`; then
    echo shar: \"'vim/src/proto/cmdline.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/cmdline.pro'
# end of 'vim/src/proto/cmdline.pro'
fi
if test -f 'vim/src/proto/csearch.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/csearch.pro'\"
else
echo shar: Extracting \"'vim/src/proto/csearch.pro'\" \(158 characters\)
sed "s/^X//" >'vim/src/proto/csearch.pro' <<'END_OF_FILE'
X/* csearch.c */
Xvoid dosub __PARMS((long lp, long up, char *cmd, unsigned char **nextcommand));
Xvoid doglob __PARMS((int type, long lp, long up, char *cmd));
END_OF_FILE
if test 158 -ne `wc -c <'vim/src/proto/csearch.pro'`; then
    echo shar: \"'vim/src/proto/csearch.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/csearch.pro'
# end of 'vim/src/proto/csearch.pro'
fi
if test -f 'vim/src/proto/digraph.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/digraph.pro'\"
else
echo shar: Extracting \"'vim/src/proto/digraph.pro'\" \(169 characters\)
sed "s/^X//" >'vim/src/proto/digraph.pro' <<'END_OF_FILE'
X/* digraph.c */
Xint dodigraph __PARMS((int c));
Xint getdigraph __PARMS((int char1, int char2));
Xvoid putdigraph __PARMS((char *str));
Xvoid listdigraphs __PARMS((void));
END_OF_FILE
if test 169 -ne `wc -c <'vim/src/proto/digraph.pro'`; then
    echo shar: \"'vim/src/proto/digraph.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/digraph.pro'
# end of 'vim/src/proto/digraph.pro'
fi
if test -f 'vim/src/proto/edit.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/edit.pro'\"
else
echo shar: Extracting \"'vim/src/proto/edit.pro'\" \(389 characters\)
sed "s/^X//" >'vim/src/proto/edit.pro' <<'END_OF_FILE'
X/* edit.c */
Xvoid edit __PARMS((long count));
Xint get_literal __PARMS((int *nextc));
Xvoid insertchar __PARMS((unsigned int c));
Xint oneright __PARMS((void));
Xint oneleft __PARMS((void));
Xvoid beginline __PARMS((int flag));
Xint oneup __PARMS((long n));
Xint onedown __PARMS((long n));
Xint onepage __PARMS((int dir, long count));
Xvoid stuff_inserted __PARMS((int c, long count, int no_esc));
END_OF_FILE
if test 389 -ne `wc -c <'vim/src/proto/edit.pro'`; then
    echo shar: \"'vim/src/proto/edit.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/edit.pro'
# end of 'vim/src/proto/edit.pro'
fi
if test -f 'vim/src/proto/fileio.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/fileio.pro'\"
else
echo shar: Extracting \"'vim/src/proto/fileio.pro'\" \(244 characters\)
sed "s/^X//" >'vim/src/proto/fileio.pro' <<'END_OF_FILE'
X/* fileio.c */
Xvoid filemess __PARMS((char *name, char *s));
Xint readfile __PARMS((char *fname, char *sfname, long from, int newfile));
Xint writeit __PARMS((char *fname, char *sfname, long start, long end, int append, int forceit, int whole));
END_OF_FILE
if test 244 -ne `wc -c <'vim/src/proto/fileio.pro'`; then
    echo shar: \"'vim/src/proto/fileio.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/fileio.pro'
# end of 'vim/src/proto/fileio.pro'
fi
if test -f 'vim/src/proto/help.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/help.pro'\"
else
echo shar: Extracting \"'vim/src/proto/help.pro'\" \(72 characters\)
sed "s/^X//" >'vim/src/proto/help.pro' <<'END_OF_FILE'
X/* help.c */
Xvoid help __PARMS((void));
Xint redrawhelp __PARMS((void));
END_OF_FILE
if test 72 -ne `wc -c <'vim/src/proto/help.pro'`; then
    echo shar: \"'vim/src/proto/help.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/help.pro'
# end of 'vim/src/proto/help.pro'
fi
if test -f 'vim/src/proto/linefunc.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/linefunc.pro'\"
else
echo shar: Extracting \"'vim/src/proto/linefunc.pro'\" \(306 characters\)
sed "s/^X//" >'vim/src/proto/linefunc.pro' <<'END_OF_FILE'
X/* linefunc.c */
Xvoid coladvance __PARMS((unsigned int wcol));
Xint inc __PARMS((struct fpos *lp));
Xint incCurpos __PARMS((void));
Xint incl __PARMS((struct fpos *lp));
Xint dec __PARMS((struct fpos *lp));
Xint decCurpos __PARMS((void));
Xint decl __PARMS((struct fpos *lp));
Xvoid adjustCurpos __PARMS((void));
END_OF_FILE
if test 306 -ne `wc -c <'vim/src/proto/linefunc.pro'`; then
    echo shar: \"'vim/src/proto/linefunc.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/linefunc.pro'
# end of 'vim/src/proto/linefunc.pro'
fi
if test -f 'vim/src/proto/main.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/main.pro'\"
else
echo shar: Extracting \"'vim/src/proto/main.pro'\" \(87 characters\)
sed "s/^X//" >'vim/src/proto/main.pro' <<'END_OF_FILE'
X/* main.c */
Xvoid main __PARMS((int argc, char **argv));
Xvoid getout __PARMS((int r));
END_OF_FILE
if test 87 -ne `wc -c <'vim/src/proto/main.pro'`; then
    echo shar: \"'vim/src/proto/main.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/main.pro'
# end of 'vim/src/proto/main.pro'
fi
if test -f 'vim/src/proto/mark.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/mark.pro'\"
else
echo shar: Extracting \"'vim/src/proto/mark.pro'\" \(433 characters\)
sed "s/^X//" >'vim/src/proto/mark.pro' <<'END_OF_FILE'
X/* mark.c */
Xint setmark __PARMS((int c));
Xvoid setpcmark __PARMS((void));
Xstruct fpos *movemark __PARMS((int count));
Xstruct fpos *getmark __PARMS((int c, int changefile));
Xvoid clrallmarks __PARMS((void));
Xvoid incrmarks __PARMS((void));
Xvoid decrmarks __PARMS((void));
Xvoid adjustmark __PARMS((char *old, char *new));
Xchar *fm_getname __PARMS((struct filemark *fmark));
Xvoid domarks __PARMS((void));
Xvoid dojumps __PARMS((void));
END_OF_FILE
if test 433 -ne `wc -c <'vim/src/proto/mark.pro'`; then
    echo shar: \"'vim/src/proto/mark.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/mark.pro'
# end of 'vim/src/proto/mark.pro'
fi
if test -f 'vim/src/proto/message.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/message.pro'\"
else
echo shar: Extracting \"'vim/src/proto/message.pro'\" \(250 characters\)
sed "s/^X//" >'vim/src/proto/message.pro' <<'END_OF_FILE'
X/* message.c */
Xvoid msg __PARMS((char *s));
Xvoid emsg __PARMS((char *s));
Xvoid emsg2 __PARMS((char *s, char *a1));
Xvoid wait_return __PARMS((int redraw));
Xvoid start_msg __PARMS((void));
Xvoid end_msg __PARMS((void));
Xvoid check_msg __PARMS((void));
END_OF_FILE
if test 250 -ne `wc -c <'vim/src/proto/message.pro'`; then
    echo shar: \"'vim/src/proto/message.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/message.pro'
# end of 'vim/src/proto/message.pro'
fi
if test -f 'vim/src/proto/misccmds.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/misccmds.pro'\"
else
echo shar: Extracting \"'vim/src/proto/misccmds.pro'\" \(1208 characters\)
sed "s/^X//" >'vim/src/proto/misccmds.pro' <<'END_OF_FILE'
X/* misccmds.c */
Xint get_indent __PARMS((void));
Xvoid set_indent __PARMS((int size, int delete));
Xint Opencmd __PARMS((int dir, int redraw, int delspaces));
Xint plines __PARMS((long p));
Xint plines_m __PARMS((long first, long last));
Xvoid fileinfo __PARMS((int fullname));
Xvoid setfname __PARMS((char *s, char *ss));
Xint otherfile __PARMS((char *s));
Xvoid maketitle __PARMS((void));
Xvoid inschar __PARMS((int c));
Xvoid insstr __PARMS((char *s));
Xint delchar __PARMS((int fixpos));
Xvoid dellines __PARMS((long nlines, int doscreen, int undo));
Xint gchar __PARMS((struct fpos *pos));
Xint gcharCurpos __PARMS((void));
Xvoid pcharCurpos __PARMS((int c));
Xint inindent __PARMS((void));
Xvoid skipspace __PARMS((char **pp));
Xvoid skiptospace __PARMS((char **pp));
Xvoid skiptodigit __PARMS((char **pp));
Xlong getdigits __PARMS((char **pp));
Xchar *plural __PARMS((long n));
Xvoid set_Changed __PARMS((void));
Xvoid change_warning __PARMS((void));
Xint ask_yesno __PARMS((char *str));
Xvoid msgmore __PARMS((long n));
Xvoid beep __PARMS((void));
Xvoid expand_env __PARMS((char *src, char *dst, int dstlen));
Xint fullpathcmp __PARMS((char *s1, char *s2));
Xchar *gettail __PARMS((char *fname));
Xint ispathsep __PARMS((int c));
END_OF_FILE
if test 1208 -ne `wc -c <'vim/src/proto/misccmds.pro'`; then
    echo shar: \"'vim/src/proto/misccmds.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/misccmds.pro'
# end of 'vim/src/proto/misccmds.pro'
fi
if test -f 'vim/src/proto/normal.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/normal.pro'\"
else
echo shar: Extracting \"'vim/src/proto/normal.pro'\" \(44 characters\)
sed "s/^X//" >'vim/src/proto/normal.pro' <<'END_OF_FILE'
X/* normal.c */
Xvoid normal __PARMS((void));
END_OF_FILE
if test 44 -ne `wc -c <'vim/src/proto/normal.pro'`; then
    echo shar: \"'vim/src/proto/normal.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/normal.pro'
# end of 'vim/src/proto/normal.pro'
fi
if test -f 'vim/src/proto/ops.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/ops.pro'\"
else
echo shar: Extracting \"'vim/src/proto/ops.pro'\" \(757 characters\)
sed "s/^X//" >'vim/src/proto/ops.pro' <<'END_OF_FILE'
X/* ops.c */
Xvoid doshift __PARMS((int op));
Xvoid shift_line __PARMS((int left, int round));
Xint dorecord __PARMS((int c));
Xint doexecbuf __PARMS((int c));
Xint insertbuf __PARMS((int c));
Xvoid dodelete __PARMS((void));
Xvoid dotilde __PARMS((void));
Xvoid swapchar __PARMS((struct fpos *pos));
Xvoid dochange __PARMS((void));
Xvoid init_yank __PARMS((void));
Xint doyank __PARMS((int deleting));
Xvoid doput __PARMS((int dir, long count));
Xvoid dodis __PARMS((void));
Xvoid dodojoin __PARMS((long count, int insert_space, int redraw));
Xint dojoin __PARMS((int insert_space, int redraw));
Xvoid doformat __PARMS((void));
Xvoid startinsert __PARMS((int initstr, int startln, long count));
Xint doaddsub __PARMS((int c, long Prenum1));
Xint startinmargin __PARMS((void));
END_OF_FILE
if test 757 -ne `wc -c <'vim/src/proto/ops.pro'`; then
    echo shar: \"'vim/src/proto/ops.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/ops.pro'
# end of 'vim/src/proto/ops.pro'
fi
if test -f 'vim/src/proto/param.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/param.pro'\"
else
echo shar: Extracting \"'vim/src/proto/param.pro'\" \(229 characters\)
sed "s/^X//" >'vim/src/proto/param.pro' <<'END_OF_FILE'
X/* param.c */
Xvoid set_init __PARMS((void));
Xint doset __PARMS((char *arg));
Xvoid paramchanged __PARMS((char *arg));
Xint makeset __PARMS((struct __stdio *fd));
Xvoid clear_termparam __PARMS((void));
Xvoid comp_col __PARMS((void));
END_OF_FILE
if test 229 -ne `wc -c <'vim/src/proto/param.pro'`; then
    echo shar: \"'vim/src/proto/param.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/param.pro'
# end of 'vim/src/proto/param.pro'
fi
if test -f 'vim/src/proto/quickfix.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/quickfix.pro'\"
else
echo shar: Extracting \"'vim/src/proto/quickfix.pro'\" \(202 characters\)
sed "s/^X//" >'vim/src/proto/quickfix.pro' <<'END_OF_FILE'
X/* quickfix.c */
Xint qf_init __PARMS((void));
Xvoid qf_jump __PARMS((int errornr));
Xvoid qf_list __PARMS((void));
Xvoid qf_clrallmarks __PARMS((void));
Xvoid qf_adjustmark __PARMS((char *old, char *new));
END_OF_FILE
if test 202 -ne `wc -c <'vim/src/proto/quickfix.pro'`; then
    echo shar: \"'vim/src/proto/quickfix.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/quickfix.pro'
# end of 'vim/src/proto/quickfix.pro'
fi
if test -f 'vim/src/proto/regexp.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/regexp.pro'\"
else
echo shar: Extracting \"'vim/src/proto/regexp.pro'\" \(171 characters\)
sed "s/^X//" >'vim/src/proto/regexp.pro' <<'END_OF_FILE'
X/* regexp.c */
Xstruct regexp *regcomp __PARMS((char *exp));
Xint regexec __PARMS((struct regexp *prog, char *string, int at_bol));
Xchar *cstrchr __PARMS((char *s, int c));
END_OF_FILE
if test 171 -ne `wc -c <'vim/src/proto/regexp.pro'`; then
    echo shar: \"'vim/src/proto/regexp.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/regexp.pro'
# end of 'vim/src/proto/regexp.pro'
fi
if test -f 'vim/src/proto/regsub.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/regsub.pro'\"
else
echo shar: Extracting \"'vim/src/proto/regsub.pro'\" \(156 characters\)
sed "s/^X//" >'vim/src/proto/regsub.pro' <<'END_OF_FILE'
X/* regsub.c */
Xchar *regtilde __PARMS((char *source, int magic));
Xint regsub __PARMS((struct regexp *prog, char *source, char *dest, int copy, int magic));
END_OF_FILE
if test 156 -ne `wc -c <'vim/src/proto/regsub.pro'`; then
    echo shar: \"'vim/src/proto/regsub.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/regsub.pro'
# end of 'vim/src/proto/regsub.pro'
fi
if test -f 'vim/src/proto/screen.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/screen.pro'\"
else
echo shar: Extracting \"'vim/src/proto/screen.pro'\" \(634 characters\)
sed "s/^X//" >'vim/src/proto/screen.pro' <<'END_OF_FILE'
X/* screen.c */
Xvoid updateline __PARMS((void));
Xvoid updateScreen __PARMS((int type));
Xvoid comp_Botline __PARMS((void));
Xint prt_line __PARMS((char *s));
Xvoid screenclear __PARMS((void));
Xvoid cursupdate __PARMS((void));
Xvoid curs_columns __PARMS((int scroll));
Xint getvcol __PARMS((struct fpos *pos, int type));
Xvoid scrolldown __PARMS((long nlines));
Xvoid scrollup __PARMS((long nlines));
Xint s_ins __PARMS((int row, int nlines, int invalid));
Xint s_del __PARMS((int row, int nlines, int invalid));
Xvoid showmode __PARMS((void));
Xvoid delmode __PARMS((void));
Xvoid showruler __PARMS((int always));
Xvoid clear_line __PARMS((void));
END_OF_FILE
if test 634 -ne `wc -c <'vim/src/proto/screen.pro'`; then
    echo shar: \"'vim/src/proto/screen.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/screen.pro'
# end of 'vim/src/proto/screen.pro'
fi
if test -f 'vim/src/proto/script.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/script.pro'\"
else
echo shar: Extracting \"'vim/src/proto/script.pro'\" \(352 characters\)
sed "s/^X//" >'vim/src/proto/script.pro' <<'END_OF_FILE'
X/* script.c */
Xvoid startscript __PARMS((void));
Xint stopscript __PARMS((void));
Xint openscript __PARMS((char *name));
Xvoid updatescript __PARMS((int c));
Xvoid openrecover __PARMS((void));
Xvoid scriptfullpath __PARMS((void));
Xchar *modname __PARMS((char *fname, char *ext));
Xvoid script_winsize __PARMS((void));
Xvoid script_winsize_pp __PARMS((void));
END_OF_FILE
if test 352 -ne `wc -c <'vim/src/proto/script.pro'`; then
    echo shar: \"'vim/src/proto/script.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/script.pro'
# end of 'vim/src/proto/script.pro'
fi
if test -f 'vim/src/proto/search.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/search.pro'\"
else
echo shar: Extracting \"'vim/src/proto/search.pro'\" \(727 characters\)
sed "s/^X//" >'vim/src/proto/search.pro' <<'END_OF_FILE'
X/* search.c */
Xstruct regexp *myregcomp __PARMS((char *pat));
Xint searchit __PARMS((struct fpos *pos, int dir, char *str, long count, int end));
Xint dosearch __PARMS((int dirc, char *str, int reverse, long count, int echo));
Xint searchc __PARMS((int c, int dir, int type, long count));
Xstruct fpos *showmatch __PARMS((void));
Xint findfunc __PARMS((int dir, int what, long count));
Xint findsent __PARMS((int dir, long count));
Xint findpar __PARMS((int dir, long count, int what));
Xint startPS __PARMS((long lnum, int para));
Xint fwd_word __PARMS((long count, int type, int eol));
Xint bck_word __PARMS((long count, int type));
Xint end_word __PARMS((long count, int type, int stop));
Xint skip_chars __PARMS((int class, int dir));
END_OF_FILE
if test 727 -ne `wc -c <'vim/src/proto/search.pro'`; then
    echo shar: \"'vim/src/proto/search.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/search.pro'
# end of 'vim/src/proto/search.pro'
fi
if test -f 'vim/src/proto/storage.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/storage.pro'\"
else
echo shar: Extracting \"'vim/src/proto/storage.pro'\" \(739 characters\)
sed "s/^X//" >'vim/src/proto/storage.pro' <<'END_OF_FILE'
X/* storage.c */
Xchar *m_blockalloc __PARMS((unsigned long size, int message));
Xvoid m_blockfree __PARMS((void));
Xvoid free_line __PARMS((char *ptr));
Xchar *alloc_line __PARMS((unsigned int size));
Xchar *save_line __PARMS((char *src));
Xvoid filealloc __PARMS((void));
Xvoid freeall __PARMS((void));
Xchar *nr2ptr __PARMS((long nr));
Xchar *pos2ptr __PARMS((struct fpos *pos));
Xchar *Curpos2ptr __PARMS((void));
Xvoid setmarked __PARMS((long lnum));
Xlong firstmarked __PARMS((void));
Xvoid clearmarked __PARMS((void));
Xlong ptr2nr __PARMS((char *ptr, long start));
Xint appendline __PARMS((long after, char *s));
Xchar *delsline __PARMS((long nr, int delmarks));
Xchar *replaceline __PARMS((long lnum, char *new));
Xint canincrease __PARMS((int n));
END_OF_FILE
if test 739 -ne `wc -c <'vim/src/proto/storage.pro'`; then
    echo shar: \"'vim/src/proto/storage.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/storage.pro'
# end of 'vim/src/proto/storage.pro'
fi
if test -f 'vim/src/proto/tag.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/tag.pro'\"
else
echo shar: Extracting \"'vim/src/proto/tag.pro'\" \(187 characters\)
sed "s/^X//" >'vim/src/proto/tag.pro' <<'END_OF_FILE'
X/* tag.c */
Xvoid dotag __PARMS((char *tag, int type, int count));
Xvoid clrtags __PARMS((void));
Xvoid incrtags __PARMS((void));
Xvoid decrtags __PARMS((void));
Xvoid dotags __PARMS((void));
END_OF_FILE
if test 187 -ne `wc -c <'vim/src/proto/tag.pro'`; then
    echo shar: \"'vim/src/proto/tag.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/tag.pro'
# end of 'vim/src/proto/tag.pro'
fi
if test -f 'vim/src/proto/term.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/term.pro'\"
else
echo shar: Extracting \"'vim/src/proto/term.pro'\" \(849 characters\)
sed "s/^X//" >'vim/src/proto/term.pro' <<'END_OF_FILE'
X/* term.c */
Xvoid set_term __PARMS((char *term));
Xchar *tgoto __PARMS((char *cm, int x, int y));
Xvoid termcapinit __PARMS((char *term));
Xvoid flushbuf __PARMS((void));
Xvoid outchar __PARMS((unsigned int c));
Xvoid outstrn __PARMS((char *s));
Xvoid outstr __PARMS((char *s));
Xvoid windgoto __PARMS((int row, int col));
Xvoid setcursor __PARMS((void));
Xvoid ttest __PARMS((int pairs));
Xint inchar __PARMS((char *buf, int maxlen, int time));
Xint check_termcode __PARMS((char *buf));
Xvoid outnum __PARMS((long n));
Xint outnuml __PARMS((long n));
Xvoid check_winsize __PARMS((void));
Xvoid set_winsize __PARMS((int width, int height, int mustset));
Xvoid set_winheight __PARMS((int height));
Xvoid settmode __PARMS((int raw));
Xvoid starttermcap __PARMS((void));
Xvoid stoptermcap __PARMS((void));
Xvoid cursor_on __PARMS((void));
Xvoid cursor_off __PARMS((void));
END_OF_FILE
if test 849 -ne `wc -c <'vim/src/proto/term.pro'`; then
    echo shar: \"'vim/src/proto/term.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/term.pro'
# end of 'vim/src/proto/term.pro'
fi
if test -f 'vim/src/proto/termlib.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/termlib.pro'\"
else
echo shar: Extracting \"'vim/src/proto/termlib.pro'\" \(300 characters\)
sed "s/^X//" >'vim/src/proto/termlib.pro' <<'END_OF_FILE'
X/* termlib.c */
Xint tgetent __PARMS((char *tbuf, char *term));
Xint tgetflag __PARMS((char *id));
Xint tgetnum __PARMS((char *id));
Xchar *tgetstr __PARMS((char *id, char **buf));
Xchar *tgoto __PARMS((char *cm, int col, int line));
Xint tputs __PARMS((char *cp, int affcnt, void (*outc)(unsigned int)));
END_OF_FILE
if test 300 -ne `wc -c <'vim/src/proto/termlib.pro'`; then
    echo shar: \"'vim/src/proto/termlib.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/termlib.pro'
# end of 'vim/src/proto/termlib.pro'
fi
if test -f 'vim/src/proto/undo.pro' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/proto/undo.pro'\"
else
echo shar: Extracting \"'vim/src/proto/undo.pro'\" \(444 characters\)
sed "s/^X//" >'vim/src/proto/undo.pro' <<'END_OF_FILE'
X/* undo.c */
Xint u_saveCurpos __PARMS((void));
Xint u_save __PARMS((long top, long bot));
Xint u_savesub __PARMS((long lnum));
Xint u_inssub __PARMS((long lnum));
Xint u_savedel __PARMS((long lnum, long nlines));
Xvoid u_undo __PARMS((int count));
Xvoid u_redo __PARMS((int count));
Xvoid u_sync __PARMS((void));
Xvoid u_clearall __PARMS((void));
Xvoid u_saveline __PARMS((long lnum));
Xvoid u_clearline __PARMS((void));
Xvoid u_undoline __PARMS((void));
END_OF_FILE
if test 444 -ne `wc -c <'vim/src/proto/undo.pro'`; then
    echo shar: \"'vim/src/proto/undo.pro'\" unpacked with wrong size!
fi
chmod +x 'vim/src/proto/undo.pro'
# end of 'vim/src/proto/undo.pro'
fi
if test -f 'vim/src/ptx_stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/ptx_stdlib.h'\"
else
echo shar: Extracting \"'vim/src/ptx_stdlib.h'\" \(955 characters\)
sed "s/^X//" >'vim/src/ptx_stdlib.h' <<'END_OF_FILE'
X/*
X * ptx_stdlib.h: declarations which are needed for sequent
X */
X
Xextern void free(void *);
X#ifdef SIZE_T /* sys/types.h */
Xextern void *malloc(size_t);
Xextern off_t lseek(int, off_t, int);
X#else
Xextern void *malloc(unsigned);
Xextern int lseek(int, int, int);
X#endif
X
X#ifndef _FCNTL_H_
Xextern int open(char *, int, ...);
X#endif
Xextern int close(int);
Xextern int read(int, char *, unsigned);
Xextern int write(int, char *, unsigned);
Xextern int ioctl(int, int, ...);
Xextern int unlink(char *);
X
Xextern char *getenv(char *);
Xextern int getuid(void);
Xextern int getgid(void);
X
X#ifdef _NFILE /* stdio.h */
Xextern int _filbuf(FILE *);
Xextern int _flsbuf(unsigned char, FILE *);
X#endif
X
X#ifdef _POLL_H_
Xextern int poll(struct pollfd[], unsigned long, int);
X#endif /* _POLL_H_ */
X
Xextern char *getcwd(char *, int);
X
Xextern int chdir(char *);
X
Xextern int atoi (char *);
Xextern long atol(char *);
Xextern long strtol(char *, char **, int);
X
Xextern int isatty(int);
END_OF_FILE
if test 955 -ne `wc -c <'vim/src/ptx_stdlib.h'`; then
    echo shar: \"'vim/src/ptx_stdlib.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/ptx_stdlib.h'
# end of 'vim/src/ptx_stdlib.h'
fi
if test -f 'vim/src/regexp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regexp.h'\"
else
echo shar: Extracting \"'vim/src/regexp.h'\" \(1541 characters\)
sed "s/^X//" >'vim/src/regexp.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * Definitions etc. for regexp(3) routines.
X *
X * Caveat:	this is V8 regexp(3) [actually, a reimplementation thereof],
X * not the System V one.
X */
X
X#ifndef _REGEXP_H
X#define _REGEXP_H
X
X#define NSUBEXP  10
Xtypedef struct regexp {
X	char		   *startp[NSUBEXP];
X	char		   *endp[NSUBEXP];
X	char			regstart;	/* Internal use only. */
X	char			reganch;	/* Internal use only. */
X	char		   *regmust;	/* Internal use only. */
X	int 			regmlen;	/* Internal use only. */
X	char			program[1]; /* Unwarranted chumminess with compiler. */
X}				regexp;
X
X/* regexp.c */
Xregexp *regcomp __ARGS((char *));
Xint regexec __ARGS((regexp *, char *, int));
X/* int cstrncmp __ARGS((char *, char *, int)); */
Xchar *cstrchr __ARGS((char *, int));
X
X/* regsub.c */
Xint regsub __ARGS((regexp *, char *, char *, int, int));
X
X/* search.c */
Xextern void 	regerror __ARGS((char *));
X
X#ifndef ORIGINAL
Xextern int		reg_ic; 		/* set non-zero to ignore case in searches */
Xextern int		reg_magic;		/* set zero to disable magicness of .*[~& */
X#endif
X#endif	/* _REGEXP_H */
END_OF_FILE
if test 1541 -ne `wc -c <'vim/src/regexp.h'`; then
    echo shar: \"'vim/src/regexp.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/regexp.h'
# end of 'vim/src/regexp.h'
fi
if test -f 'vim/src/regmagic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regmagic.h'\"
else
echo shar: Extracting \"'vim/src/regmagic.h'\" \(663 characters\)
sed "s/^X//" >'vim/src/regmagic.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * The first byte of the regexp internal "program" is actually this magic
X * number; the start node begins in the second byte.
X */
X
X#define MAGIC	0234
END_OF_FILE
if test 663 -ne `wc -c <'vim/src/regmagic.h'`; then
    echo shar: \"'vim/src/regmagic.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/regmagic.h'
# end of 'vim/src/regmagic.h'
fi
if test -f 'vim/src/sun_stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/sun_stdlib.h'\"
else
echo shar: Extracting \"'vim/src/sun_stdlib.h'\" \(1868 characters\)
sed "s/^X//" >'vim/src/sun_stdlib.h' <<'END_OF_FILE'
X/*
X * sun_stdlib.h: declararions used on a sun
X */
X
X#ifndef __stdlib_h
Xextern void free(void *);
Xextern void *malloc(unsigned);
Xextern void *realloc(void *, unsigned);
Xextern void *calloc(unsigned, unsigned);
X#endif
X#ifdef __sys_types_h
Xextern off_t lseek(int, off_t, int);
X
X# ifdef _sys_time_h
Xextern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
X# endif _sys_time_h
X
X#else
Xextern long lseek(int, long, int);
X#endif
X
Xextern long tell(int);
Xextern void perror(char *);
X
X#ifndef __sys_fcntlcom_h
Xextern int open(char *, int, ...);
X#endif
Xextern int close(int);
Xextern int read(int, char *, unsigned);
Xextern int write(int, char *, unsigned);
Xextern int ioctl(int, int, ...);
Xextern int unlink(char *);
X
X#ifdef FILE
Xextern int _filbuf(FILE *);
Xextern int _flsbuf(unsigned char, FILE *);
Xextern int fclose(FILE *);
Xextern int fprintf(FILE *, char *, ...);
Xextern int fscanf(FILE *, char *, ...);
Xextern int fseek(FILE *, long, int);
Xextern int fflush(FILE *);
Xextern int fread(char *, int, int, FILE *);
X#else
Xextern char *sprintf(char *, char *, ...);
X#endif
X
Xextern int printf(char *, ...);
X
Xextern int scanf(char *, ...);
Xextern int sscanf(char *, char *, ...);
X
Xextern int system(char *);
Xextern char *getenv(char *);
X
Xextern char *getcwd(char *, int);
Xextern char *getwd(char *);
X
Xextern int chdir(char *);
Xextern int getuid(void);
Xextern int getgid(void);
X
Xextern int atoi (char *);
Xextern long atol(char *);
Xextern long strtol(char * , char **, int);
X
Xextern void bcopy(char *, char *, int);
Xextern int bcmp(char *, char *, int);
Xextern void bzero(char *, int);
X
Xextern char *memccpy(char *, char *, int, int);
Xextern char *memchr(char *, int, int);
Xextern char *memset(char *, int, int);
X
Xextern int strncmp(char *, char *, int);
Xextern int strcasecmp(char *, char *);
X
Xextern int toupper(int);
Xextern int tolower(int);
Xextern int isatty(int);
END_OF_FILE
if test 1868 -ne `wc -c <'vim/src/sun_stdlib.h'`; then
    echo shar: \"'vim/src/sun_stdlib.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/sun_stdlib.h'
# end of 'vim/src/sun_stdlib.h'
fi
if test -f 'vim/src/term_fix.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/term_fix.uue'\"
else
echo shar: Extracting \"'vim/src/term_fix.uue'\" \(89 characters\)
sed "s/^X//" >'vim/src/term_fix.uue' <<'END_OF_FILE'
X
Xbegin 644 termlib.fix
XB#2]O=71C*2@I#6QL;&QL875N<VEG;F5D(&EN=!LZ=W$-"O__5
X``
Xend
Xsize 34
END_OF_FILE
if test 89 -ne `wc -c <'vim/src/term_fix.uue'`; then
    echo shar: \"'vim/src/term_fix.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/src/term_fix.uue'
# end of 'vim/src/term_fix.uue'
fi
if test -f 'vim/src/vim.prj' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vim.prj'\"
else
echo shar: Extracting \"'vim/src/vim.prj'\" \(254 characters\)
sed "s/^X//" >'vim/src/vim.prj' <<'END_OF_FILE'
XALLOC.C
XBUFFERS.C
XCHARSET.C
XCMDLINE.C
XCSEARCH.C
XEDIT.C
XDIGRAPH.C
XFILEIO.C
XHELP.C
XLINEFUNC.C
XMAIN.C
XMARK.C
XMESSAGE.C
XMISCCMDS.C
XMSDOS.C
XNORMAL.C
XOPS.C
XPARAM.C
XQUICKFIX.C
XREGEXP.C
XREGSUB.C
XSCREEN.C
XSCRIPT.C
XSEARCH.C
XSTORAGE.C
XTAG.C
XTERM.C
XUNDO.C
XVERSION.C
END_OF_FILE
if test 254 -ne `wc -c <'vim/src/vim.prj'`; then
    echo shar: \"'vim/src/vim.prj'\" unpacked with wrong size!
fi
chmod +x 'vim/src/vim.prj'
# end of 'vim/src/vim.prj'
fi
if test -f 'vim/src/vimresp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/vimresp'\"
else
echo shar: Extracting \"'vim/src/vimresp'\" \(320 characters\)
sed "s/^X//" >'vim/src/vimresp' <<'END_OF_FILE'
Xalloc.obj msdos.obj buffers.obj charset.obj cmdline.obj csearch.obj +
Xdigraph.obj edit.obj fileio.obj help.obj linefunc.obj main.obj mark.obj +
Xmessage.obj misccmds.obj normal.obj ops.obj param.obj quickfix.obj +
Xregexp.obj regsub.obj screen.obj script.obj search.obj storage.obj +
Xtag.obj term.obj undo.obj version.obj
END_OF_FILE
if test 320 -ne `wc -c <'vim/src/vimresp'`; then
    echo shar: \"'vim/src/vimresp'\" unpacked with wrong size!
fi
chmod +x 'vim/src/vimresp'
# end of 'vim/src/vimresp'
fi
if test ! -d 'vim/tutor' ; then
    echo shar: Creating directory \"'vim/tutor'\"
    mkdir 'vim/tutor'
fi
if test -f 'vim/tutor/Readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/tutor/Readme'\"
else
echo shar: Extracting \"'vim/tutor/Readme'\" \(768 characters\)
sed "s/^X//" >'vim/tutor/Readme' <<'END_OF_FILE'
XVitutor is a "hands on" tutorial for new users of the Vim editor.
X
XMost new users can get through it in less than one hour.  The result
Xis that you can do a simple editing task using the Vim editor.
X
XTutor is a file that contains the tutorial lessons.  You can simply
Xexecute "vim tutor" and then follow the instructions in the lessons.
XThe lessons tell you to modify the file, so DON'T DO THIS ON YOUR
XORIGINAL COPY.
X
XI have considered adding more advanced lessons but have not found the
Xtime.  Please let me know how you like it and send any improvements you
Xmake.
X
XBob Ware, Colorado School of Mines, Golden, Co 80401, USA
X(303) 273-3987
Xbware@mines.colorado.edu bware@slate.mines.colorado.edu bware@mines.bitnet
X
X(This file was modified by Bram Moolenaar for Vim)
END_OF_FILE
if test 768 -ne `wc -c <'vim/tutor/Readme'`; then
    echo shar: \"'vim/tutor/Readme'\" unpacked with wrong size!
fi
chmod +x 'vim/tutor/Readme'
# end of 'vim/tutor/Readme'
fi
if test -f 'vim/tutor/poster' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/tutor/poster'\"
else
echo shar: Extracting \"'vim/tutor/poster'\" \(860 characters\)
sed "s/^X//" >'vim/tutor/poster' <<'END_OF_FILE'
XArticle 3390 of alt.sources:
XXref: oce-rd1 comp.editors:3231 alt.sources:3390
XPath: oce-rd1!venlo!hp4nl!mcsun!uunet!zaphod.mps.ohio-state.edu!magnus.acs.ohio-state.edu!csn!pikes!slate!bware
XFrom: bware@slate.mines.colorado.edu (Ware Bob)
XNewsgroups: comp.editors,alt.sources
XSubject: hands on vi tutor
XKeywords: for new users
XMessage-ID: <1991Jul17.161355.15677@slate.mines.colorado.edu>
XDate: 17 Jul 91 16:13:55 GMT
XSender: bware@slate.mines.colorado.edu (Ware Bob)
XOrganization: Colorado School of Mines
XLines: 830
X
X
XI posted this a few weeks ago, but a number of people have munged 
Xtheir copy, so I am reposting it with better instructions.
X
XThis is a "hand-on" tutor to help new users learn the vi editor.
X
XBob Ware, Colorado School of Mines, Golden, Co 80401, USA
X(303) 273-3987
Xbware@mines.colorado.edu bware@slate.mines.colorado.edu bware@mines.bitnet
END_OF_FILE
if test 860 -ne `wc -c <'vim/tutor/poster'`; then
    echo shar: \"'vim/tutor/poster'\" unpacked with wrong size!
fi
chmod +x 'vim/tutor/poster'
# end of 'vim/tutor/poster'
fi
echo shar: End of archive 1 \(of 25\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
