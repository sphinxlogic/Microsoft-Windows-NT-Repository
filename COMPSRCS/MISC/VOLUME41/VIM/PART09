Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i059:  vim - Vi IMitation editor, v2.0, Part09/25
Message-ID: <1993Dec21.034804.27892@sparky.sterling.com>
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:48:04 GMT
Approved: kent@sparky.sterling.com
X-Md4-Signature: b7b0e75396a9957c8e59d1c13a5a8dc1

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 59
Archive-name: vim/part09
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 25)."
# Contents:  vim/doc/index vim/src/tags
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/index' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/index'\"
else
echo shar: Extracting \"'vim/doc/index'\" \(21291 characters\)
sed "s/^X//" >'vim/doc/index' <<'END_OF_FILE'
Xindex of vim commands for
X 1. insert mode
X 2. VI commands (normal mode)
X 3. command line editing
X 4. EX commands
X
X(for an overview of options see the end of reference.doc)
X
X1. INSERT MODE
X==============
X
Xchar		action
X-----------------------------------------------------------------------
X^@		insert previously inserted text and stop insert {vi: up to 128
X		chars}
X^A		insert previously inserted text {not in Vi}
X^D		delete one shiftwidth of indent in the current line {vi: 
X		only after auto-indent}
X		when preceded with <0> or <^>, delete all indent, with <^>
X		restore it in the next line
X^E		insert the character which is below the cursor
X^H <BS>		delete character before the cursor {vi: does not cross lines,
X		does not delete autoindents}
X^J <LF>		begin new line
X^K {char1} {char2} enter digraph (only when compiled with it) {vi: no digraphs}
X^M <CR>		begin new line
X^O		execute a single command and return to insert mode
X^P		toggle 'revins' option.
X^R <0-9a-z>	insert contents of register <0-9a-z> {not in vi}
X^T		insert one shiftwidth of indent in current line {vi: only in 
X		autoindent}
X^U		delete all entered characters in the current line
X^V		insert next non-digit literally, insert three digit decimal 
X		number as a single byte.
X^W		delete word before the cursor
X^Y		insert the character which is above the cursor
X^[ <ESC>	end insert mode
X<DEL>		same as ^H <BS>
X<C_UP>		cursor one line up
X<C_DOWN>	cursor one line down
X<C_LEFT>	cursor one character left
X<C_RIGHT>	cursor one character right
X<SC_UP>		one screenfull backward
X<SC_DOWN>	one screenfull forward
X<SC_LEFT>	cursor one word left
X<SC_RIGHT>	cursor one word right
X{char1}<BS>{char2} enter digraph (only when compiled with it and 'digraph' 
X		option set) {vi: no digraphs}
X
X
X2. VI COMMANDS
X==============
X
XCHAR means non-blank char
XWORD means sequences of non-blank chars
XN is number entered before the command
X<move> is a cursor movement command
XNmove is the text that is moved over with a cursor movement command
XSECTION is a section that possibly starts with '}' instead of '{'
X
Xnote: 1 = cursor movement command; 2 = can be undone/redone
X
Xchar		note	vim normal mode (vi: what the unix vi does)
X------------------------------------------------------------------------------
X^@			error
X^A		2	add N to number at/after cursor {vi: no ^A}
X^B		1	scroll N screens Backwards
X^C			interrupt current (search) command
X^D			scroll Down N lines (default: half a screen)
X^E			scroll N lines upwards (N lines Extra)
X^F		1	scroll N screens Forward
X^G			display current file name and position
X^H <BS>		1	cursor N chars to the left
X^I <TAB>	1	go to N newer entry in jump list
X^J <LF>		1	cursor N lines downward
X^K			error
X^L			redraw screen
X^M <CR>		1	cursor to the first CHAR N lines lower
X^N		1	cursor N lines downward
X^O		1	go to N older entry in jump list
X^P		1	cursor N lines upward
X^V			start blockwise Visual (vi: no Visual)
X^R		2	redo changes which were undone with 'u' (vi: retype
X			the screen)
X^S		2	subtract N from number at/after cursor {vi: no ^S}
X^T			jump to N older Tag in tag list
X^U			scroll N lines Upwards (default: half a screen)
X^V			error
X^W			error
X^X			error
X^Y			scroll N lines downwards
X^Z			suspend program (or start new shell)
X^[ <ESC>		error
X^\			error
X^]			:ta to ident under cursor
X^^			edit Nth alternate file (equivalent to :e #N)
X^_			error
X
X<SPACE>		1	cursor N chars to the right
X!<move><filter>		filter Nmove text through the "filter" command
X!!<filter>		filter N lines through the "filter" command
X"<a-zA-Z0-9.>		use buffer <a-zA-Z0-9.> for next delete, yank or put
X			(upper case to append)(<.> only works for put)
X#		1	search backward for the Nth occurrence of the ident under
X			the cursor {not in vi}
X$		1	cursor to the end of line N from the cursor
X%		1	find the next (curly/square) bracket on this line and go
X			to its match. With count: go to N percentage in the file.
X&		2	repeat last :s
X'<a-zA-Z>	1	cursor to the first CHAR on the line with mark <a-zA-Z>
X'[		1	cursor to the first CHAR on the line of the start of 
X			last operated text or start of putted text
X']		1	cursor to the first CHAR on the line of the end of 
X			last operated text or end of putted text
X''		1	cursor to the first CHAR of the line where the cursor was
X			before the latest jump.
X(		1	cursor N sentences backward
X)		1	cursor N sentences forward
X*		1	search forward for the Nth occurrence of the ident under
X			the cursor {not in vi}
X+		1	cursor to the first CHAR N lines lower
X,		1	repeat latest f, t, F or T in opposite direction N times
X-		1	cursor to the first CHAR N lines higher
X.		2	repeat last change with count replaced by N
X/<pattern>	1	search forward for the Nth occurrence of <pattern>
X0		1	cursor to the first char of the line
X1			prepend to command to give a count
X2			"
X3			"
X4			"
X5			"
X6			"
X7			"
X8			"
X9			"
X:			Ex command (see below)		
X;		1	repeat latest f, t, F or T N times
X<<move>		2	shift the Nmove lines one shiftwidth leftwards
X<<		2	shift N lines one shiftwidth leftwards
X=<move>		2	filter Nmove lines through "indent" (vi: when option
X			'lisp' is set autoindent Nmove lines)
X==		2	filter N lines through "indent"
X><move>		2	shift Nmove lines one shiftwidth rightwards
X>>		2	shift N lines one shiftwidth rightwards
X?<pattern>	1	search backward for the Nth previous occurrence of
X			<pattern>
X@<a-z>		2	execute the contents of named buffer <a-z> N times
X@@		2	repeat the previous @<a-z> N times
XA		2	append text at the end of the line N times
XB		1	cursor N WORDS backward
X<"x>C		2	change from the cursor position to the end of the line,
X			and N-1 more lines [into buffer x]; synonym for c$
X<"x>D		2	delete the characters under the cursor until the end of
X			the line and N-1 more lines [into buffer x]; synonym for d$
XE		1	cursor forward to the end of WORD N
XF<char>			cursor to the Nth occurrence of <char> to the left
XG		1	cursor to line N, default last line
XH		1	cursor to line N from top of screen
XI		2	insert text before the first CHAR on the line N times
XJ		2	Join N lines; default is 2
XK			lookup Keyword under the cursor with "keywordprg"
XL		1	cursor to line N from bottom of screen
XM		1	cursor to middle line of screen
XN		1	repeat the latest '/' or '?' N times in opposite
X			direction
XO		2	begin a new line above the cursor and insert text, repeat
X			N times (vi: blank N screen lines)
X<"x>P		2	put the text [from buffer x] before the cursor N times
XV			start Visual mode on lines (vi: go to Ex mode)
XR		2	enter replace mode: overtype existing characters, repeat the
X			entered text N-1 times
X<"x>S		2	delete N lines [into buffer x] and start insert; synonym
X			for ^cc or 0cc, depending on autoindent
XT<char>		1	cursor till after Nth occurrence of <char> to the left
XU		2	undo all latest changes on one line (vi: while not moved
X			off of it)
X			While in Visual mode: make uppercase
XQ<move>		2	Join N lines and re-format them
XW		1	cursor N WORDS forward
X<"x>X		2	delete N characters before the cursor [into buffer x]
X<"x>Y			yank N lines [into buffer x]; synonym for yy
XZZ			store current file, if modified, and exit		
X[[		1	cursor N sections backward
X[]		1	cursor N SECTIONS backward
X\			error
X]]		1	cursor N sections forward
X][		1	cursor N SECTIONS forward
X^		1	cursor to the first CHAR of the line
X_		1	cursor to the first CHAR N - 1 lines lower
X`<a-zA-Z>	1	cursor to the mark <a-zA-Z>
X`[		1	cursor to the start of last operated text or start of 
X			putted text
X`]		1	cursor to the end of last operated text or end of 
X			putted text
X``		1	cursor to the position before latest jump
Xa		2	append text after the cursor N times
Xb		1	cursor N words backward
X<"x>c<move>	2	delete Nmove text [into buffer x] and start insert
X<"x>cc		2	delete N lines [into buffer x] and start insert
X<"x>d<move>	2	delete Nmove text [into buffer x]
X<"x>dd		2	delete N lines [into buffer x]
Xe		1	cursor forward to the end of word N
Xf<char>		1	cursor to Nth occurrence of <char> to the right
Xg			error
Xh		1	cursor N chars to the left
Xi		2	insert text before the cursor N times
Xj		1	cursor N lines downward
Xk		1	cursor N lines upward
Xl		1	cursor N chars to the right
Xm<a-z>			set mark <a-z> at cursor position		
Xn		1	repeat the latest '/' or '?' N times
Xo		2	begin a new line below the cursor and insert text, repeat
X			N times (vi: blank N screen lines)
X			While Visual: cursor moves other end
X<"x>p		2	put the text [from buffer x] after the cursor N times
Xv			start Visual mode with characters (vi: no Visual)
Xr<char>		2	replace N chars by <char>
X<"x>s		2	(substitute) delete N characters [into buffer x] and
X			start insert
Xt<char>		1	cursor till before Nth occurrence of <char> to the right
Xu		2	undo changes (vi: only one level)
X			With Visual: make lowercase (vi: no Visual)
Xq<a-zA-Z>		record typed characters into named buffer <a-zA-Z>
X			(upper case to append)
Xq			stops recording (vi: no recording)
Xw		1	cursor N words forward
X<"x>x		2	delete N characters under and after the cursor [into
X			buffer x]
X<"x>y<move>		yank Nmove text [into buffer x]
X<"x>yy			yank N lines [into buffer x]
Xz<CR>			redraw, cursor line to top of window		
Xz.			redraw, cursor line to center of window
Xz-			redraw, cursor line at bottom of window
X{		1	cursor N paragraphs backward
X|		1	cursor to column N
X}		1	cursor N paragraphs forward
X~		2	option notildeop: switch case of N characters under
X			cursor and move the cursor N characters to the right
X			(vi: no count)
X~<move>			option tildeop: switch case of Nmove text (vi: no tildeop
X			option)
X<DEL>			when entering a number: remove the last digit
X<HELP>			show the file vim:vim.hlp page by page (vi: no help)
X<C_UP>		1	move cursor N lines upwards
X<C_DOWN>	1	move cursor N lines downwards
X<C_LEFT>	1	move cursor N chars to the left
X<C_RIGHT>	1	move cursor N chars to the right
X<SC_UP>		1	scroll N screens Backwards (same as ^B)
X<SC_DOWN>	1	scroll N screens Forwards (same as ^F)
X<SC_LEFT>	1	cursor N words backward (same as b)
X<SC_RIGHT>	1	cursor N words forward (same as w)
X
X
X3. command line editing
X=======================
X
XGet to the command line with the ':', '!', '/' or '?' commands.
XNormal characters are inserted at the current cursor position.
X(vi: can only alter last character in the line)
X
X^A		do filename completion on the pattern in front of the cursor
X		and insert all matches
X^B		cursor to begin of command line
X^D		list filenames that match the pattern in front of the cursor
X^E		cursor to end of command line
X^H		delete the character in front of the cursor
X^L		do filename completion on the pattern in front of the cursor
X		and insert the longest common part
X^N		after an <ESC> with multiple matches: go to next match
X		otherwise: same as <C_DOWN>
X^P		after an <ESC> with multiple matches: go to previous match
X		otherwise: same as <C_UP>
X^U		remove all characters
X^V		insert next non-digit literally, insert three digit decimal 
X		number as a single byte. {Vi: type the CTRL-V twice to get one}
X^W		delete the word in front of the cursor
X'wildchar' option (default <TAB>)
X		do filename completion on the pattern in front of the cursor
X<DEL>		delete the character under the cursor
X<C_UP>		recall previous command line from history
X<C_DOWN>	recall next command line from history
X<C_LEFT>	cursor left
X<C_RIGHT>	cursor right
X<SC_LEFT>	cursor one word left
X<SC_RIGHT>	cursor one word right
X<SC_UP>		recall previous command line that matches pattern in front of
X		the cursor
X<SC_DOWN>	recall next command line that matches pattern in front of the
X		cursor
X
X
X4. EX commands
X==============
X
Xlines that start with " or # are ignored
X
X<range> stands for a series of line specifiers, separated with ',' or ';'.
XWhen separated with ';' the cursor position will be set to that line before
Xinterpreting the next line specifier.
XThe default line specifier (for most commands) is the Cursor position.
Xline numbers may be specified with:
X	<number>	the absolute line number
X	.		the current line
X	$		the last line in the file
X	%		equal to 1,$ (the entire file)
X	't		position of mark t
X	/<pattern>	the next line where <pattern> matches
X	?<pattern>	the previous line where <pattern> matches
XEach may be followed (several times) by '+' or '-' and an optional number.
XThis number is added or subtracted from the preceding line number.
Xif the number is omitted, 1 is used.
XExamples:
X	.+3		three lines below the cursor
X	/that+1		the line below the next line containing "that"
X	.,$		from current line until end of file
X
XIn the commands below the characters in square brackets are optional.
X
X:<range>		set the cursor on the (last) specified line number
X
X:ab[breviate]		list all abbreviations
X:ab[breviate] <lhs>	list abbreviation for <lhs>
X:ab[breviate] <lhs> <rhs>
X			add <lhs> to the list of abbreviations
X
X:a[ppend]		{vi: append text}
X
X:ar[gs]			print the file list, with the current file in []
X
X:ca[bbrev]		like ":ab", but for command line mode only {not in
X			vi}
X
X:cc [nr]		Display error [nr] (default is same error)
X
X:cd			On non-Unix systems: Print the current directory
X			name. {vi: no cd command}
X:cd			On Unix systems: Change the current directory to the
X			home directory. {vi: no cd command}
X:cd <path>		change the current directory to <path>
X
X:[range]ce[nter] [width] center lines in [range] between [width] columns
X			(default 'textwidth' or 80). {vi: no such command}
X
X:cf			read error file (from errorfile option) and jump to
X			the first error
X
X:c[hange]		{vi: replace lines}
X
X:ch[dir]		same as :cd
X
X:cm[ap]			like :map, but for command line mode only {not in vi}
X
X:cn			display next error
X
X:cno[remap]		like :noremap, but for command line mode only {not in vi}
X
X:cnorea[bbrev] <lhs> <rhs>
X			like ":cab", but no remapping for this <rhs> {not in
X			vi}
X
X:[range]co[py] {address} copy lines from [range] to {address}
X
X:cp			display previous error
X
X:cq			Quit without writing and return an error code
X
X:cu[nmap]		like :unmap, but for command line mode only {not in vi}
X
X:cuna[bbrev]		like ":unab", but for command line mode only {not in
X			vi}
X
X:[<range>]d[elete] [x] [count]
X			delete <range> lines (default: current line)
X
X:dig[raphs]		display currently defined digraphs {not in vi}
X
X:dig[raphs] {char1}{char2} {number} ...
X			define the character pair {char1} {char2} to be the 
X			digraph for character {number}. {number} is entered 
X			as digits.
X
X:di[splay]		display the contents of numbered and named buffers
X			{vi: no such command}
X
X:e[dit] [file]		edit 'file' (default: current file), unless changes have
X			been made {vi: allow +n to start at certain position}
X:e[dit]! [file]		edit 'file' (default: current file) always
X
X:ex			same as :edit
X
X:f[ile]			prints the current file name and some more info
X:f[ile] <name>		sets current file name to <name>
X:files			lists the alternate file names
X
X:<range>g[lobal]/<pattern>/<cmd>
X			execute the EX command <cmd> on the lines where <pattern>
X			matches
X:<range>g[lobal]!/<pattern>/<cmd>
X			execute the EX command <cmd> on the lines where <pattern>
X			does not match
X
X:h[elp]			show the help file page by page {vi: no help}
X
X:ia[bbrev]		like ":ab", but for insert mode only {not in vi}
X
X:i[nsert]		{vi: insert text}
X
X:im[ap]			like :map, but for insert mode only {not in vi}
X
X:ino[remap]		like :noremap, but for insert mode only {not in vi}
X
X:inorea[bbrev] <lhs> <rhs>
X			like ":iab", but no remapping for this <rhs> {not in
X			vi}
X
X:iuna[bbrev]		like ":unab", but for insert mode only {not in vi}
X
X:iu[nmap]		like :unmap, but for insert mode only {not in vi}
X
X:<range>j[oin]		join <range> lines
X
X:ju[mps]		print jump list {vi: no such command}
X
X:[range]k<a-z>		set mark without a space
X
X:[range]le[ft] [indent]	left align lines in [range]. Sets the indent in the
X			lines to [indent] (default 0). {vi: no such command}
X
X:[range]l[ist]		list lines
X
X:mak[e] [arguments]	Run the program given with 'makeprg', with optional
X			[arguments]. The output is saved in the error file.
X			Then the ":cf" command is executed to jump to the
X			first error.
X
X:map <lhs> <rhs>	map the key sequence <lhs> to <rhs> in normal mode
X:map! <lhs> <rhs>	map the key sequence <lhs> to <rhs> in insert mode
X
X:[range]ma[rk] <a-z>	set mark
X
X:marks			list all marks {vi: no such command}
X
X:mk[exrc]		write options to .exrc file
X:mkv[imrc]		write options to .vimrc file {not in vi}
X
X:[range]m[ove] {address} move lines from [range] to {address}
X
X:n[ext]			edit next file, unless changes have been made
X:n[ext]!		edit next file
X:n[ext] <filelist>	define <filelist> as the new list of files and edit
X			the first one, unless changes have been made
X:n[ext]! <filelist>	define <filelist> as the new list of files and edit
X			the first one {vi: +command to start editing at a
X			specified position}
X
X:norea[bbrev] <lhs> <rhs>
X			like ":ab", but no remapping for this <rhs> {not in
X			vi}
X
X:nore[map] <lhs> <rhs>	map the key sequence <lhs> to <rhs> in normal mode, 
X			disallow remapping of <rhs> {not in vi}
X:nore[map]! <lhs> <rhs>	map the key sequence <lhs> to <rhs> in insert mode,
X			disallow remapping of <rhs> {not in vi}
X
X:nu[mber]		{vi: print specified lines with their line number}
X
X:N[ext]			edit previous file in file list, unless changes have
X			been made
X:N[ext]!		edit previous file in file list
X
X:o[pen]			{vi: start editing in open mode}
X
X:[count]po[p][!]	jump to [count] older tag in tag list {vi: no such command}
X
X:pres[erve]		{vi: emergency exit}
X
X:pr[evious]		same as :Next
X
X:<range>p[rint]		print the specified lines
X
X:pu[t] [x]		insert text from buffer [x] below current line
X:pu[t]! [x]		insert text from buffer [x] above current line
X
X:pwd			Print the current directory name. {vi: no such command}
X
X:q[uit] 		quit, unless changes have been made
X:q[uit]!		quit always, without writing
X
X:r[ead] <name>		insert the file <name> below the cursor
X:r[ead]!<cmd>		excute <cmd> and insert its standard output below the
X			cursor
X
X:rec[over]		{vi: recover a file after a crash or :preserve}
X
X:rew[ind]		start editing the first file in the file list, unless
X			changes have been made
X:rew[ind]!		start editing the first file in the file list
X
X:[range]ri[ght] [width] right align lines in [range] at [width] columns
X			(default 'textwidth' or 80). {vi: no such command}
X
X:se[t]			show all modified options {vi: non-default options}
X:se[t] all		show all options
X:se[t] <option>		set toggle option on, show value of string or number
X			option
X:se[t] no<option>	set toggle option off
X:se[t] inv<option>	invert toggle option
X:se[t] <option>=<value> set string or number option to <value>
X:se[t] <option>?	show value of <option>
X
X:sh[ell]		escape to a shell {vi: shell name from option 'shell'}
X
X:so[urce] <file>	read EX commands from <file>
X:so[urce]! <file>	read VI commands from <file> {vi: no such command}
X
X:st[op][!]		suspend the editor
X
X:<range>s[ubstitute]/<pattern>/<string>/<option>
X			for each line in <range> replace the first occurrence of
X			<pattern> by <string>; with <option> 'g' all occurrences
X			on the line are replaced; with <option> 'c' each
X			replace has to be confirmed
X:<range>s[ubstitute]	repeat last :substitute
X
X:sus[pend][!]		suspend the editor
X
X:t			synonym for copy
X
X:ta[g] <ident>		search for <indent> in the tags file and execute
X			the accompanying command, unless changes have been made
X:ta[g]! <ident>		search for <indent> in the tags file and execute
X			the accompanying command
X
X:[count]ta[g][!]	jump to [count] newer tag in tag list {vi: no such command}
X
X:tags			print the tag list {vi: no such command}
X
X:una[bbreviate]	<lhs>	remove <lhs> from abbreviation list
X
X:u[ndo]			undo last change
X
X:unm[ap] <lhs>		remove the mapping of <lhs> for normal mode
X:unm[ap]! <lhs>		remove the mapping of <lhs> for insert mode
X
X:ve[rsion]		print the version number of the editor
X
X:<range>v[global]/<pattern>/<cmd>
X			execute the EX command <cmd> on the lines where <pattern>
X			does not match
X
X:vi[sual]		{vi: switch from EX or open to visual mode}
X
X:wi[nsize] <width> <height>
X			Set effective window size to <width> columns and <height>
X			rows. Does not change actual window size. Should only be
X			used from script files. {vi: no such command}
X
X:<range>w[rite][!]	write the specified lines to the current file
X:<range>w[rite]	<file>	write the specified lines to <file>, unless it
X			already exists
X:<range>w[rite]! <file>	write the specified lines to <file>
X:<range>w[rite][!] >>	append the specified lines to the current file
X:<range>w[rite][!] >> <file>
X			append the specified lines to <file>
X:<range>w[rite] !<cmd>	execute <cmd> with <range> lines as standard input
X
X:wq			write the current file and exit if no more files
X:wq!			write the current file and exit
X:wq <file>		write to <file> and exit if no more files
X:wq! <file>		write to <file> and exit
X
X:x[it][!] [file]	same as :wq, but write only when changes have been made
X
X:y[ank] [x]		copy lines into buffer [x]
X
X:z			{vi: print some lines}
X
X:@<reg>			execute contents of buffer <reg> as an Ex command 
X			{only in some versions of vi}
X
X:@@			repeat last :@<reg> command.
X
X:![!]<cmd> [!][<arg>]	execute <cmd> with the shell, replace the optional bangs
X			with the previously given command, append the optional
X			<arg>
X:<range>![!]<cmd> [!][<arg>]
X			filter <range> lines through <cmd>, replace the optional bangs
X			with the previously given command, append the optional
X			<arg>
X
X:<			shift left
X
X:>			shift right
X
X:=			print the line number
X
X:&			same as :substitute
X
X:~			{vi: do a substitute on the previous regular expression}
END_OF_FILE
if test 21291 -ne `wc -c <'vim/doc/index'`; then
    echo shar: \"'vim/doc/index'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/index'
# end of 'vim/doc/index'
fi
if test -f 'vim/src/tags' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/tags'\"
else
echo shar: Extracting \"'vim/src/tags'\" \(20073 characters\)
sed "s/^X//" >'vim/src/tags' <<'END_OF_FILE'
XAppendCharToRedobuff	buffers.c	/^AppendCharToRedobuff(c)$/
XAppendNumberToRedobuff	buffers.c	/^AppendNumberToRedobuff(n)$/
XAppendToRedobuff	buffers.c	/^AppendToRedobuff(s)$/
XChk_Abort	amiga.c	/^Chk_Abort()$/
XCtrl	ascii.h	/^#define Ctrl(x) ((x) & 0x1f)$/
XCurpos2ptr	storage.c	/^Curpos2ptr()$/
XDoOneCmd	cmdline.c	/^DoOneCmd(buff)$/
XExpandOne	cmdline.c	/^ExpandOne(str, list_notfound, mode)$/
XExpandWildCards	amiga.c	/^ExpandWildCards(num_pat, pat, num_file, file, file/
XFAIL	regexp.c	/^#define FAIL(m) { emsg(m); return NULL; }$/
XFreeWild	amiga.c	/^FreeWild(num, file)$/
XFullName	amiga.c	/^FullName(fname, buf, len)$/
XGetChars	amiga.c	/^GetChars(buf, maxlen, time)$/
XINIT	normal.c	/^#define INIT(x) x$/
XISSPECIAL	edit.c	/^#define ISSPECIAL(c)	((c) < ' ' || (c) >= DEL)$/
XMP	amiga.c	/^#define MP(xx)	((struct MsgPort *)((struct FileHan/
XMaddcr	addcr.c	/^main(argc, argv)$/
XMagic	regexp.c	/^#define Magic(x)	((x)|('\\\\'<<8))$/
XMeta	ascii.h	/^#define Meta(x) ((x) | 0x80)$/
XMmain	main.c	/^main(argc, argv)$/
XMmkcmdtab	mkcmdtab.c	/^main(argc, argv)$/
XNEXT	regexp.c	/^#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&/
XOP	regexp.c	/^#define OP(p)	(*(p))$/
XOPENDEBUG	debug.h	/^#	define OPENDEBUG(file)\\$/
XOPERAND	regexp.c	/^#define OPERAND(p)		((p) + 3)$/
XOpencmd	misccmds.c	/^Opencmd(dir, redraw, delspaces)$/
XPeekChr	regexp.c	/^#define PeekChr() curchr	\/* shortcut only when las/
XRead	unix.c	/^Read(buf, maxlen)$/
XRealWaitForChar	unix.c	/^RealWaitForChar(ticks)$/
XResetRedobuff	buffers.c	/^ResetRedobuff()$/
XSupdatescript	script.c	/^Supdatescript(str)$/
XTO_LOWER	macros.h	/^# define TO_LOWER(c)	(isupper(c) ? tolower(c) : (c/
XTO_UPPER	macros.h	/^# define TO_UPPER(c)	(islower(c) ? toupper(c) : (c/
XTTEST	term.c	/^# define TTEST(a) debug1("%s: ", "a"); if (a) {deb/
XUCHARAT	regexp.c	/^#define UCHARAT(p)		((int)*(unsigned char *)(p))$/
XWaitForChar	msdos.c	/^WaitForChar(msec)$/
X__ARGS	regsub.c	/^# define __ARGS(a)	a$/
X__PARMS	vim.h	/^# define __PARMS(x)	x$/
X_addfmt	termlib.c	/^_addfmt(buf, fmt, val)             \/* add val to b/
X_chdrive	msdos.c	/^_chdrive(drive)$/
X_find	termlib.c	/^_find(s, set)   \/* finds next c in s that's a memb/
X_match	termlib.c	/^_match(s1, s2)                 \/* returns length o/
Xadd_buff	buffers.c	/^add_buff(buf, s)$/
Xadd_char_buff	buffers.c	/^add_char_buff(buf, c)$/
Xadd_num_buff	buffers.c	/^add_num_buff(buf, n)$/
Xaddfile	msdos.c	/^addfile(fl, f, isdir)$/
Xaddstar	cmdline.c	/^addstar(fname, len)$/
XadjustCurpos	linefunc.c	/^adjustCurpos()$/
Xadjustmark	mark.c	/^adjustmark(old, new)$/
Xalloc	alloc.c	/^alloc(size)$/
Xalloc_block	storage.c	/^alloc_block()$/
Xalloc_line	storage.c	/^alloc_line(size)$/
Xappendline	storage.c	/^appendline(after, s)$/
Xask_yesno	misccmds.c	/^ask_yesno(str)$/
Xautowrite	cmdline.c	/^autowrite()$/
Xbck_word	search.c	/^bck_word(count, type)$/
Xbeep	misccmds.c	/^beep()$/
Xbeginline	edit.c	/^beginline(flag)$/
Xblink	msdos.c	/^blink(n)$/
Xblock_prep	ops.c	/^block_prep(lnum, delete)$/
Xbreakcheck	amiga.c	/^breakcheck()$/
Xbsdmemset	alloc.c	/^bsdmemset(ptr, c, size)$/
Xbuf1line	macros.h	/^#define buf1line() (line_count == 1)$/
Xbufempty	macros.h	/^#define bufempty() (buf1line() && lineempty((linen/
Xbzero	unix.c	/^#  define bzero(a, b)	memset((a), 0, (b))$/
Xcall_shell	amiga.c	/^call_shell(cmd, filter, cooked)$/
Xcanincrease	storage.c	/^canincrease(n)$/
Xcatch_cbrk	msdos.c	/^catch_cbrk()$/
Xcatch_cint	msdos.c	/^catch_cint(bp, di, si, ds, es, dx, cx, bx, ax)$/
Xcbrk_handler	msdos.c	/^cbrk_handler()$/
Xccheck_abbr	cmdline.c	/^ccheck_abbr(c)$/
Xchange_warning	misccmds.c	/^change_warning()$/
Xcharsize	charset.c	/^charsize(c)$/
Xchartabsize	charset.c	/^chartabsize(c, col)$/
Xcheck_abbr	buffers.c	/^check_abbr(c, ptr, col, mincol)$/
Xcheck_changed	cmdline.c	/^check_changed(checkaw)$/
Xcheck_fname	cmdline.c	/^check_fname()$/
Xcheck_more	cmdline.c	/^check_more(message)$/
Xcheck_msg	message.c	/^check_msg()$/
Xcheck_readonly	cmdline.c	/^check_readonly()$/
Xcheck_termcode	term.c	/^check_termcode(buf)$/
Xcheck_win	amiga.c	/^check_win(argc, argv)$/
Xcheck_winsize	term.c	/^check_winsize()$/
Xcheckclearop	normal.c	/^checkclearop()$/
Xcheckclearopq	normal.c	/^checkclearopq()$/
Xchk_mline	fileio.c	/^chk_mline(lnum)$/
Xclear_line	screen.c	/^clear_line()$/
Xclear_termparam	param.c	/^clear_termparam()$/
Xclearmarked	storage.c	/^clearmarked()$/
Xclearopbeep	normal.c	/^clearopbeep()$/
Xclrallmarks	mark.c	/^clrallmarks()$/
Xclrtags	tag.c	/^clrtags()$/
Xcls	search.c	/^cls()$/
Xcmdchecklen	cmdline.c	/^cmdchecklen()$/
Xcoladvance	linefunc.c	/^coladvance(wcol)$/
Xcomp_Botline	screen.c	/^comp_Botline()$/
Xcomp_col	param.c	/^comp_col()$/
Xcopy_redo	buffers.c	/^copy_redo()$/
Xcopy_spaces	alloc.c	/^copy_spaces(ptr, count)$/
Xcstrchr	regexp.c	/^cstrchr(s, c)$/
Xcstrncmp	regexp.c	/^cstrncmp(s1, s2, n)$/
Xcurs_columns	screen.c	/^curs_columns(scroll)$/
Xcursor_off	term.c	/^cursor_off()$/
Xcursor_on	term.c	/^cursor_on()$/
Xcursorcmd	cmdline.c	/^cursorcmd()$/
Xcursupdate	screen.c	/^cursupdate()$/
Xdebug	debug.h	/^#	define debug(x) {fprintf(debugfp,x);fflush(debug/
Xdebug1	debug.h	/^#	define debug1(x,a) {fprintf(debugfp,x,a);fflush(/
Xdebug2	debug.h	/^#	define debug2(x,a,b) {fprintf(debugfp,x,a,b);ffl/
Xdebug3	debug.h	/^#	define debug3(x,a,b,c) {fprintf(debugfp,x,a,b,c)/
Xdec	linefunc.c	/^dec(lp)$/
XdecCurpos	linefunc.c	/^decCurpos()$/
Xdecl	linefunc.c	/^decl(lp)$/
Xdecrmarks	mark.c	/^decrmarks()$/
Xdecrtags	tag.c	/^decrtags()$/
Xdel_typestr	buffers.c	/^del_typestr(len)$/
Xdelchar	misccmds.c	/^delchar(fixpos)$/
Xdellines	misccmds.c	/^dellines(nlines, doscreen, undo)$/
Xdelmode	screen.c	/^delmode()$/
Xdelsline	storage.c	/^delsline(nr, delmarks)$/
Xdirname	amiga.c	/^dirname(buf, len)$/
Xdo_Lower	regsub.c	/^do_Lower(d, c)$/
Xdo_Upper	regsub.c	/^do_Upper(d, c)$/
Xdo_align	cmdline.c	/^do_align(start, end, width, type)$/
Xdo_copy	regsub.c	/^do_copy(d, c)$/
Xdo_lower	regsub.c	/^do_lower(d, c)$/
Xdo_mlines	fileio.c	/^do_mlines()$/
Xdo_upper	regsub.c	/^do_upper(d, c)$/
Xdoaddsub	ops.c	/^doaddsub(c, Prenum1)$/
Xdoarglist	cmdline.c	/^doarglist(str)$/
Xdobang	cmdline.c	/^dobang(addr_count, arg)$/
Xdochange	ops.c	/^dochange()$/
Xdocmdline	cmdline.c	/^docmdline(cmdline)$/
Xdodelete	ops.c	/^dodelete()$/
Xdodigraph	digraph.c	/^dodigraph(c)$/
Xdodis	ops.c	/^dodis()$/
Xdodojoin	ops.c	/^dodojoin(count, insert_space, redraw)$/
Xdoecmd	cmdline.c	/^doecmd(arg, sarg)$/
Xdoexecbuf	ops.c	/^doexecbuf(c)$/
Xdofilter	cmdline.c	/^dofilter(buff, do_in, do_out)$/
Xdoformat	ops.c	/^doformat()$/
Xdoglob	csearch.c	/^doglob(type, lp, up, cmd)$/
Xdojoin	ops.c	/^dojoin(insert_space, redraw)$/
Xdojumps	mark.c	/^dojumps()$/
Xdomake	cmdline.c	/^domake(arg)$/
Xdomap	buffers.c	/^domap(maptype, keys, mode)$/
Xdomarks	mark.c	/^domarks()$/
Xdoput	ops.c	/^doput(dir, count)$/
Xdorecord	ops.c	/^dorecord(c)$/
Xdos_packet	amiga.c	/^dos_packet(pid, action, arg)$/
Xdosearch	search.c	/^dosearch(dirc, str, reverse, count, echo)$/
Xdoset	param.c	/^doset(arg)$/
Xdoshell	cmdline.c	/^doshell(cmd)$/
Xdoshift	ops.c	/^doshift(op)$/
Xdosource	cmdline.c	/^dosource(fname)$/
Xdosub	csearch.c	/^dosub(lp, up, cmd, nextcommand)$/
Xdotag	tag.c	/^dotag(tag, type, count)$/
Xdotags	tag.c	/^dotags()$/
Xdotilde	ops.c	/^dotilde()$/
Xdowrite	cmdline.c	/^dowrite(arg, append)$/
Xdoyank	ops.c	/^doyank(deleting)$/
Xecheck_abbr	edit.c	/^echeck_abbr(c)$/
Xedit	edit.c	/^edit(count)$/
Xemsg	message.c	/^emsg(s)$/
Xemsg2	message.c	/^emsg2(s, a1)$/
Xend_msg	message.c	/^end_msg()$/
Xend_word	search.c	/^end_word(count, type, stop)$/
Xequal	macros.h	/^#define equal(a, b) (((a).lnum == (b).lnum) && ((a/
Xexpand_env	misccmds.c	/^expand_env(src, dst, dstlen)$/
Xexpandpath	msdos.c	/^expandpath(fl, path, fonly, donly, notf)$/
Xfilealloc	storage.c	/^filealloc()$/
Xfileinfo	misccmds.c	/^fileinfo(fullname)$/
Xfilemess	fileio.c	/^filemess(name, s)$/
Xfill_inbuf	unix.c	/^fill_inbuf()$/
Xfindfunc	search.c	/^findfunc(dir, what, count)$/
Xfindpar	search.c	/^findpar(dir, count, what)$/
Xfindparam	param.c	/^findparam(arg)$/
Xfindsent	search.c	/^findsent(dir, count)$/
Xfindtag	tag.c	/^findtag(tag)$/
Xfirstmarked	storage.c	/^firstmarked()$/
Xflush_buffers	buffers.c	/^flush_buffers(typeahead)$/
Xflushbuf	term.c	/^flushbuf()$/
Xfm_getname	mark.c	/^fm_getname(fmark)$/
Xfname_case	amiga.c	/^fname_case(name)$/
Xfnamecmp	vim.h	/^# define fnamecmp(x, y) stricmp((x), (y))$/
Xfree	vim.h	/^# define free(x)	nofreeNULL(x)$/
Xfree_buff	buffers.c	/^free_buff(buf)$/
Xfree_line	storage.c	/^free_line(ptr)$/
Xfree_yank	ops.c	/^free_yank(n)$/
Xfree_yank_all	ops.c	/^free_yank_all()$/
Xfreeall	storage.c	/^freeall()$/
Xfreefiles	amiga.c	/^freefiles()$/
Xfullpathcmp	misccmds.c	/^fullpathcmp(s1, s2)$/
Xfwd_word	search.c	/^fwd_word(count, type, eol)$/
Xgchar	misccmds.c	/^gchar(pos)$/
XgcharCurpos	misccmds.c	/^gcharCurpos()$/
Xget_address	cmdline.c	/^get_address(ptr)$/
Xget_bufcont	buffers.c	/^get_bufcont(buffer, dozero)$/
Xget_fib	amiga.c	/^get_fib(fname)$/
Xget_indent	misccmds.c	/^get_indent()$/
Xget_inserted	buffers.c	/^get_inserted()$/
Xget_literal	edit.c	/^get_literal(nextc)$/
Xget_recorded	buffers.c	/^get_recorded()$/
Xget_yank_buffer	ops.c	/^get_yank_buffer(writing)$/
Xgetaltfile	cmdline.c	/^getaltfile(n, lnum, setpm)$/
Xgetaltfname	cmdline.c	/^getaltfname(n)$/
Xgetchr	regexp.c	/^getchr()$/
Xgetcmdline	cmdline.c	/^getcmdline(firstc, buff)$/
Xgetdigits	misccmds.c	/^getdigits(pp)$/
Xgetdigraph	digraph.c	/^getdigraph(char1, char2)$/
Xgetent	termlib.c	/^getent(tbuf, term, termcap, buflen)$/
Xgetfile	cmdline.c	/^getfile(fname, sfname, setpm)$/
Xgetlinecol	term.c	/^getlinecol()$/
Xgetmark	mark.c	/^getmark(c, changefile)$/
Xgetout	main.c	/^getout(r)$/
Xgetperm	amiga.c	/^getperm(name)$/
Xgettail	misccmds.c	/^gettail(fname)$/
Xgetvcol	screen.c	/^getvcol(pos, type)$/
Xgotchars	buffers.c	/^gotchars(s, len)$/
Xgotocmdend	cmdline.c	/^gotocmdend()$/
Xgotocmdline	cmdline.c	/^gotocmdline(clr, firstc)$/
Xhas_wildcard	amiga.c	/^has_wildcard(p)$/
Xhave_wildcard	unix.c	/^have_wildcard(num, file)$/
Xhelp	help.c	/^help()$/
Xinc	linefunc.c	/^inc(lp)$/
XincCurpos	linefunc.c	/^incCurpos()$/
Xinchar	term.c	/^inchar(buf, maxlen, time)$/
Xincl	linefunc.c	/^incl(lp)$/
Xincrmarks	mark.c	/^incrmarks()$/
Xincrtags	tag.c	/^incrtags()$/
Xinindent	misccmds.c	/^inindent()$/
Xinit_typestr	buffers.c	/^init_typestr()$/
Xinit_yank	ops.c	/^init_yank()$/
Xinitchr	regexp.c	/^initchr(str)$/
Xinmacro	search.c	/^inmacro(opt, s)$/
Xins_typestr	buffers.c	/^ins_typestr(str, noremap)$/
Xinschar	misccmds.c	/^inschar(c)$/
Xinsertbuf	ops.c	/^insertbuf(c)$/
Xinsertchar	edit.c	/^insertchar(c)$/
Xinsfile	amiga.c	/^insfile(name, isdir)$/
Xinsstr	misccmds.c	/^insstr(s)$/
Xisdir	amiga.c	/^isdir(name)$/
Xisidchar	charset.c	/^isidchar(c)$/
Xismult	regexp.c	/^ismult(c)$/
Xispathsep	misccmds.c	/^ispathsep(c)$/
Xisspace	vim.h	/^# define isspace(x)  (((x) >= 9 && (x) <= 13) || (/
Xistermparam	param.c	/^istermparam(p)$/
Xlalloc	alloc.c	/^lalloc(size, message)$/
Xlineempty	macros.h	/^#define lineempty(p) (*nr2ptr(p) == NUL)$/
Xlistdigraphs	digraph.c	/^listdigraphs()$/
Xlock2name	amiga.c	/^lock2name(lock, buf, len)$/
Xlt	macros.h	/^#define lt(a, b) (((a).lnum != (b).lnum) \\$/
Xltoreq	macros.h	/^#define ltoreq(a, b) (((a).lnum != (b).lnum) \\$/
Xm_blockalloc	storage.c	/^m_blockalloc(size, message)$/
Xm_blockfree	storage.c	/^m_blockfree()$/
Xmakemap	buffers.c	/^makemap(fd)$/
Xmakescriptname	script.c	/^makescriptname()$/
Xmakeset	param.c	/^makeset(fd)$/
Xmaketitle	misccmds.c	/^maketitle()$/
Xmark2pos	mark.c	/^mark2pos(markp)$/
Xmch_get_winsize	amiga.c	/^mch_get_winsize()$/
Xmch_set_winsize	amiga.c	/^mch_set_winsize()$/
Xmch_settmode	amiga.c	/^mch_settmode(raw)$/
Xmch_suspend	amiga.c	/^mch_suspend()$/
Xmch_windexit	amiga.c	/^mch_windexit(r)$/
Xmch_windinit	amiga.c	/^mch_windinit()$/
Xmch_write	amiga.c	/^mch_write(p, len)$/
Xmemmove	alloc.c	/^memmove(desti, source, len)$/
Xmemset	vim.h	/^# define memset(ptr, c, size)	bsdmemset((ptr), (c)/
Xmktemp	cmdline.c	/^# define mktemp(a)	tmpnam(a)$/
Xmkup	regexp.c	/^#define mkup(c) 		(reg_ic ? TO_UPPER(c) : (c))$/
Xmodname	script.c	/^modname(fname, ext)$/
Xmovemark	mark.c	/^movemark(count)$/
Xmsg	message.c	/^msg(s)$/
Xmsgmore	misccmds.c	/^msgmore(n)$/
Xmyregcomp	search.c	/^myregcomp(pat)$/
Xnextent	termlib.c	/^nextent(tbuf, termcap, buflen)         \/* Read 1 e/
Xnextwild	cmdline.c	/^nextwild(buff, type)$/
XnofreeNULL	alloc.c	/^nofreeNULL(x)$/
Xnormal	normal.c	/^normal()$/
Xnr2ptr	storage.c	/^nr2ptr(nr)$/
Xonedown	edit.c	/^onedown(n)$/
Xoneleft	edit.c	/^oneleft()$/
Xonepage	edit.c	/^onepage(dir, count)$/
Xoneright	edit.c	/^oneright()$/
Xoneup	edit.c	/^oneup(n)$/
Xopenrecover	script.c	/^openrecover()$/
Xopenscript	script.c	/^openscript(name)$/
Xotherfile	misccmds.c	/^otherfile(s)$/
Xoutchar	term.c	/^outchar(c)$/
Xoutnum	term.c	/^outnum(n)$/
Xoutnuml	term.c	/^outnuml(n)$/
Xoutstr	term.c	/^outstr(s)$/
Xoutstrn	term.c	/^outstrn(s)$/
Xouttrans	charset.c	/^outtrans(str, len)$/
Xparam_expand	param.c	/^param_expand(i, dofree)$/
Xparamchanged	param.c	/^paramchanged(arg)$/
Xparse_builtin_tcap	term.c	/^parse_builtin_tcap(tc, s)$/
Xpchar	macros.h	/^#define pchar(lp, c) (*(nr2ptr((lp).lnum) + (lp).c/
XpcharCurpos	misccmds.c	/^pcharCurpos(c)$/
Xpeekchr	regexp.c	/^peekchr()$/
Xplines	misccmds.c	/^plines(p)$/
Xplines_m	misccmds.c	/^plines_m(first, last)$/
Xplural	misccmds.c	/^plural(n)$/
Xpos2ptr	storage.c	/^pos2ptr(pos)$/
Xpremsg	normal.c	/^premsg(c1, c2)$/
Xprep_redo	normal.c	/^prep_redo(num, cmd, c, nchar)$/
Xprintdigraph	digraph.c	/^printdigraph(p)$/
Xprt_line	screen.c	/^prt_line(s)$/
Xpstrcmp	msdos.c	/^pstrcmp(a, b)$/
Xptr2nr	storage.c	/^ptr2nr(ptr, start)$/
Xputcmdline	cmdline.c	/^putcmdline(c, buff)$/
Xputdigraph	digraph.c	/^putdigraph(str)$/
Xputescstr	buffers.c	/^putescstr(fd, str, set)$/
Xqf_adjustmark	quickfix.c	/^qf_adjustmark(old, new)$/
Xqf_clrallmarks	quickfix.c	/^qf_clrallmarks()$/
Xqf_free	quickfix.c	/^qf_free()$/
Xqf_init	quickfix.c	/^qf_init()$/
Xqf_jump	quickfix.c	/^qf_jump(errornr)$/
Xqf_list	quickfix.c	/^qf_list()$/
Xqf_types	quickfix.c	/^qf_types(c, nr)$/
Xread_redo	buffers.c	/^read_redo(init)$/
Xread_stuff	buffers.c	/^read_stuff(advance)$/
Xreadfile	fileio.c	/^readfile(fname, sfname, from, newfile)$/
Xredrawcmd	cmdline.c	/^redrawcmd()$/
Xredrawcmdline	cmdline.c	/^redrawcmdline()$/
Xredrawhelp	help.c	/^redrawhelp()$/
Xreg	regexp.c	/^reg(paren, flagp)$/
Xregatom	regexp.c	/^regatom(flagp)$/
Xregbranch	regexp.c	/^regbranch(flagp)$/
Xregc	regexp.c	/^regc(b)$/
Xregcomp	regexp.c	/^regcomp(exp)$/
Xregdump	regexp.c	/^regdump(r)$/
Xregexec	regexp.c	/^regexec(prog, string, at_bol)$/
Xreginsert	regexp.c	/^reginsert(op, opnd)$/
Xregmatch	regexp.c	/^regmatch(prog)$/
Xregnext	regexp.c	/^regnext(p)$/
Xregnode	regexp.c	/^regnode(op)$/
Xregoptail	regexp.c	/^regoptail(p, val)$/
Xregpiece	regexp.c	/^regpiece(flagp)$/
Xregprop	regexp.c	/^regprop(op)$/
Xregrepeat	regexp.c	/^regrepeat(p)$/
Xregsub	regsub.c	/^regsub(prog, source, dest, copy, magic)$/
Xregtail	regexp.c	/^regtail(p, val)$/
Xregtilde	regsub.c	/^regtilde(source, magic)$/
Xregtry	regexp.c	/^regtry(prog, string)$/
Xremove	unix.c	/^remove(buf)$/
Xrename	unix.c	/^rename(src, dest)$/
Xreplaceline	storage.c	/^replaceline(lnum, new)$/
Xresettitle	amiga.c	/^resettitle()$/
Xs_del	screen.c	/^s_del(row, nlines, invalid)$/
Xs_ins	screen.c	/^s_ins(row, nlines, invalid)$/
Xsamealtfile	cmdline.c	/^samealtfile(n)$/
Xsave_line	storage.c	/^save_line(src)$/
Xscreenalloc	screen.c	/^screenalloc(clear)$/
Xscreenchar	screen.c	/^screenchar(p, row, col)$/
Xscreenclear	screen.c	/^screenclear()$/
Xscreenclear2	screen.c	/^screenclear2()$/
Xscreenfill	screen.c	/^screenfill(srow, c)$/
Xscreenline	screen.c	/^screenline(lnum, startrow, endrow)$/
Xscript_winsize	script.c	/^script_winsize()$/
Xscript_winsize_pp	script.c	/^script_winsize_pp()$/
Xscriptfullpath	script.c	/^scriptfullpath()$/
Xscrolldown	screen.c	/^scrolldown(nlines)$/
Xscrollup	screen.c	/^scrollup(nlines)$/
Xsearchc	search.c	/^searchc(c, dir, type, count)$/
Xsearchit	search.c	/^searchit(pos, dir, str, count, end)$/
Xset_Changed	misccmds.c	/^set_Changed()$/
Xset_indent	misccmds.c	/^set_indent(size, delete)$/
Xset_init	param.c	/^set_init()$/
Xset_keymap	amiga.c	/^set_keymap(name)$/
Xset_redo_ins	buffers.c	/^set_redo_ins()$/
Xset_term	term.c	/^set_term(term)$/
Xset_window	msdos.c	/^set_window()$/
Xset_winheight	term.c	/^set_winheight(height)$/
Xset_winsize	term.c	/^set_winsize(width, height, mustset)$/
Xsetaltfname	cmdline.c	/^setaltfname(arg, sarg, lnum, newfile)$/
Xsetcursor	term.c	/^setcursor()$/
Xsetfname	misccmds.c	/^setfname(s, ss)$/
Xsetmark	mark.c	/^setmark(c)$/
Xsetmarked	storage.c	/^setmarked(lnum)$/
Xsetpcmark	mark.c	/^setpcmark()$/
Xsetperm	amiga.c	/^setperm(name, perm)$/
Xsettitle	amiga.c	/^settitle(str)$/
Xsettmode	term.c	/^settmode(raw)$/
Xshift_line	ops.c	/^shift_line(left, round)$/
Xshowmap	buffers.c	/^showmap(mp)$/
Xshowmatch	search.c	/^showmatch()$/
Xshowmatches	cmdline.c	/^showmatches(file, len)$/
Xshowmode	screen.c	/^showmode()$/
Xshowonep	param.c	/^showonep(p)$/
Xshowparams	param.c	/^showparams(all)$/
Xshowruler	screen.c	/^showruler(always)$/
Xsig_winch	unix.c	/^sig_winch()$/
Xskip_chars	search.c	/^skip_chars(class, dir)$/
Xskipchr	regexp.c	/^skipchr()$/
Xskipspace	misccmds.c	/^skipspace(pp)$/
Xskiptodigit	misccmds.c	/^skiptodigit(pp)$/
Xskiptospace	misccmds.c	/^skiptospace(pp)$/
Xsleep	amiga.c	/^sleep(n)$/
Xsmsg	message.c	/^smsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/
Xsortcmp	amiga.c	/^sortcmp(a, b)$/
XstartPS	search.c	/^startPS(lnum, para)$/
Xstart_arrow	edit.c	/^start_arrow()$/
Xstart_msg	message.c	/^start_msg()$/
Xstart_redo	buffers.c	/^start_redo(count)$/
Xstart_redo_ins	buffers.c	/^start_redo_ins()$/
Xstart_stuff	buffers.c	/^start_stuff()$/
Xstartinmargin	ops.c	/^startinmargin()$/
Xstartinsert	ops.c	/^startinsert(initstr, startln, count)$/
Xstartscript	script.c	/^startscript()$/
Xstarttermcap	term.c	/^starttermcap()$/
Xstop_arrow	edit.c	/^stop_arrow()$/
Xstop_insert	edit.c	/^stop_insert()$/
Xstop_redo_ins	buffers.c	/^stop_redo_ins()$/
Xstopscript	script.c	/^stopscript()$/
Xstoptermcap	term.c	/^stoptermcap()$/
Xstrchr	vim.h	/^# define strchr(ptr, c)			index((ptr), (c))$/
Xstrcspn	regexp.c	/^strcspn(s1, s2)$/
Xstrlowcpy	msdos.c	/^strlowcpy(d, s)$/
Xstrnfcpy	regsub.c	/^strnfcpy(f, d, s, n)$/
Xstrnsave	alloc.c	/^strnsave(string, len)$/
Xstrrchr	vim.h	/^# define strrchr(ptr, c)		rindex((ptr), (c))$/
Xstrsave	alloc.c	/^strsave(string)$/
Xstrsize	charset.c	/^strsize(s)$/
XstuffReadbuff	buffers.c	/^stuffReadbuff(s)$/
Xstuff_empty	buffers.c	/^stuff_empty()$/
Xstuff_inserted	edit.c	/^stuff_inserted(c, count, no_esc)$/
Xstuff_yank	ops.c	/^stuff_yank(bufname, p)$/
XstuffcharReadbuff	buffers.c	/^stuffcharReadbuff(c)$/
XstuffnumReadbuff	buffers.c	/^stuffnumReadbuff(n)$/
Xswapchar	ops.c	/^swapchar(pos)$/
Xtermcapinit	term.c	/^termcapinit(term)$/
Xtgetent	termlib.c	/^tgetent(tbuf, term)$/
Xtgetflag	termlib.c	/^tgetflag(id)$/
Xtgetnum	termlib.c	/^tgetnum(id)$/
Xtgetstr	termlib.c	/^tgetstr(id, buf)$/
Xtgoto	term.c	/^tgoto(cm, x, y)$/
Xtinit	termlib.c	/^tinit(name)$/
Xtltoa	term.c	/^tltoa(i)$/
Xtputs	termlib.c	/^tputs(cp, affcnt, outc)$/
Xtranschar	charset.c	/^transchar(c)$/
Xttest	term.c	/^ttest(pairs)$/
Xu_clearall	undo.c	/^u_clearall()$/
Xu_clearline	undo.c	/^u_clearline()$/
Xu_freeentry	undo.c	/^u_freeentry(uep, n)$/
Xu_freelist	undo.c	/^u_freelist(uhp)$/
Xu_getbot	undo.c	/^u_getbot()$/
Xu_inssub	undo.c	/^u_inssub(lnum)$/
Xu_redo	undo.c	/^u_redo(count)$/
Xu_save	undo.c	/^u_save(top, bot)$/
Xu_saveCurpos	undo.c	/^u_saveCurpos()$/
Xu_savecommon	undo.c	/^u_savecommon(top, bot, nocopy, newbot)$/
Xu_savedel	undo.c	/^u_savedel(lnum, nlines)$/
Xu_saveline	undo.c	/^u_saveline(lnum)$/
Xu_savesub	undo.c	/^u_savesub(lnum)$/
Xu_sync	undo.c	/^u_sync()$/
Xu_undo	undo.c	/^u_undo(count)$/
Xu_undoline	undo.c	/^u_undoline()$/
Xu_undoredo	undo.c	/^u_undoredo()$/
Xungetchr	regexp.c	/^ungetchr()$/
Xunregc	regexp.c	/^unregc()$/
XupdateScreen	screen.c	/^updateScreen(type)$/
Xupdateline	screen.c	/^updateline()$/
Xupdatescript	script.c	/^updatescript(c)$/
Xusage	main.c	/^usage(n)$/
Xvgetc	buffers.c	/^vgetc()$/
Xvgetorpeek	buffers.c	/^vgetorpeek(advance)$/
Xvim_chdir	msdos.c	/^vim_chdir(path)$/
Xvim_delay	amiga.c	/^vim_delay()$/
Xvim_remove	msdos.c	/^vim_remove(name)$/
Xvimgetenv	amiga.c	/^vimgetenv(var)$/
Xvpeekc	buffers.c	/^vpeekc()$/
Xwait_return	message.c	/^wait_return(redraw)$/
Xwin_resize_off	amiga.c	/^win_resize_off()$/
Xwin_resize_on	amiga.c	/^win_resize_on()$/
Xwindgoto	term.c	/^windgoto(row, col)$/
Xwrite_buf	fileio.c	/^write_buf(fd, buf, len)$/
Xwriteit	fileio.c	/^writeit(fname, sfname, start, end, append, forceit/
END_OF_FILE
if test 20073 -ne `wc -c <'vim/src/tags'`; then
    echo shar: \"'vim/src/tags'\" unpacked with wrong size!
fi
chmod +x 'vim/src/tags'
# end of 'vim/src/tags'
fi
echo shar: End of archive 9 \(of 25\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
