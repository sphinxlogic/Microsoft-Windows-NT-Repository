Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i058:  vim - Vi IMitation editor, v2.0, Part08/25
Message-ID: <1993Dec21.034535.27596@sparky.sterling.com>
X-Md4-Signature: f73dbd1a73ce61decf489d22abaf50ae
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:45:35 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 58
Archive-name: vim/part08
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 8 (of 25)."
# Contents:  vim/doc/difference.doc vim/src/msdos.c vim/src/term.c
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/difference.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/difference.doc'\"
else
echo shar: Extracting \"'vim/doc/difference.doc'\" \(18596 characters\)
sed "s/^X//" >'vim/doc/difference.doc' <<'END_OF_FILE'
X
X
XThis is a summary of the differences between VIM and vi.
X
X
XThe most interesting additions:
X
XVi compatibility.
XWhen the 'compatible' option is set, all options are given a vi-compatible
Xvalue. Vim will behave like the "real" vi as much as possible.
X
X
XMulti level undo.
X'u' goes backward in time, 'ctrl-R' goes forward again. Set option 
X'undolines' to the number of changes to be remembered (default 100). Set 
X'undolines' to 0 for vi-compatible one level undo.
X
X
XRepeat a series of commands.
X'q'<c> starts recording typed characters into named register <c> (append to
Xthe register if register name is upper case). A subsequent 'q' stops
Xrecording. The register can then be executed with the '@'<c> command. This is
Xvery useful to repeat a complex action.
X
X
XFlexible insert mode.
XThe arrow keys can be used in insert mode to move around in the file. This 
Xbreaks the insert in two parts as far as undo and redo is concerned.
X
XCTRL-O can be used to execute a single command-mode command. This is almost 
Xthe same as hitting ESC, typing the command and hitting 'a'. For undo/redo 
Xonly those inserts are remembered where something was actually inserted.
X
X
XVisual mode.
XVisual can be used to first choose a piece of text and then give a command 
Xto do something with it. This is an (easy to use) alternative to first giving 
Xthe operator and then moving to the end of the text to be operated upon. 'v' 
Xand 'V' are used to start Visual mode. 'v' works on characters and 'V' on
Xlines. Move the cursor to extend the Visual part. It is shown highlighted on
Xthe screen. By typing 'o' the other end of the Visual text can be moved. The
XVisual text can be affected by an operator:
X	d	delete
X	c	change
X	y	yank
X	> or <	insert or delete indent
X	!	filter through external program
X	=	filter through indent
X	:	start ":" command for the Visual lines.
X	Q	format text to 'textwidth' columns
X	J	join lines
X	~	swap case
X	u	make lowercase
X	U	make uppercase
X
X
XBlock operators.
XWith Visual a rectangular block of text can be selected. Start Visual with 
XCTRL-V. The block can be deleted ('d'), yanked ('y') or its case can be 
Xchanged ('~', 'u' and 'U'). A deleted or yanked block can be put into the
Xtext with the 'p' and 'P' commands.
X
X
XOnline help.
X':help' command and help key (F1 for MSDOS) display several pages of concise 
Xhelp. The name of the help file can be set with the "helpfile" option.
X
X
XCommand line editing.
XYou can insert or delete at any place in the command line using the cursor 
Xkeys. The right/left cursor keys can be used to move forward/backward one 
Xcharacter. The shifted right/left cursor keys can be used to move 
Xforward/backward one word. CTRL-B/CTRL-E can be used to go to the begin/end
Xof the command line.
X
XThe command lines are remembered. The up/down cursor keys can be used to 
Xrecall previous command lines. The 'history' option can be set to the number 
Xof lines that will be remembered.
X
X
XFilename completion.
XWhile entering a command line (on the bottom line of the screen) <TAB> can be 
Xtyped after an (incomplete) file name wildcard; the wildcard will be 
Xexpanded. If there are multiple matches, CTRL-N (next) and CTRL-P (previous) 
Xwill walk through the matches. The 'wildchar' option can be set to the
Xcharacter for filename completion, <TAB> is the default. CTRL-D can be typed
Xafter an (incomplete) file name wildcard; all matching files will be listed.
XCTRL-A will insert all matching files. CTRL-L will insert the longest common
Xpart of the matching files.
X
X
XHorizontal scrolling.
XIf the 'wrap' option is off, long lines will not wrap and only part of them
Xwill be shown. When the cursor is moved to a part that is not shown, the
Xscreen will scroll horizontally. The minimal number of columns to scroll can
Xbe set with the 'sidescroll' option.
X
X
XText formatting.
XThe 'textwidth' (tw) option can be used to automatically limit the line 
Xlength. This supplements the 'wrapmargin' option of Vi, which was not very 
Xuseful. The 'Q' operator can be used to format a piece of text ("Q}" formats 
Xa paragraph). Commands for text alignment: ":center", ":left" and ":right".
X
X
XEdit-compile-edit speedup.
XThe ":make" command can be used to run the compilation and jump to the first
Xerror. Alternatively Vim can be started with the "-e" option from the
Xcompiler. A file with compiler error messages is interpreted. Each line in
Xthe error file is scanned for the name of a file, line number and error
Xmessage. Vim starts editing at the first error. Optionally the name of the
Xerror file can be given with "-e errorfile". The ":cn" command can be used to
Xjump to the next error. ":cl" lists all the error messages. Other commands
Xare available (almost the same as with Manx's Z editor). The 'errorfile'
Xoption has the name of the file with error messages. The 'errorformat' option
Xcan be set to a scanf-like string to handle output from many compilers. The
X'makeprg' option contains the name of the program to be executed with the
X":make" command.
X
X
XCommand line options:
X
XWhen Vim is started with "-v" (View) then readonly mode is used (includes 
X"-n").
X
XWhen Vim is started with "-b" (Binary) then some options are set to be able
Xto edit binary or executable files.
X
XWhen Vim is started with "-s scriptfile", the characters read from 
X"scriptfile" are treated as if you typed them. If end of file is reached 
Xbefore the editor exits, further characters are read from the console.
X
XThe "-w" option can be used to record all typed characters in a script file. 
XThis file can then be used to redo the editing, possibly on another file or 
Xafter changing some commands in the script file.
X
XThe "-n" option disables the writing of a ".vim" file (see below).
X
XThe "-c command" option does the same as the the "+command" option.
X
XThe "-T terminal" option sets the terminal type.
X
XThe "-e" option starts Vim in quickfix mode.
X
X
XIn command mode:
X
XMissing command: 'Q' (go to Ex mode).
XMissing Ex commands: append, change, insert, open, preserve, recover, 
Xvisual, z and ~.
X
XThe command characters are shown in the last line of the screen. They are 
Xremoved when the command is finished. If you do not want this (on a slow 
Xterminal) reset the 'showcmd' option.
X
XIf the 'ruler' option is set, the current cursor position is shown in the 
Xlast line of the screen.
X
X'u' and CTRL-R accept a count for the number of undos/redos.
X
X'U' still works after having moved off of the last changed line and after 
X'u'.
X
XNulls in the file are replaced by <LF> internally. This allows editing of 
Xbinary files (more or less).
X
XCharacters with the 8th bit set are displayed. The characters between '~' and 
X0xa0 are displayed as "~?", "~@", "~A", etc., unless the "graphic' option is 
Xset.
X
X'=' is an operator to filter lines through an external command (vi: lisp 
Xstuff). The name of the command can be set with the 'equalprg' option. The 
Xdefault is "indent".
X
X'][' goes to the next ending of a C function ('}' in column 1).
X'[]' goes to the previous ending of a C function ('}' in column 1).
X
X'*' searches forward for the identifier under the cursor, '#' backward.
X'K' runs the program defined by the "keywordprg" option, with the identifier 
Xunder the cursor as argument.
X
X'%' can be preceded with a count. The cursor jumps to the line that 
Xpercentage down in the file. The normal '%' function to jump to the matching
Xbrace skips braces inside quotes.
X
XWith the CTRL-] command, the cursor may be in the middle of the identifier.
X
XThe used tags are remembered. Commands that can be used with the tag stack 
Xare CTRL-T, ':pop' and ':tag'. ':tags' lists the tag stack.
X
XThe 'tags' option can be set to a list of tag file names. Thus multiple 
Xtag files can be used.
X
XPreviously used file names are remembered in the alternate file name list.
XCTRL-^ accepts a count, which is an index in this list.
X
XSearch patterns have more features.
X
XSearches can find the end of a match and may include a character offset.
X
XCount added to '~', ':next', ':Next', 'n' and 'N'.
X
X"5r<CR>" replaces five characters by five line breaks. Vi replaces five
Xcharacters with a single line break.
X
XAdded :wnext command. Same as ":write" followed by ":next".
X
XIf option "tildeop" has been set, '~' is an operator (must be followed by a 
Xmovement command).
X
XWith the 'J' (join) command you can reset the 'joinspaces' (js) option to 
Xhave only one space after a period (Vi inserts two spaces).
X
X'cw' can be used to change white space formed by several characters (Vi is 
Xconfusing: 'cw' only changes one space, while 'dw' deletes all white space).
X
X'o' and 'O' accept a count for repeating the insert (Vi clears a part of 
Xdisplay).
X
X':dis' command shows the contents of the yank register.
X
XPreviously used file names are remembered in the alternate file name list.
X":files" command shows the list of alternate filenames.
X'#'<N> is replaced by the <N>th alternate filename in the list.
X"#<" is replaced by the current filename without extension.
X
XFlags after command not supported (no plans to include it).
X
XOn non-UNIX systems ":cd" command shows current directory instead of going to
Xthe home directory. ":pwd" prints the current directory on all systems.
X
X':source!' command reads Vi commands from a file.
X
X':mkexrc' command writes current modified options and mappings to a ".exrc" 
Xfile. ':mkvimrc' writes to a ".vimrc" file.
X
XNo check for "tail recursion" with mappings. This allows things like
X":map! foo ^]foo".
X
XThe :put! command inserts the contents of a register above the current line.
X
XThe named register '.' can be used with commands p, P and :put. The contents 
Xof the register is the last inserted text.
X
X":noremap" command can be used to enter a mapping that will not be remapped.
XThis is useful to exchange the meaning of two keys. ":cmap", ":cunmap" and
X":cnoremap" can be used for mapping in command line editing only. ":imap",
X":iunmap" and ":inoremap" can be used for mapping in insert mode only.
XSimilar commands exist for abbreviations: ":noreabbrev", ":iabbrev"
X":cabbrev", ":iunabbrev", ":cunabbrev", ":inoreabbrev", ":cnoreabbrev".
X
XIn vi the command ":map foo bar" would remove a previous mapping
X":map bug foo". This is considered a bug, so it is not included in Vim.
X":unmap! foo" does remove ":map! bug foo", because unmapping would be very
Xdifficult otherwise (this is vi compatible).
X
X":@r" command executes register r (is in some versions of vi).
X
XCTRL-O/CTRL-I can be used to jump to older/newer positions. These are the 
Xsame positions as used with the '' command, but may be in another file. The 
X':jumps' command lists the older positions.
X
XIf the 'shiftround' option is set, an indent is rounded to a multiple of 
X'shiftwidth' with '>' and '<' commands.
X
XThe 'scrolljump' option can be set to the minimal number of lines to scroll 
Xwhen the cursor gets off the screen. Use this when scrolling is slow.
X
XUppercase marks can be used to jump between files. The ':marks' command lists 
Xall currently set marks. The commands "']" and "`]" jump to the end of the 
Xprevious operator or end of the text inserted with the put command. "'[" and 
X"`[" do jump to the start.
X
XThe 'shelltype' option can be set to reflect the type of shell used.
X
XThe CTRL-A (add) and CTRL-S (subtract) commands are new. The count to the 
Xcommand (default 1) is added to/subtracted from the number at or after the 
Xcursor. That number may be decimal, octal (starts with a '0') or hexadecimal 
X(starts with '0x'). Very useful in macros.
X
XWith the :set command the prefix "inv" can be used to invert toggle options.
X
XIn both Vi and Vim you can create a line break with the ":substitute" command
Xby using a CTRL-M. For Vi this means you cannot insert a real CTRL-M in the
Xtext. With Vim you can put a real CTRL-M in the text by preceding it with a
XCTRL-V.
X
X
XIn insert mode:
X
XIf the 'revins' option is set, insert happens backwards. This is for typing
XHebrew. When inserting normal characters the cursor will not be shifted and
Xthe text moves rightwards. In replace mode the cursor will move leftwards.
XBackspace, CTRL-W and CTRL-U will also work in the opposite direction. CTRL-P
Xtoggles the 'revins' option.
X
XThe backspace key can be used just like CTRL-D to remove auto-indents.
X
XYou can backspace, ctrl-U and CTRL-W over line breaks if the 'backspace' (bs) 
Xoption is set to non-zero. You can backspace over the start of insert if the 
X'backspace' option is set to 2.
X
XWhen the 'paste' option is set, a few option are reset and mapping in insert
Xmode and abbreviation are disabled. This allows for pasting text in windowing
Xsystems without unexpected results. When the 'paste' option is reset, the old
Xoption values are restored.
X
XCTRL-T/CTRL-D always insert/delete an indent in the current line, no matter 
Xwhat column the cursor is in.
X
XCTRL-@ (insert previously inserted text) works always (Vi: only when typed as 
Xfirst character).
X
XCTRL-A works like CTRL-@ but does not leave insert mode.
X
XCTRL-R <0-9a-z> can be used to insert the contents of a register.
X
XWhen the 'smartindent' (si) option is set, C programs will be better 
Xauto-indented.
X
XCTRL-Y and CTRL-E can be used to copy a character from above/below the 
Xcurrent cursor position.
X
XAfter CTRL-V you can enter a three digit decimal number. This byte value is 
Xinserted in the text as a single character. Useful for international 
Xcharacters that are not on your keyboard.
X
XWhen the 'expandtab' (et) option is set, a <TAB> is expanded to the 
Xappropriate number of spaces.
X
XThe window always reflects the contents of the buffer (Vi does not do this 
Xwhen changing text and in some other cases).
X
XIf Vim is compiled with DIGRAPHS defined, digraphs are supported. A set of 
Xnormal Amiga digraphs is included. They are shown with the :digraph" command. 
XMore can be added with ":digraph {char1}{char2} {number}". A digraph is 
Xentered with "CTRL-K {char1} {char2}" or "{char1} BS {char2}" (only when 
X'digraph' option is set).
X
X
XIn command line mode:
X
XESC terminates the command line without executing it. In vi the command line
Xwould be executed, which is not what most people expect (hitting ESC should
Xalways get you back to command mode). To avoid problems with some
Xobscure macros, an ESC in a macro will execute the command. If you want a
Xtyped ESC to execute the command like vi does you can fix this with
X	":cmap ^V<ESC> ^V<CR>"
X
Xgeneral:
X
XMissing options: autoprint (ap), beautify (bf), edcompatible, hardtabs (ht), 
Xlisp, mesg, open, optimize (op), prompt, redraw, slowopen (slow), terse,
Xwindow, w300, w1200 and w9600. These options can be set but are otherwise
Xignored.
X
XWhen the 'compatible' option is set, all options are set for maximum 
Xvi-compatibility
X
XThe 'ttimeout' option is like 'timeout', but only works for cursor and 
Xfunction keys, not for ordinary mapped characters. The 'timoutlen' option
Xgives the number of milliseconds that is waited for. If the 'esckeys' option
Xis not set, cursor and function keys that start with <ESC> are not recognized
Xin insert mode.
X
XThere is an option for each terminal string. Can be used when termcap is not 
Xsupported or to change individual strings.
X
XWhen the 'textmode' option is set (default for MSDOS) <CR><LF> is used as
Xline separator. When reset (default for Unix and Amiga) <LF> is used. When
Xthe 'textauto' option is set, Vim tries to detect the type of line separator
Xused by reading up to the first <LF>. The 'textmode' option is set
Xaccordingly.
X
XOn systems that have no job control (most systems but BSD-UNIX) the CTRL-Z, 
X":stop" or ":suspend" command starts a new shell.
X
XIf Vim is started on the Amiga without an interactive window for output, a 
Xwindow is opened (and :sh still works). You can give a device to use for 
Xediting with the '-d' argument, e.g. "-d con:20/20/600/150".
X
XOn startup the VIMINIT or EXINIT environment variables, the file s:.vimrc or 
Xs:.exrc and .vimrc or .exrc are read for initialization commands. When 
Xreading .vimrc and .exrc some commands are not allowed because of security 
Xreasons (shell commands and writing to a file, :map commands are echoed). 
XThis can be overrided with the 'secure' option.
X
XLine lenght can be at least upto the maximum value of an int (for the Amiga
X32767 characters, for most 32-bit systems much larger). Editing such lines is
Xnot always possible. File length upto 2147483646 lines. If a line is larger
Xthan the screen, the last line is filled with <@>s and only the part of the
Xline before that is shown (unless 'wrap' option is reset).
X
XThe 'columns' option is used to set or get the width of the display.
X
XThe name of the current file name is shown in the title bar of the window.
X
XWildcards in file names are expanded.
X
XOption settings are read from the first and last few lines of the file. 
XOption 'modelines' determines how many lines are tried (default is 5). Note 
Xthat this is different from the Vi versions that can execute any Ex command 
Xin a modeline (a major security problem).
X
XIf the 'insertmode' option is set (e.g. in .exrc), Vim starts in insert mode.
X
XAll text is kept in memory. Available memory limits the file size (and other 
Xthings such as undo). This may be a problem with MSDOS, is hardly a problem 
Xont the Amiga and almost never with Unix.
X
XIf the 'backup' or 'writebackup' option is set: Before a file is overwritten, 
Xa backup file (.bak) is made. If the "backup" option is set it is left 
Xbehind.
X
XIf the 'binary' option is set and the file does not have an end-of-line for
Xthe last line, the end-of-line is not appended when writing.
X
XAll entered commands and text is written into a script file, ending in 
X".vim". This can be used to recover your work if the machine crashes during 
Xan edit session. This can be switched off by setting the 'updatecount' option 
Xto 0 or starting Vim with the "-n" option. Use the 'directory' option for 
Xplacing the .vim file somewhere else.
X
XThe 'shortname' (sn) option, when set, tells Vim that ".bak" and ".vim" 
Xfilenames are to be MSDOS-like: 8 characters plus 3 for extention. This 
Xshould be used on messydos or crossdos filesystems on the Amiga. If this 
Xoption is off, Vim tries to guess if MSDOS filename restrictions are 
Xeffective.
X
XRecovery after a crash has a smaller chance for success, because there is no 
Xtemporary file.
X
XError messages are shown at least one second (Vi overwrites error messages).
X
XIf Vim asks to "Hit RETURN to continue", you can hit any key. Characters 
Xother than <CR>, <LF> and <SPACE> are interpreted as the (start of) a 
Xcommand. (Vi only accepts a command starting with ':').
X
XThe contents of the numbered and unnamed registers is remembered when
Xchanging files.
X
XThe AUX: device of the Amiga is supported.
X
Xvi:tw=77:
END_OF_FILE
if test 18596 -ne `wc -c <'vim/doc/difference.doc'`; then
    echo shar: \"'vim/doc/difference.doc'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/difference.doc'
# end of 'vim/doc/difference.doc'
fi
if test -f 'vim/src/msdos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/msdos.c'\"
else
echo shar: Extracting \"'vim/src/msdos.c'\" \(17132 characters\)
sed "s/^X//" >'vim/src/msdos.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:		Bram Moolenaar			mool@oce.nl
X *								Tim Thompson			twitch!tjt
X *								Tony Andrews			onecom!wldrdg!tony
X *								G. R. (Fred) Walter 	watmath!watcgl!grwalter
X */
X
X/*
X * msdos.c
X *
X * MSDOS system-dependent routines.
X * A cheap plastic imitation of the amiga dependent code.
X * A lot in this file was made by Juergen Weigert (jw).
X */
X
X#include <io.h>
X#include "vim.h"
X#include "globals.h"
X#include "param.h"
X#include "proto.h"
X#include <conio.h>
X#include <fcntl.h>
X#include <bios.h>
X
Xstatic int WaitForChar __ARGS((int));
Xstatic int cbrk_handler __ARGS(());
X
Xtypedef struct filelist
X{
X	char	**file;
X	int		nfiles;
X	int		maxfiles;
X} FileList;
X
Xstatic void		addfile __ARGS((FileList *, char *, int));
Xstatic int		pstrcmp();	/* __ARGS((char **, char **)); BCC does not like this */
Xstatic void		strlowcpy __ARGS((char *, char *));
Xstatic int		expandpath __ARGS((FileList *, char *, int, int, int));
X
Xstatic int cbrk_pressed = FALSE;	/* set by ctrl-break interrupt */
Xstatic int ctrlc_pressed = FALSE;	/* set when ctrl-C or ctrl-break detected */
Xstatic int delayed_redraw = FALSE;	/* set when ctrl-C detected */
X
X#ifdef DEBUG
X/*
X * Put two characters in the video buffer without calling BIOS or DOS.
X */
Xblink(n)
X	int n;
X{
X	char far *p;
X	static int counter;
X
X	p = MK_FP(0xb800, 0x10 + n);		/* p points in screen buffer */
X	*p = counter;
X	*(p + 1) = counter;
X	*(p + 2) = counter;
X	*(p + 3) = counter;
X	++counter;
X}
X#endif
X
X	void
Xvim_delay()
X{
X	delay(500);
X}
X
X/*
X * this version of remove is not scared by a readonly (backup) file
X */
X	int
Xvim_remove(name)
X	char *name;
X{
X	setperm(name, 0);    /* default permissions */
X	return unlink(name);
X}
X
X/*
X * mch_write(): write the output buffer to the screen
X */
X	void
Xmch_write(s, len)
X	char	*s;
X	int		len;
X{
X	char	*p;
X	int		row, col;
X
X	if (term_console)		/* translate ESC | sequences into bios calls */
X		while (len--)
X		{
X			if (s[0] == '\n')
X				putch('\r');
X			else if (s[0] == ESC && len > 1 && s[1] == '|')
X			{
X				switch (s[2])
X				{
X				case 'J':	clrscr();
X							goto got3;
X
X				case 'K':	clreol();
X							goto got3;
X
X				case 'L':	insline();
X							goto got3;
X
X				case 'M':	delline();
Xgot3:						s += 3;
X							len -= 2;
X							continue;
X
X				case '0':
X				case '1':
X				case '2':
X				case '3':
X				case '4':
X				case '5':
X				case '6':
X				case '7':
X				case '8':
X				case '9':	p = s + 2;
X							row = getdigits(&p);		/* no check for length! */
X							if (p > s + len)
X								break;
X							if (*p == ';')
X							{
X								++p;
X								col = getdigits(&p);	/* no check for length! */
X								if (p > s + len)
X									break;
X								if (*p == 'H')
X								{
X									gotoxy(col, row);
X									len -= p - s;
X									s = p + 1;
X									continue;
X								}
X							}
X							else if (*p == 'm')
X							{
X								if (row == 0)
X									normvideo();
X								else
X									textattr(row);
X								len -= p - s;
X								s = p + 1;
X								continue;
X							}
X				}
X			}
X			putch(*s++);
X		}
X	else
X		write(1, s, (unsigned)len);
X}
X
X#define POLL_SPEED 10	/* milliseconds between polls */
X
X/*
X * Simulate WaitForChar() by slowly polling with bioskey(1) or kbhit().
X *
X * If Vim should work over the serial line after a 'ctty com1' we must use
X * kbhit() and getch(). (jw)
X * Usually kbhit() is not used, because then CTRL-C and CTRL-P
X * will be catched by DOS (mool).
X */
X
X	static int
XWaitForChar(msec)
X	int msec;
X{
X	do
X	{
X		if ((p_biosk ? bioskey(1) : kbhit()) || cbrk_pressed)
X			return 1;
X		delay(POLL_SPEED);
X		msec -= POLL_SPEED;
X	}
X	while (msec >= 0);
X	return 0;
X}
X
X/*
X * GetChars(): low level input funcion.
X * Get a characters from the keyboard.
X * If time == 0 do not wait for characters.
X * If time == n wait a short time for characters.
X * If time == -1 wait forever for characters.
X */
X	int
XGetChars(buf, maxlen, time)
X	char		*buf;
X	int 		maxlen;
X	int 		time;
X{
X	int 		len = 0;
X	int			c;
X
X/*
X * if we got a ctrl-C when we were busy, there will be a "^C" somewhere
X * on the sceen, so we need to redisplay it.
X */
X	if (delayed_redraw)
X	{
X		delayed_redraw = FALSE;
X		updateScreen(CLEAR);
X		setcursor();
X		flushbuf();
X	}
X
X	if (time >= 0)
X	{
X		if (time == 0)			/* don't know if time == 0 is allowed */
X			time = 1;
X		if (WaitForChar(time) == 0) 	/* no character available */
X			return 0;
X	}
X	else	/* time == -1 */
X	{
X	/*
X	 * If there is no character available within 2 seconds (default)
X	 * write the autoscript file to disk
X	 */
X		if (WaitForChar((int)p_ut) == 0)
X			updatescript(0);
X	}
X
X/*
X * Try to read as many characters as there are.
X * Works for the controlling tty only.
X */
X	--maxlen;		/* may get two chars at once */
X	/*
X	 * we will get at least one key. Get more if they are available
X	 * After a ctrl-break we have to read a 0 (!) from the buffer.
X	 * bioskey(1) will return 0 if no key is available and when a
X	 * ctrl-break was typed. When ctrl-break is hit, this does not always
X	 * implies a key hit.
X	 */
X	cbrk_pressed = FALSE;
X	if (p_biosk)
X		while ((len == 0 || bioskey(1)) && len < maxlen)
X		{
X			c = bioskey(0);			/* get the key */
X			if (c == 0)				/* ctrl-break */
X				c = 3;				/* return a CTRL-C */
X			if ((c & 0xff) == 0)
X			{
X				if (c == 0x0300)		/* CTRL-@ is 0x0300, translated into K_ZERO */
X					c = K_ZERO;
X				else		/* extended key code 0xnn00 translated into K_NUL, nn */
X				{
X					c >>= 8;
X					*buf++ = K_NUL;
X					++len;
X				}
X			}
X
X			*buf++ = c;
X			len++;
X		}
X	else
X		while ((len == 0 || kbhit()) && len < maxlen)
X		{
X			switch (c = getch())
X			{
X			case 0:
X					*buf++ = K_NUL;
X					break;
X			case 3:
X					cbrk_pressed = TRUE;
X					/*FALLTHROUGH*/
X			default:
X					*buf++ = c;
X			}
X			len++;
X		}
X	return len;
X}
X
X/*
X * We have no job control, fake it by starting a new shell.
X */
X	void
Xmch_suspend()
X{
X	outstr("new shell started\n");
X	call_shell(NULL, 0, TRUE);
X}
X
Xextern int _fmode;
X/*
X * we do not use windows, there is not much to do here
X */
X	void
Xmch_windinit()
X{
X	_fmode = O_BINARY;		/* we do our own CR-LF translation */
X	flushbuf();
X	mch_get_winsize();
X}
X
X	void
Xcheck_win(argc, argv)
X	int		argc;
X	char	**argv;
X{
X	if (!isatty(0) || !isatty(1))
X	{
X		fprintf(stderr, "VIM: no controlling terminal\n");
X		exit(2);
X	}
X	/*
X	 * In some cases with DOS 6.0 on a NEC notebook there is a 12 seconds
X	 * delay when starting up that can be avoided by the next two lines.
X	 * Don't ask me why!
X	 * This could be fixed by removing setver.sys from config.sys. Forget it.
X	gotoxy(1,1);
X	cputs(" ");
X	 */
X}
X
X/*
X * fname_case(): Set the case of the filename, if it already exists.
X *				 msdos filesystem is far to primitive for that. do nothing.
X */
X	void
Xfname_case(name)
X	char *name;
X{
X}
X
X/*
X * settitle(): set titlebar of our window.
X * Dos console has no title.
X */
X	void
Xsettitle(str)
X	char *str;
X{
X}
X
X	void
Xresettitle()
X{
X}
X
X/*
X * Get name of current directory into buffer 'buf' of length 'len' bytes.
X * Return non-zero for success.
X */
X	int
Xdirname(buf, len)
X	char	*buf;
X	int		len;
X{
X	return (getcwd(buf, len) != NULL);
X}
X
X/*
X * Change default drive (for Turbo C, Borland C already has it)
X */
X#ifndef __BORLANDC__
X	int
X_chdrive(drive)
X	int drive;
X{
X	unsigned dummy;
X	union REGS regs;
X
X	regs.h.ah = 0x0e;
X	regs.h.dl = drive - 1;
X	intdos(&regs, &regs);	/* set default drive */
X	regs.h.ah = 0x19;
X	intdos(&regs, &regs);	/* get default drive */
X	if (regs.h.al == drive - 1)
X		return 0;
X	else
X		return -1;
X}
X#endif
X
X/*
X * get absolute filename into buffer 'buf' of length 'len' bytes
X */
X	int
XFullName(fname, buf, len)
X	char	*fname, *buf;
X	int		len;
X{
X	if (fname == NULL)	/* always fail */
X		return 0;
X
X#ifdef __BORLANDC__		/* the old Turbo C does not have this */
X	if (_fullpath(buf, fname, len) == NULL)
X	{
X		strncpy(buf, fname, len);	/* failed, use the relative path name */
X		return 0;
X	}
X	return 1;
X#else					/* almost the same as FullName in unix.c */
X	{
X		int		l;
X		char	olddir[MAXPATHL];
X		char	*p, *q;
X		int		c;
X		int		retval = 1;
X
X		*buf = 0;
X		/*
X		 * change to the directory for a moment,
X		 * and then do the getwd() (and get back to where we were).
X		 * This will get the correct path name with "../" things.
X		 */
X		p = strrchr(fname, '/');
X		q = strrchr(fname, '\\');
X		if (q && (p == NULL || q > p))
X			p = q;
X		q = strrchr(fname, ':');
X		if (q && (p == NULL || q > p))
X			p = q;
X		if (p != NULL)
X		{
X			if (getcwd(olddir, MAXPATHL) == NULL)
X			{
X				p = NULL;		/* can't get current dir: don't chdir */
X				retval = 0;
X			}
X			else
X			{
X				if (*p == ':' || (p > fname && p[-1] == ':'))
X					q = p + 1;
X				else
X					q = p;
X				c = *q;
X				*q = NUL;
X				if (chdir(fname))
X					retval = 0;
X				else
X					fname = p + 1;
X				*q = c;
X			}
X		}
X		if (getcwd(buf, len) == NULL)
X		{
X			retval = 0;
X			*buf = NUL;
X		}
X		l = strlen(buf);
X		if (l && buf[l - 1] != '/' && buf[l - 1] != '\\')
X			strcat(buf, "\\");
X		if (p)
X			chdir(olddir);
X		strcat(buf, fname);
X		return retval;
X	}
X#endif
X}
X
X/*
X * get file permissions for 'name'
X * -1 : error
X * else FA_attributes defined in dos.h
X */
X	long
Xgetperm(name)
X	char *name;
X{
X	int r;
X
X	r = _chmod(name, 0, 0);		 /* get file mode */
X	return r;
X}
X
X/*
X * set file permission for 'name' to 'perm'
X */
X	int
Xsetperm(name, perm)
X	char	*name;
X	long	perm;
X{
X	perm &= ~FA_ARCH;
X	return _chmod(name, 1, (int)perm);
X}
X
X/*
X * check if "name" is a directory
X */
X	int
Xisdir(name)
X	char *name;
X{
X	int f;
X
X	f = _chmod(name, 0, 0);
X	if (f == -1)
X		return -1;					/* file does not exist at all */
X	if ((f & FA_DIREC) == 0)
X		return 0;					/* not a directory */
X	return 1;
X}
X
X/*
X * Careful: mch_windexit() may be called before mch_windinit()!
X */
X	void
Xmch_windexit(r)
X	int r;
X{
X	settmode(0);
X	stoptermcap();
X	flushbuf();
X	stopscript(); 				/* remove autoscript file */
X	exit(r);
X}
X
X/*
X * function for ctrl-break interrupt
X */
X	void interrupt
Xcatch_cbrk()
X{
X	cbrk_pressed = TRUE;
X	ctrlc_pressed = TRUE;
X}
X
X/*
X * ctrl-break handler for DOS. Never called when a ctrl-break is typed, because
X * we catch interrupt 1b. If you type ctrl-C while Vim is waiting for a
X * character this function is not called. When a ctrl-C is typed while Vim is
X * busy this function may be called. By that time a ^C has been displayed on
X * the screen, so we have to redisplay the screen. We can't do that here,
X * because we may be called by DOS. The redraw is in GetChars().
X */
X	static int
Xcbrk_handler()
X{
X	delayed_redraw = TRUE;
X	return 1; 				/* resume operation after ctrl-break */
X}
X
X/*
X * function for critical error interrupt
X * For DOS 1 and 2 return 0 (Ignore).
X * For DOS 3 and later return 3 (Fail)
X */
X	void interrupt
Xcatch_cint(bp, di, si, ds, es, dx, cx, bx, ax)
X	unsigned bp, di, si, ds, es, dx, cx, bx, ax;
X{
X	ax = (ax & 0xff00);		/* set AL to 0 */
X	if (_osmajor >= 3)
X		ax |= 3;			/* set AL to 3 */
X}
X
X/*
X * set the tty in (raw) ? "raw" : "cooked" mode
X *
X * Does not change the tty, as bioskey() and kbhit() work raw all the time.
X */
X
Xextern void interrupt CINT_FUNC();
X
X	void
Xmch_settmode(raw)
X	int  raw;
X{
X	static int saved_cbrk;
X	static void interrupt (*old_cint)();
X	static void interrupt (*old_cbrk)();
X
X	if (raw)
X	{
X		saved_cbrk = getcbrk();			/* save old ctrl-break setting */
X		setcbrk(0);						/* do not check for ctrl-break */
X		old_cint = getvect(0x24); 		/* save old critical error interrupt */
X		setvect(0x24, catch_cint);		/* install our critical error interrupt */
X		old_cbrk = getvect(0x1B); 		/* save old ctrl-break interrupt */
X		setvect(0x1B, catch_cbrk);		/* install our ctrl-break interrupt */
X		ctrlbrk(cbrk_handler);			/* vim's ctrl-break handler */
X		if (term_console)
X			outstr(T_TP);				/* set colors */
X	}
X	else
X	{
X		setcbrk(saved_cbrk);			/* restore ctrl-break setting */
X		setvect(0x24, old_cint);		/* restore critical error interrupt */
X		setvect(0x1B, old_cbrk);		/* restore ctrl-break interrupt */
X		/* restore ctrl-break handler, how ??? */
X		if (term_console)
X			normvideo();				/* restore screen colors */
X	}
X}
X
X/*
X * Structure used by Turbo-C/Borland-C to store video parameters.
X */
Xextern struct text_info _video;
X
X	int
Xmch_get_winsize()
X{
X	int i;
X	struct text_info ti;
X/*
X * The screenwidth is returned by the BIOS OK.
X * The screenheight is in a location in the bios RAM, if the display is EGA or VGA.
X */
X	if (!term_console)
X		return 1;
X	gettextinfo(&ti);
X	Columns = ti.screenwidth;
X	Rows = ti.screenheight;
X	if (ti.currmode > 10)
X		Rows = *(char far *)MK_FP(0x40, 0x84) + 1;
X	set_window();
X
X	if (Columns < 5 || Columns > MAX_COLUMNS ||
X					Rows < 2 || Rows > MAX_COLUMNS)
X	{
X		/* these values are overwritten by termcap size or default */
X		Columns = 80;
X		Rows = 25;
X		return 1;
X	}
X	Rows_max = Rows;				/* remember physical max height */
X
X	check_winsize();
X	script_winsize();
X
X	return 0;
X}
X
X/*
X * Set the active window for delline/insline.
X */
X	void
Xset_window()
X{
X	_video.screenheight = Rows;
X	window(1, 1, Columns, Rows);
X}
X
X	void
Xmch_set_winsize()
X{
X	/* should try to set the window size to Rows and Columns */
X	/* may involve switching display mode.... */
X}
X
X	int
Xcall_shell(cmd, filter, cooked)
X	char	*cmd;
X	int 	filter; 		/* if != 0: called by dofilter() */
X	int		cooked;
X{
X	int		x;
X	char	newcmd[200];
X
X	flushbuf();
X
X	if (cooked)
X		settmode(0);		/* set to cooked mode */
X
X	if (cmd == NULL)
X		x = system(p_sh);
X	else
X	{ 					/* we use "command" to start the shell, slow but easy */
X		sprintf(newcmd, "%s /c %s", p_sh, cmd);
X		x = system(newcmd);
X	}
X	outchar('\n');
X	if (cooked)
X		settmode(1);		/* set to raw mode */
X
X	if (x)
X	{
X		smsg("%d returned", x);
X		outchar('\n');
X	}
X
X	resettitle();
X	return x;
X}
X
X/*
X * check for an "interrupt signal": CTRL-break or CTRL-C
X */
X	void
Xbreakcheck()
X{
X	if (ctrlc_pressed)
X	{
X		ctrlc_pressed = FALSE;
X		got_int = TRUE;
X	}
X}
X
X#define FL_CHUNK 32
X
X	static void
Xaddfile(fl, f, isdir)
X	FileList	*fl;
X	char		*f;
X	int			isdir;
X{
X	char		*p;
X
X	if (!fl->file)
X	{
X		fl->file = (char **)alloc(sizeof(char *) * FL_CHUNK);
X		if (!fl->file)
X			return;
X		fl->nfiles = 0;
X		fl->maxfiles = FL_CHUNK;
X	}
X	if (fl->nfiles >= fl->maxfiles)
X	{
X		char	**t;
X		int		i;
X
X		t = (char **)lalloc(sizeof(char *) * (fl->maxfiles + FL_CHUNK), TRUE);
X		if (!t)
X			return;
X		for (i = fl->nfiles - 1; i >= 0; i--)
X			t[i] = fl->file[i];
X		free(fl->file);
X		fl->file = t;
X		fl->maxfiles += FL_CHUNK;
X	}
X	p = alloc((unsigned)(strlen(f) + 1 + isdir));
X	if (p)
X	{
X		strcpy(p, f);
X		if (isdir)
X			strcat(p, "\\");
X	}
X	fl->file[fl->nfiles++] = p;
X}
X
X	static int
Xpstrcmp(a, b)
X	char **a, **b;
X{
X	return (strcmp(*a, *b));
X}
X
X	int
Xhas_wildcard(s)
X	char *s;
X{
X	if (s)
X		for ( ; *s; ++s)
X			if (*s == '?' || *s == '*')
X				return 1;
X	return 0;
X}
X
X	static void
Xstrlowcpy(d, s)
X	char *d, *s;
X{
X	while (*s)
X		*d++ = tolower(*s++);
X	*d = '\0';
X}
X
X	static int
Xexpandpath(fl, path, fonly, donly, notf)
X	FileList	*fl;
X	char		*path;
X	int			fonly, donly, notf;
X{
X	char	buf[MAXPATH];
X	char	*p, *s, *e;
X	int		lastn, c, r;
X	struct	ffblk fb;
X
X	lastn = fl->nfiles;
X
X/*
X * Find the first part in the path name that contains a wildcard.
X * Copy it into buf, including the preceding characters.
X */
X	p = buf;
X	s = NULL;
X	e = NULL;
X	while (*path)
X	{
X		if (*path == '\\' || *path == ':' || *path == '/')
X		{
X			if (e)
X				break;
X			else
X				s = p;
X		}
X		if (*path == '*' || *path == '?')
X			e = p;
X		*p++ = *path++;
X	}
X	e = p;
X	if (s)
X		s++;
X	else
X		s = buf;
X
X	/* now we have one wildcard component between s and e */
X	*e = '\0';
X	r = 0;
X	/* If we are expanding wildcards we try both files and directories */
X	if ((c = findfirst(buf, &fb, (*path || !notf) ? FA_DIREC : 0)) != 0)
X	{
X		/* not found */
X		strcpy(e, path);
X		if (notf)
X			addfile(fl, buf, FALSE);
X		return 1; /* unexpanded or empty */
X	}
X	while (!c)
X	{
X		strlowcpy(s, fb.ff_name);
X		if (*s != '.' || (s[1] != '\0' && (s[1] != '.' || s[2] != '\0')))
X		{
X			strcat(buf, path);
X			if (!has_wildcard(path))
X				addfile(fl, buf, (isdir(buf) > 0));
X			else
X				r |= expandpath(fl, buf, fonly, donly, notf);
X		}
X		c = findnext(&fb);
X	}
X	qsort(fl->file + lastn, fl->nfiles - lastn, sizeof(char *), pstrcmp);
X	return r;
X}
X
X/*
X * MSDOS rebuilt of Scott Ballantynes ExpandWildCard for amiga/arp.
X * jw
X */
X
X	int
XExpandWildCards(num_pat, pat, num_file, file, files_only, list_notfound)
X	int 	num_pat;
X	char	**pat;
X	int 	*num_file;
X	char	***file;
X	int 	files_only, list_notfound;
X{
X	int			i, r = 0;
X	FileList	f;
X
X	f.file = NULL;
X	f.nfiles = 0;
X	for (i = 0; i < num_pat; i++)
X	{
X		if (!has_wildcard(pat[i]))
X			addfile(&f, pat[i], files_only ? FALSE : (isdir(pat[i]) > 0));
X		else
X			r |= expandpath(&f, pat[i], files_only, 0, list_notfound);
X	}
X	if (r == 0)
X	{
X		*num_file = f.nfiles;
X		*file = f.file;
X	}
X	else
X	{
X		*num_file = 0;
X		*file = NULL;
X	}
X	return r;
X}
X
X	void
XFreeWild(num, file)
X	int		num;
X	char	**file;
X{
X	if (file == NULL || num <= 0)
X		return;
X	while (num--)
X		free(file[num]);
X	free(file);
X}
X
X/*
X * The normal chdir() does not change the default drive.
X * This one does.
X */
X#undef chdir
X	int
Xvim_chdir(path)
X	char *path;
X{
X	if (path[0] == NUL)				/* just checking... */
X		return 0;
X	if (path[1] == ':')				/* has a drive name */
X	{
X		if (_chdrive(toupper(path[0]) - 'A' + 1))
X			return -1;				/* invalid drive name */
X		path += 2;
X	}
X	if (*path == NUL)				/* drive name only */
X		return 0;
X	return chdir(path);				/* let the normal chdir() do the rest */
X}
END_OF_FILE
if test 17132 -ne `wc -c <'vim/src/msdos.c'`; then
    echo shar: \"'vim/src/msdos.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/msdos.c'
# end of 'vim/src/msdos.c'
fi
if test -f 'vim/src/term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/term.c'\"
else
echo shar: Extracting \"'vim/src/term.c'\" \(18021 characters\)
sed "s/^X//" >'vim/src/term.c' <<'END_OF_FILE'
X/* vi:sw=4:ts=4:
X *
X * term.c -- VIM - Vi IMproved
X *
X * primitive termcap support added
X *
X * NOTE: padding and variable substitution is not performed,
X * when compiling without TERMCAP, we use tputs() and tgoto() dummies.
X *
X * 14.6.92
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "param.h"
X#include "proto.h"
X#ifdef TERMCAP
X# ifdef linux
X#  include <termcap.h>
X#  define TPUTSFUNCAST (outfuntype)
X# else
X#  define TPUTSFUNCAST
X#  ifdef AMIGA
X#   include "proto/termlib.pro"
X#  endif
X# endif
X#endif
X
X#ifdef DEBUG
X# define TTEST(a) debug1("%s: ", "a"); if (a) {debug2("%02x %s\n", *a, a + 1);} else debug("NULL\n");
X#endif
X
Xstatic void parse_builtin_tcap __ARGS((Tcarr *tc, char *s));
X
X/*
X * Builtin_tcaps must always contain DFLT_TCAP as the first entry!
X * DFLT_TCAP is used, when no terminal is specified with -T option or $TERM.
X * The entries are compact, therefore they normally are included even when
X * TERMCAP is defined.
X * When TERMCAP is defined, the builtin entries can be accessed with
X * "builtin_amiga", "builtin_ansi", "builtin_debug", etc.
X */
Xstatic char *builtin_tcaps[] =
X{
X#ifndef NO_BUILTIN_TCAPS
X  DFLT_TCAP,		/* almost allways included */
X# if !defined(UNIX) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
X  ANSI_TCAP,		/* default for unix */
X# endif
X# if !defined(AMIGA) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
X  AMIGA_TCAP,		/* default for amiga */
X# endif
X# if !defined(MSDOS) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
X  PCTERM_TCAP,		/* default for MSdos */
X# endif
X# if defined(MSDOS) || defined(ALL_BUILTIN_TCAPS)
X  PCANSI_TCAP,
X# endif
X# if !defined(ATARI) && defined(ALL_BUILTIN_TCAPS)
X  ATARI_TCAP,		/* default for Atari */
X# endif
X# if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
X  XTERM_TCAP,		/* always included on unix */
X# endif
X# ifdef ALL_BUILTIN_TCAPS
X  VT52_TCAP,
X# endif
X# if defined(DEBUG) || defined(ALL_BUILTIN_TCAPS)
X  DEBUG_TCAP,		/* always included when debugging */
X# endif
X#else /* NO_BUILTIN_TCAPS */
X  DUMB_TCAP,		/* minimal termcap, used when everything else fails */
X#endif /* NO_BUILTIN_TCAPS */
X  NULL,
X};
X
X/*
X * Term_strings contains currently used terminal strings.
X * It is initialized with the default values by parse_builtin_tcap().
X * The values can be changed by setting the parameter with the same name.
X */
XTcarr term_strings;
X
X/*
X * Parsing of the builtin termcap entries.
X * The terminal's name is not set, as this is already done in termcapinit().
X * Chop builtin termcaps, string entries are already '\0' terminated.
X * not yet implemented:
X *   boolean entries could be empty strings;
X *   numeric entries would need a flag (e.g. high bit of the skip byte),
X *   so that parse_builtin_tcap can handle them.
X */
X	static void
Xparse_builtin_tcap(tc, s)
X	Tcarr *tc;
X	char *s;
X{
X	char **p = &tc->t_name;
X
X	p++;
X	for (;;)
X    {
X		while (*s++)
X			;
X		p += *s++;
X		if (!*s)
X			return;
X		*p++ = s;
X    }
X}
X
X#ifdef TERMCAP
X# ifndef linux		/* included in <termlib.h> */
X#  ifndef AMIGA		/* included in proto/termlib.pro */
Xint				tgetent();
Xint				tgetnum();
Xchar			*tgetstr();
Xint				tputs();
X#  endif /* AMIGA */
X#  ifndef hpux
Xextern short	ospeed;
X#  endif
X# endif /* linux */
X# ifndef hpux
Xchar		*UP, *BC, PC;		/* should be extern, but some don't have them */
X# endif
X#endif /* TERMCAP */
X
X	void
Xset_term(term)
X	char *term;
X{
X	char **p = builtin_tcaps;
X#ifdef TERMCAP
X	int builtin = 0;
X#endif
X	int width = 0, height = 0;
X
X	if (!strncmp(term, "builtin_", (size_t)8))
X	{
X		term += 8;
X#ifdef TERMCAP
X		builtin = 1;
X#endif
X	}
X#ifdef TERMCAP
X	else
X	{
X		char			*p;
X		static char		tstrbuf[TBUFSZ];
X		char			tbuf[TBUFSZ];
X		char			*tp = tstrbuf;
X		int				i;
X
X		i = tgetent(tbuf, term);
X		if (i == -1)
X		{
X			emsg("Cannot open termcap file");
X			builtin = 1;
X		}
X		else if (i == 0)
X		{
X			emsg("terminal entry not found");
X			builtin = 1;
X		}
X		else
X		{
X			clear_termparam();		/* clear old parameters */
X		/* output strings */
X			T_EL = tgetstr("ce", &tp);
X			T_IL = tgetstr("al", &tp);
X			T_CIL = tgetstr("AL", &tp);
X			T_DL = tgetstr("dl", &tp);
X			T_CDL = tgetstr("DL", &tp);
X			T_ED = tgetstr("cl", &tp);
X			T_CI = tgetstr("vi", &tp);
X			T_CV = tgetstr("ve", &tp);
X			T_TP = tgetstr("me", &tp);
X			T_TI = tgetstr("mr", &tp);
X				/* if 'mr' or 'me' is not defined use 'so' and 'se' */
X			if (T_TP == NULL || *T_TP == NUL || T_TI == NULL || *T_TI == NUL)
X			{
X				T_TP = tgetstr("se", &tp);
X				T_TI = tgetstr("so", &tp);
X			}
X			T_CM = tgetstr("cm", &tp);
X			T_SR = tgetstr("sr", &tp);
X			T_CRI = tgetstr("RI", &tp);
X			T_VB = tgetstr("vb", &tp);
X			T_KS = tgetstr("ks", &tp);
X			T_KE = tgetstr("ke", &tp);
X			T_TS = tgetstr("ti", &tp);
X			T_TE = tgetstr("te", &tp);
X
X		/* key codes */
X			term_strings.t_ku = tgetstr("ku", &tp);
X			term_strings.t_kd = tgetstr("kd", &tp);
X			term_strings.t_kl = tgetstr("kl", &tp);
X				/* if cursor-left == backspace, ignore it (televideo 925) */
X			if (term_strings.t_kl != NULL && *term_strings.t_kl == Ctrl('H'))
X				term_strings.t_kl = NULL;
X			term_strings.t_kr = tgetstr("kr", &tp);
X			/* term_strings.t_sku = tgetstr("", &tp); termcap code unknown */
X			/* term_strings.t_skd = tgetstr("", &tp); termcap code unknown */
X			term_strings.t_sku = NULL;
X			term_strings.t_skd = NULL;
X			term_strings.t_skl = tgetstr("#4", &tp);
X			term_strings.t_skr = tgetstr("%i", &tp);
X			term_strings.t_f1 = tgetstr("k1", &tp);
X			term_strings.t_f2 = tgetstr("k2", &tp);
X			term_strings.t_f3 = tgetstr("k3", &tp);
X			term_strings.t_f4 = tgetstr("k4", &tp);
X			term_strings.t_f5 = tgetstr("k5", &tp);
X			term_strings.t_f6 = tgetstr("k6", &tp);
X			term_strings.t_f7 = tgetstr("k7", &tp);
X			term_strings.t_f8 = tgetstr("k8", &tp);
X			term_strings.t_f9 = tgetstr("k9", &tp);
X			term_strings.t_f10 = tgetstr("k;", &tp);
X			term_strings.t_sf1 = tgetstr("F1", &tp);	/* really function keys 11-20 */
X			term_strings.t_sf2 = tgetstr("F2", &tp);
X			term_strings.t_sf3 = tgetstr("F3", &tp);
X			term_strings.t_sf4 = tgetstr("F4", &tp);
X			term_strings.t_sf5 = tgetstr("F5", &tp);
X			term_strings.t_sf6 = tgetstr("F6", &tp);
X			term_strings.t_sf7 = tgetstr("F7", &tp);
X			term_strings.t_sf8 = tgetstr("F8", &tp);
X			term_strings.t_sf9 = tgetstr("F9", &tp);
X			term_strings.t_sf10 = tgetstr("FA", &tp);
X			term_strings.t_help = tgetstr("%1", &tp);
X			term_strings.t_undo = tgetstr("&8", &tp);
X
X			height = tgetnum("li");
X			width = tgetnum("co");
X
X# ifndef hpux
X			BC = tgetstr("bc", &tp);
X			UP = tgetstr("up", &tp);
X			p = tgetstr("pc", &tp);
X			if (p)
X				PC = *p;
X			ospeed = 0;
X# endif
X		}
X	}
X	if (builtin)
X#endif
X	{
X		while (*p && strcmp(term, *p))
X			p++;
X		if (!*p)
X		{
X			fprintf(stderr, "'%s' not builtin. Available terminals are:\r\n", term);
X			for (p = builtin_tcaps; *p; p++)
X#ifdef TERMCAP
X				fprintf(stderr, "\tbuiltin_%s\r\n", *p);
X#else
X				fprintf(stderr, "\t%s\r\n", *p);
X#endif
X			if (!starting)		/* when user typed :set term=xxx, quit here */
X			{
X				wait_return(TRUE);
X				return;
X			}
X			sleep(2);
X			fprintf(stderr, "defaulting to '%s'\r\n", *builtin_tcaps);
X			sleep(2);
X			p = builtin_tcaps;
X			free(term_strings.t_name);
X			term_strings.t_name = strsave(term = *p);
X		}
X		clear_termparam();		/* clear old parameters */
X		parse_builtin_tcap(&term_strings, *p);
X	}
X#if defined(AMIGA) || defined(MSDOS)
X		/* DFLT_TCAP indicates that it is the machine console. */
X	if (strcmp(term, *builtin_tcaps))
X		term_console = FALSE;
X	else
X	{
X		term_console = TRUE;
X# ifdef AMIGA
X		win_resize_on();		/* enable window resizing reports */
X# endif
X	}
X#endif
X	ttest(TRUE);
X		/* display initial screen after ttest() checking. jw. */
X	if (width <= 0 || height <= 0)
X    {
X		/* termcap failed to report size */
X		/* set defaults, in case mch_get_winsize also fails */
X		width = 80;
X#ifdef MSDOS
X		height = 25;		/* console is often 25 lines */
X#else
X		height = 24;		/* most terminals are 24 lines */
X#endif
X	}
X	Rows_max = Rows;		/* remember max. physical nr. of Rows */
X	set_winsize(width, height, FALSE);	/* may change Rows_max */
X}
X
X#if defined(TERMCAP) && defined(UNIX)
X/*
X * Get Columns and Rows from the termcap. Used after a window signal if the
X * ioctl() fails. It doesn't make sense to call tgetent each time if the "co"
X * and "li" entries never change. But this may happen on some systems.
X */
X	void
Xgetlinecol()
X{
X	char			tbuf[TBUFSZ];
X
X	if (term_strings.t_name && tgetent(tbuf, term_strings.t_name) > 0)
X	{
X		if (Columns == 0)
X			Columns = tgetnum("co");
X		if (Rows == 0)
X			Rows = tgetnum("li");
X	}
X}
X#endif
X
Xstatic char *tltoa __PARMS((unsigned long));
X
X	static char *
Xtltoa(i)
X	unsigned long i;
X{
X	static char buf[16];
X	char		*p;
X
X	p = buf + 15;
X	*p = '\0';
X	do
X	{
X		--p;
X		*p = i % 10 + '0';
X		i /= 10;
X    }
X	while (i > 0 && p > buf);
X	return p;
X}
X
X#ifndef TERMCAP
X
X/*
X * minimal tgoto() implementation.
X * no padding and we only parse for %i %d and %+char
X */
X
X	char *
Xtgoto(cm, x, y)
X	char *cm;
X	int x, y;
X{
X	static char buf[30];
X	char *p, *s, *e;
X
X	if (!cm)
X		return "OOPS";
X	e = buf + 29;
X	for (s = buf; s < e && *cm; cm++)
X    {
X		if (*cm != '%')
X        {
X			*s++ = *cm;
X			continue;
X		}
X		switch (*++cm)
X        {
X		case 'd':
X			p = tltoa((unsigned long)y);
X			y = x;
X			while (*p)
X				*s++ = *p++;
X			break;
X		case 'i':
X			x++;
X			y++;
X			break;
X		case '+':
X			*s++ = (char)(*++cm + y);
X			y = x;
X			break;
X        case '%':
X			*s++ = *cm;
X			break;
X		default:
X			return "OOPS";
X		}
X    }
X	*s = '\0';
X	return buf;
X}
X
X#endif /* TERMCAP */
X
X/*
X * Termcapinit is called from main() to initialize the terminal.
X * The optional argument is given with the -T command line option.
X */
X	void
Xtermcapinit(term)
X	char *term;
X{
X	if (!term)
X		term = (char *)vimgetenv("TERM");
X	if (!term || !*term)
X		term = *builtin_tcaps;
X	term_strings.t_name = strsave(term);
X	set_term(term);
X}
X
X/*
X * the number of calls to mch_write is reduced by using the buffer "outbuf"
X */
X#undef BSIZE			/* hpux has BSIZE in sys/param.h */
X#define BSIZE	2048
Xstatic u_char			outbuf[BSIZE];
Xstatic int				bpos = 0;		/* number of chars in outbuf */
X
X/*
X * flushbuf(): flush the output buffer
X */
X	void
Xflushbuf()
X{
X	if (bpos != 0)
X	{
X		mch_write((char *)outbuf, bpos);
X		bpos = 0;
X	}
X}
X
X/*
X * outchar(c): put a character into the output buffer.
X *			   Flush it if it becomes full.
X */
X	void
Xoutchar(c)
X	unsigned	c;
X{
X#ifdef UNIX
X	if (c == '\n')		/* turn LF into CR-LF (CRMOD does not seem to do this) */
X		outchar('\r');
X#endif
X	outbuf[bpos] = c;
X	++bpos;
X	if (bpos >= BSIZE)
X		flushbuf();
X	if (c == '\n')
X		char_count += Columns;
X	else
X		++char_count;
X}
X
X/*
X * a never-padding outstr.
X * use this whenever you don't want to run the string through tputs.
X * tputs above is harmless, but tputs from the termcap library 
X * is likely to strip off leading digits, that it mistakes for padding
X * information. (jw)
X */
X	void
Xoutstrn(s)
X	char *s;
X{
X	if (bpos > BSIZE - 20)		/* avoid terminal strings being split up */
X		flushbuf();
X	while (*s)
X		outchar(*s++);
X}
X
X/*
X * outstr(s): put a string character at a time into the output buffer.
X * If TERMCAP is defined use the termcap parser. (jw)
X */
X	void
Xoutstr(s)
X	register char			 *s;
X{
X	if (bpos > BSIZE - 20)		/* avoid terminal strings being split up */
X		flushbuf();
X	if (s)
X#ifdef TERMCAP
X		tputs(s, 1, TPUTSFUNCAST outchar);
X#else
X		while (*s)
X			outchar(*s++);
X#endif
X}
X
X/* 
X * cursor positioning using termcap parser. (jw)
X */
X	void
Xwindgoto(row, col)
X	int		row;
X	int		col;
X{
X	outstr(tgoto(T_CM, col, row));
X}
X
X/*
X * Set cursor to current position.
X * Should be optimized for minimal terminal output.
X */
X
X	void
Xsetcursor()
X{
X	if (!RedrawingDisabled)
X		windgoto(Cursrow, Curscol);
X}
X
X	void
Xttest(pairs)
X	int	pairs;
X{
X	char buf[70];
X	char *s = "terminal capability %s required.\n";
X	char *t = NULL;
X
X#ifdef TTEST
X  TTEST(T_EL);
X  TTEST(T_IL);
X  TTEST(T_CIL);
X  TTEST(T_DL);
X  TTEST(T_CDL);
X  TTEST(T_ED);
X  TTEST(T_CI);
X  TTEST(T_CV);
X  TTEST(T_TP);
X  TTEST(T_TI);
X  TTEST(T_CM);
X  TTEST(T_SR);
X  TTEST(T_CRI);
X#endif /* TTEST */
X
X  /* hard requirements */
X	if (!T_ED || !*T_ED)	/* erase display */
X		t = "cl";
X	if (!T_CM || !*T_CM)	/* cursor motion */
X		t = "cm";
X
X	if (t)
X    {
X    	sprintf(buf, s, t);
X    	emsg(buf);
X    }
X
X	if (pairs)
X	{
X	  /* optional pairs */
X		if ((!T_TP || !*T_TP) ^ (!T_TI || !*T_TI))
X		{
X			debug2("cap :me=%s:mr=%s: ignored\n", T_TP, T_TI);
X			T_TP = T_TI = NULL;
X		}
X		if ((!T_CI || !*T_CI) ^ (!T_CV || !*T_CV))
X		{
X			debug2("cap :vi=%s:ve=%s: ignored\n", T_CI, T_CV);
X			T_CI = T_CV = NULL;
X		}
X	}
X}
X
X/*
X * inchar() - get one character from
X *		1. a scriptfile
X *		2. the keyboard
X *
X *  As much characters as we can get (upto 'maxlen') are put in buf and
X *  NUL terminated (buffer length must be 'maxlen' + 1).
X *
X *	If we got an interrupt all input is read until none is available.
X *
X *  If time == 0  there is no waiting for the char.
X *  If time == n  we wait for n msec for a character to arrive.
X *  If time == -1 we wait forever for a character to arrive.
X *
X *  Return the number of obtained characters.
X */
X
X	int
Xinchar(buf, maxlen, time)
X	char	*buf;
X	int		maxlen;
X	int		time;						/* milli seconds */
X{
X	int				len;
X	int				retesc = FALSE;		/* return ESC with gotint */
X	register int 	c;
X	register int	i;
X
X	if (time == -1)				/* flush output before blocking */
X		flushbuf();
X	did_outofmem_msg = FALSE;	/* display out of memory message (again) */
X
X/*
X * first try script file
X *	If interrupted: Stop reading script files.
X */
Xretry:
X	if (scriptin[curscript] != NULL)
X	{
X		if (got_int || (c = getc(scriptin[curscript])) < 0)	/* reached EOF */
X		{
X				/* when reading script file is interrupted, return an ESC to
X									get back to normal mode */
X			if (got_int)
X				retesc = TRUE;
X			fclose(scriptin[curscript]);
X			scriptin[curscript] = NULL;
X			if (curscript > 0)
X				--curscript;
X				/* recovery may be delayed till after reading a script file */
X			if (recoverymode)
X				openrecover();
X			goto retry;		/* may read other script if this one was nested */
X		}
X		if (c == 0)
X			c = K_ZERO;		/* replace ^@ with special code */
X		*buf++ = c;
X		*buf = NUL;
X		return 1;
X	}
X
X/*
X * If we got an interrupt, skip all previously typed characters and
X * return TRUE if quit reading script file.
X */
X	if (got_int)			/* skip typed characters */
X	{
X		while (GetChars(buf, maxlen, T_PEEK))
X			;
X		return retesc;
X	}
X	len = GetChars(buf, maxlen, time);
X
X	for (i = len; --i >= 0; ++buf)
X		if (*buf == 0)
X			*(u_char *)buf = K_ZERO;		/* replace ^@ with special code */
X	*buf = NUL;								/* add trailing NUL */
X	return len;
X}
X
X/*
X * Check if buf[] begins with a terminal key code.
X * Return 0 for no match, -1 for partial match, > 0 for full match.
X * With a match the replacement code is put in buf[0], the match is
X * removed and the number characters in buf is returned.
X */
X	int
Xcheck_termcode(buf)
X	char	*buf;
X{
X	char 	**p;
X	int		slen;
X	int		len;
X
X	len = strlen(buf);
X	for (p = (char **)&term_strings.t_ku; p != (char **)&term_strings.t_undo + 1; ++p)
X	{
X		if (*p == NULL || (slen = strlen(*p)) == 0)		/* empty entry */
X			continue;
X		if (strncmp(*p, buf, (size_t)(slen > len ? len : slen)) == 0)
X		{
X			if (len >= slen)		/* got the complete sequence */
X			{
X				len -= slen;
X				memmove(buf + 1, buf + slen, (size_t)(len + 1));
X					/* this relies on the Key numbers to be consecutive! */
X				buf[0] = K_UARROW + (p - (char **)&term_strings.t_ku);
X				return (len + 1);
X			}
X			return -1;				/* got a partial sequence */
X		}
X	}
X	return 0;						/* no match found */
X}
X
X/*
X * outnum - output a (big) number fast
X */
X	void
Xoutnum(n)
X	register long n;
X{
X	outstrn(tltoa((unsigned long)n));
X}
X 
X/*
X * outnuml - output a (big) number fast and return the number of characters
X */
X	int
Xoutnuml(n)
X	register long n;
X{
X	char *s;
X
X	s = tltoa((unsigned long)n);
X	outstrn(s);
X	return (int)strlen(s);
X}
X 
X	void
Xcheck_winsize()
X{
X	if (Columns < 5)
X		Columns = 5;
X	else if (Columns > MAX_COLUMNS)
X		Columns = MAX_COLUMNS;
X	if (Rows < 2)
X		Rows = 2;
X	p_scroll = Rows >> 1;
X}
X
X/*
X * set window size
X * If 'mustset' is TRUE, we must set Rows and Columns, do not get real
X * window size (this is used for the :win command during recovery).
X * If 'mustset' is FALSE, we may try to get the real window size and if
X * it fails use 'width' and 'height'.
X */
X	void
Xset_winsize(width, height, mustset)
X	int		width, height;
X	int		mustset;
X{
X	register int 		tmp;
X
X	if (width < 0 || height < 0)	/* just checking... */
X		return;
X
X	if (State == HITRETURN || State == SETWSIZE)	/* postpone the resizing */
X	{
X		State = SETWSIZE;
X		return;
X	}
X	screenclear();
X#ifdef AMIGA
X	flushbuf(); 		/* must do this before mch_get_winsize for some obscure reason */
X#endif /* AMIGA */
X	if (mustset || mch_get_winsize())
X	{
X		debug("mch_get_win failed\n");
X		Rows = height;
X		Columns = width;
X		mch_set_winsize();
X	}
X	check_winsize();		/* always check, to get p_scroll right */
X	if (State == HELP)
X		redrawhelp();
X	else if (!starting)
X	{
X		tmp = RedrawingDisabled;
X		RedrawingDisabled = FALSE;
X		comp_Botline();
X		updateScreen(CURSUPD);
X		RedrawingDisabled = tmp;
X		if (State == CMDLINE)
X			redrawcmdline();
X		else
X			setcursor();
X	}
X	flushbuf();
X}
X
X/*
X * set active window height (for "z<number><CR>" command)
X */
X	void
Xset_winheight(height)
X	int		height;
X{
X	if (height > Rows_max)			/* can't make it larger */
X		height = Rows_max;
X	Rows = height;
X	check_winsize();
X	updateScreen(CLEAR);
X}
X
X	void
Xsettmode(raw)
X	int	 raw;
X{
X	static int		oldraw = FALSE;
X
X	if (oldraw == raw)		/* skip if already in desired mode */
X		return;
X	oldraw = raw;
X
X	mch_settmode(raw);	/* machine specific function */
X}
X
X	void
Xstarttermcap()
X{
X	outstr(T_KS);	/* start "keypad transmit" mode */
X	outstr(T_TS);	/* start termcap mode */
X	flushbuf();
X	termcap_active = TRUE;
X}
X
X	void
Xstoptermcap()
X{
X	outstr(T_KE);	/* stop "keypad transmit" mode */
X	outstr(T_TE);	/* stop termcap mode */
X	flushbuf();
X	termcap_active = FALSE;
X}
X
X/*
X * enable cursor, unless in Visual mode or no inversion possible
X */
X	void
Xcursor_on()
X{
X	if (!Visual.lnum || T_TI == NULL || *T_TI == NUL)
X		outstr(T_CV);
X}
X
X	void
Xcursor_off()
X{
X	outstr(T_CI);			/* disable cursor */
X}
END_OF_FILE
if test 18021 -ne `wc -c <'vim/src/term.c'`; then
    echo shar: \"'vim/src/term.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/term.c'
# end of 'vim/src/term.c'
fi
echo shar: End of archive 8 \(of 25\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
