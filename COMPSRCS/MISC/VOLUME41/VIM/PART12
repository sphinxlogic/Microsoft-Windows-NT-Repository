Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i062:  vim - Vi IMitation editor, v2.0, Part12/25
Message-ID: <1993Dec21.035036.28379@sparky.sterling.com>
X-Md4-Signature: 280646c5e2a950ad3a4719a4d0f2848b
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:50:36 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 62
Archive-name: vim/part12
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 12 (of 25)."
# Contents:  vim/readme2.0 vim/src/param.c
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/readme2.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/readme2.0'\"
else
echo shar: Extracting \"'vim/readme2.0'\" \(23966 characters\)
sed "s/^X//" >'vim/readme2.0' <<'END_OF_FILE'
XThis is a summary of the modifications from Vim version 1.27 to version 2.0.
X
XIncompatible changes
X====================
X
XThe 'exrc' and 'secure' options are default off. If you want Vim to read a
X.exrc or .vimrc in the current directory, you will have to set 'exrc' in your
Xglobal .exrc or .vimrc. People doing this are supposed to know about the
Xsecurity problems, so they don't need the 'secure' option set. This is also
Xmore vi-compatible.
X
XRenamed quoting to visual select and swapped 'q' and 'v' keys to avoid
Xproblems with CTRL-Q. This is also more Elvis compatible. The commands now are:
X	'v'		start character-wise visual select
X	'V'		start line-wise visual select
X	CTRL-V		start block-wise visual select
X
X	'q'		start recording
X	'Q'		formatting operator
X
XChanged CTRL-R into CTRL-Y for insert mode (copy character from line above).
XThis is more logical when comparing the meaning of CTRL-E and CTRL-Y in
Xcommand mode and insert mode.
X
XReplaced CTRL-B with CTRL-R (insert contents of a register) in insert mode.
XThis mnemonic is more logical, because "register" is used in the documentation. 
X
XAdded ":pwd" command and made ":cd" without an argument for Unix go to home
Xdirectory. This is more vi-compatible and behaves the same as the unix cd
Xcommand. The ":cd" command for MSDOS and Amiga versions is unchanged, these
Xmachines don't have a home directory.
X
XWith the 'confirm' option to :s anything but 'y', 'n', ESC, CTRL-C or 'q' is
Xignored. Nothing happens until you type a valid character. Quit substitution
Xwith <q>, ESC and CTRL-C. 
X
XSwapped 'u' and 'U' for visual mode. 'u' makes lower case, 'U' upper. This is
Xmore logical.
X
XAdded 'wildchar' option for filename completion. The default is <TAB> instead
Xof <ESC>. Most other programs use this and it avoids problems with terminal
Xsequences that start with <ESC> (one second wait before filename completion
Xstarts).
X
XChanged short name of 'showmode' option from "mo" to "smd".
X
XChanged short name of 'modelines' from 'ml' into 'mls'. This is vi-compatible.
X
XChanged meaning of the argument to :cf. The 'errorfile' option will now be
Xset to the argument.
X
X
XMajor improvements
X==================
X
XAdded horizontal scrolling and 'wrap' option. This allows the user to choose
Xbetween line wrap (you see all the text but long lines mess up the layout)
Xand horizontal scrolling (correct layout but you see only a part of long
Xlines).
X
XAdded 'sidescroll' option. It is the number of columns to jump when the
Xcursor gets off of the screen while the 'wrap' option is off. The default is
X0, which means that the cursor is centered on the screen. Set it to a small
Xnumber if you have fast screen I/O.
X
XWildcard expansion has been made more compatible with other programs. Added
X'wildchar' option; default is <TAB> instead of <ESC>. With multiple matches
Xfirst match is inserted. CTRL-A inserts all matches. With CTRL-D command: If
Xfile is a dir '/' is added. WILD_CARDS code now always included, no
Xcompile-time option anymore. 'wildchar' is only recognized when typed, not in
Xa macro (prevents problems with macros containing TABs).
X
XCTRL-L on commandline inserts longest common part of filename completion. Now
Xyou can choose between using TAB (or 'wildchar') for getting the first match
Xor CTRL-L for getting the longest match.
X
XAdded automatic textmode (lines ending in CR-LF instead of LF) detection and
X'textauto' option. This works when starting to edit a file and when doing a
X":r" command. This is useful on MS-DOS systems with a network file system and
Xwhen editing an MS-DOS floppy on Unix or Amiga. Added [(no)textmode] message
Xto readfile() and writeit(). Now you can see when unexpected line separators
Xhave been detected or are being used.
X
XAdded "-b" command line option. This makes it more easy to edit binary files
Xwithout unexpected effects.
X
XAdded ":make" command, 'errorformat' option and argument to -e option. Now you
Xcan do your compiling from within Vim and automatically jump to the line where
Xthe error is. Can be adjusted to work with many compilers. The command to be
Xexecuted with ":make" can be set with the  'makeprg' option. '%' and '#' in
Xthe 'makeprg' option are expanded as usual in a command line. 
X
XAdded reverse insert mode, 'revins' option and CTRL-P command. Now you can
Xtype backwards!
X
XAdded abbreviations. They work in insert mode and in command line mode, just
Xlike Vi. Also added :iabbr, :cabbr and friends: abbreviations for command line
Xonly or insert mode only. Added dumping of abbreviations to :mkexrc.
X
XAdded ":center" (center the lines), ":left" (left adjustment) and ":right"
X(right adjustment). ":center" and ":right" use the 'textwith' option.
X
XAdded bios calls for MSDOS screen output, ansi.sys no longer required.
XScreen updating much faster now and works with more video modes. Added pcansi
Xtermcap for when not using the console.
X
X
XOther improvements
X==================
X
XIf 'expandtab' is set, spaces will also be used in indents.
X
X'tabstop' maximum removed.
X
XDigraphs also work in the command line.
X
XAdded :redo, same as CTRL-R.
X
XAdded '-x' option for the Amiga version. The current window will be used, but
Xshell commands are not possible. Handy when starting Vim from a mail program.
X
XAdded 'secure' option. When reset you don't get the warnings from reading a
X.vimrc/.exrc file in the current directory.
X
XAdded 'exrc' option. Now you can switch the reading of ".exrc/.vimrc" off.
X
XAdded "vim:" modelines. Other vi versions allowed all ex commands in
Xmodelines, vim only allows set commands. Use "vim:" to avoid confusion.
X
XOptimized position of ruler and shown command.
X
XImproved redrawing of long command lines.
X
XAdded <SC_UP> and <SC_DOWN> to command line editing. This finds the
Xnext/previous command that starts with the text in front of the cursor.
X
XAdded CTRL-B and CTRL-E to command line editing. Go to begin/end of the
Xcommand line.
X
XWith ":w!" readonly is reset.
X
XIf possible the cursor is switched off while visual selecting. Makes it more
Xclear what is selected.
X
XFormat deletes blanks at end of lines. This makes it possible to use
Xformatting to limit the text to a certain number of columns (e.g. 80).
X
XModelines quits after first error. This avoids a long list of errors when
Xediting a text with "vi:" accidently embedded (e.g. vim.hlp).
X
XOptimized undo for delete. Now only 2/3 of the memory used and less copying of
Xlines. Speed up when deleting a lot of lines in a big file.
X
XAdded :suspend, same as CTRL-Z.
X
XAdded command-line-only mapping ":cmap", insert-mode-only ":imap" and the
Xassociated unmap and noremap commands. Now you can enter mappings for every
Xmode (command/insert/command-line) separately.
X
XChanged smart-indent a little.
X
XNow one free chunk list per allocated block in storage.c. Makes editing big
Xfiles a bit faster.
X
XAdded repeat to visual select. now you can select the same area again.
X
XImproved showmatch() for uneven number of quotes.
X
XAdded 'paste' option. This makes it easy to swith between typing and inserting
Xtext with a cut/paste method. Doing ":set nopaste" before ":set paste" does
Xnot do anything. 
X
XAdded sFilename: Filename without path. Mostly only the name you typed is
Xshown, but internally the full path name is remembered. Otherwise the ":cd"
Xcommand would mess up the real file name. Use short file name as long as :cd
Xnot used. If one does not use :cd the short file name will be valid. This
Xwill avoid long path names to be printed on the status line and having to
X"hit return to continue". It is also better to avoid problems with some
Xnetworks where the absolute path is not valid after a while. If :cd has been
Xused the full path name needs to be used to get to the right file.
X
XChanged :digraph in :digraphs. Now "digraph" and "digraphs" both work.
X
XAdded emsg2() for more informative error messages. For example: "Cannot open
X<filename> for writing" with :mkexrc.
X
XMade 'r' command use get_literal(). Now you enter the decimal code for the
Xreplacement character with CTRL-V nnn, where nnn is any decimal number.
X
XAdded default digraphs for MSDOS.
X
XAdded 'timoutlen' option. One can set this depending on the speed of the
Xterminal used. Helps when cursor keys start with ESC while working on the
Xconsole: get out of insert mode fast. Or when using a terminal over a very
Xslow line, although you better set 'notimeout' then.
X
XAdded wildcard expansion to tags, so environment variables in the file name
Xget expanded.
X
XNo error message for a non-existant tags file, only for a not-found tag.
X
XExpandWildCards() in unix.c does not start the shell when there are no
Xwildcards. Speeds up editing new files.
X
X:set can now show several values in one command, e.g. ":set columns lines".
X
XIn MSDOS use $COMSPEC to init 'shell' option.
X
XAdded 'formatprg' option for external formatting. This is the program to use
Xwhen the 'Q' command is given. If it is an empty string (which is the
Xdefault) the internal formatting is used.
X
XMade ioctl() first in mch_get_winsize() in unix.c. The environment variables
Xare now only used if the ioctl() fails. This works without problems on more
Xsystems.
X
XAdded second column number to ruler. Now you can see both the column number
Xin the file and on the screen.
X
XWith MSDOS also accept '/' as file name separator. Works better in combination
Xwith 4dos.
X
XScreen redrawn after t_tp set. You can now directly see the result of the new
Xcolors.
X
XImproved error handling from write() in writeit(). Made the write_buf
Xfunction to repeat write() until all characters have been written or an error
Xis detected. Fixes a possible problem with signals (which has never been
Xreported).
X
XWorkaround for cursor key that sends ^H. The televideo 925 sends codes for
Xcursor keys that cannot be distinguished from normal commands. At least the
Xbackspace is working again now.
X
XIf you are using a csh use 'glob' instead of 'echo' in WildExpand in unix.c.
XThis makes it possible to find file names with embedded spaces. Spaces in the
Xentered file name are still not possible (vi can't do it either).
X
XCall_shell() in unix.c uses fork/exec instead of system. This makes it about
Xtwice as fast and fixes problems with special characters in the command, e.g.
X"!!awk '{ print "ok" }'.
X
XFixed call_shell in amiga.c for space in shell option. You can now give
Xoptions to the shell command, but the name of the shell cannot contain
Xspaces anymore (big deal).
X
XWarn if no inversion is possible. Poor user, now you can't use visual select.
X
XUse termcap entries 'se' and 'so' when 'mr' or 'me' are not available. Makes
Xusing inversion possible on more terminals.
X
XAdded 'esckeys' option. If your special keys have codes that start with an
XESC you can switch them off in insert mode. When typing ESC you will
Xdirectly exit insert mode, instead of having to wait for more characters to
Xfind out if it might be a special key.
X
XAdded register name "% for the current file name. Handy when you want to use
Xthe current file name in macros.
X
XAdded <"> as a name for the unnamed register. Added the use of more registers
Xto some commands.
X
XAdded expansion of environment variable to most string parameters. Any non-id
Xcharacter can be used after the environment variable name.
X
XTrailing '/' in 'dir' option not required.
X
XAdded [Not edited] message to ":file".
X
XIf errors occur when starting to edit a file (e.g. out of memory) the
Xreadonly flag is set to prevent accidently overwriting the original file with
Xa truncated version.
X
XTrailing spaces are removed from ":" commands (except map, abbreviate, ":s",
X":g" and ":!" commands and after <|>). Useful when accidently typing a space
Xafter a filename.
X
XAdded TIOCLGET to mch_settmode() in unix.c. Restores some terminal settings
Xafter exiting Vim.
X
XA "recursive mapping" followed by another "recursive mapping" would loop
Xvery long.
X
XAllow entering CTRL-@ in command line mode.
X
XAdded 'A' - 'Z' for helpfile pages. You can add your own pages if you like.
X
XDisplay several help pages at once on a big screen.
X
XDon't give ".vim file exists" message when recovering.
X
XPut command line terminated with ESC in history. If you accidently try to
Xuse ESC for wildcard completion, you can get back what you typed.
X
XChanged display method for CTRL-D on command line. Now the redraw is done
Xafter the whole command line has been entered. Big speed win on slow
Xterminals.
X
XDon't call flushbuf() in normal() when p_sc is off (speeds up "x").
X
XDon't redisplay in main() when there is something in the stuff buffer. Speeds
Xup display a bit.
X
X:tag shows short filename. Reduces the need for "hit return to continue".
X
XAdded "#<" for command line: current filename without extension.
X
XChanged digraphs 208 and 240. Fixed digraph 172.
X
XIn help mode the keys CTRL-B and CTRL-F go one page back or forward. With
XMSDOS page-up and page-down can also be used.
X
XImplemented the drive specifier for the :cd command on MSDOS, ":cd c:" goes
Xto the C drive.
X
XImplemented FullName for msdos. Makes ":cd" really work.
X
XWhen the cursor is off the screen, put it at 1/2 of the screen. Used to be 1/3
Xor 2/3, depending on the direction.
X
X
XBug fixes
X=========
X
XFixed small screen updating bug in dodelete().
X
XInserting tab in Replace mode with 'et' option set did not delete char.
X
XFixed bug when start and end of operator are the same, e.g. "^d^".
X
XFixed 'w' on last word in file and 'b' on first word in the file.
X
XFixed 'dw' on empty line.
X
XFixed storage.c for 64 bit longs.
X
XFixed :w[!]>>newfile. Without the '!' the file must already exist.
X
XIn insert mode ^O had to be typed twice before the change command.
X
XFixed ":r !ls *". Wildcard expansion was done on "!ls".
X
XChanged flag not reset with ":w !wc".
X
XAfter CTRL-C go to normal mode. You could end up in insert mode when
Xinterrupting a macro (e.g. with the maze solving macros).
X
Xdoarglist() called FreeWild() with argv[]. This could cause a crash!
X
XRepaired FullName() in unix.c. Now "../" and links are correctly dealth with.
XAdded error handling. If a file or directory does not exist this is dealth
Xwith correctly.
X
XFixed ":g/pat/p". There is now a wait for "hit return" at the end.
XAlso fixed a double redraw.
X
XChanged key codes for MSDOS. The old ones overlapped with a few useful
Xaccented characters. Now only some graphics characters cannot be entered
Xdirectly from the keyboard.
X
XDelete "recording" when p_smd is off.
X
XFixed ":/pat" on last line. It would give an "illegal nr" error.
X
XFixed "invalid chunk" bug in insertchar(). Too many blanks were deleted when
Xdoing text formatting when the cursor is just after several blanks.
X
XBlockwise quoting did not work with upper case operators.
X
XRemoved forceit from getfile(); makes autowrite work with CTRL-^ after :n!.
X
XNo beep when search fails. When errorbells option was set you would get two
Xbeeps.
X
XIsdir() in msdos.c now returns -1 when file does not exist. It would see a
Xnon-existant file as a directory.
X
XFixed [new file] message for MSDOS.
X
XFixed screen updating in edit.c when entering CTRL-V TAB in front of a TAB.
XThe '^' would not be deleted.
X
XMade t_ options working again. You couldn't set them at all!
X
XSetting a terminal option to an empty string caused a hang.
X
XChanged flag was set for an option when it was printed.
X
XFixed makeset() for spaces in string options. Now a backslash is prepended.
X
XFixed makemap() for special characters. Now a CTRL-V is prepended.
X
XFixed dosource() for a line containing CTRL-V newline. The following line is
Xnow appended.
X
XMakeset() and makemap() add '\r' for MSDOS.
X
X'r' command no longer uses replace mode, except for CR, LF and TAB. Some
Xreplacement characters would give strange results, e.g. CTRL-O.
X
XFixed screen updating with ":s/a/A/gc". Now the screen is updated after each
Xreplacement, not after finishing a line.
X
XFixed MSDOS problem in lalloc(): Cannot handle block >64K.
X
XFixed bug in writeit(): Faulty write to memory when write() fails. This was a
Xnasty one, caused my Amiga to crash when writing to a full disk!
X
XFixed problem with cursor keys in xterm. This stupid terminal emulator sends
Xonly one character at each read().
X
XFixed problem with linewise visual and 'o' command. The column would be
Xchanged, making the visual mode character wise.
X
XFixed bug in u_undoredo() when newsize and oldsize are both zero. You would
Xget an error message when doing "!!foo", 'u', CTRL-R, 'u', when the command
X'foo' does not exist.
X
XFixed bug: not doing all lines with ":%s/ /^M/g" in dosub(). The number of
Xlines processed was not incremented by the number of new lines created.
X
XFixed crash caused by call to MatchEnd() while using ARP. This would mean
Xthat you could not use Vim with DOS 1.3. Only one person complained! Is
Xnobody using 1.3 anymore?
X
XIn out-of-memory situations writeit() would fail. It needed to allocate a
Xbuffer of 4K. It would be impossible to save your changes! Now a small
Xemergency buffer is used.
X
XFixed illegal memory access when not-set terminal option was printed.
X
XFixed hang with V~ on last line in file when the line was empty.
X
XFixed crash when typing "//".
X
XUpdated builtin termcap entry for xterm. Function keys now work.
X
XFixed bug with allocating argv in call_shell() for unix. Could cause a crash.
X
XFixed deletion of "no write since last change" message with :q command.
X
XAdded call to screenalloc() in screenclear(), fixes crash when resizing
Xwindow while viewing help. 
X
XFixed screen updating with '$' in block mode.
X
XRedisplay INSERT message after visual bell.
X
XFixed backspace in column 1 in reverse insert mode.
XFixed "illegal nr" when doing i^P^H in an empty file.
X
XFixed ruler on empty line. Column number was wrong.
X
XTypehead not flushed with every error, fixes problems with 'notimeout' and
Xerrors in scripts (recovery!).
X
XNo beep with "qxq".
X
XAdded setting of Changed flag to readfile(), needed for :r !cmd.
X
XJumplist entries were not deleted properly, causing "no alternate file" and
X"illegal nr" errors.
X
XFixed entering CTRL-V CTRL-@ in insert mode.
X
XDefault values for 'showcommand' and 'showmode' for unix exchanged.
X
XPut braces around filter command for unix, allows ":r! echo this; echo that".
X
XFixed screen redraw after ".vim file exists" message with :e command.
X
XChanged CTRL-W for insert mode: stop before spaces.
X
XWhen changing more than 8000 lines at once undo is prohibited on Amiga and
XMSDOS (used to cause out of memory errors with "10000dd").
X
XFixed problem with undo after delete without undo. (?)
X
XFixed error messages with ":set".
X
XTerminal type not reset to default with ":set term=xxx", where xxx is not a
Xvalid terminal type.
X
XFixed problem in search pattern: With 'ignorecase' set the first character
Xafter '*' was case-sensitive.
X
XUpdate screen with ":g/the/s//THE/c".
X
XWith "hit return" use command-mode mappings.
X
XFixed "(" and ")" for sentence ending at end of line.
X
XFixed screen updating with very long lines. Cursor could end up in the middle
Xof nowhere.
X
XFixed message for yank with blockwise visual (was one line off).
X
XFixed :copy when destination is within source range.
X
X"r" in visual mode wanted to get another character.
X
XWith 'nowrapscan' "Q}" scrolled the screen horizontally.
X
XDon't allocate screen if Rows or Columns is 0.
X
XFixed CTRL-D in insert mode: First round indent to multiple of shiftwidth.
X
X"z<number><CR>" is limited to physical screen height. Fixes screen updating
Xproblems when set to large number. Also fixed screen updating for CTRL-D on
Xcommand line and for ":set all".
X
XRe-inserted forceit in getfile to make ":ta!" work. Now forceit is reset at
Xthe end of DoOneCmd() to keep CTRL-^ working.
X
XCheck for :unmap without valid number of arguments in domap(). Ctrl-V was
Xremoved twice from :unmap.
X
XAdded noremaplist in buffers.c; makes mixing @a and noremap mappings work.
X
XDo not check for terminal-code in mapped characters.
X
XRecording now stores the trailing 'q' in the register; the 'q' command is
Xdisabled while executing a register (solves problem when final 'q' is result
Xfrom mapping).
X
XFixed '\~' in substitute string being recognized as '~'.
X
XFixed ":s/ */ /g", inserted one space per line instead of one space per
Xcharacter.
X
XFixed ungetchr() in regexp.c: backslashed characters were not handled
Xcorrectly.
X
XFixed screen being messed up with long commands when 'sc' is set.
X
X
XVi-compatibility fixes
X======================
X
XWhen not editing last file in a file list, typing :q twice will quit.
X
XAdded [readonly] to fileinfo(). 
X
XUndo in macros allowed. But it only works correctly once.
X
XAdded hidden options to avoid error messages when reading .exrc.
X
XAllow '-ttag' (no space after -t) on command line.
X
XChanged short name for 'showmode' option from "mo" to "smd".
X
XAdded check for "view" in main(). Vim will start in readonly mode. On Unix you
Xcan make a link from "view" to "vim".
X
XUndo keeps marks if line count does not change.
X
XFixed operators to be linewise in some cases.
X
XCTRL-Z is :stop instead of :stop!.
X
X'}' command does not stop at '{' at start of line.
X
XWith :s lines are split at CR, unless preceded with a CTRL-V. In fact this is
Xbetter than Vi, because vi can't insert a CR in the text with :s.
X
XTextwidth now off when 0, also when wrapmargin set to 0.
X
XFixed autoindent when inserting <CR> in front of some blanks.
X
XRemoved 'repdel' option: BS in replace mode puts replaced character back
X(within one line).
X
XOption 'sect' short for 'sections'.
X
XAdjusted 'M' when '~' lines on screen. Now put cursor in the middle of the
Xlines that are present on the screen, not on the middle of the screen.
X
XMultiple spaces to separate fields in tags file allowed.
X
XDEL displayed as ^? instead of ~?.
X
XAdded 'mesg', 'edcompatible', 'modeline', 'sourceany' and 'ttytype' options.
XOnly 'edcompatible' is really implemented.
X
XAdded test for trying to edit/read/write a direcory. Now you get an error
Xmessage instead of [new file] (on Amiga/MSDOS) or garbage (Unix).
X
X'%' now works on \(this\).
X
XIn UNIX and MSDOS ignore spaces after filename. In Amiga the spaces may be
Xpart of the filename, on other systems this is very unlikely.
X
XMoved code from inchar() to vgetorpeek(): Key sequences can now be mapped
Xbefore recogized as key codes. But they are still stored with a special code
Xin the script files, which makes them terminal-independent.
X
XAdded recognition of vi-compatible modeline with set command.
X
XImplemented 'warn' option.
X
XAdded CTRL-W to command line editing.
X
XImplemented 0^D and ^^D in insert mode.
X
XNon-linewise deletes within one line do not go into numbered registers.
X
XSet previous context mark with 'L', 'M' and 'H' commands.
X
XMake "cc" work like "S": indent not deleted when 'autoindent' set.
XCTRL-U in insert mode does not delete indent when 'autoindent' set.
X
XWith the "J" command the cursor is put just after the first line instead of
Xat the start of the second.
X
XConcatenated mapstr and typestr in buffers.c; makes ":map x y" ":map yz foo"
Xwork (mixing mapped and typed characters in another mapping).
X
XCTRL-C quits command line and insert mode.
X
XESC in macro executes command line (but typed ESC still quits command line).
X
XDeleted "#include <ctype.h>" from regexp.c.
X
XCall_shell does not always use cooked mode, fixes problem with typing CR
Xwhile doing filename completion in unix.
X
XFixed return value for FullName in unix.c.
X
XRemoved redraw on exit for msdos.
X
X":v" without argument was not handled correctly in doglob().
X
XCR-LF in tags file was not handled correctly.
X
X
XPorting
X=======
X
XAdded _UNIX to BSD and SYSV because 'BSD' already used by Alpha.
X
XAdded three changes for Apollo DOMAIN.
X
XAdded a few things for Amdahl UTS.
X
XUse fork() in unix.c, not all systems have vfork().
X
XAdded POSIX compatible file type checking.
X
XAdded small changes for USL 4.2.
X
XAdded additional set of termcap entries for terminfo.
X
XAdded memmove() function for SYSV. Not all versions of memcpy() can handle
Xoverlapped areas.
X
XSmall fixes for a few unix versions: AIX (on rs6000) and NeXT.
X
XChanged SETWINSIZE to SETWSIZE and a few other changes for Convex.
X
XAdded a few changes for Borland C++. Phew, it compiles really fast!
X
XMany other small changes for different Unix versions.
END_OF_FILE
if test 23966 -ne `wc -c <'vim/readme2.0'`; then
    echo shar: \"'vim/readme2.0'\" unpacked with wrong size!
fi
chmod +x 'vim/readme2.0'
# end of 'vim/readme2.0'
fi
if test -f 'vim/src/param.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/param.c'\"
else
echo shar: Extracting \"'vim/src/param.c'\" \(23470 characters\)
sed "s/^X//" >'vim/src/param.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Code to handle user-settable parameters. This is all pretty much table-
X * driven. To add a new parameter, put it in the params array, and add a
X * variable for it in param.h. If it's a numeric parameter, add any necessary
X * bounds checks to doset().
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
Xstruct param
X{
X	char		*fullname;		/* full parameter name */
X	char		*shortname; 	/* permissible abbreviation */
X	int 		flags;			/* see below */
X	char		*var;			/* pointer to variable */
X};
X
X/*
X * Flags
X */
X#define P_BOOL			0x01	/* the parameter is boolean */
X#define P_NUM			0x02	/* the parameter is numeric */
X#define P_STRING		0x04	/* the parameter is a string */
X#define P_CHANGED		0x08	/* the parameter has been changed */
X#define P_EXPAND		0x10	/* environment expansion */
X
X/*
X * The param structure is initialized here.
X * The order of the parameters should be alfabetic
X * The parameters with a NULL variable are 'hidden': a set command for
X * them is ignored and they are not printed.
X */
Xstruct param params[] =
X{
X		{"autoindent",	"ai",	P_BOOL,		(char *)&p_ai},
X		{"autoprint",	"ap",	P_BOOL,		(char *)NULL},
X		{"autowrite",	"aw",	P_BOOL,		(char *)&p_aw},
X		{"backspace",	"bs",	P_NUM,		(char *)&p_bs},
X		{"backup",		"bk",	P_BOOL,		(char *)&p_bk},
X#ifdef UNIX
X 		{"backupdir",	"bdir",	P_STRING|P_EXPAND,	(char *)&p_bdir},
X#endif
X		{"beautify",	"bf",	P_BOOL,		(char *)NULL},
X		{"binary",		"bin",	P_BOOL,		(char *)&p_bin},
X#ifdef MSDOS
X		{"bioskey",		"biosk",P_BOOL,		(char *)&p_biosk},
X#endif
X		{"columns",		"co",	P_NUM,		(char *)&Columns},
X		{"compatible",	"cp",	P_BOOL,		(char *)&p_cp},
X#ifdef DIGRAPHS
X		{"digraph",		"dg",	P_BOOL,		(char *)&p_dg},
X#endif /* DIGRAPHS */
X 		{"directory",	"dir",	P_STRING|P_EXPAND,	(char *)&p_dir},
X		{"edcompatible",NULL,	P_BOOL,		(char *)&p_ed},
X		{"equalprg",	"ep",  	P_STRING|P_EXPAND,	(char *)&p_ep},
X		{"errorbells",	"eb",	P_BOOL,		(char *)&p_eb},
X		{"errorfile",	"ef",  	P_STRING|P_EXPAND,	(char *)&p_ef},
X		{"errorformat",	"efm", 	P_STRING,	(char *)&p_efm},
X		{"esckeys",		"ek",	P_BOOL,		(char *)&p_ek},
X		{"expandtab",	"et",	P_BOOL,		(char *)&p_et},
X		{"exrc",		NULL,	P_BOOL,		(char *)&p_exrc},
X		{"formatprg",	"fp",  	P_STRING|P_EXPAND,	(char *)&p_fp},
X		{"graphic",		"gr",	P_BOOL,		(char *)&p_gr},
X		{"hardtabs",	"ht",	P_NUM,		(char *)NULL},
X		{"helpfile",	"hf",  	P_STRING|P_EXPAND,	(char *)&p_hf},
X		{"history", 	"hi", 	P_NUM,		(char *)&p_hi},
X		{"ignorecase",	"ic",	P_BOOL,		(char *)&p_ic},
X		{"insertmode",	"im",	P_BOOL,		(char *)&p_im},
X		{"joinspaces", 	"js",	P_BOOL,		(char *)&p_js},
X		{"keywordprg",	"kp",  	P_STRING|P_EXPAND,	(char *)&p_kp},
X		{"lines",		NULL, 	P_NUM,		(char *)&Rows},
X		{"lisp",		NULL,	P_BOOL,		(char *)NULL},
X		{"list",		NULL,	P_BOOL,		(char *)&p_list},
X		{"magic",		NULL,	P_BOOL,		(char *)&p_magic},
X		{"makeprg",		"mp",  	P_STRING|P_EXPAND,	(char *)&p_mp},
X		{"mesg",		NULL,	P_BOOL,		(char *)NULL},
X		{"modeline",	"ml",	P_BOOL,		(char *)&p_ml},
X		{"modelines",	"mls",	P_NUM,		(char *)&p_mls},
X		{"number",		"nu",	P_BOOL,		(char *)&p_nu},
X		{"open",		NULL,	P_BOOL,		(char *)NULL},
X		{"optimize",	"opt",	P_BOOL,		(char *)NULL},
X		{"paragraphs",	"para",	P_STRING,	(char *)&p_para},
X		{"paste",		NULL,	P_BOOL,		(char *)&p_paste},
X		{"prompt",		NULL,	P_BOOL,		(char *)NULL},
X		{"readonly",	"ro",	P_BOOL,		(char *)&p_ro},
X		{"redraw",		NULL,	P_BOOL,		(char *)NULL},
X		{"remap",		NULL,	P_BOOL,		(char *)&p_remap},
X		{"report",		NULL,	P_NUM,		(char *)&p_report},
X		{"revins",		"ri",	P_BOOL,		(char *)&p_ri},
X		{"ruler",		"ru",	P_BOOL,		(char *)&p_ru},
X		{"secure",		NULL,	P_BOOL,		(char *)&p_secure},
X		{"scroll",		NULL, 	P_NUM,		(char *)&p_scroll},
X		{"scrolljump",	"sj", 	P_NUM,		(char *)&p_sj},
X		{"sections",	"sect",	P_STRING,	(char *)&p_sections},
X		{"shell",		"sh",	P_STRING|P_EXPAND,	(char *)&p_sh},
X		{"shelltype",	"st",	P_NUM,		(char *)&p_st},
X		{"shiftround",	"sr",	P_BOOL,		(char *)&p_sr},
X		{"shiftwidth",	"sw",	P_NUM,		(char *)&p_sw},
X#ifndef MSDOS
X		{"shortname",	"sn",	P_BOOL,		(char *)&p_sn},
X#endif
X		{"showcmd",		"sc",	P_BOOL,		(char *)&p_sc},
X		{"showmatch",	"sm",	P_BOOL,		(char *)&p_sm},
X		{"showmode",	"smd",	P_BOOL,		(char *)&p_smd},
X		{"sidescroll",	"ss",	P_NUM,		(char *)&p_ss},
X		{"slowopen",	"slow",	P_BOOL,		(char *)NULL},
X		{"smartindent", "si",	P_BOOL,		(char *)&p_si},
X		{"sourceany", NULL,	P_BOOL,		(char *)NULL},
X		{"suffixes",	"su",	P_STRING,	(char *)&p_su},
X		{"tabstop", 	"ts",	P_NUM,		(char *)&p_ts},
X		{"taglength",	"tl",	P_NUM,		(char *)&p_tl},
X		{"tags",		NULL,	P_STRING|P_EXPAND,	(char *)&p_tags},
X		{"term",		NULL,	P_STRING|P_EXPAND,	(char *)&term_strings.t_name},
X		{"terse",		NULL,	P_BOOL,		(char *)NULL},
X		{"textauto",	"ta",	P_BOOL,		(char *)&p_ta},
X		{"textmode",	"tx",	P_BOOL,		(char *)&p_tx},
X		{"textwidth",	"tw",	P_NUM,		(char *)&p_tw},
X		{"tildeop", 	"to",	P_BOOL,		(char *)&p_to},
X		{"timeout", 	NULL,	P_BOOL,		(char *)&p_timeout},
X		{"timeoutlen",	"tm",	P_NUM,		(char *)&p_tm},
X		{"ttimeout", 	NULL,	P_BOOL,		(char *)&p_ttimeout},
X		{"ttytype",		NULL,	P_STRING,	(char *)NULL},
X		{"undolevels",	"ul",	P_NUM,		(char *)&p_ul},
X		{"updatecount",	"uc",	P_NUM,		(char *)&p_uc},
X		{"updatetime",	"ut",	P_NUM,		(char *)&p_ut},
X		{"visualbell",	"vb",	P_BOOL,		(char *)&p_vb},
X		{"warn",		NULL,	P_BOOL,		(char *)&p_warn},
X		{"wildchar",	"wc", 	P_NUM,		(char *)&p_wc},
X		{"window",		NULL, 	P_NUM,		(char *)NULL},
X		{"w300",		NULL, 	P_NUM,		(char *)NULL},
X		{"w1200",		NULL, 	P_NUM,		(char *)NULL},
X		{"w9600",		NULL, 	P_NUM,		(char *)NULL},
X		{"wrap",		NULL,	P_BOOL,		(char *)&p_wrap},
X		{"wrapscan",	"ws",	P_BOOL,		(char *)&p_ws},
X		{"wrapmargin",	"wm",	P_NUM,		(char *)&p_wm},
X		{"writeany",	"wa",	P_BOOL,		(char *)&p_wa},
X		{"writebackup",	"wb",	P_BOOL,		(char *)&p_wb},
X		{"yankendofline", "ye",	P_BOOL,		(char *)&p_ye},
X
X/* terminal output codes */
X		{"t_el",		NULL,	P_STRING,	(char *)&term_strings.t_el},
X		{"t_il",		NULL,	P_STRING,	(char *)&term_strings.t_il},
X		{"t_cil",		NULL,	P_STRING,	(char *)&term_strings.t_cil},
X		{"t_dl",		NULL,	P_STRING,	(char *)&term_strings.t_dl},
X		{"t_cdl",		NULL,	P_STRING,	(char *)&term_strings.t_cdl},
X		{"t_ed",		NULL,	P_STRING,	(char *)&term_strings.t_ed},
X		{"t_ci",		NULL,	P_STRING,	(char *)&term_strings.t_ci},
X		{"t_cv",		NULL,	P_STRING,	(char *)&term_strings.t_cv},
X		{"t_tp",		NULL,	P_STRING,	(char *)&term_strings.t_tp},
X		{"t_ti",		NULL,	P_STRING,	(char *)&term_strings.t_ti},
X		{"t_cm",		NULL,	P_STRING,	(char *)&term_strings.t_cm},
X		{"t_sr",		NULL,	P_STRING,	(char *)&term_strings.t_sr},
X		{"t_cri",		NULL,	P_STRING,	(char *)&term_strings.t_cri},
X		{"t_vb",		NULL,	P_STRING,	(char *)&term_strings.t_vb},
X		{"t_ks",		NULL,	P_STRING,	(char *)&term_strings.t_ks},
X		{"t_ke",		NULL,	P_STRING,	(char *)&term_strings.t_ke},
X		{"t_ts",		NULL,	P_STRING,	(char *)&term_strings.t_ts},
X		{"t_te",		NULL,	P_STRING,	(char *)&term_strings.t_te},
X
X/* terminal key codes */
X		{"t_ku",		NULL,	P_STRING,	(char *)&term_strings.t_ku},
X		{"t_kd",		NULL,	P_STRING,	(char *)&term_strings.t_kd},
X		{"t_kr",		NULL,	P_STRING,	(char *)&term_strings.t_kr},
X		{"t_kl",		NULL,	P_STRING,	(char *)&term_strings.t_kl},
X		{"t_sku",		NULL,	P_STRING,	(char *)&term_strings.t_sku},
X		{"t_skd",		NULL,	P_STRING,	(char *)&term_strings.t_skd},
X		{"t_skr",		NULL,	P_STRING,	(char *)&term_strings.t_skr},
X		{"t_skl",		NULL,	P_STRING,	(char *)&term_strings.t_skl},
X		{"t_f1",		NULL,	P_STRING,	(char *)&term_strings.t_f1},
X		{"t_f2",		NULL,	P_STRING,	(char *)&term_strings.t_f2},
X		{"t_f3",		NULL,	P_STRING,	(char *)&term_strings.t_f3},
X		{"t_f4",		NULL,	P_STRING,	(char *)&term_strings.t_f4},
X		{"t_f5",		NULL,	P_STRING,	(char *)&term_strings.t_f5},
X		{"t_f6",		NULL,	P_STRING,	(char *)&term_strings.t_f6},
X		{"t_f7",		NULL,	P_STRING,	(char *)&term_strings.t_f7},
X		{"t_f8",		NULL,	P_STRING,	(char *)&term_strings.t_f8},
X		{"t_f9",		NULL,	P_STRING,	(char *)&term_strings.t_f9},
X		{"t_f10",		NULL,	P_STRING,	(char *)&term_strings.t_f10},
X		{"t_sf1",		NULL,	P_STRING,	(char *)&term_strings.t_sf1},
X		{"t_sf2",		NULL,	P_STRING,	(char *)&term_strings.t_sf2},
X		{"t_sf3",		NULL,	P_STRING,	(char *)&term_strings.t_sf3},
X		{"t_sf4",		NULL,	P_STRING,	(char *)&term_strings.t_sf4},
X		{"t_sf5",		NULL,	P_STRING,	(char *)&term_strings.t_sf5},
X		{"t_sf6",		NULL,	P_STRING,	(char *)&term_strings.t_sf6},
X		{"t_sf7",		NULL,	P_STRING,	(char *)&term_strings.t_sf7},
X		{"t_sf8",		NULL,	P_STRING,	(char *)&term_strings.t_sf8},
X		{"t_sf9",		NULL,	P_STRING,	(char *)&term_strings.t_sf9},
X		{"t_sf10",		NULL,	P_STRING,	(char *)&term_strings.t_sf10},
X		{"t_help",		NULL,	P_STRING,	(char *)&term_strings.t_help},
X		{"t_undo",		NULL,	P_STRING,	(char *)&term_strings.t_undo},
X		{NULL, NULL, 0, NULL}			/* end marker */
X};
X
Xstatic void param_expand __ARGS((int, int));
Xstatic int findparam __ARGS((char *));
Xstatic void	showparams __ARGS((int));
Xstatic void showonep __ARGS((struct param *));
Xstatic int  istermparam __ARGS((struct param *));
X
X/*
X * Initialize the shell parameter and scroll size.
X */
X	void
Xset_init()
X{
X	char	*p;
X	int		i;
X
X	if ((p = (char *)vimgetenv("SHELL")) != NULL
X#ifdef MSDOS
X			|| (p = (char *)vimgetenv("COMSPEC")) != NULL
X#endif
X															)
X	{
X		p = strsave(p);
X		if (p != NULL)		/* we don't want a NULL */
X			p_sh = p;
X	}
X
X	p_scroll = (Rows >> 1);
X	comp_col();
X
X	/*
X	 * expand environment variables in some string options
X	 */
X	for (i = 0; params[i].fullname != NULL; i++)
X		param_expand(i, FALSE);
X}
X
X/*
X * parse 'arg' for option settings
X * 'arg' may be IObuff, but only when no errors can be present.
X */
X	int
Xdoset(arg)
X	char		*arg;	/* parameter string (may be written to!) */
X{
X	register int i;
X	char		*s;
X	char		*errmsg;
X	char		*startarg;
X	int			prefix;	/* 0: nothing, 1: "no", 2: "inv" in front of name */
X	int 		nextchar;
X	int 		len;
X	int 		flags;
X	long		value;
X	long		olduc = p_uc;		/* remember old update count */
X	long		oldRows = Rows;		/* remember old Rows */
X	int			errcnt = 0;			/* number of errornous entries */
X	static long	save_tw = 0;		/* saved options for 'paste' */
X	static int	save_ai = 0;
X	static int	save_si = 0;
X	static int	save_sm = 0;
X	static int	save_ru = 0;
X	static int	save_ri = 0;
X	static int	did_paste = FALSE;	/* when TRUE saved values have been set */
X	int			do_wait = FALSE;	/* call wait_return() at the end */
X	int			did_show = FALSE;	/* already showed one value */
X
X	if (*arg == NUL)
X	{
X		showparams(0);
X		return 0;
X	}
X
X	while (*arg)		/* loop to process all parameters */
X	{
X		errmsg = NULL;
X		startarg = arg;		/* remember for error message */
X		if (strncmp(arg, "all", (size_t)3) == 0)
X			showparams(1);
X		else if (strncmp(arg, "termcap", (size_t)7) == 0)
X			showparams(2);
X		else
X		{
X			prefix = 1;
X			if (strncmp(arg, "no", (size_t)2) == 0)
X			{
X				prefix = 0;
X				arg += 2;
X			}
X			else if (strncmp(arg, "inv", (size_t)3) == 0)
X			{
X				prefix = 2;
X				arg += 3;
X			}
X				/* find end of name */
X			for (len = 0; isalnum(arg[len]) || arg[len] == '_'; ++len)
X				;
X			nextchar = arg[len];
X			arg[len] = 0;								/* name ends with 0 */
X			i = findparam(arg);
X			arg[len] = nextchar;						/* restore nextchar */
X
X			if (i == -1)		/* found a mismatch: skip the rest */
X			{
X				errmsg = "Unknown option";
X				goto skip;
X			}
X
X			if (!params[i].var)			/* hidden option */
X				goto skip;
X
X			flags = params[i].flags;
X			/*
X			 * allow '=' and ':' as MSDOS command.com allows only one
X			 * '=' character per "set" command line. grrr. (jw)
X			 */
X			if (nextchar == '?' || 
X			    (prefix == 1 && nextchar != '=' &&
X				 nextchar != ':' && !(flags & P_BOOL)))
X			{										/* print value */
X				if (did_show)
X				{
X					outchar('\n');			/* cursor below last one */
X					do_wait = TRUE;			/* have to call wait_return() */
X				}
X				else
X				{
X					gotocmdline(TRUE, NUL);	/* cursor at status line */
X					did_show = TRUE;		/* remember that we did a line */
X				}
X				showonep(&params[i]);
X
X					/* check if the message is too long to fit in one line */
X				if ((flags & P_STRING) && strlen(params[i].fullname) +
X							(*(char **)(params[i].var) == NULL ? 0 :
X							strsize(*(char **)(params[i].var))) + 1 >= (unsigned)sc_col)
X					do_wait = TRUE;
X			}
X			else
X			{
X				if (nextchar != NUL && strchr("=: \t", nextchar) == NULL)
X				{
X					errmsg = e_invarg;
X					goto skip;
X				}
X				else if (flags & P_BOOL)					/* boolean */
X				{
X						if (nextchar == '=' || nextchar == ':')
X						{
X							errmsg = e_invarg;
X							goto skip;
X						}
X						/*
X						 * in secure mode, setting of the secure option is not allowed
X						 */
X						if (secure && (int *)params[i].var == &p_secure)
X						{
X							errmsg = "not allowed here";
X							goto skip;
X						}
X						if (prefix == 2)
X							*(int *)(params[i].var) ^= 1;	/* invert it */
X						else
X							*(int *)(params[i].var) = prefix;
X							/* handle compatbile option here */
X						if ((int *)params[i].var == &p_cp && p_cp)
X						{
X							p_bs = 0;		/* normal backspace */
X							p_bk = 0;		/* no backup file */
X#ifdef DIGRAPHS
X							p_dg = 0;		/* no digraphs */
X#endif /* DIGRAPHS */
X							p_ek = 0;		/* no ESC keys in insert mode */
X							p_et = 0;		/* no expansion of tabs */
X							p_hi = 0;		/* no history */
X							p_im = 0;		/* do not start in insert mode */
X							p_js = 1;		/* insert 2 spaces after period */
X							p_ml = 0;		/* no modelines */
X							p_ru = 0;		/* no ruler */
X							p_ri = 0;		/* no reverse insert */
X							p_sj = 1;		/* no scrolljump */
X							p_sr = 0;		/* do not round indent to shiftwidth */
X							p_sc = 0;		/* no showcommand */
X							p_smd = 0;		/* no showmode */
X							p_si = 0;		/* no smartindent */
X							p_ta = 0;		/* no automatic textmode detection */
X							p_tw = 0;		/* no automatic line wrap */
X							p_to = 0;		/* no tilde operator */
X							p_ttimeout = 0;	/* no terminal timeout */
X							p_ul = 0;		/* no multilevel undo */
X							p_uc = 0;		/* no autoscript file */
X							p_wb = 0;		/* no backup file */
X							if (p_wc == TAB)
X								p_wc = Ctrl('E');	/* normal use for TAB */
X							p_ye = 0;		/* no yank to end of line */
X						}
X						if ((int *)params[i].var == &p_bin && p_bin)	/* handle bin */
X						{
X							p_tw = 0;		/* no automatic line wrap */
X							p_tx = 0;		/* no text mode */
X							p_ta = 0;		/* no text auto */
X							p_ml = 0;		/* no modelines */
X							p_et = 0;		/* no expandtab */
X						}
X						if ((int *)params[i].var == &p_paste)	/* handle paste here */
X						{
X							if (p_paste)
X							{
X								save_tw = p_tw;		/* save current values */
X								save_ai = p_ai;
X								save_si = p_si;
X								save_sm = p_sm;
X								save_ru = p_ru;
X								save_ri = p_ri;
X								p_tw = 0;			/* textwidth is 0 */
X								p_ai = 0;			/* no auto-indent */
X								p_si = 0;			/* no smart-indent */
X								p_sm = 0;			/* no showmatch */
X								p_ru = 0;			/* no ruler */
X								p_ri = 0;			/* no reverse insert */
X								did_paste = TRUE;
X							}
X							else if (did_paste)		/* restore old values */
X							{
X								p_tw = save_tw;
X								p_ai = save_ai;
X								p_si = save_si;
X								p_sm = save_sm;
X								p_ru = save_ru;
X								p_ri = save_ri;
X							}
X						}
X				}
X				else								/* numeric or string */
X				{
X					if ((nextchar != '=' && nextchar != ':') || prefix != 1)
X					{
X						errmsg = e_invarg;
X						goto skip;
X					}
X					if (flags & P_NUM)				/* numeric */
X					{
X						value = atol(arg + len + 1);
X							/* wrapmargin is translated into textwidth */
X						if ((long *)params[i].var == &p_wm)
X						{
X							if (value == 0)		/* switch it off */
X								p_tw = 0;
X							else
X							{
X								if (value >= (int)Columns)
X									value = (int)Columns - 1;
X								p_tw = Columns - value;
X							}
X						}
X						*(long *)(params[i].var) = value;
X					}
X					else							/* string */
X					{
X						arg += len + 1;		/* jump to after the '=' */
X						prefix = *arg;		/* remember first char of arg */
X						s = alloc((unsigned)(strlen(arg) + 1)); /* get a bit too much */
X						if (s == NULL)
X							break;
X						if (flags & P_CHANGED)
X							free(*(char **)(params[i].var));
X						*(char **)(params[i].var) = s;
X									/* copy the string */
X						while (*arg && *arg != ' ')
X						{
X							if (*arg == '\\' && *(arg + 1)) /* skip over escaped chars */
X									++arg;
X							*s++ = *arg++;
X						}
X						*s = NUL;
X						if (prefix == '$')
X							param_expand(i, TRUE);	/* expand environment variables */
X						/*
X						 * options that need some action
X						 * to perform when changed (jw)
X						 */
X						if (params[i].var == (char *)&term_strings.t_name)
X							set_term(term_strings.t_name);
X						else if (istermparam(&params[i]))
X						{
X							ttest(FALSE);
X							if (params[i].var == (char *)&term_strings.t_tp)
X							{
X								outstr(T_TP);
X								updateScreen(CLEAR);
X							}
X						}
X					}
X				}
X				params[i].flags |= P_CHANGED;
X			}
X		}
X
Xskip:
X		/*
X		 * Check the bounds for numeric parameters here
X		 */
X		if (Rows < 2)
X		{
X			Rows = 2;
X			errmsg = "Need at least 2 lines";
X		}
X		/*
X		 * If the screenheight has been changed, assume it is the physical
X		 * screenheight, set Rows_max.
X		 */
X		if (oldRows != Rows)
X		{
X			Rows_max = Rows;
X#ifdef MSDOS
X			set_window();		/* active window may have changed */
X#endif
X		}
X
X		if (p_ts <= 0)
X		{
X			errmsg = e_positive;
X			p_ts = 8;
X		}
X		if (p_tm < 0)
X		{
X			errmsg = e_positive;
X			p_tm = 0;
X		}
X		if (p_scroll <= 0 || p_scroll > Rows)
X		{
X			if (p_scroll != 0)
X				errmsg = e_scroll;
X			p_scroll = Rows >> 1;
X		}
X		if (p_report < 0)
X		{
X			errmsg = e_positive;
X			p_report = 1;
X		}
X		if (p_sj < 0 || p_sj >= Rows)
X		{
X			errmsg = e_scroll;
X			p_sj = 1;
X		}
X		if (p_uc < 0)
X		{
X			errmsg = e_positive;
X			p_uc = 100;
X		}
X		if (p_ut < 0)
X		{
X			errmsg = e_positive;
X			p_ut = 2000;
X		}
X		if (p_ss < 0)
X		{
X			errmsg = e_positive;
X			p_ss = 0;
X		}
X		if (errmsg)
X		{
X			strcpy(IObuff, errmsg);
X			strcat(IObuff, ": ");
X			s = IObuff + strlen(IObuff);
X			while (*startarg && !isspace(*startarg))
X				*s++ = *startarg++;
X			*s = NUL;
X			emsg(IObuff);
X			arg = startarg;		/* skip to next argument */
X			++errcnt;			/* count number of errors */
X		}
X		skiptospace(&arg);				/* skip to next white space */
X		skipspace(&arg);				/* skip spaces */
X	}
X
X	if (p_uc == 0 && olduc != 0)		/* p_uc changed from on to off */
X		stopscript();
X	if (p_uc > 0 && olduc == 0)			/* p_uc changed from off to on */
X		startscript();
X	comp_col();
X
X	/*
X	 * Update the screen in case we changed something like "tabstop" or
X	 * "lines" or "list" that will change its appearance.
X	 * If we messed up the screen by showing more than one line of param
X	 * values call wait_return(), which will also update the screen..
X	 */
X	if (do_wait)
X	{
X		outchar('\n');
X		wait_return(TRUE);
X	}
X	else
X		updateScreen(NOT_VALID);
X	return errcnt;
X}
X
X/*
X * expand environment variable at the start of some string options
X */
X	static void
Xparam_expand(i, dofree)
X	int		i;
X	int		dofree;
X{
X	char *p;
X
X	if ((params[i].flags & P_EXPAND) && (p = *(char **)(params[i].var)) != NULL && *p == '$')
X	{
X		expand_env(*(char **)(params[i].var), IObuff, IOSIZE);
X		p = strsave(IObuff);
X		if (p)
X		{
X			if (dofree)
X				free(*(char **)(params[i].var));
X			*(char **)(params[i].var) = p;
X		}
X	}
X}
X
X/*
X * find index for option 'arg'
X * return -1 if not found
X */
X	static int
Xfindparam(arg)
X	char *arg;
X{
X	int		i;
X	char	*s;
X
X	for (i = 0; (s = params[i].fullname) != NULL; i++)
X	{
X		if (strcmp(arg, s) == 0) /* match full name */
X			break;
X	}
X	if (s == NULL)
X	{
X		for (i = 0; params[i].fullname != NULL; i++)
X		{
X			s = params[i].shortname;
X			if (s != NULL && strcmp(arg, s) == 0) /* match short name */
X				break;
X			s = NULL;
X		}
X	}
X	if (s == NULL)
X		i = -1;
X	return i;
X}
X
X/*
X * mark option 'arg' changed
X */
X	void
Xparamchanged(arg)
X	char *arg;
X{
X	int i;
X
X	i = findparam(arg);
X	if (i >= 0)
X		params[i].flags |= P_CHANGED;
X}
X
X/*
X * if 'all' == 0: show changed parameters
X * if 'all' == 1: show all normal parameters
X * if 'all' == 2: show all terminal parameters
X */
X	static void
Xshowparams(all)
X	int			all;
X{
X	struct param   *p;
X	int				col = 0;
X	int				inc;
X	int				isterm;
X
X	gotocmdline(TRUE, NUL);
X	outstrn("Parameters:\n");
X
X#ifdef AMIGA
X	settmode(0);				/* set cooked mode so output can be halted */
X#endif
X	for (p = &params[0]; p->fullname != NULL; p++)
X	{
X		isterm = istermparam(p);
X		if (p->var && (
X			(all == 2 && isterm) ||
X			(all == 1 && !isterm) ||
X			(all == 0 && (p->flags & P_CHANGED))))
X		{
X			if ((p->flags & P_STRING) && *(char **)(p->var) != NULL)
X			{
X				inc = strlen(p->fullname) + strsize(*(char **)(p->var)) + 1;
X				if (inc < 18)
X					inc = 18;
X			}
X			else
X				inc = 18;
X			if (col + inc >= Columns)
X			{
X				col = 0;
X				if (Rows != Rows_max)
X					windgoto((int)Rows_max - 1, 0);
X				outchar('\n');				/* scroll screen one line up */
X			}
X			windgoto((int)Rows - 1, col); /* make columns */
X			showonep(p);
X			col += inc;
X			col += 19 - col % 19;
X			flushbuf();
X		}
X	}
X
X	if (col)
X		outchar('\n');
X#ifdef AMIGA
X	settmode(1);
X#endif
X	wait_return(TRUE);
X}
X
X/*
X * showonep: show the value of one option
X * must not be called with a hidden option!
X */
X	static void
Xshowonep(p)
X		struct param *p;
X{
X	char			buf[64];
X
X	if ((p->flags & P_BOOL) && !*(int *)(p->var))
X		outstrn("no");
X	outstrn(p->fullname);
X	if (!(p->flags & P_BOOL))
X	{
X		outchar('=');
X		if (p->flags & P_NUM)
X		{
X			sprintf(buf, "%ld", *(long *)(p->var));
X			outstrn(buf);
X		}
X		else if (*(char **)(p->var) != NULL)
X			outtrans(*(char **)(p->var), -1);
X	}
X}
X
X/*
X * Write modified parameters as set command to a file.
X * Return 1 on error.
X */
X	int
Xmakeset(fd)
X	FILE *fd;
X{
X	struct param	*p;
X	char			*s;
X	int				e;
X
X	for (p = &params[0]; p->fullname != NULL; p++)
X		if ((p->flags & P_CHANGED) && p->var)
X		{
X			if (p->flags & P_BOOL)
X				fprintf(fd, "set %s%s", *(int *)(p->var) ? "" : "no", p->fullname);
X			else if (p->flags & P_NUM)
X				fprintf(fd, "set %s=%ld", p->fullname, *(long *)(p->var));
X			else
X			{
X				fprintf(fd, "set %s=", p->fullname);
X				s = *(char **)(p->var);
X					/* some characters hav to be escaped with CTRL-V or backslash */
X				if (s != NULL && putescstr(fd, s, TRUE) < 0)
X					return 1;
X			}
X#ifdef MSDOS
X			putc('\r', fd);
X#endif
X				/*
X				 * Only check error for this putc, should catch at least
X				 * the "disk full" situation.
X				 */
X			e = putc('\n', fd);
X			if (e < 0)
X				return 1;
X		}
X	return 0;
X}
X
X/*
X * Clear all the terminal parameters.
X * If the parameter has been changed, free the allocated memory.
X * Reset the "changed" flag, so the new value will not be freed.
X */
X	void
Xclear_termparam()
X{
X	struct param   *p;
X
X	for (p = &params[0]; p->fullname != NULL; p++)
X		if (istermparam(p))			/* terminal parameters must never be hidden */
X		{
X			if (p->flags & P_CHANGED)
X				free(*(char **)(p->var));
X			*(char **)(p->var) = NULL;
X			p->flags &= ~P_CHANGED;
X		}
X}
X
X	static int
Xistermparam(p)
X	struct param *p;
X{
X	return (p->fullname[0] == 't' && p->fullname[1] == '_');
X}
X
X/*
X * Compute columns for ruler and shown command. 'sc_col' is also used to
X * decide what the maximum length of a message on the status line can be.
X */
X
X#define COL_SHOWCMD 10		/* columns needed by shown command */
X#define COL_RULER 17		/* columns needed by ruler */
X
X	void
Xcomp_col()
X{
X	sc_col = 0;
X	ru_col = 0;
X	if (p_ru)
X		ru_col = sc_col = COL_RULER + 1;
X	if (p_sc)
X	{
X		sc_col += COL_SHOWCMD;
X		if (!p_ru)
X			++sc_col;
X	}
X	sc_col = Columns - sc_col;
X	ru_col = Columns - ru_col;
X}
END_OF_FILE
if test 23470 -ne `wc -c <'vim/src/param.c'`; then
    echo shar: \"'vim/src/param.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/param.c'
# end of 'vim/src/param.c'
fi
echo shar: End of archive 12 \(of 25\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
