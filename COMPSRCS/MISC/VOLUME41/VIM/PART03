Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i053:  vim - Vi IMitation editor, v2.0, Part03/25
Message-ID: <1993Dec21.034342.27031@sparky.sterling.com>
X-Md4-Signature: 4a4205fc214a0707effa8c55425a46b3
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:43:42 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 53
Archive-name: vim/part03
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 25)."
# Contents:  vim/doc/msdos.doc vim/src/arp_proto.h vim/src/cmdtab.h
#   vim/src/cmdtab.tab vim/src/makefile.unix vim/src/param.h
#   vim/src/regsub.c vim/todo
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:04 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/msdos.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/msdos.doc'\"
else
echo shar: Extracting \"'vim/doc/msdos.doc'\" \(6542 characters\)
sed "s/^X//" >'vim/doc/msdos.doc' <<'END_OF_FILE'
XThis file contains the particularities for the MSDOS version of Vim.
X
XThe default output method is to use bios calls. This will work right away on
Xmost systems. You do not need ansi.sys.
X
XYou can set the color used in vim with two termcap options:
X
X	":set t_tp=^V^[\|xxm"		for normal text
X	":set t_ti=^V^[\|xxm"		for error messages and visual mode
X
X^V is CTRL-V
X^[ is ESC
Xxx must be replaced by a decimal code: The foreground color number and
X   background color number added together:
X
XCOLOR		FOREGROUND	BACKGROUND
Xblack		    0		    0
Xblue		    1		   16
Xgreen		    2		   32
Xcyan		    3		   48
Xred		    4		   64
Xmagenta		    5		   80
Xbrown		    6		   96
Xlighgray	    7		  112
Xdarkgray	    8
Xlightblue	    9
Xlightgreen	   10
Xlighcyan	   11
Xlightred	   12
Xlighmagenta	   13
Xyellow		   14
Xwhite		   15
Xblink			   128
X
XWhen you use 0, the color is reset to the one used when you started Vim. This
Xis the default for t_tp. The default for t_ti is white on red, 15 + 64 = 79.
X
XThe termcap codes that are translated into bios calls are:
X	ESC |J		clear screen
X	ESC |K		clear to end of line
X	ESC |L		insert line
X	ESC |M		delete line
X	ESC |row;colH	position cursor
X	ESC |attrm	set character attribute
X
XIf you want to use another output method (e.g. when using a terminal on a COM
Xport), set the terminal name to "pcansi". You can change the termcap options
Xwhen needed (see chapter 20 of reference.doc). Note that the normal IBM
Xansi.sys does not support all the codes of the builtin pcansi terminal. If
Xyou use ansi.sys you will need to delete the termcap entries t_il and t_dl
Xwith
X	":set t_il= t_dl=".
XOtherwise the screen will not be updated correctly. It is better to use
Xnansi.sys, nnansi.sys or the like instead of ansi.sys.
X
XIf you want to use Vim on a terminal connected to a COM: port, reset the
X'bioskey' option. Otherwise the commands will be read from the PC keyboard.
XCTRL-C and CTRL-P may not work correctly with 'bioskey' reset.
X
XIf the "tx" (textmode) option is set (which is the default), Vim will accept a 
Xsingle <LF> or a <CR><LF> pair for end-of-line. When writing a file Vim will 
Xuse <CR><LF>. Thus if you edit a file and write it, <LF> is replaced with 
X<CR><LF>. If the "tx" option is not set the single <LF> will be used for
Xend-of-line. A <CR> will be shown as ^M. You can use Vim to replace <LF> by
X<CR><LF> by reading in any mode and writing in text mode. You can use Vim to
Xreplace <CR><LF> by <LF> by reading in text mode and writing in non-text
Xmode. 'textmode' is set automatically when 'textauto' is on (which is the
Xdefault), so you don't really have to worry about what you are doing.
X
XIf you want to edit a script file or a binary file you should reset the
X'textmode' and 'textauto' options before loading the file. Script files
Xcontain single <LF> characters which would be replaced by <CR><LF>. You can
Xdo this by starting Vim with the "-b" (binary) option.
X
XThe default help filename is "$VIM\vim.hlp". If the environment variable $VIM 
Xis not defined or the file is not found, the DOS search path is used to 
Xsearch for the file "vim.hlp". If you do not want to put "vim.hlp" in your 
Xsearch path, use the command ":set helpfile=pathname" to tell Vim where the 
Xhelp file is.
X
XThe ":cd" command recognizes the drive specifier and changes the current
Xdrive. Use ":cd c:" to make drive C the active drive. Use ":cd d:\dos" to go
Xto the directory "dos" in the root of drive D.
X
XThe files "_vimrc" and "_exrc" are used instead of ".vimrc" and ".exrc".
XThe files "$VIM\_vimrc" and "$VIM\_exrc" are used instead of "s:.vimrc" and 
X"s:.exrc". To use the file "c:\_vimrc" use the command "set vim=c:".
X
XUse CTRL-break instead of CTRL-C to interrupt searches. The CTRL-C is not
Xdetected until a key is read.
X
XUse CTRL-arrow-left and CTRL-arrow-right instead of SHIFT-arrow-left and 
XSHIFT-arrow-right. The arrow-up and arrow-down cannot be used with SHIFT or 
XCTRL.
X
XTemporary files (for filtering) are put in the current directory.
X
XThe default for the sh (shell) option is "command". External commands are 
Xstarted with "command /c <command_name>". Typing CTRL-Z starts a new command 
Xshell. Return to Vim with "exit".
X
XIf you want to use different colors set the termcap code t_tp (for normal
Xtext) and/or t_ti (for inverted text).
X
XStandard ANSI escape sequences are used. The codes are:
X30 black foreground       40 black background	    0 all attributes off
X31 red foreground         41 red background         1 high intensity (bold)
X32 green foreground       42 green background       2 normal intensity
X33 yellow foreground      43 yellow background      4 underline
X34 blue foreground        44 blue background        5 blinking
X35 magenta foreground     45 magenta background     7 reverse video
X36 cyan foreground        46 cyan background        8 invisible
X37 white foreground       47 white background  
X
XThe codes can be combined by separating them with a semicolon. For example to
Xget white text on a blue background:
X	:set t_tp=^V<ESC>[0;37;44m
X
X
XMS-DOS allows for only one filename extention. Therefore, in the original 
Xfilename the '.' is replaced by a '_', the name is truncated to 8 characters 
Xand the new extention ".vim" or ".bak" is appended. Two examples: "test.c" 
Xbecomes "test_c.bak", "ditiseen.tst" becomes "ditiseen.bak". The 'shortname' 
Xoption is not available.
X
XThe MS-DOS binary was compiled with Borland-C++ version 3.1, using
Xmakefile.bcc. Other compilers should also work. Use makefile.dos for Turbo-C
X2.0. Use makefile.bcc for other Borland compilers, also Turbo-C++ 3.0 (with
Xsmall changes). If you get all kinds of strange error messages when compiling,
Xyou have to add <CR> characters at the end of each line. This can be done with
Xthe addcr program: "make addcr". This will compile addcr.c to addcr.exe and
Xexecute the addcr.bat file. Sometimes this fails. Then execute the addcr.bat
Xfile from the DOS prompt.
X
XAll text is kept in memory. This limits the size of the file you can edit,
Xthe number of undo levels that can be remembered, etc.. If Vim gives an "Out 
Xof memory" warning you should stop editing. Result of further editing actions 
Xis unpredictable. Setting 'undolevels' to 0 saves some memory. Running the
Xmaze macros on a big maze is guaranteed to run out of memory, because each
Xchange is remembered for undo. In this case set 'undolevels' to a negative
Xnumber. This will switch off undo completely. In a future release extended
Xmemory and/or a swap file will be used to avoid these problems.
X
XThe *.info files are for the Amiga. You don't need them with MSDOS.
END_OF_FILE
if test 6542 -ne `wc -c <'vim/doc/msdos.doc'`; then
    echo shar: \"'vim/doc/msdos.doc'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/msdos.doc'
# end of 'vim/doc/msdos.doc'
fi
if test -f 'vim/src/arp_proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/arp_proto.h'\"
else
echo shar: Extracting \"'vim/src/arp_proto.h'\" \(6655 characters\)
sed "s/^X//" >'vim/src/arp_proto.h' <<'END_OF_FILE'
X#ifndef	PROTO_ARP_H
X#define	PROTO_ARP_H	1
X
X/*
X ************************************************************************
X *	The arp copies of the dos.library calls...			*
X ************************************************************************
X */
X
X/* Only include these if you can use ARP.library without dos.library... */
X#ifdef	DO_ARP_COPIES
X#pragma	amicall(ArpBase, 0x1E, Open(d1, d2))
X#pragma	amicall(ArpBase, 0x24, Close(d1))
X#pragma	amicall(ArpBase, 0x2A, Read(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x30, Write(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x36, Input())
X#pragma	amicall(ArpBase, 0x3C, Output())
X#pragma	amicall(ArpBase, 0x42, Seek(d1, d2, d3))
X#pragma	amicall(ArpBase, 0x48, DeleteFile(d1))
X#pragma	amicall(ArpBase, 0x4E, Rename(d1, d2))
X#pragma	amicall(ArpBase, 0x54, Lock(d1, d2))
X#pragma	amicall(ArpBase, 0x5A, UnLock(d1))
X#pragma	amicall(ArpBase, 0x60, DupLock(d1))
X#pragma	amicall(ArpBase, 0x66, Examine(d1, d2))
X#pragma	amicall(ArpBase, 0x6C, ExNext(d1, d2))
X#pragma	amicall(ArpBase, 0x72, Info(d1, d2))
X#pragma	amicall(ArpBase, 0x78, CreateDir(d1))
X#pragma	amicall(ArpBase, 0x7E, CurrentDir(d1))
X#pragma	amicall(ArpBase, 0x84, IoErr())
X#pragma	amicall(ArpBase, 0x8A, CreateProc(d1, d2, d3, d4))
X#pragma	amicall(ArpBase, 0x90, Exit(d1))
X#pragma	amicall(ArpBase, 0x96, LoadSeg(d1))
X#pragma	amicall(ArpBase, 0x9C, UnLoadSeg(d1))
X#pragma	amicall(ArpBase, 0xAE, DeviceProc(d1))
X#pragma	amicall(ArpBase, 0xB4, SetComment(d1, d2))
X#pragma	amicall(ArpBase, 0xBA, SetProtection(d1, d2))
X#pragma	amicall(ArpBase, 0xC0, DateStamp(d1))
X#pragma	amicall(ArpBase, 0xC6, Delay(d1))
X#pragma	amicall(ArpBase, 0xCC, WaitForChar(d1, d2))
X#pragma	amicall(ArpBase, 0xD2, ParentDir(d1))
X#pragma	amicall(ArpBase, 0xD8, IsInteractive(d1))
X#pragma	amicall(ArpBase, 0xDE, Execute(d1, d2, d3))
X#endif
X
X/*
X ************************************************************************
X *	Stuff only in arp.library					*
X ************************************************************************
X */
X/*	amicall(ArpBase, 0x0E4, Printf(a0, a1))	This does not work without glue */
X/*	amicall(ArpBase, 0x0EA, FPrintf(d0, a0, a1))	This does not work without glue */
X#pragma	amicall(ArpBase, 0x0F0, Puts(a1))
X#pragma	amicall(ArpBase, 0x0F6, Readline(a0))
X#pragma	amicall(ArpBase, 0x0FC, GADS(a0, d0, a1, a2, a3))
X#pragma	amicall(ArpBase, 0x102, Atol(a0))
X#pragma	amicall(ArpBase, 0x108, EscapeString(a0))
X#pragma	amicall(ArpBase, 0x10E, CheckAbort(a1))
X#pragma	amicall(ArpBase, 0x114, CheckBreak(d1, a1))
X#pragma	amicall(ArpBase, 0x11A, Getenv(a0, a1, d0))
X#pragma	amicall(ArpBase, 0x120, Setenv(a0, a1))
X#pragma	amicall(ArpBase, 0x126, FileRequest(a0))
X#pragma	amicall(ArpBase, 0x12C, CloseWindowSafely(a0, a1))
X#pragma	amicall(ArpBase, 0x132, CreatePort(a0, d0))
X#pragma	amicall(ArpBase, 0x138, DeletePort(a1))
X#pragma	amicall(ArpBase, 0x13E, SendPacket(d0, a0, a1))
X#pragma	amicall(ArpBase, 0x144, InitStdPacket(d0, a0, a1, a2))
X#pragma	amicall(ArpBase, 0x14A, PathName(d0, a0, d1))
X#pragma	amicall(ArpBase, 0x150, Assign(a0, a1))
X#pragma	amicall(ArpBase, 0x156, DosAllocMem(d0))
X#pragma	amicall(ArpBase, 0x15C, DosFreeMem(a1))
X#pragma	amicall(ArpBase, 0x162, BtoCStr(a0, d0, d1))
X#pragma	amicall(ArpBase, 0x168, CtoBStr(a0, d0, d1))
X#pragma	amicall(ArpBase, 0x16E, GetDevInfo(a2))
X#pragma	amicall(ArpBase, 0x174, FreeTaskResList())
X#pragma	amicall(ArpBase, 0x17A, ArpExit(d0, d2))
X#pragma	amicall(ArpBase, 0x180, ArpAlloc(d0))
X/*	amicall(ArpBase, 0x186, ArpAllocMem(d0, d1))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x18C, ArpOpen(d1, d2))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x192, ArpDupLock(d1))		Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x198, ArpLock(d1, d2))	Secondary result - IoErr() */
X/*	amicall(ArpBase, 0x19E, RListAlloc(a0, d0))	Secondary result - IoErr() */
X#pragma	amicall(ArpBase, 0x1A4, FindCLI(d0))
X#pragma	amicall(ArpBase, 0x1AA, QSort(a0, d0, d1, a1))
X
X#pragma	amicall(ArpBase, 0x1B0, PatternMatch(a0, a1))
X#pragma	amicall(ArpBase, 0x1B6, FindFirst(d0, a0))
X#pragma	amicall(ArpBase, 0x1BC, FindNext(a0))
X#pragma	amicall(ArpBase, 0x1C2, FreeAnchorChain(a0))
X
X#pragma	amicall(ArpBase, 0x1C8, CompareLock(d0, d1))
X
X#pragma	amicall(ArpBase, 0x1CE, FindTaskResList())
X#pragma	amicall(ArpBase, 0x1D4, CreateTaskResList())
X#pragma	amicall(ArpBase, 0x1DA, FreeResList(a1))
X#pragma	amicall(ArpBase, 0x1E0, FreeTrackedItem(a1))
X/*	amicall(ArpBase, 0x1E6, GetTracker())	Stores the ID in the tracker */
X
X#pragma	amicall(ArpBase, 0x1EC, GetAccess(a1))
X#pragma	amicall(ArpBase, 0x1F2, FreeAccess(a1))
X
X#pragma	amicall(ArpBase, 0x1F8, FreeDAList(a1))
X#pragma	amicall(ArpBase, 0x1FE, AddDANode(a0, a1, d0, d1))
X#pragma	amicall(ArpBase, 0x204, AddDADevs(a0, d0))
X
X#pragma	amicall(ArpBase, 0x20A, Strcmp(a0, a1))
X#pragma	amicall(ArpBase, 0x210, Strncmp(a0, a1, d0))
X#pragma	amicall(ArpBase, 0x216, Toupper(d0))
X#pragma	amicall(ArpBase, 0x21C, SyncRun(a0, a1, d0, d1))
X
X/*
X ************************************************************************
X *	Added V32 of arp.library					*
X *	Note that SpawnShell is ASyncRun but was added at V39 of arp...	*
X ************************************************************************
X */
X#pragma	amicall(ArpBase, 0x222, ASyncRun(a0, a1, a2))
X#pragma	amicall(ArpBase, 0x222, SpawnShell(a0, a1, a2))
X#pragma	amicall(ArpBase, 0x228, LoadPrg(d1))
X#pragma	amicall(ArpBase, 0x22E, PreParse(a0, a1))
X
X/*
X ************************************************************************
X *	Added V33 of arp.library					*
X ************************************************************************
X */
X#pragma	amicall(ArpBase, 0x234, StamptoStr(a0))
X#pragma	amicall(ArpBase, 0x23A, StrtoStamp(a0))
X
X#pragma	amicall(ArpBase, 0x240, ObtainResidentPrg(a0))
X#pragma	amicall(ArpBase, 0x246, AddResidentPrg(d1, a0))
X#pragma	amicall(ArpBase, 0x24C, RemResidentPrg(a0))
X#pragma	amicall(ArpBase, 0x252, UnLoadPrg(d1))
X#pragma	amicall(ArpBase, 0x258, LMult(d0, d1))
X#pragma	amicall(ArpBase, 0x25E, LDiv(d0, d1))
X#pragma	amicall(ArpBase, 0x264, LMod(d0, d1))
X
X#pragma	amicall(ArpBase, 0x26A, CheckSumPrg(d1))
X#pragma	amicall(ArpBase, 0x270, TackOn(a0, a1))
X#pragma	amicall(ArpBase, 0x276, BaseName(a0))
X#pragma	amicall(ArpBase, 0x27C, ReleaseResidentPrg(d1))
X
X/*
X ************************************************************************
X *	Added V36 of arp.library					*
X ************************************************************************
X */
X/*	amicall(ArpBase, 0x282, SPrintf(d0, a0, a1))	This does not work without glue */
X#pragma	amicall(ArpBase, 0x288, GetKeywordIndex(a0, a1))
X/*	amicall(ArpBase, 0x28E, ArpOpenLibrary(a1, d0))	Secondary result - IoErr() */
X#pragma	amicall(ArpBase, 0x294, ArpAllocFreq())
X
X#endif
END_OF_FILE
if test 6655 -ne `wc -c <'vim/src/arp_proto.h'`; then
    echo shar: \"'vim/src/arp_proto.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/arp_proto.h'
# end of 'vim/src/arp_proto.h'
fi
if test -f 'vim/src/cmdtab.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/cmdtab.h'\"
else
echo shar: Extracting \"'vim/src/cmdtab.h'\" \(7223 characters\)
sed "s/^X//" >'vim/src/cmdtab.h' <<'END_OF_FILE'
X/* vi:ts=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * THIS FILE IS AUTOMATICALLY PRODUCED - DO NOT EDIT
X */
X
X#define RANGE	0x01			/* allow a linespecs */
X#define BANG	0x02			/* allow a ! after the command name */
X#define EXTRA	0x04			/* allow extra args after command name */
X#define XFILE	0x08			/* expand wildcards in extra part */
X#define NOSPC	0x10			/* no spaces allowed in the extra part */
X#define	DFLALL	0x20			/* default file range is 1,$ */
X#define NODFL	0x40			/* do not default to the current file name */
X#define NEEDARG	0x80			/* argument required */
X#define TRLBAR	0x100			/* check for trailing vertical bar */
X#define REGSTR	0x200			/* allow "x for register designation */
X#define COUNT	0x400			/* allow count in argument */
X#define NOTRLCOM 0x800			/* no trailing comment allowed */
X#define ZEROR	0x1000			/* zero line number allowed */
X#define USECTRLV 0x2000			/* do not remove CTRL-V from argument */
X#define FILES	(XFILE + EXTRA)	/* multiple extra files allowed */
X#define WORD1	(EXTRA + NOSPC)	/* one extra word allowed */
X#define FILE1	(FILES + NOSPC)	/* 1 file allowed, defaults to current file */
X#define NAMEDF	(FILE1 + NODFL)	/* 1 file allowed, defaults to "" */
X#define NAMEDFS	(FILES + NODFL)	/* multiple files allowed, default is "" */
X
X/*
X * This array maps ex command names to command codes. The order in which
X * command names are listed below is significant -- ambiguous abbreviations
X * are always resolved to be the first possible match (e.g. "r" is taken
X * to mean "read", not "rewind", because "read" comes before "rewind").
X * Not supported commands are included to avoid ambiguities.
X */
Xstatic struct
X{
X	char	*cmd_name;	/* name of the command */
X	short	 cmd_argt;	/* command line arguments permitted/needed/used */
X} cmdnames[] =
X{
X	{"append",		BANG+RANGE+TRLBAR},			/* not supported */
X#define CMD_append 0
X	{"abbreviate",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_abbreviate 1
X	{"args",		TRLBAR},
X#define CMD_args 2
X	{"change",		BANG+RANGE+COUNT+TRLBAR},	/* not supported */
X#define CMD_change 3
X	{"cabbrev",		EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_cabbrev 4
X	{"cc",			TRLBAR+WORD1+BANG},
X#define CMD_cc 5
X	{"cd",			NAMEDF+TRLBAR},
X#define CMD_cd 6
X	{"center",		TRLBAR+RANGE+EXTRA},
X#define CMD_center 7
X	{"cf",			TRLBAR+FILE1+BANG},
X#define CMD_cf 8
X	{"chdir",		NAMEDF+TRLBAR},
X#define CMD_chdir 9
X	{"cl",			TRLBAR},
X#define CMD_cl 10
X	{"cmap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_cmap 11
X	{"cn",			TRLBAR+BANG},
X#define CMD_cn 12
X	{"cnoremap",	BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_cnoremap 13
X	{"cnoreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_cnoreabbrev 14
X	{"copy",		RANGE+EXTRA+TRLBAR},
X#define CMD_copy 15
X	{"cp",			TRLBAR+BANG},
X#define CMD_cp 16
X	{"cq",			TRLBAR+BANG},
X#define CMD_cq 17
X	{"cunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X#define CMD_cunmap 18
X	{"cunabbrev",	EXTRA+TRLBAR+USECTRLV},
X#define CMD_cunabbrev 19
X	{"delete",		RANGE+REGSTR+COUNT+TRLBAR},
X#define CMD_delete 20
X	{"display",		TRLBAR},
X#define CMD_display 21
X	{"digraphs",	EXTRA+TRLBAR},
X#define CMD_digraphs 22
X	{"edit",		BANG+FILE1+TRLBAR},
X#define CMD_edit 23
X	{"ex",			BANG+FILE1+TRLBAR},
X#define CMD_ex 24
X	{"file",		FILE1+TRLBAR},
X#define CMD_file 25
X	{"files",		TRLBAR},
X#define CMD_files 26
X	{"global",		RANGE+BANG+EXTRA+DFLALL},
X#define CMD_global 27
X	{"help",		TRLBAR},
X#define CMD_help 28
X	{"insert",		BANG+RANGE+TRLBAR},			/* not supported */
X#define CMD_insert 29
X	{"iabbrev",		EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_iabbrev 30
X	{"imap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_imap 31
X	{"inoremap",	BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_inoremap 32
X	{"inoreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_inoreabbrev 33
X	{"iunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X#define CMD_iunmap 34
X	{"iunabbrev",	EXTRA+TRLBAR+USECTRLV},
X#define CMD_iunabbrev 35
X	{"join",		RANGE+COUNT+TRLBAR},
X#define CMD_join 36
X	{"jumps",		TRLBAR},
X#define CMD_jumps 37
X	{"k",			RANGE+WORD1+TRLBAR},
X#define CMD_k 38
X	{"list",		RANGE+COUNT+TRLBAR},
X#define CMD_list 39
X	{"left",		TRLBAR+RANGE+EXTRA},
X#define CMD_left 40
X	{"move",		RANGE+EXTRA+TRLBAR},
X#define CMD_move 41
X	{"mark",		RANGE+WORD1+TRLBAR},
X#define CMD_mark 42
X	{"marks",		TRLBAR},
X#define CMD_marks 43
X	{"map",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_map 44
X	{"make",		NEEDARG+EXTRA+TRLBAR+XFILE},
X#define CMD_make 45
X	{"mkexrc",		BANG+FILE1+TRLBAR},
X#define CMD_mkexrc 46
X	{"mkvimrc",		BANG+FILE1+TRLBAR},
X#define CMD_mkvimrc 47
X	{"next",		RANGE+BANG+NAMEDFS+TRLBAR},
X#define CMD_next 48
X	{"number",		RANGE+COUNT+TRLBAR},
X#define CMD_number 49
X	{"noremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_noremap 50
X	{"noreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X#define CMD_noreabbrev 51
X	{"Next",		RANGE+BANG+TRLBAR},
X#define CMD_Next 52
X	{"print",		RANGE+COUNT+TRLBAR},
X#define CMD_print 53
X	{"pop",			RANGE+TRLBAR+ZEROR},
X#define CMD_pop 54
X	{"put",			RANGE+BANG+REGSTR+TRLBAR},
X#define CMD_put 55
X	{"previous",	RANGE+BANG+TRLBAR},
X#define CMD_previous 56
X	{"pwd",			TRLBAR},
X#define CMD_pwd 57
X	{"quit",		BANG+TRLBAR},
X#define CMD_quit 58
X	{"read",		RANGE+NAMEDF+NEEDARG+TRLBAR+ZEROR},
X#define CMD_read 59
X	{"rewind",		BANG+TRLBAR},
X#define CMD_rewind 60
X	{"recover",		FILE1+TRLBAR},				/* not supported */
X#define CMD_recover 61
X	{"redo",		TRLBAR},
X#define CMD_redo 62
X	{"right",		TRLBAR+RANGE+EXTRA},
X#define CMD_right 63
X	{"substitute",	RANGE+EXTRA},
X#define CMD_substitute 64
X	{"suspend",		TRLBAR+BANG},
X#define CMD_suspend 65
X	{"set",			EXTRA+TRLBAR},
X#define CMD_set 66
X	{"setkeymap",	NAMEDF+TRLBAR},
X#define CMD_setkeymap 67
X	{"shell",		TRLBAR},
X#define CMD_shell 68
X	{"source",		NAMEDF+NEEDARG+TRLBAR},
X#define CMD_source 69
X	{"stop",		TRLBAR+BANG},
X#define CMD_stop 70
X	{"t",			RANGE+EXTRA+TRLBAR},
X#define CMD_t 71
X	{"tag",			RANGE+BANG+WORD1+TRLBAR+ZEROR},
X#define CMD_tag 72
X	{"tags",		TRLBAR},
X#define CMD_tags 73
X	{"undo",		TRLBAR},
X#define CMD_undo 74
X	{"unabbreviate", EXTRA+TRLBAR+USECTRLV},
X#define CMD_unabbreviate 75
X	{"unmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X#define CMD_unmap 76
X	{"vglobal",		RANGE+EXTRA+DFLALL},
X#define CMD_vglobal 77
X	{"version",		TRLBAR},
X#define CMD_version 78
X	{"visual",		RANGE+BANG+FILE1+TRLBAR},
X#define CMD_visual 79
X	{"write",		RANGE+BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_write 80
X	{"wnext",		RANGE+BANG+FILE1+TRLBAR},
X#define CMD_wnext 81
X	{"winsize",		EXTRA+NEEDARG+TRLBAR},
X#define CMD_winsize 82
X	{"wq",			BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_wq 83
X	{"xit",			BANG+FILE1+DFLALL+TRLBAR},
X#define CMD_xit 84
X	{"yank",		RANGE+REGSTR+COUNT+TRLBAR},
X#define CMD_yank 85
X	{"z",			RANGE+COUNT+TRLBAR},		/* not supported */
X#define CMD_z 86
X	{"@",			RANGE+EXTRA+TRLBAR},
X#define CMD_at 87
X	{"!",			RANGE+NAMEDFS},
X#define CMD_bang 88
X	{"<",			RANGE+COUNT+TRLBAR},
X#define CMD_lshift 89
X	{">",			RANGE+COUNT+TRLBAR},
X#define CMD_rshift 90
X	{"=",			RANGE+TRLBAR},
X#define CMD_equal 91
X	{"&",			RANGE+EXTRA},
X#define CMD_and 92
X	{"~",			RANGE+TRLBAR}				/* not supported */
X#define CMD_tilde 93
X#define CMD_SIZE 94
X
X};
END_OF_FILE
if test 7223 -ne `wc -c <'vim/src/cmdtab.h'`; then
    echo shar: \"'vim/src/cmdtab.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/cmdtab.h'
# end of 'vim/src/cmdtab.h'
fi
if test -f 'vim/src/cmdtab.tab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/cmdtab.tab'\"
else
echo shar: Extracting \"'vim/src/cmdtab.tab'\" \(5314 characters\)
sed "s/^X//" >'vim/src/cmdtab.tab' <<'END_OF_FILE'
X/* vi:ts=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * |This file is read by mkcmdtab to produce cmdtab.h.
X *
X * The bars are used to recognize file positions. Do not insert/delete them.|
X */
X
X#define RANGE	0x01			/* allow a linespecs */
X#define BANG	0x02			/* allow a ! after the command name */
X#define EXTRA	0x04			/* allow extra args after command name */
X#define XFILE	0x08			/* expand wildcards in extra part */
X#define NOSPC	0x10			/* no spaces allowed in the extra part */
X#define	DFLALL	0x20			/* default file range is 1,$ */
X#define NODFL	0x40			/* do not default to the current file name */
X#define NEEDARG	0x80			/* argument required */
X#define TRLBAR	0x100			/* check for trailing vertical bar */
X#define REGSTR	0x200			/* allow "x for register designation */
X#define COUNT	0x400			/* allow count in argument */
X#define NOTRLCOM 0x800			/* no trailing comment allowed */
X#define ZEROR	0x1000			/* zero line number allowed */
X#define USECTRLV 0x2000			/* do not remove CTRL-V from argument */
X#define FILES	(XFILE + EXTRA)	/* multiple extra files allowed */
X#define WORD1	(EXTRA + NOSPC)	/* one extra word allowed */
X#define FILE1	(FILES + NOSPC)	/* 1 file allowed, defaults to current file */
X#define NAMEDF	(FILE1 + NODFL)	/* 1 file allowed, defaults to "" */
X#define NAMEDFS	(FILES + NODFL)	/* multiple files allowed, default is "" */
X
X/*
X * This array maps ex command names to command codes. The order in which
X * command names are listed below is significant -- ambiguous abbreviations
X * are always resolved to be the first possible match (e.g. "r" is taken
X * to mean "read", not "rewind", because "read" comes before "rewind").
X * Not supported commands are included to avoid ambiguities.
X */
Xstatic struct
X{
X	char	*cmd_name;	/* name of the command */
X	short	 cmd_argt;	/* command line arguments permitted/needed/used */
X} cmdnames[] =
X{
X|	{"append",		BANG+RANGE+TRLBAR},			/* not supported */
X	{"abbreviate",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"args",		TRLBAR},
X	{"change",		BANG+RANGE+COUNT+TRLBAR},	/* not supported */
X	{"cabbrev",		EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"cc",			TRLBAR+WORD1+BANG},
X	{"cd",			NAMEDF+TRLBAR},
X	{"center",		TRLBAR+RANGE+EXTRA},
X	{"cf",			TRLBAR+FILE1+BANG},
X	{"chdir",		NAMEDF+TRLBAR},
X	{"cl",			TRLBAR},
X	{"cmap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"cn",			TRLBAR+BANG},
X	{"cnoremap",	BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"cnoreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"copy",		RANGE+EXTRA+TRLBAR},
X	{"cp",			TRLBAR+BANG},
X	{"cq",			TRLBAR+BANG},
X	{"cunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X	{"cunabbrev",	EXTRA+TRLBAR+USECTRLV},
X	{"delete",		RANGE+REGSTR+COUNT+TRLBAR},
X	{"display",		TRLBAR},
X	{"digraphs",	EXTRA+TRLBAR},
X	{"edit",		BANG+FILE1+TRLBAR},
X	{"ex",			BANG+FILE1+TRLBAR},
X	{"file",		FILE1+TRLBAR},
X	{"files",		TRLBAR},
X	{"global",		RANGE+BANG+EXTRA+DFLALL},
X	{"help",		TRLBAR},
X	{"insert",		BANG+RANGE+TRLBAR},			/* not supported */
X	{"iabbrev",		EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"imap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"inoremap",	BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"inoreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"iunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X	{"iunabbrev",	EXTRA+TRLBAR+USECTRLV},
X	{"join",		RANGE+COUNT+TRLBAR},
X	{"jumps",		TRLBAR},
X	{"k",			RANGE+WORD1+TRLBAR},
X	{"list",		RANGE+COUNT+TRLBAR},
X	{"left",		TRLBAR+RANGE+EXTRA},
X	{"move",		RANGE+EXTRA+TRLBAR},
X	{"mark",		RANGE+WORD1+TRLBAR},
X	{"marks",		TRLBAR},
X	{"map",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"make",		NEEDARG+EXTRA+TRLBAR+XFILE},
X	{"mkexrc",		BANG+FILE1+TRLBAR},
X	{"mkvimrc",		BANG+FILE1+TRLBAR},
X	{"next",		RANGE+BANG+NAMEDFS+TRLBAR},
X	{"number",		RANGE+COUNT+TRLBAR},
X	{"noremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"noreabbrev",	EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
X	{"Next",		RANGE+BANG+TRLBAR},
X	{"print",		RANGE+COUNT+TRLBAR},
X	{"pop",			RANGE+TRLBAR+ZEROR},
X	{"put",			RANGE+BANG+REGSTR+TRLBAR},
X	{"previous",	RANGE+BANG+TRLBAR},
X	{"pwd",			TRLBAR},
X	{"quit",		BANG+TRLBAR},
X	{"read",		RANGE+NAMEDF+NEEDARG+TRLBAR+ZEROR},
X	{"rewind",		BANG+TRLBAR},
X	{"recover",		FILE1+TRLBAR},				/* not supported */
X	{"redo",		TRLBAR},
X	{"right",		TRLBAR+RANGE+EXTRA},
X	{"substitute",	RANGE+EXTRA},
X	{"suspend",		TRLBAR+BANG},
X	{"set",			EXTRA+TRLBAR},
X	{"setkeymap",	NAMEDF+TRLBAR},
X	{"shell",		TRLBAR},
X	{"source",		NAMEDF+NEEDARG+TRLBAR},
X	{"stop",		TRLBAR+BANG},
X	{"t",			RANGE+EXTRA+TRLBAR},
X	{"tag",			RANGE+BANG+WORD1+TRLBAR+ZEROR},
X	{"tags",		TRLBAR},
X	{"undo",		TRLBAR},
X	{"unabbreviate", EXTRA+TRLBAR+USECTRLV},
X	{"unmap",		BANG+EXTRA+TRLBAR+USECTRLV},
X	{"vglobal",		RANGE+EXTRA+DFLALL},
X	{"version",		TRLBAR},
X	{"visual",		RANGE+BANG+FILE1+TRLBAR},
X	{"write",		RANGE+BANG+FILE1+DFLALL+TRLBAR},
X	{"wnext",		RANGE+BANG+FILE1+TRLBAR},
X	{"winsize",		EXTRA+NEEDARG+TRLBAR},
X	{"wq",			BANG+FILE1+DFLALL+TRLBAR},
X	{"xit",			BANG+FILE1+DFLALL+TRLBAR},
X	{"yank",		RANGE+REGSTR+COUNT+TRLBAR},
X	{"z",			RANGE+COUNT+TRLBAR},		/* not supported */
X	{"@",			RANGE+EXTRA+TRLBAR},
X	{"!",			RANGE+NAMEDFS},
X	{"<",			RANGE+COUNT+TRLBAR},
X	{">",			RANGE+COUNT+TRLBAR},
X	{"=",			RANGE+TRLBAR},
X	{"&",			RANGE+EXTRA},
X	{"~",			RANGE+TRLBAR}				/* not supported */
X|
X};
X|
END_OF_FILE
if test 5314 -ne `wc -c <'vim/src/cmdtab.tab'`; then
    echo shar: \"'vim/src/cmdtab.tab'\" unpacked with wrong size!
fi
chmod +x 'vim/src/cmdtab.tab'
# end of 'vim/src/cmdtab.tab'
fi
if test -f 'vim/src/makefile.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.unix'\"
else
echo shar: Extracting \"'vim/src/makefile.unix'\" \(7083 characters\)
sed "s/^X//" >'vim/src/makefile.unix' <<'END_OF_FILE'
X#
X# Makefile for Vim on Unix, using gcc or standard cc
X#
X
X#>>>>> choose BSD_UNIX for Sun, Linux, IRIX, NeXT, POSIX and SYSV R4
X#	   or Apollo DOMAIN (with SYSTYPE = bsd4.3, change CC below)
X#	   or BSD_UNIX with TERMINFO for HPUX
X#	   or BSD_UNIX for Convex
X#          or SYSV_UNIX for Dynix/PTX, SCO-UNIX, UNICOS and SYSV R3
X#          or SOLARIS
X#          or UNICOS
X#	   or AIX (rs6000) (disable termcap below)
X#	   or UTS2 for Amdahl UTS 2.1.x (disable termcap below)
X#	   or UTS4 for Amdahl UTS 4.x
X#	   or USL for Unix Systems Laboratories (SYSV 4.2)
XMACHINE = -DBSD_UNIX
X#MACHINE = -DBSD_UNIX -DDOMAIN
X#MACHINE = -DBSD_UNIX -DTERMINFO
X#MACHINE = -DBSD_UNIX -DCONVEX
X#
X#MACHINE = -DSYSV_UNIX
X#MACHINE = -DSYSV_UNIX -DSOLARIS -DTERMINFO
X#MACHINE = -DSYSV_UNIX -DUNICOS
X#MACHINE = -DSYSV_UNIX -DAIX
X#MACHINE = -DSYSV_UNIX -DUTS2
X#MACHINE = -DSYSV_UNIX -DUTS4 -Xa
X#MACHINE = -DSYSV_UNIX -DUSL
X
X#>>>>> choose one compiler
X### standard C compiler, with optimizer, debugger or vanilla
XCC=cc -O
X#CC=cc -g
X#CC=cc
X
X### GCC on sun, Dynix
X#CC=gcc -O -Wall -traditional
X
X### GCC 2.2.2d on Linux (works for Sun OS also)
X#CC=gcc -O6 -Wall
X
X### GCC on SCO 3.2 and GCC 2.4.5 on NeXT
X#CC=gcc -O -Wall
X
X### GCC on another SCO Unix
X#CC=gcc -O6 -g -fpcc-struct-return -fwritable-strings
X
X### CenterLine cc
X#CC=clcc -O
X 
X### Apollo Domain cc
X#CC=cc -O -A systype,bsd4.3
X
X#>>>>> choose options for install
X### Name of target
XTARGET = vim
X
X### Prefix for location of files
XPREFIX = /usr/local
X
X### Location of binary
XBINLOC = $(PREFIX)/bin
X
X### Location of man page
XMANLOC = $(PREFIX)/man/man1
X
X### Location of help file
XHELPLOC = $(PREFIX)/lib
X
X### Permissions for vim binary
XBINMOD = 755
X
X### Permissions for man page
XMANMOD = 644
X
X### Permissions for help file
XHELPMOD = 644
X
XMANFILE = ../doc/vim.1
X
XHELPFILE = ../doc/vim.hlp
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support
X### -DNO_FREE_NULL	do not call free() with a null pointer
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DSTRNCASECMP	use strncasecmp() instead of internal function
X### -DUSE_LOCALE	use setlocale() to change ctype() and others
X### -DTERMCAP		full termcap file support
X### -DTERMINFO		use terminfo entries for builtin termcaps
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DMAXNAMLEN 31	maximum length of a file name (if not defined in sys/dir.h)
X### -Dconst=		for compilers that don't have type const
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
X### -DUSE_SYSTEM	use system() instead of fork/exec for starting a shell
X### -DVIM_ISSPACE	use when isspace() can't handle meta chars
X### -DSCO		SCO UNIX
X### -UM_XENIX		needed on SCO UNIX when using gcc
XDEFS = -DDIGRAPHS -DTERMCAP -DSOME_BUILTIN_TCAPS -DNO_FREE_NULL \
X	-DSYSVIMRC_FILE=\"\$$HOME/.vimrc\" -DSYSEXRC_FILE=\"\$$HOME/.exrc\" \
X	-DDEFVIMRC_FILE=\"/etc/vimrc\" -DVIM_HLP=\"$(HELPLOC)/vim.hlp\"
X
X#>>>>> link with termlib or termcap only if TERMCAP is defined
X### default
XLIBS = -ltermlib
X
X### termcap is for linux, HPUX, NeXT and others
X#LIBS = -ltermcap
X
X### for IRIX (Silicon Graphics Indigo, __sgi will be defined)
X#LIBS = -ltermlib -lmalloc -lc_s
X
X### UTS 2.1.6a (Amdahl UTS, _UTS will be defined)
X#LIBS = -ltermlib -lsocket
X
X### for SCO UNIX 3.2
X#LIBS = -ltinfo
X
X### for some SCO UNIX with gcc
X#LIBS = -ltermlib -lmalloc
X
X### without TERMCAP defined
X#LIBS = 
X
X#>>>>> end of choices
X###########################################################################
X
XCFLAGS = -c $(MACHINE) $(DEFS)
X
XINCL = vim.h globals.h param.h keymap.h macros.h ascii.h term.h unix.h debug.h
X
XOBJ =	alloc.o unix.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o term.o undo.o
X
X$(TARGET): $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) -o $(TARGET) $(OBJ) version.o $(LIBS)
X
Xdebug: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(CC) -o $(TARGET) -g $(OBJ) version.o $(LIBS)
X
Xctags:
X	csh -c ctags *.c *.h
X
Xinstall: $(TARGET)
X	chmod $(BINMOD) $(TARGET)
X	cp $(TARGET) $(BINLOC)
X	chmod $(MANMOD) $(MANFILE)
X	cp $(MANFILE) $(MANLOC)
X	chmod $(HELPMOD) $(HELPFILE)
X	cp $(HELPFILE) $(HELPLOC)
X
Xclean:
X	-rm -f $(OBJ) mkcmdtab.o version.o core $(TARGET) mkcmdtab
X	-rm -f *.bak
X
X#use this in case the files have been transported via an MSDOS system
X
XFILES = *.c *.h makefile makefile.* cmdtab.tab proto/*.pro tags
X
Xdos2unix:
X	-mv arp_prot.h arp_proto.h
X	-mv ptx_stdl.h ptx_stdlib.h
X	-mv sun_stdl.h sun_stdlib.h
X	-mv makefile.dic makefile.dice
X	-mv makefile.uni makefile.unix
X	-mv makefile.man makefile.manx
X	-mv makefile.6sa makefile.6sas
X	-mv makefile.5sa makefile.5sas
X	for i in $(FILES); do tr -d '\r\032' < $$i > ~tmp~; mv ~tmp~ $$i; echo $$i; done
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(INCL)
X	$(CC) $(CFLAGS) alloc.c
X
Xunix.o:	unix.c  $(INCL) unix.h
X	$(CC) $(CFLAGS) unix.c
X
Xbuffers.o:	buffers.c  $(INCL)
X	$(CC) $(CFLAGS) buffers.c
X
Xcharset.o:	charset.c  $(INCL)
X	$(CC) $(CFLAGS) charset.c
X
Xcmdline.o:	cmdline.c  $(INCL) cmdtab.h
X	$(CC) $(CFLAGS) cmdline.c
X
Xcsearch.o:	csearch.c  $(INCL)
X	$(CC) $(CFLAGS) csearch.c
X
Xdigraph.o:	digraph.c  $(INCL)
X	$(CC) $(CFLAGS) digraph.c
X
Xedit.o:	edit.c  $(INCL)
X	$(CC) $(CFLAGS) edit.c
X
Xfileio.o:	fileio.c  $(INCL)
X	$(CC) $(CFLAGS) fileio.c
X
Xhelp.o:	help.c  $(INCL)
X	$(CC) $(CFLAGS) help.c
X
Xlinefunc.o:	linefunc.c  $(INCL)
X	$(CC) $(CFLAGS) linefunc.c
X
Xmain.o:	main.c  $(INCL)
X	$(CC) $(CFLAGS) main.c
X
Xmark.o:	mark.c  $(INCL)
X	$(CC) $(CFLAGS) mark.c
X
Xmessage.o:	message.c  $(INCL)
X	$(CC) $(CFLAGS) message.c
X
Xmisccmds.o:	misccmds.c  $(INCL)
X	$(CC) $(CFLAGS) misccmds.c
X
Xnormal.o:	normal.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) normal.c
X
Xops.o:	ops.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) ops.c
X
Xparam.o:	param.c  $(INCL)
X	$(CC) $(CFLAGS) param.c
X
Xquickfix.o:	quickfix.c  $(INCL)
X	$(CC) $(CFLAGS) quickfix.c
X
Xregexp.o:	regexp.c  $(INCL)
X	$(CC) $(CFLAGS) regexp.c
X
Xregsub.o:	regsub.c  $(INCL)
X	$(CC) $(CFLAGS) regsub.c
X
Xscreen.o:	screen.c  $(INCL)
X	$(CC) $(CFLAGS) screen.c
X
Xscript.o:	script.c  $(INCL)
X	$(CC) $(CFLAGS) script.c
X
Xsearch.o:	search.c  $(INCL)
X	$(CC) $(CFLAGS) search.c
X
Xstorage.o:	storage.c  $(INCL)
X	$(CC) $(CFLAGS) storage.c
X
Xtag.o:	tag.c  $(INCL)
X	$(CC) $(CFLAGS) tag.c
X
Xterm.o:	term.c  $(INCL)
X	$(CC) $(CFLAGS) term.c
X
Xundo.o:	undo.c  $(INCL)
X	$(CC) $(CFLAGS) undo.c
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	./mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab: mkcmdtab.o
X	$(CC) -o mkcmdtab mkcmdtab.o
END_OF_FILE
if test 7083 -ne `wc -c <'vim/src/makefile.unix'`; then
    echo shar: \"'vim/src/makefile.unix'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.unix'
# end of 'vim/src/makefile.unix'
fi
if test -f 'vim/src/param.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/param.h'\"
else
echo shar: Extracting \"'vim/src/param.h'\" \(6735 characters\)
sed "s/^X//" >'vim/src/param.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * param.h: definition of global variables for settable parameters
X *
X * EXTERN is only defined in main.c (and vim.h)
X */
X
X#ifndef EXTERN
X# define EXTERN extern
X# define INIT(x)
X#else
X# ifndef INIT
X#  define INIT(x) x
X# endif
X#endif
X
X/*
X * The following are actual variabables for the parameters
X */
X
XEXTERN int	p_ai	INIT(= FALSE);		/* auto-indent */
XEXTERN int	p_aw	INIT(= FALSE);		/* auto-write */
XEXTERN long	p_bs	INIT(= 0);			/* backspace over newlines in insert mode */
X#if defined(COMPATIBLE) || defined(NOBACKUP)
XEXTERN int	p_bk	INIT(= FALSE);		/* make backups when writing out files */
X#else
XEXTERN int	p_bk	INIT(= TRUE);		/* make backups when writing out files */
X#endif
XEXTERN int	p_bin	INIT(= FALSE);		/* editing binary file */
X#ifdef MSDOS
XEXTERN int	p_biosk	INIT(= TRUE);		/* Use bioskey() instead of kbhit() */
X#endif
X#ifdef UNIX
XEXTERN char *p_bdir	INIT(= BACKUPDIR);	/* directory for backups */
X#endif
XEXTERN int	p_cp	INIT(= FALSE);		/* vi-compatible */
X#ifdef DIGRAPHS
XEXTERN int	p_dg	INIT(= FALSE);		/* enable digraphs */
X#endif /* DIGRAPHS */
XEXTERN char *p_dir	INIT(= "");			/* directory for autoscript file */
XEXTERN char *p_ep	INIT(= "indent");	/* program name for '=' command */
XEXTERN int	p_ed	INIT(= FALSE);		/* :s is ed compatible */
XEXTERN int	p_eb	INIT(= FALSE);		/* ring bell for errors */
X#ifdef AMIGA
XEXTERN char *p_ef	INIT(= "AztecC.Err");	/* name of errorfile */
X#else
XEXTERN char *p_ef	INIT(= "errors");			/* name of errorfile */
X#endif
X#ifdef AMIGA
XEXTERN char *p_efm	INIT(= "%f>%l:%c:%t:%n:%m");/* error format */
X#else
XEXTERN char *p_efm	INIT(= "\"%f\",%*[^0123456789]%l: %m");	/* error format */
X#endif
X#ifdef COMPATIBLE
XEXTERN int	p_ek	INIT(= FALSE);		/* function keys with ESC in insert mode */
X#else
XEXTERN int	p_ek	INIT(= TRUE);		/* function keys with ESC in insert mode */
X#endif
XEXTERN int	p_et	INIT(= FALSE);		/* expand tabs into spaces */
XEXTERN int	p_exrc	INIT(= FALSE);		/* read .exrc in current dir */
XEXTERN char *p_fp	INIT(= "");			/* name of format program */
X#ifdef MSDOS
XEXTERN int	p_gr	INIT(= TRUE);		/* display graphic characters */
X#else
XEXTERN int	p_gr	INIT(= FALSE);		/* display graphic characters */
X#endif
XEXTERN long p_hi	INIT(= 20);			/* command line history size */
XEXTERN char *p_hf	INIT(= VIM_HLP);	/* name of help file */
XEXTERN int	p_ic	INIT(= FALSE);		/* ignore case in searches */
XEXTERN int	p_im	INIT(= FALSE);		/* start editing in input mode */
XEXTERN char *p_kp	INIT(= "ref");		/* keyword program */
XEXTERN int	p_js	INIT(= TRUE);		/* use two spaces after period with Join */
XEXTERN int	p_list	INIT(= FALSE);		/* show tabs and newlines graphically */
XEXTERN int	p_magic INIT(= TRUE);		/* use some characters for reg exp */
XEXTERN char *p_mp	INIT(= "make");		/* program for :make command */
XEXTERN int	p_ml	INIT(= TRUE);		/* mode lines on/off */
XEXTERN long p_mls	INIT(= 5);			/* number of mode lines */
XEXTERN int	p_nu	INIT(= FALSE);		/* number lines on the screen */
XEXTERN int	p_paste	INIT(= FALSE);		/* paste mode */
XEXTERN char *p_para	INIT(= "IPLPPPQPP LIpplpipbp");		/* paragraphs */
XEXTERN int	p_ro	INIT(= FALSE);		/* readonly */
XEXTERN int	p_remap	INIT(= TRUE);		/* remap */
XEXTERN long	p_report	INIT(= 2);		/* minimum number of lines for report */
XEXTERN int	p_ru	INIT(= FALSE);		/* show column/line number */
XEXTERN int	p_ri	INIT(= FALSE);		/* reverse direction of insert */
XEXTERN int	p_secure	INIT(= FALSE);	/* do .exrc and .vimrc in secure mode */
XEXTERN long	p_scroll	INIT(= 12);		/* scroll size */
XEXTERN long	p_sj	INIT(= 1);			/* scroll jump size */
XEXTERN char *p_sections	INIT(= "SHNHH HUnhsh");		/* sections */
X#ifdef MSDOS
XEXTERN char *p_sh 	INIT(= "command");		/* name of shell to use */
X#else
XEXTERN char *p_sh 	INIT(= "sh");		/* name of shell to use */
X#endif
XEXTERN long	p_ss	INIT(= 0);			/* sideways scrolling offset */
XEXTERN long	p_st	INIT(= 0);			/* type of shell */
XEXTERN int	p_sr	INIT(= FALSE);		/* shift round off (for < and >) */
XEXTERN long	p_sw	INIT(= 8);			/* shiftwidth (for < and >) */
X#if defined(COMPATIBLE) || defined(UNIX)
XEXTERN int	p_sc	INIT(= FALSE);		/* show command in status line */
X#else
XEXTERN int	p_sc	INIT(= TRUE);		/* show command in status line */
X#endif
X#ifndef MSDOS
XEXTERN int	p_sn	INIT(= FALSE);		/* short names in file system */
X#endif
XEXTERN int	p_sm	INIT(= FALSE);		/* showmatch */
X#if defined(COMPATIBLE)
XEXTERN int	p_smd	INIT(= FALSE);		/* show mode */
X#else
XEXTERN int	p_smd	INIT(= TRUE);		/* show mode */
X#endif
XEXTERN int	p_si	INIT(= FALSE);		/* smart-indent for c programs */
XEXTERN char *p_su	INIT(= ".bak.o.h.info.vim");	/* suffixes for wildcard expansion */
XEXTERN long p_ts	INIT(= 8);			/* tab size in the file */
XEXTERN long p_tl	INIT(= 0);			/* used tag length */
XEXTERN char *p_tags	INIT(= "tags");		/* tags search path */
X#if defined(COMPATIBLE)
XEXTERN int	p_ta	INIT(= FALSE);		/* auto textmode detection */
X#else
XEXTERN int	p_ta	INIT(= TRUE);		/* auto textmode detection */
X#endif
X#ifdef MSDOS
XEXTERN int	p_tx	INIT(= TRUE);		/* textmode for file I/O */
X#else
XEXTERN int	p_tx	INIT(= FALSE);		/* textmode for file I/O */
X#endif
XEXTERN long p_tw	INIT(= 0);			/* textwidth */
XEXTERN int	p_to	INIT(= FALSE);		/* tilde is an operator */
XEXTERN int	p_timeout	INIT(= TRUE);	/* mappings entered within one second */
XEXTERN long p_tm	INIT(= 1000);		/* timeoutlen (msec) */
XEXTERN int	p_ttimeout	INIT(= FALSE);	/* key codes entered within one second */
X#ifdef COMPATIBLE
XEXTERN long p_ul	INIT(= 0);			/* number of Undo Levels */
XEXTERN long p_uc	INIT(= 0);			/* update count for auto script file */
X#else
XEXTERN long p_ul	INIT(= 100);		/* number of Undo Levels */
XEXTERN long p_uc	INIT(= 100);		/* update count for auto script file */
X#endif
XEXTERN long p_ut	INIT(= 2000);		/* update time for auto script file */
XEXTERN int	p_vb	INIT(= FALSE);		/* visual bell only (no beep) */
XEXTERN int	p_wrap	INIT(= TRUE);		/* wrap long lines */
XEXTERN int	p_warn	INIT(= TRUE);		/* warn for changes at shell command */
XEXTERN int	p_ws	INIT(= TRUE);		/* wrap scan */
X#ifdef COMPATIBLE
XEXTERN long	p_wc	INIT(= Ctrl('E'));	/* character for wildcard exapansion */
X#else
XEXTERN long	p_wc	INIT(= TAB);		/* character for wildcard exapansion */
X#endif
XEXTERN long p_wm	INIT(= 0);			/* wrapmargin */
XEXTERN int	p_wa	INIT(= FALSE);		/* write any */
X#if defined(COMPATIBLE) || defined(NOBACKUP)
XEXTERN int	p_wb	INIT(= FALSE);		/* write backup files */
X#else
XEXTERN int	p_wb	INIT(= TRUE);		/* write backup files */
X#endif
XEXTERN int	p_ye	INIT(= FALSE);		/* Y yanks to end of line */
END_OF_FILE
if test 6735 -ne `wc -c <'vim/src/param.h'`; then
    echo shar: \"'vim/src/param.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/param.h'
# end of 'vim/src/param.h'
fi
if test -f 'vim/src/regsub.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regsub.c'\"
else
echo shar: Extracting \"'vim/src/regsub.c'\" \(7440 characters\)
sed "s/^X//" >'vim/src/regsub.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * regsub
X *
X *		Copyright (c) 1986 by University of Toronto.
X *		Written by Henry Spencer.  Not derived from licensed software.
X *
X *		Permission is granted to anyone to use this software for any
X *		purpose on any computer system, and to redistribute it freely,
X *		subject to the following restrictions:
X *
X *		1. The author is not responsible for the consequences of use of
X *				this software, no matter how awful, even if they arise
X *				from defects in it.
X *
X *		2. The origin of this software must not be misrepresented, either
X *				by explicit claim or by omission.
X *
X *		3. Altered versions must be plainly marked as such, and must not
X *				be misrepresented as being the original software.
X *
X * $Log:		regsub.c,v $
X * Revision 1.2  88/04/28  08:11:25  tony
X * First modification of the regexp library. Added an external variable
X * 'reg_ic' which can be set to indicate that case should be ignored.
X * Added a new parameter to regexec() to indicate that the given string
X * comes from the beginning of a line and is thus eligible to match
X * 'beginning-of-line'.
X *
X * Revisions by Olaf 'Rhialto' Seibert, rhialto@cs.kun.nl:
X * Changes for vi: (the semantics of several things were rather different)
X * - Added lexical analyzer, because in vi magicness of characters
X *   is rather difficult, and may change over time.
X * - Added support for \< \> \1-\9 and ~
X * - Left some magic stuff in, but only backslashed: \| \+
X * - * and \+ still work after \) even though they shouldn't.
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
X#ifdef MSDOS
X# define __ARGS(a)	a
X#endif
X
X#define CASECONVERT
X
X#include <stdio.h>
X#include "regexp.h"
X#include "regmagic.h"
X
X#ifdef LATTICE
X# include <sys/types.h>		/* for size_t */
X#endif
X
X#ifndef CHARBITS
X#define UCHARAT(p)      ((int)*(unsigned char *)(p))
X#else
X#define UCHARAT(p)      ((int)*(p)&CHARBITS)
X#endif
X
Xextern char 	   *reg_prev_sub;
X
X#ifdef CASECONVERT
X	/*
X	 * We should define ftpr as a pointer to a function returning a pointer to
X	 * a function returning a pointer to a function ...
X	 * This is impossible, so we declare a pointer to a function returning a
X	 * pointer to a function returning void. This should work for all compilers.
X	 */
Xtypedef void (*(*fptr) __ARGS((char *, int)))();
Xstatic fptr strnfcpy __ARGS((fptr, char *, char *, int));
X
Xstatic fptr do_copy __ARGS((char *, int));
Xstatic fptr do_upper __ARGS((char *, int));
Xstatic fptr do_Upper __ARGS((char *, int));
Xstatic fptr do_lower __ARGS((char *, int));
Xstatic fptr do_Lower __ARGS((char *, int));
X
X	static fptr
Xdo_copy(d, c)
X	char *d;
X	int c;
X{
X	*d = c;
X
X	return (fptr)do_copy;
X}
X
X	static fptr
Xdo_upper(d, c)
X	char *d;
X	int c;
X{
X	*d = TO_UPPER(c);
X
X	return (fptr)do_copy;
X}
X
X	static fptr
Xdo_Upper(d, c)
X	char *d;
X	int c;
X{
X	*d = TO_UPPER(c);
X
X	return (fptr)do_Upper;
X}
X
X	static fptr
Xdo_lower(d, c)
X	char *d;
X	int c;
X{
X	*d = TO_LOWER(c);
X
X	return (fptr)do_copy;
X}
X
X	static fptr
Xdo_Lower(d, c)
X	char *d;
X	int c;
X{
X	*d = TO_LOWER(c);
X
X	return (fptr)do_Lower;
X}
X
X	static fptr
Xstrnfcpy(f, d, s, n)
X	fptr f;
X	char *d;
X	char *s;
X	int n;
X{
X	while (n-- > 0) {
X		f = (fptr)(f(d, *s));		/* Turbo C complains without the typecast */
X		if (!*s++)
X			break;
X		d++;
X	}
X
X	return f;
X}
X#endif
X
X/*
X * regtilde: replace tildes in the pattern by the old pattern
X *
X * Short explanation of the tilde: it stands for the previous replacement
X * pattern. If that previous pattern also contains a ~ we should go back
X * a step further... but we insert the previous pattern into the current one
X * and remember that.
X * This still does not handle the case where "magic" changes. TODO?
X *
X * New solution: The tilde's are parsed once before the first call to regsub().
X * In the old solution (tilde handled in regsub()) is was possible to get an
X * endless loop.
X */
X	char *
Xregtilde(source, magic)
X	char	*source;
X	int		magic;
X{
X	char	*newsub = NULL;
X	char	*tmpsub;
X	char	*p;
X	int		len;
X	int		prevlen;
X
X	for (p = source; *p; ++p)
X	{
X		if ((*p == '~' && magic) || (*p == '\\' && *(p + 1) == '~' && !magic))
X		{
X			if (reg_prev_sub)
X			{
X					/* length = len(current) - 1 + len(previous) + 1 */
X				prevlen = strlen(reg_prev_sub);
X				tmpsub = alloc((unsigned)(strlen(source) + prevlen));
X				if (tmpsub)
X				{
X						/* copy prefix */
X					len = (int)(p - source);	/* not including ~ */
X					strncpy(tmpsub, source, (size_t)len);
X						/* interpretate tilde */
X					strcpy(tmpsub + len, reg_prev_sub);
X						/* copy postfix */
X					if (!magic)
X						++p;					/* back off \ */
X					strcat(tmpsub + len, p + 1);
X
X					free(newsub);
X					newsub = tmpsub;
X					p = newsub + len + prevlen;
X				}
X			}
X			else if (magic)
X				strcpy(p, p + 1);				/* remove '~' */
X			else
X				strcpy(p, p + 2);				/* remove '\~' */
X		}
X		else if (*p == '\\' && p[1])			/* skip escaped characters */
X			++p;
X	}
X
X	free(reg_prev_sub);
X	if (newsub)
X	{
X		source = newsub;
X		reg_prev_sub = newsub;
X	}
X	else
X		reg_prev_sub = strsave(source);
X	return source;
X}
X
X/*
X - regsub - perform substitutions after a regexp match
X *
X * Returns the size of the replacement, including terminating \0.
X */
X	int
Xregsub(prog, source, dest, copy, magic)
X	regexp		   *prog;
X	char		   *source;
X	char		   *dest;
X	int 			copy;
X	int 			magic;
X{
X	register char  *src;
X	register char  *dst;
X	register char	c;
X	register int	no;
X	register int	len;
X#ifdef CASECONVERT
X	fptr			func = (fptr)do_copy;
X#endif
X
X	if (prog == NULL || source == NULL || dest == NULL)
X	{
X		emsg(e_null);
X		return 0;
X	}
X	if (UCHARAT(prog->program) != MAGIC)
X	{
X		emsg(e_re_corr);
X		return 0;
X	}
X	src = source;
X	dst = dest;
X
X	while ((c = *src++) != '\0')
X	{
X		no = -1;
X		if (c == '&' && magic)
X			no = 0;
X		else if (c == '\\')
X		{
X			if (*src == '&' && !magic)
X			{
X				++src;
X				no = 0;
X			}
X			else if ('0' <= *src && *src <= '9')
X			{
X				no = *src++ - '0';
X			}
X#ifdef CASECONVERT
X			else if (strchr("uUlLeE", *src))
X			{
X				switch (*src++)
X				{
X				case 'u':	func = (fptr)do_upper;
X							continue;
X				case 'U':	func = (fptr)do_Upper;
X							continue;
X				case 'l':	func = (fptr)do_lower;
X							continue;
X				case 'L':	func = (fptr)do_Lower;
X							continue;
X				case 'e':
X				case 'E':	func = (fptr)do_copy;
X							continue;
X				}
X			}
X#endif
X		}
X		if (no < 0)           /* Ordinary character. */
X		{
X			if (c == '\\')
X				c = *src++;
X			if (copy)
X			{
X#ifdef CASECONVERT
X				func = (fptr)(func(dst, c));
X							/* Turbo C complains without the typecast */
X#else
X				*dst = c;
X#endif
X			}
X			dst++;
X		}
X		else if (prog->startp[no] != NULL && prog->endp[no] != NULL)
X		{
X			len = (int)(prog->endp[no] - prog->startp[no]);
X			if (copy)
X			{
X#ifdef CASECONVERT
X				func = strnfcpy(func, dst, prog->startp[no], len);
X#else
X				(void) strncpy(dst, prog->startp[no], len);
X#endif
X			}
X			dst += len;
X			if (copy && len != 0 && *(dst - 1) == '\0') { /* strncpy hit NUL. */
X				emsg(e_re_damg);
X				goto exit;
X			}
X		}
X	}
X	if (copy)
X		*dst = '\0';
X
Xexit:
X	return (int)((dst - dest) + 1);
X}
END_OF_FILE
if test 7440 -ne `wc -c <'vim/src/regsub.c'`; then
    echo shar: \"'vim/src/regsub.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/regsub.c'
# end of 'vim/src/regsub.c'
fi
if test -f 'vim/todo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/todo'\"
else
echo shar: Extracting \"'vim/todo'\" \(6733 characters\)
sed "s/^X//" >'vim/todo' <<'END_OF_FILE'
XKnown problems:
X
XNone at the moment!
X
X
XProblems that will probably not be solved:
X
XSetting the size of the window with ":win" does not always work as expected.
XAmiga: When using quickfix with the Manx compiler we only get the first 25
X	errors. How do we get the rest?
XAmiga: The ":cq" command does not always abort the Manx compiler. Why?
X
X
XFurther extentions:
X
XIn visual select mode: Inclusion or exclusion of char under cursor depends
X	on movement command. "vwd" and "dw" do the same.
XFind out why macros of Stephen Riehm are working strange.
X:s///p prints the line after a substitution.
XWhen using the up/down cursor keys in insertmode keep the same column.
XMake CTRL-R (insert register contents) also work in command line mode.
XUpdatescript() can be done faster with a string instead of a char.
XWith :args, when there is only one line, don't call wait_return().
XAdd arguments to ":args", like ":next".
XWhen 'wrapscan' off give message "search hit BOTTOM without matching pattern".
XWhen 'wrapscan' on give message "search hit BOTTOM, continuing at TOP".
XAdd \! to search patterns: matches string that does not match previous atom.
XScreen updating is inefficient with CTRL-F and CTRL-B when there are long lines.
XAdd last inserted text to :display.
XMake z<nr><CR> more useful: put ruler and command on bottom line, reserve
X	more space for command line and messages (less need for hitreturn).
XUse 'backupdir' for all backup files? (Caughey)
XUse CTRL-E and CTRL-Y in insert mode for scroll up/down?
XWhen undone all changes reset the Changed flag.
XUppercase characters in ex commands can be made lowercase?
XAdd t_del, code for delete key (termcap 'kD') and maybe some other keys:
X	'kI' insert key, 'kL' delete line, etc.
XCTRL-V > should move the block, not whole lines.
XFiltering a block should only apply to the block, not to the whole lines. When
X	the number of lines is increased, add lines. When decreased, padd with
X	spaces or delete?
XIn out-of-memory situations: Free allocated space in undo (after asking).
XWith '#' and '*' commands: search whole words only (using \< and \>)?
X8-bit codes between 0x80 and 0xa0 cannot be typed directly (mostly msdos
X	problem). Need more codes for delete key and more function keys. Use
X	2-byte code?
XInsert octal numbers with CTRL-V o, hexadecimal with CTRL-V x and binary
X	with CTRL-V b.
XList mappings: Once with and without ^ and ~ (meta keys)
XIf ':' hit after "hit return to continue" no screen redraw required.
XAdd option that tells which characters to display directly, e.g.
X	":set gr=32-126,140-244", others are displayed with ^ and ~ and +
XAdd option to show character value in octal, decimal, hex and screen code.
XHow does vi detect whether a filter has messed up the screen? Check source.
X	After ":w !command" a wait_return?
XWith 'p' command on last line: scroll screen up (also for terminals without
X	insert line command).
XAmiga: ExpandWildCards in amiga.c: don't expand if there are no wildcards.
Xunix: Speedup wildcard expansion of "*", "~" and "$": do it internally, more
X	complicated things can still be done with the shell.
XOnly do wildcard expansion with 'wildchar' when entering a command that has a
X	file name as argument (:r :w :! :e :f :n)?
XIn regexp.c: "\^" after "\|" or "\(" is start of line, and "\$" before "\|"
X	and "\)" is end of line.
XRemember the "last changed" time of the edited file and check it before
X	overwriting; another user may have changed it.
XSupport for command lines longer than 256 characters (for EXINIT).
XOption for filter when reading/writing a file for compression or crypting.
XOption to set time for emsg() sleep.
XMake adjustmark() faster (sorted list of pointers? Hash list?)
XAdd "next tag" command for tags that have multiple hits.
XSupport static tags: first search for tags with current filename: "foo.c:bar",
X	then for global tags (without a filename).
XHistory stack for . command?
XWith CTRL-^ command swap the two entries at the top of the file list. Put filename
X	in the list only if it is not already there???
XUse insert/delete char when terminal supports it.
XWith undo with simple line delete/insert: optimize screen updating.
XOptimize screen redraw for slow terminals.
X"edit" option: when off changing the buffer is not possible.
XAdd "-d null" for editing from a script file without displaying.
XMSDOS: search for _exrc in the directory where the binary is, instead
X	of using $VIM\_exrc.
XIn insert mode: Remember the characters that were removed with backspace and
X	re-insert them one at a time with <key1>, all together with <key2>.
XAmiga: Add possibility to set a keymap. The code in amiga.c does not work yet.
XImplement 'redraw' option.
XAdd possibility to put the value of an option into the text: "'lines'p
XAdd 'crown' option to 'Q' command: preserve indent of second line.
XUnix: WildExpand: Without csh file name with embedded space will be split in two.
XAdd special code to 'sections' option to define something else but '{' or '}'
X	as the start of a section (e.g. one shiftwidth to the right).
XNopaste option: Mappings with non-printable characters are OK.
XAdd 'indent' option: Always use this amount of indent when starting a new line
X	and when formatting text.
XAdd option 'comment', initally "/*,*,*/,#", giving the characters at start of
X	a line that should be left alone by the internal formatting.
XAdd 'scrolloff': scroll when cursor is less then 'scrolloff' lines from top/bottom.
XAdd option to switch off ignoring braces inside quotes for "%" command??
XUse pipes for filtering on unix.
XAllow for +command and -option on any position in argv[].
XWith CTRL-O commands in insert mode: Allow to go to after last char in line.
XAdd commands like ]] and [[ that do not include the line jumped to.
X
XFrom Elvis:
Xfontchanges recognized "\\fB" etc.
X:color command
X:if and friends, conditional statements
XChange cursor shape in command/insert mode.
X
X
XFar future extentions:
X
XMSdos: use extended or expanded memory.
XUse disk swap file when editing very large files.
XWhen executing macro's: Save each line for undo only once.
XSmart cut/paste: recognize words and adjust spaces before/after them.
XAdd 'notwsuffixes' option: suffixes for files where 'tw' should be 0.
XKeyword completion: first look in the file for a match, then in a dictionary.
XSupport mouse control.
XSupport multiple windows (like xvi or emacs)
XOption verbose; when on keep the screen uptodate, when off only redisplay when
X	input needed.
XRemember message line for redraw. Integrate the command line in updateScreen().
XMode to keep text formatted while inserting/deleting.
XMode to keep C-code formatted (sort of on-line indent). Use colors for
X	keywords, comments, etc.
XKorn-shell like command line editing (like editing a single line with vi). Use
X	:cmap! for mappings.
END_OF_FILE
if test 6733 -ne `wc -c <'vim/todo'`; then
    echo shar: \"'vim/todo'\" unpacked with wrong size!
fi
chmod +x 'vim/todo'
# end of 'vim/todo'
fi
echo shar: End of archive 3 \(of 25\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
