Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i052:  vim - Vi IMitation editor, v2.0, Part02/25
Message-ID: <1993Dec21.034246.26758@sparky.sterling.com>
X-Md4-Signature: 26ea39fd7f4f54965129f57e7b5ff40b
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:42:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 52
Archive-name: vim/part02
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 25)."
# Contents:  vim/doc/Amiga.doc vim/doc/digr_doc.uue vim/doc/vim.1
#   vim/src/addcr.bat vim/src/alloc.c vim/src/charset.c vim/src/help.c
#   vim/src/keymap.h vim/src/linefunc.c vim/src/makefile.bcc
#   vim/src/makefile.dice vim/src/makefile.dos vim/src/message.c
#   vim/src/msdos.h vim/src/tccon_tc.uue vim/src/unix.h vim/termcap
#   vim/uganda.txt
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/doc/Amiga.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/Amiga.doc'\"
else
echo shar: Extracting \"'vim/doc/Amiga.doc'\" \(2211 characters\)
sed "s/^X//" >'vim/doc/Amiga.doc' <<'END_OF_FILE'
XThis file contains the particularities for the Amiga version of Vim.
X
XInstallation on the Amiga:
X- Assign "vim:" to the directory where the vim.hlp file is (for the help 
X  command).
X- With DOS 1.3 or earlier: Put "arp.library" in "libs:". Make sure that
X  newcli and run are in "c:" (for executing external commands).
X- Put a shell that accepts a command with "-c" (e.g. "Csh" from Fish disk 
X  624) in "c:" or in any other directory that is in your search path (for 
X  executing external commands).
X
XIf you have sufficient memory you can avoid startup delays by making Vim and 
Xcsh resident with the command "rez csh vim". You will have to put 
X"rezlib.library" in your "libs:" directory. Under 2.0 you will need rez 
Xversion 0.5.
X
XIf you do not use digraphs, you can save some memory by recompiling without 
Xthe DIGRAPHS option. If you want to use Vim with other terminals you can 
Xrecompile with the TERMCAP option. Vim compiles with Manx 5.x and SAS 6.x.
XSee the makefiles.
X
XIf you want to use different colors set the termcap code t_tp (for normal
Xtext) and/or t_ti (for inverted text).
X
XStandard ANSI escape sequences are used. The codes are:
X30 grey char   40 grey cell   >0 grey background    0 all attributes off
X31 black char  41 black cell  >1 black background   1 boldface
X32 white char  42 white cell  >2 white background   2 faint
X33 blue char   43 blue cell   >3 blue background    3 italic
X34 grey char   44 grey cell   >4 grey background    4 underscore
X35 black char  45 black cell  >5 black background   7 reverse video
X36 white char  46 white cell  >6 white background   8 invisible
X37 blue char   47 blue cell   >7 blue background
X
XThe codes with '>' must be the last. The cell and background color should be
Xthe same. The codes can be combined by separating them with a semicolon. For
Xexample to get white text on a blue background:
X	:set t_tp=^V<ESC>[0;32;43;>3m
X
XWhen using multiple commands with a filter command, e.g.
X	:r! echo this; echo that
XOnly the output of the last command is used. To fix this you have to group the
Xcommands. This depends on the shell you use (that is why it is not done
Xautomatically in Vim). Examples:
X	:r! (echo this; echo that)
X	:r! {echo this; echo that}
END_OF_FILE
if test 2211 -ne `wc -c <'vim/doc/Amiga.doc'`; then
    echo shar: \"'vim/doc/Amiga.doc'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/Amiga.doc'
# end of 'vim/doc/Amiga.doc'
fi
if test -f 'vim/doc/digr_doc.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/digr_doc.uue'\"
else
echo shar: Extracting \"'vim/doc/digr_doc.uue'\" \(2949 characters\)
sed "s/^X//" >'vim/doc/digr_doc.uue' <<'END_OF_FILE'
X
Xbegin 644 digraph.doc
XM5&AE<V4@87)E('1H92!D969A=6QT(&1I9W)A<&@@8VAA<F%C=&5R<R!F;W(@]
XM5FEM+@H*5&AE(&9I<G-T('1W;R!C:&%R86-T97)S(&EN(&5A8V@@8V]L=6UNG
XM(&%R92!T:&4@8VAA<F%C=&5R<R!Y;W4@:&%V92!T;R!T>7!E('1O"F5N=&5R*
XM(&$@9&EG<F%P:"X*"DEN('1H92!M:61D;&4@;V8@96%C:"!C;VQU;6X@:7,@9
XM=&AE(')E<W5L=&EN9R!C:&%R86-T97(N(%1H:7,@;6%Y(&)E(&UA;F=L960*!
XM:68@>6]U(&QO;VL@870@=&AI<R!F:6QE(&]N('-O;65T:&EN9R!E;'-E('1H>
XM86X@=&AE('-Y<W1E;2!T:&%T('1H97D@=V5R90IM96%N="!F;W(@;W(@=VAE>
XM;B!Y;W4@<')I;G0@:70N"@I4:&4@9&5C:6UA;"!N=6UB97(@:7,@=&AE($%3!
XM0TE)(&-O9&4@9F]R('1H92!C:&%R86-T97(N"@I$969A=6QT(&1I9W)A<&AS>
XM(&]N('1H92!!;6EG83H*?B$@H2`Q-C$@("!C?""B(#$V,B`@("0D(*,@,38S8
XM("`@;W@@I"`Q-C0@("!9+2"E(#$V-2`@('Q\(*8@,38V("`@<&$@IR`Q-C<*(
XM(B(@J"`Q-C@@("!C3R"I(#$V.2`@(&$M(*H@,3<P("`@/#P@JR`Q-S$@("`M_
XM+2"M(#$W,R`@(')/(*X@,3<T("`@+3T@KR`Q-S4*?F\@L"`Q-S8@("`K+2"Q$
XM(#$W-R`@(#(R(+(@,3<X("`@,S,@LR`Q-SD@("`G)R"T(#$X,"`@(&IU(+4@>
XM,3@Q("`@<'`@MB`Q.#(*?BX@MR`Q.#,@("`L+""X(#$X-"`@(#$Q(+D@,3@U:
XM("`@;RT@NB`Q.#8@("`^/B"[(#$X-R`@(#$T(+P@,3@X("`@,3(@O2`Q.#D*:
XM,S0@OB`Q.3`@("!^/R"_(#$Y,2`@($%@(,`@,3DR("`@02<@P2`Q.3,@("!!:
XM7B#"(#$Y-"`@($%^(,,@,3DU("`@02(@Q"`Q.38*04`@Q2`Q.3<@("!!12#&C
XM(#$Y."`@($,L(,<@,3DY("`@16`@R"`R,#`@("!%)R#)(#(P,2`@($5>(,H@/
XM,C`R("`@12(@RR`R,#,*26`@S"`R,#0@("!))R#-(#(P-2`@($E>(,X@,C`VQ
XM("`@22(@SR`R,#<@("`M1"#0(#(P."`@($Y^(-$@,C`Y("`@3V`@TB`R,3`*$
XM3R<@TR`R,3$@("!/7B#4(#(Q,B`@($]^(-4@,C$S("`@3R(@UB`R,30@("`OX
XM7"#7(#(Q-2`@($\O(-@@,C$V("`@56`@V2`R,3<*52<@VB`R,3@@("!57B#;K
XM(#(Q.2`@(%4B(-P@,C(P("`@62<@W2`R,C$@("!)<"#>(#(R,B`@('-S(-\@'
XM,C(S("`@86`@X"`R,C0*82<@X2`R,C4@("!A7B#B(#(R-B`@(&%^(.,@,C(W4
XM("`@82(@Y"`R,C@@("!A0"#E(#(R.2`@(&%E(.8@,C,P("`@8RP@YR`R,S$*]
XM96`@Z"`R,S(@("!E)R#I(#(S,R`@(&5>(.H@,C,T("`@92(@ZR`R,S4@("!I,
XM8"#L(#(S-B`@(&DG(.T@,C,W("`@:5X@[B`R,S@*:2(@[R`R,SD@("`M9"#PU
XM(#(T,"`@(&Y^(/$@,C0Q("`@;V`@\B`R-#(@("!O)R#S(#(T,R`@(&]>(/0@F
XM,C0T("`@;WX@]2`R-#4*;R(@]B`R-#8@("`Z+2#W(#(T-R`@(&\O(/@@,C0X3
XM("`@=6`@^2`R-#D@("!U)R#Z(#(U,"`@('5>(/L@,C4Q("`@=2(@_"`R-3(*V
XM>2<@_2`R-3,@("!I<"#^(#(U-"`@('DB(/\@,C4U"@I$969A=6QT(&1I9W)A?
XM<&AS(&]N($U31$]3.@I#+""`(#$R."`@('4B(($@,3(Y("`@92<@@B`Q,S`@R
XM("!A7B"#(#$S,2`@(&$B((0@,3,R("`@86`@A2`Q,S,@("!A0""&(#$S-`IC=
XM+""'(#$S-2`@(&5>((@@,3,V("`@92(@B2`Q,S<@("!E8""*(#$S."`@(&DB2
XM((L@,3,Y("`@:5X@C"`Q-#`@("!I8""-(#$T,0I!(B".(#$T,B`@($%`((\@^
XM,30S("`@12<@D"`Q-#0@("!A92"1(#$T-2`@($%%()(@,30V("`@;UX@DR`QB
XM-#<@("!O(B"4(#$T.`IO8""5(#$T.2`@('5>()8@,34P("`@=6`@ER`Q-3$@[
XM("!Y(B"8(#$U,B`@($\B()D@,34S("`@52(@FB`Q-30@("!C?"";(#$U-0HD\
XM)""<(#$U-B`@(%DM()T@,34W("`@4'0@GB`Q-3@@("!F9B"?(#$U.2`@(&$GN
XM(*`@,38P("`@:2<@H2`Q-C$@("!O)R"B(#$V,@IU)R"C(#$V,R`@(&Y^(*0@D
XM,38T("`@3GX@I2`Q-C4@("!A82"F(#$V-B`@(&]O(*<@,38W("`@?C\@J"`QF
XM-C@@("`M82"I(#$V.0IA+2"J(#$W,"`@(#$R(*L@,3<Q("`@,30@K"`Q-S(@Q
XM("!^(2"M(#$W,R`@(#P\(*X@,3<T("`@/CX@KR`Q-S4@("!S<R#A(#(R-0IJE
XM=2#F(#(S,"`@(&\O(.T@,C,W("`@*RT@\2`R-#$@("`^/2#R(#(T,B`@(#P]U
XM(/,@,C0S("`@.BT@]B`R-#8@("!^?B#W(#(T-PI^;R#X(#(T."`@(#(R(/T@C
X$,C4S"C0S+
X``
Xend
Xsize 2074
END_OF_FILE
if test 2949 -ne `wc -c <'vim/doc/digr_doc.uue'`; then
    echo shar: \"'vim/doc/digr_doc.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/digr_doc.uue'
# end of 'vim/doc/digr_doc.uue'
fi
if test -f 'vim/doc/vim.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/doc/vim.1'\"
else
echo shar: Extracting \"'vim/doc/vim.1'\" \(5091 characters\)
sed "s/^X//" >'vim/doc/vim.1' <<'END_OF_FILE'
X.TH VIM 1 "28 March 1992"
X.SH NAME
Xvim \- Vi IMproved, a programmers text editor
X.SH SYNOPSIS
X.B vim
X[options] [file ..]
X.br
X.B vim
X[options] \-t tag
X.br
X.B vim
X[options] +[command] file ..
X.br
X.B vim
X[options] \-c {command} file ..
X.br
X.B vim
X[options] \-e [errorfile]
X.SH DESCRIPTION
X.B Vim
Xis a text editor that is upwards compatible to vi. It can be used to edit any 
XASCII text. It is especially useful for editing programs.
X.PP
XThere are a lot of enhancements above vi: multi level undo, command line 
Xediting, filename completion, on line help, quoting, etc.. Read difference.doc 
Xfor a summary of the differences between vi and Vim.
X.PP
XMost often
X.B Vim
Xis started to edit a single file with the command
X.PP
X	vim file
X.PP
XMore generally VIM is started with:
X.PP
X	vim [options] [filelist]
X.PP
XIf the filelist is missing, the editor will start with an empty buffer.
XOtherwise exactly one out of the following four may be used to choose one or
Xmore files to be edited.
X.TP 12
Xfile ..
XA list of file names. The first one (alphabetically) will be
Xthe current file and read into the buffer. The cursor will be
Xpositioned on the first line of the buffer. You can get to the other files
Xwith the ":next" command.
X.TP
X+[num] file ..
XSame as the above, but the cursor will be positioned on line
X"num". If "num" is missing, the cursor will be positioned on
Xthe last line.
X.TP
X+/pat file ..
XSame as the above, but the cursor will be positioned on the
Xfirst occurrence of "pat" in the current file (see reference.doc, 
Xsection "pattern searches" for the available search 
Xpatterns).
X.TP
X+{command} file ..
X.TP
X-c {command} file ..
XSame as the above, but {command} will be executed after the 
Xfile has been read. {command} is interpreted as an Ex 
Xcommand. If the {command} contains spaces it must 
Xbe enclosed in double quotes (this depends on the shell that 
Xis used).
XExample: Vim "+set si" main.c
X.TP
X-t {tag}
XThe file to edit and the initial cursor position depends on a "tag", a sort 
Xof goto label. {tag} is looked up in the tags file, the associated file 
Xbecomes the current file and the associated command is executed. Mostly this 
Xis used for C programs. {tag} then should be a function name. The effect is 
Xthat the file containing that function becomes the current file and the 
Xcursor is positioned on the start of the function (see reference.doc, 
Xsection "tag searches").
X.TP
X-e [errorfile]
XStart in quickFix mode. The file [errorfile]
Xis read and the first error is displayed. If [errorfile] is omitted the file
Xname is obtained from the 'errorfile' option (defaults to "AztecC.Err" for
Xthe Amiga, "errors" on other systems). Further errors can be jumped to 
Xwith the ":cn" command. See reference.doc section 5.5.
X.SH OPTIONS
XThe options, if present, must precede the filelist. The options may be given 
Xin any order.
X.TP 12
X-r
XRecovery mode. The autoscript file is read to recover a 
Xcrashed editing session. It has almost the same effect as 
X"-s file.vim". See reference.doc, chapter "Recovery after a crash".
X.TP
X-v
XView mode. The 'readonly' option will be set. You can still 
Xedit the buffer, but will be prevented from accidental 
Xoverwriting a file. If you do want to overwrite a file, add 
Xan exclamation mark to the Ex command, as in ":w!". The 
X'readonly' option can be reset with ":set noro" (see reference.doc, 
Xoptions chapter).
X.TP
X-b
XBinary. A few options will be set that makes it possible to edit a binary or
Xexecutable file.
X.TP
X-x
X(Amiga only) Vim is not restarted to open a new window. This option should 
Xbe used when Vim is executed by a program that will wait for the edit 
Xsession to finish (e.g. mail). The ":sh" and ":!" commands will not work.
X.TP
X-n
XNo autoscript file will be written. Recovery after a crash 
Xwill be impossible. Handy if you want to edit a file on a 
Xvery slow medium (e.g. floppy). Can also be done with ":set 
Xuc=0".
X.TP
X-s {scriptin}
XThe script file {scriptin} is read. The characters in the 
Xfile are interpreted as if you had typed them. The same can 
Xbe done with the command ":source! {scriptin}". If the end 
Xof the file is reached before the editor exits, further 
Xcharacters are read from the keyboard.
X.TP
X-w {scriptout}
XAll the characters that you type are recorded in the file
X{scriptout}, until you exit VIM. This is useful if you want 
Xto create a script file to be used with "vim -s" or 
X":source!".
X.TP
X-T terminal
XTells Vim the name of the terminal you are using. Should be a terminal known 
Xto Vim (builtin) or defined in the termcap file.
X.TP
X-d device
XOpen "device" for use as a terminal. Only on the Amiga. Example:
X"\-d con:20/30/600/150".
X.SH SEE ALSO
XVim documentation:
X.br
Xreference.doc: A complete reference of Vim (long)
X.br
Xindex: Overview of all command characters (useful when mapping)
X.br
Xdifference.doc: Overview of the differences between vi and Vim
X.br
Xunix.doc: Unix-specific comments
X.br
Xvim.hlp: File used by the on-line help (short)
X.SH AUTHOR
XMost of VIM was made by Bram Moolenaar.
X.br
XVIM is based on Stevie, worked on by: Tim Thompson,
XTony Andrews and G.R. (Fred) Walter
X.SH BUGS
XProbably.
END_OF_FILE
if test 5091 -ne `wc -c <'vim/doc/vim.1'`; then
    echo shar: \"'vim/doc/vim.1'\" unpacked with wrong size!
fi
chmod +x 'vim/doc/vim.1'
# end of 'vim/doc/vim.1'
fi
if test -f 'vim/src/addcr.bat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/addcr.bat'\"
else
echo shar: Extracting \"'vim/src/addcr.bat'\" \(3570 characters\)
sed "s/^X//" >'vim/src/addcr.bat' <<'END_OF_FILE'
Xaddcr <addcr.c >tmp
Xcp tmp addcr.c 
Xaddcr <alloc.c >tmp
Xcp tmp alloc.c 
Xaddcr <ascii.h >tmp
Xcp tmp ascii.h 
Xaddcr <buffers.c >tmp
Xcp tmp buffers.c 
Xaddcr <charset.c >tmp
Xcp tmp charset.c 
Xaddcr <cmdline.c >tmp
Xcp tmp cmdline.c 
Xaddcr <cmdtab.h >tmp
Xcp tmp cmdtab.h 
Xaddcr <cmdtab.tab >tmp
Xcp tmp cmdtab.tab 
Xaddcr <csearch.c >tmp
Xcp tmp csearch.c 
Xaddcr <debug.h >tmp
Xcp tmp debug.h 
Xaddcr <digraph.c >tmp
Xcp tmp digraph.c 
Xaddcr <edit.c >tmp
Xcp tmp edit.c 
Xaddcr <env.h >tmp
Xcp tmp env.h 
Xaddcr <fileio.c >tmp
Xcp tmp fileio.c 
Xaddcr <globals.h >tmp
Xcp tmp globals.h 
Xaddcr <help.c >tmp
Xcp tmp help.c 
Xaddcr <keymap.h >tmp
Xcp tmp keymap.h 
Xaddcr <linefunc.c >tmp
Xcp tmp linefunc.c 
Xaddcr <macros.h >tmp
Xcp tmp macros.h 
Xaddcr <main.c >tmp
Xcp tmp main.c 
Xaddcr <makefile >tmp
Xcp tmp makefile 
Xaddcr <mark.c >tmp
Xcp tmp mark.c 
Xaddcr <mark.h >tmp
Xcp tmp mark.h 
Xaddcr <message.c >tmp
Xcp tmp message.c 
Xaddcr <misccmds.c >tmp
Xcp tmp misccmds.c 
Xaddcr <mkcmdtab.c >tmp
Xcp tmp mkcmdtab.c 
Xaddcr <msdos.c >tmp
Xcp tmp msdos.c 
Xaddcr <msdos.h >tmp
Xcp tmp msdos.h 
Xaddcr <normal.c >tmp
Xcp tmp normal.c 
Xaddcr <ops.c >tmp
Xcp tmp ops.c 
Xaddcr <ops.h >tmp
Xcp tmp ops.h 
Xaddcr <param.c >tmp
Xcp tmp param.c 
Xaddcr <param.h >tmp
Xcp tmp param.h 
Xaddcr <proto.h >tmp
Xcp tmp proto.h 
Xaddcr <quickfix.c >tmp
Xcp tmp quickfix.c 
Xaddcr <regexp.c >tmp
Xcp tmp regexp.c 
Xaddcr <regexp.h >tmp
Xcp tmp regexp.h 
Xaddcr <regmagic.h >tmp
Xcp tmp regmagic.h 
Xaddcr <regsub.c >tmp
Xcp tmp regsub.c 
Xaddcr <screen.c >tmp
Xcp tmp screen.c 
Xaddcr <script.c >tmp
Xcp tmp script.c 
Xaddcr <search.c >tmp
Xcp tmp search.c 
Xaddcr <storage.c >tmp
Xcp tmp storage.c 
Xaddcr <tag.c >tmp
Xcp tmp tag.c 
Xaddcr <tags >tmp
Xcp tmp tags 
Xaddcr <term.c >tmp
Xcp tmp term.c 
Xaddcr <term.h >tmp
Xcp tmp term.h 
Xaddcr <termlib.c >tmp
Xcp tmp termlib.c 
Xaddcr <termlib.fix >tmp
Xcp tmp termlib.fix 
Xaddcr <undo.c >tmp
Xcp tmp undo.c 
Xaddcr <version.c >tmp
Xcp tmp version.c 
Xaddcr <vim.h >tmp
Xcp tmp vim.h 
Xaddcr <vim.prj >tmp
Xcp tmp vim.prj 
Xaddcr <vimresp >tmp
Xcp tmp vimresp 
Xaddcr <proto\alloc.pro >tmp
Xcp tmp proto\alloc.pro 
Xaddcr <proto\amiga.pro >tmp
Xcp tmp proto\amiga.pro 
Xaddcr <proto\buffers.pro >tmp
Xcp tmp proto\buffers.pro 
Xaddcr <proto\charset.pro >tmp
Xcp tmp proto\charset.pro 
Xaddcr <proto\cmdline.pro >tmp
Xcp tmp proto\cmdline.pro 
Xaddcr <proto\csearch.pro >tmp
Xcp tmp proto\csearch.pro 
Xaddcr <proto\digraph.pro >tmp
Xcp tmp proto\digraph.pro 
Xaddcr <proto\edit.pro >tmp
Xcp tmp proto\edit.pro 
Xaddcr <proto\fileio.pro >tmp
Xcp tmp proto\fileio.pro 
Xaddcr <proto\help.pro >tmp
Xcp tmp proto\help.pro 
Xaddcr <proto\linefunc.pro >tmp
Xcp tmp proto\linefunc.pro 
Xaddcr <proto\main.pro >tmp
Xcp tmp proto\main.pro 
Xaddcr <proto\mark.pro >tmp
Xcp tmp proto\mark.pro 
Xaddcr <proto\message.pro >tmp
Xcp tmp proto\message.pro 
Xaddcr <proto\misccmds.pro >tmp
Xcp tmp proto\misccmds.pro 
Xaddcr <proto\normal.pro >tmp
Xcp tmp proto\normal.pro 
Xaddcr <proto\ops.pro >tmp
Xcp tmp proto\ops.pro 
Xaddcr <proto\param.pro >tmp
Xcp tmp proto\param.pro 
Xaddcr <proto\quickfix.pro >tmp
Xcp tmp proto\quickfix.pro 
Xaddcr <proto\regexp.pro >tmp
Xcp tmp proto\regexp.pro 
Xaddcr <proto\regsub.pro >tmp
Xcp tmp proto\regsub.pro 
Xaddcr <proto\screen.pro >tmp
Xcp tmp proto\screen.pro 
Xaddcr <proto\script.pro >tmp
Xcp tmp proto\script.pro 
Xaddcr <proto\search.pro >tmp
Xcp tmp proto\search.pro 
Xaddcr <proto\storage.pro >tmp
Xcp tmp proto\storage.pro 
Xaddcr <proto\tag.pro >tmp
Xcp tmp proto\tag.pro 
Xaddcr <proto\term.pro >tmp
Xcp tmp proto\term.pro 
Xaddcr <proto\termlib.pro >tmp
Xcp tmp proto\termlib.pro 
Xaddcr <proto\undo.pro >tmp
Xcp tmp proto\undo.pro 
Xdel tmp
END_OF_FILE
if test 3570 -ne `wc -c <'vim/src/addcr.bat'`; then
    echo shar: \"'vim/src/addcr.bat'\" unpacked with wrong size!
fi
chmod +x 'vim/src/addcr.bat'
# end of 'vim/src/addcr.bat'
fi
if test -f 'vim/src/alloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/alloc.c'\"
else
echo shar: Extracting \"'vim/src/alloc.c'\" \(3295 characters\)
sed "s/^X//" >'vim/src/alloc.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * alloc.c
X *
X * This file contains various routines dealing with allocation and
X * deallocation of memory. And some funcions for copying text.
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
X#ifdef AMIGA
X# undef FALSE			/* these are redefined in exec/types.h */
X# undef TRUE
X# include <exec/types.h>
X# include <exec/memory.h>
X# undef FALSE
X# define FALSE 0		/* define FALSE and TRUE as ints instead of longs */
X# undef TRUE
X# define TRUE 1
X#endif /* AMIGA */
X
X#ifdef MSDOS
X# include <alloc.h>
X#endif /* MSDOS */
X
X#define PANIC_FACTOR_CHIP 8192L
X
X/*
X * Note: if unsinged is 16 bits we can only allocate up to 64K with alloc().
X * Use lalloc for larger blocks.
X */
X	char *
Xalloc(size)
X	unsigned		size;
X{
X	return (lalloc((u_long)size, TRUE));
X}
X
X	char *
Xlalloc(size, message)
X	u_long			size;
X	int				message;
X{
X	register char   *p;			/* pointer to new storage space */
X
X#ifdef MSDOS
X	if (size >= 0xfff0)			/* in MSDOS we can't deal with >64K blocks */
X		p = NULL;
X	else
X#endif
X
X	if ((p = (char *)malloc(size)) != NULL)
X	{
X#ifdef AMIGA
X		if (AvailMem((long)MEMF_CHIP) < PANIC_FACTOR_CHIP)
X		{ 								/* System is low... no go! */
X				free(p);
X				p = NULL;
X		}
X#endif
X#ifdef MSDOS
X		if (coreleft() < PANIC_FACTOR_CHIP)
X		{ 								/* System is low... no go! */
X				free(p);
X				p = NULL;
X		}
X#endif
X	}
X	/*
X	 * Avoid repeating the error message many times (they take 1 second each).
X	 * Did_outofmem_msg is reset when a character is read.
X	 */
X	if (message && p == NULL && !did_outofmem_msg)
X	{
X		emsg(e_outofmem);
X		did_outofmem_msg = TRUE;
X	}
X	return (p);
X}
X
X/*
X * copy a string into newly allocated memory
X */
X	char *
Xstrsave(string)
X	char		   *string;
X{
X	char *p;
X
X	p = alloc((unsigned) (strlen(string) + 1));
X	if (p != NULL)
X		strcpy(p, string);
X	return p;
X}
X
X	char *
Xstrnsave(string, len)
X	char		*string;
X	int 		len;
X{
X	char *p;
X
X	p = alloc((unsigned) (len + 1));
X	if (p != NULL)
X	{
X		strncpy(p, string, (size_t)len);
X		p[len] = NUL;
X	}
X	return p;
X}
X
X/*
X * copy a number of spaces
X */
X	void
Xcopy_spaces(ptr, count)
X	char	*ptr;
X	size_t	count;
X{
X	register size_t	i = count;
X	register char	*p = ptr;
X
X	while (i--)
X		*p++ = ' ';
X}
X
X#ifdef NO_FREE_NULL
X#undef free
X/*
X * replacement for free() that cannot handle NULL pointers
X */
X	void
XnofreeNULL(x)
X	void *x;
X{
X	if (x != NULL)
X		free(x);
X}
X#endif
X
X#ifdef BSD_UNIX
X	char *
Xbsdmemset(ptr, c, size)
X	char	*ptr;
X	int		c;
X	long	size;
X{
X	register char *p = ptr;
X
X	while (size-- > 0)
X		*p++ = c;
X	return ptr;
X}
X#endif
X
X#ifdef MEMMOVE
X/*
X * Version of memmove that handles overlapping source and destination.
X * For systems that don't have a function that is guaranteed to do that (SYSV).
X */
X	void *
Xmemmove(desti, source, len)
X	void	*source, *desti;
X#ifdef __sgi
X	size_t	len;
X#else
X	int		len;
X#endif
X{
X	char *src = (char *)source;
X	char *dst = (char *)desti;
X
X	if (dst > src && dst < src + len)	/* overlap, copy backwards */
X	{
X		src +=len;
X		dst +=len;
X		while (--len >= 0)
X			*--dst = *--src;
X	}
X	else								/* copy forwards */
X		while (--len >= 0)
X			*dst++ = *src++;
X	return desti;
X}
X#endif
END_OF_FILE
if test 3295 -ne `wc -c <'vim/src/alloc.c'`; then
    echo shar: \"'vim/src/alloc.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/alloc.c'
# end of 'vim/src/alloc.c'
fi
if test -f 'vim/src/charset.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/charset.c'\"
else
echo shar: Extracting \"'vim/src/charset.c'\" \(2093 characters\)
sed "s/^X//" >'vim/src/charset.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
X
X	char *
Xtranschar(c)
X	unsigned c;
X{
X		static char buf[3];
X
X		if (c < ' ')
X		{
X				if (c == NL)
X						c = NUL;		/* we use newline in place of a NUL */
X				buf[0] = '^';
X				buf[1] = '@' + c;
X				buf[2] = NUL;
X		}
X		else if (c <= '~' || c > 0xa0 || p_gr)
X		{
X				buf[0] = c;
X				buf[1] = NUL;
X		}
X		else
X		{
X				if (c == 0x7f)		/* DEL displayed as ^?, not ~? */
X					buf[0] = '^';
X				else
X					buf[0] = '~';
X				buf[1] = c - 0x80 + '@';
X				buf[2] = NUL;
X		}
X		return buf;
X}
X
X/*
X * output 'len' characters in 'str' (including NULs) with translation
X * if 'len' is -1, output upto a NUL character
X * return the number of characters it takes on the screen
X */
X	int
Xouttrans(str, len)
X	register char *str;
X	register int   len;
X{
X	int retval = 0;
X
X	if (len == -1)
X		len = strlen(str);
X	while (--len >= 0)
X	{
X		outstrn(transchar(*(u_char *)str));
X		retval += charsize(*(u_char *)str);
X		++str;
X	}
X	return retval;
X}
X
X/*
X * return the number of characters 'c' will take on the screen
X */
X	int
Xcharsize(c)
X	int c;
X{
X	return ((c >= ' ' && (p_gr || c <= '~')) || c > 0xa0 ? 1 : 2);
X}
X
X/*
X * return the number of characters string 's' will take on the screen
X */
X	int
Xstrsize(s)
X	char *s;
X{
X	int	len = 0;
X
X	while (*s)
X		len += charsize(*s++);
X	return len;
X}
X
X/*
X * return the number of characters 'c' will take on the screen, taking
X * into account the size of a tab
X */
X	int
Xchartabsize(c, col)
X	register int	c;
X	int				col;
X{
X	if ((c >= ' ' && (c <= '~' || p_gr)) || c > 0xa0)
X   		return 1;
X   	else if (c == TAB && !p_list)
X   		return (int)(p_ts - (col % p_ts));
X   	else
X		return 2;
X}
X
X/*
X * return TRUE if 'c' is an identifier character
X */
X	int
Xisidchar(c)
X	int c;
X{
X#ifdef __STDC__
X		return (isalnum(c) || c == '_');
X#else
X		return (isalpha(c) || isdigit(c) || c == '_');
X#endif
X}
END_OF_FILE
if test 2093 -ne `wc -c <'vim/src/charset.c'`; then
    echo shar: \"'vim/src/charset.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/charset.c'
# end of 'vim/src/charset.c'
fi
if test -f 'vim/src/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/help.c'\"
else
echo shar: Extracting \"'vim/src/help.c'\" \(3532 characters\)
sed "s/^X//" >'vim/src/help.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * help.c: display help from the vim.hlp file
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
Xstatic long helpfilepos;		/* position in help file */
Xstatic FILE *helpfd;			/* file descriptor of help file */
X
X#define MAXSCREENS 52			/* one screen for a-z and A-Z */
X
X	void
Xhelp()
X{
X	int		c;
X	int		eof;
X	int		screens;
X	int		i;
X	long	filepos[MAXSCREENS];	/* seek position for each screen */
X	int		screennr;			/* screen number; index == 0, 'c' == 1, 'd' == 2, etc */
X#ifdef MSDOS
X	char	*fnamep;
X#endif
X
X/*
X * try to open the file specified by the "helpfile" option
X */
X	if ((helpfd = fopen(p_hf, READBIN)) == NULL)
X	{
X#ifdef MSDOS
X	/*
X	 * for MSDOS: try the DOS search path
X     */
X		fnamep = searchpath("vim.hlp");
X		if (fnamep == NULL || (helpfd = fopen(fnamep, READBIN)) == NULL)
X		{
X			smsg("Sorry, help file \"%s\" and \"vim.hlp\" not found", p_hf);
X			return;
X		}
X#else
X		smsg("Sorry, help file \"%s\" not found", p_hf);
X		return;
X#endif
X	}
X	helpfilepos = 0;
X	screennr = 0;
X	for (i = 0; i < MAXSCREENS; ++i)
X		filepos[i] = 0;
X	State = HELP;
X	for (;;)
X	{
X		screens = redrawhelp();				/* show one or more screens */
X		eof = (screens < 0);
X		if (!eof && screennr + screens < MAXSCREENS)
X			filepos[screennr + screens] = ftell(helpfd);
X
X		if ((c = vgetc()) == '\n' || c == '\r' || c == Ctrl('C') || c == ESC)
X			break;
X
X		if (c == ' ' ||
X#ifdef MSDOS
X				(c == K_NUL && vpeekc() == 'Q') ||	/* page down */
X#endif
X				c == Ctrl('F'))						/* one screen forwards */
X		{
X			if (screennr < MAXSCREENS && !eof)
X				++screennr;
X		}
X		else if (c == 'a')					/* go to first screen */
X			screennr = 0;
X		else if (c == 'b' ||
X#ifdef MSDOS
X				(c == K_NUL && vpeekc() == 'I') ||	/* page up */
X#endif
X				c == Ctrl('B'))					/* go one screen backwards */
X		{
X			if (screennr > 0)
X				--screennr;
X		}
X		else if (isalpha(c))				/* go to specified screen */
X		{
X			if (isupper(c))
X				c = c - 'A' + 'z' + 1;		/* 'A' comes after 'z' */
X			screennr = c - 'b';
X		}
X#ifdef MSDOS
X		if (c == K_NUL)
X			c = vgetc();
X#endif
X		for (i = screennr; i > 0; --i)
X			if (filepos[i])
X				break;
X		fseek(helpfd, filepos[i], 0);
X		while (i < screennr)
X		{
X			while ((c = getc(helpfd)) != '\f' && c != -1)
X				;
X			if (c == -1)
X				break;
X			filepos[++i] = ftell(helpfd);	/* store the position just after the '\f' */
X		}
X		screennr = i;						/* required when end of file reached */
X		helpfilepos = filepos[screennr];
X	}
X	State = NORMAL;
X	script_winsize_pp();
X	fclose(helpfd);
X	updateScreen(CLEAR);
X}
X
X	int
Xredrawhelp()
X{
X	int nextc;
X	int col;
X	int	line = 0;
X	int	screens = 1;
X
X	fseek(helpfd, helpfilepos, 0);
X	outstr(T_ED);
X	windgoto(0,0);
X	while ((nextc = getc(helpfd)) != -1 && (nextc != '\f' || line < Rows - 24))
X	{
X		if (nextc == Ctrl('B'))			/* begin of invert */
X			outstr(T_TI);
X		else if (nextc == Ctrl('E'))	/* end of invert */
X			outstr(T_TP);
X		else if (nextc == '\f')			/* start of next screen */
X		{
X			++screens;
X			outchar('\n');
X			++line;
X		}
X		else
X		{
X			outchar((char)nextc);
X			if (nextc == '\n')
X				++line;
X		}
X	}
X	windgoto(0, (int)(Columns - strlen(Version) - 1));
X	outstrn(Version);
X	col = (int)Columns - 52;
X	if (col < 0)
X		col = 0;
X	windgoto((int)Rows - 1, col);
X	outstrn("<space = next; return = quit; a = index; b = back>");
X	return (nextc == -1 ? -1 : screens);
X}
END_OF_FILE
if test 3532 -ne `wc -c <'vim/src/help.c'`; then
    echo shar: \"'vim/src/help.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/help.c'
# end of 'vim/src/help.c'
fi
if test -f 'vim/src/keymap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/keymap.h'\"
else
echo shar: Extracting \"'vim/src/keymap.h'\" \(2135 characters\)
sed "s/^X//" >'vim/src/keymap.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Keycode definitions for special keys
X *
X * On systems that have any of these keys, the routine 'inchar' in the
X * machine-dependent code should return one of the codes here.
X */
X
X/*
X * On MSDOS we use other codes, because the codes 0x80 - 0xb0 are used
X * for special characters. If this is changed also change the numbers in
X * term.h and main.c.
X */
X#ifdef MSDOS
X# define K_OFF 0x30
X#else
X# define K_OFF 0x00
X#endif
X
X#define K_CCIRCM		0x1e	/* control circumflex */
X
X/*
X * careful: the next entries must be in the same order as the termcap strings
X * in term.h and the numbers must be consecutive (used by inchar()).
X */
X#define K_UARROW		(K_OFF + 0x80)
X#define K_DARROW		(K_OFF + 0x81)
X#define K_LARROW		(K_OFF + 0x82)
X#define K_RARROW		(K_OFF + 0x83)
X#define K_SUARROW		(K_OFF + 0x84)
X#define K_SDARROW		(K_OFF + 0x85)
X#define K_SLARROW		(K_OFF + 0x86)
X#define K_SRARROW		(K_OFF + 0x87)
X
X#define K_F1			(K_OFF + 0x88)	/* function keys */
X#define K_F2			(K_OFF + 0x89)
X#define K_F3			(K_OFF + 0x8a)
X#define K_F4			(K_OFF + 0x8b)
X#define K_F5			(K_OFF + 0x8c)
X#define K_F6			(K_OFF + 0x8d)
X#define K_F7			(K_OFF + 0x8e)
X#define K_F8			(K_OFF + 0x8f)
X#define K_F9			(K_OFF + 0x90)
X#define K_F10			(K_OFF + 0x91)
X
X#define K_SF1			(K_OFF + 0x92)	/* shifted function keys */
X#define K_SF2			(K_OFF + 0x93)
X#define K_SF3			(K_OFF + 0x94)
X#define K_SF4			(K_OFF + 0x95)
X#define K_SF5			(K_OFF + 0x96)
X#define K_SF6			(K_OFF + 0x97)
X#define K_SF7			(K_OFF + 0x98)
X#define K_SF8			(K_OFF + 0x99)
X#define K_SF9			(K_OFF + 0x9a)
X#define K_SF10			(K_OFF + 0x9b)
X
X#define K_HELP			(K_OFF + 0x9c)
X#define K_UNDO			(K_OFF + 0x9d)
X
X/*
X * NULs cannot be in the input string, therefore CTRL-@ is replaced by K_ZERO.
X * K_NUL is used for MSDOS extended keys (same value used in term.h).
X */
X#define K_NUL			(K_OFF + 0x9e)	/* for MSDOS: special key follows */
X#define K_ZERO			(K_OFF + 0x9f)	/* replaces ^@ */
END_OF_FILE
if test 2135 -ne `wc -c <'vim/src/keymap.h'`; then
    echo shar: \"'vim/src/keymap.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/keymap.h'
# end of 'vim/src/keymap.h'
fi
if test -f 'vim/src/linefunc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/linefunc.c'\"
else
echo shar: Extracting \"'vim/src/linefunc.c'\" \(2618 characters\)
sed "s/^X//" >'vim/src/linefunc.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * linefunc.c: some functions to move to the next/previous line and
X *			   to the next/previous character
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X
X/*
X * coladvance(col)
X *
X * Try to advance the Cursor to the specified column.
X */
X
X	void
Xcoladvance(wcol)
X	colnr_t 		wcol;
X{
X	int 				index;
X	register u_char		*ptr;
X	register colnr_t	col;
X
X	ptr = (u_char *)nr2ptr(Curpos.lnum);
X
X	/* try to advance to the specified column */
X	index = -1;
X	col = 0;
X	while (col <= wcol && *ptr)
X	{
X		++index;
X		/* Count a tab for what it's worth (if list mode not on) */
X		col += chartabsize(*ptr, col);
X		++ptr;
X	}
X	if (index < 0)
X		Curpos.col = 0;
X	else
X		Curpos.col = index;
X}
X
X/*
X * inc(p)
X *
X * Increment the line pointer 'p' crossing line boundaries as necessary. Return
X * 1 when crossing a line, -1 when at end of file, 0 otherwise.
X */
X	int
Xinc(lp)
X	register FPOS  *lp;
X{
X	register char  *p = pos2ptr(lp);
X
X	if (*p != NUL)
X	{			/* still within line */
X		lp->col++;
X		return ((p[1] != NUL) ? 0 : 1);
X	}
X	if (lp->lnum != line_count)
X	{			/* there is a next line */
X		lp->col = 0;
X		lp->lnum++;
X		return 1;
X	}
X	return -1;
X}
X
X	int
XincCurpos()
X{
X	return inc(&Curpos);
X}
X
X/*
X * incl(lp): same as inc(), but skip the NUL at the end of non-empty lines
X */
X	int
Xincl(lp)
X	register FPOS *lp;
X{
X	register int r;
X
X	if ((r = inc(lp)) == 1 && lp->col)
X		r = inc(lp);
X	return r;
X}
X
X/*
X * dec(p)
X *
X * Decrement the line pointer 'p' crossing line boundaries as necessary. Return
X * 1 when crossing a line, -1 when at start of file, 0 otherwise.
X */
X	int
Xdec(lp)
X	register FPOS  *lp;
X{
X	if (lp->col > 0)
X	{			/* still within line */
X		lp->col--;
X		return 0;
X	}
X	if (lp->lnum > 1)
X	{			/* there is a prior line */
X		lp->lnum--;
X		lp->col = strlen(nr2ptr(lp->lnum));
X		return 1;
X	}
X	return -1;					/* at start of file */
X}
X
X	int
XdecCurpos()
X{
X	return dec(&Curpos);
X}
X
X/*
X * decl(lp): same as dec(), but skip the NUL at the end of non-empty lines
X */
X	int
Xdecl(lp)
X		register FPOS *lp;
X{
X		register int r;
X
X		if ((r = dec(lp)) == 1 && lp->col)
X				r = dec(lp);
X		return r;
X}
X
X/*
X * make sure Curpos in on a valid character
X */
X	void
XadjustCurpos()
X{
X	int len;
X
X	if (Curpos.lnum == 0)
X		Curpos.lnum = 1;
X	if (Curpos.lnum > line_count)
X		Curpos.lnum = line_count;
X
X	len = strlen(nr2ptr(Curpos.lnum));
X	if (len == 0)
X		Curpos.col = 0;
X	else if (Curpos.col >= len)
X		Curpos.col = len - 1;
X}
END_OF_FILE
if test 2618 -ne `wc -c <'vim/src/linefunc.c'`; then
    echo shar: \"'vim/src/linefunc.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/linefunc.c'
# end of 'vim/src/linefunc.c'
fi
if test -f 'vim/src/makefile.bcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.bcc'\"
else
echo shar: Extracting \"'vim/src/makefile.bcc'\" \(3722 characters\)
sed "s/^X//" >'vim/src/makefile.bcc' <<'END_OF_FILE'
X#
X# Makefile for Borland C++ 2.0
X# Can also be used for Turbo C++
X#
X# The options are at the end of this file
X#
X
X.AUTODEPEND
X
X#		*Translator Definitions*
X#   use tcc for Turbo C++
XCC = bcc +VIM.CFG
X#CC = tcc +VIM.CFG
XTASM = TASM
XTLIB = tlib
XTLINK = tlink
X#
X# Adjust the paths for your environment
X#
XLIBPATH = E:\BORLANDC\LIB
XINCLUDEPATH = E:\BORLANDC\INCLUDE
X 
X 
X#		*Implicit Rules*
X.c.obj:
X  $(CC) -c {$< }
X 
X.cpp.obj:
X  $(CC) -c {$< }
X 
X#		*List Macros*
X 
X 
XEXE_dependencies =  \
X alloc.obj \
X buffers.obj \
X charset.obj \
X cmdline.obj \
X csearch.obj \
X digraph.obj \
X edit.obj \
X fileio.obj \
X help.obj \
X linefunc.obj \
X main.obj \
X mark.obj \
X message.obj \
X misccmds.obj \
X msdos.obj \
X normal.obj \
X ops.obj \
X param.obj \
X quickfix.obj \
X regexp.obj \
X regsub.obj \
X screen.obj \
X script.obj \
X search.obj \
X storage.obj \
X tag.obj \
X term.obj \
X undo.obj \
X version.obj
X 
X#		*Explicit Rules*
X#  add /v for source degubbing
Xvim.exe: vim.cfg $(EXE_dependencies)
X  $(CC) -c version.c
X  $(TLINK) /x/c/L$(LIBPATH) @&&|
Xc0l.obj+
Xalloc.obj+
Xbuffers.obj+
Xcharset.obj+
Xcmdline.obj+
Xcsearch.obj+
Xdigraph.obj+
Xedit.obj+
Xfileio.obj+
Xhelp.obj+
Xlinefunc.obj+
Xmain.obj+
Xmark.obj+
Xmessage.obj+
Xmisccmds.obj+
Xmsdos.obj+
Xnormal.obj+
Xops.obj+
Xparam.obj+
Xquickfix.obj+
Xregexp.obj+
Xregsub.obj+
Xscreen.obj+
Xscript.obj+
Xsearch.obj+
Xstorage.obj+
Xtag.obj+
Xterm.obj+
Xundo.obj+
Xversion.obj
Xvim
X		# no map file
Xfp87.lib+
Xmathl.lib+
Xcl.lib
X|
X 
X 
X#		*Individual File Dependencies*
Xalloc.obj: alloc.c 
X 
Xbuffers.obj: buffers.c 
X 
Xcharset.obj: charset.c 
X 
Xcmdline.obj: cmdline.c cmdtab.h
X 
Xcmdtab.h: cmdtab.tab mkcmdtab.exe
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab.exe: mkcmdtab.obj
X	$(CC) -ml -omkcmdtab mkcmdtab.obj
X
Xmkcmdtab.obj: mkcmdtab.c
X	$(CC) $(CFLAGS) mkcmdtab.c
X
Xcsearch.obj: csearch.c 
X 
Xdigraph.obj: digraph.c 
X 
Xedit.obj: edit.c 
X 
Xfileio.obj: fileio.c 
X 
Xhelp.obj: help.c 
X 
Xlinefunc.obj: linefunc.c 
X 
Xmain.obj: main.c globals.h param.h
X 
Xmark.obj: mark.c mark.h
X 
Xmessage.obj: message.c 
X 
Xmisccmds.obj: misccmds.c 
X 
Xmsdos.obj: msdos.c 
X 
Xnormal.obj: normal.c ops.h
X 
Xops.obj: ops.c ops.h
X 
Xparam.obj: param.c 
X 
Xquickfix.obj: quickfix.c 
X 
Xregexp.obj: regexp.c 
X 
Xregsub.obj: regsub.c 
X 
Xscreen.obj: screen.c 
X 
Xscript.obj: script.c 
X 
Xsearch.obj: search.c 
X 
Xstorage.obj: storage.c 
X 
Xtag.obj: tag.c mark.h
X 
Xterm.obj: term.c term.h
X 
Xundo.obj: undo.c 
X 
Xversion.obj: version.c 
X 
X#		*Compiler Configuration File*
X# The following compile options can be changed for better machines.
X#	replace -1- with -2 to produce code for a 80286 or higher
X#	replace -1- with -3 to produce code for a 80386 or higher
X#	add -v for source debugging
Xvim.cfg: makefile
X  copy &&|
X-ml
X-1-
X-f-
X-C
X-N
X-O
X-Z
X-k-
X-d
X-h
X-vi-
X-H=VIM.SYM
X-w-par
X-w-pro
X-weas
X-wpre
X-I$(INCLUDEPATH)
X-L$(LIBPATH)
X-DPC;MSDOS;DIGRAPHS
X| vim.cfg
X
X#
X# options:
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DNO_ARP		do not use arp.library, DOS 2.0 required
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
END_OF_FILE
if test 3722 -ne `wc -c <'vim/src/makefile.bcc'`; then
    echo shar: \"'vim/src/makefile.bcc'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.bcc'
# end of 'vim/src/makefile.bcc'
fi
if test -f 'vim/src/makefile.dice' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.dice'\"
else
echo shar: Extracting \"'vim/src/makefile.dice'\" \(3076 characters\)
sed "s/^X//" >'vim/src/makefile.dice' <<'END_OF_FILE'
X#
X# Makefile for VIM, using DICE 2.06.40 and 2.06.21
X#
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DNO_ARP		do not use arp.library, DOS 2.0 required
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
XDEFINES = -DTERMCAP -DDIGRAPHS -DSOME_BUILTIN_TCAPS
X
X#>>>>> if TERMCAP is defined termlib.o has to be used
XTERMLIB = termlib.o
X#TERMLIB = 
X
X#>>>>> end of choices
X###########################################################################
X
XCFLAGS = -c -DAMIGA $(DEFINES)
X
XINCL = vim.syms
XPRE = -H${INCL}=vim.h
XLIBS = -lmanx -la
XCC = dcc
XLD = dcc
X
X.c.o:
X	${CC} ${PRE} ${CFLAGS} $*.c -o $@
X
XOBJ =	alloc.o amiga.o buffers.o charset.o cmdline.o csearch.o digraph.o \
X	edit.o fileio.o help.o linefunc.o main.o mark.o message.o misccmds.o \
X	normal.o ops.o param.o quickfix.o regexp.o regsub.o screen.o \
X	script.o search.o storage.o tag.o undo.o $(TERMLIB)
X
X/Vim: $(OBJ) version.c
X	${CC} $(CFLAGS) version.c -o version.o
X	${LD} -o /Vim $(OBJ) version.o $(LIBS)
X
Xdebug: $(OBJ) version.c
X	${CC} $(CFLAGS) version.c -o version.o
X	${LD} -s -o /Vim $(OBJ) version.o $(LIBS)
X
Xctags:
X	csh -c ctags *.c *.h
X
X# can't use delete here, too many file names
Xclean:
X	csh -c rm -f $(OBJ) version.o mkcmdtab.o /Vim $(INCL) mkcmdtab
X
X$(INCL)  : vim.h globals.h keymap.h macros.h ascii.h term.h amiga.h
X	delete $(INCL)
X
X###########################################################################
X
Xalloc.o:	alloc.c  $(INCL)
X
Xamiga.o:	amiga.c  $(INCL) amiga.h
X
Xbuffers.o:	buffers.c  $(INCL)
X
Xcharset.o:	charset.c  $(INCL)
X
Xcmdline.o:	cmdline.c  $(INCL) cmdtab.h
X
Xcsearch.o:	csearch.c  $(INCL) regexp.h
X
Xdigraph.o: digraph.c	$(INCL)
X
Xedit.o: edit.c	$(INCL)
X
Xfileio.o:	fileio.c  $(INCL)
X
Xhelp.o: help.c	$(INCL)
X
Xlinefunc.o:	linefunc.c  $(INCL)
X
Xmain.o: main.c
X	${CC} ${CFLAGS} main.c -o main.o
X
Xmark.o: mark.c	$(INCL) mark.h
X
Xmessage.o:	message.c  $(INCL)
X
Xmisccmds.o:	misccmds.c  $(INCL)
X
Xnormal.o:	normal.c  $(INCL) ops.h
X
Xops.o:	ops.c  $(INCL) ops.h
X
Xparam.o:	param.c  $(INCL)
X# Because of a bug in DC1 2.06.40, initialisation of unions does not
X# work correctly. dc1-21 is DC1 2.06.21 which does work.
X	rename dc1-21 dc1
X	${CC} ${CFLAGS} param.c -o param.o
X	rename dc1 dc1-21
X
Xquickfix.o:	quickfix.c  $(INCL)
X
Xregexp.o:	regexp.c  $(INCL) regexp.h
X
Xregsub.o:	regsub.c  $(INCL) regexp.h
X
Xscreen.o:	screen.c  $(INCL)
X
Xscript.o:	script.c  $(INCL)
X
Xsearch.o:	search.c  $(INCL) regexp.h
X
Xtag.o:	tags.c  $(INCL) mark.h
X
Xtermlib.o:	termlib.c $(INCL)
X
Xstorage.o:	storage.c  $(INCL)
X
Xundo.o: undo.c	$(INCL)
X
Xcmdtab.h: cmdtab.tab mkcmdtab
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab: mkcmdtab.o
X	${LD} -o mkcmdtab mkcmdtab.o
END_OF_FILE
if test 3076 -ne `wc -c <'vim/src/makefile.dice'`; then
    echo shar: \"'vim/src/makefile.dice'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.dice'
# end of 'vim/src/makefile.dice'
fi
if test -f 'vim/src/makefile.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/makefile.dos'\"
else
echo shar: Extracting \"'vim/src/makefile.dos'\" \(3714 characters\)
sed "s/^X//" >'vim/src/makefile.dos' <<'END_OF_FILE'
X#
X# Makefile for VIM on MSDOS, using Turbo C
X#
X
X#>>>>> choose options:
X### -DDIGRAPHS		digraph support (at the cost of 1.6 Kbyte code)
X### -DCOMPATIBLE	start in vi-compatible mode
X### -DNOBACKUP		default is no backup file
X### -DDEBUG		output a lot of debugging garbage
X### -DTERMCAP		include termcap file support
X### -DNO_BUILTIN_TCAPS	do not include builtin termcap entries
X###				(use only with -DTERMCAP)
X### -DSOME_BUILTIN_TCAPS include most useful builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DALL_BUILTIN_TCAPS	include all builtin termcap entries
X###				(use only without -DNO_BUILTIN_TCAPS)
X### -DVIMRC_FILE	name of the .vimrc file in current dir
X### -DEXRC_FILE		name of the .exrc file in current dir
X### -DSYSVIMRC_FILE	name of the global .vimrc file
X### -DSYSEXRC_FILE	name of the global .exrc file
X### -DDEFVIMRC_FILE	name of the system-wide .vimrc file
X### -DVIM_HLP		name of the help file
XDEFINES = -DDIGRAPHS
X
X#>>>>> name of the compiler and linker, name of lib directory
XCC = tcc
XLINK = tlink
XLIB = c:\turboc\lib
X
X#>>>>> end of choices
X###########################################################################
X
XINCL = vim.h globals.h param.h keymap.h macros.h ascii.h term.h msdos.h
XCFLAGS = -c -ml -DMSDOS $(DEFINES)
X
XOBJ =	alloc.obj msdos.obj buffers.obj charset.obj cmdline.obj csearch.obj \
X	digraph.obj edit.obj fileio.obj help.obj linefunc.obj main.obj mark.obj \
X	message.obj misccmds.obj normal.obj ops.obj param.obj quickfix.obj \
X	regexp.obj regsub.obj screen.obj script.obj search.obj storage.obj \
X	tag.obj term.obj undo.obj
X
X..\vim: $(OBJ) version.c
X	$(CC) $(CFLAGS) version.c
X	$(LINK) /c /m $(LIB)\C0l @vimresp,..\vim,..\vim,$(LIB)\emu $(LIB)\Cl
X
Xctags:
X	command /c ctags *.c *.h
X
Xclean:
X	del $(OBJ) version.obj mkcmdtab.obj ..\vim mkcmdtab
X
Xaddcr:	addcr.c
X	$(CC) addcr.c
X	command /c addcr.bat
X
X###########################################################################
X
Xalloc.obj:	alloc.c  $(INCL)
X	$(CC) $(CFLAGS) alloc.c
X
Xmsdos.obj:	msdos.c  $(INCL) msdos.h
X	$(CC) $(CFLAGS) msdos.c
X
Xbuffers.obj:	buffers.c  $(INCL)
X	$(CC) $(CFLAGS) buffers.c
X
Xcharset.obj:	charset.c  $(INCL)
X	$(CC) $(CFLAGS) charset.c
X
Xcmdline.obj:	cmdline.c  $(INCL) cmdtab.h
X	$(CC) $(CFLAGS) cmdline.c
X
Xcsearch.obj:	csearch.c  $(INCL)
X	$(CC) $(CFLAGS) csearch.c
X
Xdigraph.obj:	digraph.c  $(INCL)
X	$(CC) $(CFLAGS) digraph.c
X
Xedit.obj:	edit.c  $(INCL)
X	$(CC) $(CFLAGS) edit.c
X
Xfileio.obj:	fileio.c  $(INCL)
X	$(CC) $(CFLAGS) fileio.c
X
Xhelp.obj:	help.c  $(INCL)
X	$(CC) $(CFLAGS) help.c
X
Xlinefunc.obj:	linefunc.c  $(INCL)
X	$(CC) $(CFLAGS) linefunc.c
X
Xmain.obj:	main.c  $(INCL)
X	$(CC) $(CFLAGS) main.c
X
Xmark.obj:	mark.c  $(INCL)
X	$(CC) $(CFLAGS) mark.c
X
Xmessage.obj:	message.c  $(INCL)
X	$(CC) $(CFLAGS) message.c
X
Xmisccmds.obj:	misccmds.c  $(INCL)
X	$(CC) $(CFLAGS) misccmds.c
X
Xnormal.obj:	normal.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) normal.c
X
Xops.obj:	ops.c  $(INCL) ops.h
X	$(CC) $(CFLAGS) ops.c
X
Xparam.obj:	param.c  $(INCL)
X	$(CC) $(CFLAGS) param.c
X
Xquickfix.obj:	quickfix.c  $(INCL)
X	$(CC) $(CFLAGS) quickfix.c
X
Xregexp.obj:	regexp.c  $(INCL)
X	$(CC) $(CFLAGS) regexp.c
X
Xregsub.obj:	regsub.c  $(INCL)
X	$(CC) $(CFLAGS) regsub.c
X
Xscreen.obj:	screen.c  $(INCL)
X	$(CC) $(CFLAGS) screen.c
X
Xscript.obj:	script.c  $(INCL)
X	$(CC) $(CFLAGS) script.c
X
Xsearch.obj:	search.c  $(INCL)
X	$(CC) $(CFLAGS) search.c
X
Xstorage.obj:	storage.c  $(INCL)
X	$(CC) $(CFLAGS) storage.c
X
Xtag.obj:	tag.c  $(INCL)
X	$(CC) $(CFLAGS) tag.c
X
Xterm.obj:	term.c  $(INCL)
X	$(CC) $(CFLAGS) term.c
X
Xundo.obj:	undo.c  $(INCL)
X	$(CC) $(CFLAGS) undo.c
X
Xcmdtab.h: cmdtab.tab mkcmdtab.exe
X	mkcmdtab cmdtab.tab cmdtab.h
X
Xmkcmdtab.exe: mkcmdtab.obj
X	$(CC) -ml -omkcmdtab mkcmdtab.obj
X
Xmkcmdtab.obj: mkcmdtab.c
X	$(CC) $(CFLAGS) mkcmdtab.c
END_OF_FILE
if test 3714 -ne `wc -c <'vim/src/makefile.dos'`; then
    echo shar: \"'vim/src/makefile.dos'\" unpacked with wrong size!
fi
chmod +x 'vim/src/makefile.dos'
# end of 'vim/src/makefile.dos'
fi
if test -f 'vim/src/message.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/message.c'\"
else
echo shar: Extracting \"'vim/src/message.c'\" \(3525 characters\)
sed "s/^X//" >'vim/src/message.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * message.c: functions for displaying messages on the command line
X */
X
X#include "vim.h"
X#include "globals.h"
X#define MESSAGE
X#include "proto.h"
X#include "param.h"
X
Xstatic int msg_invert = FALSE;		/* message should be inverted */
X
X/*
X * msg(s) - displays the string 's' on the status line
X */
X	void
Xmsg(s)
X	char		   *s;
X{
X	if (Columns == 0)	/* terminal not initialized */
X	{
X		fprintf(stderr, s);
X		fflush(stderr);
X		return;
X	}
X
X	start_msg();
X	if (msg_invert && T_TI)
X	{
X		outstr(T_TI);
X		char_count -= strlen(T_TI);
X	}
X	outtrans(s, -1);
X	if (msg_invert && T_TP)
X	{
X		outstr(T_TP);
X		msg_invert = FALSE;
X		char_count -= strlen(T_TP);
X	}
X	end_msg();
X}
X
X#ifndef PROTO		/* automatic prototype generation does not understand this */
X/* VARARGS */
X	void
Xsmsg(s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
X	char		*s;
X	long		a1, a2, a3, a4, a5, a6, a7, a8, a9, a10;
X{
X	sprintf(IObuff, s, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
X	msg(IObuff);
X}
X#endif
X
X/*
X * emsg() - display an error message
X *
X * Rings the bell, if appropriate, and calls message() to do the real work
X */
X	void
Xemsg(s)
X	char		   *s;
X{
X	if (p_eb)
X		beep();					/* also includes flush_buffers() */
X	else
X		flush_buffers(FALSE);	/* flush internal buffers */
X	msg_invert = TRUE;
X	msg(s);
X	if (char_count < sc_col)	/* if wait_return not called */
X		sleep(1);				/* give the user a chance to read the message */
X}
X
X	void
Xemsg2(s, a1)
X	char *s, *a1;
X{
X	sprintf(IObuff, s, a1);
X	emsg(IObuff);
X}
X
Xextern int global_busy, global_wait;	/* shared with csearch.c, cmdline.c */
X
X	void
Xwait_return(redraw)
X	int		redraw;
X{
X	u_char			c;
X	int				oldState;
X	int				tmpState;
X
X		/* with the global command we only need one return at the end */
X	if (global_busy)
X	{
X		global_wait = 1;
X		starttermcap();
X		return;
X	}
X	oldState = State;
X	State = HITRETURN;
X	if (got_int)
X		outstrn("Interrupt: ");
X
X#ifdef ORG_HITRETURN
X	outstrn("Press RETURN to continue");
X	do {
X		c = vgetc();
X	} while (strchr("\r\n: ", c) == NULL);
X	if (c == ':')			 		/* this can vi too (but not always!) */
X		stuffcharReadbuff(c);
X#else
X	outstrn("Press RETURN or enter command to continue");
X	c = vgetc();
X	breakcheck();
X	if (strchr("\r\n ", c) == NULL)
X		stuffcharReadbuff(c);
X#endif
X
X	if (!termcap_active)			/* start termcap before redrawing */
X		starttermcap();
X
X/*
X * If the window size changed set_winsize() will redraw the screen.
X * Otherwise the screen is only redrawn if 'redraw' is set.
X */
X	tmpState = State;
X	State = oldState;				/* restore State before set_winsize */
X	if (tmpState == SETWSIZE)		/* got resize event while in vgetc() */
X		set_winsize(0, 0, FALSE);
X	else if (redraw)
X		updateScreen(CLEAR);
X
X	script_winsize_pp();
X}
X
X	void
Xstart_msg()
X{
X	gotocmdline(TRUE, NUL);
X	char_count = 0;
X}
X
X	void
Xend_msg()
X{
X	/*
X	 * if the string is larger than the window,
X	 * or the ruler option is set and we run into it,
X	 * we have to redraw the window.
X	 * Do not do this if we are abandoning the file.
X	 */
X	if (!exiting && char_count >= sc_col)
X	{
X		outchar('\n');
X		wait_return(TRUE);
X	}
X	else
X		flushbuf();
X}
X
X	void
Xcheck_msg()
X{
X	/*
X	 * if the string is larger than the window,
X	 * or the ruler option is set and we run into it,
X	 * we have to redraw the window later.
X	 */
X	if (char_count >= sc_col)
X		must_redraw = CLEAR;
X	cmdoffset = char_count / Columns;
X}
END_OF_FILE
if test 3525 -ne `wc -c <'vim/src/message.c'`; then
    echo shar: \"'vim/src/message.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/message.c'
# end of 'vim/src/message.c'
fi
if test -f 'vim/src/msdos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/msdos.h'\"
else
echo shar: Extracting \"'vim/src/msdos.h'\" \(2144 characters\)
sed "s/^X//" >'vim/src/msdos.h' <<'END_OF_FILE'
X/* vi:ts=8:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar		mool@oce.nl
X *				Tim Thompson		twitch!tjt
X *				Tony Andrews		onecom!wldrdg!tony
X *				G. R. (Fred) Walter	watmath!watcgl!grwalter
X */
X
X/*
X * MSDOS Machine-dependent filenames.
X */
X#ifdef SYSEXRC_FILE
X# undef SYSEXRC_FILE
X# undef SYSVIMRC_FILE
X#endif /* SYSEXRC_FILE */
X#define SYSEXRC_FILE "$VIM\\_exrc"
X#define SYSVIMRC_FILE "$VIM\\_vimrc"
X
X#ifdef EXRC_FILE
X# undef EXRC_FILE
X# undef VIMRC_FILE
X#endif /* EXRC_FILE */
X#define EXRC_FILE "_exrc"
X#define VIMRC_FILE "_vimrc"
X
X#ifdef VIM_HLP
X# undef VIM_HLP
X#endif /* VIM_HLP */
X#define VIM_HLP "$VIM\\vim.hlp"
X
X#ifdef TMPNAME1
X# undef TMPNAME1
X# undef TMPNAME2
X# undef TMPNAMELEN
X#endif /* TMPNAME1 */
X#define TMPNAME1 "viXXXXXX"		/* put it in current dir */
X#define TMPNAME2 "voXXXXXX"		/*  is there a better place? */
X#define TMPNAMELEN	10
X
X/*
X * MSDOS Machine-dependent routines.
X */
X
X#ifdef remove
X# undef remove                   /* MSDOS remove()s when not readonly */
X#endif
X#define remove vim_remove
X
X/* use chdir() that also changes the default drive */
X#define chdir vim_chdir
X
X/* msdos.c */
Xvoid	vim_delay __ARGS((void));
Xint	vim_remove __ARGS((char *));
Xvoid	flushbuf __ARGS((void));
Xvoid	outchar __ARGS((unsigned));
Xvoid	outstr __ARGS((char *));
Xint 	GetChars __ARGS((char *, int, int));
Xvoid	mch_suspend __ARGS((void));
Xvoid	mch_windinit __ARGS((void));
Xvoid	check_win __ARGS((int, char **));
Xvoid	fname_case __ARGS((char *));
Xvoid	settitle __ARGS((char *));
Xvoid	resettitle __ARGS((void));
Xint	dirname __ARGS((char *, int));
Xint	FullName __ARGS((char *, char *, int));
Xlong	getperm __ARGS((char *));
Xint	setperm __ARGS((char *, long));
Xint	isdir __ARGS((char *));
Xvoid	mch_windexit __ARGS((int));
Xvoid	mch_settmode __ARGS((int));
Xint	mch_get_winsize __ARGS((void));
Xvoid	mch_set_winsize __ARGS((void));
Xint	call_shell __ARGS((char *, int, int));
Xvoid	breakcheck __ARGS((void));
Xchar	*modname __ARGS((char *, char *));
Xint	has_wildcard __ARGS((char *));
Xint	ExpandWildCards __ARGS((int, char **, int *, char ***, int, int));
Xvoid	FreeWild __ARGS((int, char **));
Xvoid	set_window __ARGS((void));
END_OF_FILE
if test 2144 -ne `wc -c <'vim/src/msdos.h'`; then
    echo shar: \"'vim/src/msdos.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/msdos.h'
# end of 'vim/src/msdos.h'
fi
if test -f 'vim/src/tccon_tc.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/tccon_tc.uue'\"
else
echo shar: Extracting \"'vim/src/tccon_tc.uue'\" \(2410 characters\)
sed "s/^X//" >'vim/src/tccon_tc.uue' <<'END_OF_FILE'
X
Xbegin 644 tcconfig.tc
XM5'5R8F\@0R!#;VYF:6=U<F%T:6]N($9I;&4@&@`!#1(7`1H``@$!``(````";
XM``(``0`#``(``@`$``$```4``0``!@`!```(``$`!`D``@````T``@`!``X`2
XM`@```!$``0`($@`"````$P`"`!D`%``"````%0`"``$`%@`"````%P`"``$`^
XM&``"``$`9``!``%E``$``68``0`!9P`!``%H``$``6D``0`!:@`!``%K``$`F
XM`6P``0`!;0`!``%N``$``6\``0`!<``!``%Q``$``7(``0`!<P`!``%T``$`"
XM`74``0`!=@`!``%W``$``7@``0`!>0`!``%Z``$``7L``0``?``!``%]``$`2
XM`7X``0``?P`!``&```$``8(``0``A``!``&%``$``<@``0``R0`!``#*``$`Q
XM`<L``0``S``!``#-``$``,X``0`!SP`!``#0``$`&=$``0!DT@`!`"#5``$`Q
XM`-<``0``V``!``#9``$``=H``0`!VP`!``#<``$``=T``0`!W@`!``#?``$``
XM`.```0``X0`!``#B``$``2P!1```````````````````````````````````8
XM`````````````````````````````````````````````````````````"T!N
XM@`!$.EQ40UQ)3D-,541%````````````````````````````````````````1
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````"X!@`!$S
XM.EQ40UQ,24(`````````````````````````````````````````````````@
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````"\!4`!624TN:
XM4%)*````````````````````````````````````````````````````````L
XM`````````````````````````````````````````#`!!``S,@``,0$%`#(UX
XM````,@$%`#$P,```,P%_`$U31$]3.U=)3$1?0T%21%,`````````````````Y
XM`````````````````````````````````````````````````````````````
XM`````````````````````````````````````````````````````````````
XM```````````T`1X`*@``````````````````````````````````````-0$>1
XM`"H``````````````````````````````````````#8!'@`J````````````I
XM```````````````````````````W`1X`*@```````````````````````````
XM````````````.`$>`"H``````````````````````````````````````#D![
XM'@`J```````````````````````````````````````Z`1X`*@``````````+
XM````````````````````````````.P$>`"H`````````````````````````$
XM`````````````#P!'@`J```````````````````````````````````````]"
XM`8``````````````````````````````````````````````````````````!
XM`````````````````````````````````````````````````````````````
XM```````````````````````````````````````````````````````^`00`#
XM.````#\!4```````````````````````````````````````````````````(
XM`````````````````````````````````````````````````````````$`!!
XM1`!$.EQ40P``````````````````````````````````````````````````U
XM`````````````````````````````````$$!4```````````````````````2
XM`````````````````````````````````````````````````````````````
X9`````````````````````````/__`@`:````:
X``
Xend
Xsize 1690
END_OF_FILE
if test 2410 -ne `wc -c <'vim/src/tccon_tc.uue'`; then
    echo shar: \"'vim/src/tccon_tc.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/src/tccon_tc.uue'
# end of 'vim/src/tccon_tc.uue'
fi
if test -f 'vim/src/unix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/unix.h'\"
else
echo shar: Extracting \"'vim/src/unix.h'\" \(2448 characters\)
sed "s/^X//" >'vim/src/unix.h' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * Unix system-dependent filenames
X */
X#define BACKUPDIR "$HOME"
X
X#ifdef TMPNAME1
X# undef TMPNAME1
X# undef TMPNAME2
X# undef TMPNAMELEN
X#endif /* TMPNAME1 */
X#define TMPNAME1 "/tmp/viXXXXXX"
X#define TMPNAME2 "/tmp/voXXXXXX"
X#define TMPNAMELEN	15
X
X#ifdef MAX_COLUMNS
X# undef MAX_COLUMNS
X#endif /* MAX_COLUMNS */
X#define MAX_COLUMNS 1024
X
X#define stricmp vim_stricmp
X
Xvoid	flushbuf __ARGS((void));
Xvoid	outchar __ARGS((unsigned));
Xvoid	outstr __ARGS((char *));
Xvoid	mch_write __ARGS((char *, int));
Xint 	GetChars __ARGS((char *, int, int));
Xvoid	vim_delay __ARGS((void));
Xvoid	mch_suspend __ARGS((void));
Xvoid	mch_windinit __ARGS((void));
Xvoid	check_win __ARGS((int, char **));
Xvoid	fname_case __ARGS((char *));
Xvoid	settitle __ARGS((char *));
Xvoid	resettitle __ARGS((void));
Xvoid	mch_settmode __ARGS((int));
Xint 	dirname __ARGS((char *, int));
Xint		FullName __ARGS((char *, char *, int));
Xlong	getperm __ARGS((char *));
Xint		setperm __ARGS((char *, int));
Xint		isdir __ARGS((char *));
Xvoid	mch_windexit __ARGS((int));
Xint		mch_get_winsize __ARGS((void));
Xvoid	mch_set_winsize __ARGS((void));
Xint		call_shell __ARGS((char *, int, int));
Xvoid	breakcheck __ARGS((void));
X#ifdef SCO
Xint		chmod __ARGS((const char *, mode_t));
X#endif
X#if !defined(linux) && !defined(__NeXT) && !defined(M_UNIX) && !defined(ISC) && !defined(USL)
Xint		remove __ARGS((const char *));
X/*
X * If you get an error message on "const" in the lines above, try
X * adding "-Dconst=" to the options in the makefile.
X */
X
X/* generic functions, not in unix.c */
X# if !defined(SCO) && !defined(SOLARIS)
Xvoid	sleep __ARGS((int));
X# endif
Xint		rename __ARGS((const char *, const char *));
X#endif
X
Xint		stricmp __ARGS((char *, char *));
X
Xint		has_wildcard __ARGS((char *));
Xint		have_wildcard __ARGS((int, char **));
Xint		ExpandWildCards __ARGS((int, char **, int *, char ***, int, int));
Xvoid	FreeWild __ARGS((int, char **));
X
X/* memmove is not present on all systems, use our own version or bcopy */
X#if !defined(SCO) && !defined(SOLARIS) && !defined(AIX) && !defined(UTS4) && !defined(USL)
X# ifdef SYSV_UNIX
X#   define MEMMOVE
Xvoid *memmove __ARGS((void *, void *, int));
X# else
X#  define memmove(to, from, len) bcopy(from, to, len)
X# endif
X#endif
END_OF_FILE
if test 2448 -ne `wc -c <'vim/src/unix.h'`; then
    echo shar: \"'vim/src/unix.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/unix.h'
# end of 'vim/src/unix.h'
fi
if test -f 'vim/termcap' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/termcap'\"
else
echo shar: Extracting \"'vim/termcap'\" \(2694 characters\)
sed "s/^X//" >'vim/termcap' <<'END_OF_FILE'
X#
X#	Demonstration of a termcap file
X#
Xsx|ansi|any ansi terminal with pessimistic assumptions:\
X	:co#80:li#24:cl=50\E[;H\E[2J:bs:am:cm=\E[%i%d;%dH:\
X	:nd=\E[C:up=\E[A:ce=\E[K:ho=\E[H:pt:
XMu|sun|Sun Microsystems Workstation console:\
X	:am:bs:km:mi:ms:pt:li#34:co#80:cl=^L:cm=\E[%i%d;%dH:\
X	:ce=\E[K:cd=\E[J:\
X	:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:rs=\E[s:\
X	:md=\E[1m:mr=\E[7m:me=\E[m:\
X	:al=\E[L:dl=\E[M:im=:ei=:ic=\E[@:dc=\E[P:\
X	:AL=\E[%dL:DL=\E[%dM:IC=\E[%d@:DC=\E[%dP:\
X	:up=\E[A:nd=\E[C:ku=\E[A:kd=\E[B:kr=\E[C:kl=\E[D:\
X	:k1=\E[224z:k2=\E[225z:k3=\E[226z:k4=\E[227z:k5=\E[228z:\
X	:k6=\E[229z:k7=\E[230z:k8=\E[231z:k9=\E[232z:
XM-|sun-e|sun-nic|sune|Sun Microsystems Workstation without insert character:\
X	:ic@:im@:ei@:tc=sun:
XMu|sun-s|Sun Microsystems Workstation window with status line:\
X	:hs:ts=\E]l:fs=\E\\:ds=\E]l\E\\:tc=sun:
XMu|sun-e-s|sun-s-e|Sun Microsystems Workstation with status hacked for emacs:\
X	:hs:ts=\E]l:fs=\E\\:ds=\E]l\E\\:tc=sun-e:
XM0|sun-48|Sun 48-line window:\
X	:li#48:co#80:tc=sun:
XM1|sun-34|Sun 34-line window:\
X	:li#34:co#80:tc=sun:
XM2|sun-24|Sun 24-line window:\
X	:li#24:co#80:tc=sun:
XM3|sun-17|Sun 17-line window:\
X	:li#17:co#80:tc=sun:
Xv9|925a|tvi925a|TeleVideo Model 925:\
X	:al=\EE:am:bs:bt=\EI:bw:cd=\EY:ce=\ET:cl=^Z:cm=\E=%+ %+ :co#80:dc=\EW:\
X	:dl=\ER:do=^V:ei=:ic=\EQ:if=/usr/share/lib/tabset/std:im=:kb=^H:kd=^V:\
X	:kh=^^:kl=^H:kn#12:kr=^L:ku=^K:li#24:nd=^L:pt:se=\EG0:sg#1:so=\EG4:\
X	:ue=\EG0:ug#1:ul:up=^K:us=\EG8:is=\El\
X	:vb=\Eb\200\200\200\200\200\200\200\200\200\200\200\200\200\200\Ed:\
X	:ve=\E.4:vs=\E.2:
Xd0|vt100|vt100-am|vt100am|dec vt100:\
X	:do=^J:co#80:li#24:cl=50\E[;H\E[2J:sf=5\ED:\
X	:le=^H:bs:am:cm=5\E[%i%d;%dH:nd=2\E[C:up=2\E[A:\
X	:ce=3\E[K:cd=50\E[J:so=2\E[7m:se=2\E[m:us=2\E[4m:ue=2\E[m:\
X	:md=2\E[1m:mr=2\E[7m:mb=2\E[5m:me=2\E[m:is=\E[1;24r\E[24;1H:\
X	:rf=/usr/share/lib/tabset/vt100:\
X	:rs=\E>\E[?3l\E[?4l\E[?5l\E[?7h\E[?8h:ks=\E[?1h\E=:ke=\E[?1l\E>:\
X	:ku=\EOA:kd=\EOB:kr=\EOC:kl=\EOD:kb=^H:\
X	:ho=\E[H:k1=\EOP:k2=\EOQ:k3=\EOR:k4=\EOS:pt:sr=5\EM:vt#3:xn:\
X	:sc=\E7:rc=\E8:cs=\E[%i%d;%dr:
X# Amiga termcap by Bram Moolenaar
XAA|amiga|Amiga ANSI:\
X	:co#80:li#25:am:do=\E[B:ce=\E[K:cd=\E[J:\
X	:cl=\014:ku=\233A:kd=\233B:kl=\233D:kr=\233C:kb=^H:\
X	:#4=\233 A:%i=\233 @:%1=\233?~:\
X	:k1=\2330~:k2=\2331~:k3=\2332~:k4=\2333~:k5=\2334~:\
X	:k6=\2335~:k7=\2336~:k8=\2337~:k9=\2338~:k;=\2339~:\
X	:F1=\23310~:F2=\23311~:F3=\23312~:F4=\23313~:F5=\23314~:\
X	:F6=\23315~:F7=\23316~:F8=\23317~:F9=\23318~:FA=\23319~:\
X	:al=\E[L:AL=\E[%dL:dl=\E[M:DL=\E[%dM:le=^H:cm=\E[%i%d;%dH:\
X	:nd=\E[C:RI=\E[%dC:up=\E[A:\
X	:ce=\E[K:ho=\E[H:dc=\E[P:ic=\E[@:vi=\E[0 p:ve=\E[1 p:\
X	:so=\E[2m:se=\E[m:us=\E[4m:ue=\E[m:mr=\E[7m:mb=\E[7;2m:me=\E[m:
X#
X# END OF TERMCAP
X#
END_OF_FILE
if test 2694 -ne `wc -c <'vim/termcap'`; then
    echo shar: \"'vim/termcap'\" unpacked with wrong size!
fi
chmod +x 'vim/termcap'
# end of 'vim/termcap'
fi
if test -f 'vim/uganda.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/uganda.txt'\"
else
echo shar: Extracting \"'vim/uganda.txt'\" \(3078 characters\)
sed "s/^X//" >'vim/uganda.txt' <<'END_OF_FILE'
XVim is public domain. If you are happy with Vim and want to express that,
Xdon't send me money. I don't need it. But I know a place where they do need
Xyour money. Please read on.
X
XSummer 1993 I spent one month in Uganda with a Dutch team. What I experienced
Xthere was very impressive. Together with local people we built a nursery
Xschool in Kibale. In only three weeks from nothing to a roofed building!
X
XKibale is a small town in the south of Uganda. It is an area that is suffering
Xfrom AIDS very badly. About 30% of the adults are infected. Because parents
Xdie, there are many orphans. They need a lot of help. The Kibale children
Xcentre is working hard to provide the needy with food, medical care and
Xeducation. Food and medical care to keep them healthy now, and education so
Xthat they can take care of themselves in the future. This is the best charity
Xprogram I have ever encountered.
X
XThe key to solving the problems in this area is education. This has been
Xneglected in the past years with president Idi Amin and the following civil
Xwars. The people have to learn how to take care of themselves and how to avoid
Xinfections. There is also help for people who are ill, but the primary goal
Xis to prevent people from getting ill.
X
XI was impressed by the progress that is being made there. The work is very
Xwell organized. Every dollar is spent on something useful. Our team brought
Xabout $2000. For that money we were able to built most of a two classroom
Xnursery school. They have further plans to build a primary school and houses
Xfor the teachers. They also need money for books and other teaching materials.
X
XIf you want to support the Kibale children centre, please send a contribution.
X
XHow do you know that the money will be spent right? First of all you have my
Xpersonal guarantee as the author of Vim. Further the project is co-sponsored
Xand inspected by World Vision and International Child Care Fund. I will visit
Xthe project a second time in January 1994. Friends of mine will go there in
Xthe summer of 1994. So I keep informed about what is happening there.
X
XIf you have any further questions, send me e-mail: mool@oce.nl.
X
XThe director of the project is:
XSekaran Vellasamy
Xp.o. box 1658
XMasaka, Uganda, East Africa
X
XTransfering money from Holland:
XUse one of my accounts:
XRabobank Venlo, nr. 3765.05.117
XPostbank, nr. 1644503
X
XTransfering money from Europe:
XTo avoid banking costs the best thing is to send me a Eurocheque. But any
Xother method should work.
X
XTransfering money from USA:
XSend me a check that can be cashed in Holland. Any "standard" banking check
Xshould be OK. Please consider adding $10 for banking costs.
X
XMy address: Bram Moolenaar   
X            Clematisstraat 30
X            5925 BE  Venlo   
X            The Netherlands. 
X
XOr you can transfer the money directly to the director of the project.
XI don't know how well this works and what the costs are.
X
XGold Trust Bank LTD - Kampala
Xa/c no. 36059709
XCitibank, N.A.
XGlobal Clearance Services
X111 Wall Street 16th floor
XNew York 10043
XU.S.A.
XBeneficiary Mr. Sekaran Vellasamy a/c no. 2100
END_OF_FILE
if test 3078 -ne `wc -c <'vim/uganda.txt'`; then
    echo shar: \"'vim/uganda.txt'\" unpacked with wrong size!
fi
chmod +x 'vim/uganda.txt'
# end of 'vim/uganda.txt'
fi
echo shar: End of archive 2 \(of 25\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
