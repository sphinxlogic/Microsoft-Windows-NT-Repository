Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i063:  vim - Vi IMitation editor, v2.0, Part13/25
Message-ID: <1993Dec21.035111.28455@sparky.sterling.com>
X-Md4-Signature: b81c881a9a1e55760b8c5c4a451bbc63
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:51:11 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 63
Archive-name: vim/part13
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 25)."
# Contents:  vim/src/search.c vim/tutor/tutor
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/src/search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/search.c'\"
else
echo shar: Extracting \"'vim/src/search.c'\" \(24021 characters\)
sed "s/^X//" >'vim/src/search.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony
X *							G. R. (Fred) Walter     watmath!watcgl!grwalter
X */
X/*
X * search.c: code for normal mode searching commands
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X#include "ops.h"		/* for mincl */
X
X/* modified Henry Spencer's regular expression routines */
X#include "regexp.h"
X
Xstatic int inmacro __ARGS((char *, char *));
Xstatic int cls __ARGS((void));
X
X/*
X * This file contains various searching-related routines. These fall into
X * three groups:
X * 1. string searches (for /, ?, n, and N)
X * 2. character searches within a single line (for f, F, t, T, etc)
X * 3. "other" kinds of searches like the '%' command, and 'word' searches.
X */
X
X/*
X * String searches
X *
X * The string search functions are divided into two levels:
X * lowest:	searchit(); called by dosearch() and docmdline().
X * Highest: dosearch(); changes Curpos, called by normal().
X *
X * The last search pattern is remembered for repeating the same search.
X * This pattern is shared between the :g, :s, ? and / commands.
X * This is in myregcomp().
X *
X * The actual string matching is done using a heavily modified version of
X * Henry Spencer's regular expression library.
X */
X
Xstatic char 	*search_pattern = NULL;  /* previous search pattern */
Xstatic int		want_start; 			 /* looking for start of line? */
X
X/*
X * translate search pattern for regcomp()
X */
X	regexp *
Xmyregcomp(pat)
X	char *pat;
X{
X	regexp *retval;
X
X	if (pat == NULL || *pat == NUL)     /* use previous search pattern */
X	{
X		if (search_pattern == NULL)
X		{
X			emsg(e_noprevre);
X			return (regexp *) NULL;
X		}
X		pat = search_pattern;
X	}
X	else
X	{
X		if (search_pattern != NULL)
X			free(search_pattern);
X		search_pattern = strsave(pat);
X		reg_magic = p_magic;		/* Magic sticks with the r.e. */
X	}
X	want_start = (*pat == '^');		/* looking for start of line? */
X	reg_ic = p_ic;				/* tell the regexec routine how to search */
X	retval = regcomp(pat);
X	return retval;
X}
X
X/*
X * lowest level search function.
X * Search for 'count'th occurrence of 'str' in direction 'dir'.
X * Start at position 'pos' and return the found position in 'pos'.
X * Return 1 for success, 0 for failure.
X */
X	int
Xsearchit(pos, dir, str, count, end)
X	FPOS	*pos;
X	int 	dir;
X	char	*str;
X	long	count;
X	int		end;
X{
X	int 			found;
X	linenr_t		lnum;
X	linenr_t		startlnum;
X	regexp		   *prog;
X	register char  *s;
X	char		   *ptr;
X	register int	i;
X	register char  *match, *matchend;
X	int 			loop;
X
X	if ((prog = myregcomp(str)) == NULL)
X	{
X		emsg(e_invstring);
X		return 0;
X	}
X/*
X * find the string
X */
X	found = 1;
X	while (count-- && found)    /* stop after count matches, or no more matches */
X	{
X		startlnum = pos->lnum;	/* remember start of search for detecting no match */
X		found = 0;				/* default: not found */
X
X		i = pos->col + dir; 	/* search starts one postition away */
X		lnum = pos->lnum;
X
X		if (dir == BACKWARD)
X		{
X			if (i < 0)
X				--lnum;
X		}
X
X		for (loop = 0; loop != 2; ++loop)   /* do this twice if 'wrapscan' is set */
X		{
X			for ( ; lnum > 0 && lnum <= line_count; lnum += dir, i = -1)
X			{
X				s = ptr = nr2ptr(lnum);
X				if (dir == FORWARD && i > 0)    /* first line for forward search */
X				{
X					if (want_start || strlen(s) <= (size_t)i)   /* match not possible */
X						continue;
X					s += i;
X				}
X
X				if (regexec(prog, s, dir == BACKWARD || i <= 0))
X				{							/* match somewhere on line */
X					match = prog->startp[0];
X					matchend = prog->endp[0];
X					if (dir == BACKWARD && !want_start)
X					{
X						/*
X						 * Now, if there are multiple matches on this line, we have to
X						 * get the last one. Or the last one before the cursor, if we're
X						 * on that line.
X						 */
X						while (regexec(prog, prog->startp[0] + 1, (int)FALSE))
X						{
X							if ((i >= 0) && ((prog->startp[0] - s) > i))
X								break;
X							match = prog->startp[0];
X							matchend = prog->endp[0];
X						}
X
X						if ((i >= 0) && ((match - s) > i))
X							continue;
X					}
X
X					pos->lnum = lnum;
X					if (end)
X						pos->col = (int) (matchend - ptr - 1);
X					else
X						pos->col = (int) (match - ptr);
X					found = 1;
X					break;
X				}
X				/* breakcheck is slow, do it only once in 16 lines */
X				if ((lnum & 15) == 0)
X					breakcheck();       /* stop if ctrl-C typed */
X				if (got_int)
X					break;
X
X				if (loop && lnum == startlnum)  /* if second loop stop where started */
X					break;
X			}
X	/* stop the search if wrapscan isn't set, after an interrupt and after a match */
X			if (!p_ws || got_int || found)
X				break;
X
X			if (dir == BACKWARD)    /* start second loop at the other end */
X				lnum = line_count;
X			else
X				lnum = 1;
X		}
X		if (got_int)
X			break;
X	}
X
X	free((char *) prog);
X
X	if (!found)             /* did not find it */
X	{
X		if (got_int)
X				emsg(e_interr);
X		else
X				emsg(e_patnotf);
X		return 0;
X	}
X
X	return 1;
X}
X
X/*
X * Highest level string search function.
X * Search for the 'count'th occurence of string 'str' in direction 'dirc'
X *					If 'dirc' is 0: use previous dir.
X * If 'str' is 0 or 'str' is empty: use previous string.
X *			  If 'reverse' is TRUE: go in reverse of previous dir.
X *				 If 'echo' is TRUE: echo the search command
X */
X	int
Xdosearch(dirc, str, reverse, count, echo)
X	int				dirc;
X	char		   *str;
X	int				reverse;
X	long			count;
X	int				echo;
X{
X	FPOS			pos;		/* position of the last match */
X	char			*searchstr;
X	static int		lastsdir = '/';	/* previous search direction */
X	static int		lastoffline;/* previous/current search has line offset */
X	static int		lastend;	/* previous/current search set cursor at end */
X	static long 	lastoff;	/* previous/current line or char offset */
X	static int		nosetpm;    /* do not call setpcmark() */
X	register char	*p;
X	register long	c;
X	char			*dircp = NULL;
X
X	if (dirc == 0)
X		dirc = lastsdir;
X	else
X		lastsdir = dirc;
X	if (reverse)
X	{
X		if (dirc == '/')
X			dirc = '?';
X		else
X			dirc = '/';
X	}
X	searchstr = str;
X									/* use previous string */
X	if (str == NULL || *str == NUL || *str == dirc)
X	{
X		if (search_pattern == NULL)
X		{
X			emsg(e_noprevre);
X			return 0;
X		}
X		searchstr = "";				/* will use search_pattern in myregcomp() */
X	}
X	if (str != NULL && *str != NUL)	/* look for (new) offset */
X	{
X		/* If there is a matching '/' or '?', toss it */
X		for (p = str; *p; ++p)
X		{
X			if (*p == dirc)
X			{
X				dircp = p;		/* remember where we put the NUL */
X				*p++ = NUL;
X				break;
X			}
X			if (*p == '\\' && p[1] != NUL)
X				++p;	/* skip next character */
X		}
X
X		lastoffline = FALSE;
X		lastend = FALSE;
X		nosetpm = FALSE;
X		lastoff = 0;
X		switch (*p)
X		{
X			case 'n': 					/* do not call setpcmark() */
X						nosetpm = TRUE;
X						++p;
X						break;
X			case '+':
X			case '-':                   /* got a line offset */
X						lastoffline = TRUE;
X						break;
X			case 'e':                   /* position cursor at end */
X						lastend = TRUE;
X			case 's':                   /* got a character offset from start */
X						++p;
X		}
X		if (*p == '+' || *p == '-')     /* got an offset */
X		{
X			if (isdigit(*(p + 1)))
X				lastoff = atol(p);		/* '+nr' or '-nr' */
X			else if (*p == '-')			/* single '-' */
X				lastoff = -1;
X			else						/* single '+' */
X				lastoff = 1;
X			++p;
X			while (isdigit(*p))			/* skip number */
X				++p;
X		}
X		searchcmdlen = p - str;			/* compute lenght of search command
X														for get_address() */
X	}
X
X	if (echo)
X	{
X		start_msg();
X		outchar(dirc);
X		outtrans(*searchstr == NUL ? search_pattern : searchstr, -1);
X		if (lastoffline || lastend || lastoff || nosetpm)
X		{
X			outchar(dirc);
X			if (nosetpm)
X				outchar('n');
X			else if (lastend)
X				outchar('e');
X			else if (!lastoffline)
X				outchar('s');
X			if (lastoff < 0)
X			{
X				outchar('-');
X				outnum((long)-lastoff);
X			}
X			else if (lastoff > 0 || lastoffline)
X			{
X				outchar('+');
X				outnum((long)lastoff);
X			}
X		}
X		check_msg();
X
X		gotocmdline(FALSE, NUL);
X		flushbuf();
X	}
X
X	pos = Curpos;
X
X	c = searchit(&pos, dirc == '/' ? FORWARD : BACKWARD, searchstr, count, lastend);
X	if (dircp)
X		*dircp = dirc;		/* put second '/' or '?' back for normal() */
X	if (!c)
X		return 0;
X
X	if (!lastoffline)           /* add the character offset to the column */
X	{
X		if (lastoff > 0)        /* offset to the right, check for end of line */
X		{
X			p = pos2ptr(&pos) + 1;
X			c = lastoff;
X			while (c-- && *p++ != NUL)
X				++pos.col;
X		}
X		else					/* offset to the left, check for start of line */
X		{
X			if ((c = pos.col + lastoff) < 0)
X				c = 0;
X			pos.col = c;
X		}
X	}
X
X	if (!nosetpm)
X		setpcmark();
X	Curpos = pos;
X	set_want_col = TRUE;
X
X	if (!lastoffline)
X		return 1;
X
X/*
X * add the offset to the line number.
X */
X	c = Curpos.lnum + lastoff;
X	if (c < 1)
X		Curpos.lnum = 1;
X	else if (c > line_count)
X		Curpos.lnum = line_count;
X	else
X		Curpos.lnum = c;
X	Curpos.col = 0;
X
X	return 2;
X}
X
X
X/*
X * Character Searches
X */
X
X/*
X * searchc(c, dir, type, count)
X *
X * Search for character 'c', in direction 'dir'. If 'type' is 0, move to the
X * position of the character, otherwise move to just before the char.
X * Repeat this 'count' times.
X */
X	int
Xsearchc(c, dir, type, count)
X	int 			c;
X	register int	dir;
X	int 			type;
X	long			count;
X{
X	static char 	lastc = NUL;	/* last character searched for */
X	static int		lastcdir;		/* last direction of character search */
X	static int		lastctype;		/* last type of search ("find" or "to") */
X	register int	col;
X	char			*p;
X	int 			len;
X
X	if (c != NUL)       /* normal search: remember args for repeat */
X	{
X		lastc = c;
X		lastcdir = dir;
X		lastctype = type;
X	}
X	else				/* repeat previous search */
X	{
X		if (lastc == NUL)
X			return FALSE;
X		if (dir)        /* repeat in opposite direction */
X			dir = -lastcdir;
X		else
X			dir = lastcdir;
X	}
X
X	p = nr2ptr(Curpos.lnum);
X	col = Curpos.col;
X	len = strlen(p);
X
X	/*
X	 * On 'to' searches, skip one to start with so we can repeat searches in
X	 * the same direction and have it work right.
X	 * REMOVED to get vi compatibility
X	 * if (lastctype)
X	 *	col += dir;
X	 */
X
X	while (count--)
X	{
X			for (;;)
X			{
X				if ((col += dir) < 0 || col >= len)
X					return FALSE;
X				if (p[col] == lastc)
X						break;
X			}
X	}
X	if (lastctype)
X		col -= dir;
X	Curpos.col = col;
X	return TRUE;
X}
X
X/*
X * "Other" Searches
X */
X
X/*
X * showmatch - move the cursor to the matching paren or brace
X *
X * Improvement over vi: Braces inside quotes are ignored.
X */
X	FPOS		   *
Xshowmatch()
X{
X	static FPOS		pos;			/* current search position */
X	char			initc;			/* brace under or after the cursor */
X	char			findc;			/* matching brace */
X	char			c;
X	int 			count = 0;		/* cumulative number of braces */
X	int 			idx;
X	static char 	table[6] = {'(', ')', '[', ']', '{', '}'};
X	int 			inquote = 0;	/* non-zero when inside quotes */
X	register char	*linep;			/* pointer to current line */
X	register char	*ptr;
X	int				do_quotes;		/* check for quotes in current line */
X
X	pos = Curpos;
X
X	/*
X	 * find the brace under or after the cursor
X	 */
X	linep = nr2ptr(pos.lnum); 
X	for (;;)
X	{
X		initc = linep[pos.col];
X		if (initc == NUL)
X			return (FPOS *) NULL;
X
X		for (idx = 0; idx < 6; ++idx)
X			if (table[idx] == initc)
X				break;
X		if (idx != 6)
X			break;
X		++pos.col;
X	}
X
X	findc = table[idx ^ 1];		/* get matching brace */
X	idx &= 1;
X
X	do_quotes = -1;
X	while (!got_int)
X	{
X		/*
X		 * Go to the next position, forward or backward. We could use
X		 * inc() and dec() here, but that is much slower
X		 */
X		if (idx)              			/* backward search */
X		{
X			if (pos.col == 0)   		/* at start of line, go to previous one */
X			{
X				if (pos.lnum == 1)      /* start of file */
X					break;
X				--pos.lnum;
X				linep = nr2ptr(pos.lnum);
X				pos.col = strlen(linep);	/* put pos.col on trailing NUL */
X				do_quotes = -1;
X			}
X			else
X				--pos.col;
X		}
X		else							/* forward search */
X		{
X			if (linep[pos.col] == NUL)  /* at end of line, go to next one */
X			{
X				if (pos.lnum == line_count) /* end of file */
X					break;
X				++pos.lnum;
X				linep = nr2ptr(pos.lnum);
X				pos.col = 0;
X				do_quotes = -1;
X			}
X			else
X				++pos.col;
X		}
X
X		if (do_quotes == -1)		/* count number of quotes in this line */
X		{
X				/* we only do a breakcheck() once for every 16 lines */
X			if ((pos.lnum & 15) == 0)
X				breakcheck();
X
X			/*
X			 * count the number of quotes in the line, skipping \" and '"'
X			 */
X			for (ptr = linep; *ptr; ++ptr)
X				if (*ptr == '"' && (ptr == linep || ptr[-1] != '\\') &&
X							(ptr == linep || ptr[-1] != '\'' || ptr[1] != '\''))
X					++do_quotes;
X			do_quotes &= 1;			/* result is 1 with even number of quotes */
X
X			/*
X			 * If we find an uneven count, check current line and previous
X			 * one for a '\' at the end.
X			 */
X			if (!do_quotes)
X			{
X				inquote = FALSE;
X				if (ptr[-1] == '\\')
X				{
X					do_quotes = 1;
X					if (idx)					/* backward search */
X						inquote = TRUE;
X				}
X				if (pos.lnum > 1)
X				{
X					ptr = nr2ptr(pos.lnum - 1);
X					if (*ptr && *(ptr + strlen(ptr) - 1) == '\\')
X					{
X						do_quotes = 1;
X						if (!idx)				/* forward search */
X							inquote = TRUE;
X					}
X				}
X			}
X		}
X
X		/*
X		 * Things inside quotes are ignored by setting 'inquote'.
X		 * If we find a quote without a preceding '\' invert 'inquote'.
X		 * At the end of a line not ending in '\' we reset 'inquote'.
X		 *
X		 * In lines with an uneven number of quotes (without preceding '\')
X		 * we do not know which part to ignore. Therefore we only set
X		 * inquote if the number of quotes in a line is even,
X		 * unless this line or the previous one ends in a '\'.
X		 * Complicated, isn't it?
X		 */
X		switch (c = linep[pos.col])
X		{
X		case NUL:
X			inquote = FALSE;
X			break;
X
X		case '"':
X				/* a quote that is preceded with a backslash is ignored */
X			if (do_quotes && (pos.col == 0 || linep[pos.col - 1] != '\\'))
X				inquote = !inquote;
X			break;
X
X		/*
X		 * Skip things in single quotes: 'x' or '\x'.
X		 * Be careful for single single quotes, eg jon's.
X		 * Things like '\233' or '\x3f' are not skipped, there is never a
X		 * brace in them.
X		 */
X		case '\'':
X			if (idx)						/* backward search */
X			{
X				if (pos.col > 1)
X				{
X					if (linep[pos.col - 2] == '\'')
X						pos.col -= 2;
X					else if (linep[pos.col - 2] == '\\' && pos.col > 2 && linep[pos.col - 3] == '\'')
X						pos.col -= 3;
X				}
X			}
X			else if (linep[pos.col + 1])	/* forward search */
X			{
X				if (linep[pos.col + 1] == '\\' && linep[pos.col + 2] && linep[pos.col + 3] == '\'')
X					pos.col += 3;
X				else if (linep[pos.col + 2] == '\'')
X					pos.col += 2;
X			}
X			break;
X
X		default:
X			if (!inquote)      /* only check for match outside of quotes */
X			{
X				if (c == initc)
X					count++;
X				else if (c == findc)
X				{
X					if (count == 0)
X						return &pos;
X					count--;
X				}
X			}
X		}
X	}
X	return (FPOS *) NULL;       /* never found it */
X}
X
X/*
X * findfunc(dir, what) - Find the next line starting with 'what' in direction 'dir'
X *
X * Return TRUE if a line was found.
X */
X	int
Xfindfunc(dir, what, count)
X	int 		dir;
X	int			what;
X	long		count;
X{
X	linenr_t	curr;
X
X	curr = Curpos.lnum;
X
X	for (;;)
X	{
X		if (dir == FORWARD)
X		{
X				if (curr++ == line_count)
X						break;
X		}
X		else
X		{
X				if (curr-- == 1)
X						break;
X		}
X
X		if (*nr2ptr(curr) == what)
X		{
X			if (--count > 0)
X				continue;
X			setpcmark();
X			Curpos.lnum = curr;
X			Curpos.col = 0;
X			return TRUE;
X		}
X	}
X
X	return FALSE;
X}
X
X/*
X * findsent(dir, count) - Find the start of the next sentence in direction 'dir'
X * Sentences are supposed to end in ".", "!" or "?" followed by white space or
X * a line break. Also stop at an empty line.
X * Return TRUE if the next sentence was found.
X */
X	int
Xfindsent(dir, count)
X		int 	dir;
X		long	count;
X{
X	FPOS			pos, tpos;
X	register int	c;
X	int 			(*func) __PARMS((FPOS *));
X	int 			startlnum;
X	int				noskip = FALSE;			/* do not skip blanks */
X
X	pos = Curpos;
X	if (dir == FORWARD)
X		func = incl;
X	else
X		func = decl;
X
X	while (count--)
X	{
X		/* if on an empty line, skip upto a non-empty line */
X		if (gchar(&pos) == NUL)
X		{
X			do
X				if ((*func)(&pos) == -1)
X					break;
X			while (gchar(&pos) == NUL);
X			if (dir == FORWARD)
X				goto found;
X		}
X		/* if on the start of a paragraph or a section and searching
X		 * forward, go to the next line */
X		else if (dir == FORWARD && pos.col == 0 && startPS(pos.lnum, NUL))
X		{
X			if (pos.lnum == line_count)
X				return FALSE;
X			++pos.lnum;
X			goto found;
X		}
X		else if (dir == BACKWARD)
X			decl(&pos);
X
X		/* go back to the previous non-blank char */
X		while ((c = gchar(&pos)) == ' ' || c == '\t' ||
X					(dir == BACKWARD && strchr(".!?)]\"'", c) != NULL && c != NUL))
X			if (decl(&pos) == -1)
X				break;
X
X		/* remember the line where the search started */
X		startlnum = pos.lnum;
X
X		for (;;)                /* find end of sentence */
X		{
X			if ((c = gchar(&pos)) == NUL ||
X							(pos.col == 0 && startPS(pos.lnum, NUL)))
X			{
X				if (dir == BACKWARD && pos.lnum != startlnum)
X					++pos.lnum;
X				break;
X			}
X			if (c == '.' || c == '!' || c == '?')
X			{
X				tpos = pos;
X				do
X					if ((c = inc(&tpos)) == -1)
X						break;
X				while (strchr(")}\"'", c = gchar(&tpos)) != NULL && c != NUL);
X				if (c == -1  || c == ' ' || c == '\t' || c == NUL)
X				{
X					pos = tpos;
X					if (gchar(&pos) == NUL) /* skip NUL at EOL */
X						inc(&pos);
X					break;
X				}
X			}
X			if ((*func)(&pos) == -1)
X			{
X				if (count)
X					return FALSE;
X				noskip = TRUE;
X				break;
X			}
X		}
Xfound:
X			/* skip white space */
X		while (!noskip && ((c = gchar(&pos)) == ' ' || c == '\t'))
X			if (incl(&pos) == -1)
X				break;
X	}
X
X	Curpos = pos;
X	setpcmark();
X	return TRUE;
X}
X
X/*
X * findpar(dir, count, what) - Find the next paragraph in direction 'dir'
X * Paragraphs are currently supposed to be separated by empty lines.
X * Return TRUE if the next paragraph was found.
X * If 'what' is '{' or '}' we go to the next section.
X */
X	int
Xfindpar(dir, count, what)
X	register int	dir;
X	long			count;
X	int 			what;
X{
X	register linenr_t	curr;
X	int					did_skip;		/* TRUE after separating lines have
X												been skipped */
X	int					first;			/* TRUE on first line */
X
X	curr = Curpos.lnum;
X
X	while (count--)
X	{
X		did_skip = FALSE;
X		for (first = TRUE; ; first = FALSE)
X		{
X				if (*nr2ptr(curr) != NUL)
X					did_skip = TRUE;
X
X				if (!first && did_skip && startPS(curr, what))
X					break;
X
X				if ((curr += dir) < 1 || curr > line_count)
X				{
X						if (count)
X								return FALSE;
X						curr -= dir;
X						break;
X				}
X		}
X	}
X	setpcmark();
X	Curpos.lnum = curr;
X	if (curr == line_count)
X	{
X		if ((Curpos.col = strlen(nr2ptr(curr))) != 0)
X			--Curpos.col;
X		mincl = TRUE;
X	}
X	else
X		Curpos.col = 0;
X	return TRUE;
X}
X
X/*
X * check if the string 's' is a nroff macro that is in option 'opt'
X */
X	static int
Xinmacro(opt, s)
X		char *opt;
X		register char *s;
X{
X		register char *macro;
X
X		for (macro = opt; macro[0]; ++macro)
X		{
X				if (macro[0] == s[0] && (((s[1] == NUL || s[1] == ' ')
X						&& (macro[1] == NUL || macro[1] == ' ')) || macro[1] == s[1]))
X						break;
X				++macro;
X				if (macro[0] == NUL)
X						break;
X		}
X		return (macro[0] != NUL);
X}
X
X/*
X * startPS: return TRUE if line 'lnum' is the start of a section or paragraph.
X * If 'para' is '{' or '}' only check for sections.
X */
X	int
XstartPS(lnum, para)
X	linenr_t	lnum;
X	int 		para;
X{
X	register char *s;
X
X	s = nr2ptr(lnum);
X	if (*s == para || *s == '\f')
X		return TRUE;
X	if (*s == '.' && (inmacro(p_sections, s + 1) || (!para && inmacro(p_para, s + 1))))
X		return TRUE;
X	return FALSE;
X}
X
X/*
X * The following routines do the word searches performed by the 'w', 'W',
X * 'b', 'B', 'e', and 'E' commands.
X */
X
X/*
X * To perform these searches, characters are placed into one of three
X * classes, and transitions between classes determine word boundaries.
X *
X * The classes are:
X *
X * 0 - white space
X * 1 - letters, digits and underscore
X * 2 - everything else
X */
X
Xstatic int		stype;			/* type of the word motion being performed */
X
X/*
X * cls() - returns the class of character at Curpos
X *
X * The 'type' of the current search modifies the classes of characters if a 'W',
X * 'B', or 'E' motion is being done. In this case, chars. from class 2 are
X * reported as class 1 since only white space boundaries are of interest.
X */
X	static int
Xcls()
X{
X	register int c;
X
X	c = gcharCurpos();
X	if (c == ' ' || c == '\t' || c == NUL)
X		return 0;
X
X	if (isidchar(c))
X		return 1;
X
X	/*
X	 * If stype is non-zero, report these as class 1.
X	 */
X	return (stype == 0) ? 2 : 1;
X}
X
X
X/*
X * fwd_word(count, type, eol) - move forward one word
X *
X * Returns TRUE if the cursor was already at the end of the file.
X * If eol is TRUE, last word stops at end of line (for operators).
X */
X	int
Xfwd_word(count, type, eol)
X	long		count;
X	int 		type;
X	int			eol;
X{
X	int 		sclass; 	/* starting class */
X	int			i;
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X
X		/*
X		 * We always move at least one character.
X		 */
X		i = incCurpos();
X		if (i == -1)
X			return TRUE;
X		if (i == 1 && eol && count == 0)	/* started at last char in line */
X			return FALSE;
X
X		if (sclass != 0)
X			while (cls() == sclass)
X			{
X				i = incCurpos();
X				if (i == -1 || (i == 1 && eol && count == 0))
X					return FALSE;
X			}
X
X		/*
X		 * go to next non-white
X		 */
X		while (cls() == 0)
X		{
X			/*
X			 * We'll stop if we land on a blank line
X			 */
X			if (Curpos.col == 0 && *nr2ptr(Curpos.lnum) == NUL)
X				break;
X
X			i = incCurpos();
X			if (i == -1 || (i == 1 && eol && count == 0))
X				return FALSE;
X		}
X	}
X	return FALSE;
X}
X
X/*
X * bck_word(count, type) - move backward 'count' words
X *
X * Returns TRUE if top of the file was reached.
X */
X	int
Xbck_word(count, type)
X	long		count;
X	int 		type;
X{
X	int 		sclass; 	/* starting class */
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X
X		if (decCurpos() == -1)		/* started at start of file */
X			return TRUE;
X
X		if (cls() != sclass || sclass == 0)
X		{
X			/*
X			 * We were at the start of a word. Go back to the end of the prior
X			 * word.
X			 */
X			while (cls() == 0)  /* skip any white space */
X			{
X				/*
X				 * We'll stop if we land on a blank line
X				 */
X				if (Curpos.col == 0 && *nr2ptr(Curpos.lnum) == NUL)
X					goto finished;
X
X				if (decCurpos() == -1)		/* hit start of file, stop here */
X					return FALSE;
X			}
X			sclass = cls();
X		}
X
X		/*
X		 * Move backward to start of this word.
X		 */
X		if (skip_chars(sclass, BACKWARD))
X				return FALSE;
X
X		incCurpos();                    /* overshot - forward one */
Xfinished:
X		;
X	}
X	return FALSE;
X}
X
X/*
X * end_word(count, type, stop) - move to the end of the word
X *
X * There is an apparent bug in the 'e' motion of the real vi. At least on the
X * System V Release 3 version for the 80386. Unlike 'b' and 'w', the 'e'
X * motion crosses blank lines. When the real vi crosses a blank line in an
X * 'e' motion, the cursor is placed on the FIRST character of the next
X * non-blank line. The 'E' command, however, works correctly. Since this
X * appears to be a bug, I have not duplicated it here.
X *
X * Returns TRUE if end of the file was reached.
X *
X * If stop is TRUE and we are already on the end of a word, move one less.
X */
X	int
Xend_word(count, type, stop)
X	long		count;
X	int 		type;
X	int			stop;
X{
X	int 		sclass; 	/* starting class */
X
X	stype = type;
X	while (--count >= 0)
X	{
X		sclass = cls();
X		if (incCurpos() == -1)
X			return TRUE;
X
X		/*
X		 * If we're in the middle of a word, we just have to move to the end of it.
X		 */
X		if (cls() == sclass && sclass != 0)
X		{
X			/*
X			 * Move forward to end of the current word
X			 */
X			if (skip_chars(sclass, FORWARD))
X					return TRUE;
X		}
X		else if (!stop || sclass == 0)
X		{
X			/*
X			 * We were at the end of a word. Go to the end of the next word.
X			 */
X
X			if (skip_chars(0, FORWARD))     /* skip any white space */
X				return TRUE;
X
X			/*
X			 * Move forward to the end of this word.
X			 */
X			if (skip_chars(cls(), FORWARD))
X				return TRUE;
X		}
X		decCurpos();                    /* overshot - backward one */
X		stop = FALSE;					/* we move only one word less */
X	}
X	return FALSE;
X}
X
X	int
Xskip_chars(class, dir)
X	int class;
X	int dir;
X{
X		while (cls() == class)
X			if ((dir == FORWARD ? incCurpos() : decCurpos()) == -1)
X				return TRUE;
X		return FALSE;
X}
END_OF_FILE
if test 24021 -ne `wc -c <'vim/src/search.c'`; then
    echo shar: \"'vim/src/search.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/search.c'
# end of 'vim/src/search.c'
fi
if test -f 'vim/tutor/tutor' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/tutor/tutor'\"
else
echo shar: Extracting \"'vim/tutor/tutor'\" \(28799 characters\)
sed "s/^X//" >'vim/tutor/tutor' <<'END_OF_FILE'
X*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
X*    W e l c o m e   t o   V I   T u t o r    -    V e r s i o n   1 . 2      *
X*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
X                             **************
X                             * Lesson 1.0 *
X                             **************
X
X     Vim is a very powerful editor that has many commands, too many to 
X     explain in a tutor such as this.  This tutor is designed to describe
X     enough of the commands that you will be able to easily use Vim as
X     an all-purpose editor. 
X
X     The approximate time required to complete the tutor is 25-30 minutes, 
X     depending upon how much time is spent with experimentation.
X
X     It is important to remember that this tutor is set up to teach by
X     use.  That means that the student needs to execute the commands to 
X     learn them properly.  
X
X     Now, make sure that your Shift-Lock key is NOT depressed and press
X     the   j   key enough times to move the cursor so that Lesson 1.1 
X     completely fills the screen.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 1.1 *
X                             **************
X                 =====>>>>> MOVING THE CURSOR <<<<<=====
X
X   ** To move the cursor, press the h,j,k,l keys as indicated. ** 
X                                   ^
X                                   k
X                             < h       l >
X                                   j
X                                   v
X  1. Move the cursor around the screen until you are comfortable.
X
X  2. Hold down the down key (j) until it repeats.
X---> Now you know how to move to the next lesson.
X
X  3. Using the down key, move to Lesson 1.2.
X
XNote: If you are ever unsure about something you typed, press <ESC> to place
X      you in Command Mode.  Then retype the command you wanted.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 1.2 *
X                             **************
X              =====>>>>> ENTERING AND EXITING VIM <<<<<=====
X
X  !! NOTE: Before executing any of the steps below, read this entire lesson!!
X
X  1. Press the <ESC> key (to make sure you are in Command Mode).
X
X  2. Type      :q! <RETURN>.
X
X---> This exits the editor WITHOUT saving any changes you have made.
X     If you want to save the changes and exit type        :wq  <RETURN>
X
X  3. When you see the shell prompt (%) type:    vim tutor <RETURN>.
X
X---> 'vim' means enter the vim editor, 'tutor' is the file you wish to edit.
X
X  4. If you have these steps memorized and are confident, execute steps
X     1 through 3 to exit and re-enter the editor.  Then cursor down to 
X     Lesson 1.3.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 1.3 *
X                             **************
X              =====>>>>> TEXT EDITING - DELETION <<<<<=====
X
X** While in Command Mode press  x  to delete the character under the cursor. **
X
X  1. Move the cursor to the line below marked --->.
X
X  2. To fix the errors, move the cursor until it is on top of the
X     character to be deleted.
X
X  3. Press the  x  key to delete the unwanted character.
X
X  4. Repeat steps 2 through 4 until the sentence is correct.
X
X---> The ccow jumpedd ovverr thhe mooon.
X
X  5. Now that the line is correct, go on to Lesson 1.4.
X
XNOTE: As you go through this tutor, do not try to memorize, learn by usage.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 1.4 *
X                             **************
X             =====>>>>> TEXT EDITING - INSERTION <<<<<=====
X
X         ** While in Command Mode press  i  to insert text. **
X
X  1. Move the cursor to the first line below marked --->.
X
X  2. To make the first line the same as the second, move the cursor on top 
X     of the first character AFTER where the text is to be inserted.
X
X  3. Press  i  and type in the necessary additions.
X
X  4. As each error is fixed press <ESC> to return to Command Mode.
X     Repeat steps 2 through 4 to correct the sentence.
X
X---> There is text misng this .
X---> There is some text missing from this line.
X
X  5. When you are comfortable inserting text move to the summary below.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 1 SUMMARY *
X                          ********************
X
X  1. The cursor is moved using either the arrow keys or the h,j,k,l keys.
X         h (left)       j (down)       k (up)       l (right)
X
X  2. To enter Vim (from the % prompt) type:      % vim FILENAME <RETURN>
X
X  3. To exit Vim type:     <ESC>   :q!   <RETURN>
X             OR type:      <ESC>   :wq   <RETURN>  to save the changes.
X
X  4. To delete a character under the cursor in Command Mode type:  x
X
X  5. To insert text at the cursor while in Command Mode type:
X         i     type in text     <ESC>
X
XNOTE: Pressing <ESC> will place you in Command Mode or will cancel
X      an unwanted and partially completed command.
X
XNow continue with Lesson 2.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 2.1 *
X                             **************
X                =====>>>>> DELETION COMMANDS <<<<<=====
X
X            ** Type  dw  to delete to the end of a word. **
X
X  1. Press  <ESC>  to make sure you are in Command Mode.
X
X  2. Move the cursor to the line below marked --->.
X
X  3. Move the cursor to the beginning of a word that needs to be deleted.
X  
X  4. Type   dw   to make the word disappear.
X
X  NOTE: The letters dw will appear on the last line of the screen as you type
X  	them. If you typed something wrong, press  <ESC>  and start over.
X
X---> There are a some words fun that don't belong paper in this sentence.
X
X  5. Repeat steps 3 and 4 until the sentence is correct and go to Lesson 2.2.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X			     **************
X			     * Lesson 2.2 *
X			     **************
X              =====>>>>> MORE DELETION COMMANDS <<<<<=====
X
X           ** Type  d$  to delete to the end of the line. **
X
X  1. Press  <ESC>  to make sure you are in Command Mode.
X
X  2. Move the cursor to the line below marked --->.
X
X  3. Move the cursor to the end of the correct line (AFTER the first . ).
X
X  4. Type    d$    to delete to the end of the line.
X
X---> Somebody typed the end of this line twice. end of this line twice.
X
X
X  5. Move on to Lesson 2.3 to understand what is happening.
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X			     **************
X			     * Lesson 2.3 *
X			     **************
X             =====>>>>> ON COMMANDS AND OBJECTS <<<<<=====
X
X  The format for the  d  delete command is as follows:
X
X         [number]   d   object      OR       d   [number]   object
X  Where: 
X    number - is how many times to execute the command (optional, default=1).
X    d - is the command to delete.
X    object - is what the command will operate on (listed below).
X
X  A short list of objects:
X    w - from the cursor to the end of the word, including the space.
X    e - from the cursor to the end of the word, NOT including the space.
X    $ - from the cursor to the end of the line.
X    
XNOTE:  For the adventurous, pressing just the object while in Command Mode
X       without a command will move the cursor as specified in the object list.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 2.4 *
X                             **************
X        =====>>>>> AN EXCEPTION TO  'COMMAND-OBJECT' <<<<<=====
X
X               ** Type   dd   to delete a whole line. **
X
X  Due to the frequency of whole line deletion, the designers of Vim decided
X  it would be easier to simply type two d's in a row to delete a line.
X
X  1. Move the cursor to the second line in the phrase below. 
X
X  2. Type  dd  to delete the line.
X
X  3. Now move to the fourth line.
X
X  4. Type   2dd   (remember  number-command-object) to delete the two lines.
X
X      1)  Roses are red,
X      2)  Mud is fun,
X      3)  Violets are blue,
X      4)  I have a car,
X      5)  Clocks tell time,
X      6)  Sugar is sweet
X      7)  And so are you.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 2.5 *
X                             **************
X                 =====>>>>> THE UNDO COMMAND <<<<<=====
X
X   ** Press  u  to undo the last commands,   U   to fix a whole line. **
X
X  1. Move the cursor to the line below marked ---> and place it on the
X     first error.
X  2. Type  x  to delete the first unwanted character.
X  3. Now type  u  to undo the last command executed.
X  4. This time fix all the errors on the line using the  x  command.
X  5. Now type a capital  U  to return the line to its original state.
X  6. Now type  u  a few times to undo the  U  and preceding commands.
X  7. Now type CTRL-R (keeping CTRL key pressed while hitting R) a few times
X     to redo the commands (undo the undo's).
X
X---> Fiix the errors oon thhis line and reeplace them witth undo.
X
X  8. These are very useful commands.  Now move on to the Lesson 2 Summary.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 2 SUMMARY *
X                          ********************
X
X  1. To delete from the cursor to the end of a word type:    dw
X
X  2. To delete from the cursor to the end of a line type:    d$
X
X  3. To delete a whole line type:    dd
X
X  4. The format for a command in command mode is:
X
X       [number]   command   object     OR     command   [number]   object
X     where:
X       number - is how many times to repeat the command
X       command - is what to do, such as  d  for delete
X       object - is what the command should act upon, such as  w (word),
X                $ (to the end of line), etc.
X
X  5. To undo previous actions, type:         u   (lowercase u)
X     To undo all the changes on a line type: U   (capital U)
X     To undo the undo's type:		     CTRL-R
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 3.1 *
X                             **************
X                 =====>>>>> THE PUT COMMAND <<<<<=====
X
X       ** Type  p  to put the last deletion after the cursor. **
X
X  1. Move the cursor to the first line in the set below.
X
X  2. Type  dd  to delete the line and store it in Vim's buffer.
X
X  3. Move the cursor to the line ABOVE where the deleted line should go.
X
X  4. While in Command Mode, type    p    to replace the line.
X
X  5. Repeat steps 2 through 4 to put all the lines in correct order.
X
X     d) Can you learn too?
X     b) Violets are blue,
X     c) Intelligence is learned,
X     a) Roses are red,
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 3.2 *
X                             **************
X               =====>>>>> THE REPLACE COMMAND <<<<<=====
X
X  ** Type  r  and a character to replace the character under the cursor. **
X
X  1. Move the cursor to the first line below marked --->.
X
X  2. Move the cursor so that it is on top of the first error.
X
X  3. Type   r   and then the character which should replace the error.
X
X  4. Repeat steps 2 and 3 until the first line is correct.
X
X--->  Whan this lime was tuoed in, someone presswd some wrojg keys!
X--->  When this line was typed in, someone pressed some wrong keys!
X
X  5. Now move on to Lesson 3.2.
X
XNOTE: Remember that you should be learning by use, not memorization.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 3.3 *
X                             **************
X                =====>>>>> THE CHANGE COMMAND <<<<<=====
X
X           ** To change part or all of a word, type  cw . **
X
X  1. Move the cursor to the first line below marked --->.
X
X  2. Place the cursor on the u in lubw.  
X
X  3. Type  cw  and the correct word (in this case, type  'ine'.)
X
X  4. Press <ESC> and move to the next error (the first character to be changed.)
X
X  5. Repeat steps 3 and 4 until the first sentence is the same as the second.
X
X---> This lubw has a few wptfd that mrrf changing usf the change command.
X---> This line has a few words that need changing using the change command. 
X
XNotice that  cw  not only replaces the word, but also places you in insert.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 3.4 *
X                             **************
X               =====>>>>> MORE CHANGES USING c <<<<<=====
X
X     ** The change command is used with the same objects as delete. **
X
X  1. The change command works in the same way as delete.  The format is:
X
X       [number]   c   object       OR       c   [number]   object
X
X  2. The objects are also the same, such as   w (word), $ (end of line), etc.
X
X  3. Move to the first line below marked --->.
X
X  4. Move the cursor to the first error.
X 
X  5. Type  c$  to make the rest of the line like the second and press <ESC>.
X
X---> The end of this line needs some help to make it like the second. 
X---> The end of this line needs to be corrected using the  c$  command.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 3 SUMMARY *
X                          ********************
X
X  1. To replace text that has already been deleted, type   p .  This Puts the
X     deleted text AFTER the cursor (if a line was deleted it will go on the
X     line below the cursor).
X
X  2. To replace the character under the cursor, type   r   and then the 
X     character which will replace the original.
X
X  3. The change command allows you to change the specified object from the
X     cursor to the end of the object.  eg. Type  cw  to change from the
X     cursor to the end of the word, c$  to change to the end of a line.
X
X  4. The format for change is:
X    
X         [number]   c   object        OR        c   [number]   object
X
XNow go on to the next lesson.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 4.1 *
X                             **************
X             =====>>>>> LOCATION AND FILE STATUS <<<<<=====
X
X  ** Type CTRL-g to show your location in the file and the file status.   
X     Type SHIFT-G to move to a line in the file. **
X
X  Note: Read this entire lesson before executing any of the steps!!
X
X  1. Hold down the Ctrl key and press  g .  A status line will appear at the
X     bottom of the page with the filename and the line you are on.  Remember
X     the line number for Step 3.
X
X  2. Press shift-G to move you to the bottom of the file. 
X
X  3. Type in the number of the line you were on and then shift-G.  This will 
X     return you to the line you were on when you first pressed Ctrl-g.
X     (When you type in the numbers, they will NOT be displayed on the screen.)
X
X  4. If you feel confident to do this, execute steps 1 through 3.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 4.2 *
X                             **************
X                =====>>>>> THE SEARCH COMMAND <<<<<=====
X
X     ** Type  /  followed by a phrase to search for the phrase. **
X
X  1. In command mode type the  /  character.  Notice that it and the cursor
X     appear at the bottom of the screen as with the  :  command.
X
X  2. Now type 'errroor' <RETURN>.  This is the word you want to search for.
X
X  3. To search for the same phrase again, simply type  n .
X     To search for the same phrase in the opposite direction, type  Shift-N .
X
X  4. If you want to search for a phrase in the backwards direction, use the
X     command  ?  instead of /.
X
X---> When the search reaches the end of the file it will continue at the start.
X
X  "errroor" is not the way to spell error;  errroor is an error.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 4.3 *
X                             **************
X            =====>>>>> MATCHING PARENTHESES SEARCH <<<<<=====
X
X              ** Type  %  to find a matching ),], or } . **
X
X  1. Place the cursor on any (, [, or { in the line below marked --->. 
X
X  2. Now type the  %  character.
X
X  3. The cursor should be on the matching parenthesis or bracket.
X
X  4. Type  %  to move the cursor back to the first bracket (by matching).
X
X---> This ( is a test line with ('s, ['s ] and {'s } in it. ))
X
XNote: This is very useful in debugging a program with unmatched parentheses!
X
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 4.4 *
X                             **************
X              =====>>>>> A WAY TO CHANGE ERRORS <<<<<=====
X
X        ** Type  :s/old/new/g  to substitute 'new' for 'old'. **
X
X  1. Move the cursor to the line below marked --->.
X
X  2. Type  :s/thee/the <RETURN> .  Note that this command only changes the 
X     first occurrence on the line.
X
X  3. Now type    :s/thee/the/g     meaning substitute globally on the line.
X     This changes all occurrences on the line.
X
X---> thee best time to see thee flowers is in thee spring.
X
X  4. To change every occurrence of a character string between two lines,
X     type   :#,#s/old/new/g    where #,# are the numbers of the two lines.
X     Type   :%s/old/new/g    to change every occurrence in the whole file.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 4 SUMMARY *
X                          ********************
X
X  1. Ctrl-g  displays your location in the file and the file status.
X     Shift-G  moves to the end of the file.  A line number followed 
X     by  Shift-G  moves to that line number.
X
X  2. Typing  /  followed by a phrase searches FORWARD for the phrase.
X     Typing  ?  followed by a phrase searches BACKWARD for the phrase.
X     After a search type  n  to find the next occurrence in the same direction
X     or  Shift-N  to search in the opposite direction.
X
X  3. Typing  %  while the cursor is on a  (,),[,],{, or }  locates its 
X     matching pair.
X
X  4. To substitute new for the first old on a line type    :s/old/new
X     To substitute new for all 'old's on a line type       :s/old/new/g
X     To substitute phrases between two line #'s type       :#,#s/old/new/g
X     To substitute all occurrences in the file type        :%s/old/new/g
X     To ask for confirmation each time add 'c'             :%s/old/new/gc
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 5.1 *
X                             **************
X          =====>>>>> HOW TO EXECUTE AN AMIGA COMMAND <<<<<=====
X
X   ** Type  :!  followed by an Amiga command to execute that command. **
X
X  1. Type the familiar command  :  to set the cursor at the bottom of the
X     screen.  This allows you to enter a command.
X
X  2. Now type the  !  (exclamation point) character.  This allows you to 
X     execute an Amiga shell command.
X
X  3. As an example type   ls   following the !.  This will show you a listing
X     of your directory, just as if you were at the  %  prompt.
X
X---> Note:  It is possible to execute any shell command this way.
X
X
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 5.2 *
X                             **************
X              =====>>>>> MORE ON WRITING FILES <<<<<=====
X
X     ** To save the changes made to the file, type  :w FILENAME. **
X
X  1. Type  :!dir  to get a listing of your directory.
X
X  2. Choose a filename that is not already in your area, such as TEST.
X
X  3. Now type:   :w TEST   (where TEST is the filename you chose.)
X
X  4. This saves the whole file  (Vim Tutor)  under the name TEST.
X     To verify this, type    :!dir   again to see your directory
X
X---> Note that if you were to exit Vim and enter again with the filename TEST,
X     the file would be an exact copy of the tutor when you saved it.
X
X  5. Now remove the file from your area by typing:     :!delete TEST
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 5.3 *
X                             **************
X            =====>>>>> A SELECTIVE WRITE COMMAND <<<<<=====
X
X        ** To save part of the file, type   :#,# w FILENAME **
X
X  1. Once again, type    :!dir    to obtain a listing of your directory and
X     choose a suitable filename such as TEST.
X
X  2. Move the cursor to the top of this page and type  Ctrl-g  to find the 
X     number of that line.  REMEMBER THIS NUMBER!
X
X  3. Now move to the bottom of the page and type  Ctrl-g again.  REMEMBER THIS
X     LINE NUMBER ALSO!
X
X  4. To save ONLY a section to a file, type   :#,# w TEST   where #,# are
X     the two numbers you remembered (top,bottom) and TEST is your filename.
X
X  5. Again, see that the file is there with  :!dir  but DO NOT remove it.      
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 5.4 *
X                             **************
X           =====>>>>> RETRIEVING AND MERGING FILES <<<<<=====
X
X       ** To insert the contents of a file, type   :r FILENAME **
X
X  1. Type   :!dir   to make sure your TEST filename is present from before.
X
X  2. Place the cursor at the top of this page.
X
XNOTE:  After executing Step 3 you will see Lesson 5.3.  Then move DOWN to
X       this lesson again.
X
X  3. Now retrieve your TEST file using the command   :r TEST   where TEST is 
X     the name of the file.  
X
XNOTE:  The file you retrieve is placed starting where the cursor is located.
X
X  4. To verify that a file was retrieved, cursor back and notice that there 
X     are now two copies of Lesson 5.3, the original and the file version. 
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 5 SUMMARY *
X                          ********************
X
X  1.  :!command  executes an Amiga system command.
X
X      Some useful examples are:
X          :!dir  -  shows a directory listing of your area.
X          :!delete FILENAME  -  removes file FILENAME from your area.
X
X  2.  :w FILENAME  writes the current Vim file to disk with name FILENAME.
X
X  3.  :#,# FILENAME  saves the lines # through # in file FILENAME.
X
X  4.  :r FILENAME  retrieves disk file FILENAME and inserts it into the
X      current file following the cursor position.
X
X
X
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 6.1 *
X                             **************
X                 =====>>>>> THE OPEN COMMAND <<<<<=====
X
X ** Type  o  to open a line below the cursor and place you in insert mode. **
X
X  1. Move the cursor to the line below marked --->.
X
X  2. Type  o (lowercase) to open up a line BELOW the cursor and place you in
X     insert mode.
X
X  3. Now copy the line marked ---> and press <ESC> to exit insert mode.
X
X---> After typing  o  the cursor is placed on the open line in insert mode.
X
X  4. To open up a line ABOVE the cursor, simply type a capital  O , rather
X     than a lowercase  o.  Try this on the line below.
XOpen up a line above this by typing Shift-O while the cursor is on this line.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 6.2 *
X                             **************
X                =====>>>>> THE APPEND COMMAND <<<<<=====
X
X             ** Type  a  to insert text AFTER the cursor. **
X
X  1. Move the cursor to the end of the first line below marked ---> by 
X     typing  $  in Command mode.
X
X  2. Type an  a  (lowercase) to append text AFTER the character under the
X     cursor.  (Uppercase  A  appends to the end of the line.)
X
XNote: This avoids typing  i , the last character, the text to insert, <ESC>,
X      cursor-right, and finally, x , just to append to the end of a line!
X
X  3. Now complete the first line.  Note also that append is exactly the same
X     as insert mode, except for the location where text is inserted.
X
X---> This line will allow you to practice
X---> This line will allow you to practice appending text to the end of a line.
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 6.3 *
X                             **************
X            =====>>>>> ANOTHER VERSION OF REPLACE <<<<<=====
X
X      ** Type a capital  R  to replace more than one character. **
X
X  1. Move the cursor to the first line below marked --->.
X
X  2. Place the cursor at the beginning of the first word that is different
X     from the second line marked ---> (the word 'last').
X
X  3. Now type  R  and replace the remainder of the text on the first line by
X     typing over the old text to make the first line the same as the second.
X
X---> To make the first line the same as the last on this page use the keys.
X---> To make the first line the same as the second, type R and the new text.
X
X  4. Note that when you press <ESC> to exit, any unaltered text remains.
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                             **************
X                             * Lesson 6.4 *
X                             **************
X            =====>>>>> SET ENVIRONMENT VARIABLE <<<<<=====
X
X      ** Change environment so a search or substitute ignores case **
X
X
X  1. Search for 'ignore' by entering: 
X     /ignore
X     Repeat several times by hitting the n key
X
X  2. Set the 'ic' (Ignore case) variable by typing: 
X     :set ic
X
X  3. Now search for 'ignore' again by entering: n
X     Repeat search several more times by hitting the n key
X
X
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X                          ********************
X                          * LESSON 6 SUMMARY *
X                          ********************
X
X  1. Typing  o  opens a line BELOW the cursor and places the cursor on the open
X     line in insert mode.
X     Typing a capital  O  opens the line ABOVE the line the cursor is on.
X
X  2. Type an  a  to insert text AFTER the character the cursor is on.
X     Typing a capital  A  automatically appends text to the end of the line. 
X
X  3. Typing a capital  R  enters replace mode until  <ESC>  is pressed to exit.
X
X  4. Typing ":set xxx" sets the environment variable "xxx"
X
X
X
X
X
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X
X  This concludes the Vim Tutor.  It was intended to give a brief overview of
X  the Vim editor, just enough to allow you to use the editor fairly easily.
X  It is far from complete as Vim has many many more commands.
X
X  For more information on Vim editor please refer to:
X
X	doc/reference.doc - a complete description of Vim
X	doc/index - a short summary of all commands
X	doc/difference.doc - summary of differences between vi and Vim
X
X  Or hit the HELP key!
X
X  This tutorial was written by Michael C. Pierce and Robert K. Ware,
X  Colorado School of Mines using ideas supplied by Charles Smith,
X  Colorado State University.
X  E-mail: bware@mines.colorado.edu.
X
X  Modified for Vim by Bram Moolenaar.
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
END_OF_FILE
if test 28799 -ne `wc -c <'vim/tutor/tutor'`; then
    echo shar: \"'vim/tutor/tutor'\" unpacked with wrong size!
fi
chmod +x 'vim/tutor/tutor'
# end of 'vim/tutor/tutor'
fi
echo shar: End of archive 13 \(of 25\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
