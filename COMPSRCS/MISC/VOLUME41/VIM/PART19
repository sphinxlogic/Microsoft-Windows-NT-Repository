Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i069:  vim - Vi IMitation editor, v2.0, Part19/25
Message-ID: <1993Dec21.172738.1928@sparky.sterling.com>
X-Md4-Signature: 66c56722b5170bd257ffccdeb729778c
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 17:27:38 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 69
Archive-name: vim/part19
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 25)."
# Contents:  vim/src/regexp.c
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:08 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/src/regexp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/regexp.c'\"
else
echo shar: Extracting \"'vim/src/regexp.c'\" \(38964 characters\)
sed "s/^X//" >'vim/src/regexp.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X * This is NOT the original regular expression code as written by
X * Henry Spencer. This code has been modified specifically for use
X * with the VIM editor, and should not be used apart from compiling
X * VIM. If you want a good regular expression library, get the
X * original code. The copyright notice that follows is from the
X * original.
X *
X * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
X *
X *
X * regcomp and regexec -- regsub and regerror are elsewhere
X *
X *		Copyright (c) 1986 by University of Toronto.
X *		Written by Henry Spencer.  Not derived from licensed software.
X *
X *		Permission is granted to anyone to use this software for any
X *		purpose on any computer system, and to redistribute it freely,
X *		subject to the following restrictions:
X *
X *		1. The author is not responsible for the consequences of use of
X *				this software, no matter how awful, even if they arise
X *				from defects in it.
X *
X *		2. The origin of this software must not be misrepresented, either
X *				by explicit claim or by omission.
X *
X *		3. Altered versions must be plainly marked as such, and must not
X *				be misrepresented as being the original software.
X *
X * Beware that some of this code is subtly aware of the way operator
X * precedence is structured in regular expressions.  Serious changes in
X * regular-expression syntax might require a total rethink.
X *
X * $Log:		regexp.c,v $
X * Revision 1.2  88/04/28  08:09:45  tony
X * First modification of the regexp library. Added an external variable
X * 'reg_ic' which can be set to indicate that case should be ignored.
X * Added a new parameter to regexec() to indicate that the given string
X * comes from the beginning of a line and is thus eligible to match
X * 'beginning-of-line'.
X *
X * Revisions by Olaf 'Rhialto' Seibert, rhialto@cs.kun.nl:
X * Changes for vi: (the semantics of several things were rather different)
X * - Added lexical analyzer, because in vi magicness of characters
X *   is rather difficult, and may change over time.
X * - Added support for \< \> \1-\9 and ~
X * - Left some magic stuff in, but only backslashed: \| \+
X * - * and \+ still work after \) even though they shouldn't.
X */
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#undef DEBUG
X
X#include <stdio.h>
X#include "regexp.h"
X#include "regmagic.h"
X
X/*
X * The "internal use only" fields in regexp.h are present to pass info from
X * compile to execute that permits the execute phase to run lots faster on
X * simple cases.  They are:
X *
X * regstart 	char that must begin a match; '\0' if none obvious
X * reganch		is the match anchored (at beginning-of-line only)?
X * regmust		string (pointer into program) that match must include, or NULL
X * regmlen		length of regmust string
X *
X * Regstart and reganch permit very fast decisions on suitable starting points
X * for a match, cutting down the work a lot.  Regmust permits fast rejection
X * of lines that cannot possibly match.  The regmust tests are costly enough
X * that regcomp() supplies a regmust only if the r.e. contains something
X * potentially expensive (at present, the only such thing detected is * or +
X * at the start of the r.e., which can involve a lot of backup).  Regmlen is
X * supplied because the test in regexec() needs it and regcomp() is computing
X * it anyway.
X */
X
X/*
X * Structure for regexp "program".	This is essentially a linear encoding
X * of a nondeterministic finite-state machine (aka syntax charts or
X * "railroad normal form" in parsing technology).  Each node is an opcode
X * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
X * all nodes except BRANCH implement concatenation; a "next" pointer with
X * a BRANCH on both ends of it is connecting two alternatives.	(Here we
X * have one of the subtle syntax dependencies:	an individual BRANCH (as
X * opposed to a collection of them) is never concatenated with anything
X * because of operator precedence.)  The operand of some types of node is
X * a literal string; for others, it is a node leading into a sub-FSM.  In
X * particular, the operand of a BRANCH node is the first node of the branch.
X * (NB this is *not* a tree structure:	the tail of the branch connects
X * to the thing following the set of BRANCHes.)  The opcodes are:
X */
X
X/* definition	number			   opnd?	meaning */
X#define END 	0				/* no	End of program. */
X#define BOL 	1				/* no	Match "" at beginning of line. */
X#define EOL 	2				/* no	Match "" at end of line. */
X#define ANY 	3				/* no	Match any one character. */
X#define ANYOF	4				/* str	Match any character in this string. */
X#define ANYBUT	5				/* str	Match any character not in this
X								 *		string. */
X#define BRANCH	6				/* node Match this alternative, or the
X								 *		next... */
X#define BACK	7				/* no	Match "", "next" ptr points backward. */
X#define EXACTLY 8				/* str	Match this string. */
X#define NOTHING 9				/* no	Match empty string. */
X#define STAR	10				/* node Match this (simple) thing 0 or more
X								 *		times. */
X#define PLUS	11				/* node Match this (simple) thing 1 or more
X								 *		times. */
X#define BOW		12				/* no	Match "" after [^a-zA-Z0-9_] */
X#define EOW		13				/* no	Match "" at    [^a-zA-Z0-9_] */
X#define MOPEN	20				/* no	Mark this point in input as start of
X								 *		#n. */
X /* MOPEN+1 is number 1, etc. */
X#define MCLOSE	30				/* no	Analogous to MOPEN. */
X#define BACKREF	40				/* node Match same string again \1-\9 */
X
X#define Magic(x)	((x)|('\\'<<8))
X
X/*
X * Opcode notes:
X *
X * BRANCH		The set of branches constituting a single choice are hooked
X *				together with their "next" pointers, since precedence prevents
X *				anything being concatenated to any individual branch.  The
X *				"next" pointer of the last BRANCH in a choice points to the
X *				thing following the whole choice.  This is also where the
X *				final "next" pointer of each individual branch points; each
X *				branch starts with the operand node of a BRANCH node.
X *
X * BACK 		Normal "next" pointers all implicitly point forward; BACK
X *				exists to make loop structures possible.
X *
X * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
X *				BRANCH structures using BACK.  Simple cases (one character
X *				per match) are implemented with STAR and PLUS for speed
X *				and to minimize recursive plunges.
X *
X * MOPEN,MCLOSE	...are numbered at compile time.
X */
X
X/*
X * A node is one char of opcode followed by two chars of "next" pointer.
X * "Next" pointers are stored as two 8-bit pieces, high order first.  The
X * value is a positive offset from the opcode of the node containing it.
X * An operand, if any, simply follows the node.  (Note that much of the
X * code generation knows about this implicit relationship.)
X *
X * Using two bytes for the "next" pointer is vast overkill for most things,
X * but allows patterns to get big without disasters.
X */
X#define OP(p)	(*(p))
X#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
X#define OPERAND(p)		((p) + 3)
X
X/*
X * See regmagic.h for one further detail of program structure.
X */
X
X
X/*
X * Utility definitions.
X */
X#ifndef CHARBITS
X#define UCHARAT(p)		((int)*(unsigned char *)(p))
X#else
X#define UCHARAT(p)		((int)*(p)&CHARBITS)
X#endif
X
X#define FAIL(m) { emsg(m); return NULL; }
X
Xstatic int ismult __ARGS((int));
X
X	static int
Xismult(c)
X	int c;
X{
X	return (c == Magic('*') || c == Magic('+') || c == Magic('?'));
X}
X
X/*
X * Flags to be passed up and down.
X */
X#define HASWIDTH		01		/* Known never to match null string. */
X#define SIMPLE			02		/* Simple enough to be STAR/PLUS operand. */
X#define SPSTART 		04		/* Starts with * or +. */
X#define WORST			0		/* Worst case. */
X
X/*
X * The following supports the ability to ignore case in searches.
X */
X
Xint 			reg_ic = 0; 	/* set by callers to ignore case */
X
X/*
X * mkup - convert to upper case IF we're doing caseless compares
X */
X#define mkup(c) 		(reg_ic ? TO_UPPER(c) : (c))
X
X/*
X * The following allows empty REs, meaning "the same as the previous RE".
X * per the ed(1) manual.
X */
X/* #define EMPTY_RE */			/* this is done outside of regexp */
X#ifdef EMTY_RE
Xchar		   *reg_prev_re;
X#endif
X
X#define TILDE
X#ifdef TILDE
Xchar		   *reg_prev_sub;
X#endif
X
X/*
X * This if for vi's "magic" mode. If magic is false, only ^$\ are magic.
X */
X
Xint				reg_magic = 1;
X
X/*
X * Global work variables for regcomp().
X */
X
Xstatic unsigned char    *regparse;	/* Input-scan pointer. */
Xstatic int		regnpar;		/* () count. */
Xstatic char 	regdummy;
Xstatic char    *regcode;		/* Code-emit pointer; &regdummy = don't. */
Xstatic long 	regsize;		/* Code size. */
Xstatic char   **regendp;		/* Ditto for endp. */
X
X/*
X * META contains all characters that may be magic, except '^' and '$'.
X * This depends on the configuration options TILDE, BACKREF.
X * (could be done simpler for compilers that know string concatenation)
X */
X
X#ifdef TILDE
X# ifdef BACKREF
X       static char META[] = ".[()|?+*<>~123456789";
X# else
X       static char META[] = ".[()|?+*<>~";
X# endif
X#else
X# ifdef BACKREF
X       static char META[] = ".[()|?+*<>123456789";
X# else
X       static char META[] = ".[()|?+*<>";
X# endif
X#endif
X
X/*
X * Forward declarations for regcomp()'s friends.
X */
Xstatic void		initchr __ARGS((unsigned char *));
Xstatic int		getchr __ARGS((void));
Xstatic int		peekchr __ARGS((void));
X#define PeekChr() curchr	/* shortcut only when last action was peekchr() */
Xstatic int 		curchr;
Xstatic void		skipchr __ARGS((void));
Xstatic void		ungetchr __ARGS((void));
Xstatic char    *reg __ARGS((int, int *));
Xstatic char    *regbranch __ARGS((int *));
Xstatic char    *regpiece __ARGS((int *));
Xstatic char    *regatom __ARGS((int *));
Xstatic char    *regnode __ARGS((int));
Xstatic char    *regnext __ARGS((char *));
Xstatic void 	regc __ARGS((int));
Xstatic void 	unregc __ARGS((void));
Xstatic void 	reginsert __ARGS((int, char *));
Xstatic void 	regtail __ARGS((char *, char *));
Xstatic void 	regoptail __ARGS((char *, char *));
X
X#undef STRCSPN
X#ifdef STRCSPN
Xstatic int		strcspn __ARGS((const char *, const char *));
X#endif
Xstatic int		cstrncmp __ARGS((char *, char *, int));
X
X/*
X - regcomp - compile a regular expression into internal code
X *
X * We can't allocate space until we know how big the compiled form will be,
X * but we can't compile it (and thus know how big it is) until we've got a
X * place to put the code.  So we cheat:  we compile it twice, once with code
X * generation turned off and size counting turned on, and once "for real".
X * This also means that we don't allocate space until we are sure that the
X * thing really will compile successfully, and we never have to move the
X * code and thus invalidate pointers into it.  (Note that it has to be in
X * one piece because free() must be able to free it all.)
X *
X * Beware that the optimization-preparation code in here knows about some
X * of the structure of the compiled regexp.
X */
X	regexp		   *
Xregcomp(exp)
X	char		   *exp;
X{
X	register regexp *r;
X	register char  *scan;
X	register char  *longest;
X	register int	len;
X	int 			flags;
X/*	extern char    *malloc();*/
X
X	if (exp == NULL) {
X		FAIL(e_null);
X	}
X
X#ifdef EMPTY_RE			/* this is done outside of regexp */
X	if (*exp == '\0') {
X		if (reg_prev_re) {
X			exp = reg_prev_re;
X		} else {
X			FAIL(e_noprevre);
X		}
X	}
X#endif
X
X	/* First pass: determine size, legality. */
X	initchr((unsigned char *)exp);
X	regnpar = 1;
X	regsize = 0L;
X	regcode = &regdummy;
X	regendp = NULL;
X	regc(MAGIC);
X	if (reg(0, &flags) == NULL)
X		return NULL;
X
X	/* Small enough for pointer-storage convention? */
X	if (regsize >= 32767L)		/* Probably could be 65535L. */
X		FAIL(e_toolong);
X
X	/* Allocate space. */
X/*	r = (regexp *) malloc((unsigned) (sizeof(regexp) + regsize));*/
X	r = (regexp *) alloc((unsigned) (sizeof(regexp) + regsize));
X	if (r == NULL)
X		FAIL(e_outofmem);
X
X#ifdef EMPTY_RE			/* this is done outside of regexp */
X	if (exp != reg_prev_re) {
X		free(reg_prev_re);
X		if (reg_prev_re = alloc(strlen(exp) + 1))
X			strcpy(reg_prev_re, exp);
X	}
X#endif
X
X	/* Second pass: emit code. */
X	initchr((unsigned char *)exp);
X	regnpar = 1;
X	regcode = r->program;
X	regendp = r->endp;
X	regc(MAGIC);
X	if (reg(0, &flags) == NULL) {
X		free(r);
X		return NULL;
X	}
X
X	/* Dig out information for optimizations. */
X	r->regstart = '\0'; 		/* Worst-case defaults. */
X	r->reganch = 0;
X	r->regmust = NULL;
X	r->regmlen = 0;
X	scan = r->program + 1;		/* First BRANCH. */
X	if (OP(regnext(scan)) == END) { 	/* Only one top-level choice. */
X		scan = OPERAND(scan);
X
X		/* Starting-point info. */
X		if (OP(scan) == EXACTLY)
X			r->regstart = *OPERAND(scan);
X		else if (OP(scan) == BOL)
X			r->reganch++;
X
X		/*
X		 * If there's something expensive in the r.e., find the longest
X		 * literal string that must appear and make it the regmust.  Resolve
X		 * ties in favor of later strings, since the regstart check works
X		 * with the beginning of the r.e. and avoiding duplication
X		 * strengthens checking.  Not a strong reason, but sufficient in the
X		 * absence of others.
X		 */
X		if (flags & SPSTART) {
X			longest = NULL;
X			len = 0;
X			for (; scan != NULL; scan = regnext(scan))
X				if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= (size_t)len) {
X					longest = OPERAND(scan);
X					len = strlen(OPERAND(scan));
X				}
X			r->regmust = longest;
X			r->regmlen = len;
X		}
X	}
X#ifdef DEBUG
X	regdump(r);
X#endif
X	return r;
X}
X
X/*
X - reg - regular expression, i.e. main body or parenthesized thing
X *
X * Caller must absorb opening parenthesis.
X *
X * Combining parenthesis handling with the base level of regular expression
X * is a trifle forced, but the need to tie the tails of the branches to what
X * follows makes it hard to avoid.
X */
X	static char *
Xreg(paren, flagp)
X	int 			paren;		/* Parenthesized? */
X	int 		   *flagp;
X{
X	register char  *ret;
X	register char  *br;
X	register char  *ender;
X	register int	parno = 0;
X	int 			flags;
X
X	*flagp = HASWIDTH;			/* Tentatively. */
X
X	/* Make an MOPEN node, if parenthesized. */
X	if (paren) {
X		if (regnpar >= NSUBEXP)
X			FAIL(e_toombra);
X		parno = regnpar;
X		regnpar++;
X		ret = regnode((char)(MOPEN + parno));
X		if (regendp)
X			regendp[parno] = NULL;	/* haven't seen the close paren yet */
X	} else
X		ret = NULL;
X
X	/* Pick up the branches, linking them together. */
X	br = regbranch(&flags);
X	if (br == NULL)
X		return NULL;
X	if (ret != NULL)
X		regtail(ret, br);		/* MOPEN -> first. */
X	else
X		ret = br;
X	if (!(flags & HASWIDTH))
X		*flagp &= ~HASWIDTH;
X	*flagp |= flags & SPSTART;
X	while (peekchr() == Magic('|')) {
X		skipchr();
X		br = regbranch(&flags);
X		if (br == NULL)
X			return NULL;
X		regtail(ret, br);		/* BRANCH -> BRANCH. */
X		if (!(flags & HASWIDTH))
X			*flagp &= ~HASWIDTH;
X		*flagp |= flags & SPSTART;
X	}
X
X	/* Make a closing node, and hook it on the end. */
X	ender = regnode((char)((paren) ? MCLOSE + parno : END));
X	regtail(ret, ender);
X
X	/* Hook the tails of the branches to the closing node. */
X	for (br = ret; br != NULL; br = regnext(br))
X		regoptail(br, ender);
X
X	/* Check for proper termination. */
X	if (paren && getchr() != Magic(')')) {
X		FAIL(e_toombra);
X	} else if (!paren && peekchr() != '\0') {
X		if (PeekChr() == Magic(')')) {
X			FAIL(e_toomket);
X		} else
X			FAIL(e_trailing);/* "Can't happen". */
X		/* NOTREACHED */
X	}
X	/*
X	 * Here we set the flag allowing back references to this set of
X	 * parentheses.
X	 */
X	if (paren && regendp)
X		regendp[parno] = ender;	/* have seen the close paren */
X	return ret;
X}
X
X/*
X - regbranch - one alternative of an | operator
X *
X * Implements the concatenation operator.
X */
X	static char    *
Xregbranch(flagp)
X	int 		   *flagp;
X{
X	register char  *ret;
X	register char  *chain;
X	register char  *latest;
X	int 			flags;
X
X	*flagp = WORST; 			/* Tentatively. */
X
X	ret = regnode(BRANCH);
X	chain = NULL;
X	while (peekchr() != '\0' && PeekChr() != Magic('|') && PeekChr() != Magic(')')) {
X		latest = regpiece(&flags);
X		if (latest == NULL)
X			return NULL;
X		*flagp |= flags & HASWIDTH;
X		if (chain == NULL)		/* First piece. */
X			*flagp |= flags & SPSTART;
X		else
X			regtail(chain, latest);
X		chain = latest;
X	}
X	if (chain == NULL)			/* Loop ran zero times. */
X		(void) regnode(NOTHING);
X
X	return ret;
X}
X
X/*
X - regpiece - something followed by possible [*+?]
X *
X * Note that the branching code sequences used for ? and the general cases
X * of * and + are somewhat optimized:  they use the same NOTHING node as
X * both the endmarker for their branch list and the body of the last branch.
X * It might seem that this node could be dispensed with entirely, but the
X * endmarker role is not redundant.
X */
Xstatic char    *
Xregpiece(flagp)
X	int 		   *flagp;
X{
X	register char  *ret;
X	register int	op;
X	register char  *next;
X	int 			flags;
X
X	ret = regatom(&flags);
X	if (ret == NULL)
X		return NULL;
X
X	op = peekchr();
X	if (!ismult(op)) {
X		*flagp = flags;
X		return ret;
X	}
X	if (!(flags & HASWIDTH) && op != Magic('?'))
X		FAIL("*+ operand could be empty");
X	*flagp = (op != Magic('+')) ? (WORST | SPSTART) : (WORST | HASWIDTH);
X
X	if (op == Magic('*') && (flags & SIMPLE))
X		reginsert(STAR, ret);
X	else if (op == Magic('*')) {
X		/* Emit x* as (x&|), where & means "self". */
X		reginsert(BRANCH, ret); /* Either x */
X		regoptail(ret, regnode(BACK));	/* and loop */
X		regoptail(ret, ret);	/* back */
X		regtail(ret, regnode(BRANCH));	/* or */
X		regtail(ret, regnode(NOTHING)); /* null. */
X	} else if (op == Magic('+') && (flags & SIMPLE))
X		reginsert(PLUS, ret);
X	else if (op == Magic('+')) {
X		/* Emit x+ as x(&|), where & means "self". */
X		next = regnode(BRANCH); /* Either */
X		regtail(ret, next);
X		regtail(regnode(BACK), ret);	/* loop back */
X		regtail(next, regnode(BRANCH)); /* or */
X		regtail(ret, regnode(NOTHING)); /* null. */
X	} else if (op == Magic('?')) {
X		/* Emit x? as (x|) */
X		reginsert(BRANCH, ret); /* Either x */
X		regtail(ret, regnode(BRANCH));	/* or */
X		next = regnode(NOTHING);/* null. */
X		regtail(ret, next);
X		regoptail(ret, next);
X	}
X	skipchr();
X	if (ismult(peekchr()))
X		FAIL("Nested *?+");
X
X	return ret;
X}
X
X/*
X - regatom - the lowest level
X *
X * Optimization:  gobbles an entire sequence of ordinary characters so that
X * it can turn them into a single node, which is smaller to store and
X * faster to run.
X */
Xstatic char    *
Xregatom(flagp)
X	int 		   *flagp;
X{
X	register char  *ret;
X	int 			flags;
X
X	*flagp = WORST; 			/* Tentatively. */
X
X	switch (getchr()) {
X	  case Magic('^'):
X		ret = regnode(BOL);
X		break;
X	  case Magic('$'):
X		ret = regnode(EOL);
X		break;
X	  case Magic('<'):
X		ret = regnode(BOW);
X		break;
X	  case Magic('>'):
X		ret = regnode(EOW);
X		break;
X	  case Magic('.'):
X		ret = regnode(ANY);
X		*flagp |= HASWIDTH | SIMPLE;
X		break;
X	  case Magic('['):{
X			/*
X			 * In a character class, different parsing rules apply.
X			 * Not even \ is special anymore, nothing is.
X			 */
X			if (*regparse == '^') { 	/* Complement of range. */
X				ret = regnode(ANYBUT);
X				regparse++;
X			} else
X				ret = regnode(ANYOF);
X			if (*regparse == ']' || *regparse == '-')
X				regc(*regparse++);
X			while (*regparse != '\0' && *regparse != ']') {
X				if (*regparse == '-') {
X					regparse++;
X					if (*regparse == ']' || *regparse == '\0')
X						regc('-');
X					else {
X						register int	class;
X						register int	classend;
X
X						class = UCHARAT(regparse - 2) + 1;
X						classend = UCHARAT(regparse);
X						if (class > classend + 1)
X							FAIL(e_invrange);
X						for (; class <= classend; class++)
X							regc((char)class);
X						regparse++;
X					}
X				} else if (*regparse == '\\' && regparse[1]) {
X					regparse++;
X					regc(*regparse++);
X				} else
X					regc(*regparse++);
X			}
X			regc('\0');
X			if (*regparse != ']')
X				FAIL(e_toomsbra);
X			skipchr();			/* let's be friends with the lexer again */
X			*flagp |= HASWIDTH | SIMPLE;
X		}
X		break;
X	  case Magic('('):
X		ret = reg(1, &flags);
X		if (ret == NULL)
X			return NULL;
X		*flagp |= flags & (HASWIDTH | SPSTART);
X		break;
X	  case '\0':
X	  case Magic('|'):
X	  case Magic(')'):
X		FAIL(e_internal);	/* Supposed to be caught earlier. */
X		/* break; Not Reached */
X	  case Magic('?'):
X	  case Magic('+'):
X	  case Magic('*'):
X		FAIL("?+* follows nothing");
X		/* break; Not Reached */
X#ifdef TILDE
X	  case Magic('~'):			/* previous substitute pattern */
X			if (reg_prev_sub) {
X				register char *p;
X
X				ret = regnode(EXACTLY);
X				p = reg_prev_sub;
X				while (*p) {
X					regc(*p++);
X				}
X				regc('\0');
X				if (p - reg_prev_sub) {
X					*flagp |= HASWIDTH;
X					if ((p - reg_prev_sub) == 1)
X						*flagp |= SIMPLE;
X				}
X	  		} else
X				FAIL(e_nopresub);
X			break;
X#endif
X#ifdef BACKREF
X	  case Magic('1'):
X	  case Magic('2'):
X	  case Magic('3'):
X	  case Magic('4'):
X	  case Magic('5'):
X	  case Magic('6'):
X	  case Magic('7'):
X	  case Magic('8'):
X	  case Magic('9'): {
X			int				refnum;
X
X			ungetchr();
X			refnum = getchr() - Magic('0');
X			/*
X			 * Check if the back reference is legal. We use the parentheses
X			 * pointers to mark encountered close parentheses, but this
X			 * is only available in the second pass. Checking opens is
X			 * always possible.
X			 * Should also check that we don't refer to something that
X			 * is repeated (+*?): what instance of the repetition should
X			 * we match? TODO.
X			 */
X			if (refnum < regnpar &&
X				(regendp == NULL || regendp[refnum] != NULL))
X				ret = regnode(BACKREF + refnum);
X			else
X				FAIL("Illegal back reference");
X		}
X		break;
X#endif
X	  default:{
X			register int	len;
X			int				chr;
X
X			ungetchr();
X			len = 0;
X			ret = regnode(EXACTLY);
X			while ((chr = peekchr()) != '\0' && (chr < Magic(0)))
X			{
X				regc(chr);
X				skipchr();
X				len++;
X			}
X#ifdef DEBUG
X			if (len == 0)
X				 FAIL("Unexpected magic character; check META.");
X#endif
X			/*
X			 * If there is a following *, \+ or \? we need the character
X			 * in front of it as a single character operand
X			 */
X			if (len > 1 && ismult(chr))
X			{
X				unregc();			/* Back off of *+? operand */
X				ungetchr();			/* and put it back for next time */
X				--len;
X			}
X			regc('\0');
X			*flagp |= HASWIDTH;
X			if (len == 1)
X				*flagp |= SIMPLE;
X		}
X		break;
X	}
X
X	return ret;
X}
X
X/*
X - regnode - emit a node
X */
Xstatic char    *				/* Location. */
Xregnode(op)
X	int			op;
X{
X	register char  *ret;
X	register char  *ptr;
X
X	ret = regcode;
X	if (ret == &regdummy) {
X		regsize += 3;
X		return ret;
X	}
X	ptr = ret;
X	*ptr++ = op;
X	*ptr++ = '\0';				/* Null "next" pointer. */
X	*ptr++ = '\0';
X	regcode = ptr;
X
X	return ret;
X}
X
X/*
X - regc - emit (if appropriate) a byte of code
X */
Xstatic void
Xregc(b)
X	int			b;
X{
X	if (regcode != &regdummy)
X		*(u_char *)regcode++ = b;
X	else
X		regsize++;
X}
X
X/*
X - unregc - take back (if appropriate) a byte of code
X */
Xstatic void
Xunregc()
X{
X	if (regcode != &regdummy)
X		regcode--;
X	else
X		regsize--;
X}
X
X/*
X - reginsert - insert an operator in front of already-emitted operand
X *
X * Means relocating the operand.
X */
Xstatic void
Xreginsert(op, opnd)
X	int			op;
X	char		   *opnd;
X{
X	register char  *src;
X	register char  *dst;
X	register char  *place;
X
X	if (regcode == &regdummy) {
X		regsize += 3;
X		return;
X	}
X	src = regcode;
X	regcode += 3;
X	dst = regcode;
X	while (src > opnd)
X		*--dst = *--src;
X
X	place = opnd;				/* Op node, where operand used to be. */
X	*place++ = op;
X	*place++ = '\0';
X	*place = '\0';
X}
X
X/*
X - regtail - set the next-pointer at the end of a node chain
X */
Xstatic void
Xregtail(p, val)
X	char		   *p;
X	char		   *val;
X{
X	register char  *scan;
X	register char  *temp;
X	register int	offset;
X
X	if (p == &regdummy)
X		return;
X
X	/* Find last node. */
X	scan = p;
X	for (;;) {
X		temp = regnext(scan);
X		if (temp == NULL)
X			break;
X		scan = temp;
X	}
X
X	if (OP(scan) == BACK)
X		offset = (int)(scan - val);
X	else
X		offset = (int)(val - scan);
X	*(scan + 1) = (char) ((offset >> 8) & 0377);
X	*(scan + 2) = (char) (offset & 0377);
X}
X
X/*
X - regoptail - regtail on operand of first argument; nop if operandless
X */
Xstatic void
Xregoptail(p, val)
X	char		   *p;
X	char		   *val;
X{
X	/* "Operandless" and "op != BRANCH" are synonymous in practice. */
X	if (p == NULL || p == &regdummy || OP(p) != BRANCH)
X		return;
X	regtail(OPERAND(p), val);
X}
X
X/*
X - getchr() - get the next character from the pattern. We know about
X * magic and such, so therefore we need a lexical analyzer.
X */
X
X/* static int		curchr; */
Xstatic int		prevchr;
Xstatic int		nextchr;	/* used for ungetchr() */
X
Xstatic void
Xinitchr(str)
Xunsigned char *str;
X{
X	regparse = str;
X	curchr = prevchr = nextchr = -1;
X}
X
Xstatic int
Xpeekchr()
X{
X	if (curchr < 0) {
X		switch (curchr = regparse[0]) {
X		case '.':
X		case '*':
X	/*	case '+':*/
X	/*	case '?':*/
X		case '[':
X		case '~':
X			if (reg_magic)
X				curchr = Magic(curchr);
X			break;
X		case '^':
X			/* ^ is only magic as the very first character */
X			if (prevchr < 0)
X				curchr = Magic('^');
X			break;
X		case '$':
X			/* $ is only magic as the very last character */
X			if (!regparse[1])
X				curchr = Magic('$');
X			break;
X		case '\\':
X			regparse++;
X			if (regparse[0] == NUL)
X				curchr = '\\';	/* trailing '\' */
X			else if (strchr(META, regparse[0]))
X			{
X				/*
X				 * META contains everything that may be magic sometimes, except
X				 * ^ and $ ("\^" and "\$" are never magic).
X				 * We now fetch the next character and toggle its magicness.
X				 * Therefore, \ is so meta-magic that it is not in META.
X				 */
X				curchr = -1;
X				peekchr();
X				curchr ^= Magic(0);
X			}
X			else
X			{
X				/*
X				 * Next character can never be (made) magic?
X				 * Then backslashing it won't do anything.
X				 */
X				curchr = regparse[0];
X			}
X			break;
X		}
X	}
X
X	return curchr;
X}
X
Xstatic void
Xskipchr()
X{
X	regparse++;
X	prevchr = curchr;
X	curchr = nextchr;		/* use previously unget char, or -1 */
X	nextchr = -1;
X}
X
Xstatic int
Xgetchr()
X{
X	int chr;
X
X	chr = peekchr();
X	skipchr();
X
X	return chr;
X}
X
X/*
X * put character back. Works only once!
X */
Xstatic void
Xungetchr()
X{
X	nextchr = curchr;
X	curchr = prevchr;
X	/*
X	 * Backup regparse as well; not because we will use what it points at,
X	 * but because skipchr() will bump it again.
X	 */
X	regparse--;
X}
X
X/*
X * regexec and friends
X */
X
X/*
X * Global work variables for regexec().
X */
Xstatic char    *reginput;		/* String-input pointer. */
Xstatic char    *regbol; 		/* Beginning of input, for ^ check. */
Xstatic char   **regstartp;		/* Pointer to startp array. */
X/* static char   **regendp;	*/	/* Ditto for endp. */
X
X/*
X * Forwards.
X */
Xstatic int		regtry __ARGS((regexp *, char *));
Xstatic int		regmatch __ARGS((char *));
Xstatic int		regrepeat __ARGS((char *));
X
X#ifdef DEBUG
Xint 			regnarrate = 1;
Xvoid			regdump __ARGS((regexp *));
Xstatic char    *regprop __ARGS((char *));
X#endif
X
X/*
X - regexec - match a regexp against a string
X */
Xint
Xregexec(prog, string, at_bol)
X	register regexp *prog;
X	register char  *string;
X	int 			at_bol;
X{
X	register char  *s;
X
X	/* Be paranoid... */
X	if (prog == NULL || string == NULL) {
X		emsg(e_null);
X		return 0;
X	}
X	/* Check validity of program. */
X	if (UCHARAT(prog->program) != MAGIC) {
X		emsg(e_re_corr);
X		return 0;
X	}
X	/* If there is a "must appear" string, look for it. */
X	if (prog->regmust != NULL) {
X		s = string;
X		while ((s = cstrchr(s, prog->regmust[0])) != NULL) {
X			if (cstrncmp(s, prog->regmust, prog->regmlen) == 0)
X				break;			/* Found it. */
X			s++;
X		}
X		if (s == NULL)			/* Not present. */
X			return 0;
X	}
X	/* Mark beginning of line for ^ . */
X	if (at_bol)
X		regbol = string;		/* is possible to match bol */
X	else
X		regbol = NULL;			/* we aren't there, so don't match it */
X
X	/* Simplest case:  anchored match need be tried only once. */
X	if (prog->reganch)
X		return regtry(prog, string);
X
X	/* Messy cases:  unanchored match. */
X	s = string;
X	if (prog->regstart != '\0')
X		/* We know what char it must start with. */
X		while ((s = cstrchr(s, prog->regstart)) != NULL) {
X			if (regtry(prog, s))
X				return 1;
X			s++;
X		}
X	else
X		/* We don't -- general case. */
X		do {
X			if (regtry(prog, s))
X				return 1;
X		} while (*s++ != '\0');
X
X	/* Failure. */
X	return 0;
X}
X
X/*
X - regtry - try match at specific point
X */
Xstatic int						/* 0 failure, 1 success */
Xregtry(prog, string)
X	regexp		   *prog;
X	char		   *string;
X{
X	register int	i;
X	register char **sp;
X	register char **ep;
X
X	reginput = string;
X	regstartp = prog->startp;
X	regendp = prog->endp;
X
X	sp = prog->startp;
X	ep = prog->endp;
X	for (i = NSUBEXP; i > 0; i--) {
X		*sp++ = NULL;
X		*ep++ = NULL;
X	}
X	if (regmatch(prog->program + 1)) {
X		prog->startp[0] = string;
X		prog->endp[0] = reginput;
X		return 1;
X	} else
X		return 0;
X}
X
X/*
X - regmatch - main matching routine
X *
X * Conceptually the strategy is simple:  check to see whether the current
X * node matches, call self recursively to see whether the rest matches,
X * and then act accordingly.  In practice we make some effort to avoid
X * recursion, in particular by going through "ordinary" nodes (that don't
X * need to know whether the rest of the match failed) by a loop instead of
X * by recursion.
X */
Xstatic int						/* 0 failure, 1 success */
Xregmatch(prog)
X	char		   *prog;
X{
X	register char  *scan;		/* Current node. */
X	char		   *next;		/* Next node. */
X
X	scan = prog;
X#ifdef DEBUG
X	if (scan != NULL && regnarrate)
X		fprintf(stderr, "%s(\n", regprop(scan));
X#endif
X	while (scan != NULL) {
X#ifdef DEBUG
X		if (regnarrate) {
X			fprintf(stderr, "%s...\n", regprop(scan));
X		}
X#endif
X		next = regnext(scan);
X		switch (OP(scan)) {
X		  case BOL:
X			if (reginput != regbol)
X				return 0;
X			break;
X		  case EOL:
X			if (*reginput != '\0')
X				return 0;
X			break;
X		  case BOW:		/* \<word; reginput points to w */
X#define isidchar(x)	(isalnum(x) || ((x) == '_'))
X		  	if (reginput != regbol && isidchar(reginput[-1]))
X				return 0;
X		  	if (!reginput[0] || !isidchar(reginput[0]))
X				return 0;
X			break;
X		  case EOW:		/* word\>; reginput points after d */
X		  	if (reginput == regbol || !isidchar(reginput[-1]))
X				return 0;
X		  	if (reginput[0] && isidchar(reginput[0]))
X				return 0;
X			break;
X		  case ANY:
X			if (*reginput == '\0')
X				return 0;
X			reginput++;
X			break;
X		  case EXACTLY:{
X				register int	len;
X				register char  *opnd;
X
X				opnd = OPERAND(scan);
X				/* Inline the first character, for speed. */
X				if (mkup(*opnd) != mkup(*reginput))
X					return 0;
X				len = strlen(opnd);
X				if (len > 1 && cstrncmp(opnd, reginput, len) != 0)
X					return 0;
X				reginput += len;
X			}
X			break;
X		  case ANYOF:
X			if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
X				return 0;
X			reginput++;
X			break;
X		  case ANYBUT:
X			if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
X				return 0;
X			reginput++;
X			break;
X		  case NOTHING:
X			break;
X		  case BACK:
X			break;
X		  case MOPEN + 1:
X		  case MOPEN + 2:
X		  case MOPEN + 3:
X		  case MOPEN + 4:
X		  case MOPEN + 5:
X		  case MOPEN + 6:
X		  case MOPEN + 7:
X		  case MOPEN + 8:
X		  case MOPEN + 9:{
X				register int	no;
X				register char  *save;
X
X				no = OP(scan) - MOPEN;
X				save = regstartp[no];
X				regstartp[no] = reginput; /* Tentatively */
X#ifdef DEBUG
X				printf("MOPEN  %d pre  @'%s' ('%s' )'%s'\n",
X					no, save,
X					regstartp[no]? regstartp[no] : "NULL",
X					regendp[no]? regendp[no] : "NULL");
X#endif
X
X				if (regmatch(next)) {
X#ifdef DEBUG
X				printf("MOPEN  %d post @'%s' ('%s' )'%s'\n",
X					no, save,
X					regstartp[no]? regstartp[no] : "NULL",
X					regendp[no]? regendp[no] : "NULL");
X#endif
X					return 1;
X				}
X				regstartp[no] = save;		/* We were wrong... */
X				return 0;
X			}
X			/* break; Not Reached */
X		  case MCLOSE + 1:
X		  case MCLOSE + 2:
X		  case MCLOSE + 3:
X		  case MCLOSE + 4:
X		  case MCLOSE + 5:
X		  case MCLOSE + 6:
X		  case MCLOSE + 7:
X		  case MCLOSE + 8:
X		  case MCLOSE + 9:{
X				register int	no;
X				register char  *save;
X
X				no = OP(scan) - MCLOSE;
X				save = regendp[no];
X				regendp[no] = reginput; /* Tentatively */
X#ifdef DEBUG
X				printf("MCLOSE %d pre  @'%s' ('%s' )'%s'\n",
X					no, save,
X					regstartp[no]? regstartp[no] : "NULL",
X					regendp[no]? regendp[no] : "NULL");
X#endif
X
X				if (regmatch(next)) {
X#ifdef DEBUG
X				printf("MCLOSE %d post @'%s' ('%s' )'%s'\n",
X					no, save,
X					regstartp[no]? regstartp[no] : "NULL",
X					regendp[no]? regendp[no] : "NULL");
X#endif
X					return 1;
X				}
X				regendp[no] = save;		/* We were wrong... */
X				return 0;
X			}
X			/* break; Not Reached */
X#ifdef BACKREF
X		  case BACKREF + 1:
X		  case BACKREF + 2:
X		  case BACKREF + 3:
X		  case BACKREF + 4:
X		  case BACKREF + 5:
X		  case BACKREF + 6:
X		  case BACKREF + 7:
X		  case BACKREF + 8:
X		  case BACKREF + 9:{
X				register int	no;
X				int				len;
X
X				no = OP(scan) - BACKREF;
X				if (regendp[no] != NULL) {
X					len = (int)(regendp[no] - regstartp[no]);
X					if (cstrncmp(regstartp[no], reginput, len) != 0)
X						return 0;
X					reginput += len;
X				} else {
X					/*emsg("backref to 0-repeat");*/
X					/*return 0;*/
X				}
X		  	}
X			break;
X#endif
X		  case BRANCH:{
X				register char  *save;
X
X				if (OP(next) != BRANCH) /* No choice. */
X					next = OPERAND(scan);		/* Avoid recursion. */
X				else {
X					do {
X						save = reginput;
X						if (regmatch(OPERAND(scan)))
X							return 1;
X						reginput = save;
X						scan = regnext(scan);
X					} while (scan != NULL && OP(scan) == BRANCH);
X					return 0;
X					/* NOTREACHED */
X				}
X			}
X			break;
X		  case STAR:
X		  case PLUS:{
X				register char	nextch;
X				register int	no;
X				register char  *save;
X				register int	min;
X
X				/*
X				 * Lookahead to avoid useless match attempts when we know
X				 * what character comes next.
X				 */
X				nextch = '\0';
X				if (OP(next) == EXACTLY)
X					nextch = mkup(*OPERAND(next));
X				min = (OP(scan) == STAR) ? 0 : 1;
X				save = reginput;
X				no = regrepeat(OPERAND(scan));
X				while (no >= min) {
X					/* If it could work, try it. */
X					if (nextch == '\0' || mkup(*reginput) == nextch)
X						if (regmatch(next))
X							return 1;
X					/* Couldn't or didn't -- back up. */
X					no--;
X					reginput = save + no;
X				}
X				return 0;
X			}
X			/* break; Not Reached */
X		  case END:
X			return 1; 		/* Success! */
X			/* break; Not Reached */
X		  default:
X			emsg(e_re_corr);
X			return 0;
X			/* break; Not Reached */
X		}
X
X		scan = next;
X	}
X
X	/*
X	 * We get here only if there's trouble -- normally "case END" is the
X	 * terminating point.
X	 */
X	emsg(e_re_corr);
X	return 0;
X}
X
X/*
X - regrepeat - repeatedly match something simple, report how many
X */
Xstatic int
Xregrepeat(p)
X	char		   *p;
X{
X	register int	count = 0;
X	register char  *scan;
X	register char  *opnd;
X
X	scan = reginput;
X	opnd = OPERAND(p);
X	switch (OP(p)) {
X	  case ANY:
X		count = strlen(scan);
X		scan += count;
X		break;
X	  case EXACTLY:
X		while (mkup(*opnd) == mkup(*scan)) {
X			count++;
X			scan++;
X		}
X		break;
X	  case ANYOF:
X		while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
X			count++;
X			scan++;
X		}
X		break;
X	  case ANYBUT:
X		while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
X			count++;
X			scan++;
X		}
X		break;
X	  default:					/* Oh dear.  Called inappropriately. */
X		emsg(e_re_corr);
X		count = 0;				/* Best compromise. */
X		break;
X	}
X	reginput = scan;
X
X	return count;
X}
X
X/*
X - regnext - dig the "next" pointer out of a node
X */
Xstatic char    *
Xregnext(p)
X	register char  *p;
X{
X	register int	offset;
X
X	if (p == &regdummy)
X		return NULL;
X
X	offset = NEXT(p);
X	if (offset == 0)
X		return NULL;
X
X	if (OP(p) == BACK)
X		return p - offset;
X	else
X		return p + offset;
X}
X
X#ifdef DEBUG
X
X/*
X - regdump - dump a regexp onto stdout in vaguely comprehensible form
X */
Xvoid
Xregdump(r)
X	regexp		   *r;
X{
X	register char  *s;
X	register char	op = EXACTLY;		/* Arbitrary non-END op. */
X	register char  *next;
X	/*extern char    *strchr();*/
X
X
X	s = r->program + 1;
X	while (op != END) { 		/* While that wasn't END last time... */
X		op = OP(s);
X		printf("%2d%s", s - r->program, regprop(s));	/* Where, what. */
X		next = regnext(s);
X		if (next == NULL)		/* Next ptr. */
X			printf("(0)");
X		else
X			printf("(%d)", (s - r->program) + (next - s));
X		s += 3;
X		if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
X			/* Literal string, where present. */
X			while (*s != '\0') {
X				putchar(*s);
X				s++;
X			}
X			s++;
X		}
X		putchar('\n');
X	}
X
X	/* Header fields of interest. */
X	if (r->regstart != '\0')
X		printf("start `%c' ", r->regstart);
X	if (r->reganch)
X		printf("anchored ");
X	if (r->regmust != NULL)
X		printf("must have \"%s\"", r->regmust);
X	printf("\n");
X}
X
X/*
X - regprop - printable representation of opcode
X */
Xstatic char    *
Xregprop(op)
X	char		   *op;
X{
X	register char  *p;
X	static char 	buf[50];
X
X	(void) strcpy(buf, ":");
X
X	switch (OP(op)) {
X	  case BOL:
X		p = "BOL";
X		break;
X	  case EOL:
X		p = "EOL";
X		break;
X	  case ANY:
X		p = "ANY";
X		break;
X	  case ANYOF:
X		p = "ANYOF";
X		break;
X	  case ANYBUT:
X		p = "ANYBUT";
X		break;
X	  case BRANCH:
X		p = "BRANCH";
X		break;
X	  case EXACTLY:
X		p = "EXACTLY";
X		break;
X	  case NOTHING:
X		p = "NOTHING";
X		break;
X	  case BACK:
X		p = "BACK";
X		break;
X	  case END:
X		p = "END";
X		break;
X	  case MOPEN + 1:
X	  case MOPEN + 2:
X	  case MOPEN + 3:
X	  case MOPEN + 4:
X	  case MOPEN + 5:
X	  case MOPEN + 6:
X	  case MOPEN + 7:
X	  case MOPEN + 8:
X	  case MOPEN + 9:
X		sprintf(buf + strlen(buf), "MOPEN%d", OP(op) - MOPEN);
X		p = NULL;
X		break;
X	  case MCLOSE + 1:
X	  case MCLOSE + 2:
X	  case MCLOSE + 3:
X	  case MCLOSE + 4:
X	  case MCLOSE + 5:
X	  case MCLOSE + 6:
X	  case MCLOSE + 7:
X	  case MCLOSE + 8:
X	  case MCLOSE + 9:
X		sprintf(buf + strlen(buf), "MCLOSE%d", OP(op) - MCLOSE);
X		p = NULL;
X		break;
X	  case BACKREF + 1:
X	  case BACKREF + 2:
X	  case BACKREF + 3:
X	  case BACKREF + 4:
X	  case BACKREF + 5:
X	  case BACKREF + 6:
X	  case BACKREF + 7:
X	  case BACKREF + 8:
X	  case BACKREF + 9:
X		sprintf(buf + strlen(buf), "BACKREF%d", OP(op) - BACKREF);
X		p = NULL;
X		break;
X	  case STAR:
X		p = "STAR";
X		break;
X	  case PLUS:
X		p = "PLUS";
X		break;
X	  default:
X		sprintf(buf + strlen(buf), "corrupt %d", OP(op));
X		p = NULL;
X		break;
X	}
X	if (p != NULL)
X		(void) strcat(buf, p);
X	return buf;
X}
X#endif
X
X/*
X * The following is provided for those people who do not have strcspn() in
X * their C libraries.  They should get off their butts and do something
X * about it; at least one public-domain implementation of those (highly
X * useful) string routines has been published on Usenet.
X */
X#ifdef STRCSPN
X/*
X * strcspn - find length of initial segment of s1 consisting entirely
X * of characters not from s2
X */
X
Xstatic int
Xstrcspn(s1, s2)
X	const char		   *s1;
X	const char		   *s2;
X{
X	register char  *scan1;
X	register char  *scan2;
X	register int	count;
X
X	count = 0;
X	for (scan1 = s1; *scan1 != '\0'; scan1++) {
X		for (scan2 = s2; *scan2 != '\0';)		/* ++ moved down. */
X			if (*scan1 == *scan2++)
X				return count;
X		count++;
X	}
X	return count;
X}
X#endif
X
X/*
X * Compare two strings, ignore case if reg_ic set.
X * Return 0 if strings match, non-zero otherwise.
X */
X	static int
Xcstrncmp(s1, s2, n)
X	char		   *s1, *s2;
X	int 			n;
X{
X	if (!reg_ic)
X		return strncmp(s1, s2, (size_t)n);
X
X#ifndef UNIX
X	return strnicmp(s1, s2, (size_t)n);
X#else
X# ifdef STRNCASECMP
X	return strncasecmp(s1, s2, (size_t)n);
X# else
X	while (n && *s1 && *s2)
X	{
X		if (mkup(*s1) != mkup(*s2))
X			return 1;
X		s1++;
X		s2++;
X		n--;
X	}
X	if (n)
X		return 1;
X	return 0;
X# endif	/* STRNCASECMP */
X#endif	/* UNIX */
X}
X
X	char *
Xcstrchr(s, c)
X	char		   *s;
X	int				c;
X{
X	char		   *p;
X
X	c = mkup(c);
X
X	for (p = s; *p; p++)
X	{
X		if (mkup(*p) == c)
X			return p;
X	}
X	return NULL;
X}
END_OF_FILE
if test 38964 -ne `wc -c <'vim/src/regexp.c'`; then
    echo shar: \"'vim/src/regexp.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/regexp.c'
# end of 'vim/src/regexp.c'
fi
echo shar: End of archive 19 \(of 25\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
