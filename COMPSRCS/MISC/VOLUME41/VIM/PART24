Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i074:  vim - Vi IMitation editor, v2.0, Part24/25
Message-ID: <1993Dec21.173057.2578@sparky.sterling.com>
X-Md4-Signature: 2a7a566b26a006a3e1f45ae20f46fa6f
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 17:30:57 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 74
Archive-name: vim/part24
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 24 (of 25)."
# Contents:  vim/src/arpbase.h
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:09 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/src/arpbase.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/arpbase.h'\"
else
echo shar: Extracting \"'vim/src/arpbase.h'\" \(49786 characters\)
sed "s/^X//" >'vim/src/arpbase.h' <<'END_OF_FILE'
X#ifndef	LIBRARIES_ARPBASE_H
X#define	LIBRARIES_ARPBASE_H 1
X
X/*
X ************************************************************************
X *									*
X * 5/3/89	ARPbase.h	by MKSoft from ARPbase.i by SDB		*
X *									*
X ************************************************************************
X *									*
X *	AmigaDOS Resource Project -- Library Include File		*
X *				     for Lattice C 5.x or Manx C 5.x	*
X *									*
X ************************************************************************
X *									*
X *	Copyright (c) 1987/1988/1989 by Scott Ballantyne		*
X *									*
X *	The arp.library, and related code and files may be freely used	*
X *	by supporters of ARP.  Modules in the arp.library may not be	*
X *	extracted for use in independent code, but you are welcome to	*
X *	provide the arp.library with your work and call on it freely.	*
X *									*
X *	You are equally welcome to add new functions, improve the ones	*
X *	within, or suggest additions.					*
X *									*
X *	BCPL programs are not welcome to call on the arp.library.	*
X *	The welcome mat is out to all others.				*
X *									*
X ************************************************************************
X *									*
X * N O T E !  You MUST! have IoErr() defined as LONG to use LastTracker *
X *	      If your compiler has other defines for this, you may wish *
X *	      to remove the prototype for IoErr() from this file.	*
X *									*
X ************************************************************************
X */
X
X/*
X ************************************************************************
X *	First we need to include the Amiga Standard Include files...	*
X ************************************************************************
X */
X#ifndef	EXEC_TYPES_H
X#include <exec/types.h>
X#endif	/* EXEC_TYPES_H */
X
X#ifndef	EXEC_LISTS_H
X#include <exec/lists.h>
X#endif	/* EXEC_LISTS_H */
X
X#ifndef	EXEC_ALERTS_H
X#include <exec/alerts.h>
X#endif	/* EXEC_ALERTS_H */
X
X#ifndef	EXEC_LIBRARIES_H
X#include <exec/libraries.h>
X#endif	/* EXEC_LIBRARIES_H */
X
X#ifndef	EXEC_SEMAPHORES_H
X#include <exec/semaphores.h>
X#endif	/* EXEC_SEMAPHORES_H */
X
X#ifndef	LIBRARIES_DOS_H
X#include <libraries/dosextens.h>
X#endif	/* LIBRARIES_DOS_H */
X
X/*
X ************************************************************************
X *	Check for MANX/Lattice and define the differences...		*
X ************************************************************************
X *	At the moment MANX 3.6 does not have prototypes or the		*
X *	wonderful #pragma statements of Lattice 5.0...			*
X *	And, no __stdargs in MANX either...				*
X ************************************************************************
X */
X#ifdef	AZTEC_C
X
X	/* Do we have an old 3.6a compiler? -olsen */
X
X#ifndef __VERSION
X#define __VERSION 360
X#endif	/* __VERSION */
X
X	/* If this is an old compiler, don't confuse it with
X	 * ANSI prototypes and pragmas. -olsen
X	 */
X
X#if __VERSION < 500
X#define	NO_PRAGMAS	1
X#define NO_PROTOTYPES	1
X#endif	/* __VERSION */
X
X#define	C_Args
X
X#endif	/* AZTEC_C */
X
X#ifdef	LATTICE
X
X#define	C_Args	__stdargs
X
X#endif	/* LATTICE */
X
X/*
X ************************************************************************
X *	Standard definitions for arp library information		*
X ************************************************************************
X */
X#define	ArpName		"arp.library"	/* Name of library... */
X#define	ArpVersion	39L		/* Current version... */
X
X/*
X ************************************************************************
X *	The current ARP library node...					*
X ************************************************************************
X */
Xstruct	ArpBase	{
X	struct	Library			LibNode;	 /* Standard library node		*/
X		APTR			DosRootNode;	 /* Copy of dl_Root			*/
X		UBYTE			Flags;		 /* See bitdefs below			*/
X		UBYTE			ESCChar; 	 /* Character to be used for escaping	*/
X		LONG			ArpReserved1;	 /* ArpLib's use only!!			*/
X	struct	Library			*EnvBase; 	 /* Dummy library for MANX compatibility*/
X	struct	Library			*DosBase; 	 /* Cached DosBase			*/
X	struct	Library			*GfxBase; 	 /* Cached GfxBase			*/
X	struct	Library			*IntuiBase;	 /* Cached IntuitionBase		*/
X	struct	MinList			ResLists;	 /* Resource trackers			*/
X	struct	ResidentProgramNode	*ResidentPrgList;/* Resident Programs.			*/
X	struct	SignalSemaphore		ResPrgProtection;/* protection for above		*/
X		BPTR			SegList; 	 /* Pointer to loaded libcode (a BPTR).	*/
X		};
X
X/*
X ************************************************************************
X *	The following is here *ONLY* for information and for		*
X *	compatibility with MANX.  DO NOT use in new code!		*
X ************************************************************************
X */
X#ifdef	ARP_PRIVATE
Xstruct EnvBase {
X	struct	Library	LibNode;	/* Standard library node for linkage	*/
X		BYTE	*EnvSpace;	/* Access only when Forbidden!		*/
X		ULONG	EnvSize;	/* Total allocated mem for EnvSpace	*/
X	struct	ArpBase	*ArpBase;	/* Added in V32 for Resource Tracking	*/
X		};
X#endif	/* ARP_PRIVATE */
X
X/*
X ************************************************************************
X *	These are used in release 33.4 but not by the library code.	*
X *	Instead, individual programs check for these flags.		*
X ************************************************************************
X */
X#define	ARPB_WILD_WORLD 0L		; Mixed BCPL/Normal wildcards.
X#define	ARPB_WILD_BCPL  1L		; Pure BCPL wildcards.
X
X#define	ARPF_WILD_WORLD (1L << ARPB_WILD_WORLD)
X#define	ARPF_WILD_BCPL  (1L << ARPB_WILD_BCPL)
X
X/*
X ************************************************************************
X * The alert object is what you use if you really must return an alert	*
X * to the user. You would normally OR this with another alert number	*
X * from the alerts.h file. Generally, should be NON deadend alerts.	*
X *									*
X * For example, if you can't open ArpLibrary:				*
X *	Alert( (AG_OpenLib|AO_ArpLib), 0L);				*
X ************************************************************************
X */
X#define	AO_ArpLib	0x00008036L		/* Alert object */
X
X/*
X ************************************************************************
X *	Alerts that arp.library may return...				*
X ************************************************************************
X */
X#define	AN_ArpLib	0x03600000L	/* Alert number				*/
X#define	AN_ArpNoMem	0x03610000L	/* No more memory			*/
X#define	AN_ArpInputMem	0x03610002L	/* No memory for input buffer		*/
X#define	AN_ArpNoMakeEnv	0x83610003L	/* No memory to make EnvLib		*/
X
X#define	AN_ArpNoDOS	0x83630001L	/* Can't open dos.library		*/
X#define	AN_ArpNoGfx	0x83630002L	/* Can't open graphics.library		*/
X#define	AN_ArpNoIntuit	0x83630003L	/* Can't open intuition			*/
X#define	AN_BadPackBlues	0x83640000L	/* Bad packet returned to SendPacket()	*/
X#define	AN_Zombie	0x83600003L	/* Zombie roaming around system		*/
X
X#define	AN_ArpScattered	0x83600002L	/* Scatter loading not allowed for arp	*/
X
X
X/*
X ************************************************************************
X *	Return codes you can get from calling ARP Assign()...		*
X ************************************************************************
X */
X#define	ASSIGN_OK	0L	/* Everything is cool and groovey			*/
X#define	ASSIGN_NODEV	1L	/* "Physical" is not valid for assignment		*/
X#define	ASSIGN_FATAL	2L	/* Something really icky happened			*/
X#define	ASSIGN_CANCEL	3L	/* Tried to cancel something but it won't cancel	*/
X
X/*
X ************************************************************************
X *	Size of buffer you need if you are going to call ReadLine()	*
X ************************************************************************
X */
X#define	MaxInputBuf	256L
X
X/*
X ************************************************************************
X *	The ARP file requester data structure...			*
X ************************************************************************
X */
X
X	/* This whole part has to be skipped if libraries/asl.h is
X	 * pulled in before arpbase.h is included (which is the recommended
X	 * sequence). -olsen
X	 */
X
X#ifndef LIBRARIES_ASL_H
X#define LIBRARIES_ASL_H 1	/* mool: don't use libraries/asl.h */
X
X	/* You know req.library? -olsen */
X
X#ifndef REQLIBRARY_H	
X
Xstruct FileRequester	{
X			BYTE	*fr_Hail;		/* Hailing text			*/
X			BYTE	*fr_File;		/* Filename array (FCHARS + 1)	*/
X			BYTE	*fr_Dir;		/* Directory array (DSIZE + 1)	*/
X		struct	Window	*fr_Window;		/* Window requesting or NULL	*/
X			UBYTE	fr_FuncFlags;		/* Set bitdef's below		*/
X			UBYTE	fr_Flags2;		/* New flags...			*/
X			VOID	(*fr_Function)();	/* Your function, see bitdef's	*/
X			WORD	fr_LeftEdge;		/* To be used later...		*/
X			WORD	fr_TopEdge;
X			};
X
X#endif	/* REQLIBRARY_H */
X
X/*
X ************************************************************************
X * The following are the defines for fr_FuncFlags.  These bits tell	*
X * FileRequest() what your fr_UserFunc is expecting, and what		*
X * FileRequest() should call it for.					*
X *									*
X * You are called like so:						*
X * fr_Function(Mask, Object)						*
X * ULONG	Mask;							*
X * CPTR		*Object;						*
X *									*
X * The Mask is a copy of the flag value that caused FileRequest() to	*
X * call your function. You can use this to determine what action you	*
X * need to perform, and exactly what Object is, so you know what to do	*
X * and what to return.							*
X ************************************************************************
X */
X#define	FRB_DoWildFunc	7L /* Call me with a FIB and a name, ZERO return accepts.	*/
X#define	FRB_DoMsgFunc	6L /* You get all IDCMP messages not for FileRequest()		*/
X#define	FRB_DoColor	5L /* Set this bit for that new and different look		*/
X#define	FRB_NewIDCMP	4L /* Force a new IDCMP (only if fr_Window != NULL)		*/
X#define	FRB_NewWindFunc	3L /* You get to modify the newwindow structure.		*/
X#define	FRB_AddGadFunc	2L /* You get to add gadgets.					*/
X#define	FRB_GEventFunc	1L /* Function to call if one of your gadgets is selected.	*/
X#define	FRB_ListFunc	0L /* Not implemented yet.					*/
X
X#define	FRF_DoWildFunc	(1L << FRB_DoWildFunc)
X#define	FRF_DoMsgFunc	(1L << FRB_DoMsgFunc)
X#define	FRF_DoColor	(1L << FRB_DoColor)
X#define	FRF_NewIDCMP	(1L << FRB_NewIDCMP)
X#define	FRF_NewWindFunc	(1L << FRB_NewWindFunc)
X#define	FRF_AddGadFunc	(1L << FRB_AddGadFunc)
X#define	FRF_GEventFunc	(1L << FRB_GEventFunc)
X#define	FRF_ListFunc	(1L << FRB_ListFunc)
X
X/*
X ************************************************************************
X * The FR2B_ bits are for fr_Flags2 in the file requester structure	*
X ************************************************************************
X */
X#define	FR2B_LongPath	0L /* Specify the fr_Dir buffer is 256 bytes long */
X
X#define	FR2F_LongPath	(1L << FR2B_LongPath)
X
X/*
X ************************************************************************
X *	The sizes of the different buffers...				*
X ************************************************************************
X */
X#define	FCHARS		32L	/* Filename size				*/
X#define	DSIZE		33L	/* Directory name size if not FR2B_LongPath	*/
X
X#define	LONG_DSIZE	254L	/* If FR2B_LongPath is set, use LONG_DSIZE	*/
X#define	LONG_FSIZE	126L	/* For compatibility with ARPbase.i		*/
X
X#define	FR_FIRST_GADGET	0x7680L	/* User gadgetID's must be less than this value	*/
X
X#endif	/* LIBRARIES_ASL_H */
X
X#ifndef DOS_DOSASL_H		/* mool: either this or dos/dosasl.h */
X#define DOS_DOSASL_H
X/*
X ************************************************************************
X * Structure expected by FindFirst()/FindNext()				*
X *									*
X * You need to allocate this structure and initialize it as follows:	*
X *									*
X * Set ap_BreakBits to the signal bits (CDEF) that you want to take a	*
X * break on, or NULL, if you don't want to convenience the user.	*
X *									*
X * if you want to have the FULL PATH NAME of the files you found,	*
X * allocate a buffer at the END of this structure, and put the size of	*
X * it into ap_StrLen.  If you don't want the full path name, make sure	*
X * you set ap_StrLen to zero.  In this case, the name of the file, and	*
X * stats are available in the ap_Info, as per usual.			*
X *									*
X * Then call FindFirst() and then afterwards, FindNext() with this	*
X * structure.  You should check the return value each time (see below)	*
X * and take the appropriate action, ultimately calling			*
X * FreeAnchorChain() when there are no more files and you are done.	*
X * You can tell when you are done by checking for the normal AmigaDOS	*
X * return code ERROR_NO_MORE_ENTRIES.					*
X *									*
X * You will also have to check the DirEntryType variable in the ap_Info	*
X * structure to determine what exactly you have received.		*
X ************************************************************************
X */
Xstruct	AnchorPath	{
X		struct	AChain		*ap_Base;	/* Pointer to first anchor			*/
X		struct	AChain		*ap_Last;	/* Pointer to last anchor			*/
X			LONG		ap_BreakBits;	/* Bits to break on				*/
X			LONG		ap_FoundBreak;	/* Bits we broke on. Also returns ERROR_BREAK	*/
X			BYTE		ap_Flags;	/* New use for the extra word...		*/
X			BYTE		ap_Reserved;	/* To fill it out...				*/
X			WORD		ap_StrLen;	/* This is what used to be ap_Length		*/
X		struct	FileInfoBlock	ap_Info;
X			BYTE		ap_Buf[1];	/* Allocate a buffer here, if desired		*/
X			};
X
X#define ap_Length ap_StrLen
X
X/*
X ************************************************************************
X *	Bit definitions for the new ap_Flags...				*
X ************************************************************************
X */
X#define	APB_DoWild	0L	/* User option ALL				*/
X#define	APB_ItsWild	1L	/* Set by FindFirst, used by FindNext		*/
X#define	APB_DoDir	2L	/* Bit is SET if a DIR node should be entered	*/
X				/* Application can RESET this bit to AVOID	*/
X				/* entering a dir.				*/
X#define	APB_DidDir	3L	/* Bit is set for an "expired" dir node		*/
X#define	APB_NoMemErr	4L	/* Set if there was not enough memory		*/
X#define	APB_DoDot	5L	/* If set, '.' (DOT) will convert to CurrentDir	*/
X
X#define	APF_DoWild	(1L << APB_DoWild)
X#define	APF_ItsWild	(1L << APB_ItsWild)
X#define	APF_DoDir	(1L << APB_DoDir)
X#define	APF_DidDir	(1L << APB_DidDir)
X#define	APF_NoMemErr	(1L << APB_NoMemErr)
X#define	APF_DoDot	(1L << APB_DoDot)
X
X/*
X ************************************************************************
X * Structure used by the pattern matching functions, no need to obtain,	*
X * diddle or allocate this yourself.					*
X *									*
X * Note:  If you did, you will now break as it has changed...		*
X ************************************************************************
X */
X#ifdef	ARP_PRIVATE
Xstruct	AChain	{
X	struct	AChain		*an_Child;
X	struct	AChain		*an_Parent;
X	struct	FileLock	*an_Lock;
X	struct	FileInfoBlock	*an_Info;
X		BYTE		an_Flags;
X		char		an_String[1];	/* Just as is .i file	*/
X		};				/* ???  Don't use this!	*/
X#endif	/* ARP_PRIVATE */
X
X#define	DDB_PatternBit	0L
X#define	DDB_ExaminedBit	1L
X#define	DDB_Completed	2L
X#define	DDB_AllBit	3L
X
X#define	DDF_PatternBit	(1L << DDB_PatternBit)
X#define	DDF_ExaminedBit	(1L << DDB_ExaminedBit)
X#define	DDF_Completed	(1L << DDB_Completed)
X#define	DDF_AllBit	(1L << DDB_AllBit)
X
X/*
X ************************************************************************
X * This structure takes a pointer, and returns FALSE if wildcard was	*
X * not found by FindFirst()						*
X ************************************************************************
X */
X#define	IsWild( ptr )		( *((LONG *)(ptr)) )
X
X/*
X ************************************************************************
X * Constants used by wildcard routines					*
X *									*
X * These are the pre-parsed tokens referred to by pattern match.  It	*
X * is not necessary for you to do anything about these, FindFirst()	*
X * FindNext() handle all these for you.					*
X ************************************************************************
X */
X#define	P_ANY		0x80L	/* Token for '*' | '#?'	*/
X#define	P_SINGLE	0x81L	/* Token for '?'	*/
X
X/*
X ************************************************************************
X * No need to muck with these as they may change...			*
X ************************************************************************
X */
X#ifdef	ARP_PRIVATE
X#define	P_ORSTART	0x82L	/* Token for '('	*/
X#define	P_ORNEXT	0x83L	/* Token for '|'	*/
X#define	P_OREND		0x84L	/* Token for ')'	*/
X#define	P_NOT		0x85L	/* Token for '~'	*/
X#define	P_NOTCLASS	0x87L	/* Token for '^'	*/
X#define	P_CLASS		0x88L	/* Token for '[]'	*/
X#define	P_REPBEG	0x89L	/* Token for '['	*/
X#define	P_REPEND	0x8AL	/* Token for ']'	*/
X#endif	/* ARP_PRIVATE */
X
X#define	ERROR_BUFFER_OVERFLOW	303L	/* User or internal buffer overflow	*/
X#define	ERROR_BREAK		304L	/* A break character was received	*/
X#define	ERROR_NOT_EXECUTABLE	305L	/* A file has E bit cleared		*/
X	/* dos/dosasl.h uses a good lot of the symbols and structures
X	 * defined here (AnchorPatch, AChain, ERROR_BREAK and the
X	 * like), so let's don't include it again.
X	 */
X
X/* #define DOS_DOSASL_H 1 */
X#endif	/* added by mool */
X
X/*
X ************************************************************************
X * Structure used by AddDANode(), AddDADevs(), FreeDAList().		*
X *									*
X * This structure is used to create lists of names, which normally	*
X * are devices, assigns, volumes, files, or directories.		*
X ************************************************************************
X */
Xstruct	DirectoryEntry	{
X		struct	DirectoryEntry	*de_Next;	/* Next in list				*/
X			BYTE		de_Type;	/* DLX_mumble				*/
X			BYTE		de_Flags;	/* For future expansion, DO NOT USE!	*/
X			BYTE		de_Name[1];	/* The name of the thing found		*/
X			};
X
X/*
X ************************************************************************
X * Defines you use to get a list of the devices you want to look at.	*
X * For example, to get a list of all directories and volumes, do:	*
X *									*
X *	AddDADevs( mydalist, (DLF_DIRS | DLF_VOLUMES) )			*
X *									*
X * After this, you can examine the de_type field of the elements added	*
X * to your list (if any) to discover specifics about the objects added.	*
X *									*
X * Note that if you want only devices which are also disks, you must	*
X * (DLF_DEVICES | DLF_DISKONLY).					*
X ************************************************************************
X */
X#define	DLB_DEVICES	0L	/* Return devices				*/
X#define	DLB_DISKONLY	1L	/* Modifier for above: Return disk devices only	*/
X#define	DLB_VOLUMES	2L	/* Return volumes only				*/
X#define	DLB_DIRS	3L	/* Return assigned devices only			*/
X
X#define	DLF_DEVICES	(1L << DLB_DEVICES)
X#define	DLF_DISKONLY	(1L << DLB_DISKONLY)
X#define	DLF_VOLUMES	(1L << DLB_VOLUMES)
X#define	DLF_DIRS	(1L << DLB_DIRS)
X
X/*
X ************************************************************************
X * Legal de_Type values, check for these after a call to AddDADevs(),	*
X * or use on your own as the ID values in AddDANode().			*
X ************************************************************************
X */
X#define	DLX_FILE	0L	/* AddDADevs() can't determine this	*/
X#define	DLX_DIR		8L	/* AddDADevs() can't determine this	*/
X#define	DLX_DEVICE	16L	/* It's a resident device		*/
X
X#define	DLX_VOLUME	24L	/* Device is a volume			*/
X#define	DLX_UNMOUNTED	32L	/* Device is not resident		*/
X
X#define	DLX_ASSIGN	40L	/* Device is a logical assignment	*/
X
X/*
X ************************************************************************
X *	This macro is to check for an error return from the Atol()	*
X *	routine.  If Errno is ERRBADINT, then there was an error...	*
X *	This was done to try to remain as close to source compatible	*
X *	as possible with the older (rel 1.1) ARPbase.h			*
X ************************************************************************
X */
X#define	ERRBADINT	1L
X#define	Errno		(IoErr() ? ERRBADINT : 0)
X
X/*
X ************************************************************************
X *	Resource Tracking stuff...					*
X ************************************************************************
X *									*
X * There are a few things in arp.library that are only directly		*
X * acessable from assembler.  The glue routines provided by us for	*
X * all 'C' compilers use the following conventions to make these	*
X * available to C programs.  The glue for other language's should use	*
X * as similar a mechanism as possible, so that no matter what language	*
X * or compiler we speak, when talk about arp, we will know what the	*
X * other guy is saying.							*
X *									*
X * Here are the cases:							*
X *									*
X * Tracker calls...							*
X *		These calls return the Tracker pointer as a secondary	*
X *		result in the register A1.  For C, there is no clean	*
X *		way to return more than one result so the tracker	*
X *		pointer is returned in IoErr().  For ease of use,	*
X *		there is a define that typecasts IoErr() to the correct	*
X *		pointer type.  This is called LastTracker and should	*
X *		be source compatible with the earlier method of storing	*
X *		the secondary result.					*
X *									*
X * GetTracker() -							*
X *		Syntax is a bit different for C than the assembly call	*
X *		The C syntax is GetTracker(ID).  The binding routines	*
X *		will store the ID into the tracker on return.  Also,	*
X *		in an effort to remain consistant, the tracker will	*
X *		also be stored in LastTracker.				*
X *									*
X * In cases where you have allocated a tracker before you have obtained	*
X * a resource (usually the most efficient method), and the resource has	*
X * not been obtained, you will need to clear the tracker id.  The macro	*
X * CLEAR_ID() has been provided for that purpose.  It expects a pointer	*
X * to a DefaultTracker sort of struct.					*
X ************************************************************************
X */
X#define	CLEAR_ID(t)	((SHORT *) t)[-1]=NULL
X
X/*
X ************************************************************************
X * You MUST prototype IoErr() to prevent the possible error in defining	*
X * IoErr() and thus causing LastTracker to give you trash...		*
X *									*
X * N O T E !  You MUST! have IoErr() defined as LONG to use LastTracker *
X *	      If your compiler has other defines for this, you may wish *
X *	      to remove the prototype for IoErr().			*
X ************************************************************************
X */
X#define	LastTracker	((struct DefaultTracker *)IoErr())
X
X/*
X ************************************************************************
X * The rl_FirstItem list (ResList) is a list of TrackedResource (below)	*
X * It is very important that nothing in this list depend on the task	*
X * existing at resource freeing time (i.e., RemTask(0L) type stuff,	*
X * DeletePort() and the rest).						*
X *									*
X * The tracking functions return a struct Tracker *Tracker to you, this	*
X * is a pointer to whatever follows the tr_ID variable.			*
X * The default case is reflected below, and you get it if you call	*
X * GetTracker() ( see DefaultTracker below).				*
X *									*
X * NOTE: The two user variables mentioned in an earlier version don't	*
X * exist, and never did. Sorry about that (SDB).			*
X *									*
X * However, you can still use ArpAlloc() to allocate your own tracking	*
X * nodes and they can be any size or shape you like, as long as the	*
X * base structure is preserved. They will be freed automagically just	*
X * like the default trackers.						*
X ************************************************************************
X */
Xstruct	TrackedResource	{
X		struct	MinNode	tr_Node;	/* Double linked pointer		*/
X			BYTE	tr_Flags;	/* Don't touch				*/
X			BYTE	tr_Lock;	/* Don't touch, for Get/FreeAccess()	*/
X			SHORT	tr_ID;		/* Item's ID				*/
X
X/*
X ************************************************************************
X * The struct DefaultTracker *Tracker portion of the structure.		*
X * The stuff below this point can conceivably vary, depending		*
X * on user needs, etc.  This reflects the default.			*
X ************************************************************************
X */
X			union	{
X				CPTR	tr_Resource;	/* Whatever				*/
X        			LONG	tg_Verify;	/* For use during TRAK_GENERIC		*/
X				}	tr_Object;	/* The thing being tracked		*/
X			union	{
X				VOID	(*tg_Function)();/* Function to call for TRAK_GENERIC	*/
X			struct	Window	*tr_Window2;	/* For TRAK_WINDOW			*/
X				}	tr_Extra;	/* Only needed sometimes		*/
X			};
X
X#define	tg_Value tg_Verify	/* Ancient compatibility only!  Do NOT use in new CODE!!! */
X
X/*
X ************************************************************************
X * You get a pointer to a struct of the following type when you call	*
X * GetTracker().  You can change this, and use ArpAlloc() instead of	*
X * GetTracker() to do tracking. Of course, you have to take a wee bit	*
X * more responsibility if you do, as well as if you use TRAK_GENERIC	*
X * stuff.								*
X *									*
X * TRAK_GENERIC folks need to set up a task function to be called when	*
X * an item is freed.  Some care is required to set this up properly.	*
X *									*
X * Some special cases are indicated by the unions below, for		*
X * TRAK_WINDOW, if you have more than one window opened, and don't	*
X * want the IDCMP closed particularly, you need to set a ptr to the	*
X * other window in dt_Window2.  See CloseWindowSafely() for more info.	*
X * If only one window, set this to NULL.				*
X ************************************************************************
X */
Xstruct	DefaultTracker	{
X			union	{
X				CPTR	dt_Resource;	/* Whatever				*/
X				LONG	tg_Verify;	/* For use during TRAK_GENERIC		*/
X				}	dt_Object;	/* The object being tracked		*/
X			union	{
X				VOID	(*tg_Function)();/* Function to call for TRAK_GENERIC	*/
X			struct	Window	*dt_Window2;	/* For TRAK_WINDOW			*/
X				}	dt_Extra;
X			};
X
X/*
X ************************************************************************
X *	Items the tracker knows what to do about			*
X ************************************************************************
X */
X#define	TRAK_AAMEM	0L	/* Default (ArpAlloc) element		*/
X#define	TRAK_LOCK	1L	/* File lock				*/
X#define	TRAK_FILE	2L	/* Opened file				*/
X#define	TRAK_WINDOW	3L	/* Window -- see docs			*/
X#define	TRAK_SCREEN	4L	/* Screen				*/
X#define	TRAK_LIBRARY	5L	/* Opened library			*/
X#define	TRAK_DAMEM	6L	/* Pointer to DosAllocMem block		*/
X#define	TRAK_MEMNODE	7L	/* AllocEntry() node			*/
X#define	TRAK_SEGLIST	8L	/* Program segment			*/
X#define	TRAK_RESLIST	9L	/* ARP (nested) ResList			*/
X#define	TRAK_MEM	10L	/* Memory ptr/length			*/
X#define	TRAK_GENERIC	11L	/* Generic Element, your choice		*/
X#define	TRAK_DALIST	12L	/* DAlist ( aka file request )		*/
X#define	TRAK_ANCHOR	13L	/* Anchor chain (pattern matching)	*/
X#define	TRAK_FREQ	14L	/* FileRequest struct			*/
X#define	TRAK_FONT	15L	/* GfxBase CloseFont()			*/
X#define	TRAK_MAX	15L	/* Poof, anything higher is tossed	*/
X
X#define	TRB_UNLINK	7L	/* Free node bit			*/
X#define	TRB_RELOC	6L	/* This may be relocated (not used yet)	*/
X#define	TRB_MOVED	5L	/* Item moved				*/
X
X#define	TRF_UNLINK	(1L << TRB_UNLINK)
X#define	TRF_RELOC	(1L << TRB_RELOC)
X#define	TRF_MOVED	(1L << TRB_MOVED)
X
X/*
X ************************************************************************
X * Note: ResList MUST be a DosAllocMem'ed list!, this is done for	*
X * you when you call CreateTaskResList(), typically, you won't need	*
X * to access/allocate this structure.					*
X ************************************************************************
X */
Xstruct	ResList	{
X	struct	MinNode		rl_Node;	/* Used by arplib to link reslists	*/
X	struct	Task		*rl_TaskID;	/* Owner of this list			*/
X	struct	MinList		rl_FirstItem;	/* List of Tracked Resources		*/
X	struct	ResList		*rl_Link;	/* SyncRun's use - hide list here	*/
X		};
X
X/*
X ************************************************************************
X *	Returns from CompareLock()					*
X ************************************************************************
X */
X#define	LCK_EQUAL	0L	/* The two locks refer to the same object	*/
X#define	LCK_VOLUME	1L	/* Locks are on the same volume			*/
X#define	LCK_DIFVOL1	2L	/* Locks are on different volumes		*/
X#define	LCK_DIFVOL2	3L	/* Locks are on different volumes		*/
X
X/*
X ************************************************************************
X *	ASyncRun() stuff...						*
X ************************************************************************
X * Message sent back on your request by an exiting process.		*
X * You request this by putting the address of your message in		*
X * pcb_LastGasp, and initializing the ReplyPort variable of your	*
X * ZombieMsg to the port you wish the message posted to.		*
X ************************************************************************
X */
Xstruct	ZombieMsg	{
X		struct	Message		zm_ExecMessage;
X			ULONG		zm_TaskNum;	/* Task ID			*/
X			LONG		zm_ReturnCode;	/* Process's return code	*/
X			ULONG		zm_Result2;	/* System return code		*/
X		struct	DateStamp	zm_ExitTime;	/* Date stamp at time of exit	*/
X			ULONG		zm_UserInfo;	/* For whatever you wish	*/
X			};
X
X/*
X ************************************************************************
X * Structure required by ASyncRun() -- see docs for more info.		*
X ************************************************************************
X */
Xstruct	ProcessControlBlock	{
X				ULONG		pcb_StackSize;	/* Stacksize for new process			*/
X				BYTE		pcb_Pri;	/* Priority of new task				*/
X				UBYTE		pcb_Control;	/* Control bits, see defines below		*/
X				APTR		pcb_TrapCode;	/* Optional Trap Code				*/
X				BPTR		pcb_Input;
X				BPTR		pcb_Output;	/* Optional stdin, stdout			*/
X				union	{
X					BPTR	pcb_SplatFile;	/* File to use for Open("*")			*/
X					BYTE	*pcb_ConName;	/* CON: filename				*/
X					}	pcb_Console;
X				CPTR		pcb_LoadedCode;	/* If not null, will not load/unload code	*/
X			struct	ZombieMsg	*pcb_LastGasp;	/* ReplyMsg() to be filled in by exit		*/
X			struct	MsgPort		*pcb_WBProcess;	/* Valid only when PRB_NOCLI			*/
X				};
X
X/*
X ************************************************************************
X * Formerly needed to pass NULLCMD to a child.  No longer needed.	*
X * It is being kept here for compatibility only...			*
X ************************************************************************
X */
X#define	NOCMD	"\n"
X
X/*
X ************************************************************************
X * The following control bits determine what ASyncRun() does on		*
X * Abnormal Exits and on background process termination.		*
X ************************************************************************
X */
X#define	PRB_SAVEIO	0L	/* Don't free/check file handles on exit	*/
X#define	PRB_CLOSESPLAT	1L	/* Close Splat file, must request explicitly	*/
X#define	PRB_NOCLI	2L	/* Don't create a CLI process			*/
X/*	PRB_INTERACTIVE	3L	   This is now obsolete...			*/
X#define	PRB_CODE	4L	/* Dangerous yet enticing			*/
X#define	PRB_STDIO	5L	/* Do the stdio thing, splat = CON:Filename 	*/
X
X#define	PRF_SAVEIO	(1L << PRB_SAVEIO)
X#define	PRF_CLOSESPLAT	(1L << PRB_CLOSESPLAT)
X#define	PRF_NOCLI	(1L << PRB_NOCLI)
X#define	PRF_CODE	(1L << PRB_CODE)
X#define	PRF_STDIO	(1L << PRB_STDIO)
X
X/*
X ************************************************************************
X *	Error returns from SyncRun() and ASyncRun()			*
X ************************************************************************
X */
X#define	PR_NOFILE	-1L	/* Could not LoadSeg() the file			*/
X#define	PR_NOMEM	-2L	/* No memory for something			*/
X/*	PR_NOCLI	-3L	   This is now obsolete				*/
X#define	PR_NOSLOT	-4L	/* No room in TaskArray				*/
X#define	PR_NOINPUT	-5L	/* Could not open input file			*/
X#define	PR_NOOUTPUT	-6L	/* Could not get output file			*/
X/*	PR_NOLOCK	-7L	   This is now obsolete				*/
X/*	PR_ARGERR	-8L	   This is now obsolete				*/
X/*	PR_NOBCPL	-9L	   This is now obsolete				*/
X/*	PR_BADLIB	-10L	   This is now obsolete				*/
X#define	PR_NOSTDIO	-11L	/* Couldn't get stdio handles			*/
X
X/*
X ************************************************************************
X *	Added V35 of arp.library					*
X ************************************************************************
X */
X#define	PR_WANTSMESSAGE	-12L	/* Child wants you to report IoErr() to user	*/
X				/* for SyncRun() only...			*/
X#define	PR_NOSHELLPROC	-13L	/* Can't create a shell/cli process		*/
X#define	PR_NOEXEC	-14L	/* 'E' bit is clear				*/
X#define	PR_SCRIPT	-15L	/* S and E are set, IoErr() contains directory	*/
X
X/*
X ************************************************************************
X * Version 35 ASyncRun() allows you to create an independent		*
X * interactive or background Shell/CLI. You need this variant of the	*
X * pcb structure to do it, and you also have new values for nsh_Control,*
X * see below.								*
X *									*
X * Syntax for Interactive shell is:					*
X *									*
X * rc=ASyncRun("Optional Window Name","Optional From File",&NewShell);	*
X *									*
X * Syntax for a background shell is:					*
X *									*
X * rc=ASyncRun("Command line",0L,&NewShell);				*
X *									*
X * Same syntax for an Execute style call, but you have to be on drugs	*
X * if you want to do that.						*
X ************************************************************************
X */
Xstruct	NewShell	{
X			ULONG	nsh_StackSize;	/* stacksize shell will use for children	*/
X			BYTE	nsh_Pri;	/* ignored by interactive shells		*/
X			UBYTE	nsh_Control;	/* bits/values: see above			*/
X			CPTR	nsh_LogMsg;	/* Optional login message, if null, use default	*/
X			BPTR	nsh_Input;	/* ignored by interactive shells, but		*/
X			BPTR	nsh_Output;	/* used by background and execute options.	*/
X			LONG	nsh_RESERVED[5];
X			};
X
X/*
X ************************************************************************
X * Bit Values for nsh_Control, you should use them as shown below, or	*
X * just use the actual values indicated.				*
X ************************************************************************
X */
X#define	PRB_CLI		0L	/* Do a CLI, not a shell	*/
X#define	PRB_BACKGROUND	1L	/* Background shell		*/
X#define	PRB_EXECUTE	2L	/* Do as EXECUTE...		*/
X#define	PRB_INTERACTIVE	3L	/* Run an interactive shell	*/
X#define	PRB_FB		7L	/* Alt function bit...		*/
X
X#define	PRF_CLI		(1L << PRB_CLI)
X#define	PRF_BACKGOUND	(1L << PRB_BACKGROUND)
X#define	PRF_EXECUTE	(1L << PRB_EXECUTE)
X#define	PRF_INTERACTIVE	(1L << PRB_INTERACTIVE)
X#define	PRF_FB		(1L << PRB_FB)
X
X/*
X ************************************************************************
X *	Common values for sh_Control which allow you to do usefull	*
X *	and somewhat "standard" things...				*
X ************************************************************************
X */
X#define	INTERACTIVE_SHELL	(PRF_FB|PRF_INTERACTIVE)		/* Gimme a newshell!		*/
X#define	INTERACTIVE_CLI		(PRF_FB|PRF_INTERACTIVE|PRF_CLI)	/* Gimme that ol newcli!	*/
X#define	BACKGROUND_SHELL	(PRF_FB|PRF_BACKGROUND)			/* gimme a background shell	*/
X#define	EXECUTE_ME		(PRF_FB|PRF_BACKGROUND|PRF_EXECUTE)	/* aptly named, doncha think?	*/
X
X/*
X ************************************************************************
X *	Additional IoErr() returns added by ARP...			*
X ************************************************************************
X */
X#define	ERROR_NOT_CLI		400L	/* Program/function neeeds to be cli	*/
X
X/*
X ************************************************************************
X *	Resident Program Support					*
X ************************************************************************
X * This is the kind of node allocated for you when you AddResidentPrg()	*
X * a code segment.  They are stored as a single linked list with the	*
X * root in ArpBase.  If you absolutely *must* wander through this list	*
X * instead of using the supplied functions, then you must first obtain	*
X * the semaphore which protects this list, and then release it		*
X * afterwards.  Do not use Forbid() and Permit() to gain exclusive	*
X * access!  Note that the supplied functions handle this locking	*
X * protocol for you.							*
X ************************************************************************
X */
Xstruct	ResidentProgramNode	{
X			struct	ResidentProgramNode	*rpn_Next;	/* next or NULL			*/
X				LONG			rpn_Usage;	/* Number of current users	*/
X				UWORD			rpn_AccessCnt;	/* Total times used...		*/
X				ULONG			rpn_CheckSum;	/* Checksum of code		*/
X				BPTR			rpn_Segment;	/* Actual segment		*/
X				UWORD			rpn_Flags;	/* See definitions below...	*/
X				BYTE			rpn_Name[1];	/* Allocated as needed		*/
X				};
X
X/*
X ************************************************************************
X *	Bit definitions for rpn_Flags....				*
X ************************************************************************
X */
X#define	RPNB_NOCHECK	0L	/* Set in rpn_Flags for no checksumming...	*/
X#define	RPNB_CACHE	1L	/* Private usage in v1.3...			*/
X
X#define	RPNF_NOCHECK	(1L << RPNB_NOCHECK)
X#define	RPNF_CACHE	(1L << RPNB_CACHE)
X
X/*
X ************************************************************************
X * If your program starts with this structure, ASyncRun() and SyncRun()	*
X * will override a users stack request with the value in rpt_StackSize.	*
X * Furthermore, if you are actually attached to the resident list, a	*
X * memory block of size rpt_DataSize will be allocated for you, and	*
X * a pointer to this data passed to you in register A4.  You may use	*
X * this block to clone the data segment of programs, thus resulting in	*
X * one copy of text, but multiple copies of data/bss for each process	*
X * invocation.  If you are resident, your program will start at		*
X * rpt_Instruction, otherwise, it will be launched from the initial	*
X * branch.								*
X ************************************************************************
X */
Xstruct	ResidentProgramTag	{
X				BPTR	rpt_NextSeg;	/* Provided by DOS at LoadSeg time	*/
X/*
X ************************************************************************
X * The initial branch destination and rpt_Instruction do not have to be	*
X * the same.  This allows different actions to be taken if you are	*
X * diskloaded or resident.  DataSize memory will be allocated only if	*
X * you are resident, but StackSize will override all user stack		*
X * requests.								*
X ************************************************************************
X */
X				UWORD	rpt_BRA;	/* Short branch to executable		*/
X				UWORD	rpt_Magic;	/* Resident majik value			*/
X				ULONG	rpt_StackSize;	/* min stack for this process		*/
X				ULONG	rpt_DataSize;	/* Data size to allocate if resident	*/
X				/*	rpt_Instruction;	Start here if resident		*/
X				};
X
X/*
X ************************************************************************
X * The form of the ARP allocated node in your tasks memlist when	*
X * launched as a resident program. Note that the data portion of the	*
X * node will only exist if you have specified a nonzero value for	*
X * rpt_DataSize. Note also that this structure is READ ONLY, modify	*
X * values in this at your own risk.  The stack stuff is for tracking,	*
X * if you need actual addresses or stack size, check the normal places	*
X * for it in your process/task struct.					*
X ************************************************************************
X */
Xstruct	ProcessMemory	{
X		struct	Node	pm_Node;
X			UWORD	pm_Num;		/* This is 1 if no data, two if data	*/
X			CPTR	pm_Stack;
X			ULONG	pm_StackSize;
X			CPTR	pm_Data;	/* Only here if pm_Num == 2		*/
X			ULONG	pm_DataSize;
X			};
X
X/*
X ************************************************************************
X * To find the above on your memlist, search for the following name.	*
X * We guarantee this will be the only arp.library allocated node on	*
X * your memlist with this name.						*
X * i.e. FindName(task->tcb_MemEntry, PMEM_NAME);			*
X ************************************************************************
X */
X#define	PMEM_NAME	"ARP_MEM"
X
X#define	RESIDENT_MAGIC	0x4AFC		/* same as RTC_MATCHWORD (trapf) */
X
X/*
X ************************************************************************
X *	Date String/Data structures					*
X ************************************************************************
X */
X#ifndef DOS_DATETIME_H		/* added by mool */
X#define DOS_DATETIME_H
X
Xstruct	DateTime	{
X		struct	DateStamp	dat_Stamp;	/* DOS Datestamp			*/
X			UBYTE		dat_Format;	/* controls appearance ot dat_StrDate	*/
X			UBYTE		dat_Flags;	/* See BITDEF's below			*/
X			BYTE		*dat_StrDay;	/* day of the week string		*/
X			BYTE		*dat_StrDate;	/* date string				*/
X			BYTE		*dat_StrTime;	/* time string				*/
X			};
X
X/*
X ************************************************************************
X *	Size of buffer you need for each DateTime strings:		*
X ************************************************************************
X */
X#define	LEN_DATSTRING	10L
X
X/*
X ************************************************************************
X *	For dat_Flags							*
X ************************************************************************
X */
X#define	DTB_SUBST	0L	/* Substitute "Today" "Tomorrow" where appropriate	*/
X#define	DTB_FUTURE	1L	/* Day of the week is in future				*/
X
X#define	DTF_SUBST	(1L << DTB_SUBST)
X#define	DTF_FUTURE	(1L << DTB_FUTURE)
X
X/*
X ************************************************************************
X *	For dat_Format							*
X ************************************************************************
X */
X#define	FORMAT_DOS	0L		/* dd-mmm-yy AmigaDOS's own, unique style		*/
X#define	FORMAT_INT	1L		/* yy-mm-dd International format			*/
X#define	FORMAT_USA	2L		/* mm-dd-yy The good'ol'USA.				*/
X#define	FORMAT_CDN	3L		/* dd-mm-yy Our brothers and sisters to the north	*/
X#define	FORMAT_MAX	FORMAT_CDN	/* Larger than this? Defaults to AmigaDOS		*/
X
X	/* dos/datetime.h uses the same structures and defines, so
X	 * keep the compiler from pulling it in. -olsen
X	 */
X
X/* #define DOS_DATETIME_H 1 */
X#endif
X
X/*
X ************************************************************************
X * Define NO_PROTOTYPES if your compiler does not handle them...	*
X ************************************************************************
X */
X#if defined(NO_PROTOTYPES) || defined(__NO_PROTOS)
X#define	ARGs(x)	()
X#else
X#define	ARGs(x)	x
X
X	/* Added ArpVPrintf, ArpVFPrintf and ArpVSPrintf, so will have to
X	 * include the compiler specific stdarg header file. -olsen
X	 */
X
X#include <stdarg.h>
X
X#endif	/* NO_PROTOTYPES */
X
X/*
X ************************************************************************
X * Note that C_Args is a #define that, in LATTICE does __stdargs	*
X ************************************************************************
X */
X
X/*
X ************************************************************************
X * This prototype is here to prevent the possible error in defining	*
X * IoErr() as LONG and thus causing LastTracker to give you trash...	*
X *									*
X * N O T E !  You MUST! have IoErr() defined as LONG to use LastTracker *
X *	      If your compiler has other defines for this, you may wish *
X *	      to move the prototype for IoErr() into the DO_ARP_COPIES	*
X ************************************************************************
X */
X	LONG			IoErr			ARGs(	(VOID)							);
X
X/*
X ************************************************************************
X *	These duplicate the calls in dos.library			*
X *	Only include if you can use arp.library without dos.library	*
X ************************************************************************
X */
X#ifdef	DO_ARP_COPIES
X	BPTR			Open			ARGs(	(char *, LONG)						);
X	VOID			Close			ARGs(	(BPTR)							);
X	LONG			Read			ARGs(	(BPTR, char *, LONG)					);
X	LONG			Write			ARGs(	(BPTR, char *, LONG)					);
X	BPTR			Input			ARGs(	(VOID)							);
X	BPTR			Output			ARGs(	(VOID)							);
X	LONG			Seek			ARGs(	(BPTR, LONG, LONG)					);
X	LONG			DeleteFile		ARGs(	(char *)						);
X	LONG			Rename			ARGs(	(char *, char *)					);
X	BPTR			Lock			ARGs(	(char *, LONG)						);
X	VOID			UnLock			ARGs(	(BPTR)							);
X	BPTR			DupLock			ARGs(	(BPTR)							);
X	LONG			Examine			ARGs(	(BPTR, struct FileInfoBlock *)				);
X	LONG			ExNext			ARGs(	(BPTR, struct FileInfoBlock *)				);
X	LONG			Info			ARGs(	(BPTR, struct InfoData *)				);
X	BPTR			CreateDir		ARGs(	(char *)						);
X	BPTR			CurrentDir		ARGs(	(BPTR)							);
Xstruct	MsgPort			*CreateProc		ARGs(	(char *, LONG, BPTR, LONG)				);
X	VOID			Exit			ARGs(	(LONG)							);
X	BPTR			LoadSeg			ARGs(	(char *)						);
X	VOID			UnLoadSeg		ARGs(	(BPTR)							);
Xstruct	MsgPort			*DeviceProc		ARGs(	(char *)						);
X	LONG			SetComment		ARGs(	(char *, char *)					);
X	LONG			SetProtection		ARGs(	(char *, LONG)						);
X	LONG			*DateStamp		ARGs(	(LONG *)						);
X	VOID			Delay			ARGs(	(LONG)							);
X	LONG			WaitForChar		ARGs(	(BPTR, LONG)						);
X	BPTR			ParentDir		ARGs(	(BPTR)							);
X	LONG			IsInteractive		ARGs(	(BPTR)							);
X	LONG			Execute			ARGs(	(char *, BPTR, BPTR)					);
X#endif	/* DO_ARP_COPIES */
X
X/*
X ************************************************************************
X *	Now for the stuff that only exists in arp.library...		*
X ************************************************************************
X */
X	/* LONG		C_Args	Printf			ARGs(	(char *,...)						); */
X	/* LONG		C_Args	FPrintf			ARGs(	(BPTR, char *,...)					); */
X	LONG		C_Args	Printf			ARGs(	(UBYTE *, long, ...)						);
X	LONG		C_Args	FPrintf			ARGs(	(BPTR, UBYTE *, long, ...)					);
X	LONG			Puts 			ARGs(	(char *)						);
X	LONG			ReadLine		ARGs(	(char *)						);
X	LONG			GADS		 	ARGs(	(char *, LONG, char *, char **, char *)			);
X	LONG			Atol			ARGs(	(char *)						);
X	ULONG			EscapeString 		ARGs(	(char *)						);
X	LONG			CheckAbort		ARGs(	(VOID(*))						);
X	LONG			CheckBreak		ARGs(	(LONG, VOID(*))						);
X	BYTE			*Getenv			ARGs(	(char *, char *, LONG)					);
X	BOOL			Setenv			ARGs(	(char *, char *)					);
X	BYTE			*FileRequest 		ARGs(	(struct FileRequester *)				);
X	VOID			CloseWindowSafely	ARGs(	(struct Window *, LONG)					);
X/* struct	MsgPort			*CreatePort		ARGs(	(const char *, LONG)						); */
Xstruct	MsgPort			*CreatePort		ARGs(	(UBYTE *, LONG)						);
X	VOID			DeletePort 		ARGs(	(struct MsgPort *)					);
X	LONG			SendPacket 		ARGs(	(LONG, LONG *, struct MsgPort *)			);
X	VOID			InitStdPacket		ARGs(	(LONG, LONG *, struct DosPacket *, struct MsgPort *)	);
X	ULONG			PathName		ARGs(	(BPTR, char *,LONG)					);
X	ULONG			Assign			ARGs(	(char *, char *)					);
X	VOID			*DosAllocMem		ARGs(	(LONG)							);
X	VOID			DosFreeMem		ARGs(	(VOID *)						);
X	ULONG			BtoCStr			ARGs(	(char *, BSTR, LONG)					);
X	ULONG			CtoBStr			ARGs(	(char *, BSTR, LONG)					);
Xstruct	DeviceList		*GetDevInfo		ARGs(	(struct DeviceList *)					);
X	BOOL			FreeTaskResList		ARGs(	(VOID)							);
X	VOID			ArpExit 		ARGs(	(LONG,LONG)						);
X	VOID		C_Args	*ArpAlloc		ARGs(	(LONG)							);
X	VOID		C_Args	*ArpAllocMem		ARGs(	(LONG, LONG)						);
X	BPTR		C_Args	ArpOpen			ARGs(	(char *, LONG)						);
X	BPTR		C_Args	ArpDupLock		ARGs(	(BPTR)							);
X	BPTR		C_Args	ArpLock			ARGs(	(char *, LONG)						);
X	VOID		C_Args	*RListAlloc		ARGs(	(struct ResList *, LONG)				);
Xstruct	Process			*FindCLI		ARGs(	(LONG)							);
X	BOOL			QSort			ARGs(	(VOID *, LONG, LONG, int(*))				);
X	BOOL			PatternMatch		ARGs(	(char *,char *)						);
X	LONG			FindFirst		ARGs(	(char *, struct AnchorPath *)				);
X	LONG			FindNext		ARGs(	(struct AnchorPath *)					);
X	VOID			FreeAnchorChain		ARGs(	(struct AnchorPath *)					);
X	ULONG			CompareLock		ARGs(	(BPTR, BPTR)						);
Xstruct	ResList			*FindTaskResList	ARGs(	(VOID)							);
Xstruct	ResList			*CreateTaskResList	ARGs(	(VOID)							);
X	VOID			FreeResList		ARGs(	(struct ResList *)					);
X	VOID			FreeTrackedItem		ARGs(	(struct DefaultTracker *)				);
Xstruct	DefaultTracker	C_Args	*GetTracker		ARGs(	(LONG)							);
X	VOID			*GetAccess		ARGs(	(struct DefaultTracker *)				);
X	VOID			FreeAccess		ARGs(	(struct DefaultTracker *)				);
X	VOID			FreeDAList		ARGs(	(struct DirectoryEntry *)				);
Xstruct	DirectoryEntry		*AddDANode		ARGs(	(char *, struct DirectoryEntry **, LONG, LONG)		);
X	ULONG			AddDADevs		ARGs(	(struct DirectoryEntry **, LONG)			);
X	LONG			Strcmp			ARGs(	(char *, char *)					);
X	LONG			Strncmp			ARGs(	(char *, char *, LONG)					);
X	BYTE			Toupper			ARGs(	(BYTE)							);
X	LONG			SyncRun			ARGs(	(char *, char *, BPTR, BPTR)				);
X
X/*
X ************************************************************************
X *	Added V32 of arp.library					*
X ************************************************************************
X */
X	LONG			ASyncRun		ARGs(	(char *, char *, struct ProcessControlBlock *)		);
X	LONG			SpawnShell		ARGs(	(char *, char *, struct NewShell *)			);
X	BPTR			LoadPrg			ARGs(	(char *)						);
X	BOOL			PreParse		ARGs(	(char *, char *)					);
X
X/*
X ************************************************************************
X *	Added V33 of arp.library					*
X ************************************************************************
X */
X	BOOL			StamptoStr		ARGs(	(struct DateTime *)					);
X	BOOL			StrtoStamp		ARGs(	(struct DateTime *)					);
Xstruct	ResidentProgramNode	*ObtainResidentPrg	ARGs(	(char *)						);
Xstruct	ResidentProgramNode	*AddResidentPrg		ARGs(	(BPTR, char *)						);
X	LONG			RemResidentPrg		ARGs(	(char *)						);
X	VOID			UnLoadPrg		ARGs(	(BPTR)							);
X	LONG			LMult			ARGs(	(LONG, LONG)						);
X	LONG			LDiv			ARGs(	(LONG, LONG)						);
X	LONG			LMod			ARGs(	(LONG, LONG)						);
X	ULONG			CheckSumPrg		ARGs(	(struct ResidentProgramNode *)				);
X	VOID			TackOn			ARGs(	(char *, char *)					);
X	BYTE			*BaseName		ARGs(	(char *)						);
Xstruct	ResidentProgramNode	*ReleaseResidentPrg	ARGs(	(BPTR)							);
X
X/*
X ************************************************************************
X *	Added V36 of arp.library					*
X ************************************************************************
X */
X	LONG		C_Args	SPrintf			ARGs(	(char *, char *,...)					);
X	LONG			GetKeywordIndex		ARGs(	(char *, char *)					);
Xstruct	Library		C_Args	*ArpOpenLibrary		ARGs(	(char *, LONG)						);
Xstruct	FileRequester	C_Args	*ArpAllocFreq		ARGs(	(VOID)							);
X
X	/* This one's a cutie which is supported via bypassing the
X	 * ??Printf glue routines. -olsen
X	 */
X
X	LONG			ArpVPrintf		ARGs(	(char *, va_list)					);
X	LONG			ArpVFPrintf		ARGs(	(BPTR, char *, va_list)					);
X	LONG			ArpVSPrintf		ARGs(	(char *, char *, va_list)				);
X
X/*
X ************************************************************************
X *	Check if we should do the pragmas...				*
X ************************************************************************
X */
X
X#if !defined(NO_PRAGMAS) && !defined(__NO_PRAGMAS)
X#ifndef	PROTO_ARP_H
X#include <proto/arp.h>
X#endif	/* PROTO_ARP_H */
X#endif	/* NO_PRAGMAS */
X
X#endif	/* LIBRARIES_ARPBASE_H */
END_OF_FILE
if test 49786 -ne `wc -c <'vim/src/arpbase.h'`; then
    echo shar: \"'vim/src/arpbase.h'\" unpacked with wrong size!
fi
chmod +x 'vim/src/arpbase.h'
# end of 'vim/src/arpbase.h'
fi
echo shar: End of archive 24 \(of 25\).
cp /dev/null ark24isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
