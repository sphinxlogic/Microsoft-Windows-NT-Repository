Newsgroups: comp.sources.misc
From: mool@oce.nl (Bram Moolenaar)
Subject: v41i057:  vim - Vi IMitation editor, v2.0, Part07/25
Message-ID: <1993Dec21.034510.27449@sparky.sterling.com>
X-Md4-Signature: 833443fade2b4b530fd2e93ce0049e49
Keywords: utility, editor, vi, vim
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 21 Dec 1993 03:45:10 GMT
Approved: kent@sparky.sterling.com

Submitted-by: mool@oce.nl (Bram Moolenaar)
Posting-number: Volume 41, Issue 57
Archive-name: vim/part07
Environment: UNIX, AMIGA, MS-DOS
Supersedes: vim: Volume 37, Issue 1-24

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 25)."
# Contents:  vim/macros/maze/maze_mac.uue vim/src/misccmds.c
#   vim/src/version.c
# Wrapped by mool@oce-rd2 on Wed Dec 15 09:50:05 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'vim/macros/maze/maze_mac.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/macros/maze/maze_mac.uue'\"
else
echo shar: Extracting \"'vim/macros/maze/maze_mac.uue'\" \(17071 characters\)
sed "s/^X//" >'vim/macros/maze/maze_mac.uue' <<'END_OF_FILE'
X
Xbegin 644 maze_mac
XM(B!4:&5S92!M86-R;W,@)W-O;'9E)R!A;GD@;6%Z92!P<F]D=6-E9"!B>2!TQ
XM:&4@82UM87IE+6EN9R!M87IE+F,@<')O9W)A;2X*(B`*(B!&:7)S="P@82!B&
XM:70@;V8@;6%Z92!T:&5O<GDN"B(@268@>6]U('=E<F4@<'5T(&EN=&\@82!MT
XM87IE+"!A(&=U87)A;G1E960@;65T:&]D(&]F(&9I;F1I;F<@>6]U<B!W87D*L
XM(B!O=70@;V8@=&AE(&UA>F4@:7,@=&\@<'5T('EO=7(@;&5F="!H86YD(&]NG
XM=&\@82!W86QL(&%N9"!J=7-T(&ME97`@=V%L:VEN9RP*(B!N979E<B!T86MI@
XM;F<@>6]U<B!H86YD(&]F9B!T:&4@=V%L;"X@5&AI<R!T96-H;FEQ=64@:7,@S
XM;VYL>2!G=6%R86YT965D('1O"B(@=V]R:R!I9B!T:&4@;6%Z92!D;V5S(&YOY
XM="!H879E(&%N>2`G:7-L86YD<R<L(&]R(&EF('1H92`G97AI="<@:7,@;VX@Z
XM=&AE"B(@<V%M92!I<VQA;F0@87,@>6]U<B!S=&%R=&EN9R!P;VEN="X@5&AEV
XM<V4@8V]N9&ET:6]N<R!H;VQD(&9O<B!T:&4@;6%Z97,*(B!U;F1E<B!C;VYS^
XM:61E<F%T:6]N+@HB(`HB($%S<W5M:6YG('1H870@=&AE(&UA>F4@:7,@;6%D9
XM92!U<"!O9B!H;W)I>F]N=&%L(&%N9"!V97)T:6-A;"!W86QL<R!S<&%C960*S
XM(B!O;F4@<W1E<"!A<&%R="!A;F0@=&AA="!Y;W4@8V%N(&UO=F4@96ET:&5R#
XM(&YO<G1H+"!S;W5T:"P@96%S="!O<B!W97-T+`HB('1H96X@>6]U(&-A;B!A>
XM=71O;6%T92!T:&ES('!R;V-E9'5R92!B>2!C87)R>6EN9R!O=70@=&AE(&9O(
XM;&QO=VEN9R!S=&5P<RX*(B`*(B`Q+B!0=70@>6]U<G-E;&8@<V]M97=H97)E1
XM(&EN('1H92!M87IE(&YE87(@82!W86QL+@HB(#(N($-H96-K(&EF('EO=2!H(
XM879E(&$@=V%L;"!O;B!Y;W5R(&QE9G0N($EF('-O+"!G;R!T;R!S=&5P(#0N&
XM"B(@,RX@5&AE<F4@:7,@;F\@=V%L;"!O;B!Y;W5R(&QE9G0L('-O('1U<FX@\
XM;VX@=&AE('-P;W0@=&\@>6]U<B!L969T(&%N9"!S=&5P"B(@("`@9F]R=V%R-
XM9"!B>2!O;F4@<W1E<"!A;F0@<F5P96%T('-T97`@,BX*(B`T+B!#:&5C:R!WP
XM:&%T(&ES(&1I<F5C=&QY(&EN(&9R;VYT(&]F('EO=2X@268@:70@:7,@82!WY
XM86QL+"!T=7)N(&]N('1H90HB("`@('-P;W0@=&\@>6]U<B!R:6=H="!B>2`YB
XM,"!D96=R965S(&%N9"!R97!E870@<W1E<"`T+@HB(#4N(%1H97)E(&ES(&YO!
XM('=A;&P@:6X@9G)O;G0@;V8@>6]U+"!S;R!S=&5P(&9O<G=A<F0@;VYE('-T*
XM97`@86YD"B(@("`@9V\@=&\@<W1E<"`R+@HB(`HB($EN('1H:7,@=V%Y('EOI
XM=2!W:6QL(&-O=F5R(&%L;"!T:&4@8V]R<FED;W)S(&]F('1H92!M87IE("AU=
XM;G1I;"!Y;W4@9V5T(&)A8VL*(B!T;R!W:&5R92!Y;W4@<W1A<G1E9"!F<F]M7
XM+"!I9B!Y;W4@9&\@;F]T('-T;W`I+@HB(`HB($)Y(&5X86UI;FEN9R!A(&UA;
XM>F4@<')O9'5C960@8GD@=&AE(&UA>F4N8R!P<F]G<F%M('EO=2!W:6QL('-ET
XM92!T:&%T(`HB(&5A8V@@<W%U87)E(&]F('1H92!M87IE(&ES(&]N92!C:&%RC
XM86-T97(@:&EG:"!A;F0@='=O(&-H87)A8W1E<G,@=VED92X*(B!4;R!G;R!NF
XM;W)T:"!O<B!S;W5T:"P@>6]U(&UO=F4@8GD@82!O;F4@8VAA<F%C=&5R('-T#
XM97`L(&)U="!T;R!M;W9E(&5A<W0@;W(*(B!W97-T('EO=2!M;W9E(&)Y(&$@3
XM='=O(&-H87)A8W1E<B!S=&5P+B!!;'-O(&YO=&4@=&AA="!I;B!A;GD@<&]S8
XM:71I;VX*(B!T:&5R92!A<F4@9F]U<B!P;&%C97,@=VAE<F4@=V%L;',@8V]UX
XM;&0@8F4@<'5T("T@=&\@=&AE(&YO<G1H+"!T;R!T:&4@<V]U=&@L"B(@=&\@*
XM=&AE(&5A<W0@86YD('1O('1H92!W97-T+@HB($$@=V%L;"!E>&ES=',@=&\@6
XM=&AE(&YO<G1H(&]F('EO=2!I9B!T:&4@8VAA<F%C=&5R('1O('1H92!N;W)TB
XM:"!O9@HB('EO=2!I<R!A(%\@*&]T:&5R=VES92!I="!I<R!A('-P86-E*2X*K
XM(B!!('=A;&P@97AI<W1S('1O('1H92!E87-T(&]F('EO=2!I9B!T:&4@8VAA2
XM<F%C=&5R('1O('1H92!E87-T(&]F('EO=0HB(&ES(&$@?"`H;W1H97)W:7-E+
XM(&ET(&ES(&$@+BDN"B(@02!W86QL(&5X:7-T<R!T;R!T:&4@=V5S="!O9B!Y1
XM;W4@:68@=&AE(&-H87)A8W1E<B!T;R!T:&4@=V5S="!O9B!Y;W4*(B!I<R!AC
XM('P@*&]T:&5R=VES92!I="!I<R!A("XI+@HB($$@=V%L;"!E>&ES=',@=&\@=
XM=&AE('-O=71H(&]F('EO=2!I9B!T:&4@8VAA<F%C=&5R('=H97)E('EO=2!A<
XM<F4*(B!I<R!A(%\@*&]T:&5R=VES92!I="!I<R!A('-P86-E*2X*(B`*(B!.$
XM;W1E('1H92!D:69F97)E;F-E(&9O<B!D:7)E8W1I;VX@<V]U=&@L('=H97)E6
XM('=E(&UU<W0@97AA;6EN92!T:&4@8VAA<F%C=&5R"B(@=VAE<F4@=&AE(&-U:
XM<G-O<B!I<R!R871H97(@=&AA;B!A;B!A9&IA8V5N="!C96QL+@HB(`HB($EFQ
XM('EO=2!W97)E(&EM<&QE;65N=&EN9R!T:&4@86)O=F4@<')O8V5D=7)E(&ESL
XM(&$@;F]R;6%L(&-O;7!U=&5R(&QA;F=U86=E"B(@>6]U(&-O=6QD('5S92!AK
XM(&QO;W`@=VET:"!I9B!S=&%T96UE;G1S(&%N9"!C;VYT:6YU92!S=&%T96UEX
XM;G1S+"`*(B!(;W=E=F5R+"!T:&5S92!C;VYS=')U8W1S(&%R92!N;W0@879A+
XM:6QA8FQE(&EN('9I(&UA8W)O<R!S;R!)(&AA=F4@=7-E9`HB(&$@<W1A=&4@2
XM;6%C:&EN92!W:71H(#@@<W1A=&5S+B!%86-H('-T871E('-I9VYI9FEE<R!TR
XM:&4@9&ER96-T:6]N('EO=0HB(&%R92!G;VEN9R!I;B!A;F0@=VAE=&AE<B!O3
XM<B!N;W0@>6]U(&AA=F4@8VAE8VME9"!I9B!T:&5R92!I<R!A('=A;&P@;VX*&
XM(B!Y;W5R(&QE9G0N"B(@"B(@5&AE('1R86YS:71I;VX@9G)O;2!S=&%T92!T7
XM;R!S=&%T92!A;F0@=&AE(&%C=&EO;G,@=&%K96X@;VX@96%C:"!T<F%N<VET[
XM:6]N"B(@87)E(&=I=F5N(&EN('1H92!S=&%T92!T86)L92!B96QO=RX*(B!4+
XM:&4@;F%M97,@;V8@=&AE('-T871E<R!A<F4@3C$L($XR+"!3,2P@4S(L($4QQ
XM+"!%,BP@5S$L(%<R+"!W:&5R92!E86-H(&QE='1E<@HB('-T86YD<R!F;W(@4
XM82!D:7)E8W1I;VX@;V8@=&AE(&-O;7!A<W,L('1H92!N=6UB97(@,2!I;F1IY
XM8V%T97,@=&AA="!T:&4@=V4*(B!H879E(&YO="!Y970@8VAE8VME9"!T;R!S.
XM964@:68@=&AE<F4@:7,@82!W86QL(&]N(&]U<B!L969T(&%N9"!T:&4@;G5M@
XM8F5R(#(*(B!I;F1I8V%T97,@=&AA="!W92!H879E(&-H96-K960@86YD('1H2
XM97)E(&ES(&$@=V%L;"!O;B!O=7(@;&5F="X*(B`*(B!&;W(@96%C:"!S=&%T!
XM92!W92!M=7-T(&-O;G-I9&5R('1H92!E>&ES=&5N8V4@;W(@;F]T(&]F(&$@2
XM=V%L;"!I;B!A"B(@<&%R=&EC=6QA<B!D:7)E8W1I;VXN(%1H:7,@9&ER96-T-
XM:6]N(&ES(&=I=F5N(&EN('1H92!F;VQL;W=I;F<@=&%B;&4N"B(@"B(@3F5X=
XM=$-H87(@=&%B;&4Z"B(@<W1A=&4@("`@("`@(&1I<F5C=&EO;B`@("`@("!V8
XM:2!C;VUM86YD<PHB("!.,2`@("`@("`@("`@("`@5R`@("`@("`@("`@("`@=
XM(&A&"B(@($XR("`@("`@("`@("`@("!.("`@("`@("`@("`@("`@:T8*(B`@%
XM4S$@("`@("`@("`@("`@($4@("`@("`@("`@("`@("!L1@HB("!3,B`@("`@L
XM("`@("`@("`@4R`@("`@("`@("`@("`@($8*(B`@13$@("`@("`@("`@("`@;
XM($X@("`@("`@("`@("`@("!K1@HB("!%,B`@("`@("`@("`@("`@12`@("`@'
XM("`@("`@("`@(&Q&"B(@(%<Q("`@("`@("`@("`@("!3("`@("`@("`@("`@Y
XM("`@1@HB("!7,B`@("`@("`@("`@("`@5R`@("`@("`@("`@("`@(&A&"B(@,
XM"B(@=VAE<F4@1B!I<R!A(&UA8W)O('=H:6-H('EA;FMS('1H92!C:&%R86-T,
XM97(@=6YD97(@=&AE(&-U<G-O<B!I;G1O"B(@=&AE($YE>'1#:&%R(')E9VES2
XM=&5R("AN*2X*(B`*(B!3=&%T92!T86)L93H*(B!);B!T:&4@)W9I(&-O;6UA*
XM;F1S)R!C;VQU;6X@:7,@9VEV96X@=&AE(&%C=&EO;G,@=&\@8V%R<GD@;W5T]
XM('=H96X@:6X*(B!T:&ES('-T871E(&%N9"!T:&4@3F5X=$-H87(@:7,@87,@/
XM9VEV96XN(%1H92!C;VUM86YD<R!K+"!J+"!L;"P@:&@@;6]V90HB('1H92!CB
XM=7)R96YT('!O<VET:6]N(&YO<G1H+"!S;W5T:"P@96%S="!A;F0@=V5S="!R`
XM97-P96-T:79E;'DN(%1H90HB(&-O;6UA;F0@;6T@:7,@=7-E9"!A<R!A(&YO`
XM+6]P(&-O;6UA;F0N"B(@26X@=&AE("=N97AT('-T871E)R!C;VQU;6X@:7,@5
XM9VEV96X@=&AE(&YE=R!S=&%T92!O9B!T:&4@;6%C:&EN92!A9G1E<@HB('1H*
XM92!A8W1I;VX@:7,@8V%R<FEE9"!O=70N"B(@"B(@8W5R<F5N="!S=&%T92`@[
XM("`@("`@3F5X=$-H87(@("`@=FD@8V]M;6%N9',@(&YE>'0@<W1A=&4*(B`@:
XM("`@($XQ("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@:&@@("`@("`@]
XM("`@5S$*(B`@("`@($XQ("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@O
XM;6T@("`@("`@("`@3C(*(B`@("`@($XR("`@("`@("`@("`@("`@("!?("`@E
XM("`@("`@("`@;6T@("`@("`@("`@13$*(B`@("`@($XR("`@("`@("`@("`@<
XM("`@<W!A8V4@("`@("`@("`@:R`@("`@("`@("`@3C$*(B`@("`@(%,Q("`@&
XM("`@("`@("`@("`@("`N("`@("`@("`@("`@;&P@("`@("`@("`@13$*(B`@H
XM("`@(%,Q("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@:
XM("`@4S(*(B`@("`@(%,R("`@("`@("`@("`@("`@("!?("`@("`@("`@("`@5
XM;6T@("`@("`@("`@5S$*(B`@("`@(%,R("`@("`@("`@("`@("`@<W!A8V4@?
XM("`@("`@("`@:B`@("`@("`@("`@4S$*(B`@("`@($4Q("`@("`@("`@("`@0
XM("`@<W!A8V4@("`@("`@("`@:R`@("`@("`@("`@3C$*(B`@("`@($4Q("`@X
XM("`@("`@("`@("`@("!?("`@("`@("`@("`@;6T@("`@("`@("`@13(*(B`@<
XM("`@($4R("`@("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@-
XM("`@4S$*(B`@("`@($4R("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@5
XM;&P@("`@("`@("`@13$*(B`@("`@(%<Q("`@("`@("`@("`@("`@<W!A8V4@.
XM("`@("`@("`@:B`@("`@("`@("`@4S$*(B`@("`@(%<Q("`@("`@("`@("`@B
XM("`@("!?("`@("`@("`@("`@;6T@("`@("`@("`@5S(*(B`@("`@(%<R("`@W
XM("`@("`@("`@("`@("!\("`@("`@("`@("`@;6T@("`@("`@("`@3C$*(B`@!
XM("`@(%<R("`@("`@("`@("`@("`@("`N("`@("`@("`@("`@:&@@("`@("`@'
XM("`@5S$*(@HB(`HB($-O;7!L86EN="!A8F]U="!V:2!M86-R;W,Z"B(@270@5
XM<V5E;7,@=&AA="!Y;W4@8V%N;F]T(&AA=F4@;6]R92!T:&%N(&]N92`G=6YD@
XM;RUA8FQE)R!V:2!C;VUM86YD"B(@:6X@=&AE(&]N92!M86-R;RP@<V\@>6]U8
XM(&AA=F4@=&\@;6%K92!L;W1S(&]F(&QI='1L92!M86-R;W,@86YD"B(@<'5TG
XM('1H96T@=&]G971H97(N"B(*(B!))VQL(&5X<&QA:6X@=VAA="!)(&UE86X@M
XM8GD@86X@97AA;7!L92X@161I="!A(&9I;&4@86YD"B(@='EP92`G.FUA<"!1\
XM(')862<N(%1H:7,@<VAO=6QD(&UA<"!T:&4@42!K97D@=&\@)W)E<&QA8V4@>
XM=&AE"B(@8VAA<F%C=&5R('5N9&5R('1H92!C=7)S;W(@=VET:"!8(&%N9"!Y7
XM86YK('1H92!L:6YE)RX*(B!"=70@=VAE;B!)('1Y<&4@42P@=FD@=&5L;',@,
XM;64@)T-A;B=T('EA;FL@:6YS:61E(&=L;V)A;"]M86-R;R<@86YD"B(@9V]E(
XM<R!I;G1O(&5X(&UO9&4N($AO=V5V97(@:68@22!T>7!E("<Z;6%P(%$@<EA4E
XM)R!A;F0@)SIM87`@5"!9)RP*(B!E=F5R>71H:6YG(&ES($]++B!)8&T@9&]I`
XM;F<@86QL('1H:7,@;VX@82!3<&%R8W-T871I;VXN"B(@268@86YY;VYE(')EI
XM861I;F<@=&AI<R!H87,@86X@86YS=V5R('1O('1H:7,@<')O8FQE;2P@=&AE/
XM(&%U=&AO<B!W;W5L9`HB(&QO=F4@=&\@9FEN9"!O=70N($UA:6P@=&\@9W)EN
XM9VU`;W1C+F]T8V$N;WHN874N"B(*(B!4:&4@;6%C<F]S.@HB(%1H92!M86-R@
XM;R!T;R!R=6X@=&AE(&UA>F4@<V]L=F5R(&ES("=G)RX@5&AI<R!S:6UP;'D@E
XM8V%L;',@='=O(&]T:&5R"B(@;6%C<F]S.B!)+"!T;R!I;FET:6%L:7-E(&5VT
XM97)Y=&AI;F<L(&%N9"!,+"!T;R!L;V]P(&9O<F5V97(@<G5N;FEN9PHB('1H`
XM<F]U9V@@=&AE('-T871E('1A8FQE+@HB($)O=&@@;V8@=&AE<V4@;6%C<F]S)
XM(&%R92!L;VYG('-E<75E;F-E<R!O9B!C86QL<R!T;R!O=&AE<B!M86-R;W,N0
XM($%L;`HB(&]F('1H97-E(&]T:&5R(&UA8W)O<R!A<F4@<75I=&4@<VEM<&QE$
XM(&%N9"!S;R!T;R!U;F1E<G-T86YD(&AO=R!T:&ES"B(@=V]R:W,L(&%L;"!Y6
XM;W4@;F5E9"!T;R!D;R!I<R!E>&%M:6YE(&UA8W)O<R!)(&%N9"!,(&%N9"!L%
XM96%R;B!W:&%T('1H97D*(B!D;R`H82!S:6UP;&4@<V5Q=65N8V4@;V8@=FD@3
XM86-T:6]N<RD@86YD(&AO=R!,(&QO;W!S("AB>2!C86QL:6YG(%4L('=H:6-H%
XM"B(@<VEM<&QY(&-A;&QS($P@86=A:6XI+@HB"B(@36%C<F\@22!S971S('5PS
XM('1H92!S=&%T92!T86)L92!A;F0@3F5X=$-H87(@=&%B;&4@870@=&AE(&5N+
XM9"!O9B!T:&4@9FEL92X*(B!-86-R;R!,('1H96X@<V5A<F-H97,@=&AE<V4@H
XM=&%B;&5S('1O(&9I;F0@;W5T('=H870@86-T:6]N<R!T;R!P97)F;W)M(&%NI
XM9`HB('=H870@<W1A=&4@8VAA;F=E<R!T;R!M86ME+@HB"B(@5&AE(&5N=')IH
XM97,@:6X@=&AE('-T871E('1A8FQE(&%L;"!B96=I;B!W:71H(&$@:V5Y(&-O/
XM;G-I<W1I;F<@;V8@=&AE"B(@;&5T=&5R("=S)RP@=&AE(&-U<G)E;G0@<W1A:
XM=&4@86YD('1H92!.97AT0VAA<BX@($%F=&5R('1H:7,@:7,@=&AE"B(@86-TC
XM:6]N('1O('1A:V4@:6X@=&AI<R!S=&%T92!A;F0@869T97(@=&AI<R!I<R!T+
XM:&4@;F5X="!S=&%T92!T;R!C:&%N9V4@=&\N"B(*(B!4:&4@96YT<FEE<R!IC
XM;B!T:&4@3F5X=$-H87(@=&%B;&4@8F5G:6X@=VET:"!A(&ME>2!C;VYS:7-T"
XM:6YG(&]F('1H90HB(&QE='1E<B`G;B<@86YD('1H92!C=7)R96YT('-T871ED
XM+B!!9G1E<B!T:&ES(&ES('1H92!A8W1I;VX@=&\@=&%K92!T;PHB(&]B=&%IY
XM;B!.97AT0VAA<B`M('1H92!C:&%R86-T97(@=&AA="!M=7-T(&)E(&5X86UI[
XM;F5D('1O(&-H86YG92!S=&%T92X*(@HB($]N92!W87D@=&\@<V5E('=H870@.
XM96%C:"!P87)T(&]F('1H92!M86-R;W,@:7,@9&]I;F<@:7,@=&\@='EP92!IZ
XM;B!T:&4*(B!B;V1Y(&]F('1H92!M86-R;W,@22!A;F0@3"!M86YU86QL>2`HW
XM:6YS=&5A9"!O9B!T>7!I;F<@)V<G*2!A;F0@<V5E"B(@=VAA="!H87!P96YS5
XM(&%T(&5A8V@@<W1E<"X*(@HB($=O;V0@;'5C:RX*(@HB(%)E9VES=&5R<R!US
XM<V5D(&)Y('1H92!M86-R;W,Z"B(@<R`H4W1A=&4I("`@("`@("`M(&AO;&1S/
XM('1H92!S=&%T92!T:&4@;6%C:&EN92!I<R!I;@HB(&,@*$-H87(I("`@("`@)
XM("`@+2!H;VQD<R!T:&4@8VAA<F%C=&5R('5N9&5R('1H92!C=7)R96YT('!OV
XM<VET:6]N"B(@;2`H36%C<F\I("`@("`@("`M(&AO;&1S(&$@=FD@8V]M;6%NT
XM9"!S=')I;F<@=&\@8F4@97AE8W5T960@;&%T97(*(B!N("A.97AT0VAA<BD@<
XM("`@("T@:&]L9',@=&AE(&-H87)A8W1E<B!W92!M=7-T(&5X86UI;F4@=&\@D
XM8VAA;F=E('-T871E"B(@<B`H4V5C;VYD($UA8W)O*2`M(&AO;&1S(&$@<V5CG
XM;VYD('9I(&-O;6UA;F0@<W1R:6YG('1O(&)E(&5X96-U=&5D(&QA=&5R"B(*%
XM<V5T(')E;6%P"G-E="!N;VUA9VEC"G-E="!N;W1E<G-E"G-E="!W<F%P<V-AR
XM;@HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T].
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@9R`M(&=O(')U;G,@=&AE('=HV
XM;VQE('-H;W<*(B`@("`@("`@22`M(&EN:71I86QI<V4*(B`@("`@("`@3"`MS
XM('1H96X@;&]O<"!F;W)E=F5R"FUA<"!G("`@24P*(@HB/3T]/3T]/3T]/3T]Z
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/0HB($D@+2!I;FET:6%L:7-E(&5V97)Y=&AI;F<@8F5F;W)E(')U7
XM;FYI;F<@=&AE(&QO;W`*(B`@($<D/RY>32`M(&9I;F0@=&AE(&QA<W0@+B!I^
XM;B!T:&4@;6%Z90HB("`@("`@("!>("T@<F5P;&%C92!I="!W:71H(&%N(%@@/
XM*'1H92!G;V%L*0HB("`@1UE+9410("T@<')I;G0@=&AE('-T871E('1A8FQEI
XM(&%N9"!N97AT(&-H87(@=&%B;&4@870@=&AE(&5N9"!O9B!T:&4@9FEL90HB'
XM("`@("`@(#!3("T@:6YI=&EA;&ES92!T:&4@<W1A=&4@;V8@=&AE(&UA8VAI5
XM;F4@=&\@13$*(B`@("`@(#)';"`M(&UO=F4@=&\@=&AE('1O<"!L969T(&-EK
XM;&P@;V8@=&AE(&UA>F4*;6%P($D@("!')#\N#5Y'64ME1%`P4S)';`HB"B(]P
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]"B(@3"`M('1H92!L;V]P('=H:6-H(&ES(&5X6
XM96-U=&5D(&9O<F5V97(*(B`@("`@("`@42`M('-A=F4@=&AE(&-U<G)E;G0@0
XM8VAA<F%C=&5R(&EN('1H92!#:&%R(')E9VES=&5R"B(@("`@("`@($$@+2!RT
XM97!L86-E('1H92!C=7)R96YT(&-H87)A8W1E<B!W:71H(&%N("=/)PHB("`@/
XM("`@(&UA("T@;6%R:R!T:&4@8W5R<F5N="!P;W-I=&EO;B!W:71H(&UA<FL@&
XM)V$G"B(@("`@("!'3D(@+2!O;B!B;W1T;VT@;&EN92P@8W)E871E(&$@8V]M9
XM;6%N9"!T;R!S96%R8V@@=&AE($YE>'1#:&%R('1A8FQE"B(@("`@("`@("`@K
XM("!F;W(@=&AE(&-U<G)E;G0@<W1A=&4*(B`P33!%0&U>32`M('EA;FL@=&AEC
XM(&-O;6UA;F0@:6YT;R!T:&4@36%C<F\@<F5G:7-T97(@86YD(&5X96-U=&4@7
XM:70*(B`@("`@("!W6"`M('=E(&AA=F4@;F]W(&9O=6YD('1H92!E;G1R>2!IQ
XM;B!T:&4@=&%B;&4L(&YO=R!Y86YK('1H90HB("`@("`@("`@("`@9F]L;&]W*
XM:6YG('=O<F0@:6YT;R!T:&4@36%C<F\@<F5G:7-T97(*(B`@("`@8&%`;2`MS
XM(&=O(&)A8VL@=&\@=&AE(&-U<G)E;G0@<&]S:71I;VX@86YD(&5X96-U=&4@)
XM=&AE(&UA8W)O+"!T:&ES('=I;&P*(B`@("`@("`@("`@('EA;FL@=&AE($YEB
XM>'1#:&%R(&EN(')E9VES=&5R(&X*(B`@($=4)$(D4B`M(&]N(&)O='1O;2!L"
XM:6YE+"!C<F5A=&4@82!C;VUM86YD('1O('-E87)C:"!T:&4@<W1A=&4@=&%B.
XM;&4*(B`@("`@("`@("`@(&9O<B!T:&4@8W5R<F5N="!S=&%T92!A;F0@3F5XG
XM=$-H87(*(B`P33!%0&U>32`M('EA;FL@=&AE(&-O;6UA;F0@:6YT;R!T:&4@C
XM36%C<F\@<F5G:7-T97(@86YD(&5X96-U=&4@:70*(B`@("`@(#)74R`M('=EK
XM(&AA=F4@;F]W(&9O=6YD('1H92!E;G1R>2!I;B!T:&4@=&%B;&4L(&YO=R!Y@
XM86YK('1H90HB("`@("`@("`@("`@;F5X="!S=&%T92!I;G1O('1H92!3=&%T^
XM92!M86-R;PHB("`@("`@(&)8("T@86YD('EA;FL@=&AE(&%C=&EO;B!C;W)RE
XM97-P;VYD:6YG('1O('1H:7,@<W1A=&4@=&%B;&4@96YT<GD*(B`@("`@("`@)
XM("`@(&EN=&\@=&AE($UA8W)O(')E9VES=&5R"B(@("`@("!'5DH@+2!O;B!B1
XM;W1T;VT@;&EN92P@8W)E871E(&$@8V]M;6%N9"!T;R!R97-T;W)E('1H92!C&
XM=7)R96YT(&-H87)A8W1E<@HB("`@("`@(#!(("T@86YD('-A=F4@=&AE(&-OS
XM;6UA;F0@:6YT;R!T:&4@<V5C;VYD($UA8W)O(')E9VES=&5R"B(@("`@(&!A(
XM0'(@+2!G;R!B86-K('1O('1H92!C=7)R96YT('!O<VET:6]N(&%N9"!E>&5C:
XM='5T92!T:&4@;6%C<F\@=&\@<F5S=&]R90HB("`@("`@("`@("`@=&AE(&-UA
XM<G)E;G0@8VAA<F%C=&5R"B(@("`@("`@0&T@+2!E>&5C=71E('1H92!A8W1IS
XM;VX@87-S;V-I871E9"!W:71H('1H:7,@<W1A=&4*(B`@("`@("`@52`M(&%N/
XM9"!R97!E870*;6%P($P@("!106UA1TY",$TP14!M#7=88&%`;4=4)$(D4C!-M
XM,$5`;0TR5U-B6$=62C!(8&%`<D!M50HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]X
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM"B(@52`M(&YO('1A:6P@<F5C=7)S:6]N(&%L;&]W960@:6X@=FD@;6%C<F]S2
XM('-O(&-H96%T(&%N9"!S970@52`]($P*;6%P(%4@("!,"B(*(CT]/3T]/3T]-
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T*(B!3("T@>6%N:R!T:&4@;F5X="!T=V\@8VAA<F%C=&5RE
XM<R!I;G1O('1H92!3=&%T92!R96=I<W1E<@IM87`@4R`@(")S>3)L"B(*(CT]M
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!1("T@<V%V92!T:&4@8W5R<F5N="!C:&%R(
XM86-T97(@:6X@=&AE($-H87(@<F5G:7-T97(*;6%P(%$@("`B8WEL"B(*(CT]?
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!!("T@<F5P;&%C92!T:&4@8W5R<F5N="!CJ
XM:&%R86-T97(@=VET:"!A;B`G3R<*;6%P($$@("!R3PHB"B(]/3T]/3T]/3T]6
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]"B(@3B`M(')E<&QA8V4@=&AI<R!L:6YE('=I=&@@=&AE('-TL
XM<FEN9R`G;B<*;6%P($X@("!#+VX;"B(*(CT]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T*&
XM(B!"("T@<'5T('1H92!C=7)R96YT('-T871E"FUA<"!"("`@(G-P"B(*(CT]P
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T*(B!-("T@>6%N:R!T:&ES(&QI;F4@:6YT;R!T4
XM:&4@36%C<F\@<F5G:7-T97(*;6%P($T@("`B;7DD"B(*(CT]/3T]/3T]/3T]<
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T*(B!%("T@9&5L971E('1O('1H92!E;F0@;V8@=&AE(&QI;F4*\
XM;6%P($4@("!D)`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]&
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@6"`M('EA;FL@!
XM=&AI<R!W;W)D(&EN=&\@=&AE($UA8W)O(')E9VES=&5R"FUA<"!8("`@(FUY.
XM="`*(@HB/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]W
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/0HB(%0@+2!R97!L86-E('1H:7,@6
XM;&EN92!W:71H('1H92!S=')I;F<@)W,G"FUA<"!4("`@0R]S&PHB"B(]/3T]E
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]"B(@4B`M('!U="!.97AT0VAA<@IM87`@4B`@(")N>
XM<`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]0
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]"B(@5B`M(&%D9"!T:&4@;&5T=&5R!
XM("=R)R`H=&AE(')E<&QA8V4@=FD@8V]M;6%N9"D*;6%P(%8@("!A<AL*(@HBP
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T]/3T]/3T]/0HB($H@+2!R97-T;W)E('1H92!C=7)R96YT2
XM(&-H87)A8W1E<@IM87`@2B`@(")C<`HB"B(]/3T]/3T]/3T]/3T]/3T]/3T]S
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM"B(@2"`M('EA;FL@=&AI<R!L:6YE(&EN=&\@=&AE('-E8V]N9"!-86-R;R!R/
XM96=I<W1E<@IM87`@2"`@(")R>20*(@HB/3T]/3T]/3T]/3T]/3T]/3T]/3T]-
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/0HBK
XM($8@+2!Y86YK($YE>'1#:&%R("AT:&ES(&UA8W)O(&ES(&-A;&QE9"!F<F]M*
XM('1H92!-86-R;R!R96=I<W1E<BD*;6%P($8@("`B;GEL"B(*(CT]/3T]/3T]D
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]/3T]/3T]/3T*(B!>("T@<F5P;&%C92!T:&4@8W5R<F5N="!C:&%R86-T,
XM97(@=VET:"!A;B`G6"<*;6%P(%X@("!R6`HB"B(]/3T]/3T]/3T]/3T]/3T]`
XM/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]/3T]Y
XM/3T]"B(@64ME1%`@+2!C<F5A=&4@=&AE('-T871E('1A8FQE+"!.97AT0VAA"
XM<B!T86)L92!A;F0@:6YI=&EA;"!S=&%T90HB($YO=&4@=&AA="!Y;W4@:&%V'
XM92!T;R!E<V-A<&4@=&AE(&)A<B!C:&%R86-T97(L('-I;F-E(&ET(&ES('-P6
XM96-I86P@=&\*(B!T:&4@;6%P(&-O;6UA;F0@*&ET(&EN9&EC871E<R!A(&YE8
XM=R!L:6YE*2X*;6%P(%D@("!O<T4Q("!K("!.,2`@("`@("!S13%?(&UM($4RR
XM("`@("`@('-%,A9\(&UM(%,Q("`@("`@('-%,BX@;&P@13$;"FUA<"!+("`@N
XM;W-7,2`@:B`@4S$@("`@("`@<U<Q7R!M;2!7,B`@("`@("!S5S(6?"!M;2!.+
XM,2`@("`@("!S5S(N(&AH(%<Q&PIM87`@92`@(&]S3C$N(&AH(%<Q("`@("`@"
XM('-.,19\(&UM($XR("`@("`@('-.,B`@:R`@3C$@("`@("`@<TXR7R!M;2!%,
XM,1L*;6%P($0@("!O<U,Q+B!L;"!%,2`@("`@("!S4S$6?"!M;2!3,B`@("`@B
XM("!S4S(@(&H@(%,Q("`@("`@('-3,E\@;6T@5S$;"FUA<"!0("`@;VY%,2!K0
XM1B!N13(@;$8@;E<Q($<D2D8@;E<R(&A&(&Y.,2!H1B!N3C(@:T8@;E,Q(&Q&1
X/(&Y3,B!')$I&(`U%,1L*V
X``
Xend
Xsize 12165
END_OF_FILE
if test 17071 -ne `wc -c <'vim/macros/maze/maze_mac.uue'`; then
    echo shar: \"'vim/macros/maze/maze_mac.uue'\" unpacked with wrong size!
fi
chmod +x 'vim/macros/maze/maze_mac.uue'
# end of 'vim/macros/maze/maze_mac.uue'
fi
if test -f 'vim/src/misccmds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/misccmds.c'\"
else
echo shar: Extracting \"'vim/src/misccmds.c'\" \(16465 characters\)
sed "s/^X//" >'vim/src/misccmds.c' <<'END_OF_FILE'
X/* vi:ts=4:sw=4
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X * misccmds.c: functions that didn't seem to fit elsewhere
X */
X
X#include "vim.h"
X#include "globals.h"
X#include "proto.h"
X#include "param.h"
X
Xstatic char *(si_tab[]) = {"if", "else", "while", "for", "do"};
X
X/*
X * count the size of the indent in the current line
X */
X	int
Xget_indent()
X{
X	register char *ptr;
X	register int count = 0;
X
X	for (ptr = nr2ptr(Curpos.lnum); *ptr; ++ptr)
X	{
X		if (*ptr == TAB)	/* count a tab for what it is worth */
X			count += (int)p_ts - (count % (int)p_ts);
X		else if (*ptr == ' ')
X			++count;			/* count a space for one */
X		else
X			break;
X	}
X	return (count);
X}
X
X/*
X * set the indent of the current line
X * leaves the cursor on the first non-blank in the line
X */
X	void
Xset_indent(size, delete)
X	register int size;
X	int delete;
X{
X	int		oldstate = State;
X
X	State = INSERT;		/* don't want REPLACE for State */
X	Curpos.col = 0;
X	if (delete)
X	{
X		while (isspace(gcharCurpos()))	/* delete old indent */
X			delchar(FALSE);
X	}
X	if (!p_et)			/* if 'expandtab' is set, don't use TABs */
X		while (size >= (int)p_ts)
X		{
X			inschar(TAB);
X			size -= (int)p_ts;
X		}
X	while (size)
X	{
X		inschar(' ');
X		--size;
X	}
X	State = oldstate;
X	script_winsize_pp();
X}
X
X/*
X * Opencmd
X *
X * Add a blank line below or above the current line.
X */
X
X	int
XOpencmd(dir, redraw, delspaces)
X	int 		dir;
X	int			redraw;
X	int			delspaces;
X{
X	char   *l;
X	char   *ptr, *pp;
X	FPOS	oldCurpos; 			/* old cursor position */
X	int		newcol = 0;			/* new cursor column */
X	int 	newindent = 0;		/* auto-indent of the new line */
X	int 	extra = 0;			/* number of bytes to be copied from current line */
X	int		n;
X	int		truncate = FALSE;	/* truncate current line afterwards */
X	int		no_si = FALSE;		/* reset did_si afterwards */
X
X	ptr = nr2ptr(Curpos.lnum);
X	u_clearline();		/* cannot do "U" command when adding lines */
X	did_si = FALSE;
X	if (p_ai || p_si)
X	{
X		/*
X		 * count white space on current line
X		 */
X		newindent = get_indent();
X		if (newindent == 0)
X			newindent = old_indent;		/* for ^^D command in insert mode */
X		old_indent = 0;
X
X			/*
X			 * If we just did an auto-indent, then we didn't type anything on the
X			 * prior line, and it should be truncated.
X			 */
X		if (dir == FORWARD && did_ai)
X			truncate = TRUE;
X		else if (p_si && *ptr != NUL)
X		{
X			char	*p;
X			char	*pp;
X			int		i, save;
X
X			if (dir == FORWARD)
X			{
X				p = ptr + strlen(ptr) - 1;
X				while (p > ptr && isspace(*p))	/* find last non-blank in line */
X					--p;
X				if (*p == '{')					/* line ends in '{': do indent */
X				{
X					did_si = TRUE;
X					no_si = TRUE;
X				}
X				else							/* look for "if" and the like */
X				{
X					p = ptr;
X					skipspace(&p);
X					for (pp = p; islower(*pp); ++pp)
X						;
X					if (!isidchar(*pp))			/* careful for vars starting with "if" */
X					{
X						save = *pp;
X						*pp = NUL;
X						for (i = sizeof(si_tab)/sizeof(char *); --i >= 0; )
X							if (strcmp(p, si_tab[i]) == 0)
X							{
X								did_si = TRUE;
X								break;
X							}
X						*pp = save;
X					}
X				}
X			}
X			else
X			{
X				p = ptr;
X				skipspace(&p);
X				if (*p == '}')			/* if line starts with '}': do indent */
X					did_si = TRUE;
X			}
X		}
X		did_ai = TRUE;
X		if (p_si)
X			can_si = TRUE;
X	}
X	if (State == INSERT || State == REPLACE)	/* only when dir == FORWARD */
X	{
X		pp = ptr + Curpos.col;
X		if (p_ai && delspaces)
X			skipspace(&pp);
X		extra = strlen(pp);
X	}
X	if ((l = alloc_line(extra)) == NULL)
X		return (FALSE);
X	if (extra)
X	{
X		strcpy(l, pp);
X		did_ai = FALSE; 		/* don't trucate now */
X	}
X
X	oldCurpos = Curpos;
X	if (dir == BACKWARD)
X		--Curpos.lnum;
X	if (appendline(Curpos.lnum, l) == FALSE)
X		return FALSE;
X	if (newindent || did_si)
X	{
X		++Curpos.lnum;
X		if (did_si)
X		{
X			if (p_sr)
X				newindent -= newindent % (int)p_sw;
X			newindent += (int)p_sw;
X		}
X		set_indent(newindent, FALSE);
X		newcol = Curpos.col;
X		if (no_si)
X			did_si = FALSE;
X	}
X	Curpos = oldCurpos;
X
X	if (dir == FORWARD)
X	{
X		if (truncate || State == INSERT || State == REPLACE)
X		{
X			if (truncate)
X				*ptr = NUL;
X			else
X				*(ptr + Curpos.col) = NUL;	/* truncate current line at cursor */
X			canincrease(0);
X		}
X
X		/*
X		 * Get the cursor to the start of the line, so that 'Cursrow' gets
X		 * set to the right physical line number for the stuff that
X		 * follows...
X		 */
X		Curpos.col = 0;
X
X		if (redraw)
X		{
X			cursupdate();
X
X			/*
X			 * If we're doing an open on the last logical line, then go ahead and
X			 * scroll the screen up. Otherwise, just insert a blank line at the
X			 * right place. We use calls to plines() in case the cursor is
X			 * resting on a long line.
X			 */
X			n = Cursrow + plines(Curpos.lnum);
X			if (n == (Rows - 1))
X				scrollup(1L);
X			else
X				s_ins(n, 1, TRUE);
X		}
X		++Curpos.lnum;	/* cursor moves down */
X	}
X	else if (redraw)
X		s_ins(Cursrow, 1, TRUE); /* insert physical line */
X
X	Curpos.col = newcol;
X	if (redraw)
X	{
X		updateScreen(VALID_TO_CURSCHAR);
X		cursupdate();			/* update Cursrow */
X	}
X	CHANGED;
X
X	return (TRUE);
X}
X
X/*
X * plines(p) - return the number of physical screen lines taken by line 'p'
X */
X	int
Xplines(p)
X	linenr_t p;
X{
X	register int		col = 0;
X	register u_char		*s;
X
X	if (!p_wrap)
X		return 1;
X
X	s = (u_char *)nr2ptr(p);
X	if (*s == NUL)				/* empty line */
X		return 1;
X
X	while (*s != NUL)
X		col += chartabsize(*s++, col);
X
X	/*
X	 * If list mode is on, then the '$' at the end of the line takes up one
X	 * extra column.
X	 */
X	if (p_list)
X		col += 1;
X
X	/*
X	 * If 'number' mode is on, add another 8.
X	 */
X	if (p_nu)
X		col += 8;
X
X	col = (col + ((int)Columns - 1)) / (int)Columns;
X	if (col < Rows)
X		return col;
X	return (int)(Rows - 1);		/* maximum length */
X}
X
X/*
X * Count the physical lines (rows) for the lines "first" to "last" inclusive.
X */
X	int
Xplines_m(first, last)
X	linenr_t		first, last;
X{
X		int count = 0;
X
X		while (first <= last)
X				count += plines(first++);
X		return (count);
X}
X
X	void
Xfileinfo(fullname)
X	int fullname;
X{
X	if (bufempty())
X	{
X		msg("Buffer Empty");
X		return;
X	}
X	sprintf(IObuff, "\"%s\"%s%s%s line %ld of %ld -- %d %% --",
X			(!fullname && sFilename != NULL) ? sFilename :
X				((Filename != NULL) ? Filename : "No File"),
X			Changed ? " [Modified]" : "",
X			NotEdited ? " [Not edited]" : "",
X			p_ro ? " [readonly]" : "",
X			(long)Curpos.lnum,
X			(long)line_count,
X			(int)(((long)Curpos.lnum * 100L) / (long)line_count));
X
X	if (numfiles > 1)
X		sprintf(IObuff + strlen(IObuff), " (file %d of %d)", curfile + 1, numfiles);
X	msg(IObuff);
X}
X
X/*
X * Set the current file name to 's'.
X * The file name with the full path is also remembered, for when :cd is used.
X */
X	void
Xsetfname(s, ss)
X	char *s, *ss;
X{
X	free(Filename);
X	free(sFilename);
X	if (s == NULL || *s == NUL)
X	{
X		Filename = NULL;
X		sFilename = NULL;
X	}
X	else
X	{
X		if (ss == NULL)
X			ss = s;
X		sFilename = (char *)strsave(ss);
X		FullName(s, IObuff, IOSIZE);
X		Filename = (char *)strsave(IObuff);
X	}
X	if (did_cd)
X		xFilename = Filename;
X	else
X		xFilename = sFilename;
X
X#ifndef MSDOS
X	thisfile_sn = FALSE;
X#endif
X}
X
X/*
X * return nonzero if "s" is not the same file as current file
X */
X	int
Xotherfile(s)
X	char *s;
X{
X	if (s == NULL || *s == NUL || Filename == NULL)		/* no name is different */
X		return TRUE;
X	FullName(s, IObuff, IOSIZE);
X	return fnamecmp(IObuff, Filename);
X}
X	
X/*
X * put filename in title bar of window
X */
X	void
Xmaketitle()
X{
X#ifdef AMIGA
X	if (Filename == NULL)
X		settitle("");
X	else
X	{
X		if (numfiles <= 1)
X			settitle(Filename);
X		else
X		{
X			sprintf(IObuff, "%s (%d of %d)", Filename, curfile + 1, numfiles);
X			settitle(IObuff);
X		}
X	}
X#endif
X}
X
X	void
Xinschar(c)
X	int			c;
X{
X	register char  *p;
X	int				rir0;		/* reverse replace in column 0 */
X
X	p = Curpos2ptr();
X	rir0 = (State == REPLACE && p_ri && Curpos.col == 0);
X	if (rir0 || State != REPLACE || *p == NUL)
X	{
X			/* make room for the new char. */
X		if (!canincrease(1))	/* make room for the new char */
X			return;
X
X		p = Curpos2ptr();		/* get p again, canincrease() may have changed it */
X		memmove(p + 1, p, strlen(p) + 1);	/* move following text and NUL */
X	}
X	if (rir0)					/* reverse replace in column 0 */
X	{
X		*(p + 1) = c;			/* replace the char that was in column 0 */
X		c = ' ';				/* insert a space */
X		extraspace = TRUE;
X	}
X	*p = c;
X
X	/*
X	 * If we're in insert mode and showmatch mode is set, then check for
X	 * right parens and braces. If there isn't a match, then beep. If there
X	 * is a match AND it's on the screen, then flash to it briefly. If it
X	 * isn't on the screen, don't do anything.
X	 */
X	if (p_sm && State == INSERT && (c == ')' || c == '}' || c == ']'))
X	{
X		FPOS		   *lpos, csave;
X
X		if ((lpos = showmatch()) == NULL)		/* no match, so beep */
X			beep();
X		else if (lpos->lnum >= Topline)
X		{
X			updateScreen(VALID_TO_CURSCHAR); /* show the new char first */
X			csave = Curpos;
X			Curpos = *lpos; 	/* move to matching char */
X			cursupdate();
X			showruler(0);
X			setcursor();
X			flushbuf();
X			vim_delay();		/* brief pause */
X			Curpos = csave; 	/* restore cursor position */
X			cursupdate();
X		}
X	}
X	if (!p_ri)							/* normal insert: cursor right */
X		++Curpos.col;
X	else if (State == REPLACE && !rir0)	/* reverse replace mode: cursor left */
X		--Curpos.col;
X	CHANGED;
X}
X
X	void
Xinsstr(s)
X	register char  *s;
X{
X	register char  *p;
X	register int	n = strlen(s);
X
X	if (!canincrease(n))	/* make room for the new string */
X		return;
X
X	p = Curpos2ptr();
X	memmove(p + n, p, strlen(p) + 1);
X	memmove(p, s, (size_t)n);
X	Curpos.col += n;
X	CHANGED;
X}
X
X	int
Xdelchar(fixpos)
X	int			fixpos; 	/* if TRUE fix the cursor position when done */
X{
X	char		*ptr;
X	int			lastchar;
X
X	ptr = Curpos2ptr();
X
X	if (*ptr == NUL)	/* can't do anything (happens with replace mode) */
X		return FALSE;
X
X	lastchar = (*++ptr == NUL);
X	/* Delete the char. at Curpos by shifting everything in the line down. */
X	do
X		*(ptr - 1) = *ptr;
X	while (*ptr++);
X
X	/*
X	 * If we just took off the last character of a non-blank line, we don't
X	 * want to end up positioned at the newline.
X	 */
X	if (fixpos && Curpos.col > 0 && lastchar)
X		--Curpos.col;
X
X	(void)canincrease(0);
X	CHANGED;
X	return TRUE;
X}
X
X	void
Xdellines(nlines, doscreen, undo)
X	long 			nlines;			/* number of lines to delete */
X	int 			doscreen;		/* if true, update the screen */
X	int				undo;			/* if true, prepare for undo */
X{
X	int 			num_plines = 0;
X	char			*ptr;
X
X	if (nlines <= 0)
X		return;
X	/*
X	 * There's no point in keeping the screen updated if we're deleting more
X	 * than a screen's worth of lines.
X	 */
X	if (nlines > (Rows - 1 - Cursrow) && doscreen)
X	{
X		doscreen = FALSE;
X		/* flaky way to clear rest of screen */
X		s_del(Cursrow, (int)Rows - 1, TRUE);
X	}
X	if (undo && !u_savedel(Curpos.lnum, nlines))
X		return;
X	while (nlines-- > 0)
X	{
X		if (bufempty()) 		/* nothing to delete */
X			break;
X
X		/*
X		 * Set up to delete the correct number of physical lines on the
X		 * screen
X		 */
X		if (doscreen)
X			num_plines += plines(Curpos.lnum);
X
X		ptr = delsline(Curpos.lnum, TRUE);
X		if (!undo)
X			free_line(ptr);
X
X		CHANGED;
X
X		/* If we delete the last line in the file, stop */
X		if (Curpos.lnum > line_count)
X		{
X			Curpos.lnum = line_count;
X			break;
X		}
X	}
X	Curpos.col = 0;
X	/*
X	 * Delete the correct number of physical lines on the screen
X	 */
X	if (doscreen && num_plines > 0)
X		s_del(Cursrow, num_plines, TRUE);
X}
X
X	int
Xgchar(pos)
X	FPOS *pos;
X{
X	return (int)(*(pos2ptr(pos)));
X}
X
X	int
XgcharCurpos()
X{
X	return (int)(*(Curpos2ptr()));
X}
X
X	void
XpcharCurpos(c)
X	int c;
X{
X	*(Curpos2ptr()) = c;
X}
X
X/*
X * return TRUE if the cursor is before or on the first non-blank in the line
X */
X	int
Xinindent()
X{
X	register char *ptr;
X	register int col;
X
X	for (col = 0, ptr = nr2ptr(Curpos.lnum); isspace(*ptr++); ++col)
X		;
X	if (col >= Curpos.col)
X		return TRUE;
X	else
X		return FALSE;
X}
X
X/*
X * skipspace: skip over ' ' and '\t'.
X *
X * note: you must give a pointer to a char pointer!
X */
X	void
Xskipspace(pp)
X	char **pp;
X{
X    register char *p;
X    
X    for (p = *pp; *p == ' ' || *p == '\t'; ++p)	/* skip to next non-white */
X    	;
X    *pp = p;
X}
X
X/*
X * skiptospace: skip over text until ' ' or '\t'.
X *
X * note: you must give a pointer to a char pointer!
X */
X	void
Xskiptospace(pp)
X	char **pp;
X{
X	register char *p;
X
X	for (p = *pp; *p != ' ' && *p != '\t' && *p != NUL; ++p)
X		;
X	*pp = p;
X}
X
X/*
X * skiptodigit: skip over text until digit found
X *
X * note: you must give a pointer to a char pointer!
X */
X	void
Xskiptodigit(pp)
X	char **pp;
X{
X	register char *p;
X
X	for (p = *pp; !isdigit(*p) && *p != NUL; ++p)
X		;
X	*pp = p;
X}
X
X/*
X * getdigits: get a number from a string and skip over it
X *
X * note: you must give a pointer to a char pointer!
X */
X
X	long
Xgetdigits(pp)
X	char **pp;
X{
X    register char *p;
X	long retval;
X    
X	p = *pp;
X	retval = atol(p);
X    while (isdigit(*p))	/* skip to next non-digit */
X    	++p;
X    *pp = p;
X	return retval;
X}
X
X	char *
Xplural(n)
X	long n;
X{
X	static char buf[2] = "s";
X
X	if (n == 1)
X		return &(buf[1]);
X	return &(buf[0]);
X}
X
X/*
X * set_Changed is called whenever something in the file is changed
X * If the file is readonly, give a warning message with the first change.
X * Don't use emsg(), because it flushes the macro buffer.
X */
X	void
Xset_Changed()
X{
X	change_warning();
X	Changed = 1;
X	Updated = 1;
X}
X
X	void
Xchange_warning()
X{
X	if (Changed == 0 && p_ro)
X	{
X		msg("Warning: Changing a readonly file");
X		sleep(1);			/* give him some time to think about it */
X	}
X}
X
X	int
Xask_yesno(str)
X	char *str;
X{
X	int r = ' ';
X
X	while (r != 'y' && r != 'n')
X	{
X		smsg("%s (y/n)? ", str);
X		r = vgetc();
X		if (r == Ctrl('C'))
X			r = 'n';
X		outchar(r);		/* show what you typed */
X		flushbuf();
X	}
X	return r;
X}
X
X	void
Xmsgmore(n)
X	long n;
X{
X	long pn;
X
X	if (n > 0)
X		pn = n;
X	else
X		pn = -n;
X
X	if (pn > p_report)
X		smsg("%ld %s line%s %s", pn, n > 0 ? "more" : "fewer", plural(pn),
X											got_int ? "(Interrupted)" : "");
X}
X
X/*
X * give a warning for an error
X */
X	void
Xbeep()
X{
X	flush_buffers(FALSE);		/* flush internal buffers */
X	if (p_vb)
X	{
X		if (T_VB && *T_VB)
X		    outstr(T_VB);
X		else
X		{						/* very primitive visual bell */
X	        msg("    ^G");
X	        msg("     ^G");
X	        msg("    ^G ");
X	        msg("     ^G");
X	        msg("       ");
X			showmode();			/* may have deleted the mode message */
X		}
X	}
X	else
X	    outchar('\007');
X}
X
X/* 
X * Expand environment variable with path name.
X * If anything fails no expansion is done and dst equals src.
X */
X	void
Xexpand_env(src, dst, dstlen)
X	char	*src;			/* input string e.g. "$HOME/vim.hlp" */
X	char	*dst;			/* where to put the result */
X	int		dstlen;			/* maximum length of the result */
X{
X	char	*tail;
X	int		c;
X	char	*var;
X
X	if (*src == '$')
X	{
X/*
X * The variable name is copied into dst temporarily, because it may be
X * a string in read-only memory.
X */
X		tail = src + 1;
X		var = dst;
X		c = dstlen - 1;
X		while (c-- > 0 && *tail && isidchar(*tail))
X			*var++ = *tail++;
X		*var = NUL;
X/*
X * It is possible that vimgetenv() uses IObuff for the expansion, and that the
X * 'dst' is also IObuff. This works, as long as 'var' is the first to be copied
X * to 'dst'!
X */
X		var = (char *)vimgetenv(dst);
X		if (var && (strlen(var) + strlen(tail) + 1 < (unsigned)dstlen))
X		{
X			strcpy(dst, var);
X			strcat(dst, tail);
X			return;
X		}
X	}
X	strncpy(dst, src, (size_t)dstlen);
X}
X
X/*
X * Compare two file names and return TRUE if they are different files.
X * For the first name environment variables are expanded
X */
X	int
Xfullpathcmp(s1, s2)
X	char *s1, *s2;
X{
X#ifdef UNIX
X	struct stat st1, st2;
X	char buf1[MAXPATHL];
X
X	expand_env(s1, buf1, MAXPATHL);
X	if (stat(buf1, &st1) == 0 && stat(s2, &st2) == 0 &&
X				st1.st_dev == st2.st_dev && st1.st_ino == st2.st_ino)
X		return FALSE;
X	return TRUE;
X#else
X	char buf1[MAXPATHL];
X	char buf2[MAXPATHL];
X
X	expand_env(s1, buf2, MAXPATHL);
X	if (FullName(buf2, buf1, MAXPATHL) && FullName(s2, buf2, MAXPATHL))
X		return strcmp(buf1, buf2);
X	/*
X	 * one of the FullNames() failed, file probably doesn't exist.
X	 */
X	return TRUE;
X#endif
X}
X
X/*
X * get the tail of a path: the file name.
X */
X	char *
Xgettail(fname)
X	char *fname;
X{
X	register char *p1, *p2;
X
X	for (p1 = p2 = fname; *p2; ++p2)	/* find last part of path */
X	{
X		if (ispathsep(*p2))
X			p1 = p2 + 1;
X	}
X	return p1;
X}
X
X/*
X * return TRUE if 'c' is a path separator.
X */
X	int
Xispathsep(c)
X	int c;
X{
X#ifdef UNIX
X	return (c == PATHSEP);		/* UNIX has ':' inside file names */
X#else
X# ifdef MSDOS
X	return (c == ':' || c == PATHSEP || c == '/');
X# else
X	return (c == ':' || c == PATHSEP);
X# endif
X#endif
X}
END_OF_FILE
if test 16465 -ne `wc -c <'vim/src/misccmds.c'`; then
    echo shar: \"'vim/src/misccmds.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/misccmds.c'
# end of 'vim/src/misccmds.c'
fi
if test -f 'vim/src/version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vim/src/version.c'\"
else
echo shar: Extracting \"'vim/src/version.c'\" \(15699 characters\)
sed "s/^X//" >'vim/src/version.c' <<'END_OF_FILE'
X/* vi:ts=4 sw=4 tw=77
X *
X *
X * VIM - Vi IMproved
X *
X * Code Contributions By:	Bram Moolenaar			mool@oce.nl
X *							Tim Thompson			twitch!tjt
X *							Tony Andrews			onecom!wldrdg!tony 
X *							G. R. (Fred) Walter		watmath!watcgl!grwalter 
X */
X
X/*
X Started with Stevie version 3.6 (Fish disk 217) - GRWalter (Fred)
X
X VIM 1.0	- Changed so many things that I felt that a new name was required
X			(I didn't like the name Stevie that much: I don't have an ST).
X			- VIM stands for "Vi IMitation".
X			- New storage structure, MULTI-LEVEL undo and redo,
X			improved screen output, removed an awful number of bugs,
X			removed fixed size buffers, added counts to a lot of commands,
X			added new commands, added new options, added 'smart indent',
X			added recording mode, added script files, moved help to a file,
X			etc. etc. etc.
X			- Compiles under Manx/Aztec C 5.0. You can use "rez" to make VIM
X			resident.
X			- Bram Moolenaar (Mool)
X
X VIM 1.09 - spaces can be used in tags file instead of tabs (compatible with
X			Manx ctags).
X
X VIM 1.10 - Csh not required anymore for CTRL-D. Search options /e and /s added.
X			Shell option implemented. BS in replace mode does not delete
X			character. Backspace, wrapmargin and tags options added.
X			Added support for Manx's QuickFix mode (just like "Z").
X			The ENV: environment variables instead of the Old Manx environment
X			variables are now used, because Vim was compiled with version 5.0d
X			of the compiler. "mool" library not used anymore. Added index to
X			help screens.
X
X VIM 1.11 - removed bug that caused :e of same file, but with name in upper case,
X			to re-edit that file.
X
X VIM 1.12 - The second character of several commands (e.g. 'r', 't', 'm') not
X			:mapped anymore (UNIX vi does it like this, don't know why); Some
X			operators did not work when doing a 'l' on the last character in
X			a line (e.g. 'yl'); Added :mapping when executing registers;
X			Removed vi incompatibility from 't' and 'T' commands; :mapping! also
X			works for command line editing; Changed a few details to have Vim
X			run the macros for solving a maze and Towers of Hanoi! It now also
X			runs the Turing machine macros!
X
X VIM 1.13 - Removed a bug for !! on empty line. "$" no longer puts cursor at
X			the end of the line when combined with an operator. Added
X			automatic creation of a script file for recovery after a crash.
X			Added "-r" option. Solved bug for not detecting end of script file.
X			".bak" is now appended, thus "main.c" and "main.h" will have
X			separate backup files.
X
X VIM 1.14 - Removed a few minor bugs. Added "-n" option to skip autoscript.
X			Made options more Vi compatible. Improved ^C handling. On serious
X			errors typahead and scripts are discarded. 'U' is now correctly
X			undone with 'u'. Fixed showmatch() handling of 'x' and '\x'.
X			Solved window size dependency for scripts by adding ":winsize"
X			commands to scripts. This version released on Fish disk 591.
X
X VIM 1.15 - No extra return in recording mode (MCHAR instead of MLINE buffer).
X			plural() argument is now a long. Search patterns shared between
X			:g, :s and /. After recovery a message is given. Overflow of mapbuf
X			is detected. Line number possible with :read. Error message when
X			characters follow a '$' in a search pattern. Cause for crash
X			removed: ":s/pat/repl/g" allocated not enough memory. Option
X			"directory" added. Option "expandtab" added. Solved showmode non-
X			functioning. Solved bug with window resizing. Removed some *NULL
X			references. CTRL-], * and # commands now skips non-identifier
X			characters. Added tag list, CTRL-T, :pop and :tags commands.
X			Added jump list, CTRL-O and CTRL-I commands. Added "shiftround"
X			option. Applied AUX and Lattice mods from Juergen Weigert.
X			Finally made linenr_t a long, files can be > 65000 lines!
X			:win command could be written to script file halfway a command.
X			Option shelltype added. With ^V no mapping anymore.
X			Added :move, :copy, :t, :mark and :k. Improved Ex address parsing.
X			Many delimiters possible with :s.
X
X VIM 1.16 - Solved bug with zero line number in Ex range. Added file-number to
X			jump list. Solved bug when scrolling downwards. Made tagstack vi
X			compatible. Cmdline editing: CTRL-U instead of '@'. Made Vim DICE
X			compatible. Included regexp improvements from Olaf Seibert,
X			mapstring() removed. Removed bug with CTRL-U in insert mode.
X			Count allowed before ". Added uppercase (file) marks. Added
X			:marks command. Added joinspaces option. Added :jumps command. Made
X			jumplist compatible with tag list. Added count to :next and :Next.
X
X VIM 1.17 - Removed '"' for Ex register name. Repaired stupid bug in tag code.
X			Now compiled with Aztec 5.2a. Changed Arpbase.h for use with 2.04
X			includes. Added repdel option. Improved :set listing. Added count
X			to 'u' and CTRL-R commands. "vi:" and "ex:" in modelines must now
X			be preceded with a blank. Option "+command" for command line and
X		    :edit command added.
X
X VIM 1.18 - Screen was not updated when all lines deleted. Readfile() now
X			puts cursor on first new line. Catch strange disk label.
X			Endless "undo line missing" loop removed. With empty file 'O' would
X			cause this. Added window size reset in windexit(). Flush .vim file
X			only when buffer has been changed. Added the nice things from
X			Elvis 1.5: Added "equalprg" and "ruler" option. Added quoting.
X			Added third meaning to 'backspace' option: backspacing over start
X			of insert. Added "-c {command}" command line option. Made generating
X			of prototypes automatically. Added insert mode command CTRL-O and
X			arrow keys. CTRL-T/CTRL-D now always insert/delete indent. When
X			starting an edit on specified lnum there was redraw of first lines.
X			Added 'inputmode' option. Added CTRL-A and CTRL-S commands. '`' is
X			now exclusive (as it should be). Added digraphs as an option.
X			Changed implementation of parameters. Added :wnext command.
X			Added ':@r' command. Changed handling of CTRL-V in command line.
X			Block macros now work. Added keyword lookup command 'K'. Added
X			CTRL-N and CTRL-P to command line editing. For DOS 2.0x the Flush
X			function is used for the autoscript file; this should solve the
X			lockup bug. Added wait_return to msg() for long messages.
X
X VIM 1.19 - Changes from Juergen Weigert:
X			Terminal type no longer restricted to machine console. New
X			option -T terminal. New set option "term". Builtin termcap 
X			entries for "amiga", "ansi", "atari", "nansi", "pcterm". 
X			Ported to MSDOS. New set option "textmode" ("tx") to control 
X			CR-LF translation. CTRL-U and CTRL-D scroll half a screen full,
X			rather than 12 lines. New set option "writebackup" ("wb") to 
X			disable even the 'backup when writing' feature.
X			Ported to SunOS. Full termcap support. Does resize on SIGWINCH.
X
X			Made storage.c portable. Added reading of ".vimrc". Added
X			'helpfile' option. With quoting the first char of an empty line
X			is inverted. Optimized screen updating a bit. Startup code 
X			looks for VIMINIT variable and .vimrc file first. Added option
X			helpfile. Solved bug of inserting deletes: redefined ISSPECIAL.
X			Changed inchar() to use key codes from termcap. Added parameters
X			for terminal codes. Replaced aux device handling by amiga window
X			handling. Added optional termcap code. Added 'V', format
X			operator.
X
X VIM 1.20 - wait_return only ignores CR, LF and space. 'V' also works for
X            single line. No redrawing while formatting text. Added CTRL-Z.
X			Added usage of termcap "ks" and "ke". Fixed showmatch().
X			Added timeout option. Added newfile argument to readfile().
X
X VIM 1.21 - Added block mode. Added 'o' command for quoting. Added :set inv.
X			Added pos2ptr(). Added repeating and '$' to Quoting.
X
X VIM 1.22 - Fixed a bug in doput() with count > 1.
X			Port to linux by Juergen Weigert included.
X			More unix semantics in writeit(), forceit flag ignores errors while 
X			preparing backup file. For UNIX, backup is now copied, not moved.
X			When the current directory is not writable, vim now tries a backup
X			in the directory given with the backupdir option. For UNIX, raw mode
X			has now ICRNL turned off, that allowes ^V^M. Makefiles for BSD,
X			SYSV, and linux unified in makefile.unix. For MSDOS
X			mch_get_winsize() implemented. Reimplemented builtin termcaps in
X			term.c and term.h. set_term() now handles all cases. Even builtins
X			when TERMCAP is defined. Show "..." while doing filename completion.
X
X VIM 1.23 -	Improved MSDOS version: Added function and cursor keys to builtin 
X			pcterm. Replaced setmode by settmode, delay by vim_delay and 
X			delline by dellines to avoid name conflicts. Made F1 help key.
X			Renamed makecmdtab to mkcmdtab and cmdsearch to csearch for 
X			8 char name limit. Wildcard expansion adds *.* to names without a 
X			dot. Added shell execution.
X			For unix: writeit() overwrites readonly files when forced write,
X			more safety checks. Termcap buffer for linux now 2048 bytes.
X			Expandone() no longer appends "*" to file name. Added "graphic"
X			option. Added ':' command to quoting.
X			
X VIM 1.24	Adjusted number of spaces inserted by dojoin(). MSDOS version uses 
X			searchpath() to find helpfile. Fixed a few small problems. Fixed 
X			nasty bug in getperm() for SAS 6.0. Removed second argument from 
X			wait_return(). Script files accessed in binary mode with MSDOS. 
X			Added 'u' and 'U' commands to quoting (make upper or lower case). 
X			Added "CTRL-V [0-9]*" to enter any byte value. Fixed doput().
X			Dodis() displays register 0. Added CTRL-B to insert mode. Attempt 
X			to fix the lockup bug by adding Delay() to startscript(). -v 
X			option now implies -n option. doformat() added to improve 'V' 
X			command. Replace bool_t with int. Fixed handling of \& and ~ in
X			regsub(). Added interrupt handling in msdos.c for ctrl-break and
X			critical errors. Added scrolljump option. Added :stop. Added -d
X			argument. Fixed bug in quickfix startup from cli. Fixed enforcer
X			hit with aux:. Added CTRL-C handling to unix.c. Fixed "O<BS><CR>" 
X			bug with autoindent. Worked around :cq not working by adding a 
X			printf()!? Added default mapping for MSDOS PageUp etc. Fixed 
X			cursor position after 'Y'. Added shift-cursor commands. Changed 
X			ExpandFile() to keep names with errors. Added CLEAR and CURSUPD 
X			arguments to updateScreen(). Fixed CTRL-@ after a change command.
X			modname() changes '.' into '_'. Added emptyrows to screen.c. 
X			Fixed redo of search with offset. Added count to 'z' command. 
X			Made :so! work with :global. Added writing of cursor postition to 
X			startscript(). Minimized terminal requirements. Fixed problem 
X			with line in tags file with mixed spaces and tabs. Fixed problem 
X			with pattern "\\" in :s and :g. This version posted on Usenet.
X
X VIM 1.25	Improved error messages for :set. Open helpfile in binary mode 
X			for MSDOS. Fixed ignorecase for Unix in cstrncmp(). Fixed read 
X			from NULL with :tags after vim -t. Repaired 'z' command. Changed 
X			outnum() for >32767. In msdos.c flushbuf did write(1, .. instead 
X			of write(0, .. Added secure to fix security. Fixed pointer 
X			use after free() bug in regsub() (made :s fail under MSDOS). 
X			Added nofreeNULL(), needed for some UNIXes. Improved window 
X			resizing for Unix. Fixed messages for report == 0. Added 
X			bsdmemset(). Changed a few small things for portability. Added 
X			:list. Made '0' and '^' exclusive. Fixed regexp for /pattern* 
X			(did /(pattern)* instead of /pattern(n)*). Added "']" and "'[". 
X			Changed Delay(2L) into Delay(10L). Made 'timeout' option 
X			vi-compatible, added 'ttimeout' option. Changed TIOCSETP to 
X			TIOCSETN in unix.c. Added "ti" and "te" termcap entries, makes 
X			sun cmdtool work. Added stop- and starttermcap(). Use cooked 
X			output for listings on Amiga only. Added "starting" flag, no ~s 
X			anymore with every startup. Modname made portable; Added 
X			'shortname' option, Fixed problems with .vim file on messydos. 
X			Global .exrc/.vimrc for Unix added. Added patches for SCO Xenix. 
X			Add :w argument to list of alternate file names. Applied a few 
X			changes for HPUX. Added Flock in writeit() for safety. Command 
X			":'a,'bm." moved to 'b instead of current line. Argument in 
X			'shell' option allowed. Re-implemented :copy and :move. Fixed 
X			BS-CR-BS on empty line bug in edit.c. -t option was ignored if 
X			there is a file ".vim". Changed amiga.c to work without 
X			arp.library for dos 2.0. Fixed "\$" and "\^" in regexp. Fixed 
X			pipe in filter command. Fixed CTRL-U and CTRL-D. With '}' indent 
X			in front of the cursor is included in the operated text. Fixed 
X			tag with '[' in search pattern. Added CTRL-V to 'r'. Fixed "tc" 
X			entry in termlib.c. term_console now default off. Added :noremap 
X			and ^V in :map argument. Replaced CTRL by Ctrl because some 
X			unixes have this already. Fixed "Empty file" message disappearing 
X			when there is no .exrc file. Added CTRL-K for entering digraphs. 
X			Removed escape codes from vim.hlp, added handling of inversion to 
X			help().
X
X VIM 1.26	For Unix: Removed global .exrc; renamed global .vimrc to vimrc.
X 			Moved names of *rc and help files to makefile. Added various 
X			little changes for different kinds of Unix. Changed CR-LF 
X			handling in dosource() for MSDOS. Added :mkvimrc. Fixed 
X			WildExpand in unix.c for empty file. Fixed incompatibility with 
X			msdos share program (removed setperm(fname, 0) from fileio.c).
X			Added ":set compatible". Fixed 'history=0'.
X
X VIM 1.27	Added USE_LOCALE. Changed swapchar() to use toupper() and 
X			tolower(). Changed init order: .vimrc before EXINIT. Half-fixed 
X			lines that do not fit on screen. A few minor bug fixes. Fixed 
X			typehead bug in Read() in unix.c. Added :number. Reset IXON flag 
X			in unix.c for CTRL-Q. In tags file any Ex command can be used. Ex 
X			search command accepts same flags as normal search command. Fixed 
X			'?' in tag search pattern. 'New file' message was wrong when 'bk' 
X			and 'wb' options were both off.
X
X Vim 1.29 to 1.31 and Vim 2.0	See ../readme2.0.
X
X Vim 2.0	When reading and writing files and in some other cases use short
X 			filename if ":cd" not used. Fixes problem with networks. Deleted
X			"#include <ctype.h>" from regexp.c. ":v" without argument was not
X			handled correctly in doglob(). Check for tail recursion removed
X			again, because it forbids ":map! foo ^]foo", which is OK. Removed
X			redraw on exit for msdos. Fixed return value for FullName in
X			unix.c. Call_shell does not always use cooked mode, fixes problem
X			with typing CR while doing filename completion in unix. "r<TAB>"
X			now done by edit() to make expandtab works. Implemented FullName
X			for msdos. Implemented the drive specifier for the :cd command for
X			MSDOS. Added CTRL-B and CTRL-E to command line editing. Del key
X			for msdos not mapped to "x" in command mode, could not delete last
X			char of count. Fixed screen being messed up with long commands
X			when 'sc' is set. Fixed use of CR-LF in tags file. Added check
X			for abbreviation when typing ESC or CTRL-O in insert mode. Doing
X			a ":w file" does overwrite when "file" is the current file. Unmap
X			will check for 'to' string if there is no match with 'from'
X			string; Fixes ":unab foo" after ":ab foo bar". Fixed problem in
X			addstar() for msdos: Check for negative index. Added possibility
X			to switch off undo ":set ul=-1". Allow parameters to be set to
X			numbers >32000 for machines with 16 bit ints.
X*/
X
Xchar		   *Version = "VIM 2.0";
X#if !defined(__DATE__) || !defined(__TIME__)
Xchar		   *longVersion = "Vi IMproved 2.0 (1993 Dec 14) by Bram Moolenaar";
X#else
Xchar		   *longVersion = "Vi IMproved 2.0 (" __DATE__ " " __TIME__ ") by Bram Moolenaar";
X#endif
END_OF_FILE
if test 15699 -ne `wc -c <'vim/src/version.c'`; then
    echo shar: \"'vim/src/version.c'\" unpacked with wrong size!
fi
chmod +x 'vim/src/version.c'
# end of 'vim/src/version.c'
fi
echo shar: End of archive 7 \(of 25\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

===============================================================================
Bram Moolenaar                             | DISCLAIMER:  This  note  does  not
Oce Nederland B.V., Research & Development | necessarily represent the position
p.o. box 101, 5900 MA  Venlo               | of  Oce-Nederland  B.V.  Therefore
The Netherlands        phone +31 77 594077 | no liability or responsibility for
UUCP: mool@oce.nl        fax +31 77 595473 | whatever will be accepted.

exit 0 # Just in case...
