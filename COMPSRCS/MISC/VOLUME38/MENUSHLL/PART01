Newsgroups: comp.sources.misc
From: aburt@du.edu (Andrew Burt)
Subject: v38i066:  menushell - A Unix Menuing Shell, Part01/03
Message-ID: <csm-v38i066=menushell.142311@sparky.Sterling.COM>
X-Md4-Signature: cb60de66a2f7124280c392ce76691a21
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Fri, 30 Jul 1993 19:23:39 GMT
Approved: kent@sparky.sterling.com

Submitted-by: aburt@du.edu (Andrew Burt)
Posting-number: Volume 38, Issue 66
Archive-name: menushell/part01
Environment: BSD, with untested SVR4 diffs

This is the net release of Mshell, a Unix menuing shell.  Mshell was designed
to be easy for users to use and easy for admins to write menus for; menus
can be in any format and can execute any code your shell can.  For example,
a simple menu file would be:

	who	Who's on the system		l	list your files
	<1>	Send e-mail			<2>	Games menu
	*****
	who	who | sort
	l	ls -l | more
	1	mail prompt=To_whom help=/how/to/send/mail
	2	menu games

Users see the top part, key in the choice, which runs the code at the bottom.
Top part is shown to users verbatim, bottom part has lots of flexibility
in forming command lines and specifying help/man files.

This program is released "as is", but remains owned by myself and the
University of Denver.  You're welcome to use mshell, and I'd like to
hear about any bugs, and get copies of improvements, but neither I nor
DU support this software.  I'm only releasing it since so many folks
have asked for a copy.

Mshell was written to shield Nyx users (and other non-Unix gurus, like
mathematicians and secretaries in the department) from "raw" Unix.  It
is as flexible as you can get (supports full shell capabilties like
pipes, etc. inside the menu commands) but simple to write menus for.

See mshell.1 for information on writing menus & using it.
A sample menu and some more complex menu options are in the "sample.men" file.
More can be found on Nyx, where this has been in service for many years.

Nyx (rhymes with Unix of course) is a free, public access Unix system. 
We charge no fees, so all improvements have to come from donations of
money and equipment.  All labor is volunteer (I run Nyx on my own time,
others help, etc.).

If you use mshell, a donation to the Nyx project would be kindly appreciated
although not required.  Such donations go toward improving Nyx.  Send to:

	Prof. Andrew Burt
	Department of Mathematics and Computer Science
	John Green Hall
	University of Denver
	Denver, CO  80208

	Make check payable to "University of Denver", and write "For Nyx" on it.

Indeed, you're welcome to try Nyx -- log into Nyx as:

	- telnet to nyx.cs.du.edu (130.253.192.68), user 'new'.
	- call 303-871-3324

History:

I wrote the first version of mshell as a Bourne shell script.  A student,
Dinesh Punjabi, was desperate for a project, so he rewrote the script
into C.  As with most student labor :-) it was minimally functional, so
I've hacked it a bunch over the years.  It still has much of Dinesh's
style, though my style creeps in every so often (i.e., the code is no longer
entirely consistent looking!).  I've used it at various sites, one of
which required conversion to SVR2.  The SVR2 code hasn't been tested
since; however, in sysvdiffs.mar93 is a set of diffs purported to make it
work with SVR4 -- I haven't tested them so they're not incorprated into
the main logic.  The BSD code is 4.2ish (rather, Pyramid OSx 4.1's clone
of BSD 4.2+).  #ifdef'd updates are certainly welcome!
-------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README mshell.man setenv.c sysvdiffs.B
# Wrapped by kent@sparky on Mon Jul 26 16:41:39 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(3065 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XDate: July 15, 1993
XFrom: Andrew Burt <aburt@du.edu>
XSubject:  Menu shell
XArchive-name: menushell
XEnvironment: BSD, with untested SVR4 diffs
X
XThis is the net release of Mshell, a Unix menuing shell.  Mshell was designed
Xto be easy for users to use and easy for admins to write menus for; menus
Xcan be in any format and can execute any code your shell can.  For example,
Xa simple menu file would be:
X
X	who	Who's on the system		l	list your files
X	<1>	Send e-mail			<2>	Games menu
X	*****
X	who	who | sort
X	l	ls -l | more
X	1	mail prompt=To_whom help=/how/to/send/mail
X	2	menu games
X
XUsers see the top part, key in the choice, which runs the code at the bottom.
XTop part is shown to users verbatim, bottom part has lots of flexibility
Xin forming command lines and specifying help/man files.
X
XThis program is released "as is", but remains owned by myself and the
XUniversity of Denver.  You're welcome to use mshell, and I'd like to
Xhear about any bugs, and get copies of improvements, but neither I nor
XDU support this software.  I'm only releasing it since so many folks
Xhave asked for a copy.
X
XIf you use mshell, a donation to the Nyx project would be kindly appreciated.
XSuch donations go toward improving Nyx.  Send to:
X
X	Prof. Andrew Burt
X	Department of Mathematics and Computer Science
X	John Green Hall
X	University of Denver
X	Denver, CO  80208
X
X	Make check payable to "University of Denver", and write "For Nyx" on it.
X
XIndeed, you're welcome to try Nyx -- log into Nyx as:
X
X	- telnet to nyx.cs.du.edu (130.253.192.68), user 'new'.
X	- call 303-871-3324
X
XNyx (rhymes with Unix of course) is a free, public access Unix system. 
XWe charge no fees, so all improvements have to come from donations of
Xmoney and equipment.  All labor is volunteer (I run Nyx on my own time,
Xothers help, etc.).
X
XMshell was written to shield Nyx users (and other non-Unix gurus, like
Xmathematicians and secretaries in the department) from "raw" Unix.  It
Xis as flexible as you can get (supports full shell capabilties like
Xpipes, etc. inside the menu commands) but simple to write menus for.
X
XSee mshell.1 for information on writing menus & using it.
XA sample menu and some more complex menu options are in the "sample.men" file.
XMore can be found on Nyx, where this has been in service for many years.
X
XHistory:
X
XI wrote the first version of mshell as a Bourne shell script.  A student,
XDinesh Punjabi, was desperate for a project, so he rewrote the script
Xinto C.  As with most student labor :-) it was minimally functional, so
XI've hacked it a bunch over the years.  It still has much of Dinesh's
Xstyle, though my style creeps in every so often (i.e., the code is no longer
Xentirely consistent looking!).  I've used it at various sites, one of
Xwhich required conversion to SVR2.  The SVR2 code hasn't been tested
Xsince; however, in sysvdiffs.mar93 is a set of diffs purported to make it
Xwork with SVR4 -- I haven't tested them so they're not incorprated into
Xthe main logic.  The BSD code is 4.2ish (rather, Pyramid OSx 4.1's clone
Xof BSD 4.2+).  #ifdef'd updates are certainly welcome!
END_OF_FILE
  if test 3065 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'mshell.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mshell.man'\"
else
  echo shar: Extracting \"'mshell.man'\" \(12707 characters\)
  sed "s/^X//" >'mshell.man' <<'END_OF_FILE'
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
XNAME
X     mshell - menu oriented shell
X
XSYNOPSIS
X     mshell [-r] [-s] initial-menu
X
XDESCRIPTION
X     mshell is a menuing program designed to be used as  a  login
X     shell  or  as  the primary program in a wrapper shell script
X     (to set environment, etc.).  Menus are intended to be simple
X     to create without sacrificing flexibility.
X
XOPTIONS
X     -r   mshell runs in "restricted" mode, where  only  commands
X          found  in  a  command-list file can be executed.  I.e.,
X          some users may have full access  to  all  menu  options
X          while  others  run under restriction.  The command-list
X          file  is  currently  hardwired  via  the   COMMAND_LIST
X          #define  in the source, but could easily be turned into
X          a command line parameter.  Further,  -r  inhibits  user
X          replies to prompts even for options that are active (to
X          prevent users from entering  metacharacters  which  may
X          allow   unintended   access).    Commands   must  match
X          *exactly*  the  way  they  are  listed  in  the  menu's
X          "cmd=..."  line, e.g., full path or no path.  See below
X          for additional thoughts on security.
X
X     -s   Prevents the execution of !command at the  menu  prompt
X          and prevents users from typing shell meta-characters in
X          their replies to prompts.   See  below  for  additional
X          thoughts on security.
X
X     initial-menu
X          The name or path to the initial menu: If the name has a
X          / in it, that is used as the path to the starting menu;
X          if no /, then  $MENUDIR/initial-menu  is  used  as  the
X          menu.
X
XNOTES
X  Startup files
X     If the file .mshellrc exists in $HOME, it is run  via  "sh".
X     Useful  to run some intro commands (e.g., personal stty set-
X     tings), but note it cannot be used to set variables or other
X     internal state elements.
X
X  Logging
X     If you define LOGDIR (in Makefile) to an existing dir,  then
X     user  activity will be logged.  (I suggest the dir should be
X     mode 733 so users can't poke around as easily).  Every  menu
X     pick  a  user  makes  is appended to a file named with their
X     username; these  files  grows  without  bound  and  must  be
X     cleaned up manually.
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   1
X
X
X
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
X  Environment variables
X     Work inside menu values (as $VAR), as does ~ for home dir.
X
X  Built-in commands
X     cd and setenv are built in.   The  built-in  command  'menu'
X     invokes mshell recursively (i.e., does not create a new pro-
X     cess for submenus).
X
X  Security
X     Take great care if you  want  to  use  mshell  in  a  secure
X     environment.   It  can  be an experiment in futility.  Using
X     the -s and -r options you can control  what  programs  users
X     may  run;  however,  note that with just -s users can likely
X     find clever ways to subvert the security and  get  a  shell.
X     Even  with  both  -r  and -s in effect, many of the programs
X     you're likely to allow users to run may have  ways  to  gain
X     unintended  access.   For  example,  'more'  allows users to
X     invoke the shell ('!' command) or vi (e.g. the 'v' command),
X     from which they can gain instant shell access.  Monitor what
X     commands you allow in -r very carefully.  Even the  simplest
X     shell scripts may be subvertible!
X
X     It helps to set the SHELL environment variable to  something
X     like  /bin/true,  or  better yet, a command that echoes "You
X     can't have a shell, sorry."  This still won't foil a  deter-
X     mined attack, of course.
X
X     Consider a wrapper around the menu that  removes  .mshellrc,
X     for example.
X
X     Note that even with all this, mshell  shouldn't  be  trusted
X     for  genuine security, since it's nearly impossible to elim-
X     inate the ways one can get a shell (I gave it a good  whack,
X     modifying  binaries  of  various programs, hacking on source
X     for others, etc.; it's too much hassle and still can be cir-
X     cumvented).
X
X  Multiple commands
X     If the user types pick1,pick2,pick3 then each will  be  exe-
X     cuted  as  if  the  ',' were newlines.  Use 'top,...' to get
X     "absolute" picks, starting at the top of the menu tree.
X
X  Macros
X     A file named $HOME/.mshellmac is read at startup for macros.
X     Macros look like:
X          name=commands
X     For example:
X          hist=top,i,h,x
X     which on Nyx means <top, info menu, 'h' for history, 'x'  to
X     exit menu back to main>.  Execute macros as
X          #name
X     such as
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   2
X
X
X
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
X          #hist
X     Macros may be execute inside multi-command lines, as in
X          foo,#hist,bar
X     and inside other macros, like
X          foo=a,#hist,b,c
X
X  Online help
X     If a menu item has help=filename  in  the  definition,  that
X     filename  is  printed  prior  to  execution or prompt input.
X     Users can do 'help o' for an option 'o', in which  case,  if
X     man=xxx  is  set,  "man  xxx"  is  invoked.   Failing  that,
X     "cmd=zzz" causes "man zzz" to be run.  Thus one may let  the
X     cmd=  setting  default  except  where this invokes the wrong
X     manual page or one wants to  specific  a  non-man(1)  manual
X     page.
X
XMENU DEFINITION
X     Format of menu file:
X
X          screen layout
X          *****
X          keyword <tab> action_description
X
X     The top part of the screen is what the users sees --  it  is
X     just text, put whatever you want there; there is no specific
X     format rules, just make it look good.  The bottom  describes
X     what  commands have what action.  The bottom is comprised of
X     two tab-separated columns: a keyword and an action  descrip-
X     tion.   The keyword can be any string (without a tab in it),
X     usually  alpha-numeric.   Presumably  these   keywords   are
X     displayed  in the layout portion so users know what to type,
X     but that's up to you to ensure.  (That is, there is no mark-
X     ing  of  items  in  the  top  unless  you want to for visual
X     effect.  Further, you can have "invisible" menu  options  by
X     listing  them in the bottom but not the top; the drawback is
X     that you could have inoperative options  if  you  list  them
X     above and forget to list them below.)
X
X     The simplest action description is just a shell command,  as
X     in
X          w    who | sort
X     which would execute "who|sort" when a user selects 'w'  from
X     the menu.  The actions can be any shell code.
X
X     The action descriptions can be built using keywords as  fol-
X     lows:
X
X     cmd=name_of_command
X          like arg=, but  no  _  translation.   In  addition,  it
X          specifies  this  this  as  the command to run 'man' for
X          help.
X
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   3
X
X
X
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
X     prompt=prompt_to_print
X          Prints prompt (will be followed by  colon  and  space).
X          The user's response is interpolated as the next parame-
X          ter.
X
X     arg=literal
X          Argument  is  included  at  this  position  in  command
X          string.   This  is  also  the default if no keyword= is
X          given.
X
X     aarg=literal_to_append
X          Like arg=, but no space put before it; e.g., to  append
X          a filename extension after a prompted value.
X
X     aprompt=prompt_to_append
X          Prompts and  appends  to  previous  argument  (e.g.,  a
X          literal value).
X
X     help=name_of_helpfile
X          Prints said helpfile (printed immediately, i.e., before
X          input or execution of command).
X
X     man=name_of_manual
X          Specifies manual entry to use  for  'help';  useful  if
X          cmd=  isn't  set  to  something  you want a 'man' on or
X          there isn't anything interesting to set cmd= to.
X
X     Notice that no <type>= is the same as "arg=".
X
X     In [a]prompt= and [a]arg=, underscores will be translated to
X     spaces  on  output  and  are mandatory in multi-word strings
X     (i.e., if you have "prompt=foo bar" the prompt will  be  foo
X     and  bar  will  be  looked on as the next action description
X     word; instead do "prompt=foo_bar").  Tabs in  strings  don't
X     work (could be handled similar to _ for space, but aren't at
X     present).
X
X     The result is put  into  a  string;  if  it  has  any  meta-
X     characters  that  should  be  handled  by  a shell, then the
X     result is fed to system() so the shell (csh  in  particular)
X     can  deal  with  it.  Otherwise, mshell executes the command
X     directly.
X
X     If the first keyword listed in the  description  section  is
X     "_init",  this  command will be executed upon entry into the
X     menu (before any selection).
X
X     At "Enter choice" prompt, a response beginning with ! causes
X     the  remainder  of the line to be executed verbatim.  (E.g.,
X     !who will run a who.)  (Assuming this has not been  disabled
X     by -s.)
X
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   4
X
X
X
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
X     All menus respond to certain built-in options, namely 'x' to
X     exit  the menu, menu), and 'help xxx' to invoke the help for
X     option xxx.
X
X     A sample menu file might be:
X                              Main menu
X                              =========
X
X          f    Upload/Download file menu     i    Information...
X          s    Status/options/users menu     u    Unix file access menu
X
X          c    Communications menu -- bulletins, NetNews, mail, chat
X
X          p    Programming menu
X          e    Education menu           w    Word processing menu
X          g    Games menu               gr   Graphics menu
X          faq  Frequently Asked Questions    o    Organization menus
X
X          in      Introduce yourself to other Nyx users
X
X          fund Info on the "fund drive" to speed up ol' Nyx
X
X          fb   Send feedback to sysop (comments, questions, etc.)
X          *****
X          u    cmd=menu arg=$mendir/file.men
X          c    cmd=menu $mendir/comm.men
X          w    cmd=menu $mendir/wp.men
X          p    cmd=menu $mendir/prog.men
X          g    cmd=menu $mendir/games.men
X          s    cmd=menu $mendir/stat.men
X          gr   cmd=menu $mendir/graphics.men
X          i    cmd=menu $mendir/info.men
X          f    cmd=menu $mendir/updownload.men
X          e    cmd=menu $mendir/edu.men
X          o    cmd=menu $mendir/org.men
X          fb   /u5/bin/comment
X          in   /u5/bin/introduction
X          fund cmd=more -d $mendir/info/fund.drive
X          faq  cmd=more -d $mendir/info/faq
X
X          Some other random example commands:
X
X          _init     cmd=cd $downloaddir
X          used cmd=du -s $HOME
X          s    cmd=fgrep prompt=String_to_find prompt=Files_to_search_(sep._by_spaces)
X          fn   cmd=find $HOME_-name prompt=File -print
X          co   echo 'lines____words____chars'; cmd=wc prompt=File
X          ec   cmd=crypt prompt=Input_file > prompt=Output_file
X          a    cd $dldir/.areas/ aprompt=Area# help=$dldir/.areas/.list
X          l    (echo -n "Current area: ";pwd;sort .catalog)|lineup|more
X          s    mail prompt=To help=$mendir/facmain.help
X
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   5
X
X
X
X
X
X
XMshell(1)                USER COMMANDS                  Mshell(1)
X
X
X
XRECOMMENDATIONS
X  Use full pathnames for filenames.
X  Use multiple main menus for different
X  You'll need various script files as
X  Look on Nyx (nyx.cs.du.edu, login as
XAUTHOR
X     Original shell script version by Andrew Burt of the  Univer-
X     sity  of  Denver  department  of  math and computer science.
X     Initially coded in C by Dinesh Punjabi (yes,  as  a  student
X     project).   Subsequent hacks and maintenance by Andrew Burt,
X     reachable as aburt@du.edu.
X
XBUGS
X     No doubt.  I've heard tales of occasional glitches where the
X     menus get very hosed up, but haven't searched for causes.  I
X     suspect there are some memory leaks lurking around  as  well
X     in  some  of  the  older  code.   The reliance on fixed size
X     strings stems from the original,  and  should  be  replaced.
X     The  original  System V code has not been tested in ages and
X     may no longer even compile; the  newer  diffs  haven't  been
X     tested.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
XSun Release 4.1     Last change: 13 July 1993                   6
X
X
X
END_OF_FILE
  if test 12707 -ne `wc -c <'mshell.man'`; then
    echo shar: \"'mshell.man'\" unpacked with wrong size!
  fi
  # end of 'mshell.man'
fi
if test -f 'setenv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'setenv.c'\"
else
  echo shar: Extracting \"'setenv.c'\" \(1717 characters\)
  sed "s/^X//" >'setenv.c' <<'END_OF_FILE'
X/*   setenv.c   */
X#include "mshell.h"
X
Xextern char **environ;
X
X#define NULL	0
X#define NO_ROOM	(-1)
X#define O_K	0
X
Xsetenv(var, value)
Xregister char *var, *value;
X{
X	char **env = environ;
X	char **newenv, **newenv_base;
X	char *entry;		/* pointer to the new, malloc'd entry */
X	char *getenv(), *malloc(), *calloc();
X	int var_len;
X
X	var_len = strlen(var);	/* used often (maybe) */
X
X	/* make room for the new entry */
X
X	entry = malloc(var_len+strlen(value)+2);
X	if (entry == NULL)
X		return(NO_ROOM);
X
X	/* copy in the entry */
X
X	sprintf(entry, "%s=%s", var, value);
X
X	/* see where to put it now */
X
X	if (getenv(var) != NULL)	/* if it has a value, change it */
X		for (; *env != NULL; env++) {
X			if (strncmp(*env, var, var_len) == 0) {
X				*env =  entry;
X				break;	/* for */
X			}
X		}
X	else {				/* remake the whole list, and add it */
X		newenv = (char **) calloc(sarsize(env)+2, sizeof(char *));
X		if (newenv == NULL)
X			return(NO_ROOM);
X		newenv_base = newenv;
X
X		while (*newenv++ = *env++)
X			;			/* copy table */
X		*--newenv = entry;		/* add new one at end */
X		*++newenv = NULL;		/* end list */
X		environ = newenv_base;		/* and make it final */
X	}
X
X	return(O_K);
X
X} /* setenv */
X
X
X/*
X * sarsize(sar) -- determine size of
X * NULL terminated string array ("sar"),
X * such as argv or envp.
X * Returned value is akin to argc:
X * sar[returned_val] == NULL.
X */
X
Xsarsize(sar)
Xregister char **sar;
X{
X	register size = 0;
X
X	if (sar == NULL)	/* if no array to begin with, return 0 */
X		return(0);
X
X	while (sar[size] != NULL)
X		size++;
X
X	return(size);
X
X} /* sarsize */
X
X
Xprintenv()
X{
X	char **env = environ;
X
X	printf("--------------------\n");
X	while (*env != NULL)
X		printf("%s\n", *env++);
X	printf("--------------------\n");
X
X
X}
END_OF_FILE
  if test 1717 -ne `wc -c <'setenv.c'`; then
    echo shar: \"'setenv.c'\" unpacked with wrong size!
  fi
  # end of 'setenv.c'
fi
if test -f 'sysvdiffs.B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysvdiffs.B'\"
else
  echo shar: Extracting \"'sysvdiffs.B'\" \(36374 characters\)
  sed "s/^X//" >'sysvdiffs.B' <<'END_OF_FILE'
Xdiff -rc msh/macro.c msh.orig/macro.c
X*** msh/macro.c	Sun Mar 14 11:32:17 1993
X--- msh.orig/macro.c	Mon Mar 15 23:26:29 1993
X***************
X*** 1,7 ****
X  #include "mshell.h"
X  
X- static char macro_rcsid[] = "$Header: /usr3/src/msh/RCS/macro.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X- 
X  struct macro {
X  	DL_NODE n;
X  	char *name;
X--- 1,5 ----
X***************
X*** 10,16 ****
X  
X  static DLIST macrolist;
X  
X! char *mac_lookup(char *name)
X  {
X  	struct macro *m;
X  
X--- 8,16 ----
X  
X  static DLIST macrolist;
X  
X! char *
X! mac_lookup(name)
X! char *name;
X  {
X  	struct macro *m;
X  
X***************
X*** 21,34 ****
X  
X  	/* note: could do a help/list macro here as builtin */
X  
X! 	printw("No definition for macro %s\n", name);
X  	return("");
X  }
X  
X! load_macrofile(char *f)
X  {
X  	FILE *fp;
X! 	char line[MAXLEN], name[MAXLEN], def[MAXLEN], *strsave(char *);
X  	struct macro *m;
X  
X  	if ((fp = fopen(f, "r")) == NULL)
X--- 21,35 ----
X  
X  	/* note: could do a help/list macro here as builtin */
X  
X! 	printf("No definition for macro %s\n", name);
X  	return("");
X  }
X  
X! load_macrofile(f)
X! char *f;
X  {
X  	FILE *fp;
X! 	char line[MAXLEN], name[MAXLEN], def[MAXLEN];
X  	struct macro *m;
X  
X  	if ((fp = fopen(f, "r")) == NULL)
X***************
X*** 40,46 ****
X  	while (fgets(line, MAXLEN, fp))
X  		if (
X  			sscanf(line, "%[^=]=%[^\n]\n", name, def) == 2 &&
X! 			(m = (struct macro *)getnode(sizeof(*m))) &&
X  			(m->name = strsave(name)) &&
X  			(m->def = strsave(def))
X  		)
X--- 41,47 ----
X  	while (fgets(line, MAXLEN, fp))
X  		if (
X  			sscanf(line, "%[^=]=%[^\n]\n", name, def) == 2 &&
X! 			(m = getnode(sizeof(*m))) &&
X  			(m->name = strsave(name)) &&
X  			(m->def = strsave(def))
X  		)
Xdiff -rc msh/mail.c msh.orig/mail.c
X*** msh/mail.c	Sun Mar 14 11:32:17 1993
X--- msh.orig/mail.c	Mon Mar 15 23:26:27 1993
X***************
X*** 1,11 ****
X  #include "mshell.h"
X  
X- static char mail_rcsid[] = "$Header: /usr3/src/msh/RCS/mail.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X  
X- #ifdef SYSV
X- #include <string.h>
X- #endif
X- 
X  extern char     G_homevar      [];
X  extern char     G_uservar      [];
X  extern char 	G_termvar      [];
X--- 1,6 ----
X***************
X*** 14,29 ****
X  extern int      G_mailsize; 
X  extern struct   stat G_st;
X  
X! void check_for_new_mail(char *message)
X  {
X  	off_t new_mail_size;
X  
X! 	stat(G_mailfile, &G_st);
X  
X  	new_mail_size = G_st.st_size;
X  
X  	if ( new_mail_size > G_mailsize )
X! 		strcpy( message, MAIL_MESSAGE );
X  
X  	G_mailsize = new_mail_size;
X  }
X--- 9,25 ----
X  extern int      G_mailsize; 
X  extern struct   stat G_st;
X  
X! check_for_new_mail (message)
X! char * message;
X  {
X  	off_t new_mail_size;
X  
X! 	stat (G_mailfile, &G_st);
X  
X  	new_mail_size = G_st.st_size;
X  
X  	if ( new_mail_size > G_mailsize )
X! 		strcpy ( message, MAIL_MESSAGE );
X  
X  	G_mailsize = new_mail_size;
X  }
Xdiff -rc msh/main.c msh.orig/main.c
X*** msh/main.c	Sun Mar 14 11:32:18 1993
X--- msh.orig/main.c	Mon Mar 15 23:26:27 1993
X***************
X*** 7,20 ****
X   */
X  #include "mshell.h"
X  
X- static char main_rcsid[] = "$Header: /usr3/src/msh/RCS/main.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X- 
X  char     G_homevar      [] = { "$HOME" };
X- #ifdef SYSV
X- char     G_uservar      [] = { "$LOGNAME" };
X- #else
X  char     G_uservar      [] = { "$USER" };
X- #endif
X  char 	 G_termvar      [] = { "$TERM" };
X  char     G_mailfile     [WORDLEN];
X  char     G_mail_message [WORDLEN];
X--- 7,14 ----
X***************
X*** 23,29 ****
X  int	 G_shell_ok;
X  int	 G_limited = FALSE;
X  
X! main(int argc, char **argv)
X  {
X  	char menu[WORDLEN];
X  	char menuname[WORDLEN];
X--- 17,26 ----
X  int	 G_shell_ok;
X  int	 G_limited = FALSE;
X  
X! main (argc, argv)
X! int     argc;
X! char ** argv;
X! 
X  {
X  	char menu[WORDLEN];
X  	char menuname[WORDLEN];
X***************
X*** 30,42 ****
X  	char *progname = argv[0];
X  
X  	G_shell_ok = TRUE;
X- 	/* -s secure -- !commands not allowed */
X  	if ( argc > 1 && strcmp(argv[1], "-s") == 0 ) {
X  		G_shell_ok = FALSE;
X  		argc--;
X  		argv++;
X  	}
X- 	/* -r restricted -- only commands in #define COMMAND_LIST allowed */
X  	else if ( argc > 1 && strcmp(argv[1], "-r") == 0 ) {
X  		G_limited = TRUE;
X  		G_shell_ok = FALSE;
X--- 27,37 ----
X***************
X*** 45,51 ****
X  	}
X  
X  	if ( argc < 2 ) {
X! 		printf("Usage: %s <primary menu name>\n", progname);
X  		exit (1);
X  	}
X  
X--- 40,46 ----
X  	}
X  
X  	if ( argc < 2 ) {
X! 		printf ("Usage: %s <primary menu name>\n", progname);
X  		exit (1);
X  	}
X  
X***************
X*** 64,70 ****
X  	if ( getppid() == 1 )			/* Mshell is login shell */
X  #endif
X  		set_terminal_attributes();
X- 	clear_screen();
X  	set_resource_limits();
X  
X  	rc();
X--- 59,64 ----
X***************
X*** 72,82 ****
X  	load_macrofile(GLOBAL_MACRO_FILE);
X  	load_macrofile(".mshellmac");
X  
X! 	M_Shell(argv[1]);
X  	bye(0);
X  }
X  
X! void rc()
X  {
X  	if (!G_shell_ok)
X  		return;
X--- 66,76 ----
X  	load_macrofile(GLOBAL_MACRO_FILE);
X  	load_macrofile(".mshellmac");
X  
X! 	M_Shell (argv[1]);
X  	bye(0);
X  }
X  
X! rc()
X  {
X  	if (!G_shell_ok)
X  		return;
X***************
X*** 88,110 ****
X  }
X  
X  #ifndef LOGDIR
X! #define LOGDIR "/usr/local/mshell/logs"
X  #endif
X  
X  FILE *logfp;
X! 
X! void openlog()
X  {
X  	struct passwd *pw;
X! 	char fn[80];
X  
X! 	if ((pw = getpwuid(getuid())) == NULL) return;
X  	sprintf(fn, "%s/%s", LOGDIR, pw->pw_name);
X  	logfp = fopen(fn, "a");
X  	chmod(fn, 0600);
X  }
X  
X! void log(char *s1, char *s2)
X  {
X! 	if (logfp) fprintf(logfp, "%s %s\n", s1, s2);
X  }
X--- 82,106 ----
X  }
X  
X  #ifndef LOGDIR
X! #define LOGDIR "/u1/logs"
X  #endif
X  
X  FILE *logfp;
X! openlog()
X  {
X  	struct passwd *pw;
X! 	char fn[32];
X  
X! 	if ((pw = getpwuid(getuid())) == NULL)
X! 		return;
X  	sprintf(fn, "%s/%s", LOGDIR, pw->pw_name);
X  	logfp = fopen(fn, "a");
X  	chmod(fn, 0600);
X  }
X  
X! log(s1, s2)
X! char *s1, *s2;
X  {
X! 	if (logfp)
X! 		fprintf(logfp, "%s %s\n", s1, s2);
X  }
Xdiff -rc msh/menulogin msh.orig/menulogin
X*** msh/menulogin	Sun Mar 14 21:19:49 1993
X--- msh.orig/menulogin	Mon Mar 15 23:26:30 1993
X***************
X*** 1,45 ****
X  #!/bin/sh
X- # $Header: /usr3/src/msh/RCS/menulogin,v 1.2 1993/03/15 05:19:30 root Exp root $:
X  
X! PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:.
X  
X! # Initialized vars
X! MAX_DISKALLOWED=100		# in 1KB increment
X! HOME_LOWWARN=20000		# qed
X! HOME_LOWMARK=5000		# qed
X  
X! mendir=/usr/local/mshell/menus
X! dldir=$HOME/download
X  
X! /bin/echo "Configuring..."
X! 
X! set `du -s $HOME`
X! /bin/echo "FYI, your disk usage is: $1 K."
X! if [ "$1" -gt $MAX_DISKALLOWED ]; then
X! 	/bin/echo "Reminder, please keep your home dirs small (under 100 K)."
X! 	/bin/echo "There's plenty of temp space elsewhere."
X! 
X! 	free=`df -k /home | tail -1 | awk '{ print $4 }'`
X! 	if [ "$free" -lt $HOME_LOWWARN ]; then
X! 		/bin/echo "Note that free space (for EVERYONE) is tight: only $free K."
X! 		/bin/echo "(And you are using more than 100 K -- hint hint.)"
X! 		/bin/echo "Use the 'du2' option on the status menu for more info."
X! 		if [ "$free" -lt $HOME_LOWMARK ]; then
X! 			/bin/echo "***Indeed, with so little space, consider it imperative -- clean up immediately!"
X  		fi
X  	fi
X  fi
X  
X! if [ -r $HOME/.termrc ]; then
X! 	. $HOME/.termrc
X  else
X  	TERM=vt100
X  	TERMCAP=/etc/termcap
X  fi
X  if [ -r $HOME/.editor ]; then
X  	EDITOR=$HOME/.editor
X  else
X! 	EDITOR=/usr/local/bin/e
X  fi
X  if [ -f $HOME/.biffy ]; then
X  	biff y
X--- 1,43 ----
X  #!/bin/sh
X  
X! # Sample login wrapper -- name as /.../menulogin or /.../menuloginsh
X! # and it'll allow shell or not as it ends with ...sh.  Could also be
X! # modified to enable -r for some naming scheme.
X! # This junk is pretty Nyx specific, and outdated, but the idea's the thing.
X  
X! echo "Configuring..."
X  
X! set `du -s .`
X! echo "FYI, your disk usage is: $1 K."
X! if [ "$1" -gt 100 ]; then
X! 	echo "Reminder, please keep your home dirs small (under 100 K)."
X! 	echo "There's plenty of temp space elsewhere."
X  
X! 	free=`/u1/bin/pdf`
X! 	if [ "$free" -lt 20000 ]; then
X! 		echo "Note that free space (for EVERYONE) is tight: only $free K."
X! 		echo "(And you are using more than 100 K -- hint hint.)"
X! 		echo "Use the 'du2' option on the status menu for more info."
X! 		if [ "$free" -lt 5000 ]; then
X! 			echo "***Indeed, with so little space, consider it imperative -- clean up immediately!"
X  		fi
X  	fi
X  fi
X  
X! mendir=/u5/lib/menus
X! dldir=/u3/lib/download
X! if [ -r $HOME/.termtype ]; then
X! 	. $HOME/.termtype
X  else
X+ #	TERM=dw1
X  	TERM=vt100
X  	TERMCAP=/etc/termcap
X  fi
X+ PATH=/u1/bin:/u5/bin:/usr/ucb:/bin:/usr/bin:.
X  if [ -r $HOME/.editor ]; then
X  	EDITOR=$HOME/.editor
X  else
X! 	EDITOR=/u5/bin/smile
X  fi
X  if [ -f $HOME/.biffy ]; then
X  	biff y
X***************
X*** 53,64 ****
X  case $0 in
X  	*sh)
X  		# shell is ok
X! 		SHELL=/bin/sh
X  		opt=""
X  		;;
X  	*)
X  		# shell is not allowed
X! 		SHELL=/usr/local/bin/noshell
X  		opt="-s"
X  		;;
X  esac
X--- 51,62 ----
X  case $0 in
X  	*sh)
X  		# shell is ok
X! 		SHELL=/bin/csh
X  		opt=""
X  		;;
X  	*)
X  		# shell is not allowed
X! 		SHELL=/u1/bin/noshell
X  		opt="-s"
X  		;;
X  esac
X***************
X*** 75,82 ****
X  	RNINIT=$HOME/.rninit
X  	export RNINIT
X  fi
X! 
X! #/usr/ucb/stty -tabs crt erase '^h' kill '^u' intr '^c'
X! /bin/echo -n "Hit ENTER to continue..."
X  read xxx
X! exec /usr/local/bin/mshell $opt main
X--- 73,79 ----
X  	RNINIT=$HOME/.rninit
X  	export RNINIT
X  fi
X! stty -tabs crt susp undef dsusp undef -nohang erase '^h' kill '^u' intr '^c'
X! echo "Hit ENTER to continue...\c"
X  read xxx
X! exec /u5/bin/mshell $opt main
Xdiff -rc msh/mshell.c msh.orig/mshell.c
X*** msh/mshell.c	Sun Mar 14 11:32:18 1993
X--- msh.orig/mshell.c	Mon Mar 15 23:26:28 1993
X***************
X*** 1,24 ****
X  #include "mshell.h"
X- 
X- static char mshell_rcsid[] = "$Header: /usr3/src/msh/RCS/mshell.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X- 
X  #include <setjmp.h>
X! #ifdef SYSV
X! #include <string.h>
X! #endif
X  
X  extern char     G_homevar      [];
X  extern char     G_uservar      [];
X  extern char 	G_termvar      [];
X! extern char     G_mailfile     [];
X! extern char     G_mail_message [];
X  extern int      G_mailsize; 
X  extern int      G_shell_ok; 
X  extern struct   stat G_st;
X  
X  /* ================== */
X! void M_Shell(char *m)
X  /* ================== */
X  {
X  	char opt           [WORDLEN],
X  	     opt1          [OPTLEN],
X--- 1,23 ----
X  #include "mshell.h"
X  #include <setjmp.h>
X! char * index ();
X  
X+ 
X  extern char     G_homevar      [];
X  extern char     G_uservar      [];
X  extern char 	G_termvar      [];
X! extern char     G_mailfile     [WORDLEN];
X! extern char     G_mail_message [WORDLEN];
X  extern int      G_mailsize; 
X  extern int      G_shell_ok; 
X  extern struct   stat G_st;
X  
X  /* ================== */
X! M_Shell (m)
X  /* ================== */
X+ 
X+ char *m;
X+ 
X  {
X  	char opt           [WORDLEN],
X  	     opt1          [OPTLEN],
X***************
X*** 43,54 ****
X  	static int topenvset;
X  
X  	menu_flag = FALSE;
X! 	signal(SIGHUP,  exit);
X! 	signal(SIGINT,  SIG_IGN);	/* ignore all ^C interrupts */
X! 	signal(SIGQUIT, SIG_IGN);	/* ignore all ^\ interrupts */
X! 	signal(SIGTSTP, SIG_IGN);	/* ignore all ^Z interrupts */
X! 	signal(SIGPIPE, SIG_IGN);	/* ignore dead pipes */
X! 	log("M_Shell: enter", m);
X  
X  	while TRUE {
X  
X--- 42,53 ----
X  	static int topenvset;
X  
X  	menu_flag = FALSE;
X! 	signal (SIGHUP,  exit);
X! 	signal (SIGINT,  SIG_IGN);	/* ignore all ^C interrupts */
X! 	signal (SIGQUIT, SIG_IGN);	/* ignore all ^\ interrupts */
X! 	signal (SIGTSTP, SIG_IGN);	/* ignore all ^Z interrupts */
X! 	signal (SIGPIPE, SIG_IGN);	/* ignore dead pipes */
X! 	log("enter", m);
X  
X  	while TRUE {
X  
X***************
X*** 67,80 ****
X  
X  			if ( firsttime ) {
X  				firsttime = FALSE;
X! 				search_menu_array(menu_array, idx, "_init",
X  					action_string, &invalid_option);
X  				if (!invalid_option) {
X  					while (substitute(action_string))
X  						;
X! 					get_actions(action_string,
X  						exec_string, args);
X! 					execute_command(exec_string, args);
X  				}
X  				else	
X  					invalid_option = FALSE;
X--- 66,79 ----
X  
X  			if ( firsttime ) {
X  				firsttime = FALSE;
X! 				search_menu_array (menu_array, idx, "_init",
X  					action_string, &invalid_option);
X  				if (!invalid_option) {
X  					while (substitute(action_string))
X  						;
X! 					get_actions (action_string,
X  						exec_string, args);
X! 					execute_command (exec_string, args);
X  				}
X  				else	
X  					invalid_option = FALSE;
X***************
X*** 81,97 ****
X  			}
X  
X  			if ( invalid_option )
X! 				printw("No such choice as '%s'.", opt);
X  
X  			if (!moreinput())
X! 				printw("\tSelect choice [or help, x, top, bye]: ");
X! 			refresh();
X! 
X  			opt[0] = 0;
X! 			read_input_line(opt);
X  			log("	", opt);
X  			invalid_option = FALSE;
X! 			addch('\n');
X  
X  			/* if first character of option is an "!"    *
X  			 * character then invoke the remaining line  *
X--- 80,94 ----
X  			}
X  
X  			if ( invalid_option )
X! 				printf ("No such choice as '%s'.", opt);
X  
X  			if (!moreinput())
X! 				printf ("\tSelect choice [or help, x, top, bye]: ");
X  			opt[0] = 0;
X! 			read_input_line (opt);
X  			log("	", opt);
X  			invalid_option = FALSE;
X! 			putchar('\n');
X  
X  			/* if first character of option is an "!"    *
X  			 * character then invoke the remaining line  *
X***************
X*** 101,114 ****
X  			if ( !opt[0] )
X  				continue;
X  			else if ( opt[0] == EXCLAIM && G_shell_ok ) {
X- 				endwin();
X  				system(opt+1);
X  				unix_flag = TRUE;
X! 				refresh();
X! 				wait_for_user();
X  			}
X  			else {
X! 				search_menu_array(menu_array, idx, opt,
X  					action_string, &invalid_option);
X  			}
X  		}
X--- 98,109 ----
X  			if ( !opt[0] )
X  				continue;
X  			else if ( opt[0] == EXCLAIM && G_shell_ok ) {
X  				system(opt+1);
X  				unix_flag = TRUE;
X! 				wait_for_user ();
X  			}
X  			else {
X! 				search_menu_array (menu_array, idx, opt,
X  					action_string, &invalid_option);
X  			}
X  		}
X***************
X*** 126,132 ****
X  
X  	/* remove actual values of commands and arguments from action-string */
X  	/* ================================================================= */
X! 		get_actions(action_string, exec_string, args);
X  
X  	/* display any prompt and get values if specified in the command line */
X  	/* ================================================================== */
X--- 121,127 ----
X  
X  	/* remove actual values of commands and arguments from action-string */
X  	/* ================================================================= */
X! 		get_actions (action_string, exec_string, args);
X  
X  	/* display any prompt and get values if specified in the command line */
X  	/* ================================================================== */
X***************
X*** 133,160 ****
X  		opt1[0] = EOS;
X  		opt2[0] = EOS;
X  
X! 		if ( index(opt, BLANK) != NULL )
X! 			sscanf(opt, "%s %s", opt1, opt2);
X  		else
X! 			strcpy(opt1, opt);
X  
X! 		if ( strcmp(opt1, HELP) == 0 ) {
X! 			if ( strcmp(opt2, NULLSTR) == 0 )
X  				strcpy(opt2, prompt("Help on which choice"));
X  
X! 			search_menu_array(menu_array, idx, opt2,
X  				   action_string, &invalid_option);
X  
X! 			if ( strcmp(action_string, NULLSTR) == 0 ) {
X  				invalid_option = TRUE;
X! 				printw("\tNo such help option name as: %s!!!\n", opt2);
X! 				refresh();
X  			}
X  			else {
X  				tmpword[0] = EOS;
X! 				extract_action_word(action_string, MAN, tmpword, 0);
X! 				if ( strcmp(tmpword, NULLSTR) == 0 ) 
X! 					extract_action_word(action_string, CMDVAL, tmpword, 0);
X  				if (strcmp(tmpword, NULLSTR) != 0)
X  					do_man(tmpword);
X  			}
X--- 128,154 ----
X  		opt1[0] = EOS;
X  		opt2[0] = EOS;
X  
X! 		if ( index (opt, BLANK) != NULL )
X! 			sscanf (opt, "%s %s", opt1, opt2);
X  		else
X! 			strcpy (opt1, opt);
X  
X! 		if ( strcmp (opt1, HELP) == 0 ) {
X! 			if ( strcmp (opt2, NULLSTR) == 0 )
X  				strcpy(opt2, prompt("Help on which choice"));
X  
X! 			search_menu_array (menu_array, idx, opt2,
X  				   action_string, &invalid_option);
X  
X! 			if ( strcmp (action_string, NULLSTR) == 0 ) {
X  				invalid_option = TRUE;
X! 				printf ("\tNo such help option name as: %s\!\!\n", opt2);
X  			}
X  			else {
X  				tmpword[0] = EOS;
X! 				extract_action_word (action_string, MAN, tmpword, 0);
X! 				if ( strcmp (tmpword, NULLSTR) == 0 ) 
X! 					extract_action_word (action_string, CMDVAL, tmpword, 0);
X  				if (strcmp(tmpword, NULLSTR) != 0)
X  					do_man(tmpword);
X  			}
X***************
X*** 161,167 ****
X  
X  /*			if ( invalid_option ) {*/
X  				invalid_option = FALSE;
X! 				wait_for_user();
X  /*			}*/
X  			continue;
X  		}
X--- 155,161 ----
X  
X  /*			if ( invalid_option ) {*/
X  				invalid_option = FALSE;
X! 				wait_for_user ();
X  /*			}*/
X  			continue;
X  		}
X***************
X*** 184,219 ****
X  			for (i = 0; i < LINES; i++)
X  				if (menu_array[i])
X  					free(menu_array[i]);
X- 			menu_flag = FALSE;
X  			longjmp(topenv, 1);
X  		}
X! 		else if (strcmp(args[0], "menu") == 0 )
X! 			M_Shell(args[1]);
X  		else {
X! 			execute_command(exec_string, args);
X  			wait_for_user();
X  		}
X  	}
X  }
X  
X! do_man(char *entry)
X  {
X! 	char cmd[WORDLEN], *p;
X  
X  	if (p = rindex(entry, '/'))
X  		entry = p+1;
X  
X  	sprintf(cmd, "man %s", entry);
X- 	refresh();
X- 	endwin();
X  	system(cmd);
X- 	refresh();
X  }
X  
X! bye(int status)
X  {
X! 	printw("\nLogging out -- come back again soon...\n\n");
X! 	refresh();
X! 	endwin();
X  	exit(status);
X  }
X--- 178,209 ----
X  			for (i = 0; i < LINES; i++)
X  				if (menu_array[i])
X  					free(menu_array[i]);
X  			longjmp(topenv, 1);
X  		}
X! 		else if ( strcmp(args[0], "menu") == 0 )
X! 			M_Shell (args[1]);
X  		else {
X! 			execute_command (exec_string, args);
X  			wait_for_user();
X  		}
X  	}
X  }
X  
X! do_man(entry)
X! char *entry;
X  {
X! 	char cmd[WORDLEN], *p, *rindex();
X  
X  	if (p = rindex(entry, '/'))
X  		entry = p+1;
X  
X  	sprintf(cmd, "man %s", entry);
X  	system(cmd);
X  }
X  
X! bye(status)
X! int status;
X  {
X! 	printf("\nLogging out -- come back again soon...\n\n");
X  	exit(status);
X  }
Xdiff -rc msh/mshell.h msh.orig/mshell.h
X*** msh/mshell.h	Sun Mar 14 11:32:18 1993
X--- msh.orig/mshell.h	Mon Mar 15 23:26:29 1993
X***************
X*** 1,24 ****
X- #ifndef _MSHELL_H
X- #define _MSHELL_H
X- 
X  #include <stdio.h>
X  #include <curses.h>
X  #include <pwd.h>
X  #include <sys/types.h>
X- #include <sys/signal.h>
X  #include <sys/stat.h>
X- 
X  #ifdef BSD
X  #include <sys/dir.h>		/* accessing the directory structure	*/
X  #include <sgtty.h>		/* struct for terminal attributes       */
X! #else
X  #ifdef SYSV
X  #define index	strchr
X  #define rindex	strrchr
X  /* #include <termio.h>		/* do this if curses.h doesn't */
X  #endif
X- #endif
X- 
X  #include "dl.h"
X  
X  #define  BLANK           ' '
X--- 1,18 ----
X  #include <stdio.h>
X  #include <curses.h>
X+ #include <sys/signal.h>
X  #include <pwd.h>
X  #include <sys/types.h>
X  #include <sys/stat.h>
X  #ifdef BSD
X  #include <sys/dir.h>		/* accessing the directory structure	*/
X  #include <sgtty.h>		/* struct for terminal attributes       */
X! #endif
X  #ifdef SYSV
X  #define index	strchr
X  #define rindex	strrchr
X  /* #include <termio.h>		/* do this if curses.h doesn't */
X  #endif
X  #include "dl.h"
X  
X  #define  BLANK           ' '
X***************
X*** 54,69 ****
X  #define  SETENV		 "setenv"
X  
X  #ifndef  MAILDIR
X! #define  MAILDIR         "/var/mail"
X  #endif
X  #ifndef  MENUDIR
X  #define  MENUDIR         "/nyx/lib/menus"
X  #endif
X  #ifndef  GLOBAL_MACRO_FILE
X! #define  GLOBAL_MACRO_FILE         "/usr/local/mshell/menus/macros"
X  #endif
X  #ifndef  COMMAND_LIST
X! #define  COMMAND_LIST         "/usr/local/mshell/menus/commands"
X  #endif
X  
X  #ifndef TRUE	/* curses.h may #define */
X--- 48,63 ----
X  #define  SETENV		 "setenv"
X  
X  #ifndef  MAILDIR
X! #define  MAILDIR         "/usr/spool/mail/"
X  #endif
X  #ifndef  MENUDIR
X  #define  MENUDIR         "/nyx/lib/menus"
X  #endif
X  #ifndef  GLOBAL_MACRO_FILE
X! #define  GLOBAL_MACRO_FILE         "/nyx/lib/menus/macros"
X  #endif
X  #ifndef  COMMAND_LIST
X! #define  COMMAND_LIST         "/nyx/lib/menus/commands"
X  #endif
X  
X  #ifndef TRUE	/* curses.h may #define */
X***************
X*** 76,114 ****
X  	char prev [WORDLEN];
X  };
X  
X- #ifndef __STDC__
X  #define void	int
X! #endif
X! 
X! int 	all_blanks();
X  void    change_directory();
X! void    check_for_new_mail(char *);
X! void 	helpfile_display();
X! int	display_menu (char *menu_name, char *menu_array[],
X! 			int *menu_flag, int *idx);
X! void 	display_prompts();
X! void 	execute_command(char *, char *args[]);
X! void 	extract_actions();
X! void 	extract_action_word();
X  void	filter_leading_trailing_blanks_tabs ();
X! char 	*find_string(char [], char []);
X! void    find_user_details();
X! char	*in_string();
X  void    initialize ();
X! void 	insert_string(char [], char [], int);
X  void    invoke_unix_system ();
X! void 	M_Shell(char *);
X! void 	read_input_line(char *);
X! void 	remove_string(char [], int, int);
X! int 	replace_string(char [], char [], char []);
X  void 	search_menu_array ();
X! int 	strsearch();
X  void 	set_terminal_attributes ();
X! int    	setenv();
X! void 	wait_for_user();
X! void	rc();
X! void	openlog();
X! void	clear_screen();
X! char	*strsave(char *);
X! 
X! #endif /* _MSHELL_H */
X--- 70,98 ----
X  	char prev [WORDLEN];
X  };
X  
X  #define void	int
X! int 	all_blanks ();
X  void    change_directory();
X! void    check_for_new_mail ();
X! void 	helpfile_display ();
X! void 	display_menu ();
X! void 	display_prompts ();
X! void 	execute_command ();
X! void 	extract_actions ();
X! void 	extract_action_word ();
X  void	filter_leading_trailing_blanks_tabs ();
X! char * 	find_string ();
X! void    find_user_details ();
X! char *  in_string ();
X  void    initialize ();
X! void 	insert_string ();
X  void    invoke_unix_system ();
X! void 	M_Shell ();
X! void 	read_input_line ();
X! void 	remove_string ();
X! int 	replace_string ();
X  void 	search_menu_array ();
X! int 	strsearch ();
X  void 	set_terminal_attributes ();
X! int    	setenv ();
X! void 	wait_for_user ();
Xdiff -rc msh/setenv.c msh.orig/setenv.c
X*** msh/setenv.c	Sun Mar 14 11:32:19 1993
X--- msh.orig/setenv.c	Mon Mar 15 23:26:28 1993
X***************
X*** 1,13 ****
X  /*   setenv.c   */
X  #include "mshell.h"
X  
X- static char setenv_rcsid[] = "$Header: /usr3/src/msh/RCS/setenv.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X- 
X- #ifdef SYSV
X- #include <stdlib.h>
X- #include <string.h>
X- #endif
X- 
X  extern char **environ;
X  
X  #define NULL	0
X--- 1,6 ----
X***************
X*** 14,27 ****
X  #define NO_ROOM	(-1)
X  #define O_K	0
X  
X! setenv(register char *var, register char *value)
X  {
X  	char **env = environ;
X  	char **newenv, **newenv_base;
X  	char *entry;		/* pointer to the new, malloc'd entry */
X- #ifndef SYSV
X  	char *getenv(), *malloc(), *calloc();
X- #endif
X  	int var_len;
X  
X  	var_len = strlen(var);	/* used often (maybe) */
X--- 7,19 ----
X  #define NO_ROOM	(-1)
X  #define O_K	0
X  
X! setenv(var, value)
X! register char *var, *value;
X  {
X  	char **env = environ;
X  	char **newenv, **newenv_base;
X  	char *entry;		/* pointer to the new, malloc'd entry */
X  	char *getenv(), *malloc(), *calloc();
X  	int var_len;
X  
X  	var_len = strlen(var);	/* used often (maybe) */
X***************
X*** 71,77 ****
X   * sar[returned_val] == NULL.
X   */
X  
X! sarsize(register char **sar)
X  {
X  	register size = 0;
X  
X--- 63,70 ----
X   * sar[returned_val] == NULL.
X   */
X  
X! sarsize(sar)
X! register char **sar;
X  {
X  	register size = 0;
X  
X***************
X*** 90,97 ****
X  {
X  	char **env = environ;
X  
X! 	printw("--------------------\n");
X  	while (*env != NULL)
X! 		printw("%s\n", *env++);
X! 	printw("--------------------\n");
X  }
X--- 83,92 ----
X  {
X  	char **env = environ;
X  
X! 	printf("--------------------\n");
X  	while (*env != NULL)
X! 		printf("%s\n", *env++);
X! 	printf("--------------------\n");
X! 
X! 
X  }
Xdiff -rc msh/settatr.c msh.orig/settatr.c
X*** msh/settatr.c	Sun Mar 14 11:32:19 1993
X--- msh.orig/settatr.c	Mon Mar 15 23:26:28 1993
X***************
X*** 2,10 ****
X  #include <sys/time.h>
X  #include <sys/resource.h>
X  
X! static char settatr_rcsid[] = "$Header: /usr3/src/msh/RCS/settatr.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X! 
X! void set_terminal_attributes()
X  {
X  #ifdef BSD
X  	struct sgttyb  sg;
X--- 2,8 ----
X  #include <sys/time.h>
X  #include <sys/resource.h>
X  
X! set_terminal_attributes()
X  {
X  #ifdef BSD
X  	struct sgttyb  sg;
X***************
X*** 51,58 ****
X  	ioctl ( 0, TCSETA, &t );
X  #endif
X  }
X! 
X! void set_resource_limits()
X  {
X  	struct rlimit lim;
X  
X--- 49,55 ----
X  	ioctl ( 0, TCSETA, &t );
X  #endif
X  }
X! set_resource_limits()
X  {
X  	struct rlimit lim;
X  
Xdiff -rc msh/string.c msh.orig/string.c
X*** msh/string.c	Sun Mar 14 11:32:19 1993
X--- msh.orig/string.c	Mon Mar 15 23:26:28 1993
X***************
X*** 1,17 ****
X  #include "mshell.h"
X  
X! #ifdef SYSV
X! #include <string.h>
X! #include <stdlib.h>
X  #endif
X- #include <ctype.h>
X  
X- static char string_rcsid[] = "$Header: /usr3/src/msh/RCS/string.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X  
X  /* function to find the position of sub_string in main_string 
X   * ---------------------------------------------------------- */
X  
X! strsearch(char main_string[], char sub_string[])
X  {
X  	int start_mstring = 0, start_sstring = 0, 
X  	    factor = 0, answer, main_pos = 0;
X--- 1,15 ----
X  #include "mshell.h"
X  
X! #ifdef BSD
X! #define strchr	index
X  #endif
X  
X  
X  /* function to find the position of sub_string in main_string 
X   * ---------------------------------------------------------- */
X  
X! strsearch (main_string, sub_string)
X! char main_string[], sub_string[];
X  {
X  	int start_mstring = 0, start_sstring = 0, 
X  	    factor = 0, answer, main_pos = 0;
X***************
X*** 47,53 ****
X  
X  /* function to remove string starting at a specified position  
X   * ----------------------------------------------------------  */
X! void remove_string(char main_string[], int start_index, int no_of_bytes)
X  {
X  	int index, offset;
X  
X--- 45,55 ----
X  
X  /* function to remove string starting at a specified position  
X   * ----------------------------------------------------------  */
X! 
X! remove_string (main_string, start_index, no_of_bytes )
X! char main_string[];
X! int  start_index, no_of_bytes;
X! 
X  {
X  	int index, offset;
X  
X***************
X*** 60,70 ****
X  		main_string [index] = main_string [index + no_of_bytes];
X  
X  	main_string[index] = EOS;
X  }				/* end of function remove_string */
X  
X  /* replace string function 
X   * ----------------------- */
X! int replace_string(char main_string[], char old_string[], char new_string[])
X  {
X  	int  pos;
X  
X--- 62,76 ----
X  		main_string [index] = main_string [index + no_of_bytes];
X  
X  	main_string[index] = EOS;
X+ 
X  }				/* end of function remove_string */
X  
X  /* replace string function 
X   * ----------------------- */
X! 
X! int replace_string (main_string, old_string, new_string)
X! char main_string[256], old_string[256], new_string[256]; 
X! 
X  {
X  	int  pos;
X  
X***************
X*** 82,88 ****
X  
X  /* function to find insert sub-string in main-string at a specific position
X   * ------------------------------------------------------------------------ */
X! void insert_string(char main_string[], char sub_string[], int position)
X  {
X  	int i, j, offset;
X  
X--- 88,98 ----
X  
X  /* function to find insert sub-string in main-string at a specific position
X   * ------------------------------------------------------------------------ */
X! 
X! insert_string ( main_string, sub_string, position )
X! char main_string [], sub_string [];
X! int  position;
X! 
X  {
X  	int i, j, offset;
X  
X***************
X*** 100,109 ****
X  	}
X  }
X  
X  #define NULL	0
X  #define STRLEN	256
X  
X! char *findvar(char *s)
X  {
X  	static char var[STRLEN];
X  	char *p, *v = var, *strchr();
X--- 110,123 ----
X  	}
X  }
X  
X+ #include <ctype.h>
X+ 
X  #define NULL	0
X  #define STRLEN	256
X  
X! char *
X! findvar(s)
X! char *s;
X  {
X  	static char var[STRLEN];
X  	char *p, *v = var, *strchr();
X***************
X*** 121,127 ****
X  	return(var);
X  }
X  
X! substitute(char *s)
X  {
X  	char var[STRLEN], *v_in_s, *getenv();
X  
X--- 135,142 ----
X  	return(var);
X  }
X  
X! substitute(s)
X! char *s;
X  {
X  	char var[STRLEN], *v_in_s, *getenv();
X  
X***************
X*** 139,153 ****
X  	char s[STRLEN];
X  
X  	while (1) {
X! 		printw("s-> ");
X! 		getstr(s);
X  		substitute(s);
X! 		printw("--> %s\n", s);
X  	}
X  }
X  #endif
X  
X! all_blanks(char *string)
X  {
X  	for ( ; ((*string == BLANK) && (*string != EOS)) ; ++string);
X  
X--- 154,169 ----
X  	char s[STRLEN];
X  
X  	while (1) {
X! 		printf("s-> ");
X! 		gets(s);
X  		substitute(s);
X! 		printf("--> %s\n", s);
X  	}
X  }
X  #endif
X  
X! all_blanks (string)
X! char * string;
X  {
X  	for ( ; ((*string == BLANK) && (*string != EOS)) ; ++string);
X  
X***************
X*** 159,167 ****
X  
X  /* function to find position  of sub string in a main string 
X   * ---------------------------------------------------------- */
X  /* ========================================= */
X! char *find_string(char main_string[], char sub_string[])
X  /* ========================================= */
X  {
X  	int start_mstring = 0, start_sstring = 0, 
X  	    factor = 0, answer, main_pos = 0;
X--- 175,185 ----
X  
X  /* function to find position  of sub string in a main string 
X   * ---------------------------------------------------------- */
X+ 
X  /* ========================================= */
X! char * find_string (main_string, sub_string)
X  /* ========================================= */
X+ char main_string[], sub_string[];
X  {
X  	int start_mstring = 0, start_sstring = 0, 
X  	    factor = 0, answer, main_pos = 0;
X***************
X*** 201,206 ****
X--- 219,226 ----
X   * reads a line of input string from the terminal and keeps doing so until    *
X   * input string contains no colons                                            *
X   *****************************************************************************/
X+ 
X+ 
X  struct inp_link {
X  	DL_NODE n;
X  	char *input;
X***************
X*** 207,213 ****
X  };
X  static DLIST inputstack;
X  
X! void read_input_line(char *string)
X  {
X  	extern int G_shell_ok;
X  	char *p;
X--- 227,234 ----
X  };
X  static DLIST inputstack;
X  
X! read_input_line(string)
X! char *string;
X  {
X  	extern int G_shell_ok;
X  	char *p;
X***************
X*** 214,220 ****
X  
X  	if (string == NULL) {	/* just read and trash line */
X  		int c;
X! 		while ((c = getch()) != '\n' && c != EOF)
X  			;
X  		return;
X  	}
X--- 235,241 ----
X  
X  	if (string == NULL) {	/* just read and trash line */
X  		int c;
X! 		while ((c = getchar()) != '\n' && c != EOF)
X  			;
X  		return;
X  	}
X***************
X*** 231,239 ****
X  			free(l->input);
X  			dl_delete(inputstack);
X  		} /* ... else get some new input */
X! 		else if (wgetnstr(stdscr, string, OPTLEN) == ERR) {
X! 			printw("End of input -- quitting...\n");
X! 			refresh();
X  			exit(1);
X  		}
X  
X--- 252,259 ----
X  			free(l->input);
X  			dl_delete(inputstack);
X  		} /* ... else get some new input */
X! 		else if (gets(string) == NULL) {
X! 			printf("End of input -- quitting...\n");
X  			exit(1);
X  		}
X  
X***************
X*** 240,254 ****
X  		/* if it has a multi-command delim, save rest for next time */
X  #define MULTI_CMD_DELIM ','
X  		if (p = index(string, MULTI_CMD_DELIM)) {
X  			struct inp_link *l;
X  			*p++ = EOS;
X! 			if ((l = (struct inp_link *)getnode(
X! 						sizeof(struct inp_link))) &&
X! 						(l->input=strsave(p)))
X  				dl_prepend(inputstack, l);
X  		}
X  
X! 		filter_leading_trailing_blanks_tabs(string);
X  
X  		/* if macro, then expand & push definition on stack */
X  #define MACRO_DELIM '#'
X--- 260,273 ----
X  		/* if it has a multi-command delim, save rest for next time */
X  #define MULTI_CMD_DELIM ','
X  		if (p = index(string, MULTI_CMD_DELIM)) {
X+ 			char *strsave();
X  			struct inp_link *l;
X  			*p++ = EOS;
X! 			if ((l=getnode(sizeof(*l))) && (l->input=strsave(p)))
X  				dl_prepend(inputstack, l);
X  		}
X  
X! 		filter_leading_trailing_blanks_tabs (string);
X  
X  		/* if macro, then expand & push definition on stack */
X  #define MACRO_DELIM '#'
X***************
X*** 256,263 ****
X  			char *mac_lookup();
X  			char *def = mac_lookup(string+1);
X  			struct inp_link *l;
X! 			if (def && (l = (struct inp_link *)getnode(
X! 						sizeof(struct inp_link))) &&
X  						(l->input = strsave(def)))
X  				dl_prepend(inputstack, l);
X  		}
X--- 275,281 ----
X  			char *mac_lookup();
X  			char *def = mac_lookup(string+1);
X  			struct inp_link *l;
X! 			if (def && (l = getnode(sizeof(*l))) &&
X  						(l->input = strsave(def)))
X  				dl_prepend(inputstack, l);
X  		}
X***************
X*** 265,271 ****
X  
X  	/* if not allowing shell, then chop off at funny chars */
X  	if (! G_shell_ok)
X! 		truncate_at_invalid_chars(string);
X  }  /* end function read_input_line */
X  
X  int moreinput()
X--- 283,290 ----
X  
X  	/* if not allowing shell, then chop off at funny chars */
X  	if (! G_shell_ok)
X! 		truncate_at_invalid_chars (string);
X! 
X  }  /* end function read_input_line */
X  
X  int moreinput()
X***************
X*** 279,309 ****
X   * Takes a character string as a parameter                                  *
X   ****************************************************************************/
X  
X! void filter_leading_trailing_blanks_tabs(register char *string)
X  {
X  	int i, j ;
X  
X! 	for (i = 0 ; ((string[i] != EOS) && isspace(string[i])); ++i )
X  		;
X! 	for (j = 0; (string[i] != EOS); j++, i++ ) 
X! 		string[j] = string[i];
X  
X  	string[j] = EOS;
X  
X! 	for (i = strlen(string) - 1; (i >= 0 ); i--)
X! 		if ( !isspace(string[i]) )
X  			break;
X  
X  	string[i+1] = EOS; 
X  
X! 	return;
X  }
X  
X! char *strsave(char *s)
X  {
X! 	char *p;
X! 
X! 	if (s == NULL || (p=(char *)malloc(strlen(s)+1)) == NULL)
X  		return(NULL);
X  	strcpy(p, s);
X  
X--- 298,331 ----
X   * Takes a character string as a parameter                                  *
X   ****************************************************************************/
X  
X! void filter_leading_trailing_blanks_tabs ( string )
X! char * string;
X  {
X  	int i, j ;
X  
X! 	for ( i = 0 ; (( string[i] != EOS ) && (( string[i] == BLANK )
X! 					    ||  ( string[i] == TAB   )) ); ++i )
X  		;
X! 	for ( j = 0 ; ( string[j] != EOS ) ; ++j ) 
X! 		string[j] = string[j + i];
X  
X  	string[j] = EOS;
X  
X! 	for ( i = strlen(string) - 1 ; ( i >= 0 ) ; --i )
X! 		if (( string[i] != BLANK ) && ( string[i] != TAB ))
X  			break;
X  
X  	string[i+1] = EOS; 
X  
X! 	return ;
X  }
X  
X! char *
X! strsave(s)
X! char *s;
X  {
X! 	char *p, *malloc();
X! 	if (s == NULL || (p=malloc(strlen(s)+1)) == NULL)
X  		return(NULL);
X  	strcpy(p, s);
X  
X***************
X*** 311,319 ****
X  }
X  
X  /* assumes d was malloc'd -- then makes large enough to cat s onto it */
X! char *strcatsave(char *d, char *s)
X  {
X! 	if (d && (d = realloc(d, strlen(d)+strlen(s)+1)))
X  		strcat(d, s);
X  
X  	return(d);
X--- 333,345 ----
X  }
X  
X  /* assumes d was malloc'd -- then makes large enough to cat s onto it */
X! char *
X! strcatsave(d, s)
X! char *d, *s;
X  {
X! 	char *realloc();
X! 
X! 	if (d && (d = realloc(d, strlen(d)+strlen(s)+2)))
X  		strcat(d, s);
X  
X  	return(d);
X***************
X*** 320,335 ****
X  }
X  
X  /* replace _ with space */
X! char *ufix(char *s)
X  {
X! 	register char *p;
X! 	for (p=s; p && *p; p++)
X  		if (*p == '_')
X  			*p = ' ';
X  	return(s);
X  }
X  
X! strcontains(char *s, char *chars)
X  {
X  	while (*chars)
X  		if (index(s, *chars++))
X--- 346,364 ----
X  }
X  
X  /* replace _ with space */
X! char *
X! ufix(s)
X! char *s;
X  {
X! 	char *p;
X! 	for (p = s; p && *p; p++)
X  		if (*p == '_')
X  			*p = ' ';
X  	return(s);
X  }
X  
X! strcontains(s, chars)
X! char *s, *chars;
X  {
X  	while (*chars)
X  		if (index(s, *chars++))
X***************
X*** 338,344 ****
X  }
X  
X  /* remove string from no-no chars on */
X! truncate_at_invalid_chars(char *string)
X  {
X  	char *p, *index();
X  	/* XXX - update to use strpbrk */
X--- 367,374 ----
X  }
X  
X  /* remove string from no-no chars on */
X! truncate_at_invalid_chars (string)
X! char *string;
X  {
X  	char *p, *index();
X  	/* XXX - update to use strpbrk */
Xdiff -rc msh/xsystem.c msh.orig/xsystem.c
X*** msh/xsystem.c	Sun Mar 14 11:32:20 1993
X--- msh.orig/xsystem.c	Mon Mar 15 23:26:29 1993
X***************
X*** 5,18 ****
X  static char sccsid[] = "@(#)system.c	5.2 (Berkeley) 3/9/86";
X  #endif LIBC_SCCS and not lint
X  
X- static char xsystem_rcsid[] = "$Header: /usr3/src/msh/RCS/xsystem.c,v 1.1 1993/03/14 19:32:07 root Exp root $";
X- 
X  #include	<signal.h>
X  
X! system(char *s)
X  {
X  	int status, pid, w;
X! 	register void (*istat)(int), (*qstat)(int);
X  
X  	if ((pid = vfork()) == 0) {
X  		execl("/bin/csh", "csh", "-fc", s, 0);
X--- 5,17 ----
X  static char sccsid[] = "@(#)system.c	5.2 (Berkeley) 3/9/86";
X  #endif LIBC_SCCS and not lint
X  
X  #include	<signal.h>
X  
X! system(s)
X! char *s;
X  {
X  	int status, pid, w;
X! 	register int (*istat)(), (*qstat)();
X  
X  	if ((pid = vfork()) == 0) {
X  		execl("/bin/csh", "csh", "-fc", s, 0);
X
END_OF_FILE
  if test 36374 -ne `wc -c <'sysvdiffs.B'`; then
    echo shar: \"'sysvdiffs.B'\" unpacked with wrong size!
  elif test -f 'sysvdiffs.A' ; then
    echo shar: Combining  \"'sysvdiffs.mar93'\" \(61693 characters\)
    cat 'sysvdiffs.A' 'sysvdiffs.B' > 'sysvdiffs.mar93'
    if test 61693 -ne `wc -c <'sysvdiffs.mar93'`; then
      echo shar: \"'sysvdiffs.mar93'\" combined with wrong size!
    else
      rm sysvdiffs.A sysvdiffs.B 
    fi
  fi
  # end of 'sysvdiffs.B'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
