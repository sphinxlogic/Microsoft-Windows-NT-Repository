From: newsham@wiliki.eng.hawaii.edu (Timothy Newsham)
Newsgroups: comp.sources.misc
Subject: v38i012:  circ - encrypted irc package, Part03/03
Date: 19 Jun 1993 08:31:31 +0100
Sender: aem@aber.ac.uk
Approved: aem@aber.ac.uk
Message-ID: <1vufcj$jl5@uk-usenet.UK.Sun.COM>
X-Md4-Signature: 1f8533d775165c54632730a6a0ce5d1b

Submitted-by: newsham@wiliki.eng.hawaii.edu (Timothy Newsham)
Posting-number: Volume 38, Issue 12
Archive-name: circ/part03
Environment: C UNIX

#! /bin/sh
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Circ/LOG Circ/Makefile Circ/RSA/MANIFEST
#   Circ/RSA/Make.amiga Circ/RSA/Make.unix Circ/RSA/Makefile
#   Circ/RSA/README Circ/RSA/README.english Circ/RSA/WARNING
#   Circ/RSA/arith.h Circ/RSA/genprim.c Circ/RSA/genrsa.c
#   Circ/RSA/makekey Circ/RSA/nio.h Circ/RSA/patchlevel.h
#   Circ/RSA/prim.h Circ/RSA/rnd.c Circ/RSA/rnd.h Circ/RSA/rsa.hdr
#   Circ/RSA/test.c Circ/crypt.c Circ/crypt.irc2 Circ/d3des/main.c
#   Circ/d3des/readme Circ/ignore.irc Circ/pubkeys/al Circ/sock.h
#   POSTER
# Wrapped by alecm@uk-usenet on Sat Jun 19 08:26:21 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 3)."'
if test -f 'Circ/LOG' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/LOG'\"
else
  echo shar: Extracting \"'Circ/LOG'\" \(20 characters\)
  sed "s/^X//" >'Circ/LOG' <<'END_OF_FILE'
X16 cycles
X25 cycles
END_OF_FILE
  if test 20 -ne `wc -c <'Circ/LOG'`; then
    echo shar: \"'Circ/LOG'\" unpacked with wrong size!
  fi
  # end of 'Circ/LOG'
fi
if test -f 'Circ/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/Makefile'\"
else
  echo shar: Extracting \"'Circ/Makefile'\" \(1048 characters\)
  sed "s/^X//" >'Circ/Makefile' <<'END_OF_FILE'
X
X# Make:
X#     all   - make 'new' and make keys. 
X#     sock  - make 'sock'
X#     new   - make 'new'
X#     clean - remove .o's and core
X#     clobber - remove everything that can be made with Make
X#     archive - archive into a tar.Z in directory above us.
X
X# $IRCNICK should hold your irc nickname, change this
X# if you dont have $IRCNICK set already (else will use $LOGNAME)
XNICK = public
X
Xnew : new.o d3des.o crypt.o RSA/do_rsa.o
X	cc new.o d3des.o crypt.o RSA/do_rsa.o -o new
X
Xall : new keys
X
Xsock : sock2.o d3des.o crypt.o RSA/do_rsa.o
X	cc sock2.o d3des.o crypt.o RSA/do_rsa.o -o sock
X
Xkeys : RSA/genprim RSA/genrsa
X	cd RSA;makekey $(NICK)
X
XRSA/genprim :
X	cd RSA;make genprim
X
XRSA/genrsa :
X	cd RSA;make genrsa
X
Xsock2.o : sock2.c sock.h
X
Xnew.o : new.c
X
Xd3des.o : d3des/d3des.c d3des/d3des.h
X	cc -O -c d3des/d3des.c
X
Xcrypt.o : crypt.c
X
XRSA/do_rsa.o :  RSA/rsa.c
X	cd RSA;make do_rsa.o
X
Xclean :
X	rm -f RSA/*.o *.o core
X
Xclobber :
X	rm -f RSA/*.o *.o new sock secret RSA/genrsa RSA/genprim core
X
Xarchive :
X	cd ..;tar -cf irc.tar irc;compress irc.tar
END_OF_FILE
  if test 1048 -ne `wc -c <'Circ/Makefile'`; then
    echo shar: \"'Circ/Makefile'\" unpacked with wrong size!
  fi
  # end of 'Circ/Makefile'
fi
if test -f 'Circ/RSA/MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/MANIFEST'\"
else
  echo shar: Extracting \"'Circ/RSA/MANIFEST'\" \(389 characters\)
  sed "s/^X//" >'Circ/RSA/MANIFEST' <<'END_OF_FILE'
XMakefile
Xconf.h			gundlegende Definitionen
Xarith.c			grundlegende arithmetische Routinen
Xarith.h
Xprim.c			Routinen zur probabilistischen Primzahl-Berechnung
Xprim.h
Xnio.c			IO-Routinen
Xnio.h
Xrnd.c			Zufalls-Zahl Erzeugungs Routinen
Xrnd.h
Xgenprim.c		Erzeugung von Primzahlen mit vorgegebener Stellenzahl
Xgenrsa.c		Erzeugung der oeffendlichen/geheimen Schluessel
Xrsa.c			Ver/Entschluesselung
END_OF_FILE
  if test 389 -ne `wc -c <'Circ/RSA/MANIFEST'`; then
    echo shar: \"'Circ/RSA/MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/MANIFEST'
fi
if test -f 'Circ/RSA/Make.amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/Make.amiga'\"
else
  echo shar: Extracting \"'Circ/RSA/Make.amiga'\" \(768 characters\)
  sed "s/^X//" >'Circ/RSA/Make.amiga' <<'END_OF_FILE'
X
XCFLAGS = -dAUTOKEY -dSTANDALONE
X
Xall:	genprim genrsa rsa
X
Xgenprim:	genprim.o rnd.o prim.o nio.o arith.o
X	blink from lib:c.o,genprim.o,rnd.o,nio.o,prim.o,arith.o to genprim lib lib:lc.lib,lib:amiga.lib,lib:lcm.lib
X
Xgenrsa:		genrsa.o rnd.o prim.o nio.o arith.o
X	blink from lib:c.o,genrsa.o,rnd.o,nio.o,prim.o,arith.o to genrsa lib lib:lc.lib,lib:amiga.lib,lib:lcm.lib
X
X
Xrsa:		rsa.o nio.o arith.o
X	blink lib:c.o,rsa.o,nio.o,arith.o to rsa lib lib:lc.lib,lib:amiga.lib
X	copy rsa rsaencode   #ln rsa rsaencode
X	copy rsa rsadecode   #ln rsa rsadecode
X
X#rsa.o genrsa.o genprim.o nio.o prim.o arith.o:	conf.h
X#rsa.o genrsa.o genprim.o nio.o prim.o arith.o:	arith.h
X#rsa.o genrsa.o genprim.o nio.o:	nio.h
X#genrsa.o genprim.o prim.o:	prim.h
X#genrsa.o genprim.o rnd.o:	rnd.h
X
X
X
END_OF_FILE
  if test 768 -ne `wc -c <'Circ/RSA/Make.amiga'`; then
    echo shar: \"'Circ/RSA/Make.amiga'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/Make.amiga'
fi
if test -f 'Circ/RSA/Make.unix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/Make.unix'\"
else
  echo shar: Extracting \"'Circ/RSA/Make.unix'\" \(1013 characters\)
  sed "s/^X//" >'Circ/RSA/Make.unix' <<'END_OF_FILE'
X
X# if you want an executable,  -DSTANDALONE while compiling
X# rsa.c,  and uncomment the ln's below
X
XSHELL=/bin/sh
X
X# add -DSTANDALONE to CFLAGS if you want a standalone
X#CFLAGS= -O +Aa
XCFLAGS= -DAUTOKEY -O  # -g
XLDFLAGS=
X
Xall:	genprim genrsa rsa # do_rsa.o 
X
Xgenprim:	genprim.o rnd.o prim.o nio.o arith.o
X	$(CC) $(LDFLAGS) -o genprim genprim.o rnd.o nio.o prim.o arith.o
X
Xgenrsa:		genrsa.o rnd.o prim.o nio.o arith.o
X	$(CC) $(LDFLAGS) -o genrsa genrsa.o rnd.o nio.o prim.o arith.o
X
Xdo_rsa.o:		rsa.o nio.o arith.o
X	$(CC) $(LDFLAGS) -C -o do_rsa.o rsa.o nio.o arith.o
X
Xrsa:		test.o rsa.c nio.o arith.o
X	$(CC) $(LDFLAGS) -o rsa -DSTANDALONE rsa.c nio.o arith.o
X	ln rsa rsaencode
X	ln rsa rsadecode
X
Xrsa.o genrsa.o genprim.o nio.o prim.o arith.o:	conf.h
Xrsa.o genrsa.o genprim.o nio.o prim.o arith.o:	arith.h
Xrsa.o genrsa.o genprim.o nio.o:	nio.h
Xgenrsa.o genprim.o prim.o:	prim.h
Xgenrsa.o genprim.o rnd.o:	rnd.h
X
Xclean:
X	rm -f *.bak *.ba *~ \#* core *.o
X
Xclobber: clean
X	rm -f genrsa genprim rsa rsadecode rsaencode 
END_OF_FILE
  if test 1013 -ne `wc -c <'Circ/RSA/Make.unix'`; then
    echo shar: \"'Circ/RSA/Make.unix'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/Make.unix'
fi
if test -f 'Circ/RSA/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/Makefile'\"
else
  echo shar: Extracting \"'Circ/RSA/Makefile'\" \(1021 characters\)
  sed "s/^X//" >'Circ/RSA/Makefile' <<'END_OF_FILE'
X
X# if you want an executable,  -DSTANDALONE while compiling
X# rsa.c,  and uncomment the ln's below
X
XSHELL=/bin/sh
X
X# add -DSTANDALONE to CFLAGS if you want a standalone
X#CFLAGS= -O +Aa
XCFLAGS= -DAUTOKEY -O  # -g
XLDFLAGS=
XLD = ld
X
Xall:	genprim genrsa rsa # do_rsa.o 
X
Xgenprim:	genprim.o rnd.o prim.o nio.o arith.o
X	$(CC) $(LDFLAGS) -o genprim genprim.o rnd.o nio.o prim.o arith.o
X
Xgenrsa:		genrsa.o rnd.o prim.o nio.o arith.o
X	$(CC) $(LDFLAGS) -o genrsa genrsa.o rnd.o nio.o prim.o arith.o
X
Xdo_rsa.o:		rsa.o nio.o arith.o
X	$(LD) $(LDFLAGS) -r -o do_rsa.o rsa.o nio.o arith.o
X
Xrsa:		test.o rsa.c nio.o arith.o
X	$(CC) $(LDFLAGS) -o rsa -DSTANDALONE rsa.c nio.o arith.o
X	ln rsa rsaencode
X	ln rsa rsadecode
X
Xrsa.o genrsa.o genprim.o nio.o prim.o arith.o:	conf.h
Xrsa.o genrsa.o genprim.o nio.o prim.o arith.o:	arith.h
Xrsa.o genrsa.o genprim.o nio.o:	nio.h
Xgenrsa.o genprim.o prim.o:	prim.h
Xgenrsa.o genprim.o rnd.o:	rnd.h
X
Xclean:
X	rm -f *.bak *.ba *~ \#* core *.o
X
Xclobber: clean
X	rm -f genrsa genprim rsa rsadecode rsaencode 
END_OF_FILE
  if test 1021 -ne `wc -c <'Circ/RSA/Makefile'`; then
    echo shar: \"'Circ/RSA/Makefile'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/Makefile'
fi
if test -f 'Circ/RSA/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/README'\"
else
  echo shar: Extracting \"'Circ/RSA/README'\" \(4029 characters\)
  sed "s/^X//" >'Circ/RSA/README' <<'END_OF_FILE'
X
X********************************************************************************
X*									       *
X*				R S A - Verfahren			       *
X*									       *
X********************************************************************************
X
XDie Schluessel-Generierung laeuft in 2 Stufen ab.
X
XA)	Es muessen 2 Primzahlen mit genprim berechnet werden. Die
X	Groessenordnung dieser Zahlen sollte 80-130 sein, und sich um
X	eine unterscheiden. Diese Zahlen muessen in einer Datei, mit
X	einem beliebigen Trennzeichen (z.B. '#') dazwischen, abgelegt
X	werden.
X
X		Alle Zahlen werden als Hexadezimalzahlen (fuer
X		Puristen: Sedizimal :-) ein-/ausgegeben.  Bei
X		Ein-/Ausgabe sind White-Spaces (Blank,Tab,Newline)
X		nicht signifikant.
X
X	Der zweite Parameter von genprim gibt die Wahrscheinlichkeit an,
X	mit der die gefundene Zahl wirklich eine Primzahl ist.  Fuer
X	eine Parameter n ist die Wahrscheinlichkeit 1-0.5^n. Fuer n=20
X	ist ein Programierfehler von mir schon wahrscheinlicher :-).
X	Das der Test nur probabilistisch ist, verringert bei vernuenftiger
X	Wahl von n die Aussagekraeftigkeit nur unwesendlich.
X
XB)	Genrsa generiert daraus eine Datei mit oeffendlichem/geheimen
X	Schluessel.  Diese Datei enthaelt 3 Zahlen.  Aus dieser Datei
X	gewinnt man die geheime, in dem man die letzte Zahl (mit Trenn-
X	zeichen) entfernt.  Den oeffendlichen erhaelt man duch Entfernung
X	der zweiten Zahl.
X
XBeispiel:
X	$ genrsa 10 20 >p1		# erste Primzahl
X	$ cat p1
X	2023A0B0BE5
X	$ genrsa 11 20 >p2		# zweite Primzahl
X	$ cat p2
X	537A985EC975
X	$ echo "#" | cat p1 - p2 >pd	# Eingabe fuer genrsa
X	$ genrsa <pd >rd		# Alle Zahlen fertig
X	$ cat rd
X	A7AF134EFB73D789793CA9
X	#
X	9245F9009636D26B7CA5ED
X	#
X	80F408891D5932D10C2585
X
XDieses File rd muss man auf 2 Files verteilen:
X
X	$ cat geheim
X	A7AF134EFB73D789793CA9
X	#
X	9245F9009636D26B7CA5ED
X	$ cat oeffendlich
X	A7AF134EFB73D789793CA9
X	#
X	80F408891D5932D10C2585
X
XDie Dateien p1,p2,pd und rd sollte man schnell wieder loeschen.
X
X	$ rsaencode oeffendlich <data >crypt	# Verschluesseln
X	$ rsadecode geheim <crypt >clear	# Entschluesseln
X
XDie Verschluesselung laeuft in Bloecken ab, deren Groesse von der der
Xersten Zahl des Schluessels Abhaengt.  Alle Bloecke werden als binaere
XDaten behandelt.  Allerdings wird beim Entschluesseln der letzte Block
Xmit ASCII-NULL aufgefuellt.  Dieses ist kein Fehler des RSA-Verfahrens,
Xsondern liegt an meiner Verwendung.  Das RSA-Verfahren verschluesselt
Xeinfach Zahlen. Meiner Umwandlung von Daten in Zahlen ist das Manko
Xanzulasten.  Deshalb muss auch der verschluesselte Text mit btoa oder
Xaehnlichem mailbar gemacht werden.  Zur Reduktion der Blockanzahl kann
Xman natuerlich vorher den Text compressen, da er sowieso binaer behandelt
Xwird.
X
XBei mir (386-er mit 20 MHz) dauert die Ver-/Entschluesselung eines
XBlocks (aus 125 & 124 stelliger Primzahl) 20 Minuten !!!!!!
XDafuer laeuft die Primzahlberechnung in 1-20 Stunden ab :-) !!!!!
XDas haengt von dem zufaelligen Startpunkt der Suche ab.
X
XWer Lust hat, die Verschluesselung so zu modifizieren, dass nur ein
XBlock mit RSA verschluesselt wird, und alle anderen, mit einem darin
Xuebergebenen weiteren Schuessel, mit DES zu verschluesseln, der ist
Xherzlich eingeladen ein solches Programm analog rsa.c zu erstellen.
XDie eigendliche Verschluesselung ist mit den Routinen aus arith.c
Xtrivial.  Es kostet allerding Zeit :-).
X
XAls Warnung fuer Leute, die mit den Routinen arbeiten wollen:
X
XAlle Routinen sind auf Laufzeit optimiert, und enthalten fast keine
XUeberpruefungen auf Ueberlauf o.ae. .  Wenn ein Fehler entdeckt wird
X(was selten ist :-), gibts eine core.  Alle Zahlen muessen >= 0 sein.
X
XMein Wissen ueber RSA und die anderen verwendeten Verfahren hab ich
Xaus:
X	Horster, Patrick:
X	Kryptologie / von Patrick Horster. - Mannheim;
X	Wien; Zuerich: Bibliographisches Institut, 1985.
X	    (Reihe Informatik; 47)
X	    ISBN 3-411-03106-9
X	NE: GT
X
XMartin Nicolay		( martin@trillian.megalon.de )
XFliederstr. 23
X4100 Duisburg 1
XW-Germany
X
XPS:	Falls rand.h nicht vorhanden ist: darin sind nur die Funktionen
X	wie drand48 usw. deklariert.
END_OF_FILE
  if test 4029 -ne `wc -c <'Circ/RSA/README'`; then
    echo shar: \"'Circ/RSA/README'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/README'
fi
if test -f 'Circ/RSA/README.english' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/README.english'\"
else
  echo shar: Extracting \"'Circ/RSA/README.english'\" \(1320 characters\)
  sed "s/^X//" >'Circ/RSA/README.english' <<'END_OF_FILE'
XI don't know german. But, with the help of a friend of mine who speaks
Xgerman as his first language I managed to make this program work and
Xit worked truly well indeed. Here are very brief instructions to start with
Xthis little beastie:
X
X* generate two primes 10 and 11 digits long, prime with 1/2^20
X  probabilistic precision:
X
X	$ genprim 10 20 >p1		# the first prime
X	$ cat p1
X	2023A0B0BE5
X	$ genprim 11 20 >p2              # the second one
X	$ cat p2
X	537A985EC975
X	$ echo "#" | cat p1 - p2 >pd    # Put a `#' between the two primes
X
X* generate public and private key:
X	$ genrsa <pd >rd
X	$ cat rd
X	A7AF134EFB73D789793CA9
X	#
X	9245F9009636D26B7CA5ED
X	#
X	80F408891D5932D10C2585
X
X* you have to edit the `rd' file. The secret key is obtained by
X  taking the first and the second number. The public key is
X  obtained by taking the first and third number.
X
X	$ cat secret
X	A7AF134EFB73D789793CA9
X	#
X	9245F9009636D26B7CA5ED
X	$ cat public
X	A7AF134EFB73D789793CA9
X	#
X	80F408891D5932D10C2585
X
X* now you are able to crypt / encrypt your data:
X
X	$ rsaencode public <data >crypt		# encryption
X	$ rsadecode secret <crypt >plaintext	# decryption
X
X* pure RSA encryption is used. I mean, we don't use DES or any other
X  cipher to speed up the process. This means that the encryption
X  process is slow.
X
X
XEnjoy!		vince@ghost.dsi.unimi.it
END_OF_FILE
  if test 1320 -ne `wc -c <'Circ/RSA/README.english'`; then
    echo shar: \"'Circ/RSA/README.english'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/README.english'
fi
if test -f 'Circ/RSA/WARNING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/WARNING'\"
else
  echo shar: Extracting \"'Circ/RSA/WARNING'\" \(1398 characters\)
  sed "s/^X//" >'Circ/RSA/WARNING' <<'END_OF_FILE'
XThere are most certainly legal problems with using this software in the U.S.A.,
Xand probably also in several other countries, relating to a patent which 
Xcovers the techniques used here.
X
XALSO BE SURE TO LOOK AT THE FILE PATCHES IN THIS DIRECTORY!!!
X
XThe following comes directly from PKP on the use of RSA within the 
XU.S. and Canada. It seems to indicate that we may use RSA without
Xa licence for non-commercial purposes. I presume this applies to PGP
Xwhich is an RSA based system, but I really don't know. At least it
Xapplies to RSAREF, the library being made available by RSA Inc
Xto North American users. 
X
XFor information on RSAREF send mail to rsaref@rsa.com. They'll send
Xit to you provided you state that you are either an American
Xor Canadian citizen or U.S. Permanent Resident located in the U.S.
Xor Canada and state that you agree to comply with the licence  
Xagreement.
X
X"In North America, a license is needed to ``make, use or sell'' RSA. However,
XPKP has a policy that anyone may use RSA non-commercially for a 
Xpersonal, academic or intellectual reason without a license; an example 
Xof such use would be the implementation of RSA as a programming project 
Xfor a computer class. RSA Laboratories has made available (in the U.S. and
XCanada) at no charge a collection of cryptographic routines in 
Xsource code, including the RSA algorithm; it can be used for non-commercial
Xpurposes"
X
END_OF_FILE
  if test 1398 -ne `wc -c <'Circ/RSA/WARNING'`; then
    echo shar: \"'Circ/RSA/WARNING'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/WARNING'
fi
if test -f 'Circ/RSA/arith.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/arith.h'\"
else
  echo shar: Extracting \"'Circ/RSA/arith.h'\" \(1464 characters\)
  sed "s/^X//" >'Circ/RSA/arith.h' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#ifndef	_arith_h_
X#define	_arith_h_
X
X#ifndef	_conf_h_
X#include	"conf.h"
X#endif
X
Xextern NUMBER a_one,a_two;
X
X/*
X * Prototypes
X */
X
Xvoid	a_add		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	a_assign	P(( NUMBER*, NUMBER* ));
Xint	a_cmp		P(( NUMBER*, NUMBER* ));
Xvoid	a_div		P(( NUMBER*, NUMBER*, NUMBER*, NUMBER* ));
Xvoid	a_div2		P(( NUMBER* ));
Xvoid	a_ggt		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	a_imult		P(( NUMBER*, INT, NUMBER* ));
Xvoid	a_mult		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	a_sub		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	m_init		P(( NUMBER*, NUMBER* ));
Xvoid	m_add		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	m_mult		P(( NUMBER*, NUMBER*, NUMBER* ));
Xvoid	m_exp		P(( NUMBER*, NUMBER*, NUMBER* ));
Xint	n_bits		P(( NUMBER*, int));
Xvoid	n_div		P(( NUMBER*, NUMBER*, NUMBER*, NUMBER* ));
Xint	n_cmp		P(( INT*, INT*, int ));
Xint	n_mult		P(( INT*, INT, INT*, int ));
Xint	n_sub		P(( INT*, INT*, INT*, int, int ));
Xint	n_bitlen	P(( NUMBER* ));
X
X#endif
END_OF_FILE
  if test 1464 -ne `wc -c <'Circ/RSA/arith.h'`; then
    echo shar: \"'Circ/RSA/arith.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/arith.h'
fi
if test -f 'Circ/RSA/genprim.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/genprim.c'\"
else
  echo shar: Extracting \"'Circ/RSA/genprim.c'\" \(1416 characters\)
  sed "s/^X//" >'Circ/RSA/genprim.c' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#include	<stdio.h>
X
X#include	"arith.h"
X#include	"prim.h"
X#include	"nio.h"
X#include	"rnd.h"
X
Xchar *prog;
X
XNUMBER a_three,a_four;
X
Xusage()
X{
X	fprintf(stderr,"usage: %s digits [probability]\n",prog);
X	exit (1);
X}
X
Xmain( argc, argv )
Xchar **argv;
X{
X	NUMBER prim;
X	int len,i,prob;
X	
X	prog = argv[0];	
X	
X	if ( argc < 2 || 3 < argc )
X		usage();
X	
X	len = atoi( argv[1] );
X	if (argc > 2)
X		prob = atoi( argv[2] );
X	else
X		prob = 10;
X
X	a_add( &a_one, &a_two, &a_three );
X	a_add( &a_two, &a_two, &a_four );
X
X	init_rnd();
X	
X	do {
X		gen_number( len, &prim );
X	} while ( !prim.n_len );
X	
X	a_mult( &prim, &a_two, &prim );
X	a_mult( &prim, &a_three, &prim );
X	a_add( &prim, &a_one, &prim );
X	
X	for (i=1 ;; i++) {
X		if (p_prim( &prim, prob ))
X			break;
X		if (i % 2)
X			a_add( &prim, &a_four, &prim );
X		else
X			a_add( &prim, &a_two, &prim );
X	}
X	fprintf(stderr,"%d cycles\n",i);
X	
X	num_fput( &prim, stdout );
X}
END_OF_FILE
  if test 1416 -ne `wc -c <'Circ/RSA/genprim.c'`; then
    echo shar: \"'Circ/RSA/genprim.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/genprim.c'
fi
if test -f 'Circ/RSA/genrsa.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/genrsa.c'\"
else
  echo shar: Extracting \"'Circ/RSA/genrsa.c'\" \(2515 characters\)
  sed "s/^X//" >'Circ/RSA/genrsa.c' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#include	<stdio.h>
X
X#include	"arith.h"
X#include	"nio.h"
X#include	"prim.h"
X#include	"rnd.h"
X
X/* files that we use if we are on autopilot */
X#ifdef AUTOKEY
X#define PUBLIC "public"
X#define PRIVATE "secret"
X#include <fcntl.h>
X#endif AUTOKEY
X
Xmain()
X{
X	NUMBER p1,p2,n,d,e,phi,*max_p;
X	int len;
X#ifdef AUTOKEY
X        FILE *fdpub,*fdpriv;
X        FILE *fd;
X
X	if((fdpub=fopen(PUBLIC,"w"))==0) {
X		perror(PUBLIC);
X		exit(1);
X	}
X	if((fdpriv=fopen(PRIVATE,"w"))==0) {
X		perror(PRIVATE);
X		exit(1);
X	}
X	system("genprim 63 20 >ptemp");   /* 63 and 65 x4 bit primes */
X        system("echo '#' >>ptemp");       /* 252 + 260 = 512 bit modulus */
X	system("genprim 65 20 >>ptemp");  
X
X	fd=fopen("ptemp","r");
X        if(fd==NULL) {
X		printf("Cant open temp file\n");
X		exit(1);
X	}
X	num_fget( &p1, fd ); getc(fd);
X	num_fget( &p2, fd );
X 	fclose(fd);
X	system("rm -f ptemp\n");
X#else
X	num_fget( &p1, stdin ); getchar();
X	num_fget( &p2, stdin );
X#endif AUTOKEY
X	
X	if ( !a_cmp( &p1, &p2 ) ) {
X		fprintf(stderr,"the prime numbers must not be identical!\n");
X		exit(1);
X	}
X	
X	if (a_cmp( &p1, &p2 ) > 0)
X		max_p = &p1;
X	else
X		max_p = &p2;
X
X	a_mult( &p1, &p2, &n );
X	
X	a_sub( &p1, &a_one, &phi );
X	a_sub( &p2, &a_one, &e );
X	a_mult( &phi, &e, &phi );
X	
X	len = n_bitlen( &phi );
X	len = ( len + 3 ) / 4;
X	
X	a_assign( &p1, &phi );
X	a_sub( &p1, &a_one, &p1 );
X	init_rnd();
X	do {
X		do {
X			gen_number( len, &d );
X		} while (a_cmp( &d, max_p ) <= 0 || a_cmp( &d, &p1 ) >= 0);
X				
X		a_ggt( &d, &phi, &e );
X	} while ( a_cmp( &e, &a_one ) );
X	
X	
X	inv( &d, &phi, &e );
X	
X#ifndef AUTOKEY
X	num_fput( &n, stdout ); puts("#"); fflush(stdout);
X	num_fput( &d, stdout ); puts("#"); fflush(stdout);
X	num_fput( &e, stdout );
X#else AUTOKEY
X        /* priv is first and second of above,  */
X        /* public is first and third of above  */
X	num_fput( &n, fdpub ); fprintf(fdpub,"#\n");
X	num_fput( &n, fdpriv ); fprintf(fdpriv,"#\n");
X	num_fput( &d, fdpriv );
X	num_fput( &e, fdpub );
X
X	fclose(fdpub);
X	fclose(fdpriv);
X#endif AUTOKEY
X}
X
END_OF_FILE
  if test 2515 -ne `wc -c <'Circ/RSA/genrsa.c'`; then
    echo shar: \"'Circ/RSA/genrsa.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/genrsa.c'
fi
if test -f 'Circ/RSA/makekey' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/makekey'\"
else
  echo shar: Extracting \"'Circ/RSA/makekey'\" \(420 characters\)
  sed "s/^X//" >'Circ/RSA/makekey' <<'END_OF_FILE'
X#!/bin/sh
X
XNICK=$1
X
Xif [ $IRCNICK ] 
Xthen
X  NICK=$IRCNICK;
Xelse
X  if [ $LOGNAME ]
X  then
X    NICK=$LOGNAME;
X  else
X    if [ $USER ]
X    then
X      NICK=$USER
X    fi
X  fi 
Xfi
Xecho "Making keys."
Xecho "Putting secret key in file 'secret' and"
Xecho "public key in file '$NICK'"
Xecho "This takes a while.  Putting the job in the background."
X (genrsa 2>../LOG; mv public ../$NICK; mv secret ..; echo "Done making keys" ) &
X
END_OF_FILE
  if test 420 -ne `wc -c <'Circ/RSA/makekey'`; then
    echo shar: \"'Circ/RSA/makekey'\" unpacked with wrong size!
  fi
  chmod +x 'Circ/RSA/makekey'
  # end of 'Circ/RSA/makekey'
fi
if test -f 'Circ/RSA/nio.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/nio.h'\"
else
  echo shar: Extracting \"'Circ/RSA/nio.h'\" \(780 characters\)
  sed "s/^X//" >'Circ/RSA/nio.h' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#ifndef	_nio_h_
X#define	_nio_h_
X
X#ifndef _arith_h_
X#include	"arith.h"
X#endif
X
X/*
X * Prototypes
X */
X
Xint	num_sput	P(( NUMBER*, char*, int ));
Xint	num_fput	P(( NUMBER*, FILE* ));
Xint	num_sget	P(( NUMBER*, char* ));
Xint	num_fget	P(( NUMBER*, FILE* ));
X
X#endif
END_OF_FILE
  if test 780 -ne `wc -c <'Circ/RSA/nio.h'`; then
    echo shar: \"'Circ/RSA/nio.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/nio.h'
fi
if test -f 'Circ/RSA/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/patchlevel.h'\"
else
  echo shar: Extracting \"'Circ/RSA/patchlevel.h'\" \(32 characters\)
  sed "s/^X//" >'Circ/RSA/patchlevel.h' <<'END_OF_FILE'
X#define       PATCHLEVEL      1
END_OF_FILE
  if test 32 -ne `wc -c <'Circ/RSA/patchlevel.h'`; then
    echo shar: \"'Circ/RSA/patchlevel.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/patchlevel.h'
fi
if test -f 'Circ/RSA/prim.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/prim.h'\"
else
  echo shar: Extracting \"'Circ/RSA/prim.h'\" \(688 characters\)
  sed "s/^X//" >'Circ/RSA/prim.h' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#ifndef	_prim_h_
X#define	_prim_h_
X
X#ifndef _arith_h_
X#include	"arith.h"
X#endif
X
Xint	p_prim		P(( NUMBER*, int ));
Xvoid	inv		P(( NUMBER*, NUMBER*, NUMBER* ));
X
X#endif
END_OF_FILE
  if test 688 -ne `wc -c <'Circ/RSA/prim.h'`; then
    echo shar: \"'Circ/RSA/prim.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/prim.h'
fi
if test -f 'Circ/RSA/rnd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/rnd.c'\"
else
  echo shar: Extracting \"'Circ/RSA/rnd.c'\" \(1177 characters\)
  sed "s/^X//" >'Circ/RSA/rnd.c' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#include	<stdio.h>
X
X#include	"rnd.h"
X
X#include	"nio.h"
X
Xvoid gen_number( len, n )
XNUMBER *n;
X{
X	char *hex = "0123456789ABCDEF" ;
X	char num[ MAXLEN*MAXBIT/4 +1 ];
X	char *p;
X	int i,l;
X	
X	p= &num[ sizeof(num) -1];
X	*p-- = '\0';
X	
X	for (l=len; l--; p-- ) {
X		i = lrand48() % 16;
X		*p = hex[ i ];
X	}
X	p++;
X	
X	while (len-- && *p == '0')
X		p++;
X	
X	num_sget( n, p );
X}
X
X#ifdef AMIGA
Xint getpid()        /* we got no getpid on amiga */
X{
X	return(time((long *)0));
X}
X#endif
X
Xvoid init_rnd()
X{
X	long time();
X	short seed[3];
X
X	seed[0] = time((long *)0) & 0xFFFF;
X	seed[1] = getpid() & 0xFFFF;
X	seed[2] = (time((long *)0) >> 16) & 0xFFFF;
X	(void)seed48( seed );
X}	
X
X
END_OF_FILE
  if test 1177 -ne `wc -c <'Circ/RSA/rnd.c'`; then
    echo shar: \"'Circ/RSA/rnd.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/rnd.c'
fi
if test -f 'Circ/RSA/rnd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/rnd.h'\"
else
  echo shar: Extracting \"'Circ/RSA/rnd.h'\" \(673 characters\)
  sed "s/^X//" >'Circ/RSA/rnd.h' <<'END_OF_FILE'
X/*******************************************************************************
X*									       *
X*	Copyright (c) Martin Nicolay,  22. Nov. 1988			       *
X*									       *
X*	Wenn diese (oder sinngemaess uebersetzte) Copyright-Angabe enthalten   *
X*	bleibt, darf diese Source fuer jeden nichtkomerziellen Zweck weiter    *
X*	verwendet werden.						       *
X*									       *
X*	martin@trillian.megalon.de					       *
X*									       *
X*******************************************************************************/
X
X#ifndef	_rnd_h_
X#define	_rnd_h_
X
X#ifndef _arith_h_
X#include	"arith.h"
X#endif
X
Xvoid	gen_number	P(( int, NUMBER* ));
Xvoid	init_rnd	P(( void ));
X
X#endif
END_OF_FILE
  if test 673 -ne `wc -c <'Circ/RSA/rnd.h'`; then
    echo shar: \"'Circ/RSA/rnd.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/rnd.h'
fi
if test -f 'Circ/RSA/rsa.hdr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/rsa.hdr'\"
else
  echo shar: Extracting \"'Circ/RSA/rsa.hdr'\" \(1342 characters\)
  sed "s/^X//" >'Circ/RSA/rsa.hdr' <<'END_OF_FILE'
XFrom: martin@trillian.UUCP (Martin Nicolay)
XNewsgroups: sub.sources.unix,sub.sources.misc
XSubject: RSA-Routinen
XDate: 22 Nov 88 02:24:25 GMT
XReply-To: martin@trillian.megalon.de (Martin Nicolay)
XOrganization: Home
XXref: lan sub.sources.unix:2 sub.sources.misc:10
X
XIch hab eine Implementation des RSA-Verfahrens (Public-Key-Crypt) zusammen
Xgestrickt.  Enthalten sind dafuer auch Funktionen fuer Arithmetik mit grossen
XZahlen (obere Schranke ist Compile-Option).
X
XJetzt kann endlich kein Sysop mehr die private Post lesen :-).
X
XDas Programm, dass den Text verschluesselt, ist noch verbesserungswuerdig.
XZ.B. nur einen Block mit RSA (weil rechenintensiv) verschluesseln und darin
Xeine Key uebergeben, mit dem der Rest mit DES verschluesselt wird.
X
XViel Spass bei der sicheren Mail!
X
XPS:  Mein oeffendlicher Schluessel ist :
X	10875FDCBBC59099500630B241458A52B1830D35E6816A739C74534E8017E3F1
X	B9ACB73BDC84C47F954047EAFFBE0EFD5499B4431C815130766E78ED0F1E671D
X	F926171D67BDECB92374AAB07629C5F0263FCCDCD920F7D90779A8CF439538B1
X	6FAF35CE95A06051A6BFD3A7D7AF8B51FE8545C439E4C9F0ADAB7E13303
X	#
X	C6A65AE2A755FFE2026134AF1B8EC469017D0D9F3884F4D1132D273F066DBE57
X	86960811590F6873E52792D387604168183A7C22AA9FDF0F401454C4E65CE274
X	78C94992F154F380886E2F410707209665B5629864A358EDE68E0C11F94DA275
X	4C84D5F8BE6D7A6DC516FB6C4A4D7ABF13E701CCB2B8ED937E50438C2D
X
END_OF_FILE
  if test 1342 -ne `wc -c <'Circ/RSA/rsa.hdr'`; then
    echo shar: \"'Circ/RSA/rsa.hdr'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/rsa.hdr'
fi
if test -f 'Circ/RSA/test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/RSA/test.c'\"
else
  echo shar: Extracting \"'Circ/RSA/test.c'\" \(453 characters\)
  sed "s/^X//" >'Circ/RSA/test.c' <<'END_OF_FILE'
X
X#include <fcntl.h>
X
Xmain()
X{
X   char buf[8192];
X   char *data="hey there\n";
X   int a,x,log1,log2;
X
X   log1=open("log1",O_CREAT|O_WRONLY);
X   log2=open("log2",O_CREAT|O_WRONLY);
X   a=(char)strlen(data);
X   strcpy(buf+1,"hey there.\n");
X   buf[0]=a;
X   x=do_rsa("public",buf,a+1,8192);
X   write(log1,buf,8192);
X   do_rsa("secret",buf,x);
X   write(log2,buf,8192);
X   close(log1);
X   close(log2);
X   write(1,buf+1,(int) buf[0]);
X   write(1,"\n",1);
X   
X}
END_OF_FILE
  if test 453 -ne `wc -c <'Circ/RSA/test.c'`; then
    echo shar: \"'Circ/RSA/test.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/RSA/test.c'
fi
if test -f 'Circ/crypt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/crypt.c'\"
else
  echo shar: Extracting \"'Circ/crypt.c'\" \(608 characters\)
  sed "s/^X//" >'Circ/crypt.c' <<'END_OF_FILE'
X
X#include "d3des/d3des.h"
X
X#define HUGE 1024
X
Xunsigned long enkey[96],dekey[96];
X
Xchar *en_crypt(buf,len,len2)
Xchar *buf;
Xint len,*len2;
X{
X  static char ret[HUGE];
X  int i;
X
X  use3key(enkey);
X  for(i=0;i<len;i+=8)
X    Ddes(buf+i,ret+i);
X  *len2=i;
X  return(ret);
X}
X
Xchar *de_crypt(buf,len,len2)
Xchar *buf;
Xint len,*len2;
X{
X  static char ret[HUGE];
X  int i;
X
X  use3key(dekey);
X  for(i=0;i<len;i+=8)
X    Ddes(buf+i,ret+i);
X  *len2=i;
X  return(ret);
X}
X 
Xset_key(key)
Xchar *key;
X{
X  des3key(key,0);
X  cp3key(enkey);     /* set encryption key */
X  des3key(key,1);
X  cp3key(dekey);     /* set decryption key */
X}
X
END_OF_FILE
  if test 608 -ne `wc -c <'Circ/crypt.c'`; then
    echo shar: \"'Circ/crypt.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/crypt.c'
fi
if test -f 'Circ/crypt.irc2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/crypt.irc2'\"
else
  echo shar: Extracting \"'Circ/crypt.irc2'\" \(1550 characters\)
  sed "s/^X//" >'Circ/crypt.irc2' <<'END_OF_FILE'
X# this is ver ircII 2.2.4
X# for some reason, /on ^public acts differently
X
X# Start up the proggie
X/^exec -name crypt exec new
X
X# automatically pick out protocol messages
X#    crypt processor gets:   !send nick!CLIPPER:...etc
X#    or   !our nick!SKPJACK:...etc 
X# under 2.2.4 public has:  nick channel message
X#   the version I use has  nick message
X#   this is the difference between the two script versions
X/on ^public "* * CLIPPER:*" /msg %crypt !$0!$2-
X/on ^public "* * SKPJACK:*" /msg %crypt OURNICK:$N;/msg %crypt !$0!$2-
X/on ^public_other "* * CLIPPER:*" /msg %crypt !$0:$1!$2-
X/on ^public_other "* * SKPJACK:*" /msg %crypt OURNICK:$N;/msg %crypt !$0:$1!$2-
X
X/on ^msg "* CLIPPER:*" /msg %crypt !*$0*!$1-
X/on ^msg "* SKPJACK:*" /msg %crypt OURNICK:$N;/msg %crypt !*$0*!$1-
X
X# messages comming back from crypt, to server or screen?
X/on ^exec "crypt TCHANNL: *" /msg $C $2-
X/on ^exec "crypt TSCREEN: *" /echo $2-
X/on ^exec "crypt TNICKNM: *" /msg $2 $3-
X
X# our irc commands:
X#    /key nick  or /key nick filename
X#    /die
X#    /e message to be encrypted
X#    /p message to be plaintext
X#    /crypt   (turn on automatic encryption)
X#    /plain   (turn off automatic encryption)
X#    /emsg nick text  send an encrypted message
X/alias key /echo K->*$0* Sending Key;/^msg %crypt SENDKEY: $0-
X/alias die /^msg %crypt QUITDIE:;/query 
X/alias e /echo E> $0-;/^msg %crypt CRYPTME:$0-
X/alias p /msg $C $0-
X/alias crypt /query %crypt
X/alias plain /query
X/alias emsg /echo E->*$0* $1-;/^msg %crypt !$0!CRYPTME:$1-
X
X/echo *** Encrypted Irc Protocol loaded. 
END_OF_FILE
  if test 1550 -ne `wc -c <'Circ/crypt.irc2'`; then
    echo shar: \"'Circ/crypt.irc2'\" unpacked with wrong size!
  fi
  # end of 'Circ/crypt.irc2'
fi
if test -f 'Circ/d3des/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/d3des/main.c'\"
else
  echo shar: Extracting \"'Circ/d3des/main.c'\" \(711 characters\)
  sed "s/^X//" >'Circ/d3des/main.c' <<'END_OF_FILE'
X
X#include "d3des.h"
Xunsigned long enkey[96],dekey[96];
Xunsigned long e1[32],e2[32],e3[32];
Xunsigned long d1[32],d2[32],d3[32];
X
Xmain()
X{
X  char *a,b[100],*k,*k1,*k2,*k3;
X
X  strcpy(b,"this is a test");
X  k="testing123423456789212345678";
X  k1="testing1";
X  k2="23423456";
X  k3="78921234";
X  deskey(k1,0); cpkey(e1);
X  deskey(k2,1); cpkey(d2);
X  deskey(k3,0); cpkey(e3);
X  des3key(k,0); cp3key(enkey);    /* set up long keys , encrypt */
X  des3key(k,1); cp3key(dekey);    /* decrypt */
X  use3key(enkey); Ddes(b,b);      /* encrypt b */
X  write(1,b,16);
X  use3key(dekey); Ddes(b,b);      /* decrypt b */
X  write(1,b,16);
X
X  usekey(e1); des(b,b);
X  usekey(d2); des(b,b);
X  usekey(e3); des(b,b);
X  write(1,b,16);
X}
X
END_OF_FILE
  if test 711 -ne `wc -c <'Circ/d3des/main.c'`; then
    echo shar: \"'Circ/d3des/main.c'\" unpacked with wrong size!
  fi
  # end of 'Circ/d3des/main.c'
fi
if test -f 'Circ/d3des/readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/d3des/readme'\"
else
  echo shar: Extracting \"'Circ/d3des/readme'\" \(286 characters\)
  sed "s/^X//" >'Circ/d3des/readme' <<'END_OF_FILE'
XThis code by Richard Outerbridge implements DES with optional
Xdouble and triple encryption.  I think it's pretty fast, and
Xit doesn't take up much memory at runtime.
XRichard leaves a copyright notice on the code but encourages
Xfree use of the code.
X
XMark Riordan   mrr@scss3.cl.msu.edu
END_OF_FILE
  if test 286 -ne `wc -c <'Circ/d3des/readme'`; then
    echo shar: \"'Circ/d3des/readme'\" unpacked with wrong size!
  fi
  # end of 'Circ/d3des/readme'
fi
if test -f 'Circ/ignore.irc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/ignore.irc'\"
else
  echo shar: Extracting \"'Circ/ignore.irc'\" \(156 characters\)
  sed "s/^X//" >'Circ/ignore.irc' <<'END_OF_FILE'
X/on ^public "* CLIPPER:*" /comment
X/on ^public "* SKPJACK:*" /comment
X/on ^public_other "* * CLIPPER:*" /comment
X/on ^public_other "* * SKPJACK:*" /comment
END_OF_FILE
  if test 156 -ne `wc -c <'Circ/ignore.irc'`; then
    echo shar: \"'Circ/ignore.irc'\" unpacked with wrong size!
  fi
  # end of 'Circ/ignore.irc'
fi
if test -f 'Circ/pubkeys/al' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/pubkeys/al'\"
else
  echo shar: Extracting \"'Circ/pubkeys/al'\" \(261 characters\)
  sed "s/^X//" >'Circ/pubkeys/al' <<'END_OF_FILE'
XC21265D382D4E4F2C01C6CAEAEDF0278843A06DF78F4A4BA79FC09607471336B
X085AF92ED74A442160B5D3A8DA75F255E30E05C6D564633524DBBB9B614B7C99
X#
XDA4803B1FFE436844CBE6EFDA5405005B76BC8E90C575DD391723ACF8F9079BE
X277B1992A12EB70AA3C84FE460ACDAFA22EA71C4306EC79F9B7B398E6ABFDF5
END_OF_FILE
  if test 261 -ne `wc -c <'Circ/pubkeys/al'`; then
    echo shar: \"'Circ/pubkeys/al'\" unpacked with wrong size!
  fi
  # end of 'Circ/pubkeys/al'
fi
if test -f 'Circ/sock.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Circ/sock.h'\"
else
  echo shar: Extracting \"'Circ/sock.h'\" \(1318 characters\)
  sed "s/^X//" >'Circ/sock.h' <<'END_OF_FILE'
X#define DEFAULTSERVER   "netsys1.netsys.com"
X
X/*
X  Please fix these for your site: A FEW US SERVERS:
X  csd.bu.edu  mit.irc.edu  cm22.eng.umd.edu  ccwf.cc.utexas.edu
X  nic.funet.fi  cs.hut.fi  wpi.wpi.edu  chaos.cs.brandeis.edu 
X  emoryu1.cc.emory.edu  kvart.ifi.uio.no  vesuv.unisg.ch  ircserv.imp.ch 
X  stork.doc.ic.ac.uk  alf.uib.no  irc.nada.kth.se  eff.org  st6000.sct.edu 
X  husc10.harvard.edu  phoenix.princeton.edu  penfold.ece.uiuc.edu 
X  ucsu.colorado.EDU   badger.ugcs.caltech.edu  freedom.nmsu.edu  nuscc.nus.sg
X  kum.kaist.ac.kr  silver.ucs.indiana.edu  sapienza.roma.it  
X  bigvax.cs.biu.ac.il  hermes.tcad.ee.ufl.edu  tjeeves.acc.virginia.edu
X
X  Try to pick one CLOSEST to your domain if not in your domain.  There are
X  MANY more, but this is just ment to get you started, I just tried to give
X  a smattering of sites across the world.  I tried to cover every suffix 
X  that I could think of.  These are off the top of my head, so it's by no
X  means complete.  Use one if yours isn't listed and when you get on irc
X  ask someone if there's a closer site, try /who *.your.domain to find
X  people closest to you.
X
X  Notice how documentation is bigger than the code? :)
X */
X#define DEFAULTPORT	6667
X#define COMMANDCHAR	'/'
X
X/* couple fixes for non-ansi-c systems */
X#ifdef pyr
X#define strchr index
X#endif
X
END_OF_FILE
  if test 1318 -ne `wc -c <'Circ/sock.h'`; then
    echo shar: \"'Circ/sock.h'\" unpacked with wrong size!
  fi
  # end of 'Circ/sock.h'
fi
if test -f 'POSTER' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'POSTER'\"
else
  echo shar: Extracting \"'POSTER'\" \(982 characters\)
  sed "s/^X//" >'POSTER' <<'END_OF_FILE'
XFrom: Timothy Newsham <newsham@wiliki.eng.hawaii.edu>
XSubject: Re: Circ - encrypted irc package
X
XThe following (in uuencoded tar-Z format) is The first release (V1.0) of
Xthe Circ package.  It works in conjunction with the ircII client (chat
Xprogram: available at csd.bu.edu in pub/irc/clients)
X
XThe program allows for key management, key exchange and the exchange of
Xencrypted messages in real time over the IRC chat network.
X
XThe current version has been tested on Ultrix (decstation) and HPUX 9.0
X(hp9000) machines.  Previous versions have been tested on other
Xplatforms, the code is mostly made up of STDIO routines and should
Xcompile on most unix machines.
X
XAll code written by me is released into the public domain.
X
XThe code in the RSA and d3des directories were not authored by me but
Xare freely distributable.
X
X--
XModerators note:
XCirc was supplied to me as a single 127Kb shar file.  Since this was too
Xlarge to post directly, I've split it into 3 separate issues.
X
X+Alec-
END_OF_FILE
  if test 982 -ne `wc -c <'POSTER'`; then
    echo shar: \"'POSTER'\" unpacked with wrong size!
  fi
  # end of 'POSTER'
fi
echo shar: End of archive 3 \(of 3\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
