Newsgroups: comp.sources.misc
From: casey@gauss.llnl.gov (Casey Leedom)
Subject: v38i111:  lic - LLNL Line Integral Convolution, v1.2, Part08/10
Message-ID: <1993Aug12.013943.14381@sparky.sterling.com>
X-Md4-Signature: b1562ef7ddf7e116751da1583c916bb6
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 12 Aug 1993 01:39:43 GMT
Approved: kent@sparky.sterling.com

Submitted-by: casey@gauss.llnl.gov (Casey Leedom)
Posting-number: Volume 38, Issue 111
Archive-name: lic/part08
Environment: UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lic.1.2/README lic.1.2/avs/LIC.txt
#   lic.1.2/config/Makefile.config lic.1.2/liblic/ComputeImage.c
#   lic.1.2/liblic/Create.c lic.1.2/liblic/LIC_Filters.3
#   lic.1.2/liblic/liblic.h lic.1.2/test/ElectroStatic.c
# Wrapped by kent@sparky on Wed Aug 11 19:38:07 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 8 (of 10)."'
if test -f 'lic.1.2/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/README'\"
else
  echo shar: Extracting \"'lic.1.2/README'\" \(8211 characters\)
  sed "s/^X//" >'lic.1.2/README' <<'END_OF_FILE'
X$Header: /d/sisal/a/casey/tmp/lic/RCS/README,v 1.10 1993/08/11 17:34:08 casey Exp $
X
X
X          Installation notes on the LLNL LIC distribution
X
X
X Copyright (c) 1993 The Regents of the University of California.
X All rights reserved.
X
X Redistribution and use in source and binary forms, with or without
X modification, are permitted provided that the following conditions
X are met:
X 1. Redistributions of source code must retain the above copyright
X    notice, this list of conditions and the following disclaimer.
X 2. Redistributions in binary form must reproduce the above copyright
X    notice, this list of conditions and the following disclaimer in the
X    documentation and/or other materials provided with the distribution.
X 3. All advertising materials mentioning features or use of this software
X    must display the following acknowledgement:
X	This product includes software developed by the University of
X	California, Lawrence Livermore National Laboratory and its
X	contributors.
X 4. Neither the name of the University nor the names of its contributors
X    may be used to endorse or promote products derived from this software
X    without specific prior written permission.
X
X THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X SUCH DAMAGE.
X
X
XWHAT IS LLNL LIC?:
X
X    The LLNL LIC software distribution is an implementation of the
X    Line Integral Convolution algorithm.  Line Integral Convolution
X    can be used to visualize vector fields and generate a variety of
X    unique special effects.  For a thorough explanation of Line
X    Integral Convolutions see ``Imaging Vector Fields Using Line
X    Integral Convolution'' by Brian Cabral and Casey Leedom in the
X    SIGGRAPH '93 proceedings.
X
X    This software system consists of a library that implements the LIC
X    algorithm, a command line interface and an AVS coroutine module
X    interface.
X
X
XHOW TO INSTALL LIC:
X
X    SPECIAL NOTES TO USERS OF SIGGRAPH '93 CD-ROM:
X
X	Because the complete text and images of our paper is contained
X	in a separate directory on the CD-ROM, there is not a copy of
X	our paper in the doc subdirectory on the SIGGRAPH '93 CD-ROM.
X
X	Because the SIGGRAPH '93 CD-ROM is using a file system from hell,
X	we've had to rename nearly every file in the source distribution.
X	To get the correct names back, type the following on a UNIX
X	system that supports at least 18 character names:
X
X	    % sh FIXNAMES.SH
X
X	We recommend that after using FIXNAMES.SH you immediately
X	remove the script in order to save yourself from any possible
X	grief in the future because of an accidental execution.
X
X	We have made no effort to change the source to work with these
X	broken names.
X
X    PORTABILITY:
X
X	Where possible, this software has been written to conform to
X	ANSI C as defined in ANSI X3.159-1989 and POSIX 1003.1 as
X	defined in IEEE Std 1003.1-1990.  We strayed outside of this
X	goal for the command line interface which uses the Berkeley
X	mmap(2) interface to map files into virtual memory.  However,
X	the use of mmap is controlled via a compile-time configuration
X	define, so this shouldn't pose any portability problems.
X
X	The command line interface also uses getopt(3) to parse its
X	command line arguments.  Unfortunately getopt(3) was not
X	standardized in either of the above standards, but it a
X	useful and highly common facility.  If you don't have it in
X	your vendor supplied system a version can be obtained from
X	the GNU project.
X
X	At the time of this writing the software has been compiled and
X	tested on HP Snakes running HP-UX 9.01, IBM RS6000s running
X	AIX 3.2, SGIs running IRIX 4.0.5 and Sun Sparcs running SunOS
X	4.1.1.  The previous version of the software also ran on DEC
X	Alphas running OSF1 but we've lost our access to that platform
X	and can't test it for this version of the software.  However, we
X	don't anticipate any large problems porting the current software
X	to that platform.
X
X    All the configuration information is contained in the file
X    "config/Makefile.config."  The configuration scheme is grossly modeled
X    on the X11 imake scheme, but without imake ...  (I told you it was
X    gross.)
X
X    In any case, each directory contains two Makefiles: "Makefile" and
X    "Makefile.tmpl."  The Makefile basically reinvokes make for all
X    targets with roughly the following command:
X
X	make -f $(TOP)/config/Makefile.config \
X	     -f ./Makefile \
X	     -f $(TOP)/config/Makefile.std
X
X    The Makefile.tmpl contains all the real make commands to generate and
X    install the contents of the current directory.
X
X    After editing config/Makefile.config, type the following in the
X    top level directory:
X
X	% make clean
X	% make
X
X    TESTING THE SYSTEM:
X
X	If everything went okay, you should now have a working system.  To
X	test it, try the following:
X
X	    % cd test
X	    % make test
X
X	The Makefile will generate a 256 x 256 white noise image and a
X	checker board vector field.  It will then run the lic command
X	against these to generate a basket weave image.
X
X    Once you're happy with the software and want to install it on your
X    system, just type the following in the top level directory:
X
X	% make install
X	% make clean
X
X
XWHERE TO GO FROM HERE:
X
X    Hopefully the source code to the command line and AVS interfaces
X    will serve as useful trivial examples.  At least we always find it
X    easier to steal code than to read manual pages. :-)
X
X    If you find yourself overcome with an urge to read documentation,
X    a complete set of manual pages has been provided.  For general
X    information of the LIC algorithm and the LIC library you should
X    read LIC.3.  For information on creating, manipulating and
X    destroying LIC objects you should read LIC_Create.3, LIC_Change,
X    LIC_Query and LIC_Destroy.3.  Finally LIC_ComputeImage.3 will
X    anticlimatically tell you how you can get the library to actually
X    invoke the algorithm.  Once you feel comfortable with those, you
X    should probably attack LIC_Filters.3 and LIC_Convolve.3 which let
X    you get at the heart of the algorithm.
X
X    The file ABSTRACT contains a summary abstract of this software.
X    It is used by LLNL's software release program to help catalogue
X    software in a standard form.  Similarly, the file MEMO is also
X    part of LLNL's software release process and contains a ``memo of
X    understanding'' describing why we wanted to release this software.
X
X    The file TODO in the top level directory contains a brief set of
X    notes describing things left to finish in the implementation.
X
X    The directory doc/siggraph93 contains our SIGGRAPH '93 paper.
X    Minimally it should should include a PostScript version of the
X    paper with most of the figures missing (the full PostScript for
X    our paper is 24MB!)  Depending on where you got this distribution
X    from, there may also be a subdirectory "figures" which contains
X    the figures for the paper.  This is a maybe because it's 6.3MB of
X    compressed TIFF and EPS files and some distributors may Just Say
X    No to that much cruft.
X
X
XWHERE TO SEND CORRESPONDENCE:
X
X    If you have bug reports, fixes, suggestions, or just want to talk about
X    the software, address your correspondence to:
X
X
X	Brian Cabral
X	Mail Stop: L-416
X        Lawrence Livermore National Laboratory
X        Livermore, CA
X        USA
X
X	email: cabral1@llnl.gov
X	phone: (USA) 510-423-0201
X
X
X
X        Casey Leedom
X        Mail Stop: L-410
X        Lawrence Livermore National Laboratory
X        Livermore, CA
X        USA
X
X        email: casey@gauss.llnl.gov
X        phone: (USA) 510-423-7775
END_OF_FILE
  if test 8211 -ne `wc -c <'lic.1.2/README'`; then
    echo shar: \"'lic.1.2/README'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/README'
fi
if test -f 'lic.1.2/avs/LIC.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/avs/LIC.txt'\"
else
  echo shar: Extracting \"'lic.1.2/avs/LIC.txt'\" \(8630 characters\)
  sed "s/^X//" >'lic.1.2/avs/LIC.txt' <<'END_OF_FILE'
XAVS Modules						                    LIC
XLawrence Livermore National Laboratory
X
XNAME
X     LIC - 2D Line Integral Convolution (LIC) vector field imager
X
XSUMMARY
X     Name	   LIC
X
X     Type	   mapper
X
X     Inputs	   field 2D 2-vector float (vector field)
X	           field 2D 4-vector byte (image)
X
X     Outputs	   field 2D 4-vector 2-space byte (filtered image)
X
X     Parameters	   
X	Name		           Type         Default		Min	  Max
X	---------------------------------------------------------------------
X	Filter type        	   choice	Box		N/A       N/A
X	Normalization type 	   choice	Variable        N/A       N/A
X	Length             	   integer	10              0         1000
X	Frequency             	   real 	3.0             0.1       100.0
X	Variable length filtering  toggle	off		off	  on
X	Variable speed filtering   toggle	off		off       on
X	Animate                    toggle       off             off       on
X	red			   integer      -1              -1        255
X	green			   integer      -1              -1        255
X	blue			   integer      -1              -1        255
X	alpha			   integer      -1              -1        255
X
X
XDESCRIPTION
X     This module one-dimensionally filters the input image along local
X     stream lines defined by the input vector field. The resulting
X     output image appears as though it was painted using a coarse
X     brush. Many options exist for modifying the behavior of the
X     algorithm and thus controlling the appearance of the output image
X     (see below).  Particularly noteworthy is the ripple filter option
X     used in conjunction with the animate option. One can use these
X     two options to animate a sequence, visualizing the flow of the
X     vector field for a single time step.
X
X     An arbitrary RGBA image can be used as input, however white or
X     band limited noise produce the most effective scientific
X     visualizations.  The input image and vector field need not be the
X     same size. If the input image is smaller the input vector field
X     then the image is replicated and truncated to match the vector
X     field dimensions. Best results occur when contrast stretching the
X     output (see example 1).
X
X     The algorithm details and descriptions are presented in the
X     SIGGRAPH '93 paper ``Imaging Vector Fields Using Line Integral
X     Convolution'' by Brian Cabral and Casey Leedom.
X
XINPUTS
X     Input field - a 2-D 2-vector float field
X	A classic 2-space 2-vector field. Note that many 3-D slicing tools
X	produce 2-dimensional 3-vector fields and will require using the
X	extract vector module to remove one of the 3-vector components.
X
X     Input texture - a 2-D 4-vector byte RGBA image
X	An arbitrary RGBA image. Note currently the alpha channel is
X	ignored.
X
XPARAMETERS
X
X     Filter type
X	Choice: Box, Ripple, Ramp or Select
X	Default: Box
X
X	The Box filter is the default filter. The Ripple filter can be
X	used for animating vector field flow for a single time step.
X	The Ramp filter can be used for motion blurring and special
X	effects.  The Select filter selects an approximately one pixel
X	wide window near the end of the locally advected streamline.
X	This can be used to produce a warp of the input texture.
X
X     Normalization type
X	Choice: Fixed or Variable
X	Default: Variable
X
X	Fixed normalization uses a constant value to normalize the
X	output pixel intensity. This type of normalization causes
X	field singularities to appear darkener.  If the vector field
X	flows out of or into an edge this edge is also attenuated.
X	Variable normalization normalizes the output pixel so that the
X	entire image appears uniform in brightness (assuming uniform
X	brightness in the input image) irrespective of any vector
X	field singularities.
X
X     Length
X	Integer
X	Default: 10
X
X	This parameter controls the amount of blurring or the length
X	of the line integral convolution. The number is given in unit
X	pixels. Note that the run time of the algorithm is
X	proportional to this parameter.
X
X     Frequency
X	(only available for filter type "ripple")
X	Real
X	Default: 3.0
X
X	This parameter is only used in conjunction with the ripple
X	filter.  It specifies the number cycles of the ripple filter
X	over the length of the filter.  This governs the relative
X	feature size of apparent motion when used with the animate
X	option. Smaller values for frequency produce bigger features.
X	However, low frequency values produce animations which appear
X	to come in to and out of apparent focus (i.e.  the filter
X	has poor frequency response).  High frequencies have better
X	frequency response, but smaller apparent features.  Finally,
X	the frequency response problem can also be dealt with by
X	increasing the length of the filter, but this may introduce
X	more blurring than desired.  There's no free lunch.
X
X     Variable length filtering
X	Toggle
X	Default: off
X
X	Enabling variable length filtering.  The filter length for each
X	vector v will vary from 0 to Length based on the vector's
X	magnitude.  This magnitude scaling is performed by finding the
X	maximum magnitude vector in the input vector field, max_v, and
X	then using a filter length equal to Length * ||v|| / ||max_v||.
X	The filter will be dilated to match the length of the convolution.
X	This prevents any visual artifacts which might occur because of
X	abrupt filter truncation if the filter were not dilated.
X
X     Variable speed filtering
X	(only available for filter type "ripple")
X	Toggle
X	Default: off
X
X	This option is used in conjunction with the ripple filter in
X	animation mode. When enabled the LIC algorithm will vary
X	apparent motion flow as a function of the vector field
X	magnitude so that high magnitude portions of the vector field
X	move faster than low magnitude parts.  This is accomplished by
X	scaling the ripple filter frequency inversely by vector
X	magnitudes.
X
X     Animate
X	(only available for filter type "ripple")
X	Toggle
X	Default: off
X
X	Enabling the animate option will cause this module to produce
X	LIC_ANIMATION_FRAMES animated frames showing vector field flow
X	for a single time step.  The phase of the ripple filter will
X	be different for each frame, varying from 0 to 2*Pi.
X	LIC_ANIMATION_FRAMES is currently hardwired to 10.
X
X     Red, Green, Blue and Alpha
X	Integer
X	Default: -1
X
X	These RGBA values instruct the module on how to color pixels which
X	map onto zero length vectors. A value of -1 instructs the
X	algorithm to use the underlying texture pixel value for the given
X	color channel.
X
XOUTPUTS
X      Output image - 2D 4-vector 2-space byte field RGBA image
X	The module generates the usual RGBA AVS image which can be
X        displayed or otherwise manipulated.
X
XEXAMPLE	1
X	The first example illustrates the use of the LIC module
X	to visualize a 2-D vector field. Note the use of the contrast
X        stretching module to produce a crisper image. Good contrast values
X        are 50 and 200 for the input minimum and maximum values
X        respectively.
X
X	READ FIELD      GENERATE NOISE
X             |            |
X             +----------+ |
X                        | |
X                        LIC
X                         |
X                         |
X                      CONTRAST
X                         |
X                 +-------+------+
X                 |              |
X          DISPLAY IMAGE     WRITE IMAGE
X
XEXAMPLE	2
X	This second example is the same as first except it produces a
X        single time step flow animation. Note that the ripple function and
X        animation options must be enabled on the LIC algorithm the number
X        of frames is equal to the length of the LIC filter. The image
X        viewer will allow you to view and save the animation sequence.
X
X	READ FIELD      GENERATE NOISE
X             |            |
X             +----------+ |
X                        | |
X                        LIC
X                         |
X                         |
X                      CONTRAST
X                         |
X                    IMAGE VIEWER
X       
XFEATURES/BUGS
X     Asynchronous button display
X        When this module is invoked and the flow executive is disabled the
X        animate, period, and variable speed buttons will not become visible
X        upon selection of the ripple filter. In all other cases these latter
X        buttons become visible upon selection of the ripple filter and become
X        invisible upon selection of another filter.
X
XRELATED MODULES
X     Generate noise
X
XAUTHOR
X     Brian Cabral, Casey Leedom
X     Lawrence Livermore National Laboratory
X
X     Copyright (c) 1993 The Regents of the University of California.
X     All rights reserved.
X
X
XAVS Modules						                  LIC
XLawrence Livermore National Laboratory
END_OF_FILE
  if test 8630 -ne `wc -c <'lic.1.2/avs/LIC.txt'`; then
    echo shar: \"'lic.1.2/avs/LIC.txt'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/avs/LIC.txt'
fi
if test -f 'lic.1.2/config/Makefile.config' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/config/Makefile.config'\"
else
  echo shar: Extracting \"'lic.1.2/config/Makefile.config'\" \(5880 characters\)
  sed "s/^X//" >'lic.1.2/config/Makefile.config' <<'END_OF_FILE'
X#
X# $Header: /d/sisal/a/casey/tmp/lic/config/RCS/Makefile.config,v 1.6 1993/08/11 17:25:35 casey Exp $
X#
X
X# Installation targetting.  Any user commands will be installed in BINDIR,
X# libraries in LIBDIR, include files in INCDIR, manual pages in MAN1DIR
X# and MAN3DIR, avs modules in AVSMODDIR, avs module document in AVSDOCDIR,
X# etc.
X#
X      DESTDIR = 
X       BINDIR = $(DESTDIR)/usr/local/bin
X       LIBDIR = $(DESTDIR)/usr/local/lib
X       INCDIR = $(DESTDIR)/usr/local/include
X
X      MANROOT = $(DESTDIR)/usr/man
X      MAN1DIR = $(MANROOT)/man1
X      MAN1EXT = 1
X      MAN3DIR = $(MANROOT)/man3
X      MAN3EXT = 3
X      MANDIRS = $(MAN1DIR) $(MAN3DIR)
X
X       AVSDIR = $(DESTDIR)/usr/avs
X    AVSMODDIR = $(AVSDIR)/unsupp_mods
X    AVSDOCDIR = $(AVSDIR)/unsupp_doc
X
X# Specify "man" for MANINSTALL if you want unformatted troff source manual
X# pages installed in the above locations.  Specify "cat" if you want nroff
X# formatted manual pages installed.  Specify "none" if you don't want
X# manual pages installed.
X#
X   MANINSTALL = man
X
X# Protection modes to be set on various installation targets.
X#
X  INSTBINPROT = 555
X  INSTLIBPROT = 444
X  INSTINCPROT = 444
X  INSTMANPROT = 444
X  INSTDOCPROT = 444
X
X# Specify "avs" for AVS below if you have AVS and you want to build an AVS
X# LIC module.
X#
X# AVSLIBDIR is where AVS support libraries can be found.  AVS_INCLUDES are
X# -I include definitions that point to the AVS include directories.
X# AVS_DEFINES should include any special defines needed to compile AVS
X# coroutine modules on your system.  AVS_EXTRALIBS should contain any extra
X# library definitions needed to link AVS coroutine modules on your system.
X#
X# Using AVS 4.0 (under IBM AIX 3.2), we didn't need any special AVS_DEFINES
X# or AVS_EXTRALIBS.
X#
X# Using AVS 5.0 (under SGI IRIX 4.0.5), AVS_DEFINES should contain
X# -DNeedFunctionPrototypes=1 and AVS_EXTRALIBS needs to contain -lsun.
X#
X          AVS = 
X
X    AVSLIBDIR = $(AVSDIR)/lib
X AVS_INCLUDES = -I$(AVSDIR)/include
X  AVS_DEFINES = 
XAVS_EXTRALIBS = 
X
X
X# Algorithm configuration.  IMAGE_DEFINES should define one of the following
X# (yes, this should all be handled dynamically at run-time, but we ran out
X# of time):
X#
X#    ARGB, ABGR, RGBA, BGRA -- four byte pixels:  alpha, red, green and blue
X#    RGB, BGR               -- three byte pixels: red, green and blue
X#    MONOCHROME             -- one byte pixels:   grey scale
X#
XIMAGE_DEFINES = -DMONOCHROME
X
X# Setting MMAP_DEFINES to -DHAS_MMAP will cause the lic(1) command to use mmap
X# calls to map its input and output files directly into its address space.
X# If HAS_MMAP is not defined lic(1) will malloc memory for the input and
X# output files.  Using mmap has the advantage that it won't require space
X# on swap for the potentially very large images and also saves on pointless
X# I/O to swap.
X#
X MMAP_DEFINES = -DHAS_MMAP
X
X# Standard compilation environment definitions:
X#
X#  ***  Note that neither DEFINES nor INCLUDES should be used below.  They
X#  ***  are present for the benefit of various Makefile.tmpl files to add
X#  ***  includes and defines to the standard CFLAGS macro.
X#
X# DEC OSF1(alpha)
X#   1.	STD_DEFINES should contain -std1.
X#   2.	CDEBUGFLAGS should contain -g or -O (or -O2) depending on your
X#	debugging/performance needs.
X#   3.	Set RANLIB to ranlib.
X#
X# HP-UX 9.01(snake)
X#   1.	STD_DEFINES should contain -Aa, -D_INCLUDE_XOPEN_SOURCE,
X#	-D_INCLUDE_POSIX_SOURCE and -DHAS_HP_GETOPT.  Unfortunately getopt(3)
X#	wasn't part of either the ANSI C X3.159-1989 or POSIX 1003.1-1990
X#	standards.  HP has chosen a prototype for getopt that is in conflict
X#	with everyone else's.
X#   2.	Set RANLIB to /bin/true.
X#   3.	Wasn't able to use mmap even though it linked successfully.  You may
X#	have to remove -DHAS_MMAP from MMAP_DEFINES above.
X#
X# IBM AIX 3.2(rs/6000):
X#   1.	STD_DEFINES should contain -qlanglvl=ansi and -D_ALL_SOURCE.
X#   2.	CDEBUGFLAGS should contain -qsrcmsg. It should probably also contain
X#	-qextchk, but that causes the loader to complain about not being able
X#	to resolve references to LIC_Convolve_2D and LIC_Convolve_3D.
X#	CDEBUGFLAGS should also probably contain -g or -O depending on your
X#	debugging/performance needs.
X#   3.	Set RANLIB to /bin/true.
X#
X# SGI IRIX 4.0.5(mips):
X#   1.	CDEBUGFLAGS should contain -prototypes in order to get C function
X#	prototype checking.  CDEBUGFLAGS should also probably contain -g
X#	or -O depending on your debugging/performance needs.
X#   2.	Set RANLIB to /bin/true.
X#
X# SUN OS 4.1.1(sparc):
X#   1.	CC should be an ANSI C compiler like gcc or Sun's unbundled compiler.
X#	Sun's bundled compiler won't work.
X#   2.	If gcc is used, you'll probably have to add -I/usr/include to
X#	STD_INCLUDES because gcc seems to search its own local include
X#	directory before /usr/include which leads to all sorts of problems.
X#   3.	STD_DEFINES needs -DNEED_STRERROR, -DNEED_EXIT_CODES and
X#	-DHAS_OLD_TIMES.  Sun OS 4.1.1 fails to supply the ANSI C X3.159-1989
X#	strerror routine and the EXIT_SUCCESS and EXIT_FAILURE defines.  Its
X#	version of the times(2) call also doesn't conform to the POSIX
X#	definition; it returns 0 on success instead of a monotonically
X#	increasing wall clock time.
X#   4.	CDEBUGFLAGS should also probably contain -g or -O depending on your
X#	debugging/performance needs.
X#   5.	Set RANLIB to ranlib.
X#
X  BUILDINCTOP = $(TOP)/include
X    LIBLICDIR = $(TOP)/liblic
X       LIBLIC = $(LIBLICDIR)/liblic.a
X
X           CC = cc
X STD_INCLUDES = -I.
X TOP_INCLUDES = -I$(BUILDINCTOP)
X     INCLUDES = 
X  ALLINCLUDES = $(INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X  STD_DEFINES = 
X      DEFINES = 
X   ALLDEFINES = $(STD_DEFINES) $(DEFINES)
X  CDEBUGFLAGS = -O -prototypes
X       CFLAGS = $(CDEBUGFLAGS) $(ALLDEFINES) $(ALLINCLUDES)
X
X# Various programs we use ...
X#
X           AR = ar cq
X        NROFF = nroff
X       RANLIB = /bin/true
X        SHELL = /bin/sh
X        STRIP = strip
END_OF_FILE
  if test 5880 -ne `wc -c <'lic.1.2/config/Makefile.config'`; then
    echo shar: \"'lic.1.2/config/Makefile.config'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/config/Makefile.config'
fi
if test -f 'lic.1.2/liblic/ComputeImage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/liblic/ComputeImage.c'\"
else
  echo shar: Extracting \"'lic.1.2/liblic/ComputeImage.c'\" \(5991 characters\)
  sed "s/^X//" >'lic.1.2/liblic/ComputeImage.c' <<'END_OF_FILE'
X/*
X * $Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/ComputeImage.c,v 1.9 1993/07/28 18:54:58 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/ComputeImage.c,v 1.9 1993/07/28 18:54:58 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include "liblic.h"
X
X
X/*
X *	Perform Line Integral Convolution (LIC) on a LIC instance.
X *	==========================================================
X */
X
X
X#ifdef DEBUG
XFILE *ps;
X#endif
X
X
X/*
X *	Main code for top-level LIC computation.
X *	========================================
X */
X
X
Xvoid
XLIC_ComputeImage(LIC *This)
X    /*
X     * Compute LIC for each vector in input vector field.
X     */
X{
X    REGISTER int      i, j, k;
X
X#   ifdef DEBUG
X	ps = fopen("tmp.ps", "r+");
X	if (ps == NULL)
X	{
X	    perror("tmp.ps");
X	    exit(1);
X	}
X#   endif
X
X    /*
X     * Loop over the vector field rendering a pixel per field vector.
X     */
X    for (k = 0; k < This->OutputImage.Zres; k++)
X    {
X	/* Update status every slice for volume */
X	if (This->OutputImage.Zres > 1)
X	    if (This->UpdateUser)
X		This->UpdateUser(100.0 *  k / (float)This->OutputImage.Zres);
X
X	for (j = 0; j < This->OutputImage.Yres; j++)
X	{
X	    /* Update status every 10 scan lines for 2D fields */
X	    if (This->OutputImage.Zres == 1 && j % 10 == 0)
X		if (This->UpdateUser)
X		    This->UpdateUser(100.0 *  j / (float)This->OutputImage.Yres);
X
X	    for (i = 0; i < This->OutputImage.Xres; i++)
X	    {
X		double ForewardKernelArea, BackwardKernelArea;
X		double rForewardIntegral, gForewardIntegral,
X		       bForewardIntegral, aForewardIntegral;
X		double rBackwardIntegral, gBackwardIntegral,
X		       bBackwardIntegral, aBackwardIntegral;
X
X		if (This->OutputImage.Zres == 1)
X		{
X		    LIC_Convolve2D(This, i, j, LIC_FOREWARD,
X				   &rForewardIntegral, &gForewardIntegral,
X				   &bForewardIntegral, &aForewardIntegral,
X				   &ForewardKernelArea);
X		    LIC_Convolve2D(This, i, j, LIC_BACKWARD,
X				   &rBackwardIntegral, &gBackwardIntegral,
X				   &bBackwardIntegral, &aBackwardIntegral,
X				   &BackwardKernelArea);
X		}
X		else
X		{
X		    LIC_Convolve3D(This, i, j, k, LIC_FOREWARD,
X				   &rForewardIntegral, &gForewardIntegral,
X				   &bForewardIntegral, &aForewardIntegral,
X				   &ForewardKernelArea);
X		    LIC_Convolve3D(This, i, j, k, LIC_BACKWARD,
X				   &rBackwardIntegral, &gBackwardIntegral,
X				   &bBackwardIntegral, &aBackwardIntegral,
X				   &BackwardKernelArea);
X		}
X
X#		if (PixelSize >= 3)
X		{
X		    double red, green, blue;
X
X		    red   = (rForewardIntegral + rBackwardIntegral)
X			/ (ForewardKernelArea + BackwardKernelArea);
X		    green = (gForewardIntegral + gBackwardIntegral)
X			/ (ForewardKernelArea + BackwardKernelArea);
X		    blue  = (bForewardIntegral + bBackwardIntegral)
X			/ (ForewardKernelArea + BackwardKernelArea);
X
X		    /* k is 0 for 2D case ... */
X		    RED  (INDEX_3D(This->OutputImage, i, j, k)) = CLAMP(red);
X		    GREEN(INDEX_3D(This->OutputImage, i, j, k)) = CLAMP(green);
X		    BLUE (INDEX_3D(This->OutputImage, i, j, k)) = CLAMP(blue);
X		}
X#		endif
X#		if (PixelSize == 4 || PixelSize == 1)
X		{
X		    double alpha;
X
X		    alpha = (aForewardIntegral + aBackwardIntegral)
X			/ (ForewardKernelArea + BackwardKernelArea);
X
X		    ALPHA(INDEX_3D(This->OutputImage, i, j, k)) = CLAMP(alpha);
X		}
X#		endif
X
X#		ifdef DEBUG
X		    if (ThisPixel)
X		    {
X			int a, b;
X
X			fprintf(ps,  "stroke\n");
X			fprintf(ps,  "} def\n");
X			fprintf(ps,  "25 25 scale\n");
X			fprintf(ps,  "0.01 setlinewidth\n");
X			fprintf(ps,  "11 11 translate\n");
X			fprintf(ps,  "verticals\nhorizontals\n");
X			fprintf(ps,  "0.02 setlinewidth\n");
X			fprintf(ps,  "0.5 -0.5 translate\n");
X
X			for (a = i - 10; a < i + 10; a++)
X			{
X			    for (b = j - 10; b < j + 10; b++)
X			    {
X				fprintf(ps,  "%f %f %d %d arrow\n",
X					INDEX_2D(This->NormalField, a, b)[1],
X					INDEX_2D(This->NormalField, a, b)[0],
X					a-i, b-j);
X			    }
X			}
X			fprintf(ps,  "streamlines\n");
X			fprintf(ps,  "grestore\n");
X			fprintf(ps,  "showpage\n");
X			fclose(ps);
X		    }
X#		endif
X	    }
X	}
X    }
X}
END_OF_FILE
  if test 5991 -ne `wc -c <'lic.1.2/liblic/ComputeImage.c'`; then
    echo shar: \"'lic.1.2/liblic/ComputeImage.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/liblic/ComputeImage.c'
fi
if test -f 'lic.1.2/liblic/Create.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/liblic/Create.c'\"
else
  echo shar: Extracting \"'lic.1.2/liblic/Create.c'\" \(8493 characters\)
  sed "s/^X//" >'lic.1.2/liblic/Create.c' <<'END_OF_FILE'
X/*
X * $Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/Create.c,v 1.5 1993/07/28 18:54:58 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/Create.c,v 1.5 1993/07/28 18:54:58 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include "liblic.h"
X
X
X/*
X *	Create a LIC instance.
X *	======================
X */
X
X
X/*
X * Local support routines.
X */
Xstatic void   NormalizeVectorField(LIC_VectorField *This);
Xstatic double FindMaxVectorField(LIC_VectorField *This);
X
X
XLIC *
XLIC_Create(unsigned char *InputImage,
X	   int            iiXres,
X	   int            iiYres,
X	   int            iiZres,
X	   float         *InputField,
X	   int            ifXres,
X	   int            ifYres,
X	   int            ifZres,
X	   unsigned char *OutputImage,
X	   LIC_Filter     Filter,
X	   int            NormalizationType,
X	   int            Normalized,
X	   double         Length,
X	   double         Frequency,
X	   int            VariableLength,
X	   int            VariableSpeed,
X	   int            DefaultRed,
X	   int            DefaultGreen,
X	   int            DefaultBlue,
X	   int            DefaultAlpha,
X	   void		(*UpdateUser)(double),
X	   void		(*ReportError)(const char *))
X    /*
X     * Create a LIC instance variable, allocate and initialize various
X     * substructures and return a pointer to the new instance.  If
X     * memory can't be allocated for the new instance, return NULL.
X     */
X{
X    LIC *This;
X
X    This = (LIC *)malloc(sizeof(LIC));
X    if (This == NULL)
X    {
X	if (ReportError != NULL)
X	    ReportError("LIC__Create: Unable to allocate memory for LIC"
X			" instance variable");
X	return(NULL);
X    }
X
X    /*
X     * Copy constructor arguments into new instance variable.
X     */
X
X    This->InputImage.data = InputImage;
X    This->InputImage.Xres = iiXres;
X    This->InputImage.Yres = iiYres;
X    This->InputImage.Zres = iiZres;
X    This->InputImage.Rank = PixelSize;
X
X    This->InputField.data = InputField;
X    This->InputField.Xres = ifXres;
X    This->InputField.Yres = ifYres;
X    This->InputField.Zres = ifZres;
X    This->InputField.Rank = (ifZres == 1) ? 2 : 3;
X
X    /*
X     * Create normalized version of input vector field if it isn't already
X     * normalized.  Should probably check to see if field is *really*
X     * normalized, but there's only so much hand-holding you can do ...
X     */
X    This->NormalField = This->InputField;
X    if (!Normalized)
X    {
X	size_t fsize =
X	    sizeof(float) * This->NormalField.Rank
X	    * ifXres * ifYres * ifZres;
X
X	This->NormalField.data = (float *)malloc(fsize);
X	if (This->NormalField.data == NULL)
X	{
X	    if (ReportError)
X		ReportError("LIC_Create: Unable to allocate memory for"
X			    " normalized input vector field");
X	    free(This);
X	    return(NULL);
X	}
X	memcpy(This->NormalField.data, This->InputField.data, fsize);
X	NormalizeVectorField(&This->NormalField);
X    }
X
X    /*
X     * Create an output image buffer if the user didn't hand us one.
X     */
X    if (OutputImage)
X    {
X	This->OutputImage.data = OutputImage;
X	This->FreeOutput = FALSE;
X    }
X    else
X    {
X	size_t isize =
X	    sizeof(unsigned char) * PixelSize
X	    * ifXres * ifYres * ifZres;
X
X	This->OutputImage.data = (unsigned char *)malloc(isize);
X	if (This->OutputImage.data == NULL)
X	{
X	    if (ReportError)
X		ReportError("LIC_Create: Unable to allocate memory for"
X			    " output image");
X	    if (!This->Normalized)
X		free(This->NormalField.data);
X	    free(This);
X	    return(NULL);
X	}
X	This->FreeOutput = TRUE;
X    }
X
X    This->OutputImage.Xres  = ifXres;
X    This->OutputImage.Yres  = ifYres;
X    This->OutputImage.Zres  = ifZres;
X    This->OutputImage.Rank  = PixelSize;
X
X    This->Filter            = Filter;
X    This->NormalizationType = NormalizationType;
X    This->Normalized        = Normalized;
X    This->Length            = (Length < 0.0) ? 0.0 : Length;
X    This->Frequency         = (Frequency <= 0.0) ? 1e-6 : Frequency;
X    This->VariableLength    = VariableLength;
X    This->VariableSpeed     = VariableSpeed;
X
X#define SCLAMP(x) (((x) > 255) ? 255 : (((x) < -1) ?  0 : (x)))
X    This->DefaultRed        = SCLAMP(DefaultRed);
X    This->DefaultGreen      = SCLAMP(DefaultGreen);
X    This->DefaultBlue       = SCLAMP(DefaultBlue);
X    This->DefaultAlpha      = SCLAMP(DefaultAlpha);
X#undef SCLAMP
X
X    This->UpdateUser        = UpdateUser;
X    This->ReportError       = ReportError;
X
X    This->Phase             = 0.0;
X
X    if (This->VariableLength || This->VariableSpeed) {
X	This->MaxLength = FindMaxVectorField(&This->InputField);
X	if (This->MaxLength == 0.0)
X	    This->MaxLength = 1.0;	/* don't want to divide by 0 */
X    }
X    else
X	This->MaxLength = 0.0;	/* unused in this case */
X    This->NeedIntegration   = TRUE;
X
X    This->TotalLength       = 0.0;
X    This->TotalLoopCount    = 0;
X
X    return(This);
X}
X
X
Xstatic void
XNormalizeVectorField(LIC_VectorField *This)
X{
X    if (This->Zres == 1)
X    {
X	REGISTER int i, j;
X
X	for (j = 0; j < This->Yres; j++)
X	    for (i = 0; i < This->Xres; i++)
X	    {
X		REGISTER double fx, fy, mag;
X
X		fx = INDEX_2D(*This, i, j)[0];
X		fy = INDEX_2D(*This, i, j)[1];
X		mag = sqrt(fx*fx + fy*fy);
X		if (mag != 0)
X		{
X		    INDEX_2D(*This, i, j)[0] /= mag;
X		    INDEX_2D(*This, i, j)[1] /= mag;
X		}
X	    }
X    }
X    else
X    {
X	REGISTER int i, j, k;
X
X	for (k = 0; k < This->Zres; k++)
X	    for (j = 0; j < This->Yres; j++)
X		for (i = 0; i < This->Xres; i++)
X		{
X		    REGISTER double fx, fy, fz, mag;
X
X		    fx = INDEX_3D(*This, i, j, k)[0];
X		    fy = INDEX_3D(*This, i, j, k)[1];
X		    fz = INDEX_3D(*This, i, j, k)[2];
X		    mag = sqrt(fx*fx + fy*fy + fz*fz);
X		    if (mag != 0)
X		    {
X			INDEX_3D(*This, i, j, k)[0] /= mag;
X			INDEX_3D(*This, i, j, k)[1] /= mag;
X			INDEX_3D(*This, i, j, k)[2] /= mag;
X		    }
X		}
X    }
X}
X
X
Xstatic double
XFindMaxVectorField(LIC_VectorField *This)
X{
X    REGISTER double max;
X
X    max = 0.0;
X    if (This->Zres == 1)
X    {
X	REGISTER double mag;
X	REGISTER int    i, j;
X
X	for (j = 0; j < This->Yres; j++)
X	    for (i = 0; i < This->Xres; i++)
X	    {
X		mag = sqrt(  SQUARE(INDEX_2D(*This, i, j)[0])
X			   + SQUARE(INDEX_2D(*This, i, j)[1]));
X		if (mag > max)
X		    max = mag;
X	    }
X    }
X    else
X    {
X	REGISTER double mag;
X	REGISTER int    i, j, k;
X
X	for (k = 0; k < This->Yres; k++)
X	    for (j = 0; j < This->Yres; j++)
X		for (i = 0; i < This->Xres; i++)
X		{
X		    mag = sqrt(  SQUARE(INDEX_3D(*This, i, j, k)[0])
X			       + SQUARE(INDEX_3D(*This, i, j, k)[1])
X			       + SQUARE(INDEX_3D(*This, i, j, k)[2]));
X		    if (mag > max)
X			max = mag;
X		}
X    }
X    return(max);
X}
END_OF_FILE
  if test 8493 -ne `wc -c <'lic.1.2/liblic/Create.c'`; then
    echo shar: \"'lic.1.2/liblic/Create.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/liblic/Create.c'
fi
if test -f 'lic.1.2/liblic/LIC_Filters.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/liblic/LIC_Filters.3'\"
else
  echo shar: Extracting \"'lic.1.2/liblic/LIC_Filters.3'\" \(7610 characters\)
  sed "s/^X//" >'lic.1.2/liblic/LIC_Filters.3' <<'END_OF_FILE'
X.\" Copyright (c) 1993 The Regents of the University of California.
X.\" All rights reserved.
X.\"
X.\" Redistribution and use in source and binary forms, with or without
X.\" modification, are permitted provided that the following conditions
X.\" are met:
X.\" 1. Redistributions of source code must retain the above copyright
X.\"    notice, this list of conditions and the following disclaimer.
X.\" 2. Redistributions in binary form must reproduce the above copyright
X.\"    notice, this list of conditions and the following disclaimer in the
X.\"    documentation and/or other materials provided with the distribution.
X.\" 3. All advertising materials mentioning features or use of this software
X.\"    must display the following acknowledgement:
X.\"	This product includes software developed by the University of
X.\"	California, Lawrence Livermore National Laboratory and its
X.\"	contributors.
X.\" 4. Neither the name of the University nor the names of its contributors
X.\"    may be used to endorse or promote products derived from this software
X.\"    without specific prior written permission.
X.\"
X.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X.\" SUCH DAMAGE.
X.\"
X.de Hd
X.ds Dt \\$4
X..
X.Hd $Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/LIC_Filters.3,v 1.7 1993/08/10 23:35:32 casey Exp $
X.TH LIC_FILTERS 3 \*(Dt
X.SH NAME
XLIC_BuildIntegralTables, LIC_Box, LIC_Ripple, LIC_Ramp, LIC_Select \- Line Integral Convolution filter support
X.SH SYNOPSIS
X.nf
X#include <lic.h>
X
Xvoid \fBLIC_BuildIntegralTables\fP(LIC *\fIThis\fP)
Xdouble \fBLIC_Box\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ripple\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ramp\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Select\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X.fi
X.SH DESCRIPTION
X.if t .ds pi \(*p
X.if n .ds pi Pi
X.B LIC_BuildIntegralTables
Xbuilds tables of filter integral values for use in the LIC convolution
Xmethods.
X.B LIC_BuildIntegralTables
Xis automatically called by the convolution methods whenever any parameters
Xhave changed that will affect the filter integrals.
X.PP
XThe tables are discrete samples of the filter function integral for a
Xvariety of points along the filter kernel and for a variety of
X.IR speeds .
X.PP
XThe
X.I speed
Xvariations are used to implement the variable speed option of
X.BR LIC_Create .
XWith the variable speed option, high magnitude regions of the field will
Xuse higher
X.I speed
Xversions of the filter kernel.  These higher speeds variations are typically
Xfrequency scaled versions of the base frequency and are used in periodic
Xmotion animations to give the appearance of higher speed in higher magnitude
Xregions of the vector field.
XHowever, it is up to each filter integral function to implement its own
Xinterpretation of
X.I speed
X(see
X.B LIC_Ripple
Xbelow).
X.PP
XThe tables are broken up into integral values for the
Xpositive and negative halves of the filter integral as follows:
X.PP
X.RS
X.nf
Xpos[\fIspeed\fP][\fIsi\fP] = \fIFilter\fP(\fIThis\fP, 0.0, \fIs\fP, \fIspeed\fP)
Xneg[\fIspeed\fP][\fIsi\fP] = \fIFilter\fP(\fIThis\fP, -\fIs\fP, 0.0, \fIspeed\fP)
X
Xwhere
X
X0 <= \fIsi\fP < \fBLIC_INTEGRAL_LEN\fP
X0 <= \fIspeed\fP < \fBLIC_INTEGRAL_SPEEDS\fP
X
X\fIs\fP = \fILength\fP * ((double)\fIsi\fP / \fBLIC_INTEGRAL_LEN\fP)
X.fi
X.RE
X.PP
XCurrently
X.B LIC_INTEGRAL_LEN
Xis 2048 and
X.B LIC_INTEGRAL_SPEEDS
Xis 20.
X.PP
XThe tables are built up by calling a user specified filter integration
Xfunction for each of the above discrete sample points.  A simple example
Xis a ramp filter:
X.PP
X.RS
X.nf
X\fIk\fP(\fIs\fP) = (\fIs\fP + \fIL\fP) / 2\fIL\fP
X
Xintegral { \fIk\fP(\fIs\fP) \fIds\fP } = \c
X.if t (\fIs\fP\u\s-22\s+2\d + 2\fIL\fP\|\fIs\fP)/4\fIL\fP
X.if n (\fIs\fP^2 + 2\fIL\fP*\fIs\fP)/4\fIL\fP
X.fi
X.RE
X.PP
XWhich yields the following LIC filter integral function (with some algebraic
Xsimplifications):
X.PP
X.RS
X.nf
Xdouble
XLIC_Ramp(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X{
X.RS
Xif (\fBLIC_Length\fP(\fIThis\fP) == 0)
X.RS
Xreturn(0.0);
X.RE
Xelse
X.RS
Xreturn((\fIa\fP*\fIa\fP - \fIb\fP*\fIb\fP)/(4*\fBLIC_Length\fP(\fIThis\fP)) + (\fIa\fP - \fIb\fP)/2);
X.RE
X.RE
X}
X.fi
X.RE
X.PP
XFilters supplied with
Xthe LIC library include:
X.PP
X.RS
X.nf
Xdouble \fBLIC_Box\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ripple\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Ramp\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
Xdouble \fBLIC_Select\fP(LIC *\fIThis\fP, double \fIa\fP, double \fIb\fP, int \fIspeed\fP)
X.fi
X.RE
X.PP
X.B LIC_Box
Ximplements a constant box shape filter: \fIk\fP(\fIs\fP) =  1.
X.PP
X.B LIC_Ripple
Ximplements a phase shifted Hanning ripple function, windowed by a Hanning
Xfunction: \fIk\fP(\fIs\fP) = (cos(\fId\fP*\fIs\fP + \fIphase\fP) + 1)/2
X* (cos(\fIc\fP*\fIs\fP) + 1)/2.
XWhere
X.I d
Xand
X.I c
Xare the dilation constants for the ripple and window functions,
Xrespectively, and
X.I phase
Xis the phase shift of the ripple function.
X.I d
Xand
X.I c
Xcontrol the number of cycles of the Hanning functions over the filter kernel
Xfrom
X.RI - Length
Xto
X.RI + Length .
X.I d
Xis equal to \fIfrequency\fP * \*(pi / \fILength\fP and
X.I c
Xis always equal to \*(pi / \fILength\fP.
X.I frequency
Xis computed as follows:
X.PP
X.RS
X.nf
X/*
X * Implement ``speed'' variations by scaling the frequency inversely
X * to speed.  This causes low magnitude vectors to be convolved using
X * a higher frequency filter which will yield less distinct output
X * features.  As the frequency increases the filter begins to approximate
X * the Hanning window filter.
X */
X\fIm\fP = 6.0 - 5.0*(double)\fIspeed\fP/(\fBLIC_INTEGRAL_SPEEDS\fP - 1);
X
X\fIfrequency\fP = \fBLIC_Frequency\fP(\fIThis\fP) * \fIm\fP;
X.fi
X.RE
X.PP
XThis causes high magnitude regions to have fast moving, long
Xblurred looking features and low magnitude regions to have
Xslow moving, small sharp features over a blurred base.
X.PP
X.B LIC_Ramp
Ximplements  a ramp shape filter whose value is
X.B 0
Xat
X.RI - Length
Xand
X.B 1
Xat
X.RI + Length :
X\fIk\fP(\fIs\fP) = (\fIs\fP + \fIL\fP) / 2\fIL\fP.
X.PP
X.B LIC_Select
Ximplements a pixel selection filter which uses a narrow Gaussian
Xfilter positioned
X.IR L -2
Xdistance along the local streamline. It is called a selection filter
Xbecause its effect is to select an approximately one pixel wide
Xsection of the input image near the end of the local streamline
Xunderneath the Gaussian and place it at the origin of the local
Xstreamline.  A narrow Gaussian was chosen for its low-pass filter
Xqualities and simple analytical form, and is given by:
X\fIk\fP(\fIs\fP) = 1 / 2 * exp(-(\fIs\fP + \fIL\fP - 2)^2).
X.SH "SEE ALSO"
X.BR LIC (3),
X.BR LIC_Convolve (3),
X.BR LIC_Create (3)
X.SH STANDARDS
XThis is unsupported, non-standard software.  It is not the subject of any
Xstandards effort.
END_OF_FILE
  if test 7610 -ne `wc -c <'lic.1.2/liblic/LIC_Filters.3'`; then
    echo shar: \"'lic.1.2/liblic/LIC_Filters.3'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/liblic/LIC_Filters.3'
fi
if test -f 'lic.1.2/liblic/liblic.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/liblic/liblic.h'\"
else
  echo shar: Extracting \"'lic.1.2/liblic/liblic.h'\" \(6081 characters\)
  sed "s/^X//" >'lic.1.2/liblic/liblic.h' <<'END_OF_FILE'
X/*
X * $Header: /d/sisal/a/casey/tmp/lic/liblic/RCS/liblic.h,v 1.3 1993/05/28 04:27:31 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef _LIBLIC_H_
X#define _LIBLIC_H_
X
X
X/*
X * ANSI C and POSIX includes.
X */
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <string.h>
X#include <stdio.h>
X#include <sys/types.h>
X
X#include <math.h>
X
X#include <lic.h>
X
X
X/*
X * Input and output image configuration.  Should really be handled
X * dynamically at run-time ...
X */
X#if !defined(RGBA) && !defined(ABGR) && !defined(ARGB) && !defined(BGRA) \
X	&& !defined(RGB) && !defined(BGR) && !defined(MONOCHROME)
X#   define ARGB
X#endif
X
X#ifdef RGBA
X#   define PixelSize	4
X#   define PixelType	"RGBA"
X#   define ALPHA(i)	(i)[3]
X#   define RED(i)	(i)[0]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[2]
X#endif
X
X#ifdef BGRA
X#   define PixelSize	4
X#   define PixelType	"BGRA"
X#   define ALPHA(i)	(i)[3]
X#   define RED(i)	(i)[2]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[0]
X#endif
X
X#ifdef ARGB
X#   define PixelSize	4
X#   define PixelType	"ARGB"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[1]
X#   define GREEN(i)	(i)[2]
X#   define BLUE(i)	(i)[3]
X#endif
X
X#ifdef ABGR
X#   define PixelSize	4
X#   define PixelType	"ABGR"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[3]
X#   define GREEN(i)	(i)[2]
X#   define BLUE(i)	(i)[1]
X#endif
X
X#ifdef RGB
X#   define PixelSize	3
X#   define PixelType	"RGB"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[0]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[2]
X#endif
X
X#ifdef BGR
X#   define PixelSize	3
X#   define PixelType	"BGR"
X#   define ALPHA(i)	(i)[0]
X#   define RED(i)	(i)[2]
X#   define GREEN(i)	(i)[1]
X#   define BLUE(i)	(i)[0]
X#endif
X
X#ifdef MONOCHROME
X#   define PixelSize	1
X#   define PixelType	"MONOCHROME"
X#   define ALPHA(i)	(i)[0]
X#endif
X
X
X/*
X * Access macros for row major rectilinear images and other array data.
X */
X#define INDEX_2D(f, x, y) \
X	((f).data + (f).Rank * ((y)*(f).Xres + (x)))
X
X#define INDEX_3D(f, x, y, z) \
X	((f).data + (f).Rank * (((z)*(f).Yres + (y))*(f).Xres + (x)))
X
X
X/*
X * Amount of bias used to insure that we step over pixel/cell boundaries
X * when performing vector field stream line advection.
X */
X#define ROUND_OFF	0.00001
X
X
X/*
X * Default parallel edge/vector tolerance.  If an advected stream line and
X * an edge meet at an angle less than or equal to PARALLEL_EDGE, treat it
X * as an intersection of parallel lines (sic) and extend the advected stream
X * line out till it meets the next edge.
X */
X#define SIN_PARALLEL	0.523359562429	/* sin(three degrees) */
X#ifndef M_PI
X#   define M_PI		3.141592653589793116
X#endif
X
X
X/*
X * Define DEBUG to dump out PostScript to draw the streamline for the
X * vector field cell where the condition ThisPixel is TRUE.  Use the
X * PostScript prologue DebugPrologue.ps in this directory to get nice
X * output.  Note that this only works for two-dimensional fields.
X */
X#ifdef DEBUG
X#   define ThisPixel  (i == 42 && j == 64)
X#endif
X
X
X/*
X * define REGISTER to register on some machines for speed ...
X */
X#define REGISTER  register
X
X
X/*
X * Handy macros.
X */
X#define SQUARE(x)	((x)*(x))
X#define SIGN(x)		(((x) > 0) ? 1 : (((x) < 0) ? -1 : 0))
X#define CLAMP(x)	(((x) > 255) ? 255 : (((x) < 0) ?  0 : (x)))
X
X
X/*
X * Macro to wrap pixel coordinates in a torus like topology: 0 .. width-1.
X */
X#define WRAP(i, width) \
X{ \
X    if ((i) < 0) \
X    { \
X	/* we'll never be off more than one width negatively */ \
X	(i) += (width); \
X    } \
X    else if ((i) >= (width)) \
X    { \
X	/* we may be very far off positively ... */ \
X	(i) %= (width); \
X    } \
X}
X
X
X/*
X * Macros to take the floor and ceil of real numbers representing coordinates
X * within a vector lattice.  Since we're dealing with lattice coordinates,
X * we know that we're dealing with positive numbers, so we get to use
X * trucation to get floor.  Moreover, since we definitely won't be working
X * with vector fields with indexes larger than an int, we get to do the
X * truncation by simply casting into an int.  Finally, since we're dealing
X * with lattice coordinates, we get to use truncation + 1 to get ceil.
X */
X#define FLOOR(x)  ((double)(int)(x))
X#define CEIL(x)   ((double)((int)(x) + 1))
X#define IFLOOR(x) ((int)(x))
X#define ICEIL(x)  ((int)(x) + 1)
X
X
X#endif /* _LIBLIC_H_ */
END_OF_FILE
  if test 6081 -ne `wc -c <'lic.1.2/liblic/liblic.h'`; then
    echo shar: \"'lic.1.2/liblic/liblic.h'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/liblic/liblic.h'
fi
if test -f 'lic.1.2/test/ElectroStatic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lic.1.2/test/ElectroStatic.c'\"
else
  echo shar: Extracting \"'lic.1.2/test/ElectroStatic.c'\" \(7937 characters\)
  sed "s/^X//" >'lic.1.2/test/ElectroStatic.c' <<'END_OF_FILE'
X/*
X * $Header: /d/sisal/a/casey/tmp/lic/test/RCS/ElectroStatic.c,v 1.5 1993/08/11 16:31:54 casey Exp $
X */
X
X/*
X * Copyright (c) 1993 The Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Lawrence Livermore National Laboratory and its
X *	contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
X#ifndef lint
X    static char rcsid[] = "$Header: /d/sisal/a/casey/tmp/lic/test/RCS/ElectroStatic.c,v 1.5 1993/08/11 16:31:54 casey Exp $";
X    static char copyright[] =
X	"Copyright (c) 1993 The Regents of the University of California.\n"
X	"All rights reserved.\n";
X#endif
X
X
X#include <stdlib.h>
X#include <unistd.h>
X#include <errno.h>
X#include <fcntl.h>
X#include <string.h>
X#include <stdio.h>
X
X#include <math.h>
X#include <sys/types.h>
X
X#if defined(HAS_MMAP)
X#   include <sys/mman.h>
X#endif
X
X
X#ifdef NEED_EXIT_CODES
X    /*
X     * EXIT_SUCCESS and EXIT_FAILURE are supposed to be defined in <stdlib.h>
X     * according to the ANSI C X3.159-1989 specification, but Sun OS 4.1.1
X     * fails to define them ...
X     */
X#   define EXIT_SUCCESS    0
X#   define EXIT_FAILURE    1
X#endif
X
X
X#ifdef NEED_STRERROR
X    /*
X     * strerror is supposed to be defined in <string.h> and supplied in the
X     * standard C library according to the ANSI C X3.159-1989 specification,
X     * but Sun OS 4.1.1 fails to define or supply it ...  Unfortunately the
X     * only way we can control this is with an externally supplied define.
X     */
X    extern int      errno;		/* system error number */
X    extern char     *sys_errlist[];	/* system error messages */
X    extern int      sys_nerr;		/* number of entries in sys_errlist */
X
X    char *
X    strerror(int err)
X    {
X	if (err < 0 || err >= sys_nerr) {
X	    static char msg[100];
X
X	    sprintf(msg, "system error number %d", err);
X	    return(msg);
X	}
X	return(sys_errlist[err]);
X    }
X#endif
X
X
X/*
X * Create a three-dimensional electrostatic charge floating point vector
X * field.
X */
X
X
X#define SQUARE(x) ((x)*(x))
X
X#define N_CHARGES 2
Xdouble charge[N_CHARGES]   = { 1000.0, -1000.0 };
Xdouble charge_x[N_CHARGES] = { 1, -1 };
Xdouble charge_y[N_CHARGES] = { 1, -1 };
Xdouble charge_z[N_CHARGES] = { 1, -1 };
X
X
X/*
X * Internal routines to calculate electrostatic field values.
X */
Xdouble Fx(double x, double y, double z);
Xdouble Fy(double x, double y, double z);
Xdouble Fz(double x, double y, double z);
X
X
Xmain(int argc, char **argv)
X{
X    char          *myname;
X    char          *file;
X    int            Xres, Yres, Zres;
X    float         *VectorField;
X    size_t         FieldSize;
X    register int   i,  j, k;
X    register float x,  y,  z;
X    register float fx, fy, fz;
X    int            fd;
X    
X    myname = argv[0];
X    if (argc != 5)
X    {
X	fprintf(stderr, "\nUsage: %s file_name x_res y_res z_res\n", myname);
X	exit(1);
X    }
X    
X    /* grab arguments */
X    file = argv[1];
X    Xres = atoi(argv[2]);
X    Yres = atoi(argv[3]);
X    Zres = atoi(argv[4]);
X    FieldSize = Xres*Yres*Zres*(3*sizeof(float));
X    
X    /*
X     * Open the file here even for the non-mmap version just to make sure
X     * we can create it.
X     */
X    fd = open(file, O_CREAT|O_RDWR|O_EXCL, 0666);
X    if (fd < 0)
X    {
X	(void)fprintf(stderr, "%s: unable to open %s: %s\n",
X		      myname, file, strerror(errno));
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X
X#if defined(HAS_MMAP)
X
X    /*
X     * Pre-extend file to it's final size and map it into memory.
X     */
X    (void)lseek(fd, (off_t)(FieldSize - sizeof(fd)), SEEK_SET);
X    if (write(fd, (void *)&fd, sizeof(fd)) != sizeof(fd))
X    {
X	(void)fprintf(stderr, "%s: unable to preextend %s to %ld bytes: %s\n",
X		      myname, file, (int)FieldSize, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    VectorField = (float *)mmap((void *)0, (int)FieldSize, PROT_WRITE,
X			        MAP_SHARED, fd, (off_t)0);
X    if ((int)VectorField == -1)
X    {
X	(void)fprintf(stderr, "%s: unable to map %s: %s\n",
X		      myname, file, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    (void)close(fd);
X
X#else /* HAS_MMAP */
X
X    VectorField = (float *)malloc(FieldSize);
X    if (VectorField == NULL)
X    {
X	(void)fprintf(stderr, "%s: unable to allocate %d bytes of memory\n",
X		      myname, (int)FieldSize);
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    /*
X     * Should probably try to write the field now just to make sure there's
X     * enough disk space ...
X     */
X
X#endif /* HAS_MMAP */
X    
X    /*
X     * Create the electrostatic vector field ...
X     */
X    for (k = 0; k < Zres; k++)
X    {
X	z = (float)k/(float)Zres * 10.0 - 5.0;
X
X	for (j = 0; j < Yres; j++)
X	{
X	    y = (float)j/(float)Yres * 10.0 - 5.0;
X
X	    for (i = 0; i < Xres; i++)
X	    {
X		x = (float)i/(float)Xres * 10.0 - 5.0;
X		
X		fx = sqrt(fabs(Fx(x,y,z)));
X		fy = sqrt(fabs(Fy(x,y,z)));
X		fz = sqrt(fabs(Fz(x,y,z)));
X		
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 0] =  fx;
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 1] = -fy;
X		VectorField[3*(i + j*Xres + k*Xres*Yres) + 2] =  fz;
X	    }
X	}
X    }
X
X#if !defined(HAS_MMAP)
X    if (write(fd, (void *)VectorField, FieldSize) != FieldSize)
X    {
X	(void)fprintf(stderr, "%s: unable to write %ld bytes to %s: %s\n",
X		      myname, (int)FieldSize, file, strerror(errno));
X	(void)close(fd);
X	exit(EXIT_FAILURE);
X	/*NOTREACHED*/
X    }
X    (void)close(fd);
X#endif
X}
X
X
Xdouble
XFx(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((x - charge_x[i]) / sqrt(d2));
X    }
X    return(sum);
X}
X
X
Xdouble
XFy(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((y - charge_y[i]) / sqrt(d2));
X    }
X    return(sum);
X}
X
X
Xdouble
XFz(double x, double y, double z)
X{
X    int    i;
X    double sum;
X    
X    sum = 0;
X    for (i = 0; i < N_CHARGES; i++)
X    {
X	double d2 =  SQUARE(x - charge_x[i])
X		   + SQUARE(y - charge_y[i])
X		   + SQUARE(z - charge_z[i]);
X	sum += (charge[i] / d2) * ((z - charge_z[i]) / sqrt(d2));
X    }
X    return(sum);
X}
END_OF_FILE
  if test 7937 -ne `wc -c <'lic.1.2/test/ElectroStatic.c'`; then
    echo shar: \"'lic.1.2/test/ElectroStatic.c'\" unpacked with wrong size!
  fi
  # end of 'lic.1.2/test/ElectroStatic.c'
fi
echo shar: End of archive 8 \(of 10\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
