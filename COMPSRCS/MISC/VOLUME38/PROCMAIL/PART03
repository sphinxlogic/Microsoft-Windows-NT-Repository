Newsgroups: comp.sources.misc
From: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Subject: v38i022:  procmail - mail processing package v2.90, Part03/11
Message-ID: <1993Jul1.150913.20787@sparky.imd.sterling.com>
X-Md4-Signature: 7eb245a7f87a0800c457bacef1b81bdd
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 1 Jul 1993 15:09:13 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Posting-number: Volume 38, Issue 22
Archive-name: procmail/part03
Environment: sendmail, smail, MMDF, mailsurr, UNIX, POSIX
Supersedes: procmail: Volume 35, Issue 21-32,124,125

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 11)."
# Contents:  procmail/FEATURES procmail/Makefile
#   procmail/mailinglist/bin/arch_retrieve
#   procmail/mailinglist/bin/createlist
#   procmail/mailinglist/bin/flush_digests
#   procmail/mailinglist/bin/subscribe
#   procmail/mailinglist/etc/rc.submit procmail/mailinglist/install.sh
#   procmail/src/common.c procmail/src/cstdio.c procmail/src/fields.c
#   procmail/src/formail.h procmail/src/robust.c procmail/src/sublib.c
# Wrapped by berg@tubastos on Thu Jul  1 14:06:15 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'procmail/FEATURES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/FEATURES'\"
else
echo shar: Extracting \"'procmail/FEATURES'\" \(3407 characters\)
sed "s/^X//" >'procmail/FEATURES' <<'END_OF_FILE'
XFeature summary for procmail:
X	+ It's less filling (i.e. small)
X	+ Very easy to install (rated PG6 :-)
X	+ Simple to maintain and configure because
X	  all you need is actually only ONE executable (procmail)
X	  and ONE configuration file (.procmailrc)
X	+ Is event driven (i.e. gets invoked automagically when mail arrives)
X	+ Does not use *any* temporary files
X	+ Uses standard egrep regular expressions
X	+ It poses a very low impact on your system's resources
X	+ Allows for very-easy-to-use yes-no decisions on where the mail
X	  should go (can take the size of the mail into consideration)
X	+ Filters, delivers and forwards mail *reliably*
X	+ Provides a reliable hook (you might even say anchor :-) for any
X	  programs or shell scripts you may wish to start upon mail arrival
X	+ Performs heroically under even the worst conditions
X	  (file system full, out of swap space, process table full,
X	  file table full, missing support files, unavailable executables,
X	  denied permissions) and tries to deliver the mail somehow anyway
X	+ Absolutely undeliverable mail (after trying every trick in the book)
X	  will bounce back to the sender (or not, your choice)
X	+ Is one of the few mailers to perform reliable mailbox locking across
X	  NFS as well (DON'T use NFS mounted mailboxes WITHOUT installing
X	  procmail; you may lose valuable mail one day)
X	+ Supports four mailfolder standards: single file folders (standard
X	  and nonstandard VNIX format), directory folders that contain one file
X	  per message, or the similar MH directory folders (numbered files)
X	+ Variable assignment and substitution is an extremely complete subset
X	  of the standard /bin/sh syntax
X	+ Provides a mail log file, which logs all mail arrival, shows
X	  in summary whence it came, what it was about, where it went (what
X	  folder) and how long (in bytes) it was
X	+ Uses this log file to display a wide range of diagnostic and error
X	  messages (if something went wrong)
X	+ Does not impose *any* limits on line lengths, mail length (as long
X	  as memory permits), or the use of any character (any 8-bit character,
X	  including '\0' is allowed) in the mail
X	+ It has man pages (boy, does *it* have man pages)
X	+ Procmail can be used as a local delivery agent with comsat/biff
X	  support (*fully* downwards compatible with /bin/mail); in which case
X	  it can heal your system mailbox, if something messes up the
X	  permissions
X	+ Allows you to painlessly shift the system mailboxes into the
X	  user's home directories
X	+ It runs on virtually all (old and future) operating systems which
X	  names start with a 'U' or end in an 'X' :-) (i.e. extremely portable
X	  code; POSIX, ANSI C and K&R conforming)
X	+ Is clock skew immune (e.g. in the case of NFS mounted mailboxes)
X	+ Works with (among others?) sendmail, smail, MMDF and mailsurr
X
XFeature summary for formail:
X	+ Can generate auto-reply headers
X	+ Can convert mail into standard mailbox format (so that you can
X	  process it with standard mail programs)
X	+ Can split up mailboxes into the individual messages
X	+ Can split up digests into the individual messages
X	+ Can split up saved articles into the individual articles
X	+ Can do simple header munging/extraction
X
XFeature summary for lockfile:
X	+ Provides NFS-secure lockfiles to shell script programmers
X	+ Gives normal users the ability to lock their system mailbox,
X	  regardless of the permissions on the mail-spool directory
END_OF_FILE
if test 3407 -ne `wc -c <'procmail/FEATURES'`; then
    echo shar: \"'procmail/FEATURES'\" unpacked with wrong size!
fi
# end of 'procmail/FEATURES'
fi
if test -f 'procmail/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/Makefile'\"
else
echo shar: Extracting \"'procmail/Makefile'\" \(3396 characters\)
sed "s/^X//" >'procmail/Makefile' <<'END_OF_FILE'
X#$Id: Makefile,v 1.32 1993/06/25 13:38:38 berg Exp $
X
X# change BASENAME to your home directory if need be
XBASENAME = /usr/local
X
X# You can predefine ARCHITECTURE to a bin directory suffix
XARCHITECTURE=
X#ARCHITECTURE=.sun4
X
XBINDIR	  = $(BASENAME)/bin$(ARCHITECTURE)
XMANDIR	  = $(BASENAME)/man
X# MAN1SUFFIX for regular utility manuals
XMAN1SUFFIX= 1
X# MAN5SUFFIX for file-format descriptions
XMAN5SUFFIX= 5
XMAN1DIR	  = $(MANDIR)/man$(MAN1SUFFIX)
XMAN5DIR	  = $(MANDIR)/man$(MAN5SUFFIX)
X
X##############################
X# Things that can be made are:
X#
X# init (or makefiles)	Performs some preliminary sanity checks on your system
X#			and generates Makefiles accordingly
X# bins			Preinstalls only the binaries to ./new
X# mans			Preinstalls only the man pages to ./new
X# all			Does both
X# install.bin		Installs the binaries from ./new to $(BINDIR)
X# install.man		Installs the man pages from ./new to $(MAN[15]DIR)
X# install		Does both
X# recommend		Show some recommended suid/sgid modes
X# suid			Impose the modes shown by 'make recommend'
X# clean			Attempts to restore the package to pre-make state
X# realclean		Attempts to restore the package to pre-make-init state
X# deinstall		Removes any previously installed binaries and man
X#			pages from your system by careful surgery
X# autoconf.h		Will list your system's anomalies
X# procmail		Preinstalls just all procmail related stuff to ./new
X# formail		Preinstalls just all formail related stuff to ./new
X# lockfile		Preinstalls just all lockfile related stuff to ./new
X########################
X
X# Makefile.0 - mark, don't (re)move this, a sed script needs it
X
X#LOCKINGTEST=/tmp .	# Uncomment and add any directories you see fit.
X#			If LOCKINGTEST is undefined, autoconf will not
X#			prompt you to enter additional directories.
X#			See INSTALL for more information about the
X#			significance of the locking tests.
X
X########################################################################
X# Only edit below this line if you *think* you know what you are doing #
X########################################################################
X
X# Optional system libraries we search for
XSEARCHLIBS = -ldir -lx -lsocket -lnet -linet -lnsl_s -lnsl_i -lnsl -lsun -lgen\
X -lsockdns
X#			-lresolv	# not really needed, is it?
X
X# Informal list of directories where we look for the libraries in SEARCHLIBS
XLIBPATHS=/lib /usr/lib /usr/local/lib /usr/ucblib /usr/5lib /usr/ucb/lib \
X /lib/386
X
XCFLAGS0 = -O #-pedantic #-Wid-clash-6
XLDFLAGS0= -s
X
XCFLAGS1 = $(CFLAGS0) #-posix -Xp
XLDFLAGS1= $(LDFLAGS0) #-lcposix
X
X####CC	= cc # gcc
X# object file extension
XO	= o
XRM	= /bin/rm -f
XMV	= mv -f
XLN	= ln -f
XBSHELL	= /bin/sh
XINSTALL = cp
XDEVNULL = /dev/null
X
XSUBDIRS = src man
XBINSS	= procmail lockfile formail mailstat
XMANS1S	= procmail formail lockfile
XMANS5S	= procmailrc procmailex
X
X# Makefile - mark, don't (re)move this, a sed script needs it
X
XHIDEMAKE=$(MAKE)
X
Xall: init
X	$(HIDEMAKE) make $@
X
Xmake:
X	@$(BSHELL) -c "exit 0"
X
Xinit:
X	$(BSHELL) ./initmake $(BSHELL) "$(SHELL)" "$(RM)" "$(MV)" "$(LN)" \
X	 "$(SEARCHLIBS)" \
X	 "$(LIBPATHS)" \
X	 $(DEVNULL) "$(HIDEMAKE)" $(O) \
X	 "$(CC)" "$(CFLAGS1)" "$(LDFLAGS1)" "$(BINSS)" \
X	 "$(MANS1S)" "$(MANS5S)" "$(SUBDIRS)" \
X	 "$(BINDIR)"
X
Xmakefiles makefile Makefiles Makefile: init
X
Xbins mans install.bin install.man install recommend suid clean realclean \
Xveryclean clobber deinstall autoconf.h $(BINSS) multigram: init
X	$(HIDEMAKE) make $@
END_OF_FILE
if test 3396 -ne `wc -c <'procmail/Makefile'`; then
    echo shar: \"'procmail/Makefile'\" unpacked with wrong size!
fi
# end of 'procmail/Makefile'
fi
if test -f 'procmail/mailinglist/bin/arch_retrieve' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/bin/arch_retrieve'\"
else
echo shar: Extracting \"'procmail/mailinglist/bin/arch_retrieve'\" \(3830 characters\)
sed "s/^X//" >'procmail/mailinglist/bin/arch_retrieve' <<'END_OF_FILE'
X#! /bin/sh
X:
X#$Id: arch_retrieve,v 1.15 1993/05/05 15:15:55 berg Exp $
X
Xtest=test		# /bin/test
Xecho=echo		# /bin/echo
Xls=ls			# /bin/ls
Xrm=rm			# /bin/rm
Xsed=sed			# /bin/sed
Xcat=cat			# /bin/cat
Xformail=formail		# /usr/local/bin/formail
X
X$test -z "$listaddr" &&
X $echo "Don't start this script directly, it is used in rc.request" && exit 64
X
Xtmprequest=../tmp.request
Xtmpfrom=../tmp.from
X
Xcd archive
X
Xfrom=`$echo "arch_retrieve:" \`$cat $tmpfrom\` requested`
X$cat /dev/null >$tmpfrom
X
Xcase "$X_ENVELOPE_TO" in
X  *$list-request*) wrongaddress="" ;;
X  *) wrongaddress="WARNING:
X	Please try to use '$listreq'
X	the next time when issuing archive server requests.
X" ;;
Xesac
X
X$formail -k -xSubject: |
X $sed -e '/^--/,$ d' -e 's/^[	 ]*archive/ARCHIVE/' \
X  -e 's/[	 ]archive\/\/*/ /g' |
X (  oldwrongaddress="$wrongaddress"
X    wrongaddress="WARNING:
X	Please make sure to start the Subject: of requests to the archive-
X	server with the word archive.
X$wrongaddress"
X   sendhelp=""
X   ILLEGAL=""
X   while read line
X   do
X      set dummy $line
X      shift
X      case "$1" in
X	 archive|ARCHIVE) shift
X	    $test ! -z "$wrongaddress" && wrongaddress="$oldwrongaddress";;
X      esac
X      case "$1" in
X	 send|sendme|get|getme|gimme|retrieve|mail|\
X	 SEND|SENDME|GET|GETME|GIMME|RETRIEVE|MAIL)
X	    while shift; $test $# != 0
X	    do
X	       $echo $from "$1" >>$tmpfrom
X	       case "$1" in
X		  */../*|../*|*/..|..|[-/]*)
X		     $test -z "$ILLEGAL" && ILLEGAL="$1";;
X		  *)
X		   ( $formail -rt -I"Subject: archive retrieval: $1" \
X		      -i"From: $listreq" -A"X-Loop: $listaddr" \
X		      -I"Precedence: bulk" <$tmprequest
X		     $test ! -z "$wrongaddress" && $echo "$wrongaddress" &&
X		      wrongaddress=""
X		     if $test -f "./$1"
X		     then
X			$echo "File: $1"
X			$echo "BEGIN---------------cut here------------------"
X			$cat "./$1"
X			$echo "END-----------------cut here------------------"
X		     else
X			$echo "File $1 is not available."
X		     fi
X		   ) | $SENDMAIL $sendmailOPT -t ;;
X	       esac
X	    done ;;
X	 ls|dir|directory|list|show|\
X	 LS|DIR|DIRECTORY|LIST|SHOW)
X	    $test $# = 1 && set dummy .
X	    while shift; $test $# != 0
X	    do
X	       $echo $from "$1" ls >>$tmpfrom
X	       case "$1" in
X		  */../*|../*|*/..|..|[-/]*)
X		     $test -z "$ILLEGAL" && ILLEGAL="$1";;
X		  *)
X		   ( $formail -rt -I"Subject: archive retrieval: ls $1" \
X		      -i"From: $listreq" -A"X-Loop: $listaddr" \
X		      -I"Precedence: bulk" <$tmprequest
X		     $test ! -z "$wrongaddress" && $echo "$wrongaddress" &&
X		      wrongaddress=""
X		     if $test -r "./$1"
X		     then
X			$echo "ls -l $1"
X			$echo "BEGIN---------------cut here------------------"
X			$ls -lL "./$1" 2>/dev/null || $ls -l "./$1"
X			$echo "END-----------------cut here------------------"
X		     else
X			$echo "File or directory $1 is not available."
X		     fi
X		   ) | $SENDMAIL $sendmailOPT -t ;;
X	       esac
X	    done ;;
X	 "") ;;
X	 *) $test -z "$sendhelp" && sendhelp="$1" ;;
X      esac
X   done
X   if $test ! -z "$sendhelp" -o ! -z "$ILLEGAL"
X   then
X       ( $formail -rt -I"Subject: archive retrieval error" \
X	  -i"From: $listreq" -A"X-Loop: $listaddr" -I"Precedence: bulk" \
X	  <$tmprequest
X	 $test ! -z "$wrongaddress" && $echo "$wrongaddress" && wrongaddress=""
X	 $test ! -z "$sendhelp" && $echo "Unknown command $sendhelp."
X	 $test ! -z "$ILLEGAL" && $echo "Illegal filename $ILLEGAL requested."
X	 $echo ""
X	 $echo "This archive server knows the following commands:"
X	 $echo ""
X	 $echo "get filename ..."
X	 $echo "ls directory ..."
X	 $echo ""
X	 $echo "Aliases for 'get': send, sendme, getme, gimme, retrieve, mail"
X	 $echo "Aliases for 'ls': dir, directory, list, show"
X	 $echo ""
X	 $echo "Examples:"
X	 $echo "ls latest"
X	 $echo "get latest/12"
X       ) | $SENDMAIL $sendmailOPT -t
X   fi
X )
X
Xif $test ! -z "$archive_log"
Xthen
X  $cat $tmpfrom >>../$archive_log
Xfi
END_OF_FILE
if test 3830 -ne `wc -c <'procmail/mailinglist/bin/arch_retrieve'`; then
    echo shar: \"'procmail/mailinglist/bin/arch_retrieve'\" unpacked with wrong size!
fi
chmod +x 'procmail/mailinglist/bin/arch_retrieve'
# end of 'procmail/mailinglist/bin/arch_retrieve'
fi
if test -f 'procmail/mailinglist/bin/createlist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/bin/createlist'\"
else
echo shar: Extracting \"'procmail/mailinglist/bin/createlist'\" \(4274 characters\)
sed "s/^X//" >'procmail/mailinglist/bin/createlist' <<'END_OF_FILE'
X#!/bin/sh
X: &&O= || exec /bin/sh $0 $argv:q # we're in a csh, feed myself to sh
X#########################################################################
X#	createlist	To create mailinglists				#
X#									#
X#	Created by S.R. van den Berg, The Netherlands			#
X#########################################################################
X#$Id: createlist,v 1.16 1993/06/29 15:36:06 berg Exp $
X
Xdefaults=.etc
X
Xtest=test		# /bin/test
Xln=ln			# /bin/ln
Xtouch=touch		# /bin/touch
Xmkdir=mkdir		# /bin/mkdir
Xrmdir=rmdir		# /bin/rmdir
Xsed=sed			# /bin/sed
Xpwd=pwd			# /bin/pwd
Xcat=cat			# /bin/cat
Xrm=rm			# /bin/rm
Xcp=cp			# /bin/cp
Xls=ls			# /bin/ls
Xchmod=chmod		# /bin/chmod
Xecho=echo		# /bin/echo
Xgrep=grep		# /bin/grep
Xlockfile=lockfile	# /usr/local/bin/lockfile
X
Xbin_procmail=SedBinDir/procmail
X
XDEVNULL=/dev/null
XEX_USAGE=64
XEX_UNAVAILABLE=69
X
X( lockfile ) 2>$DEVNULL
Xif $test $? != 64
Xthen
X  $echo "Where is \"lockfile\"? It should be installed in your PATH" 1>&2
X  exit $EX_UNAVAILABLE
Xfi
X
Xif $test ! -d $defaults
Xthen
X  if $test -d list
X  then cd ./list
X  else cd ..
X     $test -d $defaults || cd ..
X  fi
Xfi
Xif $test ! -d $defaults
Xthen
X  $echo "createlist: You should be near the main list directory to do this" \
X   1>&2
X  exit $EX_USAGE
Xfi
X
Xif $test ! -x $bin_procmail
Xthen
X  OIFS="$IFS"
X  IFS=:"$IFS"
X  procmail=""
X
X  for a in $PATH
X  do $test -z "$procmail" -a -x "$a"/procmail && procmail=$a/procmail
X  done
X
X  IFS="$OIFS"
X  if $test -z "$procmail"
X  then
X     $echo "Where is \"procmail\"?" 1>&2
X     $echo "The symbolic link $bin_procmail must point to it" 1>&2
X     exit $EX_UNAVAILABLE
X  fi
X  $rm -f $bin_procmail
X  $ln -s $procmail $bin_procmail 2>/dev/null ||
X  $ln $procmail $bin_procmail 2>/dev/null ||
X   ( $cat >$bin_procmail <<HERE
X#! /bin/sh
X:
Xexec $procmail "\$@"
XHERE
X     $chmod 0755 $bin_procmail
X   )
Xfi
X
Xdomain=`$sed -n -e 's/^[^#]*domain= *\([^	 ]*\).*$/\1/p' \
X $defaults/rc.init`
X
Xif $test .$domain = .INSERT.YOUR.MAIL.DOMAIN.HERE
Xthen
X  $echo "I refuse to do anything useful until you have edited the" 1>&2
X  $echo "rc.init file.	\`domain' must be set to some sane value." 1>&2
X  exit $EX_USAGE
Xfi
X
Xarchiveserver=no
X$test .-a = ".$1" && shift && archiveserver=yes
X
Xif $test $# != 1 -a $# != 2 -o ".$1" = .-h
Xthen
X  $echo "Usage: createlist [-a] listname [maintainer]" 1>&2
X  $echo "	-a	create an archive server instead of a list" 1>&2
X  exit $EX_USAGE
Xfi
X
Xlist="$1"
Xmaintainer="$2"
X
Xcase "$list" in
X  "*[/	 ]*") $echo "createlist: Suspicious listname specified" 1>&2
X     exit $EX_USAGE;;
X  *[@!]*) $echo "createlist: Specify listname without domain name appended" \
X     1>&2; exit $EX_USAGE;;
Xesac
X
Xumask `$sed -n -e 's/^[^#]*UMASK=[^0-9]*\([0-9]*\).*$/\1/p' $defaults/rc.init`
X
Xif $mkdir "$list" 2>$DEVNULL
Xthen
X:
Xelse $echo "createlist: \"$list\" already exists" 1>&2; exit $EX_USAGE
Xfi
Xcd "$list"
Xfor a in rc.submit rc.init rc.request help.txt subscribe.txt reject
Xdo
X  $cat $DEVNULL >>../$defaults/$a		# to make sure it exists
X  $ln ../$defaults/$a $a
Xdone
X
X$mkdir archive
X$mkdir archive/latest
X
X$sed -e "/^maintainer/ s/=/=	$maintainer/" <../$defaults/rc.custom \
X >rc.custom
X$echo "(Only addresses below this line can be automatically removed)" >>dist
X
X$chmod ugo+x .
X$chmod ugo+r dist
X
Xif $test $archiveserver = yes
Xthen
X  $rmdir archive/latest
X  $rm -f dist subscribe.txt help.txt rc.submit rc.request
X  $cat >rc.submit <<HERE
XHOST=continue_with_rc.request
XHERE
X  $ln ../$defaults/rc.archive rc.request
Xelse
X  ln dist accept
Xfi
X
Xcd ..
X
X$echo 1>&2
X$echo "Installed the following files (many hardlinked):" 1>&2
X$echo 1>&2
X$ls -ld $list $list/* $list/*/* 1>&2 2>$DEVNULL
X$echo 1>&2
X
Xlistuser=`$ls -ld $defaults | ( read a b user d; $echo $user )`
X
XTMPF=.uniq.$$
X
Xlistdir=$HOME
X
Xtrap "$rm -f $TMPF" 1 2 3 15
X
X$touch $TMPF
Xtest -f $HOME/$TMPF || listdir=`$pwd`
X
X$rm -f $TMPF
Xtrap 1 2 3 15
X
Xflist=$listdir/SedBinDir/flist
X
X$echo "Now make the following entries in your /usr/lib/aliases file:" 1>&2
X$echo \########################################################################
X$echo "$list: \"|IFS=' ';exec $flist $list\""
X$echo "$list-request: \"|IFS=' ';exec $flist $list-request\""
X$test $archiveserver = no && $echo "$list-dist: :include:$listdir/$list/dist"
X$echo \########################################################################
END_OF_FILE
if test 4274 -ne `wc -c <'procmail/mailinglist/bin/createlist'`; then
    echo shar: \"'procmail/mailinglist/bin/createlist'\" unpacked with wrong size!
fi
chmod +x 'procmail/mailinglist/bin/createlist'
# end of 'procmail/mailinglist/bin/createlist'
fi
if test -f 'procmail/mailinglist/bin/flush_digests' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/bin/flush_digests'\"
else
echo shar: Extracting \"'procmail/mailinglist/bin/flush_digests'\" \(2728 characters\)
sed "s/^X//" >'procmail/mailinglist/bin/flush_digests' <<'END_OF_FILE'
X#!/bin/sh
X: &&O= || exec /bin/sh $0 $argv:q # we're in a csh, feed myself to sh
X#########################################################################
X#	flush_digests	To send off digests when needed			#
X#									#
X#	You should run it daily by cron (it needs to be started with	#
X#	an absolute path, do not rely on PATH to find it).		#
X#									#
X#	Created by S.R. van den Berg, The Netherlands			#
X#########################################################################
X#$Id: flush_digests,v 1.6 1993/06/04 13:49:04 berg Exp $
X
Xtest=test		# /bin/test
Xmkdir=mkdir		# /bin/mkdir
Xsed=sed			# /bin/sed
Xcat=cat			# /bin/cat
Xrm=rm			# /bin/rm
Xls=ls			# /bin/ls
Xecho=echo		# /bin/echo
Xtouch=touch		# /bin/touch
Xdirname=dirname		# /bin/dirname
Xlockfile=lockfile	# /usr/local/bin/lockfile
X
X$test \( $# != 0 -a $# != 1 \) -o $# = 1 -a .-c != ".$1" &&
X $echo "Usage: flush_digests [-c]" 1>&2 && exit 64
X
Xtmprequest=tmp.request
Xtmpfrom=tmp.from
X
Xdigestbody=archive/latest/digest.body
X
Xif $test .-c = ".$1"
Xthen
X  digestheader=archive/latest/digest.header
X  digestadmin=digest.admin
X  digestadmin2=archive/latest/$digestadmin
X  digesttrailer=archive/latest/digest.trailer
X
X  set `cat .digest.params`
X  digest_age=$1; shift
X  digest_size=$1; shift
X  archive_hist=$1; shift
X  umask $1; shift
X  SENDMAIL="$*"
X
X  if senddigest $digest_age $digest_size $digestbody $digesttrailer \
X   $tmprequest $tmpfrom $digestheader $digestadmin $digestadmin2
X  then
X     set dummy `$sed -n \
X      -e '1,/^$/ s/^Subject:.*Digest V\([0-9]*\) #\([0-9]*\)/\1 \2/p' \
X      <$digestheader`
X     Volume=archive/volume$2
X     Issue=$Volume/$3
X     $test -d $Volume || $mkdir $Volume
X     $cat $digestheader >$Issue
X     $echo "" >>$Issue
X     if $test -f $digestadmin -o -f $digestadmin2
X     then
X	$echo Administrivia: >>$Issue
X	$cat $digestadmin $digestadmin2 >>$Issue 2>/dev/null
X	$echo "" >>$Issue
X     fi
X     $cat >>$Issue <<HERE
X----------------------------------------------------------------------
X
XHERE
X     $cat $digestbody $digesttrailer >>$Issue
X     $rm -f $digesttrailer $digestbody $digestadmin $digestadmin2
X     $SENDMAIL <$Issue
X     cd archive
X     $rm -f `$ls -t volume*/* | $sed -e '1,'$archive_hist' d' -e '/[^0-9]/ d' `
X  fi
X
Xelse
X  a=`$dirname "$0"`/..
X  if cd "$a"
X  then
X  :
X  else
X     $echo "Can't chdir to $a" 1>&2 ; exit 66
X  fi
X  for a in */.digest.params dummy
X  do
X     if $test dummy != "$a"
X     then
X	list=`$dirname $a`
X	export list
X	cd $list
X	$lockfile -l3600 tmp.lock
X	trap "$rm -f tmp.lock; exit 1" 1 2 3 15
X	$cat /dev/null >$tmprequest 2>$tmpfrom
X	$test -f $digestbody && $touch $digestbody
X	PATH=.:../SedBinDir:../.bin:$PATH ../SedBinDir/flush_digests -c
X	trap "" 1 2 3 15
X	$rm -f tmp.lock
X	cd ..
X     fi
X  done
Xfi
END_OF_FILE
if test 2728 -ne `wc -c <'procmail/mailinglist/bin/flush_digests'`; then
    echo shar: \"'procmail/mailinglist/bin/flush_digests'\" unpacked with wrong size!
fi
chmod +x 'procmail/mailinglist/bin/flush_digests'
# end of 'procmail/mailinglist/bin/flush_digests'
fi
if test -f 'procmail/mailinglist/bin/subscribe' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/bin/subscribe'\"
else
echo shar: Extracting \"'procmail/mailinglist/bin/subscribe'\" \(2306 characters\)
sed "s/^X//" >'procmail/mailinglist/bin/subscribe' <<'END_OF_FILE'
X#! /bin/sh
X:
X#$Id: subscribe,v 1.16 1993/06/04 13:49:09 berg Exp $
X
Xtest=test		# /bin/test
Xecho=echo		# /bin/echo
Xcat=cat			# /bin/cat
Xsed=sed			# /bin/sed
Xgrep=grep		# /bin/grep
Xformail=formail		# /usr/local/bin/formail
Xmultigram=multigram	# ../SedBinDir/multigram
X
X$test -z "$listaddr" &&
X $echo "Don't start this script directly, it is used in rc.request" && exit 64
X
Xtmprequest=tmp.request
Xtmpfrom=tmp.from
Xsubscribetxt=subscribe.txt
X
Xcase "$X_ENVELOPE_TO" in
X  *$list-request*) wrongaddress="" ;;
X  *) wrongaddress="WARNING:
X	Please try to use '$listreq'
X	the next time when issuing (un)subscribe requests.
X" ;;
Xesac
X
Xsubscraddr=""
X
Xaddress=`$formail -k -xSubject: |
X $sed -n -e 'y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/' \
X  -e 's/add[	 ]*'\
X'[^	 ]*[	 ]\([^	 ][^	 ]*[@!][^	 ][^	 ]*\)/\1/p' \
X  -e 's/address[	 ]*'\
X'[^	 ]*[	 ]\([^	 ][^	 ]*[@!][^	 ][^	 ]*\)/\1/p' \
X  -e 's/sub[	 ]*'\
X'[^	 ]*[	 ]\([^	 ][^	 ]*[@!][^	 ][^	 ]*\)/\1/p' \
X  -e 's/subscribe[	 ]*'\
X'[^	 ]*[	 ]\([^	 ][^	 ]*[@!][^	 ][^	 ]*\)/\1/p' `
X
Xfor a in $address ""
Xdo
X  $test -z "$subscraddr" && subscraddr=$a
Xdone
X
Xif $test -z "$subscraddr"
Xthen
X  address=`$formail -k -xSubject: <$tmprequest |
X   $multigram -b1 -x$listreq -x$listaddr -l$off_threshold $tmpfrom |
X   $sed -e 's/^ *[^ ]* *[^ ]* *[^ ]* *\([^ ]*\)/\1/' `
X
X  for a in $address ""
X  do
X     $test -z "$subscraddr" && subscraddr=$a
X  done
X
X  $test -z "$subscraddr" && subscraddr=`$cat $tmpfrom`
Xfi
X
XNOT_METOO=""
X
X$formail -k -xSubject: <$tmprequest |
X $grep 'no.*[^a-z]cop.*[^a-z]please' >/dev/null && NOT_METOO=" (-n)"
X
X$multigram -a "$subscraddr$NOT_METOO" dist >/dev/null
X
X$test -z "$subscribe_log" ||
X $echo "subscribe: $subscraddr by:`$formail -rtxTo: <$tmprequest`" \
X >>$subscribe_log
X
X$formail -i"From: $listreq" -rtA"X-Loop: $listaddr" -I"Precedence: bulk" \
X <$tmprequest
X
X$test ! -z "$wrongaddress" && $echo "$wrongaddress" && wrongaddress=""
X
X$echo "You have added to the subscriber list of:"
X$echo
X$echo  "	$listaddr"
X$echo
X$echo "the following mail address:"
X$echo
X$echo  "	$subscraddr"
X$echo
Xif $test -z "$NOT_METOO"
Xthen
X  $echo "By default, copies of your own submissions will be returned."
Xelse
X  $echo "As requested, copies of your own submissions will not be returned."
Xfi
X$echo
X
X$cat $subscribetxt
X
X$sed -e 's/^\(.\)/>\1/' $tmprequest
END_OF_FILE
if test 2306 -ne `wc -c <'procmail/mailinglist/bin/subscribe'`; then
    echo shar: \"'procmail/mailinglist/bin/subscribe'\" unpacked with wrong size!
fi
chmod +x 'procmail/mailinglist/bin/subscribe'
# end of 'procmail/mailinglist/bin/subscribe'
fi
if test -f 'procmail/mailinglist/etc/rc.submit' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/etc/rc.submit'\"
else
echo shar: Extracting \"'procmail/mailinglist/etc/rc.submit'\" \(2836 characters\)
sed "s/^X//" >'procmail/mailinglist/etc/rc.submit' <<'END_OF_FILE'
X# BEFORE editing this file, you should make sure that it is not linked to
X# the master version (../.etc/rc.submit) anymore (i.e. "delink rc.request"
X# if you do not want your changes to affect all archive servers).
X#
X# New mails can be temporarily stalled by creating the file rc.lock (either in
X# ../.etc for all lists or in the current directory for this list only).
X
X#$Id: rc.submit,v 1.22 1993/06/29 15:36:16 berg Exp $
X
XINCLUDERC=$RC_INIT
XINCLUDERC=$RC_CUSTOM
X
X#
X# The following recipe makes sure that:
X#	The mail has a sane size (i.e. it is not inordinately big)
X#	It does not look like an administrative request.
X#	It wasn't sent by this list itself.
X#	It wasn't sent by a daemon (misdirected bounce message perhaps).
X# Then check to see if sender is a subscriber of this mailinglist, and while
X# doing so, also check if this subscriber wants to receive copies.
X#
X
X:0 Wh
X	* < $size_limit
X	* $!^$X_COMMAND:
X	* !^Subject:([	 ]*(archive([	 ]+((send|get)(me)?|gimme|retrieve|\
X	   mail|ls|dir(ectory)?|list|show|help|info)([	 ]|$))|[	 ]*$)|\
X	   (help|info)[	 ]*$)|[^:]*( (add .* to|(delete|remove) .* from|\
X	   take .* off|put .* on) .* [a-z-]*list|subscri(be|ption))
X	* $!^X-Loop: $listaddr
X	* !^Precedence:.*junk|^FROM_MAILER
XMETOO=	| formail -X"From " -xFrom: -xReply-To: -xSender: -xResent-From: \
X	    -xResent-Reply-To: -xResent-Sender: | \
X	   multigram -b1 -m -l$submit_threshold accept
X
X#
X# Check if this is a digested mailinglist.  If yes, processing stops here
X# and the mail will be added to the digest.
X#
X
X	:0 A W :tmp.lock
X	* $$digest_flag
X	| digest
X
X#
X# Check if we are the first mailinglist to distribute this message, if so
X# archive the message.
X#
X
X	:0 A c
X	* !^X-Mailing-List:
X	archive/latest/.
X
X#
X# Truncate the archive to the correct number of files (and possibly other
X# housekeeping chores to keep the archive current).
X#
X
X	:0 Ai c
X	* !^X-Mailing-List:
X	ARCHIVE=| arch_trunc "$-"
X
X#
X# Main header munger for submissions passing through this list.
X#
X
X	:0 A wfh
X	| formail -b -IReceived: -IReturn-Receipt-To: -IErrors-To: \
X	   -iReturn-Path: -iX-Envelope-To: -iX-Envelope-From: \
X	   -I"Precedence: list" -I"Resent-Sender: $listreq" \
X	   -a"Resent-From: $listaddr" -A"X-Loop: $listaddr" \
X	   -a"Subject: Unidentified subject!" \
X	   -a"X-Mailing-List: <$listaddr> $ARCHIVE"
X
X#
X# The following recipe will distribute the message to the subscribers.
X#
X
X	:0 A w: dist.lock
X	* !?test -z "$foreign_submit$METOO"
X	! $sendmailOPT $METOO $listdist
X
X       #! $sendmailOPT $METOO `sed -e '/^(.*)$/ d' dist` ;
X	# alternate sendmail call (if you don't have file-including aliases)
X
Xresult=$?
X
X	:0 A wfh
X	* ? test 0 != $result
X	| formail -A "X-Diagnostic: $SENDMAIL $listdist failed"
X
X	:0 A wfh
X	* ?test -z "$foreign_submit$METOO"
X	| formail -A "X-Diagnostic: Not on the subscriber list"
X
XHOST=continue_with_rc.request
END_OF_FILE
if test 2836 -ne `wc -c <'procmail/mailinglist/etc/rc.submit'`; then
    echo shar: \"'procmail/mailinglist/etc/rc.submit'\" unpacked with wrong size!
fi
# end of 'procmail/mailinglist/etc/rc.submit'
fi
if test -f 'procmail/mailinglist/install.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/install.sh'\"
else
echo shar: Extracting \"'procmail/mailinglist/install.sh'\" \(2306 characters\)
sed "s/^X//" >'procmail/mailinglist/install.sh' <<'END_OF_FILE'
X#! /bin/sh
X: &&O= || exec /bin/sh $0 $argv:q # we're in a csh, feed myself to sh
X#$Id: install.sh,v 1.23 1993/06/28 17:02:37 berg Exp $
X
XSHELL=/bin/shell
Xexport SHELL
X
Xtest $# != 1 -a $# != 2 && echo "Usage: install.sh target-directory [.bin]" &&
X exit 64
X
Xtarget="$1"
Xbindir="$2"
X
Xtest -z "$bindir" && bindir=.bin
X
Xtest ! -d "$target" && echo "Please create the target directory first" &&
X exit 2
X
Xif binmail=`procmail /dev/null DEFAULT=/dev/null LOG=\\\$SENDMAIL \
X  </dev/null 2>&1`
Xthen
X:
Xelse
X  echo "Please make sure that procmail is on our PATH"
X  exit 64
Xfi
X
Xif expr "X$bindir" : X.bin >/dev/null
Xthen
X:
Xelse
X  echo "I prefer a bin directory that starts with .bin"
X  echo "If you want to enforce a different name, patch install.sh first :-)."
X  exit 64
Xfi
X
Xcd "`dirname $0`"
XPATH=.:$PATH
X
Xexport target bindir binmail PATH
X
XTMPF=/tmp/list.id.$$
X
Xtrap "/bin/rm -f $TMPF; exit 1" 1 2 3 15
X
X/bin/rm -f $TMPF
X
Xecho Id test >$TMPF
X
XAM_ROOT=no
X
Xif ls -l $TMPF | grep '^[^ ]*  *[0-9][0-9]*  *root ' >/dev/null
Xthen
X  /bin/rm -f $TMPF
X  AM_ROOT=yes
X  installerid=`ls -l ../Makefile |
X   sed -e 's/^[^ ]* *[0-9][0-9]*[^0-9] *\([^ ]*\) .*$/\1/'`
X  listid=`ls -ld $target/. |
X   sed -e 's/^[^ ]* *[0-9][0-9]*[^0-9] *\([^ ]*\) .*$/\1/'`
X  if test root = $listid
X  then
X     echo "Please give $target the right owner & group first"
X     exit 2
X  fi
Xelse
X  /bin/rm -f $TMPF
X  if ( echo Id test >id.test ) 2>/dev/null
X  then
X  :
X  else
X     echo "Please run install.sh with root permissions instead"
X     exit 77
X  fi
X  /bin/rm -f id.test
X  listid=`ls -l install.sh |
X   sed -e 's/^[^ ]* *[0-9][0-9]*[^0-9] *\([^ ]*\) .*$/\1/'`
Xfi
X
Xtrap "" 1 2 3 15
X
Xexport listid
X
Xif test $AM_ROOT = yes
Xthen
X  case $installerid in
X     [0-9]*) . ./install.sh2;;
X     *) su $installerid ./install.sh2;;
X  esac
X  su $listid ./install.sh3
X  echo "Making $target/$bindir/flist suid root..."
X  chown root "$target/$bindir/flist"
X  chmod 04755 "$target/$bindir/flist"
Xelse
X  . ./install.sh2
X  . ./install.sh3
Xfi
X
Xecho '**********************************************************************'
Xecho "Finished installing, now you should"
Xecho "edit $target/.etc/rc.init to make sure"
Xecho "that \`PATH', \`domain' and \`listmaster' reflect your installation."
Xecho '**********************************************************************'
END_OF_FILE
if test 2306 -ne `wc -c <'procmail/mailinglist/install.sh'`; then
    echo shar: \"'procmail/mailinglist/install.sh'\" unpacked with wrong size!
fi
chmod +x 'procmail/mailinglist/install.sh'
# end of 'procmail/mailinglist/install.sh'
fi
if test -f 'procmail/src/common.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/common.c'\"
else
echo shar: Extracting \"'procmail/src/common.c'\" \(2278 characters\)
sed "s/^X//" >'procmail/src/common.c' <<'END_OF_FILE'
X/************************************************************************
X *	Some common routines for procmail and formail			*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	#include "README"						*
X ************************************************************************/
X#ifdef RCS
Xstatic /*const*/char rcsid[]=
X "$Id: common.c,v 1.11 1992/11/13 12:57:58 berg Exp $";
X#endif
X#include "procmail.h"
X#include "sublib.h"
X#include "robust.h"
X#include "shell.h"
X#include "misc.h"
X#include "common.h"
X
Xvoid shexec(argv)const char*const*argv;
X{ int i;char**newargv;const char**p;
X#ifdef SIGXCPU
X  signal(SIGXCPU,SIG_DFL);signal(SIGXFSZ,SIG_DFL);
X#endif
X#ifdef SIGLOST
X  signal(SIGLOST,SIG_DFL);
X#endif						/* or is it a shell script ? */
X  signal(SIGPIPE,SIG_DFL);execvp(*argv,(char*const*)argv);
X  for(p=(const char**)argv,i=1;i++,*p++;);	      /* count the arguments */
X  newargv=malloc(i*sizeof*p);
X  for(*(p=(const char**)newargv)=binsh;*++p= *argv++;);
X  execve(*newargv,newargv,environ);	      /* no shell script? -> trouble */
X  nlog("Failed to execute");logqnl(*argv);exit(EX_UNAVAILABLE);
X}
X
Xvoid detab(p)char*p;
X{ while(p=strpbrk(p,"\t\n\v\f\r"))
X     *p=' ';			     /* take out all tabs and other specials */
X}
X
Xchar*pstrspn(whole,sub)const char*whole,*const sub;
X{ while(*whole&&strchr(sub,*whole))
X     whole++;
X  return(char*)whole;
X}
X
X#ifdef NOstrcspn
Xstrcspn(whole,sub)const char*const whole,*const sub;
X{ const register char*p;
X  p=whole;
X  while(*p&&!strchr(sub,*p))
X     p++;
X  return p-whole;
X}
X#endif
X
Xvoid ultstr(minwidth,val,dest)unsigned long val;char*dest;
X{ int i;unsigned long j;
X  j=val;i=0;					   /* a beauty, isn't it :-) */
X  do i++;					   /* determine needed width */
X  while(j/=10);
X  while(--minwidth>=i)				 /* fill up any excess width */
X     *dest++=' ';
X  *(dest+=i)='\0';
X  do *--dest='0'+val%10;			  /* display value backwards */
X  while(val/=10);
X}
X
XstrnIcmp(a,b,l)register const char*a,*b;register size_t l;
X{ unsigned i,j;
X  if(l)						 /* case insensitive strncmp */
X     do
X      { while(*a&&*a==*b&&--l)
X	   a++,b++;
X	if(!l)
X	   break;
X	if((i= *a++)-'A'<='Z'-'A')
X	   i+='a'-'A';
X	if((j= *b++)-'A'<='Z'-'A')
X	   j+='a'-'A';
X	if(j!=i)
X	   return i>j?1:-1;
X      }
X     while(i&&j&&--l);
X  return 0;
X}
END_OF_FILE
if test 2278 -ne `wc -c <'procmail/src/common.c'`; then
    echo shar: \"'procmail/src/common.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/common.c'
fi
if test -f 'procmail/src/cstdio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/cstdio.c'\"
else
echo shar: Extracting \"'procmail/src/cstdio.c'\" \(2860 characters\)
sed "s/^X//" >'procmail/src/cstdio.c' <<'END_OF_FILE'
X/************************************************************************
X *	Custom standard-io library					*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	#include "README"						*
X ************************************************************************/
X#ifdef RCS
Xstatic /*const*/char rcsid[]=
X "$Id: cstdio.c,v 1.14 1993/06/21 14:24:15 berg Exp $";
X#endif
X#include "procmail.h"
X#include "robust.h"
X#include "cstdio.h"
X#include "misc.h"
X
Xstatic uchar rcbuf[STDBUF],*rcbufp,*rcbufend;	  /* buffer for custom stdio */
Xstatic off_t blasttell;
Xstatic struct dyna_long inced;				  /* includerc stack */
X
Xvoid pushrc(name)const char*const name;		      /* open include rcfile */
X{ struct stat stbuf;					   /* only if size>0 */
X  if(*name&&(stat(name,&stbuf)||!S_ISREG(stbuf.st_mode)||stbuf.st_size))
X   { app_val(&inced,rcbufp?(off_t)(rcbufp-rcbuf):(off_t)0);	 /* save old */
X     app_val(&inced,blasttell);app_val(&inced,(off_t)rc);   /* position & fd */
X     if(bopen(name)<0)			      /* and try to open the new one */
X	readerr(name),poprc();		       /* we couldn't, so restore rc */
X   }
X}
X
Xpoprc P((void))
X{ rclose(rc);					     /* close it in any case */
X  if(!inced.filled)				  /* include stack is empty? */
X     return 0;	      /* restore rc, seekpos, prime rcbuf and restore rcbufp */
X  rc=inced.offs[--inced.filled];lseek(rc,inced.offs[--inced.filled],SEEK_SET);
X  rcbufp=rcbufend;getb();rcbufp=rcbuf+inced.offs[--inced.filled];return 1;
X}
X
Xvoid closerc P((void))					/* {while(poprc());} */
X{ while(rclose(rc),inced.filled)
X     rc=inced.offs[inced.filled-1],inced.filled-=3;
X}
X
Xbopen(name)const char*const name;				 /* my fopen */
X{ rcbufp=rcbufend=0;return rc=ropen(name,O_RDONLY,0);
X}
X
Xgetbl(p)char*p;							  /* my gets */
X{ int i;char*q;
X  for(q=p;;)
X   { switch(i=getb())
X      { case '\n':case EOF:
X	   *q='\0';return p!=q;		     /* did we read anything at all? */
X      }
X     *q++=i;
X   }
X}
X
Xgetb P((void))							 /* my fgetc */
X{ if(rcbufp==rcbufend)						   /* refill */
X     blasttell=tell(rc),rcbufend=rcbuf+rread(rc,rcbufp=rcbuf,STDBUF);
X  return rcbufp<rcbufend?*rcbufp++:EOF;
X}
X
Xvoid ungetb(x)const int x;	/* only for pushing back original characters */
X{ if(x!=EOF)
X     rcbufp--;							   /* backup */
X}
X
Xtestb(x)const int x;		   /* fgetc that only succeeds if it matches */
X{ int i;
X  if((i=getb())==x)
X     return 1;
X  ungetb(i);return 0;
X}
X
Xsgetc P((void))					/* a fake fgetc for a string */
X{ return *sgetcp?*(uchar*)sgetcp++:EOF;
X}
X
Xskipspace P((void))
X{ int any=0;
X  while(testb(' ')||testb('\t'))
X     any=1;
X  return any;
X}
X
Xvoid getlline(target)char*target;
X{ char*chp2;
X  for(;getbl(chp2=target)&&*(target=strchr(target,'\0')-1)=='\\';
X   *target++='\n')					   /* read line-wise */
X     if(chp2!=target)					  /* non-empty line? */
X	target++;			      /* then preserve the backslash */
X}
END_OF_FILE
if test 2860 -ne `wc -c <'procmail/src/cstdio.c'`; then
    echo shar: \"'procmail/src/cstdio.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/cstdio.c'
fi
if test -f 'procmail/src/fields.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/fields.c'\"
else
echo shar: Extracting \"'procmail/src/fields.c'\" \(3562 characters\)
sed "s/^X//" >'procmail/src/fields.c' <<'END_OF_FILE'
X/************************************************************************
X *	Routines to deal with the header-field objects in formail	*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	#include "README"						*
X ************************************************************************/
X#ifdef RCS
Xstatic /*const*/char rcsid[]=
X "$Id: fields.c,v 1.10 1993/04/27 17:33:55 berg Exp $";
X#endif
X#include "includes.h"
X#include "formail.h"
X#include "sublib.h"
X#include "shell.h"
X#include "common.h"
X#include "fields.h"
X#include "ecommon.h"
X#include "formisc.h"
X
Xstruct field*findf(p,hdr)const struct field*const p,*hdr;
X{ size_t i;char*chp;		/* find a field in the linked list of fields */
X  for(i=p->id_len,chp=(char*)p->fld_text;hdr;hdr=hdr->fld_next)
X     if(i==hdr->id_len&&!strnIcmp(chp,hdr->fld_text,i))	 /* case insensitive */
X	return(struct field*)hdr;
X  return(struct field*)0;
X}
X
Xstruct field**addfield(pointer,text,totlen)register struct field**pointer;
X const char*const text;const size_t totlen;    /* add field to a linked list */
X{ register struct field*p;
X  while(*pointer)			      /* skip to the end of the list */
X     pointer= &(*pointer)->fld_next;
X  (*pointer=p=malloc(FLD_HEADSIZ+totlen))->fld_next=0;	 /* create the field */
X  p->id_len=breakfield(text,totlen);		  /* and copy field contents */
X  tmemmove(p->fld_text,text,p->tot_len=totlen);return pointer;
X}
X
Xvoid concatenate(fldp)struct field*const fldp;
X{ register char*p;register size_t l;	    /* concatenate a continued field */
X  l=fldp->tot_len;p=fldp->fld_text;
X  while(l--)
X     if(*p++=='\n'&&l)	     /* by substituting all newlines except the last */
X	p[-1]=' ';
X}
X
Xvoid renfield(pointer,oldl,newname,newl)struct field**const pointer;
X const size_t oldl,newl;const char*const newname;	    /* rename fields */
X{ struct field*p;size_t i;char*chp;
X  i=(p= *pointer)->tot_len-oldl;	      /* length of what we will keep */
X  *pointer=p=realloc(p,FLD_HEADSIZ+(p->tot_len=i+newl));chp=p->fld_text;
X  tmemmove(chp+newl,chp+oldl,i);tmemmove(chp,newname,newl);   /* shove, copy */
X}
X
Xstatic void extractfield(p)register struct field*p;
X{ if(xheader||Xheader)					 /* extracting only? */
X   { if(findf(p,xheader))			   /* extract field contents */
X      { putssn(p->fld_text+p->id_len,p->tot_len-p->id_len);return;
X      }
X     if(!findf(p,Xheader))				   /* extract fields */
X	return;
X   }
X  lputssn(p->fld_text,p->tot_len);		      /* display it entirely */
X}
X
Xvoid flushfield(pointer)register struct field**pointer;	 /* delete and print */
X{ register struct field*p,*q;				   /* them as you go */
X  for(p= *pointer,*pointer=0;p;p=q)
X     q=p->fld_next,extractfield(p),free(p);
X}
X
Xvoid dispfield(p)register const struct field*p;
X{ for(;p;p=p->fld_next)			     /* print list non-destructively */
X     if(p->id_len<p->tot_len-1)			 /* any contents to display? */
X	extractfield(p);
X}
X
Xreadhead P((void))  /* try and append one valid field to rdheader from stdin */
X{ getline();
X  if(!eqFrom_(buf))				    /* it's not a From_ line */
X   { if(!breakfield(buf,buffilled))	   /* not the start of a valid field */
X	return 0;
X     for(;;getline())		      /* get the rest of the continued field */
X      { switch(buflast)			     /* will this line be continued? */
X	 { case ' ':case '\t':continue;			  /* yep, it sure is */
X	 }
X	break;
X      }
X   }
X  else if(rdheader)
X     return 0;				       /* the From_ line was a fake! */
X  addbuf();return 1;		  /* phew, got the field, add it to rdheader */
X}
X
Xvoid addbuf P((void))
X{ addfield(&rdheader,buf,buffilled);buffilled=0;
X}
END_OF_FILE
if test 3562 -ne `wc -c <'procmail/src/fields.c'`; then
    echo shar: \"'procmail/src/fields.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/fields.c'
fi
if test -f 'procmail/src/formail.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/formail.h'\"
else
echo shar: Extracting \"'procmail/src/formail.h'\" \(914 characters\)
sed "s/^X//" >'procmail/src/formail.h' <<'END_OF_FILE'
X/*$Id: formail.h,v 1.4 1993/04/27 17:34:03 berg Exp $*/
X
X#define BSIZE		128
X
X#define NAMEPREFIX	"formail: "
X#define HEAD_DELIMITER	':'
X
X#define Re		(re+1)
X#define putssn(a,l)	tputssn(a,(size_t)(l))
X#define putcs(a)	(errout=putc(a,mystdout))
X#define lputssn(a,l)	ltputssn(a,(size_t)(l))
X#define PRDO		poutfd[0]
X#define PWRO		poutfd[1]
X#define FLD_HEADSIZ	((size_t)offsetof(struct field,fld_text[0]))
X
Xstruct saved{const char*const headr;const int lenr;int rexl;char*rexp;};
X
Xextern const char binsh[],sfolder[],couldntw[];
Xextern errout,oldstdout,quiet,buflast;
Xextern pid_t child;
Xextern FILE*mystdout;
Xextern size_t nrskip,nrtotal,buflen,buffilled;
Xextern long totallen;
Xextern char*buf,*logsummary;
X
Xextern struct field{size_t id_len;size_t tot_len;struct field*fld_next;
X char fld_text[255];}*rdheader,*xheader,*Xheader;
X
Xint
X eqFrom_ P((const char*const a)),
X breakfield Q((const char*const line,size_t len));
END_OF_FILE
if test 914 -ne `wc -c <'procmail/src/formail.h'`; then
    echo shar: \"'procmail/src/formail.h'\" unpacked with wrong size!
fi
# end of 'procmail/src/formail.h'
fi
if test -f 'procmail/src/robust.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/robust.c'\"
else
echo shar: Extracting \"'procmail/src/robust.c'\" \(3984 characters\)
sed "s/^X//" >'procmail/src/robust.c' <<'END_OF_FILE'
X/************************************************************************
X *	The fault-tolerant system-interface				*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	#include "README"						*
X ************************************************************************/
X#ifdef RCS
Xstatic /*const*/char rcsid[]=
X "$Id: robust.c,v 1.11 1993/04/02 12:39:20 berg Exp $";
X#endif
X#include "procmail.h"
X#include "robust.h"
X#include "misc.h"
X#include "mailfold.h"
X
X#define nomemretry	noresretry
X#define noforkretry	noresretry
X		       /* set nextexit to prevent elog() from using malloc() */
Xstatic void nomemerr P((void))
X{ nextexit=2;nlog("Out of memory\n");
X  if(buf2)
X   { buf[linebuf-1]=buf2[linebuf-1]='\0';elog("buffer 0:");logqnl(buf);
X     elog("buffer 1:");logqnl(buf2);
X   }
X  if(retval!=EX_TEMPFAIL)
X     retval=EX_OSERR;
X  terminate();
X}
X
Xvoid*tmalloc(len)const size_t len;    /* this malloc can survive a temporary */
X{ void*p;int i;				    /* "out of swap space" condition */
X  lcking|=lck_ALLOCLIB;
X  if(p=malloc(len))
X     goto ret;
X  lcking|=lck_MEMORY;
X  if(p=malloc(1))
X     free(p);			   /* works on some systems with latent free */
X  for(i=nomemretry;i<0||i--;)
X   { suspend();		     /* problems?  don't panic, wait a few secs till */
X     if(p=malloc(len))	     /* some other process has paniced (and died 8-) */
Xret:  { lcking&=~(lck_MEMORY|lck_ALLOCLIB);return p;
X      }
X   }
X  nomemerr();
X}
X
Xvoid*trealloc(old,len)void*const old;const size_t len;
X{ void*p;int i;
X  lcking|=lck_ALLOCLIB;
X  if(p=realloc(old,len))
X     goto ret;				    /* for comment see tmalloc above */
X  lcking|=lck_MEMORY;
X  if(p=malloc(1))
X    free(p);
X  for(i=nomemretry;i<0||i--;)
X   { suspend();
X     if(p=realloc(old,len))
Xret:  { lcking&=~(lck_MEMORY|lck_ALLOCLIB);return p;
X      }
X   }
X  nomemerr();
X}
X
Xvoid tfree(p)void*const p;
X{ lcking|=lck_ALLOCLIB;free(p);lcking&=~lck_ALLOCLIB;
X}
X
X#include "shell.h"
X
Xpid_t sfork P((void))			/* this fork can survive a temporary */
X{ pid_t i;int r;			   /* "process table full" condition */
X  elog("");r=noforkretry;			  /* flush log, just in case */
X  while((i=fork())==-1)
X   { lcking|=lck_FORK;
X     if(!(r<0||r--))
X	break;
X     suspend();
X   }
X  lcking&=~lck_FORK;return i;
X}
X
Xvoid opnlog(file)const char*file;
X{ int i;
X  if(!*file)						   /* empty LOGFILE? */
X     file=devnull;				 /* substitute the bitbucket */
X  if(0>(i=opena(file)))
X     writeerr(file);			      /* error, keep the old LOGFILE */
X  else
X     rclose(STDERR),rdup(i),rclose(i),logopened=1;
X}
X
Xopena(a)const char*const a;
X{ setlastfolder(a);yell("Opening",a);
X#ifdef O_CREAT
X  return ropen(a,O_WRONLY|O_APPEND|O_CREAT,NORMperm);
X#else
X  ;{ int fd;
X     return(fd=ropen(a,O_WRONLY,0))<0?creat(a,NORMperm):fd;
X   }
X#endif
X}
X
Xropen(name,mode,mask)const char*const name;const int mode;const mode_t mask;
X{ int i,r;					       /* a SysV secure open */
X  for(r=noresretry,lcking|=lck_FILDES;0>(i=open(name,mode,mask));)
X     if(errno!=EINTR&&!(errno==ENFILE&&(r<0||r--)))
X	break;		 /* survives a temporary "file table full" condition */
X  lcking&=~lck_FILDES;return i;
X}
X
Xrpipe(fd)int fd[2];
X{ int i,r;					  /* catch "file table full" */
X  for(r=noresretry,lcking|=lck_FILDES;0>(i=pipe(fd));)
X     if(!(errno==ENFILE&&(r<0||r--)))
X      { *fd=fd[1]= -1;break;
X      }
X  lcking&=~lck_FILDES;return i;
X}
X
Xrdup(p)const int p;
X{ int i,r;					  /* catch "file table full" */
X  for(r=noresretry,lcking|=lck_FILDES;0>(i=dup(p));)
X     if(!(errno==ENFILE&&(r<0||r--)))
X	break;
X  lcking&=~lck_FILDES;return i;
X}
X
Xrclose(fd)const int fd;		      /* a SysV secure close (signal immune) */
X{ int i;
X  while((i=close(fd))&&errno==EINTR);
X  return i;
X}
X
Xrread(fd,a,len)const int fd,len;void*const a;	       /* a SysV secure read */
X{ int i;
X  while(0>(i=read(fd,a,(size_t)len))&&errno==EINTR);
X  return i;
X}
X
Xrwrite(fd,a,len)const int fd,len;const void*const a;  /* a SysV secure write */
X{ int i;
X  while(0>(i=write(fd,a,(size_t)len))&&errno==EINTR);
X  return i;
X}
END_OF_FILE
if test 3984 -ne `wc -c <'procmail/src/robust.c'`; then
    echo shar: \"'procmail/src/robust.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/robust.c'
fi
if test -f 'procmail/src/sublib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/sublib.c'\"
else
echo shar: Extracting \"'procmail/src/sublib.c'\" \(2762 characters\)
sed "s/^X//" >'procmail/src/sublib.c' <<'END_OF_FILE'
X/*$Id: sublib.c,v 1.8 1993/01/26 12:30:51 berg Exp $*/
X#include "includes.h"
X#include "sublib.h"
X
X#ifdef NOmemmove
Xvoid*smemmove(To,From,count)void*To;const void*From;register size_t count;
X#ifdef NObcopy					  /* silly compromise, throw */
X{ register char*to=To;register const char*from=From;/*void*old;*/
X  /*old=to;*/count++;to--;from--;  /* away space to be syntactically correct */
X  if(to<=from)
X   { goto jiasc;
X     do
X      { *++to= *++from;					  /* copy from above */
Xjiasc:;
X      }
X     while(--count);
X   }
X  else
X   { to+=count;from+=count;goto jidesc;
X     do
X      { *--to= *--from;					  /* copy from below */
Xjidesc:;
X      }
X     while(--count);
X   }
X  return To/*old*/;
X#else
X{ bcopy(From,To,count);return To;
X#endif /* NObcopy */
X}
X#endif /* NOmemmove */
X
X#include "shell.h"
X
X#ifdef NOstrpbrk
Xchar*strpbrk(st,del)const char*const st,*del;
X{ const char*f=0,*t;
X  for(f=0;*del;)
X     if((t=strchr(st,*del++))&&(!f||t<f))
X	f=t;
X  return(char*)f;
X}
X#endif
X
X#ifdef NOstrstr
Xchar*strstr(whole,part)const char*whole,*const part;
X{ size_t i;const char*end;
X  for(end=strchr(whole,'\0')-(i=strlen(part))+1;--end>=whole;)
X     if(!strncmp(end,part,i))
X	return(char*)end;
X  return 0;
X}
X#endif
X			    /* strtol replacement which lacks range checking */
X#ifdef NOstrtol
Xlong strtol(start,ptr,base)const char*start,**const ptr;
X{ long result;const char*str=start;unsigned i;int sign,found;
X  if(base>=36||base<(sign=found=result=0))
X     goto fault;
X  for(;;str++)					  /* skip leading whitespace */
X   { switch(*str)
X      { case '\t':case '\n':case '\v':case '\f':case '\r':case ' ':continue;
X      }
X     break;
X   }
X  switch(*str)						       /* any signs? */
X   { case '-':sign=1;
X     case '+':str++;
X   }
X  if(*str=='0')						 /* leading zero(s)? */
X   { start++;
X     if((i= *++str)=='x'||i=='X')			/* leading 0x or 0X? */
X	if(!base||base==16)
X	   base=16,str++;			    /* hexadecimal all right */
X	else
X	   goto fault;
X     else if(!base)
X	base=8;						 /* then it is octal */
X   }
X  else if(!base)
X     base=10;						  /* or else decimal */
X  goto jumpin;
X  do
X   { found=1;result=result*base+i;str++;		 /* start converting */
Xjumpin:
X     if((i= *str-'0')<10);
X     else if(i-'A'+'0'<='Z'-'A')
X	i-='A'-10-'0';			   /* collating sequence dependency! */
X     else if(i-'a'+'0'<'z'-'a')
X	i-='a'-10-'0';			   /* collating sequence dependency! */
X     else
X	break;						/* not of this world */
X   }
X  while(i<base);				      /* still of this world */
Xfault:
X  if(ptr)
X    *ptr=found?str:start;			       /* how far did we get */
X  return sign?-result:result;
X}
X#else /* NOstrtol */
X#ifndef NOstrstr
X#ifndef NOstrpbrk
X#ifndef NOmemmove
Xint sublib_dummy_var;		      /* to prevent insanity in some linkers */
X#endif
X#endif
X#endif
X#endif /* NOstrtol */
END_OF_FILE
if test 2762 -ne `wc -c <'procmail/src/sublib.c'`; then
    echo shar: \"'procmail/src/sublib.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/sublib.c'
fi
echo shar: End of archive 3 \(of 11\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de

"Always look on the bright side of life!"

exit 0 # Just in case...
