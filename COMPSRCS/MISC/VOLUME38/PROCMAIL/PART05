Newsgroups: comp.sources.misc
From: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Subject: v38i024:  procmail - mail processing package v2.90, Part05/11
Message-ID: <1993Jul1.151106.21251@sparky.imd.sterling.com>
X-Md4-Signature: 04742e05b696259322fc4a073871e927
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 1 Jul 1993 15:11:06 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Posting-number: Volume 38, Issue 24
Archive-name: procmail/part05
Environment: sendmail, smail, MMDF, mailsurr, UNIX, POSIX
Supersedes: procmail: Volume 35, Issue 21-32,124,125

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 11)."
# Contents:  procmail/FAQ procmail/mailinglist/etc/rc.request
#   procmail/man/formail.man procmail/src/includes.h
#   procmail/src/manconf.c procmail/src/pipes.c
# Wrapped by berg@tubastos on Thu Jul  1 14:06:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'procmail/FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/FAQ'\"
else
echo shar: Extracting \"'procmail/FAQ'\" \(8275 characters\)
sed "s/^X//" >'procmail/FAQ' <<'END_OF_FILE'
X------------------------------------------------------------------------------
X---------------------- Frequently Asked Questions ----------------------------
X------------------------------------------------------------------------------
X
X1. How do I go about setting up a mailinglist or a mail-archive server?
X
X	Look in the mailinglist directory, start reading the INTRO file,
X	it describes it in detail and should get you started.
X
X2. I installed procmail (i.e. typed 'make install'), but how am I supposed to
X   use it?  When I type procmail on the command line it simply does nothing.
X
X	You're not supposed to start procmail from the command line.
X	Be sure to have a .forward and a .procmailrc file in your home
X	directory (see the examples subdirectory or the man page).
X	MMDF users should note that they need a .maildelivery file *instead*
X	of a .forward file (see the man page for more detailed information).
X
X	If however, procmail has been integrated in the maildelivery system
X	(i.e. if your system administrator installed it that way, ask him/her),
X	then you no longer need the .forward files in your home directory,
X	having a .procmailrc file will suffice.
X
X	On some systems .forward files are not checked.
X	It might be possible that your system supports a command like:
X		mail -F "|/usr/local/bin/procmail"
X	to set up forwarding to a program.
X	If that doesn't seem to work it might be worth trying to put a line
X	looking like this:
X		Forward to |/usr/local/bin/procmail
X	or if that doesn't work, try:
X		Pipe to /usr/local/bin/procmail
X	as the only line in your mail spool file (e.g. /usr/mail/$LOGNAME), as
X	well as doing a "chmod 06660 /usr/mail/$LOGNAME".  For more information
X	on such systems, do a "man mail".
X
X	If all of this doesn't work, procmail can be called on a periodical
X	basis, either via "cron", "at" or whenever you start reading mail (or
X	log in).  For a sample script look in the NOTES section of the
X	procmail(1) man page.
X
X3. When I compile everything the compiler complains about invalid or illegal
X   pointer combinations, but it produces the executables anyway.
X   Should I be concerned?
X
X	Ignore these warnings, they simply indicate that either your compiler
X	or your system include files are not ANSI/POSIX compliant.
X	The compiler will produce correct code regardless of these warnings.
X
X4. The compiler seems to issue warnings about "loop not entered at top",
X   is that a problem?
X
X	No, no problem at all, it just means I wrote the code :-)
X	That's just about the only uncommon coding technique I use (don't
X	think I don't try to avoid those jumps in loops, it's just that
X	sometimes they are the best way to code it).  Use gcc if you want
X	to avoid these warnings.
X
X5. The compiler complains about unmodifiable lvalues or assignments to const
X   variables.  Now what?
X
X	Well, if the compiler produces the executables anyway everything
X	probably is all right.	If it doesn't, you might try inserting a
X	"#define const" in the autoconf.h file by hand.	 However in any case,
X	your compiler is broken; I would recommend submitting this as a
X	compiler bug to your vendor.  In any case, if this should occur, I'd
X	appreciate a mail from you (so I can try to fix the autoconf script
X	to recognise your compiler).
X
X6. The compiler refuses to compile regexp.c, what is the problem?
X
X	Try compiling that module with optimisation turned off.
X
X7. When I send myself a testmail, the mail bounces with the message: cannot
X   execute binary file.	 What am I doing wrong?
X
X	It is very well possible that mail is processed on a different
X	machine from that where you usually read your mail.  Therefore you
X	have to make sure that procmail has the right binary format to
X	execute on those machines on which mail could arrive.  In order to
X	get this right you might need to do some .forward file tweaking,
X	look at the examples/advanced file for some suggestions.
X
X8. Where do I look for examples about:
X	One home directory, several machine architectures?
X	Procmail as an integrated local mail delivery agent? (generic,
X	 sendmail, smail, SysV mailsurr)
X	Changing the mail spool directory to $HOME for all users
X	Security considerations (when installing procmail suid root)
X	Exorbitant rcfile formats?
X	The `A' flag?
X
X	Well, this probably is your lucky day :-), all these topics are covered
X	in the examples/advanced file.
X
X	Other examples (e.g. for autoreplies) are most likely to be found by
X	typing:		man procmailex
X
X9. How do I use procmail as a general mail filter inside sendmail?
X
X	See EXAMPLES section of the procmail(1) man page.
X
X10. Why do I have to insert my login name after the '#' in the .forward or
X   .maildelivery file?
X
X	Some mailers `optimise' maildelivery and take out duplicates from
X	Cc:, Bcc: and alias lists before delivery.  If two or more persons on
X	such a list would have identical .forward files, then the mailer will
X	eliminate all but one.	Adding a `#' with your login name following
X	it will make the .forward files unique, and will ensure that the mailer
X	doesn't optimise away some addresses.
X
X11. How do I view the man pages?
X
X	If the man(1) program on your system understands the MANPATH
X	environment variable, make sure that the installation directory listed
X	in the Makefile for the manpages is included in your MANPATH.  If your
X	man program does not support MANPATH, make sure that the man pages
X	are installed in one of the standard man directories, like under
X	/usr/man.  If you do not want to install the man pages before viewing
X	them, you can view an individual man file by typing something like:
X	nroff -man procmail.1 | more
X
X12. The leading From_ line on all my arriving mail shows the wrong time.
X    Before putting procmail in the .forward file everything was OK.
X
X	This is a known bug in sendmail-5.65c+IDA.
X
X13. I sometimes get these `Lock failure on "/usr/mail/$LOGNAME.lock"' errors
X    from procmail.  What do I do about it?
X
X	The problem here is that as long as procmail has not read a
X	$HOME/.procmailrc file, it can hang on to the sgid mail permission
X	(which it needs in order to create a lockfile in /usr/mail).
X	I.e. if procmail delivers mail to a user without a $HOME/.procmailrc
X	file, procmail *can* (and does) use the /usr/mail/$LOGNAME.lock file.
X
X	If, however, it finds a $HOME/.procmailrc file, procmail has to let go
X	of the sgid mail permission because otherwise any ordinary user could
X	misuse that.
X
X	There are several solutions to this problem:
X	- Some systems support the sticky bit on directories (when set only
X	  allows the owner of a file in that directory to rename or remove
X	  it).	This enables you to make /usr/spool/mail drwxrwxrwt.  It is
X	  thus effectively world writeable, but all the mailboxes in it are
X	  protected because only the mailbox owner can remove or rename it.
X	- If your system did not exhibit the !@#$%^&* POSIX semantics for
X	  setgid(), procmail would have been able to switch back and forth
X	  between group mail and the group the recipient belongs to without
X	  creating security holes.
X	- If your system supported setrgid() or setregid() with BSD semantics,
X	  procmail would have been able to switch... (see the previous point).
X	- You could simply put the following at the end of your .procmailrc
X	  file:
X
X		LOCKFILE		# removes any preexisting lockfile
X		LOG=`lockfile $DEFAULT$LOCKEXT`
X		TRAP="rm -f $DEFAULT$LOCKEXT"
X			:0
X			$DEFAULT
X
X	- You could, instead of using /usr/mail/$LOGNAME, use a file below
X	  your home directory as your default mailbox.
X	- Or, you could still use /usr/mail/$LOGNAME as the mailbox, but
X	  simply instruct procmail to use a different lockfile.	 This can
X	  be achieved by putting following recipe at the bottom of
X	  your .procmailrc file:
X
X		:0:$HOME/.lockmail
X		$DEFAULT
X
X	  You have to make sure that all other programs that update your
X	  system mailbox will be using the same lockfile of course.
X
X
X14. None of the above topics cover my problem.	Should I panic?
X
X	Let me ask you a question :-), have you examined the CAVEATS, WARNINGS,
X	BUGS and NOTES sections of the manual pages *closely* ?
X	If you have, well, then panic.	Or, alternatively, you could submit
X	your question to the procmail mailinglist (see the man page for the
X	exact addresses, or try "procmail -v", or look in the patchlevel.h
X	file).
END_OF_FILE
if test 8275 -ne `wc -c <'procmail/FAQ'`; then
    echo shar: \"'procmail/FAQ'\" unpacked with wrong size!
fi
# end of 'procmail/FAQ'
fi
if test -f 'procmail/mailinglist/etc/rc.request' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/mailinglist/etc/rc.request'\"
else
echo shar: Extracting \"'procmail/mailinglist/etc/rc.request'\" \(5070 characters\)
sed "s/^X//" >'procmail/mailinglist/etc/rc.request' <<'END_OF_FILE'
X# BEFORE editing this file, you should make sure that it is not linked to
X# the master version (../.etc/rc.request) anymore (i.e. "delink rc.request"
X# if you do not want your changes to affect all lists).
X#
X# New mails can be temporarily stalled by creating the file rc.lock (either in
X# ../.etc for all lists or in the current directory for this list only).
X
X#$Id: rc.request,v 1.21 1993/06/21 14:23:54 berg Exp $
X
XINCLUDERC=$RC_INIT
XINCLUDERC=$RC_CUSTOM
X
XLOCKFILE=tmp.lock	# for reusing tmp.(request|from)
X			# also makes sure that the load doesn't go sky-high
X			# when a lot of mail arrives concurrently
X
X#
X# We now check:
X#	If the length is roughly within bounds.
X#	That it is not a reply or something.
X#	That we didn't send it ourselves.
X#	That it wasn't sent by a daemon of some kind.
X#
X# If everything matches, we extract the sender address into tmp.from
X#
X
X:0 whc
X* < 8192
X* $!^(X-(Loop: $listaddr|Diagnostic:)|$X_COMMAND)
X* !^Subject:(.*[^a-z])?(Re:|erro|change|problem|((can)?not|.*n't)([^a-z]|$))
X* !^FROM_DAEMON
X| formail -rt -xTo: >tmp.from
X
X#
X# Store the whole mail in tmp.request, for later reference.
X#
X
X	:0 Ac w
X	| cat >tmp.request
X
X#
X# Check for a missing Subject: line.
X#
X
X	:0 A wfh
X	* !^Subject:
X	| formail -a "Subject: "
X
X###############################################################################
X# Reader beware, the following four regular expressions are not for the faint #
X# of heart.  It'll suffice to say that they accomplish their intended job 98% #
X# of time.								      #
X###############################################################################
X
X#
X# Is it an archive retrieval command?
X#
X
X	:0 HBA w
X	* ^^(.+$)*Subject:[	 ]*($(.+$)*(^[	 ]*)+)?\
X	   ((archive([	 ]|$))|(archive[	 ]+)?\
X	   ((send|get)(me)?|gimme|retrieve|mail|ls|dir(ectory)?|list|show)\
X	   ([	 ]|$))
X	| arch_retrieve
X
X#
X# Is it an unsubscription request?
X#
X
X	:0 HBA w:dist.lock
X	* ^^(.+$)*Subject:[	 ]*(($(.+$)*(^[	 ]*)+)?(delete|remove|unsub)|\
X	   ($(.*$)*)?(.*[^a-z])?(unsubscri|\
X	   ((delete|remove) .* from|take .* off) .* [a-z-]*list([^a-z]|$)))
X	| unsubscribe | $SENDMAIL $sendmailOPT `cat tmp.from`
X
X#
X# Is it a subscription request?	 Yes, well, then check if the person
X# subscribing isn't on the reject list.	 If not, then let's see if he might
X# already be on the mailinglist.  If not, add him.
X#
X
X	:0 HBA w $cc_requests:dist.lock
X	* ^^(.+$)*Subject:[	 ]*(\
X	   ($(.+$)*(^[	 ]*)+)?(add|sub(scri|[	 ]|$)?)|\
X	   ($(.*$)*)?(.*[^a-z])?(subscri|(add .* to|put .* on) .* [a-z-]*list\
X	   ([^a-z]|$)))
X	* !?multigram -b1 -l$reject_threshold reject
X	* !?multigram -b1 -x$listreq -x$listaddr -l$reject_threshold dist
X	| subscribe | $SENDMAIL $sendmailOPT -t
X
X#
X# Is it an info or help request?  Send back the help.txt file.
X#
X
X	:0 HBA w $cc_requests
X	* ^^(.+$)*Subject:[	 ]*($(.+$)*(^[	 ]*)+)?\
X	   [a-z,.	 ]*(help|info(rm(ation)?)?)([^a-z]|$)
X	| (formail -i"From: $listreq" -rtA"X-Loop: $listaddr"; \
X	   cat help.txt) | $SENDMAIL $sendmailOPT -t
X
X#
X# Could it be a bounce message from a daemon?  Hand it down to procbounce
X# which will evaluate it.
X#
X
X:0 wc
X* !^Subject:(.*[^a-z])?Re:
X* $!^(X-(Loop: $listaddr|Diagnostic:)|$X_COMMAND)
X* ^FROM_DAEMON
X| sed -e $cutoff_bounce',$ d' >tmp.request
X
X	:0 Ahfw
X	| procbounce
X
X#
X# Or is it a remote X-Command from our maintainer?
X#
X
X:0 wf:dist.lock
X* $^$X_COMMAND:.*$maintainer.*$X_COMMAND_PASSWORD
X* $!^X-Loop: $listaddr
X| x_command `formail -x$X_COMMAND:`
X
XLOCKFILE				# we don't need the lockfile anymore
X
X#
X# Anything not taken care of yet will be served to the maintainer of the list.
X#
X# To make it easier on him, we include a small hint about what might be the
X# problem (by adding X-Diagnostic: fields to the header).
X#
X
X:0 wfh
X* !< $size_limit
X| formail -A "X-Diagnostic: Submission size exceeds $size_limit bytes"
X
X:0 wfh
X* ^FROM_DAEMON
X| formail -A "X-Diagnostic: Mail coming from a daemon, ignored"
X
X:0 HB wfh
X* $^X-Loop: $listaddr
X| formail -A "X-Diagnostic: Possible loopback problem"
X
X:0 ch
X* !^X-(Diagnostic|Processed):
X/dev/null
X
X	:0 A wfh
X	* $^$X_COMMAND:
X	| formail -A "X-Diagnostic: Suspicious $X_COMMAND format"
X
X	:0 A HB wfh
X	* ?multigram -b1 -l$reject_threshold reject
X	| formail -A "X-Diagnostic: Found on the reject list" \
X	   -A "X-Diagnostic: `multigram -b1 -l$reject_threshold reject`"
X
X	:0 A HB wfh
X	* ^((Subject:)?[a-z,.	 ]*(add|sub.*[@!])|(.*[^a-z])?(subscri.*|\
X				      (add .* to|put .* on) .* list)([^a-z]|$))
X	* ?multigram -b1 -x$listreq -x$listaddr -l$reject_threshold dist
X	| formail -A "X-Diagnostic: Already on the subscriber list" \
X	   -A "X-Diagnostic: `multigram -b1 -x$listreq -x$listaddr \
X	    -l$reject_threshold dist`"
X
X:0 wfh
X| formail -A"X-Envelope-To: $X_ENVELOPE_TO"
X
X#
X# If this list does not have a maintainer e-mail address, drop things in
X# the file request.
X#
X
XLOGABSTRACT=yes
X
X:0:
X* ?test -z "$maintainer"
Xrequest
X
X:0 w
X| formail -R"From X-Envelope-From:" -iReturn-Receipt-To: \
X   | $SENDMAIL $sendmailOPT $sendmailOPTp $maintainer
X
X:0 wfh
X| formail -A"X-Diagnostic: Maintainer $maintainer could not be reached"
X
XHOST=continue_with_../.etc/rc.post
END_OF_FILE
if test 5070 -ne `wc -c <'procmail/mailinglist/etc/rc.request'`; then
    echo shar: \"'procmail/mailinglist/etc/rc.request'\" unpacked with wrong size!
fi
# end of 'procmail/mailinglist/etc/rc.request'
fi
if test -f 'procmail/man/formail.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/man/formail.man'\"
else
echo shar: Extracting \"'procmail/man/formail.man'\" \(7509 characters\)
sed "s/^X//" >'procmail/man/formail.man' <<'END_OF_FILE'
X.Id $Id: formail.man,v 1.10 1993/05/05 13:05:52 berg Exp $
X.TH FORMAIL 1 \*(Dt BuGless
X.na
X.SH NAME
Xformail \- mail (re)formatter
X.SH SYNOPSIS
X.B formail
X.RI [ "\fB\@FM_SKIP@\fPskip" ]
X.RI [ "\fB\@FM_TOTAL@\fPtotal" ]
X.RB [ \-@FM_BOGUS@@FM_CONCATENATE@@FM_FORCE@@FM_REPLY@@FM_KEEPB@@FM_TRUST@@FM_NOWAIT@@FM_EVERY@@FM_DIGEST@@FM_QUIET@ ]
X.RB [ \-@FM_QPREFIX@
X.IR prefix ]
X.RB [ \-@FM_MINFIELDS@
X.IR "min fields" ]
X.if n .ti +0.5i
X.RB [ \-@FM_EXTRACT@
X.IR "header field" ]
X.RB [ \-@FM_EXTRC_KEEP@
X.IR "header field" ]
X.if n .ti +0.5i
X.RB [ \-@FM_ADD_IFNOT@
X.IR "header field" ]
X.RB [ \-@FM_ADD_ALWAYS@
X.IR "header field" ]
X.if n .ti +0.5i
X.RB [ \-@FM_REN_INSERT@
X.IR "header field" ]
X.RB [ \-@FM_DEL_INSERT@
X.IR "header field" ]
X.if n .ti +0.5i
X.RB [ \-@FM_ReNAME@
X.I "oldfield"
X.IR "newfield" ]
X.RB [ \-@FM_SPLIT@
X.I command
X.I arg
X\&.\|.\|.\|]
X.ad
X.Sh DESCRIPTION
X.B formail
Xis a filter that can be used to force mail into mailbox format, perform
X`@FROM@' escaping, generate auto-replying headers, do simple
Xheader munging/extracting or split up a
Xmailbox/digest/articles file.  The mail/mailbox/article contents will be
Xexpected on stdin.
X.PP
XIf formail is supposed to determine the sender of the mail, but is unable
Xto find any, it will substitute `@UNKNOWN@'.
X.PP
XIf formail is started without any command line options, it will force any
Xmail coming from stdin into mailbox format and will escape
X.B all
Xbogus `@FROM@' lines with a `@ESCAP@'.
X.Sh OPTIONS
X.Tp 0.5i
X.B \-@FM_BOGUS@
XDon't escape any bogus mailbox headers (i.e. lines starting with `@FROM@').
X.Tp
X.I "\fB\-@FM_QPREFIX@\fP prefix"
XDefine a different quotation prefix.  If unspecified it defaults to `@ESCAP@'.
X.Tp
X.B \-@FM_CONCATENATE@
XConcatenate continued fields in the header.  Might be convenient when
Xpostprocessing mail with standard (line oriented) text utilities.
X.Tp
X.B \-@FM_FORCE@
XForce formail to simply pass along any non-mailbox format (i.e. don't
Xgenerate a `@FROM@' line as the first line).
X.Tp
X.B \-@FM_REPLY@
XGenerate an auto-reply header.  This will normally throw away all the existing
Xfields in the original message, fields you wish to preserve need to be named
Xusing the
X.B \-@FM_REN_INSERT@
Xoption.
X.Tp
X.B \-@FM_KEEPB@
XWhen generating the auto-reply header, keep the body as well.  If used
Xtogether with the
X.B \-@FM_BOGUS@
Xoption then the body will not be escaped.
X.Tp
X.B \-@FM_TRUST@
XTrust the sender to have used a valid return address in his header.  This
Xoption will be most useful when generating auto-reply headers from news
Xarticles.  If this option is not turned on, formail tends to favour
Xmachine-generated addresses in the header.
X.Tp
X.B \-@FM_SPLIT@
XThe input will be split up into separate mail messages, and piped into
Xa program one by one (a new program is started for every part).
X.B \-@FM_SPLIT@
Xhas to be the last option specified, the first argument following it
Xis expected to be the name of a program, any other arguments will be passed
Xalong to it.
X.Tp
X.B \-@FM_NOWAIT@
XTell formail not to wait for every program to finish before starting the next.
X.Tp
X.B \-@FM_EVERY@
XDo not require empty lines preceding the header of a new message (i.e. the
Xmessages could start on every line).
X.Tp
X.B \-@FM_DIGEST@
XTell formail that the messages it is supposed to split need not be in strict
Xmailbox format (i.e. allows you to split digests/articles or non-standard
Xmailbox formats).
X.Tp
X.I "\fB\-@FM_MINFIELDS@\fP min fields"
XAllows you to specify the number of consecutive fields formail needs to find
Xbefore it decides it found the start of a new message, it defaults to
X@DEFminfields@.
X.Tp
X.B \-@FM_QUIET@
XTells formail to ignore any write errors on stdout.
X.Tp
X.I "\fB\-@FM_EXTRACT@\fP header field"
XExtract the contents of this
X.I header field
Xfrom the header, display it as a single line.
X.Tp
X.I "\fB\-@FM_EXTRC_KEEP@\fP header field"
XSame as
X.BR \-@FM_EXTRACT@ ,
Xbut also preserves the field name.
X.Tp
X.I "\fB\-@FM_ADD_IFNOT@\fP header field"
XAppend a custom
X.I header field
Xonto the header; but only if a similar field does not exist yet.
X.Tp
X.I "\fB\-@FM_ADD_ALWAYS@\fP header field"
XAppend a custom
X.I header field
Xonto the header in any case.
X.Tp
X.I "\fB\-@FM_REN_INSERT@\fP header field"
XSame as
X.BR \-@FM_ADD_IFNOT@ ,
Xexcept that any existing similar fields are renamed by prepending
Xan ``@OLD_PREFIX@'' prefix.  If
X.I header field
Xconsists only of a field-name, it will not be appended.
X.Tp
X.I "\fB\-@FM_DEL_INSERT@\fP header field"
XSame as
X.BR \-@FM_REN_INSERT@ ,
Xexcept that any existing similar fields are simply removed.
X.Tp
X.I "\fB\-@FM_ReNAME@\fP oldfield newfield"
XRenames all occurrences of the fieldname
X.I oldfield
Xinto
X.IR newfield .
X.Tp
X.I "\fB\@FM_SKIP@\fPskip"
XSkip the first
X.I skip
Xmessages while splitting.
X.Tp
X.I "\fB\@FM_TOTAL@\fPtotal"
XOutput at most
X.I total
Xmessages while splitting.
X.Sh EXAMPLES
XTo split up a digest one usually uses:
X.Rs
Xformail @FM_SKIP@1 \-@FM_DIGEST@@FM_SPLIT@ cat >>the_mailbox_of_your_choice
X.Re
Xor
X.Rs
Xformail @FM_SKIP@1 \-@FM_DIGEST@@FM_SPLIT@ procmail
X.Re
X.PP
XTo supersede the Reply-To: field in a header you could use:
X.Rs
Xformail \-@FM_REN_INSERT@ "Reply-To: foo@bar"
X.Re
X.PP
XTo convert a non-standard mailbox file into a standard mailbox file you can
Xuse:
X.Rs
Xformail \-@FM_DIGEST@@FM_SPLIT@ cat <old_mailbox >>new_mailbox
X.Re
X.PP
XOr, alternatively, if you have a very tolerant mailer:
X.Rs
Xformail \-@FM_ADD_IFNOT@ Date: \-@FM_DIGEST@@FM_SPLIT@ cat <old_mailbox >>new_mailbox
X.Re
X.Sh MISCELLANEOUS
XThe regular expression that is used to find `real' postmarks is:
X.Rs
X"\en\en@FROM@[\et ]*[^\et\en ]+[\et ]+[^\en\et ]"
X.Re
X.Sh "SEE ALSO"
X.na
X.nh
X.BR mail (1),
X.BR binmail (1),
X.BR sendmail (8),
X.BR procmail (1),
X.BR sh (1)
X.hy
X.ad
X.Sh DIAGNOSTICS
X.Tp 2.3i
XCan't fork
XToo many processes on this machine.
X.Tp
XCouldn't write to stdout
XThe program that formail was trying to pipe into didn't accept all the data
Xformail sent to it; this diagnostic can be disabled by the
X.B \-@FM_QUIET@
Xoption.
X.Tp
XFailed to execute "x"
XProgram not in path, or not executable.
X.Tp
XFile table full
XToo many open files on this machine.
X.Tp
XInvalid field-name: "x"
XThe specified field-name "x" does not contain a colon or contains control
Xcharacters.
X.Sh WARNINGS
XYou can save yourself and others a lot of mischief if you try to avoid using
Xthis autoreply feature on mails coming through mailinglists.  Depending
Xon the format of the incoming mail (which in turn depends on both the
Xoriginal sender's mail agent and the mailinglist setup) formail could
Xdecide to generate an autoreply header that replies to the list (if
Xthe original sender was careful enough though, formail will be able to pick
Xhis/her address, instead of the list's).  Now if the list is not intelligent
Xenough (most aren't) this autoreply will be widely distributed.
X.Sh BUGS
XWhen formail has to generate a leading `@FROM@' line it normally will contain
Xthe current date.  If formail is given the option `\-@FM_ADD_IFNOT@ Date:',
Xit will use the date from the `Date:' field in the header (if present).
XHowever, since formail copies it verbatim, the format will differ from that
Xexpected by most mail readers.
X.Sh MISCELLANEOUS
XFormail is eight-bit clean.
X.PP
XWhen formail has to determine the sender's address, every RFC 822 conforming
Xmail address is allowed.  Formail will always strip down the address to
Xits minimal form (deleting excessive comments and whitespace).
X.Sh NOTES
XCalling up formail with the \-@HELPOPT1@ or \-@HELPOPT2@ options will cause
Xit to display a command-line help page.
END_OF_FILE
if test 7509 -ne `wc -c <'procmail/man/formail.man'`; then
    echo shar: \"'procmail/man/formail.man'\" unpacked with wrong size!
fi
# end of 'procmail/man/formail.man'
fi
if test -f 'procmail/src/includes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/includes.h'\"
else
echo shar: Extracting \"'procmail/src/includes.h'\" \(7259 characters\)
sed "s/^X//" >'procmail/src/includes.h' <<'END_OF_FILE'
X/*$Id: includes.h,v 1.24 1993/06/21 14:24:25 berg Exp $*/
X
X#include "../autoconf.h"
X#include "../config.h"
X	/* not all the "library identifiers" specified here need to be
X	   available for all programs in this package; some have substitutes
X	   as well (see autoconf); this is just an informal list */
X
X#ifndef _HPUX_SOURCE
X#define _HPUX_SOURCE	      /* sad, but needed on HP-UX when compiling -Aa */
X#endif
X
X#include <sys/types.h>		/* pid_t mode_t uid_t gid_t off_t */
X#ifndef UNISTD_H_MISSING
X#include <unistd.h>		/* open() read() write() close() dup() pipe()
X				/* fork() getuid() getgid() getpid() execve()
X				   execvp() sleep() setuid() setgid()
X				   setrgid() chown() */
X#endif
X#include <stdio.h>		/* setbuf() fclose() stdin stdout stderr
X				/* fopen() fread() fwrite() fgetc() getc()
X				   fdopen() putc() fputs() FILE EOF */
X#ifndef STDDEF_H_MISSING
X#include <stddef.h>		/* ptrdiff_t size_t */
X#endif
X#ifndef STDLIB_H_MISSING
X#include <stdlib.h>		/* getenv() malloc() realloc() free()
X				/* strtol() exit() */
X#endif
X#include <time.h>		/* time() ctime() time_t */
X#include <fcntl.h>		/* fcntl() struct flock O_RDONLY O_WRONLY
X				/* O_APPEND O_CREAT O_EXCL */
X#include <grp.h>		/* getgrgid() struct group */
X#include <pwd.h>		/* getpwuid() getpwnam() struct passwd */
X#ifndef DIRENT_H_MISSING
X#include <dirent.h>		/* opendir() readdir() closedir() DIR
X				/* struct dirent */
X#endif
X#ifndef SYS_WAIT_H_MISSING
X#include <sys/wait.h>		/* wait() WIFEXITED() WIFSTOPPED()
X				/* WEXITSTATUS() */
X#endif
X#ifndef SYS_UTSNAME_H_MISSING
X#include <sys/utsname.h>	/* uname() utsname */
X#endif
X#include <sys/stat.h>		/* stat() S_ISDIR() S_ISREG() struct stat
X				/* chmod() mkdir() */
X#include <signal.h>		/* signal() kill() alarm() SIG_IGN SIGHUP
X				/* SIGINT SIGQUIT SIGALRM SIGTERM */
X#ifndef STRING_H_MISSING
X#include <string.h>		/* strcpy() strncpy() strcat() strlen()
X				/* strspn() strcspn() strchr() strcmp()
X				   strncmp() strpbrk() strstr() memmove() */
X#endif
X#include <errno.h>		/* EINTR EEXIST ENFILE EACCES EAGAIN */
X#ifndef SYSEXITS_H_MISSING
X#include <sysexits.h>		/* EX_OK EX_USAGE EX_NOINPUT EX_NOUSER
X				/* EX_UNAVAILABLE EX_OSERR EX_OSFILE
X				   EX_CANTCREAT EX_IOERR EX_TEMPFAIL EX_NOPERM
X				   */
X#endif
X
X#ifdef STDLIB_H_MISSING
Xvoid*malloc(),*realloc();
Xconst char*getenv();
X#endif
X#ifdef DIRENT_H_MISSING
X#ifndef NDIR_H_MISSING
X#include <ndir.h>
X#define dirent	direct
X#else
X#ifndef SYS_NDIR_H_MISSING
X#include <sys/ndir.h>
X#define dirent	direct
X#else
X#ifndef SYS_DIR_H_MISSING
X#include <sys/dir.h>
X#define dirent	direct
X#else			  /* due to brain-damaged NeXT sys/dirent.h contents */
X#ifndef SYS_DIRENT_H_MISSING	     /* sys/dirent.h must be moved down here */
X#include <sys/dirent.h>
X#else
X/* I give up, I can only hope that your system defines DIR and struct dirent */
X#endif
X#endif
X#endif
X#endif
X#endif /* DIRENT_H_MISSING */
X#ifdef STRING_H_MISSING
X#include <strings.h>
X#ifndef strchr
Xchar*strchr();
X#endif
Xchar*strpbrk();
X#endif
X#ifdef SYS_UTSNAME_H_MISSING
X#define NOuname
X#endif
X#ifdef SYSEXITS_H_MISSING
X		/* Standard exit codes, original list maintained
X		   by Eric Allman (eric@berkeley.edu) */
X#define EX_OK		0
X#define EX_USAGE	64
X#define EX_NOINPUT	66
X#define EX_NOUSER	67
X#define EX_UNAVAILABLE	69
X#define EX_OSERR	71
X#define EX_OSFILE	72
X#define EX_CANTCREAT	73
X#define EX_IOERR	74
X#define EX_TEMPFAIL	75
X#define EX_NOPERM	77
X#endif
X
X#if O_SYNC
X#else
X#undef O_SYNC
X#define O_SYNC		0
X#endif
X#ifndef O_RDONLY
X#define O_RDONLY	0
X#define O_WRONLY	1
X#endif
X#ifndef SEEK_SET
X#define SEEK_SET	0
X#define SEEK_CUR	1
X#define SEEK_END	2
X#endif
X#ifndef tell
X#define tell(fd)	lseek(fd,(off_t)0,SEEK_CUR)
X#endif
X
X#ifndef EWOULDBLOCK
X#define EWOULDBLOCK	EACCES
X#endif
X#ifndef EAGAIN
X#define EAGAIN		EINTR
X#endif
X
X#ifndef EOF
X#define EOF	(-1)
X#endif
X
X#ifndef S_ISDIR
X#define S_ISDIR(mode)	(((mode)&S_IFMT)==S_IFDIR)
X#ifndef S_IFDIR
X#define S_IFDIR 0040000
X#endif
X#endif
X
X#ifndef S_ISREG
X#define S_ISREG(mode)	(((mode)&S_IFMT)==S_IFREG)
X#ifndef S_IFREG
X#define S_IFREG 0100000
X#endif
X#endif
X
X#ifndef S_ISLNK
X#ifndef S_IFLNK
X#define lstat(path,stbuf)	stat(path,stbuf)
X#define S_ISLNK(mode)	0
X#else
X#define S_ISLNK(mode)	(((mode)&S_IFMT)==S_IFLNK)
X#endif
X#endif
X
X#ifndef S_IFMT
X#define S_IFMT	0170000
X#endif
X
X#ifndef S_IRWXU
X#define S_IRWXU 00700
X#define S_IRWXG 00070
X#define S_IRWXO 00007
X#endif
X#ifndef S_IWUSR
X#ifdef S_IREAD
X#define S_IRUSR	 S_IREAD
X#define S_IWUSR	 S_IWRITE
X#define S_IXUSR	 S_IEXEC
X#else
X#define S_IRUSR	 0400
X#define S_IWUSR	 0200
X#define S_IXUSR	 0100
X#endif /* S_IREAD */
X#define S_IRGRP	 0040
X#define S_IWGRP	 0020
X#define S_IXGRP	 0010
X#define S_IROTH	 0004
X#define S_IWOTH	 0002
X#define S_IXOTH	 0001
X#endif /* S_IWUSR */
X#ifndef S_ISGID
X#define S_ISUID 04000
X#define S_ISGID 02000
X#endif
X
X#ifdef WMACROS_NON_POSIX
X#ifdef WIFEXITED
X#undef WIFEXITED
X#endif
X#ifdef WIFSTOPPED
X#undef WIFSTOPPED
X#endif
X#ifdef WEXITSTATUS
X#undef WEXITSTATUS
X#endif
X#endif /* WMACROS_NON_POSIX */
X
X#ifndef WIFEXITED
X#define WIFEXITED(waitval)	(!((waitval)&255))
X#endif
X#ifndef WIFSTOPPED
X#define WIFSTOPPED(waitval)	(((waitval)&255)==127)
X#endif
X#ifndef WEXITSTATUS
X#define WEXITSTATUS(waitval)	((waitval)>>8&255)
X#endif
X
Xextern /*const*/char**environ;
Xextern errno;
X
X#ifndef STDIN_FILENO
X#define STDIN	0
X#define STDOUT	1
X#define STDERR	2
X#else
X#define STDIN	STDIN_FILENO
X#define STDOUT	STDOUT_FILENO
X#define STDERR	STDERR_FILENO
X#endif
X
X#ifdef NO_fcntl_LOCK
X#ifndef NOfcntl_lock
X#define NOfcntl_lock
X#endif
X#endif
X#ifdef NO_lockf_LOCK
X#ifdef USElockf
X#undef USElockf
X#endif
X#endif
X#ifdef NO_flock_LOCK
X#ifdef USEflock
X#undef USEflock
X#endif
X#endif
X
X#ifndef NOuname
X#ifndef P		  /* SINIX V5.23 has the wrong prototype for uname() */
Xextern int uname();					 /* so we fix it :-) */
X#define Uname(name)		((int(*)(struct utsname*))uname)(name)
X#else
X#define Uname(name)		uname(name)		    /* no fix needed */
X#endif /* P */
X#endif /* NOuname */
X				 /* NEWS OS 5.X has the wrong prototype here */
X#define Fdopen(fd,type)		((FILE*)fdopen(fd,type))
X
X#ifndef strchr		   /* for very old K&R compatible include files with */
X#ifdef P						/* new K&R libraries */
X#ifdef const
X#ifdef void
Xextern char*strchr();
Xextern char*strpbrk();
Xextern char*strstr();
Xextern void*memmove();
X#endif
X#endif
X#endif
X#endif
X
X#define Const			/*const*/     /* Convex cc doesn't grok this */
X
X#ifdef const
X#ifndef P				      /* no prototypes without const */
X#define P(args) ()
X#endif
X#endif
X
X#ifdef NOrename
X#define rename(old,new) (-(link(old,new)||unlink(old)))
X#endif
X
X#ifdef NOsetrgid
X#ifdef NOsetregid
X#define setrgid(gid)	(-1)
X#else
X#define setrgid(gid)	setregid(gid,-1)
X#endif
X#endif
X
X#ifdef NOmkdir
X#define mkdir(dir,mode) (-1)
X#endif
X
X#ifdef NOmemmove
X#define memmove(to,from,count) smemmove(to,from,count)
X#endif
X
X#ifndef P
X#define P(args)		args
X#endif
X#define Q(args)		() /* needed until function definitions are ANSI too */
X
X#ifdef oBRAIN_DAMAGE
X#undef offsetof
X#endif
X#ifndef offsetof
X#define offsetof(s,m) ((char*)&(((s*)sizeof(s))->m)-(char*)sizeof(s))
X#endif
X
X#define PROGID		const char progid[]="Stephen R. van den Berg"
X#define maxindex(x)	(sizeof(x)/sizeof((x)[0])-1)
X#define STRLEN(x)	(sizeof(x)-1)
X#define ioffsetof(s,m)	((int)offsetof(s,m))
X#define numeric(x)	((unsigned)((x)-'0')<='9'-'0')
X
X#define mx(a,b)		((a)>(b)?(a):(b))
END_OF_FILE
if test 7259 -ne `wc -c <'procmail/src/includes.h'`; then
    echo shar: \"'procmail/src/includes.h'\" unpacked with wrong size!
fi
# end of 'procmail/src/includes.h'
fi
if test -f 'procmail/src/manconf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/manconf.c'\"
else
echo shar: Extracting \"'procmail/src/manconf.c'\" \(7318 characters\)
sed "s/^X//" >'procmail/src/manconf.c' <<'END_OF_FILE'
X/* A sed script generator (for transmogrifying the man pages automagically) */
X
X/*$Id: manconf.c,v 1.25 1993/06/23 12:56:08 berg Exp $*/
X
X#include "../patchlevel.h"
X#include "procmail.h"
X
X#define pn(name,val)	pnr(name,(long)(val))
X
Xstatic char pm_version[]=VERSION;
Xconst char dirsep[]=DIRSEP;
Xstatic const char*const keepenv[]=KEEPENV,*const prestenv[]=PRESTENV,
X *const trusted_ids[]=TRUSTED_IDS,
X *const krnllocks[]={
X#ifndef NOfcntl_lock
X  "fcntl(2)",
X#endif
X#ifdef USElockf
X  "lockf(3)",
X#endif
X#ifdef USEflock
X  "flock(2)",
X#endif
X  0};
X
Xstatic char*skltmark(nl,current)char**current;
X{ char*from= *current,*p;
X  while(nl--)					 /* skip some newlines first */
X     from=strchr(from,'\n')+1;
X  while(*from=='\t')
X     from++;
X  *(p=strchr(from,'\n'))='\0';*current=p+1;return from;
X}
X
Xstatic void putcesc(i)
X{ switch(i)
X   { case '|':printf("\\\\h'-\\\\w' 'u' ");break;
X     case '\\':i='e';goto twoesc;
X     case '\1':i='\n';goto singesc;
X     case '\t':i='t';goto fin;
X     case '\n':i='n';
Xfin:	putchar('\\');putchar('\\');
Xtwoesc: putchar('\\');
Xsingesc:
X     case '&':case '/':putchar('\\');
X   }
X  putchar(i);
X}
X
Xstatic void putsesc(a)const char*a;
X{ while(*a)
X     putcesc(*a++);
X}
X
Xconst char*const*gargv;
X
Xstatic void pname(name)const char*const name;
X{ static cmdcount;
X  if(!cmdcount)
X     freopen(*++gargv,"w",stdout),cmdcount=64;
X  cmdcount--;putchar('s');putchar('/');putchar('@');putsesc(name);putchar('@');
X  putchar('/');
X}
X
Xstatic void pnr(name,value)const char*const name;const long value;
X{ pname(name);printf("%ld/g\n",value);
X}
X
Xstatic void plist(name,preamble,list,postamble,ifno,andor)
X const char*const name,*const preamble,*const postamble,*const ifno,
X *const andor;const char*const*list;
X{ pname(name);
X  if(!*list)
X     putsesc(ifno);
X  else
X   { putsesc(preamble);goto jin;
X     do
X      { putsesc(list[1]?", ":andor);
Xjin:	putsesc(*list);
X      }
X     while(*++list);
X     putsesc(postamble);
X   }
X  puts("/g");
X}
X
Xstatic void ps(name,value)const char*const name,*const value;
X{ pname(name);putsesc(value);puts("/g");
X}
X
Xstatic void pc(name,value)const char*const name;const int value;
X{ pname(name);putcesc(value);puts("/g");
X}
X
Xmain(argc,argv)const char*const argv[];
X{ char*p,*q;
X  gargv=argv;
X#ifdef CF_no_procmail_yet
X  ps("CF_procmail","If procmail is\1\
X.I not\1\
Xinstalled globally as the default mail delivery agent (ask your system \
Xadministrator), you have to make sure it is invoked when your mail arrives.");
X#else
X  ps("CF_procmail","Instead of using the system provided invocation of \
Xprocmail when mail arrives, you can control the invocation of procmail \
Xyourself.");
X#endif
X#ifndef MAILBOX_SEPARATOR
X  ps("DOT_FORWARD",".forward");
X  ps("FW_content",
X   "\"|IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME\"");
X#else
X  ps("DOT_FORWARD",".maildelivery");
X  ps("FW_content",
X   "* - | ? \"IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME\"");
X#endif
X  plist("PRESTENV","\1.PP\1Other preset environment variables are "
X   ,prestenv,".",""," and ");
X  plist("KEEPENV",", except for the values of ",keepenv,"",""," and ");
X  plist("TRUSTED_IDS",
X   ", and procmail is invoked with one of the following user or group ids: ",
X   trusted_ids,",",""," or ");
X  plist("KERNEL_LOCKING",
X   "consistently uses the following kernel locking strategies: ",krnllocks,"",
X   "doesn't use any additional kernel locking strategies"," and ");
X#ifdef LD_ENV_FIX
X  ps("LD_ENV_FIX","\1.PP\1For security reasons, procmail will wipe out all\
X environment variables starting with LD_ upon startup.");
X#else
X  ps("LD_ENV_FIX","");
X#endif
X#ifdef NO_USER_TO_LOWERCASE_HACK
X  ps("UPPERCASE_USERNAMES","\1.PP\1If the standard\1.BR getpwnam() (3)\1\
Xis case sensitive, and some users have login names with uppercase letters in\
X them, procmail will be unable to deliver mail to them, unless started with\
X their uid.");
X#else
X  ps("UPPERCASE_USERNAMES","");
X#endif
X  ps("SYSTEM_MBOX",SYSTEM_MBOX);
X#ifdef console
X  ps("pconsole","appear on\1.BR ");
X  ps("console",console);
X  ps("aconsole"," .");
X#else
X  ps("pconsole","be mailed back to the ");
X  ps("console","sender");
X  ps("aconsole",".");
X#endif
X  pname("INIT_UMASK");printf("0%lo/g\n",INIT_UMASK);
X  pn("DEFlinebuf",DEFlinebuf);
X  ps("BOGUSprefix",BOGUSprefix);
X  ps("PROCMAILRC",PROCMAILRC);
X  pn("HOSTNAMElen",HOSTNAMElen);
X  pn("DEFsuspend",DEFsuspend);
X  pn("DEFlocksleep",DEFlocksleep);
X  ps("TOkey",TOkey);
X  ps("TOsubstitute",TOsubstitute);
X  ps("FROMDkey",FROMDkey);
X  ps("FROMDsubstitute",FROMDsubstitute);
X  ps("FROMMkey",FROMMkey);
X  ps("FROMMsubstitute",FROMMsubstitute);
X  ps("DEFshellmetas",DEFshellmetas);
X  ps("DEFmaildir",DEFmaildir);
X  ps("DEFdefault",DEFdefault);
X  ps("DEFdefaultlock",strchr(DEFdefaultlock,'=')+1);
X  ps("DEFmsgprefix",DEFmsgprefix);
X  ps("DEFsendmail",DEFsendmail);
X  ps("DEFlockext",DEFlockext);
X  ps("DEFshellflags",DEFshellflags);
X  pn("DEFlocktimeout",DEFlocktimeout);
X  pn("DEFtimeout",DEFtimeout);
X  pn("DEFnoresretry",DEFnoresretry);
X  ps("COMSAThost",COMSAThost);
X  ps("COMSATservice",COMSATservice);
X  ps("COMSATprotocol",COMSATprotocol);
X  ps("COMSATxtrsep",COMSATxtrsep);
X  pc("SERV_ADDRsep",SERV_ADDRsep);
X  ps("DEFcomsat",DEFcomsat);
X  ps("BinSh",BinSh);
X  ps("RootDir",RootDir);
X  pc("MCDIRSEP",*MCDIRSEP);
X  pc("chCURDIR",chCURDIR);
X  pc("HELPOPT1",HELPOPT1);
X  pc("HELPOPT2",HELPOPT2);
X  pc("VERSIONOPT",VERSIONOPT);
X  pc("PRESERVOPT",PRESERVOPT);
X  pc("TEMPFAILOPT",TEMPFAILOPT);
X  pc("MAILFILTOPT",MAILFILTOPT);
X  pc("FROMWHOPT",FROMWHOPT);
X  pc("ALTFROMWHOPT",ALTFROMWHOPT);
X  pc("ARGUMENTOPT",ARGUMENTOPT);
X  pc("DELIVEROPT",DELIVEROPT);
X  pn("MINlinebuf",MINlinebuf);
X  ps("FROM",FROM);
X  pc("HEAD_GREP",RECFLAGS[HEAD_GREP]);
X  pc("BODY_GREP",RECFLAGS[BODY_GREP]);
X  pc("DISTINGUISH_CASE",RECFLAGS[DISTINGUISH_CASE]);
X  pc("ALSO_NEXT_RECIPE",RECFLAGS[ALSO_NEXT_RECIPE]);
X  pc("ALSO_N_IF_SUCC",RECFLAGS[ALSO_N_IF_SUCC]);
X  pc("PASS_HEAD",RECFLAGS[PASS_HEAD]);
X  pc("PASS_BODY",RECFLAGS[PASS_BODY]);
X  pc("FILTER",RECFLAGS[FILTER]);
X  pc("CONTINUE",RECFLAGS[CONTINUE]);
X  pc("WAIT_EXIT",RECFLAGS[WAIT_EXIT]);
X  pc("WAIT_EXIT_QUIET",RECFLAGS[WAIT_EXIT_QUIET]);
X  pc("IGNORE_WRITERR",RECFLAGS[IGNORE_WRITERR]);
X  ps("FROM_EXPR",FROM_EXPR);
X  pc("UNIQ_PREFIX",UNIQ_PREFIX);
X  ps("ESCAP",ESCAP);
X  ps("UNKNOWN",UNKNOWN);
X  ps("OLD_PREFIX",OLD_PREFIX);
X  pc("FM_SKIP",FM_SKIP);
X  pc("FM_TOTAL",FM_TOTAL);
X  pc("FM_BOGUS",FM_BOGUS);
X  pc("FM_QPREFIX",FM_QPREFIX);
X  pc("FM_CONCATENATE",FM_CONCATENATE);
X  pc("FM_FORCE",FM_FORCE);
X  pc("FM_REPLY",FM_REPLY);
X  pc("FM_KEEPB",FM_KEEPB);
X  pc("FM_TRUST",FM_TRUST);
X  pc("FM_SPLIT",FM_SPLIT);
X  pc("FM_NOWAIT",FM_NOWAIT);
X  pc("FM_EVERY",FM_EVERY);
X  pc("FM_MINFIELDS",FM_MINFIELDS);
X  pn("DEFminfields",DEFminfields);
X  pc("FM_DIGEST",FM_DIGEST);
X  pc("FM_QUIET",FM_QUIET);
X  pc("FM_EXTRACT",FM_EXTRACT);
X  pc("FM_EXTRC_KEEP",FM_EXTRC_KEEP);
X  pc("FM_ADD_IFNOT",FM_ADD_IFNOT);
X  pc("FM_ADD_ALWAYS",FM_ADD_ALWAYS);
X  pc("FM_REN_INSERT",FM_REN_INSERT);
X  pc("FM_DEL_INSERT",FM_DEL_INSERT);
X  pc("FM_ReNAME",FM_ReNAME);
X  pn("EX_OK",EX_OK);
X  *(p=strchr(strchr(q=strchr(pm_version,' ')+1,' ')+1,' '))='\0';p++;
X  ps("PM_VERSION",q);
X  ps("MY_MAIL_ADDR",skltmark(1,&p));
X  ps("MY_ALT_MAIL_ADDR",skltmark(0,&p));
X  ps("PM_MAILINGLIST",skltmark(2,&p));
X  ps("PM_MAILINGLISTR",skltmark(2,&p));
X  ps("BINDIR",BINDIR);
X  return EX_OK;
X}
END_OF_FILE
if test 7318 -ne `wc -c <'procmail/src/manconf.c'`; then
    echo shar: \"'procmail/src/manconf.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/manconf.c'
fi
if test -f 'procmail/src/pipes.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/src/pipes.c'\"
else
echo shar: Extracting \"'procmail/src/pipes.c'\" \(8243 characters\)
sed "s/^X//" >'procmail/src/pipes.c' <<'END_OF_FILE'
X/************************************************************************
X *	Routines related to setting up pipes and filters		*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	#include "README"						*
X ************************************************************************/
X#ifdef RCS
Xstatic /*const*/char rcsid[]=
X "$Id: pipes.c,v 1.15 1993/06/21 14:24:46 berg Exp $";
X#endif
X#include "procmail.h"
X#include "robust.h"
X#include "shell.h"
X#include "misc.h"
X#include "pipes.h"
X#include "common.h"
X#include "cstdio.h"
X#include "goodies.h"
X#include "mailfold.h"
X
Xpid_t pidchild;
Xvolatile time_t alrmtime;
Xstatic char*lastexec,*backblock;
Xstatic long backlen;	       /* length of backblock, filter recovery block */
Xstatic pid_t pidfilt;
Xstatic pipw,pbackfd[2];			       /* the emergency backpipe :-) */
X
Xvoid inittmout(progname)const char*const progname;
X{ lastexec=cstr(lastexec,progname);
X  alrmtime=timeoutv?time((time_t*)0)+(unsigned)timeoutv:0;
X  alarm((unsigned)timeoutv);
X}
X
Xvoid ftimeout P((void))
X{ alarm(0);alrmtime=0;
X  if(pidchild>0&&!kill(pidchild,SIGTERM))	   /* careful, killing again */
X	nlog("Timeout, terminating"),logqnl(lastexec);
X  signal(SIGALRM,(void(*)())ftimeout);
X}
X
Xstatic void stermchild P((void))
X{ if(pidfilt>0)		    /* don't kill what is not ours, we might be root */
X     kill(pidfilt,SIGTERM);
X  if(!Stdout)
X   { static const char rescdata[]="Rescue of unfiltered data ";
X     if(dump(PWRB,backblock,backlen))	  /* pump data back via the backpipe */
X	nlog(rescdata),elog("failed\n");
X     else if(pwait!=4)			/* are we not looking the other way? */
X	nlog(rescdata),elog("succeeded\n");
X   }
X  exit(lexitcode);
X}
X
Xstatic void childsetup P((void))
X{ lexitcode=EX_UNAVAILABLE;signal(SIGTERM,(void(*)())stermchild);
X  signal(SIGINT,(void(*)())stermchild);signal(SIGHUP,(void(*)())stermchild);
X  signal(SIGQUIT,(void(*)())stermchild);closerc();
X}
X
Xstatic void getstdin(pip)const int pip;
X{ rclose(STDIN);rdup(pip);rclose(pip);
X}
X
Xstatic void callnewprog(newname)const char*const newname;
X{ if(sh)					 /* should we start a shell? */
X   { const char*newargv[4];
X     yell(executing,newname);newargv[3]=0;newargv[2]=newname;
X     newargv[1]=tgetenv(shellflags);*newargv=tgetenv(shell);shexec(newargv);
X   }
X  ;{ register const char*p;int argc;
X     argc=1;p=newname;	     /* If no shell, chop up the arguments ourselves */
X     if(verbose)
X      { nlog(executing);elog(oquote);goto no_1st_comma;
X      }
X     do					     /* show chopped up command line */
X      { if(verbose)
X	 { elog(",");
Xno_1st_comma:
X	   elog(p);
X	 }
X	while(*p++);
X	if(verbose&&p-1==All_args&&crestarg)		  /* any "$@" found? */
X	 { const char*const*walkargs=restargv;
X	   goto No_1st_comma;
X	   do
X	    { elog(",");
XNo_1st_comma: elog(*walkargs);					/* expand it */
X	    }
X	   while(*++walkargs);
X	 }
X	if(p-1==All_args)
X	   argc+=crestarg-1;			       /* and account for it */
X      }
X     while(argc++,p!=Tmnate);
X     if(verbose)
X	elog(cquote);				      /* allocate argv array */
X     ;{ const char**newargv;
X	newargv=malloc(argc*sizeof*newargv);p=newname;argc=0;
X	do
X	 { newargv[argc++]=p;
X	   while(*p++);
X	   if(p-1==All_args&&crestarg)
X	    { const char*const*walkargs=restargv;	      /* expand "$@" */
X	      argc--;
X	      while(newargv[argc]= *walkargs++)
X		 argc++;
X	    }
X	 }
X	while(p!=Tmnate);
X	newargv[argc]=0;shexec(newargv);
X      }
X   }
X}
X
Xpipthrough(line,source,len)char*line,*source;const long len;
X{ int pinfd[2],poutfd[2];
X  if(Stdout)
X     PWRB=PRDB= -1;
X  else
X     rpipe(pbackfd);
X  rpipe(pinfd);						 /* main pipes setup */
X  if(!(pidchild=sfork()))			/* create a sending procmail */
X   { backblock=source;backlen=len;childsetup();rclose(PRDI);rclose(PRDB);
X     rpipe(poutfd);rclose(STDOUT);
X     if(!(pidfilt=sfork()))				/* create the filter */
X      { rclose(PWRB);rclose(PWRO);rdup(PWRI);rclose(PWRI);getstdin(PRDO);
X	callnewprog(line);
X      }
X     rclose(PWRI);rclose(PRDO);
X     if(forkerr(pidfilt,line))
X	rclose(PWRO),stermchild();
X     if(dump(PWRO,source,len)&&!ignwerr)  /* send in the text to be filtered */
X	writeerr(line),lexitcode=EX_IOERR,stermchild();
X     if(pwait&&waitfor(pidfilt)!=EX_OK)	 /* check the exitcode of the filter */
X      { pidfilt=0;
X	if(pwait&2)				  /* do we put it on report? */
X	   pwait=4;			     /* no, we'll look the other way */
X	else
X	   progerr(line);		      /* I'm going to tell my mommy! */
X	stermchild();
X      }
X     rclose(PWRB);exit(EX_OK);			  /* allow parent to proceed */
X   }
X  rclose(PWRB);rclose(PWRI);getstdin(PRDI);
X  if(forkerr(pidchild,procmailn))
X     return 1;
X  if(Stdout)
X   { retStdout(readdyn(Stdout,&Stdfilled));
X     if(pwait)
X	return pipw;
X   }
X  return 0;		    /* we stay behind to read back the filtered text */
X}
X
Xlong pipin(line,source,len)char*const line;char*source;long len;
X{ int poutfd[2];
X  rpipe(poutfd);
X  if(!(pidchild=sfork()))				    /* spawn program */
X     rclose(PWRO),closerc(),getstdin(PRDO),callnewprog(line);
X  rclose(PRDO);
X  if(forkerr(pidchild,line))
X     return 1;					    /* dump mail in the pipe */
X  if((len=dump(PWRO,source,len))&&(!ignwerr||(len=0)))
X     writeerr(line);		       /* pipe was shut in our face, get mad */
X  if(pwait&&waitfor(pidchild)!=EX_OK)	    /* optionally check the exitcode */
X   { if(!(pwait&2))				  /* do we put it on report? */
X	progerr(line);
X     len=1;
X   }
X  pidchild=0;
X  if(!sh)
X     concatenate(line);
X  setlastfolder(line);return len;
X}
X
Xchar*readdyn(bf,filled)char*bf;long*const filled;
X{ int i;long oldsize;
X  oldsize= *filled;goto jumpin;
X  do
X   { *filled+=i;				/* change listed buffer size */
Xjumpin:
X#ifdef SMALLHEAP
X     if((size_t)*filled>=(size_t)(*filled+BLKSIZ))
X	lcking|=lck_MEMORY,nomemerr();
X#endif
X     bf=realloc(bf,*filled+BLKSIZ);    /* dynamically adjust the buffer size */
Xjumpback:;
X   }
X  while(0<(i=rread(STDIN,bf+*filled,BLKSIZ)));			/* read mail */
X  if(pidchild>0)
X   { if(!Stdout)
X      { getstdin(PRDB);			       /* filter ready, get backpipe */
X	if(1==rread(STDIN,buf,1))		      /* backup pipe closed? */
X	 { bf=realloc(bf,(*filled=oldsize+1)+BLKSIZ);bf[oldsize]= *buf;
X	   if(pwait)
X	      waitfor(pidchild);
X	   pidchild=0;goto jumpback;	       /* filter goofed, rescue data */
X	 }
X      }
X     if(pwait)
X	pipw=waitfor(pidchild);		      /* reap your child in any case */
X   }
X  pidchild=0;					/* child must be gone by now */
X  if(!*filled)
X     return realloc(bf,1);		     /* +1 for housekeeping purposes */
X  return realloc(bf,*filled+1);			/* minimise the buffer space */
X}
X
Xchar*fromprog(name,dest,max)char*name;char*const dest;size_t max;
X{ int pinfd[2],poutfd[2];int i;char*p;
X  concon('\n');rpipe(pinfd);inittmout(name);
X  if(!(pidchild=sfork()))			/* create a sending procmail */
X   { Stdout=name;childsetup();rclose(PRDI);rpipe(poutfd);rclose(STDOUT);
X     if(!(pidfilt=sfork()))			     /* spawn program/filter */
X	rclose(PWRO),rdup(PWRI),rclose(PWRI),getstdin(PRDO),callnewprog(name);
X     rclose(PWRI);rclose(PRDO);
X     if(forkerr(pidfilt,name))
X	rclose(PWRO),stermchild();
X     dump(PWRO,themail,filled);waitfor(pidfilt);exit(lexitcode);
X   }
X  rclose(PWRI);p=dest;
X  if(!forkerr(pidchild,name))
X   { name=tstrdup(name);
X     while(0<(i=rread(PRDI,p,max))&&(p+=i,max-=i));	    /* read its lips */
X     if(0<rread(PRDI,p,1))
X	nlog("Excessive output quenched from"),logqnl(name);
X     rclose(PRDI);free(name);
X     while(--p>=dest&&*p=='\n');    /* trailing newlines should be discarded */
X     p++;waitfor(pidchild);
X   }
X  else
X     rclose(PRDI);
X  pidchild=0;*p='\0';return p;
X}
X
Xvoid exectrap(tp)const char*const tp;
X{ if(*tp)
X   { int newret;
X     metaparse(tp);concon('\n');inittmout(buf);
X     if(!(pidchild=sfork()))	     /* connect stdout to stderr before exec */
X      { int poutfd[2];
X	Stdout=buf;childsetup();rpipe(poutfd);rclose(STDOUT);pidfilt=thepid;
X	getstdin(PRDO);
X	if(!(pidchild=sfork()))			/* fork off sending procmail */
X	 { rclose(STDIN);rclose(STDERR);dump(PWRO,themail,filled);
X	   exit(lexitcode);		/* finished dumping to stdin of TRAP */
X	 }					 /* call up the TRAP program */
X	rclose(PWRO);rdup(STDERR);forkerr(pidchild,buf);callnewprog(buf);
X      }
X     if(!forkerr(pidchild,buf)&&(newret=waitfor(pidchild))!=EX_OK)
X	retval=newret;			       /* supersede the return value */
X   }
X}
END_OF_FILE
if test 8243 -ne `wc -c <'procmail/src/pipes.c'`; then
    echo shar: \"'procmail/src/pipes.c'\" unpacked with wrong size!
fi
# end of 'procmail/src/pipes.c'
fi
echo shar: End of archive 5 \(of 11\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de

"Always look on the bright side of life!"

exit 0 # Just in case...
