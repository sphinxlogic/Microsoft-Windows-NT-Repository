Newsgroups: comp.sources.misc
From: <dfs@doe.carleton.ca> (David F. Skoll)
Subject: v38i063:  remind - A replacement for calendar, Patch07b/3
Message-ID: <1993Jul22.213825.7619@sparky.sterling.com>
X-Md4-Signature: 4d49abd05a335e90af0dd31472a3000b
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 22 Jul 1993 21:38:25 GMT
Approved: kent@sparky.sterling.com

Submitted-by: <dfs@doe.carleton.ca> (David F. Skoll)
Posting-number: Volume 38, Issue 63
Archive-name: remind/patch07b
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  patch.07.A
# Wrapped by kent@sparky on Thu Jul 22 16:19:13 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'patch.07.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.07.A'\"
else
  echo shar: Extracting \"'patch.07.A'\" \(38731 characters\)
  sed "s/^X//" >'patch.07.A' <<'END_OF_FILE'
XPrereq: "03.00.06"
XSee the patched file "WHATSNEW.30" for a list of
Xchanges in this patch.
X*** ../p6/version.h	Fri Apr 23 12:59:49 1993
X--- ./version.h	Mon Jun 28 12:29:33 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.06"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.07"
X*** ../p6/Makefile	Fri Apr 23 13:00:44 1993
X--- ./Makefile	Mon Jun 28 12:30:00 1993
X***************
X*** 12,18 ****
X  
X  # Uncomment the next line if you want to use gcc instead of default compiler
X  CC= gcc
X! 
X  # Put any additional flags for the C compiler or linker here
X  CFLAGS= -O -ansi
X  CDEFS=
X--- 12,18 ----
X  
X  # Uncomment the next line if you want to use gcc instead of default compiler
X  CC= gcc
X! LD= gcc
X  # Put any additional flags for the C compiler or linker here
X  CFLAGS= -O -ansi
X  CDEFS=
X***************
X*** 46,52 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.06
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X--- 46,53 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.07
X! MATHLIB= -lm
X  
X  HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X  lang.h english.h german.h dutch.h finnish.h
X***************
X*** 70,79 ****
X  	$(CC) $(UNIX) $(SYSV) -c -o $*.o $(CFLAGS) $(CDEFS) $*.c
X  
X  rem2ps: rem2ps.o
X! 	$(CC) $(LDFLAGS) -o rem2ps rem2ps.o
X  
X  remind: $(OBJS)
X! 	$(CC) $(LDFLAGS) -o remind $(OBJS)
X  
X  clean:
X  	rm -f *.o *~
X--- 71,80 ----
X  	$(CC) $(UNIX) $(SYSV) -c -o $*.o $(CFLAGS) $(CDEFS) $*.c
X  
X  rem2ps: rem2ps.o
X! 	$(LD) $(LDFLAGS) -o rem2ps rem2ps.o
X  
X  remind: $(OBJS)
X! 	$(LD) $(LDFLAGS) -o remind $(OBJS) $(MATHLIB)
X  
X  clean:
X  	rm -f *.o *~
X***************
X*** 105,112 ****
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.6.tar $(MANIFEST)
X! 	compress -v remind-3.0.6.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X--- 106,113 ----
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.7.tar $(MANIFEST)
X! 	compress -v remind-3.0.7.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X*** ../p6/README.UNIX	Thu Apr 22 10:24:13 1993
X--- ./README.UNIX	Mon Jun 28 12:29:27 1993
X***************
X*** 32,38 ****
X  script.
X  
X  *** NOTE *** Please be aware that "remind-all.csh" and "remind-all.sh"
X! have been changed since the last release of Remind.  If you install
X  the new remind executable, make sure you switch over to the new
X  "remind-all" scripts.
X  
X--- 32,38 ----
X  script.
X  
X  *** NOTE *** Please be aware that "remind-all.csh" and "remind-all.sh"
X! have been changed since version 03.00.05 of Remind.  If you install
X  the new remind executable, make sure you switch over to the new
X  "remind-all" scripts.
X  
X*** ../p6/WHATSNEW.30	Mon May  3 11:00:51 1993
X--- ./WHATSNEW.30	Mon Jul 19 10:59:32 1993
X***************
X*** 1,5 ****
X--- 1,48 ----
X  CHANGES TO REMIND
X  
X+ * Version 3.0 Patch 7
X+ 
X+ + MAJOR ENHANCEMENTS
X+ 
X+ - Added "system variables" to allow the user more control over
X+   Remind operation, and to allow queries about the command-line
X+   options from within a reminder script.  They allow for specification
X+   of longitude and latitude for use by sunrise/sunset calculations.
X+ 
X+ - Added sunrise(), sunset(), isdst() and minsfromutc() functions -
X+   these are needed to support sunrise and sunset calculations.
X+ 
X+ + MINOR ENHANCEMENTS
X+ 
X+ - Allowed the MSG, RUN, CAL, PS and PSF keywords to be used in the
X+   same reminder as the SATISFY keyword.  This makes many complex
X+   reminders more compact.
X+ 
X+ - Added the filedir() function to enable Remind's include to emulate
X+   CPP's #include more closely.
X+ 
X+ - Allowed non-root users to use the "-u" option.  It only affects
X+   the "SHELL", "HOME", "USER" and "LOGNAME" environment variables -
X+   it doesn't change the effective uid and gid when run by non-root.
X+ 
X+ - Added built-in function "easterdate" to calculate date of Easter
X+   Sunday - function courtesy of Michael Salmon.
X+ 
X+ - Improved the Jewish holiday reminders in "defs.rem" to give advance
X+   notice of holidays.
X+ 
X+ - Allowed the "simple calendar" option (-s) to specify a number of
X+   weeks as well as a number of months, in the same fashion as the
X+   -c option.  Thanks to Dave Rickel.
X+ 
X+ + BUG FIXES
X+ 
X+ - Corrected the behaviour of "hebdate" for jahrzeits; added an additional
X+   parameter to specify the behaviour of dates in Adar during leap years.
X+ 
X+ - Changed kall so that "kall sh" doesn't commit suicide - patch courtesy
X+   of Michael Salmon.
X+ 
X  * Version 3.0 Patch 6
X  
X  + MINOR ENHANCEMENTS
X*** ../p6/calendar.c	Mon May  3 12:01:29 1993
X--- ./calendar.c	Mon Jun 28 13:08:26 1993
X***************
X*** 83,91 ****
X     } else {
X        JulianToday -= ((JulianToday+1)%7);
X  
X!       WriteIntermediateCalLine();
X!       WriteCalDays();
X!       WriteIntermediateCalLine();
X  
X        while (CalWeeks--)
X           DoCalendarOneWeek();
X--- 83,93 ----
X     } else {
X        JulianToday -= ((JulianToday+1)%7);
X  
X!       if (!DoSimpleCalendar) {
X!          WriteIntermediateCalLine();
X!          WriteCalDays();
X!          WriteIntermediateCalLine();
X!       }
X  
X        while (CalWeeks--)
X           DoCalendarOneWeek();
X***************
X*** 106,112 ****
X  static void DoCalendarOneWeek()
X  #endif
X  {
X!    int y, m, d, done, i, l;
X     char buf[81];
X     int LinesWritten = 0;
X     int OrigJul = JulianToday;
X--- 108,114 ----
X  static void DoCalendarOneWeek()
X  #endif
X  {
X!    int y, m, d, done, i, l, wd;
X     char buf[81];
X     int LinesWritten = 0;
X     int OrigJul = JulianToday;
X***************
X*** 119,124 ****
X--- 121,135 ----
X  
X  /* Output the entries */
X  
X+ /* If it's "Simple Calendar" format, do it simply... */
X+    if (DoSimpleCalendar) {
X+       wd = (JulianToday + 1) % 7;
X+       for (i=0; i<7; i++) {
X+          WriteSimpleEntries(i, OrigJul+i-wd);
X+       }
X+       return;
X+    }
X+ 
X  /* Here come the first few lines... */
X     putchar('|');
X     for (i=0; i<7; i++) {
X***************
X*** 464,469 ****
X--- 475,481 ----
X     ClearGlobalOmits();
X     DestroyOmitContexts();
X     DestroyVars();
X+    NumTriggered = 0;
X  
X     r=OpenFile(InitialFile);
X     if (r) {
X***************
X*** 618,623 ****
X--- 630,637 ----
X     CalEntry *CurPs = CalPs[col];
X     CalEntry *e;
X     char *s;
X+    char buf[TOKSIZE];
X+    Token tok;
X  
X     /* Parse the trigger date and time */
X     if ( (r=ParseRem(p, &trig, &tim)) ) return r;
X***************
X*** 627,637 ****
X     if (DontIssueAts && tim.ttime != NO_TIME) return OK;
X  #endif
X     if (trig.typ == NO_TYPE) return E_EOLN;
X!    if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X! 
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X!    if (r) return r;
X     if (!PsCal && (trig.typ == PS_TYPE || trig.typ == PSF_TYPE)) return OK;
X  
X     /* Remove any "at" times from PS or PSFILE reminders */
X--- 641,663 ----
X     if (DontIssueAts && tim.ttime != NO_TIME) return OK;
X  #endif
X     if (trig.typ == NO_TYPE) return E_EOLN;
X!    if (trig.typ == SAT_TYPE) {
X!       r=DoSatRemind(&trig, &tim, p);
X!       if (r) return r;
X!       r=ParseToken(p, buf);
X!       if (r) return r;
X!       FindToken(buf, &tok);
X!       if (tok.type == T_Empty || tok.type == T_Comment) return OK;
X!       if (tok.type != T_RemType || tok.val == SAT_TYPE) return E_PARSE_ERR;
X!       trig.typ = tok.val;
X!       jul = LastTriggerDate;
X!       if (!LastTrigValid) return OK;
X!    } else {
X     /* Calculate the trigger date */
X!       jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X!       if (r) return r;
X!    }
X! 
X     if (!PsCal && (trig.typ == PS_TYPE || trig.typ == PSF_TYPE)) return OK;
X  
X     /* Remove any "at" times from PS or PSFILE reminders */
X***************
X*** 639,644 ****
X--- 665,671 ----
X  
X     /* If trigger date == today, add it to the current entry */   
X     if (jul == JulianToday) {
X+       NumTriggered++;
X        s = SubstBuffer;
X        if (DoSimpleCalendar || tim.ttime != NO_TIME)
X           s += strlen(SimpleTime(tim.ttime, s));
X*** ../p6/config.h	Thu Apr 22 10:24:02 1993
X--- ./config.h	Mon Jun 28 12:29:29 1993
X***************
X*** 12,17 ****
X--- 12,41 ----
X  /***************************************************************/
X  
X  /*---------------------------------------------------------------------*/
X+ /* LAT_DEG, LAT_MIN and LAT_SEC:  Latitude of your location            */
X+ /* LONG_DEG, LONG_MIN and LONG_SEC: Longitude of your location         */
X+ /* For latitude, north is positive, south is negative.                 */
X+ /* For longitude, west is positive, east is negative.                  */
X+ /* NOTE:  For negative numbers, all three of DEG, MIN, SEC should be   */
X+ /*        negative.  To indicate -20deg22'33" use                      */
X+ /*        DEG=-20, MIN=-22 and SEC=-33.                                */
X+ /* The default values are initially set to Ottawa, Ontario, Canada.    */
X+ /*---------------------------------------------------------------------*/
X+ #define LAT_DEG  45
X+ #define LAT_MIN  24
X+ #define LAT_SEC  00
X+ #define LONG_DEG 75
X+ #define LONG_MIN 39
X+ #define LONG_SEC  0
X+ 
X+ /*---------------------------------------------------------------------*/
X+ /* HAVE_MKTIME: Define this if your C library includes the mktime()    */
X+ /*              function.  Otherwise, will attempt to use the Unix     */
X+ /*              style time manipulations.                              */
X+ /*---------------------------------------------------------------------*/
X+ #define HAVE_MKTIME 1
X+ 
X+ /*---------------------------------------------------------------------*/
X  /* DEFAULT_PAGE:  The default page size to use for Rem2PS.             */
X  /* The Letter version is appropriate for North America; the A4 version */
X  /* is appropriate for Europe.                                          */
X***************
X*** 72,78 ****
X  /*       IMPORTANT NOTE:  The Hebrew date routines depend on BASE      */
X  /*       being set to 1990.  If you change it, you'll have to add the  */
X  /*       number of days between 1 Jan <NEWBASE> and 1 Jan 1990 to the  */
X! /*       manifest constant CORRECTION in hbcal.c                       */
X  /*---------------------------------------------------------------------*/
X  #define BASE 1990
X  
X--- 96,103 ----
X  /*       IMPORTANT NOTE:  The Hebrew date routines depend on BASE      */
X  /*       being set to 1990.  If you change it, you'll have to add the  */
X  /*       number of days between 1 Jan <NEWBASE> and 1 Jan 1990 to the  */
X! /*       manifest constant CORRECTION in hbcal.c.  Also, the year      */
X! /*       folding mechanism in main.c depends on BASE<2001.             */
X  /*---------------------------------------------------------------------*/
X  #define BASE 1990
X  
X***************
X*** 86,92 ****
X  #define YR_RANGE 88
X  
X  /*---------------------------------------------------------------------*/
X! /* VAR_NAME_LEN: The maximum length of variable names                  */
X  /*---------------------------------------------------------------------*/
X  #define VAR_NAME_LEN 12
X  
X--- 111,118 ----
X  #define YR_RANGE 88
X  
X  /*---------------------------------------------------------------------*/
X! /* VAR_NAME_LEN: The maximum length of variable names.  Don't make it  */
X! /*               any less than 12.                                     */
X  /*---------------------------------------------------------------------*/
X  #define VAR_NAME_LEN 12
X  
X*** ../p6/defs.rem	Mon May  3 10:29:12 1993
X--- ./defs.rem	Fri Jul 16 15:28:09 1993
X***************
X*** 25,32 ****
X  ################################################
X  # Ensure required version of remind is used... #
X  ################################################
X! IF version() < "03.00.06"
X!    ERRMSG This file requires at least version 03.00.06 of Remind.%
X     ERRMSG This version is version [version()].
X     EXIT
X  ENDIF
X--- 25,32 ----
X  ################################################
X  # Ensure required version of remind is used... #
X  ################################################
X! IF version() < "03.00.07"
X!    ERRMSG This file requires at least version 03.00.07 of Remind.%
X     ERRMSG This version is version [version()].
X     EXIT
X  ENDIF
X***************
X*** 100,105 ****
X--- 100,145 ----
X  FSET _back(days)	TRIGGER(TODAY()-days)
X  
X  ###########################################################
X+ # On MS-DOS systems, the standard C library functions are #
X+ # not reliable for computing offsets from local time to   #
X+ # UTC.  The following provides a work-around for the      #
X+ # sunrise() and sunset() functions.  Note, however, that  #
X+ # if Daylight Savings Time is in effect for today(), the  #
X+ # sun functions return times in DST even for dates on     #
X+ # which DST is not in effect; the converse can also occur.#
X+ #                                                         #
X+ # Change the timezone to your timezone - the default is   #
X+ # for EST which is 5 hours (300 minutes) behind UTC.      #
X+ # The code is correct for places in which Daylight Savings#
X+ # Time begins on the last Sunday in March and ends on the #
X+ # last Sunday in October.                                 #
X+ ###########################################################
X+ 
X+ IF OSTYPE() == "MSDOS"
X+     # Eastern Standard Time
X+     SET TimeZone -300
X+ 
X+     # Use --8 rather than --7 because we want the last day BEFORE
X+     # the time switch occurs.
X+     REM Sun 1 Apr --8 SATISFY 1
X+     SET BegDst TRIGDATE()
X+ 
X+     REM Sun 1 Nov --8 SATISFY 1
X+     SET EndDst TRIGDATE()
X+ 
X+     SET $CalcUTC 0
X+ 
X+     # Check out the following IF statement and figure out why it works!
X+     IF EndDst < BegDst
X+         # Daylight Savings Time
X+         SET $MinsFromUTC TimeZone+60
X+     ELSE
X+         # Standard Time
X+         SET $MinsFromUTC TimeZone
X+     ENDIF
X+ ENDIF
X+ 
X+ ###########################################################
X  # Function which returns a string in "am/pm" format based #
X  # on the time.  For example, set a am_pm(NOW())...        #
X  ###########################################################
X***************
X*** 219,226 ****
X  # on 2 Jan rather than 8 Jan.  We add 6 to TRIGDATE() in _IsMortDate to
X  # compensate.
X  
X! REM 2 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE()+6)
X! REM [TRIGGER(TRIGDATE())] ++4 MSG %"Schedule mortgage payment%" for %a.
X  
X  # Now the mail reminder two weeks before the payment date - because two
X  # weeks before a payment date is also a payment date, no pre-compensation
X--- 259,266 ----
X  # on 2 Jan rather than 8 Jan.  We add 6 to TRIGDATE() in _IsMortDate to
X  # compensate.
X  
X! REM 2 Jan 1993 *14 ++4 SATISFY [_IsMortDate(TRIGDATE()+6)] \
X! 	MSG %"Schedule mortgage payment%" for %a.
X  
X  # Now the mail reminder two weeks before the payment date - because two
X  # weeks before a payment date is also a payment date, no pre-compensation
X***************
X*** 227,242 ****
X  # in the starting date of 8 Jan is necessary - convince yourself of this!
X  # This uses the _mail() function defined earlier.
X  
X! REM 8 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE()+14)
X! REM [TRIGGER(TRIGDATE())] ONCE RUN [_mail("Decatur Federal", \
X! 	"Pay mortgage by the " + ORD(DAY(TRIGDATE()+14)))]
X  
X  # Make an entry on the calendar when the mortgage should be paid
X  
X! REM 8 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE())
X! REM [TRIGGER(TRIGDATE())] CAL Mortgage payment
X  
X  
X  #USHOLS
X  #############################################################################
X  #       								    #
X--- 267,312 ----
X  # in the starting date of 8 Jan is necessary - convince yourself of this!
X  # This uses the _mail() function defined earlier.
X  
X! REM ONCE 8 Jan 1993 *14 SATISFY [_IsMortDate(TRIGDATE()+14)] \
X! 	RUN [_mail("Decatur Federal", \
X! 		"Pay mortgage by the " + ORD(DAY(TRIGDATE()+14)))]
X  
X  # Make an entry on the calendar when the mortgage should be paid
X  
X! REM 8 Jan 1993 *14 SATISFY [_IsMortDate(TRIGDATE())] \
X! 	CAL Mortgage payment
X  
X+ #PSSTUFF
X+ ##########################################################################
X+ #								         #
X+ # This portion of the file contains some cute examples of the new        #
X+ # PS-type reminders.  You need a PostScript printer or viewer to         #
X+ # appreciate these.  To use them, pipe the output of remind -p into the  #
X+ # rem2ps program.                                                        #
X+ #								         #
X+ ##########################################################################
X  
X+ # Convenient to stick all the PostScript code in a string var - makes
X+ # reminders easier to understand.  The variable "shade" will contain
X+ # PostScript code to shade in a particular box on the calendar.
X+ SET shade \
X+ "/_A LineWidth 2 div def \
X+ _A _A moveto \
X+ BoxWidth _A sub _A lineto \
X+ BoxWidth _A sub BoxHeight _A sub lineto \
X+ _A BoxHeight _A sub lineto \
X+ closepath 0.95 setgray fill 0.0 setgray"
X+ 
X+ # The following reminder will shade the Saturday and Sunday calendar
X+ # entries. 
X+ REM Sat Sun PS [shade]
X+ 
X+ # The following will fill in the Hebrew dates on the calendar.  For this
X+ # example, I recommend that you use the "-sd 10" option for rem2ps.
X+ REM PS Border BoxHeight Border sub DaySize sub moveto \
X+    /DayFont findfont DaySize scalefont setfont \
X+    ([hebday(today())] [hebmon(today())]) show
X+ 
X  #USHOLS
X  #############################################################################
X  #       								    #
X***************
X*** 245,260 ****
X  #									    #
X  #############################################################################
X  
X! IF !DEFINED("easter")
X! 	SET a YEAR(TODAY())
X! 	SET b (a/100 - (a/100 + 8) % 25 + 1) / 3
X! 	SET c (a%19*19 + a/100 - a/400 - b + 15) % 30
X! 	SET d (32 + a/100%4*2 + (a%100/4*2) - c - a%100%4) % 7
X! 	SET e c + d - (((a%19) + c*11 + d*22) / 451) * 7 + 114
X! 	SET easter DATE(a, e / 31, e % 31 + 1)
X! 	PRESERVE easter
X! ENDIF
X! 
X  REM  [TRIGGER(easter-46)] MSG %"Ash Wednesday%"
X  REM  [TRIGGER(easter-7)]  MSG %"Palm Sunday%"
X  OMIT [TRIGGER(easter-2)]  MSG %"Good Friday%"
X--- 315,322 ----
X  #									    #
X  #############################################################################
X  
X! SET SaveTrig $NumTrig
X! SET easter EASTERDATE(YEAR(TODAY()))
X  REM  [TRIGGER(easter-46)] MSG %"Ash Wednesday%"
X  REM  [TRIGGER(easter-7)]  MSG %"Palm Sunday%"
X  OMIT [TRIGGER(easter-2)]  MSG %"Good Friday%"
X***************
X*** 292,299 ****
X  REM  Sun [_last(Oct)]	MSG Daylight Savings Time - %"DST over%"
X  REM      Oct 30		MSG %"Mischief Night%"
X  REM      Oct 31		MSG %"Halloween%"
X! REM  Tue Nov  2		SCANFROM [_back(7)] SATISFY (YEAR(TRIGDATE()) % 4) == 0
X! 			REM [_trig()] MSG %"Election%" Day
X  REM  Thu Nov [Week_4]	SCANFROM [_back(7)] SATISFY 1
X  			OMIT [_trig()] MSG %"Thanksgiving%" Day
X  REM  Fri Nov [Week_4+1]	SCANFROM [_back(7)] SATISFY 1
X--- 354,362 ----
X  REM  Sun [_last(Oct)]	MSG Daylight Savings Time - %"DST over%"
X  REM      Oct 30		MSG %"Mischief Night%"
X  REM      Oct 31		MSG %"Halloween%"
X! REM  Tue Nov  2		SCANFROM [_back(7)] \
X! 	SATISFY [(YEAR(TRIGDATE()) % 4) == 0] \
X! 	MSG %"Election%" Day
X  REM  Thu Nov [Week_4]	SCANFROM [_back(7)] SATISFY 1
X  			OMIT [_trig()] MSG %"Thanksgiving%" Day
X  REM  Fri Nov [Week_4+1]	SCANFROM [_back(7)] SATISFY 1
X***************
X*** 301,306 ****
X--- 364,381 ----
X  OMIT     Dec 24		MSG %"Christmas Eve%"
X  OMIT     Dec 25		MSG %"Christmas%" Day
X  
X+ ##########################################################################
X+ #								         #
X+ # The next block uses the shade variable defined in PSSTUFF above.       #
X+ # If any US holidays were triggered above, shade in the calendar         #
X+ # entry in PostScript.  This is not quite correct, as it blots out the   #
X+ # other PostScript stuff above.  I was too lazy to do it properly :-)    #
X+ #								         #
X+ ##########################################################################
X+ if $NumTrig > SaveTrig
X+ 	REM PS [shade]
X+ endif
X+ 
X  # Seasons (valid from 1992 to 2000)...
X  REM Mar 20 MSG %"Spring%" begins
X  REM Jun [IIF(YEAR(TODAY())%4, 21, 20)] MSG %"Summer%" begins
X***************
X*** 315,325 ****
X  # dates were obtained from "The First Jewish Catalog" by Richard Siegel	 #
X  # and Michael and Sharon Strassfeld, published by the Jewish Publication #
X  # Society of America.  The Reform version of the calendar was guessed	 #
X! # at by David Skoll based on experience # I welcome corrections.	 #
X  #									 #
X- # You (probably) want to add deltas to some of the reminders so that	 #
X- # you are given advance notice of Jewish holidays.			 #
X- #								         #
X  ##########################################################################
X  
X  # Here are some general functions that you might find nice to use
X--- 390,397 ----
X  # dates were obtained from "The First Jewish Catalog" by Richard Siegel	 #
X  # and Michael and Sharon Strassfeld, published by the Jewish Publication #
X  # Society of America.  The Reform version of the calendar was guessed	 #
X! # at by David Skoll based on experience.  I welcome corrections.         #
X  #									 #
X  ##########################################################################
X  
X  # Here are some general functions that you might find nice to use
X***************
X*** 348,429 ****
X  SET InIsrael VALUE("InIsrael", 0)
X  SET Reform   VALUE("Reform", 0)
X  
X! [_h(1,  "Tishrey")] MSG Rosh Hashana 1
X  
X  # No RH-2 or Tzom Gedalia in Reform
X  IF !Reform
X!    [_h(2,  "Tishrey")] MSG Rosh Hashana 2
X!    [_h(3,  "Tishrey")] MSG Tzom Gedalia
X  ENDIF
X  
X! [_h(10, "Tishrey")] MSG Yom Kippur
X! [_h(15, "Tishrey")] MSG Sukkot 1
X  
X  IF !InIsrael
X!    [_h(16, "Tishrey")] MSG Sukkot 2
X  ENDIF
X  
X! [_h(21, "Tishrey")] MSG Hashana Rabba
X! [_h(22, "Tishrey")] MSG Shemini Atzeret
X  
X  IF InIsrael
X!    [_h(22, "Tishrey")] MSG Simchat Torah
X  ELSE
X!    [_h(23, "Tishrey")] MSG Simchat Torah
X  ENDIF
X  
X  # Because Kislev can change length, we must be more careful about Chanukah
X  FSET _chan(x) TRIGGER(HEBDATE(24, "Kislev", today()-9)+x)
X! [_chan(1)] MSG Chanukah 1
X! [_chan(2)] MSG Chanukah 2
X! [_chan(3)] MSG Chanukah 3
X! [_chan(4)] MSG Chanukah 4
X! [_chan(5)] MSG Chanukah 5
X! [_chan(6)] MSG Chanukah 6
X! [_chan(7)] MSG Chanukah 7
X! [_chan(8)] MSG Chanukah 8
X  
X  # Not sure about Reform's position on the next one.
X  IF !Reform
X!    [_h(10, "Tevet")] MSG Asara B'Tevet
X  ENDIF
X  
X! [_h(15, "Shvat")] MSG Tu B'Shvat
X! [_h(15, "Adar A")] MSG Purim Katan
X! [_h(13, "Adar")] MSG Fast of Esther
X! [_h(14, "Adar")] MSG Purim
X! [_h(15, "Nisan")] MSG Pesach
X  
X  IF !InIsrael
X!    [_h(16, "Nisan")] MSG Pesach 2
X  ENDIF
X  
X! [_h(21, "Nisan")] MSG Pesach 7
X  
X  IF !InIsrael && !Reform
X!    [_h(22, "Nisan")] MSG Pesach 8
X  ENDIF
X  
X! [_h(27, "Nisan")] MSG Yom HaShoah
X! [_h(4,  "Iyar")] MSG Yom HaZikaron
X! [_h(5,  "Iyar")] MSG Yom Ha'atzmaut
X  
X  # Not sure about Reform's position on Lag B'Omer
X  IF !Reform
X!    [_h(18, "Iyar")] MSG Lag B'Omer
X  ENDIF
X  
X! [_h(28, "Iyar")] MSG Yom Yerushalayim
X! [_h(6,  "Sivan")] MSG Shavuot
X  
X  IF !InIsrael && !Reform
X!    [_h(7, "Sivan")] MSG Shavuot 2
X  ENDIF
X  
X  # Fairly sure Reform Jews don't observe the next two
X  IF !Reform
X!    [_h(17, "Tamuz")] MSG Fast of 17th of Tammuz
X!    [_h(9,  "Av")] MSG Tish'a B'Av
X  ENDIF
X  
X  # Counting the omer - do the whole spiel, i.e:
X--- 420,501 ----
X  SET InIsrael VALUE("InIsrael", 0)
X  SET Reform   VALUE("Reform", 0)
X  
X! [_h(1,  "Tishrey")] ++4 MSG %"Rosh Hashana 1%" is %b.
X  
X  # No RH-2 or Tzom Gedalia in Reform
X  IF !Reform
X!    [_h(2,  "Tishrey")] ++4 MSG %"Rosh Hashana 2%" is %b.
X!    [_h(3,  "Tishrey")] ++4 MSG %"Tzom Gedalia%" is %b.
X  ENDIF
X  
X! [_h(10, "Tishrey")] ++4 MSG %"Yom Kippur%" is %b.
X! [_h(15, "Tishrey")] ++4 MSG %"Sukkot 1%" is %b.
X  
X  IF !InIsrael
X!    [_h(16, "Tishrey")] MSG %"Sukkot 2%"
X  ENDIF
X  
X! [_h(21, "Tishrey")] ++4 MSG %"Hashana Rabba%" is %b.
X! [_h(22, "Tishrey")] ++4 MSG %"Shemini Atzeret%" is %b.
X  
X  IF InIsrael
X!    [_h(22, "Tishrey")] ++4 MSG %"Simchat Torah%" is %b.
X  ELSE
X!    [_h(23, "Tishrey")] ++4 MSG %"Simchat Torah%" is %b.
X  ENDIF
X  
X  # Because Kislev can change length, we must be more careful about Chanukah
X  FSET _chan(x) TRIGGER(HEBDATE(24, "Kislev", today()-9)+x)
X! [_chan(1)] ++4 MSG %"Chanukah 1%" is %b.
X! [_chan(2)] MSG %"Chanukah 2%"
X! [_chan(3)] MSG %"Chanukah 3%"
X! [_chan(4)] MSG %"Chanukah 4%"
X! [_chan(5)] MSG %"Chanukah 5%"
X! [_chan(6)] MSG %"Chanukah 6%"
X! [_chan(7)] MSG %"Chanukah 7%"
X! [_chan(8)] MSG %"Chanukah 8%"
X  
X  # Not sure about Reform's position on the next one.
X  IF !Reform
X!    [_h(10, "Tevet")] ++4 MSG %"Asara B'Tevet%" is %b.
X  ENDIF
X  
X! [_h(15, "Shvat")] ++4 MSG %"Tu B'Shvat%" is %b.
X! [_h(15, "Adar A")] ++4 MSG %"Purim Katan%" is %b.
X! [_h(13, "Adar")] ++4 MSG %"Fast of Esther%" is %b.
X! [_h(14, "Adar")] ++4 MSG %"Purim%" is %b.
X! [_h(15, "Nisan")] ++4 MSG %"Pesach%" is %b.
X  
X  IF !InIsrael
X!    [_h(16, "Nisan")] MSG %"Pesach 2%"
X  ENDIF
X  
X! [_h(21, "Nisan")] MSG %"Pesach 7%"
X  
X  IF !InIsrael && !Reform
X!    [_h(22, "Nisan")] MSG %"Pesach 8%"
X  ENDIF
X  
X! [_h(27, "Nisan")] ++4 MSG %"Yom HaShoah%" is %b.
X! [_h(4,  "Iyar")] ++4 MSG %"Yom HaZikaron%" is %b.
X! [_h(5,  "Iyar")] ++4 MSG %"Yom Ha'atzmaut%" is %b.
X  
X  # Not sure about Reform's position on Lag B'Omer
X  IF !Reform
X!    [_h(18, "Iyar")] ++4 MSG %"Lag B'Omer%" is %b.
X  ENDIF
X  
X! [_h(28, "Iyar")] ++4 MSG %"Yom Yerushalayim%" is %b.
X! [_h(6,  "Sivan")] ++4 MSG %"Shavuot%" is %b.
X  
X  IF !InIsrael && !Reform
X!    [_h(7, "Sivan")] MSG %"Shavuot 2%"
X  ENDIF
X  
X  # Fairly sure Reform Jews don't observe the next two
X  IF !Reform
X!    [_h(17, "Tamuz")] ++4 MSG %"Fast of 17th of Tammuz%" is %b.
X!    [_h(9,  "Av")] ++4 MSG %"Tish'a B'Av%" is %b.
X  ENDIF
X  
X  # Counting the omer - do the whole spiel, i.e:
X***************
X*** 444,476 ****
X     CAL [ORD(odays)] of Omer
X  ENDIF
X  
X! #PSSTUFF
X! ##########################################################################
X! #								         #
X! # This portion of the file contains some cute examples of the new        #
X! # PS-type reminders.  You need a PostScript printer or viewer to         #
X! # appreciate these.  To use them, pipe the output of remind -p into the  #
X! # rem2ps program.                                                        #
X! #								         #
X! ##########################################################################
X  
X! # Convenient to stick all the PostScript code in a string var - makes
X! # reminders easier to understand.  The variable "shade" will contain
X! # PostScript code to shade in a particular box on the calendar.
X! SET shade \
X! "/_A LineWidth 2 div def \
X! _A _A moveto \
X! BoxWidth _A sub _A lineto \
X! BoxWidth _A sub BoxHeight _A sub lineto \
X! _A BoxHeight _A sub lineto \
X! closepath 0.95 setgray fill 0.0 setgray"
X! 
X! # The following reminder will shade the Saturday and Sunday calendar
X! # entries. 
X! REM Sat Sun PS [shade]
X! 
X! # The following will fill in the Hebrew dates on the calendar.  For this
X! # example, I recommend that you use the "-sd 10" option for rem2ps.
X! REM PS Border BoxHeight Border sub DaySize sub moveto \
X!    /DayFont findfont DaySize scalefont setfont \
X!    ([hebday(today())] [hebmon(today())]) show
X--- 516,525 ----
X     CAL [ORD(odays)] of Omer
X  ENDIF
X  
X! ### Candle lighting and Havdalah.  You should probably add candle lighting
X! ### for other holidays besides Shabbat.  These just create calendar entries
X! ### for Friday and Saturday.  Note:  You must set your latitude, longitude
X! ### and possibly time zone for these to work properly!
X  
X! REM Friday   CAL Candle lighting at [sunset(trigdate())-18]
X! REM Saturday CAL Havdalah at [sunset(trigdate())+42]
X*** ../p6/dorem.c	Fri Apr 30 13:16:27 1993
X--- ./dorem.c	Mon Jun 28 12:58:03 1993
X***************
X*** 48,62 ****
X     TimeTrig tim;
X     int r;
X     int jul;
X  
X     /* Parse the trigger date and time */
X     if ( (r=ParseRem(p, &trig, &tim)) ) return r;
X  
X     if (trig.typ == NO_TYPE) return E_EOLN;
X!    if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X!    if (r) return r;
X     
X  /* Queue the reminder, if necessary */
X  #ifdef HAVE_QUEUED
X--- 48,76 ----
X     TimeTrig tim;
X     int r;
X     int jul;
X+    char buf[TOKSIZE];
X+    Token tok;
X  
X     /* Parse the trigger date and time */
X     if ( (r=ParseRem(p, &trig, &tim)) ) return r;
X  
X     if (trig.typ == NO_TYPE) return E_EOLN;
X!    if (trig.typ == SAT_TYPE) {
X!       r=DoSatRemind(&trig, &tim, p);
X!       if (r) return r;
X!       r=ParseToken(p, buf);
X!       if (r) return r;
X!       FindToken(buf, &tok);
X!       if (tok.type == T_Empty || tok.type == T_Comment) return OK;
X!       if (tok.type != T_RemType || tok.val == SAT_TYPE) return E_PARSE_ERR;
X!       trig.typ = tok.val;
X!       jul = LastTriggerDate;
X!       if (!LastTrigValid) return OK;
X!    } else {
X     /* Calculate the trigger date */
X!       jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X!       if (r) return r;
X!    }
X     
X  /* Queue the reminder, if necessary */
X  #ifdef HAVE_QUEUED
X***************
X*** 228,234 ****
X  	    return OK;
X  
X  	 default:
X! 	    Eprint("Unknown token in REM command: %s", TokBuffer);
X  	    return E_PARSE_ERR;
X        }
X     }
X--- 242,248 ----
X  	    return OK;
X  
X  	 default:
X! 	    Eprint("Unknown token in trigger: %s", TokBuffer);
X  	    return E_PARSE_ERR;
X        }
X     }
X***************
X*** 601,608 ****
X  {
X     int iter, jul, r;
X     Value v;
X!    char *s;
X  
X     iter = 0;
X     jul = trig->scanfrom;
X     while (iter++ < MaxSatIter) {
X--- 615,623 ----
X  {
X     int iter, jul, r;
X     Value v;
X!    char *s, *t;
X  
X+    t = p->pos;
X     iter = 0;
X     jul = trig->scanfrom;
X     while (iter++ < MaxSatIter) {
X***************
X*** 612,624 ****
X        }
X        s = p->pos;
X        r = EvaluateExpr(p, &v);
X!       p->pos = s;
X        if (r) return r;
X        if (v.type != INT_TYPE && v.type != STR_TYPE) return E_BAD_TYPE;
X        if (v.type == INT_TYPE && v.v.val) return OK;
X        if (v.type == STR_TYPE && *v.v.str) return OK;
X        jul++;
X     }
X     LastTrigValid = 0;
X     return OK;
X  }
X--- 627,641 ----
X        }
X        s = p->pos;
X        r = EvaluateExpr(p, &v);
X!       t = p->pos;
X        if (r) return r;
X        if (v.type != INT_TYPE && v.type != STR_TYPE) return E_BAD_TYPE;
X        if (v.type == INT_TYPE && v.v.val) return OK;
X        if (v.type == STR_TYPE && *v.v.str) return OK;
X+       p->pos = s;
X        jul++;
X     }
X+    p->pos = t;
X     LastTrigValid = 0;
X     return OK;
X  }
X*** ../p6/err.h	Thu Apr 22 10:24:04 1993
X--- ./err.h	Mon Jun 28 12:29:30 1993
X***************
X*** 56,61 ****
X--- 56,63 ----
X  #define E_PARSE_AS_REM       44 /* Not really an error - just returned by
X                                     DoOmit to indicate line should be executed
X                                     as a REM statement, also. */
X+ #define E_CANT_MODIFY        45
X+ #define E_MKTIME_PROBLEM     46
X  #ifdef MK_GLOBALS
X  #undef EXTERN
X  #define EXTERN
X***************
X*** 112,118 ****
X     "Domain error",
X     "Invalid identifier",
X     "Recursive function call detected",
X!    ""
X  }
X  #endif
X  ;
X--- 114,122 ----
X     "Domain error",
X     "Invalid identifier",
X     "Recursive function call detected",
X!    "",
X!    "Cannot modify system variable",
X!    "C library function can't represent date/time"
X  }
X  #endif
X  ;
X*** ../p6/expr.c	Thu Apr 22 11:00:23 1993
X--- ./expr.c	Mon Jun 28 12:29:43 1993
X***************
X*** 239,245 ****
X        if (c == '\'') return OK ; else return E_MISS_QUOTE;
X     }
X  
X!    if (!ISID(c)) {
X        Eprint("%s '%c'", ErrMsg[E_ILLEGAL_CHAR], c);
X        return E_ILLEGAL_CHAR;
X     }
X--- 239,245 ----
X        if (c == '\'') return OK ; else return E_MISS_QUOTE;
X     }
X  
X!    if (!ISID(c) && c != '$') {
X        Eprint("%s '%c'", ErrMsg[E_ILLEGAL_CHAR], c);
X        return E_ILLEGAL_CHAR;
X     }
X***************
X*** 306,312 ****
X     int args; /* Number of function arguments */
X     Operator op, op2;
X     Value va;
X!    char *ufname;
X     
X     OpBase = OpStackPtr;
X     ValBase = ValStackPtr;
X--- 306,312 ----
X     int args; /* Number of function arguments */
X     Operator op, op2;
X     Value va;
X!    char *ufname = NULL; /* Stop GCC from complaining about use of uninit var */
X     
X     OpBase = OpStackPtr;
X     ValBase = ValStackPtr;
X***************
X*** 366,372 ****
X              r = PushOpStack(f);
X              if (r) return r;
X  	    continue;  /* Still looking for an atomic vlue */
X! 	 } else if (!ISID(*ExprBuf) && *ExprBuf != '"' && *ExprBuf != '\'') {
X              Eprint("%s '%c'", ErrMsg[E_ILLEGAL_CHAR], *ExprBuf);
X  	    return E_ILLEGAL_CHAR;
X  	 } else { /* Must be a literal value */
X--- 366,373 ----
X              r = PushOpStack(f);
X              if (r) return r;
X  	    continue;  /* Still looking for an atomic vlue */
X! 	 } else if (!ISID(*ExprBuf) && *ExprBuf != '$' 
X! 	            && *ExprBuf != '"' && *ExprBuf != '\'') {
X              Eprint("%s '%c'", ErrMsg[E_ILLEGAL_CHAR], *ExprBuf);
X  	    return E_ILLEGAL_CHAR;
X  	 } else { /* Must be a literal value */
X***************
X*** 483,488 ****
X--- 484,500 ----
X        v->type = INT_TYPE;
X        v->v.val = len;
X        return OK;
X+    } else if (*s == '$') { /* A system variable */
X+      if (DebugFlag & DB_PRTEXPR)
X+         fprintf(ErrFp, "%s => ", s);
X+      r = GetSysVar(s+1, v);
X+    
X+      if (! (DebugFlag & DB_PRTEXPR)) return r;
X+      if (r == OK) {
X+         PrintValue(v, ErrFp);
X+ 	putc('\n', ErrFp);
X+      }
X+      return r;
X     } else /* Must be a symbol */
X       if (DebugFlag & DB_PRTEXPR)
X          fprintf(ErrFp, "%s => ", s);
X*** ../p6/funcs.c	Mon May  3 12:30:00 1993
X--- ./funcs.c	Fri Jul 16 15:23:44 1993
X***************
X*** 19,24 ****
X--- 19,25 ----
X  #endif
X  #include <string.h>
X  #include <ctype.h>
X+ #include <math.h>
X  #ifdef UNIX
X  #ifdef HAVE_UNISTD
X  #include <unistd.h>
X***************
X*** 58,63 ****
X--- 59,66 ----
X  PRIVATE	int	FDaysinmon	ARGS ((void));
X  PRIVATE	int	FDefined	ARGS ((void));
X  PRIVATE	int	FDosubst	ARGS ((void));
X+ PRIVATE	int	FEasterdate	ARGS ((void));
X+ PRIVATE	int	FFiledir	ARGS ((void));
X  PRIVATE	int	FFilename	ARGS ((void));
X  PRIVATE	int	FGetenv		ARGS ((void));
X  PRIVATE int     FHebdate	ARGS ((void));
X***************
X*** 67,77 ****
X--- 70,82 ----
X  PRIVATE	int	FHour		ARGS ((void));
X  PRIVATE	int	FIif		ARGS ((void));
X  PRIVATE	int	FIndex		ARGS ((void));
X+ PRIVATE	int	FIsdst		ARGS ((void));
X  PRIVATE	int	FIsomitted	ARGS ((void));
X  PRIVATE	int	FLanguage	ARGS ((void));
X  PRIVATE	int	FMax		ARGS ((void));
X  PRIVATE	int	FMin		ARGS ((void));
X  PRIVATE	int	FMinute		ARGS ((void));
X+ PRIVATE	int	FMinsfromutc	ARGS ((void));
X  PRIVATE	int	FMon		ARGS ((void));
X  PRIVATE	int	FMonnum		ARGS ((void));
X  PRIVATE	int	FOrd		ARGS ((void));
X***************
X*** 81,86 ****
X--- 86,93 ----
X  PRIVATE	int	FShell		ARGS ((void));
X  PRIVATE	int	FStrlen		ARGS ((void));
X  PRIVATE	int	FSubstr		ARGS ((void));
X+ PRIVATE	int	FSunrise	ARGS ((void));
X+ PRIVATE	int	FSunset		ARGS ((void));
X  PRIVATE	int	FTime		ARGS ((void));
X  PRIVATE	int	FTrigdate	ARGS ((void));
X  PRIVATE	int	FTrigtime	ARGS ((void));
X***************
X*** 100,105 ****
X--- 107,113 ----
X  PRIVATE int	FTrigger        ARGS ((void));
X  PRIVATE int	CheckArgs       ARGS ((Operator *f, int nargs));
X  PRIVATE int	CleanUpAfterFunc ARGS ((void));
X+ PRIVATE int	SunStuff	ARGS ((int rise, double cosz, int jul));
X  
X  #ifdef __MSDOS__
X  PRIVATE FILE *popen  ARGS((char *cmd, char *mode));
X***************
X*** 161,169 ****
X      {   "daysinmon",	2,	2,	FDaysinmon },
X      {   "defined",	1,	1,	FDefined },
X      {   "dosubst",	1,	3,	FDosubst },
X      {   "filename",	0,	0,	FFilename },
X      {   "getenv",	1,	1,	FGetenv },
X!     {   "hebdate",	2,	4,	FHebdate },
X      {   "hebday",	1,	1,	FHebday },
X      {   "hebmon",	1,	1,	FHebmon },
X      {   "hebyear",	1,	1,	FHebyear },
X--- 169,179 ----
X      {   "daysinmon",	2,	2,	FDaysinmon },
X      {   "defined",	1,	1,	FDefined },
X      {   "dosubst",	1,	3,	FDosubst },
X+     {   "easterdate",	1,	1,	FEasterdate },
X+     {	"filedir",	0,	0,	FFiledir },
X      {   "filename",	0,	0,	FFilename },
X      {   "getenv",	1,	1,	FGetenv },
X!     {   "hebdate",	2,	5,	FHebdate },
X      {   "hebday",	1,	1,	FHebday },
X      {   "hebmon",	1,	1,	FHebmon },
X      {   "hebyear",	1,	1,	FHebyear },
X***************
X*** 170,175 ****
X--- 180,186 ----
X      {   "hour",		1,	1,	FHour	},
X      {   "iif",		1,	NO_MAX,	FIif	},
X      {   "index",	2,	3,	FIndex 	},
X+     {   "isdst",	0,	2,	FIsdst },
X      {   "isleap",	1,	1,	FIsleap },
X      {   "isomitted",	1,	1,	FIsomitted },
X      {   "language",     0,      0,      FLanguage },
X***************
X*** 176,181 ****
X--- 187,193 ----
X      {   "lower",	1,	1,	FLower	},
X      {   "max",		1,	NO_MAX,	FMax	},
X      {   "min",		1,	NO_MAX, FMin	},
X+     {   "minsfromutc",	0,	2,	FMinsfromutc },
X      {   "minute",	1,	1,	FMinute },
X      {   "mon",		1,	1,	FMon	},
X      {   "monnum",	1,	1,	FMonnum },
X***************
X*** 188,193 ****
X--- 200,207 ----
X      {   "shell",	1,	1,	FShell	},
X      {   "strlen",	1,	1,	FStrlen	},
X      {   "substr",	2,	3,	FSubstr	},
X+     {   "sunrise",	0,	1,	FSunrise},
X+     {   "sunset",	0,	1,	FSunset },
X      {   "time",		2,	2,	FTime	},
X      {   "today",	0,	0,	FToday	},
X      {   "trigdate",	0,	0,	FTrigdate },
X***************
X*** 417,426 ****
X        it won't be destroyed */
X     DCOPYVAL(RetVal, ARG(1));
X  
X!    if (StriEq(s, "int")) return DoCoerce(INT_TYPE, &RetVal);
X!    else if (StriEq(s, "date")) return DoCoerce(DATE_TYPE, &RetVal);
X!    else if (StriEq(s, "time")) return DoCoerce(TIM_TYPE, &RetVal);
X!    else if (StriEq(s, "string")) return DoCoerce(STR_TYPE, &RetVal);
X     else return E_CANT_COERCE;
X  }
X  
X--- 431,440 ----
X        it won't be destroyed */
X     DCOPYVAL(RetVal, ARG(1));
X  
X!    if (! StrCmpi(s, "int")) return DoCoerce(INT_TYPE, &RetVal);
X!    else if (! StrCmpi(s, "date")) return DoCoerce(DATE_TYPE, &RetVal);
X!    else if (! StrCmpi(s, "time")) return DoCoerce(TIM_TYPE, &RetVal);
X!    else if (! StrCmpi(s, "string")) return DoCoerce(STR_TYPE, &RetVal);
X     else return E_CANT_COERCE;
X  }
X  
END_OF_FILE
  if test 38731 -ne `wc -c <'patch.07.A'`; then
    echo shar: \"'patch.07.A'\" unpacked with wrong size!
  elif test -f 'patch.07.B' && test -f 'patch.07.C'; then
    echo shar: Combining  \"'patch.07'\" \(117693 characters\)
    cat 'patch.07.A' 'patch.07.B' 'patch.07.C' > 'patch.07'
    if test 117693 -ne `wc -c <'patch.07'`; then
      echo shar: \"'patch.07'\" combined with wrong size!
    else
      rm patch.07.A patch.07.B patch.07.C
    fi
  fi
  # end of 'patch.07.A'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
