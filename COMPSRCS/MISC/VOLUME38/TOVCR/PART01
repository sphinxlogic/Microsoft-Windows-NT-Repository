Newsgroups: comp.sources.misc
From: nuevos@hp400.ccu.uniovi.es (Raul y Quique)
Subject: v38i057:  tovcr - Record/Display images into the Video Frame, Part01/04
Message-ID: <csm-v38i057=tovcr.093829@sparky.Sterling.COM>
X-Md4-Signature: d3612c61ba6e335d0bacc2cccda9f103
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 14:39:50 GMT
Approved: kent@sparky.sterling.com

Submitted-by: nuevos@hp400.ccu.uniovi.es (Raul y Quique)
Posting-number: Volume 38, Issue 57
Archive-name: tovcr/part01
Environment: SGI

tovcr is a program to show/record into a video deck using the SGI's Video 
FRamer and V-lan controlled hardware.

We had a problem, a great problem, in our Dept. when we began to record 
frames into our Betacam, the time !!!. An uncompressed image spent 40 
seconds to be recorded ( wow ! ), and this is inacceptable if you have
500 frames. 

tovcr supports several image file formats and it's very fast ( now we
need 8 seconds to record a COMPRESSED frame ).

Currently file formats supported:

	i.	 Alias "pix"
	ii.	Wavefront's RLA
	iii.	URT's RLE (*)
	iv.	Aldus' TIFF (*)
	v.	SGI's internal RGB
	vi.	Trevision's TARGA
	vii.	Compuserve's GIF
	viii.	ZSoft's PCX
	ix.	JPEG (*)
	x.	PBM/PGM/PPM

Also, it has impleted a few digital image effects:

	i.	resample
	ii.	blur
	iii.	chroma
	iv.	paste

Refer to manual pages for more information.

Raul Rivero
Mathematics Dept.
University of Oviedo
( nuevos@carreras.ccu.uniovi.es )
------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README README.code tovcr.1 tovcr.c.A
# Wrapped by kent@sparky on Sun Jul 11 19:05:24 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 4)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(1977 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X
X'tovcr' is a program to show/record into a video deck using the SGI's Video 
XFRamer and V-lan controlled hardware.
X
XWe had a problem, a great problem, in our Dept. when we began to record 
Xframes into our Betacam, the time !!!. An uncompressed image spent 40 
Xseconds to be recorded ( wow ! ), and this is inacceptable if you have
X500 frames. 
X
X'tovcr' supports several image file formats and it's very fast ( now we
Xneed 8 seconds to record a COMPRESSED frame ).
X
XCurrently file formats supported:
X
X	i.	 Alias "pix"
X
X	ii.	Wavefront's RLA
X
X	iii.	URT's RLE (*)
X
X	iv.	Aldus' TIFF (*)
X
X	v.	SGI's internal RGB
X
X	vi.	Trevision's TARGA
X
X	vii.	Compruserve's GIF
X
X	viii.	ZSoft's PCX
X
X	ix.	JPEG (*)
X
X	x.	PBM/PGM/PPM
X
X
XAlso, it has impleted a few digital image effects:
X
X	i.	resample
X
X	ii.	blur
X
X	iii.	chroma
X
X	iv.	paste
X
X
XRefer to manual pages for more information.
X
X
X'tovcr' was derived from the LUG Library ( Libreria de Utilidades Graficas,
XGraphic Utilities Library ). LUG supports more file formats, viewers on the
Xmost important architectures and too much digital image editing ( but not 
Xnecessaries here ). You can get a copy from telva.ccu.uniovi.es ( 156.35.31.31,
X/pub/uniovi/mathdept/lug-1.0.tar.Z ).
X
X
X(*)
X        This is supported if you have the:
X
X                - Utah Raster Toolkit by Spencer W. Thomas
X                        princeton.edu           /pub/Graphics/urt
X                        telva.ccu.uniovi.es     /pub/graphics/Image/urt*
X
X                - LibTIFF by Sam Leffler
X                        sgi.com                 /pub/sgi/libtiff/libtiff*
X                        telva.ccu.uniovi.es     /pub/graphics/Image/libtiff*
X
X                - LibJPEG by THomas G. Lane
X                        ftp.uu.net              /graphics/jpeg/jpeg*
X			telva.ccu.uniovi.es	/pub/graphics/Image/jpeg/jpeg*
X
X        ... and check the paths of the Makefile.
X
XThanks to all them.
X
X-----
XRaul Rivero
XMathematics Dept.
XUniversity of Oviedo
X( nuevos@carreras.ccu.uniovi.es )
END_OF_FILE
  if test 1977 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'README.code' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.code'\"
else
  echo shar: Extracting \"'README.code'\" \(3357 characters\)
  sed "s/^X//" >'README.code' <<'END_OF_FILE'
X
XYou must read this file if you wanna understand the code of the 
Xprogram.
X
XFirst of all, the program has been configured to the PAL system. This
Xis controlled when you open the connection with the video framer
X( the 'open_video' subroutine ), two #define fix these names ( 
XDEFAULT_VFR_BUFFER and OPTIONAL_VFR_BUFFER ), our default buffer name
Xis "r_y_625" ( Betacam ) and optional is "rgb_625". You need change
Xthis if you use another video system.
X
XIf you change the system, also probably you need change the XSIZE and
XYSIZE defines. These fix the size of the image. Our render program sets
Xa size of 780x576 for the PAL system, but when we recorded that image 
Xinto the Betacam it was cuted ( you get it ?, the image, not the 
XBetacam ). So, we applied proof and error and fix 'our' PAL system
Xsize to 710x576. So if you change the video norm ...
X
XIn the PAL system, we have 25 frames per second but in NTSC there are
X30 f.p.s. So you need change the FPS define ( PAL => 24, NTSC => 29, 
Xthe last frame, not the number of frames ).
X
XThere is another important define, CHROMABORDER. It is what the 
Xprogram understand as transparent ( from 0 to CHROMABORDER, where this
Xnumber is r+g+b ).
X
XThe program works whit compressed files but it's very important how
Xyou ( well, the program ) uncompressed it. There are two procces
Xworking:
X
Xi.	
X	The parent process handles the video recorder. When a frame
X	has been recorded, it sends a signal to the child ( then a new
X	image can be loaded into the VFR ), release a new child and
X	waits for the first child to record that frame.
X
Xii.	
X	The child process gets ready and load a new frame into VFR 
X	( when the parent process allows it ).
X
X
X, and now is when how you uncompress the file is very important. If
Xyou use a system(...) library subroutine to execute the uncompress
Xprocess what you really get is something like:
X
X		if ( fork() )
X			wait( NULL );
X		else exe...( "uncompress", ... );
X
Xso, the child is wait-ing. Now the problem: if the child is wait-ing
Xwhen the pattern sends a signal ( and altough this is catched ) the
Xwait is released ( but the uncompress isn't finished !!! ). The 
Xsolution is the 'Uncompress' subroutine of the program, the child 
Xwaits for the end of the uncompress process and only is released by
Xthis. Ok ? ( so, if you use another subroutine to uncompress files,
Xplease check this or you can get a 'beatiful' core ).
X
XBetter algorithms could be implemented for some digital editing
Xfunctions ( examples: blur and resample ) but what we wanna was
Xspeed ( when you have 500 frames, well ... the speed of the program
Xis the most important thing ). But if you can do better ...
X
XAlso, some supported file format readers could be improved.
X
XWell, you know, nothing is perfect and I'll wait your comments.
X
XThe code has a lot of comments, so you can refer to it for further
Xexplanations.
X
X
XWhen we record an animation, we always need something different: a
Xmoving background, a super, a blur with a mask, etc. So we always
Xchange the code of tovcr, but this is the base. It's too easy adapt
Xit for what we need. You get it ?, it's too important understand the
Xcode because it's not a closed utility.
X
X
XPlease, mail me if you have some question, suggestion, you find
Xa bug, etc ...
X
X
XEnjoy !.
X
X-----
XRaul Rivero
XMathematics Dept.
XUniversity of Oviedo
X( nuevos@carreras.cuu.uniovi.es )
END_OF_FILE
  if test 3357 -ne `wc -c <'README.code'`; then
    echo shar: \"'README.code'\" unpacked with wrong size!
  fi
  # end of 'README.code'
fi
if test -f 'tovcr.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tovcr.1'\"
else
  echo shar: Extracting \"'tovcr.1'\" \(3635 characters\)
  sed "s/^X//" >'tovcr.1' <<'END_OF_FILE'
X.\"
X.\" tovcr's man pages.
X.\" Copyright (c) 1992, University of Oviedo and Raul Rivero.
X.\"
X.TH tovcr 1 "Mon Aug 17 1992" 1
X.UC 4
X.SH NAME
Xtovcr \- Record/Display images into the Video Frame.
X.SH SYNOPSIS
X.B tovcr
X[
X.B \-vcrisntuwgjpafx\!
X]
X.I inputfile
X[
X.I inputfile
X]
X.TP
X.B tovcr
X[
X.B \-vcrisntuwgjpafx\!
X]
X.I incode number_of_frames inputfile
X[
X.I inputfile
X[...] ]
X.TP
X.B tovcr
X[
X.B \-vcrisntuwgjpafx\!
X]
X.I incode start end inputfile
X[
X.I inputfile
X[...] ]
X.SH DESCRIPTION
XThis program show/record images into the Video Framer with
Xhigher speed than original utilities. Also, you can use compressed (
X.IR compress (1)
X) files, a lot of supported formats, composition and other facilities.
X.PP
XFirst use format load images into the Video Framer, no record.
X.PP
XSecond format load and record the given frame
X.I number_of_frames
Xtimes into the video recorder ( by example if you use the PAL system
Xyou need 25 to record one second this frame ).
X.PP
XThe last format is used in animation, you have several frames
X( starting at
X.I start
Xand ending at
X.I end
X) being numbered
X.I inputfile\.number[.Z].
XDuration per frame will be 1/25 seconds.
X.PP
XIf you give several sequences ( names ), the first of all will
Xbe the basea and the rest will be pasted over as a chroma ( be careful
Xwith the \fItransparent\fP color ).
X.PP
XThe size of frames has been fixed to
X.I 710x576
Xpixels. This is a valid format to \fIR-Y\ 625\fP ( \fIBetacam's\ PAL\fP ).
XSo, it's possible you need change this values if you use other video
Xformat.
X.SH OPTIONS
X.TP
X.B \-v
XVerbose output.
X.TP
X.B \-b
XBlur the goal image before download to the Video Framer.
X.TP
X.B \-c
XCenter the image, will be not adjusted to the internal given
Xresolution. By default, the image will be \fIresampled\FP if
Xits size is not equal to that format, and the image will cover
Xall area of the video display.
X.TP
X.B \-r
XThe output buffer will be configured to rgb_625 ( internally invoques
Xnext option ).
X.TP
X.B \-i
XReset the Video Framer and, by default, the r_y_625 format is
Xconfigured. It's necesary if you had used another format ( by exmaple
Xif previous option had been used ).
X.TP
X.B \-s
XBefore the requested image will be loaded into the Video Framer
Xbuffer, an \fIsuper\fP will be layed over it. Really, the super
Xis another image fixed intermally ( you would get this efect if
Xyou would give that name as the last parameter ).
X.TP
X.B \-n
XIf the size of the input image was lower than the required then
Xit will be \fIresampled\fP and a \fIblur\fP effect will be aplied ( not 
Xif the size it's greater ).
X.TP
X.B \-t
XInput file format will be TIFF.
X.TP
X.B \-u
XInput file format will be the Utah's Univ. RLE.
X.TP
X.B \-w
XInput file format will be the Wavefront's RLA.
X.TP
X.B \-g
XInput file format will be the internal SGI format.
X.TP
X.B \-a
XInput file format will be Targa.
X.TP
X.B \-f
XInput file format will be the Compuserve's GIF
X.TP
X.B \-x
XInput file format will be ZSoft's PCX.
X.TP
X.B \-j
XInput file format will be JPEG.
X.TP
X.B \-p
XInput file format will be the Jef Poskanzer's PBM/PGM/PPM
X.TP
X.B \-!
XWhat about this program ?!.
X.SH WARNING
XThis version had been configured to the PAL system. If you use
Xother system you need change \fIadd_incode\fP and the name of
Xthe Video Framer buffer.
X.PP
XIf you get the message \fIEditing aborted\fP, don't worry. You
Xcan continue from the last frame recorded. It appears as 
Xthe V-Lan could not synchronize with the video recorder. I don't
Xknow why.
X
X.SH SEE ALSO
X.IR lug (3G),
X.I Videoframer\ Programers\ Manual,
X.IR urt (1),
X.IR tiff (1),
X.IR jpeg (1),
X.IR pbm (1).
X.SH AUTHOR
XRaul Rivero, Mathematics Department, University of Oviedo.
END_OF_FILE
  if test 3635 -ne `wc -c <'tovcr.1'`; then
    echo shar: \"'tovcr.1'\" unpacked with wrong size!
  fi
  # end of 'tovcr.1'
fi
if test -f 'tovcr.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tovcr.c.A'\"
else
  echo shar: Extracting \"'tovcr.c.A'\" \(45778 characters\)
  sed "s/^X//" >'tovcr.c.A' <<'END_OF_FILE'
X/*
X * This software is copyrighted as noted below.  It may be freely copied,
X * modified, and redistributed, provided that the copyright notice is
X * preserved on all copies.
X *
X * There is no warranty or other guarantee of fitness for this software,
X * it is provided solely "as is".  Bug reports or fixes may be sent
X * to the author, who may or may not act on them as he desires.
X *
X * You may not include this software in a program or other software product
X * without supplying the source, or without informing the end-user that the
X * source is available for no extra charge.
X *
X * If you modify this software, you should include a notice giving the
X * name of the person performing the modification, the date of modification,
X * and the reason for such modification.
X */
X/*
X * tovcr.c - display/record images on a Video Recorder using the SGI VFR.
X *
X * Author:      Raul Rivero
X *              Mathematics Dept.
X *              University of Oviedo
X * Date:        Mon Aug 17 1992
X * Copyright (c) 1992, Raul Rivero
X *
X */
X/*
X * Revisions:
X *
X * 1.1
X *      Raul Rivero
X *      Mathematics Dept.
X *      University of Oviedo
X *      Mon May 17 1993
X *      ( nuevos@carreras.ccu.uniovi.es )
X *
X *      i.  New file formats supported ( JPEG, PBM/PGM/PPM, 24bits-PCX ).
X *      ii. Some little fixes.
X *
X * -----
X */
X
X#include <stdio.h>
X#include <math.h>
X#include <signal.h>
X#include <string.h>
X#include <sys/types.h>
X#include <sys/wait.h>
X#include <sys/stat.h>
X#include "image.h"
X#include "vframer.h"
X
X#ifdef iTIFF
X#   include "tiffio.h"
X#   define GetField(h, t, v)       if ( !TIFFGetField(h, t, v ) ) error(18);
X#endif  /* iTIFF */
X
X#ifdef iRLE
X#   include "rle.h"
X#   define PSEUDOCOLOR             1
X#   define DIRECTCOLOR             2
X#   define TRUECOLOR               3
X#   define GRAYSCALE               4
X#endif  /* iRLE */
X
X#ifdef iJPEG
X#   include <jinclude.h>
X#endif  /* iJPEG */
X
X/*
X * The magic flag.
X */
X#define LUGUSED                     12345   /* why not ? */
X
X#define byte                        unsigned char
X#define ushort                      unsigned short
X#define Fread(p, s, n, f)           if ( fread(p, s, n, f) != n ) error(3)
X#define Fwrite(p, s, n, f)          if ( fwrite(p, s, n, f) != n ) error(4)
X#define VPRINTF                     if (verbose) fprintf
X#define VFLUSH                      if (verbose) fflush
X#define NOBLUR                      0
X#define BLUR                        1
X#define CHROMABORDER                20
X#define PREROLLTIME                 "3:00"
X#define POSTROLLTIME                "1:00"
X#define AUTOINCREMENT               1
X
X/*
X * This is the name of the 'super' image. Be careful with
X * the file format.
X */
X#define SUPERNAME                   "/usr/a3demo/bin/fuentes/super"
X
X/* More esasy */
X#define equal(s, t)                 ( strstr(s,t) != NULL ? 1 : 0 )
X
X/*
X * ==========================================
X *  REMEMBER!!!
X *      I'm working with R-Y PAL, but you ?.
X * ==========================================
X *
X * Be careful with the next 3 blocks of defines !!!.
X */
X
X/*
X * The image will be adjusted to ...
X *
X */
X#define XFBUFFER                    780
X#define YFBUFFER                    576
X#define XSIZE                       710
X#define YSIZE                       576
X#define VFR_LINESIZE                1024
X
X/*
X * Video FRamer default buffer names.
X */
X#define DEFAULT_VFR_BUFFER          "r_y_625"
X#define OPTIONAL_VFR_BUFFER         "rgb_625"
X
X/*
X * Last frame into SMPTE ( PAL has 25 frames per
X * second ==> 24 ).
X */
X#define FPS                         24
X
X/*
X * TGA's defines.
X */
X#define TGAINTERLACED(a)            ( (a) & 0xc0 )
X#define TGAFLIP(a)                  ( ((a) & 0x20) ? 0 : 1)
X#define TGA_MAPPED                  1
X#define TGA_RGB                     2
X#define TGA_RLE_MAPPED              9
X#define TGA_RLE_RGB                 10
X
X/*
X * GIF's defines.
X */
X#define GIFHEADER                   "GIF87a"
X#define GIFIMGSEPAR                 ','
X#define ENDGIF                      ';'
X#define GIFEXISTCOLOR               (1 << 7)
X#define GIFINTERLAZE                (1 << 6)
X
X/*
X * PCX's defines
X */
X#define PCX_HEADERSIZE              128
X#define PCX_MAGICNUMBER             0x0a
X#define PCX_256COLORS               0x0c
X#define PCX_COMPRESS                0xc0
X
X#ifdef USE_STDLIB_H
X#   include <stdlib.h>
X#else
X#   ifdef VOID_STAR
X        extern void *malloc();
X#   else
X        extern char *malloc();
X#   endif /* VOID_STAR */
X    extern void free();
X#endif /* USE_STDLIB_H */
X
X#ifndef BSD
X#   define bzero(s, n)             memset((s), 0, (n))
X#   define bcopy(f, t, c)          memcpy((t), (f), (c))
X#endif /* BSD */
X
X/*
X * Pointer to funtions.
X */
Xtypedef int (* ifunptr)();
X
X/*
X * My bitmap header.
X */
Xtypedef struct {
X        int xsize, ysize;
X        int depth;
X        int colors;
X        byte *r, *g, *b;
X        byte *cmap;
X        int magic;
X} bitmap_hdr;
X
X/*
X * Wavefront's RLA format headers.
X */
Xtypedef struct {
X   short left, right, bottom, top;
X} WINDOW_S;
X
Xtypedef struct {
X   WINDOW_S     window;
X   WINDOW_S     act_window;
X   short        frame;
X   short        storage_type;
X   short        num_chan;
X   short        num_matte;
X   short        num_aux;
X   short        aux_mask;
X   char         gamma[16];
X   char         red_pri[24];
X   char         green_pri[24];
X   char         blue_pri[24];
X   char         white_pt[24];
X   long         job_num;
X   char         name[128];
X   char         desc[128];
X   char         program[64];
X   char         machine[32];
X   char         user[32];
X   char         date[20];
X   char         aspect[32];
X   char         chan[32];
X   char         space[128];
X} RLA_HEADER;
X
X/*
X * Targa header.
X */
Xtypedef struct {
X        byte   num_id;
X        byte   cmap_type;
X        byte   image_type;
X        ushort cmap_orign;
X        ushort cmap_length;
X        byte   cmap_entry_size;
X        ushort xorig, yorig;
X        ushort xsize, ysize;
X        byte   pixel_size;
X        byte   image_descriptor;
X} tga_hdr;
X
X/*
X * Alias header.
X */
Xtypedef struct {
X        short xsize, ysize;
X        short xinit, yinit;
X        short depth;
X} alias_hdr;
X
Xtypedef byte color_map[3];
X
X/*
X * Prototypes ( only what is necesary ).
X */
XFILE *Fopen();
Xchar *Malloc();
Xlong filelen();
Xchar *read_file();
Xbyte *create_bw_pallete();
Xbyte *zoom();
Xbyte *blur();
Xint fparent_ready();
Xint fchild_ready();
XVFR_DEV *open_video();
Xint vfr_not_ready();
Xint error_from_other();
Xint press_break();
Xchar *Vfr_Vlan_Cmd();
Xbyte *shorttobyte();
Xbyte *read_gif_screen_hdr();
Xbyte *read_gif_image_hdr();
Xbyte *unblockgif();
Xbyte *flip();
X#ifdef iJPEG
X    void get_jpeg_header();
X    void get_jpeg_cmap();
X    void get_jpeg_row();
X    void end_put_jpeg();
X    void d_ui_method_selection();
X#endif  /* iJPEG */
X
X/*
X * This pointer contents the funtion to read the
X * input image file format.
X */
Xifunptr read_image;
X
X/*
X * Current formats supported.
X */
Xint read_alias_file();
Xint read_rla_file();
Xint read_sgi_file();
Xint read_tga_file();
Xint read_gif_file();
Xint read_pcx_file();
Xint read_pbm_file();
X#ifdef iTIFF
X    int read_tiff_file();
X#endif
X#ifdef iRLE
X    int read_rle_file();
X#endif
X#ifdef iJPEG
X    int read_jpeg_file();
X#endif
X
X/*
X * The name of the program and an auxiliar file name
X * to uncompress input file ( if compressed ).
X */
Xchar *MY_NAME;
Xchar aux_file[40];
X
X/* Used by the GIF reader */
Xint lug_read_code_position;
X
X/* Used by the JPEG reader */
X#ifdef iJPEG
X    static bitmap_hdr *jpeg_image;
X    byte *jpeg_r, *jpeg_g, *jpeg_b;
X#endif  /* iJPEG */
X
X/* IDs for child and parent process */
Xint cpid, parent_pid;
X
X/* We'll simulate semaphores with ... */
Xint child_ready, parent_ready;
X
X/*
X * Flags ...
X */
Xint verbose = 0;
Xint super = 0;
Xint center = 0;
Xint resetvfr = 0;
Xint rgbvfr = 0;
Xint blurflag = 0;
Xint record_sequence = 0;
Xint forceblur = 0;
X
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X  register int i;
X  char *inpoint;
X  int start, end;
X
X  MY_NAME = argv[0];
X  parent_pid = getpid();
X
X  /* Default is Alias "pix" format */
X  read_image = read_alias_file;
X
X  /*
X   * Get options ( some day I'll build a procedure ).
X   */
X  if ( argc > 1 ) {             /* else core on SGI */
X   while ( argv[1][0] == '-' ) {
X      for ( i = 1; argv[1][i]; i++ ) {
X        switch ( argv[1][i] ) {
X          case 'v':
X                verbose++;
X                break;
X          case 'b':
X                forceblur++;
X                break;
X          case 'c':
X                center++;
X                break;
X          case 's':
X                super++;
X                break;
X          case 'i':
X                resetvfr++;
X                break;
X          case 'r':
X                rgbvfr++;
X                resetvfr++;
X                break;
X          case 'n':
X                blurflag++;;
X                break;
X#ifdef iTIFF
X          case 't':
X                read_image = read_tiff_file;
X                break;
X#endif
X#ifdef iRLE
X          case 'u':
X                read_image = read_rle_file;
X                break;
X#endif
X#ifdef iJPEG
X          case 'j':
X                read_image = read_jpeg_file;
X                break;
X#endif
X          case 'w':
X                read_image = read_rla_file;
X                break;
X          case 'g':
X                read_image = read_sgi_file;
X                break;
X          case 'a':
X                read_image = read_tga_file;
X                break;
X          case 'f':
X                read_image = read_gif_file;
X                break;
X          case 'x':
X                read_image = read_pcx_file;
X                break;
X          case 'p':
X                read_image = read_pbm_file;
X                break;
X          case '!':
X                print_copyright();
X                break;
X          default :
X                error( 0 );
X                break;
X        }
X      }
X      argv++;
X      argc--;
X    }
X  }
X
X  if ( argc < 2 )
X    error( 0 );
X
X  /* Skip the command name */
X  argv++;
X
X  /*
X   * Auxiliar file name where uncompress images if
X   * it's necesary.
X   */
X  sprintf(aux_file, "/usr/tmp/spix%d", parent_pid);
X
X  if ( is_a_incode( *argv ) ) {
X    /*
X     * We wanna record frames, so we read the incode.
X     */
X    inpoint = *argv++;
X    start = Atoi( *argv++ );
X    if ( isnumber( *argv ) ) {
X      /*
X       * Hey!, it's a number. Ok, we wanna record a
X       * sequence of animated frames.
X       */
X      record_sequence++;
X      end = Atoi( *argv++ );
X      /* Number of images to fade */
X      i = argc - 4;
X    }else {
X      /*
X       * We wanna record only a frame.
X       */
X      end = start;
X      i = argc - 3;
X    }
X
X    /*
X     * Ok, all ready ...
X     */
X    to_video( inpoint, start, end, i, argv );
X  }else {
X    /*
X     * What we wanna is display a image into the VFR, don't
X     * record it.
X     */
X    show_vfr_image( argv, argc - 1 );
X  }
X
X  rm_compress();
X}
X
Xshow_vfr_image( original_names, no_frames )
Xchar **original_names;
Xint no_frames;
X{
X  register int i;
X  VFR_DEV *vfr;
X  bitmap_hdr outbitmap;
X  ifunptr save_read_interface;
X
X  /*
X   * Connect with VFR interface.
X   */
X  vfr = ( VFR_DEV *) open_video();
X
X  /*
X   * Create the background image.
X   */
X   create_solid_image( &outbitmap, XFBUFFER, YFBUFFER, 0, 0, 0 );
X
X   /*
X    * Load all the imames.
X    */
X   for ( i = 0; i < no_frames; i++ ) {
X     add_image( &outbitmap, original_names[i], center );
X   }
X
X   if ( super ) {
X     /*
X      * Glue the super to end image ( but we need use
X      * Alias interface ).
X      */
X     save_read_interface = read_image;
X     read_image = read_alias_file;
X     add_image( &outbitmap, SUPERNAME, 0 );
X     /* Restores old interface */
X     read_image = save_read_interface;
X   }
X
X   /*
X    * Outbitmap is the new image.
X    */
X   write_vfr( vfr, &outbitmap );
X   freebitmap( &outbitmap );
X}
X
Xto_video( inpoint, start, end, no_frames, original_names )
Xchar *inpoint, **original_names;
Xint start, end, no_frames;
X{
X  register int i;
X  VFR_DEV *vfr;
X  int point[4];
X  char *buffer_names[20];
X  char **frames_names;
X  int autoincrement;
X
X  /*
X   * Connect with VFR interface.
X   */
X  vfr = ( VFR_DEV *) open_video();
X
X  /*
X   * Caugth errors from child and interrupt key.
X   */
X  signal( SIGINT, press_break );
X
X  /* Convert inpoint to numbers */
X  convert_inpoint( inpoint, point );
X
X  if ( record_sequence ) {
X    /*
X     * We have a sequence of frames, so we'll build each
X     * name ( and need memory ) ...
X     */
X    frames_names = buffer_names;
X    malloc_names( no_frames, original_names, frames_names);
X    creat_names( no_frames, original_names, frames_names, start );
X    /* Time for each frame */
X    autoincrement = AUTOINCREMENT;
X  }else {
X    /* Use original names */
X    frames_names = original_names;
X    /* Time for the frame */
X    autoincrement = start;
X  }
X
X  /*
X   * Child can build the image.
X   */
X  cpid = release_child( vfr, no_frames, frames_names );
X
X  /*
X   * Initialize the VLAN.
X   */
X  init_vlan( vfr, inpoint, autoincrement );
X  /*
X   * Now the child can put the image into VFR.
X   */
X  unlock_vfr( cpid );
X
X  for ( i = start; i <= end; i++ ) {
X    /* Check if the video are ready, PAUSE */
X    check_point( vfr );
X    /* Wait for child ( the child put the image into the VFR ) */
X    wait_for_children( cpid );
X    /* PerForm */
X    (void)Vfr_Vlan_Cmd( vfr, "PF" );
X    write_current_frame( point, i );
X    if ( i != end ) {
X      /* Not the end, so creat next names */
X      creat_names( no_frames, original_names, frames_names, i+1 );
X      cpid = release_child( vfr, no_frames, frames_names );
X    }
X    /* Check if the video perform the record */
X    check_status( vfr );
X    /*
X     * If the video record the last frame then child
X     * can put current image into VFR.
X     */
X    unlock_vfr( cpid );
X  }
X
X  if ( record_sequence ) {
X    free_names( no_frames, frames_names );
X  }
X}
X
Xrelease_child ( vfr, no_frames, frames_names )
XVFR_DEV *vfr;
Xint no_frames;
Xchar **frames_names;
X{
X  bitmap_hdr outbitmap;
X  ifunptr save_read_interface;
X  int pid;
X  int i;
X
X  child_ready = parent_ready = 0;
X
X  switch( pid = fork() ) {
X    case -1 :
X              /*
X               * fork() cannot respawn.
X               */
X              error( 13 );
X              break;
X    case  0 :
X              signal( SIGUSR1, fparent_ready );
X              signal( SIGUSR2, error_from_other );
X              /*
X               * Create the background image.
X               */
X              create_solid_image( &outbitmap, XFBUFFER, YFBUFFER, 0, 0, 0 );
X
X              /*
X               * Load all the images.
X               */
X              for ( i = 0; i < no_frames; i++ ) {
X                add_image( &outbitmap, frames_names[i], center );
X              }
X
X              if ( super ) {
X                /*
X                 * Glue the super to end image ( but we need use
X                 * Alias interface ).
X                 */
X                save_read_interface = read_image;
X                read_image = read_alias_file;
X                add_image( &outbitmap, SUPERNAME, 0 );
X                /* Restores old interface */
X                read_image = save_read_interface;
X              }
X
X              /*
X               * Wait for parent.
X               */
X              /*if ( !parent_ready )
X                pause();*/
X              while ( !parent_ready );
X
X              /*
X               * Outbitmap is the new image. We'll use last argument
X               * as file name.
X               */
X              write_vfr( vfr, &outbitmap );
X              freebitmap( &outbitmap );
X
X              /*
X               * This is the end of the child so report it to
X               * the parent.
X               */
X              exit( 0 );
X              break;
X    default:
X              signal( SIGUSR2, error_from_other );
X              return pid;
X              break;
X  }
X}
X
Xadd_image( base, filename, flag )
Xbitmap_hdr *base;
Xchar *filename;
Xint flag;
X{
X  bitmap_hdr inbitmap;
X  bitmap_hdr palbitmap;
X
X  /*
X   * Read the image.
X   */
X  read_image( filename, &inbitmap );
X
X  /*
X   * Adjust file to PAL and glue it to end image.
X   */
X  if ( !flag ) {
X    adjust( &inbitmap, &palbitmap, XSIZE, YSIZE, blurflag );
X    chroma( base, &palbitmap );
X  }else center_image( base, &inbitmap );
X
X  /*
X   * Free buffers.
X   */
X  freebitmap( &inbitmap );
X  if( flag )
X    freebitmap( &palbitmap );
X}
X
X
X/**************************************
X *
X * SMPTE code handlers.
X *
X */
Xcalculate_outpoint( inpoint, outpoint, totalframes )
Xchar *inpoint;
Xchar *outpoint, totalframes;
X{
X  register int i;
X  int point[4];
X
X  /* Convert inpoint to numbers */
X  convert_inpoint( inpoint, point );
X
X  /* Calculate the outpoint */
X  for ( i = 0; i < totalframes; i++ )
X    add_incode( point );
X
X  /* Convert outpoint numbers to a SMTPE format code */
X  sprintf ( outpoint, "%.2d:%.2d:%.2d:%.2d\n",
X            point[0], point[1], point[2], point[3] );
X}
X
Xis_a_incode( inpoint )
Xchar *inpoint;
X{
X  int marks = 0;
X
X  while ( *inpoint )
X    if ( *inpoint++ == ':' )
X      marks++;
X
X  return( marks == 3 );
X}
X
Xconvert_inpoint( inpoint, point )
Xchar *inpoint;
Xint *point;
X{
X  sscanf( inpoint, "%d:%d:%d:%d", &point[0], &point[1],
X                                  &point[2], &point[3] );
X
X  if (  point[0] <  0 || point[1] <  0 || point[2] <  0 || point[3] < 0 ||
X        point[0] > 23 || point[1] > 59 || point[2] > 59 || point[3] > FPS )
X    error( 14 );
X}
X
Xwrite_current_frame( point, frame )
Xint *point;
Xint frame;
X{
X#if AUTOINCREMENT > 1
X  register int i;
X#endif
X
X  if ( record_sequence ) {
X    fprintf ( stdout, "Recording frame %d on %.2d:%.2d:%.2d:%.2d\n", frame,
X              point[0], point[1], point[2], point[3] );
X  }else {
X    fprintf ( stdout, "Recording frame on %.2d:%.2d:%.2d:%.2d\n",
X              point[0], point[1], point[2], point[3] );
X  }
X
X  /*
X   * If AUTOINCREMENT is greater than one then we need add more
X   * frames to the current, else we can skip this loop.
X   */
X#if AUTOINCREMENT > 1
X  for ( i = 0; i < AUTOINCREMENT; i++ )
X#endif
X    add_incode( point );
X}
X
Xadd_incode( point )
Xint *point;
X{
X  if ( point[3] == FPS ) {
X    point[3] = 0;
X    if ( point[2] == 59 ) {
X      point[2] = 0;
X      if ( point[1] == 59 ) {
X        point[1] = 0;
X        point[0]++;
X      }else point[1]++;
X    }else point[2]++;
X  }else point[3]++;
X}
X
X
X/**************************************
X *
X * File names builders.
X *
X */
Xmalloc_names( no_frames, original_names, frames_names )
Xint no_frames;
Xchar **original_names, **frames_names;
X{
X  register int i;
X
X  /* Allocate memory to sequence names */
X  for ( i = 0; i < no_frames; i++ ) {
X    frames_names[i] = (char *) Malloc( strlen(original_names[i] ) + 10 );
X  }
X}
X
Xcreat_names( no_frames, original_names, frames_names, current_frame )
Xint no_frames, current_frame;
Xchar **original_names, **frames_names;
X{
X  register int i;
X
X  /* Creat the names of frames */
X  for ( i = 0; i < no_frames; i++ ) {
X    sprintf( frames_names[i], "%s.%d", original_names[i], current_frame );
X  }
X}
X
Xfree_names( no_frames, frames_names )
Xint no_frames;
Xchar **frames_names;
X{
X  register int i;
X
X  /* Free sequence names */
X  for ( i = 0; i < no_frames; i++ ) {
X    Free( frames_names[i] );
X  }
X}
X
X
X/**************************************
X *
X * Signal handlers.
X *
X */
Xvfr_not_ready()
X{
X  /*
X   * The alarm has been actived, the VFR doesn't respond.
X   */
X  error( 15 );
X}
X
Xerror_from_other()
X{
X  /*
X   * The other process had an error.
X   */
X  exit( 1 );
X}
X
Xunlock_vfr( cpid )
Xint cpid;
X{
X  /*
X   * Child can put image into VFR.
X   */
X  kill( cpid, SIGUSR1 );
X}
X
Xwait_for_children( cpid )
Xint cpid;
X{
X  int rpid;
X  int status;
X
X  /*
X   * The parent are ready, but the child ?.
X   */
X
X  rpid = wait( &status );
X  if ( ! WIFEXITED( status ) )
X    error( 16 );
X  signal( SIGUSR2, SIG_DFL );
X}
X
Xpress_break()
X{
X  /*
X   * User press break, so we need kill
X   * child ( if exist ).
X   */
X  if ( getpid() == parent_pid ) {
X    kill( cpid, SIGKILL );
X  }
X
X  rm_compress();
X  exit( 0 );
X}
X
Xfparent_ready()
X{
X  parent_ready = 1;
X  signal( SIGUSR1, fparent_ready );
X}
X
Xfchild_ready()
X{
X  child_ready = 1;
X  signal( SIGUSR1, fchild_ready );
X}
X
X
X/**************************************
X *
X * Digital Image Editing procedures.
X *
X */
Xadjust(inbitmap, outbitmap, newx, newy, noblur)
Xbitmap_hdr *inbitmap;
Xbitmap_hdr *outbitmap;
Xint newx, newy;
Xint noblur;
X{
X
X  /* Really, is an image ? */
X  if ( inbitmap->magic != LUGUSED )
X    error( 21 );
X
X  /* An 8 bits image ? */
X  if ( inbitmap->depth <= 8)
X    error(7);
X
X  /* If PAL then return the same image */
X  if ( inbitmap->xsize == newx && inbitmap->ysize == newy ) {
X    copy_bitmap( inbitmap, outbitmap );
X  }else {
X    /*
X     * Fill new header ...
X     */
X    outbitmap->magic = LUGUSED;
X    outbitmap->xsize = newx;
X    outbitmap->ysize = newy;
X    outbitmap->depth = inbitmap->depth;         /* 24 planes */
X    outbitmap->colors = inbitmap->colors;
X
X    /*
X     * ... and zoom each component.
X     */
X    VPRINTF(stderr, "Zooming R\n");
X    outbitmap->r= zoom( inbitmap->xsize, inbitmap->ysize,
X                        newx, newy, inbitmap->r, noblur );
X    VPRINTF(stderr, "Zooming G\n");
X    outbitmap->g= zoom( inbitmap->xsize, inbitmap->ysize,
X                        newx, newy, inbitmap->g, noblur );
X    VPRINTF(stderr, "Zooming B\n");
X    outbitmap->b= zoom( inbitmap->xsize, inbitmap->ysize,
X                        newx, newy, inbitmap->b, noblur );
X  }
X}
X
Xbyte *zoom(oldx, oldy, newx, newy, buffer, noblur)
Xint oldx, oldy;
Xint newx, newy;
Xregister byte *buffer;
Xint noblur;
X{
X  register int i, j;
X  register byte *base, *i_base;
X  double relx, rely;
X  double nrelx, nrely;
X  byte *ptr;
X  byte *nbuffer;
X  double foldx, foldy;
X  double fnewx, fnewy;
X
X  /* Allocate memory for new zoomed image */
X  nbuffer = (byte *) Malloc( newx * newy );
X
X  /*
X   * We use double variables ( only once transformation ).
X   */
X  fnewx = (double) newx, fnewy= (double) newy;
X  foldx = (double) oldx, foldy= (double) oldy;
X
X  for ( i = 0; i< newy; i++ ) {
X    /* pointer to first pixel in current row */
X    base = nbuffer + (int) (newx*i);
X    /* scale row from 0 to 1 with the new image */
X    nrely = ((double) i) / fnewy;
X    /* get equal value in old image */
X    rely = nrely * foldy;
X    /* pointer to first pixel in that row */
X    i_base = buffer + ((int) rely) * oldx;
X    for ( j = 0; j < newx; j++ ) {
X      /* scale column from 0 to 1 ... */
X      nrelx = ((double) j) / fnewx;
X      /* then we get position of old image */
X      relx = nrelx * foldx;
X      ptr = i_base + (int) relx;
X      *base++ = *ptr;
X    }
X  }
X
X  /*
X   * If image is greater then blur ( if no_blur switch
X   * is actived ).
X   */
X  if ( (newx > oldx || newy > oldy) && !noblur ) {
X    /* Blur zoomed image */
X    ptr = blur( nbuffer, newx, newy );
X    /* We have a new [blur] image, free first */
X    Free( nbuffer );
X    return ptr;
X  }else {
X    return nbuffer;
X  }
X}
X
Xbyte *blur(buffer, xsize, ysize)
Xbyte *buffer;
Xint xsize, ysize;
X{
X  register int i;
X  int totalsize = xsize * ysize;
X  byte *nbuffer;
X  register byte *fin;
X  register byte *base, *line_before;    /* pointers to new [blured] image */
X  register byte *last, *next_line;      /* pointers to old [zoomed] image */
X
X  /* Allocate memory for new blured image */
X  nbuffer= (byte *) Malloc( totalsize );
X
X  /*
X   * First and last rows, and first and last pixels in
X   * each row are not modified, so we copy image into new
X   * buffer and keep all information.
X   */
X  bcopy( buffer, nbuffer, totalsize );
X
X  /* Skip first and last row */
X  ysize--;
X  for ( i = 1; i < ysize; i++ ) {
X    /* Skip first pixel of current line */
X    base = nbuffer + i*xsize + 1;
X    /* Point to current line */
X    last = buffer + i*xsize + 1;
X    /* Point to line before */
X    line_before = last - xsize;
X    /* Point to next line */
X    next_line = last + xsize;
X    /*
X     * Pointer to last pixel for being modified of the current
X     * line ( skip last pixel ).
X     */
X    fin = base + xsize - 1;
X    while ( base < fin ) {
X      /* Blur the current pixel */
X      *base++ = .4 * *last +
X                .1 * *(last-1) + .1 * *(last+1) +
X                .1 * *line_before + .1 * *next_line +
X                .05 * *(line_before-1) + .05 * *(line_before+1) +
X                .05 * *(next_line-1) + .05 * *(next_line+1);
X      /* Update pointers */
X      next_line++;
X      line_before++;
X      last++;
X    }
X  }
X
X  return nbuffer;
X}
X
Xflip_image(inbitmap, outbitmap)
Xbitmap_hdr *inbitmap;
Xbitmap_hdr *outbitmap;
X{
X
X  /* Really, is an image ? */
X  if ( inbitmap->magic != LUGUSED )
X    error( 21 );
X
X  VPRINTF(stderr, "Flipping image\n");
X
X  /* Fill our header */
X  outbitmap->magic = LUGUSED;
X  outbitmap->xsize = inbitmap->xsize;
X  outbitmap->ysize = inbitmap->ysize;
X  outbitmap->depth = inbitmap->depth;
X  outbitmap->colors = inbitmap->colors;
X
X  outbitmap->r = flip( inbitmap->r, outbitmap->xsize, outbitmap->ysize );
X  if ( outbitmap->depth > 8 ) {
X    /* 24 planes */
X    outbitmap->g = flip( inbitmap->g, outbitmap->xsize, outbitmap->ysize );
X    outbitmap->b = flip( inbitmap->b, outbitmap->xsize, outbitmap->ysize );
X  }else outbitmap->cmap = inbitmap->cmap;
X}
X
Xbyte *flip(buffer, xsize, ysize)
Xbyte *buffer;
Xint xsize, ysize;
X{
X  register int i, j;
X  int twolines;
X  byte *image, *ptr;
X
X  ptr = image = (byte *) Malloc( xsize * ysize );
X  twolines = 2 * xsize;
X  buffer += xsize * ysize - xsize;
X
X  for ( i = 0; i < ysize; i++) {
X    for ( j = 0; j < xsize; j++ ) {
X      *ptr++ = *buffer++;
X    }
X    buffer -= twolines;
X  }
X
X  return image;
X}
X
Xto24( inbitmap, outbitmap )
Xbitmap_hdr *inbitmap;
Xbitmap_hdr *outbitmap;
X{
X  int total_size;
X  color_map *map;
X  byte *r, *g, *b;
X  byte *base;
X  byte *end;
X
X  /* Really, is an image ? */
X  if ( inbitmap->magic != LUGUSED )
X    error( 21 );
X
X  /* Fill new header */
X  outbitmap->magic = LUGUSED;
X  outbitmap->xsize = inbitmap->xsize;
X  outbitmap->ysize = inbitmap->ysize;
X  outbitmap->depth = 24;
X  outbitmap->colors = ( 1 << outbitmap->depth );
X  total_size  = outbitmap->xsize * outbitmap->ysize;
X  r = outbitmap->r = (byte *) Malloc(total_size);
X  g = outbitmap->g = (byte *) Malloc(total_size);
X  b = outbitmap->b = (byte *) Malloc(total_size);
X
X  /* A pointer to cmap */
X  map  = (color_map *) inbitmap->cmap;
X  /* A pointer to original 8 bits buffer */
X  base = inbitmap->r;
X  /* A pointer to the end */
X  end = base + total_size;
X
X  VPRINTF(stderr, "Reconverting to 24 planes\n");
X  while ( base < end ) {
X    *r++ = map[*base][0];
X    *g++ = map[*base][1];
X    *b++ = map[*base][2];
X    base++;
X  }
X}
X
Xcreate_solid_image(image, xsize, ysize, r, g, b)
Xbitmap_hdr *image;
Xint xsize, ysize;
Xbyte r, g, b;
X{
X  int totalsize = xsize * ysize;
X
X  image->magic = LUGUSED;
X  image->xsize = xsize;
X  image->ysize = ysize;
X  image->depth = 24;
X  image->colors = ( 1 << image->depth );
X  image->r= (byte *) Malloc( totalsize );
X  image->g= (byte *) Malloc( totalsize );
X  image->b= (byte *) Malloc( totalsize );
X  if ( r )
X    memset( image->r, r, totalsize );
X  if ( g )
X    memset( image->g, g, totalsize );
X  if ( b )
X    memset( image->b, b, totalsize );
X}
X
Xcenter_image( base, super )
Xbitmap_hdr *base, *super;
X{
X  int xmid, ymid;
X
X  xmid = ( XSIZE / 2 ) - ( super->xsize / 2 );
X  ymid = ( YSIZE / 2 ) - ( super->ysize / 2 );
X
X  paste( base, super, xmid, ymid );
X}
X
Xpaste(base, super, xpos, ypos)
Xbitmap_hdr *base, *super;
Xint xpos, ypos;
X{
X  register int i, j;
X  byte *r1, *g1, *b1;
X  byte *r2, *g2, *b2;
X
X   /* Really, are images ? */
X  if ( base->magic != LUGUSED || super->magic != LUGUSED )
X    error( 21 );
X
X  r1 = base->r,  g1 = base->g,  b1 = base->b;
X  r2 = super->r, g2 = super->g, b2 = super->b;
X
X  /*
X   * Skip pre-paste rows.
X   */
X  for (i= 0; i< ypos; i++) {
X    r1 += base->xsize;
X    g1 += base->xsize;
X    b1 += base->xsize;
X  }
X
X  /*
X   * While we are inside surface to paste ...
X   */
X  for ( i = 0; i < super->ysize; i++ ) {
X    for ( j = 0; j< base->xsize; j++ )
X      if ( j < xpos  || j >= super->xsize+xpos ) {
X        r1++, g1++, b1++;
X      }else {
X        if ( (*r2 + *g2 + *b2) < CHROMABORDER ) {
X          r1++, g1++, b1++;
X          r2++, g2++, b2++;
X        }else {
X          *r1++ = *r2++;
X          *g1++ = *g2++;
X          *b1++ = *b2++;
X        }
X      }
X  }
X}
X
Xchroma( base, super )
Xbitmap_hdr *base;
Xbitmap_hdr *super;
X{
X  register int i, j;
X  byte *r1, *g1, *b1;
X  byte *r2, *g2, *b2;
X
X  /* Really, are images ? */
X  if ( base->magic != LUGUSED || super->magic != LUGUSED )
X    error( 21 );
X
X  /* Set pointers */
X  r1= base->r , g1= base->g , b1= base->b;
X  r2= super->r, g2= super->g, b2= super->b;
X
X  for ( i = 0; i < super->ysize; i++ ) {
X    for ( j = 0; j < base->xsize; j++ ) {
X      if ( j < super->xsize ) {
X        /* We are into super image. */
X        if ( (*r2 + *g2 + *b2) < CHROMABORDER ) {
X          r1++, g1++, b1++;
X          r2++, g2++, b2++;
X        }else {
X          *r1++ = *r2++;
X          *g1++ = *g2++;
X          *b1++ = *b2++;
X        }
X      }else {
X        /* Out of super borders */
X        r1++, g1++, b1++;
X      }
X    }
X  }
X}
X
Xbyte *create_bw_pallete()
X{
X  register int i;
X  byte *buffer = (byte *) Malloc( 3 * 256 );
X  byte *ptr;
X
X  /* I'll use a pointer */
X  ptr = buffer;
X  for (i = 0; i < 256; i++) {
X    *ptr++= (byte) i;   /* R */
X    *ptr++= (byte) i;   /* G */
X    *ptr++= (byte) i;   /* B */
X  }
X
X  return buffer;
X}
X
X
X/**************************************
X *
X * ALIAS interface
X *
X */
Xread_alias_file( name, bitmap )
Xchar *name;
Xbitmap_hdr *bitmap;
X{
X  FILE *handle;
X
X  /* Open the file descriptor */
X  if ( name != NULL )
X    handle = Fopen( name, "r" );
X  else handle = stdin;
X
X  /* Read the bitmap */
X  read_alias( handle, bitmap );
X
X  /* Close the file */
X  Fclose( handle );
X}
X
Xread_alias(handle, image)
XFILE *handle;
Xbitmap_hdr *image;
X{
X  register int i;
X  alias_hdr header;
X  int total_size;
X  register int xsize;
X  byte *end;
X  byte *r, *g, *b;
X  int can_read_all;
X  byte *buffer, *ptr;
X  int filesize;
X  int allplanes = 0;
X  int internalerror;
X  int cmapsize;
X
X  /*
X   * Alias "pix" is a bad format to read line per line. If every
X   * triplet is different to its next, then we read 4 bytes, 4 bytes ...
X   * ... and read a file of 1 Mb. with this form ... hmmmmmm !!!
X   * This is necesary if we are reading from stdin, but if we have
X   * a file, we'll read the file into memory ( one access to disk ).
X   */
X#ifndef DEC
X  can_read_all = (handle != stdin);     /* a regular file ? */
X  VPRINTF(stderr, "Reading Alias from %s\n",
X                  (can_read_all ? "file" : "stdin"));
X#else
X  can_read_all = 0;
X#endif
X
X  if (can_read_all) {
X    /*
X     * We are using a regular file ( not a pipe ), so we can
X     * read it into memory.
X     */
X    ptr= buffer= (byte *) read_file(handle, &filesize);
X    VPRINTF(stderr, "File size: %d\n", filesize);
X    /* Copy the header */
X    bcopy(ptr, &header, sizeof(alias_hdr));
X    ptr += sizeof(alias_hdr);           /* skip the header */
X  }else {
X    /*
X     * We are using stdin so ...
X     */
X    /* We need the header of Alias pix */
X    VPRINTF(stderr, "Reading Alias header\n");
X    read_alias_header(handle, &header);
X  }
X
X  /* Size in pixels */
X  total_size = header.xsize * header.ysize;
X
X  /* Fill our header */
X  image->magic  = LUGUSED;
X  image->xsize  = header.xsize;
X  image->ysize  = header.ysize;
X  image->depth  = header.depth;
X  image->colors = 1 << image->depth;
X  allplanes = ( image->depth > 8 );     /* an image with 24 planes ? */
X  VPRINTF(stderr, "Image size: %dx%d\n", image->xsize, image->ysize);
X  VPRINTF(stderr, "Depth: %d\n", image->depth);
X
X  /* Get some memory */
X  if ( allplanes ) {
X    /*
X     * We have a image with 24 planes, so we need three buffers to
X     * store it.
X     */
X    r= image->r = (byte *) Malloc(total_size);
X    g= image->g = (byte *) Malloc(total_size);
X    b= image->b = (byte *) Malloc(total_size);
X  }else {
X    /*
X     * The image has less than 256 colors, so we use one plane,
X     * for the bitmap, and the cmap.
X     */
X    r= image->r = (byte *) Malloc(total_size);
X    cmapsize= image->colors * 3;        /* size in bytes */
X    image->cmap = (byte *) Malloc(cmapsize);
X    /* Creating the cmap from file */
X    VPRINTF(stderr, "Creating cmap\n");
X    create_alias_cmap(image);
X  }
X
X  /*
X   * We are ready to uncompress Alias file.
X   */
X  VPRINTF(stderr, "Uncompressing Alias file\n");
X  if (can_read_all) {
X    /*
X     * We have the file into memory so we uncode it directly.
X     */
X    end = r + total_size;       /* the end of main buffer */
X    if ( allplanes )
X      uncode_alias24(ptr, r, g, b, end);
X    else uncode_alias(ptr, r, end);
X    /*
X     * We have read the file and uncompressed, so we can
X     * free the memory ( and exit ).
X     */
X    Free(buffer);
X  }else {
X    /*
X     * We'll read each line from Alias file ( stdin ) until we
X     * fill our buffers or we get an error.
X     */
X    xsize = image->xsize;
X    for (i= 0; i< image->ysize; i++) {
X      /*
X       * Read and decode the Alias raster information, two cases:
X       * with planes > 8 => a triplet (RGB), else a index.
X       */
X      if ( allplanes ) {
X        /* An image with 24 planes */
X        internalerror= read_line_alias24(handle, r, b, g, xsize);
X      }else {
X        /* An image with indexes to cmap */
X        internalerror= read_line_alias(handle, r, xsize);
X      }
X      if (internalerror) {
X        /* An error, so we exit */
X        fprintf(stderr, "Error while reading line %d\n", i);
X        return 1;
X      }else {
X        /* A line has been read, so we increment theirs pointers */
X        r += xsize;
X        if ( allplanes ) {
X          g += xsize;
X          b += xsize;
X        }
X      }
X    }
X  } /* end of reading from stdin */
X
X  /* Finish with no problems */
X  return 0;
X}
X
Xread_alias_header(handle, header)
XFILE *handle;
Xalias_hdr *header;
X{
X  byte buffer[10];
X
X  /* Read the header */
X  Fread(buffer, 10, 1, handle);
X
X  /* Fill the header structure */
X  header->xsize = ( buffer[0] << 8 ) | buffer[1];
X  header->ysize = ( buffer[2] << 8 ) | buffer[3];
X  header->xinit = ( buffer[4] << 8 ) | buffer[5];
X  header->yinit = ( buffer[6] << 8 ) | buffer[7];
X  header->depth = ( buffer[8] << 8 ) | buffer[9];
X
X  /* Check some things */
X  if ( header->xsize < 1 || header->xsize > 2560 ||
X       header->ysize < 1 || header->ysize > 2560 )
X    error(5);
X  if ( header->depth > 24 || header->depth < 1 )
X    error(5);
X}
X
Xread_line_alias24(handle, r, g, b, size)
XFILE *handle;
Xbyte *r, *g, *b;
Xregister int size;
X{
X  register int i;
X  register int count = 0;
X  byte *end;
X  byte buffer[4];
X
X  end = r + size;
X  while (count < size) {
X    /*
X     * Alias code format:  <repeat>BGR => 4 bytes.
X     */
X    if ( !fread(buffer, 4, 1, handle) )         /* read next buffer */
X      return 1;   /* hey !, an EOF here ?. Hmmmm, this is an error ! */
X
X    count += buffer[0];                 /* # of repetitions */
X    /* repeat 'buffer[0]' times these triplet */
X    for (i= 0; i< buffer[0]; i++) {
X      *r++ = buffer[3];
X      *g++ = buffer[1];
X      *b++ = buffer[2];
X    }
X    if ( r > end )
X      error(6);         /* uncompress more bytes than size */
X  }
X
X  /* No problems */
X  return 0;
X}
X
Xread_line_alias(handle, r, size)
XFILE *handle;
Xbyte *r;
Xregister int size;
X{
X  register int i;
X  register int count = 0;
X  byte *end;
X  byte buffer[2];
X
X  end = r + size;
X  while (count < size) {
X    /*
X     * Alias code format:  <repeat><index> => 2 bytes.
X     */
X    if ( !fread(buffer, 2, 1, handle) )         /* read next buffer */
X      return 1;   /* hey !, an EOF here ?. Hmmmm, this is an error ! */
X
X    count += buffer[0];                 /* # of repetitions */
X    /* repeat 'buffer[0]' times these index */
X    for (i= 0; i< buffer[0]; i++) {
X      *r++ = buffer[1];
X    }
X    if ( r > end )
X      error(6);         /* uncompress more bytes than size */
X  }
X
X  /* No problems */
X  return 0;
X}
X
Xcreate_alias_cmap(image)
Xbitmap_hdr *image;
X{
X  register int i;
X  byte *ptr;
X
X  /*
X   * Alias 8 bits files are b&w, so ...
X   */
X  ptr = (byte *) image->cmap;
X  for (i= 0; i< image->colors; i++) {
X    *ptr++ = i;
X    *ptr++ = i;
X    *ptr++ = i;
X  }
X}
X
Xuncode_alias24(ptr, rbuf, gbuf, bbuf, end)
Xbyte *ptr;
Xbyte *rbuf, *gbuf, *bbuf;
Xbyte *end;
X{
X  register int i;
X  byte r, g, b;
X
X  while ( rbuf < end ) {        /* while not end of buffer */
X    if ( (i= *ptr++) > 1 ) {            /* how mary repetitions ? */
X      b= *ptr++;
X      g= *ptr++;
X      r= *ptr++;
X      while( i-- ) {    /* copy these triplet 'i' times */
X        *rbuf++ = r;
X        *gbuf++ = g;
X        *bbuf++ = b;
X      }
X    }else {                     /* else, copy these triplet */
X      *bbuf++ = *ptr++;
X      *gbuf++ = *ptr++;
X      *rbuf++ = *ptr++;
X    }
X  }
X}
X
Xuncode_alias(ptr, rbuf, end)
Xbyte *ptr;
Xbyte *rbuf;
Xbyte *end;
X{
X  register int i;
X  byte r;
X
X  while ( rbuf < end ) {        /* while not end of buffer */
X    if ( (i= *ptr++) > 1 ) {            /* how mary repetitions ? */
X      r= *ptr++;
X      while( i-- ) {    /* copy these index 'i' times */
X        *rbuf++ = r;
X      }
X    }else {                     /* else, copy these index */
X      *rbuf++ = *ptr++;
X    }
X  }
X}
X
X
X/**************************************
X *
X * Wavefront's RLA interface.
X *
X */
Xread_rla_file( name, bitmap )
Xchar *name;
Xbitmap_hdr *bitmap;
X{
X  FILE *handle;
X
X  /* Open the file descriptor */
X  if ( name != NULL )
X    handle = Fopen( name, "r" );
X  else error( 20 );
X
X  /* Read the bitmap */
X  read_rla( handle, bitmap );
X
X  /* Close the file */
X  Fclose( handle );
X}
X
Xread_rla(handle, image)
XFILE *handle;
Xbitmap_hdr *image;
X{
X  register int i, j;
X  RLA_HEADER rla;
X  int totalsize;
X  byte *r, *g, *b;
X  int *offsets;
X  short no_bytes;
X  byte *ptr;
X  byte *raux, *gaux, *baux;
X  byte *rptr, *gptr, *bptr;
X
X  /*
X   * Read the RLA's header.
X   */
X  Fread(&rla, 740, 1, handle);
X  image->magic = LUGUSED;
X  image->xsize = rla.window.right - rla.window.left + 1;
X  image->ysize = rla.window.top - rla.window.bottom + 1;
X  image->depth = 24;
X  image->colors = ( 1 << image->depth );
X  totalsize= image->xsize * image->ysize;
X
X  if ( image->xsize < 1 || image->xsize > 2559 ||
X       image->ysize < 1 || image->ysize > 2559 )
X    error(5);
X
X  /*
X   * Allocate for bitmap components.
X   */
X  r = image->r = (byte *) Malloc(totalsize);
X  g = image->g = (byte *) Malloc(totalsize);
X  b = image->b = (byte *) Malloc(totalsize);
X
X  /* Some space to unpack scanlines */
X  raux = (byte *) Malloc(image->xsize);
X  gaux = (byte *) Malloc(image->xsize);
X  baux = (byte *) Malloc(image->xsize);
X  ptr  = (byte *) Malloc(2560);
X
X  /* Allocate space for offsets */
X  offsets = (int *) Malloc(image->ysize*sizeof(int));
X  Fread(offsets, sizeof(int), image->ysize, handle);
X
X  for (i = rla.window.top; i >= rla.window.bottom; i--) {
X    if ( i > rla.act_window.top || i < rla.act_window.bottom ) {
X      /* Outlines => zeros ( done with Malloc ) */
X      r += image->xsize;
X      g += image->xsize;
X      b += image->xsize;
X    }else {
X      /*
X       * Set pointer where offsets table says.
X       */
X      if (fseek(handle, (long) offsets[i - rla.act_window.bottom], 0))
X        error( 20 );
X      /*
X       * Uncode R channel.
X       */
X      Fread(&no_bytes, sizeof(short), 1, handle);
X      Fread(ptr, (int) no_bytes, 1, handle);
X      decodeRLA(ptr, raux, no_bytes);
X      /*
X       * Uncode G channel.
X       */
X      Fread(&no_bytes, sizeof(short), 1, handle);
X      Fread(ptr, (int) no_bytes, 1, handle);
X      decodeRLA(ptr, gaux, no_bytes);
X      /*
X       * Uncode B channel.
X       */
X      Fread(&no_bytes, sizeof(short), 1, handle);
X      Fread(ptr, (int) no_bytes, 1, handle);
X      decodeRLA(ptr, baux, no_bytes);
X
X      /*
X       * If you wanna you do the same task with matte ( but I
X       * don't mind that channel ).
X       */
X
X      /*
X       * We uncode the active window, now we fill the real window
X       * with these datas and aditional zeros.
X       */
X      rptr= raux;
X      gptr= gaux;
X      bptr= baux;
X      for (j = rla.window.left; j <= rla.window.right; j++) {
X        if ( j < rla.act_window.left || j > rla.act_window.right ) {
X          /* Outlines => zeros ( done with Malloc ) */
X          *r++, *g++, *b++;
X         }else {
X           *r++ = *rptr++;
X           *g++ = *gptr++;
X           *b++ = *bptr++;
X         }
X      }
X    }
X  }
X
X  /*
X   * Free memory.
X   */
X  Free(raux);
X  Free(gaux);
X  Free(baux);
X  Free(offsets);
X  Free(ptr);
X
X  /* no errors */
X  return 0;
X}
X
XdecodeRLA(buf_in, buf_out, len)
Xbyte    *buf_in;
Xbyte    *buf_out;
Xint     len;
X{
X   int  ct;
X   byte *end;
X
X   end = buf_out + len;
X   while(len > 0) {
X      ct = *buf_in++;
X      len--;
X      if (ct < 128) {
X        /* repeat pixel value ct+1 times */
X         while (ct-- >= 0)
X            *buf_out++ = *buf_in;
X         buf_in++;
X         len--;
X      }
X      else {
X        /* copy ct unencoded values */
X         for (ct = 256-ct; ct-- > 0; len--)
X            *buf_out++ = *buf_in++;
X      }
X      /* if ( buf_out > end )
X        error(6);*/
X   }
X}
X
X
X/**************************************
X *
X * SGI interface
X *
X */
Xread_sgi_file( name, bitmap )
Xchar *name;
Xbitmap_hdr *bitmap;
X{
X  register int i, j;
X  IMAGE *sgi_image;
X  byte *r, *g, *b;
X  short *sgibuf;
X  int totalsize;
X  int flag24;
X
X  VPRINTF(stderr, "Reading SGI image\n");
X
X  if ( (sgi_image = iopen( name, "r" )) == NULL )
X    error( 1 );
X  /* if ( sgi_image->zsize < 3 )
X      error( 7 ); */
X
X  /*
X   * Fill our header.
X   */
X  bitmap->magic = LUGUSED;
X  bitmap->xsize = sgi_image->xsize;
X  bitmap->ysize = sgi_image->ysize;
X  bitmap->depth = 8 * sgi_image->zsize;
X  bitmap->colors = ( 1 << bitmap->depth );
X  flag24 = (bitmap->depth > 8);
X
X  totalsize = bitmap->xsize * bitmap->ysize;
X  r = bitmap->r = (byte *) Malloc( totalsize );
X  if ( flag24 ) {
X    g = bitmap->g = (byte *) Malloc( totalsize );
X    b = bitmap->b = (byte *) Malloc( totalsize );
X  }else bitmap->cmap = (byte *) create_bw_pallete();
X
X  /*
X   * Allocate memory for sgi raster line.
X   */
X  sgibuf = (short *) Malloc( sizeof(short) * bitmap->xsize );
X
X  for ( i = 0; i < bitmap->ysize; i++ ) {
X    j = bitmap->ysize - 1 - i;
X    getrow( sgi_image, sgibuf, j, 0 );
X    (void) shorttobyte( sgibuf, r, bitmap->xsize );
X    r += bitmap->xsize;
X    if ( flag24 ) {
X      getrow( sgi_image, sgibuf, j, 1 );
X      (void) shorttobyte( sgibuf, g, bitmap->xsize );
X      g += bitmap->xsize;
X      getrow( sgi_image, sgibuf, j, 2 );
X      (void) shorttobyte( sgibuf, b, bitmap->xsize );
X      b += bitmap->xsize;
X    }
X  }
X
X  iclose( sgi_image );
X  Free( sgibuf );
X}
X
X
X/**************************************
X *
X * TARGA interface
X *
X */
Xread_tga_file( name, bitmap )
Xchar *name;
Xbitmap_hdr *bitmap;
X{
X  FILE *handle;
X  bitmap_hdr image;
X
X  /* Open the file descriptor */
X  if ( name != NULL )
X    handle = Fopen( name, "r" );
X  else handle = stdin;
X
X  /* Read the bitmap */
X  read_tga( handle, &image );
X
X  /* Close the file */
X  Fclose( handle );
X
X  /*
X   * Now we could have a 8 or 24 bits image, but 'tovcr'
X   * needs true color images, so check it...
X   */
X  if ( image.depth > 8 ){
X    copy_bitmap( &image, bitmap );
X  }else {
X    to24( &image, bitmap );
X  }
X
X  /* Free the tmp bitmap */
X  freebitmap( &image );
X}
X
Xread_tga(handle, image)
XFILE *handle;
Xbitmap_hdr *image;
X{
X  register int i;
X  tga_hdr tga;
X  int allplanes = 0;
X  int lessplanes = 0;
X  int forceallplanes = 0;
X  byte aux4[4];
X  int totalsize;
X  byte *ptr;
X  byte *r, *g, *b;
X  byte *aux;
X
X  /* Read the Tagar header */
X  read_tga_header( handle, &tga );
X
X  /* Fill our header */
X  image->magic = LUGUSED;
X  image->xsize = tga.xsize;
X  image->ysize = tga.ysize;
X  totalsize = image->xsize * image->ysize;
X  /*
X   * Targa format can be mapped but with moer than 256 colors,
X   * our mapped images only support 8 bits, so we need convert
X   * these images to 24 bits.
X   */
X  switch ( tga.image_type ) {
X    case TGA_RGB:
X    case TGA_RLE_RGB:
X                allplanes = 1;
X                break;
X    case TGA_MAPPED:
X    case TGA_RLE_MAPPED:
X                lessplanes = 1;
X                if ( tga.cmap_type != 1 )
X                  error( 10 );
X                if ( tga.cmap_length > 256 )
X                  forceallplanes = 1;
X                break;
X  }
X
X  /*
X   * Read the cmap info ( if exists ).
X   */
X  if ( tga.cmap_type ) {
X    VPRINTF(stderr, "Reading cmap info\n");
X    if ( allplanes ) {
X      /* We only need skip the cmap block */
X      for ( i = 0; i < tga.cmap_length; i++ )
X        read_tga_data( aux4, tga.cmap_entry_size, handle );
X    }else {
X      ptr = image->cmap = (byte *) Malloc( 3 * tga.cmap_length );
X      for ( i = 0; i < tga.cmap_length; i++) {
X        read_tga_data( ptr, tga.cmap_entry_size, handle );
X        ptr += 3;
X      }
X    }
X  }
X
X  /*
X   * Allocate memory for the bitmap and fill our header.
X   */
X  image->xsize = tga.xsize;
X  image->ysize = tga.ysize;
X  totalsize = image->xsize * image->ysize;
X  if ( allplanes || forceallplanes ) {
X    r = image->r = (byte *) Malloc( totalsize );
X    g = image->g = (byte *) Malloc( totalsize );
X    b = image->b = (byte *) Malloc( totalsize );
X    image->depth = 24;
X  }else {
X    r = image->r = (byte *) Malloc( totalsize );
X    image->depth = no_bits( tga.cmap_length ) + 1;
X  }
X  image->colors = ( 1 << image->depth );
X
X  /*
X   * Read the raster information.
X   */
X  if ( allplanes ) {
X    read_tga24( handle, r, g, b, &tga );
X
X  }else if ( forceallplanes )
X          read_tga_to24( handle, r, g, b, &tga, image->cmap );
X        else read_tga8( handle, r, &tga );
X
X  if ( TGAFLIP( tga.image_descriptor ) ) {
X    VPRINTF(stderr, "Flipping the image\n");
X    aux = (byte *) flip( r, image->xsize, image->ysize );
X    Free( r );
X    image->r = aux;
X    if ( allplanes ) {
X      /* A true color image, so we have G and B buffers */
X      aux = (byte *) flip( g, image->xsize, image->ysize );
X      Free( g );
X      image->g = aux;
X      aux = (byte *) flip( b, image->xsize, image->ysize );
X      Free( b );
X      image->b = aux;
X    }
X  }
X}
X
END_OF_FILE
  if test 45778 -ne `wc -c <'tovcr.c.A'`; then
    echo shar: \"'tovcr.c.A'\" unpacked with wrong size!
  elif test -f 'tovcr.c.B'; then
    echo shar: Combining  \"'tovcr.c'\" \(99170 characters\)
    cat 'tovcr.c.A' 'tovcr.c.B' > 'tovcr.c'
    if test 99170 -ne `wc -c <'tovcr.c'`; then
      echo shar: \"'tovcr.c'\" combined with wrong size!
    else
      rm tovcr.c.A tovcr.c.B 
    fi
  fi
  # end of 'tovcr.c.A'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
