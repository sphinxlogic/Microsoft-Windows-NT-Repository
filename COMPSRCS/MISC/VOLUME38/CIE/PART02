Newsgroups: comp.sources.misc
From: kennedy@art.intellection.com (Brian M Kennedy)
Subject: v38i016:  cie - C++ In Emacs v1.0, Part02/02
Message-ID: <1993Jun20.232350.15755@sparky.imd.sterling.com>
X-Md4-Signature: 99dca9d7801abc1e2e53d0aab7299308
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sun, 20 Jun 1993 23:23:50 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: kennedy@art.intellection.com (Brian M Kennedy)
Posting-number: Volume 38, Issue 16
Archive-name: cie/part02
Environment: Emacs, C++

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  cie/COPYING cie/README cie/cie-mouse.el cie/cie.el
#   cie/class-manual.el cie/do-etags++ cie/etags++/Makefile
#   cie/etags++/hier++.c cie/goto-file.el
# Wrapped by kent@sparky on Sun Jun 20 18:21:18 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'cie/COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/COPYING'\"
else
  echo shar: Extracting \"'cie/COPYING'\" \(9934 characters\)
  sed "s/^X//" >'cie/COPYING' <<'END_OF_FILE'
X		    GNU GENERAL PUBLIC LICENSE
X		     Version 1, February 1989
X
X Copyright (C) 1989 Free Software Foundation, Inc.
X                    675 Mass Ave, Cambridge, MA 02139, USA
X Everyone is permitted to copy and distribute verbatim copies
X of this license document, but changing it is not allowed.
X
X			    Preamble
X
X  The license agreements of most software companies try to keep users
Xat the mercy of those companies.  By contrast, our General Public
XLicense is intended to guarantee your freedom to share and change free
Xsoftware--to make sure the software is free for all its users.  The
XGeneral Public License applies to the Free Software Foundation's
Xsoftware and to any other program whose authors commit to using it.
XYou can use it for your programs, too.
X
X  When we speak of free software, we are referring to freedom, not
Xprice.  Specifically, the General Public License is designed to make
Xsure that you have the freedom to give away or sell copies of free
Xsoftware, that you receive source code or can get it if you want it,
Xthat you can change the software or use pieces of it in new free
Xprograms; and that you know you can do these things.
X
X  To protect your rights, we need to make restrictions that forbid
Xanyone to deny you these rights or to ask you to surrender the rights.
XThese restrictions translate to certain responsibilities for you if you
Xdistribute copies of the software, or if you modify it.
X
X  For example, if you distribute copies of a such a program, whether
Xgratis or for a fee, you must give the recipients all the rights that
Xyou have.  You must make sure that they, too, receive or can get the
Xsource code.  And you must tell them their rights.
X
X  We protect your rights with two steps: (1) copyright the software, and
X(2) offer you this license which gives you legal permission to copy,
Xdistribute and/or modify the software.
X
X  Also, for each author's protection and ours, we want to make certain
Xthat everyone understands that there is no warranty for this free
Xsoftware.  If the software is modified by someone else and passed on, we
Xwant its recipients to know that what they have is not the original, so
Xthat any problems introduced by others will not reflect on the original
Xauthors' reputations.
X
X  The precise terms and conditions for copying, distribution and
Xmodification follow.
X
X		    GNU GENERAL PUBLIC LICENSE
X   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
X
X  0. This License Agreement applies to any program or other work which
Xcontains a notice placed by the copyright holder saying it may be
Xdistributed under the terms of this General Public License.  The
X"Program", below, refers to any such program or work, and a "work based
Xon the Program" means either the Program or any work containing the
XProgram or a portion of it, either verbatim or with modifications.  Each
Xlicensee is addressed as "you".
X
X  1. You may copy and distribute verbatim copies of the Program's source
Xcode as you receive it, in any medium, provided that you conspicuously and
Xappropriately publish on each copy an appropriate copyright notice and
Xdisclaimer of warranty; keep intact all the notices that refer to this
XGeneral Public License and to the absence of any warranty; and give any
Xother recipients of the Program a copy of this General Public License
Xalong with the Program.  You may charge a fee for the physical act of
Xtransferring a copy.
X
X  2. You may modify your copy or copies of the Program or any portion of
Xit, and copy and distribute such modifications under the terms of Paragraph
X1 above, provided that you also do the following:
X
X    a) cause the modified files to carry prominent notices stating that
X    you changed the files and the date of any change; and
X
X    b) cause the whole of any work that you distribute or publish, that
X    in whole or in part contains the Program or any part thereof, either
X    with or without modifications, to be licensed at no charge to all
X    third parties under the terms of this General Public License (except
X    that you may choose to grant warranty protection to some or all
X    third parties, at your option).
X
X    c) If the modified program normally reads commands interactively when
X    run, you must cause it, when started running for such interactive use
X    in the simplest and most usual way, to print or display an
X    announcement including an appropriate copyright notice and a notice
X    that there is no warranty (or else, saying that you provide a
X    warranty) and that users may redistribute the program under these
X    conditions, and telling the user how to view a copy of this General
X    Public License.
X
X    d) You may charge a fee for the physical act of transferring a
X    copy, and you may at your option offer warranty protection in
X    exchange for a fee.
X
XMere aggregation of another independent work with the Program (or its
Xderivative) on a volume of a storage or distribution medium does not bring
Xthe other work under the scope of these terms.
X
X  3. You may copy and distribute the Program (or a portion or derivative of
Xit, under Paragraph 2) in object code or executable form under the terms of
XParagraphs 1 and 2 above provided that you also do one of the following:
X
X    a) accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    b) accompany it with a written offer, valid for at least three
X    years, to give any third party free (except for a nominal charge
X    for the cost of distribution) a complete machine-readable copy of the
X    corresponding source code, to be distributed under the terms of
X    Paragraphs 1 and 2 above; or,
X
X    c) accompany it with the information you received as to where the
X    corresponding source code may be obtained.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form alone.)
X
XSource code for a work means the preferred form of the work for making
Xmodifications to it.  For an executable file, complete source code means
Xall the source code for all modules it contains; but, as a special
Xexception, it need not include source code for modules which are standard
Xlibraries that accompany the operating system on which the executable
Xfile runs, or for standard header files or definitions files that
Xaccompany that operating system.
X
X  4. You may not copy, modify, sublicense, distribute or transfer the
XProgram except as expressly provided under this General Public License.
XAny attempt otherwise to copy, modify, sublicense, distribute or transfer
Xthe Program is void, and will automatically terminate your rights to use
Xthe Program under this License.  However, parties who have received
Xcopies, or rights to use copies, from you under this General Public
XLicense will not have their licenses terminated so long as such parties
Xremain in full compliance.
X
X  5. By copying, distributing or modifying the Program (or any work based
Xon the Program) you indicate your acceptance of this license to do so,
Xand all its terms and conditions.
X
X  6. Each time you redistribute the Program (or any work based on the
XProgram), the recipient automatically receives a license from the original
Xlicensor to copy, distribute or modify the Program subject to these
Xterms and conditions.  You may not impose any further restrictions on the
Xrecipients' exercise of the rights granted herein.
X
X  7. The Free Software Foundation may publish revised and/or new versions
Xof the General Public License from time to time.  Such new versions will
Xbe similar in spirit to the present version, but may differ in detail to
Xaddress new problems or concerns.
X
XEach version is given a distinguishing version number.  If the Program
Xspecifies a version number of the license which applies to it and "any
Xlater version", you have the option of following the terms and conditions
Xeither of that version or of any later version published by the Free
XSoftware Foundation.  If the Program does not specify a version number of
Xthe license, you may choose any version ever published by the Free Software
XFoundation.
X
X  8. If you wish to incorporate parts of the Program into other free
Xprograms whose distribution conditions are different, write to the author
Xto ask for permission.  For software which is copyrighted by the Free
XSoftware Foundation, write to the Free Software Foundation; we sometimes
Xmake exceptions for this.  Our decision will be guided by the two goals
Xof preserving the free status of all derivatives of our free software and
Xof promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  9. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
XFOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
XOTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
XPROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
XOR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
XMERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
XTO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
XPROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
XREPAIR OR CORRECTION.
X
X  10. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
XWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
XREDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
XINCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
XOUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
XTO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
XYOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
XPROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
XPOSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
END_OF_FILE
  if test 9934 -ne `wc -c <'cie/COPYING'`; then
    echo shar: \"'cie/COPYING'\" unpacked with wrong size!
  fi
  # end of 'cie/COPYING'
fi
if test -f 'cie/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/README'\"
else
  echo shar: Extracting \"'cie/README'\" \(9444 characters\)
  sed "s/^X//" >'cie/README' <<'END_OF_FILE'
XC++ In Emacs (CIE) v 1.0
X
XArchive-name: cie
XEnvironment: Emacs, C++
X
XAuthor:  Brian M Kennedy (kennedy@intellection.com)
X         with contributions from:
X           Walt Buehring (tags.el and minibuffer-yank.el)
X           Sam Kendall (tags.el) 
X	   (and, of course, the original tags.el author(s)).
X
X
XThis package is a collection of some of the tools/enhancements we use for C++
Xdevelopment work within GNU Emacs.  Briefly, it consists of an enhanced etags
Xfor C++, a related class hierarchy generator, a mode and M-x commands for
Xbrowsing the hierarchy and getting lists of class members, a command goto-file
Xthat takes you to the proper line in a file, functions to make both tag names
Xand file names mouseable, and a class manual generator that uses the hierarchy
Xand tag information, coupled with the comments in the code, to build a class
Xmanual in texinfo format.
X
XI've been stalling on releasing this, hoping to find time to implement some of
Xthe outstanding features and do some significant cleanup.  I have decided that
XI will never get to it (and I feel more and more guilty every time I see one
Xof the many requests for these features on the newsgroups), so I am just going
Xto release it basically as is.  My apologies.
X
XNote the implication here -- in the past many, many months I have never found
Xtime to do any of the to-do queue.  You are welcome to send bug reports and
Xsuggestions, but it is highly improbable that I will ever manage to get to
Xacting on them.  If you like this package, and want it to grow, consider 
Xvolunteering to adopt it and become its maintainer.  Any and all are welcome 
Xto do so.
X
XThis has run with GNU Emacs 18.51, 18.55, 18.57 and 18.58.  I have not yet 
Xswitched to Emacs 19, so neither has this code.  If you want to use it with 
XEmacs 19, I encourage you to volunteer to "port" it for the rest of us ;-)
X
XThe etags++ and hier++ C++ programs have been compiled with Sun C++, 
XCenterline C++, Lucid C++, and Comeau C++ on Sun OS, Ultrix, and AIX 
Xplatforms.
X
X=====
X
XThe directory etags++ contains source for two programs, etags++ and hier++.
XThey are written in C++.  Assuming you have some reasonable C++ compiler
Xaccessible via command "CC", a simple make should build the two programs.
X
XThe file do-etags++ is simply an example of how to invoke etags++, hier++, 
Xand emacs in batch mode to save out the tags-alist.  This is done for me
Xautomatically each night (but just takes a few minutes on 100K LOC).
X
XThe files cie.el and cie-mouse.el set up keystrokes and mousestrokes and
Xautoloads for the other files.  You may want to load these (or variations)
Xin your default.el or .emacs.
X
XThe other files (the meat) need to be dropped in your load-path somewhere.  
XNote that the tags.el should be loaded instead of (or after) the standard 
Xtags.el.
X
XThe TAGS file generated by etags++ is standard format.  So, it is possible
Xto use just that with the standard tags.el.  And this tags.el should work
Xessentially the same as the standard tags.el on TAGS files generated by the
Xstandard etags program (that is important since etags++ only supports C/C++
Xcode; you must use the standard etags for Lisp, TeX, FORTRAN, etc.).
X
X
XHere are excerpts from the important files:
X
X======================
X;;; tags.el
X
X;; INTELLECTION MODS:
X;; 
X;; 1) Prefers the tags named explicitly after C-A's at the end of each line.
X;;    This is true both for find-tag and for the completion-alist.
X;; 2) Support for C++ scoping -- class::name is considered a tag and both
X;;    class::name and name are matches (class::name preferred though).
X;; 3) Support for completion of scoped names as well as unscoped names.
X;;    That is, the alist contains both the fully-scoped name, and each
X;;    subname (c1::c2::mem => c1::c2::mem, c2::mem, and mem in the alist).
X;; 4) Added mechanism to save out the completion alist into TAGS.alist
X;;    which is checked for when loading TAGS to prevent the need to rebuild
X;;    the alist (which can take a while with large systems).  As an added
X;;    advantage, this mechanism removes duplicates from the alist before
X;;    saving it out (making it faster and much smaller).
X
X======================
X;;; hier-mode.el
X;;; Hierarchy mode (for hierarchies output by hier++)
X
X"Major mode for viewing class hierarchy files output by hier++.
XThe file is formatted like this:
X
X* class_a 
X  * child_b  :class_a
X  * child_c  :class_a :class_f
X    * grandchild_d  :child_c
X    * grandchild_e  :child_c
X* class_f
X  * child_c  :class_a :class_f
X    * grandchild_d  :child_c
X    * grandchild_e  :child_c
X  * child_g  :class_f
X
XClasses child_b and child_c are derived from class_a; classes child_c and
Xchild_g are derived from class_f; classes grandchild_d and grandchild_e are
Xboth derived from child_c.  Note that each class (and all of its children) 
Xwill appear in the file once under each parent.
X
XDefined keys:
XM-p moves to the previous sibling
XM-n moves to the next sibling
XM-u moves up to the parent
XM-h finds the first occurrence of the hierarchy element for a class 
X    (similar to M-. in behavior)
XM-g finds the next occurrence (like M-,) in the case of multiple-inheritance.
XM-m brings up a new window with a listing of all the members (both direct and 
X    inherited) of that hierarchy entry.  It does this via tags, so you must 
X    have tags set up in Emacs.  It will also only work properly if the tags 
X    file was generated by etags++ (companion to hier++)."
X
X======================
X;;; class-manual.el
X;;; Class Manual Generation
X;;;   Code to use hier-mode (for hierarchies output by hier++) and etags++
X;;;   functionality to build a class manual using the header comments in 
X;;;   the code itself.  The formatting is in standard texinfo.
X;;;   This is a hack that has been helpful for us, given our coding 
X;;;   guidelines.  It will likely need modification to produce good
X;;;   output for you.  (Header comments are those placed between the 
X;;;   signature and the body of functions or classes.  If you don't follow
X;;;   this convention, then this code will need modification.)
X
X======================
X;;; goto-file.el
X
X;;; By binding goto-file to a key or mouse stroke, you can essentially
X;;; make filenames "hot"; it will attempt to find that file in the 
X;;; current buffer's default directory.  If no such file exists, then 
X;;; it checks the current tags-table, gambling that it is one of your
X;;; source files and will be tagged.
X;;;
X;;; Furthermore, it will try to go to the right location in the file.
X;;; If there is an adjacent line number, then it will go to that line.
X;;; Or if there is an adjacent grep pattern, then it will find that pattern.
X;;;
X;;; For instance, if you are in a shell and do an "ls", you can then click on
X;;; any file name to open the file.  If you do a "make", you can click on any
X;;; error msg to take you to the line of the error.  If you are in dbx, and it
X;;; outputs a break or an assert outputs file/line, then you can simply click
X;;; on the filename to take you to the line.  If you do a "grep", then you
X;;; can simply click on the filename of the match that you want to go to.
X;;; IMO, this is preferable to M-x compile or grep, because there is no need
X;;; to proceed in order.  It also works everywhere: in source files, in
X;;; shells, in night build logs, in mail buffers, etc.
X
X======================
X// etags++/c++file.c
X//
X// This .c file, written in C++, is intended to be included in etags++.c and hier++.c.
X// It is a quick-and-dirty "fuzzy" parser for C++ files that identifies enough tokens for
X// etags++ and hier++ to do a good job.  See those files for information on the resultant
X// functionality.  This file simply provides the common parsing code.
X
X======================
X// etags++/etags++.c
X//
X// This program reads in C++ code and generates a tags file for GNU Emacs.
X// This program is more sophisticated than the standard etags program for C++
X// programs.  It finds all classes, structs, unions, enums, enumerators, #defines,
X// typedefs, functions (both global and member), and data (both global and member).
X// Furthermore, it handles C++ scoping correctly, outputting fully-scoped tags
X// at the end of each line.  Thus, we have modified our Emacs tags.el to search
X// the fully-scoped names at the ends of the lines before the patterns.  It also
X// handles template syntax.
X//
X// In addition, we have added support for a few important macro conventions that
X// we use.  DECLARE_*(name,..) macros define the tag <name> in the current scope;
X// DEFINE_*(class,name,...) macros define the tag <class>::<name>.  We use NOTE(name)
X// macros to name comments, so that you can refer to them by See::name in other
X// comments.  In Emacs, M-. on See::name will take you to the named comment.
X//
X// Note that this uses "fuzzy", quick-and-dirty parsing to find the tokens.  Thus, it
X// can miss some things.  Also note that this is not an etags replacement -- it only
X// supports C/C++ code.  The etags program will still be needed for TeX, Fortran, etc.
X
X======================
X// etags++/hier++.c
X//
X// This program reads in C++ code and generates a "hier" file that displays the
X// class hierarchy.  You can then use the GNU Emacs hier-mode for traversing the
X// hierarchy and extracting information from your TAGS (if generated by etags++).
X//
X// Note that this program is built on the same quick-and-dirty "fuzzy" parser
X// that etags++ was, and will suffer the same ability to be fooled sometimes.
END_OF_FILE
  if test 9444 -ne `wc -c <'cie/README'`; then
    echo shar: \"'cie/README'\" unpacked with wrong size!
  fi
  # end of 'cie/README'
fi
if test -f 'cie/cie-mouse.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/cie-mouse.el'\"
else
  echo shar: Extracting \"'cie/cie-mouse.el'\" \(9055 characters\)
  sed "s/^X//" >'cie/cie-mouse.el' <<'END_OF_FILE'
X;;; Mouse Settings to make tagnames and filenames "mouseable"
X
X;; Left = This Window;  Middle = Other Window
X
X;; Shift = Tag
X(define-key mouse-map x-button-s-left          'x-find-tag-default)
X(define-key mouse-map x-button-s-left-up       'x-mouse-ignore)
X(define-key mouse-map x-button-s-middle        'x-find-tag-default-other-window)
X(define-key mouse-map x-button-s-middle-up     'x-mouse-ignore)
X;; Control = File
X(define-key mouse-map x-button-c-left          'x-goto-file)
X(define-key mouse-map x-button-c-left-up       'x-mouse-ignore)
X(define-key mouse-map x-button-c-middle        'x-goto-file-other-window)
X(define-key mouse-map x-button-c-middle-up     'x-mouse-ignore)
X
X
X(autoload 'find-tag-default "tags" "Find potential tag at point.")
X
X(defun x-find-tag (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (find-tag tag)
X    ;; Wait for and discard the button-up key so the message is not flushed.
X    (sit-for 1)
X    (discard-input)
X    (message "Find tag: %s" tag)))
X
X
X(defun x-find-tag-default (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (message "Find tag: %s" tag)
X    (find-tag tag) ))
X
X
X(defun x-find-tag-default-other-window (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (message "Find tag: %s" tag)
X    (find-tag-other-window tag) ))
X
X
X(defun x-goto-file (arg)
X  (x-mouse-set-point arg)
X  (let ((goto-file-other-window-p nil))
X    (goto-file) ) )
X
X
X(defun x-goto-file-other-window (arg)
X  (x-mouse-set-point arg)
X  (let ((goto-file-other-window-p t))
X    (goto-file) ) )
X
X
X
X;;;===== Mouse Command Defuns
X
X(defvar x-auto-mouse-select nil
X  "When non-nil, always select the window containing the mouse.")
X
X;;; Redefined from x-mouse.el - dont leave the minibuffer via the mouse
X(defun x-mouse-select (arg)
X  "Select Emacs window the mouse is on."
X  (let ((start-w (selected-window))
X	(done nil)
X	(w (selected-window))
X	(rel-coordinate nil))
X    (while (and (not done)
X		(null (setq rel-coordinate
X			    (coordinates-in-window-p arg w))))
X      (setq w (next-window w))
X      (if (eq w start-w)
X	  (setq done t)))
X    ;; Dont allow the user to exit the minibuffer using the mouse.
X    (if (and (eq (selected-window) (minibuffer-window))
X	     (not (eq w (minibuffer-window))))
X	(error ""))
X    (select-window w)
X    rel-coordinate))
X
X
X(defun x-scroll-up (arg)
X  "Scroll up the window the mouse is over."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (scroll-up nil)
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-scroll-down (arg)
X  "Scroll down the window the mouse is over."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (scroll-down nil)
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-line-to-top (arg)
X  "Scroll line at the mouse to top of window."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (save-excursion
X	    (x-mouse-set-point arg)
X	    (line-to-top-of-window))
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-line-to-bottom (arg)
X  "Scroll line at the mouse to bottom of window."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (save-excursion
X	    (x-mouse-set-point arg)
X	    (line-to-bottom-of-window))
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-scroll-up-one (arg)
X  "Scroll the window at the mouse one line up."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (scroll-one-line-up 1)
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-scroll-down-one (arg)
X  "Scroll the window at the mouse one line up."
X  (let ((owin (selected-window)))
X    (if (x-mouse-select arg)
X	(progn
X	  (scroll-one-line-down 1)
X	  (or (eq owin (selected-window))
X	      x-auto-mouse-select
X	      (select-window owin))))))
X
X
X(defun x-enlarge-window (arg)
X  "Select Emacs window mouse is on, then grow it by one line."
X  (if (x-mouse-select arg)
X      (enlarge-window 1)))
X
X
X;;; Redefined to blink cursor around region
X(defun x-cut-text (arg &optional kill)
X  "Copy text between point and mouse position into window system cut buffer.
XSave in Emacs kill ring also."
X  (if (coordinates-in-window-p arg (selected-window))
X      (save-excursion
X	(let ((opoint (point))
X	      beg end)
X	  (x-mouse-set-point arg)
X	  (sit-for 1)
X	  (setq beg (min opoint (point))
X		end (max opoint (point)))
X	  (x-store-cut-buffer (buffer-substring beg end))
X	  (copy-region-as-kill beg end)
X	  (if kill (delete-region beg end))))
X    (message "Mouse not in selected window")))
X
X
X(defun x-cut-sexp (arg &optional kill)
X  "Copy sexp starting at mouse into window system cut buffer.
XSave in Emacs kill ring also."
X  (save-window-excursion
X    (x-mouse-select arg)
X    (save-excursion
X      (x-mouse-set-point arg)
X      (let ((beg (point))
X	    end)
X	(discard-input)
X	(sit-for 1)
X	(forward-sexp 1)
X	(sit-for 1)
X	(setq end (point))
X	(x-store-cut-buffer (buffer-substring beg end))
X	(copy-region-as-kill beg end)
X	(if kill (delete-region beg end))
X	))))
X
X
X(defun x-paste-sexp (arg)
X  "Copy sexp at mouse into cut buffer and then paste at cursor."
X  (x-cut-sexp arg)
X  (insert (x-get-cut-buffer)))
X
X
X(defun x-cut-and-wipe-word (arg)
X  "Kill the word at the mouse."
X  (x-mouse-set-point arg)
X  (let ((beg (point))
X	(end (save-excursion (forward-word 1) (point))))
X    (x-store-cut-buffer (buffer-substring beg end))
X    (copy-region-as-kill beg end)
X    (delete-region beg end)))
X
X
X(defun x-cut-and-wipe-sexp (arg)
X  "Kill the sexp at the mouse."
X  (x-mouse-set-point arg)
X  (let ((beg (point))
X	(end (save-excursion (forward-sexp 1) (sit-for 1) (point))))
X    (x-store-cut-buffer (buffer-substring beg end))
X    (copy-region-as-kill beg end)
X    (delete-region beg end)))
X
X
X(defun x-find-tag (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (find-tag tag)
X    ;; Wait for and discard the button-up key so the message is not flushed.
X    (sit-for 1)
X    (discard-input)
X    (message "Find tag: %s" tag)))
X
X
X(defun x-find-tag-default (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (message "Find tag: %s" tag)
X    (find-tag tag) ))
X
X
X(defun x-find-tag-default-other-window (arg)
X  (x-mouse-set-point arg)
X  (let ((tag (find-tag-default))) 
X    (message "Find tag: %s" tag)
X    (find-tag-other-window tag) ))
X
X
X(defun x-goto-file (arg)
X  (x-mouse-set-point arg)
X  (let ((goto-file-other-window-p nil))
X    (goto-file) ) )
X
X
X(defun x-goto-file-other-window (arg)
X  (x-mouse-set-point arg)
X  (let ((goto-file-other-window-p t))
X    (goto-file) ) )
X
X
X(defun x-search-forward (arg)
X  (x-mouse-set-point arg)
X  (skip-chars-forward " \t")
X  (let* ((end (progn (forward-sexp 1) (point)))
X	 (start (save-excursion (forward-sexp -1) (point)))
X	 (string (buffer-substring start end)))
X    (search-forward string)))
X
X
X(defun x-search-backward (arg)
X  (x-mouse-set-point arg)
X  (skip-chars-forward " \t")
X  (let* ((end (progn (forward-sexp 1) (point)))
X	 (start (progn (forward-sexp -1) (point)))
X	 (string (buffer-substring start end)))
X    (search-backward string)))
X
X
X;; Redefined to prevent clobbering "last-command" which is used by
X;; x-search-forward/backward
X
X(defun x-flush-mouse-queue () 
X  "Process all queued mouse events."
X  ;; A mouse event causes a special character sequence to be given
X  ;; as keyboard input.  That runs this function, which process all
X  ;; queued mouse events and returns.
X  (interactive)
X  (while (> (x-mouse-events) 0)
X    (x-proc-mouse-event)
X    (and (boundp 'x-process-mouse-hook)
X	 (symbol-value 'x-process-mouse-hook)
X	 (funcall x-process-mouse-hook x-mouse-pos x-mouse-item)))
X  
X  )
X
X
X;; the following function may look very much like x-buffer-menu
X(defun x-command-history-menu (arg)
X  "Pop up a menu of command history for selection with the mouse."
X  (let ((menu
X         (list "Command History Menu"
X               (cons "Select Command"
X                     (let ((tail command-history)
X                           (prev "^ "); non existent command
X                           head)
X                       (while tail
X                         (let ((elt (car tail)))
X                           (if (not (string-match prev
X                                                  (prin1-to-string elt)))
X                               (setq head (cons
X                                           (cons
X                                             (setq prev (prin1-to-string elt))
X                                            elt)
X                                           head))))
X                         (setq tail (cdr tail)))
X                       (if head (reverse head)
X                         (setq head (cons (cons "command-history empty"
X                                                (prin1-to-string nil)) head)))
X                       )))))
X    (eval (x-popup-menu arg menu))))
END_OF_FILE
  if test 9055 -ne `wc -c <'cie/cie-mouse.el'`; then
    echo shar: \"'cie/cie-mouse.el'\" unpacked with wrong size!
  fi
  # end of 'cie/cie-mouse.el'
fi
if test -f 'cie/cie.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/cie.el'\"
else
  echo shar: Extracting \"'cie/cie.el'\" \(1529 characters\)
  sed "s/^X//" >'cie/cie.el' <<'END_OF_FILE'
X;;; Example Settings for CIE (c++_in_emacs) package
X;;; Put desirable ones in your default.el, or simply load this file.
X
X
X;;; You should add the following settings to your .emacs,
X;;; modified as appropriate (esp. if you use save-tags-completion-alist)
X;
X;(setq tags-file-name "~/project/TAGS")
X;(setq hier-file-name "~/project/CLASS.hier")
X
X
X;;;===== Goto-File
X(global-set-key "\C-c\C-f" 'goto-file)
X(autoload 'goto-file "goto-file" 
X	  "Goto file (and line number or pattern) named at point." t)
X
X
X;;;===== Hierarchy Mode (for .hier files created by hier++)
X
X(autoload 'hier-mode          "hier-mode" "Mode for viewing hierarchies generated by hier++." t)
X
X(setq auto-mode-alist (cons (cons "\\.hier$" 'hier-mode) auto-mode-alist))
X
X;;; add these functions to C++-mode keys
X
X(autoload 'class-hierarchy    "hier-mode" "Display the hierarchy for the given class."  t)
X(autoload 'class-members      "hier-mode" "Display all members for the given class."    t)
X(autoload 'class-data-members "hier-mode" "Display data members for the given class."   t)
X
X(setq c++-mode-hook 
X      '(lambda ()
X	 (define-key c++-mode-map "\C-ch" 'class-hierarchy)
X	 (define-key c++-mode-map "\C-cm" 'class-members)
X	 (define-key c++-mode-map "\C-cd" 'class-data-members)))
X
X
X;;;===== Minibuffer Yank (yank in the default)
X
X(autoload 'minibuffer-yank "minibuffer-yank" "Utility to yank in defaults." t)
X
X(define-key minibuffer-local-completion-map "\C-c\C-y" 'minibuffer-yank)
X(define-key minibuffer-local-must-match-map "\C-c\C-y" 'minibuffer-yank)
END_OF_FILE
  if test 1529 -ne `wc -c <'cie/cie.el'`; then
    echo shar: \"'cie/cie.el'\" unpacked with wrong size!
  fi
  # end of 'cie/cie.el'
fi
if test -f 'cie/class-manual.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/class-manual.el'\"
else
  echo shar: Extracting \"'cie/class-manual.el'\" \(8751 characters\)
  sed "s/^X//" >'cie/class-manual.el' <<'END_OF_FILE'
X;;; class-manual.el
X;;; Class Manual Generation
X;;;   Code to use hier-mode (for hierarchies output by hier++) and etags++
X;;;   functionality to build a class manual using the header comments in 
X;;;   the code itself.  The formatting is in standard texinfo.
X;;;   This is a hack that has been helpful for us, given our coding 
X;;;   guidelines.  It will likely need modification to produce good
X;;;   output for you.  (Header comments are those placed between the 
X;;;   signature and the body of functions or classes.  If you don't follow
X;;;   this convention, then this code will need modification.)
X
X;;; Copyright (C) 1993, Intellection Inc.
X;;;
X;;; Author: Brian M Kennedy (kennedy@intellection.com)
X;;;
X;;; This program is free software; you can redistribute it and/or modify
X;;; it under the terms of the GNU General Public License as published by
X;;; the Free Software Foundation; either version 1, or (at your option)
X;;; any later version.
X;;;
X;;; This program is distributed in the hope that it will be useful,
X;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
X;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X;;; GNU General Public License for more details.
X;;;
X;;; A copy of the GNU General Public License can be obtained from the
X;;; Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X;;; 92/09     Brian M Kennedy  Original 
X
X(provide 'class-manual)
X(require 'hier-mode)
X
X
X;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
X;; Manual Generation
X
X(defvar class-manual-copyright-string "1992 Intellection, Inc."
X  "The desired copyright string to be put on the title page entry 
X   generated by hier-insert-header.")
X
X
X(defun insert-class-manual-header (title)
X  "Insert the leading texinfo header necessary to for the other
X   insert-class-manual- commands."
X  (interactive "sTitle for document: ")
X  (insert "\\input texinfo	@c -*-texinfo-*-" ?\n
X	  "@comment %**start of header" ?\n
X	  "@settitle " title ?\n
X	  "@setchapternewpage off" ?\n
X	  "@comment %**end of header" ?\n
X	  "" ?\n
X	  "@titlepage" ?\n
X	  "@sp 8" ?\n
X	  "@center @titlefont{" title "}" ?\n
X	  "" ?\n
X	  "@vskip 0pt plus 1filll" ?\n
X	  "@center Class Manual generated via hier++ on " (current-time-string) ?\n
X	  "@center Copyright @copyright{} " class-manual-copyright-string ?\n
X	  "@end titlepage" ?\n)
X  )
X
X
X(defun insert-all-class-manual-entries (only-if-commented-p members-p)
X  "For every class in the named hier++ generated hierarchy file, in 
X   alphabetic order, call hier-insert-class-entry to insert a manual
X   entry about the class into the current buffer."
X  (interactive (list (y-or-n-p "Generate entries only if commented? ")
X		     (y-or-n-p "Generate entries for class members? ") ))
X  (if (not hier-file-name)
X      (prompt-for-hier-file-name))
X  (let (class-list)
X    (save-excursion
X      (message "Collecting class names...")
X      (find-file hier-file-name)
X      (goto-char (point-min))
X      (while (search-forward "* " nil t)
X	(setq class-list
X	      (add-unique-string (buffer-substring (point) 
X						   (progn (while (looking-at "\\sw\\|\\s_")
X							    (forward-char 1))
X							  (point)))
X				 class-list) ) ) )
X    (insert "@chapter Classes Descriptions" ?\n)
X    (while class-list
X      (insert-class-manual-entry (car class-list) only-if-commented-p members-p)
X      (setq class-list (cdr class-list)) ) ) )
X
X
X(defun insert-class-manual-entry (class-name only-if-commented-p members-p)
X  "Insert manual entry for given class into current buffer at point.
X   It will contain the class name, a list of its direct base classes,
X   a list of its direct descendants, a description, and a list of 
X   entries for each of its members."
X  (interactive (list (prompt-for-tag "Insert manual entry for class: ")
X		     (y-or-n-p "Generate entries only if commented? ")
X		     (y-or-n-p "Generate entries for class members? ") ))
X  (if (not hier-file-name)
X      (prompt-for-hier-file-name))
X  (message "Generating manual entry for %s..." class-name)
X
X  (let (base-list derived-list comments)
X    ;; collect class info
X    (save-excursion
X      (find-file hier-file-name)
X      (hier-find class-name)
X      (setq base-list (sort (hier-base-list) 'string<))
X      (setq derived-list (sort (hier-derived-list) 'string<))
X      (if (find-tag-if-present class-name) 
X	  (let ((end (save-excursion (re-search-forward "^[^/\n]*\\(;\\|{\\)" nil t) (point))))
X	    (while (search-forward "//" end t)
X	      (if (looking-at " ") (forward-char 1))
X	      (setq comments (concat comments "\n"
X				     (buffer-substring (point)
X						       (progn (end-of-line) (point)) ) )) ) 
X	    ) ) )
X    ;; print class info 
X    (if (or comments (not only-if-commented-p))
X	(progn
X	  (insert ?\n ?\n ?\n "@section " class-name ?\n)
X  
X	  (insert ?\n ?\n "@subsection Immediate Class Hierarchy" ?\n)
X	  ;; Base Classes
X	  (insert "The class " class-name " has ")
X	  (if (not base-list)
X	      (insert "no base classes." ?\n)
X	    (let ((num (length base-list)))
X	      (insert (int-to-string num) 
X		      (if (> num 1) " base classes:  " " base class:  ") 
X		      (car base-list) ) )
X	    (while (setq base-list (cdr base-list))
X	      (insert (if (cdr base-list) ", " ", and ") (car base-list)) ) 
X	    (insert "." ?\n) )
X	  ;; Derived Classes
X	  (insert "The class " class-name " has ")
X	  (if (not derived-list)
X	      (insert "no derived classes." ?\n)
X	    (let ((num (length derived-list)))
X	      (insert (int-to-string num) 
X		      (if (> num 1) " derived classes:  " " derived class:  ") 
X		      (car derived-list) ) )
X	    (while (setq derived-list (cdr derived-list))
X	      (insert (if (cdr derived-list) ", " ", and ") (car derived-list)) ) 
X	    (insert "." ?\n) )
X	  ;; Comment-based Description
X	  (insert ?\n ?\n "@subsection Description" ?\n
X		  ?\n (if comments (texify comments) "[No class comments found.]") ?\n)
X	  ;; Members
X	  (if members-p
X	      (let (member-list)
X		;; collect members
X		(save-excursion
X		  (visit-tags-table-buffer)
X		  (while (search-forward (concat "\C-a" class-name "::") nil t)
X		    (skip-chars-backward "^\C-a")
X		    (setq member-list 
X			  (add-unique-string (buffer-substring (point)
X							       (progn (end-of-line) (point))) 
X					     member-list))
X		    (forward-line 1) ))
X		;; print members
X		(insert ?\n ?\n "@subsection Members" ?\n)
X		(while member-list
X		  (insert-member-manual-entry (car member-list) only-if-commented-p)
X		  (setq member-list (cdr member-list)) )
X		) )
X	  )
X      )
X    )
X  )
X
X
X(defun insert-member-manual-entry (tag only-if-commented-p)
X  "Insert the member description for class member `tag`."
X  (interactive (list (prompt-for-tag "Insert manual entry for member: ")))
X  (let (entry comments)
X    ;; collect info
X    (save-excursion
X       (if (find-tag-if-present tag) 
X	   (let ((start (save-excursion 
X			  (re-search-backward "^[ \t\f]*$\\|;\\|{\\|}" nil t) 
X			  (forward-line 1)
X			  (point)))
X		 (h-end (save-excursion 
X			  (re-search-forward "^[ \t\f]*$\\|)\\|;\\|^[ \t]*:\\|{\\|}" nil t) 
X			  (skip-chars-backward ":{;")
X			  (point))) 
X		 (c-end (save-excursion 
X			  (re-search-forward "^[^/\n]*\\(;\\|{\\|}\\)" nil t) (point))) )
X	     (setq entry (buffer-substring start h-end)) 
X	     (while (search-forward "//" c-end t)
X	       (if (looking-at " ") (forward-char 1))
X	       (setq comments (concat comments "\n"
X				      (buffer-substring (point)
X							(progn (end-of-line) (point)) ) )) )
X	     ) ) )
X    ;; print info
X    (if (or comments (not only-if-commented-p))
X	(insert ?\n "@example" ?\n
X		(if entry entry "[This tag not found.]") ?\n
X		"@end example" ?\n
X		?\n (if comments (texify comments) "[No comments found.]") ?\n) )
X    )
X  )
X
X
X;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
X;; Internal Functions
X
X(defun add-unique-string (string list)
X  "Add `string` into `list` in alphabetic order, 
X   only if `string` is not already in `list`.
X   Assumes that `list` is a sorted list of strings."
X  (if (or (not list) (string-lessp string (car list)))
X      (cons string list)
X    (let ((prev list))
X      (while (and (cdr prev) (string< (car (cdr prev)) string))
X	(setq prev (cdr prev)))
X      (if (or (not (cdr prev)) (not (string= (car (cdr prev)) string)))
X	  (setcdr prev (cons string (cdr prev))) )
X      list)
X    )
X  )
X
X
X(defun find-tag-if-present (tagname &optional next other-window)
X  "Do find-tag with args.  If no error, return t; otherwise return nil."
X  (condition-case signals
X      (progn (find-tag tagname next other-window)
X	     t)
X    (error nil) ) )
X
X
X(defun texify (string)
X  "Return string with TeX special chars @, {, } changed to spaces."
X  (let ((pos 0))
X    (while pos
X      (setq pos (string-match "{\\|}\\|@\\|\\\\" string pos))
X      (if pos (aset string pos ? )) ) 
X    string) )
END_OF_FILE
  if test 8751 -ne `wc -c <'cie/class-manual.el'`; then
    echo shar: \"'cie/class-manual.el'\" unpacked with wrong size!
  fi
  # end of 'cie/class-manual.el'
fi
if test -f 'cie/do-etags++' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/do-etags++'\"
else
  echo shar: Extracting \"'cie/do-etags++'\" \(1252 characters\)
  sed "s/^X//" >'cie/do-etags++' <<'END_OF_FILE'
X#!/usr/local/bin/bash
X#
X# THIS IS JUST AN EXAMPLE.
X# IT IS HIGHLY UNLIKELY THAT THIS IS USEFUL, AS-IS, FOR ANYONE.
X#
X# do-etags++
X#
X# This is an example of using etags++, hier++, and emacs in batch mode
X# to save out the tags-completion-alist in TAGS.alist.
X#
X# 1) Goes to my code directory (where TAGS should be created)
X# 2) Runs etags++ on all my source (.c files first so that M-. finds
X#    the definitions before the declarations)
X# 3) Loads up an Emacs with the tags just generated (depends upon $USER's
X#    .emacs having (setq tags-file-name "~/project/TAGS")) and writes out
X#    a TAGS.alist file, so successive Emacs' don't have to rebuild the alist.
X#
X# This is run automatically during my night-build.
X
Xpushd $HOME/project
X
Xetags++ tools/*/*.c \
X        tools/*/*.h  \
X        tools/roguewave/toolsrc/*.c \
X        tools/roguewave/rw/*.h \
X        rhythm/*/*.c \
X        rhythm/*/*.h
X
Xemacs -batch -u $USER -load tags -f save-tags-completion-alist
X# Assumes that -u $USER's .emacs specifies the appropriate TAGS file
X# such that -load tags builds the appropriate tags-completion-alist
X# such that -f save-tags-completion-alist has something to save out.
X
Xhier++  tools/*/*.h  \
X        tools/roguewave/rw/*.h \
X        rhythm/*/*.h
X
Xpopd
END_OF_FILE
  if test 1252 -ne `wc -c <'cie/do-etags++'`; then
    echo shar: \"'cie/do-etags++'\" unpacked with wrong size!
  fi
  chmod +x 'cie/do-etags++'
  # end of 'cie/do-etags++'
fi
if test -f 'cie/etags++/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/etags++/Makefile'\"
else
  echo shar: Extracting \"'cie/etags++/Makefile'\" \(216 characters\)
  sed "s/^X//" >'cie/etags++/Makefile' <<'END_OF_FILE'
XBINS=etags++ hier++
X
XCC=CC
XCCFLAGS=-O
X
Xall:: $(BINS)
X
Xetags++: etags++.c c++file.c
X	$(CC) $(CCFLAGS) -o etags++ etags++.c
X
Xhier++: hier++.c c++file.c
X	$(CC) $(CCFLAGS) -o hier++  hier++.c
X
Xclean:
X	-rm -f $(BINS) *.o
END_OF_FILE
  if test 216 -ne `wc -c <'cie/etags++/Makefile'`; then
    echo shar: \"'cie/etags++/Makefile'\" unpacked with wrong size!
  fi
  # end of 'cie/etags++/Makefile'
fi
if test -f 'cie/etags++/hier++.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/etags++/hier++.c'\"
else
  echo shar: Extracting \"'cie/etags++/hier++.c'\" \(8876 characters\)
  sed "s/^X//" >'cie/etags++/hier++.c' <<'END_OF_FILE'
X////////////////////////////////////////////////////////////////////////////////
X// hier++.c
X//
X// This program reads in C++ code and generates a "hier" file that displays the
X// class hierarchy.  You can then use the GNU Emacs hier-mode for traversing the
X// hierarchy and extracting information from your TAGS (if generated by etags++).
X//
X// Note that this program is built on the same quick-and-dirty "fuzzy" parser
X// that etags++ was, and will suffer the same ability to be fooled sometimes.
X//
X// Author:  Brian M. Kennedy
X// (C) Copyright 1993, Intellection Inc.
X// Permission is granted to use, copy, or modify this code as long as this author and
X// copyright notice is maintained in all copies.
X//
X// Note:
X//   This is quick, hack code that was not written to be modifiable or maintainable -- beware!!
X//   I would not allow code such as this into our product!  But it is okay for a quick tool hack.
X//   If you are a user, I hope you enjoy it.  If you are modifier, my apologies ;-(
X
X#include "c++file.c"
X
X
X////////////////////////////////////////////////////////////////////////////////
X
Xstruct Element;
X
Xstruct Element_Link
X{
X  Element*      element;
X  Element_Link* next;
X
X  Element_Link (Element* element_arg, Element_Link* next_arg = 0);
X  
X};
X
X
XElement_Link::
XElement_Link (Element* element_arg, Element_Link* next_arg)
X:element(element_arg), next(next_arg)
X{}
X
X  
X////////////////////////////////////////////////////////////////////////////////
X
Xstruct Element
X{
X  const char*    name;
X  Element_Link*  parents;
X  Element_Link*  children;
X
X  Element (const C_File_Pos& name_pos);
X
X  static unsigned hash (const C_File_Pos& name);
X  unsigned hash () const;
X  
X  Element_Link* inc_parents  (Element* parent)
X  { return parents  = new Element_Link(parent, parents); }
X  
X  Element_Link* inc_children (Element* child)
X  { return children = new Element_Link(child, children); }
X
X  void print (ostream& os, unsigned indent) const;
X  
X};
X
X
XElement::
XElement (const C_File_Pos& name_pos)
X:name(0), parents(0), children(0)
X{
X  char* copy = new char [name_pos.length + 1];
X  strncpy(copy, name_pos.chars(), name_pos.length);
X  copy[name_pos.length] = 0;
X  name = copy;
X}
X
X
Xunsigned Element::
Xhash (const C_File_Pos& name)
X{
X  unsigned h = 0;
X  const char* s = name.chars();
X  for(unsigned i = 0; i < name.length; ++i, ++s)
X    h = (h << 2) + (unsigned char)(*s);
X  return h;
X}
X
X
Xunsigned Element::
Xhash () const
X{
X  unsigned h = 0;
X  for(const char* s = name; *s; ++s)
X    h = (h << 2) + (unsigned char)(*s);
X  return h;
X}
X
X
Xconst char blank_string [] = "                                        ";
X
Xinline const char*
Xblanks (unsigned n)
X    // Returns a string of 'n' blanks
X{  return blank_string + sizeof(blank_string) - n - 1; }
X
X
Xvoid Element::
Xprint (ostream& os, unsigned indent) const
X{
X  os << blanks(indent) << "* " << name << " ";
X  
X  for(Element_Link* link = parents; link; link = link->next)
X    os << " :" << link->element->name;
X  os << "\n";
X  
X  for(link = children; link; link = link->next)
X    link->element->print(os, indent+2);
X}
X
X    
X////////////////////////////////////////////////////////////////////////////////
X
Xstruct Hierarchy
X{
X  unsigned       size;
X  Element_Link** table;
X
X  Hierarchy (unsigned symbols);
X
X  Element* operator () (const C_File_Pos& name) const;
X  
X  Hierarchy& inc (Element* element);
X  Hierarchy& inc (const C_File_Pos& name) { return inc(new Element(name)); }
X
X  void print (ostream& os);
X
X};
X
X
XHierarchy::
XHierarchy (unsigned symbols)
X:size(2*symbols + 1), table(new Element_Link* [size])
X{
X  for(unsigned i = 0; i < size; ++i)
X    table[i] = 0;
X}
X
X
XElement* Hierarchy::
Xoperator () (const C_File_Pos& name) const
X{
X  unsigned index = Element::hash(name) % size;
X  Element_Link* link = table[index];
X  while(link && ((strlen(link->element->name) != name.length)
X		 || strncmp(link->element->name, name.chars(), name.length)))
X    link = link->next;
X  if(link)
X    return link->element;
X  else
X  { table[index] = new Element_Link(new Element (name), table[index]);
X    return table[index]->element;
X  }
X}
X
X
XHierarchy& Hierarchy::
Xinc (Element* element)
X{
X  unsigned index = element->hash() % size;
X  table[index] = new Element_Link(element, table[index]);
X  return *this;
X}
X
X
Xvoid Hierarchy::
Xprint (ostream& os)
X{
X  for(unsigned index = 0; index < size; ++index)
X  { for(Element_Link* link = table[index]; link; link = link->next)
X    { if(!link->element->parents)
X	link->element->print(os, 0);
X    }
X  }
X}
X
X
X////////////////////////////////////////////////////////////////////////////////
X
Xinline void
Xparent_child (Element* parent, Element* child)
X{
X  parent->inc_children(child);
X  child->inc_parents(parent);
X}
X
X
XBoolean
Xaccess_kw_p (const C_File_Pos& name)
X{
X  const char* s = name.chars();
X  if(*s == 'p')
X  {
X    switch(name.length)
X    {
X    case 6:  return !strncmp(s, "public",    6);
X    case 7:  return !strncmp(s, "private",   7) ;
X    case 9:  return !strncmp(s, "protected", 9);
X    default: return FALSE;
X    }
X  }
X  else if (*s == 'v')
X  {
X    switch(name.length)
X    {
X    case 7:  return !strncmp(s, "virtual",   7) ;
X    default: return FALSE;
X    }
X  }
X  else
X    return FALSE;
X}
X
X
X////////////////////////////////////////////////////////////////////////////////
X
XHierarchy&
Xget_class_hier (Hierarchy& hier, const File& file)
X{
X  C_File_Pos pos (file);
X  while(pos.token != END_OF_FILE)
X  {
X    switch(pos.token)
X    {
X    case CLASS_KW:
X    case STRUCT_KW:
X      pos.next_code();
X      if(pos.token == IDENTIFIER)
X      { Element* child = hier(pos);
X	pos.next_code();
X	while(pos.token != SEMI_COLON && pos.token != OPEN_BRACE && pos.token != END_OF_FILE)
X	{
X	  if(pos.token == IDENTIFIER && !access_kw_p(pos))
X	  { Element* parent = hier(pos);
X	    parent_child(parent, child);
X	  }
X	  pos.next_code();
X	}
X      }
X      else
X      { while(pos.token != SEMI_COLON && pos.token != OPEN_BRACE && pos.token != END_OF_FILE)
X	  pos.next_code();
X      }
X      if(pos.token == OPEN_BRACE)
X	pos.close_brace();
X      break;
X    case UNION_KW:
X    case ENUM_KW:
X      pos.next_code();
X      while(pos.token != SEMI_COLON && pos.token != OPEN_BRACE && pos.token != END_OF_FILE)
X	pos.next_code();
X      if(pos.token == OPEN_BRACE)
X	pos.close_brace();
X      break;
X    case TYPEDEF_KW:		// only catches last typedef (e.g 'c' in typedef int a, b, c;)
X      pos.next_code();
X      while(pos.token != SEMI_COLON && pos.token != END_OF_FILE)
X	pos.next_code();
X      break;
X    case DEFINE:
X      pos.close_define();
X      break;
X    case OPEN_BRACE:
X      pos.close_brace();
X      break;
X    case OPEN_PARE:
X      pos.close_pare();
X      break;
X    }
X    pos.next_code();
X  }
X  return hier;
X}
X
X
X////////////////////////////////////////////////////////////////////////////////
X
Xvoid
Xusage_error (const char* progname)
X{ cerr << "Usage " << progname;
X  cerr << " [-a] [-f outfile] [-s num_symbols] [-k max_infile_kbytes] infile ...";
X  cerr << endl;
X  exit(BAD);
X}
X
X
Xmain (int argc, char** argv)
X{
X  unsigned argi = 0;
X  char* progname = argv[argi];
X  
X  // Default flags
X  Boolean     append     = FALSE;
X  const char* outfile    = 0;
X  int         size       = 1024;
X  int         symbols    = 2000;
X  
X  // Process flags
X  for(argi = 1; argi < argc && argv[argi][0] == '-'; ++argi)
X  {
X    switch(argv[argi][0])
X    {
X    case '?':
X    case 'h':
X      usage_error(progname);
X    case 'a':
X      append = TRUE;
X      break;
X    case 'f':
X      if(outfile)
X      { cerr << "The -f option may only be given once." << endl;
X	usage_error(progname);
X      }
X      if(argv[argi][1])
X	outfile = &argv[argi][1];
X      else if(argi < argc)
X	outfile = argv[++argi];
X      else
X      { cerr << "The -f option must be given an argument (the outfile name)" << endl;
X	usage_error(progname);
X      }
X      break;
X    case 'k':
X      if(argv[argi][1])
X	size = atoi(&argv[argi][1]);
X      else if(argi < argc)
X	size = atoi(argv[++argi]);
X      else
X      { cerr << "The -k option must be given an argument (the max_file_size in kbytes)" << endl;
X	usage_error(progname);
X      }
X      break;
X    case 's':
X      if(argv[argi][1])
X	symbols = atoi(&argv[argi][1]);
X      else if(argi < argc)
X	symbols = atoi(argv[++argi]);
X      else
X      { cerr << "The -s option must be given an argument (the expected number of symbols)" << endl;
X	usage_error(progname);
X      }
X      break;
X    default:
X      ;
X    }
X  }
X  
X  // Arg value checks
X  if(size < 64)
X    size = 64;
X  if(symbols < 1000)
X    symbols = 1000;
X  if(!outfile)
X    outfile = "CLASS.hier";
X  
X  // Create File for input
X  File infile (size*1024);
X
X  // Create empty hierarchy
X  Hierarchy hier (symbols);
X  
X  // Process files into hier
X  for(; argi < argc; ++argi)
X  {
X    infile.read(argv[argi]);
X    get_class_hier(hier, infile);
X  }
X
X  // Output hierarchy
X  ofstream out (outfile, (append ? ios::app : ios::out));
X  hier.print(out);
X  out << flush;
X
X  exit(GOOD);
X}
END_OF_FILE
  if test 8876 -ne `wc -c <'cie/etags++/hier++.c'`; then
    echo shar: \"'cie/etags++/hier++.c'\" unpacked with wrong size!
  fi
  # end of 'cie/etags++/hier++.c'
fi
if test -f 'cie/goto-file.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cie/goto-file.el'\"
else
  echo shar: Extracting \"'cie/goto-file.el'\" \(5953 characters\)
  sed "s/^X//" >'cie/goto-file.el' <<'END_OF_FILE'
X;;; goto-file.el
X
X;;; By binding goto-file to a key or mouse stroke, you can essentially
X;;; make filenames "hot"; it will attempt to find that file in the 
X;;; current buffer's default directory.  If no such file exists, then 
X;;; it checks the current tags-table, gambling that it is one of your
X;;; source files and will be tagged.
X;;;
X;;; Furthermore, it will try to go to the right location in the file.
X;;; If there is an adjacent line number, then it will go to that line.
X;;; Or if there is an adjacent grep pattern, then it will find that pattern.
X;;;
X;;; For instance, if you are in a shell and do an "ls", you can then click on
X;;; any file name to open the file.  If you do a "make", you can click on any
X;;; error msg to take you to the line of the error.  If you are in dbx, and it
X;;; outputs a break or an assert outputs file/line, then you can simply click
X;;; on the filename to take you to the line.  If you do a "grep", then you
X;;; can simply click on the filename of the match that you want to go to.
X;;; IMO, this is preferable to M-x compile or grep, because there is no need
X;;; to proceed in order.  It also works everywhere: in source files, in
X;;; shells, in night build logs, in mail buffers, etc.
X
X;;; Copyright (C) 1993, Intellection Inc.
X;;;
X;;; Author: Brian M Kennedy (kennedy@intellection.com)
X;;;
X;;; This program is free software; you can redistribute it and/or modify
X;;; it under the terms of the GNU General Public License as published by
X;;; the Free Software Foundation; either version 1, or (at your option)
X;;; any later version.
X;;;
X;;; This program is distributed in the hope that it will be useful,
X;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
X;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X;;; GNU General Public License for more details.
X;;;
X;;; A copy of the GNU General Public License can be obtained from the
X;;; Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
X;;; 92/07/23  Brian M Kennedy  Original
X
X(provide 'goto-file)
X
X(require 'tags)
X
X
X(defvar goto-file-chars "-A-Za-z./_=+~#0-9"
X  "Characters that goto-file considers part of a filename.
X   Intentionally does not include (by default) ,:<> and quotes because
X   these are more often delimiters than part of the filename.")
X
X(defvar goto-file-other-window-p t
X  "When non-nil, goto new file in other window.")
X
X(defun goto-file (&optional dont-use-tags-p)
X  "Attempts to identify a filename at or around point.  If it finds one,
X   then it attempts to find a line number of the form 'line nn' on the 
X   same line as the filename.  If there is no line number, then it checks
X   if the filename was followed by a colon.  If so, it assumes it is a 
X   grep-style pattern that was matched in the file.
X   It then tries to find a file by that filename in the current-dirctory.
X   If there is none and the optional argument is nil, then it attempts to
X   identify a file that has been tagged with the same name in order to get a
X   full pathname.
X   If it finds a file (either way), then it opens it in another window.
X   If there was line number information, then it will goto that line.
X   If not, and there was a grep-style pattern, then it searches for that
X   pattern in the file (and sets it up so that you can search for additional
X   matches via incremental search)."
X  (interactive "P")
X  (let ((filename nil)
X	(basename nil)
X	(file     nil)
X	(line     nil)
X	(pattern  nil))
X    (save-excursion
X      ;; Get filename
X      (skip-chars-backward goto-file-chars)
X      (let (start-point base-point end-point)
X	(setq start-point (point))
X	(skip-chars-forward "./~")  ;; strip leading context info for tagfile lookup
X	(setq base-point (point))
X	(skip-chars-forward goto-file-chars)
X	(setq end-point (point))
X	(setq filename (buffer-substring start-point end-point))
X	(setq basename (buffer-substring base-point end-point)) )
X      ;; Get pattern
X      (if (looking-at ":")
X	  (progn (forward-char 1)
X		 (setq pattern (buffer-substring (point)
X						 (progn (end-of-line) (point)))) ))
X      ;; Get line
X      (cond ((looking-at "([0-9]+")
X	     (forward-char 1)
X	     (setq line (string-to-int 
X			 (buffer-substring (point)
X					   (progn (skip-chars-forward "0-9")
X						  (point) )))) )
X	    ((looking-at ".*line [0-9]")
X	     (re-search-forward ".*line ")
X	     (setq line (string-to-int 
X			 (buffer-substring (point)
X					   (progn (skip-chars-forward "0-9")
X						  (point) )))) )
X	    ((re-search-backward "line [0-9]"
X				 (save-excursion (beginning-of-line) (point))
X				 t)
X	     (forward-char 5)
X	     (setq line (string-to-int 
X			 (buffer-substring (point)
X					   (progn (skip-chars-forward "0-9")
X						  (point) )))) )
X	    ))
X    ;; Goto the file
X    (if filename
X	(let ((fullname (expand-file-name filename)))
X	  (if (and (not dont-use-tags-p)
X		   (not (and fullname (file-exists-p fullname))))
X	      (setq fullname (expand-tagged-file-name basename)))
X	  (if (and fullname (file-exists-p fullname))
X	      (progn
X		(if goto-file-other-window-p
X		    (find-file-other-window fullname)
X		  (find-file fullname))
X		(cond (line    (goto-line line))
X		      (pattern (setq search-last-string pattern)
X			       (goto-char (point-min))
X			       (search-forward pattern nil t) )
X		      ))
X	    (if dont-use-tags-p
X		(error "No file named %s is in current directory." filename)
X	      (error "No file named %s is in current or tagged directories." filename)
X	      ) ))
X      (error "No filename found at point.") )))
X
X
X
X(defun expand-tagged-file-name (filename)
X  "Find a tagged file with a name that includes 'filename' in it.
X   If one is found, return that file's expanded filename.
X   Otherwise, return nil." 
X  ;; Find the tagged file
X  (save-excursion
X    (visit-tags-table-buffer)
X    (beginning-of-buffer)
X    (if (re-search-forward (concat "\f\n\\(.*/\\)?" filename ",") nil t)
X	(expand-file-name (file-of-tag) (file-name-directory tags-file-name)) )))
END_OF_FILE
  if test 5953 -ne `wc -c <'cie/goto-file.el'`; then
    echo shar: \"'cie/goto-file.el'\" unpacked with wrong size!
  fi
  # end of 'cie/goto-file.el'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
