Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i077:  lout - Lout document formatting system, v2.05, Part09/35
Message-ID: <1993Aug8.180827.11639@sparky.sterling.com>
X-Md4-Signature: 5079abfb16dc52d5c9589db1a1928bcc
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sun, 8 Aug 1993 18:08:27 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 77
Archive-name: lout/part09
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  doc/tr.impl/s3.0 include/eq z37.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:23 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 35)."'
if test -f 'doc/tr.impl/s3.0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s3.0'\"
else
  echo shar: Extracting \"'doc/tr.impl/s3.0'\" \(378 characters\)
  sed "s/^X//" >'doc/tr.impl/s3.0' <<'END_OF_FILE'
X@Section
X    @Title { Definitions }
X@Begin
X@PP
XThe need to provide a means of packaging useful pieces of code for easy
Xrepeated use was recognised in the very earliest programming
Xlanguages.  This need is even more acute in document formatting, if that
Xis possible, because the majority of users are not programmers and do
Xnot understand the code they invoke.
X@BeginSubSections
END_OF_FILE
  if test 378 -ne `wc -c <'doc/tr.impl/s3.0'`; then
    echo shar: \"'doc/tr.impl/s3.0'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s3.0'
fi
if test -f 'include/eq' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/eq'\"
else
  echo shar: Extracting \"'include/eq'\" \(35552 characters\)
  sed "s/^X//" >'include/eq' <<'END_OF_FILE'
X
X###############################################################################
X#                                                                             #
X#  Lout @Eq package for equation formatting (Version 2.0)                     #
X#                                                                             #
X#  Version 1.0 by Jeffrey H. Kingston, December 1990.                         #
X#  Version 2.0 by Jeffrey H. Kingston, 22 December 1992.                      #
X#                                                                             #
X#  This package makes extensive use of the Adobe Systems Symbol font, and     #
X#  it assumes that the font has not been recoded.  It could be rewritten      #
X#  using the @Char symbol to be made independent of any recoding, but since   #
X#  there seems no reason to ever recode this font, I haven't bothered.        #
X#                                                                             #
X#  See "Eq - a Lout package for typesetting mathematics" for user             #
X#  information.  Acknowledgement:  the @Eq language is based closely on       #
X#  the Eqn language of B. W. Kernighan and L. L. Cherry; the spacing rules    #
X#  are similar to those of the TeX system by D. E. Knuth.                     #
X#                                                                             #
X###############################################################################
X
Xexport	"`" "``" "```" bin rel punct non vctr big
X
X	space exclam universal numbersign existential percent
X	ampersand suchthat parenleft parenright asteriskmath
X	plus comma minus period slash zero one two three four
X	five six seven eight nine colon semicolon less equal
X	greater question congruent Alpha Beta Chi Delta Epsilon
X	Phi Gamma Eta Iota thetaone Kappa Lambda Mu Nu Omicron
X	Pi Theta Rho Sigma Tau Upsilon sigmaone Omega Xi Psi Zeta
X	bracketleft therefore bracketright perpendicular underscore
X	radicalex alpha beta chi delta epsilon phi gamma eta iota
X	phione kappa lambda mu nu omicron pi theta rho sigma tau
X	upsilon omegaone omega xi psi zeta braceleft bar braceright
X	similar Upsilonone minute lessequal fraction infinity florin
X	club diamond heart spade arrowboth arrowleft arrowup
X	arrowright arrowdown degree plusminus second greaterequal
X	multiply proportional partialdiff bullet divide notequal
X	equivalence approxequal ellipsis arrowvertex arrowhorizex
X	carriagereturn aleph Ifraktur Rfraktur weierstrass
X	circlemultiply circleplus emptyset intersection union
X	propersuperset reflexsuperset notsubset propersubset
X	reflexsubset element notelement angle gradient registerserif
X	copyrightserif trademarkserif product radical dotmath
X	logicalnot logicaland logicalor arrowdblboth arrowdblleft
X	arrowdblup arrowdblright arrowdbldown lozenge angleleft
X	registersans copyrightsans trademarksans summation parenlefttp
X	parenleftex parenleftbt bracketlefttp bracketleftex
X	bracketleftbt bracelefttp braceleftmid braceleftbt braceex
X	angleright integral integraltp integralex integralbt
X	parenrighttp parenrightex parenrightbt bracketrighttp
X	bracketrightex bracketrightbt bracerighttp bracerightmid
X	bracerightbt
X
X	hbar Re Im partial infty prime nabla surd top bot dbar
X	triangle backslash forall exists neg circle square
X
X	"0" "1" "2" "3" "4" "5" "6" "7" "8" "9"
X
X	sum prod coprod int oint bcap bcup bvee bwedge bodot botimes
X	boplus buplus
X
X	"+" "-" "+-" "-+" setminus cdot times "*" circ div cap cup uplus
X	sqcap sqcup triangleleft triangleright wr bigcirc bigtriangleup
X	bigtriangledown vee wedge oplus ominus otimes oslash odot dagger
X	daggerdbl amalg
X
X	"<" ">" "=" "<=" prec preceq "<<" subset subseteq sqsubseteq
X	in vdash smile frown ">=" succ succeq ">>" supset supseteq
X	sqsupseteq ni dashv mid parallel "==" "~" "-~" asymp "~~"
X	"=~" bowtie propto models doteq perp notsub notin "!=" not
X	"<->" "<--" "-->" up down "<=>" "<==" "==>" dblup dbldown
X	":" "::" ":="
X
X	lpar blpar rpar brpar lbrack blbrack rbrack brbrack lbrace blbrace
X	rbrace brbrace lfloor blfloor rfloor brfloor lceil blceil
X	rceil brceil langle blangle rangle brangle
X
X	";" "," col
X	
X	"!" "?" "%" "(" ")" "[" "]"
X
X	arccos arcsin arctan arg cos cosh cot coth csc deg det dim exp
X	gcd hom inf ker lg lim liminf limsup ln log max min Pr sec sin
X	sinh supr tan tanh mod ldots cdots vdots ddots del grad
X	"..." "'" empty
X	
X	sup sub supp on frac half third over from to widefrom wideto
X	dot dotdot hat tilde vec dyad overbar underbar sqrt root above
X	labove cabove rabove mabove nextcol matrix
X
Xdef @Eq                  
X   body @Body
X@Begin
X
X   def @SkewGap  { 0.05f  }
X   def @SupGap   { 0.40fk }
X   def @ThinGap  { 0.15v  }
X   def @MedGap   { 0.20v  }
X   def @ThickGap { 0.25v  }
X   def @ColGap   { 0.8f   }
X   def @RowGap   { 0.5f   }
X   def @FontRed  { 0.7f   }
X   def @FontInc  { 1.3f   }
X
X   def "`"       { &@ThinGap  }
X   def "``"      { &@MedGap   }
X   def "```"     { &@ThickGap }
X
X   def bin	right x { ``  x ``  }
X   def rel	right x { ``` x ``` }
X   def punct	right x {     x `   }
X   def non	right x { 0c @Break x }
X   def big	right x { @FontInc @Font 0c @Space @FontInc @Break x }
X
X   def @Base    right x { Base @Font x }
X   def @Smaller right x { @FontRed @Font 0c @Space     0.2f @Break x }
X   def @Sym     right x { {Symbol Base} @Font x }
X
X   def @HLine
X      named line { "0.05 ft setlinewidth" }
X   {  
X      { "0 0 moveto xsize 0 lineto" line "stroke" } @Graphic {}
X   }
X
X   def @VLine
X   {
X      "0 0 moveto 0 ysize lineto 0.05 ft setlinewidth stroke" @Graphic {}
X   }
X
X   def vctr
X      right x
X   { @OneRow {   -180d @Rotate { /0.5wo 180d @Rotate { / @OneRow @OneCol x  } }
X	       ^/      @OneRow { /0.5wo      @OneRow { @OneRow @OneCol x ^/ } }
X	     }
X   }
X
X   ###################################################################
X   #                                                                 #
X   #   Full names                                                    #
X   #                                                                 #
X   #   These symbols and their names are taken directly from the     #
X   #   Adobe Systems Inc. Symbol font (see PostScript Language       #
X   #   Reference Manual, pp. 256-257).  The only differences are:    #
X   #                                                                 #
X   #      Adobe:  theta1        Eq:  thetaone                        #
X   #              sigma1             sigmaone                        #
X   #              phi1               phione                          #
X   #              omega1             omegaone                        #
X   #                                                                 #
X   #   These were needed since Lout identifiers do not have digits.  #
X   #                                                                 #
X   ###################################################################
X
X   def space           { @Sym "\040"  }
X   def exclam          { @Sym "\041"  }
X   def universal       { @Sym "\042"  }
X   def numbersign      { @Sym "\043"  }
X   def existential     { @Sym "\044"  }
X   def percent         { @Sym "\045"  }
X   def ampersand       { @Sym "\046"  }
X   def suchthat        { @Sym "\047"  }
X   def parenleft       { @Sym "\050"  }
X   def parenright      { @Sym "\051"  }
X   def asteriskmath    { @Sym "\052"  }
X   def plus            { @Sym "+"     }
X   def comma           { @Sym "\054"  }
X   def minus           { @Sym "-"     }
X   def period          { @Sym "\056"  }
X   def slash           { @Sym "\057"  }
X   def zero            { @Sym "\060"  }
X   def one             { @Sym "\061"  }
X   def two             { @Sym "\062"  }
X   def three           { @Sym "\063"  }
X   def four            { @Sym "\064"  }
X   def five            { @Sym "\065"  }
X   def six             { @Sym "\066"  }
X   def seven           { @Sym "\067"  }
X   def eight           { @Sym "\070"  }
X   def nine            { @Sym "\071"  }
X   def colon           { @Sym "\072"  }
X   def semicolon       { @Sym "\073"  }
X   def less            { @Sym "\074"  }
X   def equal           { @Sym "\075"  }
X   def greater         { @Sym "\076"  }
X   def question        { @Sym "\077"  }
X   def congruent       { @Sym "\100"  }
X   def Alpha           { @Sym "\101"  }
X   def Beta            { @Sym "\102"  }
X   def Chi             { @Sym "\103"  }
X   def Delta           { @Sym "\104"  }
X   def Epsilon         { @Sym "\105"  }
X   def Phi             { @Sym "\106"  }
X   def Gamma           { @Sym "\107"  }
X   def Eta             { @Sym "\110"  }
X   def Iota            { @Sym "\111"  }
X   def thetaone        { @Sym "\112"  }
X   def Kappa           { @Sym "\113"  }
X
X   def Lambda          { @Sym "\114"  }
X   def Mu              { @Sym "\115"  }
X   def Nu              { @Sym "\116"  }
X   def Omicron         { @Sym "\117"  }
X   def Pi              { @Sym "\120"  }
X   def Theta           { @Sym "\121"  }
X   def Rho             { @Sym "\122"  }
X   def Sigma           { @Sym "\123"  }
X   def Tau             { @Sym "\124"  }
X   def Upsilon         { @Sym "\125"  }
X   def sigmaone        { @Sym "\126"  }
X   def Omega           { @Sym "\127"  }
X   def Xi              { @Sym "\130"  }
X   def Psi             { @Sym "\131"  }
X   def Zeta            { @Sym "\132"  }
X   def bracketleft     { @Sym "\133"  }
X   def therefore       { @Sym "\134"  }
X   def bracketright    { @Sym "\135"  }
X   def perpendicular   { @Sym "\136"  }
X   def underscore      { @Sym "\137"  }
X   def radicalex       { @Sym "\140"  }
X   def alpha           { @Sym "\141"  }
X   def beta            { @Sym "\142"  }
X   def chi             { @Sym "\143"  }
X   def delta           { @Sym "\144"  }
X   def epsilon         { @Sym "\145"  }
X   def phi             { @Sym "\146"  }
X   def gamma           { @Sym "\147"  }
X   def eta             { @Sym "\150"  }
X   def iota            { @Sym "\151"  }
X   def phione          { @Sym "\152"  }
X   def kappa           { @Sym "\153"  }
X   def lambda          { @Sym "\154"  }
X   def mu              { @Sym "\155"  }
X   def nu              { @Sym "\156"  }
X
X   def omicron         { @Sym "\157"  }
X   def pi              { @Sym "\160"  }
X   def theta           { @Sym "\161"  }
X   def rho             { @Sym "\162"  }
X   def sigma           { @Sym "\163"  }
X   def tau             { @Sym "\164"  }
X   def upsilon         { @Sym "\165"  }
X   def omegaone        { @Sym "\166"  }
X   def omega           { @Sym "\167"  }
X   def xi              { @Sym "\170"  }
X   def psi             { @Sym "\171"  }
X   def zeta            { @Sym "\172"  }
X   def braceleft       { @Sym "\173"  }
X   def bar             { @Sym "\174"  }
X   def braceright      { @Sym "\175"  }
X   def similar         { @Sym "\176"  }
X   def Upsilonone      { @Sym "\241"  }
X   def minute          { @Sym "\242"  }
X   def lessequal       { @Sym "\243"  }
X   def fraction        { @Sym "\244"  }
X   def infinity        { @Sym "\245"  }
X   def florin          { @Sym "\246"  }
X   def club            { @Sym "\247"  }
X   def diamond         { @Sym "\250"  }
X   def heart           { @Sym "\251"  }
X   def spade           { @Sym "\252"  }
X   def arrowboth       { @Sym "\253"  }
X   def arrowleft       { @Sym "\254"  }
X   def arrowup         { @Sym "\255"  }
X   def arrowright      { @Sym "\256"  }
X   def arrowdown       { @Sym "\257"  }
X   def degree          { @Sym "\260"  }
X   def plusminus       { @Sym "\261"  }
X   def second          { @Sym "\262"  }
X   def greaterequal    { @Sym "\263"  }
X
X   def multiply        { @Sym "\264"  }
X   def proportional    { @Sym "\265"  }
X   def partialdiff     { @Sym "\266"  }
X   def bullet          { @Sym "\267"  }
X   def divide          { @Sym "\270"  }
X   def notequal        { @Sym "\271"  }
X   def equivalence     { @Sym "\272"  }
X   def approxequal     { @Sym "\273"  }
X   def ellipsis        { @Sym "\274"  }
X   def arrowvertex     { @Sym "\275"  }
X   def arrowhorizex    { @Sym "\276"  }
X   def carriagereturn  { @Sym "\277"  }
X   def aleph           { @Sym "\300"  }
X   def Ifraktur        { @Sym "\301"  }
X   def Rfraktur        { @Sym "\302"  }
X   def weierstrass     { @Sym "\303"  }
X   def circlemultiply  { @Sym "\304"  }
X   def circleplus      { @Sym "\305"  }
X   def emptyset        { @Sym "\306"  }
X   def intersection    { @Sym "\307"  }
X   def union           { @Sym "\310"  }
X   def propersuperset  { @Sym "\311"  }
X   def reflexsuperset  { @Sym "\312"  }
X   def notsubset       { @Sym "\313"  }
X   def propersubset    { @Sym "\314"  }
X   def reflexsubset    { @Sym "\315"  }
X   def element         { @Sym "\316"  }
X   def notelement      { @Sym "\317"  }
X   def angle           { @Sym "\320"  }
X   def gradient        { @Sym "\321"  }
X   def registerserif   { @Sym "\322"  }
X   def copyrightserif  { @Sym "\323"  }
X   def trademarkserif  { @Sym "\324"  }
X   def product         { @Sym "\325"  }
X   def radical         { @Sym "\326"  }
X   def dotmath         { @Sym "\327"  }
X
X   def logicalnot      { @Sym "\330"  }
X   def logicaland      { @Sym "\331"  }
X   def logicalor       { @Sym "\332"  }
X   def arrowdblboth    { @Sym "\333"  }
X   def arrowdblleft    { @Sym "\334"  }
X   def arrowdblup      { @Sym "\335"  }
X   def arrowdblright   { @Sym "\336"  }
X   def arrowdbldown    { @Sym "\337"  }
X   def lozenge         { @Sym "\340"  }
X   def angleleft       { @Sym "\341"  }
X   def registersans    { @Sym "\342"  }
X   def copyrightsans   { @Sym "\343"  }
X   def trademarksans   { @Sym "\344"  }
X   def summation       { @Sym "\345"  }
X   def parenlefttp     { @Sym "\346"  }
X   def parenleftex     { @Sym "\347"  }
X   def parenleftbt     { @Sym "\350"  }
X   def bracketlefttp   { @Sym "\351"  }
X   def bracketleftex   { @Sym "\352"  }
X   def bracketleftbt   { @Sym "\353"  }
X   def bracelefttp     { @Sym "\354"  }
X   def braceleftmid    { @Sym "\355"  }
X   def braceleftbt     { @Sym "\356"  }
X   def braceex         { @Sym "\357"  }
X   def angleright      { @Sym "\361"  }
X   def integral        { @Sym "\362"  }
X   def integraltp      { @Sym "\363"  }
X   def integralex      { @Sym "\364"  }
X   def integralbt      { @Sym "\365"  }
X   def parenrighttp    { @Sym "\366"  }
X   def parenrightex    { @Sym "\367"  }
X   def parenrightbt    { @Sym "\370"  }
X   def bracketrighttp  { @Sym "\371"  }
X   def bracketrightex  { @Sym "\372"  }
X   def bracketrightbt  { @Sym "\373"  }
X   def bracerighttp    { @Sym "\374"  }
X   def bracerightmid   { @Sym "\375"  }
X   def bracerightbt    { @Sym "\376"  }
X
X
X   ###################################################################
X   #                                                                 #
X   #   Short names                                                   #
X   #                                                                 #
X   #   These symbols, their names, and their spacing, are based on   #
X   #   the list in Appendix F of Donald E. Knuth's The TeXBook.      #
X   #                                                                 #
X   #   Group 1 (lowercase Greek letters):  see full names above      #
X   #   Group 2 (uppercase Greek letters):  see full names above      #
X   #   Group 3 (calligraphic capitals):    not provided by Eq        #
X   #                                                                 #
X   ###################################################################
X
X   ###################################################################
X   #                                                                 #
X   #   Group 4 (miscellaneous Ord symbols)                           #
X   #                                                                 #
X   #   Not all of Knuth's symbols are available.  The four suits     #
X   #   (heartsuit, etc.), have definitions above.                    #
X   #                                                                 #
X   ###################################################################
X
X   def hbar         { @OneCol { &0.1f @Base "-" ^/0.25fo h }	}
X   def Re           { Rfraktur					}
X   def Im           { Ifraktur					}
X   def partial      { partialdiff				}
X   def infty        { infinity					}
X   def prime        {  minute        				}
X  #def emptyset     { defined above				}
X   def nabla        { gradient					}
X   def surd         { radical					}
X   def top          { 180d @Rotate perpendicular		}
X   def bot          { perpendicular				}
X   def dbar         { @Base "||"                         	}
X  #def angle        { defined above				}
X   def backslash    { "\\"					}
X   def forall       { universal					}
X   def exists       { existential				}
X   def neg          { logicalnot				}
X
X   def circle       { @HContract @VContract
X		      { "xsize ysize 2 div moveto"
X			"xsize 2 div ysize 2 div xsize 2 div 0 360 arc"
X			"0.04 ft setlinewidth stroke"
X		      }
X		      @Graphic { 0.7f @Wide 0.3f @High ^/ 0.3f @High }
X		    }
X
X   def square       { @HContract @VContract
X		      { "0 0 moveto xsize 0 lineto xsize ysize lineto"
X			"0 ysize lineto closepath"
X			"0.04 ft setlinewidth stroke"
X		      }
X		      @Graphic { 0.6f @Wide 0.3f @High ^/ 0.3f @High }
X		    }
X
X   def triangle     { @HContract @VContract
X		      { "0 0 moveto xsize 0 lineto"
X		        "xsize 2 div ysize lineto closepath"
X			"0.04 ft setlinewidth stroke"
X		      }
X		      @Graphic
X		      { 0.3f @Wide 0.3f @High ^| ^/
X		        0.3f @Wide 0.3f @High
X		      }
X		    }
X
X   ###################################################################
X   #                                                                 #
X   #   Group 5 (digits)                                              #
X   #                                                                 #
X   ###################################################################
X
X   def "0" { zero            }
X   def "1" { one             }
X   def "2" { two             }
X   def "3" { three           }
X   def "4" { four            }
X   def "5" { five            }
X   def "6" { six             }
X   def "7" { seven           }
X   def "8" { eight           }
X   def "9" { nine            }
X
X
X   ###################################################################
X   #                                                                 #
X   #   Group 6 ("Large" operators)                                   #
X   #                                                                 #
X   #   Knuth's large operators automatically change size depending   #
X   #   on whether the equation is display or inline.  Eq does not    #
X   #   do this; instead, the `big' operator must be used.            #
X   #                                                                 #
X   ###################################################################
X
X   def sum	{ summation					}
X   def prod	{ product					}
X   def coprod	{ 180d @Rotate vctr product			}
X   def int	{ 1.3f @Font vctr integral			}
X   def oint	{ @OneCol { vctr degree |0.015fo int }		}
X   def bcap	{ 1.3f @Font intersection			}
X   def bcup	{ 1.3f @Font union				}
X   def bvee	{ 1.3f @Font logicalor				}
X   def bwedge	{ 1.3f @Font logicaland				}
X   def bodot	{ & 1.3f @Font @HContract { circle /0io &0.5rt dotmath } }
X   def botimes	{ 1.3f @Font circlemultiply			}
X   def boplus	{ 1.3f @Font circleplus				}
X   def buplus	{ & 1.3f @Font @HContract { &0.5rt 0.7f @Font plus ^/0.2fo union } }
X
X   ###################################################################
X   #                                                                 #
X   #   Group 7 (binary operations)                                   #
X   #                                                                 #
X   #   All of Knuth's symbols are available except \star, \diamond   #
X   #   and \bullet; a few have been given more mnemonic names.       #
X   #                                                                 #
X   ###################################################################
X
X   def "+"		{ bin plus				}
X   def "-"		{ bin minus				}
X   def "+-"		{ bin plusminus				}
X   def "-+"		{ bin 180d @Rotate plusminus		}
X   def setminus		{ bin backslash				}
X   def cdot		{ bin dotmath				}
X   def times		{ bin multiply				}
X   def "*"		{ bin asteriskmath			}
X  #def diamond		{ name used above			}
X   def circ		{ bin circle				}
X  #def bullet		{ name used above			}
X   def div		{ bin divide				}
X   def cap		{ bin intersection			}
X   def cup		{ bin union				}
X   def uplus		{ bin @OneRow @HContract { &0.5rt 0.7f @Font plus ^/0.2fo union}}
X   def sqcap		{ bin
X			  { @HContract @VContract
X			    {	"0 0 moveto 0 ysize lineto xsize ysize lineto"
X				"xsize 0 lineto"
X				"0.04 ft setlinewidth stroke"
X			    }
X			    @Graphic
X			    {	0.3f @Wide 0.3f @High ^| ^/
X				0.3f @Wide 0.3f @High
X			    }
X			  }
X			}
X   def sqcup		{ 180d @Rotate sqcap			}
X   def triangleleft	{ bin 90d @Rotate 0.8f @Font triangle	}
X   def triangleright	{ bin "-90d" @Rotate 0.8f @Font triangle}
X   def wr		{ bin vctr {90d @Rotate similar}	}
X   def bigcirc		{ bin 1.2f @Font circle			}
X   def bigtriangleup	{ bin 1.2f @Font triangle		}
X   def bigtriangledown	{ bin 180d @Rotate 1.2f @Font triangle	}
X   def vee		{ bin logicalor				}
X   def wedge		{ bin logicaland			}
X   def oplus		{ bin circleplus			}
X   def ominus		{ bin @OneRow @HContract { circle /0io &0.5rt minus}}
X   def otimes		{ bin circlemultiply			}
X   def oslash		{`vctr 60d @Rotate @HContract {circle/0io &0.5rt minus`}}
X   def odot		{ bin @OneRow @HContract {circle/0io &0.5rt dotmath}}
X   def dagger		{ bin @Base @Char "dagger"		}
X   def daggerdbl	{ bin @Base @Char "daggerdbl"		}
X   def amalg		{ bin 180d @Rotate vctr product		}
X
X   ###################################################################
X   #                                                                 #
X   #   Group 8 (relations)                                           #
X   #                                                                 #
X   #   All Knuth's operators are available, but many have been       #
X   #   given different, more mnemonic names.  Also included is       #
X   #   a not operator for negating the relations.                    #
X   #                                                                 #
X   ###################################################################
X
X   def "<"		{ rel less				}
X   def ">"		{ rel greater				}
X   def "="		{ rel equal				}
X   def "<="		{ rel lessequal				}
X   def prec		{ rel { 0.45f @Font "-90d" @Rotate
X				{ parenrighttp ^| parenlefttp }
X			      }
X			}
X   def preceq		{ rel { @OneRow non prec /0.1f minus }	}
X   def "<<"		{ rel {less less}			}
X   def subset		{ rel propersubset			}
X   def subseteq		{ rel reflexsubset			}
X   def sqsubseteq	{ rel @HContract @VContract
X			  {	{ "xsize 0 moveto"
X				  "0 0 lineto"
X				  "0 ysize lineto"
X				  "xsize ysize lineto"
X				  "0.04 ft setlinewidth stroke"
X				}
X				@Graphic
X				{ 0.5f @Wide 0.25f @High ^/
X				  0.25f @High
X				}
X			    /0.1f minus
X			  }
X			}
X
X   def in		{ rel element				}
X   def vdash		{ rel vctr{"-90d" @Rotate perpendicular}}
X   def smile		{ rel vctr 90d @Rotate parenleft	}
X   def frown		{ rel vctr 90d @Rotate parenright	}
X
X   def ">="		{ rel greaterequal			}
X   def succ		{ rel { 0.45f @Font 90d @Rotate
X			        { parenrighttp ^| parenlefttp }
X			      }
X			}
X   def succeq		{ rel { @OneRow non succ /0.1f minus }	}
X   def ">>"		{ rel {greater greater}			}
X   def supset		{ rel propersuperset			}
X   def supseteq		{ rel reflexsuperset			}
X   def sqsupseteq	{ rel @HContract @VContract
X			  {	{ "0 0 moveto xsize 0 lineto"
X				  "xsize ysize lineto"
X				  "0 ysize lineto"
X				  "0.04 ft setlinewidth stroke"
X				}
X				@Graphic
X				{ 0.5f @Wide 0.25f @High ^/
X				  0.25f @High
X				}
X			    /0.1f minus
X			  }
X			}
X   def ni		{ rel 180d @Rotate element		}
X   def dashv		{ rel vctr {90d @Rotate perpendicular}	}
X   def mid		{ rel @Base "|"				}
X   def parallel		{ rel @Base "||"			}
X
X   def "=="		{ rel equivalence			}
X   def "~"		{ rel similar				}
X   def "-~"		{ rel @OneRow{similar^/0.07f/0.07f minus}}
X   def asymp		{ rel 0.7f @Font @OneRow
X			      { 90d @Rotate parenleft ^/0.008f
X			      /0.008f 90d @Rotate parenright }
X			}
X   def "~~"		{ rel approxequal			}
X   def "=~"		{ rel congruent				}
X   def bowtie		{ rel{non triangleright non triangleleft}}
X   def propto		{ rel proportional			}
X   def models		{ rel{@Base vctr "|" &0.05fo vctr equal}}
X   def doteq		{ rel @OneRow @HContract {&0.5rt dotmath^/0.15f equal}}
X   def perp		{ rel perpendicular			}
X
X   def notsub		{ rel notsubset				}
X   def notin		{ rel notelement			}
X   def "!="		{ rel notequal				}
X
X   def "<->"		{ rel arrowboth				}
X   def "<--"		{ rel arrowleft				}
X   def "-->"		{ rel arrowright			}
X   def up		{ rel arrowup				}
X   def down		{ rel arrowdown				}
X   def "<=>"		{ rel arrowdblboth			}
X   def "<=="		{ rel arrowdblleft			}
X   def "==>"		{ rel arrowdblright			}
X   def dblup		{ rel arrowdblup			}
X   def dbldown		{ rel arrowdbldown			}
X
X   def ":"		{ rel colon				}
X   def "::"		{ rel @OneCol {colon ` colon}		}
X   def ":="		{ rel { colon{ //0.05fo equal} }	}
X
X   def not right x	{ @HContract {@OneCol x /0co &0.5rt slash}}
X
X
X   ###################################################################
X   #                                                                 #
X   #   Groups 11 and 12 - openings and closings.                     #
X   #                                                                 #
X   ###################################################################
X
X   def lpar	{ parenleft		}
X   def rpar	{ parenright		}
X   def lbrack	{ bracketleft		}
X   def rbrack	{ bracketright		}
X   def lbrace	{ braceleft		}
X   def rbrace	{ braceright		}
X   def lfloor	{ bracketleftbt		}
X   def rfloor	{ bracketrightbt	}
X   def lceil	{ bracketlefttp		}
X   def rceil	{ bracketrighttp	}
X   def langle	{ angleleft		}
X   def rangle	{ angleright		}
X
X   def blpar	{ @OneRow {parenlefttp    ^/ parenleftex    / parenleftbt   } }
X   def brpar	{ @OneRow {parenrighttp   ^/ parenrightex   / parenrightbt  } }
X   def blbrack	{ @OneRow {bracketlefttp  ^/ bracketleftex  / bracketleftbt } }
X   def brbrack	{ @OneRow {bracketrighttp ^/ bracketrightex / bracketrightbt} }
X   def blbrace	{ @OneRow {bracelefttp    ^/ braceleftmid   / braceleftbt   } }
X   def brbrace	{ @OneRow {bracerighttp   ^/ bracerightmid  / bracerightbt  } }
X   def blfloor	{ @OneRow {bracketleftex  ^/ bracketleftex  / bracketleftbt } }
X   def brfloor	{ @OneRow {bracketrightex ^/ bracketrightex / bracketrightbt} }
X   def blceil	{ @OneRow {bracketlefttp  ^/ bracketleftex  / bracketleftex } }
X   def brceil	{ @OneRow {bracketrighttp ^/ bracketrightex / bracketrightex} }
X   def blangle	{ @HContract @VContract
X		  { "xsize 0 moveto"
X		    "0 ysize 2 div lineto"
X		    "xsize ysize lineto"
X		    "0.04 ft setlinewidth stroke"
X	          }
X	          @Graphic { 0.5f @Wide 2f @High ^/ 2f @High }
X		}
X   def brangle	{ @HContract @VContract
X		  { "0 0 moveto"
X		    "xsize ysize 2 div lineto"
X		    "0 ysize lineto"
X		    "0.04 ft setlinewidth stroke"
X	          }
X	          @Graphic { 0.5f @Wide 2f @High ^/ 2f @High }
X		}
X
X
X   ###################################################################
X   #                                                                 #
X   #   Group 13 - punctuation.                                       #
X   #                                                                 #
X   ###################################################################
X
X   def ";"     { punct semicolon     }
X   def ","     { punct comma         }
X   def col     { punct colon         }
X
X
X   ###################################################################
X   #                                                                 #
X   #   Additional short symbols (Knuth p. 132)                       #
X   #                                                                 #
X   ###################################################################
X
X   def "!" { exclam          }
X   def "?" { question        }
X   def "%" { percent         }
X   def "(" { parenleft       }
X   def ")" { parenright      }
X   def "[" { bracketleft     }
X   def "]" { bracketright    }
X
X
X   ###################################################################
X   #                                                                 #
X   #   Common mathematical functions (from Knuth p. 162).            #
X   #   mod is included, since @Rel mod is easily typed if needed.    #
X   #                                                                 #
X   ###################################################################
X
X   def arccos	{ @Base "arccos"	}
X   def arcsin	{ @Base "arcsin"	}
X   def arctan	{ @Base "arctan"	}
X   def arg	{ @Base "arg"		}
X   def cos	{ @Base "cos"		}
X   def cosh	{ @Base "cosh"		}
X   def cot	{ @Base "cot"		}
X   def coth	{ @Base "coth"		}
X   def csc	{ @Base "csc"		}
X   def deg	{ @Base "deg"		}
X   def det	{ @Base "det"		}
X   def dim	{ @Base "dim"		}
X   def exp	{ @Base "exp"		}
X   def gcd	{ @Base "gcd"		}
X   def hom	{ @Base "hom"		}
X   def inf	{ @Base "inf"		}
X   def ker	{ @Base "ker"		}
X   def lg	{ @Base "lg"		}
X   def lim	{ @Base "lim"		}
X   def liminf	{ @OneCol { @Base "lim" ` @Base "inf" }	}
X   def limsup	{ @OneCol { @Base "lim" ` @Base "sup" }	}
X   def ln	{ @Base "ln"		}
X   def log	{ @Base "log"		}
X   def max	{ @Base "max"		}
X   def min	{ @Base "min"		}
X   def Pr	{ @Base "Pr"		}
X   def sec	{ @Base "sec"		}
X   def sin	{ @Base "sin"		}
X   def sinh	{ @Base "sinh"		}
X   def supr	{ @Base "sup"		}
X   def tan	{ @Base "tan"		}
X   def tanh	{ @Base "tanh"		}
X   def mod	{ @Base "mod"		}
X
X
X   ###################################################################
X   #                                                                 #
X   #   Other symbols taken from TeX.                                 #
X   #                                                                 #
X   ###################################################################
X
X   def ldots { .       &0.3f .       &0.3f .			}
X   def cdots { dotmath &0.3f dotmath &0.3f dotmath		}
X   def vdots { @OneRow { dotmath ^/0.3f dotmath /0.3f dotmath } }
X   def ddots { @OneCol @OneRow
X	       {        dotmath
X	         ^/0.3f |0.3f dotmath
X                  /0.3f |     |0.3f dotmath
X	       }
X	     }
X
X
X   ###################################################################
X   #                                                                 #
X   #   Symbols taken from eqn (Kernighan and Cherry 1975).           #
X   #                                                                 #
X   ###################################################################
X
X   def del	{ gradient		}
X   def grad	{ gradient		}
X   def "..."	{ ellipsis		}
X   def ",...,"	{ , ellipsis ``` ,	}
X   def "'"	{ minute		}
X   def empty	{ emptyset		}
X
X
X
X   ###################################################################
X   #                                                                 #
X   #   Symbols with parameters.                                      #
X   #                                                                 #
X   #   These symbols are essentially those of eqn, with some         #
X   #   changes and additions.                                        #
X   #                                                                 #
X   ###################################################################
X
X   def sup
X      precedence 60
X      associativity left
X      left x
X      named gap { @SupGap }
X      right y
X   {  @HContract @VContract
X      {          | @Smaller y
X	^/gap  x
X      }
X   }
X
X   def sub
X      precedence 60
X      associativity left
X      left x
X      named gap { @SupGap }
X      right y
X   {  @HContract @VContract
X      {
X	      x
X	 /gap    |  @Smaller y
X      }
X   }
X
X   def supp
X      precedence 60
X      associativity left
X      left x
X      named gap { @SupGap }
X      right y
X   {  @HContract @VContract
X      { { ^/gap x /gap } |  @Smaller y
X      }
X   }
X
X   def on
X      precedence 61
X      associativity left
X      left x
X      named gap { @SupGap }
X      right y
X   {  x ^/  / y 
X   }
X
X   def frac
X      precedence 54
X      associativity left
X      left x
X      named gap { 0ik }
X      right y
X   {  @HContract @VContract @Smaller
X      { x ^/gap | fraction /gap | | y }
X   }
X
X   def half { 1 frac 2 }
X   def third { 1 frac 3 }
X
X   def over
X      precedence 54
X      associativity left
X      left x
X      named gap { 0.2f }
X      right y
X   {  
X      @HContract @VContract
X      {          |0.5rt @OneCol x
X	^//gap   @HLine
X	 //gap   |0.5rt @OneCol y
X      }
X   }
X
X   def from
X      precedence 58
X      associativity left
X      left x
X      named gap { @ThinGap  }
X      named skew { 0c }
X      right y
X   {  
X      @HContract @VContract
X      {          |0.5rt x
X	 //gap   |0.5rt &skew @Smaller y
X      }
X   }
X
X   def to
X      precedence 58
X      associativity left
X      left x
X      named gap { @ThinGap  }
X      named skew { 0c }
X      right y
X   {
X      @HContract @VContract
X      {          |0.5rt &skew @Smaller y
X	^//gap   |0.5rt x
X      }
X   }
X
X   def widefrom
X      precedence 58
X      associativity left
X      left x
X      named gap { @ThinGap  }
X      right y
X   {
X      @HContract @VContract
X      {  x //gap @HScale y
X      }
X   }
X
X   def wideto
X      precedence 58
X      associativity left
X      left x
X      named gap { @ThinGap  }
X      right y
X   {
X      @HContract @VContract
X      { @HScale y ^//gap x
X      }
X   }
X
X   def dot
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } .
X   }
X
X   def dotdot
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } ..
X   }
X
X   def hat
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } @Base "^"
X   }
X
X   def tilde
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } @Base "~"
X   }
X
X   def vec
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } arrowright
X   }
X
X   def dyad
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x to gap { gap } skew { @SkewGap } arrowboth
X   }
X
X   def overbar
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x wideto gap { gap } minus
X   }
X
X   def underbar
X      precedence 62
X      left x
X      named gap { @ThinGap }
X   {  x widefrom gap { gap } minus
X   }
X
X   def sqrt
X      precedence 56
X      named gap { @ThinGap }
X      right x
X   {
X      @HContract @VContract
X      { @VScale surd | @OneRow
X	{ @HLine line { "0.03 ft setlinewidth 2 setlinecap" }
X	  ^//gap  |gap  x //gap
X	}
X      }
X   }
X
X   def root
X      precedence 56
X      left x
X      right y
X   { "" sup x &0io sqrt y
X   }
X
X   def above
X      precedence 52
X      left x
X      named gap { @RowGap }
X      right y
X   {  |0.5rt x //gap |0.5rt y
X   }
X
X   def labove
X      precedence 52
X      left x
X      named gap { @RowGap }
X      right y
X   {  x //gap y
X   }
X
X   def cabove
X      precedence 52
X      left x
X      named gap { @RowGap }
X      right y
X   {  |0.5rt x //gap |0.5rt y
X   }
X
X   def rabove
X      precedence 52
X      left x
X      named gap { @RowGap }
X      right y
X   {  |1rt x //gap |1rt y
X   }
X
X   def mabove
X      precedence 52
X      left x
X      named gap { @RowGap }
X      right y
X   {  x /gap y
X   }
X
X   def nextcol
X      precedence 50
X      left x
X      named gap { @ColGap }
X      right y
X   { x |gap y
X   }
X
X   def matrix
X      precedence 100
X      named gap { @MedGap }
X      named atleft {}
X      named atright {}
X      right x
X   { vctr @HContract @VContract
X     {  @VScale atleft
X	||@ThinGap  { //gap x //gap } ||@ThinGap
X	@VScale atright
X     }
X   }
X
X   Slope @Font 1.2f @Break 0c @Space @Body
X
X@End @Eq                  
END_OF_FILE
  if test 35552 -ne `wc -c <'include/eq'`; then
    echo shar: \"'include/eq'\" unpacked with wrong size!
  fi
  # end of 'include/eq'
fi
if test -f 'z37.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z37.c'\"
else
  echo shar: Extracting \"'z37.c'\" \(34601 characters\)
  sed "s/^X//" >'z37.c' <<'END_OF_FILE'
X/*@z37.c:Font Service:Declarations@*******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z37.c                                                      */
X/*  MODULE:       Font Service                                               */
X/*  EXTERNS:      FontInit(), FontDefine(), FontChange(), FontWordSize(),    */
X/*                FontSize(), FontHalfXHeight(), FontEncoding(),             */
X/*                FontEncoding(), FontFamilyAndFace(), FontNeeded()          */
X/*                                                                           */
X/*  This module implements fonts, using encoding vectors and Adobe font      */
X/*  metrics files (.AFM files, version 2).                                   */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define DEFAULT_XHEIGHT 500	/* the default XHeight if font has none      */
X#define	NO_FONT		  0	/* the not-a-font font number                */
X#define	MAX_CHARS	256	/* maximum number of chars in a font         */
X#define SZ_DFT	       1000	/* default lout size is 50p                  */
X
Xstruct metrics {
X  LENGTH up;
X  LENGTH down;
X  LENGTH left;
X  LENGTH right;
X};
X
Xstatic struct metrics	*size_table[MAX_FONT];	/* metrics of sized fonts    */
Xstatic FULL_CHAR	*lig_table[MAX_FONT];	/* ligatures                 */
Xstatic OBJECT		font_table[MAX_FONT];	/* record of sized fonts     */
Xstatic OBJECT		font_root;		/* root of tree of fonts     */
Xstatic FONT_NUM		fontcount;		/* number of sized fonts     */
Xstatic int		font_seqnum;		/* unique number for a font  */
X
X
X/*@::FontInit(), FontDebug()@*************************************************/
X/*                                                                           */
X/*  FontInit()                                                               */
X/*                                                                           */
X/*  Initialise this module.                                                  */
X/*                                                                           */
X/*****************************************************************************/
X
XFontInit()
X{ debug0(DFT, D, "FontInit()");
X  fontcount	= 0;
X  font_root	= New(ACAT);
X  font_seqnum	= 0;
X  debug0(DFT, D, "FontInit returning.");
X}
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FontDebug()                        	                                     */
X/*                                                                           */
X/*  Print out font tree.                                                     */
X/*                                                                           */
X/*****************************************************************************/
X
X#if DEBUG_ON
Xstatic FontDebug()
X{ OBJECT family, face, filename, link, flink;  int i;
X  assert( font_root != nil && type(font_root)==ACAT, "FontDebug: font_root!" );
X  for( link = Down(font_root);  link != font_root;  link = NextDown(link) )
X  { Child(family, link);
X    assert( is_word(type(family)), "FontDebug: family!" );
X    fprintf(stderr, "family %s:\n", string(family));
X    for( flink = Down(family);  flink != family;  flink = NextDown(flink) )
X    { Child(face, flink);
X      assert( is_word(type(face)), "FontDebug: face!" );
X      fprintf(stderr, "   face %s in file ", string(face));
X      assert( Down(face) != face, "FontDebug: Down(face)!");
X      Child(filename, Down(face));
X      assert( is_word(type(filename)), "FontDebug: filename!" );
X      fprintf(stderr, "%s\n", string(filename));
X    }
X  }
X  for( i = 1;  i <= fontcount;  i++ )
X    fprintf(stderr, "  font_table[%d] = %s\n", i, EchoObject(font_table[i]));
X} /* end FontDebug */
X#endif
X
X
X/*@::FontDefine()@************************************************************/
X/*                                                                           */
X/*  FontDefine(family, face, inside)                                         */
X/*                                                                           */
X/*  Insert a font defined by fontdef <family> <face> { <inside> } into the   */
X/*  font tree; <inside> ::= <fontname> <AFMfilename> <CEVfilename> <recode>  */
X/*                                                                           */
X/*****************************************************************************/
X
XFontDefine(family, face, inside)
XOBJECT family, face, inside;
X{ OBJECT font_name, AFMfilename, CEVfilename, recode;
X  OBJECT short_name, link, y, val[4]; int i;
X  debug3(DFT, D, "FontDefine( %s, %s, %s )", string(family),
X    string(face), EchoObject(inside));
X
X  /* extract font_name, AFMfilename, CEVfilename, and recode */
X  if( type(inside) != ACAT )
X  { Error(WARN, &fpos(inside), "fontdef is not a sequence of words");
X    DisposeObject(inside);  return;
X  }
X  for( i = 0;  Down(inside) != inside && i != 4;  i++ )
X  { Child(val[i], Down(inside));
X    DeleteLink(Up(val[i]));
X    if( type(val[i]) == GAP_OBJ )  DisposeObject(val[i--]);
X    else if( !is_word(type(val[i])) )
X    { Error(WARN, &fpos(val[i]), "fontdef contains a non-word");
X      DisposeObject(inside);  return;
X    }
X  }
X  if( Down(inside) != inside || i != 4 )
X  { Error(WARN, &fpos(inside), "fontdef does not contain exactly four words");
X    DisposeObject(inside);  return;
X  }
X  font_name = val[0];    AFMfilename = val[1];
X  CEVfilename = val[2];  recode = val[3];
X
X  /* insert family into font tree if not already present */
X  for( link = Down(font_root);  link != font_root;  link = NextDown(link) )
X  { Child(y, link);
X    if( StringEqual(string(y), string(family)) )
X    { Dispose(family);  family = y; break; }
X  }
X  if( link == font_root )  Link(font_root, family);
X
X  /* insert face into family, or error if already present */
X  for( link = Down(family);  link != family;  link = NextDown(link) )
X  { Child(y, link);
X    if( StringEqual(string(y), string(face)) )
X    { Error(WARN, &fpos(face), "font %s %s already defined at%s",
X	string(family), string(face), EchoFilePos(&fpos(y)));
X      debug0(DFT, D, "FontDefine returning: font already defined");
X      Dispose(face);
X      return;
X    }
X  }
X  Link(family, face);
X
X  /* add AFMfilename as first size of font, and PostScript name as its child */
X  Link(face, AFMfilename);
X  short_name = MakeWordTwo(WORD, AsciiToFull("fnt"), StringInt(++font_seqnum),
X    no_fpos);
X  Link(AFMfilename, short_name);  Link(AFMfilename, font_name);
X
X  /* load encoding vector */
X  if( StringEqual(string(recode), STR_FONT_RECODE) )
X  { font_recoded(face) = TRUE;
X    font_encoding(AFMfilename) = EvLoad(CEVfilename, TRUE);
X  }
X  else if( StringEqual(string(recode), STR_FONT_NORECODE) )
X  { font_recoded(face) = FALSE;
X    font_encoding(AFMfilename) = EvLoad(CEVfilename, FALSE);
X  }
X  else Error(FATAL, &fpos(recode), "expecting either Recode or NoRecode here");
X  debug0(DFT, D, "FontDefine returning.");
X} /* end FontDefine */
X
X
X/*@::ReadFont()@**************************************************************/
X/*                                                                           */
X/*  static ReadFont(face, err)                                               */
X/*                                                                           */
X/*  Read in a font file.  Object err is used only for error reporting.       */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic ReadFont(face, err)
XOBJECT face, err;
X{ OBJECT filename, fontname;
X  FULL_CHAR buff[MAX_LINE], command[MAX_LINE], ch;
X  int wx, llx, lly, urx, ury, xheight2, i, lnum, ligtop;
X  BOOLEAN xhfound, wxfound, bfound;
X  FILE_NUM fnum;  FILE *fp;
X  struct metrics *fnt;
X  FULL_CHAR *lig, ligchar;
X  OBJECT x;
X  char *malloc();
X  assert( is_word(type(face)), "ReadFont: !is_word(type(face))!" );
X  debug1(DFT, DD, "ReadFont( %s, err )", string(face));
X
X  /* get a new font number for this font */
X  if( ++fontcount >= MAX_FONT )  Error(FATAL, &fpos(err),
X    "too many different fonts and sizes (max is %d)", MAX_FONT - 1);
X
X  /* open the Adobe font metrics (AFM) file of the font */
X  assert( Down(face) != face, "ReadFont: filename missing!" );
X  Child(filename, Down(face));
X  assert( Down(filename) != filename, "ReadFont: filename child missing!" );
X  fnum = DefineFile(string(filename), STR_EMPTY, &fpos(filename),
X    FONT_FILE, FONT_PATH);
X  fp = OpenFile(fnum, FALSE, FALSE);
X  if( fp == NULL )
X    Error(FATAL, &fpos(filename), "cannot open font file %s", FileName(fnum));
X
X  /* check that the AFM file begins, as it should, with "StartFontMetrics" */
X  if( StringFGets(buff, MAX_LINE, fp) == NULL ||
X	sscanf( (char *) buff, "%s", command) != 1 ||
X	!StringEqual(command, "StartFontMetrics")  )
X  { debug1(DFT, D, "first line of AFM file:%s", buff);
X    debug1(DFT, D, "command:%s", command);
X    Error(FATAL, &fpos(filename),
X      "font file %s does not begin with StartFontMetrics", FileName(fnum));
X  }
X
X  /* initialise font metrics and ligature tables for the new font */
X  fnt = (struct metrics *) malloc(MAX_CHARS * sizeof(struct metrics));
X  if( fnt == (struct metrics *) NULL )  Error(FATAL, &fpos(err),
X    "run out of memory reading font file %s", FileName(fnum));
X  lig = (FULL_CHAR *) malloc(2*MAX_CHARS*sizeof(FULL_CHAR));
X  if( lig == (FULL_CHAR *) NULL )  Error(FATAL, &fpos(err),
X    "run out of memory reading font file %s", FileName(fnum));
X  for( i = 0;  i < MAX_CHARS;  i++ )  lig[i] = 1;	/* i.e. char unknown */
X  ligtop = MAX_CHARS+2;		/* must avoid ligtop - MAX_CHARS == 0 or 1 */
X
X  /* read font metrics file */
X  xhfound = FALSE;  fontname = nil;  lnum = 1;
X  while ( ( StringFGets(buff, MAX_LINE, fp) ) != NULL )
X  {
X    lnum++;
X    sscanf( (char *) buff, "%s", command);
X    switch( command[0] )
X    {
X
X      case 'X':
X
X	if( StringEqual(command, AsciiToFull("XHeight")) ) 
X	{ if( xhfound )
X	  { Error(FATAL, &fpos(filename),
X	      "XHeight found twice in font file (line %d)", lnum);
X	  }
X	  sscanf( (char *) buff, "XHeight %d", &xheight2);
X	  xheight2 = xheight2 / 2;
X	  xhfound = TRUE;
X	}
X	break;
X
X
X      case 'F':
X
X	if( StringEqual(command, AsciiToFull("FontName")) )
X	{ if( fontname != nil )
X	  { Error(FATAL, &fpos(filename),
X	      "FontName found twice in font file %s (line %d)",
X	      FileName(fnum), lnum);
X	  }
X	  sscanf( (char *) buff, "FontName %s", command);
X	  if( StringEqual(command, STR_EMPTY) )
X	  { Error(FATAL, &fpos(filename),
X	      "FontName empty in font file %s (line %d)",
X	      FileName(fnum), lnum);
X	  }
X	  Child(x, LastDown(filename));
X	  if( !StringEqual(command, string(x)) )
X	  Error(FATAL, &fpos(filename),
X	    "FontName in AFM file (%s) and in fontdef (%s) disagree",
X	    command, string(x));
X	  fontname = MakeWord(WORD, command, &fpos(filename));
X	}
X	break;
X
X
X      case 'S':
X
X	if( !StringEqual(command, AsciiToFull("StartCharMetrics")) )
X	  continue;
X	if( fontname == nil )  Error(FATAL, &fpos(filename),
X	  "FontName missing in file %s", FileName(fnum));
X	if( !xhfound )  xheight2 = DEFAULT_XHEIGHT / 2;
X	while( StringFGets(buff, MAX_LINE, fp) != NULL &&
X	       !StringBeginsWith(buff, AsciiToFull("EndCharMetrics")) )
X	{
X	  /* read one line containing metric info for one character */
X	  debug1(DFT, DD, "ReadFont reading %s", buff);
X	  lnum++;  ch = '\0';  
X	  wxfound = bfound = FALSE;
X	  i = 0;  while( buff[i] == ' ' )  i++;
X	  while( buff[i] != '\n' )
X	  {
X	      debug2(DFT, DD, "  ch = %d, &buff[i] = %s", ch, &buff[i]);
X	      sscanf( (char *) &buff[i], "%s", command);
X	      if( StringEqual(command, "N") )
X	      { sscanf( (char *) &buff[i], "N %s", command);
X		ch = EvRetrieve(command, font_encoding(filename));
X	      }
X	      else if( StringEqual(command, "WX") )
X	      {	sscanf( (char *) &buff[i], "WX %d", &wx);
X		wxfound = TRUE;
X	      }
X	      else if( StringEqual(command, "B") )
X	      { sscanf( (char *) &buff[i], "B %d %d %d %d",
X		  &llx, &lly, &urx, &ury);
X		bfound = TRUE;
X	      }
X	      else if( StringEqual(command, "L") && ch != '\0' )
X	      { if( lig[ch] == 1 )  lig[ch] = ligtop - MAX_CHARS;
X		lig[ligtop++] = ch;
X		i++;  /* skip L */
X		while( buff[i] == ' ' )  i++;
X		while( buff[i] != ';' && buff[i] != '\n' )
X		{ sscanf( (char *) &buff[i], "%s", command);
X		  ligchar = EvRetrieve(command, font_encoding(filename));
X		  if( ligchar != '\0' )  lig[ligtop++] = ligchar;
X		  else
X		  { Error(WARN, &fpos(filename),
X		    "ignoring ligature character %s in font file %s (line %d%s",
X		    command, FileName(fnum), lnum, ") as it is not encoded");
X		    lig[ch] = 1;
X		  }
X		  if( ligtop > 2*MAX_CHARS - 5 )  Error(FATAL, &fpos(filename),
X		    "too many ligature characters in font file %s (line %d)",
X		    FileName(fnum), lnum);
X		  while( buff[i] != ' ' && buff[i] != ';' )  i++;
X		  while( buff[i] == ' ' ) i++;
X		}
X		lig[ligtop++] = '\0';
X	      }
X	      while( buff[i] != ';' && buff[i] != '\n' )  i++;
X	      if( buff[i] == ';' )
X	      { i++;  while( buff[i] == ' ' ) i++;
X	      }
X	  }
X	  if( ch > '\0' )
X	  { 
X	    if( !wxfound )
X	    { Error(FATAL, &fpos(filename),
X	        "WX missing in font file %s (line %d)", FileName(fnum), lnum);
X	    }
X	    if( !bfound )
X	    { Error(FATAL, &fpos(filename),
X	        "B missing in font file %s (line %d)", FileName(fnum), lnum);
X	    }
X	    if( lig[ch] == 1 )  lig[ch] = 0;	/* set to known if unknown */
X	    else if( lig[ch] > 1 )		/* add '\0' to end of ligs */
X	      lig[ligtop++] = '\0';
X	    fnt[ch].left  = llx;
X	    fnt[ch].down  = lly - xheight2;
X	    fnt[ch].right = wx;
X	    fnt[ch].up    = ury - xheight2;
X	    debug5(DFT, DD, "  fnt[%c] = (%d,%d,%d,%d)", ch, fnt[ch].left,
X	      fnt[ch].down, fnt[ch].right, fnt[ch].up);
X	  }
X	}
X
X	/* make a new font record and insert into font tree */
X	font_num(fontname) = fontcount;
X	font_size(fontname) = SZ_DFT;
X	font_xheight2(fontname) = xheight2;
X	font_encoding(fontname) = font_encoding(filename);
X	ch = EvRetrieve(STR_PS_SPACENAME, font_encoding(fontname));
X	font_spacewidth(fontname) = ch == '\0' ? 0 : fnt[ch].right;
X	font_table[fontcount] = fontname;
X	size_table[fontcount] = fnt;
X	lig_table[fontcount] = lig;
X	Link(face, fontname);
X
X	/* close file, debug and exit */
X	fclose(fp);
X	debug4(DFT, D, "ReadFont returning: %d, name %s, fs %d, xh2 %d",
X		fontcount, string(fontname), font_size(fontname), xheight2);
X	return;
X	break;
X
X
X      default:
X
X	break;
X
X    }
X  }
X  Error(FATAL, &fpos(filename),
X	"StartCharMetrics missing from font file %s", FileName(fnum));
X} /* end ReadFont */
X
X
X/*@::FontChange()@************************************************************/
X/*                                                                           */
X/*  FontChange(style, x)                                                     */
X/*                                                                           */
X/*  Returns an internal font number which is the current font changed        */
X/*  according to word object x.  e.g. if current font is Roman 12p and x is  */
X/*  "-3p", then FontChange returns the internal font number of Roman 9p.     */
X/*                                                                           */
X/*****************************************************************************/
X
XFontChange(style, x)
XSTYLE *style;  OBJECT x;
X{ /* register */ int i;
X  OBJECT par[3], family, face, fsize, y, link, new, old, tmpf;
X  GAP gp;  LENGTH flen;  int num, c;  unsigned inc;
X  struct metrics *newfnt, *oldfnt;  FULL_CHAR *lig;  char *malloc();
X  debug2(DFT, D, "FontChange( %s, %s )", EchoStyle(style), EchoObject(x));
X  assert( font(*style) <= fontcount, "FontChange: fontcount!");
X  /* ifdebug(DFT, DD, FontDebug()); */
X
X  /* set par[0..num-1] to the 1, 2 or 3 parameters of the font operator */
X  num = 0;
X  if( is_word(type(x)) )  par[num++] = x; 
X  else if( type(x) == ACAT )
X  { for( link = Down(x);  link != x;  link = NextDown(link) )
X    { Child(y, link);
X      debug1(DFT, DD, "  pars examining y = %s", EchoObject(y));
X      if( type(y) == GAP_OBJ )  continue;
X      if( !is_word(type(y)) || num >= 3 )
X      {	Error(WARN, &fpos(x), "error in left parameter of %s", KW_FONT);
X	debug0(DFT, D, "FontChange returning: ACAT children");
X	return;
X      }
X      par[num++] = y;
X    }
X  }
X  else
X  { Error(WARN, &fpos(x), "error in left parameter of %s", KW_FONT);
X    debug0(DFT, D, "FontChange returning: wrong type");
X    return;
X  }
X  debug1(DFT, DD, " found pars, num = %d", num);
X
X  /* extract fsize parameter, if any */
X  assert( num >= 1 && num <= 3, "FontChange: num!" );
X  c = string(par[num-1])[0];
X  if( c == CH_INCGAP || c == CH_DECGAP || decimaldigit(c) )
X  { fsize = par[num-1];  num--;
X  }
X  else fsize = nil;
X
X  /* check for initial font case: must have family, face, and size */
X  if( font(*style) == NO_FONT && (fsize == nil || num < 2) )
X    Error(FATAL, &fpos(x), "initial font must have family, face and size");
X
X  /* get font family */
X  if( num == 2 )
X  {
X    /* par[0] contains a new family name */
X    for( link = Down(font_root);  link != font_root;  link = NextDown(link) )
X    { Child(family, link);
X      if( StringEqual(string(family), string(par[0])) )  break;
X    }
X    if( link == font_root )
X    { Error(WARN,&fpos(par[0]), "font family %s not defined", string(par[0]));
X      return;
X    }
X  }
X  else
X  { /* preserve current family */
X    assert( Up(font_table[font(*style)]) != font_table[font(*style)],
X      "FontChange: Up(font_table[font(*style)]) !" );
X    Parent(face, Up(font_table[font(*style)]));
X    assert( is_word(type(face)), "FontChange: type(face)!" );
X    assert( Up(face) != face, "FontChange: Up(face)!" );
X    Parent(family, Up(face));
X    assert( is_word(type(family)), "FontChange: type(family)!" );
X  }
X
X  /* get font face */
X  if( num != 0 )
X  {
X    /* par[num-1] contains a new face name */
X    for( link = Down(family);  link != family;  link = NextDown(link) )
X    { Child(face, link);
X      if( StringEqual(string(face), string(par[num-1])) )  break;
X    }
X    if( link == family )
X    {
X      /* missing face name; first check whether a family name was intended */
X      for( link = Down(font_root);  link != font_root;  link = NextDown(link) )
X      {	Child(tmpf, link);
X	if( StringEqual(string(tmpf), string(par[num-1])) )  break;
X      }
X      if( font_root == Down(font_root) )
X      {	Error(FATAL, &fpos(par[num-1]), "there are no fonts");
X      }
X      else if( link != font_root )
X      {	Error(WARN, &fpos(par[num-1]),
X	    "font family name %s must be accompanied by a face name",
X	    string(par[num-1]));
X      }
X      else Error(WARN, &fpos(par[num-1]),
X	    "font face name %s not defined in font family %s",
X		string(par[num-1]), string(family));
X      return;
X    }
X  }
X  else
X  {
X    /* preserve current face name */
X    Parent(face, Up(font_table[font(*style)]));
X    assert( is_word(type(face)), "FontChange: type(face)!" );
X    assert( Up(face) != face, "FontChange: Up(face)!" );
X  }
X
X  /* get font size */
X  if( fsize == nil )  flen = font_size(font_table[font(*style)]);
X  else 
X  { GetGap(fsize, style, &gp, &inc);
X    if( inc == GAP_ABS )  flen = width(gp);
X    else if( font(*style) == NO_FONT )
X      Error(FATAL, &fpos(fsize), "no font encloses this %s", string(fsize));
X    else if( inc==GAP_INC )  flen = font_size(font_table[font(*style)])+width(gp);
X    else if( inc==GAP_DEC )  flen = font_size(font_table[font(*style)])-width(gp);
X    else Error(INTERN, &fpos(x), "GetGap returned inc = %d!", inc);
X  }
X
X  if( flen <= 0 )
X  { Error(WARN, &fpos(fsize), "%s %s ignored: result is not positive",
X      string(fsize), KW_FONT);
X    return;
X  }
X
X  /* if the font file has not been read before, read it now */
X  assert( Down(face) != face && type(Down(face)) == LINK, "FontChange: dn!" );
X  if( Down(face) == LastDown(face) )  ReadFont(face, x);
X  assert( Down(face) != LastDown(face), "FontChange: after ReadFont!" );
X
X  /* search fonts of face for desired size; return if already present */
X  for( link = NextDown(Down(face));  link != face;  link = NextDown(link) )
X  { Child(fsize, link);
X    if( font_size(fsize) == flen )
X    { font(*style) = font_num(fsize);
X      SetGap(space_gap(*style), FALSE, TRUE, FIXED_UNIT, EDGE_MODE,
X			font_spacewidth(fsize));
X      debug2(DFT, D,"FontChange returning (old) %d (XHeight2 = %d)",
X			font(*style), font_xheight2(font_table[font(*style)]));
X      return;
X    }
X  }
X
X  /* now need to rescale the font; first create a sized font record */
X  if( ++fontcount >= MAX_FONT )  Error(FATAL, &fpos(x),
X    "too many different fonts and sizes (max is %d)", MAX_FONT - 1);
X  assert( Down(face) != face && NextDown(Down(face)) != face, "FontChange!!" );
X  Child(old, NextDown(Down(face)));
X  assert( is_word(type(old)), "FontChange: old!" );
X  new = MakeWord(WORD, string(old), no_fpos);
X  Link(face, new);
X  font_size(new)        = flen;
X  font_xheight2(new)    = font_xheight2(old) * font_size(new) / font_size(old);
X  font_encoding(new)	= font_encoding(old);
X  font_spacewidth(new)	= font_spacewidth(old) * font_size(new)/font_size(old);
X  font_num(new)         = fontcount;
X  font_table[fontcount] = new;
X  size_table[fontcount] =
X	(struct metrics *) malloc(MAX_CHARS * sizeof(struct metrics));
X  if( size_table[fontcount] == (struct metrics *) NULL )
X    Error(FATAL, &fpos(x), "run out of memory when changing font or font size");
X  lig_table[fontcount]  = lig = lig_table[font_num(old)];
X
X  /* scale old font to new size */
X  newfnt = size_table[font_num(new)];
X  oldfnt = size_table[font_num(old)];
X  for( i = 0;  i < MAX_CHARS;  i++ )  if( lig[i] != 1 )
X  { newfnt[i].left  = (oldfnt[i].left  * font_size(new)) / font_size(old);
X    newfnt[i].right = (oldfnt[i].right * font_size(new)) / font_size(old);
X    newfnt[i].down  = (oldfnt[i].down  * font_size(new)) / font_size(old);
X    newfnt[i].up    = (oldfnt[i].up    * font_size(new)) / font_size(old);
X  }
X
X  /* return new font number and exit */
X  font(*style) = fontcount;
X  SetGap(space_gap(*style), FALSE, TRUE, FIXED_UNIT, EDGE_MODE,
X    font_spacewidth(new));
X  debug2(DFT, D,"FontChange returning (scaled) %d (XHeight2 = %d)",
X    font(*style), font_xheight2(font_table[font(*style)]));
X  /* FontDebug(); */
X} /* end FontChange */
X
X
X/*@::FontWordSize()@**********************************************************/
X/*                                                                           */
X/*  FontWordSize(x)                                                          */
X/*                                                                           */
X/*  Calculate the horizontal and vertical size of WORD or QWORD x, replacing */
X/*  ligature sequences by ligature characters wherever they occur.           */
X/*                                                                           */
X/*****************************************************************************/
X
XFontWordSize(x)
XOBJECT x;
X{ FULL_CHAR *p, *q, *a, *b, *lig;  OBJECT tmp;
X  int r, u, d; struct metrics *fnt;
X  debug2(DFT, D, "FontWordSize( %s ), font = %d", string(x), word_font(x));
X  assert( is_word(type(x)), "FontWordSize: !is_word(type(x))!" );
X
X  p = q = string(x);
X  if( *p )
X  { if ( word_font(x) < 1 || word_font(x) > fontcount )
X      Error(FATAL, &fpos(x), "no current font at word %s", string(x));
X    fnt = size_table[word_font(x)];
X    lig = lig_table[word_font(x)];
X    d = u = r = 0;
X    do
X    { 
X      /* check for missing glyph (lig[] == 1) or ligatures (lig[] > 1) */
X      if( lig[*q = *p++] )
X      {
X	if( lig[*q] == 1 )
X	{ tmp = MakeWord(QWORD, STR_SPACE, &fpos(x));
X	  string(tmp)[0] = *q;
X	  Error(WARN, &fpos(x),
X	    "character %s left out (it has no glyph in font %s)",
X	     StringQuotedWord(tmp), FontFamilyAndFace(word_font(x)));
X	  Dispose(tmp);
X	  continue;
X	}
X	else
X	{ a = &lig[ lig[*(p-1)] + MAX_CHARS ];
X	  while( *a++ == *(p-1) )
X	  { b = p;
X	    while( *a == *b && *(a+1) != '\0' && *b != '\0' )  a++, b++;
X	    if( *(a+1) == '\0' )
X	    { *q = *a;
X	      p = b;
X	      break;
X	    }
X	    else
X	    { while( *++a );
X	      a++;
X	    }
X	  }
X	}
X      }
X
X      /* accumulate size of *q */
X      if( fnt[*q].up   > u )  u = fnt[*q].up;
X      if( fnt[*q].down < d )  d = fnt[*q].down;
X      r += fnt[*q++].right;
X    } while( *p );
X    *q++ = '\0';
X    back(x, COL) = 0; fwd(x, COL)  = r;
X    back(x, ROW) = u; fwd(x, ROW)  = -d;
X  } 
X  else back(x, COL) = fwd(x, COL) = back(x, ROW) = fwd(x, ROW) = 0;
X  debug4(DFT, D, "FontWordSize returning %hd %hd %hd %hd",
X	  back(x, COL), fwd(x, COL), back(x, ROW), fwd(x, ROW));
X} /* end FontWordSize */
X
X
X/*@::FontSize(), FontHalfXHeight(), FontEncoding(), FontName()@***************/
X/*                                                                           */
X/*  LENGTH FontSize(fnum, x)                                                 */
X/*                                                                           */
X/*  Return the size of this font.  x is for error messages only.             */
X/*                                                                           */
X/*****************************************************************************/
X
XLENGTH FontSize(fnum, x)
XFONT_NUM fnum;  OBJECT x;
X{ debug1(DFT, D, "FontSize( %d )", fnum);
X  assert( fnum <= fontcount, "FontSize!" );
X  if( fnum <= 0 )  Error(FATAL, &fpos(x), "no current font at this point");
X  debug1(DFT, D, "FontSize returning %d", font_size(font_table[fnum]));
X  return font_size(font_table[fnum]);
X} /* end FontSize */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  LENGTH FontHalfXHeight(fnum)                                             */
X/*                                                                           */
X/*  Return the xheight2 value of this font.                                  */
X/*                                                                           */
X/*****************************************************************************/
X
XLENGTH FontHalfXHeight(fnum)
XFONT_NUM fnum;
X{ debug1(DFT, D, "FontHalfXHeight( %d )", fnum);
X  assert( fnum <= fontcount, "FontHalfXHeight!" );
X  debug1(DFT,D,"FontHalfXHeight returning %d", font_xheight2(font_table[fnum]));
X  return font_xheight2(font_table[fnum]);
X} /* end FontSize */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  ENCODING FontEncoding(fnum)                                              */
X/*                                                                           */
X/*  Return the encoding of this font.                                        */
X/*                                                                           */
X/*****************************************************************************/
X
XENCODING FontEncoding(fnum)
XFONT_NUM fnum;
X{ debug1(DFT, D, "FontEncoding( %d )", fnum);
X  assert( fnum <= fontcount, "FontSize!" );
X  debug1(DFT, D, "FontEncoding returning %d", font_encoding(font_table[fnum]));
X  return font_encoding(font_table[fnum]);
X} /* end FontSize */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *FontName(fnum)                                                */
X/*                                                                           */
X/*  Return the short PostScript name of this font.                           */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *FontName(fnum)
XFONT_NUM fnum;
X{ OBJECT face, AFMfilename, short_name;
X  debug1(DFT, D, "FontName( %d )", fnum);
X  assert( fnum <= fontcount, "FontName!" );
X  Parent(face, Up(font_table[fnum]));
X  Child(AFMfilename, Down(face));
X  Child(short_name, Down(AFMfilename));
X  assert( is_word(type(short_name)), "FontName: short_name!" );
X  debug1(DFT, D, "FontName returning %s", string(short_name));
X  return string(short_name);
X} /* end FontSize */
X
X
X/*@::FontFamilyAndFace(), FontPrintAll()@*************************************/
X/*                                                                           */
X/*  FULL_CHAR *FontFamilyAndFace(fnum)                                       */
X/*                                                                           */
X/*  Return a static string of the current font family and face.              */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *FontFamilyAndFace(fnum)
XFONT_NUM fnum;
X{ OBJECT face, family; static FULL_CHAR buff[80];
X  debug1(DFT, D, "FontFamilyAndFace( %d )", fnum);
X  assert( fnum <= fontcount, "FontName!" );
X  Parent(face, Up(font_table[fnum]));
X  Parent(family, Up(face));
X  if( StringLength(string(family)) + StringLength(string(face)) + 1 > 80 )
X    Error(FATAL, no_fpos, "family and face names %s %s are too long",
X      string(family), string(face));
X  StringCopy(buff, string(family));
X  StringCat(buff, STR_SPACE);
X  StringCat(buff, string(face));
X  debug1(DFT, D, "FontName returning %s", buff);
X  return buff;
X} /* end FontFamilyAndFace */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FontPrintAll(fp)                   	                                     */
X/*                                                                           */
X/*  Print all font encoding commands on output file fp                       */
X/*                                                                           */
X/*****************************************************************************/
X
XFontPrintAll(fp)
XFILE *fp;
X{ OBJECT family, face, AFMfilename, short_name, ps_name, link, flink;
X  assert( font_root != nil && type(font_root)==ACAT, "FontDebug: font_root!" );
X  debug0(DFT, DD, "FontPrintAll(fp)");
X  for( link = Down(font_root);  link != font_root;  link = NextDown(link) )
X  { Child(family, link);
X    assert( is_word(type(family)), "FontPrintAll: family!" );
X    for( flink = Down(family);  flink != family;  flink = NextDown(flink) )
X    { Child(face, flink);
X      assert( is_word(type(face)), "FontPrintAll: face!" );
X      assert( Down(face) != face, "FontDebug: Down(face)!");
X      Child(AFMfilename, Down(face));
X      assert( is_word(type(AFMfilename)), "FontPrintAll: filename!" );
X      assert( Down(AFMfilename) != AFMfilename, "FontPrintAll: 1!" );
X      assert( LastDown(AFMfilename) != Down(AFMfilename), "FontPrintAll: 2!" );
X      Child(short_name, Down(AFMfilename));
X      assert( is_word(type(short_name)), "FontPrintAll: short_name!" );
X      Child(ps_name, LastDown(AFMfilename));
X      assert( is_word(type(ps_name)), "FontPrintAll: ps_name!" );
X      if( font_recoded(face) )
X      { fprintf(fp, "/%s%s %s /%s LoutRecode\n",
X	  string(ps_name), string(short_name),
X	  EvName(font_encoding(AFMfilename)), string(ps_name));
X        fprintf(fp, "/%s { /%s%s LoutFont } def\n", string(short_name),
X	  string(ps_name), string(short_name));
X      }
X      else fprintf(fp, "/%s { /%s LoutFont } def\n", string(short_name),
X	  string(ps_name));
X    }
X  }
X  fputs("\n", fp);
X  debug0(DFT, DD, "FontPrintAll returning.");
X} /* end FontPrintAll */
X
X
X/*@::FontNeeded()@************************************************************/
X/*                                                                           */
X/*  OBJECT FontNeeded(out_fp);                                               */
X/*                                                                           */
X/*  Writes font needed resources onto file out_fp.  Returns TRUE if none.    */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN FontNeeded(out_fp)
XFILE *out_fp;
X{ BOOLEAN first_need = TRUE;
X  OBJECT link, flink, family, face, x;
X  for( link = Down(font_root); link != font_root; link = NextDown(link) )
X  { Child(family, link);
X    for( flink = Down(family);  flink != family;  flink = NextDown(flink) )
X    { Child(face, flink);
X      if( LastDown(face) != Down(face) )
X      { Child(x, LastDown(face));
X        fprintf(out_fp, "%s font %s\n",
X            first_need ? "%%DocumentNeededResources:" : "%%+", string(x));
X        first_need = FALSE;
X      }
X    }
X  }
X  return first_need;
X} /* end FontNeeded */
END_OF_FILE
  if test 34601 -ne `wc -c <'z37.c'`; then
    echo shar: \"'z37.c'\" unpacked with wrong size!
  fi
  # end of 'z37.c'
fi
echo shar: End of archive 9 \(of 35\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
