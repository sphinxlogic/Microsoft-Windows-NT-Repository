Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i084:  lout - Lout document formatting system, v2.05, Part16/35
Message-ID: <1993Aug10.032741.17287@sparky.sterling.com>
X-Md4-Signature: cbea226b7c49571ddd5826ccd22be155
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 03:27:41 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 84
Archive-name: lout/part16
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  doc/tr.eq/s5 doc/tr.impl/s5.3 font/NewCenSchBolIta.AFM
#   include/fig z16.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:26 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 16 (of 35)."'
if test -f 'doc/tr.eq/s5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.eq/s5'\"
else
  echo shar: Extracting \"'doc/tr.eq/s5'\" \(16617 characters\)
  sed "s/^X//" >'doc/tr.eq/s5' <<'END_OF_FILE'
X@Section
X   @Title { Summary }
X@Begin
X@PP
XThis section is a complete list of the symbols provided by Eq.  We
Xdivide them into auxiliary, parameterized, short names (further divided
Xinto relations, binary operators, and punctuation), and full names.  The
Xauxiliary symbols are:
X@ID @Tab
X     vmargin { 0.5vx }
X     @Fmta { @Col A ! @Col B }
X{
X@Rowa
X    A { @Code "`" }
X    B { Thin space }
X@Rowa
X    A { @Code "``" }
X    B { Medium space }
X@Rowa
X    A { @Code "```" }
X    B { Thick space }
X@Rowa
X    A { @Code "bin x" }
X    B { Treat @Code x as a binary operator }
X@Rowa
X    A { @Code "rel x" }
X    B { Treat @Code x as a relation }
X@Rowa
X    A { @Code "punct x" }
X    B { Treat @Code x as a punctuation symbol }
X@Rowa
X    A { @Code "non x" }
X    B { Remove spaces normally put into @Code x }
X@Rowa
X    A { @Code "vctr x" }
X    B { Centre @Code x vertically }
X@Rowa
X    A { @Code "big x" }
X    B { Make @Code x larger }
X}
XHere are all the parameterized symbols, shown in groups of equal
Xprecedence, with the precedence itself at right:
X@ID lines @Break {
X@Code "matrix not" (100)
X@Code "dot dotdot hat tilde vec dyad overbar underbar" (62)
X@Code "sup sub supp" (60)   "on" (61)
X@Code "from to widefrom wideto" (58)
X@Code "sqrt root" (56)
X@Code "over" "frac" (54)
X@Code "above labove cabove rabove mabove" (52)
X@Code "nextcol" (50)
X}
XSee page {@PageOf matrix} for examples of matrices.  Here are some
Xexamples of the other symbols:
X@IL
X
X@LI {
X@Code "x dot"
X|7ct
X@Eq { x dot }
X}
X
X@LI {
X@Code "x dotdot"
X|7ct
X@Eq { x dotdot }
X}
X
X@LI {
X@Code "x hat"
X|7ct
X@Eq { x hat }
X}
X
X@LI {
X@Code "x tilde"
X|7ct
X@Eq { x tilde }
X}
X
X@LI {
X@Code "x vec"
X|7ct
X@Eq { x vec }
X}
X
X@LI {
X@Code "x dyad"
X|7ct
X@Eq { x dyad }
X}
X
X@LI {
X@Code "x+y overbar"
X|7ct
X@Eq { x+y overbar }
X}
X
X@LI {
X@Code "x+y underbar"
X|7ct
X@Eq { x+y underbar }
X}
X
X@EL
XThese marks are centred over the left parameter, except the last two which are
Xextended to the width of the object.
X@IL
X
X@LI {
X@Code "a sup b"
X|7ct
X@Eq {a sup b}
X}
X
X@LI {
X@Code "a sub b"
X|7ct
X@Eq {a sub b}
X}
X
X@LI {
X@Code "a supp b on c"
X|7ct
X@Eq {a supp b on c}
X}
X
X@EL
XNote that @Code "supp" and @Code "on" must be used together as shown.
X@IL
X
X@LI {
X@Code "big sum from i"
X|7ct
X@Eq {big sum from i}
X}
X
X@LI {
X@Code "big prod to j"
X|7ct
X@Eq {big prod to j}
X}
X
X@LI {
X@Code { "{a, ... , z} widefrom"
X"{90d @Rotate blbrace}" }
X|7ct
X@Eq { {a, ... , z} widefrom {90d @Rotate blbrace} }
X}
X
X@LI {
X@Code "{a, ... , z} wideto minus"
X|7ct
X@Eq { {a, ... , z} wideto minus }
X}
X
X@EL
X@Code "widefrom" and @Code "wideto" are like @Code "from" and
X@Code "to" except that they horizontally scale the right parameter
Xto the width of the left.
X@IL
X
X@LI {
X@Code "sqrt {x over y}"
X|7ct
X@Eq { sqrt {x over y} }
X}
X
X@LI {
X@Code "3 root {x over y}"
X|7ct
X@Eq { 3 root {x over y} }
X}
X
X@EL
XThe left parameter of @Code "root" may be any object.
X@IL
X
X@LI {
X@Code "2 over 3"
X|7ct
X@Eq { 2 over 3 }
X}
X
X@LI {
X@Code "2 frac 3"
X|7ct
X@Eq { 2 frac 3 }
X}
X
X@EL
XThe following short names define relations (that is, they have a thick
Xspace on each side):
X@DP
Xragged @Break {
X"<"		@Dbl @Eq {  <			}
X">"		@Dbl @Eq {  >			}
X"="		@Dbl @Eq {  =			}
X"<="		@Dbl @Eq {  <=			}
X"prec"		@Dbl @Eq {  prec		}
X"preceq"	@Dbl @Eq {  preceq		}
X"<<"		@Dbl @Eq {  <<			}
X"subset"	@Dbl @Eq {  subset		}
X"subseteq"	@Dbl @Eq {  subseteq		}
X"sqsubseteq"	@Dbl @Eq {  sqsubseteq		}
X"in"		@Dbl @Eq {  in			}
X"vdash"		@Dbl @Eq {  vdash		}
X"smile"		@Dbl @Eq {  smile		}
X"frown"		@Dbl @Eq {  frown		}
X">="		@Dbl @Eq {  >=			}
X"succ"		@Dbl @Eq {  succ		}
X"succeq"	@Dbl @Eq {  succeq		}
X">>"		@Dbl @Eq {  >>			}
X"supset"	@Dbl @Eq {  supset		}
X"supseteq"	@Dbl @Eq {  supseteq		}
X"sqsupseteq"	@Dbl @Eq {  sqsupseteq		}
X"ni"		@Dbl @Eq {  ni			}
X"dashv"		@Dbl @Eq {  dashv		}
X"mid"		@Dbl @Eq {  mid			}
X"parallel"	@Dbl @Eq {  parallel		}
X"=="		@Dbl @Eq {  ==			}
X"~"		@Dbl @Eq {  ~			}
X"-~"		@Dbl @Eq {  -~			}
X"asymp"		@Dbl @Eq {  asymp		}
X"~~"		@Dbl @Eq {  ~~			}
X"=~"		@Dbl @Eq {  =~			}
X"bowtie"	@Dbl @Eq {  bowtie		}
X"propto"	@Dbl @Eq {  propto		}
X"models"	@Dbl @Eq {  models		}
X"doteq"		@Dbl @Eq {  doteq		}
X"perp"		@Dbl @Eq {  perp		}
X"notsub"	@Dbl @Eq {  notsub		}
X"notin"		@Dbl @Eq {  notin		}
X"!="		@Dbl @Eq {  !=			}
X"<->"		@Dbl @Eq {  <->			}
X"<--"		@Dbl @Eq {  <--			}
X"-->"		@Dbl @Eq {  -->			}
X"up"		@Dbl @Eq {  up			}
X"down"		@Dbl @Eq {  down		}
X"<=>"		@Dbl @Eq {  <=>			}
X"<=="		@Dbl @Eq {  <==			}
X"==>"		@Dbl @Eq {  ==>			}
X"dblup"		@Dbl @Eq {  dblup		}
X"dbldown"	@Dbl @Eq {  dbldown		}
X":"		@Dbl @Eq {  :			}
X"::"		@Dbl @Eq {  ::			}
X":="		@Dbl @Eq {  :=			}
X}
X@DP
XThese can be negated by preceding them with {@Code "not"}, as in
X{@Code "not =="}, for example, which yields {@Eq { not == }}.  The
Xfollowing short names define binary operators (medium space on each side):
X@DP
Xragged @Break {
X"+"		@Dbl @Eq {  +			}
X"-"		@Dbl @Eq {  -			}
X"+-"		@Dbl @Eq {  +-			}
X"-+"		@Dbl @Eq {  -+			}
X"setminus"	@Dbl @Eq {  setminus		}
X"cdot"		@Dbl @Eq {  cdot		}
X"times"		@Dbl @Eq {  times		}
X"*"		@Dbl @Eq {  *			}
X"circ"		@Dbl @Eq {  circ		}
X"div"		@Dbl @Eq {  div			}
X"cap"		@Dbl @Eq {  cap			}
X"cup"		@Dbl @Eq {  cup			}
X"uplus"		@Dbl @Eq {  uplus		}
X"sqcap"		@Dbl @Eq {  sqcap		}
X"sqcup"		@Dbl @Eq {  sqcup		}
X"triangleleft"	@Dbl @Eq {  triangleleft	}
X"triangleright"	@Dbl @Eq {  triangleright	}
X"wr"		@Dbl @Eq {  wr			}
X"bigcirc"	@Dbl @Eq {  bigcirc		}
X"bigtriangleup"	@Dbl @Eq {  bigtriangleup	}
X"bigtriangledown"@Dbl @Eq {  bigtriangledown	}
X"vee"		@Dbl @Eq {  vee			}
X"wedge"		@Dbl @Eq {  wedge		}
X"oplus"		@Dbl @Eq {  oplus		}
X"ominus"	@Dbl @Eq {  ominus		}
X"otimes"	@Dbl @Eq {  otimes		}
X"oslash"	@Dbl @Eq {  oslash		}
X"odot"		@Dbl @Eq {  odot		}
X"dagger"	@Dbl @Eq {  dagger		}
X"daggerdbl"	@Dbl @Eq {  daggerdbl		}
X"amalg"		@Dbl @Eq {  amalg		}
X}
X@DP
XThe following names define punctuation symbols (thin space on the
Xright-hand side):
X@DP
Xragged @Break {
X";"		@Dbl @Eq {  ;			}
X","		@Dbl @Eq {  ,			}
X"col"		@Dbl @Eq {  col			}
X}
X@DP
XThe following symbols are used in ways typified by the large sum and
Xproduct symbols.  In display equations they should be preceded by the
X@Code "big" symbol:
X@DP
Xragged @Break {
X"sum"		@Dbl @Eq {  sum			}
X"prod"		@Dbl @Eq {  prod		}
X"coprod"	@Dbl @Eq {  coprod		}
X@LP
X"int"		@Dbl @Eq {  int			}
X"oint"		@Dbl @Eq {  oint		}
X"bcap"		@Dbl @Eq {  bcap		}
X@LP
X"bcup"		@Dbl @Eq {  bcup		}
X"bvee"		@Dbl @Eq {  bvee		}
X"bwedge"	@Dbl @Eq {  bwedge		}
X@LP
X"bodot"		@Dbl @Eq {  bodot		}
X"botimes"	@Dbl @Eq {  botimes		}
X"boplus"	@Dbl @Eq {  boplus		}
X@LP
X"buplus"	@Dbl @Eq {  buplus		}
X}
X@DP
XThe following symbols are defined so that they will appear in Roman,
Xas is con&-vent&-ional for them in equations:
X@DP
Xragged @Break {
X"arccos"	@Dbl @Eq {  arccos		}
X"arcsin"	@Dbl @Eq {  arcsin		}
X"arctan"	@Dbl @Eq {  arctan		}
X"arg"		@Dbl @Eq {  arg			}
X"cos"		@Dbl @Eq {  cos			}
X"cosh"		@Dbl @Eq {  cosh		}
X"cot"		@Dbl @Eq {  cot			}
X"coth"		@Dbl @Eq {  coth		}
X"csc"		@Dbl @Eq {  csc			}
X"deg"		@Dbl @Eq {  deg			}
X"det"		@Dbl @Eq {  det			}
X"dim"		@Dbl @Eq {  dim			}
X"exp"		@Dbl @Eq {  exp			}
X"gcd"		@Dbl @Eq {  gcd			}
X"hom"		@Dbl @Eq {  hom			}
X"inf"		@Dbl @Eq {  inf			}
X"ker"		@Dbl @Eq {  ker			}
X"lg"		@Dbl @Eq {  lg			}
X"lim"		@Dbl @Eq {  lim			}
X"liminf"	@Dbl @Eq {  liminf		}
X"limsup"	@Dbl @Eq {  limsup		}
X"ln"		@Dbl @Eq {  ln			}
X"log"		@Dbl @Eq {  log			}
X"max"		@Dbl @Eq {  max			}
X"min"		@Dbl @Eq {  min			}
X"Pr"		@Dbl @Eq {  Pr			}
X"sec"		@Dbl @Eq {  sec			}
X"sin"		@Dbl @Eq {  sin			}
X"sinh"		@Dbl @Eq {  sinh		}
X"supr"		@Dbl @Eq {  supr		}
X"tan"		@Dbl @Eq {  tan			}
X"tanh"		@Dbl @Eq {  tanh		}
X"mod"		@Dbl @Eq {  mod			}
X}
X@DP
XThe following symbols are also defined to ensure that they will appear
Xin Roman:
X@DP
Xragged @Break {
X"0"		@Dbl @Eq {  0			}
X"1"		@Dbl @Eq {  1			}
X"2"		@Dbl @Eq {  2			}
X"3"		@Dbl @Eq {  3			}
X"4"		@Dbl @Eq {  4			}
X"5"		@Dbl @Eq {  5			}
X"6"		@Dbl @Eq {  6			}
X"7"		@Dbl @Eq {  7			}
X"8"		@Dbl @Eq {  8			}
X"9"		@Dbl @Eq {  9			}
X"!"		@Dbl @Eq {  !			}
X"?"		@Dbl @Eq {  ?			}
X"%"		@Dbl @Eq {  %			}
X"("		@Dbl @Eq {  (			}
X")"		@Dbl @Eq {  )			}
X"["		@Dbl @Eq {  [			}
X"]"		@Dbl @Eq {  ]			}
X}
X@DP
XThe following symbols make good @Code atleft and
X@Code atright parameters of the @Code matrix symbol:
X@LP
X@LP
Xragged @Break {
X"lpar"		@Dbl @Eq {  lpar		}
X"blpar"		@Dbl @Eq {  blpar		}
X"rpar"		@Dbl @Eq {  rpar		}
X"brpar"		@Dbl @Eq {  brpar		}
X"lbrack"	@Dbl @Eq {  lbrack		}
X"blbrack"	@Dbl @Eq {  blbrack		}
X"rbrack"	@Dbl @Eq {  rbrack		}
X"brbrack"	@Dbl @Eq {  brbrack		}
X"lbrace"	@Dbl @Eq {  lbrace		}
X"blbrace"	@Dbl @Eq {  blbrace		}
X"rbrace"	@Dbl @Eq {  rbrace		}
X"brbrace"	@Dbl @Eq {  brbrace		}
X"lfloor"	@Dbl @Eq {  lfloor		}
X"blfloor"	@Dbl @Eq {  blfloor		}
X"rfloor"	@Dbl @Eq {  rfloor		}
X"brfloor"	@Dbl @Eq {  brfloor		}
X"lceil"		@Dbl @Eq {  lceil		}
X"blceil"	@Dbl @Eq {  blceil		}
X"rceil"		@Dbl @Eq {  rceil		}
X"brceil"	@Dbl @Eq {  brceil		}
X"langle"	@Dbl @Eq {  langle		}
X"blangle"	@Dbl @Eq {  blangle		}
X"rangle"	@Dbl @Eq {  rangle		}
X"brangle"	@Dbl @Eq {  brangle		}
X}
X@LP
X@LP
XHere are some miscellaneous symbols:
X@DP
Xragged @Break {
X"hbar"		@Dbl @Eq {  hbar		}
X"Re"		@Dbl @Eq {  Re			}
X"Im"		@Dbl @Eq {  Im			}
X"partial"	@Dbl @Eq {  partial		}
X"infty"		@Dbl @Eq {  infty		}
X"prime"		@Dbl @Eq {  prime		}
X"nabla"		@Dbl @Eq {  nabla		}
X"surd"		@Dbl @Eq {  surd		}
X"top"		@Dbl @Eq {  top			}
X"bot"		@Dbl @Eq {  bot			}
X"dbar"		@Dbl @Eq {  dbar		}
X"triangle"	@Dbl @Eq {  triangle		}
X"backslash"	@Dbl @Eq {  backslash		}
X"forall"	@Dbl @Eq {  forall		}
X"exists"	@Dbl @Eq {  exists		}
X"neg"		@Dbl @Eq {  neg			}
X"circle"	@Dbl @Eq {  circle		}
X"square"	@Dbl @Eq {  square		}
X"ldots"		@Dbl @Eq {  ldots		}
X"cdots"		@Dbl @Eq {  cdots		}
X"vdots"		@Dbl @Eq {  vdots		}
X"ddots"		@Dbl @Eq {  ddots		}
X"del"		@Dbl @Eq {  del			}
X"grad"		@Dbl @Eq {  grad		}
X"..."		@Dbl @Eq {  ...			}
X",...,"		@Dbl @Eq {  ,...,		}
X"half"		@Dbl @Eq {  half		}
X"third"		@Dbl @Eq {  third		}
X"'"		@Dbl @Eq {  '			}
X"empty"		@Dbl @Eq {  empty		}
X}
X@DP
XFinally, here is the long list of full names from the Adobe Symbol font:
X@DP
Xragged @Break {
X"space"		@Dbl @Eq {  space		}
X"exclam"	@Dbl @Eq {  exclam		}
X"universal"	@Dbl @Eq {  universal		}
X"numbersign"	@Dbl @Eq {  numbersign		}
X"existential"	@Dbl @Eq {  existential		}
X"percent"	@Dbl @Eq {  percent		}
X"ampersand"	@Dbl @Eq {  ampersand		}
X"suchthat"	@Dbl @Eq {  suchthat		}
X"parenleft"	@Dbl @Eq {  parenleft		}
X"parenright"	@Dbl @Eq {  parenright		}
X"asteriskmath"	@Dbl @Eq {  asteriskmath	}
X"plus"		@Dbl @Eq {  plus		}
X"comma"		@Dbl @Eq {  comma		}
X"minus"		@Dbl @Eq {  minus		}
X"period"	@Dbl @Eq {  period		}
X"slash"		@Dbl @Eq {  slash		}
X"zero"		@Dbl @Eq {  zero		}
X"one"		@Dbl @Eq {  one			}
X"two"		@Dbl @Eq {  two			}
X"three"		@Dbl @Eq {  three		}
X"four"		@Dbl @Eq {  four		}
X"five"		@Dbl @Eq {  five		}
X"six"		@Dbl @Eq {  six			}
X"seven"		@Dbl @Eq {  seven		}
X"eight"		@Dbl @Eq {  eight		}
X"nine"		@Dbl @Eq {  nine		}
X"colon"		@Dbl @Eq {  colon		}
X"semicolon"	@Dbl @Eq {  semicolon		}
X"less"		@Dbl @Eq {  less		}
X"equal"		@Dbl @Eq {  equal		}
X"greater"	@Dbl @Eq {  greater		}
X"question"	@Dbl @Eq {  question		}
X"congruent"	@Dbl @Eq {  congruent		}
X"Alpha"		@Dbl @Eq {  Alpha		}
X"Beta"		@Dbl @Eq {  Beta		}
X"Chi"		@Dbl @Eq {  Chi			}
X"Delta"		@Dbl @Eq {  Delta		}
X"Epsilon"	@Dbl @Eq {  Epsilon		}
X"Phi"		@Dbl @Eq {  Phi			}
X"Gamma"		@Dbl @Eq {  Gamma		}
X"Eta"		@Dbl @Eq {  Eta			}
X"Iota"		@Dbl @Eq {  Iota		}
X"thetaone"	@Dbl @Eq {  thetaone		}
X"Kappa"		@Dbl @Eq {  Kappa		}
X"Lambda"	@Dbl @Eq {  Lambda		}
X"Mu"		@Dbl @Eq {  Mu			}
X"Nu"		@Dbl @Eq {  Nu			}
X"Omicron"	@Dbl @Eq {  Omicron		}
X"Pi"		@Dbl @Eq {  Pi			}
X"Theta"		@Dbl @Eq {  Theta		}
X"Rho"		@Dbl @Eq {  Rho			}
X"Sigma"		@Dbl @Eq {  Sigma		}
X"Tau"		@Dbl @Eq {  Tau			}
X"Upsilon"	@Dbl @Eq {  Upsilon		}
X"sigmaone"	@Dbl @Eq {  sigmaone		}
X"Omega"		@Dbl @Eq {  Omega		}
X"Xi"		@Dbl @Eq {  Xi			}
X"Psi"		@Dbl @Eq {  Psi			}
X"Zeta"		@Dbl @Eq {  Zeta		}
X"bracketleft"	@Dbl @Eq {  bracketleft		}
X"therefore"	@Dbl @Eq {  therefore		}
X"bracketright"	@Dbl @Eq {  bracketright	}
X"perpendicular"	@Dbl @Eq {  perpendicular	}
X"underscore"	@Dbl @Eq {  underscore		}
X"radicalex"	@Dbl @Eq {  radicalex		}
X"alpha"		@Dbl @Eq {  alpha		}
X"beta"		@Dbl @Eq {  beta		}
X"chi"		@Dbl @Eq {  chi			}
X"delta"		@Dbl @Eq {  delta		}
X"epsilon"	@Dbl @Eq {  epsilon		}
X"phi"		@Dbl @Eq {  phi			}
X"gamma"		@Dbl @Eq {  gamma		}
X"eta"		@Dbl @Eq {  eta			}
X"iota"		@Dbl @Eq {  iota		}
X"phione"	@Dbl @Eq {  phione		}
X"kappa"		@Dbl @Eq {  kappa		}
X"lambda"	@Dbl @Eq {  lambda		}
X"mu"		@Dbl @Eq {  mu			}
X"nu"		@Dbl @Eq {  nu			}
X"omicron"	@Dbl @Eq {  omicron		}
X"pi"		@Dbl @Eq {  pi			}
X"theta"		@Dbl @Eq {  theta		}
X"rho"		@Dbl @Eq {  rho			}
X"sigma"		@Dbl @Eq {  sigma		}
X"tau"		@Dbl @Eq {  tau			}
X"upsilon"	@Dbl @Eq {  upsilon		}
X"omegaone"	@Dbl @Eq {  omegaone		}
X"omega"		@Dbl @Eq {  omega		}
X"xi"		@Dbl @Eq {  xi			}
X"psi"		@Dbl @Eq {  psi			}
X"zeta"		@Dbl @Eq {  zeta		}
X"braceleft"	@Dbl @Eq {  braceleft		}
X"bar"		@Dbl @Eq {  bar			}
X"braceright"	@Dbl @Eq {  braceright		}
X"similar"	@Dbl @Eq {  similar		}
X"Upsilonone"	@Dbl @Eq {  Upsilonone		}
X"minute"	@Dbl @Eq {  minute		}
X"lessequal"	@Dbl @Eq {  lessequal		}
X"fraction"	@Dbl @Eq {  fraction		}
X"infinity"	@Dbl @Eq {  infinity		}
X"florin"	@Dbl @Eq {  florin		}
X"club"		@Dbl @Eq {  club		}
X"diamond"	@Dbl @Eq {  diamond		}
X"heart"		@Dbl @Eq {  heart		}
X"spade"		@Dbl @Eq {  spade		}
X"arrowboth"	@Dbl @Eq {  arrowboth		}
X"arrowleft"	@Dbl @Eq {  arrowleft		}
X"arrowup"	@Dbl @Eq {  arrowup		}
X"arrowright"	@Dbl @Eq {  arrowright		}
X"arrowdown"	@Dbl @Eq {  arrowdown		}
X"degree"	@Dbl @Eq {  degree		}
X"plusminus"	@Dbl @Eq {  plusminus		}
X"second"	@Dbl @Eq {  second		}
X"greaterequal"	@Dbl @Eq {  greaterequal	}
X"multiply"	@Dbl @Eq {  multiply		}
X"proportional"	@Dbl @Eq {  proportional	}
X"partialdiff"	@Dbl @Eq {  partialdiff		}
X"bullet"	@Dbl @Eq {  bullet		}
X"divide"	@Dbl @Eq {  divide		}
X"notequal"	@Dbl @Eq {  notequal		}
X"equivalence"	@Dbl @Eq {  equivalence		}
X"approxequal"	@Dbl @Eq {  approxequal		}
X"ellipsis"	@Dbl @Eq {  ellipsis		}
X"arrowvertex"	@Dbl @Eq {  arrowvertex		}
X"arrowhorizex"	@Dbl @Eq {  arrowhorizex	}
X"carriagereturn"@Dbl @Eq {  carriagereturn	}
X"aleph"		@Dbl @Eq {  aleph		}
X"Ifraktur"	@Dbl @Eq {  Ifraktur		}
X"Rfraktur"	@Dbl @Eq {  Rfraktur		}
X"weierstrass"	@Dbl @Eq {  weierstrass		}
X"circlemultiply"@Dbl @Eq {  circlemultiply	}
X"circleplus"	@Dbl @Eq {  circleplus		}
X"emptyset"	@Dbl @Eq {  emptyset		}
X"intersection"	@Dbl @Eq {  intersection	}
X"union"		@Dbl @Eq {  union		}
X"propersuperset"@Dbl @Eq {  propersuperset	}
X"reflexsuperset"@Dbl @Eq {  reflexsuperset	}
X"notsubset"	@Dbl @Eq {  notsubset		}
X"propersubset"	@Dbl @Eq {  propersubset	}
X"reflexsubset"	@Dbl @Eq {  reflexsubset	}
X"element"	@Dbl @Eq {  element		}
X"notelement"	@Dbl @Eq {  notelement		}
X"angle"		@Dbl @Eq {  angle		}
X"gradient"	@Dbl @Eq {  gradient		}
X"registerserif"	@Dbl @Eq {  registerserif	}
X"copyrightserif"@Dbl @Eq {  copyrightserif	}
X"trademarkserif"@Dbl @Eq {  trademarkserif	}
X"product"	@Dbl @Eq {  product		}
X"radical"	@Dbl @Eq {  radical		}
X"dotmath"	@Dbl @Eq {  dotmath		}
X"logicalnot"	@Dbl @Eq {  logicalnot		}
X"logicaland"	@Dbl @Eq {  logicaland		}
X"logicalor"	@Dbl @Eq {  logicalor		}
X"arrowdblboth"	@Dbl @Eq {  arrowdblboth	}
X"arrowdblleft"	@Dbl @Eq {  arrowdblleft	}
X"arrowdblup"	@Dbl @Eq {  arrowdblup		}
X"arrowdblright"	@Dbl @Eq {  arrowdblright	}
X"arrowdbldown"	@Dbl @Eq {  arrowdbldown	}
X"lozenge"	@Dbl @Eq {  lozenge		}
X"angleleft"	@Dbl @Eq {  angleleft		}
X"registersans"	@Dbl @Eq {  registersans	}
X"copyrightsans"	@Dbl @Eq {  copyrightsans	}
X"trademarksans"	@Dbl @Eq {  trademarksans	}
X"summation"	@Dbl @Eq {  summation		}
X"parenlefttp"	@Dbl @Eq {  parenlefttp		}
X"parenleftex"	@Dbl @Eq {  parenleftex		}
X"parenleftbt"	@Dbl @Eq {  parenleftbt		}
X"bracketlefttp"	@Dbl @Eq {  bracketlefttp	}
X"bracketleftex"	@Dbl @Eq {  bracketleftex	}
X"bracketleftbt"	@Dbl @Eq {  bracketleftbt	}
X"bracelefttp"	@Dbl @Eq {  bracelefttp		}
X"braceleftmid"	@Dbl @Eq {  braceleftmid	}
X"braceleftbt"	@Dbl @Eq {  braceleftbt		}
X"braceex"	@Dbl @Eq {  braceex		}
X"angleright"	@Dbl @Eq {  angleright		}
X"integral"	@Dbl @Eq {  integral		}
X"integraltp"	@Dbl @Eq {  integraltp		}
X"integralex"	@Dbl @Eq {  integralex		}
X"integralbt"	@Dbl @Eq {  integralbt		}
X"parenrighttp"	@Dbl @Eq {  parenrighttp	}
X"parenrightex"	@Dbl @Eq {  parenrightex	}
X"parenrightbt"	@Dbl @Eq {  parenrightbt	}
X"bracketrighttp"@Dbl @Eq {  bracketrighttp	}
X"bracketrightex"@Dbl @Eq {  bracketrightex	}
X"bracketrightbt"@Dbl @Eq {  bracketrightbt	}
X"bracerighttp"	@Dbl @Eq {  bracerighttp	}
X"bracerightmid"	@Dbl @Eq {  bracerightmid	}
X"bracerightbt"	@Dbl @Eq {  bracerightbt	}
X}
X@DP
XThe names given are the same as Adobe's except in a few places where
Xthe Adobe name contains a digit, which is not possible in Lout.
X@End @Section
END_OF_FILE
  if test 16617 -ne `wc -c <'doc/tr.eq/s5'`; then
    echo shar: \"'doc/tr.eq/s5'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.eq/s5'
fi
if test -f 'doc/tr.impl/s5.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s5.3'\"
else
  echo shar: Extracting \"'doc/tr.impl/s5.3'\" \(4681 characters\)
  sed "s/^X//" >'doc/tr.impl/s5.3' <<'END_OF_FILE'
X@SubSection
X    @Tag { constraints }
X    @Title { Size constraints and size adjustments }
X@Begin
X@PP
XThe galley flushing algorithm needs to know the available width and
Xheight at each receptive symbol.  These symbols may lie within
Xarbitrarily complex objects, and they may compete with each other for
Xavailable space (as body text and footnote targets do), so this
Xinformation must be extracted from the tree structure when required.
X@PP
XFor example, consider the object
X@ID @Code "5i  @Wide  {  a  /  b  }"
Xand suppose that the width of @Code { a } is @Eq { 1i, 2i } (@Eq {1i} to
Xthe left of the mark, @Eq { 2i } to the right).  What then is the
Xavailable width at {@Code { b }}?  If we let the width of @Code b be
X@Eq {l,r}, we must have
X@ID @Eq { (1i up l) + (2i up r) <= 5i }
Xwith the @Eq {non up } (i.e. max) operations arising from mark
Xalignment.  Eliminating them gives
X@ID @Eq {
Xmatrix {
X	{ 1i + 2i ^<= 5i }
Xmabove	{ l  + 2i ^<= 5i }
Xmabove	{ 1i + r  ^<= 5i }
Xmabove	{ l  + r  ^<= 5i }
X}
X}
Xand since we assume that @Code a fits into the available space, the
Xfirst inequality may be dropped, leaving
X@ID @Eq {
Xmatrix {
X	{ l     ^<= 3i }
Xmabove	{ l + r ^<= 5i }
Xmabove	{ r     ^<= 4i }
X}
X}
XObject @Code b may have width @Eq {l, r} for any @Eq { l } and
X@Eq { r } satisfying these inequalities, and no others.
X@PP
XHere is another example:
X@ID @Code "5i  @High  {  a  /2ix  b  }"
XAssuming that @Code a has height @Eq {1i,1i}, the height @Eq {l, r} of
X@Code b must satisfy
X@ID @Eq { 1i + ((1i + l) up 2i) + r <= 5i }
XThis time the @Eq { non up } operation arises from the mark-to-mark gap
Xmode, which will widen the @Eq { 2i } gap if necessary to prevent
X@Code a and @Code b from overlapping.  This inequality can be rewritten as
X@ID @Eq {
Xmatrix {
X	{ l     ^<= infinity }
Xmabove	{ l + r ^<= 3i       }
Xmabove	{ r     ^<= 2i       }
X}
X}
XIn general, Lout is designed so that the available width or height at
Xany point can be expressed by three inequalities of the form
X@ID @Eq {
Xmatrix {
X	{ l     ^<= x }
Xmabove	{ l + r ^<= y }
Xmabove	{ r     ^<= z }
X}
X}
Xwhere @Eq {x }, @Eq {y} and @Eq {z} may be @Eq { infinity }.  We
Xabbreviate these three inequalities to @Eq { l, r <= x, y, z }, and we
Xcall @Eq {x, y, z} a {@I{size constraint}}.
X@PP
XThe two examples above showed how to propagate the size constraint
X@Eq { infinity, 5i, infinity } for
X@Code "a / b" down one level to the child {@Code b}.  Basser Lout
Xcontains a complete set of general rules for all node types, too
Xcomplicated to give here.  Instead, we give just one example of how
Xthese rules are derived, using the object
X@ID {
X@Eq {x sub 1}  @Code "/"  @Eq {x sub 2}  @Code "/"  @Eq {ldots}  @Code
X"/"  @Eq {x sub n}
X}
Xwhere @Eq { x sub j } has width @Eq { l sub j , r sub j } for all @Eq {j}.
X@PP
XSuppose the whole object has width constraint @OneCol @Eq {X,Y,Z}, and we
Xrequire the width constraint of {@Eq { x sub i }}.  Let
X@Eq { L = max sub j ` l sub j } and @Eq { R = max sub j ` r sub j },
Xso that @OneCol @Eq {L, R} is the width of the whole object.  We assume
X@Eq {L, R <= X,Y,Z}.  Then @Eq { x sub i } can be enlarged to any size
X@Eq { l sub i ` , r sub i } satisfying
X@ID @Eq { ( l sub i up L), ( r sub i up R) <= X, Y, Z }
Xwhich expands to eight inequalities:
X@ID @Eq {
Xmatrix {
X         { l sub i           ^<= X }
Xmabove   { L                 ^<= X }
Xmabove   { l sub i + r sub i ^<= Y }
Xmabove   { l sub i + R       ^<= Y }
Xmabove   { L + r sub i       ^<= Y }
Xmabove   { L + R             ^<= Y }
Xmabove   { r sub i           ^<= Z }
Xmabove   { R                 ^<= Z }
X}
X}
XThree are already known, and slightly rearranging the others gives
X@ID @Eq {
Xmatrix {
X         { l sub i           ^<= X     }
Xmabove   { l sub i           ^<= Y - R }
Xmabove   { l sub i + r sub i ^<= Y     }
Xmabove   { r sub i           ^<= Z     }
Xmabove   { r sub i           ^<= Y - L }
X}
X}
XTherefore the width constraint of @Eq { x sub i } is
X@ID @Eq { min(X, Y-R), Y, min(Z, Y-L) }
XThe size constraint of any node can be found by climbing the tree to a
X@I WIDE or @I HIGH node where the constraint is trivial, then propagating
Xit back down to the node, and this is the function of procedure
X{@I Constrained} in Basser Lout.
X@PP
XAfter some components have been promoted into a target, the sizes stored
Xin its parent and higher ancestors must be adjusted to reflect the
Xincreased size.  This is done by yet another set of recursive rules,
Xupward-moving this time, which cease as soon as some ancestor's size
Xdoes not change.  These rules are embodied in procedure @I AdjustSize
Xof Basser Lout.  The adjustment must be done before relinquishing
Xcontrol to any other galley, but not after every component.
X@End @SubSection
END_OF_FILE
  if test 4681 -ne `wc -c <'doc/tr.impl/s5.3'`; then
    echo shar: \"'doc/tr.impl/s5.3'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s5.3'
fi
if test -f 'font/NewCenSchBolIta.AFM' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font/NewCenSchBolIta.AFM'\"
else
  echo shar: Extracting \"'font/NewCenSchBolIta.AFM'\" \(15704 characters\)
  sed "s/^X//" >'font/NewCenSchBolIta.AFM' <<'END_OF_FILE'
XStartFontMetrics 2.0
XComment  Copyright (c) 1985, 1987 Adobe Systems Incorporated. All rights reserved.
XComment Creation Date:Fri Jul 17 18:25:22 PDT 1987
XFontName NewCenturySchlbk-BoldItalic
XEncodingScheme AdobeStandardEncoding
XFullName New Century Schoolbook Bold Italic
XFamilyName New Century Schoolbook
XWeight Bold
XItalicAngle -16.0
XIsFixedPitch false
XUnderlinePosition -102
XUnderlineThickness 54
XVersion 001.004
XNotice Copyright (c) 1985, 1987 Adobe Systems Incorporated.  All rights reserved. New Century Schoolbook is a trademark of Linotype Company.
XFontBBox -170 -220 1151 990
XCapHeight 722
XXHeight 477
XDescender -205
XAscender 737
XStartCharMetrics 228
XC 32 ; WX 287 ; N space ; B 0 0 0 0 ;
XC 33 ; WX 333 ; N exclam ; B 3 -15 336 737 ;
XC 34 ; WX 400 ; N quotedbl ; B 100 410 507 736 ;
XC 35 ; WX 574 ; N numbersign ; B 41 0 533 705 ;
XC 36 ; WX 574 ; N dollar ; B 3 -143 559 799 ;
XC 37 ; WX 889 ; N percent ; B 51 -34 836 721 ;
XC 38 ; WX 889 ; N ampersand ; B 31 -15 823 737 ;
XC 39 ; WX 259 ; N quoteright ; B 70 389 301 739 ;
XC 40 ; WX 407 ; N parenleft ; B 71 -123 452 740 ;
XC 41 ; WX 407 ; N parenright ; B -70 -123 308 740 ;
XC 42 ; WX 500 ; N asterisk ; B 32 268 472 704 ;
XC 43 ; WX 606 ; N plus ; B 41 0 545 505 ;
XC 44 ; WX 287 ; N comma ; B -48 -190 180 159 ;
XC 45 ; WX 333 ; N hyphen ; B 10 178 272 297 ;
XC 46 ; WX 287 ; N period ; B 12 -15 186 159 ;
XC 47 ; WX 278 ; N slash ; B -25 -15 311 737 ;
XC 48 ; WX 574 ; N zero ; B 21 -15 553 705 ;
XC 49 ; WX 574 ; N one ; B 25 0 489 705 ;
XC 50 ; WX 574 ; N two ; B -40 0 538 705 ;
XC 51 ; WX 574 ; N three ; B -5 -15 538 705 ;
XC 52 ; WX 574 ; N four ; B -13 0 544 705 ;
XC 53 ; WX 574 ; N five ; B 0 -15 573 705 ;
XC 54 ; WX 574 ; N six ; B 30 -15 573 705 ;
XC 55 ; WX 574 ; N seven ; B 64 -15 593 705 ;
XC 56 ; WX 574 ; N eight ; B 0 -15 551 705 ;
XC 57 ; WX 574 ; N nine ; B 1 -15 544 705 ;
XC 58 ; WX 287 ; N colon ; B -2 -15 257 477 ;
XC 59 ; WX 287 ; N semicolon ; B -39 -190 257 477 ;
XC 60 ; WX 606 ; N less ; B 14 -15 523 524 ;
XC 61 ; WX 606 ; N equal ; B 41 109 545 402 ;
XC 62 ; WX 606 ; N greater ; B 38 -15 547 524 ;
XC 63 ; WX 481 ; N question ; B 79 -15 452 737 ;
XC 64 ; WX 747 ; N at ; B 22 -15 722 737 ;
XC 65 ; WX 741 ; N A ; B -75 0 716 737 ;
XC 66 ; WX 759 ; N B ; B -50 0 720 722 ;
XC 67 ; WX 759 ; N C ; B 35 -15 759 737 ;
XC 68 ; WX 833 ; N D ; B -49 0 796 722 ;
XC 69 ; WX 741 ; N E ; B -41 0 728 722 ;
XC 70 ; WX 704 ; N F ; B -41 0 726 722 ;
XC 71 ; WX 815 ; N G ; B 34 -15 802 737 ;
XC 72 ; WX 870 ; N H ; B -41 0 912 722 ;
XC 73 ; WX 444 ; N I ; B -41 0 486 722 ;
XC 74 ; WX 667 ; N J ; B -9 -15 718 722 ;
XC 75 ; WX 778 ; N K ; B -41 0 832 722 ;
XC 76 ; WX 704 ; N L ; B -41 0 670 722 ;
XC 77 ; WX 944 ; N M ; B -24 0 988 722 ;
XC 78 ; WX 852 ; N N ; B -57 -16 912 722 ;
XC 79 ; WX 833 ; N O ; B 36 -15 797 737 ;
XC 80 ; WX 741 ; N P ; B -38 0 731 722 ;
XC 81 ; WX 833 ; N Q ; B 35 -186 796 737 ;
XC 82 ; WX 796 ; N R ; B -41 -15 751 722 ;
XC 83 ; WX 685 ; N S ; B 1 -15 666 737 ;
XC 84 ; WX 722 ; N T ; B 44 0 762 722 ;
XC 85 ; WX 833 ; N U ; B 88 -15 895 722 ;
XC 86 ; WX 741 ; N V ; B 32 -15 802 722 ;
XC 87 ; WX 944 ; N W ; B 40 -15 994 722 ;
XC 88 ; WX 741 ; N X ; B -72 0 811 722 ;
XC 89 ; WX 704 ; N Y ; B 15 0 777 722 ;
XC 90 ; WX 704 ; N Z ; B -29 0 715 722 ;
XC 91 ; WX 407 ; N bracketleft ; B -31 -110 432 737 ;
XC 92 ; WX 606 ; N backslash ; B 81 0 545 737 ;
XC 93 ; WX 407 ; N bracketright ; B -49 -110 414 737 ;
XC 94 ; WX 606 ; N asciicircum ; B 52 319 554 722 ;
XC 95 ; WX 500 ; N underscore ; B 0 -129 500 -75 ;
XC 96 ; WX 259 ; N quoteleft ; B 39 397 270 747 ;
XC 97 ; WX 667 ; N a ; B 15 -15 646 477 ;
XC 98 ; WX 611 ; N b ; B 28 -15 557 737 ;
XC 99 ; WX 537 ; N c ; B 3 -15 487 477 ;
XC 100 ; WX 667 ; N d ; B 0 -15 663 737 ;
XC 101 ; WX 519 ; N e ; B -2 -15 478 477 ;
XC 102 ; WX 389 ; N f ; B -48 -205 550 737 ; L i fi ; L l fl ;
XC 103 ; WX 611 ; N g ; B -66 -205 602 529 ;
XC 104 ; WX 685 ; N h ; B 0 -15 637 737 ;
XC 105 ; WX 389 ; N i ; B 28 -15 343 737 ;
XC 106 ; WX 370 ; N j ; B -170 -205 381 737 ;
XC 107 ; WX 648 ; N k ; B -5 -15 584 737 ;
XC 108 ; WX 389 ; N l ; B 26 -15 370 737 ;
XC 109 ; WX 944 ; N m ; B 9 -15 920 477 ;
XC 110 ; WX 685 ; N n ; B 3 -15 642 477 ;
XC 111 ; WX 574 ; N o ; B 10 -15 540 477 ;
XC 112 ; WX 648 ; N p ; B -118 -205 590 477 ;
XC 113 ; WX 630 ; N q ; B 0 -205 587 477 ;
XC 114 ; WX 519 ; N r ; B 3 0 524 486 ;
XC 115 ; WX 481 ; N s ; B 2 -15 437 477 ;
XC 116 ; WX 407 ; N t ; B 24 -15 404 650 ;
XC 117 ; WX 685 ; N u ; B 38 -15 639 477 ;
XC 118 ; WX 556 ; N v ; B 32 -15 500 477 ;
XC 119 ; WX 833 ; N w ; B 22 -15 788 477 ;
XC 120 ; WX 574 ; N x ; B -49 -15 571 477 ;
XC 121 ; WX 519 ; N y ; B -66 -205 492 477 ;
XC 122 ; WX 519 ; N z ; B -18 -15 472 477 ;
XC 123 ; WX 407 ; N braceleft ; B 51 -115 401 738 ;
XC 124 ; WX 606 ; N bar ; B 262 0 343 737 ;
XC 125 ; WX 407 ; N braceright ; B -30 -115 322 738 ;
XC 126 ; WX 606 ; N asciitilde ; B 51 158 555 353 ;
XC 161 ; WX 333 ; N exclamdown ; B -39 -205 289 544 ;
XC 162 ; WX 574 ; N cent ; B 30 -124 514 600 ;
XC 163 ; WX 574 ; N sterling ; B -18 -15 566 705 ;
XC 164 ; WX 167 ; N fraction ; B -166 -15 333 705 ;
XC 165 ; WX 574 ; N yen ; B 23 0 635 705 ;
XC 166 ; WX 574 ; N florin ; B -27 -205 588 737 ;
XC 167 ; WX 500 ; N section ; B -40 -145 505 737 ;
XC 168 ; WX 574 ; N currency ; B 40 110 546 612 ;
XC 169 ; WX 287 ; N quotesingle ; B 100 409 269 735 ;
XC 170 ; WX 481 ; N quotedblleft ; B 52 397 522 747 ;
XC 171 ; WX 481 ; N guillemotleft ; B -35 68 427 409 ;
XC 172 ; WX 278 ; N guilsinglleft ; B -35 68 224 409 ;
XC 173 ; WX 278 ; N guilsinglright ; B -5 67 254 408 ;
XC 174 ; WX 685 ; N fi ; B -70 -205 646 737 ;
XC 175 ; WX 685 ; N fl ; B -70 -205 681 737 ;
XC 177 ; WX 500 ; N endash ; B -18 189 518 286 ;
XC 178 ; WX 500 ; N dagger ; B 50 -146 510 737 ;
XC 179 ; WX 500 ; N daggerdbl ; B -48 -147 514 737 ;
XC 180 ; WX 287 ; N periodcentered ; B 41 168 215 342 ;
XC 182 ; WX 650 ; N paragraph ; B 67 0 661 737 ;
XC 183 ; WX 606 ; N bullet ; B 109 200 446 537 ;
XC 184 ; WX 259 ; N quotesinglbase ; B -43 -191 188 159 ;
XC 185 ; WX 481 ; N quotedblbase ; B -70 -191 402 159 ;
XC 186 ; WX 481 ; N quotedblright ; B 61 389 533 739 ;
XC 187 ; WX 481 ; N guillemotright ; B -5 67 457 408 ;
XC 188 ; WX 1000 ; N ellipsis ; B 20 -15 860 159 ;
XC 189 ; WX 1167 ; N perthousand ; B 26 -34 1151 721 ;
XC 191 ; WX 481 ; N questiondown ; B 1 -205 368 544 ;
XC 193 ; WX 333 ; N grave ; B 74 535 294 719 ;
XC 194 ; WX 333 ; N acute ; B 123 535 371 719 ;
XC 195 ; WX 333 ; N circumflex ; B 23 535 365 709 ;
XC 196 ; WX 333 ; N tilde ; B 34 557 404 683 ;
XC 197 ; WX 333 ; N macron ; B 32 573 387 649 ;
XC 198 ; WX 333 ; N breve ; B 67 534 390 698 ;
XC 199 ; WX 333 ; N dotaccent ; B 145 542 288 685 ;
XC 200 ; WX 333 ; N dieresis ; B 34 542 392 685 ;
XC 202 ; WX 333 ; N ring ; B 217 530 432 745 ;
XC 203 ; WX 333 ; N cedilla ; B -87 -220 157 3 ;
XC 205 ; WX 333 ; N hungarumlaut ; B 23 535 472 719 ;
XC 206 ; WX 333 ; N ogonek ; B 68 -155 245 -10 ;
XC 207 ; WX 333 ; N caron ; B 60 535 403 709 ;
XC 208 ; WX 1000 ; N emdash ; B -18 189 1018 286 ;
XC 225 ; WX 889 ; N AE ; B -81 0 906 722 ;
XC 227 ; WX 412 ; N ordfeminine ; B 29 327 449 737 ;
XC 232 ; WX 704 ; N Lslash ; B -41 0 670 722 ;
XC 233 ; WX 833 ; N Oslash ; B 17 -82 797 775 ;
XC 234 ; WX 963 ; N OE ; B 19 0 980 722 ;
XC 235 ; WX 356 ; N ordmasculine ; B 29 327 383 737 ;
XC 241 ; WX 815 ; N ae ; B -19 -15 774 477 ;
XC 245 ; WX 389 ; N dotlessi ; B 38 -15 353 477 ;
XC 248 ; WX 389 ; N lslash ; B 26 -15 397 737 ;
XC 249 ; WX 574 ; N oslash ; B 10 -126 540 578 ;
XC 250 ; WX 852 ; N oe ; B -5 -15 810 477 ;
XC 251 ; WX 574 ; N germandbls ; B -66 -205 523 737 ;
XC -1 ; WX 741 ; N Aacute ; B -75 0 716 964 ;
XC -1 ; WX 741 ; N Acircumflex ; B -75 0 716 954 ;
XC -1 ; WX 741 ; N Adieresis ; B -75 0 716 930 ;
XC -1 ; WX 741 ; N Agrave ; B -75 0 716 964 ;
XC -1 ; WX 741 ; N Aring ; B -75 0 716 990 ;
XC -1 ; WX 741 ; N Atilde ; B -75 0 716 928 ;
XC -1 ; WX 759 ; N Ccedilla ; B 35 -220 759 737 ;
XC -1 ; WX 741 ; N Eacute ; B -41 0 728 964 ;
XC -1 ; WX 741 ; N Ecircumflex ; B -41 0 728 954 ;
XC -1 ; WX 741 ; N Edieresis ; B -41 0 728 930 ;
XC -1 ; WX 741 ; N Egrave ; B -41 0 728 964 ;
XC -1 ; WX 833 ; N Eth ; B -49 0 796 722 ;
XC -1 ; WX 444 ; N Iacute ; B -41 0 486 964 ;
XC -1 ; WX 444 ; N Icircumflex ; B -41 0 486 954 ;
XC -1 ; WX 444 ; N Idieresis ; B -41 0 498 930 ;
XC -1 ; WX 444 ; N Igrave ; B -41 0 486 964 ;
XC -1 ; WX 852 ; N Ntilde ; B -57 -16 912 928 ;
XC -1 ; WX 833 ; N Oacute ; B 36 -15 797 964 ;
XC -1 ; WX 833 ; N Ocircumflex ; B 36 -15 797 954 ;
XC -1 ; WX 833 ; N Odieresis ; B 36 -15 797 930 ;
XC -1 ; WX 833 ; N Ograve ; B 36 -15 797 964 ;
XC -1 ; WX 833 ; N Otilde ; B 36 -15 797 928 ;
XC -1 ; WX 685 ; N Scaron ; B 1 -15 666 954 ;
XC -1 ; WX 741 ; N Thorn ; B -38 0 690 722 ;
XC -1 ; WX 833 ; N Uacute ; B 88 -15 895 964 ;
XC -1 ; WX 833 ; N Ucircumflex ; B 88 -15 895 954 ;
XC -1 ; WX 833 ; N Udieresis ; B 88 -15 895 930 ;
XC -1 ; WX 833 ; N Ugrave ; B 88 -15 895 964 ;
XC -1 ; WX 704 ; N Yacute ; B 15 0 777 964 ;
XC -1 ; WX 704 ; N Ydieresis ; B 15 0 777 930 ;
XC -1 ; WX 704 ; N Zcaron ; B -29 0 715 954 ;
XC -1 ; WX 667 ; N aacute ; B 15 -15 646 719 ;
XC -1 ; WX 667 ; N acircumflex ; B 15 -15 646 709 ;
XC -1 ; WX 667 ; N adieresis ; B 15 -15 646 685 ;
XC -1 ; WX 667 ; N agrave ; B 15 -15 646 719 ;
XC -1 ; WX 667 ; N aring ; B 15 -15 646 745 ;
XC -1 ; WX 667 ; N atilde ; B 15 -15 646 683 ;
XC -1 ; WX 606 ; N brokenbar ; B 262 0 343 737 ;
XC -1 ; WX 537 ; N ccedilla ; B 3 -220 487 477 ;
XC -1 ; WX 747 ; N copyright ; B 23 -15 723 737 ;
XC -1 ; WX 400 ; N degree ; B 70 405 370 705 ;
XC -1 ; WX 606 ; N divide ; B 41 0 545 505 ;
XC -1 ; WX 519 ; N eacute ; B -2 -15 478 719 ;
XC -1 ; WX 519 ; N ecircumflex ; B -2 -15 478 709 ;
XC -1 ; WX 519 ; N edieresis ; B -2 -15 495 685 ;
XC -1 ; WX 519 ; N egrave ; B -2 -15 478 719 ;
XC -1 ; WX 574 ; N eth ; B 10 -15 540 737 ;
XC -1 ; WX 389 ; N iacute ; B 38 -15 399 719 ;
XC -1 ; WX 389 ; N icircumflex ; B 38 -15 383 709 ;
XC -1 ; WX 389 ; N idieresis ; B 38 -15 410 685 ;
XC -1 ; WX 389 ; N igrave ; B 38 -15 353 719 ;
XC -1 ; WX 606 ; N logicalnot ; B 41 120 545 402 ;
XC -1 ; WX 606 ; N minus ; B 41 206 545 304 ;
XC -1 ; WX 685 ; N mu ; B -90 -205 639 477 ;
XC -1 ; WX 606 ; N multiply ; B 41 0 547 506 ;
XC -1 ; WX 685 ; N ntilde ; B 3 -15 642 683 ;
XC -1 ; WX 574 ; N oacute ; B 10 -15 540 719 ;
XC -1 ; WX 574 ; N ocircumflex ; B 10 -15 540 709 ;
XC -1 ; WX 574 ; N odieresis ; B 10 -15 540 685 ;
XC -1 ; WX 574 ; N ograve ; B 10 -15 540 719 ;
XC -1 ; WX 861 ; N onehalf ; B 21 -15 857 705 ;
XC -1 ; WX 861 ; N onequarter ; B 21 -15 826 705 ;
XC -1 ; WX 344 ; N onesuperior ; B 21 282 323 705 ;
XC -1 ; WX 574 ; N otilde ; B 10 -15 540 683 ;
XC -1 ; WX 606 ; N plusminus ; B 41 0 545 505 ;
XC -1 ; WX 747 ; N registered ; B 23 -15 723 737 ;
XC -1 ; WX 481 ; N scaron ; B 2 -15 477 709 ;
XC -1 ; WX 648 ; N thorn ; B -118 -205 590 650 ;
XC -1 ; WX 861 ; N threequarters ; B -4 -15 826 705 ;
XC -1 ; WX 344 ; N threesuperior ; B -4 273 348 705 ;
XC -1 ; WX 950 ; N trademark ; B 42 318 982 722 ;
XC -1 ; WX 344 ; N twosuperior ; B -16 282 360 705 ;
XC -1 ; WX 685 ; N uacute ; B 38 -15 639 719 ;
XC -1 ; WX 685 ; N ucircumflex ; B 38 -15 639 709 ;
XC -1 ; WX 685 ; N udieresis ; B 38 -15 639 685 ;
XC -1 ; WX 685 ; N ugrave ; B 38 -15 639 719 ;
XC -1 ; WX 519 ; N yacute ; B -66 -205 492 719 ;
XC -1 ; WX 519 ; N ydieresis ; B -66 -205 492 685 ;
XC -1 ; WX 519 ; N zcaron ; B -18 -15 496 709 ;
XEndCharMetrics
XStartKernData
XStartKernPairs 102
X
XKPX A y -50
XKPX A w -20
XKPX A v -20
XKPX A space -18
XKPX A quoteright -74
XKPX A Y -74
XKPX A W -92
XKPX A V -111
XKPX A T -74
X
XKPX F period -129
XKPX F f -18
XKPX F comma -129
XKPX F A -74
X
XKPX L y -55
XKPX L space -18
XKPX L quoteright -55
XKPX L Y -55
XKPX L W -55
XKPX L V -74
XKPX L T -55
X
XKPX P space -18
XKPX P period -129
XKPX P comma -129
XKPX P A -92
X
XKPX R y -50
XKPX R Y -20
XKPX R W -20
XKPX R V -20
XKPX R T -20
X
XKPX T y -89
XKPX T w -89
XKPX T u -89
XKPX T semicolon -72
XKPX T s -89
XKPX T r -89
XKPX T period -111
XKPX T o -109
XKPX T i -71
XKPX T hyphen -129
XKPX T e -109
XKPX T comma -111
XKPX T colon -62
XKPX T c -89
XKPX T a -74
XKPX T A -50
X
XKPX V y -89
XKPX V u -89
XKPX V semicolon -74
XKPX V r -109
XKPX V period -111
XKPX V o -129
XKPX V i -72
XKPX V hyphen -74
XKPX V e -129
XKPX V comma -111
XKPX V colon -74
XKPX V a -129
XKPX V A -129
X
XKPX W y -74
XKPX W u -74
XKPX W semicolon -37
XKPX W r -74
XKPX W period -55
XKPX W o -74
XKPX W i -74
XKPX W hyphen -37
XKPX W e -74
XKPX W comma -55
XKPX W colon -37
XKPX W a -74
XKPX W A -89
X
XKPX Y v -129
XKPX Y u -129
XKPX Y semicolon -111
XKPX Y q -129
XKPX Y period -129
XKPX Y p -129
XKPX Y o -129
XKPX Y i -90
XKPX Y hyphen -129
XKPX Y e -129
XKPX Y comma -129
XKPX Y colon -111
XKPX Y a -129
XKPX Y A -111
X
XKPX f quoteright 74
X
XKPX one one -74
X
XKPX quoteleft quoteleft -18
X
XKPX quoteright t -37
XKPX quoteright space -55
XKPX quoteright s -37
XKPX quoteright quoteright -18
X
XKPX r quoteright 55
XKPX r period -129
XKPX r hyphen 0
XKPX r comma -129
X
XKPX v period -37
XKPX v comma -37
X
XKPX w period -37
XKPX w comma -37
X
XKPX y period -55
XKPX y comma -55
XEndKernPairs
XEndKernData
XStartComposites 58
XCC Zcaron 2 ; PCC Z 0 0 ; PCC caron 205 245 ;
XCC zcaron 2 ; PCC z 0 0 ; PCC caron 93 0 ;
XCC Scaron 2 ; PCC S 0 0 ; PCC caron 196 245 ;
XCC scaron 2 ; PCC s 0 0 ; PCC caron 74 0 ;
XCC Ccedilla 2 ; PCC C 0 0 ; PCC cedilla 293 0 ;
XCC ccedilla 2 ; PCC c 0 0 ; PCC cedilla 142 0 ;
XCC Yacute 2 ; PCC Y 0 0 ; PCC acute 185 245 ;
XCC yacute 2 ; PCC y 0 0 ; PCC acute 93 0 ;
XCC Ydieresis 2 ; PCC Y 0 0 ; PCC dieresis 215 245 ;
XCC ydieresis 2 ; PCC y 0 0 ; PCC dieresis 83 0 ;
XCC Uacute 2 ; PCC U 0 0 ; PCC acute 290 245 ;
XCC Ucircumflex 2 ; PCC U 0 0 ; PCC circumflex 310 245 ;
XCC Udieresis 2 ; PCC U 0 0 ; PCC dieresis 320 245 ;
XCC Ugrave 2 ; PCC U 0 0 ; PCC grave 280 245 ;
XCC uacute 2 ; PCC u 0 0 ; PCC acute 176 0 ;
XCC ucircumflex 2 ; PCC u 0 0 ; PCC circumflex 176 0 ;
XCC udieresis 2 ; PCC u 0 0 ; PCC dieresis 166 0 ;
XCC ugrave 2 ; PCC u 0 0 ; PCC grave 176 0 ;
XCC Iacute 2 ; PCC I 0 0 ; PCC acute 75 245 ;
XCC Icircumflex 2 ; PCC I 0 0 ; PCC circumflex 95 245 ;
XCC Idieresis 2 ; PCC I 0 0 ; PCC dieresis 105 245 ;
XCC Igrave 2 ; PCC I 0 0 ; PCC grave 85 245 ;
XCC iacute 2 ; PCC dotlessi 0 0 ; PCC acute 28 0 ;
XCC icircumflex 2 ; PCC dotlessi 0 0 ; PCC circumflex 18 0 ;
XCC idieresis 2 ; PCC dotlessi 0 0 ; PCC dieresis 18 0 ;
XCC igrave 2 ; PCC dotlessi 0 0 ; PCC grave 28 0 ;
XCC Eacute 2 ; PCC E 0 0 ; PCC acute 234 245 ;
XCC Ecircumflex 2 ; PCC E 0 0 ; PCC circumflex 244 245 ;
XCC Edieresis 2 ; PCC E 0 0 ; PCC dieresis 244 245 ;
XCC Egrave 2 ; PCC E 0 0 ; PCC grave 234 245 ;
XCC eacute 2 ; PCC e 0 0 ; PCC acute 93 0 ;
XCC ecircumflex 2 ; PCC e 0 0 ; PCC circumflex 103 0 ;
XCC edieresis 2 ; PCC e 0 0 ; PCC dieresis 103 0 ;
XCC egrave 2 ; PCC e 0 0 ; PCC grave 103 0 ;
XCC Aacute 2 ; PCC A 0 0 ; PCC acute 204 245 ;
XCC Acircumflex 2 ; PCC A 0 0 ; PCC circumflex 244 245 ;
XCC Adieresis 2 ; PCC A 0 0 ; PCC dieresis 224 245 ;
XCC Agrave 2 ; PCC A 0 0 ; PCC grave 234 245 ;
XCC aacute 2 ; PCC a 0 0 ; PCC acute 167 0 ;
XCC acircumflex 2 ; PCC a 0 0 ; PCC circumflex 167 0 ;
XCC adieresis 2 ; PCC a 0 0 ; PCC dieresis 157 0 ;
XCC agrave 2 ; PCC a 0 0 ; PCC grave 167 0 ;
XCC Oacute 2 ; PCC O 0 0 ; PCC acute 270 245 ;
XCC Ocircumflex 2 ; PCC O 0 0 ; PCC circumflex 290 245 ;
XCC Odieresis 2 ; PCC O 0 0 ; PCC dieresis 300 245 ;
XCC Ograve 2 ; PCC O 0 0 ; PCC grave 280 245 ;
XCC oacute 2 ; PCC o 0 0 ; PCC acute 120 0 ;
XCC ocircumflex 2 ; PCC o 0 0 ; PCC circumflex 110 0 ;
XCC odieresis 2 ; PCC o 0 0 ; PCC dieresis 110 0 ;
XCC ograve 2 ; PCC o 0 0 ; PCC grave 120 0 ;
XCC Atilde 2 ; PCC A 0 0 ; PCC tilde 244 245 ;
XCC atilde 2 ; PCC a 0 0 ; PCC tilde 167 0 ;
XCC Ntilde 2 ; PCC N 0 0 ; PCC tilde 299 245 ;
XCC ntilde 2 ; PCC n 0 0 ; PCC tilde 156 0 ;
XCC Otilde 2 ; PCC O 0 0 ; PCC tilde 270 245 ;
XCC otilde 2 ; PCC o 0 0 ; PCC tilde 120 0 ;
XCC Aring 2 ; PCC A 0 0 ; PCC ring 124 245 ;
XCC aring 2 ; PCC a 0 0 ; PCC ring 57 0 ;
XEndComposites
XEndFontMetrics
END_OF_FILE
  if test 15704 -ne `wc -c <'font/NewCenSchBolIta.AFM'`; then
    echo shar: \"'font/NewCenSchBolIta.AFM'\" unpacked with wrong size!
  fi
  # end of 'font/NewCenSchBolIta.AFM'
fi
if test -f 'include/fig' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/fig'\"
else
  echo shar: Extracting \"'include/fig'\" \(16471 characters\)
  sed "s/^X//" >'include/fig' <<'END_OF_FILE'
X
X###############################################################################
X#                                                                             #
X#  Lout @Fig package for drawing figures (Version 2.0)                        #
X#                                                                             #
X#  Version 1.0 by Jeffrey H. Kingston, October 1991.                          #
X#  Version 2.0 by Jeffrey H. Kingston, 22 December 1992.                      #
X#  Symbol names changed by JHK 5 March 1993 to avoid clashes with EPS files.  #
X#                                                                             #
X#  See "Fig - a Lout package for drawing figures" for user information.       #
X#                                                                             #
X###############################################################################
X
X@SysPrependGraphic { "fig_prepend" }
X
Xexport in cm pt em sp vs ft dg
X       "<<" "**" "++" "--" @Max @Min
X       @Distance @XDistance @YDistance @Angle
X       @Prev "::" @Label @BaseOf @MarkOf @ShowLabels
X       @Colour @Color @RGBColour @RGBColor @HSBColour @HSBColor
X       @Figure @Frame @Box @Square @Diamond @Polygon @Ellipse
X       @Circle @HLine @VLine @Line @HArrow @VArrow @Arrow @Arc
X
Xdef @Fig                  
X    named maxlabels  { 200     }
X    named linestyle  { solid   }
X    named linewidth  { 0.5 pt  }
X    named linecap    { round   }
X    named dashlength { 0.15 cm }
X    named paint      { nopaint }
X    named margin     { 0.4c    }
X    named arrow      { noarrow }
X    named headstyle  { open    }
X    named headwidth  { 0.05 cm }
X    named headlength { 0.15 cm }
X    body @Body
X@Begin
X
X    # Like @Graphic, but affects the graphics state of right parameter
X    def @InnerGraphic
X	left ps
X	right x
X    {
X	{ ps gsave // grestore } @Graphic x
X    }
X
X    def in precedence 39 left x { x "in" }
X    def cm precedence 39 left x { x "cm" }
X    def pt precedence 39 left x { x "pt" }
X    def em precedence 39 left x { x "em" }
X    def sp precedence 39 left x { x "sp" }
X    def vs precedence 39 left x { x "vs" }
X    def ft precedence 39 left x { x "ft" }
X    def dg precedence 39 left x { x "dg" }
X
X    def "<<"
X	precedence 38
X	left length
X	right angle
X    {
X	0 0 length angle "lfigatangle"
X    }
X
X    def "**"
X	precedence 37
X	left point
X	right length
X    {
X	point length "lfigpmul"
X    }
X
X    def "++"
X	precedence 36
X	associativity left
X	left x
X	right y
X    {
X	x y "lfigpadd"
X    }
X
X    def "--"
X	precedence 36
X	associativity left
X	left x
X	right y
X    {
X	y x "lfigpsub"
X    }
X
X    def @Max
X	precedence 36
X	left x
X	right y
X    {
X	x y "lfigpmax"
X    }
X
X    def @Min
X	precedence 36
X	left x
X	right y
X    {
X	x y "lfigpmin"
X    }
X
X    def @Distance
X	precedence 35
X	left x
X	right y
X    {
X	x y "lfigdistance"
X    }
X
X    def @XDistance
X	precedence 35
X	left x
X	right y
X    {
X	x y "lfigxdistance"
X    }
X
X    def @YDistance
X	precedence 35
X	left x
X	right y
X    {
X	x y "lfigydistance"
X    }
X
X    def @Angle
X	precedence 35
X	left x
X	right y
X    {
X	x y "lfigangle"
X    }
X
X    def @Prev
X    {
X	"lfigprevious"
X    }
X
X    def "::"
X	precedence 33
X	left name
X	right x
X    {
X	{ "currentdict end" maxlabels "dict begin begin"
X	  // "("name") lfigpromotelabels" } @Graphic x
X    }
X
X    def @Label
X	right name
X    {
X	"/"name "lfigpointdef"
X    }
X
X    def @MarkOf
X	precedence 32
X	left point
X	right x
X    {
X	{ point "translate" } @InnerGraphic
X	{
X	    /0io |0io @OneCol @OneRow x |0io /0io
X	}
X    }
X
X    def @BaseOf
X	precedence 32
X	left point
X	right x
X    {
X	{ point "translate" } @InnerGraphic
X	{
X	    /0io |0io @OneRow @OneCol {
X	    | @OneCol @OneRow x ^/
X	    } |0io /0io
X	}
X    }
X
X    def @ShowLabels
X    {
X	"lfigshowlabels" @Graphic
X    }
X
X    def @Colour
X	left col
X	right x
X    {
X	{
X	    col @Case
X	    {
X		black @Yield "0.00 0.0 0.0"
X		grey  @Yield "0.00 0.0 0.9"
X		white @Yield "0.00 0.0 1.0"
X		red   @Yield "0.00 1.0 1.0"
X		green @Yield "0.33 1.0 1.0"
X		blue  @Yield "0.66 1.0 1.0"
X	    } sethsbcolor
X	} @InnerGraphic x
X    }
X
X    def @Color
X	left col
X	right x
X    {
X	col @Colour x
X    }
X
X    def @RGBColour
X	left col
X	right x
X    {
X	{ col setrgbcolor } @InnerGraphic x
X    }
X
X    def @RGBColor
X	left col
X	right x
X    {
X	col @RGBColour x
X    }
X
X    def @HSBColour
X	left col
X	right x
X    {
X	{ col sethsbcolor } @InnerGraphic x
X    }
X
X    def @HSBColor
X	left col
X	right x
X    {
X	col @HSBColour x
X    }
X
X    def @Figure
X	named shape      {            }
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named arrow      { arrow      }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	right x
X    {
X	@HContract @VContract
X	{
X	    #fill the shape
X	    paint @Case
X	    {
X		nopaint @Yield {}
X
X		{ white light grey gray dark black } @Yield
X		{ "/lfig"paint "[" shape "] gsave lfigpaintpath grestore" }
X	    }
X
X	    # stroke the path and add any arrowheads
X	    linestyle @Case
X	    {
X		{ solid dashed cdashed dotted noline } @Yield
X		{
X		    linewidth "setlinewidth" "lfig"linecap "setlinecap"
X		    dashlength "/lfig"linestyle "[" shape "] lfigdopath"
X		    arrow @Case
X		    {
X			noarrow @Yield { pop pop }
X			{ forward back both } @Yield
X			{  dashlength "/lfig"linestyle "/"lfigblack
X			   headstyle @Case
X			   { { open halfopen closed } @Yield "lfig"headstyle }
X			   headlength headwidth "lfig"arrow
X			}
X		    }
X		}
X	    }
X	}
X	@Graphic
X	{
X	    ^/margin ^|margin @OneCol @OneRow x |margin
X	     /margin
X	}
X    }
X
X    def @Frame
X	right x
X    {
X	@Figure
X	    shape {xsize 0 @Label X 0 ysize @Label Y}
X	{ x }
X    }
X
X    def @Box
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	right x
X    {
X	@Figure
X	    shape {
X		# 0     0      @Label SW
X		# xsize 0      @Label SE
X		# xsize ysize  @Label NE
X		# 0     ysize  @Label NW
X		# SE ** 0.5    @Label S
X		# NW ** 0.5    @Label W
X		# W ++ SE      @Label E
X		# S ++ NW      @Label N
X		# NE ** 0.5    @Label CTR
X		# SW SE NE NW SW
X		lfigbox
X	    }
X	    linestyle  { linestyle }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @Square
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	right x
X    {
X	@Figure
X	    shape {
X		# {xsize ysize} ** 0.5                           @Label CTR
X		# CTR ++ {{xsize xsize} @Max {ysize ysize}}**0.5 @Label NE
X		# CTR ++ { {CTR @Distance NE} << 135 }           @Label NW
X		# CTR ++ { {CTR @Distance NE} << 225 }           @Label SW
X		# CTR ++ { {CTR @Distance NE} << 315 }           @Label SE
X		# SW ** 0.5 ++ SE ** 0.5                         @Label S
X		# NW ** 0.5 ++ NE ** 0.5                         @Label N
X		# SW ** 0.5 ++ NW ** 0.5                         @Label W
X		# SE ** 0.5 ++ NE ** 0.5                         @Label E
X		# SW SE NE NW SW
X		lfigsquare
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @Diamond
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	right x
X    {
X	@Figure
X	    shape {
X		# {xsize 0} ** 0.5  @Label S
X		# {0 ysize} ** 0.5  @Label W
X		# S ++ W            @Label CTR
X		# CTR ++ W          @Label N
X		# CTR ++ S          @Label E
X		# S E N W S
X		lfigdiamond
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @Polygon
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	named sides      { 3          }
X	named angle      { "dup 180 exch div" }
X	right x
X    {
X	@Figure
X	    shape      { sides angle lfigpolygon }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @Ellipse
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	right x
X    {
X	@Figure
X	    shape {
X		# {xsize 0} ** 0.5  @Label S
X		# {0 ysize} ** 0.5  @Label W
X		# S ++ W            @Label CTR
X		# CTR ++ W          @Label N
X		# CTR ++ S          @Label E
X		# CTR ++ {xsize 0} ** 0.3536 ++ {0 ysize} ** 0.3536  @Label NE
X		# CTR ++ {xsize 0} ** 0.3536 -- {0 ysize} ** 0.3536  @Label SE
X		# CTR -- {xsize 0} ** 0.3536 ++ {0 ysize} ** 0.3536  @Label NW
X		# CTR -- {xsize 0} ** 0.3536 -- {0 ysize} ** 0.3536  @Label SW
X		# S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X		lfigellipse
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @Circle
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { margin     }
X	right x
X    {
X	@Figure
X	    shape {
X		# {xsize ysize} **0.5                    @Label CTR
X		# CTR ++ {{xsize 0} @Max {ysize 0}}**0.5 @Label E
X		# CTR ++ { {CTR @Distance E} << 45  }    @Label NE
X		# CTR ++ { {CTR @Distance E} << 90  }    @Label N
X		# CTR ++ { {CTR @Distance E} << 135 }    @Label NW
X		# CTR ++ { {CTR @Distance E} << 180 }    @Label W
X		# CTR ++ { {CTR @Distance E} << 225 }    @Label SW
X		# CTR ++ { {CTR @Distance E} << 270 }    @Label S
X		# CTR ++ { {CTR @Distance E} << 315 }    @Label SE
X		# S [ CTR ] E [ CTR ] N [ CTR ] W [ CTR ] S
X		lfigcircle
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	x
X    }
X
X    def @HLine
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { arrow      }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		# 0     ymark @Prev @Label FROM
X		# xsize ymark @Prev @Label TO
X		lfighline
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @VLine
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { arrow      }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		# xmark ysize @Prev @Label FROM
X		# xmark 0     @Prev @Label TO
X		lfigvline
X	    }
X	    linestyle  { linestyle }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @HArrow
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { forward    }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		# 0     ymark @Prev @Label FROM
X		# xsize ymark @Prev @Label TO
X		lfighline
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @VArrow
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { forward    }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		# xmark ysize @Prev @Label FROM
X		# xmark 0     @Prev @Label TO
X		lfigvline
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @Line
X	named from       { 0 ysize    }
X	named to         { xsize 0    }
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { arrow      }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		from @Prev @Label FROM
X		to   @Prev @Label TO
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @Arrow
X	named from       { 0 ysize    }
X	named to         { xsize 0    }
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { forward    }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		from @Prev @Label FROM
X		to   @Prev @Label TO
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    def @Arc
X	named from       { 0 ysize    }
X	named to         { xsize 0    }
X	named ctr        { 0 0        }
X	named direction  { clockwise  }
X	named linestyle  { linestyle  }
X	named linewidth  { linewidth  }
X	named linecap    { linecap    }
X	named dashlength { dashlength }
X	named paint      { paint      }
X	named margin     { 0c         }
X	named arrow      { noarrow    }
X	named headstyle  { headstyle  }
X	named headwidth  { headwidth  }
X	named headlength { headlength }
X	right x
X    {
X	@Figure
X	    shape {
X		from @Label FROM
X		to   @Label TO
X		ctr  @Label CTR
X		FROM [ CTR
X		direction @Case { {clockwise anticlockwise} @Yield direction }
X		] TO
X	    }
X	    linestyle  { linestyle  }
X	    linewidth  { linewidth  }
X	    linecap    { linecap    }
X	    dashlength { dashlength }
X	    paint      { paint      }
X	    margin     { margin     }
X	    arrow      { arrow      }
X	    headstyle  { headstyle  }
X	    headwidth  { headwidth  }
X	    headlength { headlength }
X	x
X    }
X
X    { "grestore save gsave" maxlabels "dict begin lfigdict begin"
X      // "end end restore"
X    } @Graphic @Body
X
X@End @Fig                  
END_OF_FILE
  if test 16471 -ne `wc -c <'include/fig'`; then
    echo shar: \"'include/fig'\" unpacked with wrong size!
  fi
  # end of 'include/fig'
fi
if test -f 'z16.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z16.c'\"
else
  echo shar: Extracting \"'z16.c'\" \(16533 characters\)
  sed "s/^X//" >'z16.c' <<'END_OF_FILE'
X/*@z16.c:Size Adjustment:SetNeighbours(), CatAdjustSize()@********************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z16.c                                                      */
X/*  MODULE:       Size Adjustment                                            */
X/*  EXTERNS:      SetNeighbours(), AdjustSize()                              */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  SetNeighbours(link, ratm, pg, pdef, sg, sdef, side)                      */
X/*                                                                           */
X/*  This is a utility routine used by CatConstrained(), AdjustSize(),        */
X/*  BreakTable() and FlushGalley() for calculating size updates in objects.  */
X/*  Assuming that link is the link of a component of a VCAT etc., and that   */
X/*  ratm is TRUE if there is a marked component to the right of link, set    */
X/*                                                                           */
X/*     pg    to the gap separating link from the first definite object       */
X/*           to the left, or nil if none.  If pg != nil, set pdef to         */
X/*           the preceding definite object;  else pdef is undefined.         */
X/*                                                                           */
X/*     sg    to the gap separating link from the first definite object       */
X/*           to the right, or nil if none.  if sg != nil, set sdef to        */
X/*           the succeeding definite object;  else sdef is undefined.        */
X/*                                                                           */
X/*     side  to the side of the mark link is on; either BACK, ON or FWD.     */
X/*                                                                           */
X/*****************************************************************************/
X
XSetNeighbours(link, ratm, pg, pdef, sg, sdef, side)
XOBJECT link;  BOOLEAN ratm;
XOBJECT *pg, *pdef, *sg, *sdef;  int *side;
X{ OBJECT plink, slink;
X
X  /* find preceding definite; if it exists, set *pg */
X  *pg = nil;
X  for( plink = PrevDown(link);  type(plink) == LINK;  plink = PrevDown(plink) )
X  { Child(*pdef, plink);
X    if( type(*pdef) == SPLIT ? SplitIsDefinite(*pdef) : is_definite(type(*pdef)) )
X    { Child(*pg, PrevDown(link));
X      while( is_index(type(*pg)) )
X      {	link = PrevDown(link);
X	Child(*pg, PrevDown(link));
X      }
X      assert( type(*pg) == GAP_OBJ, "SetNeighbours: type(*pg)!" );
X      break;
X    }
X  }
X
X  /* find succeeding definite; if it exists, set *sg */
X  *sg = nil;
X  for( slink = NextDown(link);  type(slink) == LINK;  slink = NextDown(slink) )
X  { Child(*sdef, slink);
X    if( type(*sdef) == SPLIT ? SplitIsDefinite(*sdef) : is_definite(type(*sdef)) )
X    { Child(*sg, PrevDown(slink));
X      while( is_index(type(*sg)) )
X      {	slink = PrevDown(slink);
X	Child(*sg, PrevDown(slink));
X      }
X      assert( type(*sg) == GAP_OBJ, "SetNeighbours: type(*sg)!" );
X      break;
X    }
X  }
X
X  *side = ratm ? BACK : *pg == nil || mark(gap(*pg)) ? ON : FWD;
X  debug4(DSA,DD, "SetNeighbours: ratm == %s, pg %s nil, sg %s nil, side == %s",
X	bool(ratm), *pg == nil ? "==" : "!=", *sg == nil ? "==" : "!=", 
X	*side == BACK ? "BACK" : *side == ON ? "ON" : "FWD");
X} /* end SetNeighbours */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static CatAdjustSize(x, b, f, ratm, y, dim)                              */
X/*                                                                           */
X/*  Adjust the size of x to be *b, *f.  Object x is known to lie in add-set  */
X/*  y;  ratm is TRUE iff there is a mark to the right of x.  Return the      */
X/*  new size of y in *b, *f.                                                 */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic CatAdjustSize(x, b, f, ratm, y, dim)
XOBJECT x;  LENGTH *b, *f;  BOOLEAN ratm;  OBJECT y;  int dim;
X{ OBJECT link;
X  OBJECT pg, prec_def, sg, sd;
X  LENGTH beffect, feffect, seffect;  int side;
X  int bb, ff;
X
X  debug6(DSA, D, "CatAdjustSize(%s x, %s, %s, %s, %s y, %s)", Image(type(x)),
X    EchoLength(*b), EchoLength(*f), bool(ratm), Image(type(y)), dimen(dim));
X  debug2(DSA,DD, "x(%s,%s) =", EchoLength(back(x,dim)), EchoLength(fwd(x,dim)));
X  ifdebug(DSA, DD, DebugObject(x));
X  debug2(DSA,DD, "y(%s,%s) =", EchoLength(back(y,dim)), EchoLength(fwd(y,dim)));
X  ifdebug(DSA, DD, DebugObject(y));
X
X  /* DO_ADJUST ACAT is a special case because adjustment affects its size */
X  if( dim==COL && type(y)==ACAT && display_style(save_style(y)) == DO_ADJUST )
X  { back(x, dim) = *b;  fwd(x, dim) = *f;
X    *b = back(y, dim);  *f = fwd(y, dim);
X    debug2(DSA, D, "CatAdjustSize ACAT %s,%s", EchoLength(*b), EchoLength(*f));
X    return;
X  }
X
X  link = UpDim(x, dim);
X  SetNeighbours(link, ratm, &pg, &prec_def, &sg, &sd, &side);
X  { ifdebug(DSA, D,
X    if( pg != nil && mode(gap(pg)) == NO_MODE )
X    { debug1(DSA, D, "NO_MODE gap pg, is_indefinite(x) == %s, y =",
X	bool(is_indefinite(type(x))) );
X      ifdebug(DSA, D, DebugObject(y));
X    }
X    if( sg != nil && mode(gap(sg)) == NO_MODE )
X    { debug1(DSA, D, "NO_MODE gap sg, is_indefinite(x) == %s, y =",
X	bool(is_indefinite(type(x))) );
X      ifdebug(DSA, D, DebugObject(y));
X    }
X  ); }
X  if( is_indefinite(type(x)) )
X  {
X    beffect = pg == nil ? *b :
X      MinGap(fwd(prec_def, dim), *b, *f, &gap(pg));
X
X    feffect = sg == nil ? *f :
X      MinGap(*f, back(sd, dim), fwd(sd, dim), &gap(sg));
X
X    seffect = pg == nil ? sg == nil ? 0 : back(sd, dim) :
X      sg == nil ? fwd(prec_def, dim) :
X      MinGap(fwd(prec_def, dim), back(sd,dim), fwd(sd,dim), &gap(sg));
X  }
X  else /* !is_indefinite(type(x)) */
X  {
X    beffect = pg == nil ?  *b - back(x, dim) :
X      MinGap(fwd(prec_def, dim), *b,           *f,          &gap(pg)) -
X      MinGap(fwd(prec_def, dim), back(x, dim), fwd(x, dim), &gap(pg));
X
X    feffect = sg == nil ? *f - fwd(x, dim) :
X      MinGap(*f,          back(sd, dim), fwd(sd, dim), &gap(sg)) -
X      MinGap(fwd(x, dim), back(sd, dim), fwd(sd, dim), &gap(sg));
X	
X    seffect = 0;
X  }
X
X  back(x, dim) = *b;  fwd(x, dim) = *f;
X  switch( side )
X  {
X    case BACK:	bb = back(y, dim) + beffect + feffect - seffect;
X		ff = fwd(y, dim);
X		break;
X
X    case ON:	bb = back(y, dim) + beffect - seffect;
X		ff = fwd(y, dim) + feffect;
X		break;
X
X    case FWD:	bb = back(y, dim);
X		ff = fwd(y, dim) + beffect + feffect - seffect;
X		break;
X  }
X  if( bb > MAX_LEN || ff > MAX_LEN )
X  { debug2(DSA, D, "bb = %s, ff = %s, y =", EchoLength(bb), EchoLength(ff));
X    ifdebug(DSA, D, DebugObject(y));
X    debug0(DSA, D, "x was");
X    ifdebug(DSA, D, DebugObject(x));
X    Error(FATAL,&fpos(y),"maximum size (%s) exceeded", EchoLength(MAX_LEN));
X  }
X  *b = bb;  *f = ff;
X  debug2(DSA, D, "CatAdjustSize returning %s,%s", EchoLength(*b), EchoLength(*f));
X} /* end CatAdjustSize */
X
X
X/*@::AdjustSize()@************************************************************/
X/*                                                                           */
X/*  AdjustSize(x, b, f, dim)                                                 */
X/*                                                                           */
X/*  Adjust the size of object x, in dimension dim, to be b, f.  If x is a    */
X/*  CLOSURE, the adjustment is from a CLOSURE to a definite object of size   */
X/*  b, f.                                                                    */
X/*                                                                           */
X/*****************************************************************************/
X
XAdjustSize(x, b, f, dim)
XOBJECT x;  LENGTH b, f;  int dim;
X{ OBJECT y, link, tlink, lp, rp, z, index;
X  BOOLEAN ratm;  LENGTH tb, tf, cby, cfy, rby, rfy;
X
X  debug6(DSA, D, "[ AdjustSize( %s(%s,%s), %s, %s, %s ), x =",
X	Image(type(x)), EchoLength(back(x, dim)), EchoLength(fwd(x, dim)),
X	EchoLength(b), EchoLength(f), dimen(dim));
X  ifdebug(DSA, DD, DebugObject(x) );
X
X  while( b != back(x, dim) || f != fwd(x, dim) || is_indefinite(type(x)) )
X  { assert( Up(x) != x, "AdjustSize: Up(x) == x!" );
X    assert( b >= 0, "AdjustSize: b < 0!" );
X    assert( f >= 0, "AdjustSize: f < 0!" );
X
X    /* these cases are unique because they have multiple parents */
X    if( type(x) == COL_THR || type(x) == ROW_THR )
X    { assert( (type(x)==COL_THR) == (dim==COL), "AdjustSize: COL_THR!" );
X      back(x, dim) = b;  fwd(x, dim) = f;
X      for( link = Up(x);  link != x;  link = NextUp(link) )
X      { Parent(y, link);
X	assert( type(y) == SPLIT, "AdjustSize: type(y) != SPLIT!") ;
X	AdjustSize(y, b, f, dim);
X      }
X      debug0(DSA, D, "[ AdjustSize (thread case) returning.");
X      return;
X    }
X
X    link = UpDim(x, dim);  ratm = FALSE;
X    for( tlink=NextDown(link);  type(tlink) == LINK;  tlink=NextDown(tlink) )
X    { Child(y, tlink);
X      if( type(y) == GAP_OBJ && mark(gap(y)) )  ratm = TRUE;
X    }
X    y = tlink;
X
X    debug5(DSA, DD, "  b = %s, f = %s, y = %s(%s,%s), x =",
X	EchoLength(b), EchoLength(f), Image(type(y)),
X	EchoLength(back(y, dim)), EchoLength(fwd(y, dim)));
X    ifdebug(DSA, DD, DebugObject(x) );
X
X    switch( type(y) )
X    {
X
X      case HEAD:
X      
X	if( dim == ROW )
X	{ back(x, dim) = b, fwd(x, dim) = f;
X	  debug0(DSA, D, "] AdjustSize ROW returning at HEAD");
X	  return;
X	}
X	else
X	{
X	  /* let lp and rp be the gaps delimiting the          */
X	  /* components joined to x                            */
X	  for( lp = PrevDown(link);  lp != y;  lp = PrevDown(lp) )
X	  { Child(z, lp);
X	    if( type(z) == GAP_OBJ && !join(gap(z)) )  break;
X	  }
X	  for( rp = NextDown(link);  rp != y;  rp = NextDown(rp) )
X	  { Child(z, rp);
X	    if( type(z) == GAP_OBJ && !join(gap(z)) )  break;
X	  }
X
X	  back(x, dim) = b;  fwd(x, dim) = f;
X	  if( lp == y && rp == y && !seen_nojoin(y) )
X	  {	
X	    /* if whole object is joined, do this */
X	    b = max(b, back(y, dim));
X	    f = max(f, fwd(y, dim));
X	  }
X	  else
X	  {
X	    /* if // or || is present, do this */
X	    tb = tf = 0;
X	    for( link = NextDown(lp);  link != rp;  link = NextDown(link) )
X	    { Child(z, link);
X	      if( type(z) == GAP_OBJ || is_index(type(z)) )  continue;
X	      tb = max(tb, back(z, dim));
X	      tf = max(tf, fwd(z, dim));
X	    }
X	    b = 0;  f = max(tb + tf, fwd(y, dim));
X	  }
X	  if( back(y, dim) == b && fwd(y, dim) == f )
X	  {
X	    debug0(DSA, D, "] AdjustSize (COL) returning at HEAD (no wider)");
X	    return;
X	  }
X	  debug3(DGF, D, "AdjustSize widening %s to %s,%s",
X		   SymName(actual(y)), EchoLength(b), EchoLength(f));
X	  back(y, dim) = b;  fwd(y, dim) = f;
X	  if( Up(y) == y )
X	  {
X	    debug0(DSA, D, "] AdjustSize ret. at HEAD (no parent)" );
X	    return;
X	  }
X	  Parent(index, Up(y));
X	  if( type(index) != RECEIVING )
X	  {
X	    debug1(DSA,D, "] AdjustSize ret. at HEAD (%s)", Image(type(index)));
X	    return;
X	  }
X	  assert( actual(index) != nil, "AdjustSize: actual(index) == nil!" );
X	  assert( type(actual(index)) == CLOSURE, "AdjustSize: index non-C!" );
X	  if( actual(actual(index)) != GalleySym )
X	  {
X	    debug0(DSA, D, "] AdjustSize ret. at HEAD (not @Galley, so root)" );
X	    return;
X	  }
X	  y = actual(index);
X	}
X	break;
X
X
X      case SPLIT:
X      case HCONTRACT:
X      case VCONTRACT:
X      case HEXPAND:
X      case VEXPAND:
X      case PADJUST:
X      case HADJUST:
X      case VADJUST:
X      case ONE_COL:
X      case ONE_ROW:
X      case GRAPHIC:
X
X	back(x, dim) = b;  fwd(x, dim) = f;
X	break;
X
X
X      case HSCALE:
X      case VSCALE:
X
X	back(x, dim) = b;  fwd(x, dim) = f;
X	if( (dim==COL) == (type(y)==HSCALE) )
X	{ debug0(DSA, D, "] AdjustSize returning at HSCALE or VSCALE");
X	  return;
X	}
X	break;
X
X
X      case SCALE:
X
X	back(x, dim) = b;  fwd(x, dim) = f;
X	if( dim == COL )
X	{ b *= bc(constraint(y)) / SF;
X	  f *= bc(constraint(y)) / SF;
X	}
X	else
X	{ b *= fc(constraint(y)) / SF;
X	  f *= fc(constraint(y)) / SF;
X	}
X	break;
X
X
X      case ROTATE:
X      
X	back(x, dim) = b;  fwd(x, dim) = f;
X	RotateSize(&cby, &cfy, &rby, &rfy, x, sparec(constraint(y)));
X	if( cby != back(y, COL) || cfy != fwd(y, COL) )
X	  AdjustSize(y, cby, cfy, COL);
X	if( rby != back(y, ROW) || rfy != fwd(y, ROW) )
X	  AdjustSize(y, rby, rfy, ROW);
X	debug1(DSA, D, "] AdjustSize returning at %s.", Image(type(y)));
X	return;
X
X
X      case WIDE:
X      case HIGH:
X      
X	if( (type(y) == WIDE) == (dim == COL) )
X	{ if( !FitsConstraint(b, f, constraint(y)) )
X	  { Error(WARN, &fpos(y), "size constraint %s,%s,%s broken by %s,%s",
X	      EchoLength(bc(constraint(y))), EchoLength(bfc(constraint(y))),
X	      EchoLength(fc(constraint(y))), EchoLength(b), EchoLength(f));
X	    SetConstraint(constraint(y), MAX_LEN, b+f, MAX_LEN);
X	  }
X	  back(x, dim) = b;  fwd(x, dim) = f;
X	  EnlargeToConstraint(&b, &f, &constraint(y));
X	}
X	else
X	{ back(x, dim) = b;
X	  fwd(x, dim) = f;
X	}
X	break;
X
X
X      case COL_THR:
X      case ROW_THR:
X
X	assert( (type(y)==COL_THR) == (dim==COL), "AdjustSize: COL_THR!" );
X	back(x, dim) = b;  fwd(x, dim) = f;
X	b = max(b, back(y, dim));
X	f = max(f, fwd(y, dim));
X	break;
X
X
X      case VCAT:
X      case HCAT:
X      case ACAT:
X
X	if( (type(y) == VCAT) == (dim == ROW) )
X	  CatAdjustSize(x, &b, &f, ratm, y, dim);
X	else
X	{
X	  /* let lp and rp be the gaps bracketing the components joined to x */
X	  for( lp = PrevDown(link);  lp != y;  lp = PrevDown(lp) )
X	  { Child(z, lp);
X	    if( type(z) == GAP_OBJ && !join(gap(z)) )  break;
X	  }
X	  for( rp = NextDown(link);  rp != y;  rp = NextDown(rp) )
X	  { Child(z, rp);
X	    if( type(z) == GAP_OBJ && !join(gap(z)) )  break;
X	  }
X
X	  back(x, dim) = b;  fwd(x, dim) = f;
X	  if( lp == y && rp == y )
X	  {
X	    /* if whole object is joined, do this */
X	    b = max(b, back(y, dim));
X	    f = max(f, fwd(y, dim));
X	  }
X	  else
X	  { /* if // or || is present, do this */
X	    tb = tf = 0;
X	    for( link = NextDown(lp); link != rp;  link = NextDown(link) )
X	    { Child(z, link);
X	      if( type(z) == GAP_OBJ || is_index(type(z)) )  continue;
X	      tb = max(tb, back(z, dim));
X	      tf = max(tf, fwd(z, dim));
X	    }
X	    b = 0;  f = max(tb + tf, fwd(y, dim));
X	  }
X	}
X	break;
X
X
X      case WORD:
X      case QWORD:
X      case CLOSURE:
X      case NULL_CLOS:
X      case CROSS:
X      default:
X      
X	Error(INTERN, &fpos(y), "AdjustSize: %s", Image(type(y)));
X	break;
X
X    } /* end switch */
X    x = y;
X  } /* end while */
X  debug0(DSA, D, "] AdjustSize returning.");
X} /* end AdjustSize */
END_OF_FILE
  if test 16533 -ne `wc -c <'z16.c'`; then
    echo shar: \"'z16.c'\" unpacked with wrong size!
  fi
  # end of 'z16.c'
fi
echo shar: End of archive 16 \(of 35\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
