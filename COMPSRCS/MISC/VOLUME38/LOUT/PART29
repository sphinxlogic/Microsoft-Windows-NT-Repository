Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i097:  lout - Lout document formatting system, v2.05, Part29/35
Message-ID: <1993Aug10.132231.18861@sparky.sterling.com>
X-Md4-Signature: e81424ff486e33443f0e43cad93dd8e0
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 13:22:31 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 97
Archive-name: lout/part29
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  doc/tr.begin/s14 doc/tr.impl/s5.1 doc/tr.lout/ch1.02
#   doc/tr.lout/setup font/ZapfDin.AFM z07.c z11.c z30.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:32 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 29 (of 35)."'
if test -f 'doc/tr.begin/s14' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s14'\"
else
  echo shar: Extracting \"'doc/tr.begin/s14'\" \(9025 characters\)
  sed "s/^X//" >'doc/tr.begin/s14' <<'END_OF_FILE'
X@Section
X   @Tag { booklayout }
X   @Title { Books }
X@Begin
X@PP
XThe DocumentLayout package may also be used to produce books.  Type
X@Code "-ibook" in the Unix command instead of {@Code "-idoc"} to use the
Xpackage in this way.
X@PP
XA book begins with a @Code "@Book" symbol:
X@ID @Code {
X"@Book"
X"    @Title {}"
X"    @Author {}"
X"    @Edition {}"
X"    @Publisher {}"
X"    @InitialFont { Times Roman 12p }"
X"    @InitialBreak { adjust 1.2fx }"
X"    @Hyphenate { Yes }"
X"//"
X}
XThe first four options are printed on the title page, the first three
Xusing {@Code "clines @Break"} (see page {@PageOf clines}).  There are no
X{@Code "@Columns"}, {@Code "@PageNumbers"}, or {@Code "@FirstPageNumber"}
Xoptions.  The last three options are as for @Code "@Document" and
X{@Code "@Report"}.  Disaster will ensue if the @Code "//" is omitted.
X@PP
XNext comes an optional preface:
X@ID @Code {
X"@Preface"
X"    @Tag { preface }"
X"    @Title { About this book }"
X"@Begin"
X"@PP"
X"..."
X"@End @Preface"
X}
XSince the title of most prefaces is simply Preface, this is the default
Xvalue of the @Code "@Title" option.  After the preface, BookLayout will
Xproduce a table of contents listing the introduction, chapters,
Xsections, subsections, appendices, biblio&-graphy, and index as
Xappropriate.
X@PP
XThe pages up to this point will be numbered in lower case Roman
Xnumerals; subsequent pages will be numbered in Arabic starting from 1.
X@PP
XNext comes an optional introduction, in exactly the same style as the
Xpreface except that @Code "@Introduction" replaces @Code "@Preface" and
Xthe default title is Introduction.  After that comes a sequence of chapters
Xin the usual style:
X@ID @Code {
X"@Chapter"
X"    @Title { Principles }"
X"    @Tag { principles }"
X"@Begin"
X"@PP"
X"..."
X"@End @Chapter"
X}
XNo @Code "@BeginChapters" or @Code "@EndChapters" symbols are
Xneeded.  Within a chapter, there may be a sequence of sections,
Xeach introduced by @Code "@Section" in the usual way, all bracketed
Xby @Code "@BeginSections" and {@Code "@EndSections"}.  Within each
Xsection there may be subsections, each introduced by {@Code "@SubSection"},
Xand the sequence as a whole bracketed by @Code "@BeginSubSections" and
X{@Code "@EndSubSections"}.  The first subsection of the first section of the
Xfirst chapter will be numbered 1.1.1, and so on.  There are no sub-subsections.
X@PP
XFinally there is opportunity for a sequence of appendices, each
Xintroduced by @Code "@Appendix" in the usual way.  No
X@Code "@BeginAppendices" or @Code "@EndAppendices" symbols are
Xneeded.  The appendices are numbered A, B, C, etc., and there
Xare sub-appendices, obtained in the usual way.
X@PP
XEach symbol with a @Code "@Title" option also has a @Code "@RunningTitle"
Xoption.  The more important parts of the book (preface, introduction,
Xchapters, and appendices) have their @Code "@RunningTitle" printed at
Xthe top of each even-numbered page; if omitted, the @Code "@Title" option
Xis used instead.
X@PP
XWith Basser Lout, a long document is best broken into a sequence of files,
Xeach containing one section, from @Code "@Section" to @Code "@End @Section"
Xinclusive.  Other files are needed for the beginning of each chapter,
Xfrom @Code "@Chapter" to {@Code "@BeginSections"}, and for the end of
Xeach chapter, that is the final @Code "@EndSections" and
X{@Code "@End @Chapter"}.  On the Unix operating system a good scheme for
Xnaming these files is
X@ID lines @Break {
X@Code ch0.00     @Code "@Book" ... @Code "//"
X@Code ch0.01     Preface
X@Code ch0.02     Introduction
X@Code ch1.00     Beginning of Chapter 1
X@Code ch1.01     Section 1.1
X@Code ch1.02     Section 1.2
X. . .
X@Code ch1.99     End of Chapter 1
X@Code ch2.00     Beginning of Chapter 2
X@Code ch2.01     Section 2.1
X@Code ch2.02     Section 2.2
X. . .
X@Code ch2.99     End of Chapter 2
X}
Xand so on.  Then the Unix command
X@ID @Code "lout -ibook ch0.00 ch3.??"
Xwill format Chapter 3 only; and
X@ID @Code "lout -ibook ch?.??"
Xwill format the entire book.  The whole book must be formatted by one
Xcommand to get the page numbers right, but there is no need to do
Xthis until everything is perfect.
X@PP
XThe symbols described in Sections 1--7 above are all available as
Xusual.  The numbering of figures and tables includes a chapter or
Xappendix number:  the first figure of Appendix A will be numbered A.1,
Xand so on.  Figures and tables within the preface and introduction are
Xnumbered 1, 2, 3, etc.  When figures and tables appear near the end of
Xa chapter, the following page on which they appear may also be the first
Xpage of the next chapter, which looks very poor.  The solution is to move
Xthe figure or table to an earlier point in the chapter.
X@PP
XFigures and tables work in a slightly different way to previously, owing
Xto the need to attach a chapter or appendix number to each one.  The
Xfirst figure of each chapter or appendix must be preceded by
X{@Code "@BeginFigures"}, and the last figure of each chapter or appendix
Xmust be followed by {@Code "@EndFigures"}.  These symbols must also bracket
Xfigures in the preface and introduction.  The symbols are not required
Xwhen there are no figures.  Similarly, {@Code "@BeginTables"} and
X{@Code "@EndTables"} must bracket tables.
X@PP
XCross referencing works as described in Section {@NumberOf cross};
X@Code "@Tag" options may be given to the preface, introduction,
Xchapters, sections, subsections, appendices, and sub-appendices.
X@PP
XReferences work as described in Section {@NumberOf refs}, except
Xthat @Code "@ReferenceSection" is added automatically as needed.  A variant of
Xthe @Code "@Ref" symbol called @Code "@ChapRef" is provided, which
Xcauses the reference to appear at the end of the current preface,
Xintroduction, chapter, or appendix, rather than at the end of the book.
X@PP
XAlso available are symbols for making an index.  To
Xadd an entry to the index, place
X@ID @Code "packages @Index { Packages }"
Xfor example at the relevant point.  The result will be something like
X@ID { Packages, 27 }
Xappearing in the index in the alphabetical position determined by the
Xleft parameter, which should be a juxtaposition of simple words composed,
Xby convention, of lower-case letters and periods only.
X@PP
XA variant called @Code "@SubIndex" provides a small indent, as is
Xconventional for sub-entries in indexes.  For example,
X@ID @Code {
X"package  @Index  { Packages }"
X"package.r @SubIndex {ReportLayout}"
X"package.b @SubIndex {BookLayout}"
X}
Xscattered through a document will produce something like
X@ID lines @Break {
XPackages, 27
X   BookLayout, 45
X   ReportLayout, 40
X}
XNote how the left parameters have been carefully chosen to produce the
Xcorrect ordering.  There is also a @Code "@SubSubIndex" symbol with a
Xdouble indent.
X@PP
XThese symbols attach one page number to each entry.  Although the best
Xauthorities recommend exactly this, many authors choose to have entries
Xlike
X@ID { Fourier Transform, 576, 583--593 }
Xdespite the inconvenience to their readers.  {@Code "@RawIndex"},
X{@Code "@RawSubIndex"}, and {@Code "@RawSubSubIndex"}
Xsymbols are provided which do not add page numbers to the entry, leaving
Xthis to the user.  For example, one systematic way to get page number
Xranges is to place
X@ID @Code {
X"packages @RawIndex {"
X"    Packages, {@PageOf packages}"
X"    -- {@PageOf packages.end}"
X"}"
X}
Xat the start of the range, and
X@ID @Code {
X"{@PageMark packages.end}"
X}
Xat the end of the range.  This works because all six index symbols
Xinclude a @Code "@PageMark" operation.  Incidentally, this means that
Xindex tags should be different from chapter and other tags.
X@PP
XAnother use for @Code "@RawIndex" is to get blank lines into the index
Xbetween the letters of the alphabet, by inserting phantom entries:
X@ID @Code {
X"b @RawIndex {}"
X"c @RawIndex {}"
X"..."
X"z @RawIndex {}"
X}
XIn fact there is a symbol called @Code "@IndexBlanks" which creates
Xexactly these 25 entries.  Unfortunately, these blanks will occasionally
Xappear at the top of a column, and if there are no entries beginning with
Xx, for example, there will be two blank lines between the w and y
Xentries.  The careful user can start off with @Code "@IndexBlanks" and
Xreplace it later by the appropriate subset.
X@FootNote {
XFor Lout to solve this problem automatically, it would need to be told
Xwhich letter each index entry belongs under, perhaps by symbols
X{@Code "@AIndex"}, {@Code "@BIndex"}, etc.  The author
Xfelt that this would have been too tedious.
X}
X@PP
XOwing to problems behind the scenes, the Index heading will be printed,
Xand an entry will be made in the table of contents, even if there are no
Xentries in the index.  To prevent this, you will need to change the
X@Code "@MakeIndex" option in the @Code book setup file to {@Code "No"},
Xusing the method described in the following section.
X@PP
XAlthough the page numbers in index entries will be kept up to date
Xautomatically as the document changes, as all cross references are, 
Xthe user is recommended to refrain from inserting index entries until
Xthe book is complete and an overall plan of the structure of the index
Xcan be made.
X@End @Section
END_OF_FILE
  if test 9025 -ne `wc -c <'doc/tr.begin/s14'`; then
    echo shar: \"'doc/tr.begin/s14'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s14'
fi
if test -f 'doc/tr.impl/s5.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s5.1'\"
else
  echo shar: Extracting \"'doc/tr.impl/s5.1'\" \(6118 characters\)
  sed "s/^X//" >'doc/tr.impl/s5.1' <<'END_OF_FILE'
X@SubSection
X    @Tag { galleys }
X    @Title { The galley abstraction }
X@Begin
X@PP
XLet us take the footnote as a representative example.  At some point in
Xthe document, we wish to write
X@ID @Code {
X"preceding text"
X"@FootNote { footnote text }"
X"following text"
X}
Xand we expect the formatter to remove the footnote from this context and
Xplace it at the bottom of the current page, possibly splitting some or
Xall of it onto a following page if space is insufficient.
X@PP
XAn object appears in the final document at the point it is invoked, but
Xthis basic property does not hold for footnotes:  the point of
Xinvocation and the point of appearance are different.  In some way, the
Xfootnote is attached to the document at both points, introducing a cross
Xlinking (Section {@NumberOf genesis}) that cannot be described in purely
Xfunctional terms.
X@PP
XSince the interpretation of any object depends on an environment and
Xstyle inherited from the context, the first question must be whether
Xthe footnote inherits them through the invocation point or through
Xthe point(s) of appearance.
X@PP
XIf symbols are to be interpreted statically as heretofore, then environments
Xmust be inherited through the invocation point alone.  Dynamic inheritance
Xthrough the point of appearance is enticing in some ways:  it might
Xreplace the body parameter, and it might help with automatic numbering,
Xsince the number of a footnote is known only at the point of appearance;
Xbut the implementation problems are severe, and static inheritance seems
Xmuch simpler and more comprehensible to the user.  Style, at least its
Xavailable width and height part, must of necessity be inherited through
Xthe point of appearance.  For consistency, the entire style should be
Xinherited in this way.  There is a suggestive analogy here with actual
Xparameters, which have a point of invocation from which they inherit an
Xenvironment, and a point of appearance within the body of the enclosing
Xdefinition, from which they inherit a style.  It may be possible to treat
Xa footnote as the actual parameter of some symbol, therefore, although
Xthe details seem very obscure.
X@PP
XBut the most profound consequence of having two types of attachment
Xpoint is that it leads to two distinctive tree structures.  Considering
Xinvocation points only leads to static trees like this one:
X@ID @I @Fig margin { 0.3c } { @Tree {
X@Node @Ellipse { body text }
X@LeftSub { @Node @Ellipse footnote }
X@RightSub {
X   @Node @Ellipse figure
X   @FirstSub { @Node @Ellipse footnote }
X}
X}}
Xwhich shows that the body text contains a footnote and a figure, the
Xlatter itself containing a footnote.  Considering points of appearance
Xonly gives a completely different, dynamic tree:
X@ID @I @Fig margin { 0.3c } { @Tree {
X@Node @Ellipse { sequence of pages }
X@FirstSub { @Node @Ellipse { body text } }
X@NextSub  { @Node @Ellipse { footnote  } }
X@NextSub  { @Node @Ellipse { figure    } }
X@NextSub  { @Node @Ellipse { footnote  } }
X}}
XThe tree can be deeper, for example with sections appearing within
Xchapters which appear within the body text, which appears within the
Xfinal sequence of pages.  Document formatting languages generally shirk
Xthe issues raised by this dual tree structure, by making the dynamic
Xtree built-in, by limiting one or both trees to two levels, and so on,
Xproviding a classic example of the impoverishing effect of failing to
Xpermit language features to attain their natural level of generality.
X@PP
XWe are thus led to propose a second abstraction for document formatting,
Xwhich we name the @I galley in recognition of its similarity to the
Xgalleys used in manual typesetting.  A galley consists of an object (such
Xas a footnote) together with a sequence of places where that object may
Xappear (such as the bottoms of the current and following pages).  Splitting
Xoccurs quite naturally when space at any place is insufficient to hold
Xthe entire object.
X@PP
XIn Lout, a footnote galley and its place of appearance are defined
Xas follows:
X@ID @Code {
X"def @FootPlace { @Galley }"
X""
X"def @FootNote into { @FootPlace&&following }"
X"    right x"
X"{ x }"
X}
XThe @Code "@FootPlace" symbol contains the special symbol {@Code "@Galley"},
Xindicating that it is a point of appearance for a galley.  By placing
Xinvocations of @Code "@FootPlace" at the bottoms of pages, as in Section
X{@NumberOf recursion}, we define the desired points of appearance for
Xfootnotes.  Symbols whose body contains @Code "@Galley" either directly
Xor indirectly are called receptive symbols, meaning receptive to
Xgalleys, and they are expanded only on demand.  The effect of the
X@Code "into" clause is to make each invocation of @Code "@FootNote" a
Xgalley whose object is the result of the invocation in the usual way,
Xand whose sequence of points of appearance is specified by the @Code "into"
Xclause; in this example, the sequence of all @Code "@FootPlace" symbols
Xfollowing the invocation point.
X@PP
XLout permits galleys to be invoked within other galleys to arbitrary
Xdepth, so that one may have footnotes within figures within the body
Xtext galley, for example, creating arbitrary static trees.  Receptive
Xsymbols like @Code "@FootPlace" may appear within any galley, creating
Xarbitrary dynamic trees as well.  The root of the dynamic tree, which
Xwould normally consist of the sequence of pages of the complete assembled
Xdocument, is considered to be a galley whose point of appearance is the 
Xoutput file.  Points of appearance may be @Code preceding or @Code following
Xthe invocation point; entries in tables of contents are the main users
Xof {@Code preceding}.
X@PP
XThe galley abstraction is adequate for all of the applications listed at
Xthe beginning of this section, except that there is no provision for
Xsorting index entries and references.  Sorting of galleys has been added
Xto Lout as a built-in feature, invoked by adding a special @Code "@Key"
Xparameter to the galleys, and using its value as the sort key.  The author
Xwas at a loss to find any other way, or any useful generalization of this
Xfeature.  Its implementation will be discussed in Section
X{@NumberOf cross.impl}.
X@End @SubSection
END_OF_FILE
  if test 6118 -ne `wc -c <'doc/tr.impl/s5.1'`; then
    echo shar: \"'doc/tr.impl/s5.1'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s5.1'
fi
if test -f 'doc/tr.lout/ch1.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch1.02'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch1.02'\" \(8755 characters\)
  sed "s/^X//" >'doc/tr.lout/ch1.02' <<'END_OF_FILE'
X@Section
X   @Title { Definitions }
X   @Tag { definitions }
X@Begin
X@PP
XThe features of Lout are very general.  They do not assume that documents
Xare composed of pages, nor that there are such things as margins and
Xfootnotes, for example.  @I Definitions
Xdefinitions. @Index { Definitions }
Xbridge the gap between Lout's general features and the
Xspecial features -- footnotes, equations, pages -- that particular
Xdocuments require.  They hold the instr&-uct&-ions for producing these
Xspecial features, conveniently packaged ready for use.
X@PP
XFor example, consider the challenge posed by `@TeX', which is the name of
Xone of Lout's most illustrious rivals [{@Ref knuth84}].  Lout solves it
Xeasily enough, like this:
X@ID @Code {
X"T{ /0.2fo E }X"
X}
Xbut to type this every time @TeX is mentioned would be tedious and
Xerror-prone.  So we place a definition at the beginning of the document:
X@ID @Code {
X"def  @TeX  {  T{ /0.2fo E }X  }"
X}
XNow @Code "@TeX" stands for the object following it between
Xbraces, and we may write
X@ID @Code {
Xconsider the challenge posed by "`@TeX'", ...
X}
Xas the author did earlier in this paragraph.
X@PP
XA @I symbol
Xsymbol. @Index Symbol
Xis a name, like {@Code "@TeX"}, which stands for
Xsomething other than itself.  The initial @Code "@" is not compulsory,
Xbut it does make the name stand out clearly.  A @I definition of a symbol
Xdeclares a name to be a symbol, and says what the symbol stands for.  The
X@I body of a definition
Xbody.of @Index { Body of a definition }
Xis the part following the name, between the braces.  To @I invoke
Xinvocation @Index { Invocation of a symbol }
Xa symbol is to make use of it.
X@PP
XAnother expression ripe for packaging in a definition is
X@ID @Code {
X"@OneRow {  |  -2p @Font n  ^/0.5fk  2  }"
X}
Xwhich produces @OneRow { | -2p @Font n ^/0.5sk 2 } as the reader
Xfamiliar with Chapter {@NumberOf details}
Xcan verify.  But this time we would like to be able to write
X@ID {
X@I object  @Code "@Super"  @I object
X}
Xso that @Code { a "@Super" 2 } would come out as {a @Super 2}, and so
Xon, for in this way the usefulness of the definition is greatly
Xincreased.  Here is how it is done:
X@ID @Code {
X"def @Super"
X"   left x"
X"   right y"
X"{ @OneRow {  |  -2p @Font y  ^/0.5fk  x  }"
X"}"
X}
XThis definition says that @Code "@Super" has two {@I parameters},
Xparameter @Index Parameter
X@Code x and {@Code y}.  When @Code "@Super" is invoked, all occurrences
Xof @Code x in the body will be replaced by the object just to the left
Xof {@Code "@Super"}, and all occurrences of @Code y will be replaced by
Xthe object just to the right.  So, for example, the expression
X@ID @Code {
X"2  @Super  { Slope @Font n }"
X}
Xis equal to
X@ID @Code {
X"@OneRow {  |  -2p @Font { Slope @Font n }  ^/0.5fk  2  }"
X}
Xand so comes out as {2 @Super {Slope @Font n}}.
X@PP
XLout permits definitions to invoke themselves, a peculiarly circular
Xthing to do which goes by the name of
Xrecursion @Index Recursion
X@I recursion.  Here is an example
Xof a recursive definition:
X@ID @Code {
X"def  @Leaders  {  ..   @Leaders  }"
X}
XThe usual rule is that the value of an invocation of a symbol is a copy of
Xthe body of the symbol's definition, so the value of @Code "@Leaders" must be
X@ID @Code {
X"..   @Leaders"
X}
XBut now this rule applies to this new invocation of {@Code "@Leaders"};
Xsubstituting its body gives
X@ID @Code {
X"..   ..   @Leaders"
X}
Xand so on forever.  In order to make this useful,
Xan invocation of a recursive symbol is replaced by its body only if
Xsufficient space is available.  So, for example,
X@ID @Code {
X"4i @Wide { Chapter 7  @Leaders   62 }"
X}
Xhas for its result the object
X@ID {
X4i @Wide { Chapter 7  @Leaders   62 }
X}
Xwith Lout checking before each replacement of @Code "@Leaders" by
X@OneCol @Code { ".."   "@Leaders" } that the total length afterwards,
Xincluding the other words, would not exceed four inches.
X@PP
XThe remaining issue is what happens when Lout decides that it is time to
Xstop.  The obvious thing to do is to replace the last invocation by an
Xempty object:
X@ID @Code {
X"..    ..    ..    ..    ..    ..    ..    ..    {}"
X}
XAs the example shows, this would leave a small trailing space, which in
Xpractice turns out to be a major headache.  Lout solves this problem
Xby replacing the last invocation with a different kind of empty object,
Xcalled @@Null, whose effect is to make an adjacent concatenation symbol
Xdisappear, preferably one preceding the @@Null.  Thus, when Lout
Xreplaces @Code "@Leaders" by @@Null in the expression
X@ID @Code {
X"..    ..    ..    ..    ..    ..    ..    ..    @Leaders"
X}
Xthe trailing space, which is really a horizontal concatenation symbol,
Xdisappears as well.  This is carefully taken into account when deciding
Xwhether there is room to replace @Code "@Leaders" by its body at each
Xstage.
X@PP
XThe remainder of this section is devoted to showing how definitions may
Xbe used to specify the @I {page layout}
Xpage.layout @RawIndex { Page layout }
Xpage.layout.basic @SubIndex { principles of }
Xof a document.  To begin with,
Xwe can define a page like this:
X@ID @Code {
X"def @Page"
X"{"
X"    //1i  ||1i"
X"    6i @Wide 9.5i @High"
X"    { @TextPlace  //1rt  @FootSect }"
X"    ||1i  //1i"
X"}"
X}
XNow @Code "@Page" is an eight by
Xeleven and a half inch object, with one inch margins, a place at the top for
Xtext, and a section at the bottom for footnotes (since @Code "//1rt" leaves
Xsufficient space to bottom-justify the following object).  It will be
Xconvenient for us to show the effect of invoking @Code "@Page" like this:
X@ID @Code
X{ { //0.5ix 8p @Font "@Page" &2m => } &2m
X@LittlePage { "@TextPlace" //1rt "@FootSect" }
X}
Xwith the invoked symbol appearing to the left of the arrow, and its body to
Xthe right.
X@PP
XThe definition of a vertical list of pages should come as no surprise:
X@ID @Code {
X"def @PageList"
X"{"
X"    @Page"
X"    //"
X"    @PageList"
X"}"
X}
XThis allows invocations like the following:
X@ID @Code @HExpand @HScale {
X{ //0.5ix 8p @Font "@PageList" }
X||1m { //0.5ix => } ||1m
X{        @LittlePage { "@TextPlace" //1rt "@FootSect" }
X  //0.2c 8p @Font "@PageList"
X}
X||1m { //0.5ix => } ||1m
X{        @LittlePage { "@TextPlace" //1rt "@FootSect" }
X  //     @LittlePage { "@TextPlace" //1rt "@FootSect" }
X  //0.2c 8p @Font "@PageList"
X}
X||1m { //0.5ix => } ||1m
X{        @LittlePage { "@TextPlace" //1rt "@FootSect" }
X  //     @LittlePage { "@TextPlace" //1rt "@FootSect" }
X}
X}
Xsetting  @Code "@PageList" to @Code @@Null on the last step.  An
Xarbitrary number of pages can be generated in this way.
X@PP
XA definition for @Code "@TextPlace" is beyond us at present, since
X@Code "@TextPlace" must be replaced by different parts of the text
Xof the document on different pages.  We can,
Xhowever, define @Code "@FootSect" to be a small space followed by a
Xhorizontal line followed by a list of places where footnotes are to go:
X@ID @Code {
X"def @FootList         "
X"{                     "
X"   @FootPlace         "
X"   //0.3v             "
X"   @FootList          "
X"}                     "
X"                      "
X"def @FootSect"
X"{                        "
X"   //0.3v 1i @Wide @HLine"
X"   //0.3v @FootList      "
X"}                        "
X}
Xassuming that @Code "@HLine" will produce a horizontal line of the
Xindicated width.  With this definition we can generate pages like this:
X@ID @Code {
X@LittlePage { "@TextPlace"
X               //1rt
X               "@FootSect"
X             }
X||2m { //0.5ix => } ||2m
X@LittlePage { "@TextPlace"
X               //1rt
X               @OneRow { 1c @Wide @HLine
X                         //0.1c
X                         "@FootList"
X                       }
X             }
X||2m { //0.5ix => } ||2m
X@LittlePage { "@TextPlace"
X               //1rt
X               @OneRow { 1c @Wide @HLine
X                         //0.1c
X                         "@FootPlace"
X                         //0.1c
X                         "@FootList"
X                       }
X             }
X}
Xand so on for arbitrarily many footnotes.
X@PP
XWe will see in the next section how invocations of @Code "@PageList",
X@Code "@FootSect" and @Code "@FootList" are replaced by their bodies only
Xwhen the need to insert text and footnotes obliges Lout to do so;
Xotherwise the invocations are replaced by @@Null.  In this way, the
Xright number of pages is made, the small line appears only on pages that
Xhave at least one footnote, and unnecessary concatenation symbols
Xdisappear.
X@PP
XThis approach to page layout is the most original contribution Lout has
Xmade to document formatting.  It is extraordinarily flexible.  Two-column
Xpages?  Use
X@ID @Code {
X"{2.8i @Wide @TextPlace}  ||0.4i  {2.8i @Wide @TextPlace}"
X}
Xinstead of {@Code "@TextPlace"}.  Footnotes in smaller type?  Use
X@Code { -2p "@Font" "@FootPlace" } instead of {@Code "@FootPlace"}.  And
Xon and on.
X@End @Section
END_OF_FILE
  if test 8755 -ne `wc -c <'doc/tr.lout/ch1.02'`; then
    echo shar: \"'doc/tr.lout/ch1.02'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch1.02'
fi
if test -f 'doc/tr.lout/setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/setup'\"
else
  echo shar: Extracting \"'doc/tr.lout/setup'\" \(8613 characters\)
  sed "s/^X//" >'doc/tr.lout/setup' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Lout setup file for producing the user manual.    #
X#                                                    #
X#  Jeffrey H. Kingston                               #
X#  20 June 1991                                      #
X#  22 December 1991                                  #
X#                                                    #
X######################################################
X
X@SysInclude { ft  }
X@SysInclude { dl  }
X@SysInclude { eq  }
X@SysInclude { fig }
X@SysInclude { tab }
X
X
X   def "->" { {Symbol Base} @Font "\256" } #174 decimal
X   def "=>" { {Symbol Base} @Font "\336" } #222 decimal
X   macro @JP	{ /0.5v  }
X
X   def @Code right x
X   { { Helvetica Base -1p } @Font lines @Break x }
X
X   macro @JL { //1vx }
X
X   ###################################################
X   #                                                 #
X   #  Lout keywords.                                 #
X   #                                                 #
X   ###################################################
X
X   def @@Begin             { @Code "@Begin"             }
X   def @@Break             { @Code "@Break"             }
X   def @@Case              { @Code "@Case"              }
X   def @@Database          { @Code "@Database"          }
X   def @@End               { @Code "@End"               }
X   def @@Font              { @Code "@Font"              }
X   def @@Char              { @Code "@Char"              }
X   def @@Galley            { @Code "@Galley"            }
X   def @@Graphic           { @Code "@Graphic"           }
X   def @@HAdjust           { @Code "@HAdjust"           }
X   def @@HContract         { @Code "@HContract"         }
X   def @@HExpand           { @Code "@HExpand"           }
X   def @@HScale            { @Code "@HScale"            }
X   def @@High              { @Code "@High"              }
X   def @@Include           { @Code "@Include"           }
X   def @@IncludeGraphic    { @Code "@IncludeGraphic"    }
X   def @@Key               { @Code "@Key"               }
X   def @@LClos             { @Code "@LClos"             }
X   def @@LEnv              { @Code "@LEnv"              }
X   def @@LInput            { @Code "@LInput"            }
X   def @@LVis              { @Code "@LVis"              }
X   def @@Moment            { @Code "@Moment"            }
X   def @@Next              { @Code "@Next"              }
X   def @@Null              { @Code "@Null"              }
X   def @@OneCol            { @Code "@OneCol"            }
X   def @@OneRow            { @Code "@OneRow"            }
X   def @@Open              { @Code "@Open"              }
X   def @@PAdjust           { @Code "@PAdjust"           }
X   def @@PrependGraphic    { @Code "@PrependGraphic"    }
X   def @@Rotate            { @Code "@Rotate"            }
X   def @@Scale             { @Code "@Scale"             }
X   def @@Space             { @Code "@Space"             }
X   def @@SysDatabase       { @Code "@SysDatabase"       }
X   def @@SysInclude        { @Code "@SysInclude"        }
X   def @@SysIncludeGraphic { @Code "@SysIncludeGraphic" }
X   def @@SysPrependGraphic { @Code "@SysPrependGraphic" }
X   def @@Tag               { @Code "@Tag"               }
X   def @@Tagged            { @Code "@Tagged"            }
X   def @@Use               { @Code "@Use"               }
X   def @@VAdjust           { @Code "@VAdjust"           }
X   def @@VContract         { @Code "@VContract"         }
X   def @@VExpand           { @Code "@VExpand"           }
X   def @@VScale            { @Code "@VScale"            }
X   def @@Yield             { @Code "@Yield"             }
X   def @@Wide              { @Code "@Wide"              }
X
X
X   ###################################################
X   #                                                 #
X   #  Miscellaneous, mostly graphical definitions.   #
X   #                                                 #
X   ###################################################
X
X   def @TeX { T{ /0.2fo E}X }
X
X   export sp sb
X   def @Equation
X      body x
X   @Begin
X
X      def sp left x right y { @OneRow { | "-2p" @Font y ^/0.5fk x } }
X      def sb left x right y { @OneRow { x ^/0.5fk | "-2p" @Font y } }
X
X      Slope @Font x
X
X   @End @Equation
X
X   def @Super
X      left x
X      right y
X   { @OneRow { | -2p @Font y ^/0.5fk x }
X   }
X
X   def @NineSquare
X      right x
X   {
X      def @Three { x |0.2i x |0.2i x }
X
X      @Three /0.2i @Three /0.2i @Three
X   }
X
X   def @Leaders
X   { ..   @Leaders
X   }
X
X   def @HLine
X   {
X	{ 0 0 moveto xsize 0 lineto stroke } @Graphic {}
X   }
X
X   def @VDashLine
X      right length
X   {
X      length @High {
X	{ 0 0 moveto 0 ysize lineto [ 3 pt ] 0 setdash stroke } @Graphic {}
X      }
X   }
X
X   def @LBox
X      right offset
X   {  @HContract @VContract
X      {
X        {  //0.2c
X           0.6c @High 1.2c @Wide
X           { 0 0 moveto xsize 0 lineto
X	     xsize ysize lineto 0 ysize lineto closepath
X	     gsave 0.9 setgray fill grestore stroke }
X           @Graphic {}
X        }
X        ||offset @VDashLine 1c
X      }
X   }
X
X   def @Arrow
X      right length
X   {  @OneCol @OneRow
X      {
X	   30d @Rotate {0.12c @Wide @HLine}
X	   //
X	   length @Wide @HLine
X	   //
X	   "-30d" @Rotate {0.12c @Wide @HLine}
X      }
X   }
X
X   def @DoubleArrow
X      right length
X   {  @OneCol @OneRow
X      { 
X         & 180d @Rotate @Arrow length
X         |0io @Arrow length
X      }
X   }
X
X   def @Put
X     left coord
X     right x
X   { @OneCol @OneRow
X     { coord / | @OneCol @OneRow x
X     }
X   }
X   
X   macro @At { //0io }
X
X
X   ###################################################
X   #                                                 #
X   #  Interpolated example documents.                #
X   #                                                 #
X   ###################################################
X
X   def @LittleEndRunPlace { @Galley }
X   def @LittleEndRun
X      force into { @LittleEndRunPlace&&preceding }
X   {}
X
X   def @LittleTextPlace { @Galley }
X   def @LittleText into { @LittleTextPlace&&preceding }
X      right x
X   { x
X   }
X
X   def @LittleFootPlace { @Galley }
X   def @LittleFootNote into { @LittleFootPlace&&following }
X      right x
X   { x
X   }
X
X   def @LittlePageColumn
X      right x
X   {
X        9px @Break 8p @Font
X        2.8c @Wide x
X   }
X
X   def @LittlePage
X      right x
X   {
X      @HContract @VContract {
X        { 0 0 moveto xsize 0 lineto xsize ysize lineto
X    	  0 ysize lineto closepath stroke } @Graphic
X        {  //0.3c ||0.3c
X           9px @Break 8p @Font
X           2.8c @Wide 3.8c @High x
X           ||0.3c //0.3c
X        }
X      }
X   }
X
X   def @LittleFootSect
X   {  1c @Wide @HLine
X      //0.3v @LittleFootPlace ||0.5c
X   }
X
X   def @LittlePageList
X     right @PageNum
X   {
X      @LittlePage { # |0.5rt @PageNum //0.8v
X		//0.3v @LittleTextPlace
X		//1rt @LittleFootSect
X	     }
X      //
X      @LittlePageList @Next @PageNum
X   }
X
X   def @LittleDocument
X   {  @LittlePage
X      {  @LittleTextPlace
X         //1rt @LittleFootSect
X      }
X      // @LittlePageList 2
X      // @LittleEndRunPlace
X   }
X		
X   def @ShowMarks
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @HContract @VContract @Fig
X      {   @Box margin { 0c } linewidth { linewidth } paint { paint }
X	  {   @Figure
X		 shape { -0.3 cm ymark
X			 {xsize ymark} ++ {0.3 cm 0}  []
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	      x
X	  }
X
X      }
X   }
X
X   def @ShowVMark
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @Fig
X      {   
X	 @Figure
X		 shape {
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	 x
X      }
X   }
X
X   def @Strange
X       named @Format right @Val { [@Val] }
X       right x
X   {   @Format x
X   }
X
X   def @Box right x
X   {
X     "0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath stroke"
X     @Graphic x
X   }
X
X   def @GreyBox right x
X   {
X     "0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath 0.8 setgray fill"
X     @Graphic x
X   }
X
X@Use { @DocumentLayout
X  @MakeIndex        { Yes                  }
X  @TableOfContents  { Yes                  }
X  @AppendixGap      { 1.10b                }
X  @BookTitleFormat  { {Bold 2.0f} @Font {//2.0f @Title //0.5f} }
X}
X
X@SysDatabase @Reference { loutrefs }
END_OF_FILE
  if test 8613 -ne `wc -c <'doc/tr.lout/setup'`; then
    echo shar: \"'doc/tr.lout/setup'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/setup'
fi
if test -f 'font/ZapfDin.AFM' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font/ZapfDin.AFM'\"
else
  echo shar: Extracting \"'font/ZapfDin.AFM'\" \(9316 characters\)
  sed "s/^X//" >'font/ZapfDin.AFM' <<'END_OF_FILE'
XStartFontMetrics 2.0
XComment Copyright (c) 1984 Adobe Systems Incorporated. 	All Rights Reserved.
XComment Creation Date:Tue Mar 3 15:22:45 PST 1987
XFontName ZapfDingbats
XEncodingScheme FontSpecific
XFullName ITC Zapf Dingbats
XFamilyName ITC Zapf Dingbats
XWeight Medium
XItalicAngle 0.0
XIsFixedPitch false
XUnderlinePosition -98
XUnderlineThickness 54
XVersion 001.001
XNotice ITC Zapf Dingbats is a registered trademark of International Typeface Corporation.
XFontBBox -1 -143 981 820
XStartCharMetrics 202
XC 32 ; WX 278 ; N space ; B 0 0 0 0 ;
XC 33 ; WX 974 ; N a1 ; B 35 72 939 621 ;
XC 34 ; WX 961 ; N a2 ; B 35 81 927 611 ;
XC 35 ; WX 974 ; N a202 ; B 35 72 939 621 ;
XC 36 ; WX 980 ; N a3 ; B 35 0 945 692 ;
XC 37 ; WX 719 ; N a4 ; B 34 139 685 566 ;
XC 38 ; WX 789 ; N a5 ; B 35 -14 755 705 ;
XC 39 ; WX 790 ; N a119 ; B 35 -14 755 705 ;
XC 40 ; WX 791 ; N a118 ; B 35 -14 761 705 ;
XC 41 ; WX 690 ; N a117 ; B 35 138 655 553 ;
XC 42 ; WX 960 ; N a11 ; B 35 123 925 568 ;
XC 43 ; WX 939 ; N a12 ; B 35 134 904 559 ;
XC 44 ; WX 549 ; N a13 ; B 29 -11 516 705 ;
XC 45 ; WX 855 ; N a14 ; B 34 59 820 632 ;
XC 46 ; WX 911 ; N a15 ; B 35 50 876 642 ;
XC 47 ; WX 933 ; N a16 ; B 35 139 899 550 ;
XC 48 ; WX 911 ; N a105 ; B 35 50 876 642 ;
XC 49 ; WX 945 ; N a17 ; B 35 139 909 553 ;
XC 50 ; WX 974 ; N a18 ; B 35 104 938 586 ;
XC 51 ; WX 755 ; N a19 ; B 34 -14 721 704 ;
XC 52 ; WX 846 ; N a20 ; B 36 -14 811 705 ;
XC 53 ; WX 762 ; N a21 ; B 35 0 727 692 ;
XC 54 ; WX 761 ; N a22 ; B 35 0 727 692 ;
XC 55 ; WX 571 ; N a23 ; B -1 -68 571 661 ;
XC 56 ; WX 677 ; N a24 ; B 36 -14 642 705 ;
XC 57 ; WX 763 ; N a25 ; B 35 0 728 692 ;
XC 58 ; WX 760 ; N a26 ; B 35 0 726 692 ;
XC 59 ; WX 759 ; N a27 ; B 35 0 725 692 ;
XC 60 ; WX 754 ; N a28 ; B 35 0 720 692 ;
XC 61 ; WX 494 ; N a6 ; B 35 0 460 692 ;
XC 62 ; WX 552 ; N a7 ; B 35 0 517 692 ;
XC 63 ; WX 537 ; N a8 ; B 35 0 503 692 ;
XC 64 ; WX 577 ; N a9 ; B 35 96 542 596 ;
XC 65 ; WX 692 ; N a10 ; B 35 -14 657 705 ;
XC 66 ; WX 786 ; N a29 ; B 35 -14 751 705 ;
XC 67 ; WX 788 ; N a30 ; B 35 -14 752 705 ;
XC 68 ; WX 788 ; N a31 ; B 35 -14 753 705 ;
XC 69 ; WX 790 ; N a32 ; B 35 -14 756 705 ;
XC 70 ; WX 793 ; N a33 ; B 35 -14 759 705 ;
XC 71 ; WX 794 ; N a34 ; B 35 -14 759 705 ;
XC 72 ; WX 816 ; N a35 ; B 35 -14 782 705 ;
XC 73 ; WX 823 ; N a36 ; B 35 -14 787 705 ;
XC 74 ; WX 789 ; N a37 ; B 35 -14 754 705 ;
XC 75 ; WX 841 ; N a38 ; B 35 -14 807 705 ;
XC 76 ; WX 823 ; N a39 ; B 35 -14 789 705 ;
XC 77 ; WX 833 ; N a40 ; B 35 -14 798 705 ;
XC 78 ; WX 816 ; N a41 ; B 35 -13 782 705 ;
XC 79 ; WX 831 ; N a42 ; B 35 -14 796 705 ;
XC 80 ; WX 923 ; N a43 ; B 35 -14 888 705 ;
XC 81 ; WX 744 ; N a44 ; B 35 0 710 692 ;
XC 82 ; WX 723 ; N a45 ; B 35 0 688 692 ;
XC 83 ; WX 749 ; N a46 ; B 35 0 714 692 ;
XC 84 ; WX 790 ; N a47 ; B 34 -14 756 705 ;
XC 85 ; WX 792 ; N a48 ; B 35 -14 758 705 ;
XC 86 ; WX 695 ; N a49 ; B 35 -14 661 706 ;
XC 87 ; WX 776 ; N a50 ; B 35 -6 741 699 ;
XC 88 ; WX 768 ; N a51 ; B 35 -7 734 699 ;
XC 89 ; WX 792 ; N a52 ; B 35 -14 757 705 ;
XC 90 ; WX 759 ; N a53 ; B 35 0 725 692 ;
XC 91 ; WX 707 ; N a54 ; B 35 -14 672 705 ;
XC 92 ; WX 708 ; N a55 ; B 35 -14 672 705 ;
XC 93 ; WX 682 ; N a56 ; B 35 -14 647 705 ;
XC 94 ; WX 701 ; N a57 ; B 35 -14 666 705 ;
XC 95 ; WX 826 ; N a58 ; B 35 -14 791 705 ;
XC 96 ; WX 815 ; N a59 ; B 35 -14 780 705 ;
XC 97 ; WX 789 ; N a60 ; B 35 -14 754 705 ;
XC 98 ; WX 789 ; N a61 ; B 35 -14 754 705 ;
XC 99 ; WX 707 ; N a62 ; B 34 -14 673 705 ;
XC 100 ; WX 687 ; N a63 ; B 36 0 651 692 ;
XC 101 ; WX 696 ; N a64 ; B 35 0 661 691 ;
XC 102 ; WX 689 ; N a65 ; B 35 0 655 692 ;
XC 103 ; WX 786 ; N a66 ; B 34 -14 751 705 ;
XC 104 ; WX 787 ; N a67 ; B 35 -14 752 705 ;
XC 105 ; WX 713 ; N a68 ; B 35 -14 678 705 ;
XC 106 ; WX 791 ; N a69 ; B 35 -14 756 705 ;
XC 107 ; WX 785 ; N a70 ; B 36 -14 751 705 ;
XC 108 ; WX 791 ; N a71 ; B 35 -14 757 705 ;
XC 109 ; WX 873 ; N a72 ; B 35 -14 838 705 ;
XC 110 ; WX 761 ; N a73 ; B 35 0 726 692 ;
XC 111 ; WX 762 ; N a74 ; B 35 0 727 692 ;
XC 112 ; WX 762 ; N a203 ; B 35 0 727 692 ;
XC 113 ; WX 759 ; N a75 ; B 35 0 725 692 ;
XC 114 ; WX 759 ; N a204 ; B 35 0 725 692 ;
XC 115 ; WX 892 ; N a76 ; B 35 0 858 705 ;
XC 116 ; WX 892 ; N a77 ; B 35 -14 858 692 ;
XC 117 ; WX 788 ; N a78 ; B 35 -14 754 705 ;
XC 118 ; WX 784 ; N a79 ; B 35 -14 749 705 ;
XC 119 ; WX 438 ; N a81 ; B 35 -14 403 705 ;
XC 120 ; WX 138 ; N a82 ; B 35 0 104 692 ;
XC 121 ; WX 277 ; N a83 ; B 35 0 242 692 ;
XC 122 ; WX 415 ; N a84 ; B 35 0 380 692 ;
XC 123 ; WX 392 ; N a97 ; B 35 263 357 705 ;
XC 124 ; WX 392 ; N a98 ; B 34 263 357 705 ;
XC 125 ; WX 668 ; N a99 ; B 35 263 633 705 ;
XC 126 ; WX 668 ; N a100 ; B 36 263 634 705 ;
XC 161 ; WX 732 ; N a101 ; B 35 -143 697 806 ;
XC 162 ; WX 544 ; N a102 ; B 56 -14 488 706 ;
XC 163 ; WX 544 ; N a103 ; B 34 -14 508 705 ;
XC 164 ; WX 910 ; N a104 ; B 35 40 875 651 ;
XC 165 ; WX 667 ; N a106 ; B 35 -14 633 705 ;
XC 166 ; WX 760 ; N a107 ; B 35 -14 726 705 ;
XC 167 ; WX 760 ; N a108 ; B 0 121 758 569 ;
XC 168 ; WX 776 ; N a112 ; B 35 0 741 705 ;
XC 169 ; WX 595 ; N a111 ; B 34 -14 560 705 ;
XC 170 ; WX 694 ; N a110 ; B 35 -14 659 705 ;
XC 171 ; WX 626 ; N a109 ; B 34 0 591 705 ;
XC 172 ; WX 788 ; N a120 ; B 35 -14 754 705 ;
XC 173 ; WX 788 ; N a121 ; B 35 -14 754 705 ;
XC 174 ; WX 788 ; N a122 ; B 35 -14 754 705 ;
XC 175 ; WX 788 ; N a123 ; B 35 -14 754 705 ;
XC 176 ; WX 788 ; N a124 ; B 35 -14 754 705 ;
XC 177 ; WX 788 ; N a125 ; B 35 -14 754 705 ;
XC 178 ; WX 788 ; N a126 ; B 35 -14 754 705 ;
XC 179 ; WX 788 ; N a127 ; B 35 -14 754 705 ;
XC 180 ; WX 788 ; N a128 ; B 35 -14 754 705 ;
XC 181 ; WX 788 ; N a129 ; B 35 -14 754 705 ;
XC 182 ; WX 788 ; N a130 ; B 35 -14 754 705 ;
XC 183 ; WX 788 ; N a131 ; B 35 -14 754 705 ;
XC 184 ; WX 788 ; N a132 ; B 35 -14 754 705 ;
XC 185 ; WX 788 ; N a133 ; B 35 -14 754 705 ;
XC 186 ; WX 788 ; N a134 ; B 35 -14 754 705 ;
XC 187 ; WX 788 ; N a135 ; B 35 -14 754 705 ;
XC 188 ; WX 788 ; N a136 ; B 35 -14 754 705 ;
XC 189 ; WX 788 ; N a137 ; B 35 -14 754 705 ;
XC 190 ; WX 788 ; N a138 ; B 35 -14 754 705 ;
XC 191 ; WX 788 ; N a139 ; B 35 -14 754 705 ;
XC 192 ; WX 788 ; N a140 ; B 35 -14 754 705 ;
XC 193 ; WX 788 ; N a141 ; B 35 -14 754 705 ;
XC 194 ; WX 788 ; N a142 ; B 35 -14 754 705 ;
XC 195 ; WX 788 ; N a143 ; B 35 -14 754 705 ;
XC 196 ; WX 788 ; N a144 ; B 35 -14 754 705 ;
XC 197 ; WX 788 ; N a145 ; B 35 -14 754 705 ;
XC 198 ; WX 788 ; N a146 ; B 35 -14 754 705 ;
XC 199 ; WX 788 ; N a147 ; B 35 -14 754 705 ;
XC 200 ; WX 788 ; N a148 ; B 35 -14 754 705 ;
XC 201 ; WX 788 ; N a149 ; B 35 -14 754 705 ;
XC 202 ; WX 788 ; N a150 ; B 35 -14 754 705 ;
XC 203 ; WX 788 ; N a151 ; B 35 -14 754 705 ;
XC 204 ; WX 788 ; N a152 ; B 35 -14 754 705 ;
XC 205 ; WX 788 ; N a153 ; B 35 -14 754 705 ;
XC 206 ; WX 788 ; N a154 ; B 35 -14 754 705 ;
XC 207 ; WX 788 ; N a155 ; B 35 -14 754 705 ;
XC 208 ; WX 788 ; N a156 ; B 35 -14 754 705 ;
XC 209 ; WX 788 ; N a157 ; B 35 -14 754 705 ;
XC 210 ; WX 788 ; N a158 ; B 35 -14 754 705 ;
XC 211 ; WX 788 ; N a159 ; B 35 -14 754 705 ;
XC 212 ; WX 894 ; N a160 ; B 35 58 860 634 ;
XC 213 ; WX 838 ; N a161 ; B 35 153 803 539 ;
XC 214 ; WX 1016 ; N a163 ; B 34 151 981 541 ;
XC 215 ; WX 458 ; N a164 ; B 35 -127 422 820 ;
XC 216 ; WX 748 ; N a196 ; B 35 94 698 597 ;
XC 217 ; WX 924 ; N a165 ; B 35 140 890 552 ;
XC 218 ; WX 748 ; N a192 ; B 35 94 698 597 ;
XC 219 ; WX 918 ; N a166 ; B 35 167 884 525 ;
XC 220 ; WX 927 ; N a167 ; B 35 32 892 660 ;
XC 221 ; WX 928 ; N a168 ; B 35 129 891 562 ;
XC 222 ; WX 928 ; N a169 ; B 35 128 893 563 ;
XC 223 ; WX 834 ; N a170 ; B 35 155 799 537 ;
XC 224 ; WX 873 ; N a171 ; B 35 93 838 599 ;
XC 225 ; WX 828 ; N a172 ; B 35 104 791 588 ;
XC 226 ; WX 924 ; N a173 ; B 35 98 889 594 ;
XC 227 ; WX 924 ; N a162 ; B 35 97 889 593 ;
XC 228 ; WX 917 ; N a174 ; B 35 0 882 692 ;
XC 229 ; WX 930 ; N a175 ; B 35 84 896 608 ;
XC 230 ; WX 931 ; N a176 ; B 35 84 896 608 ;
XC 231 ; WX 463 ; N a177 ; B 35 -99 429 791 ;
XC 232 ; WX 883 ; N a178 ; B 35 71 848 623 ;
XC 233 ; WX 836 ; N a179 ; B 35 44 802 648 ;
XC 234 ; WX 836 ; N a193 ; B 35 44 802 648 ;
XC 235 ; WX 867 ; N a180 ; B 35 101 832 591 ;
XC 236 ; WX 867 ; N a199 ; B 35 101 832 591 ;
XC 237 ; WX 696 ; N a181 ; B 35 44 661 648 ;
XC 238 ; WX 696 ; N a200 ; B 35 44 661 648 ;
XC 239 ; WX 874 ; N a182 ; B 35 77 840 619 ;
XC 241 ; WX 874 ; N a201 ; B 35 73 840 615 ;
XC 242 ; WX 760 ; N a183 ; B 35 0 725 692 ;
XC 243 ; WX 946 ; N a184 ; B 35 160 911 533 ;
XC 244 ; WX 771 ; N a197 ; B 34 37 736 655 ;
XC 245 ; WX 865 ; N a185 ; B 35 207 830 481 ;
XC 246 ; WX 771 ; N a194 ; B 34 37 736 655 ;
XC 247 ; WX 888 ; N a198 ; B 34 -19 853 712 ;
XC 248 ; WX 967 ; N a186 ; B 35 124 932 568 ;
XC 249 ; WX 888 ; N a195 ; B 34 -19 853 712 ;
XC 250 ; WX 831 ; N a187 ; B 35 113 796 579 ;
XC 251 ; WX 873 ; N a188 ; B 36 118 838 578 ;
XC 252 ; WX 927 ; N a189 ; B 35 150 891 542 ;
XC 253 ; WX 970 ; N a190 ; B 35 76 931 616 ;
XC 254 ; WX 918 ; N a191 ; B 34 99 884 593 ;
XC -1 ; WX 509 ; N a205 ; B 35 0 475 692 ;
XC -1 ; WX 410 ; N a206 ; B 35 0 375 692 ;
XC -1 ; WX 509 ; N a85 ; B 35 0 475 692 ;
XC -1 ; WX 410 ; N a86 ; B 35 0 375 692 ;
XC -1 ; WX 234 ; N a87 ; B 35 -14 199 705 ;
XC -1 ; WX 234 ; N a88 ; B 35 -14 199 705 ;
XC -1 ; WX 390 ; N a89 ; B 35 -14 356 705 ;
XC -1 ; WX 390 ; N a90 ; B 35 -14 355 705 ;
XC -1 ; WX 276 ; N a91 ; B 35 0 242 692 ;
XC -1 ; WX 276 ; N a92 ; B 35 0 242 692 ;
XC -1 ; WX 317 ; N a93 ; B 35 0 283 692 ;
XC -1 ; WX 317 ; N a94 ; B 35 0 283 692 ;
XC -1 ; WX 334 ; N a95 ; B 35 0 299 692 ;
XC -1 ; WX 334 ; N a96 ; B 35 0 299 692 ;
XEndCharMetrics
XEndFontMetrics
END_OF_FILE
  if test 9316 -ne `wc -c <'font/ZapfDin.AFM'`; then
    echo shar: \"'font/ZapfDin.AFM'\" unpacked with wrong size!
  fi
  # end of 'font/ZapfDin.AFM'
fi
if test -f 'z07.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z07.c'\"
else
  echo shar: Extracting \"'z07.c'\" \(9004 characters\)
  sed "s/^X//" >'z07.c' <<'END_OF_FILE'
X/*@z07.c:Object Service:SplitIsDefinite(), DisposeObject()@*******************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z07.c                                                      */
X/*  MODULE:       Object Service                                             */
X/*  EXTERNS:      MakeWord(), MakeWordTwo(), DisposeObject(), CopyObject(),  */
X/*                SplitIsDefinite()                                          */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN SplitIsDefinite(x)                                               */
X/*                                                                           */
X/*  Return TRUE if x is a definite SPLIT object (both children definite)     */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN SplitIsDefinite(x)
XOBJECT x;
X{ OBJECT y1, y2;
X  assert( type(x) == SPLIT, "SplitIsDefinite: x not a SPLIT!" );
X  Child(y1, DownDim(x, COL));
X  Child(y2, DownDim(x, ROW));
X  return is_definite(type(y1)) && is_definite(type(y2));
X} /* end SplitIsDefinite */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  DisposeObject(x)                                                         */
X/*                                                                           */
X/*  Dispose object x recrusively, leaving intact any shared descendants.     */
X/*                                                                           */
X/*****************************************************************************/
X
XDisposeObject(x)
XOBJECT x;
X{ debug2(DOS,D,"[DisposeObject( %d ), type = %s, x =", (int) x, Image(type(x)));
X  ifdebug(DOS, DD, DebugObject(x));
X  assert( Up(x) == x, "DisposeObject: x has a parent!" );
X  while( Down(x) != x )  DisposeChild(Down(x));   Dispose(x);
X  debug0(DOS, D, "]DisposeObject returning.");
X} /* end DisposeObject */
X
X
X/*@::MakeWord(), MakeWordTwo()@***********************************************/
X/*                                                                           */
X/*  OBJECT MakeWord(typ, str, pos)                                           */
X/*                                                                           */
X/*  Return an unsized WORD or QWORD made from the given string and fpos.     */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT MakeWord(typ, str, pos)
Xunsigned typ;  FULL_CHAR *str;  FILE_POS *pos;
X{ OBJECT res = NewWord(typ, StringLength(str), pos);
X  StringCopy(string(res), str);
X  FposCopy(fpos(res), *pos);
X  debug4(DOS, DD, "MakeWord(%s, %s, %s) returning %s",
X    Image(typ), str, EchoFilePos(pos), EchoObject(res));
X  return res;
X} /* end MakeWord */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT MakeWordTwo(typ, str1, str2, pos)                                 */
X/*                                                                           */
X/*  Return an unsized WORD or QWORD made from the two strings and fpos.      */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT MakeWordTwo(typ, str1, str2, pos)
Xunsigned typ;  FULL_CHAR *str1, *str2;  FILE_POS *pos;
X{ int len1 = StringLength(str1);
X  int len2 = StringLength(str2);
X  OBJECT res = NewWord(typ, len1 + len2, pos);
X  StringCopy(string(res), str1);
X  StringCopy(&string(res)[len1], str2);
X  FposCopy(fpos(res), *pos);
X  debug5(DOS, DD, "MakeWordTwo(%s, %s, %s, %s) returning %s",
X    Image(typ), str1, str2, EchoFilePos(pos), EchoObject(res));
X  return res;
X} /* end MakeWordTwo */
X
X
X/*@::CopyObject()@************************************************************/
X/*                                                                           */
X/*  OBJECT CopyObject(x, pos)                                                */
X/*                                                                           */
X/*  Make a copy of unsized object x, setting all file positions to *pos.     */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT CopyObject(x, pos)
XOBJECT x;  FILE_POS *pos;
X{ OBJECT y, link, res, tmp;
X
X  debug2(DOS, DD, "CopyObject(%s, %s)", EchoObject(x), EchoFilePos(pos));
X  switch( type(x) )
X  {
X
X    case WORD:
X    case QWORD:
X    
X      res = NewWord(type(x), StringLength(string(x)), pos);
X      StringCopy(string(res), string(x));
X      break;
X
X
X    case GAP_OBJ:
X    
X      res = New(type(x));
X      mark(gap(res)) = mark(gap(x));
X      join(gap(res)) = join(gap(x));
X      if( Down(x) != x )
X      {	Child(y, Down(x));
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      else
X      {	hspace(res) = hspace(x);
X	vspace(res) = vspace(x);
X      }
X      break;
X
X
X    /* case HEAD: */
X    case NULL_CLOS:
X    case CROSS:
X    case ONE_COL:
X    case ONE_ROW:
X    case WIDE:
X    case HIGH:
X    case HSCALE:
X    case VSCALE:
X    case SCALE:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case ROTATE:
X    case CASE:
X    case YIELD:
X    case XCHAR:
X    case FONT:
X    case SPACE:
X    case BREAK:
X    case NEXT:
X    case OPEN:
X    case TAGGED:
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GRAPHIC:
X    case VCAT:
X    case HCAT:
X    case ACAT:
X    
X      res = New(type(x));
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      break;
X
X
X    case ENV:
X    
X      res = x;  /* do not copy environments */
X      break;
X
X
X    case PAR:
X    
X      res = New(PAR);
X      actual(res) = actual(x);
X      assert( Down(x) != x, "CopyObject: PAR child!" );
X      Child(y, Down(x));
X      tmp = CopyObject(y, pos);
X      Link(res, tmp);
X      break;
X
X
X    case CLOSURE:
X    
X      res = New(type(x));
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	assert( type(y) != CLOSURE, "CopyObject: CLOSURE!" );
X	tmp = CopyObject(y, pos);
X	Link(res, tmp);
X      }
X      actual(res) = actual(x);
X      StyleCopy(save_style(res), save_style(x));
X      break;
X
X
X    default:
X    
X      Error(INTERN, pos, "CopyObject: %s found", Image(type(x)));
X      break;
X
X  } /* end switch */
X  if( pos == no_fpos )  FposCopy(fpos(res), fpos(x));
X  else FposCopy(fpos(res), *pos);
X  debug1(DOS, DD, "CopyObject returning %s", EchoObject(res));
X  return res;
X} /* end CopyObject */
END_OF_FILE
  if test 9004 -ne `wc -c <'z07.c'`; then
    echo shar: \"'z07.c'\" unpacked with wrong size!
  fi
  # end of 'z07.c'
fi
if test -f 'z11.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z11.c'\"
else
  echo shar: Extracting \"'z11.c'\" \(8879 characters\)
  sed "s/^X//" >'z11.c' <<'END_OF_FILE'
X/*@z11.c:Style Service:EchoStyle()@*******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z11.c                                                      */
X/*  MODULE:       Style Service                                              */
X/*  EXTERNS:      EchoStyle(), SpaceChange(), BreakChange()                  */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X#if DEBUG_ON
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *EchoStyle(style)                                              */
X/*                                                                           */
X/*  Returns a string showing the value of the style.                         */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *EchoStyle(style)
XSTYLE *style;
X{ FULL_CHAR buff1[100], buff2[100], buff3[100], buff4[100];
X  static FULL_CHAR res[100];
X  static char *hyphwords[] = { "hyph_undef", "hyph_off", "hyph_on" };
X  static char *fillwords[] = { "fill_undef", "fill_off", "fill_on" };
X  static char *displaywords[] = { "undef", "adjust", "outdent", "left",
X			     "centre", "right", "do" };
X
X  StringCopy(res, AsciiToFull("["));
X  StringCat(res, EchoCatOp(VCAT,mark(line_gap(*style)),join(line_gap(*style))));
X  StringCat(res, EchoGap(&line_gap(*style)));
X  StringCat(res, AsciiToFull(", "));
X  StringCat(res, font(*style) == 0 ?
X		   AsciiToFull("nofont") : FontFamilyAndFace(font(*style)));
X  StringCat(res, AsciiToFull(" ("));
X  StringCat(res, EchoGap(&space_gap(*style)));
X  StringCat(res, AsciiToFull("), "));
X  StringCat(res, AsciiToFull(hyph_style(*style) < 3 ?
X		    hyphwords[hyph_style(*style)] : "?"));
X  StringCat(res, AsciiToFull(":"));
X  StringCat(res, AsciiToFull(fill_style(*style) < 3 ?
X		    fillwords[fill_style(*style)] : "?"));
X  StringCat(res, AsciiToFull(":"));
X  StringCat(res, AsciiToFull(display_style(*style) < 7 ?
X		    displaywords[display_style(*style)] : "?"));
X  StringCat(res, AsciiToFull("]"));
X  return res;
X} /* end EchoStyle */
X#endif
X
X
X/*@::SpaceChange()@***********************************************************/
X/*                                                                           */
X/*  SpaceChange(style, x)                                                    */
X/*                                                                           */
X/*  Change the current break style as indicated by object x.                 */
X/*                                                                           */
X/*****************************************************************************/
X
XSpaceChange(style, x)
XSTYLE *style;  OBJECT x;
X{ GAP res_gap;  unsigned gap_inc;
X  debug2(DSS, D, "SpaceChange(%s, %s)", EchoStyle(style), EchoObject(x));
X  if( !is_word(type(x)) )
X  { Error(WARN, &fpos(x), "invalid left parameter to %s", KW_SPACE);
X  }
X  else
X  { GetGap(x, style, &res_gap, &gap_inc);
X    if( gap_inc != GAP_ABS && units(res_gap) != units(space_gap(*style)) )
X    { Error(WARN, &fpos(x), "space %s incompatible with enclosing", string(x));
X    }
X    else
X    { units(space_gap(*style)) = units(res_gap);
X      mode(space_gap(*style))  = mode(res_gap);
X      width(space_gap(*style)) = gap_inc == GAP_ABS ? width(res_gap) :
X	     gap_inc == GAP_INC ? width(space_gap(*style)) + width(res_gap) :
X	     max(width(space_gap(*style)) - width(res_gap), 0);
X    }
X  }
X  debug1(DSS, D, "SpaceChange returning %s", EchoStyle(style));
X} /* end SpaceChange */
X
X
X/*@::BreakChange()@***********************************************************/
X/*                                                                           */
X/*  BreakChange(style, x)                                                    */
X/*                                                                           */
X/*  Change the current break style as indicated by object x.                 */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic changebreak(style, x)
XSTYLE *style;  OBJECT x;
X{ GAP res_gap;  unsigned gap_inc;
X  if( beginsbreakstyle(string(x)[0]) )
X  {
X    /* should be a new break style option */
X    if( StringEqual(string(x), STR_BREAK_HYPHEN) )
X	hyph_style(*style) = HYPH_ON;
X    else if( StringEqual(string(x), STR_BREAK_NOHYPHEN) )
X	hyph_style(*style) = HYPH_OFF;
X    else if( StringEqual(string(x), STR_BREAK_ADJUST) )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_ADJUST;
X    else if( StringEqual(string(x), STR_BREAK_OUTDENT) )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_OUTDENT;
X    else if( StringEqual(string(x), STR_BREAK_RAGGED) )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_LEFT;
X    else if( StringEqual(string(x), STR_BREAK_CRAGGED) )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_CENTRE;
X    else if( StringEqual(string(x), STR_BREAK_RRAGGED) )
X	fill_style(*style) = FILL_ON, display_style(*style) = DISPLAY_RIGHT;
X    else if( StringEqual(string(x), STR_BREAK_LINES) )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_LEFT;
X    else if( StringEqual(string(x), STR_BREAK_CLINES) )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_CENTRE;
X    else if( StringEqual(string(x), STR_BREAK_RLINES) )
X	fill_style(*style) = FILL_OFF, display_style(*style) = DISPLAY_RIGHT;
X    else Error(WARN, &fpos(x), "invalid %s option %s", KW_BREAK, string(x));
X  }
X  else /* should be a new inter-line gap */
X  { GetGap(x, style, &res_gap, &gap_inc);
X    if( gap_inc != GAP_ABS && units(res_gap) != units(line_gap(*style)) )
X      Error(WARN, &fpos(x),
X		    "line spacing %s incompatible with enclosing", string(x));
X    else
X    { units(line_gap(*style)) = units(res_gap);
X      mode(line_gap(*style))  = mode(res_gap);
X      width(line_gap(*style)) = gap_inc == GAP_ABS ? width(res_gap) :
X	gap_inc == GAP_INC ? width(line_gap(*style)) + width(res_gap) :
X	max(width(line_gap(*style)) - width(res_gap), 0);
X    }
X  }
X} /* end changebreak */
X
XBreakChange(style, x)
XSTYLE *style;  OBJECT x;
X{ OBJECT link, y;
X  debug2(DSS, D, "BreakChange(%s, %s)", EchoStyle(style), EchoObject(x));
X  switch( type(x) )
X  {
X    case WORD:
X    case QWORD:	changebreak(style, x);
X		break;
X
X
X    case ACAT:	for( link = Down(x);  link != x;  link = NextDown(link) )
X		{ Child(y, link);
X		  if( type(y) == GAP_OBJ )  continue;
X		  else if( is_word(type(y)) )  changebreak(style, y);
X		  else Error(WARN, &fpos(x), "invalid left parameter of %s",
X			 KW_BREAK);
X		}
X		break;
X
X
X    default:	Error(WARN, &fpos(x), "invalid left parameter of %s", KW_BREAK);
X		break;
X  }
X  debug1(DSS, D, "BreakChange returning %s", EchoStyle(style));
X} /* end BreakChange */
END_OF_FILE
  if test 8879 -ne `wc -c <'z11.c'`; then
    echo shar: \"'z11.c'\" unpacked with wrong size!
  fi
  # end of 'z11.c'
fi
if test -f 'z30.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z30.c'\"
else
  echo shar: Extracting \"'z30.c'\" \(8858 characters\)
  sed "s/^X//" >'z30.c' <<'END_OF_FILE'
X/*@z30.c:Symbol uses:InsertUses()@********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z30.c                                                      */
X/*  MODULE:       Symbol Uses                                                */
X/*  EXTERNS:      InsertUses(), FlattenUses(), SearchUses(),                 */
X/*                FirstExternTarget(), NextExternTarget()                    */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  InsertUses(x, y)                                                         */
X/*                                                                           */
X/*  Record the fact that symbol x uses symbol y, by linking them.            */
X/*  Increment count of the number of times y is used, if y is a parameter.   */
X/*                                                                           */
X/*****************************************************************************/
X
XInsertUses(x, y)
XOBJECT x, y;
X{ OBJECT tmp;
X  debug2(DSU, D, "InsertUses( %s, %s )", SymName(x), SymName(y));
X  if( type(x) == LOCAL && type(y) == LOCAL && !predefined(y) )
X  { tmp = GetMem(USES_SIZE, no_fpos);  item(tmp) = y;
X    if( base_uses(x) == nil )  next(tmp) = tmp;
X    else next(tmp) = next(base_uses(x)), next(base_uses(x)) = tmp;
X    base_uses(x) = tmp;
X  }
X  if( is_par(type(y)) )
X  { uses_count(y) += (enclosing(y) == x ? 1 : 2);
X    if( dirty(y) || uses_count(y) > 1 )  dirty(enclosing(y)) = TRUE;
X  }
X  else if( sym_body(y) == nil || dirty(y) )  dirty(x) = TRUE;
X  debug5(DSU, D, "InsertUses returning ( %s %s; %s %s, count = %d )",
X    SymName(x), (dirty(x) ? "dirty" : "clean"),
X    SymName(y), (dirty(y) ? "dirty" : "clean"), uses_count(y));
X} /* end InsertUses */
X
X
X/*@::GatherUses(), GatherAllUses(), FlattenUses()@****************************/
X/*                                                                           */
X/*  static GatherUses(x, sym)                                                */
X/*  static GatherAllUses(x)                                                  */
X/*                                                                           */
X/*  GatherUses adds all the unmarked descendants of x to the uses relation   */
X/*  of sym;  GatherAllUses applies gather_uses to all descendants of x.      */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic GatherUses(x, sym)
XOBJECT x, sym;
X{ OBJECT link, y, tmp;
X  if( base_uses(x) != nil )
X  { link = next(base_uses(x));
X    do
X    { y = item(link);
X      if( marker(y) != sym )
X      {	if( y != sym )
X	{ marker(y) = sym;
X	  tmp = GetMem(USES_SIZE, no_fpos);  item(tmp) = y;
X	  if( uses(sym) == nil )  next(tmp) = tmp;
X	  else next(tmp) = next(uses(sym)), next(uses(sym)) = tmp;
X	  uses(sym) = tmp;
X	  if( indefinite(y) )  indefinite(sym) = TRUE;
X	  if( uses_extern_target(y) )  uses_extern_target(sym) = TRUE;
X	  GatherUses(y, sym);
X	}
X	else recursive(sym) = TRUE;
X      }
X      link = next(link);
X    } while( link != next(base_uses(x)) );
X  }
X} /* end GatherUses */
X
X
Xstatic GatherAllUses(x)
XOBJECT x;
X{ OBJECT link, y;
X  for( link = Down(x);  link != x;  link = NextDown(link) )
X  { Child(y, link);
X    if( type(y) == LOCAL )  GatherUses(y, y);
X    GatherAllUses(y);
X  }
X} /* end GatherAllUses */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FlattenUses()                                                            */
X/*                                                                           */
X/*  Traverse the directed graph assembled by InsertUses, finding its         */
X/*  transitive closure and storing this explicitly in uses(x) for all x.     */
X/*                                                                           */
X/*****************************************************************************/
X
XFlattenUses()
X{ GatherAllUses(StartSym);
X} /* end FlattenUses */
X
X
X/*@::SearchUses(), FirstExternTarget(), NextExternTarget()@*******************/
X/*                                                                           */
X/*  BOOLEAN SearchUses(x, y)                                                 */
X/*                                                                           */
X/*  Discover whether symbol x uses symbol y by searching the uses list of x. */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN SearchUses(x, y)
XOBJECT x, y;
X{ OBJECT p;
X  debug3(DSU, DD, "SearchUses(%s, %s) uses: %d", SymName(x),SymName(y),uses(x));
X  if( x == y )  return TRUE;
X  if( uses(x) != nil )
X  { p = next(uses(x));
X    do
X    { debug1(DSU, DDD, "  checking %s", SymName(item(p)));
X      if( item(p) == y )  return TRUE;
X      p = next(p);
X    } while( p != next(uses(x)) );
X  }
X  return FALSE;
X} /* end SearchUses */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT FirstExternTarget(sym, cont)                                      */
X/*  OBJECT NextExternTarget(sym, cont)                                       */
X/*                                                                           */
X/*  Together these two procedures return all symbols which are both used by  */
X/*  sym and a target for at least one external galley.  Return nil at end.   */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT FirstExternTarget(sym, cont)
XOBJECT sym, *cont;
X{ OBJECT res;
X  debug1(DSU, D, "FirstExternTarget( %s )", SymName(sym));
X  res = nil;  *cont = nil;
X  if( is_extern_target(sym) )  res = sym;
X  else if( uses(sym) != nil )
X  { *cont = next(uses(sym));
X    do
X    { if( is_extern_target(item(*cont)) )
X      {	res = item(*cont);
X	break;
X      }
X      *cont = next(*cont);
X    } while( *cont != next(uses(sym)) );
X  }
X  debug1(DSU, D, "FirstExternTarget returning %s", SymName(res));
X  return res;
X} /* end FirstExternTarget */
X
XOBJECT NextExternTarget(sym, cont)
XOBJECT sym, *cont;
X{ OBJECT res;
X  debug1(DSU, D, "NextExternTarget( %s )", SymName(sym));
X  res = nil;
X  if( *cont != nil )
X  { *cont = next(*cont);
X    while( *cont != next(uses(sym)) )
X    { if( is_extern_target(item(*cont)) )
X      {	res = item(*cont);
X	break;
X      }
X      *cont = next(*cont);
X    }
X  }
X  debug1(DSU, D, "NextExternTarget returning %s", SymName(res));
X  return res;
X} /* end NextExternTarget */
END_OF_FILE
  if test 8858 -ne `wc -c <'z30.c'`; then
    echo shar: \"'z30.c'\" unpacked with wrong size!
  fi
  # end of 'z30.c'
fi
echo shar: End of archive 29 \(of 35\).
cp /dev/null ark29isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
