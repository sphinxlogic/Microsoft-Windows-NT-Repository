Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i095:  lout - Lout document formatting system, v2.05, Part27/35
Message-ID: <1993Aug10.132146.18703@sparky.sterling.com>
X-Md4-Signature: d6c4242f990370d84e4ff65bf0d9e7ea
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 13:21:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 95
Archive-name: lout/part27
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  doc/tr.fig/s8 doc/tr.impl/s2.4 doc/tr.lout/ch1.00 z09.c
#   z21.c z26.c z39.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:31 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 27 (of 35)."'
if test -f 'doc/tr.fig/s8' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.fig/s8'\"
else
  echo shar: Extracting \"'doc/tr.fig/s8'\" \(12131 characters\)
  sed "s/^X//" >'doc/tr.fig/s8' <<'END_OF_FILE'
X@Section
X   @Title { A Concise Reference for Fig }
X@Begin
X@PP
XThe options to the @Code "@Fig" symbol, and their
Xdefault values, are as follows.  The complete range of options is shown
Xat right:
X@ID @Tab
X  hmargin { 1s }
X  vmargin { 0.5vx }
X  @Fmth { @Col @Code A ! @Col @Code " " ! @Col @Code B ! @Col @Code " " !
X	  @Col 1.0c @Wide ! @Col C }
X  @Fmta { @Col @Code A ! @Col @Code "{" ! @Col @Code B ! @Col @Code "}" !
X	  @Col 1.0c @Wide ! @Col C }
X{
X@Rowh
X  A { "@Fig" }
X@Rowa
X  A { "   maxlabels" }
X  B { 200 }
X  C { any whole number }
X@Rowa
X  A { "   linestyle" }
X  B { solid }
X  C { @Code "solid dashed cdashed dotted noline" }
X@Rowa
X  A { "   linewidth" }
X  B { 0.5 pt }
X  C { any Fig length (see below) }
X@Rowa
X  A { "   linecap"   }
X  B { round  }
X  C { @Code "butt round project" }
X@Rowa
X  A { "   dashlength"}
X  B { 0.15 cm }
X  C { any Fig length }
X@Rowa
X  A { "   paint"     }
X  B { nopaint }
X  C { @Code "nopaint white light grey gray dark black" }
X@Rowa
X  A { "   margin"    }
X  B { 0.4c }
X  C { any Lout length }
X@Rowa
X  A { "   arrow"     }
X  B { noarrow }
X  C { @Code "noarrow forward back both" }
X@Rowa
X  A { "   headstyle" }
X  B { open }
X  C { @Code "open halfopen closed" }
X@Rowa
X  A { "   headwidth" }
X  B { 0.05 cm }
X  C { any Fig length }
X@Rowa
X  A { "   headlength"}
X  B { 0.15 cm }
X  C { any Fig length }
X}
XThe @Code "linecap" option determines the shape of the ends of lines:
X@Code "round" puts a round cap on them, which is the most useful in
XFig;  @Code "butt" is a square end; and @Code "project" is a square end
Xprojecting half a line width past the end of the line; it is useful for
Xgetting sharp corners on rectangles and square dots in dotted lines.
X@FootNote {
XThe line joining options of PostScript are not reflected in Fig options
Xbecause Fig strokes paths segment by segment, not all at once, and so
Xthere are no line joins in the PostScript sense.  This was done to
Ximprove the appearance of dashed and dotted lines.
X}
X@PP
XThe following standard shapes take the same options as {@Code "@Fig"},
Xexcept that they do not have @Code "maxlabels" or the last four
X(arrow-drawing) options,
Xand occasionally they have other options.  In most cases the default
Xvalues of these options are taken from the enclosing {@Code "@Fig"}.
XWhere there are extra options, or where a different default value is
Xused, the option and its default value are shown.  The list also shows
Xthe shape's labels, and how it is superimposed on its right parameter
X(shown as a grey rectangle).  A larger margin will enlarge the right
Xparameter and hence the shape as well.  Squares, polygons and circles
Xhave a diameter equal to the larger of @Code xsize and {@Code ysize}.
X@LP
X@ID {
X5c @Wide @Code "@Box"
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Box margin { 0c }
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@LP
X@ID {
X5c @Wide @Code "@Square"
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Square margin { 0c }
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X@LP
X
X@ID {
X5c @Wide @Code "@Diamond"
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Diamond margin { 0c }
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@LP
X@ID {
X5c @Wide @Code {
X"@Polygon"
X"   sides { 3 }"
X"   angle { 180/sides }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Polygon margin { 0c }
X{ 2c @Wide 1c @High }
X|| @ShowLabels ||0.5c ... ||0.5c
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Polygon sides { 12 } margin { 0c }
X{ 2c @Wide 1c @High }
X||1c ...
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code "@Ellipse"
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Ellipse margin { 0c }
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@LP
X@ID {
X5c @Wide @Code "@Circle"
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Circle margin { 0c }
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X@LP
X
XThe following standard shapes have the same options as
X{@Code "@Fig"}, including the four arrow-drawing options,
Xand occasionally they have others.  In each case the only difference
Xbetween the line and arrow symbols is the default value of
X{@Code "arrow"}, which lines take from {@Code "@Fig"} and arrows set
Xto {@Code "forward"}.  The first four draw a line along the mark of the
Xright parameter, which is not necessarily the same as its left or top
Xedge.
X@LP
X@ID {
X5c @Wide @Code {
X"@HLine"
X"   margin { 0c }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@HLine
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@HArrow"
X"   margin { 0c }"
X"   arrow { forward }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@HArrow
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@VLine"
X"   margin { 0c }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@VLine
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@VArrow"
X"   margin { 0c }"
X"   arrow { forward }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@VArrow
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@Line"
X"   from { 0 ysize }"
X"   to { xsize 0 }"
X"   margin { 0c }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Line
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@Arrow"
X"   from { 0 ysize }"
X"   to { xsize 0 }"
X"   margin { 0c }"
X"   arrow { forward }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Arrow
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
X@ID {
X5c @Wide @Code {
X"@Arc"
X"   from { 0 ysize }"
X"   to { xsize 0 }"
X"   ctr { 0 0 }"
X"   direction { clockwise }"
X"   margin { 0c }"
X}
X||7ct
X@Fig {
X@Figure shape { 0 0 xsize 0 xsize ysize 0 ysize 0 0 } paint { grey }
Xlinestyle { noline }  margin { 0c }
X@Arc
X{ 2c @Wide 1c @High }
X// @ShowLabels
X}
X}
X
XMore generally, the @Code "@Figure" symbol takes all the options of
X@Code "@Fig" except {@Code "maxlabels"}, together with a @Code shape
Xoption containing a sequence of points, and it connects each pair of
Xpoints by a line or curve as specified by the following:
X@ID @Tab
X   vmargin { 0.5vx }
X   @Fmta { @Col A ! @Col B }
X{
X@Rowa
X  A { @I { point  point } }
X  B { Straight line }
X@Rowa
X  A { @I { point } @Code "[" &0.5s @Code "]" @I { point } }
X  B { Draw nothing }
X@Rowa
X  A { @I { point } @Code "[" @I point @Code "]" @I { point } }
X  B { Anticlockwise circular or elliptical arc }
X@Rowa
X  A { @I { point } @Code "[" @I point @Code "clockwise ]" @I { point } }
X  B { Clockwise circular or elliptical arc }
X@Rowa
X  A { @I { point } @Code "[" @I {point point} @Code "]" @I { point } }
X  B { Bezier curve with two control points }
X}
X@LP
XThe remaining symbols do not draw shapes.  They are
X@ID lines @Break {
X@I colour  @Code "@Colour"  @I object
X@I colour  @Code "@Color"  @I object
X}
XPrint @I object in {@I colour}, which may be {@Code "white"},
X{@Code "grey"}, {@Code "gray"}, {@Code "black"}, {@Code "red"},
X{@Code "green"}, or {@Code "blue"} at least.
X@ID lines @Break {
X@Code "{" @I {number number number} @Code "} @RGBColour"  @I object
X@Code "{" @I {number number number} @Code "} @RGBColor"  @I object
X@Code "{" @I {number number number} @Code "} @HSBColour"  @I object
X@Code "{" @I {number number number} @Code "} @HSBColor"  @I object
X}
XPrint @I object in the colour defined by the three numbers, using the
Xred-green-blue or hue-saturation-brightness colour models.
X@ID {
X@I point  @Code "@Label"  @I label
X}
XWithin a shape, makes @I label stand for the point on the page denoted
Xby {@I point}, which is not made part of the shape.  The label applies
Xfrom here onwards until some other point is given this label, a
Xrelabelling occurs, or the figure ends.
X@ID {
X@I label  @Code "::"  @I object
X}
XRelabel every labelled point in the right parameter (which may be an
Xarbitrary Lout object), by adding {@I label}{@Code "@"} to the front of
Xeach label.
X@ID {
X@Code "@Frame"  @I object
X}
XEquivalent to @Code "@Figure shape {xsize 0 @Label X 0 ysize @Label Y}"
X@I object & .
X@ID {
X@I point  @Code "@BaseOf"  @I object
X}
XTranslate @I object so that its bottom left-hand corner appears at
X{@I point}.  Lout thinks that the result is an empty object.
X@ID {
X@I point  @Code "@MarkOf"  @I object
X}
XTranslate @I object so that the point where its marks cross appears at
X{@I point}.  Lout thinks that the result is an empty object.
X@ID {
X@Code "@ShowLabels"
X}
XDisplay all the labels of the figure created up to this point.
X@PP
XThe following lists define all the ways to specify lengths, angles and
Xpoints.
X@FootNote {
XA length is represented in PostScript by a single number on the operand
Xstack; so is an angle.  A point is represented by two numbers on the
Xstack.  Those familiar with PostScript and willing to sacrifice portability
Xand increase their risk of error can therefore write, for example,
X@OneCol {@I length @Code "sqrt"} within a shape, to obtain a length which
Xis the square root of another length, or @OneCol { @I point @Code "exch" }
Xto obtain the reflection of a point about the main diagonal, and so on.
X}
XBrief explanations appear to the right, with the symbols' precedences in
Xparentheses where appropriate.
X@DP
X@Tab
X  vmargin { 0.5vx }
X  @Fmth { @Col { &@DispIndent     A } ! @Col   }
X  @Fmta { @Col { &@DispIndent &2s A } ! @Col B }
X{
X@Rowh A { @I length } vmargin { 0.2vx }
X@Rowh
X@Rowa
X  A { 0 }
X  B { zero }
X@Rowa
X  A { @Code xmark }
X  B { distance to column mark }
X@Rowa
X  A { @Code ymark }
X  B { distance to row mark }
X@Rowa
X  A { @Code xsize }
X  B { distance to right boundary }
X@Rowa
X  A { @Code ysize }
X  B { distance to top boundary }
X@Rowa
X  A { @I number @Code in }
X  B { @I number inches (39) }
X@Rowa
X  A { @I number @Code cm }
X  B { @I number centimetres (39) }
X@Rowa
X  A { @I number @Code pt }
X  B { @I number points (39) }
X@Rowa
X  A { @I number @Code em }
X  B { @I number ems (39) }
X@Rowa
X  A { @I number @Code sp }
X  B { 1 sp is the current width of a space (39) }
X@Rowa
X  A { @I number @Code vs }
X  B { 1 vs is the current inter-line space (39) }
X@Rowa
X  A { @I number @Code ft }
X  B { 1 ft is the size of the current font (39) }
X@Rowa
X  A { @I point @Code "@Distance" @I point }
X  B { distance between two points (35) }
X@Rowa
X  A { @I point @Code "@XDistance" @I point }
X  B { horizontal distance between two points (35) }
X@Rowa
X  A { @I point @Code "@YDistance" @I point }
X  B { vertical distance between two points (35) }
X@Rowh
X@Rowh
X@Rowh A { @I angle } vmargin { 0.2vx }
X@Rowh
X@Rowa
X  A { @I number @Code dg }
X  B { @I number degrees (39) }
X@Rowa
X  A { @I number }
X  B { @I number degrees (@Code dg is optional) }
X@Rowa
X  A { @I point @Code "@Angle" @I point }
X  B { angle from first point to second (35) }
X@Rowh
X@Rowh
X@Rowh A { @I point } vmargin { 0.2vx }
X@Rowh
X@Rowa
X  A { @I {length  length} }
X  B { @I x and @I y distance from origin (5) }
X@Rowa
X  A { @I length  @Code "<<"  @I angle }
X  B { distance and angle from origin (38) }
X@Rowa
X  A { @I point  @Code "++"  @I point }
X  B { vector sum of two points (36) }
X@Rowa
X  A { @I point  @Code "--"  @I point }
X  B { vector difference of two points (36) }
X@Rowa
X  A { @I point  @Code "@Max"  @I point }
X  B { vector maximum of two points (36) }
X@Rowa
X  A { @I point  @Code "@Min"  @I point }
X  B { vector minimum of two points (36) }
X@Rowa
X  A { @I point  @Code "**"  @I number }
X  B { multiplication of point by number (37) }
X@Rowa
X  A { @I label }
X  B {  a previously defined label }
X@Rowa
X  A { @Code "@Prev"	 }
X  B {  the previous point in a shape }
X}
X@End @Section
END_OF_FILE
  if test 12131 -ne `wc -c <'doc/tr.fig/s8'`; then
    echo shar: \"'doc/tr.fig/s8'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.fig/s8'
fi
if test -f 'doc/tr.impl/s2.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s2.4'\"
else
  echo shar: Extracting \"'doc/tr.impl/s2.4'\" \(12152 characters\)
  sed "s/^X//" >'doc/tr.impl/s2.4' <<'END_OF_FILE'
X@SubSection
X    @Tag { objects.impl }
X    @Title { Implementation of objects and concatenation }
X@Begin
X@PP
XIn this section we discuss the implementation of objects and concatenation,
Xand especially mark alignment.  The first step is to use an operator
Xprecedence parser to convert input such as
X@ID @Code "a  |0.5i  b  /0.2i  c  |  d"
Xinto parse trees such as
X@ID @Eq {
X@Fig {
X@Tree {
X@Node @FCircle fraction
X@FirstSub {
X   @Node @FCircle bar
X   @FirstSub { @Node @FCircle a }
X   @NextSub  { @Node @FEllipse 0.5i }
X   @NextSub  { @Node @FCircle b }
X}
X@NextSub { @Node @FEllipse 0.2i }
X@NextSub {
X   @Node @FCircle bar
X   @FirstSub { @Node @FCircle c }
X   @NextSub  { @Node @FCircle   }
X   @NextSub  { @Node @FCircle d }
X}
X}
X}
X}
XMissing objects are replaced by empty objects, and sequences of
Xconcatenation operators are consolidated:
X@ID @Eq {
X@Fig {
X@Tree {
X@Node @FCircle bar
X@FirstSub { @Node @FCircle a }
X@NextSub { @Node @FEllipse 0.2i }
X@NextSub {
X   @Node @FCircle bar
X   @FirstSub { @Node @FCircle c     }
X   @NextSub  { @Node @FEllipse 0.3i }
X   @NextSub  { @Node @FCircle d     }
X}
X}
X}
X&2m ==> &2m
X@Fig {
X@Tree {
X@Node @FCircle bar
X@FirstSub { @Node @FCircle a     }
X@NextSub  { @Node @FEllipse 0.2i }
X@NextSub  { @Node @FCircle c     }
X@NextSub  { @Node @FEllipse 0.3i }
X@NextSub  { @Node @FCircle d     }
X}
X}
X}
Xto make manifest their associativity and reduce the depth of the tree
Xfor efficiency later.
X@PP
XThe required semantic information is the size of each subobject,
Xconsisting of four integers:  width to left and right of the
Xdistinguished column mark, and height above and below the distinguished
Xrow mark.  These numbers are always non-negative in Basser Lout, but
Xthis restriction is unnecessary and should be dropped.
X@PP
XFor the leaves, which are simple words, the numbers are obtained from
Xfont tables.  For the higher levels we apply recursive rules.  Suppose
Xthat @Eq { hgap(x, g, y) } returns the desired distance between the
Xcolumn marks of objects @Eq { x } and @Eq { y } when they are separated by
Xgap @Eq { g }:  @Eq { right(x) + length(g) + left(y) } when the gap mode is
Xedge-to-edge, the larger of @Eq { length(g) } and
X@Eq { right(x) + left(y) } when the mode is mark-to-mark, and so on.  Given
Xan object
X@ID @Eq {
XX = x sub 1 ````` bar g sub 1 ````` ... ````` { "-2p" @Font "^"}bar g sub i-1
X````` x sub i ````` ... ````` bar g sub n-1 ````` x sub n
X}
Xwe may calculate its size as follows:
X@ID @Eq {
Xleft(X) ^= left( x sub 1 ) + hgap( x sub 1 , g sub 1 , x sub 2 )
X+ ... + hgap( x sub i-1 , g sub i-1 , x sub i )
X/1.4vx
Xright(X) ^= hgap( x sub i , g sub i , x sub i+1 )
X+ ... + hgap( x sub n-1 , g sub n-1 , x sub n ) + right( x sub n )
X/1.4vx
X"above"(X) ^= "above"(x sub 1 ) up ... up "above"(x sub n )
X/1.4vx
X"below"(X) ^= "below"(x sub 1 ) up ... up "below"(x sub n )
X}
Xwhere @Eq { non up } returns the larger of its two parameters.  Similar
Xformulas are easily derived for the other operators.
X@PP
XFor purposes of exposition we will now make the simplifying
Xassumptions that all gaps are {@Code "0i"}, all column marks lie at
Xthe left edge, and all row marks lie at the top edge.  Then the size
Xof each object can be expressed by just two numbers, width and
Xheight, and the four formulas reduce to
X@ID @Eq {
Xwidth( x sub 1 rel bar ... rel bar x sub n ) ^=
Xwidth( x sub 1 ) + ... + width( x sub n )
X/1.4vx
Xheight( x sub 1 rel bar ... rel bar x sub n ) ^=
Xheight( x sub 1 ) up ... up height( x sub n )
X}
XThe corresponding formulas for vertical concatenation are
X@ID @Eq {
Xwidth( x sub 1 rel "/" ... rel "/" x sub n ) ^=
Xwidth( x sub 1 ) up ... up width( x sub n )
X/1.4vx
Xheight( x sub 1 rel "/" ... rel "/" x sub n ) ^=
Xheight( x sub 1 ) + ... + height( x sub n )
X}
XAccording to these formulas, the height of
X@ID @Eq { @Fig { @Tree {
X@Node @FCircle fraction
X@LeftSub {
X   @Node @FCircle bar
X   @LeftSub  { @Node @FCircle a }
X   @RightSub { @Node @FCircle b }
X}
X@RightSub {
X   @Node @FCircle bar
X   @LeftSub  { @Node @FCircle c }
X   @RightSub { @Node @FCircle d }
X}
X}}}
Xis
X@ID @Eq {
X[ height(a) up height(b)] + [ height(c) up height(d)]
X}
Xwhich is correct, but for width they yield
X@ID @Eq {
X[ width(a) + width(b)] up [ width(c) + width(d)]
X}
Xwhich is not, since it does not take the merging of column marks into
Xaccount.  The asymmetry between horizontal and vertical has come
Xabout because the row entries, such as @Eq {a} and {@Eq {b}}, are
Xadjacent in the tree, but the column entries, such as @Eq {a} and
X{@Eq {c}}, are not.  It would be possible to solve this cross-linking
Xproblem by augmenting the size information stored in each node to
Xrecord the number of marks and the size of each, but the author has
Xpreferred the following method which makes structural changes to the
Xtree instead.
X@PP
XIf @Eq { a } and @Eq { c } share a column mark, they each might as well
Xhave width { @Eq {width(a) up width(c) }}, since all width calculations
Xapply to entire columns.  Accordingly, we introduce a new operator,
X@Eq {COL}, defined by
X@ID @Eq { width( x sub 1 bin COL ... bin COL x sub n ) =
Xwidth( x sub 1 ) up ... up width( x sub n )
X}
Xand replace both @Eq { a } and @Eq { c } by {@Eq { a bin COL c }}.  To
Xprevent @Eq { COL } operators from disturbing height calculations, we
Xdefine a binary operator called @Eq { SPLIT } by
X@ID @Eq { width( x bin SPLIT y) ^= width(x)
X/1.4vx
Xheight( x bin SPLIT y) ^= height(y) }
Xwhich switches height and width calculations onto different
Xsubtrees.  Then the transformation
X@ID @Eq {
X@Fig { @Tree {
X   @Node @FCircle a
X}}
X&2m ==> &2m
X@Fig { @Tree {
X   @Node @FEllipse SPLIT
X   @LeftSub {
X      @Node @FEllipse COL
X      @LeftSub  { @Node @FCircle a }
X      @RightSub { @Node @FCircle c }
X   }
X   @RightSub { @Node @FCircle a }
X}}
X}
X# where @Eq { S } denotes a @Eq { SPLIT } node and @Eq { C } denotes a
X# @Eq { COL } node,
Xwidens @Eq { a } to @Eq {width(a) up width(c) } without affecting its height;
Xit is applied to every object that shares its column mark with at least
Xone other object.  A similar transformation involving a @Eq { ROW } operator
Xdeals with shared row marks.  The effect on our little table is to replace
X@ID @Eq { @Fig { @Tree {
X@Node @FCircle fraction
X@LeftSub {
X   @Node @FCircle bar
X   @LeftSub  { @Node @FCircle a }
X   @RightSub { @Node @FCircle b }
X}
X@RightSub {
X   @Node @FCircle bar
X   @LeftSub  { @Node @FCircle c }
X   @RightSub { @Node @FCircle d }
X}
X}}}
Xby
X@ID @Eq { @Fig maxlabels { "70" } { @Tree hmargin { "0.1c" } {
X@Node @FCircle fraction
X@FirstSub {
X   @Node @FCircle bar
X   @FirstSub  {
X      @Node @FEllipse SPLIT
X      @FirstSub {
X         @Node @FEllipse COL
X         @FirstSub  { @Node @FCircle a }
X         @NextSub { @Node @FCircle c }
X      }
X      @NextSub {
X         @Node @FEllipse ROW
X         @FirstSub  { @Node @FCircle a }
X         @NextSub { @Node @FCircle b }
X      }
X   }
X   @NextSub {
X      @Node @FEllipse SPLIT
X      @FirstSub {
X         @Node @FEllipse COL
X         @FirstSub  { @Node @FCircle b }
X         @NextSub { @Node @FCircle d }
X      }
X      @NextSub {
X         @Node @FEllipse ROW
X         @FirstSub  { @Node @FCircle a }
X         @NextSub { @Node @FCircle b }
X      }
X   }
X}
X@NextSub {
X   @Node @FCircle bar
X   @FirstSub  {
X      @Node @FEllipse SPLIT
X      @FirstSub {
X         @Node @FEllipse COL
X         @FirstSub  { @Node @FCircle a }
X         @NextSub { @Node @FCircle c }
X      }
X      @NextSub {
X         @Node @FEllipse ROW
X         @FirstSub  { @Node @FCircle c }
X         @NextSub { @Node @FCircle d }
X      }
X   }
X   @NextSub {
X      @Node @FEllipse SPLIT
X      @FirstSub {
X         @Node @FEllipse COL
X         @FirstSub  { @Node @FCircle b }
X         @NextSub { @Node @FCircle d }
X      }
X      @NextSub {
X         @Node @FEllipse ROW
X         @FirstSub  { @Node @FCircle c }
X         @NextSub { @Node @FCircle d }
X      }
X   }
X}
X}}}
XIn fact, common subexpressions are identified (trivially) and the result
Xis a directed acyclic graph; each affected leaf has two parents, one for
Xwidth and one for height; and each @Eq { COL } or @Eq { ROW } node has
Xone parent and one child for each object lying on the corresponding
Xmark.  The data structure roughly doubles in size, and this occurs only
Xrarely in practice.
X@PP
XThis method can cope with any legal input, including
X@ID @Code {
X"{  a  //  c  |  d  }  |  {  b  /  e  }"
X"/  {  f  /  i  }  |  {  g  |  h  //  j  }"
X}
Xwhich produces overlapping spanning columns:
X@ID @I @Fig {
X    @FBox margin { 0.2c } width { 1.6c } 1.2f @Font a |
X    @FBox margin { 0.2c } width { 0.6c } 1.2f @Font b |
X//  @FBox margin { 0.2c } width { 0.6c } 1.2f @Font c |
X    @FBox margin { 0.2c } width { 0.6c } 1.2f @Font d |
X    @FBox margin { 0.2c } width { 0.6c } 1.2f @Font e |
X//  @FBox margin { 0.2c } width { 0.6c } 1.2f @Font f |
X    @FBox margin { 0.2c } width { 0.6c } 1.2f @Font g |
X    @FBox margin { 0.2c } width { 0.6c } 1.2f @Font h |
X//  @FBox margin { 0.2c } width { 0.6c } 1.2f @Font i |
X    @FBox margin { 0.2c } width { 1.6c } 1.2f @Font j |
X}
XThe boxes have been added to clarify the structure.  The width of this
Xobject is formally
X@ID @Eq { ((width(a) up (x + y)) + z) up (x + ((y + z) up width(j))) }
Xwhere
X@IL
X@ListItem @Eq { x = width(c) up width(`f`) up width(i) }
X@ListItem @Eq { y = width(d`) up width(g) }
X@ListItem @Eq { z = width(b) up width(e) up width(h) }
X@EL
XIt seems clear that @Eq { y } at least must appear twice in any
Xexpression for the width of this object made out of simple addition
Xand maxing operations, showing that an ordinary tree
Xstructure is insufficient for overlapping spanning columns.  The Basser
XLout interpreter actually rejects such structures, owing to the author's
Xdoubts about the implementability of @I Constrained and @I AdjustSize
X(Section {@NumberOf constraints}) on them; but with hindsight this caution
Xwas unnecessary.
X@PP
XThe directed acyclic graph is ordered in the sense that the order of
Xthe edges entering and leaving each node matters.  The structure is
Xhighly dynamic, and traversals both with and against the arrows are
Xrequired.  After a few ad-hoc attempts to extend the usual tree
Xrepresentation had failed, the author developed a representation based
Xon doubly linked lists of records denoting links, whose flexibility more
Xthan compensated for the somewhat excessive memory consumption.  For example,
X@ID @Eq { @Fig {
X       A:: @FCircle a   |2c                  |2c  B:: @FCircle b
X/1.5c  C:: @FCircle c   |    D:: @FCircle d
X// A @JoinFigures arrow { forward } C
X// A @JoinFigures arrow { forward } D
X// B @JoinFigures arrow { forward } D
X}}
Xis represented by
X@CD @Eq { @Fig maxlabels { "300" } {
XA:: @DagBox mid { @BlackDot } base { a } |2c |2c |2c |2c
XB:: @DagBox mid { @BlackDot } base { b }
X/1c L:: @DagBox top { @BlackDot } mid { @BlackDot } base { LK }
X|   M:: @DagBox top { @BlackDot } mid { @BlackDot } base { LK }
X| | N:: @DagBox top { @BlackDot } mid { @BlackDot } base { LK }
X/1c
XC:: @DagBox top { @BlackDot } base { c } | |
XD:: @DagBox top { @BlackDot } base { d }
X// @TVShape nw { A@MID@CTR } ne { A@MID@CTR } sw {L@MID@CTR } se { M@MID@CTR }
X// @TVShape nw { L@TOP@CTR } ne { L@TOP@CTR } sw {C@TOP@CTR } se { C@TOP@CTR }
X// @TVShape nw { M@TOP@CTR } ne { N@TOP@CTR } sw {D@TOP@CTR } se { D@TOP@CTR }
X// @TVShape nw { B@MID@CTR } ne { B@MID@CTR } sw {N@MID@CTR } se { N@MID@CTR }
X}}
Xwhere @Eq { LK } tags a record representing a link.  The first list
Xin any node contains all the incoming links, the second contains the
Xoutgoing ones.  The node serves as the header for both lists.  The
Xrequired operations reduce to simple appends, deletes, and traversals
Xof doubly linked lists, all having small constant cost.  There is a
Xhighly tuned memory allocator, and care is taken to dispose of each node
Xwhen the last incoming link is deleted, so that there is no need for
Xgarbage collection.
X@PP
XIn normal use the number of nodes at higher levels of the dag is small
Xin comparison with the leaves and their incoming links, so we may
Xestimate the space complexity at about 60 bytes per input word (20 bytes
Xper link, 40 per leaf node).  Careful optimization could easily halve
Xthis, but since memory is reclaimed after printing each page there is
Xlittle need.
X@End @SubSection
END_OF_FILE
  if test 12152 -ne `wc -c <'doc/tr.impl/s2.4'`; then
    echo shar: \"'doc/tr.impl/s2.4'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s2.4'
fi
if test -f 'doc/tr.lout/ch1.00' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch1.00'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch1.00'\" \(301 characters\)
  sed "s/^X//" >'doc/tr.lout/ch1.00' <<'END_OF_FILE'
X@Chapter
X   @Title { Principles }
X   @Tag { principles }
X@Begin
X@LP
XThe document formatting language Lout is based on just four key ideas:
Xobjects, definitions, cross references, and galleys.  In this chapter we
Xconcentrate on them, postponing the inevitable details to later chapters.
X@BeginSections
END_OF_FILE
  if test 301 -ne `wc -c <'doc/tr.lout/ch1.00'`; then
    echo shar: \"'doc/tr.lout/ch1.00'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch1.00'
fi
if test -f 'z09.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z09.c'\"
else
  echo shar: Extracting \"'z09.c'\" \(11009 characters\)
  sed "s/^X//" >'z09.c' <<'END_OF_FILE'
X/*@z09.c:Closure Expansion:SearchEnv()@***************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z09.c                                                      */
X/*  MODULE:       Closure Expansion                                          */
X/*  EXTERNS:      SearchEnv(), SetEnv(), AttachEnv(), GetEnv(),              */
X/*                DetachEnv(), ClosureExpand()                               */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT SearchEnv(env, sym)                                               */
X/*                                                                           */
X/*  Search environment env for a symbol such that actual() == sym.           */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT SearchEnv(env, sym)
XOBJECT env, sym;
X{ OBJECT link, y;
X  debug2(DCE, DD, "SearchEnv(%s, %s)", EchoObject(env), SymName(sym));
X  for(;;)
X  {
X    debug1(DCE, DDD, "  searching env %s", EchoObject(env));
X    assert( env != nil && type(env) == ENV, "SearchEnv: env!" );
X    if( Down(env) == env )
X    { debug0(DCE, DD, "SearchEnv returning <nil>");
X      return nil;
X    }
X    Child(y, Down(env));
X    assert( type(y) == CLOSURE, "SearchEnv: type(y) != CLOSURE!" );
X    if( actual(y) == sym )
X    { debug1(DCE, DD, "SearchEnv returning %s", EchoObject(y));
X      return y;
X    }
X    assert( LastDown(y) != y, "SearchEnv: LastDown(y) == y!" );
X    link = LastDown(env) != Down(env) ? LastDown(env) : LastDown(y);
X    Child(env, link);
X  }
X} /* end SearchEnv */
X
X
X/*@::SetEnv(), AttachEnv(), GetEnv(), DetachEnv()@****************************/
X/*                                                                           */
X/*  OBJECT SetEnv(x, y)                                                      */
X/*                                                                           */
X/*  Create a new environment containing x and possibly y.                    */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT SetEnv(x, y)
XOBJECT x, y;
X{ OBJECT res;
X  debug2(DCR, DD, "SetEnv( %s, %s )", EchoObject(x), EchoObject(y));
X  debug2(DCE, D, "SetEnv( %s, %s )", EchoObject(x), EchoObject(y));
X  assert( x != nil && type(x) == CLOSURE, "SetEnv: x == nil or not CLOSURE!" );
X  assert( y == nil || type(y) == ENV, "SetEnv: y != nil && type(y) != ENV!" );
X  res = New(ENV);  Link(res, x);
X  if( y != nil )  Link(res, y);
X  debug1(DCE, D, "SetEnv returning %s", EchoObject(res));
X  return res;
X} /* end SetEnv */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  AttachEnv(env, x)                                                        */
X/*                                                                           */
X/*  Attach environment env to CLOSURE x.                                     */
X/*                                                                           */
X/*****************************************************************************/
X
XAttachEnv(env, x)
XOBJECT env, x;
X{ debug2(DCE, D, "AttachEnv( %s, %s )", EchoObject(env), EchoObject(x));
X  assert( env != nil && type(env) == ENV, "AttachEnv: type(env) != ENV!" );
X  assert( type(x) == CLOSURE, "AttachEnv: type(x) != CLOSURE!" );
X  Link(x, env);
X  debug0(DCE, D, "AttachEnv returning.");
X} /* end AttachEnv */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT GetEnv(x)                                                         */
X/*                                                                           */
X/*  Get from CLOSURE x the environment previously attached.                  */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT GetEnv(x)
XOBJECT x;
X{ OBJECT env;
X  assert( type(x) == CLOSURE, "GetEnv: type(x) != CLOSURE!" );
X  assert( LastDown(x) != x, "GetEnv: LastDown(x) == x!" );
X  Child(env, LastDown(x));
X  assert( type(env) == ENV, "GetEnv: type(env) != ENV!" );
X  return env;
X} /* end GetEnv */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT DetachEnv(x)                                                      */
X/*                                                                           */
X/*  Detach from CLOSURE x the environment previously attached.               */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT DetachEnv(x)
XOBJECT x;
X{ OBJECT env;
X  debug1(DCE, DD, "DetachEnv( %s )", EchoObject(x));
X  assert( type(x) == CLOSURE, "DetachEnv: type(x) != CLOSURE!" );
X  assert( LastDown(x) != x, "DetachEnv: LastDown(x) == x!" );
X  Child(env, LastDown(x));
X  DeleteLink(LastDown(x));
X  assert( type(env) == ENV, "DetachEnv: type(env) != ENV!" );
X  debug1(DCE, DD, "DetachEnv resturning %s", EchoObject(env));
X  return env;
X} /* end DetachEnv */
X
X
X/*@::ClosureExpand()@*********************************************************/
X/*                                                                           */
X/*  OBJECT ClosureExpand(x, env, crs_wanted, crs, res_env)                   */
X/*                                                                           */
X/*  Return expansion of closure x in environment env.                        */
X/*  The body comes from the environment of x if x is a parameter, else from  */
X/*  the symbol table.  The original x is pushed into the environments.       */
X/*  If crs_wanted and x has a tag, a cross-reference is added to crs.        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT ClosureExpand(x, env, crs_wanted, crs, res_env)
XOBJECT x, env;  BOOLEAN crs_wanted;  OBJECT *crs, *res_env;
X{ OBJECT link, y, res, prnt_env, par, prnt;
X  debug3(DCE, D, "ClosureExpand( %s, crs, %s, %s, res_env )",
X    EchoObject(x), bool(crs_wanted), EchoObject(env));
X  assert( type(x) == CLOSURE, "ClosureExpand given non-CLOSURE!");
X  assert( predefined(actual(x)) == FALSE, "ClosureExpand given predefined!" );
X
X  /* add tag to x if needed but not provided;  add cross-reference to crs  */
X  CrossAddTag(x);
X  if( crs_wanted && has_tag(actual(x)) )
X  { OBJECT tmp = CopyObject(x, no_fpos);  AttachEnv(env, tmp);
X    y = CrossMake(actual(x), tmp, CROSS_TARG);
X    tmp = New(CROSS_TARG);  actual(tmp) = y;  Link(tmp, y);
X    if( *crs == nil )  *crs = New(CR_LIST);   Link(*crs, tmp);
X  }
X
X  /* case x is a parameter */
X  res = *res_env = nil;
X  if( is_par(type(actual(x))) )
X  { prnt = SearchEnv(env, enclosing(actual(x)));
X    if( prnt==nil ) Error(FATAL, &fpos(x), "symbol with import list misused");
X    assert( prnt != nil, "ClosureExpand: is_par but prnt == nil!" );
X    prnt_env = GetEnv(prnt);
X    for( link = Down(prnt);  link != prnt;  link = NextDown(link) )
X    { Child(par, link);
X      if( type(par) == PAR && actual(par) == actual(x) )
X      {	assert( Down(par) != par, "ExpandCLosure: Down(par)!");
X	Child(res, Down(par));
X	if( dirty(enclosing(actual(par))) )
X	{ debug2(DSU, DD, "c %s %s", SymName(actual(par)), EchoObject(res));
X	  res = CopyObject(res, no_fpos);
X	}
X	else
X	{ debug2(DSU, DD, "l %s %s", SymName(actual(par)), EchoObject(res));
X	  DeleteLink(Down(par));
X	  y = MakeWord(WORD, STR_NOCROSS, &fpos(res));
X	  Link(par, y);
X	}
X	ReplaceNode(res, x);
X	if( type(actual(x)) == RPAR && has_body(enclosing(actual(x))) )
X	{ debug0(DCR, DD, "  calling SetEnv from ClosureExpand (a)");
X	  *res_env = SetEnv(prnt, nil);  DisposeObject(x);
X	}
X	else
X	{ AttachEnv(env, x);
X	  debug0(DCR, DD, "  calling SetEnv from ClosureExpand (b)");
X	  *res_env = SetEnv(x, prnt_env);
X	}
X	break;
X      }
X    }
X  }
X
X  /* case x is a user-defined symbol or default parameter */
X  if( res == nil )
X  { if( sym_body(actual(x)) == nil )  res = MakeWord(WORD,STR_NOCROSS,&fpos(x));
X    else res = CopyObject(sym_body(actual(x)), &fpos(x));
X    ReplaceNode(res, x);  AttachEnv(env, x);
X    debug0(DCR, DD, "  calling SetEnv from ClosureExpand (c)");
X    *res_env = SetEnv(x, nil);
X  }
X
X  assert( *res_env != nil && type(*res_env) == ENV, "ClosureExpand: *res_env!");
X  debug0(DCE, D, "ClosureExpand returning, res =");
X  ifdebug(DCE, D, DebugObject(res));
X  debug1(DCE, DD, "  environment = %s", EchoObject(*res_env));
X  return res;
X} /* end ClosureExpand */
END_OF_FILE
  if test 11009 -ne `wc -c <'z09.c'`; then
    echo shar: \"'z09.c'\" unpacked with wrong size!
  fi
  # end of 'z09.c'
fi
if test -f 'z21.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z21.c'\"
else
  echo shar: Extracting \"'z21.c'\" \(10803 characters\)
  sed "s/^X//" >'z21.c' <<'END_OF_FILE'
X/*@z21.c:Galley Maker:SizeGalley()@*******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z21.c                                                      */
X/*  MODULE:       Galley Maker                                               */
X/*  EXTERNS:      SizeGalley()                                               */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  SizeGalley(hd, env, rows, joined, nonblock, trig, style, c, target,      */
X/*                                                dest_index, recs, inners)  */
X/*                                                                           */
X/*  Convert unsized galley hd into sized format.  The input parameters are:  */
X/*                                                                           */
X/*    hd          the galley to be converted                                 */
X/*    env         its environment                                            */
X/*    rows        TRUE if the resulting galley may have more than one row    */
X/*    joined      TRUE if the resulting galley must be simply joined         */
X/*    nonblock    Set the non_blocking() field of RECEPTIVEs to this value   */
X/*    trig        TRUE if indefinites of hd may trigger external galleys     */
X/*    *style      The initial style                                          */
X/*    *c          the width constraint hd should conform to                  */
X/*    target      if non-nil, expand indefinite objects to reveal a          */
X/*                @Galley within this symbol                                 */
X/*                                                                           */
X/*  The output parameters, in addition to the converted hd, are:             */
X/*                                                                           */
X/*    dest_index  the index of the @Galley found within target, if any       */
X/*    recs        list of all RECURSIVE indexes found (or nil if none)       */
X/*    inners      list of all UNATTACHED indexes found (or nil if none)      */
X/*                                                                           */
X/*****************************************************************************/
X
XSizeGalley(hd, env, rows, joined, nonblock, trig, style, c, target,
X						dest_index, recs, inners)
XOBJECT hd, env;  BOOLEAN rows, joined, nonblock, trig;  STYLE *style;
XCONSTRAINT *c;  OBJECT target, *dest_index, *recs, *inners;
X{ OBJECT y, link, z, crs, t, tlink, zlink, tmp;
X  OBJECT extras, tmp1, tmp2, bt[2], ft[2];
X  
X  assert( type(hd) == HEAD && Down(hd) != hd, "SizeGalley: precondition!" );
X  assert( !sized(hd), "SizeGalley: already sized!" );
X  debug6(DGM, D, "SizeGalley(hd, -, %s, %s, %s, %s, %s, %s, -, -, -), hd =",
X	bool(joined), bool(nonblock), bool(trig), EchoStyle(style),
X	EchoConstraint(c), SymName(target));
X  ifdebug(DGM, DD, DebugObject(hd));
X
X  /* manifest the child of hd, making sure it is simply joined if required */
X  tmp1 = target;
X  Child(y, Down(hd));
X  crs = nil;
X  bt[COL] = ft[COL] = bt[ROW] = ft[ROW] = nil;
X  if( joined )
X  { bt[COL] = New(THREAD);  ft[COL] = New(THREAD);
X    y = Manifest(y, env, style, bt, ft, &tmp1, &crs, TRUE, must_expand(hd));
X    assert( Down(bt[COL]) != bt[COL] && Down(ft[COL]) != ft[COL],
X	"SizeGalley: threads!" );
X    Child(tmp1, Down(bt[COL]));  Child(tmp2, Down(ft[COL]));
X    if( Down(bt[COL]) != LastDown(bt[COL]) ||
X	  Down(ft[COL]) != LastDown(ft[COL]) || tmp1 != tmp2 )
X      Error(FATAL, &fpos(y), "galley %s must have just one column mark",
X						SymName(actual(hd)) );
X    DisposeObject(bt[COL]);  DisposeObject(ft[COL]);
X  }
X  else y = Manifest(y, env, style, bt, ft, &tmp1, &crs, TRUE, must_expand(hd));
X
X  /* horizontally size and break hd */
X  debug0(DGM, DD, "SizeGalley: after manifesting, hd =");
X  ifdebug(DGM, DD, DebugObject(hd));
X  debug0(DGM, DD, "SizeGalley horizontally sizing and breaking hd:");
X  CopyConstraint(constraint(hd), *c);
X  y = MinSize(y, COL, &extras);
X  debug0(DOB, DD, "  calling BreakObject from SizeGalley");
X  y = BreakObject(y, c);
X  back(hd, COL) = back(y, COL);
X  fwd(hd, COL)  = fwd(y, COL);
X  assert( FitsConstraint(back(hd, COL), fwd(hd, COL), *c),
X	"SizeGalley: BreakObject failed to fit!" );
X  debug2(DSF, D, "MinSize(hd, COL) = %s,%s",
X	  EchoLength(back(hd, COL)), EchoLength(fwd(hd, COL)) );
X
X  /* get the rows of hd to the top level, if required */
X  seen_nojoin(hd) = FALSE;
X  if( rows )
X  { /* OBJECT prev_gap = nil; */
X    debug0(DGM, DD, "SizeGalley cleaning up rows of hd:");
X    for( link = hd;  NextDown(link) != hd;  link = NextDown(link) )
X    { Child(y, NextDown(link));
X      debug2(DGM, DD, "  cleaning %s: %s", Image(type(y)), EchoObject(y));
X      switch( type(y) )
X      {
X	case GAP_OBJ:
X
X	  /* prev_gap = y; */
X	  if( !join(gap(y)) )  seen_nojoin(hd) = TRUE;
X	  break;
X
X
X	case VCAT:
X	  
X	  TransferLinks(Down(y), y, Up(y));
X	  DisposeChild(Up(y));
X	  link = PrevDown(link);
X	  break;
X
X
X	case SPLIT:
X	  
X	  assert(Up(y)==LastUp(y), "SizeGalley COL_THR: Up(y)!=LastUp(y)!");
X	  Child(z, DownDim(y, ROW));
X	  if( is_indefinite(type(z)) )  external(z) = TRUE;
X	  else if( type(z) == VCAT )
X	  { OBJECT hor, thor, clink, dlink;
X	    Child(hor, DownDim(y, COL));
X	    assert( type(hor) == COL_THR, "SizeGalley: missing COL_THR!" );
X	    Parent(thor, UpDim(z, COL));
X	    assert( hor == thor, "SizeGalley/SPLIT: hor != thor!" );
X	    clink = DownDim(y, COL);
X	    dlink = UpDim(z, COL);
X	    for( tlink = LastDown(z);  tlink != z;  tlink = PrevDown(tlink) )
X	    { Child(t, tlink);
X	      if( type(t) == GAP_OBJ )  Link(NextDown(link), t);
X	      else
X	      {	tmp = New(SPLIT);
X		back(tmp, COL) = back(hor, COL);
X		fwd(tmp, COL) = fwd(hor, COL);
X		Link(NextDown(link), tmp);
X		Link(tmp, NextUp(clink));
X		Link(NextDown(dlink), t);
X		Link(tmp, t);
X	      }
X	    }
X	    DeleteLink(dlink);
X	    assert(Up(y)==LastUp(y), "SizeGalley COL_THR: Up(y) != LastUp(y)!");
X	    DisposeChild(Up(y));
X	    link = PrevDown(link);
X	  }
X	  break;
X
X
X	case CLOSURE:
X	case HEAD:
X	  
X	  external(y) = TRUE;
X	  break;
X
X
X	default:
X	  
X	  break;
X      }
X    }
X  }
X
X  /* size the rows of hd and attach indices where needed */
X  debug0(DGM, DD, "SizeGalley sizing rows of hd =");
X  ifdebug(DGM, DD, DebugObject(hd));
X  *recs = *inners = *dest_index = nil;
X  for( link = Down(hd);  link != hd;  link = NextDown(link) )
X  { Child(y, link);
X    if( type(y) == GAP_OBJ || is_index(type(y)) )  continue;
X    debug0(DGM, DDD, "  ROW sizing:");
X    ifdebug(DGM, DDD, DebugObject(y));
X    extras = New(ACAT);
X    y = MinSize(y, ROW, &extras);
X    debug3(DSF, D, "MinSize( %s , ROW ) = %s,%s", EchoObject(y),
X	  EchoLength(back(y, ROW)), EchoLength(fwd(y, ROW)) );
X    debug0(DGM, DDD, "  ROW result:");
X    ifdebug(DGM, DDD, DebugObject(y));
X
X    /* now attach indexes in front of y */
X    for( zlink = Down(extras);  zlink != extras;  zlink = NextDown(zlink) )
X    { Child(z, zlink);
X      blocked(z) = FALSE;
X      /* debug1(DCR, D, "  extra: %s", EchoObject(z)); */
X      debug1(DGM, DD, "  extra: %s", EchoObject(z));
X      switch( type(z) )
X      {
X	case RECEPTIVE:
X
X	  /* debug2(DCR, D, "  ... uses_ext  = %s, trig = %s",
X	    bool(uses_extern_target(actual(actual(z)))), bool(trig)); */
X	  trigger_externs(z) = uses_extern_target(actual(actual(z))) && trig;
X	  non_blocking(z)    = nonblock;
X	  if( actual(actual(z)) == GalleySym )  *dest_index = z;
X	  break;
X
X
X	case RECURSIVE:
X
X	  if( *recs == nil )  *recs = New(ACAT);
X	  Link(*recs, z);
X	  break;
X
X
X	case UNATTACHED:
X
X	  if( *inners == nil )  *inners = New(ACAT);
X	  Link(*inners, z);
X	  break;
X
X		
X	case EXPAND_IND:
X	case GALL_PREC:
X	case GALL_FOLL:
X	case GALL_TARG:
X	case CROSS_PREC:
X	case CROSS_FOLL:
X	case CROSS_TARG:
X
X	  debug1(DCR, DD, "  SizeGalley: %s", EchoObject(z));
X	  break;
X
X
X	default:
X	  
X	  Error(INTERN, no_fpos, "SizeGalley: %s", Image(type(z)) );
X	  break;
X
X      }
X    }
X    TransferLinks(Down(extras), extras, link);
X    assert( Down(extras) == extras && Up(extras) == extras, "SizeG: extras!");
X    Dispose(extras);
X  }
X  
X  /* insinuate cross references */
X  if( crs != nil )
X  { 
X    debug1(DCR, D, "SizeGalley insinuating %s", crs);
X    TransferLinks(Down(crs), crs, Down(hd));
X    DisposeObject(crs);
X  }
X
X  /* check that *dest_index was found if it was required, and exit */
X  if( target != nil && *dest_index == nil )
X    Error(FATAL, &fpos(hd), "Unexpected absence of %s from the body of %s",
X      SymName(target), SymName(actual(hd)));
X  debug3(DGM, D, "SizeGalley returning %s,%s  %s;  hd =",
X    EchoLength(back(hd, COL)), EchoLength(fwd(hd, COL)),
X    EchoConstraint(&constraint(hd)));
X  ifdebug(DGM, DD, DebugObject(hd));
X  sized(hd) = TRUE;
X
X} /* end SizeGalley */
END_OF_FILE
  if test 10803 -ne `wc -c <'z21.c'`; then
    echo shar: \"'z21.c'\" unpacked with wrong size!
  fi
  # end of 'z21.c'
fi
if test -f 'z26.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z26.c'\"
else
  echo shar: Extracting \"'z26.c'\" \(11364 characters\)
  sed "s/^X//" >'z26.c' <<'END_OF_FILE'
X/*@z26.c:Echo Service:BeginString()@******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z26.c                                                      */
X/*  MODULE:       Echo Service                                               */
X/*  EXTERNS:      BeginString(), AppendString(), EndString(),                */
X/*                EchoLength(), Image()                                      */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X#if DEBUG_ON
X#define	MULTI	  7			/* max no of simultaneous calls      */
X
Xstatic	FULL_CHAR buff[MULTI][MAX_LINE];/* buffers for strings       */
Xstatic	int	curr = 1;		/* current buffer in use             */
Xstatic	int	bp;			/* next free space in buff[curr]     */
Xstatic	BOOLEAN	instring = FALSE;	/* TRUE while making a string        */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BeginString()                                                            */
X/*                                                                           */
X/*  Locate a clear buffer into which debug output may be accumulated.        */
X/*                                                                           */
X/*****************************************************************************/
X
XBeginString()
X{ if( instring ) Error(INTERN, no_fpos, "BeginString: currently in string!");
X  instring = TRUE;  curr = (curr + 1) % MULTI;
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  StringCopy(buff[curr], "");  bp = 0;
X}
X
X
X/*@::AppendString(), EndString(), EchoLength()@*******************************/
X/*                                                                           */
X/*  AppendString(str, p1, p2, p3, p4, p5, p6)                                */
X/*                                                                           */
X/*  Sprintf str to the current buffer, if space is available there.          */
X/*                                                                           */
X/*****************************************************************************/
X
X/*VARARGS1*/
XAppendString(str, p1, p2, p3, p4, p5, p6)
XFULL_CHAR *str;  int p1, p2, p3, p4, p5, p6;
X{ int len;
X  if( !instring ) Error(INTERN, no_fpos, "AppendString: no current string!");
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  if( bp == MAX_LINE ) return;		/* no space, do nothing */
X
X  len = StringLength(str);
X  if( len + bp >= MAX_LINE )
X  { StringCopy( &buff[curr][MAX_LINE/2], AsciiToFull(" ... <too long>") );
X    bp = MAX_LINE;
X  }
X  else
X  { sprintf( (char *) &buff[curr][bp], str, p1, p2, p3, p4, p5, p6 );
X    while( buff[curr][bp] != '\0' )  bp++;
X    if( bp >= MAX_LINE )  Error(INTERN, no_fpos, "AppendString abort");
X  }
X} /* end AppendString */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *EndString()                                                   */
X/*                                                                           */
X/*  Return the string constructed by previous AppendString operations.       */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *EndString()
X{ if( !instring ) Error(INTERN, no_fpos, "EndString: no current string!");
X  assert( 0 <= curr && curr < MULTI, "BeginString: curr!" );
X  instring = FALSE;
X  return buff[curr];
X} /* end Endstring */
X#endif
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *EchoLength(len)                                               */
X/*                                                                           */
X/*  Echo a length.                                                           */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *EchoLength(len)
Xint len;
X{ static FULL_CHAR buff[6][20];
X  static int i = 0;
X  i = (i + 1) % 6;
X  sprintf( (char *) buff[i], "%.3fc", (float) len/CM);
X  return buff[i];
X} /* end EchoLength */
X
X
X/*@::Image()@*****************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *Image(c)                                                      */
X/*                                                                           */
X/*  Returns the string value of type c.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *Image(c)
Xunsigned int c;
X{ static FULL_CHAR b[20];
X  switch(c)
X  {
X
X    case LINK:		return  AsciiToFull("link");
X
X    case SPLIT:		return  AsciiToFull("split");
X    case HEAD:		return  AsciiToFull("head");
X    case PAR:		return  AsciiToFull("par");
X    case WORD:		return  AsciiToFull("word");
X    case QWORD:		return  AsciiToFull("qword");
X    case GAP_OBJ:	return  AsciiToFull("gap_obj");
X    case ROW_THR:	return  AsciiToFull("row_thr");
X    case COL_THR:	return  AsciiToFull("col_thr");
X    case CLOSURE:	return  AsciiToFull("closure");
X    case NULL_CLOS:	return  KW_NULL;
X    case CROSS:		return  KW_CROSS;
X    case ONE_COL:	return  KW_ONE_COL;
X    case ONE_ROW:	return  KW_ONE_ROW;
X    case WIDE:		return  KW_WIDE;
X    case HIGH:		return  KW_HIGH;
X    case HSCALE:	return  KW_HSCALE;
X    case VSCALE:	return  KW_VSCALE;
X    case HCONTRACT:	return  KW_HCONTRACT;
X    case VCONTRACT:	return  KW_VCONTRACT;
X    case HEXPAND:	return  KW_HEXPAND;
X    case VEXPAND:	return  KW_VEXPAND;
X    case PADJUST:	return  KW_PADJUST;
X    case HADJUST:	return  KW_HADJUST;
X    case VADJUST:	return  KW_VADJUST;
X    case ROTATE:	return  KW_ROTATE;
X    case SCALE:		return  KW_SCALE;
X    case CASE:		return  KW_CASE;
X    case YIELD:		return  KW_YIELD;
X    case XCHAR:		return  KW_XCHAR;
X    case FONT:		return  KW_FONT;
X    case SPACE:		return  KW_SPACE;
X    case BREAK:		return  KW_BREAK;
X    case NEXT:		return  KW_NEXT;
X    case ENV:		return  KW_ENV;
X    case CLOS:		return  KW_CLOS;
X    case LVIS:		return  KW_LVIS;
X    case OPEN:		return  KW_OPEN;
X    case TAGGED:	return  KW_TAGGED;
X    case INCGRAPHIC:	return  KW_INCGRAPHIC;
X    case SINCGRAPHIC:	return  KW_SINCGRAPHIC;
X    case GRAPHIC:	return  KW_GRAPHIC;
X    case ACAT:		return  AsciiToFull("acat");
X    case HCAT:		return  AsciiToFull("hcat");
X    case VCAT:		return  AsciiToFull("vcat");
X
X    case TSPACE:	return  AsciiToFull("tspace");
X    case TJUXTA:	return  AsciiToFull("tjuxta");
X    case LBR:		return  AsciiToFull("lbr");
X    case RBR:		return  AsciiToFull("rbr");
X    case BEGIN:		return  KW_BEGIN;
X    case END:		return  KW_END;
X    case USE:		return  KW_USE;
X    case GSTUB_NONE:	return  AsciiToFull("gstub_none");
X    case GSTUB_INT:	return  AsciiToFull("gstub_int");
X    case GSTUB_EXT:	return  AsciiToFull("gstub_ext");
X    case INCLUDE:	return  KW_INCLUDE;
X    case SYS_INCLUDE:	return  KW_SYSINCLUDE;
X    case PREPEND:	return  KW_PREPEND;
X    case SYS_PREPEND:	return  KW_SYSPREPEND;
X    case DATABASE:	return  KW_DATABASE;
X    case SYS_DATABASE:	return  KW_SYSDATABASE;
X    case START:	 	return  AsciiToFull("start");
X
X    case DEAD:		return  AsciiToFull("dead");
X    case UNATTACHED:	return  AsciiToFull("unattached");
X    case RECEPTIVE:	return  AsciiToFull("receptive");
X    case RECEIVING:	return  AsciiToFull("receiving");
X    case RECURSIVE:	return  AsciiToFull("recursive");
X    case PRECEDES:	return  AsciiToFull("precedes");
X    case FOLLOWS:	return  AsciiToFull("follows");
X    case CROSS_FOLL:	return  AsciiToFull("cross_foll");
X    case GALL_FOLL:	return  AsciiToFull("gall_foll");
X    case CROSS_TARG:	return  AsciiToFull("cross_targ");
X    case GALL_TARG:	return  AsciiToFull("gall_targ");
X    case GALL_PREC:	return  AsciiToFull("gall_prec");
X    case CROSS_PREC:	return  AsciiToFull("cross_prec");
X    case EXPAND_IND:	return  AsciiToFull("expand_ind");
X    case THREAD:	return  AsciiToFull("thread");
X    case CROSS_SYM:	return  AsciiToFull("cross_sym");
X    case CR_ROOT:	return  AsciiToFull("cr_root");
X    case MACRO:		return  KW_MACRO;
X    case LOCAL:		return  AsciiToFull("local");
X    case LPAR:		return  AsciiToFull("lpar");
X    case NPAR:		return  AsciiToFull("npar");
X    case RPAR:		return  AsciiToFull("rpar");
X    case CR_LIST:	return  AsciiToFull("cr_list");
X    case EXT_GALL:	return  AsciiToFull("ext_gall");
X    case DISPOSED:	return  AsciiToFull("disposed");
X
X    case BACK:		return  AsciiToFull("back");
X    case ON:		return  AsciiToFull("on");
X    case FWD:		return  AsciiToFull("fwd");
X
X    case PROMOTE:	return  AsciiToFull("promote");
X    case CLOSE:		return  AsciiToFull("close");
X    case BLOCK:		return  AsciiToFull("block");
X    case CLEAR:		return  AsciiToFull("clear");
X
X    case GAP_ABS:	return  AsciiToFull("abs");
X    case GAP_INC:	return  AsciiToFull("inc");
X    case GAP_DEC:	return  AsciiToFull("dec");
X
X    default:		sprintf( (char *) b, "??(%d)", c);
X			return b;
X  } /* end switch */
X} /* end Image */
END_OF_FILE
  if test 11364 -ne `wc -c <'z26.c'`; then
    echo shar: \"'z26.c'\" unpacked with wrong size!
  fi
  # end of 'z26.c'
fi
if test -f 'z39.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z39.c'\"
else
  echo shar: Extracting \"'z39.c'\" \(10885 characters\)
  sed "s/^X//" >'z39.c' <<'END_OF_FILE'
X/*@z39.c:String Handler:AsciiToFull(), StringEqual(), etc.@*******************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z39.c                                                      */
X/*  MODULE:       String Handler                                             */
X/*  EXTERNS:      AsciiToFull(), StringEqual(), StringLessEqual(),           */
X/*                StringCat(), StringCopy(), StringLength(),                 */
X/*                StringFOpen(), StringFPuts(), StringFGets(),               */
X/*                StringUnlink(), StringLink(), StringBeginsWith(),          */
X/*                StringContains(), StringInt(), StringFiveInt(),            */
X/*                StringQuotedWord()                                         */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*          AsciiToFull(str)          Returns ASCII string as FULL_CHARs.    */
X/*  BOOLEAN StringEqual(a, b)         TRUE if strings a and b are equal      */
X/*  BOOLEAN StringLessEqual(a, b)     TRUE if string a <= string b           */
X/*          StringCat(a, b)           Catenate string b onto end of a        */
X/*          StringCopy(a, b)          Overwrite string a with string b       */
X/*          StringLength(a)           Length of string a                     */
X/*          StringFOpen(str, mode)    Equivalent to fopen(str, mode)         */
X/*          StringFPuts(str, fp)      Equivalent to fputs(str, fp)           */
X/*          StringFGets(str, n, fp)   Equivalent to fgets(str, n, fp)        */
X/*          StringUnlink(a)           Equivalent to unlink(a)                */
X/*          StringLink(a, b)          Equivalent to link(a, b)               */
X/*                                                                           */
X/*  These procedures are defined as macros in file externs.                  */
X/*                                                                           */
X/*****************************************************************************/
X
X
X/*@::StringBeginsWith(), StringContains(), StringInt(), StringFiveInt()@******/
X/*                                                                           */
X/*  BOOLEAN StringBeginsWith(str, pattern)                                   */
X/*                                                                           */
X/*  Check whether str begins with pattern.                                   */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN StringBeginsWith(str, pattern)
XFULL_CHAR *str, *pattern;
X{ FULL_CHAR *sp, *pp;
X  sp = str;  pp = pattern;
X  while( *sp != '\0' && *pp != '\0' )
X  { if( *sp++ != *pp++ )  return FALSE;
X  }
X  return (*pp == '\0');
X} /* end StringBeginsWith */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN StringContains(str, pattern)                                     */
X/*                                                                           */
X/*  Check whether str contains pattern.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN StringContains(str, pattern)
XFULL_CHAR *str, *pattern;
X{ FULL_CHAR *sp;
X  for( sp = str;  *sp != '\0';  sp++ )
X  { if( StringBeginsWith(sp, pattern) )  return TRUE;
X  }
X  return FALSE;
X} /* end StringContains */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *StringInt(i)                                                  */
X/*  FULL_CHAR *StringFiveInt(i)                                              */
X/*                                                                           */
X/*  Returns a string version of integer i.                                   */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *StringInt(i)
Xint i;
X{ static FULL_CHAR buff[20];
X  sprintf( (char *) buff, "%d", i);
X  return buff;
X} /* end StringInt */
X
XFULL_CHAR *StringFiveInt(i)
Xint i;
X{ static FULL_CHAR buff[20];
X  sprintf( (char *) buff, "%.5d", i);
X  return buff;
X} /* end StringInt */
X
X
X/*@::StringQuotedWord()@******************************************************/
X/*                                                                           */
X/*  static char *quoted_string[]                                             */
X/*                                                                           */
X/*  quoted_string[ch] is a string containing the representation of the       */
X/*  8-bit character ch within a quoted string in a Lout source file.         */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic char *quoted_string[] = {
X    "\\000", "\\001", "\\002", "\\003", "\\004", "\\005", "\\006", "\\007",
X    "\\010", "\\011", "\\012", "\\013", "\\014", "\\015", "\\016", "\\017",
X    "\\020", "\\021", "\\022", "\\023", "\\024", "\\025", "\\026", "\\027",
X    "\\030", "\\031", "\\032", "\\033", "\\034", "\\035", "\\036", "\\037",
X    " ",     "!",     "\\\"",  "#",     "$",     "%",     "&",     "'",
X    "(",     ")",     "*",     "+",     ",",     "-",     ".",     "/",
X    "0",     "1",     "2",     "3",     "4",     "5",     "6",     "7",
X    "8",     "9",     ":",     ";",     "<",     "=",     ">",     "?",
X
X    "@",     "A",     "B",     "C",     "D",     "E",     "F",     "G",
X    "H",     "I",     "J",     "K",     "L",     "M",     "N",     "O",
X    "P",     "Q",     "R",     "S",     "T",     "U",     "V",     "W",
X    "X",     "Y",     "Z",     "[",     "\\\\",  "]",     "^",     "_",
X    "`",     "a",     "b",     "c",     "d",     "e",     "f",     "g",
X    "h",     "i",     "j",     "k",     "l",     "m",     "n",     "o",
X    "p",     "q",     "r",     "s",     "t",     "u",     "v",     "w",
X    "x",     "y",     "z",     "{",     "|",     "}",     "~",     "\\177",
X
X    "\\200", "\\201", "\\202", "\\203", "\\204", "\\205", "\\206", "\\207",
X    "\\210", "\\211", "\\212", "\\213", "\\214", "\\215", "\\216", "\\217",
X    "\\220", "\\221", "\\222", "\\223", "\\224", "\\225", "\\226", "\\227",
X    "\\230", "\\231", "\\232", "\\233", "\\234", "\\235", "\\236", "\\237",
X    "\\240", "\\241", "\\242", "\\243", "\\244", "\\245", "\\246", "\\247",
X    "\\250", "\\251", "\\252", "\\253", "\\254", "\\255", "\\256", "\\257",
X    "\\260", "\\261", "\\262", "\\263", "\\264", "\\265", "\\266", "\\267",
X    "\\270", "\\271", "\\272", "\\273", "\\274", "\\275", "\\276", "\\277",
X
X    "\\300", "\\301", "\\302", "\\303", "\\304", "\\305", "\\306", "\\307",
X    "\\310", "\\311", "\\312", "\\313", "\\314", "\\315", "\\316", "\\317",
X    "\\320", "\\321", "\\322", "\\323", "\\324", "\\325", "\\326", "\\327",
X    "\\330", "\\331", "\\332", "\\333", "\\334", "\\335", "\\336", "\\337",
X    "\\340", "\\341", "\\342", "\\343", "\\344", "\\345", "\\346", "\\347",
X    "\\350", "\\351", "\\352", "\\353", "\\354", "\\355", "\\356", "\\357",
X    "\\360", "\\361", "\\362", "\\363", "\\364", "\\365", "\\366", "\\367",
X    "\\370", "\\371", "\\372", "\\373", "\\374", "\\375", "\\376", "\\377",
X};
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *StringQuotedWord(x)                                           */
X/*                                                                           */
X/*  Returns the string in QWORD x in the form it would need to take if it    */
X/*  was a quoted word in a Lout source file.  Note that the result is        */
X/*  returned in a static variable so it needs to be copied before a          */
X/*  subsequent call to StringQuotedWord is made.                             */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *StringQuotedWord(x)
XOBJECT x;
X{ FULL_CHAR *p, *q, *r;
X  static FULL_CHAR buff[MAX_LINE];
X  assert( type(x) == QWORD, "StringQuotedWord: type(x) != QWORD!" );
X  q = buff;
X  *q++ = CH_QUOTE;
X  for( p = string(x);  *p != '\0';  p++ )
X  { 
X    for( r = (FULL_CHAR *) quoted_string[*p];  *r != '\0';  *q++ = *r++ );
X  }
X  *q++ = CH_QUOTE;
X  *q++ = '\0';
X  return buff;
X} /* StringQuotedWord */
END_OF_FILE
  if test 10885 -ne `wc -c <'z39.c'`; then
    echo shar: \"'z39.c'\" unpacked with wrong size!
  fi
  # end of 'z39.c'
fi
echo shar: End of archive 27 \(of 35\).
cp /dev/null ark27isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
