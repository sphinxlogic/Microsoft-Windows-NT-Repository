Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i101:  lout - Lout document formatting system, v2.05, Part33/35
Message-ID: <1993Aug10.132454.19425@sparky.sterling.com>
X-Md4-Signature: 65f537c679ed9f818f89203b800281c7
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 13:24:54 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 101
Archive-name: lout/part33
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  doc/tr.begin/s04 doc/tr.begin/s05 doc/tr.begin/s11
#   doc/tr.begin/s12 doc/tr.begin/s13 doc/tr.eq/s3 doc/tr.impl/s2.2
#   doc/tr.impl/s3.1 doc/tr.impl/s3.4 doc/tr.lout/ch0.00
#   doc/tr.lout/ch2.02 doc/tr.lout/ch2.03 doc/tr.lout/ch2.04
#   doc/tr.over/s6 doc/tr.over/setup doc/tr.tab/s1 doc/tr.tab/s3
#   evec/LoutLatin1.CEV evec/README evec/Symb.CEV evec/null.dec
#   evec/null.oct hyph.install news.blurb
# Wrapped by kent@sparky on Sun Aug  8 12:29:34 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 33 (of 35)."'
if test -f 'doc/tr.begin/s04' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s04'\"
else
  echo shar: Extracting \"'doc/tr.begin/s04'\" \(3184 characters\)
  sed "s/^X//" >'doc/tr.begin/s04' <<'END_OF_FILE'
X@Section
X   @Tag { fonts }
X   @Title { Fonts and unusual characters }
X@Begin
X@PP
XThis section explains how to gain access to the many different fonts and
Xunusual characters available with Lout.  We have already seen the
X@Code "@I" symbol, which changes the font of the following thing to
X{@I Italic}.  Similarly, there is @Code "@B" for {@B Bold}, @Code "@S"
Xfor @S SMALL {@S CAPITALS},
X@FootNote {
XOwing to problems behind the scenes, if several words are grouped within one
X@Code "@S" symbol they will be kept together on one line, so to get small
Xcapitals over several lines it is necessary to apply @Code "@S" to each
Xword individually.  This does not happen with other font symbols.
X}
Xand @Code "@R" for Roman.
X@PP
XThe @Code "@Font" symbol can be used to get many other fonts (a local
Xexpert should be able to supply the full list):
X@ID @Code {
X"{ Helvetica Slope } @Font { Hi there }" &0io
X}
Xhas result
X@ID {
X{ Helvetica Slope } @Font { Hi there }
X}
XEach font has a family name, such as Times, Helvetica, or Courier, and a
Xface name, generally Base, Slope, or Bold.  The fonts that were
Xcalled Roman, Italic, and Bold above are Times Base, Times Slope, and
XTimes Bold.  When changing families the new family and a face must be
Xspecified, but when changing face within a family just the face name is
Xenough.
X@PP
XThe @Code "@Font" symbol also changes sizes:
X@ID @Code {
X"+5p @Font Hello"
X"-3p @Font Hello"
X"12p @Font Hello"
X}
Xhas result
X@ID {
X+5p @Font Hello  -3p @Font Hello  12p @Font Hello
X}
Xwith the first Hello 5 points larger than it would have been otherwise,
Xthe second 3 points smaller, and the third in a 12 point font.  There are
X72 points to one inch, and most documents are set in 10 or 12 point.
X@PP
XThere are symbols for some unusual characters that do not appear
Xon keyboards:
X@ID @Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col @Code A ! @Col B }
X{
X    @Rowa A { "``"		}  B {	``		}
X    @Rowa A { "''"		}  B {	''		}
X    @Rowa A { "--"		}  B {	--		}
X    @Rowa A { "---"		}  B {	---		}
X    @Rowa A { "@Bullet"		}  B {	@Bullet		}
X    @Rowa A { "@Star"		}  B {	@Star		}
X    @Rowa A { "@ParSym"		}  B {	@ParSym		}
X    @Rowa A { "@SectSym"	}  B {	@SectSym	}
X    @Rowa A { "@Dagger"		}  B {	@Dagger		}
X    @Rowa A { "@DaggerDbl"	}  B {	@DaggerDbl	}
X    @Rowa A { "@CDot"		}  B {	@CDot		}
X    @Rowa A { "@Sterling"	}  B {	@Sterling	}
X    @Rowa A { "@Yen"		}  B {	@Yen		}
X    @Rowa A { "@Florin"		}  B {	@Florin		}
X    @Rowa A { "@Degree"		}  B {	@Degree		}
X    @Rowa A { "@Minute"		}  B {	@Minute		}
X    @Rowa A { "@Second"		}  B {	@Second		}
X    @Rowa A { "@Lozenge"	}  B {	@Lozenge	}
X    @Rowa A { "@Multiply"	}  B {	@Multiply	}
X    @Rowa A { "@Divide"		}  B {	@Divide		}
X    @Rowa A { "@CopyRight"	}  B {	@CopyRight	}
X    @Rowa A { "@Register"	}  B {	@Register	}
X    @Rowa A { "@TradeMark"	}  B {	@TradeMark	}
X    @Rowa A { "@Date"		}  B {	@Date		}
X}
XThese may be used anywhere.  The Adobe Systems Symbol font has many more such
Xcharacters; the Eq equation formatting package [{@Ref kingston92eq}] has
Xthe complete list.  For example, @Code "@Eq { heart }" will give
X@Eq { heart }.  Accented characters are also available (see Appendix
X{@NumberOf accented}).
X@End @Section
END_OF_FILE
  if test 3184 -ne `wc -c <'doc/tr.begin/s04'`; then
    echo shar: \"'doc/tr.begin/s04'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s04'
fi
if test -f 'doc/tr.begin/s05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s05'\"
else
  echo shar: Extracting \"'doc/tr.begin/s05'\" \(2787 characters\)
  sed "s/^X//" >'doc/tr.begin/s05' <<'END_OF_FILE'
X@Section
X   @Tag { paras }
X   @Title { Paragraph breaking }
X@Begin
X@PP
XLout takes the words or other things making up a paragraph and fills
Xlines with them.  If two words are separated by one space in the input,
Xthey will be separated by one space in the output; two spaces in, two
Xspaces out, and so on.  The end of a line counts as one space, and a tab
Xcharacter as eight.  These spaces are then enlarged to remove ragged line ends.
X@PP
XThis process is called @I paragraph {@I breaking}, and the enlargement
Xof spaces is @I {line adjustment.}  The @Code "@Break" symbol, which is
Xmost commonly used with displays and list items, affects paragraph
Xbreaking:
X@ID @Code {
X"@IndentedDisplay ragged @Break {"
X"This little paragraph will appear with"
X"ragged ends to its lines. }"
X}
Xhas result
X@IndentedDisplay 4c @Wide ragged @Break {
XThis little paragraph will appear with
Xragged ends to its lines.
X}
Xwhen placed in a four centimetre column; line adjustment is turned
Xoff.  Also available are @Code "cragged @Break" and {@Code "rragged @Break"},
Xwhich centre or right-justify each line respectively after breaking.
X@PP
XIt is also possible to have paragraphs broken in the output at the same
Xplaces they are broken in the input, using { @Code "lines @Break" }:
X@ID @Code {
X"@CenteredDisplay lines @Break @I {"
X"Teach me to hear Mermaides singing,"
X"Or to keep off envies stinging,"
X"     And finde"
X"     What winde"
X"Serves to'advance an honest minde."
X"}"
X}
Xhas result
X@CenteredDisplay lines @Break @I {
XTeach me to hear Mermaides singing,
XOr to keep off envies stinging,
X     And finde
X     What winde
XServes to'advance an honest minde.
X}
XWith @Code "lines @Break" it makes sense to indent individual lines in the
Xinput (except the first), as shown.  To centre or right-justify each line, use
X{@Code "clines @Break"} or {@PageMark clines} {@Code "rlines @Break"}.
X@PP
XThe usual method, where Lout fills and adjusts lines, is called
X{@Code "adjust @Break"}.  It has a variant called {@Code "outdent @Break"}
Xwhich inserts a small space at the beginning of each line except the first.
X@PP
XThe @Code "@Break" symbol also controls hyphenation:  @Code "hyphen"
X@Code "@Break" turns it on, @Code "nohyphen" @Code "@Break" turns it
Xoff.  For example, ragged breaking is often done without hyphenation,
Xlike this:
X@ID @Code {
X"@ID { ragged nohyphen } @Break {"
X"This little paragraph will appear with"
X"ragged ends to its lines."
X"}"
X}
XTo prevent hyphenation in the entire document, see Section
X{@NumberOf changes}.  To tell Lout where you would prefer a hyphen to be 
Xinserted (rarely necessary), use the @Code "&-" symbol:
X@ID @Code {
X"incent&-iv&-ate"
X}
XIf @Code "&-" occurs directly after a hyphen character, hyphenation will
Xbe permitted but no extra hyphen will be inserted.
X@End @Section
END_OF_FILE
  if test 2787 -ne `wc -c <'doc/tr.begin/s05'`; then
    echo shar: \"'doc/tr.begin/s05'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s05'
fi
if test -f 'doc/tr.begin/s11' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s11'\"
else
  echo shar: Extracting \"'doc/tr.begin/s11'\" \(953 characters\)
  sed "s/^X//" >'doc/tr.begin/s11' <<'END_OF_FILE'
X@Section
X   @Tag { cols }
X   @Title { Multiple columns }
X@Begin
X@PP
XDocumentLayout normally produces pages with a single column of text occupying
Xthe full width.  To get multiple columns, enclose the document in
X@ID @Code {
X"@Doc @ColText @Begin"
X"..."
X"@End @ColText"
X}
XThis will ordinarily produce two columns per page, although we will see
Xin the next section how to produce three or more.
X@PP
XIt is possible to start off a document with single columns and switch to
Xmultiple columns later, using the following arrangement:
X@ID @Code {
X"@Doc @Text @Begin"
X"single column part"
X"@ColText @Begin"
X"multiple column part"
X"@End @ColText"
X"@End @Text"
X}
XThis is the most useful combination, because switching from multiple back to
Xsingle causes a new page to be begun, which generally looks poor.  Tables
Xand figures are always full width, but the width of footnotes depends on
Xwhether they occur within @Code "@Text" or {@Code "@ColText"}.
X@End @Section
END_OF_FILE
  if test 953 -ne `wc -c <'doc/tr.begin/s11'`; then
    echo shar: \"'doc/tr.begin/s11'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s11'
fi
if test -f 'doc/tr.begin/s12' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s12'\"
else
  echo shar: Extracting \"'doc/tr.begin/s12'\" \(2068 characters\)
  sed "s/^X//" >'doc/tr.begin/s12' <<'END_OF_FILE'
X@Section
X   @Tag { changes }
X   @Title { Changing the overall appearance }
X@Begin
X@PP
XA few aspects of the overall appearance of the document may be changed
Xby beginning with a @Code "@Document" symbol, as in the following
Xexample:
X@ID @Code {
X"@Document"
X"    @InitialFont { Times Base 12p }"
X"    @InitialBreak { adjust 1.2fx }"
X"    @Hyphenate { Yes }"
X"    @PageNumbers { Yes }"
X"    @FirstPageNumber { 1 }"
X"    @Columns { Double }"
X"//"
X"@Text @Begin"
X"..."
X"@End @Text"
X}
XThis shows the six options available with {@Code "@Document"}, and their
Xdefault values.
X@PP
X@Code "@InitialFont" and @Code "@InitialBreak" determine
Xthe overall font and paragraph breaking style; @Code "1.2fx" means that
Xthe inter-line spacing is to be 1.2 times the current font size, measured
Xfrom baseline to baseline.  To get double spacing, use {@Code "2.4fx"},
Xetc.  @Code "@Hyphenate" determines whether hyphenation is permitted or
Xnot, and may be @Code Yes or {@Code No}.
X@PP
X@Code "@PageNumbers" determines whether or not page numbers will be
Xprinted (but not their format), and also may be @Code Yes or {@Code No};
X@Code "@FirstPageNumber" is the number given to the first page; and
X@Code "@Columns" determines the number of columns that @Code "@ColText"
Xproduces, and may be {@Code Single}, {@Code Double}, or {@Code Multi},
Xthe last usually meaning triple.
X@PP
XSince there are default values for the options, it is only necessary to
Xmention those options that are to be changed.  For example, to produce a
Xdocument in Helvetica 10 point font with no page numbers, begin with
X@ID @Code {
X"@Document"
X"    @InitialFont { Helvetica Base 10p }"
X"    @PageNumbers { No }"
X"//"
X}
XDisaster will ensue if the @Code "//" symbol is forgotten.  The
X@Code "@Doc" symbol used previously is just an abbreviation for
X{@Code "@Document //"}.
X@PP
XOf course, these five options only scratch the surface of the possible
Xchanges that could be made.  Section {@NumberOf big.changes} explains
Xhow to make many other and more radical changes to the overall appearance
Xof the document.
X@End @Section
END_OF_FILE
  if test 2068 -ne `wc -c <'doc/tr.begin/s12'`; then
    echo shar: \"'doc/tr.begin/s12'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s12'
fi
if test -f 'doc/tr.begin/s13' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s13'\"
else
  echo shar: Extracting \"'doc/tr.begin/s13'\" \(2988 characters\)
  sed "s/^X//" >'doc/tr.begin/s13' <<'END_OF_FILE'
X@Section
X   @Tag { reportlayout }
X   @Title { Technical reports }
X@Begin
X@PP
XThis section describes how to use the DocumentLayout package to produce
Xtechnical reports like the present document.  Type @Code "-ireport" in
Xthe Unix command instead of @Code "-idoc" to use the package in this
Xway.  We present only the differences here; everything else works as
Xbefore.
X@PP
XA technical report begins with a @Code "@Report" symbol analogous to the
X@Code "@Document" symbol described in the previous section.  Here it is,
Xwith its nine options and their default values:
X@ID @Code {
X"@Report"
X"    @Title {}"
X"    @Author {}"
X"    @Institution {}"
X"    @DateLine { @Date }"
X"    @InitialFont { Times Base 12p }"
X"    @InitialBreak { adjust 1.2fx }"
X"    @Hyphenate { Yes }"
X"    @PageNumbers { Yes }"
X"    @Columns { Single }"
X"//"
X}
XThe {@Code "@Title"}, {@Code "@Author"}, and {@Code "@Institution"} options
Xwill be printed on the cover sheet and on the first page; they are formatted
Xusing {@Code "clines @Break"} (see page {@PageOf clines}).  Multiple authors
Xshould be given on separate lines within the @Code "@Author"
Xoption.  {@Code "@DateLine"} appears below the abstract on the cover sheet,
Xand its default value is the current date as shown.  {@Code "@InitialFont"},
X{@Code "@InitialBreak"}, {@Code "@Hyphenate"}, {@Code "@PageNumbers"} and
X{@Code "@Columns"} are as described in the last section, except that there
Xis nothing analogous to @Code "@Text" and {@Code "@ColText"}:  if
X@Code "@Columns" is set to {@Code Double}, the entire document after the
Xtitle will be set in two columns.  There is no @Code "@FirstPageNumber"
Xoption.  As for {@Code "@Document"}, the symbol @Code "//" must follow
Xafter, and disaster will ensue if it is omitted.
X@PP
XIf the technical report has an abstract, it comes next:
X@ID @Code {
X"@Abstract @Begin"
X"..."
X"..."
X"@End @Abstract"
X}
XThe cover sheet of the present report shows how this will
Xappear.  @Code "@Abstract" has a @Code "@Title" option like the ones
Xbelow; its default value is {@I ABSTRACT}.
X@PP
XNext come the sections of the report, each enclosed in a @Code
X"@Section" symbol:
X@ID @Code {
X"@Section"
X"    @Title { Introduction }"
X"@Begin"
X"@PP"
X"..."
X"..."
X"@End @Section"
X}
XNo @Code "@BeginSections" or @Code "@EndSections" symbols are needed.
X The sections may contain subsections, preceded as usual by
X@Code "@BeginSubSections" and followed by {@Code "@EndSubSections"}.
X After the sections there is opportunity for a sequence of appendices,
Xeach of the form
X@ID @Code {
X"@Appendix"
X"    @Title { ... }"
X"@Begin"
X"@PP"
X"..."
X"..."
X"@End @Appendix"
X}
Xbut these are quite optional.  No @Code "@BeginAppendices" and
X@Code "@EndAppendices" symbols are needed.  An appendix may contain
Xsub-appendices via the usual symbols {@Code "@BeginSubAppendices"},
X{@Code "@SubAppendix"}, and {@Code "@BeginSubAppendices"}.  This ends
Xthe input; there is no {@Code "@End @Text"}, and any reference section
Xwill be added automatically.
X@End @Section
END_OF_FILE
  if test 2988 -ne `wc -c <'doc/tr.begin/s13'`; then
    echo shar: \"'doc/tr.begin/s13'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s13'
fi
if test -f 'doc/tr.eq/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.eq/s3'\"
else
  echo shar: Extracting \"'doc/tr.eq/s3'\" \(3398 characters\)
  sed "s/^X//" >'doc/tr.eq/s3' <<'END_OF_FILE'
X@Section
X   @Title { Spacing }
X@Begin
X@PP
XThere is a basic rule governing the use of white space characters
X(space, tab, and newline) in the input to Lout:  white space between two
Xobjects affects the result; white space between a symbol and its
Xparameter does not.
X@PP
XAlthough this rule is just right most of the time, it is not adequate
Xfor equation formatting.  Getting the horizontal spacing right in
Xequations is a very fiddly business, involving four different sizes of
Xspace (zero, thin, medium, and thick), and different rules for spacing
Xwithin superscripts and subscripts to those applying outside, according
Xto a leading authority [{@Ref knuth84}].  Eq therefore takes the spacing
Xdecisions upon itself, and con&-sequently chooses to ignore all white
Xspace in its input, even between two objects.
X@FootNote {
XThis effect is produced by enclosing the entire equation in
X{@Code "0c @Space"}.  The simplest way to restore the effect of white
Xspace to part of an equation is to enclose that part in a @Code "@Font"
Xsymbol.  Eq also changes the value of the @Code v unit, so if a paragraph
Xof filled text is desired within an equation, it may be necessary to
Xenclose it in a @Code "@Break" symbol. }
X@PP
XEvery symbol provided by Eq has a {@I {full name}}, which denotes the
Xsymbol without any space attached.  Many symbols also
Xhave a {@I {short name}}, which denotes the same symbol with what Eq
Xconsiders to be an appropriate amount of space for that symbol attached
Xto it.  For example, @Eq { lessequal } has full name @Code lessequal
Xand short name {@Code "<="}:
X@IL
X@LI {
X@Code "a lessequal b"
X|7ct
X@Eq { a lessequal b }
X}
X@LI {
X@Code "a <= b"
X|7ct
X@Eq { a <= b }
X}
X@EL
XEq puts a thick space around relation symbols like {@Code "<="}, a
Xmedium space around binary operator symbols like {@Code "+"}, and a thin
Xspace after punctuation symbols (@Code ";" and {@Code ","}); except
Xthat in places where the symbols appear in a smaller size (superscripts,
Xsubscripts, etc.), these spaces are omitted.  No other horizontal space
Xis ever inserted.
X@PP
XThe short names have been carefully designed to produce good-looking
Xmathematics most of the time.  It is best to rely
Xon them in the first instance and only think about spacing when the result
Xis not pleasing.  In that case, Eq's space can be removed by using the
Xfull names, and thin, medium and thick space can be added using the
Xfollowing symbols:
X@ID @Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col A ! @Col B }
X{
X@Rowa
X  A { @Code "`" }
X  B { {@Code "0.18f"}  ({@Code "0.018f"} in subscripts, etc.) }
X@Rowa
X  A { @Code "``" }
X  B { {@Code "0.24f"}  ({@Code "0.024f"} in subscripts, etc.) }
X@Rowa
X  A { @Code "```" }
X  B { {@Code "0.30f"}  ({@Code "0.030f"} in subscripts, etc.) }
X}
Xwhere @Code "1f" is the current font size.  These symbols have low
Xprecedence.  The @Code "&" symbol from standard Lout is also available;
Xthe @Code "s" unit has value 0 and so is not very useful, but one can
Xwrite @Code "&2m" for example for a two em space.  The full names are
Xtedious to remember, so Eq provides a @Code "non" symbol which removes
Xspaces from its right parameter; thus @Code "non <=" is equivalent to
X{@Code "lessequal"}.  There are also {@Code "rel"}, {@Code "bin"}, and
X{@Code "punct"} symbols for telling Eq to add space to the following symbol as
Xthough it was a relation symbol, binary operator, or punctuation symbol.
X@End @Section
END_OF_FILE
  if test 3398 -ne `wc -c <'doc/tr.eq/s3'`; then
    echo shar: \"'doc/tr.eq/s3'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.eq/s3'
fi
if test -f 'doc/tr.impl/s2.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s2.2'\"
else
  echo shar: Extracting \"'doc/tr.impl/s2.2'\" \(3349 characters\)
  sed "s/^X//" >'doc/tr.impl/s2.2' <<'END_OF_FILE'
X@SubSection
X    @Tag { lexical }
X    @Title { Grammatical and lexical structure }
X@Begin
X@PP
XIf objects are to be constructed like mathematical expressions, the
Xnatural notation is a functional language based on operators, as in
XEqn.  The grammar of Lout objects is accordingly
X@ID @Eq {
Xmatrix {
Xobject
Xnextcol
X--> above --> above --> above --> above --> above --> above --> above -->
Xnextcol
X{ object ``` infixop ``` object }
Xlabove gap { "1fx" }
X{ prefixop ``` object }
Xlabove gap { "1fx" }
X{ object ``` postfixop }
Xlabove gap { "1fx" }
X{ noparsop }
Xlabove gap { "1fx" }
X{ literalword }
Xlabove gap { "1fx" }
X{ @Code "{" ``` object ``` @Code "}" }
Xlabove gap { "1fx" }
X{ object ``` object }
Xlabove gap { "1fx" }
X}
X}
Xwhere {@Eq {infixop}}, {@Eq {prefixop}}, {@Eq {postfixop}}, and
X{@Eq {noparsop}} are identifiers naming operators which take 0, 1
Xor 2 parameters, as shown, and @Eq {literalword} is a sequence of
Xnon-space characters, or an arbitrary sequence of characters
Xenclosed in double quotes.  Ambiguities are resolved by precedence
Xand associativity.
X@PP
XThe last production allows a meaning for expressions such as
X{@Code "{}"}, in which an object is missing.  The value of this
X@I {empty object} is a rectangle of size 0 by 0, with one column
Xmark and one row mark, that prints as nothing.
X@PP
XThe second-last production generates sequences of arbitrary objects
Xseparated by white space, called {@I paragraphs}.  Ignoring
Xparagraph breaking for now, the natural meaning is that the two
Xobjects should appear side by side, and Lout's parser accordingly
Xinterpolates an infix horizontal concatenation operator (see below)
Xbetween them.  This operator is associative, so the grammatical
Xambiguity does no harm.  However, the Algol-60 rule that white space
Xshould be significant only as a separator is necessarily broken by
XLout in just this one place.
X@PP
XAlgol-like languages distinguish literal strings from identifiers by
Xenclosing them in quotes, but literals are far too frequent in document
Xformatting for this to be viable.  The conventional solution is to
Xbegin identifiers with a special character, and Lout follows Scribe
X[7] in using "`@'" rather than the "`\\'" of troff
X[8] and @TeX [9].
X@PP
XHowever, Lout takes the unusual step of making an initial "`@'"
Xoptional.  The designers of Eqn apparently considered such
Xcharacters disfiguring in fine-grained input like equations, and
Xthis author agrees.  The implementation is straightforward:  "`@'" is
Xclassed as just another letter, and every word is searched for in
Xthe symbol table.  If it is found, it is an identifier, otherwise it
Xis a literal.  A warning message is printed when a literal beginning
Xwith "`@'" is found, since it is probably a mis-spelt identifier.  No
Xsuch safety net is possible for identifiers without "`@'".
X@PP
XEquation formatting also demands symbols made from punctuation
Xcharacters, such as @Code "+" and {@Code "<="}.  It is traditional to
Xallow such symbols to be juxtaposed, which means that the input
X@ID @Code "<=++"
Xfor example must be interpreted within the lexical analyser by searching
Xthe symbol table for its prefixes in the order {@Code "<=++"},
X{@Code "<=+"}, {@Code "<="}.  Although this takes quadratic time, in
Xpractice such sequences are too short to make a more sophisticated
Xlinear method like tries worthwhile.
X@End @SubSection
END_OF_FILE
  if test 3349 -ne `wc -c <'doc/tr.impl/s2.2'`; then
    echo shar: \"'doc/tr.impl/s2.2'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s2.2'
fi
if test -f 'doc/tr.impl/s3.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s3.1'\"
else
  echo shar: Extracting \"'doc/tr.impl/s3.1'\" \(2778 characters\)
  sed "s/^X//" >'doc/tr.impl/s3.1' <<'END_OF_FILE'
X@SubSection
X    @Tag { operators }
X    @Title { Operators }
X@Begin
X@PP
XIt is evident from the example of Eqn that user-defined operators are
Xneeded that mimic the primitive ones in taking objects as parameters
Xand returning objects as results.  For example, to define a superscript
Xoperator so that
X@ID @Code "2 sup n"
Xappears as {@Eq {2 sup @R n}}, the following operator definition may
Xbe used:
X@ID @Code {
X"def sup"
X"    precedence 50"
X"    associativity right"
X"    left x"
X"    right y"
X"{"
X"    @OneRow {  |  {-2p @Font y}  ^/0.5fk  x  }"
X"}"
X}
XThe @Code "sup" operator has precedence 50, is right associative, takes
Xtwo objects as parameters passed on the left and right, and returns the
Xobject between braces as result.  This object has the structure
X@ID @I +2p @Font {
X| @ShowMarks @Code y / @ShowMarks @Code x
X}
Xbut with the first row mark hidden by the @Code "@OneRow" operator,
Xand @Code y two points smaller than it would otherwise have been.  The
Xlength @Code "0.5f" specifies half the current font size;  Figure
X{@NumberOf gapmodes} describes the @Code k gap mode.  In the Eq equation
Xformatting package [10] the equation as a whole is
Xset in italic font, and @Code 2 is an identifier whose body contains
Xa font change back to Roman.  The digits @Code 0 to @Code 9 are classed
Xas punctuation characters, permitting @Code 234 for example to be
Xinterpreted as a sequence of three identifiers.
X@PP
XThese definitions are easily implemented by a standard symbol table
Xand an operator precedence parser.  Algol block structure with the
Xusual scope rules was adopted as a matter of course.
X@PP
XOperators are limited to at most two parameters, left and
Xright, and the parameters cannot be given default values.  @I Named
Xparameters solve both problems:
X@ID @Code {
X"def @Preface"
X"    named @Tag {}"
X"    named @Title { Preface }"
X"    right @Body"
X"{"
X"    Bold @Font @Title"
X"    //0.3v  @Body"
X"}"
X}
XThe default value appears just after the parameter's declaration,
Xbetween braces.  Invocations have a natural syntax:
X@ID @Code {
X"@Preface"
X"    @Title { About this book }"
X"{"
X"    Few observers would have supposed in 1984, that ..."
X"}"
X}
Xwith the actual named parameters following directly after the
Xoperator, before any right parameter.  In this example, @Code "@Tag"
Xwill receive its default value, and a less expert user could safely
Xomit the @Code "@Title" parameter as well.
X@PP
XLout permits named parameters to have parameters, a feature with
Xapplications to bibliographic databases, running headers, and other
Xplaces where a format has to be supplied before content is
Xknown.  One could go further and provide a complete lambda calculus,
Xwith functions as first-class objects, provided care was taken not
Xto intimidate the non-expert user.
X@End @SubSection
END_OF_FILE
  if test 2778 -ne `wc -c <'doc/tr.impl/s3.1'`; then
    echo shar: \"'doc/tr.impl/s3.1'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s3.1'
fi
if test -f 'doc/tr.impl/s3.4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s3.4'\"
else
  echo shar: Extracting \"'doc/tr.impl/s3.4'\" \(2778 characters\)
  sed "s/^X//" >'doc/tr.impl/s3.4' <<'END_OF_FILE'
X@SubSection
X    @Tag { defs.impl }
X    @Title { Implementation of definitions }
X@Begin
X@PP
XInput is processed by a hybrid parser which employs operator precedence
Xfor objects and simple recursive descent for the headers of
Xdefinitions.  A symbol table stores the body of each definition as a
Xparse tree, except for macros which are lists of tokens, and manages the
Xusual stack of static scopes, accepting @I PushScope and @I PopScope
Xoperations as the parser enters and leaves scope regions, including
Xactual body parameters and the right parameter of the @Code "@Open"
Xoperator.
X@PP
XAs the parse proceeds, a complete call graph is constructed, recording,
Xfor each symbol, which symbols are invoked within its body.  Immediately
Xafter the last definition is read, the transitive closure of the call
Xgraph is computed, and used to determine whether each non-parameter
Xsymbol is recursive or receptive (Section {@NumberOf galleys}), and
Xwhether each parameter is invoked exactly once or not.
X@PP
XPurely functional systems may evaluate symbol invocations in applicative
Xorder (where parameters are evaluated before substitution into bodies),
Xor in normal order (substitution before evaluation), and they may also
Xshare the value of a parameter among all uses of it.  But in Basser
XLout, the presence of context-sensitive style information (Section
X{@NumberOf style}) forces normal order evaluation and prevents sharing
Xof parameter values.
X@PP
XTo evaluate an unsized object (pure parse tree), its {@I environment},
Xthe equivalent of the stack frames in Algol-like languages, must be
Xavailable, containing the actual values of all formal parameters
Xthat are visible within the unsized object.  Environment handling is
Xa well-known implementation technique, so it will be discussed
Xonly briefly here.
X@PP
XEnvironments are extra subtrees hung from the objects they refer
Xto.  This organization makes excellent use of the ordered dag to
Xpermit environments to be shared, and deleted when the last
Xreference to them is removed.  Several optimizations have been
Ximplemented.  Actual parameters known to be invoked only once are moved
Xin from the environment, not copied; copying could lead to quadratic time
Xcomplexity.  Actual parameters of the form @Code "@Next" @I object
Xreceive an applicative pre-evaluation which prevents long chains of
X@Code "@Next" symbols from forming during the generation of large page
Xnumbers.  Some environments which provably contribute nothing are
Xdeleted, most notably when a symbol invocation has no symbols within its
Xactual parameters and no import list, so that only the environment of its
Xbody need be kept; this saves a great deal of space when objects with
Xenvironments are written to auxiliary files (Section {@NumberOf cross}).
X@End @SubSection
END_OF_FILE
  if test 2778 -ne `wc -c <'doc/tr.impl/s3.4'`; then
    echo shar: \"'doc/tr.impl/s3.4'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s3.4'
fi
if test -f 'doc/tr.lout/ch0.00' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch0.00'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch0.00'\" \(2458 characters\)
  sed "s/^X//" >'doc/tr.lout/ch0.00' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Start main document off                           #
X#                                                    #
X######################################################
X
X@Book
X   @Title { Document Formatting
X
Xwith Lout }
X   @Author { JEFFREY H. KINGSTON }
X   @Edition { SECOND EDITION
X
X22 June, 1993}
X   @Publisher { @I { @CopyRight Copyright 1991 and 1993, Jeffrey H. Kingston,
XBasser Department of Computer Science, The University
Xof Sydney 2006, Australia.} }
X//
X
X@Preface
X   @Tag { preface }
X@Begin
X@LP
X@IndexBlanks
XThis manual is addressed to those who wish to become
Xexpert users of the document formatting language Lout.  An expert user
Xis someone who understands the principles of document formatting
Xthat Lout embodies, and is able to apply them, for example to design
Xa document format or a special-purpose package.  In contrast, a non-expert
Xuser is someone who simply uses Lout to format documents.
X@PP
XChapter {@NumberOf principles} explains these principles, and it
Xshould be read carefully and in sequence.  Chapters {@NumberOf details}
Xand {@NumberOf symbols} are for reference; respectively, they
Xcontain descriptions of the detailed operation of Lout's major
Xcomponents, and a complete description of each predefined symbol.  The
Xfinal chapter presents a collection of advanced examples.
X@PP
XThis manual presents Version 2.05 of Basser Lout, publicly released in
XJuly 1993 [{@Ref kingston93basser}].  Those familiar
Xwith Version 1 will notice many enhancements, including PostScript
X@FootNote { PostScript is a trademark of Adobe Systems, Inc. }
XEPS file inclusion, optimal paragraph breaking, automatic hyphenation,
Xligatures, and support for the ISO-LATIN-1 character set.
X@PP
XThis manual was printed on an Apple LaserWriter
Xapple.laserwriter @Index { Apple LaserWriter }
X@FootNote { Apple and LaserWriter are trademarks of Apple Computer, Inc. }
Xlaser printer from a PostScript
Xpostscript @Index { PostScript }
Xfile generated by Version 2.05 of the Basser Lout interpreter, using the
XDocumentLayout package [{@Ref kingston92begin}].
X@DP
X@Heading { Acknowledgment. }  Version 2.05 has benefited from hundreds of
Xcomments received since the release of Version 1 in October 1991 and
XVersion 2.01 in early 1993.  Not every suggestion could be followed,
Xbut many have been, and the encouragement was greatly appreciated.
X@End @Preface
END_OF_FILE
  if test 2458 -ne `wc -c <'doc/tr.lout/ch0.00'`; then
    echo shar: \"'doc/tr.lout/ch0.00'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch0.00'
fi
if test -f 'doc/tr.lout/ch2.02' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch2.02'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch2.02'\" \(3082 characters\)
  sed "s/^X//" >'doc/tr.lout/ch2.02' <<'END_OF_FILE'
X@Section
X  @Tag { visibility }
X  @Title { Nested definitions, body parameters, and import and export }
X@Begin
X@PP
XA definition may contain
Xnested.def @Index { Nested definitions }
Xother definitions at the beginning of its body:
X@ID @Code {
X"def @NineSquare"
X"   right x"
X"{"
X"   def @Three { x |0.2i x |0.2i x }"
X""
X"   @Three /0.2i @Three /0.2i @Three"
X"}"
X}
XA parameter like @Code x may be invoked anywhere within the body of the
Xsymbol it is a parameter of, including within nested definitions.  A
Xnested symbol like @Code "@Three" may be invoked anywhere from the
Xbeginning of its own body to the end of the body of the symbol it is
Xdefined within.  So, assuming an appropriate definition of
X{@Code "@Box"},
X@ID @Code {
X"@NineSquare @Box"
X}
Xhas result
X@ID @Fig {
X@NineSquare @Box { 0.2i @Wide 0.2i @High }
X}
XNested definitions may themselves contain nested definitions, to
Xarbitrary depth.
X@PP
XThere are three special features which permit a nested symbol or
Xparameter to be invoked outside its normal range; that is, outside the
Xbody of the enclosing symbol.  The first and simplest of these features
Xis the {@I {body parameter}},
Xparameter.body @SubIndex { @Code body parameter }
Xbody.par @Index { @Code body parameter }
Xan alternative form of right parameter.  The Eq equation formatting
Xpackage [{@Ref kingston92eq}] is a classic example of the use of a body
Xparameter.  In outline, it looks like this:
X@ID @Code {
X"export \"+\" sup over"
X""
X"def @Eq"
X"    body x"
X"{"
X"    def \"+\" ..."
X"    def sup ..."
X"    def over ..."
X"    ..."
X""
X"    Slope @Font x"
X"}"
X}
XFirst we list those nested symbols and parameters that we intend to
Xrefer to outside the body of @Code "@Eq" in an @Code export clause,
Xexport @Index { @Code export clause }
Xpreceding the definition as shown.  Only exported symbols may be
Xinvoked outside the body of {@Code "@Eq"}.  A body parameter may not be
Xexported.  The body parameter is like a right parameter except that the
Xexported symbols are visible within it:
X@ID @Code {
X"@Eq { {x sup 2 + y sup 2} over 2 }"
X}
Xcalls on the nested definitions of @Code "@Eq" to produce the result
X@ID {
X@Eq { {x sup 2 + y sup 2} over 2 }
X}
XThe body parameter's value must be enclosed in braces.  The term `body
Xparameter' is a reminder that the value is interpreted as if it was
Xwithin the body of the symbol.
X@PP
XThe second place where exported symbols may be used is in the right
Xparameter of the @@Open symbol, and following its alternative form,
X@@Use (Section {@NumberOf open}).
X@PP
XFinally, exported nested symbols and parameters may be made visible within
Xa subsequent definition or macro by preceding it with an @Code import
Ximport @Index { @Code import clause }
Xclause, like this:
X@ID @Code {
X"import @Eq"
X"def pythag { sqrt { x sup 2 + y sup 2 } }"
X}
XNote however that @Code pythag can only be used with some invocation of
X{@Code "@Eq"}:  within the body parameter of an invocation of {@Code "@Eq"},
Xwithin the right parameter of an {@Code "@Eq&&tag @Open"}, or following
Xa @@Use.  There may be several symbols in the @Code import clause.
X@End @Section
END_OF_FILE
  if test 3082 -ne `wc -c <'doc/tr.lout/ch2.02'`; then
    echo shar: \"'doc/tr.lout/ch2.02'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch2.02'
fi
if test -f 'doc/tr.lout/ch2.03' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch2.03'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch2.03'\" \(2556 characters\)
  sed "s/^X//" >'doc/tr.lout/ch2.03' <<'END_OF_FILE'
X@Section
X  @Tag { named }
X  @Title { Named parameters }
X@Begin
X@PP
XIn addition to left and right (or body) parameters, a symbol may have
Xany number of {@I {named parameters}}:
Xparameter.named @SubIndex { @Code named parameter }
Xnamed.par @Index { @Code named parameter }
X@ID @Code  {
X"def @Chapter"
X"    named @Tag {}"
X"    named @Title {}"
X"    right x"
X"{"
X"    ..."
X"}"
X}
XTheir definitions appear in between those of any left and right
Xparameters, and each is followed by a @I {default value} between
Xdefault @Index { Default value of parameter }
Xbraces.  When @Code "@Chapter" is invoked, its named parameters are
Xgiven values in the following way:
X@ID @Code  {
X"@Chapter"
X"    @Tag { intro }"
X"    @Title { Introduction }"
X"{"
X"    ..."
X"}"
X}
XThat is, a list of named parameters appears immediately following the
Xsymbol, each with its value enclosed in braces.  Any right parameter
Xfollows after them.  They do not have to appear in the order they were
Xdefined, and they can even be omitted altogether, in which case the
Xdefault value from the definition is used instead.
X@PP
XA named @Code "@Tag" parameter
Xtag.par @Index { @Code "@Tag" parameter, default value of }
Xdoes not take its default value from the definition; instead, if a default
Xvalue is needed, Lout invents a simple word which differs from every other
Xtag.  This is important, for example, in the production of numbered
Xchapters and sections (Section {@NumberOf chapters}).
X@PP
XNamed parameters may have parameters, {@PageMark strange} as in the
Xfollowing definition:
X@ID @Code {
X"def @Strange"
X"    named @Format right @Val { [@Val] }"
X"    right x"
X"{"
X"    @Format x"
X"}"
X}
XThe named parameter @Code "@Format" has right parameter {@Code "@Val"},
Xand the default value of @Code "@Format" is this parameter enclosed in
Xbrackets.  When @Code "@Format" is invoked it must be supplied with
Xa right parameter, which will replace {@Code "@Val"}.  Thus,
X@ID @Code {
X"@Strange 27"
X}
Xequals @Code "@Format 27" and so has result
X@ID {
X@Strange 27
X}
XThe @Code "@Format" symbol is like a definition with parameters whose
Xbody can be changed:
X@ID @Code {
X"@Strange"
X"    @Format { Slope @Font @Val. }"
X"27"
X}
Xstill equals {@Code "@Format 27"}, but this time the result is
X@ID {
X@Strange
X    @Format { Slope @Font @Val. }
X27
X}
XIn practice, examples of named parameters with parameters all have this
Xflavour of format being separated from content; running headers (Section
X{@NumberOf pagelayout}) and printing styles for bibliographies
X(Section {@NumberOf biblio}) are two major ones.
X@End @Section
END_OF_FILE
  if test 2556 -ne `wc -c <'doc/tr.lout/ch2.03'`; then
    echo shar: \"'doc/tr.lout/ch2.03'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch2.03'
fi
if test -f 'doc/tr.lout/ch2.04' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch2.04'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch2.04'\" \(2850 characters\)
  sed "s/^X//" >'doc/tr.lout/ch2.04' <<'END_OF_FILE'
X@Section
X   @Title { Precedence and associativity of symbols }
X   @Tag { precedence }
X@Begin
X@PP
XEvery symbol in Lout has a {@I precedence},
Xpreceden @Index { Precedence }
Xwhich is a positive whole number.  When two symbols compete for an object,
Xthe one with the higher precedence wins it.  For example,
X@ID @Code {
X"a  |  b  /  c"
X}
Xis equivalent to @OneCol @Code { "{" a "|" b "}" "/" c } rather than
X{@OneCol @Code { a "|" "{" b "/" c "}"} }, because @Code "|" has higher
Xprecedence than @Code "/" and thus wins the {@Code b}.
X@PP
XWhen the two competing symbols have equal precedence, Lout applies a
Xsecond rule.  Each symbol is either @I left-associative or
Xassociativity @Index { Associativity }
X{@I right-associative}.  The value of @OneCol @Code { a op1 b op2 c} is taken
Xto be @OneCol @Code { "{" a op1 b "}" op2 c } if the symbols are both
Xleft-associative, and @OneCol @Code "a op1 { b op2 c }" if they are
Xright-associative.  In cases not covered by these two rules, use braces.
X@PP
XIt sometimes happens that the result is the same regardless of how the
Xexpression is grouped.  For example, @OneCol @Code { "{" a "|" b "}" "|" c }
Xand @OneCol @Code { a "|" "{" b "|" c "}" } are always the same, for any
Xcombination of objects, gaps, and variants of {@Code "|"}.  In such cases
Xthe symbols are said to be {@I associative}, and we can confidently omit
Xthe braces.
X@PP
XUser-defined symbols may be given a precedence and associativity:
X@ID @Code {
X"def @Super"
X"   precedence 50"
X"   associativity right"
X"   left x"
X"   right y"
X"{"
X"   @OneRow { | -2p @Font y ^/0.5fk x }"
X"}"
X}
XThey come just after any @Code into clause and before any parameter
Xdefinitions.  The precedence may be
Xany whole number between 10 and 100, and if omitted is assigned the
Xvalue 100.  The higher the number, the higher the precedence.  The
Xassociativity may be @Code left or {@Code right}, and if omitted
Xdefaults to {@Code right}.  Lout's symbols have the following
Xprecedences and associativities:
X@ID @Tab
X   vmargin { 0.5vx }
X   @Fmta { @Col @CC A ! @Col @CC B ! @Col C }
X{
X@Rowa
X   A { Precedence }
X   B { Associativity }
X   C { Symbols }
X@Rowa
X@Rowa
X   A { 5 }
X   B { associative }
X   C { @Code "/  ^/  //  ^//" }
X@Rowa
X   A { 6 }
X   B { associative }
X   C { @Code "|  ^|  ||  ^||" }
X@Rowa
X   A { 7 }
X   B { associative }
X   C { @Code "&  ^&" }
X@Rowa
X   A { 7 }
X   B { associative }
X   C { @Code "&" in the form of one or more white space characters }
X@Rowa
X   A { 10-100 }
X   B { @Code left or @Code right }
X   C { user-defined symbols }
X@Rowa
X   A { 100 }
X   B { @Code right }
X   C { @@Wide, @@High, @@Graphic, etc. }
X@Rowa
X   A { 101 }
X   B { - }
X   C { @Code "&&" }
X@Rowa
X   A { 102 }
X   B { associative }
X   C { @Code "&" in the form of 0 spaces }
X@Rowa
X   A { 103 }
X   B { - }
X   C { Body parameters and right parameters of @@Open }
X}
X@End @Section
END_OF_FILE
  if test 2850 -ne `wc -c <'doc/tr.lout/ch2.04'`; then
    echo shar: \"'doc/tr.lout/ch2.04'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch2.04'
fi
if test -f 'doc/tr.over/s6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.over/s6'\"
else
  echo shar: Extracting \"'doc/tr.over/s6'\" \(2574 characters\)
  sed "s/^X//" >'doc/tr.over/s6' <<'END_OF_FILE'
X@Section
X   @Title { Cross references }
X@Begin
X@PP
XThe terms @Code "@TextPlace&&preceding" and @Code "@FootPlace&&following"
Xused above can be thought of as arrows in the final printed document,
Xpointing from themselves to the place they name.  Expressed in this way,
Xfree of any reference to the internal action of the document formatter,
Xthey are easy to comprehend and work with.  These arrows are called
Xcross references in Lout.
X@PP
XA galley is transported forwards along its arrow, but it turns out that
Xa reverse flow of information can also be very useful.  For example,
Xlarge documents often have cross references such as `see Table 6 on page
X57.'  If the numbers are replaced by arrows pointing to the table in
Xquestion, it should be possible to have their values filled in
Xautomatically (an idea introduced by Scribe [{@Ref reid80}]).  An arrow
Xpointing outside the docu&-ment could retrieve an entry from a database of
Xreferences, Roman numerals, etc.  And a running page header like
X`Chapter 8:  Sorting' might obtain its value from an arrow pointing from
Xthe page header line down into the body text of the page, where the
Xcurrent chapter is known.
X@PP
XAll these ideas are realized in Lout, but here we will just sketch a
Xsimplified version of the running page header definitions found in the
XBookLayout package [{@Ref kingston92begin}].  A symbol called
X@Code "@Runner" is first defined:
X@ID @Code {
X"def @Runner"
X"    right @Val"
X"{}"
X}
X@Code "@Runner" produces nothing at all, which means that we may place
Xthe invocation
X@ID @Code {
X"@Runner { Chapter"
X"8:  Sorting }"
X}
Xat the end of a chapter without harm.  This invisible invocation will be
Xcarried along with the chapter and will end up on some page of the final
Xprinted document.
X@PP
XBy modifying the definition of {@Code "@PageList"}, we can add to each
Xpage a header line containing the expression
X@ID @Code {
X"@Runner&&following"
X"@Open { @Val }"
X}
XThis means `find the nearest following invocation of @Code "@Runner" in the
Xfinal printed document and retrieve its @Code "@Val" parameter.' Every page
Xof Chapter 8 will find the correct running header, since @Code "@Runner"
Xwas placed at the end of the chapter.  The invocation @Code "@Runner {}"
Xplaced at the beginning of the chapter will suppress the header on the
Xfirst page of the chapter, as it is conventional to do.
X@PP
XThese invocations of @Code "@Runner" are hidden from the non-expert user
Xwithin the definition of the @Code "@Chapter" operator.  The result is a
Xreliable implementation of a notoriously difficult feature.
X@End @Section
END_OF_FILE
  if test 2574 -ne `wc -c <'doc/tr.over/s6'`; then
    echo shar: \"'doc/tr.over/s6'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.over/s6'
fi
if test -f 'doc/tr.over/setup' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.over/setup'\"
else
  echo shar: Extracting \"'doc/tr.over/setup'\" \(2864 characters\)
  sed "s/^X//" >'doc/tr.over/setup' <<'END_OF_FILE'
X
X######################################################
X#                                                    #
X#  Lout setup file for Overview paper.               #
X#                                                    #
X#  Jeffrey H. Kingston                               #
X#  8 June 1991                                       #
X#  23 December 1991                                  #
X#                                                    #
X######################################################
X
X@SysInclude { ft  }
X@SysInclude { dl  }
X@SysInclude { eq  }
X@SysInclude { fig }
X
X   def @Code
X      right x
X   { { Helvetica Base -1p } @Font lines @Break x
X   }
X
X   def @ShowMarks
X      named linewidth  { 0.015 cm }
X      named linestyle  { dashed   }
X      named dashlength { 0.15 cm  }
X      named paint      { light    }
X      right x
X   {
X      @Fig
X      {   @Box margin { 0c } linewidth { linewidth } paint { paint }
X	  {   @Figure
X		 shape { -0.3 cm ymark
X			 {xsize ymark} ++ {0.3 cm 0}  []
X			 xmark -0.3 cm
X			 {xmark ysize} ++ {0 0.3 cm}
X		       }
X		 linewidth { linewidth }
X		 linestyle { linestyle }
X		 dashlength { dashlength }
X	      x
X	  }
X
X      }
X   }
X
X   def @TeX { T{ /0.2fo E}X }
X
X   def @Leaders { ..   @Leaders }
X
X   ###################################################
X   #                                                 #
X   #  Interpolated example documents.                #
X   #                                                 #
X   ###################################################
X
X   def @HLine
X   { 
X         { 0 0 moveto xsize 0 lineto stroke } @Graphic {}
X   }
X
X   def @LittleEndRunPlace { @Galley }
X   def @LittleEndRun
X      force into { @LittleEndRunPlace&&preceding }
X   {}
X
X   def @LittleTextPlace { @Galley }
X   def @LittleText into { @LittleTextPlace&&preceding }
X      right x
X   { x
X   }
X
X   def @LittleFootPlace { @Galley }
X   def @LittleFootNote into { @LittleFootPlace&&following }
X      right x
X   { x
X   }
X
X   def @LittlePageColumn
X      right x
X   {
X        9px @Break 8p @Font
X        2.8c @Wide x
X   }
X
X   def @LittlePage
X      right x
X   {
X      @HContract @VContract
X      { 0 0 moveto xsize 0 lineto xsize ysize lineto
X	0 ysize lineto closepath stroke } @Graphic
X      {  //0.3c ||0.3c
X         9px @Break 8p @Font
X         2.8c @Wide 3.8c @High x
X         ||0.3c //0.3c
X      }
X   }
X
X   def @LittleFootSect
X   {  1c @Wide @HLine
X      //0.3v @LittleFootPlace ||0.5c
X   }
X
X   def @LittlePageList
X     right @PageNum
X   {
X      @LittlePage { |0.5rt - @PageNum - //0.8v
X		//0.3v @LittleTextPlace
X		//1rt @LittleFootSect
X	     }
X      //
X      @LittlePageList @Next @PageNum
X   }
X
X   def @LittleDocument
X   {  @LittlePage
X      {  @LittleTextPlace
X         //1rt @LittleFootSect
X      }
X      // @LittlePageList 2
X      // @LittleEndRunPlace
X   }
X		
X@Use { @DocumentLayout }
X
X@SysDatabase @Reference { loutrefs }
END_OF_FILE
  if test 2864 -ne `wc -c <'doc/tr.over/setup'`; then
    echo shar: \"'doc/tr.over/setup'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.over/setup'
fi
if test -f 'doc/tr.tab/s1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.tab/s1'\"
else
  echo shar: Extracting \"'doc/tr.tab/s1'\" \(2564 characters\)
  sed "s/^X//" >'doc/tr.tab/s1' <<'END_OF_FILE'
X@Section
X   @Title { Introduction }
X@Begin
X@PP
XThe Tab table formatting package is designed to simplify the production
Xof tables in documents produced with the Lout document formatting system
X[{@Ref kingston92}].  Tab aligns entries in columns, draws boxes and
Xrules, and so on.  To use Tab, either place @Code "-itab" on the Unix
X@FootNote { Unix is a trademark of "AT&T" Bell Laboratories. }
Xcommand line, or @Code "@SysInclude { tab }" in the setup file.
X@PP
XTo begin with a very simple example, the table
X@CD
X@Tab
X    @Fmta { @Col A  !  @Col B  !  @Col C }
X{
X    @Rowa A { Austen } B { Chaucer } C { Donne }
X    @Rowa A { Balzac } B { Darwin } C { Goethe }
X    @Rowa A { Byron } B { Dickens } C { Homer }
X}
Xis the result of the following Lout input:
X@ID @Code {
X"@Tab"
X"    @Fmta { @Col A  !  @Col B  !  @Col C }"
X"{"
X"    @Rowa A { Austen } B { Chaucer } C { Donne }"
X"    @Rowa A { Balzac } B { Darwin } C { Goethe }"
X"    @Rowa A { Byron } B { Dickens } C { Homer }"
X"}"
X}
XImmediately after the @Code "@Tab" symbol, which introduces the table,
Xcomes a @I { format option } & , {@Code "@Fmta"}, describing the format
Xof each row.  It says that each row contains three columns:
X{@Code "@Col A"}, {@Code "@Col B"}, and {@Code "@Col C"}.  The format
Xoption may have up to 26 columns, with names chosen freely
Xfrom the upper-&-case letters from @Code A to {@Code Z}.  The symbol
X@Code "!" separates each pair of columns.
X@PP
XAfter the format option comes the body of the table, enclosed in
Xbraces.  It consists entirely of a sequence of rows, each introduced by
Xthe @Code "@Rowa" symbol and containing one entry for each column of the
Xformat option, as shown (the row may occupy any number of lines of the
Xinput file).  The entries may be arbitrary Lout objects, such as words,
Xparagraphs, equations, figures, and so on without restriction.  An entry
Xmay be omitted altogether if it is empty.  Lout will choose suitable widths
Xfor the columns, and break paragraphs in the entries to the right widths.
X@PP
XTab neither knows nor cares what happens to the table it produces; it
Xcould appear at any point in the document, even within a paragraph of
Xtext.  Most commonly, though, tables are displayed using the 
X@Code "@IndentedDisplay" and @Code "@CentredDisplay" symbols from the
XDocumentLayout package [{@Ref kingston92begin}]:
X@ID @Code "@CentredDisplay @Tab ..."
Xor else they go into the @Code "@Table" symbol:
X@ID @Code {
X"@Table"
X"    @Caption { ... }"
X"@Tab"
X"{ ..."
X"}"
X}
Xwhich centres them at the top of the following page and adds a caption.
X@End @Section
END_OF_FILE
  if test 2564 -ne `wc -c <'doc/tr.tab/s1'`; then
    echo shar: \"'doc/tr.tab/s1'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.tab/s1'
fi
if test -f 'doc/tr.tab/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.tab/s3'\"
else
  echo shar: Extracting \"'doc/tr.tab/s3'\" \(2783 characters\)
  sed "s/^X//" >'doc/tr.tab/s3' <<'END_OF_FILE'
X@Section
X   @Title { Changing the style of rows }
X@Begin
X@PP
XSometimes different rows need different formats, usually because they
Xare headings.  Although this can be done with style-changing symbols in
Xthe entries, it is probably better to use multiple format options:
X@ID @Code {
X"@Tab"
X"    @Fmta { @Col @Heading A  !  @Col @Heading B }"
X"    @Fmtb { @Col @A  !  @Col @CC B }"
X"{"
X"    @Rowa A { Course } B { Enrolment }"
X"    @Rowb A { Software Engineering } B { 174 }"
X"    @Rowb A { Complexity Theory } B { 37 }"
X"}"
X}
Xhas result
X@CD {
X@Tab
X    @Fmta { @Col @Heading A  !  @Col @Heading B }
X    @Fmtb { @Col A  !  @Col @CC B }
X{
X    @Rowa A { Course } B { Enrolment }
X    @Rowb A { Software Engineering } B { 174 }
X    @Rowb A { Complexity Theory } B { 37 }
X}
X}
XWe have used the @Code "@Heading" symbol from the DocumentLayout package
Xjust to prove that it can be done.  Each row appears in the format of
Xthe corresponding format option:  @Code "@Rowa" rows in the format of
X{@Code "@Fmta"}, @Code "@Rowb" rows in the format of {@Code "@Fmtb"},
Xand so on.  There may be up to ten different format options, from
X@Code "@Fmta" to {@Code "@Fmtj"}, and they may be used repeatedly and
Xin any order.
X@PP
XThere is an @Code "@Over" symbol for constructing
X{@I{spanning columns}}:  columns that spread over two or more following
Xcolumns.  For example, the Lout input
X@ID @Code {
X"@I @Tab"
X"    @Fmta { @Col @CC X @Over A,B  !  @Col C }"
X"    @Fmtb { @Col A  !  @Col B  !  @Col C }"
X"{"
X"    @Rowa X { X } C { C }"
X"    @Rowb A { A } B { B } C { C }"
X"}"
X}
Xproduces the table
X@CD {
X@I @Tab
X    side { single }
X    @Fmta { @Col @CC X @Over A,B !! @Col C }
X    @Fmtb { @Col A !! @Col B !! @Col C }
X{
X    @Rowa X { X } C { C }
X       above { single }
X       below { single }
X    @Rowb A { A } B { B } C { C }
X       below { single }
X}
X}
X(We will see how to get the lines later.)  The @Code "@Over" symbol
Xalways comes directly after the column letter, and it is followed by one
Xor more letters separated by commas indicating which columns in the
Xfollowing row this column is to span over.
X@PP
XWith multiple row formats, especially those with spanning columns, it is
Ximportant to take care that each row is compatible with the one
Xpreceding it, in the sense of having the same number of columns, taking
X@Code "@Over" symbols into account.  For example, two successive
X@Code "@Rowa" rows would not be compatible in the example above, since
Xthe second has only two columns but the first prepares the way for three.
X@PP
XTab does not provide a way to have spanning columns underneath the columns
Xthey span, so spanning columns are useful only for headings.  This
Xrestriction was made necessary by inadequacies in the
Xway that the Basser Lout interpreter handles spanning columns.
X@End @Section
END_OF_FILE
  if test 2783 -ne `wc -c <'doc/tr.tab/s3'`; then
    echo shar: \"'doc/tr.tab/s3'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.tab/s3'
fi
if test -f 'evec/LoutLatin1.CEV' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'evec/LoutLatin1.CEV'\"
else
  echo shar: Extracting \"'evec/LoutLatin1.CEV'\" \(1953 characters\)
  sed "s/^X//" >'evec/LoutLatin1.CEV' <<'END_OF_FILE'
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
Xspace		exclam		quotedbl	numbersign	dollar		percent		ampersand	quoteright
Xparenleft	parenright	asterisk	plus		comma		hyphen		period		slash
Xzero		one		two		three		four		five		six		seven
Xeight		nine		colon		semicolon	less		equal		greater		question
Xat		A		B		C		D		E		F		G
XH		I		J		K		L		M		N		O
XP		Q		R		S		T		U		V		W
XX		Y		Z		bracketleft	backslash	bracketright	asciicircum	underscore
Xquoteleft	a		b		c		d		e		f		g
Xh		i		j		k		l		m		n		o
Xp		q		r		s		t		u		v		w
Xx		y		z		braceleft	bar		braceright	asciitilde	.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		quotedblleft	quotedblright	fi
Xfl		endash		emdash		bullet		dagger		daggerdbl	florin		fraction
Xdotlessi	grave		acute		circumflex	tilde		macron		breve		dotaccent
Xdieresis	.notdef		ring		cedilla		.notdef		hungarumlaut	ogonek		caron
Xspace		exclamdown	cent		sterling	currency	yen		brokenbar	section
Xdieresis	copyright	ordfeminine	guillemotleft	logicalnot	hyphen		registered	macron
Xdegree		plusminus	twosuperior	threesuperior	acute		mu		paragraph	periodcentered
Xcedilla		onesuperior	ordmasculine	guillemotright	onequarter	onehalf		threequarters	questiondown
XAgrave		Aacute		Acircumflex	Atilde		Adieresis	Aring		AE		Ccedilla
XEgrave		Eacute		Ecircumflex	Edieresis	Igrave		Iacute		Icircumflex	Idieresis
XEth		Ntilde		Ograve		Oacute		Ocircumflex	Otilde		Odieresis	multiply
XOslash		Ugrave		Uacute		Ucircumflex	Udieresis	Yacute		Thorn		germandbls
Xagrave		aacute		acircumflex	atilde		adieresis	aring		ae		ccedilla
Xegrave		eacute		ecircumflex	edieresis	igrave		iacute		icircumflex	idieresis
Xeth		ntilde		ograve		oacute		ocircumflex	otilde		odieresis	divide
Xoslash		ugrave		uacute		ucircumflex	udieresis	yacute		thorn		ydieresis
END_OF_FILE
  if test 1953 -ne `wc -c <'evec/LoutLatin1.CEV'`; then
    echo shar: \"'evec/LoutLatin1.CEV'\" unpacked with wrong size!
  fi
  # end of 'evec/LoutLatin1.CEV'
fi
if test -f 'evec/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'evec/README'\"
else
  echo shar: Extracting \"'evec/README'\" \(2146 characters\)
  sed "s/^X//" >'evec/README' <<'END_OF_FILE'
XDirectory lout/evec - character encoding vector (CEV) files
X
XThis directory contains character encoding vector (CEV) files,
Xdescribing mappings from 8-bit character codes to the character
Xnames found in AFM files.  The CEV format is hereby defined as
X256 character names, separated by arbitrary blank spaces and
Xnewlines.  Comments and other matter are not permitted.  See
Xthe accompanying files for examples.
X
X  Std.CEV        The StandardEncoding encoding vector, exactly
X                 as on page 598 of the PostScript LRM 2nd Ed.
X
X  Latin1.CEV     The ISOLatin1Encoding encoding vector, exactly
X                 as on page 599 of the PostScript LRM 2nd Ed.
X                 This is not usable with Lout as it stands
X                 because the ligature characters fi and fl have
X                 no encoding, and because the standard packages
X		 use characters that are not in this encoding.
X
X  LoutLatin1.CEV Equal to Latin1.CEV augmented with the following
X                 characters used by Lout and its standard packages:
X
X		   quotedblleft	  \205  used in DocumentLayout
X		   quotedblright  \206  used in DocumentLayout
X		   fi		  \207	must encode all ligatures
X		   fl		  \210	must encode all ligatures
X		   endash	  \211	used in DocumentLayout
X		   emdash	  \212	used in DocumentLayout
X		   bullet	  \213	used in DocumentLayout
X		   dagger	  \214	used in DocumentLayout
X		   daggerdbl	  \215	used in DocumentLayout
X		   florin	  \216	used in DocumentLayout
X		   fraction	  \217	used in Pas
X
X		 Also the character at position \055 has been
X		 changed from minus to hyphen; the minus character
X		 is not encoded in this vector.
X
X  Symb.CEV       The Symbol encoding vector, exactly as on page
X                 606 of the PostScript LRM 2nd Ed.
X
X  Ding.CEV       The Zapf Dingbats encoding vector, taken from
X                 the Zapf Dingbats AFM file.
X
X  null.oct       Useful skeleton files for building encoding
X  null.dec       vectors, given octal or decimal character code
X                 info.  Don't forget to delete the leftmost
X                 column, which is just a construction guide.
X
XJeffrey H. Kingston
X6 June 1993
END_OF_FILE
  if test 2146 -ne `wc -c <'evec/README'`; then
    echo shar: \"'evec/README'\" unpacked with wrong size!
  fi
  # end of 'evec/README'
fi
if test -f 'evec/Symb.CEV' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'evec/Symb.CEV'\"
else
  echo shar: Extracting \"'evec/Symb.CEV'\" \(2319 characters\)
  sed "s/^X//" >'evec/Symb.CEV' <<'END_OF_FILE'
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
Xspace		exclam		universal	numbersign	existential	percent		ampersand	suchthat
Xparenleft	parenright	asteriskmath	plus		comma		minus		period		slash
Xzero		one		two		three		four		five		six		seven
Xeight		nine		colon		semicolon	less		equal		greater		question
Xcongruent	Alpha		Beta		Chi		Delta		Epsilon		Phi		Gamma
XEta		Iota		theta1		Kappa		Lambda		Mu		Nu		Omicron
XPi		Theta		Rho		Sigma		Tau		Upsilon		sigma1		Omega
XXi		Psi		Zeta		bracketleft	therefore	bracketright	perpendicular	underscore
Xradicalex	alpha		beta		chi		delta		epsilon		phi		gamma
Xeta		iota		phi1		kappa		lambda		mu		nu		omicron
Xpi		theta		rho		sigma		tau		upsilon		omega1		omega
Xxi		psi		zeta		braceleft	bar		braceright	similar		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X.notdef		Upsilon1	minute		lessequal	fraction	infinity	florin		club
Xdiamond		heart		spade		arrowboth	arrowleft	arrowup		arrowright	arrowdown
Xdegree		plusminus	second		greaterequal	multiply	proportional	partialdiff	bullet
Xdivide		notequal	equivalence	approxequal	ellipsis	arrowvertex	arrowhorizex	carriagereturn
Xaleph		Ifraktur	Rfraktur	weierstrass	circlemultiply	circleplus	emptyset	intersection
Xunion		propersuperset	reflexsuperset	notsubset	propersubset	reflexsubset	element		notelement
Xangle		gradient	registerserif	copyrightserif	trademarkserif	product		radical		dotmath
Xlogicalnot	logicaland	logicalor	arrowdblboth	arrowdblleft	arrowdblup	arrowdblright	arrowdbldown
Xlozenge		angleleft	registersans	copyrightsans	trademarksans	summation	parenlefttp	parenleftex
Xparenleftbt	bracketlefttp	bracketleftex	bracketleftbt	bracelefttp	braceleftmid	braceleftbt	braceex
X.notdef		angleright	integral	integraltp	integralex	integralbt	parenrighttp	parenrightex
Xparenrightbt	bracketrighttp	bracketrightex	bracketrightbt	bracerighttp	bracerightmid	bracerightbt	.notdef
END_OF_FILE
  if test 2319 -ne `wc -c <'evec/Symb.CEV'`; then
    echo shar: \"'evec/Symb.CEV'\" unpacked with wrong size!
  fi
  # end of 'evec/Symb.CEV'
fi
if test -f 'evec/null.dec' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'evec/null.dec'\"
else
  echo shar: Extracting \"'evec/null.dec'\" \(2460 characters\)
  sed "s/^X//" >'evec/null.dec' <<'END_OF_FILE'
X000	.notdef		.notdef		.notdef		.notdef		.notdef
X005	.notdef		.notdef		.notdef		.notdef		.notdef
X010	.notdef		.notdef		.notdef		.notdef		.notdef
X015	.notdef		.notdef		.notdef		.notdef		.notdef
X020	.notdef		.notdef		.notdef		.notdef		.notdef
X025	.notdef		.notdef		.notdef		.notdef		.notdef
X030	.notdef		.notdef		.notdef		.notdef		.notdef
X035	.notdef		.notdef		.notdef		.notdef		.notdef
X040	.notdef		.notdef		.notdef		.notdef		.notdef
X045	.notdef		.notdef		.notdef		.notdef		.notdef
X050	.notdef		.notdef		.notdef		.notdef		.notdef
X055	.notdef		.notdef		.notdef		.notdef		.notdef
X060	.notdef		.notdef		.notdef		.notdef		.notdef
X065	.notdef		.notdef		.notdef		.notdef		.notdef
X070	.notdef		.notdef		.notdef		.notdef		.notdef
X075	.notdef		.notdef		.notdef		.notdef		.notdef
X080	.notdef		.notdef		.notdef		.notdef		.notdef
X085	.notdef		.notdef		.notdef		.notdef		.notdef
X090	.notdef		.notdef		.notdef		.notdef		.notdef
X095	.notdef		.notdef		.notdef		.notdef		.notdef
X100	.notdef		.notdef		.notdef		.notdef		.notdef
X105	.notdef		.notdef		.notdef		.notdef		.notdef
X110	.notdef		.notdef		.notdef		.notdef		.notdef
X115	.notdef		.notdef		.notdef		.notdef		.notdef
X120	.notdef		.notdef		.notdef		.notdef		.notdef
X125	.notdef		.notdef		.notdef		.notdef		.notdef
X130	.notdef		.notdef		.notdef		.notdef		.notdef
X135	.notdef		.notdef		.notdef		.notdef		.notdef
X140	.notdef		.notdef		.notdef		.notdef		.notdef
X145	.notdef		.notdef		.notdef		.notdef		.notdef
X150	.notdef		.notdef		.notdef		.notdef		.notdef
X155	.notdef		.notdef		.notdef		.notdef		.notdef
X160	.notdef		.notdef		.notdef		.notdef		.notdef
X165	.notdef		.notdef		.notdef		.notdef		.notdef
X170	.notdef		.notdef		.notdef		.notdef		.notdef
X175	.notdef		.notdef		.notdef		.notdef		.notdef
X180	.notdef		.notdef		.notdef		.notdef		.notdef
X185	.notdef		.notdef		.notdef		.notdef		.notdef
X190	.notdef		.notdef		.notdef		.notdef		.notdef
X195	.notdef		.notdef		.notdef		.notdef		.notdef
X200	.notdef		.notdef		.notdef		.notdef		.notdef
X205	.notdef		.notdef		.notdef		.notdef		.notdef
X210	.notdef		.notdef		.notdef		.notdef		.notdef
X215	.notdef		.notdef		.notdef		.notdef		.notdef
X220	.notdef		.notdef		.notdef		.notdef		.notdef
X225	.notdef		.notdef		.notdef		.notdef		.notdef
X230	.notdef		.notdef		.notdef		.notdef		.notdef
X235	.notdef		.notdef		.notdef		.notdef		.notdef
X240	.notdef		.notdef		.notdef		.notdef		.notdef
X245	.notdef		.notdef		.notdef		.notdef		.notdef
X250	.notdef		.notdef		.notdef		.notdef		.notdef
X255	.notdef
END_OF_FILE
  if test 2460 -ne `wc -c <'evec/null.dec'`; then
    echo shar: \"'evec/null.dec'\" unpacked with wrong size!
  fi
  # end of 'evec/null.dec'
fi
if test -f 'evec/null.oct' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'evec/null.oct'\"
else
  echo shar: Extracting \"'evec/null.oct'\" \(2400 characters\)
  sed "s/^X//" >'evec/null.oct' <<'END_OF_FILE'
X000	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X010	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X020	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X030	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X040	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X050	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X060	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X070	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X100	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X110	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X120	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X130	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X140	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X150	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X160	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X170	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X200	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X210	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X220	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X230	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X240	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X250	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X260	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X270	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X300	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X310	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X320	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X330	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X340	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X350	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X360	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
X370	.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef		.notdef
END_OF_FILE
  if test 2400 -ne `wc -c <'evec/null.oct'`; then
    echo shar: \"'evec/null.oct'\" unpacked with wrong size!
  fi
  # end of 'evec/null.oct'
fi
if test -f 'hyph.install' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hyph.install'\"
else
  echo shar: Extracting \"'hyph.install'\" \(2281 characters\)
  sed "s/^X//" >'hyph.install' <<'END_OF_FILE'
XInstallation of hyphenation patterns
X
XJeffrey H. Kingston
X22 December 1992
X
XBasser Lout Version 2.05 incorporates automatic hyphenation using the method
Xintroduced by TeX (see Appendix H of the TeXBook by D. E. Knuth).  No special
Xaction is required to install hyphenation unless it is desired to change the
Xhyphenation patterns that control it.
X
XThe first time on any run that hyphenation is required, Lout will search the
X@SysInclude directories for a binary file called lout.hyph.pk, which
Xcontains a memory image of the TeX hyphenation patterns, modified so that
Xthe file may be safely shared by big-endian and little-endian machines.  If
Xthis file cannot be found, Lout then searches for the text file lout.hyph
Xinstead, and uses it to construct lout.hyph.pk.  To change the hyphenation
Xpatterns, delete lout.hyph.pk and modify lout.hyph; the rest is automatic.
X
XFile lout.hyph mainly contains the long list of TeX hyphenation patterns,
Xbut it begins with a sequence of character classes, one class per line,
Xterminated by a blank line:
X
X    @!$%^&*()_-+=~`{[}]:;'|<,.>?/0123456789
X    aA
X    bB
X    cC
X    ...
X    yY
X    zZ
X
XBriefly, hyphenation of a word works like this.  If the word contains a
Xcharacter not found in any of these classes, it will not be hyphenated.
XOtherwise the word is analysed into sequences of letters separated by
Xsequences of non-letters (the characters in the first class are by
Xdefinition the non-letters, and the remaining characters are the letters).
XEach sequence of five or more letters is then matched with the hyphenation
Xpatterns and hyphenated.  The matching process treats the members of each
Xclass as identical (so the classes above ensure that the distinction
Xbetween upper and lower case is ignored).  The hyphen character "-" is
Xtreated specially.  Apart from the weighting digits, the patterns should
Xcontain only letters.
X
XExtreme lengths were resorted to to compress the .pk file as much as
Xpossible, and attempts to increase the number of classes or patterns
Xsignificantly are likely to fail.  Some words are not hyphenated well by
Xthe standard patterns and must be treated as exceptions; see the
XDocumentLayout package implementation (file dl in lout/include) for
Xthe standard list of these exceptions and how to deal with them.
END_OF_FILE
  if test 2281 -ne `wc -c <'hyph.install'`; then
    echo shar: \"'hyph.install'\" unpacked with wrong size!
  fi
  # end of 'hyph.install'
fi
if test -f 'news.blurb' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'news.blurb'\"
else
  echo shar: Extracting \"'news.blurb'\" \(2426 characters\)
  sed "s/^X//" >'news.blurb' <<'END_OF_FILE'
XSubject: Version 2.05 of Lout document formatting system
XDate: Tue, 27 Jul 1993 17:09:23 +1000
XNewsgroups: comp.text,comp.sources.d,aus.sources
XKeywords: document formatting typesetting lout
X
XVersion 2.05 of the Lout document formatting system is now available
X(free of charge).  The system reads a high-level description of a
Xdocument similar in style to LaTeX and produces a PostScript file which
Xcan be printed on many laser printers and graphic display devices.
X
XLout offers an unprecedented range of advanced features, including
Xoptimal paragraph breaking, automatic hyphenation, PostScript EPS file
Xinclusion, equation formatting, tables, diagrams, rotation and scaling,
Xsorted indexes, bibliographic databases, running headers and odd-even
Xpages, automatic cross referencing, and much more, all ready to go.
XFurthermore, Lout is easily extended with definitions which are very
Xmuch easier to write than troff of TeX macros because Lout is a
Xhigh-level language, the outcome of an eight-year research project that
Xwent back to the beginning.
X
XNew features just introduced in Version 2.05 include full support for the
XISO-LATIN-1 character set and arbitrary PostScript encoding vectors, small
Xchanges to the DocumentLayout package to simplify porting it to non-English
Xlanguages, source code which compiles cleanly on type-fussy compilers and
Xat least one 64-bit architecture (the DEC Alpha) but is not yet ANSI, and
Xa few small enhancements and bug fixes.
X
XLout is written in C, is highly portable to Unix systems, and produces
XPostScript output (used by many laser printers).  It is distributed under
Xthe GNU public licence as a compressed tar file called lout.2.05.tar.Z
Xin the "jeff" subdirectory of the home directory you land in when running
X"ftp ftp.cs.su.oz.au" with login name "ftp" or "anonymous" (enter any
Xnon-empty password).  The comp.sources.misc newsgroup is an alternative
Xsource of Lout distributions.  The distribution contains
X
X  *  Complete C source code
X
X  *  Standard packages of definitions for tech reports, books, equations,
X     tables, diagrams, and Pascal prettyprinting (all written in Lout)
X
X  *  Complete user documentation in the form of seven technical reports
X     and a Unix manual page
X
X  *  A makefile and installation instructions
X
XLout was designed and implemented by Jeffrey H. Kingston (jeff@cs.su.oz.au)
Xof the Basser Department of Computer Science at the University of Sydney.
END_OF_FILE
  if test 2426 -ne `wc -c <'news.blurb'`; then
    echo shar: \"'news.blurb'\" unpacked with wrong size!
  fi
  # end of 'news.blurb'
fi
echo shar: End of archive 33 \(of 35\).
cp /dev/null ark33isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
