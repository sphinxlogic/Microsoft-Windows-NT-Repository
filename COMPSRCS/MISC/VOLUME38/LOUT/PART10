Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i078:  lout - Lout document formatting system, v2.05, Part10/35
Message-ID: <1993Aug8.180844.11715@sparky.sterling.com>
X-Md4-Signature: c58532976b10e786df458a1bb95bfbe8
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sun, 8 Aug 1993 18:08:44 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 78
Archive-name: lout/part10
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  z04.c z23.c z24.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:24 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 35)."'
if test -f 'z04.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z04.c'\"
else
  echo shar: Extracting \"'z04.c'\" \(7484 characters\)
  sed "s/^X//" >'z04.c' <<'END_OF_FILE'
X/*@z04.c:Token Service:NewToken(), CopyTokenList()@***************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z04.c                                                      */
X/*  MODULE:       Token Service                                              */
X/*  EXTERNS:      NewToken(), CopyTokenList(), EchoCatOp(), EchoToken()      */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT NewToken(xtype, xfpos, xvspace, xhspace, xprec, xactual)          */
X/*                                                                           */
X/*  Returns a new non-WORD token initialised as the parameters indicate.     */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT NewToken(xtype, xfpos, xvspace, xhspace, xprec, xactual)
Xunsigned char xtype;  FILE_POS *xfpos;  unsigned char xvspace, xhspace;
Xunsigned char xprec;  OBJECT xactual;
X{ OBJECT res;
X  debug1(DTS, DDD, "NewToken(%s, ...)", Image(xtype));
X  res = New(xtype);  FposCopy(fpos(res), *xfpos);
X  vspace(res) = xvspace;  hspace(res) = xhspace;
X  precedence(res) = xprec;  actual(res) = xactual;
X  debug1(DTS, DDD, "NewToken returning %s", EchoToken(res));
X  return res;
X} /* end NewToken */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT CopyTokenList(x, pos)                                             */
X/*                                                                           */
X/*  Returns a copy of the list of tokens pointed to by x.                    */
X/*  All file positions in the copy are set to *pos.                          */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT CopyTokenList(x, pos)
XOBJECT x;  FILE_POS *pos;
X{ OBJECT y, z, res;
X  res = nil;  y = x;
X  if( x != nil ) do
X  { if( is_word(type(y)) )
X    { z = MakeWord(type(y), string(y), pos);
X      vspace(z) = vspace(y);  hspace(z) = hspace(y);
X    }
X    else z = NewToken(type(y), pos,vspace(y),hspace(y),precedence(y),actual(y));
X    res = Append(res, z, PARENT);
X    y = succ(y, PARENT);
X  } while( y != x );
X  return res;
X} /* end CopyTokenList */
X
X/*@::EchoCatOp(), EchoToken()@************************************************/
X/*                                                                           */
X/*  FULL_CHAR *EchoCatOp(xtype, xmark, xjoin)                                */
X/*                                                                           */
X/*  Return the catenation operator with this type, mark and join.            */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *EchoCatOp(xtype, xmark, xjoin)
Xunsigned xtype;  BOOLEAN xmark, xjoin;
X{ switch( xtype )
X  {
X    case VCAT:	return	(xmark ? xjoin ? KW_VCAT_MJ : KW_VCAT_MN
X			       : xjoin ? KW_VCAT_NJ : KW_VCAT_NN);
X
X    case HCAT:	return	(xmark ? xjoin ? KW_HCAT_MJ : KW_HCAT_MN
X			       : xjoin ? KW_HCAT_NJ : KW_HCAT_NN);
X
X    case ACAT:	return	(xmark ? xjoin ? KW_ACAT_MJ : AsciiToFull("??")
X			       : xjoin ? KW_ACAT_NJ : AsciiToFull("??") );
X
X    default:	Error(INTERN, no_fpos, "EchoCatOp: xtype = %d", xtype);
X		return STR_EMPTY;
X
X  } /* end switch */
X} /* end EchoCatOp */
X
X
X#if DEBUG_ON
X/*****************************************************************************/
X/*                                                                           */
X/*  FULL_CHAR *EchoToken(x)                                                  */
X/*                                                                           */
X/*  Return an image of token x.  Do not worry about preceding space.         */
X/*                                                                           */
X/*****************************************************************************/
X
XFULL_CHAR *EchoToken(x)
XOBJECT x;
X{ switch( type(x) )
X  {
X    case WORD:
X    
X      return string(x);
X      break;
X
X
X    case QWORD:
X    
X      return StringQuotedWord(x);
X      break;
X
X
X    case TSPACE:
X    case TJUXTA:
X    case USE:
X    case GSTUB_EXT:
X    case GSTUB_INT:
X    case GSTUB_NONE:
X    
X      return Image(type(x));
X      break;
X
X
X    case BEGIN:
X    case END:
X    case ENV:
X    case CLOS:
X    case LBR:
X    case RBR:
X    case NULL_CLOS:
X    case CROSS:
X    case ONE_COL:
X    case ONE_ROW:
X    case WIDE:
X    case HIGH:
X    case HSCALE:
X    case VSCALE:
X    case SCALE:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case ROTATE:
X    case CASE:
X    case YIELD:
X    case XCHAR:
X    case FONT:
X    case SPACE:
X    case BREAK:
X    case NEXT:
X    case OPEN:
X    case TAGGED:
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GRAPHIC:
X    case ACAT:
X    case HCAT:
X    case VCAT:
X    case CLOSURE:
X    case PREPEND:
X    case SYS_PREPEND:
X    case DATABASE:
X    case SYS_DATABASE:
X    
X      return SymName(actual(x));
X      break;
X
X
X    default:
X    
X      Error(INTERN, &fpos(x), "EchoToken: %s", Image(type(x)));
X      return STR_EMPTY;
X      break;
X  }
X} /* end EchoToken */
X#endif
END_OF_FILE
  if test 7484 -ne `wc -c <'z04.c'`; then
    echo shar: \"'z04.c'\" unpacked with wrong size!
  fi
  # end of 'z04.c'
fi
if test -f 'z23.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z23.c'\"
else
  echo shar: Extracting \"'z23.c'\" \(28455 characters\)
  sed "s/^X//" >'z23.c' <<'END_OF_FILE'
X/*@z23.c:Galley Printer:ScaleFactor()@****************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z23.c                                                      */
X/*  MODULE:       Galley Printer                                             */
X/*  EXTERNS:      FixAndPrintObject()                                        */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define	NO_SUPPRESS	FALSE
X#define	SUPPRESS	TRUE
X#define	ALL_ADJUST	2
X#define	LAST_ADJUST	1
X#define	ALL_ADJUST	2
X
X#define CountChild(y, link, i)						\
Xfor( y=pred(link, PARENT), i=1; type(y)==LINK;  y = pred(y, PARENT), i++ )
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static float ScaleFactor(avail_size, inner_size)                         */
X/*                                                                           */
X/*  Return the scale factor for this scaling, or 0 if impossible.            */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic float ScaleFactor(avail_size, inner_size)
XLENGTH avail_size, inner_size;
X{ float scale_factor;
X  scale_factor = avail_size <= 0 ? 0 :
X		 inner_size <= 0 ? 0 : (float) avail_size / inner_size;
X  return scale_factor;
X}
X
X
X/*@::FindAdjustIncrement()@***************************************************/
X/*                                                                           */
X/*  static LENGTH FindAdjustIncrement(x, frame_size, dim)                    */
X/*                                                                           */
X/*  Find the amount by which to increase the width of the subobjects of      */
X/*  concatenation object x so that it is adjusted to fill size frame_size.   */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic LENGTH FindAdjustIncrement(x, frame_size, dim)
XOBJECT x;  LENGTH frame_size;  int dim;
X{ OBJECT y, link, prev, g;
X  int adjustable_gaps;
X  LENGTH inc, mk, actual_size;
X
X  debug2(DGP, D, "FindAdjustIncrement(x, %s, %s)",
X	EchoLength(frame_size), dimen(dim));
X  FirstDefinite(x, link, prev);
X  if( link != x )
X  { adjustable_gaps = 0;
X    mk = back(prev, dim);
X    NextDefiniteWithGap(x, link, y, g);
X    while( link != x )
X    { if ( mode(gap(g)) == TAB_MODE || units(gap(g)) == AVAIL_UNIT
X				    || units(gap(g)) == FRAME_UNIT )
X      {	debug0(DGP, D, "FindAdjustIncrement returning 0 (tab gap)");
X	return 0;
X      }
X      mk += ActualGap(fwd(prev, dim), back(y, dim), fwd(y, dim), &gap(g),
X		frame_size, mk);
X      prev = y;
X      adjustable_gaps++;
X      NextDefiniteWithGap(x, link, y, g);
X    }
X    actual_size = mk + fwd(prev, dim);
X    debug2(DGP, DD, "  actual_size = %s, adjustable_gaps = %d",
X	EchoLength(actual_size), adjustable_gaps);
X    inc = adjustable_gaps==0 ? 0 : (frame_size - actual_size) / adjustable_gaps;
X  }
X  else inc = 0;
X  debug1(DGP, D, "FindAdjustIncrement returning %s", EchoLength(inc));
X  return inc;
X} /* end FindAdjustIncrement */
X
X
X/*@::FixAndPrintObject()@*****************************************************/
X/*                                                                           */
X/*  FixAndPrintObject(x, xmk, xb, xf, dim, adjust, suppress, padj, pg,count) */
X/*                                                                           */
X/*  Fix the absolute position of object x in dimension dim, in such a way    */
X/*  that the principal mark of x has coordinate xmk, and x has actual size   */
X/*  (xb, xf), where xb >= back(x, dim) and xf >= fwd(x, dim).                */
X/*                                                                           */
X/*  Actually, in the case where x includes an object lying on a thread       */
X/*  leading outside x, the final size of x may be different.  Because        */
X/*  of this, the procedure sets back(x, dim) and fwd(x, dim) to the actual   */
X/*  size of x upon return.  The caller assumes that x will exactly occupy    */
X/*  this space back(x, dim), fwd(x, dim).                                    */
X/*                                                                           */
X/*  If x does not fill the forward part of the space allocated to it, the    */
X/*  adjust parameter determines what, if anything, to do about this.  The    */
X/*  two possible values of this parameter are:                               */
X/*                                                                           */
X/*    LAST_ADJUST        Adjust x to fill the forward space available to     */
X/*                       it, by adjusting the last component if x is a       */
X/*                       CAT object, or adjusting the child otherwise.       */
X/*                                                                           */
X/*    ALL_ADJUST         Adjust x to fill the forward space available to     */
X/*                       it, by adjusting all the components if x is a       */
X/*                       CAT object, or adjusting the child otherwise.       */
X/*                                                                           */
X/*  The suppress parameter is true if a temporary suppression of adjustment  */
X/*  is in effect (because a neighbouring adjustment has already been done).  */
X/*                                                                           */
X/*  The padj parameter is analogous to the adjust parameter, but it          */
X/*  applies only to & adjustment, not to | or / adjustment.                  */
X/*                                                                           */
X/*  If dim == COL, the coordinate information is merely stored; but if       */
X/*  dim == ROW, it is used to generate PostScript for printing x.            */
X/*                                                                           */
X/*  Parameter pg records the height of the current page.  This is used       */
X/*  to correct for the fact that Lout places its origin is at the top left,  */
X/*  while PostScript places its origin at the bottom left.  This correction  */
X/*  cannot be made by transforming user space.                               */
X/*                                                                           */
X/*  x is child number count of its parent (used by COL_THR and ROW_THR only) */
X/*                                                                           */
X/*****************************************************************************/
X
XFixAndPrintObject(x, xmk, xb, xf, dim, adjust, suppress, padj, pg, count)
XOBJECT x;  LENGTH xmk, xb, xf; int dim, adjust;  BOOLEAN suppress;
Xint padj;  LENGTH pg;  int count;
X{ OBJECT y, link, prev, g, uplink, z;
X  LENGTH mk, frame_size, back_edge, yb, yf, inc;
X  int i; float scale_factor;
X  debug8(DGP, D, "[ FixAndPrintObject(%s, %s, %s,%s, %s, %s, %s, %s, pg ), x =",
X    Image(type(x)), EchoLength(xmk), EchoLength(xb), EchoLength(xf), dimen(dim),
X    (adjust == LAST_ADJUST ? "last_adjust" : "all_adjust"),
X    (suppress == SUPPRESS ? "suppress" : "no_suppress"),
X    (padj   == LAST_ADJUST ? "last_adjust" : "all_adjust"));
X  ifdebug(DGP, DD, DebugObject(x));
X
X  switch( type(x) )
X  {
X
X    case CLOSURE:
X    case NULL_CLOS:
X    case CROSS:
X    
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case WORD:
X    case QWORD:
X    
X      if( dim == COL )  word_save_mark(x) = xmk;
X      else if( string(x)[0] != '\0' )  PrintWord(x, word_save_mark(x), pg-xmk);
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case WIDE:
X    case HIGH:
X    
X      CountChild(y, Down(x), count);
X      if( (dim == COL) == (type(x) == WIDE) )
X      { yf = bfc(constraint(x)) - back(y, dim);
X        FixAndPrintObject(y, xmk, back(y,dim), yf, dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, pg, count);
X        back(x, dim) = xb;  fwd(x, dim) = xf;
X      }
X      else
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress,
X	  padj, pg, count);
X	back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      }
X      break;
X
X
X    case HCONTRACT:
X    case VCONTRACT:
X    
X      CountChild(y, Down(x), count);
X      if( (dim == COL) == (type(x) == HCONTRACT) )
X      {	FixAndPrintObject(y, xmk, back(y,dim), fwd(y,dim), dim, LAST_ADJUST,
X	  NO_SUPPRESS, padj, pg, count);
X        back(x, dim) = xb;  fwd(x, dim) = xf;
X      }
X      else
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress, padj,pg,count);
X        back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      }
X      break;
X
X
X    case ONE_COL:
X    case ONE_ROW:
X    case HEXPAND:
X    case VEXPAND:
X    
X      CountChild(y, Down(x), count);
X      if( (dim == COL) == (type(x) == ONE_COL || type(x) == HEXPAND) )
X      { FixAndPrintObject(y, xmk, xb, xf, dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, pg, count);
X        back(x, dim) = xb;  fwd(x, dim) = xf;
X      }
X      else
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress, padj,pg,count);
X	back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      }
X      break;
X
X
X    case PADJUST:
X    
X      CountChild(y, Down(x), count);
X      FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress,
X	ALL_ADJUST, pg, count);
X      back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      break;
X
X
X    case HADJUST:
X    case VADJUST:
X    
X      CountChild(y, Down(x), count);
X      if( (dim == COL) == (type(x) == HADJUST) )
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, ALL_ADJUST, suppress,
X	  padj, pg, count);
X        back(x, dim) = xb;  fwd(x, dim) = xf;
X      }
X      else
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress,
X	  padj, pg, count);
X	back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      }
X      break;
X
X
X    case VSCALE:
X
X      debug0(DRS, D, "FixAndPrintObject at VSCALE");
X      CountChild(y, Down(x), count);
X      if( dim == COL )
X      {	FixAndPrintObject(y, xmk, xb, xf, dim, LAST_ADJUST, NO_SUPPRESS,
X		padj,pg,count);
X      }
X      else if( (scale_factor = ScaleFactor(xb+xf, size(y, ROW))) > 0 )
X      {	SaveGraphicState();
X	CoordTranslate(0, pg - (xmk-xb + (LENGTH) (back(y, ROW)*scale_factor)));
X	CoordScale(1.0, scale_factor);
X        FixAndPrintObject(y, 0, back(y, ROW), fwd(y, ROW), dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, 0, count);
X	RestoreGraphicState();
X      }
X      else if( !is_word(type(y)) || string(y)[0] != '\0' )
X      {	Error(WARN, &fpos(x), "object deleted: cannot %s", KW_VSCALE);
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case HSCALE:
X    
X      debug0(DRS, DD, "FixAndPrintObject at HSCALE");
X      CountChild(y, Down(x), count);
X      if( dim == COL )
X      {	save_mark(x) = xmk;
X	bc(constraint(x)) = xb;
X	fc(constraint(x)) = xf;
X        if( (scale_factor = ScaleFactor(xb+xf, size(y, COL))) > 0 )
X	  FixAndPrintObject(y, 0, back(y, COL), fwd(y, COL), dim, LAST_ADJUST,
X		NO_SUPPRESS, LAST_ADJUST, pg, count);
X        else if( !is_word(type(y)) || string(y)[0] != '\0' )
X	  Error(WARN, &fpos(y), "object deleted: cannot %s", KW_HSCALE);
X      }
X      else if( (scale_factor =
X	ScaleFactor(bc(constraint(x))+fc(constraint(x)), size(y, COL))) > 0 )
X      {	SaveGraphicState();
X	CoordTranslate(save_mark(x) - bc(constraint(x))
X	   + (LENGTH) (back(y, COL)*scale_factor), 0);
X	CoordScale(scale_factor, 1.0);
X        FixAndPrintObject(y, xmk, xb, xf, dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, pg, count);
X	RestoreGraphicState();
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case SCALE:
X
X      CountChild(y, Down(x), count);
X      if( dim == COL )
X      {
X	assert( bc(constraint(x)) > 0, "FAPO: horizontal scale factor!" );
X	save_mark(x) = xmk;
X	yb = xb * SF / bc(constraint(x));
X	yf = xf * SF / bc(constraint(x));
X        FixAndPrintObject(y, 0, yb, yf, dim, LAST_ADJUST, NO_SUPPRESS,
X		padj, pg, count);
X      }
X      else
X      {
X	assert( fc(constraint(x)) > 0, "FAPO: vertical scale factor!" );
X	yb = xb * SF / fc(constraint(x));
X	yf = xf * SF / fc(constraint(x));
X	SaveGraphicState();
X	CoordTranslate(save_mark(x), pg - xmk);
X	CoordScale( (float) bc(constraint(x))/SF, (float) fc(constraint(x))/SF);
X        FixAndPrintObject(y, 0, yb, yf, dim, LAST_ADJUST, NO_SUPPRESS,
X		padj,0,count);
X	RestoreGraphicState();
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case ROTATE:
X    
X      CountChild(y, Down(x), count);
X      if( dim == COL )
X      {	save_mark(x) = xmk;
X	back(x, dim) = xb;
X	fwd(x, dim)  = xf;
X      }
X      else
X      {
X	CONSTRAINT colc, rowc, yc;
X	back(x, dim) = xb;
X	fwd(x, dim)  = xf;
X	SetConstraint(colc, back(x,COL), MAX_LEN, fwd(x,COL));
X	SetConstraint(rowc, back(x,ROW), MAX_LEN, fwd(x,ROW));
X	RotateConstraint(&yc, y, sparec(constraint(x)), &colc, &rowc, COL);
X	FixAndPrintObject(y, 0, bc(yc), fc(yc), COL, LAST_ADJUST,
X		NO_SUPPRESS, padj, pg, count);
X	SaveGraphicState();
X	CoordTranslate(save_mark(x), pg - xmk);
X	CoordRotate(sparec(constraint(x)));
X	RotateConstraint(&yc, y, sparec(constraint(x)), &colc, &rowc, ROW);
X	FixAndPrintObject(y, 0, bc(yc), fc(yc), ROW, LAST_ADJUST,
X		NO_SUPPRESS, padj, 0, count);
X	RestoreGraphicState();
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case GRAPHIC:
X    
X      CountChild(y, LastDown(x), count);
X      if( dim == COL )
X      {
X	back(x, dim) = xb;
X	fwd(x, dim)  = xf;
X	debug2(DGP, DD, "GRAPHIC COL storing size %s, %s",
X	  EchoLength(back(x, dim)), EchoLength(fwd(x, dim)));
X	save_mark(x) = xmk - back(x, COL);
X        FixAndPrintObject(y, xb, xb, xf, dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, pg, count);
X      }
X      else
X      { OBJECT tmp, pre, post;
X        Child(tmp, Down(x));
X        if( type(tmp) == VCAT )
X        { Child(pre, Down(tmp));
X          Child(post, LastDown(tmp));
X        }
X        else pre = tmp, post = nil;
X	back(x, dim) = xb;
X	fwd(x, dim)  = xf;
X        SaveGraphicState();
X        CoordTranslate(save_mark(x), pg - (xmk + fwd(x, ROW)));
X	debug4(DGP, DD, "GRAPHIC ROW calling %s,%s %s,%s",
X	  EchoLength(back(x, COL)), EchoLength(fwd(x, COL)),
X	  EchoLength(back(x, ROW)), EchoLength(fwd(x, ROW)));
X        DefineGraphicNames(x);
X        SaveGraphicState();
X        PrintGraphicObject(pre);
X        RestoreGraphicState();
X        FixAndPrintObject(y, xb, xb, xf, dim, LAST_ADJUST,
X		NO_SUPPRESS, padj, xb + xf, count);
X        if( post != nil )  PrintGraphicObject(post);
X        RestoreGraphicState();
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X
X      CountChild(y, Down(x), count);
X      if( dim == COL )
X      {	save_mark(x) = xmk;
X      }
X      else if( sparec(constraint(x)) )
X      {
X	PrintGraphicInclude(x, save_mark(x), pg - xmk);
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case SPLIT:
X    
X      link = DownDim(x, dim);  CountChild(y, link, count);
X      FixAndPrintObject(y, xmk, xb, xf, dim, adjust, suppress, padj, pg, count);
X      back(x, dim) = back(y, dim);  fwd(x, dim) = fwd(y, dim);
X      break;
X
X
X    case VCAT:
X    case HCAT:
X
X      if( (type(x) == VCAT) == (dim == ROW) )
X      { 
X	/* find adjustment increment if required */
X	frame_size = xb + xf;
X	if( adjust == ALL_ADJUST && !suppress )
X	  inc = FindAdjustIncrement(x, frame_size, dim);
X	else inc = 0;
X
X	FirstDefinite(x, link, prev);
X	if( link != x )
X	{ back_edge = xmk - back(x, dim);
X	  mk = back_edge + back(prev, dim);
X	  NextDefiniteWithGap(x, link, y, g);
X	  while( link != x )
X	  {
X	    FixAndPrintObject(prev, mk, back(prev, dim), fwd(prev, dim) + inc,
X	      dim, adjust, NO_SUPPRESS, padj, pg, count);
X	    /* NB fwd(prev, dim) may be changed by the call to FAPO */
X	    mk += ActualGap(fwd(prev, dim), back(y, dim), fwd(y, dim), &gap(g),
X		    frame_size, mk - back_edge);
X	    prev = y;
X	    NextDefiniteWithGap(x, link, y, g);
X	  }
X	  if( suppress )
X	    FixAndPrintObject(prev, mk, back(prev, dim), fwd(prev, dim),
X	      dim, adjust, NO_SUPPRESS, padj, pg, count);
X	  else
X	    FixAndPrintObject(prev, mk, back(prev,dim),
X	      max(fwd(prev, dim), back_edge+frame_size-mk),
X	      dim, adjust, NO_SUPPRESS, padj, pg, count);
X	  back(x, dim) = max(back(x, dim), xb);
X	  fwd(x, dim) = mk + fwd(prev, dim) - back_edge - back(x, dim);
X	}
X	else back(x, dim) = xb, fwd(x, dim) = xf;
X      }
X      else
X      { OBJECT start_group, zlink, m;  BOOLEAN dble_found;  LENGTH b, f, dlen;
X	start_group = nil;  dble_found = FALSE;  dlen = 0;
X	debug0(DGP, DD, "  groups beginning.");
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{
X	  Child(y, link);
X	  debug1(DGP, DD, "  examining %s", EchoObject(y));
X	  if( is_index(type(y)) )  continue;
X	  if( type(y) == GAP_OBJ )
X	  { 
X	    assert( start_group != nil, "FAPO: start_group!" );
X	    if( !join(gap(y)) )
X	    { 
X	      /* finish off and fix this group */
X	      debug2(DGP, DD, "  finishing group: b = %s, f = %s",
X	        EchoLength(b), EchoLength(f));
X	      FixAndPrintObject(m, xmk+b, b, xf-b, dim, adjust,
X		      NO_SUPPRESS, padj, pg, count);
X	      b = back(m, dim);  f = fwd(m, dim);
X	      for( zlink = start_group;  zlink != link;  zlink=NextDown(zlink) )
X	      {	CountChild(z, zlink, count);
X		if( !is_definite(type(z)) || z == m )  continue;
X		FixAndPrintObject(z, xmk + b, b, xf - b, dim,
X		      adjust, SUPPRESS, padj, pg, count);
X		b = max(b, back(z, dim));  f = max(f, fwd(z, dim));
X	      }
X	      dlen = max(dlen, b + f);
X	      dble_found = TRUE;
X	      start_group = nil;
X	    }
X	  }
X	  else if( start_group == nil )
X	  {
X	    /* start new group */
X	    b = back(y, dim);
X	    f = fwd(y, dim);
X	    m = y;
X	    start_group = link;
X	    debug2(DGP, DD, "  starting group: b = %s, f = %s",
X	      EchoLength(b), EchoLength(f));
X	  }
X	  else
X	  {
X	    /* continue with current group */
X	    b = max(b, back(y, dim));
X	    f = max(f, fwd(y, dim));
X	    if( fwd(y, dim) > fwd(m, dim) )  m = y;
X	    debug2(DGP, DD, "  continuing group: b = %s, f = %s",
X	      EchoLength(b), EchoLength(f));
X	  }
X	}
X	assert( start_group != nil, "FAPO: final start_group!" );
X
X	if( dble_found )
X	{
X	  /* finish off and fix this last group */
X	  debug2(DGP, DD, "  finishing last group: b = %s, f = %s",
X	      EchoLength(b), EchoLength(f));
X	  FixAndPrintObject(m, xmk + b, b, xf - b, dim, adjust,
X		NO_SUPPRESS, padj, pg, count);
X	  b = back(m, dim);  f = fwd(m, dim);
X	  for( zlink = start_group;  zlink != link;  zlink = NextDown(zlink) )
X	  { CountChild(z, zlink, count);
X	    if( !is_definite(type(z)) || z == m )  continue;
X	    FixAndPrintObject(z, xmk + b, b, xf - b, dim, adjust,
X		SUPPRESS, padj, pg, count);
X	    b = max(b, back(z, dim));  f = max(f, fwd(z, dim));
X	  }
X	  dlen = max(dlen, b + f);
X	  back(x, dim) = 0;  fwd(x, dim) = dlen;
X	}
X	else
X	{
X	  /* finish off and fix this last and only group */
X	  debug2(DGP, DD, "  finishing last and only group: b = %s, f = %s",
X	      EchoLength(b), EchoLength(f));
X	  FixAndPrintObject(m, xmk, xb, xf, dim, adjust,
X		 NO_SUPPRESS, padj, pg, count);
X	  b = back(m, dim);  f = fwd(m, dim);
X	  for( zlink = start_group;  zlink != link;  zlink = NextDown(zlink) )
X	  { CountChild(z, zlink, count);
X	    if( !is_definite(type(z)) || z == m )  continue;
X	    FixAndPrintObject(z, xmk, xb, xf, dim, adjust,
X		SUPPRESS, padj, pg, count);
X	    b = max(b, back(z, dim));  f = max(f, fwd(z, dim));
X	  }
X	  back(x, dim) = b;  fwd(x, dim) = f;
X	}
X      }
X      break;
X
X
X    case ACAT:
X
X      if( dim == COL )
X      { BOOLEAN bad_gap;
X	LENGTH actual_size,
X	adjust_indent, frame_size, back_edge, adjust_inc, inc;
X	int adjustable_gaps;
X      
X
X	/*********************************************************************/
X	/*                                                                   */
X	/*  The first step is to calculate the following values:             */
X	/*                                                                   */
X	/*    bad_gap          TRUE if an adjust-preventing gap is found     */
X	/*                                                                   */
X	/*    actual_size      the actual size of x;                         */
X	/*                                                                   */
X	/*    adjustable_gaps  the number of gaps to the right of the        */
X	/*                     right-most tab gap.                           */
X	/*                                                                   */
X	/*  These make it easy to perform adjustment on a second pass, if    */
X	/*  required.                                                        */
X	/*                                                                   */
X	/*********************************************************************/
X
X	FirstDefinite(x, link, y);
X	if( link == x )  break;  /* no definite children, nothing to print */
X	bad_gap = FALSE;
X	adjustable_gaps = 0;
X	back_edge = xmk - xb;
X	mk = back_edge + back(y, dim);
X	frame_size = xb + xf;
X	prev = y;
X	NextDefiniteWithGap(x, link, y, g);
X	while( link != x )
X	{
X	  save_actual_gap(g) = ActualGap(fwd(prev, dim), back(y, dim),
X		fwd(y, dim), &gap(g), frame_size, mk - back_edge);
X	  mk += save_actual_gap(g);
X	  if( mode(gap(g)) == TAB_MODE || units(gap(g)) == AVAIL_UNIT
X				       || units(gap(g)) == FRAME_UNIT )
X	  { bad_gap = TRUE;
X	  }
X	  else if( width(gap(g)) > 0 )  adjustable_gaps += 1;
X	  prev = y;
X	  NextDefiniteWithGap(x, link, y, g);
X	}
X	actual_size = mk + fwd(prev, dim) - back_edge;
X
X	/*********************************************************************/
X	/*                                                                   */
X	/*  The second step is to work out whether adjusting is required     */
X	/*  or not, and if so by how much, using the following variables:    */
X	/*                                                                   */
X	/*    adjust_inc       The amount of adjustment to apply initially.  */
X	/*                                                                   */
X	/*    adjust_indent    initial indent for centring etc.              */
X	/*                                                                   */
X	/*  NB adjust_inc may be negative, if the optimal paragraph          */
X	/*  breaker has chosen to shrink some gaps.                          */
X	/*                                                                   */
X	/*********************************************************************/
X
X	adjust_indent = 0;
X	switch( display_style(save_style(x)) )
X	{
X	  case DO_ADJUST:	padj = ALL_ADJUST;
X				break;
X	
X	  case DISPLAY_CENTRE:	if( actual_size <= frame_size )
X				{ adjust_indent = (frame_size - actual_size)/2;
X				  padj = LAST_ADJUST;
X				}
X				else padj = ALL_ADJUST;
X				debug1(DGP, DD, "cdisp %s", EchoObject(x));
X				break;
X
X	  case DISPLAY_RIGHT:	if( actual_size <= frame_size )
X				{ adjust_indent = frame_size - actual_size;
X				  padj = LAST_ADJUST;
X				}
X				else padj = ALL_ADJUST;
X				debug1(DGP, DD, "rdisp %s", EchoObject(x));
X				break;
X	}
X
X	if( padj == ALL_ADJUST && adjustable_gaps > 0 && !bad_gap )
X	{ adjust_inc = (frame_size - actual_size) / adjustable_gaps;
X	  inc = max(adjust_inc, 0);
X	}
X	else adjust_inc = inc = 0;
X
X	debug2(DGP, DD, "ACAT %s %s",
X	  EchoStyle(&save_style(x)), EchoObject(x));
X	debug3(DGP,DD,"frame_size = %s, actual_size = %s, adjustable_gaps = %d",
X	  EchoLength(frame_size), EchoLength(actual_size), adjustable_gaps);
X	debug2(DGP,DD,"bad_gap = %s, adjust_inc = %s",
X	  bool(bad_gap), EchoLength(adjust_inc));
X
X	/*********************************************************************/
X	/*                                                                   */
X	/*  The third and final step is to traverse x, fixing subobjects.    */
X	/*                                                                   */
X	/*********************************************************************/
X
X	FirstDefinite(x, link, y);
X	prev = y;
X	mk = xmk - back(x, dim) + back(y, dim) + adjust_indent;
X	NextDefiniteWithGap(x, link, y, g);
X	while( link != x )
X	{
X	  /* fix previous definite now we know it is not the last one  */
X	  if( width(gap(g)) > 0 )
X	  { FixAndPrintObject(prev, mk, back(prev, dim), fwd(prev, dim) + inc,
X	      dim, adjust, NO_SUPPRESS, LAST_ADJUST, pg, count);
X	    mk += save_actual_gap(g) + adjust_inc;
X	  }
X	  else
X	  { FixAndPrintObject(prev, mk, back(prev, dim), fwd(prev, dim),
X	      dim, adjust, NO_SUPPRESS, LAST_ADJUST, pg, count);
X	    mk += save_actual_gap(g);
X	  }
X
X	  /* move on to next subobject */
X	  prev = y;
X	  NextDefiniteWithGap(x, link, y, g);
X	}
X
X	/* fix the last definite subobject, prev, which must exist */
X	FixAndPrintObject(prev, mk, back(prev, dim),
X	  frame_size - (mk - xmk) - back(x, dim),
X	  dim, adjust, NO_SUPPRESS, LAST_ADJUST, pg, count);
X      }
X      else for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	if( !is_definite(type(y)) )  continue;
X	FixAndPrintObject(y, xmk, xb, xf, dim, adjust, NO_SUPPRESS,
X		padj,pg,count);
X      }
X      back(x, dim) = xb;  fwd(x, dim) = xf;
X      break;
X
X
X    case COL_THR:
X    case ROW_THR:
X
X      /* find and delete the child number count of y */
X      assert( (type(x) == COL_THR) == (dim == COL), "FixAndPrintObject: thr!" );
X      for( link = Down(x), uplink = Up(x), i = 1;
X	link != x && uplink != x && i < count;
X	link = NextDown(link), uplink = NextUp(uplink), i++ );
X      assert( link != x && uplink != x, "FixAndPrintObject: link or uplink!" );
X      CountChild(y, link, count);
X      MoveLink(uplink, link, CHILD);  DeleteLink(link);  /* IMPORTANT!!! */
X      assert( type(y) != GAP_OBJ, "FAPO: THR!");
X
X      /* assign size if not done previously */
X      if( thr_state(x) != FINALSIZE )
X      {	back(x, dim) = xb;  fwd(x, dim) = xf;
X	thr_state(x) = FINALSIZE;
X      }
X
X      /* *** else been here before, size is already decided; do nothing
X      {	if( back(x, dim) > xb || fwd(x, dim) > xf )
X	{ Error(WARN, &fpos(y), "wrong %s chosen (sorry!)",
X		dim == COL ? "column width" : "row height");
X	  if( back(x, dim) > xb )  back(x, dim) = xb;
X	  if( fwd(x, dim)  > xf )  fwd(x, dim)  = xf;
X	}
X      }
X      *** */
X
X      /* fix y */
X      FixAndPrintObject(y, xmk, back(x, dim), fwd(x, dim), dim, LAST_ADJUST,
X	NO_SUPPRESS, padj, pg, count);
X      if( Up(x) == x )  Dispose(x);
X      break;
X
X
X    default:
X    
X      Error(INTERN, no_fpos, "FixAndPrint: found %s", Image(type(x)));
X      break;
X
X  } /* end switch */
X  debug2(DGP, D, "] FixAndPrintObject returning (size now %s,%s).",
X	EchoLength(back(x, dim)), EchoLength(fwd(x, dim)));
X} /* end FixAndPrintObject */
END_OF_FILE
  if test 28455 -ne `wc -c <'z23.c'`; then
    echo shar: \"'z23.c'\" unpacked with wrong size!
  fi
  # end of 'z23.c'
fi
if test -f 'z24.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z24.c'\"
else
  echo shar: Extracting \"'z24.c'\" \(33714 characters\)
  sed "s/^X//" >'z24.c' <<'END_OF_FILE'
X/*@z24.c:Print Service:PrintInit()@*******************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z24.c                                                      */
X/*  MODULE:       Print Service                                              */
X/*  EXTERNS:      PrintInit(), PrintPrologue(), PrintOriginIncrement(),      */
X/*                PrintWord(), PrintClose(), CoordTranslate(),               */
X/*                CoordRotate(), CoordScale(), SaveGraphicState(),           */
X/*                RestoreGraphicState(), PrintGraphicObject(),               */
X/*                DefineGraphicNames(), PrintGraphicInclude()                */
X/*                                                                           */
X/*  This module implements the PostScript back end.                          */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define DEFAULT_XHEIGHT 500
X#define	NO_FONT	0			/* actually stolen from z37.c        */
X
X#define printnum(x, fp)							\
X{ char buff[20];  register int i, y;					\
X  if( x >= 0 )  y = x;							\
X  else { y = -x; putc(CH_MINUS, fp); }					\
X  i = 0;								\
X  do { buff[i++] = numtodigitchar(y % 10);				\
X     } while( y = y / 10 );						\
X  do { putc(buff[--i], fp);						\
X     } while( i );							\
X}
X
Xstatic FILE	*out_fp;		/* output file                       */
Xstatic FONT_NUM	currentfont;		/* font of most recent atom          */
Xstatic short	currentxheight2;	/* half xheight in current font      */
Xstatic BOOLEAN	cpexists;		/* true if a current point exists    */
Xstatic LENGTH	currenty;		/* if cpexists, its y coordinate     */
Xstatic int	wordcount;		/* atoms printed since last newline  */
Xstatic int	pagecount;		/* total number of pages printed     */
Xstatic BOOLEAN	prologue_done;		/* TRUE after prologue is printed    */
Xstatic OBJECT	needs;			/* Resource needs of included EPSFs  */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  PrintInit(file_ptr)                                                      */
X/*                                                                           */
X/*  Initialise this module.  Output is to go to FILE file_ptr.               */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintInit(file_ptr)
XFILE *file_ptr;
X{ debug0(DFT, D, "PrintInit()");
X  out_fp = file_ptr;  prologue_done = FALSE;
X  currentfont = NO_FONT;  cpexists = FALSE;
X  wordcount = pagecount = 0;  needs = New(ACAT);
X  debug0(DFT, D, "PrintInit returning.");
X}
X
X
X/*@::PrintPrologue@***********************************************************/
X/*                                                                           */
X/*  PrintPrologue(h, v)                                                      */
X/*                                                                           */
X/*  Generate the standard PostScript prologue, augmented with any @Prologue  */
X/*  or @SysPrologue files specified by the user.                             */
X/*  The first non-empty page has width h and height v in Lout units.         */
X/*  The following PostScript operators are defined:                          */
X/*                                                                           */
X/*      scale_factor  fnt       scale and set font                           */
X/*      x_coordinate  x         move to x_coordinate, current y coordinate   */
X/*      string        s         show string                                  */
X/*      number        in        result is number inches                      */
X/*      number        cm        result is number centimetres                 */
X/*      number        pt        result is number points                      */
X/*      number        sp        result is number spaces                      */
X/*      number        vs        result is number vspaces                     */
X/*      number        ft        result is number font-sizes                  */
X/*                                                                           */
X/*  as well as LoutGraphic, for use with the @Graphic operator:              */
X/*                                                                           */
X/*      xsize ysize xmark ymark fr vs sp LoutGraphic -                       */
X/*                                                                           */
X/*  Define xmark, ymark, xsize, ysize to be the positions of                 */
X/*  these features of x, and define symbols ft, vs and sp                    */
X/*  to be the current font size, line separation, and space width.           */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintPrologue(h, v)
XLENGTH h, v;
X{ FILE_NUM fnum;
X  debug2(DGP, DD, "PrintPrologue: v = %d   h = %d", v, h);
X
X  /* print header comments for PostScript DSC 3.0 output */
X  if( Encapsulated )
X    fprintf(out_fp, "%%%!PS-Adobe-3.0 EPSF-3.0\n");
X  else
X    fprintf(out_fp, "%%%!PS-Adobe-3.0\n");
X  fprintf(out_fp, "%%%%Creator: %s\n", LOUT_VERSION);
X  fprintf(out_fp, "%%%%CreationDate: %s", TimeString());
X  fprintf(out_fp, "%%%%DocumentNeededResources: (atend)\n");
X  fprintf(out_fp, "%%%%Pages: (atend)\n");
X  fprintf(out_fp, "%%%%BoundingBox: 0 0 %d %d\n", h/PT, v/PT);
X  fprintf(out_fp, "%%%%EndComments\n\n");
X
X  /* print procedure definitions part of header */
X  fprintf(out_fp, "%%%%BeginProlog\n");
X  fprintf(out_fp, "%%%%BeginResource: procset LoutStartUp\n");
X  fprintf(out_fp, "/x { currentpoint exch pop moveto } def\n");
X  fprintf(out_fp, "/s { show } def\n");
X  fprintf(out_fp, "/in { %d mul } def\n", IN);
X  fprintf(out_fp, "/cm { %d mul } def\n", CM);
X  fprintf(out_fp, "/pt { %d mul } def\n", PT);
X  fprintf(out_fp, "/em { %d mul } def\n", EM);
X  fprintf(out_fp, "/sp { louts mul } def\n");
X  fprintf(out_fp, "/vs { loutv mul } def\n");
X  fprintf(out_fp, "/ft { loutf mul } def\n");
X  fprintf(out_fp, "/dg {           } def\n\n");
X
X  fputs("/LoutGraphic {\n",					  out_fp);
X  fputs("  /louts exch def\n",					  out_fp);
X  fputs("  /loutv exch def\n",					  out_fp);
X  fputs("  /loutf exch def\n",					  out_fp);
X  fputs("  /ymark exch def\n",					  out_fp);
X  fputs("  /xmark exch def\n",					  out_fp);
X  fputs("  /ysize exch def\n",					  out_fp);
X  fputs("  /xsize exch def\n} def\n\n",				  out_fp);
X
X  /* print definition used by Lout output to recode fonts                 */
X  /* adapted from PostScript Language Reference Manual (2nd Ed), page 275 */
X  /* usage: /<fullname> <encodingvector> /<originalname> LoutRecode -     */
X
X  fputs("/LoutFont\n",                                            out_fp);
X  fputs("{ findfont exch scalefont setfont\n",                    out_fp);
X  fputs("} bind def\n\n",					  out_fp);
X
X  fputs("/LoutRecode {\n",                                        out_fp);
X  fputs("  { findfont dup length dict begin\n",                   out_fp);
X  fputs("    {1 index /FID ne {def} {pop pop} ifelse} forall\n",  out_fp);
X  fputs("    /Encoding exch def\n",                               out_fp);
X  fputs("    currentdict end definefont pop\n",                   out_fp);
X  fputs("  }\n",                                                  out_fp);
X  fputs("  stopped {}\n",                                         out_fp);
X  fputs("} bind def\n\n",                                         out_fp);
X
X  /* print definitions used by Lout output when including EPSF files      */
X  /* copied from PostScript Language Reference Manual (2nd Ed.), page 726 */
X
X  fputs("/BeginEPSF {\n",					  out_fp);
X  fputs("  /LoutEPSFState save def\n",				  out_fp);
X  fputs("  /dict_count countdictstack def\n",			  out_fp);
X  fputs("  /op_count count 1 sub def\n",			  out_fp);
X  fputs("  userdict begin\n",					  out_fp);
X  fputs("  /showpage { } def\n",				  out_fp);
X  fputs("  0 setgray 0 setlinecap\n",				  out_fp);
X  fputs("  1 setlinewidth 0 setlinejoin\n",			  out_fp);
X  fputs("  10 setmiterlimit [] 0 setdash newpath\n",		  out_fp);
X  fputs("  /languagelevel where\n",				  out_fp);
X  fputs("  { pop languagelevel\n",				  out_fp);
X  fputs("    1 ne\n",						  out_fp);
X  fputs("    { false setstrokeadjust false setoverprint\n",	  out_fp);
X  fputs("    } if\n",						  out_fp);
X  fputs("  } if\n",						  out_fp);
X  fputs("} bind def\n\n",					  out_fp);
X
X  fputs("/EndEPSF {\n",						  out_fp);
X  fputs("  count op_count sub { pop } repeat\n",		  out_fp);
X  fputs("  countdictstack dict_count sub { end } repeat\n",	  out_fp);
X  fputs("  LoutEPSFState restore\n",				  out_fp);
X  fputs("} bind def\n",						  out_fp);
X
X  fputs("%%EndResource\n\n",					  out_fp);
X
X  /* print encoding vectors and font recoding commands */
X  EvPrintAll(out_fp);
X  FontPrintAll(out_fp);
X
X  /* print prepend files (assumed to be organized as DSC 3.0 Resources) */
X  for( fnum=FirstFile(PREPEND_FILE);  fnum != NO_FILE;  fnum=NextFile(fnum) )
X  { FULL_CHAR buff[MAX_LINE];  FILE *fp;
X    if( (fp = OpenFile(fnum, FALSE, FALSE)) == null )
X      Error(WARN, PosOfFile(fnum), "cannot open %s file %s",
X	KW_PREPEND, FileName(fnum));
X    else if( StringFGets(buff, MAX_LINE, fp) == NULL )
X      Error(WARN, PosOfFile(fnum), "%s file %s is empty",
X	KW_PREPEND, FileName(fnum));
X    else
X    {
X      if( !StringBeginsWith(buff, AsciiToFull("%%BeginResource:")) )
X	Error(WARN, PosOfFile(fnum),
X	  "%s file %s lacks PostScript DSC 3.0 \"%%%%BeginResource:\" comment",
X	  KW_PREPEND, FileName(fnum));
X      StringFPuts(buff, out_fp);
X      fprintf(out_fp, "\n%% %s file %s\n", KW_PREPEND, FileName(fnum));
X      while( StringFGets(buff, MAX_LINE, fp) != NULL )
X	StringFPuts(buff, out_fp);
X    }
X  }
X
X  fputs("\n%%EndProlog\n\n", out_fp);
X  fprintf(out_fp, "%%%%Page: ? %d\n", ++pagecount);
X  fprintf(out_fp, "%%%%BeginPageSetup\n");
X  fprintf(out_fp, "/pgsave save def\n");
X  fprintf(out_fp, "%.4f dup scale %d setlinewidth\n", 1.0 / PT, PT/2);
X  fprintf(out_fp, "%%%%EndPageSetup\n");
X  prologue_done = TRUE;
X} /* end PrintPrologue */
X
X
X/*@::PrintOriginIncrement(), EightBitsToPrintForm[]@**************************/
X/*                                                                           */
X/*  PrintOriginIncrement(y)                                                  */
X/*                                                                           */
X/*  Move current vertical origin down by y.                                  */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintOriginIncrement(y)
XLENGTH y;
X{ debug1(DGP, D, "PrintOriginIncrement( %d )", y );
X  fprintf(out_fp, "\npgsave restore\nshowpage\n");
X  cpexists = FALSE;
X  currentfont = NO_FONT;
X  if( Encapsulated )
X  { PrintClose();
X    Error(FATAL, no_fpos, "truncating -EPS document at end of first page");
X  }
X  fprintf(out_fp, "\n%%%%Page: ? %d\n", ++pagecount);
X  fprintf(out_fp, "%%%%BeginPageSetup\n");
X  fprintf(out_fp, "/pgsave save def\n");
X  fprintf(out_fp, "%.4f dup scale %d setlinewidth\n", 1.0 / PT, PT/2);
X  fprintf(out_fp, "%%%%EndPageSetup\n");
X  wordcount = 0;
X}
X
X/*@::EightBitToPrintForm()@***************************************************/
X/*                                                                           */
X/*  static char *EightBitToPrintForm[]                                       */
X/*                                                                           */
X/*  Given 8-bit character i, returns a string of characters that will be     */
X/*  interpreted by PostScript as character i when read within a string.      */
X/*                                                                           */
X/*      CHAR_OUT==1    Printable ASCII literal, others as escape sequences   */
X/*      CHAR_OUT==2    Printable ISO-LATIN-1 literal, others escaped         */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic char *EightBitToPrintForm[] = {
X#if CHAR_OUT==0
X    "",      "\\001", "\\002", "\\003", "\\004", "\\005", "\\006", "\\007",
X    "\\010", "\\011", "\\012", "\\013", "\\014", "\\015", "\\016", "\\017",
X    "\\020", "\\021", "\\022", "\\023", "\\024", "\\025", "\\026", "\\027",
X    "\\030", "\\031", "\\032", "\\033", "\\034", "\\035", "\\036", "\\037",
X    " ",     "!",     "\"",    "#",     "$",     "%",     "&",     "'",
X    "\\(",   "\\)",   "*",     "+",     ",",     "-",     ".",     "/",
X    "0",     "1",     "2",     "3",     "4",     "5",     "6",     "7",
X    "8",     "9",     ":",     ";",     "<",     "=",     ">",     "?",
X    "@",     "A",     "B",     "C",     "D",     "E",     "F",     "G",
X    "H",     "I",     "J",     "K",     "L",     "M",     "N",     "O",
X    "P",     "Q",     "R",     "S",     "T",     "U",     "V",     "W",
X    "X",     "Y",     "Z",     "[",     "\\\\",  "]",     "^",     "_",
X    "`",     "a",     "b",     "c",     "d",     "e",     "f",     "g",
X    "h",     "i",     "j",     "k",     "l",     "m",     "n",     "o",
X    "p",     "q",     "r",     "s",     "t",     "u",     "v",     "w",
X    "x",     "y",     "z",     "{",     "|",     "}",     "~",     "\\177",
X    "\\200", "\\201", "\\202", "\\203", "\\204", "\\205", "\\206", "\\207",
X    "\\210", "\\211", "\\212", "\\213", "\\214", "\\215", "\\216", "\\217",
X    "\\220", "\\221", "\\222", "\\223", "\\224", "\\225", "\\226", "\\227",
X    "\\230", "\\231", "\\232", "\\233", "\\234", "\\235", "\\236", "\\237",
X    "\\240", "\\241", "\\242", "\\243", "\\244", "\\245", "\\246", "\\247",
X    "\\250", "\\251", "\\252", "\\253", "\\254", "\\255", "\\256", "\\257",
X    "\\260", "\\261", "\\262", "\\263", "\\264", "\\265", "\\266", "\\267",
X    "\\270", "\\271", "\\272", "\\273", "\\274", "\\275", "\\276", "\\277",
X    "\\300", "\\301", "\\302", "\\303", "\\304", "\\305", "\\306", "\\307",
X    "\\310", "\\311", "\\312", "\\313", "\\314", "\\315", "\\316", "\\317",
X    "\\320", "\\321", "\\322", "\\323", "\\324", "\\325", "\\326", "\\327",
X    "\\330", "\\331", "\\332", "\\333", "\\334", "\\335", "\\336", "\\337",
X    "\\340", "\\341", "\\342", "\\343", "\\344", "\\345", "\\346", "\\347",
X    "\\350", "\\351", "\\352", "\\353", "\\354", "\\355", "\\356", "\\357",
X    "\\360", "\\361", "\\362", "\\363", "\\364", "\\365", "\\366", "\\367",
X    "\\370", "\\371", "\\372", "\\373", "\\374", "\\375", "\\376", "\\377"
X#else
X#if CHAR_OUT==1
X    "",      "\\001", "\\002", "\\003", "\\004", "\\005", "\\006", "\\007",
X    "\\010", "\\011", "\\012", "\\013", "\\014", "\\015", "\\016", "\\017",
X    "\\020", "\\021", "\\022", "\\023", "\\024", "\\025", "\\026", "\\027",
X    "\\030", "\\031", "\\032", "\\033", "\\034", "\\035", "\\036", "\\037",
X    " ",     "!",     "\"",    "#",     "$",     "%",     "&",     "'",
X    "\\(",   "\\)",   "*",     "+",     ",",     "-",     ".",     "/",
X    "0",     "1",     "2",     "3",     "4",     "5",     "6",     "7",
X    "8",     "9",     ":",     ";",     "<",     "=",     ">",     "?",
X    "@",     "A",     "B",     "C",     "D",     "E",     "F",     "G",
X    "H",     "I",     "J",     "K",     "L",     "M",     "N",     "O",
X    "P",     "Q",     "R",     "S",     "T",     "U",     "V",     "W",
X    "X",     "Y",     "Z",     "[",     "\\\\",  "]",     "^",     "_",
X    "`",     "a",     "b",     "c",     "d",     "e",     "f",     "g",
X    "h",     "i",     "j",     "k",     "l",     "m",     "n",     "o",
X    "p",     "q",     "r",     "s",     "t",     "u",     "v",     "w",
X    "x",     "y",     "z",     "{",     "|",     "}",     "~",     "\\177",
X    "\\200", "\\201", "\\202", "\\203", "\\204", "\\205", "\\206", "\\207",
X    "\\210", "\\211", "\\212", "\\213", "\\214", "\\215", "\\216", "\\217",
X    "\220",  "\221",  "\222",  "\223",  "\224",  "\225",  "\226",  "\227",
X    "\230",  "\\231", "\232",  "\233",  "\\234", "\235",  "\236",  "\237",
X    "\240",  "\241",  "\242",  "\243",  "\244",  "\245",  "\246",  "\247",
X    "\250",  "\251",  "\252",  "\253",  "\254",  "\255",  "\256",  "\257",
X    "\260",  "\261",  "\262",  "\263",  "\264",  "\265",  "\266",  "\267",
X    "\270",  "\271",  "\272",  "\273",  "\274",  "\275",  "\276",  "\277",
X    "\300",  "\301",  "\302",  "\303",  "\304",  "\305",  "\306",  "\307",
X    "\310",  "\311",  "\312",  "\313",  "\314",  "\315",  "\316",  "\317",
X    "\320",  "\321",  "\322",  "\323",  "\324",  "\325",  "\326",  "\327",
X    "\330",  "\331",  "\332",  "\333",  "\334",  "\335",  "\336",  "\337",
X    "\340",  "\341",  "\342",  "\343",  "\344",  "\345",  "\346",  "\347",
X    "\350",  "\351",  "\352",  "\353",  "\354",  "\355",  "\356",  "\357",
X    "\360",  "\361",  "\362",  "\363",  "\364",  "\365",  "\366",  "\367",
X    "\370",  "\371",  "\372",  "\373",  "\374",  "\375",  "\376",  "\377"
X#else
XIf you are trying to compile this you have the wrong CHAR_OUT value!
X#endif
X#endif
X};
X
X/*@::PrintWord()@*************************************************************/
X/*                                                                           */
X/*  PrintWord(x, hpos, vpos)                                                 */
X/*                                                                           */
X/*  Print word x; its marks cross at the point (hpos, vpos).                 */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintWord(x, hpos, vpos)
XOBJECT x;  int hpos, vpos;
X{ FULL_CHAR *p;
X
X  debug4(DGP, DD, "PrintWord( %s, %d, %d ) font %d", string(x),
X	hpos, vpos, word_font(x));
X
X  /* if font is different to previous word then print change */
X  if( word_font(x) != currentfont )
X  { currentfont = word_font(x);
X    currentxheight2 = FontHalfXHeight(currentfont);
X    fprintf(out_fp, "\n%hd %s\n", FontSize(currentfont, x), FontName(currentfont));
X  }
X
X  /* move to coordinate of x */
X  debug1(DGP, DDD, "  currentxheight2 = %d", currentxheight2);
X  vpos = vpos - currentxheight2;
X  if( cpexists && currenty == vpos )
X  { printnum(hpos, out_fp);
X    fputs(" x", out_fp);
X  }
X  else
X  { currenty = vpos;
X    printnum(hpos, out_fp);
X    fputs(" ", out_fp);
X    printnum(currenty, out_fp);
X    fputs(" moveto", out_fp);
X    cpexists = TRUE;
X  }
X
X  /* show string(x) */
X  fputs("(", out_fp);
X  for( p = string(x);  *p;  p++ )  fputs(EightBitToPrintForm[*p], out_fp);
X  if( ++wordcount >= 5 )
X  { fputs(")s\n", out_fp);  wordcount = 0;
X  }
X  else fputs(")s ", out_fp);
X
X  debug0(DGP, DDD, "PrintWord returning");
X} /* end PrintWord */
X
X
X/*@::PrintClose(), CoordTranslate()@******************************************/
X/*                                                                           */
X/*  PrintClose()                                                             */
X/*                                                                           */
X/*  Clean up this module and close output stream.                            */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintClose()
X{ OBJECT x, link;  BOOLEAN first_need;
X  if( prologue_done )
X  { fprintf(out_fp, "\npgsave restore\nshowpage\n");
X    fprintf(out_fp, "%%%%Trailer\n");
X
X    /* print document fonts line */
X    /* *** obsolete DSC 1.0 version
X    fprintf(out_fp, "%%%%DocumentFonts:");
X    for( link = Down(font_root); link != font_root; link = NextDown(link) )
X    { OBJECT flink, family, face;
X      Child(family, link);
X      for( flink = Down(family);  flink != family;  flink = NextDown(flink) )
X      {	Child(face, flink);
X	if( LastDown(face) != Down(face) )
X	{ Child(x, LastDown(face));
X	  fprintf(out_fp, " %s", string(x));
X	}
X      }
X    }
X    fprintf(out_fp, "\n");
X    *** */
X
X    /* print resource requirements (DSC 3.0 version) - fonts */
X    first_need = FontNeeded(out_fp);
X
X    /* print resource requirements (DSC 3.0 version) - included EPSFs  */
X    for( link = Down(needs); link != needs; link = NextDown(link) )
X    { Child(x, link);
X      assert(is_word(type(x)), "PrintClose: needs!" );
X      fprintf(out_fp, "%s %s",
X	first_need ? "%%DocumentNeededResources:" : "%%+", string(x));
X      first_need = FALSE;
X    }
X
X    fprintf(out_fp, "%%%%Pages: %d\n", pagecount);
X    fprintf(out_fp, "%%%%EOF\n");
X  }
X} /* end PrintClose */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  CoordTranslate(xdist, ydist)                                             */
X/*                                                                           */
X/*  Translate coordinate system by the given x and y distances.              */
X/*                                                                           */
X/*****************************************************************************/
X
XCoordTranslate(xdist, ydist)
XLENGTH xdist, ydist;
X{ debug2(DRS,D,"CoordTranslate(%s, %s)",
X    EchoLength(xdist), EchoLength(ydist));
X  fprintf(out_fp, "%d %d translate\n", xdist, ydist);
X  cpexists = FALSE;  currentfont = NO_FONT;
X  debug0(DRS, D, "CoordTranslate returning.");
X} /* end CoordTranslate */
X
X/*@::CoordRotate(), CoordScale(), SaveGraphicsState(), etc.@******************/
X/*                                                                           */
X/*  CoordRotate(amount)                                                      */
X/*                                                                           */
X/*  Rotate coordinate system by given amount (in internal DG units)          */
X/*                                                                           */
X/*****************************************************************************/
X
XCoordRotate(amount)
XLENGTH amount;
X{ debug1(DRS, D, "CoordRotate(%.1f degrees)", (float) amount / DG);
X  fprintf(out_fp, "%.4f rotate\n", (float) amount / DG);
X  cpexists = FALSE;
X  currentfont = NO_FONT;
X  debug0(DRS, D, "CoordRotate returning.");
X} /* end CoordRotate */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  CoordScale(ratio, dim)                                                   */
X/*                                                                           */
X/*  Scale coordinate system by ratio in the given dimension.                 */
X/*                                                                           */
X/*****************************************************************************/
X
XCoordScale(hfactor, vfactor)
Xfloat hfactor, vfactor;
X{ char buff[20];
X  ifdebug(DRS, D, sprintf(buff, "%.3f, %.3f", hfactor, vfactor));
X  debug1(DRS, D, "CoordScale(%s)", buff);
X  fprintf(out_fp, "%.4f %.4f scale\n", hfactor, vfactor);
X  cpexists = FALSE;
X  currentfont = NO_FONT;
X  debug0(DRS, D, "CoordScale returning.");
X} /* end CoordScale */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  SaveGraphicState()                                                       */
X/*                                                                           */
X/*  Save current coord system on stack for later restoration.                */
X/*                                                                           */
X/*****************************************************************************/
X
XSaveGraphicState()
X{ debug0(DRS, D, "SaveGraphicState()");
X  fprintf(out_fp, "gsave\n");
X  debug0(DRS, D, "SaveGraphicState returning.");
X} /* end SaveGraphicState */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  RestoreGraphicState()                                                    */
X/*                                                                           */
X/*  Restore previously saved coordinate system.  NB we normally assume that  */
X/*  no white space is needed before any item of output, but since this       */
X/*  procedure is sometimes called immediately after PrintGraphicObject(),    */
X/*  which does not append a concluding space, we prepend one here.           */
X/*                                                                           */
X/*****************************************************************************/
X
XRestoreGraphicState()
X{ debug0(DRS, D, "RestoreGraphicState()");
X  fprintf(out_fp, "\ngrestore\n");
X  cpexists = FALSE;
X  currentfont = NO_FONT;
X  debug0(DRS, D, "RestoreGraphicState returning.");
X} /* end RestoreGraphicState */
X
X
X/*@::PrintGraphicObject(), DefineGraphicNames()@******************************/
X/*                                                                           */
X/*  PrintGraphicObject(x)                                                    */
X/*                                                                           */
X/*  Print object x on out_fp                                                 */
X/*                                                                           */
X/*****************************************************************************/
X
XPrintGraphicObject(x)
XOBJECT x;
X{ OBJECT y, link;
X  switch( type(x) )
X  {
X    case WORD:
X    case QWORD:
X    
X      StringFPuts(string(x), out_fp);
X      break;
X	
X
X    case ACAT:
X    
X      for( link = Down(x);  link != x;  link = NextDown(link) )
X      {	Child(y, link);
X	if( type(y) == GAP_OBJ )
X	{ if( vspace(y) > 0 )  fputs("\n", out_fp);
X	  else if( hspace(y) > 0 ) fputs(" ", out_fp);
X	}
X	else if( is_word(type(y)) || type(y) == ACAT )  PrintGraphicObject(y);
X	else if( type(y) != WIDE && !is_index(type(y)) )
X		/* @Wide, indexes are sometimes inserted by Manifest */
X	{ Error(WARN, &fpos(x), "error in left parameter of %s", KW_GRAPHIC);
X	  debug1(DGP, D, "  type(y) = %s, y =", Image(type(y)));
X	  ifdebug(DGP, D, DebugObject(y));
X	}
X      }
X      break;
X
X
X    default:
X    
X      Error(WARN, &fpos(x), "error in left parameter of %s", KW_GRAPHIC);
X      debug1(DGP, D, "  type(x) = %s, x =", Image(type(x)));
X      ifdebug(DGP, D, DebugObject(x));
X      break;
X  }
X} /* end PrintGraphicObject */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  DefineGraphicNames(x)                                                    */
X/*                                                                           */
X/*  Generate PostScript for xsize, ysize etc. names of graphic object.       */
X/*                                                                           */
X/*****************************************************************************/
X
XDefineGraphicNames(x)
XOBJECT x;
X{ assert( type(x) == GRAPHIC, "PrintGraphic: type(x) != GRAPHIC!" );
X  debug1(DRS, D, "DefineGraphicNames( %s )", EchoObject(x));
X  debug1(DRS, DD, "  style = %s", EchoStyle(&save_style(x)));
X
X  fprintf(out_fp, "%d %d %d %d %d %d %d LoutGraphic\n",
X    size(x, COL), size(x, ROW), back(x, COL), fwd(x, ROW),
X    font(save_style(x)) <= 0 ? 12*PT : FontSize(font(save_style(x)), x),
X    width(line_gap(save_style(x))), width(space_gap(save_style(x))));
X
X  debug0(DRS, D, "DefineGraphicNames returning.");
X} /* end DefineGraphicNames */
X
X
X/*@::PrintGraphicIncldue()@***************************************************/
X/*                                                                           */
X/*  PrintGraphicInclude(x, colmark, rowmark)                                 */
X/*                                                                           */
X/*  Print graphic include file, with appropriate surrounds.  This code       */
X/*  closely follows the PostScript Language Reference Manual, 2n ed.,        */
X/*  pages 733-5, except we do not clip the included EPSF.                    */
X/*                                                                           */
X/*  Note to porters: Version 3.0 of the EPSF standard is not compatible      */
X/*  with previous versions.  Thus, this output may crash your system.        */
X/*  If you can find out which comment line(s) are causing the trouble,       */
X/*  you can add to procedure strip_out to strip them out during the          */
X/*  file inclusion step.  e.g. on my system %%EOF causes problems, so I      */
X/*  strip it out.                                                            */
X/*                                                                           */
X/*****************************************************************************/
X#define	SKIPPING	0
X#define	READING_DNR	1
X#define FINISHED	2
X
Xstatic BOOLEAN strip_out(buff)
XFULL_CHAR *buff;
X{ if( StringBeginsWith(buff, AsciiToFull("%%EOF")) )  return TRUE;
X  return FALSE;
X} /* end strip_out */
X
XPrintGraphicInclude(x, colmark, rowmark)
XOBJECT x; LENGTH colmark, rowmark;
X{ OBJECT y, full_name;  FULL_CHAR buff[MAX_LINE];
X  FILE *fp;  int state;
X  debug0(DRS, D, "PrintGraphicInclude(x)");
X  assert(type(x)==INCGRAPHIC || type(x)==SINCGRAPHIC, "PrintGraphicInclude!");
X  assert(sparec(constraint(x)), "PrintGraphicInclude: sparec(constraint(x))!");
X
X  /* open the include file and get its full path name */
X  Child(y, Down(x));
X  fp = OpenIncGraphicFile(string(y), type(x), &full_name, &fpos(y));
X  assert( fp != NULL, "PrintGraphicInclude: fp!" );
X
X  /* generate appropriate header code */
X  fprintf(out_fp, "BeginEPSF\n");
X  CoordTranslate(colmark - back(x, COL), rowmark - fwd(x, ROW));
X  CoordScale( (float) PT, (float) PT );
X  CoordTranslate(-back(y, COL), -back(y, ROW));
X  fprintf(out_fp, "%%%%BeginDocument: %s\n", string(full_name));
X
X  /* copy through the include file, except divert resources lines to needs */
X  /* and strip out some comment lines that cause problems                  */
X  state = (StringFGets(buff, MAX_LINE, fp) == NULL) ? FINISHED : SKIPPING;
X  while( state != FINISHED ) switch(state)
X  {
X    case SKIPPING:
X
X      if( StringBeginsWith(buff, AsciiToFull("%%DocumentNeededResources:")) &&
X	  !StringContains(buff, AsciiToFull("(atend)")) )
X      { x = MakeWord(WORD, &buff[StringLength("%%DocumentNeededResources:")],
X	      no_fpos);
X        Link(needs, x);
X	state = (StringFGets(buff,MAX_LINE,fp)==NULL) ? FINISHED : READING_DNR;
X      }
X      else
X      { if( StringBeginsWith(buff, AsciiToFull("%%LanguageLevel:")) )
X	  Error(WARN, &fpos(x), "ignoring \"%%%%LanguageLevel\" in %s file %s",
X		KW_INCGRAPHIC, string(full_name));
X	if( StringBeginsWith(buff, AsciiToFull("%%Extensions:")) )
X	  Error(WARN, &fpos(x), "ignoring \"%%%%Extensions\" in %s file %s",
X		KW_INCGRAPHIC, string(full_name));
X	if( !strip_out(buff) )  StringFPuts(buff, out_fp);
X	state = (StringFGets(buff, MAX_LINE, fp) == NULL) ? FINISHED : SKIPPING;
X      }
X      break;
X
X    case READING_DNR:
X
X      if( StringBeginsWith(buff, AsciiToFull("%%+")) )
X      {	x = MakeWord(WORD, &buff[StringLength(AsciiToFull("%%+"))], no_fpos);
X	Link(needs, x);
X	state = (StringFGets(buff,MAX_LINE,fp)==NULL) ? FINISHED : READING_DNR;
X      }
X      else
X      { if( !strip_out(buff) )  StringFPuts(buff, out_fp);
X	state = (StringFGets(buff, MAX_LINE, fp) == NULL) ? FINISHED : SKIPPING;
X      }
X      break;
X  }
X
X  /* wrapup */
X  DisposeObject(full_name);
X  fclose(fp);
X  fprintf(out_fp, "%%%%EndDocument\nEndEPSF\n");
X  debug0(DRS, D, "PrintGraphicInclude returning.");
X} /* end PrintGraphicInclude */
END_OF_FILE
  if test 33714 -ne `wc -c <'z24.c'`; then
    echo shar: \"'z24.c'\" unpacked with wrong size!
  fi
  # end of 'z24.c'
fi
echo shar: End of archive 10 \(of 35\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
