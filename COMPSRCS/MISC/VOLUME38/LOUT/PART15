Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i083:  lout - Lout document formatting system, v2.05, Part15/35
Message-ID: <1993Aug10.032724.17211@sparky.sterling.com>
X-Md4-Signature: 176c9313a8fc7ad923b53f03088d6898
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 03:27:24 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 83
Archive-name: lout/part15
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  font/TimesBolIta.AFM z12.c z13.c z18.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:25 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 15 (of 35)."'
if test -f 'font/TimesBolIta.AFM' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'font/TimesBolIta.AFM'\"
else
  echo shar: Extracting \"'font/TimesBolIta.AFM'\" \(14435 characters\)
  sed "s/^X//" >'font/TimesBolIta.AFM' <<'END_OF_FILE'
XStartFontMetrics 2.0
XComment Copyright (c) 1984 Adobe Systems Incorporated.  All Rights Reserved.
XComment Creation Date:Wed May 27 16:42:35 PDT 1987
XFontName Times-BoldItalic
XEncodingScheme AdobeStandardEncoding
XFullName Times Bold Italic
XFamilyName Times
XWeight Bold
XItalicAngle -15.0
XIsFixedPitch false
XUnderlinePosition -98
XUnderlineThickness 54
XVersion 001.004
XNotice Times is a registered trademark of Allied Corporation.
XFontBBox -168 -232 1014 894
XCapHeight 662
XXHeight 458
XDescender -203
XAscender 682
XStartCharMetrics 228
XC 32 ; WX 250 ; N space ; B 0 0 0 0 ;
XC 33 ; WX 389 ; N exclam ; B 66 -13 367 676 ;
XC 34 ; WX 555 ; N quotedbl ; B 142 367 549 693 ;
XC 35 ; WX 500 ; N numbersign ; B 4 0 496 662 ;
XC 36 ; WX 500 ; N dollar ; B -20 -101 492 723 ;
XC 37 ; WX 833 ; N percent ; B 39 -8 784 685 ;
XC 38 ; WX 778 ; N ampersand ; B 41 -19 727 676 ;
XC 39 ; WX 333 ; N quoteright ; B 80 362 282 675 ;
XC 40 ; WX 333 ; N parenleft ; B 28 -179 340 676 ;
XC 41 ; WX 333 ; N parenright ; B -44 -179 268 676 ;
XC 42 ; WX 500 ; N asterisk ; B 56 244 445 676 ;
XC 43 ; WX 570 ; N plus ; B 33 0 537 505 ;
XC 44 ; WX 250 ; N comma ; B -10 -181 192 132 ;
XC 45 ; WX 333 ; N hyphen ; B 33 167 299 282 ;
XC 46 ; WX 250 ; N period ; B 23 -13 170 133 ;
XC 47 ; WX 278 ; N slash ; B -11 -18 289 682 ;
XC 48 ; WX 500 ; N zero ; B 17 -13 472 676 ;
XC 49 ; WX 500 ; N one ; B 5 0 415 676 ;
XC 50 ; WX 500 ; N two ; B -27 0 441 676 ;
XC 51 ; WX 500 ; N three ; B -15 -13 445 676 ;
XC 52 ; WX 500 ; N four ; B -15 0 498 676 ;
XC 53 ; WX 500 ; N five ; B -11 -13 482 662 ;
XC 54 ; WX 500 ; N six ; B 23 -13 504 676 ;
XC 55 ; WX 500 ; N seven ; B 51 0 519 662 ;
XC 56 ; WX 500 ; N eight ; B 3 -13 471 676 ;
XC 57 ; WX 500 ; N nine ; B -12 -13 470 676 ;
XC 58 ; WX 333 ; N colon ; B 52 -13 291 458 ;
XC 59 ; WX 333 ; N semicolon ; B 13 -181 291 458 ;
XC 60 ; WX 570 ; N less ; B 31 -14 540 524 ;
XC 61 ; WX 570 ; N equal ; B 33 116 537 401 ;
XC 62 ; WX 570 ; N greater ; B 31 -14 540 524 ;
XC 63 ; WX 500 ; N question ; B 78 -13 465 676 ;
XC 64 ; WX 832 ; N at ; B -9 -150 838 691 ;
XC 65 ; WX 667 ; N A ; B -51 0 602 676 ;
XC 66 ; WX 667 ; N B ; B -24 0 618 662 ;
XC 67 ; WX 667 ; N C ; B 22 -18 660 677 ;
XC 68 ; WX 722 ; N D ; B -31 0 693 662 ;
XC 69 ; WX 667 ; N E ; B -27 0 646 662 ;
XC 70 ; WX 667 ; N F ; B -20 0 646 662 ;
XC 71 ; WX 722 ; N G ; B 21 -18 699 676 ;
XC 72 ; WX 778 ; N H ; B -24 0 791 662 ;
XC 73 ; WX 389 ; N I ; B -22 0 412 662 ;
XC 74 ; WX 500 ; N J ; B -45 -98 519 662 ;
XC 75 ; WX 667 ; N K ; B -31 0 685 662 ;
XC 76 ; WX 611 ; N L ; B -22 0 584 662 ;
XC 77 ; WX 889 ; N M ; B -29 -12 907 662 ;
XC 78 ; WX 722 ; N N ; B -27 -18 740 662 ;
XC 79 ; WX 722 ; N O ; B 27 -18 684 676 ;
XC 80 ; WX 611 ; N P ; B -27 0 608 662 ;
XC 81 ; WX 722 ; N Q ; B 27 -203 684 676 ;
XC 82 ; WX 667 ; N R ; B -29 0 616 662 ;
XC 83 ; WX 556 ; N S ; B 6 -18 524 676 ;
XC 84 ; WX 611 ; N T ; B 39 0 632 662 ;
XC 85 ; WX 722 ; N U ; B 66 -18 736 662 ;
XC 86 ; WX 667 ; N V ; B 48 -18 692 662 ;
XC 87 ; WX 889 ; N W ; B 48 -18 914 662 ;
XC 88 ; WX 667 ; N X ; B -24 0 687 662 ;
XC 89 ; WX 611 ; N Y ; B 46 0 625 662 ;
XC 90 ; WX 611 ; N Z ; B -1 0 594 662 ;
XC 91 ; WX 333 ; N bracketleft ; B -7 -157 388 682 ;
XC 92 ; WX 278 ; N backslash ; B 1 0 465 682 ;
XC 93 ; WX 333 ; N bracketright ; B -65 -157 330 682 ;
XC 94 ; WX 570 ; N asciicircum ; B 34 259 536 662 ;
XC 95 ; WX 500 ; N underscore ; B 0 -127 500 -89 ;
XC 96 ; WX 333 ; N quoteleft ; B 117 363 319 676 ;
XC 97 ; WX 500 ; N a ; B 9 -14 480 458 ;
XC 98 ; WX 500 ; N b ; B 20 -13 473 682 ;
XC 99 ; WX 444 ; N c ; B 25 -13 418 458 ;
XC 100 ; WX 500 ; N d ; B 9 -13 541 682 ;
XC 101 ; WX 444 ; N e ; B 25 -13 413 458 ;
XC 102 ; WX 333 ; N f ; B -146 -203 460 682 ; L i fi ; L l fl ;
XC 103 ; WX 500 ; N g ; B -27 -203 498 458 ;
XC 104 ; WX 556 ; N h ; B 12 -13 518 682 ;
XC 105 ; WX 278 ; N i ; B 24 -13 283 676 ;
XC 106 ; WX 278 ; N j ; B -152 -203 311 676 ;
XC 107 ; WX 500 ; N k ; B 10 -13 511 682 ;
XC 108 ; WX 278 ; N l ; B 30 -13 311 682 ;
XC 109 ; WX 778 ; N m ; B 16 -13 744 458 ;
XC 110 ; WX 556 ; N n ; B 24 -13 518 458 ;
XC 111 ; WX 500 ; N o ; B 27 -13 467 458 ;
XC 112 ; WX 500 ; N p ; B -79 -203 481 458 ;
XC 113 ; WX 500 ; N q ; B 21 -203 486 459 ;
XC 114 ; WX 389 ; N r ; B 9 0 415 458 ;
XC 115 ; WX 389 ; N s ; B 16 -13 364 459 ;
XC 116 ; WX 278 ; N t ; B 15 -14 304 592 ;
XC 117 ; WX 556 ; N u ; B 47 -13 520 458 ;
XC 118 ; WX 444 ; N v ; B 50 -13 432 458 ;
XC 119 ; WX 667 ; N w ; B 50 -13 642 458 ;
XC 120 ; WX 500 ; N x ; B -5 -13 498 458 ;
XC 121 ; WX 444 ; N y ; B -60 -203 423 458 ;
XC 122 ; WX 389 ; N z ; B -24 -58 394 448 ;
XC 123 ; WX 348 ; N braceleft ; B 30 -154 380 686 ;
XC 124 ; WX 220 ; N bar ; B 70 0 151 682 ;
XC 125 ; WX 348 ; N braceright ; B -31 -161 319 679 ;
XC 126 ; WX 570 ; N asciitilde ; B 33 158 537 353 ;
XC 161 ; WX 389 ; N exclamdown ; B 20 -232 320 458 ;
XC 162 ; WX 500 ; N cent ; B 50 -142 443 570 ;
XC 163 ; WX 500 ; N sterling ; B -32 -13 505 676 ;
XC 164 ; WX 167 ; N fraction ; B -161 0 327 662 ;
XC 165 ; WX 500 ; N yen ; B -15 0 565 662 ;
XC 166 ; WX 500 ; N florin ; B -86 -154 530 682 ;
XC 167 ; WX 500 ; N section ; B 36 -143 454 676 ;
XC 168 ; WX 500 ; N currency ; B -3 110 503 612 ;
XC 169 ; WX 278 ; N quotesingle ; B 126 367 295 693 ;
XC 170 ; WX 500 ; N quotedblleft ; B 57 363 513 676 ;
XC 171 ; WX 500 ; N guillemotleft ; B 21 33 474 416 ;
XC 172 ; WX 333 ; N guilsinglleft ; B 42 33 310 416 ;
XC 173 ; WX 333 ; N guilsinglright ; B 22 38 290 421 ;
XC 174 ; WX 556 ; N fi ; B -157 -203 538 682 ;
XC 175 ; WX 556 ; N fl ; B -149 -203 577 682 ;
XC 177 ; WX 500 ; N endash ; B -11 176 511 266 ;
XC 178 ; WX 500 ; N dagger ; B 90 -146 489 676 ;
XC 179 ; WX 500 ; N daggerdbl ; B 11 -143 487 675 ;
XC 180 ; WX 250 ; N periodcentered ; B 51 179 200 328 ;
XC 182 ; WX 500 ; N paragraph ; B 61 -189 592 682 ;
XC 183 ; WX 350 ; N bullet ; B 50 175 300 425 ;
XC 184 ; WX 333 ; N quotesinglbase ; B 66 -181 268 132 ;
XC 185 ; WX 500 ; N quotedblbase ; B -57 -181 398 132 ;
XC 186 ; WX 500 ; N quotedblright ; B 56 362 509 675 ;
XC 187 ; WX 500 ; N guillemotright ; B 20 38 473 421 ;
XC 188 ; WX 1000 ; N ellipsis ; B 93 -13 906 133 ;
XC 189 ; WX 1000 ; N perthousand ; B 7 -49 985 699 ;
XC 191 ; WX 500 ; N questiondown ; B 30 -203 417 487 ;
XC 193 ; WX 333 ; N grave ; B 115 511 325 690 ;
XC 194 ; WX 333 ; N acute ; B 168 511 405 690 ;
XC 195 ; WX 333 ; N circumflex ; B 70 510 394 682 ;
XC 196 ; WX 333 ; N tilde ; B 69 530 424 648 ;
XC 197 ; WX 333 ; N macron ; B 81 547 420 616 ;
XC 198 ; WX 333 ; N breve ; B 98 511 413 671 ;
XC 199 ; WX 333 ; N dotaccent ; B 180 519 308 648 ;
XC 200 ; WX 333 ; N dieresis ; B 85 519 424 648 ;
XC 202 ; WX 333 ; N ring ; B 141 466 352 676 ;
XC 203 ; WX 333 ; N cedilla ; B 32 -216 264 5 ;
XC 205 ; WX 333 ; N hungarumlaut ; B 28 538 339 750 ;
XC 206 ; WX 333 ; N ogonek ; B -36 -173 193 44 ;
XC 207 ; WX 333 ; N caron ; B 109 511 437 683 ;
XC 208 ; WX 1000 ; N emdash ; B -14 176 1014 266 ;
XC 225 ; WX 944 ; N AE ; B -41 0 931 662 ;
XC 227 ; WX 266 ; N ordfeminine ; B -24 286 291 676 ;
XC 232 ; WX 611 ; N Lslash ; B -22 0 584 662 ;
XC 233 ; WX 722 ; N Oslash ; B 27 -124 684 754 ;
XC 234 ; WX 944 ; N OE ; B 23 -8 936 670 ;
XC 235 ; WX 300 ; N ordmasculine ; B 1 286 300 676 ;
XC 241 ; WX 722 ; N ae ; B 15 -13 685 458 ;
XC 245 ; WX 278 ; N dotlessi ; B 27 -13 260 458 ;
XC 248 ; WX 278 ; N lslash ; B 12 -13 326 682 ;
XC 249 ; WX 500 ; N oslash ; B 27 -118 467 556 ;
XC 250 ; WX 722 ; N oe ; B 26 -13 687 458 ;
XC 251 ; WX 500 ; N germandbls ; B -168 -203 497 682 ;
XC -1 ; WX 667 ; N Aacute ; B -51 0 602 894 ;
XC -1 ; WX 667 ; N Acircumflex ; B -51 0 602 886 ;
XC -1 ; WX 667 ; N Adieresis ; B -51 0 602 852 ;
XC -1 ; WX 667 ; N Agrave ; B -51 0 602 894 ;
XC -1 ; WX 667 ; N Aring ; B -51 0 602 880 ;
XC -1 ; WX 667 ; N Atilde ; B -51 0 602 852 ;
XC -1 ; WX 667 ; N Ccedilla ; B 22 -216 660 677 ;
XC -1 ; WX 667 ; N Eacute ; B -27 0 646 894 ;
XC -1 ; WX 667 ; N Ecircumflex ; B -27 0 646 886 ;
XC -1 ; WX 667 ; N Edieresis ; B -27 0 646 852 ;
XC -1 ; WX 667 ; N Egrave ; B -27 0 646 894 ;
XC -1 ; WX 722 ; N Eth ; B -31 0 693 662 ;
XC -1 ; WX 389 ; N Iacute ; B -22 0 433 894 ;
XC -1 ; WX 389 ; N Icircumflex ; B -22 0 422 886 ;
XC -1 ; WX 389 ; N Idieresis ; B -22 0 452 852 ;
XC -1 ; WX 389 ; N Igrave ; B -22 0 412 894 ;
XC -1 ; WX 722 ; N Ntilde ; B -27 -18 740 852 ;
XC -1 ; WX 722 ; N Oacute ; B 27 -18 684 894 ;
XC -1 ; WX 722 ; N Ocircumflex ; B 27 -18 684 886 ;
XC -1 ; WX 722 ; N Odieresis ; B 27 -18 684 852 ;
XC -1 ; WX 722 ; N Ograve ; B 27 -18 684 894 ;
XC -1 ; WX 722 ; N Otilde ; B 27 -18 684 852 ;
XC -1 ; WX 556 ; N Scaron ; B 6 -18 549 887 ;
XC -1 ; WX 611 ; N Thorn ; B -27 0 572 662 ;
XC -1 ; WX 722 ; N Uacute ; B 66 -18 736 894 ;
XC -1 ; WX 722 ; N Ucircumflex ; B 66 -18 736 886 ;
XC -1 ; WX 722 ; N Udieresis ; B 66 -18 736 852 ;
XC -1 ; WX 722 ; N Ugrave ; B 66 -18 736 894 ;
XC -1 ; WX 611 ; N Yacute ; B 46 0 625 894 ;
XC -1 ; WX 611 ; N Ydieresis ; B 46 0 625 852 ;
XC -1 ; WX 611 ; N Zcaron ; B -1 0 594 887 ;
XC -1 ; WX 500 ; N aacute ; B 9 -14 489 690 ;
XC -1 ; WX 500 ; N acircumflex ; B 9 -14 480 682 ;
XC -1 ; WX 500 ; N adieresis ; B 9 -14 508 648 ;
XC -1 ; WX 500 ; N agrave ; B 9 -14 480 690 ;
XC -1 ; WX 500 ; N aring ; B 9 -14 480 676 ;
XC -1 ; WX 500 ; N atilde ; B 9 -14 508 648 ;
XC -1 ; WX 220 ; N brokenbar ; B 70 0 151 682 ;
XC -1 ; WX 444 ; N ccedilla ; B 25 -216 418 458 ;
XC -1 ; WX 747 ; N copyright ; B 23 -18 723 676 ;
XC -1 ; WX 400 ; N degree ; B 70 376 370 676 ;
XC -1 ; WX 570 ; N divide ; B 33 0 537 505 ;
XC -1 ; WX 444 ; N eacute ; B 25 -13 461 690 ;
XC -1 ; WX 444 ; N ecircumflex ; B 25 -13 450 682 ;
XC -1 ; WX 444 ; N edieresis ; B 25 -13 480 648 ;
XC -1 ; WX 444 ; N egrave ; B 25 -13 413 690 ;
XC -1 ; WX 500 ; N eth ; B 27 -13 498 682 ;
XC -1 ; WX 278 ; N iacute ; B 27 -13 378 690 ;
XC -1 ; WX 278 ; N icircumflex ; B 27 -13 367 682 ;
XC -1 ; WX 278 ; N idieresis ; B 27 -13 397 648 ;
XC -1 ; WX 278 ; N igrave ; B 27 -13 298 690 ;
XC -1 ; WX 606 ; N logicalnot ; B 51 120 555 401 ;
XC -1 ; WX 606 ; N minus ; B 51 210 555 300 ;
XC -1 ; WX 576 ; N mu ; B -62 -210 522 458 ;
XC -1 ; WX 570 ; N multiply ; B 33 0 537 504 ;
XC -1 ; WX 556 ; N ntilde ; B 24 -13 536 648 ;
XC -1 ; WX 500 ; N oacute ; B 27 -13 489 690 ;
XC -1 ; WX 500 ; N ocircumflex ; B 27 -13 478 682 ;
XC -1 ; WX 500 ; N odieresis ; B 27 -13 508 648 ;
XC -1 ; WX 500 ; N ograve ; B 27 -13 467 690 ;
XC -1 ; WX 750 ; N onehalf ; B 30 0 720 676 ;
XC -1 ; WX 750 ; N onequarter ; B 30 0 720 676 ;
XC -1 ; WX 300 ; N onesuperior ; B 17 270 283 676 ;
XC -1 ; WX 500 ; N otilde ; B 27 -13 508 648 ;
XC -1 ; WX 570 ; N plusminus ; B 33 0 537 665 ;
XC -1 ; WX 747 ; N registered ; B 23 -18 723 676 ;
XC -1 ; WX 389 ; N scaron ; B 16 -13 465 683 ;
XC -1 ; WX 500 ; N thorn ; B -79 -203 474 682 ;
XC -1 ; WX 750 ; N threequarters ; B 30 0 720 676 ;
XC -1 ; WX 300 ; N threesuperior ; B 0 263 299 676 ;
XC -1 ; WX 1000 ; N trademark ; B 40 272 980 676 ;
XC -1 ; WX 300 ; N twosuperior ; B -2 270 302 676 ;
XC -1 ; WX 556 ; N uacute ; B 47 -13 520 690 ;
XC -1 ; WX 556 ; N ucircumflex ; B 47 -13 520 682 ;
XC -1 ; WX 556 ; N udieresis ; B 47 -13 536 648 ;
XC -1 ; WX 556 ; N ugrave ; B 47 -13 520 690 ;
XC -1 ; WX 444 ; N yacute ; B -60 -203 461 690 ;
XC -1 ; WX 444 ; N ydieresis ; B -60 -203 480 648 ;
XC -1 ; WX 389 ; N zcaron ; B -24 -58 465 683 ;
XEndCharMetrics
XStartKernData
XStartKernPairs 108
X
XKPX A y -74
XKPX A w -74
XKPX A v -74
XKPX A space -55
XKPX A quoteright -74
XKPX A Y -55
XKPX A W -92
XKPX A V -74
XKPX A T -55
X
XKPX F space -18
XKPX F period -129
XKPX F comma -129
XKPX F A -92
X
XKPX L y -37
XKPX L space -37
XKPX L quoteright -55
XKPX L Y -37
XKPX L W -37
XKPX L V -37
XKPX L T -18
X
XKPX P space -37
XKPX P period -129
XKPX P comma -129
XKPX P A -74
X
XKPX R y -18
XKPX R Y -18
XKPX R W -18
XKPX R V -18
X
XKPX T y -37
XKPX T w -37
XKPX T u -37
XKPX T semicolon -74
XKPX T s -92
XKPX T r -37
XKPX T period -92
XKPX T o -92
XKPX T i -37
XKPX T hyphen -92
XKPX T e -92
XKPX T comma -92
XKPX T colon -74
XKPX T c -92
XKPX T a -92
XKPX T O -18
XKPX T A -55
X
XKPX V y -74
XKPX V u -55
XKPX V space -18
XKPX V semicolon -74
XKPX V r -55
XKPX V period -129
XKPX V o -111
XKPX V i -55
XKPX V hyphen -55
XKPX V e -111
XKPX V comma -129
XKPX V colon -74
XKPX V a -111
XKPX V A -74
X
XKPX W y -55
XKPX W u -55
XKPX W space -18
XKPX W semicolon -55
XKPX W r -74
XKPX W period -74
XKPX W o -74
XKPX W i -37
XKPX W hyphen -37
XKPX W e -74
XKPX W comma -74
XKPX W colon -55
XKPX W a -74
XKPX W A -74
X
XKPX Y v -92
XKPX Y u -92
XKPX Y space -37
XKPX Y semicolon -92
XKPX Y q -111
XKPX Y period -74
XKPX Y p -74
XKPX Y o -111
XKPX Y i -55
XKPX Y hyphen -92
XKPX Y e -111
XKPX Y comma -92
XKPX Y colon -92
XKPX Y a -92
XKPX Y A -74
X
XKPX f quoteright 55
XKPX f f -18
X
XKPX one one -55
X
XKPX quoteleft quoteleft -74
X
XKPX quoteright t -37
XKPX quoteright space -74
XKPX quoteright s -74
XKPX quoteright quoteright -74
X
XKPX r quoteright 37
XKPX r period -55
XKPX r comma -55
X
XKPX space Y -18
XKPX space W -18
XKPX space A -37
X
XKPX v period -37
XKPX v comma -37
X
XKPX w period -37
XKPX w comma -37
X
XKPX y period -37
XKPX y comma -37
XEndKernPairs
XEndKernData
XStartComposites 58
XCC Zcaron 2 ; PCC Z 0 0 ; PCC caron 139 204 ;
XCC zcaron 2 ; PCC z 0 0 ; PCC caron 28 0 ;
XCC Scaron 2 ; PCC S 0 0 ; PCC caron 111 204 ;
XCC scaron 2 ; PCC s 0 0 ; PCC caron 28 0 ;
XCC Ccedilla 2 ; PCC C 0 0 ; PCC cedilla 167 0 ;
XCC ccedilla 2 ; PCC c 0 0 ; PCC cedilla 55 0 ;
XCC Yacute 2 ; PCC Y 0 0 ; PCC acute 139 204 ;
XCC yacute 2 ; PCC y 0 0 ; PCC acute 55 0 ;
XCC Ydieresis 2 ; PCC Y 0 0 ; PCC dieresis 139 204 ;
XCC ydieresis 2 ; PCC y 0 0 ; PCC dieresis 55 0 ;
XCC Uacute 2 ; PCC U 0 0 ; PCC acute 194 204 ;
XCC Ucircumflex 2 ; PCC U 0 0 ; PCC circumflex 194 204 ;
XCC Udieresis 2 ; PCC U 0 0 ; PCC dieresis 194 204 ;
XCC Ugrave 2 ; PCC U 0 0 ; PCC grave 194 204 ;
XCC uacute 2 ; PCC u 0 0 ; PCC acute 111 0 ;
XCC ucircumflex 2 ; PCC u 0 0 ; PCC circumflex 111 0 ;
XCC udieresis 2 ; PCC u 0 0 ; PCC dieresis 111 0 ;
XCC ugrave 2 ; PCC u 0 0 ; PCC grave 111 0 ;
XCC Iacute 2 ; PCC I 0 0 ; PCC acute 28 204 ;
XCC Icircumflex 2 ; PCC I 0 0 ; PCC circumflex 28 204 ;
XCC Idieresis 2 ; PCC I 0 0 ; PCC dieresis 28 204 ;
XCC Igrave 2 ; PCC I 0 0 ; PCC grave 28 204 ;
XCC iacute 2 ; PCC dotlessi 0 0 ; PCC acute -27 0 ;
XCC icircumflex 2 ; PCC dotlessi 0 0 ; PCC circumflex -27 0 ;
XCC idieresis 2 ; PCC dotlessi 0 0 ; PCC dieresis -27 0 ;
XCC igrave 2 ; PCC dotlessi 0 0 ; PCC grave -27 0 ;
XCC Eacute 2 ; PCC E 0 0 ; PCC acute 167 204 ;
XCC Ecircumflex 2 ; PCC E 0 0 ; PCC circumflex 167 204 ;
XCC Edieresis 2 ; PCC E 0 0 ; PCC dieresis 167 204 ;
XCC Egrave 2 ; PCC E 0 0 ; PCC grave 167 204 ;
XCC eacute 2 ; PCC e 0 0 ; PCC acute 55 0 ;
XCC ecircumflex 2 ; PCC e 0 0 ; PCC circumflex 55 0 ;
XCC edieresis 2 ; PCC e 0 0 ; PCC dieresis 55 0 ;
XCC eg
END_OF_FILE
  echo shar: appended 1 NEWLINEs to \"'font/TimesBolIta.AFM'\"
  if test 14436 -ne `wc -c <'font/TimesBolIta.AFM'`; then
    echo shar: \"'font/TimesBolIta.AFM'\" unpacked with wrong size!
  fi
  # end of 'font/TimesBolIta.AFM'
fi
if test -f 'z12.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z12.c'\"
else
  echo shar: Extracting \"'z12.c'\" \(18580 characters\)
  sed "s/^X//" >'z12.c' <<'END_OF_FILE'
X/*@z12.c:Size Finder:MinSize()@***********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z12.c                                                      */
X/*  MODULE:       Size Finder                                                */
X/*  EXTERNS:      MinSize()                                                  */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X#define IG_LOOKING	0
X#define IG_NOFILE	1
X#define IG_BADFILE	2
X#define IG_BADSIZE	3
X#define	IG_OK		4
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT MinSize(x, dim, extras)                                           */
X/*                                                                           */
X/*  Set fwd(x, dim) and back(x, dim) to their minimum possible values.       */
X/*  If dim == ROW, construct an extras list and return it in *extras.        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT MinSize(x, dim, extras)
XOBJECT x;  int dim;  OBJECT *extras;
X{ OBJECT y, z, link, prev, t, g, full_name;
X  int b, f, dble_fwd, llx, lly, urx, ury, status;
X  float fllx, flly, furx, fury;
X  BOOLEAN dble_found, found, will_expand, first_line;
X  FILE *fp;  FULL_CHAR buff[MAX_LINE];
X
X  debug2(DSF, DD, "[ MinSize( %s, %s, extras )", EchoObject(x), dimen(dim));
X  ifdebug(DSF, DDD, DebugObject(x));
X
X  switch( type(x) )
X  {
X
X    case WORD:
X    case QWORD:
X    
X      if( dim == COL )  FontWordSize(x);
X      break;
X
X
X    case CROSS:
X
X      /* add index to the cross-ref */
X      if( dim == ROW )
X      {	z = New(cross_type(x));
X	actual(z) = x;
X	Link(*extras, z);
X	debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X      }
X      back(x, dim) = fwd(x, dim) = 0;
X      break;
X
X
X    case NULL_CLOS:
X    
X      back(x, dim) = fwd(x, dim) = 0;
X      break;
X
X
X    case HEAD:
X
X      if( dim == ROW )
X      {	
X	/* replace the galley x by a dummy closure y */
X	y = New(NULL_CLOS);
X	FposCopy(fpos(y), fpos(x));
X	ReplaceNode(y, x);
X
X	if( has_key(actual(x)) )
X	{
X	  /* galley is sorted, make insinuated cross-reference */
X	  z = backward(x) ? New(GALL_PREC) : New(GALL_FOLL);
X	  Child(t, Down(x));
X	  actual(z) = CrossMake(whereto(x), t, (int) type(z));
X	  Link(*extras, z);
X	  DisposeObject(x);
X	  debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X	}
X	else
X	{
X	  /* galley is following, make UNATTACHED */
X	  z = New(UNATTACHED);  Link(z, x);
X	  Link(*extras, z);
X	  debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X	}
X	x = y;	/* now sizing y, not x */
X      }
X      else external(x) = FALSE;
X      back(x, dim) = fwd(x, dim) = 0;
X      break;
X
X
X    case CLOSURE:
X
X      assert( !has_target(actual(x)), "MinSize: CLOSURE has target!" );
X      if( dim == ROW )
X      { if( indefinite(actual(x)) )
X	{ z = New(RECEPTIVE);
X	  actual(z) = x;
X	  Link(*extras, z);
X	  debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X	}
X	else if( recursive(actual(x)) )
X	{ z = New(RECURSIVE);
X	  actual(z) = x;
X	  Link(*extras, z);
X	  debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X	}
X	else Error(INTERN,&fpos(x), "MinSize: definite non-recursive CLOSURE!");
X      }
X      else external(x) = FALSE;		/*  nb must be done just here! */
X      back(x, dim) = fwd(x, dim) = 0;
X      break;
X
X
X    case ONE_COL:
X    case ONE_ROW:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case HCONTRACT:
X    case VCONTRACT:
X    
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      back(x, dim) = back(y, dim);
X      fwd(x, dim)  = fwd(y, dim);
X      break;
X
X
X    case HEXPAND:
X    case VEXPAND:
X
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      back(x, dim) = back(y, dim);
X      fwd(x, dim)  = fwd(y, dim);
X
X      /* insert index into *extras for expanding later */
X      if( dim == ROW )
X      {	z = New(EXPAND_IND);
X	actual(z) = x;
X	Link(*extras, z);
X	debug1(DCR, DDD, "  MinSize: %s", EchoObject(z));
X      }	
X      break;
X
X
X    case GRAPHIC:
X    
X      Child(y, LastDown(x));
X      y = MinSize(y, dim, extras);
X      back(x, dim) = back(y, dim);
X      fwd(x, dim)  = fwd(y, dim);
X      break;
X
X
X    case HSCALE:
X    case VSCALE:
X
X      /* work out size and set to 0 if parallel */
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      if( (dim == COL) == (type(x) == HSCALE) )
X	back(x, dim) = fwd(x, dim) = 0;
X      else
X      {	back(x, dim) = back(y, dim);
X	fwd(x, dim)  = fwd(y, dim);
X      }
X      break;
X
X
X    case ROTATE:
X    
X      Child(y, Down(x));
X      if( dim == COL )
X      {	y = MinSize(y, COL, extras);
X	whereto(x) = New(ACAT);
X	y = MinSize(y, ROW, &whereto(x));
X	RotateSize(&back(x, COL), &fwd(x, COL), &back(x, ROW), &fwd(x, ROW),
X	  y, sparec(constraint(x)));
X      }
X      else
X      {	TransferLinks(Down(whereto(x)), whereto(x), *extras);
X	Dispose(whereto(x));
X      }
X      break;
X	
X
X    case SCALE:
X
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      if( dim == COL )
X      { back(x, dim) = (back(y, dim) * bc(constraint(x))) / SF;
X        fwd(x, dim)  = (fwd(y, dim)  * bc(constraint(x))) / SF;
X      }
X      else
X      { back(x, dim) = (back(y, dim) * fc(constraint(x))) / SF;
X        fwd(x, dim)  = (fwd(y, dim)  * fc(constraint(x))) / SF;
X      }
X      break;
X
X
X    case WIDE:
X
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      if( dim == COL )
X      { y = BreakObject(y, &constraint(x));
X        assert( FitsConstraint(back(y, dim), fwd(y, dim), constraint(x)),
X		"MinSize: BreakObject failed to fit!" );
X        back(x, dim) = back(y, dim);
X	fwd(x, dim)  = fwd(y, dim);
X	EnlargeToConstraint(&back(x, dim), &fwd(x, dim), &constraint(x));
X      }
X      else
X      {	back(x, dim) = back(y, dim);
X	fwd(x, dim)  = fwd(y, dim);
X      }
X      break;
X
X
X    case HIGH:
X    
X      Child(y, Down(x));
X      y = MinSize(y, dim, extras);
X      if( dim == ROW )
X      { if( !FitsConstraint(back(y, dim), fwd(y, dim), constraint(x)) )
X        { Error(WARN, &fpos(x), "forced to enlarge %s", KW_HIGH);
X	  debug0(DSF, D, "offending object was:");
X	  ifdebug(DSF, D, DebugObject(y));
X	  SetConstraint(constraint(x), MAX_LEN, size(y, dim), MAX_LEN);
X        }
X        back(x, dim) = back(y, dim);
X	fwd(x, dim)  = fwd(y, dim);
X	EnlargeToConstraint(&back(x, dim), &fwd(x, dim), &constraint(x));
X      }
X      else
X      {	back(x, dim) = back(y, dim);
X	fwd(x, dim)  = fwd(y, dim);
X      }
X      break;
X
X
X    case SPLIT:
X    
X      link = DownDim(x, dim);  Child(y, link);
X      y = MinSize(y, dim, extras);
X      back(x, dim) = back(y, dim);
X      fwd(x, dim)  = fwd(y, dim);
X      break;
X
X
X    case ACAT:
X    case HCAT:
X    case VCAT:
X    
X      if( (dim == ROW) == (type(x) == VCAT) )
X      {
X	/********************************************************************/
X	/*                                                                  */
X	/*  Calculate sizes parallel to join direction; loop invariant is:  */
X	/*                                                                  */
X	/*     If prev == nil, there are no definite children equal to or   */
X	/*        to the left of Child(link).                               */
X	/*     If prev != nil, prev is the rightmost definite child to the  */
X	/*        left of Child(link), and (b, f) is the total size up to   */
X	/*        the mark of prev i.e. not including fwd(prev).            */
X	/*     g is the most recent gap, or nil if none found yet.          */
X	/*     will_expand == TRUE when a gap is found that is likely to    */
X	/*        enlarge when ActualGap is called later on.                */
X	/*                                                                  */
X	/********************************************************************/
X
X	prev = g = nil;  will_expand = FALSE;  must_expand(x) = FALSE;
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( is_index(type(y)) )
X	  { if( dim == ROW )
X	    { link = PrevDown(link);
X	      MoveLink(NextDown(link), *extras, PARENT);
X	    }
X	    continue;
X	  }
X	  else if( type(y) == type(x) )
X	  { link = PrevDown(link);
X	    TransferLinks(Down(y), y, NextDown(link));
X	    DisposeChild(Up(y));
X	    continue;
X	  }
X	  else if( type(y) == GAP_OBJ )  g = y;
X	  else /* calculate size of y and accumulate it */
X	  { if( is_word(type(y)) )
X	    { if( dim == COL )
X	      {	FontWordSize(y);
X		debug4(DSF, DD, "FontWordSize( %s ) font %d = %s,%s",
X		EchoObject(y), word_font(y),
X		EchoLength(back(y, COL)), EchoLength(fwd(y, COL)));
X	      }
X	    }
X	    else y = MinSize(y, dim, extras);
X
X	    if( is_indefinite(type(y)) )
X	    {
X	      /* error if preceding gap has mark */
X	      if( g != nil && mark(gap(g)) )
X	      {	Error(WARN, &fpos(y), "catenation modifier ^ deleted (%s)",
X			"it may not precede this object");
X		mark(gap(g)) = FALSE;
X	      }
X
X	      /* error if next unit is used in preceding gap */
X	      if( g != nil && units(gap(g)) == NEXT_UNIT )
X	      {	Error(WARN, &fpos(y), "gap replaced by 0i (%s)",
X			"unit n may not precede this object");
X		units(gap(g)) = FIXED_UNIT;
X		width(gap(g)) = 0;
X	      }
X	    }
X	    else
X	    {
X	      /* calculate running total length */
X	      if( prev == nil )  b = back(y, dim), f = 0;
X	      else
X	      {
X		assert( g!=nil && mode(gap(g))!=NO_MODE, "MinSize: NO_MODE!" );
X		f += MinGap(fwd(prev, dim), back(y, dim), fwd(y, dim), &gap(g));
X		if( units(gap(g)) == FRAME_UNIT && width(gap(g)) > FR )
X		    will_expand = TRUE;
X		if( mark(gap(g)) )  b += f, f = 0;
X	      }
X	      prev = y;
X	    }
X	    debug2(DSF,DD,"  b = %s, f = %s",EchoLength(b),EchoLength(f));
X	  }
X	} /* end for */
X
X	if( prev == nil )  b = f = 0;
X	else f += fwd(prev, dim);
X	back(x, dim) = min(MAX_LEN, b);
X	fwd(x, dim)  = min(MAX_LEN, f);
X
X	if( type(x) == ACAT && will_expand )  fwd(x, COL) = MAX_LEN;
X      }
X      else
X      {
X	/********************************************************************/
X	/*                                                                  */
X	/*  Calculate sizes perpendicular to join direction                 */
X	/*                                                                  */
X	/*  Loop invariant:                                                 */
X	/*                                                                  */
X	/*     if found, (b, f) is the size of x, from the last // or from  */
X	/*     the start, up to link exclusive.  Else no children yet.      */
X	/*     If dble_found, a previous // exists, and (0, dble_fwd) is    */
X	/*     the size of x from the start up to that //.                  */
X	/*                                                                  */
X	/********************************************************************/
X
X	dble_found = found = FALSE;  dble_fwd = 0;
X	for( link = Down(x);  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  if( is_index(type(y)) )
X	  { if( dim == ROW )
X	    { link = PrevDown(link);
X	      MoveLink(NextDown(link), *extras, PARENT);
X	    }
X	    continue;
X	  }
X	  else if( type(y) == type(x) )
X	  { link = PrevDown(link);
X	    TransferLinks(Down(y), y, NextDown(link));
X	    DisposeChild(Up(y));
X	    continue;
X	  }
X	  else if( type(y) == GAP_OBJ )
X	  { assert( found, "MinSize/VCAT/perp: !found!" );
X	    if( !join(gap(y)) )
X	    {
X	      /* found // or || operator, so end current group */
X	      dble_found = TRUE;
X	      dble_fwd = max(dble_fwd, b + f);
X	      debug1(DSF, DD, "  endgroup, dble_fwd: %s", EchoLength(dble_fwd));
X	      found = FALSE;
X	    }
X	  }
X	  else /* found object */
X	  {
X	    /* calculate size of subobject y */
X	    if( is_word(type(y)) )
X	    { if( dim == COL )  FontWordSize(y);
X	    }
X	    else y = MinSize(y, dim, extras);
X	    if( found )
X	    { b = max(b, back(y, dim));
X	      f = max(f, fwd(y, dim));
X	    }
X	    else
X	    { b = back(y, dim);
X	      f = fwd(y, dim);
X	      found = TRUE;
X	    }
X	    debug2(DSF,DD, "  b: %s, f: %s", EchoLength(b), EchoLength(f));
X	  }
X	} /* end for */
X	assert( found, "MinSize/VCAT/perp: !found (2)!" );
X
X	/* finish off last group */
X	if( dble_found )
X	{ back(x, dim) = 0;
X	  dble_fwd = max(dble_fwd, b + f);
X	  fwd(x, dim) = min(MAX_LEN, dble_fwd);
X	  debug1(DSF, DD, "  end group, dble_fwd: %s", EchoLength(dble_fwd));
X	}
X	else
X	{ back(x, dim) = b;
X	  fwd(x, dim)  = f;
X	}
X      } /* end else */
X      break;
X
X
X    case COL_THR:
X    case ROW_THR:
X
X      assert( (type(x) == COL_THR) == (dim == COL), "Manifest/COL_THR: dim!" );
X      if( thr_state(x) == NOTSIZED )
X      {	assert( Down(x) != x, "Manifest/COL_THR: Down(x)!" );
X	Child(y, Down(x));
X	y = MinSize(y, dim, extras);
X	b = back(y, dim);
X	f = fwd(y, dim);
X	for( link = NextDown(Down(x));  link != x;  link = NextDown(link) )
X	{ Child(y, link);
X	  assert( type(y) != GAP_OBJ, "Manifest/COL_THR: GAP_OBJ!" );
X	  y = MinSize(y, dim, extras);
X	  b = max(b, back(y, dim));
X	  f = max(f, fwd(y, dim));
X	}
X	back(x, dim) = b;
X	fwd(x, dim)  = f;
X	thr_state(x) = SIZED;
X      }
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X
X      /* open file, check for initial %!, and hunt for %%BoundingBox line */
X      /* according to DSC Version 3.0, the BoundingBox parameters must be */
X      /* integers; but we read them as floats and truncate since files    */
X      /* with fractional values seem to be common in the real world       */
X      if( dim == ROW )  break;
X      status = IG_LOOKING;
X      Child(y, Down(x));
X      fp = OpenIncGraphicFile(string(y), type(x), &full_name, &fpos(y));
X      /* *** fp = OpenFile(fnum = sparec(constraint(x)), FALSE); */
X      if( fp == NULL )  status = IG_NOFILE;
X      first_line = TRUE;
X      while( status == IG_LOOKING && StringFGets(buff, MAX_LINE, fp) != NULL )
X      {
X	if( first_line && !StringBeginsWith(buff, AsciiToFull("%!")) )
X	  status = IG_BADFILE;
X	else
X	{ first_line = FALSE;
X	  if( buff[0] == '%'
X	      && StringBeginsWith(buff, AsciiToFull("%%BoundingBox:"))
X	      && !StringContains(buff, AsciiToFull("(atend)")) )
X	  { if( sscanf( (char *) buff, "%%%%BoundingBox: %f %f %f %f",
X		&fllx, &flly, &furx, &fury) == 4 )
X	    {
X	      status = IG_OK;
X	      llx = fllx;
X	      lly = flly;
X	      urx = furx;
X	      ury = fury;
X	    }
X	    else status = IG_BADSIZE;
X	  }
X	}
X      }
X
X      /* report error or calculate true size, depending on status */
X      switch( status )
X      {
X	case IG_LOOKING:
X
X	  Error(WARN, &fpos(x), "%s given zero size: format error in file %s%s",
X	    type(x) == INCGRAPHIC ? KW_INCGRAPHIC : KW_SINCGRAPHIC,
X	    string(full_name), " (missing %%BoundingBox: line)");
X	  back(y, COL) = fwd(y, COL) = back(y, ROW) = fwd(y, ROW) = 0;
X	  back(x, COL) = fwd(x, COL) = back(x, ROW) = fwd(x, ROW) = 0;
X	  sparec(constraint(x)) = TRUE;
X	  fclose(fp);
X	  break;
X
X	case IG_NOFILE:
X
X	  Error(WARN, &fpos(x), "%s deleted: cannot open file %s",
X	    type(x) == INCGRAPHIC ? KW_INCGRAPHIC : KW_SINCGRAPHIC,
X	    string(full_name));
X	  sparec(constraint(x)) = FALSE;
X	  back(x, COL) = fwd(x, COL) = back(x, ROW) = fwd(x, ROW) = 0;
X	  break;
X
X	case IG_BADFILE:
X
X	  Error(WARN, &fpos(x), "%s deleted: format error in file %s %s",
X	    type(x) == INCGRAPHIC ? KW_INCGRAPHIC : KW_SINCGRAPHIC,
X	    string(full_name), "(bad first line)");
X	  sparec(constraint(x)) = FALSE;
X	  back(x, COL) = fwd(x, COL) = back(x, ROW) = fwd(x, ROW) = 0;
X	  fclose(fp);
X	  break;
X	
X	case IG_BADSIZE:
X
X	  Error(WARN, &fpos(x), "%s given zero size: format error in file %s%s",
X	    type(x) == INCGRAPHIC ? KW_INCGRAPHIC : KW_SINCGRAPHIC,
X	    string(full_name), " (bad %%BoundingBox: line)");
X	  back(y, COL) = fwd(y, COL) = back(y, ROW) = fwd(y, ROW) = 0;
X	  back(x, COL) = fwd(x, COL) = back(x, ROW) = fwd(x, ROW) = 0;
X	  sparec(constraint(x)) = TRUE;
X	  fclose(fp);
X	  break;
X
X	case IG_OK:
X
X	  Child(y, Down(x));
X	  back(y, COL) = llx;  fwd(y, COL) = urx;
X	  back(y, ROW) = lly;  fwd(y, ROW) = ury;
X	  b = (urx - llx) * PT;
X	  b = max(0, min(b, MAX_LEN));
X	  back(x, COL) = fwd(x, COL) = b / 2;
X	  b = (ury - lly) * PT;
X	  b = max(0, min(b, MAX_LEN));
X	  back(x, ROW) = fwd(x, ROW) = b / 2;
X	  sparec(constraint(x)) = TRUE;
X	  fclose(fp);
X	  break;
X
X      }
X      DisposeObject(full_name);
X      break;
X
X
X    default:
X    
X      Error(INTERN, &fpos(x), "MinSize: type(x): %s", Image(type(x)));
X      break;
X
X
X  } /* end switch */
X  debug1(DSF, DD,  "] MinSize returning, x = %s", EchoObject(x));
X  debug3(DSF, DD, "  (%s size is %s, %s)", dimen(dim),
X		EchoLength(back(x, dim)), EchoLength(fwd(x, dim)) );
X  ifdebug(DSF, DDD, DebugObject(x));
X
X  assert( back(x, dim) >= 0, "MinSize: back(x, dim) < 0!" );
X  assert( fwd(x, dim)  >= 0, "MinSize: fwd(x, dim)  < 0!" );
X
X  return x;
X} /* end MinSize */
END_OF_FILE
  if test 18580 -ne `wc -c <'z12.c'`; then
    echo shar: \"'z12.c'\" unpacked with wrong size!
  fi
  # end of 'z12.c'
fi
if test -f 'z13.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z13.c'\"
else
  echo shar: Extracting \"'z13.c'\" \(19888 characters\)
  sed "s/^X//" >'z13.c' <<'END_OF_FILE'
X/*@z13.c:Object Breaking:BreakJoinedGroup()@**********************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z13.c                                                      */
X/*  MODULE:       Object Breaking                                            */
X/*  EXTERNS:      BreakObject()                                              */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  static BreakJoinedGroup(start, stop, m, c, res_back, res_fwd)            */
X/*                                                                           */
X/*  Break joined group of components of a VCAT, beginning from Child(start)  */
X/*  inclusive and ending at Child(stop) inclusive.  Break component m first  */
X/*  because it is the widest.                                                */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic BreakJoinedGroup(start, stop, m, c, res_back, res_fwd)
XOBJECT start, stop, m;  CONSTRAINT *c;  LENGTH *res_back, *res_fwd;
X{ OBJECT y, link, z;  LENGTH b, f;  CONSTRAINT yc;
X  ifdebug(DOB, D, Child(y, start));
X  ifdebug(DOB, D, Child(z, stop));
X  debug3(DOB, D, "BreakJoinedGroup( -> %s, -> %s, %s, -, -)",
X	EchoObject(y), EchoObject(z), EchoConstraint(c));
X  CopyConstraint(yc, *c);
X  if( m != nil )
X  { m = BreakObject(m, &yc);
X    b = back(m, COL);
X    f = fwd(m, COL);
X    SetConstraint(yc, min(bc(yc), bfc(yc)-f), bfc(yc), min(fc(yc), bfc(yc)-b));
X  }
X  else b = f = 0;
X  for( link = start;  link != NextDown(stop);  link = NextDown(link) )
X  { Child(y, link);
X    if( !is_definite(type(y)) || y == m )  continue;
X    y = BreakObject(y, &yc);
X    b = max(b, back(y, COL));
X    f = max(f, fwd(y, COL));
X    SetConstraint(yc, min(bc(yc), bfc(yc)-f), bfc(yc), min(fc(yc), bfc(yc)-b));
X  }
X  assert( FitsConstraint(b, f, *c), "BreakJoinedGroup: result does not fit!" );
X  *res_back = b;  *res_fwd = f;
X  debug2(DOB,D,"BreakJoinedGroup returning (%s, %s)",
X	EchoLength(b), EchoLength(f));
X} /* end BreakJoinedGroup */
X
X
X/*@::BreakVcat()@*************************************************************/
X/*                                                                           */
X/*  static OBJECT BreakVcat(x, c)                                            */
X/*                                                                           */
X/*  Break a VCAT to satisfy constraint c.  This is tedious because every     */
X/*  group of components between //  ...  // must be broken separately.       */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT BreakVcat(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ OBJECT y, link, start_group, m;  LENGTH b, f; int dble_fwd;  CONSTRAINT tc;
X  BOOLEAN dble_found;
X  debug2(DOB, D, "[ BreakVcat(%s, %s)", EchoObject(x), EchoConstraint(c));
X  assert(Down(x) != x, "BreakVcat: Down(x) == x!" );
X  SetConstraint(tc, MAX_LEN, min(bfc(*c), fc(*c)), MAX_LEN);
X  
X  dble_found = FALSE;  dble_fwd = 0;  start_group = nil;
X  for( link = Down(x);  link != x;  link = NextDown(link) )
X  { Child(y, link);
X    if( is_index(type(y)) )  continue;
X    if( type(y) == GAP_OBJ )
X    { assert( start_group != nil, "BreakVcat: start_group == nil!" );
X      if( !join(gap(y)) )
X      {
X	/* finish off and break this group */
X	if( !FitsConstraint(b, f, tc) )
X	  BreakJoinedGroup(start_group, link, m, &tc, &b, &f);
X	dble_found = TRUE;
X	dble_fwd = max(dble_fwd, b + f);
X	start_group = nil;
X	debug1(DOB, D, "  end group, dble_fwd: %s", EchoLength(dble_fwd));
X      }
X    }
X    else if( start_group == nil )
X    {	
X      /* start new group */
X      b = back(y, COL);  f = fwd(y, COL);
X      start_group = link;  m = y;
X      debug3(DOB, D, "  starting group: %s (%s, %s)",
X	EchoObject(y), EchoLength(b), EchoLength(f));
X    }
X    else
X    {
X      /* continue with current group */
X      b = max(b, back(y, COL));  f = max(f, fwd(y, COL));
X      if( fwd(y, COL) > fwd(m, COL) )  m = y;
X      debug4(DOB, D, "  in group: %s%s (%s, %s)", m == y ? "new max " : "",
X	EchoObject(y), EchoLength(b), EchoLength(f));
X    }
X  }
X  assert( start_group != nil, "BreakVcat: start_group == nil (2)!" );
X
X  if( dble_found )
X  {	
X    /* finish off and break this last group, and set sizes of x */
X    if( !FitsConstraint(b, f, tc) )
X      BreakJoinedGroup(start_group, LastDown(x), m, &tc, &b, &f);
X    dble_fwd = max(dble_fwd, b + f);
X    debug1(DOB, D, "  ending last group, dble_fwd: %s",EchoLength(dble_fwd));
X    back(x, COL) = 0;  fwd(x, COL) = min(MAX_LEN, dble_fwd);
X  }
X  else
X  {
X    /* finish off and break this last and only group, and set sizes of x */
X    debug2(DOB, D, "  BreakVcat ending last and only group (%s, %s)",
X	EchoLength(b), EchoLength(f));
X    BreakJoinedGroup(start_group, LastDown(x), m, c, &b, &f);
X    back(x, COL) = b;  fwd(x, COL) = f;
X  }
X
X  debug1(DOB, D, "] BreakVcat returning %s", EchoObject(x));
X  debug2(DOB, D, "  (size is %s, %s)",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)));
X  return x;
X} /* end BreakVcat */
X
X
X/*@::BreakTable()@************************************************************/
X/*                                                                           */
X/*  static OBJECT BreakTable(x, c)                                           */
X/*                                                                           */
X/*  Break table (HCAT) x to satisfy constraint c.                            */
X/*                                                                           */
X/*  Outline of algorithm:                                                    */
X/*                                                                           */
X/*     bcount = number of components to left of mark;                        */
X/*     fcount = no. of components on and right of mark;                      */
X/*     bwidth = what back(x) would be if all components had size (0, 0);     */
X/*     fwidth = what fwd(x) would be if all components had size (0, 0);      */
X/*     Set all components of x to Unbroken (broken(y) holds this flag);      */
X/*     while( an Unbroken component of x exists )                            */
X/*     {   my = the Unbroken component of x of minimum width;                */
X/*         mc = desirable constraint for my (see below);                     */
X/*         BreakObject(my, &mc);                                             */
X/*         Set my to Broken and update bcount, fcount, bwidth, fwidth        */
X/*            to reflect the actual size of my, now broken;                  */
X/*     }                                                                     */
X/*                                                                           */
X/*  The constraint mc is chosen in an attempt to ensure that:                */
X/*                                                                           */
X/*     a)  Any sufficiently narrow components will not break;                */
X/*     b)  All broken components will have the same bfc(mc), if possible;    */
X/*     c)  All available space is used.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
Xstatic OBJECT BreakTable(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ LENGTH bwidth, fwidth;	/* running back(x) and fwd(x)		     */
X  int    bcount, fcount;	/* running no. of components		     */
X  OBJECT mlink, my;		/* minimum-width unbroken component	     */
X  BOOLEAN ratm;			/* TRUE when my has a mark to its right      */
X  int    mside;			/* side of the mark my is on: BACK, ON, FWD  */
X  LENGTH msize;			/* size of my (minimal among unbroken)	     */
X  CONSTRAINT mc;		/* desirable constraint for my		     */
X  OBJECT pg, prec_def;		/* preceding definite object of my           */
X  OBJECT sg, succ_def;		/* succeeding definite object of my          */
X  LENGTH pd_extra, sd_extra;	/* space availiable for free each side of my */
X  LENGTH av_colsize;		/* the size of each unbroken component       */
X				/* if they are all assigned equal width      */
X  LENGTH fwd_max, back_max;	/* maximum space available forward of or     */
X				/* back of the mark, when columns are even   */
X  LENGTH col_size;		/* the column size actually used in breaking */
X  LENGTH beffect, feffect;	/* the amount bwidth, fwidth must increase   */
X				/* when my is broken			     */
X  OBJECT link, y, prev, g;  LENGTH tmp, tmp2;
X
X  debug2(DOB, DD, "[ BreakTable( %s, %s )", EchoObject(x), EchoConstraint(c));
X
X  /* Initialise csize, bcount, fcount, bwidth, fwidth and broken(y) */
X  bcount = fcount = 0;  bwidth = fwidth = 0;  prev = nil;
X  Child(y, Down(x));
X  assert( type(y) != GAP_OBJ, "BreakTable: GAP_OBJ!" );
X  assert( !is_index(type(y)), "BreakTable: index!" );
X  broken(y) = is_indefinite(type(y));
X  if( !broken(y) )  prev = y, fcount = 1;
X
X  for( link = NextDown(Down(x));  link != x;  link = NextDown(NextDown(link)) )
X  {
X    /* find the next gap g and following child y */
X    Child(g, link);
X    assert( type(g) == GAP_OBJ, "BreakTable: GAP_OBJ!" );
X    assert( NextDown(link) != x, "BreakTable: GAP_OBJ is last!" );
X    Child(y, NextDown(link));
X
X    assert( type(y) != GAP_OBJ, "BreakTable: GAP_OBJ!" );
X    assert( !is_index(type(y)), "BreakTable: index!" );
X    broken(y) = is_indefinite(type(y));
X    if( !broken(y) )
X    { if( prev == nil )  fcount = 1;
X      else if( mark(gap(g)) )
X      {	bcount += fcount;
X	bwidth += fwidth + MinGap(0, 0, 0, &gap(g));
X	fcount  = 1;  fwidth = 0;
X      }
X      else
X      {	fwidth += MinGap(0, 0, 0, &gap(g));
X	fcount += 1;
X      }
X      prev = y;
X    }
X  }
X
X  /* if column gaps alone are too wide, kill them all */
X  if( !FitsConstraint(bwidth, fwidth, *c) )
X  { Error(WARN, &fpos(x), "object too wide: reducing column gaps to 0i");
X    for( link = Down(x);  link != x;  link = NextDown(link) )
X    { Child(g, link);
X      if( type(g) == GAP_OBJ )
X      {	SetGap(gap(g), mark(gap(g)), join(gap(g)), FIXED_UNIT, EDGE_MODE, 0);
X      }
X    }
X    bwidth = fwidth = 0;
X  }
X
X  /* break each column, from smallest to largest */
X  while( bcount + fcount > 0 && FitsConstraint(bwidth, fwidth, *c) )
X  {
X    debug2(DOB,DD, "bcount: %d;  bwidth: %s", bcount, EchoLength(bwidth));
X    debug2(DOB,DD, "fcount: %d;  fwidth: %s", fcount, EchoLength(fwidth));
X
X    /* find a minimal-width unbroken component my */
X    my = nil;  msize = size(x, COL);       /* an upper bound for size(y) */
X    for( link = Down(x);  ;  link = NextDown(link) )
X    { Child(y, link);
X      assert( type(y) != GAP_OBJ, "BreakTable: type(y) == GAP_OBJ!" );
X      if( !broken(y) && (size(y, COL) < msize || my == nil) )
X      {	msize = size(y, COL);
X	my = y;  mlink = link;
X	ratm = FALSE;
X      }
X
X      /* next gap */
X      link = NextDown(link);
X      if( link == x )  break;
X      Child(g, link);
X      assert( type(g) == GAP_OBJ, "BreakTable: type(g) != GAP_OBJ!" );
X      if( mark(gap(g)) )  ratm = TRUE;
X    }
X
X    /* find neighbouring definite objects and resulting pd_extra and sd_extra */
X    SetNeighbours(mlink, ratm, &pg, &prec_def, &sg, &succ_def, &mside);
X    debug2(DOB, DD, "my (%s): %s", Image(mside), EchoObject(my));
X    pd_extra = pg == nil ? 0 :
X      ExtraGap(broken(prec_def) ? fwd(prec_def,COL) : 0, 0, &gap(pg), BACK);
X    sd_extra = sg == nil ? 0 :
X      ExtraGap(0, broken(succ_def) ? back(succ_def,COL) : 0, &gap(sg), FWD);
X    debug2(DOB, DD, "pd_extra:   %s;  sd_extra:      %s",
X		EchoLength(pd_extra), EchoLength(sd_extra) );
X
X    /* calculate desirable constraints for my */
X    av_colsize = (bfc(*c) - bwidth - fwidth) / (bcount + fcount);
X    debug1(DOB, DD, "av_colsize = %s", EchoLength(av_colsize));
X    switch( mside )
X    {
X
X      case BACK:
X      
X	back_max = min(bc(*c), bwidth + av_colsize * bcount);
X	col_size = (back_max - bwidth) / bcount;
X	SetConstraint(mc, col_size + pd_extra, col_size + pd_extra + sd_extra,
X			col_size + sd_extra );
X	break;
X
X
X      case ON:
X      
X	fwd_max = min(fc(*c), fwidth + av_colsize * fcount);
X	col_size = (fwd_max - fwidth) / fcount;
X	SetConstraint(mc, pd_extra + back(my, COL), MAX_LEN, col_size + sd_extra);
X	break;
X
X
X      case FWD:
X      
X	fwd_max = min(fc(*c), fwidth + av_colsize * fcount);
X	col_size = (fwd_max - fwidth) / fcount;
X	SetConstraint(mc, col_size + pd_extra, col_size + pd_extra + sd_extra,
X			col_size + sd_extra );
X	break;
X
X
X      default:
X      
X	Error(INTERN, no_fpos, "BreakTable found illegal side");
X	break;
X    }
X
X    /* now break my according to these constraints, and accept it */
X    my = BreakObject(my, &mc);  broken(my) = TRUE;
X
X    /* calculate the effect of accepting my on bwidth and fwidth */
X    if( pg != nil )
X    { tmp = broken(prec_def) ? fwd(prec_def, COL) : 0;
X      beffect = MinGap(tmp, back(my, COL), fwd(my, COL), &gap(pg)) -
X	        MinGap(tmp, 0,             0,            &gap(pg));
X    }
X    else beffect = back(my, COL);
X
X    if( sg != nil )
X    { tmp = broken(succ_def) ? back(succ_def, COL) : 0;
X      tmp2 = broken(succ_def) ? fwd(succ_def, COL) : 0;
X      feffect = MinGap(fwd(my, COL), tmp, tmp2, &gap(sg)) -
X	        MinGap(0,            tmp, tmp2, &gap(sg));
X    }
X    else feffect = fwd(my, COL);
X
X    switch( mside )
X    {
X	case BACK:	bwidth += beffect + feffect;
X			bcount--;
X			break;
X	
X	case ON:	bwidth += beffect;  fwidth += feffect;
X			fcount--;
X			break;
X
X	case FWD:	fwidth += beffect + feffect;
X			fcount--;
X			break;
X	
X	default:	Error(INTERN, no_fpos, "BreakTable: illegal side");
X			break;
X    }
X
X  } /* end while */
X
X  back(x, COL) = bwidth;
X  fwd(x, COL) = fwidth;
X
X  debug1(DOB, DD,  "] BreakTable returning %s", EchoObject(x));
X  debug2(DOB, DD, "  (size is %s, %s)", EchoLength(bwidth),EchoLength(fwidth));
X  return x;
X} /* end BreakTable */
X
X
X/*@::BreakObject()@***********************************************************/
X/*                                                                           */
X/*  OBJECT BreakObject(x, c)                                                 */
X/*                                                                           */
X/*  Break lines of object x so that it satisfies constraint c.               */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT BreakObject(x, c)
XOBJECT x;  CONSTRAINT *c;
X{ OBJECT y;  CONSTRAINT yc;
X  debug3(DOB, DD,  "[ BreakObject(x (%s,%s),  %s), x =",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)), EchoConstraint(c));
X  ifdebug(DOB, DD, DebugObject(x));
X
X  if( FitsConstraint(back(x, COL), fwd(x, COL), *c) )
X  { debug0(DOB, DD, "] BreakObject returning (fits).");
X    return x;
X  }
X  switch( type(x) )
X  {
X
X    case ROTATE:
X    
X      Error(WARN, &fpos(x), "%s deleted (too wide; cannot break %s)",
X	KW_ROTATE, KW_ROTATE);
X      y = MakeWord(WORD, STR_EMPTY, &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case SCALE:
X
X      InvScaleConstraint(&yc, bc(constraint(x)), c);
X      Child(y, Down(x));
X      y = BreakObject(y, &yc);
X      back(x, COL) = (back(y, COL) * bc(constraint(x))) / SF;
X      fwd(x, COL) =  (fwd(y, COL)  * bc(constraint(x))) / SF;
X      break;
X
X
X    case WORD:
X    case QWORD:
X    
X      Error(WARN, &fpos(x), "word %s deleted (too wide)",string(x));
X      y = MakeWord(WORD, STR_EMPTY, &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case WIDE:
X    
X      Error(WARN, &fpos(x), "%s %s reduced (too wide)",
X	EchoLength(bfc(constraint(x))), KW_WIDE);
X      MinConstraint(&constraint(x), c);
X      Child(y, Down(x));
X      y = BreakObject(y, &constraint(x));
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      EnlargeToConstraint(&back(x, COL), &fwd(x, COL), &constraint(x));
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X
X      Error(WARN, &fpos(x), "%s or %s deleted (too wide)", KW_INCGRAPHIC,
X	KW_SINCGRAPHIC);
X      y = MakeWord(WORD, STR_EMPTY, &fpos(x));
X      back(y, COL) = fwd(y, COL) = 0;
X      ReplaceNode(y, x);
X      DisposeObject(x);
X      x = y;
X      break;
X
X
X    case HIGH:
X    case VSCALE:
X    case HCONTRACT: 
X    case VCONTRACT:
X    case HEXPAND: 
X    case VEXPAND:
X    case PADJUST: 
X    case HADJUST: 
X    case VADJUST:
X    case ONE_ROW:
X    case ONE_COL:
X    
X      assert( Down(x) == LastDown(x), "BreakObject: downs!" );
X      Child(y, Down(x));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case GRAPHIC:
X    
X      Child(y, LastDown(x));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case SPLIT:
X    
X      Child(y, DownDim(x, COL));
X      y = BreakObject(y, c);
X      back(x, COL) = back(y, COL);
X      fwd(x, COL) = fwd(y, COL);
X      break;
X
X
X    case ACAT:
X    
X      x = FillObject(x, c);
X      break;
X
X
X    case HCAT:
X    
X      x = BreakTable(x, c);
X      break;
X
X
X    case COL_THR:
X    
X      BreakJoinedGroup(Down(x), LastDown(x), nil, c, &back(x,COL), &fwd(x,COL));
X      break;
X
X
X    case VCAT:
X    
X      x = BreakVcat(x, c);
X      break;
X			
X
X    default:
X    
X      Error(INTERN, &fpos(x), "BreakObject: %s!", Image(type(x)) );
X      break;
X
X  }
X  assert( back(x, COL) >= 0, "BreakObject: back(x, COL) < 0!" );
X  assert( fwd(x, COL) >= 0, "BreakObject: fwd(x, COL) < 0!" );
X  debug1(DOB, DD,  "] BreakObject returning %s", EchoObject(x));
X  debug2(DOB, DD, "  (size is %s, %s)",
X	EchoLength(back(x, COL)), EchoLength(fwd(x, COL)));
X  return x;
X} /* end BreakObject */
END_OF_FILE
  if test 19888 -ne `wc -c <'z13.c'`; then
    echo shar: \"'z13.c'\" unpacked with wrong size!
  fi
  # end of 'z13.c'
fi
if test -f 'z18.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z18.c'\"
else
  echo shar: Extracting \"'z18.c'\" \(16805 characters\)
  sed "s/^X//" >'z18.c' <<'END_OF_FILE'
X/*@z18.c:Galley Transfer:Declarations@****************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z18.c                                                      */
X/*  MODULE:       Galley Transfer                                            */
X/*  EXTERNS:      TransferInit(), TransferBegin(), TransferComponent(),      */
X/*                TransferEnd(), TransferClose()                             */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X#define	MAX_DEPTH  	30			/* max depth of galleys      */
Xstatic OBJECT		root_galley = nil;	/* the root galley           */
Xstatic OBJECT		targets[MAX_DEPTH];	/* currently open \Inputs    */
Xstatic CONSTRAINT	constraints[MAX_DEPTH];	/* their COL constraints     */
Xstatic int		itop;			/* stack top	             */
Xstatic CONSTRAINT	initial_constraint;	/* initial COL constraint    */
Xstatic STYLE		InitialStyle;		/* initial style             */
X
X#if DEBUG_ON
Xstatic debug_targets()
X{ int i;  OBJECT tmp;
X  for( i = 0;  i <= itop;  i++ )
X  { if( targets[i] == nil || Down(targets[i]) == targets[i] )  tmp = nil;
X    else Child(tmp, Down(targets[i]));
X    debug3(DGT, D, "  target[%d] %s = %s", i,
X      EchoConstraint(&constraints[i]), EchoObject(tmp));
X  }
X} /* end debug_targets */
X#endif
X
X
X/*@::TransferInit()@**********************************************************/
X/*                                                                           */
X/*  TransferInit(InitEnv)                                                    */
X/*                                                                           */
X/*  Initialise this module.  The initial environment is InitEnv.             */
X/*                                                                           */
X/*****************************************************************************/
X
XTransferInit(InitEnv)
XOBJECT InitEnv;
X{ OBJECT dest, x, y, recs, inners, nothing, dest_index, up_hd;
X  debug1(DGT, D, "TransferInit( %s )", EchoObject(InitEnv));
X  SetConstraint(initial_constraint, MAX_LEN-1, MAX_LEN-1, MAX_LEN-1);
X
X  /* save initial environment and style */
X  SetGap( line_gap(InitialStyle), FALSE, FALSE, FIXED_UNIT, MARK_MODE, 18*PT);
X  SetGap(space_gap(InitialStyle), FALSE, TRUE,  FIXED_UNIT, EDGE_MODE,  1*EM);
X  font(InitialStyle)            = 0;
X  hyph_style(InitialStyle)      = HYPH_UNDEF;
X  fill_style(InitialStyle)      = FILL_UNDEF;
X  display_style(InitialStyle)   = DISPLAY_UNDEF;
X
X  /* construct destination for root galley */
X  up_hd = New(HEAD);
X  dest_index = New(RECEIVING);
X  dest = New(CLOSURE);  actual(dest) = PrintSym;
X  actual(dest_index) = dest;
X  external(dest) = TRUE;
X  threaded(dest) = FALSE;
X  blocked(dest_index) = FALSE;
X  Link(up_hd, dest_index);
X
X  /* construct root galley */
X  root_galley = New(HEAD);
X  FposCopy(fpos(root_galley), *no_fpos);
X  actual(root_galley) = whereto(root_galley) = ready_galls(root_galley) = nil;
X  backward(root_galley) = must_expand(root_galley) = sized(root_galley) = FALSE;
X  x = New(CLOSURE);  actual(x) = InputSym;
X  Link(root_galley, x);
X  SizeGalley(root_galley, InitEnv, TRUE, FALSE, FALSE, FALSE, &InitialStyle,
X		&initial_constraint, nil, &nothing, &recs, &inners);
X  assert( recs   == nil , "TransferInit: recs   != nil!" );
X  assert( inners == nil , "TransferInit: inners != nil!" );
X  Link(dest_index, root_galley);
X
X  /* initialise target and constraint stacks */
X  Child(y, Down(root_galley));
X  assert( type(y) == RECEPTIVE && type(actual(y)) == CLOSURE &&
X	actual(actual(y)) == InputSym, "TransferInit: initial galley!" );
X  assert( external(actual(y)), "TransferInit: input sym not external!" );
X  blocked(y) = TRUE;
X  targets[itop = 0] = New(ACAT);
X  Link(targets[itop], y);
X  Constrained(actual(y), &constraints[itop], COL);
X  debug2(DSC, D, "Constrained( %s, COL ) = %s",
X	EchoObject(y), EchoConstraint(&constraints[itop]));
X
X  debug0(DGT, D, "TransferInit returning.");
X  ifdebug(DGT, DD, debug_targets());
X} /* end TransferInit */
X
X
X/*@::TransferBegin()@*********************************************************/
X/*                                                                           */
X/*  OBJECT TransferBegin(x)                                                  */
X/*                                                                           */
X/*  Commence the transfer of a new galley whose header is invokation x.      */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT TransferBegin(x)
XOBJECT x;
X{ OBJECT xsym, index, y, link, env, new_env, hold_env, res, hd, target;
X  CONSTRAINT c;
X  debug1(DGT, D, "TransferBegin( %s )", EchoObject(x));
X  ifdebug(DGT, DD, debug_targets());
X  assert( type(x) == CLOSURE, "TransferBegin: non-CLOSURE!" );
X
X  /* add an automatically generated @Tag parameter to x if required */
X  CrossAddTag(x);
X
X  /* construct new (inner) env chain */
X  if( Down(targets[itop]) == targets[itop] )
X  	Error(FATAL, &fpos(x), "cannot attach galley %s", SymName(actual(x)));
X  Child(target, Down(targets[itop]));
X  xsym = actual(x);
X  env = GetEnv(actual(target));
X  debug1(DGT, DD, "  current env chain: %s", EchoObject(env));
X  if( has_body(xsym) )
X  {
X    /* prepare a copy of x for inclusion in environment */
X    y = CopyObject(x, no_fpos);
X
X    /* attach its environment */
X    AttachEnv(env, y);
X
X    /* now the new environment is y catenated with the old one */
X    debug0(DCR, DD, "calling SetEnv from TransferBegin (a)");
X    new_env = SetEnv(y, nil);
X  }
X  else new_env = env;
X  hold_env = New(ACAT);  Link(hold_env, new_env);
X  debug1(DGT, DD, "  new env chain: %s", EchoObject(new_env));
X
X  /* convert x into an unsized galley called hd */
X  index = New(UNATTACHED);
X  hd = New(HEAD);
X  FposCopy(fpos(hd), fpos(x));
X  actual(hd) = xsym;
X  backward(hd) = TargetSymbol(x, &whereto(hd));
X  ready_galls(hd) = nil;
X  must_expand(hd) = TRUE;
X  sized(hd) = FALSE;
X  Link(index, hd);
X  Link(hd, x);
X  AttachEnv(env, x);
X
X  /* search for destination for hd and release it */
X  Link(Up(target), index);
X  debug0(DGF, D, "  calling FlushGalley from TransferBegin");
X  FlushGalley(hd);
X
X  /* if failed to flush, undo everything and exit */
X  Parent(index, Up(hd));
X  if( type(index) == UNATTACHED && !sized(hd) )
X  { DeleteNode(index);
X    DisposeObject(hold_env);
X    if( LastDown(x) != x )
X    { Child(env, LastDown(x));
X      if( type(env) == ENV )  DisposeChild(LastDown(x));
X    }
X    debug1(DGT,D, "TransferBegin returning failed, x: %s", EchoObject(x));
X    return x;
X  }
X
X  if( has_rpar(actual(hd)) )
X  {
X    /* set up new target to be inner \InputSym, or nil if none */
X    if( ++itop >= MAX_DEPTH ) Error(FATAL, &fpos(x),
X	"galley nested too deeply (max is %d)", MAX_DEPTH);
X    targets[itop] = New(ACAT);  target = nil;
X    for( link = Down(hd);  link != hd;  link = NextDown(link) )
X    { Child(y, link);
X      if( type(y) == RECEPTIVE && actual(actual(y)) == InputSym )
X      {
X	Constrained(actual(y), &constraints[itop], COL);
X	if( FitsConstraint(0, 0, constraints[itop]) )
X	{ Link(targets[itop], y);  target = y;
X	  debug2(DSC, D, "Constrained( %s, COL ) = %s",
X	    EchoObject(y), EchoConstraint(&constraints[itop]));
X	  env = DetachEnv(actual(y));
X	  AttachEnv(new_env, actual(y));
X	}
X	else
X	{ Error(WARN, &fpos(hd), "galley %s deleted (target too narrow)",
X		SymName(actual(hd)));
X	}
X	break;
X      }
X    }
X
X    /* return a token appropriate to the new target */
X    if( target == nil || external(actual(target)) )
X      res = NewToken(GSTUB_EXT, no_fpos, 0, 0, precedence(xsym), nil);
X    else
X    { Constrained(actual(target), &c, ROW);
X      if( constrained(c) )  Error(FATAL, &fpos(target),
X	    "right parameter of %s is vertically constrained", SymName(xsym));
X      else res = NewToken(GSTUB_INT, no_fpos, 0, 0, precedence(xsym), nil);
X    }
X  }
X  else res = NewToken(GSTUB_NONE, no_fpos, 0, 0, precedence(xsym), nil);
X
X  DisposeObject(hold_env);
X  debug1(DGT, D, "TransferBegin returning %s", Image(type(res)));
X  ifdebug(DGT, DD, debug_targets());
X  return res;
X} /* end TransferBegin */
X
X
X/*@::TransferComponent()@*****************************************************/
X/*                                                                           */
X/*  TransferComponent(x)                                                     */
X/*                                                                           */
X/*  Transfer component x of a galley.                                        */
X/*                                                                           */
X/*****************************************************************************/
X
XTransferComponent(x)
XOBJECT x;
X{ OBJECT y, env, start_search, recs, inners, nothing, hd, dest, dest_index;
X  debug1(DGT, D, "TransferComponent( %s )", EchoObject(x));
X  ifdebug(DGT, DD, debug_targets());
X
X  /* if no dest_index, discard x and exit */
X  if( Down(targets[itop]) == targets[itop] )
X  { DisposeObject(x);
X    debug0(DGT, D, "TransferComponent returning (no target).");
X    return;
X  }
X  Child(dest_index, Down(targets[itop]));
X  assert( external(actual(dest_index)), "TransferComponent: internal!" );
X
X  /* make the component into a galley */
X  hd = New(HEAD);
X  FposCopy(fpos(hd), fpos(x));
X  actual(hd) = whereto(hd) = ready_galls(hd) = nil;
X  backward(hd) = must_expand(hd) = sized(hd) = FALSE;
X  Link(hd, x);
X  dest = actual(dest_index);
X  env = GetEnv(dest);
X  debug1(DGT, DD, "  current env chain: %s", EchoObject(env));
X  SizeGalley(hd, env, TRUE, threaded(dest), FALSE, TRUE, &save_style(dest),
X	&constraints[itop], nil, &nothing, &recs, &inners);
X  if( recs != nil )  ExpandRecursives(recs);
X
X  /* promote the components, remembering where old spot was */
X  start_search = PrevDown(Up(dest_index));
X  debug0(DSA, D, "  calling AdjustSize from TransferComponent");
X  AdjustSize(dest, back(hd, COL), fwd(hd, COL), COL);
X  Promote(hd, hd, dest_index);
X  DeleteNode(hd);
X
X  /* flush any widowed galleys attached to \Input */
X  if( Down(dest_index) != dest_index )
X  { OBJECT tinners, index;
X    tinners = New(ACAT);
X    while( Down(dest_index) != dest_index )
X    { Child(y, Down(dest_index));
X      assert( type(y) == HEAD, "TransferComponent: input child!" );
X      DetachGalley(y);
X      Parent(index, Up(y));
X      MoveLink(Up(index), NextDown(start_search), PARENT);
X      Link(tinners, index);
X    }
X    FlushInners(tinners, nil);
X  }
X
X  /* flush any galleys inside hd */
X  if( inners != nil )  FlushInners(inners, nil);
X
X  /* flush parent galley, if needed */
X  if( blocked(dest_index) )
X  { blocked(dest_index) = FALSE;
X    Parent(y, Up(dest_index));
X    debug0(DGF, D, "  calling FlushGalley from TransferComponent");
X    FlushGalley(y);
X  }
X  
X  debug0(DGT, D, "TransferComponent returning.");
X  ifdebug(DGT, DD, debug_targets());
X} /* end TransferComponent */
X
X
X/*@::TransferEnd()@***********************************************************/
X/*                                                                           */
X/*  TransferEnd(x)                                                           */
X/*                                                                           */
X/*  End the transfer of a galley.                                            */
X/*                                                                           */
X/*****************************************************************************/
X
XTransferEnd(x)
XOBJECT x;
X{ OBJECT recs, inners, nothing, z, env, dest, hd, dest_index, y, start_search;
X  debug1(DGT, D, "TransferEnd( %s )", EchoObject(x));
X  ifdebug(DGT, DD, debug_targets());
X
X  /* if no dest_index, discard x and exit */
X  if( Down(targets[itop]) == targets[itop] )
X  { DisposeObject(x);  DisposeObject(targets[itop--]);
X    debug0(DGT, D, "TransferEnd returning: no dest_index");
X    return;
X  }
X  Child(dest_index, Down(targets[itop]));
X
X  /* make the component into a galley */
X  hd = New(HEAD);  FposCopy(fpos(hd), fpos(x));
X  actual(hd) = whereto(hd) = ready_galls(hd) = nil;
X  backward(hd) = must_expand(hd) = sized(hd) = FALSE;
X  Link(hd, x);  dest = actual(dest_index);  env = GetEnv(dest);
X  debug1(DGT, DD, "  current env chain: %s", EchoObject(env));
X  SizeGalley(hd, env, external(dest), threaded(dest), FALSE, TRUE,
X	&save_style(dest), &constraints[itop], nil, &nothing, &recs, &inners);
X  if( recs != nil )  ExpandRecursives(recs);
X
X  /* promote the components, remembering where old spot was */
X  start_search = PrevDown(Up(dest_index));
X  debug0(DSA, D, "calling AdjustSize from TransferEnd (a)");
X  AdjustSize(dest, back(hd, COL), fwd(hd, COL), COL);
X  if( !external(dest) )
X  { Child(z, LastDown(hd));
X    debug0(DSA, D, "calling AdjustSize from TransferEnd (b)");
X    AdjustSize(dest, back(z, ROW), fwd(z, ROW), ROW);
X    Interpose(dest, VCAT, hd, z);
X  }
X  Promote(hd, hd, dest_index);  DeleteNode(hd);
X
X  /* flush any widowed galleys attached to \Input */
X  if( Down(dest_index) != dest_index )
X  { OBJECT tinners, index;
X    tinners = New(ACAT);
X    while( Down(dest_index) != dest_index )
X    { Child(y, Down(dest_index));
X      assert( type(y) == HEAD, "TransferComponent: input child!" );
X      DetachGalley(y);
X      Parent(index, Up(y));
X      MoveLink(Up(index), NextDown(start_search), PARENT);
X      Link(tinners, index);
X    }
X    FlushInners(tinners, nil);
X  }
X
X  /* flush any galleys inside hd */
X  if( inners != nil )  FlushInners(inners, nil);
X
X  /* close dest_index, and flush parent galley if needed */
X  if( blocked(dest_index) )
X  { Parent(y, Up(dest_index));
X    DeleteNode(dest_index);
X    debug0(DGF, D, "  calling FlushGalley from TransferEnd");
X    FlushGalley(y);
X  }
X  else DeleteNode(dest_index);
X  
X  /* pop target stack and exit */
X  DisposeObject(targets[itop--]);
X  debug0(DGT, D, "TransferEnd returning.");
X  ifdebug(DGT, DD, debug_targets());
X} /* end TransferEnd */
X
X/*@::TransferClose()@*********************************************************/
X/*                                                                           */
X/*  TransferClose()                                                          */
X/*                                                                           */
X/*  Close this module.                                                       */
X/*                                                                           */
X/*****************************************************************************/
X
XTransferClose()
X{ OBJECT inners;
X  debug0(DGT, D, "TransferClose()");
X  debug0(DGA, D, "  calling FreeGalley from TransferClose");
X  if( LastDown(root_galley) != root_galley )
X  { inners = nil;
X    FreeGalley(root_galley, root_galley, &inners, nil, nil);
X    if( inners != nil )  FlushInners(inners, nil);
X    debug0(DGF, D, "  calling FlushGalley from TransferClose");
X    FlushGalley(root_galley);
X  }
X  debug0(DGT, D, "TransferClose returning.");
X}
END_OF_FILE
  if test 16805 -ne `wc -c <'z18.c'`; then
    echo shar: \"'z18.c'\" unpacked with wrong size!
  fi
  # end of 'z18.c'
fi
echo shar: End of archive 15 \(of 35\).
cp /dev/null ark15isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
