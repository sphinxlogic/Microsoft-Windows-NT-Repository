Newsgroups: comp.sources.misc
From: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Subject: v38i098:  lout - Lout document formatting system, v2.05, Part30/35
Message-ID: <1993Aug10.132252.18938@sparky.sterling.com>
X-Md4-Signature: feb02a7c4c6ace1f90a9ff44068f5565
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Tue, 10 Aug 1993 13:22:52 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jeff@joyce.cs.su.oz.au (Jeff Kingston)
Posting-number: Volume 38, Issue 98
Archive-name: lout/part30
Environment: UNIX
Supersedes: lout: Volume 37, Issue 99-128

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  data/loutrefs.ld doc/tr.begin/s03 doc/tr.eq/s6
#   doc/tr.fig/s3 doc/tr.impl/oldrefs.ld doc/tr.impl/s3.3
#   doc/tr.lout/ch1.01 doc/tr.lout/ch2.01 doc/tr.lout/ch2.05
#   include/tab_prepend z28.c z32.c
# Wrapped by kent@sparky on Sun Aug  8 12:29:32 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 30 (of 35)."'
if test -f 'data/loutrefs.ld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'data/loutrefs.ld'\"
else
  echo shar: Extracting \"'data/loutrefs.ld'\" \(5693 characters\)
  sed "s/^X//" >'data/loutrefs.ld' <<'END_OF_FILE'
X{ @Reference
X     @Tag { knuth84 }
X     @Type { Book }
X     @Author { Knuth, Donald E. }
X     @Title { The T{ /0.2fo E}XBook }
X     @Publisher { Addison-Wesley }
X     @Year { 1984 }
X}
X
X{ @Reference
X     @Tag { adobe90 }
X     @Type { Book }
X     @Author { Adobe Systems, Inc. }
X     @Title { PostScript Language Reference Manual, Second Edition }
X     @Publisher { Addison-Wesley }
X     @Year { 1990 }
X}
X
X{ @Reference
X     @Tag { reid80 }
X     @Type { ConferencePaper }
X     @Author { Reid, Brian K. }
X     @Title { A High-Level Approach to Computer Document Production }
X     @Proceedings { Proceedings of the 7th Symposium on the Principles
Xof Programming Languages (POPL), Las Vegas NV }
X     @Pages { 24--31 }
X     @Year { 1980 }
X}
X
X{ @Reference
X     @Tag { strunk79 }
X     @Type { Book }
X     @Author { Strunk, William and White, E. B. }
X     @Title { The Elements of Style }
X     @Publisher { Macmillan, third edition }
X     @Year { 1979 }
X}
X
X{ @Reference
X     @Tag { ossanna76 }
X     @Type { TechReport }
X     @Author { Joseph F. Ossanna }
X     @Title { "Nroff/Troff" User's Manual }
X     @Number { 54 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan75 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. and Cherry, Lorinda L. }
X     @Title { A system for typesetting mathematics }
X     @Journal { Communications of the ACM }
X     @Volume { 18 }
X     @Pages { 182--193 }
X     @Year { 1975 }
X}
X
X{ @Reference
X     @Tag { lesk76 }
X     @Type { TechReport }
X     @Author { Lesk, M. E. }
X     @Title { Tbl -- a program to format tables }
X     @Number { 49 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan82 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. }
X     @Title { PIC -- A language for typesetting graphics}
X     @Journal { Software Practice and Experience }
X     @Volume { 12 }
X     @Pages { 1--21 }
X     @Year { 1982 }
X}
X
X{ @Reference
X     @Tag { kingston93basser }
X     @Type { Software }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The Basser Lout Document Formatter, Version 2.05 }
X     @Year { 1993 }
X     @Comment { Computer program, publicly available in the
X@I jeff subdirectory of the home directory of @I ftp to host
X@I ftp.cs.su.oz.au with login name @I anonymous or @I ftp and any
Xnon-empty password (e.g. {@I none}).  Lout distributions are also
Xavailable from the comp.sources.misc newsgroup.  All enquiries to
X"jeff@cs.su.oz.au". }
X}
X
X{ @Reference
X     @Tag { kingston92 }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Document Formatting with Lout (Second Edition) }
X     @Number { 449 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92begin }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A beginners' guide to Lout }
X     @Number { 450 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92eq }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Eq -- a Lout package for typesetting mathematics }
X     @Number { 452 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X     @Comment { Contains an appendix describing the Pas Pascal
Xformatter. }
X}
X
X{ @Reference
X     @Tag { kingston92fig }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Fig -- a Lout package for drawing figures }
X     @Number { 453 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston91over }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A new approach to document formatting }
X     @Number { 412 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston92tab }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Tab -- a Lout package for formatting tables }
X     @Number { 451 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X}
X
X{ @Reference
X     @Tag { kingston92design }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The design and implementation of the Lout document formatting language }
X     @Number { 442 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1992 }
X     @Comment { To appear in @I { Software---Practice and Experience. } }
X}
X
X{ @Reference
X     @Tag { wirth71 }
X     @Type { JournalArticle }
X     @Author { Wirth, N. }
X     @Title { The programming language Pascal }
X     @Journal { Acta Informatica }
X     @Volume { 1 }
X     @Year { 1975 }
X     @Pages { 35--63 }
X}
X
X{ @Reference
X     @Tag { brooks91 }
X     @Type { JournalArticle }
X     @Author { Brooks, Kenneth P. }
X     @Title { Lilac: a two-view document editor }
X     @Journal { IEEE Computer }
X     @Volume { @Null }
X     @Pages { 7--19 }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { furuta82 }
X     @Type { JournalArticle }
X     @Author { Furuta, Richard, Scofield, Jeffrey,
Xand Shaw, Alan }
X     @Title { Document formatting systems:  survey,
Xconcepts, and issues }
X     @Journal { Computing Surveys }
X     @Volume { 14 }
X     @Pages { 417--472 }
X     @Year { 1982 }
X}
END_OF_FILE
  if test 5693 -ne `wc -c <'data/loutrefs.ld'`; then
    echo shar: \"'data/loutrefs.ld'\" unpacked with wrong size!
  fi
  # end of 'data/loutrefs.ld'
fi
if test -f 'doc/tr.begin/s03' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.begin/s03'\"
else
  echo shar: Extracting \"'doc/tr.begin/s03'\" \(5189 characters\)
  sed "s/^X//" >'doc/tr.begin/s03' <<'END_OF_FILE'
X@Section
X   @Tag { lists }
X   @Title { Lists }
X@Begin
X@PP
XWe have just seen that consecutive displays are awkward to space
Xcorrectly.  Provided they are not aligned or numbered,
Xthese are better treated as a {@I list}:
X@ID @Code {
X"... preceding text."
X"@IndentedList"
X"@ListItem @I Emma"
X"@ListItem @I { Mansfield Park }"
X"@EndList"
X"following text ..."
X}
XThere are {@Code "@LeftList"}, {@Code "@IndentedList"}, and
X@Code "@CentredList" (or {@Code "@CenteredList"}) symbols; each item is
Xintroduced by {@Code "@ListItem"}, and the list ends with
X{@Code "@EndList"}.  There may be any number of items; @Code "@DP"
Xsymbols are inserted before, between, and after them.
X@PP
XA variety of automatically generated tags is available for indented
Xlists.  Here is the full set, showing the first tag produced:
X@ID {
X     @Code "@NumberedList"	|1c	1.
X/1vx @Code "@ParenNumberedList" |	(1)
X/1vx @Code "@RomanList"		|	i.
X/1vx @Code "@ParenRomanList"	|	(i)
X/1vx @Code "@UCRomanList"	|	I.
X/1vx @Code "@ParenUCRomanList"	|	(I)
X/1vx @Code "@AlphaList"		|	a.
X/1vx @Code "@ParenAlphaList"	|	(a)
X/1vx @Code "@UCAlphaList"	|	A.
X/1vx @Code "@ParenUCAlphaList"	|	(A)
X/1vx @Code "@BulletList"	|	@Bullet
X/1vx @Code "@StarList"		|	@Star
X/1vx @Code "@DashList"		|	--
X}
XThe Roman numerals end at c (100), and the alphabet ends
Xat z (26), but ordinary numbers have no limit.  For example,
X@ID @Code {
X"@Heading { Quiz }"
X"@NumberedList"
X"@ListItem { Which American"
X"statesman owned a"
X"two-storey clock? }"
X"@ListItem { Which Yankee"
X"commander cut a swathe of"
X"destruction through the"
X"State of Georgia? }"
X"@EndList"
X}
Xhas result
X@ID {
X@Heading { Quiz }
X@DP
X@RawNumberedList
X@ListItem { Which American
Xstatesman owned a
Xtwo-storey clock? }
X@ListItem { Which Yankee
Xcommander cut a swathe of
Xdestruction through the
XState of Georgia? }
X@EndList
X}
XAlternatively, the tags may be supplied by the author, using the
X@Code "@TaggedList" symbol and its variants @Code "@WideTaggedList" and
X{@Code "@VeryWideTaggedList"}, which leave a wider indent for the tags:
X@ID @Code {
X"@WideTaggedList"
X"{ 9 a.m. } @TagItem { Breakfast in"
X"the Ipamena Lounge, served with"
X"Irish coffee and fresh croissants. }"
X"{ 10 a.m. } @TagItem { Prof. A. Smith"
X"speaks on `The Wealth of Nations.' }"
X"@EndList"
X}
Xhas result
X@ID {
X@RawWideTaggedList
X{ 9 a.m. } @TagItem { Breakfast in
Xthe Ipamena Lounge, served with
XIrish coffee and fresh croissants. }
X{ 10 a.m. } @TagItem { Prof. A. Smith
Xspeaks on `The Wealth of Nations.' }
X@EndList
X}
XEach @Code "@TagItem" symbol uses the thing just preceding it as the tag.
X@PP
XEach of these lists also has a `raw' version which omits the preceding
Xand following space.  These are mainly used when an item is itself a list:
X@ID @Code {
X"@ParenNumberedList"
X"@ListItem {"
X"   @RawParenRomanList"
X"   @ListItem { MV Nominees,"
X"hereinafter called the vendor, ... }"
X"   @EndList"
X"}"
X"@EndList"
X}
Xhas result
X@ID {
X@RawParenNumberedList
X@ListItem {
X   @RawParenRomanList
X   @ListItem { MV Nominees,
Xhereinafter called the vendor, ... }
X   @EndList
X}
X@EndList
X}
XIf @Code "@ParenRomanList" had been used instead of
X{@Code "@RawParenRomanList"}, (1) and (i) would have appeared on
Xdifferent lines.
X@PP
XIn cases where it is desired to have a paragraph symbol following a raw
Xlist, owing to problems behind the scenes this symbol should be placed
Xbefore the first {@Code "@ListItem"} or {@Code "@TagItem"}, not after
Xthe @Code "@EndList" as would naturally be expected.
X@PP
XA finer control over the appearance of lists is obtained with
X@Code "@RawIndentedList" and {@Code "@RawTaggedList"}.  These
Xhave {@I options}:  optional subsidiary symbols which modify the
Xresult.  For example,
X@ID @Code {
X"@RawIndentedList"
X"     style { [tag] }"
X"     indent { 0.5i }"
X"     gap { 0.3v }"
X"     start { 5 }"
X"@ListItem { ... }"
X"@ListItem { ... }"
X"@EndList"
X}
Xshows the four options available with {@Code "@RawIndentedList"}, namely
X{@Code style}, @Code {indent}, {@Code gap}, and {@Code start}.  It
Xhas result
X@ID {
X@RawIndentedList
X     style { [tag] }
X     indent { 0.5i }
X     gap { 0.3v }
X     start { 5 }
X@ListItem { ... }
X@ListItem { ... }
X@EndList
X}
XThe @Code style option determines the appearance of each tag, any
X@Code tag symbol
Xwithin it being replaced by the number of the item.  If numbers are not
Xwanted in the tag, @Code tag may be omitted.  The other options
Xdetermine the indent, the gap between items, and the number of the first
Xitem.  In general, options may be given in any order, and if omitted
Xwill revert to a reasonable standard value.  @Code "@RawTaggedList" works
Xin a similar way, except that @Code tag is replaced by the tag supplied
Xby the @Code "@TagItem" symbol, and there is no @Code start option.  The
Xsymbol @Code "@DP" may be used above or below the list to produce the
Xusual amount of space.
X@PP
XIndividual list items are kept together on one page or column.  However,
Xa new page may be started between two list items.
X@PP
XEvery symbol introduced in this section has an abbreviated form consisting
Xof @Code "@" followed by its capital letters only.  For example,
X@Code "@RawNumberedList" abbreviates to {@Code "@RNL"}, and
X@Code "@ListItem" to {@Code "@LI"}.
X@End @Section
END_OF_FILE
  if test 5189 -ne `wc -c <'doc/tr.begin/s03'`; then
    echo shar: \"'doc/tr.begin/s03'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.begin/s03'
fi
if test -f 'doc/tr.eq/s6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.eq/s6'\"
else
  echo shar: Extracting \"'doc/tr.eq/s6'\" \(5589 characters\)
  sed "s/^X//" >'doc/tr.eq/s6' <<'END_OF_FILE'
X@Appendix
X    @Title { Pas -- a Lout Package for Printing Pascal Programs }
X@Begin
X@PP
XPas
X@Reference
X   @Tag { jensen75 }
X   @Type { Book }
X   @Author { Jensen, K. and Wirth, N. }
X   @Title { Pascal User Manual and Report }
X   @Publisher { Springer-Verlag }
X   @Year { 1975 }
Xis a package of definitions for printing Pascal programs
X[{@Ref jensen75}] neatly with the Lout document formatter
X[{@Ref kingston92}].  No attempt is made to follow any particular
Xprinting standard; the design simply reflects the author's taste.
X@PP
XThe package is so simple that there is very little to say about
Xit.  To use Pas, place @Code "@SysInclude { pas }" in the setup file,
Xor type @Code "-ipas" in the command line.  A Pascal program is
Xentered like this, where the @Code "@ID" symbol from the DocumentLayout
Xpackage [{@Ref kingston92begin}] has been used to obtain an indented display:
X@ID @Code {
X"@ID @Pas {"
X"procedure PriDelete(x: PriEntry; var Q: PriorityQueue);"
X"    var i: integer;"
X"begin"
X"    with Q^ do begin"
X"        size := size - 1;"
X"        if x^.back <= size then"
X"        begin"
X"            i := x^.back;"
X"            A[i] := A[size + 1];"
X"            A[i]^.back := i;"
X"            PriAddRoot(i, Q);"
X"            PriAddLeaf(i, Q)"
X"        end"
X"    end"
X"end;"
X"}"
X}
XThe result will come out like this:
X@ID @Pas {
Xprocedure PriDelete(x: PriEntry; var Q: PriorityQueue);
X    var i: integer;
Xbegin
X    with Q^ do begin
X	size := size - 1;
X	if x^.back <= size then
X	begin
X	    i := x^.back;
X	    A[i] := A[size + 1];
X	    A[i]^.back := i;
X	    PriAddRoot(i, Q);
X	    PriAddLeaf(i, Q)
X	end
X    end
Xend;
X}
XBlank lines, line breaks, indents and spaces in the input are respected, with a
Xtab being considered equal to eight spaces.  @Code "@Pas" can also be used
Xwithin a paragraph to produce Pascal fragments like @Pas { A[i..j] }.  Use
X@Code "@OneCol @Pas { ... }" to prevent the result from breaking over two
Xlines.
X@PP
X@Code "@Pas" does not attempt to rearrange the program in any way.  Each
Xitem is simply printed according to the following plan:
X@ID {
X7c @Wide {
X      @Code and 	|2.5ct @Pas { and }
X//1vx @Code array 	|2.5ct @Pas { array }
X//1vx @Code begin 	|2.5ct @Pas { begin }
X//1vx @Code case 	|2.5ct @Pas { case }
X//1vx @Code const 	|2.5ct @Pas { const }
X//1vx @Code div 	|2.5ct @Pas { div }
X//1vx @Code do 		|2.5ct @Pas { do }
X//1vx @Code downto 	|2.5ct @Pas { downto }
X//1vx @Code else 	|2.5ct @Pas { else }
X//1vx @Code end 	|2.5ct @Pas { end }
X//1vx @Code file 	|2.5ct @Pas { file }
X//1vx @Code for 	|2.5ct @Pas { for }
X//1vx @Code forward	|2.5ct @Pas { forward }
X//1vx @Code function 	|2.5ct @Pas { function }
X//1vx @Code goto 	|2.5ct @Pas { goto }
X//1vx @Code if 		|2.5ct @Pas { if }
X//1vx @Code in 		|2.5ct @Pas { in }
X//1vx @Code label 	|2.5ct @Pas { label }
X//1vx @Code mod 	|2.5ct @Pas { mod }
X//1vx @Code nil 	|2.5ct @Pas { nil }
X//1vx @Code not 	|2.5ct @Pas { not }
X//1vx @Code of 		|2.5ct @Pas { of }
X//1vx @Code or 		|2.5ct @Pas { or }
X//1vx @Code otherwise 	|2.5ct @Pas { otherwise }
X//1vx @Code packed 	|2.5ct @Pas { packed }
X//1vx @Code procedure 	|2.5ct @Pas { procedure }
X//1vx @Code program 	|2.5ct @Pas { program }
X//1vx @Code record 	|2.5ct @Pas { record }
X//1vx @Code repeat 	|2.5ct @Pas { repeat }
X//1vx @Code set 	|2.5ct @Pas { set }
X//1vx @Code then 	|2.5ct @Pas { then }
X//1vx @Code to 		|2.5ct @Pas { to }
X//1vx @Code type 	|2.5ct @Pas { type }
X//1vx @Code until 	|2.5ct @Pas { until }
X//1vx @Code var 	|2.5ct @Pas { var }
X//1vx @Code while 	|2.5ct @Pas { while }
X//1vx @Code with 	|2.5ct @Pas { with }
X} | 7c @Wide {
X      @Code "0"		|2.5ct @Pas { 0 }
X//1vx @Code "1"		|2.5ct @Pas { 1 }
X//1vx @Code "2"		|2.5ct @Pas { 2 }
X//1vx @Code "3"		|2.5ct @Pas { 3 }
X//1vx @Code "4"		|2.5ct @Pas { 4 }
X//1vx @Code "5"		|2.5ct @Pas { 5 }
X//1vx @Code "6"		|2.5ct @Pas { 6 }
X//1vx @Code "7"		|2.5ct @Pas { 7 }
X//1vx @Code "8"		|2.5ct @Pas { 8 }
X//1vx @Code "9"		|2.5ct @Pas { 9 }
X//1vx @Code "."		|2.5ct @Pas { . }
X//1vx @Code ","		|2.5ct @Pas { , }
X//1vx @Code ":"		|2.5ct @Pas { : }
X//1vx @Code ";"		|2.5ct @Pas { ; }
X//1vx @Code "'"		|2.5ct @Pas { ' }
X//1vx @Code "`"		|2.5ct @Pas { ` }
X//1vx @Code "+"		|2.5ct @Pas { + }
X//1vx @Code "-"		|2.5ct @Pas { - }
X//1vx @Code "*"		|2.5ct @Pas { * }
X//1vx @Code "/"		|2.5ct @Pas { / }
X//1vx @Code "("		|2.5ct @Pas { ( }
X//1vx @Code ")"		|2.5ct @Pas { ) }
X//1vx @Code "["		|2.5ct @Pas { [ }
X//1vx @Code "]"		|2.5ct @Pas { ] }
X//1vx @Code "^"		|2.5ct @Pas { ^ }
X//1vx @Code ".."	|2.5ct @Pas { .. }
X//1vx @Code "="		|2.5ct @Pas { = }
X//1vx @Code "<"		|2.5ct @Pas { < }
X//1vx @Code ">"		|2.5ct @Pas { > }
X//1vx @Code "<>"	|2.5ct @Pas { <> }
X//1vx @Code "<="	|2.5ct @Pas { <= }
X//1vx @Code ">="	|2.5ct @Pas { >= }
X//1vx @Code ":="	|2.5ct @Pas { := }
X}
X}
XAnything not mentioned here will appear in italic font.
X@PP
XPascal character strings need a little attention before formatting by
XPas.  Their interiors are best enclosed in double quotes to prevent the
Xabove transformations from occurring inside them.  Any @Code "\\" or
X@Code "\"" characters inside strings will need to be replaced by
X@Code "\\\\" and @Code "\\\"" respectively, and the opening quote should
Xbe replaced by {@Code "`"}.
X@PP
XSimilar remarks apply to Pascal comments; don't forget that @Code "{"
Xand @Code "}" must be enclosed in double quotes.  Alternatively, a
X@Code "@Com" symbol can be placed in front of a comment enclosed
Xin braces.  It will add literal braces:
X@ID @Code {
X"@Com { A Pascal comment }"
X}
Xhas result
X@ID @Pas {
X@Com { A Pascal comment }
X}
XIt may still be necessary to enclose the interior in double quotes.
X@End @Appendix
END_OF_FILE
  if test 5589 -ne `wc -c <'doc/tr.eq/s6'`; then
    echo shar: \"'doc/tr.eq/s6'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.eq/s6'
fi
if test -f 'doc/tr.fig/s3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.fig/s3'\"
else
  echo shar: Extracting \"'doc/tr.fig/s3'\" \(5295 characters\)
  sed "s/^X//" >'doc/tr.fig/s3' <<'END_OF_FILE'
X@Section
X   @Title { Creating New Shapes }
X@Begin
X@PP
XIf the needed shape is not provided by Fig, it can be created
Xusing the @Code "@Figure" symbol.  @Code "@Figure" takes all the options
Xwe have already seen, plus another one called {@Code shape}.  For
Xexample,
X@ID {
X@Code {
X"@Figure"
X"   shape {"
X"      0 0  xsize 0"
X"      0 ysize  0 0"
X"   }"
X"{ 3c @High 2c @Wide }"
X}
X||7ct
X@Fig {
X@Figure
X   shape { 0 0  xsize 0
X           0 ysize  0 0
X         }
X{ 3c @High 2c @Wide }
X}
X}
XThe pairs of numbers define points in a coordinate system whose origin
Xis the lower left corner of the right parameter; the upper right corner
Xis @Code xsize {@Code ysize}, and the point where the
Xright parameter's marks cross is {@Code "xmark ymark"}:
X@ID 10p @Font
X{
X   { &1rt @I ysize /0ik &1rt @I ymark /0ik &1rt 0 } |0.4c
X   {  /
X      |0ik @ShowMarks { 1c @High 1.5c @Wide ^| 3c @Wide ^/ 2c @High }
X      |0ik /
X   }
X   /0.3c
X   | 0 | @I xmark | @I xsize
X}
XThis arrangement is identical with that for the @Code "@Graphic"
Xsymbol of basic Lout.  A sequence of points defines a shape, like
Xthe triangle above.  Arrowheads are drawn pointing forwards from the
Xlast segment and backwards from the first, as requested; the @Code margin
Xoption has default value {@Code 0c}.
X@PP
XNormally, the points are connected by straight lines to form the shape,
Xwhich is then painted and drawn in the usual way, depending on the other
Xoptions.
X@PP
XIf two points in the shape are separated by {@Code {"[" &0.5s "]"}}, no
Xline will be drawn between them.  This permits a shape to consist of two
Xor more disconnected parts.
X@PP
XIf two points in the shape are separated by
X{@Code "[" & @Eq{x ``` y} & @Code "]"}, where
X@Eq {x} and @Eq {y} are numbers, the two points will be joined by an
Xanticlockwise arc whose centre is the point @Eq {(x, y)}.  This arc
Xwill be circular if possible, otherwise it will be part of an ellipse
Xwhose axes are oriented horizontally and vertically.  The notation
X@Code "[" & @Eq {x ``` y} @Code "clockwise]" makes the arc go
Xclockwise.  For example,
X@ID {
X@Code {
X"@Figure"
X"   shape {"
X"      0 -0.5 cm"
X"      0 0.5 cm"
X"      1 cm 0  0 -0.5 cm [" &0.5s "]"
X"      1 cm 0 [ 1.1 cm 0 ]"
X"      1 cm 0"
X"   }"
X"{}"
X}
X||7ct
X@Fig { //0.5c
X@Figure
X   shape { 0 -0.5 cm  0 0.5 cm
X           1 cm 0  0 -0.5 cm []
X           1 cm 0 [ 1.1 cm 0 ] 1 cm 0
X         }
X{}
X}
X}
XWe have recklessly disregarded the size of the right parameter when
Xdrawing this shape, a dangerous thing to do since Lout thinks that the
Xfigure is the same size as its right parameter.
X@PP
XFinally, two points may be separated by
X@Eq { [x sub 1 ``` y sub 1 ```  x sub 2 ``` y sub 2 & ] }, which requests that a
XBezier curve be drawn between them with control points
X@Eq { (x sub 1 & , y sub 1 & ) } and
X@Eq { (x sub 2 & , y sub 2 & ) }:
X@ID @Fig {
X@Figure
X   margin { 0c }
X   shape { 1 cm 2 cm 4 cm 3.5 cm  9 cm 2 cm 2 cm 0.6 cm }
X   linestyle { dashed }
X@Figure
X   margin { 0c }
X   shape { 1 cm 2 cm [4 cm 3.5 cm  9 cm 2 cm] 2 cm 0.6 cm }
X{ 7c @Wide 4c @High }
X
X// { -0.3  cm 2.0 cm } @BaseOf @Eq { (x sub 0 & , y sub 0 & )}
X// {  4.2  cm 3.5 cm } @BaseOf @Eq { (x sub 1 & , y sub 1 & )}
X// {  9.1  cm 2.0 cm } @BaseOf @Eq { (x sub 2 & , y sub 2 & )}
X// {  2.1  cm 0.0 cm } @BaseOf @Eq { (x sub 3 & , y sub 3 & )}
X}
XThe curve is attracted toward the control points, without reaching
Xthem; it is tangent to the straight line from the start point to the
Xfirst control point, and from the second control point to the finishing
Xpoint, and it lies wholly inside the quadrilateral formed by the four
Xpoints.  Owing to the author's laziness, dashes and dots do not fit as
Xneatly onto Bezier curves as they do onto lines and arcs.
X @Code "@Figure" should be general enough to draw most shapes; for
Xexample, all the other shapes ({@Code "@Box"}, {@Code "@Circle"}, etc.)
Xare just instances of {@Code "@Figure"}.  When it is inadequate, one
Xcan fall back to the standard @Code "@Graphic" symbol.
X@PP
XLines, arrows and arcs at any angle can be produced using {@Code "@Figure"}:
X@ID {
X@Code {
X"@Figure"
X"   shape { 0 0  xsize ysize }"
X"   arrow { forward }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Figure
X   shape { 0 0  xsize ysize }
X   arrow { forward }
X{ 2c @High 3c @Wide }
X}
X}
XHowever, for convenience there are symbols @Code "@Line" and @Code
X"@Arrow" which have two options, @Code "from" and {@Code "to"}, for
Xspecifying the endpoints:
X@ID {
X@Code {
X"@Arrow"
X"   from { 0 0 }"
X"   to { xsize ysize }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Arrow
X   from { 0 0 }
X   to { xsize ysize }
X{ 2c @High 3c @Wide }
X}
X}
XThere is also an @Code "@Arc" symbol, which draws a circular or
Xelliptical arc from one point to another about a given centre, with
Xthe usual options:
X@ID {
X@Code {
X"@Arc"
X"   from { 0 0 }"
X"   to { xsize ysize }"
X"   ctr { 0 ysize }"
X"   direction { anticlockwise }"
X"   arrow { forward }"
X"   linestyle { dashed }"
X"{ 2c @High 3c @Wide }"
X}
X||7ct
X@Fig {
X@Arc
X   from { 0 0 }
X   to { xsize ysize }
X   ctr { 0 ysize }
X   direction { anticlockwise }
X   arrow { forward }
X   linestyle { dashed }
X{ 2c @High 3c @Wide }
X}
X}
XThe arc goes either @Code clockwise (the default) or @Code anticlockwise
Xabout the centre, depending on the @Code direction option.  Any
Xarrowhead will point in a direction tangent to the arc.
X@End @Section
END_OF_FILE
  if test 5295 -ne `wc -c <'doc/tr.fig/s3'`; then
    echo shar: \"'doc/tr.fig/s3'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.fig/s3'
fi
if test -f 'doc/tr.impl/oldrefs.ld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/oldrefs.ld'\"
else
  echo shar: Extracting \"'doc/tr.impl/oldrefs.ld'\" \(5587 characters\)
  sed "s/^X//" >'doc/tr.impl/oldrefs.ld' <<'END_OF_FILE'
X{ @Reference
X     @Tag { knuth84 }
X     @Type { Book }
X     @Author { Knuth, Donald E. }
X     @Title { The T{ /0.2fo E}XBook }
X     @Publisher { Addison-Wesley }
X     @Year { 1984 }
X}
X
X{ @Reference
X     @Tag { adobe85 }
X     @Type { Book }
X     @Author { Adobe Systems, Inc. }
X     @Title { PostScript Language Reference Manual }
X     @Publisher { Addison-Wesley }
X     @Year { 1985 }
X}
X
X{ @Reference
X     @Tag { reid80 }
X     @Type { ConferencePaper }
X     @Author { Reid, Brian K. }
X     @Title { A High-Level Approach to Computer Document Production }
X     @Proceedings { Proceedings of the 7th Symposium on the Principles
Xof Programming Languages (POPL), Las Vegas NV }
X     @Pages { 24--31 }
X     @Year { 1980 }
X}
X
X{ @Reference
X     @Tag { strunk79 }
X     @Type { Book }
X     @Author { Strunk, William and White, E. B. }
X     @Title { The Elements of Style }
X     @Publisher { Macmillan, third edition }
X     @Year { 1979 }
X}
X
X{ @Reference
X     @Tag { ossanna76 }
X     @Type { TechReport }
X     @Author { Joseph F. Ossanna }
X     @Title { "Nroff/Troff" User's Manual }
X     @Number { 54 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan75 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. and Cherry, Lorinda L. }
X     @Title { A system for typesetting mathematics }
X     @Journal { Communications of the ACM }
X     @Volume { 18 }
X     @Pages { 182--193 }
X     @Year { 1975 }
X}
X
X{ @Reference
X     @Tag { lesk76 }
X     @Type { TechReport }
X     @Author { Lesk, M. E. }
X     @Title { Tbl -- a program to format tables }
X     @Number { 49 }
X     @Institution { Bell Laboratories, Murray Hill, NJ 07974 }
X     @Year { 1976 }
X}
X
X{ @Reference
X     @Tag { kernighan82 }
X     @Type { JournalArticle }
X     @Author { Kernighan, Brian W. }
X     @Title { PIC -- A language for typesetting graphics}
X     @Journal { Software Practice and Experience }
X     @Volume { 12 }
X     @Pages { 1--21 }
X     @Year { 1982 }
X}
X
X{ @Reference
X     @Tag { kingston91 }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Document Formatting with Lout }
X     @Number { 408 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91basser }
X     @Type { Software }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The Basser Lout Document Formatter }
X     @Year { 1991 }
X     @Comment { Computer program; Version 2 publicly available
Xin the @I jeff subdirectory of the home directory of @I ftp to host
X@I ftp.cs.su.oz.au with login name @I anonymous or @I ftp and any
Xnon-empty password.  Distribution via email is available for
Xnon-{@I ftp} sites.  All enquiries to "jeff@cs.su.oz.au". }
X}
X
X{ @Reference
X     @Tag { kingston91begin }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A beginners' guide to Lout }
X     @Number { 409 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91eq }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Eq -- a Lout package for typesetting mathematics }
X     @Number { 410 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X     @Comment { (Contains an appendix describing the Pas Pascal formatter.) }
X}
X
X{ @Reference
X     @Tag { kingston91fig }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Fig -- a Lout package for drawing figures }
X     @Number { 411 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91over }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { A new approach to document formatting }
X     @Number { 412 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91tab }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { Tab -- a Lout package for formatting tables }
X     @Number { 413 }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { kingston91design }
X     @Type { TechReport }
X     @Author { Kingston, Jeffrey H. }
X     @Title { The design and implementation of a document formatting language }
X     @Number { @Null }
X     @Institution { Basser Department of Computer
XScience F09, University of Sydney 2006, Australia }
X     @Year { 1991 }
X     @Comment { @I { In preparation. } }
X}
X
X{ @Reference
X     @Tag { wirth71 }
X     @Type { JournalArticle }
X     @Author { Wirth, N. }
X     @Title { The programming language Pascal }
X     @Journal { Acta Informatica }
X     @Volume { 1 }
X     @Year { 1975 }
X     @Pages { 35--63 }
X}
X
X{ @Reference
X     @Tag { brooks91 }
X     @Type { JournalArticle }
X     @Author { Brooks, Kenneth P. }
X     @Title { Lilac: a two-view document editor }
X     @Journal { IEEE Computer }
X     @Volume { @Null }
X     @Pages { 7--19 }
X     @Year { 1991 }
X}
X
X{ @Reference
X     @Tag { furuta82 }
X     @Type { JournalArticle }
X     @Author { Furuta, Richard, Scofield, Jeffrey,
Xand Shaw, Alan }
X     @Title { Document formatting systems:  survey,
Xconcepts, and issues }
X     @Journal { Computing Surveys }
X     @Volume { 14 }
X     @Pages { 417--472 }
X     @Year { 1982 }
X}
END_OF_FILE
  if test 5587 -ne `wc -c <'doc/tr.impl/oldrefs.ld'`; then
    echo shar: \"'doc/tr.impl/oldrefs.ld'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/oldrefs.ld'
fi
if test -f 'doc/tr.impl/s3.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.impl/s3.3'\"
else
  echo shar: Extracting \"'doc/tr.impl/s3.3'\" \(5264 characters\)
  sed "s/^X//" >'doc/tr.impl/s3.3' <<'END_OF_FILE'
X@SubSection
X    @Tag { modules }
X    @Title { Modules }
X@Begin
X@PP
XIt is well accepted that the visibility of symbols is not adequately
Xcontrolled by Algol block structure.  The author is aware of several
Xmajor problems of this kind in document formatting.
X@PP
XOne problem is that some symbols should be visible only within
Xrestricted parts of a document.  For example, we naturally expect
Xequation formatting to be accomplished like this:
X@ID @Code {
X"surrounding text"
X"@Eq { {x sup 2  +  1} over 4 }"
X"surrounding text"
X}
Xwith the symbols {@Code "sup"}, {@Code "over"}, etc., visible only within
Xthe equation, not in the surrounding text.
X@PP
XIt seems natural to define these symbols within {@Code "@Eq"}, since
Xthey are local to equations.  It only remains then to decree that
Xsymbols local to @Code "@Eq" are to be visible within its actual right
Xparameter, and this is done by replacing the right formal parameter with a
X@I body parameter:
X@ID @Code {
X"export sup over"
X"def @Eq"
X"    body @Body"
X"{"
X"    def sup ..."
X"    def over ..."
X""
X"    Slope @Font @Body"
X"}"
X}
XThe @Code export clause lists the identifiers which are permitted to be
Xvisible outside their usual range, the body of {@Code "@Eq"}; and the
X@Code body declaration imports them into (makes them visible within)
Xthe actual right parameter of each invocation of {@Code "@Eq"}.  This
Xarrangement has proven very convenient for defining a variety of
Xspecial-purpose packages.
X@PP
XAnother problem arises when global symbols, such as the ones used for
Xheadings and paragraph separators, call on values that the non-expert
Xuser will need to modify, such as the initial font or paragraph
Xindent.  These values are like parameters of the document as a whole, so
Xit is natural to try this:
X@ID @Code {
X"export @Heading @PP ..."
X"def @BookLayout"
X"    named @InitialFont { Times Base 12p }"
X"    named @InitialBreak { adjust 14p }"
X"    named @ColumnWidth { 6i }"
X"    ..."
X"{"
X"    def @Heading ..."
X"    def @PP ..."
X"}"
X}
XNow @Code "@Heading" and @Code "@PP" may invoke @Code "@InitialFont"
Xand the other parameters.  To make @Code "@Heading" and @Code "@PP"
Xvisible throughout the document, we need only add a body parameter to
X@Code "@BookLayout" and present the entire document as
X@ID @Code {
X"@BookLayout"
X"    @InitialFont { Helvetica Base 10p }"
X"    @InitialBreak { adjust 12p }"
X"{"
X"    The document."
X"}"
X}
Xbut for practical reasons given below we prefer not to enclose the
Xentire document in braces.  Instead, we write
X@ID @Code {
X"@Use { @BookLayout"
X"    @InitialFont { Helvetica Base 10p }"
X"    @InitialBreak { adjust 12p }"
X"}"
X"The document."
X}
Xwhich has the same effect:  @Code "@Use" makes the exported symbols of
X@Code "@BookLayout" visible for the remainder of the document, and is
Xpermitted only at the beginning.
X@PP
XThe third feature that affects visibility, and which will prove useful
Xfor cross referencing (Section {@NumberOf cross}), is the @Code "@Open"
Xsymbol.  It makes the exported symbols of its left parameter visible
Xwithin its right parameter, and is therefore similar to the Pascal @Code
Xwith statement.
X@PP
XIt could be argued that Lout is over-supplied with these visibility modifying
Xfeatures: the body parameter, @Code "@Use" and @Code "@Open" do not seem
Xsufficiently different from each another.  The @Code "@Open" symbol is
Xthe most general, being capable of replacing the other two.  For
Xexample,
X@ID @Code {
X"@Use { x }"
X"@Use { y }"
X"Body of document"
X}
Xcan be replaced by
X@ID @Code {
X"x @Open {"
X"y @Open {"
X"Body of document"
X"}}"
X}
Xand, taking the @Code "@Eq" symbol above as example, we could eliminate
Xits body parameter, add
X@ID @Code "def @Body right x { Slope @Font x }"
Xto the exported definitions of {@Code "@Eq"}, and replace
X@ID @Code "@Eq { object }"
Xby
X@ID @Code "@Eq @Open { @Body { object } }"
XIf @Code "@Eq" is a galley (Section {@NumberOf galleys}), @Code "@Body"
Xmust take over that function.  But one would not want to write these
Xclumsy expressions in practice, and the enclosure of large quantities
Xof input in extra braces could cause Basser Lout to run out of memory
X(Section {@NumberOf lookahead}).
X@PP
XA quite separate kind of visibility problem arises when expert
Xusers wish to define an object or operator for repeated use within, say,
Xequations:
X@ID @Code "def isum { sum from i=1 to n }"
XAs it stands this can only be placed within the @Code "@Eq" package itself, 
Xwhere @Code "sum" and the other symbols are visible, but it is not desirable
Xto modify the source code of a standard package.  Lout provides an
X@Code "import" clause to solve this problem:
X@ID @Code {
X"import @Eq"
X"def isum { sum from i=1 to n }"
X}
Xmay appear after @Code "@Eq" is defined, and it will make the exported symbols
Xof @Code "@Eq" visible within the body of {@Code "isum"}.  This feature
Xcomplicates the treatment of environments (Section {@NumberOf defs.impl}),
Xand even introduces an insecurity, when @Code isum is invoked outside an
Xequation.  A simpler approach would be to allow only one symbol in an
X@Code import clause, and treat the following definition exactly like a
Xlocal definition of that symbol; but then it would not be possible
Xto define symbols using the resources of more than one of the standard
Xpackages.
X@End @SubSection
END_OF_FILE
  if test 5264 -ne `wc -c <'doc/tr.impl/s3.3'`; then
    echo shar: \"'doc/tr.impl/s3.3'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.impl/s3.3'
fi
if test -f 'doc/tr.lout/ch1.01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch1.01'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch1.01'\" \(6589 characters\)
  sed "s/^X//" >'doc/tr.lout/ch1.01' <<'END_OF_FILE'
X@Section
X  @Title { Objects }
X  @Tag { objects }
X@Begin
X@PP
XSince our aim is to produce neatly formatted documents, we should begin by
Xlooking at a typical example of such a document:
X@ID {
Xnohyphen @Break @LittleDocument
X//
X@LittleText {
X@DP
X|0.5rt {@B PURCELL}{ 0.8f @Font 1 ^//0.2v}
X@LittleFootNote
X{ { 0.8f @Font 1 ^//0.2v}Blom, Eric.  @I {Some Great Composers.}  Oxford, 1944.
X}
X@DP
XIn the world of music England is supposed to be a mere province.  If she
Xproduces an indifferent composer or performer, that is regarded
Xelsewhere as perfectly normal and natural; but if foreign students of
Xmusical history have to acknowledge a British musical genius, he is
Xconsidered a freak.
X@PP
XSuch a freak is Henry Purcell.  Yet if we make a choice of fifteen of
Xthe world's musical classics, as here, we find that we cannot omit this
XEnglish master.
X}
X//
X@LittleEndRun
X}
XIt is a large rectangle made from three smaller rectangles -- its
Xpages.  Each page is made of lines; each line is made of words,
Xalthough it makes sense for any rectangle (even a complete document) to
Xbe part of a line, provided it is not too large.
X@PP
XLout deals with something a little more complicated than rectangles:
X@I objects.  An object
Xobjec @Index { Object }
Xis a rectangle with at least one @I {column mark}
Xcolumn.mark @Index { Column mark }
Xmark.alignment @Index { Mark alignment }
Xalignment @RawIndex { Alignment @I see mark alignment }
Xprotruding above and below it, and at least one @I {row mark}
Xrow.mark @Index { Row mark }
Xprotruding to the left and right.  The simplest objects contain words like
Xmetempsychosis, and have one mark of each type:
X@ID {
X@ShowMarks metempsychosis
X}
XThe rectangle exactly encloses the word; its column mark is at the left
Xedge, and its row mark passes through the middle of the lower-case
Xletters.  The rectangle and marks do not appear on the printed page, but
Xto understand what Lout is doing you have to imagine them.
X@PP
XTo place two objects side by side, we separate them by the
Xsymbol @Code "|", which denotes the act of @I {horizontal
Xconcatenation}.  So, if we write
X@ID {
X@Code "USA  |  Australia"
X}
Xthe result will be the object
X@ID {
X@ShowMarks USA | @ShowMarks Australia
X}
XNotice that this object has two column marks, but still only one row mark,
Xbecause @Code "|" merges the two row marks
Xtogether.  This merging of row marks fixes the vertical
Xposition of each object with respect to the other, but it does not
Xdetermine how far apart they are.  This distance, or {@I gap},
Xmay be given just after the symbol, as in @Code "|0.5i" for example,
Xwhich specifies horizontal concatenation with a gap of half an inch.  If
Xno gap is given, it is assumed to be {@Code "0i"}.
X@PP
X@I {Vertical concatenation} & , denoted by the symbol {@Code "/"},
Xis the same apart from the change of direction:
X@ID {
X@Code "Australia  /0.1i  USA"
X}
Xhas result
X@ID {
X@ShowMarks Australia /0.1i
X@ShowMarks USA
X}
XThe usual merging of marks occurs, and now the gap determines the
Xvertical separation.  Horizontal and vertical can be combined:
X@ID  @Code {
X             |1m  USA         |1m  "|0.2i" |1m   Australia
X/1vx "/0.1i" |    Washington  |    "|"     |     Canberra
X}
Xhas result
X@ID {
X      @ShowMarks USA &
X      { 0 ymark moveto xsize 10 pt add ymark lineto [ 3 pt ] 0 setdash stroke }
X      @Graphic {1c @Wide }
X      |0.2i @ShowMarks Australia
X/0.1i @ShowMarks Washington  |     @ShowMarks Canberra
X}
Xtables @Index { Tables }
XThere are several things to note carefully here.  White space (including
Xtabs and newlines) adjacent to a concatenation symbol is ignored, so
Xit may be used freely to lay out the expression clearly.  The symbol
X@Code "|" takes precedence over {@Code "/"}, which means that the rows
Xare formed first, then vertically concatenated.  The symbol @Code "/" will
Xmerge two or more column marks, creating multiple
Xcolumns (and @Code "|" will merge two or more row marks).  This
Ximplies that the gap @Code "0.2i" used above is between
Xcolumns, not individual items in columns; a gap in the second row
Xwould therefore be redundant, and so is omitted.
X@PP
XA variant of @Code "/" called @Code "//" left-justifies
Xtwo objects instead of merging their marks.
X@PP
XBy enclosing an object in braces, it is possible to override the
Xbraces @Index { Braces }
Xset precedences.  Here is another expression for the table
Xabove, in which the columns are formed first:
X@ID  @Code {
X             |1m "{ USA"       |1m "/0.1i" |1m "Washington }"
X/1vx "|0.2i" |   "{ Australia" |   "/"     |   "Canberra }"
X}
XBraces have no effect other than to alter the grouping.
X@PP
X@I {Paragraph breaking} occurs when an object is too wide to fit
Xparagraph.breaking @Index { Paragraph breaking }
Xinto the space available to it; by breaking its paragraphs into lines,
Xits width is reduced to an acceptable amount.  The available
Xspace is determined by the @@Wide symbol, whose form is
X@ID  {
X@I length  @@Wide  @I object
X}
Xand whose result is the given object modified to have exactly the given
Xlength.  For example, the expression
X@ID  @Code {
X"5i @Wide {"
X"Macbeth was very ambitious.  This led him to wish to become"
X"king of Scotland.  The witches told him that this wish of"
X"his would come true.  The king of Scotland at this time was"
X"Duncan.  Encouraged by his wife, Macbeth murdered Duncan.  He"
X"was thus enabled to succeed Duncan as king.  (51 words)"
X"|0.5i"
X"Encouraged by his wife, Macbeth achieved his ambition and"
X"realized the prediction of the witches by murdering Duncan"
X"and becoming king of Scotland in his place.  (26 words)"
X"}"
X}
Xhas for its result the following five inch wide object [{@Ref strunk79}]:
X@ID {
X5i @Wide {
XMacbeth was very ambitious.  This led him to wish to become king
Xof Scotland.  The witches told him that this wish of his would
Xcome true.  The king of Scotland at this time was Duncan.  Encouraged
Xby his wife, Macbeth murdered Duncan.  He was thus enabled to succeed
XDuncan as king.  (51 words)
X|0.5i
XEncouraged by his wife, Macbeth achieved his ambition and realized
Xthe prediction of the witches by murdering Duncan and becoming king of
XScotland in his place.  (26 words)
X}
X}
XA paragraph of text can be included anywhere, and it will be broken
Xautomatically if necessary to fit the available space.  The spaces
Xbetween words are converted by Lout into concatenation symbols.
X@PP
XThese are the most significant of Lout's object-building symbols.  There
Xare others, for changing fonts, controlling paragraph breaking, printing
Xgraphical objects like boxes and circles, and so on, but
Xthey do not add anything new in principle.
X@End @Section
END_OF_FILE
  if test 6589 -ne `wc -c <'doc/tr.lout/ch1.01'`; then
    echo shar: \"'doc/tr.lout/ch1.01'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch1.01'
fi
if test -f 'doc/tr.lout/ch2.01' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch2.01'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch2.01'\" \(6408 characters\)
  sed "s/^X//" >'doc/tr.lout/ch2.01' <<'END_OF_FILE'
X@Section
X  @Tag { lexical }
X  @Title { Lexical structure (words, spaces, symbols) and macros }
X@Begin
X@PP
XThe input to Lout consists of a sequence of @I {textual units},
Xtextual.unit @Index {Textual unit }
Xwhich may be
Xeither {@I{white spaces}},
X@I identifiers,
X@I delimiters,
Xor
X@I {literal words}.  Each
Xis a sequence of @I characters chosen from:
Xletter @Index { Letter character }
Xother @Index { Other character }
Xquote @Index { Quote character }
Xescape @Index { Escape character }
Xcomment.char @Index { Comment character }
X@ID @Tab
X    vmargin { 0.5vx }
X    @Fmta { @Col A ! @Col B }
X{
X@Rowa A { letter      } B { @Code "@ab-zAB-Z" }
X@Rowa A { white space } B { @I { space  tab  newline } }
X@Rowa A { quote       } B { @Code "\"" }
X@Rowa A { escape      } B { @Code "\\" }
X@Rowa A { comment     } B { @Code "#" }
X@Rowa A { other       } B { @Code "!$%&'()*+,-./0123456789:;<=>?[]^_`{|}~" }
X}
XNotice that @Code "@" is classed as a letter.  Version 2.05 of Basser
XLout accepts the accented letters of the ISO-LATIN-1 character set
X(depending on how it is installed), and these are also classed as
Xletters.  The ten digits are classed as `other' characters, and in
Xfact the `other' class contains all 8-bit characters (except octal 0)
Xnot assigned to previous classes.
X@PP
XA @I {white space} is a sequence of one or more white space characters.
Xwhite.space @Index { White space }
Xspace.f @Index { Space }
X@PP
XAn @I identifier is a sequence of one or more letters which is the name of a
Xidentifier @Index { Identifier }
Xsymbol.  It is conventional but not essential to begin identifiers with
X{@Code "@"};  Basser Lout will print a warning message if it finds an
Xunquoted literal word (see below) beginning with {@Code "@"}, since such
Xwords are usually misspelt identifiers.  The ten digits are not letters
Xand may not appear in identifiers.  The complete list of predefined
Xidentifiers is
X@ID @Code {
X{     "@Begin"
X  @JL "@Break"
X  @JL "@Case"
X  @JL "@Char"
X  @JL "@Database"
X  @JL "@End"
X  @JL "@Font"
X  @JL "@Galley"
X  @JL "@Graphic"
X  @JL "@HAdjust"
X  @JL "@HContract"
X  @JL "@HExpand"
X  @JL "@High"
X  @JL "@HScale"
X  @JL "@Include"
X} |4.4cx {
X      "@IncludeGraphic"
X  @JL "@Key"
X  @JL "@LClos"
X  @JL "@LEnv"
X  @JL "@LInput"
X  @JL "@LVis"
X  @JL "@Moment"
X  @JL "@Next"
X  @JL "@Null"
X  @JL "@OneCol"
X  @JL "@OneRow"
X  @JL "@Open"
X  @JL "@PAdjust"
X  @JL "@PrependGraphic"
X  @JL "@Rotate"
X} |4.4cx {
X      "@Scale"
X  @JL "@Space"
X  @JL "@SysDatabase"
X  @JL "@SysInclude"
X  @JL "@SysIncludeGraphic"
X  @JL "@SysPrependGraphic"
X  @JL "@Tag"
X  @JL "@Tagged"
X  @JL "@Use"
X  @JL "@VAdjust"
X  @JL "@VContract"
X  @JL "@VExpand"
X  @JL "@VScale"
X  @JL "@Wide"
X  @JL "@Yield"
X}
X}
Xplus the names of the parameters of @@Moment.  The symbols @@LClos, @@LEnv,
Xlclos@Index { @@LClos symbol }
Xlenv @Index { @@LEnv symbol }
Xlinput @Index { @@LInput symbol }
Xlvis @Index { @@LVis symbol }
X@@LInput, and @@LVis appear in cross reference databases generated by Lout
Xand are not for use elsewhere.
X@PP
XA @I delimiter is a sequence of one or more `other' characters which
Xdelimiter @Index { Delimiter }
Xis the name of a symbol.  For example, @Code "{" and @Code "//" are
Xdelimiters.  When defining a delimiter, the name must be enclosed
Xin quotes:
X@ID @Code {
X"def  \"^\"  { {}  ^&  {} }"
X}
Xbut quotes are not used when the delimiter is invoked.  A delimiter may
Xhave delimiters and any other characters adjacent, whereas identifiers
Xmay not be adjacent to letters or other identifiers.  The complete list
Xof predefined delimiters is
X@ID @Code {
X{
X      "/"
X  @JL "//"
X  @JL "^/"
X  @JL "^//"
X} |2.2cx {
X      "|"
X  @JL "||"
X  @JL "^|"
X  @JL "^||"
X} |2.2cx {
X      "&"
X  @JL "^&"
X} |2.2cx {
X      "&&"
X  @JL "{"
X  @JL "}"
X}
X}
XA longer delimiter like @Code "<=" will be recognised in
Xpreference to a shorter one like {@Code "<"}.
X@PP
XA sequence of characters which is neither a white space, an identifier, nor a
Xdelimiter, is by default a @I {literal word}, which means that it will
Xword @Index { Word }
Xliteral.word @Index { Literal word }
Xquoted.word @Index { Quoted word }
Xpass through Lout unchanged.  An arbitrary sequence of characters
Xenclosed in double quotes, for example @Code "\"{  }\"", is also a
Xliteral word.  Space characters may be included, but not tabs or
Xnewlines.  There are special character sequences, used only between
Xquotes, for obtaining otherwise inaccessible characters:
X@ID @Tab
X   vmargin { 0.5vx }
X   @Fmta { @Col A ! @Col B }
X{
X@Rowa A { @Code "\\\""   } B { produces @Code "\"" }
X@Rowa A { @Code "\\\\"   } B { "\\" }
X@Rowa A { @Code "\\ddd"  } B { the character whose ASCII code is }
X@Rowa A {                } B { the up to three digit octal number {@Code ddd} }
X}
XSo, for example, @Code "\"\\\"@PP\\\"\"" produces {@Code "\"@PP\""}.
X@PP
XWhen the comment character
Xcomment @Index { Comment }
X@Code "#" is encountered, everything from
Xthat point to the end of the line is ignored.  This is useful for
Xincluding reminders to oneself, like this:
X@ID @Code {
X"# Lout user manual"
X"# J. Kingston, June 1989"
X}
Xfor temporarily deleting parts of the document, and so on.
X@PP
X@I Macros
Xmacro @Index { Macro }
Xprovide a means of defining symbols which stand for a
Xsequence of textual units rather than an object.  For example, the macro
Xdefinition
X@ID @Code {
X"macro  @PP  {  //1.3vx  2.0f @Wide  &0i }"
X}
Xmakes Lout replace the symbol @Code "@PP" by the given textual units
Xbefore assembling its input into objects.  A similar macro to this
Xone is used to separate the paragraphs of the present document.  The
Xenclosing braces and any spaces adjacent to them are dropped, which can
Xbe a problem:  @Code "@PP2i" has result {@Code "//1.3vx 2.0f @Wide &0i2i"}
Xwhich is erroneous.
X@PP
XThe meaning of symbols used within the body of a macro is determined by
Xwhere the macro is defined, not by where it is used.  Due to implementation
Xproblems, @@Open symbols will not work within macros.  Named and body
Xparameters will work if the symbol that they are parameters of is also
Xpresent.  There is no way to get a left or right brace into the body of
Xa macro without the matching brace.
X@PP
XMacros may be nested within other definitions and exported, but they may
Xnot be parameters.  They may not have parameters or nested definitions
Xof their own, and consequently a preceding @Code export clause (Section
X{@NumberOf visibility}) would be pointless; however, an @Code import
Xclause is permitted.
X@End @Section
END_OF_FILE
  if test 6408 -ne `wc -c <'doc/tr.lout/ch2.01'`; then
    echo shar: \"'doc/tr.lout/ch2.01'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch2.01'
fi
if test -f 'doc/tr.lout/ch2.05' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/tr.lout/ch2.05'\"
else
  echo shar: Extracting \"'doc/tr.lout/ch2.05'\" \(5248 characters\)
  sed "s/^X//" >'doc/tr.lout/ch2.05' <<'END_OF_FILE'
X@Section
X   @Title { The style and size of objects }
X   @Tag { size }
X@Begin
X@PP
XThis section explains how Lout determines the style and size of each
Xobject.  Together, these attributes determine the object's final
Xappearance in the output.
Xstyle @Index { Style of an object }
X@PP
XThe style of an object comprises the following:
X@BulletList
X@ListItem { Which font family, face and size to use (also defining the
X@Code f unit); }
X@ListItem { What gap to replace a single space between two objects by (also
Xdefining the @Code s unit); }
X@ListItem { The kind of paragraph breaking to employ ({@Code adjust},
X{@Code ragged}, etc.) }
X@ListItem { What gap to insert between the lines of paragraphs
X(also defining the @Code v unit); }
X@ListItem { Whether to permit hyphenation or not. }
X@EndList
XThe style of an object depends on where it appears in the final
Xdocument.  For example, the style of a parameter depends on where it is
Xused; the style of a galley is the style of the first target that it
Xattempts to attach itself to.  Of course, the style of any object can be
Xchanged by using the @@Font, @@Space, and @@Break symbols.
X@PP
XThere are no standard default values for style.  Instead one must ensure
Xthat the root galley or each of its components is enclosed in @@Font
Xand @@Break symbols.  From there the style is passed to incoming galleys
Xand the objects within them.
X@PP
Xwidth. @Index { Width of an object }
Xheight. @Index { Height of an object }
Xsize. @Index { Size of an object }
XThe remainder of this section explains how the size of each object (its
Xwidth and height on the printed page) is determined.  We will treat width
Xonly, since height is determined in exactly the same way, except that the
Xcomplications introduced by paragraph breaking are absent.
X@PP
XWith three exceptions (see below), the width of an object is as large as
Xit possibly could be without violating a @@Wide symbol or intruding into
Xthe space occupied by neighbouring gaps or objects.  As an aid to
Xinvestigating this rule, we will use the definition
X@ID @Code {
X"def @Box right x"
X"{"
X"  \"0 0 moveto xsize 0 lineto xsize ysize lineto 0 ysize lineto closepath stroke\""
X"  @Graphic x"
X"}"
X}
Xwhich draws a box around the boundary of its right parameter (Section
X{@NumberOf graphic}).  The result of
X@ID @Code {
X"5c @Wide @Box metempsychosis"
X}
Xis
X@ID {
X5c @Wide @Box metempsychosis
X}
XThe widest that @Code "@Box metempsychosis" could possibly be is five
Xcentimetres, and accordingly that is its width.  The same applies to
X{@Code metempsychosis}, which is five centimetres wide as well.  Note
Xcarefully that there is no object in this example whose width is equal
Xto the sum of the widths of the letters of {@Code metempsychosis}.
X@PP
XThe first of the three exceptions to the `as wide as possible' rule is the
X@@HContract symbol, which causes the width of its right parameter to be
Xreduced to a reasonable minimum (a formal definition will not be attempted):
X@ID @Code {
X"5c @Wide @HContract @Box metempsychosis"
X}
Xproduces
X@ID {
X5c @Wide @HContract @Box metempsychosis
X}
XThe object @Code "@HContract @Box metempsychosis" is still five centimetres
Xwide, but the object @Code "@Box metempsychosis" has been reduced.
X@PP
XThe second of the three exceptions is the horizontal concatenation symbol
X@Code "|" (and also {@Code "&"}).  Consider this example:
X@ID @Code {
X"5c @Wide @Box { A  |1c  B  |1c  C }"
X}
XAs usual, the right parameter of @@Wide is five centimetres wide, and
Xthe result looks like this:
X@ID {
X5c @Wide @Box { A  |1c  B  |1c  C }
X}
XLout has to apportion the size minus inter-column gaps among the three
Xcolumns.
X@PP
XIf the columns are wide enough to require paragraph breaking, Lout will
Xassign sizes to the columns in such a way as to leave narrow columns
Xunbroken and break wider columns to equal width, occupying the full
Xsize.  Otherwise, paragraph breaking is not required, and each column
Xwill be assigned a reasonable minimum size in the manner of @@HContract,
Xexcept that the last column receives all the leftover width.  For example,
X@ID @Code {
X"5c @Wide { @Box A  |1c  @Box B  |1c  @Box C }"
X}
Xhas result
X@ID {
X5c @Wide { @Box A  |1c  @Box B  |1c  @Box C }
X}
XIf it is desired that the leftover width remain unused, rather than
Xgoing into the last column, an empty column can be appended, or the last
Xcolumn can be enclosed in @@HContract.  Two other ways to apportion the
Xleftover width are provided by the @@HExpand and @@HAdjust symbols
X(Sections {@NumberOf hexpand} and {@NumberOf hadjust}).
X@PP
XThe third and final exception to the `as wide as possible' rule concerns
Xthe components of the root galley.  Each is considered to be enclosed
Xroot.galley.size @SubIndex { size of components of }
Xin @@HContract and @@VContract symbols.
X@PP
XUp to this point we have treated width as a single quantity, but of
Xcourse it has two parts:  width to left and right of the mark.  The
X`as wide as possible' rule applies to both directions:
X@ID @Code {
X"@HContract { @Box 953^.05 /0.5c @Box 2^.8286 }"
X}
Xhas result
X@ID {
X@HContract { @Box 953^.05 /0.5c @Box 2^.8286 }
X}
XLeftover width usually goes to the right, as we have seen, but here some
Xwidth was available only to the left of {@Code "2.8286"} owing to the
Xcolumn mark alignment.
X@End @Section
END_OF_FILE
  if test 5248 -ne `wc -c <'doc/tr.lout/ch2.05'`; then
    echo shar: \"'doc/tr.lout/ch2.05'\" unpacked with wrong size!
  fi
  # end of 'doc/tr.lout/ch2.05'
fi
if test -f 'include/tab_prepend' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'include/tab_prepend'\"
else
  echo shar: Extracting \"'include/tab_prepend'\" \(2912 characters\)
  sed "s/^X//" >'include/tab_prepend' <<'END_OF_FILE'
X%%BeginResource: procset LoutTabPrependGraphic
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X%                                                  %
X%  PostScript @SysPrependGraphic file for @Tab     %
X%                                                  %
X%  To assist in avoiding name clashes, the names   %
X%  of all these symbols begin with "ltab".         %
X%                                                  %
X%  Jeffrey H. Kingston                             %
X%  24 September 1991                               %
X%  22 December 1992                                %
X%                                                  %
X%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
X
X% linewidth ltabhs -
X% horizontal single line
X/ltabhs
X{  0 0 moveto xsize 0 lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhsp -
X% horizontal single line with projecting ends
X/ltabhsp
X{  0 0 moveto xsize 0 lineto
X   setlinewidth 2 setlinecap stroke
X} def
X
X% linewidth ltabhd -
X% horizontal double line
X/ltabhd
X{  dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch 3 mul moveto xsize exch 3 mul lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhdb -
X% horizontal double line below mark
X/ltabhdb
X{  dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch -3 mul moveto xsize exch -3 mul lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabhdnw -
X% horizontal double line with northwest corner
X/ltabhdnw
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   xsize exch 3 mul moveto
X   -3 mul exch 3 mul lineto
X   -3 mul 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdne -
X% horizontal double line with northeast corner
X/ltabhdne
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch 3 mul moveto
X   3 mul xsize add exch 3 mul lineto
X   3 mul xsize add 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdsw -
X% horizontal double line with southwest corner
X/ltabhdsw
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   xsize exch -3 mul moveto
X   -3 mul exch -3 mul lineto
X   -3 mul 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabhdse -
X% horizontal double line with southeast corner
X/ltabhdse
X{  dup dup dup dup
X   0 0 moveto xsize 0 lineto
X   0 exch -3 mul moveto
X   3 mul xsize add exch -3 mul lineto
X   3 mul xsize add 0 lineto
X   setlinewidth 0 setlinejoin 2 setlinecap stroke
X} def
X
X% linewidth ltabvs -
X% vertical single line
X/ltabvs
X{  0 0 moveto 0 ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabvd -
X% vertical double line
X/ltabvd
X{  dup dup
X   0 0 moveto 0 ysize lineto
X   -3 mul 0 moveto -3 mul ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X
X% linewidth ltabvdr -
X% vertical double line to right of mark
X/ltabvdr
X{  dup dup
X   0 0 moveto 0 ysize lineto
X   3 mul 0 moveto 3 mul ysize lineto
X   setlinewidth 0 setlinecap stroke
X} def
X%%EndResource
END_OF_FILE
  if test 2912 -ne `wc -c <'include/tab_prepend'`; then
    echo shar: \"'include/tab_prepend'\" unpacked with wrong size!
  fi
  # end of 'include/tab_prepend'
fi
if test -f 'z28.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z28.c'\"
else
  echo shar: Extracting \"'z28.c'\" \(8109 characters\)
  sed "s/^X//" >'z28.c' <<'END_OF_FILE'
X/*@z28.c:Error Service:ErrorInit(), ErrorSeen()@******************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z28.c                                                      */
X/*  MODULE:       Error Service                                              */
X/*  EXTERNS:      ErrorInit(), Error(), ErrorSeen()                          */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X#define	MAX_BLOCKS	 20		/* max number of error blocks        */
X#define	MAX_ERRORS	 20		/* max number of held error messages */
X
Xstatic BOOLEAN	print_block[MAX_BLOCKS];	/* TRUE if print this block  */
Xstatic int	start_block[MAX_BLOCKS];	/* first message of block    */
Xstatic char	message[MAX_ERRORS][MAX_LINE];	/* the error messages    */
Xstatic FILE	*fp = NULL;			/* file pointer of log file  */
Xstatic BOOLEAN	error_seen = FALSE;		/* TRUE after first error    */
Xstatic int	block_top = 0;			/* first free error block    */
Xstatic int	mess_top = 0;			/* first free error message  */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  ErrorInit(str)                                                           */
X/*                                                                           */
X/*  Open log file str and initialise this module.                            */
X/*                                                                           */
X/*****************************************************************************/
X
XErrorInit(str)
XFULL_CHAR *str;
X{ if( fp != NULL )
X    Error(FATAL, no_fpos, "-e argument appears twice in command line");
X  fp = StringFOpen(str, "w");
X  if( fp == NULL )
X    Error(FATAL, no_fpos, "cannot open error file \"%s\"", str);
X} /* end ErrorInit */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  BOOLEAN ErrorSeen()                                                      */
X/*                                                                           */
X/*  TRUE once an error has been found.                                       */
X/*                                                                           */
X/*****************************************************************************/
X
XBOOLEAN ErrorSeen()
X{ return error_seen;
X} /* end ErrorSeen */
X
X
X/*@::EnterErrorBlock(), LeaveErrorBlock()@************************************/
X/*                                                                           */
X/*  EnterErrorBlock(ok_to_print)                                             */
X/*                                                                           */
X/*  Start off a new block of error messages.  If ok_to_print, they do not    */
X/*  need to be held for a later commit.                                      */
X/*                                                                           */
X/*****************************************************************************/
X
XEnterErrorBlock(ok_to_print)
XBOOLEAN ok_to_print;
X{ if( block_top < MAX_BLOCKS )
X  { print_block[block_top] = ok_to_print;
X    start_block[block_top] = mess_top;
X    block_top++;
X  }
X  else Error(FATAL, no_fpos, "too many levels of error messages");
X} /* end EnterErrorBlock */
X
X
X/*****************************************************************************/
X/*                                                                           */
X/*  LeaveErrorBlock(commit)                                                  */
X/*                                                                           */
X/*  Finish off a block or error messages.  If commit is true, print them,    */
X/*  otherwise discard them.                                                  */
X/*                                                                           */
X/*****************************************************************************/
X
XLeaveErrorBlock(commit)
XBOOLEAN commit;
X{ int i;
X  assert( block_top > 0, "LeaveErrorBlock: no matching EnterErrorBlock!" );
X  assert( commit || !print_block[block_top - 1], "LeaveErrorBlock: commit!" );
X  if( fp == NULL )  fp = stderr;
X  if( commit )
X  { for( i = start_block[block_top - 1];  i < mess_top;  i++ )
X      fputs(message[i], fp);
X  }
X  block_top--;
X  mess_top = start_block[block_top];
X} /* end LeaveErrorBlock */
X
X
X/*@::Error()@*****************************************************************/
X/*                                                                           */
X/*  Error(etype, pos, str, p1, p2, p3, p4, p5, p6)                           */
X/*                                                                           */
X/*  Report error of type etype at position *pos in input.                    */
X/*  The error message is str with parameters p1 - p6.                        */
X/*                                                                           */
X/*****************************************************************************/
X
X/*VARARGS3*/
XError(etype, pos, str, p1, p2, p3, p4, p5, p6)
Xint etype;  FILE_POS *pos;  char *str, *p1, *p2, *p3, *p4, *p5, *p6;
X{ char val[MAX_LINE];
X  sprintf(val, str, p1, p2, p3, p4, p5, p6);
X  if( fp == NULL )  fp = stderr;
X  switch( etype )
X  {
X
X    case INTERN:
X    
X      while( block_top > 0 )  LeaveErrorBlock(TRUE);
X      fprintf(fp, "lout%s internal error: %s\n", EchoFilePos(pos), val);
X#if DEBUG_ON
X      abort();
X#else
X      exit(1);
X#endif
X      break;
X
X
X    case FATAL:
X    
X      while( block_top > 0 )  LeaveErrorBlock(TRUE);
X      fprintf(fp, "lout%s fatal error: %s\n", EchoFilePos(pos), val);
X      exit(1);
X      break;
X
X
X    case WARN:
X    
X      if( block_top == 0 || print_block[block_top - 1] )
X	fprintf(fp, "lout%s: %s\n", EchoFilePos(pos), val);
X      else if( mess_top < MAX_ERRORS )
X	sprintf(message[mess_top++], "lout%s: %s\n", EchoFilePos(pos), val);
X      else Error(FATAL, pos, "too many error messages");
X      error_seen = TRUE;
X      break;
X
X
X    default:
X    
X      Error(INTERN, no_fpos, "invalid error type");
X      exit(1);
X      break;
X
X  }
X} /* end Error */
END_OF_FILE
  if test 8109 -ne `wc -c <'z28.c'`; then
    echo shar: \"'z28.c'\" unpacked with wrong size!
  fi
  # end of 'z28.c'
fi
if test -f 'z32.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'z32.c'\"
else
  echo shar: Extracting \"'z32.c'\" \(5104 characters\)
  sed "s/^X//" >'z32.c' <<'END_OF_FILE'
X/*@z32.c:Counter Service:Next()@**********************************************/
X/*                                                                           */
X/*  LOUT: A HIGH-LEVEL LANGUAGE FOR DOCUMENT FORMATTING (VERSION 2.05)       */
X/*  COPYRIGHT (C) 1993 Jeffrey H. Kingston                                   */
X/*                                                                           */
X/*  Jeffrey H. Kingston (jeff@cs.su.oz.au)                                   */
X/*  Basser Department of Computer Science                                    */
X/*  The University of Sydney 2006                                            */
X/*  AUSTRALIA                                                                */
X/*                                                                           */
X/*  This program is free software; you can redistribute it and/or modify     */
X/*  it under the terms of the GNU General Public License as published by     */
X/*  the Free Software Foundation; either version 1, or (at your option)      */
X/*  any later version.                                                       */
X/*                                                                           */
X/*  This program is distributed in the hope that it will be useful,          */
X/*  but WITHOUT ANY WARRANTY; without even the implied warranty of           */
X/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            */
X/*  GNU General Public License for more details.                             */
X/*                                                                           */
X/*  You should have received a copy of the GNU General Public License        */
X/*  along with this program; if not, write to the Free Software              */
X/*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                */
X/*                                                                           */
X/*  FILE:         z32.c                                                      */
X/*  MODULE:       Counter Service                                            */
X/*  EXTERNS:      Next()                                                     */
X/*                                                                           */
X/*****************************************************************************/
X#include "externs"
X
X/*****************************************************************************/
X/*                                                                           */
X/*  OBJECT Next(x, inc, done)                                                */
X/*                                                                           */
X/*  Return x with its value incremented by inc (if possible).                */
X/*  Set *done to TRUE if successful, leave *done unchanged otherwise.        */
X/*                                                                           */
X/*****************************************************************************/
X
XOBJECT Next(x, inc, done)
XOBJECT x; int inc; BOOLEAN *done;
X{ OBJECT y, link;  int l, r, n, len;
X  FULL_CHAR buff[MAX_LINE + 1];
X  debug3(DCS, DD, "Next( %s, %d, %s )", EchoObject(x), inc, bool(*done));
X  switch( type(x) )
X  {
X    case WORD:
X    case QWORD:
X    
X      len = StringLength(string(x));
X      for( r = len - 1;  r >= 0 && !decimaldigit(string(x)[r]);  r--);
X      if( r < 0 ) break;
X      for( l = r-1;  l >= 0 && decimaldigit(string(x)[l]);  l-- );
X      sscanf( (char *) &string(x)[l+1], "%d", &n);
X      string(x)[l+1] = '\0';
X      StringCopy(buff, string(x));
X      StringCat(buff, StringInt(n+inc));
X      StringCat(buff, &string(x)[r+1]);
X      if( StringLength(buff) >= MAX_LINE )
X	Error(FATAL, &fpos(x), "word %s is too long", buff);
X      y = MakeWord(type(x), buff, &fpos(x));
X      word_font(y) = word_font(x);
X      MergeNode(y, x);  x = y;
X      *done = TRUE;
X      break;
X
X
X    case INCGRAPHIC:
X    case SINCGRAPHIC:
X    case GAP_OBJ:
X    case CLOSURE:
X    case NULL_CLOS:
X    case CROSS:
X    
X      break;
X
X
X    case ONE_COL:
X    case ONE_ROW:
X    case WIDE:
X    case HIGH:
X    case HCONTRACT:
X    case VCONTRACT:
X    case HEXPAND:
X    case VEXPAND:
X    case PADJUST:
X    case HADJUST:
X    case VADJUST:
X    case HSCALE:
X    case VSCALE:
X    case ROTATE:
X    case SCALE:
X    case SPLIT:
X    case GRAPHIC:
X    
X      Child(y, LastDown(x));
X      y = Next(y, inc, done);
X      break;
X
X
X    case ACAT:
X    
X      link = LastDown(x);
X      while( link != x && !*done )
X      {	Child(y, link);
X	if( is_index(type(y)) )  continue;
X	y = Next(y, inc, done);
X	if( !*done )  link = PrevDown(link);
X      }
X      break;
X
X
X    case COL_THR:
X    case ROW_THR:
X    case HCAT:
X    case VCAT:
X    
X      link = LastDown(x);
X      while( link != x && !*done )
X      {	Child(y, link);
X	if( is_index(type(y)) )  continue;
X	y = Next(y, inc, done);
X	if( !*done )  link = PrevDown(link);
X      }
X      break;
X
X
X    default:
X    
X      Error(INTERN,&fpos(x), "Next: type(x) = %s", Image(type(x)));
X      break;
X
X  } /* end switch */
X  debug1(DCS, DD, "Next returning %s", EchoObject(x));
X  return x;
X} /* end Next */
END_OF_FILE
  if test 5104 -ne `wc -c <'z32.c'`; then
    echo shar: \"'z32.c'\" unpacked with wrong size!
  fi
  # end of 'z32.c'
fi
echo shar: End of archive 30 \(of 35\).
cp /dev/null ark30isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 35 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
