Newsgroups: comp.sources.misc
From: jfh@rpp386.cactus.org (John F. Haugh II)
Subject: v38i124:  shadow - Shadow Password Suite, v3.3, Part05/14
Message-ID: <1993Aug14.192420.9351@sparky.sterling.com>
X-Md4-Signature: 44a2f7469f44fb6b498e0d056f038ee8
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sat, 14 Aug 1993 19:24:20 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jfh@rpp386.cactus.org (John F. Haugh II)
Posting-number: Volume 38, Issue 124
Archive-name: shadow/part05
Environment: UNIX
Supersedes: shadow: Volume 26, Issue 54-64

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile.sun4 chsh.c login.5 newusers.c
# Wrapped by kent@sparky on Sat Aug 14 14:11:39 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 14)."'
if test -f 'Makefile.sun4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sun4'\"
else
  echo shar: Extracting \"'Makefile.sun4'\" \(18789 characters\)
  sed "s/^X//" >'Makefile.sun4' <<'END_OF_FILE'
X#
X# Copyright 1988,1989,1990,1991,1992,1993 John F. Haugh II
X# All rights reserved.
X#
X# Permission is granted to copy and create derivative works for any
X# non-commercial purpose, provided this copyright notice is preserved
X# in all copies of source code, or included in human readable form
X# and conspicuously displayed on all copies of object code or
X# distribution media.
X#
X# This software is provided on an AS-IS basis and the author makes
X# no warrantee of any kind.
X#
X#	@(#)Makefile.sun4	3.11	08:11:03  - Shadow password system (SunOS 4.1.1 version)
X#
X#	@(#)Makefile.sun4	3.11	08:11:03	19 Jul 1993
X#
XSHELL = /bin/sh
X
X#
X# Set this flag to decide what level of code "get" returns.
X# The base USENET release was release 1.  It is no longer supported.
X# The version with the utilities added was release 2.
X# The version with database-like file access is release 3.
XRELEASE = 3
XGFLAGS = -t -r$(RELEASE)
X
X# SunOS 4.1.1 uses /usr/bin
XLOGINDIR = /usr/bin
X
X# SunOS 4.1.1 requires no extra libraries
XNDIR = 
X
X# Define some stuff for Cracklib.  This assumes that libcracklib.a is
X# in a system directory.
X# CRACKDEF='-DCRACKLIB_DICTPATH="$(DICTPATH)"'
X# CRACKLIB=-lcrack
X
X# Pick your favorite C compiler and tags command
XCC = /bin/cc
XTAGS = ctags
X
X# SunOS 4.1.1 is SUN4
XOS = -DSUN4
X
X# SunOS 4.1.1 uses ranlib
XRANLIB = ranlib
X
X# Configuration Flags
X#
X#	DEST_INCLUDE_DIR - local include files
X#	LIBS - system libraries
X#		-lsocket - needed for TCP/IP and possibly SYSLOG
X#		-ldbm or -lndbm - needed for DBM support
X#		-lcrypt - needed for SCO crypt() functions
X#	CFLAGS - C compiler flags
X#		-DLAI_TCP - needed for SCO Xenix Lachman TCP/IP
X
XDEST_INCLUDE_DIR = /usr/include
X
X# Flags for SunOS 4.1.1
XCFLAGS = -O2 $(OS) $(DEST_INCLUDE_DIR) $(CRACKDEF)
XLIBS =
XLDFLAGS = 
X
X# Library for SunOS 4.1.1
XLIBSEC = libsec.a
X
X# Names for root user and group, and bin user and group.  See your
X# /etc/passwd and /etc/group files.  This is for SunOS 4.1.1
XRUID = root
XRGID = wheel
XBUID = bin
XBGID = bin
X
X# Where the login.defs file will be copied.  Must agree with config.h
XDEST_LOGIN_DEFS = /etc/login.defs
X
X# Rules for .L (lint) files.
X.SUFFIXES: .L
XLINT = lint
XLINTFLAGS = $(OS) -Dlint
X
X.c.L:
X	$(LINT) -pxu $(LINTFLAGS) $*.c > $*.L
X
XLOBJS = lmain.o login.o env.o valid.o setup.o shell.o age.o \
X	utmp.o sub.o mail.o motd.o log.o ttytype.o failure.o \
X	tz.o console.o hushed.o
X
XLSRCS = lmain.c login.c env.c valid.c setup.c shell.c age.c \
X	utmp.c sub.c mail.c motd.c log.c ttytype.c failure.c \
X	tz.c console.c hushed.c
X
XSOBJS = smain.o env.o entry.o susetup.o shell.o \
X	sub.o mail.o motd.o sulog.o age.o tz.o hushed.o
X
XSSRCS = smain.c env.c entry.c setup.c shell.c \
X	pwent.c sub.c mail.c motd.c sulog.c shadow.c age.c pwpack.c rad64.c \
X	tz.c hushed.c
X
XPOBJS = passwd.o obscure.o
XPSRCS = passwd.c obscure.c
X
XGPSRCS = gpmain.c
X
XGPOBJS = gpmain.o
X
XPWOBJS = pwconv.o
X
XPWSRCS = pwconv.c pwent.c shadow.c pwpack.c rad64.c
X
XPWUNOBJS = pwunconv.o
X
XPWUNSRCS = pwunconv.c pwent.c shadow.c pwpack.c rad64.c
X
XSULOGOBJS = sulogin.o entry.o env.o age.o setup.o \
X	valid.o shell.o tz.o
X
XSULOGSRCS = sulogin.c entry.c env.c age.c pwent.c setup.c \
X	shadow.c shell.c valid.c pwpack.c tz.c
X
XMKPWDOBJS = mkpasswd.o
X
XMKPWDSRCS = mkpasswd.c
X
XNGSRCS = newgrp.c env.c shell.c
X
XNGOBJS = newgrp.o env.o shell.o
X
XCHFNSRCS = chfn.c fields.c
XCHFNOBJS = chfn.o fields.o
XCHSHSRCS = chsh.c fields.c
XCHSHOBJS = chsh.o fields.o
XCHAGEOBJS = chage.o fields.o
XCHAGESRCS = chage.c fields.c
XCHPASSOBJS = chpasswd.o
XCHPASSSRCS = chpasswd.c
XDPSRCS = dpmain.c
XDPOBJS = dpmain.o
X
XALLSRCS = age.c dialchk.c dialup.c entry.c env.c lmain.c log.c login.c mail.c \
X	motd.c obscure.c passwd.c pwconv.c pwent.c pwunconv.c getpass.c \
X	setup.c shadow.c shell.c smain.c sub.c sulog.c sulogin.c ttytype.c \
X	utmp.c valid.c port.c newgrp.c gpmain.c grent.c mkpasswd.c pwpack.c \
X	chfn.c chsh.c chage.c rad64.c encrypt.c chpasswd.c shadowio.c pwio.c \
X	newusers.c groupio.c fields.c pwdbm.c grpack.c grdbm.c sppack.c \
X	spdbm.c dpmain.c gshadow.c gsdbm.c gspack.c sgroupio.c useradd.c \
X	userdel.c patchlevel.h usermod.c copydir.c mkrmdir.c groupadd.c \
X	groupdel.c groupmod.c tz.c console.c hushed.c getdef.c scologin.c \
X	logoutd.c groups.c pwauth.c lockpw.c chowndir.c
X
XFILES1 = README patchlevel.h newgrp.c Makefile config.h pwunconv.c obscure.c \
X	age.c id.c
X
XFILES2 = passwd.c port.c lmain.c sulogin.c pwpack.c dialup.c
X
XFILES3 = chfn.c chsh.c smain.c faillog.c pwconv.c shadow.c pwck.c
X
XFILES4 = gpmain.c chage.c pwent.c valid.c setup.c entry.c ttytype.c port.h
X
XFILES5 = pwio.c encrypt.c chpasswd.c newusers.c rad64.c dialchk.c faillog.h \
X	pwdbm.c grdbm.c gshadow.c sppack.c grpck.c
X
XFILES6 = gspack.c spdbm.c lastlog.h shell.c login.c sub.c dpmain.c mail.c \
X	env.c pwd.h.m4 grpack.c shadow.h log.c grent.c motd.c dialup.h \
X	fields.c gsdbm.c utmp.c failure.c
X
XFILES7 = groupio.c shadowio.c sgroupio.c groups.c copydir.c mkrmdir.c \
X	mkpasswd.c pwauth.c pwauth.h lastlog.c
X
XFILES8 = useradd.c usermod.c login.defs
X
XFILES9 = groupadd.c groupdel.c groupmod.c tz.c console.c hushed.c getdef.c \
X	scologin.c logoutd.c sulog.c getpass.c userdel.c lockpw.c chowndir.c
X
XFILES_SUN4 = Makefile.sun4 README.sun4 config.h.sun4
XFILES_SVR4 = Makefile.svr4 config.h.svr4
X
XMAN_1 = chage.1 chfn.1 chsh.1 id.1 login.1 newgrp.1 passwd.1 su.1 \
X	useradd.1 userdel.1 usermod.1 groupadd.1 groupdel.1 groupmod.1 \
X	groups.1 pwck.1 grpck.1
XMAN_3 = shadow.3 pwauth.3
XMAN_4 = faillog.4 passwd.4 porttime.4 shadow.4
XMAN_5 = login.5
XMAN_8 = chpasswd.8 dpasswd.8 faillog.8 newusers.8 pwconv.8 pwunconv.8 \
X	sulogin.8 mkpasswd.8 logoutd.8 pwauth.8 lastlog.8
X
XDOCS1 = $(MAN_1) $(MAN_3) $(MAN_4)
XDOCS2 = $(MAN_5) $(MAN_8)
XDOCS = $(DOCS1) $(DOCS2)
X
XBINS = su login pwconv pwunconv passwd sulogin faillog newgrp gpasswd \
X	mkpasswd chfn chsh chage chpasswd newusers dpasswd id useradd \
X	userdel usermod groupadd groupdel groupmod logoutd groups \
X	pwck grpck lastlog
X
Xall:	$(BINS) $(DOCS)
X
X.PRECIOUS: libshadow.a
X
Xlibshadow.a: \
X	libshadow.a(dialchk.o) \
X	libshadow.a(dialup.o) \
X	libshadow.a(encrypt.o) \
X	libshadow.a(getdef.o) \
X	libshadow.a(getpass.o) \
X	libshadow.a(grdbm.o) \
X	libshadow.a(grent.o) \
X	libshadow.a(groupio.o) \
X	libshadow.a(grpack.o) \
X	libshadow.a(gshadow.o) \
X	libshadow.a(gsdbm.o) \
X	libshadow.a(gspack.o) \
X	libshadow.a(sgroupio.o) \
X	libshadow.a(port.o) \
X	libshadow.a(pwdbm.o) \
X	libshadow.a(pwent.o) \
X	libshadow.a(pwio.o) \
X	libshadow.a(pwpack.o) \
X	libshadow.a(pwauth.o) \
X	libshadow.a(rad64.o) \
X	libshadow.a(spdbm.o) \
X	libshadow.a(shadow.o) \
X	libshadow.a(shadowio.o) \
X	libshadow.a(sppack.o) \
X	libshadow.a(lockpw.o)
X	$(RANLIB) libshadow.a
X
Xlibsec: $(LIBSEC)(shadow.o)
X	$(RANLIB) $(LIBSEC)
X
Xsave:
X	[ ! -d save ] && mkdir save
X	-cp $(LOGINDIR)/login save
X	-cp /etc/mkpasswd /etc/pwconv /etc/pwunconv /etc/sulogin /etc/chpasswd \
X		/etc/newusers /etc/useradd /etc/userdel /etc/usermod \
X		/etc/groupadd /etc/groupdel /etc/groupmod /etc/logoutd \
X		/etc/login.defs /etc/pwck /etc/grpck save
X	-cp /bin/su /bin/passwd /bin/gpasswd /bin/dpasswd /bin/faillog \
X		/bin/newgrp /bin/chfn /bin/chsh /bin/chage /bin/id \
X		/bin/scologin save
X	-cp $(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/shadow.h \
X		$(DEST_INCLUDE_DIR)/pwd.h save
X
Xrestore:
X	[ -d save ]
X	-(cd save ; cp login $(LOGINDIR) )
X	-(cd save ; -cp mkpasswd pwconv pwunconv sulogin chpasswd \
X		newusers useradd userdel usermod groupadd groupdel groupmod \
X		logoutd login.defs pwck grpck /etc)
X	-(cd save ; cp su passwd gpasswd dpasswd faillog newgrp chfn chsh \
X		chage id scologin /bin)
X	-(cd save ; cp dialup.h shadow.h pwd.h $(DEST_INCLUDE_DIR) )
X
Xinstall: all
X	strip $(BINS)
X	cp login $(LOGINDIR)/login
X	cp mkpasswd /etc 
X	cp pwconv /etc 
X	cp pwunconv /etc 
X	cp sulogin /etc 
X	cp chpasswd /etc 
X	cp newusers /etc 
X	cp useradd /etc 
X	cp userdel /etc 
X	cp usermod /etc 
X	cp groupadd /etc 
X	cp groupdel /etc 
X	cp groupmod /etc 
X	cp logoutd /etc
X	cp pwck /etc
X	cp grpck /etc
X	cp su /bin
X	cp passwd /bin
X	cp gpasswd /bin
X	cp dpasswd /bin
X	cp faillog /bin
X	cp newgrp /bin
X	cp chfn /bin
X	cp chsh /bin
X	cp chage /bin
X	cp id /bin
X	cp dialup.h shadow.h pwd.h $(DEST_INCLUDE_DIR)
X	chown $(RUID) $(LOGINDIR)/login /etc/pwconv /etc/pwunconv /etc/sulogin \
X		/bin/su /bin/passwd /bin/gpasswd /bin/newgrp /etc/mkpasswd \
X		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
X		/etc/userdel /etc/usermod /etc/groupadd /etc/groupdel \
X		/etc/groupmod /etc/logoutd /etc/pwck /etc/grpck
X	chgrp $(RGID) $(LOGINDIR)/login /etc/pwconv /etc/pwunconv /etc/sulogin \
X		/bin/su /bin/passwd /bin/gpasswd /bin/newgrp /etc/mkpasswd \
X		/bin/dpasswd /bin/chsh /bin/chfn /bin/chage /etc/useradd \
X		/etc/userdel /etc/usermod /etc/groupadd /etc/groupdel \
X		/etc/groupmod /etc/logoutd /etc/pwck /etc/grpck
X	chown $(BUID) /bin/faillog /bin/id $(DEST_INCLUDE_DIR)/shadow.h \
X		$(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/pwd.h
X	chgrp $(BGID) /bin/faillog /bin/id $(DEST_INCLUDE_DIR)/shadow.h \
X		$(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/pwd.h
X	chmod 700 /etc/pwconv /etc/pwunconv /etc/sulogin /etc/mkpasswd \
X		/etc/chpasswd /etc/newusers /bin/dpasswd /bin/chage \
X		/etc/useradd /etc/userdel /etc/usermod /etc/groupadd \
X		/etc/groupdel /etc/groupmod /etc/logoutd /etc/pwck \
X		/etc/grpck
X	chmod 4711 $(LOGINDIR)/login /bin/su /bin/passwd /bin/gpasswd \
X		/bin/newgrp /bin/chfn /bin/chsh
X	chmod 711 /bin/faillog /bin/id
X	chmod 444 $(DEST_INCLUDE_DIR)/shadow.h $(DEST_INCLUDE_DIR)/dialup.h \
X		$(DEST_INCLUDE_DIR)/pwd.h
X	[ -f $(DEST_LOGIN_DEFS) ] || (cp login.defs $(DEST_LOGIN_DEFS) ; \
X		chown $(RUID) $(DEST_LOGIN_DEFS) ; \
X		chgrp $(RGID) $(DEST_LOGIN_DEFS) ; \
X		chmod 600 $(DEST_LOGIN_DEFS) )
X
Xlint:	su.lint login.lint pwconv.lint pwunconv.lint passwd.lint sulogin.lint \
X	faillog.lint newgrp.lint gpasswd.lint mkpasswd.lint chfn.lint \
X	chsh.lint chage.lint dpasswd.lint id.lint useradd.lint userdel.lint \
X	usermod.lint groupadd.lint groupdel.lint groupmod.lint logoutd.lint \
X	pwck.lint grpck.lint \
X	$(ALLSRCS:.c=.L)
X
Xtags:	$(ALLSRCS)
X	$(TAGS) $(ALLSRCS)
X
XREADME:
X	[ -f s.README ] && get -t -r$(RELEASE) s.README
X	
X$(DOCS):
X	[ -f s.$@ ] && get -t -r$(RELEASE) s.$@
X
Xlogin.defs:
X	[ -f s.login.defs ] && get -t -r$(RELEASE) s.login.defs
X
XMakefile.sun4:
X	[ -f s.Makefile.sun4 ] && get -t -r$(RELEASE) s.Makefile.sun4
X
XREADME.sun4:
X	[ -f s.README.sun4 ] && get -t -r$(RELEASE) s.README.sun4
X
Xconfig.h.sun4:
X	[ -f s.config.h.sun4 ] && get -t -r$(RELEASE) s.config.h.sun4
X
Xlogin:	$(LOBJS) libshadow.a
X	$(CC) -o login $(LDFLAGS) $(LOBJS) libshadow.a $(LIBS)
X
Xlogin.lint: $(LSRCS)
X	$(LINT) $(LINTFLAGS) $(LSRCS) > login.lint
X
Xsu:	$(SOBJS) libshadow.a
X	$(CC) -o su $(LDFLAGS) $(SOBJS) libshadow.a $(LIBS)
X
Xsu.lint:	$(SSRCS)
X	$(LINT) $(LINTFLAGS) -DSU $(SSRCS) > su.lint
X
Xpasswd:	$(POBJS) libshadow.a
X	$(CC) -o passwd $(LDFLAGS) $(POBJS) libshadow.a $(LIBS) $(CRACKLIB)
X
Xpasswd.lint: $(PSRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PSRCS) > passwd.lint
X
Xgpasswd: $(GPOBJS) libshadow.a
X	$(CC) -o gpasswd $(LDFLAGS) $(GPOBJS) libshadow.a $(LIBS)
X
Xgpasswd.lint: $(GPSRCS)
X	$(LINT) $(LINTFLAGS) $(GPSRCS) > gpasswd.lint
X
Xdpasswd: $(DPOBJS) libshadow.a
X	$(CC) -o dpasswd $(LDFLAGS) $(DPOBJS) libshadow.a $(LIBS)
X
Xdpasswd.lint: $(DPSRCS)
X	$(LINT) $(LINTFLAGS) $(DPSRCS) > dpasswd.lint
X
Xpwconv:	$(PWOBJS) libshadow.a config.h
X	$(CC) -o pwconv $(LDFLAGS) $(PWOBJS) libshadow.a $(LIBS)
X
Xpwconv.lint: $(PWSRCS) config.h
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PWSRCS) > pwconv.lint
X
Xpwunconv: $(PWUNOBJS) libshadow.a config.h
X	$(CC) -o pwunconv $(LDFLAGS) $(PWUNOBJS) libshadow.a $(LIBS)
X
Xpwunconv.lint: $(PWUNSRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PWUNSRCS) > pwunconv.lint
X
Xsulogin: $(SULOGOBJS) libshadow.a
X	$(CC) -o sulogin $(LDFLAGS) $(SULOGOBJS) libshadow.a $(LIBS)
X
Xsulogin.lint: $(SULOGSRCS)
X	$(LINT) $(LINTFLAGS) $(SULOGSRCS) > sulogin.lint
X
Xfaillog: faillog.o
X	$(CC) -o faillog $(LDFLAGS) faillog.o $(LIBS)
X
Xfaillog.lint: faillog.c faillog.h config.h
X	$(LINT) $(LINTFLAGS) faillog.c > faillog.lint
X
Xlastlog: lastlog.o
X	$(CC) -o lastlog $(LDFLAGS) lastlog.o $(LIBS)
X
Xlastlog.lint: lastlog.c config.h lastlog.h
X	$(LINT) $(LINTFLAGS) $(MKPWDSRCS) > lastlog.lint
X
Xmkpasswd: $(MKPWDOBJS) libshadow.a
X	$(CC) -o mkpasswd $(LDFLAGS) $(MKPWDOBJS) libshadow.a $(LIBS)
X
Xmkpasswd.lint: $(MKPWDSRCS)
X	$(LINT) $(LINTFLAGS) $(MKPWDSRCS) > mkpasswd.lint
X
Xnewgrp: $(NGOBJS) libshadow.a
X	$(CC) -o newgrp $(LDFLAGS) $(NGOBJS) libshadow.a $(LIBS)
X
Xnewgrp.lint: $(NGSRCS)
X	$(LINT) $(LINTFLAGS) $(NGSRCS) > newgrp.lint
X
Xsg:	newgrp
X	rm -f sg
X	ln newgrp sg
X
Xchfn:	$(CHFNOBJS) libshadow.a
X	$(CC) -o chfn $(LDFLAGS) $(CHFNOBJS) libshadow.a $(LIBS)
X
Xchfn.lint:	$(CHFNSRCS)
X	$(LINT) $(LINTFLAGS) $(CHFNSRCS) > chfn.lint
X
Xchsh:	$(CHSHOBJS) libshadow.a
X	$(CC) -o chsh $(LDFLAGS) $(CHSHOBJS) libshadow.a $(LIBS)
X
Xchsh.lint: $(CHSHSRCS)
X	$(LINT) $(LINTFLAGS) $(CHSHSRCS) > chsh.lint
X
Xchage:	$(CHAGEOBJS) libshadow.a
X	$(CC) -o chage $(LDFLAGS) $(CHAGEOBJS) libshadow.a $(LIBS)
X
Xchage.lint: $(CHAGESRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(CHAGESRCS) > chage.lint
X
Xchpasswd: $(CHPASSOBJS) libshadow.a
X	$(CC) -o chpasswd $(LDFLAGS) $(CHPASSOBJS) libshadow.a $(LIBS)
X
Xchpasswd.lint: $(CHPASSSRCS)
X	$(LINT) $(LINTFLAGS) $(CHPASSSRCS) > chpasswd.lint
X
Xnewusers: newusers.o libshadow.a
X	$(CC) -o newusers $(LDFLAGS) newusers.o libshadow.a $(LIBS)
X
Xnewusers.lint: newusers.c
X	$(LINT) $(LINTFLAGS) newusers.c > newusers.lint
X	
Xid: id.o libshadow.a
X	$(CC) -o id $(LDFLAGS) id.o libshadow.a $(LIBS)
X
Xid.lint: id.c
X	$(LINT) $(LINTFLAGS) id.c > id.lint
X
Xgroups: groups.o libshadow.a
X	$(CC) -o groups $(LDFLAGS) groups.o libshadow.a $(LIBS)
X
Xgroups.lint: groups.c
X	$(LINT) $(LINTFLAGS) groups.c > groups.lint
X
Xuseradd: useradd.o copydir.o mkrmdir.o libshadow.a
X	$(CC) -o useradd $(LDFLAGS) useradd.o copydir.o mkrmdir.o \
X		libshadow.a $(LIBS) $(NDIR)
X
Xuseradd.lint: useradd.c copydir.c mkrmdir.c
X	$(LINT) $(LINTFLAGS) useradd.c copydir.c mkrmdir.c > useradd.lint
X
Xuserdel: userdel.o copydir.o mkrmdir.o libshadow.a
X	$(CC) -o userdel $(LDFLAGS) userdel.o copydir.o mkrmdir.o \
X		libshadow.a $(LIBS) $(NDIR)
X
Xuserdel.lint: userdel.c copydir.c mkrmdir.c
X	$(LINT) $(LINTFLAGS) userdel.c copydir.c mkrmdir.c > userdel.lint
X
Xusermod: usermod.o copydir.o mkrmdir.o chowndir.o libshadow.a
X	$(CC) -o usermod $(LDFLAGS) usermod.o copydir.o mkrmdir.o \
X		chowndir.o libshadow.a $(LIBS) $(NDIR)
X
Xusermod.lint: usermod.c copydir.c mkrmdir.c chowndir.c
X	$(LINT) $(LINTFLAGS) usermod.c copydir.c mkrmdir.c \
X		chowndir.c > usermod.lint
X
Xgroupadd: groupadd.o libshadow.a
X	$(CC) -o groupadd $(LDFLAGS) groupadd.o libshadow.a $(LIBS)
X
Xgroupadd.lint: groupadd.c
X	$(LINT) $(LINTFLAGS) groupadd.c > groupadd.lint
X
Xgroupdel: groupdel.o libshadow.a
X	$(CC) -o groupdel $(LDFLAGS) groupdel.o libshadow.a $(LIBS)
X
Xgroupdel.lint: groupdel.c
X	$(LINT) $(LINTFLAGS) groupdel.c > groupdel.lint
X
Xgroupmod: groupmod.o libshadow.a
X	$(CC) -o groupmod $(LDFLAGS) groupmod.o libshadow.a $(LIBS)
X
Xgroupmod.lint: groupmod.c
X	$(LINT) $(LINTFLAGS) groupmod.c > groupmod.lint
X
Xpwd.h.m4:
X	[ -f s.pwd.h.m4 ] && get -t -r$(RELEASE) s.pwd.h.m4
X
Xpwd.h: pwd.h.m4
X	/usr/5bin/m4 $(OS) < pwd.h.m4 > pwd.h
X
Xlogoutd: logoutd.o libshadow.a
X	$(CC) -o logoutd $(LDFLAGS) logoutd.o libshadow.a
X
Xlogoutd.lint: logoutd.c
X	$(LINT) $(LINTFLAGS) logoutd.c > logoutd.lint
X
Xpwck: pwck.o libshadow.a
X	$(CC) -o pwck $(LDFLAGS) pwck.o libshadow.a $(LIBS)
X
Xpwck.lint: pwck.c
X	$(LINT) $(LINTFLAGS) pwck.c > pwck.lint
X
Xgrpck: grpck.o libshadow.a
X	$(CC) -o grpck $(LDFLAGS) grpck.o libshadow.a $(LIBS)
X
Xgrpck.lint: grpck.c
X	$(LINT) $(LINTFLAGS) grpck.c > grpck.lint
X
Xsulog.o: config.h
X
Xsusetup.c: setup.c
X	cp setup.c susetup.c
X
Xsusetup.o: config.h susetup.c pwd.h
X	$(CC) -c $(CFLAGS) -DSU susetup.c
X
Xscologin: scologin.o
X	$(CC) -o scologin $(LDFLAGS) scologin.o -lsocket
X
Xpasswd.o: config.h shadow.h pwd.h pwauth.h
Xlmain.o: config.h lastlog.h faillog.h pwd.h pwauth.h
Xsmain.o: config.h lastlog.h pwd.h shadow.h pwauth.h
Xsub.o: pwd.h
Xsetup.o: config.h pwd.h
Xmkrmdir.o: config.h
Xutmp.o: config.h
Xmail.o: config.h
Xmotd.o: config.h
Xage.o: config.h pwd.h
Xlog.o: config.h lastlog.h pwd.h
Xshell.o: config.h
Xentry.o: config.h shadow.h pwd.h
Xhushed.o: config.h pwd.h
Xvalid.o: config.h pwd.h
Xfailure.o: faillog.h config.h
Xfaillog.o: faillog.h config.h pwd.h
Xnewgrp.o: config.h shadow.h pwd.h
Xmkpasswd.o: config.h shadow.h pwd.h
Xgpmain.o: config.h pwd.h
Xchfn.o: config.h pwd.h
Xchsh.o: config.h pwd.h
Xchage.o: config.h shadow.h pwd.h
Xpwconv.o: config.h shadow.h
Xpwunconv.o: config.h shadow.h pwd.h
Xchpasswd.o: config.h shadow.h pwd.h
Xid.o: pwd.h
Xnewusers.o: config.h shadow.h pwd.h
Xdpmain.o: config.h dialup.h
Xuseradd.o: config.h shadow.h pwd.h pwauth.h
Xuserdel.o: config.h shadow.h pwd.h pwauth.h
Xusermod.o: config.h shadow.h pwd.h pwauth.h
Xgroupadd.o: config.h shadow.h
Xgroupdel.o: config.h shadow.h
Xgroupmod.o: config.h shadow.h
Xlogoutd.o: config.h
Xsulogin.o: config.h pwauth.h
Xcopydir.o: config.h
Xchowndir.o: config.h
Xpwck.o: config.h shadow.h pwd.h
Xgrpck.o: config.h shadow.h pwd.h
X
Xlibshadow.a(shadow.o): shadow.h config.h
Xlibshadow.a(shadowio.o): shadow.h
Xlibshadow.a(grent.o): config.h shadow.h
Xlibshadow.a(sgroupio.o): shadow.h
Xlibshadow.a(dialup.o): dialup.h
Xlibshadow.a(dialchk.o): dialup.h config.h
Xlibshadow.a(getdef.o): config.h
Xlibshadow.a(pwdbm.o): config.h pwd.h
Xlibshadow.a(spdbm.o): config.h shadow.h
Xlibshadow.a(grdbm.o): config.h
Xlibshadow.a(gshadow.o): config.h
Xlibshadow.a(gsdbm.o): config.h shadow.h
Xlibshadow.a(pwauth.o): config.h pwauth.h
Xlibshadow.a(pwpack.o): config.h pwd.h
Xlibshadow.a(pwent.o): config.h pwd.h
Xlibshadow.a(pwio.o): pwd.h
Xlibshadow.a(getpass.o): config.h
Xlibshadow.a(encrypt.o): config.h
Xlibshadow.a(port.o): port.h
Xlibshadow.a(rad64.o): config.h
Xlibshadow.a(lockpw.o):
X
Xclean:
X	-rm -f susetup.c *.o a.out core npasswd nshadow *.pag *.dir pwd.h
X
Xclobber: clean
X	-rm -f $(BINS) *.lint *.L libshadow.a
X
Xnuke:	clobber
X	-for file in * ; do \
X		if [ -f s.$$file -a ! -f p.$$file ] ; then \
X			rm -f $$file ;\
X		fi ;\
X	done
X
Xshar:	login.sh.01 login.sh.02 login.sh.03 login.sh.04 login.sh.05 \
X	login.sh.06 login.sh.07 login.sh.08 login.sh.09 login.sh.10 \
X	login.sh.11 login.sh.12
X
Xlogin.sh.01: $(FILES1) Makefile
X	shar -a $(FILES1) > login.sh.01
X
Xlogin.sh.02: $(FILES2) Makefile
X	shar -a $(FILES2) > login.sh.02
X
Xlogin.sh.03: $(FILES3) Makefile
X	shar -a $(FILES3) > login.sh.03
X
Xlogin.sh.04: $(FILES4) Makefile
X	shar -a $(FILES4) > login.sh.04
X
Xlogin.sh.05: $(FILES5) Makefile
X	shar -a $(FILES5) > login.sh.05
X
Xlogin.sh.06: $(FILES6) Makefile
X	shar -a $(FILES6) > login.sh.06
X
Xlogin.sh.07: $(FILES7) Makefile
X	shar -a $(FILES7) > login.sh.07
X
Xlogin.sh.08: $(FILES8) Makefile
X	shar -a $(FILES8) > login.sh.08
X
Xlogin.sh.09: $(FILES9) Makefile
X	shar -a $(FILES9) > login.sh.09
X
Xlogin.sh.10: $(DOCS1) Makefile
X	shar -a $(DOCS1) > login.sh.10
X
Xlogin.sh.11: $(DOCS2) Makefile
X	shar -a $(DOCS2) > login.sh.11
X
Xlogin.sh.12: $(FILES_SUN4) $(FILES_SVR4) Makefile
X	shar -a $(FILES_SUN4) $(FILES_SVR4) > login.sh.12
END_OF_FILE
  if test 18789 -ne `wc -c <'Makefile.sun4'`; then
    echo shar: \"'Makefile.sun4'\" unpacked with wrong size!
  fi
  # end of 'Makefile.sun4'
fi
if test -f 'chsh.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chsh.c'\"
else
  echo shar: Extracting \"'chsh.c'\" \(10350 characters\)
  sed "s/^X//" >'chsh.c' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <signal.h>
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)chsh.c	3.9	07:46:32	20 Apr 1993";
X#endif
X
X/*
X * Set up some BSD defines so that all the BSD ifdef's are
X * kept right here 
X */
X
X#ifndef	BSD
X#include <string.h>
X#include <memory.h>
X#else
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#endif
X
X#include "config.h"
X#include "pwd.h"
X
X#ifdef	USE_SYSLOG
X#include <syslog.h>
X
X#ifndef	LOG_WARN
X#define	LOG_WARN LOG_WARNING
X#endif
X#endif
X#ifdef	HAVE_RLIMIT
X#include <sys/resource.h>
X
Xstruct	rlimit	rlimit_fsize = { RLIM_INFINITY, RLIM_INFINITY };
X#endif
X
X/*
X * Global variables.
X */
X
Xchar	*Prog;			/* Program name */
Xint	amroot;				/* Real UID is root */
Xchar	loginsh[BUFSIZ];		/* Name of new login shell */
X
X/*
X * External identifiers
X */
X
Xextern	struct	passwd	*getpwuid ();
Xextern	struct	passwd	*getpwnam ();
Xextern	void	change_field ();
Xextern	int	optind;
Xextern	char	*optarg;
Xextern	char	*getlogin ();
X#ifdef	NDBM
Xextern	int	pw_dbm_mode;
X#endif
X
X/*
X * #defines for messages.  This facilitates foreign language conversion
X * since all messages are defined right here.
X */
X
X#define	USAGE		"Usage: %s [ -s shell ] [ name ]\n"
X#define	WHOAREYOU	"%s: Cannot determine your user name.\n"
X#define	UNKUSER		"%s: Unknown user %s\n"
X#define	NOPERM		"You may not change the shell for %s.\n"
X#define	NOPERM2		"can't change shell for `%s'\n"
X#define	NEWSHELLMSG	"Changing the login shell for %s\n"
X#define	NEWSHELL	"Login Shell"
X#define	NEWSHELLMSG2 \
X	"Enter the new value, or press return for the default\n\n"
X#define	BADSHELL	"%s is an invalid shell.\n"
X#define	BADFIELD	"%s: Invalid entry: %s\n"
X#define	PWDBUSY		"Cannot lock the password file; try again later.\n"
X#define	PWDBUSY2	"can't lock /etc/passwd\n"
X#define	OPNERROR	"Cannot open the password file.\n"
X#define	OPNERROR2	"can't open /etc/passwd\n"
X#define	UPDERROR	"Error updating the password entry.\n"
X#define	UPDERROR2	"error updating passwd entry\n"
X#define	DBMERROR	"Error updating the DBM password entry.\n"
X#define	DBMERROR2	"error updating DBM passwd entry.\n"
X#define	NOTROOT		"Cannot change ID to root.\n"
X#define	NOTROOT2	"can't setuid(0).\n"
X#define	CLSERROR	"Cannot commit password file changes.\n"
X#define	CLSERROR2	"can't rewrite /etc/passwd.\n"
X#define	UNLKERROR	"Cannot unlock the password file.\n"
X#define	UNLKERROR2	"can't unlock /etc/passwd.\n"
X#define	CHGSHELL	"changed user `%s' shell to `%s'\n"
X
X/*
X * usage - print command line syntax and exit
X */
X
Xvoid
Xusage ()
X{
X	fprintf (stderr, USAGE, Prog);
X	exit (1);
X}
X
X/*
X * new_fields - change the user's login shell information interactively
X *
X * prompt the user for the login shell and change it according to the
X * response, or leave it alone if nothing was entered.
X */
X
Xnew_fields ()
X{
X	printf (NEWSHELLMSG2);
X	change_field (loginsh, NEWSHELL);
X}
X
X/*
X * check_shell - see if the user's login shell is listed in /etc/shells
X *
X * The /etc/shells file is read for valid names of login shells.  If the
X * /etc/shells file does not exist the user cannot set any shell unless
X * they are root.
X */
X
Xcheck_shell (shell)
Xchar	*shell;
X{
X	char	buf[BUFSIZ];
X	char	*cp;
X	int	found = 0;
X	FILE	*fp;
X
X	if (amroot)
X		return 1;
X
X	if ((fp = fopen ("/etc/shells", "r")) == (FILE *) 0)
X		return 0;
X
X	while (fgets (buf, BUFSIZ, fp) && ! found) {
X		if (cp = strrchr (buf, '\n'))
X			*cp = '\0';
X
X		if (strcmp (buf, shell) == 0)
X			found = 1;
X	}
X	fclose (fp);
X
X	return found;
X}
X
X/*
X * restricted_shell - return true if the named shell begins with 'r' or 'R'
X *
X * If the first letter of the filename is 'r' or 'R', the shell is
X * considered to be restricted.
X */
X
Xint
Xrestricted_shell (shell)
Xchar	*shell;
X{
X	char	*cp;
X
X	if (cp = strrchr (shell, '/'))
X		cp++;
X	else
X		cp = shell;
X
X	return *cp == 'r' || *cp == 'R';
X}
X
X/*
X * chsh - this command controls changes to the user's shell
X *
X *	The only supported option is -s which permits the
X *	the login shell to be set from the command line.
X */
X
Xint
Xmain (argc, argv)
Xint	argc;
Xchar	**argv;
X{
X	char	user[BUFSIZ];		/* User name                         */
X	int	flag;			/* Current command line flag         */
X	int	sflg = 0;		/* -s - set shell from command line  */
X	int	i;			/* Loop control variable             */
X	char	*cp;			/* Miscellaneous character pointer   */
X	struct	passwd	*pw;		/* Password entry from /etc/passwd   */
X	struct	passwd	pwent;		/* New password entry                */
X
X	/*
X	 * This command behaves different for root and non-root
X	 * users.
X	 */
X
X	amroot = getuid () == 0;
X#ifdef	NDBM
X	pw_dbm_mode = O_RDWR;
X#endif
X
X	/*
X	 * Get the program name.  The program name is used as a
X	 * prefix to most error messages.  It is also used as input
X	 * to the openlog() function for error logging.
X	 */
X
X	if (Prog = strrchr (argv[0], '/'))
X		Prog++;
X	else
X		Prog = argv[0];
X
X#ifdef	USE_SYSLOG
X	openlog (Prog, LOG_PID, LOG_AUTH);
X#endif
X
X	/*
X	 * There is only one option, but use getopt() anyway to
X	 * keep things consistent.
X	 */
X
X	while ((flag = getopt (argc, argv, "s:")) != EOF) {
X		switch (flag) {
X			case 's':
X				sflg++;
X				strcpy (loginsh, optarg);
X				break;
X			default:
X				usage ();
X		}
X	}
X
X	/*
X	 * There should be only one remaining argument at most
X	 * and it should be the user's name.
X	 */
X
X	if (argc > optind + 1)
X		usage ();
X
X	/*
X	 * Get the name of the user to check.  It is either
X	 * the command line name, or the name getlogin()
X	 * returns.
X	 */
X
X	if (optind < argc) {
X		strncpy (user, argv[optind], sizeof user);
X		pw = getpwnam (user);
X	} else if (cp = getlogin ()) {
X		strncpy (user, cp, sizeof user);
X		pw = getpwnam (user);
X	} else {
X		fprintf (stderr, WHOAREYOU, Prog);
X#ifdef	USE_SYSLOG
X		closelog ();
X#endif
X		exit (1);
X	}
X
X	/*
X	 * Make certain there was a password entry for the
X	 * user.
X	 */
X
X	if (! pw) {
X		fprintf (stderr, UNKUSER, Prog, user);
X#ifdef	USE_SYSLOG
X		closelog ();
X#endif
X		exit (1);
X	}
X
X	/*
X	 * Non-privileged users are only allowed to change the
X	 * shell if the UID of the user matches the current
X	 * real UID.
X	 */
X
X	if (! amroot && pw->pw_uid != getuid ()) {
X		fprintf (stderr, NOPERM, user);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, NOPERM2, user);
X		closelog ();
X#endif
X		exit (1);
X	}
X
X	/*
X	 * Non-privileged users are only allowed to change the
X	 * shell if it is not a restricted one.
X	 */
X
X	if (! amroot && restricted_shell (pw->pw_shell)) {
X		fprintf (stderr, NOPERM, user);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, NOPERM2, user);
X		closelog ();
X#endif
X		exit (1);
X	}
X
X	/*
X	 * Make a copy of the user's password file entry so it
X	 * can be modified without worrying about it be modified
X	 * elsewhere.
X	 */
X
X	pwent = *pw;
X	pwent.pw_name = strdup (pw->pw_name);
X	pwent.pw_passwd = strdup (pw->pw_passwd);
X#ifdef	ATT_AGE
X	pwent.pw_age = strdup (pw->pw_age);
X#endif
X#ifdef	ATT_COMMENT
X	pwent.pw_comment = strdup (pw->pw_comment);
X#endif
X	pwent.pw_dir = strdup (pw->pw_dir);
X	pwent.pw_gecos = strdup (pw->pw_gecos);
X
X	/*
X	 * Now get the login shell.  Either get it from the password
X	 * file, or use the value from the command line.
X	 */
X
X	if (! sflg)
X		strcpy (loginsh, pw->pw_shell);
X
X	/*
X	 * If the login shell was not set on the command line,
X	 * let the user interactively change it.
X	 */
X
X	if (! sflg) {
X		printf (NEWSHELLMSG, user);
X		new_fields ();
X	}
X
X	/*
X	 * Check all of the fields for valid information.  The shell
X	 * field may not contain any illegal characters.  Non-privileged
X	 * users are restricted to using the shells in /etc/shells.
X	 */
X
X	if (valid_field (loginsh, ":,=")) {
X		fprintf (stderr, BADFIELD, Prog, loginsh);
X#ifdef	USE_SYSLOG
X		closelog ();
X#endif
X		exit (1);
X	}
X	if (! check_shell (loginsh)) {
X		fprintf (stderr, BADSHELL, loginsh);
X#ifdef	USE_SYSLOG
X		closelog ();
X#endif
X		exit (1);
X	}
X	pwent.pw_shell = loginsh;
X	pw = &pwent;
X
X	/*
X	 * Before going any further, raise the ulimit to prevent
X	 * colliding into a lowered ulimit, and set the real UID
X	 * to root to protect against unexpected signals.  Any
X	 * keyboard signals are set to be ignored.
X	 */
X
X#ifdef	HAVE_ULIMIT
X	ulimit (2, 30000);
X#endif
X#ifdef	HAVE_RLIMIT
X	setrlimit (RLIMIT_FSIZE, &rlimit_fsize);
X#endif
X	if (setuid (0)) {
X		fprintf (stderr, NOTROOT);
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, NOTROOT2);
X		closelog ();
X#endif
X		exit (1);
X	}
X	signal (SIGHUP, SIG_IGN);
X	signal (SIGINT, SIG_IGN);
X	signal (SIGQUIT, SIG_IGN);
X#ifdef	SIGTSTP
X	signal (SIGTSTP, SIG_IGN);
X#endif
X
X	/*
X	 * The passwd entry is now ready to be committed back to
X	 * the password file.  Get a lock on the file and open it.
X	 */
X
X	for (i = 0;i < 30;i++)
X		if (pw_lock ())
X			break;
X
X	if (i == 30) {
X		fprintf (stderr, PWDBUSY);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, PWDBUSY2);
X		closelog ();
X#endif
X		exit (1);
X	}
X	if (! pw_open (O_RDWR)) {
X		fprintf (stderr, OPNERROR);
X		(void) pw_unlock ();
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, OPNERROR2);
X		closelog ();
X#endif
X		exit (1);
X	}
X
X	/*
X	 * Update the passwd file entry.  If there is a DBM file,
X	 * update that entry as well.
X	 */
X
X	if (! pw_update (pw)) {
X		fprintf (stderr, UPDERROR);
X		(void) pw_unlock ();
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, UPDERROR2);
X		closelog ();
X#endif
X		exit (1);
X	}
X#if defined(DBM) || defined(NDBM)
X	if (access ("/etc/passwd.pag", 0) == 0 && ! pw_dbm_update (pw)) {
X		fprintf (stderr, DBMERROR);
X		(void) pw_unlock ();
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, DBMERROR2);
X		closelog ();
X#endif
X		exit (1);
X	}
X	endpwent ();
X#endif
X
X	/*
X	 * Changes have all been made, so commit them and unlock the
X	 * file.
X	 */
X
X	if (! pw_close ()) {
X		fprintf (stderr, CLSERROR);
X		(void) pw_unlock ();
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, CLSERROR2);
X		closelog ();
X#endif
X		exit (1);
X	}
X	if (! pw_unlock ()) {
X		fprintf (stderr, UNLKERROR);
X#ifdef	USE_SYSLOG
X		syslog (LOG_ERR, UNLKERROR2);
X		closelog ();
X#endif
X		exit (1);
X	}
X#ifdef	USE_SYSLOG
X	syslog (LOG_INFO, CHGSHELL, user, pwent.pw_shell);
X	closelog ();
X#endif
X	exit (0);
X}
END_OF_FILE
  if test 10350 -ne `wc -c <'chsh.c'`; then
    echo shar: \"'chsh.c'\" unpacked with wrong size!
  fi
  # end of 'chsh.c'
fi
if test -f 'login.5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'login.5'\"
else
  echo shar: Extracting \"'login.5'\" \(14568 characters\)
  sed "s/^X//" >'login.5' <<'END_OF_FILE'
X.\" Copyright 1991, 1992, 1993, John F. Haugh II and Chip Rosenthal
X.\" All rights reserved.
X.\"
X.\" Permission is granted to copy and create derivative works for any
X.\" non-commercial purpose, provided this copyright notice is preserved
X.\" in all copies of source code, or included in human readable form
X.\" and conspicuously displayed on all copies of object code or
X.\" distribution media.
X.\"
X.\" This software is provided on an AS-IS basis and the author makes
X.\" no warrantee of any kind.
X.\"
X.\"	@(#)login.5	3.6	09:30:17	30 Apr 1993
X.\"
X.TH LOGIN 5
X.SH NAME
X/etc/login.defs \- Login configuration
X.SH DESCRIPTION
XThe
X.I /etc/login.defs
Xfile defines the site-specific configuration for the shadow login
Xsuite.  This file is required.  Absence of this file will not prevent
Xsystem operation, but will probably result in undesirable operation.
X.PP
XThis file is a readable text file, each line of the file describing
Xone configuration parameter.  The lines consist of a configuration
Xname and value, seperated by whitespace.  Blank lines and comment
Xlines are ignored.  Comments are introduced with a `#' pound sign and
Xthe pound sign must be the first non-white character of the line.
X.PP
XParameter values may be of four types:  strings, booleans, numbers,
Xand long numbers.  A string is comprised of any printable characters.
XA boolean should be either the value ``yes'' or ``no''.  An undefined
Xboolean parameter or one with a value other than these will be given
Xa ``no'' value.  Numbers (both regular and long) may be either decimal
Xvalues, octal values (precede the value with ``0'') or hexadecimal
Xvalues (precede the value with ``0x'').  The maximum value of the
Xregular and long numeric parameters is machine-dependant.
X.PP
XThe following configuration items are provided:
X.\"
X.IP "CONSOLE (string)"
XIf specified, this definition provides for a restricted set of lines
Xon which root logins will be allowed.  An attempted root login which
Xdoes not meet the criteria established here will be rejected.  The
Xvalue of this field may be one of two forms, either a fully-rooted
Xpathname such as
X.sp
X.ft CW
X	CONSOLE /etc/consoles
X.ft P
X.sp
Xor a colon-delimited list of terminal lines such as:
X.sp
X.ft CW
X	CONSOLE console:tty01:tty02:tty03:tty04
X.ft P
X.sp
XIf a pathname is given, each line of the file should specify one
Xterminal line.  If this parameter is not defined or the specified file
Xdoes not exist, then root logins will be allowed from any terminal
Xline.  Because the removal of this file, or its truncation, could
Xresult in unauthorized root logins, this file must be protected.
XWhere security is critical, the colon-separated form should be used
Xto prevent this potential method of attack.
X.\"
X.IP "DIALUPS_CHECK_ENAB (boolean)"
XIf
X.I yes
Xand an
X.I /etc/dialups
Xfile exists, then secondary passwords are enabled upon the dialup
Xlines specified in this file.  This file should contain a list of
Xdialups, one per line, for example:
X.nf
X.sp
X.ft CW
X	ttyfm01
X	ttyfm02
X	\0\0.
X	\0\0.
X	\0\0.
X.ft P
X.sp
X.fi
X.\"
X.IP "ENV_HZ (string)"
XThis parameter specifies a value for an HZ environment parameter.
XExample usage is:
X.sp
X	\f(CWENV_HZ     HZ=50\fP
X.sp
XIf this parameter is not defined then no HZ value will be established.
X.\"
X.IP "ENV_PATH (string)"
XThis parameter must be defined as the search path for regular users.
XWhen a login with UID other than zero occurs, the PATH environment
Xparameter is initialized to this value.  This parameter is required;
Xif undefined a possibly incorrect default value will be provided.
X.\"
X.IP "ENV_SUPATH (string)"
XThis parameter must be defined as the search path for the superuser.
XWhen a login with UID zero occurs, the PATH environment parameter is
Xinitialized to this value.  This parameter is required; if undefined
Xa possibly incorrect default value will be provided.
X.\"
X.IP "ENV_TZ (string)"
XThis parameter specifies information for generating a TZ environment
Xparameter.  The value must either be the desired contents of TZ, or
Xthe full pathname of a file which contains this information.  Example
Xusage is:
X.sp
X	\f(CWENV_TZ\0\0\0\0TZ=CST6CDT\fP
X.sp
Xor
X.sp
X	\f(CWENV_TZ\0\0\0\0/etc/tzname\fP
X.sp
XIf a nonexistent file is named, then TZ will be initialized to some
Xdefault value.  If this parameter is not defined then no TZ value will
Xbe established.
X.\"
X.IP "ERASECHAR (number)"
XThe terminal
X.I erase
Xcharacter is initialized to this value.  This is supported only on
Xsystems with the
X.I termio
Xinterface, e.g. System V.  If not specified, the erase character will
Xbe initialized to a backspace.  See KILLCHAR for related information.
X.\"
X.IP "FAILLOG_ENAB (boolean)"
XIf
X.I yes
Xthen login failures will be accumulated in
X.I /usr/adm/faillog
Xin a
X.I faillog(8)
Xformat.
X.\"
X.IP "FTMP_FILE (string)"
XThis parameter specifies the full pathname to a file to which login
Xfailures are recorded.  When a login failure occurs, a
X.I utmp
Xformat record will be appended to this file.  Note that this differs
Xfrom the
X.I /usr/adm/faillog
Xfailure logging in that this facility logs every failure whereas the
X``faillog'' facility accumulates failure information per user.  If
Xthis parameter is not specified then logging will be inhibited.  See
XFAILLOG_ENAB and LOG_UNKFAIL_ENAB for related information.
X.\"
X.IP "HUSHLOGIN_FILE (string)"
XThis parameter is used to establish ``hushlogin'' conditions.  There
Xare two possible ways to establish these conditions.  First, if the
Xvalue of this parameter is a filename and that file exists in the
Xuser's home directory then ``hushlogin'' conditions will be in effect.
XThe contents of this file are ignored; its mere presence triggers
X``hushlogin'' conditions.  Second, if the value of this parameter is
Xa full pathname and either the user's login name or the user's shell
Xis found in this file, then ``hushlogin'' conditions will be in effect.
XIn this case, the file should be in a format similar to:
X.nf
X.sp
X.ft CW
X	demo
X	/usr/lib/uucp/uucico
X	\0\0.
X	\0\0.
X	\0\0.
X.ft P
X.sp
X.fi
XIf this parameter is not defined, then ``hushlogin'' conditions will
Xnever occur.  When ``hushlogin'' conditions are established, the
Xmessage of the day, last successful and unsuccessful login display,
Xmail status display, and password aging checks are suppressed.  Note
Xthat allowing hushlogin files in user home directories allows the user
Xto disable password aging checks.  See MOTD_FILE, FAILLOG_ENAB,
XLASTLOG_ENAB, and MAIL_CHECK_ENAB for related information.
X.\"
X.IP "KILLCHAR (number)"
XThe terminal
X.I kill
Xcharacter is initialized to this value.  This is supported only on
Xsystems with the
X.I termio
Xinterface, e.g. System V.  If not specified, the kill character will
Xbe initialized to a \s-2CTRL/U\s0.
XSee ERASECHAR for related information.
X.\"
X.IP "LASTLOG_ENAB (boolean)"
XIf
X.IR yes ,
Xand if the
X.I /usr/adm/lastlog
Xfile exists, then a successful user login will be recorded to this
Xfile.  Furthermore, if this option is enabled then the times of the
Xmost recent successful and unsuccessful logins will be displayed to
Xthe user upon login.  The unsuccessful login display will be suppressed
Xif FAILLOG_ENAB is not enabled.  If ``hushlogin'' conditions are in
Xeffect, then both the successful and unsuccessful login information
Xwill be suppressed.
X.\"
X.IP "LOG_UNKFAIL_ENAB (boolean)"
XIf
X.I yes
Xthen unknown usernames will be included when a login failure is
Xrecorded.  Note that this is a potential security risk; a common login
Xfailure mode is transposition of the user name and password, thus this
Xmode will often cause passwords to accumulate in the failure logs.
XIf this option is disabled then unknown usernames will be suppressed
Xin login failure messages.
X.\"
X.IP "MAIL_CHECK_ENAB (boolean)"
XIf
X.IR yes ,
Xthe user will be notified of his or her mailbox status upon login.
XSee MAIL_DIR for related information.
X.\"
X.IP "MAIL_DIR (string)"
XThis parameter specifies the full pathname to the directory which
Xcontains the user mailbox files.  The user's login name is appended
Xto this path to form the MAIL environment parameter \- the path to
Xthe user's mailbox.  This parameter must be defined; if undefined some
Xpossibly incorrect default value will be assumed.  See MAIL_CHECK_ENAB
Xfor related information.
X.\"
X.IP "MOTD_FILE (string)"
XThis parameter specifies a colon-delimited list of pathnames to ``message
Xof the day'' files.
XIf a specified file exists, then its contents are displayed to the user
Xupon login.
XIf this parameter is not defined or ``hushlogin'' login conditions are
Xin effect, this information will be suppressed.
X.\"
X.IP "NOLOGINS_FILE (string)"
XThis parameter specifies the full pathname to a file which inhibits
Xnon-root logins.  If this file exists and a user other than root
Xattempts to log in, the contents of the file will be displayed and
Xthe user will be disconnected.  If this parameter is not specified
Xthen this feature will be inhibited.
X.\"
X.IP "OBSCURE_CHECKS_ENAB (boolean)"
XIf
X.IR yes ,
Xthe
X.I passwd
Xprogram will perform additional checks before accepting a password change.
XThe checks performed are fairly simple, and their use is recommended.
XThese obscurity checks are bypassed if
X.I passwd
Xis run by
X.IR root .
XSee PASS_MIN_LEN for related information.
X.\"
X.IP "PASS_MIN_DAYS (number)"
XThe minimum number of days allowed between password changes.  Any password
Xchanges attempted sooner than this will be rejected.  If not specified, a
Xzero value will be assumed.
X.\"
X.IP "PASS_MIN_LEN (number)"
XThe minimum number of characters in an acceptable password.  An attempt to
Xassign a password with fewer characters will be rejected.  A zero value
Xsuppresses this check.  If not specified, a zero value will be assumed.
X.\"
X.IP "PASS_MAX_DAYS (number)"
XThe maximum number of days a password may be used.  If the password is
Xolder than this, then the account will be locked.  If not specified,
Xa large value will be assumed.
X.\"
X.IP "PASS_WARN_AGE (number)"
XThe number of days warning given before a password expires.  A zero means
Xwarning is given only upon the day of expiration, a negative value means
Xno warning is given.  If not specified, no warning will be provided.
X.IP "PORTTIME_CHECKS_ENAB (boolean)"
XIf
X.I yes
Xand an
X.I /etc/porttime
Xfile exists, that file will be consulted to ensure the user may login
Xat this time on the given line.
Xc.f. porttime(4)
X.\"
X.IP "QUOTAS_ENAB (boolean)"
XIf
X.I yes ,
Xthen the user's ``ulimit,'' ``umask,'' and ``niceness'' will be
Xinitialized to the values if specified in the
X.I gecos
Xfield of the
X.I passwd
Xfile.
Xc.f. passwd(4).
X.\"
X.IP "SU_NAME (string)"
XThis parameter assigns a command name when ``su -'' is run.  For
Xexample, if the parameter is defined as ``su'', then a
X.I ps(1)
Xlisting would show the command running as ``-su''.  If this parameter
Xis undefined, then a
X.I ps(1)
Xlisting would show the name of the actual shell being run, e.g.
Xsomething like ``-sh''.
X.\"
X.IP "SULOG_FILE (string)"
XThis parameter specifies a full pathname of a file in which
X.I su
Xactivity is logged.
XIf this parameter is not specified, the logging is suppressed.
XBecause the
X.I su
Xcommand may be used when attempting to authenticate a password,
Xeither this option, or
X.I syslog
Xshould be used to note
X.I su
Xactivity.  See the SYSLOG_SU_ENAB option for related information.
X.\"
X.IP "SYSLOG_SU_ENAB (boolean)"
XIf
X.I yes
Xand
X.I login
Xwas compiled with
X.I syslog
Xsupport, then all
X.I su
Xactivity will be noted through the
X.I syslog
Xfacility.
XSee SULOG_FILE for related information.
X.\"
X.IP "TTYGROUP (string or number)"
XThe group ownership of the terminal is initialized to this group
Xname or number.  One well-known security attack involves forcing terminal
Xcontrol sequences upon another user's terminal line.  This problem
Xcan be averted by disabling permissions which allow other users to
Xaccess the terminal line, but this unfortunately prevents programs
Xsuch as
X.I write
Xfrom operating.  Another solution is to use a version of the
X.I write
Xprogram which filters out potentially dangerous character sequences,
Xmake this program ``setgid'' to a special group, assign group ownership
Xof the terminal line to this special group, and assign permissions of
X\f(CW0620\fP to the terminal line.  The TTYGROUP definition has been
Xprovided for just this situation.  If this item is not defined, then
Xthe group ownership of the terminal is initialized to the user's group
Xnumber.  See TTYPERMS for related information.
X.\"
X.IP "TTYPERM (number)"
XThe login terminal permissions are initialized to this value.  Typical
Xvalues will be \f(CW0622\fP to permit others write access to the line
Xor \f(CW0600\fP to secure the line from other users.  If not specified,
Xthe terminal permissions will be initialized to \f(CW0622\fP.  See
XTTYGROUP for related information.
X.\"
X.IP "TTYTYPE_FILE (string)"
XThis parameter specifies the full pathname to a file which maps terminal
Xlines to terminal types.  Each line of the file contains a terminal
Xtype and a terminal line, seperated by whitespace, for example:
X.nf
X.sp
X.ft CW
X	vt100\0	tty01
X	wyse60	tty02
X	\0\0.\0\0\0	\0\0.
X	\0\0.\0\0\0	\0\0.
X	\0\0.\0\0\0	\0\0.
X.ft P
X.sp
X.fi
XThis information is used to initialize the TERM environment parameter.
XA line starting with a ``#'' pound sign will be treated as a comment.
XIf this paramter is not specified, the file does not exist, or the terminal
Xline is not found in the file, then the TERM environment parameter will not
Xbe set.
X.\"
X.IP "ULIMIT (long number)"
XThe file size limit is initialized to this value.  This is supported
Xonly on systems with a
X.IR ulimit ,
Xe.g. System V.  If not specified, the file size limit will be initialized
Xto some large value.
X.\"
X.IP "UMASK (number)"
XThe permission mask is initialized to this value.  If not specified,
Xthe permission mask will be initialized to zero.
X.\"
X.SH CROSS REFERENCE
XThe following cross reference shows which programs in the shadow login
Xsuite use which parameters.
X.na
X.IP login 12
XCONSOLE DIALUPS_CHECK_ENAB ENV_HZ ENV_SUPATH ENV_TZ ERASECHAR FAILLOG_ENAB
XFTMP_FILE HUSHLOGIN_FILE KILLCHAR LASTLOG_ENAB LOG_UNKFAIL_ENAB
XMAIL_CHECK_ENAB MAIL_DIR MOTD_FILE NOLOGINS_FILE PORTTIME_CHECKS_ENAB
XQUOTAS_ENAB TTYPERM TTYTYPE_FILE ULIMIT UMASK
X.IP newusers 12
XPASS_MAX_DAYS PASS_MIN_DAYS PASS_WARN_AGE UMASK
X.IP passwd 12
XOBSCURE_CHECKS_ENAB PASS_MIN_LEN
X.IP pwconv 12
XPASS_MAX_DAYS PASS_MIN_DAYS PASS_WARN_AGE
X.IP su 12
XENV_HZ ENV_SUPATH ENV_TZ HUSHLOGIN_FILE MAIL_CHECK_ENAB MAIL_DIR
XMOTD_FILE NOLOGIN_STR QUOTAS_ENAB SULOG_FILE SYSLOG_SU_ENAB
X.IP sulogin 12
XENV_HZ ENV_SUPATH ENV_TZ MAIL_DIR QUOTAS_ENAB TTYPERM
X.ad
X.SH SEE ALSO
Xlogin(1), passwd(4), faillog(4), porttime(4), faillog(8)
END_OF_FILE
  if test 14568 -ne `wc -c <'login.5'`; then
    echo shar: \"'login.5'\" unpacked with wrong size!
  fi
  # end of 'login.5'
fi
if test -f 'newusers.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newusers.c'\"
else
  echo shar: Extracting \"'newusers.c'\" \(13274 characters\)
  sed "s/^X//" >'newusers.c' <<'END_OF_FILE'
X/*
X * Copyright 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X *
X *	newusers - create users from a batch file
X *
X *	newusers creates a collection of entries in /etc/passwd
X *	and related files by reading a passwd-format file and
X *	adding entries in the related directories.
X */
X
X#include "config.h"
X#include <stdio.h>
X#include "pwd.h"
X#include <grp.h>
X#include <fcntl.h>
X#include <string.h>
X#ifdef	SHADOWPWD
X#include "shadow.h"
X#endif
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)newusers.c	3.9	09:19:18	04 Jun 1993";
X#endif
X
Xchar	*Prog;
X
Xextern	char	*pw_encrypt();
Xextern	char	*malloc();
X
Xint	pw_lock(), gr_lock();
Xint	pw_open(), gr_open();
Xstruct	passwd	*pw_locate(), *pw_next();
Xstruct	group	*gr_locate(), *gr_next();
Xint	pw_update(), gr_update();
Xint	pw_close(), gr_close();
Xint	pw_unlock(), gr_unlock();
Xextern	int	getdef_num();
X
X#ifdef	SHADOWPWD
Xint	spw_lock(), spw_open(), spw_update(), spw_close(), spw_unlock();
Xstruct	spwd	*spw_locate(), *spw_next();
X#endif
X
X#ifndef	MKDIR
X
X/*
X * mkdir - for those of us with no mkdir() system call.
X */
X
Xmkdir (dir, mode)
Xchar	*dir;
Xint	mode;
X{
X	int	mask;
X	int	status;
X	int	pid;
X	int	i;
X
X	mode = (~mode & 0777);
X	mask = umask (mode);
X	if ((pid = fork ()) == 0) {
X		execl ("/bin/mkdir", "mkdir", dir, (char *) 0);
X		perror ("/bin/mkdir");
X		_exit (1);
X	} else {
X		while ((i = wait (&status)) != pid && i != -1)
X			;
X	}
X	umask (mask);
X	return status;
X}
X#endif
X
X/*
X * usage - display usage message and exit
X */
X
Xusage ()
X{
X	fprintf (stderr, "Usage: %s [ input ]\n", Prog);
X	exit (1);
X}
X
X/*
X * add_group - create a new group or add a user to an existing group
X */
X
Xint
Xadd_group (name, gid, ngid)
Xchar	*name;
Xchar	*gid;
XGID_T	*ngid;
X{
X	struct	passwd	*pwd;
X	struct	group	*grp;
X	struct	group	grent;
X	char	*members[2];
X	int	i;
X
X	/*
X	 * Start by seeing if the named group already exists.  This
X	 * will be very easy to deal with if it does.
X	 */
X
X	if (grp = gr_locate (gid)) {
Xadd_member:
X		grent = *grp;
X		*ngid = grent.gr_gid;
X		for (i = 0;grent.gr_mem[i] != (char *) 0;i++)
X			if (strcmp (grent.gr_mem[i], name) == 0)
X				return 0;
X
X		if (! (grent.gr_mem = (char **)
X				malloc (sizeof (char *) * (i + 2)))) {
X			fprintf (stderr, "%s: Out of Memory\n", Prog);
X			return -1;
X		}
X		memcpy (grent.gr_mem, grp->gr_mem, sizeof (char *) * (i + 2));
X		grent.gr_mem[i] = strdup (name);
X		grent.gr_mem[i + 1] = (char *) 0;
X
X		return ! gr_update (&grent);
X	}
X
X	/*
X	 * The group did not exist, so I try to figure out what the
X	 * GID is going to be.  The gid parameter is probably "", meaning
X	 * I figure out the GID from the password file.  I want the UID
X	 * and GID to match, unless the GID is already used.
X	 */
X
X	if (gid[0] == '\0') {
X		i = 100;
X		for (pw_rewind ();pwd = pw_next ();) {
X			if (pwd->pw_uid >= i)
X				i = pwd->pw_uid + 1;
X		}
X		for (gr_rewind ();grp = gr_next ();) {
X			if (grp->gr_gid == i) {
X				i = -1;
X				break;
X			}
X		}
X	} else if (gid[0] >= '0' && gid[0] <= '9') {
X
X	/*
X	 * The GID is a number, which means either this is a brand new
X	 * group, or an existing group.  For existing groups I just add
X	 * myself as a member, just like I did earlier.
X	 */
X
X		i = atoi (gid);
X		for (gr_rewind ();grp = gr_next ();)
X			if (grp->gr_gid == i)
X				goto add_member;
X	} else
X
X	/*
X	 * The last alternative is that the GID is a name which is not
X	 * already the name of an existing group, and I need to figure
X	 * out what group ID that group name is going to have.
X	 */
X
X		i = -1;
X
X	/*
X	 * If I don't have a group ID by now, I'll go get the
X	 * next one.
X	 */
X
X	if (i == -1) {
X		for (i = 100, gr_rewind ();grp = gr_next ();)
X			if (grp->gr_gid >= i)
X				i = grp->gr_gid + 1;
X	}
X
X	/*
X	 * Now I have all of the fields required to create the new
X	 * group.
X	 */
X
X	if (gid[0] && (gid[0] <= '0' || gid[0] >= '9'))
X		grent.gr_name = gid;
X	else
X		grent.gr_name = name;
X
X	grent.gr_passwd = "!";
X	grent.gr_gid = i;
X	members[0] = name;
X	members[1] = (char *) 0;
X	grent.gr_mem = members;
X
X	*ngid = grent.gr_gid;
X	return ! gr_update (&grent);
X}
X
X/*
X * add_user - create a new user ID
X */
X
Xadd_user (name, uid, nuid, gid)
Xchar	*name;
Xchar	*uid;
XUID_T	*nuid;
XGID_T	gid;
X{
X	struct	passwd	*pwd;
X	struct	passwd	pwent;
X	UID_T	i;
X
X	/*
X	 * The first guess for the UID is either the numerical UID
X	 * that the caller provided, or the next available UID.
X	 */
X
X	if (uid[0] >= '0' && uid[0] <= '9') {
X		i = atoi (uid);
X	} else if (uid[0] && (pwd = pw_locate (uid))) {
X		i = pwd->pw_uid;
X	} else {
X		i = 100;
X		for (pw_rewind ();pwd = pw_next ();)
X			if (pwd->pw_uid >= i)
X				i = pwd->pw_uid + 1;
X	}
X
X	/*
X	 * I don't want to fill in the entire password structure
X	 * members JUST YET, since there is still more data to be
X	 * added.  So, I fill in the parts that I have.
X	 */
X
X	pwent.pw_name = name;
X	pwent.pw_passwd = "!";
X#ifdef	ATT_AGE
X	pwent.pw_age = "";
X#endif
X#ifdef	ATT_COMMENT
X	pwent.pw_comment = "";
X#endif
X#ifdef	BSD_QUOTAS
X	pwent.pw_quota = 0;
X#endif
X	pwent.pw_uid = i;
X	pwent.pw_gid = gid;
X	pwent.pw_gecos = "";
X	pwent.pw_dir = "";
X	pwent.pw_shell = "";
X
X	*nuid = i;
X	return ! pw_update (&pwent);
X}
X
X/*
X * add_passwd - add or update the encrypted password
X */
X
Xadd_passwd (pwd, passwd)
Xstruct	passwd	*pwd;
Xchar	*passwd;
X{
X#ifdef	SHADOWPWD
X	struct	spwd	*sp;
X	struct	spwd	spent;
X#endif
X	static	char	newage[5];
X	extern	char	*l64a();
X
X	/*
X	 * In the case of regular password files, this is real
X	 * easy - pwd points to the entry in the password file.
X	 * Shadow files are harder since there are zillions of
X	 * things to do ...
X	 */
X
X#ifndef	SHADOWPWD
X	pwd->pw_passwd = pw_encrypt (passwd, (char *) 0);
X#ifdef	ATT_AGE
X	if (strlen (pwd->pw_age) == 4) {
X		strcpy (newage, pwd->pw_age);
X		strcpy (newage + 2,
X			l64a (time ((long *) 0) / (7L*24L*3600L)));
X		pwd->pw_age = newage;
X	}
X#endif	/* ATT_AGE */
X	return 0;
X#else
X
X	/*
X	 * Do the first and easiest shadow file case.  The user
X	 * already exists in the shadow password file.
X	 */
X
X	if (sp = spw_locate (pwd->pw_name)) {
X		spent = *sp;
X		spent.sp_pwdp = pw_encrypt (passwd, (char *) 0);
X		return ! spw_update (&spent);
X	}
X
X	/*
X	 * Pick the next easiest case - the user has an encrypted
X	 * password which isn't equal to "!".  The password was set
X	 * to "!" earlier when the entry was created, so this user
X	 * would have to have had the password set someplace else.
X	 */
X
X	if (strcmp (pwd->pw_passwd, "!") != 0) {
X		pwd->pw_passwd = pw_encrypt (passwd, (char *) 0);
X#ifdef	ATT_AGE
X		if (strlen (pwd->pw_age) == 4) {
X			strcpy (newage, pwd->pw_age);
X			strcpy (newage + 2,
X				l64a (time ((long *) 0) / (7L*24L*3600L)));
X			pwd->pw_age = newage;
X		}
X#endif	/* ATT_AGE */
X		return 0;
X	}
X
X	/*
X	 * Now the really hard case - I need to create an entirely
X	 * shadow password file entry.
X	 */
X
X	spent.sp_namp = pwd->pw_name;
X	spent.sp_pwdp = pw_encrypt (passwd, (char *) 0);
X	spent.sp_lstchg = time ((long *) 0) / (24L*3600L);
X	spent.sp_min = getdef_num("PASS_MIN_DAYS", 0);
X					/* 10000 is infinity this week */
X	spent.sp_max = getdef_num("PASS_MAX_DAYS", 10000);
X	spent.sp_warn = getdef_num("PASS_WARN_AGE", -1);
X	spent.sp_inact = -1;
X	spent.sp_expire = -1;
X	spent.sp_flag = -1;
X
X	return ! spw_update (&spent);
X#endif
X}
X
Xmain (argc, argv)
Xint	argc;
Xchar	**argv;
X{
X	char	buf[BUFSIZ];
X	char	*fields[8];
X	int	nfields;
X	char	*cp;
X#ifdef	SHADOWPWD
X	struct	spwd	*spw_locate();
X#endif
X	struct	passwd	*pw;
X	struct	passwd	newpw;
X	struct	passwd	*pw_locate();
X	int	errors = 0;
X	int	line = 0;
X	UID_T	uid;
X	GID_T	gid;
X	int	i;
X
X	if (Prog = strrchr (argv[0], '/'))
X		Prog++;
X	else
X		Prog = argv[0];
X
X	if (argc > 1 && argv[1][0] == '-')
X		usage ();
X
X	if (argc == 2) {
X		if (! freopen (argv[1], "r", stdin)) {
X			sprintf (buf, "%s: %s", Prog, argv[1]);
X			perror (buf);
X			exit (1);
X		}
X	}
X
X	/*
X	 * Lock the password files and open them for update.  This will
X	 * bring all of the entries into memory where they may be
X	 * searched for an modified, or new entries added.  The password
X	 * file is the key - if it gets locked, assume the others can
X	 * be locked right away.
X	 */
X
X	for (i = 0;i < 30;i++) {
X		if (pw_lock ())
X			break;
X	}
X	if (i == 30) {
X		fprintf (stderr, "%s: can't lock /etc/passwd.\n", Prog);
X		exit (1);
X	}
X#ifdef	SHADOWPWD
X	if (! spw_lock () || ! gr_lock ())
X#else
X	if (! gr_lock ())
X#endif
X	{
X		fprintf (stderr, "%s: can't lock files, try again later\n",
X			Prog);
X		(void) pw_unlock ();
X#ifdef	SHADOWPWD
X		(void) spw_unlock ();
X#endif
X		exit (1);
X	}
X#ifdef	SHADOWPWD
X	if (! pw_open (O_RDWR) || ! spw_open (O_RDWR) || ! gr_open (O_RDWR))
X#else
X	if (! pw_open (O_RDWR) || ! gr_open (O_RDWR))
X#endif
X	{
X		fprintf (stderr, "%s: can't open files\n", Prog);
X		(void) pw_unlock ();
X#ifdef	SHADOWPWD
X		(void) spw_unlock ();
X#endif
X		(void) gr_unlock ();
X		exit (1);
X	}
X
X	/*
X	 * Read each line.  The line has the same format as a password
X	 * file entry, except that certain fields are not contrained to
X	 * be numerical values.  If a group ID is entered which does
X	 * not already exist, an attempt is made to allocate the same
X	 * group ID as the numerical user ID.  Should that fail, the
X	 * next available group ID over 100 is allocated.  The pw_gid
X	 * field will be updated with that value.
X	 */
X
X	while (fgets (buf, sizeof buf, stdin) != (char *) 0) {
X		line++;
X		if (cp = strrchr (buf, '\n')) {
X			*cp = '\0';
X		} else {
X			fprintf (stderr, "%s: line %d: line too long\n",
X				Prog, line);
X			errors++;
X			continue;
X		}
X
X		/*
X		 * Break the string into fields and screw around with
X		 * them.  There MUST be 7 colon separated fields,
X		 * although the values aren't that particular.
X		 */
X
X		for (cp = buf, nfields = 0;nfields < 7;nfields++) {
X			fields[nfields] = cp;
X			if (cp = strchr (cp, ':'))
X				*cp++ = '\0';
X			else
X				break;
X		}
X		if (nfields != 6) {
X			fprintf (stderr, "%s: line %d: invalid line\n",
X				Prog, line);
X			continue;
X		}
X
X		/*
X		 * Now the fields are processed one by one.  The first
X		 * field to be processed is the group name.  A new
X		 * group will be created if the group name is non-numeric
X		 * and does not already exist.  The named user will be
X		 * the only member.  If there is no named group to be a
X		 * member of, the UID will be figured out and that value
X		 * will be a candidate for a new group, if that group ID
X		 * exists, a whole new group ID will be made up.
X		 */
X		
X		if (! (pw = pw_locate (fields[0])) &&
X			add_group (fields[0], fields[3], &gid)) {
X			fprintf (stderr, "%s: %d: can't create GID\n",
X				Prog, line);
X			errors++;
X			continue;
X		}
X
X		/*
X		 * Now we work on the user ID.  It has to be specified
X		 * either as a numerical value, or left blank.  If it
X		 * is a numerical value, that value will be used, otherwise
X		 * the next available user ID is computed and used.  After
X		 * this there will at least be a (struct passwd) for the
X		 * user.
X		 */
X
X		if (! pw && add_user (fields[0], fields[2], &uid, gid)) {
X			fprintf (stderr, "%s: line %d: can't create UID\n",
X				Prog, line);
X			errors++;
X			continue;
X		}
X
X		/*
X		 * The password, gecos field, directory, and shell fields
X		 * all come next.
X		 */
X
X		if (! (pw = pw_locate (fields[0]))) {
X			fprintf (stderr, "%s: line %d: cannot find user %s\n",
X				Prog, line, fields[0]);
X			errors++;
X			continue;
X		}
X		newpw = *pw;
X
X		if (add_passwd (&newpw, fields[1])) {
X			fprintf (stderr, "%s: line %d: can't update password\n",
X				Prog, line);
X			errors++;
X			continue;
X		}
X		if (fields[4][0])
X			newpw.pw_gecos = fields[4];
X
X		if (fields[5][0])
X			newpw.pw_dir = fields[5];
X
X		if (fields[6][0])
X			newpw.pw_shell = fields[6];
X
X		if (newpw.pw_dir[0] && access (newpw.pw_dir, 0)) {
X			if (mkdir (newpw.pw_dir,
X					0777 & ~getdef_num("UMASK", 0)))
X				fprintf (stderr, "%s: line %d: mkdir failed\n",
X					Prog, line);
X			else if (chown (newpw.pw_dir,
X					newpw.pw_uid, newpw.pw_gid))
X				fprintf (stderr, "%s: line %d: chown failed\n",
X					Prog, line);
X		}
X
X		/*
X		 * Update the password entry with the new changes made.
X		 */
X
X		if (! pw_update (&newpw)) {
X			fprintf (stderr, "%s: line %d: can't update entry\n",
X				Prog, line);
X			errors++;
X			continue;
X		}
X	}
X
X	/*
X	 * Any detected errors will cause the entire set of changes
X	 * to be aborted.  Unlocking the password file will cause
X	 * all of the changes to be ignored.  Otherwise the file is
X	 * closed, causing the changes to be written out all at
X	 * once, and then unlocked afterwards.
X	 */
X
X	if (errors) {
X		fprintf (stderr, "%s: error detected, changes ignored\n", Prog);
X		(void) gr_unlock ();
X#ifdef	SHADOWPWD
X		(void) spw_unlock ();
X#endif
X		(void) pw_unlock ();
X		exit (1);
X	}
X#ifdef	SHADOWPWD
X	if (! pw_close () || ! spw_close () || ! gr_close ())
X#else
X	if (! pw_close () || ! gr_close ())
X#endif
X	{
X		fprintf (stderr, "%s: error updating files\n", Prog);
X		(void) gr_unlock ();
X#ifdef	SHADOWPWD
X		(void) spw_unlock ();
X#endif
X		(void) pw_unlock ();
X		exit (1);
X	}
X	(void) gr_unlock ();
X#ifdef	SHADOWPWD
X	(void) spw_unlock ();
X#endif
X	(void) pw_unlock ();
X
X	exit (0);
X	/*NOTREACHED*/
X}
END_OF_FILE
  if test 13274 -ne `wc -c <'newusers.c'`; then
    echo shar: \"'newusers.c'\" unpacked with wrong size!
  fi
  # end of 'newusers.c'
fi
echo shar: End of archive 5 \(of 14\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
