Newsgroups: comp.sources.misc
From: jfh@rpp386.cactus.org (John F. Haugh II)
Subject: v38i130:  shadow - Shadow Password Suite, v3.3, Part11/14
Message-ID: <1993Aug14.192617.9824@sparky.sterling.com>
X-Md4-Signature: 49f1a5de77c63412d1599e63f55266e8
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sat, 14 Aug 1993 19:26:17 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jfh@rpp386.cactus.org (John F. Haugh II)
Posting-number: Volume 38, Issue 130
Archive-name: shadow/part11
Environment: UNIX
Supersedes: shadow: Volume 26, Issue 54-64

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  chage.1 config.h config.h.sun4 config.h.svr4 getpass.c
#   grdbm.c gshadow.c id.c login.1 obscure.c pwconv.c shadow.3
#   usermod.1
# Wrapped by kent@sparky on Sat Aug 14 14:11:41 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 14)."'
if test -f 'chage.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chage.1'\"
else
  echo shar: Extracting \"'chage.1'\" \(3437 characters\)
  sed "s/^X//" >'chage.1' <<'END_OF_FILE'
X.\" Copyright 1990, John F. Haugh II
X.\" All rights reserved.
X.\"
X.\" Use, duplication, and disclosure prohibited without
X.\" the express written permission of the author.
X.\"
X.\"	@(#)chage.1	3.2	10:04:46	27 Mar 1992
X.\"
X.TH CHAGE 1
X.SH NAME
Xchage \- change user password expirate information
X.SH SYNOPSIS
X\fBchage\fR [ \fB-m \fImindays\fR ] [ \fB-M \fImaxdays\fR ]
X[ \fB-d \fIlastday\fR ] [ \fB-I \fIinactive\fR ]
X[ \fB-E \fIexpiredate\fR ] [ \fB-W \fIwarndays\fR ] \fIuser\fR
X.sp 1
X\fBchage\fR -l \fIuser\fR
X.SH DESCRIPTION
X\fIchage\f changes the number of days between password changes and the
Xdate of the last password change.
XThis information is used by the system to determine when a user must
Xchange her password.
XThe \fIchage\f command is restricted to the root user, except for the
X\fB-l\fR option, which may be used by an unprivileged user to determine
Xwhen her password or account is due to expire.
X.PP
XWith the \fB-m\fR option, the value of \fImindays\f is the minimum number
Xof days between password changes.
XA value of zero for this field indicates that the user may change
Xher password at any time.
X.PP
XWith the \fB-M\fR option, the value of \fImaxdays\f is the maximum number
Xof days during which a password is valid.
XWhen \fImaxdays\fR plus \fIlastday\fR is less than the current day,
Xthe user will be required to change her password before being
Xable to use her account.
XThis occurance can be planned for in advance by use of the \fB-W\fR option,
Xwhich provides the user with advance warning.
X.PP
XWith the \fB-d\fR option, the value of \fIlastday\f is the number of days
Xsince January 1st, 1970 when the password was last changed.
XThe date may also be expressed in the format MM/DD/YY (or the format more
Xcommonly used in your area).
X.PP
XThe \fB-E\fR option is used to set a date on which the user's account will
Xno longer be accessible.
XThe \fIexpiredate\fR option is the number of days since January 1, 1970 on
Xwhich the accounted is locked.
XThe date may also be expressed in the format MM/DD/YY (or the format more
Xcommonly used in your area).
XA user whose account is locked must contact the system administrator before
Xbeing able to use the system again.
X.PP
XThe \fB-I\fR option is used to set the number of days of inactivity after
Xa password has expired before the account is locked.
XA user whose account is locked must contact the system administrator before
Xbeing able to use the system again.
XThe \fIinactive\fR option is the number of days of inactivity. A value of
X0 disables this feature.
X.PP
XThe \fB-W\fR option is used to set the number of days of warning before a
Xpassword change is required.
XThe \fIwarndays\fR option is the number of days prior to the password
Xexpiring that a user will be warned her password is about to expire.
X.PP
XAll of the above values are stored exactly as days when the shadow
Xpassword file is used, but are converted to and from weeks when the
Xstandard password file is used.
XBecause of this conversion, rounding errors may result.
X.PP
XIf none of the options are selected, \fIchage\f operates in an interactive
Xfashion, prompting the user with the current values for all of the fields.
XEnter the new value to change the field, or leave the line blank to use
Xthe current value.
XThe current value is displayed between a pair of \fB[ ]\f marks.
X.SH Files
X/etc/passwd \- user account information
X.br
X/etc/shadow \- shadow user account information
X.SH See Also
Xpasswd(4),
Xshadow(4)
END_OF_FILE
  if test 3437 -ne `wc -c <'chage.1'`; then
    echo shar: \"'chage.1'\" unpacked with wrong size!
  fi
  # end of 'chage.1'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
  echo shar: Extracting \"'config.h'\" \(5064 characters\)
  sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X/*
X * Configuration file for login.
X *
X *	@(#)config.h	3.16.1.3	17:52:38	09 May 1993
X */
X
X
X/*
X * Pathname to the run-time configuration definitions file.
X */
X
X#define LOGINDEFS "/etc/login.defs"
X
X/*
X * Define SHADOWPWD to use shadow [ unreadable ] password file.
X * Release 3 has a requirement that SHADOWPWD always be defined.
X */
X
X#define	SHADOWPWD
X
X/*
X * Define AUTOSHADOW to have root always copy sp_pwdp to pw_passwd
X * for getpwuid() and getpwnam().  This provides compatibility for
X * privileged applications which are shadow-ignorant.  YOU ARE
X * ENCOURAGED TO NOT USE THIS OPTION UNLESS ABSOLUTELY NECESSARY.
X */
X
X#undef	AUTOSHADOW
X
X/*
X * Define SHADOWGRP to user shadowed group files.  This feature adds
X * the concept of a group administrator.  You MUST NOT define this
X * if you disable SHADOWPWD.
X */
X
X/* #define	SHADOWGRP /**/
X
X/*
X * Define DOUBLESIZE to use 16 character passwords
X */
X
X#define DOUBLESIZE
X
X/*
X * Define AGING if you want the password aging checks made.
X * Release 3 has a requirement that AGING always be defined.
X */
X
X#define	AGING
X
X/*
X * Pick your version of DBM.  If you define either DBM or NDBM, you must
X * define GETPWENT.  If you define NDBM you must define GETGRENT as well.
X */
X
X/* #define	DBM	/**/
X/* #define	NDBM	/**/
X
X/*
X * Define USE_SYSLOG if you want to have SYSLOG functions included in your code.
X */
X
X#define	USE_SYSLOG
X
X/*
X * Enable RLOGIN to support the "-r" and "-h" options.
X * Also enable UT_HOST if your /etc/utmp provides for a host name.
X */
X
X#define RLOGIN
X#undef UT_HOST
X
X/*
X * Define the "success" code from ruserok().  Most modern systems use 0
X * for success and -1 for failure, while certain older versions use 1
X * for success and 0 for failure.  Please check your manpage to be sure.
X */
X
X#define	RUSEROK	0
X
X/*
X * Select one of the following
X */
X
X#define DIR_XENIX	/* include <sys/ndir.h>, use (struct direct)	*/
X/* #define DIR_BSD	/* include <ndir.h>, use (struct direct)	*/
X/* #define DIR_SYSV	/* include <dirent.h>, use (struct dirent)	*/
X
X/*
X * Various system environment definitions.
X */
X
X#define	HAVE_ULIMIT	/* Define if your UNIX supports ulimit()	*/
X#undef	HAVE_RLIMIT	/* Define if your UNIX supports setrlimit()     */
X#define	GETPWENT	/* Define if you want my GETPWENT(3) routines	*/
X#define	GETGRENT	/* Define if you want my GETGRENT(3) routines	*/
X#define	NEED_AL64	/* Define if library does not include a64l()	*/
X#define	NEED_MKDIR	/* Define if system does not have mkdir()	*/
X#define	NEED_RMDIR	/* Define if system does not have rmdir()	*/
X#define	NEED_RENAME	/* Define if system does not have rename()	*/
X#define	NEED_STRSTR	/* Define if library does not include strstr()	*/
X#undef	NEED_PUTPWENT	/* Define if library does not include putpwent()*/
X#define	SIGTYPE	int	/* Type returned by signal()                    */
X
X/*
X * These definitions MUST agree with the values defined in <pwd.h>.
X */
X
X#undef	BSD_QUOTA	/* the pw_quota field exists */
X#define	ATT_AGE		/* the pw_age field exists */
X#define	ATT_COMMENT	/* the pw_comment field exists */
X
X#define	UID_T	uid_t	/* set to be the type of UID's */
X#define	GID_T	gid_t	/* set to be the type of GID's */
X
X#ifndef	UID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	UID_T	uid_t
X#else
X#define	UID_T	int
X#endif
X#endif
X
X#ifndef	GID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	GID_T	gid_t
X#else
X#define	GID_T	int
X#endif
X#endif
X
X/*
X * Define NDEBUG for production versions
X */
X
X#define	NDEBUG
X
X/*
X * Define PWDFILE and GRPFILE to the names of the password and
X * group files.
X */
X
X#define	PWDFILE	"/etc/passwd"
X#define	GRPFILE	"/etc/group"
X
X/*
X * The structure of the utmp file.  There are two kinds of UTMP files,
X * "BSD" and "USG".  "BSD" has no PID or type information, "USG" does.
X * If you define neither of these, the type will be defaulted by using
X * BSD, SUN, SYS3 and USG defines.
X */
X
X#define USG_UTMP	/**/
X/* #define BSD_UTMP	/**/
X
X#if !defined(USG_UTMP) && !defined(BSD_UTMP)
X#if defined(BSD) || defined(SYS3) || defined(SUN)
X#define	BSD_UTMP
X#else
X#define USG_UTMP
X#endif	/* BSD || SYS3 || SUN */
X#endif /* !USG_UTMP || !BSD_UTMP */
X
X/*
X * Telinit program.  If your system uses /etc/telinit to change run
X * level, define TELINIT and then define the RUNLEVEL macro to be the
X * run-level to switch INIT to.  This is used by sulogin to change
X * from single user to multi-user mode.
X */
X
X#define	TELINIT		/**/
X#define	RUNLEVEL	"2"	/**/
X
X/*
X * Crontab and atrm.  If your system can "crontab -r -u <user>", define
X * HAS_CRONTAB.  If your system can "atrm <user>", define HAS_ATRM.
X */
X
X#undef	HAS_CRONTAB
X#undef	HAS_ATRM
END_OF_FILE
  if test 5064 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
  fi
  # end of 'config.h'
fi
if test -f 'config.h.sun4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.sun4'\"
else
  echo shar: Extracting \"'config.h.sun4'\" \(3976 characters\)
  sed "s/^X//" >'config.h.sun4' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X */
X
X/*
X * Configuration file for login.
X *
X *	@(#)config.h.sun4	3.3	20:39:30	23 May 1993 (SunOS 4.1.1)
X */
X
X
X/*
X * Pathname to the run-time configuration definitions file.
X */
X
X#define LOGINDEFS "/etc/login.defs"
X
X/*
X * Define SHADOWPWD to use shadow [ unreadable ] password file.
X * Release 3 has a requirement that SHADOWPWD always be defined.
X */
X
X#define	SHADOWPWD
X
X/*
X * Define AUTOSHADOW to have root always copy sp_pwdp to pw_passwd
X * for getpwuid() and getpwnam().  This provides compatibility for
X * privileged applications which are shadow-ignorant.  YOU ARE
X * ENCOURAGED TO NOT USE THIS OPTION UNLESS ABSOLUTELY NECESSARY.
X */
X
X#undef	AUTOSHADOW
X
X/*
X * Define SHADOWGRP to user shadowed group files.  This feature adds
X * the concept of a group administrator.
X */
X
X#define	SHADOWGRP /**/
X
X/*
X * Define DOUBLESIZE to use 16 character passwords.  Define SW_CRYPT
X * to use 80 character passwords with SecureWare[tm]'s method of
X * generating ciphertext.
X */
X
X#define DOUBLESIZE
X#undef	SW_CRYPT
X
X/*
X * Define AGING if you want the password aging checks made.
X * Release 3 has a requirement that AGING always be defined.
X */
X
X#define	AGING
X
X/*
X * Pick your version of DBM.  If you define either DBM or NDBM, you must
X * define GETPWENT.  If you define NDBM you must define GETGRENT as well.
X */
X
X/* #define	DBM	/**/
X#define	NDBM	/**/
X
X/*
X * Define USE_SYSLOG if you want to have SYSLOG functions included in your code.
X */
X
X#define	USE_SYSLOG
X
X/*
X * Enable RLOGIN to support the "-r" and "-h" options.
X * Also enable UT_HOST if your /etc/utmp provides for a host name.
X */
X
X#define RLOGIN
X#define UT_HOST
X
X/*
X * Define the "success" code from ruserok().  Most modern systems use 0
X * for success and -1 for failure, while certain older versions use 1
X * for success and 0 for failure.  Please check your manpage to be sure.
X */
X
X#define       RUSEROK 0
X
X/*
X * Select one of the following
X */
X
X/* #define DIR_XENIX	/* include <sys/ndir.h>, use (struct direct)	*/
X/* #define DIR_BSD	/* include <ndir.h>, use (struct direct)	*/
X#define DIR_SYSV	/* include <dirent.h>, use (struct dirent)	*/
X
X/*
X * Various system environment definitions.
X */
X
X#define	HAVE_ULIMIT	/* Define if your UNIX supports ulimit()	*/
X#define	GETPWENT	/* Define if you want my GETPWENT(3) routines	*/
X#define	GETGRENT	/* Define if you want my GETGRENT(3) routines	*/
X#undef	NEED_AL64	/* Define if library does not include a64l()	*/
X#undef	NEED_MKDIR	/* Define if system does not have mkdir()	*/
X#undef	NEED_RMDIR	/* Define if system does not have rmdir()	*/
X#undef	NEED_RENAME	/* Define if system does not have rename()	*/
X#define	NEED_STRSTR	/* Define if library does not include strstr()	*/
X#undef	NEED_PUTPWENT	/* Define if library does not include putpwent()*/
X#define	SIGTYPE	void	/* Type returned by signal()                    */
X
X/*
X * These definitions MUST agree with the values defined in <pwd.h>.
X */
X
X#undef	BSD_QUOTA	/* the pw_quota field exists */
X#define	ATT_AGE		/* the pw_age field exists */
X#define	ATT_COMMENT	/* the pw_comment field exists */
X
X#define	UID_T	uid_t	/* set to be the type of UID's */
X#define	GID_T	gid_t	/* set to be the type of GID's */
X
X#ifndef	UID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	UID_T	uid_t
X#else
X#define	UID_T	int
X#endif
X#endif
X
X#ifndef	GID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	GID_T	gid_t
X#else
X#define	GID_T	int
X#endif
X#endif
X
X/*
X * Define NDEBUG for production versions
X */
X
X#define	NDEBUG
X
X/*
X * Define PWDFILE and GRPFILE to the names of the password and
X * group files.
X */
X
X#define	PWDFILE	"/etc/passwd"
X#define	GRPFILE	"/etc/group"
END_OF_FILE
  if test 3976 -ne `wc -c <'config.h.sun4'`; then
    echo shar: \"'config.h.sun4'\" unpacked with wrong size!
  fi
  # end of 'config.h.sun4'
fi
if test -f 'config.h.svr4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h.svr4'\"
else
  echo shar: Extracting \"'config.h.svr4'\" \(4648 characters\)
  sed "s/^X//" >'config.h.svr4' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X/*
X * Configuration file for login.
X *
X *	@(#)config.h.svr4	3.3	07:18:05	03 Jun 1993	(SVR4)
X */
X
X
X/*
X * Pathname to the run-time configuration definitions file.
X */
X
X#define LOGINDEFS "/etc/login.defs"
X
X/*
X * Define SHADOWPWD to use shadow [ unreadable ] password file.
X * Release 3 has a requirement that SHADOWPWD always be defined.
X */
X
X#define	SHADOWPWD
X
X/*
X * Define AUTOSHADOW to have root always copy sp_pwdp to pw_passwd
X * for getpwuid() and getpwnam().  This provides compatibility for
X * privileged applications which are shadow-ignorant.  YOU ARE
X * ENCOURAGED TO NOT USE THIS OPTION UNLESS ABSOLUTELY NECESSARY.
X *
X * SVR4 has always had /etc/shadow
X */
X
X#undef	AUTOSHADOW
X
X/*
X * Define SHADOWGRP to user shadowed group files.  This feature adds
X * the concept of a group administrator.
X */
X
X/* #define	SHADOWGRP	/**/
X
X/*
X * Define DOUBLESIZE to use 16 character passwords.  Define SW_CRYPT
X * to use 80 character passwords with SecureWare[tm]'s method of
X * generating ciphertext.
X */
X
X#define DOUBLESIZE
X#undef	SW_CRYPT
X
X/*
X * Define AGING if you want the password aging checks made.
X * Release 3 has a requirement that AGING always be defined.
X */
X
X#define	AGING
X
X/*
X * Pick your version of DBM.  If you define either DBM or NDBM, you must
X * define GETPWENT.  If you define NDBM you must define GETGRENT as well.
X *
X * SVR4 doesn't come with mkpasswd.
X */
X
X/* #define	DBM	/**/
X/* #define	NDBM	/**/
X
X/*
X * Define USE_SYSLOG if you want to have SYSLOG functions included in your code.
X *
X * SVR4 includes syslog()
X */
X
X#define	USE_SYSLOG
X
X/*
X * Enable RLOGIN to support the "-r" and "-h" options.
X * Don't define UT_HOST, it's in utmpx.
X */
X
X#define RLOGIN
X#undef UT_HOST
X
X/*
X * Define the "success" code from ruserok().  Most modern systems use 0
X * for success and -1 for failure, while certain older versions use 1
X * for success and 0 for failure.  Please check your manpage to be sure.
X */
X
X#define	RUSEROK	0
X
X/*
X * Use SVR4 directory functions.
X */
X
X#define DIR_SYSV	/* include <dirent.h>, use (struct dirent)	*/
X
X/*
X * Various system environment definitions.
X */
X
X#undef	HAVE_ULIMIT	/* Define if your UNIX supports ulimit()	*/
X#define	HAVE_RLIMIT	/* Define if your UNIX supports setrlimit()	*/
X#define	GETPWENT	/* Define if you want my GETPWENT(3) routines	*/
X#undef	GETGRENT	/* Define if you want my GETGRENT(3) routines	*/
X#undef	NEED_AL64	/* Define if library does not include a64l()	*/
X#undef	NEED_MKDIR	/* Define if system does not have mkdir()	*/
X#undef	NEED_RMDIR	/* Define if system does not have rmdir()	*/
X#undef	NEED_RENAME	/* Define if system does not have rename()	*/
X#undef	NEED_STRSTR	/* Define if library does not include strstr()	*/
X#undef	NEED_PUTPWENT	/* Define if library does not include putpwent()*/
X#define	SIGTYPE	void	/* Type returned by signal()                    */
X
X/*
X * These definitions MUST agree with the values defined in <pwd.h>.
X */
X
X#undef	BSD_QUOTA	/* the pw_quota field exists */
X#define	ATT_AGE		/* the pw_age field exists */
X#define	ATT_COMMENT	/* the pw_comment field exists */
X
X#define	UID_T	uid_t	/* set to be the type of UID's */
X#define	GID_T	gid_t	/* set to be the type of GID's */
X
X#ifndef	UID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	UID_T	uid_t
X#else
X#define	UID_T	int
X#endif
X#endif
X
X#ifndef	GID_T
X#if defined(SVR4) || defined(_POSIX_SOURCE)
X#define	GID_T	gid_t
X#else
X#define	GID_T	int
X#endif
X#endif
X
X/*
X * Define NDEBUG for production versions
X */
X
X#define	NDEBUG
X
X/*
X * Define PWDFILE and GRPFILE to the names of the password and
X * group files.
X */
X
X#define	PWDFILE	"/etc/passwd"
X#define	GRPFILE	"/etc/group"
X
X/*
X * This is SVR4.
X */
X
X#define	USG_UTMP
X
X/*
X * Telinit program.  If your system uses /etc/telinit to change run
X * level, define TELINIT and then define the RUNLEVEL macro to be the
X * run-level to switch INIT to.  This is used by sulogin to change
X * from single user to multi-user mode.
X */
X
X#define	TELINIT		/**/
X#define	RUNLEVEL	"2"	/**/
X
X/*
X * Crontab and atrm.  If your system can "crontab -r -u <user>", define
X * HAS_CRONTAB.  If your system can "atrm <user>", define HAS_ATRM.
X *
X * SVR4 has both of these.
X */
X
X#define	HAS_CRONTAB
X#define	HAS_ATRM
END_OF_FILE
  if test 4648 -ne `wc -c <'config.h.svr4'`; then
    echo shar: \"'config.h.svr4'\" unpacked with wrong size!
  fi
  # end of 'config.h.svr4'
fi
if test -f 'getpass.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getpass.c'\"
else
  echo shar: Extracting \"'getpass.c'\" \(3867 characters\)
  sed "s/^X//" >'getpass.c' <<'END_OF_FILE'
X/*
X * Copyright 1990, 1991, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X#include <signal.h>
X#include <stdio.h>
X#include "config.h"
X
X#ifdef	BSD
X#include <sgtty.h>
X#include <strings.h>
X#else
X#ifdef	SVR4
X#include <termios.h>
X#else
X#include <termio.h>
X#endif	/* SVR4 */
X#include <string.h>
X#endif
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)getpass.c	3.8	07:26:36	23 Apr 1993";
X#endif
X
X/*
X * limits.h may be kind enough to specify the length of a prompted
X * for password.
X */
X
X#if __STDC__ || _POSIX_SOURCE
X#include <limits.h>
X#endif
X
X/*
X * This is really a giant mess.  On the one hand, it would be nice
X * if PASS_MAX were real big so that DOUBLESIZE isn't needed.  But
X * if it is defined we must honor it because some idiot might use
X * this in a routine expecting some standard behavior.
X */
X
X#ifndef	PASS_MAX
X#ifdef	SW_CRYPT
X#define	PASS_MAX	80
X#else	/* !SW_CRYPT */
X#ifdef	DOUBLESIZE
X#define	PASS_MAX	16
X#else	/* !PASS_MAX */
X#define	PASS_MAX	8
X#endif	/* PASS_MAX */
X#endif	/* SW_CRYPT */
X#endif	/* !PASS_MAX */
X
X#ifdef	BSD
X#define	STTY(fd,termio)	stty(fd, termio)
X#define	GTTY(fd,termio) gtty(fd, termio)
X#define	TERMIO	struct	sgttyb
X#define	INDEX	index
X#else
X#ifdef	SVR4
X#define	STTY(fd,termio) ioctl(fd, TCSETS, termio)
X#define	GTTY(fd,termio) ioctl(fd, TCGETS, termio)
X#define	TERMIO	struct	termios
X#else
X#define	STTY(fd,termio) ioctl(fd, TCSETA, termio)
X#define	GTTY(fd,termio) ioctl(fd, TCGETA, termio)
X#define	TERMIO	struct	termio
X#endif
X#define	INDEX	strchr
X#endif
X
Xstatic	int	sig_caught;
X
Xstatic void
Xsig_catch ()
X{
X	sig_caught = 1;
X}
X
Xchar *
Xgetpass (prompt)
Xchar	*prompt;
X{
X	static	char	input[PASS_MAX+1];
X	char	*return_value = 0;
X	char	*cp;
X	FILE	*fp;
X	int	tty_opened = 0;
X	SIGTYPE	(*old_signal)();
X	TERMIO	new_modes;
X	TERMIO	old_modes;
X
X	/*
X	 * set a flag so the SIGINT signal can be re-sent if it
X	 * is caught
X	 */
X
X	sig_caught = 0;
X
X	/*
X	 * if /dev/tty can't be opened, getpass() needs to read
X	 * from stdin instead.
X	 */
X
X	if ((fp = fopen ("/dev/tty", "r")) == 0) {
X		fp = stdin;
X		setbuf (fp, (char *) 0);
X	} else {
X		tty_opened = 1;
X	}
X
X	/*
X	 * the current tty modes must be saved so they can be
X	 * restored later on.  echo will be turned off, except
X	 * for the newline character (BSD has to punt on this)
X	 */
X
X	if (GTTY (fileno (fp), &new_modes))
X		return 0;
X
X	old_modes = new_modes;
X	old_signal = signal (SIGINT, sig_catch);
X
X#ifdef	BSD
X	new_modes.sg_flags &= ~ECHO ;
X#else
X	new_modes.c_lflag &= ~(ECHO|ECHOE|ECHOK);
X	new_modes.c_lflag |= ECHONL;
X#endif
X
X	if (STTY (fileno (fp), &new_modes))
X		goto out;
X
X	/*
X	 * the prompt is output, and the response read without
X	 * echoing.  the trailing newline must be removed.  if
X	 * the fgets() returns an error, a NULL pointer is
X	 * returned.
X	 */
X
X	if (fputs (prompt, stdout) == EOF)
X		goto out;
X
X	(void) fflush (stdout);
X
X	if (fgets (input, sizeof input, fp) == input) {
X		if (cp = INDEX (input, '\n'))
X			*cp = '\0';
X		else
X			input[sizeof input - 1] = '\0';
X
X		return_value = input;
X#ifdef	BSD
X		putc ('\n', stdout);
X#endif
X	}
Xout:
X	/*
X	 * the old SIGINT handler is restored after the tty
X	 * modes.  then /dev/tty is closed if it was opened in
X	 * the beginning.  finally, if a signal was caught it
X	 * is sent to this process for normal processing.
X	 */
X
X	if (STTY (fileno (fp), &old_modes))
X		return_value = 0;
X
X	(void) signal (SIGINT, old_signal);
X
X	if (tty_opened)
X		(void) fclose (fp);
X
X	if (sig_caught) {
X		kill (getpid (), SIGINT);
X		return_value = 0;
X	}
X	return return_value;
X}
END_OF_FILE
  if test 3867 -ne `wc -c <'getpass.c'`; then
    echo shar: \"'getpass.c'\" unpacked with wrong size!
  fi
  # end of 'getpass.c'
fi
if test -f 'grdbm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grdbm.c'\"
else
  echo shar: Extracting \"'grdbm.c'\" \(3622 characters\)
  sed "s/^X//" >'grdbm.c' <<'END_OF_FILE'
X/*
X * Copyright 1990, 1991, John F. Haugh II
X * All rights reserved.
X *
X * Use, duplication, and disclosure prohibited without
X * the express written permission of the author.
X */
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)grdbm.c	3.3	08:44:03	12 Sep 1991";
X#endif
X
X#include <string.h>
X#include <stdio.h>
X#include <grp.h>
X#include "config.h"
X
X#ifdef	NDBM
X#include <ndbm.h>
XDBM	*gr_dbm;
X
X#define	GRP_FRAG	256
X
X/*
X * gr_dbm_update
X *
X * Updates the DBM password files, if they exist.
X */
X
Xint
Xgr_dbm_update (gr)
Xstruct	group	*gr;
X{
X	datum	key;
X	datum	content;
X	char	data[BUFSIZ*8];
X	char	grpkey[60];
X	char	*cp;
X	int	len;
X	int	i;
X	int	cnt;
X	static	int	once;
X
X	if (! once) {
X		if (! gr_dbm)
X			setgrent ();
X
X		once++;
X	}
X	if (! gr_dbm)
X		return 0;
X
X	len = gr_pack (gr, data);
X
X	if (len <= GRP_FRAG) {
X		content.dsize = len;
X		content.dptr = data;
X
X		key.dsize = strlen (gr->gr_name);
X		key.dptr = gr->gr_name;
X		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X			return 0;
X
X		key.dsize = sizeof gr->gr_gid;
X		key.dptr = (char *) &gr->gr_gid;
X		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X			return 0;
X
X	} else {
X		content.dsize = sizeof cnt;
X		content.dptr = (char *) &cnt;
X		cnt = (len + (GRP_FRAG-1)) / GRP_FRAG;
X
X		key.dsize = strlen (gr->gr_name);
X		key.dptr = gr->gr_name;
X		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X			return 0;
X
X		key.dsize = sizeof gr->gr_gid;
X		key.dptr = (char *) &gr->gr_gid;
X		if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X			return 0;
X
X		for (cp = data, i = 0;i < cnt;i++) {
X			content.dsize = len > GRP_FRAG ? GRP_FRAG:len;
X			len -= content.dsize;
X			content.dptr = cp;
X			cp += content.dsize;
X
X			key.dsize = sizeof i + strlen (gr->gr_name);
X			key.dptr = grpkey;
X			memcpy (grpkey, (char *) &i, sizeof i);
X			strcpy (grpkey + sizeof i, gr->gr_name);
X			if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X				return 0;
X
X			key.dsize = sizeof i + sizeof gr->gr_gid;
X			key.dptr = grpkey;
X			memcpy (grpkey, (char *) &i, sizeof i);
X			memcpy (grpkey + sizeof i, (char *) &gr->gr_gid,
X				sizeof gr->gr_gid);
X			if (dbm_store (gr_dbm, key, content, DBM_REPLACE))
X				return 0;
X		}
X	}
X	return 1;
X}
X
X/*
X * gr_dbm_remove
X *
X * Deletes the DBM group file entries, if they exist.
X */
X
Xint
Xgr_dbm_remove (gr)
Xstruct	group	*gr;
X{
X	datum	key;
X	datum	content;
X	char	grpkey[60];
X	int	i;
X	int	cnt;
X	int	errors = 0;
X	static	int	once;
X
X	if (! once) {
X		if (! gr_dbm)
X			setgrent ();
X
X		once++;
X	}
X	if (! gr_dbm)
X		return 0;
X
X	key.dsize = strlen (gr->gr_name);
X	key.dptr = (char *) gr->gr_name;
X	content = dbm_fetch (gr_dbm, key);
X	if (content.dptr == 0)
X		++errors;
X	else {
X		if (content.dsize == sizeof (int)) {
X			memcpy ((char *) &cnt, content.dptr, sizeof cnt);
X
X			for (i = 0;i < cnt;i++) {
X				key.dsize = sizeof i + strlen (gr->gr_name);
X				key.dptr = grpkey;
X				memcpy (grpkey, (char *) &i, sizeof i);
X				strcpy (grpkey + sizeof i, gr->gr_name);
X				if (dbm_delete (gr_dbm, key))
X					++errors;
X			}
X		} else {
X			if (dbm_delete (gr_dbm, key))
X				++errors;
X		}
X	}
X	key.dsize = sizeof gr->gr_gid;
X	key.dptr = (char *) &gr->gr_gid;
X	content = dbm_fetch (gr_dbm, key);
X	if (content.dptr == 0)
X		++errors;
X	else {
X		if (content.dsize == sizeof (int)) {
X			memcpy ((char *) &cnt, content.dptr, sizeof cnt);
X
X			for (i = 0;i < cnt;i++) {
X				key.dsize = sizeof i + sizeof gr->gr_gid;
X				key.dptr = grpkey;
X				memcpy (grpkey, (char *) &i, sizeof i);
X				memcpy (grpkey + sizeof i, (char *) &gr->gr_gid,
X					sizeof gr->gr_gid);
X
X				if (dbm_delete (gr_dbm, key))
X					++errors;
X			}
X		} else {
X			if (dbm_delete (gr_dbm, key))
X				++errors;
X		}
X	}
X	return errors ? 0:1;
X}
X#endif
END_OF_FILE
  if test 3622 -ne `wc -c <'grdbm.c'`; then
    echo shar: \"'grdbm.c'\" unpacked with wrong size!
  fi
  # end of 'grdbm.c'
fi
if test -f 'gshadow.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gshadow.c'\"
else
  echo shar: Extracting \"'gshadow.c'\" \(4977 characters\)
  sed "s/^X//" >'gshadow.c' <<'END_OF_FILE'
X/*
X * Copyright 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X#include "config.h"
X
X#ifdef	SHADOWGRP
X
X#include "shadow.h"
X#include <stdio.h>
X#ifndef	BSD
X#include <string.h>
X#include <memory.h>
X#else
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#endif
X
X#ifdef	NDBM
X#include <ndbm.h>
X#include <fcntl.h>
XDBM	*sg_dbm;
Xint	sg_dbm_mode = -1;
Xstatic	int	dbmopened;
Xstatic	int	dbmerror;
X#endif
X
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)gshadow.c	3.9	08:57:38	10 Jun 1993";
X#endif
X
X#define	MAXMEM	1024
X
Xstatic	FILE	*shadow;
Xstatic	char	*sgrpfile = "/etc/gshadow";
Xstatic	char	sgrbuf[BUFSIZ*4];
Xstatic	char	*members[MAXMEM+1];
Xstatic	char	*admins[MAXMEM+1];
Xstatic	struct	sgrp	sgroup;
X
Xextern	char	*fgetsx();
Xextern	int	fputsx();
X
X#define	FIELDS	4
X
Xstatic char **
Xlist (s, l)
Xchar	*s;
Xchar	**l;
X{
X	int	nmembers = 0;
X
X	while (s && *s) {
X		l[nmembers++] = s;
X		if (s = strchr (s, ','))
X			*s++ = '\0';
X	}
X	l[nmembers] = (char *) 0;
X	return l;
X}
X
Xvoid
Xsetsgent ()
X{
X#ifdef	NDBM
X	int	mode;
X#endif	/* NDBM */
X
X	if (shadow)
X		rewind (shadow);
X	else
X		shadow = fopen (GSHADOW, "r");
X
X	/*
X	 * Attempt to open the DBM files if they have never been opened
X	 * and an error has never been returned.
X	 */
X
X#ifdef NDBM
X	if (! dbmerror && ! dbmopened) {
X		char	dbmfiles[BUFSIZ];
X
X		strcpy (dbmfiles, sgrpfile);
X		strcat (dbmfiles, ".pag");
X
X		if (sg_dbm_mode == -1)
X			mode = O_RDWR;
X		else
X			mode = (sg_dbm_mode == O_RDWR) ? O_RDWR:O_RDONLY;
X
X		if (access (dbmfiles, 0) ||
X			(! (sg_dbm = dbm_open (sgrpfile, mode, 0))))
X			dbmerror = 1;
X		else
X			dbmopened = 1;
X	}
X#endif	/* NDBM */
X}
X
Xvoid
Xendsgent ()
X{
X	if (shadow)
X		(void) fclose (shadow);
X
X	shadow = (FILE *) 0;
X#ifdef	NDBM
X	if (dbmopened && sg_dbm) {
X		dbm_close (sg_dbm);
X		dbmopened = 0;
X		sg_dbm = 0;
X	}
X#endif
X}
X
Xstruct sgrp *
Xsgetsgent (string)
Xchar	*string;
X{
X	char	*fields[FIELDS];
X	char	*cp;
X	int	atoi ();
X	long	atol ();
X	int	i;
X
X	strncpy (sgrbuf, string, (int) sizeof sgrbuf - 1);
X	sgrbuf[sizeof sgrbuf - 1] = '\0';
X
X	if (cp = strrchr (sgrbuf, '\n'))
X		*cp = '\0';
X
X	/*
X	 * There should be exactly 4 colon separated fields.  Find
X	 * all 4 of them and save the starting addresses in fields[].
X	 */
X
X	for (cp = sgrbuf, i = 0;i < FIELDS && cp;i++) {
X		fields[i] = cp;
X		if (cp = strchr (cp, ':'))
X			*cp++ = '\0';
X	}
X
X	/*
X	 * If there was an extra field somehow, or perhaps not enough,
X	 * the line is invalid.
X	 */
X
X	if (cp || i != FIELDS)
X		return 0;
X
X	sgroup.sg_name = fields[0];
X	sgroup.sg_passwd = fields[1];
X	sgroup.sg_adm = list (fields[2], admins);
X	sgroup.sg_mem = list (fields[3], members);
X
X	return &sgroup;
X}
X
Xstruct sgrp
X*fgetsgent (fp)
XFILE	*fp;
X{
X	char	buf[sizeof sgrbuf];
X
X	if (! fp)
X		return (0);
X
X	if (fgetsx (buf, sizeof buf, fp) == (char *) 0)
X		return (0);
X
X	return sgetsgent (buf);
X}
X
Xstruct sgrp
X*getsgent ()
X{
X	if (! shadow)
X		setsgent ();
X
X	return (fgetsgent (shadow));
X}
X
Xstruct sgrp *
Xgetsgnam (name)
Xchar	*name;
X{
X	struct	sgrp	*sgrp;
X#ifdef NDBM
X	datum	key;
X	datum	content;
X#endif
X
X	setsgent ();
X
X#ifdef NDBM
X
X	/*
X	 * If the DBM file are now open, create a key for this group and
X	 * try to fetch the entry from the database.  A matching record
X	 * will be unpacked into a static structure and returned to
X	 * the user.
X	 */
X
X	if (dbmopened) {
X		key.dsize = strlen (name);
X		key.dptr = name;
X
X		content = dbm_fetch (sg_dbm, key);
X		if (content.dptr != 0) {
X			memcpy (sgrbuf, content.dptr, content.dsize);
X			sgroup.sg_mem = members;
X			sgroup.sg_adm = admins;
X			sgr_unpack (sgrbuf, content.dsize, &sgroup);
X			return &sgroup;
X		}
X	}
X#endif
X	while ((sgrp = getsgent ()) != (struct sgrp *) 0) {
X		if (strcmp (name, sgrp->sg_name) == 0)
X			return (sgrp);
X	}
X	return (0);
X}
X
Xint
Xputsgent (sgrp, fp)
Xstruct	sgrp	*sgrp;
XFILE	*fp;
X{
X	char	buf[sizeof sgrbuf];
X	char	*cp = buf;
X	int	i;
X
X	if (! fp || ! sgrp)
X		return -1;
X
X	/*
X	 * Copy the group name and passwd.
X	 */
X
X	strcpy (cp, sgrp->sg_name);
X	cp += strlen (cp);
X	*cp++ = ':';
X
X	strcpy (cp, sgrp->sg_passwd);
X	cp += strlen (cp);
X	*cp++ = ':';
X
X	/*
X	 * Copy the administrators, separating each from the other
X	 * with a ",".
X	 */
X
X	for (i = 0;sgrp->sg_adm[i];i++) {
X		if (i > 0)
X			*cp++ = ',';
X
X		strcpy (cp, sgrp->sg_adm[i]);
X		cp += strlen (cp);
X	}
X	*cp++ = ':';
X
X	/*
X	 * Now do likewise with the group members.
X	 */
X
X	for (i = 0;sgrp->sg_mem[i];i++) {
X		if (i > 0)
X			*cp++ = ',';
X
X		strcpy (cp, sgrp->sg_mem[i]);
X		cp += strlen (cp);
X	}
X	*cp++ = '\n';
X	*cp = '\0';
X
X	/*
X	 * Output using the function which understands the line
X	 * continuation conventions.
X	 */
X
X	return fputsx (buf, fp);
X}
X
X#endif	/* SHADOWGRP */
END_OF_FILE
  if test 4977 -ne `wc -c <'gshadow.c'`; then
    echo shar: \"'gshadow.c'\" unpacked with wrong size!
  fi
  # end of 'gshadow.c'
fi
if test -f 'id.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'id.c'\"
else
  echo shar: Extracting \"'id.c'\" \(3386 characters\)
  sed "s/^X//" >'id.c' <<'END_OF_FILE'
X/*
X * Copyright 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X/*
X * id - print current process user identification information
X *
X *	Print the current process identifiers.  This includes the
X *	UID, GID, effective-UID and effective-GID.  Optionally print
X *	the concurrent group set if the current system supports it.
X */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <grp.h>
X#include "config.h"
X#include "pwd.h"
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)id.c	3.7	07:17:31	03 Jun 1993";
X#endif
X
Xusage ()
X{
X#if NGROUPS > 0
X	fprintf (stderr, "usage: id [ -a ]\n");
X#else
X	fprintf (stderr, "usage: id\n");
X#endif
X	exit (1);
X}
X
X/*ARGSUSED*/
Xmain (argc, argv)
Xint	argc;
Xchar	**argv;
X{
X	int	id;
X#if NGROUPS > 0
X#if NGROUPS > 100
X	GID_T	*groups;
X#else
X	GID_T	groups[NGROUPS];
X#endif
X	int	ngroups;
X	int	aflg = 0;
X#endif
X	struct	passwd	*pw,
X			*getpwuid();
X	struct	group	*gr,
X			*getgrgid();
X
X#if NGROUPS > 0
X	/*
X	 * See if the -a flag has been given to print out the
X	 * concurrent group set.
X	 */
X
X	if (argc > 1) {
X		if (argc > 2 || strcmp (argv[1], "-a"))
X			usage ();
X		else
X			aflg = 1;
X	}
X#else
X	if (argc > 1)
X		usage ();
X#endif
X
X	/*
X	 * Print out the real user ID and group ID.  If the user or
X	 * group does not exist, just give the numerical value.
X	 */
X
X	if (pw = getpwuid (id = getuid ()))
X		printf ("uid=%d(%s)", id, pw->pw_name);
X	else
X		printf ("uid=%d", id);
X
X	if (gr = getgrgid (id = getgid ()))
X		printf (" gid=%d(%s)", id, gr->gr_name);
X	else
X		printf (" gid=%d", id);
X
X	/*
X	 * Print out the effective user ID and group ID if they are
X	 * different from the real values.
X	 */
X
X	if (getuid () != geteuid ()) {
X		if (pw = getpwuid (id = geteuid ()))
X			printf (" euid=%d(%s)", id, pw->pw_name);
X		else
X			printf (" euid=%d", id);
X	}
X	if (getgid () != getegid ()) {
X		if (gr = getgrgid (id = getegid ()))
X			printf (" egid=%d(%s)", id, gr->gr_name);
X		else
X			printf (" egid=%d", id);
X	}
X#if NGROUPS > 0
X
X	/*
X	 * Print out the concurrent group set if the user has requested
X	 * it.  The group numbers will be printed followed by their
X	 * names.
X	 */
X
X	if (aflg && (ngroups = getgroups (0, 0)) != -1) {
X		int	i;
X
X#if NGROUPS > 100
X		/*
X		 * The size of the group set is determined so an array
X		 * large enough to hold it can be allocated.
X		 */
X
X		if (groups = (int *) malloc (ngroups * sizeof *groups)) {
X			putchar ('\n');
X			perror ("out of memory");
X			exit (1);
X		}
X#endif
X		/*
X		 * Start off the group message.  It will be of the format
X		 *
X		 *	groups=###(aaa),###(aaa),###(aaa)
X		 *
X		 * where "###" is a numerical value and "aaa" is the
X		 * corresponding name for each respective numerical value.
X		 */
X
X		getgroups (ngroups, groups);
X		printf (" groups=");
X		for (i = 0;i < ngroups;i++) {
X			if (i)
X				putchar (',');
X
X			if (gr = getgrgid (groups[i]))
X				printf ("%d(%s)", (int) groups[i], gr->gr_name);
X			else
X				printf ("%d", (int) groups[i]);
X		}
X	}
X#endif
X
X	/*
X	 * Finish off the line.
X	 */
X
X	putchar ('\n');
X	exit (0);
X	/*NOTREACHED*/
X}
END_OF_FILE
  if test 3386 -ne `wc -c <'id.c'`; then
    echo shar: \"'id.c'\" unpacked with wrong size!
  fi
  # end of 'id.c'
fi
if test -f 'login.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'login.1'\"
else
  echo shar: Extracting \"'login.1'\" \(3347 characters\)
  sed "s/^X//" >'login.1' <<'END_OF_FILE'
X.\" Copyright 1989, 1990, John F. Haugh II
X.\" All rights reserved.
X.\"
X.\" Use, duplication, and disclosure prohibited without
X.\" the express written permission of the author.
X.\"
X.\"	@(#)login.1	3.1	09:34:21	21 Nov 1990
X.\"
X.TH LOGIN 1
X.SH NAME
Xlogin \- Begin session on the system
X.SH SYNOPSIS
X.B login
X[ username [ environmental-variables ] ]
X.SH DESCRIPTION
X.I login
Xis used to establish a new session with the system.
XIt is normally invoked automatically by responding to the
X.B login:
Xprompt on the user\'s terminal.
X.I login
Xmay be special to the shell and may not be invoked as a sub-process.
XTypically,
X.I login
Xis treated by the shell as \fBexec login\fR which causes the user
Xto exit from the current shell.
XAttempting to execute \fIlogin\fR from any shell but the login shell
Xwill produce an error message.
X.PP
XWhen invoked from the \fBlogin:\fR prompt, the user may enter
Xenvironmental variables after the username.
XThese variables are entered in the form \fBNAME=VALUE\fR.
XNot all variables may be set in the fashion, notably \fBPATH\fR,
X\fBHOME\fR and \fBSHELL\fR.
XAdditionally, \fBIFS\fR may be inhibited if the user\'s login
Xshell is \fB/bin/sh\fR.
X.PP
XThe user is then prompted for a password, where appropriate.
XEchoing is disabled to prevent revealing the password.
XOnly a small number of password failures are permitted before
X\fIlogin\fR exits and the communications link is severed.
X.PP
XIf password aging has been enabled for your account, you may be
Xprompted for a new password before proceeding.
XYou will be forced to provide your old password and the new
Xpassword before continuing.
XPlease refer to \fIpasswd(1)\fR for more information.
X.PP
XAfter a successful login,
Xyou will be informed of any system messages and the presence
Xof mail.
XYou may turn off the printing of the system message file,
X\fI/etc/motd\fR, by creating a zero-length file \fI.hushlogin\fR
Xin your login directory.
XThe mail message will be one of "\fIYou have new mail.\fR",
X"\fIYou have mail.\fR", or "\fINo Mail.\fR" according to
Xthe condition of your mailbox.
X.PP
XYour user and group ID will be set according to their values in
Xthe \fI/etc/passwd\fR file.
XThe value for \fB$HOME\fR, \fB$SHELL\fR, \fB$PATH\fR, \fB$LOGNAME\fR,
Xand \fB$MAIL\fR are set according to the appropriate fields in the
Xpassword entry.
XUlimit, umask and nice values may also be set according to
Xentries in the GECOS field.
X.PP
XOn some installations, the environmental variable \fB$TERM\fR will be
Xinitialize to the terminal type on your tty line, as specified in
X\fI/etc/ttytype\fR.
X.PP
XAn initialization script for your command interpreter may also be
Xexecuted.
XPlease see the appropriate manual section for more information on
Xthis function.
X.SH CAVEATS
X.PP
XThis version of \fIlogin\fR has many compilation options, only some of which
Xmay be in use at any particular site.
X.SH Files
X/etc/utmp \- list of current login sessions
X.br
X/etc/wtmp \- list of previous login sessions
X.br
X/etc/passwd \- user account information
X.br
X/etc/shadow \- encrypted passwords and age information
X.br
X/etc/motd \- system message file
X.br
X/etc/ttytype \- list of terminal types
X.br
X$HOME/.profile \- initialization script for default shell
X.br
X$HOME/.hushlogin \- suppress printing of system messages
X.br
X.SH See Also
X.PP
Xgetty(1M),
Xmail(1),
Xpasswd(1),
Xsh(1),
Xsu(1),
Xd_passwd(4),
Xpasswd(4)
END_OF_FILE
  if test 3347 -ne `wc -c <'login.1'`; then
    echo shar: \"'login.1'\" unpacked with wrong size!
  fi
  # end of 'login.1'
fi
if test -f 'obscure.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'obscure.c'\"
else
  echo shar: Extracting \"'obscure.c'\" \(4080 characters\)
  sed "s/^X//" >'obscure.c' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X */
X
X/*
X * This version of obscure.c contains modifications to support "cracklib"
X * by Alec Muffet (alec.muffett@uk.sun.com).  You must obtain the Cracklib
X * library source code for this function to operate.
X */
X
X#include <ctype.h>
X#ifndef	BSD
X#include <string.h>
X#include <memory.h>
X#else
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#endif
X#include "config.h"
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)obscure.c	3.7	18:10:59	03 Jul 1993";
X#endif
X
Xextern	int	getdef_bool();
Xextern	int	getdef_num();
X
X#ifdef	NEED_STRSTR
X/*
X * strstr - find substring in string
X */
X
Xchar *
Xstrstr (string, pattern)
Xchar	*string;
Xchar	*pattern;
X{
X	char	*cp;
X	int	len;
X
X	len = strlen (pattern);
X
X	for (cp = string;cp = strchr (cp, *pattern);) {
X		if (strncmp (cp, pattern, len) == 0)
X			return cp;
X
X		cp++;
X	}
X	return 0;
X}
X#endif
X
X/*
X * Obscure - see if password is obscure enough.
X *
X *	The programmer is encouraged to add as much complexity to this
X *	routine as desired.  Included are some of my favorite ways to
X *	check passwords.
X */
X
X/*ARGSUSED*/
Xint	obscure (old, new)
Xchar	*old;
Xchar	*new;
X{
X	int	i;
X	char	oldmono[32];
X	char	newmono[32];
X	char	wrapped[64];
X#ifdef	CRACKLIB_DICTPATH
X	char	*msg;
X	char	*FascistCheck();
X#endif
X
X	if (old[0] == '\0')
X		return (1);
X
X	if ( strlen(new) < getdef_num("PASS_MIN_LEN", 0) ) {
X		printf ("Too short.  ");
X		return (0);
X	}
X
X	/*
X	 * Remaining checks are optional.
X	 */
X	if ( !getdef_bool("OBSCURE_CHECKS_ENAB") )
X		return (1);
X
X	for (i = 0;new[i];i++)
X		newmono[i] = tolower (new[i]);
X
X	for (i = 0;old[i];i++)
X		oldmono[i] = tolower (old[i]); 
X
X	if (strcmp (new, old) == 0) {	/* the same */
X		printf ("No Change.  ");
X		return (0);
X	}
X	if (palindrome (newmono, oldmono))	/* a palindrome */
X		return (0);
X
X	if (strcmp (newmono, oldmono) == 0) {	/* case shifted */
X		printf ("Case changes only.  ");
X		return (0);
X	}
X	if (similiar (newmono, oldmono))	/* jumbled version */
X		return (0);
X
X	if (simple (old, new))			/* keyspace size */
X		return (0);
X
X	strcpy (wrapped, oldmono);
X	strcat (wrapped, oldmono);
X	if (strstr (wrapped, newmono)) {
X		printf ("Rotated.  ");
X		return (0);
X	}
X#ifdef CRACKLIB_DICTPATH	
X
X	/*
X	 * Invoke Alec Muffett's cracklib routines.
X	 */
X
X	if (msg = FascistCheck (new, CRACKLIB_DICTPATH)) {
X		printf("Bad Password: %s.  ", msg);
X		return (0);
X	}
X#endif /* CRACKLIB_DICTPATH */
X
X	return (1);
X}
X
X/*
X * can't be a palindrome - like `R A D A R' or `M A D A M'
X */
X
X/*ARGSUSED*/
Xint	palindrome (old, new)
Xchar	*old;
Xchar	*new;
X{
X	int	i, j;
X
X	i = strlen (new);
X
X	for (j = 0;j < i;j++)
X		if (new[i - j - 1] != new[j])
X			return (0);
X
X	printf ("A palindrome.  ");
X	return (1);
X}
X
X/*
X * more than half of the characters are different ones.
X */
X
X/*ARGSUSED*/
Xint	similiar (old, new)
Xchar	*old;
Xchar	*new;
X{
X	int	i, j;
X	char	*strchr ();
X
X	for (i = j = 0;new[i] && old[i];i++)
X		if (strchr (new, tolower (old[i])))
X			j++;
X
X	if (i >= j * 2)
X		return (0);
X
X	printf ("Too similiar.  ");
X	return (1);
X}
X
X/*
X * a nice mix of characters.
X */
X
X/*ARGSUSED*/
Xint	simple (old, new)
Xchar	*old;
Xchar	*new;
X{
X	int	digits = 0;
X	int	uppers = 0;
X	int	lowers = 0;
X	int	others = 0;
X	int	size;
X	int	i;
X
X	for (i = 0;new[i];i++) {
X		if (isdigit (new[i]))
X			digits++;
X		else if (isupper (new[i]))
X			uppers++;
X		else if (islower (new[i]))
X			lowers++;
X		else
X			others++;
X	}
X
X	/*
X	 * The scam is this - a password of only one character type
X	 * must be 8 letters long.  Two types, 7, and so on.
X	 */
X
X	size = 9;
X	if (digits) size--;
X	if (uppers) size--;
X	if (lowers) size--;
X	if (others) size--;
X
X	if (size <= i)
X		return 0;
X
X	printf ("Too Simple.  Use a longer password, or a mix of upper\n");
X	printf ("and lower case letters and numerics.  ");
X	return 1;
X}
END_OF_FILE
  if test 4080 -ne `wc -c <'obscure.c'`; then
    echo shar: \"'obscure.c'\" unpacked with wrong size!
  fi
  # end of 'obscure.c'
fi
if test -f 'pwconv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pwconv.c'\"
else
  echo shar: Extracting \"'pwconv.c'\" \(4449 characters\)
  sed "s/^X//" >'pwconv.c' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * pwconv - convert and update shadow password files
X *
X *	Pwconv copies the old password file information to a new shadow
X *	password file, merging entries from an optional existing shadow
X *	file.
X *
X *	The new password file is left in npasswd, the new shadow file is
X *	left in nshadow.  Existing shadow entries are copied as is.
X *	New entries are created with passwords which expire in MAXDAYS days,
X *	with a last changed date of today, unless password aging
X *	information was already present.  Likewise, the minimum number of
X *	days before which the password may be changed is controlled by
X *	MINDAYS.  The number of warning days is set to WARNAGE if that
X *	macro exists.  Entries with blank passwordsare not copied to the
X *	shadow file at all.
X */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include "pwd.h"
X#ifndef	BSD
X#include <string.h>
X#else
X#define	strchr	index
X#define	strrchr	rindex
X#include <strings.h>
X#endif
X#include "config.h"
X#include "shadow.h"
X
X#ifndef	lint
Xstatic	char	_sccsid[] = "@(#)pwconv.c	3.4	07:43:52	17 Sep 1991";
X#endif
X
Xchar	buf[BUFSIZ];
X
Xlong	time ();
Xlong	a64l ();
Xextern	int	getdef_num();
X
Xint	main ()
X{
X	long	today;
X	struct	passwd	*pw;
X	struct	passwd	*sgetpwent ();
X	FILE	*pwd;
X	FILE	*npwd;
X	FILE	*shadow;
X	struct	spwd	*spwd;
X	struct	spwd	tspwd;
X	int	fd;
X	char	*cp;
X
X	if (! (pwd = fopen (PWDFILE, "r"))) {
X		perror (PWDFILE);
X		exit (1);
X	}
X	unlink ("npasswd");
X	if ((fd = open ("npasswd", O_WRONLY|O_CREAT|O_EXCL, 0644)) < 0 ||
X			! (npwd = fdopen (fd, "w"))) {
X		perror ("npasswd");
X		exit (1);
X	}
X	unlink  ("nshadow");
X	if ((fd = open ("nshadow", O_WRONLY|O_CREAT|O_EXCL, 0600)) < 0 ||
X			! (shadow = fdopen (fd, "w"))) {
X		perror ("nshadow");
X		(void) unlink ("npasswd");
X		(void) unlink ("nshadow");
X		exit (1);
X	}
X
X	(void) time (&today);
X	today /= (24L * 60L * 60L);
X
X	while (fgets (buf, BUFSIZ, pwd) == buf) {
X		if (cp = strrchr (buf, '\n'))
X			*cp = '\0';
X
X		if (buf[0] == '#') {	/* comment line */
X			(void) fprintf (npwd, "%s\n", buf);
X			continue;
X		}
X		if (! (pw = sgetpwent (buf))) { /* copy bad lines verbatim */
X			(void) fprintf (npwd, "%s\n", buf);
X			continue;
X		}
X		if (pw->pw_passwd[0] == '\0') { /* no password, skip */
X			(void) fprintf (npwd, "%s\n", buf);
X			continue;
X		}
X		setspent ();		/* rewind old shadow file */
X
X		if (spwd = getspnam (pw->pw_name)) {
X			if (putspent (spwd, shadow)) { /* copy old entry */
X				perror ("nshadow");
X				goto error;
X			}
X		} else {		/* need a new entry. */
X			tspwd.sp_namp = pw->pw_name;
X			tspwd.sp_pwdp = pw->pw_passwd;
X			pw->pw_passwd = "x";
X#ifdef	ATT_AGE
X			if (pw->pw_age) { /* copy old password age stuff */
X				if (strlen (pw->pw_age) >= 2) {
X					tspwd.sp_min = c64i (pw->pw_age[1]);
X					tspwd.sp_max = c64i (pw->pw_age[0]);
X				} else {
X					tspwd.sp_min = tspwd.sp_max = -1;
X				}
X				if (strlen (pw->pw_age) == 4)
X					tspwd.sp_lstchg = a64l (&pw->pw_age[2]);
X				else
X					tspwd.sp_lstchg = -1;
X
X				/*
X				 * Convert weeks to days
X				 */
X
X				if (tspwd.sp_min != -1)
X					tspwd.sp_min *= 7;
X
X				if (tspwd.sp_max != -1)
X					tspwd.sp_max *= 7;
X
X				if (tspwd.sp_lstchg != -1)
X					tspwd.sp_lstchg *= 7;
X			} else
X#endif	/* ATT_AGE */
X			{	/* fake up new password age stuff */
X				tspwd.sp_max =
X					getdef_num("PASS_MAX_DAYS", 10000);
X				tspwd.sp_min = getdef_num("PASS_MIN_DAYS", 0);
X				tspwd.sp_lstchg = today;
X			}
X			tspwd.sp_warn = getdef_num("PASS_WARN_AGE", -1);
X			tspwd.sp_inact = tspwd.sp_expire = tspwd.sp_flag = -1;
X			if (putspent (&tspwd, shadow)) { /* output entry */
X				perror ("nshadow");
X				goto error;
X			}
X		}
X		(void) fprintf (npwd, "%s:%s:%d:%d:%s:%s:",
X				pw->pw_name, pw->pw_passwd,
X				pw->pw_uid, pw->pw_gid,
X				pw->pw_gecos, pw->pw_dir);
X
X		if (fprintf (npwd, "%s\n",
X				pw->pw_shell ? pw->pw_shell:"") == EOF) {
X			perror ("npasswd");
X			goto error;
X		}
X	}
X	endspent ();
X
X	if (ferror (npwd) || ferror (shadow)) {
X		perror ("pwconv");
Xerror:
X		(void) unlink ("npasswd");
X		(void) unlink ("nshadow");
X		exit (1);
X	}
X	(void) fclose (pwd);
X	(void) fclose (npwd);
X	(void) fclose (shadow);
X
X	exit (0);
X}
END_OF_FILE
  if test 4449 -ne `wc -c <'pwconv.c'`; then
    echo shar: \"'pwconv.c'\" unpacked with wrong size!
  fi
  # end of 'pwconv.c'
fi
if test -f 'shadow.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'shadow.3'\"
else
  echo shar: Extracting \"'shadow.3'\" \(3624 characters\)
  sed "s/^X//" >'shadow.3' <<'END_OF_FILE'
X.\" Copyright 1989, 1990, 1992, 1993, John F. Haugh II
X.\" All rights reserved.
X.\"
X.\" Permission is granted to copy and create derivative works for any
X.\" non-commercial purpose, provided this copyright notice is preserved
X.\" in all copies of source code, or included in human readable form
X.\" and conspicuously displayed on all copies of object code or
X.\" distribution media.
X.\"
X.\" This software is provided on an AS-IS basis and the author makes
X.\" no warrantee of any kind.
X.\"
X.\"	@(#)shadow.3	3.2	07:54:45	06 May 1993
X.\"
X.TH SHADOW 3
X.SH NAME
Xshadow \- encrypted password file routines
X.SH SYNTAX
X#include <shadow.h>
X.br
Xstruct spwd *getspent();
X.br
Xstruct spwd *getspnam(char * name);
X.br
Xvoid setspent();
X.br
Xvoid endspent();
X.br
Xstruct spwd *fgetspent(FILE *fp);
X.br
Xstruct spwd *sgetspent(char *cp);
X.br
Xint putspent(struct spwd *p,FILE *fp);
X.br
Xint lckpwdf ();
X.br
Xint ulckpwdf ();
X.SH DESCRIPTION
X.I shadow
Xmanipulates the contents of the shadow password file,
X\fB/etc/shadow\fR.
XThe structure in the \fI#include\fR file is
X.sp
Xstruct spwd {
X.in +.5i
X.br
X	char	*sp_namp; /* user login name */
X.br
X	char	*sp_pwdp; /* encrypted password */
X.br
X	long	sp_lstchg; /* last password change */
X.br
X	int	sp_min; /* days until change allowed. */
X.br
X	int	sp_max; /* days before change required */
X.br
X	int	sp_warn; /* days warning for expiration */
X.br
X	int	sp_inact; /* days before account inactive */
X.br
X	int	sp_expire; /* date when account expires */
X.br
X	int	sp_flag; /* reserved for future use */
X.br
X.in -.5i
X}
X.PP
XThe meanings of each field are
X.sp
Xsp_namp \- pointer to null-terminated user name.
X.br
Xsp_pwdp \- pointer to null-terminated password.
X.br
Xsp_lstchg \- days since Jan 1, 1970 password was last changed.
X.br
Xsp_min \- days before which password may not be changed.
X.br
Xsp_max \- days after which password must be changed.
X.br
Xsp_warn \- days before password is to expire that user is warned
Xof pending password expiration.
X.br
Xsp_inact \- days after password expires that account is considered
Xinactive and disabled.
X.br
Xsp_expire \- days since Jan 1, 1970 when account will be disabled.
X.br
Xsp_flag \- reserved for future use.
X.SH DESCRIPTION
X\fIgetspent\fR, \fIgetspname\fR, \fIfgetspent\fR, and \fIsgetspent\fR
Xeach return a pointer to a \fBstruct spwd\fR.
X\fIgetspent\fR returns the
Xnext entry from the file, and \fIfgetspent\fR returns the next
Xentry from the given stream, which is assumed to be a file of
Xthe proper format.
X\fIsgetspent\fR returns a pointer to a \fBstruct spwd\fR using the
Xprovided string as input.
X\fIgetspnam\fR searches from the current position in the file for
Xan entry matching \fIname\fR.
X.PP
X\fIsetspent\fR and \fIendspent\fR may be used to begin and end,
Xrespectively, access to the shadow password file.
X.PP
XThe \fIlckpwdf\fR and \fIulckpwdf\fR routines should be used to
Xinsure exclusive access to the \fB/etc/shadow\fR file.
X\fIlckpwdf\fR attempts to acquire a lock using \fIpw_lock\fR for
Xup to 15 seconds.
XIt continues by attempting to acquire a second lock using \fIspw_lock\fR
Xfor the remainder of the initial 15 seconds.
XShould either attempt fail after a total of 15 seconds, \fIlckpwdf\fR
Xreturns -1.
XWhen both locks are acquired 0 is returned.
X.SH DIAGNOSTICS
XRoutines return NULL if no more entries are available or if an
Xerror occurs during processing.
XRoutines which have \fBint\fR as the return value return 0 for
Xsuccess and -1 for failure.
X.SH CAVEATS
XThese routines may only be used by the super user as access to
Xthe shadow password file is restricted.
X.SH FILES
X/etc/shadow \- encrypted user passwords
X.SH SEE ALSO
Xgetpwent(3),
Xshadow(4)
END_OF_FILE
  if test 3624 -ne `wc -c <'shadow.3'`; then
    echo shar: \"'shadow.3'\" unpacked with wrong size!
  fi
  # end of 'shadow.3'
fi
if test -f 'usermod.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'usermod.1'\"
else
  echo shar: Extracting \"'usermod.1'\" \(4212 characters\)
  sed "s/^X//" >'usermod.1' <<'END_OF_FILE'
X.\" Copyright 1991, 1992, 1993, John F. Haugh II
X.\" All rights reserved.
X.\"
X.\" Permission is granted to copy and create derivative works for any
X.\" non-commercial purpose, provided this copyright notice is preserved
X.\" in all copies of source code, or included in human readable form
X.\" and conspicuously displayed on all copies of object code or
X.\" distribution media.
X.\"
X.\" This software is provided on an AS-IS basis and the author makes
X.\" no warrantee of any kind.
X.\"
X.\"	@(#)usermod.1	3.4	08:10:31	07 May 1993
X.\"
X.TH USERMOD 1M
X.SH NAME
Xusermod \- Modify a user account
X.SH SYNOPSIS
X.B usermod
X[ \fB-A\fI method\fR | \fBDEFAULT\fR ]
X[ \fB-c\fI comment\fR ]
X[ \fB-d\fI home_dir \fR[ \fB-m\fR ] ]
X[ \fB-e\fI expire_date\fR ]
X[ \fB-f\fI inactive_time\fR ]
X[ \fB-g\fI initial_group\fR ]
X[ \fB-G\fI group[,...]\fR ]
X[ \fB-l\fI login_name \fR ]
X[ \fB-s\fI shell\fR ]
X[ \fB-u\fI uid \fR[ \fB-o\fR ]
X.I login
X.SH DESCRIPTION
XThe \fIusermod\fR command modifies the system account files to reflect
Xthe changes that are specified on the command line.
XThe options which apply to the \fIusermod\fR command are
X.IP "\fB-A \fImethod\fR|\fBDEFAULT\fR"
XThe new value of the user's authentication method.
XThe authentication method is the name of a program which is responsible
Xfor validating the user's identity.
XThe string \fBDEFAULT\fR may be used to change the user's authentication
Xmethod to the standard system password method.
X.IP "\fB-c \fIcomment\fR"
XThe new value of the user's password file comment field.
XIt is normally modified using the \fBchfn(1)\fR utility.
X.IP "\fB-d \fIhome_dir\fR"
XThe user's new login directory.
XIf the \fB-m\fR option is given the contents of the current home directory
Xwill be moved to the new home directory, which is created if it does not
Xalready exist.
X.IP "\fB-e \fIexpire_date\fR"
XThe date on which the user account will be disabled.
XThe date is specified in the format \fIMM/DD/YY\fR.
X.IP "\fB-f \fIinactive_days\fR"
XThe number of days after a password expires until the account
Xis permanently disabled.
XA value of 0 disables the account as soon as the password has
Xexpired, and a value of -1 disables the feature.
XThe default value is -1.
X.IP "\fB-g \fIinitial_group\fR"
XThe group name or number of the user's new initial login group.
XThe group name must exist.  A group number must refer to an
Xalready existing group.
XThe default group number is 1.
X.IP "\fB-G \fIgroup,[...]\fR"
XA list of supplementary groups which the user is also a member
Xof.
XEach group is separated from the next by a comma, with no
Xintervening whitespace.
XThe groups are subject to the same restrictions as the group
Xgiven with the \fB-g\fR option.
XIf the user is currently a member of a group which is not listed,
Xthe user will be removed from the group
X.IP "\fB-l \fIlogin_name\fR"
XThe name of the user will be changed from \fIlogin\fR to
X\fIlogin_name\fR.
XNothing else is changed.
XIn particular, the user's home directory name should probably
Xbe changed to reflect the new login name.
X.IP "\fB-s \fIshell\fR"
XThe name of the user's new login shell.
XSetting this field to blank causes the system
Xto select the default login shell.
X.IP "\fB-u \fIuid\fR"
XThe numerical value of the user's ID.
XThis value must be unique, unless the \fI-o\fR option is used.
XThe value must be non-negative.
XValues between 0 and 99 are typically reserved for system accounts.
XAny files which the user owns and which are located in the directory
Xtree rooted at the user's home directory will have the file user ID
Xchanged automatically.
XFiles outside of the user's home directory must be altered manually.
X.SH CAVEATS
X\fBusermod\fB will not allow you to change the name of a user who is
Xlogged in.
XYou must make certain that the named user is not executing any processes
Xwhen this command is being executed if the user's numerical user ID is
Xbeing changed.
XYou must change the owner of any crontab files manually.
XYou must change the owner of any at jobs manually.
X.SH Files
X/etc/passwd \- user account information
X.br
X/etc/shadow \- secure user account information
X.br
X/etc/group \- group information
X.SH SEE ALSO
X\fBchfn(1), chsh(1), groupadd(1M), groupdel(1M), groupmod(1M),
Xpasswd(1), useradd(1M), userdel(1M)
END_OF_FILE
  if test 4212 -ne `wc -c <'usermod.1'`; then
    echo shar: \"'usermod.1'\" unpacked with wrong size!
  fi
  # end of 'usermod.1'
fi
echo shar: End of archive 11 \(of 14\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
