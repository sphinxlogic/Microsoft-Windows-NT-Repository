Newsgroups: comp.sources.misc
From: jfh@rpp386.cactus.org (John F. Haugh II)
Subject: v38i123:  shadow - Shadow Password Suite, v3.3, Part04/14
Message-ID: <1993Aug14.192400.9275@sparky.sterling.com>
X-Md4-Signature: ff921a960dee618d06ddddbacb15f8ea
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sat, 14 Aug 1993 19:24:00 GMT
Approved: kent@sparky.sterling.com

Submitted-by: jfh@rpp386.cactus.org (John F. Haugh II)
Posting-number: Volume 38, Issue 123
Archive-name: shadow/part04
Environment: UNIX
Supersedes: shadow: Volume 26, Issue 54-64

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile.svr4 gpmain.c lmain.c
# Wrapped by kent@sparky on Sat Aug 14 14:11:39 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 14)."'
if test -f 'Makefile.svr4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.svr4'\"
else
  echo shar: Extracting \"'Makefile.svr4'\" \(18940 characters\)
  sed "s/^X//" >'Makefile.svr4' <<'END_OF_FILE'
X#
X# Copyright 1988,1989,1990,1991,1992,1993 John F. Haugh II
X# All rights reserved.
X#
X# Permission is granted to copy and create derivative works for any
X# non-commercial purpose, provided this copyright notice is preserved
X# in all copies of source code, or included in human readable form
X# and conspicuously displayed on all copies of object code or
X# distribution media.
X#
X# This software is provided on an AS-IS basis and the author makes
X# no warrantee of any kind.
X#
X#	@(#)Makefile.svr4	3.11	08:11:05  - Shadow password system (SVR4)
X#
X#	@(#)Makefile.svr4	3.11	08:11:05	19 Jul 1993
X#
XSHELL = /sbin/sh
X
X#
X# Set this flag to decide what level of code "get" returns.
X# The base USENET release was release 1.  It is no longer supported.
X# The version with the utilities added was release 2.
X# The version with database-like file access is release 3.
XRELEASE = 3
XGFLAGS = -t -r$(RELEASE)
X
X# Define the directory login is copied to.  SVr4 uses /usr/bin.
XLOGINDIR = /usr/bin
XSBIN=/usr/sbin
X# system (admin) commands
XUBIN=/usr/bin
X# user commands
X
X# SVr4 doesn't need extra libraries
XNDIR =
X
X# Define some stuff for Cracklib.  This assumes that libcracklib.a is
X# in a system directory.
X# CRACKDEF='-DCRACKLIB_DICTPATH="$(DICTPATH)"'
X# CRACKLIB=-lcrack
X
X# Pick your favorite C compiler and tags command
XCC = cc
XTAGS = ctags
X
X# OS.  This is SVr4
XOS = -DUSG -DSVR4
X
X# SVr4 doesn't use ranlib
XRANLIB = echo
X
X# Configuration Flags
X#
X#	DEST_INCLUDE_DIR - local include files
X#	LIBS - system libraries
X#		-lsocket - needed for TCP/IP and possibly SYSLOG
X#		-ldbm or -lndbm - needed for DBM support
X#		-lcrypt - needed for SCO crypt() functions
X#		-lucb if -ldbm is defined
X#		-lsocket and -lnsl if RLOGIN is defined
X#	CFLAGS - C compiler flags
X#		-DLAI_TCP - needed for SCO Xenix Lachman TCP/IP
X
XDEST_INCLUDE_DIR = /usr/include
X
X# Flags for SVr4
XCFLAGS = -O -g $(OS) -I$(DEST_INCLUDE_DIR) $(CRACKDEF)
XLIBS =
XLDFLAGS = -g
X
X# Library is libsec.a
XLIBSEC = libsec.a
X
X# Names for root user and group, and bin user and group.
XRUID = root
XRGID = root
XBUID = bin
XBGID = bin
X
X# Where the login.defs file will be copied.  Must agree with config.h
XDEST_LOGIN_DEFS = /etc/login.defs
X
X# Rules for .L (lint) files.
X.SUFFIXES: .L
XLINT = lint
XLINTFLAGS = $(OS) -Dlint
X
X.c.L:
X	$(LINT) -pxu $(LINTFLAGS) $*.c > $*.L
X
XLOBJS = lmain.o login.o env.o valid.o setup.o shell.o age.o \
X	utmp.o sub.o mail.o motd.o log.o ttytype.o failure.o \
X	tz.o console.o hushed.o
X
XLSRCS = lmain.c login.c env.c valid.c setup.c shell.c age.c \
X	utmp.c sub.c mail.c motd.c log.c ttytype.c failure.c \
X	tz.c console.c hushed.c
X
XSOBJS = smain.o env.o entry.o susetup.o shell.o \
X	sub.o mail.o motd.o sulog.o age.o tz.o hushed.o
X
XSSRCS = smain.c env.c entry.c setup.c shell.c \
X	pwent.c sub.c mail.c motd.c sulog.c shadow.c age.c pwpack.c rad64.c \
X	tz.c hushed.c
X
XPOBJS = passwd.o obscure.o
XPSRCS = passwd.c obscure.c
X
XGPSRCS = gpmain.c
X
XGPOBJS = gpmain.o
X
XPWOBJS = pwconv.o
X
XPWSRCS = pwconv.c pwent.c shadow.c pwpack.c rad64.c
X
XPWUNOBJS = pwunconv.o
X
XPWUNSRCS = pwunconv.c pwent.c shadow.c pwpack.c rad64.c
X
XSULOGOBJS = sulogin.o entry.o env.o age.o setup.o \
X	valid.o shell.o tz.o
X
XSULOGSRCS = sulogin.c entry.c env.c age.c pwent.c setup.c \
X	shadow.c shell.c valid.c pwpack.c tz.c
X
XMKPWDOBJS = mkpasswd.o
X
XMKPWDSRCS = mkpasswd.c
X
XNGSRCS = newgrp.c env.c shell.c
X
XNGOBJS = newgrp.o env.o shell.o
X
XCHFNSRCS = chfn.c fields.c
XCHFNOBJS = chfn.o fields.o
XCHSHSRCS = chsh.c fields.c
XCHSHOBJS = chsh.o fields.o
XCHAGEOBJS = chage.o fields.o
XCHAGESRCS = chage.c fields.c
XCHPASSOBJS = chpasswd.o
XCHPASSSRCS = chpasswd.c
XDPSRCS = dpmain.c
XDPOBJS = dpmain.o
X
XALLSRCS = age.c dialchk.c dialup.c entry.c env.c lmain.c log.c login.c mail.c \
X	motd.c obscure.c passwd.c pwconv.c pwent.c pwunconv.c getpass.c \
X	setup.c shadow.c shell.c smain.c sub.c sulog.c sulogin.c ttytype.c \
X	utmp.c valid.c port.c newgrp.c gpmain.c grent.c mkpasswd.c pwpack.c \
X	chfn.c chsh.c chage.c rad64.c encrypt.c chpasswd.c shadowio.c pwio.c \
X	newusers.c groupio.c fields.c pwdbm.c grpack.c grdbm.c sppack.c \
X	spdbm.c dpmain.c gshadow.c gsdbm.c gspack.c sgroupio.c useradd.c \
X	userdel.c patchlevel.h usermod.c copydir.c mkrmdir.c groupadd.c \
X	groupdel.c groupmod.c tz.c console.c hushed.c getdef.c \
X	logoutd.c groups.c pwauth.c lockpw.c chowndir.c
X
XFILES1 = README patchlevel.h newgrp.c Makefile config.h pwunconv.c obscure.c \
X	age.c id.c
X
XFILES2 = passwd.c port.c lmain.c sulogin.c pwpack.c dialup.c
X
XFILES3 = chfn.c chsh.c smain.c faillog.c pwconv.c shadow.c pwck.c
X
XFILES4 = gpmain.c chage.c pwent.c valid.c setup.c entry.c ttytype.c port.h
X
XFILES5 = pwio.c encrypt.c chpasswd.c newusers.c rad64.c dialchk.c faillog.h \
X	pwdbm.c grdbm.c gshadow.c sppack.c grpck.c
X
XFILES6 = gspack.c spdbm.c lastlog.h shell.c login.c sub.c dpmain.c mail.c \
X	env.c pwd.h.m4 grpack.c shadow.h log.c grent.c motd.c dialup.h \
X	fields.c gsdbm.c utmp.c failure.c
X
XFILES7 = groupio.c shadowio.c sgroupio.c groups.c copydir.c mkrmdir.c \
X	mkpasswd.c pwauth.c pwauth.h lastlog.c
X
XFILES8 = useradd.c usermod.c login.defs
X
XFILES9 = groupadd.c groupdel.c groupmod.c tz.c console.c hushed.c getdef.c \
X	scologin.c logoutd.c sulog.c getpass.c userdel.c lockpw.c chowndir.c
X
XFILES_SUN4 = Makefile.sun4 README.sun4 config.h.sun4
XFILES_SVR4 = Makefile.svr4 config.h.svr4
X
XMAN_1 = chage.1 chfn.1 chsh.1 id.1 login.1 newgrp.1 passwd.1 su.1 \
X	useradd.1 userdel.1 usermod.1 groupadd.1 groupdel.1 groupmod.1 \
X	groups.1 pwck.1 grpck.1
XMAN_3 = shadow.3 pwauth.3
XMAN_4 = faillog.4 passwd.4 porttime.4 shadow.4
XMAN_5 = login.5
XMAN_8 = chpasswd.8 dpasswd.8 faillog.8 newusers.8 pwconv.8 pwunconv.8 \
X	sulogin.8 mkpasswd.8 logoutd.8 pwauth.8 lastlog.8
X
XDOCS1 = $(MAN_1) $(MAN_3) $(MAN_4)
XDOCS2 = $(MAN_5) $(MAN_8)
XDOCS = $(DOCS1) $(DOCS2)
X
XBINS = su login pwconv pwunconv passwd sulogin faillog newgrp sg gpasswd \
X	mkpasswd chfn chsh chage chpasswd newusers dpasswd id useradd \
X	userdel usermod groupadd groupdel groupmod $(SCOLOGIN) logoutd \
X	groups pwck grpck lastlog
X
Xall:	$(BINS) $(DOCS)
X
X.PRECIOUS: libshadow.a
X
Xlibshadow.a: \
X	libshadow.a(dialchk.o) \
X	libshadow.a(dialup.o) \
X	libshadow.a(encrypt.o) \
X	libshadow.a(getdef.o) \
X	libshadow.a(getpass.o) \
X	libshadow.a(grdbm.o) \
X	libshadow.a(grent.o) \
X	libshadow.a(groupio.o) \
X	libshadow.a(grpack.o) \
X	libshadow.a(gshadow.o) \
X	libshadow.a(gsdbm.o) \
X	libshadow.a(gspack.o) \
X	libshadow.a(sgroupio.o) \
X	libshadow.a(port.o) \
X	libshadow.a(pwdbm.o) \
X	libshadow.a(pwent.o) \
X	libshadow.a(pwio.o) \
X	libshadow.a(pwpack.o) \
X	libshadow.a(pwauth.o) \
X	libshadow.a(rad64.o) \
X	libshadow.a(spdbm.o) \
X	libshadow.a(shadow.o) \
X	libshadow.a(shadowio.o) \
X	libshadow.a(sppack.o) \
X	libshadow.a(lockpw.o)
X	$(RANLIB) libshadow.a
X
Xlibsec: $(LIBSEC)(shadow.o)
X	$(RANLIB) $(LIBSEC)
X
Xsave:
X	[ ! -d save ] && mkdir save
X	-cp $(LOGINDIR)/login save
X	-cp $(SBIN)/mkpasswd $(SBIN)/pwconv $(SBIN)/pwunconv $(SBIN)/sulogin \
X		$(SBIN)/chpasswd $(SBIN)/newusers $(SBIN)/useradd \
X		$(SBIN)/userdel $(SBIN)/usermod $(SBIN)/groupadd \
X		$(SBIN)/groupdel $(SBIN)/groupmod $(SBIN)/logoutd \
X		$(SBIN)/login.defs $(SBIN)/pwck $(SBIN)/grpck save
X	-cp $(UBIN)/su $(UBIN)/passwd $(UBIN)/gpasswd $(UBIN)/dpasswd \
X		$(UBIN)/faillog $(UBIN)/newgrp $(UBIN)/chfn \
X		$(UBIN)/chsh $(UBIN)/chage $(UBIN)/id save
X	-cp $(DEST_INCLUDE_DIR)/dialup.h $(DEST_INCLUDE_DIR)/shadow.h \
X		$(DEST_INCLUDE_DIR)/pwd.h save
X
Xrestore:
X	[ -d save ]
X	-(cd save ; cp login $(LOGINDIR) )
X	-(cd save ; -cp mkpasswd pwconv pwunconv sulogin chpasswd \
X		newusers useradd userdel usermod groupadd groupdel groupmod \
X		logoutd login.defs pwck grpck $(SBIN) )
X	-(cd save ; cp su passwd gpasswd dpasswd faillog newgrp chfn chsh \
X		chage id $(UBIN) )
X	-(cd save ; cp dialup.h shadow.h pwd.h $(DEST_INCLUDE_DIR) )
X
Xinstall: all
X	strip $(BINS)
X	mcs -da '@(#)shadow 3.2.3' $(BINS)
X	cp login $(LOGINDIR)/login
X	cp mkpasswd pwconv pwunconv sulogin chpasswd newusers \
X		useradd userdel usermod groupadd groupdel groupmod logoutd \
X		pwck grpck lastlog $(SBIN)
X	cp su passwd gpasswd dpasswd faillog newgrp chfn chsh chage id $(UBIN)
X	cp dialup.h shadow.h pwd.h /usr/include
X	chown $(RUID) $(LOGINDIR)/login $(SBIN)/pwconv $(SBIN)/pwunconv \
X		$(SBIN)/sulogin $(UBIN)/su $(UBIN)/passwd $(UBIN)/gpasswd \
X		$(UBIN)/newgrp $(SBIN)/mkpasswd $(UBIN)/dpasswd $(UBIN)/chsh \
X		$(UBIN)/chfn $(UBIN)/chage $(SBIN)/useradd $(SBIN)/userdel \
X		$(SBIN)/usermod $(SBIN)/groupadd $(SBIN)/groupdel \
X		$(SBIN)/groupmod $(SBIN)/logoutd $(SBIN)/pwck $(SBIN)/grpck
X	chgrp $(RGID) $(LOGINDIR)/login $(SBIN)/pwconv $(SBIN)/pwunconv \
X		$(SBIN)/sulogin $(UBIN)/su $(UBIN)/passwd $(UBIN)/gpasswd \
X		$(UBIN)/newgrp $(SBIN)/mkpasswd $(UBIN)/dpasswd $(UBIN)/chsh \
X		$(UBIN)/chfn $(UBIN)/chage $(SBIN)/useradd $(SBIN)/userdel \
X		$(SBIN)/usermod $(SBIN)/groupadd $(SBIN)/groupdel \
X		$(SBIN)/groupmod $(SBIN)/logoutd $(SBIN)/pwck $(SBIN)/grpck
X	chown $(BUID) $(UBIN)/faillog $(UBIN)/id /usr/include/shadow.h \
X		/usr/include/dialup.h /usr/include/pwd.h
X	chgrp $(BGID) $(UBIN)/faillog $(UBIN)/id /usr/include/shadow.h \
X		/usr/include/dialup.h /usr/include/pwd.h
X	chmod 700 $(SBIN)/pwconv $(SBIN)/pwunconv $(SBIN)/sulogin \
X		$(SBIN)/mkpasswd $(SBIN)/chpasswd $(SBIN)/newusers \
X		$(UBIN)/dpasswd $(UBIN)/chage $(SBIN)/useradd $(SBIN)/userdel \
X		$(SBIN)/usermod $(SBIN)/groupadd $(SBIN)/groupdel \
X		$(SBIN)/groupmod $(SBIN)/logoutd $(SBIN)/pwck $(SBIN)/grpck
X	chmod 4711 $(LOGINDIR)/login $(UBIN)/su $(UBIN)/passwd $(UBIN)/gpasswd \
X		$(UBIN)/newgrp $(UBIN)/chfn $(UBIN)/chsh
X	chmod 711 $(UBIN)/faillog $(UBIN)/id
X	chmod 444 /usr/include/shadow.h /usr/include/dialup.h \
X		/usr/include/pwd.h
X	rm -f $(UBIN)/sg
X	ln $(UBIN)/newgrp $(UBIN)/sg
X	[ -f /etc/login.defs ] || (cp login.defs /etc ; \
X		chown $(RUID) /etc/login.defs ; \
X		chgrp $(RGID) /etc/login.defs ; \
X		chmod 600 /etc/login.defs )
X
Xlint:	su.lint login.lint pwconv.lint pwunconv.lint passwd.lint sulogin.lint \
X	faillog.lint newgrp.lint gpasswd.lint mkpasswd.lint chfn.lint \
X	chsh.lint chage.lint dpasswd.lint id.lint useradd.lint userdel.lint \
X	usermod.lint groupadd.lint groupdel.lint groupmod.lint logoutd.lint \
X	pwck.lint grpck.lint \
X	$(ALLSRCS:.c=.L)
X
Xtags:	$(ALLSRCS)
X	$(TAGS) $(ALLSRCS)
X
XREADME:
X	[ -f s.README ] && get -t -r$(RELEASE) s.README
X	
X$(DOCS):
X	[ -f s.$@ ] && get -t -r$(RELEASE) s.$@
X
Xlogin.defs:
X	[ -f s.login.defs ] && get -t -r$(RELEASE) s.login.defs
X
XMakefile.sun4:
X	[ -f s.Makefile.sun4 ] && get -t -r$(RELEASE) s.Makefile.sun4
X
XMakefile.svr4:
X	[ -f s.Makefile.svr4 ] && get -t -r$(RELEASE) s.Makefile.svr4
X
XREADME.sun4:
X	[ -f s.README.sun4 ] && get -t -r$(RELEASE) s.README.sun4
X
Xconfig.h.sun4:
X	[ -f s.config.h.sun4 ] && get -t -r$(RELEASE) s.config.h.sun4
X
Xconfig.h.svr4:
X	[ -f s.config.h.svr4 ] && get -t -r$(RELEASE) s.config.h.svr4
X
Xlogin:	$(LOBJS) libshadow.a
X	$(CC) -o login $(LDFLAGS) $(LOBJS) libshadow.a $(LIBS)
X
Xlogin.lint: $(LSRCS)
X	$(LINT) $(LINTFLAGS) $(LSRCS) > login.lint
X
Xsu:	$(SOBJS) libshadow.a
X	$(CC) -o su $(LDFLAGS) $(SOBJS) libshadow.a $(LIBS)
X
Xsu.lint:	$(SSRCS)
X	$(LINT) $(LINTFLAGS) -DSU $(SSRCS) > su.lint
X
Xpasswd:	$(POBJS) libshadow.a
X	$(CC) -o passwd $(LDFLAGS) $(POBJS) libshadow.a $(LIBS) $(CRACKLIB)
X
Xpasswd.lint: $(PSRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PSRCS) > passwd.lint
X
Xgpasswd: $(GPOBJS) libshadow.a
X	$(CC) -o gpasswd $(LDFLAGS) $(GPOBJS) libshadow.a $(LIBS)
X
Xgpasswd.lint: $(GPSRCS)
X	$(LINT) $(LINTFLAGS) $(GPSRCS) > gpasswd.lint
X
Xdpasswd: $(DPOBJS) libshadow.a
X	$(CC) -o dpasswd $(LDFLAGS) $(DPOBJS) libshadow.a $(LIBS)
X
Xdpasswd.lint: $(DPSRCS)
X	$(LINT) $(LINTFLAGS) $(DPSRCS) > dpasswd.lint
X
Xpwconv:	$(PWOBJS) libshadow.a config.h
X	$(CC) -o pwconv $(LDFLAGS) $(PWOBJS) libshadow.a $(LIBS)
X
Xpwconv.lint: $(PWSRCS) config.h
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PWSRCS) > pwconv.lint
X
Xpwunconv: $(PWUNOBJS) libshadow.a config.h
X	$(CC) -o pwunconv $(LDFLAGS) $(PWUNOBJS) libshadow.a $(LIBS)
X
Xpwunconv.lint: $(PWUNSRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(PWUNSRCS) > pwunconv.lint
X
Xsulogin: $(SULOGOBJS) libshadow.a
X	$(CC) -o sulogin $(LDFLAGS) $(SULOGOBJS) libshadow.a $(LIBS)
X
Xsulogin.lint: $(SULOGSRCS)
X	$(LINT) $(LINTFLAGS) $(SULOGSRCS) > sulogin.lint
X
Xfaillog: faillog.o
X	$(CC) -o faillog $(LDFLAGS) faillog.o $(LIBS)
X
Xfaillog.lint: faillog.c faillog.h config.h
X	$(LINT) $(LINTFLAGS) faillog.c > faillog.lint
X
Xlastlog: lastlog.o
X	$(CC) -o lastlog $(LDFLAGS) lastlog.o $(LIBS)
X
Xlastlog.lint: lastlog.c config.h lastlog.h
X	$(LINT) $(LINTFLAGS) $(MKPWDSRCS) > lastlog.lint
X
Xmkpasswd: $(MKPWDOBJS) libshadow.a
X	$(CC) -o mkpasswd $(LDFLAGS) $(MKPWDOBJS) libshadow.a $(LIBS)
X
Xmkpasswd.lint: $(MKPWDSRCS)
X	$(LINT) $(LINTFLAGS) $(MKPWDSRCS) > mkpasswd.lint
X
Xnewgrp: $(NGOBJS) libshadow.a
X	$(CC) -o newgrp $(LDFLAGS) $(NGOBJS) libshadow.a $(LIBS)
X
Xnewgrp.lint: $(NGSRCS)
X	$(LINT) $(LINTFLAGS) $(NGSRCS) > newgrp.lint
X
Xsg:	newgrp
X	/bin/rm -f sg
X	ln newgrp sg
X
Xsg.lint: newgrp.lint
X	ln newgrp.lint sg.lint
X
Xchfn:	$(CHFNOBJS) libshadow.a
X	$(CC) -o chfn $(LDFLAGS) $(CHFNOBJS) libshadow.a $(LIBS)
X
Xchfn.lint:	$(CHFNSRCS)
X	$(LINT) $(LINTFLAGS) $(CHFNSRCS) > chfn.lint
X
Xchsh:	$(CHSHOBJS) libshadow.a
X	$(CC) -o chsh $(LDFLAGS) $(CHSHOBJS) libshadow.a $(LIBS)
X
Xchsh.lint: $(CHSHSRCS)
X	$(LINT) $(LINTFLAGS) $(CHSHSRCS) > chsh.lint
X
Xchage:	$(CHAGEOBJS) libshadow.a
X	$(CC) -o chage $(LDFLAGS) $(CHAGEOBJS) libshadow.a $(LIBS)
X
Xchage.lint: $(CHAGESRCS)
X	$(LINT) $(LINTFLAGS) -DPASSWD $(CHAGESRCS) > chage.lint
X
Xchpasswd: $(CHPASSOBJS) libshadow.a
X	$(CC) -o chpasswd $(LDFLAGS) $(CHPASSOBJS) libshadow.a $(LIBS)
X
Xchpasswd.lint: $(CHPASSSRCS)
X	$(LINT) $(LINTFLAGS) $(CHPASSSRCS) > chpasswd.lint
X
Xnewusers: newusers.o libshadow.a
X	$(CC) -o newusers $(LDFLAGS) newusers.o libshadow.a $(LIBS)
X
Xnewusers.lint: newusers.c
X	$(LINT) $(LINTFLAGS) newusers.c > newusers.lint
X	
Xid: id.o libshadow.a
X	$(CC) -o id $(LDFLAGS) id.o libshadow.a $(LIBS)
X
Xid.lint: id.c
X	$(LINT) $(LINTFLAGS) id.c > id.lint
X
Xgroups: groups.o libshadow.a
X	$(CC) -o groups $(LDFLAGS) groups.o libshadow.a $(LIBS)
X
Xgroups.lint: groups.c
X	$(LINT) $(LINTFLAGS) groups.c > groups.lint
X
Xuseradd: useradd.o copydir.o mkrmdir.o libshadow.a
X	$(CC) -o useradd $(LDFLAGS) useradd.o copydir.o mkrmdir.o \
X		libshadow.a $(LIBS) $(NDIR)
X
Xuseradd.lint: useradd.c copydir.c mkrmdir.c
X	$(LINT) $(LINTFLAGS) useradd.c copydir.c mkrmdir.c > useradd.lint
X
Xuserdel: userdel.o copydir.o mkrmdir.o libshadow.a
X	$(CC) -o userdel $(LDFLAGS) userdel.o copydir.o mkrmdir.o \
X		libshadow.a $(LIBS) $(NDIR)
X
Xuserdel.lint: userdel.c copydir.c mkrmdir.c
X	$(LINT) $(LINTFLAGS) userdel.c copydir.c mkrmdir.c > userdel.lint
X
Xusermod: usermod.o copydir.o mkrmdir.o chowndir.o libshadow.a
X	$(CC) -o usermod $(LDFLAGS) usermod.o copydir.o mkrmdir.o \
X		chowndir.o libshadow.a $(LIBS) $(NDIR)
X
Xusermod.lint: usermod.c copydir.c mkrmdir.c chowndir.c
X	$(LINT) $(LINTFLAGS) usermod.c copydir.c mkrmdir.c \
X		chowndir.c > usermod.lint
X
Xgroupadd: groupadd.o libshadow.a
X	$(CC) -o groupadd $(LDFLAGS) groupadd.o libshadow.a $(LIBS)
X
Xgroupadd.lint: groupadd.c
X	$(LINT) $(LINTFLAGS) groupadd.c > groupadd.lint
X
Xgroupdel: groupdel.o libshadow.a
X	$(CC) -o groupdel $(LDFLAGS) groupdel.o libshadow.a $(LIBS)
X
Xgroupdel.lint: groupdel.c
X	$(LINT) $(LINTFLAGS) groupdel.c > groupdel.lint
X
Xgroupmod: groupmod.o libshadow.a
X	$(CC) -o groupmod $(LDFLAGS) groupmod.o libshadow.a $(LIBS)
X
Xgroupmod.lint: groupmod.c
X	$(LINT) $(LINTFLAGS) groupmod.c > groupmod.lint
X
Xpwd.h.m4:
X	[ -f s.pwd.h.m4 ] && get -t -r$(RELEASE) s.pwd.h.m4
X
Xpwd.h: pwd.h.m4
X	m4 $(OS) < pwd.h.m4 > pwd.h
X
Xlogoutd: logoutd.o libshadow.a
X	$(CC) -o logoutd $(LDFLAGS) logoutd.o libshadow.a
X
Xlogoutd.lint: logoutd.c
X	$(LINT) $(LINTFLAGS) logoutd.c > logoutd.lint
X
Xpwck: pwck.o libshadow.a
X	$(CC) -o pwck $(LDFLAGS) pwck.o libshadow.a $(LIBS)
X
Xpwck.lint: pwck.c
X	$(LINT) $(LINTFLAGS) pwck.c > pwck.lint
X
Xgrpck: grpck.o libshadow.a
X	$(CC) -o grpck $(LDFLAGS) grpck.o libshadow.a $(LIBS)
X
Xgrpck.lint: grpck.c
X	$(LINT) $(LINTFLAGS) grpck.c > grpck.lint
X
Xsulog.o: config.h
X
Xsusetup.c: setup.c
X	cp setup.c susetup.c
X
Xsusetup.o: config.h susetup.c pwd.h
X	$(CC) -c $(CFLAGS) -DSU susetup.c
X
Xpasswd.o: config.h shadow.h pwd.h
Xlmain.o: config.h lastlog.h faillog.h pwd.h
Xsmain.o: config.h lastlog.h pwd.h shadow.h
Xsub.o: pwd.h
Xsetup.o: config.h pwd.h
Xmkrmdir.o: config.h
Xutmp.o: config.h
Xmail.o: config.h
Xmotd.o: config.h
Xage.o: config.h pwd.h
Xlog.o: config.h lastlog.h pwd.h
Xshell.o: config.h
Xentry.o: config.h shadow.h pwd.h
Xhushed.o: config.h pwd.h
Xvalid.o: config.h pwd.h
Xfailure.o: faillog.h config.h
Xfaillog.o: faillog.h config.h pwd.h
Xnewgrp.o: config.h shadow.h pwd.h
Xmkpasswd.o: config.h shadow.h pwd.h
Xgpmain.o: config.h pwd.h
Xchfn.o: config.h pwd.h
Xchsh.o: config.h pwd.h
Xchage.o: config.h shadow.h pwd.h
Xpwconv.o: config.h shadow.h
Xpwunconv.o: config.h shadow.h pwd.h
Xchpasswd.o: config.h shadow.h pwd.h
Xid.o: pwd.h
Xnewusers.o: config.h shadow.h pwd.h
Xdpmain.o: config.h dialup.h
Xuseradd.o: config.h shadow.h pwd.h
Xuserdel.o: config.h shadow.h pwd.h
Xusermod.o: config.h shadow.h pwd.h
Xgroupadd.o: config.h shadow.h
Xgroupdel.o: config.h shadow.h
Xgroupmod.o: config.h shadow.h
Xlogoutd.o: config.h
Xsulogin.o: config.h
Xcopydir.o: config.h
Xchowndir.o: config.h
Xpwck.o: config.h shadow.h pwd.h
Xgrpck.o: config.h shadow.h pwd.h
X
Xlibshadow.a(shadow.o): shadow.h config.h
Xlibshadow.a(shadowio.o): shadow.h
Xlibshadow.a(grent.o): config.h shadow.h
Xlibshadow.a(sgroupio.o): shadow.h
Xlibshadow.a(dialup.o): dialup.h
Xlibshadow.a(dialchk.o): dialup.h config.h
Xlibshadow.a(getdef.o): config.h
Xlibshadow.a(pwdbm.o): config.h pwd.h
Xlibshadow.a(spdbm.o): config.h shadow.h
Xlibshadow.a(grdbm.o): config.h
Xlibshadow.a(gsdbm.o): config.h shadow.h
Xlibshadow.a(pwpack.o): config.h pwd.h
Xlibshadow.a(pwent.o): config.h pwd.h
Xlibshadow.a(pwio.o): pwd.h
Xlibshadow.a(getpass.o): config.h
Xlibshadow.a(encrypt.o): config.h
Xlibshadow.a(port.o): port.h
Xlibshadow.a(rad64.o): config.h
Xlibshadow.a(lockpw.o):
X
Xclean:
X	-rm -f susetup.c *.o a.out core npasswd nshadow *.pag *.dir pwd.h
X
Xclobber: clean
X	-rm -f $(BINS) *.lint *.L libshadow.a
X
Xnuke:	clobber
X	-for file in * ; do \
X		if [ -f s.$$file -a ! -f p.$$file ] ; then \
X			rm -f $$file ;\
X		fi ;\
X	done
X
Xshar:	login.sh.01 login.sh.02 login.sh.03 login.sh.04 login.sh.05 \
X	login.sh.06 login.sh.07 login.sh.08 login.sh.09 login.sh.10 \
X	login.sh.11 login.sh.12
X
Xlogin.sh.01: $(FILES1) Makefile
X	shar -a $(FILES1) > login.sh.01
X
Xlogin.sh.02: $(FILES2) Makefile
X	shar -a $(FILES2) > login.sh.02
X
Xlogin.sh.03: $(FILES3) Makefile
X	shar -a $(FILES3) > login.sh.03
X
Xlogin.sh.04: $(FILES4) Makefile
X	shar -a $(FILES4) > login.sh.04
X
Xlogin.sh.05: $(FILES5) Makefile
X	shar -a $(FILES5) > login.sh.05
X
Xlogin.sh.06: $(FILES6) Makefile
X	shar -a $(FILES6) > login.sh.06
X
Xlogin.sh.07: $(FILES7) Makefile
X	shar -a $(FILES7) > login.sh.07
X
Xlogin.sh.08: $(FILES8) Makefile
X	shar -a $(FILES8) > login.sh.08
X
Xlogin.sh.09: $(FILES9) Makefile
X	shar -a $(FILES9) > login.sh.09
X
Xlogin.sh.10: $(DOCS1) Makefile
X	shar -a $(DOCS1) > login.sh.10
X
Xlogin.sh.11: $(DOCS2) Makefile
X	shar -a $(DOCS2) > login.sh.11
X
Xlogin.sh.12: $(FILES_SUN4) $(FILES_SVR4) Makefile
X	shar -a $(FILES_SUN4) $(FILES_SVR4) > login.sh.12
END_OF_FILE
  if test 18940 -ne `wc -c <'Makefile.svr4'`; then
    echo shar: \"'Makefile.svr4'\" unpacked with wrong size!
  fi
  # end of 'Makefile.svr4'
fi
if test -f 'gpmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'gpmain.c'\"
else
  echo shar: Extracting \"'gpmain.c'\" \(18788 characters\)
  sed "s/^X//" >'gpmain.c' <<'END_OF_FILE'
X/*
X * Copyright 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include "pwd.h"
X#include "shadow.h"
X#include <grp.h>
X#include <fcntl.h>
X#include <signal.h>
X#include <errno.h>
X#if defined(USG) || defined(SUN4)
X#include <termio.h>
X#ifdef SYS3
X# include <sys/ioctl.h>
X#endif	/* SYS3 */
X#include <string.h>
X#ifndef	SYS3
X# include <memory.h>
X#endif /* !SYS3 */
X#else /* SUN || BSD */
X#include <sgtty.h>
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#endif /* !SUN && !BSD */
X#include "config.h"
X
X#ifdef	USE_SYSLOG
X#include <syslog.h>
X
X#ifndef	LOG_WARN
X#define	LOG_WARN	LOG_WARNING
X#endif
X#endif
X
X#ifdef	USG
X#define	bzero(p,l) memset(p, 0, l)
X#endif
X
X#ifndef	lint
Xstatic	char	_sccsid[] = "@(#)gpmain.c	3.14	08:16:38	07 May 1993";
X#endif
X
Xchar	name[BUFSIZ];
Xchar	pass[BUFSIZ];
Xchar	pass2[BUFSIZ];
X
Xstruct	group	grent;
X
Xchar	*Prog;
Xchar	*user;
Xchar	*group;
Xchar	*admins;
Xchar	*members;
X
Xint	aflg;
Xint	Aflg;
Xint	dflg;
Xint	Mflg;
Xint	rflg;
Xint	Rflg;
X
X#ifndef	RETRIES
X#define	RETRIES	3
X#endif
X
Xextern	char	*l64a ();
Xextern	char	*crypt ();
Xextern	char	*pw_encrypt ();
Xextern	int	errno;
Xextern	long	a64l ();
Xextern	void	entry ();
Xextern	time_t	time ();
Xextern	char	*malloc ();
Xextern	char	*getpass ();
X#ifdef	NDBM
Xextern	int	sg_dbm_mode;
Xextern	int	gr_dbm_mode;
X#endif
X
X/*
X * usage - display usage message
X */
X
Xvoid
Xusage ()
X{
X	fprintf (stderr, "usage: %s [ -r|R ] group\n", Prog);
X	fprintf (stderr, "       %s [ -a user ] group\n", Prog);
X	fprintf (stderr, "       %s [ -d user ] group\n", Prog);
X#ifdef	SHADOWGRP
X	fprintf (stderr, "       %s [ -A user[,user] ][ -M user[,user] group\n",
X		Prog);
X#else
X	fprintf (stderr, "       %s [ -M user[,user] group\n", Prog);
X#endif
X	exit (1);
X}
X
X/*
X * add_list - add a member to a list of group members
X *
X *	the array of member names is searched for the new member
X *	name, and if not present it is added to a freshly allocated
X *	list of users.
X */
X
Xchar **
Xadd_list (list, member)
Xchar	**list;
Xchar	*member;
X{
X	int	i;
X	char	**tmp;
X
X	for (i = 0;list[i] != (char *) 0;i++)
X		if (strcmp (list[i], member) == 0)
X			return list;
X
X	if (! (tmp = (char **) malloc ((i + 2) * sizeof member)))
X		return 0;
X
X	for (i = 0;list[i] != (char *) 0;i++)
X		tmp[i] = list[i];
X
X	tmp[i++] = strdup (member);
X	tmp[i] = (char *) 0;
X
X	return tmp;
X}
X
X/*
X * del_list - delete a group member from a list of members
X *
X *	del_list searches a list of group members, copying the
X *	members which do not match "member" to a newly allocated
X *	list.
X */
X
Xchar **
Xdel_list (list, member)
Xchar	**list;
Xchar	*member;
X{
X	int	i, j;
X	char	**tmp;
X
X	for (j = i = 0;list[i] != (char *) 0;i++)
X		if (strcmp (list[i], member))
X			j++;
X
X	tmp = (char **) malloc ((j + 1) * sizeof member);
X
X	for (j = i = 0;list[i] != (char *) 0;i++)
X		if (strcmp (list[i], member) != 0)
X			tmp[j++] = list[i];
X
X	tmp[j] = (char *) 0;
X
X	return tmp;
X}
X
X/*
X * comma_to_list - convert comma-separated list to (char *) array
X */
X
Xchar **
Xcomma_to_list (comma)
Xchar	*comma;
X{
X	char	*members;
X	char	**array;
X	int	i;
X	char	*cp, *cp2;
X
X	/*
X	 * Make a copy since we are going to be modifying the list
X	 */
X
X	if (! (members = strdup (comma))) {
X		perror ("malloc");
X		exit (1);
X	}
X
X	/*
X	 * Count the number of commas in the list
X	 */
X
X	for (cp = members, i = 0;;i++)
X		if (cp2 = strchr (cp, ','))
X			cp = cp2 + 1;
X		else
X			break;
X
X	/*
X	 * Add 2 - one for the ending NULL, the other for the last item
X	 */
X
X	i += 2;
X
X	/*
X	 * Allocate the array we're going to store the pointers into.
X	 */
X
X	if (! (array = (char **) malloc (sizeof (char *) * i))) {
X
X		/*
X		 * Can't happen ...
X		 */
X
X		perror ("malloc");
X		exit (1);
X	}
X
X	/*
X	 * Now go walk that list all over again, this time building the
X	 * array of pointers.
X	 */
X
X	for (cp = members, i = 0;;i++) {
X		array[i] = cp;
X		if (cp2 = strchr (cp, ',')) {
X			*cp2++ = '\0';
X			cp = cp2;
X		} else {
X			array[i + 1] = (char *) 0;
X			break;
X		}
X	}
X
X	/*
X	 * Return the new array of pointers
X	 */
X
X	return array;
X}
X
X/*
X * check_list - check a comma-separated list of user names for validity
X *
X *	check_list scans a comma-separated list of user names and checks
X *	that each listed name exists.
X */
X
Xint
Xcheck_list (users)
Xchar	*users;
X{
X	char	*cp;
X	char	*end;
X	char	*start;
X	char	user[16];
X	int	errors = 0;
X	int	len;
X
X	for (start = users;start && *start;start = end) {
X		if (end = strchr (start, ',')) {
X			if ((len = end - start) > 15)
X				len = 15;
X
X			strncpy (user, start, len);
X			user[len] = 0;
X			end++;
X		} else {
X			if ((len = strlen (start)) > 15)
X				len = 15;
X
X			strncpy (user, start, len);
X			user[len] = 0;
X		}
X
X		/*
X		 * This user must exist.
X		 */
X
X		if (! getpwnam (user)) {
X			fprintf (stderr, "%s: unknown user %s\n", Prog, user);
X			errors++;
X		}
X	}
X	return errors;
X}
X
X/*
X * gpasswd - administer the /etc/group file
X *
X *	-a user		add user to the named group
X *	-d user		remove user from the named group
X *	-r		remove password from the named group
X *	-R		restrict access to the named group
X *	-A user,...	make list of users the administrative users
X *	-M user,...	make list of users the group members
X */
X
Xint
Xmain (argc, argv)
Xint	argc;
Xchar	**argv;
X{
X	extern	int	optind;
X	extern	char	*optarg;
X	int	flag;
X	int	i;
X	void	die ();
X	char	*cp;
X	char	*getlogin ();
X	char	*getpass ();
X	int	amroot;
X	int	retries;
X	int	ruid = getuid();
X	struct	group	*gr = 0;
X	struct	group	*getgrnam ();
X	struct	group	*sgetgrent ();
X#ifdef	SHADOWGRP
X	struct	sgrp	*sg = 0;
X	struct	sgrp	sgent;
X	struct	sgrp	*getsgnam ();
X#endif
X	struct	passwd	*pw = 0;
X	struct	passwd	*getpwuid ();
X	struct	passwd	*getpwnam ();
X
X	/*
X	 * Make a note of whether or not this command was invoked
X	 * by root.  This will be used to bypass certain checks
X	 * later on.  Also, set the real user ID to match the
X	 * effective user ID.  This will prevent the invoker from
X	 * issuing signals which would interfer with this command.
X	 */
X
X	amroot = getuid () == 0;
X#ifdef	NDBM
X	sg_dbm_mode = O_RDWR;
X	gr_dbm_mode = O_RDWR;
X#endif
X	setuid (geteuid ());
X
X	if (Prog = strrchr (argv[0], '/'))
X		Prog++;
X	else
X		Prog = argv[0];
X
X#ifdef	USE_SYSLOG
X	openlog (Prog, LOG_PID|LOG_CONS|LOG_NOWAIT, LOG_AUTH);
X#endif
X	setbuf (stdout, (char *) 0);
X	setbuf (stderr, (char *) 0);
X
X	while ((flag = getopt (argc, argv, "a:d:grRA:M:")) != EOF) {
X		switch (flag) {
X			case 'a':	/* add a user */
X				aflg++;
X				user = optarg;
X				break;
X			case 'A':
X				Aflg++;
X				admins = optarg;
X				break;
X			case 'd':	/* delete a user */
X				dflg++;
X				user = optarg;
X				break;
X			case 'g':	/* no-op from normal password */
X				break;
X			case 'M':
X				Mflg++;
X				members = optarg;
X				break;
X			case 'r':	/* remove group password */
X				rflg++;
X				break;
X			case 'R':	/* restrict group password */
X				Rflg++;
X				break;
X			default:
X				usage ();
X		}
X	}
X
X	/*
X	 * Make sure exclusive flags are exclusive
X	 */
X
X	if (aflg + dflg + rflg + Rflg + (Aflg || Mflg) > 1)
X		usage ();
X
X	/*
X	 * If the password is being changed, the input and output must
X	 * both be a tty.  The typical keyboard signals are caught
X	 * so the termio modes can be restored.
X	 */
X
X	if (! aflg && ! dflg && ! rflg && ! Rflg && ! Aflg && ! Mflg) {
X		if (! isatty (0) || ! isatty (1))
X			exit (1);
X
X		die (0);			/* save tty modes */
X
X		signal (SIGHUP, die);
X		signal (SIGINT, die);
X		signal (SIGQUIT, die);
X		signal (SIGTERM, die);
X#ifdef	SIGTSTP
X		signal (SIGTSTP, die);
X#endif
X	}
X
X	/*
X	 * Determine the name of the user that invoked this command.
X	 * This is really hit or miss because there are so many ways
X	 * that command can be executed and so many ways to trip up
X	 * the routines that report the user name.
X	 */
X
X	if ((cp = getlogin ()) && (pw = getpwnam (cp)) && pw->pw_uid == ruid) {
X					/* need user name */
X		(void) strcpy (name, cp);
X	} else if (pw = getpwuid (ruid)) /* get it from password file */
X		strcpy (name, pw->pw_name);
X	else {				/* can't find user name! */
X		fprintf (stderr, "Who are you?\n");
X		exit (1);
X	}
X	if (! (pw = getpwnam (name)))
X		goto failure;		/* can't get my name ... */
X		
X	/*
X	 * Get the name of the group that is being affected.  The group
X	 * entry will be completely replicated so it may be modified
X	 * later on.
X	 */
X
X	if (! (group = argv[optind]))
X		usage ();
X
X	if (! (gr = getgrnam (group))) {
X		fprintf (stderr, "unknown group: %s\n", group);
X		exit (1);
X	}
X	grent = *gr;
X	grent.gr_name = strdup (gr->gr_name);
X	grent.gr_passwd = strdup (gr->gr_passwd);
X
X	for (i = 0;gr->gr_mem[i];i++)
X		;
X	grent.gr_mem = (char **) malloc ((i + 1) * sizeof (char *));
X	for (i = 0;gr->gr_mem[i];i++)
X		grent.gr_mem[i] = strdup (gr->gr_mem[i]);
X	grent.gr_mem[i] = (char *) 0;
X#ifdef	SHADOWGRP
X	if (sg = getsgnam (group)) {
X		sgent = *sg;
X		sgent.sg_name = strdup (sg->sg_name);
X		sgent.sg_passwd = strdup (sg->sg_passwd);
X
X		for (i = 0;sg->sg_mem[i];i++)
X			;
X		sgent.sg_mem = (char **) malloc (sizeof (char *) * (i + 1));
X		for (i = 0;sg->sg_mem[i];i++)
X			sgent.sg_mem[i] = strdup (sg->sg_mem[i]);
X		sgent.sg_mem[i] = 0;
X
X		for (i = 0;sg->sg_adm[i];i++)
X			;
X		sgent.sg_adm = (char **) malloc (sizeof (char *) * (i + 1));
X		for (i = 0;sg->sg_adm[i];i++)
X			sgent.sg_adm[i] = strdup (sg->sg_adm[i]);
X		sgent.sg_adm[i] = 0;
X	} else {
X		sgent.sg_name = strdup (group);
X		sgent.sg_passwd = grent.gr_passwd;
X		grent.gr_passwd = "!";
X
X		for (i = 0;grent.gr_mem[i];i++)
X			;
X		sgent.sg_mem = (char **) malloc (sizeof (char *) * (i + 1));
X		for (i = 0;grent.gr_mem[i];i++)
X			sgent.sg_mem[i] = strdup (grent.gr_mem[i]);
X		sgent.sg_mem[i] = 0;
X
X		sgent.sg_adm = (char **) malloc (sizeof (char *) * 2);
X		if (sgent.sg_mem[0]) {
X			sgent.sg_adm[0] = strdup (sgent.sg_mem[0]);
X			sgent.sg_adm[1] = 0;
X		} else
X			sgent.sg_adm[0] = 0;
X
X		sg = &sgent;
X	}
X#endif
X
X#ifdef	SHADOWGRP
X
X	/*
X	 * The policy here for changing a group is that 1) you must be
X	 * root or 2). you must be listed as an administrative member.
X	 * Administrative members can do anything to a group that the
X	 * root user can.
X	 */
X
X	if (! amroot) {
X		for (i = 0;sgent.sg_adm[i];i++)
X			if (strcmp (sgent.sg_adm[i], name) == 0)
X				break;
X
X		if (sgent.sg_adm[i] == (char *) 0)
X			goto failure;
X	}
X#else
X
X	/*
X	 * The policy here for changing a group is that 1) you must bes
X	 * root or 2) you must be the first listed member of the group.
X	 * The first listed member of a group can do anything to that
X	 * group that the root user can.  The rationale for this hack is
X	 * that the FIRST user is probably the most important user in
X	 * this entire group.
X	 */
X
X	if (! amroot) {
X		if (grent.gr_mem[0] == (char *) 0)
X			goto failure;
X
X		if (strcmp (grent.gr_mem[0], name) != 0)
X			goto failure;
X	}
X
X#endif	/* SHADOWGRP */
X
X	/*
X	 * Removing a password is straight forward.  Just set the
X	 * password field to a "".
X	 */
X
X	if (rflg) {
X		grent.gr_passwd = "";
X#ifdef	SHADOWGRP
X		sgent.sg_passwd = "";
X#endif
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "remove password from group %s\n", group);
X#endif
X		goto output;
X	} else if (Rflg) {
X
X	/*
X	 * Same thing for restricting the group.  Set the password
X	 * field to "!".
X	 */
X
X		grent.gr_passwd = "!";
X#ifdef	SHADOWGRP
X		sgent.sg_passwd = "!";
X#endif
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "restrict access to group %s\n", group);
X#endif
X		goto output;
X	}
X
X	/*
X	 * Adding a member to a member list is pretty straightforward
X	 * as well.  Call the appropriate routine and split.
X	 */
X
X	if (aflg) {
X		if (getpwnam (user) == (struct passwd *) 0) {
X			fprintf (stderr, "%s: unknown user %s\n", Prog, user);
X			exit (1);
X		}
X		printf ("Adding user %s to group %s\n", user, group);
X		grent.gr_mem = add_list (grent.gr_mem, user);
X#ifdef	SHADOWGRP
X		sgent.sg_mem = add_list (sgent.sg_mem, user);
X#endif
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "add member %s to group %s\n", user, group);
X#endif
X		goto output;
X	}
X
X	/*
X	 * Removing a member from the member list is the same deal
X	 * as adding one, except the routine is different.
X	 */
X
X	if (dflg) {
X		int	removed = 0;
X
X		for (i = 0;grent.gr_mem[i];i++)
X			if (strcmp (user, grent.gr_mem[i]) == 0)
X				break;
X
X		printf ("Removing user %s from group %s\n", user, group);
X
X		if (grent.gr_mem[i] != (char *) 0) {
X			removed = 1;
X			grent.gr_mem = del_list (grent.gr_mem, user);
X		}
X#ifdef	SHADOWGRP
X		for (i = 0;sgent.sg_mem[i];i++)
X			if (strcmp (user, sgent.sg_mem[i]) == 0)
X				break;
X
X		if (sgent.sg_mem[i] != (char *) 0) {
X			removed = 1;
X			sgent.sg_mem = del_list (sgent.sg_mem, user);
X		}
X#endif
X		if (! removed) {
X			fprintf (stderr, "%s: unknown member %s\n", Prog, user);
X			exit (1);
X		}
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "remove member %s from group %s\n",
X				user, group);
X#endif
X		goto output;
X	}
X
X	/*
X	 * Replacing the entire list of members is simple.  Check the list
X	 * to make sure everyone is a real user.  Then slap the new list
X	 * in place.
X	 */
X
X	if (Mflg) {
X
X		/*
X		 * Only root can replace the entire list.
X		 */
X
X		if (! amroot)
X			goto failure;
X
X		/*
X		 * Check the list for validity, then put it in.
X		 */
X
X		if (check_list (members))
X			exit (1);
X
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "set members of %s to %s\n", group, members);
X#endif
X#ifdef	SHADOWGRP
X		sgent.sg_mem = comma_to_list (members);
X		grent.gr_mem = comma_to_list (members);
X
X		if (! Aflg)
X			goto output;
X#else
X		grent.gr_mem = comma_to_list (members);
X
X		goto output;
X#endif
X	}
X
X#ifdef	SHADOWGRP
X
X	/*
X	 * Replacing the entire list of administators is simple.  Check the
X	 * list to make sure everyone is a real user.  Then slap the new
X	 * list in place.
X	 */
X
X	if (Aflg) {
X
X		/*
X		 * Only root can replace the entire list.
X		 */
X
X		if (! amroot)
X			goto failure;
X
X		/*
X		 * Check the list for validity, then put it in.
X		 */
X
X		if (check_list (admins))
X			exit (1);
X
X#ifdef	USE_SYSLOG
X		syslog (LOG_INFO, "set administrators of %s to %s\n",
X				group, members);
X#endif
X		sgent.sg_adm = comma_to_list (admins);
X
X		goto output;
X	}
X#endif
X
X	/*
X	 * A new password is to be entered and it must be encrypted,
X	 * etc.  The password will be prompted for twice, and both
X	 * entries must be identical.  There is no need to validate
X	 * the old password since the invoker is either the group
X	 * owner, or root.
X	 */
X
X	printf ("Changing the password for group %s\n", group);
X
X	for (retries = 0;retries < RETRIES;retries++) {
X		if (! (cp = getpass ("New Password:")))
X			exit (1);
X		else {
X			strcpy (pass, cp);
X			bzero (cp, strlen (cp));
X		}
X		if (! (cp = getpass ("Re-enter new password:")))
X			exit (1);
X		else {
X			strcpy (pass2, cp);
X			bzero (cp, strlen (cp));
X		}
X		if (strcmp (pass, pass2) == 0)
X			break;
X
X		bzero (pass, sizeof pass);
X		bzero (pass2, sizeof pass2);
X
X		if (retries + 1 < RETRIES)
X			puts ("They don't match; try again");
X	}
X	bzero (pass2, sizeof pass2);
X
X	if (retries == RETRIES) {
X		fprintf (stderr, "%s: Try again later\n", Prog);
X		exit (1);
X	}
X#ifdef	SHADOWGRP
X	sgent.sg_passwd = pw_encrypt (pass, (char *) 0);
X#else
X	grent.gr_passwd = pw_encrypt (pass, (char *) 0);
X#endif
X	bzero (pass, sizeof pass);
X#ifdef	USE_SYSLOG
X	syslog (LOG_INFO, "change the password for group %s\n", group);
X#endif
X
X	/*
X	 * This is the common arrival point to output the new group
X	 * file.  The freshly crafted entry is in allocated space.
X	 * The group file will be locked and opened for writing.  The
X	 * new entry will be output, etc.
X	 */
X
Xoutput:
X	signal (SIGHUP, SIG_IGN);
X	signal (SIGINT, SIG_IGN);
X	signal (SIGQUIT, SIG_IGN);
X#ifdef	SIGTSTP
X	signal (SIGTSTP, SIG_IGN);
X#endif
X
X	if (! gr_lock ()) {
X		fprintf (stderr, "%s: can't get lock\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "failed to get lock for /etc/group\n");
X#endif
X		exit (1);
X	}
X#ifdef	SHADOWGRP
X	if (! sgr_lock ()) {
X		fprintf (stderr, "%s: can't get shadow lock\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "failed to get lock for /etc/gshadow\n");
X#endif
X		exit (1);
X	}
X#endif
X	if (! gr_open (O_RDWR)) {
X		fprintf (stderr, "%s: can't open file\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot open /etc/group\n");
X#endif
X		exit (1);
X	}
X#ifdef	SHADOWGRP
X	if (! sgr_open (O_RDWR)) {
X		fprintf (stderr, "%s: can't open shadow file\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot open /etc/gshadow\n");
X#endif
X		exit (1);
X	}
X#endif
X	if (! gr_update (&grent)) {
X		fprintf (stderr, "%s: can't update entry\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot update /etc/group\n");
X#endif
X		exit (1);
X	}
X#ifdef	SHADOWGRP
X	if (! sgr_update (&sgent)) {
X		fprintf (stderr, "%s: can't update shadow entry\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot update /etc/gshadow\n");
X#endif
X		exit (1);
X	}
X#endif
X	if (! gr_close ()) {
X		fprintf (stderr, "%s: can't re-write file\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot re-write /etc/group\n");
X#endif
X		exit (1);
X	}
X#ifdef	SHADOWGRP
X	if (! sgr_close ()) {
X		fprintf (stderr, "%s: can't re-write shadow file\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot re-write /etc/gshadow\n");
X#endif
X		exit (1);
X	}
X	(void) sgr_unlock ();
X#endif
X	if (! gr_unlock ()) {
X		fprintf (stderr, "%s: can't unlock file\n", Prog);
X		exit (1);
X	}
X#ifdef	NDBM
X	if (access ("/etc/group.pag", 0) == 0 && ! gr_dbm_update (&grent)) {
X		fprintf (stderr, "%s: can't update DBM files\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot update /etc/group DBM files\n");
X#endif
X		exit (1);
X	}
X	endgrent ();
X#ifdef	SHADOWGRP
X	if (access ("/etc/gshadow.pag", 0) == 0 && ! sg_dbm_update (&sgent)) {
X		fprintf (stderr, "%s: can't update DBM shadow files\n", Prog);
X#ifdef	USE_SYSLOG
X		syslog (LOG_WARN, "cannot update /etc/gshadow DBM files\n");
X#endif
X		exit (1);
X	}
X	endsgent ();
X#endif
X#endif
X	exit (0);
X	/*NOTREACHED*/
X
Xfailure:
X	fprintf (stderr, "Permission denied.\n");
X	exit (1);
X	/*NOTREACHED*/
X}
X
X/*
X * die - set or reset termio modes.
X *
X *	die() is called before processing begins.  signal() is then
X *	called with die() as the signal handler.  If signal later
X *	calls die() with a signal number, the terminal modes are
X *	then reset.
X */
X
Xvoid
Xdie (killed)
Xint	killed;
X{
X#if defined(BSD) || defined(SUN)
X	static	struct	sgtty	sgtty;
X
X	if (killed)
X		stty (0, &sgtty);
X	else
X		gtty (0, &sgtty);
X#else
X#if defined(SVR4) || defined (SUN4)
X	static	struct	termios	sgtty;
X
X	if (killed)
X		tcsetattr (0, TCSANOW, &sgtty);
X	else
X		tcgetattr (0, &sgtty);
X#else	/* !SVR4 */
X	static	struct	termio	sgtty;
X
X	if (killed)
X		ioctl (0, TCSETA, &sgtty);
X	else
X		ioctl (0, TCGETA, &sgtty);
X#endif	/* SVR4 */
X#endif	/* BSD || SUN */
X	if (killed) {
X		putchar ('\n');
X		fflush (stdout);
X		exit (killed);
X	}
X}
END_OF_FILE
  if test 18788 -ne `wc -c <'gpmain.c'`; then
    echo shar: \"'gpmain.c'\" unpacked with wrong size!
  fi
  # end of 'gpmain.c'
fi
if test -f 'lmain.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lmain.c'\"
else
  echo shar: Extracting \"'lmain.c'\" \(19435 characters\)
  sed "s/^X//" >'lmain.c' <<'END_OF_FILE'
X/*
X * Copyright 1989, 1990, 1991, 1992, 1993, John F. Haugh II
X * All rights reserved.
X *
X * Permission is granted to copy and create derivative works for any
X * non-commercial purpose, provided this copyright notice is preserved
X * in all copies of source code, or included in human readable form
X * and conspicuously displayed on all copies of object code or
X * distribution media.
X *
X * This software is provided on an AS-IS basis and the author makes
X * no warrantee of any kind.
X */
X
X#include "config.h"
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <stdio.h>
X#include "pwd.h"
X#ifdef SVR4
X#include <utmpx.h>
X#else
X#include <utmp.h>
X#endif
X#include <time.h>
X#include <signal.h>
X#ifndef	BSD
X#include <string.h>
X#include <memory.h>
X#else
X#include <strings.h>
X#define	strchr	index
X#define	strrchr	rindex
X#endif
X#ifndef	BSD
X#ifdef	SVR4
X#include <termios.h>
X#else	/* !SVR4 */
X#include <termio.h>
X#endif	/* SVR4 */
X#else
X#include <sgtty.h>
X#endif
X#ifdef	STDLIB_H
X#include <stdlib.h>
X#endif
X#ifdef	UNISTD_H
X#include <unistd.h>
X#endif
X
X#include "lastlog.h"
X#include "faillog.h"
X#ifdef	SHADOWPWD
X#include "shadow.h"
X#endif
X#include "pwauth.h"
X
X#ifdef SVR4_SI86_EUA
X#include <sys/proc.h>
X#include <sys/sysi86.h>
X#endif
X
X#if !defined(BSD) && !defined(SUN)
X#define	bzero(a,n)	memset(a, 0, n);
X#endif
X
X#ifdef	USE_SYSLOG
X#include <syslog.h>
X
X#ifndef	LOG_WARN
X#define	LOG_WARN	LOG_WARNING
X#endif
X#endif
X
X#ifndef	lint
Xstatic	char	sccsid[] = "@(#)lmain.c	3.24	08:07:08	19 Jul 1993";
X#endif
X
X					/* danger - side effects */
X#define STRFCPY(A,B)	strncpy((A), (B), sizeof(A)), *((A)+sizeof(A)-1) = '\0'
X
X#if defined(RLOGIN) || defined(UT_HOST) || defined(SVR4)
Xchar	host[BUFSIZ];
Xchar	term[128] = "TERM=";
Xint	remote_speed = 9600;
X#endif
X
Xstruct	passwd	pwent;
X#ifdef SVR4
Xstruct	utmpx	utxent, failent;
Xstruct	utmp	utent;
X#else	/*!SVR4 */
Xstruct	utmp	utent, failent;
X#endif	/* SVR4 */
Xstruct	lastlog	lastlog;
Xint	pflg;
Xint	rflg;
Xint	fflg;
X#ifdef	RLOGIN
Xint	hflg;
X#endif
Xint	preauth_flag;
X
X#if defined(SVR4) || defined(SUN4)
X#define	STTY(fd,termio) tcsetattr (fd, TCSANOW, termio)
X#define	GTTY(fd,termio) tcgetattr (fd, termio)
X#define	TERMIO	struct	termios
X#else
X#define	STTY(fd,termio) ioctl(fd, TCSETA, termio)
X#define	GTTY(fd,termio) ioctl(fd, TCGETA, termio)
X#define	TERMIO	struct	termio
X#endif	/* SVR4 || SUN4 */
XTERMIO	termio;
X
X#ifndef	MAXENV
X#define	MAXENV	64
X#endif
X
X/*
X * Global variables.
X */
X
Xchar	*newenvp[MAXENV];
Xchar	*Prog;
Xint	newenvc = 0;
Xint	maxenv = MAXENV;
X
X/*
X * External identifiers.
X */
X
Xextern	char	*getenv ();
Xextern	char	*getpass ();
Xextern	char	*tz ();
Xextern	void	checkutmp ();
Xextern	void	addenv ();
Xextern	void	setenv ();
Xextern	unsigned alarm ();
Xextern	void	login ();
Xextern	void	setutmp ();
Xextern	void	subsystem ();
Xextern	void	log ();
Xextern	void	setup ();
Xextern	int	expire ();
Xextern	void	motd ();
Xextern	void	mailcheck ();
Xextern	void	shell ();
Xextern	long	a64l ();
Xextern	int	c64i ();
Xextern	char	*getdef_str();
Xextern	int	getdef_bool();
Xextern	int	getdef_num();
Xextern	long	getdef_long();
Xextern	int	optind;
Xextern	char	*optarg;
Xextern	char	**environ;
Xextern	int	pw_auth();
X
X#ifdef HAVE_ULIMIT
Xextern	long	ulimit();
X#endif
X
X#ifndef	ALARM
X#define	ALARM	60
X#endif
X
X#ifndef	RETRIES
X#define	RETRIES	3
X#endif
X
Xstruct	faillog	faillog;
X
X#define	NO_SHADOW	"no shadow password for `%s' on `%s'\n"
X#define	BAD_PASSWD_HOST	"invalid password for `%s' on `%s' from `%s'\n"
X#define	BAD_PASSWD	"invalid password for `%s' on `%s'\n"
X#define	BAD_DIALUP	"invalid dialup password for `%s' on `%s'\n"
X#define	BAD_TIME_HOST	"invalid login time for `%s' on `%s' from `%s'\n"
X#define	BAD_TIME	"invalid login time for `%s' on `%s'\n"
X#define	BAD_ROOT_LOGIN	"ILLEGAL ROOT LOGIN ON TTY `%s'\n"
X#define	ROOT_LOGIN	"ROOT LOGIN ON TTY `%s'\n"
X#define	FAILURE_CNT	"exceeded failure limit for `%s' on `%s'\n"
X#define	NOT_A_TTY	"not a tty\n"
X#define	NOT_ROOT	"-r or -f flag and not ROOT on `%s'\n"
X#define AUTHFAIL	"authentication failed for user `%s'\n"
X
X/*
X * usage - print login command usage and exit
X *
X * login [ name ]
X * login -r hostname	(for rlogind)
X * login -h hostname	(for telnetd, etc.)
X * login -f name	(for pre-authenticated login: datakit, xterm, etc.)
X */
X
Xvoid
Xusage ()
X{
X	fprintf (stderr, "usage: login [ -p ] [ name ]\n");
X#ifdef	RLOGIN
X	fprintf (stderr, "       login [ -p ] -r name\n");
X	fprintf (stderr, "       login [ -p ] [ -f name ] -h host\n");
X#else
X	fprintf (stderr, "       login [ -p ] -f name\n");
X#endif	/* RLOGIN */
X	exit (1);
X}
X
X#ifdef	RLOGIN
Xstruct	{
X	int	spd_name;
X	int	spd_baud;
X} speed_table [] = {
X#ifdef	B50
X	B50, 50,
X#endif
X#ifdef	B75
X	B75, 75,
X#endif
X#ifdef	B110
X	B110, 110,
X#endif
X#ifdef	B134
X	B134, 134,
X#endif
X#ifdef	B150
X	B150, 150,
X#endif
X#ifdef	B200
X	B200, 200,
X#endif
X#ifdef	B300
X	B300, 300,
X#endif
X#ifdef	B600
X	B600, 600,
X#endif
X#ifdef	B1200
X	B1200, 1200,
X#endif
X#ifdef	B1800
X	B1800, 1800,
X#endif
X#ifdef	B2400
X	B2400, 2400,
X#endif
X#ifdef	B4800
X	B4800, 4800,
X#endif
X#ifdef	B9600
X	B9600, 9600,
X#endif
X#ifdef	B19200
X	B19200, 19200,
X#endif
X#ifdef	B38400
X	B38400, 38400,
X#endif
X	-1,	-1
X};
X
Xrlogin (remote_host, name, namelen)
Xchar	*remote_host;
Xchar	*name;
Xint	namelen;
X{
X	struct	passwd	*pwd;
X	char	remote_name[32];
X	char	*cp;
X	int	remote_speed = 9600;
X	int	speed_name = B9600;
X	int	i;
X
X	get_remote_string (remote_name, sizeof remote_name);
X	get_remote_string (name, namelen);
X	get_remote_string (term + 5, sizeof term - 5);
X
X	if (cp = strchr (term, '/')) {
X		*cp++ = '\0';
X
X		if (! (remote_speed = atoi (cp)))
X			remote_speed = 9600;
X	}
X	for (i = 0;speed_table[i].spd_baud != remote_speed &&
X				speed_table[i].spd_name != -1;i++)
X		;
X
X	if (speed_table[i].spd_name != -1)
X		speed_name = speed_table[i].spd_name;
X
X	GTTY (0, &termio);
X#ifndef	BSD
X	termio.c_iflag |= ICRNL|IXON;
X	termio.c_oflag |= OPOST|ONLCR;
X	termio.c_lflag |= ICANON|ECHO|ECHOE;
X	termio.c_cflag = (termio.c_cflag & ~CBAUD) | speed_name;
X#endif
X	STTY (0, &termio);
X
X	if (! (pwd = getpwnam (name)))
X		return 0;
X
X	/*
X	 * ruserok() returns 0 for success on modern systems, and 1 on
X	 * older ones.  If you are having trouble with people logging
X	 * in without giving a required password, THIS is the culprit -
X	 * go fix the #define in config.h.
X	 */
X
X#ifndef	RUSEROK
X	return 0;
X#else
X	return ruserok (remote_host, pwd->pw_uid == 0,
X				remote_name, name) == RUSEROK;
X#endif
X}
X
Xget_remote_string (buf, size)
Xchar	*buf;
Xint	size;
X{
X	for (;;) {
X		if (read (0, buf, 1) != 1)
X  			exit (1);
X		if (*buf == '\0')
X			return;
X		if (--size > 0)
X			++buf;
X	}
X	/*NOTREACHED*/
X}
X#endif
X
X/*
X * login - create a new login session for a user
X *
X *	login is typically called by getty as the second step of a
X *	new user session.  getty is responsible for setting the line
X *	characteristics to a reasonable set of values and getting
X *	the name of the user to be logged in.  login may also be
X *	called to create a new user session on a pty for a variety
X *	of reasons, such as X servers or network logins.
X *
X *	the flags which login supports are
X *	
X *	-p - preserve the environment
X *	-r - perform autologin protocol for rlogin
X *	-f - do not perform authentication, user is preauthenticated
X *	-h - the name of the remote host
X */
X
Xint
Xmain (argc, argv, envp)
Xint	argc;
Xchar	**argv;
Xchar	**envp;
X{
X	char	name[32];
X	char	pass[32];
X	char	tty[BUFSIZ];
X	int	reason = PW_LOGIN;
X	int	retries;
X	int	failed;
X	int	flag;
X	int	subroot = 0;
X	char	*fname;
X	char	*cp;
X	char	*tmp;
X	char	buff[128];
X	struct	passwd	*pwd;
X#ifdef	SHADOWPWD
X	struct	spwd	*spwd;
X	struct	spwd	*getspnam();
X#endif
X
X	/*
X	 * Some quick initialization.
X	 */
X
X	name[0] = '\0';
X
X	/*
X	 * Get the utmp file entry and get the tty name from it.  The
X	 * current process ID must match the process ID in the utmp
X	 * file if there are no additional flags on the command line.
X	 */
X
X	checkutmp (argc == 1 || argv[1][0] != '-');
X	STRFCPY (tty, utent.ut_line);
X
X	if (Prog = strrchr (argv[0], '/'))
X		Prog++;
X	else
X		Prog = argv[0];
X
X#ifdef	RLOGIN
X	while ((flag = getopt (argc, argv, "pr:f:h:")) != EOF)
X#else
X	while ((flag = getopt (argc, argv, "pf:")) != EOF)
X#endif
X	{
X		switch (flag) {
X			case 'p': pflg++;
X				break;
X			case 'f':
X				fflg++;
X				preauth_flag++;
X				STRFCPY (name, optarg);
X				break;
X#ifdef	RLOGIN
X			case 'r':
X				rflg++;
X				reason = PW_RLOGIN;
X				STRFCPY (host, optarg);
X#ifdef	UT_HOST
X				STRFCPY (utent.ut_host, optarg);
X#endif	/*UT_HOST*/
X#ifdef	SVR4
X				STRFCPY (utxent.ut_host, optarg);
X#endif	/* SVR4 */
X				if (rlogin (host, name, sizeof name))
X					preauth_flag++;
X
X				break;
X			case 'h':
X				hflg++;
X				reason = PW_TELNET;
X				STRFCPY (host, optarg);
X#ifdef	UT_HOST
X				STRFCPY (utent.ut_host, optarg);
X#endif	/*UT_HOST*/
X#ifdef	SVR4
X				STRFCPY (utxent.ut_host, optarg);
X#endif	/* SVR4 */
X				break;
X#endif	/*RLOGIN*/
X			default:
X				usage ();
X		}
X	}
X
X#ifdef	RLOGIN
X	/*
X	 * Neither -h nor -f should be combined with -r.
X	 */
X
X	if (rflg && (hflg || fflg))
X		usage ();
X#endif
X
X	/*
X	 * Allow authentication bypass only if real UID is zero.
X	 */
X
X	if ((rflg || fflg) && getuid () != 0) {
X		fprintf(stderr, "%s: permission denied\n", Prog);
X		exit (1);
X	}
X
X	if (! isatty (0) || ! isatty (1) || ! isatty (2))
X		exit (1);		/* must be a terminal */
X
X#ifdef	USE_SYSLOG
X	openlog (Prog, LOG_PID|LOG_CONS|LOG_NOWAIT, LOG_AUTH);
X#endif
X
X#ifndef	BSD
X	GTTY (0, &termio);		/* get terminal characteristics */
X
X	/*
X	 * Add your favorite terminal modes here ...
X	 */
X
X	termio.c_lflag |= ISIG;
X
X	termio.c_cc[VERASE] = getdef_num("ERASECHAR", '\b');
X	termio.c_cc[VKILL] = getdef_num("KILLCHAR", '\025');
X
X	/*
X	 * ttymon invocation prefers this, but these settings won't come into
X	 * effect after the first username login 
X	 */
X
X	STTY (0, &termio);
X#endif	/* !BSD */
X	umask (getdef_num("UMASK", 0));
X#ifdef HAVE_ULIMIT
X	{
X		/* 
X		 * Use the ULIMIT in the login.defs file, and if
X		 * there isn't one, use the default value.  The
X		 * user may have one for themselves, but otherwise,
X		 * just take what you get.
X		 */
X
X		long limit = getdef_long("ULIMIT", -1L);
X
X		if (limit != -1)
X			ulimit (2, limit);
X	}
X#endif
X
X	/*
X	 * The entire environment will be preserved if the -p flag
X	 * is used.
X	 */
X
X	if (pflg)
X		while (*envp)		/* add inherited environment, */
X			addenv (*envp++); /* some variables change later */
X
X#ifdef	RLOGIN
X	if (term[5] != '\0')		/* see if anything after "TERM=" */
X		addenv (term);
X#endif
X	/*
X	 * Add the timezone environmental variable so that time functions
X	 * work correctly.
X	 */
X
X	if (tmp = getenv ("TZ")) {
X		strcat (strcpy (buff, "TZ="), tmp);
X		addenv (buff);
X	} else if (cp = getdef_str ("ENV_TZ"))
X		addenv (*cp == '/' ? tz (cp):cp);
X
X	/* 
X	 * Add the clock frequency so that profiling commands work
X	 * correctly.
X	 */
X
X	if (tmp = getenv("HZ")) {
X		strcat (strcpy (buff, "HZ="), tmp);
X		addenv (buff);
X	} else if (cp = getdef_str("ENV_HZ"))
X		addenv (cp);
X
X	if (optind < argc) {		/* get the user name */
X		if (rflg || fflg)
X			usage ();
X
X#ifdef SVR4
X		/*
X		 * The "-h" option can't be used with a command-line username,
X		 * because telnetd invokes us as: login -h host TERM=...
X		 */
X
X		if (! hflg) {
X			STRFCPY (name, argv[optind]);
X			++optind;
X		}
X#else
X		STRFCPY (name, argv[optind]);
X		++optind;
X#endif
X	}
X#ifdef SVR4
X	/*
X	 * check whether ttymon has done the prompt for us already
X	 */
X
X	{
X	    char *ttymon_prompt;
X
X	    if ((ttymon_prompt = getenv("TTYPROMPT")) != NULL &&
X		    (*ttymon_prompt != 0)) {
X		login(name, 0);	/* read name, without prompt */
X	    }
X	}
X#endif /* SVR4 */
X	if (optind < argc)		/* now set command line variables */
X		    setenv (argc - optind, &argv[optind]);
X
Xtop:
X	(void) alarm (ALARM);		/* only allow ALARM sec. for login */
X
X	environ = newenvp;		/* make new environment active */
X	retries = RETRIES;
X	while (1) {	/* repeatedly get login/password pairs */
X		failed = 0;		/* haven't failed authentication yet */
X		pass[0] = '\0';
X
X		if (! name[0]) {	/* need to get a login id */
X			if (subroot) {
X#ifdef	USE_SYSLOG
X				closelog ();
X#endif
X				exit (1);
X			}
X#ifdef	RLOGIN
X			preauth_flag = 0;
X#endif
X			login (name, "login: ");
X			continue;
X		}
X		if (! (pwd = getpwnam (name))) {
X			pwent.pw_name = name;
X			pwent.pw_passwd = "!";
X			pwent.pw_shell = "/bin/sh";
X
X			preauth_flag = 0;
X			failed = 1;
X		} else {
X			pwent = *pwd;
X		}
X#ifdef	SHADOWPWD
X		if (pwd) {
X			if (! (spwd = getspnam (name)))
X#ifdef	USE_SYSLOG
X				syslog (LOG_WARN, NO_SHADOW, name, tty);
X#else
X				;
X#endif
X			else
X				pwent.pw_passwd = spwd->sp_pwdp;
X		}
X#endif	/* SHADOWPWD */
X#ifdef	RLOGIN
X		/*
X		 * If the encrypted password begins with a "!", the account
X		 * is locked and the user cannot login, even if they have
X		 * been "pre-authenticated."
X		 */
X
X		if (pwent.pw_passwd[0] == '!' || pwent.pw_passwd[0] == '*')
X			failed = 1;
X
X		/*
X		 * The -r and -f flags provide a name which has already
X		 * been authenticated by some server.
X		 */
X
X		if (preauth_flag)
X			goto have_name;
X#endif	/*RLOGIN*/
X
X		if (pw_auth (pwent.pw_passwd, name, reason, (char *) 0)) {
X#ifdef	USE_SYSLOG
X#ifdef UT_HOST
X			if (*(utent.ut_host))
X				syslog (LOG_WARN, BAD_PASSWD_HOST,
X					name, tty, utent.ut_host);
X			else
X#endif /* UT_HOST */
X#ifdef SVR4
X			if (*(utxent.ut_host))
X				syslog (LOG_WARN, BAD_PASSWD_HOST,
X					name, tty, utxent.ut_host);
X			else
X#endif /* SVR4 */
X				syslog (LOG_WARN, BAD_PASSWD,
X					name, tty);
X#endif /* USE_SYSLOG */
X			failed = 1;
X		}
X		goto auth_done;
X
X		/*
X		 * This is the point where all authenticated users
X		 * wind up.  If you reach this far, your password has
X		 * been authenticated and so on.
X		 */
X
Xauth_done:
X#ifdef	RLOGIN
Xhave_name:
X#endif
X		if (getdef_bool("DIALUPS_CHECK_ENAB")) {
X			alarm (30);
X
X			if (! dialcheck (tty, pwent.pw_shell[0] ?
X					pwent.pw_shell:"/bin/sh")) {
X#ifdef	USE_SYSLOG
X				syslog (LOG_WARN, BAD_DIALUP, name, tty);
X#endif
X				failed = 1;
X			}
X		}
X		if (getdef_bool("PORTTIME_CHECKS_ENAB") &&
X			! isttytime (pwent.pw_name, tty, time ((time_t *) 0))
X		) {
X#ifdef	USE_SYSLOG
X#ifdef UT_HOST
X			if (*(utent.ut_host))
X				syslog (LOG_WARN, BAD_TIME_HOST, name, tty,
X				    utent.ut_host);
X			else
X#endif	/* UT_HOST */
X#ifdef SVR4
X			if (*(utxent.ut_host))
X				syslog (LOG_WARN, BAD_TIME_HOST, name, tty,
X				    utxent.ut_host);
X			else
X#endif	/* SVR4 */
X				syslog (LOG_WARN, BAD_TIME, name, tty);
X#endif	/* USE_SYSLOG */
X				failed = 1;
X		}
X		if (! failed && pwent.pw_name && pwent.pw_uid == 0 &&
X				! console (tty)) {
X#ifdef	USE_SYSLOG
X			syslog (LOG_CRIT, BAD_ROOT_LOGIN, tty);
X#endif
X			failed = 1;
X		}
X		if (pwd && getdef_bool("FAILLOG_ENAB") && 
X				! failcheck (pwent.pw_uid, &faillog, failed)) {
X#ifdef	USE_SYSLOG
X			syslog (LOG_CRIT, FAILURE_CNT, name, tty);
X#endif
X			failed = 1;
X		}
X		if (! failed)
X			break;
X
X		puts ("Login incorrect");
X#ifdef	RLOGIN
X		if (rflg || fflg) {
X#ifdef	USE_SYSLOG
X			closelog ();
X#endif
X			exit (1);
X		}
X#endif	/*RLOGIN*/
X
X		/* don't log non-existent users */
X		if (pwd && getdef_bool("FAILLOG_ENAB"))
X			failure (pwent.pw_uid, tty, &faillog);
X		if (getdef_str("FTMP_FILE") != NULL) {
X#ifdef	SVR4
X			failent = utxent;
X#else
X			failent = utent;
X#endif
X
X			if (pwd)
X				STRFCPY (failent.ut_name, pwent.pw_name);
X			else
X				if (getdef_bool("LOG_UNKFAIL_ENAB"))
X					STRFCPY (failent.ut_name, name);
X				else
X					STRFCPY (failent.ut_name, "UNKNOWN");
X#ifdef	SVR4
X			gettimeofday (&(failent.ut_tv));
X#else
X			time (&failent.ut_time);
X#endif
X#ifdef	USG_UTMP
X			failent.ut_type = USER_PROCESS;
X#endif
X			failtmp (&failent);
X		}
X
X		if (--retries <= 0) {	/* only allow so many failures */
X#ifdef	USE_SYSLOG
X			closelog ();
X#endif
X			exit (1);
X		}
Xagain:
X		bzero (name, sizeof name);
X		bzero (pass, sizeof pass);
X
X		/*
X		 * Wait a while (a la SVR4 /usr/bin/login) before attempting
X		 * to login the user again.  If the earlier alarm occurs
X		 * before the sleep() below completes, login will exit.
X		 */
X
X		if (getdef_num ("FAIL_DELAY", 0))
X			sleep (getdef_num ("FAIL_DELAY", 0));
X	}
X	(void) alarm (0);		/* turn off alarm clock */
X
X	/*
X	 * Check to see if system is turned off for non-root users.
X	 * This would be useful to prevent users from logging in
X	 * during system maintenance.  We make sure the message comes
X	 * out for root so she knows to remove the file if she's
X	 * forgotten about it ...
X	 */
X
X	fname = getdef_str("NOLOGINS_FILE");
X	if (fname != NULL && access (fname, 0) == 0) {
X		FILE	*nlfp;
X		int	c;
X
X		/*
X		 * Cat the file if it can be opened, otherwise just
X		 * print a default message
X		 */
X
X		if (nlfp = fopen (fname, "r")) {
X			while ((c = getc (nlfp)) != EOF) {
X				if (c == '\n')
X					putchar ('\r');
X
X				putchar (c);
X			}
X			fflush (stdout);
X			fclose (nlfp);
X		} else
X			printf ("\r\nSystem closed for routine maintenance\r\n");
X		/*
X		 * Non-root users must exit.  Root gets the message, but
X		 * gets to login.
X		 */
X
X		if (pwent.pw_uid != 0) {
X  
X#ifdef	USE_SYSLOG
X			closelog ();
X#endif
X			exit (0);
X		}
X		printf ("\r\n[Disconnect bypassed -- root login allowed.]\r\n");
X	}
X	if (getenv ("IFS"))		/* don't export user IFS ... */
X		addenv ("IFS= \t\n");	/* ... instead, set a safe IFS */
X
X	setutmp (name, tty);		/* make entry in utmp & wtmp files */
X	if (pwent.pw_shell[0] == '*') {	/* subsystem root */
X		subsystem (&pwent);	/* figure out what to execute */
X		subroot++;		/* say i was here again */
X		endpwent ();		/* close all of the file which were */
X		endgrent ();		/* open in the original rooted file */
X#ifdef	SHADOWPWD
X		endspent ();		/* system.  they will be re-opened */
X#endif
X#ifdef	SHADOWGRP
X		endsgent ();		/* in the new rooted file system */
X#endif
X		goto top;		/* go do all this all over again */
X	}
X	if (getdef_bool("LASTLOG_ENAB"))
X		log ();			/* give last login and log this one */
X
X#ifdef SVR4_SI86_EUA
X	sysi86(SI86LIMUSER, EUA_ADD_USER);	/* how do we test for fail? */
X#endif
X
X	setup (&pwent);			/* set UID, GID, HOME, etc ... */
X#ifdef	AGING
X#ifdef	SHADOWPWD
X	if (spwd) {			/* check for age of password */
X		if (expire (&pwent, spwd)) {
X			spwd = getspnam (name);
X			pwd = getpwnam (name);
X			pwent = *pwd;
X		}
X	}
X#endif
X#ifdef	ATT_AGE
X#ifdef	SHADOWPWD
X	else
X#endif
X	if (pwent.pw_age && pwent.pw_age[0]) {
X		if (expire (&pwent, (void *) 0)) {
X			pwd = getpwnam (name);
X			pwent = *pwd;
X		}
X	}
X#endif	/* ATT_AGE */
X#endif	/* AGING */
X	if (! hushed (&pwent)) {
X		motd ();		/* print the message of the day */
X		if (getdef_bool ("FAILLOG_ENAB") && faillog.fail_cnt != 0)
X			failprint (&faillog);
X		if (getdef_bool ("LASTLOG_ENAB") && lastlog.ll_time != 0) {
X			printf ("Last login: %.19s on %s",
X				ctime (&lastlog.ll_time), lastlog.ll_line);
X#ifdef	SVR4
X			if (lastlog.ll_host[0])
X				printf(" from %.16s", lastlog.ll_host);
X#endif
X			printf("\n");
X		}
X#ifdef	AGING
X#ifdef	SHADOWPWD
X		agecheck (&pwent, spwd);
X#else
X		agecheck (&pwent, (void *) 0);
X#endif
X#endif	/* AGING */
X		mailcheck ();	/* report on the status of mail */
X	}
X	if (getdef_str("TTYTYPE_FILE") != NULL && getenv("TERM") == NULL)
X  		ttytype (tty);
X
X	signal (SIGINT, SIG_DFL);	/* default interrupt signal */
X	signal (SIGQUIT, SIG_DFL);	/* default quit signal */
X	signal (SIGTERM, SIG_DFL);	/* default terminate signal */
X	signal (SIGALRM, SIG_DFL);	/* default alarm signal */
X
X	endpwent ();			/* stop access to password file */
X	endgrent ();			/* stop access to group file */
X#ifdef	SHADOWPWD
X	endspent ();			/* stop access to shadow passwd file */
X#endif
X#ifdef	SHADOWGRP
X	endsgent ();			/* stop access to shadow group file */
X#endif
X#ifdef	USE_SYSLOG
X	if (pwent.pw_uid == 0)
X		syslog (LOG_NOTICE, ROOT_LOGIN, tty);
X
X	closelog ();
X#endif
X	shell (pwent.pw_shell, (char *) 0); /* exec the shell finally. */
X	/*NOTREACHED*/
X}
END_OF_FILE
  if test 19435 -ne `wc -c <'lmain.c'`; then
    echo shar: \"'lmain.c'\" unpacked with wrong size!
  fi
  # end of 'lmain.c'
fi
echo shar: End of archive 4 \(of 14\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
