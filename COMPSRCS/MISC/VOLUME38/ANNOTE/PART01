Newsgroups: comp.sources.misc
From: arrouye@cosmos.imag.fr (Yves Arrouye)
Subject: v38i005: annote - BibTeX styles supporting annotations, v1.5.1, Part01/04
Message-ID: <csm-v38i005=annote.135536@sparky.IMD.Sterling.COM>
X-Md4-Signature: d1fc33bb7d38c818c596af8f26976d65
Sender: kent@sparky.imd.sterling.com (Kent Landfield)
Organization: IMAG Institute, University of Grenoble
Date: Thu, 17 Jun 1993 18:55:55 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: arrouye@cosmos.imag.fr (Yves Arrouye)
Posting-number: Volume 38, Issue 5
Archive-name: annote/part01
Environment: LaTex
Supersedes: annote: Volume 37, Issue 57-59

This is version 1.5.1 of the `annote' package for BibTeX styles supporting 
annotations.

The package is intended to facilitate the use of annotated bibliographies
by enabling one to modify ``normal'' BibTeX styles in order to support
an `annote' field (like is available in Bibcard). The advantages of
this package over existing annotated bibliographies are twofold: users can
easily customize the annotation layout, and existing BibTeX styles can
be automatically modified in order to support the `annote' package.

Styles for BibTeX may be developped using the conventions of this
package, or existing style files may be converted to these
conventions. Automatic conversion of the files is available through
two interactive Emacs functions.
  
The `annotated' BibTeX styles support listing the bibliographies in
annotated or non-annotated forms without any further modifications;
instead, the user can include a style file defining his preferred
layout of annotations and use it on her bibliography. This layout is
easily modified by using a simple LaTeX \renewcommand.

This release contains the `annote' package and some example BibTeX
styles, including the ones bundled with the LaTeX distribution (i.e.
`plain.bst', `alpha.bst', `unsrt.bst' and `abbrv.bst'); these BibTeX
styles were all modified to support `annote', some by hand when
annotebib.el wasn't wrote, the other with annotebib.el.

Simple documentation is in the `annote.README' file.

Yves Arrouye <arrouye@imag.imag.fr>
June, 1993
---------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  NEWS ANNOUNCE README IDEAS ChangeLog annotebib.add
#   Makefile sample.tex sample.bib compile-annote.el annotebib.el
#   annote.sty commentaire.sty
# Wrapped by arrouye@cosmos on Tue Jun  8 13:47:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'NEWS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'NEWS'\"
else
echo shar: Extracting \"'NEWS'\" \(1272 characters\)
sed "s/^X//" >'NEWS' <<'END_OF_FILE'
XThis file documents changes between distributions of annotebib.
X
XVersion 1.5  Second post (patch). This release is the first really
X	     "stable" version of annotebib (it contains big
X	     changes/improvements, but future patches will not be as
X	     big as this one).
X
X	       Support for multiple annotation fields. This was
X             possible in the BibTeX styles, but no automated supported
X             was provided in the Emacs Lisp package.
X               Functions to remove annotation fields from an annotated
X             style (in a buffer or a file).
X	       Support to write a LaTeX style.
X               Functions to automate the modification (annotation or
X             unannotation) of a bunch of BibTeX styles, and to write
X             the associated LaTeX style files.
X	       Much better error handling, better default values,
X             confirmation asked for overwriting or other potentially
X             dangerous things.
X	       For some functions (annote-make-*, annote-*file*),
X	     errors triggered by called functions are summarized in the
X             annote-errors variable after execution (actually, it is a
X	     quick hack that will be improved in a future release).
X
XVersion 1.0  Initial post.
X
X
XYves Arrouye
Xarrouye@imag.imag.fr
END_OF_FILE
if test 1272 -ne `wc -c <'NEWS'`; then
    echo shar: \"'NEWS'\" unpacked with wrong size!
fi
# end of 'NEWS'
fi
if test -f 'ANNOUNCE' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ANNOUNCE'\"
else
echo shar: Extracting \"'ANNOUNCE'\" \(1767 characters\)
sed "s/^X//" >'ANNOUNCE' <<'END_OF_FILE'
XAnnouncing the v1.5 `annote' package for BibTeX styles supporting annotations
X-----------------------------------------------------------------------------
X
XThe package is intended to facilitate the use of annotated bibliographies
Xby enabling one to modify ``normal'' BibTeX styles in order to support
Xan `annote' field (like is available in Bibcard). The advantages of
Xthis package over existing annotated bibliographies are twofold: users can
Xeasily customize the annotation layout, and existing BibTeX styles can
Xbe automatically modified in order to support the `annote' package.
X
XStyles for BibTeX may be developped using the conventions of this
Xpackage, or existing style files may be converted to these
Xconventions.
X  An Emacs Lisp package is distributed to help making changes to the
XBibTeX styles (add or remove annotation fields) and to generate
Xappropriate LaTeX styles in order to print the annotations.
X  Releases past v1.0 have support for more than one annotation field
Xin a BibTeX style.
X  
XThe `annotated' BibTeX styles support listing the bibliographies in
Xannotated or non-annotated forms without any further modifications;
Xinstead, the user can include a style file defining his preferred
Xlayout for a given annotation field and use it on her bibliography.
XThis layout is easily modified by using a simple LaTeX \renewcommand.
X
XThis release contains the `annote' package and some example BibTeX
Xstyles, including the ones bundled with the LaTeX distribution (i.e.
X`plain.bst', `alpha.bst', `unsrt.bst' and `abbrv.bst'); these BibTeX
Xstyles were all modified to support `annote', some by hand when
Xannotebib.el wasn't wrote, the other with annotebib.el.
X
XSimple documentation is in the `README' file.
X
XYves Arrouye <arrouye@imag.imag.fr>
XMay, 1993
END_OF_FILE
if test 1767 -ne `wc -c <'ANNOUNCE'`; then
    echo shar: \"'ANNOUNCE'\" unpacked with wrong size!
fi
# end of 'ANNOUNCE'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1868 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the ``annote'' package, which provides a simple and convenient
Xway to add support for annotated bibliographies to LaTeX.
X
XThis package provides you with:
X
X  1. A generic way to add annotation capacities to your BibTeX styles.
X
X  2. An automated way of modifying your existing files.
X
X  3. A style of annotations which can be redefined by the user.
X
X
XTo make the package work, one has to make the following steps:
X
X  1. Change the .bst files to add support for annotation. This is done
X     by adding the annote field in the ENTRY list, adding the
X     format.annote function to the style file, and changing the
X     fin.entry (or the corresponding entry-closing function) by adding
X     a call to format.annote at the end of the function, followed by a
X     write$ call.
X       See the "annotebib.add" file for the source of the modifications.
X
X     * This step can be automated on most bibliography styles with the
X     use of the `annotebib.el' functions. It is the preferred (and
X     painless) way to make such modifications.
X
X  2. Install "annote.sty" in one of your LaTeX directories (one which
X     is listed in the TEXINPUTS environment variable).
X
X  3. Use it! Just add annote to your \documentstyle options when you
X     need it, or define the annote environment in your document, or
X     make that definition (the one you prefer, of course) a new .sty
X     file...
X
X       For example, to have annotations printed as quotations in
X     emphasized typeface, just say
X
X	  \newenvironment{annote}{\begin{quotation}\em}{\end{quotation}}
X
X     in your document, before the \bibliography statement.
X
X  NOTE. The modifications here use the "annote" field of the .bib
X        file, which can be easily edited with BibCard (menu "View",
X        item "Annotation..."), but one can easily change that field.
X
X
XYves Arrouye (arrouye@imag.imag.fr)
XMay 12, 1993
X
END_OF_FILE
if test 1868 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'IDEAS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'IDEAS'\"
else
echo shar: Extracting \"'IDEAS'\" \(728 characters\)
sed "s/^X//" >'IDEAS' <<'END_OF_FILE'
XThis file is intended to hold ideas for future enhancements of the
X`annote' package. If you have such ideas, please complete this file
Xand email it to the author, Yves Arrouye <arrouye@imag.imag.fr>
X
X1. Make an elaborated \cite command which takes an optional parameter
X   saying if we really want the annotation. This may be used in a
X   bibliography where related items (with similar annotations) are
X   \cite'd, but we do want only one annotation to appear.
X
X2. In the Elisp package, use programmed completion to let the user
X   choose the values between all the field names in the user variable
X   annote-default-annote-fields. Then, instead of inserting the
X   contents of the variable, let the user play with completion.
X
END_OF_FILE
if test 728 -ne `wc -c <'IDEAS'`; then
    echo shar: \"'IDEAS'\" unpacked with wrong size!
fi
# end of 'IDEAS'
fi
if test -f 'ChangeLog' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ChangeLog'\"
else
echo shar: Extracting \"'ChangeLog'\" \(6480 characters\)
sed "s/^X//" >'ChangeLog' <<'END_OF_FILE'
XTue Jun  8 13:34:56 1993  Yves.Arrouye  (arrouye@cosmos)
X
X	* Makefile: added a target to build the supplied sample file.
X
X	* annotebib.el: Revision 1.5.1
X	Fixed a bug which cause interactively-called functions annote-file
X	and unannote-file to take the filename of the current buffer if no
X	savefile was given, instead of the name of the original file.
X	  Added backup support with the annote-backup-* variables.
X	(annote-internal-ab): Fixed a typo which caused an error from
X	BibTeX, complaining about an undefined p function.
X	(annote-internal-of): Now expand the filenames.
X	(annote-internal-ws): Id.
X	
X
XWed May 19 10:49:26 1993  Yves.Arrouye  (arrouye@cosmos)
X
X	* annotebib.el: (Still 1.5)
X	(annote-internal-ob): Same principle as for annote-internal-of,
X	but for buffers. Is used by annote-buffer and annote-unannote-buffer.
X	which were rewritten.
X	(annote-buffer): See above.
X	(annote-unannote-buffer): See above.
X	(annote-accessible-BibTeX-styles): now takes three optional
X	parameters, which are the path, path-sep and regexp.
X	(annote-make-annotated): The file list may be a path (string) in a
X	non-interactive-call.
X	(annote-make-unannotated): Same as annote-make-annotate, except
X	that it removes annotation fields. (The implementation is a copy
X	of the first function with little change: it's bad).
X	Made the file-list an optional argument in both functions.
X	Improved errors in the *-make-* functions.
X
XTue May 18 11:48:16 1993  Yves Arrouye  (arrouye@chergui)
X
X        * annotebib.el: Revison 1.5.
X	Better error handling so that when processing
X	multiple files an error will not prevent processing the other.
X	The function now return a summary of errors... All functions use
X	the same construction, but code is duplicated. The functions are
X	annote-buffer (and so annote-file), annote-unannote-buffer and
X	annote-write-styles.
X	(annote-internal-of): Used to work on files.
X	(annote-unannote-file): New function for annotating a style file.
X	Use annote-internal-of.
X	(annote-file): Rewritten to use annote-internal-of (in fact,
X	annote-internal-of is the body of the old annote-file function,
X	without the interactive clause, and with a functional parameter).
X	(annote-accessible-BibTeX-styles): give all accessible BibTeX
X	styles, using the defaul BibTeX path, path separator, and style
X	file extension. Use annote-directory-files-matching and
X	annote-path-files-matching.
X	* annotebib.el: Added two functions to help system managers
X	convert a bunch of styles in a single command.
X	(annote-make-annotated): Ask interactively for all BibTeX
X	style files, the annotation fields, and annote the styles and
X	generate the LaTeX styles.
X	(annote-read-file-names): Ask for a list of files (much like
X	read-file-name).
X
XMon May 17 16:27:14 1993  Yves Arrouye  (arrouye@mistral)
X
X	* annotebib.el: Revision 1.4, support for simultaneous entries,
X	thus allowing the user to specify more than one field in a command.
X	(annote-buffer): Simple use.
X	(annote-file): Id. Calls annote-buffer so no problem here.
X	(annote-write-styles): New name for the old annote-write-style
X	function. The function does not ask for a file name anymore, but
X	rather uses the annotation fields names and the
X	annote-LaTeX-style-prefix and annote-LaTeX-style-suffix user
X	variables to build the style file name.
X	(annote-unnanote-buffer): Field name now defaults to the entire
X	list of annotation fields found in the buffer. If called
X	interactively, prompts with the last inserted field (i.e. the one
X	just before the fin.entry FUNCTION).
X
X	* annotebib.add : Reflected the name change.
X
X	* annotebib.el: For more robustness, changed the
X	`format.FIELD' name of the function to
X	`annotebib.format.FIELD', and 	used a search for that
X	FUNCTION to build the list of annotation fields. The list should
X	be good even if someone deleted the comments. But the comments are
X	looked for before.
X	Moved the `annotebib.format.' part of the name in the
X	annote-func-prefix variable.
X
X	* annotebib.el: Revision 1.3, support for unannotating a file.
X	(annote-unannote-buffer): New function to remove an annotation.
X	annote-ask-interactively: New variable controlling wether to ask
X	something interactively.
X	(annote-write-file): Write a style file. Overwrites if wanted, or
X	ask for confirmation if annote-ask-interactively is true;
X	otherwise, fail when the file/buffer existed.
X	(annote-buffer): Now one does not have to Undo! a change if the
X	function fails while editing in-place.
X
XFri May 14 11:19:24 1993  Yves.Arrouye  (arrouye@cosmos)
X
X	* annotebib.el:
X	(annnote-insert-style): If the buffer we are inserting in is
X	currently visiting a file, and if this file's name ends in
X	annote-LaTeX-style-extension, use the nondirectory part of the
X	filename without the extension as the annotation field name.
X	The code nows supplies default values for nil values or blank strings.
X	(annote-buffer): Bhe annote field gets a default value if its nil
X	or a blank string. For the filenames, however, you can save under
X	a filename which is " " for example (not really good if you want
X	to find it easily in a directory listing :-) 
X
XThu May 13 17:12:37 1993  Yves.Arrouye  (arrouye@cosmos)
X
X	* annotebib.el: Revision 1.2, support for multiple annotation fields.
X	Added the annote-default-annote-field (defaulting to "annote") in
X	the user variables list.
X	(annote-buffer): Has now two optional arguments, the first one
X	being the name of the annotation field (defaults to
X	annote-default-annote-field), the second one being the in-place
X	parameter. updated the documentation string, and added
X	instructions for setup with autoload.
X	Modified the comment saying that the style changed so that it
X	includes the version of annotebib.el and the name of the
X	annotation field.
X	Issues a message if no modifications were necessary.
X	Changed the return value when no changes are necessary.
X	Tries to be smart enough so that it will not clobber the file with
X	advertising that the style is now `annote'-compatible.
X	(annote-file): If the file was already visited, saves it modified
X	status, otherwise don't save unless success (i.e. modified).
X	Do not destroy the buffer if it was here before the call to the
X	function (it was not very smart ;-)
X	make a copy of the buffer if visited but saved under another name.
X	(annote-insert-style): new function to produce the text for a
X	style file. Asks for annotation field name, and start and end of
X	the environment. If called non-interactively, uses default from
X	user variables.
END_OF_FILE
if test 6480 -ne `wc -c <'ChangeLog'`; then
    echo shar: \"'ChangeLog'\" unpacked with wrong size!
fi
# end of 'ChangeLog'
fi
if test -f 'annotebib.add' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annotebib.add'\"
else
echo shar: Extracting \"'annotebib.add'\" \(658 characters\)
sed "s/^X//" >'annotebib.add' <<'END_OF_FILE'
X% annotebib.add: what to add/change to a .bst file to support annotations
X%
X% Yves Arrouye (arrouye@imag.imag.fr)
X%
X% April 13, 1993
X
X% You have to add the following field to the ENTRY list (after the
X% address field)
X
Xannote
X
X% This function has to be added to your .bst file
X
XFUNCTION {annotebib.format.annote}
X{ annote empty$
X	{ "" }
X        { "\ifx\annote\undefined\else\begin{annote} "
X	  annote
X	  * " \end{annote}\fi " *
X	}
X      if$
X}
X
X% The fin.entry function is changed to call annotebib.format.annote just before
X% the end (closing brace) of the function.
X
XFUNCTION {fin.entry}
X{ add.period$
X  write$
X  newline$
X  annotebib.format.annote write$
X}
END_OF_FILE
if test 658 -ne `wc -c <'annotebib.add'`; then
    echo shar: \"'annotebib.add'\" unpacked with wrong size!
fi
# end of 'annotebib.add'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1598 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XBST = *.bst
XSTY = *.sty
X
XBST2= abbrv.bst alpha.bst
XBST3= plain.bst unsrt.bst apalike.bst
XBST4= siam.bst fsiam.bst lsiam.bst
X
XOTH = NEWS ANNOUNCE README IDEAS ChangeLog annotebib.add Makefile sample.tex \
X      sample.bib compile-annote.el
XEL  = annotebib.el
XELC = annotebib.elc
XELP = $(EL) $(ELC)
X
XALL = $(OTH) $(STY) $(ELP) $(BST)
X
XBSTDIR = /usr/local/lib/tex/inputs
XSTYDIR = /usr/local/lib/tex/inputs
XOTHDIR = $(STYDIR)/documents
XELPDIR = /usr/local/src/Gnu/Emacs18/local-lisp
X
XSHRDIR = NOT-DIST
X
XLATEX  = latex
XBIBTEX = bibtex
X
Xsample: sample.dvi
Xsample.dvi: sample.tex sample.bib
X	$(LATEX) sample
X	-$(BIBTEX) sample
X	$(LATEX) sample
X	$(LATEX) sample
X
Xshar: manifest shar1 shar2 shar3 shar4
Xmanifest:
X	@echo creating $(SHRDIR)/MANIFEST
X	@echo 'Contents of the 4 archives of the `annote'"'"' package' \
X	      >$(SHRDIR)/MANIFEST
X	@echo >>$(SHRDIR)/MANIFEST
X	@echo "Archive 1: " $(OTH) $(ELP) $(STY) >>$(SHRDIR)/MANIFEST
X	@echo "Archive 2: " $(BST2) >>$(SHRDIR)/MANIFEST
X	@echo "Archive 3: " $(BST3) >>$(SHRDIR)/MANIFEST
X	@echo "Archive 4: " $(BST4) >>$(SHRDIR)/MANIFEST
X	@echo >>$(SHRDIR)/MANIFEST
X
Xshar1:
X	shar $(OTH) $(EL) $(STY) >$(SHRDIR)/annote.shar.part1
Xshar2:
X	shar $(BST2) >$(SHRDIR)/annote.shar.part2
Xshar3:
X	shar $(BST3) >$(SHRDIR)/annote.shar.part3
Xshar4:
X	shar $(BST4) >$(SHRDIR)/annote.shar.part4
X
Xannotebib.elc: annotebib.el
X	emacs -batch -l compile-annote.el
X
Xinstall: annotebib.elc
X	install -c -m 664 $(BST) $(BSTDIR)
X	install -c -m 664 $(STY) $(BSTDIR)
X	install -c -m 664 $(ELP) $(ELPDIR)
X	$(RM) -f $(ELC)
X	for i in $(OTH); do install -c -m 664 $$i $(OTHDIR)/annote.$$i; done
X
END_OF_FILE
if test 1598 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'sample.tex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.tex'\"
else
echo shar: Extracting \"'sample.tex'\" \(973 characters\)
sed "s/^X//" >'sample.tex' <<'END_OF_FILE'
X% sample.tex: a test for the `annote' package. Assume that you are
X% using an annote-compatible `plain.bst' BibTeX style.
X
X% To format: latex sample
X%            bibtex sample
X%            latex sample
X%            latex sample
X
X% Yves Arrouye
X% May, 1993
X
X% The companion bibliography has two annotation fields in it:
X% `commentaire' is in french, `annote' is in english. Not all entries
X% have both fields...
X
X% Delete `commentaire' from the \documentstyle options if you don't
X% want to have french commentaires in the bibliography.
X
X\documentstyle[a4,commentaire,refrench]{article}
X%
X\def\BibTeX-style{alpha}
X%
X\begin{document}
X\section*{Testing the `annote' package with {\tt \BibTeX-style.bst}}
X% Here is an annote environment, comment it to not look at the english
X% annotations of the bibliography. 
X\newenvironment{annote}{\begin{quote}\em [English here]\ }{\end{quote}}
X% Cite all
X\nocite{*}
X\bibliography{sample}
X\bibliographystyle{\BibTeX-style}
X\end{document}
END_OF_FILE
if test 973 -ne `wc -c <'sample.tex'`; then
    echo shar: \"'sample.tex'\" unpacked with wrong size!
fi
# end of 'sample.tex'
fi
if test -f 'sample.bib' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sample.bib'\"
else
echo shar: Extracting \"'sample.bib'\" \(5672 characters\)
sed "s/^X//" >'sample.bib' <<'END_OF_FILE'
X
X
X@manual{gnu:lew90el,
X   author = {Bil Lewis and Dan {LaLiberte} and {the GNU Manual Group}},
X   address = {675 Mass Ave, Cambridge, MA 02139},
X   edition = {1.03},
X   month = dec,
X   organization = {Free Software Foundation},
X   title = {{GNU Emacs Lisp Reference Manual}},
X   year = {1990},
X   commentaire = {Manuel de r\'ef\'erence d'Elisp (pour Emacs Lisp), le Lisp sp\'ecialis\'e int\'egr\'e \`a
XEmacs. Ce Lisp permet d'\'etendre facilement les fonctionnalit\'es d'Emacs, et dispose, outre les primitives Lisp ``classiques'', d'un tr\`es grand nombre de primitives sp\'ecialis\'ees dans la gestion de l'\'edition (insertion, destruction, recherche et remplacement de cha\^\i{}nes et d'expressions r\'eguli\`eres, gestion des modes et fen\^etres d'Emacs, etc\ldots{}), la manipulation de fichiers et la gestion de processus ``attach\'es'' \`a Emacs.},
X   annote = {Reference Manual for Elisp (standing for Emacs Lisp), the specialized Emacs built-in Lisp. This Lisp allows one to easily extend Emacs' functionalities, and gives, besides the ``classical'' Lisp primitives, a lot of primitives specialized in editing tasks (insert, delete, search and replace of strings and regular expressions, modes and windows management etc\ldots{}), file management or ``attached'' processes management.}
X}
X
X@manual{gnu:sta92em,
X   author = {Richard M. Stallman},
X   address = {675 Mass Ave, Cambridge, MA 02139},
X   edition = {7},
X   month = sep,
X   note = {Emacs Version 18.58},
X   organization = {Free Software Foundation},
X   title = {{GNU Emacs Manual}},
X   year = {1992},
X   commentaire = {Emacs est un \'editeur de texte extr\^emement puissant, facilement extensible gr\^ace au
XLisp sp\'ecialis\'e qui lui est int\'egr\'e et qui permet de reprogrammer enti\`erement
Xles fonctionnalit\'es de l'\'editeur, ainsi que d'en ajouter de nouvelles.
X\par 
XIl est possible de trouver un ``mode'' Emacs pour faciliter \`a peu pr\`es n'importe quelle
Xt\^ache d'\'edition, que ce soit de la saisie de texte dans un langage donn\'e ou
Xl'interaction avec un logiciel complexe\ldots{}}
X}
X
X@article{lng:lib91a,
X   author = {Don Libes},
X   journal = {Computing Systems},
X   number = {2},
X   pages = {99-125},
X   title = {{expect: Scripts for Controlling Interactive Processes}},
X   volume = {4},
X   year = {1991},
X   commentaire = {Le langage expect est bas\'e sur Tcl, auquel il ajoute la possibilit\'e de contr\^oler n'importe quel programme Unix, interactif ou non, sous forme de processus attach\'e au programme expect.
X\par
XComme Tcl, expect peut \^etre inclus dans une application, lui apportant alors de grandes facilit\'es d'extension.
X\par 
XCet article pr\'esente le langage en donnant un certain nombre de scripts utilis\'es dans des domaines vari\'es (administration syst\`eme, s\'ecurit\'e, jeux (!), communication,
X\ldots{}).
X}
X}
X
X@techreport{lng:lib91b,
X   author = {Don Libes},
X   address = {Gaithesburg, MD},
X   institution = {National Institute of Standards and Technology},
X   number = {NIST IR 744-91},
X   title = {{expect User Manual}},
X   year = {1991},
X   commentaire = {Le langage expect est bas\'e sur Tcl, auquel il ajoute la possibilit\'e de contr\^oler n'importe quel programme Unix, interactif ou non, sous forme de processus attach\'e au programme expect.
X\par 
XComme Tcl, expect peut \^etre inclus dans une application, lui apportant alors de grandes facilit\'es d'extension.
X}
X}
X
X@inproceedings{lng:ous90,
X   author = {John Ousterhout},
X   booktitle = {{Proceedings of the Winter 1990 USENIX Conference}},
X   crossref = {prc:usenix90w},
X   title = {{Tcl: An Embeddable Command Language}},
X   year = {1990},
X   commentaire = {Tcl est un langage destin\'e \`a \^etre inclus dans des applications afin de leur fournir un langage int\'egr\'e simple et puissant.
X\par 
XUne fois le langage ajout\'e \`a l'application, celle-ci fournit un certain nombre de points d'entr\'ee vers ses fonctionnalit\'es, qui peuvent alors \^etre utilis\'ees par un simple appel proc\'edural dans les programmes que l'utilisateur \'ecrit en Tcl.
X\par 
XTcl a \'et\'e utilis\'e dans beaucoup d'applications, dont un \'editeur de texte enti\`erement reconfigurable et programmable, Point, qui utilise Tcl et son extension pour X, Tk.}
X}
X
X@inproceedings{lng:bir92,
X   author = {J. J. Birchman and S. L. Tanimoto},
X   title = {{An Implementation of the VIVA Visual Language on the NeXT Computer}},
X   year = {1992},
X   commentaire = {VIVA est un langage de programmation visuelle destin\'e au traitement d'image. Il utilise des ic\^ones pour repr\'esenter les op\'erateurs de traitement d'image, et des arcs orient\'es pour repr\'esenter le flot de donn\'es (images) entre les op\'erateurs.
X\par 
XLe syst\`eme est organis\'e en deux niveaux accompagn\'es d'un certain nombre de modules. Le niveaux sup\'erieur est la pr\'esentation de l'environnement de programmation \`a l'utilisateur, lui permettant de cr\'eer, modifier, sauver et ex\'ecuter ses programmes. Le niveau inf\'erieur est la structure interne du langage, qui g\`ere la programmation visuelle, le d\'eclenchement des op\'erateurs \`a l'arriv\'ee de nouvelles donn\`ees, et la gestion des ic\^ones (op\'erateurs).
X\par 
XVIVA propose un mod\`ele synchrone de flot de donn\'ees, dans un environnement ``pleinement vivant'', i.e. refl\'etant \`a tout moment l'\'etat du syst\`eme et les actions de l'utilisateur.
X\par 
XVIVA a \'et\'e d\'evelopp\'e pour faciliter l'apprentissage des techniques d'imagerie m\'edicale par des m\'edecins sans connaissances informatiques.}
X}
X
X@proceedings{prc:usenix90w,
X   address = {Washington, DC},
X   month = jan,
X   title = {{Proceedings of the Winter 1990 USENIX Conference}},
X   year = {1990}
X}
END_OF_FILE
if test 5672 -ne `wc -c <'sample.bib'`; then
    echo shar: \"'sample.bib'\" unpacked with wrong size!
fi
# end of 'sample.bib'
fi
if test -f 'compile-annote.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'compile-annote.el'\"
else
echo shar: Extracting \"'compile-annote.el'\" \(70 characters\)
sed "s/^X//" >'compile-annote.el' <<'END_OF_FILE'
X;;; compile the annotebib.el file
X
X(byte-compile-file "annotebib.el")
END_OF_FILE
if test 70 -ne `wc -c <'compile-annote.el'`; then
    echo shar: \"'compile-annote.el'\" unpacked with wrong size!
fi
# end of 'compile-annote.el'
fi
if test -f 'annotebib.el' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annotebib.el'\"
else
echo shar: Extracting \"'annotebib.el'\" \(44921 characters\)
sed "s/^X//" >'annotebib.el' <<'END_OF_FILE'
X;;;; annotebib.el, v1.5.1
X;;;;
X;;;; Transform a bibliography style so that it is compatible with the
X;;;; conventions used by my `annote' package.
X;;;;
X;;;; Version 1.5.1 corrects a bug in the annote.format.* functions: a
X;;;; p (a mystyped C-p under emacs!) preceded the if$ at the end of
X;;;; the functions, making BibTeX complains about such an undefined
X;;;; function!
X;;;;   It also correct a bug when reading the "Save file: " filenames:
X;;;; if the answer was RET and the current buffer (in interactive use)
X;;;; had a filename, then this filename was used to save instead of
X;;;; the default save filename.
X;;;;   Automatic backup of files is also supported. The default value
X;;;; of annote-backup-files is nil (because most people use automatic
X;;;; backup so there is no need fo the annote one), and the files
X;;;; are backuped by adding the ".orig" suffix to the file name.
X;;;;
X;;;; Version 1.5 completes the package with annote-unannote-file and
X;;;; annote-make-unannotated; I also made some rewriting and wrote
X;;;; error handlers in functions iterating over multiple calls to basic
X;;;; functions. New error handling/remembering. For functions handling
X;;;; multiple operations, a summary of errors is available in the
X;;;; annote-errors variable after completion.
X;;;;
X;;;; Version 1.4 supports multiple field names with a single command,
X;;;; with every command except for annote-insert-style. It also adds
X;;;; `bunch-processing' functions to the package.
X;;;;
X;;;; Version 1.3 has bug fixes, and new support for writing LaTeX and
X;;;; (more useful!) unannotating a BibTeX style file.
X;;;;
X;;;; Version 1.2 supports multiple annotation fields, recognition of
X;;;; already-annotated files, and new features (annote-insert-style,
X;;;; and new user variables). The functions accept default values
X;;;; taken from user variables (when called with blank or nil
X;;;; variables or with prefix arguments).
X;;;;   Started to use a ChangeLog, so the comments below (except for
X;;;; autoloading) are not maintained now.
X;;;;
X;;;; Version 1.0 was very simple...
X;;;;
X;;;;
X;;;; Yves Arrouye (arrouye@imag.imag.fr), May 1993 -- June 1993.
X
X(provide 'annotebib)
X
X;;;; Installation with autoload. Put the following lines in your
X;;;; .emacs or site-init.el file, and uncomment them:
X;;;;
X;;;;   (autoload 'annote-buffer "annotebib"
X;;;;     "Annote the bibliography style in the optionnaly specified
X;;;;   buffer (or current if called interactively). The first argument
X;;;;   (asked interactively for) is the list of annotation fields
X;;;;   names. It defaults to the value of the user variable
X;;;;   annote-default-annote-fields.  It may be a list or a string
X;;;;   with multiple names.
X;;;;
X;;;;   The buffer is edited in place if the in-place argument is
X;;;;   non-nil, or if a negative prefix argument is given. The default
X;;;;   value for the annotation field(s) name(s) is taken from the
X;;;;   annote-default-annote-fields if the given name is nil or blank,
X;;;;   or if the function is called interactively with a numeric
X;;;;   prefix argument which is not `-' nor nil.
X;;;;
X;;;;   The function does nothing if the buffer already supports (or
X;;;;   looks like it does support) `annote' for the given field.
X;;;;
X;;;;   Return the success of the modification, or the list
X;;;;   '(no-change-for \"<annote-fields>\") if already supporting
X;;;;   `annote' for the given field.")
X;;;;
X;;;;   (autoload 'annote-unannote-buffer "annotebib"
X;;;;     "Unannote the bibliography style in the optionnally specified
X;;;;   buffer (or current if called interactively).  The first
X;;;;   argument (asked interactively for) is the list of annotation
X;;;;   fields names. It defaults to the list of all annotations names
X;;;;   in the buffer. It may be a list or a string with multiple
X;;;;   names.
X;;;;
X;;;;   The buffer is edited in place if the in-place argument is
X;;;;   non-nil, or if a negative prefix argument is given. The default
X;;;;   value for the annotation field(s) name(s) is taken from the
X;;;;   annote-default-annote-fields if the given name is nil or blank,
X;;;;   or if the function is called interactively with a numeric
X;;;;   prefix argument which is not `-' nor nil.
X;;;;
X;;;;   The function does nothing if the buffer does not support (or
X;;;;   looks like it does not support) `annote' for the given field.
X;;;;
X;;;;   Return the success of the modification, or the list
X;;;;   '(no-change-for \"<annote-fields>\") if non supporting `annote'
X;;;;   for the given field.")
X;;;;
X;;;;   (autoload 'annote-file "annotebib"
X;;;;     "Annote a file. If called interactively, asks for an existing
X;;;;   filename, for the name(s) of the annotation field(s), and then for
X;;;;   the name of the annotated file. If this name is a directory,
X;;;;   then the name of the file will be the filename of the original
X;;;;   file in this directory, unless the directories are the same, in
X;;;;   which case the original file will have the value of
X;;;;   annote-savefile-prefix prefixed to it. If the buffer was
X;;;;   already visited, it is not destroyed.
X;;;;
X;;;;   If a numeric prefix argument is given, or if the name of the
X;;;;   annotation field is blank, the default value is taken from the
X;;;;   annote-default-annote-fields user variable.
X;;;;
X;;;;   If annote-buffer fails on the loaded file, it is not saved.
X;;;;   Return success as got from annote-buffer.")
X;;;;
X;;;;   (autoload 'annote-insert-style "annotebib"
X;;;;     "Insert the text of a LaTeX style file for an environment
X;;;;   used to display an annotation field.
X;;;;
X;;;;   Arguments are the name of the annotation field, and LaTeX code
X;;;;   to start and end the environment. If the annotation field is
X;;;;   not given or blank, the function will try to guess it from the
X;;;;   name of the visited file if any. In other cases, and for the
X;;;;   other arguments, default values from the user variables will be
X;;;;   used.
X;;;;
X;;;;   If called interactively with a non-nil prefix argument, default
X;;;;   values will be used.")
X;;;;
X;;;;   (autoload annote-write-styles "annotebib"
X;;;;     "Write one or more files with the text of a LaTeX style file
X;;;;   for an environment used to display an annotation field.
X;;;;
X;;;;    Arguments are the name(s) of the annotation field(s), and
X;;;;   LaTeX code to start and end the environment. The names of the
X;;;;   fields may be given as a list of strings or a single strings
X;;;;   with multiple names in it.  If an argument is not given,
X;;;;   default values from the user variables will be used.
X;;;;
X;;;;    The function writes a file for each environment, prefixing the
X;;;;   contents of annote-LaTeX-style-prefix to the annotation field
X;;;;   name, and adding the annote-LaTeX-style-suffix to it.
X;;;;
X;;;;   If called interactively with a non-nil prefix argument, default
X;;;;   values will be used. If the last argument is non-nil or a
X;;;;   negative prefix argument is given, an existing file will be
X;;;;   overwritten; otherwise, no changes are made to the contents of
X;;;;   that file.")
X;;;;
X;;;;   (autoload 'annote-make-annotated "annotebib"
X;;;;     "Make a full annotated distribution. Gets the list of BibTeX
X;;;;   files to annotate, the list of annotation fields. Annotate the
X;;;;   BibTeX files and save them, then write the LaTeX style files
X;;;;   (asking for confirmation depending on the value of the
X;;;;   overwrite flag, see annote-write-styles.  Note that the style
X;;;;   files will all define the same environment (if you want
X;;;;   different environments, you will have to call annote-file
X;;;;   followed by as much annote-write-styles as you want different
X;;;;   environments, but this is not painful, really...).
X;;;;
X;;;;   When called interactively, the list of BibTeX files is asked
X;;;;   for, and one ends it by answering RET to the prompt. If a
X;;;;   prefix argument is given, it is used as in annote-write-styles
X;;;;   for the default values and overwrite argument.
X;;;;
X;;;;   In a non-interactive call, the file list may be a string,
X;;;;   which is assumed to be a path of directories in which to get
X;;;;   the the BibTeX files.")
X;;;;
X;;;;   (autoload 'annote-make-unannotated "annotebib"
X;;;;     "Unannote a list of files. Gets the list of BibTeX files to
X;;;;   annotate, the list of annotation fields. Unannotate the BibTeX
X;;;;   files and save them.
X;;;;
X;;;;   When called interactively, the list of BibTeX files is asked
X;;;;   for, and one ends it by answering RET to the prompt. If the
X;;;;   list is empty, it defaults to all accessible BibTeX style
X;;;;   files.
X;;;;
X;;;;   In a non-interactive call, the file list may be a string, which
X;;;;   is assumed to be a path of directories in which to get the the
X;;;;   BibTeX files.")
X
X;;;; The functions follow the guidelines found in annotebib.add: they
X;;;; look for the ENTRY declaration, add the `annote' field, then look
X;;;; for the fin.entry FUNCTION and add the `annotebib.format.annote' FUNCTION
X;;;; before it, then add a call to `annotebib.format.annote' at the end of
X;;;; `fin.entry'.
X;;;;
X;;;; The modifications are done in a separate buffer by default, then
X;;;; this buffer is copied into the original one. This means that the
X;;;; modification is undoable by a single undo, and that in case of
X;;;; errors the original file is not modified.
X
X;;;; If the transformation fails, you can either do it by hand
X;;;; (following directions in annotebib.add), or modify the regular
X;;;; expressions used to search for interesting information. The
X;;;; latter approach is best for multiple style files written with the
X;;;; same conventions/functions.
X
X
X;;; Regexps for recognizing things which interest us.
X
X(defvar annote-entry-regexp "ENTRY[^{]*{"
X  "*A regexp to find the ENTRY fields declaration. This regexp should
Xmatch up to the opening brace af the ENTRY declaration.")
X
X(defvar annote-fin-entry-regexp "FUNCTION[ \t]*{[ \t]*fin.entry[ \t]*}[^{]*"
X  "*A regexp to find the FUNCTION for ending entries. This regexp
Xshould match up to but not including the opening brace of the
Xfunction.")
X
X;;; Other customization
X
X(defvar annote-default-annote-fields "annote"
X  "*The default fields containing annotations. Used if a nil or \"\"
Xvalue is given to an annotation function. Fields must be recognized by
Xthe annote-field-regexp regexp (other chars in the string are
Xdelimiters between field names).")
X
X(defvar annote-func-prefix "annotebib.format."
X  "*The prefix used to build the name of the formatting function for a
Xgiven annotation field.")
X
X(defvar annote-unannote-func-prefix ()
X  "Uncommented function, only for those who have understood the code
Xand have a serious upgrade to do between two releases.")
X
X(defvar annote-field-regexp "[^ \t]+"
X  "*A regexp to recognize a field name. Field names in a string must
Xbe separated by characters matched by the negated regexp.")
X
X(defvar annote-savefile-prefix ""
X  "*A string prefixed to a bibliography file name when saving it. An
Xempty string means to replace the file if in the same directory.")
X
X(defvar annote-BibTeX-path (getenv "TEXINPUTS")
X  "*The path used to find a BibTeX file. Elements of the path (i.e
Xdirectories) are separated by annote-BibTeX-path-separator characters.")
X
X(defvar annote-BibTeX-path-separator ":"
X  "*A single character which separates directories in the BibTeX path
Xstring.")
X
X(defvar annote-BibTeX-style-extension ".bst"
X  "*The default BibTeX style file extension. Must start with a dot.")
X
X(defvar annote-BibTeX-style-directory 'default-directory
X  "*The default BibTeX style directory. Will be evaluated when a style
Xfile name is asked for.")
X
X(defvar annote-backup-prefix ""
X  "*A string prefixed to BibTeX style filenames when backuped.")
X
X(defvar annote-backup-suffix ".orig"
X  "*A string suffixed to BibTeX style filenames when backuped.")
X
X(defvar annote-LaTeX-style-extension ".sty"
X  "*The default LaTeX style file extension.")
X
X(defvar annote-LaTeX-style-suffix annote-LaTeX-style-extension
X  "*A string suffixed to the name of an annotation field in order to
Xbuild a LaTeX style file name. Usualyy it is a file suffix.")
X
X(defvar annote-LaTeX-style-prefix ""
X  "*A string prefixed to the name of an annotation field in order to
Xbuild a LaTeX style file name. Usually it is a directory prefix.")
X
X(defvar annote-backup-files t
X  "*A non-nil value means to backup files when the new filename is the
Xsame as the old one.")
X
X(defvar annote-ask-interactively t
X  "*A non-nil value means that annote will ask interactively for
Xfile overwriting.")
X
X(defvar annote-ask-confirmation t
X  "*A non-nil value means that annote will ask for confirmation before
Xdoing something on files you haven't expressely specified.")
X
X;;; Style file variables
X
X(defvar annote-default-env-start "\\begin{quote}"
X  "*The start of the environment used to display the annotation field
Xin the bibliography.")
X
X(defvar annote-default-env-end "\\end{quote}"
X  "*The end of the environment used to display the annotation field
Xin the bibliography.")
X
X;;; Private variables
X
X(setq annote-version-string "v1.5.1")
X
X;;; Set up a syntax table. The syntax entries are borrowed from a
X;;; BibTeX mode, and the syntax entries for { and } were added for
X;;; security (if the mode the file was in has redefined those chars)
X
X(if (or (not (boundp 'bibtex-mode-syntax-table))
X	(null bibtex-mode-syntax-table))
X    (progn
X      (setq bibtex-mode-syntax-table (copy-syntax-table))
X      (modify-syntax-entry ?\$ "$$  ")
X      (modify-syntax-entry ?\% "<   ")
X      (modify-syntax-entry ?\f ">   ")
X      (modify-syntax-entry ?\n ">   ")
X      (modify-syntax-entry ?'  "w   ")
X      (modify-syntax-entry ?@  "w   ")
X      (modify-syntax-entry ?{  "(}")
X      (modify-syntax-entry ?}  "){")))
X
X(defun annote-prompt-concat (x y)
X  (if (and x
X	   (not (and (stringp x)
X		     (string-match "^[ \t]*$" x))))
X      (concat x y)
X    x))
X
X;;; Build the formatting function name
X
X(defun annote-mk-func (f)
X  (concat annote-func-prefix f))
X
X;;; Listify: if given a list, that list; if given a string, sublistify
X;;; that string; otherwise return nil
X
X(defun annote-listify (thing &optional regexp)
X  (cond
X   ((listp thing) thing)
X   ((stringp thing) (annote-sublistify thing
X				       (if regexp regexp
X					 annote-field-regexp)
X				       0))))
X
X;;; Listify a string, i.e. return a list of substrings which match a
X;;; given regular expression
X
X(defun annote-sublistify (str regexp start)
X  (if (string-match regexp str start)
X      (cons (substring str (match-beginning 0) (match-end 0))
X	    (annote-sublistify str regexp (match-end 0)))))
X					       
X;;; Annotation of a bibliography in a buffer. This is the basic
X;;; annotation primitive.
X
X(defun annote-buffer (&optional annote-fields in-place buffer)
X  "Annote the bibliography style in the optionnaly specified buffer
X(or current if called interactively). The first argument (asked
Xinteractively for) is the list of annotation fields names. It defaults
Xto the value of the user variable annote-default-annote-fields.  It
Xmay be a list or a string with multiple names.
X
XThe buffer is edited in place if the in-place argument is non-nil, or
Xif a negative prefix argument is given. The default value for the
Xannotation field(s) name(s) is taken from the annote-default-annote-fields if
Xthe given name is nil or blank, or if the function is called
Xinteractively with a numeric prefix argument which is not `-' nor nil.
X
XThe function does nothing if the buffer already supports (or looks
Xlike it does support) `annote' for the given field.
X
XReturn the success of the modification, or the list '(no-change-for
X\"<annote-fields>\") if already supporting `annote' for the given
Xfield."
X  (interactive (list (if (or (not current-prefix-arg)
X			     (eq current-prefix-arg '-))
X			 (read-string "Annotation field(s) name(s): "
X				      (annote-prompt-concat
X                                        annote-default-annote-fields
X					" ")))
X		     (< (prefix-numeric-value current-prefix-arg) 0)))
X  (if (or (null annote-fields)
X	  (and (stringp annote-fields)
X	       (string-match "^[ \t]*$" annote-fields)))
X      (setq annote-fields annote-default-annote-fields))
X  (annote-internal-ob annote-fields in-place buffer 'annote-internal-ab
X                      "Annotating"))
X
X(defun annote-internal-ob (annote-fields in-place buffer funct msg)
X  (let ((success nil) (ret) (err)
X	(old-syntax (syntax-table))
X	(tembuf (if (not in-place) (generate-new-buffer " annote temp"))))
X    (if (not buffer) (setq buffer (current-buffer)))
X    (unwind-protect
X	(save-excursion
X	  (if tembuf
X	      (progn
X		(set-buffer tembuf)
X		(erase-buffer)
X		(insert-buffer-substring buffer)))
X	  (set-syntax-table bibtex-mode-syntax-table)
X
X	  (setq annote-fields (annote-listify annote-fields
X					      annote-field-regexp))
X	  (if (setq ret (buffer-file-name buffer))
X	      (setq msg (concat msg " `" ret "'..."))
X	    (setq msg (concat msg " \"" (buffer-name buffer) "\"...")))
X	  (message msg)
X	  (annote-clear-errors)
X	  (while annote-fields
X            (condition-case therror
X	        (if (setq ret
X			  (funcall funct (car annote-fields) (interactive-p)))
X		    (progn
X		      (undo-boundary)
X		      (setq success ret)))
X	      (error (message (car (cdr therror)))
X		     (annote-add-to-errors therror)
X		     (setq err (concat err
X				       (if err ", " "")
X				       "`" (car annote-fields) "'"))
X		     (if (interactive-p) (progn (beep) (sit-for 1)))))
X	    (setq annote-fields (cdr annote-fields)))
X
X	  (if (and tembuf (eq success t))
X	      (progn
X		(set-buffer buffer)
X		(erase-buffer)
X		(insert-buffer-substring tembuf)))
X          (if err
X              (error (concat msg "done with errors for " err "."))
X            (message (concat msg "done."))))
X      (set-syntax-table old-syntax)
X      (if tembuf (kill-buffer tembuf)))
X    success))
X
X(defun annote-internal-ab (annote-fields inter)
X  (let ((success nil)
X	(rem))
X    (goto-char (point-min))
X    (if (search-forward (concat "FUNCTION {"
X				(annote-mk-func annote-fields) "}")
X			(point-max) t)
X	;; Already supporting this field
X	(progn
X	  (setq success (list 'no-change-for annote-fields))
X	  (message "No change needed for field `%s'." annote-fields))
X      (goto-char (point-min))
X      (if (not (re-search-forward annote-entry-regexp (point-max) t))
X	  (error "Cannot find ENTRY declaration.")
X	(setq rem (match-end 0))
X	(if (not (re-search-forward annote-fin-entry-regexp
X				    (point-max) t))
X	    (error "Cannot find FUNCTION for ending entries.")
X	  ;; found the fin.entry function
X	  (setq success t)
X	  (message "Adding annotation field `%s'." annote-fields)
X	  (goto-char (1- (scan-lists (match-end 0) 1 0)))
X	  (insert "  " (annote-mk-func annote-fields) " write$\n")
X	  (goto-char (1- (match-beginning 0)))
X	  (insert "\n\
XFUNCTION {" (annote-mk-func annote-fields) "}\n\
X{ " annote-fields " empty$\n\
X        { \"\" }\n\
X        { \"\\ifx\\" annote-fields "\\undefined\\else\\begin{"
X                        annote-fields "} \"\n\
X          " annote-fields "\n\
X          * \" \\end{" annote-fields "}\\fi \" *\n\
X        }\n\
X      if$\n\
X}\n")
X	  (goto-char rem)
X	  (insert " " annote-fields "\n   ")
X	  (goto-char (point-min))
X	  (insert "\
X% Style file modified on " (current-time-string) " with `annotebib.el' "
X						 annote-version-string "\n\
X%                     by " (user-full-name)
X" <" (user-real-login-name) "@" (system-name) ">\n\
X%                     to support the `" annote-fields "' annotation field.\n")
X	  ;; try to be smart: if we find the advertising comment in
X	  ;; the buffer we just have to add to the list of
X	  ;; modifications, and not put all the stuff again
X	  (if (not (search-forward "`annote'-compatible" (point-max) t))
X              (insert "\n\
X% This bibliography style was made `annote'-compatible by \"annotebib.el\".\n\
X% It can be used for both annotated and non-annotated bibliographies \
Xlisting\n\
X% (`annote' package by Yves Arrouye <arrouye@imag.imag.fr>).\n\n")))))
X  success))
X
X;;; Return the list of annotations defined in a buffer. The preferred
X;;; place to find the names is in the comments in the top lines of the
X;;; file. However, if (and only if) all these comments have been
X;;; deleted, then we try by looking at the FUNCTIONs.
X
X(defun annote-get-fields (&optional buffer)
X  (let ((fields))
X    (save-excursion
X      (if buffer (set-buffer buffer))
X      (goto-char (point-min))
X      (if (not (setq fields (annote-cmt-fields)))
X	  (progn
X	    (goto-char (point-max))
X	    (setq fields (annote-fmt-fields)))))
X    fields))
X
X(defun annote-cmt-fields ()
X  (if (re-search-forward "`\\([^']+\\)' annotation field." (point-max) t)
X      (cons (buffer-substring (match-beginning 1) (match-end 1))
X	    (annote-cmt-fields))))
X
X(defun annote-fmt-fields ()
X  (if (re-search-backward (concat "FUNCTION {" annote-func-prefix
X				  "\\([^}]+\\)}") (point-min) t)
X      (cons (buffer-substring (match-beginning 1) (match-end 1))
X	    (annote-fmt-fields))))
X
X;;; Suppresses annotations from a buffer.
X
X(defun annote-unannote-buffer (&optional annote-fields in-place buffer)
X  "Unannote the bibliography style in the optionnally specified buffer
X(or current if called interactively).  The first argument (asked
Xinteractively for) is the list of annotation fields names. It defaults
Xto the list of all annotations names in the buffer. It may be a list
Xor a string with multiple names.
X
XThe buffer is edited in place if the in-place argument is non-nil, or
Xif a negative prefix argument is given. The default value for the
Xannotation field(s) name(s) is taken from the annote-default-annote-fields if
Xthe given name is nil or blank, or if the function is called
Xinteractively with a numeric prefix argument which is not `-' nor nil.
X
XThe function does nothing if the buffer does not support (or looks
Xlike it does not support) `annote' for the given field.
X
XReturn the success of the modification, or the list '(no-change-for
X\"<annote-fields>\") if non supporting `annote' for the given
Xfield."
X  (interactive (let ((field (car (annote-get-fields))))
X		 (if field
X		     (list (if (or (not current-prefix-arg)
X				   (eq current-prefix-arg '-))
X			       (read-string "Annotation field(s) name(s): "
X					    (annote-prompt-concat field
X					     " ")))
X			   (< (prefix-numeric-value current-prefix-arg) 0)
X			   nil)
X		   (error "Unannotated buffer (or with other annote-func-prefix)."))))
X  (if (or (null annote-fields)
X	  (and (stringp annote-fields)
X	       (string-match "^[ \t]*$" annote-fields)))
X      (progn
X        (setq annote-fields (annote-get-fields buffer))
X        (if (interactive-p)
X            (progn (message "Annotation field(s) name(s): [ALL]") (sit-for 1)))))
X  (let ((annote-func-prefix (if annote-unannote-func-prefix
X                                annote-unannote-func-prefix
X                              annote-func-prefix)))
X    (annote-internal-ob annote-fields in-place buffer 'annote-internal-ub
X                        "Unannotating")))
X
X(defun annote-internal-ub (annote-fields inter)
X  (let ((sucess nil)
X	(temp))
X    (goto-char (point-min))
X    (if (not (search-forward (concat "\nFUNCTION {"
X				     (annote-mk-func annote-fields) "}")
X			     (point-max) t))
X	;; We don't support this field
X	(progn
X	  (setq success (list 'no-change-for annote-fields))
X	  (message "No change needed for field `%s'." annote-fields))
X      ;; remember where the FUNCTION was
X      (setq temp (cons (match-beginning 0) (match-end 0)))
X      ;; delete the field from the ENTRY list
X      (goto-char (point-min))
X      (if (not (re-search-forward (concat annote-entry-regexp
X					  "[^}]*\\( " annote-fields
X					  "\n   \\)")
X				  (point-max) t))
X	  (error (concat "Cannot find ENTRY declaration for field `"
X			 annote-fields "'."))
X	(delete-region (match-beginning 1) (match-end 1)))
X      ;; delete the FUNCTION
X      (search-forward (concat "\nFUNCTION {"
X			      (annote-mk-func annote-fields) "}")
X		      (point-max) t)
X      (goto-char (match-end 0))
X      (delete-region (match-beginning 0)
X		     (1+ (scan-lists (match-end 0) 1 0)))
X      ;; and delete the call to that function too
X      (while (re-search-forward (concat "^[ \t]*"
X					(annote-mk-func annote-fields) ".*\n")
X				(point-max) t)
X	(delete-region (match-beginning 0) (match-end 0)))
X      (setq success t)
X      (message "Removing annotation field `%s'." annote-fields)
X      (goto-char (point-min))
X      (if (re-search-forward (concat "`" annote-fields
X				     "' annotation field.\n")
X			     (point-max) t)
X	  (let ((end (point)))
X	    (if (re-search-backward "^% Style file modified" (point-min) t)
X		(delete-region (match-beginning 0) end))))
X      ;; try to be smart: if this was the last annotation found in
X      ;; the buffer we have to delete the advertising comment.
X      (goto-char (point-min))
X      (if (not (re-search-forward "^% Style file modified" (point-max) t))
X	  (if (re-search-forward "\n%.*`annote'-compatible"
X				 (point-max) t)
X	      (progn
X		(end-of-line 4)
X		(delete-region (match-beginning 0) (1+ (point)))))))
X    success))
X
X;;; Annotation of a file.
X;;;
X;;; If and savefile is nil or "", then the original file is modified.
X
X(defun annote-file (origfile &optional annote-fields savefile)
X  "Annote a file. If called interactively, asks for an existing
Xfilename, for the name(s) of the annotation field(s), and then for the name
Xof the annotated file. If this name is a directory, then the name of
Xthe file will be the filename of the original file in this directory,
Xunless the directories are the same, in which case the original file
Xwill have the value of annote-savefile-prefix prefixed to it. If the
Xbuffer was already visited, it is not destroyed.
X
XIf a numeric prefix argument is given, or if the name of the
Xannotation field is blank, the default value is taken from the
Xannote-default-annote-fields user variable.
X
XIf annote-buffer fails on the loaded file, it is not saved. Return
Xsuccess as got from annote-buffer."
X  (interactive (list (read-file-name "Bib file: " default-directory
X				     (eval annote-BibTeX-style-directory) t)
X		     (if (not current-prefix-arg)
X			 (read-string "Annotation field(s) name(s): "
X				      (annote-prompt-concat
X				         annote-default-annote-fields
X					 " ")))
X		     (read-file-name "Save file: " default-directory
X				     default-directory)))
X  (annote-internal-of origfile annote-fields savefile 'annote-buffer))
X
X(defun annote-unannote-file (origfile &optional annote-fields savefile)
X  "Unannote a file. If called interactively, asks for an existing
Xfilename, for the name(s) of the annotation field(s), and then for the name
Xof the unannotated file. If this name is a directory, then the name of
Xthe file will be the filename of the original file in this directory,
Xunless the directories are the same, in which case the original file
Xwill have the value of annote-savefile-prefix prefixed to it. If the
Xbuffer was already visited, it is not destroyed.
X
XIf a numeric prefix argument is given, or if the name of the
Xannotation field is blank, the default value is taken from the
Xannote-default-annote-fields user variable.
X
XIf annote-buffer fails on the loaded file, it is not saved. Return
Xsuccess as got from annote-unannote-buffer."
X  (interactive (list (read-file-name "Bib file: " default-directory
X				     (eval annote-BibTeX-style-directory) t)
X		     (if (not current-prefix-arg)
X			 (read-string "Annotation field(s) name(s): "
X				      (annote-prompt-concat
X				         annote-default-annote-fields
X					 " ")))
X		     (read-file-name "Save file: " default-directory
X				     default-directory)))
X  (annote-internal-of origfile annote-fields savefile 'annote-unannote-buffer))
X
X(defun annote-internal-of (origfile annote-fields savefile funct)
X  (setq origfile (expand-file-name origfile))
X  (if (file-directory-p origfile)
X      (error (concat "File `" origfile "' is a directory!")))
X  (if (or (null savefile)
X	  (string-equal savefile ""))
X      (setq savefile (file-name-directory origfile)))
X  (if (string-match ".+\\(/+\\)$" savefile)
X      (setq savefile (substring savefile 0 (match-beginning 1))))
X  (if (file-directory-p savefile)
X      ;; the savefile is a directory
X      (progn
X	(setq savefile (concat savefile "/"))
X	(setq savefile
X	      (concat savefile
X		      (if (string-equal (file-name-directory origfile)
X					savefile)
X			  ;; same directory: append the contents of
X			  ;; the annote-savefile-prefix variable
X			  annote-savefile-prefix)
X		      (file-name-nondirectory origfile)))))
X  (setq savefile (expand-file-name savefile))
X  ;; now do the real job: load the file, modify it, and save it
X  (if (not (file-readable-p origfile))
X      (error (concat "Wouldn't read `" origfile "'"))
X    (if (not (file-writable-p savefile))
X	(error (concat "Wouldn't write `" savefile "'"))))
X  (let ((success nil)
X	(was-here (get-file-buffer origfile))
X	(tembuf)
X	(modified))
X    (setq modified (if was-here (buffer-modified-p was-here))
X	  tembuf (if was-here
X		     (if (string-equal origfile savefile)
X			 was-here
X		       (let ((buf (generate-new-buffer " annote temp")))
X			 (set-buffer buf)
X			 (insert-buffer-substring was-here)
X			 (setq was-here nil)
X			 buf))
X		   (find-file-noselect origfile)))
X    (if (or (null annote-fields)
X	    (and (stringp annote-fields)
X		 (string-match "^[ \t]*$" annote-fields)))
X	(progn
X	  (setq annote-fields (annote-get-fields tembuf))
X	  (if (interactive-p)
X	      (message "Annotation field(s) name(s): [ALL]"))))
X    (unwind-protect
X	(save-excursion
X	  (if (and (string-equal savefile origfile)
X		   annote-backup-files)
X	      ;; save the original file as a backup
X	      (copy-file origfile
X			 (concat (file-name-directory origfile)
X				 annote-backup-prefix
X				 (file-name-nondirectory origfile)
X				 annote-backup-suffix)
X			 t))
X	  (set-buffer tembuf)
X	  (set-visited-file-name savefile)
X	  (set-buffer-modified-p nil)
X	  (if (eq (setq success (funcall funct annote-fields t)) t)
X	      (save-buffer)))
X      (if (not (eq success t))
X	  ;; don't save, it's either a fail or a no-op
X	  (progn
X	    (set-buffer tembuf)
X	    (set-buffer-modified-p nil))))
X    (save-excursion
X      (set-buffer tembuf)
X      (set-buffer-modified-p modified))
X    (if (not was-here)
X	(kill-buffer tembuf))
X    success))
X
X;;; Guess the name of the annotation field from a filename. If it is ending in
X;;; the contents of annote-LaTeX-style-extension, then the
X;;; nondirectory part without the extension will be used, otherwise it
X;;; defaults to the contents of the annote-default-annote-fields variable.
X
X(defun annote-get-field-from-filename (fname)
X  (if (and fname
X	   (string-match (concat annote-LaTeX-style-extension "$")
X			 (file-name-nondirectory fname)))
X      (substring
X       (file-name-nondirectory fname)
X       0
X       (match-beginning 0))
X    annote-default-annote-fields))
X
X;;; Set values of fields when needed
X
X(defun annote-mk-values (lst)
X  (mapcar '(lambda (f)
X	     (let ((x (car f))
X		   (y (cdr f)))
X	       (if (or (null (eval x))
X		       (and (stringp (eval x))
X			    (string-match "^[ \t]*$" (eval x))))
X		   (set x (eval y)))))
X	  lst))
X  
X;;; Insert the text for an annotation style for a given field.
X
X(defun annote-insert-style (&optional annote-field env-start env-end)
X  "Insert the text of a LaTeX style file for an environment used to
Xdisplay an annotation field.
X
XArguments are the name of the annotation field, and LaTeX code to
Xstart and end the environment. If the annotation field is not given or
Xblank, the function will try to guess it from the name of the visited
Xfile if any. In other cases, and for the other arguments, default
Xvalues from the user variables will be used.
X
XIf called interactively with a non-nil prefix argument, default values
Xwill be used."
X  (interactive (if (not current-prefix-arg)
X		   (list (read-string "Annotation field name: "
X				      (annote-get-field-from-filename
X				       (buffer-file-name)))
X			 (read-string "Start of env: "
X				      annote-default-env-start)
X			 (read-string "End of env: "
X				      annote-default-env-end))))
X  ;; Restore default values if they were garbaged during reading
X  (annote-mk-values
X   '((annote-field . (annote-get-field-from-filename (buffer-file-name)))
X     (env-start . annote-default-env-start)
X     (env-end . annote-default-env-end)))
X  (insert "% `"
X	  annote-field ".sty' annotation style file for BibTeX/LaTeX\n\n\
X% Style file generated on " (current-time-string) " with `annotebib.el' "
X						 annote-version-string "\n\
X%                      by " (user-full-name)
X" <" (user-real-login-name) "@" (system-name) ">\n\
X%                      to support the `" annote-field "' annotation field.\n\n\
X% This style file must be used in conjunction with a BibTeX style file\n\
X% supporting the `annote' package by Yves Arrouye <arrouye@imag.imag.fr>.\n\n\
X\\newenvironment{" annote-field "}{%\n" env-start "%\n}{%\n" env-end "%\n}\n"))
X
X;;; Write a style file with the text for an annotation style for a
X;;; given field.
X
X(defun annote-write-styles (&optional annote-fields
X				      env-start env-end overwrite inter)
X  "Write one or more files with the text of a LaTeX style file for an
Xenvironment used to display an annotation field.
X
XArguments are the name(s) of the annotation field(s), and LaTeX code
Xto start and end the environment. The names of the fields may be given
Xas a list of strings or a single strings with multiple names in it.
XIf an argument is not given, default values from the user variables
Xwill be used.
X
XThe function writes a file for each environment, prefixing the
Xcontents of annote-LaTeX-style-prefix to the annotation field name,
Xand adding the annote-LaTeX-style-suffix to it.
X
XIf called interactively with a non-nil prefix argument, default values
Xwill be used. If the last argument is non-nil or a negative prefix
Xargument is given, an existing file will be overwritten; otherwise, no
Xchanges are made to the contents of that file."
X  (interactive (append
X		(if (not current-prefix-arg)
X		    (list (read-string "Annotation field(s) name(s): "
X				       (annote-prompt-concat
X					(annote-get-field-from-filename "")
X					" "))
X			  (read-string "Start of env: "
X				       annote-default-env-start)
X			  (read-string "End of env: "
X				       annote-default-env-end))
X		  '(nil nil nil))
X		(list (< (prefix-numeric-value current-prefix-arg) 0)
X		      t)))
X  (let ((err))
X    ;; Restore default values if they were garbaged during reading
X    (annote-mk-values
X     '((annote-fields . (annote-get-field-from-filename ""))
X       (env-start . annote-default-env-start)
X       (env-end . annote-default-env-end)))
X    (save-excursion
X      (setq annote-fields (annote-listify annote-fields
X					  annote-field-regexp))
X      (annote-clear-errors)
X      (while annote-fields
X	(condition-case therror
X	    (annote-internal-ws (car annote-fields)
X				(concat annote-LaTeX-style-prefix
X					(car annote-fields)
X					annote-LaTeX-style-suffix)
X				overwrite
X				inter)
X	  (error (message (car (cdr therror)))
X		 (annote-add-to-errors therror)
X		 (setq err (concat err
X				   (if err ", " "")
X				   "`" (car annote-fields) "'"))
X		 (if inter (progn (beep) (sit-for 1)))))
X	(undo-boundary)
X	(setq annote-fields (cdr annote-fields)))
X      (if err
X	  (error (concat "Style writing...done with errors for " err "."))
X	(message "Style writing...done.")))))
X
X(defun annote-internal-ws (annote-field stylefile overwrite inter)
X  (let ((stybuf)
X	(was-here (get-file-buffer stylefile)))
X    (setq stybuf (if was-here
X		     was-here
X		   (find-file-noselect stylefile)))
X    (set-buffer stybuf)
X    (setq stylefile (expand-file-name stylefile))
X    (if (or was-here (file-exists-p stylefile))
X	;; must have overwriting permission first
X	(if (and (not overwrite)
X		 inter
X		 annote-ask-interactively)
X	    ;; ask for confirmation
X	    (setq overwrite (yes-or-no-p (concat "Overwrite " stylefile
X						 "? "))))
X      (setq overwrite t))
X    (if (not overwrite)
X	(error "Wouldn't overwrite `%s'" stylefile)
X      ;; okay, now we can do what we want
X      (message "Write style `%s' for field `%s'." stylefile annote-field)
X      (if (and (file-exists-p stylefile)
X	       annote-backup-files)
X	  (copy-file stylefile
X		     (concat (file-name-directory stylefile)
X			     annote-backup-prefix
X			     (file-name-nondirectory stylefile)
X			     annote-backup-suffix)
X		     t))
X      (erase-buffer)
X      (annote-insert-style annote-field env-start env-end)
X      (save-buffer))
X    (if (not was-here) (kill-buffer stybuf))))
X
X;;; Ask interactively for a list of filenames, until the user type RET
X;;; as an answer to the prompt. Arguments are a prompt for the first
X;;; filename, an optional  prompt for other filenames (defaults to the first
X;;; prompt), an optional directory and an optional flag requiring
X;;; existence of the file.
X
X(defun annote-read-file-names (prompt &optional secprompt directory existing)
X  "Read a list of file names."
X  (let ((names)
X	(current))
X    (if (not secprompt) (setq secprompt prompt))
X    (setq current (read-file-name prompt directory "" existing))
X    (while (not (string-equal current ""))
X      (setq names (append names (list current))
X	    directory (file-name-directory current)
X	    current (read-file-name secprompt directory "" existing)))
X    names))
X
X;;; Making a full package of annotated bibliography styles, both
X;;; BibTeX and LaTeX.
X
X(defun annote-make-annotated (&optional file-list annote-fields
X					env-start env-end overwrite)
X  "Make a full annotated distribution. Gets the list of BibTeX files
Xto annotate, the list of annotation fields. Annotate the BibTeX files
Xand save them, then write the LaTeX style files (asking for
Xconfirmation depending on the value of the overwrite flag, see
Xannote-write-styles.  Note that the style files will all define the
Xsame environment (if you want different environments, you will have to
Xcall annote-file followed by as much annote-write-styles as you want
Xdifferent environments, but this is not painful, really...).
X
XWhen called interactively, the list of BibTeX files is asked for, and
Xone ends it by answering RET to the prompt. If the list is empty, it
Xdefaults to all accessible BibTeX style files. If a prefix argument is
Xgiven, it is used as in annote-write-styles for the default values and
Xoverwrite argument.
X
XIn a non-interactive call, the file list may be a string, which is
Xassumed to be a path of directories in which to get the the BibTeX files."
X  (interactive (append
X		(list (annote-read-file-names
X		       "BibTeX style: "
X		       "Another style: "
X		       (eval annote-BibTeX-style-directory)
X		       t))
X		(if (not current-prefix-arg)
X		    (list (read-string "Annotation field(s) name(s): "
X				       (annote-prompt-concat
X					(annote-get-field-from-filename "")
X					" "))
X			  (read-string "Start of env: "
X				       annote-default-env-start)
X			  (read-string "End of env: "
X				       annote-default-env-end))
X		  '(nil nil nil))
X		(list (< (prefix-numeric-value current-prefix-arg) 0))))
X  (setq annote-fields (annote-listify annote-fields))
X  (let ((err) (errors))
X    ;; if no files, default to all BibTeX files
X    (if (null file-list)
X	(if (and (interactive-p) annote-ask-confirmation)
X	    (if (yes-or-no-p "Really annote all accessible BibTeX styles? ")
X		(setq file-list (annote-accessible-BibTeX-styles))
X	      (setq file-list nil))
X	  (setq file-list (annote-accessible-BibTeX-styles)))
X      (if (stringp file-list)
X	  ;; assume it is a path
X	  (setq file-list (annote-accessible-BibTeX-styles file-list))))
X    (if file-list
X	(progn
X	  (message "Annotating...")
X	  ;; annote the BibTeX styles by iterating over filenames
X	  (while file-list
X	    (annote-clear-errors)
X	    (condition-case therror
X		(if (and (interactive-p) annote-ask-interactively)
X		    ;; ask if you really want this one
X		    (if (y-or-n-p (concat "Really annote `"
X					  (car file-list) "'? "))
X			(annote-file (car file-list) annote-fields))
X		  (annote-file (car file-list) annote-fields))
X	      (error (message (car (cdr therror)))
X		     (annote-add-to-errors therror)
X		     (setq err (concat err
X				       (if err ", " "")
X				       "`" (car file-list) "'"))
X		     (if (interactive-p) (progn (beep) (sit-for 1)))))
X	    ;; save the errors
X	    (setq errors (append errors annote-errors))
X	    ;; next file
X	    (setq file-list (cdr file-list)))
X	  ;; now generate the LaTeX styles
X	  (condition-case therror
X	      (annote-write-styles annote-fields env-start env-end
X				   overwrite (interactive-p))
X	    (error (if (null err)
X		       (error (car (cdr therror)))
X		     (message (car (cdr therror))) (beep) (sit-for 1))))
X	  (annote-set-errors errors)
X	  (if err
X	      (error (concat "Annotating...done with errors for " err "."))
X	    (message "Annotating...done."))))
X      (message "Annotating...nothing done.")
X      annote-errors))
X
X(defun annote-make-unannotated (&optional file-list annote-fields)
X  "Unannote a list of files. Gets the list of BibTeX files
Xto annotate, the list of annotation fields. Unannotate the BibTeX files
Xand save them.
X
XWhen called interactively, the list of BibTeX files is asked for, and
Xone ends it by answering RET to the prompt. If the list is empty, it
Xdefaults to all accessible BibTeX style files.
X
XIn a non-interactive call, the file list may be a string, which is
Xassumed to be a path of directories in which to get the the BibTeX files."
X  (interactive (list (annote-read-file-names
X		      "BibTeX style: "
X		      "Another style: "
X		      (eval annote-BibTeX-style-directory)
X		      t)
X		     (if (not current-prefix-arg)
X			 (read-string "Annotation field(s) name(s): "
X				      (annote-prompt-concat
X				       (annote-get-field-from-filename "")
X				       " ")))))
X  (setq annote-fields (annote-listify annote-fields))
X  (let ((err) (errors))
X    ;; if no files, default to all BibTeX files
X    (if (null file-list)
X	(if (and (interactive-p) annote-ask-confirmation)
X	    (if (yes-or-no-p "Really unannote all accessible BibTeX styles? ")
X		(setq file-list (annote-accessible-BibTeX-styles))
X	      (setq file-list nil))
X	  (setq file-list (annote-accessible-BibTeX-styles)))
X      (if (stringp file-list)
X	  ;; assume it is a path
X	  (setq file-list (annote-accessible-BibTeX-styles file-list))))
X    (if file-list
X	(progn
X	  (message "Unannotating...")
X	  ;; unannote the BibTeX styles by iterating over filenames
X	  (annote-clear-errors)
X	  (while file-list
X	    (annote-clear-errors)
X	    (condition-case therror
X		(if (and (interactive-p) annote-ask-interactively)
X		    ;; ask if you really want this one
X		    (if (y-or-n-p (concat "Really unannote `"
X					  (car file-list) "'? "))
X			(annote-unannote-file (car file-list) annote-fields))
X		  (annote-unannote-file (car file-list) annote-fields))
X	      (error (message (car (cdr therror)))
X		     (annote-add-to-errors therror)
X		     (setq err (concat err
X				       (if err ", " "")
X				       "`" (car file-list) "'"))
X		     (if (interactive-p) (progn (beep) (sit-for 1)))))
X	    ;; save the errors
X	    (setq errors (append errors annote-errors))
X	    ;; next file
X	    (setq file-list (cdr file-list)))
X	  (if err
X	      (error (concat "Unannotating...done with errors for " err "."))
X	    (message "Unannotating...done.")))
X      (message "Unannotating...nothing done."))
X    (annote-set-errors errors)))
X
X;;; List of files matching a regexp in a directory.
X
X(defun annote-directory-files-matching (directory &optional regexp)
X  "Return the list of files matching the given regexp in the given directory."
X  (mapcar '(lambda (what)
X	     (concat directory "/" what))
X	  (if regexp
X	      (apply 'append (mapcar '(lambda (name)
X					(if (string-match regexp name)
X					    (list name)))
X				     (directory-files directory)))
X	    (directory-files directory))))
X
X;;; List of files matching a regexp in a path of directories
X
X(defun annote-path-files-matching (path path-sep &optional regexp)
X  "Return all files matching the regexp in the given path, where path
Xelements are separated by the single-char string path-sep."
X  (apply 'append
X	 (mapcar '(lambda (dir)
X		    (annote-directory-files-matching dir regexp))
X		 (annote-listify path (concat "[^]" path-sep "]+")))))
X
X;;; Specialization of annote-path-files-matching for BibTeX style files
X
X(defun annote-accessible-BibTeX-styles (&optional path path-sep regexp)
X  "Return a list of all accessible BibTeX styles."
X  (if (null path) (setq path annote-BibTeX-path))
X  (if (null path-sep) (setq path-sep annote-BibTeX-path-separator))
X  (if (null regexp) (setq regexp (concat "\\" annote-BibTeX-style-extension
X					 "$")))
X  (annote-path-files-matching path path-sep regexp))
X
X;;; Error-supporting functions
X
X(defun annote-set-errors (err)
X  (setq annote-errors err))
X
X(defun annote-clear-errors ()
X  (annote-set-errors nil))
X
X(defun annote-add-to-errors (err)
X  (setq annote-errors (append annote-errors (list (car (cdr err))))))
END_OF_FILE
if test 44921 -ne `wc -c <'annotebib.el'`; then
    echo shar: \"'annotebib.el'\" unpacked with wrong size!
fi
# end of 'annotebib.el'
fi
if test -f 'annote.sty' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'annote.sty'\"
else
echo shar: Extracting \"'annote.sty'\" \(461 characters\)
sed "s/^X//" >'annote.sty' <<'END_OF_FILE'
X% `annote.sty' annotation style file for BibTeX/LaTeX
X
X% Style file generated on Tue Jun  8 12:32:12 1993 with `annotebib.el' v1.5.1
X%                      by Yves.Arrouye <arrouye@cosmos>
X%                      to support the `annote' annotation field.
X
X% This style file must be used in conjunction with a BibTeX style file
X% supporting the `annote' package by Yves Arrouye <arrouye@imag.imag.fr>.
X
X\newenvironment{annote}{%
X\begin{quote}%
X}{%
X\end{quote}%
X}
END_OF_FILE
if test 461 -ne `wc -c <'annote.sty'`; then
    echo shar: \"'annote.sty'\" unpacked with wrong size!
fi
# end of 'annote.sty'
fi
if test -f 'commentaire.sty' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'commentaire.sty'\"
else
echo shar: Extracting \"'commentaire.sty'\" \(476 characters\)
sed "s/^X//" >'commentaire.sty' <<'END_OF_FILE'
X% `commentaire.sty' annotation style file for BibTeX/LaTeX
X
X% Style file generated on Tue Jun  8 12:32:11 1993 with `annotebib.el' v1.5.1
X%                      by Yves.Arrouye <arrouye@cosmos>
X%                      to support the `commentaire' annotation field.
X
X% This style file must be used in conjunction with a BibTeX style file
X% supporting the `annote' package by Yves Arrouye <arrouye@imag.imag.fr>.
X
X\newenvironment{commentaire}{%
X\begin{quote}%
X}{%
X\end{quote}%
X}
END_OF_FILE
if test 476 -ne `wc -c <'commentaire.sty'`; then
    echo shar: \"'commentaire.sty'\" unpacked with wrong size!
fi
# end of 'commentaire.sty'
fi
echo shar: End of shell archive.
exit 0

exit 0 # Just in case...
