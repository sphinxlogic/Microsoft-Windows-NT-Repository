Newsgroups: comp.sources.misc
From: anita@bouw.tno.nl (Anita Eijs)
Subject: v38i118:  linkedlist - Generic Linked List Package, Part02/02
Message-ID: <1993Aug12.141946.9312@sparky.sterling.com>
X-Md4-Signature: bf1c004ada8c16e9fb689de4689130f9
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Thu, 12 Aug 1993 14:19:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: anita@bouw.tno.nl (Anita Eijs)
Posting-number: Volume 38, Issue 118
Archive-name: linkedlist/part02
Environment: UNIX, MS-DOS, VAX/VMS, Macintosh, Amiga
Supersedes: linkedlist: Volume 37, Issue 36-37

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  CHANGES Doc/Intro.3 Doc/lDef.3 Doc/lDel.3 Doc/lDelAll.3
#   Doc/lDelIndxNode.3 Doc/lDelNode.3 Doc/lDump.3 Doc/lFndFlagNode.3
#   Doc/lFndNode.3 Doc/lGetIndxNode.3 Doc/lInfo.3 Doc/lInfoIndxNode.3
#   Doc/lInfoNode.3 Doc/lInsNode.3 Doc/lSize.3 Doc/lSort.3
#   Doc/lUndump.3 Doc/lUpdIndxNode.3 Doc/lUpdNode.3 Makefile
#   Makefile.Amiga Makefile.BCC ReadMe.Amiga ReadMe.BCC Tools_makerule
#   list.h sorttest.c
# Wrapped by kent@sparky on Thu Aug 12 09:13:08 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(2431 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XMost important changes from version 0.9 to version 0.10 (August 1993) :
X
X-	New routine 'lSize'.
X
X-	Possibility to skip the error file generation.
X
X-	Better error recovery for allocation problems.
X
X-	Bug solved for inserting (lAFTER) in doubly linked lists (Jan Pillaerd).
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.8 to version 0.9 (May 1993) :
X
X-	Bug solved in the heap sorting algorithm.
X
X-	Ported to Amiga by James Diffendaffer.
X
X-	Some additional porting solutions for Borland and other MSDOS C
X	compilers by Shane Brath.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.7 to version 0.8 (March 1993) :
X
X-	Routine lIndxNode is renamed to lGetIndxNode.
X
X-	Routine lFlagNode is renamed to lFndFlagNode.
X	The parameter where is added to find several nodes matching the
X	requested flag.
X
X-	Some routines added : lDelIndxNode, lInfoIndxNode, lUpdIndxNode,
X	lSort.
X
X-	Defines are made more specific; FIRST is renamed to lFIRST, etc.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.6 to version 0.7 (March 1992) :
X
X-	Ported to Macintosh by Vincent van Gentevoort.
X
X-	New routine 'lFlagNode'.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.5 to version 0.6 (December 1991) :
X
X-	Ported to VAX/VMS by Anita Eijs & Rene Balkenende.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.4 to version 0.5  (February 1991) :
X
X-	Return type for each routine.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.3 to version 0.4 (November 1990) :
X
X-	New routines 'lDump' and 'lUndump'.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.2 to version 0.3 (September 1990) :
X
X-	New routine 'lError'.
X
X--------------------------------------------------------------------------------
X
XMost important changes from version 0.1 to version 0.2 (April 1990) :
X
X-	New routine 'lIndxNode'.
X
X--------------------------------------------------------------------------------
X
XVersion 0.1 (May 1989) :
X
X-	Created by Anita Eijs, TNO-BOUW, BouwInformatica.
END_OF_FILE
  if test 2431 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'Doc/Intro.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/Intro.3'\"
else
  echo shar: Extracting \"'Doc/Intro.3'\" \(7126 characters\)
  sed "s/^X//" >'Doc/Intro.3' <<'END_OF_FILE'
X.TH "Intro"
X.IX Intro
X.SH NAME
XIntro - Introduction to the Generic Linked List.
X.SH DESCRIPTION
XThe Generic Linked List package is a package to define, create, update,
Xquery and delete one or more (nodes of) linked lists, to sort linked
Xlists, and so on. The user doesn't have to take care of allocating a
Xnumber of bytes for a node, inserting on the right place, deleting and
Xfreeing a node and so on.
X.br
XDifferent kind of linked lists can be defined. In a \fIsingly\fP linked
Xlist each node points to the next node, in a \fIdoubly\fP linked list
Xeach node points also to the previous node. A \fIchain\fP is a list in
Xwhich the last node has a NULL-pointer and in a \fIcircular\fP linked
Xlist the last node points back to the first node.
X.br
XThe package consists of the following routines :
X.nf
X.if t .ta 0.2i 1.3i
X	lDef	define linked list
X	lInfo	get information about linked list
X	lSize	get number of nodes in linked list
X	lSort	sort linked list
X	lDel	delete linked list
X	lDelAll	delete all linked lists
X	lDump	dump a linked list to a file
X	lUndump	undump a linked list from a file
X	lInsNode	insert node
X	lInfoNode	get information about node
X	lGetNode	get node
X	lFndNode	find node
X	lFndFlagNode	find node by flag
X	lUpdNode	update current node
X	lDelNode	delete node
X	lInfoIndxNode	get information about node by index
X	lGetIndxNode	get node by index
X	lUpdIndxNode	update node by index
X	lDelIndxNode	delete node by index
X.fi
X.SH ERROR CODES
X.if t .ta 0.2i 1.8i
XHere follows an enumeration of the possible error codes, and their
Xmeanings. Error codes always have negative integer values. Success
Xcodes always have positive values, inclusive 0 (=lSUCCESS). For each
Xfunction-call is specified which error codes could be expected.
X.nf
X	lEMPTY_LIST	linked list doesn't contain any nodes
X	lEOL	end of list reached
X	lNO_LIST	there are no linked lists defined (*)
X	lNOT_DOUBLY	backward searching / retrieving not possible for
X		singly linked list (*)
X	lNOT_FOUND	node not found
X	lOPEN_ERROR	can't open linked list dump file for writing or
X		reading (*)
X	lSIZE_NE	size of expected data and size of node are not
X		equal (*)
X	lUNKNOWN_FUNC	function name is unknown (*)
X	lUNKNOWN_ID	list identifier is unknown (*)
X	lWRONG_CC	parameter \fIcc\fP has wrong value (*)
X	lWRONG_INDEX	index out of range (*)
X	lWRONG_ORDER	parameter \fIorder\fP has wrong value (*)
X	lWRONG_SD	parameter \fIsd\fP has wrong value (*)
X	lWRONG_THEORY	parameter \fItheory\fP has wrong value (*)
X	lWRONG_WHERE	parameter \fIwhere\fP has wrong value (*)
X	lWRONG_WHICH	parameter \fIwhich\fP has wrong value (*)
X	lOUT_OF_MEMORY	no more memory to allocate for [cm]alloc (*)
X.fi
XThe marked errors (*) can also be written to an error file (lERROR_FILE),
Xthis may be useful when testing the application. To avoid the creation
Xof this error file skip the define ERROR_FILE in the Makefile.
X.SH LIBRARY
X$(TOOLS_HOME)/Lib/list.a
X.SH INCLUDE FILE
X$(TOOLS_HOME)/List/list.h
X.SH PORTABILITY
XThe Generic Linked List package is a very portable tool. The tool is
Xdeveloped on UNIX and ported to MSDOS, VAX-VMS and Macintosh. On
Xthose 'ported' machines the library isn't created, but list.c and list.h
Xwere treated the same as all the other source-files (*.[ch]) of the
Xprogram, which used the Generic Linked List package.
X.SH EXAMPLE
X.if t .ta 0.3i 0.6i 0.9i 1.2i 2.2i 3.2i 4.2i 4.5i 4.8i
X.nf
X#ifdef	AMIGA
X#include		<string.h>
X#endif
X
X#include		<stdio.h>
X#include		"list.h"
X
Xtypedef struct rapport {
X	char		title[30];
X	char		author[15];
X	int		date;
X} Rapport;
Xint	rapSz = sizeof(Rapport);
X
X#ifdef ANSI
Xstatic void	insRap(int id, int where, int flag, char *title, char *author,
X				int date);
Xstatic void	prRapAll(int id);
Xstatic void	prRap(int code, Rapport *rpprt);
Xstatic int	search(int *date, Rapport *rpprt);
Xstatic int	compare(Rapport *data1, Rapport *data2);
X#else
Xstatic void	insRap(), prRapAll(), prRap();
Xstatic int	search(), compare();
X#endif
X
Xint
Xmain()
X{
X	int			id, code, search_date;
X	Rapport		rap;
X
X	id = lDef(lSINGLY, lCHAIN);
X
X	insRap(id, lFIRST, 1, "Book 1", "People", 890129);
X	insRap(id, lFIRST, 2, "Book 2", "More People", 890130);
X	insRap(id, lLAST, 1, "Book 3", "Lots of People", 890131);
X
X	fprintf(stdout, "lGetNode\\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lGetIndxNode\\n");
X	code = lGetIndxNode(id, 4, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, -1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lGetIndxNode(id, 3, &rap, rapSz);
X	prRap(code, &rap);
X
X	fprintf(stdout, "lFndNode\\n");
X	search_date = 890129;
X	code = lFndNode(id, lFIRST, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndNode(id, lNEXT, search, &search_date, &rap, rapSz);
X	prRap(code, &rap);
X
X	code = lDump(id, "dump");
X	fprintf(stdout, "lDump : %d\\n", code);
X
X	lDel(id);
X
X	id = lUndump("dump");
X	fprintf(stdout, "lUndump : %d\\n", id);
X
X	insRap(id, lFIRST, 4, "Book 4", "The Author", 891127);
X
X	prRapAll(id);
X
X	fprintf(stdout, "lFndFlagNode\\n");
X	code = lFndFlagNode(id, lFIRST, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lNEXT, 1, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 2, &rap, rapSz);
X	prRap(code, &rap);
X	code = lFndFlagNode(id, lFIRST, 7, &rap, rapSz);
X	prRap(code, &rap);
X	
X	fprintf(stdout, "Untouched list\\n");
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\\n");
X	lSort(id, lDESCENDING, lBUBBLE, compare);
X	prRapAll(id);
X
X	fprintf(stdout, "lSort\\n");
X	lSort(id, lASCENDING, lHEAP, compare);
X	prRapAll(id);
X
X	lDelAll();
X}
X
Xstatic void
XinsRap(id, where, flag, title, author, date)
Xint		id, where, flag, date;
Xchar		*title, *author;
X{
X	int		code;
X	Rapport	rap;
X
X	strcpy(rap.title, title);
X	strcpy(rap.author, author);
X	rap.date = date;
X	code = lInsNode(id, where, &rap, rapSz, flag);
X}
X
Xstatic void
XprRapAll(id)
Xint	id;
X{
X	int		code;
X	Rapport	rap;
X
X	code = lGetNode(id, lFIRST, &rap, rapSz);
X	prRap(code, &rap);
X	while (code == lFIRST || code == lSUCCESS || code == lLAST) {
X		code = lGetNode(id, lNEXT, &rap, rapSz);
X		prRap(code, &rap);
X	}
X}
X
Xstatic void
XprRap(code, rpprt)
Xint			code;
XRapport		*rpprt;
X{
X	if (code >= 0)
X		fprintf(stdout, "Rapport : '%s' '%s' '%d'\\n", rpprt->title,
X			rpprt->author, rpprt->date);
X	else
X		fprintf(stdout, "Return code = %d\\n", code);
X}
X
Xstatic int
Xsearch(date, rpprt)
Xint			*date;
XRapport		*rpprt;
X{
X	if (rpprt->date > *date)
X		return(lFOUND);
X	else
X		return(lNOT_FOUND);
X}
X
Xstatic int 
Xcompare(data1, data2)
XRapport *data1, *data2;
X{
X	int	k = strcmp(data1->author, data2->author);
X
X	if (k == 0)
X		return(lSAME);	/* key1 == key2 */
X	else if (k > 0)
X		return(l2LT1);	/* key1 > key2 */
X	else if (k < 0)
X		return(l1LT2);	/* key1 < key2 */
X}
X.fi
X.SH VERSION
XGeneric Linked List 0.9, May 1993.
X.SH PUBLIC DOMAIN
XThe Generic Linked List package is in the public domain. If you have
Xany comments, suggestions, or find any bugs, or make any changes you'd
Xlike to share, please let me know.
X.SH AUTHOR
XCopyright (c) 1993 by Anita Eijs (anita@bouw.tno.nl).
X.sp 1
X.nf
XTNO - Bouw - BouwInformatica
XP.O. Box 49
X2600 AA Delft
XThe Netherlands
X.fi
END_OF_FILE
  if test 7126 -ne `wc -c <'Doc/Intro.3'`; then
    echo shar: \"'Doc/Intro.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/Intro.3'
fi
if test -f 'Doc/lDef.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDef.3'\"
else
  echo shar: Extracting \"'Doc/lDef.3'\" \(1055 characters\)
  sed "s/^X//" >'Doc/lDef.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDef"
X.IX lDef
X.SH NAME
XlDef - Define linked list.
X.SH SYNOPSIS
Xint
X.BR "lDef" "(sd, cc)"
X.br
X.RT
X.RP
XIn	int	sd	singly or doubly linked list
X.br
X.RP
XIn	int	cc	chain or circular linked list
X.DT
X.SH DESCRIPTION
XTo define a linked list use \fBlDef\fP. It is possible to define a
Xsingly or doubly linked list and a chain or circular linked list.
XThe routine returns the identifier of the defined linked list (\(>= 1),
Xwhich must be used in the other routines of the linked list tool.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIsd\fP :
X.nf
X	lSINGLY	singly linked list, each node points to the next node
X	lDOUBLY	doubly linked list, each node points to the previous and
X		the next node
X.fi
X.sp 1
X\fIcc\fP :
X.nf
X	lCHAIN	chain linked list, last node has a NULL-pointer
X	lCIRCULAR	circular linked list, last node points back to the first node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	identifier of linked list (\(>= 1)
XReturn on error :
X	lWRONG_SD, lWRONG_CC, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1055 -ne `wc -c <'Doc/lDef.3'`; then
    echo shar: \"'Doc/lDef.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDef.3'
fi
if test -f 'Doc/lDel.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDel.3'\"
else
  echo shar: Extracting \"'Doc/lDel.3'\" \(348 characters\)
  sed "s/^X//" >'Doc/lDel.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDel"
X.IX lDel
X.SH NAME
XlDel - Delete linked list.
X.SH SYNOPSIS
Xint
X.BR "lDel" "(id)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.DT
X.SH DESCRIPTION
X\fBlDel\fP deletes a linked list.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 348 -ne `wc -c <'Doc/lDel.3'`; then
    echo shar: \"'Doc/lDel.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDel.3'
fi
if test -f 'Doc/lDelAll.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelAll.3'\"
else
  echo shar: Extracting \"'Doc/lDelAll.3'\" \(322 characters\)
  sed "s/^X//" >'Doc/lDelAll.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelAll"
X.IX lDelAll
X.SH NAME
XlDelAll - Delete all linked lists.
X.SH SYNOPSIS
Xint
X.BR "lDelAll" "()"
X.br
X.DT
X.SH DESCRIPTION
X\fBlDelAll\fP deletes all linked lists.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lNO_LIST
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 322 -ne `wc -c <'Doc/lDelAll.3'`; then
    echo shar: \"'Doc/lDelAll.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelAll.3'
fi
if test -f 'Doc/lDelIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lDelIndxNode.3'\" \(617 characters\)
  sed "s/^X//" >'Doc/lDelIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelIndxNode"
X.IX lDelIndxNode
X.SH NAME
XlDelIndxNode - Delete node by index.
X.SH SYNOPSIS
Xint
X.BR "lDelIndxNode" "(id, index)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	index	index of node which must be deleted
X.DT
X.SH DESCRIPTION
X\fBlDelIndxNode\fP deletes an indexed node from a linked list. Which node
Xmust be deleted can be specified by \fIindex\fP (\(>= 1).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 617 -ne `wc -c <'Doc/lDelIndxNode.3'`; then
    echo shar: \"'Doc/lDelIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelIndxNode.3'
fi
if test -f 'Doc/lDelNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDelNode.3'\"
else
  echo shar: Extracting \"'Doc/lDelNode.3'\" \(716 characters\)
  sed "s/^X//" >'Doc/lDelNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDelNode"
X.IX lDelNode
X.SH NAME
XlDelNode - Delete node.
X.SH SYNOPSIS
Xint
X.BR "lDelNode" "(id, which)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	which	which node must be deleted
X.DT
X.SH DESCRIPTION
X\fBlDelNode\fP deletes a node from a linked list. Which node must be
Xdeleted can be specified by \fIwhich\fP. The first, the current and
Xthe last node of a linked list can be deleted.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	first node
X	lCURRENT	current node
X	lLAST	last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 716 -ne `wc -c <'Doc/lDelNode.3'`; then
    echo shar: \"'Doc/lDelNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDelNode.3'
fi
if test -f 'Doc/lDump.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lDump.3'\"
else
  echo shar: Extracting \"'Doc/lDump.3'\" \(793 characters\)
  sed "s/^X//" >'Doc/lDump.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lDump"
X.IX lDump
X.SH NAME
XlDump - Dump a linked list to a file.
X.SH SYNOPSIS
Xint
X.BR "lDump" "(id, file)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlDump\fP is a linked list dumping utility. It allows the user to store
Xlinked list data in a specially formatted file, so the linked list data can
Xbe used within another program session. This file can be read by the linked
Xlist undumping utility lUndump.
X.br
XDon't use pointers within your data structure, because only the pointers
Xwill be written in the dump file, not the data pointed to.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lOPEN_ERROR
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 793 -ne `wc -c <'Doc/lDump.3'`; then
    echo shar: \"'Doc/lDump.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lDump.3'
fi
if test -f 'Doc/lFndFlagNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFndFlagNode.3'\"
else
  echo shar: Extracting \"'Doc/lFndFlagNode.3'\" \(1632 characters\)
  sed "s/^X//" >'Doc/lFndFlagNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFndFlagNode"
X.IX lFndFlagNode
X.SH NAME
XlFndFlagNode - Get node by flag.
X.SH SYNOPSIS
Xint
X.BR "lFndFlagNode" "(id, which, flag, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	which	from which node must be searched and in which direction
X.br
X.RP
XIn	int	flag	flag of node which must be retrieved
X.br
X.RP
XOut	Byte	*data	data of node
X.br
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFndFlagNode\fP searches a 'flagged' node from the linked list. From
Xwhich node the searching must start and in which direction must be
Xsearched can be specified by \fIwhich\fP. A node can be searched forward
Xfrom the beginning of the list (lFIRST) or from the current node (lNEXT)
Xand backward from the end of the list (lLAST) or from the current node
X(lPREVIOUS).
X.br
XBackward searching is only possible for doubly linked list.
X.br
XWhen the found node is the first or the last node, the return code will
Xhave the value lFIRST or lLAST, otherwise lFOUND.
XWhen the linked list contains only one node, the return code will have
Xthe value lFIRST, when searching backward, and the value lLAST, when
Xsearching forward.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	search forward starting from the first node
X	lNEXT	search forward starting from the next node
X	lLAST	search backward starting from the last node
X	lPREVIOUS	search backward starting from the previous node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lFOUND, lFIRST, lLAST, lNOT_FOUND
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lSIZE_NE
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1632 -ne `wc -c <'Doc/lFndFlagNode.3'`; then
    echo shar: \"'Doc/lFndFlagNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFndFlagNode.3'
fi
if test -f 'Doc/lFndNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lFndNode.3'\"
else
  echo shar: Extracting \"'Doc/lFndNode.3'\" \(2055 characters\)
  sed "s/^X//" >'Doc/lFndNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lFndNode"
X.IX lFndNode
X.SH NAME
XlFndNode - Find node.
X.SH SYNOPSIS
Xint
X.BR "lFndNode" "(id, which, func, ptr, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.br
X.RP
XIn	int	which	from which node must be searched and in which direction
X.br
X.RP
XIn	int	(*func)()	function for checking the data on conditions
X.br
X.RP
XIn	Byte	*ptr	data for comparison in function
X.br
X.RP
XOut	Byte	*data	data of node
X.br
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlFndNode\fP searches a node from the linked list, using the user
Xdefined search function \fIfunc\fP, which checks the data of a node
Xon conditions. This function must have two parameters, a pointer to
Xthe data to compare with and a pointer to the data of a node. The
Xpossible return values are lFOUND or lNOT_FOUND. See the introduction
Xof Generic Linked List for an example of such a search function. From
Xwhich node the searching must start and in which direction must be
Xsearched can be specified by \fIwhich\fP. A node can be searched
Xforward from the beginning of the list (lFIRST) or from the current
Xnode (lNEXT) and backward from the end of the list (lLAST) or from
Xthe current node (lPREVIOUS).
X.br
XBackward searching is only possible for doubly linked list.
X.br
XWhen the found node is the first or the last node, the return code will
Xhave the value lFIRST or lLAST, otherwise lFOUND.
XWhen the linked list contains only one node, the return code will have
Xthe value lFIRST, when searching backward, and the value lLAST, when
Xsearching forward.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	search forward starting from the first node
X	lNEXT	search forward starting from the next node
X	lLAST	search backward starting from the last node
X	lPREVIOUS	search backward starting from the previous node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lFOUND, lFIRST, lLAST, lNOT_FOUND
XReturn on error :
X.fi
X.in +0.2i
XlUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lNOT_DOUBLY, lUNKNOWN_FUNC
X.in -0.2i
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 2055 -ne `wc -c <'Doc/lFndNode.3'`; then
    echo shar: \"'Doc/lFndNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lFndNode.3'
fi
if test -f 'Doc/lGetIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lGetIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lGetIndxNode.3'\" \(835 characters\)
  sed "s/^X//" >'Doc/lGetIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lGetIndxNode"
X.IX lGetIndxNode
X.SH NAME
XlGetIndxNode - Get node by index.
X.SH SYNOPSIS
Xint
X.BR "lGetIndxNode" "(id, index, data, size)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be retrieved
X.RP
XOut	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.DT
X.SH DESCRIPTION
X\fBlGetIndxNode\fP gets the data of an indexed node of a linked list. Which
Xnode must be retrieved can be specified by \fIindex\fP (\(>= 1).
X.br
XWhen the retrieved node is the first or the last node, the return code
Xwill have the value lFIRST or lLAST. For the other nodes the routine returns
XlSUCCESS.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS, lFIRST, lLAST
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX, lSIZE_NE
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 835 -ne `wc -c <'Doc/lGetIndxNode.3'`; then
    echo shar: \"'Doc/lGetIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lGetIndxNode.3'
fi
if test -f 'Doc/lInfo.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfo.3'\"
else
  echo shar: Extracting \"'Doc/lInfo.3'\" \(657 characters\)
  sed "s/^X//" >'Doc/lInfo.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfo"
X.IX lInfo
X.SH NAME
XlInfo - Get information about linked list.
X.SH SYNOPSIS
Xint
X.BR "lInfo" "(id, sd, cc, n)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XOut	int	*sd	singly or doubly linked list
X.RP
XOut	int	*cc	chain or circular linked list
X.RP
XOut	int	*n	number of nodes
X.DT
X.SH DESCRIPTION
X\fBlInfo\fP returns some information about a linked list. The type of
Xthe linked list (\fIsd\fP and \fIcc\fP, defined by the user) and the
Xnumber of nodes added to the linked list (\fIn\fP).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 657 -ne `wc -c <'Doc/lInfo.3'`; then
    echo shar: \"'Doc/lInfo.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfo.3'
fi
if test -f 'Doc/lInfoIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfoIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lInfoIndxNode.3'\" \(837 characters\)
  sed "s/^X//" >'Doc/lInfoIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfoIndxNode"
X.IX lInfoIndxNode
X.SH NAME
XlInfoIndxNode - Get information about node by index.
X.SH SYNOPSIS
Xint
X.BR "lInfoIndxNode" "(id, index, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be inspected
X.RP
XOut	int	*size	size of data of node
X.RP
XOut	int	*flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInfoIndxNode\fP returns some information about an indexed node.
XThe size of the data of the node (\fIsize\fP) and the user information
Xflag (\fIflag\fP). Of which node the information must be given can be
Xspecified by \fIindex\fP (\(>= 1).
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 837 -ne `wc -c <'Doc/lInfoIndxNode.3'`; then
    echo shar: \"'Doc/lInfoIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfoIndxNode.3'
fi
if test -f 'Doc/lInfoNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInfoNode.3'\"
else
  echo shar: Extracting \"'Doc/lInfoNode.3'\" \(1197 characters\)
  sed "s/^X//" >'Doc/lInfoNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInfoNode"
X.IX lInfoNode
X.SH NAME
XlInfoNode - Get information about node.
X.SH SYNOPSIS
Xint
X.BR "lInfoNode" "(id, which, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	which	which node must be inspected
X.RP
XOut	int	*size	size of data of node
X.RP
XOut	int	*flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInfoNode\fP returns some information about a node. The size of
Xthe data of the node (\fIsize\fP) and the user information flag
X(\fIflag\fP). Of which node the information must be given can be
Xspecified by \fIwhich\fP. The first node, the current node, the node
Xbefore or after the current node and the node at the end of the list
Xcan be inspected.
X.br
XBackward retrieving is only possible for doubly linked list. A previous
Xnode can't be inspected for singly linked lists.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhich\fP :
X.nf
X	lFIRST	first node
X	lPREVIOUS	previous node
X	lCURRENT	current node
X	lNEXT	next node
X	lLAST	last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X.fi
X.in +0.2i
XlUNKNOWN_ID, lEMPTY_LIST, lWRONG_WHICH, lNOT_DOUBLY, lEOL
X.in -0.2i
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1197 -ne `wc -c <'Doc/lInfoNode.3'`; then
    echo shar: \"'Doc/lInfoNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInfoNode.3'
fi
if test -f 'Doc/lInsNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lInsNode.3'\"
else
  echo shar: Extracting \"'Doc/lInsNode.3'\" \(1090 characters\)
  sed "s/^X//" >'Doc/lInsNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lInsNode"
X.IX lInsNode
X.SH NAME
XlInsNode - Insert node.
X.SH SYNOPSIS
Xint
X.BR "lInsNode" "(id, where, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	where	place where node must be inserted
X.RP
XIn	Byte	*data	data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	user information flag
X.DT
X.SH DESCRIPTION
X\fBlInsNode\fP inserts a node in a linked list. Where the node must be
Xinserted can be specified by \fIwhere\fP. A node can be added at the
Xfront of the list, before or after the current node and at the end of
Xthe list. For each node a flag can be set by the user, e.g. to identify
Xthe node or the type of node. When the flag identifies the node you can
Xretrieve the nodes by flag (lFndFlagNode).
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIwhere\fP :
X.nf
X	lFIRST	as first node
X	lBEFORE	before current node
X	lAFTER	after current node
X	lLAST	as last node
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lWRONG_WHERE, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 1090 -ne `wc -c <'Doc/lInsNode.3'`; then
    echo shar: \"'Doc/lInsNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lInsNode.3'
fi
if test -f 'Doc/lSize.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lSize.3'\"
else
  echo shar: Extracting \"'Doc/lSize.3'\" \(416 characters\)
  sed "s/^X//" >'Doc/lSize.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lSize"
X.IX lSize
X.SH NAME
XlSize - Get number of nodes in linked list.
X.SH SYNOPSIS
Xint
X.BR "lSize" "(id)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.DT
X.SH DESCRIPTION
X\fBlSize\fP returns the number of nodes added to the linked list.
X.SH RETURN CODES
X.nf
XReturn on success :
X	number of nodes (\(>= 0)
XReturn on error :
X	lUNKNOWN_ID
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 416 -ne `wc -c <'Doc/lSize.3'`; then
    echo shar: \"'Doc/lSize.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lSize.3'
fi
if test -f 'Doc/lSort.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lSort.3'\"
else
  echo shar: Extracting \"'Doc/lSort.3'\" \(1297 characters\)
  sed "s/^X//" >'Doc/lSort.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lSort"
X.IX lSort
X.SH NAME
XlSort - Sort a linked list.
X.SH SYNOPSIS
Xint
X.BR "lSort" "(id, order, theory, func)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	order	sorting order
X.RP
XIn	int	theory	sorting theory
X.RP
XIn	int	(*func)()	function for comparing the data of two nodes
X.DT
X.SH DESCRIPTION
X\fBlSort\fP sorts a linked list in the specified \fIorder\fP, using
Xthe specified \fItheory\fP, and the user defined function \fIfunc\fP,
Xwhich compares the data of two nodes. This function must have two
Xparameters, two pointers to the data of a node. The possible return
Xvalues are lSAME, l1LT2 and l2LT1. See the introduction of Generic
XLinked List for an example of such a compare function.
X.SH PARAMETER DEFINITIONS
X.if t .ta 0.2i 1.5i
X\fIorder\fP :
X.nf
X	lASCENDING	'a', 'b', 'c', ...
X	lDESCENDING	'z', 'y', 'x', ...
X.fi
X.sp 1
X\fItheory\fP :
X.nf
X	lBUBBLE	bubble sorting algorithm
X	lHEAP	heap sorting algorithm
X	lINSERT	insert sorting algorithm
X	lQUICK	quick sorting algorithm
X	lSELECTION	selection sorting algorithm
X.fi
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_ORDER, lWRONG_THEORY, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 1297 -ne `wc -c <'Doc/lSort.3'`; then
    echo shar: \"'Doc/lSort.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lSort.3'
fi
if test -f 'Doc/lUndump.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUndump.3'\"
else
  echo shar: Extracting \"'Doc/lUndump.3'\" \(826 characters\)
  sed "s/^X//" >'Doc/lUndump.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUndump"
X.IX lUndump
X.SH NAME
XlUndump - Undump a linked list from a file.
X.SH SYNOPSIS
Xint
X.BR "lUndump" "(file)"
X.br
X.RT
X.RP
XIn	char	*file	name of linked list dump file
X.DT
X.SH DESCRIPTION
X\fBlUndump\fP is a linked list undumping utility. The user will be able to
Xuse linked list data that was saved by lDump in the same or an earlier
Xprogram session. The linked list data was saved in a specially formatted
Xfile by lDump. The routine returns the identifier of the undumped linked
Xlist (\(>= 1), which must be used in the other routines of the linked list
Xtool. This identifier doesn't have to be the same as used by lDump.
X.SH RETURN CODES
X.nf
XReturn on success :
X	identifier of linked list (\(>=1)
XReturn on error :
X	lOPEN_ERROR, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 826 -ne `wc -c <'Doc/lUndump.3'`; then
    echo shar: \"'Doc/lUndump.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUndump.3'
fi
if test -f 'Doc/lUpdIndxNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUpdIndxNode.3'\"
else
  echo shar: Extracting \"'Doc/lUpdIndxNode.3'\" \(833 characters\)
  sed "s/^X//" >'Doc/lUpdIndxNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUpdIndxNode"
X.IX lUpdIndxNode
X.SH NAME
XlUpdIndxNode - Update node by index.
X.SH SYNOPSIS
Xint
X.BR "lUpdIndxNode" "(id, index, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	int	index	index of node which must be updated
X.RP
XIn	Byte	*data	updated data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	updated user information flag
X.DT
X.SH DESCRIPTION
X\fBlUpdIndxNode\fP updates an indexed node in a linked list, in fact
Xthis routine replaces the data of the indexed node by the data of the
Xupdated node. The flag for user information can also be updated.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lWRONG_INDEX, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
X.nf
XAnita Eijs (TNO - Bouw - BouwInformatica)
XShane Brath (University of Wisconsin)
X.fi
END_OF_FILE
  if test 833 -ne `wc -c <'Doc/lUpdIndxNode.3'`; then
    echo shar: \"'Doc/lUpdIndxNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUpdIndxNode.3'
fi
if test -f 'Doc/lUpdNode.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/lUpdNode.3'\"
else
  echo shar: Extracting \"'Doc/lUpdNode.3'\" \(693 characters\)
  sed "s/^X//" >'Doc/lUpdNode.3' <<'END_OF_FILE'
X'.so tmac.clman
X.TH "lUpdNode"
X.IX lUpdNode
X.SH NAME
XlUpdNode - Update current node.
X.SH SYNOPSIS
Xint
X.BR "lUpdNode" "(id, data, size, flag)"
X.br
X.RT
X.RP
XIn	int	id	identifier of linked list
X.RP
XIn	Byte	*data	updated data of node
X.RP
XIn	int	size	size of data
X.RP
XIn	int	flag	updated user information flag
X.DT
X.SH DESCRIPTION
X\fBlUpdNode\fP updates the current node in a linked list, in fact
Xthis routine replaces the data of the current node by the data of the
Xupdated node. The flag for user information can also be updated.
X.SH RETURN CODES
X.nf
XReturn on success :
X	lSUCCESS
XReturn on error :
X	lUNKNOWN_ID, lEMPTY_LIST, lOUT_OF_MEMORY
X.fi
X.SH AUTHOR
XAnita Eijs (TNO - Bouw - BouwInformatica)
END_OF_FILE
  if test 693 -ne `wc -c <'Doc/lUpdNode.3'`; then
    echo shar: \"'Doc/lUpdNode.3'\" unpacked with wrong size!
  fi
  # end of 'Doc/lUpdNode.3'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(1995 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Generic Linked List
X#
X# Anita Eijs, TNO-BOUW, BouwInformatica, September 1989
X
X# Include rules for package
XMAKERULE= Tools_makerule
XRULE	= $(TOOLS_HOME)/$(MAKERULE)
Xinclude $(RULE)
X
X# Operating Systems:	UNIX, MSDOS, VAXC, MAC, AMIGA
X# Create error file:	ERROR_FILE
X#CFLAGS	= -DUNIX -DERROR_FILE
XCFLAGS	= -DUNIX
X# Compiler options
XCC	= gcc
X
XTOOLS_HOME	= /usr2/user/anita/Tools
X
X# Name of current directory
XDIR	= List
X
X# Name of library
X#LIB	= $(TOOLS_HOME)/Lib/list.a
XLIB	= ./list.a
X
X# Contents of current directory
XLIST	= CHANGES \
X	Makefile Makefile.Amiga Makefile.BCC \
X	README ReadMe.Amiga ReadMe.BCC \
X	list.c list.h \
X	example.c sorted.c sorttest.c
X
X# Documentation
XDOC	= \
X	Doc/Intro.3		Doc/lDef.3		Doc/lDel.3 \
X	Doc/lDelAll.3		Doc/lDelIndxNode.3	Doc/lDelNode.3 \
X	Doc/lDump.3		Doc/lFndFlagNode.3	Doc/lFndNode.3 \
X	Doc/lGetNode.3		Doc/lGetIndxNode.3	Doc/lInfo.3 \
X	Doc/lInfoIndxNode.3	Doc/lInfoNode.3		Doc/lInsNode.3 \
X	Doc/lSize.3		Doc/lSort.3		Doc/lUndump.3 \
X	Doc/lUpdIndxNode.3	Doc/lUpdNode.3
X
X# Object dependencies
XOBJ	= list.o
X
XLIB_OBJ	= $(LIB)(list.o)
X
X# The targets
Xusage:
X		$(ECHO)
X		$(ECHO) $(USAGE_ID)
X		$(ECHO) $(USAGE_TARGETS)
X		$(ECHO) $(USAGE_USAGE)
X		$(ECHO) $(USAGE_LIB)
X		$(ECHO) $(USAGE_NEWLIB)
X		$(ECHO) $(USAGE_OFILES)
X		$(ECHO) $(USAGE_TEST)
X		$(ECHO) $(USAGE_TAR)
X		$(ECHO)
X		$(ECHO) $(USAGE_DEFLTS1)
X		$(ECHO) $(USAGE_DEFLTS2)
X		$(ECHO) $(USAGE_DEFLTS3)
X
Xall: ofiles newlib example sorttest sorted
X
Xlib:		$(LIB_OBJ)
X		$(RANLIB) $(LIB)
X
Xnewlib:		$(OBJ)
X		$(AR) r $(LIB) *.o
X		rm -f *.o
X		$(RANLIB) $(LIB)
X
Xofiles:		$(OBJ)
X
Xtest:		example sorttest sorted
X
Xexample:	$(LIB) example.o
X		$(CC) -o example example.o $(LIB)
X
Xsorttest:	$(LIB) sorttest.o
X		$(CC) -o sorttest sorttest.o $(LIB)
X
Xsorted:		$(LIB) sorted.o
X		$(CC) -o sorted sorted.o $(LIB)
X
Xtar:
X		$(ECHO) "Making tar-file in $(TARFILE)"
X		cp ../$(MAKERULE) $(MAKERULE)
X		tar cvf $(TARFILE) $(MAKERULE) $(LIST) $(DOC)
X		rm $(MAKERULE)
X
Xclean:
X		$(ECHO) "Cleaning Directory"
X		rm $(OBJ) example sorttest sorted
END_OF_FILE
  if test 1995 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'Makefile.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.Amiga'\"
else
  echo shar: Extracting \"'Makefile.Amiga'\" \(1085 characters\)
  sed "s/^X//" >'Makefile.Amiga' <<'END_OF_FILE'
X# Generic Linked List
X#
X# Anita Eijs, TNO-BOUW, BouwInformatica, September 1989
X# Amiga Port By James Diffendaffer, May 1993
X# SAS 6.0 Makefile
X
XCC	= sc
XASM	= asm
XLINK	= slink
XSTARTUP	= lib:c.o
X#MYLIBS	= 
XCFLAGS	= streq strmer nominc nostkchk ansi noicons \
X	DEF=ANSI DEF=AMIGA IGN=88 IGN=304
XAFLAGS	= -iInclude:
XLFLAGS	= BATCH SC ND
X# DEFINE ___main=___tinymain
X
XAPP		= example
XHFL		= list.h
XCFILES	= example.c sorted.c sorttest.c list.c
XOFILES	= example.o sorted.o sorttest.o list.o
XHFILES	= list.h
X
Xexample:	example.o list.o sorted sorttest Makefile.Amiga
X	$(LINK) FROM $(STARTUP) example.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO example ${LFLAGS}
Xsorted:	sorted.o list.o Makefile.Amiga
X	$(LINK) FROM $(STARTUP) sorted.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO sorted ${LFLAGS}
Xsorttest:	sorttest.o list.o Makefile.Amiga
X	$(LINK) FROM $(STARTUP) sorttest.o list.o \
X	LIB lib:sc.lib lib:amiga.lib \
X	TO sorttest ${LFLAGS}
X
Xexample.o:
X	$(CC) $(CFLAGS) example.c
X
Xsorted.o:
X	$(CC) $(CFLAGS) sorted.c
X
Xsorttest.o:
X	$(CC) $(CFLAGS) sorttest.c
X
Xlist.o:
X	$(CC) $(CFLAGS) list.c
END_OF_FILE
  if test 1085 -ne `wc -c <'Makefile.Amiga'`; then
    echo shar: \"'Makefile.Amiga'\" unpacked with wrong size!
  fi
  # end of 'Makefile.Amiga'
fi
if test -f 'Makefile.BCC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.BCC'\"
else
  echo shar: Extracting \"'Makefile.BCC'\" \(5737 characters\)
  sed "s/^X//" >'Makefile.BCC' <<'END_OF_FILE'
X.AUTODEPEND
X
X#
X# Linked List Tool -- makefile for Borland C++ v3.1
X#
X# Gabe Helou <gabe@angus.mi.org>, September 1992
X#                                                                 
X# This make file has been tested with MS-DOS versions of tar, shar,
X# zip, and lha.
X#
X
XTOOLS_HOME     = c:\usr
XMAKERULE       = Tools_makerule
X
X# Name of current directory
XDIR    = .
X
X# Name of library
XLIB    = $(TOOLS_HOME)\lib
X
X# Name of user include dir
XINC    = $(TOOLS_HOME)\include
X
X# Contents of current directory
XLIST   = Makefile README example.c list.c list.h
X
X#          *Translator Definitions*
X
XCC = bcc +list.CFG
XFLAGS       = -O2 -c
XTASM        = TASM
XTLIB        = tlib
XTLINK       = tlink
XSHAR        = shar -v -c -pXX
X
XLIBPATH     = $(BCDIR)\lib
XINCLUDEPATH = $(BCDIR)\include
X
XTARFILE     = $(TOOLS_HOME)\llistt.tar
XSHARFILE    = $(TOOLS_HOME)\llistt.shr
XZIPFILE     = $(TOOLS_HOME)\llistt.zip
XLHAFILE     = $(TOOLS_HOME)\llistt.lzh
X
X# Doc list for shar
XDOC_1 = Doc/Intro.1    Doc/lDef.1      Doc/lDel.1      Doc/lDelAll.1
XDOC_2 = Doc/lDelNode.1 Doc/lDump.1     Doc/lFlagNode.1 Doc/lFndNode.1
XDOC_3 = Doc/lGetNode.1 Doc/lIndxNode.1 Doc/lInfo.1     Doc/lInfoNode.1
XDOC_4 = Doc/lInsNode.1 Doc/lUndump.1   Doc/lUpdNode.1
X
XDOC_ALL_1 = Doc/Intro.man    Doc/lDef.man      Doc/lDel.man      Doc/lDelAll.man
XDOC_ALL_2 = Doc/lDelNode.man Doc/lDump.man     Doc/lFlagNode.man Doc/lFndNode.man
XDOC_ALL_3 = Doc/lGetNode.man Doc/lIndxNode.man Doc/lInfo.man     Doc/lInfoNode.man
XDOC_ALL_4 = Doc/lInsNode.man Doc/lUndump.man   Doc/lUpdNode.man  
XDOC_ALL_5 = Doc/list_doc.ps
X
X#              *Implicit Rules*
X
X.c.obj:
X  $(CC) $(FLAGS) {$< }
X
X.cpp.obj:
X  $(CC) $(FLAGS) {$< }
X
X
X#              *List Macros*
X
XLIB_dependencies =  \
X  list.obj
X
X
X#              *Targets*
X
Xusge:   usage.msg
X    type usage.msg
X
Xall:      lib
X
Xinstall:  newlib
X
Xclean:
X    del list.obj
X    del list.lib
X    
Xlist.lib: lib
X
Xlib:      list.cfg $(LIB_dependencies)
X    del list.lib
X    $(TLIB) /C /E /e list.lib +list.obj
X
Xnewlib:   list.h list.lib
X    copy list.lib $(LIB)
X    copy list.h   $(INC)
X
Xofiles:   $(LIB_dependencies)
X
Xtest:     example
X
Xexample:  $(LIB)\list.lib example.obj
X        $(CC) -c $(FLAGS) example.c
X        $(TLINK) /v/x/c/P-/L$(LIBPATH);$(LIB) @&&|
Xc0l.obj+
Xexample.obj
Xexample
X       	     	# no map file
Xemu.lib+
Xmathl.lib+
Xlist.lib+
Xcl.lib
X|
X
Xtar:    doc.lst doc_all.lst src.lst
X        echo Making tar-file in $(TARFILE)
X        type doc.lst      >  $$tartmp
X        type doc_all.lst  >> $$tartmp
X        echo $(MAKERULE)  >> $$tartmp
X        type src.lst      >> $$tartmp
X        tar -cvf $(TARFILE) -T $$tartmp
X        del $$tartmp
X
Xshar:
X        echo Making shar-file in $(SHARFILE)
X        $(SHAR) $(MAKERULE) >  $(SHARFILE)
X        $(SHAR) $(LIST)     >> $(SHARFILE)
X        $(SHAR) $(DOC_1)    >> $(SHARFILE)
X        $(SHAR) $(DOC_2)    >> $(SHARFILE)
X        $(SHAR) $(DOC_3)    >> $(SHARFILE)
X        $(SHAR) $(DOC_4)    >> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_1)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_2)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_3)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_4)>> $(SHARFILE)
X        $(SHAR) $(DOC_ALL_5)>> $(SHARFILE)
X        dos2unix $(SHARFILE)
X
Xshort_shar:
X        echo Making short shar-file in $(SHARFILE)
X        $(SHAR) $(MAKERULE) >  $(SHARFILE)
X        $(SHAR) $(LIST)     >> $(SHARFILE)
X        $(SHAR) $(DOC_1)    >> $(SHARFILE)
X        $(SHAR) $(DOC_2)    >> $(SHARFILE)
X        $(SHAR) $(DOC_3)    >> $(SHARFILE)
X        $(SHAR) $(DOC_4)    >> $(SHARFILE)
X        dos2unix $(SHARFILE)
X
Xzip:    doc.lst doc_all.lst
X        echo Making ZIP-file in $(ZIPFILE)
X        pkzip -ap $(ZIPFILE) $(MAKERULE) $(LIST)
X        pkzip -ap $(ZIPFILE) @doc.lst
X        pkzip -ap $(ZIPFILE) @doc_all.lst
X#                           zip    $(ZIPFILE) $(MAKERULE) $(LIST)
X#        type doc.lst     | zip -@ $(ZIPFILE)
X#        type doc_all.lst | zip -@ $(ZIPFILE)
X
Xlha:    doc.lst doc_all.lst
X        echo Making lha-file in $(LHAFILE)
X        lha a /x1 $(LHAFILE) $(MAKERULE) $(LIST)
X        lha a /x1 $(LHAFILE) @doc.lst
X        lha a /x1 $(LHAFILE) @doc_all.lst
X
Xlist.obj: list.cfg list.c list.h
X
Xusage.msg:  makefile.bcc
X    copy &&|
X
X  Makefile of directory $(DIR)
X
X  Targets are:
X
X     usge         = Prints this
X     lib          = Make objects for LIB
X     newlib       = Make objects and place them in LIB
X     ofiles       = Make objects
X     test/example = Make test program
X     tar          = Make TARFILE
X     shar         = Make SHARFILE
X     zip          = Make ZIPFILE
X     lha          = Make LHAFILE
X
X     all          = same as 'lib'
X     install      = same as 'newlib'
X     clean        = remove object files and temp files
X
X  defaults:
X
X     TARFILE  = $(TARFILE)
X     LIB      = $(LIB)
X     SHARFILE = $(SHARFILE)
X     ZIPFILE  = $(ZIPFILE)
X     LHAFILE  = $(LHAFILE)
X
X| usage.msg
X
X# Documentation
Xdoc.lst:  makefile.bcc
X   copy &&|
XDoc/Intro.1             
XDoc/lDef.1
XDoc/lDel.1
XDoc/lDelAll.1
XDoc/lDelNode.1
XDoc/lDump.1
XDoc/lFlagNode.1
XDoc/lFndNode.1
XDoc/lGetNode.1
XDoc/lIndxNode.1
XDoc/lInfo.1
XDoc/lInfoNode.1
XDoc/lInsNode.1
XDoc/lUndump.1
XDoc/lUpdNode.1
X| doc.lst
X
Xdoc_all.lst:  makefile.bcc
X   copy &&|
XDoc/list_doc.ps
XDoc/Intro.man
XDoc/lDef.man
XDoc/lDel.man
XDoc/lDelAll.man
XDoc/lDelNode.man
XDoc/lDump.man
XDoc/lFlagNode.man
XDoc/lFndNode.man
XDoc/lGetNode.man
XDoc/lIndxNode.man
XDoc/lInfo.man
XDoc/lInfoNode.man
XDoc/lInsNode.man
XDoc/lUndump.man
XDoc/lUpdNode.man
X| doc_all.lst
X
Xsrc.lst:  makefile.bcc
X   copy &&|
XMakefile
XREADME
Xexample.c 
Xlist.c 
Xlist.h
X| src.lst
X
Xlist.cfg: makefile.bcc
X   copy &&|
X-ml
X-v
X-vi-
X-H=list.SYM
X-w-ret
X-w-nci
X-w-inl
X-wamp
X-w-par
X-w-cpt
X-w-dup
X-w-pia
X-w-ill
X-w-sus
X-wstv
X-w-ext
X-w-ias
X-w-ibc
X-w-pre
X-w-nst
X-I$(INCLUDEPATH)
X-L$(LIBPATH)
X-DANSI
X-DMSDOS
X| list.cfg
END_OF_FILE
  if test 5737 -ne `wc -c <'Makefile.BCC'`; then
    echo shar: \"'Makefile.BCC'\" unpacked with wrong size!
  fi
  # end of 'Makefile.BCC'
fi
if test -f 'ReadMe.Amiga' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe.Amiga'\"
else
  echo shar: Extracting \"'ReadMe.Amiga'\" \(662 characters\)
  sed "s/^X//" >'ReadMe.Amiga' <<'END_OF_FILE'
XThe included makefile for the Amiga is for SAS C 6.0,
Xif you have something else you'll have to modify it.
XBTW, this was a quick-n-dirty makefile, so don't yell
Xat me if you don't like the way it's set up.
XI only put in a couple hours on it (max), don't expect
Xperfection... it works.
XThe makefile does not build a link library.
X
XJust type "smake -f Makefile.Amiga" to build the
Xexamples.
X
XDon't add the time optimization flag "OPT OPTTIME" to
Xthe CFLAGS line of Makefile.Amiga, because this option
Xcauses some problems with the HEAP sorting algorithm.
X
XIf you have questions regarding the Amiga port, you can
Xsend email to:
X
XJames Diffendaffer
Xslwjt@cc.usu.edu
END_OF_FILE
  if test 662 -ne `wc -c <'ReadMe.Amiga'`; then
    echo shar: \"'ReadMe.Amiga'\" unpacked with wrong size!
  fi
  # end of 'ReadMe.Amiga'
fi
if test -f 'ReadMe.BCC' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ReadMe.BCC'\"
else
  echo shar: Extracting \"'ReadMe.BCC'\" \(614 characters\)
  sed "s/^X//" >'ReadMe.BCC' <<'END_OF_FILE'
XThe makefile for Borland C++ v3.1 is made by Gabe Helou
X(gabe@angus.mi.org). If you have any questions regarding
Xthis port, don't ask me, but send mail to Gabe.
X
XShane S. Brath (shane.s.brath@uwrf.edu) suggested to add
Xthe following line to the top of list.c on one line :
X
X#pragma option -ml -v -vi- -w-ret -w-nci -w-inl -wamp -w-par -w-cpt -w-dup -w-pia -w-ill -w-sus -wstv -w-ext -w-ias -w-ibc -w-pre -w-nst -A -G -O2 -w-sus -w-aus -w-par -w-pro -w-rvl
X
XThe addition of the pragma line was meant for Borland and
Xother MSDOS C compilers. The Microsoft C compiler (5.10)
Xgives a warning on this line.
X
XAnita Eijs
END_OF_FILE
  if test 614 -ne `wc -c <'ReadMe.BCC'`; then
    echo shar: \"'ReadMe.BCC'\" unpacked with wrong size!
  fi
  # end of 'ReadMe.BCC'
fi
if test -f 'Tools_makerule' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Tools_makerule'\"
else
  echo shar: Extracting \"'Tools_makerule'\" \(827 characters\)
  sed "s/^X//" >'Tools_makerule' <<'END_OF_FILE'
XTARFILE		= /tmp/Tools$(DIR).tar
XSHARFILE	= /tmp/Tools$(DIR).shar
XAR		= ar
X# RANLIB should be :
X# echo :	IRIX System V Release 3.3.1, Silicon Graphics, Inc.
X# ranlib :	Sun Sparc2 SunOS, Berkeley UNIX
X#	(AE, Dec 91)
X#RANLIB		= echo "Ready with"
XRANLIB		= ranlib
XCOFLAGS		= -q
XCFLAGS		= -O
X
X# Set defaults for macro's
XECHO		= echo $(INDNTTN)
XARG_INDNTTN	= INDNTTN="$(INDNTTN)'	'"
X
X# Help macro
XUSAGE_ID	= "Makefile of directory $(DIR)"
XUSAGE_TARGETS	= "Targets are:"
XUSAGE_USAGE	= "usage		= Prints this"
XUSAGE_LIB	= "lib		= Make objects for LIB"
XUSAGE_NEWLIB	= "newlib		= Make objects and place them in LIB"
XUSAGE_OFILES	= "ofiles		= Make objects"
XUSAGE_TEST	= "test/example	= Make test program"
XUSAGE_TAR	= "tar		= Make TARFILE"
XUSAGE_DEFLTS1	= "defaults:"
XUSAGE_DEFLTS2	= "	TARFILE = $(TARFILE)"
XUSAGE_DEFLTS3	= "	LIB = $(LIB)"
END_OF_FILE
  if test 827 -ne `wc -c <'Tools_makerule'`; then
    echo shar: \"'Tools_makerule'\" unpacked with wrong size!
  fi
  # end of 'Tools_makerule'
fi
if test -f 'list.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list.h'\"
else
  echo shar: Extracting \"'list.h'\" \(3628 characters\)
  sed "s/^X//" >'list.h' <<'END_OF_FILE'
X#define	lBUBBLE		1	/* bubble sorting algorithm */
X#define	lHEAP		2	/* heap sorting algorithm */
X#define	lINSERT		3	/* insert sorting algorithm */
X#define	lQUICK		4	/* quick sorting algorithm */
X#define	lSELECTION	5	/* selection sorting algorithm */
X
X/* Sorting defines by shane.s.brath@uwrf.edu */
X#define lASCENDING 1
X#define lDESCENDING -1
X
X#define	lSAME		1	/* compared nodes are the same */
X#define	l1LT2		2	/* first node is less than second node */
X#define	l2LT1		3	/* second node is less than first node */
X
X#define	lSUCCESS	0	/* function call ended successfully */
X
X#define	lSINGLY		1	/* singly linked list */
X#define	lDOUBLY		2	/* doubly linked list */
X#define	lCHAIN		3	/* chain linked list */
X#define	lCIRCULAR	4	/* circular linked list */
X
X#define	lFIRST		1	/* add at front of list */
X				/* get/find/delete first node */
X#define	lPREVIOUS	2	/* get/find previous node */
X#define	lBEFORE		3	/* add before current node */
X#define	lCURRENT	4	/* get/delete current node */
X#define	lAFTER		5	/* add after current node */
X#define	lNEXT		6	/* get/find next node */
X#define	lLAST		7	/* add at end of list */
X				/* get/find/delete last node */
X
X#define	lONE_NODE	10	/* add first node to list / delete last node */
X
X#define	lWRONG_SD	-1	/* parameter 'sd' has wrong value */
X#define	lWRONG_CC	-2	/* parameter 'cc' has wrong value */
X#define	lWRONG_WHERE	-3	/* parameter 'where' has wrong value */
X#define	lWRONG_WHICH	-4	/* parameter 'which' has wrong value */
X#define	lUNKNOWN_ID	-5	/* list id is unknown */
X#define	lUNKNOWN_FUNC	-6	/* function name is unknown */
X#define	lNO_LIST	-7	/* there are no lists defined */
X#define	lEMPTY_LIST	-8	/* list is empty */
X#define	lEOL		-9	/* end of list reached */
X#define	lNOT_FOUND	-10	/* node not found */
X#define	lNOT_DOUBLY	-11	/* list is not doubly linked */
X#define	lSIZE_NE	-12	/* size of expected data and node not equal */
X#define	lWRONG_INDEX	-13	/* 'index' out of range */
X#define	lOPEN_ERROR	-14	/* can't open dump-file */
X#define	lWRONG_ORDER	-15	/* parameter 'order' has wrong value */
X#define	lWRONG_THEORY	-16	/* parameter 'theory' has wrong value */
X#define	lOUT_OF_MEMORY	-17	/* no more memory to allocate for [cm]alloc */
X
X#define	lFOUND		0	/* node found */
X
X#ifdef MSDOS
X#define	lERROR_FILE	"linklist.err"
X#else
X# ifdef VAXC
X#define	lERROR_FILE	"linklist.err"
X# else
X#define	lERROR_FILE	"=listError="
X# endif
X#endif
X
X#ifdef ANSI
Xtypedef	int		(*Func)();
Xtypedef	unsigned char	Byte;
Xint lDef(int sd, int cc);
Xint lInfo(int id, int *sd, int *cc, int *n);
Xint lSize(int id);
Xint lSort(int id, int order, int theory, Func func);
Xint lDump(int id, char *file);
Xint lUndump(char *file);
Xint lDel(int id);
Xint lDelAll(void);
Xint lInsNode(int id, int where, Byte *data, int size, int flag);
Xint lInfoNode(int id, int which, int *size, int *flag);
Xint lGetNode(int id, int which, Byte *data, int size);
Xint lFndNode(int id, int where, Func func, Byte *ptr, Byte *data, int size);
Xint lFndFlagNode(int id, int where, int flag, Byte *data, int size);
Xint lUpdNode(int id, Byte *data, int size, int flag);
Xint lDelNode(int id, int which);
Xint lInfoIndxNode(int id, int index, int *size, int *flag);
Xint lGetIndxNode(int id, int index, Byte *data, int size);
Xint lUpdIndxNode(int id, int index, Byte *data, int size, int flag);
Xint lDelIndxNode(int id, int index);
X#else
Xint lDef();
Xint lInfo();
Xint lSize();
Xint lSort();
Xint lDump();
Xint lUndump();
Xint lDel();
Xint lDelAll();
Xint lInsNode();
Xint lInfoNode();
Xint lGetNode();
Xint lFndNode();
Xint lFndFlagNode();
Xint lUpdNode();
Xint lDelNode();
Xint lInfoIndxNode();
Xint lGetIndxNode();
Xint lUpdIndxNode();
Xint lDelIndxNode();
X#endif
END_OF_FILE
  if test 3628 -ne `wc -c <'list.h'`; then
    echo shar: \"'list.h'\" unpacked with wrong size!
  fi
  # end of 'list.h'
fi
if test -f 'sorttest.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sorttest.c'\"
else
  echo shar: Extracting \"'sorttest.c'\" \(7405 characters\)
  sed "s/^X//" >'sorttest.c' <<'END_OF_FILE'
X/* Sort torture test */
X
X#ifdef UNIX
X#include	<malloc.h>
X#endif
X
X#ifdef	AMIGA
X#include	<stdlib.h>
X#endif
X
X#ifdef MSDOS
X#include	<malloc.h>
X#endif
X
X#include	<stdio.h>
X#include	<string.h>
X#include	<time.h>
X#include	"list.h"
X
Xtypedef struct catalog {
X	char		number[35];
X	char		title[40];
X	char		author[35];
X	int		date;
X} catalog;
X
X#ifdef ANSI
Xstatic int	compare_author(catalog *a, catalog *b);
Xstatic int	compare_title(catalog *a, catalog *b, int order);
Xstatic void	load_it(int id, int num);
Xstatic void	print_some(int id, int num);
Xstatic time_t	what_time(void);
Xstatic void	diff_time(time_t a, time_t b);
Xstatic void	prRap(int code, catalog *rpprt);
X#else
Xstatic int	compare_author();
Xstatic int	compare_title();
Xstatic void	load_it();
Xstatic void	print_some();
Xstatic time_t	what_time();
Xstatic void	diff_time();
Xstatic void	prRap();
X#endif
X
Xstatic int
Xcompare_author(a, b)
Xcatalog *a, *b;
X{
X	int	k;
X
X	k = strcmp(a->author, b->author);
X
X	if (k == 0)
X		return(lSAME);
X	else if (k > 0)
X		return(l2LT1);
X	else if (k < 0)
X		return(l1LT2);
X}
X
Xstatic int
Xcompare_title(a, b, order)
Xcatalog *a, *b;
Xint order;
X{
X	int	k;
X
X	k = strcmp(a->title, b->title);
X
X	if (k == 0)
X		return(lSAME);
X	else if (k > 0)
X		return(l2LT1);
X	else if (k < 0)
X		return(l1LT2);
X}
X
Xstatic void
Xload_it(id, num)
Xint id;
Xint num;
X{
X	int	loop, size = sizeof(catalog), code;
X	char	c1, c2, c3, c4, c5, c6, c7, c8;
X	catalog	rap;
X
X	c1 = c2 = c3 = c4 = c5 = c6 = c7 = 'A';
X	c7--;
X	for (loop=1; loop<=num; loop++) {
X		c7++;
X
X		if (c7>'Z') {c7 = 'A'; c6++;}
X		if (c6>'Z') {c6 = 'A'; c5++;}
X		if (c5>'Z') {c5 = 'A'; c4++;}
X		if (c4>'Z') {c4 = 'A'; c3++;}
X		if (c3>'Z') {c3 = 'A'; c2++;}
X		if (c2>'Z') {c2 = 'A'; c1++;}
X		if (c1>'Z') {c1 = 'A'; c1 = c2 = c3 = c4 = c5 = c6 = c7 = 'A';}
X
X		sprintf(rap.number,"B-90-%d", loop);
X		sprintf(rap.title, "Book %d", loop);
X		sprintf(rap.author,"%c%c%c%c%c%c%c%d",
X			c1, c2, c3, c4, c5, c6, c7, loop);
X		rap.date = 890129;
X		code = lInsNode(id, lLAST, &rap, size, loop);
X	}
X	/* printf("Linked List created\n"); */
X}
X
Xstatic void
Xprint_some(id, num)
Xint id;
Xint num;
X{
X	int	size = sizeof(catalog), loop;
X	int	code;
X	catalog	rap;
X
X	code = lGetNode(id, lFIRST, &rap, size);
X	prRap(code, &rap);
X
X	for (loop=2; loop<=num; loop++) {
X		code = lGetNode(id, lNEXT, &rap, size);
X		prRap(code, &rap);
X	}
X}
X
Xstatic time_t
Xwhat_time()
X{
X	return((time_t)time(NULL));
X}
X
Xstatic void
Xdiff_time(a, b)
Xtime_t a, b;
X{
X	struct tm	*tt;
X	char		buf1[101], buf2[101];
X	int		hour[2], min[2], sec[2];
X	time_t		x;
X
X	tt = (struct tm *)malloc(sizeof(struct tm *) + 1);
X
X	tt = (struct tm *)localtime(&a);
X	strftime(buf1, 100, "%H %M %S", tt);
X
X	tt = (struct tm *)localtime(&b);
X	strftime(buf2, 100, "%H %M %S", tt);
X
X	sscanf(buf1,"%d %d %d", &hour[0], &min[0], &sec[0]);
X	sscanf(buf2,"%d %d %d", &hour[1], &min[1], &sec[1]);
X
X	printf("Hours = %d  Mins = %d  Secs = %d\n",
X	(hour[1] - hour[0] > 0)?(hour[1] - hour[0]) : (hour[0] - hour[1]),
X	(min[1] - min[0] > 0)?(min[1] - min[0]) : (min[0] - min[1]),
X	(sec[1] - sec[0] > 0)?(sec[1] - sec[0]) : (sec[0] - sec[1]));
X}
X
Xint
Xmain()
X{
X	int	size = sizeof(catalog);
X	int	id, code;
X	time_t	start, finish;
X	catalog	rap;
X
X	/* Quick sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lQuickSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lQUICK, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lQUICK, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort DESCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lQUICK, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lQuickSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lQUICK, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* Heap sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lHeapSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lHEAP, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lHeapSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lHEAP, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lHeapSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lHEAP, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* Selection sort */
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lSelectionSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lSELECTION, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lSelectionSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lSELECTION, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lSelectionSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lSELECTION, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* insertion sort*/
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	printf("lInsertSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lINSERT, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lInsertSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lINSERT, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lInsertSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lINSERT, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X
X	/* start testing sorting efficiency */
X	id = lDef(lSINGLY, lCHAIN);
X	load_it(id, 3000);
X
X	printf("Untouched list\n");
X	print_some(id, 10);
X
X	/* Bubble sort */
X	printf("lBubbleSort DESCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lDESCENDING, lBUBBLE, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lBubbleSort ASCENDING by TITLE : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lBUBBLE, compare_title);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	printf("lBubbleSort ASCENDING by AUTHOR : ");
X	start = what_time();
X	code = lSort(id, lASCENDING, lBUBBLE, compare_author);
X	finish = what_time();
X	diff_time(start, finish);
X	print_some(id, 10);
X
X	code = lDelAll();
X}
X
Xstatic void
XprRap(code, rpprt)
Xint	code;
Xcatalog	*rpprt;
X{
X	if (code >= 0)
X		printf("catalog :'%s'\t'%s'\t'%s'\t'%d'\n", rpprt->number,
X			rpprt->title, rpprt->author, rpprt->date);
X	else
X		printf("Return code = %d\n", code);
X}
END_OF_FILE
  if test 7405 -ne `wc -c <'sorttest.c'`; then
    echo shar: \"'sorttest.c'\" unpacked with wrong size!
  fi
  # end of 'sorttest.c'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
