Newsgroups: comp.sources.misc
From: dfs@doe.carleton.ca (David F. Skoll)
Subject: v39i117:  remind - A replacement for calendar, Patch09c/4
Message-ID: <1993Oct4.203951.8096@sparky.sterling.com>
X-Md4-Signature: 1d433b1fc40db3530e16ead0a828c986
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Dept. of Electronics, Carleton University
Date: Mon, 4 Oct 1993 20:39:51 GMT
Approved: kent@sparky.sterling.com

Submitted-by: dfs@doe.carleton.ca (David F. Skoll)
Posting-number: Volume 39, Issue 117
Archive-name: remind/patch09c
Environment: UNIX, MS-DOS, OS/2
Patch-To: remind: Volume 33, Issue 58-69

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  patch.09.A.UU patch.09.D
# Wrapped by kent@sparky on Mon Oct  4 15:03:31 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 4)."'
if test -f 'patch.09.A.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.09.A.UU'\"
else
  echo shar: Extracting \"'patch.09.A.UU'\" \(10581 characters\)
  sed "s/^X//" >'patch.09.A.UU' <<'END_OF_FILE'
Xbegin 664 patch.09.A
XM4')E<F5Q.B B,#,N,# N,#@B"BHJ*B N+B]P<F5V+W9E<G-I;VXN: E-;VX@
XM2G5L(#$Y(#$R.C(Q.C4S(#$Y.3,*+2TM("XO=F5R<VEO;BYH"51U92!!=6<@
XM,S$@,3,Z,C(Z,C4@,3DY,PHJ*BHJ*BHJ*BHJ*BHJ*BH**BHJ(#DL,3(@*BHJ
XM*@H@("\J(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
XM(" @(" @(" @(" @(" @(" @(" @("HO"B @+RHJ*BHJ*BHJ*BHJ*BHJ*BHJ
XM*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ
XM*B\*(" *(2 C9&5F:6YE(%9%4E-)3TX@(C S+C P+C X(@HM+2T@.2PQ,B M
XM+2TM"B @+RH@(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @
XM(" @(" @(" @(" @(" @(" @(" @(" @*B\*(" O*BHJ*BHJ*BHJ*BHJ*BHJ
XM*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ*BHJ
XM*BHJ+PH@( HA("-D969I;F4@5D524TE/3B B,#,N,# N,#DB"BHJ*B N+B]P
XM<F5V+TU!3DE&15-4+D1/4PE7960@075G(#$X(#$Q.C$P.C0Y(#$Y.3,*+2TM
XM("XO34%.249%4U0N1$]3"4UO;B!397 @,C @,30Z-3@Z,3<@,3DY,PHJ*BHJ
XM*BHJ*BHJ*BHJ*BH**BHJ(#,P+#,U("HJ*BH*+2TM(#,P+#,V("TM+2T*("!M
XM86ME9FEL92YT8PH@(&UA;FEF97-T+F1O<PH@(&UA;FEF97-T+G5N> HK(&UO
XM;VXN8PH@(&YO<G=G:6%N+F@*("!O;6ET+F,*("!P<F]T;W,N: HJ*BH@+BXO
XM<')E=B]-04Y)1D535"Y53E@)5V5D($%U9R Q." Q,3HQ,3HP,R Q.3DS"BTM
XM+2 N+TU!3DE&15-4+E5.6 E-;VX@4V5P(#(P(#$T.C4X.C X(#$Y.3,**BHJ
XM*BHJ*BHJ*BHJ*BHJ"BHJ*B S-"PS.2 J*BHJ"BTM+2 S-"PT," M+2TM"B @
XM;6%K969I;&4N;7-C"B @;6%K969I;&4N;W,R"B @;6%K969I;&4N=&,**R!M
XM;V]N+F,*("!N;W)W9VEA;BYH"B @;VUI="YC"B @<')O=&]S+F@**BHJ("XN
XM+W!R978O36%K969I;&4)5'5E($%U9R S,2 Q,CHS-3HU.2 Q.3DS"BTM+2 N
XM+TUA:V5F:6QE"51U92!397 @,C@@,38Z-#@Z-3<@,3DY,PHJ*BHJ*BHJ*BHJ
XM*BHJ*BH**BHJ(#0T+#4W("HJ*BH*(" C($U!3DU/1$4Z("!7:&%T(&9I;&4@
XM<')O=&5C=&EO;B!M;V1E('-H;W5L9"!B92!U<V5D(&9O<B!T:&4@;6%N('!A
XM9V5S/PH@($U!3DU/1$4](#8T- H@( HA(",@3U=.15(Z("!7:&%T(&]W;F5R
XM(&%N9"!G<F]U<"!T;R!U<V4@9F]R(&5X96-U=&%B;&5S+"!S8W)I<'1S(&%N
XM9"!M86X@<&%G97,_"B$@3U=.15(]8FEN+F)I;@H@( H@(",M+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+0H@(",@64]5(%-(3U5,1$XG5"!%1$E4
XM($%.651(24Y'($)%3$]7($A%4D4N("!9;W4@;6%Y('=A;G0@=&\@8VAA;F=E
XM('-O;64@=&AI;F=S"B @(R!I;B!C;VYF:6<N:#L@=&AE;BP@>6]U('-H;W5L
XM9"!B92!A8FQE('1O('1Y<&4@)VUA:V4G+@H@(",M+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+0HA(%9%4E-)3TX](# S+C P+C X"B @34%42$Q)
XM0CT@+6QM"B @"B @2$124ST@8V]N9FEG+F@@97)R+F@@97AP<BYH(&=L;V)A
XM;',N:"!P<F]T;W,N:"!T>7!E<RYH('9E<G-I;VXN:"!<"BTM+2 T-"PU.2 M
XM+2TM"B @(R!-04Y-3T1%.B @5VAA="!F:6QE('!R;W1E8W1I;VX@;6]D92!S
XM:&]U;&0@8F4@=7-E9"!F;W(@=&AE(&UA;B!P86=E<S\*("!-04Y-3T1%/2 V
XM-#0*(" *(2 C($]73D52+"!'4D]54#H@(%=H870@;W=N97(@86YD(&=R;W5P
XM('1O('5S92!F;W(@97AE8W5T86)L97,L"B$@(R!S8W)I<'1S(&%N9"!M86X@
XM<&%G97,_"B$@3U=.15(]8FEN"B$@1U)/55 ]8FEN"B @"B @(RTM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM"B @(R!93U4@4TA/54Q$3B=4($5$
XM250@04Y95$A)3D<@0D5,3U<@2$5212X@(%EO=2!M87D@=V%N="!T;R!C:&%N
XM9V4@<V]M92!T:&EN9W,*(" C(&EN(&-O;F9I9RYH.R!T:&5N+"!Y;W4@<VAO
XM=6QD(&)E(&%B;&4@=&\@='EP92 G;6%K92<N"B @(RTM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM"B$@5D524TE/3CT@,#,N,# N,#D*("!-051(
XM3$E"/2 M;&T*(" *("!(1%)3/2!C;VYF:6<N:"!E<G(N:"!E>'!R+F@@9VQO
XM8F%L<RYH('!R;W1O<RYH('1Y<&5S+F@@=F5R<VEO;BYH(%P**BHJ*BHJ*BHJ
XM*BHJ*BHJ"BHJ*B V,BPV." J*BHJ"B @3$%.1TA$4E,](&5N9VQI<V@N:"!G
XM97)M86XN:"!D=71C:"YH(&9I;FYI<V@N:"!F<F5N8V@N:"!N;W)W9VEA;BYH
XM"B @"B @4U)#4ST@8V%L96YD87(N8R!D;W)E;2YC(&1O<W5B<W0N8R!E>'!R
XM+F,@9FEL97,N8R!F=6YC<RYC(&=L;V)A;',N8R!H8F-A;"YC(%P*(2!I;FET
XM+F,@;6%I;BYC(&]M:70N8R!S;W)T+F,@<75E=64N8R!T;VME;BYC('1R:6=G
XM97(N8R!U<V5R9FYS+F,@=71I;',N8R!V87(N8PH@( H@($U!3DE&15-4/2!2
XM14%$344N54Y)6"!214%$344N1$]3($-/4%E224=(5" D*$A$4E,I("0H4U)#
XM4RD@36%K969I;&4@<F5M(')E;2XQ(%P*("!R96UI;F0N,2!R96UI;F0M86QL
XM+F-S:"!R96UI;F0M86QL+G-H('1E<W0N<F5M('1E<W0M<F5M('1E<W0N8VUP
XM(&UA:V5F:6QE+G1C(%P*+2TM(#8T+#<Q("TM+2T*("!,04Y'2$124ST@96YG
XM;&ES:"YH(&=E<FUA;BYH(&1U=&-H+F@@9FEN;FES:"YH(&9R96YC:"YH(&YO
XM<G=G:6%N+F@*(" *("!34D-3/2!C86QE;F1A<BYC(&1O<F5M+F,@9&]S=6)S
XM="YC(&5X<'(N8R!F:6QE<RYC(&9U;F-S+F,@9VQO8F%L<RYC(&AB8V%L+F,@
XM7 HA(&EN:70N8R!M86EN+F,@;6]O;BYC(&]M:70N8R!S;W)T+F,@<75E=64N
XM8R!T;VME;BYC('1R:6=G97(N8R!U<V5R9FYS+F,@7 HA('5T:6QS+F,@=F%R
XM+F,*(" *("!-04Y)1D535#T@4D5!1$U%+E5.25@@4D5!1$U%+D1/4R!#3U!9
XM4DE'2%0@)"A(1%)3*2 D*%-20U,I($UA:V5F:6QE(')E;2!R96TN,2!<"B @
XM<F5M:6YD+C$@<F5M:6YD+6%L;"YC<V@@<F5M:6YD+6%L;"YS:"!T97-T+G)E
XM;2!T97-T+7)E;2!T97-T+F-M<"!M86ME9FEL92YT8R!<"BHJ*BHJ*BHJ*BHJ
XM*BHJ*@HJ*BH@,3 S+#$P." J*BHJ"BTM+2 Q,#8L,3$R("TM+2T*("!H8F-A
XM;"YO.B!H8F-A;"YC("0H4U1$2$124RD*("!I;FET+F\Z(&EN:70N8R D*%-4
XM1$A$4E,I(&5X<'(N:"!V97)S:6]N+F@@;&%N9RYH("0H3$%.1TA$4E,I"B @
XM;6%I;BYO.B!M86EN+F,@)"A35$1(1%)3*2!E>'!R+F@**R!M;V]N+F\Z(&UO
XM;VXN8R D*%-41$A$4E,I"B @;VUI="YO.B!O;6ET+F,@)"A35$1(1%)3*0H@
XM('-O<G0N;SH@<V]R="YC("0H4U1$2$124RD*("!Q=65U92YO.B!Q=65U92YC
XM("0H4U1$2$124RD**BHJ*BHJ*BHJ*BHJ*BHJ"BHJ*B Q,3,L,3(P("HJ*BH*
XM("!V87(N;SH@=F%R+F,@)"A35$1(1%)3*2!E>'!R+F@*(" *("!T87):.@HA
XM( ET87(@8W9F(')E;6EN9"TS+C N."YT87(@)"A-04Y)1D535"D*(2 )8V]M
XM<')E<W,@+78@<F5M:6YD+3,N,"XX+G1A<@H@( H@('-H87(Z"B @"7-H87(@
XM+7@@+6XB4F5M:6YD("0H5D524TE/3BDB("UL-#4@+6\N+U-H87(@)"A-04Y)
XM1D535"D*+2TM(#$Q-RPQ,C0@+2TM+0H@('9A<BYO.B!V87(N8R D*%-41$A$
XM4E,I(&5X<'(N: H@( H@('1A<EHZ"B$@"71A<B!C=F8@<F5M:6YD+3,N,"XY
XM+G1A<B D*$U!3DE&15-4*0HA( EC;VUP<F5S<R M=B!R96UI;F0M,RXP+CDN
XM=&%R"B @"B @<VAA<CH*(" )<VAA<B M>" M;B)296UI;F0@)"A615)324].
XM*2(@+6PT-2 M;RXO4VAA<B D*$U!3DE&15-4*0HJ*BHJ*BHJ*BHJ*BHJ*BH*
XM*BHJ(#$T."PQ.#8@*BHJ*@H@( EC<"!R96UI;F0@)"A"24Y$25(I+W)E;6EN
XM9 H@( DM8VAM;V0@)"A%6$5-3T1%*2 D*$))3D1)4BDO<F5M:6YD"B @"2UC
XM:&]W;B D*$]73D52*2 D*$))3D1)4BDO<F5M:6YD"B @"6-P(')E;3)P<R D
XM*$))3D1)4BDO<F5M,G!S"B @"2UC:&UO9" D*$5814U/1$4I("0H0DE.1$E2
XM*2]R96TR<',*(" )+6-H;W=N("0H3U=.15(I("0H0DE.1$E2*2]R96TR<',*
XM(" *("!I;G-T86QL+7-C<FEP=',Z"B @"6-P(&MA;&P@)"A30U))4%1$25(I
XM+VMA;&P*(" )+6-H;6]D("0H15A%34]$12D@)"A30U))4%1$25(I+VMA;&P*
XM(" )+6-H;W=N("0H3U=.15(I("0H4T-225!41$E2*2]K86QL"B @"6-P(')E
XM;2 D*%-#4DE05$1)4BDO<F5M"B @"2UC:&UO9" D*$5814U/1$4I("0H4T-2
XM25!41$E2*2]R96T*(" )+6-H;W=N("0H3U=.15(I("0H4T-225!41$E2*2]R
XM96T*(" *("!I;G-T86QL+6UA;CH*(" )8W @<F5M:6YD+C$@)"A-04Y$25(I
XM+VUA;B0H34%.4T5#5"DO<F5M:6YD+B0H34%.4T5#5"D*(" )+6-H;6]D("0H
XM34%.34]$12D@)"A-04Y$25(I+VUA;B0H34%.4T5#5"DO<F5M:6YD+B0H34%.
XM4T5#5"D*(" )+6-H;W=N("0H3U=.15(I("0H34%.1$E2*2]M86XD*$U!3E-%
XM0U0I+W)E;6EN9"XD*$U!3E-%0U0I"B @"6-P(')E;2XQ("0H34%.1$E2*2]M
XM86XD*$U!3E-%0U0I+W)E;2XD*$U!3E-%0U0I"B @"2UC:&UO9" D*$U!3DU/
XM1$4I("0H34%.1$E2*2]M86XD*$U!3E-%0U0I+W)E;2XD*$U!3E-%0U0I"B @
XM"2UC:&]W;B D*$]73D52*2 D*$U!3D1)4BDO;6%N)"A-04Y314-4*2]R96TN
XM)"A-04Y314-4*0H@( EC<"!K86QL+C$@)"A-04Y$25(I+VUA;B0H34%.4T5#
XM5"DO:V%L;"XD*$U!3E-%0U0I"B @"2UC:&UO9" D*$U!3DU/1$4I("0H34%.
XM1$E2*2]M86XD*$U!3E-%0U0I+VMA;&PN)"A-04Y314-4*0H@( DM8VAO=VX@
XM)"A/5TY%4BD@)"A-04Y$25(I+VUA;B0H34%.4T5#5"DO:V%L;"XD*$U!3E-%
XM0U0I"B @"6-P(')E;3)P<RXQ("0H34%.1$E2*2]M86XD*$U!3E-%0U0I+W)E
XM;3)P<RXD*$U!3E-%0U0I"B @"2UC:&UO9" D*$U!3DU/1$4I("0H34%.1$E2
XM*2]M86XD*$U!3E-%0U0I+W)E;3)P<RXD*$U!3E-%0U0I"B @"2UC:&]W;B D
XM*$]73D52*2 D*$U!3D1)4BDO;6%N)"A-04Y314-4*2]R96TR<',N)"A-04Y3
XM14-4*0H@( H@(')E;&5A<V4Z"B @"2UM:V1I<B!214Q%05-%"B @"2UR;2 M
XM9B!214Q%05-%+RH*(2 );6MP871C:" N+B]P<F5V("X@<&%T8V@N,#@@4VAA
XM<B B4F5M:6YD+3,N,"]0871C:"TP."(*(" );78@4VAA<BH@4D5,14%310HA
XM( ER;2 M9B!P871C:"XP. H@( EF;W(@:2!I;B J+C$[(&1O(&YR;V9F("UM
XM86X@)"1I('P@<V5D("UE("=S+U\(+R]G)R ^(&!B87-E;F%M92 D)&D@+C%@
XM+FUA;CL@9&]N90H@( EM=B J+FUA;B!214Q%05-%"B @"69O<B!I(&EN("HN
XM,3L@9&\@9W)O9F8@+6UA;B M5'!S("0D:2 ^(&!B87-E;F%M92 D)&D@+C%@
XM+G!S.R!D;VYE"B @"6UV("HN<',@4D5,14%310HM+2T@,34R+#(P-" M+2TM
XM"B @"6-P(')E;6EN9" D*$))3D1)4BDO<F5M:6YD"B @"2UC:&UO9" D*$58
XM14U/1$4I("0H0DE.1$E2*2]R96UI;F0*(" )+6-H;W=N("0H3U=.15(I("0H
XM0DE.1$E2*2]R96UI;F0**R )+6-H9W)P("0H1U)/55 I("0H0DE.1$E2*2]R
XM96UI;F0*(" )8W @<F5M,G!S("0H0DE.1$E2*2]R96TR<',*(" )+6-H;6]D
XM("0H15A%34]$12D@)"A"24Y$25(I+W)E;3)P<PH@( DM8VAO=VX@)"A/5TY%
XM4BD@)"A"24Y$25(I+W)E;3)P<PHK( DM8VAG<G @)"A'4D]54"D@)"A"24Y$
XM25(I+W)E;3)P<PH@( H@(&EN<W1A;&PM<V-R:7!T<SH*(" )8W @:V%L;" D
XM*%-#4DE05$1)4BDO:V%L; H@( DM8VAM;V0@)"A%6$5-3T1%*2 D*%-#4DE0
XM5$1)4BDO:V%L; H@( DM8VAO=VX@)"A/5TY%4BD@)"A30U))4%1$25(I+VMA
XM;&P**R )+6-H9W)P("0H1U)/55 I("0H4T-225!41$E2*2]K86QL"B @"6-P
XM(')E;2 D*%-#4DE05$1)4BDO<F5M"B @"2UC:&UO9" D*$5814U/1$4I("0H
XM4T-225!41$E2*2]R96T*(" )+6-H;W=N("0H3U=.15(I("0H4T-225!41$E2
XM*2]R96T**R )+6-H9W)P("0H1U)/55 I("0H4T-225!41$E2*2]R96T*(" *
XM("!I;G-T86QL+6UA;CH*(" )8W @<F5M:6YD+C$@)"A-04Y$25(I+VUA;B0H
XM34%.4T5#5"DO<F5M:6YD+B0H34%.4T5#5"D*(" )+6-H;6]D("0H34%.34]$
XM12D@)"A-04Y$25(I+VUA;B0H34%.4T5#5"DO<F5M:6YD+B0H34%.4T5#5"D*
XM(" )+6-H;W=N("0H3U=.15(I("0H34%.1$E2*2]M86XD*$U!3E-%0U0I+W)E
XM;6EN9"XD*$U!3E-%0U0I"BL@"2UC:&=R<" D*$=23U50*2 D*$U!3D1)4BDO
XM;6%N)"A-04Y314-4*2]R96UI;F0N)"A-04Y314-4*0H@( EC<"!R96TN,2 D
XM*$U!3D1)4BDO;6%N)"A-04Y314-4*2]R96TN)"A-04Y314-4*0H@( DM8VAM
XM;V0@)"A-04Y-3T1%*2 D*$U!3D1)4BDO;6%N)"A-04Y314-4*2]R96TN)"A-
XM04Y314-4*0H@( DM8VAO=VX@)"A/5TY%4BD@)"A-04Y$25(I+VUA;B0H34%.
XM4T5#5"DO<F5M+B0H34%.4T5#5"D**R )+6-H9W)P("0H1U)/55 I("0H34%.
XM1$E2*2]M86XD*$U!3E-%0U0I+W)E;2XD*$U!3E-%0U0I"B @"6-P(&MA;&PN
XM,2 D*$U!3D1)4BDO;6%N)"A-04Y314-4*2]K86QL+B0H34%.4T5#5"D*(" )
XM+6-H;6]D("0H34%.34]$12D@)"A-04Y$25(I+VUA;B0H34%.4T5#5"DO:V%L
XM;"XD*$U!3E-%0U0I"B @"2UC:&]W;B D*$]73D52*2 D*$U!3D1)4BDO;6%N
XM)"A-04Y314-4*2]K86QL+B0H34%.4T5#5"D**R )+6-H9W)P("0H1U)/55 I
XM("0H34%.1$E2*2]M86XD*$U!3E-%0U0I+VMA;&PN)"A-04Y314-4*0H@( EC
XM<"!R96TR<',N,2 D*$U!3D1)4BDO;6%N)"A-04Y314-4*2]R96TR<',N)"A-
XM04Y314-4*0H@( DM8VAM;V0@)"A-04Y-3T1%*2 D*$U!3D1)4BDO;6%N)"A-
XM04Y314-4*2]R96TR<',N)"A-04Y314-4*0H@( DM8VAO=VX@)"A/5TY%4BD@
XM)"A-04Y$25(I+VUA;B0H34%.4T5#5"DO<F5M,G!S+B0H34%.4T5#5"D**R )
XM+6-H9W)P("0H1U)/55 I("0H34%.1$E2*2]M86XD*$U!3E-%0U0I+W)E;3)P
XM<RXD*$U!3E-%0U0I"B @"B @<F5L96%S93H*(" )+6UK9&ER(%)%3$5!4T4*
XM(" )+7)M("UF(%)%3$5!4T4O*@HA( EM:W!A=&-H("XN+W!R978@+B!P871C
XM:"XP.2!3:&%R(")296UI;F0M,RXP+U!A=&-H+3 Y+W!A<G0B"B @"6UV(%-H
XM87(J(%)%3$5!4T4*(2 )<FT@+68@<&%T8V@N,#D*(" )9F]R(&D@:6X@*BXQ
XM.R!D;R!N<F]F9B M;6%N("0D:2!\('-E9" M92 G<R]?""\O9R<@/B!@8F%S
XM96YA;64@)"1I("XQ8"YM86X[(&1O;F4*(" );78@*BYM86X@4D5,14%310H@
XM( EF;W(@:2!I;B J+C$[(&1O(&=R;V9F("UM86X@+51P<R D)&D@/B!@8F%S
XM96YA;64@)"1I("XQ8"YP<SL@9&]N90H@( EM=B J+G!S(%)%3$5!4T4**R *
XM*R C($UE86YT(&9O<B!D96)U9V=I;F<@+2!D;VXG="!I;G9O:V4@=&AI<R!T
XM87)G970@=6YL97-S('EO=2!K;F]W('=H870**R C('EO=2=R92!D;VEN9R$*
XM*R!M86IO<G1E<W0Z"BL@"69O<B!C;VUP(&EN(")C8R(@(F=C8R M5V%L;" M
XM<&5D86YT:6,@+6%N<VDB(#L@9&\@9F]R(&QA;F<@:6X@,2 R(#,@-" U(# @
XM.R!D;R!F;W(@9&5F(&EN($E33TQ!5$E.,2!)0DU%6%1%3D1%1"!&3T]"05)"
XM05H@.R!D;R!E8VAO("0D9&5F("0D;&%N9R [("0H34%+12D@8VQO8F)E<B [
XM("0H34%+12D@(D-$1493/2U$3$%.1STD)&QA;F<@+40D)&1E9CTQ(B!#1DQ!
XM1U,]+4\@(D-#/20D8V]M<"(@(DQ$/20D8V]M<"(@.R!D;VYE(#L@9&]N92 [
X)(&1O;F4**R *
X 
Xend
END_OF_FILE
  if test 10581 -ne `wc -c <'patch.09.A.UU'`; then
    echo shar: \"'patch.09.A.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'patch.09.A'\" \(7659 characters\)
    cat patch.09.A.UU | uudecode
    if test 7659 -ne `wc -c <'patch.09.A'`; then
      echo shar: \"'patch.09.A'\" uudecoded with wrong size!
    else
      rm patch.09.A.UU
      if test -f 'patch.09.B' && test -f 'patch.09.C' && test -f 'patch.09.D'
      then   
        echo shar: Combining  \"'patch.09'\" \(145785 characters\)
        cat 'patch.09.A' 'patch.09.B' 'patch.09.C' 'patch.09.D' > 'patch.09'
        if test 145785 -ne `wc -c <'patch.09'`; then
          echo shar: \"'patch.09'\" combined with wrong size!
        else
          rm patch.09.A patch.09.B patch.09.C patch.09.D
        fi
      fi
    fi
  fi
  # end of 'patch.09.A.UU'
fi
if test -f 'patch.09.D' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.09.D'\"
else
  echo shar: Extracting \"'patch.09.D'\" \(42130 characters\)
  sed "s/^X//" >'patch.09.D' <<'END_OF_FILE'
X         strcmp(SmallFont, DayFont)  &&
X         strcmp(SmallFont, EntryFont)) printf(" %s", SmallFont);
X     putchar('\n');
X     printf("%%%%Creator: Rem2PS\n");
X--- 326,340 ----
X  /* Write the document structuring stuff */
X     printf("%%!PS-Adobe-\n");
X     printf("%%%%DocumentFonts: %s", HeadFont);
X!    if (strcmp(TitleFont, HeadFont)) printf(" %s", TitleFont);
X!    if (strcmp(TitleFont, DayFont) &&
X!        strcmp(HeadFont, DayFont)) printf(" %s", DayFont);
X     if (strcmp(EntryFont, HeadFont) &&
X+        strcmp(TitleFont, EntryFont) &&
X         strcmp(EntryFont, DayFont)) printf(" %s", EntryFont);
X     if (!NoSmallCal && strcmp(SmallFont, HeadFont) &&
X         strcmp(SmallFont, DayFont)  &&
X+        strcmp(TitleFont, SmallFont) &&
X         strcmp(SmallFont, EntryFont)) printf(" %s", SmallFont);
X     putchar('\n');
X     printf("%%%%Creator: Rem2PS\n");
X***************
X*** 335,343 ****
X     printf("%%%%EndComments\n");
X  
X     for (i=0; PSProlog1[i]; i++) puts(PSProlog1[i]);
X!    printf("[(%s) (%s) (%s) (%s) (%s) (%s) (%s)]\n",
X! 	  L_SUNDAY, L_MONDAY, L_TUESDAY, L_WEDNESDAY,
X! 	  L_THURSDAY, L_FRIDAY, L_SATURDAY);
X     for (i=0; PSProlog2[i]; i++) puts(PSProlog2[i]);
X  
X     printf("/HeadFont /%s %s\n", HeadFont, isostuff);
X--- 343,356 ----
X     printf("%%%%EndComments\n");
X  
X     for (i=0; PSProlog1[i]; i++) puts(PSProlog1[i]);
X!    if (!MondayFirst)
X!       printf("[(%s) (%s) (%s) (%s) (%s) (%s) (%s)]\n",
X! 	     L_SUNDAY, L_MONDAY, L_TUESDAY, L_WEDNESDAY,
X! 	     L_THURSDAY, L_FRIDAY, L_SATURDAY);
X!    else
X!       printf("[(%s) (%s) (%s) (%s) (%s) (%s) (%s)]\n",
X! 	     L_MONDAY, L_TUESDAY, L_WEDNESDAY,
X! 	     L_THURSDAY, L_FRIDAY, L_SATURDAY, L_SUNDAY);
X     for (i=0; PSProlog2[i]; i++) puts(PSProlog2[i]);
X  
X     printf("/HeadFont /%s %s\n", HeadFont, isostuff);
X***************
X*** 344,352 ****
X--- 357,367 ----
X     if (!NoSmallCal) printf("/SmallFont /%s %s\n", SmallFont, isostuff);
X     printf("/DayFont /%s %s\n", DayFont, isostuff);
X     printf("/EntryFont /%s %s\n", EntryFont, isostuff);
X+    printf("/TitleFont /%s %s\n", TitleFont, isostuff);
X     printf("/HeadSize %s def\n", HeadSize);
X     printf("/DaySize %s def\n", DaySize);
X     printf("/EntrySize %s def\n", EntrySize);
X+    printf("/TitleSize %s def\n", TitleSize);
X     printf("/XSIZE %d def\n", CurPage->xsize);
X     printf("/MinX %d def\n", LeftMarg);
X     printf("/MinY %d def\n", BotMarg);
X***************
X*** 402,408 ****
X  
X  /* Move to appropriate location */
X     printf("/CAL%d {\n", CurDay);
X!    printf("Border ytop %d xincr mul MinX add xincr\n", WkDayNum);
X  
X  /* Set up the text array */
X     printf("[\n");
X--- 417,426 ----
X  
X  /* Move to appropriate location */
X     printf("/CAL%d {\n", CurDay);
X!    if (!MondayFirst)
X!       printf("Border ytop %d xincr mul MinX add xincr\n", WkDayNum);
X!    else
X!       printf("Border ytop %d xincr mul MinX add xincr\n", (WkDayNum ? WkDayNum-1 : 6));
X  
X  /* Set up the text array */
X     printf("[\n");
X***************
X*** 427,437 ****
X     printf("/y exch def y ymin lt {/ymin y def} if\n");
X     printf("} def\n");
X  
X! /* If WkDayNum is a Sunday, move to next row.  Also handle the queued
X!    PS and PSFILE reminders */
X!    if (WkDayNum == 6 || CurDay == MaxDay) {
X        HadQPS = 0;
X!       begin = CurDay - WkDayNum;
X        if (begin < 1) begin = 1;
X        end = CurDay;
X        for (i=begin; i<=end; i++) {
X--- 445,457 ----
X     printf("/y exch def y ymin lt {/ymin y def} if\n");
X     printf("} def\n");
X  
X! /* If WkDayNum is a Sunday or Monday, depending on MondayFirst,
X!    move to next row.  Also handle the queued PS and PSFILE reminders */
X!    if ((!MondayFirst && WkDayNum == 6) ||
X!         (MondayFirst && WkDayNum == 0) || CurDay == MaxDay) {
X        HadQPS = 0;
X!       if (MondayFirst) begin =  CurDay - (WkDayNum ? WkDayNum-1 : 6);
X!       else             begin = CurDay - WkDayNum;
X        if (begin < 1) begin = 1;
X        end = CurDay;
X        for (i=begin; i<=end; i++) {
X***************
X*** 533,538 ****
X--- 553,560 ----
X     BotMarg = 36;
X     UseISO = 0;
X     FillPage = 0;
X+    MondayFirst = 0;
X+    SmallLocation = "bt";
X  
X     for(j=0; j<32; j++) PsEntries[i] = NULL;
X  
X***************
X*** 545,550 ****
X--- 567,577 ----
X        if (*s++ != '-') Usage("Options must begin with '-'");
X  
X        switch(*s++) {
X+ 
X+          case 'n':
X+ 	    MondayFirst = 1;
X+ 	    break;
X+ 
X           case 'p':
X  	    if (i == argc) Usage("Prologue filename must be supplied");
X  	    UserProlog = argv[i++];
X***************
X*** 558,564 ****
X  	          case 'h': HeadSize = t; break;
X  		  case 'e': EntrySize = t; break;
X  		  case 'd': DaySize = t; break;
X!                   default: Usage("Size must specify h, e, or d");	    
X  	       }
X              }
X  	    break;
X--- 585,592 ----
X  	          case 'h': HeadSize = t; break;
X  		  case 'e': EntrySize = t; break;
X  		  case 'd': DaySize = t; break;
X! 		  case 't': TitleSize = t; break;
X!                   default: Usage("Size must specify h, t, e, or d");	    
X  	       }
X              }
X  	    break;
X***************
X*** 572,578 ****
X  		  case 'e': EntryFont = t; break;
X  		  case 'd': DayFont = t; break;
X  		  case 's': SmallFont = t; break;
X!                   default: Usage("Font must specify s, h, e, or d");	    
X  	       }
X              }
X  	    break;
X--- 600,607 ----
X  		  case 'e': EntryFont = t; break;
X  		  case 'd': DayFont = t; break;
X  		  case 's': SmallFont = t; break;
X! 		  case 't': TitleFont = t; break;
X!                   default: Usage("Font must specify s, h, t, e, or d");	    
X  	       }
X              }
X  	    break;
X***************
X*** 627,633 ****
X  
X  	 case 'i': UseISO = 1; break;
X  
X! 	 case 'c': NoSmallCal = 1; break;
X  
X  	 case 'e': FillPage = 1; break;
X  
X--- 656,673 ----
X  
X  	 case 'i': UseISO = 1; break;
X  
X! 	 case 'c': j=(*s);
X! 	           if (!j) {
X! 		      SmallLocation = SmallCalLoc[0];
X!                    } else {
X! 		      j -= '0';
X! 		      if (j>=0 && j<NUMSMALL) {
X! 		         SmallLocation = SmallCalLoc[j];
X! 		      } else {
X! 		         SmallLocation = SmallCalLoc[0];
X!                       }
X!                    }
X! 		   break;
X  
X  	 case 'e': FillPage = 1; break;
X  
X***************
X*** 655,671 ****
X     fprintf(stderr, "Options:\n\n");
X     fprintf(stderr, "-p file       Include user-supplied PostScript code in prologue\n");
X     fprintf(stderr, "-l            Do calendar in landscape mode\n");
X!    fprintf(stderr, "-c            Do NOT generate small calendars for previous\n");
X     fprintf(stderr, "              and next month\n");
X     fprintf(stderr, "-i            Use ISO 8859-1 encoding in PostScript output\n");
X     fprintf(stderr, "-m media      Set page size (eg, Letter, Legal, A4.)  Case sensitive!\n");
X     fprintf(stderr, "              (Default page size is %s)\n", DefaultPage[0].name);
X!    fprintf(stderr, "-f[shed] font Set font for small cal, hdr, cal entries and/or day numbers\n");
X!    fprintf(stderr, "-s[hed] size  Set size for header, calendar entries and/or day numbers\n");
X     fprintf(stderr, "-b size       Set border size for calendar entries\n");
X     fprintf(stderr, "-t size       Set line thickness\n");
X     fprintf(stderr, "-e            Make calendar fill entire page\n");
X     fprintf(stderr, "-o[lrtb] marg Specify left, right, top and bottom margins\n");
X     exit(1);
X  }
X  
X--- 695,712 ----
X     fprintf(stderr, "Options:\n\n");
X     fprintf(stderr, "-p file       Include user-supplied PostScript code in prologue\n");
X     fprintf(stderr, "-l            Do calendar in landscape mode\n");
X!    fprintf(stderr, "-c[n]         Control small calendars: 0=none; 1=bt; 2=tb; 3=sbt\n");
X     fprintf(stderr, "              and next month\n");
X     fprintf(stderr, "-i            Use ISO 8859-1 encoding in PostScript output\n");
X     fprintf(stderr, "-m media      Set page size (eg, Letter, Legal, A4.)  Case sensitive!\n");
X     fprintf(stderr, "              (Default page size is %s)\n", DefaultPage[0].name);
X!    fprintf(stderr, "-f[shted] font Set font for small cal, hdr, title, cal entries, day numbers\n");
X!    fprintf(stderr, "-s[hted] size Set size for header, title, calendar entries and/or day numbers\n");
X     fprintf(stderr, "-b size       Set border size for calendar entries\n");
X     fprintf(stderr, "-t size       Set line thickness\n");
X     fprintf(stderr, "-e            Make calendar fill entire page\n");
X     fprintf(stderr, "-o[lrtb] marg Specify left, right, top and bottom margins\n");
X+    fprintf(stderr, "-n            Start calendar with Monday rather than Sunday\n");
X     exit(1);
X  }
X  
X***************
X*** 676,692 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! void DoSmallCal(char *m, int days, int first, int col)
X  #else
X! void DoSmallCal(m, days, first, col)
X  char *m;
X  int days, first, col;
X  #endif
X  {
X     /* Do the small calendar */
X!    int i;
X     int row = 2;
X  
X     /* Figure out the font size */
X  
X     printf("/SmallFontSize MinBoxSize Border sub Border sub 8 div 2 sub def\n");
X--- 717,737 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! void DoSmallCal(char *m, int days, int first, int col, int which)
X  #else
X! void DoSmallCal(m, days, first, col, which)
X  char *m;
X  int days, first, col;
X  #endif
X  {
X     /* Do the small calendar */
X!    int i, j;
X     int row = 2;
X  
X+    if (MondayFirst) {
X+       first--;
X+       if (first < 0) first = 6;
X+    }
X     /* Figure out the font size */
X  
X     printf("/SmallFontSize MinBoxSize Border sub Border sub 8 div 2 sub def\n");
X***************
X*** 703,716 ****
X     printf("gsave\n");
X  
X     /* Move origin to upper-left hand corner of appropriate box */
X!    printf("%d xincr mul MinX add ysmall translate\n", col);
X  
X     /* Print the month */   
X     printf("SmallWidth 7 mul (%s) stringwidth pop sub 2 div Border add Border neg SmallFontSize sub moveto (%s) show\n", m, m);
X  
X     /* Print the days of the week */
X!    for (i=0; i<7; i++)
X!       printf("Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize sub 2 sub moveto (%c) show\n", i, Days[i]);
X  
X     /* Now do the days of the month */
X     for (i=1; i<=days; i++) {
X--- 748,764 ----
X     printf("gsave\n");
X  
X     /* Move origin to upper-left hand corner of appropriate box */
X!    printf("%d xincr mul MinX add ysmall%d translate\n", col, which);
X  
X     /* Print the month */   
X     printf("SmallWidth 7 mul (%s) stringwidth pop sub 2 div Border add Border neg SmallFontSize sub moveto (%s) show\n", m, m);
X  
X     /* Print the days of the week */
X!    for (i=0; i<7; i++) {
X!       if (MondayFirst) j=(i+1)%7;
X!       else             j=i;
X!       printf("Border %d SmallWidth mul add Border neg SmallFontSize sub SmallFontSize sub 2 sub moveto (%c) show\n", i, Days[j]);
X!    }
X  
X     /* Now do the days of the month */
X     for (i=1; i<=days; i++) {
X***************
X*** 744,750 ****
X     int fnoff;
X     char buffer[LINELEN];
X  
X!    begin = CurDay - WkDayNum;
X     wd = 0;
X     while (begin < 1) begin++, wd++;
X     end = CurDay;
X--- 792,799 ----
X     int fnoff;
X     char buffer[LINELEN];
X  
X!    if (!MondayFirst) begin = CurDay - WkDayNum;
X!    else		     begin = CurDay - (WkDayNum ? WkDayNum-1 : 6);
X     wd = 0;
X     while (begin < 1) begin++, wd++;
X     end = CurDay;
X***************
X*** 795,797 ****
X--- 844,916 ----
X     }
X     return HadPS;
X  }
X+ 
X+ /***************************************************************/
X+ /*                                                             */
X+ /* GetSmallLocations                                           */
X+ /*                                                             */
X+ /* Set up the locations for the small calendars.               */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PUBLIC void GetSmallLocations(void)
X+ #else
X+ void GetSmallLocations()
X+ #endif
X+ {
X+    char c;
X+    char *s = SmallLocation;
X+    int colfirst, collast;
X+ 
X+ /* Figure out the first and last columns */
X+    colfirst = FirstWkDay;
X+    collast = (FirstWkDay+MaxDay-1) % 7;
X+    if (MondayFirst) {
X+       colfirst = colfirst ? colfirst - 1 : 6;
X+       collast = collast ? collast - 1 : 6;
X+    }
X+    NoSmallCal = 0;
X+ 
X+    while((c = *s++) != 0) {
X+       switch(c) {
X+          case 'b':
X+ 	    /* Adjust Feb. if we want it on the bottom */
X+ 	    if (MaxDay == 28 && colfirst == 0) { 
X+ 	       printf("/ysmallbot ymin def /ymin ysmallbot MinBoxSize sub def\n");
X+ 	       printf("MinX ymin MaxX ymin L\n");
X+ 	       printf("/ysmall1 ysmallbot def /ysmall2 ysmallbot def\n");
X+ 	       SmallCol1 = 5;
X+ 	       SmallCol2 = 6;
X+ 	       return;
X+             }
X+ 	    if (collast <= 4) {
X+ 	       printf("/ysmall1 ysmallbot def /ysmall2 ysmallbot def\n");
X+ 	       SmallCol1 = 5;
X+ 	       SmallCol2 = 6;
X+ 	       return;
X+ 	    }
X+ 	    break;
X+ 
X+ 	 case 't':
X+ 	    if (colfirst >= 2) {
X+ 	       printf("/ysmall1 ysmalltop def /ysmall2 ysmalltop def\n");
X+ 	       SmallCol1 = 0;
X+ 	       SmallCol2 = 1;
X+ 	       return;
X+ 	    }
X+ 	    break;
X+ 
X+ 	 case 's':
X+ 	    if (colfirst >= 1 && collast<=5) {
X+ 	       printf("/ysmall1 ysmalltop def /ysmall2 ysmallbot def\n");
X+ 	       SmallCol1 = 0;
X+ 	       SmallCol2 = 6;
X+ 	       return;
X+ 	    }
X+ 	    break;
X+       }
X+    }
X+    NoSmallCal = 1;
X+    return;
X+ }
X+ 	       
X*** ../prev/rem2ps.h	Mon Jun 28 12:30:22 1993
X--- ./rem2ps.h	Tue Sep 28 16:53:52 1993
X***************
X*** 64,80 ****
X     "/doheading",
X     "{",
X     "   /monthyr exch def",
X!    "   ",
X!    "   /HeadFont findfont",
X!    "   HeadSize scalefont setfont   ",
X     "   monthyr stringwidth",
X!    "   pop",
X     "   2 div MaxX MinX add 2 div exch sub /x exch def",
X!    "   MaxY HeadSize 1.5 mul sub /y exch def",
X     "   newpath x y moveto monthyr show",
X!    "   y HeadSize 0.5 mul sub /y exch def",
X     "   MinX y MaxX y L",
X     "   /topy y def",
X     "% Do the days of the week",
X     "   MaxX MinX sub 7 div /xincr exch def",
X     "   /x MinX def",
X--- 64,82 ----
X     "/doheading",
X     "{",
X     "   /monthyr exch def",
X!    "",
X!    "   /TitleFont findfont",
X!    "   TitleSize scalefont setfont",
X     "   monthyr stringwidth",
X!    "   /hgt exch def",
X     "   2 div MaxX MinX add 2 div exch sub /x exch def",
X!    "   MaxY Border sub TitleSize sub /y exch def",
X     "   newpath x y moveto monthyr show",
X!    "   newpath x y moveto monthyr false charpath flattenpath pathbbox",
X!    "   pop pop Border sub /y exch def pop",
X     "   MinX y MaxX y L",
X     "   /topy y def",
X+    "   /HeadFont findfont HeadSize scalefont setfont",
X     "% Do the days of the week",
X     "   MaxX MinX sub 7 div /xincr exch def",
X     "   /x MinX def",
X***************
X*** 143,149 ****
X     "   /curline () def",
X     "   /len word length def",
X     "   /Fcount len 1 sub def",
X!    "   ",
X     "   {",
X     "     word 0 Fcount getinterval stringwidth pop width le",
X     "     {exit} if",
X--- 145,151 ----
X     "   /curline () def",
X     "   /len word length def",
X     "   /Fcount len 1 sub def",
X!    "",
X     "   {",
X     "     word 0 Fcount getinterval stringwidth pop width le",
X     "     {exit} if",
X*** ../prev/remind.1	Thu Aug 26 10:58:39 1993
X--- ./remind.1	Thu Sep 30 15:25:03 1993
X***************
X*** 1,4 ****
X! .TH REMIND 1 "14 April 1993"
X  .UC 4
X  .SH NAME
X  remind \- a sophisticated reminder service
X--- 1,4 ----
X! .TH REMIND 1 "30 September 1993"
X  .UC 4
X  .SH NAME
X  remind \- a sophisticated reminder service
X***************
X*** 59,64 ****
X--- 59,70 ----
X  \fBrem2ps\fR program, which creates a PostScript calendar.  For this
X  option, \fIn\fR cannot start with "+"; it must specify a number of months.
X  .TP
X+ .B \-m
X+ The \fB\-m\fR option causes the \fB\-c\fR option to produce a calendar whose
X+ first column is Monday rather than Sunday.  (This conforms to the international
X+ standard.)  It does \fInot\fR, however, affect the \fB\-p\fR or \fB\-s\fR
X+ options.
X+ .TP
X  .B \-v
X  The \fB\-v\fR option makes the output of \fBRemind\fR slightly more verbose.
X  .TP
X***************
X*** 202,207 ****
X--- 208,220 ----
X  it, rather than the actual system date, as its notion of "today."
X  This lets you create calendars for future months, or test to see
X  how your reminders will be triggered in the future.
X+ .PP
X+ In addition, as part of the \fIdate\fR component, you can supply a
X+ \fIrepeat\fR parameter, which has the form *\fInum\fR.  This causes
X+ \fBRemind\fR to be run \fInum\fR times, with the date incrementing
X+ on each iteration.  You may have to enclose the parameter in quotes
X+ to avoid shell expansion.  See the subsection "Repeated Execution"
X+ in the section "Calendar Mode" for more information.
X  .SH REMINDER FILES
X  .PP
X  \fBRemind\fR uses scripts to control its operation.  The commands
X***************
X*** 281,287 ****
X  reminders - they are \fB$FirstIndent\fR, \fB$SubsIndent\fR and
X  \fB$FormWidth\fR.  They are discussed in the section "System Variables."
X  The \fBMSF\fR keyword causes the spacing of your reminder to be altered -
X! extra spaces are discarded, and two spaces are placed after periods.
X  .PP
X  A \fBRUN\fR-type
X  reminder also passes the \fIbody\fR through the substitution filter, but
X--- 294,306 ----
X  reminders - they are \fB$FirstIndent\fR, \fB$SubsIndent\fR and
X  \fB$FormWidth\fR.  They are discussed in the section "System Variables."
X  The \fBMSF\fR keyword causes the spacing of your reminder to be altered -
X! extra spaces are discarded, and two spaces are placed after periods and
X! other characters, as specified by the system variables \fB$EndSent\fR and
X! \fB$EndSentIg\fR.  Note that if the body of the reminder includes
X! newline characters (placed there with the %_ sequence), then the newlines
X! are treated as the beginnings of new paragraphs, and the \fB$FirstIndent\fR
X! indentation is used for the next line.  You can use two consecutive
X! newlines to have spaced paragraphs emitted from a single reminder body.
X  .PP
X  A \fBRUN\fR-type
X  reminder also passes the \fIbody\fR through the substitution filter, but
X***************
X*** 291,297 ****
X  .PP
X  A \fBPS\fR or \fBPSFILE\fR-type reminder is used to pass PostScript code
X  directly to the printer when producing PostScript calendars.  This can
X! be used to shade certain calendar entries, include graphics in the calendar,
X  or almost any other purpose you can think of.  You
X  should not use these types of reminders unless you are an expert PostScript
X  programmer.  The \fBPS\fR and \fBPSFILE\fR reminders are ignored unless
X--- 310,317 ----
X  .PP
X  A \fBPS\fR or \fBPSFILE\fR-type reminder is used to pass PostScript code
X  directly to the printer when producing PostScript calendars.  This can
X! be used to shade certain calendar entries (see the psshade() function),
X! include graphics in the calendar,
X  or almost any other purpose you can think of.  You
X  should not use these types of reminders unless you are an expert PostScript
X  programmer.  The \fBPS\fR and \fBPSFILE\fR reminders are ignored unless
X***************
X*** 1468,1483 ****
X  version 03.00.07 of \fBRemind\fR.
X  .PP
X  All system variables begin with a dollar sign '$'.  They can be used
X! in \fBSET\fR commands and expressions just as regular variables can.  However,
X! system variables always hold values of type \fBINT\fR.  In addition,
X! some system variables cannot be modified, and you cannot create new
X! system variables.  System variables can be initialized on the command
X! line with the \fB\-i\fR option, but you may need to quote them to avoid
X! having the shell interpret the dollar sign.  System variable names are
X! not case-sensitive.
X  .PP
X  The following system variables are defined.  Those marked
X  "read-only" cannot be changed with the \fBSET\fR command.
X  .TP
X  .B $CalcUTC 
X  If 1 (the default), then \fBRemind\fR uses C library functions
X--- 1488,1505 ----
X  version 03.00.07 of \fBRemind\fR.
X  .PP
X  All system variables begin with a dollar sign '$'.  They can be used
X! in \fBSET\fR commands and expressions just as regular variables can.
X! All system variables always hold values of a specified type.  In
X! addition, some system variables cannot be modified, and you cannot
X! create new system variables.  System variables can be initialized on
X! the command line with the \fB\-i\fR option, but you may need to quote
X! them to avoid having the shell interpret the dollar sign.  System
X! variable names are not case-sensitive.
X  .PP
X  The following system variables are defined.  Those marked
X  "read-only" cannot be changed with the \fBSET\fR command.
X+ All system variables hold values of type \fBINT\fR, unless otherwise
X+ specified.
X  .TP
X  .B $CalcUTC 
X  If 1 (the default), then \fBRemind\fR uses C library functions
X***************
X*** 1506,1511 ****
X--- 1528,1556 ----
X  If non-zero, then the \fB\-q\fR option was supplied on the command line.
X  For the MS-DOS version, always contains 1.
X  .TP
X+ .B $EndSent (STRING type)
X+ Contains a list of characters which end a sentence.  The \fBMSF\fR
X+ keyword inserts two spaces after these characters.  Initially,
X+ \fB$EndSent\fR is set to ".!?" (period, exclamation mark, and
X+ question mark.)
X+ .TP
X+ .B $EndSentIg (STRING type)
X+ Contains a list of characters which should be ignored when \fBMSF\fR
X+ decides whether or not to place two spaces after a sentence.  Initially,
X+ is set to "'>)]}"+CHAR(34) (single-quote, greater-than, right
X+ parenthesis, right bracket, right brace, and double-quote.)
X+ .PP
X+ .RS
X+ For example, the default values work as follows:
X+ .PP
X+ .nf
X+ 	MSF He said, "Huh! (Two spaces will follow this.)"  Yup.
X+ .fi
X+ .PP
X+ because the final parenthesis and quote are ignored (for the purposes
X+ of spacing) when they follow a period.
X+ .RE
X+ .TP
X  .B $FirstIndent
X  The number of spaces by which to indent the first line of a \fBMSF\fR-type
X  reminder.  The default is 0.
X***************
X*** 1545,1550 ****
X--- 1590,1601 ----
X  are positive; southern ones are negative.  For southern latitudes, all
X  three components should be negative.
X  .TP
X+ .B $Location (STRING type)
X+ This is a string specifying the name of your location.  It is usually
X+ the name of your town or city.  It can be set to whatever you like,
X+ but good style indicates that it should be kept consistent with
X+ the latitude and longitude system variables.
X+ .TP
X  .B $LongDeg, $LongMin, $LongSec
X  These specify the longitude of your location.  \fB$LongDeg\fR can
X  range from -180 to 180.  Western longitudes are positive; eastern
X***************
X*** 1907,1912 ****
X--- 1958,2005 ----
X  Returns an \fBINT\fR from 1 to 12, representing the month component of
X  \fIdate\fR.
X  .TP
X+ .B "moondate(i_phase [,d_date [,t_time]])"
X+ This function returns the date of the first occurrence of the phase
X+ \fIphase\fR of the moon on or after \fIdate\fR and \fItime\fR.
X+ \fIPhase\fR can range from 0 to 3, with 0 signifying new moon, 1 first
X+ quarter, 2 full moon, and 3 third quarter.  If \fIdate\fR is omitted,
X+ it defaults to \fBtoday()\fR.  If \fItime\fR is omitted, it defaults
X+ to midnight.
X+ .RS
X+ .PP
X+ For example, the following returns the date of the next full moon:
X+ .PP
X+ .nf
X+ 		SET fullmoon moondate(2)
X+ .fi
X+ .PP
X+ .RE
X+ .TP
X+ .B "moontime(i_phase [,d_date [,t_time]])"
X+ This function returns the time of the first occurrence of the phase
X+ \fIphase\fR of the moon on or after \fIdate\fR and \fItime\fR.
X+ \fIPhase\fR can range from 0 to 3, with 0 signifying new moon, 1 first
X+ quarter, 2 full moon, and 3 third quarter.  If \fIdate\fR is omitted,
X+ it defaults to \fBtoday()\fR.  If \fItime\fR is omitted, it defaults
X+ to midnight.  \fBMoontime()\fR is intended to be used in conjunction
X+ with \fBmoondate()\fR.  Don't take the time too seriously - it's only
X+ accurate to within 15-20 minutes.
X+ .RS
X+ .PP
X+ For example, the following returns the date and time of the next full moon:
X+ .PP
X+ .nf
X+ 		MSG Next full moon at [moontime(2)] on [moondate(2)]
X+ .fi
X+ .PP
X+ .RE
X+ .TP
X+ .B moonphase([d_date [,t_time]])
X+ This function returns the phase of the moon on \fIdate\fR and \fItime\fR,
X+ which default to \fBtoday()\fR and midnight, respectively.  The returned
X+ value is an integer from 0 to 359, representing the phase of the moon
X+ in degrees.  0 is a new moon, 180 is a full moon, 90 is first-quarter, etc.
X+ .TP
X  .B now()
X  Returns the current system time, as a \fBTIME\fR type.
X  .TP
X***************
X*** 1931,1936 ****
X--- 2024,2064 ----
X  \fIstr2\fR otherwise.
X  .RE
X  .TP
X+ .B psmoon(i_phase [,i_size])
X+ Returns a \fBSTRING\fR consisting of PostScript code to draw a moon
X+ in the upper-left hand corner of the calendar box.  \fIPhase\fR specifies
X+ the phase of the moon, and is 0 (new moon), 1 (first quarter), 2 (full moon)
X+ or 3 (third quarter).  If \fIsize\fR is specified, it controls the radius of
X+ the moon in PostScript units (1/72 inch.)  If it is not specified, the size
X+ of the day-number font is used.
X+ .PP
X+ .RS
X+ For example, the following four lines place moon symbols on the PostScript
X+ calendar:
X+ .PP
X+ .nf
X+ 		REM [trigger(moondate(0))] PS [psmoon(0)]
X+ 		REM [trigger(moondate(1))] PS [psmoon(1)]
X+ 		REM [trigger(moondate(2))] PS [psmoon(2)]
X+ 		REM [trigger(moondate(3))] PS [psmoon(3)]
X+ .fi
X+ .PP
X+ .RE
X+ .TP
X+ .B psshade(i_num)
X+ Returns a \fBSTRING\fR which consists of PostScript commands to
X+ shade a calendar box.  \fINum\fR can range from 0 (completely black)
X+ to 100 (completely white.)  Here's an example of how to use this:
X+ .RS
X+ .PP
X+ .nf
X+ 		REM Sat Sun PS [psshade(95)]
X+ .fi
X+ .PP
X+ The above command emits PostScript code to lightly shade the boxes
X+ for Saturday and Sunday in a PostScript calendar.
X+ .RE
X+ .TP
X  .B realtoday()
X  Returns the date as provided by the operating system.  This is in contrast to
X  \fBRemind\fR's concept of "today", which may be changed if it is running
X***************
X*** 2460,2465 ****
X--- 2588,2605 ----
X  timed reminders are discarded.  If you are in calendar mode
X  (described next), then the calendar processing is aborted.
X  .PP
X+ If you supply an \fBINT\fR-type expression after the \fBEXIT\fR command,
X+ it is returned to the calling program as the exit status.  Otherwise,
X+ an exit status of 99 is returned.
X+ .PP
X+ .B THE FLUSH COMMAND
X+ .PP
X+ This command simply consists of the word \fBFLUSH\fR on a line by
X+ itself.  The command flushes the standard output and standard error
X+ streams used by \fBRemind\fR.  This is not terribly useful to most
X+ people, but may be useful if you run \fBRemind\fR as a subprocess of
X+ another program, and want to use pipes for communication.
X+ .PP
X  .SH CALENDAR MODE
X  .PP
X  If you supply the \fB\-c\fR, \fB\-s\fR or \fB\-p\fR
X***************
X*** 2561,2566 ****
X--- 2701,2728 ----
X  places the time of timed reminders in the calendar according to the
X  \fB\-b\fR command-line option.
X  .PP
X+ .B REPEATED EXECUTION
X+ .PP
X+ If you supply a \fIrepeat\fR parameter on the command line,
X+ and do not use the \fB\-c\fR, \fB\-p\fR, or \fB\-s\fR options, \fBRemind\fR
X+ operates in a similar manner to calendar mode.  It repeatedly executes
X+ the reminder script, incrementing \fBtoday()\fR with each iteration.
X+ The same rules about preserving variables and function definitions
X+ apply.  Note that using \fIrepeat\fR on the command line also enables
X+ the \fB\-q\fR option and disables any \fB\-z\fR option.
X+ As an example, if you want to see how \fBRemind\fR
X+ will behave for the next week, you can type:
X+ .PP
X+ .nf
X+ 	remind .reminders '*7'
X+ .fi
X+ .PP
X+ If you want to print the dates of the next 1000 days, use:
X+ .PP
X+ .nf
X+ 	(echo 'banner %'; echo 'msg [today()]%') | remind - '*1000'
X+ .fi
X+ .PP
X  .SH INITIALIZING VARIABLES ON THE COMMAND LINE
X  .PP
X  The \fB\-i\fR option is used to initialize variables on the \fBRemind\fR
X***************
X*** 2640,2650 ****
X  of the regular calendar entry area.  The space from here to the top
X  of the box is used only to draw the day number.
X  .TP
X! /DayFont, /EntryFont, /SmallFont and /HeadFont
X  The fonts used to draw the day numbers, the calendar entries, the small
X! calendars, and the month and day headings, respectively.
X  .TP
X! DaySize, EntrySize and HeadSize
X  The sizes of the above fonts.  (The size of the small calendar font
X  is \fInot\fR defined here.)  For example, if you wanted to print
X  the Hebrew date next to the regular day number in the calendar, use:
X--- 2802,2813 ----
X  of the regular calendar entry area.  The space from here to the top
X  of the box is used only to draw the day number.
X  .TP
X! /DayFont, /EntryFont, /SmallFont, /TitleFont and /HeadFont
X  The fonts used to draw the day numbers, the calendar entries, the small
X! calendars, the calendar title (month, year)
X! and the day-of-the-week headings, respectively.
X  .TP
X! DaySize, EntrySize, TitleSize and HeadSize
X  The sizes of the above fonts.  (The size of the small calendar font
X  is \fInot\fR defined here.)  For example, if you wanted to print
X  the Hebrew date next to the regular day number in the calendar, use:
X***************
X*** 3144,3150 ****
X  versions of \fBRemind\fR prior to 03.00.01.
X  .SH AUTHOR
X  .PP
X! David F. Skoll
X  .SH BUGS
X  .PP
X  There's no good reason why read-only system variables are not
X--- 3307,3316 ----
X  versions of \fBRemind\fR prior to 03.00.01.
X  .SH AUTHOR
X  .PP
X! David F. Skoll wrote \fBRemind\fR.  The moon code was copied largely verbatim
X! from "moontool" by John Walker.  The Hebrew calendar support was taken
X! from "hdate" by Amos Shapir.  The authors of the language files are
X! listed in the header file "lang.h" which comes with \fBRemind\fR.
X  .SH BUGS
X  .PP
X  There's no good reason why read-only system variables are not
X*** ../prev/sort.c	Thu Aug 19 16:12:01 1993
X--- ./sort.c	Tue Aug 31 16:28:20 1993
X***************
X*** 182,187 ****
X--- 182,188 ----
X        free(cur);
X        cur = next;
X     }
X+    SortedQueue = NULL;
X  }
X  /***************************************************************/
X  /*                                                             */
X*** ../prev/test.cmp	Thu Aug 19 17:06:48 1993
X--- ./test.cmp	Tue Aug 31 13:22:46 1993
X***************
X*** 631,637 ****
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.08"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X--- 631,637 ----
X  "a05" + "6" => "a056"
X  value("a056") => "SDFJHSDF KSJDFH KJSDFH KSJDFH"
X  set a058 version()
X! version() => "03.00.09"
X  set a059 wkday(today())
X  today() => 1991/02/16
X  wkday(1991/02/16) => "Saturday"
X***************
X*** 772,778 ****
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.08"
X          a077  "1992 92
X  "
X          a049  21
X--- 772,778 ----
X          a048  "foo"
X          a067  "INT"
X          a039  "February"
X!         a058  "03.00.09"
X          a077  "1992 92
X  "
X          a049  21
X*** ../prev/token.c	Tue Aug  3 12:29:05 1993
X--- ./token.c	Fri Sep  3 11:50:53 1993
X***************
X*** 57,62 ****
X--- 57,63 ----
X     { "errmsg",          6,      T_ErrMsg,       0 },
X     { "exit",		4,	T_Exit,		0 },
X     { "february", 	3, 	T_Month,	1 },
X+    { "flush",		5,	T_Flush,	0 },
X     { "friday", 		3,	T_WkDay,	4 },
X     { "fset",		4,	T_Fset,		0 },
X     { "if",		2,	T_If,		0 },
X*** ../prev/types.h	Tue Aug  3 12:28:45 1993
X--- ./types.h	Fri Sep  3 11:50:48 1993
X***************
X*** 126,132 ****
X    T_Clr,
X    T_Debug,
X    T_Dumpvars,
X!   T_Scanfrom
X  };
X  
X  /* The structure of a token */
X--- 126,133 ----
X    T_Clr,
X    T_Debug,
X    T_Dumpvars,
X!   T_Scanfrom,
X!   T_Flush
X  };
X  
X  /* The structure of a token */
X*** ../prev/var.c	Thu Aug 19 16:40:40 1993
X--- ./var.c	Tue Sep 28 16:16:07 1993
X***************
X*** 12,17 ****
X--- 12,18 ----
X  
X  #include "config.h"
X  #include <stdio.h>
X+ #include <string.h>
X  #ifdef HAVE_STDLIB_H
X  #include <stdlib.h>
X  #endif
X***************
X*** 218,228 ****
X     r = EvaluateExpr(p, &v);
X     if (r) return r;
X  
X!    if (*TokBuffer == '$') {
X!       if (v.type != INT_TYPE) return E_BAD_TYPE;
X!       return SetSysVar(TokBuffer+1, v.v.val);
X!    }
X!    return SetVar(TokBuffer, &v);
X  }
X  
X  /***************************************************************/
X--- 219,226 ----
X     r = EvaluateExpr(p, &v);
X     if (r) return r;
X  
X!    if (*TokBuffer == '$') return SetSysVar(TokBuffer+1, &v);
X!    else return SetVar(TokBuffer, &v);
X  }
X  
X  /***************************************************************/
X***************
X*** 331,343 ****
X  /*  DestroyVars                                                */
X  /*                                                             */
X  /*  Free all the memory used by variables, but don't delete    */
X! /*  preserved variables.                                       */
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC void DestroyVars(void)
X  #else
X! void DestroyVars()
X  #endif
X  {
X     int i;
X--- 329,342 ----
X  /*  DestroyVars                                                */
X  /*                                                             */
X  /*  Free all the memory used by variables, but don't delete    */
X! /*  preserved variables unless ALL is non-zero.                */
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC void DestroyVars(int all)
X  #else
X! void DestroyVars(all)
X! int all;
X  #endif
X  {
X     int i;
X***************
X*** 348,354 ****
X        VHashTbl[i] = NULL;
X        prev = NULL;
X        while(v) {
X!          if (!v->preserve) {
X              DestroyValue(&(v->v));
X     	    next = v->next;
X  	    free(v);
X--- 347,353 ----
X        VHashTbl[i] = NULL;
X        prev = NULL;
X        while(v) {
X!          if (all || !v->preserve) {
X              DestroyValue(&(v->v));
X     	    next = v->next;
X  	    free(v);
X***************
X*** 431,472 ****
X  typedef struct {
X     char *name;
X     char modifiable;
X!    int *value;   
X     int min;
X     int max;
X  } SysVar;
X  
X! #define NO_CONSTRAINT 4532
X  /* All of the system variables sorted alphabetically */
X  static SysVar SysVarArr[] = {
X!        /* name		  modifiable	value		min	max */
X!    {   "CalcUTC",	  1,		&CalculateUTC,	0,	1   },
X!    {   "CalMode",	  0,		&DoCalendar,	0,	0   },
X!    {   "Daemon",	  0,		&Daemon,	0,	0   },
X!    {   "DontFork",	  0,		&DontFork,	0,	0   },
X!    {   "DontQueue",	  0,		&DontQueue,	0,	0   },
X!    {   "DontTrigAts",	  0,		&DontIssueAts,	0,	0   },
X!    {   "FirstIndent",	  1,		&FirstIndent,	0,	132 },
X!    {   "FoldYear",	  1,		&FoldYear,	0,	1   },
X!    {   "FormWidth",	  1,		&FormWidth,	20,	132 },
X!    {   "HushMode",	  0,		&Hush,		0,	0   },
X!    {   "IgnoreOnce",	  0,		&IgnoreOnce,	0,	0   },
X!    {   "InfDelta",	  0,		&InfiniteDelta,	0,	0   },
X!    {   "LatDeg",	  1,		&LatDeg,	-90,	90  },
X!    {   "LatMin",	  1,		&LatMin,	-59,	59  },
X!    {   "LatSec",	  1,		&LatSec,	-59,	59  },
X!    {   "LongDeg",	  1,		&LongDeg,	-180,	180  },
X!    {   "LongMin",	  1,		&LongMin,	-59,	59  },
X!    {   "LongSec",	  1,		&LongSec,	-59,	59  },
X!    {   "MaxSatIter",	  1,		&MaxSatIter,	10,	NO_CONSTRAINT },
X!    {   "MinsFromUTC",	  1,		&MinsFromUTC,	-13*60,	13*60 },
X!    {   "NextMode",	  0,		&NextMode,	0,	0   },
X!    {   "NumQueued",	  0,		&NumQueued,	0,	0   },
X!    {   "NumTrig",	  0,		&NumTriggered,	0,	0   },
X!    {   "PSCal",		  0,		&PsCal,		0,	0   },
X!    {   "RunOff",	  0,		&RunDisabled,	0,	0   },
X!    {   "SimpleCal",	  0,		&DoSimpleCalendar,	0,  0 },
X!    {   "SubsIndent",	  1,		&SubsIndent,	0,	132}
X  };
X  
X  #define NUMSYSVARS ( sizeof(SysVarArr) / sizeof(SysVar) )
X--- 430,480 ----
X  typedef struct {
X     char *name;
X     char modifiable;
X!    int type;
X!    void *value;
X     int min;
X     int max;
X  } SysVar;
X  
X! /* If the type of a sys variable is STR_TYPE, then min is redefined
X!    to be a flag indicating whether or not the value has been malloc'd. */
X! #define been_malloced min
X! 
X! /* Flag for no min/max constraint */
X! #define ANY 4532
X  /* All of the system variables sorted alphabetically */
X  static SysVar SysVarArr[] = {
X!        /* name		  mod	type		value		min/mal	max */
X!    {   "CalcUTC",	  1,	INT_TYPE,	&CalculateUTC,	0,	1   },
X!    {   "CalMode",	  0,	INT_TYPE,	&DoCalendar,	0,	0   },
X!    {   "Daemon",	  0,	INT_TYPE,	&Daemon,	0,	0   },
X!    {   "DontFork",	  0,	INT_TYPE,	&DontFork,	0,	0   },
X!    {   "DontQueue",	  0,	INT_TYPE,	&DontQueue,	0,	0   },
X!    {   "DontTrigAts",	  0,	INT_TYPE,	&DontIssueAts,	0,	0   },
X!    {   "EndSent",	  1,	STR_TYPE,	&EndSent,	0,	0   },
X!    {   "EndSentIg",	  1,	STR_TYPE,	&EndSentIg,	0,	0   },
X!    {   "FirstIndent",	  1,	INT_TYPE,	&FirstIndent,	0,	132 },
X!    {   "FoldYear",	  1,	INT_TYPE,	&FoldYear,	0,	1   },
X!    {   "FormWidth",	  1,	INT_TYPE,	&FormWidth,	20,	132 },
X!    {   "HushMode",	  0,	INT_TYPE,	&Hush,		0,	0   },
X!    {   "IgnoreOnce",	  0,	INT_TYPE,	&IgnoreOnce,	0,	0   },
X!    {   "InfDelta",	  0,	INT_TYPE,	&InfiniteDelta,	0,	0   },
X!    {   "LatDeg",	  1,	INT_TYPE,	&LatDeg,	-90,	90  },
X!    {   "LatMin",	  1,	INT_TYPE,	&LatMin,	-59,	59  },
X!    {   "LatSec",	  1,	INT_TYPE,	&LatSec,	-59,	59  },
X!    {   "Location",	  1,	STR_TYPE,	&Location,	0,	0   },
X!    {   "LongDeg",	  1,	INT_TYPE,	&LongDeg,	-180,	180  },
X!    {   "LongMin",	  1,	INT_TYPE,	&LongMin,	-59,	59  },
X!    {   "LongSec",	  1,	INT_TYPE,	&LongSec,	-59,	59  },
X!    {   "MaxSatIter",	  1,	INT_TYPE,	&MaxSatIter,	10,	ANY },
X!    {   "MinsFromUTC",	  1,	INT_TYPE,	&MinsFromUTC,	-13*60,	13*60 },
X!    {   "NextMode",	  0,	INT_TYPE,	&NextMode,	0,	0   },
X!    {   "NumQueued",	  0,	INT_TYPE,	&NumQueued,	0,	0   },
X!    {   "NumTrig",	  0,	INT_TYPE,	&NumTriggered,	0,	0   },
X!    {   "PSCal",		  0,	INT_TYPE,	&PsCal,		0,	0   },
X!    {   "RunOff",	  0,	INT_TYPE,	&RunDisabled,	0,	0   },
X!    {   "SimpleCal",	  0,	INT_TYPE,	&DoSimpleCalendar,	0,  0 },
X!    {   "SubsIndent",	  1,	INT_TYPE,	&SubsIndent,	0,	132}
X  };
X  
X  #define NUMSYSVARS ( sizeof(SysVarArr) / sizeof(SysVar) )
X***************
X*** 480,501 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int SetSysVar(const char *name, int value)
X  #else
X  int SetSysVar(name, value)
X  char *name;
X! int value;
X  #endif
X  {
X     SysVar *v = FindSysVar(name);
X     if (!v) return E_NOSUCH_VAR;
X     if (!v->modifiable) {
X        Eprint("%s: '$%s'", ErrMsg[E_CANT_MODIFY], name);
X        return E_CANT_MODIFY;
X     }
X!    if (v->max != NO_CONSTRAINT && value > v->max) return E_2HIGH;
X!    if (v->min != NO_CONSTRAINT && value < v->min) return E_2LOW;
X!    *(v->value) = value;
X     return OK;
X  }
X  
X--- 488,519 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PUBLIC int SetSysVar(const char *name, Value *value)
X  #else
X  int SetSysVar(name, value)
X  char *name;
X! Value *value;
X  #endif
X  {
X     SysVar *v = FindSysVar(name);
X     if (!v) return E_NOSUCH_VAR;
X+    if (v->type != value->type) return E_BAD_TYPE;
X     if (!v->modifiable) {
X        Eprint("%s: '$%s'", ErrMsg[E_CANT_MODIFY], name);
X        return E_CANT_MODIFY;
X     }
X! 
X! /* If it's a string variable, special measures must be taken */
X!    if (v->type == STR_TYPE) {
X!       if (v->been_malloced) free(*((char **)(v->value)));
X!       v->been_malloced = 1;
X!       *((char **) v->value) = value->v.str;
X!       value->type = ERR_TYPE;  /* So that it's not accidentally freed */
X!    } else {
X!       if (v->max != ANY && value->v.val > v->max) return E_2HIGH;
X!       if (v->min != ANY && value->v.val < v->min) return E_2LOW;
X!       *((int *)v->value) = value->v.val;
X!    }
X     return OK;
X  }
X  
X***************
X*** 516,525 ****
X  {
X     SysVar *v = FindSysVar(name);
X  
X!    val->type = INT_TYPE;
X!    val->v.val = 0;
X     if (!v) return E_NOSUCH_VAR;
X!    val->v.val = *(v->value);
X     return OK;
X  }
X  
X--- 534,548 ----
X  {
X     SysVar *v = FindSysVar(name);
X  
X!    val->type = ERR_TYPE;
X     if (!v) return E_NOSUCH_VAR;
X!    if (v->type == STR_TYPE) {
X!       val->v.str = StrDup(*((char **) v->value));
X!       if (!val->v.str) return E_NO_MEM;
X!    } else {
X!       val->v.val = *((int *) v->value);
X!    }
X!    val->type = v->type;
X     return OK;
X  }
X  
X***************
X*** 603,615 ****
X     if (name) strcat(buffer, name); else strcat(buffer, v->name);
X     fprintf(ErrFp, "%*s  ", VAR_NAME_LEN, buffer);
X     if (v) {
X!       if (!v->modifiable) fprintf(ErrFp, "%d\n", *v->value);
X!       else {
X!          fprintf(ErrFp, "%-10d  ", *v->value);
X! 	 if (v->min == NO_CONSTRAINT) fprintf(ErrFp, "(-Inf, ");
X! 	 else                         fprintf(ErrFp, "[%d, ", v->min);
X! 	 if (v->max == NO_CONSTRAINT) fprintf(ErrFp, "Inf)\n");
X! 	 else                         fprintf(ErrFp, "%d]\n", v->max);
X        }
X     } else   fprintf(ErrFp, "%s\n", UNDEF);
X  
X--- 626,648 ----
X     if (name) strcat(buffer, name); else strcat(buffer, v->name);
X     fprintf(ErrFp, "%*s  ", VAR_NAME_LEN, buffer);
X     if (v) {
X!       if (v->type == STR_TYPE) {
X!          char *s = *((char **)v->value);
X! 	 int y;
X! 	 putc('"', ErrFp);
X! 	 for (y=0; y<MAX_PRT_LEN && *s; y++) putc(*s++, ErrFp);
X! 	 putc('"', ErrFp);
X! 	 if (*s) fprintf(ErrFp, "...");
X! 	 putc('\n', ErrFp);
X!       } else {
X!          if (!v->modifiable) fprintf(ErrFp, "%d\n", *((int *)v->value));
X!          else {
X!             fprintf(ErrFp, "%-10d  ", *((int *)v->value));
X!    	    if (v->min == ANY) fprintf(ErrFp, "(-Inf, ");
X! 	    else                         fprintf(ErrFp, "[%d, ", v->min);
X! 	    if (v->max == ANY) fprintf(ErrFp, "Inf)\n");
X! 	    else                         fprintf(ErrFp, "%d]\n", v->max);
X!          }
X        }
X     } else   fprintf(ErrFp, "%s\n", UNDEF);
X  
END_OF_FILE
  if test 42130 -ne `wc -c <'patch.09.D'`; then
    echo shar: \"'patch.09.D'\" unpacked with wrong size!
  elif test -f 'patch.09.A' && test -f 'patch.09.B' && test -f 'patch.09.C'
  then
    echo shar: Combining  \"'patch.09'\" \(145785 characters\) 
    cat 'patch.09.A' 'patch.09.B' 'patch.09.C' 'patch.09.D' > 'patch.09' 
    if test 145785 -ne `wc -c <'patch.09'`; then 
      echo shar: \"'patch.09'\" combined with wrong size! 
    else 
      rm patch.09.A patch.09.B patch.09.C patch.09.D 
    fi 
  fi
  # end of 'patch.09.D'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
