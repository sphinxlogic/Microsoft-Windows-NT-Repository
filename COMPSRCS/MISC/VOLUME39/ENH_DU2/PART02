Newsgroups: comp.sources.misc
From: chip@chinacat.unicom.com (Chip Rosenthal)
Subject: v39i036: enh-du2 - enhanced du (disk usage) v2.0 + utilities, Part02/02
Message-ID: <1993Aug22.012639.27999@sparky.sterling.com>
X-Md4-Signature: 762905bf4674c5de0b8c84a425e6c175
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Unicom Systems Development, Austin, TX
Date: Sun, 22 Aug 1993 01:26:39 GMT
Approved: kent@sparky.sterling.com

Submitted-by: chip@chinacat.unicom.com (Chip Rosenthal)
Posting-number: Volume 39, Issue 36
Archive-name: enh-du2/part02
Environment: UNIX
Supersedes: enh-du: Volume 14, Issue 88

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile config.h du.c du.h dusort.1 dusort.c ngsizes
#   patchlevel.h stdlib.h
# Wrapped by kent@sparky on Sat Aug 21 19:59:21 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(5074 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# @(#) Makefile 1.20 93/08/18 00:08:53
X
X##############################################################################
X#
X# Site-specific customizations - please edit accordingly.
X#
X
XSHELL = /bin/sh
XCC = cc
XOPTIM = -O
X#DEBUG = -g -DDEBUG
X
X#
X# Specify any system specific "cc" flags here.
X#	WARNING - For HPUX see the rules section for building "fsinfo.o".
X#
XCDEFS =		# For most systems.
X#CDEFS = -I.	# If your system does not have a <stdlib.h> header file.
X
X#
X# Specify any system specific libraries here.
X#
XLIBS = -lmalloc		# Use this for systems with a good malloc library.
X#LIBS =			# Use this if no special libraries needed.
X#LIBS = -lmalloc -ldir	# Recent SCO XENIX - define USE_DIR_DIRENT in config.h.
X#LIBS = -lmalloc -lx	# Old SCO XENIX - define USE_DIR_SYSNDIR in config.h.
X
X#
X# If you want "make install" to work, you must do one of two things:
X# (1) create a script called "Install" in the current directory with
X# the installation instructions, or (2) customize the following definitions:
X#
X# CP - Define as the command to install things in their place.
X#
X# BINDIR - Define as the pathname of the directory where the executables
X#	and scripts go.
X#
X#	==> If you want to suppress the installation of executables
X#	    and scripts then comment out the BINDIR definition.
X#
X# STRIP, CHOWNEXE, CHGRPEXE, CHMODEXE - Various commands that can be
X#	performed on the executables and scripts after they are
X#	installed in place.  (STRIP is not done for scripts, just
X#	executables.)  If you do not want the associated command run,
X#	then either stick a ":" at the front of it or define it to
X#	something innocuous such as "true".
X#
X#
X# MANDIR - Define as the pathname of the directory where manual page
X#	source files go.
X#
X#	==> If you want to suppress the installation of manual
X#	    page source files then comment out the MANDIR definition.
X#
X# MANSUF - Define as the suffix to put at the end of manual page source
X#	files.
X#
X# CHOWNMAN, CHGRPMAN, CHMODMAN - Various commands that can be performed
X#	on the man page sources after they are installed in place.  If
X#	you do not want the associated command run, then either stick
X#	a ":" at the front of it or define it to something innocuous
X#	such as "true".
X#
XCP = cp
XBINDIR = /local/bin
XSTRIP = : strip
XCHOWNEXE = chown bin
XCHGRPEXE = chgrp bin
XCHMODEXE = chmod 555
XMANDIR = /local/man/man1
XMANSUF = 1
XCHOWNMAN = chown bin
XCHGRPMAN = chgrp bin
XCHMODMAN = chmod 444
X
X#
X# End of site-specific customizations.
X#
X##############################################################################
X
XCFLAGS = $(OPTIM) $(CDEFS) $(DEBUG)
XLDFLAGS = $(DEBUG)
XLINTFLAGS = $(CDEFS) -DNO_PROTOTYPE -DPTRTYPE=char
X
XFILES = README du.c duentry.c fsinfo.c dusort.c \
X	patchlevel.h config.h du.h stdlib.h \
X	Makefile ngsizes du.1 dusort.1 ngsizes.1
X
Xall : du dusort ngsizes du.1 dusort.1 ngsizes.1
X
Xdu : du.o duentry.o fsinfo.o
X	$(CC) $(LDFLAGS) -o $@ du.o duentry.o fsinfo.o $(LIBS)
X
Xdu.o : du.c config.h du.h patchlevel.h
Xduentry.o : duentry.c config.h du.h
Xfsinfo.o : fsinfo.c config.h du.h
X
X#
X# I've been told "fsinfo.c" breaks under HPUX with -D_POSIX_SOURCE and
X# you need to use -D_HPUX_SOURCE instead.  If this applies to you, you
X# might need to comment out the above rule for "fsinfo.o" and enable
X# the following.
X#
X#fsinfo.o : fsinfo.c config.h du.h
X#	$(CC) -D_HPUX_SOURCE $(OPTIM) $(DEBUG) fsinfo.c
X#
X
Xdusort : dusort.o
X	$(CC) $(LDFLAGS) -o $@ dusort.o $(LIBS)
X
Xdusort.o : dusort.c
X
Xclean :
X	rm -f du dusort *.o a.out core *.lint
X	-if test -d SCCS ; then sccs clean && sccs get Makefile ; fi
X
Xlint : du dusort
X	lint $(LINTFLAGS) du.c duentry.c fsinfo.c $(LIBS) >du.lint
X	lint $(LINTFLAGS) dusort.c $(LIBS) >dusort.lint
X
Xinstall : all
X	-test ! -f Install -a -f SCCS/s.Install && sccs get Install
X	-if test -f Install ; then \
X		( set -x ; sh Install -$(MAKEFLAGS) ) ; \
X	else \
X		if test "X$(BINDIR)" != X -a -d "$(BINDIR)" ; then \
X			( set -x ; $(MAKE) -$(MAKEFLAGS) install_bin ) ; \
X		fi ; \
X		if test "X$(MANDIR)" != X -a -d "$(MANDIR)" ; then \
X			( set -x ; $(MAKE) -$(MAKEFLAGS) install_man ) ; \
X		fi ; \
X	fi
X
Xinstall_bin : $(BINDIR)/du $(BINDIR)/dusort $(BINDIR)/ngsizes
X
Xinstall_man : $(MANDIR)/du.$(MANSUF) $(MANDIR)/dusort.$(MANSUF) \
X		$(MANDIR)/ngsizes.$(MANSUF)
X
X$(BINDIR)/du : du
X	rm -f $@
X	$(CP) $? $@
X	$(STRIP) $@
X	$(CHMODEXE) $@ ; $(CHGRPEXE) $@ ; $(CHOWNEXE) $@
X
X$(BINDIR)/dusort : dusort
X	rm -f $@
X	$(CP) $? $@
X	$(STRIP) $@
X	$(CHMODEXE) $@ ; $(CHGRPEXE) $@ ; $(CHOWNEXE) $@
X
X$(BINDIR)/ngsizes : ngsizes
X	rm -f $@
X	$(CP) $? $@
X	$(STRIP) $@
X	$(CHMODEXE) $@ ; $(CHGRPEXE) $@ ; $(CHOWNEXE) $@
X
X$(MANDIR)/du.$(MANSUF) : du.1
X	rm -f $@
X	$(CP) $? $@
X	$(CHMODMAN) $@ ; $(CHGRPMAN) $@ ; $(CHOWNMAN) $@
X
X$(MANDIR)/dusort.$(MANSUF) : dusort.1
X	rm -f $@
X	$(CP) $? $@
X	$(CHMODMAN) $@ ; $(CHGRPMAN) $@ ; $(CHOWNMAN) $@
X
X$(MANDIR)/ngsizes.$(MANSUF) : ngsizes.1
X	rm -f $@
X	$(CP) $? $@
X	$(CHMODMAN) $@ ; $(CHGRPMAN) $@ ; $(CHOWNMAN) $@
X
X
Xshar : du.shar
X
Xdu.shar : $(FILES)
X	shar $(FILES) > $@
X
X
X#
X# yeah - go ahead and comment this out if it's creating problems
X#
X$(FILES) Install :
X	sccs get $@
X
Xsccs : $(FILES) Install
X
END_OF_FILE
  if test 5074 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
  echo shar: Extracting \"'config.h'\" \(8290 characters\)
  sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/* @(#) config.h 1.14 93/08/18 00:08:58 
X *
X * "du" enhanced disk usage summary - version 2.
X *
X * Copyright 1990-1993, Unicom Systems Development.  All rights reserved.
X * See accompanying README file for terms of distribution and use.
X *
X * Edit at tabstops=8.
X *
X * This file must be configured for the target system.  Warning -- a lot
X * of this stuff is pretty obscure and esoteric.  That's unavoidable.
X * After all, we are dealing with some very low-level system facilities.
X * Moreover, some vendors take it upon themself to "value add" their Unix
X * to death, which just makes this task more difficult.
X *
X * With patience (and a good file pager) you will persevere!  I've tried
X * to provide hints and assistance wherever possible.  Nonetheless, chances
X * are very good that you will need to trawl through your /usr/include
X * directory to determine which selections are correct.
X *
X * If you get stuck, consult the README.  You'll find some hints for a
X * handful of systems that I have personally used.  If you have any
X * suggestions on how to make this task easier, let me know.
X */
X
X/*
X * Select one of the following.  It says how to read directories.
X */
X#define USE_DIR_DIRENT		/* use <dirent.h>, struct dirent       common */
X/*#define USE_DIR_SYSDIR	/* use <sys/dir.h>, struct direct     old BSD */
X/*#define USE_DIR_SYSNDIR	/* use <sys/ndir.h>, struct direct  old XENIX */
X
X/*
X * Select one of the following.  It says how to look for mounted filesystems.
X */
X#define USE_MOUNT_MNTTAB	/* use <mnttab.h>, use /etc/mnttab       SysV */
X/*#define USE_MOUNT_R4MNTTAB	/* use <sys/mnttab.h>, /etc/mnttab     SysVr4 */
X/*#define USE_MOUNT_MNTENT	/* use <mntent.h>, use /etc/mtab   SunOS,HPUX */
X/*#define USE_MOUNT_FSTAB	/* use <fstab.h>, use /etc/fstab          BSD */
X/*#define USE_MOUNT_MNTCTL	/* use <sys/mntctl.h>, use mntctl()       AIX */
X
X/*
X * Select one of the following.  It says where your "struct statfs" is
X * defined -- or that your system doesn't support the "statfs()" call.
X */
X#define USE_STATFS_SYSV		/* include <sys/statfs.h>                     */
X/*#define USE_STATFS_BSD	/* include <sys/mount.h>		      */
X/*#define USE_STATFS_SUN	/* include <sys/vfs.h>, SysV-style stafs()    */
X/*#define USE_STATFS_HPUX	/* include <sys/vfs.h>, BSD-style statfs()    */
X/*#define USE_STATFS_NONE	/* statfs() call not available, e.g. S5R2     */
X
X/*
X * Enable USE_SYMLINKS if you have symbolic links, else comment it out.
X *
X * It is important you enable this if appropriate.  It prevents "du" from
X * following symlinks that point to directories, and thus reporting bogus
X * results or ending up in strange twisted loops.
X */
X/*#define USE_SYMLINKS 		/* enable for SysVr4, Sun, etc. */
X
X/*
X * Enable USE_STBLOCKS if the "stat" structure in your <sys/stat.h> file
X * has an "st_blocks" member, else comment it out.
X *
X * It is important to enable this if appropriate for two reasons.  First,
X * performance of "du" is *significantly* improved if "st_blocks"
X * information can be used.  Second, it will avoid reporting errors on
X * so-called "sparse" files.
X */
X/*#define USE_STBLOCKS		/* enable for SysVr4, Sun, etc. */
X
X/*
X * Leave BROKE_STBLOCKS undefined unless you really need it.
X *
X * If you didn't define USE_STBLOCKS above then don't even bother
X * reading this -- just leave BROKE_STBLOCKS undefined.
X *
X * This definition is provided as a workaround for certain vendors who
X * are a little confused about how Unix is supposed to work.  The
X * "st_blocks" information returned by stat(2) is supposed to be in
X * 512-byte blocks.  Some vendors botch this.  AIX, for example, properly
X * reports local filesystems in 512-byte blocks, but across the network
X * reports in 1024-byte blocks.  HPUX does the exact opposite.
X *
X * If you define BROKE_STBLOCKS, then "du" will try to calculate how
X * "st_blocks" should be interpreted rather than assuming 512-byte blocks.
X * This calculation, unfortunately, will fail for filesystems that use
X * fragments and the "f_bsize" value reported by statfs(2) is the block
X * size instead of the fragment size (e.g. Solaris, BSDI).
X *
X * So, enable BROKE_STBLOCKS only if all the following is true:
X *
X *	- You have defined USE_STBLOCKS.  If you haven't, BROKE_STBLOCKS
X *	  is ignored anyway.
X *
X *	- "du" is reporting wrong values, usually either twice or half
X *	  the correct size.
X *
X *	- Either you do not have a fast filesystem with fragments or
X *	  "f_bsize" indicates the size of the fragment.
X *
X * (Please send a note to the author if you wish you could use
X * BROKE_STBLOCKS but can't because your system uses fragments.)
X */
X/*#define BROKE_STBLOCKS	/* enable for HPUX, networked AIX */
X
X/*
X * If your system has the ANSI <stdarg.h> facility then enable USE_STDARG.
X * If your system only has the older <varargs.h> then disable it.
X */
X#define USE_STDARG		/* enable on ANSI-compliant systems */
X
X/*
X * Enable USE_UNISTD if your system has a <unistd.h> file.
X * If you don't have this header file then disable it.
X */
X#define USE_UNISTD		/* enable on ANSI-compliant systems */
X
X/*
X * Enable USE_PATHCONF if your system has the POSIX pathconf() facility,
X * else comment it out.
X *
X * ===>	For some reason, this is the definition people seem to flub up
X *	most frequently.  If your system is an older, pre-POSIX system
X *	that lacks pathconf() then do NOT enable this.  If you ain't
X *	got it, I can't use it!
X *
X * If you enable USE_PATHCONF you *must* also have enabled USE_UNISTD.
X * If you disable USE_PATHCONF then we will make a (usually reasonable)
X * guess at how much space to reserve to hold pathnames.
X */
X#define USE_PATHCONF		/* enable on POSIX-compliant systems */
X
X/*
X * PTRTYPE indicates what your compiler uses as a generic pointer type.
X * Most modern compilers will accept "void".  Crufty compilers use "char".
X */
X#ifndef PTRTYPE
X#define PTRTYPE void		/* use (void *) as a generic pointer	*/
X/*#define PTRTYPE char		/* use (char *) as a generic pointer	*/
X#endif
X
X/*
X * ### YOU ARE NOW FINISHED WITH THE ESSENTIAL CONFIGURATIONS ###
X * 
X * Congratulations!  You made it.  You are now ready to roll.
X *
X * You might, however, want to glance through the following definitions.
X * These allow you to tailor "du" behavior according to your site-specific
X * preferences.
X */
X
X/*
X * REPORT_BLOCKSIZE specifies default block size to use for reporting
X * disk usage, usually either "512" or "1024".  Most versions of "du"
X * (including POSIX conformant versions) use 512.  Others, such as SunOS,
X * use 1024.  Pick whatever you prefer.  This choice does not effect the
X * usage calculations or accuracy, only how the results are displayed,
X * and there are command line switches that will override the default
X * selected here.
X */
X#define REPORT_BLKSIZE		512	/* report in 512-byte blocks    */
X/*#define REPORT_BLKSIZE	1024	/* report in 1024-byte blocks   */
X
X/*
X * PRINT_ERRORS controls whether or not error messages (e.g. "permission
X * denied", etc.) are displayed.  When defined, these error messages are
X * displayed.  When disabled, the errors are silently ignored -- which
X * is traditional "du" behavior.  I think it makes more sense to print
X * the errors (i.e. enable PRINT_ERRORS).  If, however, you disable this
X * to obtain backward compatibility, you will get a "-r" command line
X * option that will turn error messages back on.
X */
X#define PRINT_ERRORS		/* display errors by default if enabled */
X
X/*
X * TIMEOUT is a release hatch for hung NFS servers.  If you define
X * this value, "du" will unceremoniously kill itself after this many
X * seconds of inactivity.
X */
X/*#define TIMEOUT	300	/* timeout value in seconds		*/
X
X/*
X * MAX_BREAK is maximum number of columns which can be requested by the
X * "-c" option (breakdown usage by age).  Increasing this value will
X * increase the memory usage, but not by much.
X */
X#define MAX_BREAK	64	/* max columns in breakdown by age	*/
X
X/*
X * OBSOLETEOPT enables "-d" which was present in the original "enh-du"
X * release.  This prevents "du" from descending into directories
X * entirely, which in retrospect seems like a pretty useless thing.
X * If you really need it, enable OBSOLETEOPT.  And let me know, because
X * it is slated for removal if and when another release is done.
X */
X/*#define OBSOLETEOPT		/* if you want old "-d" option		*/
X
END_OF_FILE
  if test 8290 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
  fi
  # end of 'config.h'
fi
if test -f 'du.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'du.c'\"
else
  echo shar: Extracting \"'du.c'\" \(8826 characters\)
  sed "s/^X//" >'du.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char SCCSID[] = "@(#) du.c 1.16 93/08/18 00:09:01";
X#endif
Xstatic char Copyright[] = "@(#) Copyright 1990-1993, Unicom Systems Development, Inc.  All rights reserved.";
X
X/*
X * "du" enhanced disk usage summary - version 2.
X *
X * Copyright 1990-1993, Unicom Systems Development.  All rights reserved.
X * See accompanying README file for terms of distribution and use.
X *
X * Edit at tabstops=4.
X */
X
X#define USAGE "usage: %s [ options ] [ path ... ]  (try \"-h\" for help)\n"
X
X#include "config.h"
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <pwd.h>
X#include <time.h>
X#ifdef TIMEOUT
X# include <signal.h>
X#endif
X#ifdef USE_STDARG
X# include <stdarg.h>
X#else
X# include <varargs.h>
X#endif
X#include <sys/types.h>
X#include <sys/stat.h>
X#define INTERN
X#include "du.h"
X#include "patchlevel.h"
X
Xstatic void do_help __ARGS((void));
Xstatic void set_breakdown __ARGS((char *));
Xstatic int get_userid __ARGS((char *));
X
X
X#ifdef TIMEOUT
X/*ARGSUSED*/
Xvoid alarm_catcher(n)
Xint n;
X{
X	errmssg(ERR_ABORT, 0, "timeout occurred -- giving up");
X	/*NOTREACHED*/
X}
X#endif
X
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int i;
X	struct dusage tot_usage, ent_usage;
X	extern char *optarg;
X	extern int optind;
X
X	Progname = argv[0];
X
X	/* 
X	 * Crack command line options.
X	 */
X	while ((i = getopt(argc, argv, "abB:c:CDdfFhiklLrstuU:")) != EOF) {
X		switch (i) {
X			case 'a':	Handle_output = PR_EVERYTHING;		break;
X			case 'b':   Report_blksize = 1;					break;
X			case 'B':   Report_blksize = atoi(optarg);		break;
X			case 'c':	set_breakdown(optarg);				break;
X			case 'C':	Do_file_counts = TRUE;				break;
X#ifdef OBSOLETEOPT
X			case 'd':	Do_descend_dirs = FALSE;			break;
X#endif
X			case 'f':	Handle_filesys = FS_NEVER_CROSS;	break;
X			case 'F':	Handle_filesys = FS_LOCAL_ONLY;		break;
X			case 'h':	do_help();							exit(0);
X			case 'i':	Do_accum_subdirs = FALSE;			break;
X			case 'k':   Report_blksize = 1024;				break;
X			case 'l':	Handle_links = LK_COUNT_ALL;		break;
X			case 'L':	Handle_links = LK_COUNT_AVERAGE;	break;
X			case 'r':	Do_print_errors = TRUE;				break;
X			case 's':	Handle_output = PR_TOTALS_ONLY;		break;
X			case 't':	Do_print_grand_total = TRUE;		break;
X			case 'u':	Handle_links = LK_COUNT_NONE;		break;
X			case 'U':	Selected_user = get_userid(optarg);	break;
X#ifdef DEBUG
X			case 'D':	Debug = TRUE;						break;
X#endif
X			default:	fprintf(stderr, USAGE, Progname);
X						exit(1);
X		}
X	}
X
X#ifdef TIMEOUT
X	/*
X	 * Install the handler to trap timeouts.
X	 */
X	(void) signal(SIGALRM, alarm_catcher);
X#endif
X
X	/*
X	 * Initialize the filesystem information tables.
X	 */
X	fs_initinfo();
X
X	/*
X	 * Get the time so we can do the breakdown of usage by age.
X	 */
X	(void) time(&Curr_time);
X
X	/*
X	 * Go get the usage.
X	 */
X	if (argc == optind) {
X		du_entry(".", &tot_usage);
X	} else {
X		zero_usage(&tot_usage);
X		for (i = optind ; i < argc ; ++i) {
X			du_entry(argv[i], &ent_usage);
X			add_usage(&tot_usage, &ent_usage);
X		}
X	}
X
X	if (Do_print_grand_total)
X		print_usage("TOTAL", &tot_usage);
X	exit(0);
X	/*NOTREACHED*/
X}
X
X
Xstatic char *help_text[] = {
X	"du - version %V",
X	"    %C",
X	"Usage:",
X	"    %P [ options ] [ path ... ]",
X	"Options:",
X	"    -a          Report all entries, i.e. files as well as directories.",
X	"    -b          Equivalent to \"-B 1\".",
X	"    -B n        Report in blocks of \"n\" bytes (default %B).",
X	"                  (Use \"0\" to report in native filesystem blocks.)",
X	"    -c n,n,...  Breakdown by age, one col for each \"n\" days or older.",
X	"    -C          Display file counts as well as disk usage.",
X#ifdef OBSOLETEOPT
X	"    -d          Do not descend into directories.",
X#endif
X	"    -f          Do not cross any filesystem mount points.",
X	"    -F          Do not cross remote filesystem mount points.",
X	"    -h          Display this help message.",
X	"    -i          Do not accumulate subdirectory usages into parent dir.",
X	"    -k          Equivalent to \"-B 1024\".",
X	"    -l          Count multiply linked files each time encountered.",
X	"    -L          Average usage of multiply linked files across the links.",
X#ifndef PRINT_ERRORS
X	"    -r          Print (do not suppress) errors which occur during scan.",
X#endif
X	"    -s          Only report a total for each argument on command line.",
X	"    -t          Report a grand total of all items.",
X	"    -u          Skip (do not count) multiply linked files entirely.",
X	"    -U user     Report only usage by given user (specify name or id num).",
X	NULL
X};
X
X
Xstatic void do_help()
X{
X	char *s, *p;
X	int i;
X
X	for (i = 0 ; help_text[i] != NULL ; ++i) {
X		for (s = help_text[i] ; *s != '\0' ; ++s) {
X			if (*s != '%') {
X				putchar(*s);
X			} else {
X				switch (*++s) {
X					case 'B':
X						printf("%d", REPORT_BLKSIZE);
X						break;
X					case 'C':
X						for (p = Copyright ; *p != ' ' ; ++p)
X							;
X						fputs(p+1, stdout);
X						break;
X					case 'P':
X						fputs(Progname, stdout);
X						break;
X					case 'V':
X						fputs(VERSION, stdout);
X						break;
X					default:
X						putchar('%');
X						putchar(*s);
X						break;
X				}
X			}
X		}
X		putchar('\n');
X	}
X	exit(0);
X}
X
X
Xstatic void set_breakdown(str)
Xchar *str;
X{
X	char *s;
X	Num_break = 0;
X	while ((s = strtok(str, " \t,")) != NULL) {
X		str = NULL;
X		if (Num_break >= MAX_BREAK)
X			errmssg(ERR_ABORT, 0, "too many breakdown catagories");
X		if ((Breakdown[Num_break++] = atoi(s)) <= 0 && strcmp(s, "0") != 0)
X			errmssg(ERR_ABORT, 0, "bad breakdown value \"%s\"", s);
X	}
X	if (Num_break == 0)
X		errmssg(ERR_ABORT, 0, "no breakdown catagories specified");
X}
X
X
Xstatic int get_userid(id)
Xchar *id;
X{
X	int n;
X	struct passwd *pw;
X	extern struct passwd *getpwnam();
X
X	if ((n = atoi(id)) != 0 || strcmp(id, "0") == 0)
X		return n;
X	pw = getpwnam(id);
X	endpwent();
X	if (pw != NULL)
X		return pw->pw_uid;
X	errmssg(ERR_ABORT, 0, "bad user id \"%s\" specified", id);
X	/*NOTREACHED*/
X}
X
X
XPTRTYPE *xmalloc(n)
Xunsigned n;
X{
X	PTRTYPE *s;
X	if ((s = malloc(n)) == NULL)
X		errmssg(ERR_ABORT, 0, "out of memory [malloc failed]");
X	return s;
X}
X
X
XPTRTYPE *xrealloc(s, n)
XPTRTYPE *s;
Xunsigned n;
X{
X	if ((s = realloc(s, n)) == NULL)
X		errmssg(ERR_ABORT, 0, "out of memory [malloc failed]");
X	return s;
X}
X
X
X/*
X * errmssg - Error reporting routine.  If "err" is nonzero then the
X * sys_errlist[] text will be included in the message.  If "severe" is
X * non-zero then the program will abort after displaying the message.
X * Non-fatal errors will be displayed only if "Do_print_errors" is TRUE.
X */
X/*VARARGS*/
X#ifdef USE_STDARG
Xvoid errmssg(int severe, int err, char *fmt, ...)
X#else
Xvoid errmssg(va_alist)
Xva_dcl
X#endif
X{
X	va_list args;
X#ifndef USE_STDARG
X	int severe, err;
X	char *fmt;
X#endif
X	extern char *sys_errlist[];
X
X#ifdef USE_STDARG
X	va_start(args, fmt);
X#else
X	va_start(args);
X	severe = va_arg(args, int);
X	err = va_arg(args, int);
X	fmt = va_arg(args, char *);
X#endif
X
X	if (severe || Do_print_errors) {
X		fprintf(stderr, "%s: ", Progname);
X		vfprintf(stderr, fmt, args);
X		if (err > 0)
X			fprintf(stderr, " [%s]", sys_errlist[err]);
X		putc('\n', stderr);
X	}
X
X	va_end(args);
X
X	if (severe)
X		exit(1);
X}
X
X
X/*
X * Disk Usage Functions - Disk usage is accumulated (struct dusage) and
X * is used to track both disk usage and file counts chronologically.
X * The following routines manipulate this information.
X */
X
X
X/*
X * Reset usage information to zero.
X */
Xvoid zero_usage(usage)
Xstruct dusage *usage;
X{
X	register int *f, i;
X	register long *b;
X
X	b = usage->blocks;
X	f = usage->files;
X	i = Num_break;
X	while (--i >= 0) {
X		*b++ = 0L;
X		*f++ = 0;
X	}
X}
X
X/*
X * Load usage information from file size and age.
X */
Xvoid set_usage(usage, mtime, nblocks)
Xstruct dusage *usage;
Xtime_t mtime;
Xlong nblocks;
X{
X	register int *f, i;
X	register long *b;
X	int ndays, *brk;
X
X	/*
X	 * There is a race condition here which luckily works out OK.  If a file
X	 * is created after "du" is started, the "Curr_time-sbufp->st_mtime" value
X	 * will be a small negative number, however dividing by "60*60*24" will
X	 * truncate the result to zero, which is the result we want.
X	 */
X	ndays = (int)((Curr_time-mtime) / (60L*60L*24L/*seconds*/));
X
X	b = usage->blocks;
X	f = usage->files;
X	brk = Breakdown;
X	i = Num_break;
X	while (--i >= 0) {
X		if (*brk++ <= ndays) {
X			*b++ = nblocks;
X			*f++ = 1;
X		} else {
X			*b++ = 0L;
X			*f++ = 0;
X		}
X	}
X}
X
X/*
X * Accumulate usage information.
X */
Xvoid add_usage(tot_usage, ent_usage)
Xregister struct dusage *tot_usage, *ent_usage;
X{
X	register int i;
X
X	i = Num_break;
X	while (--i >= 0) {
X		tot_usage->blocks[i] += ent_usage->blocks[i];
X		tot_usage->files[i] += ent_usage->files[i];
X	}
X}
X
X/*
X * Display usage information.
X */
Xvoid print_usage(name, usage)
Xchar *name;
Xstruct dusage *usage;
X{
X	int i;
X	for (i = 0 ; i < Num_break ; ++i) {
X		if (Do_file_counts)
X			printf("%ld\t%d\t", usage->blocks[i], usage->files[i]);
X		else
X			printf("%ld\t", usage->blocks[i]);
X	}
X	printf("%s\n", name);
X}
X
END_OF_FILE
  if test 8826 -ne `wc -c <'du.c'`; then
    echo shar: \"'du.c'\" unpacked with wrong size!
  fi
  # end of 'du.c'
fi
if test -f 'du.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'du.h'\"
else
  echo shar: Extracting \"'du.h'\" \(6342 characters\)
  sed "s/^X//" >'du.h' <<'END_OF_FILE'
X/* @(#) du.h 1.15 93/08/18 00:09:02 
X *
X * "du" enhanced disk usage summary - version 2.
X *
X * Copyright 1990-1993, Unicom Systems Development.  All rights reserved.
X * See accompanying README file for terms of distribution and use.
X *
X * Edit at tabstops=4.
X */
X
X
X#define TRUE		1
X#define FALSE		0
X
X/*
X * Severity levels for errmssg() routine.
X */
X#define ERR_WARN	0
X#define ERR_ABORT	1
X
X#ifdef DEBUG
X# define Dprintf	if (!Debug) ; else fprintf
X#endif
X
X#ifdef S_IFMT
X# ifndef S_ISREG
X#  define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
X# endif
X# ifndef S_ISDIR
X#  define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
X# endif
X#endif
X
X#if defined(lint) && defined(NULL)
X# undef NULL
X# define NULL 0
X#endif
X
X/*
X * A boolean true/false value.
X */
Xtypedef int BOOL;
X
X/*
X * Structure used to store information on mounted filesystems.
X */
Xstruct fsinfo {
X	int dev;				/* the device number						*/
X	int nino;				/* number of available inodes on filesys	*/
X	int bsize;				/* num bytes in a disk block for this dev	*/
X	int nindir;				/* num direct disk addr can fit in a block	*/
X	BOOL remote;			/* is this filesys a remote mount?			*/
X#ifdef BROKE_STBLOCKS
X	int stbsize;			/* quanta for st_blocks reported by stat(2)	*/
X#endif
X	int path_max;			/* max pathlen for an entry on this filesys	*/
X	unsigned char *idone;	/* bit vector to mark inodes of links done	*/
X};
X
X
X/*
X * Structure to accumulate usage statistics.
X *
X * The statistics are accumulated in a chronological breakdown, as
X * specified by "Num_break" and the "Breakdown[]" array.  "Num_break"
X * indicates the number of columns in the breakdown, and "Breakdown[]"
X * specifies the age for each of those columns.
X *
X * The "Num_break" value will range from 1 to MAX_BREAK.  The "blocks[n]"
X * value accumulates the disk usage of all filesystem entries "Breakdown[n]"
X * days or older.  The "files[n]" value counts the number of filesystem
X * entries that contributed to that total.
X *
X * By default, "Num_break" will be 1 and "Breakdown[0]" will be 0.  That
X * says accumulate a single set of statistics for all filesystem entries
X * zero days old or older (i.e. everything).
X *
X */
Xstruct dusage {
X	long blocks[MAX_BREAK];	/* accumulated disk usage					*/
X	int files[MAX_BREAK];	/* number of disk entries					*/
X};
X
X
X#ifdef INTERN
X#	define EXTERN
X#	define INIT(X) = X
X#else
X#	define EXTERN extern
X#	define INIT(X)
X#endif
X
XEXTERN char *Progname;
X#ifdef DEBUG
XEXTERN BOOL Debug INIT(FALSE);
X#endif
X
X/*
X * What to do at filesystem mount points.
X */
XEXTERN enum {
X	FS_ALWAYS_CROSS,	/* always cross mount points (default)	*/
X	FS_NEVER_CROSS,		/* never cross mount points (-f)		*/
X	FS_LOCAL_ONLY		/* cross only local mount points (-F)	*/
X} Handle_filesys INIT(FS_ALWAYS_CROSS);
X
X/*
X * What to do with hard links.
X */
XEXTERN enum {
X	LK_COUNT_FIRST,		/* count just first link encountered (default)	*/
X	LK_COUNT_ALL,		/* handle all hard links (-l)					*/
X	LK_COUNT_NONE,		/* ignore all hard links (-u)					*/
X	LK_COUNT_AVERAGE	/* average disk usage across hard links (-L)	*/
X} Handle_links INIT(LK_COUNT_FIRST);
X
X/*
X * What to report.
X */
XEXTERN enum {
X	PR_DIRS_ONLY,		/* report usage at all directories (default)	*/
X	PR_TOTALS_ONLY,		/* report usage just for cmd line items (-s)	*/
X	PR_EVERYTHING		/* report usage for everything encountered (-a)	*/
X} Handle_output INIT(PR_DIRS_ONLY);
X
X/*
X * If true, accumulate the disk usage of a subdirectory into the usage
X * of its parent directory.  If false, the disk usage of a directory will
X * include just the contents of that directory.
X */
XEXTERN BOOL Do_accum_subdirs INIT(TRUE);
X
X/*
X * If true, display file counts as well as disk block usage.
X */
XEXTERN BOOL Do_file_counts INIT(FALSE);
X
X#ifdef OBSOLETEOPT
X/*
X * If true, descend into directories and accumulate usage (subject to
X * filesystem handling at mount points).  If false, do not descend into
X * directories and simply report the usage of the directory filesystem
X * entry (i.e. sans contents) as its usage.
X *
X * This is a pretty useless option, but was present in the original
X * "enh-du".  Unless somebody tells me they really use it, it is
X * subject to removal in a future version.
X */
XEXTERN BOOL Do_descend_dirs INIT(TRUE);
X#endif
X
X/*
X * If true, the sum of the usages of all items specified on the command
X * line is displayed.  If false, this grand total is omitted.
X */
XEXTERN BOOL Do_print_grand_total INIT(FALSE);
X
X/*
X * If true, error messages are displayed (rational behavior).
X * If false, error messages are suppressed (traditional behavior).
X */
X#ifdef PRINT_ERRORS
XEXTERN BOOL Do_print_errors INIT(TRUE);
X#else
XEXTERN BOOL Do_print_errors INIT(FALSE);
X#endif
X
X/*
X * Block size used in reporting disk usage.  The actual disk usage is
X * calculated, and then scaled to blocks of the size indicated here.  If
X * the value is zero, then the native filesystem block size is used.
X */
XEXTERN int Report_blksize INIT(REPORT_BLKSIZE);
X
X/*
X * Only count usage for the user whose UID is this value, or
X * negative to count usage for all users.
X */
XEXTERN int Selected_user INIT(-1);
X
X/*
X * Specifies ages for the chronological breakdown in a (struct dusage).
X * See comments in the (struct dusage) declaration for more info.
X */
XEXTERN int Breakdown[MAX_BREAK] INIT({0});
X
X/*
X * Number of columns in the chronological breakdown.
X * Specifies number of elements in "Breakdown[]" that are actually used.
X */
XEXTERN int Num_break INIT(1);
X
X/*
X * Current time, used for calculation of the chronological breakdown.
X */
XEXTERN long Curr_time;
X
X
X#if defined(__STDC__) && !defined(NO_PROTOTYPE)
X#	define __ARGS(X) X
X#else
X#	define __ARGS(X) ()
X#endif
X
X/*
X * Procedures.
X */
XPTRTYPE *xmalloc __ARGS((unsigned));
XPTRTYPE *xrealloc __ARGS((PTRTYPE *, unsigned));
Xvoid errmssg __ARGS((int, int, char *, ...));
Xvoid zero_usage __ARGS((struct dusage *));
Xvoid set_usage __ARGS((struct dusage *, time_t, long));
Xvoid add_usage __ARGS((struct dusage *, struct dusage *));
Xvoid print_usage __ARGS((char *, struct dusage *));
Xint max_path_len __ARGS((char *));
Xvoid du_entry __ARGS((char *, struct dusage *));
Xint du_dir __ARGS((char *, struct stat	*, struct fsinfo *, struct dusage *));
Xvoid fs_initinfo __ARGS((void));
Xstruct fsinfo *fs_getinfo __ARGS((struct stat *));
Xint fs_linkdone __ARGS((struct fsinfo *, struct stat *));
Xlong fs_numblocks __ARGS((struct fsinfo *, struct stat *));
X
X
Xextern int errno;
X
END_OF_FILE
  if test 6342 -ne `wc -c <'du.h'`; then
    echo shar: \"'du.h'\" unpacked with wrong size!
  fi
  # end of 'du.h'
fi
if test -f 'dusort.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dusort.1'\"
else
  echo shar: Extracting \"'dusort.1'\" \(1956 characters\)
  sed "s/^X//" >'dusort.1' <<'END_OF_FILE'
X.\" @(#) dusort.1 1.5 93/08/18 00:09:04
X.TH DUSORT 1
X.SH NAME
Xdusort \- Sort disk usage summaries.
X.SH SYNTAX
X.B dusort
X[
X.B \-t
Xthreshold ] [ file ]
X.SH DESCRIPTION
X.P
XThe
X.I dusort
Xprogram is an output filter for
X.IR du .
XIt reads a disk usage report from
X.IR file ,
Xor the standard input if no file is specified on the command line,
Xand produces a listing to the standard output.  The listing will show
Xthe contents of the directories sorted in descending order, and indented
Xunder their parent directory.  The input data lines must have at least
Xtwo white-space delimited fields.  The first field is the disk usage
Xand the last field is the pathname.  The
X.B \-t
Xoption suppresses any entries less than
X.I threshold
Xdisk blocks.
X.SH SEE ALSO
Xdu(1L)
X.SH BUGS
X.P
XA more precise explanation of what this utility does is as follows:
Xit reads the entire
X.I du
Xreport into memory, arranges it into a tree, sorts all of the siblings
Xin order of disk usage, and then performs a depth-first traversal to
Xdisplay the results.
X.P
XThe indentation in the report can get a little wierd if the input
Xdata was generated by running
X.I du
Xwith multiple starting directories.
X.SH AUTHOR
XChip Rosenthal
X.br
XUnicom Systems Development, Inc.
X.br
X<chip\s-1@\s+1chinacat.Unicom.COM>
X.P
X.if t \v'0.3v'\s+4\(co\s-4\v'-0.3v'
XCopyright 1990-1993, Unicom Systems Development, Inc.  All rights reserved.
X.P
XYou are granted a non-exclusive license to use, modify, copy, and
Xdistribute this software subject to the following conditions.  You
Xmust ensure all copyright notices and license notices remain intact
Xin the copies you use or distribute.  Any modifications, other than
Xthose in the areas clearly reserved for site-specific modifications,
Xmust be marked as such.  This software is provided "as is".  No
Xwarranties have been expressed or implied.  Since this license was
Xprovided to you at no charge, you must assume the entire risk and
Xliability for all use of this software.
END_OF_FILE
  if test 1956 -ne `wc -c <'dusort.1'`; then
    echo shar: \"'dusort.1'\" unpacked with wrong size!
  fi
  # end of 'dusort.1'
fi
if test -f 'dusort.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dusort.c'\"
else
  echo shar: Extracting \"'dusort.c'\" \(7653 characters\)
  sed "s/^X//" >'dusort.c' <<'END_OF_FILE'
X/* @(#) dusort.c 1.7 93/08/18 00:09:05
X *
X * disk usage sorter
X *
X * Copyright 1990-1992, Unicom Systems Development.  All rights reserved.
X * See accompanying README file for terms of distribution and use.
X *
X * Edit at tabstops=4.
X *
X * This filter reads the output from "du", builds a tree representing
X * the directories scanned, sorts the nodes in descending order, and
X * traverses the tree, thus yielding a printout of disk usage sorted
X * within directories.
X */
X
X#include "config.h"
X#include <stdio.h>
X#include <stdlib.h>
X#include <ctype.h>
X#include <string.h>
X
X#define USAGE		"usage: %s [-t threshold] [file]\n"
X#define INDENT		4
X#define LISTINCR	16
X#define TRUE		1
X#define FALSE		0
X
X/*
X * The disk usage information is loaded into a tree structure.  Each node
X * of the tree is a (struct duentry), and corresponds to one component
X * in a pathname.  If the node represents a directory, its contents (both
X * files and subdirectories) will be stored in the "child[]" list.  The
X * disk usage at this entry will be saved into "size", or set to -1 if
X * no disk usage info exists at this entry.  Only those entries with a
X * nonnegative "size" value will be printed in the final report.
X */
Xstruct duentry {
X	char *name;				/* pathname component at this node			*/
X	long size;				/* usage size info, or -1 if not available	*/
X	struct duentry **child;	/* directory contents						*/
X	int ch_alloc;			/* allocated size of "child" array			*/
X	int ch_size;			/* number of elements used in "child" array	*/
X	short leading_slash;	/* is there a "/" before the name component	*/
X};
X
X/*
X * Only save off entries whose disk usage exceeds this threshold.
X */
Xlong Threshold;
X
X
Xstruct duentry *make_entry();	/* allocate a node to be placed in the tree	*/
Xstruct duentry *find_entry();	/* search directory for an entry			*/
Xstruct duentry *attach_entry();	/* add entry as child to current directory	*/
Xvoid sort_tree();				/* sort tree in descending order			*/
Xvoid print_tree();				/* pre-order traversal of the tree			*/
Xchar *xstrdup();
XPTRTYPE *xmalloc();
XPTRTYPE *xrealloc();
X
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	char buf[1024], *fname, *last_field, *bufp, *s;
X	int lineno, leading_slash, i;
X	long size;
X	struct duentry *du_root, *p, *p1;
X	extern int optind;
X	extern char *optarg;
X
X	/*
X	 * Initialize.
X	 */
X	Threshold = 0L;
X	du_root = make_entry("", FALSE);
X
X	/*
X	 * Crack command line.
X	 */
X	while ((i = getopt(argc, argv, "t:")) != EOF) {
X		switch (i) {
X		case 't':
X			if ((Threshold=atol(optarg)) <= 0L && strcmp(optarg, "0") != 0) {
X				fprintf(stderr, "%s: bad threshold value \"%s\"\n",
X					argv[0], optarg);
X				exit(1);
X			}
X			break;
X		default:
X			fprintf(stderr, USAGE, argv[0]);
X			exit(1);
X		}
X	}
X
X	/*
X	 * Figure out where input is coming from.
X	 */
X	switch (argc-optind) {
X	case 1:
X		fname = argv[optind];
X		if (freopen(fname, "r", stdin) == NULL) {
X			perror(fname);
X			exit(1);
X		}
X		break;
X	case 0:
X		/* read from stdin */
X		fname = "<stdin>";
X		break;
X	default:
X		fprintf(stderr, USAGE, argv[0]);
X		exit(1);
X	}
X
X	/*
X	 * Read in the input data.  It is expected to be in a format:
X	 *
X	 *		size   ....   pathname
X	 */
X	lineno = 0;
X	while (++lineno, fgets(buf, sizeof(buf), stdin) != NULL) {
X
X		/*
X		 * Break the line up into fields.  Save the first field as the size.
X		 */
X		s = NULL;
X		bufp = buf;
X		i = 0;
X		while (last_field = s, (s = strtok(bufp, " \t\n")) != NULL) {
X			bufp = NULL;
X			if (i++ == 0)
X				size = atol(s);
X		}
X		if (i < 2) {
X			fprintf(stderr, "%s(%d): line ignored\n", fname, lineno);
X			continue;
X		}
X
X		/*
X		 * Ignore this entry if it is smaller than what we want.
X		 */
X		if (size < Threshold)
X			continue;
X
X		/*
X		 * Break the pathname into components, and descend down
X		 * into the tree, creating nodes as required.
X		 */
X		leading_slash = (*last_field == '/');
X		p = du_root;
X		while ((s = strtok(last_field, "/")) != NULL) {
X			if ((p1 = find_entry(p, s)) == NULL)
X				p1 = attach_entry(p, make_entry(s, leading_slash));
X			last_field = NULL;
X			leading_slash = TRUE;
X			p = p1;
X		}
X
X		/*
X		 * Save disk usage for this entry in last component of the path.
X		 */
X		p->size = size;
X
X	}
X
X	/*
X	 * Sort and traverse the tree.
X	 */
X	sort_tree(du_root);
X	buf[0] = '\0';
X	print_tree(du_root, buf, buf, 0);
X
X	exit(0);
X	/*NOTREACHED*/
X}
X
X
X/*
X * Allocate a new node for the tree.
X */
Xstruct duentry *make_entry(name, leading_slash)
Xregister char *name;
Xint leading_slash;
X{
X	register struct duentry *p;
X	p = (struct duentry *) xmalloc(sizeof(struct duentry));
X	p->name = xstrdup(name);
X	p->size = -1L;
X	p->child = (struct duentry **) NULL;
X	p->ch_alloc = 0;
X	p->ch_size = 0;
X	p->leading_slash = (short) leading_slash;
X	return p;
X}
X
X
X/*
X * Search a directory entry for a member entry and return a pointer to
X * the located entry.  If not found, add this member to the directory.
X */
Xstruct duentry *find_entry(p, name)
Xregister struct duentry *p;
Xregister char *name;
X{
X	register int i;
X
X	for (i = 0 ; i < p->ch_size ; ++i) {
X		if (strcmp(name, p->child[i]->name) == 0)
X			return p->child[i];
X	}
X	return (struct duentry *) NULL;
X}
X
X
X/*
X * Add a new child at the current node.
X */
Xstruct duentry *attach_entry(p, pchild)
Xregister struct duentry *p, *pchild;
X{
X	if (p->ch_size >= p->ch_alloc) {
X		p->ch_alloc += LISTINCR;
X		p->child = (struct duentry **) xrealloc((PTRTYPE *)p->child,
X			p->ch_alloc*sizeof(struct duentry *));
X	}
X	p->child[p->ch_size++] = pchild;
X	return pchild;
X}
X
X
X/*
X * Recursively sort the tree so that the nodes in "child[]" are in
X * descending order by disk usage.  This is done as a selection sort.
X */
Xvoid sort_tree(p)
Xstruct duentry *p;
X{
X	int i, j, m;
X	long msize;
X	struct duentry *t;
X
X	/*
X	 * Selection sort.
X	 */
X	for (i = 0 ; i < p->ch_size ; ++i) {
X		/*
X		 * INVARIANT: child[0:i-1] is sorted in descending order.
X		 * child[x] > child[y] for all x < y && x < i.
X		 */
X		m = i;
X		msize = p->child[i]->size;
X		for (j = i+1 ; j < p->ch_size ; ++j) {
X			/*
X			 * INVARIANT: child[m] is the maximum in the range child[i:j-1]
X			 */
X			if (p->child[j]->size > msize) {
X				m = j;
X				msize = p->child[j]->size;
X			}
X		}
X		/*
X		 * RESULT: child[m] is the maximum in the range [i:ch_size-1]
X		 */
X		if (m != i) {
X			t = p->child[m];
X			p->child[m] = p->child[i];
X			p->child[i] = t;
X		}
X		/*
X		 * RESULT: child[0:i] is sorted,
X		 * child[x] > child[y] for all x < y && x < i+1.
X		 */
X		sort_tree(p->child[i]);
X	}
X}
X
X
X/*
X * Perform a preorder traversal of the tree to get a sorted report.
X */
Xvoid print_tree(p, buf, bufend, lvl)
Xstruct duentry *p;
Xchar *buf, *bufend;
Xint lvl;
X{
X	int i;
X	char *s;
X
X	/*
X	 * Append this entry to the pathname.
X	 */
X	if (p->leading_slash)
X		*bufend++ = '/';
X	for (s = p->name ; *s != '\0' ; )
X		*bufend++ = *s++;
X	*bufend = '\0';
X
X	/*
X	 * If there is a size at this entry then display it.
X	 */
X	if (p->size >= 0) {
X		printf("%ld\t%*s%s\n", p->size, INDENT*lvl, "",
X			(buf[0] == '\0' ? "/" : buf));
X		++lvl;
X	}
X
X	/*
X	 * Recurse into the children of this entry.
X	 */
X	for (i = 0 ; i < p->ch_size ; ++i)
X		print_tree(p->child[i], buf, bufend, lvl);
X}
X
X
Xstatic char malloc_error[] = "error - out of memory [malloc failed]\n";
X
Xchar *xstrdup(s)
Xregister char *s;
X{
X	register char *s1;
X	if ((s1 = (char *) malloc((unsigned)strlen(s)+1)) == NULL) {
X		fputs(malloc_error, stderr);
X		exit(1);
X	}
X	return strcpy(s1, s);
X}
X
XPTRTYPE *xmalloc(n)
Xregister unsigned n;
X{
X	register PTRTYPE *s;
X	if ((s = malloc(n)) == NULL) {
X		fputs(malloc_error, stderr);
X		exit(1);
X	}
X	return s;
X}
X
XPTRTYPE *xrealloc(s, n)
Xregister PTRTYPE *s;
Xregister unsigned n;
X{
X	if ((s = (s == NULL ? malloc(n) : realloc(s, n))) == NULL) {
X		fputs(malloc_error, stderr);
X		exit(1);
X	}
X	return s;
X}
X
END_OF_FILE
  if test 7653 -ne `wc -c <'dusort.c'`; then
    echo shar: \"'dusort.c'\" unpacked with wrong size!
  fi
  # end of 'dusort.c'
fi
if test -f 'ngsizes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ngsizes'\"
else
  echo shar: Extracting \"'ngsizes'\" \(6066 characters\)
  sed "s/^X//" >'ngsizes' <<'END_OF_FILE'
X: '@(#) ngsizes 1.7 93/08/18 00:09:10'
X#
X# ngsizes - Generate disk usage summary for USENET newsgroups.
X#
X# Copyright 1990-1993, Unicom Systems Development.  All rights reserved.
X# See accompanying README file for terms of distribution and use.
X#
X# Usage:
X#
X#   ngsizes [-D] [-b breakdown_list] [-t threshold]
X#
X#	-t  Specifies only groups using "threshold" or more disk blocks should
X#	    be reported.  The default is defined by the "threshold" parameter
X#	    below.
X#
X#	-b  Specifies how usage should be broken down versus age.  For example,
X#	    saying "-b 0,7,14" will report usage in three columns:  the total
X#	    usage, the usage by articles a week or older, and the usage by
X#	    articles two weeks or older.  The default is defined by the
X#	    "breakdown" parameter below.
X#
X#	-D  For debugging, the temporary files will be maintained.
X#
X
XUSAGE="usage: $0 [-b breakdown_list] [-t threshold]"
X
X
X##############################################################################
X#
X# Site-specific definitions.
X#
X
XSPOOLDIR=/usenet/spool/news	# Pathname to the Usenet spool directory.
XACTIVE=/usenet/lib/news/active	# Pathname to the list of active newsgroups.
XDU=du				# Pathname to the enhanced "du" command.
X
X#
X# Pick one of the following.  It specifies how to account for the disk
X# space used by cross-posted articles.
X#
XDU_LINKOPTS=-l	# Count xposted article every time it appears.
X#DU_LINKOPTS=	# Count xposted article only first time it is encountered.
X#DU_LINKOPTS=-L	# Average usage across newsgroups in which it appears.
X
X#
X# Pick one of the following.  It specifies how you want usage reported.
X#
XDU_BSIZE=-k	# Report usage in KB.
X#DU_BSIZE=	# Report usage however du normally does.
X
X#
X# Specify the default reporting threshold.  Newsgroups with usage below
X# this value will not be reported.  The units for this number depend upon
X# whatever you specified above for DU_BSIZE.  This default can be overridden
X# by the "-t" command line option.
X#
XDFLT_THRESHOLD=0
X
X#
X# Specify the default for the breakdown.  There will be one column in
X# the output for every number in the breakdown list.  Each value in the
X# list specifies a number of days, and the corresponding column will show
X# the disk usage by articles that are that many days or older.  This default
X# can be overridden by the "-b" command line option.
X#
XDFLT_BREAKDOWN=0,1,3,5,7,15
X
X#
X# Work Files:
X#	$TMP.read	Readership statistics.
X#	$TMP.ngs	List of all newsgroups to check.
X#	$TMP.du		Disk usage for all directories in the news spool dir.
X#
XTMP=/tmp/ngsz$$
Xtrap 'rm -f $TMP.* ; exit 1' 1 2 3
X
X#
X# End of site-specific customizations.
X#
X##############################################################################
X
X
X#
X# Initialize.
X#
Xdebug=0
Xthreshold=$DFLT_THRESHOLD
Xbreakdown=$DFLT_BREAKDOWN
X
X#
X# Crack the command line options.
X#
Xset -- `getopt 'Db:t:' $*`
Xif [ $? -ne 0 ] ; then
X	echo "$USAGE" 1>&2
X	exit 1
Xfi
Xwhile : ; do
X	case "$1" in
X	-D)  TMP=/tmp/ngsz debug=1 ; trap '' 1 2 3	; shift ;;
X	-b)  breakdown="$2"				; shift 2 ;;
X	-t)  threshold="$2"				; shift 2 ;;
X	--)  shift ; break ;;
X	*)   echo "$USAGE" 1>&2				; exit 1 ;;
X	esac
Xdone
Xif [ $# -ne 0 ] ; then
X	echo "$USAGE" 1>&2
X	exit 1
Xfi
X
X#
X# Verify we can find the active file.
X#
Xif [ ! -r $ACTIVE ] ; then
X	echo "$0: file '$ACTIVE' not found or unreadable" 1>&2
X	[ $debug -eq 0 ] && rm -f $TMP.*
X	exit 1
Xfi
X
X#
X# Get a count of the readers for each newsgroup.
X# Output format will be "readership_count newsgroup_name"
X#
Xfor newsrc in `awk -F: '{ print $6 "/.newsrc" }' /etc/passwd | sort -u` ; do
X	test -f $newsrc && sed -n 's/:.*//p' $newsrc
Xdone | sort | uniq -c > $TMP.read
X
X#
X# Build a sorted list of all known newsgroups from the active file.
X#
Xsed '
X	s/[ 	].*//
X	/^$/d
X' $ACTIVE | sort -u > $TMP.ngs
X
X#
X# Scan the spool directory for disk usage.  Convert the newsgroup pathname
X# to a newsgroup name, and move it to the first field on the line.
X# Output format will be "newsgroup_name usage usage ..."
X#
Xif [ $debug -ne 0 -a -f $TMP.du ] ; then
X	: suppress scan for debugging
Xelse
X	$DU -ir $DU_LINKOPTS $DU_BSIZE -c "$breakdown" $SPOOLDIR	\
X	| sed								\
X		-e 's/^\(.*\)	\([^	]*\)$/\2	\1/'		\
X		-e "s!$SPOOLDIR/!!"					\
X		-e "s!/!.!g"						\
X	| sort -u							\
X		> $TMP.du
Xfi
X
X#
X# Generate the report.
X#
X(
X	echo "BREAKDOWN $breakdown" | sed 's/,/ /g'
X	echo "THRESHOLD $threshold"
X	sed 's/^/READERS /' $TMP.read
X	join $TMP.du $TMP.ngs | sort -rn +1 | sed 's/^/NEWSGROUP /'
X) | awk '
X
XBEGIN {
X	LINE_WIDTH = 79		# maximum length of a line
X	NG_WIDTH = 26		# width of field to print newsgroup in
X	READR_WIDTH = 4		# width of field to print number of readers in
X	FRONT_FMT = "%-" NG_WIDTH "." NG_WIDTH "s" "%" READR_WIDTH "s"
X}
X
X#
X# Record "BREAKDOWN n1 n2 ..."
X#   Defines the format for the newsgroup usage lines.  Each "n" corresponds
X#   to one column in the newsgroup usage line, and specifies the age of
X#   articles which consume this amount of disk space.
X#
X$1 == "BREAKDOWN" {
X	num_breakdn = NF - 1
X	FIELD_WIDTH = ( LINE_WIDTH - (NG_WIDTH+READR_WIDTH) ) / num_breakdn
X	if ( FIELD_WIDTH > 8 )
X		FIELD_WIDTH = 8
X	FIELD_FMT = "%" FIELD_WIDTH "s"
X	printf(FRONT_FMT,"newsgroup","read")
X	for ( i = 0 ; i < num_breakdn ; ++i )
X		printf(FIELD_FMT,sprintf("%ddays",$(i+2)))
X	printf("\n")
X	next
X}
X
X#
X# Record "THRESHOLD n"
X#   Indicates we only want to see newsgroups using "n" or more blocks.
X#
X$1 == "THRESHOLD" {
X	threshold = $2
X	next
X}
X
X#
X# Record "READERS n ng"
X#   Indicates that newsgroup "ng" has "n" readers.
X#
X$1 == "READERS" {
X	num_readers[$3] = $2
X	next
X}
X
X#
X# Record "NEWSGROUP ng n1 n2 ..."
X#   Indicates the disk usage of newsgroup "ng".  Each "n" specifies the
X#   diskspace used by articles "ndays" or older, where "ndays" is defined
X#   by the BREAKDOWN record.
X#
X$1 == "NEWSGROUP" {
X	if ( $3 >= threshold ) {
X		if ( num_readers[$2] == "" )
X			num_readers[$2] = 0
X		printf(FRONT_FMT,$2,num_readers[$2])
X		for ( i = 0 ; i < num_breakdn ; ++i )
X			printf(FIELD_FMT,$(i+3))
X		printf("\n")
X	}
X	next
X}
X
X{
X	printf("ngsizes - bad line '%s'\n", $0) | "cat 1>&2"
X}
X
X'
X
X[ $debug -eq 0 ] && rm -f $TMP.*
Xexit 0
X
END_OF_FILE
  if test 6066 -ne `wc -c <'ngsizes'`; then
    echo shar: \"'ngsizes'\" unpacked with wrong size!
  fi
  # end of 'ngsizes'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
  echo shar: Extracting \"'patchlevel.h'\" \(70 characters\)
  sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/* @(#) patchlevel.h 1.13 93/08/18 00:09:11 */
X#define VERSION "2.0"
X
END_OF_FILE
  if test 70 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
  fi
  # end of 'patchlevel.h'
fi
if test -f 'stdlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stdlib.h'\"
else
  echo shar: Extracting \"'stdlib.h'\" \(462 characters\)
  sed "s/^X//" >'stdlib.h' <<'END_OF_FILE'
X
X/* @(#) stdlib.h 1.3 93/08/18 00:09:12 */
X
Xextern double	atof();
Xextern int	atoi();
Xextern long	atol();
Xextern double	strtod();
Xextern long	strtol();
Xextern int	rand();
Xextern void	srand();
Xextern void 	free();
Xextern void	abort();
Xextern void	exit();
Xextern char	*getenv();
Xextern int	system();
Xextern void	qsort();
Xextern int	abs();
Xextern long	labs();
Xextern PTRTYPE 	*calloc();
Xextern PTRTYPE 	*malloc();
Xextern PTRTYPE 	*realloc();
Xextern char	*bsearch();
END_OF_FILE
  if test 462 -ne `wc -c <'stdlib.h'`; then
    echo shar: \"'stdlib.h'\" unpacked with wrong size!
  fi
  # end of 'stdlib.h'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
