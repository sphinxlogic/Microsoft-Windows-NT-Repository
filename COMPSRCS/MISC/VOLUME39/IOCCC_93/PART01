Newsgroups: comp.sources.misc
From: chongo@toad.com (Landon Curt Noll)
Subject: v39i104:  ioccc.1993 - 1993 International Obfuscated C Code Contest winners, Part01/04
Message-ID: <csm-v39i104=ioccc.1993.122324@sparky.Sterling.COM>
X-Md4-Signature: fe403d217821bf7d08519da4ec7ec4c4
Keywords: ioccc
Sender: kent@sparky.sterling.com (Kent Landfield)
Reply-To: chongo@toad.com (Landon Curt Noll)
Organization: Nebula Consultants in San Francisco
Date: Sun, 26 Sep 1993 17:25:14 GMT
Approved: kent@sparky.sterling.com

Submitted-by: chongo@toad.com (Landon Curt Noll)
Posting-number: Volume 39, Issue 104
Archive-name: ioccc.1993/part01
Environment: C

Enclosed is the first of a 4 part shar file containing the winners of
the 1993 International Obfuscated C Code Contest.

We congratulate the winners for doing a fine job.  Their efforts and
feedback have resulted another good year for the contest.

We apologize to both the 1993 winners and to the net for the delay in
posting of these results.  We had extended discussions with several of
the contest winners that took some time to resolve.  In addition one
of us, Landon Curt Noll, became very busy running for City Council in
Sunnyvale California, USA.

Please note:  

    The 1994 contest will not open until early March 1994.  The rules
    are expected to be very similar to the 1993 rules, though the input
    format will change slightly.  Please wait for the 1994 rules to be
    posted before submitting 1994 entries.

If you find problems with some of the contest entries, or find typos
in our notes, please send ->PATCH FILES OR COMPLETE FILES<- containing 
the corrections to:

    judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges

chongo <Landon Curt Noll> /\cc/\        chongo@toad.com
Larry Bassel                            lab@sun.com

p.s. previous winners are available on ftp.uu.net via anonymous ftp
     under the directory pub/ioccc.  Any 'patches' to the 1993 winners
     will be deposited there in a few months.

=-=
 
  Send comments, questions, bugs to: 
 
     judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges
 
  You are strongly encouraged to read the new contest rules before
  sending any entries.  The rules, and sometimes the contest Email
  address itself, change over time.  Valid entries one year may
  be rejected in a later year due to changes in the rules.  The typical
  start date for contests is in early March.  Contest rules are normally not 
  finalized and posted until the beginning of the contest.  The typical closing
  date for contests are in early May.
 
  The contest rules are posted to comp.unix.wizards, comp.lang.c,
  misc.misc, alt.sources and comp.sources.d.  If you do not have access 
  to these groups, or if you missed the early March posting, you may 
  request a copy from the judges, via Email, at the address above.
 
  Copyright (c) 1993, Landon Curt Noll & Larry Bassel.
  All Rights Reserved.  Permission for personal, educational or non-profit
  use is granted provided this this copyright and notice are included in its
  entirety and remains unaltered.  All other uses must receive prior permission
  in writing from both Landon Curt Noll and Larry Bassel.
 
  Previous contest winners are available via anonymous ftp from
  ftp.uu.net under the directory /pub/ioccc.

---- Cut Here and unpack ----
#! /bin/sh
# This is ioccc.1993, a shell archive.  Remove anything before this line, 
# then feed it into a shell via "sh file" or similar.  To overwrite existing
# files, type "sh file -c".
#
# Contents:  1993 1993/ant.doc 1993/ejb.explain2 1993/jonth.hint
#   1993/mkentry.c
#
# Send comments, questions, bugs to: 
#
#    judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges
#
# You are strongly encouraged to read the new contest rules before
# sending any entries.  The rules, and sometimes the contest Email
# address itself, change over time.  Valid entries one year may
# be rejected in a later year due to changes in the rules.  The typical
# start date for contests is in early March.  Contest rules are normally not 
# finalized and posted until the beginning of the contest.  The typical closing 
# date for contests are in early May.
#
# The contest rules are posted to comp.unix.wizards, comp.lang.c,
# misc.misc, alt.sources and comp.sources.d.  If you do not have access 
# to these groups, or if you missed the early March posting, you may 
# request a copy from the judges, via Email, at the address above.
#
# Copyright (c) 1993, Landon Curt Noll & Larry Bassel.
# All Rights Reserved.  Permission for personal, educational or non-profit
# use is granted provided this this copyright and notice are included in its
# entirety and remains unaltered.  All other uses must receive prior permission
# in writing from both Landon Curt Noll and Larry Bassel.
#
# Previous contest winners are available via anonymous ftp from
# ftp.uu.net under the directory /pub/ioccc.
#
# Wrapped by kent@sparky on Sun Sep 26 12:05:11 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 4)."'
if test ! -d '1993' ; then
    echo shar: Creating directory \"'1993'\"
    mkdir '1993'
fi
if test -f '1993/ant.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ant.doc'\"
else
  echo shar: Extracting \"'1993/ant.doc'\" \(12274 characters\)
  sed "s/^X//" >'1993/ant.doc' <<'END_OF_FILE'
X0. NAME
X
X	ag		Anthony's Grep
X
X
X1. SYNOPSIS
X
X	ag <pattern> [file...]
X
X
X2. DESCRIPTION
X
XThe AG utility shall search input files, selecting lines matching a
Xpattern.  An input line shall be selected if the pattern, treated as a
Xsubset of Extended Regular Expressions as described by POSIX.2
XStandard section 2.8.4, matches any part of the line; a null pattern
Xshall match every line.  Each selected input line shall be written to
Xthe standard output.
X
XRegular expression matching shall be based on text lines, which are
Xseparated by a <newline> character.  A regular expression cannot
Xcontain a <newline> and there is no way for a pattern to match a
X<newline> found in the input.
X
X
X3. OPTIONS
X
XNone.
X
X
X4. OPERANDS
X
Xpattern         Specify one pattern to be used during the search for
X		input.  See Extended Regular Exprssions below on what
X		constitutes a valid pattern.
X
Xfile            A pathname of a file to be searched for the pattern.
X		If no file operands are specified or the file operand
X		is dash (-), the standard input shall be used.
X
X
X5. EXTERNINAL INFLUENCES
X
X5.1. STANDARD INPUT
X
XThe standard input shall be used only if no file operands are
Xspecifed.  See Input Files.
X
X
X5.2. INPUT FILES
X
XThe input files shall be text files.
X
X
X5.3. ENVIRONMENT VARIABLES
X
XNo environment variables are used.
X
X
X5.4. ASYNCHRONOUS EVENTS
X
XDefault.
X
X
X6. EXTERNAL EFFECTS
X
X6.1. STANDARD OUTPUT
X
XFor each selected input line from a file, a single output line shall
Xbe written:
X
X	"%s:%s\n", file, line
X
XStandard input will have the filename dash (-).
X
X
X6.2. STANDARD ERROR
X
XStandard error is used for diagnostic messages only.
X
X
X6.3. OUTPUT FILES
X
XNone.
X
X
X7. EXTENDED DESCRIPTION
X
X7.1. EXTENDED REGULAR EXPRESSIONS
X
X7.1.1. MATCHING A SINGLE CHARACTER
X
XAn ERE ordinary character, a special character preceded by a
Xbackslash, or a period shall match a single character.  A bracket
Xexpression shall match a single character.  An ERE matching a single
Xcharacter enclosed in parentheses shall match the same as the ERE
Xwithout parentheses would have matched.
X
X
X7.1.1.1. ERE ORDINARY CHARACTERS
X
XAn oridinary character is an ERE that matches itself.  An ordinary
Xcharacter is any character in the supported character set, except for
Xthe ERE special characters listed in 7.1.1.2.  The interpretation of
Xan ordinary character preceded by a backslash (\) is the ordinary
Xcharacter.
X
X
X7.1.1.2. ERE SPECIAL CHARACTERS
X
XAn ERE special character has special properties in certain contexts.
XOutside of those contexts, or when preceded by a backslash, such a
Xcharacter shall be an ERE that matches the special character itself.
XThe extended regular expression special characters and the contexts in
Xwhich they have their special meaning are:
X
X	. [ \ (         The period, left-bracket, backslash, and left-
X			parenthesis are special except when used in a
X			bracket expression.  Outside a bracket
X			expression, a left-parenthesis immediately
X			followed by a right-parenthesis will be
X			treated as a null expression.
X
X	)               The right-parenthesis is special when matched
X			with a preceding left-parenthesis, both
X			outside of a bracket expression.
X
X	* ?             The asterisk and question-mark are special
X			except when used in a bracket expression.
X			Results are undefined if this character
X			appears first in an ERE, or immediately
X			following a vertial-line, circumflex, or
X			left-parenthesis.
X
X	|               The vertical-line is special except when used
X			in a bracket expression.  A vertical-line
X			appearing first or last in an ERE or
X			immediately following a vertical-line or
X			left-parenthesis, or preceding a
X			right-parenthesis, produces a null expression.
X
X	^               The circumflex shall be special when used as
X			an anchor or, as the first character of a
X			bracket expression.
X
X	$               The dollar-sign shall be special when used as
X			an anchor.
X
X
X7.1.1.3 PERIODS IN ERE
X
XA period (.), when used outside of a bracket expression, is an ERE
Xthat shall match any character in the supported character set except
XNUL.
X
X7.1.2. ERE BRACKET EXPRESSION
X
XA bracket expression (an expression enclosed in square brackets, []),
Xis an ERE that matches a single character contained in the nonempty
Xset of characters represented by the bracket expression.
X
XThe following rules and definitions apply to bracket expressions:
X
X   1)   A bracket expression is either a matching list expression
X	or a nonmatching list expression.  It consists of one or more
X	characters and/or range expressions.  The right-bracket (])
X	shall lose its special meaning and represent itself in a
X	bracket expression if it occurs first in the list [after an
X	initial circumflex (^), if any].  Otherwise, it shall
X	terminate the bracket expression.  The special characters
X	period (.), asterisk (*), left-bracket ([), and backslash (\)
X	shall lose their special meaning within a bracket expression.
X
X   2)   A matching list expression specifies a list that shall match
X	any one of the expressions represented in the list.  The first
X	character of the list shall not be the circumflex.  For
X	example,  [abc]  is an ERE that matches any of a, b, or c.
X
X   3)   A nonmatching list expression begins with a circumflex (^),
X	and specifies a list that shall match any character except for
X	the expressions represented in the list after the leading
X	circumflex.  For example,  [^abc]  is an ERE that matches any
X	character except a, b, or c.  The circumflex shall have this
X	special meaning only when it occurs first in the list,
X	immediately following the left-bracket.
X
X   4)   A range expression represents the set of characters that
X	fall between two elements in the current collation sequence,
X	inclusive.  It shall be expressed as the starting point and
X	the ending point separated by a hyphen (-).
X
X	In the following, all examples assume the collation sequence
X	specified for the POSIX Locale (a.k.a ASCII Character Set),
X	unless another collation sequence is sepecifically defined
X	by the hardware.
X
X	The starting range point and the ending range point shall be a
X	collating element (character).  The ending range point shall
X	collate higher than the starting range point; otherwise the
X	expression shall be treated as invalid.
X
X	The interpretation of a range expression where the ending
X	range point is the starting range point of a subsequent range
X	expression is undefined.
X
X	The hyphen character shall be treated as itself if it occurs
X	first (after an initial ^, if any) or last in the list, or as
X	an ending range point in a range expression.  As examples, the
X	expressions  [-ac]  and  [ac-] are equivalent and match any of
X	the characters a, c, or -; the expressions  [^-ac]  and [^ac-]
X	are equivalent and match ant character except a, c, -; the
X	expression  [%--]  matches any of the characters between % and
X	- inclusive;  the expression  [--@]  matches any of the
X	characters between - and @ inclusive; and the expression
X	[a--@] is invalid, because the letter a follows the symbol -
X	in the POSIX Locale.
X
X
X7.1.3. ERE MATCHING MULTIPLE CHARACTERS
X
XThe following rules shall be used to construct EREs matching multiple
Xcharacters from EREs matching a single character:
X
X   1)   A concatenation of EREs shall match the concatenation of the
X	character sequences matched by each component of the ERE.  A
X	concatenation of EREs enclosed in parentheses shall match
X	whatever the concatenation without parentheses matches.  For
X	example, both the ERE cd and the ERE (cd) are matched by the
X	third and forth character of the string abcdefabcdef.
X
X   2)   When an ERE matching a single character, or a concatention of
X	EREs enclosed in parentheses is followed by the special
X	character asterisk (*), together with that asterisk it shall
X	match what zero or more consecutive occurences of the ERE
X	would match.  For example, the ERE b*c matches the first
X	character in the string cabbbcde, and the ERE b*cd matches the
X	third through seventh characters in the string
X	cabbbcdebbbbbbcdbc.  And, [ab]* and [ab][ab] are equivalent
X	when matching the string ab.
X
X    3)  When an ERE matching a single character or an ERE enclosed in
X	parentheses is followed by the special character question-mark
X	(?), together with that question mark it shall match what zero
X	or one consecutive occurences of the ERE would match.  For
X	example, the ERE b?c matches the second character in the
X	string acabbbcde.
X
XThe behaviour of multiple adjacent duplication symbols (*, ?) produces
Xundefined results.
X
X
X7.1.4. ERE ALTERATION
X
XTwo EREs separated by the special character vertical-line (|) shall
Xmatch a string that is matched by either.  For example, the ERE
Xa((bc)|d) matches the string abc and the string ad.  Single
Xcharacters, or expressions matching single characters, separated by
Xthe vertical-line and enclosed in parentheses, shall be treated as an
XERE matching a single character.
X
X
X7.1.5. ERE PRECEDENCE
X
XThe order of precedence shall be as shown in the table below, from 
Xhigh to low:
X
X	escaped characters			\<special character>
X	bracket expression			[ ]
X	grouping				( )
X	single-character-ERE duplication	* ?
X	concatenation
X	anchoring				^ $
X	alteration				|
X
XFor example, the ERE abba|cde matches either the string abba or the
Xstring cde (because concatenation has a higher order of precedence
Xthan alteration).
X
X
X7.1.6. ERE EXPRESSION ANCHORING
X
XAn ERE can be limited to matching strings that begin or end a line;
Xthis is called anchoring.  The circumflex and dollar-sign special
Xcharacters shall be considered ERE anchors in the following contexts:
X
X   1)   A circumflex (^) outside a bracket expression shall anchor
X	the (sub)expression it begins to the beginning of a string;
X	such a (sub)expression can match only a sequence starting at
X	the first character of a string.  For example, the EREs ^ab
X	and (^ab) match ab in the string abcdef, but fail to match in
X	the string cdefab, and the ERE a^b is valid, but can never
X	match because the character a prevents the expression ^b from
X	matching the first character of a string.
X
X   2)   A dollar-sign ($) outside a bracket expression shall anchor
X	the (sub)expression it ends to the end of a string; such a
X	(sub)expression can match only a sequence ending at the last
X	character of a string.  For example, the EREs ef$ and (ef$)
X	match ef in the string abcdef, but fail to match in the string
X	cdefab, and the ERE e$f is valid, but can never match because
X	the character f prevents the expression e$ from matching the
X	last character of a string.
X
X
X8. EXIT STATUS
X
XThe following exit codes will be returned:
X 
X	0	Successful match.
X	1	No match.
X	2	Usage error.
X	3	General error.
X
X
X9. INSTALLATION
X
XAG can be built on any system providing at least K&R C.  It has been 
Xtested on 
X
X	o  SunOS with GCC
X	o  ATARI Mega ST with Sozobon C
X	o  PC clone with Turbo C and WatCom C
X	o  Interactive UNIX System V/386 release 3.2
X
XFor most machines, the compile command line should be
X
X	cc -O -o ag ag.c
X
XPC class machines may require that medium or large memory model be used
Xand that ARRAY be set to 256.  For Watcom C the command line would be
X
X	wcl -ml -DARRAY=256 ag.c
X
XThe value ARRAY represents the size of the compiled pattern array and
Xthe size of the array used to record matched states.  The default
Xvalue choosen should handle most patterns.  ARRAY can be overridden on
Xthe command line with -DARRAY=nn, where 255 < nn < INT_MAX.
X
X
X10. REFERENCES
X
X[Aho86]	Aho, Sethi, and Ullman, "Compilers - Principles, Techniques,
X	and Tools", Addison-Wesley, 86, ISBN 0-201-10088-6, chapter 3
X
X[K&P81] Kernighan and Plauger, "Software Tools in Pascal".
X	Addison-Wesley, 81, ISBN 0-201-10342-7, chapter 5
X
X[Mil87]	Webb Miller, "A Software Tools Sampler", 
X	Prentice Hall, 87, ISBN 0-13-822305-X, chaper 4
X
X[POSIX]	POSIX.2 Standard, 2.8.4 Extended Regular Expressions, 4.28 Grep
X
X
X11. FILES
X
Xag.c		Obfuscated source
Xag.doc		Manual for AG
Xagag.c		Unobfuscated source
Xtest.mk		Makefile test driver for AG.
X
X
X12. BUGS
X
XThe expression (a*)* compiles but loops forever.
X
XThere is no check for trailing backslash (\) in the pattern.
X
XThere is no check for unbalanced brackets.  Omitting a closing bracket
Xwill generate a "Patern too long" error, which is not the real error.
X
X
X13. NOTICES
X
XPublic Domain 1992, 1993 by Anthony Howe.  No warranty.
X
X
END_OF_FILE
  if test 12274 -ne `wc -c <'1993/ant.doc'`; then
    echo shar: \"'1993/ant.doc'\" unpacked with wrong size!
  fi
  # end of '1993/ant.doc'
fi
if test -f '1993/ejb.explain2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ejb.explain2'\"
else
  echo shar: Extracting \"'1993/ejb.explain2'\" \(7258 characters\)
  sed "s/^X//" >'1993/ejb.explain2' <<'END_OF_FILE'
X    The Patience puzzle, probably of Chinese origin, consists of
X    an iron U-shaped piece and several rings that link around
X    it.  The physical shape of the puzzle is very difficult to
X    describe verbally, but here is an attempt.
X
X    This description of the puzzle is presented as a set of
X    instructions for constructing the puzzle.  Start with a flat
X    piece of iron about 15 centimeters long by about two
X    centimeters wide.  Drill six holes in the piece of iron.
X    Through each hole, place a rod.  The rod should have a
X    diameter slightly less than that of the hole so that it can
X    move freely.  One end of the rod is like the head of a nail
X    and is larger than the hole to prevent it from coming free.
X    The other end is looped around a metal ring with a diameter
X    of about five centimeters.  This completely prevents the
X    iron rod from separating from the base.  Each rod, in
X    addition to going through the iron base, goes through the
X    ring at the end of the rod to its right.  The only rod free
X    of this restriction is the rightmost rod.  What has been
X    described so far is one of the two components of the puzzle.
X
X    The other component is another iron rod shaped like a U.
X    the U is as long from the tips to the base as the original
X    piece of iron with the holes in it.  The ends of the U are
X    looped around another ring of about five centimeters in
X    diameter.  In the puzzle's initial configuration, the U is
X    placed through the rings so that it is held in place by the
X    iron rods.  Imagine starting with the U piece before the
X    iron loop is placed at the end.  Slide the legs of the U
X    through the loops so that the iron rods securing the loops
X    to the metal strip go up the center of the U.  Placing the
X    final ring at the ends of the U prevents it from coming out.
X    The object of the puzzle is to free the U-shaped piece from
X    the other piece.
X
X    The following illustration (sideways) shows a three-ring
X    case of this puzzle.  If you look carefully, you can see
X    that the first ring could be lifted over the edge of the U
X    and slid down through the center of the U, thereby freeing
X    the U from the first iron rod.  The second ring can also be
X    freed in the initial configuration since it is already over
X    the rod for the first ring.  The third ring cannot be moved,
X    however, since it is blocked by the iron rod two which the
X    first ring is attached.  If the first first is removed, then
X    the third ring is no longer blocked by the first ring's iron
X    rod and can be removed freely.  The second ring, however
X    cannot be moved if the first ring is gone because it will
X    then be blocked by the first ring in its new position
X    outside of the U.
X
X    Here is an illustration of the three-ring case.  The bottom
X    of the puzzle is on the left-hand side of the page.
X
X
X
X                               //==\\
X                              ||    ||
X                              ||    ||
X                         *****||**  ||
X                       ***    || ***||
X                       **     ||   *||
X          |\           **     ||    ||**
X          | \           ***   ||    ||  ***
X          |  \            ***  |    ||    ===
X          |   \             ***     ||  // * \\
X          |    \              ***   || || **  ||
X          |     |             | **********    ||
X          |     |             ||    || ||     ||
X          |     |             ||    || ||     ||
X          |     |        *****||**  ||  \\    ||
X       |  | |\  |      ***    || ***||        ||
X       |==| |=========-**-===-||-============//
X       |==| |=========-**-===-||-===========//
X       |  |  \| |       ***   ||    ||  ***
X          |     |         *** ||    ||    ===
X          |     |           ***|    ||  // * \\
X          |     |             ***   || || **  ||
X          |     |             ||**********    ||
X          |     |             ||    || ||     ||
X          |     |        *****||**  ||  \\    ||
X       |  | |\  |      ***    || ***||        ||
X       |==| |=========-**-===-||-============//
X       |==| |=========-**-===-||-===========//
X       |  |  \| |       ***   ||    ||  ***
X          |     |         *** ||    ||    ===
X          |     |           ***|    ||  // * \\
X          |     |             ***   || || **  ||
X          |     |             ||**********    ||
X          |     |             ||    || ||     ||
X          |     |             ||    || ||     ||
X       |  |     |             ||    ||  \\    ||
X       |  | |\  |             ||    ||        ||
X       |==| |================-||-============//
X       |==| |================-||-===========//
X       |  |  \| |             ||    ||
X          |     |             ||    ||
X          |     |             ||    ||
X          |     |             ||    ||
X          \     |             ||    ||
X           \    |              \\   ||
X            \   |               \\  ||
X             \  |                \\ ||
X              \ |                 \\||
X               \|                  \||
X
X    This puzzle takes other forms as well.  One such puzzle is
X    called "Spin-Out".  This puzzle consists of one plastic
X    piece that encases another piece that can slide in and out
X    of it.  The movement of the smaller piece is restricted by
X    discs that, when turned to one angle, lock the smaller piece
X    inside the larger one and, when turned the other way, allow
X    it to move.  This puzzle is as difficult to describe as the
X    first and, since I don't have one in front of me, I will not
X    attempt to describe it.  The object of this puzzle is to
X    free the smaller piece from the larger one.  The other
X    puzzle that is like this one consists of a cylinder with
X    rods protruding from the top.  The rods can be slid from the
X    center to the edge of the cylinder constrained by a series
X    of discs in the center.  The discs have cuts in them that
X    allow some rods to move and force others in one place based
X    on the relative rotations of the discs.  The object here is
X    to move all the rods from the inside to the outside.
X
X    What makes these puzzles similar is that the physical shapes
X    of the puzzles put the same restrictions on the movement of
X    the pieces.  Specifically, there is always one piece that is
X    free to move.  The only other piece that is free to move is
X    the second one that is still attached to the base it is
X    trying to be freed from.  In the case of the original
X    puzzle, consider the rings numbered from 1 to 6 with ring 1
X    being the one at the closed send of the U.  Ring 1 can
X    always be removed from or added to the U.  In the initial
X    state, when all rings are around the U, ring 2 is the other
X    one that can be moved because it is second.  If ring 1 is
X    removed, then only two operations are possible: the
X    restoration of ring 1 and the removal of ring 3.  This is
X    because ring 1 is always movable, and ring 3 is currently
X    the second ring still attached to the U.  This constraint
X    leads to a recursive solution to the puzzle.  Like the
X    Towers of Hanoi, the number of steps to solve this puzzle is
X    exponential in the number of rings.
END_OF_FILE
  if test 7258 -ne `wc -c <'1993/ejb.explain2'`; then
    echo shar: \"'1993/ejb.explain2'\" unpacked with wrong size!
  fi
  # end of '1993/ejb.explain2'
fi
if test -f '1993/jonth.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/jonth.hint'\"
else
  echo shar: Extracting \"'1993/jonth.hint'\" \(844 characters\)
  sed "s/^X//" >'1993/jonth.hint' <<'END_OF_FILE'
XMost Obfuscated X Program: <jonth@ifi.uio.no> Jon Thingvold
X
X	Jon Thingvold
X	University of Oslo
X	Sogn Studentby 8231
X	N 0858 Oslo
X	Norway
X
X
XJudges' comments:
X
X    To use:
X	make jonth		# requires the X11 library
X	./jonth			# must be run on an X11 server
X
X    Use 'h' and 'l' to shift objects left or right.  Use 'k' to
X    rotate and press SPACE to drop.
X
X    This program's output may be even more obfuscated when played 
X    on inverse video.  :-)
X
X
XSelected notes from the author:
X
X    This is jonth (jon's t(h)etris) for the X Window System.
X
X    This program is also an example of data abstraction.  The X array is 
X    after initialization hidden by the well defined macros t, u and F.
X
X    This program is highly portable as it runs on a "Notebook" size SPARC.
X    This program will not work on machines with sizeof(int)!=sizeof(void *).
END_OF_FILE
  if test 844 -ne `wc -c <'1993/jonth.hint'`; then
    echo shar: \"'1993/jonth.hint'\" unpacked with wrong size!
  fi
  # end of '1993/jonth.hint'
fi
if test -f '1993/mkentry.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/mkentry.c'\"
else
  echo shar: Extracting \"'1993/mkentry.c'\" \(34486 characters\)
  sed "s/^X//" >'1993/mkentry.c' <<'END_OF_FILE'
X/* @(#)mkentry.c	1.25 4/5/93 15:58:08 */
X/*
X * Copyright (c) Landon Curt Noll & Larry Bassel, 1993.
X * All Rights Reserved.  Permission for personal, educational or non-profit 
X * use is granted provided this this copyright and notice are included in 
X * its entirety and remains unaltered.  All other uses must receive prior
X * permission in writing from both Landon Curt Noll and Larry Bassel.
X */
X/*
X * mkentry - make an International Obfuscated C Code Contest entry
X *
X * usage:
X *	mkentry -r remarks -b build -p prog.c -o ioccc.entry
X *
X *	-r remarks		file with remarks about the entry
X *	-b build		file containing how prog.c should be built
X *	-p prog.c		the obfuscated program source file
X *	-o ioccc.entry		ioccc entry output file
X *
X * compile by:
X *	cc mkentry.c -o mkentry
X */
X/*
X * Placed in the public domain by Landon Curt Noll, 1992.
X *
X * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X */
X/*
X * WARNING:
X *
X * This program attempts to implement the IOCCC rules.  Every attempt
X * has been made to make sure that this program produces an entry that
X * conforms to the contest rules.  In all cases, where this program
X * differs from the contest rules, the contest rules will be used.  Be
X * sure to check with the contest rules before submitting an entry.
X *
X * FOR MORE INFORMATION:
X *
X *   You may contact the judges by sending Email to the following address:
X *
X *	...!{apple,pyramid,sun,uunet}!hoptoad!judges	(not the address for
X *	judges@toad.com					 submitting entries)
X *
X *   Questions and comments about the contest are welcome.
X *
X *  The rules and the guidelines may (and often do) change from year to
X *  year.  You should be sure you have the current rules and guidelines
X *  prior to submitting entries.  To obtain them, send Email to the address
X *  above and use the subject 'send rules'.
X *
X *  One may obtain winners of previous contests (1984 to date), via ftp from:
X *
X *	host: ftp.uu.net	(192.48.96.9)
X *	user: anonymous
X *	pass: yourname@yourhost
X *	dir:  ~/pub/ioccc
X *
X *  As a last resort, previous winners may be obtained by sending Email
X *  to the above address.  Please use the subject 'send YEAR winners',
X *  where YEAR is a single 4 digit year, a year range, or 'all'.
X *
X * Because contest rules change from year to year, one should only use this
X * program for the year that it was intended.  Be sure that the RULE_YEAR
X * define below matches this current year.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <time.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X
X/* logic */
X#ifndef TRUE
X# define TRUE 1
X#endif /* TRUE */
X#ifndef FALSE
X# define FALSE 0
X#endif /* FALSE */
X#define EOF_OK TRUE
X#define EOF_NOT_OK FALSE
X
X/* global limits */
X#define RULE_YEAR 1993		/* NOTE: should match the current year */
X#define START_DATE "1Mar92 0:00 UTC"	/* first confirmation received */
X#define MAX_COL 79		/* max column a line should hit */
X#define MAX_BUILD_SIZE 256	/* max how to build size */
X#define MAX_PROGRAM_SIZE 3217	/* max program source size */
X#define MAX_PROGRAM_SIZE2 1536	/* max program source size not counting
X				   whitespace and {}; not followed by
X				   whitespace or EOF */
X#define MAX_TITLE_LEN 12	/* max chars in the title */
X#define MAX_ENTRY_LEN 1		/* max length in the entry input line */
X#define MAX_ENTRY 8		/* max number of entries per person per year */
X#define MAX_FILE_LEN 1024	/* max filename length for a info file */
X
X/* where to send entries */
X#define ENTRY_ADDR1 "...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate"
X#define ENTRY_ADDR2 "obfuscate@toad.com"
X
X/* uuencode process - assumes ASCII */
X#define UUENCODE(c) (encode_str[(int)(c)&0xff])
X#define UUENCODE_LEN 45		/* max uuencode chunk size */
X#define UUINFO_MODE 0444	/* mode of an info file's uuencode file */
X#define UUBUILD_MODE 0444	/* mode of the build file's uuencode file */
X#define UUBUILD_NAME "build"	/* name for the build file's uuencode file */
X#define UUPROG_MODE 0444	/* mode of the program's uuencode file */
X#define UUPROG_NAME "prog.c"	/* name for the program's uuencode file */
X
X/* encode_str[(char)val] is the uuencoded character of val */
Xchar encode_str[256+1] = "`!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_";
X
X/* global declarations */
Xchar *program;			/* our name */
Xlong start_time;		/* the startup time */
X
X/* forward declarations */
Xvoid parse_args();
Xvoid usage();
XFILE *open_remark();
XFILE *open_build();
XFILE *open_program();
XFILE *open_output();
Xvoid output_entry();
Xvoid output_remark();
Xvoid output_author();
Xvoid output_info();
Xvoid output_build();
Xvoid output_program();
Xvoid output_end();
Xint get_line();
Xvoid output_till_dot();
Xint col_len();
Xvoid check_io();
Xvoid uuencode();
X
Xmain(argc, argv)
X    int argc;		/* arg count */
X    char **argv;	/* the args */
X{
X    FILE *remark=NULL;	/* open remarks stream */
X    FILE *build=NULL;	/* open build file stream */
X    FILE *prog=NULL;	/* open program stream */
X    FILE *output=NULL;	/* open output stream */
X    char *rname=NULL;	/* file with remarks about the entry */
X    char *bname=NULL;	/* file containing how prog.c should be built */
X    char *pname=NULL;	/* the obfuscated program source file */
X    char *oname=NULL;	/* ioccc entry output file */
X    struct tm *tm;	/* startup time structure */
X
X    /*
X     * check on the year
X     */
X    start_time = time((long *)0);
X    tm = gmtime(&start_time);
X    if (tm->tm_year != RULE_YEAR-1900) {
X	fprintf(stderr,
X	"%s: WARNING: this program applies to %d, which may differ from %d\n\n",
X	    argv[0], RULE_YEAR, 1900+tm->tm_year);
X    }
X
X    /*
X     * parse the command line args
X     */
X    parse_args(argc, argv, &rname, &bname, &pname, &oname);
X
X    /*
X     * open/check the input and output files
X     *
X     * We open and truncate the output file first, in case it is the same
X     * as one of the input files.
X     */
X    output = open_output(oname);
X    remark = open_remark(rname);
X    build = open_build(bname);
X    prog = open_program(pname);
X    if (output==NULL || remark==NULL || build==NULL || prog==NULL) {
X	exit(1);
X    }
X
X    /*
X     * output each section
X     */
X    output_entry(output, oname);
X    output_remark(output, oname, remark, rname);
X    output_author(output, oname);
X    output_info(output, oname);
X    output_build(output, oname, build, bname);
X    output_program(output, oname, prog, pname);
X    output_end(output, oname);
X
X    /*
X     * flush the output
X     */
X    if (fflush(output) == EOF) {
X	fprintf(stderr, "%s: flush error in %s: ", program, oname);
X	perror("");
X	exit(2);
X    }
X
X    /*
X     * final words
X     */
X    printf("\nYour entry can be found in %s.  You should check this file\n",
X	oname);
X    printf("correct any problems and verify that the uudecode utility will\n");
X    printf("correctly decode your build file and program.\n\n");
X    printf("This program has been provided as a guide for submitters.  In\n");
X    printf("cases where it conflicts with the rules, the rules shall apply.\n");
X    printf("It is your responsibility to ensure that your entry conforms to\n");
X    printf("the current rules.\n\n");
X    printf("Email your entries to:\n");
X    printf("\t%s\n", ENTRY_ADDR1);
X    printf("\t%s\n\n", ENTRY_ADDR2);
X    printf("Please use the following subject when you Email your entry:\n");
X    printf("\tioccc entry\n\n");
X    /* all done */
X    exit(0);
X}
X
X/*
X * parse_args - parse the command line args
X *
X * Given the command line args, this function parses them and sets the
X * required name flags.  This function will return only if the command
X * line syntax is correct.
X */
Xvoid
Xparse_args(argc, argv, rname, bname, pname, oname)
X    int argc;		/* arg count */
X    char **argv;	/* the args */
X    char **rname;	/* file with remarks about the entry */
X    char **bname;	/* file containing how prog.c should be built */
X    char **pname;	/* the obfuscated program source file */
X    char **oname;	/* ioccc entry output file */
X{
X    char *optarg;	/* -flag option operand */
X    int flagname;	/* the name of the -flag */
X    int i;
X
X    /*
X     * Not everyone has getopt, so we must parse args by hand.
X     */
X    program = argv[0];
X    for (i=1; i < argc; ++i) {
X
X	/* determine the flagname */
X	if (argv[i][0] != '-') {
X	    usage(1);
X	    /*NOTREACHED*/
X	}
X	flagname = (int)argv[i][1];
X
X	/* determine the flag's operand */
X	if (flagname != '\0' && argv[i][2] != '\0') {
X	    optarg = &argv[i][2];
X	} else {
X	    if (i+1 >= argc) {
X		usage(2);
X		/*NOTREACHED*/
X	    } else {
X		optarg = argv[++i];
X	    }
X	}
X
X	/* save the flag's operand in the correct global variable */
X	switch (flagname) {
X	case 'r':
X	    *rname = optarg;
X	    break;
X	case 'b':
X	    *bname = optarg;
X	    break;
X	case 'p':
X	    *pname = optarg;
X	    break;
X	case 'o':
X	    *oname = optarg;
X	    break;
X	default:
X	    usage(3);
X	    /*NOTREACHED*/
X	}
X    }
X
X    /*
X     * verify that we have all of the required flags
X     */
X    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) {
X	usage(4);
X	/*NOTREACHED*/
X    }
X    return;
X}
X
X/*
X * usage - print a usage message and exit
X *
X * This function does not return.
X */
Xvoid
Xusage(exitval)
X    int exitval;		/* exit with this value */
X{
X    fprintf(stderr,
X	"usage: %s -r remarks -b build -p prog.c -o ioccc.entry\n\n", program);
X    fprintf(stderr, "\t-r remarks\tfile with remarks about the entry\n");
X    fprintf(stderr, "\t-b build\tfile containing how prog.c should be built\n");
X    fprintf(stderr, "\t-p prog.c\tthe obfuscated program source file\n");
X    fprintf(stderr, "\t-o ioccc.entry\tioccc entry output file\n");
X    exit(exitval);
X}
X
X/*
X * open_remark - open/check the remark file
X *
X * The remark file should be indented by 4 spaces, and should not extend
X * beyond column MAX_COL.  These are not requirements, so we only warn.
X *
X * This function returns NULL on I/O or format error.
X */
XFILE *
Xopen_remark(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    char buf[BUFSIZ+1];		/* input buffer */
X    int toolong=0;		/* number of lines that are too long */
X    int non_indent=0;		/* number of lines not indented by 4 spaces */
X
X    /*
X     * open the remark input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open remark file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X
X    /*
X     * look at each line
X     */
X    while (fgets(buf, BUFSIZ, stream) != NULL) {
X
X	/* count lines that do not start with 4 spaces */
X	if (buf[0] != '\n' && strncmp(buf, "    ", 4) != 0) {
X	    ++non_indent;
X	}
X
X	/* count long lines */
X	if (col_len(buf) > MAX_COL) {
X	    /* found a line that is too long */
X	    ++toolong;
X	}
X    }
X
X    /* watch for I/O errors */
X    check_io(stream, filename, EOF_OK);
X
X    /* note long lines if needed */
X    if (toolong > 0) {
X	fprintf(stderr,
X	    "%s: WARNING: %d line(s) from %s extend beyond the 80th column\n",
X	    program, toolong, filename);
X	fprintf(stderr,
X	    "%s:          This is ok, but it would be nice to avoid\n\n",
X	    program);
X    }
X
X    /* note non-indented lines, if needed */
X    if (non_indent > 0) {
X	fprintf(stderr,
X	    "%s: WARNING: %d line(s) from %s are not indented by 4 spaces\n",
X	    program, non_indent, filename);
X	fprintf(stderr,
X	    "%s:          This is ok, but it would be nice to avoid\n\n",
X	    program);
X    }
X
X    /* return the open file */
X    rewind(stream);
X    return(stream);
X}
X
X/*
X * open_build - open/check the build file
X *
X * The how to build file must not be longer than MAX_BUILD_SIZE bytes.
X *
X * This function returns NULL on I/O or size error.
X */
XFILE *
Xopen_build(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    struct stat statbuf;	/* the status of the open file */
X
X    /*
X     * open the how to build input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open how to build file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X
X    /*
X     * determine the size of the file
X     */
X    if (fstat(fileno(stream), &statbuf) < 0) {
X	fprintf(stderr, "%s: cannot stat how to build file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X    if (statbuf.st_size > MAX_BUILD_SIZE) {
X	fprintf(stderr,
X	    "%s: FATAL: the how to build file: %s, is %d bytes long\n",
X	    program, filename, statbuf.st_size);
X	fprintf(stderr,
X	    "%s:        it may not be longer than %d bytes\n",
X	    program, MAX_BUILD_SIZE);
X	return(NULL);
X    }
X
X    /* return the open file */
X    return(stream);
X}
X
X/*
X * open_program - open/check the program source file
X *
X * The program source file must be <= 3217 bytes.  The number of
X * non-whitespace and }{; chars not followed by whitespace must
X * be <= 1536 bytes.
X *
X * This function returns NULL on I/O or size error.
X */
XFILE *
Xopen_program(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X    struct stat statbuf;	/* the status of the open file */
X    int count;			/* special count size */
X    int c;			/* the character read */
X
X    /*
X     * open the program source input file
X     */
X    stream = fopen(filename, "r");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open program source file: %s: ",
X	    program, filename);
X	perror("");
X	exit(7);
X    }
X
X    /*
X     * determine the size of the file
X     */
X    if (fstat(fileno(stream), &statbuf) < 0) {
X	fprintf(stderr, "%s: cannot stat program source file: %s: ",
X	    program, filename);
X	perror("");
X	return(NULL);
X    }
X    if (statbuf.st_size > MAX_PROGRAM_SIZE) {
X	fprintf(stderr,
X	    "%s: FATAL: the program source file: %s, is %d bytes long\n",
X	    program, filename, statbuf.st_size);
X	fprintf(stderr,
X	    "%s:        it may not be longer than %d bytes\n",
X	    program, MAX_PROGRAM_SIZE);
X	return(NULL);
X    }
X
X    /*
X     * count the non-whitespace, non {}; followed by whitespace chars
X     */
X    count = 0;
X    c = 0;
X    while ((c=fgetc(stream)) != EOF) {
X	/* look at non-whitespace */
X	if (!isascii(c) || !isspace(c)) {
X	    switch (c) {
X	    case '{':		/* count if not followed by EOF or whitespace */
X	    case '}':
X	    case ';':
X		/* peek at next char */
X		c = fgetc(stream);
X		if (c != EOF && isascii(c) && !isspace(c)) {
X		    /* not followed by whitespace or EOF, count it */
X		    ungetc(c, stream);
X		    ++count;
X		}
X		break;
X	    default:
X		++count;
X		break;
X	    }
X	}
X    }
X
X    /* watch for I/O errors */
X    check_io(stream, filename, EOF_OK);
X
X    /* look at the special size */
X    if (count > MAX_PROGRAM_SIZE2) {
X	fprintf(stderr,
X	    "%s: FATAL: the number of bytes that are non-whitespace, and\n",
X	    program);
X	fprintf(stderr,
X	    "%s:        that are not '{', '}', ';' followed by whitespace\n",
X	    program);
X	fprintf(stderr,
X	    "%s:        or EOF must be <= %d bytes\n",
X	    program, MAX_PROGRAM_SIZE2);
X	fprintf(stderr,
X	    "%s:        in %s, %d bytes were found\n",
X	    program, filename, count);
X	return(NULL);
X    }
X
X    /* return the open file */
X    rewind(stream);
X    return(stream);
X}
X
X/*
X * open_output - open/check the entry output file
X *
X * This function returns NULL on open error.
X */
XFILE *
Xopen_output(filename)
X    char *filename;
X{
X    FILE *stream;		/* the opened file stream */
X
X    /*
X     * open the ioccc entry output file
X     */
X    stream = fopen(filename, "w");
X    if (stream == NULL) {
X	fprintf(stderr, "%s: cannot open ioccc entry file for output: %s: ",
X	    program, filename);
X	perror("");
X	exit(8);
X    }
X
X    /* return the open file */
X    return(stream);
X}
X
X/*
X * output_entry - output the ---entry--- section
X *
X * Read the needed information form stdin, and write the entry section.
X */
Xvoid
Xoutput_entry(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char title[MAX_TITLE_LEN+1+1];	/* the entry's title */
X    char buf[MAX_COL+1+1];		/* I/O buffer */
X    int entry=0;			/* entry number */
X    int ret;				/* fields processed by fscanf */
X    int ok_line=0;			/* 0 => the line is not ok */
X    char skip;				/* input to skip */
X    FILE *date_pipe;			/* pipe to a date command */
X    time_t epoch_sec;			/* seconds since the epoch */
X    char *p;
X
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---entry---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the rule year
X     */
X    fprintf(output, "rule:\t%d\n", RULE_YEAR);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /* determine if this is a fix */
X    printf("Is this a fix, update or resubmittion to a ");
X    printf("previous entry (enter y or n)? ");
X    while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	printf("\nplease answer y or n: ");
X    }
X    if (buf[0] == 'y') {
X	fprintf(output, "fix:\ty\n");
X	check_io(output, oname, EOF_NOT_OK);
X	printf("\nBe sure that the title and entry number that you give\n");
X	printf("are the same of as the entry you are replacing\n");
X    } else {
X	fprintf(output, "fix:\tn\n");
X	check_io(output, oname, EOF_NOT_OK);
X    }
X
X    /*
X     * write the title
X     */
X    printf("\nYour title must match expression be a [a-zA-Z0-9_=] character\n");
X    printf("followed by 0 to %d more [a-zA-Z0-9_=+-] characters.\n\n",
X	MAX_TITLE_LEN-1);
X    printf("It is suggested, but not required, that the title should\n");
X    printf("incorporate your username; in the\n");
X    printf("case of multiple authors, consider using parts of the usernames\n");
X    printf("of the authors.\n\n");
X    printf("enter your title: ");
X    do {
X	/* prompt and read a line */
X	if ((ok_line = get_line(title, MAX_TITLE_LEN+1, MAX_COL-9)) <= 0) {
X	    printf("\ntitle is too long, please re-enter: ");
X	    continue;
X	}
X
X	/* verify the pattern, not everyone has regexp, so do it by hand */
X	if (!isascii((int)title[0]) ||
X	    !(isalnum((int)title[0]) || title[0] == '_' || title[0] == '=')) {
X	    printf("\ninvalid first character in the title\n\n");
X	    printf("enter your title: ");
X	    ok_line = 0;
X	} else {
X	    for (p=(&title[1]); *p != '\0' && *p != '\n'; ++p) {
X		if (!isascii((int)*p) ||
X		    !(isalnum((int)*p) ||
X		      *p == '_' || *p == '=' || *p == '+' || *p == '-')) {
X		    printf("\ninvalid character in the title\n\n");
X		    printf("enter your title: ");
X		    ok_line = 0;
X		}
X	    }
X	}
X    } while (ok_line <= 0);
X    fprintf(output, "title:\t%s", title);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the entry number
X     */
X    printf("\nEach person may submit up to %d entries per year.\n\n",
X	MAX_ENTRY);
X    printf("enter an entry number from 0 to %d inclusive: ", MAX_ENTRY-1);
X    do {
X	/* get a valid input line */
X	fflush(stdout);
X	ret = fscanf(stdin, "%d[\n]", &entry);
X	check_io(stdin, "stdin", EOF_NOT_OK);
X	/* skip over input until newline is found */
X	do {
X	    skip = fgetc(stdin);
X	    check_io(stdin, "stdin", EOF_NOT_OK);
X	    if (skip != '\n') {
X		/* bad text in input, invalidate entry number */
X		entry = -1;
X	    }
X	} while (skip != '\n');
X
X	/* check if we have a number, and if it is in range */
X	if (ret != 1 || entry < 0 || entry > MAX_ENTRY-1) {
X	    printf(
X	      "\nThe entry number must be between 0 and %d inclusive\n\n",
X		MAX_ENTRY-1);
X	    printf("enter the entry number: ");
X	}
X    } while (ret != 1 || entry < 0 || entry > MAX_ENTRY-1);
X    fprintf(output, "entry:\t%d\n", entry);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the submission date
X     */
X    /* returns a newline */
X    epoch_sec = time(NULL);
X    fprintf(output, "date:\t%s", asctime(gmtime(&epoch_sec)));
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * write the OS/machine host information
X     */
X    printf(
X      "\nEnter the machine(s) and OS(s) under which your entry was tested.\n");
X    output_till_dot(output, oname, "host:");
X}
X
X/*
X * output_remark - output the ---remark--- section
X *
X * Read the needed information form stdin, and write the entry section.
X */
Xvoid
Xoutput_remark(output, oname, remark, rname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *remark;		/* stream to the file containing remark text */
X    char *rname;		/* name of the remark file */
X{
X    char buf[BUFSIZ+1];		/* input/output buffer */
X
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---remark---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * copy the remark file to the section
X     */
X    while (fgets(buf, BUFSIZ, remark) != NULL) {
X	fputs(buf, output);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X    check_io(remark, rname, EOF_OK);
X
X    /* be sure that the remark section ends with a newline */
X    if (buf[strlen(buf)-1] != '\n') {
X	fputc('\n', output);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X}
X
X/*
X * output_author - output the ---author--- section
X *
X * Read the needed information from stdin, and write the author section.
X * If multiple authors exist, multiple author sections will be written.
X */
Xvoid
Xoutput_author(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char buf[MAX_COL+1+1];	/* I/O buffer */
X    int more_auths;		/* TRUE => more authors to note */
X    int auth_cnt=0;		/* number of authors processed */
X
X    /*
X     * prompt the user for the author section
X     */
X    printf("\nEnter information about each author.  If your entry is after\n");
X    printf("%s and before the contest deadline, the judges\n", START_DATE);
X    printf("will attempt to Email back a confirmation to the first author\n");
X
X    /*
X     * place author information for each author in an individual section
X     */
X    do {
X
X	/* write the start of the section */
X	fprintf(output, "---author---\n");
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the author */
X	printf("\nAuthor #%d name: ", ++auth_cnt);
X	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
X	    printf("\nname too long, please re-enter: ");
X	}
X	fprintf(output, "name:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the organization */
X	printf("\nEnter the School/Company/Organization of author #%d\n",
X	    auth_cnt);
X	printf("\nAuthor #%d org: ", auth_cnt);
X	while (get_line(buf, MAX_COL+1, MAX_COL-9) <= 0) {
X	    printf("\nline too long, please re-enter: ");
X	}
X	fprintf(output, "org:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* write the address */
X	printf(
X	    "\nEnter the postal address for author #%d.  Be sure to include\n",
X	    auth_cnt);
X	printf("your country and do not include your name.\n");
X	output_till_dot(output, oname, "addr:");
X
X	/* write the Email address */
X	printf(
X	    "\nEnter the Email address for author #%d.  Use an address from\n",
X	    auth_cnt);
X	printf(
X	    "a registered domain or well known site.  If you give several\n");
X	printf("forms, list them one per line.\n");
X	output_till_dot(output, oname, "email:");
X
X	/* write the anonymous status */
X	printf("\nShould author #%d remain anonymous (enter y or n)? ",
X	    auth_cnt);
X	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X	fprintf(output, "anon:\t%s", buf);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* determine if there is another author */
X	printf("\nIs there another author (enter y or n)? ");
X	while (get_line(buf, 1+1, 0) <= 0 || !(buf[0]=='y' || buf[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X	if (buf[0] == 'y') {
X	    more_auths = TRUE;
X	} else {
X	    more_auths = FALSE;
X	}
X    } while (more_auths == TRUE);
X    return;
X}
X
X/*
X * output_info - output the ---info--- section(s)
X *
X * Read the needed information from stdin, and write the info section.
X * If multiple info files exist, multiple info sections will be written.
X */
Xvoid
Xoutput_info(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    char infoname[MAX_FILE_LEN+1];	/* filename buffer */
X    char yorn[1+1];		/* y or n answer */
X    char *uuname;		/* name to uuencode as */
X    FILE *infile;		/* info file stream */
X
X    /*
X     * prompt the user for info information
X     */
X    printf("\nInfo files should be used only to supplement your entry.\n");
X    printf("For example, info files may provide sample input or detailed\n");
X    printf("information about your entry.  Because they are supplemental,\n");
X    printf("the entry should not require them to exist.\n\n");
X
X    /*
X     * while there is another info file to save, uuencode it
X     */
X    printf("Do you have a info file to include (enter y or n)? ");
X    while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
X	printf("\nplease answer y or n: ");
X    }
X    while (yorn[0] == 'y') {
X
X	/* read the filename */
X	printf("\nEnter the info filename: ");
X	while (get_line(infoname, MAX_FILE_LEN+1, 0) <= 0) {
X	    printf("\nInfo filename too long, please re-enter: ");
X	}
X
X	/* compute the basename of the info filename */
X	/* remove the trailing newline */
X	uuname = &infoname[strlen(infoname)-1];
X	*uuname = '\0';
X	/* avoid rindex/shrrchr compat issues, do it by hand */
X	for (--uuname; uuname > infoname; --uuname) {
X	    if (*uuname == '/') {
X		++uuname;
X		break;
X	    }
X	}
X
X	/* attempt to open the info file */
X	infile = fopen(infoname, "r");
X	if (infile == NULL) {
X	    fprintf(stderr, "\n%s: cannot open info file: %s: ",
X		program, infoname);
X	    perror("");
X	    continue;
X	}
X
X	/*
X	 * write the start of the section
X	 */
X	fprintf(output, "---info---\n");
X	check_io(output, oname, EOF_NOT_OK);
X
X	/* uuencode the info file */
X	uuencode(output, oname, infile, infoname, UUINFO_MODE, uuname);
X
X	printf("\nDo you have another info file to include (enter y or n)? ");
X	while (get_line(yorn, 1+1, 0) <= 0 || !(yorn[0]=='y' || yorn[0]=='n')) {
X	    printf("\nplease answer y or n: ");
X	}
X    };
X    return;
X}
X
X/*
X * output_build - output the ---build--- section
X *
X * Read the needed information from stdin, and write the build section.
X */
Xvoid
Xoutput_build(output, oname, build, bname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *build;		/* open build file stream */
X    char *bname;		/* name of the build file */
X{
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---build---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * uuencode the program file
X     */
X    uuencode(output, oname, build, bname, UUBUILD_MODE, UUBUILD_NAME);
X    return;
X}
X
X/*
X * output_program - output the ---program--- section
X *
X * Read the needed information form stdin, and write the program section.
X */
Xvoid
Xoutput_program(output, oname, prog, pname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    FILE *prog;			/* open program stream */
X    char *pname;		/* name of program file */
X{
X    /*
X     * write the start of the section
X     */
X    fprintf(output, "---program---\n");
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * uuencode the program file
X     */
X    uuencode(output, oname, prog, pname, UUPROG_MODE, UUPROG_NAME);
X    return;
X}
X
X/*
X * output_end - output the ---end--- section
X *
X * Read the needed information form stdin, and write the 'end section'.
X */
Xvoid
Xoutput_end(output, oname)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X{
X    /*
X     * write the final section terminator
X     */
X    fprintf(output, "---end---\n");
X    check_io(output, oname, EOF_NOT_OK);
X    return;
X}
X
X/*
X * get_line - get an answer from stdin
X *
X * This function will flush stdout, in case a prompt is pending, and
X * read in the answer.
X *
X * This function returns 0 if the line is too long, of the length of the
X * line (including the newline) of the line was ok.  This function does
X * not return if ERROR or EOF.
X */
Xint
Xget_line(buf, siz, maxcol)
X    char *buf;			/* input buffer */
X    int siz;			/* length of input, including the newline */
X    int maxcol;			/* max col allowed, 0 => disable check */
X{
X    int length;			/* the length of the input line */
X
X    /* flush terminal output */
X    fflush(stdout);
X
X    /* read the line */
X    if (fgets(buf, siz+1, stdin) == NULL) {
X	/* report the problem */
X	check_io(stdin, "stdin", EOF_NOT_OK);
X    }
X
X    /* look for the newline */
X    length = strlen(buf);
X    if (buf[length-1] != '\n') {
X	int eatchar;		/* the char being eaten */
X
X	/* no newline found, line must be too long, eat the rest of the line */
X	do {
X	    eatchar = fgetc(stdin);
X	} while (eatchar != EOF && eatchar != '\n');
X	check_io(stdin, "stdin", EOF_NOT_OK);
X
X	/* report the situation */
X	return 0;
X    }
X
X    /* watch for long lines, if needed */
X    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) {
X	/* report the situation */
X	return 0;
X    }
X
X    /* return length */
X    return length;
X}
X
X/*
X * output_till_dot - output a set of lines until '.' by itself is read
X *
X * This routine will read a set of lines until (but not including)
X * a single line with '.' is read.  The format of the output is:
X *
X *	leader:\tfirst line
X *	\tnext line
X *	\tnext line
X *	   ...
X *
X * This routine will not return if I/O error or EOF.
X */
Xvoid
Xoutput_till_dot(output, oname, leader)
X    FILE *output;		/* entry's output file stream */
X    char *oname;		/* name of the output file */
X    char *leader;		/* the lead text for the first line */
X{
X    char buf[BUFSIZ+1];		/* input buffer */
X    int count;			/* lines read */
X    int done=FALSE;		/* TRUE => finished reading input */
X
X    /* instruct the user on how to input */
X    printf("\nTo end input, enter a line with a single period.\n");
X
X    /* read lines until '.' or EOF */
X    count = 0;
X    while (!done) {
X	/* issue the prompt */
X	printf("%s\t", (count>0) ? "" : leader);
X	fflush(stdout);
X
X	/* get the line */
X	if (get_line(buf, BUFSIZ, MAX_COL-9) <= 0) {
X	    printf("\nline too long, please re-enter:\n\t");
X	    continue;
X	}
X
X	/* note if '.' was read */
X	if (strcmp(buf, ".\n") == 0) {
X	    done = TRUE;
X	}
X
X	/* write line if we read something */
X	if (!done) {
X	    fprintf(output, "%s\t%s", (count++>0) ? "" : leader, buf);
X	    check_io(output, oname, EOF_NOT_OK);
X	}
X    }
X
X    /* if no lines read, at least output something */
X    if (count <= 0) {
X	fprintf(output, "%s\t.\n", leader);
X	check_io(output, oname, EOF_NOT_OK);
X    }
X    return;
X}
X
X/*
X * col_len - determine the highest that a string would reach
X *
X * Given a string, this routine returns that a string would reach
X * if the string were printed at column 1.  Tab stops are assumed
X * to start at 9, 17, 25, 33, ...
X */
Xint
Xcol_len(string)
X    char *string;		/* the string to examine */
X{
X    int col;	/* current column */
X    char *p;	/* current char */
X
X    /* scan the string */
X    for (col=0, p=string; *p != '\0' && *p != '\n'; ++p) {
X	/* note the column shift */
X	col = (*p=='\t') ? 1+((col+8)/8*8) : col+1;
X    }
X    if (*p == '\n') {
X	--col;
X    }
X
X    /* return the highest column */
X    return col;
X}
X
X/*
X * check_io - check for EOF or I/O error on a stream
X *
X * Does not return if EOF or I/O error.
X */
Xvoid
Xcheck_io(stream, name, eof_ok)
X    FILE *stream;		/* the stream to check */
X    char *name;			/* the name of this stream */
X    int eof_ok;			/* EOF_OK or EOF_NOT_OK */
X{
X    /* test for I/O error */
X    if (ferror(stream)) {
X	fprintf(stderr, "%s: error on %s: ", program, name);
X	perror("");
X	exit(1);
X
X    /* test for EOF */
X    } else if (eof_ok == EOF_NOT_OK && feof(stream)) {
X	fprintf(stderr, "%s: EOF on %s\n", program, name);
X	exit(1);
X    }
X    return;
X}
X
X/*
X * uuencode - uuencode a file
X *
X * Perform the uuencoding process identical to the process performed
X * by the uuencode(1) utility.
X *
X * This routine implements the algorithm described in the uuencode(5)
X * 4.3BSD Reno man page.
X */
Xvoid
Xuuencode(output, oname, infile, iname, umode, uname)
X    FILE *output;		/* output file stream */
X    char *oname;		/* output filename */
X    FILE *infile;		/* input file stream */
X    char *iname;		/* input filename */
X    int umode;			/* the mode to put on the uuencode file */
X    char *uname;		/* name to put on the uuencode file */
X{
X    char buf[UUENCODE_LEN+1];	/* the uuencode buffer */
X    int read_len;		/* actual number of chars read */
X    int val;			/* 6 bit chunk from buf */
X    char filler='\0';		/* filler uuencode pad text */
X    char *p;
X
X    /*
X     * output the initial uuencode header
X     */
X    fprintf(output, "begin %o %s\n", umode, uname);
X    check_io(output, oname, EOF_NOT_OK);
X
X    /*
X     * clear out the input buffer
X     */
X    for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
X	*p = '\0';
X    }
X
X    /*
X     * We will process UUENCODE_LEN chars at a time, forming
X     * a single output line each time.
X     */
X    while ((read_len=fread(buf,sizeof(buf[0]),UUENCODE_LEN,infile)) > 0) {
X
X	/*
X	 * the first character is the length character
X	 */
X	fputc(UUENCODE(read_len), output);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/*
X	 * We will convert 24 bits at a time.  Thus we will convert
X	 * 3 sets of 8 bits into 4 sets of uuencoded 6 bits.
X	 */
X	for (p=buf; read_len>0; read_len-=3, p+=3) {
X
X	    /* bits 0 to 5 */
X	    val = (p[0]>>2)&0x3f;
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 6 to 11 */
X	    val = ((p[0]<<4)&0x30) | ((p[1]>>4)&0x0f);
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 12 to 17 */
X	    val = ((p[1]<<2)&0x3c) | ((p[2]>>6)&0x03);
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X
X	    /* bits 18 to 23 */
X	    val = p[2]&0x3f;
X	    fputc(UUENCODE(val), output);
X	    check_io(output, oname, EOF_NOT_OK);
X	}
X
X	/* end of UUENCODE_LEN line */
X	fputc('\n', output);
X	check_io(output, oname, EOF_NOT_OK);
X
X	/*
X	 * clear out the input buffer  (don't depend on bzero() or memset())
X	 */
X	for (p=buf; p < &buf[sizeof(buf)/sizeof(buf[0])]; ++p) {
X	    *p = '\0';
X	}
X    }
X
X    /* check the last read on the input file */
X    check_io(infile, iname, EOF_OK);
X
X    /* write end of uuencode file */
X    fprintf(output, "%c\nend\n", UUENCODE(filler));
X    check_io(output, oname, EOF_NOT_OK);
X}
END_OF_FILE
  if test 34486 -ne `wc -c <'1993/mkentry.c'`; then
    echo shar: \"'1993/mkentry.c'\" unpacked with wrong size!
  fi
  # end of '1993/mkentry.c'
fi
echo shar: End of archive 1 \(of 4\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
