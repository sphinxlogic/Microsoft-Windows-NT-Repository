Newsgroups: comp.sources.misc
From: chongo@toad.com (Landon Curt Noll)
Subject: v39i106:  ioccc.1993 - 1993 International Obfuscated C Code Contest winners, Part03/04
Message-ID: <1993Sep26.172602.4179@sparky.sterling.com>
X-Md4-Signature: 3c919fa0d293f8d4fe4bb60718ce02f2
Keywords: ioccc
Sender: kent@sparky.sterling.com (Kent Landfield)
Reply-To: chongo@toad.com (Landon Curt Noll)
Organization: Nebula Consultants in San Francisco
Date: Sun, 26 Sep 1993 17:26:02 GMT
Approved: kent@sparky.sterling.com

Submitted-by: chongo@toad.com (Landon Curt Noll)
Posting-number: Volume 39, Issue 106
Archive-name: ioccc.1993/part03
Environment: C

#! /bin/sh
# This is ioccc.1993, a shell archive.  Remove anything before this line,
# then feed it into a shell via "sh file" or similar.  To overwrite existing
# files, type "sh file -c".
#
# Contents:  1993/Makefile 1993/README 1993/ant.c 1993/ant.test.mk
#   1993/cmills.hint 1993/dgibson.c 1993/dgibson.data5
#   1993/dgibson.hint 1993/ejb.c 1993/ejb.hint 1993/jonth.c 1993/leo.c
#   1993/leo.hint 1993/rince.c 1993/rince.design 1993/rince.orig.c
#   1993/schnitzi.c 1993/schnitzi.hint 1993/vanb.c
#
# Send comments, questions, bugs to:
#
#    judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges
#
# You are strongly encouraged to read the new contest rules before
# sending any entries.  The rules, and sometimes the contest Email
# address itself, change over time.  Valid entries one year may
# be rejected in a later year due to changes in the rules.  The typical
# start date for contests is in early March.  Contest rules are normally not
# finalized and posted until the beginning of the contest.  The typical closing
# date for contests are in early May.
#
# The contest rules are posted to comp.unix.wizards, comp.lang.c,
# misc.misc, alt.sources and comp.sources.d.  If you do not have access
# to these groups, or if you missed the early March posting, you may
# request a copy from the judges, via Email, at the address above.
#
# Copyright (c) 1993, Landon Curt Noll & Larry Bassel.
# All Rights Reserved.  Permission for personal, educational or non-profit
# use is granted provided this this copyright and notice are included in its
# entirety and remains unaltered.  All other uses must receive prior permission
# in writing from both Landon Curt Noll and Larry Bassel.
#
# Previous contest winners are available via anonymous ftp from
# ftp.uu.net under the directory /pub/ioccc.
#
# Wrapped by kent@sparky on Sun Sep 26 12:05:12 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 4)."'
if test -f '1993/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/Makefile'\"
else
  echo shar: Extracting \"'1993/Makefile'\" \(3297 characters\)
  sed "s/^X//" >'1993/Makefile' <<'END_OF_FILE'
X# %W% %G% %U%
X#
X# 1993 makefile
X#
X# Copyright (c) 1993, Landon Curt Noll & Larry Bassel.
X# All Rights Reserved.  Permission for personal, educational or non-profit
X# use is granted provided this this copyright and notice are included in its
X# entirety and remains unaltered.  All other uses must receive prior permission
X# in writing from both Landon Curt Noll and Larry Bassel.
X
X
XSHELL=/bin/sh
XCHMOD=chmod
XCP=cp
XRM=rm
XSED=sed
XLN=ln
X
X# flags for ANSI compiles
X#
X# NOTE: Some ANSI compilers make use of -Xa to turn on ANSI mode,
X#	others such as gcc may want -ansi, others may want nothing
X#	at all.  Adjust the CFLAGS line as needed.
X#
X# NOTE: Some compilers cannot optimize, or optimize some entries
X#	entries incorrectly.  You might want need to turn on -O 
X#	to see if your compiler can handle them.
X#
X#CFLAGS=-O -Xa
X#CFLAGS=-Xa
XCFLAGS= -ansi
X#CFLAGS=
X
X# ANSI compiler
X#
X# Set CC to the name of your ANSI compiler.
X#CC=cc
XCC=gcc
X
X# misc shell babble
X#
XNOINCLUDE=$(SED) -e 's/^.\([	 ]*\)include/%include/'
XSPACECLEAN=$(SED) -e 's/\([^	 ]\)\([	 ]\)[ 	][ 	]*/\1\2/g'
XCPPCLEAN=$(GREP) -v '^. [0-9][0-9]*'
X
X# winners that compile under ANSI C
X#
XWINNERS= ant cmills dgibson ejb jonth leo lmfjyh plummer rince schnitzi vanb
XALT_NAMES= ag ag.doc chris mind jkb
X
Xall: $(WINNERS) $(ALT_NAMES)
X
Xant: ant.c
X	${CC} ${CFLAGS} ant.c -o ant
X
Xcmills: cmills.c
X	${CC} ${CFLAGS} cmills.c -o cmills -lX11
X
Xdgibson: dgibson.c dgibson.sh dgibson.data1
X	-@if [ ! -f life.d ] ; then \
X	    echo "cp dgibson.data1 life.d"; \
X	    cp dgibson.data1 life.d; \
X	    echo "rm -f data.name"; \
X	    rm -f data.name; \
X	    echo "echo dgibson.data1 > data.name"; \
X	    echo dgibson.data1 > data.name; \
X	fi
X	${CC} ${CFLAGS} dgibson.c -o dgibson
X	-${CHMOD} +x dgibson.sh
X
Xejb: ejb.c
X	${CC} ${CFLAGS} ejb.c -o ejb
X
Xjonth: jonth.c
X	${RM} -f jonth.tmp.c
X	${SED} -e s/\^\ /#define/ -e 's/@/Window(D,/g' jonth.c > jonth.tmp.c
X	${CC} ${CFLAGS} \
X	    -DXX1='H 19;}M(J,4)}N H 20;}M(T,4)}q(m,w,' \
X	    -DXX='XKeycodeToKeysym(D,o[13],0);K 12:Y();}R;}d XX1' \
X	    jonth.tmp.c -o jonth -lX11
X
Xleo: leo.c
X	${CC} ${CFLAGS} leo.c -o leo
X
Xlmfjyh: lmfjyh.c
X	${RM} -f \"\;main\(\)\{puts\(\"Hello\ World!\"\)\;\}char\*C=\".c
X	${CP} lmfjyh.c \"\;main\(\)\{puts\(\"Hello\ World!\"\)\;\}char\*C=\".c
X	${CC} ${CFLAGS} \
X	    \"\;main\(\)\{puts\(\"Hello\ World!\"\)\;\}char\*C=\".c \
X	    -o lmfjyh
X
Xplummer: plummer.c
X	${CC} ${CFLAGS} plummer.c -o plummer
X
Xrince: rince.c
X	${CC} ${CFLAGS} rince.c -lcurses -ltermcap -o rince
X
X# NOTE: this is the original source that won
X#
Xrince.orig: rince.orig.c
X	$(CC) $(CFLAGS) rince.orig.c -lcurses -ltermcap -o rince.orig
X
Xschnitzi: schnitzi.c
X	${CC} ${CFLAGS} schnitzi.c -o schnitzi
X
Xvanb: vanb.c
X	${CC} ${CFLAGS} -DO5=main vanb.c -o vanb
X
X
X# alternate names for selected entries
X#
Xag: ant
X	$(RM) -f ag
X	$(LN) ant ag
X
Xag.doc: ant.doc
X	$(RM) -f ag.doc
X	$(LN) ant.doc ag.doc
X
Xchris: cmills
X	$(RM) -f chris
X	$(LN) cmills chris
X
Xmind: leo
X	$(RM) -f mind
X	$(LN) leo mind
X
Xjkb: rince
X	$(RM) -f jkb
X	$(LN) rince jkb
X
Xtidy:
X	${RM} -f \"\;main\(\)\{puts\(\"Hello\ World!\"\)\;\}char\*C=\".c
X
Xclean:
X	$(RM) -f *.o a.out core 
X
Xclobber: clean tidy
X	$(RM) -f $(WINNERS)
X	$(RM) -f $(ALT_NAMES)
X	${RM} -f jonth.tmp.c life.d rince.orig data.name data.name2
X
Xnuke: clobber
X	@true
X
Xinstall: all
X	cat $(WINNERS) > /dev/null
END_OF_FILE
  if test 3297 -ne `wc -c <'1993/Makefile'`; then
    echo shar: \"'1993/Makefile'\" unpacked with wrong size!
  fi
  # end of '1993/Makefile'
fi
if test -f '1993/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/README'\"
else
  echo shar: Extracting \"'1993/README'\" \(2629 characters\)
  sed "s/^X//" >'1993/README' <<'END_OF_FILE'
X1993 marked the "The Tenth International Obfuscated C Code Contest"
X
XCopyright (c) 1993, Landon Curt Noll & Larry Bassel.
XAll Rights Reserved.  Permission for personal, educational or non-profit use is
Xgranted provided this this copyright and notice are included in its entirety
Xand remains unaltered.  All other uses must receive prior permission in writing
Xfrom both Landon Curt Noll and Larry Bassel.
X
XUse make to compile entries.  It is possible that on BSD or non-unix
Xsystems the makefile needs to be changed.  See the Makefile for details.
X
XLook at the source and try to figure out what the programs do, and run
Xthem with various inputs.  If you want to, look at the hints files for
Xspoilers - this year we included most of the information included
Xby the submitters.
X
XRead over the makefile for compile/build issues.  Your system may
Xrequire certain changes (add or remove a library, add or remove a
X#define).
X
XName and address information are separated from the actual program
Xprior to judging.  This eliminates any chance that we would bias our
Xjudging for/against any person or group.
X
XThis year was the first year that ANSI C was the default.  Use of
Xclassic K&R C was allowed so long as ANSI C compilers could still
Xcompile the entry.  If you do not have an ANSI C compiler, you may
Xnot be able to compile the winners, sorry!
X
XA few notes regarding future contests:
X
XBe sure to wait until the 1994 rules are posted before submitting entries.  
XRules differ from year to year, sometimes in significant ways.
X
XIn 1994, we will retract the guideline that discouraged the use of C
Xconstructs such as 3["curds"].  At one time, certain ANSI compilers did
Xnot consider such expressions to be valid ANSI C.  Alert readers noted
Xthat the current ANSI standard considered them to be valid.  We were
Xunable to find an ANSI C compiler that flagged such expressions as
Xerrors.
X
XPlease send us comments and suggestions what we have expressed above.
XAlso include anything else that you would like to see in future contests.
XSend such email to:
X
X	...!{sun,pacbell,uunet,pyramid}!hoptoad!judges
X	judges@toad.com
X
XIf you use, distribute or publish these entries in some way, please drop
Xus a line.  We enjoy seeing who, where and how the contest is used.
X
XIf you have problems with any of the entries, AND YOU HAVE A FIX, please
XEmail the fix (patch file or the entire changed file) to the above address.
X
XCredits:
X
XWe would like to thank Barbara Frezza for her role as official chef 
Xof the contest.  Landon Noll and Larry Bassel appreciated the opportunity
Xto serve as official taste testers.  And as usual, the food was excellent.
END_OF_FILE
  if test 2629 -ne `wc -c <'1993/README'`; then
    echo shar: \"'1993/README'\" unpacked with wrong size!
  fi
  # end of '1993/README'
fi
if test -f '1993/ant.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ant.c'\"
else
  echo shar: Extracting \"'1993/ant.c'\" \(2931 characters\)
  sed "s/^X//" >'1993/ant.c' <<'END_OF_FILE'
X#define D ++*p
X#define B **p
X#define W while
X#define R return 
X#define E else
X#define Q if
X#define G fprintf(stderr,
X
X
X#include <stdio.h>
X
X#ifndef A
X#define A	512
X#endif
X
Xtypedef int I;
Xtypedef char C;
Xtypedef void V;
X
XI z;
XI f;
XI x;
XI a[A], b;
X
X
XI d[A][A];
XI m[A], n, o;
X
XI N();
XI M();
XI P();
XI U();
XV X();
XV T();
XV F();
XV L();
XV O();
X
XI
Xmain(c, p)
XI c;
XC B;
X{
X	I i;
X	FILE *j;
X	C *k, l[BUFSIZ+1];
X
X	Q (--c < 1) {
X		G "usage:  ag <pattern> [js...]\n");
X		R 2;
X	}
X
X	
X	N(-3);
X	N(-6-b);
X	N(0);
X	N(-3-b);
X
X	X(&(*++p));
X
X	*l = '\n';
X	o = 1;
X	i = 1;
X	do {
X		k = "-";
X		j = stdin;
X		Q (1 < c && **++p != '-') {
X			Q (!(j = fopen(k = *p, "r"))) {
X				G 
X					"ag: Failed to open '%s'.\n", k);
X				i = 3;
X				continue;
X			}
X		}
X		W (fgets(l+1, BUFSIZ, j)) {
X			Q (M(l)) {
X				printf("%s:%s", k, l+1);
X				i = 0; 
X			}
X		}
X		fclose(j);
X	} W (1 < --c);
X	R i;
X}
X
X
XV
XX(p)
XC B;
X{
X	I i, j;
X	i = N(-3);
X	T(p);
X	W (B == '|') {
X		D;
X		j = N(-3);
X		N('\n');
X		a[i] = -4-b;
X		i = N(-3);
X		T(p);
X		a[j] = -4-b;
X	}
X}
X
X
XV
XT(p)
XC B;
X{
X	W (B != '|' && (!x || B != ')')  && B)
X		F(p);
X}
X
X
XV
XF(p)
XC B;
X{
X	I i = N(-3);
X	Q (B == '^') {
X		D;
X		N('\n');
X	} E Q (B == '$') {
X		D;
X		N('\n');
X	} E Q (B == '(') { 
X		D; 
X		++x;
X		X(p); 
X		Q (B != ')') { 
X			G "ag: Missing ')'.\n"); 
X			exit(3); 
X		}
X		--x;
X		D;
X	} E {
X		L(p);
X	}
X	Q (B == '*') {
X		D;
X		a[i] = -4-b;
X		N(-5-i);
X	} E Q (B == '?') {
X		D;
X		a[i] = -4-b;
X	}
X}
X
X
XV
XL(p)
XC B;
X{
X	I i, j;
X	Q (B == '.') {
X		N(0);
X	} E Q (B == '[') {
X		D;
X		i = N(-2);
X		Q (B == '^') {
X			D;
X			a[i] = -1;
X		}
X		Q (B == ']') {
X			D;
X			N(']');
X		}
X		W ((i = B) != ']') {
X			Q ((*p)[1] == '-' && i < (j = (*p)[2])) {
X				W (i <= j)
X					N(i++);
X				*p += 3;
X			} E {
X				N(i);
X				D;
X			}
X		}
X		N('\n');
X	} E {
X		Q (B == '\\')
X			D;
X		N(B);
X	}
X	D;
X}
X
X
XI
XN(c)
XI c;
X{
X	Q (A <= b) {
X		G "ag: Pattern too long.\n");
X		exit(3);
X	}
X	a[b] = c;
X	R b++;
X}
X
X
XV
XO(p)
XI p;
X{
X	I i = n;
X	Q (b <= p)
X		R;
X	Q (a[p] < -2) {
X		Q (a[p] != -3)
X			O(-4-a[p]);
X		O(p+1);
X	} E Q (!a[p] || a[p] == z || P(&p)) {
X		
X		W (i < o)
X			Q (m[i++] == p)
X				R;
X		
X		f = U(p+1);
X
X		Q (A <= o) {
X			G "ag: Out of space.\n");
X			exit(3);
X		}
X		
X		m[o++] = p;
X	}
X}
X
X
XI
XP(p)
XI *p;
X{
X	I i = 0, j = 0;
X	Q (a[*p] == -2 || (j = a[*p] == -1)) {
X		W (a[D] != '\n')
X			Q (a[*p] == z)
X				i = 1;
X	}
X	R i ^ j;
X}
X
X
XI
XU(p)
XI p;
X{
X	R (
X		f || p == b || (
X			a[p] < -2 && (
X				(a[p] != -3 && U(-4-a[p])) 
X				|| U(p+1)
X			)
X		)
X	);
X}
X
X
XI
XM(p)
XC *p;
X{
X	I c, i, j, k;
X	f = c = 0;
X	W (*p && 0 <= c) {
X		Q (0 < (i = d[c][*p])) {
X			
X			c = i;
X		} E {
X			
X			z = *p;
X			i = d[c][0];
X			j = n = o;
X			do 
X				O(m[i++]+1);
X			W (m[i] != 2);
X
X			
X			i = k = 0;
X			W (i < n) {
X				Q (m[i] == 2) {
X					j = n;
X					++k;
X				}
X				Q (m[i++] == m[j]) {
X					Q (o <= ++j) {
X						j = n;
X						Q (m[i] == 2) {
X							
X							o = n;
X							break;
X						}
X					}
X				} E {
X					j = n;
X				}
X			}
X			Q (n < o) 
X				
X				d[++k][0] = n;
X			c = d[c][*p] = f ? -1 : k;
X		}
X		++p;
X	}
X	R c < 0;
X}
X
END_OF_FILE
  if test 2931 -ne `wc -c <'1993/ant.c'`; then
    echo shar: \"'1993/ant.c'\" unpacked with wrong size!
  fi
  # end of '1993/ant.c'
fi
if test -f '1993/ant.test.mk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ant.test.mk'\"
else
  echo shar: Extracting \"'1993/ant.test.mk'\" \(3470 characters\)
  sed "s/^X//" >'1993/ant.test.mk' <<'END_OF_FILE'
X#
X#	Test Driver for Anthony's Grep
X#
X#	Public Domain 1992, 1993 by Anthony Howe.  No warranty.
X#
X
XSHELL=/bin/sh
XPRG=./ant
X
Xall: ant char word anchor literal wild closure option branch sub class
X
X#
X# Built the entry
X#
Xant: Makefile
X	make -f Makefile ant
X
X#
X# Test simple text patterns without the use of meta characters.
X#
X
Xempty: 
X	$(PRG) '' ant.test.mk
X
Xchar:
X	$(PRG) 'q' ant.test.mk
X
Xword:
X	$(PRG) 'simple' ant.test.mk
X
X#
X# Test meta characters.
X#
X
Xanchor: anchor1 anchor2 anchor3 anchor4 anchor5
X
Xanchor1:
X	$(PRG) '^anchor1' ant.test.mk
X
Xanchor2:
X	$(PRG) 'Grep$$' ant.test.mk
X
X#
X# Find all empty lines.
X#
Xanchor3:
X	$(PRG) '^$$' ant.test.mk
X
X#
X# This is valid but will never match.
X#
Xanchor4:
X	-$(PRG) 'x^a' ant.test.mk
X
X#
X# This is valid but will never match.
X#
Xanchor5:
X	-$(PRG) 'mk$$x' ant.test.mk
X
Xliteral: literal1 literal2
X
X#
X# Every line with a dollar-sign.	
X#
Xliteral1:
X	$(PRG) '\$$' ant.test.mk
X
X#
X# Every line with a backslash.	
X#
Xliteral2:
X	$(PRG) '\\' ant.test.mk
X
X#
X#	wild #1#
X#	wild #a#
X#	wild #%#
X#
Xwild:
X	$(PRG) '#.#' ant.test.mk
X
X#
X#  	closure !!
X#  	closure !x!
X#	closure !xxxxxx!
X#
Xclosure:
X	$(PRG) 'closure !x*!' ant.test.mk
X
X#
X#	option ++
X#	option +a+
X#	option +b+
X#	option +c+
X#	option +abc+
X#
Xoption: option1 option2
X
Xoption1:
X	$(PRG) '+b?+' ant.test.mk
X
Xoption2:
X	$(PRG) '+.?+' ant.test.mk
X
Xbranch: branch1 branch2 branch3 branch4 branch5 branch6
X
Xbranch1:
X	$(PRG) 'q|simple' ant.test.mk
X
X#
X# This pattern should be the same as '(^all)|(Public)|(Grep$)'.
X#
Xbranch2:
X	$(PRG) '^all|Public|Grep$$' ant.test.mk
X
X#
X# This pattern should generate the same results as branch2.
X#
Xbranch3:
X	$(PRG) 'Grep$$|^all|Public' ant.test.mk
X
X#
X# Null expression between start of pattern and vertical-line.
X#
Xbranch4:
X	$(PRG) '|Grep' ant.test.mk
X
X#
X# Null expression between vertical-line and end of pattern.
X#
Xbranch5:
X	$(PRG) 'Grep|' ant.test.mk
X
X#
X# Null expression between vertical-line and vertical-line.
X#
Xbranch6:
X	$(PRG) 'all||Grep' ant.test.mk
X
X#
X#	sub aabcbcbcxx
X#	sub aagxx
X#	sub aaggxx
X#	sub aadddxx
X#	sub aaxx
X#
Xsub: sub0 sub1 sub2 sub3 sub4 sub5 lparen1 lparen2 rparen1 rparen2
X
X#
X# Null sub-expressions.
X#
Xsub0:
X	$(PRG) 's()u()b()' ant.test.mk
X
Xsub1:
X	$(PRG) '#(1|%)#' ant.test.mk
X
Xsub2:
X	$(PRG) 'aa((bc)*|g)xx' ant.test.mk
X
X#
X# Null expression between the left-parenthesis and the vertical-line.
X#
Xsub3:
X	$(PRG) '#(|1)#' ant.test.mk
X
X#
X# Null expression between the vertical-line and the right-parenthesis.
X#
Xsub4:
X	$(PRG) '#(1|)#' ant.test.mk
X
X#
X# Null expression between the vertical-line and the right-parenthesis.
X#
Xsub5:
X	$(PRG) '#(%||1)#' ant.test.mk
X
X#
X# Missing left-parenthesis generates an error.
X#
Xlparen1:
X	-$(PRG) 'left ( only' ant.test.mk
X
Xlparen2:
X	$(PRG) 'left \( only' ant.test.mk
X
X#
X# Right-parenthesis without preceding left parenthesis should be a literal.
X#
Xrparen1:
X	-$(PRG) 'right ) only' ant.test.mk
X
Xrparen2:
X	$(PRG) 'right \) only' ant.test.mk
X
X#
X#		12345678
X#	-----------------
X#	=0=	1  45
X#	=1=	 2 45 78
X#	=2=	 2 45
X#	=3=	 2 45 78
X#	=4=	 2 45
X#	=5=	 2 45
X#	=6=	 2 45
X#	=7=	 2 45
X#	=8=	 2 45
X#	=9=	1  45
X#	=]=	 23  6
X#	=-=	 2 4 678
X#	= =	 2 4 6
X#
Xclass:	class1 class2 class3 class4 class5 class6 class7 class8
X
Xclass1:
X	$(PRG) '=[09]=' ant.test.mk
X
Xclass2:
X	$(PRG) '=[^09]=' ant.test.mk
X
Xclass3:
X	$(PRG) '=[]]=' ant.test.mk
X
Xclass4:
X	$(PRG) '=[^]]=' ant.test.mk
X
Xclass5:
X	$(PRG) '=[0-9]=' ant.test.mk
X
Xclass6:
X	$(PRG) '=[^0-9]=' ant.test.mk
X
Xclass7:
X	-$(PRG) '=[3-1]=' ant.test.mk
X
Xclass8:
X	$(PRG) '=[-13]=' ant.test.mk
X
END_OF_FILE
  if test 3470 -ne `wc -c <'1993/ant.test.mk'`; then
    echo shar: \"'1993/ant.test.mk'\" unpacked with wrong size!
  fi
  # end of '1993/ant.test.mk'
fi
if test -f '1993/cmills.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/cmills.hint'\"
else
  echo shar: Extracting \"'1993/cmills.hint'\" \(2242 characters\)
  sed "s/^X//" >'1993/cmills.hint' <<'END_OF_FILE'
X"Bill Gates" Award: <chris@pagine.com> Chris Mills
X
X	Chris Mills
X	Pagine Corporation
X	1961-A Concourse Drive
X	San Jose, CA 95131
X	USA
X
X
XJudges' comments:
X
X    From the San Jose Mercury News (May 15, 1993 page 20A "West Hackers 
X    trounce East in computer quiz game"): 
X
X	"Since 1984, a contest has been held on Usenet for the most
X	unreadable, creative, bizarre but working C program", Gates
X	said. "What is the name of this contest?"
X
X	"Windows," shot back Gassee, naming Microsoft's premier product
X	- a product over which Apple sued Microsoft five years ago. Not
X	the right answer - it's "The Obfuscated C Contest [sic]" - but
X	it brought down the house of Apple partisans...
X
X    [The expression on Bill Gates' face was a sight to behold, as reported
X    to us by several who were there].
X
X    To use:
X	make cmills 		# requires the X11 library
X	DISPLAY="your_X_server_display" 
X	export DISPLAY
X	./cmills [speed]	# must be run on an X11 server
X
X    where:
X	speed	update speed from 1 to 9 (default is 9)
X
X    Csh users should use:
X	make cmills 		# requires the X11 library
X	setenv DISPLAY "your_X_server_display" 
X	./cmills [speed]	# must be run on an X11 server
X
X    You must set $DISPLAY in your environment or the program will 
X    dump core.  This is not a bug as the author documented it as
X    a feature.  :-)
X
X    The optional argument is integer which controls the speed of the
X    program.  By default the speed is 9.  You may want to try 1.
X
X    You will have to kill the program (i.e., ^C) to stop it.
X
X    WARNING: Slow servers or servers with long request queues will
X	     continue to 'run' for a while after you have killed
X	     the program.
X
X    This program makes your windows about as useful as their windows. :-)
X
X
XSelected notes from the author:
X
X    The program uses a single backing pixmap (which is the size of the
X    screen) for all of its subwindows (with a little bit of trickery to
X    move the offset around).  This is much better (and faster) than the
X    obvious implementation which would require a full-screen pixmap and
X    a separate backing pixmap for each subwindow.
X
X    The chance that a window breaks is based on it's kinetic energy,
X    which in turn is based on it's area and speed.  How silly!
END_OF_FILE
  if test 2242 -ne `wc -c <'1993/cmills.hint'`; then
    echo shar: \"'1993/cmills.hint'\" unpacked with wrong size!
  fi
  # end of '1993/cmills.hint'
fi
if test -f '1993/dgibson.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/dgibson.c'\"
else
  echo shar: Extracting \"'1993/dgibson.c'\" \(2143 characters\)
  sed "s/^X//" >'1993/dgibson.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#define maxc (prs >> 16)
X#define maxr (prs & 0xff00) >> 8
X#define find (col > 1)
X#define endb || (prs & 16) && X(0) || chpa || (eols, 0)
X#define lnst doln ? 0 : (init, 0) || (prs & 128) && X(0)
X#define L    endb) || 0 || (find ? 0 : (rrr++, rrc = 0)) || (lnst
X#define X(p) (dfc++ && ((prs & 48) != 32 || rrc < maxc) && ++ccl && \
X             (find ? (bat = bit, bit = but, but = p, ccl == col && \
X             (ret = bat + bit + but) + 1) : (las = las * 2 + \
X             (((main(ccl + 1, cro - 1) + main(ccl + 1, cro) + \
X             main(ccl + 1, cro + 1) - p) | p) == 3), occ |= las & 1, \
X             printf(" %c", "_O"[las & 1]), ccl == 2 && (sta |= (las & 3) << 6),\
X             0)))
X#define _    || (find || rrc++, 0) || X(0)
X#define O    || (find || rrc++, 0) || X(1)
X#define chpa (find && col > ccl && ((ret = bit + but) + 1))
X#define eols (!find && (cro == 1 ? (sta |= occ << 3) : cro == 2 && \
X             (sta |= occ << 2), sta |= (las & 3) << 4))
X#define init (find ? (ret = bit = but = 0) : (ocp = occ, las = occ = 0, \
X             printf("\nL")), dfc = (prs & 192) != 64, ccl = 0)
X#define doln !(dfl++ && (((prs & 3) != 2) || rrr < maxr) && \
X             (++cro == row || !find))
X#define recu (col =- col, (ccl = find ? rcf : rcl), cro = rro, 0 _ || \
X             (rrc >= maxc ? 0 : (find ? rcf = ccl : (rcl = ccl), \
X             main(-col, row))))
X#define addl (lnst || (rro = cro, find ? rcf = ccl : (rrc = 0, rcl = ccl), \
X             0) || main(-col, row) || (ccl = rcl + 1, 0) endb)
X#define outp (find || printf("\n\nGEN %d STAT %ld\nEND\n", ++gen, \
X             (long)ccl << 16 | cro << 8 | (sta | occ | ocp << 1) ^ 0x66))
X#define GEN  endb) || (prs & 1) && addl || (outp, 0)), ret)); } int gen =
X#define STAT ;long prs =
X#define END  ;
X#define LIFE int bat, bit, but, las, gen, ret, rcl, rcf, rro, rrc, rrr, \
X             occ, ocp, sta, dfc; long prs; main(int col, int row) { \
X             int dfl = ((prs & 12) != 4), ccl = 0, cro = 0; return \
X             col == 1 && printf("LIFE\n"), (col < 0 ? recu : \
X             (((ret = 0) || (prs & 8) && addl || 0 && (0
X
X#include "life.d"
END_OF_FILE
  if test 2143 -ne `wc -c <'1993/dgibson.c'`; then
    echo shar: \"'1993/dgibson.c'\" unpacked with wrong size!
  fi
  # end of '1993/dgibson.c'
fi
if test -f '1993/dgibson.data5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/dgibson.data5'\"
else
  echo shar: Extracting \"'1993/dgibson.data5'\" \(3531 characters\)
  sed "s/^X//" >'1993/dgibson.data5' <<'END_OF_FILE'
X/* Howdy, Landon:							    */
X/* Here is one of the best Life patterns found in many years.  It is called */
X/* a "spacefiller", for reasons which will become obvious when you run it.  */
X/* This was found by Hartmut Holzwart a couple of weeks ago.  Enjoy!	    */
X/* 							BCNU, -dbell-	    */
XLIFE
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O _ O _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O _ _ O _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O _ _ _ _ O _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O O _ _ _ O O O _ _ _ _ O _ O O O O O _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O _ _ O _ O _ _ O _ _ _ _ _ _ _ _ _ _ _ _ O O _ _ _
XL _ _ _ _ _ _ _ _ _ _ O O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ O O O _ _ _ O _ _
XL _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _ _ O _ _ _ O _
XL _ _ _ _ _ _ _ _ O O _ _ O _ _ _ _ _ _ _ O _ O _ O _ O _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ O _
XL _ _ _ _ _ _ _ O _ _ _ _ O _ _ _ _ _ _ _ O _ O _ O _ O _ _ _ _ _ _ _ _ _ _ O _ _ O _ _ O _
XL _ _ _ _ _ _ O O O O O _ _ _ _ _ _ _ _ _ _ O _ _ _ O _ _ _ _ _ _ _ _ O _ O O _ _ O _ O _ _
XL _ _ _ O O _ _ _ _ _ O O _ _ _ _ O _ _ _ O O O _ O O O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _
XL _ _ O _ _ _ O O O _ _ O _ _ O O O _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O O _
XL _ O _ _ _ O _ _ _ _ _ O O _ O O _ _ _ O O O O O O O O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O _
XL _ O _ _ _ _ _ O _ _ _ O _ _ _ O _ _ O _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _ _ _ O O O _
XL _ O _ _ O _ _ O _ _ _ _ _ O O O _ O O O O O O O O O O O O _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _
XL _ _ O _ O _ _ O O _ O _ _ O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O _ _ O _ O O _ _ O _ O _ _
XL _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ O O O O O O O O O O O O _ O O O _ _ _ _ _ O _ _ O _ _ O _
XL _ O O O _ _ _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ O _ _ O _ _ _ O _ _ _ O _ _ _ _ _ O _
XL _ O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ O O O O O O O O O _ _ _ O O _ O O _ _ _ _ _ O _ _ _ O _
XL _ O O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ O O O _ _ O _ _ O O O _ _ _ O _ _
XL _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O O O _ O O O _ _ _ O _ _ _ _ O O _ _ _ _ _ O O _ _ _
XL _ _ O _ O _ _ O O _ O _ _ _ _ _ _ _ _ O _ _ _ O _ _ _ _ _ _ _ _ _ _ O O O O O _ _ _ _ _ _
XL _ O _ _ O _ _ O _ _ _ _ _ _ _ _ _ _ O _ O _ O _ O _ _ _ _ _ _ _ O _ _ _ _ O _ _ _ _ _ _ _
XL _ O _ _ _ _ _ O _ _ _ _ _ _ _ _ _ _ O _ O _ O _ O _ _ _ _ _ _ _ O _ _ O O _ _ _ _ _ _ _ _
XL _ O _ _ _ O _ _ _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ _ _
XL _ _ O _ _ _ O O O _ _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O _ _ _ _ _ _ _ O O _ _ _ _ _ _ _ _ _ _
XL _ _ _ O O _ _ _ _ _ _ _ _ _ _ _ _ O _ _ O _ O _ _ O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ O O O O O _ O _ _ _ _ O O O _ _ _ O O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ O _ _ _ _ O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ O O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ O _ _ O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ O _ O _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
XGEN 0
XEND
END_OF_FILE
  if test 3531 -ne `wc -c <'1993/dgibson.data5'`; then
    echo shar: \"'1993/dgibson.data5'\" unpacked with wrong size!
  fi
  # end of '1993/dgibson.data5'
fi
if test -f '1993/dgibson.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/dgibson.hint'\"
else
  echo shar: Extracting \"'1993/dgibson.hint'\" \(1756 characters\)
  sed "s/^X//" >'1993/dgibson.hint' <<'END_OF_FILE'
XBest Abuse of the C Preprocessor: <dgibson@cs.uct.ac.za> David Gibson
X
X	David Gibson
X	University of Cape Town
X
X	1 Sweet Valley Road
X	Bergvliet
X	7945
X	South Africa
X
X
XJudges' comments:
X
X    To use:
X	sh ./dgibson.sh [datafile]
X
X    where:
X	datafile	initial pattern (default: dgibson.data1)
X    
X    We have provided the shell script 'dgibson.sh' to make it easier
X    to run this entry.  Run this shell script several times to
X    see what happens.
X
X    There are a number of data files available:
X
X	dgibson.data1
X	dgibson.data2
X	dgibson.data3
X	dgibson.data4
X	dgibson.data5
X
X    For dgibson.data5 you will need a large screen, lots of virtual
X    memory and lots of time!
X
X    Good luck trying to use a debugger on this entry!  Life is not
X    always pretty.
X
X
XSelected notes from the author:
X
X    This program plays the Game of Life.
X
X    Life is a cellular automaton invented by J. H. Conway, in which each of
X    a rectangular grid of cells can be alive or dead, and cells with more
X    than 3 or less than 2 (out of 8) live neighbours die, and empty cells
X    with exactly 3 neighbours give birth.
X
X    Some notes: the "STAT n" information does not have to be present in the
X    initial configuration;  the initial configuration should not have live
X    cells around the edges; the grid should be a perfect rectangle.
X
X    Further features: the current generation number is preserved, and the
X    grid automatically resizes itself as the object gets too big or too
X    small.
X
X	When writing this program, my goal was to make each cell in the life
X	grid expand to the code which calculates the fate of that cell.  In
X	addition, the resulting program is a single expression, which makes it
X	necessary to recurse on main in two "directions" simultaneously.
X
END_OF_FILE
  if test 1756 -ne `wc -c <'1993/dgibson.hint'`; then
    echo shar: \"'1993/dgibson.hint'\" unpacked with wrong size!
  fi
  # end of '1993/dgibson.hint'
fi
if test -f '1993/ejb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ejb.c'\"
else
  echo shar: Extracting \"'1993/ejb.c'\" \(2422 characters\)
  sed "s/^X//" >'1993/ejb.c' <<'END_OF_FILE'
X
X
X                     static signed char a[] = {0x69,
X                   110, 118, 97, 108, 105,  0x64, 1-1,
X                 0x6d, 111, 118,  101, 1<<1<<1<<1<<1<<1,
X                 114,  105, 0x6e,  103,  32, 'o'/3, 100,
X                 32, 102, 114, 111,  0x6d, 32, 115, 116,
X                 97, 100-001, 107, 32,37, 2*'2', '@'>>1,
X                 116, '%' + '%' + '%','w'-'W',115, 0x74,
X                 97, 3*'!', 107, 'q' - 'Q', 37, 10*'\n',
X                 10, 0}, * b = a + (1<<1<<1<<1), * w, x,
X                 *q, c, r; int main(int d, char *e []) {
X                 return q = (signed char *)(e+1+1), (r =
X                 e[0] && e[1] ? 0 : 0 * puts (a) + 1) ||
X                 (r = e[1<<1] && d != 1 <<1 && 0 * puts(
X                 a) + 1) || e[1- -1] ||  (r = atoi(e[1])
X                 < -0200 || atoi (e [1]) > 0x7f || ( x =
X                 atoi( e[1] ) ) == 0 ? 0 * puts(a) + 1 :
X                 0) || e [1- -1] || (x- -x > 1-1 ? (q[0]
X                   = x, q[1] = q[3] = 1, q[2] = 2) : (
X                     memset ( w = ( signed  char * )
X
X
X
X
X
X
X
X                     malloc(-x), '1', -x), puts (w),
X                   q[0] = x, q[1] = '0', q[2] = q[3] =
X                 0)), r || (q[3] ? (c = 6 - q[1] - q[2],
X                 (q[0] != 1) ? q[0]-- , d = q[2], q[2] =
X                 c, main(2, e), c = q[2], q[2] = d, q[0]
X                 ++ : 0, printf(b, q[0], q[1], q[2]), (q
X                 [0] != 1) ? q[0]--, d = q[1],q[1] = c ,
X                 main(2, e), c = q[1], q[1] = d, q[0] ++
X                 : 0) : - 1 - q[0] - 1 == 0 ? (w[- x - 1
X                 - (q[1] & 1 ^ 1)] = q[1], puts (w), w [
X                 - x - 1 - (q[1] & 1)] = q[1], puts(w) )
X                 : - 1 - q[0] == 0 ?  (w[- x - 1] = q[ 1
X                   ], puts(w)) : (q[0] += 1 + ( q[1] & 1
X                       ^ 1), main(2, e), q[0] -= 1 + ( q
X                             [1] & 1 ^ 1), q[1] & 1 ? (q
X                                [0]+=1+1,  q[1]^=1, main
X                                (2, e), q[1]^=1, q[0]-=1
X                                +1) : 0, w[q[0] - x] = q
X                               [1], puts(w), q[1] & 1 ?
X                             0 : (q[0]+=1+1, q[1]^=1,
X                           main (2, e), q[1]^=1, q
X                         [0]-=1+1), q[0] += 1 +
X                      (q[1] & 1),main(2,e)
X                  , q[0] -= 1 + (q[1]
X                 & 1) ) ), r; }
END_OF_FILE
  if test 2422 -ne `wc -c <'1993/ejb.c'`; then
    echo shar: \"'1993/ejb.c'\" unpacked with wrong size!
  fi
  # end of '1993/ejb.c'
fi
if test -f '1993/ejb.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/ejb.hint'\"
else
  echo shar: Extracting \"'1993/ejb.hint'\" \(3138 characters\)
  sed "s/^X//" >'1993/ejb.hint' <<'END_OF_FILE'
XBest Obfuscated Algorithm: <ejb@ERA.COM> E. Jay Berkenbilt
X
X	E. Jay Berkenbilt
X	Engineering Research Associates
X	1595 Springhill Road
X	Vienna, VA 22182-2235
X	USA
X
X
XJudges' comments:
X
X    To run:
X	make ejb
X	./ejb level
X
X    where:
X	level   a value from -128 to 127
X
X     A negative argument plays the patience puzzle.  An argument
X     greater than 0 plays the Tower of Hanoi puzzle.  In either case
X     the absolute value of the argument specifies the size of the
X     respective puzzle.  Refer to the files ejb.explain1 and
X     ejb.explain2 for more information on these puzzles.
X
X     Of course, you need a different kind of "patience" if you give
X     the argument 127 to this program and want to see it finish!
X
X
XSelected notes from the author:
X
X    WHAT THIS PROGRAM DOES
X    ======================
X
X    ./ejb 5		Output: solution to Towers of Hanoi for five rings
X    ./ejb -6		Output: solution to the Patience puzzle for six rings
X
X    The format of the output for the Towers of Hanoi case is simply a
X    text description of how to solve the puzzle.  For the patience
X    puzzle, the output is a sequence binary codes representing
X    successive states of the puzzle.  The rightmost digit represents
X    the first ring.  A "1" means the ring is on the U; a "0" means it
X    is off the U.  The program prints the word "Invalid" in response to
X    illegal command line parameters.
X
X    MOTIVATION
X    ==========
X    Most people who have written software for other people have been
X    asked to count lines of code.  Naturally, this brings up the
X    controversial question of exactly what defines a line of code.
X    This program serves to show that counting semicolons will not
X    always provide a meaningful measure of code size.  This is
X    especially true in this program where the number of semicolons
X    itself is ambiguous.  Does it have two or three?  In addition, the
X    only "C" keyword this program uses besides type names and
X    qualifiers is "return", and the only function defined in the code
X    is "main".  The level of complexity of the program without multiple
X    semicolons, statements, and functions is achieved by abusing C
X    operators, especially the comma operator.  Considerable use of ||,
X    &&, and ? : helps too.  In addition, main is called recursively.
X    The null pointer that terminates argv is used to pass additional
X    information into main.  Even though the algorithms used by this
X    code are simple, this program is still hard to follow even when
X    indented properly.  (It is pretty hard to indent this code
X    reasonably, however.)
X
X    Although this program is has only been tested on UNIX systems but
X    will probably run on just about any machine with an ANSI C
X    compiler.  It does not use the C preprocessor at all.  The only
X    functions it uses are atoi, malloc, memset, printf, and puts.  It
X    does, however, require that the architecture it runs on have bytes
X    that are at least eight bits long and pointers that are at least
X    four bytes long.  In addition, it requires an ANSI compiler since
X    it uses "signed char" and ANSI-style function declarations.
END_OF_FILE
  if test 3138 -ne `wc -c <'1993/ejb.hint'`; then
    echo shar: \"'1993/ejb.hint'\" unpacked with wrong size!
  fi
  # end of '1993/ejb.hint'
fi
if test -f '1993/jonth.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/jonth.c'\"
else
  echo shar: Extracting \"'1993/jonth.c'\" \(2221 characters\)
  sed "s/^X//" >'1993/jonth.c' <<'END_OF_FILE'
X  G	int i,j
X  K	case
X  R	return 0
X  S(	x,y) for(x=0; x<y; x++)
X  I	S(i,10
X  z	I-6)B[t][u
X  t	(X[m].b[i].i+g)
X  u	(X[m].b[i].j+l)
X  M(	x,y) XFillRectangles(D,p,x,a,y);
X  s	B[i][j
X  W	=XCreateGC(D,p,4,L)
X  E(	W,_) k=0; I)S(j,22)if(W s]){ a[k].x=i*20; a[k].y=j*20+30; a[k].w=a[k].h=_; k++; }M(
X  A(	W,_) &&!B[W]; if(!j){ z]=1; R; } else{ N(m); _; v(0); }
X  Q	]=0; I-6&&j)j=
X  F	I-6)B[X[w].b[i].i+g][X[w].b[i].j+l
X  e(	x) break; K x:q(c,j,x);
X  H	(m){ G; I-6){ a[i].x=t*20; a[i].y=u*20+30; a[i].w=a[i].h=
X  v(	_) d(m); z+_]=1; R+1;
Xstruct{
X	short x,y,w,h;
X} a[220],C;
Xstruct{
X	struct{
X		G;
X	} b[4];
X} X[99];
XG,l,g=3,p,B[10][22],L[99],o[99],n,r,h,_[4],D,J,T;
Xf(){
X	*L=2;
X	n||XSendEvent(D,p,n=1,0,L),XFlush(D);
X	P();
X}
XZ(){
X	_[1]=_[3]=(9-h)*40000;
X	setitimer(0,_,0);
X}
Xmain(){
X	G,*_=(int*)X;
X	char*c=
X"*{{{ {}{{*{{{ {}* {    {{*{{{   *{{{ {* {* * {  {{ {  { *{* {   {* *{{{ *{{{ {   * {  { *{{{ {{  *{{ {  {{* {   {*{{ {{ {{ {* { {*{{ {  *{{{{    *{{ {{ ";
X	for(; *c; )
X		*_++=(unsigned)(*c+++2)%4;
X	srand(time(0));
X	L[10]=32769;
X	D=XOpenDisplay(0);
X	L[1]=L[2]=XWhitePixel(D,j=XDefaultScreen(D));
X	XMap@p=XCreate@XRoot@j),0,0,200,470,2,0,1,0,2056,L));
X	T W;
X	L[2]=XBlackPixel(D,j);
X	J W;{
X		G,O=0,c=0;
X		Z(P());
X		q(c,c,1);
X		for(; ; ){
X			i=lK();
X			j=c;
X			switch(i){
X				K 'k':c=q(c="$#&'(%)+,-*/01.3254"[c]-35,j,4)?c:j;
X				e('j')e('l')e(32)}
X			if(n){
X				if(!q(c,j,2)){
X					G,n;
X					for(j=21;j-1;j--){
X						n=1;
X						I&&n)n=s];
X						n&&(X9(j++),O++);
X					}
X					n=0;
X					I&&!n)n=B[i][21];
X					Y();
X					r++;
X					c=rand()%19;
X					if(!q(c,c,3))
X						R+puts(L);
X						U(Z(h=O/9));
X					}
X				n=0;
X			}
X		}
X	}
X}
XY(){
X	G,E(,19)J,k)E(!,20)T,k)U();
X}
XlK(){
X	XNextEvent(D,o);
X	switch(*o){
X		K 2:R+o[2]?0:XX k){
X			G=1;switch(k){
X				K 1:z+l]=1;
X				d(m);R+1;
X				K 'j':z Q t A(t-1][u,g--)K 'l':z Q t<9
X				A(1+t][u,g++)K 4:F Q
X				u<22&&t>=0&&t<10&&!B[t][u ];
X				if(!j){
X					F]=1;
X					R;
X				}
X			N(w);
X		v(0)K 32:for(;
X	q(m,m,2);
X	)n=r++;
X	R+1;
X	K 3:l=0;
X	g=3;
X	I-6&&j)j=!B[t][u+l ];
X	if(!j)R;
X	v(l)K 2:z Q(u+1)<22 A(t][u+1,l++)}
X	R;
X}
XX9(_){
X	G;
X	for(j=_; j; j--)I)s]=s-1];
X}
XU(){
X	void*a=&C;
X	C.w=200;
X	C.h=30;
X	M(T,1);
X	sprintf(L,"Score%9d Level%9d",r,h);
X	XDrawString(D,p,J,7,15,L,29);}
XP(){
X	signal(14,f);
X}
X
END_OF_FILE
  if test 2221 -ne `wc -c <'1993/jonth.c'`; then
    echo shar: \"'1993/jonth.c'\" unpacked with wrong size!
  fi
  # end of '1993/jonth.c'
fi
if test -f '1993/leo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/leo.c'\"
else
  echo shar: Extracting \"'1993/leo.c'\" \(1731 characters\)
  sed "s/^X//" >'1993/leo.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <malloc.h>
X#include <string.h>
X
X#define A(x) (e^d)&i?e:(e+=i+i/15-d,d<<=4,i<<=4,x)
X#define B b+=!((e^d)&i)&&(d|=i),i<<=4,
X#define C i=15,B B B B d=d<<4|d>>12,
X#define D=(d=g,b=0,C b<<=4, C C C b)
X#define E if(**y)goto
X#define F=a[rand()%c]
X#define G unsigned short
X#define H e^=a[z],a[z]^=e,e^=a[z],
X
Xvoid
X    main
X	(int
X	    z,char
X		**y)
X		    {G*a
X			,b,c
X			    ,d,e
X				,f,g
X				    ,h,i
X					;*(*
X					    y+=
X						strlen
X						    (*y)
X							-1)^=
X							    'd';
X								srand
X								    (time
X									(0))
X									    ;z==
X									2&&
X								    sscanf
X								(y[1
X							    ],"%d"
X							,&z)
X						    &&z?
X						0:(z
X					    =6);
X					if(!
X				    (a=(
X				G*)
X			    calloc(
X			z*z*
X		    z*z,
X		sizeof
X	    (G))
X	)){
X    printf
X("No\
X    memory\
X	\n");
X	    exit
X		(1);
X		    }for
X			(c=1
X			    ;i=15
X				,d=z
X				    ,c<z
X					*z*z
X					    *z&&
X						(e=a
X						    [c-1
X							]+1,
X							    a[c]
X								=A(A
X								    (A(A
X									(0))
X									    )),1
X									);c++
X								    );*(
X								**y?
X							    &g:&
X							e)F;
X						    do{
X						printf
X					    ("(%d): ????\b\b\b\b"
X					,c);E
X				    q0;else
X				goto
X			    q1;q0:
X			printf
X		    ("%04X\n"
X		,g+
X	    4369
X	);E
X    q2;q1:
Xscanf
X    ("%hx"
X	,**y
X	    ?&h:
X		&g);
X		    E q3
X			;g-=
X			    4369
X				;q2:
X				    printf
X					("??\b\b"
X					    );E q1;
X						printf(
X						    "%02x\n"
X							,h D
X							    );q3
X								:for
X								    (z=f
X									=0;(
X									   z<c||
X									(c=f
X								    ,0))
X								&&(H
X							    b D!=
X							h,H b
X						    ||(a[
X						f++]=
X					    a[z])
X					,1);z
X				    ++);
X				}while
X			    (h!=
X			64&&
X		    c>0&&
X		((g F
X	    ),1)
X	);printf
X    ("\n"
X);}
END_OF_FILE
  if test 1731 -ne `wc -c <'1993/leo.c'`; then
    echo shar: \"'1993/leo.c'\" unpacked with wrong size!
  fi
  # end of '1993/leo.c'
fi
if test -f '1993/leo.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/leo.hint'\"
else
  echo shar: Extracting \"'1993/leo.hint'\" \(2886 characters\)
  sed "s/^X//" >'1993/leo.hint' <<'END_OF_FILE'
XBest Game: <leo@ipmce.su> Leonid A. Broukhis
X
X	Leonid A. Broukhis
X	Moscow Centre of SPARC Technology
X	123481 Liberty St.,
X	89-1-95 Moscow
X	Russia
X
X
XJudges' comments:
X
X    To make:
X	make leo
X
X    To have the computer guess:
X	leo [colors]
X
X    To guess the computer's number:
X	mind [colors]
X
X    where:
X	colors		number of possible colors (1 to 15) (default: 6)
X    
X    By default, the number of colors if 6.  You may specify a
X    value of between 1 and 15 colors.  See the author's notes
X    for instructions of how to play.
X
X    We look forward to more entries from the newer members of the 
X    International Internet community.
X
X    On some systems, you may need to remove the line:
X
X	#include <malloc.h>
X    
X    or replace that line with:
X
X	#include <sys/types.h>
X	#include <sys/malloc.h>
X
X    to successfully build this entry.
X
X
XSelected notes from the author:
X
X    This program plays mastermind, if you call it by a name ending by
X    'd', otherwise it _solves_ mastermind. Call it without parameters
X    to use 6 digits (colors), or indicate the number of possible digits
X    (you cannot change the number of positions so easily).
X
X    The number in parentheses is the number of possible combinations,
X    based on previous questions and answers.  If you solve the puzzle,
X    "(1)" indicates that your previous moves are enough to give correct
X    answer.  If the program acts as solver and terminates prematurely,
X    it means that you have mistaken in your answers to its guesses.
X    Question marks indicate the number of digits you have to enter
X    (either 4 when you guess or 2 when computer guesses).
X
X    Note that the program uses the same code for both player and
X    solver, and the only place where it makes difference is the
X    interactive part. Many obfuscations have been made to achieve
X    this.  An expression giving (bulls * 16 + cows) from two numbers
X    is, however, quite straightforward :-) , as well as the arithmetic
X    of binary coded colors-base numbers is.
X
X    Limitations: maximum number of digits (colors) is 14 (1..F).
X
X    Suggestions: Use terminal (or emulator) with non-destructive
X    backspaces. Do "disable scrolling" on cmdtool or similar emulators.
X
X    Bugs: Please don't type ^D at the prompt!!
X
X    EXAMPLE: Suppose we think of 1234:
X
X    judges-385> leo
X	(1296): 6433
X	?? 12       # one 3 is a bull, another is a cow, and 4 is a cow
X	(160): 5363
X	?? 02       # both 3's are cows
X	(21): 4231
X	?? 22       # 2 and 3 are bulls, 4 and 1 are cows
X	(2): 4132
X	?? 13       # 3 is a bull; 1, 2 and 4 are cows
X	(1): 1234
X	?? 40       # you may enter everything there
X
X    EXAMPLE: Guess the computer's number:
X
X    judges-387> mind
X	(1296): ???? 1122   # my strategy isn't the best, just as example
X	00
X	(256): ???? 3344
X	20
X	(18): ???? 5566
X	02
X	(6): ???? 3654
X	11
X	(2): ???? 3355
X	00
X	(1): ???? 6444
X	40		   # we have guessed the number
END_OF_FILE
  if test 2886 -ne `wc -c <'1993/leo.hint'`; then
    echo shar: \"'1993/leo.hint'\" unpacked with wrong size!
  fi
  # end of '1993/leo.hint'
fi
if test -f '1993/rince.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/rince.c'\"
else
  echo shar: Extracting \"'1993/rince.c'\" \(2803 characters\)
  sed "s/^X//" >'1993/rince.c' <<'END_OF_FILE'
X/** J.K.Bonfield **
X^	<						 	 							
X^	>						 	 							
X<			#				>						v		
X<			 				 			<					
X<			>				>			<		v		
XX			 				 			X				j
Xx			 				 			X				j
XX	 						x	^						k
X^	 						 	^							
X^	#						 									
XX			 				X			X				X
X
X^	v						 	 							
Xv						 	 						v		
Xv						#	 									
Xv						X	 						 		
Xv						x	 						 		
X>				#			<						v		
X>				 			 				>				
XX				 			 				X			l
Xx				 			 				X			l
X
X41 20
X########################################
X#                                      #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#           X                          #
X########################################*/
X#include <stdio.h>
X#include <curses.h>
X#include <stdlib.h>
X#include <setjmp.h>
X#include <sys/time.h>
Xint _tty_ch;
Xbool _echoit;
Xbool _rawmode;
XSGTTY _tty;
X#define U char
X#define G for(
X#define I )malloc(sizeof(
X
Xtypedef struct z {U x[20]; struct z*y; } j; j*J[2][256];
Xstruct timeval v= {0,1<<17} ;
XU**X,c,*P="noopoqqnr",d;
X
Xj*a(int Q, int i) {
X    G
X    clear(),noecho(),cbreak(); ;
X)
X
X{
X    int x=0,y=0,W=Q,Q=i-1,k;
X    G;
X    y<=Q;
X    (mvaddch(y,x,X[y][x]),++x^W-1)||(x=0,y++));
X    k=y=- --x;
X    G
X    refresh(),c=select(k,&y,0,0,&v)?getch():0;
X    k?++x-W||(x=1,++y-Q||(--k,x=W-1,y=Q-1)):--x||(y--,x=W-1),k|y;
X)
X
X{
X    j *t;
X    G
X    t=J[1-k][X[y][x]]; t; t=t->y) {
X	U*f=t->x;
X	if (d==f[17]|f[17]==c) {
X	    int i=k&2,u=9,k=1,w=x,_=y,T;
X	    G;
X	    --u||(d-f[8]&&(X[y][x]=f[8]),w---_--,i=0,u=8,k--);) {
X	        _+=P[T=i>u?u:i]-'o';
X	        w+=P[4+T]-'p';
X	        if(k) {
X		    if (d-f[i]&&f[i]-X[_][w]) break;
X		        i++;
X	        } else
X		    f[++i+8]-d && (X[_][w]=f[i+8]);
X}   }   }   }   }   }
X
Xjmp_buf E;
X
Xint main(int open, U**exit) {
X    FILE*C=fopen (
X	open-2?__FILE__:*++exit,P+8);
X	j*t;
X	volatile int Q,Y=0;
X	int i,q; d=open-2?'\t':'*'; L:
X
X	Q=0; G; setjmp(E)<256; Q--
X    )
X    longjmp(E,(J[Y][Q]=0,Q++));
X    G; ; ) {
X	if(!C)return 1;
X	if('\n'==(c=getc(C)))
X	    if(!Y++)goto L; else
X	    {	fscanf(C,"%d %d\n",&i,&q);
X		X=(U**I P++)*q*(i+1));
X	    Q=0; G; Q<q; Q++)
X        X[Q]=(U*)&X[q]+Q*i;
X    
X	fread(*X,(initscr(),q*i),1,C);
X	a(i,Q);
X    }
X    t=(j*I*a(Q--,--Q)));
X    t->y=J[Y][c]; J[Y][c]=t;
X    fgets(t->x,20,C); }
X}
END_OF_FILE
  if test 2803 -ne `wc -c <'1993/rince.c'`; then
    echo shar: \"'1993/rince.c'\" unpacked with wrong size!
  fi
  # end of '1993/rince.c'
fi
if test -f '1993/rince.design' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/rince.design'\"
else
  echo shar: Extracting \"'1993/rince.design'\" \(3411 characters\)
  sed "s/^X//" >'1993/rince.design' <<'END_OF_FILE'
X    Implementation notes
X    --------------------
X
X    Due to the long time this has been slowly evolving, it's hard to describe
X    quite whether it's been `implemented'. I think perhaps evolve is a better
X    term. I basic concept behind the program is to describe a game as a simple,
X    slightly cheaty, cellular automata system, with some of the transitions
X    bound to key presses.
X
X    For instance, assume you wish to make a boulder 'o' roll off a hill '/'
X    A standard automata would have 2 rules something like this:
X
X
X	o..			...	
X	\..  -->  `o'		.o.  -->  `.'
X	...			.\.
X
X
X    However, the system I devised, in order to keep things small and neat(!),
X    was to define a 3x3 to 3x3 map (instead of the 3x3 to 1x1 shown above).
X    Hence:
X
X	.o.	  ...
X	.\.  -->  .\o
X	...	  ...
X
X    This does of course have the odd problem with clashes. What if we want to
X    roll two down boulders down simultaneously towards the same square.
X    I perform no buffering, and so this situation is just a 'fight it out' and
X    let which ever transition has priority win. Such a case may produce the
X    following change of maps (depending on which 'roll' transition is used
X    first).
X
X	o.o			..o	    o..
X	\./	changes to	\o/  or to  \o/
X	...			...	    ...
X
X    I claim that it is possible to perform all of the 3x3 to 1x1 transitions
X    in a 3x3 to 3x3 based system. One other feature added in is a work around
X    for the 'no buffering' problem. if we define an space ship (as in the
X    space invader example) to fly right, and we are 'walking through' our map
X    from top-left to bottom-right, then it is easy to foresee a situation where
X    our space ship would zip right as far as possible in only the one cycle
X    of the automata. However, a similar leftwards-bound space ship would only
X    move the required one square. For this reason I have two lists of
X    transitions and apply them independently of each other; first top-left to
X    bottom right, and the second in the reverse direction. This means that I
X    can make any 'object' move by any amount in a single transition.
X
X    Now comes the key important addition to make it 'game' worthy - the
X    addition of external control by the user. This is done by requesting that
X    some transitions are only valid when a certain key has been pressed.
X    So for example, if we (an @ symbol) wish to move right when the 'l' key
X    is hit we have a transition like:
X
X    Key: l
X	* * *		* * *
X	* @ .		* . @
X	* * *		* * *
X
X    Here I also use wildcards. On the match side (left) of the transition, an
X    asterisk will match against any character. On the update side (right), an
X    asterisk means 'keep whatever was here before'. So the above example
X    simply means to swap the '@' and '.' around when 'l' is pressed. For the
X    purposes of space saving, this transition is shrunk to a single line.
X
X    Key: K
X	a b c		1 2 3
X	d e f		4 5 6
X	g h i		7 8 9
X
X    is written as:
X
X    eabcdfghi512346789K
X
X    If there are no keys needed for this transition, the character '*' should
X    be used instead. Now the format of the game description file is now
X    the following: (angle brackets denote an 'entity' to be defined).
X
X    <top-bot transition>*\n<bot-top transition>*\n<X size>[ \t]+<Y size>\n
X    <map>
X
X    The <X size> should take into account the newline at the end of each line
X    of map, and hence should also be one larger than expected.
END_OF_FILE
  if test 3411 -ne `wc -c <'1993/rince.design'`; then
    echo shar: \"'1993/rince.design'\" unpacked with wrong size!
  fi
  # end of '1993/rince.design'
fi
if test -f '1993/rince.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/rince.orig.c'\"
else
  echo shar: Extracting \"'1993/rince.orig.c'\" \(2749 characters\)
  sed "s/^X//" >'1993/rince.orig.c' <<'END_OF_FILE'
X/** J.K.Bonfield **
X^	<						 	 							
X^	>						 	 							
X<			#				>						v		
X<			 				 			<					
X<			>				>			<		v		
XX			 				 			X				j
Xx			 				 			X				j
XX	 						x	^						k
X^	 						 	^							
X^	#						 									
XX			 				X			X				X
X
X^	v						 	 							
Xv						 	 						v		
Xv						#	 									
Xv						X	 						 		
Xv						x	 						 		
X>				#			<						v		
X>				 			 				>				
XX				 			 				X			l
Xx				 			 				X			l
X
X41 20
X########################################
X#                                      #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#  <   <   <   <   <>  <   <   <       #
X#       >   >   >  <>   >   >   >   >  #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#                                      #
X#           X                          #
X########################################*/
X#include <stdio.h>
X#include <curses.h>
X#include <stdlib.h>
X#include <setjmp.h>
X#include <sys/time.h>
X#define U char
X#define G for(
X#define I )malloc(sizeof(
X
Xtypedef struct z {U x[20]; struct z*y; } j; j*J[2][256];
Xstruct timeval v= {0,1<<17} ;
XU**X,c,*P="noopoqqnr",d;
X
Xj*a(int Q, int i) {
X    G
X    clear(),noecho(),cbreak(); ;
X)
X
X{
X    int x=0,y=0,W=Q,Q=i-1,k;
X    G;
X    y<=Q;
X    (mvaddch(y,x,X[y][x]),++x^W-1)||(x=0,y++));
X    k=y=- --x;
X    G
X    refresh(),c=select(k,&y,0,0,&v)?getch():0;
X    k?++x-W||(x=1,++y-Q||(--k,x=W-1,y=Q-1)):--x||(y--,x=W-1),k|y;
X)
X
X{
X    j *t;
X    G
X    t=J[1-k][X[y][x]]; t; t=t->y) {
X	U*f=t->x;
X	if (d==f[17]|f[17]==c) {
X	    int i=k&2,u=9,k=1,w=x,_=y,T;
X	    G;
X	    --u||(d-f[8]&&(X[y][x]=f[8]),w---_--,i=0,u=8,k--);) {
X	        _+=P[T=i>u?u:i]-'o';
X	        w+=P[4+T]-'p';
X	        if(k) {
X		    if (d-f[i]&&f[i]-X[_][w]) break;
X		        i++;
X	        } else
X		    f[++i+8]-d && (X[_][w]=f[i+8]);
X}   }   }   }   }   }
X
Xjmp_buf E;
X
Xint main(int open, U**exit) {
X    FILE*C=fopen (
X	open-2?__FILE__:*++exit,P+8);
X	j*t;
X	volatile int Q,Y=0;
X	int i,q; d=open-2?'\t':'*'; L:
X
X	Q=0; G; setjmp(E)<256; Q--
X    )
X    longjmp(E,(J[Y][Q]=0,Q++));
X    G; ; ) {
X	if(!C)return 1;
X	if('\n'==(c=getc(C)))
X	    if(!Y++)goto L; else
X	    {	fscanf(C,"%d %d\n",&i,&q);
X		X=(U**I P++)*q*(i+1));
X	    Q=0; G; Q<q; Q++)
X        X[Q]=(U*)&X[q]+Q*i;
X    
X	fread(*X,(initscr(),q*i),1,C);
X	a(i,Q);
X    }
X    t=(j*I*a(Q--,--Q)));
X    t->y=J[Y][c]; J[Y][c]=t;
X    fgets(t->x,20,C); }
X}
END_OF_FILE
  if test 2749 -ne `wc -c <'1993/rince.orig.c'`; then
    echo shar: \"'1993/rince.orig.c'\" unpacked with wrong size!
  fi
  # end of '1993/rince.orig.c'
fi
if test -f '1993/schnitzi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/schnitzi.c'\"
else
  echo shar: Extracting \"'1993/schnitzi.c'\" \(2103 characters\)
  sed "s/^X//" >'1993/schnitzi.c' <<'END_OF_FILE'
X#include      <stdio.h>
X#define            iii\
X(                     I  )                    if (                     ii(I,6\
X )                   )I [               strlen(I  )                     -1]=!1
X          int ii(ll,lll  )              char*ll; {
X
X  char *l="\"; !l ? 1.1 : l; l,printf(";int l1=1-/*+&|");  &+|-*/1,li=!1;while
X
X(                lll>l1  )                 li|=! (                  l[3*l1+++3
X ]           -ll[strlen (                 ll)-1]  )                    ;return
X(                    li  )                ;}main (                      ll,lll
X )  char*lll[];{char l1 [   111][21],li1[111][21  ]              ,il1[111],i1l
X[                   111  ] ;int lli,l11,l1l,li/* (  */,ll1,il,l;FILE*f;if(ll-2
X )             {f=fopen (             lll[1],"r"  )     ;lli=l=ll1=il=!1;while
X( fscanf(f,"%s",l1[lli]  )             +1){li=ii (                   l1[lli],3
X )                 ;iii (                l1[lli]  )          ;l1l=l11=!1;while
X(               l1l>-ll  )                  {iii (                   lll[-l1l]
X )          ;strcasecmp (    lll[-l1l--],l1[lli]  )                         ||
X(              l11=++il  )       ;}l11||lli++;if (                          li
X )                  {if (                 ll1<il  )    {ll1=il;l1l=l=lli;while
X(                 l1l--  )                strcpy (            li1[l1l],l1[l1l]
X )     ;}il=lli=!1;}}if (                   !ll1  )                       puts
X(          " Beats me."  )              ;else if (                          !l
X )                 puts (                " Yes."  ) ;else{*li1[l1l=!1]=toupper
X(              *li1[!1]  )                ;while (                       l>l1l
X )               printf (       " %s",li1[l1l++]  )                      ;puts
X(                   "."  )       ;}}else{sprintf (    il1,"cat %s;echo",lll[1]
X )              ;system (                    il1  )                   ;}printf
X(                "\n? "  )                 ;gets (                         il1
X )             ;sprintf (  i1l,"%s %s %s",lll[!1  ]        ,lll[1],il1);system
X(                 i1l);  }
END_OF_FILE
  if test 2103 -ne `wc -c <'1993/schnitzi.c'`; then
    echo shar: \"'1993/schnitzi.c'\" unpacked with wrong size!
  fi
  # end of '1993/schnitzi.c'
fi
if test -f '1993/schnitzi.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/schnitzi.hint'\"
else
  echo shar: Extracting \"'1993/schnitzi.hint'\" \(2960 characters\)
  sed "s/^X//" >'1993/schnitzi.hint' <<'END_OF_FILE'
XObfuscated Intelligence Award: <schnitzi@longwood.cs.ucf.edu> Mark Schnitzius
X
X	Mark Schnitzius
X	1700 Woodbury Rd. #1208
X	Orlando, FL 32828
X	USA
X
X
XJudges' comments:
X
X    To run:
X	make schnitzi
X	./schnitzi file
X    
X    where:
X	file	a file containing some text
X
X    After this program prints the conte{n}ts of 'file', ask it
X    some questions related to the text.
X    
X    The author suggests the following questions when using schnitzi.info:
X
X	Who is Mark Schnitzius?
X	What exactly does this program do?
X	What language is it written in?
X	Has the Loch Ness monster really been captured?
X	Who was H{i}tler?
X	Were the NASA moon landings faked?
X	Is it true that Elvis is alive?
X	Do colorless green ideas sleep furiously?
X
X    NOTE: The author may also be contacted at: marks@aldrin.ksc.nasa.gov
X
X    We suggest {you} try using the body (minus the header and signature line) 
X    of {a} Usenet article.  You might want to try something from alt.flame.  :-)
X
X
XSelected notes from the author:
X
X    I wanted to write a program that would read in a text file in
X    natural language (such as English) and answer questions about that
X    text file.  I thought this might be a complicated task, and I was
X    right -- it took me over 800 bytes.  Of course, it doesn't always
X    work, but that's AI for you.
X
X    This program accepts the name of a text file as the first
X    parameter.  For example, to run it on the supplied data file called
X    'info' you would type 'schnitzi info'.  It echoes the file, then
X    gives you a prompt where you may type in questions about that text.
X    The more words you use which are actually present in the text file,
X    the better results you get.  You'll need to hit <ctrl-c> to break out
X    of the program.  Just hitting <return> at the prompt will reprint the
X    paragraph.
X
X    If you're curious as to how it works, I guess you could feed in the
X    source as the input file and ask "How does this work?" at the prompt,
X    but I'm not guaranteeing any results...
X
X    Compilation notes:
X
X    o  The use of 'strcasecmp' may be non-standard.  'strcmp'
X       can be substituted for it, with a slight performance penalty.
X
X    o  This program depends on the first command-line parameter, typically
X       called argv[0], to hold the name of the executable.  It is my under-
X       standing that this property of argv[0] is not guaranteed on some
X       systems.
X
X    This program is obfuscated in the following ways:
X
X    o  It uses a hidden string to test for punctuation;
X
X    o  The layout, variable names, and expression format
X       have been chosen in such a way as to cause visual confusion;
X
X    o  It uses uses external 'system' calls to echo the text
X       file and break up the question into individual words with a
X       recursive call;
X
X    o  It uses a clever hack to simulate artificial intelligence.
X
X    The text for the info file, by the way, consists largely of headlines
X    from the Weekly World News.
END_OF_FILE
  if test 2960 -ne `wc -c <'1993/schnitzi.hint'`; then
    echo shar: \"'1993/schnitzi.hint'\" unpacked with wrong size!
  fi
  # end of '1993/schnitzi.hint'
fi
if test -f '1993/vanb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1993/vanb.c'\"
else
  echo shar: Extracting \"'1993/vanb.c'\" \(1956 characters\)
  sed "s/^X//" >'1993/vanb.c' <<'END_OF_FILE'
XO5(O2,O7,O3)char**O7;{return!(O2+=~01+01)?00:!(O2-=02>01)?printf("\045\157\012"
X,O5(012,O7+01,00)):!(O2-=02>>01)?(**O7<=067&&**O7>057?O5(03,O7,*(*O7)++-060+010
X   *O3):O3                     ):!(O2      -=-O3-      ~O3)?       (072>**
X   O7&&060                     <=**O7      ?O5(04      ,O7,012     *O3-060
X    +*(*O7                    )++):O3      ):!(O2      -=!O3+      !!O3)?(
X    **O7>057                  &&**O7       <=071?      O5(05,      O7,*(*
X     O7)+++                   O3*020       -060):      **O7<=      0106&&
X     00101<=                 **O7?O5       (05,O7      ,020*O3     +*(*O7)
X      ++-067)               :0140<**       O7&&**      O7<0147     ?O5(05,
X      O7,-0127              +*(*O7         )+++020     *O3):O3     ):!(
X       O2-=02-             01)?(**         O7==050     ?050**      ++*O7,
X       O5(013,             O7,O5(          012,O7      ,00)):*     *O7<056
X        &&054<*           *O7?055          **++*       O7,-O5(     06,O7,
X        00):054           >**O7&&          052<**      O7?050*     *(*O7)
X         ++,O5(06        ,O7,00            ):!(**      O7^0170     )||!(
X         0130^**         O7)?*++           *O7,O5      (05,O7      ,00):*
X          *O7==0144     ||**O7             ==0104      ?++*O7      ,O5(04,
X           O7,00):      O5(03              ,O7,00      )):!--      O2?(*
X           *O7==052    ?O5(07              ,O7,O3*     (*++*O7     ,O5(06
X           ,O7,00)     )):!(               045-**      O7)?O5(     07,O7,
X            O3%(03+( *O7)++,               O5(06,      O7,00)      )):!(**
X             O7^057)?O5(07,                O7,O3/(     03-*++      *O7,O5(
X             06,O7,00))):O3                ):!(O2      +=01-02     )?O5(07
X             ,O7,O5(06,O7,                 00)):!(     O2+=-02/    02)?(!(*
X*O7-053)?O5(011,O7,O3+(++*O7,O5(010,O7,00))):!(055^**O7)?O5(011,O7,O3-(03+*(*O7
X)++,O5(0010,O7,00))):O3):!(O2-=0563&0215)?O5(011,O7,O5(010,O7,00)):(++*O7,O3);}
END_OF_FILE
  if test 1956 -ne `wc -c <'1993/vanb.c'`; then
    echo shar: \"'1993/vanb.c'\" unpacked with wrong size!
  fi
  # end of '1993/vanb.c'
fi
echo shar: End of archive 3 \(of 4\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
