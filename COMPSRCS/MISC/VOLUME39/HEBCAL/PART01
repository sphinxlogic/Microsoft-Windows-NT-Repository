Newsgroups: comp.sources.misc,soc.culture.jewish
From: sadinoff@unagi.cis.upenn.edu (Danny Sadinoff)
Subject: v39i108:  hebcal - A Jewish calendar generator, v2.1, Part01/01
Message-ID: <1993Sep28.125353.6997@sparky.sterling.com>
X-Md4-Signature: 4dbb81a4e209c59989672edb5ed29909
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: University of Pennsylvania
Date: Tue, 28 Sep 1993 12:53:53 GMT
Approved: kent@sparky.sterling.com

Submitted-by: sadinoff@unagi.cis.upenn.edu (Danny Sadinoff)
Posting-number: Volume 39, Issue 108
Archive-name: hebcal/part01
Environment: UNIX
Supersedes: hebcal: Volume 35, Issue 76

            [ THIS PROGRAM IS GUILTWARE  -Kent+ ]

Hebcal 2.1  - a program for printing Jewish calendars
  by Danny Sadinoff

DESCRIPTION
Hebcal is a program which prints out the days in the Jewish calendar
for a given gregorian year.  Hebcal is fairly flexible in terms of which
events in the Jewish calendar it displays.  Each of the following can
be individualy turned on or off:

  The Hebrew date
  Jewish Holdiays (including Yom Ha'atzmaut and Yom HaShoah etc.)
  The weekly Sedrah
  The day of the week
  The days of the Omer

CHANGES 
Since version 2.0:
  Fixed some minor bugs: the date of purim katan and taanit bechorot.
  Added -a Ashkenazis hebrew option.
  Added -y 2 digit year option
  Added -r Tab-delinated format option.


DISTRIBUTION
This program is GUILTWARE. 
It may be distributed freely, with a few conditions:
   1) The package must be distributed INTACT with ALL source code, as
   well as this file.  You are welcome to modify the code,
   but DON'T distribute it modified.  This section should certainly
   appear with every distributed copy.
   
   2) If you are going to use this program, please drop me a line.
   I'd like to know who you are, what version you're using, and how
   you're using hebcal, and anything else you'd like to tell me, so
   that I can adjust the program to meet users' needs.

   I am NOT demanding payment for the use of my program, but writing
   this program DID take time.  Feel free to send $10 to
   me at my US Mail address. (hint)

   send US Mail to:        send email to:
    Danny Sadinoff	   sadinoff@eniac.seas.upenn.edu
    1 Cove La. 
    Great Neck, NY 11024

   Email respondents will receive notifications of new versions as they
   come out, as will US Mail responents (if they send me postage for a disk).

 
COMPILATION
The code has K&R "old style" declarations in it, so it should compile
on most machines.
The distribution includes a "Makefile" so once you've unpacked all the
files, (including this one) just run the command "make" and that
should compile everything for you.

The file hebcal.1 is the manual page.  For information on using man in
conjunction with local manpages, see the manpage for man.  Briefly, to
read a manpage, type 
nroff -man <filename> | more


DISCLAIMER
I tried to make this program as accurate as possible.  However, I
take no responsibility for any horrible consequences which may come
about as a result of faulty output from this program.  This program
should in no way be invested with halachic authority.

The secular dates before september 1752 are off by two weeks due to
the correction that took place then.

The secular dates before 1522 become progressively meaningless, as I
made no correction for the changeover from julian to gregorian
calendars; but the Hebrew dates and years are correct.

COMING SOON
Features to be included in future versions:
  - The ability to specify and output a particular HEBREW year, month
    or date. 
  - hebrew output.

GRIPES
send questions, comments or complaints to:
Danny Sadinoff
sadinoff@eniac.seas.upenn.edu
--------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Makefile danlib.c danlib.h error.c error.h getopt.c
#   getopt.h greg.c greg.h hebcal.1 hebcal.c hebcal.h proto.h start.c
# Wrapped by kent@sparky on Tue Sep 28 07:40:04 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(5984 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XHebcal 2.1  - a program for printing Jewish calendars
X  by Danny Sadinoff
X
XDESCRIPTION
XHebcal is a program which prints out the days in the Jewish calendar
Xfor a given gregorian year.  Hebcal is fairly flexible in terms of which
Xevents in the Jewish calendar it displays.  Each of the following can
Xbe individualy turned on or off:
X
X  The Hebrew date
X  Jewish Holdiays (including Yom Ha'atzmaut and Yom HaShoah etc.)
X  The weekly Sedrah
X  The day of the week
X  The days of the Omer
X
XCHANGES 
XSince version 2.0:
X  Fixed some minor bugs: the date of purim katan and taanit bechorot.
X  Added -a Ashkenazis hebrew option.
X  Added -y 2 digit year option
X  Added -r Tab-delinated format option.
X
XSince version 1.4:
X  Optimized code, with an eye towards the -t and -T switches
X  Added -i user events option.
X  Added -S "what's this week's sedra?" option
X
XSince version 1.3:
X  This is a quickie fix of the new Chanukah routine added in the last release
X  I also changed the suffix of the manpage from .l to .1, since it was
X     causing some versions of make to compile the manpage as a lex
X     file, destroying the source code in the process.
X  Added Yom Yerushalayim 
X   changed output format from "24 of Kislev" to "24th of Kislev"
X
XSince version 1.2:
X  Fixed a critical bug which put Purim on the 15th of Adar, instead of
X    the 14th
X  Now uses sys/types.h instead of stdlib.h
X  Added the rest of the 8 days of Chanukah
X  Added -e European output switch.
X
XSince version 1.1, the following changes were made:
X  Changed usage-- the -p "parshiot" switch was changed to "-s" sedrot switch
X  Fixed certain slippery variable type bugs
X  Changed code to K&R old style
X  Added Manpage
X  Decided to change the "Distribu-Ware" to a normal shareware.
X
XDISTRIBUTION
XThis program is GUILTWARE. 
XIt may be distributed freely, with a few conditions:
X   1) The package must be distributed INTACT with ALL source code, as
X   well as this file.  You are welcome to modify the code,
X   but DON'T distribute it modified.  This section should certainly
X   appear with every distributed copy.
X   
X   2) If you are going to use this program, please drop me a line.
X   I'd like to know who you are, what version you're using, and how
X   you're using hebcal, and anything else you'd like to tell me, so
X   that I can adjust the program to meet users' needs.
X
X   I am NOT demanding payment for the use of my program, but writing
X   this program DID take time.  Feel free to send $10 to
X   me at my US Mail address. (hint)
X
X   send US Mail to:        send email to:
X    Danny Sadinoff	   sadinoff@eniac.seas.upenn.edu
X    1 Cove La. 
X    Great Neck, NY 11024
X
X   Email respondents will receive notifications of new versions as they
X   come out, as will US Mail responents (if they send me postage for a disk).
X
X 
XCOMPILATION
XThe code has K&R "old style" declarations in it, so it should compile
Xon most machines.
XThe distribution includes a "Makefile" so once you've unpacked all the
Xfiles, (including this one) just run the command "make" and that
Xshould compile everything for you.
X
XThe file hebcal.1 is the manual page.  For information on using man in
Xconjunction with local manpages, see the manpage for man.  Briefly, to
Xread a manpage, type 
Xnroff -man <filename> | more
X
X
XOPERATION:
XThe operation of hebcal is fairly simple.  Hebcal defaults to printing
Xout the holidays for the current gregorian year.  With the
Xcommand-line options, a specific gregorian year, month or date can be
Xspecified.  
X
XGiven one numeric argument, hebcal will print out the calendar 
Xfor that year.  Given two numeric argumetnts mm yyyy, it
Xprints out the calendar for month mm of year yyyy.  Given three
Xnumeric arguments mm dd yyyy, it will print out the hebrew calendar
Xentries for day dd of month mm of year yyyy.  In the last case, the -d
Xoption is automatically enabled.
X
XNOTE 
XBe sure to give the whole year to hebcal.  
Xhebcal 92 will return the calendar for a time somewhere in the Roman 
Xera, not in the twentieth century.  Use hebcal 1992 instead.
X
Xusage: hebcal [-adehorsStTwy] [-i filename] [[month [day]] year]  
X       hebcal help --- prints this message. 
X
XOPTIONS:  
X   -a : Ashkenazis Hebrew
X   -d : add hebrew dates
X   -e : use European dates (dd mm yyyy) for OUTPUT ONLY (input format
X        the same)
X   -h : suppress holidays
X   -i : draw user-defined calendar events from the specified file
X   -o : add days of the omer
X   -r : use tab-delinated format
X   -s : add weekly sedrot on Saturdays
X   -S : add sedra of the week every day
X   -t : only output today's date.  This switch implies the -d switch.
X   -T : only output today's date, suppressing gregorian date. This
X        switch implies the -d and -o switches.
X   -w : add day of the week
X   -y : use two-digit year
X
X
XExamples: 
Xexample% hebcal -ho
X4/19/1992 1st day of the Omer
X4/20/1992 2nd day of the Omer
X4/21/1992 3rd day of the Omer
X4/22/1992 4th day of the Omer
X4/23/1992 5th day of the Omer
X4/24/1992 6th day of the Omer
X.
X.
X6/5/1992 48th day of the Omer
X6/6/1992 49th day of the Omer
X
Xto find out what's happening in today's Jewish calendar, use
Xexample% hebcal -ToS
X19 of Nisan, 5752
XPesach V (CH"M)
X4th day of the Omer
X
X
XDISCLAIMER
XI tried to make this program as accurate as possible.  However, I
Xtake no responsibility for any horrible consequences which may come
Xabout as a result of faulty output from this program.  This program
Xshould in no way be invested with halachic authority.
X
XThe secular dates before september 1752 are off by two weeks due to
Xthe correction that took place then.
X
XThe secular dates before 1522 become progressively meaningless, as I
Xmade no correction for the changeover from julian to gregorian
Xcalendars; but the Hebrew dates and years are correct.
X
XCOMING SOON
XFeatures to be included in future versions:
X  - The ability to specify and output a particular HEBREW year, month
X    or date. 
X  - hebrew output.
X
XGRIPES
Xsend questions, comments or complaints to:
XDanny Sadinoff
Xsadinoff@eniac.seas.upenn.edu
END_OF_FILE
  if test 5984 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(126 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XCFLAGS = -O
XCC = cc
XOBJ= start.o hebcal.o greg.o error.o danlib.o getopt.o
Xhebcal:  $(OBJ)
X	 $(CC) $(OBJ) -o hebcal $(CFLAGS)
END_OF_FILE
  if test 126 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'danlib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'danlib.c'\"
else
  echo shar: Extracting \"'danlib.c'\" \(1285 characters\)
  sed "s/^X//" >'danlib.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/types.h>
X#include <ctype.h>
X#include "danlib.h"
X#include "error.h"
X
X/* Some generally useful routines */
X  
Xvoid initStr(s,size)
Xchar **s;
Xint size;
X{
X  /* allocate space for a string */
X  if ((*s = (char *)malloc((size_t) (size + 1) * sizeof(char))) == NULL)
X    die("\n Memory Error: Couldn't allocate string\n","");
X
X  **s = '\0';
X}
X
Xint isAllNums(s)
Xchar * s;
X{
X/* returns true if a string contains only digits, dashes and newlines */
X  int n = 0, len = strlen(s);
X  
X  for(n=0;
X      (n < len)  &&  ( isdigit(s[n]) || (s[n] == '-') || (s[n] == '\n'));
X      n++);
X  return (n == len);
X}
X
Xchar * numSuffix(i)
Xint i;
X{
X/* returns he proper ordinal suffix of a number */
X  if ((i / 10) == 1) return "th";
X  switch (i % 10) {
X  case 1 : return "st";
X  case 2 : return "nd";
X  case 3 : return "rd";
X  default: return "th";
X  }
X}
X
Xchar * itoa (i) 
Xint i;
X{
X  static char ret[7];
X  int c = 0;
X  char tmp;
X
X  if (i < 0) {			/* is i negative? */
X    ret[c++] = '-';		/* then put a minus */
X    i = abs(i);
X  }
X  
X  while (i >0) {		/* compose the number */
X    ret[c++] = (i % 10) + '0';
X    i /= 10;
X  }
X  i = c-1;
X  
X  for (c =0; c < i; c++) {	/* reverse the number */
X    tmp = ret[c];
X    ret[c] = ret[i-c];
X    ret[i-c] = tmp;
X  } 
X
X  return ret;
X}
X 
X
END_OF_FILE
  if test 1285 -ne `wc -c <'danlib.c'`; then
    echo shar: \"'danlib.c'\" unpacked with wrong size!
  fi
  # end of 'danlib.c'
fi
if test -f 'danlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'danlib.h'\"
else
  echo shar: Extracting \"'danlib.h'\" \(187 characters\)
  sed "s/^X//" >'danlib.h' <<'END_OF_FILE'
X#ifndef __DANLIB__
X#define __DANLIB
X
X#define CHAR2NUM(x) ((x) - '0')
X#define LAST_INDEX(x) (sizeof x / sizeof x[0])
X
Xint isAllNums();
Xvoid initStr();
Xchar * numSuffix(), *itoa();
X
X#endif
END_OF_FILE
  if test 187 -ne `wc -c <'danlib.h'`; then
    echo shar: \"'danlib.h'\" unpacked with wrong size!
  fi
  # end of 'danlib.h'
fi
if test -f 'error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error.c'\"
else
  echo shar: Extracting \"'error.c'\" \(589 characters\)
  sed "s/^X//" >'error.c' <<'END_OF_FILE'
X#include "error.h"
X
Xextern int errno, sys_nerr;
Xextern char *sys_errlist[], *progname;
X
Xvoid die (s1,s2)	/* print error message and die */
Xchar *s1, *s2;
X{
X  if (progname)
X    fprintf(stderr, "%s: ", progname);
X  fprintf(stderr, s1, s2);
X  if (errno > 0 && errno < sys_nerr)
X    fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X  exit(1);
X}
X
Xvoid warn (s1,s2) /* print error message but don't die */
Xchar *s1, *s2;
X{
X  if (progname)
X    fprintf(stderr, "%s: ", progname);
X  fprintf(stderr, s1, s2);
X  if (errno > 0 && errno < sys_nerr)
X    fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X}
END_OF_FILE
  if test 589 -ne `wc -c <'error.c'`; then
    echo shar: \"'error.c'\" unpacked with wrong size!
  fi
  # end of 'error.c'
fi
if test -f 'error.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error.h'\"
else
  echo shar: Extracting \"'error.h'\" \(102 characters\)
  sed "s/^X//" >'error.h' <<'END_OF_FILE'
X#ifndef __ERROR__
X#define __ERROR__
X#include <stdio.h>
X#include <errno.h>
X
Xvoid die(), warn();
X#endif
END_OF_FILE
  if test 102 -ne `wc -c <'error.h'`; then
    echo shar: \"'error.h'\" unpacked with wrong size!
  fi
  # end of 'error.h'
fi
if test -f 'getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.c'\"
else
  echo shar: Extracting \"'getopt.c'\" \(1927 characters\)
  sed "s/^X//" >'getopt.c' <<'END_OF_FILE'
X/* optarg - parse command-line arguments */
X/* Author: AT&T */
X
X#include <stdio.h>
X
X#define ERR(S, C) if(opterr){\
X	char errbuf[3];\
X	errbuf[0] = C; errbuf[1] = '\n'; errbuf[2] = '\0';\
X	fprintf(stderr,"%s", argv[0]);\
X	fprintf(stderr, "%s", S);\
X	fprintf(stderr, "%s", errbuf);}
X
Xextern int strcmp();
Xextern char *strchr();
Xextern int strlen();
X
Xint	opterr = 1;		/* getopt prints errors if this is on */
Xint	optind = 1;		/* token pointer */
Xint	optopt;			/* option character passed back to user */
Xchar	*optarg;		/* flag argument (or value) */
X
Xint	/* return option character, EOF if no more or ? if problem */
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv;
Xchar	*opts;				/* option string */
X{
X	static int sp = 1;		/* character index in current token */
X	register char *cp;		/* pointer into current token */
X
X	if(sp == 1)
X		/* check for more flag-like tokens */
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == 0) {
X			optind++;
X			return(EOF);
X		}
X	optopt = argv[optind][sp];
X	if(optopt == ':' || (cp=strchr(opts, optopt)) == 0) {
X		ERR(": illegal option -- ", optopt);
X		/* if no chars left in this token, move to next token */
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X
X	if(*++cp == ':') {	/* if a value is expected, get it */
X		if(argv[optind][sp+1] != '\0')
X			/* flag value is rest of current token */
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": option requires an argument -- ", optopt);
X			sp = 1;
X			return('?');
X		} else
X			/* flag value is next token */
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		/* set up to look at next char in token, next time */
X		if(argv[optind][++sp] == '\0') {
X			/* no more in current token, so setup next token */
X			sp = 1;
X			optind++;
X		}
X		optarg = 0;
X	}
X	return(optopt);/* return the current flag character found */
X}
END_OF_FILE
  if test 1927 -ne `wc -c <'getopt.c'`; then
    echo shar: \"'getopt.c'\" unpacked with wrong size!
  fi
  # end of 'getopt.c'
fi
if test -f 'getopt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getopt.h'\"
else
  echo shar: Extracting \"'getopt.h'\" \(336 characters\)
  sed "s/^X//" >'getopt.h' <<'END_OF_FILE'
X#ifndef GETOPT_H
X#define GETOPT_H
X#include "proto.h"				/* define PROTO */
X
Xint getopt PROTO((int, char **, char *));
Xextern char *optarg;				/* current argv string */
Xextern int optind;				/* current argv index */
Xextern int optopt;				/* option character */
Xextern int opterr;				/* getopt prints errors if 1 */
X#endif /* GETOPT_H */
END_OF_FILE
  if test 336 -ne `wc -c <'getopt.h'`; then
    echo shar: \"'getopt.h'\" unpacked with wrong size!
  fi
  # end of 'getopt.h'
fi
if test -f 'greg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'greg.c'\"
else
  echo shar: Extracting \"'greg.c'\" \(2697 characters\)
  sed "s/^X//" >'greg.c' <<'END_OF_FILE'
X#include "greg.h"
X
X/* greg.c gregorian calendar module for hebrew calendar program
X   By Danny Sadinoff
X   (C) 1992
X
X*/
X
Xchar * eMonths[] = { 
X  "January","February","March","April","May","June","July",
X  "August","September","October","November","December"
X  };
X		      
Xint MonthLengths[][12] ={ 
X  {31,28,31,30,31,30,31,31,30,31,30,31},
X  {31,29,31,30,31,30,31,31,30,31,30,31}
X};
X
Xchar * DayNames[] = {
X  "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
X  };
X
Xchar * ShortDayNames[] = {
X  "Sun","Mon","Tue","Wed","Thu","Fri","Sat"
X  };
X
Xstatic void checkRange (dt,routine)
Xdate_t dt;
Xchar * routine;
X{
X  if ((dt.mm > 13)||(dt.dd > 31) || (dt.yy > 7000) || 
X      (dt.mm <0)  ||(dt.dd <0  ) || (dt.yy < -7000))
X    die("Date out of range from routine %s.",routine);
X}
X
Xstatic long int daysSinceOrigin (dt)
Xdate_t dt;
X{
X  int m,y;
X  long int days = 0L;
X
X  checkRange(dt,"daysSinceOrigin");
X
X  for (y =1; y < dt.yy; y++)
X    days += DAYS_IN(y);
X  y = dt.yy;
X  for (m= JAN; m < dt.mm; m++)
X    days += MonthLengths[LEAP(y)][m];
X  days += dt.dd -1;
X  return days;
X}
X
Xint diffDays(d1,d2)
Xdate_t d1, d2;
X{
X  return (int) (daysSinceOrigin(d1) - daysSinceOrigin(d2));
X}
X
Xint exceeds (d1,d2)
Xdate_t d1, d2;
X{
X  if (d1.yy > d2.yy)
X    return 1;
X  else if (d1.yy < d2.yy)
X    return 0;
X  else if (d1.mm > d2.mm)
X    return 1;
X  else if (d1.mm < d2.mm)
X    return 0;
X  else if (d1.dd > d2.dd)
X    return 1;
X  else return 0;
X}
X
Xvoid decDate (dt,n) /* decrements dt by n days */
Xdate_t *dt;
Xint n;
X{
X/*under construction*/
X/*  while (n > 365) {
X    n -= DAYS_IN(dt->yy -1);
X    dt ->yy--;
X  }
X
X
X  if ((dt->mm == FEB) && (dt->dd == 29) && !LEAP(dt->yy))
X    dt->dd--;
X*/
X  
X  while (n--) 
X    if (dt->dd ==1) {
X      if (dt->mm == JAN) {
X	dt->yy--;
X	dt->mm = DEC;
X	dt->dd = 31;
X      }
X      else {
X	dt->mm--;
X	dt->dd = MonthLengths[LEAP(dt->yy)][dt->mm];
X      }
X    }
X    else dt->dd--;
X}
X
Xvoid incDate (dt,n)   /* increments dt by n days */
Xdate_t *dt;
Xint n;
X{
X/*  while (n > 365) {
X    n -= DAYS_IN(dt->yy);
X    dt->yy++;
X  }
X
X  if ((dt->mm == FEB) && (dt->dd == 29) && !LEAP(dt->yy) ) {
X    dt-> mm = MAR;
X    dt-> dd = 1;
X  }
X*/
X  while (n--) 
X   if ((dt->dd + 1) > MonthLengths[LEAP(dt->yy)][dt->mm]) 
X     if (dt->mm == DEC) {
X       dt->yy++;
X       dt->mm = JAN;
X       dt->dd = 1;
X     }
X     else {
X       dt->mm++;
X       dt->dd =1;
X     }
X   else 
X     dt->dd ++;
X}
X
Xint dayOfWeek(d1)  /* sunday = 0 */
Xdate_t d1;
X{
X  return (int) ((daysSinceOrigin(d1) + 1) % 7 ) ;
X}
X
Xvoid setDate (d) 
Xdate_t *d;
X{
X  time_t secs;
X  struct tm *loctm;
X
X  secs = time(NULL);
X  loctm = localtime(&secs);
X  d->yy = 1900 + loctm->tm_year;
X  d->mm = loctm->tm_mon;
X  d->dd = loctm->tm_mday;
X}
X
X
END_OF_FILE
  if test 2697 -ne `wc -c <'greg.c'`; then
    echo shar: \"'greg.c'\" unpacked with wrong size!
  fi
  # end of 'greg.c'
fi
if test -f 'greg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'greg.h'\"
else
  echo shar: Extracting \"'greg.h'\" \(875 characters\)
  sed "s/^X//" >'greg.h' <<'END_OF_FILE'
X#ifndef __GREG__
X#define __GREG__
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <time.h>
X#include "error.h"
X
X#define LEAP(x) (!((x) % 4) && ( ((x) % 100) || !((x) % 400)))
X#define DAYS_IN(x) (LEAP((x))?366:365)
X
X#define JAN 0
X#define FEB 1
X#define MAR 2
X#define APR 3
X#define MAY 4
X#define JUN 5
X#define JUL 6
X#define AUG 7
X#define SEP 8
X#define OCT 9
X#define NOV 10
X#define DEC 11
X
X#define SUN 0
X#define MON 1
X#define TUE 2
X#define WED 3
X#define THU 4
X#define FRI 5
X#define SAT 6
X
Xextern char * eMonths[];
Xextern int MonthLengths[][12] ;
Xextern char * DayNames[] ;
Xextern char * ShortDayNames[];
Xextern char * eDays[] ;
X
Xtypedef struct {
X  int mm;	/* months since january 0,11*/
X  int dd;	/* day of month 1,31 */
X  int yy;	/* years since year 1 BCE i.e. -1 = 2 BCE */
X  } date_t;
X
Xint diffDays(), exceeds(), dayOfWeek();
Xvoid decDate (), incDate(), setDate();
X
X#endif
END_OF_FILE
  if test 875 -ne `wc -c <'greg.h'`; then
    echo shar: \"'greg.h'\" unpacked with wrong size!
  fi
  # end of 'greg.h'
fi
if test -f 'hebcal.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hebcal.1'\"
else
  echo shar: Extracting \"'hebcal.1'\" \(4969 characters\)
  sed "s/^X//" >'hebcal.1' <<'END_OF_FILE'
X.TH HEBCAL 1 "Hebcal Version 2.1" "Danny Sadinoff"
X.SH NAME
Xhebcal - a Jewish calendar generator
X.SH SYNOPSIS
X.B hebcal
X[ 
X\-adehorsStTwy
X] [ 
X\-i
X.I file
X] [[
X.I month
X[
X.I day
X]]
X.I year
X]
X.br
X.B hebcal help
X.SH DESCRIPTION
XWith no arguments, 
X.B hebcal
Xwill print to stdout the 
Xdates of the Jewish holidays in the current
Xsecular year.  Each line is prefixed with a gregorian date of the form
Xmm/dd/yyyy.  
X.sp
XBy specifying 
X.I month,
X.I day,
Xor 
X.I year 
Xoutput can be limited to a particular month or date
Xin a particular year.  
X.sp
X.I year
Xis an integer (it can be negative).  So 92 is during the Roman period,
Xnot the late twentieth century.
X.sp
X.I month
Xis a number from 1..12.
X.sp
X.I day 
Xis a number from 1..31.
X.sp
XFor example, the command
X.nf
X
X	hebcal 10 1992
X
X.fi
Xwill print out the holidays occurring in October of 1992.
X.PP
XNOTE:  hebcal 92 is 
X.I not
Xthe same as hebcal 1992.  The year is assumed to be complete, so the
Xformer calendar preceeds the latter by nineteen centuries.
X.PP
XA few other bells and whistles include the weekly 
X.I sedra
Xas well as the day of the week, the count of the 
X.I omer,
Xand the Hebrew date.
X.PP
XOutput from hebcal can be used to drive calendar(1).  
XDay\-to\-day use for hebcal is provided for in the 
X.B -T
X and 
X.B -t
Xswitches, which print out Jewish calendar entries for the current date.
X.PP
X.SH OPTIONS
X.TP 1.0i
X.B "  -a"
XUse Ashkenazis hebrew.
X.TP
X.B "  -d"
XAdd the Hebrew date to the output.
X.TP
X.B "  -e"
XChange the output format to European\-style dates: dd.mm.yyyy
X.TP
X.B "  -h"
XSuppress holidays in output.  User defined calendar events are
Xunaffected by this switch.
X.TP
X.B "  -i "
XRead extra events from specified file.  These events are printed
Xregardless of the 
X.B -h 
Xsuppress holidays switch.
X.br
XThere is one holiday per line in 
X.I file,
Xeach with the format
X.br
X.I month day description
X.br
Xwhere 
X.I month 
Xis a number from 1 to 12,
X.I day
Xis a number from 1 to 30, and 
X.I description
Xis a newline-terminated string describing the holiday.
X.br
XHere is the list of Hebrew months and their code numbers:
X.br
X1	Tishrei
X.br
X2	Cheshvan
X.br
X3	Kislev
X.br
X4	Tevet
X.br
X5	Shvat
X.br
X6	Adar (Adar II on leap years)
X.br
X6a	Adar (Adar I on leap years)
X.br
X6b	same as 6
X.br
X7	Nisan
X.br
X8	Iyyar
X.br
X9	Sivan
X.br
X10	Tamuz
X.br
X11	Av
X.br
X12	Elul
X.br 
XPlease note the special option associated with Adar.  If a person died
Xin Adar of a non-leap year, the 
X.I yahrtzeit
Xlands in Adar II of a leap year, so the event gets the 6b (or 6) month
Xcode.  Only people who died on leap years in Adar II should have their
X.I yahrtzeits
Xon 6a.  The same rule applies for Jewish birthdays (this is used when
Xcalculating 
X.I bar-mitzvah 
Xor 
X.I bat-mitzvah 
Xdates).
X.TP
X.B "  -o"
XAdd the count of the 
X.I omer
Xto the output.
X.TP
X.B "  -r"
XUse a tab-delineated format
X.TP
X.B "  -s"
XAdd the weekly 
X.I sedra 
Xto the output on Saturdays.
X.TP
X.B "  -S"
XAdd the weekly 
X.I sedra 
Xto the output every day.
X.TP
X.B "  -t"
XPrint calendar information for today's date only.  -d is
Xasserted with this option. 
X.TP
X.B "  -T"
XSame as -t, only without the gregorian date.  This option is useful in
Xlogin scripts, just to see what's happening today in the Jewish calendar.
X.TP
X.B "  -w"
XAdd the day of the week to the output.
X.TP
X.B "  -y"
XPrint only the last two digits of the year.
X.SH EXAMPLES
X.LP
XTo find the days of the 
X.I omer 
Xin 1997, printing the days of the week:
X.RS
X.nf
X.ft B
Xexample% hebcal -how 1997
X.br
X4/23/97 Wed, 1st day of the Omer
X.br
X4/24/97 Thu, 2nd day of the Omer
X.br
X4/25/97 Fri, 3rd day of the Omer
X.br
X .
X.br
X .
X.br
X .
X.br
X6/9/97 Mon, 48th day of the Omer
X.br
X6/10/97 Tue, 49th day of the Omer
X.RE
X.LP
XTo just print the weekly 
X.I sedrot
Xof December 2000
X.RS
X.nf
X.ft B
Xexample% hebcal -hp 12 2000
X.br
X12/2/00 Parshat Toldot
X.br
X12/9/00 Parshat Vayetzei
X.br
X12/16/00 Parshat Vayishlach
X.br
X12/23/00 Parshat Vayeshev
X.br
X12/30/00 Parshat Miketz
X.br
X.RE
X.LP 
XTo find out what's happening in the Jewish calendar today , use
X.RS
X.nf
X.ft B
Xexample% hebcal -ToS
X.br
X19 of Nisan, 5752
X.br
XParshat Achrei Mot
X.br
XPesach V (CH"M)
X.br
X4th day of the Omer
X.br
X.RE
X.SH AUTHOR
XDanny Sadinoff, University of Pennsylvania
X.SH SEE ALSO
Xcalendar(1), hcal(1), hdate(1), omer(1), rise(1)
X.sp
XThe motivation for the algorithms in this program is the
X.I "Tur Shulchan Aruch.  "
XA well written treatment of the Jewish calendar is given in 
X.I Understanding the Jewish Calendar
Xby Rabbi Nathan Bushwick.  A more complete bibliography on the topic
Xcan be found there.
X.SH DISCLAIMER
XThis is just a program I wrote one summer.  It should not be invested
Xwith any sort of halachic authority.
X.SH BUGS
XHebrew dates are only valid before sundown on that secular date
X.sp
XHebcal performs no checking for changes between the julian and
Xgregorian calendar, so secular dates before 1752 are untrustworthy.
X.sp 
XHebcal cannot currently handle date computations before 2 C.E.  sorry.
X.SH BUG REPORTS TO
XDanny Sadinoff
X.br
Xsadinoff@eniac.seas.upenn.edu
END_OF_FILE
  if test 4969 -ne `wc -c <'hebcal.1'`; then
    echo shar: \"'hebcal.1'\" unpacked with wrong size!
  fi
  # end of 'hebcal.1'
fi
if test -f 'hebcal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hebcal.c'\"
else
  echo shar: Extracting \"'hebcal.c'\" \(24526 characters\)
  sed "s/^X//" >'hebcal.c' <<'END_OF_FILE'
X#include "hebcal.h"
X#include "danlib.h"
X#include <string.h>
X  
X  
X  /* hebcal.c main module for hebrew calendar program
X     By Danny Sadinoff
X     (C) 1993
X     
X     $Date: 93/09/26 16:26:59 $
X     $Revision: 2.1 $
X     
X     */ 
X  
X  int ashkenazis_sw, sedrot_sw, hebDates_sw, euroDates_sw, specMonth_sw,
X  specDay_sw, inputFile_sw, weekday_sw, suppressHolidays_sw,
X  suppressGreg_sw, printOmer_sw, sedraAllWeek_sw, yearDigits_sw,
X  tabs_sw, omer;
X
XFILE *inFile;
X
Xholstorep_t holidays[13][MAXDAYS],union_Adar[MAXDAYS];
X
Xyear_t legend[2][8] = {
X  {                             /* stam years */
X    {"1BX",353,29,29,1,1,1,1,0,1,1},    /* BX */
X    {"1BS",355,30,30,1,1,1,1,1,1,1},    /* BS */
X    {"2GC",354,29,30,1,1,1,1,1,1,1},    /* GC */
X    {"4HC",354,29,30,1,1,1,1,0,1,0},    /* HC */ 
X    {"0error - HX",354,29,29,1,1,1,1,0,1,0},    /* error! hx */
X    {"4HS",355,30,30,0,1,1,1,0,1,0},    /* HS */
X    {"6ZX",353,29,29,1,1,1,1,0,1,0},    /* ZX */
X    {"6ZS",355,30,30,1,1,1,1,0,1,1},    /* ZS */
X  },
X  {                             /* leap years */
X    {"1BX",383,29,29,0,0,0,0,1,1,1},    /* BX */
X    {"1BS",385,30,30,0,0,0,0,0,1,0},    /* BS */
X    {"2GC",384,29,30,0,0,0,0,0,1,0},    /* GC */
X    {"0error - HC",383,29,30,0,0,0,0,0,0,0},    /* error ! hc */
X    {"4HX",383,29,29,0,0,0,0,0,0,0},    /* HX */
X    {"4HS",385,30,30,0,0,0,0,0,0,1},    /* HS */
X    {"6ZX",383,29,29,0,0,0,0,0,1,1},    /* ZX */
X    {"6ZS",385,30,30,0,0,0,0,1,1,1},    /* ZS */
X  }
X};
X
Xint leapYears[] = {0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1};
X/*enum {BX,BS,GC,HC,HX,HS,ZX,ZS}; */
X#define BX 0
X#define BS 1
X#define GC 2
X#define HC 3
X#define HX 4
X#define HS 5
X#define ZX 6
X#define ZS 7
X
Xint luach[][19] = 
X{
X  {HC,BX,HS,HC,BS,ZX,HC,BS,BX,HS,GC,BS,ZX,GC,BS,ZS,HX,GC,ZS},
X  {ZS,HC,BX,ZS,HC,BX,ZS,HS,HC,BX,HS,HC,BS,ZX,HC,BS,ZX,HS,GC},
X  {BS,ZX,GC,BS,ZS,HX,GC,ZS,ZS,HC,BX,ZS,HC,BS,BX,HC,BS,BS,ZX},
X  {HC,HS,ZX,HC,HS,ZS,ZX,GC,BS,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BX},
X  {ZS,HC,BS,BX,HC,BS,BS,ZX,HC,BS,ZX,HS,GC,ZS,ZS,HC,BX,ZS,HX},
X  {GC,ZS,HS,HC,BX,HS,HC,BX,ZS,HC,BS,BX,HS,GC,BS,ZX,GC,BS,ZS},
X  {ZX,GC,ZS,ZS,HC,BX,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BS,ZX,HC,BS},
X  {BS,ZX,GC,BS,ZS,HX,GC,ZS,ZX,GC,ZS,ZS,HC,BX,ZS,HC,BS,BX,HS},
X  {HC,BS,ZX,HC,BS,ZX,HS,GC,BS,ZX,GC,BS,ZS,HX,GC,ZS,HS,HC,BX},
X  {ZS,HC,BX,ZS,HC,BS,BX,HS,HC,BS,ZX,HC,BS,ZX,HS,GC,ZS,ZX,GC},
X  {BS,ZS,HX,GC,ZS,HS,HC,BX,ZS,HC,BX,ZS,HC,BS,BX,HS,GC,BS,ZX}, /* 10,11 GX? */
X  {HC,BS,ZS,ZX,GC,ZS,ZS,HX,GC,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BS},
X  {BX,HC,BS,BS,ZX,GC,BS,ZX,HS,GC,ZS,ZS,HC,BX,ZS,HC,BX,ZS,HS}
X};
X
Xstruct {
X  char * name;
X  int length;
X}hMonths[][14] = {
X  {  
X    {"Tishrei",30}, {"Cheshvan",29}, {"Kislev",30},
X    {"Tevet",29}, {"Sh'vat",30}, {"Adar",29},
X    {"Nisan",30}, {"Iyyar",29}, {"Sivan",30},
X    {"Tamuz",29}, {"Av",30},{"Elul",29},{"Tishrei",30}},
X  {
X    {"Tishrei",30}, {"Cheshvan",29}, {"Kislev",30},
X    {"Tevet",29}, {"Sh'vat",30}, {"Adar I",29}, {"Adar II",30},
X    {"Nisan",30}, {"Iyyar",29}, {"Sivan",30},
X    {"Tamuz",29}, {"Av",30},{"Elul",29},{"Tishrei",30}}    
X};
X
X#define TISHREI 0
X#define CHESHVAN 1
X#define KISLEV 2
X#define ADAR_2 6
X
X#define LANGUAGE(str) (ashkenazis_sw && (str)[1] ? ((str)[1]) : ((str)[0]))
X
Xchar * sedrot[][2] = {
X  {"Bereshit","Bereshis"},
X  {"Noach","Noach"}, {"Lech-Lecha","Lech-Lecha"},
X  {"Vayera","Vayera"},{"Chayei Sara","Chayei Sara"},
X  {"Toldot","Toldos"}, {"Vayetzei","Vayetzei"},
X  {"Vayishlach","Vayishlach"}, {"Vayeshev","Vayeshev"},
X  {"Miketz","Miketz"}, {"Vayigash","Vayigash"},
X  {"Vayechi","Vayechi"},
X  
X  {"Shemot","Shemos"}, {"Vaera","Vaera"}, {"Bo","Bo"},
X  {"Beshalach","Beshalach"}, {"Yitro","Yisro"},
X  {"Mishpatim","Mishpatim"},{"Terumah","Terumah"},
X  {"Tetzaveh","Tetzaveh"}, {"Ki Tisa","Ki Sisa"},
X  {"Vayakhel","Vayakhel"}, {"Pekudei","Pekudei"},
X  
X  {"Vayikra","Vayikra"}, {"Tzav","Tzav"},
X  {"Shmini","Shmini"}, {"Tazria","Sazria"},
X  {"Metzora","Metzora"}, {"Achrei Mot","Achrei Mos"},
X  {"Kedoshim","Kedoshim"}, {"Emor","Emor"},
X  {"Behar","Behar"}, {"Bechukotai","Bechukosai"},
X  
X  {"Bamidbar","Bamidbar"}, {"Nasso","Nasso"}, {"Beha'alotcha","Beha'aloscha"},
X  {"Sh'lach","Sh'lach"}, {"Korach","Korach"}, {"Chukat","Chukas"},
X  {"Balak","Balak"}, {"Pinchas","Pinchas"}, {"Matot","Matos"},
X  {"Masei","Masei"},
X  
X  {"Devarim","Devarim"}, {"Vaetchanan","Vaeschanan"},
X  {"Eikev","Eikev"},{"Re'eh","Re'eh"},
X  {"Shoftim","Shoftim"},{"Ki Teitzei","Ki Seitzei"},
X  {"Ki Tavo","Ki Savo"}, {"Nitzavim","Nitzavim"},
X  {"Vayeilech","Vayeilech"},{"Ha'Azinu","Ha'Azinu"},
X  {"V'Zot Habracha","V'Zos Habracha"}
X};
X
X#define VAYAKHEL 21
X#define TAZRIA 26
X#define ACHREI 28
X#define BEHAR 31
X#define CHUKAT 38
X#define MATOT 41
X#define NITZAVIM 50
X
X#define NM_LEN 60
X
X#define OWNSEDRA 1
X#define NIDCHE 2
X#define MUKDAM 4
X#define MUKDAM2 8
X#define SKIP_NORMAL_ADAR 16
X#define USER_EVENT 32
X
Xholinput_t inp_holidays[] = {   /* 5 = Adar I */
X  /* 6 = Adar = Adar II */
X  {{0,1},{"Rosh Hashana I"},OWNSEDRA},{{0,2},{"Rosh Hashana II"},OWNSEDRA},
X  {{0,3},{"Tzom Gedalia"},NIDCHE},
X  {{0,9},{"Erev Yom Kippur"}},
X  {{0,10},{"Yom Kippur"},OWNSEDRA},
X  
X  {{0,15},{"Sukkot I","Sukkos I"},OWNSEDRA},
X  {{0,16},{"Sukkot II","Sukkos II"},OWNSEDRA},
X  {{0,17},{"Sukkot III (CH''M)","Sukkos III (CH''M)"},OWNSEDRA},
X  {{0,18},{"Sukkot IV (CH''M)","Sukkos IV (CH''M)"},OWNSEDRA},
X  {{0,19},{"Sukkot V (CH''M)","Sukkos V (CH''M)"},OWNSEDRA},
X  {{0,20},{"Sukkot VI (CH''M)","Sukkos VI (CH''M)"},OWNSEDRA},
X  {{0,21},{"Sukkot VII (Hoshana Raba)","Sukkos VII (Hoshana Raba)"},OWNSEDRA},
X  {{0,22},{"Shmini Atzeret","Shmini Atzeres"},OWNSEDRA},
X  {{0,23},{"Simchat Torah","Simchas Torah"},OWNSEDRA},
X  
X  {{2,25},{"Chanukah I"}},
X  {{2,26},{"Chanukah II"}},{{2,27},{"Chanukah III"}},{{2,28},{"Chanukah IV"}},
X  
X  {{3,10},{"Asara B'Tevet"},NIDCHE},
X  
X  {{4,15},{"Tu B'Shvat"}},
X  
X  {{5,14},{"Purim katan"},SKIP_NORMAL_ADAR},
X  
X  {{6,13},{"Ta'anit Esther","Ta'anis Esther"},MUKDAM},
X  {{6,14},{"Purim"}},
X  {{6,15},{"Shushan Purim"}},
X  
X  {{7,14},{"Erev Pesach"}},
X  {{7,14},{"Ta'anit Bechorot","Ta'anis Bechorot"},MUKDAM},
X  {{7,15},{"Pesach I"},OWNSEDRA},
X  {{7,16},{"Pesach II"},OWNSEDRA},
X  {{7,17},{"Pesach III (CH''M)"},OWNSEDRA},
X  {{7,18},{"Pesach IV (CH''M)"},OWNSEDRA},
X  {{7,19},{"Pesach V (CH''M)"},OWNSEDRA},
X  {{7,20},{"Pesach VI (CH''M)"},OWNSEDRA},
X  {{7,21},{"Pesach VII"},OWNSEDRA},
X  {{7,22},{"Pesach VIII"},OWNSEDRA},
X  {{7,27},{"Yom HaShoah"}},
X  
X  {{8,4},{"Yom HaZikaron"},MUKDAM2},
X  {{8,5},{"Yom Ha'atzmaut"},MUKDAM},
X  {{8,28},{"Yom Yerushalayim"},MUKDAM},  /* not certain about mukdam status  of the yoms */
X  
X  {{9,6},{"Shavuot I","Shavuos I"},OWNSEDRA},
X  {{9,7},{"Shavuot II","Shavuos II"},OWNSEDRA},
X  
X  {{10,17},{"Shiva Assar B'Tamuz"},NIDCHE},
X  
X  {{11,9},{"Tish'a B'Av"},NIDCHE},
X  
X  {{12,29},{"Erev Rosh Hashana"}}
X};
X
Xholstore_t chanukah_arr[5] =
X{
X  {""},
X  {"Chanukah V"},
X  {"Chanukah VI"}, 
X  {"Chanukah VII"},
X  {"Chanukah VIII"}
X};
X
X#define SIMCHAT_DAY 23
X#define LEAP_YR_HEB(x) (leapYears[((x) -1) % 19])
X#define MONTHS_IN_HEB(x) (LEAP_YR_HEB(x) ? 13 :12)
X
Xyear_t yearData(yr)
X     int yr;
X{
X  return legend[LEAP_YR_HEB(yr)][luach[((yr-1)/19+7)%13][(yr-1) %19]];
X}
X
Xint daysInHebMonth(month, year) 
X     int month, year;
X{
X  year_t theYear;
X  
X  theYear = yearData(year);
X  if (month == CHESHVAN) 
X    return theYear.daysInCheshvan;
X  else if (month == KISLEV)
X    return theYear.daysInKislev;
X  else return hMonths[LEAP_YR_HEB(year)][month].length;
X}
X
Xdate_t nextHebDate (dth) 
X     date_t dth;
X{
X  dth.dd++;
X  if (dth.dd > daysInHebMonth(dth.mm,dth.yy))
X    if (dth.mm ==  MONTHS_IN_HEB(dth.yy)-1)
X      {
X        dth.yy++;
X        dth.mm =0;
X        dth.dd =1;
X      }
X    else 
X      {
X        dth.mm++;
X        dth.dd =1;
X      }
X  return dth;
X}
X
Xdate_t prevHebDate (dth) 
X     date_t dth;
X{
X  dth.dd--;
X  if (dth.dd == 0)
X    if (dth.mm == 0)
X      {
X        dth.yy--;
X        dth.mm = MONTHS_IN_HEB(dth.yy) -1 ;
X        dth.dd = daysInHebMonth(dth.mm,dth.yy);
X      }
X    else 
X      {
X        dth.mm--;
X        dth.dd = daysInHebMonth(dth.mm,dth.yy);
X      }
X  return dth;
X}
X
Xholstorep_t getHolstorep (s)    /* return a pointer to a new */
X     char *s;                               /* holiday */
X{
X  holstorep_t tmp;
X  if (!(tmp = (holstorep_t)malloc ( (size_t) sizeof (holstore_t))))
X    die("Unable to allocate memory for holiday. Called from %s",s);
X  tmp->next = NULL;
X  tmp->name = NULL;
X  tmp->typeMask = 0;
X  return tmp;
X}
X
X
Xint PushHoliday (hp,lp) /*pushes a copy of a holiday on to a holiday list */
X     holstorep_t 
X       hp,                      /* the holiday to be added */
X       *lp;                     /* pointer to the list to be added to.*/
X{
X  holstorep_t temp;
X  
X  temp = getHolstorep("PushHoliday");
X  initStr(&temp->name,MAX_LINE_LEN);
X  strcpy(temp->name,hp->name);
X  temp->typeMask = hp->typeMask;
X  
X  if (!*lp)
X    /* if there are no holidays here yet, start a new bucket*/
X    *lp = temp; 
X  else 
X    {
X      temp->next = *lp;         /* put hp at the head of the list */
X      *lp = temp;
X    }
X  return temp->typeMask;
X}
X
X
Xvoid InitHolidays(roshDt)       /* set up the stored holidays array */
X     date_t roshDt;
X{
X  
X  int d,m;
X  holstorep_t tmpholp;
X  holinputp_t todayinp;
X  
X  for (m = 0; m<= 12; m++)      /* clear holidays buckets */
X    for (d = 0; d < MAXDAYS; d++)
X      holidays[m][d] = NULL;
X  
X  for (m = 0,todayinp = inp_holidays; /* load holiday buckets */
X       m < LAST_INDEX(inp_holidays); 
X       m++, todayinp++)
X    {
X      tmpholp = getHolstorep("InitHolidays");      /* allocate hsnode*/
X      tmpholp->typeMask = todayinp->typeMask;      /* load the new holiday into it. */
X      tmpholp->name = LANGUAGE(todayinp->name);
X      PushHoliday(tmpholp,&holidays[todayinp->date.mm][todayinp->date.dd]);
X      if ((todayinp->date.mm == 5 || todayinp->date.mm == 6) && 
X          !(tmpholp->typeMask & SKIP_NORMAL_ADAR))
X        PushHoliday(tmpholp,&union_Adar[todayinp->date.dd]);
X    }
X  
X  if (inputFile_sw)             /* get user-defined "holidays" */
X    {
X      char *s,*monthStr,*adarp,*eventStr,nextChar;
X      int index,hYear,inMonth,inDay,lineNum = 1;
X      
X      
X      hYear = JUL2HEB(roshDt.yy)+1;
X      initStr(&s,MAX_LINE_LEN);
X      initStr(&monthStr,MAX_LINE_LEN);
X      nextChar = (char) getc(inFile); /* priming getc */
X      while (!feof(inFile))
X        {
X          ungetc(nextChar,inFile); 
X          if (!fgets(s,MAX_LINE_LEN,inFile))
X            die ("input file read error at line number %s.\n",itoa(lineNum));
X          
X          if (!sscanf(s,"%s %d%n",monthStr,&inDay,&index))
X            die ("Error in input file at line %s\n",itoa(lineNum));
X          
X          if (isAllNums(monthStr) && (inMonth = atoi(monthStr)) < 6)
X            inMonth--;
X          else if (adarp = strchr(monthStr,'a'))
X            {
X              *adarp = '\0';    /* terminate the string at the 'a' */
X              if (isAllNums(monthStr))
X                inMonth = atoi(monthStr)-1;
X              else die ("Error in input file at line %s\n",itoa(lineNum));
X            }
X          else if (adarp = strchr(monthStr,'b'))
X            {   /* this case puts the event in month 6 = Adar II*/
X              *adarp = '\0';    
X              if (isAllNums(monthStr))
X                inMonth = atoi(monthStr); /* note no decrement */
X              else die ("Error in input file at line %s\n",itoa(lineNum));
X            }
X          
X          if (inMonth >12 || inMonth <0)
X            die ("Month out of range in input file at line %s\n",itoa(lineNum));
X          
X          if(inDay <0 || inDay >30)
X            die ("Date out of range in input file at line %s\n",itoa(lineNum));
X          
X#if 0
X          if ((inMonth == 5) && !LEAP_YR_HEB(hYear))
X            warn("Warning:user event scheduled on Adar I in nonleap year. line %s\n",
X                 itoa(lineNum));
X#endif   
X          if (inDay > daysInHebMonth(inMonth,hYear))
X            warn("Warning:user event scheduled on date not appearing this year. line %s\n",
X                 itoa(lineNum));
X          
X          eventStr = s +index +1; /* get the name of the event */
X          if (eventStr[strlen(eventStr)-1] == '\n')
X            eventStr[strlen(eventStr)-1] = '\0'; /* chop off the \n */
X          
X          /* store the holiday in the LUT */
X          tmpholp = getHolstorep("InitHolidays:inputFile");
X          initStr(&tmpholp->name,MAX_LINE_LEN);
X          strcpy(tmpholp->name,eventStr); /* load the user holiday into it. */
X          tmpholp->typeMask = USER_EVENT;
X          PushHoliday(tmpholp,&holidays[inMonth][inDay]);
X          if (inMonth == 5 || inMonth == 6) 
X            PushHoliday(tmpholp,&union_Adar[inDay]);
X          
X          lineNum++;
X          nextChar = (char) getc(inFile); /* force an EOF */
X        }
X    }
X}      
X
X
X
Xvoid getHebHolidays (dth,weekday, holiList) 
X     date_t dth;             /* returns a linked list of holidays for that date*/ 
X     int weekday;
X     holstorep_t *holiList;     /* the typeMask on the first element of */
X     /* the returned list must reflect */
X     /* the union of all component masks */
X{
X  char * funName = "getHebHolidays";
X  int tmpMask;
X  holstorep_t tmpholip, chp;
X  static holstorep_t todayp, yesterp, morrowp, morrow2p;
X  static int chanukah_day,first;
X  
X#define CORRECTION(yy,mm) (LEAP_YR_HEB(yy) ? 0 : (((mm) > 4) ? 1: 0))
X  
X  if (first) 
X    {
X      todayp  = holidays[dth.mm][dth.dd];
X      yesterp = holidays[prevHebDate(dth).mm][prevHebDate(dth).dd];
X      morrowp = holidays[nextHebDate(dth).mm][nextHebDate(dth).dd];
X      morrow2p = holidays[nextHebDate(nextHebDate(dth)).mm]
X        [nextHebDate(nextHebDate(dth)).dd];
X      first = 0;
X    }
X  else
X    {
X      date_t morrow2dt;
X      
X      morrow2dt = nextHebDate(nextHebDate(dth));
X      yesterp = todayp;
X      todayp = morrowp;
X      morrowp = morrow2p;
X      if (!LEAP_YR_HEB(dth.yy) && morrow2dt.mm == 5)
X        morrow2p = union_Adar[morrow2dt.dd];
X      else
X        morrow2p = holidays[morrow2dt.mm +CORRECTION(dth.yy,morrow2dt.mm)]
X          [morrow2dt.dd];
X    }
X  
X  tmpMask =0;
X  *holiList = NULL;
X
X
X#define NISAN (6 + LEAP_YR_HEB(dth.yy))
X#define SIVAN (NISAN + 2)
X  if (dth.mm == NISAN && dth.dd == 16) /* 2nd day of pesach */
X    omer++;
X  if (omer && dth.mm == SIVAN && dth.dd == 6 ) /*shavuot*/
X    omer = 0;
X
X  for (chp = todayp; chp; chp = chp->next)
X    {
X      /* for normal holidays */
X      if (!(weekday == SAT && chp->typeMask & NIDCHE) &&
X          !(chp->typeMask & MUKDAM  && (weekday == FRI || weekday == SAT)) &&
X          !(chp->typeMask & MUKDAM2 && (weekday == THU || weekday == FRI)))
X	tmpMask |= PushHoliday(chp,holiList);	/* do normal holidays*/
X    }
X  
X  if (weekday == SUN && yesterp)      /* fast days which are nidche */
X    for (chp = yesterp; chp; chp = chp->next)
X      if (chp->typeMask & NIDCHE)
X        {
X          char *st;
X          
X          initStr(&st,NM_LEN);
X          strncat(st,chp->name,NM_LEN);
X          strncat(st," [nidche]",NM_LEN);
X          tmpMask |= PushHoliday(chp,holiList);
X          (*holiList)->name = st;
X        }
X  
X  /* if the date actually falls */
X  /* on friday or shabbat*/
X  if (weekday == THU)
X    {
X      for (chp = morrowp; chp; chp = chp->next)
X        if (chp->typeMask & MUKDAM)
X          {
X            char *st;
X            
X            initStr(&st,NM_LEN);
X            strncat(st,chp->name,NM_LEN);
X            strncat(st," [mukdam]",NM_LEN);
X            tmpMask |= PushHoliday(chp,holiList);
X            (*holiList)->name = st;
X          }
X      for (chp = morrow2p; chp; chp = chp->next)
X        if (chp->typeMask & MUKDAM)
X          {
X            char *st;
X            
X            initStr(&st,NM_LEN);
X            strncat(st,chp->name,NM_LEN);
X            strncat(st," [mukdam]",NM_LEN);
X            tmpMask |= PushHoliday(chp,holiList);
X            (*holiList)->name = st;
X          }
X    }
X  
X  /* if the date actually falls */
X  /* on thursday or friday*/
X  if (weekday == WED)
X    {
X      for (chp = morrowp; chp; chp = chp->next)
X        if (chp->typeMask & MUKDAM2)
X          {
X            char *st;
X            
X            initStr(&st,NM_LEN);
X            strncat(st,chp->name,NM_LEN);
X            strncat(st," [mukdam]",NM_LEN);
X            tmpMask |= PushHoliday(chp,holiList);
X            (*holiList)->name = st;
X          }
X      for (chp = morrow2p; chp; chp = chp->next)
X        if (chp->typeMask & MUKDAM2)
X          {
X            char *st;
X            
X            initStr(&st,NM_LEN);
X            strncat(st,chp->name,NM_LEN);
X            strncat(st," [mukdam]",NM_LEN);
X            tmpMask |= PushHoliday(chp,holiList);
X            (*holiList)->name = st;
X          }
X    }
X  
X  /* Lag B'Omer Processing */
X  if (omer == 33) {
X    tmpholip = getHolstorep(funName);
X    initStr(&tmpholip->name,NM_LEN); 
X    strncpy(tmpholip->name,"Lag B'Omer",NM_LEN);
X    tmpMask |= PushHoliday(tmpholip,holiList);
X  }
X  
X  if (dth.dd == 29 && dth.mm == 2) 
X    chanukah_day = 1;
X  
X  if (chanukah_day) {
X    tmpMask |= PushHoliday(&chanukah_arr[chanukah_day],holiList);
X    if (chanukah_day == 4)
X      chanukah_day = 0;
X    else chanukah_day++;
X  }
X  
X  
X  /* rosh Chodesh Processing... */
X  if (dth.dd == 1 && dth.mm){   /* every 1st of the month except tishrei */
X    tmpholip = getHolstorep(funName);
X    initStr(&tmpholip->name,NM_LEN); 
X    strcat(tmpholip->name,"Rosh Chodesh ");
X    if (!tabs_sw)
X      strncat(tmpholip->name,hMonths[LEAP_YR_HEB(dth.yy)][dth.mm].name,NM_LEN);
X    tmpMask |= PushHoliday(tmpholip,holiList);
X  }
X  if (dth.dd == 30){
X    tmpholip = getHolstorep(funName);
X    initStr(&tmpholip->name,NM_LEN);
X    strcat(tmpholip->name,"Rosh Chodesh ");
X    if (!tabs_sw)
X      strncat(tmpholip->name,hMonths[LEAP_YR_HEB(dth.yy)][dth.mm+1].name,NM_LEN);
X    tmpMask |= PushHoliday(tmpholip,holiList);
X  }
X  
X  if (*holiList) (*holiList)->typeMask = tmpMask;
X  
X}
X
Xvoid incHebJulDate(dth,dtj,wkday)
X     date_t *dth, *dtj;
X     int *wkday;
X{
X  /* increments both hebrew and julian calendars */
X  
X  incDate (dtj,1);
X  *wkday = dayOfWeek(*dtj);
X  *dth = nextHebDate(*dth);
X}   
X
Xvoid PrintWeekday (dt) 
X     date_t dt;
X{
X  printf ("%s, ",ShortDayNames[dayOfWeek(dt)]);
X}
X
Xvoid PrintJulDate (dt) 
X     date_t dt;
X{
X  if (!suppressGreg_sw) {
X    if (euroDates_sw)
X      printf ("%d.%d.",dt.dd,dt.mm+1);
X    else
X      printf ("%d/%d/",dt.mm+1,dt.dd);
X    
X    if (yearDigits_sw)
X      printf("%d",dt.yy % 100);
X    else
X      printf("%d",dt.yy);
X    
X    if (tabs_sw)
X      printf("\t");
X    else
X      printf(" ");
X  }
X  
X  if (weekday_sw)
X    PrintWeekday(dt);
X}
X
X
Xchar *DoSedra (sedra, ydat,increment) /* returns a string "Parshat <parsha>" */
X     int *sedra,increment;      /* based on the current parsha number */
X     year_t ydat;
X{
X#define PLENGTH 40
X  static char s[PLENGTH+1];
X  static char * p;
X  
X  if (ashkenazis_sw) p = "Parshas ";
X  else               p = "Parshat ";
X  
X  if (increment) increment = 1;
X  *s = '\0';
X  if (!tabs_sw)
X    strncat(s,p,PLENGTH);
X  strncat(s,sedrot[*sedra][ashkenazis_sw],PLENGTH);
X  switch (*sedra)
X    {
X    case VAYAKHEL :
X      if (ydat.vayakhelPikudei)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case TAZRIA:
X      if (ydat.tazriaMetzorah)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case ACHREI :
X      if (ydat.achreiKedoshim)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case BEHAR :
X      if (ydat.beharBech)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case CHUKAT :
X      if (ydat.chukatBalak)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case MATOT :
X      if (ydat.matotMasei)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case NITZAVIM :
X      if (ydat.nitzavimVayelech)
X        {
X          strncat(s,"-",PLENGTH);
X          strncat(s,sedrot[*sedra+1][ashkenazis_sw],PLENGTH);
X          *sedra += 2*increment;
X        }
X      else *sedra += 1*increment;
X      break;
X    case LAST_INDEX(sedrot)-1:
X      *sedra = 0;
X      break;
X    default:
X      *sedra += 1*increment;
X    }
X  
X  strncat(s,"\n",PLENGTH);
X  return s;
X}
X
Xvoid DoCalendar (roshDt,justMonth,justDay)
X     date_t roshDt;             /* rosh Hashana of preceeding year */
X     int justMonth,             /* print this month  */
X       justDay;                 /* print this day */
X{
X  int sedra,weekday;
X  date_t todayj, todayh;
X  holstorep_t holip;            /* a list of holidays for today */
X  year_t theYear;
X  todayj = roshDt;
X  
X  todayh.mm = 0;
X  todayh.dd = 1;
X  todayh.yy = JUL2HEB(roshDt.yy) + 1; /* because it's after R"H */
X  
X  
X  theYear = yearData(todayh.yy);
X  
X  if (CHAR2NUM(theYear.name[0]) != dayOfWeek(roshDt))
X    die ("Bad Day!\n","");  
X  
X  /* first scan forward to simchat Torah, keeping track of dates only. */
X  while (todayh.dd != SIMCHAT_DAY)
X    incHebJulDate(&todayh, &todayj,&weekday);
X  
X  sedra = 0;            /* initialize sedra */
X  
X  /* then continue until january 1st. */
X  do 
X    {
X      getHebHolidays(todayh,weekday,&holip);
X      if (weekday == SAT && !(holip && holip->typeMask & OWNSEDRA)) 
X        DoSedra(&sedra,theYear,1);
X      incHebJulDate(&todayh,&todayj,&weekday);
X    } while (!(todayj.mm==0 && todayj.dd==1));
X  
X  /* -------Main Year Loop-------*/
X  do 
X    {
X      if (hebDates_sw && 
X          (!specMonth_sw || (justMonth== todayj.mm)) &&
X          (!specDay_sw   || (justDay == todayj.dd)))
X        {
X          PrintJulDate(todayj);
X
X       	  printf ("%d%s of %s, %d\n",todayh.dd, /* print the hebrew date */
X		              numSuffix(todayh.dd),
X		              hMonths[LEAP_YR_HEB(todayh.yy)][todayh.mm].name,
X		              todayh.yy);
X        }
X      getHebHolidays(todayh,weekday,&holip);
X      
X      if (todayh.mm == TISHREI && todayh.dd == 1)
X        theYear = yearData(todayh.yy); /* if R"H reset YearData */
X      
X      
X      
X      if (sedraAllWeek_sw ||
X          (sedrot_sw && weekday==SAT &&
X           !(holip && holip->typeMask & OWNSEDRA)))
X        {
X          if ((!specMonth_sw || (justMonth == todayj.mm)) &&
X              (!specDay_sw   || (justDay == todayj.dd)))
X            {
X              PrintJulDate(todayj);
X              printf("%s",DoSedra(&sedra,theYear,weekday==SAT &&
X                                  !(holip && holip->typeMask & OWNSEDRA)));
X            }
X          else DoSedra(&sedra,theYear,weekday==SAT &&
X                       !(holip && holip->typeMask & OWNSEDRA));
X        }
X      
X      
X      if (sedrot_sw && 
X          todayh.mm == TISHREI && /* reset the sedra on simchat torah */
X          todayh.dd == SIMCHAT_DAY)
X        sedra =0;
X      
X      if ((!specMonth_sw || (justMonth == todayj.mm)) &&
X          (!specDay_sw   || (justDay == todayj.dd)))
X        for (;holip;holip = holip->next)
X          if (!suppressHolidays_sw || (holip->typeMask & USER_EVENT))
X            {
X              PrintJulDate(todayj);
X              printf ("%s\n",holip->name);
X            }
X      
X      /* print the omer if desired */
X      if (omer && printOmer_sw &&
X          (!specMonth_sw || (justMonth == todayj.mm)) &&
X          (!specDay_sw   || (justDay == todayj.dd)))
X        {
X          char *omerStr;
X          initStr(&omerStr,NM_LEN);
X          if (!tabs_sw) {
X            strncat(omerStr,itoa(omer),NM_LEN);
X            strncat(omerStr,numSuffix(omer),NM_LEN);
X            strncat(omerStr," day of the Omer",NM_LEN);
X          }
X          else {
X            strncat(omerStr,"Omer: ",NM_LEN);
X            strncat(omerStr,itoa(omer),NM_LEN);
X          }
X          PrintJulDate(todayj);
X	  printf ("%s\n",omerStr);
X        }
X      if (omer) omer++;
X      
X      incHebJulDate(&todayh,&todayj,&weekday);
X      
X    } while (!(specMonth_sw && todayj.mm > justMonth) &&
X             (todayj.mm!=0 || todayj.dd!=1)); /* continue to january 1st */
X}
END_OF_FILE
  if test 24526 -ne `wc -c <'hebcal.c'`; then
    echo shar: \"'hebcal.c'\" unpacked with wrong size!
  fi
  # end of 'hebcal.c'
fi
if test -f 'hebcal.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hebcal.h'\"
else
  echo shar: Extracting \"'hebcal.h'\" \(813 characters\)
  sed "s/^X//" >'hebcal.h' <<'END_OF_FILE'
X#ifndef __HEBCAL__
X#define __HEBCAL__
X#include <stdio.h>
X#include "greg.h"
X#include "error.h"
X#define MAXDAYS 31
X#define JUL2HEB(x) ((x)+ 3760)
X#define MAX_LINE_LEN 100
X
Xtypedef struct {
X  
X  char * name;
X  int length;
X  
X  int daysInCheshvan;
X  int daysInKislev;
X  
X  int vayakhelPikudei;	/* double parsha flags */
X  int tazriaMetzorah;
X  int achreiKedoshim;
X  int beharBech;
X  int chukatBalak; 
X  int matotMasei;
X  int nitzavimVayelech;
X  
X} year_t;
X
Xtypedef struct hinode{   /* holiday input structure */
X	date_t date;
X	char *(name[2]);
X  int typeMask;
X  struct hinode *next;
X} holinput_t, *holinputp_t;
X
Xtypedef struct hsnode{  /* holiday storage structure */
X	char *name;
X  int typeMask;
X  struct hsnode *next;
X} holstore_t, *holstorep_t;
X
Xyear_t yearData();
Xvoid InitHolidays();
Xvoid DoCalendar ();
X
X#endif
END_OF_FILE
  if test 813 -ne `wc -c <'hebcal.h'`; then
    echo shar: \"'hebcal.h'\" unpacked with wrong size!
  fi
  # end of 'hebcal.h'
fi
if test -f 'proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.h'\"
else
  echo shar: Extracting \"'proto.h'\" \(159 characters\)
  sed "s/^X//" >'proto.h' <<'END_OF_FILE'
X#ifndef PROTO_H
X#define PROTO_H
X#if __STDC__==1 || PROTOTYPES_EXIST
X#define PROTO(A) A
X#else
X#define PROTO(A) ()
X#endif /*has prototypes */
X#endif /*PROTO_H*/
END_OF_FILE
  if test 159 -ne `wc -c <'proto.h'`; then
    echo shar: \"'proto.h'\" unpacked with wrong size!
  fi
  # end of 'proto.h'
fi
if test -f 'start.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'start.c'\"
else
  echo shar: Extracting \"'start.c'\" \(6378 characters\)
  sed "s/^X//" >'start.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "hebcal.h"
X#include "getopt.h"
X
Xextern int
X  ashkenazis_sw, sedrot_sw, hebDates_sw, euroDates_sw,
X  specMonth_sw,specDay_sw,
X  inputFile_sw, weekday_sw, suppressHolidays_sw, suppressGreg_sw, 
X  printOmer_sw, sedraAllWeek_sw, yearDigits_sw, tabs_sw, omer;
X
Xextern FILE *inFile;
X
Xvoid RollBack(dtg,target) /* move rosh hashana dtj back until it's */
X     date_t *dtg;		  /* in the year before target */
X     int target;
X{
X  int days,theyear;
X  
X  for (days = 0,theyear = dtg->yy ;theyear > target -1; theyear--)
X    days +=yearData(JUL2HEB(theyear)).length;
X  decDate (dtg,days); 
X  
X}
X
Xvoid RollForward(dtg,target)   /* move rosh hashana dtg forward until it's*/
X     date_t *dtg;		       /*  in the year before target*/
X     int target; 
X{
X  int days,theyear;
X  
X  for (days = 0,theyear = dtg->yy ;theyear < target -1; theyear++)
X    days +=yearData(JUL2HEB(theyear+1)).length;
X  incDate (dtg,days); 
X  
X}
X
Xstatic int theYear,theMonth,theDay,yearDirty;
X
Xvoid handleArgs(argc, argv)
X     int argc;
X     char *argv[];
X{
X  char optchar;
X  date_t tempdt;
X  
X  char * usage = "usage: hebcal [-adehorsStTwy] [-i file] [[month [day]] year]\n               hebcal help\n";
X
X  setDate(&tempdt);		/* do this year */
X  theYear = tempdt.yy;
X  
X  while (EOF != (optchar = 
X		 getopt(argc,argv,"adehorsStTwyi:")))
X    {
X      switch (optchar) 
X	{
X	case 'a':                      /* ashkenazis hebrew */
X	  ashkenazis_sw =1;
X	  break;
X	case 'd':                      /* print hebrew date */
X	  hebDates_sw = 1;
X	  break;
X	case 'i':                      /* input file */
X	  inputFile_sw =1;
X	  if (!(inFile = fopen(optarg,"r"))) 
X	    die("could not open input file %s.",optarg);
X	  break;
X	case 'e':
X	  euroDates_sw=1;
X	  break;
X	case 'h':
X	  suppressHolidays_sw =1;
X	  break;
X	case 'o':
X	  printOmer_sw =1;
X	  break;
X	case 'r' :			/* Tab-delineated Format */
X	  tabs_sw = 1;
X	  break;
X	case 's' :			/* print sedrot */
X	  sedrot_sw = 1;
X	  break;
X	case 'S':			/* print sedra every day. */
X	  sedraAllWeek_sw =1;
X	  break;
X	case 't':			/* do hebcal for today. */
X	  specMonth_sw =1;
X	  specDay_sw =1;
X	  theMonth = tempdt.mm;	/* year and month specified */
X	  theDay = tempdt.dd;	/* print theDay of theMonth */
X	  yearDirty =1;
X	  printOmer_sw =1;
X	  break;
X	case 'T':			/* do hebcal for today, omit gregorian date. */
X	  suppressGreg_sw = 1;
X	  specMonth_sw =1;
X	  specDay_sw =1;
X	  theMonth = tempdt.mm;	/* year and month specified */
X	  theDay = tempdt.dd;	/* print theDay of theMonth */
X	  yearDirty =1;
X	  printOmer_sw =1;
X	  break;
X	case 'w' :			/* print days of the week */
X	  weekday_sw = 1;
X	  break;
X	case 'y' :			/* Print only last 2 digits of year */
X	  yearDigits_sw = 1;
X	  break;
X
X	default: die(usage,"");
X	}
X    }
X  
X  switch (argc - optind) /* suck up the date */
X    {	
X    case 0 : break;		/* process this year */
X    case 1 : 
X      if (isAllNums(argv[optind])) 
X	{
X	  theYear = atoi(argv[optind]); /* just year specified */
X	  yearDirty =1;		    /* print whole year */
X	}
X      else if (!strcmp(argv[optind],"help")) 
X	{
X	  printf ("Hebcal Version 2.1 By Danny Sadinoff\n");
X	  printf (usage);
X	  printf ("\nOPTIONS:\n");
X	  printf ("   -a : use ashkenazis hebrew\n");
X	  printf ("   -d : add hebrew dates\n");
X	  printf ("   -e : ouput european dates DD.MM.YYYY\n");
X	  printf ("   -h : suppress holidays\n");
X	  printf ("   -i : get user events from specified file\n");
X	  printf ("   -o : add days of the omer\n");
X	  printf ("   -r : tab delineated format\n");
X	  printf ("   -s : add weekly sedrot on Saturday\n");
X	  printf ("   -S : print sedrah of the week on all calendar days\n");
X	  printf ("   -t : only output for today's date\n");
X	  printf ("   -T : print today's pertinent information, no gregorian date\n");
X	  printf ("   -w : add day of the week\n");
X	  printf ("   -y : print only last two digits of year\n\n");
X	  printf ("hebcal help --- prints this message\n");
X	  printf (" ---MORE--- hit enter to continue....\n");
X	  gets (argv[0]);
X	  printf ("Hebcal prints out hebrew calendars one solar year at a time.  Given one\n");
X	  printf ("argument, it will print out the calendar for that year.  Given two numeric\n");
X	  printf ("arguments mm yyyy, it prints out the calendar for month mm of year yyyy.\n");
X	  printf ("\nFor example, \n");
X	  printf ("   hebcal -ho\n");
X	  printf ("will just print out the days of the omer for the current year.\n");
X	  printf ("Note: use COMPLETE years.  You probably aren't interested in \n");
X	  printf ("hebcal 93, but rather hebcal 1993.\n");
X	  printf ("\n\nHebcal is not free.  If you wish to use it for more than a week,\n");
X	  printf ("you must let me know you're using it:  sadinoff@eniac.seas.upenn.edu\n");
X	  printf ("Checks are also welcome:  If you'd like to patronize good programming,\n");
X	  printf ("send $10 to Danny Sadinoff\n");
X	  printf ("            1 Cove La.    \n");
X	  printf ("            Great Neck, NY\n");
X	  printf ("                    11024\n");
X	  exit (0);
X	}
X      else die (usage,"");
X      break;
X      
X    case 2:
X      if (!(isAllNums(argv[optind]) && isAllNums(argv[optind +1])))
X	die (usage,"");
X      specMonth_sw =1;
X      theMonth = atoi(argv[optind]) -1; /* year and month specified */
X      theYear = atoi(argv[++optind]); /* print theMonth of theYear */
X      yearDirty =1;
X      break;
X      
X    case 3:
X      if (!(isAllNums(argv[optind]) 
X	    && isAllNums(argv[optind +1])
X	    && isAllNums(argv[optind +2])))
X	die (usage,"");
X      specMonth_sw =1;
X      specDay_sw =1;
X      theMonth = atoi(argv[optind]) -1; /* year and month specified */
X      theDay = atoi(argv[++optind]); /* print theDay of theMonth */
X      theYear = atoi(argv[++optind]); /* print theMonth of theYear */
X      yearDirty =1;
X      break;
X    default: die (usage,"");
X    }
X}
X
X
Xchar * progname;
X
Xint main (argc, argv)
X     int argc;
X     char *argv[];
X{
X  date_t startDate;
X  
X  progname = "HEBCAL";
X  
X  startDate.dd = 28;
X  startDate.mm = SEP; /* any ol' rosh hashana */
X  startDate.yy = 1992;
X  
X  handleArgs(argc,argv);
X  
X  if (specDay_sw) hebDates_sw = 1;
X  
X  if (theYear < startDate.yy +1) /* go to R"H of the year before */
X    RollBack(&startDate,theYear);
X  else if (theYear > startDate.yy +1) /* start from there */
X    RollForward(&startDate,theYear);
X  
X  InitHolidays(startDate);
X  DoCalendar(startDate,theMonth,theDay);   
X  
X  return 0;
X}
END_OF_FILE
  if test 6378 -ne `wc -c <'start.c'`; then
    echo shar: \"'start.c'\" unpacked with wrong size!
  fi
  # end of 'start.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
