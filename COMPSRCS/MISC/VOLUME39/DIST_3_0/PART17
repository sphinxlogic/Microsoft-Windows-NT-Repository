Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i021:  dist-3.0 - Configure script generator and related tools, Part17/28
Message-ID: <1993Aug19.131418.5743@sparky.sterling.com>
X-Md4-Signature: c5097488949eebf936852c2d288632cf
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 19 Aug 1993 13:14:18 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 21
Archive-name: dist-3.0/part17
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  jmake/README mcon/U/Config_h.U mcon/U/Finish.U
#   mcon/U/Inhdr.U mcon/U/bin.U mcon/U/d_NeWS.U mcon/U/d_castneg.U
#   mcon/U/d_flexfnam.U mcon/U/d_ftime.U mcon/U/d_inetd.U
#   mcon/U/d_setpgrp.U mcon/U/d_sigsetmk.U mcon/U/d_voidsig.U
#   mcon/U/libs.U mcon/U/mallocsrc.U mcon/U/usenm.U mcon/pl/depend.pl
#   pat/patftp.SH
# Wrapped by ram@soft208 on Wed Aug 18 14:42:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 17 (of 28)."'
if test -f 'jmake/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/README'\"
else
  echo shar: Extracting \"'jmake/README'\" \(2463 characters\)
  sed "s/^X//" >'jmake/README' <<'END_OF_FILE'
XThis is the root directory for jmake.
X
XThe jmake program is a Makefile generator. It comes from 'imake' one
Xmay find in the X11R4 distribution, but it produces a Makefile.SH
Xinstead of a Makefile. Jmake has a template which knows some metaconfig
Xsymbols and has built-in commands which make it more powerful than imake.
X
XThe jmkmf script may be used to produce the Makefile.SH from a Jmakefile.
XOnce the bootstrap is done, you can run 'make Makefile.SH' to rebuild the
XMakefile.SH in the current directory, or 'make Makefiles.SH' to build the
XMakefiles in a recursive manner.
X
XAll the rules used by jmake are listed in an automatically built index.
XThe jmake's cryptic syntax is documented in file NOTES. You may also
Xhave a look at the sample Jmakefiles that come with this package.
XUsually, you do not include them in the release, but I kept them so
Xthat you may have a real example and see how things are organized.
X
XIf you choose to use jmake, then you will have to use metaconfig, in
Xorder to get a meaningful value for all the needed symbol. Thus, each
Xtime you change your Jmakefiles, it may be necessary to update the
XConfigure script.
X
XHere is how to use jmake...
X
XFirst, you have to write a Jmakefile for each directory where you want
Xto put a Makefile. Be sure to declare all the sub-directories with the
XSetSubdirs rule. Usually, the order of the rules is not significant,
Xbut you should make sure the Makefile begins with an 'all::' target,
Xso that a default 'make' does not run a clean for instance.
X
XThen, if this is the first time, you have to bootstrap. Go to the main
Xdirectory of your package and run:
X
X	jmkmf
X	make Makefiles.SH
X
Xwhich will first produce the main makefile and then recursively build
Xall the makefiles.
X
XOnce you have bootstrapped once, you can edit a Jmakefile and rebuild
Xthe local makefile with
X
X	make Makefile
X
Xor all the hierachy below with:
X
X	make Makefiles.SH
X
XIf you want to extract all the makefiles, you may run
X
X	sh Makefile.SH
X	make Makefiles
X
Xin the top-level directory. Finally, if you only want to test the
Xgenerated Makefile.SH without disturbing the Makefile, run
X
X	make Makefile.SH
X
Xwhich will stop before running the produced file through sh.
X
X
XCAUTION:
X
XOn machines whose cpp eats up tabs in macro expansion, the Makefile.SH
Xproduced might not be indented properly inside rules.
X
XPerl 4.0 PL10 sometimes dumps core, while PL3 does not. Thus, perl 4.0
XPL10 should NOT be used with jmake, at least on a MIPS.
X
END_OF_FILE
  if test 2463 -ne `wc -c <'jmake/README'`; then
    echo shar: \"'jmake/README'\" unpacked with wrong size!
  fi
  # end of 'jmake/README'
fi
if test -f 'mcon/U/Config_h.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Config_h.U'\"
else
  echo shar: Extracting \"'mcon/U/Config_h.U'\" \(2577 characters\)
  sed "s/^X//" >'mcon/U/Config_h.U' <<'END_OF_FILE'
X?RCS: $Id: Config_h.U,v 3.0 1993/08/18 12:04:47 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Config_h.U,v $
X?RCS: Revision 3.0  1993/08/18  12:04:47  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: 
X?X: This file ends up producing the config_h.SH script, which is run to produce
X?X: the config.h file.  The file ./.Config_h below contains all the ?H: lines
X?X: extracted out of all the units.  Metaconfig itself adds the !GROK!THIS!.
X?X: Note that this code isn't included into Configure, but must be shipped with.
X?X:
X?X: For those who wish to know why the file is config_h.SH instead of the more
X?X: natural config.h.SH, well... it is to support systems like MS-DOG. Only one
X?X: 'dot' is allowed within the file name, as it is part of the "extension" of
X?X: the file. MS-DOG will not let you have two 'dots' because that would mean
X?X: two "extensions".
X?X: 
X?MAKE:Config_h: Id End Config_sh Obsol_h myuname cf_time cf_by
X?MAKE:	-pick c_h_weed $@ %<
X?MAKE:	-pick c_h_weed $@ ./Config_h
X?MAKE:	-pick c_h_weed $@ ./Obsol_h
X?T:CONFIG
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
X?X: Make sure we are in the directory where the .SH file is located.
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting config.h (with variable substitutions)"
Xsed <<!GROK!THIS! >config.h -e 's!^#undef!/\*#define!' -e 's!^#un-def!#undef!'
X/*
X * This file was produced by running the config_h.SH script, which
X * gets its values from config.sh, which is generally produced by
X * running Configure.
X *
X * Feel free to modify any of this as the need arises.  Note, however,
X * that running config.h.SH again will wipe out any changes you've made.
X * For a more permanent change edit config.sh and rerun config.h.SH.
X *
X * \$Id: Config_h.U,v 3.0 1993/08/18 12:04:47 ram Exp $
X */
X
X/* Configuration time: $cf_time
X * Configured by: $cf_by
X * Target system: $myuname
X */
X
X#ifndef _config_h_
X#define _config_h_
X
END_OF_FILE
  if test 2577 -ne `wc -c <'mcon/U/Config_h.U'`; then
    echo shar: \"'mcon/U/Config_h.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Config_h.U'
fi
if test -f 'mcon/U/Finish.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Finish.U'\"
else
  echo shar: Extracting \"'mcon/U/Finish.U'\" \(2441 characters\)
  sed "s/^X//" >'mcon/U/Finish.U' <<'END_OF_FILE'
X?RCS: $Id: Finish.U,v 3.0 1993/08/18 12:04:55 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Finish.U,v $
X?RCS: Revision 3.0  1993/08/18  12:04:55  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: 
X?X: This unit is the very last one in the Configure script.  It runs all the
X?X: SH files, which among other things produce config.h and (usually) Makefile.
X?X: It offers to do a make depend if the Makefile contains that target.
X?X: 
X?MAKE:Finish: Chk_MANI Extract Myread Oldsym Config_h cat rm contains
X?MAKE:	-pick add $@ %<
X: Finish up by extracting the .SH files
Xcase "$alldone" in
Xexit)
X	$rm -rf UU
X	echo "Done."
X	exit 0
X	;;
Xcont)
X	;;
X'')
X	echo " "
X	dflt=''
Xecho "If you didn't make any mistakes, then just type a carriage return here."
X	rp="If you need to edit config.sh, do it as a shell escape here:"
X	. UU/myread
X	case "$ans" in
X	'') ;;
X	*) : in case they cannot read
X		eval $ans;;
X	esac
X	;;
Xesac
X
X: if this fails, just run all the .SH files by hand
X. ./config.sh
X
X?X:
X?X: Turn silent mode off from now on (we want a verbose file extraction).
X?X: This means we have to explicitely test for '$silent' from now on to
X?X: strip off any verbose messages.
X?X:
Xecho " "
Xexec 1>&4
X. ./UU/extract
X
Xif $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
X	dflt=y
X	case "$silent" in
X	true) ;;
X	*)
X		$cat <<EOM
X
XNow you need to generate make dependencies by running "make depend".
XYou might prefer to run it in background: "make depend > makedepend.out &"
XIt can take a while, so you might not want to run it right now.
X
XEOM
X		;;
X	esac
X	rp="Run make depend now?"
X	. UU/myread
X	case "$ans" in
X	y*)
X		make depend && echo "Now you must run a make."
X		;;
X	*)
X		echo "You must run 'make depend' then 'make'."
X		;;
X	esac
Xelif test -f [Mm]akefile; then
X	echo " "
X	echo "Now you must run a make."
Xelse
X	echo "Done."
Xfi
X
X?X:
X?X: kit*isdone files are left over by shell archives built using the makedist
X?X: script which comes from dist, while ark*isdone files are left over by
X?X: the cshar archive maker.
X?X:
X$rm -f kit*isdone ark*isdone
X$rm -rf UU
X: End of Configure
END_OF_FILE
  if test 2441 -ne `wc -c <'mcon/U/Finish.U'`; then
    echo shar: \"'mcon/U/Finish.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Finish.U'
fi
if test -f 'mcon/U/Inhdr.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Inhdr.U'\"
else
  echo shar: Extracting \"'mcon/U/Inhdr.U'\" \(2542 characters\)
  sed "s/^X//" >'mcon/U/Inhdr.U' <<'END_OF_FILE'
X?RCS: $Id: Inhdr.U,v 3.0 1993/08/18 12:05:01 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Inhdr.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:01  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit checks wether a set of header files exists or not.
X?X:	If the first header is not found, the function tries to locate
X?X: the next header, and so on, until one is found or there is no
X?X: more header in the list.
X?X:
X?X: To use it, say:
X?X: set header i_header [ header2 i_header2 ... ]
X?X: eval $inhdr
X?X:
X?MAKE:Inhdr: test Findhdr Whoa
X?MAKE:	-pick add $@ %<
X?LINT:define inhdr
X?LINT:use ccflags
X?V:inhdr
X?S:inhdr:
X?S:	This shell variable is used internally by Configure to check
X?S:	wether a set of headers exist or not. A typical use is:
X?S:		set header i_header [ header2 i_header2 ... ]
X?S:		eval $inhdr
X?S:	That will print a message, saying wether header was found or
X?S:	not and set i_header* accordingly. If the first header is not
X?S: found, we try the next one, until the list is empty or one is found.
X?S:.
X?T:xxx xxf var td xxnf tu yyy instead was cont
X: define an alternate in-header-list? function
Xinhdr='echo " "; td=$define; tu=$undef; yyy=$@;
Xcont=true; xxf="echo \"<\$1> found.\" >&4";
Xcase $# in 2) xxnf="echo \"<\$1> NOT found.\" >&4";;
X*) xxnf="echo \"<\$1> NOT found, ...\" >&4";;
Xesac;
Xcase $# in 4) instead=instead;; *) instead="at last";; esac;
Xwhile $test "$cont"; do
X	xxx=`./findhdr $1`
X	var=$2; eval "was=\$$2";
X	if $test "$xxx" && $test -r "$xxx";
X	then eval $xxf;
X		eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
X		cont="";
X	else eval $xxnf;
X		eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi;
X	set $yyy; shift; shift; yyy=$@;
X	case $# in 0) cont="";;
X	2) xxf="echo \"but I found <\$1> $instead.\" >&4";
X		xxnf="echo \"and I did not find <\$1> either.\" >&4";;
X	*) xxf="echo \"but I found <\$1\> instead.\" >&4";
X		xxnf="echo \"there is no <\$1>, ...\" >&4";;
X	esac;
Xdone;
X?X: Remaining values are set to 'undef'
Xwhile $test "$yyy";
Xdo set $yyy; var=$2; eval "was=\$$2";
X	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu";
X	set $yyy; shift; shift; yyy=$@;
Xdone'
X
END_OF_FILE
  if test 2542 -ne `wc -c <'mcon/U/Inhdr.U'`; then
    echo shar: \"'mcon/U/Inhdr.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Inhdr.U'
fi
if test -f 'mcon/U/bin.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/bin.U'\"
else
  echo shar: Extracting \"'mcon/U/bin.U'\" \(2463 characters\)
  sed "s/^X//" >'mcon/U/bin.U' <<'END_OF_FILE'
X?RCS: $Id: bin.U,v 3.0 1993/08/18 12:05:26 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: bin.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:26  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:bin binexp installbin: Getfile Loc Oldconfig afs cat
X?MAKE:	-pick add $@ %<
X?S:bin:
X?S:	This variable holds the name of the directory in which the user wants
X?S:	to put publicly executable images for the package in question.  It
X?S:	is most often a local directory such as /usr/local/bin. Programs using
X?S:	this variable must be prepared to deal with ~name substitution.
X?S:.
X?S:binexp:
X?S:	This is the same as the bin variable, but is filename expanded at
X?S:	configuration time, for use in your makefiles.
X?S:.
X?S:installbin:
X?S:	This variable is the same as binexp unless AFS is running in which case
X?S:	the user is explicitely prompted for it. This variable should always
X?S:	be used in your makefiles for maximum portability.
X?S:.
X?C:BIN:
X?C:	This symbol holds the path of the bin directory where the package will
X?C:	be installed. Program must be prepared to deal with ~name substitution.
X?C:.
X?C:BIN_EXP:
X?C:	This symbol is the filename expanded version of the BIN symbol, for
X?C:	programs that do not want to deal with that at run-time.
X?C:.
X?H:#define BIN "$bin"	/**/
X?H:#define BIN_EXP "$binexp"	/**/
X?H:.
X?D:bin='/usr/local/bin'
X: determine where public executables go
Xecho " "
Xcase "$bin" in
X'')
X	dflt=`./loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
X	;;
X*)
X	dflt="$bin"
X	;;
Xesac
Xfn=d~
Xrp='Where do you want to put the public executables?'
X. ./getfile
Xbin="$ans"
Xbinexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xexecutables reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installbin" in
X	'') dflt=`echo $binexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installbin";;
X	esac
X	fn=de~
X	rp='Where will public executables be installed?'
X	. ./getfile
X	installbin="$ans"
Xelse
X	installbin="$binexp"
Xfi
X
END_OF_FILE
  if test 2463 -ne `wc -c <'mcon/U/bin.U'`; then
    echo shar: \"'mcon/U/bin.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/bin.U'
fi
if test -f 'mcon/U/d_NeWS.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_NeWS.U'\"
else
  echo shar: Extracting \"'mcon/U/d_NeWS.U'\" \(2785 characters\)
  sed "s/^X//" >'mcon/U/d_NeWS.U' <<'END_OF_FILE'
X?RCS: $Id: d_NeWS.U,v 3.0 1993/08/18 12:05:39 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_NeWS.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:39  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_news d_news0 d_newshome d_textcan: test rm Myread Getfile
X?MAKE:	-pick add $@ %<
X?S:d_news:
X?S:	Set if running NeWS 1.1
X?S:.
X?S:d_news0:
X?S:	Set if running NeWS 1.0
X?S:.
X?S:d_newshome:
X?S:	Path to the top directory of the NeWS structure.
X?S:.
X?S:d_textcan:
X?S:	Path to where the textcan.ps stuff is...
X?S:.
X?C:HAS_NEWS1_1 (NEWS1_1):
X?C:	This symbol defined if running NeWS 1.1.
X?C:.
X?C:HAS_NEWS1_0 (NEWS1_0):
X?C:	This symbol defined if running NeWS 1.0.
X?C:.
X?C:TEXTCAN:
X?C:	Tells path to where the textcan.ps stuff is...
X?C:.
X?H:#$d_news HAS_NEWS1_1     /**/
X?H:#$d_news0 HAS_NEWS1_0     /**/
X?H:#define TEXTCAN $d_textcan /**/
X?H:.
X?INIT:: default path for NeWS
X?INIT:d_newshome="/usr/NeWS"
X?INIT:
X: Check to see what version of NeWS is being run?
Xcd ..
Xecho " "
Xecho "Now for the interesting stuff... Lets see what kind of NeWS"
Xecho "they grow round here...."
Xecho " "
Xdflt='y'
Xif $test -d $d_newshome; then
X	d_newshome=`(cd $d_newshome ; /bin/pwd)`
X	echo "Ah...found myself a NeWS in $d_newshome..."
X	dflt='y'
X	rp="Is this the NeWS you want your children to grow up with?"
X	. UU/myread
Xfi
Xwhile $test $ans = "n"; do
Xdflt=$d_newshome
Xfn=d
Xrp="Path to NeWS you want:"
X. UU/getfile
Xd_newshome=$ans
X
Xecho " "
Xif $test ! -d $d_newshome/lib; then
X	echo "ARG!  No lib directory in $d_newshome!!!"
X	: heavy medicine.  I wonder what the disease is...
X	$rm -f kit*isdone
X	$rm -rf UU
X	: bye bye
X	set -t; echo "Sorry... no NeWS is bad news..."
Xfi
X
Xif $test -r $d_newshome/lib/NeWS/colors.ps ; then
X	echo 'Ahh... your running NeWS 1.1!  Boy... that makes stuff easy....'
X	echo " "
X	d_news="$define" 
X	d_news0="$undef"
X	if $test -r $d_newshome/lib/NeWS/textcan.ps; then
X		d_textcan=$d_newshome/lib/NeWS
X		echo "The textcan.ps stuff seems to be in : $d_textcan"
X	else
X		d_textcan=$d_newshome/clientsrc/client/nterm
X		if $test ! -r $d_textcan/textcan.ps; then
X			d_news="$undef"
X			d_news0="$define"
X			echo 'Hmm... must have been fooled... gotta be NeWS 1.1 beta!'
X		else
X			echo "The textcan.ps stuff seems to be in : $d_textcan"
X		fi
X	fi
Xelse
X	echo 'snif... snif... I smell the dilapidated smell of NeWS 1.0..'
X	echo 'Some things will not work under NeWS 1.0...'
X	d_news="$undef"
X	d_news0="$define"
Xfi
Xcd UU
X
END_OF_FILE
  if test 2785 -ne `wc -c <'mcon/U/d_NeWS.U'`; then
    echo shar: \"'mcon/U/d_NeWS.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_NeWS.U'
fi
if test -f 'mcon/U/d_castneg.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_castneg.U'\"
else
  echo shar: Extracting \"'mcon/U/d_castneg.U'\" \(2692 characters\)
  sed "s/^X//" >'mcon/U/d_castneg.U' <<'END_OF_FILE'
X?RCS: $Id: d_castneg.U,v 3.0 1993/08/18 12:05:47 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_castneg.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:47  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X:	Can the compiler cast negative / odd floats to unsigned values.
X?X:
X?MAKE:d_castneg castflags: cat cc ccflags rm Setvar
X?MAKE:	-pick add $@ %<
X?S:d_castneg:
X?S:	This variable conditionally defines CASTNEG, which indicates
X?S:	wether the C compiler can cast negative float to unsigned.
X?S:.
X?S:castflags:
X?S:	This variable contains a flag that precise difficulties the
X?S:	compiler has casting odd floating values to unsigned long:
X?S:		0 = ok
X?S:		1 = couldn't cast < 0
X?S:		2 = couldn't cast >= 0x80000000
X?S:.
X?C:CASTNEGFLOAT:
X?C:	This symbol is defined if the C compiler can cast negative
X?C:	numbers to unsigned longs, ints and shorts.
X?C:.
X?C:CASTFLAGS:
X?C:	This symbol contains flags that say what difficulties the compiler
X?C:	has casting odd floating values to unsigned long:
X?C:		0 = ok
X?C:		1 = couldn't cast < 0
X?C:		2 = couldn't cast >= 0x80000000
X?C:.
X?H:#$d_castneg	CASTNEGFLOAT		/**/
X?H:#define CASTFLAGS $castflags		/**/
X?H:.
X?LINT:set d_castneg
X: check for ability to cast negative floats to unsigned
Xecho " "
Xecho 'Checking whether your C compiler can cast negative float to unsigned.' >&4
X$cat >try.c <<'EOCP'
X#include <signal.h>
Xblech() { exit(3); }
Xmain()
X{
X	double f = -123;
X	unsigned long along;
X	unsigned int aint;
X	unsigned short ashort;
X	int result = 0;
X
X	signal(SIGFPE, blech);
X	along = (unsigned long)f;
X	aint = (unsigned int)f;
X	ashort = (unsigned short)f;
X	if (along != (unsigned long)-123)
X		result |= 1;
X	if (aint != (unsigned int)-123)
X		result |= 1;
X	if (ashort != (unsigned short)-123)
X		result |= 1;
X	f = (double)0x40000000;
X	f = f + f;
X	along = 0;
X	along = (unsigned long)f;
X	if (along != 0x80000000)
X		result |= 2;
X	f -= 1.;
X	along = 0;
X	along = (unsigned long)f;
X	if (along != 0x7fffffff)
X		result |= 1;
X	f += 2.;
X	along = 0;
X	along = (unsigned long)f;
X	if (along != 0x80000001)
X		result |= 2;
X	exit(result);
X
X}
XEOCP
Xif $cc -o try $ccflags try.c >/dev/null 2>&1; then
X	./try
X	castflags=$?
Xelse
X	castflags=3
Xfi
Xcase "$castflags" in
X0)	val="$define"
X	echo "Yup, it can."
X	;;
X*)	val="$undef"
X	echo "Nope, it can't."
X	;;
Xesac
Xset d_castneg
Xeval $setvar
X$rm -f try.*
X
END_OF_FILE
  if test 2692 -ne `wc -c <'mcon/U/d_castneg.U'`; then
    echo shar: \"'mcon/U/d_castneg.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_castneg.U'
fi
if test -f 'mcon/U/d_flexfnam.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_flexfnam.U'\"
else
  echo shar: Extracting \"'mcon/U/d_flexfnam.U'\" \(2547 characters\)
  sed "s/^X//" >'mcon/U/d_flexfnam.U' <<'END_OF_FILE'
X?RCS: $Id: d_flexfnam.U,v 3.0 1993/08/18 12:06:04 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_flexfnam.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:04  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_flexfnam: cat rm test Setvar
X?MAKE:	-pick add $@ %<
X?S:d_flexfnam:
X?S:	This variable conditionally defines the FLEXFILENAMES symbol, which
X?S:	indicates that the system supports filenames longer than 14 characters.
X?S:.
X?C:FLEXFILENAMES:
X?C:	This symbol, if defined, indicates that the system supports filenames
X?C:	longer than 14 characters.
X?C:.
X?H:#$d_flexfnam	FLEXFILENAMES		/**/
X?H:.
X?T:first second
X?LINT:set d_flexfnam
X: see if we can have long filenames
Xecho " "
X?X:
X?X: We have to test in both /tmp and . because of NFS (remote server may allow
X?X: long filenames while the local filesystem cannot support them). If at least
X?X: one of those file systems cannot support long filenames, then we assume the
X?X: whole system can't.
X?X:
Xrmlist="$rmlist /tmp/cf$$"
X$test -d /tmp/cf$$ || mkdir /tmp/cf$$
Xfirst=123456789abcdef
Xsecond=/tmp/cf$$/$first
X$rm -f $first $second
Xif (echo hi >$first) 2>/dev/null; then
X	if $test -f 123456789abcde; then
X		echo 'You cannot have filenames longer than 14 characters.  Sigh.' >&4
X		val="$undef"
X	else
X		if (echo hi >$second) 2>/dev/null; then
X			if $test -f /tmp/cf$$/123456789abcde; then
X				$cat <<'EOM'
XThat's peculiar... You can have filenames longer than 14 characters, but only
Xon some of the filesystems.  Maybe you are using NFS.  Anyway, to avoid problems
XI shall consider your system cannot support long filenames at all.
XEOM
X				val="$undef"
X			else
X				echo 'You can have filenames longer than 14 characters.' >&4
X				val="$define"
X			fi
X		else
X			$cat <<'EOM'
XHow confusing! Some of your filesystems are sane enough to allow filenames
Xlonger than 14 characters but some others like /tmp can't even think about them.
XSo, for now on, I shall assume your kernel does not allow them at all.
XEOM
X			val="$undef"
X		fi
X	fi
Xelse
X	$cat <<'EOM'
XYou can't have filenames longer than 14 chars.  You can't even think about them!
XEOM
X	val="$undef"
Xfi 
Xset d_flexfnam
Xeval $setvar
X$rm -rf /tmp/cf$$ 123456789abcde*
X
END_OF_FILE
  if test 2547 -ne `wc -c <'mcon/U/d_flexfnam.U'`; then
    echo shar: \"'mcon/U/d_flexfnam.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_flexfnam.U'
fi
if test -f 'mcon/U/d_ftime.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_ftime.U'\"
else
  echo shar: Extracting \"'mcon/U/d_ftime.U'\" \(2582 characters\)
  sed "s/^X//" >'mcon/U/d_ftime.U' <<'END_OF_FILE'
X?RCS: $Id: d_ftime.U,v 3.0 1993/08/18 12:06:06 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_ftime.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:06  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_ftime d_gettimeod: Inlibc Setvar
X?MAKE:	-pick add $@ %<
X?S:d_ftime:
X?S:	This variable conditionally defines the HAS_FTIME symbol, which indicates
X?S:	that the ftime() routine exists.  The ftime() routine is basically
X?S:	a sub-second accuracy clock.
X?S:.
X?S:d_gettimeod:
X?S:	This variable conditionally defines the HAS_GETTIMEOFDAY symbol, which
X?S:	indicates that the gettimeofday() system call exists (to obtain a
X?S: sub-second accuracy clock). You should probably include <sys/resource.h>.
X?S:.
X?C:HAS_FTIME (FTIMER):
X?C:	This symbol, if defined, indicates that the ftime() routine exists.
X?C:	It is basically a sub-second accuracy clock, but is less accurate
X?C:	than gettimeofday(2) anyway. The type "Timeval" should be used to
X?C:	refer to "struct timeb".
X?C:.
X?C:HAS_GETTIMEOFDAY (GETTIMEOFDAY):
X?C:	This symbol, if defined, indicates that the gettimeofday() system
X?C:	call is available for a sub-second accuracy clock. Usually, the file
X?C:	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
X?C:	The type "Timeval" should be used to refer to "struct timeval".
X?C:.
X?H:#$d_ftime HAS_FTIME		/**/
X?H:#$d_gettimeod HAS_GETTIMEOFDAY	/**/
X?H:?%<:@if HAS_FTIME
X?H:?%<:#ifdef HAS_FTIME
X?H:?%<:#define Timeval struct timeb		/* Structure used by ftime() */
X?H:?%<:#endif
X?H:?%<:@end
X?H:?%<:@if HAS_GETTIMEOFDAY
X?H:?%<:#ifdef HAS_GETTIMEOFDAY
X?H:?%<:#define Timeval struct timeval	/* Structure used by gettimeofday() */
X?H:?%<:#endif
X?H:?%<:@end
X?H:.
X?X:FIXME
X?X:?I:?d_ftime:i_systimeb
X?X:?I:?d_gettimeod:i_sysresrc
X?LINT:set d_gettimeod d_ftime
X?LINT:known Timeval
X: see if gettimeofday or ftime exists
X?X:
X?X:	Give priority to gettimeofday(2) because timing is more accurate
X?X:
Xset gettimeofday d_gettimeod
Xeval $inlibc
Xcase "$d_gettimeod" in
X"$undef")
X	set ftime d_ftime 
X	eval $inlibc
X	;;
X*)
X	val="$undef"; set d_ftime; eval $setvar
X	;;
Xesac
Xcase "$d_gettimeod$d_ftime" in
X"$undef$undef")
X	echo " "
X	echo 'No ftime() nor gettimeofday() -- timing may be less accurate.' >&4
X	;;
Xesac
X
END_OF_FILE
  if test 2582 -ne `wc -c <'mcon/U/d_ftime.U'`; then
    echo shar: \"'mcon/U/d_ftime.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_ftime.U'
fi
if test -f 'mcon/U/d_inetd.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_inetd.U'\"
else
  echo shar: Extracting \"'mcon/U/d_inetd.U'\" \(2421 characters\)
  sed "s/^X//" >'mcon/U/d_inetd.U' <<'END_OF_FILE'
X?RCS: $Id: d_inetd.U,v 3.0 1993/08/18 12:06:23 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_inetd.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:23  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_inetd: cat test package Myread Setvar
X?MAKE:	-pick add $@ %<
X?S:d_inetd:
X?S:	This symbol conditionally defines USE_INETD which indicates to the C
X?S:	program that the initial socket connection will be done via inetd.
X?S:.
X?C:USE_INETD (INETD):
X?C:	This symbol if defined indicates to the C program that inetd will be
X?C:	in charge of the initial socket connection. The file descriptors 0 and
X?C:	1 have been dup()ed from the original connected socket descriptor and
X?C:	are ready for send() and recv().
X?C:.
X?H:#$d_inetd USE_INETD		/**/
X?H:.
X?LINT:set d_inetd
X: ask whether initial socket connection is to be done via inetd
Xecho " "
Xdflt=n
Xcase "$d_inetd" in
X'') if $test -f /etc/inetd.conf; then
X		$cat <<EOM
XYour system provides a so called "Internet super-server", the inetd daemon.
XNetwork services like ftp or rlogin are usually handled via ftpd and rlogind
Xdaemons. Without inetd, these daemons must always be running for the service
Xto be on. On the contrary, inetd listens to specific ports defined in file
X/etc/inetd.conf and will run the appropriate daemon upon request. This scheme
Xavoids eating up the process table and memory with useless daemons.
X
XI can set up things so that internet connections for $package will be done
Xusing inetd, in which case you will have to edit /etc/inetd.conf to add some
Xspecific informations.
X
XEOM
X		dflt=y
X	else
X		$cat <<EOM
XI do not see any trace of a configuration file for inetd, hence I assume your
Xsystem does not support the so called "Internet super-server". This means
X$package will need to have a daemon process running on this machine to allow
Xnetwork connections.
X
XEOM
X	fi;;
X*) case "$d_inetd" in
X	"$define") dflt=y;;
X	esac;;
Xesac
Xrp='Do you wish to use inetd for network connections?'
X. ./myread
Xval="$undef"
Xcase "$ans" in
Xy*|Y*) val="$define";;
Xesac
Xset d_inetd
Xeval $setvar
X
END_OF_FILE
  if test 2421 -ne `wc -c <'mcon/U/d_inetd.U'`; then
    echo shar: \"'mcon/U/d_inetd.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_inetd.U'
fi
if test -f 'mcon/U/d_setpgrp.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_setpgrp.U'\"
else
  echo shar: Extracting \"'mcon/U/d_setpgrp.U'\" \(2391 characters\)
  sed "s/^X//" >'mcon/U/d_setpgrp.U' <<'END_OF_FILE'
X?RCS: $Id: d_setpgrp.U,v 3.0 1993/08/18 12:07:09 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_setpgrp.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:09  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_setpgrp d_bsdpgrp: cat rm +cc +libs +ccflags Inlibc Guess Setvar
X?MAKE:	-pick add $@ %<
X?S:d_setpgrp:
X?S:	This variable conditionally defines HAS_SETPGRP if setpgrp() is
X?S:	available to set the current process group.
X?S:.
X?S:d_bsdpgrp:
X?S:	This variable conditionally defines USE_BSDPGRP if the notion of
X?S:	process group is the BSD one. This means setpgrp needs two arguments
X?S:	whereas USG one needs none.
X?S:.
X?C:HAS_SETPGRP (SETPGRP):
X?C:	This symbol, if defined, indicates that the setpgrp routine is
X?C:	available to set the current process group.
X?C:.
X?C:USE_BSDPGRP (BSDPGRP):
X?C:	This symbol, if defined, indicates that the BSD notion of process
X?C:	group is to be used. For instance, you have to say setpgrp(pid, pgrp)
X?C:	instead of the USG setpgrp().
X?C:.
X?H:#$d_setpgrp HAS_SETPGRP		/**/
X?H:#$d_bsdpgrp USE_BSDPGRP		/**/
X?H:.
X?T:xxx
X?LINT:set d_setpgrp d_bsdpgrp
X: see if setpgrp exists
Xset setpgrp d_setpgrp
Xeval $inlibc
X
X@if USE_BSDPGRP || d_bsdpgrp
X: see which flavor of setpgrp is in use
Xcase "$d_setpgrp" in
X"$define")
X	echo " "
X	$cat >set.c <<EOP
Xmain()
X{
X	if (getuid() == 0) {
X		printf("(I see you are running Configure as super-user...)\n");
X		setuid(1);
X	}
X	if (-1 == setpgrp(1, 1))
X		exit(1);
X	exit(0);
X}
XEOP
X	if $cc $ccflags -o set set.c $libs >/dev/null 2>&1; then
X		./set 2>/dev/null
X		case $? in
X		0) echo "You have to use setpgrp() instead of setpgrp(pid, pgrp)." >&4
X			val="$undef";;
X		*) echo "You have to use setpgrp(pid, pgrp) instead of setpgrp()." >&4
X			val="$define";;
X		esac
X	else
X		if usg; then
X			xxx="USG one, i.e. you use setpgrp()."
X			val="$undef"
X		else
X			xxx="BSD one, i.e. you use setpgrp(pid, pgrp)."
X			val="$define"
X		fi
X		echo "Assuming your setpgrp is a $xxx" >&4
X	fi
X	;;
X*) val="$undef";;
Xesac
Xset d_bsdpgrp
Xeval $setvar
X$rm -f set set.c
X
X@end
END_OF_FILE
  if test 2391 -ne `wc -c <'mcon/U/d_setpgrp.U'`; then
    echo shar: \"'mcon/U/d_setpgrp.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_setpgrp.U'
fi
if test -f 'mcon/U/d_sigsetmk.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_sigsetmk.U'\"
else
  echo shar: Extracting \"'mcon/U/d_sigsetmk.U'\" \(1397 characters\)
  sed "s/^X//" >'mcon/U/d_sigsetmk.U' <<'END_OF_FILE'
X?RCS: $Id: d_sigsetmk.U,v 3.0 1993/08/18 12:07:23 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_sigsetmk.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:23  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_sigsetmk: Csym Setvar
X?MAKE:	-pick add $@ %<
X?S:d_sigsetmk:
X?S:	This variable conditionally defines the HAS_SIGSETMASK symbol, which
X?S:	indicates to the C program that the sigsetmask() routine is available
X?S:	to set current signal mask.
X?S:.
X?C:HAS_SIGSETMASK (SIGSETMASK):
X?C:	This symbol, if defined, indicates that the sigsetmask() routine is
X?C:	available to set current signal mask. Otherwise, you should probably
X?C:	emulate this by using signal(), but fear race conditions...
X?C:.
X?H:#$d_sigsetmk HAS_SIGSETMASK		/**/
X?H:.
X?LINT:set d_sigsetmk
X: see if sigsetmask exists
Xecho " "
Xif set sigsetmask val -f d_sigsetmk; eval $csym; $val; then
X	echo 'sigsetmask() found.' >&4
X	val="$define"
Xelse
X	echo "sigsetmask() not found -- We'll use signal()." >&4
X	val="$undef"
Xfi
Xset d_sigsetmk
Xeval $setvar
X
END_OF_FILE
  if test 1397 -ne `wc -c <'mcon/U/d_sigsetmk.U'`; then
    echo shar: \"'mcon/U/d_sigsetmk.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_sigsetmk.U'
fi
if test -f 'mcon/U/d_voidsig.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_voidsig.U'\"
else
  echo shar: Extracting \"'mcon/U/d_voidsig.U'\" \(2712 characters\)
  sed "s/^X//" >'mcon/U/d_voidsig.U' <<'END_OF_FILE'
X?RCS: $Id: d_voidsig.U,v 3.0 1993/08/18 12:07:56 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_voidsig.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:56  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_voidsig signal_t: rm contains cppstdin cppminus cppflags test Myread \
X	Oldconfig Setvar Findhdr
X?MAKE:	-pick add $@ %<
X?S:d_voidsig:
X?S:	This variable conditionally defines VOIDSIG if this system
X?S:	declares "void (*signal(...))()" in signal.h.  The old way was to
X?S:	declare it as "int (*signal(...))()".
X?S:.
X?S:signal_t:
X?S:	This variable holds the type of the signal handler (void or int).
X?S:.
X?C:VOIDSIG:
X?C:	This symbol is defined if this system declares "void (*signal(...))()" in
X?C:	signal.h.  The old way was to declare it as "int (*signal(...))()".  It
X?C:	is up to the package author to declare things correctly based on the
X?C:	symbol.
X?C:.
X?C:Signal_t (SIGNAL_T):
X?C:	This symbol's value is either "void" or "int", corresponding to the
X?C:	appropriate return type of a signal handler.  Thus, you can declare
X?C:	a signal handler using "Signal_t (*handler)()", and define the
X?C:	handler using "Signal_t handler(sig)".
X?C:.
X?H:#$d_voidsig VOIDSIG 	/**/
X?H:#define Signal_t $signal_t	/* Signal handler's return type */
X?H:.
X?T:xxx
X?LINT:set d_voidsig
X: see if signal is declared as pointer to function returning int or void
Xecho " "
Xxxx=`./findhdr signal.h`
X$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
Xif $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have int (*signal())() instead of void." >&4
X	val="$undef"
X	signal_t="int"
Xelif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have void (*signal())() instead of int." >&4
X	val="$define"
X	signal_t="void"
Xelif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
X	echo "You have int (*signal())() instead of void." >&4
X	val="$undef"
X	signal_t="int"
Xelse
X	case "$d_voidsig" in
X	'')
X	echo "I can't determine whether signal handler returns void or int..." >&4
X		dflt=void
X		rp="What type does your signal handler returns?"
X		. ./myread
X		case "$ans" in
X		void) val="$define"; signal_t="void";;
X		*) val="$undef"; signal_t="int";;
X		esac;;
X	*) echo "As you already told me, signal handler returns $signal_t." >&4;;
X	esac
Xfi
Xset d_voidsig
Xeval $setvar
X$rm -f $$.tmp
X
END_OF_FILE
  if test 2712 -ne `wc -c <'mcon/U/d_voidsig.U'`; then
    echo shar: \"'mcon/U/d_voidsig.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_voidsig.U'
fi
if test -f 'mcon/U/libs.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/libs.U'\"
else
  echo shar: Extracting \"'mcon/U/libs.U'\" \(2737 characters\)
  sed "s/^X//" >'mcon/U/libs.U' <<'END_OF_FILE'
X?RCS: $Id: libs.U,v 3.0 1993/08/18 12:09:03 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: libs.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:03  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:libs: test cat Myread Oldconfig Loc libpth incpath package xlibpth
X?MAKE:	-pick add $@ %<
X?S:libs:
X?S:	This variable holds the additional libraries we want to use.
X?S: It is up to the Makefile to deal with it.
X?S:.
X?T:xxx yyy thislib thatlib libswanted
X?INIT:: no additional library wanted by default
X?INIT:libswanted=''
X?INIT:
X: Looking for optional libraries
Xecho " "
Xecho "Checking for optional libraries..." >&4
Xcase "$libs" in
X' '|'') dflt='';;
X*) dflt="$libs";;
Xesac
Xcase "$libswanted" in
X'') libswanted='c_s';;
Xesac
Xfor thislib in $libswanted; do
X	case "$thislib" in
X	dbm) thatlib=ndbm;;
X	*_s) thatlib=NONE;;
X	*) thatlib="${thislib}_s";;
X	*) thatlib=NONE;;
X	esac
X	yyy="$incpath/usr/ccs/lib $incpath/usr/lib $incpath/usr/ucblib"
X	yyy="$yyy $incpath/usr/local/lib $incpath/lib"
X	xxx=`./loc lib$thislib.a X $yyy`
X	if $test -f $xxx; then
X		echo "Found -l$thislib."
X		case "$dflt" in
X		*-l$thislib*|*-l$thatlib*);;
X		*) dflt="$dflt -l$thislib";;
X		esac
X	else
X		xxx=`./loc lib$thislib.a X $libpth`
X		if $test -f $xxx; then
X			echo "Found $xxx."
X			case "$dflt" in
X			*$xxx*);;
X			*) dflt="$dflt $xxx";;
X			esac
X		else
X			xxx=`./loc Slib$thislib.a X $xlibpth`
X			if $test -f $xxx; then
X				echo "Found -l$thislib."
X				case "$dflt" in
X				*-l$thislib*|*-l$thatlib*);;
X				*) dflt="$dflt -l$thislib";;
X				esac
X			else
X				echo "No -l$thislib."
X			fi
X		fi
X	fi
Xdone
Xset X $dflt
Xshift
Xdflt="$*"
Xcase "$libs" in
X'') dflt="$dflt";;
X*) dflt="$libs";;
Xesac
Xcase "$dflt" in
X' '|'') dflt='none';;
Xesac
X
X$cat <<EOM
X 
XSome versions of Unix support shared libraries, which make executables smaller
Xbut make load time slightly longer.
X
XOn some systems, mostly newer Unix System V's, the shared library is included
Xby putting the option "-lc_s" as the last thing on the cc command line when
Xlinking.  Other systems use shared libraries by default.  There may be other
Xlibraries needed to compile $package on your machine as well.  If your system
Xneeds the "-lc_s" option, include it here.  Include any other special libraries
Xhere as well.  Say "none" for none.
XEOM
X
Xecho " "
Xrp="Any additional libraries?"
X. ./myread
Xcase "$ans" in
Xnone) libs=' ';;
X*) libs="$ans";;
Xesac
X
END_OF_FILE
  if test 2737 -ne `wc -c <'mcon/U/libs.U'`; then
    echo shar: \"'mcon/U/libs.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/libs.U'
fi
if test -f 'mcon/U/mallocsrc.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/mallocsrc.U'\"
else
  echo shar: Extracting \"'mcon/U/mallocsrc.U'\" \(2779 characters\)
  sed "s/^X//" >'mcon/U/mallocsrc.U' <<'END_OF_FILE'
X?RCS: $Id: mallocsrc.U,v 3.0 1993/08/18 12:09:12 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: mallocsrc.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:12  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:mallocsrc mallocobj usemymalloc malloctype: Myread Oldconfig package \
X	Guess test rm cat +cc +ccflags Findhdr
X?MAKE:	-pick add $@ %<
X?S:usemymalloc:
X?S:	This variable contains y if the malloc that comes with this package
X?S:	is desired over the system's version of malloc.  People often include
X?S:	special versions of malloc for effiency, but such versions are often
X?S:	less portable.  See also mallocsrc and mallocobj.
X?S:.
X?S:mallocsrc:
X?S:	This variable contains the name of the malloc.c that comes with
X?S:	the package, if that malloc.c is preferred over the system malloc.
X?S:	Otherwise the value is null.  This variable is intended for generating
X?S:	Makefiles.
X?S:.
X?S:mallocobj:
X?S:	This variable contains the name of the malloc.o that this package
X?S:	generates, if that malloc.o is preferred over the system malloc.
X?S:	Otherwise the value is null.  This variable is intended for generating
X?S:	Makefiles.  See mallocsrc.
X?S:.
X?S:malloctype:
X?S:	This variable contains the kind of ptr returned by malloc and realloc.
X?S:.
X?C:Malloc_t (MALLOCPTRTYPE):
X?C:	This symbol is the type of pointer returned by malloc and realloc.
X?C:.
X?H:#define Malloc_t $malloctype			/**/
X?H:.
X?X: Cannot test for mallocsrc; it is the unit's name and there is a bug in
X?X: the interpreter which defines all the names, even though they are not used.
X@if mallocobj
X: determine which malloc to compile in
Xecho " "
Xcase "$usemymalloc" in
X'')
X	if bsd || v7; then
X		dflt='y'
X	else
X		dflt='n'
X	fi
X	;;
X*)  dflt="$usemymalloc"
X	;;
Xesac
Xrp="Do you wish to attempt to use the malloc that comes with $package?"
X. ./myread
Xusemymalloc="$ans"
Xcase "$ans" in
Xy*) mallocsrc='malloc.c'; mallocobj='malloc.o';;
X*) mallocsrc=''; mallocobj='';;
Xesac
X
X@end
X@if MALLOCPTRTYPE || Malloc_t
X: compute the type returned by malloc
Xecho " "
Xcase "$malloctype" in
X'')
X	if $test `./findhdr malloc.h`; then
X		echo "#include <malloc.h>" > malloc.c
X	fi
X#include <malloc.h>
X	$cat >>malloc.c <<'END'
Xvoid *malloc();
XEND
X	if $cc $ccflags -c malloc.c >/dev/null 2>&1; then
X		malloctype='void *'
X	else
X		malloctype='char *'
X	fi
X	$rm -f malloc.[co]
X	;;
Xesac
Xecho "Your system wants malloc to return '$malloctype', it would seem." >&4
X
X@end
END_OF_FILE
  if test 2779 -ne `wc -c <'mcon/U/mallocsrc.U'`; then
    echo shar: \"'mcon/U/mallocsrc.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/mallocsrc.U'
fi
if test -f 'mcon/U/usenm.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/usenm.U'\"
else
  echo shar: Extracting \"'mcon/U/usenm.U'\" \(2519 characters\)
  sed "s/^X//" >'mcon/U/usenm.U' <<'END_OF_FILE'
X?RCS: $Id: usenm.U,v 3.0 1993/08/18 12:09:57 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: usenm.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:57  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:usenm runnm nm_opt: cat test Myread Oldconfig
X?MAKE:	-pick add $@ %<
X?S:usenm:
X?S:	This variable contains 'true' or 'false' depending whether the
X?S:	nm extraction is wanted or not.
X?S:.
X?S:runnm:
X?S:	This variable contains 'true' or 'false' depending whether the
X?S:	nm extraction should be performed or not, according to the value
X?S:	of usenm and the flags on the Configure command line.
X?S:.
X?S:nm_opt:
X?S:	This variable holds the options that may be necessary for nm.
X?S:.
X: see if nm is to be used to determine whether a symbol is defined or not
X?X: If there is enough enquiries, it might be worth to wait for the nm
X?X: extraction. Otherwise, the C compilations might be a better deal.
Xcase "$usenm" in
X'')
X	dflt=`egrep 'inlibc|csym' ../Configure | wc -l 2>/dev/null`
X	if $test $dflt -gt 20; then
X		dflt=y
X	else
X		dflt=n
X	fi
X	;;
X*)
X	case "$usenm" in
X	true) dflt=y;;
X	*) dflt=n;;
X	esac
X	;;
Xesac
X$cat <<EOM
X
XI can use 'nm' to extract the symbols from your C libraries. This is a time
Xconsuming task which may generate huge output on the disk (up to 3 megabytes)
Xbut that should make the symbols extraction faster. The alternative is to skip
Xthe 'nm' extraction part and to compile a small test program instead to
Xdetermine whether each symbol is present. If you have a fast C compiler and/or
Xif your 'nm' output cannot be parsed, this may be the best solution.
X
XEOM
Xrp='Shall I use nm to extract C symbols from the libraries?'
X. ./myread
Xcase "$ans" in
Xn|N) usenm=false;;
X*) usenm=true;;
Xesac
X
X?X: Name extraction is to be run if 'nm' usage is wanted and if no -r flag
X?X: was provided to configure (in which case we simply re-use the previous
X?X: values).
Xrunnm=$usenm
Xcase "$reuseval" in
Xtrue) runnm=false;;
Xesac
X
X: nm options which may be necessary
Xcase "$nm_opt" in
X'') if $test -f /mach_boot; then
X		nm_opt=''
X	elif $test -d /usr/ccs/lib; then
X		nm_opt='-p'
X	elif $test -f /dgux; then
X		nm_opt='-p'
X	else
X		nm_opt=''
X	fi;;
Xesac
X
END_OF_FILE
  if test 2519 -ne `wc -c <'mcon/U/usenm.U'`; then
    echo shar: \"'mcon/U/usenm.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/usenm.U'
fi
if test -f 'mcon/pl/depend.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/depend.pl'\"
else
  echo shar: Extracting \"'mcon/pl/depend.pl'\" \(2576 characters\)
  sed "s/^X//" >'mcon/pl/depend.pl' <<'END_OF_FILE'
X;# $Id: depend.pl,v 3.0 1993/08/18 12:10:21 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: depend.pl,v $
X;# Revision 3.0  1993/08/18  12:10:21  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# Metaconfig-dependent part of the dependency extranction.
X;#
X# Process the ?W: lines
Xsub p_wanted {
X	# Syntax is ?W:<shell symbols>:<C symbols>
X	local($active) = $_[0] =~ /^([^:]*):/;		# Symbols to activate
X	local($look_symbols) = $_[0] =~ /:(.*)/;	# When those are used
X	local(@syms) = split(/ /, $look_symbols);	# Keep original spacing info
X	$active =~ s/\s+/\n/g;						# One symbol per line
X
X	# Concatenate quoted strings, so saying something like 'two words' will
X	# be introduced as one single symbol "two words".
X	local(@symbols);				# Concatenated symbols to look for
X	local($concat) = '';			# Concatenation buffer
X	foreach (@syms) {
X		if (s/^\'//) {
X			$concat = $_;
X		} elsif (s/\'$//) {
X			push(@symbols, $concat . ' ' . $_);
X			$concat = '';
X		} else {
X			push(@symbols, $_) unless $concat;
X			$concat .= ' ' . $_ if $concat;
X		}
X	}
X
X	# Now record symbols in master and wanted tables
X	foreach (@symbols) {
X		$cmaster{$_} = undef;					# Asks for look-up in C files
X		$cwanted{$_} = "$active" if $active;	# Shell symbols to activate
X	}
X}
X
X# Process the ?INIT: lines
Xsub p_init {
X	local($_) = @_;
X	print INIT "?$unit:", $_;		# Wanted only if unit is loaded
X}
X
X# Process the ?D: lines
Xsub p_default {
X	local($_) = @_;
X	s/^([A-Za-z_]+)=(.*)/@if !$1\n%$1:$1=$2\n@define $1\n@end/
X		&& ($hasdefault{$1}++, print INIT $_);
X}
X
X# Process the ?L: lines
X# There should not be any '-l' in front of the library name
Xsub p_library {
X	&write_out("L:$_");
X}
X
X# Process the ?I: lines
Xsub p_include {
X	&write_out("I:$_");
X}
X
X# Write out line in file Extern.U. The information recorded there has the
X# following prototypical format:
X#   ?symbol:L:inet bsd
X# If 'symbol' is wanted, then 'inet bsd' will be added to $libswanted.
Xsub write_out {
X	local($_) = @_;
X	local($target) = $defined;		# By default, applies to defined symbols
X	$target = $1 if s/^(.*)://;		# List is qualified "?L:target:symbols"
X	local(@target) = split(' ', $target);
X	chop;
X	foreach $key (@target) {
X		print EXTERN "?$key:$_\n";	# EXTERN file defined in xref.pl
X	}
X}
X
END_OF_FILE
  if test 2576 -ne `wc -c <'mcon/pl/depend.pl'`; then
    echo shar: \"'mcon/pl/depend.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/depend.pl'
fi
if test -f 'pat/patftp.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/patftp.SH'\"
else
  echo shar: Extracting \"'pat/patftp.SH'\" \(2510 characters\)
  sed "s/^X//" >'pat/patftp.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/patftp (with variable substitutions)"
Xcat >patftp <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: patftp.SH,v 3.0 1993/08/18 12:10:44 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Larry Wall <lwall@netlabs.com>
X#
X# $Log: patftp.SH,v $
X# Revision 3.0  1993/08/18  12:10:44  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$orgname='$orgname';
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>patftp <<'!NO!SUBS!'
X
Xchop($orgname = `cat $orgname`) if $orgname =~ m|^/|;
X
Xrequire 'getopts.pl';
X&usage unless &Getopts("hV");
X
Xif ($opt_V) {
X	print STDERR "patftp $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X$RCSEXT = ',v' unless $RCSEXT;
Xchdir '..' if -d '../bugs';
X
X&readpackage;
X
Xif ($#ARGV < 0) {
X	open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X	while (<PL>) {
X		$argv = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X	}
X	close PL;
X	die "Malformed patchlevel.h file.\n" if $argv eq '';
X	@ARGV = $argv;
X} else {
X	for (@ARGV) {
X		s/^patch//;
X	}
X	$argv = &rangeargs(@ARGV);
X	@ARGV = split(' ',$argv);
X}
X
Xif ($#ARGV < 0) {
X	print STDERR  "No patches specified.\n";
X	&usage;
X} elsif ($#ARGV) {
X	print "Copying $package $baserev patches $argv to $ftpdir...\n";
X} else {
X	print "Copying $package $baserev patch $argv to $ftpdir...\n";
X}
X
Xchdir 'bugs' || die "Can't cd to bugs\n";
X
Xuntil ($#ARGV < 0) {
X	$patnum = shift;
X	`cp patch$patnum $ftpdir`;
X}
X
Xsub usage {
X	print STDERR "Usage: patftp [-hV] patchlist\n";
X	print STDERR "  -h : print this message and exit\n";
X	print STDERR "  -V : print version number and exit\n";
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/package.pl >>patftp
X$grep -v '^;#' ../pl/rangeargs.pl >>patftp
Xchmod +x patftp
X$eunicefix patftp
END_OF_FILE
  if test 2510 -ne `wc -c <'pat/patftp.SH'`; then
    echo shar: \"'pat/patftp.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/patftp.SH'
fi
echo shar: End of archive 17 \(of 28\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
