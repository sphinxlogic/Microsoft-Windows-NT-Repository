Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i015:  dist-3.0 - Configure script generator and related tools, Part11/28
Message-ID: <1993Aug19.131133.5278@sparky.sterling.com>
X-Md4-Signature: 263dc5ed5f2493ee7699bc7ab11d41e7
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 19 Aug 1993 13:11:33 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 15
Archive-name: dist-3.0/part11
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Makefile.SH jmake/Makefile.SH jmake/NOTES
#   jmake/files/Jmake.tmpl mcon/U/mkdep.U mcon/U/models.U
#   mcon/pl/locate.pl mcon/pl/tsort.pl pat/README
# Wrapped by ram@soft208 on Wed Aug 18 14:42:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 28)."'
if test -f 'Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SH'\"
else
  echo shar: Extracting \"'Makefile.SH'\" \(5370 characters\)
  sed "s/^X//" >'Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL0]
X: $X-Id: Jmake.tmpl,v 2.8.1.2 91/11/18 13:22:54 ram Exp $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=.
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = .
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ./install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XL = $manext
XMANSRC = $installmansrc
XMAKE = make
XMV = $mv
XRM = $rm -f
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSUBDIRS = bin mcon jmake pat kit lib
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 2.8.1.4 91/11/18 13:19:07 ram Exp $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.8.1.1 91/10/18 10:09:07 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $X-Log:	Jmakefile,v $
X# Revision 2.8.1.1  91/10/18  10:09:07  ram
X# patch7: tried to install a non-existent manual page for packinit
X# patch7: reported by Christian Bertin <bertin@acri.fr>
X#
X# Revision 2.8  91/07/08  13:22:56  ram
X# 3.0 alpha baseline.
X#
X
Xall::
X
Xinstall.man:: dist.man
X	$(INSTALL) -c -m 444 dist.man $(MANSRC)/dist.$(L)
X
Xdeinstall.man::
X	$(RM) $(MANSRC)/dist.$(L)
X
Xlocal_clobber::
X	$(RM) install
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: sub_clean local_clean
Xrealclean: sub_realclean local_realclean
Xclobber: sub_clobber local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X	$(RM) -r UU
X
Xlocal_clobber:: local_realclean
X	$(RM) config.sh config.h
X	$(RM) Makefile
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Rules for building in sub-directories -- do not edit
X
Xsubdirs:
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo $(VERB) "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS) $(FLAGS) $(TARGET)); \
X	done
X
Xinstall::
X	@$(MAKE) subdirs TARGET=install VERB="Installing" FLAGS=
X
Xdeinstall::
X	@$(MAKE) subdirs TARGET=deinstall VERB="Deinstalling" FLAGS=
X
Xinstall.man::
X	@$(MAKE) subdirs TARGET=install.man VERB="Installing man pages" FLAGS=
X
Xdeinstall.man::
X	@$(MAKE) subdirs TARGET=deinstall.man VERB="Deinstalling man pages" FLAGS=
X
Xsub_clean::
X	@$(MAKE) subdirs TARGET=clean VERB="Cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "clean...
X
Xsub_realclean::
X	@$(MAKE) subdirs TARGET=realclean VERB="Real cleaning" FLAGS=
X	@echo "Back to $(CURRENT) for "realclean...
X
Xsub_clobber::
X	@$(MAKE) subdirs TARGET=clobber VERB="Clobbering" FLAGS=
X	@echo "Back to $(CURRENT) for "clobber...
X
Xtag::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X		(cd $$i ; echo "Tagging" "in $(DIR)$$i..."; \
X			$(MAKE) $(MFLAGS)  tag); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		echo "Making "Makefiles" in $(DIR)$$i..."; \
X		(cd $$i || exit 1; \
X		if test ! -f Makefile; then /bin/sh Makefile.SH; fi; \
X		$(MAKE) $(MFLAGS) Makefiles) \
X	done
X
XMakefiles.SH:: Makefile.SH
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS);\
X	do \
X		case "$(DIR)$$i/" in \
X		*/*/*/*/) newtop=../../../..;; \
X		*/*/*/) newtop=../../..;; \
X		*/*/) newtop=../..;; \
X		*/) newtop=..;; \
X		esac; \
X		case "$(TOP)" in \
X		/*) newtop="$(TOP)" ;; \
X		esac; \
X		echo "Making Makefiles.SH in $(DIR)$$i..."; \
X		(cd $$i || exit 1; $(MAKE) $(MFLAGS) -f ../Makefile \
X		Makefile TOP=$$newtop CURRENT=$(DIR)$$i;\
X		$(MAKE) $(MFLAGS) Makefiles.SH) \
X	done
X
Xall::
X	@$(MAKE) subdirs TARGET=all VERB="Making all" FLAGS=
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5370 -ne `wc -c <'Makefile.SH'`; then
    echo shar: \"'Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'Makefile.SH'
fi
if test -f 'jmake/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/Makefile.SH'\"
else
  echo shar: Extracting \"'jmake/Makefile.SH'\" \(5291 characters\)
  sed "s/^X//" >'jmake/Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL0]
X: $X-Id: Jmake.tmpl,v 2.8.1.2 91/11/18 13:22:54 ram Exp $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=jmake
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = ..
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ../install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XL = $manext
XMANSRC = $installmansrc
XMAKE = make
XMV = $mv
XPRIVLIB = $installprivlib
XRM = $rm -f
XSCRIPTDIR = $installscript
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSCRIPTS =  jmake jmkmf
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 2.8.1.4 91/11/18 13:19:07 ram Exp $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.8.1.1 91/07/14 13:34:08 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $X-Log:	Jmakefile,v $
X# Revision 2.8.1.1  91/07/14  13:34:08  ram
X# patch1: bindex was wrongly installed as a public executable
X#
X# Revision 2.8  91/07/08  13:27:23  ram
X# 3.0 alpha baseline.
X#
X
Xall:: Index
X
Xlocal_realclean::
X	$(RM) Index
X
XIndex: bindex
X	chmod +x bindex
X	./bindex
X
Xall:: jmake jmkmf
X
Xlocal_realclean::
X	$(RM) jmake jmkmf
X
Xjmake: jmake.SH
X	/bin/sh jmake.SH
X
Xjmkmf: jmkmf.SH
X	/bin/sh jmkmf.SH
X
X
Xinstall:: $(SCRIPTS) $(LSCRIPTS)
X	@for file in $(SCRIPTS) $(LSCRIPTS); do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(INSTALL) -c -m 555 $$file $(SCRIPTDIR)); \
X	done
X
Xdeinstall::
X	@for file in $(SCRIPTS) $(LSCRIPTS); do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(RM) $(SCRIPTDIR)/$$file); \
X	done
X
Xinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(SCRIPTS); do \
X			(set -x; \
X			$(INSTALL) -c -m 444 $$file.man $(MANSRC)/$$file.$(L)); \
X		done; \
X	else exit 0; fi
X
Xdeinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(SCRIPTS); do \
X			(set -x; $(RM) $(MANSRC)/$$file.$(L)); \
X		done; \
X	else exit 0; fi
X
Xall:: bindex
X
Xlocal_realclean::
X	$(RM) bindex
X
Xbindex: bindex.SH
X	/bin/sh bindex.SH
X
X
Xinstall::
X	@for dir in $(PRIVLIB) $(PRIVLIB)/files; do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(INSTALL) -d $$dir); \
X	done
X
Xdeinstall::
X	$(RM) -r $(PRIVLIB) $(PRIVLIB)/files
X
Xinstall:: Index
X	$(INSTALL) -c -m 444 Index $(PRIVLIB)
X
Xdeinstall::
X	$(RM) $(PRIVLIB)/Index
X
Xinstall:: bindex
X	$(INSTALL) -c -m 555  bindex $(PRIVLIB)
X
Xdeinstall::
X	$(RM) $(PRIVLIB)/bindex
X
Xinstall:: files/Jmake*
X	@case '${MFLAGS}' in *[i]*) set +e;; esac; \
X	for i in files/Jmake*; do \
X		(set -x; $(INSTALL) -c -m 444 $$i $(PRIVLIB)/files); \
X	done
X
Xdeinstall::
X	@case '${MFLAGS}' in *[i]*) set +e;; esac; \
X	for i in files/Jmake*; do \
X		(set -x; $(RM) $(PRIVLIB)/files/$$i); \
X	done
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: local_clean
Xrealclean: local_realclean
Xclobber: local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X
Xlocal_clobber:: local_realclean
X	$(RM) Makefile config.sh
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Empty rules for directories with no sub-directories -- do not edit
X
Xinstall::
X	@echo "install in $(CURRENT) done."
X
Xdeinstall::
X	@echo "deinstall in $(CURRENT) done."
X
Xinstall.man::
X	@echo "install.man in $(CURRENT) done."
X
Xdeinstall.man::
X	@echo "deinstall.man in $(CURRENT) done."
X
XMakefiles::
X
XMakefiles.SH::
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5291 -ne `wc -c <'jmake/Makefile.SH'`; then
    echo shar: \"'jmake/Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'jmake/Makefile.SH'
fi
if test -f 'jmake/NOTES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/NOTES'\"
else
  echo shar: Extracting \"'jmake/NOTES'\" \(5498 characters\)
  sed "s/^X//" >'jmake/NOTES' <<'END_OF_FILE'
XThe syntax in Jmake.rules is not elegant at all, but:
X
X	- It is easy to parse (like sendmail.cf or troff files).
X	- The rules are not supposed to change very often.
X	- It is simple enough to be mastered in five minutes. :-)
X
XHere is a small description:
X
Xo To deal with various cpp implementations:
X
XFinal @!\ means: end of line, next line starts at the left margin.
XFinal @@\ means: end of line, next line is to be indented by one tab.
X
XThe conversion occurs during Pass1.
X
X
Xo Symbol definitions
X
X>SYMBOL: defines the symbol (Pass 1).
X?SYMBOL:<text>: keeps <text> iff SYMBOL is defined (Pass 2).
X%SYMBOL:<text>: keeps <text> iff SYMBOL is not defined (Pass 2).
X
XThe ?SYM can be nested (logical AND), as in:
X
X	?SYMBOL:%TOKEN:text		/* Keeps text if SYMBOL and not TOKEN */
X
XTo implement a logical OR, see below.
X
X
Xo Commands
X
XCommands can be passed to 'jmake'. They start with a leading '|'.
X
XAvailable commands are:
X
X|suffix <sx>: adds <sx> to the .SUFFIXES: list in the makefile (Pass 1 & 2).
X|rule:<text>: adds <text> to the building rule section (Pass 1 & 2).
X|rule: <text>: same as before, with a leading tab.
X|skip: skips text until a line starting with '-skip' is found (Pass 2).
X|expand <pattern>: expand lines until '-expand' with <pattern> (Pass 2).
X|once <symbol>: text up to '-once' appears only the first time (Pass 1).
X
XThus, a way to implement a logical OR could be:
X
X	/* Implements SYMBOL or not TOKEN */
X	?SYMBOL:text			/* Keeps text if SYMBOL */
X	%SYMBOL:|skip
X		%TOKEN:text			/* Keeps text if not TOKEN */
X	-skip
X
XActually, this is ugly, because the text has to appear twice.
XFortunately, I did not use it. :-)
X
XThe '|' commands cannot be nested. In particular, due to the simple
Ximplementation of '|skip', it is impossible to put '|skip' inside
Xa skipped part. However, a '|once' section may have '|skip' sections.
X
XBut actually, as you have surely already guessed, the best way to
Ximplement a logical OR is to use De Morgan's Law:
X
X	not (p or q) <=> not p and not q
X
X	/* Implements SYMBOL or not TOKEN (attempt #2) */
X	%SYMBOL:?TOKEN:|skip
X	text					/* If SYMBOL or not TOKEN */
X	-skip
X
XWho said they don't care ? ;-)
X
Xo Expansion
X
XExpansion is done with the 'expand' command.  It has been provided to
Xavoid some cumbersome writings in makefiles when you have to repeat some
Xsilly lines that only differ in file names, for instance.  Let's look at
Xan example first:
X
X	|expand a!foo bar! b!yes no!
X	!a::
X		echo !a, !b
X	-expand
X
XThen two rules will be printed, and the values of (a,b) for the first
Xwill be (foo, yes), for the second (bar, no).  Substitution is controled
Xby the '!' character.  If the word to be substituted is part of another
Xone, detach with the ^^ construct as in:  !b^^c.  It is possible to
Xuse Makefile macros in the <pattern>, and they will be expanded by
Xjmake.  If this is not what you want, escape the first '$' sign (this is
Xa Makefile escape, i.e. you must double the '$', not precede it with a
Xbackslash). A // stands for the null substitution value.
X
XHere is another example which shows how the macro Expand can be used.
XIt is defined in Jmake.rules as:
X
X	#define Expand(rule, pattern) @!\
X	|expand pattern @!\
X	rule @!\
X	-expand
X
XSo we can write in the Jmakefile:
X
X	|skip
X	A = foo bar
X	-skip
X
X	#define Rule @!\
X	$(DIR)/!a^^.o: !a^^.o @@\
X		$(CC) -c !a^^.c @@\
X		$(MV) !a^^.o $(DIR)
X	
X	Expand(Rule, a!$(A)!)
X
Xwhich will generate in Makefile.SH:
X
X	$(DIR)/foo.o: foo.o
X		$(CC) -c foo.c
X		$(MV) foo.o $(DIR)
X
X	$(DIR)/bar.o: bar.o
X		$(CC) -c bar.c
X		$(MV) bar.o $$(DIR)
X
XThe 'A' declaration has been surrounded by skip, so that it does
Xnot appear in the generated Makefile.SH, but it will be taken into
Xaccount by jmake for the substitution in the pattern.
X
XThe number of expansions is determined by the number of possible
Xvalues for the _first_ parameter. If other parameters have less
Xsubstitution values, they will get void ones.
X
XIt is possible to add a regular expression at the end of '-expand'.
XThis regular expression will be removed from the final set of expansion
Xat the end of each line.  It is also possible to do substitutions in the
Xexpanded item, by using the syntax (if 'f' is the expanded variable)
X!f:<p>=<q> where <p> and <q> are two regular expressions (without
Xspaces).  The pattern <p> will be replaced by pattern <q> (only the
Xfirst occurrence will be replaced).
X
XFinally, you may refer in the expanded section to variables whose value
Xis computed via another expansion, which makes it easy to define generic
XJmakefiles.
X
XExample:
X
X	SRC = foo.c bar.c
X	OBJ = \
X	|expand f!$(SRC)!
X		!f:\.c=\.o \
X	-expand \\
X	INC = \
X	|expand f!$(OBJ)!
X		!f:\.o=\.h \
X	-expand \\
X
Xwhich will generate in Makefile.SH:
X
X	SRC = foo.c bar.c
X	OBJ = \
X		foo.o \
X		bar.o
X	INC = \
X		foo.h \
X		bar.h
X
XDo not forget to protect special characters in your regular expressions such
Xas backslash, point, etc...
X
Xo Once
X
XThe once command is tagged with a name. The first time the name appears,
Xthe once construct is ignored and the text up to '-once' will be copied
Xin the generated Makefile.SH.  However, future occurences of the same
Xname will be ignored (once will behave like skip).
X
XExample:
X
X	|once this_is_a_name
X	<text>
X	-once
X
Xo Initializations
X
X+<line>: Puts the whole line in the initialization section (Pass 1 & 2).
X++SYMBOL <value>: Adds <value> to the SYMBOL macro (Pass 1 and 2).
X
Xo User-defined variables
X
XCFLAGS: added flags to C compiler
XDPFLAGS: cpp flags to be added to mkdep for dependency
XLDFLAGS: flags/libraries to be added at linking stage
END_OF_FILE
  if test 5498 -ne `wc -c <'jmake/NOTES'`; then
    echo shar: \"'jmake/NOTES'\" unpacked with wrong size!
  fi
  # end of 'jmake/NOTES'
fi
if test -f 'jmake/files/Jmake.tmpl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/files/Jmake.tmpl'\"
else
  echo shar: Extracting \"'jmake/files/Jmake.tmpl'\" \(5613 characters\)
  sed "s/^X//" >'jmake/files/Jmake.tmpl' <<'END_OF_FILE'
X/*
X * Generic jmake template
X *
X * $Id: Jmake.tmpl,v 3.0 1993/08/18 12:04:16 ram Exp $
X *
X *  Copyright (c) 1991-1993, Raphael Manfredi
X *  
X *  You may redistribute only under the terms of the Artistic Licence,
X *  as specified in the README file that comes with the distribution.
X *  You may reuse parts of this distribution only within the terms of
X *  that same Artistic Licence; a copy of which may be found at the root
X *  of the source tree for dist 3.0.
X *
X * $Log: Jmake.tmpl,v $
X * Revision 3.0  1993/08/18  12:04:16  ram
X * Baseline for dist 3.0 netwide release.
X *
X */
X
X: Makefile.SH generated from Jmake.tmpl and Jmakefile <TAG>
X: $Id: Jmake.tmpl,v 3.0 1993/08/18 12:04:16 ram Exp $
X
X/*************************************************************************
X *                                                                       *
X *                     DO NOT MODIFY BELOW THIS LINE                     *
X *                                                                       *
X *************************************************************************/
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/#*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
X|expand cur!CURDIR!
XCURRENT=!cur:^\./=
X-expand
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X;########################################################################
X;# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = TOPDIR
XCURRENT = $CURRENT
XDIR = $DIR
X?INSTALL:INSTALL = TOPDIR/install
X
X;########################################################################
X;# Parameters set by Configure -- edit config.sh if changes are needed
X
X?AR:AR = ar rc				/* FIXME */
X?BINDIR:BINDIR = $installbin
X?CC:CC = $cc
X?CP:CP = $cp
X?CPP:CPP = $cpp $cppminus $cppflags
X?CTAGS:CTAGS = ctags		/* FIXME */
X?JCFLAGS:JCFLAGS = \$(CFLAGS) $optimize $ccflags $large
X?JLDFLAGS:JLDFLAGS = \$(LDFLAGS) $optimize $ldflags
X?JLFLAGS:JLFLAGS = \$(LFLAGS)
X?JYFLAGS:JYFLAGS = \$(YFLAGS) $yaccflags
X?L:L = $manext
X?LD:LD = ld
X?LEX:LEX = lex
X?LIBS:LIBS = $libs
X?LINT:LINT = lint
X?LN:LN = $ln
X?MANSRC:MANSRC = $installmansrc
X?MAKE:MAKE = make				/* Otherwise $(MAKE) doesn't work on SONY */
X?MKDEP:MKDEP = $mkdep \$(DPFLAGS) --
X?MV:MV = $mv
X?PRIVLIB:PRIVLIB = $installprivlib
X?RANLIB:RANLIB = $ranlib
X?RM:RM = $rm -f
X?SCRIPTDIR:SCRIPTDIR = $installscript
X?SED:SED = $sed
X?YACC:YACC = $yacc
X
X/*
X * The following will only be added if at least one initialization
X * rule was found in the Jmakefile.
X */
X%INIT:|skip			/* Skip if no initializations are necessary */
X;########################################################################
X;# Automatically generated parameters -- do not edit
X
XINIT_SECTION
X
X-skip				/* Initializations */
X%SUFFIX:|skip		/* Skip if no suffixes/rules are defined */
X;########################################################################
X;# New suffixes and associated building rules -- edit with care
X
XSUFFIX_SECTION
X-skip				/* Suffixes/Rules */
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X#include <Jmake.rules>
X
X%MKDEP:|skip		/* Skip if no depend target */
X;########################################################################
X;# Force 'make depend' to be performed first -- do not edit
X
X.FORCE_DEPEND::
X
Xall:: .FORCE_DEPEND
X
X-skip				/* Depend target */
X;########################################################################
X;# Start of Jmakefile
X#include <Jmakefile>
X
X;########################################################################
X;# Common rules for all Makefiles -- do not edit
X/*
X * These need to be here so that rules in Jmakefile occur first;  the blank
X * all is to make sure that an empty Jmakefile doesn't default to make clean.
X */
Xemptyrule::
X
XCleanTarget()
XMakefileTarget()
XTagsTarget()
X
X%SUBDIRS:|skip		/* Skip if no sub-directories */
X;########################################################################
X;# Rules for building in sub-directories -- do not edit
X
XCommonSubdirsRule($(SUBDIRS))
XInstallSubdirs()
XInstallManSubdirs()
XCleanSubdirs()
XTagSubdirs($(SUBDIRS))
XMakefileSubdirs()
XMakeSubdirs()
X
X-skip				/* Sub-directories */
X?SUBDIRS:|skip		/* Skip if sub-directories */
X;########################################################################
X;# Empty rules for directories with no sub-directories -- do not edit
X
Xinstall::
X	@echo "install in $(CURRENT) done."
X
Xdeinstall::
X	@echo "deinstall in $(CURRENT) done."
X
Xinstall.man::
X	@echo "install.man in $(CURRENT) done."
X
Xdeinstall.man::
X	@echo "deinstall.man in $(CURRENT) done."
X
X/*
X * Action for 'Makefiles' would be required, if a .SUFFIXES: .SH rule
X * were added, because in that case, a "/bin/sh Makefiles.SH" would
X * be issued and raise an error.
X */
XMakefiles::
X
XMakefiles.SH::
X
X-skip				/* No sub-directories */
X%MKDEP:|skip		/* Skip if no depend target */
X;########################################################################
X;# Dependencies generated by make depend
X;# DO NOT DELETE THIS LINE -- make depend relies on it
X
X;# Put nothing here or make depend will gobble it up
X.FORCE_DEPEND::
X?TOP: @echo "You haven't run a 'make depend' yet!"; exit 1
X%TOP: @echo "You must run 'make depend' in $(TOP) first."; exit 1
X-skip				/* Depend target */
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 5613 -ne `wc -c <'jmake/files/Jmake.tmpl'`; then
    echo shar: \"'jmake/files/Jmake.tmpl'\" unpacked with wrong size!
  fi
  # end of 'jmake/files/Jmake.tmpl'
fi
if test -f 'mcon/U/mkdep.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/mkdep.U'\"
else
  echo shar: Extracting \"'mcon/U/mkdep.U'\" \(5399 characters\)
  sed "s/^X//" >'mcon/U/mkdep.U' <<'END_OF_FILE'
X?RCS: $Id: mkdep.U,v 3.0 1993/08/18 12:09:16 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: mkdep.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:16  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit generates the script 'mkdep' in the top-level directory.
X?X:	It is up to the makefile to use it for automatic dependencies
X?X: generation (usage: 'mkdep [cppflags] -- *.c').
X?X:
X?MAKE:mkdep: spitshell startsh cpp cppflags grep contains rm sed sort uniq \
X	Getfile Oldconfig eunicefix cat +cc cppminus test
X?MAKE:	-pick add $@ %<
X?S:mkdep:
X?S:	This variable holds the name of a command to generate makefile
X?S:	dependencies on the standard output. It is the pathname of the
X?S:	generated mkdep script.
X?S:.
X?T:IFS arg flags takeflags srcfile toplev filebase inc dir files file dep c
X: find out how to generate dependencies
Xecho " "
Xecho "Checking how to generate makefile dependencies on your machine..." >&4
X?X: We are in the UU directory
Xtoplev=`cd ..;pwd`
X$cat >dep.c <<'EOCP'
X#include "dep.h"
XEOCP
X?X: Empty dep.h causes RIOS to barf
X$cat >dep.h <<'EOCP'
X
XEOCP
Xtakeflags='flags=""
Xcase "$@" in
X*--*)
X	for arg
X	do
X		shift
X		case "$arg" in
X		--) break;;
X		*) flags="$flags $arg";;
X		esac
X	done;;
Xesac'
Xcase "$mkdep" in
X'')
X	;;
X*)
X	if test -x "$mkdep" &&
X		$mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "$mkdep works."
X	else
X		mkdep=
X	fi
Xesac
X
Xcase "$mkdep" in
X'')
X?X: have to figure something out: Try cpp
X?X: have to pass source names one by one to cpp...
X	$spitshell > ../mkdep <<EOM
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	$cpp -M -I. $cppflags \$flags \$srcfile 2>/dev/null
Xdone
XEOM
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "Looks like we can use $cpp -M."
X	else
X		mkdep=
X	fi
X	;;
Xesac
X
Xcase "$mkdep" in
X'')
X?X: have to figure something out: on NeXT, use cc -MM
X?X: have to pass source names one by one to cc...
X	$spitshell > ../mkdep <<EOM
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	$cc -MM -I. $cppflags \$flags \$srcfile 2>/dev/null
Xdone
XEOM
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep.o: dep.h' dep.out >/dev/null 2>&1
X	then
X		echo "Looks like we can use $cc -MM."
X	else
X		mkdep=
X	fi
X	;;
Xesac
X
Xcase "$mkdep" in
X'')
X?X: still no luck -- try something fancier.
X	$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	<\$srcfile $cpp $cppminus $cppflags -I. \$flags 2>/dev/null | \\
X	$sed -e '/^# *[0-9]/!d' \\
X		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X		-e 's|: \./|: |' \\
X		-e 's|: *$|: '\$srcfile'|' | \\
X	$grep -v '^#' | $sort | $uniq
Xdone
XEOS
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "A shell script using $cpp does the trick."
X	else
X		echo "$cpp doesn't seem to be any use at all."
X		$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfiles="\$@"
Xset X \$flags
Xshift
Xinc='.'
Xwhile test \$# -gt 0
Xdo
X	case "\$1" in
X	-I) 
X		shift
X		inc="\$inc:\$1"
X		;;
X	-I*)
X		dir=\`echo \$1 | sed -e 's/^-I//'\`
X		inc="\$inc:\$dir"
X		;;
X	esac
X	shift
Xdone
Xset X \$files
Xshift
Xtrap "$rm -f /tmp/mkdep\$\$; exit 1" 1 2 3 15
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	echo \$filebase.o: \$srcfile
X	$grep '^#[  ]*include' \$srcfile /dev/null | \
X	$sed -n -e 's/#[   ]*include[  ]*//' \\
X		-e '/<\(.*\)>/ d' \\
X		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
X		-e 's/\.c:/\.o:/p' > /tmp/mkdep\$\$
X?X: Deal with directories specified via -I requests to locate files
X	IFS=': '
X	while read file dep; do
X		for dir in \$inc; do
X			if $test -f "\$dir/\$dep"; then
X				dep="\$dir/\$dep"
X				break
X			fi
X		done
X		echo "\$file: \$dep" | $sed -e 's,: \./,: ,'
X	done </tmp/mkdep\$\$
X	IFS=' '
X	$rm -f /tmp/mkdep\$\$
Xdone
XEOS
X		mkdep=$toplev/mkdep
X		chmod +x $mkdep
X		$eunicefix $mkdep
X		if $mkdep dep.c >dep.out 2>/dev/null &&
X			$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X		then
X			cat << EOM
X
XI can use a script with grep instead, but it will make some incorrect
Xdependencies, since it doesn't understand about conditional compilation.
XMoreover, some dependencies may be missing, because scanning won't be
Xa recursive process.
XIf you have a program which generates makefile dependencies, you may want
Xto use it.  If not, you can use the script and edit the Makefile by hand
Xif you need to.
XEOM
X		else
X			mkdep=
X			cat << EOM
X
XI can't seem to generate makefile dependencies at all!  Perhaps you have a
Xprogram that does?  If you don't, you might look at the mkdep script to
Xsee if you can create one which works.
XEOM
X		fi
X	fi
Xesac
Xdflt="$mkdep"
Xfn=f~/
Xrp="Name of program to make makefile dependencies?"
X. ./getfile
Xmkdep="$ans"
X$rm -f dep.c dep.h dep.o dep.out
X
END_OF_FILE
  if test 5399 -ne `wc -c <'mcon/U/mkdep.U'`; then
    echo shar: \"'mcon/U/mkdep.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/mkdep.U'
fi
if test -f 'mcon/U/models.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/models.U'\"
else
  echo shar: Extracting \"'mcon/U/models.U'\" \(5256 characters\)
  sed "s/^X//" >'mcon/U/models.U' <<'END_OF_FILE'
X?RCS: $Id: models.U,v 3.0 1993/08/18 12:09:17 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: models.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:17  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:models split small medium large huge: test cat Myread sysman Oldconfig \
X	Loc contains
X?MAKE:	-pick add $@ %<
X?S:models:
X?S:	This variable contains the list of memory models supported by this
X?S:	system.  Possible component values are none, split, unsplit, small,
X?S:	medium, large, and huge.  The component values are space separated.
X?S:.
X?S:split:
X?S:	This variable contains a flag which will tell the C compiler and loader
X?S:	to produce a program that will run in separate I and D space, for those
X?S:	machines that support separation of instruction and data space.  It is
X?S:	up to the Makefile to use this.
X?S:.
X?S:small:
X?S:	This variable contains a flag which will tell the C compiler and loader
X?S:	to produce a program running with a small memory model.  It is up to
X?S:	the Makefile to use this.
X?S:.
X?S:medium:
X?S:	This variable contains a flag which will tell the C compiler and loader
X?S:	to produce a program running with a medium memory model.  If the
X?S:	medium model is not supported, contains the flag to produce large
X?S:	model programs.  It is up to the Makefile to use this.
X?S:.
X?S:large:
X?S:	This variable contains a flag which will tell the C compiler and loader
X?S:	to produce a program running with a large memory model.  It is up to
X?S:	the Makefile to use this.
X?S:.
X?S:huge:
X?S:	This variable contains a flag which will tell the C compiler and loader
X?S:	to produce a program running with a huge memory model.  If the
X?S:	huge model is not supported, contains the flag to produce large
X?S:	model programs.  It is up to the Makefile to use this.
X?S:.
X?T:unsplit tans
X: see what memory models we can support
Xcase "$models" in
X'')
X?X: We may not use Cppsym or we get a circular dependency through cc.
X?X: But this should work regardless of which cc we eventually use.
X	$cat >pdp11.c <<'EOP'
Xmain() {
X#ifdef pdp11
X	exit(0);
X#else
X	exit(1);
X#endif
X}
XEOP
X	cc -o pdp11 pdp11.c >/dev/null 2>&1
X	if ./pdp11 2>/dev/null; then
X		dflt='unsplit split'
X	else
X		tans=`./loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
X		case "$tans" in
X		X) dflt='none';;
X		*) if $test -d /lib/small || $test -d /usr/lib/small; then
X				dflt='small'
X			else
X				dflt=''
X			fi
X			if $test -d /lib/medium || $test -d /usr/lib/medium; then
X				dflt="$dflt medium"
X			fi
X			if $test -d /lib/large || $test -d /usr/lib/large; then
X				dflt="$dflt large"
X			fi
X			if $test -d /lib/huge || $test -d /usr/lib/huge; then
X				dflt="$dflt huge"
X			fi
X		esac
X	fi;;
X*) dflt="$models";;
Xesac
X$cat <<EOM
X 
XSome systems have different model sizes.  On most systems they are called
Xsmall, medium, large, and huge.  On the PDP11 they are called unsplit and
Xsplit.  If your system doesn't support different memory models, say "none".
XIf you wish to force everything to one memory model, say "none" here and
Xput the appropriate flags later when it asks you for other cc and ld flags.
XVenix systems may wish to put "none" and let the compiler figure things out.
X(In the following question multiple model names should be space separated.)
X
XEOM
Xrp="Which memory models are supported?"
X. ./myread
Xmodels="$ans"
X
Xcase "$models" in
Xnone)
X	small=''
X	medium=''
X	large=''
X	huge=''
X	unsplit=''
X	split=''
X	;;
X*split)
X	case "$split" in
X	'') if $contains '\-i' $sysman/ld.1 >/dev/null 2>&1 || \
X			 $contains '\-i' $sysman/cc.1 >/dev/null 2>&1; then
X			dflt='-i'
X		else
X			dflt='none'
X		fi;;
X	*) dflt="$split";;
X	esac
X	rp="What flag indicates separate I and D space?"
X	. ./myread
X	tans="$ans"
X	case "$tans" in
X	none) tans='';;
X	esac
X	split="$tans"
X	unsplit='';;
X*large*|*small*|*medium*|*huge*)
X	case "$models" in
X	*large*)
X		case "$large" in
X		'') dflt='-Ml';;
X		*) dflt="$large";;
X		esac
X	rp="What flag indicates large model?"
X	. ./myread
X	tans="$ans"
X	case "$tans" in
X	none) tans='';
X	esac
X	large="$tans";;
X	*) large='';;
X	esac
X	case "$models" in
X	*huge*) case "$huge" in
X		'') dflt='-Mh';;
X		*) dflt="$huge";;
X		esac
X		rp="What flag indicates huge model?"
X		. ./myread
X		tans="$ans"
X		case "$tans" in
X		none) tans='';
X		esac
X		huge="$tans";;
X	*) huge="$large";;
X	esac
X	case "$models" in
X	*medium*) case "$medium" in
X		'') dflt='-Mm';;
X		*) dflt="$medium";;
X		esac
X		rp="What flag indicates medium model?"
X		. ./myread
X		tans="$ans"
X		case "$tans" in
X		none) tans='';
X		esac
X		medium="$tans";;
X	*) medium="$large";;
X	esac
X	case "$models" in
X	*small*) case "$small" in
X		'') dflt='none';;
X		*) dflt="$small";;
X		esac
X		rp="What flag indicates small model?"
X		. ./myread
X		tans="$ans"
X		case "$tans" in
X		none) tans='';
X		esac
X		small="$tans";;
X	*) small='';;
X	esac
X	;;
X*)
X	echo "Unrecognized memory models--you may have to edit Makefile.SH" >&4
X	;;
Xesac
X
END_OF_FILE
  if test 5256 -ne `wc -c <'mcon/U/models.U'`; then
    echo shar: \"'mcon/U/models.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/models.U'
fi
if test -f 'mcon/pl/locate.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/locate.pl'\"
else
  echo shar: Extracting \"'mcon/pl/locate.pl'\" \(5796 characters\)
  sed "s/^X//" >'mcon/pl/locate.pl' <<'END_OF_FILE'
X;# $Id: locate.pl,v 3.0 1993/08/18 12:10:25 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: locate.pl,v $
X;# Revision 3.0  1993/08/18  12:10:25  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# 
X;# Locate units and put them in the @ARGV array, for later perusal. We first
X;# look in the private U directory, then in the public U library. In each U
X;# directory, units may be gathered in clusters (directories). These clusters
X;# should not have a name ending with .U, as those will never be stat()'ed.
X;#
X;# NB: Currently, the clusters are only a practical way of grouping a set of
X;# closely related units. There must not be any name conflicts.
X;#
X;# The following variables are used:
X;#  $WD is assumed to be the working directory (where the process was spawned)
X;#  $MC is the location of metaconfig's public library
X;#  @ARGV is the list of all the units full path
X;#  %Unit maps an unit name (without final .U) to a path
X;#  @myUlist lists the user's units, which will be appended at the end of @ARGV
X;#  %myUseen lists the user's units which overwrite public ones
X;#
Xpackage locate;
X
X# Locate the units and push their path in @ARGV (sorted alphabetically)
Xsub main'locate_units {
X	print "Locating units...\n" unless $main'opt_s;
X	local(*WD) = *main'WD;			# Current working directory
X	local(*MC) = *main'MC;			# Public metaconfig library
X	undef %myUlist;					# Records private units paths
X	undef %myUseen;					# Records private/public conflicts
X	&private_units;					# Locate private units in @myUlist
X	&public_units;					# Locate public units in @ARGV
X	@ARGV = sort @ARGV;				# Sort it alphabetically
X	push(@ARGV, sort @myUlist);		# Append user's units sorted
X	&dump_list if $main'opt_v;		# Dump the list of units
X}
X
X# Dump the list of units on stdout
Xsub dump_list {
X	print "\t";
X	$, = "\n\t";
X	print @ARGV;
X	$, = '';
X	print "\n";
X}
X
X# Scan private units
Xsub private_units {
X	return unless -d 'U';			# Nothing to be done if no 'U' entry
X	local(*ARGV) = *myUlist;		# Really fill in @myUlist
X	local($MC) = $WD;				# We are really in the working directory
X	&units_path("U");				# Locate units in the U directory
X	local($unit_name);				# Unit's name (without .U)
X	local(@kept);					# Array of kept units
X	# Loop over the units and remove duplicates (the first one seen is the one
X	# we keep). Also set the %myUseen H table to record private units seen.
X	foreach (@ARGV) {
X		($unit_name) = m|^.*/(.*)\.U$|;	# Get unit's name from path
X		next if $myUseen{$unit_name};	# Already recorded
X		$myUseen{$unit_name} = 1;		# Record pirvate unit
X		push(@kept, $_);				# Keep this unit
X	}
X	@ARGV = @kept;
X}
X
X# Scan public units
Xsub public_units {
X	chdir($MC) || die "Can't find directory $MC.\n";
X	&units_path("U");				# Locate units in public U directory
X	chdir($WD) || die "Can't go back to directory $WD.\n";
X	local($path);					# Relative path from $WD
X	local($unit_name);				# Unit's name (without .U)
X	local(*Unit) = *main'Unit;		# Unit is a global from main package
X	local(@kept);					# Units kept
X	local(%warned);					# Units which have already issued a message
X	# Loop over all the units and keep only the ones that were not found in
X	# the user's U directory. As it is possible two or more units with the same
X	# name be found in
X	foreach (@ARGV) {
X		($unit_name) = m|^.*/(.*)\.U$|;	# Get unit's name from path
X		next if $warned{$unit_name};	# We have already seen this unit
X		$warned{$unit_name} = 1;		# Remember we have warned the user
X		if ($myUseen{$unit_name}) {		# User already has a private unit
X			$path = $Unit{$unit_name};	# Extract user's unit path
X			next if $path eq $_;		# Same path, we must be in mcon/
X			$path =~ s|^$WD/||o;		# Weed out leading working dir path
X			print "    Your private $path overrides the public one.\n"
X				unless $main'opt_s;
X		} else {
X			push(@kept, $_);			# We may keep this one
X		}
X	}
X	@ARGV = @kept;
X}
X
X# Recursively locate units in the directory. Each file ending with .U has to be
X# a unit. Others are stat()'ed, and if they are a directory, they are also
X# scanned through. The $MC and @ARGV variable are dynamically set by the caller.
Xsub units_path {
X	local($dir) = @_;					# Directory where units are to be found
X	local(@contents);					# Contents of the directory
X	local($unit_name);					# Unit's name, without final .U
X	local($path);						# Full path of a unit
X	local(*Unit) = *main'Unit;			# Unit is a global from main package
X	unless (opendir(DIR, $dir)) {
X		warn("Cannot open directory $dir.\n");
X		return;
X	}
X	print "Locating in $MC/$dir...\n" if $main'opt_v;
X	@contents = readdir DIR;			# Slurp the whole thing
X	close DIR;							# And close dir, ready for recursion
X	foreach (@contents) {
X		next if $_ eq '.' || $_ eq '..';
X		if (/\.U$/) {					# A unit, definitely
X			($unit_name) = /^(.*)\.U$/;
X			$path = "$MC/$dir/$_";				# Full path of unit
X			push(@ARGV, $path);					# Record its path
X			if (defined $Unit{$unit_name}) {	# Already seen this unit
X				if ($main'opt_v) {
X					($path) = $Unit{$unit_name} =~ m|^(.*)/.*|;
X					print "    We've already seen $unit_name.U in $path.\n";
X				}
X			} else {
X				$Unit{$unit_name} = $path;		# Map name to path
X			}
X			next;
X		}
X		# We have found a file which does not look like a unit. If it is a
X		# directory, then scan it. Otherwise skip the file.
X		unless (-d "$dir/$_") {
X			print "    Skipping file $_ in $dir.\n" if $main'opt_v;
X			next;
X		}
X		&units_path("$dir/$_");
X		print "Back to $MC/$dir...\n" if $main'opt_v;
X	}
X}
X
Xpackage main;
X
END_OF_FILE
  if test 5796 -ne `wc -c <'mcon/pl/locate.pl'`; then
    echo shar: \"'mcon/pl/locate.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/locate.pl'
fi
if test -f 'mcon/pl/tsort.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/tsort.pl'\"
else
  echo shar: Extracting \"'mcon/pl/tsort.pl'\" \(5789 characters\)
  sed "s/^X//" >'mcon/pl/tsort.pl' <<'END_OF_FILE'
X;# $Id: tsort.pl,v 3.0 1993/08/18 12:10:28 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: tsort.pl,v $
X;# Revision 3.0  1993/08/18  12:10:28  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# 
X;# The topological sort is performed using the following algorithm:
X;#
X;# We have a list of successors for each item; makefile dependencies of
X;# the form 'a b: c d' means successors(a) = successors(b) = { c, d }.
X;# From that input, we derive a number of precursors for each item.
X;# In our simple example above, c and d both have two precursors and
X;# a and b have none. Items with no precursors are called outsiders
X;# and are left in a pool. The sort is then initiated and will continue
X;# until all the items have been sorted or a cycle is found...
X;#
X;# Outsiders are ready to be sorted; since the topological sort is a partial
X;# order, an external criterion is needed to choose one item among the ones
X;# in the pool. That item is assigned a number, and the number of precursors
X;# for the remaining items is updated (by following the successors of the
X;# sorted item and decrementing the value for each successor). Among those,
X;# if any item reaches a precursor count of zero, it becomes an outsider.
X;#
X;# The algorithm ends when the outsider pool is empty. If it becomes empty and
X;# some items remain unsorted, then there is one or more cycles among them.
X;# One way to outline that cycle first extract all those items whose precursor
X;# count is minimal then visit their dependency graph to find the cycle,
X;# extract only those items belonging to the cycle into the outsiders set and
X;# resume the main processing stream.
X;#
X#
X# Topological sort of Makefile dependencies with cycle enhancing.
X#
X
Xpackage tsort;
X
X# Perform the topological sort of the items and outline cycles.
Xsub main'tsort {
X	local(*Succ, *Prec) = @_;	# Tables of succesors and predecessors
X	local(@Out);				# The outsider set
X	local(@keys);				# Current active precursors
X	local($item);				# Item to sort
X
X	for (@keys = keys %Prec; @keys || @Out; @keys = keys %Prec) {
X		&resync;			# Resynchronize outsiders
X		if (@Out == 0) {	# Cycle detected
X			&extract_cycle(*Prec, *Succ);
X			next;
X		}
X		$item = shift(@Out);	# Sort current item (don't care which one)
X		&sort($item);		# Update internal structures
X	}
X}
X
X# Resynchronize the outsiders stack (those items that have no more precursors).
X# If the outsiders stack becomes empty, then there is a cycle.
Xsub resync {
X	foreach $target (keys %Prec) {
X		if ($Prec{$target} == 0) {
X			delete $Prec{$target};		# We're done with this item
X			push(@Out, $target);		# Ready to be sorted
X		}
X	}
X}
X
X# Sort item
Xsub sort {
X	local($item) = @_;
X	print "(ok) $item\n" if $main'opt_d && !$Cycle;
X	print "(fx) $item\n" if $main'opt_d && $Cycle;
X	foreach $succ (split(' ', $Succ{$item})) {
X		# The test for definedness is necessary, since when a cycle is found,
X		# one item is forced out of %Prec. If we had the guarantee of no
X		# cycle, the the test would not be necessary and no decrementation
X		# could go past 0.
X		$Prec{$succ}-- if defined $Prec{$succ};
X	}
X}
X
X# Extract cycle... We look through the %Prec array and find all those items
X# with the same lowest value. Those are a cycle, so we dump them, and make
X# them new outsiders by resetting their count to 0.
Xsub extract_cycle {
X	local(*Prec, *Succ) = @_;
X	local($item) = (&sort_by_value(*Prec))[0];
X	local($min) = $Prec{$item};			# Minimum value
X	local($key, $value);
X	local(%candidate);	# Superset of the cycle we found
X	warn "    Cycle found for:\n";
X	$Cycle++;
X	while (($key, $value) = each %Prec) {
X		$candidate{$key}++ if $value == $min;
X	}
X	local(%state);		# State of visited nodes (1 = cycle, -1 = dead)
X	local($CYCLE) = 1;	# Possible member of a cycle
X	local($DEAD) = -1;	# Dead end, no cycling possible
X	foreach $key (keys %candidate) {
X		last if $CYCLE == &visit($key, $Succ{$key});
X	}
X	while (($key, $value) = each %candidate) {
X		next unless $state{$key} == $CYCLE;
X		$Prec{$key} = 0;			# Members of cycle are new outsiders
X		warn "\t(#$Cycle) $key\n";
X	}
X	local(%involved);	 # Items involved in the cycle...
X	while (($key, $value) = each %state) {
X		$involved{$key}++ if $state{$key} == $CYCLE;
X	}
X	&outline_cycle(*Succ, *involved);
X}
X
Xsub outline_cycle {
X	local(*Succ, *member) = @_;
X	local($key, $value);
X	local($depends);
X	local($unit);
X	warn "    Cycle involves:\n";
X	while (($key, $value) = each %Succ) {
X		next unless $member{$key};
X		$depends = '';
X		foreach $item (split(' ', $value)) {
X			$depends .= "$item " if $member{$item};
X		}
X		$unit = $main'shmaster{"\$$key"};
X		$unit =~ s/\s+$//;
X		$unit = '?' if $unit eq '';
X		warn "\t($unit) $key: $depends\n";
X	}
X}
X
X# Visit a tree node, following all its successors, until we find a cycle.
X# Return $CYCLE if the exploration of the node leaded to a cycle, $DEAD
X# otherwise.
Xsub visit {
X	local($node, $children) = @_;	# A node and its children
X	# If we have already visited the node, return the status value attached
X	# to it.
X	return $state{$node} if $state{$node};
X	$state{$node} = $CYCLE;			# Assume member of cycle
X	local($all_dead) = 1;			# Set to 0 if at least one cycle found
X	foreach $child (split(' ', $children)) {
X		$all_dead = 0 if $CYCLE == &visit($child, $Succ{$child});
X	}
X	$state{$node} = $DEAD if $all_dead;
X	$state{$node};
X}
X
X# Sort associative array by value
Xsub sort_by_value {
X	local(*x) = @_;
X	sub _by_value { $x{$a} <=> $x{$b}; }
X	sort _by_value keys %x;
X}
X
Xpackage main;
X
X1;
END_OF_FILE
  if test 5789 -ne `wc -c <'mcon/pl/tsort.pl'`; then
    echo shar: \"'mcon/pl/tsort.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/tsort.pl'
fi
if test -f 'pat/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/README'\"
else
  echo shar: Extracting \"'pat/README'\" \(5099 characters\)
  sed "s/^X//" >'pat/README' <<'END_OF_FILE'
XThis is the root directory for pat tools.
X
XThis directory contains an automatic patch generator.  You must have RCS
Xto use this.  You must also have run packinit in the top level directory
Xof your package to create a .package file.
X
XWhen you've modified a file in your package, the pat program is used to
Xcontrol the whole process.  The other programs can be called by hand, but
Xusually needn't be.  Run pat from the top level directory of your package.
X
XThe pat, patcil, patdiff, and patbase programs take a list of filenames as
Xarguments.  Alternately, a -a means all files listed in MANIFEST.
X
XPatcil will create an RCS directory if necessary.  However, it may not check in
Xthings which require special initializaton properly.  For example, if you
Xwant to check in a shell script, you'd better make your RCS directory yourself
Xand then say
X
X	rcs -i -c'# ' blurfl.xsh
X
Xbefore running pat or patcil.  Otherwise the RCS log may not be commented
Xproperly.  Unless of course you are using a standard extension (like .c for
Xa C file) or have placed the proper comments in front of the $Log marker
Xwithin the file itself--patcil will then correctly guess the type of
Xcomment required.
X
XPatdiff will create a bugs directory in your top level directory, and will want
Xto find a patchlevel.h file in that same directory.  Everything is done from
Xthat top level directory--don't put any patchlevel.h or bugs directories in
Xyour subdirectories.  Each subdirectory has its own RCS directory though.
X
XPatpost, patsend and patftp may be used to post to Usenet, mail to someone,
Xor copy patches to your ftp directory.  They take a destination and a list
Xof patches to process.
X
XThose pat tools are an hopefully enhanced version of the tools that
Xcame with Larry Wall's dist 2.0. There are however a few new scripts:
X
X    - patclean, which checks in the mods and removes the working files.
X    - patcol, which restores the files removed by a patclean.
X    - patname, which sets a symbolic version number.
X
XHere is the way I am using the pat tools...
X
XFirst, I set up a MANIFEST.new file. If you are converting an existing
Xdistribution to use dist, the manifake script will convert a MANIFEST
Xinto a MANIFEST.new (removing the possible archive number column).
X
XThen I run packinit to modify the version number and set up things
Xcorrectly. The package is then ready to be placed under pat control.
XI make sure the file patchlevel.h is correctly set and I run:
X
X	patcil -f -a -s
X	touch patchlevel.h
X	find . -name "*~" -exec /bin/rm -f {} \; -print
X
XThere is a prototypical patchlevel.h file in this directory, so you
Xmight want to have a look at it.
X
X[If you are planning on using the mailagent to send the patches (and sort
Xyour mail -- that's its primary goal now), the you must make sure
Xthe patchelevel.h file is locatated in the root directory of your package.
XThe mailagent program is available separately, and was posted on the
Xcomp.sources.misc newsgroup]
X
XNow everything is ready. The distribution is frozen, the bugs directory
Xhas been created. I issue a makedist -v to create the distribution kits.
XEventually I set up the mailagent so that people can request for the
Xdistribution automatically. If I want to create a directory containing
Xthe lattest sources (to be able to `kit' them to someone using the kit
Xprogram -- posted to comp.sources.unix), I use:
X
X	makedist -c <package>-<version>@<patchlevel>
X
Xfor instance, for dist 2.9 at PL26
X
X	makedist -c dist-2.9@26
X
Xwhich I can then send to people directly with kit (which is NOT part
Xof this release).
X
XAs I receive patches or find some bugs, I edit the files and make the
Xmodifications. When I want to issue an official patch, I run:
X
X	pat -n
X
Xand one or more patches are issued. You can compress the patches in the
Xbugs subdirectory, since the mailpatch program knows about that. Also
Xpatindex will correctly uncompress them.
X
XWhen I need to clean up the distribution directory, I use:
X
X	patclean -a
X
Xwhich checks in every changes and removes the working files. The whole
Xset of working files can then be restored by:
X
X	patcol -a
X
XSometimes, I made a couple of modification and I don't want to issue
Xa patch right now. I then run:
X
X	patcil -a
X
Xwhich checks in the changes. You can run this as many times as you want,
Xbecause patcil will skip unchanged file and remembers the last time you
Xissued a patch.
X
XIf you are still using RCS 4.3, be sure you use makedist and not your
Xown shell archiver, as the $Locker symbol has an annoying expansion
Xwhich makes patch to fail when applyed. I'm not sure this was correctly
Xfixed with RCS 5.5 as I am not using it yet for various reasons.
X
XIn any case, if you are using the copyright expansion feature (i.e. the
Xstuffing of the COPYRIGHT token surrounded by '@' -- can't do it here
Xor it will get expanded...), then you must use makedist to make sure
Xthe copyright is properly written in all your files. Distributing files
Xwith an un-expanded COPYRIGHT token in them would be a disaster, since
Xthe patching system will also expand them before building a patch and
Xsome of your hunks may not apply correctly.
END_OF_FILE
  if test 5099 -ne `wc -c <'pat/README'`; then
    echo shar: \"'pat/README'\" unpacked with wrong size!
  fi
  # end of 'pat/README'
fi
echo shar: End of archive 11 \(of 28\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
